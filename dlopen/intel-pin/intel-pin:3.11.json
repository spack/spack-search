{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/secondary_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n   Test the scenario when Pin attaches to an application, using PIN_AttachProbed API,\n   which one of its secondary thread is a zombie thread .\n   Pin wouldn't attach to the zombie thread and wouldn't give a thread detach callbacks on detach\n   to the zombie thread.\n*/\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sstream>\n#include <fstream>\n#include <sys/wait.h>\n#include \"zombie_utils.h\"\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\nEXPORT_SYM bool AfterAttach1();\n\nconst char *imageToLoad;\n\npid_t zombieThreadPid;\n\npid_t parentPid;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts to execute.\nvoid* SecondaryThreadMain(void* v) \n{\n    void *handle = dlopen(imageToLoad, RTLD_LAZY); \n\n    if(!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    pthread_exit(0);\n    return NULL;\n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] Pin flags (e.g. -slow_asserts)\n//     >> zero or more flags possible\n// [3] \"-t\"\n// [4] tool\n// [5] imageName\n// [6] output file\n\nint main(int argc, char** argv)\n{\n    if(argc < 6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 4){      // added: -pid attachPid -probe -o NULL\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n    imageToLoad = argv[argc-2];     // argv[argc-2] is imageName\n    parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_SECONDARY_THREAD_ZOMBIE_IN_REATTACH);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n        fprintf(stderr, \"APP: tid of zombie: %d\\n\", (int)tid);\n        \n        while(1);\n    }\n    \n    if (child == 0)\n    {\n        // Inside child \n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        {\n            // Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", parentPid);\n\n            char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n            int args_count = 0;\n            int argv_count = 1;                          // to start from argv[1]...\n            args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n            args[args_count++] = (char*)\"-probe\";\n            args[args_count++] = (char*)\"-pid\";\n            args[args_count++] = attachPid;\n            while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n                args[args_count++] = argv[argv_count++];\n            }\n            args[args_count++] = argv[argv_count++];     // \"-t\"\n            args[args_count++] = argv[argv_count++];     // tool\n            argv_count++;                                // skip the imageName, not needed for the execv command\n            args[args_count++] = (char*)\"-o\";\n            args[args_count++] = argv[argv_count++];     // output file\n            args[args_count++] = NULL;                   // end\n            // Pin attaches to the application.\n            execv(argv[1], (char * const *)args);        // never returns\n            perror(\"execv failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\n#ifdef TARGET_LINUX\n\n#define DLL_SUFFIX \".so\"\n\n#elif defined(TARGET_MAC)\n\n#define DLL_SUFFIX \".dylib\"\n\n#endif\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll\" DLL_SUFFIX \", thread %ld\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/attachReattachThreadDetachCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <pthread.h>\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_INVALID_ARGS      // 4\n};\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] pin executable\n    [2] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [3] \"-t\"\n    [4] tool\n    [5] output file\n    [6] First imageName\n\t[7] Second imageName\n*/\nint main(int argc, char** argv)\n{\n    fprintf(stderr, \"Start main\\n\");\n    if(argc < 7)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 3){      // added: -pid attachPid -o NULL\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n\n    loop  = true;\n\n    int ret_val;\n    pthread_t h[NTHREADS];\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\t\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n        void *handle = dlopen(argv[argc-2], RTLD_LAZY); // argv[argc-2] is First imageName\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[argc-2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n        handle = dlopen(argv[argc-1], RTLD_LAZY);   // argv[argc-1] is Second imageName\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[argc-1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n    if ( child == 0 )\n    {\n        // Inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n        int args_count = 0;\n        int argv_count = 1;                          // to start from argv[1]...\n        args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];\n        }\n        args[args_count++] = argv[argv_count++];     // \"-t\"\n        args[args_count++] = argv[argv_count++];     // tool\n        args[args_count++] = (char*)\"-o\";\n        args[args_count++] = argv[argv_count++];     // output file\n        args[args_count++] = NULL;                   // end\n        execv(argv[1], (char * const *)args);        // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching Pin from running process on a Unix compatible system\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n\n#define NTHREADS 20\n\n#ifdef TARGET_MAC\n# define DLL_SUFFIX \".dylib\"\n#else\n# define DLL_SUFFIX \".so\"\n#endif\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/main_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n   Test the scenario where Pin tries to reattach to an application, using PIN_AttachProbed API,\n   when the main thread of the application is a zombie thread.\n   Pin wouldn't attach to the application in this scenario. \n   Instead, Pin will give a message to the user notifying why Pin didn't attach to the application and the\n   application will continue to run natively\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <fstream>\n#include <sstream>\n#include \"zombie_utils.h\"\n#include <string.h>\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n\nEXPORT_SYM bool AfterAttach1();\n\npid_t zombieThreadPid;\n\nconst char * fileName;\n\nconst char *imageToLoad;\n\nbool AfterAttach1()\n{\n    // Pin sets an analysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n// This function is invoked when the secondary thread starts execution.\nvoid* SecondaryThreadMain(void* v)\n{\n    // Wait until Pin notifies the application that it can't reattach to it since\n    // the main thread of the application is a zombie thread.\n    while(!NotifyUserPinUnableToAttach(fileName)) sleep(1);\n    pthread_exit(0);\n    return NULL;\n}\n\n// Expected argv arguments:\n// [1] pin executable\n// [2] Pin flags (e.g. -slow_asserts)\n//     >> zero or more flags possible\n// [3] \"-t\"\n// [4] tool\n// [5] imageName\n// [6] output file\nint main(int argc, char** argv)\n{\n    if(argc < 6)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE - 3){      // added: -probe -pid attachPid -o NULL, omitted: argv[0], imageName\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_INVALID_ARGS);\n    }\n    imageToLoad = argv[argc-2];     // argv[argc-2] is imageName\n    fileName = argv[argc-1];        // argv[argc-1] is output file\n    zombieThreadPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"Fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    { \n        // Pin sets an analysis function here to notify the application\n        // when Pin attaches to it in the first attach session.\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        NotifyTestType(TEST_TYPE_MAIN_THREAD_ZOMBIE_IN_REATTACH);\n\n        NotifyZombiePid(zombieThreadPid);\n\n        pthread_t tid;\n        pthread_create(&tid, NULL, SecondaryThreadMain, NULL);\n\n        // When the image is loaded into the memory,\n        // the tool instructs Pin to detach from the application.\n        void *handle = dlopen(imageToLoad, RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", imageToLoad, dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }  \n\n        // After calling to thread_exit(0) function, the main thread is going to become a zombie thread.\n        // Pin should not attach to the application.\n        // Instead, Pin should give a message to the user notifying why Pin didn't attach to the application.\n        pthread_exit(0);\n    }\n\n    if (child == 0)\n    {\n        // Inside child 1\n        pid_t second_child_pid = fork ();\n        \n        if (second_child_pid < 0)\n        {\n            perror(\"Fork failed while creating application process\");\n            exit(RES_FORK_FAILED);\n        }\n\n        if (second_child_pid > 0)\n        {\n            // Inside parent 2\n            waitpid(second_child_pid, 0, 0); // wait until Pin is injected to the application process.\n            exit(RES_SUCCESS);\n        }\n        else\n        {\n            //Inside child 2\n            char attachPid[MAX_SIZE];\n            snprintf(attachPid, MAX_SIZE , \"%d\", zombieThreadPid);\n\n            char* args[MAX_COMMAND_LINE_SIZE] = {NULL};  // arguments for execv command\n            int args_count = 0;\n            int argv_count = 1;                          // to start from argv[1]...\n            args[args_count++] = argv[argv_count++];     // by convention, first arg is the filename of the executed file (pin)\n            args[args_count++] = (char*)\"-probe\";\n            args[args_count++] = (char*)\"-pid\";\n            args[args_count++] = attachPid;\n            while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n                args[args_count++] = argv[argv_count++];\n            }\n            args[args_count++] = argv[argv_count++];     // \"-t\"\n            args[args_count++] = argv[argv_count++];     // tool\n            args[args_count++] = (char*)\"-o\";\n            argv_count++;                                // skip the imageName, not needed for the execv command\n            args[args_count++] = argv[argv_count++];     // output file\n            args[args_count++] = NULL;                   // end\n            // Pin  attaches to the application.\n            execv(argv[1], (char * const *)args);        // never returns\n            perror(\"execv failed while trying to attach Pin to the application\\n\");\n            exit(RES_EXEC_FAILED);\n        }\n    }\n\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/reattach_jit_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in signaled by the pintool (by replacing AppShouldExit()) that it should exit.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{\n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nextern \"C\" int AppShouldExit()\n{\n    return 0;\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{\n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n\n            //sleep(1);\n            dlclose(handle);\n        }\n        else\n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        }\n        number += 0.01;\n    }\n\n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    const unsigned int numOfSeconds = 5 * 60; // allow 5 minutes\n    unsigned int secondsRemaining = numOfSeconds;\n    for (; secondsRemaining && (!AppShouldExit()) ; --secondsRemaining)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n\n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }\n    if (secondsRemaining == 0)\n    {\n        fprintf(stderr, \"ERROR: The application ran for %u seconds without completion\\n\", numOfSeconds);\n        return 1;\n    }\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/AttachDetach/launchReattachThreadDetachCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n\n#define EXPORT_SYM extern \"C\"\n\n#define NTHREADS 20\n\n\nvolatile bool loop;\n\nEXPORT_SYM bool AfterAttach2();\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_INVALID_ARGS      // 2    \n};\n\n\n\nvoid * thread_func (void *arg)\n{    \n    while (loop)\n    {\n         sched_yield();\n    }\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1]\tFirst image to load\t\n    [2]\tSecond image to load\n*/\nint main (int argc, char *argv[])\n{\n    if(argc!=3)\n    {\n       fprintf(stderr, \"Not enough arguments\\n\" );\n       fflush(stderr);\n       exit(RES_INVALID_ARGS);\n    }\n\n    loop = true;\n\t\n    pthread_t h[NTHREADS];\n    int ret_val;\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        ret_val= pthread_create (&h[i], 0, thread_func, 0);\n        if(ret_val) \n        {\n            perror(\"ERROR, pthread_create failed\");\n            exit(1);\n        }\n    }\n\n\tvoid *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    \n\twhile(!AfterAttach2())\n    {\n        sleep(1);\n    }\n    \n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n\n    return RES_SUCCESS;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/MemTranslate/malloc_translation_app.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// The highest bit value in a pointer\n#define HIGHEST_BIT ((uintptr_t)1 << (8 * sizeof(void*) - 1))\n// Turn on the highest bit in a pointer\n#define MK_PTR(ptr) ((void*)(((uintptr_t)ptr) | HIGHEST_BIT))\n// Turn off the highest bit in a pointer\n#define STRIP_PTR(ptr) ((void*)((uintptr_t)ptr & ~HIGHEST_BIT))\n\n// Initial allocator buffer (see below for explnaition).\nstatic char initial_buf[1024*1024];\nstatic size_t initial_buf_idx = 0;\n\nstatic void* (*libc_malloc)(size_t) = NULL;\nstatic void* (*libc_calloc)(size_t, size_t) = NULL;\nstatic void* (*libc_realloc)(void *ptr, size_t) = NULL;\nstatic void (*libc_free)(void*) = NULL;\n\n/*\n * Initialize all malloc related symbols from libc\n */\nvoid __attribute__((constructor)) init()\n{\n    libc_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    libc_calloc = dlsym(RTLD_NEXT, \"calloc\");\n    libc_realloc = dlsym(RTLD_NEXT, \"realloc\");\n    libc_free = dlsym(RTLD_NEXT, \"free\");\n}\n\n/*********************************************************\n * Below we implement an initial allocator.\n * The first allocated bytes cannot be allocate with libc's\n * memory allocation function.\n * This is merely because calling dlsym() in the loader, to\n * get the address of libc's memory allocation function,\n * causes the loader to call calloc() (the overriden version\n * of calloc()) and if we call dlsym() in calloc() it will\n * eventually cause an infinite recursion.\n * To overcome this, we implement a simple allocator here\n * that allocates the first bytes of the program from\n * the static buffer initial_buf[].\n *********************************************************/\nvoid *initial_malloc(size_t size)\n{\n    void* ret;\n    if (sizeof(initial_buf) < initial_buf_idx + size + sizeof(size_t))\n    {\n        return NULL;\n    }\n    *((size_t*)&initial_buf[initial_buf_idx]) = size;\n    ret = (void*)&initial_buf[initial_buf_idx + sizeof(size_t)];\n    initial_buf_idx += ((size + 2 * sizeof(size_t) - 1) / sizeof(size_t)) * sizeof(size_t);\n    return ret;\n}\n\nsize_t initial_free(void* ptr)\n{\n    if ((ptr >= (void*)initial_buf) && (ptr < (void*)&initial_buf[initial_buf_idx]))\n    {\n        return *((size_t*)ptr - 1);\n    }\n    return 0;\n}\n\n/*********************************************************\n * Wrapper functions for libc memory allocation functions.\n * Here we translate the memory addresses in and out of\n * memory allocation function so the highest bit in the\n * memory address will be turn on.\n *********************************************************/\nvoid *malloc(size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_malloc(size));\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(nmemb*size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_calloc(nmemb, size));\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    size_t old_size;\n    if (0 != (old_size = initial_free(STRIP_PTR(ptr))))\n    {\n        void* new_ptr = malloc(size);\n        memcpy(STRIP_PTR(new_ptr), STRIP_PTR(ptr), size<old_size?size:old_size);\n        return new_ptr;\n    }\n    return MK_PTR(libc_realloc(STRIP_PTR(ptr), size));\n}\n\nvoid free(void *ptr)\n{\n    if (0 < initial_free(STRIP_PTR(ptr)))\n    {\n        return;\n    }\n    return libc_free(STRIP_PTR(ptr));\n}\n\n/*\n * This simple program just loads the library which its filename was\n * provided ain the command line arguments\n */\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n\n    printf(\"Application finished successfully!\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Replay/ia32_cross_os_replay.reference": "[ 0]+ /disk/PinTools/Utils/obj-ia32/cp-pin    \nFunction 'main' loaded at 8048d90\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n[ 1]+ /lib/ld-linux.so.2                      \nFunction 'rtld_lock_default_unlock_recursive' loaded at 555558c0\nFunction 'relocate_doit' loaded at 55556770\nFunction 'fillin_rpath' loaded at 5555a3c0\nFunction 'decompose_rpath' loaded at 5555c9f0\nFunction 'do_lookup_x' loaded at 5555e380\nFunction '_dl_map_object_deps' loaded at 55560e40\nFunction '_dl_sort_fini' loaded at 55562ba0\nFunction 'match_symbol' loaded at 55563930\nFunction '_dl_next_tls_modid' loaded at 55564e10\nFunction '_dl_tls_setup' loaded at 55565940\nFunction '_dl_runtime_resolve' loaded at 55567930\nFunction '__assert_fail' loaded at 55568870\nFunction 'calloc' loaded at 55568f60\nFunction 'profil_counter' loaded at 55569560\nFunction '__lseek' loaded at 555698d0\nFunction '__madvise' loaded at 55569e50\nFunction 'strlen' loaded at 5556a270\nFunction '__i686.get_pc_thunk.cx' loaded at 5556ae47\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n[ 2]+ /usr/lib/libstdc++.so.6                 \nFunction '_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' loaded at 56d760f0\nFunction '_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' loaded at 56d774d0\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' loaded at 56d78800\nFunction '_ZNSt7codecvtIcc11__mbstate_tEC1Ej' loaded at 56d78c10\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' loaded at 56d78f70\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' loaded at 56d791c0\nFunction '_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d79900\nFunction '_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' loaded at 56d7a7f0\nFunction '_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' loaded at 56d7bdf0\nFunction '_ZNSt5ctypeIcED2Ev' loaded at 56d7c340\nFunction '_ZNSt12ctype_bynameIwEC2EPKcj' loaded at 56d7c880\nFunction '_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' loaded at 56d7da10\nFunction '_ZSt18__throw_bad_typeidv' loaded at 56d7de60\nFunction '_ZNSt12out_of_rangeD0Ev' loaded at 56d7e0f0\nFunction '_ZSt23__throw_underflow_errorPKc' loaded at 56d7e480\nFunction '_ZNSt8ios_base6xallocEv' loaded at 56d7edd0\nFunction '_ZNSt8ios_base7failureC1ERKSs' loaded at 56d7f3c0\nFunction '_ZNSt8ios_base7_M_initEv' loaded at 56d808d0\nFunction '_ZNSt6localeC2ERKS_' loaded at 56d80b10\nFunction '_ZNSt6locale5_ImplD2Ev' loaded at 56d81310\nFunction '_ZNSt6locale5_ImplC2Ej' loaded at 56d81e00\nFunction '_ZNSt6localeC2ERKS_S1_i' loaded at 56d84170\nFunction '_ZNSt11logic_errorC2ERKSs' loaded at 56d86830\nFunction '_ZNSt13runtime_errorC2ERKSs' loaded at 56d86af0\nFunction '_ZNSt13runtime_errorD0Ev' loaded at 56d86e20\nFunction '_ZNSt12strstreambuf7_M_freeEPc' loaded at 56d870e0\nFunction '_ZNSt12strstreambuf9underflowEv' loaded at 56d87330\nFunction '_ZNSt12strstreambufC2EPaiS0_' loaded at 56d87c80\nFunction '_ZNSt12strstreambufC1EPKhi' loaded at 56d88450\nFunction '_ZNSt10ostrstreamD2Ev' loaded at 56d88cb0\nFunction '_ZNSt10istrstreamD1Ev' loaded at 56d89480\nFunction '_ZNSt9strstreamD0Ev' loaded at 56d89bf0\nFunction '_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' loaded at 56d8a2d0\nFunction '_ZNSaIwED1Ev' loaded at 56d8a8c0\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' loaded at 56d8b6c0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' loaded at 56d8b8b0\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' loaded at 56d8be20\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' loaded at 56d8d060\nFunction '_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' loaded at 56d8e080\nFunction '_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' loaded at 56d8e980\nFunction '_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' loaded at 56d8f250\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' loaded at 56d8f860\nFunction '_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' loaded at 56d8fe60\nFunction '_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' loaded at 56d904d0\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' loaded at 56d90d40\nFunction '_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' loaded at 56d91430\nFunction '_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' loaded at 56d91dc0\nFunction '_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' loaded at 56d92260\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' loaded at 56d93680\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' loaded at 56d938f0\nFunction '_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' loaded at 56d93c00\nFunction '_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' loaded at 56d93fe0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' loaded at 56d941d0\nFunction '_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' loaded at 56d944a0\nFunction '_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' loaded at 56d94f60\nFunction '_ZNSdC1Ev' loaded at 56d95280\nFunction '_ZNSirsEPFRSt8ios_baseS0_E' loaded at 56d954d0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' loaded at 56d95600\nFunction '_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' loaded at 56d958a0\nFunction '_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' loaded at 56d95b40\nFunction '_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' loaded at 56d95e20\nFunction '_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' loaded at 56d96650\nFunction '_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56d96fa0\nFunction '_ZNSirsERy' loaded at 56d97a40\nFunction '_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' loaded at 56d987a0\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' loaded at 56d99390\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' loaded at 56d99e80\nFunction '_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' loaded at 56d9abf0\nFunction '_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' loaded at 56d9c540\nFunction '_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' loaded at 56d9c6c0\nFunction '_ZNKSt10moneypunctIcLb1EE10pos_formatEv' loaded at 56d9c890\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56d9cb50\nFunction '_ZNSt16__numpunct_cacheIcEC1Ej' loaded at 56d9cda0\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' loaded at 56d9d200\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' loaded at 56d9d5f0\nFunction '_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' loaded at 56d9d850\nFunction '_ZNKSt8messagesIcE4openERKSsRKSt6locale' loaded at 56d9db80\nFunction '_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' loaded at 56d9dfc0\nFunction '_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' loaded at 56d9e1e0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' loaded at 56d9e3f0\nFunction '_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' loaded at 56d9e810\nFunction '_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' loaded at 56d9ebb0\nFunction '_ZNSt7collateIcEC2Ej' loaded at 56d9ef10\nFunction '_ZNSt8messagesIcED1Ev' loaded at 56d9f290\nFunction '_ZNSt16__numpunct_cacheIcED2Ev' loaded at 56d9f6d0\nFunction '_ZNSt15numpunct_bynameIcED2Ev' loaded at 56d9fb30\nFunction '_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56d9ffb0\nFunction '_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' loaded at 56da0310\nFunction '_ZNSt15messages_bynameIcEC2EPKcj' loaded at 56da07c0\nFunction '_ZNSt11__timepunctIcEC2Ej' loaded at 56da0fc0\nFunction '_ZNKSt8numpunctIcE12do_falsenameEv' loaded at 56da12f0\nFunction '_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' loaded at 56da17f0\nFunction '_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' loaded at 56da1c80\nFunction '_ZNSt15numpunct_bynameIcEC1EPKcj' loaded at 56da2180\nFunction '_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' loaded at 56da3b00\nFunction '_ZNKSt7collateIcE12do_transformEPKcS2_' loaded at 56da68d0\nFunction '_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dac390\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' loaded at 56daeb10\nFunction '_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' loaded at 56db0310\nFunction '_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' loaded at 56db2f10\nFunction '_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' loaded at 56db5520\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' loaded at 56db5a10\nFunction '_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' loaded at 56db5ba0\nFunction '_ZNSoC1Ev' loaded at 56db5e20\nFunction '_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' loaded at 56db6470\nFunction '_ZNSoD2Ev' loaded at 56db6a40\nFunction '_ZNSolsEs' loaded at 56db6d50\nFunction '_ZNSo5writeEPKci' loaded at 56db7af0\nFunction '_ZNSolsEx' loaded at 56db8a50\nFunction '_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' loaded at 56db9e90\nFunction '_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' loaded at 56dbb170\nFunction '_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' loaded at 56dbba10\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' loaded at 56dbbd40\nFunction '_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' loaded at 56dbc7f0\nFunction '_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' loaded at 56dbcc90\nFunction '_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' loaded at 56dbd7f0\nFunction '_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' loaded at 56dbdfc0\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' loaded at 56dbe670\nFunction '_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' loaded at 56dbee50\nFunction '_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' loaded at 56dbf9a0\nFunction '_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' loaded at 56dc0180\nFunction '_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' loaded at 56dc0a90\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc12e0\nFunction '_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' loaded at 56dc1420\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' loaded at 56dc14f0\nFunction '_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' loaded at 56dc1680\nFunction '_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' loaded at 56dc1740\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' loaded at 56dc1a40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' loaded at 56dc1ce0\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' loaded at 56dc1e40\nFunction '_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' loaded at 56dc2150\nFunction '_ZNKSs7_M_dataEv' loaded at 56dc26e0\nFunction '_ZNKSs4sizeEv' loaded at 56dc2820\nFunction '_ZNSs4_Rep15_M_set_sharableEv' loaded at 56dc28e0\nFunction '_ZNKSs5emptyEv' loaded at 56dc2d70\nFunction '_ZNKSs16find_last_not_ofEcj' loaded at 56dc3010\nFunction '_ZNKSs13find_first_ofEcj' loaded at 56dc33e0\nFunction '_ZNKSs4rendEv' loaded at 56dc3740\nFunction '_ZNKSs7compareEjjRKSs' loaded at 56dc3b60\nFunction '_ZNSsC2EPKcjRKSaIcE' loaded at 56dc4040\nFunction '_ZNSsC1IPcEET_S1_RKSaIcE' loaded at 56dc4470\nFunction '_ZNSs6appendEPKcj' loaded at 56dc4a00\nFunction '_ZNSs6assignEPKc' loaded at 56dc5100\nFunction '_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' loaded at 56dc54e0\nFunction '_ZNSs7_M_leakEv' loaded at 56dc59b0\nFunction '_ZNSsD2Ev' loaded at 56dc5d10\nFunction '_ZNSs7replaceEjjPKc' loaded at 56dc63b0\nFunction '_ZNSt8valarrayIjED2Ev' loaded at 56dc6700\nFunction '_ZNKSt10moneypunctIwLb0EE13positive_signEv' loaded at 56dc6dc0\nFunction '_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' loaded at 56dc6f70\nFunction '_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' loaded at 56dc7100\nFunction '_ZNKSt8numpunctIwE13decimal_pointEv' loaded at 56dc74b0\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' loaded at 56dc76f0\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' loaded at 56dc7b10\nFunction '_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' loaded at 56dc7ea0\nFunction '_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' loaded at 56dc8130\nFunction '_ZNKSt8messagesIwE8do_closeEi' loaded at 56dc8430\nFunction '_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' loaded at 56dc87b0\nFunction '_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' loaded at 56dc89d0\nFunction '_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' loaded at 56dc8cb0\nFunction '_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' loaded at 56dc9110\nFunction '_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' loaded at 56dc9470\nFunction '_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' loaded at 56dc97d0\nFunction '_ZNSt15messages_bynameIwED0Ev' loaded at 56dc9bb0\nFunction '_ZNSt18__moneypunct_cacheIwLb1EED1Ev' loaded at 56dca010\nFunction '_ZNSt17moneypunct_bynameIwLb1EED1Ev' loaded at 56dca3f0\nFunction '_ZNSt8numpunctIwEC1EP15__locale_structj' loaded at 56dca870\nFunction '_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' loaded at 56dcabf0\nFunction '_ZNSt17__timepunct_cacheIwEC1Ej' loaded at 56dcb110\nFunction '_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' loaded at 56dcb8b0\nFunction '_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' loaded at 56dcbe10\nFunction '_ZNSt8messagesIwEC1EP15__locale_structPKcj' loaded at 56dcc1f0\nFunction '_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' loaded at 56dcc8d0\nFunction '_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' loaded at 56dccd40\nFunction '_ZNSt14collate_bynameIwEC2EPKcj' loaded at 56dcf9b0\nFunction '_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' loaded at 56dd1030\nFunction '_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' loaded at 56dd4110\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' loaded at 56dd7b60\nFunction '_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' loaded at 56dda050\nFunction '_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' loaded at 56ddcfc0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' loaded at 56ddd810\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' loaded at 56ddd8e0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' loaded at 56dddca0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' loaded at 56dddf40\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' loaded at 56dde330\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' loaded at 56dde6a0\nFunction '_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' loaded at 56dde9c0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' loaded at 56ddefa0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' loaded at 56ddf3b0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' loaded at 56ddf8d0\nFunction '_ZNSbIwSt11char_traitsIwESaIwEED2Ev' loaded at 56ddfe30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' loaded at 56de0420\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' loaded at 56de0910\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' loaded at 56de0c30\nFunction '_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' loaded at 56de1210\nFunction '_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' loaded at 56de15e0\nFunction '_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' loaded at 56de1dc0\nFunction '_ZNKSt5ctypeIwE10do_toupperEw' loaded at 56de21e0\nFunction '_ZNSt10moneypunctIwLb0EED2Ev' loaded at 56de2ab0\nFunction '_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' loaded at 56de3090\nFunction '_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' loaded at 56de4390\nFunction '_ZNSt12__basic_fileIcE4syncEv' loaded at 56de5a80\nFunction '_ZNSt12__basic_fileIcE6xsgetnEPci' loaded at 56de5f30\nFunction '_ZdlPvRKSt9nothrow_t' loaded at 56de62c0\nFunction '__cxa_begin_catch' loaded at 56de66c0\nFunction '__cxa_call_unexpected' loaded at 56de6d30\nFunction '__cxa_guard_release' loaded at 56de7630\nFunction '__cxa_pure_virtual' loaded at 56de7970\nFunction '_ZN10__cxxabiv117__class_type_infoD0Ev' loaded at 56de7b30\nFunction '_ZNSt10bad_typeidD1Ev' loaded at 56de7d50\nFunction '_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' loaded at 56de8060\nFunction '_ZN10__cxxabiv117__pbase_type_infoD2Ev' loaded at 56de8a60\nFunction '_ZN10__cxxabiv120__function_type_infoD0Ev' loaded at 56de8c70\nFunction '_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' loaded at 56de8ef0\nFunction '__cxa_vec_new' loaded at 56de95e0\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n[ 3]+ /lib/libm.so.6                          \nFunction '__i686.get_pc_thunk.bx' loaded at 56e2e4c7\nFunction 'fegetenv' loaded at 56e30a90\nFunction '__ieee754_asin' loaded at 56e30db0\nFunction '__ieee754_y0' loaded at 56e314e0\nFunction '__ieee754_log10' loaded at 56e32c10\nFunction 'cbrt' loaded at 56e335f0\nFunction 'logb' loaded at 56e340d0\nFunction 'asin' loaded at 56e34840\nFunction 'hypot' loaded at 56e34e30\nFunction 'log10' loaded at 56e35560\nFunction 'nan' loaded at 56e35b00\nFunction 'creal' loaded at 56e35f10\nFunction 'csin' loaded at 56e36b80\nFunction 'clog10' loaded at 56e37d60\nFunction '__finite' loaded at 56e382b0\nFunction '__ieee754_atan2f' loaded at 56e386d0\nFunction 'ponef' loaded at 56e38ee0\nFunction '__ieee754_remainderf' loaded at 56e3a280\nFunction 'cbrtf' loaded at 56e3ab60\nFunction 'logbf' loaded at 56e3b4d0\nFunction 'asinf' loaded at 56e3b9e0\nFunction 'hypotf' loaded at 56e3bff0\nFunction 'log10f' loaded at 56e3c6c0\nFunction 'nanf' loaded at 56e3cc50\nFunction 'crealf' loaded at 56e3cf60\nFunction 'csinf' loaded at 56e3dab0\nFunction 'clog10f' loaded at 56e3e9d0\nFunction 'finitef' loaded at 56e3ee00\nFunction '__ieee754_atan2l' loaded at 56e3f320\nFunction 'pone' loaded at 56e3fff0\nFunction '__ieee754_remainderl' loaded at 56e41730\nFunction 'cbrtl' loaded at 56e41ca0\nFunction 'logbl' loaded at 56e42800\nFunction 'atan2l' loaded at 56e42db0\nFunction 'y0l' loaded at 56e43420\nFunction 'powl' loaded at 56e43b90\nFunction 'truncl' loaded at 56e44180\nFunction 'cabsl' loaded at 56e444c0\nFunction 'ctanl' loaded at 56e45540\nFunction 'fmal' loaded at 56e466c0\nFunction 'copysignl' loaded at 56e46ae0\nFunction '__divdc3' loaded at 56e48190\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n[ 4]+ /lib/libgcc_s.so.1                      \nFunction '__ashldi3' loaded at 56e5a8e0\nFunction '__subvsi3' loaded at 56e5abe0\nFunction '__ctzdi2' loaded at 56e5b030\nFunction '__mulxc3' loaded at 56e5bd70\nFunction '__fixdfdi' loaded at 56e5d020\nFunction '__udivmoddi4' loaded at 56e5d8e0\nFunction '_Unwind_GetGR' loaded at 56e5dcd0\nFunction '__register_frame_info' loaded at 56e60260\nFunction '.fini' loaded at 56e62104\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n[ 5]+ /lib/libc.so.6                          \nFunction 'gnu_get_libc_version' loaded at 56e79980\nFunction '__divdi3' loaded at 56e79ee0\nFunction '__gconv_close' loaded at 56e7adc0\nFunction '__gconv_find_transform' loaded at 56e7bab0\nFunction 'add_alias' loaded at 56e7c180\nFunction '__gconv_transform_ascii_internal' loaded at 56e7e080\nFunction '__gconv_translit_find' loaded at 56e81e20\nFunction '__gconv_lookup_cache' loaded at 56e82780\nFunction '_L_unlock_996' loaded at 56e838fc\nFunction 'rangecmp' loaded at 56e84640\nFunction '__duplocale' loaded at 56e85ad0\nFunction '__collseq_table_lookup' loaded at 56e85f30\nFunction 'isdigit' loaded at 56e86400\nFunction '__isascii_l' loaded at 56e866a0\nFunction 'ispunct_l' loaded at 56e86810\nFunction 'set_binding_values' loaded at 56e869d0\nFunction '__dcigettext' loaded at 56e87a10\nFunction 'dcngettext' loaded at 56e88220\nFunction '_nl_expand_alias' loaded at 56e89d40\nFunction 'new_exp_2' loaded at 56e8a920\nFunction 'finite' loaded at 56e8bd40\nFunction 'copysignf' loaded at 56e8c0f0\nFunction 'modfl' loaded at 56e8c3b0\nFunction '__libc_longjmp' loaded at 56e8c810\nFunction 'sigpending' loaded at 56e8cd90\nFunction 'sigpause' loaded at 56e8d1f0\nFunction 'sigaddset' loaded at 56e8d5a0\nFunction '__libc_current_sigrtmax_private' loaded at 56e8d8f0\nFunction 'sigset' loaded at 56e8de10\nFunction '_quicksort' loaded at 56e8e360\nFunction '_L_lock_22' loaded at 56e8f45a\nFunction 'exit' loaded at 56e8f530\nFunction 'div' loaded at 56e8f9d0\nFunction 'initstate' loaded at 56e8fef0\nFunction 'setstate_r' loaded at 56e90070\nFunction 'mrand48' loaded at 56e90610\nFunction 'jrand48_r' loaded at 56e908d0\nFunction 'strtoll' loaded at 56e90ca0\nFunction 'strtoull_l' loaded at 56e92390\nFunction '__strtof_l' loaded at 56e948e0\nFunction 'do_system' loaded at 56e99720\nFunction 'realpath' loaded at 56e99cf0\nFunction '__xpg_basename' loaded at 56e9b780\nFunction 'wcstoimax' loaded at 56e9c020\nFunction '__mpn_add_n' loaded at 56e9c4a0\nFunction '__mpn_impn_sqr_n_basecase' loaded at 56e9cfa0\nFunction '__mpn_construct_double' loaded at 56e9ddf0\nFunction '_itowa' loaded at 56e9e690\nFunction '_L_unlock_11056' loaded at 56ea35aa\nFunction 'printf_size_info' loaded at 56ea77b0\nFunction 'group_number' loaded at 56ea8220\nFunction 'vfscanf' loaded at 56eb2050\nFunction 'perror_internal' loaded at 56eb6cd0\nFunction '__path_search' loaded at 56eb7770\nFunction 'ftrylockfile' loaded at 56eb7ea0\nFunction '_IO_file_doallocate' loaded at 56eb8b50\nFunction '_L_unlock_161' loaded at 56eb9245\nFunction '__fopen_internal' loaded at 56eb9690\nFunction '_L_lock_41' loaded at 56eb9bdc\nFunction '_L_unlock_185' loaded at 56eb9ecf\nFunction '_L_lock_47' loaded at 56eba57b\nFunction '_IO_proc_close' loaded at 56ebaa70\nFunction '_L_unlock_110' loaded at 56ebb13e\nFunction '_IO_setbuffer' loaded at 56ebb4a0\nFunction '_L_unlock_95' loaded at 56ebb894\nFunction '_L_unlock_105' loaded at 56ebbda2\nFunction 'getwchar' loaded at 56ebc020\nFunction '_L_lock_43' loaded at 56ebc4e9\nFunction 'putwc' loaded at 56ebc940\nFunction '_L_unlock_81' loaded at 56ebcc61\nFunction 'vswprintf' loaded at 56ebcf20\nFunction '_IO_sungetwc' loaded at 56ebd360\nFunction 'save_for_wbackup' loaded at 56ebd7c0\nFunction '_IO_wstr_finish' loaded at 56ebe140\nFunction '_IO_wdo_write' loaded at 56ebf2a0\nFunction 'do_out' loaded at 56ebfb00\nFunction '_L_lock_29' loaded at 56ec0220\nFunction '_L_lock_30' loaded at 56ec04ae\nFunction '_L_lock_29' loaded at 56ec08df\nFunction '_L_lock_30' loaded at 56ec0c7e\nFunction '_IO_strn_overflow' loaded at 56ec1080\nFunction 'ftello' loaded at 56ec1670\nFunction 'ftello64' loaded at 56ec1b60\nFunction '__fpending' loaded at 56ec1e00\nFunction '_L_unlock_17' loaded at 56ec25f2\nFunction '_L_lock_29' loaded at 56ec2814\nFunction '_IO_file_sync_mmap' loaded at 56ec2d30\nFunction '_IO_do_write' loaded at 56ec3a10\nFunction '_IO_file_setbuf_mmap' loaded at 56ec44a0\nFunction 'flush_cleanup' loaded at 56ec4fa0\nFunction '_IO_sgetn' loaded at 56ec55a0\nFunction '_IO_adjust_column' loaded at 56ec5960\nFunction '_IO_default_seek' loaded at 56ec5fc0\nFunction '_IO_list_lock' loaded at 56ec6070\nFunction '_IO_default_doallocate' loaded at 56ec67e0\nFunction '_L_unlock_280' loaded at 56ec6c3e\nFunction '_L_lock_1784' loaded at 56ec6cca\nFunction '_IO_str_pbackfail' loaded at 56ec6f60\nFunction '__failing_morecore' loaded at 56ec75a0\nFunction 'ptmalloc_init' loaded at 56ec7ef0\nFunction 'cfree' loaded at 56ec91a0\nFunction 'realloc_check' loaded at 56ecaaa0\nFunction 'realloc_hook_ini' loaded at 56ecbad0\nFunction '_L_unlock_2466' loaded at 56ecc04a\nFunction '_L_unlock_4424' loaded at 56ecc0e2\nFunction '_L_unlock_8320' loaded at 56ecc17a\nFunction '_L_lock_9316' loaded at 56ecc20f\nFunction '_L_unlock_9886' loaded at 56ecc29b\nFunction '_L_unlock_10772' loaded at 56ecc327\nFunction 'mprobe' loaded at 56ecc510\nFunction 'mtrace' loaded at 56eccc10\nFunction '_L_lock_751' loaded at 56ecd4f3\nFunction '_obstack_memory_used' loaded at 56ecd8f0\nFunction '__strdup' loaded at 56ecdfd0\nFunction 'strpbrk' loaded at 56ece820\nFunction 'bcmp' loaded at 56ecf180\nFunction 'ffsll' loaded at 56ecfd90\nFunction '_wordcopy_fwd_aligned' loaded at 56ed0310\nFunction 'rawmemchr' loaded at 56ed0b90\nFunction 'argz_insert' loaded at 56ed1180\nFunction 'envz_add' loaded at 56ed1970\nFunction '__memset_gcn_by4' loaded at 56ed3700\nFunction '__strncat_g' loaded at 56ed3950\nFunction '__strcspn_g' loaded at 56ed3b40\nFunction '__strcspn_c1' loaded at 56ed3f70\nFunction '__strsep_3c' loaded at 56ed4270\nFunction '__xpg_strerror_r' loaded at 56ed4680\nFunction 'wcsncpy' loaded at 56ed4aa0\nFunction 'wmemset' loaded at 56ed4f80\nFunction 'mbsrtowcs' loaded at 56ed58e0\nFunction 'wcstoll' loaded at 56ed6550\nFunction '____wcstol_l_internal' loaded at 56ed6870\nFunction '____wcstod_l_internal' loaded at 56ed8040\nFunction 'wcscoll' loaded at 56ede440\nFunction '_nl_cleanup_ctype' loaded at 56ee0000\nFunction 'asctime' loaded at 56ee0c60\nFunction 'guess_time_tm' loaded at 56ee0eb0\nFunction '__tzstring' loaded at 56ee1be0\nFunction '_L_unlock_2123' loaded at 56ee287f\nFunction 'ftime' loaded at 56ee39c0\nFunction 'memcpy_uppcase' loaded at 56ee68e0\nFunction '_nl_init_alt_digit' loaded at 56eeab60\nFunction '_nl_cleanup_time' loaded at 56eeafe0\nFunction '_L_unlock_119' loaded at 56eeb4ac\nFunction 'alphasort' loaded at 56eeb840\nFunction '_L_lock_246' loaded at 56eebee0\nFunction '_L_lock_27' loaded at 56eec50a\nFunction 'getgrgid' loaded at 56eecca0\nFunction '_L_unlock_290' loaded at 56eed201\nFunction 'getgrgid_r' loaded at 56eed4e0\nFunction '_L_unlock_116' loaded at 56eee03e\nFunction '_L_lock_25' loaded at 56eee5d6\nFunction '_L_unlock_233' loaded at 56eee8bd\nFunction 'times' loaded at 56eef2d0\nFunction 'pause' loaded at 56eefb10\nFunction 'execle' loaded at 56ef0120\nFunction 'getegid' loaded at 56ef09a0\nFunction 'getsid' loaded at 56ef0c60\nFunction 'setlogin' loaded at 56ef1140\nFunction 'handle_intel' loaded at 56ef1a00\nFunction 'collated_compare' loaded at 56ef3be0\nFunction 'end_pattern' loaded at 56ef5f50\nFunction 're_node_set_contains' loaded at 56efa780\nFunction 'find_subexp_node' loaded at 56efad00\nFunction 'lower_subexps' loaded at 56efb590\nFunction 'free_dfa_content' loaded at 56efb9d0\nFunction 'check_arrival_expand_ecl' loaded at 56efc4b0\nFunction 're_node_set_init_copy' loaded at 56efd1f0\nFunction 'build_upper_buffer' loaded at 56efe6f0\nFunction 'check_arrival' loaded at 56efffa0\nFunction 'parse_bracket_exp' loaded at 56f02cf0\nFunction 'set_regs' loaded at 56f05f40\nFunction 're_exec' loaded at 56f08f60\nFunction '_getopt_long_only_r' loaded at 56f0a650\nFunction '__sched_get_priority_min' loaded at 56f0a940\nFunction 'in6aicmp' loaded at 56f0ad30\nFunction '_L_lock_9088' loaded at 56f0e70d\nFunction 'eval_expr' loaded at 56f0ed40\nFunction 'pread' loaded at 56f12850\nFunction 'posix_spawn_file_actions_addclose' loaded at 56f12cb0\nFunction 'posix_spawnattr_setpgroup' loaded at 56f12fa0\nFunction 'posix_spawnattr_setschedparam' loaded at 56f13760\nFunction '__xstat64' loaded at 56f13b70\nFunction 'fstatfs64' loaded at 56f143f0\nFunction 'mkdir' loaded at 56f14a00\nFunction '__close' loaded at 56f15160\nFunction '__fcntl_nocancel' loaded at 56f15750\nFunction 'creat64' loaded at 56f15cc0\nFunction 'getttyname' loaded at 56f162f0\nFunction 'readlinkat' loaded at 56f17050\nFunction 'object_compare' loaded at 56f184b0\nFunction 'fts_palloc' loaded at 56f19850\nFunction 'posix_fadvise' loaded at 56f1afc0\nFunction '__internal_statvfs' loaded at 56f1bea0\nFunction 'tcsetpgrp' loaded at 56f1c4c0\nFunction 'setrlimit64' loaded at 56f1c8f0\nFunction '__sbrk' loaded at 56f1cdb0\nFunction 'setregid' loaded at 56f1d440\nFunction '___newselect_nocancel' loaded at 56f1d84a\nFunction 'sethostid' loaded at 56f1de50\nFunction 'usleep' loaded at 56f1e150\nFunction 'getfsspec' loaded at 56f1e570\nFunction '_L_lock_1062' loaded at 56f1f144\nFunction 'ftruncate64' loaded at 56f1f5c0\nFunction 'endusershell' loaded at 56f1fcc0\nFunction 'openlog_internal' loaded at 56f20390\nFunction '_L_lock_1085' loaded at 56f20c4c\nFunction 'madvise' loaded at 56f21070\nFunction 'fcvt_r' loaded at 56f21420\nFunction 'hsearch_r' loaded at 56f22060\nFunction 'tsearch' loaded at 56f22a40\nFunction 'errx' loaded at 56f23040\nFunction 'dirname' loaded at 56f238b0\nFunction 'listxattr' loaded at 56f23d30\nFunction 'vm86' loaded at 56f24080\nFunction 'gnu_dev_major' loaded at 56f24450\nFunction 'capget' loaded at 56f24730\nFunction 'inotify_add_watch' loaded at 56f24a30\nFunction 'prctl' loaded at 56f24d60\nFunction 'getpeername' loaded at 56f250c0\nFunction 'setsockopt' loaded at 56f25500\nFunction '__libc_msgsnd' loaded at 56f259a0\nFunction 'shmget' loaded at 56f25f10\nFunction 'pc_to_index' loaded at 56f26b80\nFunction 'iswxdigit' loaded at 56f27410\nFunction 'iswpunct' loaded at 56f27c50\nFunction 'iswalpha_l' loaded at 56f28270\nFunction '__towlower_l' loaded at 56f28880\nFunction '_L_unlock_111' loaded at 56f28cd6\nFunction 'getspent_r' loaded at 56f29440\nFunction '_nss_files_parse_spent' loaded at 56f298b0\nFunction '_L_lock_34' loaded at 56f2a3eb\nFunction '__argp_fmtstream_update' loaded at 56f2a500\nFunction '__argp_fmtstream_puts' loaded at 56f2af00\nFunction 'until_short' loaded at 56f2b2d0\nFunction 'usage_argful_short_opt' loaded at 56f2c270\nFunction 'argp_help' loaded at 56f2e4a0\nFunction 'argp_usage' loaded at 56f2f580\nFunction 'pthread_attr_setschedparam' loaded at 56f2f7d0\nFunction 'pthread_cond_signal' loaded at 56f2fa10\nFunction 'pthread_self' loaded at 56f2fc50\nFunction '_L_lock_116' loaded at 56f2ff5a\nFunction 'inet_ntop4' loaded at 56f30490\nFunction 'net_mask' loaded at 56f30ec0\nFunction 'skip_ws' loaded at 56f324c0\nFunction '_L_unlock_68' loaded at 56f3306e\nFunction '__nss_configure_lookup' loaded at 56f33a70\nFunction '__nss_getent' loaded at 56f34000\nFunction '__nss_group_lookup' loaded at 56f34eb0\nFunction '__backtrace' loaded at 56f35490\nFunction '__sprintf_chk' loaded at 56f35e60\nFunction '_L_unlock_99' loaded at 56f362af\nFunction '_L_unlock_302' loaded at 56f36680\nFunction '__pread64_chk' loaded at 56f36be0\nFunction '__wmemcpy_chk' loaded at 56f36ee0\nFunction '__vswprintf_chk' loaded at 56f37220\nFunction '_L_lock_35' loaded at 56f376ca\nFunction '_L_unlock_247' loaded at 56f379a7\nFunction '__wcsnrtombs_chk' loaded at 56f37c70\nFunction '_L_unlock_63' loaded at 56f38084\nFunction '__h_errno_location' loaded at 56f38530\nFunction '_L_unlock_149' loaded at 56f38ddb\nFunction '_L_unlock_73' loaded at 56f396ee\nFunction '_L_lock_28' loaded at 56f39c55\nFunction '_L_lock_148' loaded at 56f39fee\nFunction '_L_lock_24' loaded at 56f3a5ed\nFunction '_L_unlock_237' loaded at 56f3a8ce\nFunction '_L_lock_27' loaded at 56f3b036\nFunction '_L_unlock_72' loaded at 56f3b54e\nFunction '_L_unlock_111' loaded at 56f3b7b6\nFunction '_L_unlock_167' loaded at 56f3bbce\nFunction 'ether_ntoa_r' loaded at 56f3c510\nFunction 'rresvport_af' loaded at 56f3d200\nFunction '__internal_setnetgrent_reuse' loaded at 56f3ed70\nFunction '_L_unlock_711' loaded at 56f3f622\nFunction '_L_lock_28' loaded at 56f3f9ad\nFunction '_L_lock_25' loaded at 56f3fc16\nFunction 'if_nameindex' loaded at 56f40ba0\nFunction 'inet6_option_init' loaded at 56f41ee0\nFunction 'setsourcefilter' loaded at 56f42720\nFunction 'authnone_create_once' loaded at 56f43340\nFunction 'xdr_authunix_parms' loaded at 56f43b70\nFunction 'clntraw_geterr' loaded at 56f448e0\nFunction 'clnttcp_freeres' loaded at 56f44fc0\nFunction 'clntudp_freeres' loaded at 56f45930\nFunction 'pmap_unset' loaded at 56f46810\nFunction 'pmap_rmtcall' loaded at 56f47720\nFunction '__rpc_thread_variables' loaded at 56f480a0\nFunction 'svcerr_weakauth' loaded at 56f483b0\nFunction 'xprt_unregister' loaded at 56f48920\nFunction 'svcraw_getargs' loaded at 56f48e30\nFunction 'svctcp_freeargs' loaded at 56f495e0\nFunction 'svctcp_rendezvous_abort' loaded at 56f49c40\nFunction 'svcudp_recv' loaded at 56f4a4f0\nFunction 'xdr_u_longlong_t' loaded at 56f4ab90\nFunction 'xdr_wrapstring' loaded at 56f4afb0\nFunction 'xdrmem_setpos' loaded at 56f4b520\nFunction 'skip_input_bytes' loaded at 56f4b7c0\nFunction 'xdrrec_getbytes' loaded at 56f4bb50\nFunction 'xdrstdio_create' loaded at 56f4c150\nFunction 'xdrstdio_getpos' loaded at 56f4c400\nFunction 'x_destroy' loaded at 56f4c790\nFunction 'xdr_authdes_cred' loaded at 56f4d030\nFunction 'key_get_conv' loaded at 56f4e400\nFunction '_L_unlock_445' loaded at 56f4e8df\nFunction 'xdr_keystatus' loaded at 56f4ec90\nFunction '_svcauth_des' loaded at 56f4f730\nFunction 'clntunix_create' loaded at 56f50340\nFunction 'svcunixfd_create' loaded at 56f50ed0\nFunction '_create_xid' loaded at 56f516a0\nFunction 'xdr_uint8_t' loaded at 56f51ac0\nFunction '__nscd_gethostbyname2_r' loaded at 56f52fd0\nFunction 'get_mapping' loaded at 56f53dc0\nFunction 'getutent' loaded at 56f546c0\nFunction 'endutent' loaded at 56f549f0\nFunction 'getutline' loaded at 56f54b40\nFunction '__utmp_equal' loaded at 56f55040\nFunction 'updwtmp' loaded at 56f55fb0\nFunction 'setutxent' loaded at 56f56cb0\nFunction 'dl_iterate_phdr' loaded at 56f56e70\nFunction '__libc_dlopen_mode' loaded at 56f57510\nFunction 'fde_unencoded_compare' loaded at 56f57b40\nFunction '__register_frame' loaded at 56f58350\nFunction '_L_lock_136' loaded at 56f59129\nFunction '_Unwind_GetIP' loaded at 56f591e0\nFunction 'read_uleb128' loaded at 56f59b50\nFunction '_IO_old_cookie_seek' loaded at 56f59eb0\nFunction '_L_lock_68' loaded at 56f5a7ea\nFunction '_L_lock_36' loaded at 56f5ab9c\nFunction '_IO_file_xsputn' loaded at 56f5af40\nFunction '_IO_old_file_finish' loaded at 56f5bae0\nFunction 'versionsort64' loaded at 56f5c090\nFunction 'sched_setaffinity' loaded at 56f5d210\nFunction 'getspent_r' loaded at 56f5d550\nFunction 'gethostbyname2_r' loaded at 56f5d7f0\nFunction 'getservbyport_r' loaded at 56f5dbe0\nFunction 'free_mem' loaded at 56f5dff0\nFunction 'free_mem' loaded at 56f5e5c0\nFunction '_L_unlock_44' loaded at 56f5e905\nFunction '__rpc_thread_destroy' loaded at 56f5ec70\n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 6]- /disk/PinTools/Utils/obj-ia32/cp-pin    \n   L  /disk/PinTools/Utils/obj-ia32/cp-pin     [0x8048ad8:0x8049258] offset 0x0    1 RTNs\n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 5]- /lib/ld-linux.so.2                      \n   L  /lib/ld-linux.so.2                       [0x555557c0:0x5556af6a] offset 0x55555000   18 RTNs\n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 4]- /usr/lib/libstdc++.so.6                 \n   L  /usr/lib/libstdc++.so.6                  [0x56d7182c:0x56dedee0] offset 0x56d37000  215 RTNs\n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 3]- /lib/libm.so.6                          \n   L  /lib/libm.so.6                           [0x56e2e314:0x56e488f0] offset 0x56e2b000   42 RTNs\n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 2]- /lib/libgcc_s.so.1                      \n   L  /lib/libgcc_s.so.1                       [0x56e5a4fc:0x56e62120] offset 0x56e59000    9 RTNs\n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n[ 1]- /lib/libc.so.6                          \n   L  /lib/libc.so.6                           [0x56e795d8:0x56f5ed1e] offset 0x56e64000  340 RTNs\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Replay/ia32_cross_os_replay.record": "L '/disk/PinTools/Utils/obj-ia32/cp-pin' 8048ad8 781 0 1 \n\t'main' 8048d90\nEND_RTN_LIST\nL '/lib/ld-linux.so.2' 555557c0 157ab 55555000 0 \n\t'rtld_lock_default_unlock_recursive' 555558c0\n\t'relocate_doit' 55556770\n\t'fillin_rpath' 5555a3c0\n\t'decompose_rpath' 5555c9f0\n\t'do_lookup_x' 5555e380\n\t'_dl_map_object_deps' 55560e40\n\t'_dl_sort_fini' 55562ba0\n\t'match_symbol' 55563930\n\t'_dl_next_tls_modid' 55564e10\n\t'_dl_tls_setup' 55565940\n\t'_dl_runtime_resolve' 55567930\n\t'__assert_fail' 55568870\n\t'calloc' 55568f60\n\t'profil_counter' 55569560\n\t'__lseek' 555698d0\n\t'__madvise' 55569e50\n\t'strlen' 5556a270\n\t'__i686.get_pc_thunk.cx' 5556ae47\nEND_RTN_LIST\nL '/usr/lib/libstdc++.so.6' 56d7182c 7c6b5 56d37000 0 \n\t'_ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv' 56d760f0\n\t'_ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE' 56d774d0\n\t'_ZNKSt7codecvtIwc11__mbstate_tE16do_always_noconvEv' 56d78800\n\t'_ZNSt7codecvtIcc11__mbstate_tEC1Ej' 56d78c10\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7_M_copyEPwPKwj' 56d78f70\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE15_M_check_lengthEjjPKc' 56d791c0\n\t'_ZNKSt14basic_ofstreamIwSt11char_traitsIwEE7is_openEv' 56d79900\n\t'_ZStlsIdcSt11char_traitsIcEERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E' 56d7a7f0\n\t'_ZNKSt5ctypeIcE9do_narrowEPKcS2_cPc' 56d7bdf0\n\t'_ZNSt5ctypeIcED2Ev' 56d7c340\n\t'_ZNSt12ctype_bynameIwEC2EPKcj' 56d7c880\n\t'_ZN11__gnu_debug19_Safe_sequence_base7_M_swapERS0_' 56d7da10\n\t'_ZSt18__throw_bad_typeidv' 56d7de60\n\t'_ZNSt12out_of_rangeD0Ev' 56d7e0f0\n\t'_ZSt23__throw_underflow_errorPKc' 56d7e480\n\t'_ZNSt8ios_base6xallocEv' 56d7edd0\n\t'_ZNSt8ios_base7failureC1ERKSs' 56d7f3c0\n\t'_ZNSt8ios_base7_M_initEv' 56d808d0\n\t'_ZNSt6localeC2ERKS_' 56d80b10\n\t'_ZNSt6locale5_ImplD2Ev' 56d81310\n\t'_ZNSt6locale5_ImplC2Ej' 56d81e00\n\t'_ZNSt6localeC2ERKS_S1_i' 56d84170\n\t'_ZNSt11logic_errorC2ERKSs' 56d86830\n\t'_ZNSt13runtime_errorC2ERKSs' 56d86af0\n\t'_ZNSt13runtime_errorD0Ev' 56d86e20\n\t'_ZNSt12strstreambuf7_M_freeEPc' 56d870e0\n\t'_ZNSt12strstreambuf9underflowEv' 56d87330\n\t'_ZNSt12strstreambufC2EPaiS0_' 56d87c80\n\t'_ZNSt12strstreambufC1EPKhi' 56d88450\n\t'_ZNSt10ostrstreamD2Ev' 56d88cb0\n\t'_ZNSt10istrstreamD1Ev' 56d89480\n\t'_ZNSt9strstreamD0Ev' 56d89bf0\n\t'_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base' 56d8a2d0\n\t'_ZNSaIwED1Ev' 56d8a8c0\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE13_M_set_bufferEi' 56d8b6c0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv' 56d8b8b0\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEE9pbackfailEj' 56d8be20\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE6xsgetnEPci' 56d8d060\n\t'_ZNSt14basic_ifstreamIwSt11char_traitsIwEE7is_openEv' 56d8e080\n\t'_ZNSt13basic_filebufIwSt11char_traitsIwEED0Ev' 56d8e980\n\t'_ZNSt13basic_filebufIcSt11char_traitsIcEE9showmanycEv' 56d8f250\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode' 56d8f860\n\t'_ZNSt14basic_ofstreamIwSt11char_traitsIwEEC2Ev' 56d8fe60\n\t'_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode' 56d904d0\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1Ev' 56d90d40\n\t'_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev' 56d91430\n\t'_ZTv0_n12_NSt13basic_fstreamIcSt11char_traitsIcEED0Ev' 56d91dc0\n\t'_ZNSt13basic_fstreamIwSt11char_traitsIwEED2Ev' 56d92260\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE7rdstateEv' 56d93680\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEEC1Ev' 56d938f0\n\t'_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev' 56d93c00\n\t'_ZNKSt9basic_iosIwSt11char_traitsIwEE3badEv' 56d93fe0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE10exceptionsESt12_Ios_Iostate' 56d941d0\n\t'_ZNSt9basic_iosIwSt11char_traitsIwEE5imbueERKSt6locale' 56d944a0\n\t'_ZNSt14basic_iostreamIwSt11char_traitsIwEEC1Ev' 56d94f60\n\t'_ZNSdC1Ev' 56d95280\n\t'_ZNSirsEPFRSt8ios_baseS0_E' 56d954d0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsEPFRSt8ios_baseS4_E' 56d95600\n\t'_ZStrsISt11char_traitsIcEERSt13basic_istreamIcT_ES5_Pa' 56d958a0\n\t'_ZStrsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_St12_Setiosflags' 56d95b40\n\t'_ZTv0_n12_NSt13basic_istreamIwSt11char_traitsIwEED1Ev' 56d95e20\n\t'_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_RS3_' 56d96650\n\t'_ZNSi3getERSt15basic_streambufIcSt11char_traitsIcEE' 56d96fa0\n\t'_ZNSirsERy' 56d97a40\n\t'_ZSt2wsIwSt11char_traitsIwEERSt13basic_istreamIT_T0_ES6_' 56d987a0\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE3getERSt15basic_streambufIwS1_Ew' 56d99390\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEErsERf' 56d99e80\n\t'_ZNSt13basic_istreamIwSt11char_traitsIwEE6sentryC2ERS2_b' 56d9abf0\n\t'_ZNKSt10moneypunctIcLb0EE13thousands_sepEv' 56d9c540\n\t'_ZNKSt10moneypunctIcLb0EE14do_frac_digitsEv' 56d9c6c0\n\t'_ZNKSt10moneypunctIcLb1EE10pos_formatEv' 56d9c890\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56d9cb50\n\t'_ZNSt16__numpunct_cacheIcEC1Ej' 56d9cda0\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRe' 56d9d200\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPKv' 56d9d5f0\n\t'_ZNSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEEC2Ej' 56d9d850\n\t'_ZNKSt8messagesIcE4openERKSsRKSt6locale' 56d9db80\n\t'_ZNSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED0Ev' 56d9dfc0\n\t'_ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEED1Ev' 56d9e1e0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEED2Ev' 56d9e3f0\n\t'_ZSt9has_facetISt8numpunctIcEEbRKSt6locale' 56d9e810\n\t'_ZSt9use_facetISt10moneypunctIcLb0EEERKT_RKSt6locale' 56d9ebb0\n\t'_ZNSt7collateIcEC2Ej' 56d9ef10\n\t'_ZNSt8messagesIcED1Ev' 56d9f290\n\t'_ZNSt16__numpunct_cacheIcED2Ev' 56d9f6d0\n\t'_ZNSt15numpunct_bynameIcED2Ev' 56d9fb30\n\t'_ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56d9ffb0\n\t'_ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEEC1Ej' 56da0310\n\t'_ZNSt15messages_bynameIcEC2EPKcj' 56da07c0\n\t'_ZNSt11__timepunctIcEC2Ej' 56da0fc0\n\t'_ZNKSt8numpunctIcE12do_falsenameEv' 56da12f0\n\t'_ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj' 56da17f0\n\t'_ZNKSt8time_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE3putES3_RSt8ios_basecPK2tmPKcSB_' 56da1c80\n\t'_ZNSt15numpunct_bynameIcEC1EPKcj' 56da2180\n\t'_ZNKSt8time_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE14do_get_weekdayES3_S3_RSt8ios_baseRSt12_Ios_IostateP2tm' 56da3b00\n\t'_ZNKSt7collateIcE12do_transformEPKcS2_' 56da68d0\n\t'_ZNKSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_bRSt8ios_baseRSt12_Ios_IostateRSs' 56dac390\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE15_M_insert_floatIeEES3_S3_RSt8ios_baseccT_' 56daeb10\n\t'_ZNKSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE6do_putES3_RSt8ios_basecm' 56db0310\n\t'_ZNKSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRm' 56db2f10\n\t'_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E' 56db5520\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEPFRS2_S3_E' 56db5a10\n\t'_ZNSoC2EPSt15basic_streambufIcSt11char_traitsIcEE' 56db5ba0\n\t'_ZNSoC1Ev' 56db5e20\n\t'_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_' 56db6470\n\t'_ZNSoD2Ev' 56db6a40\n\t'_ZNSolsEs' 56db6d50\n\t'_ZNSo5writeEPKci' 56db7af0\n\t'_ZNSolsEx' 56db8a50\n\t'_ZNSt13basic_ostreamIwSt11char_traitsIwEElsEi' 56db9e90\n\t'_ZSt4endsIwSt11char_traitsIwEERSt13basic_ostreamIT_T0_ES6_' 56dbb170\n\t'_ZNKSt19basic_ostringstreamIcSt11char_traitsIcESaIcEE5rdbufEv' 56dbba10\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE6setbufEPwi' 56dbbd40\n\t'_ZNSt15basic_stringbufIwSt11char_traitsIwESaIwEE3strERKSbIwS1_S2_E' 56dbc7f0\n\t'_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEEC2ESt13_Ios_Openmode' 56dbcc90\n\t'_ZNKSt18basic_stringstreamIcSt11char_traitsIcESaIcEE3strEv' 56dbd7f0\n\t'_ZNKSt19basic_istringstreamIwSt11char_traitsIwESaIwEE3strEv' 56dbdfc0\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEED2Ev' 56dbe670\n\t'_ZNSt18basic_stringstreamIwSt11char_traitsIwESaIwEEC1ESt13_Ios_Openmode' 56dbee50\n\t'_ZNSt19basic_ostringstreamIwSt11char_traitsIwESaIwEEC1ERKSbIwS1_S2_ESt13_Ios_Openmode' 56dbf9a0\n\t'_ZTv0_n12_NSt19basic_istringstreamIwSt11char_traitsIwESaIwEED0Ev' 56dc0180\n\t'_ZTv0_n12_NSt19basic_istringstreamIcSt11char_traitsIcESaIcEED1Ev' 56dc0a90\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE10pubseekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc12e0\n\t'_ZNKSt15basic_streambufIcSt11char_traitsIcEE4pptrEv' 56dc1420\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEE10pubseekoffExSt12_Ios_SeekdirSt13_Ios_Openmode' 56dc14f0\n\t'_ZNKSt15basic_streambufIwSt11char_traitsIwEE5pbaseEv' 56dc1680\n\t'_ZNSt15basic_streambufIwSt11char_traitsIwEEaSERKS2_' 56dc1740\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEEC1Ev' 56dc1a40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEED1Ev' 56dc1ce0\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE7seekposESt4fposI11__mbstate_tESt13_Ios_Openmode' 56dc1e40\n\t'_ZNSt15basic_streambufIcSt11char_traitsIcEE5sputcEc' 56dc2150\n\t'_ZNKSs7_M_dataEv' 56dc26e0\n\t'_ZNKSs4sizeEv' 56dc2820\n\t'_ZNSs4_Rep15_M_set_sharableEv' 56dc28e0\n\t'_ZNKSs5emptyEv' 56dc2d70\n\t'_ZNKSs16find_last_not_ofEcj' 56dc3010\n\t'_ZNKSs13find_first_ofEcj' 56dc33e0\n\t'_ZNKSs4rendEv' 56dc3740\n\t'_ZNKSs7compareEjjRKSs' 56dc3b60\n\t'_ZNSsC2EPKcjRKSaIcE' 56dc4040\n\t'_ZNSsC1IPcEET_S1_RKSaIcE' 56dc4470\n\t'_ZNSs6appendEPKcj' 56dc4a00\n\t'_ZNSs6assignEPKc' 56dc5100\n\t'_ZNSs6insertEN9__gnu_cxx17__normal_iteratorIPcSsEEjc' 56dc54e0\n\t'_ZNSs7_M_leakEv' 56dc59b0\n\t'_ZNSsD2Ev' 56dc5d10\n\t'_ZNSs7replaceEjjPKc' 56dc63b0\n\t'_ZNSt8valarrayIjED2Ev' 56dc6700\n\t'_ZNKSt10moneypunctIwLb0EE13positive_signEv' 56dc6dc0\n\t'_ZNKSt10moneypunctIwLb1EE13decimal_pointEv' 56dc6f70\n\t'_ZNKSt10moneypunctIwLb1EE16do_thousands_sepEv' 56dc7100\n\t'_ZNKSt8numpunctIwE13decimal_pointEv' 56dc74b0\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE3getES3_S3_RSt8ios_baseRSt12_Ios_IostateRt' 56dc76f0\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE3putES3_RSt8ios_basewb' 56dc7b10\n\t'_ZNKSt11__timepunctIwE20_M_date_time_formatsEPPKw' 56dc7ea0\n\t'_ZNKSt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10date_orderEv' 56dc8130\n\t'_ZNKSt8messagesIwE8do_closeEi' 56dc8430\n\t'_ZNSt8time_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEED0Ev' 56dc87b0\n\t'_ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEED1Ev' 56dc89d0\n\t'_ZSt9has_facetISt8time_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEEbRKSt6locale' 56dc8cb0\n\t'_ZSt9has_facetISt7codecvtIwc11__mbstate_tEEbRKSt6locale' 56dc9110\n\t'_ZSt9use_facetISt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEERKT_RKSt6locale' 56dc9470\n\t'_ZNSt14codecvt_bynameIwc11__mbstate_tED1Ev' 56dc97d0\n\t'_ZNSt15messages_bynameIwED0Ev' 56dc9bb0\n\t'_ZNSt18__moneypunct_cacheIwLb1EED1Ev' 56dca010\n\t'_ZNSt17moneypunct_bynameIwLb1EED1Ev' 56dca3f0\n\t'_ZNSt8numpunctIwEC1EP15__locale_structj' 56dca870\n\t'_ZNSt18__moneypunct_cacheIwLb0EEC2Ej' 56dcabf0\n\t'_ZNSt17__timepunct_cacheIwEC1Ej' 56dcb110\n\t'_ZNKSt10moneypunctIwLb0EE16do_negative_signEv' 56dcb8b0\n\t'_ZNSt10moneypunctIwLb1EEC1EPSt18__moneypunct_cacheIwLb1EEj' 56dcbe10\n\t'_ZNSt8messagesIwEC1EP15__locale_structPKcj' 56dcc1f0\n\t'_ZNSt15time_get_bynameIwSt19istreambuf_iteratorIwSt11char_traitsIwEEEC2EPKcj' 56dcc8d0\n\t'_ZNSt17moneypunct_bynameIwLb0EEC2EPKcj' 56dccd40\n\t'_ZNSt14collate_bynameIwEC2EPKcj' 56dcf9b0\n\t'_ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE' 56dd1030\n\t'_ZNKSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE10_M_extractILb0EEES3_S3_S3_RSt8ios_baseRSt12_Ios_IostateRSs' 56dd4110\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE13_M_insert_intIxEES3_S3_RSt8ios_basewT_' 56dd7b60\n\t'_ZNKSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE6do_getES3_S3_RSt8ios_baseRSt12_Ios_IostateRx' 56dda050\n\t'_ZNKSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE6do_putES3_RSt8ios_basewb' 56ddcfc0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE5beginEv' 56ddd810\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4_Rep12_M_is_sharedEv' 56ddd8e0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE4findEPKwjj' 56dddca0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE17find_first_not_ofEwj' 56dddf40\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE13find_first_ofEPKwjj' 56dde330\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE12find_last_ofEPKwj' 56dde6a0\n\t'_ZNKSbIwSt11char_traitsIwESaIwEE7compareEjjRKS2_jj' 56dde9c0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1ERKS2_jjRKS1_' 56ddefa0\n\t'_ZNSbIwSt11char_traitsIwESaIwEEC1EPKwRKS1_' 56ddf3b0\n\t'_ZNSbIwSt11char_traitsIwESaIwEE9push_backEw' 56ddf8d0\n\t'_ZNSbIwSt11char_traitsIwESaIwEED2Ev' 56ddfe30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEN9__gnu_cxx17__normal_iteratorIPwS2_EEw' 56de0420\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6insertEjRKS2_jj' 56de0910\n\t'_ZNSbIwSt11char_traitsIwESaIwEE6rbeginEv' 56de0c30\n\t'_ZNSbIwSt11char_traitsIwESaIwEE7replaceEjjPKw' 56de1210\n\t'_ZNKSt7codecvtIwc11__mbstate_tE9do_lengthERS0_PKcS4_j' 56de15e0\n\t'_ZNKSt5ctypeIwE11do_scan_notEtPKwS2_' 56de1dc0\n\t'_ZNKSt5ctypeIwE10do_toupperEw' 56de21e0\n\t'_ZNSt10moneypunctIwLb0EED2Ev' 56de2ab0\n\t'_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc' 56de3090\n\t'_ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct' 56de4390\n\t'_ZNSt12__basic_fileIcE4syncEv' 56de5a80\n\t'_ZNSt12__basic_fileIcE6xsgetnEPci' 56de5f30\n\t'_ZdlPvRKSt9nothrow_t' 56de62c0\n\t'__cxa_begin_catch' 56de66c0\n\t'__cxa_call_unexpected' 56de6d30\n\t'__cxa_guard_release' 56de7630\n\t'__cxa_pure_virtual' 56de7970\n\t'_ZN10__cxxabiv117__class_type_infoD0Ev' 56de7b30\n\t'_ZNSt10bad_typeidD1Ev' 56de7d50\n\t'_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_' 56de8060\n\t'_ZN10__cxxabiv117__pbase_type_infoD2Ev' 56de8a60\n\t'_ZN10__cxxabiv120__function_type_infoD0Ev' 56de8c70\n\t'_ZNK10__cxxabiv119__pointer_type_info15__pointer_catchEPKNS_17__pbase_type_infoEPPvj' 56de8ef0\n\t'__cxa_vec_new' 56de95e0\nEND_RTN_LIST\nL '/lib/libm.so.6' 56e2e314 1a5dd 56e2b000 0 \n\t'__i686.get_pc_thunk.bx' 56e2e4c7\n\t'fegetenv' 56e30a90\n\t'__ieee754_asin' 56e30db0\n\t'__ieee754_y0' 56e314e0\n\t'__ieee754_log10' 56e32c10\n\t'cbrt' 56e335f0\n\t'logb' 56e340d0\n\t'asin' 56e34840\n\t'hypot' 56e34e30\n\t'log10' 56e35560\n\t'nan' 56e35b00\n\t'creal' 56e35f10\n\t'csin' 56e36b80\n\t'clog10' 56e37d60\n\t'__finite' 56e382b0\n\t'__ieee754_atan2f' 56e386d0\n\t'ponef' 56e38ee0\n\t'__ieee754_remainderf' 56e3a280\n\t'cbrtf' 56e3ab60\n\t'logbf' 56e3b4d0\n\t'asinf' 56e3b9e0\n\t'hypotf' 56e3bff0\n\t'log10f' 56e3c6c0\n\t'nanf' 56e3cc50\n\t'crealf' 56e3cf60\n\t'csinf' 56e3dab0\n\t'clog10f' 56e3e9d0\n\t'finitef' 56e3ee00\n\t'__ieee754_atan2l' 56e3f320\n\t'pone' 56e3fff0\n\t'__ieee754_remainderl' 56e41730\n\t'cbrtl' 56e41ca0\n\t'logbl' 56e42800\n\t'atan2l' 56e42db0\n\t'y0l' 56e43420\n\t'powl' 56e43b90\n\t'truncl' 56e44180\n\t'cabsl' 56e444c0\n\t'ctanl' 56e45540\n\t'fmal' 56e466c0\n\t'copysignl' 56e46ae0\n\t'__divdc3' 56e48190\nEND_RTN_LIST\nL '/lib/libgcc_s.so.1' 56e5a4fc 7c25 56e59000 0 \n\t'__ashldi3' 56e5a8e0\n\t'__subvsi3' 56e5abe0\n\t'__ctzdi2' 56e5b030\n\t'__mulxc3' 56e5bd70\n\t'__fixdfdi' 56e5d020\n\t'__udivmoddi4' 56e5d8e0\n\t'_Unwind_GetGR' 56e5dcd0\n\t'__register_frame_info' 56e60260\n\t'.fini' 56e62104\nEND_RTN_LIST\nL '/lib/libc.so.6' 56e795d8 e5747 56e64000 0 \n\t'gnu_get_libc_version' 56e79980\n\t'__divdi3' 56e79ee0\n\t'__gconv_close' 56e7adc0\n\t'__gconv_find_transform' 56e7bab0\n\t'add_alias' 56e7c180\n\t'__gconv_transform_ascii_internal' 56e7e080\n\t'__gconv_translit_find' 56e81e20\n\t'__gconv_lookup_cache' 56e82780\n\t'_L_unlock_996' 56e838fc\n\t'rangecmp' 56e84640\n\t'__duplocale' 56e85ad0\n\t'__collseq_table_lookup' 56e85f30\n\t'isdigit' 56e86400\n\t'__isascii_l' 56e866a0\n\t'ispunct_l' 56e86810\n\t'set_binding_values' 56e869d0\n\t'__dcigettext' 56e87a10\n\t'dcngettext' 56e88220\n\t'_nl_expand_alias' 56e89d40\n\t'new_exp_2' 56e8a920\n\t'finite' 56e8bd40\n\t'copysignf' 56e8c0f0\n\t'modfl' 56e8c3b0\n\t'__libc_longjmp' 56e8c810\n\t'sigpending' 56e8cd90\n\t'sigpause' 56e8d1f0\n\t'sigaddset' 56e8d5a0\n\t'__libc_current_sigrtmax_private' 56e8d8f0\n\t'sigset' 56e8de10\n\t'_quicksort' 56e8e360\n\t'_L_lock_22' 56e8f45a\n\t'exit' 56e8f530\n\t'div' 56e8f9d0\n\t'initstate' 56e8fef0\n\t'setstate_r' 56e90070\n\t'mrand48' 56e90610\n\t'jrand48_r' 56e908d0\n\t'strtoll' 56e90ca0\n\t'strtoull_l' 56e92390\n\t'__strtof_l' 56e948e0\n\t'do_system' 56e99720\n\t'realpath' 56e99cf0\n\t'__xpg_basename' 56e9b780\n\t'wcstoimax' 56e9c020\n\t'__mpn_add_n' 56e9c4a0\n\t'__mpn_impn_sqr_n_basecase' 56e9cfa0\n\t'__mpn_construct_double' 56e9ddf0\n\t'_itowa' 56e9e690\n\t'_L_unlock_11056' 56ea35aa\n\t'printf_size_info' 56ea77b0\n\t'group_number' 56ea8220\n\t'vfscanf' 56eb2050\n\t'perror_internal' 56eb6cd0\n\t'__path_search' 56eb7770\n\t'ftrylockfile' 56eb7ea0\n\t'_IO_file_doallocate' 56eb8b50\n\t'_L_unlock_161' 56eb9245\n\t'__fopen_internal' 56eb9690\n\t'_L_lock_41' 56eb9bdc\n\t'_L_unlock_185' 56eb9ecf\n\t'_L_lock_47' 56eba57b\n\t'_IO_proc_close' 56ebaa70\n\t'_L_unlock_110' 56ebb13e\n\t'_IO_setbuffer' 56ebb4a0\n\t'_L_unlock_95' 56ebb894\n\t'_L_unlock_105' 56ebbda2\n\t'getwchar' 56ebc020\n\t'_L_lock_43' 56ebc4e9\n\t'putwc' 56ebc940\n\t'_L_unlock_81' 56ebcc61\n\t'vswprintf' 56ebcf20\n\t'_IO_sungetwc' 56ebd360\n\t'save_for_wbackup' 56ebd7c0\n\t'_IO_wstr_finish' 56ebe140\n\t'_IO_wdo_write' 56ebf2a0\n\t'do_out' 56ebfb00\n\t'_L_lock_29' 56ec0220\n\t'_L_lock_30' 56ec04ae\n\t'_L_lock_29' 56ec08df\n\t'_L_lock_30' 56ec0c7e\n\t'_IO_strn_overflow' 56ec1080\n\t'ftello' 56ec1670\n\t'ftello64' 56ec1b60\n\t'__fpending' 56ec1e00\n\t'_L_unlock_17' 56ec25f2\n\t'_L_lock_29' 56ec2814\n\t'_IO_file_sync_mmap' 56ec2d30\n\t'_IO_do_write' 56ec3a10\n\t'_IO_file_setbuf_mmap' 56ec44a0\n\t'flush_cleanup' 56ec4fa0\n\t'_IO_sgetn' 56ec55a0\n\t'_IO_adjust_column' 56ec5960\n\t'_IO_default_seek' 56ec5fc0\n\t'_IO_list_lock' 56ec6070\n\t'_IO_default_doallocate' 56ec67e0\n\t'_L_unlock_280' 56ec6c3e\n\t'_L_lock_1784' 56ec6cca\n\t'_IO_str_pbackfail' 56ec6f60\n\t'__failing_morecore' 56ec75a0\n\t'ptmalloc_init' 56ec7ef0\n\t'cfree' 56ec91a0\n\t'realloc_check' 56ecaaa0\n\t'realloc_hook_ini' 56ecbad0\n\t'_L_unlock_2466' 56ecc04a\n\t'_L_unlock_4424' 56ecc0e2\n\t'_L_unlock_8320' 56ecc17a\n\t'_L_lock_9316' 56ecc20f\n\t'_L_unlock_9886' 56ecc29b\n\t'_L_unlock_10772' 56ecc327\n\t'mprobe' 56ecc510\n\t'mtrace' 56eccc10\n\t'_L_lock_751' 56ecd4f3\n\t'_obstack_memory_used' 56ecd8f0\n\t'__strdup' 56ecdfd0\n\t'strpbrk' 56ece820\n\t'bcmp' 56ecf180\n\t'ffsll' 56ecfd90\n\t'_wordcopy_fwd_aligned' 56ed0310\n\t'rawmemchr' 56ed0b90\n\t'argz_insert' 56ed1180\n\t'envz_add' 56ed1970\n\t'__memset_gcn_by4' 56ed3700\n\t'__strncat_g' 56ed3950\n\t'__strcspn_g' 56ed3b40\n\t'__strcspn_c1' 56ed3f70\n\t'__strsep_3c' 56ed4270\n\t'__xpg_strerror_r' 56ed4680\n\t'wcsncpy' 56ed4aa0\n\t'wmemset' 56ed4f80\n\t'mbsrtowcs' 56ed58e0\n\t'wcstoll' 56ed6550\n\t'____wcstol_l_internal' 56ed6870\n\t'____wcstod_l_internal' 56ed8040\n\t'wcscoll' 56ede440\n\t'_nl_cleanup_ctype' 56ee0000\n\t'asctime' 56ee0c60\n\t'guess_time_tm' 56ee0eb0\n\t'__tzstring' 56ee1be0\n\t'_L_unlock_2123' 56ee287f\n\t'ftime' 56ee39c0\n\t'memcpy_uppcase' 56ee68e0\n\t'_nl_init_alt_digit' 56eeab60\n\t'_nl_cleanup_time' 56eeafe0\n\t'_L_unlock_119' 56eeb4ac\n\t'alphasort' 56eeb840\n\t'_L_lock_246' 56eebee0\n\t'_L_lock_27' 56eec50a\n\t'getgrgid' 56eecca0\n\t'_L_unlock_290' 56eed201\n\t'getgrgid_r' 56eed4e0\n\t'_L_unlock_116' 56eee03e\n\t'_L_lock_25' 56eee5d6\n\t'_L_unlock_233' 56eee8bd\n\t'times' 56eef2d0\n\t'pause' 56eefb10\n\t'execle' 56ef0120\n\t'getegid' 56ef09a0\n\t'getsid' 56ef0c60\n\t'setlogin' 56ef1140\n\t'handle_intel' 56ef1a00\n\t'collated_compare' 56ef3be0\n\t'end_pattern' 56ef5f50\n\t're_node_set_contains' 56efa780\n\t'find_subexp_node' 56efad00\n\t'lower_subexps' 56efb590\n\t'free_dfa_content' 56efb9d0\n\t'check_arrival_expand_ecl' 56efc4b0\n\t're_node_set_init_copy' 56efd1f0\n\t'build_upper_buffer' 56efe6f0\n\t'check_arrival' 56efffa0\n\t'parse_bracket_exp' 56f02cf0\n\t'set_regs' 56f05f40\n\t're_exec' 56f08f60\n\t'_getopt_long_only_r' 56f0a650\n\t'__sched_get_priority_min' 56f0a940\n\t'in6aicmp' 56f0ad30\n\t'_L_lock_9088' 56f0e70d\n\t'eval_expr' 56f0ed40\n\t'pread' 56f12850\n\t'posix_spawn_file_actions_addclose' 56f12cb0\n\t'posix_spawnattr_setpgroup' 56f12fa0\n\t'posix_spawnattr_setschedparam' 56f13760\n\t'__xstat64' 56f13b70\n\t'fstatfs64' 56f143f0\n\t'mkdir' 56f14a00\n\t'__close' 56f15160\n\t'__fcntl_nocancel' 56f15750\n\t'creat64' 56f15cc0\n\t'getttyname' 56f162f0\n\t'readlinkat' 56f17050\n\t'object_compare' 56f184b0\n\t'fts_palloc' 56f19850\n\t'posix_fadvise' 56f1afc0\n\t'__internal_statvfs' 56f1bea0\n\t'tcsetpgrp' 56f1c4c0\n\t'setrlimit64' 56f1c8f0\n\t'__sbrk' 56f1cdb0\n\t'setregid' 56f1d440\n\t'___newselect_nocancel' 56f1d84a\n\t'sethostid' 56f1de50\n\t'usleep' 56f1e150\n\t'getfsspec' 56f1e570\n\t'_L_lock_1062' 56f1f144\n\t'ftruncate64' 56f1f5c0\n\t'endusershell' 56f1fcc0\n\t'openlog_internal' 56f20390\n\t'_L_lock_1085' 56f20c4c\n\t'madvise' 56f21070\n\t'fcvt_r' 56f21420\n\t'hsearch_r' 56f22060\n\t'tsearch' 56f22a40\n\t'errx' 56f23040\n\t'dirname' 56f238b0\n\t'listxattr' 56f23d30\n\t'vm86' 56f24080\n\t'gnu_dev_major' 56f24450\n\t'capget' 56f24730\n\t'inotify_add_watch' 56f24a30\n\t'prctl' 56f24d60\n\t'getpeername' 56f250c0\n\t'setsockopt' 56f25500\n\t'__libc_msgsnd' 56f259a0\n\t'shmget' 56f25f10\n\t'pc_to_index' 56f26b80\n\t'iswxdigit' 56f27410\n\t'iswpunct' 56f27c50\n\t'iswalpha_l' 56f28270\n\t'__towlower_l' 56f28880\n\t'_L_unlock_111' 56f28cd6\n\t'getspent_r' 56f29440\n\t'_nss_files_parse_spent' 56f298b0\n\t'_L_lock_34' 56f2a3eb\n\t'__argp_fmtstream_update' 56f2a500\n\t'__argp_fmtstream_puts' 56f2af00\n\t'until_short' 56f2b2d0\n\t'usage_argful_short_opt' 56f2c270\n\t'argp_help' 56f2e4a0\n\t'argp_usage' 56f2f580\n\t'pthread_attr_setschedparam' 56f2f7d0\n\t'pthread_cond_signal' 56f2fa10\n\t'pthread_self' 56f2fc50\n\t'_L_lock_116' 56f2ff5a\n\t'inet_ntop4' 56f30490\n\t'net_mask' 56f30ec0\n\t'skip_ws' 56f324c0\n\t'_L_unlock_68' 56f3306e\n\t'__nss_configure_lookup' 56f33a70\n\t'__nss_getent' 56f34000\n\t'__nss_group_lookup' 56f34eb0\n\t'__backtrace' 56f35490\n\t'__sprintf_chk' 56f35e60\n\t'_L_unlock_99' 56f362af\n\t'_L_unlock_302' 56f36680\n\t'__pread64_chk' 56f36be0\n\t'__wmemcpy_chk' 56f36ee0\n\t'__vswprintf_chk' 56f37220\n\t'_L_lock_35' 56f376ca\n\t'_L_unlock_247' 56f379a7\n\t'__wcsnrtombs_chk' 56f37c70\n\t'_L_unlock_63' 56f38084\n\t'__h_errno_location' 56f38530\n\t'_L_unlock_149' 56f38ddb\n\t'_L_unlock_73' 56f396ee\n\t'_L_lock_28' 56f39c55\n\t'_L_lock_148' 56f39fee\n\t'_L_lock_24' 56f3a5ed\n\t'_L_unlock_237' 56f3a8ce\n\t'_L_lock_27' 56f3b036\n\t'_L_unlock_72' 56f3b54e\n\t'_L_unlock_111' 56f3b7b6\n\t'_L_unlock_167' 56f3bbce\n\t'ether_ntoa_r' 56f3c510\n\t'rresvport_af' 56f3d200\n\t'__internal_setnetgrent_reuse' 56f3ed70\n\t'_L_unlock_711' 56f3f622\n\t'_L_lock_28' 56f3f9ad\n\t'_L_lock_25' 56f3fc16\n\t'if_nameindex' 56f40ba0\n\t'inet6_option_init' 56f41ee0\n\t'setsourcefilter' 56f42720\n\t'authnone_create_once' 56f43340\n\t'xdr_authunix_parms' 56f43b70\n\t'clntraw_geterr' 56f448e0\n\t'clnttcp_freeres' 56f44fc0\n\t'clntudp_freeres' 56f45930\n\t'pmap_unset' 56f46810\n\t'pmap_rmtcall' 56f47720\n\t'__rpc_thread_variables' 56f480a0\n\t'svcerr_weakauth' 56f483b0\n\t'xprt_unregister' 56f48920\n\t'svcraw_getargs' 56f48e30\n\t'svctcp_freeargs' 56f495e0\n\t'svctcp_rendezvous_abort' 56f49c40\n\t'svcudp_recv' 56f4a4f0\n\t'xdr_u_longlong_t' 56f4ab90\n\t'xdr_wrapstring' 56f4afb0\n\t'xdrmem_setpos' 56f4b520\n\t'skip_input_bytes' 56f4b7c0\n\t'xdrrec_getbytes' 56f4bb50\n\t'xdrstdio_create' 56f4c150\n\t'xdrstdio_getpos' 56f4c400\n\t'x_destroy' 56f4c790\n\t'xdr_authdes_cred' 56f4d030\n\t'key_get_conv' 56f4e400\n\t'_L_unlock_445' 56f4e8df\n\t'xdr_keystatus' 56f4ec90\n\t'_svcauth_des' 56f4f730\n\t'clntunix_create' 56f50340\n\t'svcunixfd_create' 56f50ed0\n\t'_create_xid' 56f516a0\n\t'xdr_uint8_t' 56f51ac0\n\t'__nscd_gethostbyname2_r' 56f52fd0\n\t'get_mapping' 56f53dc0\n\t'getutent' 56f546c0\n\t'endutent' 56f549f0\n\t'getutline' 56f54b40\n\t'__utmp_equal' 56f55040\n\t'updwtmp' 56f55fb0\n\t'setutxent' 56f56cb0\n\t'dl_iterate_phdr' 56f56e70\n\t'__libc_dlopen_mode' 56f57510\n\t'fde_unencoded_compare' 56f57b40\n\t'__register_frame' 56f58350\n\t'_L_lock_136' 56f59129\n\t'_Unwind_GetIP' 56f591e0\n\t'read_uleb128' 56f59b50\n\t'_IO_old_cookie_seek' 56f59eb0\n\t'_L_lock_68' 56f5a7ea\n\t'_L_lock_36' 56f5ab9c\n\t'_IO_file_xsputn' 56f5af40\n\t'_IO_old_file_finish' 56f5bae0\n\t'versionsort64' 56f5c090\n\t'sched_setaffinity' 56f5d210\n\t'getspent_r' 56f5d550\n\t'gethostbyname2_r' 56f5d7f0\n\t'getservbyport_r' 56f5dbe0\n\t'free_mem' 56f5dff0\n\t'free_mem' 56f5e5c0\n\t'_L_unlock_44' 56f5e905\n\t'__rpc_thread_destroy' 56f5ec70\nEND_RTN_LIST\nU '/disk/PinTools/Utils/obj-ia32/cp-pin'\nU '/lib/ld-linux.so.2'\nU '/usr/lib/libstdc++.so.6'\nU '/lib/libm.so.6'\nU '/lib/libgcc_s.so.1'\nU '/lib/libc.so.6'\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Debugger/makefile.rules": "##############################################################\n#\n# This file includes all the test targets as well as all the\n# non-default build rules and test recipes.\n#\n##############################################################\n\n###### Additional includes that are specific to this directory ######\n\ninclude $(TOOLS_ROOT)/Config/makefile.debug.rules\n\n\n##############################################################\n#\n# Test targets\n#\n##############################################################\n\n###### Place all generic definitions here ######\n\n# This defines tests which run tools of the same name.  This is simply for convenience to avoid\n# defining the test name twice (once in TOOL_ROOTS and again in TEST_ROOTS).\n# Tests defined here should not be defined in TOOL_ROOTS and TEST_ROOTS.\nTEST_TOOL_ROOTS :=\n\n# This defines the tests to be run that were not already defined in TEST_TOOL_ROOTS.\nTEST_ROOTS :=\n\n# This defines the tools which will be run during the the tests, and were not already defined in\n# TEST_TOOL_ROOTS.\nTOOL_ROOTS :=\n\n# This defines the static analysis tools which will be run during the the tests. They should not\n# be defined in TEST_TOOL_ROOTS. If a test with the same name exists, it should be defined in\n# TEST_ROOTS.\n# Note: Static analysis tools are in fact executables linked with the Pin Static Analysis Library.\n# This library provides a subset of the Pin APIs which allows the tool to perform static analysis\n# of an application or dll. Pin itself is not used when this tool runs.\nSA_TOOL_ROOTS :=\n\n# This defines all the applications that will be run during the tests.\nAPP_ROOTS :=\n\n# This defines any additional object files that need to be compiled.\nOBJECT_ROOTS :=\n\n# This defines any additional dlls (shared objects), other than the pintools, that need to be compiled.\nDLL_ROOTS :=\n\n# This defines any static libraries (archives), that need to be built.\nLIB_ROOTS :=\n\n###### Place OS-specific definitions here ######\n\n# Linux\nifeq ($(TARGET_OS),linux)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize simple execfail fork breaktool breaktool_const_context \\\n                  breaktool-wait breaktool-nodebugger bp-icount action-pending thread launch-gdb stack-debugger pindb-zmm \\\n                  debugger-shell-breakpoints debugger-shell-tracepoints start-fini intercept-breakpoint emu-simple ymm zmm \\\n                  pc-change-bp pc-change-async interpreter-remove mt-exit debugger-type signal-step siginfo xmm-$(TARGET) \\\n                  pindb-attach-after-custom-stop allow-remote set-mode gdb-detach-reattach invalid-write bptest-$(TARGET) \\\n                  pindb-pthread-step-exit gdb-pthread-step-exit pindb-pthread-cont-exitgroup pindb-pthread-step-exitgroup \\\n                  simultaneous-toolbreak simultaneous-toolbreak-squash simultaneous-toolbreak-change \\\n                  simultaneous-toolbreak-attach pindb-simultaneous-multi pindb-simultaneous-multi-serialize \\\n                  pindb-simultaneous-toolbreak-attach launch-gdb_const_context ymm_with_set_xmm_scratch_regs_tool \\\n                  watchpoint_const_context simultaneous-toolbreak_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                  xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                  app-pause-in-app-thread app-pause-in-int-thread bphandler gdb-svr4-libraries-extension simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  breaktool int3-count action-pending-tool checkpoint watchpoint launch-gdb-tool intercept-tool \\\n                  pc-change-async-tool interpreter-remove mt-exit-tool debugger-type set-mode-tool invalidate-regs \\\n                  set_xmm_scratches set_xmm_scratches_before_breakpoint set_xmm_scratches_before_breakpoint_and_set_xmm_reg \\\n                  set_xmm_scratches_for_ymmtest null-emulator-$(TARGET) \\\n                  app-pause-in-app-thread-tool app-pause-in-int-thread-tool library-load-tool\n    APP_ROOTS += simple-pindb simple simple-static exec fork action-pending-app thread checkpoint-app bptest-$(TARGET) \\\n                 watchpoint-app callerapp fibonacci sleep-unix intercept-app pc-change-bp pc-change-async xmm-$(TARGET) \\\n                 mt-exit signal-catch reattach-loop pthread-bare-exit pthread-bare-exitgroup thread-$(OS_TYPE) \\\n                 ymm-$(TARGET) zmm-$(TARGET) debugger-shell-app-$(TARGET) app-pause-app pick-random-port bphandler_app \\\n                 dlopen-dlclose\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) zmm-asm-$(TARGET)\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\n\n    ifeq ($(shell $(TOOLS_ROOT)/Utils/testStaticLibs), 1)\n        TEST_ROOTS := $(filter-out bp-icount, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out int3-count, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out simple-static, $(APP_ROOTS))\n    endif\nendif\n\n# macOS*\nifeq ($(TARGET_OS),mac)\n    TEST_ROOTS += app-pause-in-app-thread app-pause-in-int-thread \\\n                  simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-pthread-step-exit pindb-pthread-cont-exitgroup \\\n                  pindb-pthread-step-exitgroup pindb-simultaneous-multi pindb-simultaneous-multi-serialize pindb-zmm \\\n                  simple execfail fork breaktool bphandler stack-debugger debugger-type simple-pindb-attach\n# pindb-attach-after-custom-stop pindb-simultaneous-toolbreak-attach\n    TOOL_ROOTS += app-pause-in-app-thread-tool app-pause-in-int-thread-tool default_mac_tool simple-command-tool \\\n                  invalidate-regs use-debugger-shell breaktool bphandler stack-debugger debugger-type\n    APP_ROOTS += app-pause-app simple simple-pindb thread-$(OS_TYPE) pthread-bare-exit pthread-bare-exitgroup \\\n    \t\t\t zmm-$(TARGET) bphandler_app fibonacci\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) zmm-asm-$(TARGET)\nendif\n\n# Windows\nifeq ($(TARGET_OS),windows)\n    TEST_TOOL_ROOTS += stop-resume-when-suspended check-if-thread-stopped\n    TEST_ROOTS += simple-pindb-launch pindb-start-fini pindb-noprompt-kill pindb-detach pindb-abrupt-disconnect \\\n                  pindb-kill-like-gdb pindb-simple-command pindb-step-custom-break pindb-simultaneous-toolbreak \\\n                  pindb-simultaneous-toolbreak-serialize pindb-simultaneous-toolbreak-squash pindb-invalidate-regs \\\n                  pindb-simultaneous-toolbreak-change pindb-simultaneous-toolbreak-step pindb-simple-simultaneous-multi \\\n                  pindb-simple-simultaneous-multi-serialize pindb-win-unhandled-exception pindb-win-handled-exception \\\n                  pindb-win-continued-exception1 pindb-win-continued-exception2 pindb-win-software-exception \\\n                  pindb-win-cpp-exception pindb-win-squash-exception pindb-win-step-exception pindb-zmm \\\n                  pindb-win-library-notifications pindb-win-step-library pindb-win-thread-stress \\\n                  pindb-win-exception-after-exit app-pause-in-app-thread app-pause-in-int-thread simple-pindb-attach\n    TOOL_ROOTS += stack-debugger start-fini-callback simple-command-tool use-debugger-shell simultaneous-toolbreak \\\n                  invalidate-regs app-pause-in-app-thread-tool app-pause-in-int-thread-tool\n    APP_ROOTS += simple-pindb simple win-unhandled-exception win-handled-exception win-continued-exception1 \\\n                 win-continued-exception2 win-software-exception win-cpp-exception win-load-library \\\n                 win-thread-stress thread-$(OS_TYPE) app-pause-app win-exception-after-exit zmm-$(TARGET)\n    OBJECT_ROOTS += simple-pindb-asm-$(TARGET) win-foo-library zmm-asm-$(TARGET)\n    DLL_ROOTS += win-foo-library win-exception-after-exit-dll\n    ifeq ($(TARGET),ia32)\n        TEST_ROOTS += access-64-on-32\n    endif\nendif\n\n###### Handle exceptions here ######\n\n\nifeq ($(TARGET_OS),windows)\n    #pindb-win-step-exception fails on pinw32-12. Mantis: 3072. \n    TEST_ROOTS := $(filter-out pindb-win-step-exception, $(TEST_ROOTS))\n    # This test is disabled until Mantis 1839 is fixed.\n    TEST_ROOTS := $(filter-out simple-pindb-attach, $(TEST_ROOTS))\n    # This test is disabled until Mantis 4566 is fixed\n    TEST_TOOL_ROOTS := $(filter-out stop-resume-when-suspended, $(TEST_TOOL_ROOTS))\nendif\n\n# There is a bug with PinADX when using early-injection (the default) on 32-bit applications when running\n# on a 64-bit host and when using versions of Windows earlier than Vista.  That bug causes this test to\n# fail, so we disable it in this case.  We can re-enable this test when Mantis #2385 is fixed.\n#\nosname := $(shell uname -s)\nifeq ($(findstring CYGWIN_NT-5,$(osname))-$(HOST_ARCH)-$(TARGET),CYGWIN_NT-5-intel64-ia32)\n    TEST_ROOTS := $(filter-out pindb-start-fini, $(TEST_ROOTS))\nendif\n\nifeq ($(TARGET_OS),linux)\n    GDB_VERSION_IF_BEFORE_66 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 6.6)\n    GDB_VERSION_IF_BEFORE_74 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 7.4)\n    GDB_VERSION_IF_BEFORE_80 := $(shell $(TOOLS_ROOT)/Utils/testToolVersion $(GDB) le 8.0)\n    ifeq ($(GDB_VERSION_IF_BEFORE_66),1)\n#   Versions of gdb older than 6.6 do not understand the XMM registers, so disable the xmm tests.\n#\n        TEST_ROOTS := $(filter-out xmm-$(TARGET) xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                   xmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg, \\\n                                   $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out set_xmm_scratches_before_breakpoint \\\n                                   set_xmm_scratches_before_breakpoint_and_set_xmm_reg set_xmm_scratches, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out xmm-$(TARGET), $(APP_ROOTS))\n    endif\n    ifeq ($(GDB_VERSION_IF_BEFORE_74),1)\n#   Versions of gdb older than 7.4 do not understand svr4 libraries query\n#\n        TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n        TOOL_ROOTS := $(filter-out library-load-tool, $(TOOL_ROOTS))\n        APP_ROOTS := $(filter-out dlopen-dlclose, $(APP_ROOTS))\n    endif\n    ifeq ($(GDB_VERSION_IF_BEFORE_80),1)\n#   Versions of gdb older than 8.0 do not support AVX512 registers\n#\n        TEST_ROOTS := $(filter-out zmm, $(TEST_ROOTS))\n    endif\nendif\n\nifeq ($(TARGET_OS),linux)\n    # See mantis 4613\n    TEST_ROOTS := $(filter-out gdb-svr4-libraries-extension, $(TEST_ROOTS))\n    \n    ifeq ($(DIST_NAME_RHEL),1)\n        ifeq ($(TARGET),ia32)\n            DIST_VER_75_OR_76 := $(shell $(TOOLS_ROOT)/Utils/testLinuxDistVersion eq 7.5)\n            ifeq ($(DIST_VER_75_OR_76),0)\n                DIST_VER_75_OR_76 := $(shell $(TOOLS_ROOT)/Utils/testLinuxDistVersion eq 7.6)\n            endif\n            \n            ifeq ($(DIST_VER_75_OR_76),1)\n                # Disable 32 bit tests on rhel7.5 & thel7.6 - see mantis 4677\n                TEST_ROOTS := $(filter-out action-pending allow-remote bphandler bptest-ia32 breaktool_const_context \\\n                                  breaktool-wait breaktool debugger-shell-breakpoints debugger-shell-tracepoints execfail fork \\\n                                  gdb-detach-reattach gdb-pthread-step-exit intercept-breakpoint invalid-write pc-change-async \\\n                                  pc-change-bp set-mode siginfo signal-step simple simultaneous-toolbreak_const_context \\\n                                  simultaneous-toolbreak-change simultaneous-toolbreak-squash simultaneous-toolbreak \\\n                                  stack-debugger thread watchpoint_const_context \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context \\\n                                  xmm-ia32_with_set_xmm_scratch_regs_before_breakpoint_tool xmm-ia32 \\\n                                  ymm_with_set_xmm_scratch_regs_tool ymm pindb-simultaneous-toolbreak, $(TEST_ROOTS))\n            endif\n        endif\n    endif\n    \nendif\n\n###### Define the sanity subset ######\n\n# This defines the list of tests that should run in sanity. It should include all the tests listed in\n# TEST_TOOL_ROOTS and TEST_ROOTS excluding only unstable tests.\nSANITY_SUBSET := $(TEST_TOOL_ROOTS) $(TEST_ROOTS)\n\nifeq ($(TARGET_OS),mac)\n    # See mantis 4598\n    SANITY_SUBSET := $(filter-out pindb-simultaneous-toolbreak pindb-simultaneous-toolbreak-serialize \\\n                                  pindb-simultaneous-toolbreak-squash pindb-simultaneous-toolbreak-change \\\n                                  pindb-simultaneous-toolbreak-step, $(SANITY_SUBSET))\n\n    ifeq ($(TARGET),ia32)\n        # See mantis 4589\n        SANITY_SUBSET := $(filter-out fork breaktool simple, $(SANITY_SUBSET))\n        # See mantis 4601\n        SANITY_SUBSET := $(filter-out stack-debugger, $(SANITY_SUBSET))\n        # See mantis 4602\n        SANITY_SUBSET := $(filter-out pindb-invalidate-regs, $(SANITY_SUBSET))\n    endif\n\n    # See mantis 4679\n    SANITY_SUBSET := $(filter-out pindb-simultaneous-multi-serialize, $(SANITY_SUBSET))\nendif\n\nifeq ($(TARGET_OS),windows)\n    # See mantis 4570\n    SANITY_SUBSET := $(filter-out pindb-zmm, $(SANITY_SUBSET))\nendif\n\n\n##############################################################\n#\n# Test recipes\n#\n##############################################################\n\n# This section contains recipes for tests other than the default.\n# See makefile.default.rules for the default test rules.\n# All tests in this section should adhere to the naming convention: <testname>.test\n\n# This is a time limit (in seconds) we use for some of the tests below.  It's intentionally high\n# to avoid timeouts when the system load is very high, which can happen in our nightly tests.\n#\n\nTLIMIT := 120\n\nifeq ($(TARGET_OS),mac)\n    BATCH_CMD_CONNECT_REMOTE :=gdb-remote\n    BATCH_CMD_TIMEOUT_LIMIT:=\n    DBG:=lldb\n    DBG_STR:=$(DBG)\n    DBG_CMD_SRC_FLAG:=-s\n    DBG_CMD_MORE_FLAGS:=-x --batch\n    DEFAULT_TOOL:=$(OBJDIR)default_mac_tool$(PINTOOL_SUFFIX)\n    PIN_CMD_DEFAULT_TOOL:= -t $(DEFAULT_TOOL)\n    COMPARE_RE_FILE_SUFFIX:=.lldb \nendif\nifeq ($(TARGET_OS),linux)\n    BATCH_CMD_CONNECT_REMOTE :=target remote\n    BATCH_CMD_TIMEOUT_LIMIT:= set remotetimeout $(TLIMIT)\n    DBG:=$(GDB)\n    DBG_STR:=gdb\n    DBG_CMD_SRC_FLAG=-x\n    DBG_CMD_MORE_FLAGS:=-n -batch\n    COMPARE_RE_FILE_SUFFIX:=\nendif\n\n# This is the example tool from the manual run such that you can attach the debugger after it triggers a stack\n# breakpoint.\n#\nstack-debugger-late.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_silent -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -stackbreak 4000 -o $(OBJDIR)$(@:.test=.toolout) -timeout $(TLIMIT) \\\n\t    -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.toolout) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.toolout) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test of debugger features.\n#\nsimple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test for breakpoint handling features.\n#\nbphandler.test: $(OBJDIR)bphandler$(PINTOOL_SUFFIX) $(OBJDIR)bphandler_app$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)bphandler$(PINTOOL_SUFFIX) -- $(OBJDIR)bphandler_app$(EXE_SUFFIX) > \\\n      $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)bphandler_app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify we can debug across a failed exec() call.\n#\nexecfail.test: $(OBJDIR)exec$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -follow_execv $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)exec$(EXE_SUFFIX) ./does-not-exist > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)exec$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify we can debug across a parent call to fork().\n#\nfork.test: $(OBJDIR)fork$(EXE_SUFFIX) $(DEFAULT_TOOL)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) $(PIN_CMD_DEFAULT_TOOL) -- $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fork$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Basic test of PIN_ApplicationBreakpoint()\n#\nbreaktool.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nbreaktool_const_context.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 -const_context 1 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that PIN_ApplicationBreakpoint(.., TRUE, ..) will wait if there's no debugger.\n#\nbreaktool-wait.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.out) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) &\n\tcount=0; \\\n\tuntil $(BASHTEST) -s $(OBJDIR)$(@:.test=.out) -o $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tsleep 5\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tport=`cat $(OBJDIR)$(@:.test=.out)`; echo \"target remote :$$port\" >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that PIN_ApplicationBreakpoint(.., FALSE, ..) does not wait if there's no debugger.\n#\nbreaktool-nodebugger.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -wait_for_debugger 0 \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX)\n\n# Test breakpoints in various circumstances.\n#\nbptest-$(TARGET).test: $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.)$(COMPARE_EXT) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that breakpoints do not cause the tool to see any extra instructions (e.g. INT3).\n#\nbp-icount.test: $(OBJDIR)simple-static$(EXE_SUFFIX) $(OBJDIR)int3-count$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.reference \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)int3-count$(PINTOOL_SUFFIX) -func main -o $(OBJDIR)bp-icount.count \\\n\t  -- $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(CMP) $(OBJDIR)bp-icount.reference $(OBJDIR)bp-icount.count\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_IsActionPending() API.\n#\naction-pending.test: $(OBJDIR)action-pending-app$(EXE_SUFFIX) $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)action-pending-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)action-pending-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)action-pending-app$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can print out XMM registers.  Older GDB's don't know how to print XMM registers well,\n# so use a modern GDB for this test.\n#\n# We first test that GDB itself will run.  If not, we just skip the body of this test.  The modern\n# GDB won't run on some old test systems.\n#\nxmm-$(TARGET).test: $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(QGREP) \"regular_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_const_context.test: $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out -const_context 1 \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"did setApplicationBreakpoint\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(QGREP) \"const_context\" $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches_before_breakpoint_const_context.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_before_breakpoint_tool_and_set_xmm_reg.test: $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(QGREP) \"$$1 = 0x[0]*3f800000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$2 = 0x[0]*40000000\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$3 = 0xff00ff000a550a55123456789abcdef0\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"$$4 = 0x5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"exited normally.\" $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) \"instrumented the movdqa\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool got the expected gdb command\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(QGREP) \"tool properly set xmm3\" $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratch_regs_before_breakpoint_tool_set_xmm_reg.out\n\nxmm-$(TARGET)_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN)  $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX) \\\n\t  -output_filename $(OBJDIR)set_xmm_scratches.out \\\n\t    -- $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(QGREP) instrumented $(OBJDIR)set_xmm_scratches.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)set_xmm_scratches.out\n\n# Simple test of a threaded program.\n#\nthread.test: $(OBJDIR)thread$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat thread.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Simple test of a threaded program built statically (uses non-nptl thread package on Linux).\n# NOTE: This test is disabled, so it does not run automatically.  Modern versions of GDB do not\n#   support non-nptl threads well.\n#\nthread-static.test: $(OBJDIR)thread-static$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat thread.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-static$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p thread.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Simple test of the 'pindb' debugger.  We launch Pin separatly and pindb attaches.\n#\nsimple-pindb-attach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare)\n\t$(PYTHON) launch-pin-attach-debugger.py --pin=$(BARE_PIN) --pin-exe=$(BARE_PIN) \\\n\t    --pindb=$(PINDB) --pindb-libpath=$(PINDB_LIBPATH) \\\n\t    --tool=$(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) --app=$(OBJDIR)simple-pindb$(EXE_SUFFIX) \\\n\t    --cpu=$(TARGET) --timeout=$(TLIMIT) \\\n\t    --pin-out=$(OBJDIR)$(@:.test=.out) --pindb-in=$(OBJDIR)$(@:.test=.pindbin) \\\n\t    --pindb-out=$(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.pindbout)\n\n# Simple test of the 'pindb' debugger.  We use the pindb \"run\" command to launch and attach to pin.\n#\nsimple-pindb-launch.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) basic $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbout) \\\n\t      $(OBJDIR)$(@:.test=.pindbin)\n\n# Test the checkpoint tool.\n#\ncheckpoint.test: $(OBJDIR)checkpoint-app$(EXE_SUFFIX) $(OBJDIR)checkpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)checkpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)checkpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p checkpoint-gdb.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p checkpoint-app.compare -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the watchpoint tool.\n#\nwatchpoint.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app 1 > $(OBJDIR)$(@:.test=.$(DBG_STR))\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.$(DBG_STR))\n\nwatchpoint_const_context.test: $(OBJDIR)watchpoint-app$(EXE_SUFFIX) $(OBJDIR)watchpoint$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)watchpoint-app$(EXE_SUFFIX) 1 > $(OBJDIR)$(@:.test=.$(DBG_STR))\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)watchpoint$(PINTOOL_SUFFIX) -const_context 1 \\\n\t  -- $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)watchpoint-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.$(DBG_STR))\n\n# This test starts Pin with debugger support enabled, but Pin does not stop at\n# the first instruction waiting for a debugger to attach.  Instead, the\n# application runs under Pin immediately.  Later, if the tool finds something\n# interesting, it can ask the user (or a GUI shell) to start the debugger and\n# attach at the interesting point.\n#\nlaunch-gdb.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This tests the -appdebug_server_port <PORT> option of PIN.\n# We pick an available TCP port randomly, then we run PIN with -appdebug_server_port specifying the random port\n# We expect to connect with GDB to the port we specified\n#\ngdb-fixed-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we.\n# provide a port which is already taken by another application\n# We expect PIN to fail because it won't acquire the port\n#\ngdb-fixed-port-used.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) used > $(OBJDIR)$(@:.test=.random)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Unable to create debugger connection\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.random)\n\n# This tests the -appdebug_server_port <PORT> option of PIN when we\n# provide an invalid TCP port number.\n# We expect PIN to fail because the TCP port number is invalid\n#\ngdb-fixed-bad-port.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t! ( $(PIN) $(PINFLAGS_DEBUG_RUNFREE) -appdebug_server_port 100000 -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) \\\n\t    -timeout $(TLIMIT) -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) )\n\t$(QGREP) \"E:Invalid TCP server port: 100000\" $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\nlaunch-gdb_const_context.test: $(OBJDIR)callerapp$(EXE_SUFFIX) $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)launch-gdb-tool$(PINTOOL_SUFFIX) -const_context 1 -timeout $(TLIMIT) \\\n\t  -o $(OBJDIR)$(@:.test=.$(DBG_STR)in) -- $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.$(DBG_STR)in) > /dev/null 2>&1 || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)callerapp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# This is the example tool we describe in the manual, which demonstrates the major features\n# of the application-level debugging API.  The tool tracks the application's stack usage\n# and allows breakpoints to be set when the stack usage crosses a threshold.\n#\nstack-debugger.test: $(OBJDIR)fibonacci$(EXE_SUFFIX) $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)stack-debugger$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)fibonacci$(EXE_SUFFIX) 1000 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)fibonacci$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can asynchronously stop the target in PinDB by sending CTRL-C (SIGINT).\n# TODO: This is disabled until Mantis #2055 is fixed.\n#\npindb-async-stop.test: $(OBJDIR)sleep-unix$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)sleep-unix$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout) & \\\n\t    pid=$$!; \\\n\t    sleep 2; \\\n\t    while kill -INT $$pid > /dev/null 2>&1; \\\n\t    do \\\n\t        sleep 2; \\\n\t    done; \\\n\t    wait\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test of breakpoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-breakpoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) breakpoints $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test of tracepoint commands in the \"debugger-shell\" instrumentation library.\n#\ndebugger-shell-tracepoints.test: $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) tracepoints $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in.0) $(OBJDIR)$(@:.test=.compare) \\\n\t      $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called even when GDB\n# immediately terminates the application .\n#\nstart-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) & \\\n\t    count=0; \\\n\t    until $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t        do sleep 1; count=`expr $$count + 1`; done; \\\n\t    echo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    cat quit.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in); \\\n\t    $(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1; \\\n\twait\n\t$(CMP) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that the thread-start, thread-fini, and fini call-backs are correctly called when PinDB\n# immediately terminates the application (tested on both Linux and Windows).\n#\npindb-start-fini.test: $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)start-fini-callback$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(DIFF) start-fini.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\nstop-resume-when-suspended.test: $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)stop-resume-when-suspended$(PINTOOL_SUFFIX) \\\n\t    -o $(OBJDIR)$(@:.test=.toolout)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(DIFF) stop-resume-when-suspended.reference $(OBJDIR)$(@:.test=.toolout)\n\t$(QGREP) \"Sum is 55\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.toolout) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that PIN_InterceptDebuggingEvent() can intercept and squash breakpoints.\n#\nintercept-breakpoint.test: $(OBJDIR)intercept-app$(EXE_SUFFIX) $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)intercept-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)intercept-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=-gdb.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_AddDebuggerRegisterEmulator() API.  This test is legal to run with any version of GDB,\n# but it only tests the API well when run with a GDB that supports register extensions in the XML\n# \"feature document\".  This includes GDB 7.2 and later, and a few special earlier distributions.\n#\nemu-simple.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)null-emulator-$(TARGET)$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that the debugger can print the value of a YMM register when running on native AVX hardware.\n# This test will pass even when run on non-AVX hardware.  However, it's only effective when run on\n# AVX hardware and when run with a GDB that supports AVX.\n#\nymm.test: $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nymm_with_set_xmm_scratch_regs_tool.test: $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tcat set_xmm_scratches_for_ymmtest.out\n\t$(QGREP) instrumented set_xmm_scratches_for_ymmtest.out\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f instrumented set_xmm_scratches_for_ymmtest.out\n\n# Verify that the debugger can print the value of a ZMM register when running on native AVX512 hardware.\n# This test will pass even when run on non-AVX512 hardware.  However, it's only effective when run on\n# AVX512 hardware and when run with a GDB that supports AVX512.\n#\nzmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t-$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tif ! $(QGREP) \"HandleSigill\" $(OBJDIR)$(@:.test=.$(DBG_STR)out) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\npindb-zmm.test: $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\n\techo \"set pinargs \" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tif ! $(QGREP) \"Processor does not support AVX512\" $(OBJDIR)$(@:.test=.pindbout) ; then \\\n\t  $(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout); \\\n\tfi\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Verify that the debugger change the the PC when stopped after an indirect JMP instruction.\n#\npc-change-bp.test: $(OBJDIR)pc-change-bp$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pc-change-bp$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that the tool can change the PC from an ASYNC_BREAK intercept function when the thread\n# is stopped after an indirect JMP instruction.\n#\npc-change-async.test: $(OBJDIR)pc-change-async$(EXE_SUFFIX) $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)pc-change-async-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pc-change-async$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test the PIN_RemoveDebugInterpreter() API.\n#\ninterpreter-remove.test: $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -appdebug -t $(OBJDIR)interpreter-remove$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t  do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\techo 'monitor bdio' >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\techo 'c' >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > /dev/null 2>&1\n\t! $(GREP) 'PIN_RemoveDebugInterpreter failed' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\n# Verify that GDB can terminate an application where one thread is blocked in\n# a system call.  Previously, the Pin process would sometimes hang when this\n# happened, so the test checks that the process exits.  (Note, \"kill -s 0 <pid>\"\n# just checks if a process exists, it doesn't send a signal.)\n#\nmt-exit.test: $(OBJDIR)mt-exit$(EXE_SUFFIX) $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.toolout)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)mt-exit-tool$(PINTOOL_SUFFIX) -o $(OBJDIR)$(@:.test=.toolout) \\\n\t  -- $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)mt-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\tpid=`cat $(OBJDIR)$(@:.test=.toolout)`; \\\n\tcount=0; \\\n\tuntil ! kill -s 0 $$pid > /dev/null 2>&1 || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done; \\\n\t$(BASHTEST) $$count -le $(TLIMIT)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out) $(OBJDIR)$(@:.test=.toolout)\n\n# Simple test of the PIN_GetDebuggerType() API.\n#\ndebugger-type.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)debugger-type$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)debugger-type$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(GREP) -i 'Debugger Type is $(DBG_STR)' $(OBJDIR)$(@:.test=.out) > /dev/null\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can single-step into a signal handler.\n#\nsignal-step.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that GDB can print $_siginfo and get the signal information structure from Pin.\n#\nsiginfo.test: $(OBJDIR)signal-catch$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)signal-catch$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that PinDB can attach after the Pin tool has stopped at a custom breakpoint and that PinDB\n# can still get the tool's custom stop message (see Mantis #2357).\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-attach-after-custom-stop.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)breaktool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)breaktool$(PINTOOL_SUFFIX) -where main -wait_for_debugger 1 -port $(OBJDIR)$(@:.test=.port) \\\n\t    -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Tool stopping at breakpoint' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows unhandled exception with PinDB.\n#\npindb-win-unhandled-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows handled exception with PinDB.\n#\npindb-win-handled-exception.test: $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-handled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter continues the search.\npindb-win-continued-exception1.test: $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception1$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows continued exception with PinDB.  The exception filter executes the handler.\npindb-win-continued-exception2.test: $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-continued-exception2$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows software exception with PinDB.  The exception is raised via RaiseException() and is unhandled.\n#\npindb-win-software-exception.test: $(OBJDIR)win-software-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-software-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test Windows C++ exception with PinDB.\n#\npindb-win-cpp-exception.test: $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-cpp-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to squash a Windows exception.  Squashing a first-chance exception re-executes\n# the excepting instruction, which raises a new first-chance exception.  Squashing a last-chance\n# exception also re-executes the excepting instruction, which raises a new first-chance exception.\n#\npindb-win-squash-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows exception.  Stepping from a first-chance\n# exception should go to the first instruction in the handler.  Stepping from a last-chance\n# exception should cause the application to terminate.\n#\npindb-win-step-exception.test: $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-unhandled-exception$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that Pin properly handles exception which happens after beginning of process exit flow\n# when PinADX is disabled.\n#\npindb-win-exception-after-exit.test: $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-exception-after-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 2\n\t$(QGREP) \"Caught exception C0000005\" $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test DLL load / unload notifications with PinDB.\n#\npindb-win-library-notifications.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test ability to single-step after receiving a Windows library load / unload notification.\n#\npindb-win-step-library.test: $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-load-library$(EXE_SUFFIX) $(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure PinDB does not wait for confirmation when killing the target process when --noprompt is specified.\n#\npindb-noprompt-kill.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the -appdebug_allow_remote knob, which allows GDB to run on a different machine than Pin.\n# However, it's difficult to actually run GDB on a different machine as part of this test, so\n# we still run them both on the same machine.\n#\nallow-remote.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_allow_remote -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Verify that Pin doesn't crash if the debugger attempts to access a 64-bit address for a 32-bit Pin process.\n#\naccess-64-on-32.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Make sure we can ebable debugging via PIN_SetDebugMode() from the tool.  This test should\n# be run without -appdebug.\n#\nset-mode.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) -t $(OBJDIR)set-mode-tool$(PINTOOL_SUFFIX) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat simple.$(DBG_STR) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(PYCOMPARE) -p simple.compare -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that PinDB can detach from Pin.\n#\npindb-detach.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) detach $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.pindbin.0) \\\n\t      $(OBJDIR)$(@:.test=.compare)\n\n# Abruptly disconnect PinDB from Pin.  This simulates the behavior when the debugger unexpectedly dies.\n# We expect an error from Pin, but Pin shouldn't hang.\n#\npindb-abrupt-disconnect.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs -logfile $(OBJDIR)$(@:.test=.pin.log) $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(SYNC)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pin.log) $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the \"kill-like-gdb\" command in PinDB.  This sends the same legacy \"kill\" command to PinADX that\n# GDB uses.\n#\npindb-kill-like-gdb.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(@:.test=-1.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(@:.test=-2.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) \\\n\t      $(OBJDIR)$(@:.test=-1.$(DBG_STR)out) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\n# Test that GDB can detach from Pin and then re-attach later.\n#\ngdb-detach-reattach-fixed-port.test: $(OBJDIR)reattach-loop$(EXE_SUFFIX) $(OBJDIR)pick-random-port$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(OBJDIR)pick-random-port$(EXE_SUFFIX) unused > $(OBJDIR)$(@:.test=.random)\n\t$(PIN) $(PINFLAGS_DEBUG) -appdebug_server_port `cat $(OBJDIR)$(@:.test=.random)` -- \\\n\t    $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` \\\n\t    $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(GREP) 'target remote :'`cat $(OBJDIR)$(@:.test=.random)` $(OBJDIR)$(@:.test=.out) > $(OBJDIR)$(@:.test=.port)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\tcat $(@:.test=-1.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-1.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(OBJDIR)$(@:.test=.port) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\tcat $(@:.test=-2.$(DBG_STR)) >> $(OBJDIR)$(@:.test=-2.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)reattach-loop$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-1.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-1.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-gdb-2.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=-2.$(DBG_STR)out)\n\t$(PYCOMPARE) -p $(@:.test=-app.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port) $(OBJDIR)$(@:.test=-1.$(DBG_STR)in) \\\n\t    $(OBJDIR)$(@:.test=-1.$(DBG_STR)out) $(OBJDIR)$(@:.test=-2.$(DBG_STR)in) $(OBJDIR)$(@:.test=-2.$(DBG_STR)out) \\\n\t    $(OBJDIR)$(@:.test=.random)\n\n# Test that extended commands work using PinDB.  This also checks that the tool does _not_ receive\n# commands that start with the \"pin \" prefix.\n#\npindb-simple-command.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simple-command-tool$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that the debugger can write to an invalid address in the application.\n#\ninvalid-write.test: $(OBJDIR)simple$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t-$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)simple$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Try debugging an application with lots of threads that exit at the same time.\n#\npindb-win-thread-stress.test: $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)win-thread-stress$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the calling thread while another thread\n# still exists.  We expect the debugger to stop after the thread exits, leaving the focus on\n# the one remaining thread.\n#\npindb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Same test as above, but use GDB instead of PinDB.\n#\ngdb-pthread-step-exit.test: $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -- $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)pthread-bare-exit$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can debug an application where one thread exits the entire process\n# while another thread still exists.\n#\npindb-pthread-cont-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that exits the entire process while\n# another thread still exists.  We expect the debugger to stop after the exit call\n# and indicate that the process is terminated.\n#\npindb-pthread-step-exitgroup.test: $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Test that we can single-step over an instruction that triggers a custom breakpoint.\n# This should stop due to the custom breakpoint, without stepping over the instruction.\n# A subsequent step should skip the custom breakpoint and step over the instruction.\n#\npindb-step-custom-break.test: $(OBJDIR)simple-pindb$(EXE_SUFFIX) $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\n\t$(OBJDIR)simple-pindb$(EXE_SUFFIX) step-custom-break $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple-pindb$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(OBJDIR)$(@:.test=.pindbin.0) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(OBJDIR)$(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin.0) $(OBJDIR)$(@:.test=.compare) $(OBJDIR)$(@:.test=.pindbin) \\\n\t      $(OBJDIR)$(@:.test=.pindbout)\n\n# Test the behavior when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test makes\n# sure that the pending events are delivered one-at-a-time to GDB.  It also\n# tests that the tool can list the pending breakpoints.\n#\nsimultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\nsimultaneous-toolbreak_const_context.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -const_context 1 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || test $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# squashes the pending breakpoints and then makes sure they are not\n# delivered to GDB.\n#\nsimultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# After one breakpoint is delivered, the others are pending.  This test\n# changes the message of the pending breakpoints and then makes sure they\n# are delivered with the new message.\n#\nsimultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Test that we can attach GDB to the application after it has stopped\n# at several simultaneous tool breakpoints.  We expect GDB to attach\n# at the context of one of those breakpoints, and we expect the others\n# to be pending.\n#\nsimultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) \\\n\t  -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 -wait_for_debugger \\\n\t    -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs with PinDB, which expects all breakpoints to be delivered\n# simultaneously.  Make sure that all 4 breakpoints are delivered at once,\n# and that none are pending.\n#\npindb-simultaneous-toolbreak.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test runs PinDB in a mode where each breakpoint is delivered one-\n# at-a-time (similar to GDB).  We make sure that there are pending breakpoints\n# after the first is delivered, and we make sure that all breakpoints are\n# delivered one-at-a-time.\n#\npindb-simultaneous-toolbreak-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we squash the remaining breakpoints after\n# the first is delivered and then make sure that the squashed breakpoints\n# are not delivered.\n#\npindb-simultaneous-toolbreak-squash.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# This test also runs PinDB in a mode where each breakpoint is delivered\n# one-at-a-time.  In this test, we change the message of the remaining\n# breakpoints after the first is delivered and then make sure that the\n# breakpoints are delivered with the changed message.\n#\npindb-simultaneous-toolbreak-change.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# Another test when several threads stop at simultaneous tool breakpoints.\n# When breakpoints are delivered one-at-a-time, try single-stepping one\n# thread while there are pending breakpoints on the others.  The pending\n# breakpoints should not be delivered because the single-step doesn't\n# advance the execution of those threads.\n#\npindb-simultaneous-toolbreak-step.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4\" \\\n\t  > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This is a stress test for simultaneous debugger events.  Each thread stops when\n# the thread is created, at a normal breakpoint, at a tool breakpoint, and stops\n# when the thread exits.  There is no serialization in this variant of the test,\n# so we expect that many events will be reported to the debugger simultaneously.\n# The test verifies that we get all the events.\n#\npindb-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  If a virus scan happens when this test runs,\n# the scanner injects a new thread into the test application.  If the debugger\n# stops when new threads are created, the scanner thread causes an extra stop in\n# the debugger which causes the test to fail.  This variant of the test avoids\n# the problem by not stopping in the debugger when new threads start or exit.\n# We also run this test on Unix because it tests different code paths in Pin.\n#\npindb-simple-simultaneous-multi.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n        $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is another stress test for simultaneous debugger events, similar to the\n# one above.  In this variant, Pin delivers the events one-at-a-time to the\n# debugger.  Again, we verifiy that the debugger gets them all.\n#\npindb-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare3) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare4) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This test is identical to the one above except that we don't stop when new\n# threads are created or when they exit.  We use this test on Windows to avoid\n# a problem with the virus scanner.  See \"pindb-simple-simultaneous-multi.test\"\n# for more information.  We also run it on Unix because it tests different code\n# paths in Pin.\n#\npindb-simple-simultaneous-multi-serialize.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 8\" >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -print-address > $(OBJDIR)$(@:.test=.address)\n\tsed \"s/GLOBAL_FUNCTION/`cat $(OBJDIR)$(@:.test=.address)`/\" $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --serialize-debugger-events --noprompt $(PINDB_USERFLAGS) \\\n\t    < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare1) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare2) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address)\n\n# This is similar to \"simultaneous-toolbreak-attach\", but we use PinDB\n# instead of GDB.  The application stops at several simultaneous breakpoints\n# before PinDB attaches.  Since PinDB allows multiple simultaneous breakpoints,\n# we expect all of them to be visible when PinDB attaches, and there will be\n# no pending breakpoints.\n#\n# This is disabled on Windows, but it could probably be enabled there when Mantis #1839 is fixed.\n#\npindb-simultaneous-toolbreak-attach.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out)\n\t$(PIN) $(PINFLAGS_DEBUG_RUNFREE) -t $(OBJDIR)simultaneous-toolbreak$(PINTOOL_SUFFIX) -sync_for_threads 4 \\\n\t  -wait_for_debugger -port $(OBJDIR)$(@:.test=.port) -- $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4 \\\n\t    > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) 'Waiting for debugger to attach' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    --gdb-protocol=:`cat $(OBJDIR)$(@:.test=.port)` $(PINDB_USERFLAGS) < $(@:.test=.pindbin) > \\\n\t    $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.address) \\\n\t  $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.port)\n\n# Test that we can use a custom command to change the register state of the target application,\n# and then use the \"invalidate registers\" API to invalidate any stale register data in the\n# debugger protocol library.\n#\npindb-invalidate-regs.test: $(OBJDIR)simple$(EXE_SUFFIX) $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)invalidate-regs$(PINTOOL_SUFFIX)\" > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)simple$(EXE_SUFFIX)\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) \\\n\t    --noprompt $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout)\n\n# This test validates stopping threads API called in application thread.\napp-pause-in-app-thread.test: $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-app-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by application thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\n# This test validates stopping threads API called in internal thread.\napp-pause-in-int-thread.test: $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) $(OBJDIR)app-pause-app$(EXE_SUFFIX)\n\t$(PIN) -t $(OBJDIR)app-pause-in-int-thread-tool$(PINTOOL_SUFFIX) \\\n\t  -- $(OBJDIR)app-pause-app$(EXE_SUFFIX) > $(OBJDIR)$(@:.test=.out)\n\t$(CGREP) 'Threads stopped by internal thread' $(OBJDIR)$(@:.test=.out) | $(QGREP) \"3\"\n\t$(RM) $(OBJDIR)$(@:.test=.out)\n\ncheck-if-thread-stopped.test: $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX)\n\techo \"set pinargs $(PIN_USERFLAGS) -t $(OBJDIR)check-if-thread-stopped$(PINTOOL_SUFFIX) -threads 4\" \\\n\t  -o $(OBJDIR)$(@:.test=.toolout) > $(OBJDIR)$(@:.test=.pindbin)\n\techo \"run $(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX) -threads 4\" >> $(OBJDIR)$(@:.test=.pindbin)\n\tcat $(@:.test=.pindb) >> $(OBJDIR)$(@:.test=.pindbin)\n\t$(PINDB_WITH_LIBPATH) --pin=$(BARE_PIN) --timeout=$(TLIMIT) --cpu=$(TARGET) --noprompt \\\n\t    $(PINDB_USERFLAGS) < $(OBJDIR)$(@:.test=.pindbin) > $(OBJDIR)$(@:.test=.pindbout)\n\tsleep 5\n\t$(PYCOMPARE) -p $(@:.test=.compare) -c $(OBJDIR)$(@:.test=.pindbout)\n\t$(QGREP) \"Finished\" $(OBJDIR)$(@:.test=.toolout)\n\t$(RM) -f $(OBJDIR)$(@:.test=.pindbin) $(OBJDIR)$(@:.test=.pindbout) $(OBJDIR)$(@:.test=.toolout)\n\n# Tests GDB extension of retrieving loaded shared libraries\n# Also, this test changes the base address of libc.so as seen\n# by GDB to 0xd00dead and checks that GDB reports the expected\n# base address.\n#\ngdb-svr4-libraries-extension.test: $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX)\n\t$(PIN) $(PINFLAGS_DEBUG) -t $(OBJDIR)library-load-tool$(PINTOOL_SUFFIX) -- \\\n\t    $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) `$(CXX) $(COMP_OBJ) /dev/null -print-file-name=libm.so` > $(OBJDIR)$(@:.test=.out) &\n\tcount=0; \\\n\tuntil $(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) > /dev/null || $(BASHTEST) $$count -gt $(TLIMIT); \\\n\t    do sleep 1; count=`expr $$count + 1`; done\n\techo '$(BATCH_CMD_TIMEOUT_LIMIT)' > $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(GREP) '$(BATCH_CMD_CONNECT_REMOTE)' $(OBJDIR)$(@:.test=.out) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\tcat $(@:.test=.$(DBG_STR)) >> $(OBJDIR)$(@:.test=.$(DBG_STR)in)\n\t$(DBG) $(DBG_CMD_SRC_FLAG) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(DBG_CMD_MORE_FLAGS) $(OBJDIR)dlopen-dlclose$(EXE_SUFFIX) \\\n\t  > $(OBJDIR)$(@:.test=.$(DBG_STR)out) 2>&1\n\t$(PYCOMPARE) -p $(@:.test=.compare$(COMPARE_RE_FILE_SUFFIX)) -c $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\t$(RM) -f $(OBJDIR)$(@:.test=.out) $(OBJDIR)$(@:.test=.$(DBG_STR)in) $(OBJDIR)$(@:.test=.$(DBG_STR)out)\n\n\n##############################################################\n#\n# Build rules\n#\n##############################################################\n\n# This section contains the build rules for all binaries that have special build rules.\n# See makefile.default.rules for the default build rules.\n\n###### Special tools' build rules ######\n\n$(OBJDIR)use-debugger-shell$(PINTOOL_SUFFIX): $(OBJDIR)use-debugger-shell$(OBJ_SUFFIX) $(OBJDIR)debugger-shell$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_before_breakpoint_and_set_xmm_reg$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n$(OBJDIR)set_xmm_scratches_for_ymmtest$(PINTOOL_SUFFIX): $(OBJDIR)set_xmm_scratches_for_ymmtest$(OBJ_SUFFIX) $(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX)\n\t$(LINKER) $(TOOL_LDFLAGS) $(LINK_EXE)$@ $^ $(TOOL_LPATHS) $(TOOL_LIBS)\n\n###### Special applications' build rules ######\n\n$(OBJDIR)simple$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bphandler_app$(EXE_SUFFIX): bphandler_app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-static$(EXE_SUFFIX): simple.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)exec$(EXE_SUFFIX): exec.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fork$(EXE_SUFFIX): fork.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)bptest-$(TARGET)$(EXE_SUFFIX): bptest.cpp bptest-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)action-pending-app$(EXE_SUFFIX): action-pending-app.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)xmm-$(TARGET)$(EXE_SUFFIX): xmm.c xmm-asm-$(TARGET).s\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)thread-static$(EXE_SUFFIX): thread.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(STATIC) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)simple-pindb$(EXE_SUFFIX): simple-pindb.cpp $(OBJDIR)simple-pindb-asm-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(NO_RANDOM) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)checkpoint-app$(EXE_SUFFIX): checkpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)watchpoint-app$(EXE_SUFFIX): watchpoint-app.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)callerapp$(EXE_SUFFIX): callerapp.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)fibonacci$(EXE_SUFFIX): $(TOOLS_ROOT)/ManualExamples/fibonacci.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)sleep-unix$(EXE_SUFFIX): sleep-unix.c\n\t$(APP_CC) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)debugger-shell-app-$(TARGET)$(EXE_SUFFIX): debugger-shell-app.cpp debugger-shell-app-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)intercept-app$(EXE_SUFFIX): intercept-app.cpp intercept-app-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)ymm-$(TARGET)$(EXE_SUFFIX): ymm.cpp ymm-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)zmm-$(TARGET)$(EXE_SUFFIX): zmm.cpp $(OBJDIR)zmm-asm-$(TARGET)$(OBJ_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-bp$(EXE_SUFFIX): pc-change-bp.cpp pc-change-bp-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pc-change-async$(EXE_SUFFIX): pc-change-async.cpp pc-change-async-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)mt-exit$(EXE_SUFFIX): mt-exit.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)signal-catch$(EXE_SUFFIX): signal-catch.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-unhandled-exception$(EXE_SUFFIX): win-unhandled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n \n$(OBJDIR)win-handled-exception$(EXE_SUFFIX): win-handled-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception1$(EXE_SUFFIX): win-continued-exception1.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-continued-exception2$(EXE_SUFFIX): win-continued-exception2.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-software-exception$(EXE_SUFFIX): win-software-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-cpp-exception$(EXE_SUFFIX): win-cpp-exception.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-exception-after-exit$(EXE_SUFFIX): win-exception-after-exit.cpp $(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX)\n\t$(APP_CXX) $(APP_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(APP_LIBS) $(OBJDIR)win-exception-after-exit-dll$(LIB_SUFFIX)\n\n$(OBJDIR)win-load-library$(EXE_SUFFIX): win-load-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)reattach-loop$(EXE_SUFFIX): reattach-loop.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(NO_PIC) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)win-thread-stress$(EXE_SUFFIX): win-thread-stress.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exit$(EXE_SUFFIX): pthread-bare-exit.cpp pthread-bare-exit-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)pthread-bare-exitgroup$(EXE_SUFFIX): pthread-bare-exitgroup.cpp pthread-bare-exitgroup-asm-$(TARGET).s\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n# A simple threaded application that we use for several tests.  Both Windows and Posix (Unix)\n# versions export the function \"GlobalFunction()\", which the tests rely on.\n#\n$(OBJDIR)thread-$(OS_TYPE)$(EXE_SUFFIX): thread-$(OS_TYPE).cpp\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS_NOOPT) $(DBG_INFO_CXX_ALWAYS) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)app-pause-app$(EXE_SUFFIX): app-pause-app.cpp $(THREADLIB)\n\t$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS) $(APP_LPATHS) $(APP_LIBS) $(APP_LIB_ATOMIC)\n\n###### Special objects' build rules ######\n\n$(OBJDIR)stack-debugger$(OBJ_SUFFIX): $(TOOLS_ROOT)/ManualExamples/stack-debugger.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)debugger-shell$(OBJ_SUFFIX): $(TOOLS_ROOT)/InstLib/debugger-shell.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(SUPPRESS_WARNING_ALIGNED_NEW) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)start-fini-callback$(OBJ_SUFFIX): start-fini-callback.cpp\n\t$(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)simple-pindb-asm-$(TARGET)$(OBJ_SUFFIX): simple-pindb-asm-$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)win-foo-library$(OBJ_SUFFIX): win-foo-library.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(DLL_CXXFLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n$(OBJDIR)set_xmm_scratches_asm$(OBJ_SUFFIX): set_xmm_scratches_$(TARGET)$(ASM_SUFFIX)\n\t$(ASMBLR) $(ASM_FLAGS) $(DBG_INFO_CXX_ALWAYS) $(COMP_OBJ)$@ $<\n\n###### Special dlls' build rules ######\n\n$(OBJDIR)$(DLL_PREFIX)win-foo-library$(DLL_SUFFIX): $(OBJDIR)win-foo-library$(OBJ_SUFFIX)\n\t$(LINKER) $(APP_LDFLAGS_NOOPT) $(DLL_LDFLAGS) $(LINK_EXE)$@ $< $(APP_LIBS) $(DBG_INFO_LD_ALWAYS)\n\n$(OBJDIR)$(DLL_PREFIX)win-exception-after-exit-dll$(DLL_SUFFIX): win-exception-after-exit-dll.cpp\n\t$(APP_CXX) $(APP_CXXFLAGS) $(DLL_CXXFLAGS) $(COMP_EXE)$@ $< $(APP_LDFLAGS) $(DLL_LDFLAGS) $(APP_LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Debugger/dlopen-dlclose.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Macro to create empty function which won't be opt-out by\n// the compiler\n#define EMPTY_FUNCTION(name) \\\n    void name();        \\\n    __asm__(              \\\n    \".global \" #name \"\\n\" \\\n    #name \":\\n\"          \\\n    \"ret\\n\"               \\\n    )\n\nEMPTY_FUNCTION(AfterLoadLibrary);\nEMPTY_FUNCTION(AfterUnloadLibrary);\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    AfterLoadLibrary();\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n    AfterUnloadLibrary();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ToolUnitTests/dltest.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ToolUnitTests/main_dll.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  pin tool combined from multi-DLLs (main_dll, dynamic_secondary_dll, static_secondary_dll). \n *  This is the \"main DLL\", use PIN API only in this DLL\n *  usage of PIN API in dynamic_secondary_dll and static_secondary_dll is not allowed\n *  (see README for more inforamtion)\n *\n *  NOTE: New Pin image loader does not (yet) support dynamic loading of Pin DLLs.\n *        Code related to dynamic_secondary_dll was suppressed.\n *        Look at Mantis 3280 for updates.\n *        #define DYN_LOAD will enable validation of dynamic loading feature in the test.\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"pin.H\"\n\nusing std::cerr;\nusing std::endl;\nusing std::hex;\n\nKNOB<BOOL> KnobEnumerate(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"enumerate\", \"0\", \"Enumerate modules loaded by Pin\");\n\n/* ===================================================================== */\n/* Global Variables and Declerations */\n/* ===================================================================== */\n\nPIN_LOCK pinLock;\n\ntypedef VOID (* BEFORE_BBL)(ADDRINT ip);\ntypedef int (* INIT_F)(bool enumerate);\ntypedef VOID (* FINI_F)();\n\n#if defined(DYN_LOAD)\n// Functions pointers for dynamic_secondary_dll\nBEFORE_BBL pBeforeBBL2;\nINIT_F pInit2;\nFINI_F pFini2;\n#endif\n\n// Dll imports for static_secondary_dll\nextern \"C\" __declspec( dllimport ) VOID BeforeBBL1(ADDRINT ip);\nextern \"C\" __declspec( dllimport ) VOID Init1();\nextern \"C\" __declspec( dllimport ) VOID Fini1();\n\n/* ===================================================================== */\n\n// This function is called before every basic block\nVOID PIN_FAST_ANALYSIS_CALL BeforeBBL(ADDRINT ip) \n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(ip);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(ip);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// Pin calls this function every time a new trace is encountered\nVOID Trace(TRACE trace, VOID *v)\n{\n    // Visit every basic block  in the trace\n    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))\n    {\n        // Insert a call to BeforeBBL before every bbl, passing the ip address.\n        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)BeforeBBL, IARG_FAST_ANALYSIS_CALL, \n                       IARG_INST_PTR, IARG_END);\n    }\n}\n\nVOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(0);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\nVOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n#if defined(DYN_LOAD)\n    pBeforeBBL2(0);\n#endif\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// This function is called when the application exits\nVOID Fini(INT32 code, VOID *v)\n{\n    Fini1();\n#if defined(DYN_LOAD)\n    pFini2();\n#endif\n}\n\n// This function gets info of an image loaded by Pin loader.\n// Invoked by dl_iterate_phdr()\nint dl_iterate_callback(struct dl_phdr_info * info, size_t size, VOID * data)\n{\n    cerr << info->dlpi_name << \" \" << hex << info->dlpi_addr << \" \" << info->dlpi_phdr->p_memsz << endl;\n    // Increment module counter.\n    ++(*reinterpret_cast<int *>(data));\n    return 0;\n}\n\n/* ===================================================================== */\n\nint main(int argc, char * argv[])\n{\n    // Initialize pin\n    PIN_Init(argc, argv);\n\n    PIN_InitLock(&pinLock);\n\n    // Register Trace() to be called to instrument traces\n    TRACE_AddInstrumentFunction(Trace, 0);\n\n    // Register Fini() to be called when the application exits\n    PIN_AddFiniFunction(Fini, 0);\n\n    // Call Static secondary dll Init1()\n    Init1();\n\n    int nModules;\n\n#if defined(DYN_LOAD)\n    // Dynamic secondary dll - load library, initialize function pointers\n    // and call Init2()\n    VOID * module = dlopen(\"dynamic_secondary_dll.dll\", RTLD_NOW);\n    if (module == NULL)\n    {\n        cerr << \"Failed to load dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n    pInit2 = reinterpret_cast<INIT_F>(dlsym(module, \"Init2\"));\n    pBeforeBBL2 = reinterpret_cast<BEFORE_BBL>(dlsym(module, \"BeforeBBL2\"));\n    pFini2 = reinterpret_cast<FINI_F>(dlsym(module, \"Fini2\"));\n    if (pInit2 == NULL || pBeforeBBL2 == NULL || pFini2 == NULL)\n    {\n        cerr << \"Failed to find proc addresses in dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n\n    nModules = pInit2(KnobEnumerate);\n#endif\n\n    int nModulesMain = 0;\n    // Enumerate DLLs currently loaded by Pin loader.\n    dl_iterate_phdr(dl_iterate_callback, &nModulesMain);\n\n    if (KnobEnumerate && ((nModulesMain <= 0) || (nModulesMain != nModules)))\n    {\n        // Failure. Module enumeration results in main and dynamic Dlls don't match.\n        PIN_ExitApplication(1);\n    }\n\n    // Start the program, never returns\n    PIN_StartProgram();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ToolUnitTests/dlclose_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define LIBCLOSE \"libclose1.dylib\"\n#else\n#define LIBCLOSE \"libclose1.so\"\n#endif\n\nvoid Load(const char * name)\n{\n    void * handle;\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(LIBCLOSE);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/tpss_lin_libc_tool.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the tool's libc (e.g. PIN CRT).\n * This file implements all the intrumenting logic thus requires PIN headers.\n */\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\nusing std::string;\nusing std::ios;\nusing std::hex;\nusing std::cerr;\nusing std::ofstream;\nusing std::endl;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nofstream OutFile;\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"tpss_lin_libc.txt\",\n        \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Pointers to the original functions that we probe                      */\n/* ===================================================================== */\nextern AFUNPTR fptrnanosleep;\nextern AFUNPTR fptrdl_iterate_phdr;\nextern AFUNPTR fptrsystem;\nextern AFUNPTR fptralarm;\nextern AFUNPTR fptrrecvmsg;\nextern AFUNPTR fptrsendmsg;\nextern AFUNPTR fptrpause;\nextern AFUNPTR fptrsigtimedwait;\nextern AFUNPTR fptrsigwaitinfo;\nextern AFUNPTR fptrepoll_wait;\nextern AFUNPTR fptrppoll;\nextern AFUNPTR fptrmsgsnd;\nextern AFUNPTR fptrmsgrcv;\nextern AFUNPTR fptrsemop;\nextern AFUNPTR fptrsemtimedop;\nextern AFUNPTR fptrusleep;\nextern AFUNPTR fptrualarm;\nextern AFUNPTR fptrgetitimer;\nextern AFUNPTR fptrsigwait;\nextern AFUNPTR fptrmsgget;\nextern AFUNPTR fptrsemget;\nextern AFUNPTR fptrwait;\nextern AFUNPTR fptrwaitpid;\nextern AFUNPTR fptrwaitid;\nextern AFUNPTR fptrwait3;\nextern AFUNPTR fptrwait4;\nextern AFUNPTR fptrreadv;\nextern AFUNPTR fptrwritev;\nextern AFUNPTR fptrflock;\nextern AFUNPTR fptrflockfile;\nextern AFUNPTR fptrfunlockfile;\nextern AFUNPTR fptrlockf;\nextern AFUNPTR fptrsetenv;\nextern AFUNPTR fptrunsetenv;\nextern AFUNPTR fptrgetenv;\nextern AFUNPTR fptrperror;\nextern AFUNPTR fptrmmap;\nextern AFUNPTR fptrmunmap;\nextern AFUNPTR fptrfileno;\nextern AFUNPTR fptrgetpid;\nextern AFUNPTR fptrgetppid;\nextern AFUNPTR fptrmemset;\nextern AFUNPTR fptrmemcpy;\nextern AFUNPTR fptraccess;\nextern AFUNPTR fptrlseek;\nextern AFUNPTR fptrlseek64;\nextern AFUNPTR fptrfdatasync;\nextern AFUNPTR fptrunlink;\nextern AFUNPTR fptrstrlen;\nextern AFUNPTR fptrwcslen;\nextern AFUNPTR fptrstrcpy;\nextern AFUNPTR fptrstrncpy;\nextern AFUNPTR fptrstrcat;\nextern AFUNPTR fptrstrstr;\nextern AFUNPTR fptrstrrchr;\nextern AFUNPTR fptrstrcmp;\nextern AFUNPTR fptrstrncmp;\nextern AFUNPTR fptrsigaddset;\nextern AFUNPTR fptrsigdelset;\nextern AFUNPTR fptrstrerror;\nextern AFUNPTR fptrbind;\nextern AFUNPTR fptrlisten;\nextern AFUNPTR fptruname;\nextern AFUNPTR fptrgethostname;\nextern AFUNPTR fptrkill;\nextern AFUNPTR fptrsched_yield;\nextern AFUNPTR fptrtimer_settime;\nextern AFUNPTR fptrsigaltstack;\nextern AFUNPTR fptrshutdown;\nextern AFUNPTR fptrsleep;\nextern AFUNPTR fptrsocket;\nextern AFUNPTR fptrselect;\nextern AFUNPTR fptrpoll;\nextern AFUNPTR fptraccept;\nextern AFUNPTR fptrconnect;\nextern AFUNPTR fptrrecv;\nextern AFUNPTR fptrrecvfrom;\nextern AFUNPTR fptrsend;\nextern AFUNPTR fptrgetwc;\nextern AFUNPTR fptrsetitimer;\nextern AFUNPTR fptrsigpending;\nextern AFUNPTR fptrsigaction;\nextern AFUNPTR fptrsignal;\nextern AFUNPTR fptrabort;\nextern AFUNPTR fptrsendto;\nextern AFUNPTR fptr_IO_getc;\nextern AFUNPTR fptrgetchar;\nextern AFUNPTR fptrgetwchar;\nextern AFUNPTR fptrgets;\nextern AFUNPTR fptrfgets;\nextern AFUNPTR fptrfgetwc;\nextern AFUNPTR fptrfread;\nextern AFUNPTR fptrfwrite;\nextern AFUNPTR fptropen;\nextern AFUNPTR fptrgetw;\nextern AFUNPTR fptrfgetc;\nextern AFUNPTR fptrfgetws;\nextern AFUNPTR fptrpipe;\nextern AFUNPTR fptrread;\nextern AFUNPTR fptrwrite;\nextern AFUNPTR fptrfopen;\nextern AFUNPTR fptrfdopen;\nextern AFUNPTR fptrclose;\nextern AFUNPTR fptrfclose;\nextern AFUNPTR fptrcallrpc;\nextern AFUNPTR fptrclnt_broadcast;\nextern AFUNPTR fptrclntudp_create;\nextern AFUNPTR fptrclntudp_bufcreate;\nextern AFUNPTR fptrpmap_getmaps;\nextern AFUNPTR fptrpmap_getport;\nextern AFUNPTR fptrpmap_rmtcall;\nextern AFUNPTR fptrpmap_set;\nextern AFUNPTR fptrclntraw_create;\nextern AFUNPTR fptrsvc_run;\nextern AFUNPTR fptrsvc_sendreply;\nextern AFUNPTR fptrsvcraw_create;\nextern AFUNPTR fptrsvctcp_create;\nextern AFUNPTR fptrsvcudp_bufcreate;\nextern AFUNPTR fptrsvcudp_create;\nextern AFUNPTR fptr_exit;\nextern AFUNPTR fptrsigprocmask;\nextern AFUNPTR fptrexit;\nextern AFUNPTR fptrpselect;\nextern AFUNPTR fptrioctl;\nextern AFUNPTR fptr__libc_dlopen_mode;\nextern AFUNPTR fptr__errno_location;\nextern AFUNPTR fptrsyscall;\n\n/* ===================================================================== */\n/* Replacement functions implemented in the other part of the tool       */\n/* ===================================================================== */\nextern \"C\"\n{\nvoid mysleep();\nvoid mysocket();\nvoid myshutdown();\nvoid myselect();\nvoid mypoll();\nvoid mypselect();\nvoid myaccept();\nvoid myconnect();\nvoid myrecv();\nvoid myrecvfrom();\nvoid mysend();\nvoid mysendto();\nvoid mygetwc();\nvoid mygetw();\nvoid my_IO_getc();\nvoid mygetchar();\nvoid mygetwchar();\nvoid mygets();\nvoid myfgetc();\nvoid myfgetwc();\nvoid myfgets();\nvoid myfgetws();\nvoid myfread();\nvoid myfwrite();\nvoid mypipe();\nvoid myread();\nvoid mywrite();\nvoid myopen();\nvoid myfopen();\nvoid myfdopen();\nvoid myclose();\nvoid myfclose();\nvoid mycallrpc();\nvoid myclnt_broadcast();\nvoid myclntudp_create();\nvoid myclntudp_bufcreate();\nvoid mypmap_getmaps();\nvoid mypmap_getport();\nvoid mypmap_rmtcall();\nvoid mypmap_set();\nvoid myclntraw_create();\nvoid mysvc_run();\nvoid mysvc_sendreply();\nvoid mysvcraw_create();\nvoid mysvctcp_create();\nvoid mysvcudp_bufcreate();\nvoid mysvcudp_create();\nvoid myabort();\nvoid my_exit();\nvoid my_nanosleep();\nvoid mysignal();\nvoid mysigprocmask();\nvoid mysigpending();\nvoid mysigaction();\nvoid mysetitimer();\nvoid myexit();\nvoid mydl_iterate_phdr();\nvoid mysystem();\nvoid myalarm();\nvoid myrecvmsg();\nvoid mysendmsg();\nvoid mypause();\nvoid mysigtimedwait();\nvoid mysigwaitinfo();\nvoid myepoll_wait();\nvoid myppoll();\nvoid mymsgsnd();\nvoid mymsgrcv();\nvoid mymsgrcv();\nvoid mysemtimedop();\nvoid myusleep();\nvoid myualarm();\nvoid mygetitimer();\nvoid mysigwait();\nvoid mymsgget();\nvoid mysemget();\nvoid mywait();\nvoid mywaitpid();\nvoid mywaitid();\nvoid mywait3();\nvoid mywait4();\nvoid myreadv();\nvoid mywritev();\nvoid myflockfile();\nvoid mylockf();\nvoid mysetenv();\nvoid myunsetenv();\nvoid mygetenv();\nvoid myperror();\nvoid mymmap();\nvoid mymunmap();\nvoid myfileno();\nvoid mygetpid();\nvoid mygetppid();\nvoid mymemset();\nvoid mymemcpy();\nvoid myaccess();\nvoid mylseek();\nvoid mylseek64();\nvoid myfdatasync();\nvoid myunlink();\nvoid mystrlen();\nvoid mywcslen();\nvoid mystrcpy();\nvoid mystrcpy();\nvoid mystrcat();\nvoid mystrstr();\nvoid mystrchr0();\nvoid mystrrchr();\nvoid mystrcmp();\nvoid mystrncmp();\nvoid mysigaddset();\nvoid mysigdelset();\nvoid mysigismember();\nvoid mystrerror();\nvoid mybind();\nvoid mylisten();\nvoid myuname();\nvoid mygethostname();\nvoid mykill();\nvoid mysched_yield();\nvoid mytimer_settime();\nvoid mysigaltstack();\nvoid myioctl();\nvoid myflock();\nvoid my__libc_dlopen_mode();\nvoid my__errno_location();\nvoid mysyscall();\nvoid myfunlockfile();\n}\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage() {\n    cerr\n            << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\"\n            << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime() {\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\nextern \"C\" void printFunctionCalled(const char* funcName)\n{\n    OutFile << CurrentTime() << funcName << \" called \" << endl;\n    OutFile.flush();\n}\n\nbool is_GLIBC2_24_or_newer(IMG img)\n{\n    char path[PATH_MAX] = {0};\n    if (0 <= readlink(IMG_Name(img).c_str(), path, sizeof(path)-1))\n    {\n        return (string(\"libc-2.24.so\") == basename(path));\n    }\n    return false;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, VOID_PTR v) {\n    // Called every time a new image is loaded\n    if ((IMG_Name(img).find(\"libc.so\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.SO\") != string::npos)\n            || (IMG_Name(img).find(\"LIBC.so\") != string::npos))\n    {\n\n        RTN rtnsleep = RTN_FindByName(img, \"sleep\");\n        if (RTN_Valid(rtnsleep) && RTN_IsSafeForProbedReplacement(rtnsleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sleep at \"\n                    << RTN_Address(rtnsleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsleep, AFUNPTR(mysleep)));\n            fptrsleep = fptr;\n        }\n\n        RTN rtnsocket = RTN_FindByName(img, \"socket\");\n        if (RTN_Valid(rtnsocket) && RTN_IsSafeForProbedReplacement(rtnsocket))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for socket at \"\n                    << RTN_Address(rtnsocket) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsocket, AFUNPTR(mysocket)));\n            fptrsocket = fptr;\n        }\n\n        RTN rtnshutdown = RTN_FindByName(img, \"shutdown\");\n        if (RTN_Valid(rtnshutdown)\n                && RTN_IsSafeForProbedReplacement(rtnshutdown))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for shutdown at \" << RTN_Address(rtnshutdown) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnshutdown, AFUNPTR(myshutdown)));\n            fptrshutdown = fptr;\n        }\n\n        RTN rtnselect = RTN_FindByName(img, \"select\");\n        if (RTN_Valid(rtnselect) && RTN_IsSafeForProbedReplacement(rtnselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for select at \" << RTN_Address(rtnselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnselect, AFUNPTR(myselect)));\n            fptrselect = fptr;\n        }\n\n        RTN rtnpoll = RTN_FindByName(img, \"poll\");\n        if (RTN_Valid(rtnpoll) && RTN_IsSafeForProbedReplacement(rtnpoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for poll at \" << RTN_Address(rtnpoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpoll, AFUNPTR(mypoll)));\n            fptrpoll = fptr;\n        }\n\n        RTN rtnpselect = RTN_FindByName(img, \"pselect\");\n        if (RTN_Valid(rtnpselect)\n                && RTN_IsSafeForProbedReplacement(rtnpselect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pselect at \"\n                    << RTN_Address(rtnpselect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpselect, AFUNPTR(mypselect)));\n            fptrpselect = fptr;\n        }\n\n        RTN rtnaccept = RTN_FindByName(img, \"accept\");\n        if (RTN_Valid(rtnaccept) && RTN_IsSafeForProbedReplacement(rtnaccept))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for accept at \" << RTN_Address(rtnaccept) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccept, AFUNPTR(myaccept)));\n            fptraccept = fptr;\n        }\n\n        RTN rtnconnect = RTN_FindByName(img, \"connect\");\n        if (RTN_Valid(rtnconnect) && RTN_IsSafeForProbedReplacement(rtnconnect))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for connect at \" << RTN_Address(rtnconnect) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnconnect, AFUNPTR(myconnect)));\n            fptrconnect = fptr;\n        }\n\n        RTN rtnrecv = RTN_FindByName(img, \"recv\");\n        if (RTN_Valid(rtnrecv) && RTN_IsSafeForProbedReplacement(rtnrecv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recv at \" << RTN_Address(rtnrecv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecv, AFUNPTR(myrecv)));\n            fptrrecv = fptr;\n        }\n\n        RTN rtnrecvfrom = RTN_FindByName(img, \"recvfrom\");\n        if (RTN_Valid(rtnrecvfrom) && RTN_IsSafeForProbedReplacement(rtnrecvfrom))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvfrom at \" << RTN_Address(rtnrecvfrom) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvfrom, AFUNPTR(myrecvfrom)));\n            fptrrecvfrom = fptr;\n        }\n\n        RTN rtnsend = RTN_FindByName(img, \"send\");\n        if (RTN_Valid(rtnsend) && RTN_IsSafeForProbedReplacement(rtnsend))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for send at \" << RTN_Address(rtnsend) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsend, AFUNPTR(mysend)));\n            fptrsend = fptr;\n        }\n\n        RTN rtnsendto = RTN_FindByName(img, \"sendto\");\n        if (RTN_Valid(rtnsendto) && RTN_IsSafeForProbedReplacement(rtnsendto))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendto at \" << RTN_Address(rtnsendto) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendto, AFUNPTR(mysendto)));\n            fptrsendto = fptr;\n        }\n\n        RTN rtngetwc = RTN_FindByName(img, \"getwc\");\n        if (RTN_Valid(rtngetwc) && RTN_IsSafeForProbedReplacement(rtngetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwc at \" << RTN_Address(rtngetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwc, AFUNPTR(mygetwc)));\n            fptrgetwc = fptr;\n        }\n\n        RTN rtngetw = RTN_FindByName(img, \"getw\");\n        if (RTN_Valid(rtngetw) && RTN_IsSafeForProbedReplacement(rtngetw))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getw at \" << RTN_Address(rtngetw) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetw, AFUNPTR(mygetw)));\n            fptrgetw = fptr;\n        }\n\n        RTN rtn_IO_getc = RTN_FindByName(img, \"_IO_getc\");\n        if (RTN_Valid(rtn_IO_getc)\n                && RTN_IsSafeForProbedReplacement(rtn_IO_getc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _IO_getc at \" << RTN_Address(rtn_IO_getc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_IO_getc, AFUNPTR(my_IO_getc)));\n            fptr_IO_getc = fptr;\n        }\n\n        RTN rtngetchar = RTN_FindByName(img, \"getchar\");\n        if (RTN_Valid(rtngetchar) && RTN_IsSafeForProbedReplacement(rtngetchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getchar at \" << RTN_Address(rtngetchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetchar, AFUNPTR(mygetchar)));\n            fptrgetchar = fptr;\n        }\n\n        RTN rtngetwchar = RTN_FindByName(img, \"getwchar\");\n        if (RTN_Valid(rtngetwchar) && RTN_IsSafeForProbedReplacement(rtngetwchar))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getwchar at \"\n                    << RTN_Address(rtngetwchar) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetwchar, AFUNPTR(mygetwchar)));\n            fptrgetwchar = fptr;\n        }\n\n        RTN rtngets = RTN_FindByName(img, \"gets\");\n        if (RTN_Valid(rtngets) && RTN_IsSafeForProbedReplacement(rtngets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gets at \" << RTN_Address(rtngets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngets, AFUNPTR(mygets)));\n            fptrgets = fptr;\n        }\n\n        RTN rtnfgetc = RTN_FindByName(img, \"fgetc\");\n        if (RTN_Valid(rtnfgetc) && RTN_IsSafeForProbedReplacement(rtnfgetc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetc at \" << RTN_Address(rtnfgetc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetc, AFUNPTR(myfgetc)));\n            fptrfgetc = fptr;\n        }\n\n        RTN rtnfgetwc = RTN_FindByName(img, \"fgetwc\");\n        if (RTN_Valid(rtnfgetwc) && RTN_IsSafeForProbedReplacement(rtnfgetwc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetwc at \" << RTN_Address(rtnfgetwc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetwc, AFUNPTR(myfgetwc)));\n            fptrfgetwc = fptr;\n        }\n\n        RTN rtnfgets = RTN_FindByName(img, \"fgets\");\n        if (RTN_Valid(rtnfgets) && RTN_IsSafeForProbedReplacement(rtnfgets))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgets at \" << RTN_Address(rtnfgets) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgets, AFUNPTR(myfgets)));\n            fptrfgets = fptr;\n        }\n\n        RTN rtnfgetws = RTN_FindByName(img, \"fgetws\");\n        if (RTN_Valid(rtnfgetws) && RTN_IsSafeForProbedReplacement(rtnfgetws))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fgetws at \" << RTN_Address(rtnfgetws) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfgetws, AFUNPTR(myfgetws)));\n            fptrfgetws = fptr;\n        }\n\n        RTN rtnfread = RTN_FindByName(img, \"fread\");\n        if (RTN_Valid(rtnfread) && RTN_IsSafeForProbedReplacement(rtnfread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fread at \" << RTN_Address(rtnfread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfread, AFUNPTR(myfread)));\n            fptrfread = fptr;\n        }\n\n        RTN rtnfwrite = RTN_FindByName(img, \"fwrite\");\n        if (RTN_Valid(rtnfwrite) && RTN_IsSafeForProbedReplacement(rtnfwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fwrite at \" << RTN_Address(rtnfwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfwrite, AFUNPTR(myfwrite)));\n            fptrfwrite = fptr;\n        }\n\n        RTN rtnpipe = RTN_FindByName(img, \"pipe\");\n        if (RTN_Valid(rtnpipe) && RTN_IsSafeForProbedReplacement(rtnpipe))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pipe at \" << RTN_Address(rtnpipe) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpipe, AFUNPTR(mypipe)));\n            fptrpipe = fptr;\n        }\n\n        RTN rtnread = RTN_FindByName(img, \"read\");\n        if (RTN_Valid(rtnread) && RTN_IsSafeForProbedReplacement(rtnread))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for read at \" << RTN_Address(rtnread) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnread, AFUNPTR(myread)));\n            fptrread = fptr;\n        }\n\n        RTN rtnwrite = RTN_FindByName(img, \"write\");\n        if (RTN_Valid(rtnwrite) && RTN_IsSafeForProbedReplacement(rtnwrite))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for write at \" << RTN_Address(rtnwrite) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwrite, AFUNPTR(mywrite)));\n            fptrwrite = fptr;\n        }\n\n        RTN rtnopen = RTN_FindByName(img, \"open\");\n        if (RTN_Valid(rtnopen) && RTN_IsSafeForProbedReplacement(rtnopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for open at \" << RTN_Address(rtnopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnopen, AFUNPTR(myopen)));\n            fptropen = fptr;\n        }\n\n        RTN rtnfopen = RTN_FindByName(img, \"fopen\");\n        if (RTN_Valid(rtnfopen) && RTN_IsSafeForProbedReplacement(rtnfopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fopen at \" << RTN_Address(rtnfopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfopen, AFUNPTR(myfopen)));\n            fptrfopen = fptr;\n        }\n\n        RTN rtnfdopen = RTN_FindByName(img, \"fdopen\");\n        if (RTN_Valid(rtnfdopen) && RTN_IsSafeForProbedReplacement(rtnfdopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdopen at \" << RTN_Address(rtnfdopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdopen, AFUNPTR(myfdopen)));\n            fptrfdopen = fptr;\n        }\n\n        RTN rtnclose = RTN_FindByName(img, \"close\");\n        if (RTN_Valid(rtnclose) && RTN_IsSafeForProbedReplacement(rtnclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for close at \" << RTN_Address(rtnclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclose, AFUNPTR(myclose)));\n            fptrclose = fptr;\n        }\n\n        RTN rtnfclose = RTN_FindByName(img, \"fclose\");\n        if (RTN_Valid(rtnfclose) && RTN_IsSafeForProbedReplacement(rtnfclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fclose at \" << RTN_Address(rtnfclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfclose, AFUNPTR(myfclose)));\n            fptrfclose = fptr;\n        }\n\n        RTN rtncallrpc = RTN_FindByName(img, \"callrpc\");\n        if (RTN_Valid(rtncallrpc)&& RTN_IsSafeForProbedReplacement(rtncallrpc))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for callrpc at \" << RTN_Address(rtncallrpc) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtncallrpc, AFUNPTR(mycallrpc)));\n            fptrcallrpc = fptr;\n        }\n\n        RTN rtnclnt_broadcast = RTN_FindByName(img, \"clnt_broadcast\");\n        if (RTN_Valid(rtnclnt_broadcast)\n                && RTN_IsSafeForProbedReplacement(rtnclnt_broadcast))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clnt_broadcast at \" << RTN_Address(rtnclnt_broadcast) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclnt_broadcast, AFUNPTR(myclnt_broadcast)));\n            fptrclnt_broadcast = fptr;\n        }\n\n        RTN rtnclntudp_create = RTN_FindByName(img, \"clntudp_create\");\n        if (RTN_Valid(rtnclntudp_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_create at \" << RTN_Address(rtnclntudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_create, AFUNPTR(myclntudp_create)));\n            fptrclntudp_create = fptr;\n        }\n\n        RTN rtnclntudp_bufcreate = RTN_FindByName(img, \"clntudp_bufcreate\");\n        if (RTN_Valid(rtnclntudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnclntudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntudp_bufcreate at \" << RTN_Address(rtnclntudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntudp_bufcreate, AFUNPTR(myclntudp_bufcreate)));\n            fptrclntudp_bufcreate = fptr;\n        }\n\n        RTN rtnpmap_getmaps = RTN_FindByName(img, \"pmap_getmaps\");\n        if (RTN_Valid(rtnpmap_getmaps) && RTN_IsSafeForProbedReplacement(rtnpmap_getmaps))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getmaps at \" << RTN_Address(rtnpmap_getmaps) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getmaps, AFUNPTR(mypmap_getmaps)));\n            fptrpmap_getmaps = fptr;\n        }\n\n        RTN rtnpmap_getport = RTN_FindByName(img, \"pmap_getport\");\n        if (RTN_Valid(rtnpmap_getport) && RTN_IsSafeForProbedReplacement(rtnpmap_getport))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_getport at \" << RTN_Address(rtnpmap_getport) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_getport, AFUNPTR(mypmap_getport)));\n            fptrpmap_getport = fptr;\n        }\n\n        RTN rtnpmap_rmtcall = RTN_FindByName(img, \"pmap_rmtcall\");\n        if (RTN_Valid(rtnpmap_rmtcall) && RTN_IsSafeForProbedReplacement(rtnpmap_rmtcall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_rmtcall at \" << RTN_Address(rtnpmap_rmtcall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_rmtcall, AFUNPTR(mypmap_rmtcall)));\n            fptrpmap_rmtcall = fptr;\n        }\n\n        RTN rtnpmap_set = RTN_FindByName(img, \"pmap_set\");\n        if (RTN_Valid(rtnpmap_set) && RTN_IsSafeForProbedReplacement(rtnpmap_set))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pmap_set at \" << RTN_Address(rtnpmap_set) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpmap_set, AFUNPTR(mypmap_set)));\n            fptrpmap_set = fptr;\n        }\n\n        RTN rtnclntraw_create = RTN_FindByName(img, \"clntraw_create\");\n        if (RTN_Valid(rtnclntraw_create)\n                && RTN_IsSafeForProbedReplacement(rtnclntraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for clntraw_create at \" << RTN_Address(rtnclntraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnclntraw_create, AFUNPTR(myclntraw_create)));\n            fptrclntraw_create = fptr;\n        }\n\n        RTN rtnsvc_run = RTN_FindByName(img, \"svc_run\");\n        if (RTN_Valid(rtnsvc_run) && RTN_IsSafeForProbedReplacement(rtnsvc_run))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_run at \"\n                    << RTN_Address(rtnsvc_run) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_run, AFUNPTR(mysvc_run)));\n            fptrsvc_run = fptr;\n        }\n\n        RTN rtnsvc_sendreply = RTN_FindByName(img, \"svc_sendreply\");\n        if (RTN_Valid(rtnsvc_sendreply) && RTN_IsSafeForProbedReplacement(rtnsvc_sendreply))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svc_sendreply at \" << RTN_Address(rtnsvc_sendreply) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvc_sendreply, AFUNPTR(mysvc_sendreply)));\n            fptrsvc_sendreply = fptr;\n        }\n\n        RTN rtnsvcraw_create = RTN_FindByName(img, \"svcraw_create\");\n        if (RTN_Valid(rtnsvcraw_create) && RTN_IsSafeForProbedReplacement(rtnsvcraw_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcraw_create at \" << RTN_Address(rtnsvcraw_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcraw_create, AFUNPTR(mysvcraw_create)));\n            fptrsvcraw_create = fptr;\n        }\n\n        RTN rtnsvctcp_create = RTN_FindByName(img, \"svctcp_create\");\n        if (RTN_Valid(rtnsvctcp_create) && RTN_IsSafeForProbedReplacement(rtnsvctcp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svctcp_create at \" << RTN_Address(rtnsvctcp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvctcp_create, AFUNPTR(mysvctcp_create)));\n            fptrsvctcp_create = fptr;\n        }\n\n        RTN rtnsvcudp_bufcreate = RTN_FindByName(img, \"svcudp_bufcreate\");\n        if (RTN_Valid(rtnsvcudp_bufcreate) && RTN_IsSafeForProbedReplacement(rtnsvcudp_bufcreate))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_bufcreate at \" << RTN_Address(rtnsvcudp_bufcreate) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_bufcreate, AFUNPTR(mysvcudp_bufcreate)));\n            fptrsvcudp_bufcreate = fptr;\n        }\n\n        RTN rtnsvcudp_create = RTN_FindByName(img, \"svcudp_create\");\n        if (RTN_Valid(rtnsvcudp_create) && RTN_IsSafeForProbedReplacement(rtnsvcudp_create))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for svcudp_create at \" << RTN_Address(rtnsvcudp_create) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsvcudp_create, AFUNPTR(mysvcudp_create)));\n            fptrsvcudp_create = fptr;\n        }\n\n        RTN rtnabort = RTN_FindByName(img, \"abort\");\n        if (RTN_Valid(rtnabort) && RTN_IsSafeForProbedReplacement(rtnabort))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for abort at \" << RTN_Address(rtnabort) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnabort, AFUNPTR(myabort)));\n            fptrabort = fptr;\n        }\n\n        RTN rtn_exit = RTN_FindByName(img, \"_exit\");\n        if (RTN_Valid(rtn_exit) && RTN_IsSafeForProbedReplacement(rtn_exit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for _exit at \" << RTN_Address(rtn_exit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn_exit, AFUNPTR(my_exit)));\n            fptr_exit = fptr;\n        }\n\n        RTN rtnnanosleep = RTN_FindByName(img, \"nanosleep\");\n        if (RTN_Valid(rtnnanosleep) && RTN_IsSafeForProbedReplacement(rtnnanosleep))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for nanosleep at \" << RTN_Address(rtnnanosleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnnanosleep, AFUNPTR(my_nanosleep)));\n            fptrnanosleep = fptr;\n        }\n\n        RTN rtnsignal = RTN_FindByName(img, \"signal\");\n        if (RTN_Valid(rtnsignal) && RTN_IsSafeForProbedReplacement(rtnsignal))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for signal at \" << RTN_Address(rtnsignal) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsignal, AFUNPTR(mysignal)));\n            fptrsignal = fptr;\n        }\n\n        RTN rtnsigprocmask = RTN_FindByName(img, \"sigprocmask\");\n        if (RTN_Valid(rtnsigprocmask) && RTN_IsSafeForProbedReplacement(rtnsigprocmask))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigprocmask at \" << RTN_Address(rtnsigprocmask) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigprocmask, AFUNPTR(mysigprocmask)));\n            fptrsigprocmask = fptr;\n        }\n\n        RTN rtnsigpending = RTN_FindByName(img, \"sigpending\");\n        if (RTN_Valid(rtnsigpending) && RTN_IsSafeForProbedReplacement(rtnsigpending))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigpending at \" << RTN_Address(rtnsigpending) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigpending, AFUNPTR(mysigpending)));\n            fptrsigpending = fptr;\n        }\n\n        RTN rtnsigaction = RTN_FindByName(img, \"sigaction\");\n        if (RTN_Valid(rtnsigaction) && RTN_IsSafeForProbedReplacement(rtnsigaction))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaction at \" << RTN_Address(rtnsigaction) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaction, AFUNPTR(mysigaction)));\n            fptrsigaction = fptr;\n        }\n\n        RTN rtnsetitimer = RTN_FindByName(img, \"setitimer\");\n        if (RTN_Valid(rtnsetitimer) && RTN_IsSafeForProbedReplacement(rtnsetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setitimer at \" << RTN_Address(rtnsetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetitimer, AFUNPTR(mysetitimer)));\n            fptrsetitimer = fptr;\n        }\n\n        RTN rtnexit = RTN_FindByName(img, \"exit\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtnexit))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for exit at \" << RTN_Address(rtnexit) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnexit, AFUNPTR(myexit)));\n            fptrexit = fptr;\n        }\n\n        RTN rtndl_iterate_phdr = RTN_FindByName(img, \"dl_iterate_phdr\");\n        if (RTN_Valid(rtnexit) && RTN_IsSafeForProbedReplacement(rtndl_iterate_phdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dl_iterate_phdr at \" << RTN_Address(rtndl_iterate_phdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndl_iterate_phdr, AFUNPTR(mydl_iterate_phdr)));\n            fptrdl_iterate_phdr = fptr;\n        }\n\n        RTN rtnsystem = RTN_FindByName(img, \"system\");\n        if (RTN_Valid(rtnsystem) && RTN_IsSafeForProbedReplacement(rtnsystem))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for system at \"\n                    << RTN_Address(rtnsystem) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsystem, AFUNPTR(mysystem)));\n            fptrsystem = fptr;\n        }\n\n        RTN rtnalarm = RTN_FindByName(img, \"alarm\");\n        if (RTN_Valid(rtnalarm) && RTN_IsSafeForProbedReplacement(rtnalarm))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for alarm at \"\n                    << RTN_Address(rtnalarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnalarm, AFUNPTR(myalarm)));\n            fptralarm = fptr;\n        }\n\n        RTN rtnrecvmsg = RTN_FindByName(img, \"recvmsg\");\n        if (RTN_Valid(rtnrecvmsg) && RTN_IsSafeForProbedReplacement(rtnrecvmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for recvmsg at \" << RTN_Address(rtnrecvmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnrecvmsg, AFUNPTR(myrecvmsg)));\n            fptrrecvmsg = fptr;\n        }\n\n        RTN rtnsendmsg = RTN_FindByName(img, \"sendmsg\");\n        if (RTN_Valid(rtnsendmsg) && RTN_IsSafeForProbedReplacement(rtnsendmsg))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sendmsg at \"\n                    << RTN_Address(rtnsendmsg) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsendmsg, AFUNPTR(mysendmsg)));\n            fptrsendmsg = fptr;\n        }\n\n        RTN rtnpause = RTN_FindByName(img, \"pause\");\n        if (RTN_Valid(rtnpause) && RTN_IsSafeForProbedReplacement(rtnpause))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for pause at \"\n                    << RTN_Address(rtnpause) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnpause, AFUNPTR(mypause)));\n            fptrpause = fptr;\n        }\n\n        RTN rtnsigtimedwait = RTN_FindByName(img, \"sigtimedwait\");\n        if (RTN_Valid(rtnsigtimedwait) && RTN_IsSafeForProbedReplacement(rtnsigtimedwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigtimedwait at \" << RTN_Address(rtnsigtimedwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigtimedwait, AFUNPTR(mysigtimedwait)));\n            fptrsigtimedwait = fptr;\n        }\n\n        RTN rtnsigwaitinfo = RTN_FindByName(img, \"sigwaitinfo\");\n        if (RTN_Valid(rtnsigwaitinfo) && RTN_IsSafeForProbedReplacement(rtnsigwaitinfo))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwaitinfo at \" << RTN_Address(rtnsigwaitinfo) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwaitinfo, AFUNPTR(mysigwaitinfo)));\n            fptrsigwaitinfo = fptr;\n        }\n\n        RTN rtnepoll_wait = RTN_FindByName(img, \"epoll_wait\");\n        if (RTN_Valid(rtnepoll_wait) && RTN_IsSafeForProbedReplacement(rtnepoll_wait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for epoll_wait at \" << RTN_Address(rtnepoll_wait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnepoll_wait, AFUNPTR(myepoll_wait)));\n            fptrepoll_wait = fptr;\n        }\n\n        RTN rtnppoll = RTN_FindByName(img, \"ppoll\");\n        if (RTN_Valid(rtnppoll) && RTN_IsSafeForProbedReplacement(rtnppoll))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ppoll at \" << RTN_Address(rtnppoll) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnppoll, AFUNPTR(myppoll)));\n            fptrppoll = fptr;\n        }\n\n        RTN rtnmsgsnd = RTN_FindByName(img, \"msgsnd\");\n        if (RTN_Valid(rtnmsgsnd) && RTN_IsSafeForProbedReplacement(rtnmsgsnd))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgsnd at \" << RTN_Address(rtnmsgsnd) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgsnd, AFUNPTR(mymsgsnd)));\n            fptrmsgsnd = fptr;\n        }\n\n        RTN rtnmsgrcv = RTN_FindByName(img, \"msgrcv\");\n        if (RTN_Valid(rtnmsgrcv) && RTN_IsSafeForProbedReplacement(rtnmsgrcv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgrcv at \" << RTN_Address(rtnmsgrcv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgrcv, AFUNPTR(mymsgrcv)));\n            fptrmsgrcv = fptr;\n        }\n\n        RTN rtnsemop = RTN_FindByName(img, \"semop\");\n        if (RTN_Valid(rtnsemop) && RTN_IsSafeForProbedReplacement(rtnsemop))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semop at \" << RTN_Address(rtnsemop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemop, AFUNPTR(mymsgrcv)));\n            fptrsemop = fptr;\n        }\n\n        RTN rtnsemtimedop = RTN_FindByName(img, \"semtimedop\");\n        if (RTN_Valid(rtnsemtimedop)\n                && RTN_IsSafeForProbedReplacement(rtnsemtimedop)) {\n            OutFile << CurrentTime() << \"Inserting probe for semtimedop at \"\n                    << RTN_Address(rtnsemtimedop) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = RTN_ReplaceProbed(rtnsemtimedop, AFUNPTR(mysemtimedop));\n            fptrsemtimedop = fptr;\n        }\n\n        RTN rtnusleep = RTN_FindByName(img, \"usleep\");\n        if (RTN_Valid(rtnusleep) && RTN_IsSafeForProbedReplacement(rtnusleep)) {\n            OutFile << CurrentTime() << \"Inserting probe for usleep at \"\n                    << RTN_Address(rtnusleep) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnusleep, AFUNPTR(myusleep)));\n            fptrusleep = fptr;}\n\n        RTN rtnualarm = RTN_FindByName(img, \"ualarm\");\n        if (RTN_Valid(rtnualarm) && RTN_IsSafeForProbedReplacement(rtnualarm)) {\n            OutFile << CurrentTime() << \"Inserting probe for ualarm at \"\n                    << RTN_Address(rtnualarm) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnualarm, AFUNPTR(myualarm)));\n            fptrualarm = fptr;}\n\n        RTN rtngetitimer = RTN_FindByName(img, \"getitimer\");\n        if (RTN_Valid(rtngetitimer) && RTN_IsSafeForProbedReplacement(rtngetitimer))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getitimer at \" << RTN_Address(rtngetitimer) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetitimer, AFUNPTR(mygetitimer)));\n            fptrgetitimer = fptr;}\n\n        RTN rtnsigwait = RTN_FindByName(img, \"sigwait\");\n        if (RTN_Valid(rtnsigwait) && RTN_IsSafeForProbedReplacement(rtnsigwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigwait at \" << RTN_Address(rtnsigwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigwait, AFUNPTR(mysigwait)));\n            fptrsigwait = fptr;\n        }\n\n        RTN rtnmsgget = RTN_FindByName(img, \"msgget\");\n        if (RTN_Valid(rtnmsgget) && RTN_IsSafeForProbedReplacement(rtnmsgget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for msgget at \" << RTN_Address(rtnmsgget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmsgget, AFUNPTR(mymsgget)));\n            fptrmsgget = fptr;\n        }\n\n        RTN rtnsemget = RTN_FindByName(img, \"semget\");\n        if (RTN_Valid(rtnsemget) && RTN_IsSafeForProbedReplacement(rtnsemget))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for semget at \" << RTN_Address(rtnsemget) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsemget, AFUNPTR(mysemget)));\n            fptrsemget = fptr;\n        }\n\n        RTN rtnwait = RTN_FindByName(img, \"wait\");\n        if (RTN_Valid(rtnwait) && RTN_IsSafeForProbedReplacement(rtnwait))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait at \" << RTN_Address(rtnwait) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait, AFUNPTR(mywait)));\n            fptrwait = fptr;\n        }\n\n        RTN rtnwaitpid = RTN_FindByName(img, \"waitpid\");\n        if (RTN_Valid(rtnwaitpid) && RTN_IsSafeForProbedReplacement(rtnwaitpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitpid at \" << RTN_Address(rtnwaitpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitpid, AFUNPTR(mywaitpid)));\n            fptrwaitpid = fptr;\n        }\n\n        RTN rtnwaitid = RTN_FindByName(img, \"waitid\");\n        if (RTN_Valid(rtnwaitid) && RTN_IsSafeForProbedReplacement(rtnwaitid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for waitid at \" << RTN_Address(rtnwaitid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwaitid, AFUNPTR(mywaitid)));\n            fptrwaitid = fptr;\n        }\n\n        RTN rtnwait3 = RTN_FindByName(img, \"wait3\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait3))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait3 at \" << RTN_Address(rtnwait3) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait3)));\n            fptrwait3 = fptr;\n        }\n\n        RTN rtnwait4 = RTN_FindByName(img, \"wait4\");\n        if (RTN_Valid(rtnwait3) && RTN_IsSafeForProbedReplacement(rtnwait4))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wait4 at \" << RTN_Address(rtnwait4) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwait3, AFUNPTR(mywait4)));\n            fptrwait4 = fptr;\n        }\n\n        RTN rtnreadv = RTN_FindByName(img, \"readv\");\n        if (RTN_Valid(rtnreadv) && RTN_IsSafeForProbedReplacement(rtnreadv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for readv at \" << RTN_Address(rtnreadv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnreadv, AFUNPTR(myreadv)));\n            fptrreadv = fptr;\n        }\n\n        RTN rtnwritev = RTN_FindByName(img, \"writev\");\n        if (RTN_Valid(rtnwritev) && RTN_IsSafeForProbedReplacement(rtnwritev))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for writev at \" << RTN_Address(rtnwritev) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwritev, AFUNPTR(mywritev)));\n            fptrwritev = fptr;\n        }\n\n        RTN rtnflockfile = RTN_FindByName(img, \"flockfile\");\n        if (RTN_Valid(rtnflockfile) && RTN_IsSafeForProbedReplacement(rtnflockfile))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flockfile at \" << RTN_Address(rtnflockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflockfile, AFUNPTR(myflockfile)));\n            fptrflockfile = fptr;\n        }\n        RTN rtnfunlockfile = RTN_FindByName(img, \"funlockfile\");\n        if (RTN_Valid(rtnfunlockfile)\n                && RTN_IsSafeForProbedReplacement(rtnfunlockfile)) {\n            OutFile << CurrentTime() << \"Inserting probe for funlockfile at \"\n                    << RTN_Address(rtnfunlockfile) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfunlockfile,\n                    AFUNPTR(myfunlockfile)));\n            fptrfunlockfile = fptr;}\n\n        RTN rtnlockf = RTN_FindByName(img, \"lockf\");\n        if (RTN_Valid(rtnlockf) && RTN_IsSafeForProbedReplacement(rtnlockf))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lockf at \" << RTN_Address(rtnlockf) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlockf, AFUNPTR(mylockf)));\n            fptrlockf = fptr;\n        }\n\n        RTN rtnsetenv = RTN_FindByName(img, \"setenv\");\n        if (RTN_Valid(rtnsetenv) && RTN_IsSafeForProbedReplacement(rtnsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for setenv at \" << RTN_Address(rtnsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsetenv, AFUNPTR(mysetenv)));\n            fptrsetenv = fptr;\n        }\n\n        RTN rtnunsetenv = RTN_FindByName(img, \"unsetenv\");\n        if (RTN_Valid(rtnunsetenv) && RTN_IsSafeForProbedReplacement(rtnunsetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unsetenv at \" << RTN_Address(rtnunsetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunsetenv, AFUNPTR(myunsetenv)));\n            fptrunsetenv = fptr;\n        }\n\n        RTN rtngetenv = RTN_FindByName(img, \"getenv\");\n        if (RTN_Valid(rtngetenv) && RTN_IsSafeForProbedReplacement(rtngetenv))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getenv at \"\n                    << RTN_Address(rtngetenv) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetenv, AFUNPTR(mygetenv)));\n            fptrgetenv = fptr;\n        }\n\n        RTN rtnperror = RTN_FindByName(img, \"perror\");\n        if (RTN_Valid(rtnperror) && RTN_IsSafeForProbedReplacement(rtnperror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for perror at \"\n                    << RTN_Address(rtnperror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnperror, AFUNPTR(myperror)));\n            fptrperror = fptr;\n        }\n\n        RTN rtnmmap = RTN_FindByName(img, \"mmap\");\n        if (RTN_Valid(rtnmmap) && RTN_IsSafeForProbedReplacement(rtnmmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for mmap at \"\n                    << RTN_Address(rtnmmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmmap, AFUNPTR(mymmap)));\n            fptrmmap = fptr;\n        }\n\n        RTN rtnmunmap = RTN_FindByName(img, \"munmap\");\n        if (RTN_Valid(rtnmunmap) && RTN_IsSafeForProbedReplacement(rtnmunmap))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for munmap at \"\n                    << RTN_Address(rtnmunmap) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmunmap, AFUNPTR(mymunmap)));\n            fptrmunmap = fptr;\n        }\n\n        RTN rtnfileno = RTN_FindByName(img, \"fileno\");\n        if (RTN_Valid(rtnfileno) && RTN_IsSafeForProbedReplacement(rtnfileno))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fileno at \"\n                    << RTN_Address(rtnfileno) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfileno, AFUNPTR(myfileno)));\n            fptrfileno = fptr;\n        }\n\n        RTN rtngetpid = RTN_FindByName(img, \"getpid\");\n        if (RTN_Valid(rtngetpid) && RTN_IsSafeForProbedReplacement(rtngetpid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getpid at \"\n                    << RTN_Address(rtngetpid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetpid, AFUNPTR(mygetpid)));\n            fptrgetpid = fptr;\n        }\n\n        RTN rtngetppid = RTN_FindByName(img, \"getppid\");\n        if (RTN_Valid(rtngetppid) && RTN_IsSafeForProbedReplacement(rtngetppid))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for getppid at \" << RTN_Address(rtngetppid) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngetppid, AFUNPTR(mygetppid)));\n            fptrgetppid = fptr;\n        }\n\n        RTN rtnmemset = RTN_FindByName(img, \"memset\");\n        if (RTN_Valid(rtnmemset) && RTN_IsSafeForProbedReplacement(rtnmemset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for memset at \" << RTN_Address(rtnmemset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemset, AFUNPTR(mymemset)));\n            fptrmemset = fptr;\n        }\n\n        RTN rtnmemcpy = RTN_FindByName(img, \"memcpy\");\n        if (RTN_Valid(rtnmemcpy) && RTN_IsSafeForProbedReplacement(rtnmemcpy))\n        {\n            if (!is_GLIBC2_24_or_newer(img))\n            {\n                OutFile << CurrentTime() << \"Inserting probe for memcpy at \" << RTN_Address(rtnmemcpy) << endl;\n                OutFile.flush();\n                AFUNPTR fptr = (RTN_ReplaceProbed(rtnmemcpy, AFUNPTR(mymemcpy)));\n                fptrmemcpy = fptr;\n            }\n        }\n\n        RTN rtnaccess = RTN_FindByName(img, \"access\");\n        if (RTN_Valid(rtnaccess) && RTN_IsSafeForProbedReplacement(rtnaccess))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for access at \" << RTN_Address(rtnaccess) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnaccess, AFUNPTR(myaccess)));\n            fptraccess = fptr;\n        }\n\n        RTN rtnlseek = RTN_FindByName(img, \"lseek\");\n        if (RTN_Valid(rtnlseek) && RTN_IsSafeForProbedReplacement(rtnlseek))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek at \" << RTN_Address(rtnlseek) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek, AFUNPTR(mylseek)));\n            fptrlseek = fptr;\n        }\n\n        RTN rtnlseek64 = RTN_FindByName(img, \"lseek64\");\n        if (RTN_Valid(rtnlseek64) && RTN_IsSafeForProbedReplacement(rtnlseek64))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for lseek64 at \" << RTN_Address(rtnlseek64) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlseek64, AFUNPTR(mylseek64)));\n            fptrlseek64 = fptr;\n        }\n\n        RTN rtnfdatasync = RTN_FindByName(img, \"fdatasync\");\n        if (RTN_Valid(rtnfdatasync) && RTN_IsSafeForProbedReplacement(rtnfdatasync))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for fdatasync at \" << RTN_Address(rtnfdatasync) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnfdatasync, AFUNPTR(myfdatasync)));\n            fptrfdatasync = fptr;\n        }\n\n        RTN rtnunlink = RTN_FindByName(img, \"unlink\");\n        if (RTN_Valid(rtnunlink) && RTN_IsSafeForProbedReplacement(rtnunlink))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for unlink at \" << RTN_Address(rtnunlink) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnunlink, AFUNPTR(myunlink)));\n            fptrunlink = fptr;\n        }\n\n        RTN rtnstrlen = RTN_FindByName(img, \"strlen\");\n        if (RTN_Valid(rtnstrlen) && RTN_IsSafeForProbedReplacement(rtnstrlen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strlen at \" << RTN_Address(rtnstrlen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrlen, AFUNPTR(mystrlen)));\n            fptrstrlen = fptr;\n        }\n\n        RTN rtnwcslen = RTN_FindByName(img, \"wcslen\");\n        if (RTN_Valid(rtnwcslen) && RTN_IsSafeForProbedReplacement(rtnwcslen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for wcslen at \"<< RTN_Address(rtnwcslen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnwcslen, AFUNPTR(mywcslen)));\n            fptrwcslen = fptr;\n        }\n\n        RTN rtnstrcpy = RTN_FindByName(img, \"strcpy\");\n        if (RTN_Valid(rtnstrcpy) && RTN_IsSafeForProbedReplacement(rtnstrcpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcpy at \" << RTN_Address(rtnstrcpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcpy, AFUNPTR(mystrcpy)));\n            fptrstrcpy = fptr;\n        }\n\n        RTN rtnstrncpy = RTN_FindByName(img, \"strncpy\");\n        if (RTN_Valid(rtnstrncpy) && RTN_IsSafeForProbedReplacement(rtnstrncpy))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncpy at \" << RTN_Address(rtnstrncpy) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncpy, AFUNPTR(mystrcpy)));\n            fptrstrncpy = fptr;\n        }\n\n        RTN rtnstrcat = RTN_FindByName(img, \"strcat\");\n        if (RTN_Valid(rtnstrcat) && RTN_IsSafeForProbedReplacement(rtnstrcat))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcat at \" << RTN_Address(rtnstrcat) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcat, AFUNPTR(mystrcat)));\n            fptrstrcat = fptr;\n        }\n\n        RTN rtnstrstr = RTN_FindByName(img, \"strstr\");\n        if (RTN_Valid(rtnstrstr) && RTN_IsSafeForProbedReplacement(rtnstrstr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strstr at \" << RTN_Address(rtnstrstr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrstr, AFUNPTR(mystrstr)));\n            fptrstrstr = fptr;\n        }\n\n        RTN rtnstrchr0 = RTN_FindByName(img, \"strchr0\");\n        if (RTN_Valid(rtnstrchr0) && RTN_IsSafeForProbedReplacement(rtnstrchr0))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strchr0 at \" << RTN_Address(rtnstrchr0) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrchr0, AFUNPTR(mystrchr0)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrrchr = RTN_FindByName(img, \"strrchr\");\n        if (RTN_Valid(rtnstrrchr) && RTN_IsSafeForProbedReplacement(rtnstrrchr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strrchr at \"\n                    << RTN_Address(rtnstrrchr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrrchr, AFUNPTR(mystrrchr)));\n            fptrstrrchr = fptr;\n        }\n\n        RTN rtnstrcmp = RTN_FindByName(img, \"strcmp\");\n        if (RTN_Valid(rtnstrcmp) && RTN_IsSafeForProbedReplacement(rtnstrcmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strcmp at \" << RTN_Address(rtnstrcmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrcmp, AFUNPTR(mystrcmp)));\n            fptrstrcmp = fptr;\n        }\n\n        RTN rtnstrncmp = RTN_FindByName(img, \"strncmp\");\n        if (RTN_Valid(rtnstrncmp) && RTN_IsSafeForProbedReplacement(rtnstrncmp))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strncmp at \" << RTN_Address(rtnstrncmp) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrncmp, AFUNPTR(mystrncmp)));\n            fptrstrncmp = fptr;\n        }\n\n        RTN rtnsigaddset = RTN_FindByName(img, \"sigaddset\");\n        if (RTN_Valid(rtnsigaddset) && RTN_IsSafeForProbedReplacement(rtnsigaddset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaddset at \" << RTN_Address(rtnsigaddset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaddset, AFUNPTR(mysigaddset)));\n            fptrsigaddset = fptr;\n        }\n\n        RTN rtnsigdelset = RTN_FindByName(img, \"sigdelset\");\n        if (RTN_Valid(rtnsigdelset) && RTN_IsSafeForProbedReplacement(rtnsigdelset))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigdelset at \"<< RTN_Address(rtnsigdelset) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigdelset, AFUNPTR(mysigdelset)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnsigismember = RTN_FindByName(img, \"sigismember\");\n        if (RTN_Valid(rtnsigismember) && RTN_IsSafeForProbedReplacement(rtnsigismember))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigismember at \" << RTN_Address(rtnsigismember) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigismember, AFUNPTR(mysigismember)));\n            fptrsigdelset = fptr;\n        }\n\n        RTN rtnstrerror = RTN_FindByName(img, \"strerror\");\n        if (RTN_Valid(rtnstrerror) && RTN_IsSafeForProbedReplacement(rtnstrerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for strerror at \" << RTN_Address(rtnstrerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnstrerror, AFUNPTR(mystrerror)));\n            fptrstrerror = fptr;\n        }\n\n        RTN rtnbind = RTN_FindByName(img, \"bind\");\n        if (RTN_Valid(rtnbind) && RTN_IsSafeForProbedReplacement(rtnbind))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for bind at \" << RTN_Address(rtnbind) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnbind, AFUNPTR(mybind)));\n            fptrbind = fptr;\n        }\n\n        RTN rtnlisten = RTN_FindByName(img, \"listen\");\n        if (RTN_Valid(rtnlisten) && RTN_IsSafeForProbedReplacement(rtnlisten))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for listen at \" << RTN_Address(rtnlisten) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnlisten, AFUNPTR(mylisten)));\n            fptrlisten = fptr;\n        }\n\n        RTN rtnuname = RTN_FindByName(img, \"uname\");\n        if (RTN_Valid(rtnuname) && RTN_IsSafeForProbedReplacement(rtnuname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for uname at \"    << RTN_Address(rtnuname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnuname, AFUNPTR(myuname)));\n            fptruname = fptr;\n        }\n\n        RTN rtngethostname = RTN_FindByName(img, \"gethostname\");\n        if (RTN_Valid(rtngethostname) && RTN_IsSafeForProbedReplacement(rtngethostname))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for gethostname at \" << RTN_Address(rtngethostname) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtngethostname, AFUNPTR(mygethostname)));\n            fptrgethostname = fptr;\n        }\n\n        RTN rtnkill = RTN_FindByName(img, \"kill\");\n        if (RTN_Valid(rtnkill) && RTN_IsSafeForProbedReplacement(rtnkill))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for kill at \" << RTN_Address(rtnkill) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnkill, AFUNPTR(mykill)));\n            fptrkill = fptr;\n        }\n\n        RTN rtnsched_yield = RTN_FindByName(img, \"sched_yield\");\n        if (RTN_Valid(rtnsched_yield) && RTN_IsSafeForProbedReplacement(rtnsched_yield)) {\n            OutFile << CurrentTime() << \"Inserting probe for sched_yield at \" << RTN_Address(rtnsched_yield) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsched_yield, AFUNPTR(mysched_yield)));\n            fptrsched_yield = fptr;\n        }\n\n        RTN rtntimer_settime = RTN_FindByName(img, \"timer_settime\");\n        if (RTN_Valid(rtntimer_settime) && RTN_IsSafeForProbedReplacement(rtntimer_settime))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for timer_settime at \" << RTN_Address(rtntimer_settime) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtntimer_settime, AFUNPTR(mytimer_settime)));\n            fptrtimer_settime = fptr;\n        }\n\n        RTN rtnsigaltstack = RTN_FindByName(img, \"sigaltstack\");\n        if (RTN_Valid(rtnsigaltstack) && RTN_IsSafeForProbedReplacement(rtnsigaltstack))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for sigaltstack at \" << RTN_Address(rtnsigaltstack) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsigaltstack, AFUNPTR(mysigaltstack)));\n            fptrsigaltstack = fptr;\n        }\n\n        RTN rtnioctl = RTN_FindByName(img, \"ioctl\");\n        if (RTN_Valid(rtnioctl) && RTN_IsSafeForProbedReplacement(rtnioctl))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for ioctl at \" << RTN_Address(rtnioctl) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnioctl, AFUNPTR(myioctl)));\n            fptrioctl = fptr;\n        }\n\n        RTN rtnflock = RTN_FindByName(img, \"flock\");\n        if (RTN_Valid(rtnflock) && RTN_IsSafeForProbedReplacement(rtnflock))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for flock at \" << RTN_Address(rtnflock) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnflock, AFUNPTR(myflock)));\n            fptrflock = fptr;\n        }\n\n        RTN rtn__libc_dlopen_mode = RTN_FindByName(img, \"__libc_dlopen_mode\");\n        if (RTN_Valid(rtn__libc_dlopen_mode) && RTN_IsSafeForProbedReplacement(rtn__libc_dlopen_mode))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __libc_dlopen_mode at \" << RTN_Address(rtn__libc_dlopen_mode) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__libc_dlopen_mode, AFUNPTR(my__libc_dlopen_mode)));\n            fptr__libc_dlopen_mode = fptr;\n        }\n\n        RTN rtn__errno_location = RTN_FindByName(img, \"__errno_location\");\n        if (RTN_Valid(rtn__errno_location) && RTN_IsSafeForProbedReplacement(rtn__errno_location))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for __errno_location at \" << RTN_Address(rtn__errno_location) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtn__errno_location, AFUNPTR(my__errno_location)));\n            fptr__errno_location = fptr;\n        }\n\n        RTN rtnsyscall = RTN_FindByName(img, \"syscall\");\n        if (RTN_Valid(rtnsyscall) && RTN_IsSafeForProbedReplacement(rtnsyscall))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for syscall at \" << RTN_Address(rtnsyscall) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtnsyscall, AFUNPTR(mysyscall)));\n            fptrsyscall = fptr;}\n        }\n        // finished instrumentation\n    }\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[]) {\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/dltest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/malloctrace2.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called\n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\nusing std::cerr;\nusing std::endl;\nusing std::cout;\n\n#ifdef TARGET_MAC\n# define MALLOC_LIB \"libsystem_malloc.dylib\"\n#else\n# define MALLOC_LIB \"libc.so\"\n#endif\n\n\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(SHARED_LIB(\"libmallocwrappers\"), RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        //\n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n\n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n\n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn))\n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn))\n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n\n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n\n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n\n    }\n    if (strstr(IMG_Name(img).c_str(), \"libdyld.dylib\"))\n    {\n        RTN dlopenRtn = RTN_FindByName(img, C_MANGLE(\"dlopen\") );\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, C_MANGLE(\"dlsym\") );\n\n        // In some systems, dlsym and dlopen symbols don't exist.\n        // In this case, exit with special return code.\n        if (!RTN_Valid(dlsymRtn) && !RTN_Valid(dlopenRtn))\n        {\n            cerr << \"Error: dlsym and dlopen not found\" << endl;\n            PIN_ExitApplication(13);\n        }\n\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n    }\n\n    if (strstr(IMG_Name(img).c_str(), MALLOC_LIB))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, C_MANGLE(\"malloc\"));\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, C_MANGLE(\"free\"));\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n\n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n\n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n\n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n\n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n\n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n\n    IMG_AddInstrumentFunction(ImageLoad, 0);\n\n    PIN_StartProgramProbed();\n\n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/tpss_lin_libc.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libc functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n *\n * This file is part of the tpss_lin_libc tool and compiles against the native\n * libc of the machine/compiler in order to extact data types definition from it's headers.\n */\n\n#define _GNU_SOURCE\n#include <link.h>\n#include <sys/types.h>\n#include <sys/timeb.h>\n#include <rpc/rpc.h>\n#include <rpc/pmap_clnt.h>\n#include <semaphore.h>\n#include <dlfcn.h>\n#include <signal.h>\n#include <poll.h>\n#include <time.h>\n#include <link.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/ipc.h>\n#include <sys/sem.h>\n#include <signal.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n#include <sys/socket.h>\n#include <sys/utsname.h>\n#include <sched.h>\n#include <time.h>\n\ntypedef int * INT_PTR;\n\ntypedef void * VOID_PTR;\n\ntypedef char * CHAR_PTR;\n\nvoid printFunctionCalled(const char* funcName);\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nint (*fptrnanosleep)(const struct timespec *__rqtp, struct timespec *__rmtp);\n\nint (*fptrdl_iterate_phdr)(int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n    VOID_PTR __data), VOID_PTR __data);\n\nint (*fptrsystem)(const CHAR_PTR __command);\n\nunsigned int (*fptralarm)(unsigned int __seconds);\n\nssize_t (*fptrrecvmsg)(int __socket, struct msghdr *__message, int __flags);\n\nssize_t (*fptrsendmsg)(int __sockfd, const struct msghdr *__msg, int __flags);\n\nint (*fptrpause)(void);\n\nint (*fptrsigtimedwait)(const sigset_t *__set, siginfo_t *__info, const struct timespec *__timeout);\n\nint (*fptrsigwaitinfo)(const sigset_t *__set, siginfo_t *__info);\n\nint (*fptrepoll_wait)(int __epfd, struct epoll_event *__events, int __maxevents,\n    int __timeout);\n\nint (*fptrepoll_pwait)(int __epfd, struct epoll_event *__events,\n    int __maxevents, int __timeout, const sigset_t *__sigmask);\n\nint (*fptrppoll)(struct pollfd *__fds, nfds_t __nfds,\n    const struct timespec *__timeout_ts, const sigset_t *__sigmask);\n\nint (*fptrmsgsnd)(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg);\n\nssize_t (*fptrmsgrcv)(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp, int __msgflg);\n\nint (*fptrsemop)(int __semid, struct sembuf *__sops, unsigned __nsops);\n\nint (*fptrsemtimedop)(int __semid, struct sembuf *__sops);\n\nint (*fptrusleep)(useconds_t __usec);\n\nuseconds_t (*fptrualarm)(useconds_t __usecs, useconds_t __interval);\n\nint (*fptrgetitimer)(int __which, struct itimerval *__curr_value);\n\nint (*fptrsigwait)(const sigset_t *__set, INT_PTR __sig);\n\nint (*fptrmsgget)(key_t __key, int __msgflg);\n\nint (*fptrsemget)(key_t __key, int __nsems, int __semflg);\n\npid_t (*fptrwait)(INT_PTR __status);\n\npid_t (*fptrwaitpid)(pid_t __pid, INT_PTR __atus, int __options);\n\nint (*fptrwaitid)(idtype_t __idtype, id_t __id, siginfo_t *__infop,int __options);\n\npid_t (*fptrwait3)(INT_PTR __status, int __options, struct rusage *__rusage);\n\npid_t (*fptrwait4)(pid_t __pid, INT_PTR status, int __options, struct rusage *__rusage);\n\nssize_t (*fptrreadv)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nssize_t (*fptrwritev)(int __fd, const struct iovec *__iov, int __iovcnt);\n\nint (*fptrflock)(int __fd, int __operation);\n\nvoid (*fptrflockfile)(FILE *__filehandle);\n\nvoid (*fptrfunlockfile)(FILE *__filehandle);\n\nint (*fptrlockf)(int __fd, int __cmd, off_t __len);\n\nint (*fptrsetenv)(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite);\n\nint (*fptrunsetenv)(const CHAR_PTR __name);\n\nCHAR_PTR (*fptrgetenv)(const CHAR_PTR __name);\n\nvoid (*fptrperror)(const CHAR_PTR __s);\n\nVOID_PTR (*fptrmmap)(VOID_PTR __addr, size_t __len, int __prot, int __flags,\n        int __fildes, off_t __off);\n\nint (*fptrmunmap)(VOID_PTR __addr, size_t __len);\n\nint (*fptrfileno)(FILE *__stream);\n\npid_t (*fptrgetpid)(void);\n\npid_t (*fptrgetppid)(void);\n\nVOID_PTR (*fptrmemset)(VOID_PTR __s, int __c, size_t __n);\n\nVOID_PTR (*fptrmemcpy)(VOID_PTR __dest, const VOID_PTR __src, size_t __n);\n\nint (*fptraccess)(const CHAR_PTR __pathname, int __mode);\n\noff_t (*fptrlseek)(int __fd, off_t __offset, int __whence);\n\noff64_t (*fptrlseek64)(int __fd, off64_t __offset, int __whence);\n\nint (*fptrfdatasync)(int __fd);\n\nint (*fptrunlink)(const CHAR_PTR __pathname);\n\nsize_t (*fptrstrlen)(const CHAR_PTR __s);\n\nsize_t (*fptrwcslen)(const wchar_t *__s);\n\nCHAR_PTR (*fptrstrcpy)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrncpy)(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n);\n\nCHAR_PTR (*fptrstrcat)(CHAR_PTR __dest, const CHAR_PTR __src);\n\nCHAR_PTR (*fptrstrstr)(const CHAR_PTR __haystack, const CHAR_PTR __needle);\n\nCHAR_PTR (*fptrstrchr0)(const CHAR_PTR __s, int __c);\n\nCHAR_PTR (*fptrstrrchr)(const CHAR_PTR __s, int __c);\n\nint (*fptrstrcmp)(const CHAR_PTR __s1, const CHAR_PTR __s2);\n\nint (*fptrstrncmp)(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n);\n\nint (*fptrsigaddset)(sigset_t *__set, int __signum);\n\nint (*fptrsigdelset)(sigset_t *__set, int __signum);\n\nint (*fptrsigismember)(const sigset_t *__set, int __signum);\n\nCHAR_PTR (*fptrstrerror)(int __errnum);\n\nint (*fptrbind)(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen);\n\nint (*fptrlisten)(int __sockfd, int __backlog);\n\nint (*fptruname)(struct utsname *__name);\n\nint (*fptrgethostname)(CHAR_PTR __name, size_t __len);\n\nint (*fptrkill)(pid_t __pid, int __sig);\n\nint (*fptrsched_yield)(void);\n\nint (*fptrtimer_settime)(timer_t __timerid, int __flags, const struct itimerspec * __value, struct itimerspec * __ovalue);\n\nint (*fptrsigaltstack)(const stack_t *__ss, stack_t *__oss);\n\nint (*fptrshutdown)(int, int);\n\nint (*fptrsleep)(unsigned int);\n\nint (*fptrsocket)(int, int, int);\n\nint (*fptrselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, struct timeval *__restrict);\n\nint (*fptrpoll)(struct pollfd *, nfds_t, int);\n\nint (*fptraccept)(int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nint (*fptrconnect)(int, __CONST_SOCKADDR_ARG, socklen_t);\n\nssize_t (*fptrrecv)(int, VOID_PTR , size_t, int);\n\nssize_t (*fptrrecvfrom)(int, VOID_PTR __restrict, size_t, int, __SOCKADDR_ARG, socklen_t *__restrict);\n\nssize_t (*fptrsend)(int, __const VOID_PTR , size_t, int);\n\nwint_t (*fptrgetwc)(__FILE *);\n\nint (*fptrsetitimer)(__itimer_which_t, __const struct itimerval *__restrict, struct itimerval *__restrict);\n\nint (*fptrsigpending)(sigset_t *);\n\nint (*fptrsigaction)(int, __const struct sigaction *__restrict, struct sigaction *__restrict);\n\n__sighandler_t (*fptrsignal)(int, __sighandler_t);\n\nvoid (*fptrabort)();\n\nssize_t (*fptrsendto)(int, __const VOID_PTR , size_t, int, __CONST_SOCKADDR_ARG, socklen_t);\n\nint (*fptr_IO_getc)(FILE *);\n\nint (*fptrgetchar)();\n\nwint_t (*fptrgetwchar)();\n\nCHAR_PTR  (*fptrgets)(CHAR_PTR );\n\nCHAR_PTR  (*fptrfgets)(CHAR_PTR __restrict, int, FILE *__restrict);\n\nwint_t (*fptrfgetwc)(__FILE *);\n\nsize_t (*fptrfread)(VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nsize_t (*fptrfwrite)(__const VOID_PTR __restrict, size_t, size_t, FILE *__restrict);\n\nint (*fptropen)(__const CHAR_PTR , int, mode_t);\n\nint (*fptrgetw)(FILE *);\n\nvoid (*fptrfgetc)(__FILE *);\n\nwchar_t * (*fptrfgetws)(wchar_t *__restrict, int, __FILE *__restrict);\n\nint (*fptrpipe)(int[2]);\n\nssize_t (*fptrread)(int, VOID_PTR , size_t);\n\nssize_t (*fptrwrite)(int, __const VOID_PTR , size_t);\n\nFILE * (*fptrfopen)(__const CHAR_PTR __restrict, __const CHAR_PTR __restrict);\n\nFILE * (*fptrfdopen)(int, __const CHAR_PTR );\n\nint (*fptrclose)(int);\n\nint (*fptrfclose)(FILE *);\n\nint (*fptrcallrpc)(__const CHAR_PTR , u_long, u_long, u_long, xdrproc_t, __const CHAR_PTR , xdrproc_t, CHAR_PTR );\n\nenum clnt_stat (*fptrclnt_broadcast)(u_long, u_long, u_long, xdrproc_t, caddr_t,\n        xdrproc_t, caddr_t, resultproc_t);\n\nCLIENT * (*fptrclntudp_create)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR );\n\nCLIENT * (*fptrclntudp_bufcreate)(struct sockaddr_in *, u_long, u_long, struct timeval, INT_PTR , u_int, u_int);\n\nstruct pmaplist * (*fptrpmap_getmaps)(struct sockaddr_in *);\n\nu_short (*fptrpmap_getport)(struct sockaddr_in *, u_long, u_long, u_int);\n\nenum clnt_stat (*fptrpmap_rmtcall)(struct sockaddr_in *, u_long, u_long, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t, struct timeval, u_long *);\n\nbool_t (*fptrpmap_set)(u_long, u_long, int, u_short);\n\nCLIENT * (*fptrclntraw_create)(u_long, u_long);\n\nvoid (*fptrsvc_run)();\n\nbool_t (*fptrsvc_sendreply)(SVCXPRT *, xdrproc_t, caddr_t);\n\nSVCXPRT * (*fptrsvcraw_create)();\n\nSVCXPRT * (*fptrsvctcp_create)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_bufcreate)(int, u_int, u_int);\n\nSVCXPRT * (*fptrsvcudp_create)(int);\n\nvoid (*fptr_exit)(int);\n\nint (*fptrsigprocmask)(int, __const sigset_t *__restrict, sigset_t *__restrict);\n\nvoid (*fptrexit)(int);\n\nint (*fptrpselect)(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict, \n    const struct timespec *__restrict, const __sigset_t *__restrict);\n\nint (*fptrioctl)(int __d, int __request, CHAR_PTR  __argp);\n\nint (*fptrfcntl)(int __fd, int __cmd, VOID_PTR  __argp);\n\nVOID_PTR (*fptr__libc_dlopen_mode)(const CHAR_PTR __name, int __mode);\n\nINT_PTR  (*fptr__errno_location)(void);\n\nint (*fptrsyscall)(int __number, long int __arg1, long int __arg2, long int __arg3,\n     long int __arg4, long int __arg5, long int __arg6, long int __arg7);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nint mynanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"mynanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\nint mydl_iterate_phdr(\n        int (*__callback)(struct dl_phdr_info *__info, size_t __size,\n                VOID_PTR __data), VOID_PTR __sec_data) \n{\n    printFunctionCalled(\"mydl_iterate_phdr\");\n    int res = fptrdl_iterate_phdr((__callback), __sec_data);\n    return res;\n}\n\nint mysystem(const CHAR_PTR __command) \n{\n    printFunctionCalled(\"mysystem\");\n    int res = fptrsystem(__command);\n\n    return res;\n}\n\nunsigned int myalarm(unsigned int __seconds)\n{\n    printFunctionCalled(\"myalarm\");\n    unsigned int res = fptralarm(__seconds);\n\n    return res;\n}\n\nssize_t myrecvmsg(int __socket, struct msghdr *__message, int __flags)\n{\n    printFunctionCalled(\"myrecvmsg\");\n    ssize_t res = fptrrecvmsg(__socket, __message, __flags);\n\n    return res;\n}\n\nssize_t mysendmsg(int __sockfd, const struct msghdr *__msg, int __flags) \n{\n    printFunctionCalled(\"mysendmsg\");\n    ssize_t res = fptrsendmsg(__sockfd, __msg, __flags);\n\n    return res;\n}\n\nint mypause(void) \n{\n    printFunctionCalled(\"mypause\");\n    int res = fptrpause();\n\n    return res;\n}\n\nint mysigtimedwait(const sigset_t *__set, siginfo_t *__info,\n        const struct timespec *__timeout) \n{\n    printFunctionCalled(\"mysigtimedwait\");\n    int res = fptrsigtimedwait(__set, __info, __timeout);\n\n    return res;\n}\n\nint mysigwaitinfo(const sigset_t *__set, siginfo_t *__info) \n{\n    printFunctionCalled(\"mysigwaitinfo\");\n    int res = fptrsigwaitinfo(__set, __info);\n\n    return res;\n}\n\nint myepoll_wait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_wait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myepoll_pwait(int __epfd, struct epoll_event *__events, int __maxevents,\n        int __timeout) \n{\n    printFunctionCalled(\"myepoll_pwait\");\n    int res = fptrepoll_wait(__epfd, __events, __maxevents, __timeout);\n\n    return res;\n}\n\nint myppoll(struct pollfd *__fds, nfds_t __nfds,\n        const struct timespec *__timeout_ts, const sigset_t *__sigmask) \n{\n    printFunctionCalled(\"myppoll\");\n    int res = fptrppoll(__fds, __nfds, __timeout_ts, __sigmask);\n\n    return res;\n}\n\nint mymsgsnd(int __msqid, const VOID_PTR __msgp, size_t __msgsz, int __msgflg) \n{\n    printFunctionCalled(\"mymsgsnd\");\n    int res = fptrmsgsnd(__msqid, __msgp, __msgsz, __msgflg);\n\n    return res;\n}\n\nssize_t mymsgrcv(int __msqid, VOID_PTR __msgp, size_t __msgsz, long __msgtyp,\n        int __msgflg) \n{\n    printFunctionCalled(\"mymsgrcv\");\n    ssize_t res = fptrmsgrcv(__msqid, __msgp, __msgsz, __msgtyp, __msgflg);\n\n    return res;\n}\n\nint mysemtimedop(int __semid, struct sembuf *__sops) \n{\n    printFunctionCalled(\"mysemtimedop\");\n    int res = fptrsemtimedop(__semid, __sops);\n\n    return res;\n}\n\nint myusleep(useconds_t __usecs) \n{\n    printFunctionCalled(\"myusleep\");\n    int res = fptrusleep(__usecs);\n\n    return res;\n}\n\nuseconds_t myualarm(useconds_t __usecs, useconds_t __interval) \n{\n    printFunctionCalled(\"myualarm\");\n    useconds_t res = fptrualarm(__usecs, __interval);\n\n    return res;\n}\n\nint mygetitimer(int __which, struct itimerval *__curr_value) \n{\n    printFunctionCalled(\"mygetitimer\");\n    int res = fptrgetitimer(__which, __curr_value);\n\n    return res;\n}\n\nint mysigwait(const sigset_t *__set, INT_PTR __sig) \n{\n    printFunctionCalled(\"mysigwait\");\n    int res = fptrsigwait(__set, __sig);\n\n    return res;\n}\n\nint mymsgget(key_t __key, int __msgflg) \n{\n    printFunctionCalled(\"mymsgget\");\n    int res = fptrmsgget(__key, __msgflg);\n\n    return res;\n}\n\nint mysemget(key_t __key, int __nsems, int __semflg) \n{\n    printFunctionCalled(\"mysemget\");\n    int res = fptrsemget(__key, __nsems, __semflg);\n\n    return res;\n}\n\npid_t mywaitpid(pid_t __pid, INT_PTR __status, int __options) \n{\n    printFunctionCalled(\"mywaitpid\");\n    pid_t res = fptrwaitpid(__pid, __status, __options);\n\n    return res;\n}\n\nint mywaitid(idtype_t __idtype, id_t __id, siginfo_t *__infop, int __options)\n{\n    printFunctionCalled(\"mywaittid\");\n    int res = fptrwaitid(__idtype, __id, __infop, __options);\n\n    return res;\n}\n\npid_t mywait3(INT_PTR __status, int __options, struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait3\");\n    pid_t res = fptrwait3(__status, __options, __rusage);\n\n    return res;\n}\n\npid_t mywait4(pid_t __pid, INT_PTR __status, int __options,\n        struct rusage *__rusage) \n{\n    printFunctionCalled(\"mywait4\");\n    pid_t res = fptrwait4(__pid, __status, __options, __rusage);\n\n    return res;\n}\n\nssize_t myreadv(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"myreadv\");\n    ssize_t res = fptrreadv(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nssize_t mywritev(int __fd, const struct iovec *__iov, int __iovcnt) \n{\n    printFunctionCalled(\"mywritev\");\n    ssize_t res = fptrwritev(__fd, __iov, __iovcnt);\n\n    return res;\n}\n\nint myflock(int __fd, int __operation) \n{\n    printFunctionCalled(\"myflock\");\n    int res = fptrflock(__fd, __operation);\n\n    return res;\n}\n\nvoid myflockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myflockfile\");\n    fptrflockfile(__filehandle);\n}\n\nvoid myfunlockfile(FILE *__filehandle) \n{\n    printFunctionCalled(\"myfunlockfile\");\n    fptrfunlockfile(__filehandle);\n}\n\nint mylockf(int __fd, int __cmd, off_t __len) \n{\n    printFunctionCalled(\"mylockf\");\n    int res = fptrlockf(__fd, __cmd, __len);\n\n    return res;\n}\n\nint mysetenv(const CHAR_PTR __name, const CHAR_PTR __value, int __overwrite) \n{\n    printFunctionCalled(\"mysetenv\");\n    int res = fptrsetenv(__name, __value, __overwrite);\n\n    return res;\n}\n\nint myunsetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"myunsetenv\");\n    int res = fptrunsetenv(__name);\n\n    return res;\n}\n\nCHAR_PTR  mygetenv(const CHAR_PTR __name) \n{\n    printFunctionCalled(\"mygetenv\");\n    CHAR_PTR  res = fptrgetenv(__name);\n\n    return res;\n}\n\nvoid myperror(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"myperror\");\n    fptrperror(__s);\n\n}\n\nVOID_PTR  mymmap(VOID_PTR __addr, size_t __len, int __prot, int __flags, int __fildes,\n        off_t __off) \n{\n    printFunctionCalled(\"mymmap\");\n    VOID_PTR  res = fptrmmap(__addr, __len, __prot, __flags, __fildes, __off);\n\n    return res;\n}\n\nint mymunmap(VOID_PTR __addr, size_t __len) \n{\n    printFunctionCalled(\"mymunmap\");\n    int res = fptrmunmap(__addr, __len);\n\n    return res;\n}\n\nint myfileno(FILE *__stream)\n{   \n    printFunctionCalled(\"myfileno\");\n    int res = fptrfileno(__stream);\n\n    return res;\n}\n\npid_t mygetpid(void) \n{\n    printFunctionCalled(\"mygetpid\");\n    pid_t res = fptrgetpid();\n\n    return res;\n}\n\npid_t mygetppid(void) \n{\n    printFunctionCalled(\"mygetppid\");\n    pid_t res = fptrgetppid();\n\n    return res;\n}\n\nVOID_PTR  mymemset(VOID_PTR __s, int __c, size_t __n) {\n    printFunctionCalled(\"mymemset\");\n    VOID_PTR  res = fptrmemset(__s, __c, __n);\n\n    return res;\n}\n\nVOID_PTR  mymemcpy(VOID_PTR __dest, const VOID_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mymemcpy\");\n    VOID_PTR  res = fptrmemcpy(__dest, __src, __n);\n\n    return res;\n}\n\nint myaccess(const CHAR_PTR __pathname, int __mode) \n{\n    printFunctionCalled(\"myaccess\");\n    int res = fptraccess(__pathname, __mode);\n\n    return res;\n}\n\noff_t mylseek(int __fd, off_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek\");\n    off_t res = fptrlseek(__fd, __offset, __whence);\n\n    return res;\n}\n\noff64_t mylseek64(int __fd, off64_t __offset, int __whence) \n{\n    printFunctionCalled(\"mylseek64\");\n    off64_t res = fptrlseek64(__fd, __offset, __whence);\n\n    return res;\n}\n\nint myfdatasync(int __fd) {\n    printFunctionCalled(\"myfdatasync\");\n    int res = fptrfdatasync(__fd);\n\n    return res;\n}\n\nint myunlink(const CHAR_PTR __pathname) \n{\n    printFunctionCalled(\"myunlink\");\n    int res = fptrunlink(__pathname);\n\n    return res;\n}\n\nsize_t mystrlen(const CHAR_PTR __s) \n{\n    printFunctionCalled(\"mystrlen\");\n    size_t res = fptrstrlen(__s);\n\n    return res;\n}\n\nsize_t mywcslen(const wchar_t *__s)\n{\n    printFunctionCalled(\"mywcslen\");\n    size_t res = fptrwcslen(__s);\n\n    return res;\n}\n\nCHAR_PTR  mystrcpy(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcpy\");\n    CHAR_PTR  res = fptrstrcpy(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrncpy(CHAR_PTR __dest, const CHAR_PTR __src, size_t __n) \n{\n    printFunctionCalled(\"mystrncpy\");\n    CHAR_PTR  res = fptrstrncpy(__dest, __src, __n);\n\n    return res;\n}\n\nCHAR_PTR  mystrcat(CHAR_PTR __dest, const CHAR_PTR __src) \n{\n    printFunctionCalled(\"mystrcat\");\n    CHAR_PTR  res = fptrstrcat(__dest, __src);\n\n    return res;\n}\n\nCHAR_PTR  mystrstr(const CHAR_PTR __haystack, const CHAR_PTR __needle) \n{\n    printFunctionCalled(\"mystrstr\");\n    CHAR_PTR  res = fptrstrstr(__haystack, __needle);\n\n    return res;\n}\n\nCHAR_PTR  mystrchr0(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrchr0\");\n    CHAR_PTR  res = fptrstrchr0(__s, __c);\n\n    return res;\n}\n\nCHAR_PTR  mystrrchr(const CHAR_PTR __s, int __c) \n{\n    printFunctionCalled(\"mystrrchr\");\n    CHAR_PTR  res = fptrstrrchr(__s, __c);\n\n    return res;\n}\n\nint mystrcmp(const CHAR_PTR __s1, const CHAR_PTR __s2) \n{\n    printFunctionCalled(\"mystrcmp\");\n    int res = fptrstrcmp(__s1, __s2);\n\n    return res;\n}\n\nint mystrncmp(const CHAR_PTR __s1, const CHAR_PTR __s2, size_t __n) \n{\n    printFunctionCalled(\"mystrncmp\");\n    int res = fptrstrncmp(__s1, __s2, __n);\n\n    return res;\n}\n\nint mysigaddset(sigset_t *__set, int __signum) \n{\n    printFunctionCalled(\"mysigaddset\");\n    int res = fptrsigaddset(__set, __signum);\n\n    return res;\n}\n\nint mysigdelset(sigset_t *__set, int __signum) {\n    printFunctionCalled(\"mysigdelset\");\n    int res = fptrsigdelset(__set, __signum);\n\n    return res;\n}\n\nint mysigismember(sigset_t *__set, int __signum)\n{\n    printFunctionCalled(\"mysigismember\");\n    int res = fptrsigismember(__set, __signum);\n\n    return res;\n}\n\nCHAR_PTR  mystrerror(int __errnum) \n{\n    printFunctionCalled(\"mystrerror\");\n    CHAR_PTR  res = fptrstrerror(__errnum);\n\n    return res;\n}\n\nint mybind(int __sockfd, const struct sockaddr *__addr, socklen_t __addrlen) \n{\n    printFunctionCalled(\"mybind\");\n    int res = fptrbind(__sockfd, __addr, __addrlen);\n\n    return res;\n}\n\nint mylisten(int __sockfd, int __backlog) \n{\n    printFunctionCalled(\"mylisten\");\n    int res = fptrlisten(__sockfd, __backlog);\n\n    return res;\n}\n\nint myuname(struct utsname *__name) \n{\n    printFunctionCalled(\"myuname\");\n    int res = fptruname(__name);\n\n    return res;\n}\n\nint mygethostname(CHAR_PTR __name, size_t __len) \n{\n    printFunctionCalled(\"mygethostname\");\n    int res = fptrgethostname(__name, __len);\n\n    return res;\n}\n\nint mykill(pid_t __pid, int __sig) \n{\n    printFunctionCalled(\"mykill\");\n    int res = fptrkill(__pid, __sig);\n\n    return res;\n}\n\nint mysched_yield(void) \n{\n    printFunctionCalled(\"mysched_yield\");\n    int res = fptrsched_yield();\n\n    return res;\n}\n\nint mytimer_settime(timer_t __timerid, int __flags,\n        const struct itimerspec * __value, struct itimerspec * __ovalue) \n{\n    printFunctionCalled(\"mytimer_settime\");\n    int res = fptrtimer_settime(__timerid, __flags, __value, __ovalue);\n\n    return res;\n}\n\nint mysigaltstack(const stack_t *__ss, stack_t *__oss) \n{\n    printFunctionCalled(\"mysigaltstacke\");\n    int res = fptrsigaltstack(__ss, __oss);\n\n    return res;\n}\n\nint mysleep(unsigned int __seconds) \n{\n    printFunctionCalled(\"mysleep\");\n    int res = fptrsleep(__seconds);\n\n    return res;\n}\n\nint mysocket(int __domain, int __type, int __protocol) \n{\n    printFunctionCalled(\"mysocket\");\n    int res = fptrsocket(__domain, __type, __protocol);\n\n    return res;\n}\n\nint myshutdown(int __fd, int __how) \n{\n    printFunctionCalled(\"myshutdown\");\n    int res = fptrshutdown(__fd, __how);\n\n    return res;\n}\n\nint myselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        struct timeval *__restrict __timeout) \n{\n    printFunctionCalled(\"myselect\");\n    int res = fptrselect(__nfds, __readfds, __writefds, __exceptfds, __timeout);\n\n    return res;\n}\n\nint mypoll(struct pollfd * __fds, nfds_t __nfds, int __timeout) \n{\n    printFunctionCalled(\"mypoll\");\n    int res = fptrpoll(__fds, __nfds, __timeout);\n\n    return res;\n}\n\nint myaccept(int __fd, __SOCKADDR_ARG __addr,\n        socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myaccept\");\n    int res = fptraccept(__fd, __addr, __addr_len);\n\n    return res;\n}\n\nint myconnect(int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len) \n{\n    printFunctionCalled(\"myconnect\");\n    int res = fptrconnect(__fd, __addr, __len);\n\n    return res;\n}\n\nssize_t myrecv(int __fd, VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"myrecv\");\n    ssize_t res = fptrrecv(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nssize_t myrecvfrom(int __fd, VOID_PTR __restrict __buf, size_t __n, int __flags,\n        __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) \n{\n    printFunctionCalled(\"myrecvfrom\");\n    ssize_t res = fptrrecvfrom(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nssize_t mysend(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags) \n{\n    printFunctionCalled(\"mysend\");\n    ssize_t res = fptrsend(__fd, __buf, __n, __flags);\n\n    return res;\n}\n\nwint_t mygetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"mygetwc\");\n    wint_t res = fptrgetwc(__stream);\n\n    return res;\n}\n\nvoid myexit(int __status) \n{\n    printFunctionCalled(\"myexit\");\n    fptrexit(__status);\n\n}\n\nint mysetitimer(__itimer_which_t  __which, __const\n        struct itimerval *__restrict __new,\n        struct itimerval *__restrict __old) \n{\n    printFunctionCalled(\"mysetitimer\");\n    int res = fptrsetitimer(__which, __new, __old);\n\n    return res;\n}\n\nint mysigpending(sigset_t * __set) \n{\n    printFunctionCalled(\"mysigpending\");\n    int res = fptrsigpending(__set);\n\n    return res;\n}\n\n__sighandler_t mysignal(int __sig, __sighandler_t  __handler) \n\n{\n    printFunctionCalled(\"mysignal\");\n    __sighandler_t res = fptrsignal(__sig, __handler);\n\n    return res;\n}\n\nvoid myabort() \n{\n    printFunctionCalled(\"myabort\");\n    fptrabort();\n}\n\nint myclose(int __fd) \n{\n    printFunctionCalled(\"myclose\");\n    int res = fptrclose(__fd);\n\n    return res;\n}\n\nssize_t mysendto(int __fd, __const VOID_PTR  __buf, size_t __n, int __flags,\n        __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len) \n{\n    printFunctionCalled(\"mysendto\");\n    ssize_t res = fptrsendto(__fd, __buf, __n, __flags, __addr, __addr_len);\n\n    return res;\n}\n\nint my_IO_getc(FILE * __stream) \n{\n    printFunctionCalled(\"my_IO_getc\");\n    int res = fptr_IO_getc(__stream);\n\n    return res;\n}\n\nint mygetchar()\n{\n    printFunctionCalled(\"mygetchar\");\n    int res = fptrgetchar();\n\n    return res;\n}\n\nwint_t mygetwchar() \n{\n    printFunctionCalled(\"mygetwchar\");\n    wint_t res = fptrgetwchar();\n\n    return res;\n}\n\nCHAR_PTR  mygets(CHAR_PTR  __s) \n{\n    printFunctionCalled(\"mygets\");\n    CHAR_PTR  res = fptrgets(__s);\n\n    return res;\n}\n\nCHAR_PTR  myfgets(CHAR_PTR __restrict __s, int __n, FILE *__restrict __stream) \n{\n    printFunctionCalled(\"myfgets\");\n    CHAR_PTR  res = fptrfgets(__s, __n, __stream);\n\n    return res;\n}\n\nwint_t myfgetwc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetwc\");\n    wint_t res = fptrfgetwc(__stream);\n\n    return res;\n}\n\nsize_t myfread(VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __stream)\n{\n    printFunctionCalled(\"myfread\");\n    size_t res = fptrfread(__ptr, __size, __n, __stream);\n\n    return res;\n}\n\nsize_t myfwrite(__const VOID_PTR __restrict __ptr, size_t __size, size_t __n,\n        FILE *__restrict __s) \n{\n    printFunctionCalled(\"myfwrite\");\n    size_t res = fptrfwrite(__ptr, __size, __n, __s);\n\n    return res;\n}\n\nint myopen(__const CHAR_PTR  __file, int __flags, mode_t __mode) \n{\n    printFunctionCalled(\"myopen\");\n    int res = fptropen(__file, __flags, __mode);\n\n    return res;\n}\n\nint mygetw(FILE * __stream) \n{\n    printFunctionCalled(\"mygetw\");\n    int res = fptrgetw(__stream);\n\n    return res;\n}\n\nvoid myfgetc(__FILE * __stream) \n{\n    printFunctionCalled(\"myfgetc\");\n    fptrfgetc(__stream);\n\n}\n\nwchar_t * myfgetws(wchar_t *__restrict __ws, int __n,\n        __FILE *__restrict __stream) \n        {\n    printFunctionCalled(\"myfgetws\");\n    wchar_t * res = fptrfgetws(__ws, __n, __stream);\n\n    return res;\n}\n\nint mypipe(int* __pipedes) \n{\n    printFunctionCalled(\"mypipe\");\n    int res = fptrpipe(__pipedes);\n\n    return res;\n}\n\nssize_t myread(int __fd, VOID_PTR  __buf, size_t __nbytes) \n{\n    printFunctionCalled(\"myread\");\n    ssize_t res = fptrread(__fd, __buf, __nbytes);\n\n    return res;\n}\n\nssize_t mywrite(int __fd, __const VOID_PTR  __buf, size_t __n) \n{\n    printFunctionCalled(\"mywrite\");\n    ssize_t res = fptrwrite(__fd, __buf, __n);\n\n    return res;\n}\n\nFILE * myfopen(__const CHAR_PTR __restrict __filename,\n        __const CHAR_PTR __restrict __modes) \n{\n    printFunctionCalled(\"myfopen\");\n    FILE * res = fptrfopen(__filename, __modes);\n\n    return res;\n}\n\nFILE * myfdopen(int __fd, __const CHAR_PTR  __modes) \n{\n    printFunctionCalled(\"myfdopen\");\n    FILE * res = fptrfdopen(__fd, __modes);\n\n    return res;\n}\n\nint mycallrpc(__const CHAR_PTR  __host, u_long __prognum, u_long __versnum,\n        u_long __procnum, xdrproc_t __inproc, __const CHAR_PTR  __in,\n        xdrproc_t __outproc, CHAR_PTR  __out) \n{\n    printFunctionCalled(\"mycallrpc\");\n    int res = fptrcallrpc(__host, __prognum, __versnum, __procnum, __inproc,\n            __in, __outproc, __out);\n\n    return res;\n}\n\nenum clnt_stat myclnt_broadcast(u_long __prog, u_long __vers, u_long __proc,\n        xdrproc_t __xargs, caddr_t __argsp, xdrproc_t __xresults,\n        caddr_t __resultsp, resultproc_t __eachresult) \n{\n    printFunctionCalled(\"myclnt_broadcast\");\n    enum clnt_stat res = fptrclnt_broadcast(__prog, __vers, __proc, __xargs,\n            __argsp, __xresults, __resultsp, __eachresult);\n\n    return res;\n}\n\nCLIENT * myclntudp_create(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp) \n{\n    printFunctionCalled(\"myclntudp_create\");\n    CLIENT * res = fptrclntudp_create(__raddr, __program, __version,\n            __wait_resend, __sockp);\n\n    return res;\n}\n\nCLIENT * myclntudp_bufcreate(struct sockaddr_in * __raddr, u_long __program,\n        u_long __version, struct timeval __wait_resend, INT_PTR  __sockp,\n        u_int __sendsz, u_int __recvsz) \n{\n    printFunctionCalled(\"myclntudp_bufcreate\");\n    CLIENT * res = fptrclntudp_bufcreate(__raddr, __program, __version,\n            __wait_resend, __sockp, __sendsz, __recvsz);\n\n    return res;\n}\n\nstruct pmaplist * mypmap_getmaps(struct sockaddr_in * __address) \n{\n    printFunctionCalled(\"mypmap_getmaps\");\n    struct pmaplist * res = fptrpmap_getmaps(__address);\n\n    return res;\n}\n\nu_short mypmap_getport(struct sockaddr_in * __address, u_long __program,\n        u_long __version, u_int __protocol) \n{\n    printFunctionCalled(\"mypmap_getport\");\n    u_short res = fptrpmap_getport(__address, __program, __version, __protocol);\n\n    return res;\n}\n\nenum clnt_stat mypmap_rmtcall(struct sockaddr_in * __addr, u_long __prog,\n        u_long __vers, u_long __proc, xdrproc_t __xdrargs, caddr_t __argsp,\n        xdrproc_t __xdrres, caddr_t __resp, struct timeval __tout,\n        u_long * __port_ptr) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    enum clnt_stat res = fptrpmap_rmtcall(__addr, __prog, __vers, __proc,\n            __xdrargs, __argsp, __xdrres, __resp, __tout, __port_ptr);\n\n    return res;\n}\n\nbool_t mypmap_set(u_long __program, u_long __vers, int __protocol, u_short __port) \n{\n    printFunctionCalled(\"mypmap_set\");\n    bool_t res = fptrpmap_set(__program, __vers, __protocol, __port);\n\n    return res;\n}\n\nCLIENT * myclntraw_create(u_long __prog, u_long __vers) \n{\n    printFunctionCalled(\"myclntraw_create\");\n    CLIENT * res = fptrclntraw_create(__prog, __vers);\n\n    return res;\n}\n\nvoid mysvc_run()\n{\n    printFunctionCalled(\"mysvc_run\");\n    fptrsvc_run();\n}\n\nbool_t mysvc_sendreply(SVCXPRT * xprt, xdrproc_t __xdr_results,\n        caddr_t __xdr_location) \n{\n    printFunctionCalled(\"mysvc_sendreply\");\n    bool_t res = fptrsvc_sendreply(xprt, __xdr_results, __xdr_location);\n\n    return res;\n}\n\nSVCXPRT * mysvcraw_create() \n{\n    printFunctionCalled(\"mysvcraw_create\");\n    SVCXPRT * res = fptrsvcraw_create();\n\n    return res;\n}\n\nSVCXPRT * mysvctcp_create(int __sock, u_int __sendsize, u_int __recvsize) \n{\n    printFunctionCalled(\"mypmap_rmtcall\");\n    SVCXPRT * res = fptrsvctcp_create(__sock, __sendsize, __recvsize);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_bufcreate(int __sock, u_int __sendsz, u_int __recvsz)\n{\n    printFunctionCalled(\"mysvcudp_bufcreate\");\n    SVCXPRT * res = fptrsvcudp_bufcreate(__sock, __sendsz, __recvsz);\n\n    return res;\n}\n\nSVCXPRT * mysvcudp_create(int __sock)\n{\n    printFunctionCalled(\"mysvcudp_create\");\n    SVCXPRT * res = fptrsvcudp_create(__sock);\n\n    return res;\n}\n\nvoid my_exit(int __status)\n{\n    printFunctionCalled(\"my_exit\");\n    fptr_exit(__status);\n\n}\n\nint my_nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) \n{\n    printFunctionCalled(\"my_nanosleep\");\n    int res = fptrnanosleep(__rqtp, __rmtp);\n\n    return res;\n}\n\nint mysigprocmask(int __how, __const sigset_t *__restrict __set,\n        sigset_t *__restrict __oset) \n{\n    printFunctionCalled(\"mysigprocmask\");\n    int res = fptrsigprocmask(__how, __set, __oset);\n\n    return res;\n}\n\nint mypselect(int __nfds, fd_set *__restrict __readfds,\n        fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,\n        const struct timespec *__restrict __timeout,\n        const __sigset_t *__restrict __sigmask) \n{\n    printFunctionCalled(\"mypselect\");\n    int res = fptrpselect(__nfds, __readfds, __writefds, __exceptfds, __timeout,\n            __sigmask);\n\n    return res;\n}\n\npid_t mywait(INT_PTR __status) \n{\n    printFunctionCalled(\"mywait\");\n    int res = fptrwait(__status);\n\n    return res;\n}\n\nint myfclose(FILE * __stream) \n{\n    printFunctionCalled(\"myfclose\");\n    int res = fptrfclose(__stream);\n\n    return res;\n}\n\nint myioctl(int __d, int __request, CHAR_PTR  __argp) \n{\n    printFunctionCalled(\"myioctl\");\n    int res = fptrioctl(__d, __request, __argp);\n\n    return res;\n}\n\nint myfcntl(int __fd, int __cmd, VOID_PTR  __argp) \n{\n    printFunctionCalled(\"myfcntl\");\n    int res = fptrfcntl(__fd, __cmd, __argp);\n\n    return res;\n}\n\nVOID_PTR  my__libc_dlopen_mode(const CHAR_PTR __name, int __mode) \n{\n    printFunctionCalled(\"my__libc_dlopen_mode\");\n    VOID_PTR  res = fptr__libc_dlopen_mode(__name, __mode);\n\n    return res;\n}\n\nINT_PTR  my__errno_location(void) \n{\n    printFunctionCalled(\"my__errno_location\");\n    INT_PTR  res = fptr__errno_location();\n\n    return res;\n}\n\nint mysyscall(int __number, long int __arg1, long int __arg2, long int __arg3,\n        long int __arg4, long int __arg5, long int __arg6, long int __arg7) \n{\n    printFunctionCalled(\"mysyscall\");\n    int res = fptrsyscall(__number, __arg1, __arg2, __arg3, __arg4, __arg5,\n            __arg6, __arg7);\n\n    return res;\n}\n\nint mysigaction(int __sig, __const struct sigaction *__restrict __act,\n        struct sigaction *__restrict __oact) \n{\n    printFunctionCalled(\"mysigaction\");\n    int res = fptrsigaction(__sig, __act, __oact);\n\n    return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\nusing std::string;\nusing std::ios;\nusing std::hex;\nusing std::cerr;\nusing std::ofstream;\nusing std::endl;\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/unloadtest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/JitProfilingApiTests/jitter_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <assert.h>\n#include <limits.h>\n#include <memory.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <errno.h>\n\n#include \"jitprofiling.h\"\n\n#include <iostream>\nusing namespace std;\n\nextern \"C\" int foo(int n, int method_id); // This function body is in an assembly file\n\ntypedef int (*FOO_FUNC)(int, int);\ntypedef int (*PinNotifyEventFunc)(iJIT_JVM_EVENT event_type, void* EventSpecificData);\n\nunsigned int iJIT_GetNewMethodID(void)\n{\n    static unsigned int id = 0;\n    return ++id;\n}\n\nsize_t get_page_size()\n{\n    return sysconf(_SC_PAGE_SIZE);\n}\n\nsize_t get_size_in_full_pages(const size_t code_size)\n{\n    const size_t page_size = get_page_size();\n    if ((code_size % page_size) == 0) \n    {\n        return code_size; // already aligned\n    }\n    else\n    {\n        return page_size* ((code_size/page_size) + 1);\n    }\n}\n\nvoid create_function_duplicate_and_notify(PinNotifyEventFunc f_notify_event, void* src_func_addr, size_t src_func_size, void* dst_func_address, const char* dst_func_name, unsigned int& method_id)\n{\n    memcpy(dst_func_address, src_func_addr, src_func_size);\n    \n    // Notify method load\n    iJIT_Method_Load jit_func_load_event   = { 0 };\n    method_id = iJIT_GetNewMethodID();\n    jit_func_load_event.method_id           = method_id;\n    jit_func_load_event.method_name         = strdup(dst_func_name);\n    jit_func_load_event.method_load_address = dst_func_address  ;\n    jit_func_load_event.method_size         = src_func_size   + 1;\n    jit_func_load_event.line_number_size    = 0;\n     (*f_notify_event)(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED, (void*)&jit_func_load_event  );\n    free(jit_func_load_event.method_name);\n}\n\nint main(int argc, char *argv[])\n{\n    //\n    // parse argv\n    //\n    if (argc != 2)\n    {\n        printf(\"Error: Expecting 1 argument - foo size \\n\");\n        return 1;\n    }\n\n    // The only argument is the size of foo()\n    const long int foo_size = strtol(argv[1], NULL, 10);\n    if ((foo_size == 0) || (foo_size == LONG_MAX) || (foo_size == (LONG_MIN)))\n    {\n        printf(\"Error: Failed to convert parameter \\\"%s\\\" to a number \\n\", argv[1]);\n        return 1;\n    }\n\n    //\n    // Load libpinjitprofiling.so and find NotifyEvent function address\n    //\n    void* handle = NULL;\n    PinNotifyEventFunc iJIT_NotifyEvent;\n\n    handle = dlopen(\"libpinjitprofiling.so\", RTLD_LAZY);\n    if (handle) {\n        dlerror();\n         *(void **)(&iJIT_NotifyEvent) = dlsym(handle, \"NotifyEvent\");\n        if (iJIT_NotifyEvent == NULL)\n        {\n            printf(\"Error: dlsym failed with error %s\\n\", dlerror());\n            return 1;\n        }\n     }\n    else\n    {\n        printf(\"Error: dlopen failed with error %s\\n\", dlerror());\n        return 1;\n    }\n\n    //\n    // Create duplicates of foo()\n    //\n    const size_t foo_size_in_pages = get_size_in_full_pages((size_t)foo_size);\n    const size_t allocated_size = (foo_size_in_pages * 3) + get_page_size();\n    void* allocated_addr = mmap( NULL,                               /*addr*/\n                                 allocated_size,                    /*length*/\n                                 PROT_READ | PROT_WRITE | PROT_EXEC, /*prot*/\n                                 MAP_PRIVATE | MAP_ANONYMOUS,        /*flags*/\n                                 -1                                  /*fd*/, \n                                 0                                   /*offset*/\n                                 );\n\n    if (allocated_addr == MAP_FAILED)\n    {\n        printf(\"Error: mmap failed with errno %d\\n\", errno);\n        return 1;\n    }\n\n    // Create 3 duplicated:\n    // 1 - at the base address of the allocated buffer\n    // 2 - at the base address of the adjacent page to duplicate 1\n    // 3 - leave a blank page between duplicate 2 and duplicate 3\n    unsigned int method_id_1, method_id_2, method_id_3;\n    void* addr_1 = allocated_addr;\n    void* addr_2 = (void*)((uint8_t*)allocated_addr + foo_size_in_pages);\n    void* addr_3 = (void*)((uint8_t*)allocated_addr + (2*foo_size_in_pages) + get_page_size());\n    create_function_duplicate_and_notify(iJIT_NotifyEvent, (void*)foo, (size_t)foo_size, addr_1, \"jit_foo_1\", method_id_1);\n    create_function_duplicate_and_notify(iJIT_NotifyEvent, (void*)foo, (size_t)foo_size, addr_2, \"jit_foo_2\", method_id_2);\n    create_function_duplicate_and_notify(iJIT_NotifyEvent, (void*)foo, (size_t)foo_size, addr_3, \"jit_foo_3\", method_id_3);\n    const FOO_FUNC jit_foo_1 = (FOO_FUNC)addr_1;\n    const FOO_FUNC jit_foo_2 = (FOO_FUNC)addr_2;\n    const FOO_FUNC jit_foo_3 = (FOO_FUNC)addr_3;\n\n    // Execute jit functions\n    const int i = 8;\n    assert((jit_foo_1)(i, (int)method_id_1) == (i*i)); // just to make sure the functionality is ok\n    assert((jit_foo_2)(i, (int)method_id_2) == (i*i));\n    assert((jit_foo_3)(i, (int)method_id_3) == (i*i));\n\n    // Notify shutdown\n    (*iJIT_NotifyEvent)(iJVM_EVENT_TYPE_SHUTDOWN, NULL);\n\n    // Shutdown:\n    // Unmap memory\n    // Unoad libpinjitprofiling.so\n\n    if (munmap(allocated_addr, allocated_size) == -1)\n    {\n        printf(\"Error: munmap failed with errno %d\\n\", errno);\n        return 1;\n    }\n\n    if (handle)\n    {\n        if (dlclose(handle) != 0)\n        {\n            printf(\"Error: dlclose failed with error %s\\n\", dlerror());\n            return 1;\n        }\n     }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/l_imageLoad_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <string.h>\n\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM int AfterAttach();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\nvoid UnixOpen(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", filename, dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n    dlclose(dlh);\n}\n\nint AfterAttach()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return 0;\n}\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [5] \"-probe\"\n    [6] \"-t\"\n    [7] tool\n    [8] \"-o\"\n    [9] tool's output file\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 8)\n    {\n        fprintf(stderr, \"l_imageLoad_app received too few arguments.\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if(argc > MAX_COMMAND_LINE_SIZE - 2)    // added: -pid attachPid NULL, omitted: argv[0..2]\n    {\n        fprintf(stderr, \"l_imageLoad_app received too many arguments\\n\" );\n        exit(RES_RES_INVALID_ARGS);\n    }\n\n    UnixOpen(argv[1]);\n\n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach())\n        {\n            sleep(1);\n        }\n\n        UnixOpen(argv[2]);\n    }\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        sprintf(attachPid, \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};    // arguments for execv command\n        int args_count = 0;\n        int argv_count = 3;                            // to start from argv[3]...\n        args[args_count++] = argv[argv_count++];       // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];   // including \"-probe\" (mandatory for test)\n        }\n        args[args_count++] = argv[argv_count++];       // \"-t\"\n        args[args_count++] = argv[argv_count++];       // tool\n        args[args_count++] = argv[argv_count++];       // \"-o\"\n        args[args_count++] = argv[argv_count++];       // tool's output file\n        args[args_count++] = NULL;                     // end\n        execv(argv[3], (char * const *)args);          // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/imageUnload_app.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\nvoid Open(char* filename)\n{\n    void* dlh = dlopen(filename, RTLD_LAZY);\n    if( !dlh )\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\", filename, dlerror());\n        exit(2);\n    }\n    dlclose(dlh);\n}\n\nint main(int argc, char** argv)\n{\n    if(argc<1)\n    {\n        fprintf(stderr, \"No image name to load has been supplied\" );\n        fflush(stderr);\n        return 1;\n    }\n\n    Open(argv[1]);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/full_path_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <dlfcn.h>\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n    RES_RES_INVALID_ARGS  // 2\n};\n\n/*\n    Expected argv arguments:\n    [1] image to load\n*/\nint main(int argc, char** argv)\n{\n    if(argc!=2)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        return RES_RES_INVALID_ARGS;\n    }\n\n    void* handle;\n\n    handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        return RES_LOAD_FAILED;\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/split_image_linux_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <vector>\n#include <dlfcn.h>\n#include <limits.h>\n#include <link.h>\nusing std::pair;\nusing std::vector;\n\n// The executable filename of this program\nchar progname[4096];\n\n\n/*\n * Iterate over all images known to the loader and print their memory regions\n */\nint dl_iterate(struct dl_phdr_info *info, size_t size, void *data)\n{\n    const char* realname = info->dlpi_name;\n    vector<pair<void*, void*> > vecSegments;\n    if (strstr(realname, \"linux-gate.so\") == realname || strstr(realname, \"linux-vdso.so\") == realname)\n    {\n        // Don't count VDSO, PIN doesn't repont it intentionally\n        return 0;\n    }\n    for (int j = 0; j < info->dlpi_phnum; j++)\n    {\n        if (info->dlpi_phdr[j].p_type == PT_LOAD)\n        {\n            void* start = (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);\n            void* end = (void*)((char*)start + info->dlpi_phdr[j].p_memsz - 1);\n            vecSegments.push_back(pair<void*, void*>(start, end));\n            if (*realname == 0 && (void*)dl_iterate >= start && (void*)dl_iterate < end)\n            {\n                realname = progname;\n            }\n        }\n    }\n    if (*realname != 0)\n    {\n        for (vector<pair<void*, void*> >::iterator it = vecSegments.begin(); it != vecSegments.end(); it++)\n        {\n            printf(\"%s, %p-%p\\n\", realname, it->first, it->second);\n        }\n    }\n    return 0;\n}\n\nint main(int argc, const char* argv[], char** envp)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <path to lib>\\n\", argv[0]);\n        return 1;\n    }\n    realpath(argv[0], progname);\n    void* hDll = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n    if (NULL == hDll)\n    {\n        printf(\"Failed to open %s - %s\\n\", argv[1], dlerror());\n        return 1;\n    }\n    int (*return2)() = (int (*)())dlsym(hDll, \"return2\");\n    if (NULL == return2)\n    {\n        printf(\"Failed to locate 'return2' - %s\\n\", dlerror());\n        return 1;\n    }\n\n    if (return2() != 2)\n    {\n        printf(\"Bad value returned from 'return2'\\n\");\n        return 1;\n    }\n    dl_iterate_phdr(dl_iterate, NULL);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/launchReattachImageLoadCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach2();\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_LOAD_FAILED,      // 1\n};\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nint main (int argc, char *argv[])\n{\n    void *handle = dlopen(argv[1], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(!AfterAttach2())\n    {\n        sleep(1);\n    }\n\n    handle = dlopen(argv[2], RTLD_LAZY);\n    if (!handle)\n    {\n        fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n        fflush(stderr);\n        exit(RES_LOAD_FAILED);\n    }\n\n    while(1)\n    {\n        // expected to be stopped by tool.\n        sleep(1);\n    }\n\n    return RES_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/attachReattachImageLoadCallbacks_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_COMMAND_LINE_SIZE 15    // the size for the array of arguments to execv (this value is arbitrary)\n#define EXPORT_SYM extern \"C\"\n\nEXPORT_SYM bool AfterAttach1();\n\nEXPORT_SYM bool AfterAttach2();\n\nstatic int MAX_SIZE = 128; /*maximum line size*/\n\nenum ExitType {\n    RES_SUCCESS = 0,      // 0\n    RES_FORK_FAILED,      // 1\n    RES_EXEC_FAILED,      // 2\n    RES_LOAD_FAILED,      // 3\n    RES_RES_INVALID_ARGS  // 4\n};\n\n\nbool AfterAttach1()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\nbool AfterAttach2()\n{\n    // Pin sets an anslysis function here to notify the application when Pin attaches to it.\n    return false;\n}\n\n/*\n * block only the signals in the list: \"signalsListToBlock\"\n */\nvoid BlockSignals(int signalsListToBlock[] , int len, sigset_t * sigmask)\n{\n    sigemptyset(sigmask);\n    int i;\n    for(i=0; i< len; ++i) \n        sigaddset(sigmask, signalsListToBlock[i]);\n    pthread_sigmask(SIG_SETMASK, sigmask, NULL);\n}\n\n\n/*\n    Expected argv arguments:\n    [1] first image to load\n    [2] second image to load\n    [3] pin executable\n    [4] Pin flags (e.g. -slow_asserts)\n        >> zero or more flags possible\n    [5] \"-probe\"\n    [6] \"-t\"\n    [7] tool\n    [8] output file\n    [9] represent if SIGTRAP should be blocked by the application\n    argv[9]=0 - SIGTRAP shouldn't be blocked\n    argv[9]=1 - SIGTRAP should be blocked\n*/\n\nint main(int argc, char** argv)\n{\n    if(argc < 9)\n    {\n        fprintf(stderr, \"No enough arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if (argc > MAX_COMMAND_LINE_SIZE){      // added: -pid attachPid -o NULL, omitted: argv[0..2], argv[9]\n        fprintf(stderr, \"Too many arguments\\n\" );\n        fflush(stderr);\n        exit(RES_RES_INVALID_ARGS);\n    }\n    if (strcmp(argv[argc-1], \"1\") == 0) // Need to block the SIGTRAP signal\n    {\n        int sigList[1] = {SIGTRAP};\n        sigset_t sigmask;\n        BlockSignals(sigList, 1, &sigmask);\n    }\n   \n    pid_t parentPid = getpid();\n    pid_t child = fork();\n    if (child < 0)\n    {\n        perror(\"fork failed while creating application process\");\n        exit(RES_FORK_FAILED);\n    }\n\n    if (child)\n    {\n        // inside parent\n        while(!AfterAttach1())\n        {\n            sleep(1);\n        }\n\n        void *handle = dlopen(argv[1], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[1], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(!AfterAttach2())\n        {\n            sleep(1);\n        }\n\n        handle = dlopen(argv[2], RTLD_LAZY);\n        if (!handle)\n        {\n            fprintf(stderr, \" Failed to load: %s because: %s\\n\", argv[2], dlerror());\n            fflush(stderr);\n            exit(RES_LOAD_FAILED);\n        }\n\n        while(1)\n        {\n            // expected to be stopped by tool.\n            sleep(1);\n        }\n    }\n\n    if ( child == 0 )\n    {\n        // inside child\n        char attachPid[MAX_SIZE];\n        snprintf(attachPid ,MAX_SIZE , \"%d\", parentPid);\n        char* args[MAX_COMMAND_LINE_SIZE] = {NULL};    // arguments for execv command\n        int args_count = 0;\n        int argv_count = 3;                            // to start from argv[3]...\n        args[args_count++] = argv[argv_count++];       // by convention, first arg is the filename of the executed file (pin)\n        args[args_count++] = (char*)\"-pid\";\n        args[args_count++] = attachPid;\n        while (strcmp(argv[argv_count], \"-t\") != 0){   // additional Pin flags (optional)\n            args[args_count++] = argv[argv_count++];   // including \"-probe\" (mandatory for test)\n        }\n        args[args_count++] = argv[argv_count++];       // \"-t\"\n        args[args_count++] = argv[argv_count++];       // tool\n        args[args_count++] = (char*)\"-o\";\n        args[args_count++] = argv[argv_count++];       // output file\n        args[args_count++] = NULL;                     // end\n        execv(argv[3], (char * const *)args);          // never returns\n        perror(\"execv failed while trying to attach Pin to the application\\n\");\n        exit(RES_EXEC_FAILED);\n    }\n    return RES_SUCCESS;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/ImageTests/images_on_attach_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n *  This application should be used with the images_on_attach_tool tool.\n *  See documentation in the tool for the test details.\n */\n\n#include <iostream>\n#include <cstdlib>\n#include <dlfcn.h>\n#include <unistd.h>\n\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\n\nextern \"C\"\n{\nvoid DoRelease(volatile bool* doRelease)\n{\n    // Do nothing\n}\n} // extern \"C\"\n\n\nstatic void WaitForAttach()\n{\n    const unsigned int timeout = 300;\n    unsigned int releaseCounter = 0;\n    volatile bool released = false;\n    while (!released)\n    {\n        if (timeout == releaseCounter)\n        {\n            cerr << \"APP ERROR: Timeout reached and the tool did not release the application.\" << endl;\n            exit(1);\n        }\n        ++releaseCounter;\n        DoRelease(&released);\n        sleep(1);\n    }\n}\n\n\nstatic void LoadAdditionalLibraries(const char* usrlib)\n{\n    const void *libutil = dlopen(\"libutil.so.1\", RTLD_LAZY);\n    if(NULL == libutil)\n    {\n        cerr << \"APP ERROR: Failed to load libutil.so.1\" << endl;\n        exit(1);\n    }\n    const void *usrlibptr = dlopen(usrlib, RTLD_LAZY);\n    if(NULL == usrlibptr)\n    {\n        cerr << \"APP ERROR: Failed to load \" << usrlib << endl;\n        exit(1);\n    }\n}\n\n\n/*\n * Expected arguments:\n *\n * [1] - Shared object to load dynamically\n */\nint main( int argc, char *argv[] )\n{\n    // Check the number of parameters.\n    if (2 != argc)\n    {\n        cerr << \"Usage: \" << argv[0] << \" <shared object to load>\" << endl;\n        return 1;\n    }\n\n    // Wait for the tool to attach to the application.\n    WaitForAttach();\n\n    // Pin is attached, now load two more shared objects.\n    LoadAdditionalLibraries(argv[1]);\n\n    // Done.\n    cout << \"APP: Application completed successfully.\" << endl;\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/include/dlfcn.h": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software and the related documents are Intel copyrighted materials, and your\n * use of them is governed by the express license under which they were provided to\n * you (\"License\"). Unless the License provides otherwise, you may not use, modify,\n * copy, publish, distribute, disclose or transmit this software or the related\n * documents without Intel's prior written permission.\n * \n * This software and the related documents are provided as is, with no express or\n * implied warranties, other than those that are expressly stated in the License.\n * \n * This file incorporates work covered by the following copyright and permission notice:\n */\n\n/*\n * Copyright (C) 2008 The Android Open Source Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef __DLFCN_H__\n#define __DLFCN_H__\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\ntypedef struct {\n    const char *dli_fname;  /* Pathname of shared object that\n                               contains address */\n    void       *dli_fbase;  /* Address at which shared object\n                               is loaded */\n    const char *dli_sname;  /* Name of nearest symbol with address\n                               lower than addr */\n    void       *dli_saddr;  /* Exact address of symbol named\n                               in dli_sname */\n} Dl_info;\n\nextern void*        dlopen(const char*  filename, int flag);\nextern int          dlclose(void*  handle);\nextern const char*  dlerror(void);\nextern void*        dlsym(void*  handle, const char*  symbol);\nextern int          dladdr(const void* addr, Dl_info *info);\n\nenum {\n#if defined(__APPLE__)\n  RTLD_LAZY   = 1,\n  RTLD_NOW    = 2,\n  RTLD_LOCAL  = 4,\n  RTLD_GLOBAL = 8,\n  RTLD_NOLOAD = 0x10,\n  RTLD_NODELETE = 0x80,\n  RTLD_FIRST = 0x100,   /* macOS 10.5 and later */\n#else\n# if defined(__LP64__)\n  RTLD_NOW  = 2,\n# else\n  RTLD_NOW  = 0,\n# endif\n  RTLD_LAZY = 1,\n\n  RTLD_LOCAL  = 0,\n# if defined(__LP64__)\n  RTLD_GLOBAL = 0x00100,\n# else\n  RTLD_GLOBAL = 2,\n# endif\n  RTLD_NOLOAD = 4,\n#endif\n};\n\n#if defined(__APPLE__)\n# define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n# define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n# define RTLD_SELF       ((void *) -3)   /* Search this and subsequent objects (macOS 10.5 and later) */\n# define RTLD_MAIN_ONLY  ((void *) -5)   /* Search main executable only (macOS 10.5 and later) */\n#else\n# if defined (__LP64__)\n#  define RTLD_DEFAULT  ((void*) 0)\n#  define RTLD_NEXT     ((void*) -1L)\n# else\n#  define RTLD_DEFAULT  ((void*) 0xffffffff)\n#  define RTLD_NEXT     ((void*) 0xfffffffe)\n# endif\n#endif\n\n#if defined(__APPLE__) && defined(__NEED_DYLD_PRIVATE)\n#include <mach-o/dyld.h>\n#include <mach-o/dyld_images.h>\n\nstruct dyld_unwind_sections\n{\n\tconst struct mach_header*\t\tmh;\n\tconst void*\t\t\t\t\t\tdwarf_section;\n\tuintptr_t\t\t\t\t\t\tdwarf_section_length;\n\tconst void*\t\t\t\t\t\tcompact_unwind_section;\n\tuintptr_t\t\t\t\t\t\tcompact_unwind_section_length;\n};\n\nextern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);\nextern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\nextern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\n\n#endif\n\n__END_DECLS\n\n#endif /* __DLFCN_H */\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/include/nsswitch.h": "/*\t$NetBSD: nsswitch.h,v 1.21 2011/07/17 20:54:34 joerg Exp $\t*/\n\n/*-\n * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Luke Mewburn.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef _NSSWITCH_H\n#define _NSSWITCH_H\t1\n\n#include <sys/types.h>\n#include <stdarg.h>\n\n#define\tNSS_MODULE_INTERFACE_VERSION\t0\n\n#ifndef _PATH_NS_CONF\n#define _PATH_NS_CONF\t\"/etc/nsswitch.conf\"\n#endif\n\n#define\tNS_CONTINUE\t0\n#define\tNS_RETURN\t1\n\n/*\n * Layout of:\n *\tuint32_t ns_src.flags\n */\n\t/* nsswitch.conf status codes and nsdispatch(3) return values */\n#define\tNS_SUCCESS\t(1<<0)\t\t/* entry was found */\n#define\tNS_UNAVAIL\t(1<<1)\t\t/* source not responding, or corrupt */\n#define\tNS_NOTFOUND\t(1<<2)\t\t/* source responded 'no such entry' */\n#define\tNS_TRYAGAIN\t(1<<3)\t\t/* source busy, may respond to retrys */\n#define\tNS_STATUSMASK\t0x000000ff\t/* bitmask to get the status flags */\n\n\t/* internal nsdispatch(3) flags; not settable in nsswitch.conf(5)  */\n#define\tNS_FORCEALL\t(1<<8)\t\t/* force all methods to be invoked; */\n\n/*\n * Currently implemented sources.\n */\n#define NSSRC_FILES\t\"files\"\t\t/* local files */\n#define\tNSSRC_DNS\t\"dns\"\t\t/* DNS; IN for hosts, HS for others */\n#define\tNSSRC_NIS\t\"nis\"\t\t/* YP/NIS */\n#define\tNSSRC_COMPAT\t\"compat\"\t/* passwd,group in YP compat mode */\n\n/*\n * Currently implemented databases.\n */\n#define NSDB_HOSTS\t\t\"hosts\"\n#define NSDB_GROUP\t\t\"group\"\n#define NSDB_GROUP_COMPAT\t\"group_compat\"\n#define NSDB_NETGROUP\t\t\"netgroup\"\n#define NSDB_NETWORKS\t\t\"networks\"\n#define NSDB_PASSWD\t\t\"passwd\"\n#define NSDB_PASSWD_COMPAT\t\"passwd_compat\"\n#define NSDB_SHELLS\t\t\"shells\"\n\n/*\n * Suggested databases to implement.\n */\n#define NSDB_ALIASES\t\t\"aliases\"\n#define NSDB_AUTH\t\t\"auth\"\n#define NSDB_AUTOMOUNT\t\t\"automount\"\n#define NSDB_BOOTPARAMS\t\t\"bootparams\"\n#define NSDB_ETHERS\t\t\"ethers\"\n#define NSDB_EXPORTS\t\t\"exports\"\n#define NSDB_NETMASKS\t\t\"netmasks\"\n#define NSDB_PHONES\t\t\"phones\"\n#define NSDB_PRINTCAP\t\t\"printcap\"\n#define NSDB_PROTOCOLS\t\t\"protocols\"\n#define NSDB_REMOTE\t\t\"remote\"\n#define NSDB_RPC\t\t\"rpc\"\n#define NSDB_SENDMAILVARS\t\"sendmailvars\"\n#define NSDB_SERVICES\t\t\"services\"\n#define NSDB_TERMCAP\t\t\"termcap\"\n#define NSDB_TTYS\t\t\"ttys\"\n\n/*\n * ns_dtab `callback' function signature.\n */\ntypedef\tint (*nss_method)(void *, void *, va_list);\n\n/*\n * ns_dtab - `nsswitch dispatch table'\n * Contains an entry for each source and the appropriate function to call.\n */\ntypedef struct {\n\tconst char\t *src;\n\tnss_method\t callback;\n\tvoid\t\t *cb_data;\n} ns_dtab;\n\n/*\n * Macros to help build an ns_dtab[]\n */\n#define NS_FILES_CB(F,C)\t{ NSSRC_FILES,\tF,\t__UNCONST(C) },\n#define NS_COMPAT_CB(F,C)\t{ NSSRC_COMPAT,\tF,\t__UNCONST(C) },\n\n#ifdef HESIOD\n#   define NS_DNS_CB(F,C)\t{ NSSRC_DNS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_DNS_CB(F,C)\n#endif\n\n#ifdef YP\n#   define NS_NIS_CB(F,C)\t{ NSSRC_NIS,\tF,\t__UNCONST(C) },\n#else\n#   define NS_NIS_CB(F,C)\n#endif\n#define\tNS_NULL_CB\t\t{ .src = NULL },\n\n/*\n * ns_src - `nsswitch source'\n * Used by the nsparser routines to store a mapping between a source\n * and its dispatch control flags for a given database.\n */\ntypedef struct {\n\tconst char\t*name;\n\tuint32_t\t flags;\n} ns_src;\n\n\n/*\n * Default sourcelists (if nsswitch.conf is missing, corrupt,\n * or the requested database doesn't have an entry)\n */\nextern const ns_src __nsdefaultsrc[];\nextern const ns_src __nsdefaultcompat[];\nextern const ns_src __nsdefaultcompat_forceall[];\nextern const ns_src __nsdefaultfiles[];\nextern const ns_src __nsdefaultfiles_forceall[];\nextern const ns_src __nsdefaultnis[];\nextern const ns_src __nsdefaultnis_forceall[];\n\n\n/*\n * ns_mtab - `nsswitch method table'\n * An nsswitch module provides a mapping from (database name, method name)\n * tuples to the nss_method and associated callback data.  Effectively,\n * ns_dtab, but used for dynamically loaded modules.\n */\ntypedef struct {\n\tconst char\t*database;\n\tconst char\t*name;\n\tnss_method\t method;\n\tvoid\t\t*mdata;\n} ns_mtab;\n\n/*\n * nss_module_register_fn - module registration function\n *\tcalled at module load\n * nss_module_unregister_fn - module un-registration function\n *\tcalled at module unload\n */\ntypedef\tvoid (*nss_module_unregister_fn)(ns_mtab *, u_int);\ntypedef\tns_mtab *(*nss_module_register_fn)(const char *, u_int *,\n\t\t\t\t\t   nss_module_unregister_fn *);\n\n#ifdef _NS_PRIVATE\n\n/*\n * Private data structures for back-end nsswitch implementation.\n */\n\n/*\n * ns_dbt - `nsswitch database thang'\n * For each database in /etc/nsswitch.conf there is a ns_dbt, with its\n * name and a list of ns_src's containing the source information.\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* name of database */\n\tns_src\t\t*srclist;\t/* list of sources */\n\tu_int\t\t srclistsize;\t/* size of srclist */\n} ns_dbt;\n\n/*\n * ns_mod - `nsswitch module'\n */\ntypedef struct {\n\tconst char\t*name;\t\t/* module name */\n\tvoid\t\t*handle;\t/* handle from dlopen() */\n\tns_mtab\t\t*mtab;\t\t/* method table */\n\tu_int\t\t mtabsize;\t/* size of mtab */\n\t\t\t\t\t/* called to unload module */\n\tnss_module_unregister_fn unregister;\n} ns_mod;\n\n#endif /* _NS_PRIVATE */\n\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\nint\tnsdispatch(void *, const ns_dtab [], const char *,\n\t\t\tconst char *, const ns_src [], ...) __LIBC_ABI_PUBLIC__;\n\n#ifdef _NS_PRIVATE\nint\t\t _nsdbtaddsrc(ns_dbt *, const ns_src *);\nvoid\t\t _nsdbtdump(const ns_dbt *);\nint\t\t _nsdbtput(const ns_dbt *);\nvoid\t\t _nsyyerror(const char *);\nint\t\t _nsyylex(void);\n#endif /* _NS_PRIVATE */\n\n__END_DECLS\n\n#endif /* !_NSSWITCH_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/include/android/dlext.h": "/*\n * Copyright (C) 2014 The Android Open Source Project\n\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __ANDROID_DLEXT_H__\n#define __ANDROID_DLEXT_H__\n\n#include <stddef.h>\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\n/* bitfield definitions for android_dlextinfo.flags */\nenum {\n  /* When set, the reserved_addr and reserved_size fields must point to an\n   * already-reserved region of address space which will be used to load the\n   * library if it fits. If the reserved region is not large enough, the load\n   * will fail.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS      = 0x1,\n\n  /* As DLEXT_RESERVED_ADDRESS, but if the reserved region is not large enough,\n   * the linker will choose an available address instead.\n   */\n  ANDROID_DLEXT_RESERVED_ADDRESS_HINT = 0x2,\n\n  /* When set, write the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, to allow it to be reused by another\n   * process loading the same library at the same address. This implies\n   * ANDROID_DLEXT_USE_RELRO.\n   */\n  ANDROID_DLEXT_WRITE_RELRO           = 0x4,\n\n  /* When set, compare the GNU RELRO section of the mapped library to relro_fd\n   * after relocation has been performed, and replace any relocated pages that\n   * are identical with a version mapped from the file.\n   */\n  ANDROID_DLEXT_USE_RELRO             = 0x8,\n\n  /* Instruct dlopen to use library_fd instead of opening file by name.\n   * The filename parameter is still used to identify the library.\n   */\n  ANDROID_DLEXT_USE_LIBRARY_FD        = 0x10,\n\n  /* Mask of valid bits */\n  ANDROID_DLEXT_VALID_FLAG_BITS       = ANDROID_DLEXT_RESERVED_ADDRESS |\n                                        ANDROID_DLEXT_RESERVED_ADDRESS_HINT |\n                                        ANDROID_DLEXT_WRITE_RELRO |\n                                        ANDROID_DLEXT_USE_RELRO |\n                                        ANDROID_DLEXT_USE_LIBRARY_FD,\n};\n\ntypedef struct {\n  uint64_t flags;\n  void*   reserved_addr;\n  size_t  reserved_size;\n  int     relro_fd;\n  int     library_fd;\n} android_dlextinfo;\n\nextern void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo);\n\n__END_DECLS\n\n#endif /* __ANDROID_DLEXT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/include/freebsd/sys/sys/elf_common.h": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software and the related documents are Intel copyrighted materials, and your\n * use of them is governed by the express license under which they were provided to\n * you (\"License\"). Unless the License provides otherwise, you may not use, modify,\n * copy, publish, distribute, disclose or transmit this software or the related\n * documents without Intel's prior written permission.\n * \n * This software and the related documents are provided as is, with no express or\n * implied warranties, other than those that are expressly stated in the License.\n * \n * This file incorporates work covered by the following copyright and permission notice:\n */\n\n/*-\n * Copyright (c) 2017 Dell EMC\n * Copyright (c) 2000, 2001, 2008, 2011, David E. O'Brien\n * Copyright (c) 1998 John D. Polstra.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD$\n */\n\n#ifndef _SYS_ELF_COMMON_H_\n#define _SYS_ELF_COMMON_H_ 1\n\n/*\n * ELF definitions that are independent of architecture or word size.\n */\n\n/*\n * Note header.  The \".note\" section contains an array of notes.  Each\n * begins with this header, aligned to a word boundary.  Immediately\n * following the note header is n_namesz bytes of name, padded to the\n * next word boundary.  Then comes n_descsz bytes of descriptor, again\n * padded to a word boundary.  The values of n_namesz and n_descsz do\n * not include the padding.\n */\n\ntypedef struct {\n  u_int32_t n_namesz; /* Length of name. */\n  u_int32_t n_descsz; /* Length of descriptor. */\n  u_int32_t n_type;   /* Type of this note. */\n} Elf_Note;\n\n/*\n * Option kinds.\n */\n#define ODK_NULL  0 /* undefined */\n#define ODK_REGINFO 1 /* register usage info */\n#define ODK_EXCEPTIONS  2 /* exception processing info */\n#define ODK_PAD   3 /* section padding */\n#define ODK_HWPATCH 4 /* hardware patch applied */\n#define ODK_FILL  5 /* fill value used by the linker */\n#define ODK_TAGS  6 /* reserved space for tools */\n#define ODK_HWAND 7 /* hardware AND patch applied */\n#define ODK_HWOR  8 /* hardware OR patch applied */\n#define ODK_GP_GROUP  9 /* GP group for text/data sections */\n#define ODK_IDENT 10  /* ID information */\n#define ODK_PAGESIZE  11  /* page size information */\n\n/*\n * ODK_EXCEPTIONS info field masks.\n */\n#define OEX_FPU_MIN 0x0000001f  /* min FPU exception required */\n#define OEX_FPU_MAX 0x00001f00  /* max FPU exception allowed */\n#define OEX_PAGE0 0x00010000  /* page zero must be mapped */\n#define OEX_SMM   0x00020000  /* run in sequential memory mode */\n#define OEX_PRECISEFP 0x00040000  /* run in precise FP exception mode */\n#define OEX_DISMISS 0x00080000  /* dismiss invalid address traps */\n\n/*\n * ODK_PAD info field masks.\n */\n#define OPAD_PREFIX 0x0001\n#define OPAD_POSTFIX  0x0002\n#define OPAD_SYMBOL 0x0004\n\n/*\n * ODK_HWPATCH info field masks.\n */\n#define OHW_R4KEOP  0x00000001  /* patch for R4000 branch at end-of-page bug */\n#define OHW_R8KPFETCH 0x00000002  /* R8000 prefetch bug may occur */\n#define OHW_R5KEOP  0x00000004  /* patch for R5000 branch at end-of-page bug */\n#define OHW_R5KCVTL 0x00000008  /* R5000 cvt.[ds].l bug: clean == 1 */\n#define OHW_R10KLDL 0x00000010UL  /* need patch for R10000 misaligned load */\n\n/*\n * ODK_HWAND/ODK_HWOR info field and hwp_flags[12] masks.\n */\n#define OHWA0_R4KEOP_CHECKED  0x00000001  /* object checked for R4000 end-of-page bug */\n#define OHWA0_R4KEOP_CLEAN  0x00000002  /* object verified clean for R4000 end-of-page bug */\n#define OHWO0_FIXADE    0x00000001  /* object requires call to fixade */\n\n/*\n * ODK_IDENT/ODK_GP_GROUP info field masks.\n */\n#define OGP_GROUP 0x0000ffff  /* GP group number */\n#define OGP_SELF  0x00010000  /* GP group is self-contained */\n\n/*\n * The header for GNU-style hash sections.\n */\n\ntypedef struct {\n  u_int32_t gh_nbuckets;  /* Number of hash buckets. */\n  u_int32_t gh_symndx;  /* First visible symbol in .dynsym. */\n  u_int32_t gh_maskwords; /* #maskwords used in bloom filter. */\n  u_int32_t gh_shift2;  /* Bloom filter shift count. */\n} Elf_GNU_Hash_Header;\n\n/* Indexes into the e_ident array.  Keep synced with\n   http://www.sco.com/developers/gabi/latest/ch4.eheader.html */\n#define EI_MAG0   0 /* Magic number, byte 0. */\n#define EI_MAG1   1 /* Magic number, byte 1. */\n#define EI_MAG2   2 /* Magic number, byte 2. */\n#define EI_MAG3   3 /* Magic number, byte 3. */\n#define EI_CLASS  4 /* Class of machine. */\n#define EI_DATA   5 /* Data format. */\n#define EI_VERSION  6 /* ELF format version. */\n#define EI_OSABI  7 /* Operating system / ABI identification */\n#define EI_ABIVERSION 8 /* ABI version */\n#define OLD_EI_BRAND  8 /* Start of architecture identification. */\n#define EI_PAD    9 /* Start of padding (per SVR4 ABI). */\n#define EI_NIDENT 16  /* Size of e_ident array. */\n\n/* Values for the magic number bytes. */\n#define ELFMAG0   0x7f\n#define ELFMAG1   'E'\n#define ELFMAG2   'L'\n#define ELFMAG3   'F'\n#define ELFMAG    \"\\177ELF\" /* magic string */\n#define SELFMAG   4   /* magic string size */\n\n/* Values for e_ident[EI_VERSION] and e_version. */\n#define EV_NONE   0\n#define EV_CURRENT  1\n\n/* Values for e_ident[EI_CLASS]. */\n#define ELFCLASSNONE  0 /* Unknown class. */\n#define ELFCLASS32  1 /* 32-bit architecture. */\n#define ELFCLASS64  2 /* 64-bit architecture. */\n\n/* Values for e_ident[EI_DATA]. */\n#define ELFDATANONE 0 /* Unknown data format. */\n#define ELFDATA2LSB 1 /* 2's complement little-endian. */\n#define ELFDATA2MSB 2 /* 2's complement big-endian. */\n\n/* Values for e_ident[EI_OSABI]. */\n#define ELFOSABI_NONE   0 /* UNIX System V ABI */\n#define ELFOSABI_HPUX   1 /* HP-UX operating system */\n#define ELFOSABI_NETBSD   2 /* NetBSD */\n#define ELFOSABI_LINUX    3 /* GNU/Linux */\n#define ELFOSABI_HURD   4 /* GNU/Hurd */\n#define ELFOSABI_86OPEN   5 /* 86Open common IA32 ABI */\n#define ELFOSABI_SOLARIS  6 /* Solaris */\n#define ELFOSABI_AIX    7 /* AIX */\n#define ELFOSABI_IRIX   8 /* IRIX */\n#define ELFOSABI_FREEBSD  9 /* FreeBSD */\n#define ELFOSABI_TRU64    10  /* TRU64 UNIX */\n#define ELFOSABI_MODESTO  11  /* Novell Modesto */\n#define ELFOSABI_OPENBSD  12  /* OpenBSD */\n#define ELFOSABI_OPENVMS  13  /* Open VMS */\n#define ELFOSABI_NSK    14  /* HP Non-Stop Kernel */\n#define ELFOSABI_AROS   15  /* Amiga Research OS */\n#define ELFOSABI_FENIXOS  16  /* FenixOS */\n#define ELFOSABI_CLOUDABI 17  /* Nuxi CloudABI */\n#define ELFOSABI_ARM_AEABI  64  /* ARM EABI */\n#define ELFOSABI_ARM    97  /* ARM */\n#define ELFOSABI_STANDALONE 255 /* Standalone (embedded) application */\n\n#define ELFOSABI_SYSV   ELFOSABI_NONE /* symbol used in old spec */\n#define ELFOSABI_MONTEREY ELFOSABI_AIX  /* Monterey */\n#define ELFOSABI_GNU    ELFOSABI_LINUX\n\n/* e_ident */\n#define IS_ELF(ehdr)  ((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \\\n       (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \\\n       (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \\\n       (ehdr).e_ident[EI_MAG3] == ELFMAG3)\n\n/* Values for e_type. */\n#define ET_NONE   0 /* Unknown type. */\n#define ET_REL    1 /* Relocatable. */\n#define ET_EXEC   2 /* Executable. */\n#define ET_DYN    3 /* Shared object. */\n#define ET_CORE   4 /* Core file. */\n#define ET_LOOS   0xfe00  /* First operating system specific. */\n#define ET_HIOS   0xfeff  /* Last operating system-specific. */\n#define ET_LOPROC 0xff00  /* First processor-specific. */\n#define ET_HIPROC 0xffff  /* Last processor-specific. */\n\n/* Values for e_machine. */\n#define EM_NONE   0 /* Unknown machine. */\n#define EM_M32    1 /* AT&T WE32100. */\n#define EM_SPARC  2 /* Sun SPARC. */\n#define EM_386    3 /* Intel i386. */\n#define EM_68K    4 /* Motorola 68000. */\n#define EM_88K    5 /* Motorola 88000. */\n#define EM_IAMCU  6 /* Intel MCU. */\n#define EM_860    7 /* Intel i860. */\n#define EM_MIPS   8 /* MIPS R3000 Big-Endian only. */\n#define EM_S370   9 /* IBM System/370. */\n#define EM_MIPS_RS3_LE  10  /* MIPS R3000 Little-Endian. */\n#define EM_PARISC 15  /* HP PA-RISC. */\n#define EM_VPP500 17  /* Fujitsu VPP500. */\n#define EM_SPARC32PLUS  18  /* SPARC v8plus. */\n#define EM_960    19  /* Intel 80960. */\n#define EM_PPC    20  /* PowerPC 32-bit. */\n#define EM_PPC64  21  /* PowerPC 64-bit. */\n#define EM_S390   22  /* IBM System/390. */\n#define EM_V800   36  /* NEC V800. */\n#define EM_FR20   37  /* Fujitsu FR20. */\n#define EM_RH32   38  /* TRW RH-32. */\n#define EM_RCE    39  /* Motorola RCE. */\n#define EM_ARM    40  /* ARM. */\n#define EM_SH   42  /* Hitachi SH. */\n#define EM_SPARCV9  43  /* SPARC v9 64-bit. */\n#define EM_TRICORE  44  /* Siemens TriCore embedded processor. */\n#define EM_ARC    45  /* Argonaut RISC Core. */\n#define EM_H8_300 46  /* Hitachi H8/300. */\n#define EM_H8_300H  47  /* Hitachi H8/300H. */\n#define EM_H8S    48  /* Hitachi H8S. */\n#define EM_H8_500 49  /* Hitachi H8/500. */\n#define EM_IA_64  50  /* Intel IA-64 Processor. */\n#define EM_MIPS_X 51  /* Stanford MIPS-X. */\n#define EM_COLDFIRE 52  /* Motorola ColdFire. */\n#define EM_68HC12 53  /* Motorola M68HC12. */\n#define EM_MMA    54  /* Fujitsu MMA. */\n#define EM_PCP    55  /* Siemens PCP. */\n#define EM_NCPU   56  /* Sony nCPU. */\n#define EM_NDR1   57  /* Denso NDR1 microprocessor. */\n#define EM_STARCORE 58  /* Motorola Star*Core processor. */\n#define EM_ME16   59  /* Toyota ME16 processor. */\n#define EM_ST100  60  /* STMicroelectronics ST100 processor. */\n#define EM_TINYJ  61  /* Advanced Logic Corp. TinyJ processor. */\n#define EM_X86_64 62  /* Advanced Micro Devices x86-64 */\n#define EM_AMD64  EM_X86_64 /* Advanced Micro Devices x86-64 (compat) */\n#define EM_PDSP   63  /* Sony DSP Processor. */\n#define EM_FX66   66  /* Siemens FX66 microcontroller. */\n#define EM_ST9PLUS  67  /* STMicroelectronics ST9+ 8/16\n           microcontroller. */\n#define EM_ST7    68  /* STmicroelectronics ST7 8-bit\n           microcontroller. */\n#define EM_68HC16 69  /* Motorola MC68HC16 microcontroller. */\n#define EM_68HC11 70  /* Motorola MC68HC11 microcontroller. */\n#define EM_68HC08 71  /* Motorola MC68HC08 microcontroller. */\n#define EM_68HC05 72  /* Motorola MC68HC05 microcontroller. */\n#define EM_SVX    73  /* Silicon Graphics SVx. */\n#define EM_ST19   74  /* STMicroelectronics ST19 8-bit mc. */\n#define EM_VAX    75  /* Digital VAX. */\n#define EM_CRIS   76  /* Axis Communications 32-bit embedded\n           processor. */\n#define EM_JAVELIN  77  /* Infineon Technologies 32-bit embedded\n           processor. */\n#define EM_FIREPATH 78  /* Element 14 64-bit DSP Processor. */\n#define EM_ZSP    79  /* LSI Logic 16-bit DSP Processor. */\n#define EM_MMIX   80  /* Donald Knuth's educational 64-bit proc. */\n#define EM_HUANY  81  /* Harvard University machine-independent\n           object files. */\n#define EM_PRISM  82  /* SiTera Prism. */\n#define EM_AVR    83  /* Atmel AVR 8-bit microcontroller. */\n#define EM_FR30   84  /* Fujitsu FR30. */\n#define EM_D10V   85  /* Mitsubishi D10V. */\n#define EM_D30V   86  /* Mitsubishi D30V. */\n#define EM_V850   87  /* NEC v850. */\n#define EM_M32R   88  /* Mitsubishi M32R. */\n#define EM_MN10300  89  /* Matsushita MN10300. */\n#define EM_MN10200  90  /* Matsushita MN10200. */\n#define EM_PJ   91  /* picoJava. */\n#define EM_OPENRISC 92  /* OpenRISC 32-bit embedded processor. */\n#define EM_ARC_A5 93  /* ARC Cores Tangent-A5. */\n#define EM_XTENSA 94  /* Tensilica Xtensa Architecture. */\n#define EM_VIDEOCORE  95  /* Alphamosaic VideoCore processor. */\n#define EM_TMM_GPP  96  /* Thompson Multimedia General Purpose\n           Processor. */\n#define EM_NS32K  97  /* National Semiconductor 32000 series. */\n#define EM_TPC    98  /* Tenor Network TPC processor. */\n#define EM_SNP1K  99  /* Trebia SNP 1000 processor. */\n#define EM_ST200  100 /* STMicroelectronics ST200 microcontroller. */\n#define EM_IP2K   101 /* Ubicom IP2xxx microcontroller family. */\n#define EM_MAX    102 /* MAX Processor. */\n#define EM_CR   103 /* National Semiconductor CompactRISC\n           microprocessor. */\n#define EM_F2MC16 104 /* Fujitsu F2MC16. */\n#define EM_MSP430 105 /* Texas Instruments embedded microcontroller\n           msp430. */\n#define EM_BLACKFIN 106 /* Analog Devices Blackfin (DSP) processor. */\n#define EM_SE_C33 107 /* S1C33 Family of Seiko Epson processors. */\n#define EM_SEP    108 /* Sharp embedded microprocessor. */\n#define EM_ARCA   109 /* Arca RISC Microprocessor. */\n#define EM_UNICORE  110 /* Microprocessor series from PKU-Unity Ltd.\n           and MPRC of Peking University */\n#define EM_AARCH64  183 /* AArch64 (64-bit ARM) */\n#define EM_RISCV  243 /* RISC-V */\n\n/* Non-standard or deprecated. */\n#define EM_486    6 /* Intel i486. */\n#define EM_MIPS_RS4_BE  10  /* MIPS R4000 Big-Endian */\n#define EM_ALPHA_STD  41  /* Digital Alpha (standard value). */\n#define EM_ALPHA  0x9026  /* Alpha (written in the absence of an ABI) */\n\n/**\n * e_flags\n */\n#define EF_ARM_RELEXEC  0x1\n#define EF_ARM_HASENTRY 0x2\n#define EF_ARM_SYMSARESORTED  0x4\n#define EF_ARM_DYNSYMSUSESEGIDX 0x8\n#define EF_ARM_MAPSYMSFIRST 0x10\n#define EF_ARM_LE8    0x00400000\n#define EF_ARM_BE8    0x00800000\n#define EF_ARM_EABIMASK   0xFF000000\n#define EF_ARM_EABI_UNKNOWN 0x00000000\n#define EF_ARM_EABI_VER1  0x01000000\n#define EF_ARM_EABI_VER2  0x02000000\n#define EF_ARM_EABI_VER3  0x03000000\n#define EF_ARM_EABI_VER4  0x04000000\n#define EF_ARM_EABI_VER5  0x05000000\n#define EF_ARM_INTERWORK  0x00000004\n#define EF_ARM_APCS_26    0x00000008\n#define EF_ARM_APCS_FLOAT 0x00000010\n#define EF_ARM_PIC    0x00000020\n#define EF_ARM_ALIGN8   0x00000040\n#define EF_ARM_NEW_ABI    0x00000080\n#define EF_ARM_OLD_ABI    0x00000100\n#define EF_ARM_SOFT_FLOAT 0x00000200\n#define EF_ARM_VFP_FLOAT  0x00000400\n#define EF_ARM_MAVERICK_FLOAT 0x00000800\n\n#define EF_MIPS_NOREORDER 0x00000001\n#define EF_MIPS_PIC   0x00000002  /* Contains PIC code */\n#define EF_MIPS_CPIC    0x00000004  /* STD PIC calling sequence */\n#define EF_MIPS_UCODE   0x00000010\n#define EF_MIPS_ABI2    0x00000020  /* N32 */\n#define EF_MIPS_OPTIONS_FIRST 0x00000080\n#define EF_MIPS_ARCH_ASE  0x0F000000  /* Architectural extensions */\n#define EF_MIPS_ARCH_ASE_MDMX 0x08000000  /* MDMX multimedia extension */\n#define EF_MIPS_ARCH_ASE_M16  0x04000000  /* MIPS-16 ISA extensions */\n#define EF_MIPS_ARCH    0xF0000000  /* Architecture field */\n\n#define EF_PPC_EMB    0x80000000\n#define EF_PPC_RELOCATABLE  0x00010000\n#define EF_PPC_RELOCATABLE_LIB  0x00008000\n\n#define EF_SPARC_EXT_MASK 0x00ffff00\n#define EF_SPARC_32PLUS   0x00000100\n#define EF_SPARC_SUN_US1  0x00000200\n#define EF_SPARC_HAL_R1   0x00000200\n#define EF_SPARC_SUN_US3  0x00000800\n\n#define EF_SPARCV9_MM   0x00000003\n#define EF_SPARCV9_TSO    0x00000000\n#define EF_SPARCV9_PSO    0x00000001\n#define EF_SPARCV9_RMO    0x00000002\n\n/* Special section indexes. */\n#define SHN_UNDEF      0    /* Undefined, missing, irrelevant. */\n#define SHN_LORESERVE 0xff00    /* First of reserved range. */\n#define SHN_LOPROC  0xff00    /* First processor-specific. */\n#define SHN_HIPROC  0xff1f    /* Last processor-specific. */\n#define SHN_LOOS  0xff20    /* First operating system-specific. */\n#define SHN_FBSD_CACHED SHN_LOOS  /* Transient, for sys/kern/link_elf_obj\n             linker only: Cached global in local\n             symtab. */\n#define SHN_HIOS  0xff3f    /* Last operating system-specific. */\n#define SHN_ABS   0xfff1    /* Absolute values. */\n#define SHN_COMMON  0xfff2    /* Common data. */\n#define SHN_XINDEX  0xffff    /* Escape -- index stored elsewhere. */\n#define SHN_HIRESERVE 0xffff    /* Last of reserved range. */\n\n/* sh_type */\n#define SHT_NULL    0 /* inactive */\n#define SHT_PROGBITS    1 /* program defined information */\n#define SHT_SYMTAB    2 /* symbol table section */\n#define SHT_STRTAB    3 /* string table section */\n#define SHT_RELA    4 /* relocation section with addends */\n#define SHT_HASH    5 /* symbol hash table section */\n#define SHT_DYNAMIC   6 /* dynamic section */\n#define SHT_NOTE    7 /* note section */\n#define SHT_NOBITS    8 /* no space section */\n#define SHT_REL     9 /* relocation section - no addends */\n#define SHT_SHLIB   10  /* reserved - purpose unknown */\n#define SHT_DYNSYM    11  /* dynamic symbol table section */\n#define SHT_INIT_ARRAY    14  /* Initialization function pointers. */\n#define SHT_FINI_ARRAY    15  /* Termination function pointers. */\n#define SHT_PREINIT_ARRAY 16  /* Pre-initialization function ptrs. */\n#define SHT_GROUP   17  /* Section group. */\n#define SHT_SYMTAB_SHNDX  18  /* Section indexes (see SHN_XINDEX). */\n#define SHT_LOOS    0x60000000  /* First of OS specific semantics */\n#define SHT_LOSUNW    0x6ffffff4\n#define SHT_SUNW_dof    0x6ffffff4\n#define SHT_SUNW_cap    0x6ffffff5\n#define SHT_GNU_ATTRIBUTES  0x6ffffff5\n#define SHT_SUNW_SIGNATURE  0x6ffffff6\n#define SHT_GNU_HASH    0x6ffffff6\n#define SHT_GNU_LIBLIST   0x6ffffff7\n#define SHT_SUNW_ANNOTATE 0x6ffffff7\n#define SHT_SUNW_DEBUGSTR 0x6ffffff8\n#define SHT_SUNW_DEBUG    0x6ffffff9\n#define SHT_SUNW_move   0x6ffffffa\n#define SHT_SUNW_COMDAT   0x6ffffffb\n#define SHT_SUNW_syminfo  0x6ffffffc\n#define SHT_SUNW_verdef   0x6ffffffd\n#define SHT_GNU_verdef    0x6ffffffd  /* Symbol versions provided */\n#define SHT_SUNW_verneed  0x6ffffffe\n#define SHT_GNU_verneed   0x6ffffffe  /* Symbol versions required */\n#define SHT_SUNW_versym   0x6fffffff\n#define SHT_GNU_versym    0x6fffffff  /* Symbol version table */\n#define SHT_HISUNW    0x6fffffff\n#define SHT_HIOS    0x6fffffff  /* Last of OS specific semantics */\n#define SHT_LOPROC    0x70000000  /* reserved range for processor */\n#define SHT_X86_64_UNWIND 0x70000001  /* unwind information */\n#define SHT_AMD64_UNWIND  SHT_X86_64_UNWIND \n\n#define SHT_ARM_EXIDX   0x70000001  /* Exception index table. */\n#define SHT_ARM_PREEMPTMAP  0x70000002  /* BPABI DLL dynamic linking \n               pre-emption map. */\n#define SHT_ARM_ATTRIBUTES  0x70000003  /* Object file compatibility \n               attributes. */\n#define SHT_ARM_DEBUGOVERLAY  0x70000004  /* See DBGOVL for details. */\n#define SHT_ARM_OVERLAYSECTION  0x70000005  /* See DBGOVL for details. */\n#define SHT_MIPS_LIBLIST  0x70000000\n#define SHT_MIPS_MSYM   0x70000001\n#define SHT_MIPS_CONFLICT 0x70000002\n#define SHT_MIPS_GPTAB    0x70000003\n#define SHT_MIPS_UCODE    0x70000004\n#define SHT_MIPS_DEBUG    0x70000005\n#define SHT_MIPS_REGINFO  0x70000006\n#define SHT_MIPS_PACKAGE  0x70000007\n#define SHT_MIPS_PACKSYM  0x70000008\n#define SHT_MIPS_RELD   0x70000009\n#define SHT_MIPS_IFACE    0x7000000b\n#define SHT_MIPS_CONTENT  0x7000000c\n#define SHT_MIPS_OPTIONS  0x7000000d\n#define SHT_MIPS_DELTASYM 0x7000001b\n#define SHT_MIPS_DELTAINST  0x7000001c\n#define SHT_MIPS_DELTACLASS 0x7000001d\n#define SHT_MIPS_DWARF    0x7000001e  /* MIPS gcc uses MIPS_DWARF */\n#define SHT_MIPS_DELTADECL  0x7000001f\n#define SHT_MIPS_SYMBOL_LIB 0x70000020\n#define SHT_MIPS_EVENTS   0x70000021\n#define SHT_MIPS_TRANSLATE  0x70000022\n#define SHT_MIPS_PIXIE    0x70000023\n#define SHT_MIPS_XLATE    0x70000024\n#define SHT_MIPS_XLATE_DEBUG  0x70000025\n#define SHT_MIPS_WHIRL    0x70000026\n#define SHT_MIPS_EH_REGION  0x70000027\n#define SHT_MIPS_XLATE_OLD  0x70000028\n#define SHT_MIPS_PDR_EXCEPTION  0x70000029\n#define SHT_MIPS_ABIFLAGS 0x7000002a\n\n#define SHT_SPARC_GOTDATA 0x70000000\n\n#define SHTORDERED\n#define SHT_HIPROC    0x7fffffff  /* specific section header types */\n#define SHT_LOUSER    0x80000000  /* reserved range for application */\n#define SHT_HIUSER    0xffffffff  /* specific indexes */\n\n/* Flags for sh_flags. */\n#define SHF_WRITE   0x1 /* Section contains writable data. */\n#define SHF_ALLOC   0x2 /* Section occupies memory. */\n#define SHF_EXECINSTR   0x4 /* Section contains instructions. */\n#define SHF_MERGE   0x10  /* Section may be merged. */\n#define SHF_STRINGS   0x20  /* Section contains strings. */\n#define SHF_INFO_LINK   0x40  /* sh_info holds section index. */\n#define SHF_LINK_ORDER    0x80  /* Special ordering requirements. */\n#define SHF_OS_NONCONFORMING  0x100 /* OS-specific processing required. */\n#define SHF_GROUP   0x200 /* Member of section group. */\n#define SHF_TLS     0x400 /* Section contains TLS data. */\n#define SHF_COMPRESSED    0x800 /* Section contains compressed data. */\n#define SHF_MASKOS  0x0ff00000  /* OS-specific semantics. */\n#define SHF_MASKPROC  0xf0000000  /* Processor-specific semantics. */\n\n/* Flags for section groups. */\n#define GRP_COMDAT  0x1 /* COMDAT semantics. */\n\n/*\n * Flags / mask for .gnu.versym sections.\n */\n#define VERSYM_VERSION  0x7fff\n#define VERSYM_HIDDEN 0x8000\n\n/* Values for p_type. */\n#define PT_NULL   0 /* Unused entry. */\n#define PT_LOAD   1 /* Loadable segment. */\n#define PT_DYNAMIC  2 /* Dynamic linking information segment. */\n#define PT_INTERP 3 /* Pathname of interpreter. */\n#define PT_NOTE   4 /* Auxiliary information. */\n#define PT_SHLIB  5 /* Reserved (not used). */\n#define PT_PHDR   6 /* Location of program header itself. */\n#define PT_TLS    7 /* Thread local storage segment */\n#define PT_LOOS   0x60000000  /* First OS-specific. */\n#define PT_SUNW_UNWIND  0x6464e550  /* amd64 UNWIND program header */\n#define PT_GNU_EH_FRAME 0x6474e550\n#define PT_GNU_STACK  0x6474e551\n#define PT_GNU_RELRO  0x6474e552\n#define PT_DUMP_DELTA 0x6fb5d000  /* va->pa map for kernel dumps\n             (currently arm). */\n#define PT_LOSUNW 0x6ffffffa\n#define PT_SUNWBSS  0x6ffffffa  /* Sun Specific segment */\n#define PT_SUNWSTACK  0x6ffffffb  /* describes the stack segment */\n#define PT_SUNWDTRACE 0x6ffffffc  /* private */\n#define PT_SUNWCAP  0x6ffffffd  /* hard/soft capabilities segment */\n#define PT_HISUNW 0x6fffffff\n#define PT_HIOS   0x6fffffff  /* Last OS-specific. */\n#define PT_LOPROC 0x70000000  /* First processor-specific type. */\n#define PT_ARM_ARCHEXT  0x70000000  /* ARM arch compat information. */\n#define PT_ARM_EXIDX  0x70000001  /* ARM exception unwind tables. */\n#define PT_HIPROC 0x7fffffff  /* Last processor-specific type. */\n\n/* Values for p_flags. */\n#define PF_X    0x1   /* Executable. */\n#define PF_W    0x2   /* Writable. */\n#define PF_R    0x4   /* Readable. */\n#define PF_MASKOS 0x0ff00000  /* Operating system-specific. */\n#define PF_MASKPROC 0xf0000000  /* Processor-specific. */\n\n/* Extended program header index. */\n#define PN_XNUM   0xffff\n\n/* Values for d_tag. */\n#define DT_NULL   0 /* Terminating entry. */\n#define DT_NEEDED 1 /* String table offset of a needed shared\n           library. */\n#define DT_PLTRELSZ 2 /* Total size in bytes of PLT relocations. */\n#define DT_PLTGOT 3 /* Processor-dependent address. */\n#define DT_HASH   4 /* Address of symbol hash table. */\n#define DT_STRTAB 5 /* Address of string table. */\n#define DT_SYMTAB 6 /* Address of symbol table. */\n#define DT_RELA   7 /* Address of ElfNN_Rela relocations. */\n#define DT_RELASZ 8 /* Total size of ElfNN_Rela relocations. */\n#define DT_RELAENT  9 /* Size of each ElfNN_Rela relocation entry. */\n#define DT_STRSZ  10  /* Size of string table. */\n#define DT_SYMENT 11  /* Size of each symbol table entry. */\n#define DT_INIT   12  /* Address of initialization function. */\n#define DT_FINI   13  /* Address of finalization function. */\n#define DT_SONAME 14  /* String table offset of shared object\n           name. */\n#define DT_RPATH  15  /* String table offset of library path. [sup] */\n#define DT_SYMBOLIC 16  /* Indicates \"symbolic\" linking. [sup] */\n#define DT_REL    17  /* Address of ElfNN_Rel relocations. */\n#define DT_RELSZ  18  /* Total size of ElfNN_Rel relocations. */\n#define DT_RELENT 19  /* Size of each ElfNN_Rel relocation. */\n#define DT_PLTREL 20  /* Type of relocation used for PLT. */\n#define DT_DEBUG  21  /* Reserved (not used). */\n#define DT_TEXTREL  22  /* Indicates there may be relocations in\n           non-writable segments. [sup] */\n#define DT_JMPREL 23  /* Address of PLT relocations. */\n#define DT_BIND_NOW 24  /* [sup] */\n#define DT_INIT_ARRAY 25  /* Address of the array of pointers to\n           initialization functions */\n#define DT_FINI_ARRAY 26  /* Address of the array of pointers to\n           termination functions */\n#define DT_INIT_ARRAYSZ 27  /* Size in bytes of the array of\n           initialization functions. */\n#define DT_FINI_ARRAYSZ 28  /* Size in bytes of the array of\n           termination functions. */\n#define DT_RUNPATH  29  /* String table offset of a null-terminated\n           library search path string. */\n#define DT_FLAGS  30  /* Object specific flag values. */\n#define DT_ENCODING 32  /* Values greater than or equal to DT_ENCODING\n           and less than DT_LOOS follow the rules for\n           the interpretation of the d_un union\n           as follows: even == 'd_ptr', odd == 'd_val'\n           or none */\n#define DT_PREINIT_ARRAY 32 /* Address of the array of pointers to\n           pre-initialization functions. */\n#define DT_PREINIT_ARRAYSZ 33 /* Size in bytes of the array of\n           pre-initialization functions. */\n#define DT_MAXPOSTAGS 34  /* number of positive tags */\n#define DT_LOOS   0x6000000d  /* First OS-specific */\n#define DT_SUNW_AUXILIARY 0x6000000d  /* symbol auxiliary name */\n#define DT_SUNW_RTLDINF   0x6000000e  /* ld.so.1 info (private) */\n#define DT_SUNW_FILTER    0x6000000f  /* symbol filter name */\n#define DT_SUNW_CAP   0x60000010  /* hardware/software */\n#define DT_HIOS   0x6ffff000  /* Last OS-specific */\n\n/*\n * DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n * Dyn.d_un.d_val field of the Elf*_Dyn structure.\n */\n#define DT_VALRNGLO 0x6ffffd00\n#define DT_GNU_PRELINKED  0x6ffffdf5 /* prelinking timestamp */\n#define DT_GNU_CONFLICTSZ 0x6ffffdf6 /* size of conflict section */\n#define DT_GNU_LIBLISTSZ  0x6ffffdf7 /* size of library list */\n#define DT_CHECKSUM 0x6ffffdf8  /* elf checksum */\n#define DT_PLTPADSZ 0x6ffffdf9  /* pltpadding size */\n#define DT_MOVEENT  0x6ffffdfa  /* move table entry size */\n#define DT_MOVESZ 0x6ffffdfb  /* move table size */\n#define DT_FEATURE  0x6ffffdfc  /* feature holder */\n#define DT_FEATURE_1  DT_FEATURE\n#define DT_POSFLAG_1  0x6ffffdfd  /* flags for DT_* entries, effecting */\n          /*  the following DT_* entry. */\n          /*  See DF_P1_* definitions */\n#define DT_SYMINSZ  0x6ffffdfe  /* syminfo table size (in bytes) */\n#define DT_SYMINENT 0x6ffffdff  /* syminfo entry size (in bytes) */\n#define DT_VALRNGHI 0x6ffffdff\n\n/*\n * DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n * Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n *\n * If any adjustment is made to the ELF object after it has been\n * built, these entries will need to be adjusted.\n */\n#define DT_ADDRRNGLO  0x6ffffe00\n#define DT_GNU_HASH 0x6ffffef5  /* GNU-style hash table */\n#define DT_TLSDESC_PLT  0x6ffffef6  /* loc. of PLT for tlsdesc resolver */\n#define DT_TLSDESC_GOT  0x6ffffef7  /* loc. of GOT for tlsdesc resolver */\n#define DT_GNU_CONFLICT 0x6ffffef8  /* address of conflict section */\n#define DT_GNU_LIBLIST  0x6ffffef9  /* address of library list */\n#define DT_CONFIG 0x6ffffefa  /* configuration information */\n#define DT_DEPAUDIT 0x6ffffefb  /* dependency auditing */\n#define DT_AUDIT  0x6ffffefc  /* object auditing */\n#define DT_PLTPAD 0x6ffffefd  /* pltpadding (sparcv9) */\n#define DT_MOVETAB  0x6ffffefe  /* move table */\n#define DT_SYMINFO  0x6ffffeff  /* syminfo table */\n#define DT_ADDRRNGHI  0x6ffffeff\n\n#define DT_VERSYM 0x6ffffff0  /* Address of versym section. */\n#define DT_RELACOUNT  0x6ffffff9  /* number of RELATIVE relocations */\n#define DT_RELCOUNT 0x6ffffffa  /* number of RELATIVE relocations */\n#define DT_FLAGS_1  0x6ffffffb  /* state flags - see DF_1_* defs */\n#define DT_VERDEF 0x6ffffffc  /* Address of verdef section. */\n#define DT_VERDEFNUM  0x6ffffffd  /* Number of elems in verdef section */\n#define DT_VERNEED  0x6ffffffe  /* Address of verneed section. */\n#define DT_VERNEEDNUM 0x6fffffff  /* Number of elems in verneed section */\n\n#define DT_LOPROC 0x70000000  /* First processor-specific type. */\n\n#define DT_ARM_SYMTABSZ     0x70000001\n#define DT_ARM_PREEMPTMAP   0x70000002\n\n#define DT_SPARC_REGISTER   0x70000001\n#define DT_DEPRECATED_SPARC_REGISTER  0x7000001\n\n#define DT_MIPS_RLD_VERSION   0x70000001\n#define DT_MIPS_TIME_STAMP    0x70000002\n#define DT_MIPS_ICHECKSUM   0x70000003\n#define DT_MIPS_IVERSION    0x70000004\n#define DT_MIPS_FLAGS     0x70000005\n#define DT_MIPS_BASE_ADDRESS    0x70000006\n#define DT_MIPS_CONFLICT    0x70000008\n#define DT_MIPS_LIBLIST     0x70000009\n#define DT_MIPS_LOCAL_GOTNO   0x7000000a\n#define DT_MIPS_CONFLICTNO    0x7000000b\n#define DT_MIPS_LIBLISTNO   0x70000010\n#define DT_MIPS_SYMTABNO    0x70000011\n#define DT_MIPS_UNREFEXTNO    0x70000012\n#define DT_MIPS_GOTSYM      0x70000013\n#define DT_MIPS_HIPAGENO    0x70000014\n#define DT_MIPS_RLD_MAP     0x70000016\n#define DT_MIPS_DELTA_CLASS   0x70000017\n#define DT_MIPS_DELTA_CLASS_NO    0x70000018\n#define DT_MIPS_DELTA_INSTANCE    0x70000019\n#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001A\n#define DT_MIPS_DELTA_RELOC   0x7000001B\n#define DT_MIPS_DELTA_RELOC_NO    0x7000001C\n#define DT_MIPS_DELTA_SYM   0x7000001D\n#define DT_MIPS_DELTA_SYM_NO    0x7000001E\n#define DT_MIPS_DELTA_CLASSSYM    0x70000020\n#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021\n#define DT_MIPS_CXX_FLAGS   0x70000022\n#define DT_MIPS_PIXIE_INIT    0x70000023\n#define DT_MIPS_SYMBOL_LIB    0x70000024\n#define DT_MIPS_LOCALPAGE_GOTIDX  0x70000025\n#define DT_MIPS_LOCAL_GOTIDX    0x70000026\n#define DT_MIPS_HIDDEN_GOTIDX   0x70000027\n#define DT_MIPS_PROTECTED_GOTIDX  0x70000028\n#define DT_MIPS_OPTIONS     0x70000029\n#define DT_MIPS_INTERFACE   0x7000002A\n#define DT_MIPS_DYNSTR_ALIGN    0x7000002B\n#define DT_MIPS_INTERFACE_SIZE    0x7000002C\n#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002D\n#define DT_MIPS_PERF_SUFFIX   0x7000002E\n#define DT_MIPS_COMPACT_SIZE    0x7000002F\n#define DT_MIPS_GP_VALUE    0x70000030\n#define DT_MIPS_AUX_DYNAMIC   0x70000031\n#define DT_MIPS_PLTGOT      0x70000032\n#define DT_MIPS_RLD_OBJ_UPDATE    0x70000033\n#define DT_MIPS_RWPLT     0x70000034\n\n#define DT_PPC_GOT      0x70000000\n#define DT_PPC_TLSOPT     0x70000001\n\n#define DT_PPC64_GLINK      0x70000000\n#define DT_PPC64_OPD      0x70000001\n#define DT_PPC64_OPDSZ      0x70000002\n#define DT_PPC64_TLSOPT     0x70000003\n\n#define DT_AUXILIARY  0x7ffffffd  /* shared library auxiliary name */\n#define DT_USED   0x7ffffffe  /* ignored - same as needed */\n#define DT_FILTER 0x7fffffff  /* shared library filter name */\n#define DT_HIPROC 0x7fffffff  /* Last processor-specific type. */\n\n/* Values for DT_FLAGS */\n#define DF_ORIGIN 0x0001  /* Indicates that the object being loaded may\n           make reference to the $ORIGIN substitution\n           string */\n#define DF_SYMBOLIC 0x0002  /* Indicates \"symbolic\" linking. */\n#define DF_TEXTREL  0x0004  /* Indicates there may be relocations in\n           non-writable segments. */\n#define DF_BIND_NOW 0x0008  /* Indicates that the dynamic linker should\n           process all relocations for the object\n           containing this entry before transferring\n           control to the program. */\n#define DF_STATIC_TLS 0x0010  /* Indicates that the shared object or\n           executable contains code using a static\n           thread-local storage scheme. */\n\n/* Values for DT_FLAGS_1 */\n#define DF_1_BIND_NOW 0x00000001  /* Same as DF_BIND_NOW */\n#define DF_1_GLOBAL 0x00000002  /* Set the RTLD_GLOBAL for object */\n#define DF_1_NODELETE 0x00000008  /* Set the RTLD_NODELETE for object */\n#define DF_1_LOADFLTR 0x00000010  /* Immediate loading of filtees */\n#define DF_1_NOOPEN     0x00000040  /* Do not allow loading on dlopen() */\n#define DF_1_ORIGIN 0x00000080  /* Process $ORIGIN */\n#define DF_1_INTERPOSE  0x00000400  /* Interpose all objects but main */\n#define DF_1_NODEFLIB 0x00000800  /* Do not search default paths */\n\n/* Values for l_flags. */\n#define LL_NONE     0x0 /* no flags */\n#define LL_EXACT_MATCH    0x1 /* require an exact match */\n#define LL_IGNORE_INT_VER 0x2 /* ignore version incompatibilities */\n#define LL_REQUIRE_MINOR  0x4\n#define LL_EXPORTS    0x8\n#define LL_DELAY_LOAD   0x10\n#define LL_DELTA    0x20\n\n/* Values for n_type used in executables. */\n#define NT_FREEBSD_ABI_TAG  1\n#define NT_FREEBSD_NOINIT_TAG 2\n#define NT_FREEBSD_ARCH_TAG 3\n\n/* Values for n_type.  Used in core files. */\n#define NT_PRSTATUS 1 /* Process status. */\n#define NT_FPREGSET 2 /* Floating point registers. */\n#define NT_PRPSINFO 3 /* Process state info. */\n#define NT_THRMISC  7 /* Thread miscellaneous info. */\n#define NT_PROCSTAT_PROC  8 /* Procstat proc data. */\n#define NT_PROCSTAT_FILES 9 /* Procstat files data. */\n#define NT_PROCSTAT_VMMAP 10  /* Procstat vmmap data. */\n#define NT_PROCSTAT_GROUPS  11  /* Procstat groups data. */\n#define NT_PROCSTAT_UMASK 12  /* Procstat umask data. */\n#define NT_PROCSTAT_RLIMIT  13  /* Procstat rlimit data. */\n#define NT_PROCSTAT_OSREL 14  /* Procstat osreldate data. */\n#define NT_PROCSTAT_PSSTRINGS 15  /* Procstat ps_strings data. */\n#define NT_PROCSTAT_AUXV  16  /* Procstat auxv data. */\n#define NT_PTLWPINFO    17  /* Thread ptrace miscellaneous info. */\n#define NT_PPC_VMX  0x100 /* PowerPC Altivec/VMX registers */\n#define NT_X86_XSTATE 0x202 /* x86 XSAVE extended state. */\n#define NT_ARM_VFP  0x400 /* ARM VFP registers */\n\n/* Symbol Binding - ELFNN_ST_BIND - st_info */\n#define STB_LOCAL 0 /* Local symbol */\n#define STB_GLOBAL  1 /* Global symbol */\n#define STB_WEAK  2 /* like global - lower precedence */\n#define STB_LOOS  10  /* Start of operating system reserved range. */\n#define STB_GNU_UNIQUE  10  /* Unique symbol (GNU) */\n#define STB_HIOS  12  /* End of operating system reserved range. */\n#define STB_LOPROC  13  /* reserved range for processor */\n#define STB_HIPROC  15  /*   specific semantics. */\n\n/* Symbol type - ELFNN_ST_TYPE - st_info */\n#define STT_NOTYPE  0 /* Unspecified type. */\n#define STT_OBJECT  1 /* Data object. */\n#define STT_FUNC  2 /* Function. */\n#define STT_SECTION 3 /* Section. */\n#define STT_FILE  4 /* Source file. */\n#define STT_COMMON  5 /* Uninitialized common block. */\n#define STT_TLS   6 /* TLS object. */\n#define STT_NUM   7\n#define STT_LOOS  10  /* Reserved range for operating system */\n#define STT_GNU_IFUNC 10\n#define STT_HIOS  12  /*   specific semantics. */\n#define STT_LOPROC  13  /* Start of processor reserved range. */\n#define STT_SPARC_REGISTER 13 /* SPARC register information. */\n#define STT_HIPROC  15  /* End of processor reserved range. */\n\n/* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */\n#define STV_DEFAULT 0x0 /* Default visibility (see binding). */\n#define STV_INTERNAL  0x1 /* Special meaning in relocatable objects. */\n#define STV_HIDDEN  0x2 /* Not visible. */\n#define STV_PROTECTED 0x3 /* Visible but not preemptible. */\n#define STV_EXPORTED  0x4\n#define STV_SINGLETON 0x5\n#define STV_ELIMINATE 0x6\n\n/* Special symbol table indexes. */\n#define STN_UNDEF 0 /* Undefined symbol index. */\n\n/* Symbol versioning flags. */\n#define VER_DEF_CURRENT 1\n#define VER_DEF_IDX(x)  VER_NDX(x)\n\n#define VER_FLG_BASE  0x01\n#define VER_FLG_WEAK  0x02\n\n#define VER_NEED_CURRENT  1\n#define VER_NEED_WEAK (1u << 15)\n#define VER_NEED_HIDDEN VER_NDX_HIDDEN\n#define VER_NEED_IDX(x) VER_NDX(x)\n\n#define VER_NDX_LOCAL 0\n#define VER_NDX_GLOBAL  1\n#define VER_NDX_GIVEN 2\n\n#define VER_NDX_HIDDEN  (1u << 15)\n#define VER_NDX(x)  ((x) & ~(1u << 15))\n\n#define CA_SUNW_NULL  0\n#define CA_SUNW_HW_1  1   /* first hardware capabilities entry */\n#define CA_SUNW_SF_1  2   /* first software capabilities entry */\n\n/*\n * Syminfo flag values\n */\n#define SYMINFO_FLG_DIRECT  0x0001  /* symbol ref has direct association */\n          /*  to object containing defn. */\n#define SYMINFO_FLG_PASSTHRU  0x0002  /* ignored - see SYMINFO_FLG_FILTER */\n#define SYMINFO_FLG_COPY  0x0004  /* symbol is a copy-reloc */\n#define SYMINFO_FLG_LAZYLOAD  0x0008  /* object containing defn should be */\n          /*  lazily-loaded */\n#define SYMINFO_FLG_DIRECTBIND  0x0010  /* ref should be bound directly to */\n          /*  object containing defn. */\n#define SYMINFO_FLG_NOEXTDIRECT 0x0020  /* don't let an external reference */\n          /*  directly bind to this symbol */\n#define SYMINFO_FLG_FILTER  0x0002  /* symbol ref is associated to a */\n#define SYMINFO_FLG_AUXILIARY 0x0040  /*  standard or auxiliary filter */\n\n/*\n * Syminfo.si_boundto values.\n */\n#define SYMINFO_BT_SELF   0xffff  /* symbol bound to self */\n#define SYMINFO_BT_PARENT 0xfffe  /* symbol bound to parent */\n#define SYMINFO_BT_NONE   0xfffd  /* no special symbol binding */\n#define SYMINFO_BT_EXTERN 0xfffc  /* symbol defined as external */\n#define SYMINFO_BT_LOWRESERVE 0xff00  /* beginning of reserved entries */\n\n/*\n * Syminfo version values.\n */\n#define SYMINFO_NONE    0 /* Syminfo version */\n#define SYMINFO_CURRENT   1\n#define SYMINFO_NUM   2\n\n/* Values for ch_type (compressed section headers). */\n#define ELFCOMPRESS_ZLIB  1 /* ZLIB/DEFLATE */\n#define ELFCOMPRESS_LOOS  0x60000000  /* OS-specific */\n#define ELFCOMPRESS_HIOS  0x6fffffff\n#define ELFCOMPRESS_LOPROC  0x70000000  /* Processor-specific */\n#define ELFCOMPRESS_HIPROC  0x7fffffff\n\n/*\n * Relocation types.\n *\n * All machine architectures are defined here to allow tools on one to\n * handle others.\n */\n\n#define R_386_NONE    0 /* No relocation. */\n#define R_386_32    1 /* Add symbol value. */\n#define R_386_PC32    2 /* Add PC-relative symbol value. */\n#define R_386_GOT32   3 /* Add PC-relative GOT offset. */\n#define R_386_PLT32   4 /* Add PC-relative PLT offset. */\n#define R_386_COPY    5 /* Copy data from shared object. */\n#define R_386_GLOB_DAT    6 /* Set GOT entry to data address. */\n#define R_386_JMP_SLOT    7 /* Set GOT entry to code address. */\n#define R_386_RELATIVE    8 /* Add load address of shared object. */\n#define R_386_GOTOFF    9 /* Add GOT-relative symbol address. */\n#define R_386_GOTPC   10  /* Add PC-relative GOT table address. */\n#define R_386_TLS_TPOFF   14  /* Negative offset in static TLS block */\n#define R_386_TLS_IE    15  /* Absolute address of GOT for -ve static TLS */\n#define R_386_TLS_GOTIE   16  /* GOT entry for negative static TLS block */\n#define R_386_TLS_LE    17  /* Negative offset relative to static TLS */\n#define R_386_TLS_GD    18  /* 32 bit offset to GOT (index,off) pair */\n#define R_386_TLS_LDM   19  /* 32 bit offset to GOT (index,zero) pair */\n#define R_386_TLS_GD_32   24  /* 32 bit offset to GOT (index,off) pair */\n#define R_386_TLS_GD_PUSH 25  /* pushl instruction for Sun ABI GD sequence */\n#define R_386_TLS_GD_CALL 26  /* call instruction for Sun ABI GD sequence */\n#define R_386_TLS_GD_POP  27  /* popl instruction for Sun ABI GD sequence */\n#define R_386_TLS_LDM_32  28  /* 32 bit offset to GOT (index,zero) pair */\n#define R_386_TLS_LDM_PUSH  29  /* pushl instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDM_CALL  30  /* call instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDM_POP 31  /* popl instruction for Sun ABI LD sequence */\n#define R_386_TLS_LDO_32  32  /* 32 bit offset from start of TLS block */\n#define R_386_TLS_IE_32   33  /* 32 bit offset to GOT static TLS offset entry */\n#define R_386_TLS_LE_32   34  /* 32 bit offset within static TLS block */\n#define R_386_TLS_DTPMOD32  35  /* GOT entry containing TLS index */\n#define R_386_TLS_DTPOFF32  36  /* GOT entry containing TLS offset */\n#define R_386_TLS_TPOFF32 37  /* GOT entry of -ve static TLS offset */\n#define R_386_IRELATIVE   42  /* PLT entry resolved indirectly at runtime */\n\n#define R_AARCH64_NONE    0 /* No relocation */\n#define R_AARCH64_ABS64   257 /* Absolute offset */\n#define R_AARCH64_ABS32   258 /* Absolute, 32-bit overflow check */\n#define R_AARCH64_ABS16   259 /* Absolute, 16-bit overflow check */\n#define R_AARCH64_PREL64  260 /* PC relative */\n#define R_AARCH64_PREL32  261 /* PC relative, 32-bit overflow check */\n#define R_AARCH64_PREL16  262 /* PC relative, 16-bit overflow check */\n#define R_AARCH64_COPY    1024  /* Copy data from shared object */\n#define R_AARCH64_GLOB_DAT  1025  /* Set GOT entry to data address */\n#define R_AARCH64_JUMP_SLOT 1026  /* Set GOT entry to code address */\n#define R_AARCH64_RELATIVE  1027  /* Add load address of shared object */\n#define R_AARCH64_TLS_DTPREL64  1028\n#define R_AARCH64_TLS_DTPMOD64  1029\n#define R_AARCH64_TLS_TPREL64   1030\n#define R_AARCH64_TLSDESC   1031  /* Identify the TLS descriptor */\n#define R_AARCH64_IRELATIVE 1032\n\n#define R_ARM_NONE    0 /* No relocation. */\n#define R_ARM_PC24    1\n#define R_ARM_ABS32   2\n#define R_ARM_REL32   3\n#define R_ARM_PC13    4\n#define R_ARM_ABS16   5\n#define R_ARM_ABS12   6\n#define R_ARM_THM_ABS5    7\n#define R_ARM_ABS8    8\n#define R_ARM_SBREL32   9\n#define R_ARM_THM_PC22    10\n#define R_ARM_THM_PC8   11\n#define R_ARM_AMP_VCALL9  12\n#define R_ARM_SWI24   13\n#define R_ARM_THM_SWI8    14\n#define R_ARM_XPC25   15\n#define R_ARM_THM_XPC22   16\n/* TLS relocations */\n#define R_ARM_TLS_DTPMOD32  17  /* ID of module containing symbol */\n#define R_ARM_TLS_DTPOFF32  18  /* Offset in TLS block */\n#define R_ARM_TLS_TPOFF32 19  /* Offset in static TLS block */\n#define R_ARM_COPY    20  /* Copy data from shared object. */\n#define R_ARM_GLOB_DAT    21  /* Set GOT entry to data address. */\n#define R_ARM_JUMP_SLOT   22  /* Set GOT entry to code address. */\n#define R_ARM_RELATIVE    23  /* Add load address of shared object. */\n#define R_ARM_GOTOFF    24  /* Add GOT-relative symbol address. */\n#define R_ARM_GOTPC   25  /* Add PC-relative GOT table address. */\n#define R_ARM_GOT32   26  /* Add PC-relative GOT offset. */\n#define R_ARM_PLT32   27  /* Add PC-relative PLT offset. */\n#define R_ARM_GNU_VTENTRY 100\n#define R_ARM_GNU_VTINHERIT 101\n#define R_ARM_RSBREL32    250\n#define R_ARM_THM_RPC22   251\n#define R_ARM_RREL32    252\n#define R_ARM_RABS32    253\n#define R_ARM_RPC24   254\n#define R_ARM_RBASE   255\n\n/*  Name      Value    Field  Calculation */\n#define R_IA_64_NONE    0 /* None */\n#define R_IA_64_IMM14   0x21  /* immediate14  S + A */\n#define R_IA_64_IMM22   0x22  /* immediate22  S + A */\n#define R_IA_64_IMM64   0x23  /* immediate64  S + A */\n#define R_IA_64_DIR32MSB  0x24  /* word32 MSB S + A */\n#define R_IA_64_DIR32LSB  0x25  /* word32 LSB S + A */\n#define R_IA_64_DIR64MSB  0x26  /* word64 MSB S + A */\n#define R_IA_64_DIR64LSB  0x27  /* word64 LSB S + A */\n#define R_IA_64_GPREL22   0x2a  /* immediate22  @gprel(S + A) */\n#define R_IA_64_GPREL64I  0x2b  /* immediate64  @gprel(S + A) */\n#define R_IA_64_GPREL32MSB  0x2c  /* word32 MSB @gprel(S + A) */\n#define R_IA_64_GPREL32LSB  0x2d  /* word32 LSB @gprel(S + A) */\n#define R_IA_64_GPREL64MSB  0x2e  /* word64 MSB @gprel(S + A) */\n#define R_IA_64_GPREL64LSB  0x2f  /* word64 LSB @gprel(S + A) */\n#define R_IA_64_LTOFF22   0x32  /* immediate22  @ltoff(S + A) */\n#define R_IA_64_LTOFF64I  0x33  /* immediate64  @ltoff(S + A) */\n#define R_IA_64_PLTOFF22  0x3a  /* immediate22  @pltoff(S + A) */\n#define R_IA_64_PLTOFF64I 0x3b  /* immediate64  @pltoff(S + A) */\n#define R_IA_64_PLTOFF64MSB 0x3e  /* word64 MSB @pltoff(S + A) */\n#define R_IA_64_PLTOFF64LSB 0x3f  /* word64 LSB @pltoff(S + A) */\n#define R_IA_64_FPTR64I   0x43  /* immediate64  @fptr(S + A) */\n#define R_IA_64_FPTR32MSB 0x44  /* word32 MSB @fptr(S + A) */\n#define R_IA_64_FPTR32LSB 0x45  /* word32 LSB @fptr(S + A) */\n#define R_IA_64_FPTR64MSB 0x46  /* word64 MSB @fptr(S + A) */\n#define R_IA_64_FPTR64LSB 0x47  /* word64 LSB @fptr(S + A) */\n#define R_IA_64_PCREL60B  0x48  /* immediate60 form1 S + A - P */\n#define R_IA_64_PCREL21B  0x49  /* immediate21 form1 S + A - P */\n#define R_IA_64_PCREL21M  0x4a  /* immediate21 form2 S + A - P */\n#define R_IA_64_PCREL21F  0x4b  /* immediate21 form3 S + A - P */\n#define R_IA_64_PCREL32MSB  0x4c  /* word32 MSB S + A - P */\n#define R_IA_64_PCREL32LSB  0x4d  /* word32 LSB S + A - P */\n#define R_IA_64_PCREL64MSB  0x4e  /* word64 MSB S + A - P */\n#define R_IA_64_PCREL64LSB  0x4f  /* word64 LSB S + A - P */\n#define R_IA_64_LTOFF_FPTR22  0x52  /* immediate22  @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64I 0x53  /* immediate64  @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR32MSB 0x54  /* word32 MSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR32LSB 0x55  /* word32 LSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64MSB 0x56  /* word64 MSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_LTOFF_FPTR64LSB 0x57  /* word64 LSB @ltoff(@fptr(S + A)) */\n#define R_IA_64_SEGREL32MSB 0x5c  /* word32 MSB @segrel(S + A) */\n#define R_IA_64_SEGREL32LSB 0x5d  /* word32 LSB @segrel(S + A) */\n#define R_IA_64_SEGREL64MSB 0x5e  /* word64 MSB @segrel(S + A) */\n#define R_IA_64_SEGREL64LSB 0x5f  /* word64 LSB @segrel(S + A) */\n#define R_IA_64_SECREL32MSB 0x64  /* word32 MSB @secrel(S + A) */\n#define R_IA_64_SECREL32LSB 0x65  /* word32 LSB @secrel(S + A) */\n#define R_IA_64_SECREL64MSB 0x66  /* word64 MSB @secrel(S + A) */\n#define R_IA_64_SECREL64LSB 0x67  /* word64 LSB @secrel(S + A) */\n#define R_IA_64_REL32MSB  0x6c  /* word32 MSB BD + A */\n#define R_IA_64_REL32LSB  0x6d  /* word32 LSB BD + A */\n#define R_IA_64_REL64MSB  0x6e  /* word64 MSB BD + A */\n#define R_IA_64_REL64LSB  0x6f  /* word64 LSB BD + A */\n#define R_IA_64_LTV32MSB  0x74  /* word32 MSB S + A */\n#define R_IA_64_LTV32LSB  0x75  /* word32 LSB S + A */\n#define R_IA_64_LTV64MSB  0x76  /* word64 MSB S + A */\n#define R_IA_64_LTV64LSB  0x77  /* word64 LSB S + A */\n#define R_IA_64_PCREL21BI 0x79  /* immediate21 form1 S + A - P */\n#define R_IA_64_PCREL22   0x7a  /* immediate22  S + A - P */\n#define R_IA_64_PCREL64I  0x7b  /* immediate64  S + A - P */\n#define R_IA_64_IPLTMSB   0x80  /* function descriptor MSB special */\n#define R_IA_64_IPLTLSB   0x81  /* function descriptor LSB speciaal */\n#define R_IA_64_SUB   0x85  /* immediate64  A - S */\n#define R_IA_64_LTOFF22X  0x86  /* immediate22  special */\n#define R_IA_64_LDXMOV    0x87  /* immediate22  special */\n#define R_IA_64_TPREL14   0x91  /* imm14  @tprel(S + A) */\n#define R_IA_64_TPREL22   0x92  /* imm22  @tprel(S + A) */\n#define R_IA_64_TPREL64I  0x93  /* imm64  @tprel(S + A) */\n#define R_IA_64_TPREL64MSB  0x96  /* word64 MSB @tprel(S + A) */\n#define R_IA_64_TPREL64LSB  0x97  /* word64 LSB @tprel(S + A) */\n#define R_IA_64_LTOFF_TPREL22 0x9a  /* imm22  @ltoff(@tprel(S+A)) */\n#define R_IA_64_DTPMOD64MSB 0xa6  /* word64 MSB @dtpmod(S + A) */\n#define R_IA_64_DTPMOD64LSB 0xa7  /* word64 LSB @dtpmod(S + A) */\n#define R_IA_64_LTOFF_DTPMOD22  0xaa  /* imm22  @ltoff(@dtpmod(S+A)) */\n#define R_IA_64_DTPREL14  0xb1  /* imm14  @dtprel(S + A) */\n#define R_IA_64_DTPREL22  0xb2  /* imm22  @dtprel(S + A) */\n#define R_IA_64_DTPREL64I 0xb3  /* imm64  @dtprel(S + A) */\n#define R_IA_64_DTPREL32MSB 0xb4  /* word32 MSB @dtprel(S + A) */\n#define R_IA_64_DTPREL32LSB 0xb5  /* word32 LSB @dtprel(S + A) */\n#define R_IA_64_DTPREL64MSB 0xb6  /* word64 MSB @dtprel(S + A) */\n#define R_IA_64_DTPREL64LSB 0xb7  /* word64 LSB @dtprel(S + A) */\n#define R_IA_64_LTOFF_DTPREL22  0xba  /* imm22  @ltoff(@dtprel(S+A)) */\n\n#define R_MIPS_NONE 0 /* No reloc */\n#define R_MIPS_16 1 /* Direct 16 bit */\n#define R_MIPS_32 2 /* Direct 32 bit */\n#define R_MIPS_REL32  3 /* PC relative 32 bit */\n#define R_MIPS_26 4 /* Direct 26 bit shifted */\n#define R_MIPS_HI16 5 /* High 16 bit */\n#define R_MIPS_LO16 6 /* Low 16 bit */\n#define R_MIPS_GPREL16  7 /* GP relative 16 bit */\n#define R_MIPS_LITERAL  8 /* 16 bit literal entry */\n#define R_MIPS_GOT16  9 /* 16 bit GOT entry */\n#define R_MIPS_PC16 10  /* PC relative 16 bit */\n#define R_MIPS_CALL16 11  /* 16 bit GOT entry for function */\n#define R_MIPS_GPREL32  12  /* GP relative 32 bit */\n#define R_MIPS_64 18  /* Direct 64 bit */\n#define R_MIPS_GOT_DISP 19\n#define R_MIPS_GOT_PAGE 20\n#define R_MIPS_GOT_OFST 21\n#define R_MIPS_GOT_HI16 22  /* GOT HI 16 bit */\n#define R_MIPS_GOT_LO16 23  /* GOT LO 16 bit */\n#define R_MIPS_SUB  24\n#define R_MIPS_CALLHI16 30  /* upper 16 bit GOT entry for function */\n#define R_MIPS_CALLLO16 31  /* lower 16 bit GOT entry for function */\n#define R_MIPS_JALR 37\n#define R_MIPS_TLS_GD 42\n#define R_MIPS_COPY 126\n#define R_MIPS_JUMP_SLOT  127\n\n#define R_PPC_NONE    0 /* No relocation. */\n#define R_PPC_ADDR32    1\n#define R_PPC_ADDR24    2\n#define R_PPC_ADDR16    3\n#define R_PPC_ADDR16_LO   4\n#define R_PPC_ADDR16_HI   5\n#define R_PPC_ADDR16_HA   6\n#define R_PPC_ADDR14    7\n#define R_PPC_ADDR14_BRTAKEN  8\n#define R_PPC_ADDR14_BRNTAKEN 9\n#define R_PPC_REL24   10\n#define R_PPC_REL14   11\n#define R_PPC_REL14_BRTAKEN 12\n#define R_PPC_REL14_BRNTAKEN  13\n#define R_PPC_GOT16   14\n#define R_PPC_GOT16_LO    15\n#define R_PPC_GOT16_HI    16\n#define R_PPC_GOT16_HA    17\n#define R_PPC_PLTREL24    18\n#define R_PPC_COPY    19\n#define R_PPC_GLOB_DAT    20\n#define R_PPC_JMP_SLOT    21\n#define R_PPC_RELATIVE    22\n#define R_PPC_LOCAL24PC   23\n#define R_PPC_UADDR32   24\n#define R_PPC_UADDR16   25\n#define R_PPC_REL32   26\n#define R_PPC_PLT32   27\n#define R_PPC_PLTREL32    28\n#define R_PPC_PLT16_LO    29\n#define R_PPC_PLT16_HI    30\n#define R_PPC_PLT16_HA    31\n#define R_PPC_SDAREL16    32\n#define R_PPC_SECTOFF   33\n#define R_PPC_SECTOFF_LO  34\n#define R_PPC_SECTOFF_HI  35\n#define R_PPC_SECTOFF_HA  36\n\n/*\n * 64-bit relocations\n */\n#define R_PPC64_ADDR64    38\n#define R_PPC64_ADDR16_HIGHER 39\n#define R_PPC64_ADDR16_HIGHERA  40\n#define R_PPC64_ADDR16_HIGHEST  41\n#define R_PPC64_ADDR16_HIGHESTA 42\n#define R_PPC64_UADDR64   43\n#define R_PPC64_REL64   44\n#define R_PPC64_PLT64   45\n#define R_PPC64_PLTREL64  46\n#define R_PPC64_TOC16   47\n#define R_PPC64_TOC16_LO  48\n#define R_PPC64_TOC16_HI  49\n#define R_PPC64_TOC16_HA  50\n#define R_PPC64_TOC   51\n#define R_PPC64_DTPMOD64  68\n#define R_PPC64_TPREL64   73\n#define R_PPC64_DTPREL64  78\n\n/*\n * TLS relocations\n */\n#define R_PPC_TLS   67\n#define R_PPC_DTPMOD32    68\n#define R_PPC_TPREL16   69\n#define R_PPC_TPREL16_LO  70\n#define R_PPC_TPREL16_HI  71\n#define R_PPC_TPREL16_HA  72\n#define R_PPC_TPREL32   73\n#define R_PPC_DTPREL16    74\n#define R_PPC_DTPREL16_LO 75\n#define R_PPC_DTPREL16_HI 76\n#define R_PPC_DTPREL16_HA 77\n#define R_PPC_DTPREL32    78\n#define R_PPC_GOT_TLSGD16 79\n#define R_PPC_GOT_TLSGD16_LO  80\n#define R_PPC_GOT_TLSGD16_HI  81\n#define R_PPC_GOT_TLSGD16_HA  82\n#define R_PPC_GOT_TLSLD16 83\n#define R_PPC_GOT_TLSLD16_LO  84\n#define R_PPC_GOT_TLSLD16_HI  85\n#define R_PPC_GOT_TLSLD16_HA  86\n#define R_PPC_GOT_TPREL16 87\n#define R_PPC_GOT_TPREL16_LO  88\n#define R_PPC_GOT_TPREL16_HI  89\n#define R_PPC_GOT_TPREL16_HA  90\n\n/*\n * The remaining relocs are from the Embedded ELF ABI, and are not in the\n *  SVR4 ELF ABI.\n */\n\n#define R_PPC_EMB_NADDR32 101\n#define R_PPC_EMB_NADDR16 102\n#define R_PPC_EMB_NADDR16_LO  103\n#define R_PPC_EMB_NADDR16_HI  104\n#define R_PPC_EMB_NADDR16_HA  105\n#define R_PPC_EMB_SDAI16  106\n#define R_PPC_EMB_SDA2I16 107\n#define R_PPC_EMB_SDA2REL 108\n#define R_PPC_EMB_SDA21   109\n#define R_PPC_EMB_MRKREF  110\n#define R_PPC_EMB_RELSEC16  111\n#define R_PPC_EMB_RELST_LO  112\n#define R_PPC_EMB_RELST_HI  113\n#define R_PPC_EMB_RELST_HA  114\n#define R_PPC_EMB_BIT_FLD 115\n#define R_PPC_EMB_RELSDA  116\n\n/*\n * RISC-V relocation types.\n */\n\n/* Relocation types used by the dynamic linker. */\n#define R_RISCV_NONE    0\n#define R_RISCV_32    1\n#define R_RISCV_64    2\n#define R_RISCV_RELATIVE  3\n#define R_RISCV_COPY    4\n#define R_RISCV_JUMP_SLOT 5\n#define R_RISCV_TLS_DTPMOD32  6\n#define R_RISCV_TLS_DTPMOD64  7\n#define R_RISCV_TLS_DTPREL32  8\n#define R_RISCV_TLS_DTPREL64  9\n#define R_RISCV_TLS_TPREL32 10\n#define R_RISCV_TLS_TPREL64 11\n\n/* Relocation types not used by the dynamic linker. */\n#define R_RISCV_BRANCH    16\n#define R_RISCV_JAL   17\n#define R_RISCV_CALL    18\n#define R_RISCV_CALL_PLT  19\n#define R_RISCV_GOT_HI20  20\n#define R_RISCV_TLS_GOT_HI20  21\n#define R_RISCV_TLS_GD_HI20 22\n#define R_RISCV_PCREL_HI20  23\n#define R_RISCV_PCREL_LO12_I  24\n#define R_RISCV_PCREL_LO12_S  25\n#define R_RISCV_HI20    26\n#define R_RISCV_LO12_I    27\n#define R_RISCV_LO12_S    28\n#define R_RISCV_TPREL_HI20  29\n#define R_RISCV_TPREL_LO12_I  30\n#define R_RISCV_TPREL_LO12_S  31\n#define R_RISCV_TPREL_ADD 32\n#define R_RISCV_ADD8    33\n#define R_RISCV_ADD16   34\n#define R_RISCV_ADD32   35\n#define R_RISCV_ADD64   36\n#define R_RISCV_SUB8    37\n#define R_RISCV_SUB16   38\n#define R_RISCV_SUB32   39\n#define R_RISCV_SUB64   40\n#define R_RISCV_GNU_VTINHERIT 41\n#define R_RISCV_GNU_VTENTRY 42\n#define R_RISCV_ALIGN   43\n#define R_RISCV_RVC_BRANCH  44\n#define R_RISCV_RVC_JUMP  45\n\n#define R_SPARC_NONE    0\n#define R_SPARC_8   1\n#define R_SPARC_16    2\n#define R_SPARC_32    3\n#define R_SPARC_DISP8   4\n#define R_SPARC_DISP16    5\n#define R_SPARC_DISP32    6\n#define R_SPARC_WDISP30   7\n#define R_SPARC_WDISP22   8\n#define R_SPARC_HI22    9\n#define R_SPARC_22    10\n#define R_SPARC_13    11\n#define R_SPARC_LO10    12\n#define R_SPARC_GOT10   13\n#define R_SPARC_GOT13   14\n#define R_SPARC_GOT22   15\n#define R_SPARC_PC10    16\n#define R_SPARC_PC22    17\n#define R_SPARC_WPLT30    18\n#define R_SPARC_COPY    19\n#define R_SPARC_GLOB_DAT  20\n#define R_SPARC_JMP_SLOT  21\n#define R_SPARC_RELATIVE  22\n#define R_SPARC_UA32    23\n#define R_SPARC_PLT32   24\n#define R_SPARC_HIPLT22   25\n#define R_SPARC_LOPLT10   26\n#define R_SPARC_PCPLT32   27\n#define R_SPARC_PCPLT22   28\n#define R_SPARC_PCPLT10   29\n#define R_SPARC_10    30\n#define R_SPARC_11    31\n#define R_SPARC_64    32\n#define R_SPARC_OLO10   33\n#define R_SPARC_HH22    34\n#define R_SPARC_HM10    35\n#define R_SPARC_LM22    36\n#define R_SPARC_PC_HH22   37\n#define R_SPARC_PC_HM10   38\n#define R_SPARC_PC_LM22   39\n#define R_SPARC_WDISP16   40\n#define R_SPARC_WDISP19   41\n#define R_SPARC_GLOB_JMP  42\n#define R_SPARC_7   43\n#define R_SPARC_5   44\n#define R_SPARC_6   45\n#define R_SPARC_DISP64    46\n#define R_SPARC_PLT64   47\n#define R_SPARC_HIX22   48\n#define R_SPARC_LOX10   49\n#define R_SPARC_H44   50\n#define R_SPARC_M44   51\n#define R_SPARC_L44   52\n#define R_SPARC_REGISTER  53\n#define R_SPARC_UA64    54\n#define R_SPARC_UA16    55\n#define R_SPARC_TLS_GD_HI22 56\n#define R_SPARC_TLS_GD_LO10 57\n#define R_SPARC_TLS_GD_ADD  58\n#define R_SPARC_TLS_GD_CALL 59\n#define R_SPARC_TLS_LDM_HI22  60\n#define R_SPARC_TLS_LDM_LO10  61\n#define R_SPARC_TLS_LDM_ADD 62\n#define R_SPARC_TLS_LDM_CALL  63\n#define R_SPARC_TLS_LDO_HIX22 64\n#define R_SPARC_TLS_LDO_LOX10 65\n#define R_SPARC_TLS_LDO_ADD 66\n#define R_SPARC_TLS_IE_HI22 67\n#define R_SPARC_TLS_IE_LO10 68\n#define R_SPARC_TLS_IE_LD 69\n#define R_SPARC_TLS_IE_LDX  70\n#define R_SPARC_TLS_IE_ADD  71\n#define R_SPARC_TLS_LE_HIX22  72\n#define R_SPARC_TLS_LE_LOX10  73\n#define R_SPARC_TLS_DTPMOD32  74\n#define R_SPARC_TLS_DTPMOD64  75\n#define R_SPARC_TLS_DTPOFF32  76\n#define R_SPARC_TLS_DTPOFF64  77\n#define R_SPARC_TLS_TPOFF32 78\n#define R_SPARC_TLS_TPOFF64 79\n\n#define R_X86_64_NONE   0 /* No relocation. */\n#define R_X86_64_64   1 /* Add 64 bit symbol value. */\n#define R_X86_64_PC32   2 /* PC-relative 32 bit signed sym value. */\n#define R_X86_64_GOT32    3 /* PC-relative 32 bit GOT offset. */\n#define R_X86_64_PLT32    4 /* PC-relative 32 bit PLT offset. */\n#define R_X86_64_COPY   5 /* Copy data from shared object. */\n#define R_X86_64_GLOB_DAT 6 /* Set GOT entry to data address. */\n#define R_X86_64_JMP_SLOT 7 /* Set GOT entry to code address. */\n#define R_X86_64_RELATIVE 8 /* Add load address of shared object. */\n#define R_X86_64_GOTPCREL 9 /* Add 32 bit signed pcrel offset to GOT. */\n#define R_X86_64_32   10  /* Add 32 bit zero extended symbol value */\n#define R_X86_64_32S    11  /* Add 32 bit sign extended symbol value */\n#define R_X86_64_16   12  /* Add 16 bit zero extended symbol value */\n#define R_X86_64_PC16   13  /* Add 16 bit signed extended pc relative symbol value */\n#define R_X86_64_8    14  /* Add 8 bit zero extended symbol value */\n#define R_X86_64_PC8    15  /* Add 8 bit signed extended pc relative symbol value */\n#define R_X86_64_DTPMOD64 16  /* ID of module containing symbol */\n#define R_X86_64_DTPOFF64 17  /* Offset in TLS block */\n#define R_X86_64_TPOFF64  18  /* Offset in static TLS block */\n#define R_X86_64_TLSGD    19  /* PC relative offset to GD GOT entry */\n#define R_X86_64_TLSLD    20  /* PC relative offset to LD GOT entry */\n#define R_X86_64_DTPOFF32 21  /* Offset in TLS block */\n#define R_X86_64_GOTTPOFF 22  /* PC relative offset to IE GOT entry */\n#define R_X86_64_TPOFF32  23  /* Offset in static TLS block */\n#define R_X86_64_PC64   24  /* PC-relative 64 bit signed sym value. */\n#define R_X86_64_GOTOFF64 25\n#define R_X86_64_GOTPC32  26\n#define R_X86_64_GOT64    27\n#define R_X86_64_GOTPCREL64 28\n#define R_X86_64_GOTPC64  29\n#define R_X86_64_GOTPLT64 30\n#define R_X86_64_PLTOFF64 31\n#define R_X86_64_SIZE32   32\n#define R_X86_64_SIZE64   33\n#define R_X86_64_GOTPC32_TLSDESC 34\n#define R_X86_64_TLSDESC_CALL 35\n#define R_X86_64_TLSDESC  36\n#define R_X86_64_IRELATIVE  37\n\n\n#endif /* !_SYS_ELF_COMMON_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/group__KNOBS.html": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/xhtml;charset=UTF-8\"/>\n<title>Pin: Command Line Switches</title>\n<link href=\"tabs.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<link href=\"search/search.css\" rel=\"stylesheet\" type=\"text/css\"/>\n<script type=\"text/javascript\" src=\"search/search.js\"></script>\n<link href=\"doxygen.css\" rel=\"stylesheet\" type=\"text/css\"/>\n</head>\n<body onload='searchBox.OnSelectItem(0);'>\n<!-- Generated by Doxygen 1.7.4 -->\n<script type=\"text/javascript\"><!--\nvar searchBox = new SearchBox(\"searchBox\", \"search\",false,'Search');\n--></script>\n<div id=\"top\">\n<div id=\"titlearea\">\n<table cellspacing=\"0\" cellpadding=\"0\">\n <tbody>\n <tr style=\"height: 56px;\">\n  <td style=\"padding-left: 0.5em;\">\n   <div id=\"projectname\">Pin</div>\n  </td>\n </tr>\n </tbody>\n</table>\n</div>\n  <div id=\"navrow1\" class=\"tabs\">\n    <ul class=\"tablist\">\n      <li><a href=\"index.html\"><span>Main&#160;Page</span></a></li>\n      <li><a href=\"modules.html\"><span>Modules</span></a></li>\n      <li><a href=\"namespaces.html\"><span>Namespaces</span></a></li>\n      <li><a href=\"annotated.html\"><span>Classes</span></a></li>\n      <li id=\"searchli\">\n        <div id=\"MSearchBox\" class=\"MSearchBoxInactive\">\n        <span class=\"left\">\n          <img id=\"MSearchSelect\" src=\"search/mag_sel.png\"\n               onmouseover=\"return searchBox.OnSearchSelectShow()\"\n               onmouseout=\"return searchBox.OnSearchSelectHide()\"\n               alt=\"\"/>\n          <input type=\"text\" id=\"MSearchField\" value=\"Search\" accesskey=\"S\"\n               onfocus=\"searchBox.OnSearchFieldFocus(true)\" \n               onblur=\"searchBox.OnSearchFieldFocus(false)\" \n               onkeyup=\"searchBox.OnSearchFieldChange(event)\"/>\n          </span><span class=\"right\">\n            <a id=\"MSearchClose\" href=\"javascript:searchBox.CloseResultsWindow()\"><img id=\"MSearchCloseImg\" border=\"0\" src=\"search/close.png\" alt=\"\"/></a>\n          </span>\n        </div>\n      </li>\n    </ul>\n  </div>\n</div>\n<div class=\"header\">\n  <div class=\"headertitle\">\n<div class=\"title\">Command Line Switches</div>  </div>\n</div>\n<div class=\"contents\">\n<table class=\"memberdecls\">\n</table>\n<p>This section describes the command line switches that are currently supported by Pin.</p>\n<p>Pin switches should appear after the pin command, but before the -t &lt;tool&gt; option. The following Pin switches are supported:</p>\n<table  frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-follow_execv </td><td>Execute all processes spawned by the execv class system calls with Pin.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pause_tool &lt;n&gt; </td><td>Pause and print the PID so the debugger can be attached after the tool is loaded. Processing will resume after \"n\" seconds.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pin.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-error_file </td><td>Indicates the path and name of the error file. The default path is the current working directory. If an error file is specified, all errors will be written to the error file, and will not be displayed on the console. If an error file is not specified, no error file will be created. The error file is designed to be parsed by tools that layer on top of Pin. See <a class=\"el\" href=\"group__ERROR__FILE__BASIC.html\">Pin Error Reporting Support</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_error_file </td><td>Appends the pid to the error file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-injection &lt;mode&gt; </td><td>Where &lt;mode&gt; is one of dynamic, self, child, parent. UNIX-only. See <a class=\"el\" href=\"index.html#INJECTION\">Injection</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-inline </td><td>Inline simple analysis routines.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-log_inline </td><td>Report which analysis routines have been inlined in the pin.log file.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-cc_memory_size &lt;n&gt; </td><td>Max (in bytes) code cache size (0==unlimited, default). Must be a multiple of the code cache block size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pid &lt;pid #&gt; </td><td>Attach Pin and the Pintool to an already running executable with the given process id.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_range </td><td>Restrict Pin to a memory range, 0x80000000:0x90000000 or size: 0:0x10000000.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-restrict_memory </td><td>Prevent PIN's dynamic loader from using these memory regions, 0x10000000:0x20000000   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-pin_memory_size </td><td>Limit the number of bytes that can be dynamically allocated by PIN and PIN tool Note that the number of bytes allocated by PIN is defined by the total number of memory pages allocated by PIN multiplied by the page size   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-tool_load_option </td><td>Load the tool with additional flags. Currently supported flags are:<br/>\n <b>deepbind:</b> (Linux only) Load the tool with the RTLD_DEEPBIND flag to make it a self-contained library. For more information see the dlopen man pages.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t &lt;toolname&gt; </td><td>Specify the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-t64 &lt;64-bit toolname&gt; </td><td>Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>. <br/>\n <b>Important</b>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p32 &lt;toolname&gt; </td><td>Specify Pin binary for IA-32 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-p64 &lt;toolname&gt; </td><td>Specify Pin binary for Intel(R) 64 architecture. See <a class=\"el\" href=\"index.html#MIXED-MODE\">Instrumenting Applications on Intel(R) 64 Architectures</a>.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_support [1][0] </td><td>Enable (1) or disable (0) support for self-modifying code (SMC) in the application. This option is enabled by default.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-smc_strict [0][1] </td><td>Enable (1) or disable (0) support for SMC inside basic blocks. By default (0), Pin assumes that basic blocks do not modify their own code.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG\"></a> -appdebug  </td><td>Debug the application, stopping in the debugger as soon as the application is launched.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ENABLE\"></a> -appdebug_enable  </td><td>Enable application level debugger support, but do not stop when the application is launched. Instead, you can connect a debugger after launch.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_SILENT\"></a> -appdebug_silent  </td><td>When application debugging is enabled, Pin normally prints a message telling how to connect an external debugger. This knob disables the message. Pin never prints this message when -appdebug_connection is specified.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_EXCLUDE\"></a> -appdebug_exclude  </td><td>When application debugging and -follow_execv are both specified, the default behavior is to enable debugging on all child processes. This knob, which is repeatable, specifies an application name for which debugging is disabled. Debugging is disabled for a process if it's argv[0] value matches one of the -appdebug_exclude names.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_ALLOW_REMOTE\"></a> -appdebug_allow_remote  </td><td>When application debugging is enabled, the default behavior requires the debugger to run on the same system as Pin. This knob allows Pin to connect to an external debugger that runs on a remote system. This knob is ignored when -appdebug_connection is specified because -appdebug_connection explicitly specifies the machine on which the debugger runs.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td><a class=\"anchor\" id=\"SWITCH_APPDEBUG_CONNECTION\"></a> -appdebug_connection  </td><td>When application debugging is enabled, Pin's default behavior is to open a TCP port and wait for a debugger to connect. This knob reverses the roles; the debugger opens a TCP port and waits for Pin to connect to the port specified in this knob. The format of the knob value should be \"[ip]:port\". If the \"ip\" address is specified, it should be in dot-decimal notation. If \"ip\" is omitted, Pin connects to the specified port on the local machine. The port number should be specified in decimal. Note that this knob is never used when debugging with GDB.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-detach_reattach </td><td>Allow detach and reattach in probe mode. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-debug_instrumented_processes </td><td>Print message to allow debugger attach to instrumented processes. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks   </td></tr>\n</table>\n<p>Pin also supports the following tool switches. Tool switches should be placed after the tool name, but before the double dash (\"--\").</p>\n<table  frame=\"void\" rules=\"none\" cellspacing=\"10\">\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-logfile </td><td>Indicates the path and name of the log file. The default path is the current working directory. The default name is pintool.log.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-unique_logfile </td><td>Appends the pid to the log file name.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info &lt;module_name&gt; </td><td>Discard line information for specific module. Module name should be a short name without path, and not a symbolic link   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-discard_line_info_all </td><td>Discard line information for all modules.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-help </td><td>Print the help message.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-support_jit_api </td><td>Enables managed platforms support.  </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-short_name </td><td>Use the shortest name for the RTN. Names with version substrings are preferred over the same name without the substring.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-symbol_path &lt;list of paths&gt; </td><td>Specifies list of paths separated with semicolons that are searched to find symbol and line information. The list is searched when necessary after default search algorithm is applied. Default list is empty. Windows* only.   </td></tr>\n<tr valign=\"top\" align=\"left\">\n<td></td><td>-slow_asserts </td><td>Perform expensive sanity checks. Recommended to be used in development and testing phase.   </td></tr>\n</table>\n<p>If you want to add your own command line options to your tool, please see <a class=\"el\" href=\"group__KNOB__API.html\">KNOBS</a>. </p>\n</div>\n<!-- window showing the filter options -->\n<div id=\"MSearchSelectWindow\"\n     onmouseover=\"return searchBox.OnSearchSelectShow()\"\n     onmouseout=\"return searchBox.OnSearchSelectHide()\"\n     onkeydown=\"return searchBox.OnSearchSelectKey(event)\">\n<a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(0)\"><span class=\"SelectionMark\">&#160;</span>All</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(1)\"><span class=\"SelectionMark\">&#160;</span>Classes</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(2)\"><span class=\"SelectionMark\">&#160;</span>Namespaces</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(3)\"><span class=\"SelectionMark\">&#160;</span>Functions</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(4)\"><span class=\"SelectionMark\">&#160;</span>Variables</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(5)\"><span class=\"SelectionMark\">&#160;</span>Typedefs</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(6)\"><span class=\"SelectionMark\">&#160;</span>Enumerations</a><a class=\"SelectItem\" href=\"javascript:void(0)\" onclick=\"searchBox.OnSelectItem(7)\"><span class=\"SelectionMark\">&#160;</span>Enumerator</a></div>\n\n<!-- iframe showing the search results (closed by default) -->\n<div id=\"MSearchResultsWindow\">\n<iframe src=\"javascript:void(0)\" frameborder=\"0\" \n        name=\"MSearchResults\" id=\"MSearchResults\">\n</iframe>\n</div>\n\n<hr class=\"footer\"/><address class=\"footer\"><small>Generated on Tue Jul 23 2019 02:56:02 for Pin by&#160;\n<a href=\"http://www.doxygen.org/index.html\">\n<img class=\"footer\" src=\"doxygen.png\" alt=\"doxygen\"/></a> 1.7.4 </small></address>\n</body>\n</html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/pin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/intel64/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/probefastcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/probefastcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/probestdcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/probestdcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Tests/winapp_runs_pin_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/source/tools/Tests/winapp_runs_pin_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/ia32/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/xed-intel64/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/xed-intel64/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/intel64/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/components/lib/ia32/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/crt/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/xed-ia32/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/extras/xed-ia32/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.11-nbph5bpwoneezdlbvgvgz4tsaagrh7vg/spack-src/doc/html/search/search_l.png"
    ],
    "total_files": 4339
}