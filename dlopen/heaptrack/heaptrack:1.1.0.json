{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/.travis.yml": "language: cpp\ncompiler: gcc\nsudo: require\ndist: trusty\n\nbefore_install:\n  - sudo add-apt-repository ppa:beineri/opt-qt593-trusty -y\n  - sudo apt-get update -qq\n\ninstall:\n  - sudo apt-get -y install qt59base qt59svg qt59x11extras libdwarf-dev libboost-iostreams-dev libboost-program-options-dev\n  - source /opt/qt*/bin/qt*-env.sh\n  - git clone git://anongit.kde.org/extra-cmake-modules\n  - cd extra-cmake-modules\n  - mkdir build\n  - cd build\n  - cmake ..\n  - make\n  - sudo make install\n  - cd ../..\n  - # Precompiled KF5\n  - wget -c \"https://github.com/chigraph/precompiled-kf5-linux/releases/download/precompiled/kf5-gcc6-linux64-release.tar.xz\"\n  - tar xf kf5-gcc6-linux64-release.tar.xz\n  - sudo cp -Rf root/kf5-release/* /opt/qt*/\n  - # Precompiled kdiagram\n  - wget -c \"https://swanson.kdab.com/owncloud/index.php/s/bZmRRXAKd54ROKd/download\" -O kdiagram.tar.bz2\n  - tar xf kdiagram.tar.bz2\n  - sudo cp -Rf kdiagram-*/opt/qt* /opt/\n  - # Precompiled version of libunwind in newer version (1.)2\n  - wget -c \"https://swanson.kdab.com/owncloud/index.php/s/ZETvRRZ7J5Nllo5/download\" -O libunwind.tar.bz2\n  - tar xf libunwind.tar.bz2\n  - sudo cp -Rf libunwind-*/usr/* /usr/\n  - # Get AppImage tools\n  - wget -c \"https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage\"\n  - chmod a+x linuxdeployqt*.AppImage\n  - sudo mv linuxdeployqt*.AppImage /usr/bin/linuxdeployqt\n  - wget -c \"https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage\"\n  - chmod a+x appimagetool-*.AppImage\n  - sudo mv appimagetool-*.AppImage /usr/bin/appimagetool\n\nscript:\n  - set -e # Exit immediately if anything fails\n  - mkdir build\n  - cd build\n  - cmake .. -DCMAKE_INSTALL_PREFIX=/usr\n  - make -j$(nproc)\n  - make DESTDIR=appdir install\n  - unset QTDIR; unset QT_PLUGIN_PATH ; unset LD_LIBRARY_PATH\n  - export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu # make sure this path is known so all Qt/KF5 libs are found\n  - linuxdeployqt ./appdir/usr/share/applications/org.kde.heaptrack.desktop -executable=./appdir/usr/lib/heaptrack/libexec/heaptrack_interpret -executable=./appdir/usr/lib/heaptrack/libheaptrack_preload.so -executable=./appdir/usr/lib/heaptrack/libheaptrack_inject.so -bundle-non-qt-libs\n  - # Ensure we prefer the bundled libs also when calling dlopen, cf.: https://github.com/KDAB/hotspot/issues/89\n  - mv ./appdir/usr/bin/heaptrack_gui{,_bin}\n  - echo -e '#!/bin/bash\\nf=\"$(readlink -f \"${0}\")\"\\nd=\"$(dirname \"$f\")\"\\nLD_LIBRARY_PATH=\"$d/../lib:$LD_LIBRARY_PATH\" \"$d/heaptrack_gui_bin\" \"$@\"' > ./appdir/usr/bin/heaptrack_gui\n  - chmod +x ./appdir/usr/bin/heaptrack_gui\n  - # use the shell script as AppRun entry point\n  - rm ./appdir/AppRun\n  - ln -sr ./appdir/usr/bin/heaptrack ./appdir/AppRun\n  - # Actually create the final image\n  - appimagetool ./appdir/\n  - curl --upload-file ./Heaptrack-*.AppImage https://transfer.sh/heaptrack-git.$(git rev-parse --short HEAD)-x86_64.AppImage\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/libheaptrack.cpp": "/*\n * Copyright 2014-2017 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n/**\n * @file libheaptrack.cpp\n *\n * @brief Collect raw heaptrack data by overloading heap allocation functions.\n */\n\n#include \"libheaptrack.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <fcntl.h>\n#include <link.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdio_ext.h>\n#include <sys/file.h>\n#include <syscall.h>\n\n#include <atomic>\n#include <cinttypes>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <thread>\n#include <unordered_set>\n\n#include <boost/algorithm/string/replace.hpp>\n\n#include \"tracetree.h\"\n#include \"util/config.h\"\n#include \"util/libunwind_config.h\"\n#include \"util/linewriter.h\"\n\n/**\n * uncomment this to get extended debug code for known pointers\n * there are still some malloc functions I'm missing apparently,\n * related to TLS and such I guess\n */\n// #define DEBUG_MALLOC_PTRS\n\nusing namespace std;\n\nnamespace {\n\nusing clock = chrono::steady_clock;\nchrono::time_point<clock> startTime()\n{\n    static const chrono::time_point<clock> s_start = clock::now();\n    return s_start;\n}\n\nchrono::milliseconds elapsedTime()\n{\n    return chrono::duration_cast<chrono::milliseconds>(clock::now() - startTime());\n}\n\n__pid_t gettid()\n{\n    return syscall(SYS_gettid);\n}\n\n/**\n * A per-thread handle guard to prevent infinite recursion, which should be\n * acquired before doing any special symbol handling.\n */\nstruct RecursionGuard\n{\n    RecursionGuard()\n        : wasLocked(isActive)\n    {\n        isActive = true;\n    }\n\n    ~RecursionGuard()\n    {\n        isActive = wasLocked;\n    }\n\n    const bool wasLocked;\n    static thread_local bool isActive;\n};\n\nthread_local bool RecursionGuard::isActive = false;\n\nenum DebugVerbosity\n{\n    NoDebugOutput,\n    MinimalOutput,\n    VerboseOutput,\n    VeryVerboseOutput,\n};\n\n// change this to add more debug output to stderr\nconstexpr const DebugVerbosity s_debugVerbosity = NoDebugOutput;\n\n/**\n * Call this to optionally show debug information but give the compiler\n * a hand in removing it all if debug output is disabled.\n */\ntemplate <DebugVerbosity debugLevel, typename... Args>\ninline void debugLog(const char fmt[], Args... args)\n{\n    if (debugLevel <= s_debugVerbosity) {\n        RecursionGuard guard;\n        flockfile(stderr);\n        fprintf(stderr, \"heaptrack debug(%d) [%d:%d]@%lu \", static_cast<int>(debugLevel), getpid(), gettid(),\n                elapsedTime().count());\n        fprintf(stderr, fmt, args...);\n        fputc('\\n', stderr);\n        funlockfile(stderr);\n    }\n}\n\nvoid printBacktrace()\n{\n    if (s_debugVerbosity == NoDebugOutput)\n        return;\n\n#if LIBUNWIND_HAS_UNW_GETCONTEXT && LIBUNWIND_HAS_UNW_INIT_LOCAL\n    RecursionGuard guard;\n\n    unw_context_t context;\n    unw_getcontext(&context);\n\n    unw_cursor_t cursor;\n    unw_init_local(&cursor, &context);\n\n    int frameNr = 0;\n    while (unw_step(&cursor)) {\n        ++frameNr;\n        unw_word_t ip = 0;\n        unw_get_reg(&cursor, UNW_REG_IP, &ip);\n\n        unw_word_t sp = 0;\n        unw_get_reg(&cursor, UNW_REG_SP, &sp);\n\n        char symbol[256] = {\"<unknown>\"};\n        unw_word_t offset = 0;\n        unw_get_proc_name(&cursor, symbol, sizeof(symbol), &offset);\n\n        fprintf(stderr, \"#%-2d 0x%016\" PRIxPTR \" sp=0x%016\" PRIxPTR \" %s + 0x%\" PRIxPTR \"\\n\", frameNr,\n                static_cast<uintptr_t>(ip), static_cast<uintptr_t>(sp), symbol, static_cast<uintptr_t>(offset));\n    }\n#endif\n}\n\n/**\n * Set to true in an atexit handler. In such conditions, the stop callback\n * will not be called.\n */\natomic<bool> s_atexit{false};\n\n/**\n * Set to true in heaptrack_stop, when s_atexit was not yet set. In such conditions,\n * we always fully unload and cleanup behind ourselves\n */\natomic<bool> s_forceCleanup{false};\n\nint createFile(const char* fileName)\n{\n    string outputFileName;\n    if (fileName) {\n        outputFileName.assign(fileName);\n    }\n\n    if (outputFileName == \"-\" || outputFileName == \"stdout\") {\n        debugLog<VerboseOutput>(\"%s\", \"will write to stdout\");\n        return fileno(stdout);\n    } else if (outputFileName == \"stderr\") {\n        debugLog<VerboseOutput>(\"%s\", \"will write to stderr\");\n        return fileno(stderr);\n    }\n\n    if (outputFileName.empty()) {\n        // env var might not be set when linked directly into an executable\n        outputFileName = \"heaptrack.$$\";\n    }\n\n    boost::replace_all(outputFileName, \"$$\", to_string(getpid()));\n\n    auto out = open(outputFileName.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC, 0644);\n    debugLog<VerboseOutput>(\"will write to %s/%p\\n\", outputFileName.c_str(), out);\n    // we do our own locking, this speeds up the writing significantly\n    if (out == -1) {\n        fprintf(stderr, \"ERROR: failed to open heaptrack output file %s: %s (%d)\\n\", outputFileName.c_str(),\n                strerror(errno), errno);\n    } else if (flock(out, LOCK_EX | LOCK_NB) != 0) {\n        fprintf(stderr, \"ERROR: failed to lock heaptrack output file %s: %s (%d)\\n\", outputFileName.c_str(),\n                strerror(errno), errno);\n        close(out);\n        return -1;\n    }\n\n    return out;\n}\n\n/**\n * Thread-Safe heaptrack API\n *\n * The only critical section in libheaptrack is the output of the data,\n * dl_iterate_phdr\n * calls, as well as initialization and shutdown.\n */\nclass HeapTrack\n{\npublic:\n    HeapTrack(const RecursionGuard& /*recursionGuard*/)\n    {\n        debugLog<VeryVerboseOutput>(\"%s\", \"acquiring lock\");\n        s_lock.lock();\n        debugLog<VeryVerboseOutput>(\"%s\", \"lock acquired\");\n    }\n\n    ~HeapTrack()\n    {\n        debugLog<VeryVerboseOutput>(\"%s\", \"releasing lock\");\n        s_lock.unlock();\n    }\n\n    void initialize(const char* fileName, heaptrack_callback_t initBeforeCallback,\n                    heaptrack_callback_initialized_t initAfterCallback, heaptrack_callback_t stopCallback)\n    {\n        debugLog<MinimalOutput>(\"initializing: %s\", fileName);\n        if (s_data) {\n            debugLog<MinimalOutput>(\"%s\", \"already initialized\");\n            return;\n        }\n\n        if (initBeforeCallback) {\n            debugLog<MinimalOutput>(\"%s\", \"calling initBeforeCallback\");\n            initBeforeCallback();\n            debugLog<MinimalOutput>(\"%s\", \"done calling initBeforeCallback\");\n        }\n\n        // do some once-only initializations\n        static once_flag once;\n        call_once(once, [] {\n            debugLog<MinimalOutput>(\"%s\", \"doing once-only initialization\");\n            // configure libunwind for better speed\n            if (unw_set_caching_policy(unw_local_addr_space, UNW_CACHE_PER_THREAD)) {\n                fprintf(stderr, \"WARNING: Failed to enable per-thread libunwind caching.\\n\");\n            }\n#if LIBUNWIND_HAS_UNW_SET_CACHE_SIZE\n            if (unw_set_cache_size(unw_local_addr_space, 1024, 0)) {\n                fprintf(stderr, \"WARNING: Failed to set libunwind cache size.\\n\");\n            }\n#endif\n\n            // do not trace forked child processes\n            // TODO: make this configurable\n            pthread_atfork(&prepare_fork, &parent_fork, &child_fork);\n\n            atexit([]() {\n                if (s_forceCleanup) {\n                    return;\n                }\n                debugLog<MinimalOutput>(\"%s\", \"atexit()\");\n                s_atexit.store(true);\n                heaptrack_stop();\n            });\n        });\n\n        const auto out = createFile(fileName);\n\n        if (out == -1) {\n            if (stopCallback) {\n                stopCallback();\n            }\n            return;\n        }\n\n        s_data = new LockedData(out, stopCallback);\n\n        writeVersion();\n        writeExe();\n        writeCommandLine();\n        writeSystemInfo();\n\n        if (initAfterCallback) {\n            debugLog<MinimalOutput>(\"%s\", \"calling initAfterCallback\");\n            initAfterCallback(s_data->out);\n            debugLog<MinimalOutput>(\"%s\", \"calling initAfterCallback done\");\n        }\n\n        debugLog<MinimalOutput>(\"%s\", \"initialization done\");\n    }\n\n    void shutdown()\n    {\n        if (!s_data) {\n            return;\n        }\n\n        debugLog<MinimalOutput>(\"%s\", \"shutdown()\");\n\n        writeTimestamp();\n        writeRSS();\n\n        s_data->out.flush();\n        s_data->out.close();\n\n        // NOTE: we leak heaptrack data on exit, intentionally\n        // This way, we can be sure to get all static deallocations.\n        if (!s_atexit || s_forceCleanup) {\n            delete s_data;\n            s_data = nullptr;\n        }\n\n        debugLog<MinimalOutput>(\"%s\", \"shutdown() done\");\n    }\n\n    void invalidateModuleCache()\n    {\n        if (!s_data) {\n            return;\n        }\n        s_data->moduleCacheDirty = true;\n    }\n\n    void writeTimestamp()\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n\n        auto elapsed = elapsedTime();\n\n        debugLog<VeryVerboseOutput>(\"writeTimestamp(%\" PRIx64 \")\", elapsed.count());\n\n        s_data->out.writeHexLine('c', static_cast<size_t>(elapsed.count()));\n    }\n\n    void writeRSS()\n    {\n        if (!s_data || !s_data->out.canWrite() || !s_data->procStatm) {\n            return;\n        }\n\n        // read RSS in pages from statm, then rewind for next read\n        size_t rss = 0;\n        if (fscanf(s_data->procStatm, \"%*x %zx\", &rss) != 1) {\n            fprintf(stderr, \"WARNING: Failed to read RSS value from /proc/self/statm.\\n\");\n            fclose(s_data->procStatm);\n            s_data->procStatm = nullptr;\n            return;\n        }\n        rewind(s_data->procStatm);\n        // TODO: compare to rusage.ru_maxrss (getrusage) to find \"real\" peak?\n        // TODO: use custom allocators with known page sizes to prevent tainting\n        //       the RSS numbers with heaptrack-internal data\n\n        s_data->out.writeHexLine('R', rss);\n    }\n\n    void writeVersion()\n    {\n        s_data->out.writeHexLine('v', static_cast<size_t>(HEAPTRACK_VERSION),\n                                 static_cast<size_t>(HEAPTRACK_FILE_FORMAT_VERSION));\n    }\n\n    void writeExe()\n    {\n        const int BUF_SIZE = 1023;\n        char buf[BUF_SIZE + 1];\n        ssize_t size = readlink(\"/proc/self/exe\", buf, BUF_SIZE);\n        if (size > 0 && size < BUF_SIZE) {\n            buf[size] = 0;\n            s_data->out.write(\"x %s\\n\", buf);\n        }\n    }\n\n    void writeCommandLine()\n    {\n        s_data->out.write(\"X\");\n        const int BUF_SIZE = 4096;\n        char buf[BUF_SIZE + 1];\n        auto fd = open(\"/proc/self/cmdline\", O_RDONLY);\n        int bytesRead = read(fd, buf, BUF_SIZE);\n        char* end = buf + bytesRead;\n        for (char* p = buf; p < end;) {\n            s_data->out.write(\" %s\", p);\n            while (*p++)\n                ; // skip until start of next 0-terminated section\n        }\n\n        close(fd);\n        s_data->out.write(\"\\n\");\n    }\n\n    void writeSystemInfo()\n    {\n        s_data->out.writeHexLine('I', static_cast<size_t>(sysconf(_SC_PAGESIZE)),\n                                 static_cast<size_t>(sysconf(_SC_PHYS_PAGES)));\n    }\n\n    void handleMalloc(void* ptr, size_t size, const Trace& trace)\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n        updateModuleCache();\n\n        const auto index = s_data->traceTree.index(\n            trace, [this](uintptr_t ip, uint32_t index) { return s_data->out.writeHexLine('t', ip, index); });\n\n#ifdef DEBUG_MALLOC_PTRS\n        auto it = s_data->known.find(ptr);\n        assert(it == s_data->known.end());\n        s_data->known.insert(ptr);\n#endif\n\n        s_data->out.writeHexLine('+', size, index, reinterpret_cast<uintptr_t>(ptr));\n    }\n\n    void handleFree(void* ptr)\n    {\n        if (!s_data || !s_data->out.canWrite()) {\n            return;\n        }\n\n#ifdef DEBUG_MALLOC_PTRS\n        auto it = s_data->known.find(ptr);\n        assert(it != s_data->known.end());\n        s_data->known.erase(it);\n#endif\n\n        s_data->out.writeHexLine('-', reinterpret_cast<uintptr_t>(ptr));\n    }\n\nprivate:\n    static int dl_iterate_phdr_callback(struct dl_phdr_info* info, size_t /*size*/, void* data)\n    {\n        auto heaptrack = reinterpret_cast<HeapTrack*>(data);\n        const char* fileName = info->dlpi_name;\n        if (!fileName || !fileName[0]) {\n            fileName = \"x\";\n        }\n\n        debugLog<VerboseOutput>(\"dlopen_notify_callback: %s %zx\", fileName, info->dlpi_addr);\n\n        if (!heaptrack->s_data->out.write(\"m %s %zx\", fileName, info->dlpi_addr)) {\n            return 1;\n        }\n\n        for (int i = 0; i < info->dlpi_phnum; i++) {\n            const auto& phdr = info->dlpi_phdr[i];\n            if (phdr.p_type == PT_LOAD) {\n                if (!heaptrack->s_data->out.write(\" %zx %zx\", phdr.p_vaddr, phdr.p_memsz)) {\n                    return 1;\n                }\n            }\n        }\n\n        if (!heaptrack->s_data->out.write(\"\\n\")) {\n            return 1;\n        }\n\n        return 0;\n    }\n\n    static void prepare_fork()\n    {\n        debugLog<MinimalOutput>(\"%s\", \"prepare_fork()\");\n        // don't do any custom malloc handling while inside fork\n        RecursionGuard::isActive = true;\n    }\n\n    static void parent_fork()\n    {\n        debugLog<MinimalOutput>(\"%s\", \"parent_fork()\");\n        // the parent process can now continue its custom malloc tracking\n        RecursionGuard::isActive = false;\n    }\n\n    static void child_fork()\n    {\n        debugLog<MinimalOutput>(\"%s\", \"child_fork()\");\n        // but the forked child process cleans up itself\n        // this is important to prevent two processes writing to the same file\n        s_data = nullptr;\n        RecursionGuard::isActive = true;\n    }\n\n    void updateModuleCache()\n    {\n        if (!s_data || !s_data->out.canWrite() || !s_data->moduleCacheDirty) {\n            return;\n        }\n        debugLog<MinimalOutput>(\"%s\", \"updateModuleCache()\");\n        if (!s_data->out.write(\"m -\\n\")) {\n            return;\n        }\n        dl_iterate_phdr(&dl_iterate_phdr_callback, this);\n        s_data->moduleCacheDirty = false;\n    }\n\n    void writeError()\n    {\n        debugLog<MinimalOutput>(\"write error %d/%s\", errno, strerror(errno));\n        printBacktrace();\n        shutdown();\n    }\n\n    struct LockCheckFailed{};\n\n    /**\n     * To prevent deadlocks on shutdown, we try to lock from the timer thread\n     * and throw an LockCheckFailed exception otherwise.\n     */\n    template <typename AdditionalLockCheck>\n    HeapTrack(AdditionalLockCheck lockCheck)\n    {\n        debugLog<VeryVerboseOutput>(\"%s\", \"trying to acquire lock\");\n        while (!s_lock.try_lock()) {\n            if (!lockCheck())\n                throw LockCheckFailed();\n            this_thread::sleep_for(chrono::microseconds(1));\n        }\n        debugLog<VeryVerboseOutput>(\"%s\", \"lock acquired\");\n    }\n\n    struct LockedData\n    {\n        LockedData(int out, heaptrack_callback_t stopCallback)\n            : out(out)\n            , stopCallback(stopCallback)\n        {\n\n            debugLog<MinimalOutput>(\"%s\", \"constructing LockedData\");\n            procStatm = fopen(\"/proc/self/statm\", \"r\");\n            if (!procStatm) {\n                fprintf(stderr, \"WARNING: Failed to open /proc/self/statm for reading: %s.\\n\", strerror(errno));\n            } else if (setvbuf(procStatm, nullptr, _IONBF, 0)) {\n                // disable buffering to ensure we read the latest values\n                fprintf(stderr, \"WARNING: Failed to disable buffering for reading of /proc/self/statm: %s.\\n\",\n                        strerror(errno));\n            }\n\n            // ensure this utility thread is not handling any signals\n            // our host application may assume only one specific thread\n            // will handle the threads, if that's not the case things\n            // seemingly break in non-obvious ways.\n            // see also: https://bugs.kde.org/show_bug.cgi?id=378494\n            sigset_t previousMask;\n            sigset_t newMask;\n            sigfillset(&newMask);\n            if (pthread_sigmask(SIG_SETMASK, &newMask, &previousMask) != 0) {\n                fprintf(stderr, \"WARNING: Failed to block signals, disabling timer thread.\\n\");\n                return;\n            }\n\n            // the mask we set above will be inherited by the thread that we spawn below\n            timerThread = thread([&]() {\n                RecursionGuard::isActive = true;\n                debugLog<MinimalOutput>(\"%s\", \"timer thread started\");\n\n                // now loop and repeatedly print the timestamp and RSS usage to the data stream\n                while (!stopTimerThread) {\n                    // TODO: make interval customizable\n                    this_thread::sleep_for(chrono::milliseconds(10));\n\n                    try {\n                        HeapTrack heaptrack([&] { return !stopTimerThread.load(); });\n                        heaptrack.writeTimestamp();\n                        heaptrack.writeRSS();\n                    } catch (LockCheckFailed) {\n                        break;\n                    }\n                }\n            });\n\n            // now restore the previous mask as if nothing ever happened\n            if (pthread_sigmask(SIG_SETMASK, &previousMask, nullptr) != 0) {\n                fprintf(stderr, \"WARNING: Failed to restore the signal mask.\\n\");\n            }\n        }\n\n        ~LockedData()\n        {\n            debugLog<MinimalOutput>(\"%s\", \"destroying LockedData\");\n            stopTimerThread = true;\n            if (timerThread.joinable()) {\n                try {\n                    timerThread.join();\n                } catch (std::system_error) {\n                }\n            }\n\n            out.close();\n\n            if (procStatm) {\n                fclose(procStatm);\n            }\n\n            if (stopCallback && (!s_atexit || s_forceCleanup)) {\n                stopCallback();\n            }\n            debugLog<MinimalOutput>(\"%s\", \"done destroying LockedData\");\n        }\n\n        LineWriter out;\n\n        /// /proc/self/statm file stream to read RSS value from\n        FILE* procStatm = nullptr;\n\n        /**\n         * Calls to dlopen/dlclose mark the cache as dirty.\n         * When this happened, all modules and their section addresses\n         * must be found again via dl_iterate_phdr before we output the\n         * next instruction pointer. Otherwise, heaptrack_interpret might\n         * encounter IPs of an unknown/invalid module.\n         */\n        bool moduleCacheDirty = true;\n\n        TraceTree traceTree;\n\n        atomic<bool> stopTimerThread{false};\n        thread timerThread;\n\n        heaptrack_callback_t stopCallback = nullptr;\n\n#ifdef DEBUG_MALLOC_PTRS\n        unordered_set<void*> known;\n#endif\n    };\n\n    static std::mutex s_lock;\n    static LockedData* s_data;\n};\n\nstd::mutex HeapTrack::s_lock;\nHeapTrack::LockedData* HeapTrack::s_data{nullptr};\n}\nextern \"C\" {\n\nvoid heaptrack_init(const char* outputFileName, heaptrack_callback_t initBeforeCallback,\n                    heaptrack_callback_initialized_t initAfterCallback, heaptrack_callback_t stopCallback)\n{\n    RecursionGuard guard;\n    // initialize\n    startTime();\n\n    debugLog<MinimalOutput>(\"heaptrack_init(%s)\", outputFileName);\n\n    HeapTrack heaptrack(guard);\n    heaptrack.initialize(outputFileName, initBeforeCallback, initAfterCallback, stopCallback);\n}\n\nvoid heaptrack_stop()\n{\n    RecursionGuard guard;\n\n    debugLog<MinimalOutput>(\"%s\", \"heaptrack_stop()\");\n\n    HeapTrack heaptrack(guard);\n\n    if (!s_atexit) {\n        s_forceCleanup.store(true);\n    }\n\n    heaptrack.shutdown();\n}\n\nvoid heaptrack_malloc(void* ptr, size_t size)\n{\n    if (ptr && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>(\"heaptrack_malloc(%p, %zu)\", ptr, size);\n\n        Trace trace;\n        trace.fill(2 + HEAPTRACK_DEBUG_BUILD);\n\n        HeapTrack heaptrack(guard);\n        heaptrack.handleMalloc(ptr, size, trace);\n    }\n}\n\nvoid heaptrack_free(void* ptr)\n{\n    if (ptr && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>(\"heaptrack_free(%p)\", ptr);\n\n        HeapTrack heaptrack(guard);\n        heaptrack.handleFree(ptr);\n    }\n}\n\nvoid heaptrack_realloc(void* ptr_in, size_t size, void* ptr_out)\n{\n    if (ptr_out && !RecursionGuard::isActive) {\n        RecursionGuard guard;\n\n        debugLog<VeryVerboseOutput>(\"heaptrack_realloc(%p, %zu, %p)\", ptr_in, size, ptr_out);\n\n        Trace trace;\n        trace.fill(2 + HEAPTRACK_DEBUG_BUILD);\n\n        HeapTrack heaptrack(guard);\n        if (ptr_in) {\n            heaptrack.handleFree(ptr_in);\n        }\n        heaptrack.handleMalloc(ptr_out, size, trace);\n    }\n}\n\nvoid heaptrack_invalidate_module_cache()\n{\n    RecursionGuard guard;\n\n    debugLog<VerboseOutput>(\"%s\", \"heaptrack_invalidate_module_cache()\");\n\n    HeapTrack heaptrack(guard);\n    heaptrack.invalidateModuleCache();\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/heaptrack_preload.cpp": "/*\n * Copyright 2014-2017 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"libheaptrack.h\"\n#include \"util/config.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <dlfcn.h>\n\n#include <atomic>\n#include <type_traits>\n\nusing namespace std;\n\n#if defined(_ISOC11_SOURCE)\n#define HAVE_ALIGNED_ALLOC 1\n#else\n#define HAVE_ALIGNED_ALLOC 0\n#endif\n\nextern \"C\" {\n__attribute__((weak)) void __libc_freeres();\n}\nnamespace __gnu_cxx {\n__attribute__((weak)) extern void __freeres();\n}\n\nnamespace {\n\nnamespace hooks {\n\ntemplate <typename Signature, typename Base>\nstruct hook\n{\n    Signature original = nullptr;\n\n    void init() noexcept\n    {\n        auto ret = dlsym(RTLD_NEXT, Base::identifier);\n        if (!ret) {\n            fprintf(stderr, \"Could not find original function %s\\n\", Base::identifier);\n            abort();\n        }\n        original = reinterpret_cast<Signature>(ret);\n    }\n\n    template <typename... Args>\n    auto operator()(Args... args) const noexcept -> decltype(original(args...))\n    {\n        return original(args...);\n    }\n\n    explicit operator bool() const noexcept\n    {\n        return original;\n    }\n};\n\n#define HOOK(name)                                                                                                     \\\n    struct name##_t : public hook<decltype(&::name), name##_t>                                                         \\\n    {                                                                                                                  \\\n        static constexpr const char* identifier = #name;                                                               \\\n    } name\n\nHOOK(malloc);\nHOOK(free);\nHOOK(calloc);\n#if HAVE_CFREE\nHOOK(cfree);\n#endif\nHOOK(realloc);\nHOOK(posix_memalign);\nHOOK(valloc);\n#if HAVE_ALIGNED_ALLOC\nHOOK(aligned_alloc);\n#endif\nHOOK(dlopen);\nHOOK(dlclose);\n\n/**\n * Dummy implementation, since the call to dlsym from findReal triggers a call\n * to calloc.\n *\n * This is only called at startup and will eventually be replaced by the\n * \"proper\" calloc implementation.\n */\nvoid* dummy_calloc(size_t num, size_t size) noexcept\n{\n    const size_t MAX_SIZE = 1024;\n    static char* buf[MAX_SIZE];\n    static size_t offset = 0;\n    if (!offset) {\n        memset(buf, 0, MAX_SIZE);\n    }\n    size_t oldOffset = offset;\n    offset += num * size;\n    if (offset >= MAX_SIZE) {\n        fprintf(stderr,\n                \"failed to initialize, dummy calloc buf size exhausted: \"\n                \"%zu requested, %zu available\\n\",\n                offset, MAX_SIZE);\n        abort();\n    }\n    return buf + oldOffset;\n}\n\nvoid init()\n{\n    atexit([]() {\n        // free internal libstdc++ resources\n        // see also Valgrind's `--run-cxx-freeres` option\n        if (&__gnu_cxx::__freeres) {\n            __gnu_cxx::__freeres();\n        }\n        // free internal libc resources, cf: https://bugs.kde.org/show_bug.cgi?id=378765\n        // see also Valgrind's `--run-libc-freeres` option\n        if (&__libc_freeres) {\n            __libc_freeres();\n        }\n    });\n    heaptrack_init(getenv(\"DUMP_HEAPTRACK_OUTPUT\"),\n                   [] {\n                       hooks::calloc.original = &dummy_calloc;\n                       hooks::calloc.init();\n                       hooks::dlopen.init();\n                       hooks::dlclose.init();\n                       hooks::malloc.init();\n                       hooks::free.init();\n                       hooks::calloc.init();\n#if HAVE_CFREE\n                       hooks::cfree.init();\n#endif\n                       hooks::realloc.init();\n                       hooks::posix_memalign.init();\n                       hooks::valloc.init();\n#if HAVE_ALIGNED_ALLOC\n                       hooks::aligned_alloc.init();\n#endif\n\n                       // cleanup environment to prevent tracing of child apps\n                       unsetenv(\"LD_PRELOAD\");\n                       unsetenv(\"DUMP_HEAPTRACK_OUTPUT\");\n                   },\n                   nullptr, nullptr);\n}\n}\n}\n\nextern \"C\" {\n\n/// TODO: memalign, pvalloc, ...?\n\nvoid* malloc(size_t size) noexcept\n{\n    if (!hooks::malloc) {\n        hooks::init();\n    }\n\n    void* ptr = hooks::malloc(size);\n    heaptrack_malloc(ptr, size);\n    return ptr;\n}\n\nvoid free(void* ptr) noexcept\n{\n    if (!hooks::free) {\n        hooks::init();\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    heaptrack_free(ptr);\n\n    hooks::free(ptr);\n}\n\nvoid* realloc(void* ptr, size_t size) noexcept\n{\n    if (!hooks::realloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::realloc(ptr, size);\n\n    if (ret) {\n        heaptrack_realloc(ptr, size, ret);\n    }\n\n    return ret;\n}\n\nvoid* calloc(size_t num, size_t size) noexcept\n{\n    if (!hooks::calloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::calloc(num, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, num * size);\n    }\n\n    return ret;\n}\n\n#if HAVE_CFREE\nvoid cfree(void* ptr) noexcept\n{\n    if (!hooks::cfree) {\n        hooks::init();\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    if (ptr) {\n        heaptrack_free(ptr);\n    }\n\n    hooks::cfree(ptr);\n}\n#endif\n\nint posix_memalign(void** memptr, size_t alignment, size_t size) noexcept\n{\n    if (!hooks::posix_memalign) {\n        hooks::init();\n    }\n\n    int ret = hooks::posix_memalign(memptr, alignment, size);\n\n    if (!ret) {\n        heaptrack_malloc(*memptr, size);\n    }\n\n    return ret;\n}\n\n#if HAVE_ALIGNED_ALLOC\nvoid* aligned_alloc(size_t alignment, size_t size) noexcept\n{\n    if (!hooks::aligned_alloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::aligned_alloc(alignment, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n#endif\n\nvoid* valloc(size_t size) noexcept\n{\n    if (!hooks::valloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::valloc(size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n\nvoid* dlopen(const char* filename, int flag) noexcept\n{\n    if (!hooks::dlopen) {\n        hooks::init();\n    }\n\n    void* ret = hooks::dlopen(filename, flag);\n\n    if (ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n\nint dlclose(void* handle) noexcept\n{\n    if (!hooks::dlclose) {\n        hooks::init();\n    }\n\n    int ret = hooks::dlclose(handle);\n\n    if (!ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/heaptrack.sh.cmake": "#!/bin/sh\n\n#\n# Copyright 2014-2017 Milian Wolff <mail@milianw.de>\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n#\n\nusage() {\n    echo \"Usage: $0 [--debug|-d] DEBUGGEE [ARGUMENT]...\"\n    echo \"or:    $0 [--debug|-d] -p PID\"\n    echo \"or:    $0 -a FILE\"\n    echo\n    echo \"A heap memory usage profiler. It uses LD_PRELOAD to track all\"\n    echo \"calls to the core memory allocation functions and logs these\"\n    echo \"occurrences. Additionally, backtraces are obtained and logged.\"\n    echo \"Combined this can give interesting answers to questions such as:\"\n    echo\n    echo \"  * How much heap memory is my application using?\"\n    echo \"  * Where is heap memory being allocated, and how often?\"\n    echo \"  * How much space are heap individual allocations requesting?\"\n    echo\n    echo \"To evaluate the generated heaptrack data, use heaptrack_print or heaptrack_gui.\"\n    echo\n    echo \"Mandatory arguments to heaptrack:\"\n    echo \"  DEBUGGEE       The name or path to the application that should\"\n    echo \"                 be run with heaptrack analyzation enabled.\"\n    echo\n    echo \"Alternatively, to attach to a running process:\"\n    echo \"  -p, --pid PID  The process ID of a running process into which\"\n    echo \"                 heaptrack will be injected. This only works with\"\n    echo \"                 applications that already link against libdl.\"\n    echo \"  WARNING: Runtime-attaching heaptrack is UNSTABLE and can lead to CRASHES\"\n    echo \"           in your application, especially after you detach heaptrack again.\"\n    echo \"           You are hereby warned, use it at your own risk!\"\n    echo\n    echo \"Optional arguments to heaptrack:\"\n    echo \"  -d, --debug    Run the debuggee in GDB and heaptrack.\"\n    echo \"  ARGUMENT       Any number of arguments that will be passed verbatim\"\n    echo \"                 to the debuggee.\"\n    echo \"  -h, --help     Show this help message and exit.\"\n    echo \"  -v, --version  Displays version information.\"\n    echo\n    echo \"Alternatively, to analyze a recorded heaptrack data file:\"\n    echo \"  -a, --analyze FILE    Open the heaptrack data file in heaptrack_gui, if available,\"\n    echo \"                        or fallback to heaptrack_print otherwise.\"\n    echo \"                        Any options passed after --analyze will be passed along.\"\n    echo\n    exit 0\n}\n\ndebug=\npid=\nclient=\n\n# path to current heaptrack.sh executable\nSCRIPT_PATH=$(readlink -f \"$0\")\nSCRIPT_DIR=$(dirname \"$SCRIPT_PATH\")\nEXE_PATH=$(readlink -f \"$SCRIPT_DIR\")\n\nopenHeaptrackDataFiles() {\n    if [ -x \"$EXE_PATH/heaptrack_gui\" ]; then\n        \"$EXE_PATH/heaptrack_gui\" \"$@\"\n    else\n        \"$EXE_PATH/heaptrack_print\" \"$@\"\n    fi\n}\n\nwhile true; do\n    case \"$1\" in\n        \"-d\" | \"--debug\")\n            if [ -z \"$(which gdb 2> /dev/null)\" ]; then\n                echo \"GDB is not installed, cannot debug heaptrack.\"\n                exit 1\n            fi\n            debug=1\n            shift 1\n            ;;\n        \"-h\" | \"--help\")\n            usage\n            exit 0\n            ;;\n        \"-p\" | \"--pid\")\n            if [ -z \"$(which gdb 2> /dev/null)\" ]; then\n                echo \"GDB is not installed, cannot attach to running process.\"\n                exit 1\n            fi\n            pid=$2\n            if [ -z \"$pid\" ]; then\n                echo \"Missing PID argument.\"\n                exit 1\n            fi\n            client=$(cat /proc/$pid/comm)\n            if [ -z \"$client\" ]; then\n                echo \"Cannot attach to unknown process with PID $pid.\"\n                exit 1\n            fi\n            shift 2\n            echo $@\n            if [ ! -z \"$@\" ]; then\n                echo \"You cannot specify a debuggee and a pid at the same time.\"\n                exit 1\n            fi\n            break\n            ;;\n        \"-v\" | \"--version\")\n            echo \"heaptrack @HEAPTRACK_VERSION_MAJOR@.@HEAPTRACK_VERSION_MINOR@.@HEAPTRACK_VERSION_PATCH@\"\n            exit 0\n            ;;\n        \"-a\" | \"--analyze\")\n            shift 1\n            openHeaptrackDataFiles \"$@\"\n            exit\n            ;;\n        *)\n            if [ \"$1\" = \"--\" ]; then\n                shift 1\n            fi\n            if [ ! -x \"$(which \"$1\" 2> /dev/null)\" ]; then\n                if [ -f \"$1\" ] && echo \"$1\" | grep -q \"heaptrack.\"; then\n                    openHeaptrackDataFiles \"$@\"\n                    exit\n                fi\n                echo \"Error: Debuggee \\\"$1\\\" is not an executable.\"\n                echo\n                echo \"Usage: $0 [--debug|-d] [--help|-h] DEBUGGEE [ARGS...]\"\n                exit 1\n            fi\n            client=\"$1\"\n            shift 1\n            break\n            ;;\n    esac\ndone\n\n# put output into current pwd\noutput=$(pwd)/heaptrack.$(basename \"$client\").$$\n\n# find preload library and interpreter executable using relative paths\nLIB_REL_PATH=\"@LIB_REL_PATH@\"\nLIBEXEC_REL_PATH=\"@LIBEXEC_REL_PATH@\"\n\nINTERPRETER=\"$EXE_PATH/$LIBEXEC_REL_PATH/heaptrack_interpret\"\nif [ ! -f \"$INTERPRETER\" ]; then\n    echo \"Could not find heaptrack interpreter executable: $INTERPRETER\"\n    exit 1\nfi\nINTERPRETER=$(readlink -f \"$INTERPRETER\")\n\nLIBHEAPTRACK_PRELOAD=\"$EXE_PATH/$LIB_REL_PATH/libheaptrack_preload.so\"\nif [ ! -f \"$LIBHEAPTRACK_PRELOAD\" ]; then\n    echo \"Could not find heaptrack preload library $LIBHEAPTRACK_PRELOAD\"\n    exit 1\nfi\nLIBHEAPTRACK_PRELOAD=$(readlink -f \"$LIBHEAPTRACK_PRELOAD\")\n\nLIBHEAPTRACK_INJECT=\"$EXE_PATH/$LIB_REL_PATH/libheaptrack_inject.so\"\nif [ ! -f \"$LIBHEAPTRACK_INJECT\" ]; then\n    echo \"Could not find heaptrack inject library $LIBHEAPTRACK_INJECT\"\n    exit 1\nfi\nLIBHEAPTRACK_INJECT=$(readlink -f \"$LIBHEAPTRACK_INJECT\")\n\n# setup named pipe to read data from\npipe=/tmp/heaptrack_fifo$$\nmkfifo $pipe\n\noutput_suffix=\"gz\"\nCOMPRESSOR=\"gzip -c\"\n\nif [ \"@ZSTD_FOUND@\" = \"TRUE\" ] && [ ! -z \"$(which zstd 2> /dev/null)\" ]; then\n    output_suffix=\"zst\"\n    COMPRESSOR=\"zstd -c\"\nfi\n\n# interpret the data and compress the output on the fly\noutput=\"$output.$output_suffix\"\n\"$INTERPRETER\" < $pipe | $COMPRESSOR > \"$output\" &\ndebuggee=$!\n\ncleanup() {\n    if [ ! -z \"$pid\" ]; then\n        echo \"removing heaptrack injection via GDB, this might take some time...\"\n        gdb --batch-silent -n -iex=\"set auto-solib-add off\" -p $pid \\\n            --eval-command=\"sharedlibrary libheaptrack_inject\" \\\n            --eval-command=\"call heaptrack_stop()\" \\\n            --eval-command=\"detach\"\n        # NOTE: we do not call dlclose here, as that has the tendency to trigger\n        #       crashes in the debuggee. So instead, we keep heaptrack loaded.\n    fi\n    rm -f \"$pipe\"\n    kill \"$debuggee\" 2> /dev/null\n\n    echo \"Heaptrack finished! Now run the following to investigate the data:\"\n    echo\n    echo \"  heaptrack --analyze \\\"$output\\\"\"\n}\ntrap cleanup EXIT\n\necho \"heaptrack output will be written to \\\"$output\\\"\"\n\nif [ -z \"$debug\" ] && [ -z \"$pid\" ]; then\n  echo \"starting application, this might take some time...\"\n  LD_PRELOAD=\"$LIBHEAPTRACK_PRELOAD${LD_PRELOAD:+:$LD_PRELOAD}\" DUMP_HEAPTRACK_OUTPUT=\"$pipe\" \"$client\" \"$@\"\nelse\n  if [ -z \"$pid\" ]; then\n    echo \"starting application in GDB, this might take some time...\"\n    gdb --quiet --eval-command=\"set environment LD_PRELOAD=$LIBHEAPTRACK_PRELOAD\" \\\n        --eval-command=\"set environment DUMP_HEAPTRACK_OUTPUT=$pipe\" \\\n        --eval-command=\"set startup-with-shell off\" \\\n        --eval-command=\"run\" --args \"$client\" \"$@\"\n  else\n    echo \"injecting heaptrack into application via GDB, this might take some time...\"\n    if [ -z \"$debug\" ]; then\n        gdb --batch-silent -n -iex=\"set auto-solib-add off\" -p $pid \\\n            --eval-command=\"sharedlibrary libc.so\" \\\n            --eval-command=\"call (void) __libc_dlopen_mode(\\\"$LIBHEAPTRACK_INJECT\\\", 0x80000000 | 0x002)\" \\\n            --eval-command=\"sharedlibrary libheaptrack_inject\" \\\n            --eval-command=\"call (void) heaptrack_inject(\\\"$pipe\\\")\" \\\n            --eval-command=\"detach\"\n    else\n        gdb --quiet -p $pid \\\n            --eval-command=\"sharedlibrary libc.so\" \\\n            --eval-command=\"call (void) __libc_dlopen_mode(\\\"$LIBHEAPTRACK_INJECT\\\", 0x80000000 | 0x002)\" \\\n            --eval-command=\"sharedlibrary libheaptrack_inject\" \\\n            --eval-command=\"call (void) heaptrack_inject(\\\"$pipe\\\")\"\n    fi\n    echo \"injection finished\"\n  fi\nfi\n\nwait $debuggee\n\n# kate: hl Bash\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/heaptrack_inject.cpp": "/*\n * Copyright 2014-2017 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"libheaptrack.h\"\n#include \"util/config.h\"\n#include \"util/linewriter.h\"\n\n#include <cstdlib>\n#include <cstring>\n\n#include <errno.h>\n#include <link.h>\n#include <malloc.h>\n#include <unistd.h>\n\n#include <sys/mman.h>\n\n#include <type_traits>\n\n/**\n * @file heaptrack_inject.cpp\n *\n * @brief Experimental support for symbol overloading after runtime injection.\n */\n\n#if __WORDSIZE == 64\n#define ELF_R_SYM(i) ELF64_R_SYM(i)\n#elif __WORDSIZE == 32\n#define ELF_R_SYM(i) ELF32_R_SYM(i)\n#else\n#error unsupported word size\n#endif\n\nnamespace {\n\nnamespace Elf {\nusing Addr = ElfW(Addr);\nusing Dyn = ElfW(Dyn);\nusing Rel = ElfW(Rel);\nusing Rela = ElfW(Rela);\nusing Sym = ElfW(Sym);\nusing Sxword = ElfW(Sxword);\nusing Xword = ElfW(Xword);\n}\n\nvoid overwrite_symbols() noexcept;\n\nnamespace hooks {\n\nstruct malloc\n{\n    static constexpr auto name = \"malloc\";\n    static constexpr auto original = &::malloc;\n\n    static void* hook(size_t size) noexcept\n    {\n        auto ptr = original(size);\n        heaptrack_malloc(ptr, size);\n        return ptr;\n    }\n};\n\nstruct free\n{\n    static constexpr auto name = \"free\";\n    static constexpr auto original = &::free;\n\n    static void hook(void* ptr) noexcept\n    {\n        heaptrack_free(ptr);\n        original(ptr);\n    }\n};\n\nstruct realloc\n{\n    static constexpr auto name = \"realloc\";\n    static constexpr auto original = &::realloc;\n\n    static void* hook(void* ptr, size_t size) noexcept\n    {\n        auto ret = original(ptr, size);\n        heaptrack_realloc(ptr, size, ret);\n        return ret;\n    }\n};\n\nstruct calloc\n{\n    static constexpr auto name = \"calloc\";\n    static constexpr auto original = &::calloc;\n\n    static void* hook(size_t num, size_t size) noexcept\n    {\n        auto ptr = original(num, size);\n        heaptrack_malloc(ptr, num * size);\n        return ptr;\n    }\n};\n\n#if HAVE_CFREE\nstruct cfree\n{\n    static constexpr auto name = \"cfree\";\n    static constexpr auto original = &::cfree;\n\n    static void hook(void* ptr) noexcept\n    {\n        heaptrack_free(ptr);\n        original(ptr);\n    }\n};\n#endif\n\nstruct dlopen\n{\n    static constexpr auto name = \"dlopen\";\n    static constexpr auto original = &::dlopen;\n\n    static void* hook(const char* filename, int flag) noexcept\n    {\n        auto ret = original(filename, flag);\n        if (ret) {\n            heaptrack_invalidate_module_cache();\n            overwrite_symbols();\n        }\n        return ret;\n    }\n};\n\nstruct dlclose\n{\n    static constexpr auto name = \"dlclose\";\n    static constexpr auto original = &::dlclose;\n\n    static int hook(void* handle) noexcept\n    {\n        auto ret = original(handle);\n        if (!ret) {\n            heaptrack_invalidate_module_cache();\n        }\n        return ret;\n    }\n};\n\nstruct posix_memalign\n{\n    static constexpr auto name = \"posix_memalign\";\n    static constexpr auto original = &::posix_memalign;\n\n    static int hook(void** memptr, size_t alignment, size_t size) noexcept\n    {\n        auto ret = original(memptr, alignment, size);\n        if (!ret) {\n            heaptrack_malloc(*memptr, size);\n        }\n        return ret;\n    }\n};\n\ntemplate <typename Hook>\nbool hook(const char* symname, Elf::Addr addr, bool restore)\n{\n    static_assert(std::is_convertible<decltype(&Hook::hook), decltype(Hook::original)>::value,\n                  \"hook is not compatible to original function\");\n\n    if (strcmp(Hook::name, symname) != 0) {\n        return false;\n    }\n\n    // try to make the page read/write accessible, which is hackish\n    // but apparently required for some shared libraries\n    auto page = reinterpret_cast<void*>(addr & ~(0x1000 - 1));\n    mprotect(page, 0x1000, PROT_READ | PROT_WRITE);\n\n    // now write to the address\n    auto typedAddr = reinterpret_cast<typename std::remove_const<decltype(Hook::original)>::type*>(addr);\n    if (restore) {\n        // restore the original address on shutdown\n        *typedAddr = Hook::original;\n    } else {\n        // now actually inject our hook\n        *typedAddr = &Hook::hook;\n    }\n\n    return true;\n}\n\nvoid apply(const char* symname, Elf::Addr addr, bool restore)\n{\n    // TODO: use std::apply once we can rely on C++17\n    hook<malloc>(symname, addr, restore) || hook<free>(symname, addr, restore) || hook<realloc>(symname, addr, restore)\n        || hook<calloc>(symname, addr, restore)\n#if HAVE_CFREE\n        || hook<cfree>(symname, addr, restore)\n#endif\n        || hook<posix_memalign>(symname, addr, restore) || hook<dlopen>(symname, addr, restore)\n        || hook<dlclose>(symname, addr, restore);\n}\n}\n\ntemplate <typename T, Elf::Sxword AddrTag, Elf::Sxword SizeTag>\nstruct elftable\n{\n    using type = T;\n    T* table = nullptr;\n    Elf::Xword size = {};\n\n    bool consume(const Elf::Dyn* dyn) noexcept\n    {\n        if (dyn->d_tag == AddrTag) {\n            table = reinterpret_cast<T*>(dyn->d_un.d_ptr);\n            return true;\n        } else if (dyn->d_tag == SizeTag) {\n            size = dyn->d_un.d_val;\n            return true;\n        }\n        return false;\n    }\n};\n\nusing elf_string_table = elftable<const char, DT_STRTAB, DT_STRSZ>;\nusing elf_rel_table = elftable<Elf::Rel, DT_REL, DT_RELSZ>;\nusing elf_rela_table = elftable<Elf::Rela, DT_RELA, DT_RELASZ>;\nusing elf_jmprel_table = elftable<Elf::Rela, DT_JMPREL, DT_PLTRELSZ>;\nusing elf_symbol_table = elftable<Elf::Sym, DT_SYMTAB, DT_SYMENT>;\n\ntemplate <typename Table>\nvoid try_overwrite_elftable(const Table& jumps, const elf_string_table& strings, const elf_symbol_table& symbols,\n                            const Elf::Addr base, const bool restore) noexcept\n{\n    const auto rela_end = reinterpret_cast<typename Table::type*>(reinterpret_cast<char*>(jumps.table) + jumps.size);\n    for (auto rela = jumps.table; rela < rela_end; rela++) {\n        const auto index = ELF_R_SYM(rela->r_info);\n        const char* symname = strings.table + symbols.table[index].st_name;\n        auto addr = rela->r_offset + base;\n        hooks::apply(symname, addr, restore);\n    }\n}\n\nvoid try_overwrite_symbols(const Elf::Dyn* dyn, const Elf::Addr base, const bool restore) noexcept\n{\n    elf_symbol_table symbols;\n    elf_rel_table rels;\n    elf_rela_table relas;\n    elf_jmprel_table jmprels;\n    elf_string_table strings;\n\n    // initialize the elf tables\n    for (; dyn->d_tag != DT_NULL; ++dyn) {\n        symbols.consume(dyn) || strings.consume(dyn) || rels.consume(dyn) || relas.consume(dyn) || jmprels.consume(dyn);\n    }\n\n    // find symbols to overwrite\n    try_overwrite_elftable(rels, strings, symbols, base, restore);\n    try_overwrite_elftable(relas, strings, symbols, base, restore);\n    try_overwrite_elftable(jmprels, strings, symbols, base, restore);\n}\n\nint iterate_phdrs(dl_phdr_info* info, size_t /*size*/, void* data) noexcept\n{\n    if (strstr(info->dlpi_name, \"/libheaptrack_inject.so\")) {\n        // prevent infinite recursion: do not overwrite our own symbols\n        return 0;\n    } else if (strstr(info->dlpi_name, \"/ld-linux\")) {\n        // prevent strange crashes due to overwriting the free symbol in ld-linux\n        return 0;\n    }\n\n    for (auto phdr = info->dlpi_phdr, end = phdr + info->dlpi_phnum; phdr != end; ++phdr) {\n        if (phdr->p_type == PT_DYNAMIC) {\n            try_overwrite_symbols(reinterpret_cast<const Elf::Dyn*>(phdr->p_vaddr + info->dlpi_addr), info->dlpi_addr,\n                                  data != nullptr);\n        }\n    }\n    return 0;\n}\n\nvoid overwrite_symbols() noexcept\n{\n    dl_iterate_phdr(&iterate_phdrs, nullptr);\n}\n}\n\nextern \"C\" {\nvoid heaptrack_inject(const char* outputFileName) noexcept\n{\n    heaptrack_init(outputFileName, []() { overwrite_symbols(); }, [](LineWriter& out) { out.write(\"A\\n\"); },\n                   []() {\n                       bool do_shutdown = true;\n                       dl_iterate_phdr(&iterate_phdrs, &do_shutdown);\n                   });\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/tests/auto/tst_inject.cpp": "/*\n * Copyright 2018 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"3rdparty/catch.hpp\"\n\n#include \"tempfile.h\"\n#include \"tst_config.h\"\n\n#include <dlfcn.h>\n\n#include <iostream>\n\nstatic_assert(RTLD_NOW == 0x2, \"RTLD_NOW needs to equal 0x2\");\n\nusing heaptrack_inject_t = void (*)(const char*);\nusing heaptrack_stop_t = void (*)();\n\nnamespace {\ntemplate <typename T>\nT resolveSymbol(void* handle, const char* symbol)\n{\n    return reinterpret_cast<T>(dlsym(handle, symbol));\n}\n\nheaptrack_inject_t resolveHeaptrackInject(void* handle)\n{\n    return resolveSymbol<heaptrack_inject_t>(handle, \"heaptrack_inject\");\n}\n\nheaptrack_stop_t resolveHeaptrackStop(void* handle)\n{\n    return resolveSymbol<heaptrack_stop_t>(handle, \"heaptrack_stop\");\n}\n\ntemplate <typename Load, typename Unload>\nvoid runInjectTest(Load load, Unload unload)\n{\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    auto* handle = load();\n    REQUIRE(handle);\n\n    auto* heaptrack_inject = resolveHeaptrackInject(handle);\n    REQUIRE(heaptrack_inject);\n\n    auto* heaptrack_stop = resolveHeaptrackStop(handle);\n    REQUIRE(heaptrack_stop);\n\n    TempFile file;\n\n    heaptrack_inject(file.fileName.c_str());\n\n    auto* p = malloc(100);\n    free(p);\n\n    heaptrack_stop();\n\n    unload(handle);\n\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    const auto contents = file.readContents();\n    REQUIRE(!contents.empty());\n    REQUIRE(contents.find(\"\\nA\\n\") != std::string::npos);\n    REQUIRE(contents.find(\"\\n+\") != std::string::npos);\n    REQUIRE(contents.find(\"\\n-\") != std::string::npos);\n}\n}\n\nTEST_CASE (\"inject via dlopen\", \"[inject]\") {\n    runInjectTest(\n        []() -> void* {\n            dlerror(); // clear error\n            auto* handle = dlopen(HEAPTRACK_LIB_INJECT_SO, RTLD_NOW);\n            if (!handle) {\n                std::cerr << \"DLOPEN FAILED: \" << dlerror() << std::endl;\n            }\n            return handle;\n        },\n        [](void* handle) { dlclose(handle); });\n}\n\nextern \"C\" {\n__attribute__((weak)) void* __libc_dlopen_mode(const char* filename, int flag);\n__attribute__((weak)) int __libc_dlclose(void* handle);\n}\n\nTEST_CASE (\"inject via libc\", \"[inject]\") {\n    REQUIRE(__libc_dlopen_mode);\n    runInjectTest([]() { return __libc_dlopen_mode(HEAPTRACK_LIB_INJECT_SO, 0x80000000 | 0x002); },\n                  [](void* handle) { __libc_dlclose(handle); });\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/3rdparty/libbacktrace/dwarf.c": "/* dwarf.c -- Get file/line information from DWARF for backtraces.\n   Copyright (C) 2012-2017 Free Software Foundation, Inc.\n   Written by Ian Lance Taylor, Google.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    (1) Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    (2) Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n    (3) The name of the author may not be used to\n    endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.  */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include \"dwarf2.h\"\n#include \"filenames.h\"\n\n#include \"backtrace.h\"\n#include \"internal.h\"\n\n#if !defined(HAVE_DECL_STRNLEN) || !HAVE_DECL_STRNLEN\n\n/* If strnlen is not declared, provide our own version.  */\n\nstatic size_t\nxstrnlen (const char *s, size_t maxlen)\n{\n  size_t i;\n\n  for (i = 0; i < maxlen; ++i)\n    if (s[i] == '\\0')\n      break;\n  return i;\n}\n\n#define strnlen xstrnlen\n\n#endif\n\n/* A buffer to read DWARF info.  */\n\nstruct dwarf_buf\n{\n  /* Buffer name for error messages.  */\n  const char *name;\n  /* Start of the buffer.  */\n  const unsigned char *start;\n  /* Next byte to read.  */\n  const unsigned char *buf;\n  /* The number of bytes remaining.  */\n  size_t left;\n  /* Whether the data is big-endian.  */\n  int is_bigendian;\n  /* Error callback routine.  */\n  backtrace_error_callback error_callback;\n  /* Data for error_callback.  */\n  void *data;\n  /* Non-zero if we've reported an underflow error.  */\n  int reported_underflow;\n};\n\n/* A single attribute in a DWARF abbreviation.  */\n\nstruct attr\n{\n  /* The attribute name.  */\n  enum dwarf_attribute name;\n  /* The attribute form.  */\n  enum dwarf_form form;\n};\n\n/* A single DWARF abbreviation.  */\n\nstruct abbrev\n{\n  /* The abbrev code--the number used to refer to the abbrev.  */\n  uint64_t code;\n  /* The entry tag.  */\n  enum dwarf_tag tag;\n  /* Non-zero if this abbrev has child entries.  */\n  int has_children;\n  /* The number of attributes.  */\n  size_t num_attrs;\n  /* The attributes.  */\n  struct attr *attrs;\n};\n\n/* The DWARF abbreviations for a compilation unit.  This structure\n   only exists while reading the compilation unit.  Most DWARF readers\n   seem to a hash table to map abbrev ID's to abbrev entries.\n   However, we primarily care about GCC, and GCC simply issues ID's in\n   numerical order starting at 1.  So we simply keep a sorted vector,\n   and try to just look up the code.  */\n\nstruct abbrevs\n{\n  /* The number of abbrevs in the vector.  */\n  size_t num_abbrevs;\n  /* The abbrevs, sorted by the code field.  */\n  struct abbrev *abbrevs;\n};\n\n/* The different kinds of attribute values.  */\n\nenum attr_val_encoding\n{\n  /* An address.  */\n  ATTR_VAL_ADDRESS,\n  /* A unsigned integer.  */\n  ATTR_VAL_UINT,\n  /* A sigd integer.  */\n  ATTR_VAL_SINT,\n  /* A string.  */\n  ATTR_VAL_STRING,\n  /* An offset to other data in the containing unit.  */\n  ATTR_VAL_REF_UNIT,\n  /* An offset to other data within the .dwarf_info section.  */\n  ATTR_VAL_REF_INFO,\n  /* An offset to data in some other section.  */\n  ATTR_VAL_REF_SECTION,\n  /* A type signature.  */\n  ATTR_VAL_REF_TYPE,\n  /* A block of data (not represented).  */\n  ATTR_VAL_BLOCK,\n  /* An expression (not represented).  */\n  ATTR_VAL_EXPR,\n};\n\n/* An attribute value.  */\n\nstruct attr_val\n{\n  /* How the value is stored in the field u.  */\n  enum attr_val_encoding encoding;\n  union\n  {\n    /* ATTR_VAL_ADDRESS, ATTR_VAL_UINT, ATTR_VAL_REF*.  */\n    uint64_t uint;\n    /* ATTR_VAL_SINT.  */\n    int64_t sint;\n    /* ATTR_VAL_STRING.  */\n    const char *string;\n    /* ATTR_VAL_BLOCK not stored.  */\n  } u;\n};\n\n/* The line number program header.  */\n\nstruct line_header\n{\n  /* The version of the line number information.  */\n  int version;\n  /* The minimum instruction length.  */\n  unsigned int min_insn_len;\n  /* The maximum number of ops per instruction.  */\n  unsigned int max_ops_per_insn;\n  /* The line base for special opcodes.  */\n  int line_base;\n  /* The line range for special opcodes.  */\n  unsigned int line_range;\n  /* The opcode base--the first special opcode.  */\n  unsigned int opcode_base;\n  /* Opcode lengths, indexed by opcode - 1.  */\n  const unsigned char *opcode_lengths;\n  /* The number of directory entries.  */\n  size_t dirs_count;\n  /* The directory entries.  */\n  const char **dirs;\n  /* The number of filenames.  */\n  size_t filenames_count;\n  /* The filenames.  */\n  const char **filenames;\n};\n\n/* Map a single PC value to a file/line.  We will keep a vector of\n   these sorted by PC value.  Each file/line will be correct from the\n   PC up to the PC of the next entry if there is one.  We allocate one\n   extra entry at the end so that we can use bsearch.  */\n\nstruct line\n{\n  /* PC.  */\n  uintptr_t pc;\n  /* File name.  Many entries in the array are expected to point to\n     the same file name.  */\n  const char *filename;\n  /* Line number.  */\n  int lineno;\n  /* Index of the object in the original array read from the DWARF\n     section, before it has been sorted.  The index makes it possible\n     to use Quicksort and maintain stability.  */\n  int idx;\n};\n\n/* A growable vector of line number information.  This is used while\n   reading the line numbers.  */\n\nstruct line_vector\n{\n  /* Memory.  This is an array of struct line.  */\n  struct backtrace_vector vec;\n  /* Number of valid mappings.  */\n  size_t count;\n};\n\n/* A function described in the debug info.  */\n\nstruct function\n{\n  /* The name of the function.  */\n  const char *name;\n  /* If this is an inlined function, the filename of the call\n     site.  */\n  const char *caller_filename;\n  /* If this is an inlined function, the line number of the call\n     site.  */\n  int caller_lineno;\n  /* Map PC ranges to inlined functions.  */\n  struct function_addrs *function_addrs;\n  size_t function_addrs_count;\n};\n\n/* An address range for a function.  This maps a PC value to a\n   specific function.  */\n\nstruct function_addrs\n{\n  /* Range is LOW <= PC < HIGH.  */\n  uint64_t low;\n  uint64_t high;\n  /* Function for this address range.  */\n  struct function *function;\n};\n\n/* A growable vector of function address ranges.  */\n\nstruct function_vector\n{\n  /* Memory.  This is an array of struct function_addrs.  */\n  struct backtrace_vector vec;\n  /* Number of address ranges present.  */\n  size_t count;\n};\n\n/* A DWARF compilation unit.  This only holds the information we need\n   to map a PC to a file and line.  */\n\nstruct unit\n{\n  /* The first entry for this compilation unit.  */\n  const unsigned char *unit_data;\n  /* The length of the data for this compilation unit.  */\n  size_t unit_data_len;\n  /* The offset of UNIT_DATA from the start of the information for\n     this compilation unit.  */\n  size_t unit_data_offset;\n  /* DWARF version.  */\n  int version;\n  /* Whether unit is DWARF64.  */\n  int is_dwarf64;\n  /* Address size.  */\n  int addrsize;\n  /* Offset into line number information.  */\n  off_t lineoff;\n  /* Primary source file.  */\n  const char *filename;\n  /* Compilation command working directory.  */\n  const char *comp_dir;\n  /* Absolute file name, only set if needed.  */\n  const char *abs_filename;\n  /* The abbreviations for this unit.  */\n  struct abbrevs abbrevs;\n\n  /* The fields above this point are read in during initialization and\n     may be accessed freely.  The fields below this point are read in\n     as needed, and therefore require care, as different threads may\n     try to initialize them simultaneously.  */\n\n  /* PC to line number mapping.  This is NULL if the values have not\n     been read.  This is (struct line *) -1 if there was an error\n     reading the values.  */\n  struct line *lines;\n  /* Number of entries in lines.  */\n  size_t lines_count;\n  /* PC ranges to function.  */\n  struct function_addrs *function_addrs;\n  size_t function_addrs_count;\n};\n\n/* An address range for a compilation unit.  This maps a PC value to a\n   specific compilation unit.  Note that we invert the representation\n   in DWARF: instead of listing the units and attaching a list of\n   ranges, we list the ranges and have each one point to the unit.\n   This lets us do a binary search to find the unit.  */\n\nstruct unit_addrs\n{\n  /* Range is LOW <= PC < HIGH.  */\n  uint64_t low;\n  uint64_t high;\n  /* Compilation unit for this address range.  */\n  struct unit *u;\n};\n\n/* A growable vector of compilation unit address ranges.  */\n\nstruct unit_addrs_vector\n{\n  /* Memory.  This is an array of struct unit_addrs.  */\n  struct backtrace_vector vec;\n  /* Number of address ranges present.  */\n  size_t count;\n};\n\n/* The information we need to map a PC to a file and line.  */\n\nstruct dwarf_data\n{\n  /* The data for the next file we know about.  */\n  struct dwarf_data *next;\n  /* The base address for this file.  */\n  uintptr_t base_address;\n  /* A sorted list of address ranges.  */\n  struct unit_addrs *addrs;\n  /* Number of address ranges in list.  */\n  size_t addrs_count;\n  /* The unparsed .debug_info section.  */\n  const unsigned char *dwarf_info;\n  size_t dwarf_info_size;\n  /* The unparsed .debug_line section.  */\n  const unsigned char *dwarf_line;\n  size_t dwarf_line_size;\n  /* The unparsed .debug_ranges section.  */\n  const unsigned char *dwarf_ranges;\n  size_t dwarf_ranges_size;\n  /* The unparsed .debug_str section.  */\n  const unsigned char *dwarf_str;\n  size_t dwarf_str_size;\n  /* Whether the data is big-endian or not.  */\n  int is_bigendian;\n  /* A vector used for function addresses.  We keep this here so that\n     we can grow the vector as we read more functions.  */\n  struct function_vector fvec;\n};\n\n/* Report an error for a DWARF buffer.  */\n\nstatic void\ndwarf_buf_error (struct dwarf_buf *buf, const char *msg)\n{\n  char b[200];\n\n  snprintf (b, sizeof b, \"%s in %s at %d\",\n\t    msg, buf->name, (int) (buf->buf - buf->start));\n  buf->error_callback (buf->data, b, 0);\n}\n\n/* Require at least COUNT bytes in BUF.  Return 1 if all is well, 0 on\n   error.  */\n\nstatic int\nrequire (struct dwarf_buf *buf, size_t count)\n{\n  if (buf->left >= count)\n    return 1;\n\n  if (!buf->reported_underflow)\n    {\n      dwarf_buf_error (buf, \"DWARF underflow\");\n      buf->reported_underflow = 1;\n    }\n\n  return 0;\n}\n\n/* Advance COUNT bytes in BUF.  Return 1 if all is well, 0 on\n   error.  */\n\nstatic int\nadvance (struct dwarf_buf *buf, size_t count)\n{\n  if (!require (buf, count))\n    return 0;\n  buf->buf += count;\n  buf->left -= count;\n  return 1;\n}\n\n/* Read one byte from BUF and advance 1 byte.  */\n\nstatic unsigned char\nread_byte (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 1))\n    return 0;\n  return p[0];\n}\n\n/* Read a signed char from BUF and advance 1 byte.  */\n\nstatic signed char\nread_sbyte (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 1))\n    return 0;\n  return (*p ^ 0x80) - 0x80;\n}\n\n/* Read a uint16 from BUF and advance 2 bytes.  */\n\nstatic uint16_t\nread_uint16 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 2))\n    return 0;\n  if (buf->is_bigendian)\n    return ((uint16_t) p[0] << 8) | (uint16_t) p[1];\n  else\n    return ((uint16_t) p[1] << 8) | (uint16_t) p[0];\n}\n\n/* Read a uint32 from BUF and advance 4 bytes.  */\n\nstatic uint32_t\nread_uint32 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 4))\n    return 0;\n  if (buf->is_bigendian)\n    return (((uint32_t) p[0] << 24) | ((uint32_t) p[1] << 16)\n\t    | ((uint32_t) p[2] << 8) | (uint32_t) p[3]);\n  else\n    return (((uint32_t) p[3] << 24) | ((uint32_t) p[2] << 16)\n\t    | ((uint32_t) p[1] << 8) | (uint32_t) p[0]);\n}\n\n/* Read a uint64 from BUF and advance 8 bytes.  */\n\nstatic uint64_t\nread_uint64 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 8))\n    return 0;\n  if (buf->is_bigendian)\n    return (((uint64_t) p[0] << 56) | ((uint64_t) p[1] << 48)\n\t    | ((uint64_t) p[2] << 40) | ((uint64_t) p[3] << 32)\n\t    | ((uint64_t) p[4] << 24) | ((uint64_t) p[5] << 16)\n\t    | ((uint64_t) p[6] << 8) | (uint64_t) p[7]);\n  else\n    return (((uint64_t) p[7] << 56) | ((uint64_t) p[6] << 48)\n\t    | ((uint64_t) p[5] << 40) | ((uint64_t) p[4] << 32)\n\t    | ((uint64_t) p[3] << 24) | ((uint64_t) p[2] << 16)\n\t    | ((uint64_t) p[1] << 8) | (uint64_t) p[0]);\n}\n\n/* Read an offset from BUF and advance the appropriate number of\n   bytes.  */\n\nstatic uint64_t\nread_offset (struct dwarf_buf *buf, int is_dwarf64)\n{\n  if (is_dwarf64)\n    return read_uint64 (buf);\n  else\n    return read_uint32 (buf);\n}\n\n/* Read an address from BUF and advance the appropriate number of\n   bytes.  */\n\nstatic uint64_t\nread_address (struct dwarf_buf *buf, int addrsize)\n{\n  switch (addrsize)\n    {\n    case 1:\n      return read_byte (buf);\n    case 2:\n      return read_uint16 (buf);\n    case 4:\n      return read_uint32 (buf);\n    case 8:\n      return read_uint64 (buf);\n    default:\n      dwarf_buf_error (buf, \"unrecognized address size\");\n      return 0;\n    }\n}\n\n/* Return whether a value is the highest possible address, given the\n   address size.  */\n\nstatic int\nis_highest_address (uint64_t address, int addrsize)\n{\n  switch (addrsize)\n    {\n    case 1:\n      return address == (unsigned char) -1;\n    case 2:\n      return address == (uint16_t) -1;\n    case 4:\n      return address == (uint32_t) -1;\n    case 8:\n      return address == (uint64_t) -1;\n    default:\n      return 0;\n    }\n}\n\n/* Read an unsigned LEB128 number.  */\n\nstatic uint64_t\nread_uleb128 (struct dwarf_buf *buf)\n{\n  uint64_t ret;\n  unsigned int shift;\n  int overflow;\n  unsigned char b;\n\n  ret = 0;\n  shift = 0;\n  overflow = 0;\n  do\n    {\n      const unsigned char *p;\n\n      p = buf->buf;\n      if (!advance (buf, 1))\n\treturn 0;\n      b = *p;\n      if (shift < 64)\n\tret |= ((uint64_t) (b & 0x7f)) << shift;\n      else if (!overflow)\n\t{\n\t  dwarf_buf_error (buf, \"LEB128 overflows uint64_t\");\n\t  overflow = 1;\n\t}\n      shift += 7;\n    }\n  while ((b & 0x80) != 0);\n\n  return ret;\n}\n\n/* Read a signed LEB128 number.  */\n\nstatic int64_t\nread_sleb128 (struct dwarf_buf *buf)\n{\n  uint64_t val;\n  unsigned int shift;\n  int overflow;\n  unsigned char b;\n\n  val = 0;\n  shift = 0;\n  overflow = 0;\n  do\n    {\n      const unsigned char *p;\n\n      p = buf->buf;\n      if (!advance (buf, 1))\n\treturn 0;\n      b = *p;\n      if (shift < 64)\n\tval |= ((uint64_t) (b & 0x7f)) << shift;\n      else if (!overflow)\n\t{\n\t  dwarf_buf_error (buf, \"signed LEB128 overflows uint64_t\");\n\t  overflow = 1;\n\t}\n      shift += 7;\n    }\n  while ((b & 0x80) != 0);\n\n  if ((b & 0x40) != 0 && shift < 64)\n    val |= ((uint64_t) -1) << shift;\n\n  return (int64_t) val;\n}\n\n/* Return the length of an LEB128 number.  */\n\nstatic size_t\nleb128_len (const unsigned char *p)\n{\n  size_t ret;\n\n  ret = 1;\n  while ((*p & 0x80) != 0)\n    {\n      ++p;\n      ++ret;\n    }\n  return ret;\n}\n\n/* Free an abbreviations structure.  */\n\nstatic void\nfree_abbrevs (struct backtrace_state *state, struct abbrevs *abbrevs,\n\t      backtrace_error_callback error_callback, void *data)\n{\n  size_t i;\n\n  for (i = 0; i < abbrevs->num_abbrevs; ++i)\n    backtrace_free (state, abbrevs->abbrevs[i].attrs,\n\t\t    abbrevs->abbrevs[i].num_attrs * sizeof (struct attr),\n\t\t    error_callback, data);\n  backtrace_free (state, abbrevs->abbrevs,\n\t\t  abbrevs->num_abbrevs * sizeof (struct abbrev),\n\t\t  error_callback, data);\n  abbrevs->num_abbrevs = 0;\n  abbrevs->abbrevs = NULL;\n}\n\n/* Read an attribute value.  Returns 1 on success, 0 on failure.  If\n   the value can be represented as a uint64_t, sets *VAL and sets\n   *IS_VALID to 1.  We don't try to store the value of other attribute\n   forms, because we don't care about them.  */\n\nstatic int\nread_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n\t\tint is_dwarf64, int version, int addrsize,\n\t\tconst unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\tstruct attr_val *val)\n{\n  /* Avoid warnings about val.u.FIELD may be used uninitialized if\n     this function is inlined.  The warnings aren't valid but can\n     occur because the different fields are set and used\n     conditionally.  */\n  memset (val, 0, sizeof *val);\n\n  switch (form)\n    {\n    case DW_FORM_addr:\n      val->encoding = ATTR_VAL_ADDRESS;\n      val->u.uint = read_address (buf, addrsize);\n      return 1;\n    case DW_FORM_block2:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uint16 (buf));\n    case DW_FORM_block4:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uint32 (buf));\n    case DW_FORM_data2:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint16 (buf);\n      return 1;\n    case DW_FORM_data4:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint32 (buf);\n      return 1;\n    case DW_FORM_data8:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_string:\n      val->encoding = ATTR_VAL_STRING;\n      val->u.string = (const char *) buf->buf;\n      return advance (buf, strnlen ((const char *) buf->buf, buf->left) + 1);\n    case DW_FORM_block:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uleb128 (buf));\n    case DW_FORM_block1:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_byte (buf));\n    case DW_FORM_data1:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_flag:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_sdata:\n      val->encoding = ATTR_VAL_SINT;\n      val->u.sint = read_sleb128 (buf);\n      return 1;\n    case DW_FORM_strp:\n      {\n\tuint64_t offset;\n\n\toffset = read_offset (buf, is_dwarf64);\n\tif (offset >= dwarf_str_size)\n\t  {\n\t    dwarf_buf_error (buf, \"DW_FORM_strp out of range\");\n\t    return 0;\n\t  }\n\tval->encoding = ATTR_VAL_STRING;\n\tval->u.string = (const char *) dwarf_str + offset;\n\treturn 1;\n      }\n    case DW_FORM_udata:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_ref_addr:\n      val->encoding = ATTR_VAL_REF_INFO;\n      if (version == 2)\n\tval->u.uint = read_address (buf, addrsize);\n      else\n\tval->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_ref1:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_ref2:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint16 (buf);\n      return 1;\n    case DW_FORM_ref4:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint32 (buf);\n      return 1;\n    case DW_FORM_ref8:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_ref_udata:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_indirect:\n      {\n\tuint64_t form;\n\n\tform = read_uleb128 (buf);\n\treturn read_attribute ((enum dwarf_form) form, buf, is_dwarf64,\n\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n\t\t\t       val);\n      }\n    case DW_FORM_sec_offset:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_exprloc:\n      val->encoding = ATTR_VAL_EXPR;\n      return advance (buf, read_uleb128 (buf));\n    case DW_FORM_flag_present:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = 1;\n      return 1;\n    case DW_FORM_ref_sig8:\n      val->encoding = ATTR_VAL_REF_TYPE;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_GNU_addr_index:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_GNU_str_index:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_GNU_ref_alt:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_GNU_strp_alt:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    default:\n      dwarf_buf_error (buf, \"unrecognized DWARF form\");\n      return 0;\n    }\n}\n\n/* Compare function_addrs for qsort.  When ranges are nested, make the\n   smallest one sort last.  */\n\nstatic int\nfunction_addrs_compare (const void *v1, const void *v2)\n{\n  const struct function_addrs *a1 = (const struct function_addrs *) v1;\n  const struct function_addrs *a2 = (const struct function_addrs *) v2;\n\n  if (a1->low < a2->low)\n    return -1;\n  if (a1->low > a2->low)\n    return 1;\n  if (a1->high < a2->high)\n    return 1;\n  if (a1->high > a2->high)\n    return -1;\n  return strcmp (a1->function->name, a2->function->name);\n}\n\n/* Compare a PC against a function_addrs for bsearch.  Note that if\n   there are multiple ranges containing PC, which one will be returned\n   is unpredictable.  We compensate for that in dwarf_fileline.  */\n\nstatic int\nfunction_addrs_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct function_addrs *entry = (const struct function_addrs *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->low)\n    return -1;\n  else if (pc >= entry->high)\n    return 1;\n  else\n    return 0;\n}\n\n/* Add a new compilation unit address range to a vector.  Returns 1 on\n   success, 0 on failure.  */\n\nstatic int\nadd_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n\t       struct unit_addrs addrs,\n\t       backtrace_error_callback error_callback, void *data,\n\t       struct unit_addrs_vector *vec)\n{\n  struct unit_addrs *p;\n\n  /* Add in the base address of the module here, so that we can look\n     up the PC directly.  */\n  addrs.low += base_address;\n  addrs.high += base_address;\n\n  /* Try to merge with the last entry.  */\n  if (vec->count > 0)\n    {\n      p = (struct unit_addrs *) vec->vec.base + (vec->count - 1);\n      if ((addrs.low == p->high || addrs.low == p->high + 1)\n\t  && addrs.u == p->u)\n\t{\n\t  if (addrs.high > p->high)\n\t    p->high = addrs.high;\n\t  return 1;\n\t}\n    }\n\n  p = ((struct unit_addrs *)\n       backtrace_vector_grow (state, sizeof (struct unit_addrs),\n\t\t\t      error_callback, data, &vec->vec));\n  if (p == NULL)\n    return 0;\n\n  *p = addrs;\n  ++vec->count;\n  return 1;\n}\n\n/* Free a unit address vector.  */\n\nstatic void\nfree_unit_addrs_vector (struct backtrace_state *state,\n\t\t\tstruct unit_addrs_vector *vec,\n\t\t\tbacktrace_error_callback error_callback, void *data)\n{\n  struct unit_addrs *addrs;\n  size_t i;\n\n  addrs = (struct unit_addrs *) vec->vec.base;\n  for (i = 0; i < vec->count; ++i)\n    free_abbrevs (state, &addrs[i].u->abbrevs, error_callback, data);\n}\n\n/* Compare unit_addrs for qsort.  When ranges are nested, make the\n   smallest one sort last.  */\n\nstatic int\nunit_addrs_compare (const void *v1, const void *v2)\n{\n  const struct unit_addrs *a1 = (const struct unit_addrs *) v1;\n  const struct unit_addrs *a2 = (const struct unit_addrs *) v2;\n\n  if (a1->low < a2->low)\n    return -1;\n  if (a1->low > a2->low)\n    return 1;\n  if (a1->high < a2->high)\n    return 1;\n  if (a1->high > a2->high)\n    return -1;\n  if (a1->u->lineoff < a2->u->lineoff)\n    return -1;\n  if (a1->u->lineoff > a2->u->lineoff)\n    return 1;\n  return 0;\n}\n\n/* Compare a PC against a unit_addrs for bsearch.  Note that if there\n   are multiple ranges containing PC, which one will be returned is\n   unpredictable.  We compensate for that in dwarf_fileline.  */\n\nstatic int\nunit_addrs_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct unit_addrs *entry = (const struct unit_addrs *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->low)\n    return -1;\n  else if (pc >= entry->high)\n    return 1;\n  else\n    return 0;\n}\n\n/* Sort the line vector by PC.  We want a stable sort here to maintain\n   the order of lines for the same PC values.  Since the sequence is\n   being sorted in place, their addresses cannot be relied on to\n   maintain stability.  That is the purpose of the index member.  */\n\nstatic int\nline_compare (const void *v1, const void *v2)\n{\n  const struct line *ln1 = (const struct line *) v1;\n  const struct line *ln2 = (const struct line *) v2;\n\n  if (ln1->pc < ln2->pc)\n    return -1;\n  else if (ln1->pc > ln2->pc)\n    return 1;\n  else if (ln1->idx < ln2->idx)\n    return -1;\n  else if (ln1->idx > ln2->idx)\n    return 1;\n  else\n    return 0;\n}\n\n/* Find a PC in a line vector.  We always allocate an extra entry at\n   the end of the lines vector, so that this routine can safely look\n   at the next entry.  Note that when there are multiple mappings for\n   the same PC value, this will return the last one.  */\n\nstatic int\nline_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct line *entry = (const struct line *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->pc)\n    return -1;\n  else if (pc >= (entry + 1)->pc)\n    return 1;\n  else\n    return 0;\n}\n\n/* Sort the abbrevs by the abbrev code.  This function is passed to\n   both qsort and bsearch.  */\n\nstatic int\nabbrev_compare (const void *v1, const void *v2)\n{\n  const struct abbrev *a1 = (const struct abbrev *) v1;\n  const struct abbrev *a2 = (const struct abbrev *) v2;\n\n  if (a1->code < a2->code)\n    return -1;\n  else if (a1->code > a2->code)\n    return 1;\n  else\n    {\n      /* This really shouldn't happen.  It means there are two\n\t different abbrevs with the same code, and that means we don't\n\t know which one lookup_abbrev should return.  */\n      return 0;\n    }\n}\n\n/* Read the abbreviation table for a compilation unit.  Returns 1 on\n   success, 0 on failure.  */\n\nstatic int\nread_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n\t      const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n\t      int is_bigendian, backtrace_error_callback error_callback,\n\t      void *data, struct abbrevs *abbrevs)\n{\n  struct dwarf_buf abbrev_buf;\n  struct dwarf_buf count_buf;\n  size_t num_abbrevs;\n\n  abbrevs->num_abbrevs = 0;\n  abbrevs->abbrevs = NULL;\n\n  if (abbrev_offset >= dwarf_abbrev_size)\n    {\n      error_callback (data, \"abbrev offset out of range\", 0);\n      return 0;\n    }\n\n  abbrev_buf.name = \".debug_abbrev\";\n  abbrev_buf.start = dwarf_abbrev;\n  abbrev_buf.buf = dwarf_abbrev + abbrev_offset;\n  abbrev_buf.left = dwarf_abbrev_size - abbrev_offset;\n  abbrev_buf.is_bigendian = is_bigendian;\n  abbrev_buf.error_callback = error_callback;\n  abbrev_buf.data = data;\n  abbrev_buf.reported_underflow = 0;\n\n  /* Count the number of abbrevs in this list.  */\n\n  count_buf = abbrev_buf;\n  num_abbrevs = 0;\n  while (read_uleb128 (&count_buf) != 0)\n    {\n      if (count_buf.reported_underflow)\n\treturn 0;\n      ++num_abbrevs;\n      // Skip tag.\n      read_uleb128 (&count_buf);\n      // Skip has_children.\n      read_byte (&count_buf);\n      // Skip attributes.\n      while (read_uleb128 (&count_buf) != 0)\n\tread_uleb128 (&count_buf);\n      // Skip form of last attribute.\n      read_uleb128 (&count_buf);\n    }\n\n  if (count_buf.reported_underflow)\n    return 0;\n\n  if (num_abbrevs == 0)\n    return 1;\n\n  abbrevs->num_abbrevs = num_abbrevs;\n  abbrevs->abbrevs = ((struct abbrev *)\n\t\t      backtrace_alloc (state,\n\t\t\t\t       num_abbrevs * sizeof (struct abbrev),\n\t\t\t\t       error_callback, data));\n  if (abbrevs->abbrevs == NULL)\n    return 0;\n  memset (abbrevs->abbrevs, 0, num_abbrevs * sizeof (struct abbrev));\n\n  num_abbrevs = 0;\n  while (1)\n    {\n      uint64_t code;\n      struct abbrev a;\n      size_t num_attrs;\n      struct attr *attrs;\n\n      if (abbrev_buf.reported_underflow)\n\tgoto fail;\n\n      code = read_uleb128 (&abbrev_buf);\n      if (code == 0)\n\tbreak;\n\n      a.code = code;\n      a.tag = (enum dwarf_tag) read_uleb128 (&abbrev_buf);\n      a.has_children = read_byte (&abbrev_buf);\n\n      count_buf = abbrev_buf;\n      num_attrs = 0;\n      while (read_uleb128 (&count_buf) != 0)\n\t{\n\t  ++num_attrs;\n\t  read_uleb128 (&count_buf);\n\t}\n\n      if (num_attrs == 0)\n\t{\n\t  attrs = NULL;\n\t  read_uleb128 (&abbrev_buf);\n\t  read_uleb128 (&abbrev_buf);\n\t}\n      else\n\t{\n\t  attrs = ((struct attr *)\n\t\t   backtrace_alloc (state, num_attrs * sizeof *attrs,\n\t\t\t\t    error_callback, data));\n\t  if (attrs == NULL)\n\t    goto fail;\n\t  num_attrs = 0;\n\t  while (1)\n\t    {\n\t      uint64_t name;\n\t      uint64_t form;\n\n\t      name = read_uleb128 (&abbrev_buf);\n\t      form = read_uleb128 (&abbrev_buf);\n\t      if (name == 0)\n\t\tbreak;\n\t      attrs[num_attrs].name = (enum dwarf_attribute) name;\n\t      attrs[num_attrs].form = (enum dwarf_form) form;\n\t      ++num_attrs;\n\t    }\n\t}\n\n      a.num_attrs = num_attrs;\n      a.attrs = attrs;\n\n      abbrevs->abbrevs[num_abbrevs] = a;\n      ++num_abbrevs;\n    }\n\n  backtrace_qsort (abbrevs->abbrevs, abbrevs->num_abbrevs,\n\t\t   sizeof (struct abbrev), abbrev_compare);\n\n  return 1;\n\n fail:\n  free_abbrevs (state, abbrevs, error_callback, data);\n  return 0;\n}\n\n/* Return the abbrev information for an abbrev code.  */\n\nstatic const struct abbrev *\nlookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n\t       backtrace_error_callback error_callback, void *data)\n{\n  struct abbrev key;\n  void *p;\n\n  /* With GCC, where abbrevs are simply numbered in order, we should\n     be able to just look up the entry.  */\n  if (code - 1 < abbrevs->num_abbrevs\n      && abbrevs->abbrevs[code - 1].code == code)\n    return &abbrevs->abbrevs[code - 1];\n\n  /* Otherwise we have to search.  */\n  memset (&key, 0, sizeof key);\n  key.code = code;\n  p = bsearch (&key, abbrevs->abbrevs, abbrevs->num_abbrevs,\n\t       sizeof (struct abbrev), abbrev_compare);\n  if (p == NULL)\n    {\n      error_callback (data, \"invalid abbreviation code\", 0);\n      return NULL;\n    }\n  return (const struct abbrev *) p;\n}\n\n/* Add non-contiguous address ranges for a compilation unit.  Returns\n   1 on success, 0 on failure.  */\n\nstatic int\nadd_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n\t\t struct unit *u, uint64_t ranges, uint64_t base,\n\t\t int is_bigendian, const unsigned char *dwarf_ranges,\n\t\t size_t dwarf_ranges_size,\n\t\t backtrace_error_callback error_callback, void *data,\n\t\t struct unit_addrs_vector *addrs)\n{\n  struct dwarf_buf ranges_buf;\n\n  if (ranges >= dwarf_ranges_size)\n    {\n      error_callback (data, \"ranges offset out of range\", 0);\n      return 0;\n    }\n\n  ranges_buf.name = \".debug_ranges\";\n  ranges_buf.start = dwarf_ranges;\n  ranges_buf.buf = dwarf_ranges + ranges;\n  ranges_buf.left = dwarf_ranges_size - ranges;\n  ranges_buf.is_bigendian = is_bigendian;\n  ranges_buf.error_callback = error_callback;\n  ranges_buf.data = data;\n  ranges_buf.reported_underflow = 0;\n\n  while (1)\n    {\n      uint64_t low;\n      uint64_t high;\n\n      if (ranges_buf.reported_underflow)\n\treturn 0;\n\n      low = read_address (&ranges_buf, u->addrsize);\n      high = read_address (&ranges_buf, u->addrsize);\n\n      if (low == 0 && high == 0)\n\tbreak;\n\n      if (is_highest_address (low, u->addrsize))\n\tbase = high;\n      else\n\t{\n\t  struct unit_addrs a;\n\n\t  a.low = low + base;\n\t  a.high = high + base;\n\t  a.u = u;\n\t  if (!add_unit_addr (state, base_address, a, error_callback, data,\n\t\t\t      addrs))\n\t    return 0;\n\t}\n    }\n\n  if (ranges_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Find the address range covered by a compilation unit, reading from\n   UNIT_BUF and adding values to U.  Returns 1 if all data could be\n   read, 0 if there is some error.  */\n\nstatic int\nfind_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n\t\t     struct dwarf_buf *unit_buf,\n\t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\t     const unsigned char *dwarf_ranges,\n\t\t     size_t dwarf_ranges_size,\n\t\t     int is_bigendian, backtrace_error_callback error_callback,\n\t\t     void *data, struct unit *u,\n\t\t     struct unit_addrs_vector *addrs)\n{\n  while (unit_buf->left > 0)\n    {\n      uint64_t code;\n      const struct abbrev *abbrev;\n      uint64_t lowpc;\n      int have_lowpc;\n      uint64_t highpc;\n      int have_highpc;\n      int highpc_is_relative;\n      uint64_t ranges;\n      int have_ranges;\n      size_t i;\n\n      code = read_uleb128 (unit_buf);\n      if (code == 0)\n\treturn 1;\n\n      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n      if (abbrev == NULL)\n\treturn 0;\n\n      lowpc = 0;\n      have_lowpc = 0;\n      highpc = 0;\n      have_highpc = 0;\n      highpc_is_relative = 0;\n      ranges = 0;\n      have_ranges = 0;\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attr_val val;\n\n\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n\t\t\t       dwarf_str, dwarf_str_size, &val))\n\t    return 0;\n\n\t  switch (abbrev->attrs[i].name)\n\t    {\n\t    case DW_AT_low_pc:\n\t      if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t{\n\t\t  lowpc = val.u.uint;\n\t\t  have_lowpc = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_high_pc:\n\t      if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t{\n\t\t  highpc = val.u.uint;\n\t\t  have_highpc = 1;\n\t\t}\n\t      else if (val.encoding == ATTR_VAL_UINT)\n\t\t{\n\t\t  highpc = val.u.uint;\n\t\t  have_highpc = 1;\n\t\t  highpc_is_relative = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_ranges:\n\t      if (val.encoding == ATTR_VAL_UINT\n\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n\t\t{\n\t\t  ranges = val.u.uint;\n\t\t  have_ranges = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_stmt_list:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_SECTION))\n\t\tu->lineoff = val.u.uint;\n\t      break;\n\n\t    case DW_AT_name:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && val.encoding == ATTR_VAL_STRING)\n\t\tu->filename = val.u.string;\n\t      break;\n\n\t    case DW_AT_comp_dir:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && val.encoding == ATTR_VAL_STRING)\n\t\tu->comp_dir = val.u.string;\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      if (abbrev->tag == DW_TAG_compile_unit\n\t  || abbrev->tag == DW_TAG_subprogram)\n\t{\n\t  if (have_ranges)\n\t    {\n\t      if (!add_unit_ranges (state, base_address, u, ranges, lowpc,\n\t\t\t\t    is_bigendian, dwarf_ranges,\n\t\t\t\t    dwarf_ranges_size, error_callback,\n\t\t\t\t    data, addrs))\n\t\treturn 0;\n\t    }\n\t  else if (have_lowpc && have_highpc)\n\t    {\n\t      struct unit_addrs a;\n\n\t      if (highpc_is_relative)\n\t\thighpc += lowpc;\n\t      a.low = lowpc;\n\t      a.high = highpc;\n\t      a.u = u;\n\n\t      if (!add_unit_addr (state, base_address, a, error_callback, data,\n\t\t\t\t  addrs))\n\t\treturn 0;\n\t    }\n\n\t  /* If we found the PC range in the DW_TAG_compile_unit, we\n\t     can stop now.  */\n\t  if (abbrev->tag == DW_TAG_compile_unit\n\t      && (have_ranges || (have_lowpc && have_highpc)))\n\t    return 1;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  if (!find_address_ranges (state, base_address, unit_buf,\n\t\t\t\t    dwarf_str, dwarf_str_size,\n\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n\t\t\t\t    is_bigendian, error_callback, data,\n\t\t\t\t    u, addrs))\n\t    return 0;\n\t}\n    }\n\n  return 1;\n}\n\n/* Build a mapping from address ranges to the compilation units where\n   the line number information for that range can be found.  Returns 1\n   on success, 0 on failure.  */\n\nstatic int\nbuild_address_map (struct backtrace_state *state, uintptr_t base_address,\n\t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n\t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n\t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n\t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\t   int is_bigendian, backtrace_error_callback error_callback,\n\t\t   void *data, struct unit_addrs_vector *addrs)\n{\n  struct dwarf_buf info;\n  struct abbrevs abbrevs;\n\n  memset (&addrs->vec, 0, sizeof addrs->vec);\n  addrs->count = 0;\n\n  /* Read through the .debug_info section.  FIXME: Should we use the\n     .debug_aranges section?  gdb and addr2line don't use it, but I'm\n     not sure why.  */\n\n  info.name = \".debug_info\";\n  info.start = dwarf_info;\n  info.buf = dwarf_info;\n  info.left = dwarf_info_size;\n  info.is_bigendian = is_bigendian;\n  info.error_callback = error_callback;\n  info.data = data;\n  info.reported_underflow = 0;\n\n  memset (&abbrevs, 0, sizeof abbrevs);\n  while (info.left > 0)\n    {\n      const unsigned char *unit_data_start;\n      uint64_t len;\n      int is_dwarf64;\n      struct dwarf_buf unit_buf;\n      int version;\n      uint64_t abbrev_offset;\n      int addrsize;\n      struct unit *u;\n\n      if (info.reported_underflow)\n\tgoto fail;\n\n      unit_data_start = info.buf;\n\n      is_dwarf64 = 0;\n      len = read_uint32 (&info);\n      if (len == 0xffffffff)\n\t{\n\t  len = read_uint64 (&info);\n\t  is_dwarf64 = 1;\n\t}\n\n      unit_buf = info;\n      unit_buf.left = len;\n\n      if (!advance (&info, len))\n\tgoto fail;\n\n      version = read_uint16 (&unit_buf);\n      if (version < 2 || version > 4)\n\t{\n\t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n\t  goto fail;\n\t}\n\n      abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n      if (!read_abbrevs (state, abbrev_offset, dwarf_abbrev, dwarf_abbrev_size,\n\t\t\t is_bigendian, error_callback, data, &abbrevs))\n\tgoto fail;\n\n      addrsize = read_byte (&unit_buf);\n\n      u = ((struct unit *)\n\t   backtrace_alloc (state, sizeof *u, error_callback, data));\n      if (u == NULL)\n\tgoto fail;\n      u->unit_data = unit_buf.buf;\n      u->unit_data_len = unit_buf.left;\n      u->unit_data_offset = unit_buf.buf - unit_data_start;\n      u->version = version;\n      u->is_dwarf64 = is_dwarf64;\n      u->addrsize = addrsize;\n      u->filename = NULL;\n      u->comp_dir = NULL;\n      u->abs_filename = NULL;\n      u->lineoff = 0;\n      u->abbrevs = abbrevs;\n      memset (&abbrevs, 0, sizeof abbrevs);\n\n      /* The actual line number mappings will be read as needed.  */\n      u->lines = NULL;\n      u->lines_count = 0;\n      u->function_addrs = NULL;\n      u->function_addrs_count = 0;\n\n      if (!find_address_ranges (state, base_address, &unit_buf,\n\t\t\t\tdwarf_str, dwarf_str_size,\n\t\t\t\tdwarf_ranges, dwarf_ranges_size,\n\t\t\t\tis_bigendian, error_callback, data,\n\t\t\t\tu, addrs))\n\t{\n\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n\t  goto fail;\n\t}\n\n      if (unit_buf.reported_underflow)\n\t{\n\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n\t  goto fail;\n\t}\n    }\n  if (info.reported_underflow)\n    goto fail;\n\n  return 1;\n\n fail:\n  free_abbrevs (state, &abbrevs, error_callback, data);\n  free_unit_addrs_vector (state, addrs, error_callback, data);\n  return 0;\n}\n\n/* Add a new mapping to the vector of line mappings that we are\n   building.  Returns 1 on success, 0 on failure.  */\n\nstatic int\nadd_line (struct backtrace_state *state, struct dwarf_data *ddata,\n\t  uintptr_t pc, const char *filename, int lineno,\n\t  backtrace_error_callback error_callback, void *data,\n\t  struct line_vector *vec)\n{\n  struct line *ln;\n\n  /* If we are adding the same mapping, ignore it.  This can happen\n     when using discriminators.  */\n  if (vec->count > 0)\n    {\n      ln = (struct line *) vec->vec.base + (vec->count - 1);\n      if (pc == ln->pc && filename == ln->filename && lineno == ln->lineno)\n\treturn 1;\n    }\n\n  ln = ((struct line *)\n\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n\t\t\t       data, &vec->vec));\n  if (ln == NULL)\n    return 0;\n\n  /* Add in the base address here, so that we can look up the PC\n     directly.  */\n  ln->pc = pc + ddata->base_address;\n\n  ln->filename = filename;\n  ln->lineno = lineno;\n  ln->idx = vec->count;\n\n  ++vec->count;\n\n  return 1;\n}\n\n/* Free the line header information.  */\n\nstatic void\nfree_line_header (struct backtrace_state *state, struct line_header *hdr,\n\t\t  backtrace_error_callback error_callback, void *data)\n{\n  if (hdr->dirs_count != 0)\n    backtrace_free (state, hdr->dirs, hdr->dirs_count * sizeof (const char *),\n\t\t    error_callback, data);\n  backtrace_free (state, hdr->filenames,\n\t\t  hdr->filenames_count * sizeof (char *),\n\t\t  error_callback, data);\n}\n\n/* Read the line header.  Return 1 on success, 0 on failure.  */\n\nstatic int\nread_line_header (struct backtrace_state *state, struct unit *u,\n\t\t  int is_dwarf64, struct dwarf_buf *line_buf,\n\t\t  struct line_header *hdr)\n{\n  uint64_t hdrlen;\n  struct dwarf_buf hdr_buf;\n  const unsigned char *p;\n  const unsigned char *pend;\n  size_t i;\n\n  hdr->version = read_uint16 (line_buf);\n  if (hdr->version < 2 || hdr->version > 4)\n    {\n      dwarf_buf_error (line_buf, \"unsupported line number version\");\n      return 0;\n    }\n\n  hdrlen = read_offset (line_buf, is_dwarf64);\n\n  hdr_buf = *line_buf;\n  hdr_buf.left = hdrlen;\n\n  if (!advance (line_buf, hdrlen))\n    return 0;\n\n  hdr->min_insn_len = read_byte (&hdr_buf);\n  if (hdr->version < 4)\n    hdr->max_ops_per_insn = 1;\n  else\n    hdr->max_ops_per_insn = read_byte (&hdr_buf);\n\n  /* We don't care about default_is_stmt.  */\n  read_byte (&hdr_buf);\n\n  hdr->line_base = read_sbyte (&hdr_buf);\n  hdr->line_range = read_byte (&hdr_buf);\n\n  hdr->opcode_base = read_byte (&hdr_buf);\n  hdr->opcode_lengths = hdr_buf.buf;\n  if (!advance (&hdr_buf, hdr->opcode_base - 1))\n    return 0;\n\n  /* Count the number of directory entries.  */\n  hdr->dirs_count = 0;\n  p = hdr_buf.buf;\n  pend = p + hdr_buf.left;\n  while (p < pend && *p != '\\0')\n    {\n      p += strnlen((const char *) p, pend - p) + 1;\n      ++hdr->dirs_count;\n    }\n\n  hdr->dirs = NULL;\n  if (hdr->dirs_count != 0)\n    {\n      hdr->dirs = ((const char **)\n\t\t   backtrace_alloc (state,\n\t\t\t\t    hdr->dirs_count * sizeof (const char *),\n\t\t\t\t    line_buf->error_callback, line_buf->data));\n      if (hdr->dirs == NULL)\n\treturn 0;\n    }\n\n  i = 0;\n  while (*hdr_buf.buf != '\\0')\n    {\n      if (hdr_buf.reported_underflow)\n\treturn 0;\n\n      hdr->dirs[i] = (const char *) hdr_buf.buf;\n      ++i;\n      if (!advance (&hdr_buf,\n\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n\treturn 0;\n    }\n  if (!advance (&hdr_buf, 1))\n    return 0;\n\n  /* Count the number of file entries.  */\n  hdr->filenames_count = 0;\n  p = hdr_buf.buf;\n  pend = p + hdr_buf.left;\n  while (p < pend && *p != '\\0')\n    {\n      p += strnlen ((const char *) p, pend - p) + 1;\n      p += leb128_len (p);\n      p += leb128_len (p);\n      p += leb128_len (p);\n      ++hdr->filenames_count;\n    }\n\n  hdr->filenames = ((const char **)\n\t\t    backtrace_alloc (state,\n\t\t\t\t     hdr->filenames_count * sizeof (char *),\n\t\t\t\t     line_buf->error_callback,\n\t\t\t\t     line_buf->data));\n  if (hdr->filenames == NULL)\n    return 0;\n  i = 0;\n  while (*hdr_buf.buf != '\\0')\n    {\n      const char *filename;\n      uint64_t dir_index;\n\n      if (hdr_buf.reported_underflow)\n\treturn 0;\n\n      filename = (const char *) hdr_buf.buf;\n      if (!advance (&hdr_buf,\n\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n\treturn 0;\n      dir_index = read_uleb128 (&hdr_buf);\n      if (IS_ABSOLUTE_PATH (filename)\n\t  || (dir_index == 0 && u->comp_dir == NULL))\n\thdr->filenames[i] = filename;\n      else\n\t{\n\t  const char *dir;\n\t  size_t dir_len;\n\t  size_t filename_len;\n\t  char *s;\n\n\t  if (dir_index == 0)\n\t    dir = u->comp_dir;\n\t  else if (dir_index - 1 < hdr->dirs_count)\n\t    dir = hdr->dirs[dir_index - 1];\n\t  else\n\t    {\n\t      dwarf_buf_error (line_buf,\n\t\t\t       (\"invalid directory index in \"\n\t\t\t\t\"line number program header\"));\n\t      return 0;\n\t    }\n\t  dir_len = strlen (dir);\n\t  filename_len = strlen (filename);\n\t  s = ((char *)\n\t       backtrace_alloc (state, dir_len + filename_len + 2,\n\t\t\t\tline_buf->error_callback, line_buf->data));\n\t  if (s == NULL)\n\t    return 0;\n\t  memcpy (s, dir, dir_len);\n\t  /* FIXME: If we are on a DOS-based file system, and the\n\t     directory or the file name use backslashes, then we\n\t     should use a backslash here.  */\n\t  s[dir_len] = '/';\n\t  memcpy (s + dir_len + 1, filename, filename_len + 1);\n\t  hdr->filenames[i] = s;\n\t}\n\n      /* Ignore the modification time and size.  */\n      read_uleb128 (&hdr_buf);\n      read_uleb128 (&hdr_buf);\n\n      ++i;\n    }\n\n  if (hdr_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Read the line program, adding line mappings to VEC.  Return 1 on\n   success, 0 on failure.  */\n\nstatic int\nread_line_program (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t   struct unit *u, const struct line_header *hdr,\n\t\t   struct dwarf_buf *line_buf, struct line_vector *vec)\n{\n  uint64_t address;\n  unsigned int op_index;\n  const char *reset_filename;\n  const char *filename;\n  int lineno;\n\n  address = 0;\n  op_index = 0;\n  if (hdr->filenames_count > 0)\n    reset_filename = hdr->filenames[0];\n  else\n    reset_filename = \"\";\n  filename = reset_filename;\n  lineno = 1;\n  while (line_buf->left > 0)\n    {\n      unsigned int op;\n\n      op = read_byte (line_buf);\n      if (op >= hdr->opcode_base)\n\t{\n\t  unsigned int advance;\n\n\t  /* Special opcode.  */\n\t  op -= hdr->opcode_base;\n\t  advance = op / hdr->line_range;\n\t  address += (hdr->min_insn_len * (op_index + advance)\n\t\t      / hdr->max_ops_per_insn);\n\t  op_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t  lineno += hdr->line_base + (int) (op % hdr->line_range);\n\t  add_line (state, ddata, address, filename, lineno,\n\t\t    line_buf->error_callback, line_buf->data, vec);\n\t}\n      else if (op == DW_LNS_extended_op)\n\t{\n\t  uint64_t len;\n\n\t  len = read_uleb128 (line_buf);\n\t  op = read_byte (line_buf);\n\t  switch (op)\n\t    {\n\t    case DW_LNE_end_sequence:\n\t      /* FIXME: Should we mark the high PC here?  It seems\n\t\t that we already have that information from the\n\t\t compilation unit.  */\n\t      address = 0;\n\t      op_index = 0;\n\t      filename = reset_filename;\n\t      lineno = 1;\n\t      break;\n\t    case DW_LNE_set_address:\n\t      address = read_address (line_buf, u->addrsize);\n\t      break;\n\t    case DW_LNE_define_file:\n\t      {\n\t\tconst char *f;\n\t\tunsigned int dir_index;\n\n\t\tf = (const char *) line_buf->buf;\n\t\tif (!advance (line_buf, strnlen (f, line_buf->left) + 1))\n\t\t  return 0;\n\t\tdir_index = read_uleb128 (line_buf);\n\t\t/* Ignore that time and length.  */\n\t\tread_uleb128 (line_buf);\n\t\tread_uleb128 (line_buf);\n\t\tif (IS_ABSOLUTE_PATH (f))\n\t\t  filename = f;\n\t\telse\n\t\t  {\n\t\t    const char *dir;\n\t\t    size_t dir_len;\n\t\t    size_t f_len;\n\t\t    char *p;\n\n\t\t    if (dir_index == 0)\n\t\t      dir = u->comp_dir;\n\t\t    else if (dir_index - 1 < hdr->dirs_count)\n\t\t      dir = hdr->dirs[dir_index - 1];\n\t\t    else\n\t\t      {\n\t\t\tdwarf_buf_error (line_buf,\n\t\t\t\t\t (\"invalid directory index \"\n\t\t\t\t\t  \"in line number program\"));\n\t\t\treturn 0;\n\t\t      }\n\t\t    dir_len = strlen (dir);\n\t\t    f_len = strlen (f);\n\t\t    p = ((char *)\n\t\t\t backtrace_alloc (state, dir_len + f_len + 2,\n\t\t\t\t\t  line_buf->error_callback,\n\t\t\t\t\t  line_buf->data));\n\t\t    if (p == NULL)\n\t\t      return 0;\n\t\t    memcpy (p, dir, dir_len);\n\t\t    /* FIXME: If we are on a DOS-based file system,\n\t\t       and the directory or the file name use\n\t\t       backslashes, then we should use a backslash\n\t\t       here.  */\n\t\t    p[dir_len] = '/';\n\t\t    memcpy (p + dir_len + 1, f, f_len + 1);\n\t\t    filename = p;\n\t\t  }\n\t      }\n\t      break;\n\t    case DW_LNE_set_discriminator:\n\t      /* We don't care about discriminators.  */\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    default:\n\t      if (!advance (line_buf, len - 1))\n\t\treturn 0;\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  switch (op)\n\t    {\n\t    case DW_LNS_copy:\n\t      add_line (state, ddata, address, filename, lineno,\n\t\t\tline_buf->error_callback, line_buf->data, vec);\n\t      break;\n\t    case DW_LNS_advance_pc:\n\t      {\n\t\tuint64_t advance;\n\n\t\tadvance = read_uleb128 (line_buf);\n\t\taddress += (hdr->min_insn_len * (op_index + advance)\n\t\t\t    / hdr->max_ops_per_insn);\n\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t      }\n\t      break;\n\t    case DW_LNS_advance_line:\n\t      lineno += (int) read_sleb128 (line_buf);\n\t      break;\n\t    case DW_LNS_set_file:\n\t      {\n\t\tuint64_t fileno;\n\n\t\tfileno = read_uleb128 (line_buf);\n\t\tif (fileno == 0)\n\t\t  filename = \"\";\n\t\telse\n\t\t  {\n\t\t    if (fileno - 1 >= hdr->filenames_count)\n\t\t      {\n\t\t\tdwarf_buf_error (line_buf,\n\t\t\t\t\t (\"invalid file number in \"\n\t\t\t\t\t  \"line number program\"));\n\t\t\treturn 0;\n\t\t      }\n\t\t    filename = hdr->filenames[fileno - 1];\n\t\t  }\n\t      }\n\t      break;\n\t    case DW_LNS_set_column:\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    case DW_LNS_negate_stmt:\n\t      break;\n\t    case DW_LNS_set_basic_block:\n\t      break;\n\t    case DW_LNS_const_add_pc:\n\t      {\n\t\tunsigned int advance;\n\n\t\top = 255 - hdr->opcode_base;\n\t\tadvance = op / hdr->line_range;\n\t\taddress += (hdr->min_insn_len * (op_index + advance)\n\t\t\t    / hdr->max_ops_per_insn);\n\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t      }\n\t      break;\n\t    case DW_LNS_fixed_advance_pc:\n\t      address += read_uint16 (line_buf);\n\t      op_index = 0;\n\t      break;\n\t    case DW_LNS_set_prologue_end:\n\t      break;\n\t    case DW_LNS_set_epilogue_begin:\n\t      break;\n\t    case DW_LNS_set_isa:\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    default:\n\t      {\n\t\tunsigned int i;\n\n\t\tfor (i = hdr->opcode_lengths[op - 1]; i > 0; --i)\n\t\t  read_uleb128 (line_buf);\n\t      }\n\t      break;\n\t    }\n\t}\n    }\n\n  return 1;\n}\n\n/* Read the line number information for a compilation unit.  Returns 1\n   on success, 0 on failure.  */\n\nstatic int\nread_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\tbacktrace_error_callback error_callback, void *data,\n\t\tstruct unit *u, struct line_header *hdr, struct line **lines,\n\t\tsize_t *lines_count)\n{\n  struct line_vector vec;\n  struct dwarf_buf line_buf;\n  uint64_t len;\n  int is_dwarf64;\n  struct line *ln;\n\n  memset (&vec.vec, 0, sizeof vec.vec);\n  vec.count = 0;\n\n  memset (hdr, 0, sizeof *hdr);\n\n  if (u->lineoff != (off_t) (size_t) u->lineoff\n      || (size_t) u->lineoff >= ddata->dwarf_line_size)\n    {\n      error_callback (data, \"unit line offset out of range\", 0);\n      goto fail;\n    }\n\n  line_buf.name = \".debug_line\";\n  line_buf.start = ddata->dwarf_line;\n  line_buf.buf = ddata->dwarf_line + u->lineoff;\n  line_buf.left = ddata->dwarf_line_size - u->lineoff;\n  line_buf.is_bigendian = ddata->is_bigendian;\n  line_buf.error_callback = error_callback;\n  line_buf.data = data;\n  line_buf.reported_underflow = 0;\n\n  is_dwarf64 = 0;\n  len = read_uint32 (&line_buf);\n  if (len == 0xffffffff)\n    {\n      len = read_uint64 (&line_buf);\n      is_dwarf64 = 1;\n    }\n  line_buf.left = len;\n\n  if (!read_line_header (state, u, is_dwarf64, &line_buf, hdr))\n    goto fail;\n\n  if (!read_line_program (state, ddata, u, hdr, &line_buf, &vec))\n    goto fail;\n\n  if (line_buf.reported_underflow)\n    goto fail;\n\n  if (vec.count == 0)\n    {\n      /* This is not a failure in the sense of a generating an error,\n\t but it is a failure in that sense that we have no useful\n\t information.  */\n      goto fail;\n    }\n\n  /* Allocate one extra entry at the end.  */\n  ln = ((struct line *)\n\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n\t\t\t       data, &vec.vec));\n  if (ln == NULL)\n    goto fail;\n  ln->pc = (uintptr_t) -1;\n  ln->filename = NULL;\n  ln->lineno = 0;\n  ln->idx = 0;\n\n  if (!backtrace_vector_release (state, &vec.vec, error_callback, data))\n    goto fail;\n\n  ln = (struct line *) vec.vec.base;\n  backtrace_qsort (ln, vec.count, sizeof (struct line), line_compare);\n\n  *lines = ln;\n  *lines_count = vec.count;\n\n  return 1;\n\n fail:\n  vec.vec.alc += vec.vec.size;\n  vec.vec.size = 0;\n  backtrace_vector_release (state, &vec.vec, error_callback, data);\n  free_line_header (state, hdr, error_callback, data);\n  *lines = (struct line *) (uintptr_t) -1;\n  *lines_count = 0;\n  return 0;\n}\n\n/* Read the name of a function from a DIE referenced by a\n   DW_AT_abstract_origin or DW_AT_specification tag.  OFFSET is within\n   the same compilation unit.  */\n\nstatic const char *\nread_referenced_name (struct dwarf_data *ddata, struct unit *u,\n\t\t      uint64_t offset, backtrace_error_callback error_callback,\n\t\t      void *data)\n{\n  struct dwarf_buf unit_buf;\n  uint64_t code;\n  const struct abbrev *abbrev;\n  const char *ret;\n  size_t i;\n\n  /* OFFSET is from the start of the data for this compilation unit.\n     U->unit_data is the data, but it starts U->unit_data_offset bytes\n     from the beginning.  */\n\n  if (offset < u->unit_data_offset\n      || offset - u->unit_data_offset >= u->unit_data_len)\n    {\n      error_callback (data,\n\t\t      \"abstract origin or specification out of range\",\n\t\t      0);\n      return NULL;\n    }\n\n  offset -= u->unit_data_offset;\n\n  unit_buf.name = \".debug_info\";\n  unit_buf.start = ddata->dwarf_info;\n  unit_buf.buf = u->unit_data + offset;\n  unit_buf.left = u->unit_data_len - offset;\n  unit_buf.is_bigendian = ddata->is_bigendian;\n  unit_buf.error_callback = error_callback;\n  unit_buf.data = data;\n  unit_buf.reported_underflow = 0;\n\n  code = read_uleb128 (&unit_buf);\n  if (code == 0)\n    {\n      dwarf_buf_error (&unit_buf, \"invalid abstract origin or specification\");\n      return NULL;\n    }\n\n  abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n  if (abbrev == NULL)\n    return NULL;\n\n  ret = NULL;\n  for (i = 0; i < abbrev->num_attrs; ++i)\n    {\n      struct attr_val val;\n\n      if (!read_attribute (abbrev->attrs[i].form, &unit_buf,\n\t\t\t   u->is_dwarf64, u->version, u->addrsize,\n\t\t\t   ddata->dwarf_str, ddata->dwarf_str_size,\n\t\t\t   &val))\n\treturn NULL;\n\n      switch (abbrev->attrs[i].name)\n\t{\n\tcase DW_AT_name:\n\t  /* We prefer the linkage name if get one.  */\n\t  if (val.encoding == ATTR_VAL_STRING)\n\t    ret = val.u.string;\n\t  break;\n\n\tcase DW_AT_linkage_name:\n\tcase DW_AT_MIPS_linkage_name:\n\t  if (val.encoding == ATTR_VAL_STRING)\n\t    return val.u.string;\n\t  break;\n\n\tcase DW_AT_specification:\n\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n\t    {\n\t      /* This refers to a specification defined in some other\n\t\t compilation unit.  We can handle this case if we\n\t\t must, but it's harder.  */\n\t      break;\n\t    }\n\t  if (val.encoding == ATTR_VAL_UINT\n\t      || val.encoding == ATTR_VAL_REF_UNIT)\n\t    {\n\t      const char *name;\n\n\t      name = read_referenced_name (ddata, u, val.u.uint,\n\t\t\t\t\t   error_callback, data);\n\t      if (name != NULL)\n\t\tret = name;\n\t    }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\n  return ret;\n}\n\n/* Add a single range to U that maps to function.  Returns 1 on\n   success, 0 on error.  */\n\nstatic int\nadd_function_range (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t    struct function *function, uint64_t lowpc, uint64_t highpc,\n\t\t    backtrace_error_callback error_callback,\n\t\t    void *data, struct function_vector *vec)\n{\n  struct function_addrs *p;\n\n  /* Add in the base address here, so that we can look up the PC\n     directly.  */\n  lowpc += ddata->base_address;\n  highpc += ddata->base_address;\n\n  if (vec->count > 0)\n    {\n      p = (struct function_addrs *) vec->vec.base + vec->count - 1;\n      if ((lowpc == p->high || lowpc == p->high + 1)\n\t  && function == p->function)\n\t{\n\t  if (highpc > p->high)\n\t    p->high = highpc;\n\t  return 1;\n\t}\n    }\n\n  p = ((struct function_addrs *)\n       backtrace_vector_grow (state, sizeof (struct function_addrs),\n\t\t\t      error_callback, data, &vec->vec));\n  if (p == NULL)\n    return 0;\n\n  p->low = lowpc;\n  p->high = highpc;\n  p->function = function;\n  ++vec->count;\n  return 1;\n}\n\n/* Add PC ranges to U that map to FUNCTION.  Returns 1 on success, 0\n   on error.  */\n\nstatic int\nadd_function_ranges (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t     struct unit *u, struct function *function,\n\t\t     uint64_t ranges, uint64_t base,\n\t\t     backtrace_error_callback error_callback, void *data,\n\t\t     struct function_vector *vec)\n{\n  struct dwarf_buf ranges_buf;\n\n  if (ranges >= ddata->dwarf_ranges_size)\n    {\n      error_callback (data, \"function ranges offset out of range\", 0);\n      return 0;\n    }\n\n  ranges_buf.name = \".debug_ranges\";\n  ranges_buf.start = ddata->dwarf_ranges;\n  ranges_buf.buf = ddata->dwarf_ranges + ranges;\n  ranges_buf.left = ddata->dwarf_ranges_size - ranges;\n  ranges_buf.is_bigendian = ddata->is_bigendian;\n  ranges_buf.error_callback = error_callback;\n  ranges_buf.data = data;\n  ranges_buf.reported_underflow = 0;\n\n  while (1)\n    {\n      uint64_t low;\n      uint64_t high;\n\n      if (ranges_buf.reported_underflow)\n\treturn 0;\n\n      low = read_address (&ranges_buf, u->addrsize);\n      high = read_address (&ranges_buf, u->addrsize);\n\n      if (low == 0 && high == 0)\n\tbreak;\n\n      if (is_highest_address (low, u->addrsize))\n\tbase = high;\n      else\n\t{\n\t  if (!add_function_range (state, ddata, function, low + base,\n\t\t\t\t   high + base, error_callback, data, vec))\n\t    return 0;\n\t}\n    }\n\n  if (ranges_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Read one entry plus all its children.  Add function addresses to\n   VEC.  Returns 1 on success, 0 on error.  */\n\nstatic int\nread_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t     struct unit *u, uint64_t base, struct dwarf_buf *unit_buf,\n\t\t     const struct line_header *lhdr,\n\t\t     backtrace_error_callback error_callback, void *data,\n\t\t     struct function_vector *vec_function,\n\t\t     struct function_vector *vec_inlined)\n{\n  while (unit_buf->left > 0)\n    {\n      uint64_t code;\n      const struct abbrev *abbrev;\n      int is_function;\n      struct function *function;\n      struct function_vector *vec;\n      size_t i;\n      uint64_t lowpc;\n      int have_lowpc;\n      uint64_t highpc;\n      int have_highpc;\n      int highpc_is_relative;\n      uint64_t ranges;\n      int have_ranges;\n\n      code = read_uleb128 (unit_buf);\n      if (code == 0)\n\treturn 1;\n\n      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n      if (abbrev == NULL)\n\treturn 0;\n\n      is_function = (abbrev->tag == DW_TAG_subprogram\n\t\t     || abbrev->tag == DW_TAG_entry_point\n\t\t     || abbrev->tag == DW_TAG_inlined_subroutine);\n\n      if (abbrev->tag == DW_TAG_inlined_subroutine)\n\tvec = vec_inlined;\n      else\n\tvec = vec_function;\n\n      function = NULL;\n      if (is_function)\n\t{\n\t  function = ((struct function *)\n\t\t      backtrace_alloc (state, sizeof *function,\n\t\t\t\t       error_callback, data));\n\t  if (function == NULL)\n\t    return 0;\n\t  memset (function, 0, sizeof *function);\n\t}\n\n      lowpc = 0;\n      have_lowpc = 0;\n      highpc = 0;\n      have_highpc = 0;\n      highpc_is_relative = 0;\n      ranges = 0;\n      have_ranges = 0;\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attr_val val;\n\n\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n\t\t\t       ddata->dwarf_str, ddata->dwarf_str_size,\n\t\t\t       &val))\n\t    return 0;\n\n\t  /* The compile unit sets the base address for any address\n\t     ranges in the function entries.  */\n\t  if (abbrev->tag == DW_TAG_compile_unit\n\t      && abbrev->attrs[i].name == DW_AT_low_pc\n\t      && val.encoding == ATTR_VAL_ADDRESS)\n\t    base = val.u.uint;\n\n\t  if (is_function)\n\t    {\n\t      switch (abbrev->attrs[i].name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  if (val.encoding == ATTR_VAL_UINT)\n\t\t    {\n\t\t      if (val.u.uint == 0)\n\t\t\tfunction->caller_filename = \"\";\n\t\t      else\n\t\t\t{\n\t\t\t  if (val.u.uint - 1 >= lhdr->filenames_count)\n\t\t\t    {\n\t\t\t      dwarf_buf_error (unit_buf,\n\t\t\t\t\t       (\"invalid file number in \"\n\t\t\t\t\t\t\"DW_AT_call_file attribute\"));\n\t\t\t      return 0;\n\t\t\t    }\n\t\t\t  function->caller_filename =\n\t\t\t    lhdr->filenames[val.u.uint - 1];\n\t\t\t}\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  if (val.encoding == ATTR_VAL_UINT)\n\t\t    function->caller_lineno = val.u.uint;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n\t\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n\t\t    {\n\t\t      /* This refers to an abstract origin defined in\n\t\t\t some other compilation unit.  We can handle\n\t\t\t this case if we must, but it's harder.  */\n\t\t      break;\n\t\t    }\n\t\t  if (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_UNIT)\n\t\t    {\n\t\t      const char *name;\n\n\t\t      name = read_referenced_name (ddata, u, val.u.uint,\n\t\t\t\t\t\t   error_callback, data);\n\t\t      if (name != NULL)\n\t\t\tfunction->name = name;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  if (val.encoding == ATTR_VAL_STRING)\n\t\t    {\n\t\t      /* Don't override a name we found in some other\n\t\t\t way, as it will normally be more\n\t\t\t useful--e.g., this name is normally not\n\t\t\t mangled.  */\n\t\t      if (function->name == NULL)\n\t\t\tfunction->name = val.u.string;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  if (val.encoding == ATTR_VAL_STRING)\n\t\t    function->name = val.u.string;\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t    {\n\t\t      lowpc = val.u.uint;\n\t\t      have_lowpc = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t    {\n\t\t      highpc = val.u.uint;\n\t\t      have_highpc = 1;\n\t\t    }\n\t\t  else if (val.encoding == ATTR_VAL_UINT)\n\t\t    {\n\t\t      highpc = val.u.uint;\n\t\t      have_highpc = 1;\n\t\t      highpc_is_relative = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_SECTION)\n\t\t    {\n\t\t      ranges = val.u.uint;\n\t\t      have_ranges = 1;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      /* If we couldn't find a name for the function, we have no use\n\t for it.  */\n      if (is_function && function->name == NULL)\n\t{\n\t  backtrace_free (state, function, sizeof *function,\n\t\t\t  error_callback, data);\n\t  is_function = 0;\n\t}\n\n      if (is_function)\n\t{\n\t  if (have_ranges)\n\t    {\n\t      if (!add_function_ranges (state, ddata, u, function, ranges,\n\t\t\t\t\tbase, error_callback, data, vec))\n\t\treturn 0;\n\t    }\n\t  else if (have_lowpc && have_highpc)\n\t    {\n\t      if (highpc_is_relative)\n\t\thighpc += lowpc;\n\t      if (!add_function_range (state, ddata, function, lowpc, highpc,\n\t\t\t\t       error_callback, data, vec))\n\t\treturn 0;\n\t    }\n\t  else\n\t    {\n\t      backtrace_free (state, function, sizeof *function,\n\t\t\t      error_callback, data);\n\t      is_function = 0;\n\t    }\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  if (!is_function)\n\t    {\n\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n\t\t\t\t\terror_callback, data, vec_function,\n\t\t\t\t\tvec_inlined))\n\t\treturn 0;\n\t    }\n\t  else\n\t    {\n\t      struct function_vector fvec;\n\n\t      /* Gather any information for inlined functions in\n\t\t FVEC.  */\n\n\t      memset (&fvec, 0, sizeof fvec);\n\n\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n\t\t\t\t\terror_callback, data, vec_function,\n\t\t\t\t\t&fvec))\n\t\treturn 0;\n\n\t      if (fvec.count > 0)\n\t\t{\n\t\t  struct function_addrs *faddrs;\n\n\t\t  if (!backtrace_vector_release (state, &fvec.vec,\n\t\t\t\t\t\t error_callback, data))\n\t\t    return 0;\n\n\t\t  faddrs = (struct function_addrs *) fvec.vec.base;\n\t\t  backtrace_qsort (faddrs, fvec.count,\n\t\t\t\t   sizeof (struct function_addrs),\n\t\t\t\t   function_addrs_compare);\n\n\t\t  function->function_addrs = faddrs;\n\t\t  function->function_addrs_count = fvec.count;\n\t\t}\n\t    }\n\t}\n    }\n\n  return 1;\n}\n\n/* Read function name information for a compilation unit.  We look\n   through the whole unit looking for function tags.  */\n\nstatic void\nread_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t    const struct line_header *lhdr,\n\t\t    backtrace_error_callback error_callback, void *data,\n\t\t    struct unit *u, struct function_vector *fvec,\n\t\t    struct function_addrs **ret_addrs,\n\t\t    size_t *ret_addrs_count)\n{\n  struct function_vector lvec;\n  struct function_vector *pfvec;\n  struct dwarf_buf unit_buf;\n  struct function_addrs *addrs;\n  size_t addrs_count;\n\n  /* Use FVEC if it is not NULL.  Otherwise use our own vector.  */\n  if (fvec != NULL)\n    pfvec = fvec;\n  else\n    {\n      memset (&lvec, 0, sizeof lvec);\n      pfvec = &lvec;\n    }\n\n  unit_buf.name = \".debug_info\";\n  unit_buf.start = ddata->dwarf_info;\n  unit_buf.buf = u->unit_data;\n  unit_buf.left = u->unit_data_len;\n  unit_buf.is_bigendian = ddata->is_bigendian;\n  unit_buf.error_callback = error_callback;\n  unit_buf.data = data;\n  unit_buf.reported_underflow = 0;\n\n  while (unit_buf.left > 0)\n    {\n      if (!read_function_entry (state, ddata, u, 0, &unit_buf, lhdr,\n\t\t\t\terror_callback, data, pfvec, pfvec))\n\treturn;\n    }\n\n  if (pfvec->count == 0)\n    return;\n\n  addrs_count = pfvec->count;\n\n  if (fvec == NULL)\n    {\n      if (!backtrace_vector_release (state, &lvec.vec, error_callback, data))\n\treturn;\n      addrs = (struct function_addrs *) pfvec->vec.base;\n    }\n  else\n    {\n      /* Finish this list of addresses, but leave the remaining space in\n\t the vector available for the next function unit.  */\n      addrs = ((struct function_addrs *)\n\t       backtrace_vector_finish (state, &fvec->vec,\n\t\t\t\t\terror_callback, data));\n      if (addrs == NULL)\n\treturn;\n      fvec->count = 0;\n    }\n\n  backtrace_qsort (addrs, addrs_count, sizeof (struct function_addrs),\n\t\t   function_addrs_compare);\n\n  *ret_addrs = addrs;\n  *ret_addrs_count = addrs_count;\n}\n\n/* See if PC is inlined in FUNCTION.  If it is, print out the inlined\n   information, and update FILENAME and LINENO for the caller.\n   Returns whatever CALLBACK returns, or 0 to keep going.  */\n\nstatic int\nreport_inlined_functions (uintptr_t pc, struct function *function,\n\t\t\t  backtrace_full_callback callback, void *data,\n\t\t\t  const char **filename, int *lineno)\n{\n  struct function_addrs *function_addrs;\n  struct function *inlined;\n  int ret;\n\n  if (function->function_addrs_count == 0)\n    return 0;\n\n  function_addrs = ((struct function_addrs *)\n\t\t    bsearch (&pc, function->function_addrs,\n\t\t\t     function->function_addrs_count,\n\t\t\t     sizeof (struct function_addrs),\n\t\t\t     function_addrs_search));\n  if (function_addrs == NULL)\n    return 0;\n\n  while (((size_t) (function_addrs - function->function_addrs) + 1\n\t  < function->function_addrs_count)\n\t && pc >= (function_addrs + 1)->low\n\t && pc < (function_addrs + 1)->high)\n    ++function_addrs;\n\n  /* We found an inlined call.  */\n\n  inlined = function_addrs->function;\n\n  /* Report any calls inlined into this one.  */\n  ret = report_inlined_functions (pc, inlined, callback, data,\n\t\t\t\t  filename, lineno);\n  if (ret != 0)\n    return ret;\n\n  /* Report this inlined call.  */\n  ret = callback (data, pc, *filename, *lineno, inlined->name);\n  if (ret != 0)\n    return ret;\n\n  /* Our caller will report the caller of the inlined function; tell\n     it the appropriate filename and line number.  */\n  *filename = inlined->caller_filename;\n  *lineno = inlined->caller_lineno;\n\n  return 0;\n}\n\n/* Look for a PC in the DWARF mapping for one module.  On success,\n   call CALLBACK and return whatever it returns.  On error, call\n   ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n   0 if not.  */\n\nstatic int\ndwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t uintptr_t pc, backtrace_full_callback callback,\n\t\t backtrace_error_callback error_callback, void *data,\n\t\t int *found)\n{\n  struct unit_addrs *entry;\n  struct unit *u;\n  int new_data;\n  struct line *lines;\n  struct line *ln;\n  struct function_addrs *function_addrs;\n  struct function *function;\n  const char *filename;\n  int lineno;\n  int ret;\n\n  *found = 1;\n\n  /* Find an address range that includes PC.  */\n  entry = bsearch (&pc, ddata->addrs, ddata->addrs_count,\n\t\t   sizeof (struct unit_addrs), unit_addrs_search);\n\n  if (entry == NULL)\n    {\n      *found = 0;\n      return 0;\n    }\n\n  /* If there are multiple ranges that contain PC, use the last one,\n     in order to produce predictable results.  If we assume that all\n     ranges are properly nested, then the last range will be the\n     smallest one.  */\n  while ((size_t) (entry - ddata->addrs) + 1 < ddata->addrs_count\n\t && pc >= (entry + 1)->low\n\t && pc < (entry + 1)->high)\n    ++entry;\n\n  /* We need the lines, lines_count, function_addrs,\n     function_addrs_count fields of u.  If they are not set, we need\n     to set them.  When running in threaded mode, we need to allow for\n     the possibility that some other thread is setting them\n     simultaneously.  */\n\n  u = entry->u;\n  lines = u->lines;\n\n  /* Skip units with no useful line number information by walking\n     backward.  Useless line number information is marked by setting\n     lines == -1.  */\n  while (entry > ddata->addrs\n\t && pc >= (entry - 1)->low\n\t && pc < (entry - 1)->high)\n    {\n      if (state->threaded)\n\tlines = (struct line *) backtrace_atomic_load_pointer (&u->lines);\n\n      if (lines != (struct line *) (uintptr_t) -1)\n\tbreak;\n\n      --entry;\n\n      u = entry->u;\n      lines = u->lines;\n    }\n\n  if (state->threaded)\n    lines = backtrace_atomic_load_pointer (&u->lines);\n\n  new_data = 0;\n  if (lines == NULL)\n    {\n      size_t function_addrs_count;\n      struct line_header lhdr;\n      size_t count;\n\n      /* We have never read the line information for this unit.  Read\n\t it now.  */\n\n      function_addrs = NULL;\n      function_addrs_count = 0;\n      if (read_line_info (state, ddata, error_callback, data, entry->u, &lhdr,\n\t\t\t  &lines, &count))\n\t{\n\t  struct function_vector *pfvec;\n\n\t  /* If not threaded, reuse DDATA->FVEC for better memory\n\t     consumption.  */\n\t  if (state->threaded)\n\t    pfvec = NULL;\n\t  else\n\t    pfvec = &ddata->fvec;\n\t  read_function_info (state, ddata, &lhdr, error_callback, data,\n\t\t\t      entry->u, pfvec, &function_addrs,\n\t\t\t      &function_addrs_count);\n\t  free_line_header (state, &lhdr, error_callback, data);\n\t  new_data = 1;\n\t}\n\n      /* Atomically store the information we just read into the unit.\n\t If another thread is simultaneously writing, it presumably\n\t read the same information, and we don't care which one we\n\t wind up with; we just leak the other one.  We do have to\n\t write the lines field last, so that the acquire-loads above\n\t ensure that the other fields are set.  */\n\n      if (!state->threaded)\n\t{\n\t  u->lines_count = count;\n\t  u->function_addrs = function_addrs;\n\t  u->function_addrs_count = function_addrs_count;\n\t  u->lines = lines;\n\t}\n      else\n\t{\n\t  backtrace_atomic_store_size_t (&u->lines_count, count);\n\t  backtrace_atomic_store_pointer (&u->function_addrs, function_addrs);\n\t  backtrace_atomic_store_size_t (&u->function_addrs_count,\n\t\t\t\t\t function_addrs_count);\n\t  backtrace_atomic_store_pointer (&u->lines, lines);\n\t}\n    }\n\n  /* Now all fields of U have been initialized.  */\n\n  if (lines == (struct line *) (uintptr_t) -1)\n    {\n      /* If reading the line number information failed in some way,\n\t try again to see if there is a better compilation unit for\n\t this PC.  */\n      if (new_data)\n\treturn dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\tdata, found);\n      return callback (data, pc, NULL, 0, NULL);\n    }\n\n  /* Search for PC within this unit.  */\n\n  ln = (struct line *) bsearch (&pc, lines, entry->u->lines_count,\n\t\t\t\tsizeof (struct line), line_search);\n  if (ln == NULL)\n    {\n      /* The PC is between the low_pc and high_pc attributes of the\n\t compilation unit, but no entry in the line table covers it.\n\t This implies that the start of the compilation unit has no\n\t line number information.  */\n\n      if (entry->u->abs_filename == NULL)\n\t{\n\t  const char *filename;\n\n\t  filename = entry->u->filename;\n\t  if (filename != NULL\n\t      && !IS_ABSOLUTE_PATH (filename)\n\t      && entry->u->comp_dir != NULL)\n\t    {\n\t      size_t filename_len;\n\t      const char *dir;\n\t      size_t dir_len;\n\t      char *s;\n\n\t      filename_len = strlen (filename);\n\t      dir = entry->u->comp_dir;\n\t      dir_len = strlen (dir);\n\t      s = (char *) backtrace_alloc (state, dir_len + filename_len + 2,\n\t\t\t\t\t    error_callback, data);\n\t      if (s == NULL)\n\t\t{\n\t\t  *found = 0;\n\t\t  return 0;\n\t\t}\n\t      memcpy (s, dir, dir_len);\n\t      /* FIXME: Should use backslash if DOS file system.  */\n\t      s[dir_len] = '/';\n\t      memcpy (s + dir_len + 1, filename, filename_len + 1);\n\t      filename = s;\n\t    }\n\t  entry->u->abs_filename = filename;\n\t}\n\n      return callback (data, pc, entry->u->abs_filename, 0, NULL);\n    }\n\n  /* Search for function name within this unit.  */\n\n  if (entry->u->function_addrs_count == 0)\n    return callback (data, pc, ln->filename, ln->lineno, NULL);\n\n  function_addrs = ((struct function_addrs *)\n\t\t    bsearch (&pc, entry->u->function_addrs,\n\t\t\t     entry->u->function_addrs_count,\n\t\t\t     sizeof (struct function_addrs),\n\t\t\t     function_addrs_search));\n  if (function_addrs == NULL)\n    return callback (data, pc, ln->filename, ln->lineno, NULL);\n\n  /* If there are multiple function ranges that contain PC, use the\n     last one, in order to produce predictable results.  */\n\n  while (((size_t) (function_addrs - entry->u->function_addrs + 1)\n\t  < entry->u->function_addrs_count)\n\t && pc >= (function_addrs + 1)->low\n\t && pc < (function_addrs + 1)->high)\n    ++function_addrs;\n\n  function = function_addrs->function;\n\n  filename = ln->filename;\n  lineno = ln->lineno;\n\n  ret = report_inlined_functions (pc, function, callback, data,\n\t\t\t\t  &filename, &lineno);\n  if (ret != 0)\n    return ret;\n\n  return callback (data, pc, filename, lineno, function->name);\n}\n\n\n/* Return the file/line information for a PC using the DWARF mapping\n   we built earlier.  */\n\nstatic int\ndwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n\t\tbacktrace_full_callback callback,\n\t\tbacktrace_error_callback error_callback, void *data)\n{\n  struct dwarf_data *ddata;\n  int found;\n  int ret;\n\n  if (!state->threaded)\n    {\n      for (ddata = (struct dwarf_data *) state->fileline_data;\n\t   ddata != NULL;\n\t   ddata = ddata->next)\n\t{\n\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\t data, &found);\n\t  if (ret != 0 || found)\n\t    return ret;\n\t}\n    }\n  else\n    {\n      struct dwarf_data **pp;\n\n      pp = (struct dwarf_data **) (void *) &state->fileline_data;\n      while (1)\n\t{\n\t  ddata = backtrace_atomic_load_pointer (pp);\n\t  if (ddata == NULL)\n\t    break;\n\n\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\t data, &found);\n\t  if (ret != 0 || found)\n\t    return ret;\n\n\t  pp = &ddata->next;\n\t}\n    }\n\n  /* FIXME: See if any libraries have been dlopen'ed.  */\n\n  return callback (data, pc, NULL, 0, NULL);\n}\n\n/* Initialize our data structures from the DWARF debug info for a\n   file.  Return NULL on failure.  */\n\nstatic struct dwarf_data *\nbuild_dwarf_data (struct backtrace_state *state,\n\t\t  uintptr_t base_address,\n\t\t  const unsigned char *dwarf_info,\n\t\t  size_t dwarf_info_size,\n\t\t  const unsigned char *dwarf_line,\n\t\t  size_t dwarf_line_size,\n\t\t  const unsigned char *dwarf_abbrev,\n\t\t  size_t dwarf_abbrev_size,\n\t\t  const unsigned char *dwarf_ranges,\n\t\t  size_t dwarf_ranges_size,\n\t\t  const unsigned char *dwarf_str,\n\t\t  size_t dwarf_str_size,\n\t\t  int is_bigendian,\n\t\t  backtrace_error_callback error_callback,\n\t\t  void *data)\n{\n  struct unit_addrs_vector addrs_vec;\n  struct unit_addrs *addrs;\n  size_t addrs_count;\n  struct dwarf_data *fdata;\n\n  if (!build_address_map (state, base_address, dwarf_info, dwarf_info_size,\n\t\t\t  dwarf_abbrev, dwarf_abbrev_size, dwarf_ranges,\n\t\t\t  dwarf_ranges_size, dwarf_str, dwarf_str_size,\n\t\t\t  is_bigendian, error_callback, data, &addrs_vec))\n    return NULL;\n\n  if (!backtrace_vector_release (state, &addrs_vec.vec, error_callback, data))\n    return NULL;\n  addrs = (struct unit_addrs *) addrs_vec.vec.base;\n  addrs_count = addrs_vec.count;\n  backtrace_qsort (addrs, addrs_count, sizeof (struct unit_addrs),\n\t\t   unit_addrs_compare);\n\n  fdata = ((struct dwarf_data *)\n\t   backtrace_alloc (state, sizeof (struct dwarf_data),\n\t\t\t    error_callback, data));\n  if (fdata == NULL)\n    return NULL;\n\n  fdata->next = NULL;\n  fdata->base_address = base_address;\n  fdata->addrs = addrs;\n  fdata->addrs_count = addrs_count;\n  fdata->dwarf_info = dwarf_info;\n  fdata->dwarf_info_size = dwarf_info_size;\n  fdata->dwarf_line = dwarf_line;\n  fdata->dwarf_line_size = dwarf_line_size;\n  fdata->dwarf_ranges = dwarf_ranges;\n  fdata->dwarf_ranges_size = dwarf_ranges_size;\n  fdata->dwarf_str = dwarf_str;\n  fdata->dwarf_str_size = dwarf_str_size;\n  fdata->is_bigendian = is_bigendian;\n  memset (&fdata->fvec, 0, sizeof fdata->fvec);\n\n  return fdata;\n}\n\n/* Build our data structures from the DWARF sections for a module.\n   Set FILELINE_FN and STATE->FILELINE_DATA.  Return 1 on success, 0\n   on failure.  */\n\nint\nbacktrace_dwarf_add (struct backtrace_state *state,\n\t\t     uintptr_t base_address,\n\t\t     const unsigned char *dwarf_info,\n\t\t     size_t dwarf_info_size,\n\t\t     const unsigned char *dwarf_line,\n\t\t     size_t dwarf_line_size,\n\t\t     const unsigned char *dwarf_abbrev,\n\t\t     size_t dwarf_abbrev_size,\n\t\t     const unsigned char *dwarf_ranges,\n\t\t     size_t dwarf_ranges_size,\n\t\t     const unsigned char *dwarf_str,\n\t\t     size_t dwarf_str_size,\n\t\t     int is_bigendian,\n\t\t     backtrace_error_callback error_callback,\n\t\t     void *data, fileline *fileline_fn)\n{\n  struct dwarf_data *fdata;\n\n  fdata = build_dwarf_data (state, base_address, dwarf_info, dwarf_info_size,\n\t\t\t    dwarf_line, dwarf_line_size, dwarf_abbrev,\n\t\t\t    dwarf_abbrev_size, dwarf_ranges, dwarf_ranges_size,\n\t\t\t    dwarf_str, dwarf_str_size, is_bigendian,\n\t\t\t    error_callback, data);\n  if (fdata == NULL)\n    return 0;\n\n  if (!state->threaded)\n    {\n      struct dwarf_data **pp;\n\n      for (pp = (struct dwarf_data **) (void *) &state->fileline_data;\n\t   *pp != NULL;\n\t   pp = &(*pp)->next)\n\t;\n      *pp = fdata;\n    }\n  else\n    {\n      while (1)\n\t{\n\t  struct dwarf_data **pp;\n\n\t  pp = (struct dwarf_data **) (void *) &state->fileline_data;\n\n\t  while (1)\n\t    {\n\t      struct dwarf_data *p;\n\n\t      p = backtrace_atomic_load_pointer (pp);\n\n\t      if (p == NULL)\n\t\tbreak;\n\n\t      pp = &p->next;\n\t    }\n\n\t  if (__sync_bool_compare_and_swap (pp, NULL, fdata))\n\t    break;\n\t}\n    }\n\n  *fileline_fn = dwarf_fileline;\n\n  return 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/3rdparty/libbacktrace/CMakeLists.txt": "# based on: https://github.com/ValveSoftware/vogl/blob/master/src/libbacktrace/CMakeLists.txt\n#\n#    CMakeLists.txt -- libbacktrace CMake build script\n#    Contributed by Alexander Monakov, ISP RAS\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#     (1) Redistributions of source code must retain the above copyright\n#     notice, this list of conditions and the following disclaimer.\n#\n#     (2) Redistributions in binary form must reproduce the above copyright\n#     notice, this list of conditions and the following disclaimer in\n#     the documentation and/or other materials provided with the\n#     distribution.\n#\n#     (3) The name of the author may not be used to\n#     endorse or promote products derived from this software without\n#     specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.  */\n\ncmake_minimum_required (VERSION 2.8)\n\nproject (libbacktrace)\n\nset (BACKTRACE_SUPPORTED 1)\n\ninclude (CheckSymbolExists)\nif (true)\n    # When unwind.h is in /usr/local/include, check_symbol_exists() is failing. But\n    #  these functions are in the Linux Standard Base Core Spec and should just exist\n    #  for Linux, yes?  I'm assuming that's the case for now and using them.\n    #  (Otherwise stack tracing won't work anyway).\n    set (HAVE_BACKTRACE 1)\n    set (HAVE_GETIPINFO 1)\nelse()\n    check_symbol_exists (_Unwind_Backtrace unwind.h HAVE_BACKTRACE)\n    check_symbol_exists (_Unwind_GetIPInfo unwind.h HAVE_GETIPINFO)\nendif()\n\nif (HAVE_BACKTRACE)\n    set (BACKTRACE_FILE backtrace.c simple.c)\nelse ()\n    message(FATAL_ERROR \"Could not find unwind.h, install the libunwind development package.\")\nendif ()\n\ninclude (CheckCCompilerFlag)\ncheck_c_compiler_flag (\"-funwind-tables\" FLAG_UNWIND_TABLES)\nif (FLAG_UNWIND_TABLES)\n    add_definitions (\"-funwind-tables\")\nendif ()\n\nif (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    add_definitions(\"-D_DEBUG -DDEBUG\")\nendif()\n\n# Adjust warnings\nif (CMAKE_COMPILER_IS_GNUCC)\n    add_definitions (\"-Wno-switch -Wno-enum-compare\")\nendif ()\n\n# Add these compiler options to match how voglcore and voglcommon are compiled, and to get libbacktrace compiling with gcc.\n# -fno-strict-aliasing is particularly important if voglcore is called, and -fvisibility=hidden must be used otherwide symbols from this lib could be made visible in libvogltrace.\nadd_definitions (\"-g -fno-omit-frame-pointer -fno-strict-aliasing -fno-math-errno -fvisibility=hidden\")\nSET(CMAKE_CXX_FLAGS_RELEASE \"-O2 -g -DNDEBUG\")\n\nif (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\")\n   if ( NOT BUILD_X64 )\n      # Fix startup crash in dlopen_notify_callback (called indirectly from our dlopen() function) when tracing glxspheres on my AMD dev box (x86 release only)\n      #add_definitions (\"-mstack-alignment=8\")\n   endif()\nendif()\n\n# clang doesn't print colored diagnostics when invoked from Ninja\nif (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\")\n  if (UNIX AND CMAKE_GENERATOR STREQUAL \"Ninja\")\n      add_definitions (\"-fcolor-diagnostics\")\n  endif()\nendif()\n\ncheck_c_source_compiles (\n    \"int i;\n    int main() {\n    __sync_bool_compare_and_swap (&i, i, i);\n    __sync_lock_test_and_set (&i, 1);\n    __sync_lock_release (&i);}\"\n    HAVE_SYNC_FUNCTIONS)\n\ncheck_c_source_compiles (\n    \"int i;\n    int main() {\n    __atomic_load_n (&i, __ATOMIC_ACQUIRE);\n    __atomic_store_n (&i, i, __ATOMIC_RELEASE);}\"\n    HAVE_ATOMIC_FUNCTIONS)\n\nif (HAVE_SYNC_FUNCTIONS OR HAVE_ATOMIC_FUNCTIONS)\n    set (BACKTRACE_SUPPORTS_THREADS 1)\nelse ()\n    set (BACKTRACE_SUPPORTS_THREADS 0)\nendif ()\n\ninclude(CMakeDetermineCompilerId)\nif (CMAKE_EXECUTABLE_FORMAT STREQUAL \"ELF\")\n    set (FORMAT_FILE elf.c dwarf.c)\n    math (EXPR BACKTRACE_ELF_SIZE 8*${CMAKE_C_SIZEOF_DATA_PTR})\nelse ()\n    message(FATAL_ERROR \"Unknown executable format \\\"${CMAKE_EXECUTABLE_FORMAT}\\\", currently only ELF is supported.\")\nendif ()\n\ncheck_symbol_exists (mmap sys/mman.h HAVE_MMAP)\ncheck_symbol_exists(lstat sys/stat.h HAVE_LSTAT)\ncheck_symbol_exists(readlink unistd.h HAVE_READLINK)\n\n# NOTE: For the use-case of heaptrack, we want to use malloc for allocating\n# the tiny fragments required for reading a backtrace as we are doing this\n# in a separate process, outside of a potential signal handler\n# This has a tremendous impact on the performance when analyzing the DWARF\n# symbols of a large binary, such as clang++ or webkit.\nset (ALLOC_FILE alloc.c)\nset (BACKTRACE_USES_MALLOC 1)\n\nif (HAVE_MMAP)\n    set (VIEW_FILE mmapio.c)\n    check_symbol_exists (MAP_ANONYMOUS sys/mman.h HAVE_MMAP_ANONYMOUS)\n    check_symbol_exists (MAP_ANON sys/mman.h HAVE_MMAP_ANON)\nelse ()\n    set (VIEW_FILE read.c)\nendif ()\n\nif (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    add_definitions(\"-D_DEBUG -DDEBUG\")\nendif()\nadd_definitions (-D_GNU_SOURCE)\nset (CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS} -D_GNU_SOURCE)\ncheck_symbol_exists (dl_iterate_phdr link.h HAVE_DL_ITERATE_PHDR)\n\ninclude (CheckFunctionExists)\ncheck_function_exists (fcntl HAVE_FCNTL)\n\ncheck_function_exists (strnlen HAVE_DECL_STRNLEN)\n\ncheck_function_exists (getexecname HAVE_GETEXECNAME)\n\ninclude (CheckIncludeFile)\nfind_path(DWARF_INCLUDE_DIR dwarf.h\n      PATH_SUFFIXES libdwarf)\nif (NOT DWARF_INCLUDE_DIR)\n    message(FATAL_ERROR \"Could not find dwarf.h, try installing the dwarf or elfutils development package.\")\nendif ()\ninclude_directories(${DWARF_INCLUDE_DIR})\n\nconfigure_file (backtrace-supported.h.in backtrace-supported.h)\n\nconfigure_file (config.h.in.cmake config.h)\n\ninclude_directories (BEFORE\n    ${CMAKE_CURRENT_BINARY_DIR}\n)\ninclude_directories (\n    auxincl\n    ${LIBUNWIND_INCLUDE_DIR}\n)\n\nadd_library (backtrace STATIC\n    ${BACKTRACE_FILE}\n    ${FORMAT_FILE}\n    ${VIEW_FILE}\n    ${ALLOC_FILE}\n    atomic.c\n    fileline.c\n    posix.c\n    print.c\n    state.c\n    sort.c\n)\n\ntarget_link_libraries(backtrace ${LIBUNWIND_LIBRARY})\n\nset_target_properties (backtrace PROPERTIES\n    COMPILE_FLAGS \"${CMAKE_SHARED_LIBRARY_C_FLAGS}\"\n)\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/tools/build_appimage.sh": "#!/bin/sh\n\ncd $(dirname $0)/../\n\nOUTDIR=$PWD\n\nPREFIX=/opt\n\nif [ ! -z \"$1\" ]; then\n    PREFIX=$1\nfi\n\nif [ ! -z \"$2\" ]; then\n    OUTDIR=\"$2\"\nfi\n\nZSTD=$(which zstd)\n\nif [ -z \"$ZSTD\" ]; then\n    echo \"ERROR: cannot find zstd in PATH\"\n    exit 1\nfi\n\nif [ -z \"$(which linuxdeployqt)\" ]; then\n    echo \"ERROR: cannot find linuxdeployqt in PATH\"\n    exit 1\nfi\n\nif [ -z \"$(which appimagetool)\" ]; then\n    echo \"ERROR: cannot find appimagetool in PATH\"\n    exit 1\nfi\n\nif [ ! -d build-appimage ]; then\n    mkdir build-appimage\nfi\n\ncd build-appimage\n\ncmake -DCMAKE_INSTALL_PREFIX=$PREFIX -DCMAKE_BUILD_TYPE=Release ..\nmake -j$(nproc)\nmake DESTDIR=appdir install\n\n# copy the zstd binary into the app image\ncp $ZSTD ./appdir/$PREFIX/bin/zstd\n\nlinuxdeployqt \"./appdir/$PREFIX/share/applications/org.kde.heaptrack.desktop\" \\\n    -executable=\"./appdir/$PREFIX/lib/heaptrack/libexec/heaptrack_interpret\" \\\n    -executable=\"./appdir/$PREFIX/lib/heaptrack/libheaptrack_preload.so\" \\\n    -executable=\"./appdir/$PREFIX/lib/heaptrack/libheaptrack_inject.so\" \\\n    -executable=\"./appdir/$PREFIX/bin/zstd\" \\\n    -bundle-non-qt-libs\n\n# Ensure we prefer the bundled libs also when calling dlopen, cf.: https://github.com/KDAB/hotspot/issues/89\nmv \"./appdir/$PREFIX/bin/heaptrack_gui\" \"./appdir/$PREFIX/bin/heaptrack_gui_bin\"\ncat << WRAPPER_SCRIPT > ./appdir/$PREFIX/bin/heaptrack_gui\n#!/bin/bash\nf=\"\\$(readlink -f \"\\${0}\")\"\nd=\"\\$(dirname \"\\$f\")\"\nLD_LIBRARY_PATH=\"\\$d/../lib:\\$LD_LIBRARY_PATH\" \"\\$d/heaptrack_gui_bin\" \"\\$@\"\nWRAPPER_SCRIPT\nchmod +x ./appdir/$PREFIX/bin/heaptrack_gui\n\n# use the shell script as AppRun entry point\n# also make sure we find the bundled zstd\nrm ./appdir/AppRun\ncat << WRAPPER_SCRIPT > ./appdir/AppRun\n#!/bin/bash\nf=\"\\$(readlink -f \"\\${0}\")\"\nd=\"\\$(dirname \"\\$f\")\"\nbin=\"\\$d/$PREFIX/bin\"\nPATH=\"\\$PATH:\\$bin\" \"\\$bin/heaptrack\" \"\\$@\"\nWRAPPER_SCRIPT\nchmod +x ./appdir/AppRun\n\n# Actually create the final image\nappimagetool ./appdir $OUTDIR/heaptrack-$(git describe)-x86_64.AppImage\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/16-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/64-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/32-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/128-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/48-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/22-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_flamegraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_allocations_chart.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_summary.png"
    ],
    "total_files": 147
}