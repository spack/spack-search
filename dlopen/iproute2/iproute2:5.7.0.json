{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/genl/genl.c": "/*\n * genl.c\t\t\"genl\" utility frontend.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tJamal Hadi Salim\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <errno.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h> /* until we put our own header */\n#include \"SNAPSHOT.h\"\n#include \"utils.h\"\n#include \"genl_utils.h\"\n\nint show_stats;\nint show_details;\nint show_raw;\n\nstatic void *BODY;\nstatic struct genl_util *genl_list;\n\n\nstatic int print_nofopt(struct nlmsghdr *n, void *arg)\n{\n\tfprintf((FILE *) arg, \"unknown genl type ..\\n\");\n\treturn 0;\n}\n\nstatic int parse_nofopt(struct genl_util *f, int argc, char **argv)\n{\n\tif (argc) {\n\t\tfprintf(stderr,\n\t\t\t\"Unknown genl \\\"%s\\\", hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\tf->name, *argv);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct genl_util *get_genl_kind(const char *str)\n{\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct genl_util *f;\n\n\tfor (f = genl_list; f; f = f->next)\n\t\tif (strcmp(f->name, str) == 0)\n\t\t\treturn f;\n\n\tsnprintf(buf, sizeof(buf), \"%s.so\", str);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\tdlh = BODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = BODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_genl_util\", str);\n\n\tf = dlsym(dlh, buf);\n\tif (f == NULL)\n\t\tgoto noexist;\nreg:\n\tf->next = genl_list;\n\tgenl_list = f;\n\treturn f;\n\nnoexist:\n\tf = calloc(1, sizeof(*f));\n\tif (f) {\n\t\tstrncpy(f->name, str, 15);\n\t\tf->parse_genlopt = parse_nofopt;\n\t\tf->print_genlopt = print_nofopt;\n\t\tgoto reg;\n\t}\n\treturn f;\n}\n\nstatic void usage(void) __attribute__((noreturn));\n\nstatic void usage(void)\n{\n\tfprintf(stderr,\n\t\t\"Usage: genl [ OPTIONS ] OBJECT [help] }\\n\"\n\t\t\"where  OBJECT := { ctrl etc }\\n\"\n\t\t\"       OPTIONS := { -s[tatistics] | -d[etails] | -r[aw] | -V[ersion] | -h[elp] }\\n\");\n\texit(-1);\n}\n\nint main(int argc, char **argv)\n{\n\twhile (argc > 1) {\n\t\tif (argv[1][0] != '-')\n\t\t\tbreak;\n\t\tif (matches(argv[1], \"-stats\") == 0 ||\n\t\t    matches(argv[1], \"-statistics\") == 0) {\n\t\t\t++show_stats;\n\t\t} else if (matches(argv[1], \"-details\") == 0) {\n\t\t\t++show_details;\n\t\t} else if (matches(argv[1], \"-raw\") == 0) {\n\t\t\t++show_raw;\n\t\t} else if (matches(argv[1], \"-Version\") == 0) {\n\t\t\tprintf(\"genl utility, iproute2-ss%s\\n\", SNAPSHOT);\n\t\t\texit(0);\n\t\t} else if (matches(argv[1], \"-help\") == 0) {\n\t\t\tusage();\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Option \\\"%s\\\" is unknown, try \\\"genl -help\\\".\\n\",\n\t\t\t\targv[1]);\n\t\t\texit(-1);\n\t\t}\n\t\targc--;\targv++;\n\t}\n\n\tif (argc > 1) {\n\t\tstruct genl_util *a;\n\t\tint ret;\n\n\t\ta = get_genl_kind(argv[1]);\n\t\tif (!a) {\n\t\t\tfprintf(stderr, \"bad genl %s\\n\", argv[1]);\n\t\t\texit(-1);\n\t\t}\n\n\t\tret = a->parse_genlopt(a, argc-1, argv+1);\n\t\treturn ret;\n\t}\n\n\tusage();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/include/dlfcn.h": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Stub dlfcn implementation for systems that lack shared library support\n * but obviously can still reference compiled-in symbols.\n */\n\n#ifndef NO_SHARED_LIBS\n#include_next <dlfcn.h>\n#else\n\n#define RTLD_LAZY 0\n#define RTLD_GLOBAL 1\n#define _FAKE_DLFCN_HDL (void *)0xbeefcafe\n\nstatic inline void *dlopen(const char *file, int flag)\n{\n\tif (file == NULL)\n\t\treturn _FAKE_DLFCN_HDL;\n\telse\n\t\treturn NULL;\n}\n\nvoid *_dlsym(const char *sym);\nstatic inline void *dlsym(void *handle, const char *sym)\n{\n\tif (handle != _FAKE_DLFCN_HDL)\n\t\treturn NULL;\n\treturn _dlsym(sym);\n}\n\nstatic inline char *dlerror(void)\n{\n\treturn NULL;\n}\n\nstatic inline int dlclose(void *handle)\n{\n\treturn (handle == _FAKE_DLFCN_HDL) ? 0 : 1;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/ip/iplink.c": "/*\n * iplink.c\t\t\"ip link\".\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <linux/if.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n#include <linux/sockios.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <stdbool.h>\n#include <linux/mpls.h>\n\n#include \"rt_names.h\"\n#include \"utils.h\"\n#include \"ip_common.h\"\n#include \"namespace.h\"\n\n#define IPLINK_IOCTL_COMPAT\t1\n#ifndef LIBDIR\n#define LIBDIR \"/usr/lib\"\n#endif\n\n#ifndef GSO_MAX_SIZE\n#define GSO_MAX_SIZE\t\t65536\n#endif\n#ifndef GSO_MAX_SEGS\n#define GSO_MAX_SEGS\t\t65535\n#endif\n\n\nstatic void usage(void) __attribute__((noreturn));\nstatic int iplink_have_newlink(void);\n\nvoid iplink_usage(void)\n{\n\tif (iplink_have_newlink()) {\n\t\tfprintf(stderr,\n\t\t\t\"Usage: ip link add [link DEV] [ name ] NAME\\n\"\n\t\t\t\"\t\t    [ txqueuelen PACKETS ]\\n\"\n\t\t\t\"\t\t    [ address LLADDR ]\\n\"\n\t\t\t\"\t\t    [ broadcast LLADDR ]\\n\"\n\t\t\t\"\t\t    [ mtu MTU ] [index IDX ]\\n\"\n\t\t\t\"\t\t    [ numtxqueues QUEUE_COUNT ]\\n\"\n\t\t\t\"\t\t    [ numrxqueues QUEUE_COUNT ]\\n\"\n\t\t\t\"\t\t    type TYPE [ ARGS ]\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"\tip link delete { DEVICE | dev DEVICE | group DEVGROUP } type TYPE [ ARGS ]\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"\tip link set { DEVICE | dev DEVICE | group DEVGROUP }\\n\"\n\t\t\t\"\t\t\t[ { up | down } ]\\n\"\n\t\t\t\"\t\t\t[ type TYPE ARGS ]\\n\");\n\t} else\n\t\tfprintf(stderr,\n\t\t\t\"Usage: ip link set DEVICE [ { up | down } ]\\n\");\n\n\tfprintf(stderr,\n\t\t\"\t\t[ arp { on | off } ]\\n\"\n\t\t\"\t\t[ dynamic { on | off } ]\\n\"\n\t\t\"\t\t[ multicast { on | off } ]\\n\"\n\t\t\"\t\t[ allmulticast { on | off } ]\\n\"\n\t\t\"\t\t[ promisc { on | off } ]\\n\"\n\t\t\"\t\t[ trailers { on | off } ]\\n\"\n\t\t\"\t\t[ carrier { on | off } ]\\n\"\n\t\t\"\t\t[ txqueuelen PACKETS ]\\n\"\n\t\t\"\t\t[ name NEWNAME ]\\n\"\n\t\t\"\t\t[ address LLADDR ]\\n\"\n\t\t\"\t\t[ broadcast LLADDR ]\\n\"\n\t\t\"\t\t[ mtu MTU ]\\n\"\n\t\t\"\t\t[ netns { PID | NAME } ]\\n\"\n\t\t\"\t\t[ link-netns NAME | link-netnsid ID ]\\n\"\n\t\t\"\t\t\t[ alias NAME ]\\n\"\n\t\t\"\t\t\t[ vf NUM [ mac LLADDR ]\\n\"\n\t\t\"\t\t\t\t [ vlan VLANID [ qos VLAN-QOS ] [ proto VLAN-PROTO ] ]\\n\"\n\t\t\"\t\t\t\t [ rate TXRATE ]\\n\"\n\t\t\"\t\t\t\t [ max_tx_rate TXRATE ]\\n\"\n\t\t\"\t\t\t\t [ min_tx_rate TXRATE ]\\n\"\n\t\t\"\t\t\t\t [ spoofchk { on | off} ]\\n\"\n\t\t\"\t\t\t\t [ query_rss { on | off} ]\\n\"\n\t\t\"\t\t\t\t [ state { auto | enable | disable} ] ]\\n\"\n\t\t\"\t\t\t\t [ trust { on | off} ] ]\\n\"\n\t\t\"\t\t\t\t [ node_guid { eui64 } ]\\n\"\n\t\t\"\t\t\t\t [ port_guid { eui64 } ]\\n\"\n\t\t\"\t\t\t[ { xdp | xdpgeneric | xdpdrv | xdpoffload } { off |\\n\"\n\t\t\"\t\t\t\t  object FILE [ section NAME ] [ verbose ] |\\n\"\n\t\t\"\t\t\t\t  pinned FILE } ]\\n\"\n\t\t\"\t\t\t[ master DEVICE ][ vrf NAME ]\\n\"\n\t\t\"\t\t\t[ nomaster ]\\n\"\n\t\t\"\t\t\t[ addrgenmode { eui64 | none | stable_secret | random } ]\\n\"\n\t\t\"\t\t\t[ protodown { on | off } ]\\n\"\n\t\t\"\t\t\t[ gso_max_size BYTES ] | [ gso_max_segs PACKETS ]\\n\"\n\t\t\"\\n\"\n\t\t\"\tip link show [ DEVICE | group GROUP ] [up] [master DEV] [vrf NAME] [type TYPE]\\n\"\n\t\t\"\\n\"\n\t\t\"\tip link xstats type TYPE [ ARGS ]\\n\"\n\t\t\"\\n\"\n\t\t\"\tip link afstats [ dev DEVICE ]\\n\"\n\t\t\"\tip link property add dev DEVICE [ altname NAME .. ]\\n\"\n\t\t\"\tip link property del dev DEVICE [ altname NAME .. ]\\n\");\n\n\tif (iplink_have_newlink()) {\n\t\tfprintf(stderr,\n\t\t\t\"\\n\"\n\t\t\t\"\tip link help [ TYPE ]\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"TYPE := { vlan | veth | vcan | vxcan | dummy | ifb | macvlan | macvtap |\\n\"\n\t\t\t\"\t   bridge | bond | team | ipoib | ip6tnl | ipip | sit | vxlan |\\n\"\n\t\t\t\"\t   gre | gretap | erspan | ip6gre | ip6gretap | ip6erspan |\\n\"\n\t\t\t\"\t   vti | nlmon | team_slave | bond_slave | bridge_slave |\\n\"\n\t\t\t\"\t   ipvlan | ipvtap | geneve | vrf | macsec | netdevsim | rmnet |\\n\"\n\t\t\t\"\t   xfrm }\\n\");\n\t}\n\texit(-1);\n}\n\nstatic void usage(void)\n{\n\tiplink_usage();\n}\n\nstatic int on_off(const char *msg, const char *realval)\n{\n\tfprintf(stderr,\n\t\t\"Error: argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\", not \\\"%s\\\"\\n\",\n\t\tmsg, realval);\n\treturn -1;\n}\n\nstatic void *BODY;\t\t/* cached dlopen(NULL) handle */\nstatic struct link_util *linkutil_list;\n\nstruct link_util *get_link_kind(const char *id)\n{\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct link_util *l;\n\n\tfor (l = linkutil_list; l; l = l->next)\n\t\tif (strcmp(l->id, id) == 0)\n\t\t\treturn l;\n\n\tsnprintf(buf, sizeof(buf), LIBDIR \"/ip/link_%s.so\", id);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\t/* look in current binary, only open once */\n\t\tdlh = BODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = BODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_link_util\", id);\n\tl = dlsym(dlh, buf);\n\tif (l == NULL)\n\t\treturn NULL;\n\n\tl->next = linkutil_list;\n\tlinkutil_list = l;\n\treturn l;\n}\n\nstatic int get_link_mode(const char *mode)\n{\n\tif (strcasecmp(mode, \"default\") == 0)\n\t\treturn IF_LINK_MODE_DEFAULT;\n\tif (strcasecmp(mode, \"dormant\") == 0)\n\t\treturn IF_LINK_MODE_DORMANT;\n\treturn -1;\n}\n\nstatic int get_addr_gen_mode(const char *mode)\n{\n\tif (strcasecmp(mode, \"eui64\") == 0)\n\t\treturn IN6_ADDR_GEN_MODE_EUI64;\n\tif (strcasecmp(mode, \"none\") == 0)\n\t\treturn IN6_ADDR_GEN_MODE_NONE;\n\tif (strcasecmp(mode, \"stable_secret\") == 0)\n\t\treturn IN6_ADDR_GEN_MODE_STABLE_PRIVACY;\n\tif (strcasecmp(mode, \"random\") == 0)\n\t\treturn IN6_ADDR_GEN_MODE_RANDOM;\n\treturn -1;\n}\n\n#if IPLINK_IOCTL_COMPAT\nstatic int have_rtnl_newlink = -1;\n\nstatic int accept_msg(struct rtnl_ctrl_data *ctrl,\n\t\t      struct nlmsghdr *n, void *arg)\n{\n\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(n);\n\n\tif (n->nlmsg_type == NLMSG_ERROR &&\n\t    (err->error == -EOPNOTSUPP || err->error == -EINVAL))\n\t\thave_rtnl_newlink = 0;\n\telse\n\t\thave_rtnl_newlink = 1;\n\treturn -1;\n}\n\nstatic int iplink_have_newlink(void)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tn;\n\t\tstruct ifinfomsg\ti;\n\t\tchar\t\t\tbuf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,\n\t\t.n.nlmsg_type = RTM_NEWLINK,\n\t\t.i.ifi_family = AF_UNSPEC,\n\t};\n\n\tif (have_rtnl_newlink < 0) {\n\t\tif (rtnl_send(&rth, &req.n, req.n.nlmsg_len) < 0) {\n\t\t\tperror(\"request send failed\");\n\t\t\texit(1);\n\t\t}\n\t\trtnl_listen(&rth, accept_msg, NULL);\n\t}\n\treturn have_rtnl_newlink;\n}\n#else /* IPLINK_IOCTL_COMPAT */\nstatic int iplink_have_newlink(void)\n{\n\treturn 1;\n}\n#endif /* ! IPLINK_IOCTL_COMPAT */\n\nstatic int nl_get_ll_addr_len(const char *ifname)\n{\n\tint len;\n\tint dev_index = ll_name_to_index(ifname);\n\tstruct iplink_req req = {\n\t\t.n = {\n\t\t\t.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t\t.nlmsg_type = RTM_GETLINK,\n\t\t\t.nlmsg_flags = NLM_F_REQUEST\n\t\t},\n\t\t.i = {\n\t\t\t.ifi_family = preferred_family,\n\t\t\t.ifi_index = dev_index,\n\t\t}\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[IFLA_MAX+1];\n\n\tif (dev_index == 0)\n\t\treturn -1;\n\n\tif (rtnl_talk(&rth, &req.n, &answer) < 0)\n\t\treturn -1;\n\n\tlen = answer->nlmsg_len - NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\tif (len < 0) {\n\t\tfree(answer);\n\t\treturn -1;\n\t}\n\n\tparse_rtattr_flags(tb, IFLA_MAX, IFLA_RTA(NLMSG_DATA(answer)),\n\t\t\t   len, NLA_F_NESTED);\n\tif (!tb[IFLA_ADDRESS]) {\n\t\tfree(answer);\n\t\treturn -1;\n\t}\n\n\tlen = RTA_PAYLOAD(tb[IFLA_ADDRESS]);\n\tfree(answer);\n\treturn len;\n}\n\nstatic void iplink_parse_vf_vlan_info(int vf, int *argcp, char ***argvp,\n\t\t\t\t      struct ifla_vf_vlan_info *ivvip)\n{\n\tint argc = *argcp;\n\tchar **argv = *argvp;\n\tunsigned int vci;\n\n\tNEXT_ARG();\n\tif (get_unsigned(&vci, *argv, 0) || vci > 4095)\n\t\tinvarg(\"Invalid \\\"vlan\\\" value\\n\", *argv);\n\n\tivvip->vlan = vci;\n\tivvip->vf = vf;\n\tivvip->qos = 0;\n\tivvip->vlan_proto = htons(ETH_P_8021Q);\n\tif (NEXT_ARG_OK()) {\n\t\tNEXT_ARG();\n\t\tif (matches(*argv, \"qos\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&ivvip->qos, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"qos\\\" value\\n\", *argv);\n\t\t} else {\n\t\t\t/* rewind arg */\n\t\t\tPREV_ARG();\n\t\t}\n\t}\n\tif (NEXT_ARG_OK()) {\n\t\tNEXT_ARG();\n\t\tif (matches(*argv, \"proto\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (ll_proto_a2n(&ivvip->vlan_proto, *argv))\n\t\t\t\tinvarg(\"protocol is invalid\\n\", *argv);\n\t\t\tif (ivvip->vlan_proto != htons(ETH_P_8021AD) &&\n\t\t\t    ivvip->vlan_proto != htons(ETH_P_8021Q)) {\n\t\t\t\tSPRINT_BUF(b1);\n\t\t\t\tSPRINT_BUF(b2);\n\t\t\t\tchar msg[64 + sizeof(b1) + sizeof(b2)];\n\n\t\t\t\tsprintf(msg,\n\t\t\t\t\t\"Invalid \\\"vlan protocol\\\" value - supported %s, %s\\n\",\n\t\t\t\t\tll_proto_n2a(htons(ETH_P_8021Q),\n\t\t\t\t\t     b1, sizeof(b1)),\n\t\t\t\t\tll_proto_n2a(htons(ETH_P_8021AD),\n\t\t\t\t\t     b2, sizeof(b2)));\n\t\t\t\tinvarg(msg, *argv);\n\t\t\t}\n\t\t} else {\n\t\t\t/* rewind arg */\n\t\t\tPREV_ARG();\n\t\t}\n\t}\n\n\t*argcp = argc;\n\t*argvp = argv;\n}\n\nstatic int iplink_parse_vf(int vf, int *argcp, char ***argvp,\n\t\t\t   struct iplink_req *req, const char *dev)\n{\n\tchar new_rate_api = 0, count = 0, override_legacy_rate = 0;\n\tstruct ifla_vf_rate tivt;\n\tint len, argc = *argcp;\n\tchar **argv = *argvp;\n\tstruct rtattr *vfinfo;\n\n\ttivt.min_tx_rate = -1;\n\ttivt.max_tx_rate = -1;\n\n\tvfinfo = addattr_nest(&req->n, sizeof(*req), IFLA_VF_INFO);\n\n\twhile (NEXT_ARG_OK()) {\n\t\tNEXT_ARG();\n\t\tcount++;\n\t\tif (!matches(*argv, \"max_tx_rate\")) {\n\t\t\t/* new API in use */\n\t\t\tnew_rate_api = 1;\n\t\t\t/* override legacy rate */\n\t\t\toverride_legacy_rate = 1;\n\t\t} else if (!matches(*argv, \"min_tx_rate\")) {\n\t\t\t/* new API in use */\n\t\t\tnew_rate_api = 1;\n\t\t}\n\t}\n\n\twhile (count--) {\n\t\t/* rewind arg */\n\t\tPREV_ARG();\n\t}\n\n\twhile (NEXT_ARG_OK()) {\n\t\tNEXT_ARG();\n\t\tif (matches(*argv, \"mac\") == 0) {\n\t\t\tstruct ifla_vf_mac ivm = { 0 };\n\t\t\tint halen = nl_get_ll_addr_len(dev);\n\n\t\t\tNEXT_ARG();\n\t\t\tivm.vf = vf;\n\t\t\tlen = ll_addr_a2n((char *)ivm.mac, 32, *argv);\n\t\t\tif (len < 0)\n\t\t\t\treturn -1;\n\t\t\tif (halen > 0 && len != halen) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Invalid address length %d - must be %d bytes\\n\",\n\t\t\t\t\tlen, halen);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_MAC,\n\t\t\t\t  &ivm, sizeof(ivm));\n\t\t} else if (matches(*argv, \"vlan\") == 0) {\n\t\t\tstruct ifla_vf_vlan_info ivvi;\n\n\t\t\tiplink_parse_vf_vlan_info(vf, &argc, &argv, &ivvi);\n\t\t\t/* support the old interface in case of older kernel*/\n\t\t\tif (ivvi.vlan_proto == htons(ETH_P_8021Q)) {\n\t\t\t\tstruct ifla_vf_vlan ivv;\n\n\t\t\t\tivv.vf = ivvi.vf;\n\t\t\t\tivv.vlan = ivvi.vlan;\n\t\t\t\tivv.qos = ivvi.qos;\n\t\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t\t  IFLA_VF_VLAN, &ivv, sizeof(ivv));\n\t\t\t} else {\n\t\t\t\tstruct rtattr *vfvlanlist;\n\n\t\t\t\tvfvlanlist = addattr_nest(&req->n, sizeof(*req),\n\t\t\t\t\t\t\t  IFLA_VF_VLAN_LIST);\n\t\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t\t  IFLA_VF_VLAN_INFO, &ivvi,\n\t\t\t\t\t  sizeof(ivvi));\n\n\t\t\t\twhile (NEXT_ARG_OK()) {\n\t\t\t\t\tNEXT_ARG();\n\t\t\t\t\tif (matches(*argv, \"vlan\") != 0) {\n\t\t\t\t\t\tPREV_ARG();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tiplink_parse_vf_vlan_info(vf, &argc,\n\t\t\t\t\t\t\t\t  &argv, &ivvi);\n\t\t\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t\t\t  IFLA_VF_VLAN_INFO, &ivvi,\n\t\t\t\t\t\t  sizeof(ivvi));\n\t\t\t\t}\n\t\t\t\taddattr_nest_end(&req->n, vfvlanlist);\n\t\t\t}\n\t\t} else if (matches(*argv, \"rate\") == 0) {\n\t\t\tstruct ifla_vf_tx_rate ivt;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&ivt.rate, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"rate\\\" value\\n\", *argv);\n\n\t\t\tivt.vf = vf;\n\t\t\tif (!new_rate_api)\n\t\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t\t  IFLA_VF_TX_RATE, &ivt, sizeof(ivt));\n\t\t\telse if (!override_legacy_rate)\n\t\t\t\ttivt.max_tx_rate = ivt.rate;\n\n\t\t} else if (matches(*argv, \"max_tx_rate\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&tivt.max_tx_rate, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"max tx rate\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\ttivt.vf = vf;\n\n\t\t} else if (matches(*argv, \"min_tx_rate\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&tivt.min_tx_rate, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"min tx rate\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\ttivt.vf = vf;\n\n\t\t} else if (matches(*argv, \"spoofchk\") == 0) {\n\t\t\tstruct ifla_vf_spoofchk ivs;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (matches(*argv, \"on\") == 0)\n\t\t\t\tivs.setting = 1;\n\t\t\telse if (matches(*argv, \"off\") == 0)\n\t\t\t\tivs.setting = 0;\n\t\t\telse\n\t\t\t\treturn on_off(\"spoofchk\", *argv);\n\t\t\tivs.vf = vf;\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_SPOOFCHK,\n\t\t\t\t  &ivs, sizeof(ivs));\n\n\t\t} else if (matches(*argv, \"query_rss\") == 0) {\n\t\t\tstruct ifla_vf_rss_query_en ivs;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (matches(*argv, \"on\") == 0)\n\t\t\t\tivs.setting = 1;\n\t\t\telse if (matches(*argv, \"off\") == 0)\n\t\t\t\tivs.setting = 0;\n\t\t\telse\n\t\t\t\treturn on_off(\"query_rss\", *argv);\n\t\t\tivs.vf = vf;\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_RSS_QUERY_EN,\n\t\t\t\t  &ivs, sizeof(ivs));\n\n\t\t} else if (matches(*argv, \"trust\") == 0) {\n\t\t\tstruct ifla_vf_trust ivt;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (matches(*argv, \"on\") == 0)\n\t\t\t\tivt.setting = 1;\n\t\t\telse if (matches(*argv, \"off\") == 0)\n\t\t\t\tivt.setting = 0;\n\t\t\telse\n\t\t\t\tinvarg(\"Invalid \\\"trust\\\" value\\n\", *argv);\n\t\t\tivt.vf = vf;\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_TRUST,\n\t\t\t\t  &ivt, sizeof(ivt));\n\n\t\t} else if (matches(*argv, \"state\") == 0) {\n\t\t\tstruct ifla_vf_link_state ivl;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (matches(*argv, \"auto\") == 0)\n\t\t\t\tivl.link_state = IFLA_VF_LINK_STATE_AUTO;\n\t\t\telse if (matches(*argv, \"enable\") == 0)\n\t\t\t\tivl.link_state = IFLA_VF_LINK_STATE_ENABLE;\n\t\t\telse if (matches(*argv, \"disable\") == 0)\n\t\t\t\tivl.link_state = IFLA_VF_LINK_STATE_DISABLE;\n\t\t\telse\n\t\t\t\tinvarg(\"Invalid \\\"state\\\" value\\n\", *argv);\n\t\t\tivl.vf = vf;\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_LINK_STATE,\n\t\t\t\t  &ivl, sizeof(ivl));\n\t\t} else if (matches(*argv, \"node_guid\") == 0) {\n\t\t\tstruct ifla_vf_guid ivg;\n\n\t\t\tNEXT_ARG();\n\t\t\tivg.vf = vf;\n\t\t\tif (get_guid(&ivg.guid, *argv)) {\n\t\t\t\tinvarg(\"Invalid GUID format\\n\", *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_IB_NODE_GUID,\n\t\t\t\t  &ivg, sizeof(ivg));\n\t\t} else if (matches(*argv, \"port_guid\") == 0) {\n\t\t\tstruct ifla_vf_guid ivg;\n\n\t\t\tNEXT_ARG();\n\t\t\tivg.vf = vf;\n\t\t\tif (get_guid(&ivg.guid, *argv)) {\n\t\t\t\tinvarg(\"Invalid GUID format\\n\", *argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_IB_PORT_GUID,\n\t\t\t\t  &ivg, sizeof(ivg));\n\t\t} else {\n\t\t\t/* rewind arg */\n\t\t\tPREV_ARG();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_rate_api) {\n\t\tint tmin, tmax;\n\n\t\tif (tivt.min_tx_rate == -1 || tivt.max_tx_rate == -1) {\n\t\t\tipaddr_get_vf_rate(tivt.vf, &tmin, &tmax, dev);\n\t\t\tif (tivt.min_tx_rate == -1)\n\t\t\t\ttivt.min_tx_rate = tmin;\n\t\t\tif (tivt.max_tx_rate == -1)\n\t\t\t\ttivt.max_tx_rate = tmax;\n\t\t}\n\n\t\tif (tivt.max_tx_rate && tivt.min_tx_rate > tivt.max_tx_rate) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid min_tx_rate %d - must be <= max_tx_rate %d\\n\",\n\t\t\t\ttivt.min_tx_rate, tivt.max_tx_rate);\n\t\t\treturn -1;\n\t\t}\n\n\t\taddattr_l(&req->n, sizeof(*req), IFLA_VF_RATE, &tivt,\n\t\t\t  sizeof(tivt));\n\t}\n\n\tif (argc == *argcp)\n\t\tincomplete_command();\n\n\taddattr_nest_end(&req->n, vfinfo);\n\n\t*argcp = argc;\n\t*argvp = argv;\n\treturn 0;\n}\n\nint iplink_parse(int argc, char **argv, struct iplink_req *req, char **type)\n{\n\tchar *name = NULL;\n\tchar *dev = NULL;\n\tchar *link = NULL;\n\tint ret, len;\n\tchar abuf[32];\n\tint qlen = -1;\n\tint mtu = -1;\n\tint netns = -1;\n\tint vf = -1;\n\tint numtxqueues = -1;\n\tint numrxqueues = -1;\n\tint link_netnsid = -1;\n\tint index = 0;\n\tint group = -1;\n\tint addr_len = 0;\n\n\tret = argc;\n\n\twhile (argc > 0) {\n\t\tif (strcmp(*argv, \"up\") == 0) {\n\t\t\treq->i.ifi_change |= IFF_UP;\n\t\t\treq->i.ifi_flags |= IFF_UP;\n\t\t} else if (strcmp(*argv, \"down\") == 0) {\n\t\t\treq->i.ifi_change |= IFF_UP;\n\t\t\treq->i.ifi_flags &= ~IFF_UP;\n\t\t} else if (strcmp(*argv, \"name\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (name)\n\t\t\t\tduparg(\"name\", *argv);\n\t\t\tif (check_ifname(*argv))\n\t\t\t\tinvarg(\"\\\"name\\\" not a valid ifname\", *argv);\n\t\t\tname = *argv;\n\t\t\tif (!dev)\n\t\t\t\tdev = name;\n\t\t} else if (strcmp(*argv, \"index\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (index)\n\t\t\t\tduparg(\"index\", *argv);\n\t\t\tindex = atoi(*argv);\n\t\t\tif (index <= 0)\n\t\t\t\tinvarg(\"Invalid \\\"index\\\" value\", *argv);\n\t\t} else if (matches(*argv, \"link\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tlink = *argv;\n\t\t} else if (matches(*argv, \"address\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\taddr_len = ll_addr_a2n(abuf, sizeof(abuf), *argv);\n\t\t\tif (addr_len < 0)\n\t\t\t\treturn -1;\n\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t  IFLA_ADDRESS, abuf, addr_len);\n\t\t} else if (matches(*argv, \"broadcast\") == 0 ||\n\t\t\t   strcmp(*argv, \"brd\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tlen = ll_addr_a2n(abuf, sizeof(abuf), *argv);\n\t\t\tif (len < 0)\n\t\t\t\treturn -1;\n\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t  IFLA_BROADCAST, abuf, len);\n\t\t} else if (matches(*argv, \"txqueuelen\") == 0 ||\n\t\t\t   strcmp(*argv, \"qlen\") == 0 ||\n\t\t\t   matches(*argv, \"txqlen\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (qlen != -1)\n\t\t\t\tduparg(\"txqueuelen\", *argv);\n\t\t\tif (get_integer(&qlen,  *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"txqueuelen\\\" value\\n\", *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t  IFLA_TXQLEN, &qlen, 4);\n\t\t} else if (strcmp(*argv, \"mtu\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (mtu != -1)\n\t\t\t\tduparg(\"mtu\", *argv);\n\t\t\tif (get_integer(&mtu, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"mtu\\\" value\\n\", *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_MTU, &mtu, 4);\n\t\t} else if (strcmp(*argv, \"xdpgeneric\") == 0 ||\n\t\t\t   strcmp(*argv, \"xdpdrv\") == 0 ||\n\t\t\t   strcmp(*argv, \"xdpoffload\") == 0 ||\n\t\t\t   strcmp(*argv, \"xdp\") == 0) {\n\t\t\tbool generic = strcmp(*argv, \"xdpgeneric\") == 0;\n\t\t\tbool drv = strcmp(*argv, \"xdpdrv\") == 0;\n\t\t\tbool offload = strcmp(*argv, \"xdpoffload\") == 0;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (xdp_parse(&argc, &argv, req, dev,\n\t\t\t\t      generic, drv, offload))\n\t\t\t\texit(-1);\n\n\t\t\tif (offload && name == dev)\n\t\t\t\tdev = NULL;\n\t\t} else if (strcmp(*argv, \"netns\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (netns != -1)\n\t\t\t\tduparg(\"netns\", *argv);\n\t\t\tnetns = netns_get_fd(*argv);\n\t\t\tif (netns >= 0)\n\t\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_NET_NS_FD,\n\t\t\t\t\t  &netns, 4);\n\t\t\telse if (get_integer(&netns, *argv, 0) == 0)\n\t\t\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t\t\t  IFLA_NET_NS_PID, &netns, 4);\n\t\t\telse\n\t\t\t\tinvarg(\"Invalid \\\"netns\\\" value\\n\", *argv);\n\t\t} else if (strcmp(*argv, \"multicast\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_MULTICAST;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_MULTICAST;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_MULTICAST;\n\t\t\telse\n\t\t\t\treturn on_off(\"multicast\", *argv);\n\t\t} else if (strcmp(*argv, \"allmulticast\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_ALLMULTI;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_ALLMULTI;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_ALLMULTI;\n\t\t\telse\n\t\t\t\treturn on_off(\"allmulticast\", *argv);\n\t\t} else if (strcmp(*argv, \"promisc\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_PROMISC;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_PROMISC;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_PROMISC;\n\t\t\telse\n\t\t\t\treturn on_off(\"promisc\", *argv);\n\t\t} else if (strcmp(*argv, \"trailers\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_NOTRAILERS;\n\n\t\t\tif (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_NOTRAILERS;\n\t\t\telse if (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_NOTRAILERS;\n\t\t\telse\n\t\t\t\treturn on_off(\"trailers\", *argv);\n\t\t} else if (strcmp(*argv, \"arp\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_NOARP;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_NOARP;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_NOARP;\n\t\t\telse\n\t\t\t\treturn on_off(\"arp\", *argv);\n\t\t} else if (strcmp(*argv, \"carrier\") == 0) {\n\t\t\tint carrier;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tcarrier = 1;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tcarrier = 0;\n\t\t\telse\n\t\t\t\treturn on_off(\"carrier\", *argv);\n\n\t\t\taddattr8(&req->n, sizeof(*req), IFLA_CARRIER, carrier);\n\t\t} else if (strcmp(*argv, \"vf\") == 0) {\n\t\t\tstruct rtattr *vflist;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (get_integer(&vf,  *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"vf\\\" value\\n\", *argv);\n\n\t\t\tvflist = addattr_nest(&req->n, sizeof(*req),\n\t\t\t\t\t      IFLA_VFINFO_LIST);\n\t\t\tif (!dev)\n\t\t\t\tmissarg(\"dev\");\n\n\t\t\tlen = iplink_parse_vf(vf, &argc, &argv, req, dev);\n\t\t\tif (len < 0)\n\t\t\t\treturn -1;\n\t\t\taddattr_nest_end(&req->n, vflist);\n\n\t\t\tif (name == dev)\n\t\t\t\tdev = NULL;\n\t\t} else if (matches(*argv, \"master\") == 0) {\n\t\t\tint ifindex;\n\n\t\t\tNEXT_ARG();\n\t\t\tifindex = ll_name_to_index(*argv);\n\t\t\tif (!ifindex)\n\t\t\t\tinvarg(\"Device does not exist\\n\", *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_MASTER,\n\t\t\t\t  &ifindex, 4);\n\t\t} else if (strcmp(*argv, \"vrf\") == 0) {\n\t\t\tint ifindex;\n\n\t\t\tNEXT_ARG();\n\t\t\tifindex = ll_name_to_index(*argv);\n\t\t\tif (!ifindex)\n\t\t\t\tinvarg(\"Not a valid VRF name\\n\", *argv);\n\t\t\tif (!name_is_vrf(*argv))\n\t\t\t\tinvarg(\"Not a valid VRF name\\n\", *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_MASTER,\n\t\t\t\t  &ifindex, sizeof(ifindex));\n\t\t} else if (matches(*argv, \"nomaster\") == 0) {\n\t\t\tint ifindex = 0;\n\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_MASTER,\n\t\t\t\t  &ifindex, 4);\n\t\t} else if (matches(*argv, \"dynamic\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\treq->i.ifi_change |= IFF_DYNAMIC;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\treq->i.ifi_flags |= IFF_DYNAMIC;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\treq->i.ifi_flags &= ~IFF_DYNAMIC;\n\t\t\telse\n\t\t\t\treturn on_off(\"dynamic\", *argv);\n\t\t} else if (matches(*argv, \"type\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\t*type = *argv;\n\t\t\targc--; argv++;\n\t\t\tbreak;\n\t\t} else if (matches(*argv, \"alias\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tlen = strlen(*argv);\n\t\t\tif (len >= IFALIASZ)\n\t\t\t\tinvarg(\"alias too long\\n\", *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_IFALIAS,\n\t\t\t\t  *argv, len);\n\t\t} else if (strcmp(*argv, \"group\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (group != -1)\n\t\t\t\tduparg(\"group\", *argv);\n\t\t\tif (rtnl_group_a2n(&group, *argv))\n\t\t\t\tinvarg(\"Invalid \\\"group\\\" value\\n\", *argv);\n\t\t\taddattr32(&req->n, sizeof(*req), IFLA_GROUP, group);\n\t\t} else if (strcmp(*argv, \"mode\") == 0) {\n\t\t\tint mode;\n\n\t\t\tNEXT_ARG();\n\t\t\tmode = get_link_mode(*argv);\n\t\t\tif (mode < 0)\n\t\t\t\tinvarg(\"Invalid link mode\\n\", *argv);\n\t\t\taddattr8(&req->n, sizeof(*req), IFLA_LINKMODE, mode);\n\t\t} else if (strcmp(*argv, \"state\") == 0) {\n\t\t\tint state;\n\n\t\t\tNEXT_ARG();\n\t\t\tstate = get_operstate(*argv);\n\t\t\tif (state < 0)\n\t\t\t\tinvarg(\"Invalid operstate\\n\", *argv);\n\n\t\t\taddattr8(&req->n, sizeof(*req), IFLA_OPERSTATE, state);\n\t\t} else if (matches(*argv, \"numtxqueues\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (numtxqueues != -1)\n\t\t\t\tduparg(\"numtxqueues\", *argv);\n\t\t\tif (get_integer(&numtxqueues, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"numtxqueues\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_NUM_TX_QUEUES,\n\t\t\t\t  &numtxqueues, 4);\n\t\t} else if (matches(*argv, \"numrxqueues\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (numrxqueues != -1)\n\t\t\t\tduparg(\"numrxqueues\", *argv);\n\t\t\tif (get_integer(&numrxqueues, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"numrxqueues\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_NUM_RX_QUEUES,\n\t\t\t\t  &numrxqueues, 4);\n\t\t} else if (matches(*argv, \"addrgenmode\") == 0) {\n\t\t\tstruct rtattr *afs, *afs6;\n\t\t\tint mode;\n\n\t\t\tNEXT_ARG();\n\t\t\tmode = get_addr_gen_mode(*argv);\n\t\t\tif (mode < 0)\n\t\t\t\tinvarg(\"Invalid address generation mode\\n\",\n\t\t\t\t       *argv);\n\t\t\tafs = addattr_nest(&req->n, sizeof(*req), IFLA_AF_SPEC);\n\t\t\tafs6 = addattr_nest(&req->n, sizeof(*req), AF_INET6);\n\t\t\taddattr8(&req->n, sizeof(*req),\n\t\t\t\t IFLA_INET6_ADDR_GEN_MODE, mode);\n\t\t\taddattr_nest_end(&req->n, afs6);\n\t\t\taddattr_nest_end(&req->n, afs);\n\t\t} else if (matches(*argv, \"link-netns\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (link_netnsid != -1)\n\t\t\t\tduparg(\"link-netns/link-netnsid\", *argv);\n\t\t\tlink_netnsid = get_netnsid_from_name(*argv);\n\t\t\t/* No nsid? Try to assign one. */\n\t\t\tif (link_netnsid < 0)\n\t\t\t\tset_netnsid_from_name(*argv, -1);\n\t\t\tlink_netnsid = get_netnsid_from_name(*argv);\n\t\t\tif (link_netnsid < 0)\n\t\t\t\tinvarg(\"Invalid \\\"link-netns\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr32(&req->n, sizeof(*req), IFLA_LINK_NETNSID,\n\t\t\t\t  link_netnsid);\n\t\t} else if (matches(*argv, \"link-netnsid\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (link_netnsid != -1)\n\t\t\t\tduparg(\"link-netns/link-netnsid\", *argv);\n\t\t\tif (get_integer(&link_netnsid, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"link-netnsid\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr32(&req->n, sizeof(*req), IFLA_LINK_NETNSID,\n\t\t\t\t  link_netnsid);\n\t\t} else if (strcmp(*argv, \"protodown\") == 0) {\n\t\t\tunsigned int proto_down;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tproto_down = 1;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tproto_down = 0;\n\t\t\telse\n\t\t\t\treturn on_off(\"protodown\", *argv);\n\t\t\taddattr8(&req->n, sizeof(*req), IFLA_PROTO_DOWN,\n\t\t\t\t proto_down);\n\t\t} else if (strcmp(*argv, \"gso_max_size\") == 0) {\n\t\t\tunsigned int max_size;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&max_size, *argv, 0) ||\n\t\t\t    max_size > GSO_MAX_SIZE)\n\t\t\t\tinvarg(\"Invalid \\\"gso_max_size\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr32(&req->n, sizeof(*req),\n\t\t\t\t  IFLA_GSO_MAX_SIZE, max_size);\n\t\t} else if (strcmp(*argv, \"gso_max_segs\") == 0) {\n\t\t\tunsigned int max_segs;\n\n\t\t\tNEXT_ARG();\n\t\t\tif (get_unsigned(&max_segs, *argv, 0) ||\n\t\t\t    max_segs > GSO_MAX_SEGS)\n\t\t\t\tinvarg(\"Invalid \\\"gso_max_segs\\\" value\\n\",\n\t\t\t\t       *argv);\n\t\t\taddattr32(&req->n, sizeof(*req),\n\t\t\t\t  IFLA_GSO_MAX_SEGS, max_segs);\n\t\t} else {\n\t\t\tif (matches(*argv, \"help\") == 0)\n\t\t\t\tusage();\n\n\t\t\tif (strcmp(*argv, \"dev\") == 0)\n\t\t\t\tNEXT_ARG();\n\t\t\tif (dev != name)\n\t\t\t\tduparg2(\"dev\", *argv);\n\t\t\tif (check_altifname(*argv))\n\t\t\t\tinvarg(\"\\\"dev\\\" not a valid ifname\", *argv);\n\t\t\tdev = *argv;\n\t\t}\n\t\targc--; argv++;\n\t}\n\n\tret -= argc;\n\n\t/* Allow \"ip link add dev\" and \"ip link add name\" */\n\tif (!name)\n\t\tname = dev;\n\telse if (!dev)\n\t\tdev = name;\n\telse if (!strcmp(name, dev))\n\t\tname = dev;\n\n\tif (dev && addr_len &&\n\t    !(req->n.nlmsg_flags & NLM_F_CREATE)) {\n\t\tint halen = nl_get_ll_addr_len(dev);\n\n\t\tif (halen >= 0 && halen != addr_len) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid address length %d - must be %d bytes\\n\",\n\t\t\t\taddr_len, halen);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(req->n.nlmsg_flags & NLM_F_CREATE) && index) {\n\t\tfprintf(stderr,\n\t\t\t\"index can be used only when creating devices.\\n\");\n\t\texit(-1);\n\t}\n\n\tif (group != -1) {\n\t\tif (!dev) {\n\t\t\tif (argc) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Garbage instead of arguments \\\"%s ...\\\". Try \\\"ip link help\\\".\\n\",\n\t\t\t\t\t*argv);\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t\tif (req->n.nlmsg_flags & NLM_F_CREATE) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"group cannot be used when creating devices.\\n\");\n\t\t\t\texit(-1);\n\t\t\t}\n\n\t\t\t*type = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(req->n.nlmsg_flags & NLM_F_CREATE)) {\n\t\tif (!dev) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Not enough information: \\\"dev\\\" argument is required.\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\treq->i.ifi_index = ll_name_to_index(dev);\n\t\tif (!req->i.ifi_index)\n\t\t\treturn nodev(dev);\n\n\t\t/* Not renaming to the same name */\n\t\tif (name == dev)\n\t\t\tname = NULL;\n\t} else {\n\t\tif (name != dev) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"both \\\"name\\\" and \\\"dev\\\" cannot be used when creating devices.\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\tif (link) {\n\t\t\tint ifindex;\n\n\t\t\tifindex = ll_name_to_index(link);\n\t\t\tif (!ifindex)\n\t\t\t\treturn nodev(link);\n\t\t\taddattr32(&req->n, sizeof(*req), IFLA_LINK, ifindex);\n\t\t}\n\n\t\treq->i.ifi_index = index;\n\t}\n\n\tif (name) {\n\t\taddattr_l(&req->n, sizeof(*req),\n\t\t\t  IFLA_IFNAME, name, strlen(name) + 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int iplink_modify(int cmd, unsigned int flags, int argc, char **argv)\n{\n\tchar *type = NULL;\n\tstruct iplink_req req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST | flags,\n\t\t.n.nlmsg_type = cmd,\n\t\t.i.ifi_family = preferred_family,\n\t};\n\tint ret;\n\n\tret = iplink_parse(argc, argv, &req, &type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (type) {\n\t\tstruct link_util *lu;\n\t\tstruct rtattr *linkinfo;\n\t\tchar *ulinep = strchr(type, '_');\n\t\tint iflatype;\n\n\t\tlinkinfo = addattr_nest(&req.n, sizeof(req), IFLA_LINKINFO);\n\t\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, type,\n\t\t\t strlen(type));\n\n\t\tlu = get_link_kind(type);\n\t\tif (ulinep && !strcmp(ulinep, \"_slave\"))\n\t\t\tiflatype = IFLA_INFO_SLAVE_DATA;\n\t\telse\n\t\t\tiflatype = IFLA_INFO_DATA;\n\n\t\targc -= ret;\n\t\targv += ret;\n\n\t\tif (lu && argc) {\n\t\t\tstruct rtattr *data;\n\n\t\t\tdata = addattr_nest(&req.n, sizeof(req), iflatype);\n\n\t\t\tif (lu->parse_opt &&\n\t\t\t    lu->parse_opt(lu, argc, argv, &req.n))\n\t\t\t\treturn -1;\n\n\t\t\taddattr_nest_end(&req.n, data);\n\t\t} else if (argc) {\n\t\t\tif (matches(*argv, \"help\") == 0)\n\t\t\t\tusage();\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Garbage instead of arguments \\\"%s ...\\\". Try \\\"ip link help\\\".\\n\",\n\t\t\t\t*argv);\n\t\t\treturn -1;\n\t\t}\n\t\taddattr_nest_end(&req.n, linkinfo);\n\t} else if (flags & NLM_F_CREATE) {\n\t\tfprintf(stderr,\n\t\t\t\"Not enough information: \\\"type\\\" argument is required\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rtnl_talk(&rth, &req.n, NULL) < 0)\n\t\treturn -2;\n\n\t/* remove device from cache; next use can refresh with new data */\n\tll_drop_by_index(req.i.ifi_index);\n\n\treturn 0;\n}\n\nint iplink_get(char *name, __u32 filt_mask)\n{\n\tstruct iplink_req req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETLINK,\n\t\t.i.ifi_family = preferred_family,\n\t};\n\tstruct nlmsghdr *answer;\n\n\tif (name) {\n\t\taddattr_l(&req.n, sizeof(req),\n\t\t\t  !check_ifname(name) ? IFLA_IFNAME : IFLA_ALT_IFNAME,\n\t\t\t  name, strlen(name) + 1);\n\t}\n\taddattr32(&req.n, sizeof(req), IFLA_EXT_MASK, filt_mask);\n\n\tif (rtnl_talk(&rth, &req.n, &answer) < 0)\n\t\treturn -2;\n\n\topen_json_object(NULL);\n\tprint_linkinfo(answer, stdout);\n\tclose_json_object();\n\n\tfree(answer);\n\treturn 0;\n}\n\n#if IPLINK_IOCTL_COMPAT\nstatic int get_ctl_fd(void)\n{\n\tint s_errno;\n\tint fd;\n\n\tfd = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (fd >= 0)\n\t\treturn fd;\n\ts_errno = errno;\n\tfd = socket(PF_PACKET, SOCK_DGRAM, 0);\n\tif (fd >= 0)\n\t\treturn fd;\n\tfd = socket(PF_INET6, SOCK_DGRAM, 0);\n\tif (fd >= 0)\n\t\treturn fd;\n\terrno = s_errno;\n\tperror(\"Cannot create control socket\");\n\treturn -1;\n}\n\nstatic int do_chflags(const char *dev, __u32 flags, __u32 mask)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\tint err;\n\n\tstrlcpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tfd = get_ctl_fd();\n\tif (fd < 0)\n\t\treturn -1;\n\terr = ioctl(fd, SIOCGIFFLAGS, &ifr);\n\tif (err) {\n\t\tperror(\"SIOCGIFFLAGS\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((ifr.ifr_flags^flags)&mask) {\n\t\tifr.ifr_flags &= ~mask;\n\t\tifr.ifr_flags |= mask&flags;\n\t\terr = ioctl(fd, SIOCSIFFLAGS, &ifr);\n\t\tif (err)\n\t\t\tperror(\"SIOCSIFFLAGS\");\n\t}\n\tclose(fd);\n\treturn err;\n}\n\nstatic int do_changename(const char *dev, const char *newdev)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\tint err;\n\n\tstrlcpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tstrlcpy(ifr.ifr_newname, newdev, IFNAMSIZ);\n\tfd = get_ctl_fd();\n\tif (fd < 0)\n\t\treturn -1;\n\terr = ioctl(fd, SIOCSIFNAME, &ifr);\n\tif (err) {\n\t\tperror(\"SIOCSIFNAME\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tclose(fd);\n\treturn err;\n}\n\nstatic int set_qlen(const char *dev, int qlen)\n{\n\tstruct ifreq ifr = { .ifr_qlen = qlen };\n\tint s;\n\n\ts = get_ctl_fd();\n\tif (s < 0)\n\t\treturn -1;\n\n\tstrlcpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(s, SIOCSIFTXQLEN, &ifr) < 0) {\n\t\tperror(\"SIOCSIFXQLEN\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\tclose(s);\n\n\treturn 0;\n}\n\nstatic int set_mtu(const char *dev, int mtu)\n{\n\tstruct ifreq ifr = { .ifr_mtu = mtu };\n\tint s;\n\n\ts = get_ctl_fd();\n\tif (s < 0)\n\t\treturn -1;\n\n\tstrlcpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(s, SIOCSIFMTU, &ifr) < 0) {\n\t\tperror(\"SIOCSIFMTU\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\tclose(s);\n\n\treturn 0;\n}\n\nstatic int get_address(const char *dev, int *htype)\n{\n\tstruct ifreq ifr = {};\n\tstruct sockaddr_ll me = {\n\t\t.sll_family = AF_PACKET,\n\t\t.sll_protocol = htons(ETH_P_LOOP),\n\t};\n\tsocklen_t alen;\n\tint s;\n\n\ts = socket(PF_PACKET, SOCK_DGRAM, 0);\n\tif (s < 0) {\n\t\tperror(\"socket(PF_PACKET)\");\n\t\treturn -1;\n\t}\n\n\tstrlcpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\tme.sll_ifindex = ifr.ifr_ifindex;\n\tif (bind(s, (struct sockaddr *)&me, sizeof(me)) == -1) {\n\t\tperror(\"bind\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\talen = sizeof(me);\n\tif (getsockname(s, (struct sockaddr *)&me, &alen) == -1) {\n\t\tperror(\"getsockname\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\tclose(s);\n\t*htype = me.sll_hatype;\n\treturn me.sll_halen;\n}\n\nstatic int parse_address(const char *dev, int hatype, int halen,\n\t\tchar *lla, struct ifreq *ifr)\n{\n\tint alen;\n\n\tmemset(ifr, 0, sizeof(*ifr));\n\tstrlcpy(ifr->ifr_name, dev, IFNAMSIZ);\n\tifr->ifr_hwaddr.sa_family = hatype;\n\talen = ll_addr_a2n(ifr->ifr_hwaddr.sa_data, 14, lla);\n\tif (alen < 0)\n\t\treturn -1;\n\tif (alen != halen) {\n\t\tfprintf(stderr,\n\t\t\t\"Wrong address (%s) length: expected %d bytes\\n\",\n\t\t\tlla, halen);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int set_address(struct ifreq *ifr, int brd)\n{\n\tint s;\n\n\ts = get_ctl_fd();\n\tif (s < 0)\n\t\treturn -1;\n\tif (ioctl(s, brd?SIOCSIFHWBROADCAST:SIOCSIFHWADDR, ifr) < 0) {\n\t\tperror(brd?\"SIOCSIFHWBROADCAST\":\"SIOCSIFHWADDR\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\tclose(s);\n\treturn 0;\n}\n\nstatic int do_set(int argc, char **argv)\n{\n\tchar *dev = NULL;\n\t__u32 mask = 0;\n\t__u32 flags = 0;\n\tint qlen = -1;\n\tint mtu = -1;\n\tchar *newaddr = NULL;\n\tchar *newbrd = NULL;\n\tstruct ifreq ifr0, ifr1;\n\tchar *newname = NULL;\n\tint htype, halen;\n\n\twhile (argc > 0) {\n\t\tif (strcmp(*argv, \"up\") == 0) {\n\t\t\tmask |= IFF_UP;\n\t\t\tflags |= IFF_UP;\n\t\t} else if (strcmp(*argv, \"down\") == 0) {\n\t\t\tmask |= IFF_UP;\n\t\t\tflags &= ~IFF_UP;\n\t\t} else if (strcmp(*argv, \"name\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (check_ifname(*argv))\n\t\t\t\tinvarg(\"\\\"name\\\" not a valid ifname\", *argv);\n\t\t\tnewname = *argv;\n\t\t} else if (matches(*argv, \"address\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tnewaddr = *argv;\n\t\t} else if (matches(*argv, \"broadcast\") == 0 ||\n\t\t\t   strcmp(*argv, \"brd\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tnewbrd = *argv;\n\t\t} else if (matches(*argv, \"txqueuelen\") == 0 ||\n\t\t\t   strcmp(*argv, \"qlen\") == 0 ||\n\t\t\t   matches(*argv, \"txqlen\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (qlen != -1)\n\t\t\t\tduparg(\"txqueuelen\", *argv);\n\t\t\tif (get_integer(&qlen,  *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"txqueuelen\\\" value\\n\", *argv);\n\t\t} else if (strcmp(*argv, \"mtu\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (mtu != -1)\n\t\t\t\tduparg(\"mtu\", *argv);\n\t\t\tif (get_integer(&mtu, *argv, 0))\n\t\t\t\tinvarg(\"Invalid \\\"mtu\\\" value\\n\", *argv);\n\t\t} else if (strcmp(*argv, \"multicast\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_MULTICAST;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags |= IFF_MULTICAST;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags &= ~IFF_MULTICAST;\n\t\t\telse\n\t\t\t\treturn on_off(\"multicast\", *argv);\n\t\t} else if (strcmp(*argv, \"allmulticast\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_ALLMULTI;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags |= IFF_ALLMULTI;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags &= ~IFF_ALLMULTI;\n\t\t\telse\n\t\t\t\treturn on_off(\"allmulticast\", *argv);\n\t\t} else if (strcmp(*argv, \"promisc\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_PROMISC;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags |= IFF_PROMISC;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags &= ~IFF_PROMISC;\n\t\t\telse\n\t\t\t\treturn on_off(\"promisc\", *argv);\n\t\t} else if (strcmp(*argv, \"trailers\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_NOTRAILERS;\n\n\t\t\tif (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags |= IFF_NOTRAILERS;\n\t\t\telse if (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags &= ~IFF_NOTRAILERS;\n\t\t\telse\n\t\t\t\treturn on_off(\"trailers\", *argv);\n\t\t} else if (strcmp(*argv, \"arp\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_NOARP;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags &= ~IFF_NOARP;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags |= IFF_NOARP;\n\t\t\telse\n\t\t\t\treturn on_off(\"arp\", *argv);\n\t\t} else if (matches(*argv, \"dynamic\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tmask |= IFF_DYNAMIC;\n\n\t\t\tif (strcmp(*argv, \"on\") == 0)\n\t\t\t\tflags |= IFF_DYNAMIC;\n\t\t\telse if (strcmp(*argv, \"off\") == 0)\n\t\t\t\tflags &= ~IFF_DYNAMIC;\n\t\t\telse\n\t\t\t\treturn on_off(\"dynamic\", *argv);\n\t\t} else {\n\t\t\tif (strcmp(*argv, \"dev\") == 0)\n\t\t\t\tNEXT_ARG();\n\t\t\telse if (matches(*argv, \"help\") == 0)\n\t\t\t\tusage();\n\n\t\t\tif (dev)\n\t\t\t\tduparg2(\"dev\", *argv);\n\t\t\tif (check_ifname(*argv))\n\t\t\t\tinvarg(\"\\\"dev\\\" not a valid ifname\", *argv);\n\t\t\tdev = *argv;\n\t\t}\n\t\targc--; argv++;\n\t}\n\n\tif (!dev) {\n\t\tfprintf(stderr,\n\t\t\t\"Not enough of information: \\\"dev\\\" argument is required.\\n\");\n\t\texit(-1);\n\t}\n\n\tif (newaddr || newbrd) {\n\t\thalen = get_address(dev, &htype);\n\t\tif (halen < 0)\n\t\t\treturn -1;\n\t\tif (newaddr) {\n\t\t\tif (parse_address(dev, htype, halen,\n\t\t\t\t\t  newaddr, &ifr0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (newbrd) {\n\t\t\tif (parse_address(dev, htype, halen,\n\t\t\t\t\t  newbrd, &ifr1) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (newname && strcmp(dev, newname)) {\n\t\tif (do_changename(dev, newname) < 0)\n\t\t\treturn -1;\n\t\tdev = newname;\n\t}\n\tif (qlen != -1) {\n\t\tif (set_qlen(dev, qlen) < 0)\n\t\t\treturn -1;\n\t}\n\tif (mtu != -1) {\n\t\tif (set_mtu(dev, mtu) < 0)\n\t\t\treturn -1;\n\t}\n\tif (newaddr || newbrd) {\n\t\tif (newbrd) {\n\t\t\tif (set_address(&ifr1, 1) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (newaddr) {\n\t\t\tif (set_address(&ifr0, 0) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (mask)\n\t\treturn do_chflags(dev, flags, mask);\n\treturn 0;\n}\n#endif /* IPLINK_IOCTL_COMPAT */\n\nstatic void print_mpls_stats(FILE *fp, struct rtattr *attr)\n{\n\tstruct rtattr *mrtb[MPLS_STATS_MAX+1];\n\tstruct mpls_link_stats *stats;\n\n\tparse_rtattr(mrtb, MPLS_STATS_MAX, RTA_DATA(attr),\n\t\t     RTA_PAYLOAD(attr));\n\tif (!mrtb[MPLS_STATS_LINK])\n\t\treturn;\n\n\tstats = RTA_DATA(mrtb[MPLS_STATS_LINK]);\n\n\tfprintf(fp, \"    mpls:\\n\");\n\tfprintf(fp, \"        RX: bytes  packets  errors  dropped  noroute\\n\");\n\tfprintf(fp, \"        \");\n\tprint_num(fp, 10, stats->rx_bytes);\n\tprint_num(fp, 8, stats->rx_packets);\n\tprint_num(fp, 7, stats->rx_errors);\n\tprint_num(fp, 8, stats->rx_dropped);\n\tprint_num(fp, 7, stats->rx_noroute);\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"        TX: bytes  packets  errors  dropped\\n\");\n\tfprintf(fp, \"        \");\n\tprint_num(fp, 10, stats->tx_bytes);\n\tprint_num(fp, 8, stats->tx_packets);\n\tprint_num(fp, 7, stats->tx_errors);\n\tprint_num(fp, 7, stats->tx_dropped);\n\tfprintf(fp, \"\\n\");\n}\n\nstatic void print_af_stats_attr(FILE *fp, int ifindex, struct rtattr *attr)\n{\n\tbool if_printed = false;\n\tstruct rtattr *i;\n\tint rem;\n\n\trem = RTA_PAYLOAD(attr);\n\tfor (i = RTA_DATA(attr); RTA_OK(i, rem); i = RTA_NEXT(i, rem)) {\n\t\tif (preferred_family != AF_UNSPEC &&\n\t\t    i->rta_type != preferred_family)\n\t\t\tcontinue;\n\n\t\tif (!if_printed) {\n\t\t\tfprintf(fp, \"%u: %s\\n\", ifindex,\n\t\t\t\tll_index_to_name(ifindex));\n\t\t\tif_printed = true;\n\t\t}\n\n\t\tswitch (i->rta_type) {\n\t\tcase AF_MPLS:\n\t\t\tprint_mpls_stats(fp, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fp, \"    unknown af(%d)\\n\", i->rta_type);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstruct af_stats_ctx {\n\tFILE *fp;\n\tint ifindex;\n};\n\nstatic int print_af_stats(struct nlmsghdr *n, void *arg)\n{\n\tstruct if_stats_msg *ifsm = NLMSG_DATA(n);\n\tstruct rtattr *tb[IFLA_STATS_MAX+1];\n\tint len = n->nlmsg_len;\n\tstruct af_stats_ctx *ctx = arg;\n\tFILE *fp = ctx->fp;\n\n\tlen -= NLMSG_LENGTH(sizeof(*ifsm));\n\tif (len < 0) {\n\t\tfprintf(stderr, \"BUG: wrong nlmsg len %d\\n\", len);\n\t\treturn -1;\n\t}\n\n\tif (ctx->ifindex && ifsm->ifindex != ctx->ifindex)\n\t\treturn 0;\n\n\tparse_rtattr(tb, IFLA_STATS_MAX, IFLA_STATS_RTA(ifsm), len);\n\n\tif (tb[IFLA_STATS_AF_SPEC])\n\t\tprint_af_stats_attr(fp, ifsm->ifindex, tb[IFLA_STATS_AF_SPEC]);\n\n\tfflush(fp);\n\treturn 0;\n}\n\nstatic int iplink_afstats(int argc, char **argv)\n{\n\t__u32 filt_mask = IFLA_STATS_FILTER_BIT(IFLA_STATS_AF_SPEC);\n\tconst char *filter_dev = NULL;\n\tstruct af_stats_ctx ctx = {\n\t\t.fp = stdout,\n\t\t.ifindex = 0,\n\t};\n\n\twhile (argc > 0) {\n\t\tif (strcmp(*argv, \"dev\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (filter_dev)\n\t\t\t\tduparg2(\"dev\", *argv);\n\t\t\tfilter_dev = *argv;\n\t\t} else if (matches(*argv, \"help\") == 0) {\n\t\t\tusage();\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Command \\\"%s\\\" is unknown, try \\\"ip link help\\\".\\n\",\n\t\t\t\t*argv);\n\t\t\texit(-1);\n\t\t}\n\n\t\targv++; argc--;\n\t}\n\n\tif (filter_dev) {\n\t\tctx.ifindex = ll_name_to_index(filter_dev);\n\t\tif (ctx.ifindex <= 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Device \\\"%s\\\" does not exist.\\n\",\n\t\t\t\tfilter_dev);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (rtnl_statsdump_req_filter(&rth, AF_UNSPEC, filt_mask) < 0) {\n\t\tperror(\"Cannont send dump request\");\n\t\treturn 1;\n\t}\n\n\tif (rtnl_dump_filter(&rth, print_af_stats, &ctx) < 0) {\n\t\tfprintf(stderr, \"Dump terminated\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iplink_prop_mod(int argc, char **argv, struct iplink_req *req)\n{\n\tstruct rtattr *proplist;\n\tchar *dev = NULL;\n\tchar *name;\n\n\tproplist = addattr_nest(&req->n, sizeof(*req),\n\t\t\t\tIFLA_PROP_LIST | NLA_F_NESTED);\n\n\twhile (argc > 0) {\n\t\tif (matches(*argv, \"altname\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (check_altifname(*argv))\n\t\t\t\tinvarg(\"not a valid altname\", *argv);\n\t\t\tname = *argv;\n\t\t\taddattr_l(&req->n, sizeof(*req), IFLA_ALT_IFNAME,\n\t\t\t\t  name, strlen(name) + 1);\n\t\t} else if (matches(*argv, \"help\") == 0) {\n\t\t\tusage();\n\t\t} else {\n\t\t\tif (strcmp(*argv, \"dev\") == 0)\n\t\t\t\tNEXT_ARG();\n\t\t\tif (dev)\n\t\t\t\tduparg2(\"dev\", *argv);\n\t\t\tif (check_altifname(*argv))\n\t\t\t\tinvarg(\"\\\"dev\\\" not a valid ifname\", *argv);\n\t\t\tdev = *argv;\n\t\t}\n\t\targv++; argc--;\n\t}\n\taddattr_nest_end(&req->n, proplist);\n\n\tif (!dev) {\n\t\tfprintf(stderr, \"Not enough of information: \\\"dev\\\" argument is required.\\n\");\n\t\texit(-1);\n\t}\n\n\treq->i.ifi_index = ll_name_to_index(dev);\n\tif (!req->i.ifi_index)\n\t\treturn nodev(dev);\n\n\tif (rtnl_talk(&rth, &req->n, NULL) < 0)\n\t\treturn -2;\n\n\treturn 0;\n}\n\nstatic int iplink_prop(int argc, char **argv)\n{\n\tstruct iplink_req req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.i.ifi_family = preferred_family,\n\t};\n\n\tif (argc <= 0) {\n\t\tusage();\n\t\texit(-1);\n\t}\n\n\tif (matches(*argv, \"add\") == 0) {\n\t\treq.n.nlmsg_flags |= NLM_F_EXCL | NLM_F_CREATE | NLM_F_APPEND;\n\t\treq.n.nlmsg_type = RTM_NEWLINKPROP;\n\t} else if (matches(*argv, \"del\") == 0) {\n\t\treq.n.nlmsg_type = RTM_DELLINKPROP;\n\t} else if (matches(*argv, \"help\") == 0) {\n\t\tusage();\n\t} else {\n\t\tfprintf(stderr, \"Operator required\\n\");\n\t\texit(-1);\n\t}\n\treturn iplink_prop_mod(argc - 1, argv + 1, &req);\n}\n\nstatic void do_help(int argc, char **argv)\n{\n\tstruct link_util *lu = NULL;\n\n\tif (argc <= 0) {\n\t\tusage();\n\t\treturn;\n\t}\n\n\tlu = get_link_kind(*argv);\n\tif (lu && lu->print_help)\n\t\tlu->print_help(lu, argc-1, argv+1, stdout);\n\telse\n\t\tusage();\n}\n\nint do_iplink(int argc, char **argv)\n{\n\tif (argc < 1)\n\t\treturn ipaddr_list_link(0, NULL);\n\n\tif (iplink_have_newlink()) {\n\t\tif (matches(*argv, \"add\") == 0)\n\t\t\treturn iplink_modify(RTM_NEWLINK,\n\t\t\t\t\t     NLM_F_CREATE|NLM_F_EXCL,\n\t\t\t\t\t     argc-1, argv+1);\n\t\tif (matches(*argv, \"set\") == 0 ||\n\t\t    matches(*argv, \"change\") == 0)\n\t\t\treturn iplink_modify(RTM_NEWLINK, 0,\n\t\t\t\t\t     argc-1, argv+1);\n\t\tif (matches(*argv, \"replace\") == 0)\n\t\t\treturn iplink_modify(RTM_NEWLINK,\n\t\t\t\t\t     NLM_F_CREATE|NLM_F_REPLACE,\n\t\t\t\t\t     argc-1, argv+1);\n\t\tif (matches(*argv, \"delete\") == 0)\n\t\t\treturn iplink_modify(RTM_DELLINK, 0,\n\t\t\t\t\t     argc-1, argv+1);\n\t} else {\n#if IPLINK_IOCTL_COMPAT\n\t\tif (matches(*argv, \"set\") == 0)\n\t\t\treturn do_set(argc-1, argv+1);\n#endif\n\t}\n\n\tif (matches(*argv, \"show\") == 0 ||\n\t    matches(*argv, \"lst\") == 0 ||\n\t    matches(*argv, \"list\") == 0)\n\t\treturn ipaddr_list_link(argc-1, argv+1);\n\n\tif (matches(*argv, \"xstats\") == 0)\n\t\treturn iplink_ifla_xstats(argc-1, argv+1);\n\n\tif (matches(*argv, \"afstats\") == 0) {\n\t\tiplink_afstats(argc-1, argv+1);\n\t\treturn 0;\n\t}\n\n\tif (matches(*argv, \"property\") == 0)\n\t\treturn iplink_prop(argc-1, argv+1);\n\n\tif (matches(*argv, \"help\") == 0) {\n\t\tdo_help(argc-1, argv+1);\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"Command \\\"%s\\\" is unknown, try \\\"ip link help\\\".\\n\",\n\t\t*argv);\n\texit(-1);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/m_ipt.c": "/*\n * m_ipt.c\tiptables based targets\n *\t\tutilities mostly ripped from iptables <duh, its the linux way>\n *\n *\t\tThis program is free software; you can distribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:  J Hadi Salim (hadi@cyberus.ca)\n */\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <iptables.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include \"utils.h\"\n#include \"tc_util.h\"\n#include <linux/tc_act/tc_ipt.h>\n#include <stdio.h>\n#include <dlfcn.h>\n#include <getopt.h>\n#include <errno.h>\n#include <string.h>\n#include <netdb.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n\nstatic const char *pname = \"tc-ipt\";\nstatic const char *tname = \"mangle\";\nstatic const char *pversion = \"0.1\";\n\nstatic const char *ipthooks[] = {\n\t\"NF_IP_PRE_ROUTING\",\n\t\"NF_IP_LOCAL_IN\",\n\t\"NF_IP_FORWARD\",\n\t\"NF_IP_LOCAL_OUT\",\n\t\"NF_IP_POST_ROUTING\",\n};\n\nstatic struct option original_opts[] = {\n\t{\"jump\", 1, 0, 'j'},\n\t{0, 0, 0, 0}\n};\n\nstatic struct xtables_target *t_list;\nstatic struct option *opts = original_opts;\nstatic unsigned int global_option_offset;\n#define OPTION_OFFSET 256\n\nchar *lib_dir;\n\nvoid\nxtables_register_target(struct xtables_target *me)\n{\n\tme->next = t_list;\n\tt_list = me;\n\n}\n\nstatic void exit_tryhelp(int status)\n{\n\tfprintf(stderr, \"Try `%s -h' or '%s --help' for more information.\\n\",\n\t\tpname, pname);\n\texit(status);\n}\n\nstatic void exit_error(enum xtables_exittype status, char *msg, ...)\n{\n\tva_list args;\n\n\tva_start(args, msg);\n\tfprintf(stderr, \"%s v%s: \", pname, pversion);\n\tvfprintf(stderr, msg, args);\n\tva_end(args);\n\tfprintf(stderr, \"\\n\");\n\tif (status == PARAMETER_PROBLEM)\n\t\texit_tryhelp(status);\n\tif (status == VERSION_PROBLEM)\n\t\tfprintf(stderr,\n\t\t\t\"Perhaps iptables or your kernel needs to be upgraded.\\n\");\n\texit(status);\n}\n\n/* stolen from iptables 1.2.11\nThey should really have them as a library so i can link to them\nEmail them next time i remember\n*/\n\nstatic void free_opts(struct option *local_opts)\n{\n\tif (local_opts != original_opts) {\n\t\tfree(local_opts);\n\t\topts = original_opts;\n\t\tglobal_option_offset = 0;\n\t}\n}\n\nstatic struct option *\nmerge_options(struct option *oldopts, const struct option *newopts,\n\t      unsigned int *option_offset)\n{\n\tstruct option *merge;\n\tunsigned int num_old, num_new, i;\n\n\tfor (num_old = 0; oldopts[num_old].name; num_old++);\n\tfor (num_new = 0; newopts[num_new].name; num_new++);\n\n\t*option_offset = global_option_offset + OPTION_OFFSET;\n\n\tmerge = malloc(sizeof(struct option) * (num_new + num_old + 1));\n\tmemcpy(merge, oldopts, num_old * sizeof(struct option));\n\tfor (i = 0; i < num_new; i++) {\n\t\tmerge[num_old + i] = newopts[i];\n\t\tmerge[num_old + i].val += *option_offset;\n\t}\n\tmemset(merge + num_old + num_new, 0, sizeof(struct option));\n\n\treturn merge;\n}\n\nstatic void *\nfw_calloc(size_t count, size_t size)\n{\n\tvoid *p;\n\n\tif ((p = (void *) calloc(count, size)) == NULL) {\n\t\tperror(\"iptables: calloc failed\");\n\t\texit(1);\n\t}\n\treturn p;\n}\n\nstatic struct xtables_target *\nfind_t(char *name)\n{\n\tstruct xtables_target *m;\n\n\tfor (m = t_list; m; m = m->next) {\n\t\tif (strcmp(m->name, name) == 0)\n\t\t\treturn m;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct xtables_target *\nget_target_name(const char *name)\n{\n\tvoid *handle;\n\tchar *error;\n\tchar *new_name, *lname;\n\tstruct xtables_target *m;\n\tchar path[strlen(lib_dir) + sizeof(\"/libipt_.so\") + strlen(name)];\n\n#ifdef NO_SHARED_LIBS\n\treturn NULL;\n#endif\n\n\tnew_name = calloc(1, strlen(name) + 1);\n\tlname = calloc(1, strlen(name) + 1);\n\tif (!new_name)\n\t\texit_error(PARAMETER_PROBLEM, \"get_target_name\");\n\tif (!lname)\n\t\texit_error(PARAMETER_PROBLEM, \"get_target_name\");\n\n\tstrcpy(new_name, name);\n\tstrcpy(lname, name);\n\n\tif (isupper(lname[0])) {\n\t\tint i;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tlname[i] = tolower(lname[i]);\n\t\t}\n\t}\n\n\tif (islower(new_name[0])) {\n\t\tint i;\n\n\t\tfor (i = 0; i < strlen(new_name); i++) {\n\t\t\tnew_name[i] = toupper(new_name[i]);\n\t\t}\n\t}\n\n\t/* try libxt_xx first */\n\tsprintf(path, \"%s/libxt_%s.so\", lib_dir, new_name);\n\thandle = dlopen(path, RTLD_LAZY);\n\tif (!handle) {\n\t\t/* try libipt_xx next */\n\t\tsprintf(path, \"%s/libipt_%s.so\", lib_dir, new_name);\n\t\thandle = dlopen(path, RTLD_LAZY);\n\n\t\tif (!handle) {\n\t\t\tsprintf(path, \"%s/libxt_%s.so\", lib_dir, lname);\n\t\t\thandle = dlopen(path, RTLD_LAZY);\n\t\t}\n\n\t\tif (!handle) {\n\t\t\tsprintf(path, \"%s/libipt_%s.so\", lib_dir, lname);\n\t\t\thandle = dlopen(path, RTLD_LAZY);\n\t\t}\n\t\t/* ok, lets give up .. */\n\t\tif (!handle) {\n\t\t\tfputs(dlerror(), stderr);\n\t\t\tprintf(\"\\n\");\n\t\t\tfree(new_name);\n\t\t\tfree(lname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tm = dlsym(handle, new_name);\n\tif ((error = dlerror()) != NULL) {\n\t\tm = (struct xtables_target *) dlsym(handle, lname);\n\t\tif ((error = dlerror()) != NULL) {\n\t\t\tm = find_t(new_name);\n\t\t\tif (m == NULL) {\n\t\t\t\tm = find_t(lname);\n\t\t\t\tif (m == NULL) {\n\t\t\t\t\tfputs(error, stderr);\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tdlclose(handle);\n\t\t\t\t\tfree(new_name);\n\t\t\t\t\tfree(lname);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(new_name);\n\tfree(lname);\n\treturn m;\n}\n\nstatic void set_revision(char *name, u_int8_t revision)\n{\n\t/* Old kernel sources don't have \".revision\" field,\n\t*  but we stole a byte from name. */\n\tname[IPT_FUNCTION_MAXNAMELEN - 2] = '\\0';\n\tname[IPT_FUNCTION_MAXNAMELEN - 1] = revision;\n}\n\n/*\n * we may need to check for version mismatch\n*/\nstatic int build_st(struct xtables_target *target, struct ipt_entry_target *t)\n{\n\tif (target) {\n\t\tsize_t size;\n\n\t\tsize =\n\t\t    XT_ALIGN(sizeof(struct ipt_entry_target)) + target->size;\n\n\t\tif (t == NULL) {\n\t\t\ttarget->t = fw_calloc(1, size);\n\t\t\ttarget->t->u.target_size = size;\n\n\t\t\tif (target->init != NULL)\n\t\t\t\ttarget->init(target->t);\n\t\t\tset_revision(target->t->u.user.name, target->revision);\n\t\t} else {\n\t\t\ttarget->t = t;\n\t\t}\n\t\tstrcpy(target->t->u.user.name, target->name);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int parse_ipt(struct action_util *a, int *argc_p,\n\t\t     char ***argv_p, int tca_id, struct nlmsghdr *n)\n{\n\tstruct xtables_target *m = NULL;\n\tstruct ipt_entry fw;\n\tstruct rtattr *tail;\n\tint c;\n\tint rargc = *argc_p;\n\tchar **argv = *argv_p;\n\tint argc = 0, iargc = 0;\n\tchar k[FILTER_NAMESZ];\n\tint size = 0;\n\tint iok = 0, ok = 0;\n\t__u32 hook = 0, index = 0;\n\n\tlib_dir = getenv(\"IPTABLES_LIB_DIR\");\n\tif (!lib_dir)\n\t\tlib_dir = IPT_LIB_DIR;\n\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < rargc; i++) {\n\t\t\tif (!argv[i] || strcmp(argv[i], \"action\") == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tiargc = argc = i;\n\t}\n\n\tif (argc <= 2) {\n\t\tfprintf(stderr, \"bad arguments to ipt %d vs %d\\n\", argc, rargc);\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"j:\", opts, NULL);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'j':\n\t\t\tm = get_target_name(optarg);\n\t\t\tif (m != NULL) {\n\n\t\t\t\tif (build_st(m, NULL) < 0) {\n\t\t\t\t\tprintf(\" %s error\\n\", m->name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\topts =\n\t\t\t\t    merge_options(opts, m->extra_opts,\n\t\t\t\t\t\t  &m->option_offset);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \" failed to find target %s\\n\\n\", optarg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tok++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmemset(&fw, 0, sizeof(fw));\n\t\t\tif (m) {\n\t\t\t\tm->parse(c - m->option_offset, argv, 0,\n\t\t\t\t\t &m->tflags, NULL, &m->t);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \" failed to find target %s\\n\\n\", optarg);\n\t\t\t\treturn -1;\n\n\t\t\t}\n\t\t\tok++;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tif (iargc > optind) {\n\t\tif (matches(argv[optind], \"index\") == 0) {\n\t\t\tif (get_u32(&index, argv[optind + 1], 10)) {\n\t\t\t\tfprintf(stderr, \"Illegal \\\"index\\\"\\n\");\n\t\t\t\tfree_opts(opts);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tiok++;\n\n\t\t\toptind += 2;\n\t\t}\n\t}\n\n\tif (!ok && !iok) {\n\t\tfprintf(stderr, \" ipt Parser BAD!! (%s)\\n\", *argv);\n\t\treturn -1;\n\t}\n\n\t/* check that we passed the correct parameters to the target */\n\tif (m)\n\t\tm->final_check(m->tflags);\n\n\t{\n\t\tstruct tcmsg *t = NLMSG_DATA(n);\n\n\t\tif (t->tcm_parent != TC_H_ROOT\n\t\t    && t->tcm_parent == TC_H_MAJ(TC_H_INGRESS)) {\n\t\t\thook = NF_IP_PRE_ROUTING;\n\t\t} else {\n\t\t\thook = NF_IP_POST_ROUTING;\n\t\t}\n\t}\n\n\ttail = addattr_nest(n, MAX_MSG, tca_id);\n\tfprintf(stdout, \"tablename: %s hook: %s\\n \", tname, ipthooks[hook]);\n\tfprintf(stdout, \"\\ttarget: \");\n\n\tif (m)\n\t\tm->print(NULL, m->t, 0);\n\tfprintf(stdout, \" index %d\\n\", index);\n\n\tif (strlen(tname) > 16) {\n\t\tsize = 16;\n\t\tk[15] = 0;\n\t} else {\n\t\tsize = 1 + strlen(tname);\n\t}\n\tstrncpy(k, tname, size);\n\n\taddattr_l(n, MAX_MSG, TCA_IPT_TABLE, k, size);\n\taddattr_l(n, MAX_MSG, TCA_IPT_HOOK, &hook, 4);\n\taddattr_l(n, MAX_MSG, TCA_IPT_INDEX, &index, 4);\n\tif (m)\n\t\taddattr_l(n, MAX_MSG, TCA_IPT_TARG, m->t, m->t->u.target_size);\n\taddattr_nest_end(n, tail);\n\n\targc -= optind;\n\targv += optind;\n\t*argc_p = rargc - iargc;\n\t*argv_p = argv;\n\n\toptind = 0;\n\tfree_opts(opts);\n\t/* Clear flags if target will be used again */\n        m->tflags = 0;\n        m->used = 0;\n\t/* Free allocated memory */\n\tif (m->t)\n\t    free(m->t);\n\n\n\treturn 0;\n\n}\n\nstatic int\nprint_ipt(struct action_util *au, FILE * f, struct rtattr *arg)\n{\n\tstruct rtattr *tb[TCA_IPT_MAX + 1];\n\tstruct ipt_entry_target *t = NULL;\n\tstruct xtables_target *m;\n\t__u32 hook;\n\n\tif (arg == NULL)\n\t\treturn -1;\n\n\tlib_dir = getenv(\"IPTABLES_LIB_DIR\");\n\tif (!lib_dir)\n\t\tlib_dir = IPT_LIB_DIR;\n\n\tparse_rtattr_nested(tb, TCA_IPT_MAX, arg);\n\n\tif (tb[TCA_IPT_TABLE] == NULL) {\n\t\tfprintf(stderr,  \"Missing ipt table name, assuming mangle\\n\");\n\t} else {\n\t\tfprintf(f, \"tablename: %s \",\n\t\t\trta_getattr_str(tb[TCA_IPT_TABLE]));\n\t}\n\n\tif (tb[TCA_IPT_HOOK] == NULL) {\n\t\tfprintf(stderr, \"Missing ipt hook name\\n \");\n\t\treturn -1;\n\t}\n\n\thook = rta_getattr_u32(tb[TCA_IPT_HOOK]);\n\tfprintf(f, \" hook: %s\\n\", ipthooks[hook]);\n\n\tif (tb[TCA_IPT_TARG] == NULL) {\n\t\tfprintf(stderr, \"Missing ipt target parameters\\n\");\n\t\treturn -1;\n\t}\n\n\n\tt = RTA_DATA(tb[TCA_IPT_TARG]);\n\tm = get_target_name(t->u.user.name);\n\tif (m != NULL) {\n\t\tif (build_st(m, t) < 0) {\n\t\t\tfprintf(stderr, \" %s error\\n\", m->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\topts =\n\t\t\tmerge_options(opts, m->extra_opts,\n\t\t\t\t      &m->option_offset);\n\t} else {\n\t\tfprintf(stderr, \" failed to find target %s\\n\\n\",\n\t\t\tt->u.user.name);\n\t\treturn -1;\n\t}\n\n\tfprintf(f, \"\\ttarget \");\n\tm->print(NULL, m->t, 0);\n\tif (tb[TCA_IPT_INDEX] == NULL) {\n\t\tfprintf(stderr, \"Missing ipt target index\\n\");\n\t} else {\n\t\t__u32 index;\n\n\t\tindex = rta_getattr_u32(tb[TCA_IPT_INDEX]);\n\t\tfprintf(f, \"\\n\\tindex %u\", index);\n\t}\n\n\tif (tb[TCA_IPT_CNT]) {\n\t\tstruct tc_cnt *c  = RTA_DATA(tb[TCA_IPT_CNT]);\n\n\t\tfprintf(f, \" ref %d bind %d\", c->refcnt, c->bindcnt);\n\t}\n\tif (show_stats) {\n\t\tif (tb[TCA_IPT_TM]) {\n\t\t\tstruct tcf_t *tm = RTA_DATA(tb[TCA_IPT_TM]);\n\n\t\t\tprint_tm(f, tm);\n\t\t}\n\t}\n\tfprintf(f, \"\\n\");\n\n\tfree_opts(opts);\n\n\treturn 0;\n}\n\nstruct action_util ipt_action_util = {\n\t.id = \"ipt\",\n\t.parse_aopt = parse_ipt,\n\t.print_aopt = print_ipt,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/tc.c": "/*\n * tc.c\t\t\"tc\" utility frontend.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n * Fixes:\n *\n * Petri Mattila <petri@prihateam.fi> 990308: wrong memset's resulted in faults\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"SNAPSHOT.h\"\n#include \"utils.h\"\n#include \"tc_util.h\"\n#include \"tc_common.h\"\n#include \"namespace.h\"\n#include \"rt_names.h\"\n\nint show_stats;\nint show_details;\nint show_raw;\nint show_graph;\nint timestamp;\n\nint batch_mode;\nint use_iec;\nint force;\nbool use_names;\nint json;\nint color;\nint oneline;\n\nstatic char *conf_file;\n\nstruct rtnl_handle rth;\n\nstatic void *BODY;\t/* cached handle dlopen(NULL) */\nstatic struct qdisc_util *qdisc_list;\nstatic struct filter_util *filter_list;\n\nstatic int print_noqopt(struct qdisc_util *qu, FILE *f,\n\t\t\tstruct rtattr *opt)\n{\n\tif (opt && RTA_PAYLOAD(opt))\n\t\tfprintf(f, \"[Unknown qdisc, optlen=%u] \",\n\t\t\t(unsigned int) RTA_PAYLOAD(opt));\n\treturn 0;\n}\n\nstatic int parse_noqopt(struct qdisc_util *qu, int argc, char **argv,\n\t\t\tstruct nlmsghdr *n, const char *dev)\n{\n\tif (argc) {\n\t\tfprintf(stderr,\n\t\t\t\"Unknown qdisc \\\"%s\\\", hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\tqu->id, *argv);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int print_nofopt(struct filter_util *qu, FILE *f, struct rtattr *opt, __u32 fhandle)\n{\n\tif (opt && RTA_PAYLOAD(opt))\n\t\tfprintf(f, \"fh %08x [Unknown filter, optlen=%u] \",\n\t\t\tfhandle, (unsigned int) RTA_PAYLOAD(opt));\n\telse if (fhandle)\n\t\tfprintf(f, \"fh %08x \", fhandle);\n\treturn 0;\n}\n\nstatic int parse_nofopt(struct filter_util *qu, char *fhandle,\n\t\t\tint argc, char **argv, struct nlmsghdr *n)\n{\n\t__u32 handle;\n\n\tif (argc) {\n\t\tfprintf(stderr,\n\t\t\t\"Unknown filter \\\"%s\\\", hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\tqu->id, *argv);\n\t\treturn -1;\n\t}\n\tif (fhandle) {\n\t\tstruct tcmsg *t = NLMSG_DATA(n);\n\n\t\tif (get_u32(&handle, fhandle, 16)) {\n\t\t\tfprintf(stderr, \"Unparsable filter ID \\\"%s\\\"\\n\", fhandle);\n\t\t\treturn -1;\n\t\t}\n\t\tt->tcm_handle = handle;\n\t}\n\treturn 0;\n}\n\nstruct qdisc_util *get_qdisc_kind(const char *str)\n{\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct qdisc_util *q;\n\n\tfor (q = qdisc_list; q; q = q->next)\n\t\tif (strcmp(q->id, str) == 0)\n\t\t\treturn q;\n\n\tsnprintf(buf, sizeof(buf), \"%s/q_%s.so\", get_tc_lib(), str);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (!dlh) {\n\t\t/* look in current binary, only open once */\n\t\tdlh = BODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = BODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_qdisc_util\", str);\n\tq = dlsym(dlh, buf);\n\tif (q == NULL)\n\t\tgoto noexist;\n\nreg:\n\tq->next = qdisc_list;\n\tqdisc_list = q;\n\treturn q;\n\nnoexist:\n\tq = calloc(1, sizeof(*q));\n\tif (q) {\n\t\tq->id = strdup(str);\n\t\tq->parse_qopt = parse_noqopt;\n\t\tq->print_qopt = print_noqopt;\n\t\tgoto reg;\n\t}\n\treturn q;\n}\n\n\nstruct filter_util *get_filter_kind(const char *str)\n{\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct filter_util *q;\n\n\tfor (q = filter_list; q; q = q->next)\n\t\tif (strcmp(q->id, str) == 0)\n\t\t\treturn q;\n\n\tsnprintf(buf, sizeof(buf), \"%s/f_%s.so\", get_tc_lib(), str);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\tdlh = BODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = BODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_filter_util\", str);\n\tq = dlsym(dlh, buf);\n\tif (q == NULL)\n\t\tgoto noexist;\n\nreg:\n\tq->next = filter_list;\n\tfilter_list = q;\n\treturn q;\nnoexist:\n\tq = calloc(1, sizeof(*q));\n\tif (q) {\n\t\tstrncpy(q->id, str, 15);\n\t\tq->parse_fopt = parse_nofopt;\n\t\tq->print_fopt = print_nofopt;\n\t\tgoto reg;\n\t}\n\treturn q;\n}\n\nstatic void usage(void)\n{\n\tfprintf(stderr,\n\t\t\"Usage:\ttc [ OPTIONS ] OBJECT { COMMAND | help }\\n\"\n\t\t\"\ttc [-force] -batch filename\\n\"\n\t\t\"where  OBJECT := { qdisc | class | filter | chain |\\n\"\n\t\t\"\t\t    action | monitor | exec }\\n\"\n\t\t\"       OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[aw] |\\n\"\n\t\t\"\t\t    -o[neline] | -j[son] | -p[retty] | -c[olor]\\n\"\n\t\t\"\t\t    -b[atch] [filename] | -n[etns] name | -N[umeric] |\\n\"\n\t\t\"\t\t     -nm | -nam[es] | { -cf | -conf } path }\\n\");\n}\n\nstatic int do_cmd(int argc, char **argv)\n{\n\tif (matches(*argv, \"qdisc\") == 0)\n\t\treturn do_qdisc(argc-1, argv+1);\n\tif (matches(*argv, \"class\") == 0)\n\t\treturn do_class(argc-1, argv+1);\n\tif (matches(*argv, \"filter\") == 0)\n\t\treturn do_filter(argc-1, argv+1);\n\tif (matches(*argv, \"chain\") == 0)\n\t\treturn do_chain(argc-1, argv+1);\n\tif (matches(*argv, \"actions\") == 0)\n\t\treturn do_action(argc-1, argv+1);\n\tif (matches(*argv, \"monitor\") == 0)\n\t\treturn do_tcmonitor(argc-1, argv+1);\n\tif (matches(*argv, \"exec\") == 0)\n\t\treturn do_exec(argc-1, argv+1);\n\tif (matches(*argv, \"help\") == 0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"Object \\\"%s\\\" is unknown, try \\\"tc help\\\".\\n\",\n\t\t*argv);\n\treturn -1;\n}\n\nstatic int batch(const char *name)\n{\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret = 0;\n\n\tbatch_mode = 1;\n\tif (name && strcmp(name, \"-\") != 0) {\n\t\tif (freopen(name, \"r\", stdin) == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Cannot open file \\\"%s\\\" for reading: %s\\n\",\n\t\t\t\tname, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\ttc_core_init();\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"Cannot open rtnetlink\\n\");\n\t\treturn -1;\n\t}\n\n\tcmdlineno = 0;\n\twhile (getcmdline(&line, &len, stdin) != -1) {\n\t\tchar *largv[100];\n\t\tint largc;\n\n\t\tlargc = makeargs(line, largv, 100);\n\t\tif (largc == 0)\n\t\t\tcontinue;\t/* blank line */\n\n\t\tif (do_cmd(largc, largv)) {\n\t\t\tfprintf(stderr, \"Command failed %s:%d\\n\",\n\t\t\t\tname, cmdlineno);\n\t\t\tret = 1;\n\t\t\tif (!force)\n\t\t\t\tbreak;\n\t\t}\n\t\tfflush(stdout);\n\t}\n\n\tfree(line);\n\trtnl_close(&rth);\n\treturn ret;\n}\n\n\nint main(int argc, char **argv)\n{\n\tint ret;\n\tchar *batch_file = NULL;\n\n\twhile (argc > 1) {\n\t\tif (argv[1][0] != '-')\n\t\t\tbreak;\n\t\tif (matches(argv[1], \"-stats\") == 0 ||\n\t\t\t matches(argv[1], \"-statistics\") == 0) {\n\t\t\t++show_stats;\n\t\t} else if (matches(argv[1], \"-details\") == 0) {\n\t\t\t++show_details;\n\t\t} else if (matches(argv[1], \"-raw\") == 0) {\n\t\t\t++show_raw;\n\t\t} else if (matches(argv[1], \"-pretty\") == 0) {\n\t\t\t++pretty;\n\t\t} else if (matches(argv[1], \"-graph\") == 0) {\n\t\t\tshow_graph = 1;\n\t\t} else if (matches(argv[1], \"-Version\") == 0) {\n\t\t\tprintf(\"tc utility, iproute2-ss%s\\n\", SNAPSHOT);\n\t\t\treturn 0;\n\t\t} else if (matches(argv[1], \"-iec\") == 0) {\n\t\t\t++use_iec;\n\t\t} else if (matches(argv[1], \"-help\") == 0) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t} else if (matches(argv[1], \"-force\") == 0) {\n\t\t\t++force;\n\t\t} else if (matches(argv[1], \"-batch\") == 0) {\n\t\t\targc--;\targv++;\n\t\t\tif (argc <= 1)\n\t\t\t\tusage();\n\t\t\tbatch_file = argv[1];\n\t\t} else if (matches(argv[1], \"-netns\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (netns_switch(argv[1]))\n\t\t\t\treturn -1;\n\t\t} else if (matches(argv[1], \"-Numeric\") == 0) {\n\t\t\t++numeric;\n\t\t} else if (matches(argv[1], \"-names\") == 0 ||\n\t\t\t\tmatches(argv[1], \"-nm\") == 0) {\n\t\t\tuse_names = true;\n\t\t} else if (matches(argv[1], \"-cf\") == 0 ||\n\t\t\t\tmatches(argv[1], \"-conf\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tconf_file = argv[1];\n\t\t} else if (matches_color(argv[1], &color)) {\n\t\t} else if (matches(argv[1], \"-timestamp\") == 0) {\n\t\t\ttimestamp++;\n\t\t} else if (matches(argv[1], \"-tshort\") == 0) {\n\t\t\t++timestamp;\n\t\t\t++timestamp_short;\n\t\t} else if (matches(argv[1], \"-json\") == 0) {\n\t\t\t++json;\n\t\t} else if (matches(argv[1], \"-oneline\") == 0) {\n\t\t\t++oneline;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Option \\\"%s\\\" is unknown, try \\\"tc -help\\\".\\n\",\n\t\t\t\targv[1]);\n\t\t\treturn -1;\n\t\t}\n\t\targc--;\targv++;\n\t}\n\n\t_SL_ = oneline ? \"\\\\\" : \"\\n\";\n\n\tcheck_enable_color(color, json);\n\n\tif (batch_file)\n\t\treturn batch(batch_file);\n\n\tif (argc <= 1) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\ttc_core_init();\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"Cannot open rtnetlink\\n\");\n\t\texit(1);\n\t}\n\n\tif (use_names && cls_names_init(conf_file)) {\n\t\tret = -1;\n\t\tgoto Exit;\n\t}\n\n\tret = do_cmd(argc-1, argv+1);\nExit:\n\trtnl_close(&rth);\n\n\tif (use_names)\n\t\tcls_names_uninit();\n\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/m_action.c": "/*\n * m_action.c\t\tAction Management\n *\n *\t\tThis program is free software; you can distribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:  J Hadi Salim (hadi@cyberus.ca)\n *\n * TODO:\n * - parse to be passed a filedescriptor for logging purposes\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"utils.h\"\n#include \"tc_common.h\"\n#include \"tc_util.h\"\n\nstatic struct action_util *action_list;\n#ifdef CONFIG_GACT\nstatic int gact_ld; /* f*ckin backward compatibility */\n#endif\nstatic int tab_flush;\n\nstatic void act_usage(void)\n{\n\t/*XXX: In the near future add a action->print_help to improve\n\t * usability\n\t * This would mean new tc will not be backward compatible\n\t * with any action .so from the old days. But if someone really\n\t * does that, they would know how to fix this ..\n\t *\n\t */\n\tfprintf(stderr,\n\t\t\"usage: tc actions <ACTSPECOP>*\\n\"\n\t\t\"Where: \tACTSPECOP := ACR | GD | FL\\n\"\n\t\t\"\tACR := add | change | replace <ACTSPEC>*\\n\"\n\t\t\"\tGD := get | delete | <ACTISPEC>*\\n\"\n\t\t\"\tFL := ls | list | flush | <ACTNAMESPEC>\\n\"\n\t\t\"\tACTNAMESPEC :=  action <ACTNAME>\\n\"\n\t\t\"\tACTISPEC := <ACTNAMESPEC> <INDEXSPEC>\\n\"\n\t\t\"\tACTSPEC := action <ACTDETAIL> [INDEXSPEC] [HWSTATSSPEC]\\n\"\n\t\t\"\tINDEXSPEC := index <32 bit indexvalue>\\n\"\n\t\t\"\tHWSTATSSPEC := hw_stats [ immediate | delayed | disabled ]\\n\"\n\t\t\"\tACTDETAIL := <ACTNAME> <ACTPARAMS>\\n\"\n\t\t\"\t\tExample ACTNAME is gact, mirred, bpf, etc\\n\"\n\t\t\"\t\tEach action has its own parameters (ACTPARAMS)\\n\"\n\t\t\"\\n\");\n\n\texit(-1);\n}\n\nstatic int print_noaopt(struct action_util *au, FILE *f, struct rtattr *opt)\n{\n\tif (opt && RTA_PAYLOAD(opt))\n\t\tfprintf(f, \"[Unknown action, optlen=%u] \",\n\t\t\t(unsigned int) RTA_PAYLOAD(opt));\n\treturn 0;\n}\n\nstatic int parse_noaopt(struct action_util *au, int *argc_p,\n\t\t\tchar ***argv_p, int code, struct nlmsghdr *n)\n{\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\n\tif (argc)\n\t\tfprintf(stderr,\n\t\t\t\"Unknown action \\\"%s\\\", hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\tau->id, *argv);\n\telse\n\t\tfprintf(stderr, \"Unknown action \\\"%s\\\"\\n\", au->id);\n\n\treturn -1;\n}\n\nstatic struct action_util *get_action_kind(char *str)\n{\n\tstatic void *aBODY;\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct action_util *a;\n#ifdef CONFIG_GACT\n\tint looked4gact = 0;\nrestart_s:\n#endif\n\tfor (a = action_list; a; a = a->next) {\n\t\tif (strcmp(a->id, str) == 0)\n\t\t\treturn a;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s/m_%s.so\", get_tc_lib(), str);\n\tdlh = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n\tif (dlh == NULL) {\n\t\tdlh = aBODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = aBODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_action_util\", str);\n\ta = dlsym(dlh, buf);\n\tif (a == NULL)\n\t\tgoto noexist;\n\nreg:\n\ta->next = action_list;\n\taction_list = a;\n\treturn a;\n\nnoexist:\n#ifdef CONFIG_GACT\n\tif (!looked4gact) {\n\t\tlooked4gact = 1;\n\t\tstrcpy(str, \"gact\");\n\t\tgoto restart_s;\n\t}\n#endif\n\ta = calloc(1, sizeof(*a));\n\tif (a) {\n\t\tstrncpy(a->id, \"noact\", 15);\n\t\ta->parse_aopt = parse_noaopt;\n\t\ta->print_aopt = print_noaopt;\n\t\tgoto reg;\n\t}\n\treturn a;\n}\n\nstatic bool\nnew_cmd(char **argv)\n{\n\treturn (matches(*argv, \"change\") == 0) ||\n\t\t(matches(*argv, \"replace\") == 0) ||\n\t\t(matches(*argv, \"delete\") == 0) ||\n\t\t(matches(*argv, \"get\") == 0) ||\n\t\t(matches(*argv, \"add\") == 0);\n}\n\nstatic const struct hw_stats_item {\n\tconst char *str;\n\t__u8 type;\n} hw_stats_items[] = {\n\t{ \"immediate\", TCA_ACT_HW_STATS_IMMEDIATE },\n\t{ \"delayed\", TCA_ACT_HW_STATS_DELAYED },\n\t{ \"disabled\", 0 }, /* no bit set */\n};\n\nstatic void print_hw_stats(const struct rtattr *arg, bool print_used)\n{\n\tstruct nla_bitfield32 *hw_stats_bf = RTA_DATA(arg);\n\t__u8 hw_stats;\n\tint i;\n\n\thw_stats = hw_stats_bf->value & hw_stats_bf->selector;\n\tprint_string(PRINT_FP, NULL, \"\\t\", NULL);\n\topen_json_array(PRINT_ANY, print_used ? \"used_hw_stats\" : \"hw_stats\");\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_stats_items); i++) {\n\t\tconst struct hw_stats_item *item;\n\n\t\titem = &hw_stats_items[i];\n\t\tif ((!hw_stats && !item->type) || hw_stats & item->type)\n\t\t\tprint_string(PRINT_ANY, NULL, \" %s\", item->str);\n\t}\n\tclose_json_array(PRINT_JSON, NULL);\n\tprint_nl();\n}\n\nstatic int parse_hw_stats(const char *str, struct nlmsghdr *n)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_stats_items); i++) {\n\t\tconst struct hw_stats_item *item;\n\n\t\titem = &hw_stats_items[i];\n\t\tif (matches(str, item->str) == 0) {\n\t\t\tstruct nla_bitfield32 hw_stats_bf = {\n\t\t\t\t.value = item->type,\n\t\t\t\t.selector = item->type\n\t\t\t};\n\n\t\t\taddattr_l(n, MAX_MSG, TCA_ACT_HW_STATS,\n\t\t\t\t  &hw_stats_bf, sizeof(hw_stats_bf));\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn -1;\n}\n\nint parse_action(int *argc_p, char ***argv_p, int tca_id, struct nlmsghdr *n)\n{\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tstruct rtattr *tail, *tail2;\n\tchar k[FILTER_NAMESZ];\n\tint act_ck_len = 0;\n\tint ok = 0;\n\tint eap = 0; /* expect action parameters */\n\n\tint ret = 0;\n\tint prio = 0;\n\tunsigned char act_ck[TC_COOKIE_MAX_SIZE];\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\ttail2 = addattr_nest(n, MAX_MSG, tca_id);\n\n\twhile (argc > 0) {\n\n\t\tmemset(k, 0, sizeof(k));\n\n\t\tif (strcmp(*argv, \"action\") == 0) {\n\t\t\targc--;\n\t\t\targv++;\n\t\t\teap = 1;\n#ifdef CONFIG_GACT\n\t\t\tif (!gact_ld)\n\t\t\t\tget_action_kind(\"gact\");\n#endif\n\t\t\tcontinue;\n\t\t} else if (strcmp(*argv, \"flowid\") == 0) {\n\t\t\tbreak;\n\t\t} else if (strcmp(*argv, \"classid\") == 0) {\n\t\t\tbreak;\n\t\t} else if (strcmp(*argv, \"help\") == 0) {\n\t\t\treturn -1;\n\t\t} else if (new_cmd(argv)) {\n\t\t\tgoto done0;\n\t\t} else {\n\t\t\tstruct action_util *a = NULL;\n\n\t\t\tif (!action_a2n(*argv, NULL, false))\n\t\t\t\tstrncpy(k, \"gact\", sizeof(k) - 1);\n\t\t\telse\n\t\t\t\tstrncpy(k, *argv, sizeof(k) - 1);\n\t\t\teap = 0;\n\t\t\tif (argc > 0) {\n\t\t\t\ta = get_action_kind(k);\n\t\t\t} else {\ndone0:\n\t\t\t\tif (ok)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (a == NULL)\n\t\t\t\tgoto bad_val;\n\n\n\t\t\ttail = addattr_nest(n, MAX_MSG, ++prio);\n\t\t\taddattr_l(n, MAX_MSG, TCA_ACT_KIND, k, strlen(k) + 1);\n\n\t\t\tret = a->parse_aopt(a, &argc, &argv,\n\t\t\t\t\t    TCA_ACT_OPTIONS | NLA_F_NESTED,\n\t\t\t\t\t    n);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr, \"bad action parsing\\n\");\n\t\t\t\tgoto bad_val;\n\t\t\t}\n\n\t\t\tif (*argv && strcmp(*argv, \"cookie\") == 0) {\n\t\t\t\tsize_t slen;\n\n\t\t\t\tNEXT_ARG();\n\t\t\t\tslen = strlen(*argv);\n\t\t\t\tif (slen > TC_COOKIE_MAX_SIZE * 2) {\n\t\t\t\t\tchar cookie_err_m[128];\n\n\t\t\t\t\tsnprintf(cookie_err_m, 128,\n\t\t\t\t\t\t \"%zd Max allowed size %d\",\n\t\t\t\t\t\t slen, TC_COOKIE_MAX_SIZE*2);\n\t\t\t\t\tinvarg(cookie_err_m, *argv);\n\t\t\t\t}\n\n\t\t\t\tif (slen % 2 ||\n\t\t\t\t    hex2mem(*argv, act_ck, slen / 2) < 0)\n\t\t\t\t\tinvarg(\"cookie must be a hex string\\n\",\n\t\t\t\t\t       *argv);\n\n\t\t\t\tact_ck_len = slen / 2;\n\t\t\t\targc--;\n\t\t\t\targv++;\n\t\t\t}\n\n\t\t\tif (act_ck_len)\n\t\t\t\taddattr_l(n, MAX_MSG, TCA_ACT_COOKIE,\n\t\t\t\t\t  &act_ck, act_ck_len);\n\n\t\t\tif (*argv && matches(*argv, \"hw_stats\") == 0) {\n\t\t\t\tNEXT_ARG();\n\t\t\t\tret = parse_hw_stats(*argv, n);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tinvarg(\"value is invalid\\n\", *argv);\n\t\t\t\tNEXT_ARG_FWD();\n\t\t\t}\n\n\t\t\tif (*argv && strcmp(*argv, \"no_percpu\") == 0) {\n\t\t\t\tstruct nla_bitfield32 flags =\n\t\t\t\t\t{ TCA_ACT_FLAGS_NO_PERCPU_STATS,\n\t\t\t\t\t  TCA_ACT_FLAGS_NO_PERCPU_STATS };\n\n\t\t\t\taddattr_l(n, MAX_MSG, TCA_ACT_FLAGS, &flags,\n\t\t\t\t\t  sizeof(struct nla_bitfield32));\n\t\t\t\tNEXT_ARG_FWD();\n\t\t\t}\n\n\t\t\taddattr_nest_end(n, tail);\n\t\t\tok++;\n\t\t}\n\t}\n\n\tif (eap > 0) {\n\t\tfprintf(stderr, \"bad action empty %d\\n\", eap);\n\t\tgoto bad_val;\n\t}\n\n\taddattr_nest_end(n, tail2);\n\ndone:\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn 0;\nbad_val:\n\t/* no need to undo things, returning from here should\n\t * cause enough pain\n\t */\n\tfprintf(stderr, \"parse_action: bad value (%d:%s)!\\n\", argc, *argv);\n\treturn -1;\n}\n\nstatic int tc_print_one_action(FILE *f, struct rtattr *arg)\n{\n\n\tstruct rtattr *tb[TCA_ACT_MAX + 1];\n\tint err = 0;\n\tstruct action_util *a = NULL;\n\n\tif (arg == NULL)\n\t\treturn -1;\n\n\tparse_rtattr_nested(tb, TCA_ACT_MAX, arg);\n\n\tif (tb[TCA_ACT_KIND] == NULL) {\n\t\tfprintf(stderr, \"NULL Action!\\n\");\n\t\treturn -1;\n\t}\n\n\n\ta = get_action_kind(RTA_DATA(tb[TCA_ACT_KIND]));\n\tif (a == NULL)\n\t\treturn err;\n\n\terr = a->print_aopt(a, f, tb[TCA_ACT_OPTIONS]);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (show_stats && tb[TCA_ACT_STATS]) {\n\t\tprint_string(PRINT_FP, NULL, \"\\tAction statistics:\", NULL);\n\t\tprint_nl();\n\t\topen_json_object(\"stats\");\n\t\tprint_tcstats2_attr(f, tb[TCA_ACT_STATS], \"\\t\", NULL);\n\t\tclose_json_object();\n\t\tprint_nl();\n\t}\n\tif (tb[TCA_ACT_COOKIE]) {\n\t\tint strsz = RTA_PAYLOAD(tb[TCA_ACT_COOKIE]);\n\t\tchar b1[strsz * 2 + 1];\n\n\t\tprint_string(PRINT_ANY, \"cookie\", \"\\tcookie %s\",\n\t\t\t     hexstring_n2a(RTA_DATA(tb[TCA_ACT_COOKIE]),\n\t\t\t\t\t   strsz, b1, sizeof(b1)));\n\t\tprint_nl();\n\t}\n\tif (tb[TCA_ACT_FLAGS]) {\n\t\tstruct nla_bitfield32 *flags = RTA_DATA(tb[TCA_ACT_FLAGS]);\n\n\t\tif (flags->selector & TCA_ACT_FLAGS_NO_PERCPU_STATS)\n\t\t\tprint_bool(PRINT_ANY, \"no_percpu\", \"\\tno_percpu\",\n\t\t\t\t   flags->value &\n\t\t\t\t   TCA_ACT_FLAGS_NO_PERCPU_STATS);\n\t\tprint_nl();\n\t}\n\tif (tb[TCA_ACT_HW_STATS])\n\t\tprint_hw_stats(tb[TCA_ACT_HW_STATS], false);\n\n\tif (tb[TCA_ACT_USED_HW_STATS])\n\t\tprint_hw_stats(tb[TCA_ACT_USED_HW_STATS], true);\n\n\treturn 0;\n}\n\nstatic int\ntc_print_action_flush(FILE *f, const struct rtattr *arg)\n{\n\n\tstruct rtattr *tb[TCA_MAX + 1];\n\tint err = 0;\n\tstruct action_util *a = NULL;\n\t__u32 *delete_count = 0;\n\n\tparse_rtattr_nested(tb, TCA_MAX, arg);\n\n\tif (tb[TCA_KIND] == NULL) {\n\t\tfprintf(stderr, \"NULL Action!\\n\");\n\t\treturn -1;\n\t}\n\n\ta = get_action_kind(RTA_DATA(tb[TCA_KIND]));\n\tif (a == NULL)\n\t\treturn err;\n\n\tdelete_count = RTA_DATA(tb[TCA_FCNT]);\n\tfprintf(f, \" %s (%d entries)\\n\", a->id, *delete_count);\n\ttab_flush = 0;\n\treturn 0;\n}\n\nint\ntc_print_action(FILE *f, const struct rtattr *arg, unsigned short tot_acts)\n{\n\n\tint i;\n\n\tif (arg == NULL)\n\t\treturn 0;\n\n\tif (!tot_acts)\n\t\ttot_acts = TCA_ACT_MAX_PRIO;\n\n\tstruct rtattr *tb[tot_acts + 1];\n\n\tparse_rtattr_nested(tb, tot_acts, arg);\n\n\tif (tab_flush && tb[0] && !tb[1])\n\t\treturn tc_print_action_flush(f, tb[0]);\n\n\topen_json_array(PRINT_JSON, \"actions\");\n\tfor (i = 0; i <= tot_acts; i++) {\n\t\tif (tb[i]) {\n\t\t\topen_json_object(NULL);\n\t\t\tprint_nl();\n\t\t\tprint_uint(PRINT_ANY, \"order\",\n\t\t\t\t   \"\\taction order %u: \", i);\n\t\t\tif (tc_print_one_action(f, tb[i]) < 0) {\n\t\t\t\tprint_string(PRINT_FP, NULL,\n\t\t\t\t\t     \"Error printing action\\n\", NULL);\n\t\t\t}\n\t\t\tclose_json_object();\n\t\t}\n\n\t}\n\tclose_json_array(PRINT_JSON, NULL);\n\n\treturn 0;\n}\n\nint print_action(struct nlmsghdr *n, void *arg)\n{\n\tFILE *fp = (FILE *)arg;\n\tstruct tcamsg *t = NLMSG_DATA(n);\n\tint len = n->nlmsg_len;\n\t__u32 *tot_acts = NULL;\n\tstruct rtattr *tb[TCA_ROOT_MAX+1];\n\n\tlen -= NLMSG_LENGTH(sizeof(*t));\n\n\tif (len < 0) {\n\t\tfprintf(stderr, \"Wrong len %d\\n\", len);\n\t\treturn -1;\n\t}\n\n\tparse_rtattr(tb, TCA_ROOT_MAX, TA_RTA(t), len);\n\n\tif (tb[TCA_ROOT_COUNT])\n\t\ttot_acts = RTA_DATA(tb[TCA_ROOT_COUNT]);\n\n\topen_json_object(NULL);\n\tprint_uint(PRINT_ANY, \"total acts\", \"total acts %u\",\n\t\t   tot_acts ? *tot_acts : 0);\n\tprint_nl();\n\tclose_json_object();\n\tif (tb[TCA_ACT_TAB] == NULL) {\n\t\tif (n->nlmsg_type != RTM_GETACTION)\n\t\t\tfprintf(stderr, \"print_action: NULL kind\\n\");\n\t\treturn -1;\n\t}\n\n\tif (n->nlmsg_type == RTM_DELACTION) {\n\t\tif (n->nlmsg_flags & NLM_F_ROOT) {\n\t\t\tfprintf(fp, \"Flushed table \");\n\t\t\ttab_flush = 1;\n\t\t} else {\n\t\t\tfprintf(fp, \"Deleted action \");\n\t\t}\n\t}\n\n\tif (n->nlmsg_type == RTM_NEWACTION) {\n\t\tif ((n->nlmsg_flags & NLM_F_CREATE) &&\n\t\t    !(n->nlmsg_flags & NLM_F_REPLACE)) {\n\t\t\tfprintf(fp, \"Added action \");\n\t\t} else if (n->nlmsg_flags & NLM_F_REPLACE) {\n\t\t\tfprintf(fp, \"Replaced action \");\n\t\t}\n\t}\n\n\topen_json_object(NULL);\n\ttc_print_action(fp, tb[TCA_ACT_TAB], tot_acts ? *tot_acts:0);\n\tclose_json_object();\n\n\treturn 0;\n}\n\nstatic int tc_action_gd(int cmd, unsigned int flags,\n\t\t\tint *argc_p, char ***argv_p)\n{\n\tchar k[FILTER_NAMESZ];\n\tstruct action_util *a = NULL;\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tint prio = 0;\n\tint ret = 0;\n\t__u32 i = 0;\n\tstruct rtattr *tail;\n\tstruct rtattr *tail2;\n\tstruct nlmsghdr *ans = NULL;\n\n\tstruct {\n\t\tstruct nlmsghdr         n;\n\t\tstruct tcamsg           t;\n\t\tchar                    buf[MAX_MSG];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcamsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST | flags,\n\t\t.n.nlmsg_type = cmd,\n\t\t.t.tca_family = AF_UNSPEC,\n\t};\n\n\targc -= 1;\n\targv += 1;\n\n\n\ttail = addattr_nest(&req.n, MAX_MSG, TCA_ACT_TAB);\n\n\twhile (argc > 0) {\n\t\tif (strcmp(*argv, \"action\") == 0) {\n\t\t\targc--;\n\t\t\targv++;\n\t\t\tcontinue;\n\t\t} else if (strcmp(*argv, \"help\") == 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrncpy(k, *argv, sizeof(k) - 1);\n\t\ta = get_action_kind(k);\n\t\tif (a == NULL) {\n\t\t\tfprintf(stderr, \"Error: non existent action: %s\\n\", k);\n\t\t\tret = -1;\n\t\t\tgoto bad_val;\n\t\t}\n\t\tif (strcmp(a->id, k) != 0) {\n\t\t\tfprintf(stderr, \"Error: non existent action: %s\\n\", k);\n\t\t\tret = -1;\n\t\t\tgoto bad_val;\n\t\t}\n\n\t\targc -= 1;\n\t\targv += 1;\n\t\tif (argc <= 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Error: no index specified action: %s\\n\", k);\n\t\t\tret = -1;\n\t\t\tgoto bad_val;\n\t\t}\n\n\t\tif (matches(*argv, \"index\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (get_u32(&i, *argv, 10)) {\n\t\t\t\tfprintf(stderr, \"Illegal \\\"index\\\"\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto bad_val;\n\t\t\t}\n\t\t\targc -= 1;\n\t\t\targv += 1;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Error: no index specified action: %s\\n\", k);\n\t\t\tret = -1;\n\t\t\tgoto bad_val;\n\t\t}\n\n\t\ttail2 = addattr_nest(&req.n, MAX_MSG, ++prio);\n\t\taddattr_l(&req.n, MAX_MSG, TCA_ACT_KIND, k, strlen(k) + 1);\n\t\tif (i > 0)\n\t\t\taddattr32(&req.n, MAX_MSG, TCA_ACT_INDEX, i);\n\t\taddattr_nest_end(&req.n, tail2);\n\n\t}\n\n\taddattr_nest_end(&req.n, tail);\n\n\treq.n.nlmsg_seq = rth.dump = ++rth.seq;\n\n\tif (rtnl_talk(&rth, &req.n, cmd == RTM_DELACTION ? NULL : &ans) < 0) {\n\t\tfprintf(stderr, \"We have an error talking to the kernel\\n\");\n\t\treturn 1;\n\t}\n\n\tif (cmd == RTM_GETACTION) {\n\t\tnew_json_obj(json);\n\t\tret = print_action(ans, stdout);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Dump terminated\\n\");\n\t\t\tfree(ans);\n\t\t\tdelete_json_obj();\n\t\t\treturn 1;\n\t\t}\n\t\tdelete_json_obj();\n\t}\n\tfree(ans);\n\n\t*argc_p = argc;\n\t*argv_p = argv;\nbad_val:\n\treturn ret;\n}\n\nstatic int tc_action_modify(int cmd, unsigned int flags,\n\t\t\t    int *argc_p, char ***argv_p)\n{\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tint ret = 0;\n\tstruct {\n\t\tstruct nlmsghdr         n;\n\t\tstruct tcamsg           t;\n\t\tchar                    buf[MAX_MSG];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcamsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST | flags,\n\t\t.n.nlmsg_type = cmd,\n\t\t.t.tca_family = AF_UNSPEC,\n\t};\n\tstruct rtattr *tail = NLMSG_TAIL(&req.n);\n\n\targc -= 1;\n\targv += 1;\n\tif (parse_action(&argc, &argv, TCA_ACT_TAB, &req.n)) {\n\t\tfprintf(stderr, \"Illegal \\\"action\\\"\\n\");\n\t\treturn -1;\n\t}\n\ttail->rta_len = (void *) NLMSG_TAIL(&req.n) - (void *) tail;\n\n\tif (rtnl_talk(&rth, &req.n, NULL) < 0) {\n\t\tfprintf(stderr, \"We have an error talking to the kernel\\n\");\n\t\tret = -1;\n\t}\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n\n\treturn ret;\n}\n\nstatic int tc_act_list_or_flush(int *argc_p, char ***argv_p, int event)\n{\n\tstruct rtattr *tail, *tail2, *tail3, *tail4;\n\tint ret = 0, prio = 0, msg_size = 0;\n\tstruct action_util *a = NULL;\n\tstruct nla_bitfield32 flag_select = { 0 };\n\tchar **argv = *argv_p;\n\t__u32 msec_since = 0;\n\tint argc = *argc_p;\n\tchar k[FILTER_NAMESZ];\n\tstruct {\n\t\tstruct nlmsghdr         n;\n\t\tstruct tcamsg           t;\n\t\tchar                    buf[MAX_MSG];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct tcamsg)),\n\t\t.t.tca_family = AF_UNSPEC,\n\t};\n\n\ttail = addattr_nest(&req.n, MAX_MSG, TCA_ACT_TAB);\n\ttail2 = NLMSG_TAIL(&req.n);\n\n\tstrncpy(k, *argv, sizeof(k) - 1);\n#ifdef CONFIG_GACT\n\tif (!gact_ld)\n\t\tget_action_kind(\"gact\");\n\n#endif\n\ta = get_action_kind(k);\n\tif (a == NULL) {\n\t\tfprintf(stderr, \"bad action %s\\n\", k);\n\t\tgoto bad_val;\n\t}\n\tif (strcmp(a->id, k) != 0) {\n\t\tfprintf(stderr, \"bad action %s\\n\", k);\n\t\tgoto bad_val;\n\t}\n\tstrncpy(k, *argv, sizeof(k) - 1);\n\n\targc -= 1;\n\targv += 1;\n\n\tif (argc && (strcmp(*argv, \"since\") == 0)) {\n\t\tNEXT_ARG();\n\t\tif (get_u32(&msec_since, *argv, 0))\n\t\t\tinvarg(\"dump time \\\"since\\\" is invalid\", *argv);\n\t}\n\n\taddattr_l(&req.n, MAX_MSG, ++prio, NULL, 0);\n\taddattr_l(&req.n, MAX_MSG, TCA_ACT_KIND, k, strlen(k) + 1);\n\ttail2->rta_len = (void *) NLMSG_TAIL(&req.n) - (void *) tail2;\n\taddattr_nest_end(&req.n, tail);\n\n\ttail3 = NLMSG_TAIL(&req.n);\n\tflag_select.value |= TCA_FLAG_LARGE_DUMP_ON;\n\tflag_select.selector |= TCA_FLAG_LARGE_DUMP_ON;\n\taddattr_l(&req.n, MAX_MSG, TCA_ROOT_FLAGS, &flag_select,\n\t\t  sizeof(struct nla_bitfield32));\n\ttail3->rta_len = (void *) NLMSG_TAIL(&req.n) - (void *) tail3;\n\tif (msec_since) {\n\t\ttail4 = NLMSG_TAIL(&req.n);\n\t\taddattr32(&req.n, MAX_MSG, TCA_ROOT_TIME_DELTA, msec_since);\n\t\ttail4->rta_len = (void *) NLMSG_TAIL(&req.n) - (void *) tail4;\n\t}\n\tmsg_size = NLMSG_ALIGN(req.n.nlmsg_len)\n\t\t- NLMSG_ALIGN(sizeof(struct nlmsghdr));\n\n\tif (event == RTM_GETACTION) {\n\t\tif (rtnl_dump_request(&rth, event,\n\t\t\t\t      (void *)&req.t, msg_size) < 0) {\n\t\t\tperror(\"Cannot send dump request\");\n\t\t\treturn 1;\n\t\t}\n\t\tnew_json_obj(json);\n\t\tret = rtnl_dump_filter(&rth, print_action, stdout);\n\t\tdelete_json_obj();\n\t}\n\n\tif (event == RTM_DELACTION) {\n\t\treq.n.nlmsg_len = NLMSG_ALIGN(req.n.nlmsg_len);\n\t\treq.n.nlmsg_type = RTM_DELACTION;\n\t\treq.n.nlmsg_flags |= NLM_F_ROOT;\n\t\treq.n.nlmsg_flags |= NLM_F_REQUEST;\n\t\tif (rtnl_talk(&rth, &req.n, NULL) < 0) {\n\t\t\tfprintf(stderr, \"We have an error flushing\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\nbad_val:\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn ret;\n}\n\nint do_action(int argc, char **argv)\n{\n\n\tint ret = 0;\n\n\twhile (argc > 0) {\n\n\t\tif (matches(*argv, \"add\") == 0) {\n\t\t\tret =  tc_action_modify(RTM_NEWACTION,\n\t\t\t\t\t\tNLM_F_EXCL | NLM_F_CREATE,\n\t\t\t\t\t\t&argc, &argv);\n\t\t} else if (matches(*argv, \"change\") == 0 ||\n\t\t\t  matches(*argv, \"replace\") == 0) {\n\t\t\tret = tc_action_modify(RTM_NEWACTION,\n\t\t\t\t\t       NLM_F_CREATE | NLM_F_REPLACE,\n\t\t\t\t\t       &argc, &argv);\n\t\t} else if (matches(*argv, \"delete\") == 0) {\n\t\t\targc -= 1;\n\t\t\targv += 1;\n\t\t\tret = tc_action_gd(RTM_DELACTION, 0,  &argc, &argv);\n\t\t} else if (matches(*argv, \"get\") == 0) {\n\t\t\targc -= 1;\n\t\t\targv += 1;\n\t\t\tret = tc_action_gd(RTM_GETACTION, 0,  &argc, &argv);\n\t\t} else if (matches(*argv, \"list\") == 0 ||\n\t\t\t   matches(*argv, \"show\") == 0 ||\n\t\t\t   matches(*argv, \"lst\") == 0) {\n\t\t\tif (argc <= 2) {\n\t\t\t\tact_usage();\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\targc -= 2;\n\t\t\targv += 2;\n\t\t\treturn tc_act_list_or_flush(&argc, &argv,\n\t\t\t\t\t\t    RTM_GETACTION);\n\t\t} else if (matches(*argv, \"flush\") == 0) {\n\t\t\tif (argc <= 2) {\n\t\t\t\tact_usage();\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\targc -= 2;\n\t\t\targv += 2;\n\t\t\treturn tc_act_list_or_flush(&argc, &argv,\n\t\t\t\t\t\t    RTM_DELACTION);\n\t\t} else if (matches(*argv, \"help\") == 0) {\n\t\t\tact_usage();\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Command \\\"%s\\\" is unknown, try \\\"tc actions help\\\".\\n\",\n\t\t\t\t*argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/m_ematch.c": "/*\n * m_ematch.c\t\tExtended Matches\n *\n *\t\tThis program is free software; you can distribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tThomas Graf <tgraf@suug.ch>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#include \"utils.h\"\n#include \"tc_util.h\"\n#include \"m_ematch.h\"\n\n#define EMATCH_MAP \"/etc/iproute2/ematch_map\"\n\nstatic struct ematch_util *ematch_list;\n\n/* export to bison parser */\nint ematch_argc;\nchar **ematch_argv;\nchar *ematch_err;\nstruct ematch *ematch_root;\n\nstatic int begin_argc;\nstatic char **begin_argv;\n\nstatic void bstr_print(FILE *fd, const struct bstr *b, int ascii);\n\nstatic inline void map_warning(int num, char *kind)\n{\n\tfprintf(stderr,\n\t    \"Error: Unable to find ematch \\\"%s\\\" in %s\\n\" \\\n\t    \"Please assign a unique ID to the ematch kind the suggested \" \\\n\t    \"entry is:\\n\" \\\n\t    \"\\t%d\\t%s\\n\",\n\t    kind, EMATCH_MAP, num, kind);\n}\n\nstatic int lookup_map(__u16 num, char *dst, int len, const char *file)\n{\n\tint err = -EINVAL;\n\tchar buf[512];\n\tFILE *fd = fopen(file, \"r\");\n\n\tif (fd == NULL)\n\t\treturn -errno;\n\n\twhile (fgets(buf, sizeof(buf), fd)) {\n\t\tchar namebuf[512], *p = buf;\n\t\tint id;\n\n\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\tp++;\n\t\tif (*p == '#' || *p == '\\n' || *p == 0)\n\t\t\tcontinue;\n\n\t\tif (sscanf(p, \"%d %s\", &id, namebuf) != 2) {\n\t\t\tfprintf(stderr, \"ematch map %s corrupted at %s\\n\",\n\t\t\t    file, p);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (id == num) {\n\t\t\tif (dst)\n\t\t\t\tstrncpy(dst, namebuf, len - 1);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = -ENOENT;\nout:\n\tfclose(fd);\n\treturn err;\n}\n\nstatic int lookup_map_id(char *kind, int *dst, const char *file)\n{\n\tint err = -EINVAL;\n\tchar buf[512];\n\tFILE *fd = fopen(file, \"r\");\n\n\tif (fd == NULL)\n\t\treturn -errno;\n\n\twhile (fgets(buf, sizeof(buf), fd)) {\n\t\tchar namebuf[512], *p = buf;\n\t\tint id;\n\n\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\tp++;\n\t\tif (*p == '#' || *p == '\\n' || *p == 0)\n\t\t\tcontinue;\n\n\t\tif (sscanf(p, \"%d %s\", &id, namebuf) != 2) {\n\t\t\tfprintf(stderr, \"ematch map %s corrupted at %s\\n\",\n\t\t\t    file, p);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!strcasecmp(namebuf, kind)) {\n\t\t\tif (dst)\n\t\t\t\t*dst = id;\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = -ENOENT;\n\t*dst = 0;\nout:\n\tfclose(fd);\n\treturn err;\n}\n\nstatic struct ematch_util *get_ematch_kind(char *kind)\n{\n\tstatic void *body;\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct ematch_util *e;\n\n\tfor (e = ematch_list; e; e = e->next) {\n\t\tif (strcmp(e->kind, kind) == 0)\n\t\t\treturn e;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"em_%s.so\", kind);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\tdlh = body;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = body = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_ematch_util\", kind);\n\te = dlsym(dlh, buf);\n\tif (e == NULL)\n\t\treturn NULL;\n\n\te->next = ematch_list;\n\tematch_list = e;\n\n\treturn e;\n}\n\nstatic struct ematch_util *get_ematch_kind_num(__u16 kind)\n{\n\tchar name[513];\n\n\tif (lookup_map(kind, name, sizeof(name), EMATCH_MAP) < 0)\n\t\treturn NULL;\n\n\treturn get_ematch_kind(name);\n}\n\nstatic int em_parse_call(struct nlmsghdr *n, struct tcf_ematch_hdr *hdr,\n\t\t\t struct ematch_util *e, struct ematch *t)\n{\n\tif (e->parse_eopt_argv) {\n\t\tint argc = 0, i = 0, ret;\n\t\tstruct bstr *args;\n\t\tchar **argv;\n\n\t\tfor (args = t->args; args; args = bstr_next(args))\n\t\t\targc++;\n\t\targv = calloc(argc, sizeof(char *));\n\t\tif (!argv)\n\t\t\treturn -1;\n\t\tfor (args = t->args; args; args = bstr_next(args))\n\t\t\targv[i++] = args->data;\n\n\t\tret = e->parse_eopt_argv(n, hdr, argc, argv);\n\n\t\tfree(argv);\n\t\treturn ret;\n\t}\n\n\treturn e->parse_eopt(n, hdr, t->args->next);\n}\n\nstatic int parse_tree(struct nlmsghdr *n, struct ematch *tree)\n{\n\tint index = 1;\n\tstruct ematch *t;\n\n\tfor (t = tree; t; t = t->next) {\n\t\tstruct rtattr *tail;\n\t\tstruct tcf_ematch_hdr hdr = { .flags = t->relation };\n\n\t\tif (t->inverted)\n\t\t\thdr.flags |= TCF_EM_INVERT;\n\n\t\ttail = addattr_nest(n, MAX_MSG, index++);\n\n\t\tif (t->child) {\n\t\t\t__u32 r = t->child_ref;\n\n\t\t\taddraw_l(n, MAX_MSG, &hdr, sizeof(hdr));\n\t\t\taddraw_l(n, MAX_MSG, &r, sizeof(r));\n\t\t} else {\n\t\t\tint num = 0, err;\n\t\t\tchar buf[64];\n\t\t\tstruct ematch_util *e;\n\n\t\t\tif (t->args == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tstrncpy(buf, (char *) t->args->data, sizeof(buf)-1);\n\t\t\te = get_ematch_kind(buf);\n\t\t\tif (e == NULL) {\n\t\t\t\tfprintf(stderr, \"Unknown ematch \\\"%s\\\"\\n\",\n\t\t\t\t    buf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\terr = lookup_map_id(buf, &num, EMATCH_MAP);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tmap_warning(e->kind_num, buf);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\thdr.kind = num;\n\t\t\tif (em_parse_call(n, &hdr, e, t) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\taddattr_nest_end(n, tail);\n\t}\n\n\treturn 0;\n}\n\nstatic int flatten_tree(struct ematch *head, struct ematch *tree)\n{\n\tint i, count = 0;\n\tstruct ematch *t;\n\n\tfor (;;) {\n\t\tcount++;\n\n\t\tif (tree->child) {\n\t\t\tfor (t = head; t->next; t = t->next);\n\t\t\tt->next = tree->child;\n\t\t\tcount += flatten_tree(head, tree->child);\n\t\t}\n\n\t\tif (tree->relation == 0)\n\t\t\tbreak;\n\n\t\ttree = tree->next;\n\t}\n\n\tfor (i = 0, t = head; t; t = t->next, i++)\n\t\tt->index = i;\n\n\tfor (t = head; t; t = t->next)\n\t\tif (t->child)\n\t\t\tt->child_ref = t->child->index;\n\n\treturn count;\n}\n\n__attribute__((format(printf, 5, 6)))\nint em_parse_error(int err, struct bstr *args, struct bstr *carg,\n\t\t   struct ematch_util *e, char *fmt, ...)\n{\n\tva_list a;\n\n\tva_start(a, fmt);\n\tvfprintf(stderr, fmt, a);\n\tva_end(a);\n\n\tif (ematch_err)\n\t\tfprintf(stderr, \": %s\\n... \", ematch_err);\n\telse\n\t\tfprintf(stderr, \"\\n... \");\n\n\twhile (ematch_argc < begin_argc) {\n\t\tif (ematch_argc == (begin_argc - 1))\n\t\t\tfprintf(stderr, \">>%s<< \", *begin_argv);\n\t\telse\n\t\t\tfprintf(stderr, \"%s \", *begin_argv);\n\t\tbegin_argv++;\n\t\tbegin_argc--;\n\t}\n\n\tfprintf(stderr, \"...\\n\");\n\n\tif (args) {\n\t\tfprintf(stderr, \"... %s(\", e->kind);\n\t\twhile (args) {\n\t\t\tfprintf(stderr, \"%s\", args == carg ? \">>\" : \"\");\n\t\t\tbstr_print(stderr, args, 1);\n\t\t\tfprintf(stderr, \"%s%s\", args == carg ? \"<<\" : \"\",\n\t\t\t    args->next ? \" \" : \"\");\n\t\t\targs = args->next;\n\t\t}\n\t\tfprintf(stderr, \")...\\n\");\n\n\t}\n\n\tif (e == NULL) {\n\t\tfprintf(stderr,\n\t\t    \"Usage: EXPR\\n\" \\\n\t\t    \"where: EXPR  := TERM [ { and | or } EXPR ]\\n\" \\\n\t\t    \"       TERM  := [ not ] { MATCH | '(' EXPR ')' }\\n\" \\\n\t\t    \"       MATCH := module '(' ARGS ')'\\n\" \\\n\t\t    \"       ARGS := ARG1 ARG2 ...\\n\" \\\n\t\t    \"\\n\" \\\n\t\t    \"Example: a(x y) and not (b(x) or c(x y z))\\n\");\n\t} else\n\t\te->print_usage(stderr);\n\n\treturn -err;\n}\n\nstatic inline void free_ematch_err(void)\n{\n\tif (ematch_err) {\n\t\tfree(ematch_err);\n\t\tematch_err = NULL;\n\t}\n}\n\nextern int ematch_parse(void);\n\nint parse_ematch(int *argc_p, char ***argv_p, int tca_id, struct nlmsghdr *n)\n{\n\tbegin_argc = ematch_argc = *argc_p;\n\tbegin_argv = ematch_argv = *argv_p;\n\n\tif (ematch_parse()) {\n\t\tint err = em_parse_error(EINVAL, NULL, NULL, NULL,\n\t\t    \"Parse error\");\n\t\tfree_ematch_err();\n\t\treturn err;\n\t}\n\n\tfree_ematch_err();\n\n\t/* undo look ahead by parser */\n\tematch_argc++;\n\tematch_argv--;\n\n\tif (ematch_root) {\n\t\tstruct rtattr *tail, *tail_list;\n\n\t\tstruct tcf_ematch_tree_hdr hdr = {\n\t\t\t.nmatches = flatten_tree(ematch_root, ematch_root),\n\t\t\t.progid = TCF_EM_PROG_TC\n\t\t};\n\n\t\ttail = addattr_nest(n, MAX_MSG, tca_id);\n\t\taddattr_l(n, MAX_MSG, TCA_EMATCH_TREE_HDR, &hdr, sizeof(hdr));\n\n\t\ttail_list = addattr_nest(n, MAX_MSG, TCA_EMATCH_TREE_LIST);\n\n\t\tif (parse_tree(n, ematch_root) < 0)\n\t\t\treturn -1;\n\n\t\taddattr_nest_end(n, tail_list);\n\t\taddattr_nest_end(n, tail);\n\t}\n\n\t*argc_p = ematch_argc;\n\t*argv_p = ematch_argv;\n\n\treturn 0;\n}\n\nstatic int print_ematch_seq(FILE *fd, struct rtattr **tb, int start,\n\t\t\t    int prefix)\n{\n\tint n, i = start;\n\tstruct tcf_ematch_hdr *hdr;\n\tint dlen;\n\tvoid *data;\n\n\tfor (;;) {\n\t\tif (tb[i] == NULL)\n\t\t\treturn -1;\n\n\t\tdlen = RTA_PAYLOAD(tb[i]) - sizeof(*hdr);\n\t\tdata = (void *) RTA_DATA(tb[i]) + sizeof(*hdr);\n\n\t\tif (dlen < 0)\n\t\t\treturn -1;\n\n\t\thdr = RTA_DATA(tb[i]);\n\n\t\tif (hdr->flags & TCF_EM_INVERT)\n\t\t\tfprintf(fd, \"NOT \");\n\n\t\tif (hdr->kind == 0) {\n\t\t\t__u32 ref;\n\n\t\t\tif (dlen < sizeof(__u32))\n\t\t\t\treturn -1;\n\n\t\t\tref = *(__u32 *) data;\n\t\t\tfprintf(fd, \"(\\n\");\n\t\t\tfor (n = 0; n <= prefix; n++)\n\t\t\t\tfprintf(fd, \"  \");\n\t\t\tif (print_ematch_seq(fd, tb, ref + 1, prefix + 1) < 0)\n\t\t\t\treturn -1;\n\t\t\tfor (n = 0; n < prefix; n++)\n\t\t\t\tfprintf(fd, \"  \");\n\t\t\tfprintf(fd, \") \");\n\n\t\t} else {\n\t\t\tstruct ematch_util *e;\n\n\t\t\te = get_ematch_kind_num(hdr->kind);\n\t\t\tif (e == NULL)\n\t\t\t\tfprintf(fd, \"[unknown ematch %d]\\n\",\n\t\t\t\t    hdr->kind);\n\t\t\telse {\n\t\t\t\tfprintf(fd, \"%s(\", e->kind);\n\t\t\t\tif (e->print_eopt(fd, hdr, data, dlen) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tfprintf(fd, \")\\n\");\n\t\t\t}\n\t\t\tif (hdr->flags & TCF_EM_REL_MASK)\n\t\t\t\tfor (n = 0; n < prefix; n++)\n\t\t\t\t\tfprintf(fd, \"  \");\n\t\t}\n\n\t\tswitch (hdr->flags & TCF_EM_REL_MASK) {\n\t\t\tcase TCF_EM_REL_AND:\n\t\t\t\tfprintf(fd, \"AND \");\n\t\t\t\tbreak;\n\n\t\t\tcase TCF_EM_REL_OR:\n\t\t\t\tfprintf(fd, \"OR \");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int print_ematch_list(FILE *fd, struct tcf_ematch_tree_hdr *hdr,\n\t\t\t     struct rtattr *rta)\n{\n\tint err = -1;\n\tstruct rtattr **tb;\n\n\ttb = malloc((hdr->nmatches + 1) * sizeof(struct rtattr *));\n\tif (tb == NULL)\n\t\treturn -1;\n\n\tif (hdr->nmatches > 0) {\n\t\tif (parse_rtattr_nested(tb, hdr->nmatches, rta) < 0)\n\t\t\tgoto errout;\n\n\t\tfprintf(fd, \"\\n  \");\n\t\tif (print_ematch_seq(fd, tb, 1, 1) < 0)\n\t\t\tgoto errout;\n\t}\n\n\terr = 0;\nerrout:\n\tfree(tb);\n\treturn err;\n}\n\nint print_ematch(FILE *fd, const struct rtattr *rta)\n{\n\tstruct rtattr *tb[TCA_EMATCH_TREE_MAX+1];\n\tstruct tcf_ematch_tree_hdr *hdr;\n\n\tif (parse_rtattr_nested(tb, TCA_EMATCH_TREE_MAX, rta) < 0)\n\t\treturn -1;\n\n\tif (tb[TCA_EMATCH_TREE_HDR] == NULL) {\n\t\tfprintf(stderr, \"Missing ematch tree header\\n\");\n\t\treturn -1;\n\t}\n\n\tif (tb[TCA_EMATCH_TREE_LIST] == NULL) {\n\t\tfprintf(stderr, \"Missing ematch tree list\\n\");\n\t\treturn -1;\n\t}\n\n\tif (RTA_PAYLOAD(tb[TCA_EMATCH_TREE_HDR]) < sizeof(*hdr)) {\n\t\tfprintf(stderr, \"Ematch tree header size mismatch\\n\");\n\t\treturn -1;\n\t}\n\n\thdr = RTA_DATA(tb[TCA_EMATCH_TREE_HDR]);\n\n\treturn print_ematch_list(fd, hdr, tb[TCA_EMATCH_TREE_LIST]);\n}\n\nstruct bstr *bstr_alloc(const char *text)\n{\n\tstruct bstr *b = calloc(1, sizeof(*b));\n\n\tif (b == NULL)\n\t\treturn NULL;\n\n\tb->data = strdup(text);\n\tif (b->data == NULL) {\n\t\tfree(b);\n\t\treturn NULL;\n\t}\n\n\tb->len = strlen(text);\n\n\treturn b;\n}\n\nunsigned long bstrtoul(const struct bstr *b)\n{\n\tchar *inv = NULL;\n\tunsigned long l;\n\tchar buf[b->len+1];\n\n\tmemcpy(buf, b->data, b->len);\n\tbuf[b->len] = '\\0';\n\n\tl = strtoul(buf, &inv, 0);\n\tif (l == ULONG_MAX || inv == buf)\n\t\treturn ULONG_MAX;\n\n\treturn l;\n}\n\nstatic void bstr_print(FILE *fd, const struct bstr *b, int ascii)\n{\n\tint i;\n\tchar *s = b->data;\n\n\tif (ascii)\n\t\tfor (i = 0; i < b->len; i++)\n\t\t    fprintf(fd, \"%c\", isprint(s[i]) ? s[i] : '.');\n\telse {\n\t\tfor (i = 0; i < b->len; i++)\n\t\t    fprintf(fd, \"%02x\", s[i]);\n\t\tfprintf(fd, \"\\\"\");\n\t\tfor (i = 0; i < b->len; i++)\n\t\t    fprintf(fd, \"%c\", isprint(s[i]) ? s[i] : '.');\n\t\tfprintf(fd, \"\\\"\");\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/tc_exec.c": "/*\n * tc_exec.c\t\"tc exec\".\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:\tDaniel Borkmann <daniel@iogearbox.net>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n#include \"utils.h\"\n\n#include \"tc_util.h\"\n#include \"tc_common.h\"\n\nstatic struct exec_util *exec_list;\nstatic void *BODY;\n\nstatic void usage(void)\n{\n\tfprintf(stderr,\n\t\t\"Usage: tc exec [ EXEC_TYPE ] [ help | OPTIONS ]\\n\"\n\t\t\"Where:\\n\"\n\t\t\"EXEC_TYPE := { bpf | etc. }\\n\"\n\t\t\"OPTIONS := ... try tc exec <desired EXEC_KIND> help\\n\");\n}\n\nstatic int parse_noeopt(struct exec_util *eu, int argc, char **argv)\n{\n\tif (argc) {\n\t\tfprintf(stderr, \"Unknown exec \\\"%s\\\", hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\teu->id, *argv);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct exec_util *get_exec_kind(const char *name)\n{\n\tstruct exec_util *eu;\n\tchar buf[256];\n\tvoid *dlh;\n\n\tfor (eu = exec_list; eu; eu = eu->next)\n\t\tif (strcmp(eu->id, name) == 0)\n\t\t\treturn eu;\n\n\tsnprintf(buf, sizeof(buf), \"%s/e_%s.so\", get_tc_lib(), name);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\tdlh = BODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = BODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%s_exec_util\", name);\n\teu = dlsym(dlh, buf);\n\tif (eu == NULL)\n\t\tgoto noexist;\nreg:\n\teu->next = exec_list;\n\texec_list = eu;\n\n\treturn eu;\nnoexist:\n\teu = calloc(1, sizeof(*eu));\n\tif (eu) {\n\t\tstrncpy(eu->id, name, sizeof(eu->id) - 1);\n\t\teu->parse_eopt = parse_noeopt;\n\t\tgoto reg;\n\t}\n\n\treturn eu;\n}\n\nint do_exec(int argc, char **argv)\n{\n\tstruct exec_util *eu;\n\tchar kind[FILTER_NAMESZ] = {};\n\n\tif (argc < 1) {\n\t\tfprintf(stderr, \"No command given, try \\\"tc exec help\\\".\\n\");\n\t\treturn -1;\n\t}\n\n\tif (matches(*argv, \"help\") == 0) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\tstrncpy(kind, *argv, sizeof(kind) - 1);\n\n\teu = get_exec_kind(kind);\n\n\targc--;\n\targv++;\n\n\treturn eu->parse_eopt(eu, argc, argv);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/tc/m_pedit.c": "/*\n * m_pedit.c\t\tgeneric packet editor actions module\n *\n *\t\tThis program is free software; you can distribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Authors:  J Hadi Salim (hadi@cyberus.ca)\n *\n * TODO:\n *\t1) Big endian broken in some spots\n *\t2) A lot of this stuff was added on the fly; get a big double-double\n *\tand clean it up at some point.\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"utils.h\"\n#include \"tc_util.h\"\n#include \"m_pedit.h\"\n#include \"rt_names.h\"\n\nstatic struct m_pedit_util *pedit_list;\nstatic int pedit_debug;\n\nstatic void explain(void)\n{\n\tfprintf(stderr,\n\t\t\"Usage: ... pedit munge [ex] <MUNGE> [CONTROL]\\n\"\n\t\t\"Where: MUNGE := <RAW>|<LAYERED>\\n\"\n\t\t\"\\t<RAW>:= <OFFSETC>[ATC]<CMD>\\n \\t\\tOFFSETC:= offset <offval> <u8|u16|u32>\\n\"\n\t\t\"\\t\\tATC:= at <atval> offmask <maskval> shift <shiftval>\\n\"\n\t\t\"\\t\\tNOTE: offval is byte offset, must be multiple of 4\\n\"\n\t\t\"\\t\\tNOTE: maskval is a 32 bit hex number\\n \\t\\tNOTE: shiftval is a shift value\\n\"\n\t\t\"\\t\\tCMD:= clear | invert | set <setval>| add <addval> | retain\\n\"\n\t\t\"\\t<LAYERED>:= ip <ipdata> | ip6 <ip6data>\\n\"\n\t\t\" \\t\\t| udp <udpdata> | tcp <tcpdata> | icmp <icmpdata>\\n\"\n\t\t\"\\tCONTROL:= reclassify | pipe | drop | continue | pass |\\n\"\n\t\t\"\\t          goto chain <CHAIN_INDEX>\\n\"\n\t\t\"\\tNOTE: if 'ex' is set, extended functionality will be supported (kernel >= 4.11)\\n\"\n\t\t\"For Example usage look at the examples directory\\n\");\n\n}\n\nstatic void usage(void)\n{\n\texplain();\n\texit(-1);\n}\n\nstatic int pedit_parse_nopopt(int *argc_p, char ***argv_p,\n\t\t\t      struct m_pedit_sel *sel,\n\t\t\t      struct m_pedit_key *tkey)\n{\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\n\tif (argc) {\n\t\tfprintf(stderr,\n\t\t\t\"Unknown action  hence option \\\"%s\\\" is unparsable\\n\",\n\t\t\t*argv);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\n}\n\nstatic struct m_pedit_util *get_pedit_kind(const char *str)\n{\n\tstatic void *pBODY;\n\tvoid *dlh;\n\tchar buf[256];\n\tstruct m_pedit_util *p;\n\n\tfor (p = pedit_list; p; p = p->next) {\n\t\tif (strcmp(p->id, str) == 0)\n\t\t\treturn p;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"p_%s.so\", str);\n\tdlh = dlopen(buf, RTLD_LAZY);\n\tif (dlh == NULL) {\n\t\tdlh = pBODY;\n\t\tif (dlh == NULL) {\n\t\t\tdlh = pBODY = dlopen(NULL, RTLD_LAZY);\n\t\t\tif (dlh == NULL)\n\t\t\t\tgoto noexist;\n\t\t}\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"p_pedit_%s\", str);\n\tp = dlsym(dlh, buf);\n\tif (p == NULL)\n\t\tgoto noexist;\n\nreg:\n\tp->next = pedit_list;\n\tpedit_list = p;\n\treturn p;\n\nnoexist:\n\tp = calloc(1, sizeof(*p));\n\tif (p) {\n\t\tstrlcpy(p->id, str, sizeof(p->id));\n\t\tp->parse_peopt = pedit_parse_nopopt;\n\t\tgoto reg;\n\t}\n\treturn p;\n}\n\nstatic int pack_key(struct m_pedit_sel *_sel, struct m_pedit_key *tkey)\n{\n\tstruct tc_pedit_sel *sel = &_sel->sel;\n\tstruct m_pedit_key_ex *keys_ex = _sel->keys_ex;\n\tint hwm = sel->nkeys;\n\n\tif (hwm >= MAX_OFFS)\n\t\treturn -1;\n\n\tif (tkey->off % 4) {\n\t\tfprintf(stderr, \"offsets MUST be in 32 bit boundaries\\n\");\n\t\treturn -1;\n\t}\n\n\tsel->keys[hwm].val = tkey->val;\n\tsel->keys[hwm].mask = tkey->mask;\n\tsel->keys[hwm].off = tkey->off;\n\tsel->keys[hwm].at = tkey->at;\n\tsel->keys[hwm].offmask = tkey->offmask;\n\tsel->keys[hwm].shift = tkey->shift;\n\n\tif (_sel->extended) {\n\t\tkeys_ex[hwm].htype = tkey->htype;\n\t\tkeys_ex[hwm].cmd = tkey->cmd;\n\t} else {\n\t\tif (tkey->htype != TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK ||\n\t\t    tkey->cmd != TCA_PEDIT_KEY_EX_CMD_SET) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Munge parameters not supported. Use 'pedit ex munge ...'.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsel->nkeys++;\n\treturn 0;\n}\n\nstatic int pack_key32(__u32 retain, struct m_pedit_sel *sel,\n\t\t      struct m_pedit_key *tkey)\n{\n\tif (tkey->off > (tkey->off & ~3)) {\n\t\tfprintf(stderr,\n\t\t\t\"pack_key32: 32 bit offsets must begin in 32bit boundaries\\n\");\n\t\treturn -1;\n\t}\n\n\ttkey->val = htonl(tkey->val & retain);\n\ttkey->mask = htonl(tkey->mask | ~retain);\n\treturn pack_key(sel, tkey);\n}\n\nstatic int pack_key16(__u32 retain, struct m_pedit_sel *sel,\n\t\t      struct m_pedit_key *tkey)\n{\n\tint ind, stride;\n\t__u32 m[4] = { 0x0000FFFF, 0xFF0000FF, 0xFFFF0000 };\n\n\tif (tkey->val > 0xFFFF || tkey->mask > 0xFFFF) {\n\t\tfprintf(stderr, \"pack_key16 bad value\\n\");\n\t\treturn -1;\n\t}\n\n\tind = tkey->off & 3;\n\n\tif (ind == 3) {\n\t\tfprintf(stderr, \"pack_key16 bad index value %d\\n\", ind);\n\t\treturn -1;\n\t}\n\n\tstride = 8 * (2 - ind);\n\ttkey->val = htonl((tkey->val & retain) << stride);\n\ttkey->mask = htonl(((tkey->mask | ~retain) << stride) | m[ind]);\n\n\ttkey->off &= ~3;\n\n\tif (pedit_debug)\n\t\tprintf(\"pack_key16: Final val %08x mask %08x\\n\",\n\t\t       tkey->val, tkey->mask);\n\treturn pack_key(sel, tkey);\n}\n\nstatic int pack_key8(__u32 retain, struct m_pedit_sel *sel,\n\t\t     struct m_pedit_key *tkey)\n{\n\tint ind, stride;\n\t__u32 m[4] = { 0x00FFFFFF, 0xFF00FFFF, 0xFFFF00FF, 0xFFFFFF00 };\n\n\tif (tkey->val > 0xFF || tkey->mask > 0xFF) {\n\t\tfprintf(stderr, \"pack_key8 bad value (val %x mask %x\\n\",\n\t\t\ttkey->val, tkey->mask);\n\t\treturn -1;\n\t}\n\n\tind = tkey->off & 3;\n\n\tstride = 8 * (3 - ind);\n\ttkey->val = htonl((tkey->val & retain) << stride);\n\ttkey->mask = htonl(((tkey->mask | ~retain) << stride) | m[ind]);\n\n\ttkey->off &= ~3;\n\n\tif (pedit_debug)\n\t\tprintf(\"pack_key8: Final word off %d  val %08x mask %08x\\n\",\n\t\t       tkey->off, tkey->val, tkey->mask);\n\treturn pack_key(sel, tkey);\n}\n\nstatic int pack_mac(struct m_pedit_sel *sel, struct m_pedit_key *tkey,\n\t\t    __u8 *mac)\n{\n\tint ret = 0;\n\n\tif (!(tkey->off & 0x3)) {\n\t\ttkey->mask = 0;\n\t\ttkey->val = ntohl(*((__u32 *)mac));\n\t\tret |= pack_key32(~0, sel, tkey);\n\n\t\ttkey->off += 4;\n\t\ttkey->mask = 0;\n\t\ttkey->val = ntohs(*((__u16 *)&mac[4]));\n\t\tret |= pack_key16(~0, sel, tkey);\n\t} else if (!(tkey->off & 0x1)) {\n\t\ttkey->mask = 0;\n\t\ttkey->val = ntohs(*((__u16 *)mac));\n\t\tret |= pack_key16(~0, sel, tkey);\n\n\t\ttkey->off += 4;\n\t\ttkey->mask = 0;\n\t\ttkey->val = ntohl(*((__u32 *)(mac + 2)));\n\t\tret |= pack_key32(~0, sel, tkey);\n\t} else {\n\t\tfprintf(stderr,\n\t\t\t\"pack_mac: mac offsets must begin in 32bit or 16bit boundaries\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int pack_ipv6(struct m_pedit_sel *sel, struct m_pedit_key *tkey,\n\t\t     __u32 *ipv6)\n{\n\tint ret = 0;\n\tint i;\n\n\tif (tkey->off & 0x3) {\n\t\tfprintf(stderr,\n\t\t\t\"pack_ipv6: IPv6 offsets must begin in 32bit boundaries\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttkey->mask = 0;\n\t\ttkey->val = ntohl(ipv6[i]);\n\n\t\tret = pack_key32(~0, sel, tkey);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttkey->off += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_val(int *argc_p, char ***argv_p, __u32 *val, int type)\n{\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\tif (type == TINT)\n\t\treturn get_integer((int *)val, *argv, 0);\n\n\tif (type == TU32)\n\t\treturn get_u32(val, *argv, 0);\n\n\tif (type == TIPV4) {\n\t\tinet_prefix addr;\n\n\t\tif (get_prefix_1(&addr, *argv, AF_INET))\n\t\t\treturn -1;\n\n\t\t*val = addr.data[0];\n\t\treturn 0;\n\t}\n\n\tif (type == TIPV6) {\n\t\tinet_prefix addr;\n\n\t\tif (get_prefix_1(&addr, *argv, AF_INET6))\n\t\t\treturn -1;\n\n\t\tmemcpy(val, addr.data, addr.bytelen);\n\n\t\treturn 0;\n\t}\n\n\tif (type == TMAC) {\n#define MAC_ALEN 6\n\t\tint ret = ll_addr_a2n((char *)val, MAC_ALEN, *argv);\n\n\t\tif (ret == MAC_ALEN)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nint parse_cmd(int *argc_p, char ***argv_p, __u32 len, int type, __u32 retain,\n\t      struct m_pedit_sel *sel, struct m_pedit_key *tkey)\n{\n\t__u32 mask[4] = { 0 };\n\t__u32 val[4] = { 0 };\n\t__u32 *m = &mask[0];\n\t__u32 *v = &val[0];\n\t__u32 o = 0xFF;\n\tint res = -1;\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\tif (pedit_debug)\n\t\tprintf(\"parse_cmd argc %d %s offset %d length %d\\n\",\n\t\t       argc, *argv, tkey->off, len);\n\n\tif (len == 2)\n\t\to = 0xFFFF;\n\tif (len == 4)\n\t\to = 0xFFFFFFFF;\n\n\tif (matches(*argv, \"invert\") == 0) {\n\t\t*v = *m = o;\n\t} else if (matches(*argv, \"set\") == 0 ||\n\t\t   matches(*argv, \"add\") == 0) {\n\t\tif (matches(*argv, \"add\") == 0)\n\t\t\ttkey->cmd = TCA_PEDIT_KEY_EX_CMD_ADD;\n\n\t\tif (!sel->extended && tkey->cmd) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Non extended mode. only 'set' command is supported\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tNEXT_ARG();\n\t\tif (parse_val(&argc, &argv, val, type))\n\t\t\treturn -1;\n\t} else if (matches(*argv, \"preserve\") == 0) {\n\t\tretain = 0;\n\t} else {\n\t\tif (matches(*argv, \"clear\") != 0)\n\t\t\treturn -1;\n\t}\n\n\targc--;\n\targv++;\n\n\tif (argc && matches(*argv, \"retain\") == 0) {\n\t\tNEXT_ARG();\n\t\tif (parse_val(&argc, &argv, &retain, TU32))\n\t\t\treturn -1;\n\t\targc--;\n\t\targv++;\n\t}\n\n\tif (len > 4 && retain != ~0) {\n\t\tfprintf(stderr,\n\t\t\t\"retain is not supported for fields longer the 32 bits\\n\");\n\t\treturn -1;\n\t}\n\n\tif (type == TMAC) {\n\t\tres = pack_mac(sel, tkey, (__u8 *)val);\n\t\tgoto done;\n\t}\n\n\tif (type == TIPV6) {\n\t\tres = pack_ipv6(sel, tkey, val);\n\t\tgoto done;\n\t}\n\n\ttkey->val = *v;\n\ttkey->mask = *m;\n\n\tif (type == TIPV4)\n\t\ttkey->val = ntohl(tkey->val);\n\n\tif (len == 1) {\n\t\tres = pack_key8(retain, sel, tkey);\n\t\tgoto done;\n\t}\n\tif (len == 2) {\n\t\tres = pack_key16(retain, sel, tkey);\n\t\tgoto done;\n\t}\n\tif (len == 4) {\n\t\tres = pack_key32(retain, sel, tkey);\n\t\tgoto done;\n\t}\n\n\treturn -1;\ndone:\n\tif (pedit_debug)\n\t\tprintf(\"parse_cmd done argc %d %s offset %d length %d\\n\",\n\t\t       argc, *argv, tkey->off, len);\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn res;\n\n}\n\nstatic int parse_offset(int *argc_p, char ***argv_p, struct m_pedit_sel *sel,\n\t\t\tstruct m_pedit_key *tkey)\n{\n\tint off;\n\t__u32 len, retain;\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tint res = -1;\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\tif (get_integer(&off, *argv, 0))\n\t\treturn -1;\n\ttkey->off = off;\n\n\targc--;\n\targv++;\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\tif (matches(*argv, \"u32\") == 0) {\n\t\tlen = 4;\n\t\tretain = 0xFFFFFFFF;\n\t\tgoto done;\n\t}\n\tif (matches(*argv, \"u16\") == 0) {\n\t\tlen = 2;\n\t\tretain = 0xffff;\n\t\tgoto done;\n\t}\n\tif (matches(*argv, \"u8\") == 0) {\n\t\tlen = 1;\n\t\tretain = 0xff;\n\t\tgoto done;\n\t}\n\n\treturn -1;\n\ndone:\n\n\tNEXT_ARG();\n\n\t/* [at <someval> offmask <maskval> shift <shiftval>] */\n\tif (matches(*argv, \"at\") == 0) {\n\n\t\t__u32 atv = 0, offmask = 0x0, shift = 0;\n\n\t\tNEXT_ARG();\n\t\tif (get_u32(&atv, *argv, 0))\n\t\t\treturn -1;\n\t\ttkey->at = atv;\n\n\t\tNEXT_ARG();\n\n\t\tif (get_u32(&offmask, *argv, 16))\n\t\t\treturn -1;\n\t\ttkey->offmask = offmask;\n\n\t\tNEXT_ARG();\n\n\t\tif (get_u32(&shift, *argv, 0))\n\t\t\treturn -1;\n\t\ttkey->shift = shift;\n\n\t\tNEXT_ARG();\n\t}\n\n\tres = parse_cmd(&argc, &argv, len, TU32, retain, sel, tkey);\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn res;\n}\n\nstatic int parse_munge(int *argc_p, char ***argv_p, struct m_pedit_sel *sel)\n{\n\tstruct m_pedit_key tkey = {};\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tint res = -1;\n\n\tif (argc <= 0)\n\t\treturn -1;\n\n\tif (matches(*argv, \"offset\") == 0) {\n\t\tNEXT_ARG();\n\t\tres = parse_offset(&argc, &argv, sel, &tkey);\n\t\tgoto done;\n\t} else {\n\t\tchar k[FILTER_NAMESZ];\n\t\tstruct m_pedit_util *p = NULL;\n\n\t\tstrncpy(k, *argv, sizeof(k) - 1);\n\n\t\tif (argc > 0) {\n\t\t\tp = get_pedit_kind(k);\n\t\t\tif (p == NULL)\n\t\t\t\tgoto bad_val;\n\t\t\tNEXT_ARG();\n\t\t\tres = p->parse_peopt(&argc, &argv, sel, &tkey);\n\t\t\tif (res < 0) {\n\t\t\t\tfprintf(stderr, \"bad pedit parsing\\n\");\n\t\t\t\tgoto bad_val;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\nbad_val:\n\treturn -1;\n\ndone:\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn res;\n}\n\nstatic int pedit_keys_ex_getattr(struct rtattr *attr,\n\t\t\t\t struct m_pedit_key_ex *keys_ex, int n)\n{\n\tstruct rtattr *i;\n\tint rem = RTA_PAYLOAD(attr);\n\tstruct rtattr *tb[TCA_PEDIT_KEY_EX_MAX + 1];\n\tstruct m_pedit_key_ex *k = keys_ex;\n\n\tfor (i = RTA_DATA(attr); RTA_OK(i, rem); i = RTA_NEXT(i, rem)) {\n\t\tif (!n)\n\t\t\treturn -1;\n\n\t\tif (i->rta_type != TCA_PEDIT_KEY_EX)\n\t\t\treturn -1;\n\n\t\tparse_rtattr_nested(tb, TCA_PEDIT_KEY_EX_MAX, i);\n\n\t\tk->htype = rta_getattr_u16(tb[TCA_PEDIT_KEY_EX_HTYPE]);\n\t\tk->cmd = rta_getattr_u16(tb[TCA_PEDIT_KEY_EX_CMD]);\n\n\t\tk++;\n\t\tn--;\n\t}\n\n\treturn !!n;\n}\n\nstatic int pedit_keys_ex_addattr(struct m_pedit_sel *sel, struct nlmsghdr *n)\n{\n\tstruct m_pedit_key_ex *k = sel->keys_ex;\n\tstruct rtattr *keys_start;\n\tint i;\n\n\tif (!sel->extended)\n\t\treturn 0;\n\n\tkeys_start = addattr_nest(n, MAX_MSG, TCA_PEDIT_KEYS_EX | NLA_F_NESTED);\n\n\tfor (i = 0; i < sel->sel.nkeys; i++) {\n\t\tstruct rtattr *key_start;\n\n\t\tkey_start = addattr_nest(n, MAX_MSG,\n\t\t\t\t\t TCA_PEDIT_KEY_EX | NLA_F_NESTED);\n\n\t\tif (addattr16(n, MAX_MSG, TCA_PEDIT_KEY_EX_HTYPE, k->htype) ||\n\t\t    addattr16(n, MAX_MSG, TCA_PEDIT_KEY_EX_CMD, k->cmd)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\taddattr_nest_end(n, key_start);\n\n\t\tk++;\n\t}\n\n\taddattr_nest_end(n, keys_start);\n\n\treturn 0;\n}\n\nstatic int parse_pedit(struct action_util *a, int *argc_p, char ***argv_p,\n\t\t       int tca_id, struct nlmsghdr *n)\n{\n\tstruct m_pedit_sel sel = {};\n\n\tint argc = *argc_p;\n\tchar **argv = *argv_p;\n\tint ok = 0, iok = 0;\n\tstruct rtattr *tail;\n\n\twhile (argc > 0) {\n\t\tif (pedit_debug > 1)\n\t\t\tfprintf(stderr, \"while pedit (%d:%s)\\n\", argc, *argv);\n\t\tif (matches(*argv, \"pedit\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tok++;\n\n\t\t\tif (matches(*argv, \"ex\") == 0) {\n\t\t\t\tif (ok > 1) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"'ex' must be before first 'munge'\\n\");\n\t\t\t\t\texplain();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tsel.extended = true;\n\t\t\t\tNEXT_ARG();\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t} else if (matches(*argv, \"help\") == 0) {\n\t\t\tusage();\n\t\t} else if (matches(*argv, \"munge\") == 0) {\n\t\t\tif (!ok) {\n\t\t\t\tfprintf(stderr, \"Bad pedit construct (%s)\\n\",\n\t\t\t\t\t*argv);\n\t\t\t\texplain();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tNEXT_ARG();\n\n\t\t\tif (parse_munge(&argc, &argv, &sel)) {\n\t\t\t\tfprintf(stderr, \"Bad pedit construct (%s)\\n\",\n\t\t\t\t\t*argv);\n\t\t\t\texplain();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tok++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (!ok) {\n\t\texplain();\n\t\treturn -1;\n\t}\n\n\tparse_action_control_dflt(&argc, &argv, &sel.sel.action, false, TC_ACT_OK);\n\n\tif (argc) {\n\t\tif (matches(*argv, \"index\") == 0) {\n\t\t\tNEXT_ARG();\n\t\t\tif (get_u32(&sel.sel.index, *argv, 10)) {\n\t\t\t\tfprintf(stderr, \"Pedit: Illegal \\\"index\\\"\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\targc--;\n\t\t\targv++;\n\t\t\tiok++;\n\t\t}\n\t}\n\n\ttail = addattr_nest(n, MAX_MSG, tca_id);\n\tif (!sel.extended) {\n\t\taddattr_l(n, MAX_MSG, TCA_PEDIT_PARMS, &sel,\n\t\t\t  sizeof(sel.sel) +\n\t\t\t  sel.sel.nkeys * sizeof(struct tc_pedit_key));\n\t} else {\n\t\taddattr_l(n, MAX_MSG, TCA_PEDIT_PARMS_EX, &sel,\n\t\t\t  sizeof(sel.sel) +\n\t\t\t  sel.sel.nkeys * sizeof(struct tc_pedit_key));\n\n\t\tpedit_keys_ex_addattr(&sel, n);\n\t}\n\n\taddattr_nest_end(n, tail);\n\n\t*argc_p = argc;\n\t*argv_p = argv;\n\treturn 0;\n}\n\nstatic const char * const pedit_htype_str[] = {\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK] = \"\",\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_ETH] = \"eth\",\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_IP4] = \"ipv4\",\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_IP6] = \"ipv6\",\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_TCP] = \"tcp\",\n\t[TCA_PEDIT_KEY_EX_HDR_TYPE_UDP] = \"udp\",\n};\n\nstatic void print_pedit_location(FILE *f,\n\t\t\t\t enum pedit_header_type htype, __u32 off)\n{\n\tif (htype == TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK) {\n\t\tfprintf(f, \"%d\", (unsigned int)off);\n\t\treturn;\n\t}\n\n\tif (htype < ARRAY_SIZE(pedit_htype_str))\n\t\tfprintf(f, \"%s\", pedit_htype_str[htype]);\n\telse\n\t\tfprintf(f, \"unknown(%d)\", htype);\n\n\tfprintf(f, \"%c%d\", (int)off  >= 0 ? '+' : '-', abs((int)off));\n}\n\nstatic int print_pedit(struct action_util *au, FILE *f, struct rtattr *arg)\n{\n\tstruct tc_pedit_sel *sel;\n\tstruct rtattr *tb[TCA_PEDIT_MAX + 1];\n\tstruct m_pedit_key_ex *keys_ex = NULL;\n\n\tif (arg == NULL)\n\t\treturn -1;\n\n\tparse_rtattr_nested(tb, TCA_PEDIT_MAX, arg);\n\n\tif (!tb[TCA_PEDIT_PARMS] && !tb[TCA_PEDIT_PARMS_EX]) {\n\t\tfprintf(stderr, \"Missing pedit parameters\\n\");\n\t\treturn -1;\n\t}\n\n\tif (tb[TCA_PEDIT_PARMS]) {\n\t\tsel = RTA_DATA(tb[TCA_PEDIT_PARMS]);\n\t} else {\n\t\tint err;\n\n\t\tsel = RTA_DATA(tb[TCA_PEDIT_PARMS_EX]);\n\n\t\tif (!tb[TCA_PEDIT_KEYS_EX]) {\n\t\t\tfprintf(f, \"Netlink error\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tkeys_ex = calloc(sel->nkeys, sizeof(*keys_ex));\n\t\tif (!keys_ex) {\n\t\t\tfprintf(f, \"Out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = pedit_keys_ex_getattr(tb[TCA_PEDIT_KEYS_EX], keys_ex,\n\t\t\t\t\t    sel->nkeys);\n\t\tif (err) {\n\t\t\tfprintf(f, \"Netlink error\\n\");\n\n\t\t\tfree(keys_ex);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfprintf(f, \" pedit \");\n\tprint_action_control(f, \"action \", sel->action, \" \");\n\tfprintf(f,\"keys %d\\n \", sel->nkeys);\n\tfprintf(f, \"\\t index %u ref %d bind %d\", sel->index, sel->refcnt,\n\t\tsel->bindcnt);\n\n\tif (show_stats) {\n\t\tif (tb[TCA_PEDIT_TM]) {\n\t\t\tstruct tcf_t *tm = RTA_DATA(tb[TCA_PEDIT_TM]);\n\n\t\t\tprint_tm(f, tm);\n\t\t}\n\t}\n\tif (sel->nkeys) {\n\t\tint i;\n\t\tstruct tc_pedit_key *key = sel->keys;\n\t\tstruct m_pedit_key_ex *key_ex = keys_ex;\n\n\t\tfor (i = 0; i < sel->nkeys; i++, key++) {\n\t\t\tenum pedit_header_type htype =\n\t\t\t\tTCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK;\n\t\t\tenum pedit_cmd cmd = TCA_PEDIT_KEY_EX_CMD_SET;\n\n\t\t\tif (keys_ex) {\n\t\t\t\thtype = key_ex->htype;\n\t\t\t\tcmd = key_ex->cmd;\n\n\t\t\t\tkey_ex++;\n\t\t\t}\n\n\t\t\tfprintf(f, \"\\n\\t key #%d\", i);\n\n\t\t\tfprintf(f, \"  at \");\n\n\t\t\tprint_pedit_location(f, htype, key->off);\n\n\t\t\tfprintf(f, \": %s %08x mask %08x\",\n\t\t\t\tcmd ? \"add\" : \"val\",\n\t\t\t\t(unsigned int)ntohl(key->val),\n\t\t\t\t(unsigned int)ntohl(key->mask));\n\t\t}\n\t} else {\n\t\tfprintf(f, \"\\npedit %x keys %d is not LEGIT\", sel->index,\n\t\t\tsel->nkeys);\n\t}\n\n\tprint_nl();\n\n\tfree(keys_ex);\n\treturn 0;\n}\n\nstruct action_util pedit_action_util = {\n\t.id = \"pedit\",\n\t.parse_aopt = parse_pedit,\n\t.print_aopt = print_pedit,\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-iproute2-5.7.0-rricwi5kyr44folgpvkusojnfntsrsry/spack-src/testsuite/tests/ss/ss1.dump"
    ],
    "total_files": 583
}