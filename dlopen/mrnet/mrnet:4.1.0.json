{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/doc/mrnet_4.1.0.html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\"><HTML>\n<HEAD>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=ISO-8859-1\">\n<META HTTP-EQUIV=\"Content-Style-Type\" CONTENT=\"text/css\">\n<META NAME=\"GENERATOR\" CONTENT=\"Adobe FrameMaker 7.0/HTML Export Filter\">\n<LINK REL=\"STYLESHEET\" HREF=\"mrnet_4.1.0.css\" CHARSET=\"ISO-8859-1\" TYPE=\"text/css\">\n<TITLE>\n Table of Contents\n</TITLE>\n\n</HEAD>\n<BODY BGCOLOR=\"#ffffff\">\n<P CLASS=\"Body\">\n<A NAME=\"50520065_pgfId-108356\"></A>&nbsp;</P>\n<DIV>\n<H1 CLASS=\"Title\">\n<A NAME=\"50520072_pgfId-628840\"></A>Table of Contents</H1>\n<P CLASS=\"nh1TOC\">\n<A NAME=\"50520072_pgfId-629245\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1023908\" CLASS=\"Index\">Introduction \t1</A></P>\n<P CLASS=\"nh1TOC\">\n<A NAME=\"50520072_pgfId-629247\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1026670\" CLASS=\"Index\">Abstractions \t2</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629249\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1023961\" CLASS=\"Index\">End-Points \t2</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629251\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1023972\" CLASS=\"Index\">Communicators \t2</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629253\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031063\" CLASS=\"Index\">Streams \t2</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629255\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031073\" CLASS=\"Index\">Filters \t2</A></P>\n<P CLASS=\"nh1TOC\">\n<A NAME=\"50520072_pgfId-629257\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031120\" CLASS=\"Index\">A Simple Example \t4</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629259\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031121\" CLASS=\"Index\">The MRNet Interface \t4</A></P>\n<DIV>\n<H6 CLASS=\"FigureTitleTOC\">\n<A NAME=\"50520072_pgfId-629261\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1036886\" CLASS=\"Index\">MRNet Front-End Sample Code \t4</A></H6>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629263\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031191\" CLASS=\"Index\">MRNet Instantiation \t5</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"FigureTitleTOC\">\n<A NAME=\"50520072_pgfId-629265\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1055560\" CLASS=\"Index\">MRNet Back-End Sample Code \t5</A></H6>\n<P CLASS=\"nh1TOC\">\n<A NAME=\"50520072_pgfId-629267\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031386\" CLASS=\"Index\">The MRNet API \t7</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629269\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1036741\" CLASS=\"Index\">C++ API Reference \t7</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629271\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1035253\" CLASS=\"Index\">C API Reference \t25</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629273\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031405\" CLASS=\"Index\">Building and Testing MRNet \t31</A></H6>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629275\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031427\" CLASS=\"Index\">Supported Platforms and Compilers \t31</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629277\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031499\" CLASS=\"Index\">Configuration, Compilation, and Installation \t31</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629279\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031535\" CLASS=\"Index\">Testing the Code \t31</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629281\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031510\" CLASS=\"Index\">Bugs, Questions, and Comments \t31</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629283\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031505\" CLASS=\"Index\">A Complete Example: Integer Addition \t32</A></H6>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629285\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1044461\" CLASS=\"Index\">A Complete MRNet Front-End \t32</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629287\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031764\" CLASS=\"Index\">A Complete MRNet Back-End \t34</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629289\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031877\" CLASS=\"Index\">A Complete MRNet Lightweight Back-End \t35</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629291\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031878\" CLASS=\"Index\">A MRNet Filter: Integer Addition \t36</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629293\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031426\" CLASS=\"Index\">Process-Tree Topologies \t37</A></H6>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629295\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1032108\" CLASS=\"Index\">Topology File Format \t37</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629297\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1048570\" CLASS=\"Index\">An Example Topology File \t38</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629299\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1032109\" CLASS=\"Index\">Topology File Generator \t38</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629301\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031412\" CLASS=\"Index\">Adding New Filters \t39</A></H6>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629303\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1032205\" CLASS=\"Index\">Defining an MRNet Filter \t39</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629305\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1032206\" CLASS=\"Index\">Fault-Tolerant Filters \t39</A></P>\n<P CLASS=\"nh2TOC\">\n<A NAME=\"50520072_pgfId-629307\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1032207\" CLASS=\"Index\">Creating and Using MRNet Filter Shared Object Files \t40</A></P>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629309\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1054752\" CLASS=\"Index\">Format Strings \t41</A></H6>\n<DIV>\n<H6 CLASS=\"TableTitleTOC\">\n<A NAME=\"50520072_pgfId-629311\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1054908\" CLASS=\"Index\">Format String Conversions \t41</A></H6>\n</DIV>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629313\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1031410\" CLASS=\"Index\">MRNet Stream Performance Data \t42</A></H6>\n<DIV>\n<H6 CLASS=\"TableTitleTOC\">\n<A NAME=\"50520072_pgfId-629315\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1055206\" CLASS=\"Index\">Metric-Context Compatibility Matrix \t43</A></H6>\n</DIV>\n</DIV>\n<DIV>\n<H6 CLASS=\"Header-AppendixTOC\">\n<A NAME=\"50520072_pgfId-629317\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1052906\" CLASS=\"Index\">Network Settings \t44</A></H6>\n<DIV>\n<H6 CLASS=\"TableTitleTOC\">\n<A NAME=\"50520072_pgfId-629319\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_pgfId-1033597\" CLASS=\"Index\">Environment Variables and Network Attributes \t44</A></H6>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"nh1\">\n<A NAME=\"50520069_pgfId-1023908\"></A>Introduction</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1030968\"></A>MRNet is a customizable, high-throughput communication software system for parallel tools and applications with a master/slave architecture. MRNet reduces the cost of these tools' activities by incorporating a tree-based overlay network (TBON) of processes between the tool's front-end and back-ends. MRNet uses the TBON to distribute many important tool communication and computation activities, reducing analysis time and keeping tool front-end loads manageable.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1030970\"></A>MRNet-based tools send data between front-end and back-ends on logical flows of data called streams. MRNet internal processes use filters to synchronize and aggregate data sent to the tool's front-end. Using filters to manipulate data in parallel as it passes through the network, MRNet can efficiently compute averages, sums, and other more complex aggregations on back-end data.</P>\n<UL>\n<LI CLASS=\"pp\">\n<A NAME=\"50520069_pgfId-1030971\"></A>&nbsp;</LI>\n</UL>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1024782\"></A>Several features make MRNet especially well-suited as a general facility for building scalable parallel tools: </P>\n<UL>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1030997\"></A><EM CLASS=\"Emphasis\">\nFlexible organization</EM>\n. MRNet does not dictate the organization of the TBON. MRNet process organization is specified in a configuration file that can specify common network overlays like k-ary and k-nomial trees, or custom layouts tailored to the system(s) running the tool. For example, MRNet internal processes can be allocated to dedicated system nodes or co-located with tool back-end and application processes.</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031004\"></A><EM CLASS=\"Emphasis\">\nScalable, flexible data aggregation</EM>\n. MRNet's built-in filters provide efficient computation of averages, sums, concatenation, and other common data reductions. Custom filters can be loaded dynamically into the network to perform tool-specific aggregation operations.</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031011\"></A><EM CLASS=\"Emphasis\">\nHigh-bandwidth communication.</EM>\n MRNet transfers data within the tool system using an efficient, packed binary representation. Zero-copy data paths are used whenever possible to reduce the cost of transferring data through internal processes.</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031018\"></A><EM CLASS=\"Emphasis\">\nScalable multicast.</EM>\n As the number of back-ends increases, serialization when sending control requests limits the scalability of existing tools. MRNet supports efficient message multicast to reduce the cost of issuing control requests from the tool front-end to its back-ends.</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031025\"></A><EM CLASS=\"Emphasis\">\nMultiple concurrent data channels</EM>\n. MRNet supports multiple logical streams of data between tool components. Data aggregation and message multicast takes place within the context of a data stream, and multiple operations (both upward and downward) can be active simultaneously.</LI>\n</UL>\n</DIV>\n<DIV>\n<H2 CLASS=\"nh1\">\n<A NAME=\"50520069_pgfId-1026670\"></A>Abstractions</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1055743\"></A>The MRNet distribution has two main components: <EM CLASS=\"codeword\">\nlibmrnet</EM>\n, a library that is linked into a tool's front-end and back-end components, and <EM CLASS=\"codeword\">\nmrnet_commnode</EM>\n, a program that runs on intermediate nodes interposed between the application front-end and back-ends. <EM CLASS=\"codeword\">\nlibmrnet</EM>\n exports an API (see <A HREF=\"mrnet_4.1.0.htm#50520069_48507\" CLASS=\"XRef\">See C++ API Reference</A>) that enables I/O interaction between the front-end and groups of back-ends via MRNet. The primary purpose of <EM CLASS=\"codeword\">\nmrnet_commnode</EM>\n is to distribute data processing functionality across multiple computer hosts and to implement efficient and scalable group communications. In addition, there is another component, <EM CLASS=\"codeword\">\nlibmrnet_lightweight</EM>\n, which exports an API (see <A HREF=\"mrnet_4.1.0.htm#50520069_42905\" CLASS=\"XRef\">See C API Reference</A>) that enables I/O interaction between the front-end and groups of &quot;lightweight&quot; back-ends via MRNet. Lightweight back-ends provide a pure C implementation of the MRNet API. They also do not support loading custom filters, and by default the API cannot be used by multiple threads concurrently. There is a separately built component, <EM CLASS=\"codeword\">\nlibmrnet_lightweight_r</EM>\n, which is thread-safe. The following sub-sections describe the lower-level components of the MRNet API in more detail. </P>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1023961\"></A>End-Points</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1023968\"></A>An MRNet end-point represents a tool or application process. Specifically, they represent the back-end processes (i.e., leaf processes) in the overlay tree. The front-end can communicate in a unicast or multicast fashion with these end-points as described below. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1023972\"></A>Communicators</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036817\"></A>MRNet uses communicators to represent groups of end-points. Like communicators in MPI, MRNet communicators provide a handle that identifies a set of end-points for point-to-point, multicast or broadcast communications. MPI applications typically have a non-hierarchical layout of potentially identical processes. In contrast, MRNet enforces a tree-like layout of all processes, rooted at the front-end. Accordingly, MRNet communicators are created and managed by the front-end, and communication is only allowed between a front-end and its back-ends. Thus, back-ends cannot interact with each other directly using the MRNet API. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031063\"></A>Streams</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1055781\"></A>A stream is a logical channel that connects the front-end to the end-points of a communicator. All MRNet communication uses the stream abstraction. Streams carry data packets downstream, from the front-end toward the back-ends, and upstream, from the back-ends toward the front-end. Streams are expected to carry data of a specific type, allowing data aggregation operations to be associated with a stream. The type is specified using a format string (see <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A>) similar to those used in C formatted I/O primitives (e.g., a packet whose data is described by the format string &quot;<EM CLASS=\"codeword\">\n%d %d %f %s</EM>\n&quot; contains two integers followed by a float then a character string). MRNet expands the standard format string specification to allow for description of arrays. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031073\"></A>Filters</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031076\"></A>Data aggregation is the process of merging multiple input data packets and transforming them into one or more output packets. Though it is not necessary for the aggregation to result in less or even different data, aggregations that reduce or modify data values are most common. MRNet uses data filters to aggregate data packets. Filters specify an operation to perform and the type of the data expected on the bound stream. Filter instances are bound to a stream at stream creation. MRNet uses two types of filters: synchronization filters and transformation filters. Synchronization filters organize data packets from downstream nodes into synchronized waves of data packets, while transformation filters operate on the synchronized data packets yielding one or more output packets. A distinction between synchronization and transformation filters is that synchronization filters are independent of the packet data type, but transformation filters operate on packets of a specific type.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031078\"></A>Synchronization filters operate on data flowing upstream in the network, receiving packets one at a time and outputting packets only when the specified synchronization criteria has been met. Synchronization filters provide a mechanism to deal with the asynchronous arrival of packets from children nodes. The synchronizer collects packets and typically aligns them into waves, passing an entire wave onward at the same time. Therefore, synchronization filters do no data transformation and can operate on packets in a type-independent fashion. MRNet currently supports three synchronization modes:</P>\n<UL>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031080\"></A><EM CLASS=\"Emphasis\">\nWait For All</EM>\n: wait for a complete wave (i.e., a packet from every child node) before producing output packets (SFILTER_WAITFORALL)</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031081\"></A><EM CLASS=\"Emphasis\">\nDo Not Wait: </EM>\noutput packets immediately (SFILTER_DONTWAIT)</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1037159\"></A>Timeout : output packets after `timeout' milliseconds (SFILTER_TIMEOUT), or when a complete wave has been accumulated. The timeout period begins upon receipt of the first packet since the filter last produced output. The timeout value in milliseconds can be set using Stream::set_FilterParameters. Note that this timeout value is used at each level of the tree - a timeout value of 100ms combined with a tree of depth three should produce outputs at the front-end approximately 300ms after a packet is sent from a back-end. The default timeout value is 0ms. If you use SFILTER_TIMEOUT without setting a non-zero timeout value, it will behave similar to SFILTER_DONTWAIT.</LI>\n</UL>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031083\"></A>Transformation filters can be used on both upstream and downstream data flows. Transformation filters input a group of synchronized packets, and combine data from multiple packets by performing an aggregation that yields one or more new data packets. Data packets produced by a transformation filter can be forwarded in either direction on a Stream by placing them in the appropriate output set. Since transformation filters are expected to perform computational operations on data packets, there is a type requirement for the data packets to be passed to this type of filter: the data format string of the stream's packets and the filter must be the same. Transformation operations must be synchronous, but are able to maintain state from one execution to the next. MRNet provides several transformation filters that should be of general use:</P>\n<UL>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031085\"></A><EM CLASS=\"Emphasis\">\nBasic scalar operations on characters/integers/floats</EM>\n: minimum (TFILTER_MIN), maximum (TFILTER_MAX), summation (TFILTER_SUM), average (TFILTER_AVG)</LI>\n<LI CLASS=\"ip\">\n<A NAME=\"50520069_pgfId-1031086\"></A><EM CLASS=\"Emphasis\">\nConcatenation</EM>\n: operation that inputs n scalars and outputs a vector of length n of the same base type (TFILTER_ARRAY_CONCAT)</LI>\n</UL>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031074\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_28904\" CLASS=\"XRef\">See Adding New Filters</A> describes facilities for adding new user-defined transformation and synchronization filters. </P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"nh1\">\n<A NAME=\"50520069_pgfId-1031120\"></A>A Simple Example</H2>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031121\"></A>The MRNet Interface</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031129\"></A>A complete description of the MRNet API is in <A HREF=\"mrnet_4.1.0.htm#50520069_48507\" CLASS=\"XRef\">See C++ API Reference</A> and <A HREF=\"mrnet_4.1.0.htm#50520069_42905\" CLASS=\"XRef\">See C API Reference</A>. This section offers a brief overview only. Using <EM CLASS=\"codeword\">\nlibmrnet,</EM>\n a tool can leverage a system of internal processes, instances of the <EM CLASS=\"codeword\">\nmrnet_commnode</EM>\n program, as a communication substrate. After instantiation of the MRNet network (discussed in <A HREF=\"mrnet_4.1.0.htm#50520069_25663\" CLASS=\"XRef\">See MRNet Instantiation</A>), the front-end and back-end processes are connected by the internal processes. The connection topology and host assignment of these processes is determined by a configuration file, thus the geometry of MRNet's process tree can be customized to suit the physical topology of the underlying hardware resources. While MRNet can generate a variety of standard topologies, users can easily specify their own topologies; see <A HREF=\"mrnet_4.1.0.htm#50520069_88497\" CLASS=\"XRef\">See Process-Tree Topologies</A> for further discussion.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031127\"></A>The MRNet API contains Network, EndPoint, Communicator, and Stream objects that a tool's front-end and back-end use for communication. The Network object is used to instantiate the MRNet network and access EndPoint objects that represent available tool back-ends. The Communicator object is a container for groups of end-points, and Stream objects are used to send data to the EndPoints in a Communicator. </P>\n<TABLE BORDER=\"1\">\n<CAPTION>\n<H6 CLASS=\"FigureTitle\">\n<A NAME=\"50520069_pgfId-1036886\"></A><A NAME=\"50520069_46966\"></A>MRNet Front-End Sample Code</H6>\n</CAPTION>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036869\"></A>front_end_main(...) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036870\"></A>\tNetwork * net;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036871\"></A>\tCommunicator * comm;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036872\"></A>\tStream * stream;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036873\"></A>\tPacketPtr packet;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036874\"></A>\tint tag = FirstApplicationTag;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036875\"></A>\tfloat result;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036876\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036877\"></A>\tnet = Network::CreateNetworkFE(topology_file, backend_exe, argv);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036878\"></A>\tcomm = net-&gt;get_BroadcastCommunicator( );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036879\"></A>\tstream = net-&gt;new_Stream(comm, TFILTER_SUM, SFILTER_WAITFORALL);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036880\"></A>\tstream-&gt;send(tag, &quot;%d&quot;, SUM_INIT);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036881\"></A>\tstream-&gt;recv(&amp;tag, packet)</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1036882\"></A>\tpacket-&gt;unpack(&quot;%f&quot;, &amp;result);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1044517\"></A>}</P>\n</TD>\n</TR>\n</TABLE>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036943\"></A>A simplified version of code from an example tool front-end is shown in <A HREF=\"mrnet_4.1.0.htm#50520069_46966\" CLASS=\"XRef\">See MRNet Front-End Sample Code</A>. In the front-end code, after some variable definitions in lines 2-6, an instance of the MRNet network is created on line 9 using the topology specified in topology_file. In line 10, the newly created Network object is queried for an auto-generated broadcast communicator that contains all available end-points. In line 11, this Communicator is used to establish a Stream that will use a built-in filter that finds the summation of the data sent upstream. The front-end then sends one or more initialization messages to the backends; in our example code on line 12, we broadcast an integer initializer on the new stream. The tag parameter is an application-specific value denoting the nature of the message being transmitted. After the send operation, the front-end performs a blocking stream receive at line 13. This call returns a tag and a packet. Finally, line 14 calls unpack to deserialize the floating point value contained in packet.</P>\n<TABLE BORDER=\"1\">\n<CAPTION>\n<H6 CLASS=\"FigureTitle\">\n<A NAME=\"50520069_pgfId-1055560\"></A><A NAME=\"50520069_10625\"></A>MRNet Back-End Sample Code</H6>\n</CAPTION>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055546\"></A>back_end_main(int argc, char** argv) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055547\"></A>\tStream * stream;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055548\"></A>\tPacketPtr packet;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055549\"></A>\tint val, tag;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055550\"></A>\tfloat random_float = (float) random( );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055551\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055552\"></A>\tNetwork * net = Network::CreateNetworkBE(argc,argv);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055553\"></A>\tnet-&gt;recv(&amp;tag, packet, &amp;stream);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055554\"></A>\tpacket-&gt;unpack(&quot;%d&quot;, &amp;val );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055555\"></A>\tif( val == SUM_INIT )</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055556\"></A>\t\tstream-&gt;send(tag, &quot;%f&quot;, random_float);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1055557\"></A>}</P>\n</TD>\n</TR>\n</TABLE>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036966\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_10625\" CLASS=\"XRef\">See MRNet Back-End Sample Code</A> shows the code for the back-end that reciprocates the actions of the front-end. Each tool back-end first connects to the MRNet network in line 5, using the back-end version of the Network constructor that receives its arguments via the program argument vector (<EM CLASS=\"codeword\">\nargc/argv</EM>\n). While the front-end makes a stream-specific receive call, the back-ends use a stream-anonymous network receive that returns the tag sent by the front-end, the packet containing the actual data sent, and a stream object representing the stream that the front-end has established. Finally, each back-end sends a scalar floating point value upstream toward the front-end.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036970\"></A>A complete example of MRNet code can be found below in <A HREF=\"mrnet_4.1.0.htm#50520069_58245\" CLASS=\"XRef\">See A Complete Example: Integer Addition</A>. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031191\"></A><A NAME=\"50520069_25663\"></A>MRNet Instantiation</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031162\"></A>While conceptually simple, creating and connecting the internal processes is complicated by interactions with the various job scheduling systems. In the simplest environments, MRNet can launch processes directly using facilities like <EM CLASS=\"codeword\">\nrsh</EM>\n or <EM CLASS=\"codeword\">\nssh</EM>\n. In more complex environments, it is necessary to submit all requests to a job management system. In this case, MRNet is constrained by the operations provided by the job manager (and these vary from system to system). Currently, two modes of instantiating MRNet-based tools are supported.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031164\"></A>In the first mode of process instantiation, MRNet creates the internal and back-end processes, using the specified MRNet topology configuration to determine the hosts on which the components should be located. First, the front-end consults the configuration and uses a remote shell program to create internal processes for the first level of the communication tree on the appropriate hosts. Upon instantiation, the newly created processes establish a network connection to the process that created it. The first activity on this connection is a message from parent to child containing the portion of the configuration relevant to that child. The child then uses this information to begin instantiation of the sub-tree rooted at that child. When a sub-tree has been established, the root of that sub-tree sends a report to its parent containing the end-points accessible via that sub-tree. Each internal node establishes its children processes and their respective connections sequentially. However, since the various processes are expected to run on different compute nodes, sub-trees in different branches of the network are created concurrently, maximizing the efficiency of network instantiation.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031160\"></A>In the second mode of process instantiation, MRNet relies on a process management system to create some of the MRNet processes. This mode accommodates tools that require their back-ends to create, monitor, and control other processes. For example, IBM's POE uses environment variables to pass information, such as the process' rank within the application's global MPI communicator, to the MPI run-time library in each application process. In cases like this, MRNet cannot provide back-end processes with the environment necessary to start MPI application processes. As a result, MRNet creates its internal processes recursively as in the first instantiation mode, but does not instantiate any back-end processes. MRNet then waits for the tool back-ends to be started by the process management system to ensure they have the environment needed to create application processes successfully. To allow back-ends to connect to the MRNet network, information such as process host names and connection port numbers must be provided to the back-ends. This information can be provided via the environment, using shared filesystems or other information services as available on the target system. To collect the necessary information, the front-end can use the MRNet API methods for discovering the network topology details. This mode of process instantiation is referred to as &quot;back-end attach mode&quot;. We show how to construct a tool that requires back-end attach in <EM CLASS=\"codeword\">\n$MRNET_ROOT/Examples/NoBackEndInstantiation</EM>\n. </P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"nh1\">\n<A NAME=\"50520069_pgfId-1031386\"></A><A NAME=\"50520069_25905\"></A>The MRNet API </H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036739\"></A>Standard MRNet relies on the back-end nodes supporting C++ libraries. However, we have also created a lightweight backend library with a pure C interface. The instantiation process is the same and both methods of process instantation are supported, although the API interface is slightly different. </P>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1036741\"></A><A NAME=\"50520069_48507\"></A>C++ API Reference</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033713\"></A>All classes are included in the <EM CLASS=\"codeword\">\nMRN</EM>\n namespace. For this discussion, we do not explicitly include reference to the namespace; for example, when we reference the class <EM CLASS=\"codeword\">\nNetwork</EM>\n, we are implying the class <EM CLASS=\"codeword\">\nMRN::Network</EM>\n.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033711\"></A>In MRNet, there are five top-level classes: <EM CLASS=\"codeword\">\nNetwork</EM>\n, <EM CLASS=\"codeword\">\nNetworkTopology</EM>\n, <EM CLASS=\"codeword\">\nCommunicator</EM>\n, <EM CLASS=\"codeword\">\nStream</EM>\n, and <EM CLASS=\"codeword\">\nPacket</EM>\n. The <EM CLASS=\"codeword\">\nNetwork</EM>\n class primarily contains methods for instantiating and destroying MRNet process trees. The <EM CLASS=\"codeword\">\nNetworkTopology</EM>\n class represents the interface for discovering details about the topology of an instantiated network. Application back-ends are referred to as end-points, and the <EM CLASS=\"codeword\">\nCommunicator</EM>\n class is used to reference a group of end-points. A communicator is used to establish a <EM CLASS=\"codeword\">\nStream</EM>\n for unicast, multicast, or broadcast communications via the MRNet infrastructure. The <EM CLASS=\"codeword\">\nPacket</EM>\n class encapsulates the data packets that are sent on a stream. The public members of these classes are detailed below. </P>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031393\"></A>Class Network</H5>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036758\"></A>The corresponding lightweight backend API class is <A HREF=\"mrnet_4.1.0.htm#50520069_53570\" CLASS=\"XRef\">See Class Network</A>.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033722\"></A>Network * Network::CreateNetworkFE(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038985\"></A>\tconst char * topology, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033959\"></A>\tconst char * backend_exe, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033960\"></A>\tconst char ** backend_argv, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037010\"></A>\tconst std::map&lt; std::string, std::string&gt;* attrs=NULL,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033961\"></A>\tbool rank_backends = true, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033962\"></A>\tbool using_memory_buffer = false );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033733\"></A>The front-end constructor method that is used to instantiate the MRNet process tree. <EM CLASS=\"codeword\">\ntopology</EM>\n is the path to a configuration file that describes the desired process tree topology.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034176\"></A><EM CLASS=\"codeword\">\nbackend_exe</EM>\n is the path to the executable to be used for the application's back-end processes. <EM CLASS=\"codeword\">\nbackend_argv</EM>\n is a null terminated list of arguments to pass to the back-end application upon creation (NOTE: <EM CLASS=\"codeword\">\nbackend_argv </EM>\nshoud not contain the executable). If <EM CLASS=\"codeword\">\nbackend_exe</EM>\n is NULL, no back-end processes will be started, and the leaves of the topology specified by topology will be instances of<EM CLASS=\"codeword\">\n mrnet_commnode</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037150\"></A>attrs is a pointer to a map of attribute-value string pairs. attrs allows front-ends to programatically set the values to use for the MRNet and XPlat environment variables (see <A HREF=\"mrnet_4.1.0.htm#50520069_28837\" CLASS=\"XRef\">See Environment Variables and Network Attributes</A>) -- MRNet will only query the environment for settings not given via attrs. On Cray XT, when communication or back-end processes of the MRNet tree are to be co-located with application processes, attrs must contain a string pair that provides either the &quot;CRAY_ALPS_APID&quot; or &quot;CRAY_ALPS_APRUN_PID&quot; attribute value (see <A HREF=\"mrnet_4.1.0.htm#50520069_28837\" CLASS=\"XRef\">See Environment Variables and Network Attributes</A> for a description of these attributes).</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034182\"></A><EM CLASS=\"codeword\">\nrank_backends</EM>\n indicates whether the back-end process ranks should begin at 0, similar to MPI rank numbering, and defaults to true.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033932\"></A>If <EM CLASS=\"codeword\">\nusing_memory_buffer</EM>\n is set to true (default is false), the topology parameter is actually a pointer to a memory buffer containing the specification, rather than the name of a file.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033741\"></A>When this function completes without error, all MRNet processes specified in the topology will have been instantiated. You may use <EM CLASS=\"codeword\">\nNetwork::has_error</EM>\n to check for successful completion. The explicit use of the <EM CLASS=\"codeword\">\nNetwork</EM>\n constructor is now deprecated.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033743\"></A><A NAME=\"50520069_10810\"></A>Network * Network::CreateNetworkBE( int argc, char ** argv );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033748\"></A>The back-end constructor method that is used when the process is started due to a front-end network instantiation. MRNet automatically passes the necessary information to the back-end process using the program argument vector (<EM CLASS=\"codeword\">\nargc/argv</EM>\n) by inserting it after the user-specified arguments. The explicit use of the <EM CLASS=\"codeword\">\nNetwork</EM>\n constructor is now deprecated.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1050144\"></A>In the &quot;back-end attach&quot; mode of network instantiation, where the back-end is not launched directly by MRNet, the back-end program must construct a suitable argument vector. Typically, the front-end program will obtain information about the leaf mrnet_commnode processes using the NetworkTopology class, and pass this information to back-ends using external communication channels (e.g., a shared file system). The back-ends choose a leaf process as a parent, and use that parent's host, port, and rank information to attach. Each back-end must choose a unique value for its local rank; this value must be larger than any of the ranks of the processes in the existing network. The following code shows how to construct a valid argument vector:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050150\"></A>char parHostname[64], myHostname[64], parPort[6], parRank[6], myRank[6];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050166\"></A>// fill parent data here using info from front-end</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050190\"></A>gethostname( myHostname, 64 );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050191\"></A>sprintf( myRank, &quot;%d&quot;, &lt;unique rank&gt; );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050146\"></A>be_argc = 6;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050135\"></A>char* be_argv[be_argc];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050136\"></A>be_argv[0] = argv[0];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050137\"></A>be_argv[1] = parHostname;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050159\"></A>be_argv[2] = parPort; </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050160\"></A>be_argv[3] = parRank;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050161\"></A>be_argv[4] = myHostname;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050162\"></A>be_argv[5] = myRank;</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033767\"></A>void Network::&#126;Network();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037326\"></A><EM CLASS=\"codeword\">\nNetwork::&#126;Network</EM>\n tears down the MRNet process tree when the <EM CLASS=\"codeword\">\nNetwork</EM>\n object is deleted. Note that Network::shutdown_Network is deprecated.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037333\"></A>void Network::waitfor_ShutDown();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037334\"></A><EM CLASS=\"codeword\">\nNetwork::waitfor_ShutDown</EM>\n can be used by back-ends to block until the network has been shut down by the front-end.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037335\"></A>bool Network::is_ShutDown();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037330\"></A>Back-ends use this method to query if the network has been shut down; returns true if it has been shut down, false otherwise.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1044391\"></A>bool Network::set_FailureRecovery( bool enable );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1044392\"></A><EM CLASS=\"codeword\">\nNetwork::set_FailureRecovery</EM>\n is used by a front-end to control whether internal communication processes and back-ends will automatically re-connect to a new parent when their parent terminates unexpectedly. By default, failure recovery is enabled and processes will re-connect. Call this method with enable set to false to turn off automatic failure recovery. This method returns true if the setting has been applied successfully, false otherwise.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033780\"></A>bool Network::has_Error( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033782\"></A><EM CLASS=\"codeword\">\nNetwork::has_error</EM>\n returns true if an error has occured during the last call to a <EM CLASS=\"codeword\">\nNetwork</EM>\n method. <EM CLASS=\"codeword\">\nNetwork::print_error</EM>\n can be used to print a message describing the exact error. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053256\"></A>ErrorCode Network::get_Error( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053254\"></A><EM CLASS=\"codeword\">\nNetwork::get_Error</EM>\n returns an ErrorCode for an error that occured during the last call to a <EM CLASS=\"codeword\">\nNetwork</EM>\n method. <EM CLASS=\"codeword\">\nNetwork::get_ErrorStr</EM>\n can be used to retrieve a message string describing the error.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053271\"></A>const char * Network::get_ErrorStr( ErrorCode code );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053268\"></A><EM CLASS=\"codeword\">\nNetwork::get_ErrorStr</EM>\n returns a character string describing the error indicated by code. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033784\"></A>void Network::print_error( const char * error_msg );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033787\"></A><EM CLASS=\"codeword\">\nNetwork::print_error</EM>\n prints a message to stderr describing the last error encountered during a Network method. It first prints the null-terminated string <EM CLASS=\"codeword\">\nerror_msg</EM>\n followed by a colon, then the actual error message followed by a newline. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033789\"></A>std::string Network::get_LocalHostName();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033791\"></A><EM CLASS=\"codeword\">\nNetwork::get_LocalHostName</EM>\n returns the name of the host on which the local MRNet process is running. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033793\"></A>Port Network::get_LocalPort();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033795\"></A><EM CLASS=\"codeword\">\n\tNetwork::get_LocalPort </EM>\nreturns the listening port of the local MRNet process. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033797\"></A>Rank Network::get_LocalRank();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1044324\"></A><EM CLASS=\"codeword\">\nNetwork::get_LocalRank </EM>\nreturns the rank of the local MRNet process.<EM CLASS=\"codeword\">\n\t</EM>\n</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033801\"></A>int Network::load_FilterFunc( const char * so_file, const char* func );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033808\"></A>This method loads a new filter operation for use in the Network, and is conveniently similar to the conventional <EM CLASS=\"codeword\">\ndlopen</EM>\n facilities for opening a shared object and dynamically loading symbols defined within. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1044427\"></A><EM CLASS=\"codeword\">\nso_file</EM>\n is the path to a shared object file that contains the filter function to be loaded and <EM CLASS=\"codeword\">\nfunc_name</EM>\n is the name of the function to be loaded. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053978\"></A>On success, <EM CLASS=\"codeword\">\nNetwork::load_FilterFunc</EM>\n returns the id of the newly loaded filter which may be used in subsequent calls to <EM CLASS=\"codeword\">\nNetwork::new_Stream</EM>\n. A value of -1 is returned on failure. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053989\"></A>int Network::load_FilterFuncs(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053995\"></A>\tconst char * so_file, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053990\"></A>\tconst std::vector&lt; const char* &gt; &amp; functions, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053991\"></A>\tstd::vector&lt; int &gt; &amp; filter_ids );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053980\"></A>This method loads several new filter operations residing in the same shared library into the Network.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053973\"></A><EM CLASS=\"codeword\">\nso_file</EM>\n is the path to a shared object file that contains the filter function to be loaded and <EM CLASS=\"codeword\">\nfunctions</EM>\n is a vector of function names to be loaded. <EM CLASS=\"codeword\">\nfilter_ids</EM>\n is an output vector of filter ids, where the id for the function at index i in <EM CLASS=\"codeword\">\nfunctions</EM>\n will be stored at index i in <EM CLASS=\"codeword\">\nfilter_ids</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053974\"></A><EM CLASS=\"codeword\">\nNetwork::load_FilterFuncs</EM>\n returns the number of filter functions that were successfully loaded, and populates the the <EM CLASS=\"codeword\">\nfilter_ids</EM>\n vector with the ids of the newly loaded filters (or -1 if a function could not be loaded). </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033816\"></A>int Network::recv(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038977\"></A>\tint * tag, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034047\"></A>\tPacketPtr &amp; packet, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034048\"></A>\tStream ** stream, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034049\"></A>\tbool blocking = true );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033825\"></A><EM CLASS=\"codeword\">\nNetwork::recv</EM>\n is used to invoke a stream-anonymous receive operation. Any packet available (i.e., addressed to any stream) will be returned (in roughly FIFO order).</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033827\"></A><EM CLASS=\"codeword\">\notag</EM>\n will be filled in with the integer tag value that was passed by the corresponding <EM CLASS=\"codeword\">\nStream::send</EM>\n operation. <EM CLASS=\"codeword\">\npacket</EM>\n is the packet that was received. A pointer to the stream to which the packet was addressed will be returned in <EM CLASS=\"codeword\">\nstream</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033829\"></A><EM CLASS=\"codeword\">\nblocking </EM>\nis used to signal whether this call should block or return if data is not immediately available; it defaults to a blocking call.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033831\"></A>A return value of -1 indicates that the Network has experienced a terminal failure, and further attempts to send or receive data on the Network will fail. A return value of 0 indicates no packets were available for a non-blocking receive, or a stream has been closed for a blocking receive. The return value 1 indicates a packet has been received successfully. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053637\"></A>int Network::send(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053649\"></A>\tRank be, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053638\"></A>\tint tag, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053639\"></A>\tconst char * format_string, ... );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053642\"></A><EM CLASS=\"codeword\">\nNetwork::send</EM>\n is used to singlecast a packet from the front-end to a specific back-end. <EM CLASS=\"codeword\">\nbe</EM>\n is the rank of the back-end process. <EM CLASS=\"codeword\">\ntag</EM>\n is an integer that identifies the data in the packet. <EM CLASS=\"codeword\">\nformat_string</EM>\n is a format string describing the data in the packet (See <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> for a full description.)</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053635\"></A>A return value of -1 indicates that the Network has experienced a terminal failure, and further attempts to send or receive data on the Network will fail. The return value 0 indicates a packet has been sent successfully. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053660\"></A>NOTE: <EM CLASS=\"codeword\">\ntag</EM>\n must have a value greather than or equal to the constant <EM CLASS=\"codeword\">\nFirstApplicationTag </EM>\ndefined by MRNet (<EM CLASS=\"codeword\">\n#include &quot;mrnet/Types.h&quot;</EM>\n). Tag values less than <EM CLASS=\"codeword\">\nFirstApplicationTag</EM>\n are reserved for internal MRNet use.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033833\"></A>bool Network::enable_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038981\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034065\"></A>\tperfdata_context_t context );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033838\"></A><EM CLASS=\"codeword\">\nNetwork::enable_PerformanceData</EM>\n uses <EM CLASS=\"codeword\">\nStream::enable_PerformanceData</EM>\n to start the recording of performance data of the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n on all streams. Returns true on success, false otherwise. <A HREF=\"mrnet_4.1.0.htm#50520069_16750\" CLASS=\"XRef\">See MRNet Stream Performance Data</A> describes the supported metric and context types. See <EM CLASS=\"codeword\">\nStream::enable_PerformanceData</EM>\n for additional details. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033840\"></A>bool Network::disable_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038993\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034081\"></A>\tperfdata_context_t context );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033845\"></A><EM CLASS=\"codeword\">\nNetwork::disable_PerformanceData</EM>\n stops the recording of performance data of the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n on all streams. Returns true on success, false otherwise. See <EM CLASS=\"codeword\">\nStream::disable_PerformanceData</EM>\n for additional details. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033847\"></A>bool Network::collect_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038966\"></A>\tstd::map&lt; int, rank_perfdata_map &gt; &amp; results, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034094\"></A>\tperfdata_metric_t metric, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034095\"></A>\tperfdata_context_t context, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034096\"></A>\tint aggr_filter_id = TFILTER_ARRAY_CONCAT ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033856\"></A><EM CLASS=\"codeword\">\nNetwork::collect_PerformanceData</EM>\n collects the performance data of the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n on all streams. The performance data of each stream is passed through the transformation filter identified by <EM CLASS=\"codeword\">\naggr_filter_id</EM>\n. The data for all streams is stored within the map <EM CLASS=\"codeword\">\nresults</EM>\n, keyed by stream identifier. Returns true on success, false otherwise. See <EM CLASS=\"codeword\">\nStream::collect_PerformanceData</EM>\n for additional details. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033858\"></A>void Network::print_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038973\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034107\"></A>\tperfdata_context_t context ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033863\"></A><EM CLASS=\"codeword\">\nNetwork::enable_PerformanceData</EM>\n uses <EM CLASS=\"codeword\">\nStream::print_PerformanceData</EM>\n to print recorded performance data of the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n on all streams. Data is printed to the MRNet log files. See <EM CLASS=\"codeword\">\nStream::print_PerformanceData</EM>\n for additional details.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053302\"></A>unsigned int Network::num_EventsPending( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053303\"></A><EM CLASS=\"codeword\">\nNetwork::num_EventsPending</EM>\n returns the number of pending events available for retrieval using <EM CLASS=\"codeword\">\nNetwork::next_Event</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053307\"></A>Event * Network::next_Event( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053308\"></A>This method returns a pointer the next pending Event, or NULL if no events are available. Each event has an associated EventClass, one of <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n, <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n, or <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n, that can be queried using Event::get_Class. Similarly, each event has an associated EventType that can be queried using Event::get_Type.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053310\"></A>void Network::clear_Events( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053311\"></A>This method clears all pending events.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053403\"></A>bool Network::register_EventCallback(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053404\"></A>\tEventClass eclass,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053414\"></A>\tEventType etyp,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053722\"></A>\tevt_cb_func cb_func,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053727\"></A>\tvoid * cb_func_data,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053716\"></A>\tbool onetime = false );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053718\"></A><EM CLASS=\"codeword\">\nNetwork::register_EventCallback</EM>\n allows users to register a callback function to be called when events are generated.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053382\"></A><EM CLASS=\"codeword\">\neclass</EM>\n should be set to one of <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n, <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n, or <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053383\"></A><EM CLASS=\"codeword\">\netyp</EM>\n should be set to either <EM CLASS=\"codeword\">\nEvent::EVENT_TYPE_ALL</EM>\n, to have the function called when any event within the specified EventClass occurs, or one of the valid class-specific EventType values (see the classes DataEvent, TopologyEvent, and ErrorEvent in &quot;mrnet/Event.h&quot; for the class-specific types).</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053429\"></A>The type evt_cb_func is defined as `void (*evt_cb_fn)( Event* e, void* cb_data )'. All user-defined callback functions must use the same function prototype. When an event occurs, all callbacks registered for that type of event will be called. Each function is passed a pointer to the <EM CLASS=\"codeword\">\nEvent</EM>\n, and the value of the auxiliary data pointer cb_func_data given at registration, which may be NULL.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053734\"></A><EM CLASS=\"codeword\">\nonetime</EM>\n should be set to true if the function should be removed after it is called for the first (and only) time. Note that onetime callbacks must be registered for a specific event type.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053482\"></A>void Network::remove_EventCallback(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053483\"></A>\tevt_cb_func cb_func,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053484\"></A>\tEventClass eclass,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053485\"></A>\tEventType etyp );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053386\"></A>This method removes cb_func from the list of functions to be called for the specified EventClass and EventType. If <EM CLASS=\"codeword\">\neclass</EM>\n is given as <EM CLASS=\"codeword\">\nEvent::EVENT_CLASS_ALL</EM>\n, the function will be removed for all events. <EM CLASS=\"codeword\">\netyp</EM>\n can be given as <EM CLASS=\"codeword\">\nEvent::EVENT_TYPE_ALL</EM>\n to remove the function for all types of events in the given <EM CLASS=\"codeword\">\neclass</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053545\"></A>void Network::remove_EventCallbacks(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053546\"></A>\tEventClass eclass,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053548\"></A>\tEventType etyp );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053543\"></A>This method removes all functions to be called for the specified EventClass and EventType. If <EM CLASS=\"codeword\">\neclass</EM>\n is given as <EM CLASS=\"codeword\">\nEvent::EVENT_CLASS_ALL</EM>\n, all callback functions will be removed for all events. <EM CLASS=\"codeword\">\netyp</EM>\n can be given as <EM CLASS=\"codeword\">\nEvent::EVENT_TYPE_ALL</EM>\n to remove all functions registered for all types of events in the given <EM CLASS=\"codeword\">\neclass</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033865\"></A>int Network::get_EventNotificationFd( EventClass eclass ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034143\"></A><EM CLASS=\"codeword\">\nNetwork::get_EventNotificationFd</EM>\n returns a file descriptor that can be used with select or poll to receive notification of interesting DATA, TOPOLOGY, or ERROR events.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033870\"></A><EM CLASS=\"codeword\">\neclass</EM>\n should be set to one of <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n, <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n, or <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n. <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n can be used by both front-end and back-end processes to provide notification that one or more data packets have been received. <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n and <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n can only be used by front-end processes, and provide notification when the front-end observes a change in network topology or an error, respectively.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033872\"></A>When the file descriptor has data available (for reading), you should call <EM CLASS=\"codeword\">\nNetwork::clear_EventNotificationFd</EM>\n before taking action on the notification. When notifications are no longer needed, use <EM CLASS=\"codeword\">\nNetwork::close_EventNotificationFd</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053196\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033874\"></A>void Network::clear_EventNotificationFd( EventClass eclass ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053198\"></A>This method resets the event notification file descriptor returned from <EM CLASS=\"codeword\">\nNetwork::get_EventNotificationFd</EM>\n. <EM CLASS=\"codeword\">\neclass</EM>\n should be set to one of <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n, <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n, or <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033877\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033879\"></A>void Network::close_EventNotificationFd( EventClass eclass ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053210\"></A>This method closes the event notification file descriptor returned from <EM CLASS=\"codeword\">\nNetwork::get_EventNotificationFd</EM>\n. <EM CLASS=\"codeword\">\neclass</EM>\n should be set to one of <EM CLASS=\"codeword\">\nEvent::DATA_EVENT</EM>\n, <EM CLASS=\"codeword\">\nEvent::TOPOLOGY_EVENT</EM>\n, or <EM CLASS=\"codeword\">\nEvent::ERROR_EVENT</EM>\n. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1033882\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037040\"></A>bool is_LocalNodeChild( ) const;</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1044353\"></A>bool is_LocalNodeParent( ) const;</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1044359\"></A>bool is_LocalNodeInternal( ) const;</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037043\"></A>bool is_LocalNodeFrontEnd( ) const;</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037045\"></A>bool is_LocalNodeBackEnd( ) const;</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037106\"></A>These methods return true if the local process is of the specified type, false otherwise.</P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031394\"></A>Class NetworkTopology</H5>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1034264\"></A>Instances of NetworkTopology are network specific, so they are created when a Network is instantiated. MRNet API users should not need to create their own NetworkTopology instances.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036763\"></A>The corresponding lightweight backend API class is <A HREF=\"mrnet_4.1.0.htm#50520069_84145\" CLASS=\"XRef\">See Class NetworkTopology</A>.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034265\"></A>NetworkTopology * Network::get_NetworkTopology( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034267\"></A><EM CLASS=\"codeword\">\nNetwork::get_NetworkTopology</EM>\n is used to retrieve a pointer to the underlying NetworkTopology instance of a Network.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034269\"></A>unsigned int NetworkTopology::get_NumNodes( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034271\"></A>This method returns the total number of nodes in the tree topology, including front-end, internal, and back-end processes. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034273\"></A>NetworkTopology::Node * NetworkTopology::find_Node( Rank \tnode_rank );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034276\"></A>This method returns a pointer to the tree node with rank equal to <EM CLASS=\"codeword\">\nnode_rank</EM>\n, or NULL if not found. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034278\"></A>NetworkTopology::Node * NetworkTopology::get_Root( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034280\"></A>    This method returns a pointer to the root node of the tree, or NULL if not found. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034282\"></A>void NetworkTopology::get_Leaves(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1038999\"></A>\tstd::vector&lt;NetworkTopology::Node * &gt; &amp; leaves );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034285\"></A>This method fills the <EM CLASS=\"codeword\">\nleaves</EM>\n vector with pointers to the leaf nodes in the topology. In the case where back-end processes are not started when the network is instantiated, a front-end process can use this function to retrieve information about the leaf internal processes to which the back-ends should attach. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034287\"></A>void NetworkTopology::get_BackEndNodes(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039003\"></A>\tstd::set&lt; NetworkTopology::Node * &gt; &amp; nodes );\t</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034290\"></A>This method fills a set with pointers to all back-end process tree nodes. Note that this method is unsafe to use while the network topology is in flux, as is the case during the &quot;back-end attach&quot; mode of MRNet tree instantiation.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034292\"></A>void NetworkTopology::get_ParentNodes(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039007\"></A>\tstd::set&lt;NetworkTopology::Node * &gt; &amp; nodes );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034295\"></A>This method fills a set with pointers to all tree nodes that are parents (i.e., those nodes having at least one child).</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034297\"></A>void NetworkTopology::get_OrphanNodes(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039011\"></A>\tstd::set&lt; NetworkTopology::Node * &gt; &amp; nodes );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034300\"></A>This method fills a set with pointers to all tree nodes that have no parent due to a failure. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034302\"></A>void NetworkTopology::get_TreeStatistics(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039015\"></A>\tunsigned int &amp; num_nodes,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034454\"></A>\tunsigned int &amp; depth,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034458\"></A>\tunsigned int &amp; min_fanout,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034462\"></A>\tunsigned int &amp; max_fanout,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034466\"></A>\tdouble &amp; avg_fanout,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034470\"></A>\tdouble &amp; stddev_fanout );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034315\"></A>This method provides users statistics about the tree topology by setting the passed parameters.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034317\"></A><EM CLASS=\"codeword\">\nnum_nodes</EM>\n is the total number of tree nodes (same as the value returned by <EM CLASS=\"codeword\">\nNetworkTopology::get_NumNodes</EM>\n), <EM CLASS=\"codeword\">\ndepth</EM>\n is the depth of the tree (i.e., the maximum path length from root to any leaf), <EM CLASS=\"codeword\">\nmin_fanout</EM>\n is the minimum number of children of any parent node, <EM CLASS=\"codeword\">\nmax_fanout</EM>\n is the maximum number of children of any parent node, <EM CLASS=\"codeword\">\navg_fanout</EM>\n is the average number of children across all parent nodes, and <EM CLASS=\"codeword\">\nstddev_fanout</EM>\n is the standard deviation in number of children across all parent nodes. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034319\"></A>void NetworkTopology::print_TopologyFile( const char * \tfilename );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034322\"></A>This method will create (or overwrite) the specified topology file <EM CLASS=\"codeword\">\nfilename</EM>\n using the current state of this <EM CLASS=\"codeword\">\nNetworkTopology</EM>\n object. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034324\"></A>void NetworkTopology::print_DOTGraph( const char * filename );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034327\"></A>This method will create (or overwrite) the specified dot graph file <EM CLASS=\"codeword\">\nfilename</EM>\n using the current state of this <EM CLASS=\"codeword\">\nNetworkTopology</EM>\n object. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034329\"></A>std::string NetworkTopology::Node::get_HostName(\t);\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034331\"></A>This method returns a string identifying the hostname of the tree node. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034333\"></A>Port NetworkTopology::Node::get_Port();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034335\"></A>This method returns the listening port of the tree node. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034337\"></A>Rank NetworkTopology::Node::get_Rank();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034339\"></A>This method returns the unique rank of the tree node. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034341\"></A>Rank NetworkTopology::Node::get_Parent();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034343\"></A>This method returns the rank of the tree node's parent. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034345\"></A>const std::set&lt; NetworkTopology::Node * &gt; &amp; NetworkTopology::Node::get_Children(\t);\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034347\"></A>This method returns a set containing pointers to the children of the tree node, and is useful for navigating through the tree. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034349\"></A>unsigned int NetworkTopology::Node::get_NumChildren(\t);\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034351\"></A>This method returns the number of children of the tree node. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034353\"></A>unsigned int NetworkTopology::Node::find_SubTreeHeight(\t);\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034262\"></A>This method returns the height of the subtree rooted at this NetworkTopology node.</P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031395\"></A>Class Communicator</H5>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1034549\"></A>Instances of Communicator are network specific, so their creation methods are functions of an instantiated Network object. There is no corresponding lightweight backend class.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034551\"></A>Communicator * Network::new_Communicator();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034553\"></A>This method returns a pointer to a new Communicator object. The object contains no end-points. Use <EM CLASS=\"codeword\">\nCommunicator::add_EndPoint</EM>\n to populate the communicator. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034555\"></A>Communicator * Network::new_Communicator( Communicator &amp; comm );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034558\"></A>This method returns a pointer to a new Communicator object that contains the same set of end-points contained in <EM CLASS=\"codeword\">\ncomm</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034560\"></A>Communicator * Network::new_Communicator(\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039019\"></A>\tstd::set&lt; CommunicationNode * &gt; &amp; endpoints );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034563\"></A>This method returns a pointer to a new Communicator object that contains the provided set of end-points. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1044488\"></A>Communicator * Network::new_Communicator( std::set&lt; Rank &gt; &amp; endpoints );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034565\"></A>This method returns a pointer to a new Communicator object that contains the set of end-points corresponding to processes whose ranks are provided in the passed set. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1044494\"></A>Communicator * Network::get_BroadcastCommunicator( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034567\"></A>This method returns a pointer to a broadcast Communicator containing all the end-points available in the system at the time the function is called.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034569\"></A>Multiple calls to this method return the same pointer to the Communicator object created at network instantiation. If the network topology changes, as can occur when starting back-ends separately, the object will be updated to reflect the additions or deletions. This object should not be deleted.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034571\"></A>bool Communicator::add_EndPoint( Rank ep_rank );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034574\"></A>This method is used to add an existing end-point with rank <EM CLASS=\"codeword\">\nep_rank</EM>\n to the set contained by this Communicator.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034576\"></A>If the set of end-points in the communicator already contains the new end-point, the function returns success. This method fails if there exists no end-point defined by <EM CLASS=\"codeword\">\nep_rank</EM>\n. This method returns true on success, false on failure.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034578\"></A>bool Communicator::add_EndPoint( CommunicationNode * endpoint );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034581\"></A>This method is similar to add_EndPoint above except that it takes a pointer to a CommunicationNode object instead of a rank. Success and failure conditions are exactly as stated above. This method returns true on success and false on failure. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034583\"></A>const std::set&lt; CommunicationNode * &gt; &amp; Communicator::get_EndPoints( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034585\"></A>Returns a reference to the set of CommunicationNode pointers comprising the end-points in the communicator. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034587\"></A>std::string CommunicationNode::get_HostName( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034589\"></A>Returns a character string identifying the hostname of the end-point represented by this CommunicationNode. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034591\"></A>Port CommunicationNode::get_Port( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034593\"></A>Returns the listening port of the end-point represented by this CommunicationNode. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034595\"></A>Rank CommunicationNode::get_Rank( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034597\"></A>Returns the rank of the end-point represented by this CommunicationNode. </P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031396\"></A>Class Stream</H5>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1034706\"></A>Instances of Stream are network specific, so their creation methods are functions of an instantiated Network object. The corresponding lightweight backend API class is <A HREF=\"mrnet_4.1.0.htm#50520069_62834\" CLASS=\"XRef\">See Class Stream</A>.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1051244\"></A>MRNet provides two types of streams, homegenous and heterogeneous. Homogenous streams use the same filters at every process participating in the stream, while heterogeneous streams allow for different filters to be used at different processes.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034707\"></A>Stream * Network::new_Stream(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039023\"></A>\tCommunicator * comm, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034868\"></A>\tint up_transfilter_id = TFILTER_NULL, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034871\"></A>\tint up_syncfilter_id = SFILTER_WAITFORALL, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034874\"></A>\tint down_transfilter_id = TFILTER_NULL );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034716\"></A>This version of <EM CLASS=\"codeword\">\nNetwork::new_Stream</EM>\n is used to create a homogenous Stream object attached to the end-points specified by a Communicator object <EM CLASS=\"codeword\">\ncomm</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034718\"></A><EM CLASS=\"codeword\">\nup_transfilter_id</EM>\n specifies the transformation filter to apply to data flowing upstream from the application back-ends toward the front-end; the default value is TFILTER_NULL.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034720\"></A><EM CLASS=\"codeword\">\nup_syncfilter_id</EM>\n specifies the synchronization filter to apply to upstream packets; the default value is SFILTER_WAITFORALL.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034722\"></A><EM CLASS=\"codeword\">\ndown_transfilter_id</EM>\n allows the user to specify a filter to apply to downstream data flows; the default value is TFILTER_NULL.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034724\"></A>Stream * Network::new_Stream(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039027\"></A>\tCommunicator * comm, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034902\"></A>\tstd::string us_filters, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034906\"></A>\tstd::string sync_filters, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034910\"></A>\tstd::string ds_filters );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034733\"></A>This version of <EM CLASS=\"codeword\">\nNetwork::new_Stream</EM>\n is used to creae a heterogeneous Stream object. Users specify where packet filters are placed within the tree. Like the homogenous version of <EM CLASS=\"codeword\">\nNetwork::new_Stream</EM>\n, the end-points are specified by the <EM CLASS=\"codeword\">\ncomm</EM>\n argument.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034735\"></A>Strings are used to specify the filter placements, with the following syntax: &quot;filter_id =&gt; rank; [filter_id =&gt; rank; ...]&quot;. If &quot;*&quot; is specified as the rank for an assignment, the filter will be assigned to all ranks that have not already been assigned. If a rank within <EM CLASS=\"codeword\">\ncomm</EM>\n is not assigned a filter, it will use the default filter. See <EM CLASS=\"codeword\">\n$MRNET_ROOT/Examples/HeterogeneousFilters</EM>\n for an example of using <EM CLASS=\"codeword\">\nNetwork::new_Stream</EM>\n to specify different filter types to be used within the same stream.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034737\"></A><EM CLASS=\"codeword\">\nus_filters</EM>\n specifies the transformation filters to apply to data flowing upstream from the application back-ends toward the front-end.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034739\"></A><EM CLASS=\"codeword\">\nsync_filters </EM>\nspecifies the synchronization filters to apply to upstream packets.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034741\"></A><EM CLASS=\"codeword\">\nds_filters</EM>\n allows the user to specify filters to apply to downstream data flows.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034743\"></A>Note that more than one filter should not be assigned to a single rank in any of these strings.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034745\"></A>Stream * Network::get_Stream( unsigned int id );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034748\"></A>Returns a pointer to the Stream identified by <EM CLASS=\"codeword\">\nid</EM>\n, or NULL on failure. Back-ends may pass their local rank as the <EM CLASS=\"codeword\">\nid</EM>\n to retrieve a singlecast stream that can be used for non-filtered communication directly with the front-end.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034750\"></A>unsigned int Stream::get_Id( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034752\"></A>Returns the integer identifier for this Stream. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034754\"></A>const std::set&lt; Rank &gt; &amp; Stream::get_EndPoints( );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034756\"></A>Returns the set of end-point ranks for this Stream. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034758\"></A>unsigned int Stream::size( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034760\"></A>Returns an integer indicating the number of end-points for this Stream. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053926\"></A>bool Stream::is_Closed( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053924\"></A>When used by back-ends, this method returns true if the front-end has closed this Stream by deleting the corresponding object, false otherwise. On the front-end, this method can be used to determine if the stream has been disabled due to a non-recoverable failure (e.g., a back-end process has died or a sub-tree containing stream end-points has become unreachable).</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053871\"></A>int Stream::send( int tag, const char * format_string, ... );\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053877\"></A>int Stream::send( const char * format_string, va_list list, int tag );\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053896\"></A>int Stream::send( int tag, const void** data, const char * format_string );\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053882\"></A>int Stream::send( PacketPtr &amp; pkt );\t</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053863\"></A>Invokes a data send operation on the calling Stream. The first three interfaces construct a packet from the passed operands, while the fourth allows for sending an already constructed packet. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053904\"></A><EM CLASS=\"codeword\">\ntag</EM>\n is an integer that identifies the data in the packet. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053905\"></A><EM CLASS=\"codeword\">\nformat_string</EM>\n is a format string describing the data in the packet (See <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> for a full description).</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053907\"></A><EM CLASS=\"codeword\">\ndata</EM>\n is an array of pointers to individual data items; the format string indicates the type of data pointed to by each array index.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053906\"></A>On success, <EM CLASS=\"codeword\">\nStream::send</EM>\n returns 0; on failure -1.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034998\"></A>NOTE: <EM CLASS=\"codeword\">\ntag</EM>\n must have a value greather than or equal to the constant <EM CLASS=\"codeword\">\nFirstApplicationTag </EM>\ndefined by MRNet (<EM CLASS=\"codeword\">\n#include &quot;mrnet/Types.h&quot;</EM>\n). Tag values less than <EM CLASS=\"codeword\">\nFirstApplicationTag</EM>\n are reserved for internal MRNet use.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053175\"></A>int Stream::flush();</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053172\"></A>Commits a flush of all packets currently buffered by this Stream. A successful return value of 0 indicates that all buffered packets have been passed to the operating system for network transmission. A return value of -1 indicates that the stream has experienced a terminal failure, and further attempts to send or receive data on the stream will fail. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034772\"></A>int Stream::recv( int * tag, PacketPtr &amp; packet, bool blocking = true );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034779\"></A>Invokes a stream receive operation. Packets received by the calling Stream will be returned by this method, one-at-a-time, in FIFO order.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034781\"></A><EM CLASS=\"codeword\">\ntag</EM>\n will be filled in with the integer tag value that was passed by the corresponding <EM CLASS=\"codeword\">\nStream::send</EM>\n operation. packet is set to point to the received packet.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034783\"></A><EM CLASS=\"codeword\">\nblocking</EM>\n determines whether the receive should block or return if data is not immediately available; it defaults to a blocking call.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034785\"></A>A return value of -1 indicates that the stream has experienced a terminal failure, and further attempts to send or receive data on the stream will fail. A return value of 0 indicates no packets were available for a non-blocking receive, or the stream has been closed. The return value 1 indicates a packet has been received successfully. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053147\"></A>int Stream::get_DataNotificationFd( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053148\"></A><EM CLASS=\"codeword\">\nStream::get_DataNotificationFd</EM>\n returns a file descriptor that can be used with select or poll to receive notification that data has arrived for a stream.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053215\"></A>When the file descriptor has data available (for reading), you should call <EM CLASS=\"codeword\">\nStream::clear_DataNotificationFd</EM>\n before taking action on the notification. When notifications are no longer needed, use <EM CLASS=\"codeword\">\nStream::close_DataNotificationFd</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053150\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053151\"></A>void Stream::clear_DataNotificationFd( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053220\"></A>This method resets the data notification file descriptor returned from <EM CLASS=\"codeword\">\nStream::get_DataNotificationFd</EM>\n. </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053152\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053153\"></A>void Stream::close_DataNotificationFd( ); </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053225\"></A>This method closes the data notification file descriptor returned from <EM CLASS=\"codeword\">\nStream::get_DataNotificationFd</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037189\"></A>NOTE: this functionality is not available on Windows platforms.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053145\"></A>int Stream::set_FilterParameters( </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039042\"></A>\tFilterType ftype, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039049\"></A>\tconst char *format_str, ... ) const;</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034797\"></A><EM CLASS=\"codeword\">\nStream::set_FilterParameters</EM>\n allows users to dynamically configure the operation of a stream transformation filter by passing arbitrary data in a similar fashion to <EM CLASS=\"codeword\">\nStream::send</EM>\n. When the filter executes, the passed data is available as a PacketPtr parameter to the filter, and the filter can extract the configuration settings.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037208\"></A>ftype should be given as FILTER_UPSTREAM_SYNC to configure the synchronization filter, FILTER_UPSTREAM_TRANS for upstream transformation filter and FILTER_DOWNSTREAM_TRANS for downstream transformation filter.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037215\"></A>int Stream::set_FilterParameters( </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039046\"></A>\tconst char *format_str, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039047\"></A>\tva_list params, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039048\"></A>\tFilterType ftype ) const;</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037213\"></A>This method is the same as the previous method except for the filter configuration parameters are given in the va_list form.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034801\"></A>bool Stream::enable_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039056\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035079\"></A>\tperfdata_context_t context );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034806\"></A><EM CLASS=\"codeword\">\nStream::enable_PerformanceData</EM>\n starts recording performance data for the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n. Returns true on success, false otherwise. <A HREF=\"mrnet_4.1.0.htm#50520069_16750\" CLASS=\"XRef\">See MRNet Stream Performance Data</A> describes the metric and context types. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034808\"></A>bool Stream::disable_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039060\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035096\"></A>\tperfdata_context_t context );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034813\"></A><EM CLASS=\"codeword\">\nStream::disable_PerformanceData</EM>\n stops recording performance data for the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n. Previously recorded data is not discarded, so that it can be retrieved with <EM CLASS=\"codeword\">\nStream::collect_PerformanceData</EM>\n. Users can enable/disable recording for a particular <EM CLASS=\"codeword\">\nmetric</EM>\n and <EM CLASS=\"codeword\">\ncontext</EM>\n any number of times before collecting the results. Returns true on success, false otherwise. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034815\"></A>bool Stream::collect_PerformanceData(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039067\"></A>\trank_perfdata_map &amp; results,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035111\"></A>\tperfdata_metric_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035114\"></A>\tperfdata_context_t context,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035806\"></A>\tint aggr_filter_id = TFILTER_ARRAY_CONCAT );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034824\"></A><EM CLASS=\"codeword\">\nStream::collect_PerformanceData</EM>\n collects the recorded performance data for the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n. The collected data is returned in a <EM CLASS=\"codeword\">\nrank_perfdata_map</EM>\n, which associates individual node ranks to a <EM CLASS=\"codeword\">\nstd::vector&lt; perf_data_t &gt;</EM>\n containing the recorded data instances. After collection, the recorded data at each nodeis discarded. Returns true on success, false otherwise.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034826\"></A>Users can aggregate the recorded data across nodes by specifying a transformation filter with <EM CLASS=\"codeword\">\naggr_filter_id</EM>\n. Note that only the built-in filter types of TFILTER_SUM, TFILTER_MIN, TFILTER_MAX, TFILTER_AVG, and TFILTER_ARRAY_CONCAT are supported. By default, performance data from each node is concatenated, and results contains every recorded data instance for each node. If the summary aggregation filters are used, results will contain a single associated pair. The rank for this pair is equal to -1&#8734;(number of aggregated ranks), and the vector contains one or more aggregated instances. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1034828\"></A>void Stream::print_PerformanceData(\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039071\"></A>\tperfdata_context_t metric,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035140\"></A>\tperfdata_context_t context );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1034704\"></A><EM CLASS=\"codeword\">\nStream::print_PerformanceData</EM>\n prints recorded performance data of the specified <EM CLASS=\"codeword\">\nmetric</EM>\n type for the given <EM CLASS=\"codeword\">\ncontext</EM>\n. At each rank, the data is printed to the MRNet log files and then discarded. </P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031397\"></A>Class Packet</H5>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1055753\"></A>A Packet encapsulates a set of formatted data elements sent on a stream. Packets are created using a format string (e.g., &quot;<EM CLASS=\"codeword\">\n%s %d</EM>\n&quot; describes a null-terminated string followed by a 32-bit integer, and the packet is said to contain two data elements). MRNet front-end and back-end processes typically do not create Packet instances, as they are automatically produced from the formatted data passed to <EM CLASS=\"codeword\">\nStream::send</EM>\n or <EM CLASS=\"codeword\">\nNetwork::send</EM>\n. Each Packet is allocated using malloc of the C standard library, and therefore has the same byte alignment guarantees. <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> contains the full listing of data types that can be sent in a Packet.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1035148\"></A>When receiving a packet via <EM CLASS=\"codeword\">\nStream::recv</EM>\n, <EM CLASS=\"codeword\">\nNetwork::recv</EM>\n, or in a filter's input vector, the Packet instance is stored within a PacketPtr object. PacketPtr is a class based on the Boost shared_ptr class, and helps with memory management of packets. A PacketPtr can be assumed to be equivalent to &quot;Packet *&quot;, and all operations on packets require use of PacketPtr. Packets can be created explicitly using the constructors shown below, using the following method to instantiate a PacketPtr.</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1054305\"></A>PacketPtr new_pkt( new Packet(...) );</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036800\"></A>The corresponding lightweight backend API class is <A HREF=\"mrnet_4.1.0.htm#50520069_29869\" CLASS=\"XRef\">See Class Packet</A>.</P>\n<UL>\n<LI CLASS=\"pp\">\n<A NAME=\"50520069_pgfId-1055598\"></A>&nbsp;</LI>\n</UL>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054329\"></A>Packet::Packet( \t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054330\"></A>\tunsigned int stream_id,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054335\"></A>\tint tag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054341\"></A>\tconst char* format_str, ... );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054312\"></A>Constructs a Packet that can be sent on the stream with the given stream_id. The packet is associated with a tag that can be used by receivers to identify the contents. <EM CLASS=\"codeword\">\nformat_str</EM>\n is a format string describing the data elements in the packet. The variable arguments following <EM CLASS=\"codeword\">\nformat_str</EM>\n should have the appropriate types for each data element. Note that for array data elements, an extra argument must be passed to hold each array's length. (See <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> for a full description.)</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054384\"></A>Packet::Packet( </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054385\"></A>\tconst char* format_str,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054396\"></A>\tva_list data_elems,\t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054397\"></A>\tunsigned int stream_id,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054316\"></A>\tint tag );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054445\"></A>Works the same as the first Packet constructor, but allows for passing a <EM CLASS=\"codeword\">\nva_list</EM>\n in place of the variable arguments. This constructor is useful for libraries built on top of MRNet that allow users to specify packet format strings.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054446\"></A>Packet::Packet( </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054462\"></A>\tunsigned int stream_id,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054463\"></A>\tint tag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054468\"></A>\tconst void** data_elems,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054449\"></A>\tconst char* format_str );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054317\"></A>Works the same as the first Packet constructor, but allows for passing an array of data element pointers instead of the variable arguments. The <EM CLASS=\"codeword\">\ndata_elems</EM>\n array must contain the same number of elements as indicated by <EM CLASS=\"codeword\">\nformat_str</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035150\"></A>int Packet::get_Tag( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035152\"></A>Returns the integer tag associated with this Packet. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054081\"></A>void Packet::set_Tag( int tag );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035154\"></A>Sets the integer tag associated with this Packet.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054090\"></A>unsigned int Packet::get_StreamId( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035156\"></A>Returns the stream id associated with this Packet. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054028\"></A>void Packet::set_StreamId( unsigned int strm_id );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054029\"></A>Sets the stream id associated with this Packet to strm_id. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035158\"></A>const char * Packet::get_FormatString( );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054058\"></A>Returns the character string specifying the data format of this Packet. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054067\"></A>int Packet::unpack( const char * format_str, ... );\t \t</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054062\"></A>int Packet::unpack( va_list list, const char * format_str, bool );\t</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054063\"></A>Extracts data contained within this Packet according to the <EM CLASS=\"codeword\">\nformat_str</EM>\n, which must match that of the packet. <EM CLASS=\"codeword\">\nformat_str</EM>\n is a format string describing the data in the packet (See <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> for a full description).</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054076\"></A>For the first version, the function arguments following <EM CLASS=\"codeword\">\nformat_str</EM>\n should be pointers to the appropriate types of each data item. For string and array data types, new memory buffers to hold the data will be allocated using <EM CLASS=\"codeword\">\nmalloc</EM>\n, and it is the user's responsibility to free these strings and arrays. Note that for array data elements, an extra argument must be passed to hold each array's length.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054077\"></A>For the second version, the va_list list should contain the arguments corresponding to the varargs from the first version. The third parameter is a dummy parameter required by some compilers to distinguish the second version from the first version, and its value is ignored.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053748\"></A>The return value 0 indicates success; -1 indicates the format string supplied did not match the packet or a failure in unpacking.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053800\"></A>void Packet::set_Tag( int tag );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053801\"></A>This method can be used to set the packet's tag value after it has been created. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053805\"></A>void Packet::set_Destinations( const Rank * bes, unsigned int num_bes );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053806\"></A>This method can be used to tell MRNet to deliver the packet to a specific set of back-ends, rather than all the back-ends addressed by the stream on which the packet is sent. bes should point to an array of back-end ranks, and num_bes is the number of entries in the array.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035168\"></A>void Packet::set_DestroyData( bool destroy );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035251\"></A>This method can be used to tell MRNet whether or not to deallocate the string and array data members of a Packet. If <EM CLASS=\"codeword\">\ndestroy</EM>\n is true, string and array data members will be deallocated using free when the Packet destructor is executed - this assumes they were allocated using <EM CLASS=\"codeword\">\nmalloc</EM>\n. The default behavior for user-generated packets is not to deallocate (false). Turning on deallocation is useful in filter code that must allocate strings or arrays for output packets, which cannot be freed before the filter function returns. </P>\n</DIV>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1035253\"></A><A NAME=\"50520069_42905\"></A>C API Reference</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1036748\"></A>In the MRNet lightweight back-end library, the MRNet C++ classes are mimicked for ease of use. With the exception of constructors/destructors, API calls in standard MRNet can be translated to their lightweight versions according to the following pattern:</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035263\"></A>return_type class::function_name( param1_type param1, ...);\t </P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1035267\"></A>translates to:</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035268\"></A>return_type class_function_name(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039080\"></A>\tclass class_object,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035297\"></A>\tparam1_type param1, ...);\t </P>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031398\"></A><A NAME=\"50520069_53570\"></A>Class Network</H5>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035304\"></A>Network_t * Network_CreateNetworkBE( int argc, char ** argv );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035309\"></A>The back-end constructor method. MRNet automatically passes the necessary information to the back-end process using the program argument vector (<EM CLASS=\"codeword\">\nargc/argv</EM>\n) by inserting it after the user specified arguments. See <A HREF=\"mrnet_4.1.0.htm#50520069_10810\" CLASS=\"XRef\">See Network * Network::CreateNetworkBE( int argc, char ** argv );</A> for more information on the required arguments.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037291\"></A>void delete_Network_t( Network_t * network );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037292\"></A><EM CLASS=\"codeword\">\ndelete_Network_t</EM>\n acts as a destructor for the Network_t object and cleans up internal structures before freeing the Network_t pointer.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037318\"></A>void Network_waitfor_ShutDown( Network_t * network );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037319\"></A><EM CLASS=\"codeword\">\nNetwork_waitfor_ShutDown</EM>\n blocks until the network has been shut down.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037320\"></A>char Network_is_ShutDown( Network_t * network );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037322\"></A>Returns true if the network has been shut down.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037304\"></A>char* Network_get_LocalHostName( Network_t * network );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035319\"></A><EM CLASS=\"codeword\">\nNetwork_get_LocalHostName</EM>\n returns the name of the host where the process is running. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035321\"></A>Port Network_get_LocalPort( Network_t * network );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035324\"></A><EM CLASS=\"codeword\">\nNetwork_get_LocalPort</EM>\n returns the listening port of the local process. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035326\"></A>Rank Network_get_LocalRank( Network_t * network );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035329\"></A><EM CLASS=\"codeword\">\nNetwork_get_LocalRank</EM>\n returns the rank of the local process. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035331\"></A>int Network_recv(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039088\"></A>\tNetwork_t * network,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035559\"></A>\tint otag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035563\"></A>\tPacket_t * packet,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035567\"></A>\tStream_t * stream );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035340\"></A><EM CLASS=\"codeword\">\nNetwork_recv</EM>\n is used to invoke a blocking stream-anonymous receive operation. Any packet available (i.e., addressed to any stream) will be returned in roughly FIFO order.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035342\"></A><EM CLASS=\"codeword\">\notag</EM>\n will be filled in with the integer tag value that was passed by the corresponding <EM CLASS=\"codeword\">\nStream_send</EM>\n operation. <EM CLASS=\"codeword\">\npacket</EM>\n is the packet that was received. A pointer to the Stream_t to which the packet was addressed will be returned in <EM CLASS=\"codeword\">\nstream</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035302\"></A>A return value of -1 indicates an error and 1 indictes a success.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054225\"></A>int Network_recv_nonblock(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054226\"></A>\tNetwork_t * network,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054227\"></A>\tint otag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054228\"></A>\tPacket_t * packet,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054229\"></A>\tStream_t * stream );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054230\"></A><EM CLASS=\"codeword\">\nNetwork_recv_nonblock</EM>\n is used to invoke a non-blocking stream-anonymous receive operation. Any packet available (i.e., addressed to any stream) will be returned in roughly FIFO order.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054231\"></A><EM CLASS=\"codeword\">\notag</EM>\n will be filled in with the integer tag value that was passed by the corresponding <EM CLASS=\"codeword\">\nStream_send</EM>\n operation. <EM CLASS=\"codeword\">\npacket</EM>\n is the packet that was received. A pointer to the Stream_t to which the packet was addressed will be returned in <EM CLASS=\"codeword\">\nstream</EM>\n.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054232\"></A>A return value of -1 indicates an error, 0 indicates no packets were available, and 1 indicates a success. </P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031399\"></A><A NAME=\"50520069_84145\"></A>Class NetworkTopology</H5>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035360\"></A>NetworkTopology_t * Network_get_NetworkTopology( Network_t * network );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035363\"></A>Network_get_NetworkTopology is used to retrieve a pointer to the underlying NetworkTopology_t instance within <EM CLASS=\"codeword\">\nnetwork</EM>\n. Note that in the lightweight back-end library, the information available in the NetworkTopology_t may be a subset of the full topology.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035365\"></A>Node_t * NetworkTopology_find_Node(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039092\"></A>\tNetworkTopology_t * net_top, \t </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035605\"></A>\tRank node_rank );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035370\"></A>This method returns a pointer to the topology node with rank equal to <EM CLASS=\"codeword\">\nnode_rank</EM>\n, or NULL if no match is found. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035372\"></A>Node_t * NetworkTopology_get_Root( NetworkTopology_t * net_top );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035375\"></A>This method returns a pointer to the root node of the tree, or NULL if not found. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035377\"></A>char * NetworkTopology_Node_get_HostName( Node_t * node );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035380\"></A>This method returns a string identifying the hostname of the <EM CLASS=\"codeword\">\nnode</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035382\"></A>Port NetworkTopology_Node_get_Port( Node_t * node );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035385\"></A>This method returns the listening port of the <EM CLASS=\"codeword\">\nnode</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035387\"></A>Rank NetworkTopology_Node_get_Rank( Node_t * node );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035390\"></A>This method returns the rank of the <EM CLASS=\"codeword\">\nnode</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035392\"></A>Rank NetworkTopology_Node_get_Parent( Node_t * node );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035357\"></A>This method returns the rank of the node's parent. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035662\"></A>unsigned int NetworkTopology_Node_find_SubTreeHeight( Node_t * node );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035494\"></A>This method returns the height of the sub-tree rooted at the <EM CLASS=\"codeword\">\nnode</EM>\n.</P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031400\"></A><A NAME=\"50520069_62834\"></A>Class Stream</H5>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037340\"></A>Stream_t * Network_get_Stream( Network_t * network, unsigned int id );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035410\"></A><EM CLASS=\"codeword\">\nNetwork_get_Stream</EM>\n returns a pointer to a Stream_t identified by <EM CLASS=\"codeword\">\nid</EM>\n, or NULL on failure. Back-ends may pass their local rank as the <EM CLASS=\"codeword\">\nid</EM>\n to retrieve a singlecast stream that can be used for non-filtered communication directly with the front-end.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1053753\"></A>void delete_Stream_t( Stream_t * stream );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053754\"></A><EM CLASS=\"codeword\">\ndelete_Stream_t</EM>\n acts as a destructor for the Stream_t object and cleans up internal structures before freeing the Stream_t pointer.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035412\"></A>unsigned int Stream_get_Id( Stream_t * stream );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035415\"></A>This method returns the integer identifier for this Stream_t. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035417\"></A>int Stream_send(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039098\"></A>\tStream_t * stream, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035697\"></A>\tint tag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035701\"></A>\tconst char * format_string, ... );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1051335\"></A>This method sends data on <EM CLASS=\"codeword\">\nstream</EM>\n. <EM CLASS=\"codeword\">\ntag</EM>\n is an integer that identifies the data to be sent by the stream. <EM CLASS=\"codeword\">\nformat_string</EM>\n is a format string describing the types of the data elements (see <A HREF=\"mrnet_4.1.0.htm#50520069_40816\" CLASS=\"XRef\">See Format Strings</A> for a full description.) On success, <EM CLASS=\"codeword\">\nStream_send</EM>\n returns 0; on failure, -1.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035426\"></A>NOTE: <EM CLASS=\"codeword\">\ntag</EM>\n must have a value greater than or equal to the constant <EM CLASS=\"codeword\">\nFirstApplicationTag</EM>\n defined by MRNet (<EM CLASS=\"codeword\">\n#include &quot;mrnet_lightweight/Types.h&quot;</EM>\n). Tag values less than <EM CLASS=\"codeword\">\nFirstApplicationTag</EM>\n are reserved for internal MRNet use.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054193\"></A>int Stream_send_packet(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054194\"></A>\tStream_t * stream, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054196\"></A>\tPacket_t * packet );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054197\"></A>This method sends packet on <EM CLASS=\"codeword\">\nstream</EM>\n. On success, <EM CLASS=\"codeword\">\nStream_send</EM>\n_packet returns 0; on failure, -1.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1051319\"></A>int Stream_flush( Stream_t * stream );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1051320\"></A>This operation is currently not required in lightweight MRNet, as <EM CLASS=\"codeword\">\nStream_send</EM>\n will deliver the data for network transmission. This method will always return the value 0 for success.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037239\"></A>int Stream_recv(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039614\"></A>\tStream_t * stream,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037258\"></A>\tint * tag,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054238\"></A>\tPacket_t * packet,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1037259\"></A>\tbool_t blocking );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053762\"></A><EM CLASS=\"codeword\">\nStream_recv</EM>\n invokes a stream-specific receive operation. Packets addressed to the passed <EM CLASS=\"codeword\">\nstream</EM>\n will be returned, one-at-a-time, in FIFO order. If blocking is true, the operation will block until a packet is available for this stream; if false, the operation will return immediately.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037264\"></A><EM CLASS=\"codeword\">\ntag</EM>\n will be filled in with the integer tag value that was passed by the corresponding <EM CLASS=\"codeword\">\nStream::send</EM>\n operation. <EM CLASS=\"codeword\">\npacket</EM>\n is the received Packet_t.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1037270\"></A>A return value of -1 indicates an error, 0 indicates no packet available for a non-blocking receieve, and 1 indicates a packet was found.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054247\"></A>char Stream_is_Closed( Stream_t * stream );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054248\"></A>This method returns the value 1 if the stream has been closed by the front-end, 0 otherwise.</P>\n</DIV>\n<DIV>\n<H5 CLASS=\"nh3\">\n<A NAME=\"50520069_pgfId-1031401\"></A><A NAME=\"50520069_29869\"></A>Class Packet</H5>\n<UL>\n<LI CLASS=\"pp\">\n<A NAME=\"50520069_pgfId-1035447\"></A>When receiving a packet, it is stored within a Packet_t object. Note that standard MRNet makes use of the PacketPtr object, which is based on the Boost library shared_ptr class. However, in the lightweight back-end library, pointers to Packet_t objects are used instead.</LI>\n</UL>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035449\"></A>int Packet_get_Tag( Packet_t * packet );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035452\"></A>This method returns the integer tag associated with <EM CLASS=\"codeword\">\npacket</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054153\"></A>void Packet_set_Tag( Packet_t * packet, int tag );</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054154\"></A>This method sets the integer tag associated with <EM CLASS=\"codeword\">\npacket</EM>\n. </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035454\"></A>unsigned int Packet_get_StreamId( Packet_t * packet );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035457\"></A>This method returns the stream id associated with<EM CLASS=\"codeword\">\n packet</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054159\"></A>void Packet_set_StreamId( Packet_t * packet, unsigned int strm_id );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054160\"></A>This method sets the stream id associated with<EM CLASS=\"codeword\">\n packet</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035459\"></A>char* Packet_get_FormatString( Packet_t * packet );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035462\"></A>This method returns the character string specifying the data format of <EM CLASS=\"codeword\">\npacket</EM>\n.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035464\"></A>void Packet_unpack(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1039618\"></A>\tPacket_t * packet,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1035768\"></A>\tconst char * format_string, ... );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1053768\"></A>This method extracts data elements contained within <EM CLASS=\"codeword\">\npacket</EM>\n according to the <EM CLASS=\"codeword\">\nformat_string</EM>\n, which must match that of <EM CLASS=\"codeword\">\npacket</EM>\n. The function arguments following <EM CLASS=\"codeword\">\nformat_string</EM>\n should be pointers to the appropriate types of each data element. For string and array data types, new memory buffers to hold the data will be allocated using <EM CLASS=\"codeword\">\nmalloc</EM>\n, and it is the user's responsibility to free these strings and arrays. Note that for array data elements, an extra argument must be passed to hold each array's length.</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1035439\"></A>The return value 0 indicates success; -1 indicates the format string supplied did not match the packet or a failure in unpacking.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054166\"></A>void Packet_unpack_valist(</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054167\"></A>\tPacket_t * packet,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054175\"></A>\tva_list arg_list,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1054179\"></A>\tconst char * format_string );\t </P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054183\"></A>This method extracts data elements contained within <EM CLASS=\"codeword\">\npacket</EM>\n according to the <EM CLASS=\"codeword\">\nformat_string</EM>\n, which must match that of <EM CLASS=\"codeword\">\npacket</EM>\n. The function arguments contained in the va_list arg_list should be pointers to the appropriate types of each data element. For string and array data types, new memory buffers to hold the data will be allocated using <EM CLASS=\"codeword\">\nmalloc</EM>\n, and it is the user's responsibility to free these strings and arrays. Note that for array data elements, an extra argument must be passed to hold each array's length. The fourth parameter</P>\n<P CLASS=\"api-desc\">\n<A NAME=\"50520069_pgfId-1054184\"></A>The return value 0 indicates success; -1 indicates the format string supplied did not match the packet or a failure in unpacking.</P>\n</DIV>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1031405\"></A>Building and Testing MRNet</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031416\"></A>For this discussion, <EM CLASS=\"codeword\">\n$MRNET_ROOT</EM>\n is the location of the top-level directory of the MRNet distribution and <EM CLASS=\"codeword\">\n$MRNET_ARCH</EM>\n is a string describing the platform (OS and architecture) as discovered by the configure process.</P>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031427\"></A>Supported Platforms and Compilers</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031430\"></A>MRNet has been developed to be highly portable; we expect it to run properly on all common Unix-based as well as Windows platforms. Please refer to the README document included with the MRNet distribution for the list of currently supported platforms. </P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1055359\"></A>MRNet requires GNU make for building on Unix/Linux systems. Our build system attempts to use native system compilers where available. For building on Windows systems, Visual Studio 2010 solution/project files are available, as are pre-built libraries and binaries.</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031499\"></A>Configuration, Compilation, and Installation</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031549\"></A>Please refer to the INSTALL document included with the MRNet distribution for configuration, compilation, and installation instructions. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031535\"></A>Testing the Code</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031540\"></A>The shell script, <EM CLASS=\"codeword\">\nmrnet_tests.sh</EM>\n is placed in the build/installation directory for binaries along with the other executables. This script can be used to run the MRNet test programs and check their output for errors. The script is used as follows:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031542\"></A>UNIX&gt; mrnet_tests.sh { -l | -r hostfile | -a hostfile }</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048854\"></A>\t\t\t[ -f ] [ -lightweight ]</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031536\"></A>One of the <EM CLASS=\"codeword\">\n-l</EM>\n, <EM CLASS=\"codeword\">\n-r</EM>\n, or <EM CLASS=\"codeword\">\n-a</EM>\n flags is required. The <EM CLASS=\"codeword\">\n-l</EM>\n flag is used to run all tests using only topologies that create processes on the local machine (note: running the tests locally can take quite a while, up to 15 minutes depending on machine capabilities). The <EM CLASS=\"codeword\">\n-r</EM>\n flag runs tests using remote machines specified in the file whose name immediately follows this flag. To run tests both locally and remotely, use the <EM CLASS=\"codeword\">\n-a</EM>\n flag and provide a hostfile.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1054519\"></A>To test MRNet's ability to dynamically load shared libraries containing filter functions, you must specify the <EM CLASS=\"codeword\">\n-f</EM>\n flag. The <EM CLASS=\"codeword\">\n-lightweight</EM>\n flag is used to run the tests using lightweight back-ends in addition to the standard back-ends. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031510\"></A>Bugs, Questions, and Comments</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031513\"></A>MRNet is maintained by the Paradyn Tools Project at the University of Wisconsin-Madison. Comments and feedback whether positive or negative are encouraged; please send to mrnet@cs.wisc.edu. Bug fixes as patches are also welcome.</P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1031505\"></A><A NAME=\"50520069_58245\"></A>A Complete Example: Integer Addition</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1031758\"></A>The source code for the example contained in this appendix can be found in <EM CLASS=\"codeword\">\n$MRNET_ROOT/Examples/IntegerAddition</EM>\n. </P>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1044461\"></A>A Complete MRNet Front-End</H4>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031766\"></A>#include &quot;mrnet/MRNet.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031767\"></A>#include &quot;IntegerAddition.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031769\"></A>using namespace MRN;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031770\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031771\"></A>int main(int argc, char **argv)</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031772\"></A>{</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031773\"></A>\tint send_val=32, recv_val=0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031774\"></A>\tint tag, retval;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031775\"></A>\tPacketPtr p;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031777\"></A>\tif( argc != 4 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031778\"></A>\t\tprintf(&quot;Usage: %s topology be_exe so_file&#92;n&quot;, argv[0]);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031779\"></A>\t\texit(-1);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031780\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031781\"></A>\tconst char * topology_file = argv[1];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031782\"></A>\tconst char * be_exe = argv[2];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031783\"></A>\tconst char * so_file = argv[3];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1046837\"></A>\tconst char * argv=NULL;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031785\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031786\"></A>\t// Instantiates the MRNet internal nodes, using the organization</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031787\"></A>\t// in &quot;topology_file,&quot; and the specified back-end application</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031789\"></A>\tNetwork * network = Network::CreateNetworkFE( topology_file,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047261\"></A>\t\t\t\t\t\t\t\t be_exe, &amp;argv  );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031790\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031791\"></A>\t// Make sure path to &quot;so_file&quot; is in LD_LIBRARY_PATH</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031792\"></A>\tint filter_id = network-&gt;load_FilterFunc( so_file, &quot;IntegerAdd&quot; );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031793\"></A>\tif( filter_id == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031794\"></A>\t\tprintf( &quot;Network::load_FilterFunc() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031795\"></A>\t\tdelete network;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031796\"></A>\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031797\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031798\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031799\"></A>\t// A Broadcast communicator contains all the back-ends</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031800\"></A>\tCommunicator * comm_BC = network-&gt;get_BroadcastCommunicator( );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031801\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031802\"></A>\t// Create a stream that uses Integer_Add filter for aggregation</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031803\"></A>\tStream * stream = network-&gt;new_Stream( comm_BC, filter_id,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031804\"></A>\t\t\t\t\t\t\t SFILTER_WAITFORALL);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031806\"></A>\tint num_backends = comm_BC-&gt;get_EndPoints().size();</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047602\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047603\"></A>\t// Broadcast a control message to back-ends to send us &quot;num_iters&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031811\"></A>\t// waves of integers</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047607\"></A>\ttag = PROT_SUM;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047608\"></A>\tunsigned int num_iters=5;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031812\"></A>\tif( stream-&gt;send( tag, &quot;%d %d&quot;, send_val, num_iters ) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031813\"></A>\t\tprintf(&quot;stream::send() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031814\"></A>\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031815\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031816\"></A>\tif( stream-&gt;flush( ) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031817\"></A>\t\tprintf(&quot;stream::flush() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031818\"></A>\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031819\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031821\"></A>\t// We expect &quot;num_iters&quot; aggregated responses from all back-ends</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031822\"></A>\tfor( unsigned int i=0; i&lt;num_iters; i++ ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031823\"></A>\t\tretval = stream-&gt;recv(&amp;tag, p);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031825\"></A>\t\tif( retval == -1){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031826\"></A>\t\t\t//recv error</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031827\"></A>\t\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031828\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031830\"></A>\t\tif( p-&gt;unpack( &quot;%d&quot;, &amp;recv_val ) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031831\"></A>\t\t\tprintf(&quot;stream::unpack() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031832\"></A>\t\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031833\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031835\"></A>\t\tif( recv_val != num_backends * i * send_val ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031836\"></A>\t\t\tprintf(&quot;Iteration %d: Failure!&#92;n&quot;, i);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031838\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031839\"></A>\t\telse{</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031840\"></A>\t\t\tprintf(&quot;Iteration %d: Success! recv_val(%d) == %d&#92;n&quot;,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031841\"></A>\t\t\t\t i, recv_val, send_val*i*num_backends );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031842\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031843\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031844\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031845\"></A>\tif(stream-&gt;send(PROT_EXIT, &quot;&quot;) == -1){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031846\"></A>\t\tprintf(&quot;stream::send(exit) failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031847\"></A>\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031848\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031849\"></A>\tif(stream-&gt;flush() == -1){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031850\"></A>\t\tprintf(&quot;stream::flush() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031851\"></A>\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031852\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031854\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047247\"></A>\t// Network destruction will exit all processes</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031855\"></A>\tdelete network;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031857\"></A>\treturn 0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031858\"></A>}</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031764\"></A>A Complete MRNet Back-End</H4>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031882\"></A>#include &quot;mrnet/MRNet.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031883\"></A>#include &quot;IntegerAddition.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031884\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031885\"></A>using namespace MRN;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031886\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031887\"></A>int main(int argc, char **argv)</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031888\"></A>{</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031889\"></A>\tStream * stream=NULL;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031890\"></A>\tPacketPtr p;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031891\"></A>\tint tag=0, recv_val=0, num_iters=0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031893\"></A>\tNetwork * network = Network::CreateNetworkBE( argc, argv );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031895\"></A>\tdo {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047290\"></A>\t\tif ( network-&gt;recv(&amp;tag, p, &amp;stream) != 1){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031897\"></A>\t\t\tfprintf(stderr, &quot;stream::recv() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031898\"></A>\t\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031899\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031901\"></A>\t\tswitch(tag){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031902\"></A>\t\tcase PROT_SUM:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031903\"></A>\t\t\tp-&gt;unpack( &quot;%d %d&quot;, &amp;recv_val, &amp;num_iters );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031904\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031905\"></A>\t\t\t// Send num_iters waves of integers</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031906\"></A>\t\t\tfor( unsigned int i=0; i&lt;num_iters; i++ ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031907\"></A>\t\t\t\tif( stream-&gt;send(tag, &quot;%d&quot;, recv_val*i) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031908\"></A>\t\t\t\t\tprintf(&quot;stream::send(%%d) failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031909\"></A>\t\t\t\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031910\"></A>\t\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031911\"></A>\t\t\t\tif( stream-&gt;flush( ) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031912\"></A>\t\t\t\t\tprintf(&quot;stream::flush() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031913\"></A>\t\t\t\t\treturn -1;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031914\"></A>\t\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031915\"></A>\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031916\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031918\"></A>\t\tcase PROT_EXIT:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031919\"></A>\t\t\tprintf(&quot;Processing PROT_EXIT ...&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031920\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031922\"></A>\t\tdefault:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031923\"></A>\t\t\tprintf(&quot;Unknown Protocol: %d&#92;n&quot;, tag);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031924\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031925\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031926\"></A>\t} while ( tag != PROT_EXIT );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1039635\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1039629\"></A>\tnetwork-&gt;waitfor_ShutDown();</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1039639\"></A>\tdelete network;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1039636\"></A>\treturn 0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031929\"></A>}</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031877\"></A>A Complete MRNet Lightweight Back-End</H4>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031945\"></A>#include &quot;mrnet_lightweight/MRNet.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031946\"></A>#include &quot;IntegerAddition_lightweight.h&quot;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037002\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031947\"></A>int main(int argc, char **argv)</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031948\"></A>{</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031949\"></A>\tStream_t * stream;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031951\"></A>\tPacket_t* p = (Packet_t*)malloc(sizeof(Packet_t));</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031953\"></A>\tint tag=0, recv_val=0, num_iters=0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031955\"></A>\tNetwork_t * net = Network_CreateNetworkBE( argc, argv );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031958\"></A>\tdo {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031959\"></A>\t\tif( Network_recv(net, &amp;tag, p, &amp;stream) != 1 ) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031960\"></A>\t\t\tprintf(&quot;BE: stream::recv() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047695\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031962\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031964\"></A>\t\tswitch(tag) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031966\"></A>\t\tcase PROT_SUM:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031967\"></A>\t\t\tPacket_unpack(p, &quot;%d %d&quot;, &amp;recv_val, &amp;num_iters );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031969\"></A>\t\t\t// Send num_iters waves of integers</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031970\"></A>\t\t\tunsigned int i;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031971\"></A>\t\t\tfor( i=0; i&lt;num_iters; i++ ) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031972\"></A>\t\t\t\tprintf(&quot;BE: Sending wave %u ...&#92;n&quot;, i);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031973\"></A>\t\t\t\tif( Stream_send(stream,tag, &quot;%d&quot;, </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047796\"></A>\t\t\t\t\t\t\trecv_val*i) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031974\"></A>\t\t\t\t\tprintf(&quot;BE: stream::send(%%d) failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031975\"></A>\t\t\t\t\ttag = PROT_EXIT;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031976\"></A>\t\t\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031977\"></A>\t\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031978\"></A>\t\t\t\tif( Stream_flush(stream ) == -1 ){</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031979\"></A>\t\t\t\t\tprintf(&quot;BE: stream::flush() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031980\"></A>\t\t\t\t\ttag = PROT_EXIT;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1047945\"></A>\t\t\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031982\"></A>\t\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031984\"></A>\t\t\t\tsleep(2); // stagger sends</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031985\"></A>\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031986\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031988\"></A>\t\tcase PROT_EXIT:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1039655\"></A>\t\t\tif( Stream_send(stream,tag, &quot;%d&quot;, 0) == -1 ) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031990\"></A>\t\t\t\tprintf(&quot;BE: stream::send(%%s) failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031991\"></A>\t\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031992\"></A>\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031993\"></A>\t\t\tif( Stream_flush(stream ) == -1 ) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031994\"></A>\t\t\t\tprintf(&quot;BE: stream::flush() failure&#92;n&quot;);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031995\"></A>\t\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031996\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031997\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031998\"></A>\t\tdefault:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1031999\"></A>\t\t\tfprintf(stderr, &quot;BE: Unknown Protocol: %d&#92;n&quot;, tag);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032000\"></A>\t\t\ttag = PROT_EXIT;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032001\"></A>\t\t\tbreak;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032002\"></A>\t\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032006\"></A>\t} while ( tag != PROT_EXIT );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037377\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037387\"></A>\tif ( p != NULL )</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037378\"></A>\t\tfree (p);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037379\"></A>\t</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037380\"></A>\tNetwork_waitfor_ShutDown(net);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1037381\"></A>\tdelete_Network_t(net);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032012\"></A>\treturn 0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032013\"></A>}</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1031878\"></A>A MRNet Filter: Integer Addition</H4>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032030\"></A>extern &quot;C&quot; {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032031\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032032\"></A>//Must declare the format of data expected by the filter</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032033\"></A>const char * IntegerAdd_format_string = &quot;%d&quot;; </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032034\"></A>void IntegerAdd( std::vector&lt; PacketPtr &gt; &amp; packets_in,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032035\"></A>\t\t\tstd::vector&lt; PacketPtr &gt; &amp; packets_out,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032036\"></A>\t\t\tstd::vector&lt; PacketPtr &gt; &amp; /* packets_out_reverse */,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032037\"></A>\t\t\tvoid ** /* filter state */,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032038\"></A>\t\t\tPacketPtr &amp; /* configuration parameters */,</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1040712\"></A>\t\t\tTopologyLocalInfo &amp; /* local topology information */)</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032039\"></A>{</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032040\"></A>\tint sum = 0;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032041\"></A>    </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032042\"></A>\tfor( unsigned int i = 0; i &lt; packets_in.size( ); i++ ) {</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032043\"></A>\t\tPacketPtr cur_packet = packets_in[i];</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032044\"></A>\t\tint val;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032045\"></A>\t\tcur_packet-&gt;unpack(&quot;%d&quot;, &amp;val);</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032046\"></A>\t\tsum += val;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032047\"></A>\t}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032048\"></A>    </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032049\"></A>\tPacketPtr new_packet ( new Packet(packets_in[0]-&gt;get_StreamId(),</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032050\"></A>\t\t\t\t\tpackets_in[0]-&gt;get_Tag(), &quot;%d&quot;, sum ) );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032051\"></A>\tpackets_out.push_back( new_packet );</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032052\"></A>}</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032053\"></A>&nbsp;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032054\"></A>} /* extern &quot;C&quot; */</P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1031426\"></A><A NAME=\"50520069_88497\"></A>Process-Tree Topologies</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032110\"></A>MRNet allows a tool to specify a node allocation and process connectivity tailored to its computation and communication requirements and to the system where the tool will run. Choosing an appropriate MRNet configuration can be difficult due to the complexity of the tool's own activity and its interaction with the system. This section describes how users define their own process topologies, and the <EM CLASS=\"codeword\">\nmrnet_topgen</EM>\n utility provided by MRNet to facilitate generation of topology specification files. </P>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1032108\"></A>Topology File Format</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032121\"></A>The first parameter to <EM CLASS=\"codeword\">\nNetwork::CreateNetworkFE</EM>\n is the name of an MRNet topology file. This file defines the topological layout of the front-end, internal, and back-end MRNet processes. In the syntax of the topology file, the hostname:id tuple represents a process with instance id running on hostname. It is important to note that the instance is used to distinguish processes on the same host, and does not reflect a port or process rank. A line in the topology file has the form:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1032123\"></A>hostname1:0 =&gt; hostname1:1 hostname1:2 ;</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032125\"></A>meaning a process on hostname1 with instance id 0 has two children, with instance ids 1 and 2, running on the same host. MRNet will parse the topology file without error if the file properly defines a tree in the mathematical sense (i.e. a tree must have a single root, no cycles, full connection, and no node can be its own descendant). Please note that the hostname associated with the root of the topology must match the host where the front-end process is run, or a run-time error will occur.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032126\"></A>NOTE: A single topology specification line may span multiple physical lines to improve readability. For example:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1035836\"></A>hostname1:0 =&gt; </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1035860\"></A>\t\thostname1:1 </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1035880\"></A>\t\thostname1:2 </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1035908\"></A>\t\t;</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1048570\"></A>An Example Topology File</H4>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048515\"></A>nutmeg:0 =&gt; c01:0 c02:0 c03:0 c04:0 ;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048516\"></A>c03:0 =&gt; c05:0 ;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048517\"></A>c04:0 =&gt; c06:0 c07:0 c08:0 c09:0 ;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048521\"></A>#       nutmeg</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048523\"></A>#          |</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048524\"></A>#       -------</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048527\"></A>#     /  |   |  &#92;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048529\"></A>#  c01  c02  c03  c04</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048530\"></A>#             |    |</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048531\"></A>#            c05   |</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048532\"></A>#               -------</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048534\"></A>#             /  |   |  &#92;</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1048536\"></A>#          c06  c07 c08  c09</P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1032109\"></A>Topology File Generator</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1048999\"></A>MRNet provides a topology generator program that supports generation of balanced and k-nomial topologies using simple specifications, and arbitrary topologies with a more complex specification that fully enumerates the topology fan-outs at each level of the tree. After MRNet is built, this program can be found at <EM CLASS=\"codeword\">\n$MRNET_ROOT/build/$MRNET_ARCH/bin/mrnet_topgen</EM>\n. The usage can be obtained by running <EM CLASS=\"codeword\">\nmrnet_topgen</EM>\n without arguments.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1050750\"></A>The generator program uses host lists that specify the maximum number of processes to place on each host. The format for the host list is one host specification per line, where each specification is of the form hostname[:num_slots]. If the number of process slots is not given with the host, the generator program assumes only one process should be placed on the host. Additionally, if the same hostname is given on multiple lines, the number of processes that can be placed on the host is the summation of the process slot counts for all lines. An example host list file follows:</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050759\"></A>host1:4</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050760\"></A>host2 </P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050761\"></A>host3:2</P>\n<P CLASS=\"codeblock\">\n<A NAME=\"50520069_pgfId-1050762\"></A>host2</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1050757\"></A>The above host list file results in three hosts being available for topology process placement, with host1 having four available slots, and host2 and host3 each having two available slots. The generator program also allows users to specify different host lists for the placement of internal communication processes and back-end processes (see the <EM CLASS=\"codeword\">\nmrnet_topgen</EM>\n usage for more information).</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1050843\"></A>Some MRNet front-end programs may wish to generate a topology at run-time. To support this requirement, MRNet provides three API classes: BalancedTree, KnomialTree, and GenericTree that front-end programs may use directly to generate any topology that can be produced by <EM CLASS=\"codeword\">\nmrnet_topgen</EM>\n. Not surprisingly, <EM CLASS=\"codeword\">\nmrnet_topgen</EM>\n is built upon these classes, and its source code (<EM CLASS=\"codeword\">\n$MRNET_ROOT/tests/config_generator.C)</EM>\n can serve as a reference for front-end programs wishing to use these classes.</P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1031412\"></A><A NAME=\"50520069_28904\"></A>Adding New Filters</H2>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1032205\"></A>Defining an MRNet Filter</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032210\"></A>A filter function has the following signature:</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1032211\"></A>void filter_name( </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1048310\"></A>\tstd::vector&lt; PacketPtr &gt; &amp; packets_in,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1036440\"></A>\tstd::vector&lt; PacketPtr &gt; &amp; packets_out, </P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1036443\"></A>\tstd::vector&lt; PacketPtr &gt; &amp; packets_out_reverse,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1036446\"></A>\tvoid ** filter_state,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1036449\"></A>\tPacketPtr &amp; config_params,</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1048314\"></A>\tconst TopologyLocalInfo &amp; topol_info );</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032222\"></A><EM CLASS=\"codeword\">\npackets_in</EM>\n is a reference to a vector of packets serving as input to the filter function. <EM CLASS=\"codeword\">\npackets_out</EM>\n is a reference to a vector into which output packets should be placed. When packets need to be sent in the reverse direction on the stream, <EM CLASS=\"codeword\">\npackets_out_reverse</EM>\n can be used instead of <EM CLASS=\"codeword\">\npackets_out</EM>\n. Both <EM CLASS=\"codeword\">\npackets_out</EM>\n and <EM CLASS=\"codeword\">\npackets_out_reverse</EM>\n can be used simultaneously. <EM CLASS=\"codeword\">\nfilter_state</EM>\n may be used to define and maintain state specific to a filter instance. <EM CLASS=\"codeword\">\nconfig_params</EM>\n is a reference to a PacketPtr containing the current configuration settings for the filter instance, as can be set using <EM CLASS=\"codeword\">\nStream::set_FilterParameters</EM>\n. Finally, topol_info provides information that can be used by filters to determine the local process's placement in the topology, as well as access to the local Network object.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032208\"></A>For each filter function defined in a shared object file, there must be a const char * symbol named by the string formed by the concatenation of the filter function name and the suffix &quot;<EM CLASS=\"codeword\">\n_format_string</EM>\n&quot;. For instance, if the filter function is named <EM CLASS=\"codeword\">\nmy_filter_func</EM>\n, the shared object must define a symbol &quot;const char* <EM CLASS=\"codeword\">\nmy_filter_func_format_string</EM>\n&quot;. The value of this string will be the MRNet format string describing the format of data that the filter can operate on. A value of <EM CLASS=\"codeword\">\n&quot;&quot;</EM>\n denotes that the filter can operate on packets containing arbitrary data. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1032206\"></A>Fault-Tolerant Filters</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032233\"></A>MRNet automatically recovers from failures of internal tree processes (i.e., those processes that are not the front-end (root) or back-ends (leaves)). As part of the recovery, MRNet will extract filter state from the children of a failed process and pass that state as input to each child's newly chosen parent. If you have a filter that maintains persistent state using <EM CLASS=\"codeword\">\nfilter_state</EM>\n, you can provide an additional function within the shared object for your filter that MRNet may use to extract the state. The name of this extraction function should be the same as the filter name with the suffix &quot;<EM CLASS=\"codeword\">\n_get_state</EM>\n&quot; appended. For instance, if the filter function is named my_filter_func, the extraction function should be named <EM CLASS=\"codeword\">\nmy_filter_func_get_state</EM>\n.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032235\"></A>A filter state extraction function has the following signature:</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1032236\"></A>PacketPtr filter_name_get_state( void ** filter_state, int stream_id );\t </P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032231\"></A><EM CLASS=\"codeword\">\nfilter_state</EM>\n is a pointer to the state defined by the filter for the stream identified by <EM CLASS=\"codeword\">\nstream_id</EM>\n. This function should extract the necessary state and return a packet that can be passed as input to the filter function. Since the packet will be processed as a normal input packet for the filter, it's format must match that expected by the filter. A fault-tolerant filter example is provided in <EM CLASS=\"codeword\">\n$MRNET_ROOT/Examples/FaultRecovery</EM>\n. </P>\n</DIV>\n<DIV>\n<H4 CLASS=\"nh2\">\n<A NAME=\"50520069_pgfId-1032207\"></A>Creating and Using MRNet Filter Shared Object Files</H4>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032248\"></A>Since we use the C facility <EM CLASS=\"codeword\">\ndlopen</EM>\n to dynamically load new filter functions, all C++ symbols must be exported. That is, the filter function, format string, and state extraction function definitions must fall within the statements:</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032250\"></A><EM CLASS=\"codeword\">\nextern &quot;C&quot; {</EM>\n</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032252\"></A>and</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032254\"></A><EM CLASS=\"codeword\">\n}</EM>\n</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032256\"></A>The file that contains the filter functions and format strings must be compiled into a valid shared object. For example, with the GNU C++ compiler on ELF systems, the options &quot;<EM CLASS=\"codeword\">\n-fPIC -shared -rdynamic</EM>\n&quot; can be used. Please refer to your compiler documentation for the appropriate options for other compilers. You can also refer to the setting of the SOFLAGS variable in <EM CLASS=\"codeword\">\n$MRNET_ROOT/build/$MRNET_ARCH/Makefile.examples</EM>\n to see the options chosen during the configure process for compiling the Example filter libraries.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032244\"></A>Additionally, front-end and back-end programs that will dynamically load filters must be built with compiler options that notify the linker to export global symbols (for GNU compilers, you can use &quot;-<EM CLASS=\"codeword\">\nWl,-E</EM>\n&quot;). </P>\n</DIV>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1054752\"></A><A NAME=\"50520069_40816\"></A>Format Strings</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1054756\"></A>The table below shows the format string conversions for individual data elements of specific types. Each conversion is preceded by the `%' character (e.g., &quot;%d&quot;).</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1054872\"></A>Arrays of specific types are also supported. An array can be specified by prepending `a' to the appropriate type conversion (e.g., &quot;%ac&quot; for an array of 8-bit signed characters). Array conversions require an implicit length parameter of type uint32_t to be passed to send() methods: e.g., <EM CLASS=\"codeword\">\nsend(&quot;%af&quot;, float_array_pointer, float_array_length)</EM>\n. When the number of elements in the array exceeds the maximum value of uint32_t (roughly over 4 billion elements), MRNet provides a large array conversion that can be specified by prepending `A' to the appropriate type conversion (e.g., &quot;%Auc&quot; for an array of 8-bit unsigned characters). Large array conversions require an implicit length parameter of type uint64_t .</P>\n<TABLE BORDER=\"1\">\n<CAPTION>\n<H6 CLASS=\"TableTitle\">\n<A NAME=\"50520069_pgfId-1054908\"></A>Format String Conversions</H6>\n</CAPTION>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054912\"></A>c</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054914\"></A>signed 8-bit character</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054916\"></A>uc</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054918\"></A>unsigned 8-bit character</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054920\"></A>hd</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054922\"></A>signed 16-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054924\"></A>uhd</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054926\"></A>unsigned 16-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054928\"></A>d</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054930\"></A>signed 32-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054932\"></A>ud</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054934\"></A>unsigned 32-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054936\"></A>ld</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054938\"></A>signed 64-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054940\"></A>uld</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054942\"></A>unsigned 64-bit decimal integer</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054944\"></A>f</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054946\"></A>single-precision floating-point number</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054948\"></A>lf</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054950\"></A>double-precision floating-point number</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054952\"></A>s</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"Body\">\n<A NAME=\"50520069_pgfId-1054954\"></A>null-terminated character string</P>\n</TD>\n</TR>\n</TABLE>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1031410\"></A><A NAME=\"50520069_16750\"></A>MRNet Stream Performance Data</H2>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033329\"></A>The primary abstraction for communication and data processing within MRNet is the stream, so performance metrics and contexts are associated with actions on a particular stream.</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033331\"></A>All data is recorded as instances of a perf_data_t, which is simply a union type that can hold a 64-bit signed integer, a 64-bit unsigned integer, or a double precision float. As shown below, the data values can be accessed using the <EM CLASS=\"codeword\">\ni</EM>\n, <EM CLASS=\"codeword\">\nu</EM>\n, or <EM CLASS=\"codeword\">\nd</EM>\n union fields.</P>\n<P CLASS=\"api-codeblock\">\n<A NAME=\"50520069_pgfId-1033332\"></A>\ttypedef union { int64_t i; uint64_t u; double d; } perfdata_t;</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033334\"></A>Metrics define the type of performance data to record. The supported metric types are:</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033336\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_NUM_BYTES </EM>\n\t: count of data bytes (uint64_t)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033337\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_NUM_PKTS</EM>\n \t: count of data packets (uint64_t)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033338\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_ELAPSED_SEC</EM>\n \t: elapsed seconds (double)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033339\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_CPU_USR_PCT</EM>\n \t: percent CPU utilization by user (double)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033340\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_CPU_USR_PCT</EM>\n \t: percent CPU utilization by system (double)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033341\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_MEM_VIRT_KB</EM>\n \t: virtual memory footprint in KB (double)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033342\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_MET_MEM_PHYS_KB</EM>\n \t: physical memory footprint in KB (double)</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033344\"></A>Contexts specify when to record data. The supported contexts are:</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033346\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_SEND</EM>\n \t: when data is sent</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033347\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_RECV</EM>\n \t: when data is received</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033348\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_FILT_IN \t:</EM>\n before executing transformation filter</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033349\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_FILT_OUT \t</EM>\n: after executing transformation filter</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1054975\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_SYNCFILT_IN \t:</EM>\n before executing synchronization filter</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1054976\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_SYNCFILT_OUT \t</EM>\n: after executing synchronization filter</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1033350\"></A>    * <EM CLASS=\"codeword\">\nPERFDATA_CTX_NONE</EM>\n \t: when data is collected</P>\n<P CLASS=\"lp\">\n<A NAME=\"50520069_pgfId-1032847\"></A><A HREF=\"mrnet_4.1.0.htm#50520069_63803\" CLASS=\"XRef\">See Metric-Context Compatibility Matrix</A> shows which metrics are valid for a given context. When a metric is valid for only <EM CLASS=\"codeword\">\nCTX_FILT_OUT</EM>\n, the metric is actually recorded through a combination of measurements at <EM CLASS=\"codeword\">\nCTX_FILT_IN</EM>\n and <EM CLASS=\"codeword\">\nCTX_FILT_OUT</EM>\n. When a metric is valid for only <EM CLASS=\"codeword\">\nCTX_NONE</EM>\n, the data is only recorded at the time it is collected. An example MRNet application that makes use of the Stream performance data collection facilities is provided in <EM CLASS=\"codeword\">\n$MRNET_ROOT/Examples/PerformanceData</EM>\n.</P>\n<TABLE BORDER=\"1\">\n<CAPTION>\n<H6 CLASS=\"TableTitle\">\n<A NAME=\"50520069_pgfId-1055206\"></A><A NAME=\"50520069_63803\"></A>Metric-Context Compatibility Matrix</H6>\n</CAPTION>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055216\"></A>&nbsp;</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055218\"></A>CTX_SEND</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055219\"></A>CTX_RECV</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055221\"></A>CTX_FILT_IN</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055222\"></A>CTX_SYNCFILT_IN</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055224\"></A>CTX_FILT_OUT</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055225\"></A>CTX_SYNCFILT_OUT</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055227\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055298\"></A>CTX_NONE</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055229\"></A>MET_NUM_BYTES</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055231\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055233\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055235\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055237\"></A>no</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055239\"></A>MET_NUM_PKTS</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055241\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055243\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055245\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055247\"></A>no</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055249\"></A>MET_ELAPSED_SEC</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055251\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055253\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055255\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055257\"></A>no</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055259\"></A>MET_CPU_USR_PCT</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055261\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055263\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055265\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055267\"></A>no</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055269\"></A>MET_CPU_SYS_PCT</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055271\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055273\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055275\"></A>yes</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055277\"></A>no</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055279\"></A>MET_MEM_VIRT_KB</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055281\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055283\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055285\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055287\"></A>yes</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055289\"></A>MET_MEM_PHYS_KB</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055291\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055293\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055295\"></A>no</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055297\"></A>yes</P>\n</TD>\n</TR>\n</TABLE>\n<UL>\n<LI CLASS=\"pp\">\n<A NAME=\"50520069_pgfId-1033589\"></A>NOTE: <EM CLASS=\"codeword\">\nMET_CPU_USR_PCT</EM>\n, <EM CLASS=\"codeword\">\nMET_CPU_SYS_PCT</EM>\n, <EM CLASS=\"codeword\">\nMET_MEM_VIRT_KB</EM>\n, and <EM CLASS=\"codeword\">\nMET_MEM_PHYS_KB</EM>\n are currently only supported for Linux.</LI>\n</UL>\n</DIV>\n<DIV>\n<H2 CLASS=\"Header-Appendix\">\n<A NAME=\"50520069_pgfId-1052906\"></A>Network Settings</H2>\n<TABLE BORDER=\"1\">\n<CAPTION>\n<H6 CLASS=\"TableTitle\">\n<A NAME=\"50520069_pgfId-1033597\"></A><A NAME=\"50520069_28837\"></A>Environment Variables and Network Attributes</H6>\n</CAPTION>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033601\"></A>XPLAT_RSH</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051090\"></A>XPLAT_RSH_ARGS</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051108\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051131\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051132\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051134\"></A>XPLAT_REMCMD</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033603\"></A>Set XPLAT_RSH to the name of the remote shell program to use for remote process execution. Default is 'ssh'. XPLAT_RSH_ARGS can be used to pass shell-specific options to the remote shell.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051113\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051120\"></A>If it is necessary to run the remote shell program with a utility such as runauth to non-interactively authenticate the unattended remote process, that command may be specified using XPLAT_REMCMD.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033609\"></A>XPLAT_RESOLVE_HOSTS</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051140\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051148\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051149\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051143\"></A>XPLAT_RESOLVE_CANONICAL</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033611\"></A>Tell XPlat to perform DNS resolution of hostnames and IP addresses by setting the variable to '1'. Default is '1'.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051152\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051153\"></A>When <EM CLASS=\"codeword\">\nXPLAT_RESOLVE_HOSTS</EM>\n is '1', setting <EM CLASS=\"codeword\">\nXPLAT_RESOLVE_CANONICAL</EM>\n to '1' will tell XPlat to try to resolve all hostnames to their canonical DNS format. Default is '0'.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033617\"></A>MRNET_DEBUG_LEVEL</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051190\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051191\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051192\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051193\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051194\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051195\"></A>MRNET_DEBUG_LOG_DIRECTORY</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033619\"></A>Set the debug output level (valid values are 1-5, default is 1). Level 1 will only log warning/error messages, level 3 provides fairly detailed function execution logging, and level 5 enables all log messages.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051171\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1051177\"></A>Specify the absolute path to the directory to store MRNet log files. By default, the directory $HOME/mrnet-log will be used if it exists; otherwise, log messages will be output to stderr.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033625\"></A>MRN_COMM_PATH (deprecated)</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053781\"></A>MRNET_COMM_PATH</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1033627\"></A>If <EM CLASS=\"codeword\">\nmrnet_commnode</EM>\n is not in your path by default, you can specify the full path using this variable.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055308\"></A>MRNET_STARTUP_TIMEOUT</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055310\"></A>Set the maximum time in seconds that a MRNet process will try to connect to its parent during Network instantiation before exiting.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054110\"></A>MRNET_FAILURE_RECOVERY</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054112\"></A>Set attribute value to `1' to turn on failure recovery (default), or `0' to turn off failure recovery. Alternatively, you may specify the recovery mode using <EM CLASS=\"codeword\">\nNetwork::set_FailureRecovery()</EM>\n.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054113\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054114\"></A>Note: there is no corresponding environment variable for this attribute.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055320\"></A>MRNET_PORT_BASE</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055322\"></A>Specify the base port used for listening for socket connections by MRNet communication processes on the same host. For N processes on a host, the ports in the range [base, base+N) must be available.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055327\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055328\"></A>On Cray systems, the default base port is 26500. </P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055329\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1055330\"></A>On rsh/ssh systems, all listening ports are chosen dynamically and this value is ignored.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053960\"></A>CRAY_ALPS_APID</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053963\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053964\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053965\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053966\"></A>CRAY_ALPS_APRUN_PID</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053962\"></A>Specify the ALPS application id (aka apid - the unique identifier assigned to the application by ALPS, as can be queried using apstat).</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053967\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1053968\"></A>As an alternative to CRAY_ALPS_APID, you may use this attribute to specify the process id (pid) of the aprun process used to start the target application, and MRNet will obtain the corresponding apid. </P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054131\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054145\"></A>Note: MRNet must be configured to use the ALPS tool helper library to use these settings.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054149\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054146\"></A>Note: there are no corresponding environment variables for either of these attributes.</P>\n</TD>\n</TR>\n<TR>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054128\"></A>CRAY_ALPS_STAGE_FILES</P>\n</TD>\n<TD ROWSPAN=\"1\" COLSPAN=\"1\">\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054130\"></A>Specify a colon-separated list of file pathnames (e.g., &quot;/path/to/file/a:/path/to/file/b&quot;). MRNet will use the ALPS tool helper library to stage the specified files to Cray compute nodes hosting the application identified using either CRAY_ALPS_APID or CRAY_ALPS_APRUN_PID.</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054133\"></A>&nbsp;</P>\n<P CLASS=\"CellBody\">\n<A NAME=\"50520069_pgfId-1054137\"></A>Note: MRNet must be configured to use the ALPS tool helper library to use this setting.</P>\n</TD>\n</TR>\n</TABLE>\n</DIV>\n</DIV>\n</BODY>\n</HTML>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/Tree.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTNetwork.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTBackEndNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHFrontEndNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHBackEndNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHInternalNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTBackEndNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHInternalNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHFrontEndNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHParentNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHParentNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTFrontEndNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHBackEndNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/RSHChildNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTFrontEndNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTInternalNode.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/src/XTInternalNode.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/microbench_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_arrays_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/microbench_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/microbench_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/microbench_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_common.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_basic.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/singlecast_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_common.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_basic_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_basic_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_NativeFilters_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_MultStreams_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_NativeFilters_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_basic_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/singlecast_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_arrays_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/singlecast.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_MultStreams_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/microbench.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_NativeFilters_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/singlecast_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_arrays_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_NativeFilters.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_MultStreams_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_arrays_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_NativeFilters_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/timer.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/Topology.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_basic_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_arrays.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/config_generator.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/test_DynamicFilters.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/Topology.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/tests/singlecast_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/conf/Makefile.ltwt.in",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecovery_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecovery_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecovery.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecoveryFilter.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecovery_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/FaultRecovery/FaultRecovery_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAdditionFilter.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_FE_asyncStreams.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_FE_timeout.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_FE_async.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/IntegerAddition/IntegerAddition_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/header_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/header.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/BE_mpi_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/NoBackEndInstantiation/BE_mpi.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerformanceData/BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerformanceData/FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerformanceData/BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreams_lightweight.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreams_BE_lightweight.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreams.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreams_FE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreamsFilter.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/Examples/PerThreadStreams/PerThreadStreams_BE.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SharedObject-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SocketUtils-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Once-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/PathUtils-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Mutex-pthread.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SocketUtils.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Process-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SocketUtils-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Process.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/NetUtils-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Thread-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Thread-pthread.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Tokenizer.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Error-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Mutex-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/TLSKey-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Once-pthread.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/NetUtils.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/TLSKey-pthread.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Once-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SharedObject-unix.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/NetUtils-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/TLSKey-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Monitor-pthread.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Process-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Monitor-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Monitor-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SharedObject-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Monitor-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Error-unix.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/PathUtils-win.C",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/SharedObject-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Mutex-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Mutex-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/Once-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/TLSKey-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Thread-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/SocketUtils-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Error-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Mutex-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/PathUtils-unix.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/PathUtils-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Monitor-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Thread-pthread.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/NetUtils.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/NetUtils-unix.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/NetUtils-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Mutex-pthread.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Monitor-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Monitor-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Process-win.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Mutex-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Mutex-pthread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Process-unix.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Error-unix.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/src/lightweight/Monitor-pthread.c",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Types-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Thread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Types.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Error.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Monitor.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/NetUtils.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/SocketUtils.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Process.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/PathUtils.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Types-unix.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat_lightweight/Mutex.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Types-win.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Thread.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/TLSKey.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Once.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/SharedObject.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Types.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Error.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Monitor.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/SocketUtils.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Atomic.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Process.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Tokenizer.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/PathUtils.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Types-unix.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/include/xplat/Mutex.h",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/conf/Makefile.ltwt.in",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/xplat/conf/Makefile.in",
        "/tmp/vanessa/spack-stage/spack-stage-mrnet-4.1.0-lxrxhd7tsrmk5jj6bc3dpes2my45zrmv/spack-src/doc/mrnet_4.1.0.pdf"
    ],
    "total_files": 453
}