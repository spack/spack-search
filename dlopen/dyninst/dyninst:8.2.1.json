{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/common/src/serialize-xml.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"common/src/serialize.h\"\n\n#if !defined(SERIALIZATION_DISABLED)\n\n#if !defined(os_windows)\n#include \"common/src/pathName.h\"\n#include <dlfcn.h>\n#if defined (cap_have_libxml)\n//libxml2 functions\nvoid *hXML;\n#endif\n#else\n#include \"windows.h\"\n#if defined (cap_have_libxml)\n#include <libxml/xmlversion.h>\n#undef LIBXML_ICONV_ENABLED\nHINSTANCE hXML;\n#endif\n#endif\n\n#if defined (cap_have_libxml)\n#if defined (os_linux)\n//  gcc is complaining about the constness of the library-provided\n//  typecast (BAD_CAST) (which is defined in xmlstring.h), so we make our own\n#define XMLCHAR_CAST (const xmlChar *)\n#else\n#define XMLCHAR_CAST BAD_CAST\n#endif\n\n#else\n#define XMLCHAR_CAST (const char *)\n#endif\n\n#if 0\nSerDesXML &SerializerXML::getSD_xml()\n{\n   SerDes &sd = getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *> (&sd);\n   assert(sdxml);\n   return *sdxml;\n}\n#endif\n\n\n#if 0\nbool end_xml_element(SerializerBase *, const char *);\n#endif\n\n\n\n// DLLEXPORT SerDesXML(xmlTextWriterPtr w, iomode_t mode)  : SerDes(mode), writer(w) { }\n// DLLEXPORT static xmlTextWriterPtr init(std::string fname, iomode_t mode, bool verbose);\n\n#if defined (cap_have_libxml)\nxmlTextWriterPtr(*my_xmlNewTextWriterFilename)(const char *,int) = NULL;\n\nint (*my_xmlTextWriterStartDocument)(xmlTextWriterPtr, \n      const char *, const char *, const char * ) = NULL;\n\nint (*my_xmlTextWriterStartElement)(xmlTextWriterPtr, \n      const xmlChar *) = NULL;\n\nint (*my_xmlTextWriterWriteFormatElement)(xmlTextWriterPtr,\n      const xmlChar *,const char *,...) = NULL;\n\nint (*my_xmlTextWriterEndDocument)(xmlTextWriterPtr) = NULL;\n\nvoid (*my_xmlFreeTextWriter)(xmlTextWriterPtr) = NULL;\n\nint (*my_xmlTextWriterWriteFormatAttribute)(xmlTextWriterPtr, \n      const xmlChar *,const char *,...) = NULL;\n\nint (*my_xmlTextWriterEndElement)(xmlTextWriterPtr) = NULL;\n\nxmlTextWriterPtr SerDesXML::init(std::string fname, iomode_t /*mode*/, bool /*verbose*/) \n{\n#if defined(_MSC_VER)\n   hXML = LoadLibrary(LPCSTR(\"../../../i386-unknown-nt4.0/lib/libxml2.dll\"));\n   if (hXML == NULL)\n   {\n      char buf[1000];\n      DWORD result = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        buf, 1000, NULL);\n      SER_ERR(buf);\n   }\n\n    my_xmlNewTextWriterFilename = \n       (xmlTextWriterPtr (*)(const char *,int)) GetProcAddress(hXML,\"xmlNewTextWriterFilename\");\n    \n    my_xmlTextWriterStartDocument = \n       (int (*)(xmlTextWriterPtr, const char *, const char *, const char * ))GetProcAddress(hXML,\"xmlTextWriterStartDocument\");\n    \n    my_xmlTextWriterStartElement = \n       (int (*)(xmlTextWriterPtr, const xmlChar *))GetProcAddress(hXML,\"xmlTextWriterStartElement\");\n\n    my_xmlTextWriterWriteFormatElement = \n       (int (*)(xmlTextWriterPtr,const xmlChar *,const char *,...))GetProcAddress(hXML,\"xmlTextWriterWriteFormatElement\");\n\n    my_xmlTextWriterEndDocument = \n       (int (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlTextWriterEndDocument\");\n\n    my_xmlFreeTextWriter = \n       (void (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlFreeTextWriter\");\n\n    my_xmlTextWriterWriteFormatAttribute = \n       (int (*)(xmlTextWriterPtr, const xmlChar *,const char *,...))GetProcAddress(hXML,\"xmlTextWriterWriteFormatAttribute\");\n    \n    my_xmlTextWriterEndElement = \n       (int (*)(xmlTextWriterPtr))GetProcAddress(hXML,\"xmlTextWriterEndElement\");\n\n#else\n\n    hXML = dlopen(\"libxml2.so\", RTLD_LAZY);\n\n    if (hXML == NULL)\n    {\n      SER_ERR(\"Unable to find libxml2\");\n      return NULL;\n    }\n\n    my_xmlNewTextWriterFilename = (xmlTextWriterPtr(*)(const char *,int))dlsym(hXML,\"xmlNewTextWriterFilename\");\n    my_xmlTextWriterStartDocument = (int(*)(xmlTextWriterPtr, const char *, const char *, const char * ))dlsym(hXML,\"xmlTextWriterStartDocument\");\n    my_xmlTextWriterStartElement = (int(*)(xmlTextWriterPtr, const xmlChar *))dlsym(hXML,\"xmlTextWriterStartElement\");\n    my_xmlTextWriterWriteFormatElement = (int(*)(xmlTextWriterPtr,const xmlChar *,const char *,...))dlsym(hXML,\"xmlTextWriterWriteFormatElement\");\n    my_xmlTextWriterEndDocument = (int(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlTextWriterEndDocument\");\n    my_xmlFreeTextWriter = (void(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlFreeTextWriter\");\n    my_xmlTextWriterWriteFormatAttribute = (int(*)(xmlTextWriterPtr, const xmlChar *,const char *,...))dlsym(hXML,\"xmlTextWriterWriteFormatAttribute\");\n    my_xmlTextWriterEndElement = (int(*)(xmlTextWriterPtr))dlsym(hXML,\"xmlTextWriterEndElement\");\n\n#endif\n\n    /* Create a new XmlWriter for DOM */\n\n    xmlTextWriterPtr writer = my_xmlNewTextWriterFilename(fname.c_str(), 0);\n\n    if (writer == NULL) \n    {\n        SER_ERR(\"testXmlwriterDoc: Error creating the xml writer\");\n      return NULL;\n    }\n\n    int rc = my_xmlTextWriterStartDocument(writer, NULL, \"ISO-8859-1\", NULL);\n\n    if (rc < 0) \n    {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartDocument\");\n    return NULL;\n    }\n\n    return writer;\n}\n\n#endif // defined (cap_have_libxml)\n\n\nnamespace Dyninst {\n#if defined (cap_have_libxml)\n//int (*my_xmlTextWriterStartElement)(xmlTextWriterPtr, \n//      const xmlChar *) = NULL;\nbool start_xml_elem(void *writer, const char *tag)\n{\n    int rc = my_xmlTextWriterStartElement((xmlTextWriterPtr) writer, XMLCHAR_CAST tag);\n    return (rc >= 0);\n}\n//    my_xmlTextWriterEndElement(writer);\n\nbool end_xml_elem(void *writer)\n{\n    int rc = my_xmlTextWriterEndElement((xmlTextWriterPtr) writer);\n    return (rc >= 0);\n}\n\nbool write_xml_elem(void *writer, const char *tag, const char *fmt, ...)\n{\n   va_list ap;\n   va_start(ap, fmt);\n\n   int rc = my_xmlTextWriterWriteFormatElement((xmlTextWriterPtr) writer, XMLCHAR_CAST tag, fmt, ap);\n\n   if (rc < 0) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n   va_end(ap);\n\n   return (rc >= 0);\n}\n#else\n\nbool start_xml_elem(void * /*writer*/, const char * /*xmlChar*/)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n\nbool end_xml_elem(void * /*writer*/)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n\nbool write_xml_elem(void * /*writer*/, const char * /*tag*/, const char * /*fmt*/, ...)\n{\n   fprintf(stderr, \"%s[%d]:  xml output is disabled\\n\", FILE__, __LINE__);\n   return false;\n}\n#endif\n}\n\nnamespace Dyninst {\nbool start_xml_elem(SerDesXML &s, const char *tag)\n{\n\treturn start_xml_elem(s.writer, tag);\n}\nbool end_xml_elem(SerDesXML &s)\n{\n\treturn end_xml_elem(s.writer);\n}\n}\n\nnamespace Dyninst {\nbool ifxml_start_element(SerializerBase *sb, const char *tag)\n{\n#if 0\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n   if (!sxml) \n   {\n      return false;\n   }\n\n   if (sxml->iomode() == sd_deserialize) \n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n#endif\n   if (!sb->isXML())\n\t   return false;\n   if (!sb->isOutput())\n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n\n   SerDes &sd = sb->getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *>(&sd);\n   assert(sdxml);\n   ::start_xml_elem(sdxml->writer, tag);\n\n#if 0\n   sxml->getSD_xml().start_element(tag);\n#endif\n\n   return true;\n}\n}\n\nnamespace Dyninst {\nCOMMON_EXPORT bool ifxml_end_element(SerializerBase *sb, const char * /*tag*/)\n{\n#if 0\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n   if (!sxml) \n   {\n      return false;\n   }\n\n   if (sxml->iomode() == sd_deserialize) \n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n#endif\n   if (!sb->isXML())\n\t   return false;\n   if (!sb->isOutput())\n   {\n      fprintf(stderr, \"%s[%d]:  ERROR:  request to deserialize xml\\n\", FILE__, __LINE__);\n      return false;\n   }\n\n   SerDes &sd = sb->getSD();\n   SerDesXML *sdxml = dynamic_cast<SerDesXML *>(&sd);\n   assert(sdxml);\n   ::end_xml_elem(sdxml->writer);\n   \n#if 0\n   sxml->getSD_xml().end_element();\n#endif\n\n   return true;\n}\n}\n\nbool SerializerXML::start_xml_element(SerializerBase *sb, const char *tag)\n{\n\tSerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n\tif (!sxml)\n\t{\n\t\tfprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\",\n\t\t\t\tFILE__, __LINE__);\n\t\treturn false;\n\t}\n\n\tSerDesXML sdxml = sxml->getSD_xml();\n\tstart_xml_elem(sdxml, tag);\n\treturn true;\n\n}\n#if 0\nbool SerializerXML::start_xml_element(SerializerBase *sb, const char *tag)\n{\n\tSerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n\tif (!sxml) \n\t{\n      fprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\", \n            FILE__, __LINE__);\n      return false;\n   }\n\n   SerDesXML sdxml = sxml->getSD_xml();\n   start_xml_elem(sdxml.writer, tag);\n\n#if 0\n   sdxml.start_element(tag); \n#endif\n\n   return true;\n}\n#endif\n\nSerDesXML &SerializerXML::getSD_xml()\n{\n\tSerializerBase *sb = this;\n\tSerDes &sd = sb->getSD();\n\tSerDesXML *sdxml = dynamic_cast<SerDesXML *> (&sd);\n\tassert(sdxml);\n\treturn *sdxml;\n}\n\nbool SerializerXML::end_xml_element(SerializerBase * sb, const char  * /*tag*/)\n{\n   SerializerXML *sxml = dynamic_cast<SerializerXML *>(sb);\n\n   if (!sxml) \n   {\n      fprintf(stderr, \"%s[%d]:  FIXME:  called xml function with non xml serializer\\n\", \n            FILE__, __LINE__);\n      return false;\n   }\n\n   SerDesXML sdxml = sxml->getSD_xml();\n   end_xml_elem(sdxml);\n\n#if 0\n   sdxml.end_element(); \n#endif\n   return true;\n}\n\nSerDesXML::~SerDesXML()\n{\n#if defined (cap_have_libxml)\n    my_xmlFreeTextWriter(writer);\n#endif\n\n}\n\nvoid SerDesXML::vector_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::vector_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::multimap_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::multimap_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::pair_start(const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::pair_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::hash_map_start(unsigned long &/*size*/, const char *tag) DECLTHROW(SerializerError)\n{\n   bool rc = ::start_xml_elem(writer,  tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::hash_map_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::annotation_start(Dyninst::AnnotationClassID &a_id, void *& parent_id, sparse_or_dense_anno_t &sod, const char * /*id*/, const char * tag) \n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate(a_id, \"annotationID\");\n   translate((Address &)parent_id, \"annotatableID\");\n   translate((int &) sod, \"SparseOrDense\");\n   //char sodstr[12];\n   //sprintf(sodstr, \"%s\", sod == sparse ? \"sparse\" : \"dense\");\n   //const char *sodstr = (sod == sparse) ? \"sparse\" : \"dense\";\n   //translate((const char *&)const_cast<const char *>(sodstr), 12, \"SparseOrDense\");\n}\n\nvoid SerDesXML::annotation_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\n\nvoid SerDesXML::annotation_container_start(void *& id) \n{\n   bool rc = ::start_xml_elem(writer, \"AnnotationContainer\");\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate((Address &)id, \"containerID\");\n}\n\nvoid SerDesXML::annotation_container_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\n\nvoid SerDesXML::annotation_container_item_start(void *& id) \n{\n   bool rc = ::start_xml_elem(writer, \"AnnotationContainerItem\");\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n   translate((Address &)id, \"containerID\");\n}\n\nvoid SerDesXML::annotation_container_item_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\nvoid SerDesXML::annotation_list_start(Address &/*id*/, unsigned long &/*nelem*/, const char * tag) \n{\n   bool rc = ::start_xml_elem(writer, tag);\n\n   if (!rc)\n   {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::annotation_list_end()\n{\n   bool rc = ::end_xml_elem(writer);\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n}\nvoid SerDesXML::translate(bool &param, const char *tag)\n{       \n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param ? \"true\" : \"false\");\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                \"%s\", param ? \"true\" : \"false\");\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n    \n}     \n\nvoid SerDesXML::translate(char &param, const char *tag)\n{       \n   bool rc = write_xml_elem(writer, tag,\n         \"%c\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                \"%c\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n    \n}     \n\nvoid SerDesXML::translate(int &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%d\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%d\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(long &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%l\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%l\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(short &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%h\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%h\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(unsigned short &param, const char *tag)\n{   \n   bool rc = write_xml_elem(writer, tag,\n         \"%h\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n    \n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%h\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::translate(unsigned int &param, const char *tag)\n{   \n  translate( param, tag);\n}\n\n#if 0\nvoid SerDesXML::translate(OFFSET &param, const char *tag)\n{\n\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%lx\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\nvoid SerDesXML::translate(float &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%e\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%e\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(double &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%g\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%g\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(Address &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%p\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%p\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(void * &param, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%p\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%p\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\nvoid SerDesXML::translate(const char * &param, int /*bufsize*/, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(char * &param, int /*bufsize*/, const char *tag)\n{\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param);\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\nvoid SerDesXML::translate(std::string &param, const char *tag)\n{\n   assert(tag);\n   assert(param.c_str());\n\n   bool rc = write_xml_elem(writer, tag,\n         \"%s\", param.c_str());\n\n   if (!rc) \n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param.c_str());\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\n#if 0\nvoid SerDesXML::translate(pdstring &param, const char *tag)\n{\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", param.c_str());\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\nvoid SerDesXML::translate(std::vector<std::string> &param, const char *tag,\n                          const char *elem_tag)\n{\n   bool rc = ::start_xml_elem(writer, tag);\n   if (!rc)\n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n\n#if 0\n    int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag) ;\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n\n    for (unsigned int i = 0; i < param.size(); ++i) \n      translate(param[i], elem_tag);\n    \n\n   rc = ::end_xml_elem(writer);\n   if (!rc)\n   {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterEndElement\");\n   }\n\n#if 0\n    rc = my_xmlTextWriterEndElement(writer);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n#endif\n}\n\n#if 0\nvoid SerDesXML::start_element(const char *tag)\n{\n   int rc = my_xmlTextWriterStartElement(writer, XMLCHAR_CAST tag) ;\n   if (rc < 0) {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::end_element()\n{\n   int rc = my_xmlTextWriterEndElement(writer);\n   if (rc < 0) {\n      SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n   }\n}\n\nvoid SerDesXML::xml_value(const char *s, const char *tag)\n{\n    int rc = my_xmlTextWriterWriteFormatElement(writer, XMLCHAR_CAST tag,\n                                                 \"%s\", s);\n    if (rc < 0) {\n        SER_ERR(\"testXmlwriterDoc: Error at my_xmlTextWriterStartElement\");\n    }\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/proccontrol/src/int_thread_db.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"common/src/Types.h\"\n#include \"proccontrol/src/int_thread_db.h\"\n\n\n#include <cassert>\n#include <cerrno>\n#include <cstdarg>\n#include <cstring>\n#include <set>\n#include <dlfcn.h>\n#include <iostream>\n\n#include \"common/src/dthread.h\"\n#include \"common/h/SymReader.h\"\n#include \"proccontrol/src/int_event.h\"\n#include \"proccontrol/h/Mailbox.h\"\n\nusing namespace std;\n\n#if defined(cap_thread_db)\n\n/* \n * proc_service interface implementation, needed by libthread_db\n */\n\nps_err_e ps_pglobal_lookup(struct ps_prochandle *handle, const char *objName, \n        const char *symName, psaddr_t *symbolAddr)\n{\n    pthrd_printf(\"Looking up symbol %s in %s\\n\", symName, objName);\n    return handle->thread_db_proc->getSymbolAddr(objName, symName, symbolAddr);\n}\n\nps_err_e ps_pread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   thread_db_process *llproc = handle->thread_db_proc;\n   pthrd_printf(\"thread_db reading from %#lx to %#lx, size = %d on %d\\n\",\n                (unsigned long)remote, (unsigned long)local, (int)size, llproc->getPid());\n\n   llproc->resps.clear();\n   async_ret_t result = llproc->getMemCache()->readMemory(local, (Address) remote, size,\n                                                          llproc->resps,\n                                                          llproc->triggerThread());\n   \n\n   switch (result) {\n      case aret_success:\n         llproc->hasAsyncPending = false;\n         return PS_OK;\n      case aret_async:\n         llproc->hasAsyncPending = true;\n         pthrd_printf(\"Incomplete async read in thread_db read\\n\");\n         return PS_ERR;\n      case aret_error:\n         llproc->hasAsyncPending = false;\n         pthrd_printf(\"Unexpected read error in thread_db read\\n\");\n         return PS_ERR;\n   }\n   assert(0);\n   return PS_ERR;\n}\n\nps_err_e ps_pdread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   return ps_pread(handle, remote, local, size);\n}\n\nps_err_e ps_ptread(struct ps_prochandle *handle, psaddr_t remote, void *local, size_t size) {\n   return ps_pread(handle, remote, local, size);\n}\n\nps_err_e ps_pwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n    pthrd_printf(\"thread_db writing to %#lx from %#lx, size = %d on %d\\n\",\n            (unsigned long)remote, (unsigned long)local, (int)size, handle->thread_db_proc->getPid());\n\n    thread_db_process *proc = handle->thread_db_proc;\n\n    async_ret_t result = proc->getMemCache()->writeMemory((Address) remote, \n                                                          const_cast<void *>(local), \n                                                          size, \n                                                          proc->res_resps, \n                                                          proc->triggerThread());\n    switch (result) {\n      case aret_success:\n         proc->hasAsyncPending = false;\n         return PS_OK;\n      case aret_async:\n         proc->hasAsyncPending = true;\n         pthrd_printf(\"Incomplete async write in thread_db write\\n\");\n         return PS_ERR;\n      case aret_error:\n         proc->hasAsyncPending = false;\n         pthrd_printf(\"Unexpected read error in thread_db write\\n\");\n         return PS_ERR;\n    }\n    assert(0);\n    return PS_ERR;\n}\n\nps_err_e ps_pdwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n   return ps_pwrite(handle, remote, local, size);\n}\n\nps_err_e ps_ptwrite(struct ps_prochandle *handle, psaddr_t remote, const void *local, size_t size) {\n   return ps_pwrite(handle, remote, local, size);\n}\n\nps_err_e ps_linfo(struct ps_prochandle *handle, lwpid_t lwp, void *lwpInfo) {\n   if( !handle->thread_db_proc->plat_getLWPInfo(lwp, lwpInfo) ) {\n      pthrd_printf(\"thread_db called ps_linfo, returning error\\n\");\n      return PS_ERR;\n   }\n   pthrd_printf(\"thread_db called ps_linfo, returning info\\n\");\n   return PS_OK;\n}\n\nps_err_e ps_lstop(struct ps_prochandle *handle, lwpid_t lwp) {\n   int_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *thr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!thr) {\n      perr_printf(\"ps_lstop is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n   pthrd_printf(\"ps_lstop on %d/%d\\n\", proc->getPid(), thr->getLWP());\n   \n   if (thr->getInternalState().getState() == int_thread::stopped) {\n      return PS_OK;\n   }\n   else if (thr->getInternalState().getState() != int_thread::running) {\n      perr_printf(\"Error, ps_lstop on thread in bad state\\n\");\n      return PS_ERR;\n   }\n\n   thr->getInternalState().setState(int_thread::stopped);\n   \n   return PS_OK;\n}\n\nps_err_e ps_lcontinue(struct ps_prochandle *handle, lwpid_t lwp) {\n   int_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *thr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!thr) {\n      perr_printf(\"ps_lcontinue is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n   pthrd_printf(\"ps_lcontinue on %d/%d\\n\", proc->getPid(), thr->getLWP());\n   \n   if (thr->getInternalState().getState() == int_thread::running) {\n      return PS_OK;\n   }\n   else if (thr->getInternalState().getState() != int_thread::stopped) {\n      perr_printf(\"Error, ps_lcontinue on thread in bad state\\n\");\n      return PS_ERR;\n   }\n   \n   thr->getInternalState().setState(int_thread::stopped);\n   return PS_OK;\n}\n\nps_err_e ps_lgetregs(struct ps_prochandle *handle, lwpid_t lwp, prgregset_t regs) {\n   thread_db_process *proc = handle->thread_db_proc;\n   int_threadPool *tp = proc->threadPool();\n   assert(tp);\n   int_thread *llthr = tp->findThreadByLWP((Dyninst::LWP) lwp);\n   if (!llthr) {\n      perr_printf(\"ps_lgetregs is unable to find LWP %d in process %d\\n\",\n                  lwp, proc->getPid());\n      return PS_ERR;\n   }\n\n   thread_db_thread *thr = dynamic_cast<thread_db_thread *>(llthr);\n   \n   pthrd_printf(\"thread_db reading registers on thread %d/%d\\n\",\n                proc->getPid(), thr->getLWP());\n   \n   int_registerPool pool;\n   async_ret_t result = proc->getMemCache()->getRegisters(llthr, pool);\n   if (result == aret_async) {\n      pthrd_printf(\"Async return during get reg\\n\");\n      return PS_ERR;\n   }\n   if (result == aret_error) {\n      pthrd_printf(\"Error return during get reg\\n\");\n      return PS_ERR;\n   }\n\n   bool bresult = thr->plat_convertToSystemRegs(pool, (unsigned char *) regs, true);\n   if (!bresult) {\n      pthrd_printf(\"Error convering to system regs\\n\");\n      return PS_ERR;\n   }\n   return PS_OK;\n}\n\npid_t ps_getpid (struct ps_prochandle *ph)\n{\n   int pid = ph->thread_db_proc->threaddb_getPid();\n   pthrd_printf(\"thread_db called ps_getpid.  Returning %d\\n\", pid);\n   return pid;\n}\n\nvoid ps_plog(const char *format, ...) {\n   pthrd_printf(\"thread_db called ps_plog\\n\");\n    if( !dyninst_debug_proccontrol ) return;\n    if( NULL == format ) return;\n\n    va_list va;\n    va_start(va, format);\n    vfprintf(pctrl_err_out, format, va);\n    va_end(va);\n}\n\n#define NA_IMPLEMENTED \"This function is not implemented\"\n\nps_err_e ps_lgetfpregs(struct ps_prochandle *, lwpid_t, prfpregset_t *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetfpregs(struct ps_prochandle *, lwpid_t, const prfpregset_t *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetregs(struct ps_prochandle *, lwpid_t, const prgregset_t) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lgetxmmregs (struct ps_prochandle *, lwpid_t, char *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_lsetxmmregs (struct ps_prochandle *, lwpid_t, const char *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pcontinue(struct ps_prochandle *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pdmodel(struct ps_prochandle *, int *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_pstop(struct ps_prochandle *) {\n    assert(!NA_IMPLEMENTED);\n    return PS_ERR;\n}\n\nps_err_e ps_get_thread_area(const struct ps_prochandle *phandle, lwpid_t lwp, int val, psaddr_t *addr)\n{\n   thread_db_process *tdb_proc = phandle->thread_db_proc;\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(tdb_proc->threadPool()->findThreadByLWP(lwp));\n\n   Dyninst::Address daddr = 0;\n   bool result = tdb_thread->thrdb_getThreadArea(val, daddr);\n   if (addr && result)\n      *addr = (psaddr_t) daddr;\n      \n   pthrd_printf(\"thread_db called ps_get_thread_area.  Returning %s\\n\", result ? \"PS_OK\" : \"PS_ERR\");\n   return result ? PS_OK : PS_ERR;\n}\n\n#if defined(THREAD_DB_STATIC)\n#define TDB_BIND(SYM) \\\n   p_ ## SYM = SYM\n#else\n#define TDB_BIND(SYM) \\\n   do { \\\n     p_ ## SYM = (SYM ## _t) dlsym(libhandle, #SYM); \\\n     if (!p_ ## SYM) { \\\n       const char *errmsg = dlerror();                                       \\\n       perr_printf(\"Error looking up %s in threaddb.so: %s\\n\", #SYM, errmsg); \\\n       return false; \\\n     } \\\n   } while (0)\n#endif\n\n#if defined(THREAD_DB_PATH)\n#define THREAD_DB_PATH_STR THREAD_DB_PATH\n#else\n#define THREAD_DB_PATH_STR NULL\n#endif\n\nthread_db_process::td_init_t thread_db_process::p_td_init;\nthread_db_process::td_ta_new_t thread_db_process::p_td_ta_new;\nthread_db_process::td_ta_delete_t thread_db_process::p_td_ta_delete;\nthread_db_process::td_ta_event_addr_t thread_db_process::p_td_ta_event_addr;\nthread_db_process::td_ta_set_event_t thread_db_process::p_td_ta_set_event;\nthread_db_process::td_ta_map_lwp2thr_t thread_db_process::p_td_ta_map_lwp2thr;\nthread_db_process::td_ta_event_getmsg_t thread_db_process::p_td_ta_event_getmsg;\nthread_db_process::td_thr_get_info_t thread_db_process::p_td_thr_get_info;\nthread_db_process::td_thr_event_enable_t thread_db_process::p_td_thr_event_enable;\nthread_db_process::td_thr_set_event_t thread_db_process::p_td_thr_set_event;\nthread_db_process::td_thr_event_getmsg_t thread_db_process::p_td_thr_event_getmsg;\nthread_db_process::td_thr_dbsuspend_t thread_db_process::p_td_thr_dbsuspend;\nthread_db_process::td_thr_dbresume_t thread_db_process::p_td_thr_dbresume;\n\nbool thread_db_process::tdb_loaded = false;\nbool thread_db_process::tdb_loaded_result = false;\n\n#if !defined(THREAD_DB_STATIC)\nstatic void *dlopenThreadDB(char *path)\n{\n   std::string filename;\n   std::string alt_filename;\n   if (path) {\n      filename = std::string(path);\n      if (*filename.rend() != '/') {\n         filename += std::string(\"/\");\n      }\n      filename += std::string(\"libthread_db.so\");\n#if !defined(os_bg)\n      //On BG alt_filename would try to load /lib/libthread_db.so, which is\n      // for the IO node.\n      alt_filename = std::string(\"libthread_db.so\");\n#endif\n\n   }\n   else {\n      filename = std::string(\"libthread_db.so\");\n   }\n\n#if defined(os_bgq)\n   alt_filename = filename;\n   filename = std::string(\"/bgsys/drivers/ppcfloor/gnu-linux/powerpc64-bgq-linux/lib/libthread_db.so.1\");\n#endif\n\n   pthrd_printf(\"Opening thread_db with %s\\n\", filename.c_str());\n   void *libhandle = dlopen(filename.c_str(), RTLD_LAZY);\n   if (!libhandle && !alt_filename.empty()) {\n   pthrd_printf(\"Opening thread_db with %s\\n\", alt_filename.c_str());\n      libhandle = dlopen(alt_filename.c_str(), RTLD_LAZY);\n   }\n   if (!libhandle) {\n      const char *errmsg = dlerror();\n      perr_printf(\"Error loading libthread_db.so: %s\\n\", errmsg);\n      return NULL;\n   }\n   return libhandle;\n}\n\n#else\nstatic void *dlopenThreadDB(char *)\n{\n   return (void *) 0x1;  //Return anything non-NULL\n}\n#endif\n\nbool thread_db_process::loadedThreadDBLibrary()\n{\n   if (tdb_loaded)\n      return tdb_loaded_result;\n   tdb_loaded = true;\n   \n   void *libhandle = dlopenThreadDB(THREAD_DB_PATH_STR);\n   if (!libhandle)\n      return false;\n\n   TDB_BIND(td_init);\n   TDB_BIND(td_ta_new);\n   TDB_BIND(td_ta_delete);\n   TDB_BIND(td_ta_event_addr);\n   TDB_BIND(td_ta_set_event);\n   TDB_BIND(td_ta_event_getmsg);\n   TDB_BIND(td_ta_map_lwp2thr);\n   TDB_BIND(td_thr_get_info);\n   TDB_BIND(td_thr_event_enable);\n   TDB_BIND(td_thr_set_event);\n   TDB_BIND(td_thr_event_getmsg);\n   TDB_BIND(td_thr_dbsuspend);\n   TDB_BIND(td_thr_dbresume);\n\n   pthrd_printf(\"Successfully loaded thread_db.so library\\n\");\n   tdb_loaded_result = true;\n   return true;\n}\n\n#ifndef CASE_RETURN_STR\n#define CASE_RETURN_STR(x) case x: return #x;\n#endif\n\nstatic const char *tdErr2Str(td_err_e errVal) {\n    switch(errVal) {\n        CASE_RETURN_STR(TD_ERR)\n        CASE_RETURN_STR(TD_OK)\n        CASE_RETURN_STR(TD_BADKEY)\n        CASE_RETURN_STR(TD_BADPH)\n        CASE_RETURN_STR(TD_BADSH)\n        CASE_RETURN_STR(TD_BADTA)\n        CASE_RETURN_STR(TD_BADTH)\n        CASE_RETURN_STR(TD_DBERR)\n        CASE_RETURN_STR(TD_MALLOC)\n        CASE_RETURN_STR(TD_NOAPLIC)\n        CASE_RETURN_STR(TD_NOCAPAB)\n        CASE_RETURN_STR(TD_NOEVENT)\n        CASE_RETURN_STR(TD_NOFPREGS)\n        CASE_RETURN_STR(TD_NOLIBTHREAD)\n        CASE_RETURN_STR(TD_NOLWP)\n        CASE_RETURN_STR(TD_NOMSG)\n        CASE_RETURN_STR(TD_NOSV)\n        CASE_RETURN_STR(TD_NOTHR)\n        CASE_RETURN_STR(TD_NOTSD)\n        CASE_RETURN_STR(TD_NOXREGS)\n        CASE_RETURN_STR(TD_PARTIALREG)\n        default:\n            return \"?\";\n    }\n}\n\nEvent::ptr thread_db_process::decodeThreadEvent(td_event_msg_t *eventMsg, bool &async)\n{\n   td_thrinfo_t info;\n   async = false;\n#if !defined(os_freebsd)\n   td_thrhandle_t *handle = const_cast<td_thrhandle_t *>(eventMsg->th_p);\n#else\n   td_thrhandle_t *handle = (td_thrhandle_t *)(eventMsg->th_p);\n#endif\n   pthrd_printf(\"Decoding thread event on %u\\n\", getPid());\n   async_ret_t result = ll_fetchThreadInfo(handle, &info);\n   if (result == aret_error) {\n      pthrd_printf(\"Failed to fetch thread info\\n\");\n      return Event::ptr();\n   }\n   if (result == aret_async) {\n      async = true;\n      pthrd_printf(\"Returning async from decodeThreadEvent\\n\");\n      return Event::ptr();\n   }\n   Dyninst::LWP lwp = (Dyninst::LWP) info.ti_lid;\n   int_thread *thr = threadPool()->findThreadByLWP(lwp); //thr may be NULL if OS doesn't support LWP events (BG/P) \n   switch(eventMsg->event) {\n      case TD_CREATE:\n      {\n         pthrd_printf(\"Decoded to user thread create of %d/%d\\n\", getPid(), lwp);\n\n         EventNewUserThread::ptr new_ev = EventNewUserThread::ptr(new EventNewUserThread());\n         new_ev->setProcess(proc());\n         new_ev->setThread(thr ? thr->thread() : Thread::ptr());\n         new_ev->setSyncType(Event::sync_process);\n         int_eventNewUserThread *iev = new_ev->getInternalEvent();\n\n         new_thread_data_t *thrdata = (new_thread_data_t *) malloc(sizeof(new_thread_data_t));\n         thrdata->thr_handle = new td_thrhandle_t(*handle);\n         thrdata->thr_info = info;\n         thrdata->threadHandle_alloced = true;\n\n         iev->raw_data = (void *) thrdata;\n         iev->lwp = lwp;\n\n         if (threadPool()->initialThread() == thr)\n            initialThreadEventCreated = true;\n\n         return new_ev;\n      }\n      case TD_DEATH: {\n         pthrd_printf(\"Decoded to user thread death of %d/%d\\n\", getPid(), lwp);\n         if (!thr) {\n            perr_printf(\"Error.  Got thread delete event for unknown LWP\\n\");\n            return Event::ptr();\n         }\n\n         EventUserThreadDestroy::ptr new_ev = EventUserThreadDestroy::ptr(new EventUserThreadDestroy(EventType::Pre));\n         new_ev->setProcess(proc());\n         new_ev->setThread(thr->thread());\n         new_ev->setSyncType(Event::sync_process);\n\n         return new_ev;\n      }\n      default: {\n         pthrd_printf(\"Unimplemented libthread_db event encountered. Skipping for now.\\n\");\n         break;\n      }\n   }\n\n   return Event::ptr();\n}\n\nvolatile bool thread_db_process::thread_db_initialized = false;\nMutex<> thread_db_process::thread_db_init_lock;\n\nthread_db_process::thread_db_process(Dyninst::PID p, std::string e, std::vector<std::string> envp, std::vector<std::string> a, std::map<int, int> f) :\n  int_process(p, e, a, envp, f),\n  int_threadTracking(p, e, a, envp, f),\n  thread_db_proc_initialized(false),\n  threadAgent(NULL),\n  createdThreadAgent(false),\n  self(NULL),\n  trigger_thread(NULL),\n  hasAsyncPending(false),\n  initialThreadEventCreated(false),\n  setEventSet(false),\n  completed_post(false),\n  track_threads(ThreadTracking::getDefaultTrackThreads())\n{\n   if (!loadedThreadDBLibrary())\n      return;\n   self = new ps_prochandle();\n   assert(self);\n   self->thread_db_proc = this;\n}\n\nthread_db_process::thread_db_process(Dyninst::PID pid_, int_process *p) :\n  int_process(pid_, p),\n  int_threadTracking(pid_, p), \n  thread_db_proc_initialized(false),\n  threadAgent(NULL),\n  createdThreadAgent(false),\n  self(NULL),\n  trigger_thread(NULL),\n  hasAsyncPending(false),\n  initialThreadEventCreated(false),\n  setEventSet(false),\n  completed_post(false),\n  track_threads(ThreadTracking::getDefaultTrackThreads())\n{\n   if (!loadedThreadDBLibrary())\n      return;\n   self = new ps_prochandle();\n   assert(self);\n   self->thread_db_proc = this;\n}\n\nthread_db_process::~thread_db_process() \n{\n    // Free the breakpoints allocated for events\n    map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator brkptIter;\n    for(brkptIter = addr2Event.begin(); brkptIter != addr2Event.end(); ++brkptIter) {\n        delete brkptIter->second.first;\n    }\n\n    if (self)\n       delete self;\n}\n\nasync_ret_t thread_db_process::initThreadWithHandle(td_thrhandle_t *thr, td_thrinfo_t *info, LWP lwp)\n{\n   pthrd_printf(\"initThreadWithHandle on %d/%d\\n\", getPid(), lwp);\n\n   td_thrinfo_t tinfo;\n   if (!info) {\n      async_ret_t result = ll_fetchThreadInfo(thr, &tinfo);\n      if (result == aret_error) {\n         pthrd_printf(\"Error calling ll_fetchThreadInfo from initThreadWithHandle\\n\");\n         return aret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"Returning async from initThreadWithHandle\\n\");\n         return aret_async;\n      }\n      info = &tinfo;\n   }\n\n   if (lwp == NULL_LWP) {\n      lwp = (Dyninst::LWP) info->ti_lid;\n      pthrd_printf(\"initThreadWithHandle found thread %d/%d\\n\", getPid(), lwp);\n   }\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(threadPool()->findThreadByLWP(lwp));\n   if (!tdb_thread) {\n      perr_printf(\"Error.  Thread_db reports thread %d/%d, but couldn't find existing LWP\\n\",\n                  getPid(), lwp);\n      return aret_error;\n   }\n   if (tdb_thread->thread_initialized) {\n      return aret_success;\n   }\n   pthrd_printf(\"thread_db handling thread create for %d/%d\\n\", getPid(), lwp);\n   tdb_thread->threadHandle = thr;\n   tdb_thread->tinfo = *info;\n   if (info->ti_tid)\n      tdb_thread->tinfo_initialized = true;\n\n   getMemCache()->markToken(token_seteventreporting);\n   async_ret_t result = tdb_thread->setEventReporting(true);\n   if (result == aret_error) {\n      pthrd_printf(\"Error in setEventReporting for %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      return aret_error;\n   }\n   if (result == aret_async) {\n      pthrd_printf(\"Async return in setEventReporting for %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      return aret_async;\n   }\n   getMemCache()->condense();\n   tdb_thread->thread_initialized = true;\n   return aret_success;\n}\n\n\nasync_ret_t thread_db_process::handleThreadAttach(td_thrhandle_t *thr, Dyninst::LWP lwp)\n{\n   return initThreadWithHandle(thr, NULL, lwp);\n}\n\nasync_ret_t thread_db_process::initThreadDB() {\n    // Q: Why isn't this in the constructor? \n    // A: This function depends on the corresponding thread library being loaded\n    // and this event occurs some time after process creation.\n\n   if (!track_threads) {\n      return aret_success;\n   }\n    // Make sure thread_db is initialized - only once for all instances\n   if( !thread_db_initialized ) {\n      pthrd_printf(\"Initializing thread_db library\\n\");\n      thread_db_init_lock.lock();\n      if( !thread_db_initialized ) {\n         if (!loadedThreadDBLibrary()) {\n            setLastError(err_internal, \"libthread_db was not loaded\");\n            thread_db_init_lock.unlock();\n            return aret_error;\n         }\n         td_err_e errVal;\n         if( TD_OK != (errVal = p_td_init()) ) {\n            perr_printf(\"Failed to initialize libthread_db: %s(%d)\\n\",\n                        tdErr2Str(errVal), errVal);\n            setLastError(err_internal, \"libthread_db initialization failed\");\n            thread_db_init_lock.unlock();\n            return aret_error;\n          }\n         pthrd_printf(\"Sucessfully initialized thread_db\\n\");\n         thread_db_initialized = true;\n      }\n      thread_db_init_lock.unlock();\n   }\n   if (thread_db_proc_initialized) {\n      return aret_success;\n   }\n\n   getMemCache()->markToken(token_init);   \n   // Create the thread agent\n   td_err_e errVal;\n   if (!createdThreadAgent)\n   {\n      pthrd_printf(\"Creating threadAgent\\n\");\n      errVal = p_td_ta_new(self, &threadAgent);\n      switch(errVal) {\n         case TD_OK:\n            pthrd_printf(\"Retrieved thread agent from thread_db\\n\");\n            break;\n         case TD_NOLIBTHREAD:\n            pthrd_printf(\"Debuggee isn't multithreaded at this point, libthread_db not enabled\\n\");\n            return aret_success;\n         case TD_ERR:\n            if (getMemCache()->hasPendingAsync()) {\n               pthrd_printf(\"Postponing thread_db initialization for async\\n\");\n               return aret_async;\n            }\n            //FALLTHROUGH\n         default:\n            perr_printf(\"Failed to create thread agent: %s(%d)\\n\",\n                        tdErr2Str(errVal), errVal);\n            thread_db_proc_initialized = true;\n            setLastError(err_internal, \"Failed to create libthread_db agent\");\n            return aret_error;\n      }\n      createdThreadAgent = true;\n   }\n\n   bool hasAsync = false;\n   set<pair<td_thrhandle_t *, LWP> > all_handles;\n   for (int_threadPool::iterator i = threadPool()->begin(); i != threadPool()->end(); i++) {\n      thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(*i);\n      \n      if (tdb_thread->threadHandle_alloced) {\n         all_handles.insert(pair<td_thrhandle_t *, LWP>(tdb_thread->threadHandle, tdb_thread->getLWP()));\n         continue;\n      }\n      \n      if (!tdb_thread->threadHandle) {\n         tdb_thread->threadHandle = new td_thrhandle_t;\n         memset(tdb_thread->threadHandle, 0, sizeof(td_thrhandle_t));\n      }\n      \n      pthrd_printf(\"lwp2thr on %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      errVal = p_td_ta_map_lwp2thr(getThreadDBAgent(), tdb_thread->getLWP(), tdb_thread->threadHandle);\n      if (errVal != TD_OK) {\n         if (getMemCache()->hasPendingAsync()) {\n            pthrd_printf(\"Hit async during lwp2thr\\n\");\n            hasAsync = true;\n            continue;\n         }\n         perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                     tdb_thread->getLWP(), tdErr2Str(errVal), errVal);\n         setLastError(err_internal, \"Failed to get thread_db thread handle\");\n         delete tdb_thread->threadHandle;\n         tdb_thread->threadHandle = NULL;\n         continue;\n      }\n      pthrd_printf(\"Successful lwp2thr on %d/%d\\n\", getPid(), tdb_thread->getLWP());\n      tdb_thread->threadHandle_alloced = true;\n      all_handles.insert(pair<td_thrhandle_t *, LWP>(tdb_thread->threadHandle, tdb_thread->getLWP()));\n   }\n   if (hasAsync) {\n      pthrd_printf(\"Postponing lwp2thr for async\\n\");\n      return aret_async;\n   }\n\n   pthrd_printf(\"handleThreadAttach for %d threads\\n\", (int) all_handles.size());\n   for (set<pair<td_thrhandle_t *, LWP> >::iterator i = all_handles.begin(); i != all_handles.end(); i++)\n   {\n      async_ret_t result = handleThreadAttach(i->first, i->second);\n      if (result == aret_error) {\n         perr_printf(\"Error handling thread_db attach\\n\");\n         return aret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"handleThreadAttach returned async in initThreadDB\\n\");\n         return aret_async;\n      }\n   }\n   \n   // Enable all events\n   td_thr_events_t eventMask;\n#if defined(td_event_fillset)\n   //Macro on GNU libc\n   td_event_fillset(&eventMask);\n#elif defined(os_freebsd)\n   //Inline header file function on FreeBSD\n   td_event_fillset(&eventMask);\n#else\n//Need to make td_event_fillset a function pointer if this hits\n#error td_event_fillset is not a macro on this platform\n#endif\n\n   if (!setEventSet) {\n      getMemCache()->markToken(token_setevent);\n      errVal = p_td_ta_set_event(threadAgent, &eventMask);\n      if( errVal != TD_OK && getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"Async return from td_ta_set_event in initThreadDB\\n\");\n         return aret_async;\n      }\n      setEventSet = true;\n      getMemCache()->condense();\n      if (errVal != TD_OK) {\n         perr_printf(\"Failed to enable events: %s(%d)\\n\",\n                     tdErr2Str(errVal), errVal);\n         setLastError(err_internal, \"Failed to enable libthread_db events\");\n         thread_db_proc_initialized = true;\n         return aret_error;\n      }\n   }\n\n    // Determine the addresses for all events\n   td_event_e allEvents[] = { TD_CATCHSIG, TD_CONCURRENCY, TD_CREATE,\n                              TD_DEATH, TD_IDLE, TD_LOCK_TRY, TD_PREEMPT, TD_PRI_INHERIT,\n                              TD_READY, TD_REAP, TD_SLEEP, TD_SWITCHFROM, TD_SWITCHTO,\n                              TD_TIMEOUT };\n\n   for(unsigned i = 0; i < (sizeof(allEvents)/sizeof(td_event_e)); ++i) {\n      td_notify_t notifyResult;\n      errVal = p_td_ta_event_addr(threadAgent, allEvents[i], &notifyResult);\n      \n      // This indicates that the event isn't supported\n      if( TD_OK != errVal ) continue;\n      \n      assert( notifyResult.type == NOTIFY_BPT && \"Untested notify type\" );\n      \n      EventType newEvent;\n      switch(allEvents[i]) {\n         case TD_CREATE:\n            newEvent = EventType(EventType::Post, EventType::ThreadCreate);\n            pthrd_printf(\"Installing breakpoint for thread creation events\\n\");\n            break;\n         case TD_DEATH:\n            newEvent = EventType(EventType::Post, EventType::ThreadDestroy);\n            pthrd_printf(\"Installing breakpoint for thread destroy events\\n\");\n            break;\n         default:\n            pthrd_printf(\"Unimplemented libthread_db event encountered. Skipping for now.\\n\");\n            continue;\n      }\n      \n      Address addr = (Address) notifyResult.u.bptaddr;\n      pthrd_printf(\"Received address of 0x%lx for breakpoint, checking platform conversion\\n\",\n\t\t   addr);\n      if( !plat_convertToBreakpointAddress(addr, triggerThread()) ) {\n         perr_printf(\"Failed to determine breakpoint address\\n\");\n         setLastError(err_internal, \"Failed to install new thread_db event breakpoint\");\n         thread_db_proc_initialized = true;\n         return aret_error;\n      }\n      pthrd_printf(\"Post-conversion, using address of 0x%lx\\n\", addr);\n#if defined(os_freebsd)\n      notifyResult.u.bptaddr = (psaddr_t) addr;\n#else\n      notifyResult.u.bptaddr = (void *) addr;\n#endif \n      int_breakpoint *newEventBrkpt = new int_breakpoint(Breakpoint::ptr());\n      newEventBrkpt->setProcessStopper(true);\n      if( !addBreakpoint(addr, newEventBrkpt))\n      {\n         perr_printf(\"Failed to install new event breakpoint\\n\");\n         setLastError(err_internal, \"Failed to install new thread_db event breakpoint\");\n         delete newEventBrkpt;\n         thread_db_proc_initialized = true;\n         return aret_error;\n         }\n      \n      pair<map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator, bool> insertIter;\n      insertIter = addr2Event.insert(make_pair(addr, make_pair(newEventBrkpt, newEvent)));\n\n      assert( insertIter.second && \"event breakpoint address not unique\" );\n   }\n   \n   thread_db_proc_initialized = true;\n   return aret_success;\n}\n\nvoid thread_db_process::freeThreadDBAgent() {\n    // This code cannot be in the destructor because it makes use of\n    // the proc_service interface and this makes calls to functions\n    // that are pure virtual in this class.\n    //\n    // A possible, better solution would be to make the functions static\n    // but we lose all the convenience of pure virtual functions\n    //\n    // At any rate, this function should be called from a derived class' \n    // destructor for the time being.\n\n    if( thread_db_initialized && threadAgent ) {\n        td_err_e errVal = p_td_ta_delete(threadAgent);\n        if( TD_OK != errVal ) {\n            perr_printf(\"Failed to delete thread agent: %s(%d)\\n\",\n                    tdErr2Str(errVal), errVal);\n        }\n        assert( TD_OK == errVal && \"Failed to delete thread agent\" );\n        threadAgent = NULL;\n    }\n}\n\nconst char *thread_db_process::getThreadLibName(const char *)\n{\n   return \"\";\n}\n\nbool thread_db_process::decodeTdbLWPExit(EventLWPDestroy::ptr lwp_ev)\n{\n   thread_db_thread *db_thread = dynamic_cast<thread_db_thread *>(lwp_ev->getThread()->llthrd());\n   assert(db_thread);\n   \n   if (db_thread->destroyed || !db_thread->thread_initialized)\n      return false;\n\n   pthrd_printf(\"Decoded LWP exit without thread exit on %d/%d.  Faking thread exit event\\n\",\n                db_thread->llproc()->getPid(), db_thread->getLWP());\n\n   EventUserThreadDestroy::ptr new_ev = EventUserThreadDestroy::ptr(new EventUserThreadDestroy(EventType::Post));\n   new_ev->setProcess(db_thread->llproc()->proc());\n   new_ev->setThread(db_thread->thread());\n   new_ev->setSyncType(Event::async);\n   lwp_ev->addSubservientEvent(new_ev);\n\n   return true;\n}\n\nasync_ret_t thread_db_process::decodeTdbBreakpoint(EventBreakpoint::ptr bp)\n{ \n    // Decoding thread_db events needs to be a two-step process:\n    // 1) Create events depending on the breakpoint address\n    //    Don't get events from thread_db as this can write to memory\n    //    and threads could currently be running -- introduces some race\n    //    conditions where the running threads could be modifying data\n    //    structures thread_db is accessing\n    //    Just create placeholder events that can later be filled in with\n    //    more information\n    // 2) Get events from thread_db in the handler for the event, at this\n    //    point all threads are stopped and it is safe to make changes to\n    //    memory because the parent event is a breakpoint and requires\n    //    that all threads are stopped\n    Dyninst::Address addr = bp->getAddress();\n    \n    // Determine what type of event occurs at the specified address\n    map<Dyninst::Address, pair<int_breakpoint *, EventType> >::iterator addrIter;\n    addrIter = addr2Event.find(addr);\n    if (addrIter == addr2Event.end()) \n       return aret_error;\n\n    vector<Event::ptr> threadEvents;\n\n    EventType::Code ecode = addrIter->second.second.code();\n    pthrd_printf(\"Address 0x%lx corresponds to a thread %s breakpoint.\\n\",\n                 addr, ecode == EventType::ThreadCreate ? \"create\" : \"destroy\");\n    switch(ecode) {\n       case EventType::ThreadCreate:\n       case EventType::ThreadDestroy:\n          threadEvents.push_back(EventThreadDB::ptr(new EventThreadDB()));\n          break;\n       default:\n          pthrd_printf(\"Failed to decode any thread events due to the breakpoint\\n\");\n          return aret_error;\n    }\n\n    for (vector<Event::ptr>::iterator i = threadEvents.begin(); i != threadEvents.end(); i++) {\n       Event::ptr ev = *i;\n       if (!ev->getThread()) \n          ev->setThread(bp->getThread());\n       if (!ev->getProcess()) \n          ev->setProcess(proc());\n       if (ev->getSyncType() == Event::unset)\n          ev->setSyncType(Event::sync_process);\n       bp->addSubservientEvent(ev);\n    }\n    bp->setSuppressCB(true);\n    return aret_success;\n}\n\ntd_thragent_t *thread_db_process::getThreadDBAgent() {\n    return threadAgent;\n}\n\nstatic string stripLibraryName(const char *libname)\n{\n   const char *filename_c = strrchr(libname, '/');\n   if (!filename_c)\n      filename_c = strrchr(libname, '\\\\');\n   if (!filename_c) \n      filename_c = libname;\n   else \n      filename_c++;\n   \n   const char *lesser_ext = NULL;\n   const char *dot_ext = strchr(filename_c, '.');\n   if (dot_ext)\n      lesser_ext = dot_ext;\n   const char *dash_ext = strchr(filename_c, '-');\n   if (dash_ext && (!lesser_ext || dash_ext < lesser_ext))\n      lesser_ext = dash_ext;\n\n   if (!lesser_ext) {\n      return std::string(filename_c);\n   }\n   return std::string(filename_c, lesser_ext - filename_c);\n}\n\nps_err_e thread_db_process::getSymbolAddr(const char *objName, const char *symName,\n        psaddr_t *symbolAddr)\n{\n    SymReader *objSymReader = NULL;\n    int_library *lib = NULL;\n    \n    if (plat_isStaticBinary()) {\n       // For static executables, we need to search the executable instead of the\n       // thread library. \n       assert(memory()->libs.size() == 1);\n       lib = *memory()->libs.begin();\n    }\n    else\n    {\n       // FreeBSD implementation doesn't set objName\n       const char *name_c = objName ? objName : getThreadLibName(symName);\n       std::string name = stripLibraryName(name_c);\n       \n       for (set<int_library *>::iterator i = memory()->libs.begin(); i != memory()->libs.end(); i++) {\n          int_library *l = *i;\n          if (strstr(l->getName().c_str(), name.c_str())) {\n             lib = l;\n             break;\n          }\n       }\n    }\n\n    if( NULL == lib ) {\n       pthrd_printf(\"Didn't yet find loaded thread library\\n\");\n       return PS_ERR;\n    }\n\n    objSymReader = getSymReader()->openSymbolReader(lib->getName());\n    if( NULL == objSymReader ) {\n        perr_printf(\"Failed to open symbol reader for %s\\n\",\n                    lib->getName().c_str());\n        setLastError(err_internal, \"Failed to open executable for symbol reading\");\n        return PS_ERR;\n    }\n\n    Symbol_t lookupSym = objSymReader->getSymbolByName(string(symName));\n\n    if( !objSymReader->isValidSymbol(lookupSym) ) {\n       pthrd_printf(\"thread_db getSymbolAddr(%s, %s) = none\\n\", objName ? objName : \"NULL\", \n                    symName ? symName : \"NULL\");\n       return PS_NOSYM;\n    }\n    \n    Address tmp = lib->getAddr() + objSymReader->getSymbolOffset(lookupSym);\n    if (getAddressWidth() == 4) {\n       tmp &= 0xffffffff;\n    }\n    \n    *symbolAddr = (psaddr_t) tmp;\n\n    pthrd_printf(\"thread_db getSymbolAddr(%s, %s) = %p\\n\", objName ? objName : \"NULL\", \n                 symName ? symName : \"NULL\", (void *) *symbolAddr);\n    return PS_OK;\n}\n\n\nasync_ret_t thread_db_process::post_create(std::set<response::ptr> &async_responses)\n{\n   async_ret_t result;\n   if (!completed_post) {\n      result = int_process::post_create(async_responses);\n      if (result != aret_success)\n         return result;\n      completed_post = true;\n   }\n\n   err_t last_error = getLastError();\n   const char *last_err_msg = getLastErrorMsg();\n\n   getMemCache()->setSyncHandling(true);\n   for (;;) {\n      result = initThreadDB();\n      if (result != aret_async)\n         break;\n      getMemCache()->getPendingAsyncs(async_responses);\n      return aret_async;\n   }\n   getMemCache()->setSyncHandling(false);\n\n   setLastError(last_error, last_err_msg);\n   return aret_success; //Swallow these errors, thread_db failure does not bring down rest of startup\n}\n\nasync_ret_t thread_db_process::post_attach(bool wasDetached, set<response::ptr> &aresps) {\n   async_ret_t result;\n   if (!completed_post) {\n      result = int_process::post_attach(wasDetached, aresps);\n      if (result != aret_success)\n         return result;\n      completed_post = true;\n   }\n   \n   err_t last_error = getLastError();\n   const char *last_err_msg = getLastErrorMsg();\n\n   getMemCache()->setSyncHandling(true);\n   for (;;) {\n      result = initThreadDB();\n      if (result != aret_async)\n         break;\n      getMemCache()->getPendingAsyncs(aresps);\n      return aret_async;\n   }\n   getMemCache()->setSyncHandling(false);\n\n   setLastError(last_error, last_err_msg);\n   return aret_success; //Swallow these errors, thread_db failure does not bring down rest of startup\n}\n\n#if 0\n#warning TODO fix detach part in post attach rewrite\nbool thread_db_process::post_attach(bool wasDetached) {\n    if( !int_process::post_attach(wasDetached) ) return false;\n\n    if( !wasDetached ) {\n        return initThreadDB();\n    }else{\n        // Need to initialize all new threads\n        bool success = true;\n        td_err_e errVal;\n        for (int_threadPool::iterator i = threadPool()->begin(); i != threadPool()->end(); i++) {\n           thread_db_thread *tdb_thread = static_cast<thread_db_thread *>(*i);\n           if( tdb_thread->thread_initialized ) continue;\n\n           tdb_thread->threadHandle = new td_thrhandle_t;\n\n           errVal = td_ta_map_lwp2thr(getThreadDBAgent(), tdb_thread->getLWP(), tdb_thread->threadHandle);\n           if (errVal != TD_OK) {\n              perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                          tdb_thread->getLWP(), tdErr2Str(errVal), errVal);\n              setLastError(err_internal, \"Failed to get thread_db thread handle\");\n              delete tdb_thread->threadHandle;\n              tdb_thread->threadHandle = NULL;\n              success = false;\n              continue;\n           }\n           tdb_thread->threadHandle_alloced = true;\n\n           if( !handleThreadAttach(tdb_thread->threadHandle) ) {\n               perr_printf(\"Error handling thread_db attach\\n\");\n               success = false;\n           }\n        }\n\n        return success;\n    }\n}\n#endif\n\nbool thread_db_process::isSupportedThreadLib(string libName) {\n   return (libName.find(\"libpthread\") != string::npos);\n}\n\nvoid thread_db_process::addThreadDBHandlers(HandlerPool *hpool) {\n   static bool initialized = false;\n   static ThreadDBLibHandler *libHandler = NULL;\n   static ThreadDBCreateHandler *createHandler = NULL;\n   static ThreadDBDestroyHandler *destroyHandler = NULL;\n   static ThreadDBDispatchHandler *dispatchHandler = NULL;\n   if( !initialized ) {\n      libHandler = new ThreadDBLibHandler();\n      createHandler = new ThreadDBCreateHandler();\n      destroyHandler = new ThreadDBDestroyHandler();\n      dispatchHandler = new ThreadDBDispatchHandler();\n      initialized = true;\n   }\n   hpool->addHandler(libHandler);\n   hpool->addHandler(createHandler);\n   hpool->addHandler(destroyHandler);\n   hpool->addHandler(dispatchHandler);\n}\n\nbool thread_db_process::plat_getLWPInfo(lwpid_t, void *) \n{\n   perr_printf(\"Attempt to use unsupported plat_getLWPInfo\\n\");\n   return false;\n}\n\nbool thread_db_process::plat_supportThreadEvents()\n{\n   if (!loadedThreadDBLibrary()) {\n      return false;\n   }\n   return true;\n}\n\nbool thread_db_thread::plat_convertToSystemRegs(const int_registerPool &,\n                                                unsigned char *, bool)\n{\n    return true;\n}\n\nint_thread *thread_db_process::triggerThread() const\n{\n   return trigger_thread;\n}\n\nasync_ret_t thread_db_process::ll_fetchThreadInfo(td_thrhandle_t *th, td_thrinfo_t *info)\n{\n   td_err_e result = thread_db_process::p_td_thr_get_info(th, info);\n   if (result != TD_OK) {\n      if (getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"Async return from td_thr_get_info in ll_fetchThreadInfo\\n\");\n         return aret_async;\n      }\n      perr_printf(\"Error calling td_thr_get_info: %s (%d)\\n\", tdErr2Str(result), (int) result);\n      return aret_error;\n   }\n   pthrd_printf(\"Successful ll_fetchThreadInfo for handle %p - tid = %lu, lid = %lu\\n\", th, (unsigned long) info->ti_tid, (unsigned long) info->ti_lid);\n   return aret_success;\n}\n\nThreadDBDispatchHandler::ThreadDBDispatchHandler() :\n   Handler(\"thread_db Dispatch Handler\")\n{\n}\n\nThreadDBDispatchHandler::~ThreadDBDispatchHandler()\n{\n}\n\nint ThreadDBDispatchHandler::getPriority() const\n{\n   return Handler::PostPlatformPriority;\n}\n\nHandler::handler_ret_t ThreadDBDispatchHandler::handleEvent(Event::ptr ev)\n{\n   /**\n    * All we know is that we got a thread_db breakpoint, but we don't\n    * know whether that was a thread create/destroy, or any information\n    * about those events.  We'll collect that info here, then add\n    * UserThreadCreate or UserThreadDestroy events as 'late' events \n    * (means they were generated at handle time) to this event.\n    **/\n   pthrd_printf(\"At top of ThreadDB Dispatch handler\\n\");\n   EventThreadDB::ptr etdb = ev->getEventThreadDB();\n   assert(etdb);\n   int_eventThreadDB *int_ev = etdb->getInternal();\n   assert(int_ev);\n\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(etdb->getProcess()->llproc());\n   assert(proc);\n\n   if (proc->dispatch_event && proc->dispatch_event != etdb) {\n      //We don't need to handle a new dispatch event if another is in\n      //progress.  We'll drop the second.\n      pthrd_printf(\"Dropping dispatch event, another is in progress\\n\");\n      return ret_success;\n   }\n   proc->dispatch_event = etdb;\n\n   if (!int_ev->completed_new_evs) {\n      async_ret_t result = proc->getEventForThread(int_ev);\n      if (result == aret_async) {\n         pthrd_printf(\"getEventForThread returned async\\n\");\n         return ret_async;\n      }\n      int_ev->completed_new_evs = true;\n      if (result == aret_error) {\n         pthrd_printf(\"getEventForThread returned error\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return ret_error;\n      }\n   }\n\n   thread_db_thread *main_thread = dynamic_cast<thread_db_thread *>(proc->threadPool()->initialThread());\n   if (main_thread->tinfo_initialized)\n      proc->initialThreadEventCreated = true;\n\n   if (!proc->initialThreadEventCreated) {\n      pthrd_printf(\"Creating thread event for main thread\\n\");\n\n      if (!main_thread->threadHandle) {\n         main_thread->threadHandle = new td_thrhandle_t;\n         bzero(&main_thread->threadHandle, sizeof(td_thrhandle_t));\n         main_thread->threadHandle_alloced = true;\n      }\n\n      int td_result = thread_db_process::p_td_ta_map_lwp2thr(proc->getThreadDBAgent(), main_thread->getLWP(), main_thread->threadHandle);\n      if (td_result == TD_ERR && proc->getMemCache()->hasPendingAsync()) {\n         pthrd_printf(\"async return from td_ta_map_lwp2thr while creating event for main thread\\n\");\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;\n      }\n      else if (td_result == TD_ERR) {\n         perr_printf(\"Error return from td_ta_map_lwp2thr while creating event for main thread\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return ret_error;\n      }\n\n      td_thrinfo_t tinfo;\n      bzero(&tinfo, sizeof(td_thrinfo_t));\n      async_ret_t result = proc->ll_fetchThreadInfo(main_thread->threadHandle, &tinfo);\n      if (result == aret_async) {\n         pthrd_printf(\"Async return during ll_fetchThreadInfo for main thread\\n\");\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;         \n      }\n      if (result == aret_error) {\n         pthrd_printf(\"Error return during ll_fetchThreadInfo for main thread\\n\");\n         proc->dispatch_event = EventThreadDB::ptr();\n         return Handler::ret_error;\n      }\n      if (tinfo.ti_tid) {\n         new_thread_data_t *thrdata = (new_thread_data_t *) malloc(sizeof(new_thread_data_t));\n         thrdata->thr_handle = main_thread->threadHandle;\n         thrdata->thr_info = tinfo;\n         thrdata->threadHandle_alloced = main_thread->threadHandle_alloced;\n         \n         EventNewUserThread::ptr new_ev = EventNewUserThread::ptr(new EventNewUserThread());\n         new_ev->setProcess(proc->proc());\n         new_ev->setThread(main_thread->thread());\n         new_ev->setSyncType(Event::sync_process);\n         new_ev->getInternalEvent()->thr = main_thread;\n         new_ev->getInternalEvent()->lwp = main_thread->getLWP();\n         new_ev->getInternalEvent()->raw_data = (void *) thrdata;\n         proc->initialThreadEventCreated = true;\n         int_ev->new_evs.insert(new_ev);\n         pthrd_printf(\"Success creating event for main thread\\n\");\n      }\n      else {\n         pthrd_printf(\"TID info for main thread not ready yet\\n\");\n      }\n   }\n   pthrd_printf(\"Got %u events, adding as late events\\n\", (unsigned int) int_ev->new_evs.size());\n   for (set<Event::ptr>::iterator i = int_ev->new_evs.begin(); i != int_ev->new_evs.end(); i++) {\n      proc->handlerPool()->addLateEvent(*i);\n   }\n   proc->dispatch_event = EventThreadDB::ptr();\n   return ret_success;\n}\n\nvoid ThreadDBDispatchHandler::getEventTypesHandled(std::vector<EventType> &etypes)\n{\n   etypes.push_back(EventType(EventType::None, EventType::ThreadDB));\n}\n\nThreadDBLibHandler::ThreadDBLibHandler() :\n    Handler(\"thread_db Library Handler\")\n{\n}\n\nThreadDBLibHandler::~ThreadDBLibHandler() \n{\n}\n\nHandler::handler_ret_t ThreadDBLibHandler::handleEvent(Event::ptr ev) {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\\n\");\n      return Handler::ret_success;\n   }\n\n   EventLibrary::const_ptr libEv = ev->getEventLibrary();\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(ev->getProcess()->llproc());\n   const set<Library::ptr> &addLibs = libEv->libsAdded();\n\n   set<Library::ptr>::iterator libIter;\n   for( libIter = addLibs.begin(); libIter != addLibs.end(); ++libIter ) {\n      if( ! proc->isSupportedThreadLib((*libIter)->getName()) )\n         continue;\n      \n      pthrd_printf(\"Enabling thread_db support for pid %d\\n\",\n                   proc->getPid());\n      async_ret_t ret = proc->initThreadDB();\n \n      if (ret == aret_error) {\n         pthrd_printf(\"Failed to initialize thread_db for pid %d\\n\",\n                      proc->getPid());\n         return Handler::ret_error;\n      }\n      else if (ret == aret_success) {\n         return Handler::ret_success;\n      }\n      else if (ret == aret_async) {\n         std::set<response::ptr> resps;\n         proc->getMemCache()->getPendingAsyncs(resps);\n         proc->handlerPool()->notifyOfPendingAsyncs(resps, ev);\n         return Handler::ret_async;\n      }\n   }\n   \n   return Handler::ret_success;\n}\n\nint ThreadDBLibHandler::getPriority() const {\n    return PostPlatformPriority;\n}\n\nvoid ThreadDBLibHandler::getEventTypesHandled(vector<EventType> &etypes) {\n    etypes.push_back(EventType(EventType::None, EventType::Library));\n}\n\nThreadDBCreateHandler::ThreadDBCreateHandler() :\n    Handler(\"thread_db New Thread Handler\")\n{\n}\n\nThreadDBCreateHandler::~ThreadDBCreateHandler() \n{\n}\n\nint ThreadDBCreateHandler::getPriority() const\n{\n   //After dispatch handler, which runs at PostPlatformPriority\n   return Handler::PostPlatformPriority + 1;\n}\n\nHandler::handler_ret_t ThreadDBCreateHandler::handleEvent(Event::ptr ev) {\n  pthrd_printf(\"ThreadDBCreateHandler::handleEvent\\n\");\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\");\n      return Handler::ret_success;\n   }\n\n   EventNewUserThread::ptr threadEv = ev->getEventNewUserThread();\n   thread_db_process *tdb_proc = dynamic_cast<thread_db_process *>(threadEv->getProcess()->llproc());\n   thread_db_thread *tdb_thread = dynamic_cast<thread_db_thread *>(threadEv->getNewThread()->llthrd());\n\n   pthrd_printf(\"ThreadDBCreateHandler::handleEvent for %d/%d\\n\", tdb_proc->getPid(), tdb_thread->getLWP());\n   if (threadEv->getInternalEvent()->needs_update) {\n      pthrd_printf(\"Updating user thread data for %d/%d in thread_db create handler\\n\",\n                   tdb_proc->getPid(), tdb_thread->getLWP());\n      assert(tdb_proc);\n      new_thread_data_t *thrdata = (new_thread_data_t *) threadEv->getInternalEvent()->raw_data;\n      \n      async_ret_t result = tdb_proc->initThreadWithHandle(thrdata->thr_handle, &thrdata->thr_info, NULL_LWP);\n      if (result == aret_error) {\n         pthrd_printf(\"ThreadDBCreateHandler returning error\\n\");\n         return Handler::ret_error;\n      }\n      if (result == aret_async) {\n         pthrd_printf(\"ThreadDBCreateHandler returning async\\n\");\n         return Handler::ret_async;\n      }\n      if (thrdata->threadHandle_alloced) tdb_thread->threadHandle_alloced = true;\n   }\n   \n   return Handler::ret_success;\n}\n\nvoid ThreadDBCreateHandler::getEventTypesHandled(vector<EventType> &etypes) {\n   etypes.push_back(EventType(EventType::Any, EventType::UserThreadCreate));\n}\n\nThreadDBDestroyHandler::ThreadDBDestroyHandler() :\n   Handler(\"thread_db Destroy Handler\")\n{\n}\n\nThreadDBDestroyHandler::~ThreadDBDestroyHandler()\n{\n}\n\nint ThreadDBDestroyHandler::getPriority() const\n{\n   //After dispatch handler, which runs at PostPlatformPriority\n   return Handler::PostPlatformPriority + 1;\n}\n\nHandler::handler_ret_t ThreadDBDestroyHandler::handleEvent(Event::ptr ev) {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      pthrd_printf(\"Failed to load thread_db.  Not running handlers\\n\");\n      return Handler::ret_success;\n   }\n   thread_db_process *proc = dynamic_cast<thread_db_process *>(ev->getProcess()->llproc());\n   thread_db_thread *thrd = dynamic_cast<thread_db_thread *>(ev->getThread()->llthrd());\n   pthrd_printf(\"Running ThreadDBDestroyHandler on %d/%d\\n\", proc->getPid(), thrd->getLWP());\n   thrd->markDestroyed();\n\n   return Handler::ret_success;\n}\n\nvoid ThreadDBDestroyHandler::getEventTypesHandled(vector<EventType> &etypes) {\n    etypes.push_back(EventType(EventType::Any, EventType::UserThreadDestroy));\n}\n\nthread_db_thread::thread_db_thread(int_process *p, Dyninst::THR_ID t, Dyninst::LWP l) :\n   int_thread(p, t, l),\n   threadHandle(NULL),\n   destroyed(false),\n   tinfo_initialized(false),\n   thread_initialized(false),\n   threadHandle_alloced(false),\n   enabled_event_reporting(false)\n{\n   memset(&tinfo, 0, sizeof(tinfo));\n}\n\nthread_db_thread::~thread_db_thread() \n{\n   if (threadHandle_alloced)\n      delete threadHandle;\n}\n\nbool thread_db_thread::initThreadHandle() {\n    if( NULL != threadHandle ) return true;\n\n    thread_db_process *lproc = dynamic_cast<thread_db_process *>(llproc());\n    if( NULL == lproc->getThreadDBAgent() ) return false;\n\n    threadHandle = new td_thrhandle_t;\n\n    td_err_e errVal = thread_db_process::p_td_ta_map_lwp2thr(lproc->getThreadDBAgent(),\n                                          lwp, threadHandle);\n    if( TD_OK != errVal ) {\n        perr_printf(\"Failed to map LWP %d to thread_db thread: %s(%d)\\n\",\n                lwp, tdErr2Str(errVal), errVal);\n        setLastError(err_internal, \"Failed to get thread_db thread handle\");\n        delete threadHandle;\n        threadHandle = NULL;\n        return false;\n    }\n    threadHandle_alloced = true;\n\n    return true;\n}\n\nasync_ret_t thread_db_process::getEventForThread(int_eventThreadDB *iev) {\n   // These specific calls into thread_db can modify the memory of the process\n   // and can introduce some race conditions if the platform allows memory reads\n   // while some threads are running\n   assert( threadPool()->allHandlerStopped() );\n  \n   // We need to save thread_db generated events because we need to use the\n   // process-level event retrieval call to get thread creation events (at\n   // least on some platforms).\n\n   bool local_async = false;\n   td_err_e msgErr = TD_OK;\n\n   if (!iev->completed_getmsgs) {\n      getMemCache()->markToken(token_getmsg);\n      vector<td_event_msg_t> msgs;\n      vector<td_thrhandle_t> handles;\n\n      td_event_msg_t evMsg;\n\n      for (;;) {\n         msgErr = p_td_ta_event_getmsg(threadAgent, &evMsg);\n         if (msgErr != TD_OK) {\n            if (getMemCache()->hasPendingAsync()) {\n               pthrd_printf(\"Async return in getEventForThread from td_ta_event_getmsg\\n\");\n               return aret_async;\n            }\n            else if (msgErr == TD_NOMSG) {\n               pthrd_printf(\"No more messages ready in thread_db\\n\");\n               break;\n            }\n            else {\n               perr_printf(\"Error reading messages from thread_db\\n\");\n               return aret_error;\n            }\n         }\n         msgs.push_back(evMsg);\n         //GLIBC's thread_db returns a pointer to a static variable inside\n         // evMsg.  Thus subsequent calls will override the data from prior\n         // calls.  Annoying.  Make a copy of the th_p in handles to avoid\n         // this problem.\n         handles.push_back(*evMsg.th_p);\n      }\n      pthrd_printf(\"Received %lu messages from thread_db on %d\\n\", (unsigned long)msgs.size(), getPid());\n      iev->msgs = msgs;\n      iev->handles = handles;\n      iev->completed_getmsgs = true;\n   }\n\n   getMemCache()->condense();\n\n   for (int i=iev->msgs.size()-1; i>=0; i--) {\n      td_event_msg_t &evMsg = iev->msgs[i];\n      evMsg.th_p = & iev->handles[i];\n      Event::ptr newEvent = decodeThreadEvent(&evMsg, local_async);\n      if (local_async) {\n         pthrd_printf(\"Async return from decodeThreadEvent\\n\");\n         return aret_async;\n      }\n      if (newEvent)\n         iev->new_evs.insert(newEvent);\n      iev->msgs.pop_back();\n      iev->handles.pop_back();\n   }\n  \n   return aret_success;\n}\n\nbool thread_db_process::setTrackThreads(bool b, std::set<std::pair<int_breakpoint *, Address> > &bps,\n                                                 bool &add_bp)\n{\n   if (b == track_threads) {\n      pthrd_printf(\"User wants to %s thread_db on %d, which is already done.  Leaving in same state\\n\",\n                   b ? \"enable\" : \"disable\", getPid());\n      return true;\n   }\n   track_threads = b;\n   \n   std::map<Address, pair<int_breakpoint *, EventType> >::iterator i;\n   for (i = addr2Event.begin(); i != addr2Event.end(); i++) {\n      Address addr = i->first;\n      int_breakpoint *bp = i->second.first;\n      bps.insert(make_pair(bp, addr));\n   }\n\n   add_bp = b;\n   return true;\n}\n\nbool thread_db_process::isTrackingThreads()\n{\n   return track_threads;\n}\n\nbool thread_db_process::refreshThreads()\n{\n   EventThreadDB::ptr ev = EventThreadDB::ptr(new EventThreadDB());\n   ev->setSyncType(Event::async);\n   ev->setProcess(proc());\n   ev->setThread(threadPool()->initialThread()->thread());\n   mbox()->enqueue(ev);\n   return true;\n}\n\nint thread_db_process::threaddb_getPid()\n{\n   return getPid();\n}\n\nasync_ret_t thread_db_thread::setEventReporting(bool on) {\n    if( !initThreadHandle() ) return aret_error;\n    if (enabled_event_reporting == on) return aret_success;\n\n    pthrd_printf(\"Enabled thread_db events for LWP %d\\n\", lwp);\n    td_err_e errVal = thread_db_process::p_td_thr_event_enable(threadHandle, (on ? 1 : 0 ));\n    if (errVal != TD_OK && llproc()->getMemCache()->hasPendingAsync()) {\n       pthrd_printf(\"td_thr_event_enable returned async in setEventReporting\\n\");\n       return aret_async;\n    }\n    enabled_event_reporting = on;\n    if (errVal != TD_OK) {\n       perr_printf(\"Failed to enable events for LWP %d: %s(%d)\\n\",\n                   lwp, tdErr2Str(errVal), errVal);\n       setLastError(err_internal, \"Failed to enable thread_db events\");\n       return aret_error;\n    }\n\n    return aret_success;\n}\n\nbool thread_db_thread::fetchThreadInfo() {\n   if (!thread_db_process::loadedThreadDBLibrary()) {\n      perr_printf(\"Failed to load thread_db.  Not fetching thread data.\");\n      setLastError(err_unsupported, \"thread_db.so not loaded.  User-level thread data unavailable.\");\n      return false;\n   }\n   if (!thread_initialized) {\n      perr_printf(\"Attempt to read user thread info of %d/%d before user thread create\\n\",\n                  llproc()->getPid(), getLWP());\n      setLastError(err_nouserthrd, \"Attempted to read user thread info, but user thread has not been created.\");\n      return false;\n   }\n   if (tinfo_initialized) {\n      return true;\n   }\n   if( !initThreadHandle() ) return false;\n\n   pthrd_printf(\"Calling td_thr_get_info on %d/%d\\n\", llproc()->getPid(), getLWP());\n   thread_db_process *tdb_proc = dynamic_cast<thread_db_process *>(llproc());\n   async_ret_t result = tdb_proc->ll_fetchThreadInfo(threadHandle, &tinfo);\n   if (result == aret_error) {\n      pthrd_printf(\"Returning error in fetchThreadInfo due to ll_fetchThreadInfo\\n\");\n      return false;\n   }\n   while (result == aret_async) {\n      std::set<response::ptr> resps;\n      llproc()->getMemCache()->getPendingAsyncs(resps);\n      llproc()->waitForAsyncEvent(resps);\n      result = tdb_proc->ll_fetchThreadInfo(threadHandle, &tinfo);\n      if (result == aret_error) {\n         pthrd_printf(\"Returning error in fetchThreadInfo due to ll_fetchThreadInfo\\n\");\n         return false;\n      }\n   }\n\n   if( tinfo.ti_tid ) tinfo_initialized = true;\n   return true;\n}\n\nvoid thread_db_thread::markDestroyed() {\n    destroyed = true;\n}\n\nbool thread_db_thread::isDestroyed() {\n    return destroyed;\n}\n\nbool thread_db_thread::thrdb_getThreadArea(int, Dyninst::Address &)\n{\n   assert(0); //Unsupported.  Currently only known to be needed on linux/x86_64\n   return false;\n}\n\nbool thread_db_thread::haveUserThreadInfo()\n{\n   pthrd_printf(\"haveUserThreadInfo (%d/%d): %d\\n\", (llproc() ? llproc()->getPid() : 0), lwp, thread_initialized);\n   return thread_initialized;\n}\n\nbool thread_db_thread::getTID(Dyninst::THR_ID &tid)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n#if defined(os_freebsd)\n   tid = (Dyninst::THR_ID) tinfo.ti_thread;\n#else\n   tid = (Dyninst::THR_ID) tinfo.ti_tid;\n#endif\n   return true;\n}\n\nbool thread_db_thread::getStartFuncAddress(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_startfunc;\n   return true;\n}\n\nbool thread_db_thread::getStackBase(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_stkbase;\n   return true;\n}\n\nbool thread_db_thread::getStackSize(unsigned long &size)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   size = (unsigned long) tinfo.ti_stksize;\n   return true;\n}\n\nbool thread_db_thread::getTLSPtr(Dyninst::Address &addr)\n{\n   if (!fetchThreadInfo()) {\n      return false;\n   }\n   addr = (Dyninst::Address) tinfo.ti_tls;\n   return true;\n}\n\n#else\n\n//Empty place holder functions in-case we're built on a machine without libthread_db.so\n\nthread_db_process::thread_db_process(Dyninst::PID p, std::string e, std::vector<std::string> a, std::vector<std::string> envp, std::map<int, int> f) : \n   int_threadTracking(p, e, a, envp, f)\n{\n  cerr << \"Thread DB process constructor\" << endl;\n}\n\nthread_db_process::thread_db_process(Dyninst::PID pid_, int_process *p) :\n   int_threadTracking(pid_, p)\n{\n}\n\nthread_db_process::~thread_db_process()\n{\n}\n\nbool thread_db_process::decodeTdbLWPExit(EventLWPDestroy::ptr)\n{\n   return false;\n}\n\nasync_ret_t thread_db_process::decodeTdbBreakpoint(EventBreakpoint::ptr)\n{\n   return aret_error;\n}\n\nvoid thread_db_process::addThreadDBHandlers(HandlerPool *)\n{\n}\n\nthread_db_thread::thread_db_thread(int_process *p, Dyninst::THR_ID t, Dyninst::LWP l) : \n   int_thread(p, t, l)\n{\n}\n\nthread_db_thread::~thread_db_thread()\n{\n}\n\nbool thread_db_thread::thrdb_getThreadArea(int, Dyninst::Address &)\n{\n   assert(0); //Should not be called if there's no thread_db\n   return false;\n}\n\nbool thread_db_thread::haveUserThreadInfo()\n{\n   return false;\n}\n\nbool thread_db_thread::getTID(Dyninst::THR_ID &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStartFuncAddress(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStackBase(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getStackSize(unsigned long &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::getTLSPtr(Dyninst::Address &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_thread::plat_convertToSystemRegs(const int_registerPool &,\n                                                unsigned char *, bool)\n{\n   return true;\n}\n\nasync_ret_t thread_db_process::post_attach(bool b, set<response::ptr> &s) {\n   return int_process::post_attach(b, s);\n}\n\nasync_ret_t thread_db_process::post_create(std::set<response::ptr> &async_responses) {\n   return int_process::post_create(async_responses);\n}\n\nbool thread_db_process::plat_getLWPInfo(lwpid_t, void *) {\n   return false;\n}\n\nconst char *thread_db_process::getThreadLibName(const char *)\n{\n   return \"\";\n}\n\nvoid thread_db_process::freeThreadDBAgent() {\n}\n\nasync_ret_t thread_db_process::getEventForThread(int_eventThreadDB *) \n{\n   return aret_error;\n}\n\nbool thread_db_process::isSupportedThreadLib(string) {\n   return false;\n}\n\nbool thread_db_process::plat_supportThreadEvents() {\n   return false;\n}\n\nbool thread_db_process::setTrackThreads(bool, std::set<std::pair<int_breakpoint *, Address> > &,\n                                                 bool &)\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nbool thread_db_process::isTrackingThreads()\n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return false;\n}\n\nThreadTracking *thread_db_process::threaddb_getThreadTracking() \n{\n   perr_printf(\"Error. thread_db not installed on this platform.\\n\");\n   setLastError(err_unsupported, \"Cannot perform thread operations without thread_db\\n\");\n   return NULL;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/proccontrol/src/loadLibrary/codegen-linux.C": "// Linux-specific routines to generate a code sequence to load a library\n// into a target process.\n\n#include \"loadLibrary/codegen.h\"\n#include <dlfcn.h>\n#include <iostream>\n#include \"PCProcess.h\"\n#include <sys/mman.h>\n\nusing namespace Dyninst;\nusing namespace std;\nusing namespace ProcControlAPI;\n\nstatic const int DLOPEN_MODE = RTLD_NOW | RTLD_GLOBAL;\n\n// Note: this is an internal libc flag -- it is only used\n// when libc and ld.so don't have symbols\n#ifndef __RTLD_DLOPEN\n#define __RTLD_DLOPEN 0x80000000\n#endif\n\nstatic const char DL_OPEN_FUNC_EXPORTED[] = \"dlopen\";\nstatic const char DL_OPEN_LIBC_FUNC_EXPORTED[] = \"__libc_dlopen_mode\";\nstatic const char DL_OPEN_FUNC_NAME[] = \"do_dlopen\";\nstatic const char DL_OPEN_FUNC_INTERNAL[] = \"_dl_open\";\n\n\nbool Codegen::generateInt() {\n   Address dlopen_addr = 0;\n\n    int mode = DLOPEN_MODE;\n    bool useHiddenFunction = false;\n    bool needsStackUnprotect = false;\n    Address var_addr = 0;\n    Address mprotect_addr = 0;\n    do {\n       dlopen_addr = findSymbolAddr(DL_OPEN_FUNC_EXPORTED, true); \n       if (dlopen_addr) {\n          break;\n       }\n       \n       // This approach will work if libc and the loader have symbols\n       // Note: this is more robust than the next approach\n       useHiddenFunction = true;\n       needsStackUnprotect = true;\n       dlopen_addr = findSymbolAddr(DL_OPEN_FUNC_NAME, true);\n       var_addr = findSymbolAddr(\"__stack_prot\");\n       mprotect_addr = findSymbolAddr(\"mprotect\", true);\n       if (dlopen_addr && var_addr && mprotect_addr) {\n          break;\n       }\n       \n       // If libc and the loader don't have symbols, we need to take a\n       // different approach. We still need to the stack protection turned\n       // off, but since we don't have symbols we use an undocumented flag\n       // to turn off the stack protection\n       useHiddenFunction = false;\n       needsStackUnprotect = false;\n       mode |= __RTLD_DLOPEN;\n       dlopen_addr = findSymbolAddr(DL_OPEN_LIBC_FUNC_EXPORTED, true);\n       if (dlopen_addr) {\n          break;\n       }\n       fprintf(stderr, \"Couldn't find dlopen address, bailing\\n\");\n       // We can't go farther without parsing\n       return false;\n    } while(0);\n\n    assert(dlopen_addr);\n\n    std::vector<Address> arguments;\n\n    Address libbase = copyString(libname_);\n\n    if (useHiddenFunction) {\n       // The argument is a pointer to a struct rather than\n       // arguments directly\n       Address structbase = buildLinuxArgStruct(libbase, mode);\n       arguments.push_back(structbase);\n    }\n    else {\n       arguments.push_back(libbase);\n       arguments.push_back(mode);\n    }\n\n    generateNoops();\n    codeStart_ = buffer_.curAddr();\n    \n    generatePreamble();\n    \n    if (needsStackUnprotect) {\n      if (!generateStackUnprotect(var_addr, mprotect_addr)) return false;\n    }\n\n    if (!generateCall(dlopen_addr, arguments)) return false;\n    \n    return true;\n}\n\nAddress Codegen::buildLinuxArgStruct(Address libbase, unsigned mode) {\n   struct libc_dlopen_args_32 {\n      uint32_t namePtr;\n      uint32_t mode;\n      uint32_t linkMapPtr;\n   };\n   \n   struct libc_dlopen_args_64 {\n      uint64_t namePtr;\n      uint32_t mode;\n      uint64_t linkMapPtr;\n   };\n   \n   // Construct the argument to the internal function\n   struct libc_dlopen_args_32 args32;\n   struct libc_dlopen_args_64 args64;\n   unsigned argsSize = 0;\n   void *argsPtr = NULL;\n\n   if (proc_->getArchitecture() == Arch_x86 ||\n       proc_->getArchitecture() == Arch_ppc32) {\n      args32.namePtr = (uint32_t) libbase;\n      args32.mode = mode;\n      args32.linkMapPtr = 0;\n      argsSize = sizeof(args32);\n      argsPtr = &args32;\n   }\n   else {\n      args64.namePtr = libbase;\n      args64.mode = mode;\n      args64.linkMapPtr = 0;\n      argsSize = sizeof(args64);\n      argsPtr = &args64;\n   }\n\n   return copyBuf(argsPtr, argsSize);\n}\n\nbool Codegen::generateStackUnprotect(Address var_addr, Address mprotect_addr) {\n   // Since we are punching our way down to an internal function, we\n   // may run into problems due to stack execute protection. Basically,\n   // glibc knows that it needs to be able to execute on the stack in\n   // in order to load libraries with dl_open(). It has code in\n   // _dl_map_object_from_fd (the workhorse of dynamic library loading)\n   // that unprotects a global, exported variable (__stack_prot), sets\n   // the execute flag, and reprotects it. This only happens, however,\n   // when the higher-level dl_open() functions (which we skip) are called,\n   // as they append an undocumented flag to the library open mode. Otherwise,\n   // assignment to the variable happens without protection, which will\n   // cause a fault.\n   //\n   // Instead of chasing the value of the undocumented flag, we will\n   // unprotect the __stack_prot variable ourselves (if we can find it).\n\n\n   if (!var_addr || !mprotect_addr) {\n     fprintf(stderr, \"Couldn't find symbols to unprotect stack, bailing\\n\");\n     return false;\n   }\n   Address page_start;\n   Address pagesize = getpagesize();\n\n   page_start = var_addr & ~(pagesize - 1);\n\n\n   std::vector<Address> args;\n   args.push_back(page_start);\n   args.push_back(pagesize);\n   args.push_back(PROT_READ | PROT_WRITE | PROT_EXEC); // read | write | execute\n\n   return generateCall(mprotect_addr, args);\n}\n\n#if 0\n\nbool Codegen::findTOC(Symbol *sym, Library::ptr lib) {\n   Address baseTOC = \n\n   return false;\n   if (proc_->getArchitecture() != Arch_ppc64) return true;\n\n\n   Address baseTOC = sym->getSymtab()->getTOCoffset(sym->getOffset());\n   baseTOC += lib->getDataLoadAddress();\n   toc_ = baseTOC;\n   return toc_ != 0;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/proccontrol/src/loadLibrary/codegen.h": "// Codegen.h\n//\n// Interface class for generating a dlopen() call\n//\n\n#if !defined(_INJECTOR_CODEGEN_H_)\n#define _INJECTOR_CODEGEN_H_\n\n#include \"PCProcess.h\"\n#include \"Buffer.h\"\n\nnamespace Dyninst {\n\nnamespace ProcControlAPI {\n\nclass Codegen {\n  public:\n   Codegen(ProcControlAPI::Process *proc, \n           std::string libname);\n   ~Codegen();\n\n   // Override for assembly generation\n   bool generate();\n\n   const Buffer &buffer() { return buffer_; }\n   unsigned startOffset() const;\n\n  private:\n   \n   unsigned estimateSize();\n   bool generateInt();\n   Address findSymbolAddr(const std::string name, bool saveTOC = false);\n   Address copyString(std::string);\n   Address copyBuf(void *buf, unsigned size);\n   Address copyByte(unsigned char);\n   Address copyInt(unsigned int);\n   Address copyLong(unsigned long);\n\n#if defined(os_linux)\n   Address buildLinuxArgStruct(Address libbase, unsigned mode);\n   bool generateStackUnprotect(Address var, Address mprotect);\n#endif\n\n   bool generateCall(Address addr, const std::vector<Address> &args);\n\n   bool generateCallIA32(Address addr, const std::vector<Address> &args);\n   bool generateCallAMD64(Address addr, const std::vector<Address> &args);\n\n   bool generateCallPPC32(Address addr, const std::vector<Address> &args);\n   bool generateCallPPC64(Address addr, const std::vector<Address> &args);\n\n\n   bool generatePreamble();\n   bool generatePreambleIA32();\n   bool generatePreambleAMD64();\n\n   bool generatePreamblePPC32();\n   bool generatePreamblePPC64();\n\n   void generatePPC32(Address val, unsigned reg);\n   void generatePPC64(Address val, unsigned reg);\n\n\n   bool generateTrap();\n   bool generateNoops();\n\n   ProcControlAPI::Process *proc_;\n   std::string libname_;\n\n   Address codeStart_;\n   Buffer buffer_;   \n\n   // PPC64 only, but it's handy to stash it here\n   std::map<Address, Address> toc_;\n};\n\n};\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/proccontrol/src/loadLibrary/codegen-freebsd.C": "// Linux-specific routines to generate a code sequence to load a library\n// into a target process.\n\n#include \"loadLibrary/codegen.h\"\n#include <dlfcn.h>\n#include <iostream>\n#include \"PCProcess.h\"\n#include \"int_process.h\"\n#include \"common/src/pathName.h\"\n#include <sys/mman.h>\n\nusing namespace Dyninst;\nusing namespace std;\nusing namespace ProcControlAPI;\n\nstatic const int DLOPEN_MODE = RTLD_NOW | RTLD_GLOBAL;\n\nconst char DL_OPEN_FUNC_EXPORTED[] = \"dlopen\";\n\nbool Codegen::generateInt() {\n    // We need to make sure that the correct dlopen function is being used -- the\n    // dlopen in the runtime linker. A symbol for dlopen exists in ld.so even\n    // when it is stripped so we should always find that version of dlopen\n\n    auto aout = proc_->libraries().getExecutable();\n    SymReader *objSymReader = proc_->llproc()->getSymReader()->openSymbolReader(aout->getName());\n    if (!objSymReader) {\n      return false;\n    }\n    std::string interp = resolve_file_path(objSymReader->getInterpreterName().c_str());\n\n    objSymReader = proc_->llproc()->getSymReader()->openSymbolReader(interp);\n    if (!objSymReader) {\n      return false;\n    }\n    auto lookupSym = objSymReader->getSymbolByName(DL_OPEN_FUNC_EXPORTED);\n    if (!objSymReader->isValidSymbol(lookupSym)) {\n      return false;\n    }\n\n    Address dlopenAddr = objSymReader->getSymbolOffset(lookupSym);\n\n    // But we still need the load addr...\n    bool found = false;\n    for (auto li = proc_->libraries().begin(); li != proc_->libraries().end(); ++li) {\n      std::string canonical = resolve_file_path((*li)->getName().c_str());\n      if (canonical == interp) {\n\tfound = true;\n\tdlopenAddr += (*li)->getLoadAddress();\n\tbreak;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n\n    std::vector<Address> arguments;\n\n    Address libbase = copyString(libname_);\n\n    arguments.push_back(libbase);\n    arguments.push_back(DLOPEN_MODE);\n\n    generateNoops();\n    codeStart_ = buffer_.curAddr();\n    \n    generatePreamble();\n    \n    if (!generateCall(dlopenAddr, arguments)) return false;\n    \n    return true;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI_RT/src/RTmutatedBinary_ELF.c": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/* $Id: RTmutatedBinary_ELF.c,v 1.29 2007/07/11 17:58:24 ssuen Exp $ */\n\n/* this file contains the code to restore the necessary\n   data for a mutated binary \n */\n\n#include <stdlib.h>\n#include \"dyninstAPI_RT/h/dyninstAPI_RT.h\"\n#include <unistd.h>\n#include  <fcntl.h>\n#include <string.h>\n\n#include <libelf.h>\n\n\n\n#if defined(i386_unknown_linux2_0) \\\n || (defined(arch_power) && defined(os_linux)) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n#define __USE_GNU\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <link.h> /* ccw 23 jan 2002 */\n#include <limits.h>\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\nextern ElfW(Dyn) _DYNAMIC[];\n\n#endif\n\n/* Borrowed from Linux's link.h: Allows us to use functions from\n   libelf regardless of word size. */\n//#define ELF_FUNC(type)      _ELF_FUNC (elf, __ELF_NATIVE_CLASS, type)\n#define ELF_FUNC(type)      _ELF_FUNC (Elf, __ELF_NATIVE_CLASS, type)\n#define _ELF_FUNC(e,w,t)    _ELF_FUNC_1 (e, w, _##t)\n#define _ELF_FUNC_1(e,w,t)  e##w##t\n\ntypedef struct {\n      ElfW(Sword) d_tag;\n      union {\n          ElfW(Sword) d_val;\n          ElfW(Addr) d_ptr;\n      } d_un;\n  } __Elf_Dyn;\n\nunsigned long checkAddr;\n/*extern int isMutatedExec;\nchar *buffer;\n*/\n\nstruct link_map* map=NULL;\n\nchar *sharedLibraryInfo = NULL;\nunsigned int originalInsnBkpt;\nunsigned int addressBkpt;\n\n/* \tthis is not misnamed.  In the future, this function will contain\n\tcode to patch the instrumentation of a shared library that has \n\tbeen loaded into a different place during a mutated binary run.\n\n\tNow, it just exit()s, as you can see\n*/\n\nvoid fixInstrumentation(char* soName, unsigned long currAddr, unsigned long oldAddr){\n\tprintf(\" %s loaded at wrong address: 0x%lx (expected at 0x%lx) \\n\", soName, currAddr, oldAddr);\n\tprintf(\" This is an unrecoverable error, the instrumentation will not\");\n\tprintf(\"\\n run correctly if shared libraries are loaded at a different address\\n\");\n\tprintf(\"\\n Exiting.....\\n\");\n\tfflush(stdout);\n        //while(1);\n\t//exit(9);\n}\n\n/* \tthis function checks the shared library (soName) to see if it\n\tis currently loaded (loadAddr) at the same place it was before (address).\n\tIf the shared library is not found in the list (sharedLibraryInfo) that\n\tmean the shared library was *NOT* instrumented and can be loaded\n\tanywhere\n*/\nunsigned long checkSOLoadAddr(char *soName, unsigned long loadAddr){\n\tunsigned long result=0, found = 0;\n\tunsigned long address;\n\tchar *ptr = sharedLibraryInfo;\n\twhile(ptr &&  *ptr && !found ){\n\t\t/*fprintf(stderr,\" CHECKING FOR %s in %s\\n\", ptr, soName);*/\n\n        \tif(strstr(soName, ptr) || strstr(ptr,soName)){\n                \tfound = 1;\n\t\t\tptr += (strlen(ptr) +1);\n\t\t\tmemcpy(&address, ptr, sizeof(unsigned long)); \n\t\t\t/* previous line is done b/c of alignment issues on sparc*/\n\t\t\tif(loadAddr == address) {\n\t\t\t\tresult = 0;\n\t\t\t}else{\n\t\t\t\tresult = address;\n\t\t\t}\t\n\t\t}\n\n\t\tptr += (strlen(ptr) +1);\n\t\tptr += sizeof(unsigned long);\n\t\tptr += sizeof(unsigned long); /* for flag */\n\n\n\t}\n\tif(!found){\n\t\tresult = 0;\n\t\t/*fprintf(stderr,\" NOT FOUND %s\\n\",soName);*/\n\t}\n\n\t/*fprintf(stderr,\" checkSOLoadAddr: %s %lx %lx\\n\", soName, loadAddr, result);*/\n\treturn result;\n}\n\n\n#if defined(i386_unknown_linux2_0) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\nunsigned long loadAddr;\nvoid (*dl_debug_state_func)(void);\n\nvoid dyninst_dl_debug_state(){\n\tasm(\"nop\");\n\tif(_r_debug.r_state == 1){\n\tdo {\n\t\t\tif(map->l_next){\n\t\t\t\tmap = map->l_next;\n\t\t\t}\n\t\t\tloadAddr = checkSOLoadAddr(map->l_name, (unsigned long)map->l_ld);/*l_addr*/\n\t\t\tif(loadAddr){\n\t\t\t\tfixInstrumentation(map->l_name, (unsigned long)map->l_ld, loadAddr);/*l_addr*/\n\t\t\t}\n\t\t}while(map->l_next);\n\n\t}\n\n\t/* the following call is used to call\n\t * _dl_debug_state to ensure correctness (if\n\t * someone relies on it being called it is\n\t * execuated after this function)\n\t * The value stored in dl_debug_state_func is\n\t * the address of the function _dl_debug_state\n\t * and is set in checkElfFile\n\t */\n\tasm(\"nop\");\n\tasm(\"nop\");\n\tasm(\"nop\");\n\t(*dl_debug_state_func)();\n\tasm(\"nop\");\n\n}\n\nvoid hack_ld_linux_plt(unsigned long pltEntryAddr){ \n/* this is ugly.\n * save the world needs to check each shared library\n * that is loaded to ensure that it is loaded at the\n * same base address it was loaded at when the mutator/mutatee\n * pair ran.  \n * So, we know dlopen calls _dl_debug_state per the r_debug\n * interface to let the process know a shared library has changed\n * state.\n * with this function we change the Procedure Linkage Table (.plt)\n * for ld-linux.so so that the entry that used to point to\n * _dl_debug_state points to dyninst_dl_debug_state.\n *\n * dyninst_dl_debug_state then calls _dl_debug_state before\n * exiting \n *\n * dont try this at home\n */\n\tunsigned long mprotectAddr = pltEntryAddr - (pltEntryAddr % getpagesize());\t\n\tunsigned long newTarget = (unsigned long) &dyninst_dl_debug_state ;\n\t\n\tmprotect( (void*) mprotectAddr, pltEntryAddr - mprotectAddr + sizeof(long), \n\t\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC);\n\n\tmemcpy( (void*) dl_debug_state_func, (void*) pltEntryAddr, sizeof(long)); \n\n\tmemcpy( (void*) pltEntryAddr, &newTarget, sizeof(long));\n}\n#endif\n\nunsigned (*Elf_version)(unsigned) = NULL;\nElf *(*Elf_begin)(int fildes, Elf_Cmd cmd, Elf *ref) = NULL;\nElf_Scn *(*Elf_getscn)(Elf *elf, size_t index) = NULL;\nElf_Data *(*Elf_getdata)(Elf_Scn *scn, Elf_Data *data) = NULL;\nElf_Scn *(*Elf_nextscn)(Elf *elf, Elf_Scn *scn) = NULL;\nElf32_Shdr *(*Elf32_getshdr)(Elf_Scn *scn) = NULL;\nElf32_Ehdr *(*Elf32_getehdr)(Elf *elf) = NULL;\nElf64_Shdr *(*Elf64_getshdr)(Elf_Scn *scn) = NULL;\nElf64_Ehdr *(*Elf64_getehdr)(Elf *elf) = NULL;\nconst char *(*Elf_errmsg)(int err) = NULL;\nint (*Elf_errno)(void) = NULL;\nint (*Elf_end)(Elf *elf) = NULL;\n\n\nint checkSO(char* soName){\n\tElfW(Shdr) *shdr;\n\tElfW(Ehdr) *   ehdr;\n    \tElf *          elf;\n\tint       fd;\n\tElf_Data *strData;\n\tElf_Scn *scn;\n\tint result = 0;\n\n \tif((fd = (int) open(soName, O_RDONLY)) == -1){\n\t\tRTprintf(\"cannot open : %s\\n\",soName);\n    \t\tfflush(stdout); \n\t\treturn result;\n\t}\n\tif((elf = Elf_begin(fd, ELF_C_READ, NULL)) ==NULL){\n\t\tRTprintf(\"%s %s \\n\",soName, Elf_errmsg(Elf_errno()));\n\t\tRTprintf(\"cannot elf_begin\\n\");\n\t\tfflush(stdout);\n\t\tclose(fd);\n\t\treturn result;\n\t}\n\n\tehdr = ELF_FUNC( getehdr(elf) );\n\tscn = Elf_getscn(elf, ehdr->e_shstrndx);\n\tstrData = Elf_getdata(scn,NULL);\n   \tfor( scn = NULL; !result && (scn = Elf_nextscn(elf, scn)); ){\n\t\tshdr = ELF_FUNC( getshdr(scn) );\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \".dyninst_mutated\")) {\n\t\t\tresult = 1;\n\t\t}\n\t}\n\tElf_end(elf);\n\tclose(fd);\n\n\treturn result;\n}\n\nint checkMutatedFile(){\n\n    /* Apparently a future section stomps on the tramp guard. Whoops. Instead,\n       we'll keep the address around and initialize the guard at the end. */\n    int *trampGuardBase_ = NULL;\n    int trampGuardSize_ = 0;\n\n\tElfW(Shdr) *shdr;\n\tElfW(Ehdr) *   ehdr;\n\tElf *          elf;\n\tint       cnt,fd;\n\tElf_Data *elfData,*strData;\n\tElf_Scn *scn;\n\tchar *execStr;\n\tint retVal = 0;\n\tunsigned long mmapAddr;\n\tint pageSize;\n\tAddress dataAddress;\n\tint dataSize;\n\tchar* tmpPtr;\n\tunsigned long updateAddress, updateSize, updateOffset;\n\tunsigned long *dataPtr;\n\tunsigned int numberUpdates,i ;\n\tchar* oldPageData;\n\tDl_info dlip;\n\tint soError = 0; \n\n     char * error_msg = NULL;\n     void * elfHandle = NULL;\n\n\t//fprintf(stderr,\"SBRK 0x%x\\n\",sbrk(1));;\n\n//     elfHandle = dlopen(\"/usr/lib/libelf.so.1\", RTLD_NOW);\n\n     elfHandle = dlopen(\"libelf.so\", RTLD_NOW);\n     if(! elfHandle){\n        error_msg = dlerror();\n        if (error_msg) {\n          //fprintf(stderr,\"Could not open lib: %s- %s\\n\",\"libelf\",error_msg);\n        }\n        else{\n          //fprintf(stderr, \"failure\\n\");\n        }\n\treturn 0;\n     }\n\n     Elf_version = (unsigned (*)(unsigned)) dlsym(elfHandle, \"elf_version\");\n     Elf_begin = (Elf *(*)(int,Elf_Cmd,Elf *)) dlsym(elfHandle, \"elf_begin\");\n     Elf_getscn = (Elf_Scn *(*)(Elf *, size_t)) dlsym(elfHandle, \"elf_getscn\");\n     Elf_nextscn = (Elf_Scn *(*)(Elf *, Elf_Scn *)) dlsym(elfHandle, \"elf_nextscn\");\n     Elf_getdata = (Elf_Data *(*)(Elf_Scn *, Elf_Data *)) dlsym(elfHandle, \"elf_getdata\");\n     Elf32_getehdr = (Elf32_Ehdr *(*)(Elf *)) dlsym(elfHandle, \"elf32_getehdr\");\n     Elf32_getshdr = (Elf32_Shdr *(*)(Elf_Scn *)) dlsym(elfHandle, \"elf32_getshdr\");\n     Elf64_getehdr = (Elf64_Ehdr *(*)(Elf *)) dlsym(elfHandle, \"elf64_getehdr\");\n     Elf64_getshdr = (Elf64_Shdr *(*)(Elf_Scn *)) dlsym(elfHandle, \"elf64_getshdr\");\n     Elf_errmsg = (const char *(*)(int)) dlsym(elfHandle, \"elf_errmsg\");\n     Elf_errno = (int (*)(void)) dlsym(elfHandle, \"elf_errno\");\n     Elf_end = (int (*)(Elf *)) dlsym(elfHandle, \"elf_end\");\n\n\tElf_version(EV_CURRENT);\n\n\texecStr = (char*) malloc(1024);\n\tmemset(execStr,'\\0',1024);\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */ \\\n   || (defined(os_linux) && defined(arch_power))\n\tsprintf(execStr,\"/proc/%d/exe\",getpid());\n#endif\n\n\tif((fd = (int) open(execStr, O_RDONLY)) == -1){\n\t\tprintf(\"cannot open : %s\\n\",execStr);\n    \t\tfflush(stdout); \n\t\treturn retVal;\n\t}\n\tif((elf = Elf_begin(fd, ELF_C_READ, NULL)) ==NULL){\n\t\tprintf(\"%s %s \\n\",execStr, Elf_errmsg( Elf_errno()));\n\t\tprintf(\"cannot Elf_begin\\n\");\n\t\tfflush(stdout);\n\t\tclose(fd);\n\t\treturn retVal;\n\t}\n\n\tehdr = ELF_FUNC( getehdr(elf) );\n\tscn = Elf_getscn(elf, ehdr->e_shstrndx);\n\tstrData = Elf_getdata(scn,NULL);\n\tpageSize =  getpagesize();\n\n\t/*fprintf(stderr,\"IN MUTATED FILE\\n\");*/\n   \tfor(cnt = 0, scn = NULL; !soError &&  (scn = Elf_nextscn(elf, scn));cnt++){\n\t\tshdr = ELF_FUNC( getshdr(scn) );\n\t\tif(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPItrampgu\", 17)) {\n\t\t\tdataAddress = shdr->sh_addr;\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\t\t\t//fprintf(stderr,\"tramp guard addr %x, tmpPtr %p (%d)\\n\", dataAddress, tmpPtr, *tmpPtr);\n                        trampGuardBase_ = (int *)dataAddress;\n                        trampGuardSize_ = *(int *)tmpPtr;\n\n\n\t\t\t/* \twe already own it. \n\t\n\t\t\t\tbecause we have moved the start of the heap beyond this address\n\t\t\t*/\n\n\t\t\t/* set tramp guard to 1 */\n\t\t\tfor(i=0;i<*(int*)tmpPtr;i++){\n                            ((unsigned*) dataAddress)[i]=1;\n                        }\n                        /* This may get reverted, so we'll re-do the work below. */\n\n\t\t}else if(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_data\", 15)) {\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\t\t\tdataAddress = -1;\n\t\t\twhile( dataAddress != 0 ) { \n\t\t\t\t/*tmpPtr may not be aligned on the correct boundry\n\t\t\t\tso use memcpy to set dataSize\n\t\t\t\tdataSize = *(int*) tmpPtr;*/\n\t\t\t\tmemcpy((char*) & dataSize, tmpPtr, sizeof(int));\n\n\t\t\t\ttmpPtr+=sizeof(int);\n\t\t\t\tmemcpy( (char*) & dataAddress, tmpPtr, sizeof(Address));\n\n\t\t\t\ttmpPtr += sizeof(Address);\n\t\t\t\tif(dataAddress){\n\t\t\t\t\tmemcpy((char*) dataAddress, tmpPtr, dataSize);\n\n\t\t\t\t\ttmpPtr += dataSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(!strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_\",11)){ \n\t\t\tchar *tmpStr = strchr((char *)strData->d_buf + shdr->sh_name, (int)'_'); ;\n\n\t\t\ttmpStr ++;\n\n\t\t\tif( *tmpStr>=0x30 && *tmpStr <= 0x39 ) {\n\t\t\t\t/* we dont want to do this unless this is a dyninstAPI_### section\n\t\t\t\t\tspecifically, dont do this for dyninstAPI_SharedLibraries*/\n\t\t\t\tretVal = 1; /* this is a restored run */\n\n\t\t\t\tif( *tmpStr>=0x30 && *tmpStr <= 0x39 ) {\n\t\t\t\t\t/* this is a heap tramp section */\n\n\t\t\t\t\t/* \tthe new starting address of the heap is immediately AFTER the last\n\t\t\t\t\t\tdyninstAPI_### section, so we can ALWAYS memcpy the data into place\n\t\t\t\t\t\tsee the value of newHeapAddr in writeBackElf.C\n\t\t\t\t\t*/\n\t\t\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\t\t\tmemcpy((void*)shdr->sh_addr, elfData->d_buf, shdr->sh_size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_mutatedSO\")){\n\t\t\t/* make sure the mutated SOs are loaded, not the original ones */\n\t\t\tchar *soNames;\n\t\t\tint mutatedFlag = 0;\n\t\t\tint totallen=0;\n#if defined(i386_unknown_linux2_0) \\\n   || (defined(arch_power) && defined(os_linux)) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\tstruct link_map *lmap=0;\n#endif\n\t\t\tchar *loadedname, *dyninstname;\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\tsharedLibraryInfo = (char*) malloc(elfData->d_size);\n\t\t\tmemcpy(sharedLibraryInfo, elfData->d_buf, elfData->d_size);\n\t\t\tlmap = _r_debug.r_map;\n\n\t\t\tfor(soNames = (char*) elfData->d_buf ; totallen<elfData->d_size; \n\t\t\t\tsoNames = &((char*) elfData->d_buf)[strlen(soNames)+1+sizeof(unsigned int) +sizeof(unsigned int)]){\n\t\t\t\t/* added a +sizeof(unsigned int) above for flag */\n\t\t\t\ttotallen += strlen(soNames) + 1 + sizeof(unsigned int) +sizeof(unsigned int); /*for flag*/\n\t\t\t\tmemcpy(&mutatedFlag, &((char*) elfData->d_buf)[totallen-sizeof(unsigned int)], sizeof(unsigned int));\n\t\t\t\tlmap = _r_debug.r_map;\n\t\t\t\twhile(lmap){\n\t\t\t\t\tloadedname = strrchr(lmap->l_name,'/');\n\t\t\t\t\tdyninstname =  strrchr((const char *)soNames,(int)'/');\n\t\t\t\t\tif(loadedname == 0){\n\t\t\t\t\t\tloadedname = lmap->l_name;\n\t\t\t\t\t}\n\t\t\t\t\tif(dyninstname == 0){\n\t\t\t\t\t\tdyninstname = soNames;\n\t\t\t\t\t}\t\n\t\t\t\t\tif(mutatedFlag && !strcmp(loadedname, dyninstname)) {\n\t\t\t\t\t\tif(!checkSO(lmap->l_name)){\n\t\t\tprintf(\"ERROR: %s was mutated during saveworld and\",lmap->l_name);\n\t\t\tprintf(\" the currently loaded %s has not been mutated\\n\", lmap->l_name);\n\t\t\tprintf(\" check your LD path to be sure the mutated %s is visible\\n\", soNames);\n\t\t\t\t\t\t\tsoError = 1;\n\t\t\n\t\t\t\t\t\t}\n\n\t\t\n\t\t\t\t\t}\n\t\t\t\t\tlmap = lmap->l_next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"rtlib_addr\")){\n\t\t\tunsigned int ptr;\n\t\t\tint done = 0;\n\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\t/*ptr = elfData->d_buf;*/\n\t\t\t/* use memcpy because of alignment issues on sparc */\t\n\t\t\tmemcpy(&ptr,elfData->d_buf,sizeof(unsigned int));\n\n\t\n\t\t\tmap = _r_debug.r_map;\n\n\t\t\twhile(map && !done){\n\t\t\t\t/*fprintf(stderr,\"CHECKING %s 0x%x\\n\", map->l_name,map->l_addr);*/\n\t\t\t\tif( * map->l_name  && strstr(map->l_name, \"libdyninstAPI_RT\")){\n\t\t\t\t\tunsigned long loadaddr = (unsigned long)map->l_addr;\n\n\t\t\t\t\t/* \tLINUX PROBLEM. in the link_map structure the map->l_addr field is NOT\n\t\t\t\t\t\tthe load address of the dynamic object, as the documentation says.  It is the\n\t\t\t\t\t\tRELOCATED address of the object. If the object was not relocated then the\n\t\t\t\t\t\tvalue is ZERO.\n\n\t\t\t\t\t\tSo, on LINUX we check the address of the dynamic section, map->l_ld, which is\n\t\t\t\t\t\tcorrect.\n\t\t\t\t\t*/\n#if defined(i386_unknown_linux2_0) || defined(x86_64_unknown_linux2_4)\n\t\t\t\t\tloadaddr = (unsigned long)map->l_ld;\n#endif\n\n\t\t\t\t\t/*fprintf(stderr,\" loadadd %x ptr %x\\n\", loadaddr, ptr);*/\n\t\t\t\t\tif( loadaddr !=  (ptr)){\n\t\t\t\t\t\tfixInstrumentation(map->l_name, loadaddr,  (ptr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* check every loaded SO but leave map such that map->l_next == NULL.\n\t\t\t\t\tThe next time a SO is loaded it will be placed at \n\t\t\t\t\tmap->l_next, so keep a tail pointer such that we \n\t\t\t\t\tdont need to loop through the entire list again\n\t\t\t\t*/\n\t\t\t\tif(map->l_next){\n\t\t\t\t\tmap = map->l_next;\n\t\t\t\t}else{\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_SharedLibraries\")){\n\t\t\tunsigned long diffAddr;\n\t\t\tunsigned long ld_linuxBaseAddr;\n\t\t\tchar *ptr;\n\t\t\tint done = 0;\n\n\n\t\t\telfData = Elf_getdata(scn, NULL);\n\n\t\t\tptr = elfData->d_buf;\n\t\t\n\t\t\tmap = _r_debug.r_map;\n\n\t\t\twhile(map && !done){\n\t\t\t\tif( map->l_name && * map->l_name ){\n\t\t\t\t\tunsigned int loadaddr = map->l_addr;\n\n\t\t\t\t\t/* \tLINUX PROBLEM. in the link_map structure the map->l_addr field is NOT\n\t\t\t\t\t\tthe load address of the dynamic object, as the documentation says.  It is the\n\t\t\t\t\t\tRELOCATED address of the object. If the object was not relocated then the\n\t\t\t\t\t\tvalue is ZERO.\n\n\t\t\t\t\t\tSo, on LINUX we check the address of the dynamic section, map->l_ld, which is\n\t\t\t\t\t\tcorrect.\n\t\t\t\t\t*/\n#if defined(i386_unknown_linux2_0) || defined(x86_64_unknown_linux2_4)\n\t\t\t\t\tloadaddr = (unsigned long)map->l_ld;\n#endif\n\n\t\t\t\t\t/*fprintf(stderr,\" CHECKING: %s %x\\n\",map->l_name, map->l_addr);*/\n\t\t\t\t\tdiffAddr = checkSOLoadAddr(map->l_name, loadaddr);\n\t\t\t\t\tif(diffAddr){\n\t\t\t\t\t\tfixInstrumentation(map->l_name, loadaddr, diffAddr);\n\t\t\t\t\t}\n#if defined(i386_unknown_linux2_0) \\\n || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\t\t\t/* ld-linux.so will never be hand relocated so l_addr should be correct. right? */\n\t\t\t\t\tif(strstr(map->l_name, \"ld-linux.so\")){\n\t\t\t\t\t\tld_linuxBaseAddr = map->l_addr;\n\t\t\t\t\t}\t\n#endif\n\t\t\t\t}\n\t\t\t\t/* check every loaded SO but leave map such that map->l_next == NULL.\n\t\t\t\t\tThe next time a SO is loaded it will be placed at \n\t\t\t\t\tmap->l_next, so keep a tail pointer such that we \n\t\t\t\t\tdont need to loop through the entire list again\n\t\t\t\t*/\n\t\t\t\tif(map->l_next){\n\t\t\t\t\tmap = map->l_next;\n\t\t\t\t}else{\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( shdr->sh_addr != 0){\n\t\t\t\t/* if the addr is zero, then there is \n\t\t\t\t\tno PLT entry for dlopen.  if there is\n\t\t\t\t\tno entry for dlopen the mutatee must not\n\t\t\t\t\tcall it.  -- what about calling it from\n\t\t\t\t\ta shared lib that is statically loaded?\n\t\t\t\t*/\n\n\t\t\t/* WHY IS THERE A POUND DEFINE HERE? \n\n\t\t\t\twell, we need to intercept the dlopen calls from the mutated binary\n\t\t\t\tbecause our trampolines expect the shared libraries to be in\n\t\t\t\ta particular location and if they are not where they are expected\n\t\t\t\tour trampolines can jump off into nothingness, or even worse, some\n\t\t\t\trandom bit of executable code.  \n\n\t\t\t\tSo we must intercept the dlopen call and then check to be sure\n\t\t\t\tthe shared libraries are loaded in the same place as before.  If\n\t\t\t\tthey are not we exit with a message to the user saying this is\n\t\t\t\ta fatal error.\n\t\t\n\t\t\t\tNote, only shared libraries that have been instrumented are checked\n\t\t\t\there.  \n\t\t\t*/\n\n#if defined(i386_unknown_linux2_0) \\\n   || defined(x86_64_unknown_linux2_4) /* Blind duplication - Ray */\n\t\t\t/* install jump to catch call to _dl_debug_state */\n\t\t\t/* see comment int hack_ld_linux_plt for explainations */\n\t\t\thack_ld_linux_plt(ld_linuxBaseAddr + shdr->sh_addr); \n#endif\n\t\t}/* shdr->sh_addr != 0 */ \n\t\t}\n\t\tif( !strncmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPIhighmem_\",18)){\n\t\t\t/*the layout of dyninstAPIhighmem_ is:\n\t\t\tpageData\n\t\t\taddress of update\n\t\t\tsize of update\n\t\t\t...\t\n\t\t\taddress of update\n\t\t\tsize of update\t\n\t\t\tnumber of updates\n\t\n\t\t\twe must ONLY overwrite the updates, the other\n\t\t\tareas of the page may be important (and different than\n\t\t\tthe saved data in the file.  we first copy out the\n\t\t\tpage, the apply the updates to it, and then\n\t\t\twrite it back.\n\t\t\t*/\n\n\t\t\tint oldPageDataSize;\n\t\t\tint count =0;\n\n\t\t\tretVal = 1; /* just to be sure */\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\tnumberUpdates = 0;\n\t\t\t\n\t\t\t/*this section may be padded out with zeros to align the next section\n\t\t\t  so we need to look backwards until we find a nonzero value */\n\t\t\twhile(numberUpdates == 0){\n\t\t\t\tcount++;\n\t\t\t\tnumberUpdates = (unsigned int) ( ((unsigned int*) elfData->d_buf)[\n\t\t\t\t\t(elfData->d_size - (sizeof(unsigned int)*count))/ sizeof(unsigned int) ]);\n\t\t\t}\n\n\t\t\t/*fprintf(stderr,\" numberUpdates: %d :: (%d - 4) / 4  %x\\n\", numberUpdates, elfData->d_size, (unsigned int*) &elfData->d_buf );*/\n\n\t\t\toldPageDataSize = shdr->sh_size-(((2*numberUpdates)* sizeof(unsigned int)) +((sizeof(unsigned int)*count))) ;\n\n\n\t\t\toldPageData = (char*) malloc(oldPageDataSize+sizeof(unsigned long));\n\t\t\t/*fprintf(stderr,\"oldpagedatasize %d datasize %d \\n\",oldPageDataSize,elfData->d_size);\n\t\t\tperror(\"malloc\");*/\n\t\t\t/*copy old page data */\n\n\n\t\t\t/* probe memory to see if we own it */\n\t\t\tcheckAddr = dladdr((void*)shdr->sh_addr, &dlip);\n\n\n\t\t\tupdateSize  = shdr->sh_size-((2*numberUpdates)* (sizeof(unsigned int)) -(count* (sizeof(unsigned int))));\n\t\t\t/*fprintf(stderr,\" updateSize : %d-((2 * %d + 1) * 4))\",shdr->sh_size, numberUpdates);*/\n\t\n\t\t\tif(!checkAddr){ \n\t\t\t\t/* we dont own it,mmap it!*/\n\n                        \tmmapAddr = shdr->sh_offset;\n                        \tmmapAddr =(unsigned long) mmap((void*) shdr->sh_addr,oldPageDataSize,\n                                \tPROT_READ|PROT_WRITE|PROT_EXEC,MAP_FIXED|MAP_PRIVATE,fd,mmapAddr);\n\t\t\t\t\t/*fprintf(stderr,\"MMAP %x %d %x size: %x\\n\",shdr->sh_addr, mmapAddr,shdr->sh_offset,oldPageDataSize);*/\n\t\t\t\t\t\n\n\t\t\t}else{\n\t\t\t\t/*we own it, finish the memcpy */\n\t\t\t\tmmapAddr = (unsigned long) memcpy((void*) oldPageData, \n                                      (const void*) shdr->sh_addr, oldPageDataSize);\n\t\t\t\t/*fprintf(stderr,\"memcpy %x %d\\n\",shdr->sh_addr, updateSize);*/\n\n\t\t\t}\n\n\t\t\tdataPtr =(unsigned long *) &(((char*)  elfData->d_buf)[oldPageDataSize]);\t\n\t\t\t/*apply updates*/\n\t\t\tfor(i = 0; i< numberUpdates; i++){\n\t\t\t\tupdateAddress = *dataPtr; \n\t\t\t\tupdateSize = *(++dataPtr);\n\n\t\t\t\tupdateOffset = updateAddress - shdr->sh_addr;\n\t\t\t\t/*do update*/\t\n\t\t\t\t/*fprintf(stderr,\"updateAddress %x : %x %x %d %d\\n\",updateAddress,&( oldPageData[updateOffset]), &(((char*)elfData->d_buf)[updateOffset]) , updateSize,updateOffset);*/\n\t\t\t\tmemcpy(&( oldPageData[updateOffset]),\n\t\t\t\t\t\t&(((char*)elfData->d_buf)[updateOffset]) , updateSize);\t\n\n\t\t\t\tdataPtr ++;\n\n\t\t\t\n\t\t\t} \n\t\t\tif(!checkAddr){\n\t\t\t\tmmapAddr = shdr->sh_offset ;\n\n\t\t\t\tmmapAddr =(unsigned long) mmap((void*) shdr->sh_addr,oldPageDataSize, \n\t\t\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED| MAP_PRIVATE,fd,mmapAddr);\n\n\t\t\t\t\t/*fprintf(stderr,\"2MMAP %x %d\\n\",shdr->sh_addr, mmapAddr);*/\n\n\n\t\t\t}else{\n\n\t\t\t\tmemcpy((void*) shdr->sh_addr, oldPageData,oldPageDataSize );\n\t\t\t\t/*fprintf(stderr,\"2memcpy %x %d\\n\",shdr->sh_addr, oldPageDataSize);*/\n\n\t\t\t}\n\t\t}\n\t\tif(!strcmp((char *)strData->d_buf + shdr->sh_name, \"dyninstAPI_loadLib\")){\n\t\t\t/* ccw 14 may 2002 */\n\t\t\t/* this section loads shared libraries into the mutated binary\n\t\t\t\tthat were loaded by BPatch_thread::loadLibrary */\n\t\t\tvoid * handle =NULL;\n\t\t\telfData = Elf_getdata(scn, NULL);\n\t\t\ttmpPtr = elfData->d_buf;\n\n\t\t\twhile(*tmpPtr) { \n\t\t\t\thandle = dlopen(tmpPtr, RTLD_LAZY);\n\t\t\t\tif(handle){\n\n\t\t\t\t}else{\n\n\t\t\t\t\tprintf(\" %s cannot be loaded at the correct address\\n\", tmpPtr );\n\t\t\t\t\tprintf(\" This is an unrecoverable error, the instrumentation will not\");\n\t\t\t\t\tprintf(\"\\n run correctly if shared libraries are loaded at a different address\\n\");\n\t\t\t\t\tprintf(\"\\n Exiting.....\\n\");\n\n\t\t\t\t\tprintf(\"\\n%s\\n\",dlerror());\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t\texit(9);\n\n\t\t\t\t}\n                                /* brk ptr not used for ELF */\n\t\t\t\ttmpPtr += (strlen(tmpPtr) +1 + sizeof(void *));\t\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\n        Elf_end(elf);\n        close(fd);\n\n\tfree(execStr);\n\n\tif(soError){\n\t\texit(2);\n\t}\n\n        for(i=0;i < trampGuardSize_; i++){\n            trampGuardBase_[i]=1;\n        }\n        \n\treturn retVal;\n}\n/* vim:set ts=5: */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI_RT/src/RTlinux.c": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/************************************************************************\n * $Id: RTlinux.c,v 1.54 2008/04/11 23:30:44 legendre Exp $\n * RTlinux.c: mutatee-side library function specific to Linux\n ************************************************************************/\n\n#include \"dyninstAPI_RT/h/dyninstAPI_RT.h\"\n#include \"dyninstAPI_RT/src/RTthread.h\"\n#include \"dyninstAPI_RT/src/RTcommon.h\"\n#include <assert.h>\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n\n#if !defined(DYNINST_RT_STATIC_LIB)\n#include <dlfcn.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <link.h>\n\n#if defined(DYNINST_RT_STATIC_LIB)\n/* \n * The weak symbol here removes the dependence of the static version of this\n * library on pthread_self. If pthread_self is available, then it will be\n * linked.  Otherwise, the linker will ignore it.\n */\n#pragma weak pthread_self\nextern pthread_t pthread_self(void);\n#else\n#include <pthread.h>\n#endif\n\nextern double DYNINSTstaticHeap_512K_lowmemHeap_1[];\nextern double DYNINSTstaticHeap_16M_anyHeap_1[];\nextern unsigned long sizeOfLowMemHeap1;\nextern unsigned long sizeOfAnyHeap1;\n\nstatic struct trap_mapping_header *getStaticTrapMap(unsigned long addr);\n\n#if defined(arch_power) && defined(arch_64bit) && defined(os_linux)\nunsigned long DYNINSTlinkSave;\nunsigned long DYNINSTtocSave;\n#endif\n\n/************************************************************************\n * void DYNINSTbreakPoint(void)\n *\n * stop oneself.\n************************************************************************/\n\n#ifndef SYS_tkill\n#define SYS_tkill 238\n#endif\n\nint t_kill(int pid, int sig) {\n    static int has_tkill = 1;\n    long int result = 0;\n    if (has_tkill) {\n        result = syscall(SYS_tkill, pid, sig);\n        if (result == -1 && errno == ENOSYS) {\n            has_tkill = 0;\n        }\n    }\n    if (!has_tkill) {\n        result = kill(pid, sig);\n    }\n\n    return (result == 0);\n}\n\nvoid DYNINSTbreakPoint()\n{\n   /* We set a global flag here so that we can tell\n      if we're ever in a call to this when we get a \n      SIGBUS */\n   if (DYNINSTstaticMode)\n      return;\n\n   DYNINST_break_point_event = 1;\n   while (DYNINST_break_point_event)  {\n      t_kill(dyn_lwp_self(), DYNINST_BREAKPOINT_SIGNUM);\n   }\n   /* Mutator resets to 0... */\n}\n\nstatic int failed_breakpoint = 0;\nvoid uncaught_breakpoint(int sig)\n{\n   (void)sig; /* unused parameter */\n   failed_breakpoint = 1;\n}\n\nvoid DYNINSTlinuxBreakPoint()\n{\n   struct sigaction act, oldact;\n   int result;\n   \n   if (DYNINSTstaticMode)\n      return;\n\n   memset(&oldact, 0, sizeof(struct sigaction));\n   memset(&act, 0, sizeof(struct sigaction));\n\n   result = sigaction(DYNINST_BREAKPOINT_SIGNUM, NULL, &act);\n   if (result == -1) {\n      perror(\"DyninstRT library failed sigaction1\");\n      return;\n   }\n   act.sa_handler = uncaught_breakpoint;\n\n   result = sigaction(DYNINST_BREAKPOINT_SIGNUM, &act, &oldact);\n   if (result == -1) {\n      perror(\"DyninstRT library failed sigaction2\");\n      return;\n   }\n\n   DYNINST_break_point_event = 1;\n   failed_breakpoint = 0;\n   kill(dyn_lwp_self(), DYNINST_BREAKPOINT_SIGNUM);\n   if (failed_breakpoint) {\n      DYNINST_break_point_event = 0;\n      failed_breakpoint = 0;\n   }\n\n   result = sigaction(DYNINST_BREAKPOINT_SIGNUM, &oldact, NULL);\n   if (result == -1) {\n      perror(\"DyninstRT library failed sigaction3\");\n      return;\n   }\n}\n\nvoid DYNINSTsafeBreakPoint()\n{\n   if (DYNINSTstaticMode)\n      return;\n\n    DYNINST_break_point_event = 2; /* Not the same as above */\n    //    while (DYNINST_break_point_event)\n    kill(dyn_lwp_self(), SIGSTOP);\n}\n\nvoid mark_heaps_exec() {\n\t/* Grab the page size, to align the heap pointer. */\n\tlong int pageSize = sysconf( _SC_PAGESIZE );\n\tif( pageSize == 0 || pageSize == - 1 ) {\n\t\tfprintf( stderr, \"*** Failed to obtain page size, guessing 16K.\\n\" );\n\t\tperror( \"mark_heaps_exec\" );\n\t\tpageSize = 1024 * 16;\n\t\t} /* end pageSize initialization */\n\n\t/* Align the heap pointer. */\n\tunsigned long int alignedHeapPointer = (unsigned long int) DYNINSTstaticHeap_16M_anyHeap_1;\n\talignedHeapPointer = (alignedHeapPointer) & ~(pageSize - 1);\n\tunsigned long int adjustedSize = (unsigned long int) DYNINSTstaticHeap_16M_anyHeap_1 - alignedHeapPointer + sizeOfAnyHeap1;\n\n\t/* Make the heap's page executable. */\n\tint result = mprotect( (void *) alignedHeapPointer, (size_t) adjustedSize, PROT_READ | PROT_WRITE | PROT_EXEC );\n\tif( result != 0 ) {\n\t\tfprintf( stderr, \"%s[%d]: Couldn't make DYNINSTstaticHeap_16M_anyHeap_1 executable!\\n\", __FILE__, __LINE__);\n\t\tperror( \"mark_heaps_exec\" );\n\t\t}\n\tRTprintf( \"*** Marked memory from 0x%lx to 0x%lx executable.\\n\", alignedHeapPointer, alignedHeapPointer + adjustedSize );\n\n\t/* Mark _both_ heaps executable. */\n\talignedHeapPointer = (unsigned long int) DYNINSTstaticHeap_512K_lowmemHeap_1;\n\talignedHeapPointer = (alignedHeapPointer) & ~(pageSize - 1);\n\tadjustedSize = (unsigned long int) DYNINSTstaticHeap_512K_lowmemHeap_1 - alignedHeapPointer + sizeOfLowMemHeap1;\n\n\t/* Make the heap's page executable. */\n\tresult = mprotect( (void *) alignedHeapPointer, (size_t) adjustedSize, PROT_READ | PROT_WRITE | PROT_EXEC );\n\tif( result != 0 ) {\n\t\tfprintf( stderr, \"%s[%d]: Couldn't make DYNINSTstaticHeap_512K_lowmemHeap_1 executable!\\n\", __FILE__, __LINE__ );\n\t\tperror( \"mark_heaps_exec\" );\n\t\t}\n\tRTprintf( \"*** Marked memory from 0x%lx to 0x%lx executable.\\n\", alignedHeapPointer, alignedHeapPointer + adjustedSize );\n\t} /* end mark_heaps_exec() */\n\n/************************************************************************\n * void DYNINSTos_init(void)\n *\n * OS initialization function\n************************************************************************/\nint DYNINST_sysEntry;\n\n#if !defined(DYNINST_RT_STATIC_LIB)\n/*\n * For now, removing dependence of static version of this library\n * on libdl.\n */\ntypedef struct dlopen_args {\n  const char *libname;\n  int mode;\n  void *result;\n  void *caller;\n} dlopen_args_t;\n\nvoid *(*DYNINST_do_dlopen)(dlopen_args_t *) = NULL;\n\nstatic int get_dlopen_error() {\n   char *err_str;\n   err_str = dlerror();\n   if (err_str) {\n      strncpy(gLoadLibraryErrorString, err_str, (size_t) ERROR_STRING_LENGTH);\n      return 1;\n   }\n   else {\n      sprintf(gLoadLibraryErrorString,\"unknown error with dlopen\");\n      return 0;\n   }\n   return 0;\n}\n\nint DYNINSTloadLibrary(char *libname)\n{\n   void *res;\n   gLoadLibraryErrorString[0]='\\0';\n   res = dlopen(libname, RTLD_LAZY | RTLD_GLOBAL);\n   if (res)\n   {\n      return 1;\n   }\n \n   get_dlopen_error();\n#if defined(arch_x86)\n   /* dlopen on recent glibcs has a \"security check\" so that\n      only registered modules can call it. Unfortunately, progs\n      that don't include libdl break this check, so that we\n      can only call _dl_open (the dlopen worker function) from\n      within glibc. We do this by calling do_dlopen\n      We fool this check by calling an addr written by the\n      mutator */\n   if (strstr(gLoadLibraryErrorString, \"invalid caller\") != NULL &&\n       DYNINST_do_dlopen != NULL) {\n      dlopen_args_t args;\n      args.libname = libname;\n      args.mode = RTLD_NOW | RTLD_GLOBAL;\n      args.result = 0;\n      args.caller = (void *)DYNINST_do_dlopen;\n      // There's a do_dlopen function in glibc. However, it's _not_\n      // exported; thus, getting the address is a bit of a pain. \n      \n      (*DYNINST_do_dlopen)(&args);\n      // Duplicate the above\n      if (args.result != NULL)\n      {\n         return 1;\n      }\n      else\n         get_dlopen_error();\n   }\n#endif\n   return 0;\n}\n#endif\n\n//Define this value so that we can compile on a system that doesn't have\n// gettid and still run on one that does.\n#if !defined(SYS_gettid)\n\n#if defined(arch_x86)\n#define SYS_gettid 224\n#elif defined(arch_x86_64)\n#define SYS_gettid 186\n#endif\n\n#endif\n\nint dyn_lwp_self()\n{\n   static int gettid_not_valid = 0;\n   int result;\n\n   if (gettid_not_valid)\n      return getpid();\n\n   result = syscall((long int) SYS_gettid);\n   if (result == -1 && errno == ENOSYS)\n   {\n      gettid_not_valid = 1;\n      return getpid();\n   }\n   return result;  \n}\n\nint dyn_pid_self()\n{\n   return getpid();\n}\n\ndyntid_t (*DYNINST_pthread_self)(void);\n\ndyntid_t dyn_pthread_self()\n{\n   dyntid_t me;\n   if (DYNINSTstaticMode) {\n#if defined(DYNINST_RT_STATIC_LIB)\n       /* This special case is necessary because the static\n        * version of libc doesn't define a version of pthread_self\n        * unlike the shared version of the library.\n        */\n       if( !pthread_self ) {\n           return (dyntid_t) DYNINST_SINGLETHREADED;\n       }\n#endif\n      return (dyntid_t) pthread_self();\n   }\n   if (!DYNINST_pthread_self) {\n      return (dyntid_t) DYNINST_SINGLETHREADED;\n   }\n   me = (*DYNINST_pthread_self)();\n   return (dyntid_t) me;\n}\n\n/* \n   We reserve index 0 for the initial thread. This value varies by\n   platform but is always constant for that platform. Wrap that\n   platform-ness here. \n*/\nint DYNINST_am_initial_thread( dyntid_t tid ) {\n\t(void)tid; /* unused parameter */\n\tif( dyn_lwp_self() == getpid() ) {\n\t\treturn 1;\n   }\n\treturn 0;\n} /* end DYNINST_am_initial_thread() */\n\n#if defined(cap_mutatee_traps)\n\n#include <ucontext.h>\n\n// Register numbers experimentally verified\n\n#if defined(arch_x86)\n  #define UC_PC(x) x->uc_mcontext.gregs[14]\n#elif defined(arch_x86_64)\n  #if defined(MUTATEE_32)\n    #define UC_PC(x) x->uc_mcontext.gregs[14]\n  #else // 64-bit\n    #define UC_PC(x) x->uc_mcontext.gregs[16]\n  #endif // amd-64\n#elif defined(arch_power)\n  #if defined(arch_64bit)\n    #define UC_PC(x) x->uc_mcontext.regs->gpr[32]\n  #else // 32-bit\n    #define UC_PC(x) x->uc_mcontext.uc_regs->gregs[32]\n  #endif // power\n#endif // UC_PC\n\nextern volatile unsigned long dyninstTrapTableUsed;\nextern volatile unsigned long dyninstTrapTableVersion;\nextern volatile trapMapping_t *dyninstTrapTable;\nextern volatile unsigned long dyninstTrapTableIsSorted;\n\n/**\n * This comment is now obsolete, left for historic purposes\n *\n * Called by the SIGTRAP handler, dyninstTrapHandler.  This function is \n * closly intwined with dyninstTrapHandler, don't modify one without \n * understanding the other.\n *\n * This function sets up the calling context that was passed to the\n * SIGTRAP handler so that control will be redirected to our instrumentation\n * when we do the setcontext call.\n * \n * There are a couple things that make this more difficult than it should be:\n *   1. The OS provided calling context is similar to the GLIBC calling context,\n *      but not compatible.  We'll create a new GLIBC compatible context and\n *      copy the possibly stomped registers from the OS context into it.  The\n *      incompatiblities seem to deal with FP and other special purpose registers.\n *   2. setcontext doesn't restore the flags register.  Thus dyninstTrapHandler\n *      will save the flags register first thing and pass us its value in the\n *      flags parameter.  We'll then push the instrumentation entry and flags\n *      onto the context's stack.  Instead of transfering control straight to the\n *      instrumentation, we'll actually go back to dyninstTrapHandler, which will\n *      do a popf/ret to restore flags and go to instrumentation.  The 'retPoint'\n *      parameter is the address in dyninstTrapHandler the popf/ret can be found.\n **/\n\nvoid dyninstTrapHandler(int sig, siginfo_t *sg, ucontext_t *context)\n{\n   void *orig_ip;\n   void *trap_to;\n   (void)sig; /* unused parameter */\n   (void)sg; /* unused parameter */\n\n   orig_ip = (void *) UC_PC(context);\n   assert(orig_ip);\n   // Find the new IP we're going to and substitute. Leave everything else untouched.\n   if (DYNINSTstaticMode) {\n      unsigned long zero = 0;\n      unsigned long one = 1;\n      struct trap_mapping_header *hdr = getStaticTrapMap((unsigned long) orig_ip);\n      assert(hdr);\n      volatile trapMapping_t *mapping = &(hdr->traps[0]);\n      trap_to = dyninstTrapTranslate(orig_ip,\n                                     (unsigned long *) &hdr->num_entries, \n                                     &zero, \n                                     &mapping,\n                                     &one);\n   }\n   else {\n      trap_to = dyninstTrapTranslate(orig_ip, \n                                     &dyninstTrapTableUsed,\n                                     &dyninstTrapTableVersion,\n                                     &dyninstTrapTable,\n                                     &dyninstTrapTableIsSorted);\n                                     \n   }\n   UC_PC(context) = (long) trap_to;\n}\n\n#if defined(cap_binary_rewriter)\n\nextern struct r_debug _r_debug;\nDLLEXPORT struct r_debug _r_debug __attribute__ ((weak));\n\n/* Verify that the r_debug variable is visible */\nvoid r_debugCheck() { assert(_r_debug.r_map); }\n\n#define NUM_LIBRARIES 512 //Important, max number of rewritten libraries\n\n#define WORD_SIZE (8 * sizeof(unsigned))\n#define NUM_LIBRARIES_BITMASK_SIZE (1 + NUM_LIBRARIES / WORD_SIZE)\nstruct trap_mapping_header *all_headers[NUM_LIBRARIES];\n\nstatic unsigned all_headers_current[NUM_LIBRARIES_BITMASK_SIZE];\nstatic unsigned all_headers_last[NUM_LIBRARIES_BITMASK_SIZE];\n\n#if !defined(arch_x86_64) || defined(MUTATEE_32)\ntypedef Elf32_Dyn ElfX_Dyn;\n#else\ntypedef Elf64_Dyn ElfX_Dyn;\n#endif\n\nstruct trap_mapping_header *getStaticTrapMap(unsigned long addr);\n\nstatic int parse_libs();\nstatic int parse_link_map(struct link_map *l);\nstatic void clear_unloaded_libs();\n\nstatic void set_bit(unsigned *bit_mask, int bit, char value);\n//static char get_bit(unsigned *bit_mask, int bit);\nstatic void clear_bitmask(unsigned *bit_mask);\nstatic unsigned get_next_free_bitmask(unsigned *bit_mask, int last_pos);\nstatic unsigned get_next_set_bitmask(unsigned *bit_mask, int last_pos);\n\nstatic tc_lock_t trap_mapping_lock;\n\nstatic struct trap_mapping_header *getStaticTrapMap(unsigned long addr)\n{\n   struct trap_mapping_header *header;\n   int i;\n   \n   tc_lock_lock(&trap_mapping_lock);\n   parse_libs();\n\n   i = -1;\n   for (;;) {\n      i = get_next_set_bitmask(all_headers_current, i);\n      assert(i >= 0 && i <= NUM_LIBRARIES);\n      if (i == NUM_LIBRARIES) {\n         header = NULL;\n         rtdebug_printf(\"%s[%d]:  getStaticTrapMap: returning NULL\\n\", __FILE__, __LINE__);\n         goto done;\n      }\n      header = all_headers[i];\n      if (addr >= header->low_entry && addr <= header->high_entry) {\n         goto done;\n      }\n   }  \n done:\n   tc_lock_unlock(&trap_mapping_lock);\n   return header;\n}\n\nstatic int parse_libs()\n{\n   struct link_map *l_current;\n\n   l_current = _r_debug.r_map;\n   if (!l_current) {\n        rtdebug_printf(\"%s[%d]:  parse_libs: _r_debug.r_map was not set\\n\", __FILE__, __LINE__);\n       return -1;\n   }\n\n   clear_bitmask(all_headers_current);\n   while (l_current) {\n      parse_link_map(l_current);\n      l_current = l_current->l_next;\n   }\n   clear_unloaded_libs();\n\n   return 0;\n}\n\n//parse_link_map return values\n#define PARSED 0\n#define NOT_REWRITTEN 1\n#define ALREADY_PARSED 2\n#define ERROR_INTERNAL -1\n#define ERROR_FULL -2\nstatic int parse_link_map(struct link_map *l) \n{\n   ElfX_Dyn *dynamic_ptr;\n   struct trap_mapping_header *header;\n   unsigned int i, new_pos;\n\n   dynamic_ptr = (ElfX_Dyn *) l->l_ld;\n   if (!dynamic_ptr)\n      return -1;\n\n   assert(sizeof(dynamic_ptr->d_un.d_ptr) == sizeof(void *));\n   for (; dynamic_ptr->d_tag != DT_NULL && dynamic_ptr->d_tag != DT_DYNINST; dynamic_ptr++);\n   if (dynamic_ptr->d_tag == DT_NULL) {\n      return NOT_REWRITTEN;\n   }\n\n   header = (struct trap_mapping_header *) (dynamic_ptr->d_un.d_val + l->l_addr);\n   \n   if (header->signature != TRAP_HEADER_SIG)\n      return ERROR_INTERNAL;\n   if (header->pos != -1) {\n      set_bit(all_headers_current, header->pos, 1);\n      assert(all_headers[header->pos] == header);\n      return ALREADY_PARSED;\n   }\n \n   for (i = 0; i < header->num_entries; i++)\n   {\n      header->traps[i].source = (void *) (((unsigned long) header->traps[i].source) + l->l_addr);\n      header->traps[i].target = (void *) (((unsigned long) header->traps[i].target) + l->l_addr);\n      if (!header->low_entry || header->low_entry > (unsigned long) header->traps[i].source)\n         header->low_entry = (unsigned long) header->traps[i].source;\n      if (!header->high_entry || header->high_entry < (unsigned long) header->traps[i].source)\n         header->high_entry = (unsigned long) header->traps[i].source;\n   }\n\n   new_pos = get_next_free_bitmask(all_headers_last, -1);\n   assert(new_pos < NUM_LIBRARIES);\n   if (new_pos == NUM_LIBRARIES)\n      return ERROR_FULL;\n\n   header->pos = new_pos;\n   all_headers[new_pos] = header;\n   set_bit(all_headers_current, new_pos, 1);\n   set_bit(all_headers_last, new_pos, 1);\n\n   return PARSED;\n}\n\nstatic void clear_unloaded_libs()\n{\n   unsigned i;\n   for (i = 0; i<NUM_LIBRARIES_BITMASK_SIZE; i++)\n   {\n      all_headers_last[i] = all_headers_current[i];\n   }\n}\n\nstatic void set_bit(unsigned *bit_mask, int bit, char value) {\n   assert(bit < NUM_LIBRARIES);\n   unsigned *word = bit_mask + bit / WORD_SIZE;\n   unsigned shift = bit % WORD_SIZE;\n   if (value) {\n      *word |= (1 << shift);\n   }\n   else {\n      *word &= ~(1 << shift);\n   }\n}\n\n//Wasn't actually needed\n/*\nstatic char get_bit(unsigned *bit_mask, int bit) {\n   assert(bit < NUM_LIBRARIES);\n   unsigned *word = bit_mask + bit / WORD_SIZE;\n   unsigned shift = bit % WORD_SIZE;\n   return (*word & (1 << shift)) ? 1 : 0;\n}\n*/\n\nstatic void clear_bitmask(unsigned *bit_mask) {\n   unsigned i;\n   for (i = 0; i < NUM_LIBRARIES_BITMASK_SIZE; i++) {\n      bit_mask[i] = 0;\n   }\n}\n\nstatic unsigned get_next_free_bitmask(unsigned *bit_mask, int last_pos) {\n   unsigned i, j;\n   j = last_pos+1;\n   i = j / WORD_SIZE;\n   for (; j < NUM_LIBRARIES; i++) {\n      if (bit_mask[i] == (unsigned) -1) {\n         j += WORD_SIZE;\n         continue;\n      }\n      for (;;) {\n         if (!((1 << (j % WORD_SIZE) & bit_mask[i]))) {\n            return j;\n         }\n         j++;\n         if (j % WORD_SIZE == 0) {\n            break;\n         }\n      }\n   }\n   return NUM_LIBRARIES;\n}\n\nstatic unsigned get_next_set_bitmask(unsigned *bit_mask, int last_pos) {\n   unsigned i, j;\n   j = last_pos+1;\n   i = j / WORD_SIZE;\n   for (; j < NUM_LIBRARIES; i++) {\n      if (bit_mask[i] == (unsigned) 0) {\n         j += WORD_SIZE;\n         continue;\n      }\n      for (;;) {\n         if ((1 << (j % WORD_SIZE) & bit_mask[i])) {\n            return j;\n         }\n         j++;\n         if (j % WORD_SIZE == 0) {\n            break;\n         }\n      }\n   }\n   return NUM_LIBRARIES;\n}\n\n#endif\n\n\n\n#endif /* cap_mutatee_traps */\n\n#if defined(cap_binary_rewriter) && !defined(DYNINST_RT_STATIC_LIB)\n/* For a static binary, all global constructors are combined in an undefined\n * order. Also, DYNINSTBaseInit must be run after all global constructors have\n * been run. Since the order of global constructors is undefined, DYNINSTBaseInit\n * cannot be run as a constructor in static binaries. Instead, it is run from a\n * special constructor handler that processes all the global constructors in\n * the binary. Leaving this code in would create a global constructor for the\n * function runDYNINSTBaseInit(). See DYNINSTglobal_ctors_handler.\n */ \nextern void r_debugCheck();\nextern void DYNINSTBaseInit();\nvoid runDYNINSTBaseInit() __attribute__((constructor));\nvoid runDYNINSTBaseInit()\n{\n    r_debugCheck();\n   DYNINSTBaseInit();\n}\n#endif\n\n\n/*\n//Small program for finding the correct values to fill in pos_in_pthreadt\n// above\n#include <pthread.h>\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define gettid() syscall(SYS_gettid)\n\npthread_attr_t attr;\n\nvoid *foo(void *f) {\n  pid_t pid, tid;\n  unsigned stack_addr;\n  unsigned best_stack = 0xffffffff;\n  int best_stack_pos = 0;\n  void *start_func;\n  int *p;\n  int i = 0;\n  pid = getpid();\n  tid = gettid();\n  start_func = foo;\n  //x86 only.  \n  asm(\"movl %%ebp,%0\" : \"=r\" (stack_addr));\n  p = (int *) pthread_self();\n  while (i < 1000)\n  {\n    if (*p == (unsigned) pid)\n      printf(\"pid @ %d\\n\", i);\n    if (*p == (unsigned) tid)\n      printf(\"lwp @ %d\\n\", i);\n    if (*p > stack_addr && *p < best_stack)\n    {\n      best_stack = *p;\n      best_stack_pos = i;\n    }\n    if (*p == (unsigned) start_func)\n      printf(\"func @ %d\\n\", i);\n    i += sizeof(int);\n    p++;\n  }  \n  printf(\"stack @ %d\\n\", best_stack_pos);\n  return NULL;\n}\n\nint main(int argc, char *argv[])\n{\n  pthread_t t;\n  void *result;\n  pthread_attr_init(&attr);\n  pthread_create(&t, &attr, foo, NULL);\n  pthread_join(t, &result);\n  return 0;\n}\n*/\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI_RT/src/RTfreebsd.c": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/************************************************************************\n * $Id: RTlinux.c,v 1.54 2008/04/11 23:30:44 legendre Exp $\n * RTlinux.c: mutatee-side library function specific to Linux\n ************************************************************************/\n\n#include \"dyninstAPI_RT/h/dyninstAPI_RT.h\"\n#include \"dyninstAPI_RT/src/RTthread.h\"\n#include \"dyninstAPI_RT/src/RTcommon.h\"\n#include <assert.h>\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <link.h>\n\n/* FreeBSD libc has stubs so a static version shouldn't need libpthreads */\n#include <pthread.h>\n\nextern double DYNINSTstaticHeap_512K_lowmemHeap_1[];\nextern double DYNINSTstaticHeap_16M_anyHeap_1[];\nextern unsigned long sizeOfLowMemHeap1;\nextern unsigned long sizeOfAnyHeap1;\n\nstatic struct trap_mapping_header *getStaticTrapMap(unsigned long addr);\n\n/** RT lib initialization **/\n\nvoid mark_heaps_exec() {\n    RTprintf( \"*** Initializing dyninstAPI runtime.\\n\" );\n\n    /* Grab the page size, to align the heap pointer. */\n    long int pageSize = sysconf( _SC_PAGESIZE );\n    if( pageSize == 0 || pageSize == - 1 ) {\n        fprintf( stderr, \"*** Failed to obtain page size, guessing 16K.\\n\" );\n        perror( \"mark_heaps_exec\" );\n        pageSize = 1024 * 16;\n    } /* end pageSize initialization */\n\n    /* Align the heap pointer. */\n    unsigned long int alignedHeapPointer = (unsigned long int) DYNINSTstaticHeap_16M_anyHeap_1;\n    alignedHeapPointer = (alignedHeapPointer) & ~(pageSize - 1);\n    unsigned long int adjustedSize = (unsigned long int) DYNINSTstaticHeap_16M_anyHeap_1 - alignedHeapPointer + sizeOfAnyHeap1;\n\n    /* Make the heap's page executable. */\n    int result = mprotect( (void *) alignedHeapPointer, (size_t) adjustedSize, PROT_READ | PROT_WRITE | PROT_EXEC );\n    if( result != 0 ) {\n        fprintf( stderr, \"%s[%d]: Couldn't make DYNINSTstaticHeap_16M_anyHeap_1 executable!\\n\", __FILE__, __LINE__);\n        perror( \"mark_heaps_exec\" );\n    }\n    RTprintf( \"*** Marked memory from 0x%lx to 0x%lx executable.\\n\", alignedHeapPointer, alignedHeapPointer + adjustedSize );\n\n    /* Mark _both_ heaps executable. */\n    alignedHeapPointer = (unsigned long int) DYNINSTstaticHeap_512K_lowmemHeap_1;\n    alignedHeapPointer = (alignedHeapPointer) & ~(pageSize - 1);\n    adjustedSize = (unsigned long int) DYNINSTstaticHeap_512K_lowmemHeap_1 - alignedHeapPointer + sizeOfLowMemHeap1;\n\n    /* Make the heap's page executable. */\n    result = mprotect( (void *) alignedHeapPointer, (size_t) adjustedSize, PROT_READ | PROT_WRITE | PROT_EXEC );\n    if( result != 0 ) {\n        fprintf( stderr, \"%s[%d]: Couldn't make DYNINSTstaticHeap_512K_lowmemHeap_1 executable!\\n\", __FILE__, __LINE__ );\n        perror( \"mark_heaps_exec\" );\n    }\n    RTprintf( \"*** Marked memory from 0x%lx to 0x%lx executable.\\n\", alignedHeapPointer, alignedHeapPointer + adjustedSize );\n} /* end mark_heaps_exec() */\n\n\n#if defined(cap_binary_rewriter) && !defined(DYNINST_RT_STATIC_LIB)\n/* For a static binary, all global constructors are combined in an undefined\n * order. Also, DYNINSTBaseInit must be run after all global constructors have\n * been run. Since the order of global constructors is undefined, DYNINSTBaseInit\n * cannot be run as a constructor in static binaries. Instead, it is run from a\n * special constructor handler that processes all the global constructors in\n * the binary. Leaving this code in would create a global constructor for the\n * function runDYNINSTBaseInit(). See DYNINSTglobal_ctors_handler.\n */ \nextern void DYNINSTBaseInit();\nvoid runDYNINSTBaseInit() __attribute__((constructor));\nvoid runDYNINSTBaseInit()\n{\n   DYNINSTBaseInit();\n}\n#endif\n\n/** Dynamic instrumentation support **/\n\nstatic\nint tkill(pid_t pid, long lwp, int sig) {\n    static int has_tkill = 1;\n    int result = 0;\n\n    if( has_tkill ) {\n        result = syscall(SYS_thr_kill2, pid, lwp, sig);\n        if( 0 != result && ENOSYS == errno ) {\n            has_tkill = 0;\n        }\n    }\n\n    if( !has_tkill ) {\n        result = kill(pid, sig);\n    }\n\n    return (result == 0);\n}\n\nvoid DYNINSTbreakPoint()\n{\n    if(DYNINSTstaticMode) return;\n\n    DYNINST_break_point_event = 1;\n    while( DYNINST_break_point_event ) {\n        tkill(getpid(), dyn_lwp_self(), DYNINST_BREAKPOINT_SIGNUM);\n    }\n    /* Mutator resets to 0 */\n}\n\nstatic int failed_breakpoint = 0;\nvoid uncaught_breakpoint(int sig)\n{\n   failed_breakpoint = 1;\n}\n\nvoid DYNINSTsafeBreakPoint()\n{\n    if(DYNINSTstaticMode) return;\n\n    DYNINST_break_point_event = 1;\n    while( DYNINST_break_point_event ) {\n        tkill(getpid(), dyn_lwp_self(), SIGSTOP);\n    }\n    /* Mutator resets to 0 */\n\n#if 0\n    if( DYNINSTstaticMode ) return;\n    DYNINST_break_point_event = 2;\n    sigset_t emptyset;\n    sigemptyset(&emptyset);\n\n    // There is a bug with attaching to a stopped process on FreeBSD This\n    // achieves the same result as long as Dyninst attaches to the process when\n    // it is in sigsuspend\n    while( DYNINST_break_point_event ) {\n        sigsuspend(&emptyset);\n    }\n#endif\n}\n\n#if !defined(DYNINST_RT_STATIC_LIB)\nstatic int get_dlopen_error() {\n    const char *err_str;\n    err_str = dlerror();\n    if( err_str ) {\n        strncpy(gLoadLibraryErrorString, err_str, (size_t) ERROR_STRING_LENGTH);\n        return 1;\n    }\n\n    sprintf(gLoadLibraryErrorString, \"unknown error withe dlopen\");\n    return 0;\n}\n\nint DYNINSTloadLibrary(char *libname)\n{\n    void *res;\n    gLoadLibraryErrorString[0] = '\\0';\n    res = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);\n    if( res ) return 1;\n\n    get_dlopen_error();\n    return 0;\n}\n#endif\n\n/** threading support **/\n\nint dyn_lwp_self()\n{\n    static int gettid_not_valid = 0;\n    int result;\n    \n    if( gettid_not_valid )\n        return getpid();\n\n    long lwp_id;\n    result = syscall(SYS_thr_self, &lwp_id);\n    if( result && errno == ENOSYS ) {\n        gettid_not_valid = 1;\n        return getpid();\n    }\n\n    return lwp_id;\n}\n\nint dyn_pid_self()\n{\n   return getpid();\n}\n\ndyntid_t (*DYNINST_pthread_self)(void);\n\ndyntid_t dyn_pthread_self()\n{\n   dyntid_t me;\n   if (DYNINSTstaticMode) {\n      return (dyntid_t) pthread_self();\n   }\n   if (!DYNINST_pthread_self) {\n      return (dyntid_t) DYNINST_SINGLETHREADED;\n   }\n   me = (*DYNINST_pthread_self)();\n   return (dyntid_t) me;\n}\n\nint DYNINST_am_initial_thread( dyntid_t tid ) {\n    /*\n     * LWPs and PIDs are in different namespaces on FreeBSD.\n     *\n     * I don't really know a good way to determine this without\n     * doing an expensive sysctl.\n     *\n     * Luckily, this function isn't used anymore\n     */\n    assert(!\"This function is unimplemented on FreeBSD\");\n    return 0;\n}\n\n/** trap based instrumentation **/\n\n#if defined(cap_mutatee_traps)\n\n#include <ucontext.h>\n\n#if defined(arch_x86) || defined(MUTATEE_32)\n#define UC_PC(x) x->uc_mcontext.mc_eip\n#elif defined(arch_x86_64)\n#define UC_PC(x) x->uc_mcontext.mc_rip\n#endif // UC_PC\n\nextern unsigned long dyninstTrapTableUsed;\nextern unsigned long dyninstTrapTableVersion;\nextern trapMapping_t *dyninstTrapTable;\nextern unsigned long dyninstTrapTableIsSorted;\n\n/**\n * This comment is now obsolete, left for historic purposes\n *\n * Called by the SIGTRAP handler, dyninstTrapHandler.  This function is \n * closly intwined with dyninstTrapHandler, don't modify one without \n * understanding the other.\n *\n * This function sets up the calling context that was passed to the\n * SIGTRAP handler so that control will be redirected to our instrumentation\n * when we do the setcontext call.\n * \n * There are a couple things that make this more difficult than it should be:\n *   1. The OS provided calling context is similar to the GLIBC calling context,\n *      but not compatible.  We'll create a new GLIBC compatible context and\n *      copy the possibly stomped registers from the OS context into it.  The\n *      incompatiblities seem to deal with FP and other special purpose registers.\n *   2. setcontext doesn't restore the flags register.  Thus dyninstTrapHandler\n *      will save the flags register first thing and pass us its value in the\n *      flags parameter.  We'll then push the instrumentation entry and flags\n *      onto the context's stack.  Instead of transfering control straight to the\n *      instrumentation, we'll actually go back to dyninstTrapHandler, which will\n *      do a popf/ret to restore flags and go to instrumentation.  The 'retPoint'\n *      parameter is the address in dyninstTrapHandler the popf/ret can be found.\n **/\nvoid dyninstTrapHandler(int sig, siginfo_t *sg, ucontext_t *context)\n{\n   void *orig_ip;\n   void *trap_to;\n\n   orig_ip = UC_PC(context);\n   assert(orig_ip);\n\n   // Find the new IP we're going to and substitute. Leave everything else untouched\n   if (DYNINSTstaticMode) {\n      unsigned long zero = 0;\n      unsigned long one = 1;\n      struct trap_mapping_header *hdr = getStaticTrapMap((unsigned long) orig_ip);\n      if (!hdr) return;\n\n      assert(hdr);\n      trapMapping_t *mapping = &(hdr->traps[0]);\n      trap_to = dyninstTrapTranslate(orig_ip, \n                                     (unsigned long *) &hdr->num_entries, \n                                     &zero, \n                                     (volatile trapMapping_t **) &mapping,\n                                     &one);\n   }\n   else {\n      trap_to = dyninstTrapTranslate(orig_ip, \n                                     &dyninstTrapTableUsed,\n                                     &dyninstTrapTableVersion,\n                                     (volatile trapMapping_t **) &dyninstTrapTable,\n                                     &dyninstTrapTableIsSorted);\n                                     \n   }\n   UC_PC(context) = (long) trap_to;\n}\n\n#if defined(cap_binary_rewriter)\n\n#define NUM_LIBRARIES 512 //Important, max number of rewritten libraries\n\n#define WORD_SIZE (8 * sizeof(unsigned))\n#define NUM_LIBRARIES_BITMASK_SIZE (1 + NUM_LIBRARIES / WORD_SIZE)\nstruct trap_mapping_header *all_headers[NUM_LIBRARIES];\n\nstatic unsigned all_headers_current[NUM_LIBRARIES_BITMASK_SIZE];\nstatic unsigned all_headers_last[NUM_LIBRARIES_BITMASK_SIZE];\n\n#if !defined(arch_x86_64) || defined(MUTATEE_32)\ntypedef Elf32_Dyn ElfX_Dyn;\ntypedef Elf32_Ehdr ElfX_Ehdr;\n#else\ntypedef Elf64_Dyn ElfX_Dyn;\ntypedef Elf64_Ehdr ElfX_Ehdr;\n#endif\n\nstatic int parse_libs();\nstatic int parse_link_map(struct link_map *l);\nstatic void clear_unloaded_libs();\n\nstatic void set_bit(unsigned *bit_mask, int bit, char value);\nstatic void clear_bitmask(unsigned *bit_mask);\nstatic unsigned get_next_free_bitmask(unsigned *bit_mask, int last_pos);\nstatic unsigned get_next_set_bitmask(unsigned *bit_mask, int last_pos);\n\nstatic tc_lock_t trap_mapping_lock;\n\nstatic struct trap_mapping_header *getStaticTrapMap(unsigned long addr)\n{\n   struct trap_mapping_header *header;\n   int i;\n   \n   tc_lock_lock(&trap_mapping_lock);\n   parse_libs();\n\n   i = -1;\n   for (;;) {\n      i = get_next_set_bitmask(all_headers_current, i);\n      assert(i >= 0 && i <= NUM_LIBRARIES);\n      if (i == NUM_LIBRARIES) {\n         header = NULL;\n         goto done;\n      }\n      header = all_headers[i];\n      if (addr >= header->low_entry && addr <= header->high_entry) {\n         goto done;\n      }\n   }  \n done:\n   tc_lock_unlock(&trap_mapping_lock);\n   return header;\n}\n\nstatic struct link_map *getLinkMap() {\n    struct link_map *map = NULL;\n#if !defined(DYNINST_RT_STATIC_LIB)\n    if( dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &map) ) {\n        return NULL;\n    }\n\n    // Rewind the current link map pointer to find the\n    // start of the list\n    struct link_map *last_map;\n    while( map != NULL ) {\n        last_map = map;\n        map = map->l_prev;\n    }\n\n    map = last_map;\n#endif\n    return map;\n}\n\nstatic int parse_libs()\n{\n   struct link_map *l_current;\n\n   l_current = getLinkMap();\n   if (!l_current)\n      return -1;\n\n   clear_bitmask(all_headers_current);\n   while (l_current) {\n      parse_link_map(l_current);\n      l_current = l_current->l_next;\n   }\n   clear_unloaded_libs();\n\n   return 0;\n}\n\n//parse_link_map return values\n#define PARSED 0\n#define NOT_REWRITTEN 1\n#define ALREADY_PARSED 2\n#define ERROR_INTERNAL -1\n#define ERROR_FULL -2\nstatic int parse_link_map(struct link_map *l) \n{\n   ElfX_Dyn *dynamic_ptr;\n   struct trap_mapping_header *header;\n   unsigned int i, new_pos;\n\n   dynamic_ptr = (ElfX_Dyn *) l->l_ld;\n   if (!dynamic_ptr)\n      return -1;\n\n   assert(sizeof(dynamic_ptr->d_un.d_ptr) == sizeof(void *));\n   for (; dynamic_ptr->d_tag != DT_NULL && dynamic_ptr->d_tag != DT_DYNINST; dynamic_ptr++);\n   if (dynamic_ptr->d_tag == DT_NULL) {\n      return NOT_REWRITTEN;\n   }\n\n   header = (struct trap_mapping_header *) (dynamic_ptr->d_un.d_val + l->l_addr);\n\n   caddr_t libAddr = l->l_addr;\n\n   // Executables have an implicit zero load address but the library load address\n   // may be non-zero\n   if( ((ElfX_Ehdr *)libAddr)->e_type == ET_EXEC ) {\n       libAddr = 0;\n   }else if( ((ElfX_Ehdr *)libAddr)->e_type == ET_DYN ) {\n       // Account for library_adjust mechanism which is used for shared libraries\n       // on FreeBSD\n       libAddr += getpagesize();\n   }\n\n   header = (struct trap_mapping_header *) (dynamic_ptr->d_un.d_val + libAddr);\n   \n   if (header->signature != TRAP_HEADER_SIG)\n      return ERROR_INTERNAL;\n   if (header->pos != -1) {\n      set_bit(all_headers_current, header->pos, 1);\n      assert(all_headers[header->pos] == header);\n      return ALREADY_PARSED;\n   }\n \n   for (i = 0; i < header->num_entries; i++)\n   {\n      header->traps[i].source = (void *) (((unsigned long) header->traps[i].source) + libAddr);\n      header->traps[i].target = (void *) (((unsigned long) header->traps[i].target) + libAddr);\n      if (!header->low_entry || header->low_entry > (unsigned long) header->traps[i].source)\n         header->low_entry = (unsigned long) header->traps[i].source;\n      if (!header->high_entry || header->high_entry < (unsigned long) header->traps[i].source)\n         header->high_entry = (unsigned long) header->traps[i].source;\n   }\n\n   new_pos = get_next_free_bitmask(all_headers_last, -1);\n   assert(new_pos >= 0 && new_pos < NUM_LIBRARIES);\n   if (new_pos == NUM_LIBRARIES)\n      return ERROR_FULL;\n\n   header->pos = new_pos;\n   all_headers[new_pos] = header;\n   set_bit(all_headers_current, new_pos, 1);\n   set_bit(all_headers_last, new_pos, 1);\n\n   return PARSED;\n}\n\nstatic void clear_unloaded_libs()\n{\n   unsigned i;\n   for (i = 0; i<NUM_LIBRARIES_BITMASK_SIZE; i++)\n   {\n      all_headers_last[i] = all_headers_current[i];\n   }\n}\n\nstatic void set_bit(unsigned *bit_mask, int bit, char value) {\n   assert(bit < NUM_LIBRARIES);\n   unsigned *word = bit_mask + bit / WORD_SIZE;\n   unsigned shift = bit % WORD_SIZE;\n   if (value) {\n      *word |= (1 << shift);\n   }\n   else {\n      *word &= ~(1 << shift);\n   }\n}\n\nstatic void clear_bitmask(unsigned *bit_mask) {\n   unsigned i;\n   for (i = 0; i < NUM_LIBRARIES_BITMASK_SIZE; i++) {\n      bit_mask[i] = 0;\n   }\n}\n\nstatic unsigned get_next_free_bitmask(unsigned *bit_mask, int last_pos) {\n   unsigned i, j;\n   j = last_pos+1;\n   i = j / WORD_SIZE;\n   for (; j < NUM_LIBRARIES; i++) {\n      if (bit_mask[i] == (unsigned) -1) {\n         j += WORD_SIZE;\n         continue;\n      }\n      for (;;) {\n         if (!((1 << (j % WORD_SIZE) & bit_mask[i]))) {\n            return j;\n         }\n         j++;\n         if (j % WORD_SIZE == 0) {\n            break;\n         }\n      }\n   }\n   return NUM_LIBRARIES;\n}\n\nstatic unsigned get_next_set_bitmask(unsigned *bit_mask, int last_pos) {\n   unsigned i, j;\n   j = last_pos+1;\n   i = j / WORD_SIZE;\n   for (; j < NUM_LIBRARIES; i++) {\n      if (bit_mask[i] == (unsigned) 0) {\n         j += WORD_SIZE;\n         continue;\n      }\n      for (;;) {\n         if ((1 << (j % WORD_SIZE) & bit_mask[i])) {\n            return j;\n         }\n         j++;\n         if (j % WORD_SIZE == 0) {\n            break;\n         }\n      }\n   }\n   return NUM_LIBRARIES;\n}\n\n#endif\n\n#endif /* cap_mutatee_traps */\n\n/*\n * Note: this program is for historical purposes only, we use libthread_db\n * now to get thread information.\n *\n * A program to determine the offsets of certain thread structures on FreeBSD\n *\n * This program should be compiled with the headers from the libthr library from\n * /usr/src. This can be installed using sysinstall. The following arguments \n * should be added to the compile once these headers are installed.\n *\n * -I/usr/src/lib/libthr/arch/amd64/include -I/usr/src/lib/libthr/thread\n *\n * Change amd64 to what ever is appropriate.\n\n#include <pthread.h>\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"thr_private.h\"\n\npthread_attr_t attr;\n\nvoid *foo(void *f) {\n    unsigned long stack_addr;\n    void *(*start_func)(void *);\n    unsigned long tid;\n\n    // Get all the values\n    syscall(SYS_thr_self, &tid);\n\n    start_func = foo;\n\n    asm(\"mov %%rbp,%0\" : \"=r\" (stack_addr));\n\n    pthread_t threadSelf = pthread_self();\n\n    printf(\"TID: %u == %u\\n\", tid, threadSelf->tid);\n    printf(\"STACK: 0x%lx == 0x%lx\\n\", stack_addr, threadSelf->attr.stackaddr_attr + threadSelf->attr.stacksize_attr);\n    printf(\"START: 0x%lx == 0x%lx\\n\", (unsigned long)start_func, (unsigned long)threadSelf->start_routine);\n\n    unsigned char *ptr = (unsigned char *)threadSelf;\n    unsigned long tidVal = *((unsigned long *)(ptr + offsetof(struct pthread, tid)));\n    unsigned long stackAddrVal = *((unsigned long *)(ptr + offsetof(struct pthread, attr) + offsetof(struct pthread_attr, stackaddr_attr)));\n    unsigned long stackSizeVal = *((unsigned long *)(ptr + offsetof(struct pthread, attr) + offsetof(struct pthread_attr, stacksize_attr)));\n    unsigned long startFuncVal = *((unsigned long *)(ptr + offsetof(struct pthread, start_routine)));\n\n    printf(\"TID = %u, offset = %u\\n\", tidVal, offsetof(struct pthread, tid));\n    printf(\"STACK = 0x%lx, offset = %u\\n\", stackAddrVal, offsetof(struct pthread, attr) + offsetof(struct pthread_attr, stackaddr_attr));\n    printf(\"SIZE = 0x%lx, offset = %u\\n\", stackSizeVal, offsetof(struct pthread, attr) + offsetof(struct pthread_attr, stacksize_attr));\n    printf(\"START = 0x%lx, offset = %u\\n\", startFuncVal, offsetof(struct pthread, start_routine));\n\n    return NULL;\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t t;\n    void *result;\n    pthread_attr_init(&attr);\n    pthread_create(&t, &attr, foo, NULL);\n    pthread_join(t, &result);\n\n    return 0;\n}\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/parseThat/configure.ac": "# Process this file with autoconf to produce a configure script.\nAC_INIT([parseThat], [1.0])\nAC_CONFIG_SRCDIR([src/config.C])\nAC_PREFIX_DEFAULT([.])\n#AC_CONFIG_AUX_DIR([../autodyninst])\nAC_LANG(C++)\n\n\nAC_SEARCH_LIBS(dlopen, dl)\n\nAC_ARG_WITH(dyninst,\n            [AS_HELP_STRING([--with-dyninst],[Base directory to look for dyninst headers and libraries])],\n            [DYNINST_LIB=\"${withval}/${PLATFORM}/lib\"\n             DYNINST_INC=\"${withval}/include\"],)\n\nAC_ARG_WITH(dyninst-lib,\n            [AS_HELP_STRING([--with-dyninst-lib],[Directory to look for dyninst libraries])],\n            [DYNINST_LIB=\"${withval}\"],)\n\nAC_ARG_WITH(dyninst-include,\n            [AS_HELP_STRING([--with-dyninst-include],[Directory to look for dyninst headers])],\n            [DYNINST_INC=\"${withval}\"],)\n\nAC_ARG_WITH(dwarf-lib,\n            [AS_HELP_STRING([--with-dwarf-include],[Directory to look for libdwarf])],\n            [DWARF_LIB=\"${withval}\"],)\n\nAC_ARG_WITH(elf-lib,\n            [AS_HELP_STRING([--with-elf-include],[Directory to look for libelf])],\n            [ELF_LIB=\"${withval}\"],)\n\nAC_ARG_WITH(liberty-lib,\n            [AS_HELP_STRING([--with-liberty-lib],[Link string to use for libiberty])],\n            [LIBERTY_LIB=\"${withval}\"],)\n\nif test -n ${DYNINST_ROOT}; then\n   # Add search paths to CPPFLAGS and LDFLAGS.\n   if test -z ${DYNINST_LIB}; then\n      DYNINST_LIB=\"${DYNINST_ROOT}/lib\"\n   fi\n   if test -z ${DYNINST_INC}; then\n      DYNINST_INC=\"${DYNINST_ROOT}/include\"\n   fi\nfi\n\nAC_SUBST([LDFLAGS], [\"-L${DYNINST_LIB} ${LDFLAGS}\"])\nAC_SUBST([DWARFFLAGS], [\"${DWARF_LIB}\"])\nAC_SUBST([ELFFLAGS], [\"${ELF_LIB}\"])\nAC_SUBST([LIBERTYFLAGS], [\"${LIBERTY_LIB}\"])\nAC_SUBST([CPPFLAGS], [\"-I${DYNINST_INC} ${CPPFLAGS}\"])\n\n# Generate host string.\nAC_CANONICAL_HOST()\n\n# Build all configure tests with C++ compiler.\nAC_LANG([C++])\n\n# sha1.C requres these system files and endianess to be tested.\nAC_CHECK_HEADERS([inttypes.h], [], [], [// Do not use default includes])\nAC_CHECK_HEADERS([stdint.h], [], [], [// Do not use default includes])\nAC_C_BIGENDIAN()\n\n# Search for Dyninst in all the right places.\nAC_CHECK_HEADER([BPatch.h], [],\n\t\t[AC_MSG_ERROR([Cannot find DyninstAPI library include files.])],\n\t\t[// Do not use default includes])\n\n# Check if Dyninst is version 5.0+\nAC_CHECK_HEADERS([BPatch_process.h],\n\t\t [AC_SUBST([DYNINST_VER], [5])],\n\t\t [AC_SUBST([DYNINST_VER], [4])],\n\t\t [// Do not use default includes])\n\n# Find appropriate install program\nAC_PROG_INSTALL()\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT()\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/mapped_object.h": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n// $Id: mapped_object.h,v 1.23 2008/10/27 17:23:53 mlam Exp $\n\n#if !defined(_mapped_object_h)\n#define _mapped_object_h\n\n#include <string>\n#include \"common/src/Types.h\"\n#include \"dyninstAPI/src/image.h\"\n#include \"dyninstAPI/h/BPatch_enums.h\"\n#include <list>\n#include \"dyninstAPI/src/Relocation/DynObject.h\"\n#include \"PCProcess.h\"\n\nclass block_instance;\nclass func_instance;\nclass edge_instance;\n\n//  we really do not want to have this defined, but I'm defining it for the moment to get thru paradyn seperation\n#define CHECK_ALL_CALL_POINTS  // we depend on this for Paradyn\n\nusing namespace Dyninst;\nusing Dyninst::PatchAPI::DynCFGMaker;\n\nclass mapped_module;\n\nclass int_symbol {\n public:\n    int_symbol(SymtabAPI::Symbol *sym, Address base) : addr_(base + sym->getOffset()), sym_(sym) {}\n    int_symbol() : addr_(0), sym_(NULL) {};\n\n    Address getAddr() const { return addr_; }\n    unsigned getSize() const { return sym_->getSize(); }\n    const string &symTabName() const { return sym_->getMangledName(); }\n    const string &prettyName() const { return sym_->getPrettyName(); }\n    const string &typedName() const { return sym_->getTypedName(); }\n    const SymtabAPI::Symbol *sym() const { return sym_; }\n\n private:\n    Address addr_;\n    const SymtabAPI::Symbol *sym_;\n};\n\n\nclass int_variable {\n    // Should subclass this and function off the same thing...\n\n private:\n    int_variable() {};\n public:\n    int_variable(image_variable *var,\n                 Address base,\n                 mapped_module *mod);\n\n    int_variable(int_variable *parVar, mapped_module *child);\n\n    Address getAddress() const { return addr_; }\n    // Can variables have multiple names?\n    const string &symTabName() const;\n    const vector<string>& prettyNameVector() const;\n    const vector<string>& symTabNameVector() const;\n    mapped_module *mod() const { return mod_; };\n    //AddressSpace *as() const { return mod()->proc(); }\n    const image_variable *ivar() const { return ivar_; }\n\n    Address addr_;\n    unsigned size_;\n    // type?\n    image_variable *ivar_;\n\n    mapped_module *mod_;\n};\n\nstruct edgeStub {\n    edgeStub(block_instance *s, Address t, EdgeTypeEnum y)\n    { src = s; trg = t; type = y; }\n    block_instance* src;\n    Address trg;\n    EdgeTypeEnum type;\n};\n\n\n/*\n * A class for link map information about a shared object that is mmapped\n * by the dynamic linker into the applications address space at runtime.\n */\n#define \tSHAREDOBJECT_NOCHANGE\t0\n#define \tSHAREDOBJECT_ADDED\t1\n#define \tSHAREDOBJECT_REMOVED\t2\n\n// mapped_object represents a file in memory. It will be a collection\n// of modules (basically, .o's) that are referred to as a unit and\n// loaded as a unit.  The big reason for this is 1) per-process\n// specialization and 2) a way to reduce memory; to create objects for\n// all functions ahead of time is wasteful and expensive. So\n// basically, the mapped_object \"wins\" if it can return useful\n// information without having to allocate memory.\n\nclass mapped_object : public codeRange, public Dyninst::PatchAPI::DynObject {\n    friend class mapped_module; // for findFunction\n    friend class func_instance;\n    friend class block_instance; // Adds to codeRangesByAddr_\n    friend class edge_instance;\n    friend class DynCFGMaker;\n private:\n    mapped_object();\n    mapped_object(fileDescriptor fileDesc,\n                  image *img,\n                  AddressSpace *proc,\n                  BPatch_hybridMode mode = BPatch_normalMode);\n\n public:\n    // We need a way to check for errors; hence a \"get\" method\n    static mapped_object *createMappedObject(fileDescriptor &desc,\n                                             AddressSpace *p,\n                                             BPatch_hybridMode m = BPatch_normalMode,\n                                             bool parseGaps = true);\n    static mapped_object *createMappedObject(ProcControlAPI::Library::const_ptr lib,\n                                             AddressSpace *p,\n                                             BPatch_hybridMode m = BPatch_normalMode,\n                                             bool parseGaps = true);\n\n\n    // Copy constructor: for forks\n    mapped_object(const mapped_object *par_obj, AddressSpace *child);\n\n    // Will delete all func_instances which were originally part of this object; including\n    // any that were relocated (we can always follow the \"I was relocated\" pointer).\n    ~mapped_object();\n\n    bool analyze();\n    bool isAnalyzed() { return analyzed_; }\n\n    const fileDescriptor &getFileDesc() const { return desc_; }\n    // Full name, including path\n    const string &fullName() const { return fullName_; }\n    string fileName() const;\n    Address codeAbs() const;\n    Address codeBase() const { return codeBase_; }\n    Address imageOffset() const { return parse_img()->imageOffset(); }\n    unsigned imageSize() const { return parse_img()->imageLength(); }\n    unsigned memoryEnd(); // largest allocated memory address + 1\n\n    // 32-bit math safe!\n    bool isCode(Address addr) const;\n    bool isData(Address addr) const;\n\n    // Deprecated...\n    Address getBaseAddress() const { return codeBase(); }\n\n    Address dataAbs() const;\n    Address dataBase() const { return dataBase_; }\n    Address dataOffset() const { return parse_img()->dataOffset(); }\n    unsigned dataSize() const { return parse_img()->dataLength(); }\n\n    image *parse_img() const { return image_; }\n    bool isSharedLib() const;\n    bool isStaticExec() const;\n    static bool isSystemLib(const std::string &name);\n    bool isMemoryImg() const { return memoryImg_; }\n\n    void setMemoryImg() { memoryImg_ = true; };\n\n    // Return an appropriate identification string for debug purposes.\n    // Will eventually be required by a debug base class.\n    const std::string debugString() const;\n\n    // Used for codeRange ONLY! DON'T USE THIS! BAD USER!\n    Address get_address() const { return codeAbs(); }\n    void *get_local_ptr() const;\n    unsigned get_size() const { return imageSize(); }\n\n    AddressSpace *proc() const;\n\n    mapped_module *findModule(string m_name, bool wildcard = false);\n    mapped_module *findModule(pdmodule *mod);\n\n    mapped_module *getDefaultModule();\n\n    func_instance *findFuncByEntry(const Address addr);\n    func_instance *findFuncByEntry(const block_instance *blk);\n\n    bool getInfHeapList(pdvector<heapDescriptor> &infHeaps);\n    void getInferiorHeaps(vector<pair<string, Address> > &infHeaps);\n\n    bool findFuncsByAddr(const Address addr, std::set<func_instance *> &funcs);\n    bool findBlocksByAddr(const Address addr, std::set<block_instance *> &blocks);\n    block_instance *findBlockByEntry(const Address addr);\n    block_instance *findOneBlockByAddr(const Address addr);\n\n    // codeRange method\n    void *getPtrToInstruction(Address addr) const;\n    void *getPtrToData(Address addr) const;\n\n    // Try to avoid using these if you can, since they'll trigger\n    // parsing and allocation.\n    bool getAllFunctions(pdvector<func_instance *> &funcs);\n    bool getAllVariables(pdvector<int_variable *> &vars);\n\n    const pdvector<mapped_module *> &getModules();\n\n    // begin exploratory and defensive mode functions //\n    BPatch_hybridMode hybridMode() { return analysisMode_; }\n    bool isExploratoryModeOn();\n    bool parseNewEdges(const std::vector<edgeStub>& sources);\n    bool parseNewFunctions(std::vector<Address> &funcEntryAddrs);\n    bool updateCodeBytesIfNeeded(Address entryAddr); // ret true if was needed\n    void updateCodeBytes(const std::list<std::pair<Address,Address> > &owRanges );\n    void setCodeBytesUpdated(bool);\n    void addProtectedPage(Address pageAddr); // adds to protPages_\n    void removeProtectedPage(Address pageAddr);\n    void removeEmptyPages();\n    void remove(func_instance *func);\n    void remove(instPoint *p);\n    void splitBlock(block_instance *first, block_instance *second);\n    bool findBlocksByRange(Address startAddr,\n                          Address endAddr,\n                          std::list<block_instance*> &pageBlocks);\n    void findFuncsByRange(Address startAddr,\n                          Address endAddr,\n                          std::set<func_instance*> &pageFuncs);\n    void addEmulInsn(Address insnAddr, Register effective_addr);\n    bool isEmulInsn(Address insnAddr);\n    Register getEmulInsnReg(Address insnAddr);\n    void setEmulInsnVal(Address insnAddr, void * val);\n    int codeByteUpdates() { return codeByteUpdates_; }\n\n    void replacePLTStub(SymtabAPI::Symbol *PLTsym, \n                        func_instance *func, \n                        Address newAddr);\nprivate:\n    // helper functions\n    void updateCodeBytes(SymtabAPI::Region *reg);\n    bool isUpdateNeeded(Address entryAddr);\n    bool isExpansionNeeded(Address entryAddr);\n    void expandCodeBytes(SymtabAPI::Region *reg);\n    // end exploratory and defensive mode functions //\npublic:\n\n    bool  getSymbolInfo(const std::string &n, int_symbol &sym);\n\n    // All name lookup functions are vectorized, because you can have\n    // multiple overlapping names for all sorts of reasons.\n    // Demangled/\"pretty\": easy overlap (overloaded funcs, etc.).\n    // Mangled: multiple modules with static/private functions and\n    // we've lost the module name.\n\n    const pdvector<func_instance *> *findFuncVectorByPretty(const std::string &funcname);\n    const pdvector<func_instance *> *findFuncVectorByMangled(const std::string &funcname);\n\n    bool findFuncsByAddr(std::vector<func_instance *> &funcs);\n    bool findBlocksByAddr(std::vector<block_instance *> &blocks);\n\n    const pdvector<int_variable *> *findVarVectorByPretty(const std::string &varname);\n    const pdvector<int_variable *> *findVarVectorByMangled(const std::string &varname);\n    const int_variable *getVariable(const std::string &varname);\n\n\t//this marks the shared object as dirty, mutated\n\t//so it needs saved back to disk\n\tvoid setDirty(){ dirty_=true;}\n\tbool isDirty() { return dirty_; }\n\n    func_instance *findFunction(ParseAPI::Function *img_func);\n\n    int_variable *findVariable(image_variable *img_var);\n\n    block_instance *findBlock(ParseAPI::Block *);\n    // If we already know the source or target hand them in for efficiency\n    edge_instance *findEdge(ParseAPI::Edge *, block_instance *src = NULL, block_instance *trg = NULL);\n\n    // These methods should be invoked to find the global constructor and\n    // destructor functions in stripped, static binaries\n    func_instance *findGlobalConstructorFunc(const std::string &ctorHandler);\n    func_instance *findGlobalDestructorFunc(const std::string &dtorHandler);\n\n    // We store callee names at the mapped_object level for\n    // efficiency\n    std::string getCalleeName(block_instance *);\n    void setCalleeName(block_instance *, std::string name);\n\n    void setCallee(const block_instance *, func_instance *);\n    func_instance *getCallee(const block_instance *) const;\n\n    void destroy(PatchAPI::PatchFunction *f);\n    void destroy(PatchAPI::PatchBlock *b);\n    // void destroy(PatchAPI::PatchEdge *e); // don't need to destroy anything\n\n  private:\n    //\n    //     PRIVATE DATA MEMBERS\n    //\n    fileDescriptor desc_; // full file descriptor\n\n    string  fullName_;\t// full file name of the shared object\n    string  fileName_; // name of shared object as it should be identified\n\t\t\t//  in mdl, e.g. as used for \"exclude\"....\n    // Address   codeBase_; // The OS offset where the text segment is loaded;\n    // there is a corresponding codeOffset_ in the image class.\n\n    // For example, an a.out often has a codeBase of 0, and a\n    // codeOffset of 0x<valid>. Libraries are the reverse; codeBase_\n    // of <valid>, codeOffset of 0. All of our incoming functions,\n    // etc. from the image class have codeOffset built in.\n\n    Address   dataBase_; // Where the data starts...\n\n    void set_short_name();\n\n    pdvector<mapped_module *> everyModule;\n    typedef std::unordered_map<std::string, std::vector<func_instance *> *> func_index_t;\n    typedef std::unordered_map<std::string, std::vector<int_variable *> *> var_index_t;\n    \n    std::unordered_map<const image_variable *, int_variable *> everyUniqueVariable;\n    func_index_t allFunctionsByMangledName;\n    func_index_t allFunctionsByPrettyName;\n    var_index_t allVarsByMangledName;\n    var_index_t allVarsByPrettyName;\n\n    codeRangeTree codeRangesByAddr_;\n\n    // And those call...\n    void addFunction(func_instance *func);\n    void addVariable(int_variable *var);\n\n    // Add a name after-the-fact\n    typedef enum {\n        mangledName = 1,\n        prettyName = 2,\n        typedName = 4 } nameType_t;\n    void addFunctionName(func_instance *func, const std::string newName, \n                         func_index_t &index);\n\n    bool dirty_; // marks the shared object as dirty\n    bool dirtyCalled_;//see comment for setDirtyCalled\n\n    image  *image_; // pointer to image if processed is true\n    bool dlopenUsed; //mark this shared object as opened by dlopen\n    AddressSpace *proc_; // Parent process\n\n    bool analyzed_; // Prevent multiple adds\n\n    // exploratory and defensive mode variables\n    typedef enum  {\n        PROTECTED,\n        REPROTECTED,\n        UNPROTECTED,\n    } WriteableStatus;\n    BPatch_hybridMode analysisMode_;\n    map<Address,WriteableStatus> protPages_;\n    std::set<SymtabAPI::Region*> expansionCheckedRegions_;\n    bool pagesUpdated_;\n    int codeByteUpdates_;\n    typedef std::map<Address, std::pair<Register,void*> > EmulInsnMap;\n    EmulInsnMap emulInsns_;\n\n    Address memEnd_; // size of object in memory\n\n    mapped_module *getOrCreateForkedModule(mapped_module *mod);\n\n    bool memoryImg_;\n\n    std::map<block_instance *, std::string> calleeNames_;\n    std::map<const block_instance *, func_instance *> callees_;\n\n};\n\n// Aggravation: a mapped object might very well occupy multiple \"ranges\".\nclass mappedObjData : public codeRange {\n public:\n    mappedObjData(mapped_object *obj_) : obj(obj_) {};\n    Address get_address() const { return obj->dataAbs(); }\n    unsigned get_size() const { return obj->dataSize(); }\n    mapped_object *obj;\n};\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/dynProcess.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"dynProcess.h\"\n#include \"dynThread.h\"\n#include \"pcEventHandler.h\"\n#include \"pcEventMuxer.h\"\n#include \"function.h\"\n#include \"os.h\"\n#include \"debug.h\"\n#include \"instPoint.h\"\n#include \"BPatch.h\"\n#include \"mapped_module.h\"\n#include \"baseTramp.h\"\n#include \"registerSpace.h\"\n#include \"mapped_object.h\"\n#include \"image.h\"\n\n#include \"common/src/pathName.h\"\n\n#include \"proccontrol/h/PCErrors.h\"\n#include \"MemoryEmulator/memEmulator.h\"\n#include <boost/tuple/tuple.hpp>\n\n#include \"symtabAPI/h/SymtabReader.h\"\n#include \"patchAPI/h/PatchMgr.h\"\n#include \"patchAPI/h/Point.h\"\n\n\n#include <sstream>\n\nusing namespace Dyninst::ProcControlAPI;\nusing std::map;\nusing std::vector;\nusing std::string;\nusing std::stringstream;\n\nDyninst::SymtabAPI::SymtabReaderFactory *PCProcess::symReaderFactory_;\n\nPCProcess *PCProcess::createProcess(const string file, pdvector<string> &argv,\n                                    BPatch_hybridMode analysisMode,\n                                    pdvector<string> &envp,\n                                    const string dir, int stdin_fd, int stdout_fd,\n                                    int stderr_fd)\n{\n    // Debugging information\n    startup_cerr << \"Creating process \" << file << \" in directory \" << dir << endl;\n\n    startup_cerr << \"Arguments: (\" << argv.size() << \")\" << endl;\n    for (unsigned a = 0; a < argv.size(); a++)\n        startup_cerr << \"   \" << a << \": \" << argv[a] << endl;\n\n    startup_cerr << \"Environment: (\" << envp.size() << \")\" << endl;\n    for (unsigned e = 0; e < envp.size(); e++)\n        startup_cerr << \"   \" << e << \": \" << envp[e] << endl;\n\n    startup_printf(\"%s[%d]: stdin: %d, stdout: %d, stderr: %d\\n\", FILE__, __LINE__,\n            stdin_fd, stdout_fd, stderr_fd);\n\n    initSymtabReader();\n\n    // Create a full path to the executable\n    string path = createExecPath(file, dir);\n\n    std::map<int, int> fdMap;\n    redirectFds(stdin_fd, stdout_fd, stderr_fd, fdMap);\n\n    if( !setEnvPreload(envp, path) ) {\n        startup_cerr << \"Failed to set environment var to preload RT library\" << endl;\n        return NULL;\n    }\n\n    // Create the ProcControl process\n    Process::ptr tmpPcProc = Process::createProcess(path, argv, envp, fdMap);\n\n    if( !tmpPcProc ) {\n       cerr << \"Failed to create process \" << path << endl;\n       const char *lastErrMsg = getLastErrorMsg();\n        startup_printf(\"%s[%d]: failed to create process for %s: %s\\n\", __FILE__,\n                __LINE__, file.c_str(), lastErrMsg);\n        string msg = string(\"Failed to create process for \") + file +\n           string(\": \") + lastErrMsg;\n        showErrorCallback(68, msg.c_str());\n        return NULL;\n    }\n\n    startup_cerr << \"Created process \" << tmpPcProc->getPid() << endl;\n\n    PCProcess *ret = new PCProcess(tmpPcProc, file, analysisMode);\n    assert(ret);\n    tmpPcProc->setData(ret);\n\n    if( !ret->bootstrapProcess() ) {\n        startup_cerr << \"Failed to bootstrap process \" << ret->getPid()\n                     << \": terminating...\" << endl;\n        ret->terminateProcess();\n\n        delete ret;\n        return NULL;\n    }\n\n    return ret;\n}\n\nPCProcess *PCProcess::attachProcess(const string &progpath, int pid,\n                                    BPatch_hybridMode analysisMode)\n{\n    initSymtabReader();\n\n    startup_cerr << \"Attaching to process \" << pid << endl;\n    Process::ptr tmpPcProc = Process::attachProcess(pid, progpath);\n\n    if( !tmpPcProc ) {\n        const char *lastErrMsg = getLastErrorMsg();\n        startup_printf(\"%s[%d]: Failed to attach process %d: %s\\n\",\n                __FILE__, __LINE__, pid, lastErrMsg);\n        stringstream msg;\n        msg << \"Failed to attach to process \" << pid << \": \" << lastErrMsg;\n        showErrorCallback(26, msg.str());\n        return NULL;\n    }\n    startup_cerr << \"Attached to process \" << tmpPcProc->getPid() << endl;\n        \n    PCProcess *ret = new PCProcess(tmpPcProc, analysisMode);\n    assert(ret);\n\n    tmpPcProc->setData(ret);\n\n    ret->runningWhenAttached_ = tmpPcProc->allThreadsRunningWhenAttached();\n    ret->file_ = tmpPcProc->libraries().getExecutable()->getAbsoluteName();\n\n    if( !ret->bootstrapProcess() ) {\n        startup_cerr << \"Failed to bootstrap process \" << pid \n                     << \": terminating...\" << endl;\n        ret->terminateProcess();\n\n        delete ret;\n        return NULL;\n    }\n\n    return ret;\n}\n\nPCProcess *PCProcess::setupForkedProcess(PCProcess *parent, Process::ptr pcProc) {\n    startup_printf(\"%s[%d]: setting up forked process %d\\n\",\n            FILE__, __LINE__, pcProc->getPid());\n\n    PCProcess *ret = new PCProcess(parent, pcProc);\n    assert(ret);\n\n    pcProc->setData(ret);\n\n    ret->copyAddressSpace(parent);\n\n    // This requires the AddressSpace be copied from the parent\n    if (parent->tracedSyscalls_)\n      ret->tracedSyscalls_ = new syscallNotification(parent->tracedSyscalls_, ret);\n    else\n      ret->tracedSyscalls_ = NULL;\n\n    // Check if RT library exists in child\n    if( ret->runtime_lib.size() == 0 ) {\n        // Set the RT library name\n        if( !ret->getDyninstRTLibName() ) {\n            startup_printf(\"%s[%d]: failed to get Dyninst RT lib name\\n\",\n                    FILE__, __LINE__);\n            delete ret;\n            return NULL;\n        }\n        startup_printf(\"%s[%d]: Got Dyninst RT libname: %s\\n\", FILE__, __LINE__,\n                       ret->dyninstRT_name.c_str());\n\n        for(unsigned i = 0; i < ret->mapped_objects.size(); ++i) {\n            const fileDescriptor &desc = ret->mapped_objects[i]->getFileDesc();\n            fileDescriptor tmpDesc(ret->dyninstRT_name,\n                    desc.code(), desc.data(), true);\n            if( desc == tmpDesc ) {\n                ret->runtime_lib.insert(ret->mapped_objects[i]);\n                break;\n            }\n        }\n    }\n\n    // TODO hybrid mode stuff\n\n    // Copy signal handlers\n    pdvector<codeRange *> sigHandlers;\n    parent->signalHandlerLocations_.elements(sigHandlers);\n    for(unsigned i = 0; i < sigHandlers.size(); ++i) {\n        signal_handler_location *oldSig = dynamic_cast<signal_handler_location *>(sigHandlers[i]);\n        assert(oldSig);\n        signal_handler_location *newSig = new signal_handler_location(*oldSig);\n        ret->signalHandlerLocations_.insert(newSig);\n    }\n\n    // If required\n    if( !ret->copyDanglingMemory(parent) ) {\n        startup_printf(\"%s[%d]: failed to copy dangling memory from parent %d to child %d\\n\",\n                FILE__, __LINE__, parent->getPid(), ret->getPid());\n        ret->terminateProcess();\n\n        delete ret;\n        return NULL;\n    }\n\n    ret->setInEventHandling(true);\n\n    if( !ret->bootstrapProcess() ) {\n        startup_cerr << \"Failed to bootstrap process \" << ret->getPid()\n                     << \": terminating...\" << endl;\n        ret->terminateProcess();\n\n        delete ret;\n        return NULL;\n    }\n\n    ret->setDesiredProcessState(parent->getDesiredProcessState());\n\n    return ret;\n}\n\nPCProcess *PCProcess::setupExecedProcess(PCProcess *oldProc, std::string execPath) {\n    BPatch::bpatch->registerExecCleanup(oldProc, NULL);\n\n    PCProcess *newProc = new PCProcess(oldProc->pcProc_, execPath, oldProc->analysisMode_);\n\n    oldProc->pcProc_->setData(newProc);\n    newProc->setExecing(true);\n\n    if( !newProc->bootstrapProcess() ) {\n        proccontrol_printf(\"%s[%d]: failed to bootstrap execed process %d\\n\",\n                FILE__, __LINE__, newProc->getPid());\n        delete newProc;\n        return NULL;\n    }\n\n    delete oldProc;\n    oldProc = NULL;\n\n    newProc->setInEventHandling(true);\n    //newProc->incPendingEvents();\n\n    BPatch::bpatch->registerExecExit(newProc);\n\n    newProc->setExecing(false);\n    newProc->setDesiredProcessState(ps_running);\n\n    return newProc;\n}\n\nPCProcess::~PCProcess() {\n    if( tracedSyscalls_ ) delete tracedSyscalls_;\n    tracedSyscalls_ = NULL;\n\n    if( irpcTramp_ ) delete irpcTramp_;\n    irpcTramp_ = NULL;\n\n    signalHandlerLocations_.clear();\n\n    trapMapping.clearTrapMappings();\n}\n\nvoid PCProcess::initSymtabReader()\n{\n   //Set SymbolReaderFactory in Stackwalker before create/attach\n   if (!symReaderFactory_) {\n      symReaderFactory_ = new Dyninst::SymtabAPI::SymtabReaderFactory();\n      Dyninst::Stackwalker::Walker::setSymbolReader(symReaderFactory_);\n   }\n}\n\n/***************************************************************************\n **** Runtime library initialization code (Dyninst)                     ****\n ***************************************************************************/\n\n/*\n *\n * Gratuitously large comment. This diagrams the startup flow of\n * messages between the mutator and mutatee. Entry points\n * for create and attach process are both given.\n *     Mutator           Signal              Mutatee\n * Create:\n *     Fork/Exec\n *                     <-- Trap              Halted in exec (handled by ProcControlAPI)\n *     Install trap in main\n *                     <-- Trap              Halted in main\n *  Attach: (also paused, not in main)\n *     Install call to dlopen/\n *     LoadLibrary\n *                     <-- Trap              In library load\n *     Set parameters in library\n *                     <-- Trap              Finished loading\n *     Restore code and leave paused\n *     Finalize library\n *       If finalizing fails, init via iRPC\n */\n\n/*\n * In all cases, the process is left paused at the entry of main\n * (create) or where it was (attach). No permanent instrumentation\n * is inserted.\n */\n\nbool PCProcess::hasReachedBootstrapState(bootstrapState_t state) const {\n    return state <= bootstrapState_;\n}\n\nvoid PCProcess::setBootstrapState(bootstrapState_t newState) {\n    bootstrapState_ = newState;\n}\n\nbool PCProcess::bootstrapProcess() {\n    assert( pcProc_->allThreadsStopped() );\n\n    startup_printf(\"%s[%d]: attempting to bootstrap process %d\\n\", \n            FILE__, __LINE__, getPid());\n\n    if( !wasCreatedViaFork() ) {\n        // Initialize the inferior heaps\n        initializeHeap();\n\n        for(unsigned i = 0; i < mapped_objects.size(); ++i) {\n            addInferiorHeap(mapped_objects[i]);\n        }\n\n        // Create the mapped_objects for the executable and shared libraries\n        if( !createInitialMappedObjects() ) {\n            startup_printf(\"%s[%d]: bootstrap failed while creating mapped objects\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    // Create the initial threads\n    createInitialThreads();\n\n    // Initialize StackwalkerAPI\n    if ( !createStackwalker() )\n    {\n      startup_printf(\"Bootstrap failed while initializing Stackwalker\\n\");\n      return false;\n    }\n\n    // Insert a breakpoint at the entry point of main (and possibly __libc_start_main)\n    if( !hasPassedMain() ) {\n      startup_printf(\"%s[%d]: inserting breakpoint at main\\n\", FILE__, __LINE__);\n        if( !insertBreakpointAtMain() ) {\n            startup_printf(\"%s[%d]: bootstrap failed while setting a breakpoint at main\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\tstartup_printf(\"%s[%d]: continuing process to breakpoint\\n\", FILE__, __LINE__);\n        if( !continueProcess() ) {\n            startup_printf(\"%s[%d]: bootstrap failed while continuing the process\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        while( !hasReachedBootstrapState(bs_readyToLoadRTLib) ) {\n\t  startup_printf(\"%s[%d]: waiting for main() loop\\n\", FILE__, __LINE__);\n            if( isStopped() ) {\n\t      startup_printf(\"%s[%d]: We think the process is stopped, continuing\\n\", FILE__, __LINE__);\n                if( !continueProcess() ) {\n                    startup_printf(\"%s[%d]: bootstrap failed while continuing the process\\n\",\n                            FILE__, __LINE__);\n                    return false;\n                }\n            }\n\n            if( isTerminated() ) {\n                bperr(\"The process exited during startup.  This is likely due to one \"\n                      \"of two reasons:\\n\"\n                      \"A). The application is mis-built and unable to load.  Try \"\n                      \"running the application outside of Dyninst and see if it \"\n                      \"loads properly.\\n\"\n                      \"B). libdyninstAPI_RT is mis-built.  Try loading the library \"\n                      \"into another application and see if it reports any errors.  \"\n                      \"Ubuntu users - You may need to rebuild the RT library \"\n                      \"with the DISABLE_STACK_PROT line enabled in \"\n                      \"core/make.config.local\");\n                startup_printf(\"%s[%d]: program exited early, never reached \"\n                               \"initialized state\\n\", FILE__, __LINE__);\n                startup_printf(\"Error is likely due to the application or RT \"\n                               \"library having missing symbols or dependencies\\n\");\n                return false;\n            }\n\n            startup_printf(\"%s[%d]: bootstrap waiting for process to initialize\\n\",\n                    FILE__, __LINE__);\n            if( PCEventMuxer::wait(true) == PCEventMuxer::Error) {\n                startup_printf(\"%s[%d]: bootstrap failed to wait for events\\n\",\n                        FILE__, __LINE__);\n                return false;\n            }\n        }\n    }else{\n        bootstrapState_ = bs_readyToLoadRTLib;\n    }\n    startup_printf(\"%s[%d]: process initialized, loading the RT library\\n\",\n            FILE__, __LINE__);\n\n    // Load the RT library\n    if( !loadRTLib() ) {\n        bperr(\"Dyninst was unable to load the dyninst runtime library \"\n              \"into the application.  This may be caused by statically \"\n              \"linked executables, or by having dyninst linked against a \"\n              \"different version of libelf than it was built with.\");\n        startup_printf(\"%s[%d]: bootstrap failed to load RT library\\n\",\n                FILE__, __LINE__);\n        return false;\n    }\n\n\n    pdvector<int_variable *> obsCostVec;\n    if( !findVarsByAll(\"DYNINSTobsCostLow\", obsCostVec) ) {\n        startup_printf(\"%s[%d]: failed to find DYNINSTobsCostLow\\n\",\n                FILE__, __LINE__);\n        return false;\n    }\n\n    costAddr_ = obsCostVec[0]->getAddress();\n    assert(costAddr_);\n\n    if( !wasCreatedViaFork() ) {\n        // Install system call tracing\n        startup_printf(\"%s[%d]: installing default Dyninst instrumentation into process %d\\n\", \n            FILE__, __LINE__, getPid());\n\n        tracedSyscalls_ = new syscallNotification(this);\n\n        // TODO \n        // pre-fork and pre-exit should depend on whether a callback is defined\n        // \n        // This will require checking whether BPatch holds a defined callback and also\n        // adding a way for BPatch enable this instrumentation in all processes when\n        // a callback is registered\n\n        if (!tracedSyscalls_->installPreFork()) {\n            startup_printf(\"%s[%d]: failed pre-fork notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        if (!tracedSyscalls_->installPostFork()) {\n            startup_printf(\"%s[%d]: failed post-fork notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        if (!tracedSyscalls_->installPreExec()) {\n            startup_printf(\"%s[%d]: failed pre-exec notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        if (!tracedSyscalls_->installPostExec()) {\n            startup_printf(\"%s[%d]: failed post-exec notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        if (!tracedSyscalls_->installPreExit()) {\n            startup_printf(\"%s[%d]: failed pre-exit notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        if (!tracedSyscalls_->installPreLwpExit()) {\n            startup_printf(\"%s[%d]: failed pre-lwp-exit notification setup\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        // Initialize the tramp guard\n        startup_printf(\"%s[%d]: initializing tramp guard\\n\", FILE__, __LINE__);\n        if( !initTrampGuard() ) {\n            startup_printf(\"%s[%d]: failed to initalize tramp guards\\n\", FILE__, __LINE__);\n            return false;\n        }\n\n        // Initialize the MT stuff\n        if (multithread_capable()) {\n            if( !instrumentMTFuncs() ) {\n                startup_printf(\"%s[%d]: Failed to instrument MT funcs\\n\",\n                        FILE__, __LINE__);\n                return false;\n            }\n        }\n    }\n\n    // Register the initial threads\n    startup_printf(\"%s[%d]: registering initial threads with RT library\\n\",\n            FILE__, __LINE__);\n    vector<pair<dynthread_t, PCThread *> > toUpdate;\n    for(map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        if( !registerThread(i->second) ) {\n            startup_printf(\"%s[%d]: bootstrap failed while registering threads with RT library\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n\n        // If the information available has improved, update the mapping to reflect this\n        if( i->first != i->second->getTid() ) toUpdate.push_back(*i);\n    }\n\n    for(vector<pair<dynthread_t, PCThread *> >::iterator i = toUpdate.begin();\n            i != toUpdate.end(); ++i)\n    {\n        threadsByTid_.erase(i->first);\n        threadsByTid_.insert(make_pair(i->second->getTid(), i->second));\n    }\n\n    startup_printf(\"%s[%d]: finished registering initial threads with RT library\\n\",\n            FILE__, __LINE__);\n\n    // use heuristics to set hybrid analysis mode\n    if (BPatch_heuristicMode == analysisMode_) {\n        if (getAOut()->parse_img()->codeObject()->defensiveMode()) {\n            analysisMode_ = BPatch_defensiveMode;\n        } else {\n            analysisMode_ = BPatch_normalMode;\n        }\n    }\n\n    bootstrapState_ = bs_initialized;\n    startup_printf(\"%s[%d]: finished bootstrapping process %d\\n\", FILE__, __LINE__, getPid());\n\n    return true;\n}\n\nbool PCProcess::initTrampGuard() {\n    const std::string vrbleName = \"DYNINST_tramp_guards\";\n    pdvector<int_variable *> vars;\n    if (!findVarsByAll(vrbleName, vars)) {\n        return false;\n    }\n    assert(vars.size() == 1);\n\n    Address allocedTrampAddr = 0;\n\n    if (getAddressWidth() == 4) {\n        // Don't write directly into trampGuardBase_ as a buffer,\n        //   in case we're on a big endian architechture.\n        unsigned int value;\n        readDataWord((void *)vars[0]->getAddress(), 4, &value, true);\n        allocedTrampAddr = value;\n\n    } else if (getAddressWidth() == 8) {\n        readDataWord((void *)vars[0]->getAddress(), 8, &allocedTrampAddr, true);\n    } else assert(0 && \"Incompatible mutatee address width\");\n\n    trampGuardBase_ = getAOut()->getDefaultModule()->createVariable(\"DYNINST_tramp_guard\", \n            allocedTrampAddr, getAddressWidth());\n\n    return true;\n}\n\nbool PCProcess::createStackwalker()\n{\n  using namespace Stackwalker;\n  ProcDebug *procDebug = NULL;\n  StackwalkSymLookup *symLookup = NULL;\n\n  // Create ProcessState\n  if (NULL == (procDebug = ProcDebug::newProcDebug(pcProc_)))\n  {\n    startup_printf(\"Could not create Stackwalker process state\\n\");\n    return false;\n  }\n\n  // Create SymbolLookup\n  symLookup = new StackwalkSymLookup(this);\n\n  // Create Walker without default steppers\n  if (NULL == (stackwalker_ = Walker::newWalker(procDebug,\n                                                NULL,\n                                                symLookup,\n                                                false)))\n  {\n    startup_printf(\"Could not create Stackwalker\\n\");\n    return false;\n  }\n\n  return createStackwalkerSteppers();\n}\n\nvoid PCProcess::createInitialThreads() {\n    ThreadPool &pcThreads = pcProc_->threads();\n    initialThread_ = PCThread::createPCThread(this, pcThreads.getInitialThread());\n    addThread(initialThread_);\n\n    for(ThreadPool::iterator i = pcThreads.begin(); i != pcThreads.end(); ++i) {\n        if( *i == pcThreads.getInitialThread() ) continue;\n\n        // Wait to create threads until they have user thread information available\n        if( !(*i)->haveUserThreadInfo() ) continue;\n\n        PCThread *newThr = PCThread::createPCThread(this, *i);\n        addThread(newThr);\n    }\n}\n\nbool PCProcess::createInitialMappedObjects() {\n    if( file_.empty() ) {\n        startup_printf(\"%s[%d]: failed to determine executable for process %d\\n\",\n                FILE__, __LINE__, getPid());\n        return false;\n    }\n\n    startup_printf(\"Processing initial shared objects\\n\");\n    startup_printf(\"----\\n\");\n\n    initPatchAPI();\n\n    // Do the a.out first...\n    mapped_object *aout = mapped_object::createMappedObject(pcProc_->libraries().getExecutable(), this, analysisMode_);\n    addASharedObject(aout);\n\n    // Set the RT library name\n    if( !getDyninstRTLibName() ) {\n      bperr(\"Dyninst was unable to find the dyninst runtime library.\");\n        startup_printf(\"%s[%d]: failed to get Dyninst RT lib name\\n\",\n                FILE__, __LINE__);\n        return false;\n    }\n\n    // Find main\n    startup_printf(\"%s[%d]:  leave setAOut/setting main\\n\", FILE__, __LINE__);\n    setMainFunction();\n\n    // Create mapped objects for any loaded shared libraries\n    const LibraryPool &libraries = pcProc_->libraries();\n    for(LibraryPool::const_iterator i = libraries.begin(); i != libraries.end(); ++i) {\n       // Some platforms don't use the data load address field\n       if ((*i) == libraries.getExecutable()) continue;\n\n       startup_cerr << \"Library: \" << (*i)->getAbsoluteName() \n            << hex << \" / \" << (*i)->getLoadAddress() \n            << \", \" << ((*i)->isSharedLib() ? \"<lib>\" : \"<aout>\") << dec << endl;\n\n       mapped_object *newObj = mapped_object::createMappedObject(*i, \n                                                                 this, analysisMode_);\n       if( newObj == NULL ) {\n           startup_printf(\"%s[%d]: failed to create mapped object for library %s\\n\",\n                   FILE__, __LINE__, (*i)->getAbsoluteName().c_str());\n           return false;\n       }\n\n       const fileDescriptor &desc = newObj->getFileDesc();\n       fileDescriptor tmpDesc(dyninstRT_name, desc.code(), desc.data(), true);\n       if( desc == tmpDesc ) {\n          startup_printf(\"%s[%d]: RT library already loaded, manual loading not necessary\\n\",\n                         FILE__, __LINE__);\n          runtime_lib.insert(newObj);\n       }\n\n       addASharedObject(newObj);\n    }\n\n\n    startup_printf(\"----\\n\");\n\n    return true;\n}\n\n// creates an image, creates new resources for a new shared object\n// adds it to the collection of mapped_objects\nvoid PCProcess::addASharedObject(mapped_object *newObj) {\n    assert(newObj);\n\n    addMappedObject(newObj);\n\n    findSignalHandler(newObj);\n\n    startup_printf(\"%s[%d]: adding shared object %s, addr range 0x%lx to 0x%lx\\n\",\n            FILE__, __LINE__,\n            newObj->fileName().c_str(),\n            newObj->getBaseAddress(),\n            newObj->getBaseAddress() + newObj->get_size());\n    parsing_printf(\"Adding shared object %s, addr range 0x%x to 0x%x\\n\",\n            newObj->fileName().c_str(),\n            newObj->getBaseAddress(),\n            newObj->getBaseAddress() + newObj->get_size());\n\n    if( heapInitialized_ ) {\n        addInferiorHeap(newObj);\n    }else{\n        startup_printf(\"%s[%d]: skipping check for new inferior heaps, heap uninitialized\\n\",\n                                       FILE__, __LINE__);\n    }\n}\n\nvoid PCProcess::removeASharedObject(mapped_object *obj) {\n    // Remove from mapped_objects list\n    for (unsigned j = 0; j < mapped_objects.size(); j++) {\n        if (obj == mapped_objects[j]) {\n            mapped_objects[j] = mapped_objects.back();\n            mapped_objects.pop_back();\n            deletedObjects_.push_back(obj);\n            break;\n        }\n    }\n\n    if (runtime_lib.end() != runtime_lib.find(obj)) {\n        runtime_lib.erase( runtime_lib.find(obj) );\n    }\n    proccontrol_printf(\"Removing shared object %s, addr range 0x%x to 0x%x\\n\",\n                  obj->fileName().c_str(),\n                  obj->getBaseAddress(),\n                  obj->get_size());\n\n    // TODO Signal handler...\n}\n\nbool PCProcess::setAOut(fileDescriptor &desc) {\n    startup_printf(\"%s[%d]:  enter setAOut\\n\", FILE__, __LINE__);\n\n    assert(mapped_objects.size() == 0);\n\n    mapped_object *aout = mapped_object::createMappedObject\n                          (desc, this, getHybridMode());\n    if (!aout) {\n        startup_printf(\"%s[%d]:  fail setAOut\\n\", FILE__, __LINE__);\n        return false;\n    }\n\n\n    return true;\n}\n\n// We keep a vector of all signal handler locations\nvoid PCProcess::findSignalHandler(mapped_object *obj) {\n    startup_printf(\"%s[%d]: findSignalhandler(%p)\\n\", FILE__, __LINE__, obj);\n    assert(obj);\n\n    int_symbol sigSym;\n    string signame(SIGNAL_HANDLER);\n\n    startup_printf(\"%s[%d]: findSignalhandler(%p): gettingSymbolInfo\\n\", FILE__, __LINE__, obj);\n    if (obj->getSymbolInfo(signame, sigSym)) {\n        // Symbols often have a size of 0. This b0rks the codeRange code,\n        // so override to 1 if this is true...\n        unsigned size_to_use = sigSym.getSize();\n        if (!size_to_use) size_to_use = 1;\n\n        startup_printf(\"%s[%d]: findSignalhandler(%p): addingSignalHandler(%p, %d)\\n\", FILE__, __LINE__, obj, (void *) sigSym.getAddr(), size_to_use);\n        addSignalHandler(sigSym.getAddr(), size_to_use);\n    }\n\n    startup_printf(\"%s[%d]: leaving findSignalhandler(%p)\\n\", FILE__, __LINE__, obj);\n}\n\n// NUMBER_OF_MAIN_POSSIBILITIES is defined in image.h\nvoid PCProcess::setMainFunction() {\n    assert(!main_function_);\n\n    for (unsigned i = 0; i < NUMBER_OF_MAIN_POSSIBILITIES; i++) {\n        main_function_ = findOnlyOneFunction(main_function_names[i]);\n        if (main_function_) {\n           break;\n        }\n    }\n}\n \n/*\n * Given an image, add all static heaps inside it\n * (DYNINSTstaticHeap...) to the buffer pool.\n */\nvoid PCProcess::addInferiorHeap(mapped_object *obj) {\n    pdvector<heapDescriptor> infHeaps;\n    /* Get a list of inferior heaps in the new image */\n    if (obj->getInfHeapList(infHeaps)) {\n        /* Add the vector to the inferior heap structure */\n        for (u_int j=0; j < infHeaps.size(); j++) {\n            infmalloc_printf(\"%s[%d]: adding heap at 0x%lx to 0x%lx, name %s\\n\",\n                             FILE__, __LINE__,\n                             infHeaps[j].addr(),\n                             infHeaps[j].addr() + infHeaps[j].size(),\n                             infHeaps[j].name().c_str());\n\n            // platform-specific check to ignore this heap\n            if( skipHeap(infHeaps[j]) ) continue;\n\n            heapItem *h = new heapItem (infHeaps[j].addr(), infHeaps[j].size(),\n                                        infHeaps[j].type(), false);\n\n            infmalloc_printf(\"%s[%d]: Adding heap from 0x%lx - 0x%lx (%d bytes, type %d) from mapped object %s\\n\",\n                             FILE__, __LINE__,\n                             infHeaps[j].addr(),\n                             infHeaps[j].addr() + infHeaps[j].size(),\n                             infHeaps[j].size(),\n                             infHeaps[j].type(),\n                             obj->fileName().c_str());\n\n            addHeap(h);\n\n            // set rtlib heaps (runtime_lib hasn't been set yet)\n            if ( ! obj->fullName().compare( dyninstRT_name ) ) {\n                dyninstRT_heaps_.push_back(h);\n            }\n        }\n    }\n}\n\nstatic const unsigned MAX_THREADS = 32; // Should match MAX_THREADS in RTcommon.c\n\nbool PCProcess::loadRTLib() {\n    // Check if the RT library has already been loaded\n   if( runtime_lib.size() != 0 ) {\n      startup_printf(\"%s[%d]: RT library already loaded\\n\",\n                     FILE__, __LINE__);\n\n      bootstrapState_ = bs_loadedRTLib;\n   }\n   else {\n     if (!pcProc_->addLibrary(dyninstRT_name)) {\n       startup_printf(\"%s[%d]: failed to start loading RT lib\\n\", FILE__,\n\t\t      __LINE__);\n       return false;\n     }\n     bootstrapState_ = bs_loadedRTLib;\n     \n     // Process the library load (we hope)\n     PCEventMuxer::handle();\n     \n     if( runtime_lib.size() == 0 ) {\n       startup_printf(\"%s[%d]: failed to load RT lib\\n\", FILE__,\n\t\t      __LINE__);\n       return false;\n     }\n     \n     bootstrapState_ = bs_loadedRTLib;\n   }\n   int loaded_ok = 0;\n   pdvector<int_variable *> vars;\n   if (!findVarsByAll(\"DYNINSThasInitialized\", vars)) {\n        startup_printf(\"%s[%d]: no DYNINSThasInitialized variable\\n\", FILE__, __LINE__);\n\t\treturn false;\n   }\n   if (!readDataWord((void*)vars[0]->getAddress(), sizeof(int), (void *)&loaded_ok, false)) {\n        startup_printf(\"%s[%d]: readDataWord failed\\n\", FILE__, __LINE__);\n        return false;\n   }\n   if(!loaded_ok)\n   {\n\t   startup_printf(\"%s[%d]: DYNINSTinit not called automatically\\n\", FILE__, __LINE__);\n   }\n   startup_printf(\"%s[%d]: DYNINSTinit succeeded\\n\", FILE__, __LINE__);\n   return setRTLibInitParams();\n}\n\n// Set up the parameters for DYNINSTinit in the RT lib\nbool PCProcess::setRTLibInitParams() {\n    startup_printf(\"%s[%d]: welcome to PCProcess::setRTLibInitParams\\n\",\n            FILE__, __LINE__);\n\n    int pid = P_getpid();\n\n\n    // Now we write these variables into the following global vrbles\n    // in the dyninst library:\n    // libdyninstAPI_RT_init_localCause\n    // libdyninstAPI_RT_init_localPid\n\n    pdvector<int_variable *> vars;\n\n\n    if (!findVarsByAll(\"libdyninstAPI_RT_init_localPid\", vars)) {\n        if (!findVarsByAll(\"_libdyninstAPI_RT_init_localPid\", vars)) {\n            startup_printf(\"%s[%d]: could not find necessary internal variable\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    assert(vars.size() == 1);\n    if (!writeDataWord((void*)vars[0]->getAddress(), sizeof(int), (void *)&pid)) {\n        startup_printf(\"%s[%d]: writeDataWord failed\\n\", FILE__, __LINE__);\n        return false;\n    }\n    vars.clear();\n\n    if (!findVarsByAll(\"libdyninstAPI_RT_init_maxthreads\", vars)) {\n        if (!findVarsByAll(\"_libdyninstAPI_RT_init_maxthreads\", vars)) {\n            startup_printf(\"%s[%d]: could not find necessary internal variable\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    unsigned numThreads = MAX_THREADS;\n    if( !multithread_capable() ) numThreads = 1;\n\n    assert(vars.size() == 1);\n    if (!writeDataWord((void*)vars[0]->getAddress(), sizeof(int), (void *) &numThreads)) {\n        startup_printf(\"%s[%d]: writeDataWord failed\\n\", FILE__, __LINE__);\n        return false;\n    }\n    vars.clear();\n\n    if (!findVarsByAll(\"libdyninstAPI_RT_init_debug_flag\", vars)) {\n        if (!findVarsByAll(\"_libdyninstAPI_RT_init_debug_flag\", vars)) {\n            startup_printf(\"%s[%d]: could not find necessary internal variable\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    assert(vars.size() == 1);\n    if (!writeDataWord((void*)vars[0]->getAddress(), sizeof(int), (void *) &dyn_debug_rtlib)) {\n        startup_printf(\"%s[%d]: writeDataWord failed\\n\", FILE__, __LINE__);\n        return false;\n    }\n    vars.clear();\n    if (dyn_debug_rtlib) {\n        fprintf(stderr, \"%s[%d]:  set var in RTlib for debug...\\n\", FILE__, __LINE__);\n    }\n\n    int static_mode = 0;\n    if (!findVarsByAll(\"DYNINSTstaticMode\", vars)) {\n        if (!findVarsByAll(\"DYNINSTstaticMode\", vars)) {\n            startup_printf(\"%s[%d]: could not find necessary internal variable\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    assert(vars.size() == 1);\n    if (!writeDataWord((void*)vars[0]->getAddress(), sizeof(int), (void *) &static_mode)) {\n        startup_printf(\"%s[%d]: writeDataWord failed\\n\", FILE__, __LINE__);\n        return false;\n    }\n    vars.clear();\n    return true;\n}\n\n\n#if defined(os_vxworks)\nbool PCProcess::insertBreakpointAtMain() {\n    // We don't need any extra processing of the RTlib.\n    return true;\n}\n#else\nbool PCProcess::insertBreakpointAtMain() {\n    if( main_function_ == NULL ) {\n        startup_printf(\"%s[%d]: main function not yet found, cannot insert breakpoint\\n\",\n                FILE__, __LINE__);\n        return false;\n    }\n    Address addr = main_function_->addr();\n\n    // Create the breakpoint\n    mainBrkPt_ = Breakpoint::newBreakpoint();\n    if( !pcProc_->addBreakpoint(addr, mainBrkPt_) ) {\n        startup_printf(\"%s[%d]: failed to insert a breakpoint at main entry: 0x%x\\n\",\n                FILE__, __LINE__, addr);\n        return false;\n    }\n\n    startup_printf(\"%s[%d]: added trap to entry of main, address 0x%x\\n\", \n            FILE__, __LINE__, addr);\n\n    return true;\n}\n#endif\n\nbool PCProcess::removeBreakpointAtMain() {\n    if( main_function_ == NULL || mainBrkPt_ == Breakpoint::ptr() ) {\n        startup_printf(\"%s[%d]: no breakpoint set at main function, not removing\\n\",\n                FILE__, __LINE__);\n        return true;\n    }\n\n    Address addr = main_function_->addr();\n\n    if( !pcProc_->rmBreakpoint(addr, mainBrkPt_) ) {\n        startup_printf(\"%s[%d]: failed to remove breakpoint at main entry: 0x%x\\n\",\n                FILE__, __LINE__, addr);\n        return false;\n    }\n    mainBrkPt_ = Breakpoint::ptr();\n\n    return true;\n}\n\nBreakpoint::ptr PCProcess::getBreakpointAtMain() const {\n    return mainBrkPt_;\n}\n\n// End Runtime library initialization code\n\nbool PCProcess::continueProcess() {\n    proccontrol_printf(\"%s[%d]: Continuing process %d\\n\", FILE__, __LINE__, getPid());\n\n    if( !isAttached() || isTerminated() ) {\n        bpwarn(\"Warning: continue attempted on non-attached process\\n\");\n        return false;\n    }\n\n    // If the process is in event handling, the process should not be continued, \n    // the processState_t value will be used after event handling to determine the\n    // state of the process\n    if( isInEventHandling() ) {\n        proccontrol_printf(\"%s[%d]: process currently in event handling, not continuing\\n\",\n                FILE__, __LINE__);\n        return true;\n    }\n\n    for(map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        i->second->clearStackwalk();\n    }\n\n    return pcProc_->continueProc();\n}\n\nbool PCProcess::stopProcess() {\n    proccontrol_printf(\"%s[%d]: Stopping process %d\\n\", FILE__, __LINE__, getPid());\n\n    if( !isAttached() || isTerminated() ) {\n        bpwarn(\"Warning: stop attempted on non-attached process\\n\");\n        return false;\n    }\n\n    // See comment in continueProcess about this\n    if( isInEventHandling() ) {\n        proccontrol_printf(\"%s[%d]: process currently in event handling, not stopping\\n\",\n                FILE__, __LINE__);\n        return true;\n    }\n\n    return pcProc_->stopProc();\n}\n\nbool PCProcess::terminateProcess() {\n    if( isTerminated() ) return true;\n\n    if( !isAttached() ) return false;\n\n    forcedTerminating_ = true;\n\n    proccontrol_printf(\"%s[%d]: Terminating process %d\\n\", FILE__, __LINE__, getPid());\n    if( !pcProc_->terminate() ) {\n        proccontrol_printf(\"%s[%d]: Failed to terminate process %d\\n\", FILE__, __LINE__, \n                getPid());\n        return false;\n    }\n    PCEventMuxer::handle();\n\n    proccontrol_printf(\"%s[%d]: finished terminating process %d\\n\", FILE__, __LINE__, getPid());\n\n    return true;\n}\n\nbool PCProcess::detachProcess(bool /*cont*/) {\n    if( isTerminated() ) return true;\n\n    if( !isAttached() ) return false;\n\n    if (tracedSyscalls_) {\n        // Process needs to be stopped to change instrumentation\n        bool needToContinue = false;\n        if( !isStopped() ) {\n            needToContinue = true;\n            if( !stopProcess() ) {\n                proccontrol_printf(\"%s[%d]: failed to stop process for removing syscalls\\n\",\n                        FILE__, __LINE__);\n            }\n        }\n\n        tracedSyscalls_->removePreFork();\n        tracedSyscalls_->removePostFork();\n        tracedSyscalls_->removePreExec();\n        tracedSyscalls_->removePostExec();\n        tracedSyscalls_->removePreExit();\n        tracedSyscalls_->removePreLwpExit();\n\n        if( needToContinue ) {\n            if( !continueProcess() ) {\n                proccontrol_printf(\"%s[%d]: failed to continue process after removing syscalls\\n\",\n                        FILE__, __LINE__);\n            }\n        }\n    }\n\n    // TODO figure out if ProcControl should care about continuing a process\n    // after detach\n\n    // NB: it's possible to get markExited() while handling events for the\n    // tracedSyscalls_->remove* calls above, clearing pcProc_.\n    if( isTerminated() || pcProc_->detach() ) {\n        attached_ = false;\n        return true;\n    }\n\n    return false;\n}\n\nbool PCProcess::isBootstrapped() const {\n    return bootstrapState_ == bs_initialized;\n}\n\nbool PCProcess::isAttached() const {\n    return attached_;\n}\n\nbool PCProcess::isStopped() const {\n    if( pcProc_ == Process::ptr() ) return true;\n    return pcProc_->allThreadsStopped();\n}\n\nbool PCProcess::isTerminated() const {\n    if( pcProc_ == Process::ptr() ) return true;\n    return pcProc_->isTerminated();\n}\n\nbool PCProcess::hasExitedNormally() const {\n    if( pcProc_ == Process::ptr() ) return true;\n    return pcProc_->isExited();\n}\n\nbool PCProcess::isExecing() const {\n    return execing_;\n}\n\nvoid PCProcess::setExecing(bool b) {\n    execing_ = b;\n}\n\nbool PCProcess::isExiting() const {\n    return exiting_;\n}\n\nvoid PCProcess::setExiting(bool b) {\n    exiting_ = b;\n}\n\nbool PCProcess::isInEventHandling() const {\n    return inEventHandling_;\n}\n\nvoid PCProcess::setInEventHandling(bool b) {\n    inEventHandling_ = b;\n}\n\nbool PCProcess::hasReportedEvent() const {\n    return reportedEvent_;\n}\n\nvoid PCProcess::setReportingEvent(bool b) {\n    reportedEvent_ = b;\n}\n\nvoid PCProcess::markExited() {\n\tif(pcProc_) pcProc_ = Process::ptr();\n}\n\nvoid PCProcess::writeDebugDataSpace(void *inTracedProcess, u_int amount,\n        const void *inSelf)\n{\n    static unsigned write_no = 0;\n\n    if( !dyn_debug_write ) return;\n\n    write_printf(\"const unsigned char \");\n    switch(getArch()) {\n        case Arch_x86:\n            write_printf(\"x86_\");\n            break;\n        case Arch_x86_64:\n            write_printf(\"amd64_\");\n            break;\n        case Arch_ppc32:\n        case Arch_ppc64:\n            write_printf(\"power_\");\n            break;\n        default:\n            write_printf(\"unknown_\");\n            break;\n    }\n    write_printf(\"%lx_%d_%u[] = {\", inTracedProcess, getPid(), write_no++);\n\n    if( amount > 0 ) {\n       const unsigned char *buffer = (const unsigned char *)inSelf;\n       for(unsigned i = 0; i < amount-1; ++i) {\n           if( i % 10 == 0 ) write_printf(\"\\n\");\n           write_printf(\"0x%02hhx, \", buffer[i]);\n       }\n       write_printf(\"0x%02hhx\", buffer[amount-1]);\n    }\n    write_printf(\"\\n};\\n\");\n}\n\nbool PCProcess::writeDataSpace(void *inTracedProcess, u_int amount,\n                               const void *inSelf) {\n    if( isTerminated() ) {\n       cerr << \"Writing to terminated process!\" << endl;\n       return false;\n    }\n    bool result = pcProc_->writeMemory((Address)inTracedProcess, inSelf,\n                                       amount);\n\n    if( BPatch_defensiveMode == proc()->getHybridMode() && !result ) {\n        // the write may have failed because we've removed write permissions\n        // from the page, remove them and try again\n\n        PCMemPerm origRights, rights(true, true, true);\n        if (!pcProc_->setMemoryAccessRights((Address)inTracedProcess,\n                                            amount, rights, origRights)) {\n            cerr << \"Fail to set memory permissions!\" << endl;\n            return false;\n        }\n\n        /*\n        int oldRights = pcProc_->setMemoryAccessRights((Address)inTracedProcess,\n                                                       amount,\n                                                       PAGE_EXECUTE_READWRITE);\n\n        if( oldRights == PAGE_EXECUTE_READ || oldRights == PAGE_READONLY ) {\n        */\n\n        if( origRights.isRX() || origRights.isR() ) {\n            result = pcProc_->writeMemory((Address)inTracedProcess, inSelf,\n                                          amount);\n\n            /*\n            if( pcProc_->setMemoryAccessRights((Address)inTracedProcess,\n                                               amount, oldRights) == false ) {\n            */\n\n            PCMemPerm tmpRights;\n            if( !pcProc_->setMemoryAccessRights((Address)inTracedProcess,\n                                                amount, origRights, tmpRights)) {\n                result = false;\n            }\n        } else {\n            result = false;\n        }\n    }\n\n    if( result && dyn_debug_write ) writeDebugDataSpace(inTracedProcess, amount, inSelf);\n\n    return result;\n}\n\nbool PCProcess::writeDataWord(void *inTracedProcess,\n                   u_int amount, const void *inSelf) \n{\n    if( isTerminated() ) return false;\n\n    // XXX ProcControlAPI should support word writes in the future\n    bool result = pcProc_->writeMemory((Address)inTracedProcess, inSelf, amount);\n    if( result && dyn_debug_write ) writeDebugDataSpace(inTracedProcess, amount, inSelf);\n    return result;\n}\n\nbool PCProcess::readDataSpace(const void *inTracedProcess, u_int amount,\n                   void *inSelf, bool displayErrMsg)\n{\n    if( isTerminated() ) return false;\n\n    bool result = pcProc_->readMemory(inSelf, (Address)inTracedProcess, amount);\n    if( !result && displayErrMsg ) {\n        stringstream msg;\n        msg << \"System error: unable to read \" << amount << \"@\" \n            << Address_str((Address)inTracedProcess) << \" from process data space: \"\n            << getLastErrorMsg() << \"(pid = \" << getPid() << \")\";\n       showErrorCallback(38, msg.str()); \n    }\n    return result;\n}\n\nbool PCProcess::readDataWord(const void *inTracedProcess, u_int amount,\n                  void *inSelf, bool displayErrMsg)\n{\n    if( isTerminated() ) return false;\n\n    // XXX see writeDataWord above\n    bool result = pcProc_->readMemory(inSelf, (Address)inTracedProcess, amount);\n    if( !result && displayErrMsg ) {\n        stringstream msg;\n        msg << \"System error: unable to read \" << amount << \"@\" \n            << Address_str((Address)inTracedProcess) << \" from process data space: \"\n            << getLastErrorMsg() << \"(pid = \" << getPid() << \")\";\n       showErrorCallback(38, msg.str());\n    }\n\n    return result;\n}\n\nbool PCProcess::writeTextSpace(void *inTracedProcess, u_int amount, const void *inSelf)\n{\n    if( isTerminated() ) return false;\n    bool result = pcProc_->writeMemory((Address)inTracedProcess, inSelf, amount);\n\n    if( result && dyn_debug_write ) writeDebugDataSpace(inTracedProcess, amount, inSelf);\n\n    return result;\n}\n\nbool PCProcess::writeTextWord(void *inTracedProcess, u_int amount, const void *inSelf)\n{\n    if( isTerminated() ) return false;\n\n    // XXX see writeDataWord above\n    bool result = pcProc_->writeMemory((Address)inTracedProcess, inSelf, amount);\n\n    if( result && dyn_debug_write ) writeDebugDataSpace(inTracedProcess, amount, inSelf);\n\n    return result;\n}\n\nbool PCProcess::readTextSpace(const void *inTracedProcess, u_int amount,\n                   void *inSelf)\n{\n    if( isTerminated() ) return false;\n\n    return pcProc_->readMemory(inSelf, (Address)inTracedProcess, amount);\n}\n\nbool PCProcess::readTextWord(const void *inTracedProcess, u_int amount,\n                  void *inSelf)\n{\n    if( isTerminated() ) return false;\n\n    // XXX see writeDataWord above\n    return pcProc_->readMemory(inSelf, (Address)inTracedProcess, amount);\n}\n\nPCThread *PCProcess::getInitialThread() const {\n    return initialThread_;\n}\n\nPCThread *PCProcess::getThread(dynthread_t tid) const {\n    map<dynthread_t, PCThread *>::const_iterator findIter;\n    findIter = threadsByTid_.find(tid);\n    if( findIter == threadsByTid_.end() ) {\n        return NULL;\n    }\n\n    return findIter->second;\n}\n\nbool PCProcess::removeThread(dynthread_t tid) {\n    map<dynthread_t, PCThread *>::iterator result;\n    result = threadsByTid_.find(tid);\n\n    if( result == threadsByTid_.end() ) return false;\n\n    PCThread *toDelete = result->second;\n\n    if( !unregisterThread(toDelete) ) return false;\n\n    threadsByTid_.erase(result);\n\n    if( toDelete == initialThread_ ) {\n        initialThread_ = NULL;\n    }\n\n    toDelete->markExited();\n\n    // Note: don't delete the thread here, the BPatch_thread takes care of it\n    proccontrol_printf(\"%s[%d]: removed thread %lu from process %d\\n\",\n            FILE__, __LINE__, toDelete->getLWP(), getPid());\n    return true;\n}\nextern Address getVarAddr(PCProcess *proc, std::string str);\n\n\nbool PCProcess::registerThread(PCThread *thread) {\t\n   Address tid = (Address) thread->getTid();\n   Address index = thread->getIndex();\n   \n   Address tmp = 0;\n   unsigned ptrsize = getAddressWidth();\n\n   if (tid == (Address) -1) return true;\n   if (index == (Address) -1) return true;\n\n   if (!initializeRegisterThread()) {\n      startup_printf(\"%s[%d]: initializeRegisterThread failed\\n\",\n                     FILE__, __LINE__);\n\t   \n\t   return false;\n   }\n   // Must match the \"hash\" algorithm used in the RT lib\n   int working = (tid % thread_hash_size);\n   while(1) {\n      tmp = 0;\n      if (!readDataWord(( void *)(thread_hash_indices + (working * ptrsize)), ptrsize, &tmp, false)) {\n         startup_printf(\"%s[%d]: Failed to read index slot, base 0x%lx, active 0x%lx\\n\", FILE__, __LINE__,\n                        thread_hash_indices, thread_hash_indices + (working * ptrsize));\n         return false;\n      }\n      startup_printf(\"%s[%d]: value of tid in slot %p is 0x%lx\\n\",\n                     FILE__, __LINE__, thread_hash_indices + (working * ptrsize), tmp);\n      if (ptrsize == 4 && tmp == 0xffffffff) {\n         int index_int = (int) index;\n         int tid_int = (int) tid;\n         startup_printf(\"%s[%d]: writing %d to %p and 0x%x to %p\\n\",\n                        FILE__, __LINE__, index_int, thread_hash_indices + (working * ptrsize),\n                        tid_int, thread_hash_tids + (working * ptrsize));\n         writeDataWord(( void *)(thread_hash_indices + (working * ptrsize)), ptrsize, &index_int);\n         writeDataWord(( void *)(thread_hash_tids + (working * ptrsize)), ptrsize, &tid_int);\n         break;\n      }\n      else if (ptrsize == 8 && tmp == (Address)-1)  {\n         writeDataWord(( void *)(thread_hash_indices + (working * ptrsize)), ptrsize, &index);\n         writeDataWord(( void *)(thread_hash_tids + (working * ptrsize)), ptrsize, &tid);\n         break;\n      }\n      working++;\n      if (working == thread_hash_size) working = 0;\n      if (working == (int) (tid % thread_hash_size)) {\n         startup_printf(\"%s[%d]: Failed to find empty tid slot\\n\", FILE__, __LINE__);\n         return false;\n      }\n   }\n   return true;\n}\nbool PCProcess::unregisterThread(PCThread *thread) {\t\n   return true;\n   Address tid = (Address) thread->getTid();\n   Address index = thread->getIndex();\n   Address tmp = 0;\n   \n   unsigned ptrsize = getAddressWidth();\n   if (tid == (Address) -1) return true;\n   if (index == (Address) -1) return true;\n\n   initializeRegisterThread();\n\n   // Must match the \"hash\" algorithm used in the RT lib\n   int working = tid % thread_hash_size;\n   while(1) {\n      tmp = 0;\n      if (!readDataWord((void *)(thread_hash_tids + (working * ptrsize)), ptrsize, &tmp, false)) return false;\n      if (tmp == tid) {\n         // Zero it out\n         tmp = (Address) -1;\n         writeDataWord(( void *)(thread_hash_indices + (working * ptrsize)), ptrsize, &tmp);\n         break;\n      }\n      working++;\n      if (working == thread_hash_size) working = 0;\n      if (working == (int) (tid % thread_hash_size)) return false;\n   }\n   return true;\n}\n\nbool PCProcess::initializeRegisterThread() {\n//   if (thread_hash_tids) return true;\n\n   unsigned ptrsize = getAddressWidth();\n   \n   Address tidPtr = getVarAddr(this, \"DYNINST_thread_hash_tids\");\n   if (!tidPtr) return false;\n   Address indexPtr = getVarAddr(this, \"DYNINST_thread_hash_indices\");\n   if (!indexPtr) return false;\n   Address sizePtr = getVarAddr(this, \"DYNINST_thread_hash_size\");\n   if (!sizePtr) return false;\n   \n   if (!readDataWord((const void *)tidPtr, ptrsize, &thread_hash_tids, false)) return false;\n\n   if (!readDataWord((const void *)indexPtr, ptrsize, &thread_hash_indices, false)) return false;\n\n   if (!readDataWord((const void *)sizePtr, sizeof(int), &thread_hash_size, false)) return false;\n\n   return true;\n}\n\n\n\nvoid PCProcess::addThread(PCThread *thread) {\n    pair<map<dynthread_t, PCThread *>::iterator, bool> result;\n    result = threadsByTid_.insert(make_pair(thread->getTid(), thread));\n\n    assert( result.second && \"Thread already in collection of threads\" );\n    proccontrol_printf(\"%s[%d]: added thread %lu to process %d\\n\",\n            FILE__, __LINE__, thread->getLWP(), getPid());\n}\n\nvoid PCProcess::getThreads(vector<PCThread* > &threads) const {\n    for(map<dynthread_t, PCThread *>::const_iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        threads.push_back(i->second);\n    }\n}\n\nbool PCProcess::wasRunningWhenAttached() const {\n    return runningWhenAttached_;\n}\n\nbool PCProcess::wasCreatedViaAttach() const {\n    return createdViaAttach_;\n}\n\nbool PCProcess::wasCreatedViaFork() const {\n    return parent_ != NULL;\n}\n\nunsigned PCProcess::getMemoryPageSize() const {\n   assert(pcProc_);\n   return pcProc_->getMemoryPageSize();\n}\n\nint PCProcess::getPid() const {\n    return savedPid_;\n}\n\nint PCProcess::incrementThreadIndex() {\n    int ret = curThreadIndex_;\n    curThreadIndex_++;\n    return ret;\n}\n\nunsigned PCProcess::getAddressWidth() const {\n    if( mapped_objects.size() > 0 ) {\n        return mapped_objects[0]->parse_img()->codeObject()->cs()->getAddressWidth();\n    }\n\n    // We can call this before we've attached...best effort guess\n    return sizeof(Address);\n}\n\nPCEventHandler * PCProcess::getPCEventHandler() const {\n    return eventHandler_;\n}\n\nbool PCProcess::walkStacks(pdvector<pdvector<Frame> > &stackWalks) {\n    bool needToContinue = false;\n    bool retval = true;\n\n    // sanity check\n\tif( stackwalker_ == NULL ) return false;\n\n    // Process needs to be stopped before doing a stackwalk\n    if( !isStopped() ) {\n        needToContinue = true;\n        if( !stopProcess() ) {\n            proccontrol_printf(\"%s[%d]: failed to stop process for stackwalking\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    for(map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n           i != threadsByTid_.end(); ++i)\n    {\n        PCThread *curThr = i->second;\n\n        pdvector<Frame> stackWalk;\n        if( !curThr->walkStack(stackWalk) ) {\n            retval = false;\n            proccontrol_printf(\"%s[%d]: failed to walk stack for thread 0x%lx(%d)\\n\",\n                    FILE__, __LINE__,\n                    curThr->getTid(), curThr->getLWP());\n        }else{\n            stackWalks.push_back(stackWalk);\n        }\n    }\n\n    if( needToContinue ) {\n        if( !continueProcess() ) {\n            proccontrol_printf(\"%s[%d]: failed to continue process after performing stackwalking\\n\",\n                    FILE__, __LINE__);\n            return false;\n        }\n    }\n\n    return retval;\n}\n\n// Return a vector (possibly with one object) of active frames in the process\nbool PCProcess::getAllActiveFrames(pdvector<Frame> &activeFrames) {\n    Frame active;\n    if( threadsByTid_.size() == 0 ) return false;\n\n    for(map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        Frame active = i->second->getActiveFrame();\n        if( active == Frame() ) return false;\n        activeFrames.push_back(active);\n    }\n\n    return true;\n}\n\n//\n// dynamic inferior heap stuff\n//\n\n#if defined(os_vxworks)\n#include \"vxworks.h\"\n#define HEAP_DYN_BUF_SIZE (0x4000)\n#else\n#define HEAP_DYN_BUF_SIZE (0x100000)\n#endif\n\nstatic const Address ADDRESS_LO = ((Address)0);\nstatic const Address ADDRESS_HI = ((Address)~((Address)0));\n\nAddress PCProcess::inferiorMalloc(unsigned size, inferiorHeapType type,\n                                  Address near_, bool *err) \n{\n   if(bootstrapState_ <= bs_readyToLoadRTLib) {\n      return 0;\n   }\n\n    enum MallocAttempt {\n        AsIs = 0,\n        DeferredFree = 1, // compact free blocks\n        NewSegment1MBConstrained = 2, // allocate new segment (1 MB, constrained)\n        NewSegmentSizedConstrained = 3, // allocate new segment (sized, constrained)\n        RemoveRangeConstraints = 4,\n        NewSegment1MBUnconstrained = 5,\n        NewSegmentSizedUnconstrained = 6,\n        DeferredFreeAgain = 7 // why again?\n    };\n\n    Address ret = 0;\n    if (err) *err = false;\n\n    if( size <= 0 ) {\n        infmalloc_printf(\"%s[%d]: inferior malloc cannot be <= 0\\n\",\n                FILE__, __LINE__);\n        if( err ) *err = true;\n        return 0;\n    }\n\n    // allocation range\n    Address lo = ADDRESS_LO; // Should get reset to a more reasonable value\n    Address hi = ADDRESS_HI; // Should get reset to a more reasonable value\n\n    //#if defined(cap_dynamic_heap)\n    inferiorMallocAlign(size); // align size\n    // Set the lo/hi constraints (if necessary)\n    inferiorMallocConstraints(near_, lo, hi, type);\n    //#else\n    /* align to cache line size (32 bytes on SPARC) */\n    //size = (size + 0x1f) & ~0x1f;\n    //#endif\n\n    infmalloc_printf(\"%s[%d]: inferiorMalloc entered; size %d, type %d, near 0x%lx (0x%lx to 0x%lx)\\n\",\n                     FILE__, __LINE__, size, type, near_, lo, hi);\n\n    // find free memory block (multiple attempts)\n    int freeIndex = -1;\n    int ntry = 0;\n    for (ntry = 0; freeIndex == -1; ntry++) {\n        switch(ntry) {\n        case AsIs: \n            break;\n\t    //#if defined(cap_dynamic_heap)\n        case DeferredFree: \n            infmalloc_printf(\"%s[%d]: garbage collecting and compacting\\n\",\n                             FILE__, __LINE__);\n            inferiorFreeCompact();\n            break;\n        case NewSegment1MBConstrained: \n            infmalloc_printf(\"%s[%d]: inferiorMallocDynamic for %d (0x%x) bytes between 0x%lx - 0x%lx\\n\",\n                             FILE__, __LINE__, HEAP_DYN_BUF_SIZE, HEAP_DYN_BUF_SIZE, lo, hi);\n            inferiorMallocDynamic(HEAP_DYN_BUF_SIZE, lo, hi);\n            break;\n        case NewSegmentSizedConstrained: \n            infmalloc_printf(\"%s[%d]: inferiorMallocDynamic for %d (0x%x) bytes between 0x%lx - 0x%lx\\n\",\n                             FILE__, __LINE__, size, size, lo, hi);\n            inferiorMallocDynamic(size, lo, hi);\n            break;\n        case RemoveRangeConstraints: \n            infmalloc_printf(\"%s[%d]: inferiorMalloc: removing range constraints\\n\",\n                             FILE__, __LINE__);\n            lo = ADDRESS_LO;\n            hi = ADDRESS_HI;\n            if (err) {\n                infmalloc_printf(\"%s[%d]: error in inferiorMalloc\\n\", FILE__, __LINE__);\n                *err = true;\n            }\n            break;\n        case NewSegment1MBUnconstrained: \n            infmalloc_printf(\"%s[%d]: inferiorMallocDynamic for %d (0x%x) bytes between 0x%lx - 0x%lx\\n\",\n                             FILE__, __LINE__, HEAP_DYN_BUF_SIZE, HEAP_DYN_BUF_SIZE, lo, hi);\n            inferiorMallocDynamic(HEAP_DYN_BUF_SIZE, lo, hi);\n            break;\n        case NewSegmentSizedUnconstrained: \n            infmalloc_printf(\"%s[%d]: inferiorMallocDynamic for %d (0x%x) bytes between 0x%lx - 0x%lx\\n\",\n                             FILE__, __LINE__, size, size, lo, hi);\n            inferiorMallocDynamic(size, lo, hi);\n            break;\n        case DeferredFreeAgain: \n            infmalloc_printf(\"%s[%d]: inferiorMalloc: recompacting\\n\", FILE__, __LINE__);\n            inferiorFreeCompact();\n            break;\n\t    //#else /* !(cap_dynamic_heap) */\n\t    //case DeferredFree: // deferred free, compact free blocks\n            //inferiorFreeCompact();\n            //break;\n\t    //#endif /* cap_dynamic_heap */\n\n        default: // error - out of memory\n            infmalloc_printf(\"%s[%d]: failed to allocate memory\\n\", FILE__, __LINE__);\n            if( err ) *err = true;\n            return 0;\n        }\n\n        ret = inferiorMallocInternal(size, lo, hi, type);\n        if (ret) break;\n    }\n    infmalloc_printf(\"%s[%d]: inferiorMalloc, returning address 0x%lx\\n\", FILE__, __LINE__, ret);\n    return ret;\n}\n\nvoid PCProcess::inferiorFree(Dyninst::Address item) {\n    inferiorFreeInternal(item);\n}\n\nbool PCProcess::inferiorRealloc(Dyninst::Address item, unsigned int newSize) {\n\tif(bootstrapState_ <= bs_readyToLoadRTLib) {\n      return true;\n   }\n   return inferiorReallocInternal(item, newSize);\n}\n\nstatic\nvoid alignUp(int &val, int align) {\n    assert(val >= 0);\n    assert(align >= 0);\n\n    if (val % align != 0) {\n        val = ((val / align) + 1) * align;\n    }\n}\n\nbool PCProcess::inferiorMallocDynamic(int size, Address lo, Address hi) {\n    const int MallocFailed = 0;\n    const int UnalignedBuffer = -1;\n\n    infmalloc_printf(\"%s[%d]: entering inferiorMallocDynamic\\n\", FILE__, __LINE__);\n\n    // word-align buffer size\n    // (see \"DYNINSTheap_align\" in rtinst/src/RTheap-<os>.c)\n    alignUp(size, 4);\n    // build AstNode for \"DYNINSTos_malloc\" call\n    std::string callee = \"DYNINSTos_malloc\";\n    pdvector<AstNodePtr> args(3);\n    args[0] = AstNode::operandNode(AstNode::Constant, (void *)(Address)size);\n    args[1] = AstNode::operandNode(AstNode::Constant, (void *)lo);\n    args[2] = AstNode::operandNode(AstNode::Constant, (void *)hi);\n    AstNodePtr code = AstNode::funcCallNode(callee, args);\n\n    // issue RPC and wait for result\n    bool wasRunning = !isStopped();\n\n    proccontrol_printf(\"%s[%d]: running inferiorMalloc via iRPC on process %d\\n\",\n            FILE__, __LINE__, getPid());\n\n    Address result = 0;\n    if( !postIRPC(code,\n                  NULL, // only care about the result\n                  wasRunning, // run when finished?\n                  NULL, // no specific thread\n                  true, // wait for completion\n                  (void **)&result,\n                  false, // internal iRPC\n                  true) ) // is a memory allocation RPC\n    {\n        infmalloc_printf(\"%s[%d]: failed to post iRPC for inferior malloc\\n\",\n                FILE__, __LINE__);\n        return false;\n    }\n    proccontrol_printf(\"%s[%d]: inferiorMalloc via iRPC returned 0x%lx\\n\",\n            FILE__, __LINE__, result);\n\n    switch ((int)result) {\n        case MallocFailed:\n            infmalloc_printf(\"%s[%d]: DYNINSTos_malloc() failed\\n\",\n                               FILE__, __LINE__);\n            return false;\n        case UnalignedBuffer:\n            infmalloc_printf(\"%s[%d]: DYNINSTos_malloc(): unaligned buffer size\\n\",\n                               FILE__, __LINE__);\n            return false;\n        default:\n            // add new segment to buffer pool\n            heapItem *h = new heapItem(result, size, getDynamicHeapType(),\n                    true, HEAPfree);\n            addHeap(h);\n            break;\n    }\n\n    return true;\n}\n\n// A copy of the BPatch-level instrumentation installer\nvoid PCProcess::installInstrRequests(const pdvector<instMapping*> &requests) {\n    if (requests.size() == 0) {\n        return;\n    }\n\n    // Instrumentation is now generated on a per-function basis, while\n    // the requests are per-inst, not per-function. So \n    // accumulate functions, then generate afterwards. \n\n    vector<func_instance *> instrumentedFuncs;\n\n    for (unsigned lcv=0; lcv < requests.size(); lcv++) {\n      inst_printf(\"%s[%d]: handling request %d of %d\\n\", FILE__, __LINE__, lcv+1, requests.size());\n\n        instMapping *req = requests[lcv];\n        pdvector<miniTramp *> minis;\n        \n        if(!multithread_capable() && req->is_MTonly())\n            continue;\n        \n        pdvector<func_instance *> matchingFuncs;\n        \n        if (!findFuncsByAll(req->func, matchingFuncs, req->lib)) {\n            inst_printf(\"%s[%d]: failed to find any functions matching %s (lib %s), returning failure from installInstrRequests\\n\", FILE__, __LINE__, req->func.c_str(), req->lib.c_str());\n            return;\n        }\n        else {\n            inst_printf(\"%s[%d]: found %d functions matching %s (lib %s), instrumenting...\\n\",\n                        FILE__, __LINE__, matchingFuncs.size(), req->func.c_str(), req->lib.c_str());\n        }\n\n        for (unsigned funcIter = 0; funcIter < matchingFuncs.size(); funcIter++) {\n           func_instance *func = matchingFuncs[funcIter];\n           if (!func) {\n              inst_printf(\"%s[%d]: null int_func detected\\n\",\n                          FILE__,__LINE__);\n              continue;  // probably should have a flag telling us whether errors\n           }\n\n\t   inst_printf(\"%s[%d]: Instrumenting %s at 0x%lx, offset 0x%lx in %s\\n\",\n\t\t       FILE__, __LINE__, \n\t\t       func->symTabName().c_str(),\n\t\t       func->addr(),\n\t\t       func->addr() - func->obj()->codeBase(),\n\t\t       func->obj()->fullName().c_str());\n            \n           // should be silently handled or not\n           AstNodePtr ast;\n           if ((req->where & FUNC_ARG) && req->args.size()>0) {\n              ast = AstNode::funcCallNode(req->inst, \n                                          req->args,\n                                          this);\n           }\n           else {\n              pdvector<AstNodePtr> def_args;\n              def_args.push_back(AstNode::operandNode(AstNode::Constant,\n                                                      (void *)0));\n              ast = AstNode::funcCallNode(req->inst,\n                                          def_args);\n           }\n           // We mask to strip off the FUNC_ARG bit...\n           std::vector<Point *> points;\n           switch ( ( req->where & 0x7) ) {\n              case FUNC_EXIT:\n                 mgr()->findPoints(Dyninst::PatchAPI::Scope(func),\n                                   Point::FuncExit,\n                                   std::back_inserter(points));\n                 break;\n              case FUNC_ENTRY:\n                 mgr()->findPoints(Dyninst::PatchAPI::Scope(func),\n                                   Point::FuncEntry,\n                                   std::back_inserter(points));\n                 break;\n              case FUNC_CALL:\n                 mgr()->findPoints(Dyninst::PatchAPI::Scope(func),\n                                   Point::PreCall,\n                                   std::back_inserter(points));\n                 break;\n              default:\n                 fprintf(stderr, \"Unknown where: %d\\n\",\n                         req->where);\n                 break;\n           } // switch\n\t   inst_printf(\"%s[%d]: found %d points to instrument\\n\", FILE__, __LINE__, points.size());\n           for (std::vector<Point *>::iterator iter = points.begin();\n                iter != points.end(); ++iter) {\n              Dyninst::PatchAPI::Instance::Ptr inst = (req->order == orderFirstAtPoint) ? \n                 (*iter)->pushFront(ast) :\n                 (*iter)->pushBack(ast);\n              if (inst) {\n                 if (!req->useTrampGuard) inst->disableRecursiveGuard();\n                 req->instances.push_back(inst);\n              }\n              else {\n                 fprintf(stderr, \"%s[%d]:  failed to addInst here\\n\", FILE__, __LINE__);\n              }\n           }        } // matchingFuncs        \n        \n    } // requests\n    relocate();\n    return;\n}\n\nstatic const unsigned MAX_IRPC_SIZE = 0x100000;\n\n\nbool PCProcess::postIRPC(void* buffer, int size, void* userData, bool runProcessWhenDone,\n                         PCThread* thread, bool synchronous, void** result,\n                         bool userRPC, bool isMemAlloc, Address addr)\n{\n   return postIRPC_internal(buffer,\n                            size,\n                            size,\n                            REG_NULL,\n                            addr,\n                            userData,\n                            runProcessWhenDone,\n                            thread,\n                            synchronous,\n                            userRPC,\n                            isMemAlloc,\n                            result);    \n}\n\nbool PCProcess::postIRPC(AstNodePtr action, void *userData, \n                         bool runProcessWhenDone, PCThread *thread, bool synchronous,\n                         void **result, bool userRPC, bool isMemAlloc, Address addr)\n{   \n   // Generate the code for the iRPC\n   codeGen irpcBuf(MAX_IRPC_SIZE);\n   irpcBuf.setAddrSpace(this);\n   irpcBuf.setRegisterSpace(registerSpace::irpcRegSpace(proc()));\n   irpcBuf.beginTrackRegDefs();\n   irpcBuf.setThread(thread);\n   \n#if defined(bug_syscall_changepc_rewind)\n   // Reported by SGI, during attach to a process in a system call:\n   \n   // Insert eight NOP instructions before the actual call to dlopen(). Loading\n   // the runtime library when the mutatee was in a system call will sometimes\n   // cause the process to (on IA32 anyway) execute the instruction four bytes\n   // PREVIOUS to the PC we actually set here. No idea why. Prepending the\n   // actual dlopen() call with eight NOP instructions insures this doesn't\n   // really matter. Eight was selected rather than four because I don't know\n   // if x86-64 does the same thing (and jumps eight bytes instead of four).\n   \n   // We will put in <addr width> rather than always 8; this will be 4 on x86 and\n   // 32-bit AMD64, and 8 on 64-bit AMD64.\n   irpcBuf.fill(proc()->getAddressWidth(), codeGen::cgNOP);\n#endif\n\n   irpcTramp_->setIRPCAST(action);\n   \n   // Create a stack frame for the RPC\n   if( !irpcTramp_->generateSaves(irpcBuf, irpcBuf.rs()) ) {\n      proccontrol_printf(\"%s[%d]: failed to generate saves via baseTramp\\n\",\n                         FILE__, __LINE__);\n      return false;\n   }\n   \n   Register resultReg = REG_NULL;\n   if( !action->generateCode(irpcBuf, false, resultReg) ) {\n      proccontrol_printf(\"%s[%d]: failed to generate code from AST\\n\",\n                         FILE__, __LINE__);\n      return false;\n   }\n\n    // Note: we should not do a corresponding baseTramp restore here:\n    // 1) It isn't necessary because ProcControl will restore the\n    //    registers\n    // 2) We need to be able to read registers to get the result of the iRPC\n    //    If we restore, we can't do that\n\n    // Emit the trailer for the iRPC\n\n    // breakOffset: where the irpc ends\n    unsigned breakOffset = irpcBuf.used();\n    insnCodeGen::generateTrap(irpcBuf);\n    insnCodeGen::generateTrap(irpcBuf);\n\n    irpcBuf.endTrackRegDefs();\n\n    return postIRPC_internal(irpcBuf.start_ptr(),\n                             irpcBuf.used(),\n                             breakOffset,\n                             resultReg,\n                             addr,\n                             userData,\n                             runProcessWhenDone,\n                             thread,\n                             synchronous,\n                             userRPC,\n                             isMemAlloc,\n                             result);    \n}\n\n// DEBUG\n#include \"instructionAPI/h/InstructionDecoder.h\"\n\nbool PCProcess::postIRPC_internal(void *buf,\n                                  unsigned size,\n                                  unsigned breakOffset,\n                                  Register resultReg,\n                                  Address addr,\n                                  void *userData,\n                                  bool runProcessWhenDone,\n                                  PCThread *thread,\n                                  bool synchronous,\n                                  bool userRPC,\n                                  bool isMemAlloc,\n                                  void **result) {\n   if( isTerminated() ) {\n      proccontrol_printf(\"%s[%d]: cannot post RPC to exited or terminated process %d\\n\",\n                         FILE__, __LINE__, getpid());\n      return false;\n   }\n   \n   if( thread && !thread->isLive() ) {\n      proccontrol_printf(\"%s[%d]: attempted to post RPC to dead thread %d\\n\",\n                         FILE__, __LINE__, thread->getLWP());\n      return false;\n   }\n\n\n   inferiorRPCinProgress *newRPC = new inferiorRPCinProgress;\n   newRPC->runProcWhenDone = runProcessWhenDone;\n   newRPC->deliverCallbacks = userRPC;\n   newRPC->userData = userData;\n   newRPC->synchronous = synchronous;\n\n   newRPC->resultRegister = resultReg;\n   \n   // Create the iRPC at the ProcControl level\n   if( addr == 0 ) {\n      bool err = false;\n      if( isMemAlloc ) {\n         // This assumes that there will always be space\n         addr = inferiorMalloc(size, lowmemHeap, 0, &err);\n      }else{\n         // recursive RPCs are okay when this isn't an inferiorMalloc RPC\n         addr = inferiorMalloc(size, anyHeap, 0, &err);\n      }\n      \n      if( err ) {\n         proccontrol_printf(\"%s[%d]: failed to allocate memory for RPC\\n\",\n                            FILE__, __LINE__);\n         delete newRPC;\n         return false;\n      }\n      newRPC->memoryAllocated = true;\n   }\n   \n    if (addr)\n       newRPC->rpc = IRPC::createIRPC(buf, size, addr);\n    else\n       newRPC->rpc = IRPC::createIRPC(buf, size);\n\n#if 0\n   // DEBUG\n   InstructionAPI::InstructionDecoder d(buf,size,getArch());\n   Address foo = addr;\n   InstructionAPI::Instruction::Ptr insn = d.decode();\n   while(insn) {\n      cerr << \"\\t\" << hex << foo << \": \" << insn->format(foo) << dec << endl;\n      foo += insn->size();\n      insn = d.decode();\n   }\n#endif\n    newRPC->rpc->setData(newRPC);\n\n    unsigned int start_offset = 0;\n#if defined(bug_syscall_changepc_rewind)\n    // Some Linux kernels have the following behavior:\n    // Process is in a system call;\n    // We interrupt the system call;\n    // We say \"change PC to address N\"\n    // The kernel helpfully changes it to (N - address width)\n    // The program crashes\n    // See a more complete comment above.\n    // For now, we pad the start of our code with NOOPS and change to just\n    // after those; if we hit rewind behavior, then we're executing safe code.\n    //\n    // Matt Note:  The above comment is slightly incorrect.  The kernel subracts\n    //  the length of the syscall/int instruction that triggered the system call,\n    //  not the address width.  Still address width is big enough, so I'm not\n    //  changing anything.\n    start_offset = proc()->getAddressWidth();\n    newRPC->rpcStartAddr += start_offset;\n#endif\n    newRPC->rpc->setStartOffset(start_offset);\n    newRPC->rpcCompletionAddr = addr + breakOffset;\n\n    // Post the iRPC\n    Thread::ptr t;\n    if (thread) {\n       t = thread->pcThr();\n    }\n    newRPC->thread = t;\n    \n    bool res = false;\n    proccontrol_printf(\"%s[%d]: Launching IRPC\\n\", FILE__, __LINE__);\n    if (synchronous) {\n       // We have an interesting problem here. ProcControl allows callbacks to specify whether the \n       // process should stop or run; however, that allows us to stop a process in the middle of an\n       // inferior RPC. If that happens, manually execute a continue and wait for completion ourselves.\n       if (t)\n          res = t->runIRPCSync(newRPC->rpc);\n       else\n          res = pcProc_->runIRPCSync(newRPC->rpc);\n       if (!res) {\n          bool done = false;\n          while (!done) {\n             proccontrol_printf(\"%s[%d]: Iterating in loop waiting for IRPC to complete\\n\", FILE__, __LINE__);\n             if (isTerminated()) {\n                fprintf(stderr, \"IRPC on terminated process, ret false!\\n\");\n                delete newRPC;\n                return false;\n             }\n\n            if (ProcControlAPI::getLastError() != ProcControlAPI::err_notrunning) {\n                // Something went wrong\n               proccontrol_printf(\"%s[%d]: failed to post %s RPC to %s, error %s\\n\",\n                                  FILE__, __LINE__, (synchronous ? \"sync\" : \"async\"), \n                                  ((thread == NULL) ? \"thread\" : \"process\"),\n                                  ProcControlAPI::getLastErrorMsg());\n               delete newRPC;\n               return false;\n            }\n            else {\n               proccontrol_printf(\"%s[%d]: ProcControl reported IRPC thread stopped, continuing and consuming events\\n\", FILE__, __LINE__);\n               newRPC->rpc->continueStoppedIRPC();\n               proccontrol_printf(\"%s[%d]: handling events in ProcControl\\n\", FILE__, __LINE__);\n               res = pcProc_->handleEvents(true);\n               PCEventMuxer::muxer().handle(NULL);\n               if (newRPC->rpc->state() == ProcControlAPI::IRPC::Done) {\n                  proccontrol_printf(\"%s[%d]: IRPC complete\\n\", FILE__, __LINE__);\n                  done = true;\n               }\n            }\n          }\n       }\n    }\n    else {\n       if (t)\n          res = t->runIRPCAsync(newRPC->rpc);\n       else\n          res = pcProc_->runIRPCAsync(newRPC->rpc);\n    }\n    if(!res) {\n       proccontrol_printf(\"%s[%d]: failed to post %s RPC to %s\\n\",\n                          FILE__, __LINE__, (synchronous ? \"sync\" : \"async\"), ((thread == NULL) ? \"thread\" : \"process\"));\n       delete newRPC;\n       return false;\n    }\n    \n    if( result ) {\n       *result = newRPC->returnValue;\n    }\n    \n    // Make sure Dyninst has worked everything out\n    PCEventMuxer::muxer().wait(false);\n\n   return true;\n}\n\n\nBPatch_hybridMode PCProcess::getHybridMode() {\n    return BPatch_normalMode;\n}\n\nbool PCProcess::isExploratoryModeOn() const {\n    return BPatch_exploratoryMode == analysisMode_ ||\n           BPatch_defensiveMode   == analysisMode_;\n}\n\nbool PCProcess::isRuntimeHeapAddr(Address addr) const {\n    for (unsigned hidx=0; hidx < dyninstRT_heaps_.size(); hidx++) {\n        if (addr >= dyninstRT_heaps_[hidx]->addr &&\n            addr < dyninstRT_heaps_[hidx]->addr + dyninstRT_heaps_[hidx]->length) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* returns true if blocks were overwritten, initializes overwritten\n * blocks and ranges by contrasting shadow pages with current memory\n * contents\n * 1. reads shadow pages in from memory\n * 2. constructs overwritten region list\n * 3. constructs overwrittn basic block list\n * 4. determines if the last of the blocks has an abrupt end, in which\n *    case it marks it as overwritten\n */\nbool PCProcess::getOverwrittenBlocks\n  ( std::map<Address, unsigned char *>& overwrittenPages,//input\n    std::list<std::pair<Address,Address> >& overwrittenRanges,//output\n    std::list<block_instance *> &writtenBBIs)//output\n{\n    const unsigned MEM_PAGE_SIZE = getMemoryPageSize();\n    unsigned char * memVersion = (unsigned char *) ::malloc(MEM_PAGE_SIZE);\n    Address regionStart = 0;\n    bool foundStart = false;\n    map<Address, unsigned char*>::iterator pIter = overwrittenPages.begin();\n    set<mapped_object*> owObjs;\n    for (; pIter != overwrittenPages.end(); pIter++) {\n        Address curPageAddr = (*pIter).first / MEM_PAGE_SIZE * MEM_PAGE_SIZE;\n        unsigned char *curShadow = (*pIter).second;\n\n        // 0. check to make sure curShadow is non-null, if it is null, \n        //    that means it hasn't been written to\n        if ( ! curShadow ) {\n                        cerr << \"\\t\\t No current shadow, continuing\" << endl;\n                        continue;\n        }\n\n        mapped_object* obj = findObject(curPageAddr);\n        if (owObjs.end() != owObjs.find(obj)) {\n            obj->setCodeBytesUpdated(false);\n        }\n\n        // 1. Read the modified page in from memory\n        Address readAddr = curPageAddr;\n        if (isMemoryEmulated()) {\n            bool valid = false;\n            boost::tie(valid,readAddr) = getMemEm()->translate(curPageAddr);\n                        cerr << \"\\t\\t Reading from shadow page \" << hex << readAddr << \" instead of original \" << curPageAddr << endl;\n            assert(valid);\n        }\n        readTextSpace((void*)readAddr, MEM_PAGE_SIZE, memVersion);\n\n        // 2. build overwritten region list by comparing shadow, memory\n        for (unsigned mIdx = 0; mIdx < MEM_PAGE_SIZE; mIdx++) {\n            if ( ! foundStart && curShadow[mIdx] != memVersion[mIdx] ) {\n                foundStart = true;\n                regionStart = curPageAddr+mIdx;\n            } else if (foundStart && curShadow[mIdx] == memVersion[mIdx]) {\n                foundStart = false;\n                                cerr << \"\\t\\t Adding overwritten range \" << hex << regionStart << \" -> \" << curPageAddr + mIdx << dec << endl;\n\n                overwrittenRanges.push_back(\n                    pair<Address,Address>(regionStart,curPageAddr+mIdx));\n            }\n        }\n        if (foundStart) {\n\n            foundStart = false;\n                        cerr << \"\\t\\t Adding overwritten range \" << hex << regionStart << \" -> \" << curPageAddr + MEM_PAGE_SIZE << dec << endl;\n\n            overwrittenRanges.push_back(\n                pair<Address,Address>(regionStart,curPageAddr+MEM_PAGE_SIZE));\n        }\n    }\n\n    // 3. Determine which basic blocks have been overwritten\n    list<pair<Address,Address> >::const_iterator rIter = overwrittenRanges.begin();\n    std::list<block_instance*> curBBIs;\n    while (rIter != overwrittenRanges.end()) {\n        mapped_object *curObject = findObject((*rIter).first);\n\n        curObject->findBlocksByRange((*rIter).first,(*rIter).second,curBBIs);\n        if (curBBIs.size()) {\n            mal_printf(\"overwrote %d blocks in range %lx %lx \\n\",\n                       curBBIs.size(),(*rIter).first,(*rIter).second);\n            writtenBBIs.splice(writtenBBIs.end(), curBBIs);\n        }\n\n        curBBIs.clear();\n        rIter++;\n    }\n\n    free(memVersion);\n    if (writtenBBIs.size()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// distribute the work to mapped_objects\nvoid PCProcess::updateCodeBytes\n    ( const list<pair<Address, Address> > &owRanges ) // input\n{\n    std::map<mapped_object *,list<pair<Address,Address> >*> objRanges;\n    list<pair<Address,Address> >::const_iterator rIter = owRanges.begin();\n    for (; rIter != owRanges.end(); rIter++) {\n        mapped_object *obj = findObject((*rIter).first);\n        if (objRanges.find(obj) == objRanges.end()) {\n            objRanges[obj] = new list<pair<Address,Address> >();\n        }\n        objRanges[obj]->push_back(pair<Address,Address>(rIter->first, rIter->second));\n    }\n\n    std::map<mapped_object *,list<pair<Address,Address> > *>::iterator oIter = \n        objRanges.begin();\n    for (; oIter != objRanges.end(); oIter++) \n    {\n        oIter->first->updateCodeBytes( *(oIter->second) );\n        delete (oIter->second);\n    }\n    assert(objRanges.size() <= 1); //o/w analysis code may not be prepared for other cases\n}\n\n#if 0\nstatic void otherFuncBlocks(func_instance *func, \n                            const set<block_instance*> &blks, \n                            set<block_instance*> &otherBlks)\n{\n    const func_instance::BlockSet &allBlocks = \n        func->blocks();\n    for (func_instance::BlockSet::const_iterator bit =\n         allBlocks.begin();\n         bit != allBlocks.end(); \n         bit++) \n    {\n        if (blks.end() == blks.find((*bit))) {\n            otherBlks.insert((*bit));\n        }\n    }\n}\n#endif\n\n/* Summary\n * Given a list of overwritten blocks, find blocks that are unreachable,\n * functions that have been overwritten at their entry points and can go away,\n * and new function entry for functions that are being overwritten while still\n * executing\n *\n * variables\n * f:  the overwritten function\n * ow: the set of overwritten blocks\n * ex: the set of blocks that are executing on the call stack that were not overwritten\n * \n * primitives\n * R(b,s): yields set of reachable blocks for collection of blocks b, starting\n *         at seed blocks s.\n * B(f):   the blocks pertaining to function f\n * EP(f):  the entry point of function f\n * F(b):   functions containing block b\n * \n * calculations\n * Elim(f): the set of blocks to eliminate from function f.\n *          Elim(f) = B(f) - R( B(f)-ow , EP(f) )\n * New(f):  new function entry candidates for f's surviving blocks.\n *          If EB(f) not in ow(f), empty set\n *          Else, all blocks b such that ( b in ex AND e in Elim(f) )\n *          Eliminate New(f) elements that have ancestors in New(f)\n * Del(f):  A block can be deleted altogether if\n *          forall f in F(b): B(F) - R( B(f) - ow , New(f) U (EP(f) \\ ow(f)) U (ex(f) intersect Elim(f)) ),\n *          b is not in the resulting set. In other words, b is not\n *          reachable from non-overwritten blocks in the functions in\n *          which it appears, seeded at new entry points and original\n *          non-overwritten entry points to the function, and at f's\n *          executing blocks if these will be deleted from the\n *          function (they constitute an entry point into the function \n *          even if they've been overwritten). \n * DeadF:   the set of functions that have no executing blocks \n *          and were overwritten in their entry blocks\n *          EP(f) in ow(f) AND ex(f) is empty\n */\nbool PCProcess::getDeadCode\n( const std::list<block_instance*> & /*owBlocks*/, // input\n  std::set<block_instance*> & /*delBlocks*/, //output: Del(for all f)\n  std::map<func_instance*,set<block_instance*> > & /*elimMap*/, //output: elimF\n  std::list<func_instance*> & /*deadFuncs*/, //output: DeadF\n  std::map<func_instance*,block_instance*> & /*newFuncEntries*/) //output: newF\n{\n   assert(0 && \"TODO\");\n   return false;\n#if 0\n    // do a stackwalk to see which functions are currently executing\n    pdvector<pdvector<Frame> >  stacks;\n    pdvector<Address> pcs;\n    if (!walkStacks(stacks)) {\n        inst_printf(\"%s[%d]:  walkStacks failed\\n\", FILE__, __LINE__);\n        return false;\n    }\n    for (unsigned i = 0; i < stacks.size(); ++i) {\n        pdvector<Frame> &stack = stacks[i];\n        for (unsigned int j = 0; j < stack.size(); ++j) {\n            Address origPC = 0;\n            vector<func_instance*> dontcare1;\n            baseTramp *dontcare2 = NULL;\n            getAddrInfo(stack[j].getPC(), origPC, dontcare1, dontcare2);\n            pcs.push_back( origPC );\n        }\n    }\n\n    // group blocks by function\n    std::map<func_instance*,set<block_instance*> > deadMap;\n    std::set<func_instance*> deadEntryFuncs;\n    std::set<Address> owBlockAddrs;\n    for (list<block_instance*>::const_iterator bIter=owBlocks.begin();\n         bIter != owBlocks.end(); \n         bIter++) \n    {\n       deadMap[(*bIter)->func()].insert(*bIter);\n       owBlockAddrs.insert((*bIter)->start());\n       if ((*bIter)->llb() == (*bIter)->func()->ifunc()->entry()) {\n          deadEntryFuncs.insert((*bIter)->func());\n       }\n    }\n\n    // for each modified function, calculate ex, ElimF, NewF, DelF\n    for (map<func_instance*,set<block_instance*> >::iterator fit = deadMap.begin();\n         fit != deadMap.end(); \n         fit++) \n    {\n\n        // calculate ex(f)\n        set<block_instance*> execBlocks;\n        for (unsigned pidx=0; pidx < pcs.size(); pidx++) {\n            std::set<block_instance *> candidateBlocks;\n            fit->first->findBlocksByAddr(pcs[pidx], candidateBlocks);\n            for (std::set<block_instance *>::iterator cb_iter = candidateBlocks.begin();\n                cb_iter != candidateBlocks.end(); ++cb_iter) {\n                block_instance *exB = *cb_iter;\n                if (exB && owBlockAddrs.end() == owBlockAddrs.find(\n                                                        exB->start())) \n                {\n                    execBlocks.insert(exB);\n                }\n            }\n        }\n\n        // calculate DeadF: EP(f) in ow and EP(f) not in ex\n        if ( 0 == execBlocks.size() ) {\n            set<block_instance*>::iterator eb = fit->second.find(\n                fit->first->entryBlock());\n            if (eb != fit->second.end()) {\n                deadFuncs.push_back(fit->first);\n                continue;// treated specially, don't need elimF, NewF or DelF\n            }\n        } \n\n        // calculate elimF\n        set<block_instance*> keepF;\n        list<block_instance*> seedBs;\n        seedBs.push_back(fit->first->entryBlock());\n        fit->first->getReachableBlocks(fit->second, seedBs, keepF);\n        otherFuncBlocks(fit->first, keepF, elimMap[fit->first]);\n\n        // calculate NewF\n        if (deadEntryFuncs.end() != deadEntryFuncs.find(fit->first)) {\n            for (set<block_instance*>::iterator bit = execBlocks.begin();\n                 bit != execBlocks.end();\n                 bit++) \n            {\n                if (elimMap[fit->first].end() != \n                    elimMap[fit->first].find(*bit)) \n                {\n                    newFuncEntries[fit->first] = *bit;\n                    break; // just need one candidate\n                }\n            }\n        }\n\n        // calculate Del(f)\n        seedBs.clear();\n        if (deadEntryFuncs.end() == deadEntryFuncs.find(fit->first)) {\n            seedBs.push_back(fit->first->entryBlock());\n        }\n        else if (newFuncEntries.end() != newFuncEntries.find(fit->first)) {\n            seedBs.push_back(newFuncEntries[fit->first]);\n        }\n        for (set<block_instance*>::iterator xit = execBlocks.begin();\n             xit != execBlocks.end();\n             xit++) \n        {\n            if (elimMap[fit->first].end() != elimMap[fit->first].find(*xit)) {\n                seedBs.push_back(*xit);\n            }\n        }\n        keepF.clear();\n        fit->first->getReachableBlocks(fit->second, seedBs, keepF);\n        otherFuncBlocks(fit->first, keepF, delBlocks);\n        \n    }\n\n    return true;\n#endif\n}\n\n// will flush addresses of all addresses in the specified range, if the\n// range is null, flush all addresses from the cache.  Also flush \n// rt-lib heap addrs that correspond to the range\nvoid PCProcess::flushAddressCache_RT(Address start, unsigned size)\n{\n    if (start != 0) {\n        mal_printf(\"Flushing address cache of range [%lx %lx]\\n\",\n                   start, \n                   start + size);\n    } else {\n        mal_printf(\"Flushing address cache of rt_lib heap addrs only \\n\");\n    }\n\n    // Find the runtime cache's address if it hasn't been set yet\n    if (0 == RT_address_cache_addr_) {\n        std::string arg_str (\"DYNINST_target_cache\");\n        pdvector<int_variable *> vars;\n        if ( ! findVarsByAll(arg_str, vars) ) {\n            fprintf(stderr, \"%s[%d]:  cannot find var %s\\n\", \n                    FILE__, __LINE__, arg_str.c_str());\n            assert(0);\n        }\n        if (vars.size() != 1) {\n            fprintf(stderr, \"%s[%d]:  ERROR:  %d vars matching %s, not 1\\n\", \n                    FILE__, __LINE__, (int)vars.size(), arg_str.c_str());\n            assert(0);\n        }\n        RT_address_cache_addr_ = vars[0]->getAddress();\n    }\n\n    // Clear all cache entries that match the runtime library\n    // Read in the contents of the cache\n    Address* cacheCopy = (Address*)malloc(TARGET_CACHE_WIDTH*sizeof(Address));\n    if ( ! readDataSpace( (void*)RT_address_cache_addr_, \n                          sizeof(Address)*TARGET_CACHE_WIDTH,(void*)cacheCopy,\n                          false ) ) \n    {\n        assert(0);\n    }\n\n    assert(dyninstRT_heaps_.size());\n    bool flushedHeaps = false;\n\n    while ( true ) // iterate twice, once to flush the heaps, \n    {              // and once to flush the flush range\n        Address flushStart=0;\n        Address flushEnd=0;\n        if (!flushedHeaps) {\n            // figure out the range of addresses we'll want to flush from\n\n            flushStart = dyninstRT_heaps_[0]->addr;\n            flushEnd = flushStart + dyninstRT_heaps_[0]->length;\n            for (unsigned idx=1; idx < dyninstRT_heaps_.size(); idx++) {\n                Address curAddr = dyninstRT_heaps_[idx]->addr;\n                if (flushStart > curAddr) {\n                    flushStart = curAddr;\n                }\n                curAddr += dyninstRT_heaps_[idx]->length;\n                if (flushEnd < curAddr) {\n                    flushEnd = curAddr;\n                }\n            }\n        } else {\n            flushStart = start;\n            flushEnd = start + size;\n        }\n        //zero out entries that lie in the runtime heaps\n        for(int idx=0; idx < TARGET_CACHE_WIDTH; idx++) {\n            //printf(\"cacheCopy[%d]=%lx\\n\",idx,cacheCopy[idx]);\n            if (flushStart <= cacheCopy[idx] &&\n                flushEnd   >  cacheCopy[idx]) {\n                cacheCopy[idx] = 0;\n            }\n        }\n        if ( flushedHeaps || (start == 0) ) {\n            break;\n        }\n        flushedHeaps = true;\n    }\n\n    // write the modified cache back into the RT_library\n    if ( ! writeDataSpace( (void*)RT_address_cache_addr_,\n                           sizeof(Address)*TARGET_CACHE_WIDTH,\n                           (void*)cacheCopy ) ) {\n        assert(0);\n    }\n    free(cacheCopy);\n}\n\n/* Given an address that's on the call stack, find the function that's\n * actively executing that address.  This makes most sense for finding the\n * address that's triggered a context switch back to Dyninst, either\n * through instrumentation or a signal\n */\nfunc_instance *PCProcess::findActiveFuncByAddr(Address addr)\n{\n    std::set<func_instance *> funcs;\n    // error checking by size...\n    (void)findFuncsByAddr(addr, funcs, true);\n    if (funcs.empty()) return NULL;\n\n    if (funcs.size() == 1) {\n        return *(funcs.begin());\n    }\n\n    // unrelocated shared function address, do a stack walk to figure \n    // out which of the shared functions is on the call stack\n    bool foundFrame = false;\n    func_instance *activeFunc = NULL; \n    pdvector<pdvector<Frame> >  stacks;\n    if ( false == walkStacks(stacks) ) {\n        fprintf(stderr,\"ERROR: %s[%d], walkStacks failed\\n\", \n                FILE__, __LINE__);\n        assert(0);\n    }\n    for (unsigned int i = 0; !foundFrame && i < stacks.size(); ++i) {\n        pdvector<Frame> &stack = stacks[i];\n        for (unsigned int j = 0; !foundFrame && j < stack.size(); ++j) {\n            Frame *curFrame = &stack[j];\n            Address framePC = curFrame->getPC();\n\n            // if we're at a relocated address, we can translate \n            // back to the right function, if translation fails \n            // frameFunc will still be NULL\n            RelocInfo ri;\n            func_instance *frameFunc = NULL;\n\n            if (getRelocInfo(framePC, ri) &&\n                ri.func) {\n               frameFunc = ri.func;\n            }\n            else if (j < (stack.size() - 1)) {\n                // Okay, crawl original code. \n                // Step 1: get our current function\n                std::set<func_instance *> curFuncs;\n                findFuncsByAddr(framePC, curFuncs);\n                // Step 2: get return addresses one frame up and map to possible callers\n                std::set<block_instance *> callerBlocks;\n                findBlocksByAddr(stack[j+1].getPC() - 1, callerBlocks);\n                for (std::set<block_instance *>::iterator cb_iter = callerBlocks.begin();\n                    cb_iter != callerBlocks.end(); ++cb_iter)\n                {\n                    if (!(*cb_iter)->containsCall()) continue;\n                    // We have a call point; now see if it called the entry of any function\n                    // that maps to a curFunc.\n                    for (std::set<func_instance *>::iterator cf_iter = curFuncs.begin();\n                         cf_iter != curFuncs.end(); ++cf_iter) {\n                       if ((*cf_iter) == (*cb_iter)->callee()) {\n                          frameFunc = *cf_iter;\n                       }\n                    }\n                }\n            }\n            if (frameFunc) {\n                foundFrame = true;\n                activeFunc = frameFunc;\n            }\n        }\n    }\n    if (!foundFrame) {\n        activeFunc = *(funcs.begin());\n    }\n                \n    return activeFunc;\n}\n\nbool PCProcess::patchPostCallArea(instPoint *callPt) {\n   // 1) Find all the post-call patch areas that correspond to this \n   //    call point\n   // 2) Generate and install the branches that will be inserted into \n   //    these patch areas\n   \n   // 1...\n   AddrPairSet patchAreas;\n   if ( ! generateRequiredPatches(callPt, patchAreas) ) {\n      return false;\n   }\n   \n   // 2...\n   generatePatchBranches(patchAreas);\n   return true;\n}\n\nbool PCProcess::generateRequiredPatches(instPoint *callPoint, \n                                        AddrPairSet &patchAreas)\n{\n    // We need to figure out where this patch should branch to.\n    // To do that, we're going to:\n    // 1) Forward map the entry of the ft block to\n    //    its most recent relocated version (if that exists)\n    // 2) For each padding area, create a (padAddr,target) pair\n\n    // 3)\n\n    block_instance *callB = callPoint->block();\n    block_instance *ftBlk = callB->getFallthrough()->trg();\n    if (!ftBlk) {\n        // find the block at the next address, if there's no fallthrough block\n        ftBlk = callB->obj()->findBlockByEntry(callB->end());\n        assert(ftBlk);\n    }\n\n    // ensure that we patch other callPts at the same address\n\n    vector<ParseAPI::Function*> callFuncs;\n    callPoint->block()->llb()->getFuncs(callFuncs);\n    for (vector<ParseAPI::Function*>::iterator fit = callFuncs.begin();\n         fit != callFuncs.end();\n         fit++)\n    {\n        func_instance *callF = findFunction((parse_func*)*fit);\n        instPoint *callP = instPoint::preCall(callF, callB);\n        Relocation::CodeTracker::RelocatedElements reloc;\n        CodeTrackers::reverse_iterator rit;\n        for (rit = relocatedCode_.rbegin(); rit != relocatedCode_.rend(); rit++)\n        {\n            if ((*rit)->origToReloc(ftBlk->start(), ftBlk, callF, reloc)) {\n                break;\n            }\n        }\n        if (rit == relocatedCode_.rend()) {\n            mal_printf(\"WARNING: no relocs of call-fallthrough at %lx \"\n                       \"in func at %lx, will not patch its post-call \"\n                       \"padding\\n\", callP->block()->last(),callF->addr());\n            (*relocatedCode_.rbegin())->debug();\n            continue;\n        }\n\n        Address to = reloc.instruction;\n        if (!reloc.instrumentation.empty()) {\n           // There could be a lot of instrumentation at this point. Bias towards the lowest,\n           // non-edge instrumentation\n           for (std::map<instPoint *, Address>::iterator inst_iter = reloc.instrumentation.begin();\n                inst_iter != reloc.instrumentation.end(); ++inst_iter) {\n              if (inst_iter->first->type() == PatchAPI::Point::EdgeDuring) continue;\n              to = (inst_iter->second < to) ? inst_iter->second : to;\n           }\n        }\n\n        // 2) \n        Address callInsnAddr = callP->block()->last();\n        if (forwardDefensiveMap_.end() != forwardDefensiveMap_.find(callInsnAddr)) {\n            map<func_instance*,set<DefensivePad> >::iterator mit = forwardDefensiveMap_[callInsnAddr].begin();\n            for (; mit != forwardDefensiveMap_[callInsnAddr].end(); ++mit) {\n              if (callF == mit->first) {\n                  set<DefensivePad>::iterator dit = mit->second.begin();\n                  for (; dit != mit->second.end(); ++dit) {\n                     Address jumpAddr = dit->first;\n                     patchAreas.insert(std::make_pair(jumpAddr, to));\n                     mal_printf(\"patching post-call pad for %lx[%lx] with %lx %s[%d]\\n\",\n                                callB->end(), jumpAddr, to, FILE__,__LINE__);\n                  }\n              }\n            }\n        }\n    }\n    if (patchAreas.empty()) {\n       mal_printf(\"WARNING: no relocs to patch for call at %lx, block end %lx\\n\", \n                  callPoint->addr_compat(),ftBlk->start());\n    }\n    return ! patchAreas.empty();\n}\n\nvoid PCProcess::generatePatchBranches(AddrPairSet &branchesNeeded) {\n  for (AddrPairSet::iterator iter = branchesNeeded.begin();\n       iter != branchesNeeded.end(); ++iter) \n  {\n    Address from = iter->first;\n    Address to = iter->second;\n\n    codeGen gen(64);\n    insnCodeGen::generateBranch(gen, from, to);\n\n    // Safety check: make sure we didn't overrun the patch area\n    Address lb = 0, ub = 0;\n    std::pair<func_instance*,Address> tmp;\n    if (!reverseDefensiveMap_.find(from, lb, ub, tmp)) {\n      // Huh? This worked before!\n      assert(0);\n    }\n    assert((from + gen.used()) <= ub);\n    if (!writeTextSpace((void *)from, \n\t\t\tgen.used(),\n\t\t\tgen.start_ptr())) {\n      assert(0);\n    }\n  }\n}\n\n/* debugSuicide is a kind of alternate debugging continueProc.  It runs the\n * process until terminated in single step mode, printing each instruction as\n * it executes.\n */\nvoid PCProcess::debugSuicide() {\n    if( isTerminated() ) return;\n\n    isInDebugSuicide_ = true;\n\n    pdvector<Frame> activeFrames;\n    getAllActiveFrames(activeFrames);\n\n    for(unsigned i=0; i < activeFrames.size(); ++i) {\n        Address addr = activeFrames[i].getPC();\n        fprintf(stderr, \"Frame %u @ 0x%lx\\n\", i , addr);\n    }\n\n    Thread::ptr initialThread = pcProc_->threads().getInitialThread();\n\n    initialThread->setSingleStepMode(true);\n    while( !isTerminated() && isAttached() && initialThread->isLive() ) {\n        // Get the current PC\n        MachRegister pcReg = MachRegister::getPC(getArch());\n        MachRegisterVal resultVal;\n        if( !initialThread->getRegister(pcReg, resultVal) ) {\n            fprintf(stderr, \"%s[%d]: failed to retreive register from thread %d/%d\\n\",\n                    FILE__, __LINE__, getPid(), initialThread->getLWP());\n            return;\n        }\n    }\n}\n\npdvector<func_instance *> PCProcess::pcsToFuncs(pdvector<Frame> stackWalk) {\n    pdvector <func_instance *> ret;\n    unsigned i;\n    func_instance *fn;\n    for(i=0;i<stackWalk.size();i++) {\n        fn = (func_instance *)findOneFuncByAddr(stackWalk[i].getPC());\n        // no reason to add a null function to ret\n        if (fn != 0) ret.push_back(fn);\n    }\n    return ret;\n}\n\nbool PCProcess::isInSignalHandler(Address addr) {\n    codeRange *range;\n    if( signalHandlerLocations_.find(addr, range) ) {\n        return true;\n    }\n\n    return false;\n}\n\nvoid PCProcess::addSignalHandler(Address addr, unsigned size) {\n    codeRange *handlerLoc;\n    if (signalHandlerLocations_.find(addr, handlerLoc)) {\n        return; // we're already tracking this location\n    }\n    handlerLoc = new signal_handler_location(addr, size);\n    signalHandlerLocations_.insert((signal_handler_location *)handlerLoc);\n}\n\nbool PCProcess::mappedObjIsDeleted(mapped_object *obj) {\n    for(unsigned i = 0; i < deletedObjects_.size(); ++i) {\n        if( obj == deletedObjects_[i] ) return true;\n    }\n\n    return false;\n}\n\n// AddressSpace Implementation //\nAddress PCProcess::offset() const {\n    assert(!\"This function is not implemented\");\n    return 0;\n}\n\nAddress PCProcess::length() const {\n    assert(!\"This function is not implemented\");\n    return 0;\n}\n\nArchitecture PCProcess::getArch() const {\n    return savedArch_;\n}\n\nbool PCProcess::multithread_ready(bool ignoreIfMtNotSet) {\n    // Since ProcControlAPI has taken over handling thread creation\n    // and destruction from the RT library, as soon as the process reaches\n    // the initialized state, the process is multithread ready if it\n    // is multithread capable.\n\n    if( !hasReachedBootstrapState(bs_initialized) ) return false;\n    if( !multithread_capable(ignoreIfMtNotSet) ) return false;\n\n    return true;\n}\n\nbool PCProcess::needsPIC() {\n    return false;\n}\n\nbool PCProcess::isInDebugSuicide() const {\n    return isInDebugSuicide_;\n}\n\nPCProcess::processState_t PCProcess::getDesiredProcessState() const {\n    return processState_;\n}\n\nvoid PCProcess::setDesiredProcessState(PCProcess::processState_t pc) {\n    processState_ = pc;\n}\n\nbool PCProcess::walkStack(pdvector<Frame> &stackWalk,\n                          PCThread *thread)\n{\n  if( stackwalker_ == NULL ) return false;\n\n  vector<Dyninst::Stackwalker::Frame> swWalk;\n\n  if (!stackwalker_->walkStack(swWalk, thread->getLWP()))\n  {\n    return false;\n  }\n\n  for (vector<Dyninst::Stackwalker::Frame>::iterator SWB = swWalk.begin(),\n       SWI = SWB,\n       SWE = swWalk.end();\n       SWI != SWE;\n       ++SWI)\n  {\n    stackWalk.push_back(Frame(*SWI, this, thread, (SWI == SWB)));\n  }\n\n  return true;\n}\n\nbool PCProcess::getActiveFrame(Frame &frame, PCThread *thread)\n{\n  Dyninst::Stackwalker::Frame swFrame;\n  if (!stackwalker_->getInitialFrame(swFrame, thread->getLWP()))\n  {\n    return false;\n  }\n\n  frame = Frame(swFrame, this, thread, true);\n  return true;\n}\n\n/* This is the simple version\n * 1. Need three pieces of information:\n * 1a. The instrumentation point that triggered the stopThread event (pointAddress)\n * 1b. The ID of the callback function given at the registration\n *     of the stopThread snippet\n * 1c. The result of the snippet calculation that was given by the user,\n *     if the point is a return instruction, read the return address\n * 2. If the calculation is an address that is meant to be interpreted, do that\n * 3. Invoke the callback\n */\nbool PCProcess::triggerStopThread(Address pointAddress, int callbackID, void *calculation) {\n    AddressSpace::RelocInfo ri;\n    if( !getRelocInfo(pointAddress, ri) ) {\n        assert(0);\n        return false;\n    }\n\n    // get instPoint from point address\n    func_instance *pointfunc = ri.func;\n    if (!pointfunc) {\n        mal_printf(\"%s[%d]: failed to find active function at 0x%lx\\n\",\n                FILE__, __LINE__, pointAddress);\n        return false;\n    }\n\n    instPoint *intPoint = ri.bt->point();\n    if (!intPoint) {\n        mal_printf(\"%s[%d]: failed to find inst point at 0x%lx\\n\",\n                FILE__, __LINE__, pointAddress);\n        return false;\n    }\n\n    mal_printf(\"handling stopThread %lx[%lx]=>%lx %s[%d]\\n\",\n            ri.reloc, pointAddress, (long)calculation, FILE__, __LINE__);\n\n    /* 2. If the callbackID is negative, the calculation is meant to be\n      interpreted as the address of code, so we call stopThreadCtrlTransfer\n      to translate the target to an unrelocated address */\n    if (callbackID < 0) {\n        callbackID *= -1;\n        calculation = (void*)\n            stopThreadCtrlTransfer(intPoint, (Address)calculation);\n    }\n\n    /* 3. Trigger the callback for the stopThread\n      using the correct snippet instance ID & event type */\n    ((BPatch_process*)up_ptr())->triggerStopThread\n        (intPoint, pointfunc, callbackID, (void*)calculation);\n\n    return true;\n}\n\n/*    If calculation is a relocated address, translate it to the original addr\n *    case 1: The point is at a return instruction\n *    case 2: The point is a control transfer into the runtime library\n *    Mark returning functions as returning\n *    Save the targets of indirect control transfers (not regular returns)\n */\nAddress PCProcess::stopThreadCtrlTransfer (instPoint* intPoint, \n                                         Address target)\n{\n   Address pointAddr = intPoint->addr_compat();\n\n    // if the point is a real return instruction and its target is a stack \n    // address, get the return address off of the stack \n    if (intPoint->type() == instPoint::FuncExit &&\n        intPoint->block()->isFuncExit() &&\n        !intPoint->func()->isSignalHandler()) \n    {\n        mal_printf(\"%s[%d]: return address is %lx\\n\", FILE__,\n                    __LINE__,target);\n    }\n\n    Address unrelocTarget = target;\n\n    if ( isRuntimeHeapAddr( target ) ) {\n        // get unrelocated target address, there are three possibilities\n        // a. We're in post-call padding, and targBBI is the call block\n        // b. We're in an analyzed fallthrough block\n        // c. The stack was tampered with and we need the (mod_pc - pc) \n        //    offset to figure out where we should be\n        malware_cerr << \"Looking for matches to incoming address \" \n            << hex << target << dec << endl;\n        std::pair<func_instance*,Address> tmp;\n\n        if ( reverseDefensiveMap_.find(target,tmp) ) {\n            // a. \n           std::set<block_instance*> callBs;\n           tmp.first->getBlocks(tmp.second, callBs);\n           block_instance *callB = (*callBs.begin());\n           edge_instance *fallthrough = callB->getFallthrough();\n           if (fallthrough) {\n              unrelocTarget = fallthrough->trg()->start();\n           } else {\n              unrelocTarget = callB->end();\n           }\n        }\n        else {\n            // b. \n            // if we're in the fallthrough block, match to call block, \n            // and if necessary, add fallthrough edge\n           AddressSpace::RelocInfo ri;\n           bool hasFT = getRelocInfo(target, ri);\n           assert(hasFT); // otherwise we should be in the defensive map\n           if (ri.pad) {\n               unrelocTarget = ri.block->end();\n           } else {\n               unrelocTarget = ri.block->start();\n           }\n        }\n        mal_printf(\"translated target %lx to %lx %s[%d]\\n\",\n            target, unrelocTarget, FILE__, __LINE__);\n    }\n    else { // target is not relocated, nothing to do but find the \n           // mapped_object, creating one if necessary, for transfers\n           // into memory regions that are allocated at runtime\n        mapped_object *obj = findObject(target);\n        if (!obj) {\n\n#if 0           \n           Frame activeFrame = threads[0]->get_lwp()->getActiveFrame();\n           for (unsigned i = 0; i < 0x100; ++i) {\n\t\t          Address stackTOP = activeFrame.esp;\n\t\t          Address stackTOPVAL =0;\n                readDataSpace((void *) (stackTOP + 4*i), \n                              sizeof(getAddressWidth()), \n                              &stackTOPVAL, false);\n\t\t          malware_cerr << \"\\tSTACK[\" << hex << stackTOP+4*i << \"]=\" \n                             << stackTOPVAL << dec << endl;\n           }\n#endif\n\n            obj = createObjectNoFile(target);\n            if (!obj) {\n                fprintf(stderr,\"ERROR, point %lx has target %lx that responds \"\n                        \"to no object %s[%d]\\n\", pointAddr, target, \n                        FILE__,__LINE__);\n                assert(0 && \"stopThread snippet has an invalid target\");\n                return 0;\n            }\n        }\n    }\n\n#if 0\n           Frame activeFrame = threads[0]->get_lwp()->getActiveFrame();\n           Address stackTOP = activeFrame.esp;\n           Address stackTOPVAL =0;\n           for (unsigned i = 0; \n                i < 0x100 && 0 != ((stackTOP + 4*i) % memoryPageSize_); \n                ++i) \n           {\n                readDataSpace((void *) (stackTOP + 4*i), \n                              sizeof(getAddressWidth()), \n                              &stackTOPVAL, false);\n\t\t          malware_cerr << \"\\tSTACK[\" << hex << stackTOP+4*i << \"]=\" \n                             << stackTOPVAL << dec << endl;\n           }\n#endif\n\n    return unrelocTarget;\n}\n\nvoid PCProcess::triggerNormalExit(int exitcode) {\n    for(std::map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        if( i->second != initialThread_ ) \n            BPatch::bpatch->registerThreadExit(this, i->second);\n    }\n    BPatch::bpatch->registerNormalExit(this, exitcode);\n\n    // Let the event handler know that the process should be moved to\n    // an exited state\n    setExiting(true);\n}\n\n// Debugging only\nbool PCProcess::setBreakpoint(Address addr) {\n    Breakpoint::ptr brkPt = Breakpoint::newBreakpoint();\n    if( !pcProc_->addBreakpoint(addr, brkPt) ) {\n        proccontrol_printf(\"%s[%d]: failed to set breakpoint at 0x%lx\\n\",\n                FILE__, __LINE__, addr);\n        return false;\n    }\n\n    return true;\n}\n\nbool PCProcess::launchDebugger() {\n    // Stop the process on detach \n    pdvector<func_instance *> breakpointFuncs;\n    if( !findFuncsByAll(\"DYNINSTsafeBreakPoint\", breakpointFuncs) ) {\n        fprintf(stderr, \"Failed to find function DYNINSTsafeBreakPoint\\n\");\n        return false;\n    }\n\n    func_instance *safeBreakpoint = breakpointFuncs[0];\n    for(map<dynthread_t, PCThread *>::iterator i = threadsByTid_.begin();\n            i != threadsByTid_.end(); ++i)\n    {\n        if( !i->second->pcThr_->setRegister(MachRegister::getPC(getArch()),\n                    safeBreakpoint->addr()) )\n        {\n            fprintf(stderr, \"Failed to set PC to 0x%lx\\n\", \n                    safeBreakpoint->addr());\n            return false;\n        }\n    }\n\n    // Detach the process\n    if( !detachProcess(true) ) {\n        fprintf(stderr, \"Failed to detach from process %d\\n\", getPid());\n        return false;\n    }\n\n    if( !startDebugger() ) {\n        fprintf(stderr, \"Failed to start debugger on process %d\\n\", getPid());\n        return false;\n    }\n\n    return true;\n}\n\n// End debugging\n\nAddress getVarAddr(PCProcess *proc, std::string str) {\n    Address retAddr = 0;\n\n    pdvector<int_variable *> vars;\n    if( proc->findVarsByAll(str, vars) ) {\n        if( vars.size() != 1 ) {\n            proccontrol_printf(\"%s[%d]: WARNING: multiple copies of %s found\\n\",\n                    FILE__, __LINE__, str.c_str());\n        }else{\n            retAddr = vars[0]->getAddress();\n        }\n    }else{\n        proccontrol_printf(\"%s[%d]: failed to find variable %s\\n\",\n                FILE__, __LINE__, str.c_str());\n    }\n    return retAddr;\n}\n\nAddress PCProcess::getRTEventBreakpointAddr() {\n    if( sync_event_breakpoint_addr_ == 0 ) {\n        sync_event_breakpoint_addr_ = getVarAddr(this, \"DYNINST_break_point_event\");\n    }\n\n    return sync_event_breakpoint_addr_;\n}\n\nAddress PCProcess::getRTEventIdAddr() {\n    if( sync_event_id_addr_ == 0 ) {\n        sync_event_id_addr_ = getVarAddr(this, \"DYNINST_synch_event_id\");\n    }\n\n    return sync_event_id_addr_;\n}\n\nAddress PCProcess::getRTEventArg1Addr() {\n    if( sync_event_arg1_addr_ == 0 ) {\n        sync_event_arg1_addr_ = getVarAddr(this, \"DYNINST_synch_event_arg1\");\n    }\n\n    return sync_event_arg1_addr_;\n}\n\nAddress PCProcess::getRTEventArg2Addr() {\n    if( sync_event_arg2_addr_ == 0 ) {\n        sync_event_arg2_addr_ = getVarAddr(this, \"DYNINST_synch_event_arg2\");\n    }\n\n    return sync_event_arg2_addr_;\n}\n\nAddress PCProcess::getRTEventArg3Addr() {\n    if( sync_event_arg3_addr_ == 0 ) {\n        sync_event_arg3_addr_ = getVarAddr(this, \"DYNINST_synch_event_arg3\");\n    }\n\n    return sync_event_arg3_addr_;\n}\n\nbool PCProcess::hasPendingEvents() {\n   // Go to the muxer as a final arbiter\n   return PCEventMuxer::muxer().hasPendingEvents(this);\n}\n\nbool PCProcess::hasRunningSyncRPC() const {\n    return (syncRPCThreads_.size() > 0);\n}\n\nvoid PCProcess::addSyncRPCThread(Thread::ptr thr) {\n   proccontrol_printf(\"%s[%d]: added sync rpc thread %d/%d\\n\",\n                      FILE__, __LINE__, getPid(), thr ? thr->getLWP() : 0);\n    syncRPCThreads_.insert(thr);\n}\n\nvoid PCProcess::removeSyncRPCThread(Thread::ptr thr) {\n    proccontrol_printf(\"%s[%d]: removed sync rpc thread %d/%d\\n\",\n\t\tFILE__, __LINE__, getPid(), thr ? thr->getLWP() : 0);\n    syncRPCThreads_.erase(thr);\n}\n\nbool PCProcess::continueSyncRPCThreads() {\n\tfor(set<Thread::ptr>::iterator i = syncRPCThreads_.begin();\n            i != syncRPCThreads_.end(); ++i)\n    {\n\t\tif(!(*i)) {\n\t\t\tif(!pcProc_->continueProc())\n\t\t\t{\n\t\t\t\tproccontrol_printf(\"%s[%d]: failed to continue entire process %d for sync RPC\\n\",\n\t\t\t\t\t\tFILE__, __LINE__, getPid());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if( !(*i)->continueThread() ) {\n            proccontrol_printf(\"%s[%d]: failed to continue thread %d/%d for sync RPC\\n\",\n                    FILE__, __LINE__, getPid(), (*i)->getLWP());\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid PCProcess::addTrap(Address from, Address to, codeGen &gen) {\n    map<Address, Breakpoint::ptr>::iterator breakIter =\n       installedCtrlBrkpts.find(from);\n\n    if( breakIter != installedCtrlBrkpts.end() ) {\n        if( !pcProc_->rmBreakpoint(from, breakIter->second) ) {\n\t  // Oops? \n        }\n        installedCtrlBrkpts.erase(breakIter);\n    }\n    \n    Breakpoint::ptr newBreak = Breakpoint::newTransferBreakpoint(to);\n    newBreak->setSuppressCallbacks(true);\n\n    if( !pcProc_->addBreakpoint(from, newBreak) ) {\n      // Oops? \n    }\n\n    installedCtrlBrkpts.insert(make_pair(from, newBreak));\n    gen.invalidate();\n}\n\nvoid PCProcess::removeTrap(Address from) {\n    map<Address, Breakpoint::ptr>::iterator breakIter = \n        installedCtrlBrkpts.find(from);\n    if( breakIter == installedCtrlBrkpts.end() ) return;\n\n    if( !pcProc_->rmBreakpoint(from, breakIter->second) ) {\n        proccontrol_printf(\"%s[%d]: failed to remove ctrl transfer breakpoint from 0x%lx\\n\",\n                FILE__, __LINE__, from);\n    }\n\n    installedCtrlBrkpts.erase(breakIter);\n}\n\nvoid PCProcess::invalidateMTCache() {\n    mt_cache_result_ = not_cached;\n}\n\n\nStackwalkSymLookup::StackwalkSymLookup(PCProcess *p)\n  : proc_(p)\n{}\n\nStackwalkSymLookup::~StackwalkSymLookup()\n{}\n\nbool StackwalkSymLookup::lookupAtAddr(Dyninst::Address addr, std::string &out_name, void* &out_value)\n{\n  func_instance *func = proc_->findOneFuncByAddr(addr);\n  if( func == NULL ) return false;\n\n  // set out_name to the name of the function at this addr\n  // set out_value to NULL, this value is no longer used\n\n  out_value = NULL;\n\n  if (func)\n  {\n    out_name = func->prettyName();\n  }\n  else\n  {\n    out_name = string(\"[UNKNOWN]\");\n  }\n  \n  return true;\n}\n\nStackwalkInstrumentationHelper::StackwalkInstrumentationHelper(PCProcess *p)\n  : proc_(p)\n{}\n\nStackwalkInstrumentationHelper::~StackwalkInstrumentationHelper()\n{}\n\nDynFrameHelper::DynFrameHelper(PCProcess *p)\n  : FrameFuncHelper(NULL),\n  proc_(p)\n{}\n\nDynFrameHelper::~DynFrameHelper()\n{}\n\nDynWandererHelper::DynWandererHelper(PCProcess *p)\n  : WandererHelper(NULL),\n  proc_(p)\n{}\n\nDynWandererHelper::~DynWandererHelper()\n{}\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/BPatch_process.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define BPATCH_FILE\n\n#include <string>\n\n#include \"inst.h\"\n#include \"instP.h\"\n#include \"instPoint.h\"\n#include \"function.h\" // func_instance\n#include \"codeRange.h\"\n#include \"dynProcess.h\"\n#include \"dynThread.h\"\n#include \"pcEventHandler.h\"\n#include \"os.h\"\n\n#include \"mapped_module.h\"\n#include \"mapped_object.h\"\n\n#include \"BPatch_libInfo.h\"\n#include \"BPatch.h\"\n#include \"BPatch_point.h\"\n#include \"BPatch_thread.h\"\n#include \"BPatch_function.h\"\n#include \"BPatch_basicBlock.h\"\n#include \"BPatch_module.h\"\n#include \"hybridAnalysis.h\"\n#include \"BPatch_private.h\"\n#include \"parseAPI/h/CFG.h\"\n#include \"ast.h\"\n#include \"debug.h\"\n#include \"MemoryEmulator/memEmulator.h\"\n#include <boost/tuple/tuple.hpp>\n\n#include \"PatchMgr.h\"\n#include \"PatchModifier.h\"\n#include \"Command.h\"\n#include \"Relocation/DynAddrSpace.h\"\n#include \"Relocation/DynPointMaker.h\"\n#include \"Relocation/DynObject.h\"\n\n#include \"Point.h\"\n\nusing namespace Dyninst;\nusing namespace Dyninst::SymtabAPI;\nusing PatchAPI::DynObject;\nusing PatchAPI::DynAddrSpace;\nusing PatchAPI::PatchMgr;\nusing PatchAPI::Patcher;\n\nint BPatch_process::getAddressWidth(){\n        return llproc->getAddressWidth();\n}\n\n/*\n * BPatch_process::getPid\n *\n * Return the process ID of the thread associated with this object.\n */\nint BPatch_process::getPid()\n{\n   return llproc ? llproc->getPid() : -1;\n}\n\n/*\n * BPatch_process::BPatch_process\n *\n * Starts a new process and associates it with the BPatch_process being\n * constructed.  The new process is placed into a stopped state before\n * executing any code.\n *\n * path         Pathname of the executable to start.\n * argv         A list of pointers to character strings which are the\n *              arguments for the new process, terminated by a NULL pointer.\n * envp         A list of pointers to character strings which are the\n *              environment variables for the new process, terminated by a\n *              NULL pointer.  If NULL, the default environment will be used.\n */\nBPatch_process::BPatch_process(const char *path, const char *argv[],\n                               BPatch_hybridMode mode, const char **envp,\n                               int stdin_fd, int stdout_fd, int stderr_fd)\n   : llproc(NULL), lastSignal(-1), exitCode(-1), exitSignal(-1),\n     exitedNormally(false), exitedViaSignal(false), mutationsActive(true), \n     createdViaAttach(false), detached(false), \n     terminated(false), reportedExit(false),\n     hybridAnalysis_(NULL)\n{\n   image = NULL;\n   pendingInsertions = NULL;\n\n   pdvector<std::string> argv_vec;\n   pdvector<std::string> envp_vec;\n   // Contruct a vector out of the contents of argv\n   if (argv) {\n      for(int i = 0; argv[i] != NULL; i++)\n         argv_vec.push_back(argv[i]);\n   }\n\n   // Construct a vector out of the contents of envp\n   if(envp) {\n      for(int i = 0; envp[i] != NULL; ++i)\n         envp_vec.push_back(envp[i]);\n   }\n\n   std::string directoryName = \"\";\n\n #if !defined(os_windows)\n   // this fixes a problem on linux and alpha platforms where pathless\n   // filenames are searched for either in a standard, predefined path, or\n   // in $PATH by execvp.  thus paths that should resolve to \"./\" are\n   // missed.  Note that the previous use of getcwd() here for the alpha\n   // platform was dangerous since this is an API and we don't know where\n   // the user's code will leave the cwd pointing.\n\n   if (NULL == strchr(path, '/')) {\n      const char *pathenv = getenv(\"PATH\");\n      char *pathenv_copy = strdup(pathenv);\n      char *ptrptr;\n      char *nextpath = strtok_r(pathenv_copy, \":\", &ptrptr);\n      while (nextpath) {\n         struct stat statbuf;\n\n         char *fullpath = new char[strlen(nextpath)+strlen(path)+2];\n         strcpy(fullpath,nextpath);\n         strcat(fullpath,\"/\");\n         strcat(fullpath,path);\n\n         if (!stat(fullpath,&statbuf)) {\n            directoryName = nextpath;\n            delete[] fullpath;\n            break;\n         }\n         delete[] fullpath;\n         nextpath = strtok_r(NULL,\":\", &ptrptr);\n      }\n      ::free(pathenv_copy);\n\n      if (nextpath == NULL) {\n         const char *dotslash = \"./\";\n         directoryName = dotslash;\n      }\n   }\n#endif\n\n   /*\n    * Set directoryName if a current working directory can be found in\n    * the new process' environment (and override any previous settings).\n    */\n   if (envp) {\n       for (int i = 0; envp[i] != NULL; ++i) {\n           if (strncmp(envp[i], \"PWD=\", 4) == 0) {\n               directoryName = envp[i] + 4;\n               break;\n           }\n       }\n   }\n\n   std::string spath(path);\n   llproc = PCProcess::createProcess(spath, argv_vec, mode, envp_vec,\n                                     directoryName, \n                                     stdin_fd, stdout_fd, stderr_fd);\n   if (llproc == NULL) {\n      BPatch_reportError(BPatchFatal, 68,\n           \"Dyninst was unable to create the specified process\");\n      return;\n   }\n\n   startup_cerr << \"Registering function callback...\" << endl;\n   llproc->registerFunctionCallback(createBPFuncCB);\n\n\n   startup_cerr << \"Registering instPoint callback...\" << endl;\n   llproc->registerInstPointCallback(createBPPointCB);\n   llproc->set_up_ptr(this);\n\n   assert(BPatch::bpatch != NULL);\n   startup_cerr << \"Registering process...\" << endl;\n   BPatch::bpatch->registerProcess(this);\n\n   // Create an initial thread\n   startup_cerr << \"Getting initial thread...\" << endl;\n   PCThread *thr = llproc->getInitialThread();\n   BPatch_thread *initial_thread = new BPatch_thread(this, thr);\n   threads.push_back(initial_thread);\n\n   startup_cerr << \"Creating new BPatch_image...\" << endl;\n   image = new BPatch_image(this);\n\n   assert(llproc->isBootstrapped());\n\n   assert(BPatch_heuristicMode != llproc->getHybridMode());\n   if ( BPatch_normalMode != mode ) {\n       BPatch::bpatch->setInstrStackFrames(true);\n       hybridAnalysis_ = new HybridAnalysis(llproc->getHybridMode(),this);\n   }\n\n   // Let's try to profile memory usage\n#if defined(PROFILE_MEM_USAGE)\n   void *mem_usage = sbrk(0);\n   fprintf(stderr, \"Post BPatch_process: sbrk %p\\n\", mem_usage);\n#endif\n\n   startup_cerr << \"BPatch_process::BPatch_process, completed.\" << endl;\n}\n\n#if defined(os_linux)\n/* Particular linux kernels running dyninst in particular patterns\n   (namely, with a single process having spawned the mutator and the\n   mutatee) are susceptible to a kernel bug that will cause a panic\n   if the mutator exits before the mutatee. See the comment above\n   class ForkNewProcessCallback : public DBICallbackBase in\n   debuggerinterface.h for details.\n*/\nbool LinuxConsideredHarmful(pid_t pid) // PUSH\n{\n    int major, minor, sub, subsub; // version numbers\n    pid_t my_ppid, my_pid, mutatee_ppid = 0;\n    FILE *fd;\n    char buf[1024];\n    char filename[64];\n\n    get_linux_version(major,minor,sub,subsub);\n\n    if( major == 2 && minor == 6 &&\n        (sub < 11 || (sub == 11 && subsub <= 11)) )\n    {\n        my_ppid = getppid();\n        my_pid = getpid();\n        // If anybody knows a better way to get the parent pid, be my\n        // guest to change this.\n        snprintf(filename, 64, \"/proc/%d/status\", pid);\n        fd = fopen(filename, \"r\");\n        if (!fd) {\n            startup_printf(\"Failed to open %s, assuming no linux kernel bug\\n\",\n                            filename);\n            return false;\n        }\n        while (fgets(buf, 1024, fd)) {\n            if (strncmp(buf, \"PPid\", 4) == 0) {\n                sscanf(buf, \"%*s %d\", &mutatee_ppid);\n                break;\n            }\n        }\n        fclose(fd);\n\n        if(my_ppid == mutatee_ppid ||\n           my_pid == mutatee_ppid)\n            return true;\n    }\n\n    return false;\n}\n#endif\n/*\n * BPatch_process::BPatch_process\n *\n * Constructs a new BPatch_process and associates it with a running process.\n * Stops execution of the process.\n *\n * path         Pathname of the executable file for the process.\n * pid          Process ID of the target process.\n */\nBPatch_process::BPatch_process\n(const char *path, int pid, BPatch_hybridMode mode)\n   : llproc(NULL), lastSignal(-1), exitCode(-1), exitSignal(-1),\n     exitedNormally(false), exitedViaSignal(false), mutationsActive(true), \n     createdViaAttach(true), detached(false), \n     terminated(false), reportedExit(false),\n     hybridAnalysis_(NULL)\n{\n   image = NULL;\n   pendingInsertions = NULL;\n\n#if defined(os_linux)\n    /* We need to test whether we are in kernel 2.6.9 - 2.6.11.11 (inclusive).\n       If so, and if the mutatee's parent and our parent are one and the same,\n       we are exposing the user to a potential kernel panic.\n    */\n    startup_printf(\"Checking for potential Linux kernel bug...\\n\");\n    if(LinuxConsideredHarmful(pid))\n    {\n        fprintf(stderr,\n            \"\\nWARNING: You are running a Linux kernel between 2.6.9 and \\n\"\n            \"2.6.11.11 (inclusive). Executing Dyninst under this kernel \\n\"\n            \"may exercise a bug in the Linux kernel and lead to a panic \\n\"\n            \"under some conditions. We STRONGLY suggest that you upgrade \\n\"\n            \"your kernel to 2.6.11.12 or higher.\\n\\n\");\n    }\n#endif\n\n   assert(BPatch::bpatch != NULL);\n\n    startup_printf(\"%s[%d]:  creating new BPatch_image...\\n\", FILE__, __LINE__);\n   image = new BPatch_image(this);\n    startup_printf(\"%s[%d]:  created new BPatch_image...\\n\", FILE__, __LINE__);\n   std::string spath = path ? std::string(path) : std::string();\n    startup_printf(\"%s[%d]:  attaching to process %s/%d\\n\", FILE__, __LINE__,\n          path ? path : \"no_path\", pid);\n\n   llproc = PCProcess::attachProcess(spath, pid, mode);\n   if (!llproc) {\n      BPatch_reportError(BPatchFatal, 68, \"Dyninst was unable to attach to the specified process\");\n      BPatch::bpatch->unRegisterProcess(pid, this);\n\n      return;\n   }\n\n   BPatch::bpatch->registerProcess(this, pid);\n   startup_printf(\"%s[%d]:  attached to process %s/%d\\n\", FILE__, __LINE__, path ? path : \n            \"no_path\", pid);\n\n   // Create the initial threads\n   pdvector<PCThread *> llthreads;\n   llproc->getThreads(llthreads);\n   for (pdvector<PCThread *>::iterator i = llthreads.begin();\n           i != llthreads.end(); ++i)\n   {\n      BPatch_thread *thrd = new BPatch_thread(this, *i);\n      threads.push_back(thrd);\n   }\n\n   llproc->registerFunctionCallback(createBPFuncCB);\n   llproc->registerInstPointCallback(createBPPointCB);\n   llproc->set_up_ptr(this);\n\n   assert(llproc->isBootstrapped());\n   assert(llproc->isStopped());\n\n   assert(BPatch_heuristicMode != llproc->getHybridMode());\n   if ( BPatch_normalMode != mode ) {\n       hybridAnalysis_ = new HybridAnalysis(llproc->getHybridMode(),this);\n   }\n}\n\n/*\n * BPatch_process::BPatch_process\n *\n * Constructs a new BPatch_process and associates it with a forked process.\n *\n * parentPid          Pathname of the executable file for the process.\n * childPid           Process ID of the target process.\n */\nBPatch_process::BPatch_process(PCProcess *nProc)\n   : llproc(nProc), lastSignal(-1), exitCode(-1), exitSignal(-1),\n     exitedNormally(false), exitedViaSignal(false), mutationsActive(true),\n     createdViaAttach(true), detached(false),\n     terminated(false),\n     reportedExit(false), hybridAnalysis_(NULL)\n{\n   // Add this object to the list of threads\n   assert(BPatch::bpatch != NULL);\n   image = NULL;\n   pendingInsertions = NULL;\n\n   BPatch::bpatch->registerProcess(this);\n\n   // Create the initial threads\n   pdvector<PCThread *> llthreads;\n   llproc->getThreads(llthreads);\n   for (pdvector<PCThread *>::iterator i = llthreads.begin();\n           i != llthreads.end(); ++i)\n   {\n      BPatch_thread *thrd = new BPatch_thread(this, *i);\n      threads.push_back(thrd);\n   }\n\n   llproc->registerFunctionCallback(createBPFuncCB);\n   llproc->registerInstPointCallback(createBPPointCB);\n   llproc->set_up_ptr(this);\n\n   image = new BPatch_image(this);\n}\n\n/*\n * BPatch_process::~BPatch_process\n *\n * Destructor for BPatch_process.\n */\nBPatch_process::~BPatch_process()\n{\n   if( llproc ) {\n       //  unRegister process before doing detach\n       BPatch::bpatch->unRegisterProcess(getPid(), this);   \n\n       /**\n        * If we attached to the process, then we detach and leave it be,\n        * otherwise we'll terminate it\n        **/\n\n       if (createdViaAttach) \n       {\n           llproc->detachProcess(true);\n       }\n       else  \n       {\n           if (llproc->isAttached()) {\n               terminateExecution();\n           }\n       }\n       delete llproc;\n       llproc = NULL;\n   }\n\n   for (int i=threads.size()-1; i>=0; i--) {\n       delete threads[i];\n   }\n\n   if (image) delete image;\n\n   image = NULL;\n\n   if (pendingInsertions)\n   {\n       for (unsigned f = 0; f < pendingInsertions->size(); f++)\n           {\n           delete (*pendingInsertions)[f];\n       }\n\n       delete pendingInsertions;\n       pendingInsertions = NULL;\n   }\n\n   if (NULL != hybridAnalysis_) {\n       delete hybridAnalysis_;\n   }\n\n   assert(BPatch::bpatch != NULL);\n}\n\n/*\n * BPatch_process::triggerInitialThreadEvents\n *\n * Events and callbacks shouldn't be delivered from a constructor so after a\n * BPatch_process is constructed, this should be called.\n */\nvoid BPatch_process::triggerInitialThreadEvents() {\n    // For compatibility, only do this for multithread capable processes\n    if( llproc->multithread_capable() ) {\n        for (BPatch_Vector<BPatch_thread *>::iterator i = threads.begin();\n                i != threads.end(); ++i) \n        {\n            BPatch::bpatch->registerThreadCreate(this, *i);\n        }\n    }\n}\n\n/*\n * BPatch_process::stopExecution\n *\n * Puts the thread into the stopped state.\n */\nbool BPatch_process::stopExecution() \n{\n    if( NULL == llproc ) return false;\n\n    // The user has already indicated they would like the process stopped\n    if( llproc->getDesiredProcessState() == PCProcess::ps_stopped ) return true;\n\n    llproc->setDesiredProcessState(PCProcess::ps_stopped);\n    return llproc->stopProcess();\n}\n\n/*\n * BPatch_process::continueExecution\n *\n * Puts the thread into the running state.\n */\nbool BPatch_process::continueExecution() \n{\n    if( NULL == llproc ) return false;\n    if( !llproc->isBootstrapped() ) return false;\n\n    // The user has already indicated they would like the process running\n    if( llproc->getDesiredProcessState() == PCProcess::ps_running ) return true;\n\n    llproc->setDesiredProcessState(PCProcess::ps_running);\n\n    return llproc->continueProcess();\n}\n\n/*\n * BPatch_process::terminateExecution\n *\n * Kill the thread.\n */\nbool BPatch_process::terminateExecution() \n{\n    if( NULL == llproc ) return false;\n\n    if( isTerminated() ) return true;\n\n    proccontrol_printf(\"%s[%d]:  about to terminate proc\\n\", FILE__, __LINE__);\n    return llproc->terminateProcess();\n}\n\n/*\n * BPatch_process::isStopped\n *\n * Returns true if the thread has stopped, and false if it has not.  \n */\nbool BPatch_process::isStopped()\n{\n    if( llproc == NULL ) return true;\n\n    // The state visible to the user is different than the state\n    // maintained by ProcControlAPI because processes remain in\n    // a stopped state while doing event handling -- the user \n    // shouldn't see the process in a stopped state in this\n    // case\n    //\n    // The following list is all cases where the user should see\n    // the process stopped:\n    // 1) BPatch_process::stopExecution is invoked\n    // 2) A snippet breakpoint occurs\n    // 3) The mutatee is delivered a stop signal\n\n    return llproc->getDesiredProcessState() == PCProcess::ps_stopped;\n}\n\n/*\n * BPatch_process::stopSignal\n *\n * Returns the number of the signal which caused the thread to stop.\n */\nint BPatch_process::stopSignal()\n{\n    if (!isStopped()) {\n        BPatch::reportError(BPatchWarning, 0, \n                \"Request for stopSignal when process is not stopped\");\n        return -1;\n    }\n    return lastSignal;\n}\n\n/*\n * BPatch_process::statusIsTerminated\n *\n * Returns true if the process has terminated, false if it has not.\n */\nbool BPatch_process::statusIsTerminated()\n{\n   if (llproc == NULL) return true;\n   return llproc->isTerminated();\n}\n\n/*\n * BPatch_process::isTerminated\n *\n * Returns true if the thread has terminated, and false if it has not.  This\n * may involve checking for thread events that may have recently changed this\n * thread's status.  \n */\nbool BPatch_process::isTerminated()\n{\n    if( NULL == llproc ) return true;\n\n    if( exitedNormally || exitedViaSignal ) return true;\n\n    return llproc->isTerminated();\n}\n\n/*\n * BPatch_process::terminationStatus\n *\n * Indicates how the program exited.  Returns one of NoExit, ExitedNormally,\n * or ExitedViaSignal.\n *\n */\nBPatch_exitType BPatch_process::terminationStatus() {\n   if(exitedNormally)\n      return ExitedNormally;\n   else if(exitedViaSignal)\n      return ExitedViaSignal;\n   return NoExit;\n}\n\n/*\n * BPatch_process::getExitCode\n *\n * Returns exit code of applications\n *\n */\nint BPatch_process::getExitCode()\n{\n   return exitCode;\n}\n\n/*\n * BPatch_process::getExitSignal\n *\n * Returns signal number that caused application to exit.\n *\n */\nint BPatch_process::getExitSignal()\n{\n   return lastSignal;\n}\n\nbool BPatch_process::wasRunningWhenAttached()\n{\n  if (!llproc) return false;\n  return llproc->wasRunningWhenAttached();\n}\n\n/*\n * BPatch_process::detach\n *\n * Detach from the thread represented by this object.\n *\n * cont         True if the thread should be continued as the result of the\n *              detach, false if it should not.\n */\nbool BPatch_process::detach(bool cont)\n{\n   if (image)\n      image->removeAllModules();\n   detached = llproc->detachProcess(cont);\n   BPatch::bpatch->unRegisterProcess(getPid(), this);\n   return detached;\n}\n\n/*\n * BPatch_process::isDetached\n *\n * Returns whether dyninstAPI is detached from this mutatee\n *\n */\nbool BPatch_process::isDetached()\n{\n   return detached;\n}\n\n/*\n * BPatch_process::dumpCore\n *\n * Causes the process to dump its state to a file, and optionally to terminate.\n * Returns true upon success, and false upon failure.\n *\n * file         The name of the file to which the state should be written.\n * terminate    Indicates whether or not the thread should be terminated after\n *              dumping core.  True indicates that it should, false that is\n *              should not.\n */\nbool BPatch_process::dumpCore(const char *file, bool terminate)\n{\n   bool was_stopped = isStopped();\n\n   stopExecution();\n\n   bool ret = llproc->dumpCore(file);\n   if (ret && terminate) {\n      terminateExecution();\n   } else if (!was_stopped) {\n      continueExecution();\n   }\n\n   return ret;\n}\n\n/*\n * BPatch_process::dumpImage\n *\n * Writes the contents of memory into a file.\n * Returns true upon success, and false upon failure.\n *\n * file         The name of the file to which the image should be written.\n */\nbool BPatch_process::dumpImage(const char *file)\n{\n#if defined(os_windows) \n   return false;\n#else\n   bool was_stopped = isStopped();\n\n   stopExecution();\n\n   bool ret = llproc->dumpImage(file);\n   if (!was_stopped) continueExecution();\n\n   return ret;\n#endif\n}\n\n/*\n * BPatch_process::getInheritedVariable\n *\n * Allows one to retrieve a variable which exists in a child process that\n * was inherited from and originally created in the parent process.\n * Function is invoked on the child BPatch_process (created from a fork in\n * the application).\n *\n * parentVar   A BPatch_variableExpr created in the parent thread\n *\n * Returns:    The corresponding BPatch_variableExpr from the child thread\n *             or NULL if the variable argument hasn't been malloced\n *             in a parent process.\n */\nBPatch_variableExpr *BPatch_process::getInheritedVariable(\n                                                             BPatch_variableExpr &parentVar)\n{\n   if(! llproc->isInferiorAllocated((Address)parentVar.getBaseAddr())) {\n      // isn't defined in this process so must not have been defined in a\n      // parent process\n      return NULL;\n   }\n\n   return new BPatch_variableExpr(this, llproc, parentVar.getBaseAddr(), Null_Register,\n                                  const_cast<BPatch_type *>(parentVar.getType()));\n}\n\n\n/*\n * BPatch_process::getInheritedSnippet\n *\n * Allows one to retrieve a snippet which exists in a child process which\n * was inherited from and originally created in the parent process.\n * Function is invoked on the child BPatch_process (created from a fork in\n * the application).\n *\n * Allows one to retrieve a snippet which exists in a child process which\n * was inherited from and originally created in the parent process.\n * Function is invoked on the child BPatch_process (created from a fork in\n * the application).\n *\n * parentSnippet: A BPatchSnippetHandle created in the parent thread\n *\n * Returns:       The corresponding BPatchSnippetHandle from the child thread.\n *\n */\n\nBPatchSnippetHandle *BPatch_process::getInheritedSnippet(BPatchSnippetHandle &parentSnippet)\n{\n    // a BPatchSnippetHandle has an miniTramp for each point that\n    // the instrumentation is inserted at\n   const BPatch_Vector<Dyninst::PatchAPI::Instance::Ptr> &instances = parentSnippet.instances_;\n\n   BPatchSnippetHandle *childSnippet = new BPatchSnippetHandle(this);\n   for(unsigned i=0; i<instances.size(); i++) {\n      Dyninst::PatchAPI::Instance::Ptr child = getChildInstance(instances[0], llproc);\n      if (child) childSnippet->addInstance(child);\n   }\n   return childSnippet;\n}\n\n/*\n * BPatch_addressSpace::beginInsertionSet\n *\n * Starts a batch insertion set; that is, all calls to insertSnippet until\n * finalizeInsertionSet are delayed.\n *\n */\n\nvoid BPatch_process::beginInsertionSet()\n{\n    if (pendingInsertions == NULL)\n        pendingInsertions = new BPatch_Vector<batchInsertionRecord *>;\n    // Nothing else to do...\n}\n\n\n/*\n * BPatch_process::finalizeInsertionSet\n *\n * Installs all instrumentation specified since the last beginInsertionSet call.\n *\n * modified gets set as a result of the catchup/fixup logic and is helpful in\n * interpreting a false return value...  if finalizeInsertionSet returns false,\n * but modified comes back true, then something horrible happened, because, if\n * we go thru the trouble to modify the process state to make everything work\n * then the function really should work.\n */\nbool BPatch_process::finalizeInsertionSet(bool, bool *)\n{\n\n   if (statusIsTerminated()) return false;\n\n\n  // Can't insert code when mutations are not active.\n  bool shouldContinue = false;\n  if (!mutationsActive) {\n    return false;\n  }\n  \n  if ( ! isStopped() ) {\n    shouldContinue = true;\n    stopExecution();\n  }\n\n  /* PatchAPI stuffs */\n  bool ret = AddressSpace::patch(llproc);\n  /* End of PatchAPI stuffs */\n\n  llproc->trapMapping.flush();\n\n  if (shouldContinue)\n    continueExecution();\n\n  if (pendingInsertions) {\n    delete pendingInsertions;\n    pendingInsertions = NULL;\n  }\n\n  return ret;\n}\n\n\nbool BPatch_process::finalizeInsertionSetWithCatchup(bool, bool *,\n                                                        BPatch_Vector<BPatch_catchupInfo> &)\n{\n   return false;\n}\n\n/*\n * BPatch_process::oneTimeCode\n *\n * execute argument <expr> once.\n *\n */\nvoid *BPatch_process::oneTimeCode(const BPatch_snippet &expr, bool *err)\n{\n    if( !isStopped() ) {\n        BPatch_reportError(BPatchWarning, 0,\n                \"oneTimeCode failing because process is not stopped\");\n        if( err ) *err = true;\n        return NULL;\n    }\n\n    return oneTimeCodeInternal(expr, NULL, NULL, NULL, true, err, true);\n}\n\n/*\n * BPatch_process::oneTimeCodeCallbackDispatch\n *\n * theProc\tThe process in which the RPC completed.\n * userData\tThis is a value that can be set when we invoke an inferior RPC\n * returnValue\tThe value returned by the RPC.\n */\nint BPatch_process::oneTimeCodeCallbackDispatch(PCProcess *theProc,\n                                                 unsigned /* rpcid */, \n                                                 void *userData,\n                                                 void *returnValue)\n{\n    // Don't care what the process state is...\n    int retval = RPC_LEAVE_AS_IS;\n\n    assert(BPatch::bpatch != NULL);\n\n    OneTimeCodeInfo *info = (OneTimeCodeInfo *)userData;\n\n    BPatch_process *bproc =\n    BPatch::bpatch->getProcessByPid(theProc->getPid());\n\n    assert(bproc != NULL);\n\n    assert(info && !info->isCompleted());\n\n    info->setReturnValue(returnValue);\n    info->setCompleted(true);\n\n    if (!info->isSynchronous()) {\n        // Do the callback specific to this OneTimeCode, if set\n        BPatchOneTimeCodeCallback specificCB = info->getCallback();\n        if( specificCB ) {\n            (*specificCB)(bproc->threads[0], info->getUserData(), returnValue);\n        }\n\n        // Do the registered callback\n        BPatchOneTimeCodeCallback cb = BPatch::bpatch->oneTimeCodeCallback;\n        if( cb ) {\n            (*cb)(bproc->threads[0], info->getUserData(), returnValue);\n        }\n\n        // This is the case if the user requested a stop in a callback\n        if (bproc->isStopped()) retval = RPC_STOP_WHEN_DONE;\n        else retval = RPC_RUN_WHEN_DONE;\n\n        delete info;\n    }\n\n    return retval;\n}\n\n/*\n * BPatch_process::oneTimeCodeInternal\n *\n * Causes a snippet expression to be evaluated once in the mutatee at the next\n * available opportunity.  Optionally, Dyninst will call a callback function\n * when the snippet has executed in the mutatee, and can wait until the\n * snippet has executed to return.\n *\n * expr         The snippet to evaluate.\n * userData     This value is given to the callback function along with the\n *              return value for the snippet.  Can be used by the caller to\n *              store per-oneTimeCode information.\n * synchronous  True means wait until the snippet has executed, false means\n *              return immediately.\n */\nvoid *BPatch_process::oneTimeCodeInternal(const BPatch_snippet &expr,\n                                          BPatch_thread *thread,\n                                          void *userData,\n                                          BPatchOneTimeCodeCallback cb,\n                                          bool synchronous,\n                                          bool *err,\n                                          bool userRPC)\n{\n    if( statusIsTerminated() ) { \n        BPatch_reportError(BPatchWarning, 0,\n                \"oneTimeCode failing because process has already exited\");\n        if( err ) *err = true;\n        return NULL;\n    }\n\n    proccontrol_printf(\"%s[%d]: UI top of oneTimeCode...\\n\", FILE__, __LINE__);\n\n    OneTimeCodeInfo *info = new OneTimeCodeInfo(synchronous, userData, cb,\n            (thread) ? thread->getBPatchID() : 0);\n\n    if( !llproc->postIRPC(expr.ast_wrapper, \n            (void *)info,\n            !isStopped(), \n            (thread ? thread->llthread : NULL),\n            synchronous,\n            NULL, // the result will be passed to the callback \n            userRPC) )\n    {\n        BPatch_reportError(BPatchWarning, 0,\n                    \"failed to continue process to run oneTimeCode\");\n        if( err ) *err = true;\n        delete info;\n        return NULL;\n    }\n\n    if( !synchronous ) return NULL;\n\n    assert( info->isCompleted() );\n\n    void *ret = info->getReturnValue();\n\n    proccontrol_printf(\"%s[%d]: RPC completed, process status %s\\n\",\n                       FILE__, __LINE__, isStopped() ? \"stopped\" : \"running\");\n\n    if (err) *err = false;\n    delete info;\n    return ret;\n}\n\n//  BPatch_process::oneTimeCodeAsync\n//\n//  Have the specified code be executed by the mutatee once.  Don't wait\n//  until done.\nbool BPatch_process::oneTimeCodeAsync(const BPatch_snippet &expr,\n                                         void *userData, BPatchOneTimeCodeCallback cb)\n{\n   bool err = false;\n   oneTimeCodeInternal(expr, NULL, userData,  cb, false, &err, true);\n\n   if( err ) return false;\n   return true;\n}\n\n/*\n * BPatch_process::loadLibrary\n *\n * Load a dynamically linked library into the address space of the mutatee.\n *\n * libname      The name of the library to load.\n */\nBPatch_object *BPatch_process::loadLibrary(const char *libname, bool)\n{\n   if (!libname) {\n      fprintf(stderr, \"[%s:%u] - loadLibrary called with NULL library name\\n\",\n              __FILE__, __LINE__);\n      return NULL;\n   }\n\n   bool wasStopped = isStopped();\n   if( !wasStopped ) {\n       if (!stopExecution()) {\n          BPatch_reportError(BPatchWarning, 0, \n                  \"Failed to stop process for loadLibrary\");\n          return NULL;\n       }\n   }\n\n   BPatch_object *object = NULL;\n   do {\n\n      /**\n       * Find the DYNINSTloadLibrary function\n       **/\n      BPatch_Vector<BPatch_function *> bpfv;\n      image->findFunction(\"DYNINSTloadLibrary\", bpfv);\n      if (!bpfv.size()) {\n         cerr << __FILE__ << \":\" << __LINE__ << \": FATAL:  Cannot find Internal\"\n              << \"Function DYNINSTloadLibrary\" << endl;\n         break;\n      }\n      if (bpfv.size() > 1) {\n         std::string msg = std::string(\"Found \") + utos(bpfv.size()) +\n            std::string(\"functions called DYNINSTloadLibrary -- not fatal but weird\");\n         BPatch_reportError(BPatchSerious, 100, msg.c_str());\n      }\n      BPatch_function *dlopen_func = bpfv[0];\n      if (dlopen_func == NULL)\n        break;\n\n      /**\n       * Generate a call to DYNINSTloadLibrary, and then run the generated code.\n       **/\n      BPatch_Vector<BPatch_snippet *> args;\n      BPatch_constExpr nameArg(libname);\n      args.push_back(&nameArg);\n      BPatch_funcCallExpr call_dlopen(*dlopen_func, args);\n\n      if (!oneTimeCodeInternal(call_dlopen, NULL, NULL, NULL, true)) {\n         BPatch_variableExpr *dlerror_str_var =\n            image->findVariable(\"gLoadLibraryErrorString\");\n         assert(NULL != dlerror_str_var);\n         char dlerror_str[256];\n         dlerror_str_var->readValue((void *)dlerror_str, 256);\n         BPatch_reportError(BPatchSerious, 124, dlerror_str);\n         break;\n      }\n      /* Find the new mapped_object, map it to a BPatch_module, and return it */\n\n      mapped_object* plib = llproc->findObject(libname);\n      if (!plib) {\n        std::string wildcard(libname);\n        wildcard += \"*\";\n        plib = llproc->findObject(wildcard, true);\n      }\n      if (!plib) {\n         // Best effort; take the latest added mapped_object\n         plib = llproc->mappedObjects().back();\n      }\n\n      dynamic_cast<DynAddrSpace*>(llproc->mgr()->as())->loadLibrary(plib);\n      object = getImage()->findOrCreateObject(plib);\n\n   } while (0);\n\n   if( !wasStopped ) {\n       if( !continueExecution() ) {\n           BPatch_reportError(BPatchWarning, 0,\n                   \"Failed to continue process for loadLibrary\");\n       }\n   }\n\n   return object;\n}\n\n\nvoid BPatch_process::enableDumpPatchedImage(){\n    // deprecated; saveTheWorld is dead. Do nothing for now; kill later.\n}\n\nvoid BPatch_process::setExitedViaSignal(int signalnumber)\n{\n   exitedViaSignal = true;\n   lastSignal = signalnumber;\n}\n\nvoid BPatch_process::setExitedNormally()\n{\n   exitedNormally = true;\n}\n\nvoid BPatch_process::getThreads(BPatch_Vector<BPatch_thread *> &thrds)\n{\n   for (unsigned i=0; i<threads.size(); i++)\n      thrds.push_back(threads[i]);\n}\n\nbool BPatch_process::isMultithreaded()\n{\n   return (threads.size() > 1);\n}\n\nbool BPatch_process::isMultithreadCapable()\n{\n   if (!llproc) return false;\n   return llproc->multithread_capable();\n}\n\nBPatch_thread *BPatch_process::getThread(dynthread_t tid)\n{\n   for (unsigned i=0; i<threads.size(); i++)\n      if (threads[i]->getTid() == tid)\n         return threads[i];\n   return NULL;\n}\n\nBPatch_thread *BPatch_process::getThreadByIndex(unsigned index)\n{\n   for (unsigned i=0; i<threads.size(); i++)\n      if (threads[i]->getBPatchID() == index)\n         return threads[i];\n   return NULL;\n}\n\nbool BPatch_process::getType()\n{\n  return TRADITIONAL_PROCESS;\n}\n\nvoid BPatch_process::getAS(std::vector<AddressSpace *> &as)\n{\n   as.push_back(static_cast<AddressSpace*>(llproc));\n}\n\n/**\n * Removes the BPatch_thread from this process' collection of\n * threads\n **/\nvoid BPatch_process::deleteBPThread(BPatch_thread *thrd)\n{\n   if (!thrd || !thrd->getBPatchID())\n   {\n      //Don't delete if this is the initial thread.  Some Dyninst programs\n      // may use the initial BPatch_thread as a handle instead of the\n      // BPatch_process, and we don't want to delete that handle out from\n      // under the users.\n      return;\n   }\n\n#if !defined(USE_DEPRECATED_BPATCH_VECTOR)\n   // STL vectors don't have item erase. We use iterators instead...\n   threads.erase(std::find(threads.begin(),\n                                 threads.end(),\n                                 thrd));\n#else\n   for (unsigned i=0; i< threads.size(); i++) {\n      if (threads[i] == thrd) {\n         threads.erase(i);\n         break;\n      }\n   }\n#endif\n\n   llproc->removeThread(thrd->getTid());\n\n   // We allow users to maintain pointers to exited threads\n   // If this changes, the memory can be free'd here\n   // delete thrd;\n}\n\n#ifdef IBM_BPATCH_COMPAT\n/**\n * In IBM's code, this is a wrapper for _BPatch_thread->addSharedObject (linux)\n * which is in turn a wrapper for creating a new\n * ibmBpatchElf32Teader(name, addr)\n **/\nbool BPatch_process::addSharedObject(const char *name,\n                                        const unsigned long loadaddr)\n{\n   return loadLibrary(name);\n}\n#endif\n\n/**\n * This function continues a stopped process, letting it execute in single step mode,\n * and printing the current instruction as it executes.\n **/\n\nvoid BPatch_process::debugSuicide()\n{\n    llproc->debugSuicide();\n}\n\nvoid BPatch_process::triggerThreadCreate(PCThread *thread) {\n  BPatch_thread *newthr = BPatch_thread::createNewThread(this, thread);\n  threads.push_back(newthr);\n  BPatch::bpatch->registerThreadCreate(this, newthr);\n}\n\n/* BPatch::triggerStopThread\n *\n * Causes the execution of a callback in the mutator that was\n * triggered for the evtStopThread event. As BPatch_stopThreadExpr\n * snippets allow a different callback to be triggered for each\n * snippet instance, the cb_ID is used to find the right callback to\n * trigger. This code had to be in a BPatch-level class so that we\n * could utilize the findOrCreateBPFunc and findOrCreateBPPoint\n * functions.\n *\n * @intPoint: the instPoint at which the event occurred, will be\n *    wrapped in a BPatch_point and sent to the callback as a parameter\n * @intFunc: the function in which the event occurred, will be wrapped\n *    in a BPatch_function and sent to the callback as a parameter\n * @proc: the process is needed for the creation of BPatch level objects\n * @cb_ID: helps us identify the correct call\n * @retVal: the return value of a parameter snippet that gets passed\n *    down in the stopThread snippet and evaluated.\n *\n * Return Value: Will always be true if code unless an error occurs, a\n *    callback is triggered for every stopThread snippet instance.\n */\nbool BPatch_process::triggerStopThread(instPoint *intPoint,\n         func_instance *intFunc, int cb_ID, void *retVal)\n{\n    // find the BPatch_point corresponding to the instrumentation point\n    BPatch_function *bpFunc = findOrCreateBPFunc(intFunc, NULL);\n    BPatch_procedureLocation bpPointType =\n        BPatch_point::convertInstPointType_t(intPoint->type());\n    BPatch_point *bpPoint = findOrCreateBPPoint(bpFunc, intPoint, bpPointType);\n    if (!bpPoint) {\n        return false;\n    }\n\n    // Trigger all the callbacks matching this snippet\n    for(unsigned int i = 0; i < BPatch::bpatch->stopThreadCallbacks.size(); ++i) {\n        BPatchStopThreadCallback curCallback = BPatch::bpatch->stopThreadCallbacks[i];\n        if( cb_ID == BPatch::bpatch->info->getStopThreadCallbackID((Address)curCallback) ) {\n            (*curCallback)(bpPoint, retVal);\n        }\n    }\n\n   return true;\n}\n\n\n/* BPatch::triggerSignalHandlerCB\n *\n * Grabs BPatch level objects for the instPoint and enclosing function\n * and triggers any registered callbacks for this signal/exception\n *\n * @intPoint: the instPoint at which the event occurred, will be\n * wrapped in a BPatch_point and sent to the callback as a parameter\n * @intFunc: the function in which the event occurred, will be\n * wrapped in a BPatch_function and sent to the callback as a parameter\n *\n * Return Value: true if a matching callback was found and no error occurred\n *\n */\nbool BPatch_process::triggerSignalHandlerCB(instPoint *intPoint,\n        func_instance *intFunc, long signum, BPatch_Vector<Address> *handlers)\n{\n    // find the BPatch_point corresponding to the exception-raising instruction\n    BPatch_function *bpFunc = findOrCreateBPFunc(intFunc, NULL);\n    BPatch_procedureLocation bpPointType =\n        BPatch_point::convertInstPointType_t(intPoint->type());\n    BPatch_point *bpPoint = findOrCreateBPPoint(bpFunc, intPoint, bpPointType);\n    if (!bpPoint) { return false; }\n\n    // Do the callback\n    InternalSignalHandlerCallback cb = BPatch::bpatch->signalHandlerCallback;\n    if( cb ) {\n        (*cb)(bpPoint, signum, *handlers);\n        return true;\n    }\n\n    return false;\n}\n\n/* BPatch::triggerCodeOverwriteCB\n *\n * Grabs BPatch level objects for the instPoint and enclosing function\n * and triggers a registered callback if there is one\n *\n * @intPoint: the instPoint at which the event occurred, will be\n * wrapped in a BPatch_point and sent to the callback as a parameter\n *\n * Return Value: true if a matching callback was found and no error occurred\n */\nbool BPatch_process::triggerCodeOverwriteCB(instPoint *faultPoint,\n                                            Address faultTarget)\n{\n    BPatch_function *bpFunc = findOrCreateBPFunc\n        (faultPoint->func(),NULL);\n    assert(bpFunc);\n    BPatch_point *bpPoint = findOrCreateBPPoint(\n        bpFunc,\n        faultPoint,\n        BPatch_point::convertInstPointType_t(faultPoint->type()));\n\n    // Do the callback\n    InternalCodeOverwriteCallback cb = BPatch::bpatch->codeOverwriteCallback;\n    if( cb ) {\n        (*cb)(bpPoint, faultTarget);\n        return true;\n    }\n\n    return false;\n}\n\n/* This is a Windows only function that sets the user-space\n * debuggerPresent flag to 0 or 1, 0 meaning that the process is not\n * being debugged.  The debugging process will still have debug\n * access, but system calls that ask if the process is being debugged\n * will say that it is not because they merely return the value of the\n * user-space beingDebugged flag.\n */\nbool BPatch_process::hideDebugger()\n{\n    // do non-instrumentation related hiding\n    bool retval = llproc->hideDebugger();\n\n    // disable API calls //\n    vector<pair<BPatch_function *,BPatch_function *> > disabledFuncs;\n    BPatch_module *user = image->findModule(\"user32.dll\",true);\n    BPatch_module *kern = image->findModule(\"*kernel32.dll\",true);\n\n    if (user) {\n        // BlockInput\n        using namespace SymtabAPI;\n        vector<BPatch_function*> funcs;\n        user->findFunction(\n            \"BlockInput\",\n            funcs, false, false, false, true);\n        assert (funcs.size());\n        BPatch_module *rtlib = this->image->findOrCreateModule(\n            (*llproc->runtime_lib.begin())->getModules().front());\n        vector<BPatch_function*> repfuncs;\n        rtlib->findFunction(\"DYNINST_FakeBlockInput\", repfuncs, false);\n        assert(!repfuncs.empty());\n        replaceFunction(*funcs[0],*repfuncs[0]);\n        disabledFuncs.push_back(pair<BPatch_function*,BPatch_function*>(\n                                funcs[0],repfuncs[0]));\n    }\n\n    if (kern) {\n        // SuspendThread\n        // KEVINTODO: condition the function replacement on its thread ID parameter matching a Dyninst thread\n        using namespace SymtabAPI;\n        vector<BPatch_function*> funcs;\n        kern->findFunction(\n            \"SuspendThread\",\n            funcs, false, false, false, true);\n        assert (funcs.size());\n        BPatch_module *rtlib = this->image->findOrCreateModule(\n            (*llproc->runtime_lib.begin())->getModules().front());\n        vector<BPatch_function*> repfuncs;\n        rtlib->findFunction(\"DYNINST_FakeSuspendThread\", repfuncs, false);\n        assert(!repfuncs.empty());\n        replaceFunction(*funcs[0],*repfuncs[0]);\n        disabledFuncs.push_back(pair<BPatch_function*,BPatch_function*>(\n                                funcs[0],repfuncs[0]));\n    }\n\n    if (kern) {\n        // getTickCount\n        using namespace SymtabAPI;\n        vector<BPatch_function*> funcs;\n        kern->findFunction(\n            \"GetTickCount\",\n            funcs, false, false, false, true);\n        if (!funcs.empty()) {\n\t\t\tBPatch_module *rtlib = this->image->findOrCreateModule(\n\t\t\t\t(*llproc->runtime_lib.begin())->getModules().front());\n\t\t\tvector<BPatch_function*> repfuncs;\n\t\t\trtlib->findFunction(\"DYNINST_FakeTickCount\", repfuncs, false);\n\t\t\tassert(!repfuncs.empty());\n\t\t\treplaceFunction(*funcs[0],*repfuncs[0]);\n\t\t\tdisabledFuncs.push_back(pair<BPatch_function*,BPatch_function*>(\n\t\t\t\t\t\t\t\t\tfuncs[0],repfuncs[0]));\n\t\t}\n    }\n\n    if (kern) {\n        // getSystemTime\n        using namespace SymtabAPI;\n        vector<BPatch_function*> funcs;\n        kern->findFunction(\n            \"GetSystemTime\",\n            funcs, false, false, false, true);\n        assert (!funcs.empty());\n        BPatch_module *rtlib = this->image->findOrCreateModule(\n            (*llproc->runtime_lib.begin())->getModules().front());\n        vector<BPatch_function*> repfuncs;\n        rtlib->findFunction(\"DYNINST_FakeGetSystemTime\", repfuncs, false);\n        assert(!repfuncs.empty());\n        replaceFunction(*funcs[0],*repfuncs[0]);\n        disabledFuncs.push_back(pair<BPatch_function*,BPatch_function*>(\n                                funcs[0],repfuncs[0]));\n    }\n\n    if (kern) {\n        // CheckRemoteDebuggerPresent\n        vector<BPatch_function*> funcs;\n        kern->findFunction(\n            \"CheckRemoteDebuggerPresent\",\n            funcs, false, false, true);\n        assert (funcs.size());\n        BPatch_module *rtlib = this->image->findOrCreateModule(\n            (*llproc->runtime_lib.begin())->getModules().front());\n        vector<BPatch_function*> repfuncs;\n        rtlib->findFunction(\"DYNINST_FakeCheckRemoteDebuggerPresent\", repfuncs, false);\n        assert(!repfuncs.empty());\n        replaceFunction(*funcs[0],*repfuncs[0]);\n        disabledFuncs.push_back(pair<BPatch_function*,BPatch_function*>(\n                                funcs[0],repfuncs[0]));\n    }\n\n    if (kern && user) {\n        // OutputDebugStringA\n        vector<BPatch_function*> funcs;\n        kern->findFunction(\"OutputDebugStringA\",\n            funcs, false, false, true);\n        assert(funcs.size());\n        vector<BPatch_function*> sle_funcs;\n        user->findFunction(\"SetLastErrorEx\", sle_funcs,\n                           false, false, true, true);\n        assert(!sle_funcs.empty());\n        vector<BPatch_snippet*> args;\n        BPatch_constExpr lasterr(1);\n        args.push_back(&lasterr);\n        args.push_back(&lasterr); // need a second parameter, but it goes unused by windows\n        BPatch_funcCallExpr callSLE (*(sle_funcs[0]), args);\n        vector<BPatch_point*> *exitPoints = sle_funcs[0]->findPoint(BPatch_exit);\n        beginInsertionSet();\n        for (unsigned i=0; i < exitPoints->size(); i++) {\n            insertSnippet( callSLE, *((*exitPoints)[i]) );\n        }\n    }\n\n    if (NULL != hybridAnalysis_) {\n        hybridAnalysis_->addReplacedFuncs(disabledFuncs);\n    }\n    finalizeInsertionSet(false);\n\n    if (!user || !kern) {\n        retval = false;\n    }\n    return retval;\n}\n\nbool BPatch_process::setMemoryAccessRights(Address start, size_t size, Dyninst::ProcControlAPI::Process::mem_perm rights) {\n    bool wasStopped = isStopped();\n    if( !wasStopped ) {\n        if (!stopExecution()) {\n            BPatch_reportError(BPatchWarning, 0,\n                               \"Failed to stop process for setMemoryAccessRights\");\n            return false;\n        }\n    }\n\n    int result = llproc->setMemoryAccessRights(start, size, rights);\n\n    if( !wasStopped ) {\n        if( !continueExecution() ) {\n            BPatch_reportError(BPatchWarning, 0,\n                    \"Failed to continue process for setMemoryAccessRights\");\n            return false;\n        }\n    }\n\n    return (result != -1);\n}\n\nunsigned char * BPatch_process::makeShadowPage(Dyninst::Address pageAddr)\n{\n    unsigned pagesize = llproc->getMemoryPageSize();\n    pageAddr = (pageAddr / pagesize) * pagesize;\n\n    Address shadowAddr = pageAddr;\n    if (llproc->isMemoryEmulated()) {\n        bool valid = false;\n        boost::tie(valid, shadowAddr) = llproc->getMemEm()->translate(pageAddr);\n        assert(valid);\n    }\n\n    unsigned char* buf = (unsigned char*) ::malloc(pagesize);\n    llproc->readDataSpace((void*)shadowAddr, pagesize, buf, true);\n    return buf;\n}\n\n// is the first instruction: [00 00] add byte ptr ds:[eax],al ? \nstatic bool hasWeirdEntryBytes(func_instance *func)\n{\n    using namespace SymtabAPI;\n    Symtab *sym = func->obj()->parse_img()->getObject();\n    if (sym->findEnclosingRegion(func->addr())\n        !=\n        sym->findEnclosingRegion(func->addr()+1))\n    {\n        return false;\n    }\n    unsigned short ebytes;\n    memcpy(&ebytes,func->obj()->getPtrToInstruction(func->addr()),2);\n\n    if (0 == ebytes) {\n        mal_printf(\"funct at %lx hasWeirdEntryBytes, 0x0000\\n\", func->addr());\n        return true;\n    }\n    return false;\n}\n\nvoid BPatch_process::overwriteAnalysisUpdate\n    ( std::map<Dyninst::Address,unsigned char*>& owPages, //input\n      std::vector<std::pair<Dyninst::Address,int> >& deadBlocks, //output\n      std::vector<BPatch_function*>& owFuncs, //output: overwritten & modified\n      std::set<BPatch_function *> &monitorFuncs, // output: those that call overwritten or modified funcs\n      bool &changedPages, bool &changedCode) //output\n{\n    //1.  get the overwritten blocks and regions\n    std::list<std::pair<Address,Address> > owRegions;\n    std::list<block_instance *> owBBIs;\n    llproc->getOverwrittenBlocks(owPages, owRegions, owBBIs);\n    changedPages = ! owRegions.empty();\n    changedCode = ! owBBIs.empty();\n\n    if ( !changedCode ) {\n        // update the mapped data for the overwritten ranges\n        llproc->updateCodeBytes(owRegions);\n        return;\n    }\n\n    /*2. remove dead code from the analysis */\n\n    // identify the dead code (see getDeadCode for its parameter definitions)\n    std::set<block_instance*> delBlocks; \n    std::map<func_instance*,set<block_instance*> > elimMap; \n    std::list<func_instance*> deadFuncs; \n    std::map<func_instance*,block_instance*> newFuncEntries; \n    llproc->getDeadCode(owBBIs,delBlocks,elimMap,deadFuncs,newFuncEntries);\n\n    // remove instrumentation from affected funcs\n    beginInsertionSet();\n    for(std::map<func_instance*,set<block_instance*> >::iterator fIter = elimMap.begin();\n        fIter != elimMap.end();\n        fIter++)\n    {\n        BPatch_function *bpfunc = findOrCreateBPFunc(fIter->first,NULL);\n        //hybridAnalysis_->removeInstrumentation(bpfunc,false,false);\n        bpfunc->removeInstrumentation(false);\n    }\n\n    //remove instrumentation from dead functions\n    for(std::list<func_instance*>::iterator fit = deadFuncs.begin();\n        fit != deadFuncs.end();\n        fit++)\n    {\n        // remove instrumentation\n        findOrCreateBPFunc(*fit,NULL)->removeInstrumentation(true);\n    }\n\n    finalizeInsertionSet(false);\n\n    // update the mapped data for the overwritten ranges\n    llproc->updateCodeBytes(owRegions);\n\n    // create stub edge set which is: all edges such that:\n    //     e->trg() in owBBIs and\n    //     while e->src() in delBlocks choose stub from among e->src()->sources()\n    std::map<func_instance*,vector<edgeStub> > stubs =\n       llproc->getStubs(owBBIs,delBlocks,deadFuncs);\n\n    // get stubs for dead funcs\n    map<Address,vector<block_instance*> > deadFuncCallers;\n    for(std::list<func_instance*>::iterator fit = deadFuncs.begin();\n        fit != deadFuncs.end();\n        fit++)\n    {\n       if ((*fit)->getLiveCallerBlocks(delBlocks, deadFuncs, deadFuncCallers) &&\n           ((*fit)->ifunc()->hasWeirdInsns() || hasWeirdEntryBytes(*fit))) \n       {\n          // don't reparse the function if it's likely a garbage function, \n          // but mark the caller point as unresolved so we'll re-parse\n          // if we actually call into the garbage func\n          Address funcAddr = (*fit)->addr();\n          vector<block_instance*>::iterator sit = deadFuncCallers[funcAddr].begin();\n          for ( ; sit != deadFuncCallers[funcAddr].end(); sit++) {\n             (*sit)->llb()->setUnresolvedCF(true);\n             vector<func_instance*> cfuncs;\n             (*sit)->getFuncs(std::back_inserter(cfuncs));\n             for (unsigned i=0; i < cfuncs.size(); i++) {\n                cfuncs[i]->ifunc()->setPrevBlocksUnresolvedCF(0); // force rebuild of unresolved list\n                cfuncs[i]->preCallPoint(*sit, true); // create point\n                monitorFuncs.insert(findOrCreateBPFunc(cfuncs[i], NULL));\n             }\n          }\n          deadFuncCallers.erase(deadFuncCallers.find(funcAddr));\n       }\n    }\n\n    // set new entry points for functions with NewF blocks, the active blocks\n    // in newFuncEntries serve as suggested entry points, but will not be \n    // chosen if there are other blocks in the function with no incoming edges\n    for (map<func_instance*,block_instance*>::iterator nit = newFuncEntries.begin();\n         nit != newFuncEntries.end();\n         nit++)\n    {\n        nit->first->setNewEntry(nit->second,delBlocks);\n    }\n    \n    // delete delBlocks and set new function entry points, if necessary\n    vector<PatchBlock*> delVector;\n    for(set<block_instance*>::reverse_iterator bit = delBlocks.rbegin(); \n        bit != delBlocks.rend();\n        bit++)\n    {\n        mal_printf(\"Deleting block [%lx %lx)\\n\", (*bit)->start(),(*bit)->end());\n        deadBlocks.push_back(pair<Address,int>((*bit)->start(),(*bit)->size()));\n        delVector.push_back(*bit);\n    }\n    if (!delVector.empty() && ! PatchAPI::PatchModifier::remove(delVector,true)) {\n        assert(0);\n    }\n    mal_printf(\"Done deleting blocks\\n\"); \n    // delete completely dead functions // \n\n    // save deadFunc block addresses in deadBlocks\n    for(std::list<func_instance*>::iterator fit = deadFuncs.begin();\n        fit != deadFuncs.end();\n        fit++)\n    {\n        const PatchFunction::Blockset& deadBs = (*fit)->blocks();\n        PatchFunction::Blockset::const_iterator bIter= deadBs.begin();\n        for (; bIter != deadBs.end(); bIter++) {\n            deadBlocks.push_back(pair<Address,int>((*bIter)->start(),\n                                                   (*bIter)->size()));\n        }\n    }\n\n    // now actually delete the dead functions and redirect call edges to sink \n    // block (if there already is an edge to the sink block, redirect \n    // doesn't duplicate the edge)\n    for(std::list<func_instance*>::iterator fit = deadFuncs.begin();\n        fit != deadFuncs.end();\n        fit++)\n    {\n        const PatchBlock::edgelist & srcs = (*fit)->entry()->sources();\n        vector<PatchEdge*> srcVec; // can't operate off edgelist, since we'll be deleting edges\n        srcVec.insert(srcVec.end(), srcs.begin(), srcs.end());\n        for (vector<PatchEdge*>::const_iterator sit = srcVec.begin();\n             sit != srcVec.end();\n             sit++)\n        {\n           if ((*sit)->type() == ParseAPI::CALL) {\n              PatchAPI::PatchModifier::redirect(*sit, NULL);\n           }\n        }\n\n        if (false == PatchAPI::PatchModifier::remove(*fit)) {\n            assert(0);\n        }\n    }\n    mal_printf(\"Done deleting functions\\n\");\n\n\n    // set up data structures for re-parsing dead functions from stubs\n    map<mapped_object*,vector<edgeStub> > dfstubs;\n    for (map<Address, vector<block_instance*> >::iterator sit = deadFuncCallers.begin();\n         sit != deadFuncCallers.end();\n         sit++)\n    {\n       for (vector<block_instance*>::iterator bit = sit->second.begin();\n            bit != sit->second.end();\n            bit++) \n       {\n          // re-instate call edges to the function\n          dfstubs[(*bit)->obj()].push_back(edgeStub(*bit,\n                                                    sit->first,\n                                                    ParseAPI::CALL));\n       }\n   }\n\n    // re-parse the functions\n    for (map<mapped_object*,vector<edgeStub> >::iterator mit= dfstubs.begin();\n         mit != dfstubs.end(); mit++)\n    {\n        mit->first->setCodeBytesUpdated(false);\n        if (mit->first->parseNewEdges(mit->second)) {\n            // add functions to output vector\n            for (unsigned fidx=0; fidx < mit->second.size(); fidx++) {\n               BPatch_function *bpfunc = findFunctionByEntry(mit->second[fidx].trg);\n               if (bpfunc) {\n                  owFuncs.push_back(bpfunc);\n               } else {\n                  // couldn't reparse\n                  mal_printf(\"WARNING: Couldn't re-parse an overwritten \"\n                             \"function at %lx %s[%d]\\n\", mit->second[fidx].trg, \n                             FILE__,__LINE__);\n               }\n            }\n        } else {\n            mal_printf(\"ERROR: Couldn't re-parse overwritten \"\n                       \"functions %s[%d]\\n\", FILE__,__LINE__);\n        }\n    }\n\n    //3. parse new code, one overwritten function at a time\n    for(std::map<func_instance*,set<block_instance*> >::iterator\n        fit = elimMap.begin();\n        fit != elimMap.end();\n        fit++)\n    {\n        // parse new edges in the function\n       if (!stubs[fit->first].empty()) {\n          fit->first->obj()->parseNewEdges(stubs[fit->first]);\n       } else {\n          // stubs may have been shared with another function and parsed in \n          // the other function's context.  \n          mal_printf(\"WARNING: didn't have any stub edges for overwritten \"\n                     \"func %lx\\n\", fit->first->addr());\n          //KEVINTEST: we used to wind up here with deleted functions, hopefully we do not anymore\n       }\n        // add curFunc to owFuncs, and clear the function's BPatch_flowGraph\n        BPatch_function *bpfunc = findOrCreateBPFunc(fit->first,NULL);\n        bpfunc->removeCFG();\n        owFuncs.push_back(bpfunc);\n    }\n\n    // do a consistency check\n    for(std::map<func_instance*,set<block_instance*> >::iterator \n        fit = elimMap.begin();\n        fit != elimMap.end();\n        fit++) \n    {\n        assert(fit->first->consistency());\n    }\n}\n\n/* Protect analyzed code without protecting relocated code in the\n * runtime library and for now only protect code in the aOut,\n * also don't protect code that hasn't been analyzed\n */\nbool BPatch_process::protectAnalyzedCode()\n{\n    bool ret = true;\n    BPatch_Vector<BPatch_module *> *bpMods = image->getModules();\n    for (unsigned midx=0; midx < bpMods->size(); midx++) {\n       if (!(*bpMods)[midx]->setAnalyzedCodeWriteable(false)) {\n           ret = false;\n       }\n    }\n    return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/BPatch.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdio.h>\n#include <assert.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if !defined(os_windows)\n#include <unistd.h>\n#endif\n\n#define BPATCH_FILE\n#include \"common/src/Pair.h\"\n#include \"common/src/Vector.h\"\n#include \"common/src/stats.h\"\n#include \"BPatch.h\"\n#include \"BPatch_libInfo.h\"\n#include \"BPatch_collections.h\"\n#include \"BPatch_thread.h\"\n#include \"common/src/timing.h\"\n#include \"debug.h\"\n#include \"mapped_module.h\"\n#include \"instPoint.h\"\n#include \"hybridAnalysis.h\"\n\n// ProcControlAPI interface\n#include \"dynProcess.h\"\n#include \"dynThread.h\"\n#include \"pcEventMuxer.h\"\n\n#if defined(i386_unknown_nt4_0)\n#include \"nt_signal_emul.h\"\n#endif\n\n#include <fstream>\n\nusing namespace SymtabAPI;\n\nextern void loadNativeDemangler();\n\nBPatch *BPatch::bpatch = NULL;\n\nvoid defaultErrorFunc(BPatchErrorLevel level, int num, const char * const *params);\n\n#ifndef CASE_RETURN_STR\n#define CASE_RETURN_STR(x) case x: return #x\n#endif\n\nconst char *asyncEventType2Str(BPatch_asyncEventType ev) {\n    switch(ev) {\n        CASE_RETURN_STR(BPatch_nullEvent);\n        CASE_RETURN_STR(BPatch_newConnectionEvent);\n        CASE_RETURN_STR(BPatch_internalShutDownEvent);\n        CASE_RETURN_STR(BPatch_threadCreateEvent);\n        CASE_RETURN_STR(BPatch_threadDestroyEvent);\n        CASE_RETURN_STR(BPatch_dynamicCallEvent);\n    default:\n        return \"BadEventType\";\n    }\n}\n\n/*\n * BPatch::BPatch\n *\n * Constructor for BPatch.  Performs one-time initialization needed by the\n * library.\n */\nBPatch::BPatch()\n  : info(NULL),\n    typeCheckOn(true),\n    lastError(0),\n    debugParseOn(true),\n    baseTrampDeletionOn(false),\n    trampRecursiveOn(false),\n    forceRelocation_NP(false),\n    autoRelocation_NP(true),\n    saveFloatingPointsOn(true),\n    forceSaveFloatingPointsOn(false),\n    livenessAnalysisOn_(true),\n    livenessAnalysisDepth_(3),\n    asyncActive(false),\n    delayedParsing_(false),\n    instrFrames(false),\n    systemPrelinkCommand(NULL),\n    notificationFDOutput_(-1),\n    notificationFDInput_(-1),\n    FDneedsPolling_(false),\n    errorCallback(NULL),\n    preForkCallback(NULL),\n    postForkCallback(NULL),\n    execCallback(NULL),\n    exitCallback(NULL),\n    oneTimeCodeCallback(NULL),\n    dynLibraryCallback(NULL),\n    threadCreateCallback(NULL),\n    threadDestroyCallback(NULL),\n    dynamicCallSiteCallback(NULL),\n    signalHandlerCallback(NULL),\n    codeOverwriteCallback(NULL),\n    inDestructor(false),\n    builtInTypes(NULL),\n    stdTypes(NULL),\n    type_Error(NULL),\n    type_Untyped(NULL)\n{\n    init_debug();\n    init_stats();\n\n    memset(&stats, 0, sizeof(BPatch_stats));\n    extern bool init();\n\n    // Save a pointer to the one-and-only bpatch object.\n    if (bpatch == NULL){\n       bpatch = this;\n    }\n    \n    BPatch::bpatch->registerErrorCallback(defaultErrorFunc);\n    bpinfo(\"installed default error reporting function\");\n    \n    /*\n     * Create the list of processes.\n     */\n    info = new BPatch_libInfo();\n\n    /*\n     * Create the \"error\" and \"untyped\" types.\n     */\n    type_Error   = BPatch_type::createFake(\"<error>\");\n    type_Untyped = BPatch_type::createFake(\"<no type>\");\n    \n    /*\n     * Initialize hash table of API types.\n     */\n    APITypes = BPatch_typeCollection::getGlobalTypeCollection();\n\n    stdTypes = BPatch_typeCollection::getGlobalTypeCollection();\n    vector<Type *> *sTypes = Symtab::getAllstdTypes();\n    for(unsigned i=0; i< sTypes->size(); i++)\n        stdTypes->addType(new BPatch_type((*sTypes)[i]));\n\n    builtInTypes = new BPatch_builtInTypeCollection;\n    sTypes = Symtab::getAllbuiltInTypes();\n    for(unsigned i=0; i< sTypes->size(); i++)\n        builtInTypes->addBuiltInType(new BPatch_type((*sTypes)[i]));\n\n    //loadNativeDemangler();\n\n\t// Start up the event handler thread\n\tPCEventMuxer::start();\n}\n\n\n/*\n * BPatch::~BPatch\n *\n * Destructor for BPatch.  Free allocated memory.\n */\nBPatch::~BPatch()\n{\n   inDestructor = true;\n    for(auto i = info->procsByPid.begin(); \n        i != info->procsByPid.end();\n        ++i)\n    {\n       delete i->second;\n    }\n\n    delete info;\n\n    type_Error->decrRefCount();\n    type_Untyped->decrRefCount();\n\n    if (stdTypes)\n        BPatch_typeCollection::freeTypeCollection(stdTypes);\n    if (APITypes)\n        BPatch_typeCollection::freeTypeCollection(APITypes);\n    if(builtInTypes)\n      delete builtInTypes;\n    \n    if(systemPrelinkCommand){\n        delete [] systemPrelinkCommand;\n    }\n    bpatch = NULL;\n}\n\nBPatch *BPatch::getBPatch() {\n\treturn bpatch;\n}\n\nchar * BPatch::getPrelinkCommand(){\n\treturn systemPrelinkCommand;\n}\n\nvoid BPatch::setPrelinkCommand(char *command){\n\n\tif(systemPrelinkCommand){\n\t\tdelete [] systemPrelinkCommand;\n\t}\n\tsystemPrelinkCommand = new char[strlen(command)+1];\n\tmemcpy(systemPrelinkCommand, command, strlen(command)+1);\n}\n\nbool BPatch::isTypeChecked()\n{\n  return typeCheckOn;\n}\nvoid BPatch::setTypeChecking(bool x)\n{\n  typeCheckOn = x;\n}\nbool BPatch::parseDebugInfo()\n{\n  return debugParseOn;\n}\nbool BPatch::delayedParsingOn()\n{\n  return delayedParsing_;\n}\nvoid BPatch::setDebugParsing(bool x)\n{\n  debugParseOn = x;\n}\nbool BPatch::baseTrampDeletion()\n{\n  return baseTrampDeletionOn;\n}\nvoid BPatch::setBaseTrampDeletion(bool x)\n{\n  baseTrampDeletionOn = x;\n}\nbool BPatch::isTrampRecursive()\n{\n  return trampRecursiveOn;\n}\nvoid BPatch::setTrampRecursive(bool x)\n{\n  trampRecursiveOn = x;\n}\nvoid BPatch::setLivenessAnalysis(bool x)\n{\n    livenessAnalysisOn_ = x;\n}\nbool BPatch::livenessAnalysisOn() {\n    return livenessAnalysisOn_;\n}\n\nvoid BPatch::setLivenessAnalysisDepth(int x)\n{\n    livenessAnalysisDepth_ = x;\n}\nint BPatch::livenessAnalysisDepth() {\n    return livenessAnalysisDepth_;\n}\n\nbool BPatch::hasForcedRelocation_NP()\n{\n  return forceRelocation_NP;\n}\nvoid BPatch::setForcedRelocation_NP(bool x)\n{\n  forceRelocation_NP = x;\n}\nbool BPatch::autoRelocationOn()\n{\n  return autoRelocation_NP;\n}\nvoid BPatch::setAutoRelocation_NP(bool x)\n{\n  autoRelocation_NP = x;\n}\nvoid BPatch::setDelayedParsing(bool x)\n{\n  delayedParsing_ = x;\n}\nbool BPatch::isMergeTramp()\n{\n  return true;\n}\nvoid BPatch::setMergeTramp(bool)\n{\n}\n\nbool BPatch::isSaveFPROn()\n{\n  return saveFloatingPointsOn;\n}\nvoid BPatch::setSaveFPR(bool x)\n{\n  saveFloatingPointsOn = x;\n}\n\nbool BPatch::isForceSaveFPROn()\n{\n  return forceSaveFloatingPointsOn;\n}\nvoid BPatch::forceSaveFPR(bool x)\n{\n  forceSaveFloatingPointsOn = x;\n}\n\n/*\n * BPatch::registerErrorCallback\n *\n * Registers a function that is to be called by the library when an error\n * occurs or when there is status to report.  Returns the address of the\n * previously registered error callback function.\n *\n * function\tThe function to be called.\n */\n\n\nBPatchErrorCallback BPatch::registerErrorCallback(BPatchErrorCallback function)\n{\n    BPatchErrorCallback previous = errorCallback;\n    errorCallback = function;\n    return previous;\n}\n\n/*\n * BPatch::registerPostForkCallback\n *\n * Registers a function that is to be called by the library when a new\n * process has been forked off by an mutatee process.\n *\n * function\tThe function to be called.\n */\nBPatchForkCallback BPatch::registerPostForkCallback(BPatchForkCallback func)\n{\n#if defined(i386_unknown_nt4_0) \n  reportError(BPatchWarning, 0,\n\t      \"postfork callbacks not implemented on this platform\\n\");\n  return NULL;\n#else\n    BPatchForkCallback previous = postForkCallback;\n    postForkCallback = func;\n    return previous;\n#endif\n}\n\n/*\n * BPatch::registerPreForkCallback\n *\n * Registers a function that is to be called by the library when a process\n * is about to fork a new process\n *\n * function\tThe function to be called.\n */\nBPatchForkCallback BPatch::registerPreForkCallback(BPatchForkCallback func)\n{\n#if defined(i386_unknown_nt4_0)\n    reportError(BPatchWarning, 0,\n\t\"prefork callbacks not implemented on this platform\\n\");\n    return NULL;\n#else\n    BPatchForkCallback previous = preForkCallback;\n    preForkCallback = func;\n    return previous;\n#endif\n}\n\n/*\n * BPatch::registerExecCallback\n *\n * Registers a function that is to be called by the library when a \n * process has just completed an exec* call\n *\n * func\tThe function to be called.\n */\nBPatchExecCallback BPatch::registerExecCallback(BPatchExecCallback func)\n{\n\n#if defined(i386_unknown_nt4_0) \n    reportError(BPatchWarning, 0,\n\t\"exec callbacks not implemented on this platform\\n\");\n    return NULL;\n#else\n    BPatchExecCallback previous = execCallback;\n    execCallback = func;\n    return previous;\n#endif\n}\n\n/*\n * BPatch::registerExitCallback\n *\n * Registers a function that is to be called by the library when a \n * process has just called the exit system call\n *\n * func\tThe function to be called.\n */\nBPatchExitCallback BPatch::registerExitCallback(BPatchExitCallback func)\n{\n    BPatchExitCallback previous = exitCallback;\n    exitCallback = func;\n    return previous;\n}\n\n/*\n * BPatch::registerOneTimeCodeCallback\n *\n * Registers a function that is to be called by the library when a \n * oneTimeCode (inferior RPC) is completed.\n *\n * func\tThe function to be called.\n */\nBPatchOneTimeCodeCallback BPatch::registerOneTimeCodeCallback(BPatchOneTimeCodeCallback func)\n{\n    BPatchOneTimeCodeCallback previous = oneTimeCodeCallback;\n    oneTimeCodeCallback = func;\n    return previous;\n}\n\n/*\n * BPatch::registerDynLibraryCallback\n *\n * Registers a function that is to be called by the library when a dynamically\n * loaded library is loaded or unloaded by a process under the API's control.\n * Returns the address of the previously registered callback function.\n *\n * function\tThe function to be called.\n */\nBPatchDynLibraryCallback\nBPatch::registerDynLibraryCallback(BPatchDynLibraryCallback function)\n{\n    BPatchDynLibraryCallback previous = dynLibraryCallback;\n    dynLibraryCallback = function;\n    return previous;\n}\n\n/*\n * BPatch::getEnglishErrorString\n *\n * Returns the descriptive error string for the passed error number.\n *\n * number\tThe number that identifies the error.\n */\nconst char *BPatch::getEnglishErrorString(int /* number */)\n{\n    return \"%s\";\n}\n\n\n/*\n * BPatch::reportError\n *\n * Report an error using the callback mechanism.\n *\n * severity\tThe severity level of the error.\n * number\tIdentifies the error.\n * str\t\tA string to pass as the first element of the list of strings\n *\t\tgiven to the callback function.\n */\nvoid BPatch::reportError(BPatchErrorLevel severity, int number, const char *str)\n{\n   if (bpatch == NULL) {\n      return; //Probably decontructing objects.\n   }\n\n\n    // don't log BPatchWarning or BPatchInfo messages as \"errors\"\n    if ((severity == BPatchFatal) || (severity == BPatchSerious))\n        bpatch->lastError = number;\n\n    if( !BPatch::bpatch->errorCallback ) { \n        fprintf(stdout, \"%s[%d]:  DYNINST ERROR:\\n %s\\n\", FILE__, __LINE__, str);\n        fflush(stdout);\n        return; \n    }\n\n    BPatch::bpatch->errorCallback(severity, number, &str);\n    \n}\n\n\n/*\n * BPatch::formatErrorString\n *\n * Takes a format string with an error message (obtained from\n * getEnglishErrorString) and an array of parameters that were passed to an\n * error callback function, and creates a string with the parameters\n * substituted into it.\n *\n * dst\t\tThe address into which the formatted string should be copied.\n * size\t\tIf the formatted string is equal to or longer than this number\n * \t\tof characters, then it will be truncated to size-1 characters\n * \t\tand terminated with a nul ('\\0').\n * fmt\t\tThe format string (returned by a function such as\n *\t\tgetEnglishErrorString).\n * params\tThe array of parameters that were passed to an error callback\n *\t\tfunction.\n */\nvoid BPatch::formatErrorString(char *dst, int size,\n\t\t\t       const char *fmt, const char * const *params)\n{\n    int cur_param = 0;\n\n    while (size > 1 && *fmt) {\n\tif (*fmt == '%') {\n\t    if (fmt[1] == '\\0') {\n\t\tbreak;\n\t    } else if (fmt[1] == '%') {\n\t\t*dst++ = '%';\n\t\tsize--;\n\t    } else if (fmt[1] == 's') {\n\t\tchar *p = const_cast<char *>(params[cur_param++]);\n\t\twhile (size > 1 && *p) {\n\t\t    *dst++ = *p++;\n\t\t    size--;\n\t\t}\n\t    } else {\n\t\t// Illegal specifier\n\t\t*dst++ = fmt[0];\n\t\t*dst++ = fmt[1];\n\t\tsize -= 2;\n\t    }\n    \t    fmt += 2;\n\t} else {\n\t    *dst++ = *fmt++;\n\t    size--;\n\t}\n    }\n    if (size > 0)\n\t*dst = '\\0';\n}\n\nstatic const char *lvl_str(BPatchErrorLevel lvl)\n{\n  switch(lvl) {\n    case BPatchFatal: return \"--FATAL--\";\n    case BPatchSerious: return \"--SERIOUS--\";\n    case BPatchWarning: return \"--WARN--\";\n    case BPatchInfo: return \"--INFO--\";\n  };\n  return \"BAD ERR CODE\";\n}\n\nvoid defaultErrorFunc(BPatchErrorLevel level, int num, const char * const *params)\n{\n    char line[256];\n\n    if ((level == BPatchWarning) || (level == BPatchInfo)) {\n         // ignore low level errors/warnings in the default reporter\n         return;\n    }\n\n    const char *msg = BPatch::bpatch->getEnglishErrorString(num);\n    BPatch::bpatch->formatErrorString(line, sizeof(line), msg, params);\n\n    if (num != -1) {\n       fprintf(stderr,\"%s #%d: %s\\n\", lvl_str(level),num, line);\n    }\n}\n\n\n/*\n * BPatch::getThreadByPid\n *\n * Given a process ID, this function returns a pointer to the associated\n * BPatch_thread object (or NULL if there is none).  Since a process may be\n * registered provisionally with a thread object pointer of NULL, the boolean\n * pointed to by the parameter \"exists\" is set to true if the pid exists in\n * the table of processes, and false if it does not.\n *\n * pid\t\tThe pid to look up.\n * exists\tA pointer to a boolean to fill in with true if the pid exists\n *\t\tin the table and false if it does not.  NULL may be passed in\n *\t\tif this information is not required.\n */\nBPatch_process *BPatch::getProcessByPid(int pid, bool *exists)\n{\n   auto iter = info->procsByPid.find(pid);\n   if (iter != info->procsByPid.end()) {\n      if (exists) *exists = true;\n      BPatch_process *proc = iter->second;\n      return proc;\n    } else {\n      if (exists) *exists = false;\n      return NULL;\n   }\n}\n\nBPatch_thread *BPatch::getThreadByPid(int pid, bool *exists)\n{\n   BPatch_process *p = getProcessByPid(pid, exists);\n   if (!exists)\n      return NULL;\n   assert(p->threads.size() > 0);\n   return p->threads[0];\n}\n\n\n\n/*\n * BPatch::getProcs\n *\n * Returns a vector of all threads that are currently defined.  Includes\n * threads created directly using the library and those created with UNIX fork\n * or Windows NT spawn system calls.  The caller is responsible for deleting\n * the vector when it is no longer needed.\n */\nBPatch_Vector<BPatch_process *> *BPatch::getProcesses()\n{\n   BPatch_Vector<BPatch_process *> *result = new BPatch_Vector<BPatch_process *>;\n   for (auto iter = info->procsByPid.begin(); iter != info->procsByPid.end(); ++iter) {\n      result->push_back(iter->second);\n   }\n   \n   return result;\n}\n\n\n/*\n * BPatch::registerProvisionalThread\n *\n * Register a new process that is not yet associated with a thread.\n * (this function is called only by createProcess).\n *\n * pid\t\tThe pid of the process to register.\n */\nvoid BPatch::registerProvisionalThread(int pid)\n{\n   assert(info->procsByPid.find(pid) == info->procsByPid.end());\n   info->procsByPid[pid] = NULL;\n}\n\n\n/*\n * BPatch::registerForkedProcess\n *\n * Register a new process that is not yet associated with a thread.\n * (this function is an upcall when a new process is created).\n *\n * parentPid\t\tthe pid of the parent process.\n * childPid\t\tThe pid of the process to register.\n * proc\t\t\tlower lever handle to process specific stuff\n *\n */\nvoid BPatch::registerForkedProcess(PCProcess *parentProc, PCProcess *childProc)\n{\n    int parentPid = parentProc->getPid();\n    int childPid = childProc->getPid();\n\n    proccontrol_printf(\"BPatch: registering fork, parent %d, child %d\\n\",\n                    parentPid, childPid);\n    assert(getProcessByPid(childPid) == NULL);\n    \n    BPatch_process *parent = getProcessByPid(parentPid);\n    assert(parent);\n\n    BPatch_process *child = new BPatch_process(childProc);\n    child->triggerInitialThreadEvents();\n\n    if( postForkCallback ) {\n        postForkCallback(parent->threads[0], child->threads[0]);\n    }\n    \n    proccontrol_printf(\"BPatch: finished registering fork, parent %d, child %d\\n\",\n                    parentPid, childPid);\n}\n\n/*\n * BPatch::registerForkingThread\n *\n * Perform whatever processing is necessary when a thread enters\n * a fork system call. Previously the preForkCallback was made directly.\n *\n * forkingPid   pid of the forking process\n * proc\t\t\tlower lever handle to process specific stuff\n *\n */\nvoid BPatch::registerForkingProcess(int forkingPid, PCProcess * /*proc*/)\n{\n    BPatch_process *forking = getProcessByPid(forkingPid);\n    assert(forking);\n\n    if( preForkCallback ) {\n        preForkCallback(forking->threads[0], NULL);\n    }\n}\n\n\n/*\n * BPatch::registerExecCleanup\n *\n * Register a process that has just entered exec\n *\n * Gives us some cleanup time\n */\n\nvoid BPatch::registerExecCleanup(PCProcess *p, char *) \n{\n    BPatch_process *execing = getProcessByPid(p->getPid());\n    assert(execing);\n\n    for (unsigned i=0; i<execing->threads.size(); i++)\n       registerThreadExit(p, execing->threads[i]->llthread);\n\n}    \n\n/*\n * BPatch::registerExecExit\n *\n * Register a process that has just done an exec call.\n *\n * proc - the representation of the process after the exec\n */\nvoid BPatch::registerExecExit(PCProcess *proc) {\n    int execPid = proc->getPid();\n    BPatch_process *process = getProcessByPid(execPid);\n    assert(process);\n\n    assert( process->threads.size() <= 1 );\n\n    // There is a new underlying process representation\n    process->llproc = proc;\n    PCThread *thr = proc->getInitialThread();\n\n    // Create a new initial thread or update it\n    BPatch_thread *initialThread;\n    if( process->threads.size() == 0 ) { \n        initialThread = new BPatch_thread(process, thr);\n        process->threads.push_back(initialThread);\n    }else{\n        initialThread = process->getThreadByIndex(0);\n        initialThread->updateThread(thr);\n    }\n\n    // build a new BPatch_image for this one\n    if (process->image)\n        process->image->removeAllModules();\n\n    BPatch_image *oldImage = process->image;\n    process->image = new BPatch_image(process);\n    if( oldImage ) delete oldImage;\n\n    assert( proc->isBootstrapped() );\n\n    // ProcControlAPI doesn't deliver callbacks for the initial thread,\n    // even if the mutatee is multithread capable\n    if( proc->multithread_capable() ) {\n        registerThreadCreate(process, initialThread);\n    }\n\n    if( execCallback ) {\n        execCallback(process->threads[0]);\n    }\n}\n\nvoid BPatch::registerNormalExit(PCProcess *proc, int exitcode)\n{\n   if (!proc)\n      return;\n\n\n   int pid = proc->getPid();\n\n   BPatch_process *process = getProcessByPid(pid);\n\n   if (!process) return;\n\n   process->terminated = true;\n\n\n   BPatch_thread *thrd = process->getThreadByIndex(0);\n\n   process->setExitCode(exitcode);\n   process->setExitedNormally();\n\n   if (thrd) {\n\t   if( threadDestroyCallback && !thrd->madeExitCallback() ) {\n          threadDestroyCallback(process, thrd);\n      }\n   }\n\n   if( exitCallback ) {\n       exitCallback(process->threads[0], ExitedNormally);\n   }\n\n   // We now run the process out; set its state to terminated. Really, the user shouldn't\n   // try to do anything else with this, but we can get that happening.\n   BPatch_process *stillAround = getProcessByPid(pid);\n   if (stillAround) {\n      stillAround->reportedExit = true;\n      stillAround->terminated = true;\n   }\n}\n\nvoid BPatch::registerSignalExit(PCProcess *proc, int signalnum)\n{\n   if (!proc)\n      return;\n\n   int pid = proc->getPid();\n\n   BPatch_process *bpprocess = getProcessByPid(pid);\n   if (!bpprocess) {\n       // Error during startup can cause this -- we have a partially\n       // constructed process object, but it was never registered with\n       // bpatch\n       return;\n   }\n   BPatch_thread *thrd = bpprocess->getThreadByIndex(0);\n\n   bpprocess->setExitedViaSignal(signalnum);\n   bpprocess->terminated = true;\n\n   if (thrd) {\n\t   if( threadDestroyCallback && !thrd->madeExitCallback() ) {\n          threadDestroyCallback(bpprocess, thrd);\n      }\n      if( exitCallback ) {\n          exitCallback(bpprocess->threads[0], ExitedViaSignal);\n      }\n   }\n   \n   // We now run the process out; set its state to terminated. Really, the user shouldn't\n   // try to do anything else with this, but we can get that happening.\n   BPatch_process *stillAround = getProcessByPid(pid);\n   if (stillAround) {\n      stillAround->reportedExit = true;\n      stillAround->terminated = true;\n   }\n\n   // We need to clean this up... but the user still has pointers\n   // into this code. Ugh.\n   // Do not continue at this point; process is already gone.\n\n}\n\nbool BPatch::registerThreadCreate(BPatch_process *proc, BPatch_thread *newthr)\n{\n   if( threadCreateCallback ) {\n       threadCreateCallback(proc, newthr);\n   }\n\n   return true;\n}\n\nvoid BPatch::registerThreadExit(PCProcess *llproc, PCThread *llthread)\n{\n    assert( llproc && llthread );\n    \n    BPatch_process *bpprocess = getProcessByPid(llproc->getPid());\n    \n    if (!bpprocess) {\n        // Error during startup can cause this -- we have a partially\n        // constructed process object, but it was never registered with\n        // bpatch\n        return;\n    }\n\n    BPatch_thread *thrd = bpprocess->getThread(llthread->getTid());\n    if (!thrd) {\n        //If we don't have an BPatch thread, then it might have been an internal\n        // thread that we decided not to report to the user (happens during \n        //  windows attach).  Just trigger the lower level clean up in this case.\n        llproc->removeThread(llthread->getTid());\n        return;\n    }\n\n\tif (thrd->madeExitCallback()) return;\n\n    if( threadDestroyCallback ) {\n        threadDestroyCallback(bpprocess, thrd);\n    }\n\n\tthrd->setMadeExitCallback();\n    bpprocess->deleteBPThread(thrd);\n}\n\n\nvoid BPatch::registerUserEvent(BPatch_process *process, void *buffer,\n                       unsigned int bufsize)\n{\n    for(unsigned i = 0; i < userEventCallbacks.size(); ++i) {\n        (userEventCallbacks[i])(process, buffer, bufsize);\n    }\n}\n\nvoid BPatch::registerDynamicCallsiteEvent(BPatch_process *process, Address callTarget,\n                       Address callAddr)\n{\n    // find the point that triggered the event\n\n    proccontrol_printf(\"%s[%d]: dynamic call event from 0x%lx to 0x%lx\\n\",\n            FILE__, __LINE__, callAddr, callTarget);\n    BPatch_point *point = info->getMonitoredPoint(callAddr);\n    if ( point == NULL ) {\n        proccontrol_printf(\"%s[%d]: failed to find point for dynamic callsite event\\n\",\n                FILE__, __LINE__);\n        return;\n    }\n\n    func_instance *targetFunc = process->llproc->findOneFuncByAddr(callTarget);\n    if( targetFunc == NULL ) {\n        proccontrol_printf(\"%s[%d]: failed to find dynamic call target function\\n\",\n                FILE__, __LINE__);\n        return;\n    }\n\n    BPatch_function *bpatchTargetFunc = process->findOrCreateBPFunc(targetFunc, NULL);\n    if( bpatchTargetFunc == NULL ) {\n        proccontrol_printf(\"%s[%d]: failed to find BPatch target function\\n\",\n                FILE__, __LINE__);\n        return;\n    }\n\n    if( dynamicCallSiteCallback ) {\n        dynamicCallSiteCallback(point, bpatchTargetFunc);\n    }\n}\n\n/*\n * BPatch::registerLoadedModule\n *\n * Register a new module loaded by a process (e.g., dlopen)\n */\n\nvoid BPatch::registerLoadedModule(PCProcess *process, mapped_module *mod) {\n\n    BPatch_process *bProc = BPatch::bpatch->getProcessByPid(process->getPid());\n    if (!bProc) return; // Done\n\n    // Squash this notification if the PCProcess has changed (e.g. during exec)\n    if (bProc->llproc != process) return;\n\n    BPatch_image *bImage = bProc->getImage();\n    assert(bImage); // This we can assert to be true\n    \n    BPatch_module *bpmod = bImage->findOrCreateModule(mod);\n\n    if( dynLibraryCallback ) {\n        dynLibraryCallback(bProc->threads[0], bpmod, true);\n    }\n}\n\n/*\n * BPatch::registerUnloadedModule\n *\n * Register a new module loaded by a process (e.g., dlopen)\n */\n\nvoid BPatch::registerUnloadedModule(PCProcess *process, mapped_module *mod) {\n\n    BPatch_process *bProc = BPatch::bpatch->getProcessByPid(process->getPid());\n    if (!bProc) return; // Done\n\n    // Squash this notification if the PCProcess has changed (e.g. during exec)\n    if (bProc->llproc != process) return;\n\n    BPatch_image *bImage = bProc->getImage();\n    if (!bImage) { // we got an event during process startup\n        return;\n    }\n    \n    BPatch_module *bpmod = bImage->findModule(mod);\n    if (bpmod == NULL) return;\n\n    \n    // For now we use the same callback for load and unload of library....\n    if( dynLibraryCallback ) {\n        dynLibraryCallback(bProc->threads[0], bpmod, false);\n    }\n\n    bImage->removeModule(bpmod);\n}\n\n\n/*\n * BPatch::registerProcess\n *\n * Register a new BPatch_process object with the BPatch library (this function\n * is called only by the constructor for BPatch_process).\n *\n * process\tA pointer to the process to register.\n */ \nvoid BPatch::registerProcess(BPatch_process *process, int pid)\n{\n   if (!pid)\n      pid = process->getPid();\n\n   assert(info->procsByPid.find(pid) == info->procsByPid.end());\n   info->procsByPid[pid] = process;\n}\n\n\n/*\n * BPatch::unRegisterProcess\n *\n * Remove the BPatch_thread associated with a given pid from the list of\n * threads being managed by the library.\n *\n * pid\t\tThe pid of the thread to be removed.\n */\nvoid BPatch::unRegisterProcess(int pid, BPatch_process *proc)\n{\n   // DO NOT CHANGE THE MAP!\n   if (inDestructor) return;\n\n   if (pid == -1 || (info->procsByPid.find(pid) == info->procsByPid.end())) {\n      // Deleting an exited process; search and nuke\n      for (auto iter = info->procsByPid.begin(); iter != info->procsByPid.end(); ++iter) {\n         if (iter->second == proc) {\n            info->procsByPid.erase(iter);\n            return;\n         }\n      }\n      if (pid != -1) {\n         char ebuf[256];\n         sprintf(ebuf, \"%s[%d]: no process %d defined in procsByPid\\n\", FILE__, __LINE__, pid);\n         reportError(BPatchFatal, 68, ebuf);\n         return;\n      }\n   }\n   info->procsByPid.erase(pid);\n}\n\nstatic void buildPath(const char *path, const char **argv,\n                      char * &pathToUse,\n                      char ** &argvToUse) {\n   ifstream file;\n   file.open(path);\n   if (!file.is_open()) return;\n   std::string line;\n   getline(file, line);\n   if (line.compare(0, 2, \"#!\") != 0) {\n      file.close();\n      return;\n   }\n\n   // A shell script, so reinterpret path/argv\n\n   // Modeled after Linux's fs/binfmt_script.c\n   // #! lines have the interpreter and optionally a single argument,\n   // all separated by spaces and/or tabs.\n\n   size_t pos_start = line.find_first_not_of(\" \\t\", 2);\n   if (pos_start == std::string::npos) {\n      file.close();\n      return;\n   }\n   size_t pos_end = line.find_first_of(\" \\t\", pos_start);\n   std::string interp = line.substr(pos_start, pos_end - pos_start);\n   pathToUse = strdup(interp.c_str());\n\n   std::string interp_arg;\n   pos_start = line.find_first_not_of(\" \\t\", pos_end);\n   if (pos_start != std::string::npos) {\n      // The argument goes all the way to the last non-space/tab,\n      // even if there are spaces/tabs in the middle somewhere.\n      pos_end = line.find_last_not_of(\" \\t\") + 1;\n      interp_arg = line.substr(pos_start, pos_end - pos_start);\n   }\n\n   // Count the old and new argc values\n   int argc = 0;\n   while(argv[argc] != NULL) {\n      argc++;\n   }\n   int argcToUse = argc + 1;\n   if (!interp_arg.empty()) {\n      argcToUse++;\n   }\n   argvToUse = (char **) malloc((argcToUse+1) * sizeof(char *));\n\n   // The interpreter takes the new argv[0]\n   int argi = 0;\n   argvToUse[argi++] = strdup(pathToUse);\n\n   // If there's an interpreter argument, that's the new argv[1]\n   if (!interp_arg.empty()) {\n      argvToUse[argi++] = strdup(interp_arg.c_str());\n   }\n\n   // Then comes path, *replacing* the old argv[0],\n   // and the old argv[1..] are filled in for the rest\n   argvToUse[argi++] = strdup(path);\n   for (int tmp = 1; tmp < argc; ++tmp) {\n      argvToUse[argi++] = strdup(argv[tmp]);\n   }\n   argvToUse[argcToUse] = NULL;\n   file.close();\n}\n\n/*\n * BPatch::processCreate\n *\n * Create a process and return a BPatch_process representing it.\n * Returns NULL upon failure.\n *\n * path\t\tThe pathname of the executable for the new process.\n * argv\t\tA list of the arguments for the new process, terminated by a\n *\t\tNULL.\n * envp\t\tA list of values that make up the environment for the new\n *\t\tprocess, terminated by a NULL.  If envp is NULL, the new\n *\t\tnew process will inherit the environemnt of the parent.\n * stdin_fd\tfile descriptor to use for stdin for the application\n * stdout_fd\tfile descriptor to use for stdout for the application\n * stderr_fd\tfile descriptor to use for stderr for the application\n\n */\nBPatch_process *BPatch::processCreate(const char *path, const char *argv[], \n                                         const char **envp, int stdin_fd, \n                                         int stdout_fd, int stderr_fd,\n                                         BPatch_hybridMode mode)\n{\n   clearError();\n\n    if (!OS_isConnected()) {\n        reportError(BPatchFatal, 68, \"Attempted to create process before connected to target server\\n\");\n        return NULL;\n    }\n\n   if ( path == NULL ) { return NULL; }\n\n#if !defined (os_windows)\n   //  This might be ok on windows...  not 100% sure and it takes\n   //  to long to build for the moment.\n\n   //  just a sanity check for the exitence of <path>\n   struct stat statbuf;\n   if (-1 == stat(path, &statbuf)) {\n      char ebuf[2048];\n      sprintf(ebuf, \"createProcess(%s,...):  file does not exist\\n\", path);\n      reportError(BPatchFatal, 68, ebuf);\n      return NULL;\n   }\n\n   //  and ensure its a regular file:\n   if (!S_ISREG(statbuf.st_mode)) {\n      char ebuf[2048];\n      sprintf(ebuf, \"createProcess(%s,...):  not a regular file \\n\", path);\n      reportError(BPatchFatal, 68, ebuf);\n      return NULL;\n   }\n\n#if !defined(os_vxworks) // Not necessary for VxWorks modules\n\n   //  and ensure its executable (does not check permissions):\n   if (! ( (statbuf.st_mode & S_IXUSR)\n            || (statbuf.st_mode & S_IXGRP)\n            || (statbuf.st_mode & S_IXOTH) )) {\n      char ebuf[2048];\n      sprintf(ebuf, \"createProcess(%s,...):  not an executable  \\n\", path);\n      reportError(BPatchFatal, 68, ebuf);\n      return NULL;\n   }\n\n#endif // !VxWorks\n#endif // !Windows\n\n   // User request: work on scripts by creating the interpreter instead\n   char *pathToUse = NULL;\n   char **argvToUse = NULL;\n\n   buildPath(path, argv, pathToUse, argvToUse);\n\n   BPatch_process *ret = \n      new BPatch_process((pathToUse ? pathToUse : path), \n                         (argvToUse ? (const_cast<const char **>(argvToUse)) : argv), \n                         mode, envp, stdin_fd,stdout_fd,stderr_fd);\n   \n   if (pathToUse) free(pathToUse);\n   if (argvToUse) {\n\n      int tmp = 0;\n      while(argvToUse[tmp] != NULL) {\n         free(argvToUse[tmp]);\n         tmp++;\n      }\n      free(argvToUse);\n   }\n\n   if (!ret->llproc \n         ||  !ret->llproc->isStopped()\n         ||  !ret->llproc->isBootstrapped()) {\n      delete ret;\n      reportError(BPatchFatal, 68, \"create process failed bootstrap\");\n      return NULL;\n   }\n\n   ret->triggerInitialThreadEvents();\n\n   if (ret->lowlevel_process()->isExploratoryModeOn()) {\n       ret->getHybridAnalysis()->init();\n   }\n\n   return ret;\n}\n\n\n/*\n * BPatch::processAttach\n *\n * Attach to a running process and return a BPatch_thread representing it.\n * Returns NULL upon failure.\n *\n * path\t\tThe pathname of the executable for the process.\n * pid\t\tThe id of the process to attach to.\n */\nBPatch_process *BPatch::processAttach\n(const char *path, int pid, BPatch_hybridMode mode)\n{\n   clearError();\n\n    if (!OS_isConnected()) {\n        reportError(BPatchFatal, 68, \"Error: Attempted to attach to process before connected to target server.\");\n        return NULL;\n    }\n\n    if (info->procsByPid.find(pid) != info->procsByPid.end()) {\n      char msg[256];\n      sprintf(msg, \"attachProcess failed.  Dyninst is already attached to %d.\",\n              pid);\n      reportError(BPatchWarning, 26, msg);      \n      return NULL;\n   }\n\n   BPatch_process *ret = new BPatch_process(path, pid, mode);\n\n   if (!ret->llproc ||\n       !ret->llproc->isStopped() ||\n       !ret->llproc->isBootstrapped()) {\n       char msg[256];\n       sprintf(msg,\"attachProcess failed: process %d may now be killed!\",pid);\n       reportError(BPatchWarning, 26, msg);\n\t   \n\t   delete ret;\n       return NULL;\n   }\n\n   ret->triggerInitialThreadEvents();\n\n   if (ret->lowlevel_process()->isExploratoryModeOn()) {\n       ret->getHybridAnalysis()->init();\n   }\n\n   return ret;\n}\n\nstatic bool recursiveEventHandling = false;\n\n/*\n * pollForStatusChange\n *\n * Checks for unreported changes to the status of any child process, and\n * returns true if any are detected.  Returns false otherwise.\n *\n * This function is declared as a friend of BPatch_thread so that it can use\n * the BPatch_thread::getThreadEvent call to check for status changes.\n */\nbool BPatch::pollForStatusChange()\n{\n    // Sanity check: don't allow waiting for events in the callbacks\n    if( recursiveEventHandling ) {\n        BPatch_reportError(BPatchWarning, 0,\n                \"Cannot wait for events in a callback\");\n        return false;\n    }\n\n    proccontrol_printf(\"[%s:%u] Polling for events\\n\", FILE__, __LINE__);\n\n    recursiveEventHandling = true;\n    PCEventMuxer::WaitResult result = PCEventMuxer::wait(false);\n    recursiveEventHandling = false;\n\n    if( result == PCEventMuxer::Error ) {\n        proccontrol_printf(\"[%s:%u] Failed to poll for events\\n\",\n                FILE__, __LINE__);\n        BPatch_reportError(BPatchWarning, 0, \n                \"Failed to handle events and deliver callbacks\");\n        return false;\n    }\n\n\n    if( result == PCEventMuxer::EventsReceived ) {\n        proccontrol_printf(\"[%s:%u] Events received\\n\", FILE__, __LINE__);\n        return true;\n    }\n  \n    proccontrol_printf(\"[%s:%u] No events available\\n\", FILE__, __LINE__);\n    return false;\n}\n\n/*\n * waitForStatusChange\n *\n * Blocks waiting for a change to occur in the running status of a child\n * process.  Returns true upon success, false upon failure.\n */\nbool BPatch::waitForStatusChange() {\n    // Sanity check: don't allow waiting for events in the callbacks\n    if( recursiveEventHandling ) {\n        BPatch_reportError(BPatchWarning, 0,\n                \"Cannot wait for events in a callback\");\n        return false;\n    }\n\n    // Sanity check: make sure there are processes running that could\n    // cause events to occur, otherwise the user will be waiting indefinitely\n    bool processRunning = false;\n    for(auto i = info->procsByPid.begin(); i != info->procsByPid.end(); ++i) \n    {\n       if( !i->second->isStopped() ) {\n          processRunning = true;\n          break;\n       }\n    }\n\n    if( !processRunning ) {\n        BPatch_reportError(BPatchWarning, 0,\n                \"No processes running, not waiting for events\");\n\t\treturn false;\n    }\n\n    proccontrol_printf(\"%s:[%d] Waiting for events\\n\", FILE__, __LINE__);\n\n    recursiveEventHandling = true;\n    PCEventMuxer::WaitResult result = PCEventMuxer::wait(true);\n    recursiveEventHandling = false;\n\n    if( result == PCEventMuxer::Error ) {\n        proccontrol_printf(\"%s:[%d] Failed to wait for events\\n\",\n                      FILE__, __LINE__);\n        BPatch_reportError(BPatchWarning, 0,\n\t\t\t\t\t\t\t\"Failed to handle events and deliver callbacks\");\n\t\treturn false;\n    }\n\n\n    if( result == PCEventMuxer::EventsReceived ) {\n        proccontrol_printf(\"%s:[%d] Events received in waitForStatusChange\\n\", FILE__, __LINE__);\n        return true;\n    }\n    else {\n        proccontrol_printf(\"%s:[%d] No events received in waitForStatusChange\\n\", FILE__, __LINE__);\n        return true;\n    }\n    //  we waited for a change, but didn't get it\n    proccontrol_printf(\"%s[%d]:  Error in status change reporting\\n\", FILE__, __LINE__);\n\treturn false;\n}\n\n/*\n * createEnum\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\nBPatch_type * BPatch::createEnum( const char * name, \n\t\t\t\t     BPatch_Vector<char *> &elementNames,\n\t\t\t\t     BPatch_Vector<int> &elementIds)\n{\n    if (elementNames.size() != elementIds.size()) {\n      return NULL;\n    }\n    string typeName = name;\n    vector<pair<string, int> *>elements;\n    for (unsigned int i=0; i < elementNames.size(); i++) \n        elements.push_back(new pair<string, int>(elementNames[i], elementIds[i]));\n    \n    Type *typ = typeEnum::create( typeName, elements);\n    if (!typ) return NULL;\n    \n    BPatch_type *newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n    \n    APITypes->addType(newType);\n\n    return(newType);\n}\n\n\n/*\n * createEnum\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.  The user has left element id specification to us\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\nBPatch_type * BPatch::createEnum( const char * name, \n\t\t\t\t        BPatch_Vector<char *> &elementNames)\n{\n    string typeName = name;\n    vector<pair<string, int> *>elements;\n    for (unsigned int i=0; i < elementNames.size(); i++) \n        elements.push_back(new pair<string, int>(elementNames[i], i));\n    \n    Type *typ = typeEnum::create( typeName, elements);\n    if (!typ) return NULL;\n    \n    BPatch_type *newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n    \n    APITypes->addType(newType);\n\n    return(newType);\n}\n\n/*\n * createStructs\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\n\nBPatch_type * BPatch::createStruct( const char * name,\n\t\t\t\t       BPatch_Vector<char *> &fieldNames,\n\t\t\t\t       BPatch_Vector<BPatch_type *> &fieldTypes)\n{\n   unsigned int i;\n   \n   if (fieldNames.size() != fieldTypes.size()) {\n      return NULL;\n   }\n   \n   string typeName = name;\n   vector<pair<string, Type *> *> fields;\n   for(i=0; i<fieldNames.size(); i++)\n   {\n      if(!fieldTypes[i])\n         return NULL;\n      fields.push_back(new pair<string, Type *> (fieldNames[i], fieldTypes[i]->getSymtabType()));\n   }\t\n   \n   Type *typ = typeStruct::create(typeName, fields);\n   if (!typ) return NULL;\n   \n   BPatch_type *newType = new BPatch_type(typ);\n   if (!newType) return NULL;\n   \n   APITypes->addType(newType);\n   \n   return(newType);\n}\n\n/*\n * createUnions\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\n\nBPatch_type * BPatch::createUnion( const char * name, \n\t\t\t\t      BPatch_Vector<char *> &fieldNames,\n\t\t\t\t      BPatch_Vector<BPatch_type *> &fieldTypes)\n{\n    unsigned int i;\n    \n    if (fieldNames.size() != fieldTypes.size()) {\n      return NULL;\n    }\n\n    string typeName = name;\n    vector<pair<string, Type *> *> fields;\n    for(i=0; i<fieldNames.size(); i++)\n    {\n        if(!fieldTypes[i])\n\t    return NULL;\n        fields.push_back(new pair<string, Type *> (fieldNames[i], fieldTypes[i]->getSymtabType()));\n    }\t\n    \n    Type *typ = typeUnion::create(typeName, fields);\n    if (!typ) return NULL;\n    \n    BPatch_type *newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n\n    APITypes->addType(newType);\n\n    return(newType);\n}    \n\n/*\n * createArray for Arrays and SymTypeRanges\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\nBPatch_type * BPatch::createArray( const char * name, BPatch_type * ptr,\n\t\t\t\t      unsigned int low, unsigned int hi)\n{\n\n    BPatch_type * newType;\n    if (!ptr) \n        return NULL;\n        \n    string typeName = name;\n    Type *typ = typeArray::create(typeName, ptr->getSymtabType(), low, hi);\n    if (!typ) return NULL;\n    \n    newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n\n    APITypes->addType(newType);\n    return newType;\n}\n\n/*\n * createPointer for BPatch_pointers\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\nBPatch_type * BPatch::createPointer(const char * name, BPatch_type * ptr,\n                                       int /*size*/)\n{\n    BPatch_type * newType;\n    if(!ptr)\n        return NULL;\n    \n    string typeName = name;\n    Type *typ = typePointer::create(typeName, ptr->getSymtabType());\n    if (!typ) return NULL;\n    \n    newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n\n    APITypes->addType(newType);\n    return newType;\n}\n\n/*\n * createScalar for scalars with a size and no range\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\n\nBPatch_type * BPatch::createScalar( const char * name, int size)\n{\n    BPatch_type * newType;\n    \n    string typeName = name;\n    Type *typ = typeScalar::create(typeName, size);\n    if (!typ) return NULL;\n    \n    newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n\n    APITypes->addType(newType);\n    return newType;\n}\n\n/*\n * createType for typedefs\n *\n * This function is a wrapper for the BPatch_type constructors for API/User\n * created types.\n *\n * It returns a pointer to a BPatch_type that was added to the APITypes\n * collection.\n */\nBPatch_type * BPatch::createTypedef( const char * name, BPatch_type * ptr)\n{\n    BPatch_type * newType;\n    if(!ptr)\n        return NULL;\n    \n    string typeName = name;\n    Type *typ = typeTypedef::create(typeName, ptr->getSymtabType());\n    if (!typ) return NULL;\n    \n    newType = new BPatch_type(typ);\n    if (!newType) return NULL;\n\n    APITypes->addType(newType);\n    return newType;\n}\n\nbool BPatch::waitUntilStopped(BPatch_thread *appThread){\n\n   bool ret = false;\n\n   while (1) {\n     if (!appThread->getProcess()->isStopped() && !appThread->getProcess()->isTerminated()) {\n       this->waitForStatusChange();\n     }\n     else {\n       break;\n     }\n   }\n\n   if (!appThread->getProcess()->isStopped())\n\t{\n\t\tcerr << \"ERROR : process did not signal mutator via stop\"\n\t\t     << endl;\n\t\tret = false;\n \t\tgoto done;\n\t}\n#if defined(os_windows)\n\telse if((appThread->getProcess()->stopSignal() != EXCEPTION_BREAKPOINT) && \n\t\t(appThread->getProcess()->stopSignal() != -1))\n\t{\n\t\tcerr << \"ERROR : process stopped on signal different\"\n\t\t     << \" than SIGTRAP\" << endl;\n\t\tret =  false;\n \t\tgoto done;\n\t}\n#else\n\telse if ((appThread->getProcess()->stopSignal() != SIGSTOP) &&\n\t\t (appThread->getProcess()->stopSignal() != SIGHUP)) {\n\t\tcerr << \"ERROR :  process stopped on signal \"\n\t\t     << \"different than SIGSTOP\" << endl;\n\t\tret =  false;\n \t\tgoto done;\n\t}\n#endif\n\n  done:\n  return ret;\n}\n\nBPatch_stats &BPatch::getBPatchStatistics()\n{\n  updateStats();\n  return stats;\n}\n//  updateStats() -- an internal function called before returning\n//  statistics buffer to caller of BPatch_getStatistics(),\n//  -- just copies global variable statistics counters into \n//  the buffer which is returned to the user.\nvoid BPatch::updateStats() \n{\n  stats.pointsUsed = pointsUsed.value();\n  stats.totalMiniTramps = totalMiniTramps.value();\n  stats.trampBytes = trampBytes.value();\n  stats.ptraceOtherOps = ptraceOtherOps.value();\n  stats.ptraceOps = ptraceOps.value();\n  stats.ptraceBytes = ptraceBytes.value();\n  stats.insnGenerated = insnGenerated.value();\n}\n\nbool BPatch::registerThreadEventCallback(BPatch_asyncEventType type,\n                                            BPatchAsyncThreadEventCallback func)\n{\n    switch(type) {\n        case BPatch_threadCreateEvent:\n            threadCreateCallback = func;\n            break;\n        case BPatch_threadDestroyEvent:\n            threadDestroyCallback = func;\n            break;\n        default:\n            bpwarn(\"Cannot register callback for non-thread event type %s\",\n                    asyncEventType2Str(type));\n            return false;\n    }\n\n    return true;\n}\n\nbool BPatch::removeThreadEventCallback(BPatch_asyncEventType type,\n                                          BPatchAsyncThreadEventCallback cb)\n{\n    bool result = false;\n    switch(type) {\n        case BPatch_threadCreateEvent:\n            if( cb == threadCreateCallback ) {\n                threadCreateCallback = NULL;\n                result = true;\n            }\n            break;\n        case BPatch_threadDestroyEvent:\n            if( cb == threadDestroyCallback ) {\n                threadDestroyCallback = NULL;\n                result = true;\n            }\n            break;\n        default:\n            bpwarn(\"Cannot remove callback for non-thread event type %s\",\n                    asyncEventType2Str(type));\n            return false;\n    }\n\n    return result;\n}\n\nbool BPatch::registerDynamicCallCallback(BPatchDynamicCallSiteCallback func)\n{\n    dynamicCallSiteCallback = func;\n    return true;\n}\n\nbool BPatch::removeDynamicCallCallback(BPatchDynamicCallSiteCallback func)\n{\n    if( dynamicCallSiteCallback == func ) {\n        dynamicCallSiteCallback = func;\n        return true;\n    }\n\n    return false;\n}\n\nbool BPatch::registerUserEventCallback(BPatchUserEventCallback func)\n{\n    userEventCallbacks.push_back(func);\n    return true;\n}\n\nbool BPatch::removeUserEventCallback(BPatchUserEventCallback cb)\n{\n    bool result = false;\n    BPatch_Vector<BPatchUserEventCallback> userCallbacks;\n    for(unsigned int i = 0; i < userEventCallbacks.size(); ++i) {\n        if( cb != userEventCallbacks[i] ) {\n            userCallbacks.push_back(userEventCallbacks[i]);\n        }else{\n            result = true;\n        }\n    }\n\n    userEventCallbacks = userCallbacks;\n\n    return result;\n}\n\nbool BPatch::registerCodeDiscoveryCallback(BPatchCodeDiscoveryCallback cb)\n{\n    std::vector<BPatch_process*> *procs = getProcesses();\n    for(unsigned i =0; i < procs->size(); i++) {\n        HybridAnalysis *hybrid = (*procs)[i]->getHybridAnalysis();\n        hybrid->registerCodeDiscoveryCallback(cb);\n    }\n    return true;\n}\n\nbool BPatch::removeCodeDiscoveryCallback(BPatchCodeDiscoveryCallback)\n{\n    std::vector<BPatch_process*> *procs = getProcesses();\n    for(unsigned i =0; i < procs->size(); i++) {\n        HybridAnalysis *hybrid = (*procs)[i]->getHybridAnalysis();\n        hybrid->removeCodeDiscoveryCallback();\n    }\n    return true;\n}\n\nbool BPatch::registerSignalHandlerCallback(BPatchSignalHandlerCallback bpatchCB, \n                                           std::set<long> &signums)\n{\n    signalHandlerCallback = HybridAnalysis::getSignalHandlerCB();\n    callbackSignals = signums;\n\n    std::vector<BPatch_process*> *procs = getProcesses();\n    for(unsigned i=0; i < procs->size(); i++) {\n        HybridAnalysis *hybrid = (*procs)[i]->getHybridAnalysis();\n        hybrid->registerSignalHandlerCallback(bpatchCB);\n    }\n    return true;\n}\n\nbool BPatch::registerSignalHandlerCallback(BPatchSignalHandlerCallback bpatchCB, \n                                           BPatch_Set<long> *signums) {\n   // This is unfortunate, but our method above takes a std::set<long>,\n   // not a std::set<long, comparison<long>>\n   \n   std::set<long> tmp;\n   if (NULL == signums || signums->empty())\n\t   tmp = std::set<long>();\n   else\n       std::copy(signums->begin(), signums->end(), std::inserter(tmp, tmp.end()));\n   \n   return registerSignalHandlerCallback(bpatchCB, tmp);\n}\n\nbool BPatch::removeSignalHandlerCallback(BPatchSignalHandlerCallback)\n{\n    signalHandlerCallback = NULL;\n    callbackSignals.clear();\n\n    std::vector<BPatch_process*> *procs = getProcesses();\n    for(unsigned i=0; i < procs->size(); i++) {\n        HybridAnalysis *hybrid = (*procs)[i]->getHybridAnalysis();\n        hybrid->removeSignalHandlerCallback();\n    }\n    return true;\n}\n\nbool BPatch::registerCodeOverwriteCallbacks\n    (BPatchCodeOverwriteBeginCallback cbBegin,\n     BPatchCodeOverwriteEndCallback cbEnd)\n{\n    codeOverwriteCallback = HybridAnalysisOW::getCodeOverwriteCB();\n\n    std::vector<BPatch_process*> *procs = getProcesses();\n    for(unsigned i=0; i < procs->size(); i++) {\n        HybridAnalysis *hybrid = (*procs)[i]->getHybridAnalysis();\n        hybrid->hybridOW()->registerCodeOverwriteCallbacks(cbBegin,cbEnd);\n    }\n    return true;\n}\n\nvoid BPatch::continueIfExists(int pid) \n{\n    BPatch_process *proc = getProcessByPid(pid);\n    if (!proc) return;\n\n    proc->continueExecution();\n}\n\n\nint BPatch::getNotificationFD() {\n#if !defined(os_windows)\n   return Dyninst::ProcControlAPI::evNotify()->getFD(); \n#else\n    return -1;\n#endif\n}\n\n/* If true, we return just filenames when the user asks for line info\n   otherwise, we return filename plus path information. */\nvoid BPatch::truncateLineInfoFilenames(bool newval) {\n   mapped_module::truncateLineFilenames = newval;\n}\n\nvoid BPatch::getBPatchVersion(int &major, int &minor, int &subminor) \n{\n   major = DYNINST_MAJOR;\n   minor = DYNINST_MINOR;\n   subminor = DYNINST_SUBMINOR;\n}\n\nBPatch_binaryEdit *BPatch::openBinary(const char *path, bool openDependencies /* = false */) {\n   BPatch_binaryEdit *editor = new BPatch_binaryEdit(path, openDependencies);\n   if (!editor)\n      return NULL;\n   if (editor->creation_error) {\n      delete editor;\n      return NULL;\n   }\n   return editor;\n}\n\nvoid BPatch::setInstrStackFrames(bool r)\n{\n   instrFrames = r;\n}\n\nbool BPatch::getInstrStackFrames()\n{\n   return instrFrames;\n}\n\nbool BPatch::isConnected()\n{\n    return OS_isConnected();\n}\n\n// -----------------------------------------------------------\n// Undocumented public remote debugging interface.\n// See comments in BPatch.h about the future of these methods.\nbool BPatch::remoteConnect(BPatch_remoteHost &remote)\n{\n    if (remote.type >= BPATCH_REMOTE_DEBUG_END) {\n        fprintf(stderr, \"Unknown remote debugging protocol %d\\n\", remote.type);\n        return false;\n    }\n\n    return OS_connect(remote);\n}\n\nbool BPatch::getPidList(BPatch_remoteHost &remote, BPatch_Vector<unsigned int> &pidlist)\n{\n    if (remote.type >= BPATCH_REMOTE_DEBUG_END) {\n        fprintf(stderr, \"Unknown remote debugging protocol %d\\n\", remote.type);\n        return false;\n    }\n\n    return OS_getPidList(remote, pidlist);\n}\n\nbool BPatch::getPidInfo(BPatch_remoteHost &remote, unsigned int pid,\n                           std::string &pidInfo)\n{\n    if (remote.type >= BPATCH_REMOTE_DEBUG_END) {\n        fprintf(stderr, \"Unknown remote debugging protocol %d\\n\", remote.type);\n        return false;\n    }\n\n    return OS_getPidInfo(remote, pid, pidInfo);\n}\n\nbool BPatch::remoteDisconnect(BPatch_remoteHost &remote)\n{\n    if (remote.type >= BPATCH_REMOTE_DEBUG_END) {\n        fprintf(stderr, \"Unknown remote debugging protocol %d\\n\", remote.type);\n        return false;\n    }\n\n    return OS_disconnect(remote);\n}\n// -----------------------------------------------------------\n\nvoid BPatch::addNonReturningFunc(std::string name)\n{\n  Dyninst::ParseAPI::SymtabCodeSource::addNonReturning(name);\n}\n\nint BPatch_libInfo::getStopThreadCallbackID(Address cb) {\n   auto iter = stopThreadCallbacks_.find(cb);\n   if (iter != stopThreadCallbacks_.end()) {\n      return iter->second;\n   }\n\n    int cb_id = ++stopThreadIDCounter_;\n    stopThreadCallbacks_[cb] = cb_id;\n    return cb_id;\n}\n\nbool BPatch_libInfo::registerMonitoredPoint(BPatch_point *point) {\n   if (monitoredPoints_.find((Address) point->getAddress()) != monitoredPoints_.end())\n      return false;\n\n    monitoredPoints_[(Address)point->getAddress()] = point;\n\n    proccontrol_printf(\"%s[%d]: monitoring address 0x%lx for dynamic calls\\n\",\n            FILE__, __LINE__, (unsigned long)point->getAddress());\n\n    return true;\n}\n\nBPatch_point *BPatch_libInfo::getMonitoredPoint(Address addr) {\n   auto iter = monitoredPoints_.find(addr);\n   if (iter == monitoredPoints_.end()) return NULL;\n   return iter->second;\n}\n\n// Functions for accessing stop thread callback state\nvoid BPatch::registerStopThreadCallback(BPatchStopThreadCallback stopCB) {\n    stopThreadCallbacks.push_back(stopCB);\n}\n\nint BPatch::getStopThreadCallbackID(BPatchStopThreadCallback stopCB) {\n    return info->getStopThreadCallbackID((Address)stopCB);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/mapped_object.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n// $Id: mapped_object.C,v 1.39 2008/09/03 06:08:44 jaw Exp $\n\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n#include \"dyninstAPI/src/mapped_object.h\"\n#include \"dyninstAPI/src/mapped_module.h\"\n#include \"dyninstAPI/src/image.h\"\n#include \"dyninstAPI/src/function.h\"\n#include \"dyninstAPI/h/BPatch_function.h\"\n#include \"dyninstAPI/src/debug.h\"\n#include \"dyninstAPI/src/addressSpace.h\"\n#include \"dyninstAPI/src/dynProcess.h\"\n#include \"symtabAPI/h/Symtab.h\"\n#include \"InstructionDecoder.h\"\n#include \"Parsing.h\"\n#include \"instPoint.h\"\n#include \"MemoryEmulator/memEmulator.h\"\n#include <boost/tuple/tuple.hpp>\n\n#include \"PatchCFG.h\"\n#include \"PCProcess.h\"\n\nusing namespace Dyninst;\nusing namespace Dyninst::ParseAPI;\nusing namespace Dyninst::ProcControlAPI;\n#if defined(os_windows)\n#define FS_FIELD_SEPERATOR '\\\\'\n#else\n#define FS_FIELD_SEPERATOR '/'\n#endif\n// Whee hasher...\n\n\n// triggered when parsing needs to check if the underlying data has changed\nbool codeBytesUpdateCB(void *objCB, Address targ)\n{\n    mapped_object *obj = (mapped_object*) objCB;\n    return obj->updateCodeBytesIfNeeded(targ);\n}\n\nmapped_object::mapped_object(fileDescriptor fileDesc,\n      image *img,\n      AddressSpace *proc,\n      BPatch_hybridMode mode):\n  DynObject(img->codeObject(), proc, fileDesc.code()),\n  desc_(fileDesc),\n  fullName_(img->getObject()->file()),\n  dirty_(false),\n  dirtyCalled_(false),\n  image_(img),\n  dlopenUsed(false),\n  proc_(proc),\n  analyzed_(false),\n  analysisMode_(mode),\n  pagesUpdated_(true),\n  codeByteUpdates_(0),\n  memEnd_(-1),\n  memoryImg_(false)\n{\n// Set occupied range (needs to be ranges)\n   dataBase_ = fileDesc.data();\n\n#if defined(os_linux)\n   // Handling for non-fPIE\n   if (codeBase_ == image_->imageOffset()) {\n      // Normal, non-PIE executable, so set the codeBase to 0. \n      codeBase_ = 0;\n      dataBase_ = 0;\n   }\n#endif\n   \n   startup_printf(\"[%s:%d] Creating new mapped_object %s/%s\\n\",\n                  FILE__, __LINE__, fullName_.c_str(), getFileDesc().member().c_str());\n   startup_printf(\"[%s:%d] \\tcodeBase 0x%lx, codeOffset 0x%lx, size %d\\n\",\n                  FILE__, __LINE__, codeBase_, image_->imageOffset(), image_->imageLength());\n   startup_printf(\"[%s:%d] \\tdataBase 0x%lx, dataOffset 0x%lx, size %d\\n\",\n                  FILE__, __LINE__, dataBase_, image_->dataOffset(), image_->dataLength());\n   startup_printf(\"[%s:%d] \\tfileDescriptor: code at 0x%lx, data 0x%lx\\n\",\n                  FILE__, __LINE__, fileDesc.code(), fileDesc.data());\n   startup_printf(\"[%s:%d] \\tCode: 0x%lx to 0x%lx\\n\",\n                  FILE__, __LINE__, codeAbs(), codeAbs() + imageSize());\n   startup_printf(\"[%s:%d] \\tData: 0x%lx to 0x%lx\\n\",\n                  FILE__, __LINE__, dataAbs(), dataAbs() + dataSize());\n   image_->getObject()->rebase(codeBase_);\n\n\n   // Sets \"fileName_\"\n   set_short_name();\n}\n\nmapped_object *mapped_object::createMappedObject(Library::const_ptr lib,\n                                                 AddressSpace *p,\n                                                 BPatch_hybridMode analysisMode,\n                                                 bool parseGaps) {\n   fileDescriptor desc(lib->getAbsoluteName(),\n                       lib->getLoadAddress(),\n                       p->usesDataLoadAddress() ? lib->getDataLoadAddress() : lib->getLoadAddress(),\n                       lib->isSharedLib());\n   return createMappedObject(desc, p, analysisMode, parseGaps);\n}\n   \n\nmapped_object *mapped_object::createMappedObject(fileDescriptor &desc,\n                                                 AddressSpace *p,\n                                                 BPatch_hybridMode analysisMode,\n                                                 bool parseGaps) {\n   if (!p) return NULL;\n   if ( BPatch_defensiveMode == analysisMode ) {\n       // parsing in the gaps in defensive mode is a bad idea because\n       // we mark all binary regions as possible code-containing areas\n       parseGaps = false;\n   }\n   assert(desc.file() != \"\");\n   startup_printf(\"%s[%d]:  about to parseImage\\n\", FILE__, __LINE__);\n   startup_printf(\"%s[%d]: name %s, codeBase 0x%lx, dataBase 0x%lx\\n\",\n                  FILE__, __LINE__, desc.file().c_str(), desc.code(), desc.data());\n   image *img = image::parseImage( desc, analysisMode, parseGaps);\n   if (!img)  {\n      startup_printf(\"%s[%d]:  failed to parseImage\\n\", FILE__, __LINE__);\n      return NULL;\n   }\n   if (img->isDyninstRTLib()) {\n       parseGaps = false;\n   }\n#if defined(os_linux) && defined(arch_x86_64)\n   //Our x86_64 is actually reporting negative load addresses.  Go fig.\n   // On Linux/x86_64 with 32-bit mutatees this causes problems because we\n   // treat the load address as a unsigned 64 bit integer, and things don't\n   // correctly wrap.\n   //\n   // We'll detect this by noticing that the dynamic entry doesn't match up\n   // and then correct.\n   if (desc.dynamic() &&\n       p->getAddressWidth() == 4 &&\n       img->getObject()->getElfDynamicOffset() + desc.code() != desc.dynamic()) {\n      Address new_load_addr;\n      new_load_addr = desc.dynamic() - img->getObject()->getElfDynamicOffset();\n      startup_printf(\"[%s:%u] - Incorrect binary load address %lx, changing \"\n              \"to %lx\\n\", FILE__, __LINE__, (unsigned long) desc.code(),\n              (unsigned long) new_load_addr);\n      desc.setCode(new_load_addr);\n      desc.setData(new_load_addr);\n   }\n#endif\n   if (!desc.isSharedObject()) {\n      //We've seen a case where the a.out is a shared object (RHEL4's\n      // version of ssh).  Check if the shared object flag is set in the\n      // binary (which is different from the isSharedObject()) call above.\n      // If so, we need to update the load address.\n      if (p->proc() &&\n          (img->getObject()->getObjectType() == SymtabAPI::obj_SharedLib)) {\n         //Executable is a shared lib\n         p->proc()->setAOutLoadAddress(desc);\n      }\n      \n// Used to search for main here and enable system call tracing to find out \n// when libc.so is loaded -- this is unnecessary now that we use ProcControlAPI\n//\n// This is now done on-demand when libc is loaded and main has yet to be found\n   }\n\n   // Adds exported functions and variables..\n   startup_printf(\"%s[%d]:  creating mapped object\\n\", FILE__, __LINE__);\n   mapped_object *obj = new mapped_object(desc, img, p, analysisMode);\n   if (BPatch_defensiveMode == analysisMode) {\n       img->register_codeBytesUpdateCB(obj);\n   }\n   startup_printf(\"%s[%d]:  leaving createMappedObject(%s)\\n\", FILE__, __LINE__, desc.file().c_str());\n\n  return obj;\n}\n\nmapped_object::mapped_object(const mapped_object *s, AddressSpace *child) :\n   codeRange(),\n   DynObject(s, child, s->codeBase_),\n   desc_(s->desc_),\n   fullName_(s->fullName_),\n   fileName_(s->fileName_),\n   dataBase_(s->dataBase_),\n   dirty_(s->dirty_),\n   dirtyCalled_(s->dirtyCalled_),\n   image_(s->image_),\n   dlopenUsed(s->dlopenUsed),\n   proc_(child),\n   analyzed_(s->analyzed_),\n   analysisMode_(s->analysisMode_),\n   pagesUpdated_(true),\n   codeByteUpdates_(0),\n   memEnd_(s->memEnd_),\n   memoryImg_(s->memoryImg_)\n{\n   // Let's do modules\n   for (unsigned k = 0; k < s->everyModule.size(); k++) {\n      // Doesn't copy things like line info. Ah, well.\n      mapped_module *parMod = s->everyModule[k];\n      mapped_module *mod = mapped_module::createMappedModule(this, parMod->pmod());\n      assert(mod);\n      everyModule.push_back(mod);\n   }\n\n   copyCFG(const_cast<mapped_object*>(s));\n\n   for (auto iter = s->everyUniqueVariable.begin();\n        iter != s->everyUniqueVariable.end(); ++iter) {\n      int_variable *parVar = iter->second;\n      assert(parVar->mod());\n      mapped_module *mod = getOrCreateForkedModule(parVar->mod());\n      int_variable *newVar = new int_variable(parVar,\n            mod);\n      addVariable(newVar);\n   }\n\n   assert(BPatch_defensiveMode != analysisMode_);\n\n   image_ = s->image_->clone();\n}\n\n\nmapped_object::~mapped_object()\n{\n   // desc_ is static\n   // fullName_ is static\n   // fileName_ is static\n   // codeBase_ is static\n   // dataBase_ is static\n\n   for (unsigned i = 0; i < everyModule.size(); i++)\n      delete everyModule[i];\n   everyModule.clear();\n\n   for (auto iter = everyUniqueVariable.begin();\n        iter != everyUniqueVariable.end(); ++iter) {\n      delete iter->second;\n   }\n   everyUniqueVariable.clear();\n\n   for (auto fm_iter = allFunctionsByMangledName.begin(); \n        fm_iter != allFunctionsByMangledName.end(); ++fm_iter) {\n      delete fm_iter->second;\n   }\n   allFunctionsByMangledName.clear();\n\n   for (auto fp_iter = allFunctionsByPrettyName.begin(); \n        fp_iter != allFunctionsByPrettyName.end(); ++fp_iter) {\n      delete fp_iter->second;\n   }\n   allFunctionsByPrettyName.clear();\n\n   for (auto vm_iter = allVarsByMangledName.begin(); \n        vm_iter != allVarsByMangledName.end(); ++vm_iter) {\n      delete vm_iter->second;\n   }\n   allVarsByMangledName.clear();\n\n   for (auto vp_iter = allVarsByPrettyName.begin(); \n        vp_iter != allVarsByPrettyName.end(); ++vp_iter) {\n      delete vp_iter->second;\n   }\n   allVarsByPrettyName.clear();\n\n   // codeRangesByAddr_ is static\n    // Remainder are static\n   image::removeImage(image_);\n}\n\nAddress mapped_object::codeAbs() const {\n  return codeBase_ + imageOffset();\n}\n\nAddress mapped_object::dataAbs() const {\n  return dataBase_ + dataOffset();\n}\n\nbool mapped_object::isCode(Address addr) const {\n   Address offset;\n   offset = addr - codeBase();\n\n   return parse_img()->getObject()->isCode(offset);\n}\n\nbool mapped_object::isData(Address addr) const {\n   Address offset;\n   offset = addr - codeBase();\n\n   return parse_img()->getObject()->isData(offset);\n}\n\nbool mapped_object::analyze()\n{\n    if (analyzed_) return true;\n  // Create a process-specific version of the image; all functions and\n  // variables at an absolute address (and modifiable).\n\n  // At some point, we should do better handling of base\n  // addresses. Right now we assume we have one per mapped object; AIX\n  // is a special case with two (one for functions, one for\n  // variables).\n\n  if (!image_) return false;\n\n  image_->analyzeIfNeeded();\n\n  analyzed_ = true;\n\n  // TODO: CLEANUP, shouldn't need this for loop, calling findFunction forces \n  // PatchAPI to create function objects, destroying lazy function creation\n  // We already have exported ones. Force analysis (if needed) and get\n  // the functions we created via analysis.\n  const CodeObject::funclist & allFuncs = parse_img()->getAllFunctions();\n  CodeObject::funclist::const_iterator fit = allFuncs.begin();\n  for( ; fit != allFuncs.end(); ++fit) {\n  // For each function, we want to add our base address\n      if((*fit)->src() != HINT)\n        findFunction((parse_func*)*fit);\n  }\n\n  // Remember: variables don't.\n  pdvector<image_variable *> unmappedVars = image_->getCreatedVariables();\n  for (unsigned vi = 0; vi < unmappedVars.size(); vi++) {\n      findVariable(unmappedVars[vi]);\n  }\n  return true;\n}\n\nmapped_module *mapped_object::findModule(string m_name, bool wildcard)\n{\n   parsing_printf(\"findModule for %s (substr match %d)\\n\",\n         m_name.c_str(), wildcard);\n   std::string tmp = m_name.c_str();\n   for (unsigned i = 0; i < everyModule.size(); i++) {\n      if (everyModule[i]->fileName() == m_name ||\n            everyModule[i]->fullName() == m_name ||\n            (wildcard &&\n             (wildcardEquiv(tmp, everyModule[i]->fileName()) ||\n              wildcardEquiv(tmp, everyModule[i]->fullName())))) {\n         //parsing_printf(\"... found!\\n\");\n         return everyModule[i];\n      }\n   }\n   // Create a new one IF there's one in the child pd_module\n\n   pdmodule *pdmod = image_->findModule(m_name, wildcard);\n   if (pdmod) {\n      mapped_module *mod = mapped_module::createMappedModule(this,\n            pdmod);\n      everyModule.push_back(mod);\n      //parsing_printf(\"... made new module!\\n\");\n      return mod;\n   }\n   else {\n      //parsing_printf(\"... error, no module found...\\n\");\n      return NULL;\n   }\n}\n\n\nmapped_module *mapped_object::findModule(pdmodule *pdmod)\n{\n   if (!pdmod) {\n      fprintf(stderr, \"%s[%d]:  please call this findModule with nonNULL parameter\\n\", FILE__, __LINE__);\n      return NULL;\n   }\n\n   assert(pdmod);\n\n   if (pdmod->imExec() != parse_img()) {\n      fprintf(stderr, \"%s[%d]: WARNING: lookup for module in wrong mapped object! %p != %p\\n\", FILE__, __LINE__, pdmod->imExec(), parse_img());\n      fprintf(stderr, \"%s[%d]:  \\t\\t %s \\n\", FILE__, __LINE__, parse_img()->name().c_str());\n      fprintf(stderr, \"%s[%d]:  \\t %s != \\n\", FILE__, __LINE__, pdmod->imExec()->name().c_str());\n      return NULL;\n   }\n\n   //parsing_printf(\"findModule for pdmod %s\\n\",\n   //pdmod->fullName().c_str());\n\n   for (unsigned i = 0; i < everyModule.size(); i++) {\n      if (everyModule[i]->pmod() == pdmod) {\n         //parsing_printf(\"... found at index %d\\n\", i);\n         return everyModule[i];\n      }\n   }\n\n   mapped_module *mod = mapped_module::createMappedModule(this,\n         pdmod);\n   if (mod) {\n      //parsing_printf(\"... created new module\\n\");\n      everyModule.push_back(mod);\n      return mod;\n   }\n   else\n      return NULL;\n}\n\n// fill in \"short_name\" data member.  Use last component of \"name\" data\n// member with FS_FIELD_SEPERATOR (\"/\") as field seperator....\nvoid mapped_object::set_short_name() {\n   const char *name_string = fullName_.c_str();\n   const char *ptr = strrchr(name_string, FS_FIELD_SEPERATOR);\n   if (ptr != NULL) {\n      fileName_ = ptr+1;\n   } else {\n      fileName_ = fullName_;\n   }\n}\n\nconst pdvector<func_instance *> *mapped_object::findFuncVectorByPretty(const std::string &funcname)\n{\n   if (funcname.c_str() == 0) return NULL;\n   // First, check the underlying image.\n   const pdvector<parse_func *> *img_funcs = parse_img()->findFuncVectorByPretty(funcname);\n   if (img_funcs == NULL) {\n      return NULL;\n   }\n\n   assert(img_funcs->size());\n   // Fast path:\n   auto iter = allFunctionsByPrettyName.find(funcname);\n   if (iter != allFunctionsByPrettyName.end()) {\n      // Okay, we've pulled in some of the functions before (this can happen as a\n      // side effect of adding functions). But did we get them all?\n      pdvector<func_instance *> *map_funcs = iter->second;\n      if (map_funcs->size() == img_funcs->size()) {\n         // We're allocating at the lower level....\n         delete img_funcs;\n         return map_funcs;\n      }\n   }\n\n   // Slow path: check each img_func, add those we don't already have, and return.\n   for (unsigned i = 0; i < img_funcs->size(); i++) {\n       parse_func *func = (*img_funcs)[i];\n       if (funcs_.find(func) == funcs_.end()) {\n           findFunction(func);\n       }\n       assert(funcs_[func]);\n   }\n   delete img_funcs;\n   return allFunctionsByPrettyName[funcname];\n}\n\nconst pdvector <func_instance *> *mapped_object::findFuncVectorByMangled(const std::string &funcname)\n{\n    if (funcname.c_str() == 0) return NULL;\n\n    // First, check the underlying image.\n    const pdvector<parse_func *> *img_funcs = parse_img()->findFuncVectorByMangled(funcname);\n    if (img_funcs == NULL) {\n       return NULL;\n    }\n\n    assert(img_funcs->size());\n    // Fast path:\n    auto iter = allFunctionsByMangledName.find(funcname);\n    if (iter != allFunctionsByMangledName.end()) {\n        // Okay, we've pulled in some of the functions before (this can happen as a\n        // side effect of adding functions). But did we get them all?\n       pdvector<func_instance *> *map_funcs = iter->second;\n       if (map_funcs->size() == img_funcs->size()) {\n          // We're allocating at the lower level...\n          delete img_funcs;\n          return map_funcs;\n       }\n    }\n    \n    // Slow path: check each img_func, add those we don't already have, and return.\n    for (unsigned i = 0; i < img_funcs->size(); i++) {\n       parse_func *func = (*img_funcs)[i];\n       if (funcs_.find(func) == funcs_.end()) {\n          findFunction(func);\n       }\n       assert(funcs_[func]);\n    }\n    delete img_funcs;\n    return allFunctionsByMangledName[funcname];\n}\n\n\nconst pdvector<int_variable *> *mapped_object::findVarVectorByPretty(const std::string &varname)\n{\n    if (varname.c_str() == 0) return NULL;\n\n    // First, check the underlying image.\n    const pdvector<image_variable *> *img_vars = parse_img()->findVarVectorByPretty(varname);\n    if (img_vars == NULL) return NULL;\n\n    assert(img_vars->size());\n    // Fast path:\n    auto iter = allVarsByPrettyName.find(varname);\n    if (iter != allVarsByPrettyName.end()) {\n       // Okay, we've pulled in some of the variabletions before (this can happen as a\n       // side effect of adding variabletions). But did we get them all?\n       pdvector<int_variable *> *map_variables = iter->second;\n       if (map_variables->size() == img_vars->size()) {\n          delete img_vars;\n          return map_variables;\n       }\n    }\n    \n    // Slow path: check each img_variable, add those we don't already have, and return.\n    for (unsigned i = 0; i < img_vars->size(); i++) {\n        image_variable *var = (*img_vars)[i];\n        auto iter2 = everyUniqueVariable.find(var);\n        if (iter2 == everyUniqueVariable.end()) {\n           findVariable(var);\n        }\n        assert(everyUniqueVariable[var]);\n    }\n    delete img_vars;\n    return allVarsByPrettyName[varname];\n}\n\nconst pdvector <int_variable *> *mapped_object::findVarVectorByMangled(const std::string &varname)\n{\n  if (varname.c_str() == 0) return NULL;\n\n  // First, check the underlying image.\n  const pdvector<image_variable *> *img_vars = parse_img()->findVarVectorByMangled(varname);\n  if (img_vars == NULL) return NULL;\n\n  assert(img_vars->size());\n  // Fast path:\n\n  auto iter = allVarsByMangledName.find(varname);\n  if (iter != allVarsByMangledName.end()) {\n      // Okay, we've pulled in some of the variabletions before (this can happen as a\n      // side effect of adding variables). But did we get them all?\n     pdvector<int_variable *> *map_variables = iter->second;\n      if (map_variables->size() == img_vars->size()) {\n         delete img_vars;\n         return map_variables;\n      }\n  }\n  \n  // Slow path: check each img_variable, add those we don't already have, and return.\n  for (unsigned i = 0; i < img_vars->size(); i++) {\n     image_variable *var = (*img_vars)[i];\n     auto iter2 = everyUniqueVariable.find(var);\n     if (iter2 == everyUniqueVariable.end()) {\n        findVariable(var);\n     }\n     assert(everyUniqueVariable[var]);\n  }\n  delete img_vars;\n  return allVarsByMangledName[varname];\n}\n\n//Returns one variable, doesn't search other mapped_objects.  Use carefully.\nconst int_variable *mapped_object::getVariable(const std::string &varname) {\n    const pdvector<int_variable *> *vars = NULL;\n    vars = findVarVectorByPretty(varname);\n    if (!vars) vars = findVarVectorByMangled(varname);\n    if (vars) {\n        assert(vars->size() > 0);\n        return (*vars)[0];\n    }\n    return NULL;\n}\n\nblock_instance *mapped_object::findBlockByEntry(Address addr)\n{\n    std::set<block_instance *> allBlocks;\n    if (!findBlocksByAddr(addr, allBlocks)) return NULL;\n    for (std::set<block_instance *>::iterator iter = allBlocks.begin();\n        iter != allBlocks.end(); ++iter)\n    {\n        if ((*iter)->start() == addr)\n        {\n           return *iter;\n        }\n    }\n    return NULL;\n}\n\n\nbool mapped_object::findBlocksByAddr(const Address addr, std::set<block_instance *> &blocks)\n{\n    // Quick bounds check...\n    if (addr < codeAbs()) {\n        return false;\n    }\n    if (addr >= (codeAbs() + imageSize())) {\n        return false;\n    }\n\n    // Duck into the image class to see if anything matches\n    set<ParseAPI::Block *> stab;\n    parse_img()->findBlocksByAddr(addr - codeBase(), stab);\n    if (stab.empty()) return false;\n\n    for (set<ParseAPI::Block *>::iterator llb_iter = stab.begin();\n        llb_iter != stab.end(); ++llb_iter)\n    {\n        // For each block b \\in stab\n        //   For each func f \\in b.funcs()\n        //     Let i_f = up_map(f)\n        //       add up_map(b, i_f)\n        std::vector<ParseAPI::Function *> ll_funcs;\n        (*llb_iter)->getFuncs(ll_funcs);\n        for (std::vector<ParseAPI::Function *>::iterator llf_iter = ll_funcs.begin();\n            llf_iter != ll_funcs.end(); ++llf_iter) {\n           block_instance *block = findBlock(*llb_iter);\n           assert(block);\n           blocks.insert(block);\n        }\n    }\n    return !blocks.empty();\n}\n\nbool mapped_object::findFuncsByAddr(const Address addr, std::set<func_instance *> &funcs)\n{\n    bool ret = false;\n    // Quick and dirty implementation\n    std::set<block_instance *> blocks;\n    if (!findBlocksByAddr(addr, blocks)) return false;\n    for (std::set<block_instance *>::iterator iter = blocks.begin();\n         iter != blocks.end(); ++iter) {\n       (*iter)->getFuncs(std::inserter(funcs, funcs.end()));\n       ret = true;\n    }\n    return ret;\n}\n\nfunc_instance *mapped_object::findFuncByEntry(const Address addr) {\n   std::set<func_instance *> funcs;\n   if (!findFuncsByAddr(addr, funcs)) return NULL;\n   for (std::set<func_instance *>::iterator iter = funcs.begin();\n        iter != funcs.end(); ++iter) {\n      if ((*iter)->entryBlock()->start() == addr) return *iter;\n   }\n   return NULL;\n}\n\n\nconst pdvector<mapped_module *> &mapped_object::getModules() {\n    // everyModule may be out of date...\n    std::vector<pdmodule *> pdmods;\n    parse_img()->getModules(pdmods);\n    if (everyModule.size() == pdmods.size())\n        return everyModule;\n    for (unsigned i = 0; i < pdmods.size(); i++) {\n        findModule(pdmods[i]);\n    }\n\n    return everyModule;\n}\n\nbool mapped_object::getAllFunctions(pdvector<func_instance *> &funcs) {\n    unsigned start = funcs.size();\n\n    const CodeObject::funclist &img_funcs = parse_img()->getAllFunctions();\n    CodeObject::funclist::const_iterator fit = img_funcs.begin();\n    for( ; fit != img_funcs.end(); ++fit) {\n        if(funcs_.find((parse_func*)*fit) == funcs_.end()) {\n            findFunction((parse_func*)*fit);\n        }\n        funcs.push_back(SCAST_FI(funcs_[*fit]));\n    }\n    return funcs.size() > start;\n}\n\nbool mapped_object::getAllVariables(pdvector<int_variable *> &vars) {\n    unsigned start = vars.size();\n\n    const pdvector<image_variable *> &img_vars = parse_img()->getAllVariables();\n\n    for (unsigned i = 0; i < img_vars.size(); i++) {\n       auto iter = everyUniqueVariable.find(img_vars[i]);\n       if (iter == everyUniqueVariable.end()) {\n          findVariable(img_vars[i]);\n       }\n       vars.push_back(everyUniqueVariable[img_vars[i]]);\n    }\n    return vars.size() > start;\n}\n\nfunc_instance *mapped_object::findFunction(ParseAPI::Function *papi_func) {\n  return SCAST_FI(getFunc(papi_func));\n}\n\nvoid mapped_object::addFunctionName(func_instance *func,\n                                    const std::string newName,\n                                    func_index_t &index) {\n   pdvector<func_instance *> *funcsByName = NULL;\n   \n   auto iter = index.find(newName); \n   if (iter != index.end()) {\n      funcsByName = iter->second;\n   }\n   else {\n      funcsByName = new std::vector<func_instance *>;\n      index[newName] = funcsByName;\n   }\n\n   assert(funcsByName != NULL);\n   funcsByName->push_back(func);\n}\n\n\nvoid mapped_object::addFunction(func_instance *func) {\n    // Possibly multiple demangled (pretty) names...\n    // And multiple functions (different addr) with the same pretty\n    // name. So we have a many::many mapping...\n    for (unsigned pretty_iter = 0;\n         pretty_iter < func->prettyNameVector().size();\n         pretty_iter++) {\n        string pretty_name = func->prettyNameVector()[pretty_iter];\n        addFunctionName(func, pretty_name.c_str(), allFunctionsByPrettyName);\n    }\n\n    // And multiple symtab names...\n    for (unsigned symtab_iter = 0;\n         symtab_iter < func->symTabNameVector().size();\n         symtab_iter++) {\n        string symtab_name = func->symTabNameVector()[symtab_iter];\n        addFunctionName(func, symtab_name.c_str(), allFunctionsByMangledName);\n    }\n\n    func->mod()->addFunction(func);\n}\n\n// Enter a function in all the appropriate tables\nint_variable *mapped_object::findVariable(image_variable *img_var) {\n    if (!img_var) return NULL;\n\n    auto iter = everyUniqueVariable.find(img_var);\n    if (iter != everyUniqueVariable.end()) { return iter->second; }\n\n    mapped_module *mod = findModule(img_var->pdmod());\n    assert(mod);\n\n    int_variable *var = new int_variable(img_var, dataBase_, mod);\n    addVariable(var);\n    return var;\n}\n\nvoid mapped_object::addVariable(int_variable *var) {\n\n    // Possibly multiple demangled (pretty) names...\n    // And multiple functions (different addr) with the same pretty\n    // name. So we have a many::many mapping...\n    for (unsigned pretty_iter = 0;\n         pretty_iter < var->prettyNameVector().size();\n         pretty_iter++) {\n        string pretty_name = var->prettyNameVector()[pretty_iter];\n        pdvector<int_variable *> *varsByPrettyEntry = NULL;\n\n        // Ensure a vector exists\n        auto iter = allVarsByPrettyName.find(pretty_name);\n        if (iter == allVarsByPrettyName.end()) {\n           varsByPrettyEntry = new std::vector<int_variable *>;\n           allVarsByPrettyName[pretty_name] = varsByPrettyEntry;\n        }\n        else {\n           varsByPrettyEntry = iter->second;\n        }\n\n\n        (*varsByPrettyEntry).push_back(var);\n    }\n\n    // And multiple symtab names...\n    for (unsigned symtab_iter = 0;\n         symtab_iter < var->symTabNameVector().size();\n         symtab_iter++) {\n        string symtab_name = var->symTabNameVector()[symtab_iter];\n        pdvector<int_variable *> *varsBySymTabEntry = NULL;\n\n        // Ensure a vector exist\n        auto iter = allVarsByMangledName.find(symtab_name);\n        if (iter == allVarsByMangledName.end()) {\n           varsBySymTabEntry = new std::vector<int_variable *>;\n           allVarsByMangledName[symtab_name] = varsBySymTabEntry;\n        }\n        else {\n           varsBySymTabEntry = iter->second;\n        }\n\n        (*varsBySymTabEntry).push_back(var);\n    }\n\n    everyUniqueVariable[var->ivar()] = var;\n\n    var->mod()->addVariable(var);\n}\n\n/////////// Dinky functions\n\n// This way we don't have to cross-include every header file in the\n// world.\n\nAddressSpace *mapped_object::proc() const { return proc_; }\n\nbool mapped_object::isSharedLib() const\n{\n    if (isMemoryImg()) return false;\n\n    return parse_img()->isSharedObj();\n    // HELL NO\n    //return desc_.isSharedObject();\n}\n\nbool mapped_object::isStaticExec() const\n{\n    return parse_img()->getObject()->isStaticBinary();\n}\n\nconst std::string mapped_object::debugString() const\n{\n    std::string debug;\n    debug = std::string(fileName_.c_str()) + \":\"\n       + utos(codeBase_)\n       + \"/\" + utos(imageSize());\n    return debug;\n}\n\n// Search an object for heapage\nbool mapped_object::getInfHeapList(pdvector<heapDescriptor> &infHeaps) {\n    vector<pair<string,Address> > foundHeaps;\n\n    getInferiorHeaps(foundHeaps);\n\n    for (u_int j = 0; j < foundHeaps.size(); j++) {\n        // The string layout is: DYNINSTstaticHeap_size_type_unique\n        // Can't allocate a variable-size array on NT, so malloc\n        // that sucker\n        char *temp_str = (char *)malloc(strlen(foundHeaps[j].first.c_str())+1);\n        strcpy(temp_str, foundHeaps[j].first.c_str());\n        char *garbage_str = strtok(temp_str, \"_\"); // Don't care about beginning\n        assert(!strcmp(\"DYNINSTstaticHeap\", garbage_str));\n        // Name is as is.\n        // If address is zero, then skip (error condition)\n        if (foundHeaps[j].second == 0) {\n            cerr << \"Skipping heap \" << foundHeaps[j].first.c_str()\n                 << \"with address 0\" << endl;\n            continue;\n        }\n        // Size needs to be parsed out (second item)\n        // Just to make life difficult, the heap can have an optional\n        // trailing letter (k,K,m,M,g,G) which indicates that it's in\n        // kilobytes, megabytes, or gigabytes. Why gigs? I was bored.\n        char *heap_size_str = strtok(NULL, \"_\"); // Second element, null-terminated\n        unsigned heap_size = (unsigned) atol(heap_size_str);\n        if (heap_size == 0)\n            /* Zero size or error, either way this makes no sense for a heap */\n        {\n            free(temp_str);\n            continue;\n        }\n        switch (heap_size_str[strlen(heap_size_str)-1]) {\n        case 'g':\n        case 'G':\n            heap_size *= 1024;\n        case 'm':\n        case 'M':\n            heap_size *= 1024;\n        case 'k':\n        case 'K':\n            heap_size *= 1024;\n        default:\n            break;\n        }\n\n        // Type needs to be parsed out. Can someone clean this up?\n        inferiorHeapType heap_type;\n        char *heap_type_str = strtok(NULL, \"_\");\n\n        if (!strcmp(heap_type_str, \"anyHeap\"))\n            heap_type = anyHeap;\n        else if (!strcmp(heap_type_str, \"lowmemHeap\"))\n            heap_type = lowmemHeap;\n        else if (!strcmp(heap_type_str, \"dataHeap\"))\n            heap_type = dataHeap;\n        else if (!strcmp(heap_type_str, \"textHeap\"))\n            heap_type = textHeap;\n        else if (!strcmp(heap_type_str, \"uncopiedHeap\"))\n            heap_type = uncopiedHeap;\n        else {\n            cerr << \"Unknown heap string \" << heap_type_str << \" read from file!\" << endl;\n            free(temp_str);\n            continue;\n        }\n        infHeaps.push_back(heapDescriptor(foundHeaps[j].first.c_str(),\n                                          foundHeaps[j].second,\n                                          heap_size, heap_type));\n        free(temp_str);\n    }\n    return foundHeaps.size() > 0;\n}\n\nunsigned mapped_object::memoryEnd() \n{ \n    if ((long)memEnd_ != -1) {\n        return memEnd_;\n    }\n    memEnd_ = 0;\n    vector<SymtabAPI::Region*> regs;\n    parse_img()->getObject()->getMappedRegions(regs);\n    for (unsigned ridx=0; ridx < regs.size(); ridx++) {\n        if (memEnd_ < regs[ridx]->getMemOffset() + regs[ridx]->getMemSize()) {\n            memEnd_ = regs[ridx]->getMemOffset() + regs[ridx]->getMemSize();\n        }\n    }\n    memEnd_ += codeBase();\n    return memEnd_;\n}\n\n\n// This gets called once per image. Poke through to the internals;\n// all we care about, amusingly, is symbol table information.\n\nvoid mapped_object::getInferiorHeaps(vector<pair<string, Address> > &foundHeaps)\n{\n    vector<pair<string, Address> > code_heaps;\n    vector<pair<string, Address> > data_heaps;\n\n    if (!parse_img()->getInferiorHeaps(code_heaps, data_heaps)) {\n        return;\n    }\n\n\n    // We have a bunch of offsets, now add in the base addresses\n    for (unsigned i = 0; i < code_heaps.size(); i++) {\n\t\tfoundHeaps.push_back(pair<string,Address>(code_heaps[i].first,\n                                                  code_heaps[i].second + codeBase()));\n    }\n    for (unsigned i = 0; i < data_heaps.size(); i++) {\n        foundHeaps.push_back(pair<string,Address>(data_heaps[i].first,\n                                                  data_heaps[i].second + dataBase()));\n    }\n}\n\n\nvoid *mapped_object::getPtrToInstruction(Address addr) const {\n   if (!isCode(addr)) return NULL;\n   \n   Address offset;\n   if (proc()->getAddressWidth() == 8) {\n      offset = addr - codeBase();\n   }\n   else {\n      offset = ((unsigned) addr) - ((unsigned) codeBase());\n   }\n\n  return image_->codeObject()->cs()->getPtrToInstruction(offset);\n}\n\nvoid *mapped_object::getPtrToData(Address addr) const\n{\n   assert(addr >= dataAbs());\n   assert(addr < (dataAbs() + dataSize()));\n\n   // Don't go from the code base... the image adds back in the code\n   // offset.\n   Address offset = addr - dataBase();\n   return image_->codeObject()->cs()->getPtrToData(offset);\n}\n\n// mapped objects may contain multiple Symtab::Regions, this function\n// should not be used, but must be included in the class because this\n// function is a subclass of codeRange\nvoid *mapped_object::get_local_ptr() const\n{\n    assert(0);// if you crash here, blame me. -kevin\n    return NULL;\n    //   return image_->getObject()->image_ptr();\n}\n\n\nbool mapped_object::getSymbolInfo(const std::string &n, int_symbol &info)\n{\n    using SymtabAPI::Symbol;\n\n    assert(image_);\n\n    Symbol *lowlevel_sym = image_->symbol_info(n);\n    if (!lowlevel_sym) {\n        lowlevel_sym = image_->symbol_info(std::string(\"_\") + n);\n    }\n\n    if (!lowlevel_sym) return false;\n\n    if (lowlevel_sym->getType() == Symbol::ST_OBJECT)\n        info = int_symbol(lowlevel_sym, dataBase_);\n    else\n        info = int_symbol(lowlevel_sym, codeBase_);\n\n    return true;\n}\n\nmapped_module *mapped_object::getOrCreateForkedModule(mapped_module *parMod)\n{\n   // Okay. We're forking, and this is the child mapped_object.\n   // And now, given a parent module, we need to find the right one\n   // in our little baby modules.\n\n   // Since we've already copied modules, we can just do a name lookup.\n   mapped_module *childModule = findModule(parMod->fileName(), false);\n   assert(childModule);\n   return childModule;\n\n}\n\nmapped_module* mapped_object::getDefaultModule()\n{\n  mapped_module* ret = findModule(\"DEFAULT_MODULE\");\n  if(ret) return ret;\n\n  // Make sure the everyModule vector is initialized\n  getModules();\n\n  assert(everyModule.size() > 0);\n  return everyModule[0];\n\n}\n\n\n// Grabs all block_instances corresponding to the region (horribly inefficient)\nbool mapped_object::findBlocksByRange(Address startAddr,\n                                      Address endAddr,\n                                      list<block_instance*> &rangeBlocks)//output\n{\n   std::set<ParseAPI::Block *> papiBlocks;\n   for (Address cur = startAddr; cur < endAddr; ++cur) {\n      Address papiCur = cur - codeBase();\n      parse_img()->codeObject()->findBlocks(NULL, papiCur, papiBlocks);\n   }\n\n   for (std::set<ParseAPI::Block *>::iterator iter = papiBlocks.begin();\n        iter != papiBlocks.end(); ++iter) {\n      // For each parseAPI block, up-map it to a block_instance\n      block_instance *bbl = this->findBlock(*iter);\n      assert(bbl);\n      rangeBlocks.push_back(bbl);\n   }\n   return !rangeBlocks.empty();\n}\n\nvoid mapped_object::findFuncsByRange(Address startAddr,\n                                      Address endAddr,\n                                      std::set<func_instance*> &pageFuncs)\n{\n   std::list<block_instance *> bbls;\n   findBlocksByRange(startAddr, endAddr, bbls);\n   for (std::list<block_instance *>::iterator iter = bbls.begin();\n        iter != bbls.end(); ++iter) {\n      (*iter)->getFuncs(std::inserter(pageFuncs, pageFuncs.end()));\n   }\n}\n\n/* Re-trigger parsing in the object.  This function should\n * only be invoked if all funcEntryAddrs lie within the boundaries of\n * the object.\n *\n * Copies over the raw data if a funcEntryAddr lies in between\n * the region's disk size and memory size, also copies raw data\n * if the memory around the entry point has changed\n *\n * A true return value means that new functions were parsed\n*/\nbool mapped_object::parseNewFunctions(vector<Address> &funcEntryAddrs)\n{\n\n    bool reparsedObject = false;\n    Address baseAddress = codeBase();\n    SymtabAPI::Region *reg;\n    std::set<SymtabAPI::Region*> visitedRegions;\n\n    // code page bytes may need updating\n    if (BPatch_defensiveMode == analysisMode_) {\n        setCodeBytesUpdated(false);\n    }\n\n    assert(!parse_img()->hasNewBlocks());\n\n    // update regions if necessary, check that functions not parsed already\n    vector<Address>::iterator curEntry = funcEntryAddrs.begin();\n    while (curEntry != funcEntryAddrs.end()) {\n        Address entryOffset = (*curEntry)-baseAddress;\n        reg = parse_img()->getObject()->findEnclosingRegion(entryOffset);\n        if (reg != NULL) {\n\n            if (parse_img()->codeObject()->defensiveMode() &&\n                visitedRegions.end() == visitedRegions.find(reg))\n            {\n                updateCodeBytesIfNeeded(*curEntry);\n                visitedRegions.insert(reg);\n            }\n\n            if (parse_img()->findFuncByEntry(entryOffset)) {\n                fprintf(stderr,\"WARNING: tried to parse at %lx, where a \"\n                        \"function entry exists already %s[%d]\\n\",\n                        *curEntry, FILE__,__LINE__);\n                curEntry = funcEntryAddrs.erase(curEntry);\n            }\n            else {\n                curEntry++;\n            }\n\n        }\n        else {\n            fprintf(stderr,\"ERROR: passed invalid address %lx to \"\n                    \"parseNewFunctions %s[%d]\\n\", *curEntry,FILE__,__LINE__);\n            assert(0);\n            curEntry++;\n        }\n    }\n\n    // parse at funcEntryAddrs\n    curEntry = funcEntryAddrs.begin();\n    set<ParseAPI::Function*> tmpfuncs;\n    while (curEntry != funcEntryAddrs.end()) {\n        Address entryOffset = (*curEntry)  - baseAddress;\n        parse_img()->codeObject()->parse( entryOffset, true );\n\n        if ( ! parse_img()->findFuncs(entryOffset, tmpfuncs) ) {\n            // parse failed, this can happen when the function is just a\n            // jump or return instruction, but it doesn't mean that we\n            // didn't do any parsing\n            fprintf(stderr,\"WARNING, failed to parse function at %lx, \"\n                    \"%s[%d]\\n\", *curEntry, FILE__, __LINE__);\n        }\n        else {\n            reparsedObject = true;\n            tmpfuncs.clear();\n        }\n        curEntry++;\n    }\n\n    assert(consistency(&(*addrSpace())));\n    return reparsedObject;\n}\n\n\n/* 0. The target and source must be in the same mapped region, make sure memory\n *    for the target is up to date\n * 1. Parse from target address, add new edge at image layer\n * 2. Register all newly created functions as a result of new edge parsing\n * 3. Add image blocks as block_instances\n * 4. fix up mapping of split blocks with points\n * 5. Add image points, as instPoints\n*/\nbool mapped_object::parseNewEdges(const std::vector<edgeStub> &stubs)\n{\n    using namespace SymtabAPI;\n    using namespace ParseAPI;\n\n    vector<ParseAPI::CodeObject::NewEdgeToParse> edgesInThisObject;\n\n/* 0. Make sure memory for the target is up to date */\n\n    // Do various checks and set edge types, if necessary\n    for (unsigned idx=0; idx < stubs.size(); idx++) {\n        mapped_object *targ_obj = proc()->findObject(stubs[idx].trg);\n        assert(targ_obj);\n\n        // update target region if needed\n        if (BPatch_defensiveMode == hybridMode())\n        {\n          targ_obj->updateCodeBytesIfNeeded(stubs[idx].trg);\n        }\n\n        EdgeTypeEnum edgeType = stubs[idx].type;\n\n        // Determine if this stub already has been parsed\n        // Which means looking up a block at the target address\n        if (targ_obj->findBlockByEntry(stubs[idx].trg)) {\n           cerr << \"KEVINTEST: VERIFY THAT I WORK: parsing edge for target that already exists\" << endl;\n          //continue; //KEVINTODO: don't we maybe want to add the edge anyway?\n        }\n\n        // Otherwise we don't have a target block, so we need to make one.\n        if (stubs[idx].type == ParseAPI::NOEDGE)\n        {\n            using namespace InstructionAPI;\n            // And we don't know what type of edge this is. Lovely. Let's\n            // figure it out from the instruction class, since that's\n            // the easy way to do things.\n\n            block_instance::Insns insns;\n            stubs[idx].src->getInsns(insns);\n            InstructionAPI::Instruction::Ptr cf = insns[stubs[idx].src->last()];\n            assert(cf);\n            switch (cf->getCategory()) {\n            case c_CallInsn:\n                if (stubs[idx].trg == stubs[idx].src->end())\n                {\n                    edgeType = CALL_FT;\n                }\n                else\n                {\n                    edgeType = CALL;\n                }\n                break;\n            case c_ReturnInsn:\n                //edgeType = RET;\n                // The above doesn't work according to Nate\n                edgeType = INDIRECT;\n                break;\n            case c_BranchInsn:\n                if (cf->readsMemory())\n                {\n                    edgeType = INDIRECT;\n                }\n                else if (!cf->allowsFallThrough())\n                {\n                    edgeType = DIRECT;\n                }\n                else if (stubs[idx].trg == stubs[idx].src->end())\n                {\n                    edgeType = COND_NOT_TAKEN;\n                }\n                else\n                {\n                    edgeType = COND_TAKEN;\n                }\n                break;\n            default:\n                edgeType = FALLTHROUGH;\n                break;\n            }\n        }\n\n\t\t/* 1. Parse from target address, add new edge at image layer  */\n\t\tCodeObject::NewEdgeToParse newEdge(stubs[idx].src->llb(),\n            stubs[idx].trg - targ_obj->codeBase(),\n            edgeType);\n\t\tif (this != targ_obj) {\n\t\t\tstd::vector<ParseAPI::CodeObject::NewEdgeToParse> newEdges;\n\t\t\tnewEdges.push_back(newEdge);\n\t\t\ttarg_obj->parse_img()->codeObject()->parseNewEdges(newEdges);\n\t\t}\n\t\telse {\n\t\t\tedgesInThisObject.push_back(newEdge);\n\t\t}\n\t}\n \n\t/* 2. Parse intra-object edges, after removing any edges that \n          would be duplicates at the image-layer */\n\tparse_img()->codeObject()->parseNewEdges(edgesInThisObject);\n\n    // build list of potentially modified functions\n    vector<ParseAPI::Function*> modIFuncs;\n    vector<func_instance*> modFuncs;\n    for(unsigned sidx=0; sidx < stubs.size(); sidx++) {\n        if (stubs[sidx].src != NULL) {\n            stubs[sidx].src->llb()->getFuncs(modIFuncs);\n        }\n    }\n\n    for (unsigned fidx=0; fidx < modIFuncs.size(); fidx++)\n    {\n       func_instance *func = findFunction(modIFuncs[fidx]);\n       modFuncs.push_back(func);\n\n       //func->ifunc()->invalidateCache();//KEVINTEST: used to call this, which might have been important\n\n       modFuncs[fidx]->triggerModified();\n       modFuncs[fidx]->blocks();\n       modFuncs[fidx]->callBlocks();\n       modFuncs[fidx]->exitBlocks();\n    }\n\n    assert(consistency(&(*addrSpace())));\n    return true;\n}\n\n\n/* 1. Copy the entire region in from the mutatee,\n * 2. if memory emulation is not on, copy blocks back in from the\n * mapped file, since we don't want to copy instrumentation into\n * the mutatee.\n */\nvoid mapped_object::expandCodeBytes(SymtabAPI::Region *reg)\n{\n    assert(reg);\n    void *mappedPtr = reg->getPtrToRawData();\n    Address regStart = reg->getMemOffset();\n    ParseAPI::Block *cur = NULL;\n    ParseAPI::CodeObject *cObj = parse_img()->codeObject();\n    ParseAPI::CodeRegion *parseReg = NULL;\n    Address copySize = reg->getMemSize();\n    void* regBuf = malloc(copySize);\n    Address initializedEnd = regStart + copySize;\n\n    set<ParseAPI::CodeRegion*> parseRegs;\n    cObj->cs()->findRegions(regStart, parseRegs);\n    parseReg = * parseRegs.begin();\n    parseRegs.clear();\n\n    // 1. copy memory into regBuf\n    Address readAddr = regStart + codeBase();\n    if (proc()->isMemoryEmulated()) {\n        bool valid = false;\n        boost::tie(valid, readAddr) = proc()->getMemEm()->translate(readAddr);\n        assert(valid);\n    }\n    if (!proc()->readDataSpace((void*)readAddr,\n                               copySize,\n                               regBuf,\n                               true))\n    {\n        fprintf(stderr, \"%s[%d] Failed to read from region [%lX %lX]\\n\",\n                __FILE__, __LINE__, (long)regStart+codeBase(), copySize);\n        assert(0);\n    }\n    mal_printf(\"EXTEND_CB: copied to [%lx %lx)\\n\", codeBase()+regStart, codeBase()+regStart+copySize);\n\n\n    if ( ! proc()->isMemoryEmulated() ) {\n\n    // 2. copy code bytes back into the regBuf to wipe out instrumentation\n    //    and set regBuf to be the data for the region\n\n        // find the first block in the region\n        set<ParseAPI::Block*> analyzedBlocks;\n        cObj->findBlocks(parseReg, regStart, analyzedBlocks);\n        if (analyzedBlocks.size()) {\n            cur = * analyzedBlocks.begin();\n        } else {\n            cur = cObj->findNextBlock(parseReg, regStart);\n        }\n\n        // copy code ranges from old mapped data into regBuf\n        while (cur != NULL &&\n               cur->start() < initializedEnd)\n        {\n            if ( ! memcpy((void*)((Address)regBuf + cur->start() - regStart),\n                          (void*)((Address)mappedPtr + cur->start() - regStart),\n                          cur->size()) )\n            {\n                assert(0);\n            }\n            mal_printf(\"EX: uncopy [%lx %lx)\\n\", codeBase()+cur->start(),codeBase()+cur->end());\n            // advance to the next block\n            Address prevEnd = cur->end();\n            cur = cObj->findBlockByEntry(parseReg,prevEnd);\n            if (!cur) {\n                cur = cObj->findNextBlock(parseReg,prevEnd);\n            }\n        }\n        mal_printf(\"Expand region: %lx blocks copied back into mapped file\\n\",\n                   analyzedBlocks.size());\n    }\n\n    if (reg->isDirty()) {\n        // if isDirty is true, the pointer was created via malloc\n        // and we can free it.  If not, isDirty is part of a mapped\n        // file and we can't free it\n        free( mappedPtr );\n    }\n\n    // swap out rawDataPtr for the mapped file\n    static_cast<SymtabCodeSource*>(cObj->cs())->\n        resizeRegion( reg, reg->getMemSize() );\n    reg->setPtrToRawData( regBuf , copySize );\n\n    // expand this mapped_object's codeRange\n    if (codeBase() + reg->getMemOffset() + reg->getMemSize()\n        >\n        codeAbs() + get_size())\n    {\n        parse_img()->setImageLength( codeBase()\n                                     + reg->getMemOffset()\n                                     + reg->getMemSize()\n                                     - codeAbs() );\n\n    }\n}\n\n// 1. use other update functions to update non-code areas of mapped files,\n//    expanding them if we overwrote into unmapped areas\n// 2. copy overwritten regions into the mapped objects\nvoid mapped_object::updateCodeBytes(const list<pair<Address,Address> > &owRanges)\n{\n    bool memEmulation = proc()->isMemoryEmulated();\n// 1. use other update functions to update non-code areas of mapped files,\n//    expanding them if we wrote in un-initialized memory\n    using namespace SymtabAPI;\n    std::set<Region *> expandRegs;// so we don't update regions more than once\n    Address baseAddress = codeBase();\n\n    // figure out which regions need expansion and which need updating\n    list<pair<Address,Address> >::const_iterator rIter = owRanges.begin();\n    for(; rIter != owRanges.end(); rIter++) {\n        Address lastChangeOffset = (*rIter).second -1 -baseAddress;\n        Region *curReg = parse_img()->getObject()->findEnclosingRegion\n                                                    ( lastChangeOffset );\n        if ( lastChangeOffset - curReg->getMemOffset() >= curReg->getDiskSize() ) {\n            expandRegs.insert(curReg);\n        }\n    }\n    // expand and update regions\n    for (set<Region*>::iterator regIter = expandRegs.begin();\n         regIter != expandRegs.end(); regIter++)\n    {\n        expandCodeBytes(*regIter);\n    }\n    std::vector<Region *> allregions;\n    parse_img()->getObject()->getCodeRegions(allregions);\n    for (unsigned int ridx=0; ridx < allregions.size(); ridx++)\n    {\n        Region *curreg = allregions[ridx];\n        if (expandRegs.end() == expandRegs.find(curreg)) {\n            updateCodeBytes(curreg); // KEVINOPTIMIZE: major overkill here, only update regions that had unprotected pages\n        }\n    }\n\n// 2. copy overwritten regions into the mapped objects\n    for(rIter = owRanges.begin(); rIter != owRanges.end(); rIter++)\n    {\n        Address readAddr = rIter->first;\n        if (memEmulation) {\n            bool valid = false;\n            boost::tie(valid, readAddr) = proc()->getMemEm()->translate(readAddr);\n            assert(valid);\n        }\n\n        Region *reg = parse_img()->getObject()->findEnclosingRegion\n            ( (*rIter).first - baseAddress );\n        unsigned char* regPtr = (unsigned char*)reg->getPtrToRawData()\n            + (*rIter).first - baseAddress - reg->getMemOffset();\n\n        if (!proc()->readDataSpace((void*)readAddr,\n                                   (*rIter).second - (*rIter).first,\n                                   regPtr,\n                                   true) )\n        {\n            assert(0);\n        }\n        if (0) {\n            mal_printf(\"OW_CB: copied to [%lx %lx): \", rIter->first,rIter->second);\n            for (unsigned idx=0; idx < rIter->second - rIter->first; idx++) {\n                mal_printf(\"%2x \", (unsigned) regPtr[idx]);\n            }\n            mal_printf(\"\\n\");\n        }\n    }\n    pagesUpdated_ = true;\n}\n\n// this is a helper function\n//\n// update mapped data for whole object, or just one region, if specified\n//\n// Read unprotected pages into the mapped file\n// (not analyzed code regions so we don't get instrumentation in our parse)\nvoid mapped_object::updateCodeBytes(SymtabAPI::Region * symReg)\n{\n    assert(NULL != symReg);\n\n    Address base = codeBase();\n    ParseAPI::CodeObject *cObj = parse_img()->codeObject();\n    std::vector<SymtabAPI::Region *> regions;\n\n    Block *curB = NULL;\n    set<ParseAPI::Block *> analyzedBlocks;\n    set<ParseAPI::CodeRegion*> parseRegs;\n\n    void *mappedPtr = symReg->getPtrToRawData();\n    Address regStart = symReg->getMemOffset();\n\n    cObj->cs()->findRegions(regStart, parseRegs);\n    ParseAPI::CodeRegion *parseReg = * parseRegs.begin();\n    parseRegs.clear();\n\n    // find the first block in the region\n    cObj->findBlocks(parseReg, regStart, analyzedBlocks);\n    if (analyzedBlocks.size()) {\n        curB = * analyzedBlocks.begin();\n        analyzedBlocks.clear();\n    } else {\n        curB = cObj->findNextBlock(parseReg, regStart);\n    }\n\n    Address prevEndAddr = regStart;\n    while ( curB != NULL &&\n            curB->start() < regStart + symReg->getDiskSize() )\n    {\n        // if there's a gap between previous and current block\n        if (prevEndAddr < curB->start()) {\n            // update the mapped file\n            Address readAddr = prevEndAddr + base;\n            if (proc()->isMemoryEmulated()) {\n                bool valid = false;\n                boost::tie(valid, readAddr) = proc()->getMemEm()->translate(readAddr);\n                assert(valid);\n            }\n            if (!proc()->readDataSpace(\n                    (void*)readAddr,\n                    curB->start() - prevEndAddr,\n                    (void*)((Address)mappedPtr + prevEndAddr - regStart),\n                    true))\n            {\n                assert(0);//read failed\n            }\n            //mal_printf(\"UPDATE_CB: copied to [%lx %lx)\\n\", prevEndAddr+base,curB->start()+base);\n        }\n\n        // advance curB to last adjacent block and set prevEndAddr\n        prevEndAddr = curB->end();\n        Block *ftBlock = cObj->findBlockByEntry(parseReg,prevEndAddr);\n        while (ftBlock) {\n            curB = ftBlock;\n            prevEndAddr = curB->end();\n            ftBlock = cObj->findBlockByEntry(parseReg,prevEndAddr);\n        }\n\n        curB = cObj->findNextBlock(parseReg, prevEndAddr);\n\n    }\n    // read in from prevEndAddr to the end of the region\n\t// (will read in whole region if there are no ranges in the region)\n    if (prevEndAddr < regStart + symReg->getDiskSize()) {\n        Address readAddr = prevEndAddr + base;\n        if (proc()->isMemoryEmulated()) {\n            bool valid = false;\n            boost::tie(valid, readAddr) = proc()->getMemEm()->translate(readAddr);\n            assert(valid);\n        }\n        if (!proc()->readDataSpace(\n                (void*)readAddr,\n                regStart + symReg->getDiskSize() - prevEndAddr,\n                (void*)((Address)mappedPtr + prevEndAddr - regStart),\n                true))\n        {\n            assert(0);// read failed\n        }\n    }\n    // change all region pages with REPROTECTED status to PROTECTED status\n    Address page_size = proc()->proc()->getMemoryPageSize();\n    Address curPage = (regStart / page_size) * page_size + base;\n    Address regEnd = base + regStart + symReg->getDiskSize();\n    for (; protPages_.end() == protPages_.find(curPage)  && curPage < regEnd;\n         curPage += page_size) {};\n    for (map<Address,WriteableStatus>::iterator pit = protPages_.find(curPage);\n         pit != protPages_.end() && pit->first < regEnd;\n         pit++)\n    {\n        pit->second = PROTECTED;\n    }\n}\n\n// checks if update is needed by looking in the gap between the previous\n// and next block for changes to the underlying bytes\n//\n// should only be called if we've already checked that we're not on an\n// analyzed page that's been protected from overwrites, as this\n// check would not be needed\nbool mapped_object::isUpdateNeeded(Address entry)\n{\n    using namespace ParseAPI;\n    bool updateNeeded = false;\n    void* regBuf = NULL;\n    Address base = codeBase();\n\n    assert( BPatch_defensiveMode == hybridMode() );\n\n    set<CodeRegion*> cregs;\n    CodeObject *co = parse_img()->codeObject();\n    co->cs()->findRegions(entry-base, cregs);\n    assert( ! co->cs()->regionsOverlap() );\n    if (0 == cregs.size()) {\n        mal_printf(\"Object update request has invalid addr[%lx] %s[%d]\\n\",\n                   entry, FILE__,__LINE__);\n        return false;\n    }\n    SymtabCodeRegion *creg = static_cast<SymtabCodeRegion*>( * cregs.begin() );\n\n    // update the range tree, if necessary\n    set<ParseAPI::Block *> analyzedBlocks;\n    if (parse_img()->findBlocksByAddr(entry-base, analyzedBlocks)) {\n        return false; // don't need to update if target is in analyzed code\n    }\n\n    // see if the underlying bytes have changed\n    //\n    // read until the next basic block or until the end of the region\n    // to make sure nothing has changed, otherwise we'll want to read\n    // the section in again\n    Block *nextBlk = co->findNextBlock(creg, entry-base);\n    unsigned comparison_size = 0;\n    if (nextBlk) {\n        comparison_size = nextBlk->start() - (entry-base);\n    } else {\n        comparison_size = creg->symRegion()->getDiskSize()\n            - ( (entry - base) - creg->symRegion()->getMemOffset() );\n    }\n\n    // read until first difference, then see if the difference is to known\n    // in which case the difference is due to instrumentation, as we would\n    // have otherwise detected the overwrite\n    Address page_size = proc()->proc()->getMemoryPageSize();\n    comparison_size = ( comparison_size <  page_size)\n                      ? comparison_size : page_size;\n    regBuf = malloc(comparison_size);\n    Address readAddr = entry;\n    if (proc()->isMemoryEmulated()) {\n        bool valid = false;\n\t\tAddress translated = 0;\n\t\tboost::tie(valid, translated) = proc()->getMemEm()->translate(readAddr);\n\t\tif (valid) readAddr = translated;\n\t}\n\n   // mal_printf(\"%s[%d] Comparing %lx bytes starting at %lx\\n\",\n      //      FILE__,__LINE__,comparison_size,entry);\n    if (!proc()->readDataSpace((void*)readAddr, comparison_size, regBuf, true)) {\n        assert(0);\n    }\n    void *mappedPtr = (void*)\n                      ((Address)creg->symRegion()->getPtrToRawData() +\n                        (entry - base - creg->symRegion()->getMemOffset()) );\n    //compare\n    if (0 != memcmp(mappedPtr,regBuf,comparison_size) ) {\n        updateNeeded = true;\n    }\n    free(regBuf);\n    regBuf = NULL;\n\n    return updateNeeded;\n}\n\n// checks to see if expansion is needed\nbool mapped_object::isExpansionNeeded(Address entry)\n{\n    using namespace SymtabAPI;\n    Address base = codeBase();\n    Region * reg = parse_img()->getObject()->findEnclosingRegion(entry - base);\n\n    if (reg->getMemSize() <= reg->getDiskSize()) {\n        return false;\n    }\n\n    if ( ! parse_img()->getObject()->isCode(entry - base) ) {\n        return true;\n    }\n\n    if (expansionCheckedRegions_.end() !=\n        expansionCheckedRegions_.find(reg)) {\n        return false;\n    }\n    expansionCheckedRegions_.insert(reg);\n\n    // if there is uninitialized space in the region,\n    // see if the first few bytes have been updated\n    Address compareStart =\n        base + reg->getMemOffset() + reg->getDiskSize();\n    if (proc()->isMemoryEmulated()) {\n        bool valid = false;\n        boost::tie(valid, compareStart) = proc()->getMemEm()->translate(compareStart);\n        assert(valid);\n    }\n    unsigned compareSize = InstructionAPI::InstructionDecoder::maxInstructionLength;\n\n    Address uninitSize = reg->getMemSize() - reg->getDiskSize();\n    if (compareSize > uninitSize) {\n        compareSize = uninitSize;\n    }\n    unsigned char* regBuf = (unsigned char*) malloc(compareSize);\n    if (!proc()->readDataSpace((void*)compareStart,compareSize,regBuf,true)) {\n        fprintf(stderr, \"%s[%d] Failed to read from region [%lX %lX]\\n\",\n                __FILE__, __LINE__, compareStart, compareStart+compareSize);\n        assert(0);\n    }\n    // compare to zero if the region has not been expanded yet\n    bool allZeros = true;\n    for (unsigned idx=0; allZeros && idx < compareSize; idx++) {\n        if (0 != regBuf[idx]) {\n            allZeros = false;\n        }\n    }\n    if (allZeros) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n// updates the raw code bytes by fetching from memory, if needed\n//\n// updates if we haven't updated since the last time code could have\n// changed, and if the entry address is on an unprotected code page,\n// or if the address is in an uninitialized memory,\nbool mapped_object::updateCodeBytesIfNeeded(Address entry)\n{\n\t//cerr << \"updateCodeBytes @ \" << hex << entry << dec << endl;\n\n\tassert( BPatch_defensiveMode == analysisMode_ );\n\n    Address pageAddr = entry -\n        (entry % proc()->proc()->getMemoryPageSize());\n\n    if ( pagesUpdated_ ) {\n\t\t//cerr << \"\\t No pages have been updated in mapped_object, ret false\" << endl;\n        return false;\n    }\n\n    if (protPages_.end() != protPages_.find(pageAddr) &&\n        PROTECTED == protPages_[pageAddr])\n    {\n\t\t//cerr << \"\\t Address corresponds to protected page, ret false\" << endl;\n        return false;\n    }\n\n    bool expand = isExpansionNeeded(entry);\n    if ( ! expand ) {\n        if ( ! isUpdateNeeded(entry) ) {\n\t\t\t//cerr << \"\\t Expansion false and no update needed, ret false\" << endl;\n            return false;\n        }\n    }\n\n    SymtabAPI::Region * reg = parse_img()->getObject()->findEnclosingRegion\n        (entry - codeBase());\n    mal_printf(\"%s[%d] updating region [%lx %lx] for entry point %lx\\n\",\n               FILE__,__LINE__,\n               reg->getMemOffset(),\n               reg->getMemOffset()+reg->getDiskSize(),\n               entry);\n\n    if ( expand ) {\n        expandCodeBytes(reg);\n    }\n    else {\n        updateCodeBytes(reg);\n    }\n\n    codeByteUpdates_++;\n    pagesUpdated_ = true;\n    return true;\n}\n\nvoid mapped_object::remove(func_instance *func) {\n\n    if (as()->isMemoryEmulated()) {\n        as()->getMemEm()->removeSpringboards(func);\n    }\n    \n    // clear out module- and BPatch-level data structures \n    BPatch_addressSpace* bpAS = (BPatch_addressSpace*)proc()->up_ptr();\n    BPatch_module *bpmod = bpAS->getImage()->findModule(func->mod());\n    BPatch_function *bpfunc = bpAS->findOrCreateBPFunc(SCAST_FI(func), bpmod);\n    bpfunc->removeCFG();\n    bpmod->remove(bpfunc);\n    func->mod()->remove(func);\n\n    // remove from func_instance vector\n    funcs_.erase(func->ifunc());\n\n    // remove symtab names\n    for (auto name_iter = func->symTabNameVector().begin();\n         name_iter != func->symTabNameVector().end(); \n         ++name_iter) {\n       auto map_iter = allFunctionsByMangledName.find(*name_iter);\n       if (map_iter == allFunctionsByMangledName.end()) continue;\n       \n       std::vector<func_instance *> &name_vec = *(map_iter->second);\n       for (unsigned i = 0; i < name_vec.size(); ++i) {\n          if (name_vec[i] == func) {\n             name_vec[i] = name_vec.back();\n             name_vec.pop_back();\n             if (name_vec.empty()) {\n                delete map_iter->second;\n                allFunctionsByMangledName.erase(map_iter);\n             }\n             break;\n          }\n       }\n    }\n\n    // remove pretty names\n    for (auto name_iter = func->prettyNameVector().begin();\n         name_iter != func->prettyNameVector().end(); \n         ++name_iter) {\n       auto map_iter = allFunctionsByPrettyName.find(*name_iter);\n       if (map_iter == allFunctionsByPrettyName.end()) continue;\n       \n       std::vector<func_instance *> &name_vec = *(map_iter->second);\n       for (unsigned i = 0; i < name_vec.size(); ++i) {\n          if (name_vec[i] == func) {\n             name_vec[i] = name_vec.back();\n             name_vec.pop_back();\n             if (name_vec.empty()) {\n                delete map_iter->second;\n                allFunctionsByPrettyName.erase(map_iter);\n             }\n             break;\n          }\n       }\n    }\n\n}\n\nvoid mapped_object::remove(instPoint *point)\n{\n    BPatch_addressSpace* bpAS = (BPatch_addressSpace*)proc()->up_ptr();\n    BPatch_module *bpmod = bpAS->getImage()->findModule(point->func()->mod());\n    bpmod->remove(point);\n}\n\n// does not delete\nvoid mapped_object::destroy(PatchAPI::PatchBlock *b) {\n   calleeNames_.erase(SCAST_BI(b));\n   if (as()->isMemoryEmulated()) {\n      as()->getMemEm()->removeSpringboards(SCAST_BI(b));\n   }\n}\n\n// does not delete\nvoid mapped_object::destroy(PatchAPI::PatchFunction *f) {\n    remove(SCAST_FI(f));\n}\n\nvoid mapped_object::removeEmptyPages()\n{\n    // get all pages currently containing code from the mapped modules\n    set<Address> curPages;\n    vector<Address> emptyPages;\n    const vector<mapped_module*> & mods = getModules();\n    for (unsigned midx=0; midx < mods.size(); midx++) {\n        mods[midx]->getAnalyzedCodePages(curPages);\n    }\n    // find entries in protPages_ that aren't in curPages, add to emptyPages\n    for (map<Address,WriteableStatus>::iterator pit= protPages_.begin();\n         pit != protPages_.end();\n         pit++)\n    {\n        if (curPages.end() == curPages.find(pit->first)) {\n            emptyPages.push_back(pit->first);\n        }\n    }\n    // erase emptyPages from protPages\n    for (unsigned pidx=0; pidx < emptyPages.size(); pidx++) {\n        protPages_.erase(emptyPages[pidx]);\n    }\n}\n\nbool mapped_object::isSystemLib(const std::string &objname)\n{\n   std::string lowname = objname;\n   std::transform(lowname.begin(),lowname.end(),lowname.begin(),\n                  (int(*)(int))std::tolower);\n\n   if (std::string::npos != lowname.find(\"libdyninstapi_rt\"))\n      return true;\n\n#if defined(os_linux)\n   if (std::string::npos != lowname.find(\"libc.so\"))\n      return true;\n   if (std::string::npos != lowname.find(\"libpthread\"))\n      return true;\n#endif\n\n#if defined(os_freebsd)\n   if(std::string::npos != lowname.find(\"libc.so\"))\n       return true;\n   if(std::string::npos != lowname.find(\"libthr\"))\n       return true;\n#endif\n\n#if defined(os_windows)\n   if (std::string::npos != lowname.find(\"windows\\\\system32\\\\\") &&\n       std::string::npos != lowname.find(\".dll\"))\n       return true;\n   if (std::string::npos != lowname.find(\"kernel32.dll\"))\n      return true;\n   if (std::string::npos != lowname.find(\"user32.dll\"))\n      return true;\n   if (std::string::npos != lowname.find(\"advapi32.dll\"))\n      return true;\n   if (std::string::npos != lowname.find(\"ntdll.dll\"))\n      return true;\n   if (std::string::npos != lowname.find(\"msvcrt\") &&\n       std::string::npos != lowname.find(\".dll\"))\n      return true;\n   if (std::string::npos != lowname.find(\".dll\"))\n       return true; //KEVINTODO: find a reliable way of detecting windows system libraries\n#endif\n\n   return false;\n}\n\nbool mapped_object::isExploratoryModeOn()\n{\n    return BPatch_exploratoryMode == analysisMode_ ||\n           BPatch_defensiveMode == analysisMode_;\n}\n\nvoid mapped_object::addProtectedPage(Address pageAddr)\n{\n    map<Address,WriteableStatus>::iterator iter = protPages_.find(pageAddr);\n    if (protPages_.end() == iter) {\n        protPages_[pageAddr] = PROTECTED;\n    }\n    else if (PROTECTED != iter->second) {\n        iter->second = REPROTECTED;\n    }\n}\n\nvoid mapped_object::removeProtectedPage(Address pageAddr)\n{\n    map<Address,WriteableStatus>::iterator iter = protPages_.find(pageAddr);\n    if (iter == protPages_.end()) {\n        // sanity check, make sure there isn't any code on the page, in which\n        // case we're unprotecting a page that was originally set to be writeable\n        Address pageOffset = pageAddr - codeBase();\n        SymtabAPI::Region *reg = parse_img()->getObject()->findEnclosingRegion(pageOffset);\n        assert(reg);\n        set<CodeRegion*> cregs;\n        parse_img()->codeObject()->cs()->findRegions(reg->getMemOffset(), cregs);\n        if (!cregs.empty()) { // (if empty, pageAddr is in uninitialized memory)\n            ParseAPI::Block *blk = parse_img()->codeObject()->findNextBlock\n                (*cregs.begin(), pageOffset);\n            Address pageEnd =  pageOffset + proc()->proc()->getMemoryPageSize();\n            if (blk && blk->start() < pageEnd) {\n                assert(0);\n            }\n        }\n        return;\n    }\n    iter->second = UNPROTECTED;\n}\n\nvoid mapped_object::setCodeBytesUpdated(bool newval)\n{\n    if (BPatch_defensiveMode == analysisMode_) {\n        if (false == newval && newval != pagesUpdated_) {\n            expansionCheckedRegions_.clear();\n        }\n        pagesUpdated_ = newval;\n    } else {\n        cerr << \"WARNING: requesting update of code bytes from memory \"\n             <<  \"on non-defensive mapped object, ignoring request \"\n             << fileName().c_str() << \" \" << __FILE__ << __LINE__ << endl;\n    }\n}\n\n#if !( (defined(os_linux) || defined(os_freebsd)) && \\\n       (defined(arch_x86) || defined(arch_x86_64) || defined(arch_power)) )\nfunc_instance *mapped_object::findGlobalConstructorFunc(const std::string &) {\n    assert(!\"Not implemented\");\n    return NULL;\n}\n\nfunc_instance *mapped_object::findGlobalDestructorFunc(const std::string &) {\n    assert(!\"Not implemented\");\n    return NULL;\n}\n#endif\n\nbool mapped_object::isEmulInsn(Address insnAddr)\n{\n    return ( emulInsns_.end() != emulInsns_.find(insnAddr) );\n}\n\n\nvoid mapped_object::setEmulInsnVal(Address insnAddr, void * val)\n{\n    assert(emulInsns_.end() != emulInsns_.find(insnAddr));\n    emulInsns_[insnAddr] = pair<Register,void*>(emulInsns_[insnAddr].first,val);\n}\n\nRegister mapped_object::getEmulInsnReg(Address insnAddr)\n{\n    assert(emulInsns_.end() != emulInsns_.find(insnAddr));\n    return emulInsns_[insnAddr].first;\n}\n\nvoid mapped_object::addEmulInsn(Address insnAddr, Register effectiveAddrReg)\n{\n    emulInsns_[insnAddr] = pair<Register,void*>(effectiveAddrReg,(void *)0);\n}\n\nstd::string mapped_object::getCalleeName(block_instance *b) {\n   std::map<block_instance *, std::string>::iterator iter = calleeNames_.find(b);\n   if (iter != calleeNames_.end()) return iter->second;\n\n#if defined(os_windows)\n   string calleeName;\n   if (parse_img()->codeObject()->isIATcall(b->last() - codeBase(), calleeName)) {\n      setCalleeName(b, calleeName);\n      return calleeName;\n   }\n#endif\n\n   return std::string();\n}\n\nvoid mapped_object::setCalleeName(block_instance *b, std::string s) {\n   calleeNames_[b] = s;\n}\n\n// Missing\n// findEdge\n// findBlock\n// findOneBlockByAddr\n// splitBlock\n// findFuncByEntry\n// findBlock (again)\n\nedge_instance *mapped_object::findEdge(ParseAPI::Edge *e,\n                                       block_instance *src,\n                                       block_instance *trg) {\n  edge_instance *inst = SCAST_EI(getEdge(e, src, trg));\n  return inst;\n}\n\nblock_instance *mapped_object::findBlock(ParseAPI::Block *b) {\n  return SCAST_BI(getBlock(b));\n}\n\nblock_instance *mapped_object::findOneBlockByAddr(const Address addr) {\n   std::set<block_instance *> possibles;\n   findBlocksByAddr(addr, possibles);\n   for (std::set<block_instance *>::iterator iter = possibles.begin();\n        iter != possibles.end(); ++iter) {\n      block_instance::Insns insns;\n      (*iter)->getInsns(insns);\n      if (insns.find(addr) != insns.end()) {\n         return *iter;\n      }\n   }\n   return NULL;\n}\n\nvoid mapped_object::splitBlock(block_instance * b1, \n                               block_instance * b2) \n{\n    // fix block mappings in: map<block_instance *, std::string> calleeNames_\n    map<block_instance *, std::string>::iterator nit = calleeNames_.find(b1);\n    if (calleeNames_.end() != nit) {\n        string name = nit->second;\n        calleeNames_.erase(nit);\n        calleeNames_[b2] = name;\n    }\n}\n\nfunc_instance *mapped_object::findFuncByEntry(const block_instance *blk) {\n  parse_block *llb = SCAST_PB(blk->llb());\n  parse_func* f = llb->getEntryFunc();\n  if (!f) return NULL;\n  return findFunction(f);\n}\n\nfunc_instance *mapped_object::getCallee(const block_instance *b) const {\n   std::map<const block_instance *, func_instance *>::const_iterator iter = callees_.find(b);\n   if (iter == callees_.end()) return NULL;\n   return iter->second;\n}\n\nvoid mapped_object::setCallee(const block_instance *b, func_instance *f) {\n   callees_[b] = f;\n}\n\n#include \"Symtab.h\"\n\nvoid mapped_object::replacePLTStub(SymtabAPI::Symbol *sym, func_instance *orig, Address newAddr) {\n   // Let's play relocation games...\n   vector<SymtabAPI::relocationEntry> fbt;\n   bool ok = parse_img()->getObject()->getFuncBindingTable(fbt);\n   if(!ok) return;\n   \n   \n   for (unsigned i = 0; i < fbt.size(); ++i) {\n      if (fbt[i].name() == sym->getMangledName()) {\n         proc()->bindPLTEntry(fbt[i], codeBase(), orig, newAddr);\n      }\n   }\n}\n\nstring mapped_object::fileName() const { \n  return parse_img()->getObject()->name();\n  \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dyninstAPI/src/linux-power.C": "/*\n * See the dyninst/COPYRIGHT file for copyright information.\n * \n * We provide the Paradyn Tools (below described as \"Paradyn\")\n * on an AS IS basis, and do not warrant its validity or performance.\n * We reserve the right to update, modify, or discontinue this\n * software at any time.  We shall have no obligation to supply such\n * updates or modifications or any other form of support to you.\n * \n * By your use of Paradyn, you understand and agree that we (or any\n * other person or entity with proprietary rights in Paradyn) are\n * under no obligation to provide either maintenance services,\n * update services, notices of latent defects, or correction of\n * defects for Paradyn.\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n// $Id: linux-power.C,v 1.19 2008/06/19 19:53:26 legendre Exp $\n\n#include <string>\n#include <dlfcn.h>\n\n#include \"dyninstAPI/src/linux-power.h\"\n#include \"dyninstAPI/src/addressSpace.h\"\n#include \"dyninstAPI/src/dynProcess.h\"\n#include \"dyninstAPI/src/frame.h\"\n#include \"dyninstAPI/src/debug.h\"\n#include \"dyninstAPI/src/mapped_object.h\"\n#include \"dyninstAPI/src/inst-power.h\"\n#include \"dyninstAPI/src/baseTramp.h\"\n#include \"dyninstAPI/src/registerSpace.h\"\n#include \"dyninstAPI/src/function.h\"\n\n#define DLOPEN_MODE (RTLD_NOW | RTLD_GLOBAL)\n\nconst char DL_OPEN_FUNC_EXPORTED[] = \"dlopen\";\nconst char DL_OPEN_FUNC_INTERNAL[] = \"_dl_open\";\nconst char DL_OPEN_FUNC_NAME[] = \"do_dlopen\";\nconst char DL_OPEN_LIBC_FUNC_EXPORTED[] = \"__libc_dlopen_mode\";\n\nAddress PCProcess::getLibcStartMainParam(PCThread *) {\n    assert(!\"This function is unimplemented\");\n    return 0;\n}\n\nAddress PCProcess::getTOCoffsetInfo(Address dest) {\n    if ( getAddressWidth() == 4 ) return 0;\n\n    // We have an address, and want to find the module the addr is\n    // contained in. Given the probabilities, we (probably) want\n    // the module dyninst_rt is contained in.\n    // I think this is the right func to use\n\n    // Find out which object we're in (by addr).\n    mapped_object *mobj = findObject(dest);\n\n    // Very odd case if this is not defined.\n    assert(mobj);\n    Address TOCOffset = mobj->parse_img()->getObject()->getTOCoffset();\n    \n    if (!TOCOffset)\n       return 0;\n    return TOCOffset + mobj->dataBase();\n}\n\nAddress PCProcess::getTOCoffsetInfo(func_instance *func) {\n    if ( getAddressWidth() == 4 ) return 0;\n\n    mapped_object *mobj = func->obj();\n\n    return mobj->parse_img()->getObject()->getTOCoffset() + mobj->dataBase();\n}\n\nbool PCProcess::getOPDFunctionAddr(Address &addr) {\n    bool result = true;\n    if( getAddressWidth() == 8 ) {\n        Address resultAddr = 0;\n        if( !readDataSpace((const void *)addr, getAddressWidth(),\n                    (void *)&resultAddr, false) ) \n        {\n            result = false;\n        }else{\n            addr = resultAddr;\n       }\n    }\n    return result;\n}\n\nAstNodePtr PCProcess::createUnprotectStackAST() {\n    // This is not necessary on power\n    return AstNode::nullNode();\n}\n\nbool Frame::setPC(Address newpc) {\n   Address pcAddr = getPClocation();\n   if (!pcAddr)\n   {\n       //fprintf(stderr, \"[%s:%u] - Frame::setPC aborted\", __FILE__, __LINE__);\n      return false;\n   }\n\n   //fprintf(stderr, \"[%s:%u] - Frame::setPC setting %x to %x\",\n   //__FILE__, __LINE__, pcAddr_, newpc);\n   if (getProc()->getAddressWidth() == sizeof(uint64_t)) {\n      uint64_t newpc64 = newpc;\n      if (!getProc()->writeDataSpace((void*)pcAddr, sizeof(newpc64), &newpc64))\n         return false;\n      sw_frame_.setRA(newpc64);\n   }\n   else {\n      uint32_t newpc32 = newpc;\n      if (!getProc()->writeDataSpace((void*)pcAddr, sizeof(newpc32), &newpc32))\n         return false;\n      sw_frame_.setRA(newpc32);\n   }\n\n   return true;\n}\n\nbool AddressSpace::getDyninstRTLibName() {\n//full path to libdyninstAPI_RT (used an _m32 suffix for 32-bit version)\n    startup_printf(\"dyninstRT_name: %s\\n\", dyninstRT_name.c_str());\n    if (dyninstRT_name.length() == 0) {\n        // Get env variable\n        if (getenv(\"DYNINSTAPI_RT_LIB\") != NULL) {\n            dyninstRT_name = getenv(\"DYNINSTAPI_RT_LIB\");\n        }\n        else {\n            std::string msg = std::string(\"Environment variable \") +\n                std::string(\"DYNINSTAPI_RT_LIB\") +\n               std::string(\" has not been defined\");\n            showErrorCallback(101, msg);\n            return false;\n        }\n    }\n\n    // Automatically choose 32-bit library if necessary.\n    const char *modifier = \"\";\n    const char *name = dyninstRT_name.c_str();\n\n    const char *split = P_strrchr(name, '/');\n    if ( !split ) split = name;\n    split = P_strchr(split, '.');\n    if ( !split || P_strlen(split) <= 1 ) {\n        // We should probably print some error here.\n        // Then, of course, the user will find out soon enough.\n        startup_printf(\"Invalid Dyninst RT lib name: %s\\n\", \n                dyninstRT_name.c_str());\n        return false;\n    }\n\n    if (getAddressWidth() == 4 &&\n        (sizeof(void *) == 8)) {\n       // Need _m32...\n       if (P_strstr(name, \"_m32\") == NULL) {\n          modifier = \"_m32\";\n       }\n    }\n\n    const char *suffix = split;\n    if( getAOut()->isStaticExec() ) {\n        suffix = \".a\";\n    }else{\n        if( P_strncmp(suffix, \".a\", 2) == 0 ) {\n            // This will be incorrect if the RT library's version changes\n            suffix = \".so\";\n        }\n    }\n\n    dyninstRT_name = std::string(name, split - name) +\n                     std::string(modifier) +\n                     std::string(suffix);\n\n    startup_printf(\"Dyninst RT Library name set to '%s'\\n\",\n            dyninstRT_name.c_str());\n\n    // Check to see if the library given exists.\n    if (access(dyninstRT_name.c_str(), R_OK)) {\n        std::string msg = std::string(\"Runtime library \") + dyninstRT_name\n        + std::string(\" does not exist or cannot be accessed!\");\n        showErrorCallback(101, msg);\n\tcerr << msg << endl;\n        return false;\n    }\n    return true;\n}\n\n// floor of inferior malloc address range within a single branch of x\n// for 32-bit ELF PowerPC mutatees\nAddress region_lo(const Address x) {\n   const Address floor = getpagesize();\n\n   assert(x >= floor);\n\n   if ((x > floor) && (x - floor > getMaxBranch()))\n      return x - getMaxBranch();\n\n   return floor;\n}\n\n\n// floor of inferior malloc address range within a single branch of x\n// for 64-bit ELF PowerPC mutatees\nAddress region_lo_64(const Address x) {\n   const Address floor = getpagesize();\n\n   assert(x >= floor);\n\n   if ((x > floor) && (x - floor > getMaxBranch()))\n      return x - getMaxBranch();\n\n   return floor;\n}\n\n\n// ceiling of inferior malloc address range within a single branch of x\n// for 32-bit ELF PowerPC mutatees\nAddress region_hi(const Address x) {\n   const Address ceiling = ~(Address)0 & 0xffffffff;\n\n   assert(x < ceiling);\n\n   if ((x < ceiling) && (ceiling - x > getMaxBranch()))\n      return x + getMaxBranch();\n\n   return ceiling;\n}\n\n\n// ceiling of inferior malloc address range within a single branch of x\n// for 64-bit ELF PowerPC mutatees\nAddress region_hi_64(const Address x) {\n   const Address ceiling = ~(Address)0;\n\n   assert(x < ceiling);\n\n   if ((x < ceiling) && (ceiling - x > getMaxBranch()))\n      return x + getMaxBranch();\n\n   return ceiling;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/symtabapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/symtab-text.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/symtabAPI/doc/API/Symtab/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/patchapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/figure/abstraction/img.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/patchAPI/doc/figure/command/img.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/.git/objects/pack/pack-593da7349d733fdcdb7163ec158abe109f63e7ae.pack",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/.git/objects/pack/pack-593da7349d733fdcdb7163ec158abe109f63e7ae.idx",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/parseAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/parseAPI/doc/parseapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/stackwalk/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/stackwalk/doc/stackwalkerapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/instructionapi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/instruction_representation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/ownership_graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/refman.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/decoder_use.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/full_inheritance_graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/deref-eval.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/instructionAPI/doc/fig/ast_ownership.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dynC_API/doc/paradyn_logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dyninst-8.2.1-ocgakd7jz756m4psrtry427465kkqwyu/spack-src/dynC_API/doc/dyncapi.pdf"
    ],
    "total_files": 1164
}