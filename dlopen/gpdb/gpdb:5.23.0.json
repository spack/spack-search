{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/configure.in": "dnl Process this file with autoconf to produce a configure script.\ndnl $PostgreSQL: pgsql/configure.in,v 1.546.2.16 2010/05/14 03:27:07 scrappy Exp $\ndnl\ndnl Developers, please strive to achieve this order:\ndnl\ndnl 0. Initialization and options processing\ndnl 1. Programs\ndnl 2. Libraries\ndnl 3. Header files\ndnl 4. Types\ndnl 5. Structures\ndnl 6. Compiler characteristics\ndnl 7. Functions, global variables\ndnl 8. System services\ndnl\ndnl Read the Autoconf manual for details.\ndnl\nm4_pattern_forbid(^PGAC_)dnl to catch undefined macros\n\ndnl The PACKAGE_VERSION from upstream PostgreSQL is maintained in the\ndnl PG_PACKAGE_VERSION variable, when merging make sure to update this\ndnl variable with the merge conflict from the AC_INIT() statement.\nAC_INIT([Greenplum Database], [5.0.0], [support@greenplum.org])\n[PG_PACKAGE_VERSION=8.3.23]\nAC_SUBST(PG_PACKAGE_VERSION)\n\ndnl m4_if(m4_defn([m4_PACKAGE_VERSION]), [2.63], [], [m4_fatal([Autoconf version 2.63 is required.\ndnl Untested combinations of 'autoconf' and PostgreSQL versions are not\ndnl recommended.  You can remove the check from 'configure.in' but it is then\ndnl your responsibility whether the result works or not.])])\nAC_COPYRIGHT([Copyright (c) 1996-2010, PostgreSQL Global Development Group])\nAC_CONFIG_SRCDIR([src/backend/access/common/heaptuple.c])\nAC_CONFIG_AUX_DIR(config)\nAC_PREFIX_DEFAULT(/usr/local/gpdb)\nAC_SUBST(configure_args, [$ac_configure_args])\n\n[PG_MAJORVERSION=`expr \"$PG_PACKAGE_VERSION\" : '\\([0-9][0-9]*\\.[0-9][0-9]*\\)'`]\nAC_SUBST(PG_MAJORVERSION)\nAC_DEFINE_UNQUOTED(PG_MAJORVERSION, \"$PG_MAJORVERSION\", [PostgreSQL major version as a string])\n\n[PG_VERSION=\"$PG_PACKAGE_VERSION\"]\ndnl Greenplum co-opts the --with-extra-version value to append to Only the Greenplum version\nPGAC_ARG_REQ(with, extra-version, [STRING], [append STRING to version], [], [])\nAC_DEFINE_UNQUOTED(PG_VERSION, \"$PG_PACKAGE_VERSION\", [Postgres version Greenplum Database is based on])\n\nAC_CANONICAL_HOST\n\ntemplate=\nAC_MSG_CHECKING([which template to use])\n\nPGAC_ARG_REQ(with, template, [],\n[\n  case $withval in\n    list)   echo; ls \"$srcdir/src/template\"; exit;;\n    *)      if test -f \"$srcdir/src/template/$with_template\" ; then\n              template=$withval\n            else\n              AC_MSG_ERROR(['$withval' is not a valid template name. Use 'list' for a list.])\n            fi;;\n  esac\n],\n[\n# --with-template not given\n\ncase $host_os in\n     aix*) template=aix ;;\n    bsdi*) template=bsdi ;;\n  cygwin*) template=cygwin ;;\n  darwin*) template=darwin ;;\ndragonfly*) template=netbsd ;;\n    dgux*) template=dgux ;;\n freebsd*) template=freebsd ;;\n    hpux*) template=hpux ;;\n    irix*) template=irix ;;\n linux*|gnu*|k*bsd*-gnu)\n           template=linux ;;\n   mingw*) template=win32 ;;\n  netbsd*) template=netbsd ;;\nnextstep*) template=nextstep ;;\n openbsd*) template=openbsd ;;\n     osf*) template=osf ;;\n     sco*) template=sco ;;\n solaris*) template=solaris ;;\n   sunos*) template=sunos4 ;;\n sysv4.2*)\n        case $host_vendor in\n          univel) template=univel ;;\n        esac ;;\n   sysv4*) template=svr4 ;;\n   sysv5*) template=unixware ;;\n  ultrix*) template=ultrix4 ;;\nesac\n\n  if test x\"$template\" = x\"\" ; then\n    AC_MSG_ERROR([[\n*******************************************************************\nPostgreSQL has apparently not been ported to your platform yet.\nTo try a manual configuration, look into the src/template directory\nfor a similar platform and use the '--with-template=' option.\n\nPlease also contact <bugs@greenplum.org> to see about\nrectifying this.  Include the above 'checking host system type...'\nline.\n*******************************************************************\n]])\n  fi\n\n])\n\nAC_MSG_RESULT([$template])\n\nPORTNAME=$template\nAC_SUBST(PORTNAME)\n\n# Initialize default assumption that we do not need separate assembly code\n# for TAS (test-and-set).  This can be overridden by the template file\n# when it's executed.\nneed_tas=no\ntas_file=dummy.s\n\n\n\n##\n## Command line options\n##\n\n#\n# Installation directory for documentation\n#\nPGAC_ARG(with, docdir, [  --with-docdir=DIR       install the documentation in DIR [[PREFIX/doc]]\n  --without-docdir        do not install the documentation],\n         [AC_MSG_ERROR([option --with-docdir requires an argument])],\n         [docdir=],\n         [docdir=$withval],\n         [docdir='${prefix}/doc'])\nAC_SUBST(docdir)\n\n\n#\n# Add non-standard directories to the include path\n#\nPGAC_ARG_REQ(with, includes, [  --with-includes=DIRS    look for additional header files in DIRS])\n\n\n#\n# Add non-standard directories to the library search path\n#\nPGAC_ARG_REQ(with, libraries, [  --with-libraries=DIRS   look for additional libraries in DIRS],\n             [LIBRARY_DIRS=$withval])\n\nPGAC_ARG_REQ(with, libs,      [  --with-libs=DIRS        alternative spelling of --with-libraries],\n             [LIBRARY_DIRS=$withval])\n\n\n#\n# 64-bit integer date/time storage: enabled by default.\n#\nAC_MSG_CHECKING([whether to build with 64-bit integer date/time support])\nPGAC_ARG_BOOL(enable, integer-datetimes, yes, [  --disable-integer-datetimes disable 64-bit integer date/time support],\n              [AC_DEFINE([USE_INTEGER_DATETIMES], 1,\n                         [Define to 1 if you want 64-bit integer timestamp and interval support. (--enable-integer-datetimes)])])\nAC_MSG_RESULT([$enable_integer_datetimes])\n\n\n#\n# NLS\n#\n# NLS is not supported in Greenplum. There's no fundamental reason for it,\n# but no-one's kept the translations up-to-date. The .po files have been\n# removed from the repository, so it won't work if you just uncomment the\n# below block. If we wanted to enable NLS support, we should come up with a\n# scheme to use the upstream PostgreSQL .po files as is, to make merging\n# easier, and provide additional .po files for all the Greenplum-specific\n# strings.\n# to the users to let them build with very incomplete translations.\n#AC_MSG_CHECKING([whether NLS is wanted])\n#PGAC_ARG_OPTARG(enable, nls,\n#                [[  --enable-nls[=LANGUAGES]  enable Native Language Support]],\n#                [],\n#                [WANTED_LANGUAGES=$enableval],\n#                [AC_DEFINE(ENABLE_NLS, 1,\n#                           [Define to 1 if you want National Language Support. (--enable-nls)])])\n#AC_MSG_RESULT([$enable_nls])\n#AC_SUBST(enable_nls)\n#AC_SUBST(WANTED_LANGUAGES)\n\n#\n# Default port number (--with-pgport), default 5432\n#\nAC_MSG_CHECKING([for default port number])\nPGAC_ARG_REQ(with, pgport, [  --with-pgport=PORTNUM   change default port number [[5432]]],\n             [default_port=$withval],\n             [default_port=5432])\nAC_MSG_RESULT([$default_port])\n# Need both of these because some places want an integer and some a string\nAC_DEFINE_UNQUOTED(DEF_PGPORT, ${default_port},\n[Define to the default TCP port number on which the server listens and\nto which clients will try to connect.  This can be overridden at run-time,\nbut it's convenient if your clients have the right default compiled in.\n(--with-pgport=PORTNUM)])\nAC_DEFINE_UNQUOTED(DEF_PGPORT_STR, \"${default_port}\",\n                   [Define to the default TCP port number as a string constant.])\nAC_SUBST(default_port)\n\n#\n# Option to disable shared libraries\n#\nPGAC_ARG_BOOL(enable, shared, yes,\n              [  --disable-shared        do not build shared libraries])\nAC_SUBST(enable_shared)\n\n#\n# '-rpath'-like feature can be disabled\n#\nPGAC_ARG_BOOL(enable, rpath, yes,\n              [  --disable-rpath         do not embed shared library search path in executables])\nAC_SUBST(enable_rpath)\n\n#\n# Spinlocks\n#\nPGAC_ARG_BOOL(enable, spinlocks, yes,\n              [  --disable-spinlocks     do not use spinlocks])\n\n#\n# Atomic operations\n#\nPGAC_ARG_BOOL(enable, atomics, yes,\n              [  --disable-atomics       do not use atomic operations])\n\n#\n# gpfdist\n#\nPGAC_ARG_BOOL(enable, gpfdist, yes,\n             [  --disable-gpfdist       do not use gpfdist])\nAC_SUBST(enable_gpfdist)\n\n#\n# pxf\n#\nPGAC_ARG_BOOL(enable, pxf, yes,\n             [  --enable-pxf            build with pxf])\nAC_SUBST(enable_pxf)\n\n#\n# gphdfs\n#\nPGAC_ARG_BOOL(enable, gphdfs, no,\n             [  --enable-gphdfs         build with gphdfs])\nAC_SUBST(enable_gphdfs)\n\n#\n# --enable-gpperfmon\n#\nPGAC_ARG_BOOL(enable, gpperfmon, no,\n              [  --enable-gpperfmon      build with gpperfmon])\nAC_SUBST(enable_gpperfmon)\n\n#\n# --enable-debug adds -g to compiler flags\n#\nPGAC_ARG_BOOL(enable, debug, no,\n              [  --enable-debug          build with debugging symbols (-g)])\nAC_SUBST(enable_debug)\n\n#\n# --enable-profiling enables gcc profiling\n#\nPGAC_ARG_BOOL(enable, profiling, no,\n              [  --enable-profiling      build with profiling enabled ])\nAC_SUBST(enable_profiling)\n\n#\n# --enable-coverage enables generation of code coverage metrics with gcov\n#\nPGAC_ARG_BOOL(enable, coverage, no,\n              [  --enable-coverage       build with coverage testing instrumentation],\n[AC_CHECK_PROGS(GCOV, gcov)\nif test -z \"$GCOV\"; then\n  AC_MSG_ERROR([gcov not found])\nfi\nAC_CHECK_PROGS(LCOV, lcov)\nif test -z \"$LCOV\"; then\n  AC_MSG_ERROR([lcov not found])\nfi\nAC_CHECK_PROGS(GENHTML, genhtml)\nif test -z \"$GENHTML\"; then\n  AC_MSG_ERROR([genhtml not found])\nfi])\nAC_SUBST(enable_coverage)\n\n#\n# DTrace\n#\nPGAC_ARG_BOOL(enable, dtrace, no,\n              [  --enable-dtrace         build with DTrace support],\n[AC_DEFINE([ENABLE_DTRACE], 1,\n           [Define to 1 to enable DTrace support. (--enable-dtrace)])\nAC_CHECK_PROGS(DTRACE, dtrace)\nif test -z \"$DTRACE\"; then\n  AC_MSG_ERROR([dtrace not found])\nfi\nAC_SUBST(DTRACEFLAGS)])\nAC_SUBST(enable_dtrace)\n\n#\n# TAP tests\n#\nPGAC_ARG_BOOL(enable, tap-tests, no,\n              [  --enable-tap-tests      enable TAP tests (requires Perl and IPC::Run)])\nAC_SUBST(enable_tap_tests)\n\n#\n# C compiler\n#\n\n# For historical reasons you can also use --with-CC to specify the C compiler\n# to use, although the standard way to do this is to set the CC environment\n# variable.\nPGAC_ARG_REQ(with, CC, [], [CC=$with_CC])\n\ncase $template in\n  aix) pgac_cc_list=\"gcc xlc\";;\n irix) pgac_cc_list=\"cc\";; # no gcc\n    *) pgac_cc_list=\"gcc cc\";;\nesac\n\nAC_PROG_CC([$pgac_cc_list])\n\n#\n# C++ compiler\n#\n#\n# AC_PROG_CXX will add \"-g -O2\" to CXXFLAGS, if CXXFLAGS was not already set.\n# We don't want that, because we derive CXXFLAGS from CFLAGS later on. Set\n# CXXFLAGS to an empty string explicitly before invoking AC_PROG_CXX, to\n# avoid that.\nac_save_CXXFLAGS=$CXXFLAGS\nCXXFLAGS=\"\"\nAC_PROG_CXX\nCXXFLAGS=$ac_save_CXXFLAGS\n\n# Check if it's Intel's compiler, which (usually) pretends to be gcc,\n# but has idiosyncrasies of its own.  We assume icc will define\n# __INTEL_COMPILER regardless of CFLAGS.\nAC_TRY_COMPILE([], [@%:@ifndef __INTEL_COMPILER\nchoke me\n@%:@endif], [ICC=[yes]], [ICC=[no]])\n\nunset CFLAGS\n\n#\n# Read the template\n#\n. \"$srcdir/src/template/$template\" || exit\n\n# CFLAGS are selected so:\n# If the user specifies something in the environment, that is used.\n# else:  If the template file set something, that is used.\n# else:  If coverage was enabled, don't set anything.\n# else:  If the compiler is GCC, then we use -O3.\n# else:  If the compiler is something else, then we use -O, unless debugging.\n\nif test \"$ac_env_CFLAGS_set\" = set; then\n  CFLAGS=$ac_env_CFLAGS_value\nelif test \"${CFLAGS+set}\" = set; then\n  : # (keep what template set)\nelif test \"$enable_coverage\" = yes; then\n  : # no optimization by default\nelif test \"$GCC\" = yes; then\n  CFLAGS=\"-O3\"\nelse\n  # if the user selected debug mode, don't use -O\n  if test \"$enable_debug\" != yes; then\n    CFLAGS=\"-O\"\n  fi\nfi\n\n# For GPDB, Use C99, rather than C89, compile rules\n#\n#\nif test \"$GCC\" = yes; then\n  if test \"$ICC\" = yes; then\n    CFLAGS=\"$CFLAGS -c99 \"\n  else\n    CFLAGS=\"$CFLAGS -std=gnu99 \"\n  fi\nfi\n\n\n# Check for x86 cpuid instruction to determine if we can perform a\n# runtime check\nAC_CACHE_CHECK([for __get_cpuid], [pgac_cv__get_cpuid],\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <cpuid.h>],\n  [[unsigned int exx[4] = {0, 0, 0, 0};\n  __get_cpuid(1, &exx[0], &exx[1], &exx[2], &exx[3]);\n  ]])],\n  [pgac_cv__get_cpuid=\"yes\"],\n  [pgac_cv__get_cpuid=\"no\"])])\nif test x\"$pgac_cv__get_cpuid\" = x\"yes\"; then\n  AC_DEFINE(HAVE__GET_CPUID, 1, [Define to 1 if you have __get_cpuid.])\nfi\n\nAC_CACHE_CHECK([for __cpuid], [pgac_cv__cpuid],\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <intrin.h>],\n  [[unsigned int exx[4] = {0, 0, 0, 0};\n  __get_cpuid(exx[0], 1);\n  ]])],\n  [pgac_cv__cpuid=\"yes\"],\n  [pgac_cv__cpuid=\"no\"])])\nif test x\"$pgac_cv__cpuid\" = x\"yes\"; then\n  AC_DEFINE(HAVE__CPUID, 1, [Define to 1 if you have __cpuid.])\nfi\n\n# Check for Intel SSE 4.2 intrinsics to do CRC calculations.\n#\n# First check if the _mm_crc32_u8 and _mm_crc32_u64 intrinsics can be used\n# with the default compiler flags. If not, check if adding the -msse4.2\n# flag helps. CFLAGS_SSE42 is set to -msse4.2 if that's required.\nPGAC_SSE42_CRC32_INTRINSICS([])\nif test x\"$pgac_sse42_crc32_intrinsics\" != x\"yes\"; then\n  PGAC_SSE42_CRC32_INTRINSICS([-msse4.2])\nfi\nAC_SUBST(CFLAGS_SSE42)\n\n# Are we targeting a processor that supports SSE 4.2? gcc, clang and icc all\n# define __SSE4_2__ in that case.\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [\n#ifndef __SSE4_2__\n#error __SSE4_2__ not defined\n#endif\n])], [SSE4_2_TARGETED=1])\n\n# Select CRC-32C implementation.\n#\n# If we are targeting a processor that has SSE 4.2 instructions, we can use the\n# special CRC instructions for calculating CRC-32C. If we're not targeting such\n# a processor, but we can nevertheless produce code that uses the SSE\n# intrinsics, perhaps with some extra CFLAGS, compile both implementations and\n# select which one to use at runtime, depending on whether SSE 4.2 is supported\n# by the processor we're running on.\n#\n# You can override this logic by setting the appropriate USE_*_CRC32 flag to 1\n# in the template or configure command line.\nif test x\"$USE_SSE42_CRC32C\" = x\"\" && test x\"$USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\" = x\"\" && test x\"$USE_SLICING_BY_8_CRC32C\" = x\"\"; then\n  if test x\"$pgac_sse42_crc32_intrinsics\" = x\"yes\" && test x\"$SSE4_2_TARGETED\" = x\"1\" ; then\n    USE_SSE42_CRC32C=1\n  else\n    # the CPUID instruction is needed for the runtime check.\n    if test x\"$pgac_sse42_crc32_intrinsics\" = x\"yes\" && (test x\"$pgac_cv__get_cpuid\" = x\"yes\" || test x\"$pgac_cv__cpuid\" = x\"yes\"); then\n      USE_SSE42_CRC32C_WITH_RUNTIME_CHECK=1\n    else\n      # fall back to slicing-by-8 algorithm which doesn't require any special\n      # CPU support.\n      USE_SLICING_BY_8_CRC32C=1\n    fi\n  fi\nfi\n\n# Set PG_CRC32C_OBJS appropriately depending on the selected implementation.\nAC_MSG_CHECKING([which CRC-32C implementation to use])\nif test x\"$USE_SSE42_CRC32C\" = x\"1\"; then\n  AC_DEFINE(USE_SSE42_CRC32C, 1, [Define to 1 use Intel SSE 4.2 CRC instructions.])\n  PG_CRC32C_OBJS=\"pg_crc32c_sse42.o\"\n  AC_MSG_RESULT(SSE 4.2)\nelse\n  if test x\"$USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\" = x\"1\"; then\n    AC_DEFINE(USE_SSE42_CRC32C_WITH_RUNTIME_CHECK, 1, [Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check.])\n    PG_CRC32C_OBJS=\"pg_crc32c_sse42.o pg_crc32c_sb8.o pg_crc32c_choose.o\"\n    AC_MSG_RESULT(SSE 4.2 with runtime check)\n  else\n    AC_DEFINE(USE_SLICING_BY_8_CRC32C, 1, [Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check.])\n    PG_CRC32C_OBJS=\"pg_crc32c_sb8.o\"\n    AC_MSG_RESULT(slicing-by-8)\n  fi\nfi\nAC_SUBST(PG_CRC32C_OBJS)\n\n\n# set CFLAGS_VECTOR from the environment, if available\nif test \"$ac_env_CFLAGS_VECTOR_set\" = set; then\n  CFLAGS_VECTOR=$ac_env_CFLAGS_VECTOR_value\nfi\n\n# Some versions of GCC support some additional useful warning flags.\n# Check whether they are supported, and add them to CFLAGS if so.\n# ICC pretends to be GCC but it's lying; it doesn't support these options.\n\nif test \"$GCC\" = yes -a \"$ICC\" = no; then\n  CFLAGS=\"$CFLAGS -Wall -Wmissing-prototypes -Wpointer-arith\"\n  # These work in some but not all gcc versions\n  # GPDB code is full of declarations after statement.\n  #PGAC_PROG_CC_CFLAGS_OPT([-Wdeclaration-after-statement])\n  PGAC_PROG_CC_CFLAGS_OPT([-Wendif-labels])\n  # This was included in -Wall/-Wformat in older GCC versions\n  PGAC_PROG_CC_CFLAGS_OPT([-Wformat-security])\n  # Disable strict-aliasing rules; needed for gcc 3.3+\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-strict-aliasing])\n  # Disable optimizations that assume no overflow; needed for gcc 4.3+\n  PGAC_PROG_CC_CFLAGS_OPT([-fwrapv])\n  # Disable FP optimizations that cause various errors on gcc 4.5+ or maybe 4.6+\n  PGAC_PROG_CC_CFLAGS_OPT([-fexcess-precision=standard])\n  # Disable loop optimizations that get confused by variable-length struct\n  # declarations in gcc 4.8+\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-aggressive-loop-optimizations])\n\n  # Silence compiler warnings that you get with modern versions of GCC.\n  # All of these warnings have been fixed in later versions of PostgreSQL,\n  # but GPDB is based on 8.2, so you get these. TODO: Remove when we catch up\n  # with later PostgreSQL releases.\n  PGAC_PROG_CC_CFLAGS_OPT([-Wno-unused-but-set-variable])\n  PGAC_PROG_CC_CFLAGS_OPT([-Wno-address])\n\n  #-Wno-error=enum-compare -Wno-error=address -Wno-error=maybe-uninitialized\n\n  # Optimization flags for specific files that benefit from vectorization\n  PGAC_PROG_CC_VAR_OPT(CFLAGS_VECTOR, [-funroll-loops])\n  PGAC_PROG_CC_VAR_OPT(CFLAGS_VECTOR, [-ftree-vectorize])\n  # We want to suppress clang's unhelpful unused-command-line-argument warnings\n  # but gcc won't complain about unrecognized -Wno-foo switches, so we have to\n  # test for the positive form and if that works, add the negative form\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wunused-command-line-argument])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-unused-command-line-argument\"\n  fi\n  # Similarly disable useless truncation warnings from gcc 8+\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wformat-truncation])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-format-truncation\"\n  fi\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wstringop-truncation])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-stringop-truncation\"\n  fi\nelif test \"$ICC\" = yes; then\n  # Intel's compiler has a bug/misoptimization in checking for\n  # division by NAN (NaN == 0), -mp1 fixes it, so add it to the CFLAGS.\n  PGAC_PROG_CC_CFLAGS_OPT([-mp1])\n  # Make sure strict aliasing is off (though this is said to be the default)\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-strict-aliasing])\nelif test x\"${CC}\" = x\"xlc\"; then\n  # AIX xlc has to have strict aliasing turned off too\n  PGAC_PROG_CC_CFLAGS_OPT([-qnoansialias])\nfi\n\nAC_SUBST(CFLAGS_VECTOR, $CFLAGS_VECTOR)\n\n# supply -g if --enable-debug\nif test \"$enable_debug\" = yes && test \"$ac_cv_prog_cc_g\" = yes; then\n  if test \"$GCC\" = yes; then\n  \tCFLAGS=\"$CFLAGS -g -ggdb\"\n  else\n    CFLAGS=\"$CFLAGS -g\"\n  fi\nfi\n\n# enable code coverage if --enable-coverage\nif test \"$enable_coverage\" = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"$CFLAGS -fprofile-arcs -ftest-coverage\"\n  else\n    AC_MSG_ERROR([--enable-coverage is supported only when using GCC])\n  fi\nfi\n\n# enable profiling if --enable-profiling\nif test \"$enable_profiling\" = yes && test \"$ac_cv_prog_cc_g\" = yes; then\n  if test \"$GCC\" = yes; then\n    AC_DEFINE([PROFILE_PID_DIR], 1,\n           [Define to 1 to allow profiling output to be saved separately for each process.])\n    CFLAGS=\"$CFLAGS -pg $PLATFORM_PROFILE_FLAGS\"\n  else\n    AC_MSG_ERROR([--enable-profiling is supported only when using GCC])\n  fi\nfi\n\n# We already have this in Makefile.win32, but configure needs it too\nif test \"$PORTNAME\" = \"win32\"; then\n  CPPFLAGS=\"$CPPFLAGS -I$srcdir/src/include/port/win32 -IgpAux/ext/win32/kfw-3-2-2/inc/krb5 -IgpAux/ext/win32/kfw-3-2-2/inc/krb5/gssapi -LgpAux/ext/win32/kfw-3-2-2/lib  -DEXEC_BACKEND -DUNSAFE_STAT_OK\"\n\nfi\n\n# Check if the compiler still works with the template settings\nAC_MSG_CHECKING([whether the C compiler still works])\nAC_TRY_LINK([], [return 0;],\n  [AC_MSG_RESULT(yes)],\n  [AC_MSG_RESULT(no)\n   AC_MSG_ERROR([cannot proceed])])\n\n# Defend against gcc -ffast-math\nif test \"$GCC\" = yes; then\nAC_TRY_COMPILE([], [@%:@ifdef __FAST_MATH__\nchoke me\n@%:@endif], [], [AC_MSG_ERROR([do not put -ffast-math in CFLAGS])])\nfi\n\n# Since PostgreSQL is written in pure C, all the tests in this file\n# add necessary flags to CFLAGS only. We have some C++ code in\n# src/backend/gpopt, so we must also configure CXXFLAGS in the same way.\n# However, some CFLAGS might not be applicable to C++, so we cannot just\n# use CFLAGS as is with the C++ compiler. Derive CXXFLAGS from CFLAGS,\n# by picking those CFLAGS that also work with the C++ compiler.\n#\n# This assumes that the C++ compiler is roughly compatible with the C\n# compiler, and accepts the same flags. While we test that each flag works\n# with the C++ compiler, we would miss any flags that we would need for\n# the C++ compiler, but not for the C compiler. For example, if you tried\n# to use CC=clang and CXX=g++, we would not know to apply flags that are\n# needed for g++, but not by clang. So don't mix and match compiler\n# families!\n\n# Loop over all options in CFLAGS, and check if they also work with CXX.\n# Add to CXXFLAGS those that do.\nfor cflag in $CFLAGS; do\n  PGAC_PROG_CXX_CXXFLAGS_OPT($cflag)\ndone\n\n\nAC_PROG_CPP\nAC_SUBST(GCC)\n\n[BLD_ARCH=`echo $BLD_ARCH`]\nAC_SUBST(BLD_ARCH)\n\n# Get the Greenplum version string from VERSION\n\nGP_VERSION_LONG=`bash ./getversion`\n\nGP_VERSION_LONG=\"$GP_VERSION_LONG$with_extra_version\"\n\necho $GP_VERSION_LONG > VERSION\nGP_VERSION=`cat VERSION`\n\nGP_VERSION_SHORT=`bash ./getversion --short`\nGP_VERSION_SHORT=\"$GP_VERSION_SHORT$with_extra_version\"\nAC_SUBST(GP_VERSION_SHORT)\n\nGP_VERSION_IN=\"src/include/catalog/gp_version.in\"\nGP_VERSION_HEADER=\"src/include/catalog/gp_version.h\"\nif grep '\\$\\$' $GP_VERSION_IN > /dev/null 2>&1 ; then\n    sed \"s,\\\\$.*\\\\$\\\\$,$GP_VERSION,\" $GP_VERSION_IN > $GP_VERSION_HEADER\nfi\n\nGP_BASH_VERSION_IN=\"gpMgmt/bin/lib/gp_bash_version.sh.in\"\nGP_BASH_VERSION_SH=\"gpMgmt/bin/lib/gp_bash_version.sh\"\nif grep '##' $GP_BASH_VERSION_IN > /dev/null 2>&1 ; then\n    sed \"s,##.*##,$GP_VERSION,\" $GP_BASH_VERSION_IN > $GP_BASH_VERSION_SH\nfi\n\nAC_DEFINE_UNQUOTED(GP_VERSION,\n                   [\"$GP_VERSION\"],\n                   [A string containing the Greenplum version number])\n\n[GP_MAJORVERSION=`expr \"$GP_VERSION\" : '\\([0-9][0-9]*\\)'`]\nAC_SUBST(GP_MAJORVERSION)\nAC_DEFINE_UNQUOTED(GP_MAJORVERSION, \"$GP_MAJORVERSION\", [Greenplum major version as a string])\n\n\n#\n# Set up TAS assembly code if needed; the template file has now had its\n# chance to request this.\n#\nAC_CONFIG_LINKS([src/backend/port/tas.s:src/backend/port/tas/${tas_file}])\n\nif test \"$need_tas\" = yes ; then\n  TAS=tas.o\nelse\n  TAS=\"\"\nfi\nAC_SUBST(TAS)\n\n\n#\n# Automatic dependency tracking\n#\nPGAC_ARG_BOOL(enable, depend, no, [  --enable-depend         turn on automatic dependency tracking],\n              [autodepend=yes])\nAC_SUBST(autodepend)\n\n\n#\n# Enable assert checks\n#\nPGAC_ARG_BOOL(enable, cassert, no, [  --enable-cassert        enable assertion checks (for debugging)],\n              [AC_DEFINE([USE_ASSERT_CHECKING], 1,\n                         [Define to 1 to build with assertion checks. (--enable-cassert)])])\n\n#\n# Enable debug_break\n#\nPGAC_ARG_BOOL(enable, debugbreak, no, [  --enable-debugbreak     enable debug_break and debug_break_n (for debugging)],\n              [AC_DEFINE([USE_DEBUG_BREAK], 1,\n                         [Define to 1 to build with debug_break capabilities. (--enable-debugbreak)])])\n\n# Enable debug ntuplestore\nPGAC_ARG_BOOL(enable, debugntuplestore, no, [  --enable-ntuplestore    enable debug_ntuplestore (for debugging)],\n              [AC_DEFINE([USE_DEBUG_NTUPLESTORE], 1,\n                         [Define to 1 to build with debug_ntuplestore. (--enable-ntuplestore)])])\n\n#\n# Enable testing utilities\n#\nPGAC_ARG_BOOL(enable, testutils, no, [  --enable-testutils      enable testing utilities],\n              [AC_DEFINE([USE_TEST_UTILS], 1,\n                         [Define to 1 to build with testing utilities. (--enable-testutils)])])\n\n#\n# Enable Greenplum ORCA optimizer\n#\nPGAC_ARG_BOOL(enable, orca, yes, [  --disable-orca          disable ORCA optimizer],\n              [AC_DEFINE([USE_ORCA], 1,\n                         [Define to 1 to build with Greenplum ORCA optimizer. (--enable-orca)])])\nAC_MSG_RESULT([checking whether to build with ORCA... $enable_orca])\nAC_SUBST(enable_orca)\n\n#\n# --enable-snmp enables snmp mib and trap/inform\n#\nPGAC_ARG_BOOL(enable, snmp, no, [  --enable-snmp           enable snmp for MIB and alerts via TRAP/INFORM],\n              [AC_DEFINE([USE_SNMP], 1,\n                         [Define to 1 to build with snmp capabilities. (--enable-snmp)])])\nAC_MSG_RESULT([checking whether to build with snmp... $enable_snmp])\nAC_SUBST(enable_snmp)\n\n#\n# --enable-ddboost enables DD Boost support\n#\nPGAC_ARG_BOOL(enable, ddboost, no,  [  --enable-ddboost        enable DD Boost support],\n              [AC_DEFINE([USE_DDBOOST], 1,\n                         [Define to 1 to build with DD Boost capabilities. (--enable-ddboost)])])\nAC_MSG_RESULT([checking whether to build with DD Boost support... $enable_ddboost])\nAC_SUBST(enable_ddboost)\n\n#\n# --enable-netbackup enables NetBackup support\n#\nPGAC_ARG_BOOL(enable, netbackup, no,  [  --enable-netbackup      enable NetBackup support],\n              [AC_DEFINE([USE_NETBACKUP], 1,\n                         [Define to 1 to build with NetBackup capabilities. (--enable-netbackup)])])\nAC_MSG_RESULT([checking whether to build with NetBackup support... $enable_netbackup])\nAC_SUBST(enable_netbackup)\n\n#\n# --enable-mapreduce enables GPMapreduce support\n#\nPGAC_ARG_BOOL(enable, mapreduce, no, [  --enable-mapreduce      enable Greenplum Mapreduce support],\n              [AC_DEFINE([USE_MAPREDUCE], 1,\n\t\t\t             [Define to 1 to build with Mapreduce capabilities (--enable-mapreduce)])])\nAC_MSG_RESULT([checking whether to build with Greenplum Mapreduce... $enable_mapreduce])\nAC_SUBST(enable_mapreduce)\n\n#\n# gpcloud, enabled by default\n#\nPGAC_ARG_BOOL(enable, gpcloud, yes, [  --disable-gpcloud       disable gpcloud support],\n              [AC_DEFINE([USE_GPCLOUD], 1,\n\t\t\t             [Define to 1 to build with gpcloud (--enable-gpcloud)])])\nAC_MSG_RESULT([checking whether to build with gpcloud... $enable_gpcloud])\nAC_SUBST(enable_gpcloud)\n\nAS_IF([test \"$enable_gpcloud\" = yes],\n[ # then\n  AX_CXX_COMPILE_STDCXX([11], [noext], [mandatory])\n]) # fi\n\n#\n# Include directories\n#\nac_save_IFS=$IFS\nIFS=\"${IFS}${PATH_SEPARATOR}\"\n# SRCH_INC comes from the template file\nfor dir in $with_includes $SRCH_INC; do\n  if test -d \"$dir\"; then\n    INCLUDES=\"$INCLUDES -I$dir\"\n  else\n    AC_MSG_WARN([*** Include directory $dir does not exist.])\n  fi\ndone\nIFS=$ac_save_IFS\nAC_SUBST(INCLUDES)\n\n\n#\n# Library directories\n#\nac_save_IFS=$IFS\nIFS=\"${IFS}${PATH_SEPARATOR}\"\n# LIBRARY_DIRS comes from command line, SRCH_LIB from template file.\nfor dir in $LIBRARY_DIRS $SRCH_LIB; do\n  if test -d \"$dir\"; then\n    LIBDIRS=\"$LIBDIRS -L$dir\"\n  else\n    AC_MSG_WARN([*** Library directory $dir does not exist.])\n  fi\ndone\nIFS=$ac_save_IFS\n\n#\n# Enable thread-safe client libraries\n#\nAC_MSG_CHECKING([allow thread-safe client libraries])\n# GPDB wants the default here to be \"yes\", unlike PostgreSQL.\n# it's also required for Win32 client builds.\nPGAC_ARG_BOOL(enable, thread-safety, yes, [  --disable-thread-safety  Do not make client libraries thread-safe])\n\nPGAC_ARG_BOOL(enable, thread-safety-force, no, [  --enable-thread-safety-force  force thread-safety despite thread test failure])\nif test \"$enable_thread_safety\" = yes -o \\\n        \"$enable_thread_safety_force\" = yes; then\n  enable_thread_safety=\"yes\"\t# for 'force'\n  AC_DEFINE([ENABLE_THREAD_SAFETY], 1,\n          [Define to 1 to build client libraries as thread-safe code. (--enable-thread-safety)])\nfi\nAC_MSG_RESULT([$enable_thread_safety])\nAC_SUBST(enable_thread_safety)\n\n#\n# Optionally build Tcl modules (PL/Tcl)\n#\nAC_MSG_CHECKING([whether to build with Tcl])\nPGAC_ARG_BOOL(with, tcl, no, [  --with-tcl              build Tcl modules (PL/Tcl)])\nAC_MSG_RESULT([$with_tcl])\nAC_SUBST([with_tcl])\n\n# We see if the path to the Tcl/Tk configuration scripts is specified.\n# This will override the use of tclsh to find the paths to search.\n\nPGAC_ARG_REQ(with, tclconfig, [  --with-tclconfig=DIR    tclConfig.sh is in DIR])\n\n#\n# Optionally build Perl modules (PL/Perl)\n#\nAC_MSG_CHECKING([whether to build Perl modules])\nPGAC_ARG_BOOL(with, perl, no, [  --with-perl             build Perl modules (PL/Perl)])\nAC_MSG_RESULT([$with_perl])\nAC_SUBST(with_perl)\n\n#\n# Optionally build Python modules (PL/Python)\n#\nAC_MSG_CHECKING([whether to build Python modules])\nPGAC_ARG_BOOL(with, python, no, [  --with-python           build Python modules (PL/Python)])\nAC_MSG_RESULT([$with_python])\nAC_SUBST(with_python)\n\n#\n# GSSAPI\n#\nAC_MSG_CHECKING([whether to build with GSSAPI support])\nPGAC_ARG_BOOL(with, gssapi, no, [  --with-gssapi           build with GSSAPI support],\n[\n  AC_DEFINE(ENABLE_GSS, 1, [Define to build with GSSAPI support. (--with-gssapi)])\n  krb_srvtab=\"FILE:\\$(sysconfdir)/krb5.keytab\"\n])\nAC_MSG_RESULT([$with_gssapi])\nAC_SUBST(with_gssapi)\n\n#\n# Kerberos 5\n#\nAC_MSG_CHECKING([whether to build with Kerberos 5 support])\nPGAC_ARG_BOOL(with, krb5, no, [  --with-krb5             build with Kerberos 5 support],\n[\n  AC_DEFINE(KRB5, 1, [Define to build with Kerberos 5 support. (--with-krb5)])\n  krb_srvtab=\"FILE:\\$(sysconfdir)/krb5.keytab\"\n])\nAC_MSG_RESULT([$with_krb5])\nAC_SUBST(with_krb5)\n\n\nAC_SUBST(krb_srvtab)\n\n\n#\n# Kerberos configuration parameters\n#\nPGAC_ARG_REQ(with, krb-srvnam,\n             [  --with-krb-srvnam=NAME  default service principal name in Kerberos [[postgres]]],\n             [],\n             [with_krb_srvnam=\"postgres\"])\nAC_DEFINE_UNQUOTED([PG_KRB_SRVNAM], [\"$with_krb_srvnam\"],\n                   [Define to the name of the default PostgreSQL service principal in Kerberos. (--with-krb-srvnam=NAME)])\n\n\n#\n# PAM\n#\nAC_MSG_CHECKING([whether to build with PAM support])\nPGAC_ARG_BOOL(with, pam, no,\n              [  --with-pam              build with PAM support],\n              [AC_DEFINE([USE_PAM], 1, [Define to 1 to build with PAM support. (--with-pam)])])\nAC_MSG_RESULT([$with_pam])\nAC_SUBST(with_pam)\n\n\n#\n# LDAP\n#\nAC_MSG_CHECKING([whether to build with LDAP support])\nPGAC_ARG_BOOL(with, ldap, no,\n              [  --with-ldap             build with LDAP support],\n              [AC_DEFINE([USE_LDAP], 1, [Define to 1 to build with LDAP support. (--with-ldap)])])\nAC_MSG_RESULT([$with_ldap])\nAC_SUBST(with_ldap)\n\n\n#\n# Bonjour\n#\nAC_MSG_CHECKING([whether to build with Bonjour support])\nPGAC_ARG_BOOL(with, bonjour, no,\n              [  --with-bonjour          build with Bonjour support],\n              [AC_DEFINE([USE_BONJOUR], 1, [Define to 1 to build with Bonjour support. (--with-bonjour)])])\nAC_MSG_RESULT([$with_bonjour])\nAC_SUBST(with_bonjour)\n\n\n#\n# OpenSSL\n#\nAC_MSG_CHECKING([whether to build with OpenSSL support])\nPGAC_ARG_BOOL(with, openssl, no, [  --with-openssl          build with OpenSSL support],\n              [AC_DEFINE([USE_SSL], 1, [Define to build with (Open)SSL support. (--with-openssl)])])\nAC_MSG_RESULT([$with_openssl])\nAC_SUBST(with_openssl)\n\n\n#\n# Readline\n#\nPGAC_ARG_BOOL(with, readline, yes,\n              [  --without-readline      do not use GNU Readline nor BSD Libedit for editing])\n# readline on MinGW has problems with backslashes in psql and other bugs.\n# This is particularly a problem with non-US code pages.\n# Therefore disable its use until we understand the cause. 2004-07-20\nif test \"$PORTNAME\" = \"win32\"; then\n  if test \"$with_readline\" = yes; then\n    AC_MSG_WARN([*** Readline does not work on MinGW --- disabling])\n    with_readline=no\n  fi\nfi\n\n\n#\n# Prefer libedit\n#\n# In GPDB we want the default to be yes, because we don't want to link with GPL code.\n#\nPGAC_ARG_BOOL(with, libedit-preferred, yes,\n              [  --without-libedit-preferred  Don't prefer BSD Libedit over GNU Readline])\n\n\n#\n# OSSP UUID library\n#\nPGAC_ARG_BOOL(with, ossp-uuid, no, [  --with-ossp-uuid        use OSSP UUID library when building contrib/uuid-ossp])\nAC_SUBST(with_ossp_uuid)\n\n\n#\n# XML\n#\nPGAC_ARG_BOOL(with, libxml, no, [  --with-libxml           build with XML support],\n              [AC_DEFINE([USE_LIBXML], 1, [Define to 1 to build with XML support. (--with-libxml)])])\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_PROGS(XML2_CONFIG, xml2-config)\n  if test -n \"$XML2_CONFIG\"; then\n    for pgac_option in `$XML2_CONFIG --cflags`; do\n      case $pgac_option in\n        -I*|-D*) CPPFLAGS=\"$CPPFLAGS $pgac_option\";;\n      esac\n    done\n    for pgac_option in `$XML2_CONFIG --libs`; do\n      case $pgac_option in\n        -L*) LDFLAGS=\"$LDFLAGS $pgac_option\";;\n      esac\n    done\n  fi\nfi\n\nAC_SUBST(with_libxml)\n\n#\n# XSLT\n#\nPGAC_ARG_BOOL(with, libxslt, no, [  --with-libxslt          use XSLT support when building contrib/xml2],\n              [AC_DEFINE([USE_LIBXSLT], 1, [Define to 1 to use XSLT support when building contrib/xml2. (--with-libxslt)])])\n\n\nAC_SUBST(with_libxslt)\n\n#\n# tzdata\n#\nPGAC_ARG_REQ(with, system-tzdata,\n             [  --with-system-tzdata=DIR  use system time zone data in DIR])\nAC_SUBST(with_system_tzdata)\n\n#\n# Zlib\n#\nPGAC_ARG_BOOL(with, zlib, yes,\n              [  --without-zlib          do not use Zlib])\nAC_SUBST(with_zlib)\n\n#\n# Realtime library\n#\nPGAC_ARG_BOOL(with, rt, yes,\n              [  --without-rt            do not use Realtime Library])\nAC_SUBST(with_rt)\n\n#\n# libcurl. Used for external table support and the PXF extension\n#\nPGAC_ARG_BOOL(with, libcurl, yes,\n              [  --without-libcurl       do not use libcurl])\nAC_SUBST(with_libcurl)\n\nif test \"$with_libcurl\" = \"no\" && test \"$enable_pxf\" = \"yes\"; then\n  AC_MSG_ERROR([libcurl is required by PXF])\nfi\n\n#\n# libapr. Used for gpfdist and gpperfmon\n#\nPGAC_ARG_REQ(with, apr-config,\n             [  --with-apr-config=PATH  path to apr-1-config utility])\nAC_SUBST(with_apr_config)\n\n#\n# libapu. Used for gpperfmon.\n#\nPGAC_ARG_REQ(with, apu-config,\n             [  --with-apu-config=PATH  path to apu-1-config utility])\nAC_SUBST(with_apu_config)\n\n#\n# Elf\n#\n\n# Assume system is ELF if it predefines __ELF__ as 1,\n# otherwise believe host_os based default.PostgreSQL\ncase $host_os in\n    freebsd1*|freebsd2*) elf=no;;\n    freebsd3*|freebsd4*) elf=yes;;\nesac\n\nAC_EGREP_CPP(yes,\n[#if __ELF__\n  yes\n#endif\n],\n[ELF_SYS=true],\n[if test \"X$elf\" = \"Xyes\" ; then\n  ELF_SYS=true\nelse\n  ELF_SYS=\nfi])\nAC_SUBST(ELF_SYS)\n\n#\n# Assignments\n#\n\nCPPFLAGS=\"$CPPFLAGS $INCLUDES\"\nLDFLAGS=\"$LDFLAGS $LIBDIRS\"\n\nAC_ARG_VAR(LDFLAGS_EX, [extra linker flags for linking executables only])\nAC_ARG_VAR(LDFLAGS_SL, [extra linker flags for linking shared libraries only])\n\nAC_MSG_NOTICE([using CPPFLAGS=$CPPFLAGS])\nAC_MSG_NOTICE([using LDFLAGS=$LDFLAGS])\n\nAC_ARG_VAR(LDFLAGS_SL)\n\nPGAC_PROG_LD\nAC_SUBST(LD)\nAC_SUBST(with_gnu_ld)\ncase $host_os in sysv5*)\n  AC_CACHE_CHECK([whether ld -R works], [pgac_cv_prog_ld_R],\n  [\n    pgac_save_LDFLAGS=$LDFLAGS; LDFLAGS=\"$LDFLAGS -Wl,-R/usr/lib\"\n    AC_TRY_LINK([], [], [pgac_cv_prog_ld_R=yes], [pgac_cv_prog_ld_R=no])\n    LDFLAGS=$pgac_save_LDFLAGS\n  ])\n  ld_R_works=$pgac_cv_prog_ld_R\n  AC_SUBST(ld_R_works)\nesac\nAC_PROG_RANLIB\nPGAC_CHECK_STRIP\nAC_CHECK_TOOL(AR, ar, ar)\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_CHECK_TOOL(DLLTOOL, dlltool, dlltool)\n  AC_CHECK_TOOL(DLLWRAP, dllwrap, dllwrap)\n  AC_CHECK_TOOL(WINDRES, windres, windres)\nfi\n\nAC_PATH_PROG(TAR, tar)\nAC_PROG_LN_S\nAC_PROG_AWK\nAC_PROG_MKDIR_P\n# When Autoconf chooses install-sh as mkdir -p program it tries to generate\n# a relative path to it in each makefile where it subsitutes it. This clashes\n# with our Makefile.global concept. This workaround helps.\ncase $MKDIR_P in\n  *install-sh*) MKDIR_P='\\${SHELL} \\${top_srcdir}/config/install-sh -c -d';;\nesac\n\nPGAC_PATH_BISON\nPGAC_PATH_FLEX\n\nPGAC_PATH_PERL\nif test \"$with_perl\" = yes; then\n  if test -z \"$PERL\"; then\n    AC_MSG_ERROR([Perl not found])\n  fi\n  PGAC_CHECK_PERL_CONFIGS([archlibexp,privlibexp,useshrplib])\n  PGAC_CHECK_PERL_EMBED_LDFLAGS\nfi\n\nif test \"$with_python\" = yes; then\n  PGAC_PATH_PYTHON\n  PGAC_CHECK_PYTHON_EMBED_SETUP\nfi\n\nZIC=\nif test \"$cross_compiling\" = yes && test -z \"$with_system_tzdata\"; then\n  AC_PATH_PROG(ZIC, zic)\n  if test -z \"$ZIC\"; then\n    AC_MSG_ERROR([\nWhen cross-compiling, either use the option --with-system-tzdata to use\nexisting time-zone data, or set the environment variable ZIC to a zic\nprogram to use during the build.])\n  fi\nfi\n\nAC_SUBST(ADDON_DIR)\n\n#\n[GP_VERSION_NUM=\"`echo \"$PACKAGE_VERSION\" | sed 's/[A-Za-z].*$//' |\ntr '.' '\t' |\n$AWK '{printf \"%d%02d%02d\", $1, $2, (NF >= 3) ? $3 : 0}'`\"]\nAC_DEFINE_UNQUOTED(GP_VERSION_NUM, $GP_VERSION_NUM, [Greenplum version as a number])\n\n##\n## Libraries\n##\n## Most libraries are included only if they demonstrably provide a function\n## we need, but libm is an exception: always include it, because there are\n## too many compilers that play cute optimization games that will break\n## probes for standard functions such as pow().\n##\n\nAC_CHECK_LIB(m, main)\nAC_SEARCH_LIBS(setproctitle, util)\nAC_SEARCH_LIBS(dlopen, dl)\nAC_SEARCH_LIBS(socket, [socket wsock32])\nAC_SEARCH_LIBS(shl_load, dld)\n# We only use libld in port/dynloader/aix.c\ncase $host_os in\n     aix*)\n\tAC_SEARCH_LIBS(ldopen, ld)\n\t;;\nesac\nAC_SEARCH_LIBS(getopt_long, [getopt gnugetopt])\nAC_SEARCH_LIBS(crypt, crypt)\n# Solaris:\nAC_SEARCH_LIBS(fdatasync, [rt posix4])\n# Required for thread_test.c on Solaris 2.5:\n# Other ports use it too (HP-UX) so test unconditionally\nAC_SEARCH_LIBS(gethostbyname_r, nsl)\n# Cygwin:\nAC_SEARCH_LIBS(shmget, cygipc)\n\nif test \"$with_readline\" = yes; then\n  PGAC_CHECK_READLINE\n  if test x\"$pgac_cv_check_readline\" = x\"no\"; then\n    AC_MSG_ERROR([readline library not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])\n  fi\nfi\n\nif test \"$with_zlib\" = yes; then\n  AC_CHECK_LIB(z, inflate, [],\n               [AC_MSG_ERROR([zlib library not found\nIf you have zlib already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-zlib to disable zlib support.])])\nfi\n\nif test \"$enable_spinlocks\" = yes; then\n  AC_DEFINE(HAVE_SPINLOCKS, 1, [Define to 1 if you have spinlocks.])\nelse\n  AC_MSG_WARN([\n*** Not using spinlocks will cause poor performance.])\nfi\n\nif test \"$enable_atomics\" = yes; then\n  AC_DEFINE(HAVE_ATOMICS, 1, [Define to 1 if you want to use atomics.])\nelse\n  AC_MSG_WARN([\n*** Not using atomic operations will cause poor performance.])\nfi\n\nif test \"$with_gssapi\" = yes ; then\n  if test \"$PORTNAME\" != \"win32\"; then\n    AC_SEARCH_LIBS(gss_init_sec_context, [gssapi_krb5 gss 'gssapi -lkrb5 -lcrypto'], [],\n\t\t \t\t  [AC_MSG_ERROR([could not find function 'gss_init_sec_context' required for GSSAPI])])\n  else\n    LIBS=\"$LIBS -lgssapi32\"\n  fi\nfi\n\nif test \"$with_krb5\" = yes ; then\n  if test \"$PORTNAME\" != \"win32\"; then\n     AC_SEARCH_LIBS(com_err, [krb5 'krb5 -lcrypto -ldes -lasn1 -lroken' com_err 'com_err -lssl -lcrypto'], [],\n                    [AC_MSG_ERROR([could not find function 'com_err' required for Kerberos 5])])\n     AC_SEARCH_LIBS(krb5_sendauth, [krb5 'krb5 -lcrypto -ldes -lasn1 -lroken'], [],\n                    [AC_MSG_ERROR([could not find function 'krb5_sendauth' required for Kerberos 5])])\n  else\n     AC_SEARCH_LIBS(com_err, 'comerr32 -lkrb5_32', [],\n                    [AC_MSG_ERROR([could not find function 'com_err' required for Kerberos 5])])\n  fi\nfi\n\nAC_DEFUN([CHECK_APR], [\n  GPAC_PATH_APR_1_CONFIG\n  # If the 'apr-1-config --link-ld' produced correct output, -lapr-1 is already\n  # in LIBS, hence AC_SEARCH_LIBS rather than AC_CHECK_LIB. (and the autoconf\n  # manual recommends always using AC_SEARCH_LIBS rather than AC_CHECK_LIB\n  # anyway)\n  _LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $apr_link_ld_libs\"\n  AC_SEARCH_LIBS(apr_getopt_long, [apr-1], [], [AC_MSG_ERROR([libapr-1 is required by gpfdist and gpperfmon])])\n ])\n\nif test \"$enable_gpfdist\" = yes ; then\n  CHECK_APR()\n  AC_SEARCH_LIBS(event_add, [event], [], [AC_MSG_ERROR([libevent is required for gpfdist])])\n\n  AC_SEARCH_LIBS(yaml_parser_initialize, [yaml], [have_yaml=yes], [AC_MSG_WARN([libyaml is not found. disabling transformations for gpfdist.])])\n  LIBS=\"$_LIBS\"\n  AC_SUBST(have_yaml)\nfi\n\nif test \"$enable_gpperfmon\" = yes; then\n  CHECK_APR()\n  GPAC_PATH_APU_1_CONFIG\n  LIBS=\"$LIBS $apu_link_ld_libs\"\n  AC_SEARCH_LIBS(event_add, [event], [], [AC_MSG_ERROR([libevent is required for gpperfrmon])])\n  AC_SEARCH_LIBS(apr_queue_push, [aprutil-1], [], [AC_MSG_ERROR([libaprutil-1 is required for gpperfmon])])\n\n  AC_SEARCH_LIBS(sigar_open, [sigar], [with_libsigar=yes], [AC_MSG_ERROR([libsigar is required for gpperfmon])])\n  LIBS=\"$_LIBS\"\n  AC_SUBST(with_libsigar)\nfi\n\n\nif test \"$with_openssl\" = yes ; then\n  dnl Order matters!\n  if test \"$PORTNAME\" != \"win32\"; then\n     AC_CHECK_LIB(crypto, CRYPTO_new_ex_data, [], [AC_MSG_ERROR([library 'crypto' is required for OpenSSL])])\n     AC_CHECK_LIB(ssl,    SSL_library_init, [], [AC_MSG_ERROR([library 'ssl' is required for OpenSSL])])\n  else\n     AC_CHECK_LIB(eay32, CRYPTO_new_ex_data, [], [AC_MSG_ERROR([library 'eay32' is required for OpenSSL])])\n     AC_CHECK_LIB(ssleay32,    SSL_library_init, [], [AC_MSG_ERROR([library 'ssleay32' is required for OpenSSL])])\n  fi\nfi\n\nif test \"$with_rt\" = yes ; then\n  AC_CHECK_LIB(rt, clock_gettime, [],\n                [AC_MSG_WARN([Realtime library not found])])\nfi\n\nif test \"$with_pam\" = yes ; then\n  AC_CHECK_LIB(pam,    pam_start, [], [AC_MSG_ERROR([library 'pam' is required for PAM])])\nfi\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_LIB(xml2, xmlSaveToBuffer, [], [AC_MSG_ERROR([library 'xml2' (version >= 2.6.23) is required for XML support])])\nfi\n\n# Check for curl.\n# CURLOPT_MAIL_FROM is introduced in curl 7.20 and only needed for email alerts.\nif test \"$with_libcurl\" = yes ; then\n  AC_CHECK_CURL([7.19.0])\n  CFLAGS=\"$CFLAGS $CURL_CFLAGS\"\n  LIBS=\"$LIBS $CURL_LIBS\"\n  AC_DEFINE([USE_CURL], 1,\n          [Define to 1 to build with libcurl support. (--with-libcurl)])\n  AC_CHECK_DECLS([CURLOPT_MAIL_FROM], [], [], [#include <curl/curl.h>])\nfi\n\n# Check for bzip2\nAC_SEARCH_LIBS(BZ2_bzDecompress, bz2)\n\n# Check for net-snmp\nif test \"$enable_snmp\" = yes ; then\n\tAC_CHECK_LIB(netsnmp,  netsnmp_ds_set_string,  [], [AC_MSG_ERROR([library 'netsnmp' is required for snmp support])])\nfi\n\nif test \"$with_libxslt\" = yes ; then\n  AC_CHECK_LIB(xslt, xsltCleanupGlobals, [], [AC_MSG_ERROR([library 'xslt' is required for XSLT support])])\nfi\n\n# for contrib/uuid-ossp\nif test \"$with_ossp_uuid\" = yes ; then\n  AC_CHECK_LIB(ossp-uuid, uuid_export,\n    [OSSP_UUID_LIBS=\"-lossp-uuid\"],\n    [AC_CHECK_LIB(uuid, uuid_export,\n      [OSSP_UUID_LIBS=\"-luuid\"],\n      [AC_MSG_ERROR([library 'ossp-uuid' or 'uuid' is required for OSSP-UUID])])])\nfi\nAC_SUBST(OSSP_UUID_LIBS)\n\n# Check for DD Boost\nif test \"$enable_ddboost\" = yes ; then\n  _LIBS=\"$LIBS\"\n  AC_CHECK_LIB(DDBoost, main, [], [AC_MSG_ERROR([library 'DDBoost' is required for DD Boost support])])\n  LIBS=\"$_LIBS\"\nfi\n\n##\n## Header files\n##\n\nAC_INCLUDES_DEFAULT\n\n# Check for Greenplum Query Optimizer (orca) and supporting Greenplum OS header files.\nif test \"$enable_orca\" = yes; then\n  PGAC_CHECK_ORCA_HEADERS\n  PGAC_CHECK_ORCA_XERCES\n  PGAC_CHECK_ORCA_LIBS\n  PGAC_CHECK_ORCA_VERSION\nfi\n\ndnl sys/socket.h is required by AC_FUNC_ACCEPT_ARGTYPES\nAC_CHECK_HEADERS([atomic.h crypt.h dld.h endian.h fp_class.h getopt.h ieeefp.h ifaddrs.h langinfo.h mbarrier.h poll.h pwd.h sys/ioctl.h sys/ipc.h sys/poll.h sys/pstat.h sys/resource.h sys/select.h sys/sem.h sys/shm.h sys/socket.h sys/sockio.h sys/tas.h sys/time.h sys/un.h termios.h ucred.h utime.h wchar.h wctype.h kernel/OS.h kernel/image.h SupportDefs.h])\n\n# Check for bzlib.h\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_MSG_WARN([*** bzip2 not required for windows partial build --- disabling.])\nelse\n  AC_CHECK_HEADER(bzlib.h, [], [AC_MSG_ERROR([header file <bzlib.h> is required for bzip2 support])], [])\nfi\n\n# On BSD, cpp test for net/if.h will fail unless sys/socket.h\n# is included first.\nAC_CHECK_HEADERS(net/if.h, [], [],\n[AC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n])\n\n# At least on IRIX, cpp test for netinet/tcp.h will fail unless\n# netinet/in.h is included first.\nAC_CHECK_HEADERS(netinet/in.h)\nAC_CHECK_HEADERS(netinet/tcp.h, [], [],\n[AC_INCLUDES_DEFAULT\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n])\n\nif expr x\"$pgac_cv_check_readline\" : 'x-lreadline' >/dev/null ; then\n  AC_CHECK_HEADERS(readline/readline.h, [],\n        [AC_CHECK_HEADERS(readline.h, [],\n                [AC_MSG_ERROR([readline header not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])])])\n  AC_CHECK_HEADERS(readline/history.h, [],\n        [AC_CHECK_HEADERS(history.h, [],\n                [AC_MSG_ERROR([history header not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])])])\nfi\n\nif expr x\"$pgac_cv_check_readline\" : 'x-ledit' >/dev/null ; then\n# Some installations of libedit usurp /usr/include/readline/, which seems\n# bad practice, since in combined installations readline will have its headers\n# there.  We might have to resort to AC_EGREP checks to make sure we found\n# the proper header...\n  AC_CHECK_HEADERS(editline/readline.h, [],\n        [AC_CHECK_HEADERS(readline.h, [],\n                [AC_CHECK_HEADERS(readline/readline.h, [],\n                        [AC_MSG_ERROR([readline header not found\nIf you have libedit already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable libedit support.])])])])\n# Note: in a libedit installation, history.h is sometimes a dummy, and may\n# not be there at all.  Hence, don't complain if not found.  We must check\n# though, since in yet other versions it is an independent header.\n  AC_CHECK_HEADERS(editline/history.h, [],\n        [AC_CHECK_HEADERS(history.h, [],\n                [AC_CHECK_HEADERS(readline/history.h)])])\nfi\n\nif test \"$enable_gpfdist\" = yes; then\n  if test \"$PORTNAME\" = \"win32\"; then\n    AC_CHECK_HEADERS([winsock2.h])\n  fi\n\n  AC_CHECK_HEADERS(yaml.h, [], [AC_MSG_WARN([header file <yaml.h> is not found. disabling transformations for gpfdist.])])\n  AC_CHECK_HEADERS(event.h, [], [AC_MSG_ERROR([header file <event.h> is required for gpfdist])])\n\n  ac_save_CPPFLAGS=$CPPFLAGS\n  CPPFLAGS=\"$apr_includes $CPPFLAGS\"\n  AC_CHECK_HEADERS(apr_getopt.h, [], [AC_MSG_ERROR(['header file <apr_getopt.h> is required for gpfdist'])])\n  CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\nif test \"enable_gpperfmon\" = yes; then\n  AC_CHECK_HEADERS(event.h, [], [AC_MSG_ERROR([header file <event.h> is required for gpperfmon])])\nfi\n\nif test \"$with_zlib\" = yes; then\n  AC_CHECK_HEADER(zlib.h, [], [AC_MSG_ERROR([zlib header not found\nIf you have zlib already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-zlib to disable zlib support.])])\nfi\n\nif test \"$with_gssapi\" = yes ; then\n  AC_CHECK_HEADERS(gssapi/gssapi.h, [],\n\t[AC_CHECK_HEADERS(gssapi.h, [], [AC_MSG_ERROR([gssapi.h header file is required for GSSAPI])])])\nfi\n\nif test \"$with_krb5\" = yes ; then\n  AC_CHECK_HEADER(krb5.h, [], [AC_MSG_ERROR([header file <krb5.h> is required for Kerberos 5])])\nfi\n\nif test \"$with_openssl\" = yes ; then\n  AC_CHECK_HEADER(openssl/ssl.h, [], [AC_MSG_ERROR([header file <openssl/ssl.h> is required for OpenSSL])])\n  AC_CHECK_HEADER(openssl/err.h, [], [AC_MSG_ERROR([header file <openssl/err.h> is required for OpenSSL])])\n  AC_CHECK_FUNCS([ERR_set_mark])\nfi\n\nif test \"$with_pam\" = yes ; then\n  AC_CHECK_HEADERS(security/pam_appl.h, [],\n                   [AC_CHECK_HEADERS(pam/pam_appl.h, [],\n                                     [AC_MSG_ERROR([header file <security/pam_appl.h> or <pam/pam_appl.h> is required for PAM.])])])\nfi\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_HEADER(libxml/parser.h, [], [AC_MSG_ERROR([header file <libxml/parser.h> is required for XML support])])\nfi\n\nif test \"$with_libxslt\" = yes ; then\n  AC_CHECK_HEADER(libxslt/xslt.h, [], [AC_MSG_ERROR([header file <libxslt/xslt.h> is required for XSLT support])])\nfi\n\nif test \"$with_ldap\" = yes ; then\n  if test \"$PORTNAME\" != \"win32\"; then\n     AC_CHECK_HEADERS(ldap.h, [],\n                      [AC_MSG_ERROR([header file <ldap.h> is required for LDAP])])\n  else\n     AC_CHECK_HEADERS(winldap.h, [],\n                      [AC_MSG_ERROR([header file <winldap.h> is required for LDAP])],\n                      [AC_INCLUDES_DEFAULT\n#include <windows.h>\n                      ])\n  fi\nfi\n\nif test \"$with_bonjour\" = yes ; then\n  AC_CHECK_HEADER(DNSServiceDiscovery/DNSServiceDiscovery.h, [], [AC_MSG_ERROR([header file <DNSServiceDiscovery/DNSServiceDiscovery.h> is required for Bonjour])])\nfi\n\nif test \"$enable_ddboost\" = yes ; then\n  AC_CHECK_HEADER(ddp_api.h, [], [AC_MSG_ERROR([header file <ddp_api.h> is required for DD Boost])])\nfi\n\n# For processor affinity support in Linux on NUMA platforms such as\n# AMD x86_64, the 'numactl' or 'libnuma' package is required.  See\n#  http://lwn.net/Articles/67005/\n#  http://www.x86-64.org/pipermail/discuss/2003-May/003528.html\ncase $template in\n  linux*)\n    AC_CHECK_LIB(numa, numa_available)\n    AC_CHECK_HEADERS([numa.h])\n    ;;\nesac\n\n# net-snmp\nif test \"$enable_snmp\" = yes; then\n\tAC_CHECK_HEADERS([net-snmp/net-snmp-config.h], [],\n\t\t\t\t\t[AC_MSG_ERROR([header file <<net-snmp/net-snmp-config.h> is required for snmp support])])\nfi\n\n\n# realtime library header\nif test \"$with_rt\" = yes; then\n\tAC_CHECK_HEADERS([time.h], [],\n\t\t\t [AC_MSG_ERROR([header file <time.h> is required for realtime library support])])\nfi\n\nif test \"$enable_mapreduce\" = yes; then\n  if test \"$with_perl\" = no; then\n    AC_MSG_ERROR([Greenplum Mapreduce requires Perl, reconfigure with --with-perl])\n  fi\n  AC_CHECK_HEADERS(yaml.h, [], [AC_MSG_ERROR([YAML includes required for Greenplum Mapreduce])])\nfi\n\n##\n## Types, structures, compiler characteristics\n##\n\nm4_defun([AC_PROG_CC_STDC], []) dnl We don't want that.\nAC_C_BIGENDIAN\nPGAC_C_INLINE\nAC_C_CONST\nAC_C_STRINGIZE\nPGAC_C_SIGNED\nAC_C_VOLATILE\nPGAC_C_FUNCNAME_SUPPORT\nPGAC_C_STATIC_ASSERT\nPGAC_C_TYPES_COMPATIBLE\nPGAC_C_BUILTIN_CONSTANT_P\nPGAC_C_BUILTIN_UNREACHABLE\nPGAC_C_VA_ARGS\nPGAC_STRUCT_TIMEZONE\nPGAC_UNION_SEMUN\nPGAC_STRUCT_SOCKADDR_UN\nPGAC_STRUCT_SOCKADDR_STORAGE\nPGAC_STRUCT_SOCKADDR_STORAGE_MEMBERS\nPGAC_STRUCT_ADDRINFO\nAC_TYPE_INTPTR_T\nAC_TYPE_UINTPTR_T\nAC_TYPE_LONG_LONG_INT\n\nAC_CHECK_TYPES([struct cmsgcred, struct fcred, struct sockcred], [], [],\n[#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ucred.h>])\n\nAC_CHECK_TYPES([struct option], [], [],\n[#ifdef HAVE_GETOPT_H\n#include <getopt.h>\n#endif])\n\nif test \"$with_zlib\" = yes; then\n  # Check that <zlib.h> defines z_streamp (versions before about 1.0.4\n  # did not).  While we could work around the lack of z_streamp, it\n  # seems unwise to encourage people to use such old zlib versions...\n  AC_CHECK_TYPE(z_streamp, [], [AC_MSG_ERROR([zlib version is too old\nUse --without-zlib to disable zlib support.])],\n                [#include <zlib.h>])\nfi\n\nif test \"$with_krb5\" = yes; then\n# Check for differences between MIT and Heimdal (KTH) releases\n  AC_CHECK_MEMBERS(krb5_ticket.enc_part2, [],\n                   [AC_CHECK_MEMBERS(krb5_ticket.client, [],\n                                     [AC_MSG_ERROR([could not determine how to get client name from Kerberos 5 ticket])],\n                                     [#include <krb5.h>])],\n                   [#include <krb5.h>])\n  AC_CHECK_MEMBERS(krb5_error.text.data, [],\n                   [AC_CHECK_MEMBERS(krb5_error.e_data, [],\n                                     [AC_MSG_ERROR([could not determine how to extract Kerberos 5 error messages])],\n                                     [#include <krb5.h>])],\n                   [#include <krb5.h>])\n\n# Win32 requires headers to be loaded for __stdcall, so can't use\n# AC_CHECK_FUNCS here.\n  AC_MSG_CHECKING(for krb5_free_unparsed_name)\n  AC_TRY_LINK([#include <krb5.h>],\n              [krb5_free_unparsed_name(NULL,NULL);],\n              [AC_DEFINE(HAVE_KRB5_FREE_UNPARSED_NAME, 1, [Define to 1 if you have krb5_free_unparsed_name])\nAC_MSG_RESULT(yes)],\n              [AC_MSG_RESULT(no)])\nfi\n\n\n##\n## Functions, global variables\n##\n\nPGAC_VAR_INT_TIMEZONE\nAC_FUNC_ACCEPT_ARGTYPES\nPGAC_FUNC_GETTIMEOFDAY_1ARG\n\n# Some versions of libedit contain strlcpy(), setproctitle(), and other\n# symbols that that library has no business exposing to the world.  Pending\n# acquisition of a clue by those developers, ignore libedit (including its\n# possible alias of libreadline) while checking for everything else.\nLIBS_including_readline=\"$LIBS\"\nLIBS=`echo \"$LIBS\" | sed -e 's/-ledit//g' -e 's/-lreadline//g'`\n\nAC_CHECK_FUNCS([cbrt dlopen fcvt fdatasync getifaddrs getpeereid getpeerucred getrlimit memmove poll pstat readlink setproctitle setsid sigprocmask symlink sysconf towlower utime utimes waitpid wcstombs])\n\n# posix_fadvise() is a no-op on Solaris, so don't incur function overhead\n# by calling it, 2009-04-02\n# http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/gen/posix_fadvise.c\nif test \"$PORTNAME\" != \"solaris\"; then\nAC_CHECK_FUNCS(posix_fadvise)\nAC_CHECK_DECLS(posix_fadvise, [], [], [#include <fcntl.h>])\nfi\n\nAC_CHECK_DECLS(fdatasync, [], [], [#include <unistd.h>])\nAC_CHECK_DECLS([strlcat, strlcpy])\n# This is probably only present on Darwin, but may as well check always\nAC_CHECK_DECLS(F_FULLFSYNC, [], [], [#include <fcntl.h>])\n\nHAVE_IPV6=no\nAC_CHECK_TYPE([struct sockaddr_in6],\n        [AC_DEFINE(HAVE_IPV6, 1, [Define to 1 if you have support for IPv6.])\n         HAVE_IPV6=yes],\n        [],\n[$ac_includes_default\n#include <netinet/in.h>])\nAC_SUBST(HAVE_IPV6)\n\nAC_CACHE_CHECK([for PS_STRINGS], [pgac_cv_var_PS_STRINGS],\n[AC_TRY_LINK(\n[#include <machine/vmparam.h>\n#include <sys/exec.h>\n],\n[PS_STRINGS->ps_nargvstr = 1;\nPS_STRINGS->ps_argvstr = \"foo\";],\n[pgac_cv_var_PS_STRINGS=yes],\n[pgac_cv_var_PS_STRINGS=no])])\nif test \"$pgac_cv_var_PS_STRINGS\" = yes ; then\n  AC_DEFINE([HAVE_PS_STRINGS], [], [Define to 1 if the PS_STRINGS thing exists.])\nfi\n\n\n# We use our snprintf.c emulation if either snprintf() or vsnprintf()\n# is missing.  Yes, there are machines that have only one.  We may\n# also decide to use snprintf.c if snprintf() is present but does not\n# have all the features we need --- see below.\n\nif test \"$PORTNAME\" = \"win32\"; then\n  # Win32 gets snprintf.c built unconditionally.\n  #\n  # To properly translate all NLS languages strings, we must support the\n  # *printf() %$ format, which allows *printf() arguments to be selected\n  # by position in the translated string.\n  #\n  # libintl versions < 0.13 use the native *printf() functions, and Win32\n  # *printf() doesn't understand %$, so we must use our /port versions,\n  # which do understand %$. libintl versions >= 0.13 include their own\n  # *printf versions on Win32.  The libintl 0.13 release note text is:\n  #\n  #   C format strings with positions, as they arise when a translator\n  #   needs to reorder a sentence, are now supported on all platforms.\n  #   On those few platforms (NetBSD and Woe32) for which the native\n  #   printf()/fprintf()/... functions don't support such format\n  #   strings, replacements are provided through <libintl.h>.\n  #\n  # We could use libintl >= 0.13's *printf() if we were sure that we had\n  # a litint >= 0.13 at runtime, but seeing that there is no clean way\n  # to guarantee that, it is best to just use our own, so we are sure to\n  # get %$ support. In include/port.h we disable the *printf() macros\n  # that might have been defined by libintl.\n  #\n  # We do this unconditionally whether NLS is used or not so we are sure\n  # that all Win32 libraries and binaries behave the same.\n  pgac_need_repl_snprintf=yes\nelse\n  pgac_need_repl_snprintf=no\n  AC_CHECK_FUNCS(snprintf, [], pgac_need_repl_snprintf=yes)\n  AC_CHECK_FUNCS(vsnprintf, [], pgac_need_repl_snprintf=yes)\nfi\n\n\n# Check whether <stdio.h> declares snprintf() and vsnprintf(); if not,\n# include/c.h will provide declarations.  Note this is a separate test\n# from whether the functions exist in the C library --- there are\n# systems that have the functions but don't bother to declare them :-(\n\nAC_CHECK_DECLS([snprintf, vsnprintf])\n\n\ndnl Cannot use AC_CHECK_FUNC because isinf may be a macro\nAC_CACHE_CHECK([for isinf], ac_cv_func_isinf,\n[AC_TRY_LINK([\n#include <math.h>\ndouble glob_double;\n],\n[return isinf(glob_double) ? 0 : 1;],\n[ac_cv_func_isinf=yes],\n[ac_cv_func_isinf=no])])\n\nif test $ac_cv_func_isinf = yes ; then\n  AC_DEFINE(HAVE_ISINF, 1, [Define to 1 if you have isinf().])\nelse\n  AC_LIBOBJ(isinf)\n  # Look for a way to implement a substitute for isinf()\n  AC_CHECK_FUNCS([fpclass fp_class fp_class_d class], [break])\nfi\n\n# Some versions of libedit contain strlcpy(); so disregard that library while\n# checking for these standard libc functions.\npgac_save_LIBS=\"$LIBS\"\nLIBS=`echo \"$LIBS\" | sed -e 's/-ledit//g' -e 's/-lreadline//g'`\n\n# net-snmp has the same problem..\nLIBS=`echo \"$LIBS\" | sed -e 's/-lnetsnmp//g'`\n\nAC_REPLACE_FUNCS([crypt fseeko getopt getpeereid getrusage inet_aton random rint srandom strdup strerror strlcat strlcpy strtol strtoul unsetenv])\n\ncase $host_os in\n\n        # Windows uses a specialised env handler\n        mingw*)\n                AC_DEFINE(HAVE_UNSETENV, 1, [Define to 1 because replacement version used.])\n                ac_cv_func_unsetenv=yes;;\n        *)\n                AC_REPLACE_FUNCS([unsetenv])\n\t\t;;\nesac\n\n# System's version of getaddrinfo(), if any, may be used only if we found\n# a definition for struct addrinfo; see notes in src/include/getaddrinfo.h.\n# (Note: the AC_REPLACE_FUNCS probe fails on Windows, where the available\n# versions of getaddrinfo don't follow normal C call protocol.  This is OK\n# because we want to use our own getaddrinfo.c on Windows anyway.)\nif test x\"$ac_cv_type_struct_addrinfo\" = xyes ; then\n  AC_REPLACE_FUNCS([getaddrinfo])\nelse\n  AC_LIBOBJ(getaddrinfo)\nfi\n\n# Similarly, use system's getopt_long() only if system provides struct option.\n# Solaris' getopt() doesn't do what we want for long options, so always use\n# our versions on that platform.\nif test \"$PORTNAME\" = \"solaris\"; then\n  AC_LIBOBJ(getopt)\n  AC_LIBOBJ(getopt_long)\nelif test x\"$ac_cv_type_struct_option\" = xyes ; then\n  AC_REPLACE_FUNCS([getopt_long])\nelse\n  AC_LIBOBJ(getopt_long)\nfi\n\n# Solaris' getopt() doesn't do what we want for long options, so always use\n# our version on that platform.\nif test \"$PORTNAME\" = \"solaris\"; then\n  AC_LIBOBJ(getopt)\nfi\n\n# mingw has adopted a GNU-centric interpretation of optind/optreset,\n# so always use our version on Windows.\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_LIBOBJ(getopt)\n  AC_LIBOBJ(getopt_long)\nfi\n\n# Win32 support\nif test \"$PORTNAME\" = \"win32\"; then\nAC_REPLACE_FUNCS(gettimeofday)\nAC_LIBOBJ(kill)\nAC_LIBOBJ(open)\nAC_LIBOBJ(rand)\nAC_LIBOBJ(win32env)\nAC_LIBOBJ(win32error)\nAC_DEFINE([HAVE_SYMLINK], 1,\n          [Define to 1 if you have the `symlink' function.])\nfi\n\ndnl Cannot use AC_CHECK_FUNC because sigsetjmp may be a macro\ndnl (especially on GNU libc)\ndnl See also comments in c.h.\nAC_MSG_CHECKING(for sigsetjmp)\nAC_TRY_LINK([#include <setjmp.h>],\n            [sigjmp_buf x; sigsetjmp(x, 1);],\n            [AC_DEFINE(HAVE_SIGSETJMP, 1, [Define to 1 if you have sigsetjmp().])\nAC_MSG_RESULT(yes)],\n            [AC_MSG_RESULT(no)])\n\nAC_DECL_SYS_SIGLIST\n\nAC_CHECK_FUNC(syslog,\n              [AC_CHECK_HEADER(syslog.h,\n                               [AC_DEFINE(HAVE_SYSLOG, 1, [Define to 1 if you have the syslog interface.])])])\n\nAC_CACHE_CHECK([for opterr], pgac_cv_var_int_opterr,\n[AC_TRY_LINK([#include <unistd.h>],\n  [extern int opterr; opterr = 1;],\n  [pgac_cv_var_int_opterr=yes],\n  [pgac_cv_var_int_opterr=no])])\nif test x\"$pgac_cv_var_int_opterr\" = x\"yes\"; then\n  AC_DEFINE(HAVE_INT_OPTERR, 1, [Define to 1 if you have the global variable 'int opterr'.])\nfi\n\nAC_CACHE_CHECK([for optreset], pgac_cv_var_int_optreset,\n[AC_TRY_LINK([#include <unistd.h>],\n  [extern int optreset; optreset = 1;],\n  [pgac_cv_var_int_optreset=yes],\n  [pgac_cv_var_int_optreset=no])])\nif test x\"$pgac_cv_var_int_optreset\" = x\"yes\"; then\n  AC_DEFINE(HAVE_INT_OPTRESET, 1, [Define to 1 if you have the global variable 'int optreset'.])\nfi\n\nAC_CHECK_FUNCS([strtoll strtoq], [break])\nAC_CHECK_FUNCS([strtoull strtouq], [break])\n\n# Check for one of atexit() or on_exit()\nAC_CHECK_FUNCS(atexit, [],\n               [AC_CHECK_FUNCS(on_exit, [],\n               [AC_MSG_ERROR([neither atexit() nor on_exit() found])])])\n\nAC_REPLACE_FUNCS(fseeko)\ncase $host_os in\n\t# BSD/OS & NetBSD use a custom fseeko/ftello built on fsetpos/fgetpos\n\t# Mingw uses macros to access Win32 API calls\n\tbsdi*|netbsd*|mingw*)\n\t\tAC_DEFINE(HAVE_FSEEKO, 1, [Define to 1 because replacement version used.])\n\t\tac_cv_func_fseeko=yes;;\n\t*)\n\t\tAC_FUNC_FSEEKO;;\nesac\n\n\nAC_CACHE_CHECK([for builtin locking functions], pgac_cv_gcc_int_atomics,\n[AC_TRY_LINK([],\n  [int lock = 0;\n   __sync_lock_test_and_set(&lock, 1);\n   __sync_lock_release(&lock);],\n  [pgac_cv_gcc_int_atomics=\"yes\"],\n  [pgac_cv_gcc_int_atomics=\"no\"])])\nif test x\"$pgac_cv_gcc_int_atomics\" = x\"yes\"; then\n  AC_DEFINE(HAVE_GCC_INT_ATOMICS, 1, [Define to 1 if you have __sync_lock_test_and_set(int *) and friends.])\nfi\n\n# Lastly, restore full LIBS list and check for readline/libedit symbols\nLIBS=\"$LIBS_including_readline\"\n\nif test \"$with_readline\" = yes; then\n  PGAC_VAR_RL_COMPLETION_APPEND_CHARACTER\n  AC_CHECK_FUNCS([rl_completion_matches rl_filename_completion_function])\n  AC_CHECK_FUNCS([replace_history_entry])\nfi\n\n\n#\n# Pthreads\n#\n# For each platform, we need to know about any special compile and link\n# libraries, and whether the normal C function names are thread-safe.\n# See the comment at the top of src/port/thread.c for more information.\n# WIN32 doesn't need the pthread tests;  it always uses threads\nif test \"$enable_thread_safety\" = yes -a \"$PORTNAME\" != \"win32\"; then\nACX_PTHREAD\t# set thread flags\n\n# Some platforms use these, so just define them.  They can't hurt if they\n# are not supported.  For example, on Solaris -D_POSIX_PTHREAD_SEMANTICS\n# enables 5-arg getpwuid_r, among other things.\nPTHREAD_CFLAGS=\"$PTHREAD_CFLAGS -D_REENTRANT -D_THREAD_SAFE -D_POSIX_PTHREAD_SEMANTICS\"\n\n\n# At this point, we don't want to muck with the compiler name for threading.\n# Let's see who fails, perhaps AIX.  2004-04-23\nif test \"$PTHREAD_CC\" != \"$CC\"; then\nAC_MSG_ERROR([\nPostgreSQL does not support platforms that require a special compiler\nfor thread safety.])\nfi\n\nif test \"$THREAD_SUPPORT\" = no; then\nAC_MSG_ERROR([cannot enable threads on this platform\nThis platform is known to not support thread-safe programs.  For details,\ncompile and run src/bin/pg_thread_test.])\nfi\n\n# Check for *_r functions\n_CFLAGS=\"$CFLAGS\"\n_LIBS=\"$LIBS\"\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\nLIBS=\"$LIBS $PTHREAD_LIBS\"\n\nif test \"$PORTNAME\" != \"win32\"; then\nAC_CHECK_HEADER(pthread.h, [], [AC_MSG_ERROR([pthread.h not found, required for --enable-thread-safety])])\nfi\n\nAC_CHECK_FUNCS([strerror_r getpwuid_r gethostbyname_r])\n\n# Do test here with the proper thread flags\nPGAC_FUNC_GETPWUID_R_5ARG\nPGAC_FUNC_STRERROR_R_INT\n\nCFLAGS=\"$_CFLAGS\"\nLIBS=\"$_LIBS\"\n\nelse\n# do not use values from template file\nPTHREAD_CFLAGS=\nPTHREAD_LIBS=\nfi\n\nAC_SUBST(PTHREAD_CFLAGS)\nAC_SUBST(PTHREAD_LIBS)\n\n\n# We can test for libldap_r only after we know PTHREAD_LIBS\nif test \"$with_ldap\" = yes ; then\n  _LIBS=\"$LIBS\"\n  if test \"$PORTNAME\" != \"win32\"; then\n    AC_CHECK_LIB(ldap, ldap_bind, [],\n\t\t [AC_MSG_ERROR([library 'ldap' is required for LDAP])],\n\t\t [$EXTRA_LDAP_LIBS])\n    LDAP_LIBS_BE=\"-lldap $EXTRA_LDAP_LIBS\"\n    if test \"$enable_thread_safety\" = yes; then\n      # on some platforms ldap_r fails to link without PTHREAD_LIBS\n      AC_CHECK_LIB(ldap_r, ldap_simple_bind, [],\n\t\t   [AC_MSG_ERROR([library 'ldap_r' is required for LDAP])],\n\t\t   [$PTHREAD_CFLAGS $PTHREAD_LIBS $EXTRA_LDAP_LIBS])\n      LDAP_LIBS_FE=\"-lldap_r $EXTRA_LDAP_LIBS\"\n    else\n      LDAP_LIBS_FE=\"-lldap $EXTRA_LDAP_LIBS\"\n    fi\n  else\n    AC_CHECK_LIB(wldap32, ldap_bind, [], [AC_MSG_ERROR([library 'wldap32' is required for LDAP])])\n    LDAP_LIBS_FE=\"-lwldap32\"\n    LDAP_LIBS_BE=\"-lwldap32\"\n  fi\n  LIBS=\"$_LIBS\"\nfi\nAC_SUBST(LDAP_LIBS_FE)\nAC_SUBST(LDAP_LIBS_BE)\n\n\n# This test makes sure that run tests work at all.  Sometimes a shared\n# library is found by the linker, but the runtime linker can't find it.\n# This check should come after all modifications of compiler or linker\n# variables, and before any other run tests.\nAC_MSG_CHECKING([test program])\nAC_TRY_RUN([int main() { return 0; }],\n[AC_MSG_RESULT(ok)],\n[AC_MSG_RESULT(failed)\nAC_MSG_ERROR([[\nCould not execute a simple test program.  This may be a problem\nrelated to locating shared libraries.  Check the file 'config.log'\nfor the exact reason.]])],\n[AC_MSG_RESULT([cross-compiling])])\n\n# --------------------\n# Run tests below here\n# --------------------\n\n# Force use of our snprintf if system's doesn't do arg control\n# See comment above at snprintf test for details.\nif test \"$enable_nls\" = yes -a \"$pgac_need_repl_snprintf\" = no; then\n  PGAC_FUNC_PRINTF_ARG_CONTROL\n  if test $pgac_cv_printf_arg_control != yes ; then\n    pgac_need_repl_snprintf=yes\n  fi\nfi\n\n\ndnl Check to see if we have a working 64-bit integer type.\ndnl This breaks down into two steps:\ndnl (1) figure out if the compiler has a 64-bit int type with working\ndnl arithmetic, and if so\ndnl (2) see whether snprintf() can format the type correctly.  (Currently,\ndnl snprintf is the only library routine we really need for int8 support.)\ndnl It's entirely possible to have a compiler that handles a 64-bit type\ndnl when the C library doesn't; this is fairly likely when using gcc on\ndnl an older platform, for example.\ndnl If there is no native snprintf() or it does not handle the 64-bit type,\ndnl we force our own version of snprintf() to be used instead.\ndnl Note this test must be run after our initial check for snprintf/vsnprintf.\n\ndnl As of Postgres 8.4, we no longer support compilers without a working\ndnl 64-bit type.  But we still handle the case of snprintf being broken.\n\nPGAC_TYPE_64BIT_INT([long int])\n\nif test x\"$HAVE_LONG_INT_64\" = x\"yes\" ; then\n  pg_int64_type=\"long int\"\nelse\n  PGAC_TYPE_64BIT_INT([long long int])\n  if test x\"$HAVE_LONG_LONG_INT_64\" = x\"yes\" ; then\n    pg_int64_type=\"long long int\"\n  else\n    AC_MSG_ERROR([Cannot find a working 64-bit integer type.])\n  fi\nfi\n\nAC_DEFINE_UNQUOTED(PG_INT64_TYPE, $pg_int64_type,\n  [Define to the name of a signed 64-bit integer type.])\n\n\ndnl If we need to use \"long long int\", figure out whether nnnLL notation works.\n\nif test x\"$HAVE_LONG_LONG_INT_64\" = xyes ; then\n  AC_TRY_COMPILE([\n#define INT64CONST(x)  x##LL\nlong long int foo = INT64CONST(0x1234567890123456);\n],\n\t[],\n\t[AC_DEFINE(HAVE_LL_CONSTANTS, 1, [Define to 1 if constants of type 'long long int' should have the suffix LL.])],\n\t[])\nfi\n\n\n# If we found \"long int\" is 64 bits, assume snprintf handles it.  If\n# we found we need to use \"long long int\", better check.  We cope with\n# snprintfs that use %lld, %qd, or %I64d as the format.  If none of these\n# work, fall back to our own snprintf emulation (which we know uses %lld).\n\nif test \"$HAVE_LONG_LONG_INT_64\" = yes ; then\n  if test $pgac_need_repl_snprintf = no; then\n    PGAC_FUNC_SNPRINTF_LONG_LONG_INT_FORMAT\n    if test \"$LONG_LONG_INT_FORMAT\" = \"\"; then\n      # Force usage of our own snprintf, since system snprintf is broken\n      pgac_need_repl_snprintf=yes\n      LONG_LONG_INT_FORMAT='%lld'\n    fi\n  else\n    # Here if we previously decided we needed to use our own snprintf\n    LONG_LONG_INT_FORMAT='%lld'\n  fi\n  LONG_LONG_UINT_FORMAT=`echo \"$LONG_LONG_INT_FORMAT\" | sed 's/d$/u/'`\n  INT64_FORMAT=\"\\\"$LONG_LONG_INT_FORMAT\\\"\"\n  UINT64_FORMAT=\"\\\"$LONG_LONG_UINT_FORMAT\\\"\"\nelse\n  # Here if we are not using 'long long int' at all\n  INT64_FORMAT='\"%ld\"'\n  UINT64_FORMAT='\"%lu\"'\nfi\n\nAC_DEFINE_UNQUOTED(INT64_FORMAT, $INT64_FORMAT,\n                   [Define to the appropriate snprintf format for 64-bit ints, if any.])\n\nAC_DEFINE_UNQUOTED(UINT64_FORMAT, $UINT64_FORMAT,\n                   [Define to the appropriate snprintf format for unsigned 64-bit ints, if any.])\n\n# Now we have checked all the reasons to replace snprintf\nif test $pgac_need_repl_snprintf = yes; then\n  AC_DEFINE(USE_REPL_SNPRINTF, 1, [Use replacement snprintf() functions.])\n  AC_LIBOBJ(snprintf)\nfi\n\n# Need a #define for the size of Datum (unsigned long)\nAC_CHECK_SIZEOF([unsigned long])\n\n# And check size of void *, size_t (enables tweaks for > 32bit address space)\nAC_CHECK_SIZEOF([void *])\nAC_CHECK_SIZEOF([size_t])\n\n# Determine memory alignment requirements for the basic C data types.\n\nPGAC_CHECK_ALIGNOF(short)\nPGAC_CHECK_ALIGNOF(int)\nPGAC_CHECK_ALIGNOF(long)\nif test x\"$HAVE_LONG_LONG_INT_64\" = x\"yes\" ; then\n  PGAC_CHECK_ALIGNOF(long long int)\nfi\nPGAC_CHECK_ALIGNOF(double)\n\n# Compute maximum alignment of any basic type.\n# We assume long's alignment is at least as strong as char, short, or int;\n# but we must check long long (if it exists) and double.\n\nMAX_ALIGNOF=$pgac_cv_alignof_long\nif test $MAX_ALIGNOF -lt $pgac_cv_alignof_double ; then\n  MAX_ALIGNOF=$pgac_cv_alignof_double\nfi\nif test x\"$HAVE_LONG_LONG_INT_64\" = xyes && test $MAX_ALIGNOF -lt $pgac_cv_alignof_long_long_int ; then\n  MAX_ALIGNOF=\"$pgac_cv_alignof_long_long_int\"\nfi\nAC_DEFINE_UNQUOTED(MAXIMUM_ALIGNOF, $MAX_ALIGNOF, [Define as the maximum alignment requirement of any C data type.])\n\n\n# Some platforms predefine the types int8, int16, etc.  Only check\n# a (hopefully) representative subset.\nAC_CHECK_TYPES([int8, uint8, int64, uint64], [], [],\n[#include <stdio.h>\n#ifdef HAVE_SUPPORTDEFS_H\n#include <SupportDefs.h>\n#endif])\n\n# We also check for sig_atomic_t, which *should* be defined per ANSI\n# C, but is missing on some old platforms.\nAC_CHECK_TYPES(sig_atomic_t, [], [], [#include <signal.h>])\n\n# Check for various atomic operations now that we have checked how to declare\n# 64bit integers.\nPGAC_HAVE_GCC__SYNC_CHAR_TAS\nPGAC_HAVE_GCC__SYNC_INT32_TAS\nPGAC_HAVE_GCC__SYNC_INT32_CAS\nPGAC_HAVE_GCC__SYNC_INT64_CAS\nPGAC_HAVE_GCC__ATOMIC_INT32_CAS\nPGAC_HAVE_GCC__ATOMIC_INT64_CAS\n\n\n# If the user did not disable integer datetimes, check that\n# there is a working 64-bit integral type to use.\nif test x\"$USE_INTEGER_DATETIMES\" = x\"yes\" &&\n   test x\"$HAVE_LONG_INT_64\" = x\"no\" &&\n   test x\"$HAVE_LONG_LONG_INT_64\" = x\"no\" &&\n   test x\"$HAVE_INT64\" = x\"no\" ; then\n  AC_MSG_ERROR([\nInteger-based datetime support requires a 64-bit integer type,\nbut no such type could be found. The --disable-integer-datetimes\nconfigure option can be used to disable integer-based storage\nof datetime values.])\nfi\n\n\nif test \"$PORTNAME\" != \"win32\"\nthen\nPGAC_FUNC_POSIX_SIGNALS\nif test \"$pgac_cv_func_posix_signals\" != yes -a \"$enable_thread_safety\" = yes; then\n  AC_MSG_ERROR([\nThread-safety requires POSIX signals, which are not supported by this\noperating system.])\nfi\nfi\n\nif test $ac_cv_func_fseeko = yes; then\nAC_SYS_LARGEFILE\nenable_largefile=yes\nelse\nenable_largefile=no\nfi\nAC_SUBST(enable_largefile)\n\n# Check for largefile support (must be after AC_SYS_LARGEFILE)\nAC_CHECK_SIZEOF([off_t])\n\nif test \"$PORTNAME\" != \"win32\"; then\n# If we don't have largefile support, can't handle segsize >= 2GB.\nif test \"$ac_cv_sizeof_off_t\" -lt 8 -a \"$segsize\" != \"1\"; then\n   AC_MSG_ERROR([Large file support is not enabled. Segment size cannot be larger than 1GB.])\nfi\nfi\n\n# SunOS doesn't handle negative byte comparisons properly with +/- return\nAC_FUNC_MEMCMP\n\n\n# Select semaphore implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  if test x\"$USE_NAMED_POSIX_SEMAPHORES\" = x\"1\" ; then\n    AC_DEFINE(USE_NAMED_POSIX_SEMAPHORES, 1, [Define to select named POSIX semaphores.])\n    SEMA_IMPLEMENTATION=\"src/backend/port/posix_sema.c\"\n  else\n    if test x\"$USE_UNNAMED_POSIX_SEMAPHORES\" = x\"1\" ; then\n      AC_DEFINE(USE_UNNAMED_POSIX_SEMAPHORES, 1, [Define to select unnamed POSIX semaphores.])\n      SEMA_IMPLEMENTATION=\"src/backend/port/posix_sema.c\"\n    else\n  AC_DEFINE(USE_SYSV_SEMAPHORES, 1, [Define to select SysV-style semaphores.])\n  SEMA_IMPLEMENTATION=\"src/backend/port/sysv_sema.c\"\n    fi\n  fi\nelse\n  AC_DEFINE(USE_WIN32_SEMAPHORES, 1, [Define to select Win32-style semaphores.])\n  SEMA_IMPLEMENTATION=\"src/backend/port/win32_sema.c\"\nfi\n\n\n# Select shared-memory implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  AC_DEFINE(USE_SYSV_SHARED_MEMORY, 1, [Define to select SysV-style shared memory.])\n  SHMEM_IMPLEMENTATION=\"src/backend/port/sysv_shmem.c\"\nelse\n  AC_DEFINE(USE_WIN32_SHARED_MEMORY, 1, [Define to select Win32-style shared memory.])\n  SHMEM_IMPLEMENTATION=\"src/backend/port/win32_shmem.c\"\nfi\n\n# Select latch implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  LATCH_IMPLEMENTATION=\"src/backend/port/unix_latch.c\"\nelse\n#  LATCH_IMPLEMENTATION=\"src/backend/port/win32_latch.c\"\n  LATCH_IMPLEMENTATION=\"\"\nfi\n\n# If not set in template file, set bytes to use libc memset()\nif test x\"$MEMSET_LOOP_LIMIT\" = x\"\" ; then\n  MEMSET_LOOP_LIMIT=1024\nfi\nAC_DEFINE_UNQUOTED(MEMSET_LOOP_LIMIT, ${MEMSET_LOOP_LIMIT}, [Define bytes to use libc memset().])\n\n\nif test \"$enable_nls\" = yes ; then\n  PGAC_CHECK_GETTEXT\nfi\n\n# Check for Tcl configuration script tclConfig.sh\nif test \"$with_tcl\" = yes; then\n    PGAC_PATH_TCLCONFIGSH([$with_tclconfig])\n    PGAC_EVAL_TCLCONFIGSH([$TCL_CONFIG_SH],\n                          [TCL_INCLUDE_SPEC,TCL_LIB_FILE,TCL_LIBS,TCL_LIB_SPEC,TCL_SHARED_BUILD])\n    AC_SUBST(TCL_SHLIB_LD_LIBS)dnl don't want to double-evaluate that one\n    # now that we have TCL_INCLUDE_SPEC, we can check for <tcl.h>\n    ac_save_CPPFLAGS=$CPPFLAGS\n    CPPFLAGS=\"$TCL_INCLUDE_SPEC $CPPFLAGS\"\n    AC_CHECK_HEADER(tcl.h, [], [AC_MSG_ERROR([header file <tcl.h> is required for Tcl])])\n    CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\n#\n# Check for DocBook and tools\n#\nPGAC_PROG_NSGMLS\nPGAC_PROG_JADE\nPGAC_CHECK_DOCBOOK(4.2)\nPGAC_PATH_DOCBOOK_STYLESHEETS\nPGAC_PATH_COLLATEINDEX\nAC_CHECK_PROGS(SGMLSPL, sgmlspl)\n\n#\n# Check for test tools\n#\nif test \"$enable_tap_tests\" = yes; then\n  AC_CHECK_PROGS(PROVE, prove)\n  if test -z \"$PROVE\"; then\n    AC_MSG_ERROR([prove not found])\n  fi\n  if test -z \"$PERL\"; then\n    AC_MSG_ERROR([Perl not found])\n  fi\n  # Check for necessary modules\n  AX_PROG_PERL_MODULES(IPC::Run, ,\n    AC_MSG_ERROR([Perl module IPC::Run is required to run TAP tests]))\nfi\n# Thread testing\n\n# We have to run the thread test near the end so we have all our symbols\n# defined.  Cross compiling throws a warning.\n#\nif test \"$enable_thread_safety_force\" = yes; then\nif test \"$PORTNAME\" != \"win32\"\nthen\n  AC_MSG_WARN([\n*** Skipping thread test program.  --enable-thread-safety-force was used.\n*** Run the program in src/test/thread on the your machine and add proper\n*** locking function calls to your applications to guarantee thread safety.\n])\nelse\nAC_MSG_WARN([*** skipping thread test on Win32])\nfi\nelif test \"$enable_thread_safety\" = yes; then\nif test \"$PORTNAME\" != \"win32\"\nthen\nAC_MSG_CHECKING([thread safety of required library functions])\n\n_CFLAGS=\"$CFLAGS\"\n_LIBS=\"$LIBS\"\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS -DIN_CONFIGURE\"\nLIBS=\"$LIBS $PTHREAD_LIBS\"\nAC_TRY_RUN([#include \"$srcdir/src/test/thread/thread_test.c\"],\n  [AC_MSG_RESULT(yes)],\n  [AC_MSG_RESULT(no)\n  AC_MSG_ERROR([thread test program failed\nThis platform is not thread-safe.  Check the file 'config.log' for the\nexact reason.\n\nYou can use the configure option --enable-thread-safety-force to force\nthreads to be enabled.  But you must then run the program in\nsrc/test/thread and add locking function calls to your applications to\nguarantee thread safety.])],\n  [AC_MSG_RESULT(maybe)\n  AC_MSG_WARN([\n*** Skipping thread test program because of cross-compile build.\n*** Run the program in src/test/thread on the target machine.\n])])\nCFLAGS=\"$_CFLAGS\"\nLIBS=\"$_LIBS\"\nelse\nAC_MSG_WARN([*** skipping thread test on Win32])\nfi\nfi\n\n# If compiler will take -Wl,--as-needed (or various platform-specific\n# spellings thereof) then add that to LDFLAGS.  This is much easier than\n# trying to filter LIBS to the minimum for each executable.\n# (Note that shared library links won't use this switch, though.)\n# On (at least) some Red-Hat-derived systems, this switch breaks linking to\n# libreadline; therefore we postpone testing it until we know what library\n# dependencies readline has.  The test code will try to link with $LIBS.\nif test \"$with_readline\" = yes; then\n  link_test_func=readline\nelse\n  link_test_func=exit\nfi\n\nif test \"$PORTNAME\" = \"openbsd\"; then\n  PGAC_PROG_CC_LDFLAGS_OPT([-Wl,-Bdynamic], $link_test_func)\nelse\n  PGAC_PROG_CC_LDFLAGS_OPT([-Wl,--as-needed], $link_test_func)\nfi\n\n# Begin output steps\n\nAC_MSG_NOTICE([using CFLAGS=$CFLAGS])\nAC_MSG_NOTICE([using CPPFLAGS=$CPPFLAGS])\nAC_MSG_NOTICE([using LDFLAGS=$LDFLAGS])\nAC_MSG_NOTICE([using LIBS=$LIBS])\n\n# Create compiler version string\nif test x\"$GCC\" = x\"yes\" ; then\n  cc_string=\"GCC `${CC} --version | sed q`\"\nelse\n  cc_string=$CC\nfi\n\nAC_DEFINE_UNQUOTED(PG_VERSION_STR,\n                   [\"PostgreSQL $PG_VERSION (Greenplum Database $GP_VERSION) on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \\* 8`-bit\"],\n                   [A string containing the version number, platform, and C compiler])\n\n# Supply a numeric version string for use by 3rd party add-ons\n# awk -F is a regex on some platforms, and not on others, so make \".\" a tab\n[PG_VERSION_NUM=\"`echo \"$PG_PACKAGE_VERSION\" | sed 's/[A-Za-z].*$//' |\ntr '.' '\t' |\n$AWK '{printf \"%d%02d%02d\", $1, $2, (NF >= 3) ? $3 : 0}'`\"]\nAC_DEFINE_UNQUOTED(PG_VERSION_NUM, $PG_VERSION_NUM, [PostgreSQL version as a number])\n\n\n# prepare build tree if outside source tree\n# Note 1: test -ef might not exist, but it's more reliable than `pwd`.\n# Note 2: /bin/pwd might be better than shell's built-in at getting\n#         a symlink-free name.\nif ( test \"$srcdir\" -ef . ) >/dev/null 2>&1 || test \"`cd $srcdir && /bin/pwd`\" = \"`/bin/pwd`\"; then\n  vpath_build=no\nelse\n  vpath_build=yes\n  if test \"$no_create\" != yes; then\n    _AS_ECHO_N([preparing build tree... ])\n    pgac_abs_top_srcdir=`cd \"$srcdir\" && pwd`\n    $SHELL \"$ac_aux_dir/prep_buildtree\" \"$pgac_abs_top_srcdir\" \".\" \\\n      || AC_MSG_ERROR(failed)\n    AC_MSG_RESULT(done)\n  fi\nfi\nAC_SUBST(vpath_build)\n\n\nAC_CONFIG_FILES([GNUmakefile src/Makefile.global])\n\nAC_CONFIG_LINKS([\n  src/backend/port/dynloader.c:src/backend/port/dynloader/${template}.c\n  src/backend/port/pg_sema.c:${SEMA_IMPLEMENTATION}\n  src/backend/port/pg_shmem.c:${SHMEM_IMPLEMENTATION}\n  src/backend/port/pg_latch.c:${LATCH_IMPLEMENTATION}\n  src/include/dynloader.h:src/backend/port/dynloader/${template}.h\n  src/include/pg_config_os.h:src/include/port/${template}.h\n  src/Makefile.port:src/makefiles/Makefile.${template}\n])\n\nif test \"$PORTNAME\" = \"win32\"; then\nAC_CONFIG_COMMANDS([check_win32_symlinks],[\n# Links sometimes fail undetected on Mingw -\n# so here we detect it and warn the user\nfor FILE in $CONFIG_LINKS\n do\n\t# test -e works for symlinks in the MinGW console\n\ttest -e `expr \"$FILE\" : '\\([[^:]]*\\)'` || AC_MSG_WARN([*** link for $FILE -- please fix by hand])\n done\n])\nfi\n\nAC_CONFIG_HEADERS([src/include/pg_config.h],\n[\n# Update timestamp for pg_config.h (see Makefile.global)\necho >src/include/stamp-h\n])\n\nAC_CONFIG_HEADERS([src/interfaces/ecpg/include/ecpg_config.h],\n                  [echo >src/interfaces/ecpg/include/stamp-h])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/include/pg_config.h.win32": "/* src/include/pg_config.h.  Generated by configure.  */\n/* src/include/pg_config.h.in.  Generated from configure.in by autoheader.  */\n\n#if defined(__i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n#if defined(__amd64) && !defined(__amd64__)\n#define __amd64__\n#endif\n\n#if defined(__x86_64) && !defined(__x86_64__)\n#define __x86_64__\n#endif\n\n#if defined(__sparc) && !defined(__sparc__)\n#define __sparc__\n#endif\n\n#ifndef\t\t\tBIG_ENDIAN\n#define\t\t\tBIG_ENDIAN\t\t4321\n#endif\n#ifndef\t\t\tLITTLE_ENDIAN\n#define\t\t\tLITTLE_ENDIAN\t1234\n#endif\n#ifndef\t\t\tPDP_ENDIAN\n#define\t\t\tPDP_ENDIAN\t\t3412\n#endif\n\n#ifndef\t\t\tBYTE_ORDER\n\n#ifdef __sparc__\n#define\t\t  BYTE_ORDER\t  BIG_ENDIAN\n#endif\n#if defined(__i386__) || defined(__x86_64__)\n#define\t\t BYTE_ORDER\t\t LITTLE_ENDIAN\n#endif\n#endif\n\n/* This file is generated from MingW ./configure, and with the following\n * changes to be valid for Visual C++ (and compatible):\n *\n * HAVE_CBRT, HAVE_FUNCNAME_FUNC, HAVE_FUNCNAME_FUNCTION, HAVE_GETOPT,\n * HAVE_GETOPT_H, HAVE_GETOPT_LONG, HAVE_RINT, HAVE_STRINGS_H,\n * HAVE_STRTOLL, HAVE_STRTOULL, HAVE_STRUCT_OPTION, ENABLE_THREAD_SAFETY,\n * USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n *\n */\n\n/* Define to the type of arg 1 of 'accept' */\n#define ACCEPT_TYPE_ARG1 unsigned int\n\n/* Define to the type of arg 2 of 'accept' */\n#define ACCEPT_TYPE_ARG2 struct sockaddr *\n\n/* Define to the type of arg 3 of 'accept' */\n#define ACCEPT_TYPE_ARG3 int\n\n/* Define to the return type of 'accept' */\n#define ACCEPT_TYPE_RETURN unsigned int PASCAL\n\n/* The alignment requirement of a `double'. */\n#define ALIGNOF_DOUBLE 8\n\n/* The alignment requirement of a `int'. */\n#define ALIGNOF_INT 4\n\n/* The alignment requirement of a `long'. */\n#define ALIGNOF_LONG 4\n\n/* The alignment requirement of a `long long int'. */\n#define ALIGNOF_LONG_LONG_INT 8\n\n/* The alignment requirement of a `short'. */\n#define ALIGNOF_SHORT 2\n\n/* Define to the default TCP port number on which the server listens and to\n   which clients will try to connect. This can be overridden at run-time, but\n   it's convenient if your clients have the right default compiled in.\n   (--with-pgport=PORTNUM) */\n#define DEF_PGPORT 5432\n\n/* Define to the default TCP port number as a string constant. */\n#define DEF_PGPORT_STR \"5432\"\n\n/* Define to 1 if you want National Language Support. (--enable-nls) */\n/* #undef ENABLE_NLS */\n\n/* Define to 1 to build client libraries as thread-safe code.\n   (--enable-thread-safety) */\n#define ENABLE_THREAD_SAFETY 1\n\n/* Define to 1 if getpwuid_r() takes a 5th argument. */\n/* #undef GETPWUID_R_5ARG */\n\n/* Define to 1 if gettimeofday() takes only 1 argument. */\n/* #undef GETTIMEOFDAY_1ARG */\n\n#ifdef GETTIMEOFDAY_1ARG\n# define gettimeofday(a,b) gettimeofday(a)\n#endif\n\n/* Define to 1 if you have the `atexit' function. */\n#define HAVE_ATEXIT 1\n\n/* Define to 1 if you have the `cbrt' function. */\n//#define HAVE_CBRT 1\n\n/* Define to 1 if you have the `class' function. */\n/* #undef HAVE_CLASS */\n\n/* Define to 1 if you have the `crypt' function. */\n/* #undef HAVE_CRYPT */\n\n/* Define to 1 if you have the <crypt.h> header file. */\n/* #undef HAVE_CRYPT_H */\n\n/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you\n   don't. */\n#define HAVE_DECL_FDATASYNC 0\n\n/* Define to 1 if you have the declaration of `F_FULLFSYNC', and to 0 if you\n   don't. */\n#define HAVE_DECL_F_FULLFSYNC 0\n\n/* Define to 1 if you have the declaration of `snprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL_SNPRINTF 1\n\n/* Define to 1 if you have the declaration of `vsnprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL_VSNPRINTF 1\n\n/* Define to 1 if you have the <dld.h> header file. */\n/* #undef HAVE_DLD_H */\n\n/* Define to 1 if you have the `dlopen' function. */\n/* #undef HAVE_DLOPEN */\n\n/* Define to 1 if you have the <editline/history.h> header file. */\n/* #undef HAVE_EDITLINE_HISTORY_H */\n\n/* Define to 1 if you have the <editline/readline.h> header file. */\n/* #undef HAVE_EDITLINE_READLINE_H */\n\n/* Define to 1 if you have the `fcvt' function. */\n#define HAVE_FCVT 1\n\n/* Define to 1 if you have the `fdatasync' function. */\n/* #undef HAVE_FDATASYNC */\n\n/* Define to 1 if you have finite(). */\n#define HAVE_FINITE 1\n\n/* Define to 1 if you have the `fpclass' function. */\n/* #undef HAVE_FPCLASS */\n\n/* Define to 1 if you have the `fp_class' function. */\n/* #undef HAVE_FP_CLASS */\n\n/* Define to 1 if you have the `fp_class_d' function. */\n/* #undef HAVE_FP_CLASS_D */\n\n/* Define to 1 if you have the <fp_class.h> header file. */\n/* #undef HAVE_FP_CLASS_H */\n\n/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */\n#define HAVE_FSEEKO 1\n\n/* Define to 1 if your compiler understands __func__. */\n//#define HAVE_FUNCNAME__FUNC 1\n\n/* Define to 1 if your compiler understands __FUNCTION__. */\n#define HAVE_FUNCNAME__FUNCTION 1\n\n/* Define to 1 if you have getaddrinfo(). */\n/* #undef HAVE_GETADDRINFO */\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n/* #undef HAVE_GETHOSTBYNAME_R */\n\n/* Define to 1 if you have the `getopt' function. */\n//#define HAVE_GETOPT 1\n\n/* Define to 1 if you have the <getopt.h> header file. */\n//#define HAVE_GETOPT_H 1\n\n/* Define to 1 if you have the `getopt_long' function. */\n//#define HAVE_GETOPT_LONG 1\n\n/* Define to 1 if you have the `getpeereid' function. */\n/* #undef HAVE_GETPEEREID */\n\n/* Define to 1 if you have the `getpwuid_r' function. */\n/* #undef HAVE_GETPWUID_R */\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #undef HAVE_GETRUSAGE */\n\n/* Define to 1 if you have the <history.h> header file. */\n/* #undef HAVE_HISTORY_H */\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n/* #undef HAVE_IEEEFP_H */\n\n/* Define to 1 if you have the `inet_aton' function. */\n/* #undef HAVE_INET_ATON */\n\n/* Define to 1 if the system has the type `int64'. */\n/* #undef HAVE_INT64 */\n\n/* Define to 1 if the system has the type `int8'. */\n/* #undef HAVE_INT8 */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the global variable 'int optreset'. */\n/* #define HAVE_INT_OPTRESET 1 */\n\n/* Define to 1 if you have the global variable 'int timezone'. */\n#define HAVE_INT_TIMEZONE\n\n/* Define to 1 if you have support for IPv6. */\n#define HAVE_IPV6 1\n\n/* Define to 1 if you have isinf(). */\n#define HAVE_ISINF 1\n\n/* Define to 1 if you have the <kernel/image.h> header file. */\n/* #undef HAVE_KERNEL_IMAGE_H */\n\n/* Define to 1 if you have the <kernel/OS.h> header file. */\n/* #undef HAVE_KERNEL_OS_H */\n\n/* Define to 1 if `e_data' is member of `krb5_error'. */\n/* #undef HAVE_KRB5_ERROR_E_DATA */\n\n/* Define to 1 if `text.data' is member of `krb5_error'. */\n/* #undef HAVE_KRB5_ERROR_TEXT_DATA */\n\n/* Define to 1 if `client' is member of `krb5_ticket'. */\n/* #undef HAVE_KRB5_TICKET_CLIENT */\n\n/* Define to 1 if `enc_part2' is member of `krb5_ticket'. */\n/* #undef HAVE_KRB5_TICKET_ENC_PART2 */\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n/* #undef HAVE_LANGINFO_H */\n\n/* Define to 1 if you have the <ldap.h> header file. */\n/* #undef HAVE_LDAP_H */\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n/* #undef HAVE_LIBCRYPTO */\n\n/* Define to 1 if you have the `eay32' library (-leay32). */\n/* #undef HAVE_LIBEAY32 */\n\n/* Define to 1 if you have the `ldap' library (-lldap). */\n/* #undef HAVE_LIBLDAP */\n\n/* Define to 1 if you have the `pam' library (-lpam). */\n/* #undef HAVE_LIBPAM */\n\n/* Define if you have a function readline library */\n/* #undef HAVE_LIBREADLINE */\n\n/* Define to 1 if you have the `ssl' library (-lssl). */\n/* #undef HAVE_LIBSSL */\n\n/* Define to 1 if you have the `ssleay32' library (-lssleay32). */\n/* #undef HAVE_LIBSSLEAY32 */\n\n/* Define to 1 if you have the `wldap32' library (-lwldap32). */\n/* #undef HAVE_LIBWLDAP32 */\n\n/* Define to 1 if you have the `z' library (-lz). */\n/* #undef HAVE_LIBZ */\n\n/* Define to 1 if constants of type 'long long int' should have the suffix LL.\n   */\n#if (_MSC_VER > 1200)\n#define HAVE_LL_CONSTANTS 1\n#endif\n\n/* Define to 1 if `long int' works and is 64 bits. */\n/* #undef HAVE_LONG_INT_64 */\n\n/* Define to 1 if `long long int' works and is 64 bits. */\n#if (_MSC_VER > 1200)\n#define HAVE_LONG_LONG_INT_64\n#endif\n\n/* Define to 1 if you have the `memmove' function. */\n#define HAVE_MEMMOVE 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#define HAVE_NETINET_IN_H 1\n\n/* Define to 1 if you have the <netinet/tcp.h> header file. */\n/* #undef HAVE_NETINET_TCP_H */\n\n/* Define to 1 if you have the `on_exit' function. */\n/* #undef HAVE_ON_EXIT */\n\n/* Define to 1 if you have the <pam/pam_appl.h> header file. */\n/* #undef HAVE_PAM_PAM_APPL_H */\n\n/* Define to 1 if you have the `poll' function. */\n/* #undef HAVE_POLL */\n\n/* Define to 1 if you have the <poll.h> header file. */\n/* #undef HAVE_POLL_H */\n\n/* Define to 1 if you have the POSIX signal interface. */\n/* #undef HAVE_POSIX_SIGNALS */\n\n/* Define to 1 if you have the `pstat' function. */\n/* #undef HAVE_PSTAT */\n\n/* Define to 1 if the PS_STRINGS thing exists. */\n/* #undef HAVE_PS_STRINGS */\n\n/* Define if you have POSIX threads libraries and header files. */\n/* #undef HAVE_PTHREAD */\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#define HAVE_PWD_H 1\n\n/* Define to 1 if you have the `random' function. */\n/* #undef HAVE_RANDOM */\n\n/* Define to 1 if you have the <readline.h> header file. */\n/* #undef HAVE_READLINE_H */\n\n/* Define to 1 if you have the <readline/history.h> header file. */\n/* #undef HAVE_READLINE_HISTORY_H */\n\n/* Define to 1 if you have the <readline/readline.h> header file. */\n/* #undef HAVE_READLINE_READLINE_H */\n\n/* Define to 1 if you have the `readlink' function. */\n/* #undef HAVE_READLINK */\n\n/* Define to 1 if you have the `replace_history_entry' function. */\n/* #undef HAVE_REPLACE_HISTORY_ENTRY */\n\n/* Define to 1 if you have the `rint' function. */\n/*#define HAVE_RINT 1*/\n\n/* Define to 1 if you have the global variable\n   'rl_completion_append_character'. */\n/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */\n\n/* Define to 1 if you have the `rl_completion_matches' function. */\n/* #undef HAVE_RL_COMPLETION_MATCHES */\n\n/* Define to 1 if you have the `rl_filename_completion_function' function. */\n/* #undef HAVE_RL_FILENAME_COMPLETION_FUNCTION */\n\n/* Define to 1 if you have the <security/pam_appl.h> header file. */\n/* #undef HAVE_SECURITY_PAM_APPL_H */\n\n/* Define to 1 if you have the `setproctitle' function. */\n/* #undef HAVE_SETPROCTITLE */\n\n/* Define to 1 if you have the `setsid' function. */\n/* #undef HAVE_SETSID */\n\n/* Define to 1 if you have the `sigprocmask' function. */\n/* #undef HAVE_SIGPROCMASK */\n\n/* Define to 1 if you have sigsetjmp(). */\n/* #undef HAVE_SIGSETJMP */\n\n/* Define to 1 if the system has the type `sig_atomic_t'. */\n#define HAVE_SIG_ATOMIC_T 1\n\n/* Define to 1 if you have the `snprintf' function. */\n/* #undef HAVE_SNPRINTF */\n\n/* Define to 1 if you have spinlocks. */\n#define HAVE_SPINLOCKS 1\n\n/* Define to 1 if you have atomics. */\n#define HAVE_ATOMICS 1\n\n/* Define to 1 if you have the `srandom' function. */\n/* #undef HAVE_SRANDOM */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n/* #define HAVE_STDINT_H 1 */\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strdup' function. */\n#define HAVE_STRDUP 1\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef HAVE_STRERROR\n#define HAVE_STRERROR 1\n#endif\n\n/* Define to 1 if you have the `strerror_r' function. */\n/* #undef HAVE_STRERROR_R */\n\n/* Define to 1 if cpp supports the ANSI # stringizing operator. */\n#define HAVE_STRINGIZE 1\n\n/* Define to 1 if you have the <strings.h> header file. */\n/*#define HAVE_STRINGS_H 1 */\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the `strtol' function. */\n#define HAVE_STRTOL 1\n\n/* Define to 1 if you have the `strtoll' function. */\n//#define HAVE_STRTOLL 1\n\n/* Define to 1 if you have the `strtoq' function. */\n/* #undef HAVE_STRTOQ */\n\n/* Define to 1 if you have the `strtoul' function. */\n#define HAVE_STRTOUL 1\n\n/* Define to 1 if you have the `strtoull' function. */\n//#define HAVE_STRTOULL 1\n\n/* Define to 1 if you have the `strtouq' function. */\n/* #undef HAVE_STRTOUQ */\n\n/* Define to 1 if the system has the type `struct addrinfo'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_ADDRINFO 1\n#endif\n\n/* Define to 1 if the system has the type `struct cmsgcred'. */\n/* #undef HAVE_STRUCT_CMSGCRED */\n\n/* Define to 1 if the system has the type `struct fcred'. */\n/* #undef HAVE_STRUCT_FCRED */\n\n/* Define to 1 if the system has the type `struct option'. */\n//#define HAVE_STRUCT_OPTION 1\n\n/* Define to 1 if `sa_len' is member of `struct sockaddr'. */\n/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */\n\n/* Define to 1 if the system has the type `struct sockaddr_storage'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n#endif\n\n/* Define to 1 if `ss_family' is member of `struct sockaddr_storage'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1\n#endif\n\n/* Define to 1 if `ss_len' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n/* Define to 1 if `__ss_family' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */\n\n/* Define to 1 if `__ss_len' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_LEN */\n\n/* Define to 1 if the system has the type `struct sockaddr_un'. */\n/* #undef HAVE_STRUCT_SOCKADDR_UN */\n\n/* Define to 1 if the system has the type `struct sockcred'. */\n/* #undef HAVE_STRUCT_SOCKCRED */\n\n/* Define to 1 if `tm_zone' is member of `struct tm'. */\n/* #undef HAVE_STRUCT_TM_TM_ZONE */\n\n/* Define to 1 if you have the <SupportDefs.h> header file. */\n/* #undef HAVE_SUPPORTDEFS_H */\n\n/* Define to 1 if you have the `symlink' function. */\n#define HAVE_SYMLINK 1\n\n/* Define to 1 if you have the `sysconf' function. */\n/* #undef HAVE_SYSCONF */\n\n/* Define to 1 if you have the syslog interface. */\n/* #undef HAVE_SYSLOG */\n\n/* Define to 1 if you have the <sys/ipc.h> header file. */\n/* #undef HAVE_SYS_IPC_H */\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n/* #undef HAVE_SYS_POLL_H */\n\n/* Define to 1 if you have the <sys/pstat.h> header file. */\n/* #undef HAVE_SYS_PSTAT_H */\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n/* #undef HAVE_SYS_SELECT_H */\n\n/* Define to 1 if you have the <sys/sem.h> header file. */\n/* #undef HAVE_SYS_SEM_H */\n\n/* Define to 1 if you have the <sys/shm.h> header file. */\n/* #undef HAVE_SYS_SHM_H */\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n/* #undef HAVE_SYS_UN_H */\n\n/* Define to 1 if you have the <termios.h> header file. */\n/* #undef HAVE_TERMIOS_H */\n\n/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use\n   `HAVE_STRUCT_TM_TM_ZONE' instead. */\n/* #undef HAVE_TM_ZONE */\n\n/* Define to 1 if you have the `towlower' function. */\n#define HAVE_TOWLOWER 1\n\n/* Define to 1 if you have the external array `tzname'. */\n/* #undef HAVE_TZNAME */\n\n/* Define to 1 if the system has the type `uint64'. */\n/* #undef HAVE_UINT64 */\n\n/* Define to 1 if the system has the type `uint8'. */\n/* #undef HAVE_UINT8 */\n\n/* Define to 1 if the system has the type `union semun'. */\n/* #undef HAVE_UNION_SEMUN */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have unix sockets. */\n/* #undef HAVE_UNIX_SOCKETS */\n\n/* Define to 1 if you have the `unsetenv' function. */\n/* #undef HAVE_UNSETENV */\n\n/* Define to 1 if you have the `utime' function. */\n#define HAVE_UTIME 1\n\n/* Define to 1 if you have the `utimes' function. */\n/* #undef HAVE_UTIMES */\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H 1\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#define HAVE_VSNPRINTF 1\n\n/* Define to 1 if you have the `waitpid' function. */\n/* #undef HAVE_WAITPID */\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#define HAVE_WCHAR_H 1\n\n/* Define to 1 if you have the `wcstombs' function. */\n#define HAVE_WCSTOMBS 1\n\n/* Define to 1 if you have the <wctype.h> header file. */\n#define HAVE_WCTYPE_H 1\n\n/* Define to 1 if you have the <winldap.h> header file. */\n/* #undef HAVE_WINLDAP_H */\n\n/* Define to 1 if you have __cpuid. */\n#define HAVE__CPUID 1\n\n/* Define to 1 if you have __get_cpuid. */\n#undef HAVE__GET_CPUID\n\n/* Define to 1 if your compiler understands __builtin_constant_p. */\n/* #undef HAVE__BUILTIN_CONSTANT_P */\n\n/* Define to 1 if your compiler understands __builtin_types_compatible_p. */\n/* #undef HAVE__BUILTIN_TYPES_COMPATIBLE_P */\n\n/* Define to 1 if your compiler understands __builtin_unreachable. */\n/* #undef HAVE__BUILTIN_UNREACHABLE */\n\n/* Define to 1 if your compiler understands _Static_assert. */\n/* #undef HAVE__STATIC_ASSERT */\n\n/* Define to 1 if your compiler understands __VA_ARGS__ in macros. */\n#define HAVE__VA_ARGS 1\n\n/* Define to the appropriate snprintf format for 64-bit ints, if any. */\n#define INT64_FORMAT \"%lld\"\n\n/* Define to build with Kerberos 5 support. (--with-krb5) */\n/* #undef KRB5 */\n\n/* Define to the location of locale files. */\n/* #undef LOCALEDIR */\n\n/* Define as the maximum alignment requirement of any C data type. */\n#define MAXIMUM_ALIGNOF 8\n\n/* Define bytes to use libc memset(). */\n#define MEMSET_LOOP_LIMIT 1024\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"support@greenplum.com\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"Greenplum Database\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"Greenplum Database 8.3devel\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"8.3.23\"\n\n/* PostgreSQL version as a string */\n#define PG_VERSION \"8.3.23\"\n\n/* PostgreSQL version as a number */\n#define PG_VERSION_NUM 80323\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"greenplum\"\n\n/* Define to the name of the default PostgreSQL service principal in Kerberos.\n   (--with-krb-srvnam=NAME) */\n#define PG_KRB_SRVNAM \"greenplum\"\n\n/* A string containing the version number, platform, and C compiler */\n#define PG_VERSION_STR \"Uninitialized version string (win32)\"\n\n/* Define to the necessary symbol if this constant uses a non-standard name on\n   your system. */\n/* #undef PTHREAD_CREATE_JOINABLE */\n\n/* The size of a `size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T 4\n\n/* The size of a `unsigned long', as computed by sizeof. */\n#define SIZEOF_UNSIGNED_LONG 4\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define to 1 if strerror_r() returns a int. */\n/* #undef STRERROR_R_INT */\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n/* #undef TM_IN_SYS_TIME */\n\n/* Define to the appropriate snprintf format for unsigned 64-bit ints, if any.\n   */\n#define UINT64_FORMAT \"%llu\"\n\n/* Define to 1 to build with assertion checks. (--enable-cassert) */\n/* #undef USE_ASSERT_CHECKING */\n\n/* Define to 1 to build with Bonjour support. (--with-bonjour) */\n/* #undef USE_BONJOUR */\n\n/* Define to 1 if you want 64-bit integer timestamp and interval support.\n   (--enable-integer-datetimes) */\n/* #undef USE_INTEGER_DATETIMES */\n\n/* Define to 1 to build with LDAP support. (--with-ldap) */\n/* #undef USE_LDAP */\n\n/* Define to select named POSIX semaphores. */\n/* #undef USE_NAMED_POSIX_SEMAPHORES */\n\n/* Define to 1 to build with PAM support. (--with-pam) */\n/* #undef USE_PAM */\n\n/* Use replacement snprintf() functions. */\n#define USE_REPL_SNPRINTF 1\n\n/* Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check. */\n#if (_MSC_VER < 1500)\n#define USE_SLICING_BY_8_CRC32C 1\n#end\n\n/* Define to 1 use Intel SSE 4.2 CRC instructions. */\n/* #undef USE_SSE42_CRC32C */\n\n/* Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check. */\n#if (_MSC_VER >= 1500)\n#define USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n#endif\n\n/* Define to build with (Open)SSL support. (--with-openssl) */\n/* #undef USE_SSL */\n\n/* Define to select SysV-style semaphores. */\n/* #undef USE_SYSV_SEMAPHORES */\n\n/* Define to select SysV-style shared memory. */\n#define USE_SYSV_SHARED_MEMORY 1\n\n/* Define to select unnamed POSIX semaphores. */\n/* #undef USE_UNNAMED_POSIX_SEMAPHORES */\n\n/* Define to select Win32-style semaphores. */\n#define USE_WIN32_SEMAPHORES\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n/* #undef _FILE_OFFSET_BITS */\n\n/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n/* #undef _LARGEFILE_SOURCE */\n\n/* Define for large files, on AIX-style hosts. */\n/* #undef _LARGE_FILES */\n\n/* Define to empty if `const' does not conform to ANSI C. */\n/* #undef const */\n\n/* Define as `__inline' if that's what the C compiler calls it, or to nothing\n   if it is not supported. */\n/* #undef inline */\n\n/* Define to empty if the C compiler does not understand signed types. */\n/* #undef signed */\n\n/* Define to empty if the keyword `volatile' does not work. Warning: valid\n   code using `volatile' can become incorrect without. Disable with care. */\n/* #undef volatile */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/include/pg_config.h.in": "/* src/include/pg_config.h.in.  Generated from configure.in by autoheader.  */\n\n/* Define to the type of arg 1 of 'accept' */\n#undef ACCEPT_TYPE_ARG1\n\n/* Define to the type of arg 2 of 'accept' */\n#undef ACCEPT_TYPE_ARG2\n\n/* Define to the type of arg 3 of 'accept' */\n#undef ACCEPT_TYPE_ARG3\n\n/* Define to the return type of 'accept' */\n#undef ACCEPT_TYPE_RETURN\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* The alignment requirement of a `double'. */\n#undef ALIGNOF_DOUBLE\n\n/* The alignment requirement of a `int'. */\n#undef ALIGNOF_INT\n\n/* The alignment requirement of a `long'. */\n#undef ALIGNOF_LONG\n\n/* The alignment requirement of a `long long int'. */\n#undef ALIGNOF_LONG_LONG_INT\n\n/* The alignment requirement of a `short'. */\n#undef ALIGNOF_SHORT\n\n/* Define to the default TCP port number on which the server listens and to\n   which clients will try to connect. This can be overridden at run-time, but\n   it's convenient if your clients have the right default compiled in.\n   (--with-pgport=PORTNUM) */\n#undef DEF_PGPORT\n\n/* Define to the default TCP port number as a string constant. */\n#undef DEF_PGPORT_STR\n\n/* Define to 1 to enable DTrace support. (--enable-dtrace) */\n#undef ENABLE_DTRACE\n\n/* Define to build with GSSAPI support. (--with-gssapi) */\n#undef ENABLE_GSS\n\n/* Define to 1 to build client libraries as thread-safe code.\n   (--enable-thread-safety) */\n#undef ENABLE_THREAD_SAFETY\n\n/* Define to 1 if getpwuid_r() takes a 5th argument. */\n#undef GETPWUID_R_5ARG\n\n/* Define to 1 if gettimeofday() takes only 1 argument. */\n#undef GETTIMEOFDAY_1ARG\n\n#ifdef GETTIMEOFDAY_1ARG\n# define gettimeofday(a,b) gettimeofday(a)\n#endif\n\n/* Greenplum major version as a string */\n#undef GP_MAJORVERSION\n\n/* A string containing the Greenplum version number */\n#undef GP_VERSION\n\n/* Greenplum version as a number */\n#undef GP_VERSION_NUM\n\n/* Define to 1 if you have the <apr_getopt.h> header file. */\n#undef HAVE_APR_GETOPT_H\n\n/* Define to 1 if you have the `atexit' function. */\n#undef HAVE_ATEXIT\n\n/* Define to 1 if you want to use atomics. */\n#undef HAVE_ATOMICS\n\n/* Define to 1 if you have the <atomic.h> header file. */\n#undef HAVE_ATOMIC_H\n\n/* Define to 1 if you have the `cbrt' function. */\n#undef HAVE_CBRT\n\n/* Define to 1 if you have the `class' function. */\n#undef HAVE_CLASS\n\n/* Define to 1 if you have the `crypt' function. */\n#undef HAVE_CRYPT\n\n/* Define to 1 if you have the <crypt.h> header file. */\n#undef HAVE_CRYPT_H\n\n/* define if the compiler supports basic C++11 syntax */\n#undef HAVE_CXX11\n\n/* Define to 1 if you have the declaration of `CURLOPT_MAIL_FROM', and to 0 if\n   you don't. */\n#undef HAVE_DECL_CURLOPT_MAIL_FROM\n\n/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you\n   don't. */\n#undef HAVE_DECL_FDATASYNC\n\n/* Define to 1 if you have the declaration of `F_FULLFSYNC', and to 0 if you\n   don't. */\n#undef HAVE_DECL_F_FULLFSYNC\n\n/* Define to 1 if you have the declaration of `posix_fadvise', and to 0 if you\n   don't. */\n#undef HAVE_DECL_POSIX_FADVISE\n\n/* Define to 1 if you have the declaration of `snprintf', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SNPRINTF\n\n/* Define to 1 if you have the declaration of `strlcat', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRLCAT\n\n/* Define to 1 if you have the declaration of `strlcpy', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRLCPY\n\n/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SYS_SIGLIST\n\n/* Define to 1 if you have the declaration of `vsnprintf', and to 0 if you\n   don't. */\n#undef HAVE_DECL_VSNPRINTF\n\n/* Define to 1 if you have the <dld.h> header file. */\n#undef HAVE_DLD_H\n\n/* Define to 1 if you have the `dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the <editline/history.h> header file. */\n#undef HAVE_EDITLINE_HISTORY_H\n\n/* Define to 1 if you have the <editline/readline.h> header file. */\n#undef HAVE_EDITLINE_READLINE_H\n\n/* Define to 1 if you have the <endian.h> header file. */\n#undef HAVE_ENDIAN_H\n\n/* Define to 1 if you have the `ERR_set_mark' function. */\n#undef HAVE_ERR_SET_MARK\n\n/* Define to 1 if you have the <event.h> header file. */\n#undef HAVE_EVENT_H\n\n/* Define to 1 if you have the `fcvt' function. */\n#undef HAVE_FCVT\n\n/* Define to 1 if you have the `fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the `fpclass' function. */\n#undef HAVE_FPCLASS\n\n/* Define to 1 if you have the `fp_class' function. */\n#undef HAVE_FP_CLASS\n\n/* Define to 1 if you have the `fp_class_d' function. */\n#undef HAVE_FP_CLASS_D\n\n/* Define to 1 if you have the <fp_class.h> header file. */\n#undef HAVE_FP_CLASS_H\n\n/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */\n#undef HAVE_FSEEKO\n\n/* Define to 1 if your compiler understands __func__. */\n#undef HAVE_FUNCNAME__FUNC\n\n/* Define to 1 if your compiler understands __FUNCTION__. */\n#undef HAVE_FUNCNAME__FUNCTION\n\n/* Define to 1 if you have __sync_lock_test_and_set(int *) and friends. */\n#undef HAVE_GCC_INT_ATOMICS\n\n/* Define to 1 if you have __atomic_compare_exchange_n(int *, int *, int). */\n#undef HAVE_GCC__ATOMIC_INT32_CAS\n\n/* Define to 1 if you have __atomic_compare_exchange_n(int64 *, int *, int64).\n   */\n#undef HAVE_GCC__ATOMIC_INT64_CAS\n\n/* Define to 1 if you have __sync_lock_test_and_set(char *) and friends. */\n#undef HAVE_GCC__SYNC_CHAR_TAS\n\n/* Define to 1 if you have __sync_compare_and_swap(int *, int, int). */\n#undef HAVE_GCC__SYNC_INT32_CAS\n\n/* Define to 1 if you have __sync_lock_test_and_set(int *) and friends. */\n#undef HAVE_GCC__SYNC_INT32_TAS\n\n/* Define to 1 if you have __sync_compare_and_swap(int64 *, int64, int64). */\n#undef HAVE_GCC__SYNC_INT64_CAS\n\n/* Define to 1 if you have the `getaddrinfo' function. */\n#undef HAVE_GETADDRINFO\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define to 1 if you have the `getifaddrs' function. */\n#undef HAVE_GETIFADDRS\n\n/* Define to 1 if you have the `getopt' function. */\n#undef HAVE_GETOPT\n\n/* Define to 1 if you have the <getopt.h> header file. */\n#undef HAVE_GETOPT_H\n\n/* Define to 1 if you have the `getopt_long' function. */\n#undef HAVE_GETOPT_LONG\n\n/* Define to 1 if you have the `getpeereid' function. */\n#undef HAVE_GETPEEREID\n\n/* Define to 1 if you have the `getpeerucred' function. */\n#undef HAVE_GETPEERUCRED\n\n/* Define to 1 if you have the `getpwuid_r' function. */\n#undef HAVE_GETPWUID_R\n\n/* Define to 1 if you have the `getrlimit' function. */\n#undef HAVE_GETRLIMIT\n\n/* Define to 1 if you have the `getrusage' function. */\n#undef HAVE_GETRUSAGE\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the <gpdbcost/CCostModelGPDB.h> header file. */\n#undef HAVE_GPDBCOST_CCOSTMODELGPDB_H\n\n/* Define to 1 if you have the <gpopt/init.h> header file. */\n#undef HAVE_GPOPT_INIT_H\n\n/* Define to 1 if you have the <gpos/_api.h> header file. */\n#undef HAVE_GPOS__API_H\n\n/* Define to 1 if you have the <gssapi/gssapi.h> header file. */\n#undef HAVE_GSSAPI_GSSAPI_H\n\n/* Define to 1 if you have the <gssapi.h> header file. */\n#undef HAVE_GSSAPI_H\n\n/* Define to 1 if you have the <history.h> header file. */\n#undef HAVE_HISTORY_H\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define to 1 if you have the <ifaddrs.h> header file. */\n#undef HAVE_IFADDRS_H\n\n/* Define to 1 if you have the `inet_aton' function. */\n#undef HAVE_INET_ATON\n\n/* Define to 1 if the system has the type `int64'. */\n#undef HAVE_INT64\n\n/* Define to 1 if the system has the type `int8'. */\n#undef HAVE_INT8\n\n/* Define to 1 if the system has the type `intptr_t'. */\n#undef HAVE_INTPTR_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the global variable 'int opterr'. */\n#undef HAVE_INT_OPTERR\n\n/* Define to 1 if you have the global variable 'int optreset'. */\n#undef HAVE_INT_OPTRESET\n\n/* Define to 1 if you have the global variable 'int timezone'. */\n#undef HAVE_INT_TIMEZONE\n\n/* Define to 1 if you have support for IPv6. */\n#undef HAVE_IPV6\n\n/* Define to 1 if you have isinf(). */\n#undef HAVE_ISINF\n\n/* Define to 1 if you have the <kernel/image.h> header file. */\n#undef HAVE_KERNEL_IMAGE_H\n\n/* Define to 1 if you have the <kernel/OS.h> header file. */\n#undef HAVE_KERNEL_OS_H\n\n/* Define to 1 if `e_data' is a member of `krb5_error'. */\n#undef HAVE_KRB5_ERROR_E_DATA\n\n/* Define to 1 if `text.data' is a member of `krb5_error'. */\n#undef HAVE_KRB5_ERROR_TEXT_DATA\n\n/* Define to 1 if you have krb5_free_unparsed_name */\n#undef HAVE_KRB5_FREE_UNPARSED_NAME\n\n/* Define to 1 if `client' is a member of `krb5_ticket'. */\n#undef HAVE_KRB5_TICKET_CLIENT\n\n/* Define to 1 if `enc_part2' is a member of `krb5_ticket'. */\n#undef HAVE_KRB5_TICKET_ENC_PART2\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H\n\n/* Define to 1 if you have the <ldap.h> header file. */\n#undef HAVE_LDAP_H\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n#undef HAVE_LIBCRYPTO\n\n/* Define to 1 if you have the `DDBoost' library (-lDDBoost). */\n#undef HAVE_LIBDDBOOST\n\n/* Define to 1 if you have the `eay32' library (-leay32). */\n#undef HAVE_LIBEAY32\n\n/* Define to 1 if you have the `gpdbcost' library (-lgpdbcost). */\n#undef HAVE_LIBGPDBCOST\n\n/* Define to 1 if you have the `gpopt' library (-lgpopt). */\n#undef HAVE_LIBGPOPT\n\n/* Define to 1 if you have the `gpos' library (-lgpos). */\n#undef HAVE_LIBGPOS\n\n/* Define to 1 if you have the `ldap' library (-lldap). */\n#undef HAVE_LIBLDAP\n\n/* Define to 1 if you have the `ldap_r' library (-lldap_r). */\n#undef HAVE_LIBLDAP_R\n\n/* Define to 1 if you have the `m' library (-lm). */\n#undef HAVE_LIBM\n\n/* Define to 1 if you have the `naucrates' library (-lnaucrates). */\n#undef HAVE_LIBNAUCRATES\n\n/* Define to 1 if you have the `netsnmp' library (-lnetsnmp). */\n#undef HAVE_LIBNETSNMP\n\n/* Define to 1 if you have the `numa' library (-lnuma). */\n#undef HAVE_LIBNUMA\n\n/* Define to 1 if you have the `pam' library (-lpam). */\n#undef HAVE_LIBPAM\n\n/* Define if you have a function readline library */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the `rt' library (-lrt). */\n#undef HAVE_LIBRT\n\n/* Define to 1 if you have the `ssl' library (-lssl). */\n#undef HAVE_LIBSSL\n\n/* Define to 1 if you have the `ssleay32' library (-lssleay32). */\n#undef HAVE_LIBSSLEAY32\n\n/* Define to 1 if you have the `wldap32' library (-lwldap32). */\n#undef HAVE_LIBWLDAP32\n\n/* Define to 1 if you have the `xerces-c' library (-lxerces-c). */\n#undef HAVE_LIBXERCES_C\n\n/* Define to 1 if you have the `xml2' library (-lxml2). */\n#undef HAVE_LIBXML2\n\n/* Define to 1 if you have the `xslt' library (-lxslt). */\n#undef HAVE_LIBXSLT\n\n/* Define to 1 if you have the `z' library (-lz). */\n#undef HAVE_LIBZ\n\n/* Define to 1 if constants of type 'long long int' should have the suffix LL.\n   */\n#undef HAVE_LL_CONSTANTS\n\n/* Define to 1 if `long int' works and is 64 bits. */\n#undef HAVE_LONG_INT_64\n\n/* Define to 1 if the system has the type `long long int'. */\n#undef HAVE_LONG_LONG_INT\n\n/* Define to 1 if `long long int' works and is 64 bits. */\n#undef HAVE_LONG_LONG_INT_64\n\n/* Define to 1 if you have the <mbarrier.h> header file. */\n#undef HAVE_MBARRIER_H\n\n/* Define to 1 if you have the `memmove' function. */\n#undef HAVE_MEMMOVE\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the <naucrates/init.h> header file. */\n#undef HAVE_NAUCRATES_INIT_H\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#undef HAVE_NETINET_IN_H\n\n/* Define to 1 if you have the <netinet/tcp.h> header file. */\n#undef HAVE_NETINET_TCP_H\n\n/* Define to 1 if you have the <net/if.h> header file. */\n#undef HAVE_NET_IF_H\n\n/* Define to 1 if you have the <net-snmp/net-snmp-config.h> header file. */\n#undef HAVE_NET_SNMP_NET_SNMP_CONFIG_H\n\n/* Define to 1 if you have the <numa.h> header file. */\n#undef HAVE_NUMA_H\n\n/* Define to 1 if you have the `on_exit' function. */\n#undef HAVE_ON_EXIT\n\n/* Define to 1 if you have the <pam/pam_appl.h> header file. */\n#undef HAVE_PAM_PAM_APPL_H\n\n/* Define to 1 if you have the `poll' function. */\n#undef HAVE_POLL\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the `posix_fadvise' function. */\n#undef HAVE_POSIX_FADVISE\n\n/* Define to 1 if you have the POSIX signal interface. */\n#undef HAVE_POSIX_SIGNALS\n\n/* Define to 1 if you have the `pstat' function. */\n#undef HAVE_PSTAT\n\n/* Define to 1 if the PS_STRINGS thing exists. */\n#undef HAVE_PS_STRINGS\n\n/* Define if you have POSIX threads libraries and header files. */\n#undef HAVE_PTHREAD\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#undef HAVE_PWD_H\n\n/* Define to 1 if you have the `random' function. */\n#undef HAVE_RANDOM\n\n/* Define to 1 if you have the <readline.h> header file. */\n#undef HAVE_READLINE_H\n\n/* Define to 1 if you have the <readline/history.h> header file. */\n#undef HAVE_READLINE_HISTORY_H\n\n/* Define to 1 if you have the <readline/readline.h> header file. */\n#undef HAVE_READLINE_READLINE_H\n\n/* Define to 1 if you have the `readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the `replace_history_entry' function. */\n#undef HAVE_REPLACE_HISTORY_ENTRY\n\n/* Define to 1 if you have the `rint' function. */\n#undef HAVE_RINT\n\n/* Define to 1 if you have the global variable\n   'rl_completion_append_character'. */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define to 1 if you have the `rl_completion_matches' function. */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define to 1 if you have the `rl_filename_completion_function' function. */\n#undef HAVE_RL_FILENAME_COMPLETION_FUNCTION\n\n/* Define to 1 if you have the <security/pam_appl.h> header file. */\n#undef HAVE_SECURITY_PAM_APPL_H\n\n/* Define to 1 if you have the `setproctitle' function. */\n#undef HAVE_SETPROCTITLE\n\n/* Define to 1 if you have the `setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the `sigprocmask' function. */\n#undef HAVE_SIGPROCMASK\n\n/* Define to 1 if you have sigsetjmp(). */\n#undef HAVE_SIGSETJMP\n\n/* Define to 1 if the system has the type `sig_atomic_t'. */\n#undef HAVE_SIG_ATOMIC_T\n\n/* Define to 1 if you have the `snprintf' function. */\n#undef HAVE_SNPRINTF\n\n/* Define to 1 if you have spinlocks. */\n#undef HAVE_SPINLOCKS\n\n/* Define to 1 if you have the `srandom' function. */\n#undef HAVE_SRANDOM\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `strdup' function. */\n#undef HAVE_STRDUP\n\n/* Define to 1 if you have the `strerror' function. */\n#undef HAVE_STRERROR\n\n/* Define to 1 if you have the `strerror_r' function. */\n#undef HAVE_STRERROR_R\n\n/* Define to 1 if cpp supports the ANSI # stringizing operator. */\n#undef HAVE_STRINGIZE\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strlcat' function. */\n#undef HAVE_STRLCAT\n\n/* Define to 1 if you have the `strlcpy' function. */\n#undef HAVE_STRLCPY\n\n/* Define to 1 if you have the `strtol' function. */\n#undef HAVE_STRTOL\n\n/* Define to 1 if you have the `strtoll' function. */\n#undef HAVE_STRTOLL\n\n/* Define to 1 if you have the `strtoq' function. */\n#undef HAVE_STRTOQ\n\n/* Define to 1 if you have the `strtoul' function. */\n#undef HAVE_STRTOUL\n\n/* Define to 1 if you have the `strtoull' function. */\n#undef HAVE_STRTOULL\n\n/* Define to 1 if you have the `strtouq' function. */\n#undef HAVE_STRTOUQ\n\n/* Define to 1 if the system has the type `struct addrinfo'. */\n#undef HAVE_STRUCT_ADDRINFO\n\n/* Define to 1 if the system has the type `struct cmsgcred'. */\n#undef HAVE_STRUCT_CMSGCRED\n\n/* Define to 1 if the system has the type `struct fcred'. */\n#undef HAVE_STRUCT_FCRED\n\n/* Define to 1 if the system has the type `struct option'. */\n#undef HAVE_STRUCT_OPTION\n\n/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */\n#undef HAVE_STRUCT_SOCKADDR_SA_LEN\n\n/* Define to 1 if the system has the type `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE\n\n/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY\n\n/* Define to 1 if `ss_len' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n\n/* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY\n\n/* Define to 1 if `__ss_len' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_LEN\n\n/* Define to 1 if the system has the type `struct sockaddr_un'. */\n#undef HAVE_STRUCT_SOCKADDR_UN\n\n/* Define to 1 if the system has the type `struct sockcred'. */\n#undef HAVE_STRUCT_SOCKCRED\n\n/* Define to 1 if `tm_zone' is a member of `struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if you have the <SupportDefs.h> header file. */\n#undef HAVE_SUPPORTDEFS_H\n\n/* Define to 1 if you have the `symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the `sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the syslog interface. */\n#undef HAVE_SYSLOG\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#undef HAVE_SYS_IOCTL_H\n\n/* Define to 1 if you have the <sys/ipc.h> header file. */\n#undef HAVE_SYS_IPC_H\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#undef HAVE_SYS_POLL_H\n\n/* Define to 1 if you have the <sys/pstat.h> header file. */\n#undef HAVE_SYS_PSTAT_H\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#undef HAVE_SYS_RESOURCE_H\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#undef HAVE_SYS_SELECT_H\n\n/* Define to 1 if you have the <sys/sem.h> header file. */\n#undef HAVE_SYS_SEM_H\n\n/* Define to 1 if you have the <sys/shm.h> header file. */\n#undef HAVE_SYS_SHM_H\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#undef HAVE_SYS_SOCKET_H\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#undef HAVE_SYS_SOCKIO_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/tas.h> header file. */\n#undef HAVE_SYS_TAS_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <time.h> header file. */\n#undef HAVE_TIME_H\n\n/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use\n   `HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the `towlower' function. */\n#undef HAVE_TOWLOWER\n\n/* Define to 1 if you have the external array `tzname'. */\n#undef HAVE_TZNAME\n\n/* Define to 1 if you have the <ucred.h> header file. */\n#undef HAVE_UCRED_H\n\n/* Define to 1 if the system has the type `uint64'. */\n#undef HAVE_UINT64\n\n/* Define to 1 if the system has the type `uint8'. */\n#undef HAVE_UINT8\n\n/* Define to 1 if the system has the type `uintptr_t'. */\n#undef HAVE_UINTPTR_T\n\n/* Define to 1 if the system has the type `union semun'. */\n#undef HAVE_UNION_SEMUN\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have unix sockets. */\n#undef HAVE_UNIX_SOCKETS\n\n/* Define to 1 if you have the `unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define to 1 if the system has the type `unsigned long long int'. */\n#undef HAVE_UNSIGNED_LONG_LONG_INT\n\n/* Define to 1 if you have the `utime' function. */\n#undef HAVE_UTIME\n\n/* Define to 1 if you have the `utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#undef HAVE_UTIME_H\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#undef HAVE_VSNPRINTF\n\n/* Define to 1 if you have the `waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#undef HAVE_WCHAR_H\n\n/* Define to 1 if you have the `wcstombs' function. */\n#undef HAVE_WCSTOMBS\n\n/* Define to 1 if you have the <wctype.h> header file. */\n#undef HAVE_WCTYPE_H\n\n/* Define to 1 if you have the <winldap.h> header file. */\n#undef HAVE_WINLDAP_H\n\n/* Define to 1 if you have the <winsock2.h> header file. */\n#undef HAVE_WINSOCK2_H\n\n/* Define to 1 if you have the <yaml.h> header file. */\n#undef HAVE_YAML_H\n\n/* Define to 1 if your compiler understands __builtin_constant_p. */\n#undef HAVE__BUILTIN_CONSTANT_P\n\n/* Define to 1 if your compiler understands __builtin_types_compatible_p. */\n#undef HAVE__BUILTIN_TYPES_COMPATIBLE_P\n\n/* Define to 1 if your compiler understands __builtin_unreachable. */\n#undef HAVE__BUILTIN_UNREACHABLE\n\n/* Define to 1 if you have __cpuid. */\n#undef HAVE__CPUID\n\n/* Define to 1 if you have __get_cpuid. */\n#undef HAVE__GET_CPUID\n\n/* Define to 1 if your compiler understands _Static_assert. */\n#undef HAVE__STATIC_ASSERT\n\n/* Define to 1 if your compiler understands __VA_ARGS__ in macros. */\n#undef HAVE__VA_ARGS\n\n/* Define to the appropriate snprintf format for 64-bit ints, if any. */\n#undef INT64_FORMAT\n\n/* Define to build with Kerberos 5 support. (--with-krb5) */\n#undef KRB5\n\n/* Define as the maximum alignment requirement of any C data type. */\n#undef MAXIMUM_ALIGNOF\n\n/* Define bytes to use libc memset(). */\n#undef MEMSET_LOOP_LIMIT\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to the name of a signed 64-bit integer type. */\n#undef PG_INT64_TYPE\n\n/* Define to the name of the default PostgreSQL service principal in Kerberos.\n   (--with-krb-srvnam=NAME) */\n#undef PG_KRB_SRVNAM\n\n/* PostgreSQL major version as a string */\n#undef PG_MAJORVERSION\n\n/* Define to 1 if \"static inline\" works without unwanted warnings from\n   compilations where static inline functions are defined but not called. */\n#undef PG_USE_INLINE\n\n/* Postgres version Greenplum Database is based on */\n#undef PG_VERSION\n\n/* PostgreSQL version as a number */\n#undef PG_VERSION_NUM\n\n/* A string containing the version number, platform, and C compiler */\n#undef PG_VERSION_STR\n\n/* Define to 1 to allow profiling output to be saved separately for each\n   process. */\n#undef PROFILE_PID_DIR\n\n/* Define to the necessary symbol if this constant uses a non-standard name on\n   your system. */\n#undef PTHREAD_CREATE_JOINABLE\n\n/* The size of `off_t', as computed by sizeof. */\n#undef SIZEOF_OFF_T\n\n/* The size of `size_t', as computed by sizeof. */\n#undef SIZEOF_SIZE_T\n\n/* The size of `unsigned long', as computed by sizeof. */\n#undef SIZEOF_UNSIGNED_LONG\n\n/* The size of `void *', as computed by sizeof. */\n#undef SIZEOF_VOID_P\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define to 1 if strerror_r() returns a int. */\n#undef STRERROR_R_INT\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Define to the appropriate snprintf format for unsigned 64-bit ints, if any.\n   */\n#undef UINT64_FORMAT\n\n/* Define to 1 to build with assertion checks. (--enable-cassert) */\n#undef USE_ASSERT_CHECKING\n\n/* Define to 1 to build with Bonjour support. (--with-bonjour) */\n#undef USE_BONJOUR\n\n/* Define to 1 to build with libcurl support. (--with-libcurl) */\n#undef USE_CURL\n\n/* Define to 1 to build with DD Boost capabilities. (--enable-ddboost) */\n#undef USE_DDBOOST\n\n/* Define to 1 to build with debug_break capabilities. (--enable-debugbreak)\n   */\n#undef USE_DEBUG_BREAK\n\n/* Define to 1 to build with debug_ntuplestore. (--enable-ntuplestore) */\n#undef USE_DEBUG_NTUPLESTORE\n\n/* Define to 1 to build with gpcloud (--enable-gpcloud) */\n#undef USE_GPCLOUD\n\n/* Define to 1 if you want 64-bit integer timestamp and interval support.\n   (--enable-integer-datetimes) */\n#undef USE_INTEGER_DATETIMES\n\n/* Define to 1 to build with LDAP support. (--with-ldap) */\n#undef USE_LDAP\n\n/* Define to 1 to build with XML support. (--with-libxml) */\n#undef USE_LIBXML\n\n/* Define to 1 to use XSLT support when building contrib/xml2.\n   (--with-libxslt) */\n#undef USE_LIBXSLT\n\n/* Define to 1 to build with Mapreduce capabilities (--enable-mapreduce) */\n#undef USE_MAPREDUCE\n\n/* Define to select named POSIX semaphores. */\n#undef USE_NAMED_POSIX_SEMAPHORES\n\n/* Define to 1 to build with NetBackup capabilities. (--enable-netbackup) */\n#undef USE_NETBACKUP\n\n/* Define to 1 to build with Greenplum ORCA optimizer. (--enable-orca) */\n#undef USE_ORCA\n\n/* Define to 1 to build with PAM support. (--with-pam) */\n#undef USE_PAM\n\n/* Use replacement snprintf() functions. */\n#undef USE_REPL_SNPRINTF\n\n/* Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check. */\n#undef USE_SLICING_BY_8_CRC32C\n\n/* Define to 1 to build with snmp capabilities. (--enable-snmp) */\n#undef USE_SNMP\n\n/* Define to 1 use Intel SSE 4.2 CRC instructions. */\n#undef USE_SSE42_CRC32C\n\n/* Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check. */\n#undef USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n\n/* Define to build with (Open)SSL support. (--with-openssl) */\n#undef USE_SSL\n\n/* Define to select SysV-style semaphores. */\n#undef USE_SYSV_SEMAPHORES\n\n/* Define to select SysV-style shared memory. */\n#undef USE_SYSV_SHARED_MEMORY\n\n/* Define to 1 to build with testing utilities. (--enable-testutils) */\n#undef USE_TEST_UTILS\n\n/* Define to select unnamed POSIX semaphores. */\n#undef USE_UNNAMED_POSIX_SEMAPHORES\n\n/* Define to select Win32-style semaphores. */\n#undef USE_WIN32_SEMAPHORES\n\n/* Define to select Win32-style shared memory. */\n#undef USE_WIN32_SHARED_MEMORY\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#undef _FILE_OFFSET_BITS\n\n/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n#undef _LARGEFILE_SOURCE\n\n/* Define for large files, on AIX-style hosts. */\n#undef _LARGE_FILES\n\n/* Define to empty if `const' does not conform to ANSI C. */\n#undef const\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#undef inline\n#endif\n\n/* Define to the type of a signed integer type wide enough to hold a pointer,\n   if such a type exists, and if the system does not define it. */\n#undef intptr_t\n\n/* Define to empty if the C compiler does not understand signed types. */\n#undef signed\n\n/* Define to the type of an unsigned integer type wide enough to hold a\n   pointer, if such a type exists, and if the system does not define it. */\n#undef uintptr_t\n\n/* Define to empty if the keyword `volatile' does not work. Warning: valid\n   code using `volatile' can become incorrect without. Disable with care. */\n#undef volatile\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/include/utils/dynamic_loader.h": "/*-------------------------------------------------------------------------\n *\n * dynamic_loader.h\n *\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/include/utils/dynamic_loader.h,v 1.28 2008/01/01 19:45:59 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef DYNAMIC_LOADER_H\n#define DYNAMIC_LOADER_H\n\n#include \"fmgr.h\"\n\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n\n#endif   /* DYNAMIC_LOADER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/win32.h": "/*\n * $PostgreSQL: pgsql/src/backend/port/dynloader/win32.h,v 1.5 2009/06/11 14:49:00 momjian Exp $\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\n#define pg_dlopen(f)\tdlopen((f), 1)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/dgux.h": "/*-------------------------------------------------------------------------\n *\n * dgux.h\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/dgux.h,v 1.22 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on DG/UX.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/sunos4.h": "/*-------------------------------------------------------------------------\n *\n * sunos4.h\n *\t  port-specific prototypes for SunOS 4\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/sunos4.h,v 1.21 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SunOS 4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/cygwin.h": "/*-------------------------------------------------------------------------\n *\n * Dynamic loader declarations for Cygwin\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/cygwin.h,v 1.9 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/freebsd.h": "/*-------------------------------------------------------------------------\n *\n * freebsd.h\n *\t  port-specific prototypes for FreeBSD\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/freebsd.h,v 1.23 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/darwin.h": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/darwin.h,v 1.5 2003/11/29 19:51:54 pgsql Exp $ */\n\n#include \"fmgr.h\"\n\nvoid\t   *pg_dlopen(char *filename);\nPGFunction\tpg_dlsym(void *handle, char *funcname);\nvoid\t\tpg_dlclose(void *handle);\nchar\t   *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/sco.h": "/*-------------------------------------------------------------------------\n *\n * sco.h\n *\t  port-specific prototypes for SCO 3.2v5.2\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/sco.h,v 1.20 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SCO 3.2v5.0.2\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/win32.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/win32.c,v 1.9 2006/12/04 22:23:40 momjian Exp $ */\n\n#include \"postgres.h\"\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\nstatic char last_dyn_error[512];\n\nstatic void\nset_dl_error(void)\n{\n\tDWORD\t\terr = GetLastError();\n\n\tif (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t\t\t  FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  err,\n\t\t\t\t\t  MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),\n\t\t\t\t\t  last_dyn_error,\n\t\t\t\t\t  sizeof(last_dyn_error) - 1,\n\t\t\t\t\t  NULL) == 0)\n\t{\n\t\tsnprintf(last_dyn_error, sizeof(last_dyn_error) - 1,\n\t\t\t\t \"unknown error %lu\", err);\n\t}\n}\n\nchar *\ndlerror(void)\n{\n\tif (last_dyn_error[0])\n\t\treturn last_dyn_error;\n\telse\n\t\treturn NULL;\n}\n\nint\ndlclose(void *handle)\n{\n\tif (!FreeLibrary((HMODULE) handle))\n\t{\n\t\tset_dl_error();\n\t\treturn 1;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn 0;\n}\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n\tvoid\t   *ptr;\n\n\tptr = GetProcAddress((HMODULE) handle, symbol);\n\tif (!ptr)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn ptr;\n}\n\nvoid *\ndlopen(const char *path, int mode)\n{\n\tHMODULE\t\th;\n\tint\t\t\tprevmode;\n\n\t/* Disable popup error messages when loading DLLs */\n\tprevmode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\th = LoadLibrary(path);\n\tSetErrorMode(prevmode);\n\n\tif (!h)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn (void *) h;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/bsdi.h": "/*-------------------------------------------------------------------------\n *\n * bsdi.h\n *\t\tDynamic loader interface for BSD/OS\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/bsdi.h,v 1.25 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\n\n#ifdef HAVE_DLOPEN\n\n#include <dlfcn.h>\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t  pg_dlopen(f)\t  dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t  pg_dlsym\t\t  dlsym\n#define\t\t  pg_dlclose\t  dlclose\n#define\t\t  pg_dlerror\t  dlerror\n#else\t\t\t\t\t\t\t/* not HAVE_DLOPEN */\n\n#define pg_dlsym(handle, funcname)\t  ((PGFunction) dld_get_func((funcname)))\n#define pg_dlclose(handle) \\\ndo { \\\n\tdld_unlink_by_file(handle, 1); \\\n\tfree(handle); \\\n} while (0)\n#endif   /* not HAVE_DLOPEN */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/hpux.h": "/*-------------------------------------------------------------------------\n *\n * dynloader.h\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/hpux.h,v 1.14 2008/01/01 19:45:51 momjian Exp $\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n/* System includes */\n#include \"fmgr.h\"\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/osf.h": "/*-------------------------------------------------------------------------\n *\n * osf.h\n *\t  prototypes for OSF/1-specific routines\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/osf.h,v 1.16 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Alpha OSF/1.x\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/solaris.h": "/*-------------------------------------------------------------------------\n *\n * solaris.h\n *\t  port-specific prototypes for Solaris\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/solaris.h,v 1.17 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/nextstep.h": "/*-------------------------------------------------------------------------\n *\n * port_protos.h\n *\t  port-specific prototypes for NeXT\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/nextstep.h,v 1.9 2006/03/11 04:38:31 momjian Exp $\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\nvoid\t   *next_dlopen(char *name);\nint\t\t\tnext_dlclose(void *handle);\nvoid\t   *next_dlsym(void *handle, char *symbol);\nchar\t   *next_dlerror(void);\n\n#define pg_dlopen(f)\tnext_dlopen\n#define pg_dlsym\t\tnext_dlsym\n#define pg_dlclose\t\tnext_dlclose\n#define pg_dlerror\t\tnext_dlerror\n\n/* port.c */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/netbsd.c": "/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/netbsd.c,v 1.22.2.1 2008/03/05 21:20:47 alvherre Exp $\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/aix.h": "/*-------------------------------------------------------------------------\n *\n * aix.h\n *\t  prototypes for AIX-specific routines\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/aix.h,v 1.14 2009/04/21 21:15:50 tgl Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/netbsd.h": "/*-------------------------------------------------------------------------\n *\n * netbsd.h\n *\t  port-specific prototypes for NetBSD\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/netbsd.h,v 1.17 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/unixware.h": "/*-------------------------------------------------------------------------\n *\n * unixware.h\n *\t  port-specific prototypes for Intel x86/UNIXWARE 7\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * unixware.h,v 1.2 1995/03/17 06:40:18 andrew Exp\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/svr4.h": "/*-------------------------------------------------------------------------\n *\n * svr4.h\n *\t  port-specific prototypes for Intel x86/Intel SVR4\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/svr4.h,v 1.20 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/openbsd.h": "/*-------------------------------------------------------------------------\n *\n * openbsd.h\n *\t  port-specific prototypes for OpenBSD\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/openbsd.h,v 1.18 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/linux.c": "/*-------------------------------------------------------------------------\n *\n * linux.c\n *\t  Dynamic Loader for Postgres for Linux, generated from those for\n *\t  Ultrix.\n *\n *\t  You need to install the dld library on your Linux system!\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/linux.c,v 1.35 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#ifdef HAVE_DLD_H\n#include <dld.h>\n#endif\n\n#include \"dynloader.h\"\n#include \"miscadmin.h\"\n\n\n#ifndef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n#ifndef HAVE_DLD_H\n\telog(ERROR, \"dynamic load not supported\");\n\treturn NULL;\n#else\n\tstatic int\tdl_initialized = 0;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (dld_init(dld_find_executable(my_exec_path)))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * link the file, then check for undefined symbols!\n\t */\n\tif (dld_link(filename))\n\t\treturn NULL;\n\n\t/*\n\t * If undefined symbols: try to link with the C and math libraries! This\n\t * could be smarter, if the dynamic linker was able to handle shared libs!\n\t */\n\tif (dld_undefined_sym_count > 0)\n\t{\n\t\tif (dld_link(\"/usr/lib/libc.a\"))\n\t\t{\n\t\t\telog(WARNING, \"could not link C library\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dld_undefined_sym_count > 0)\n\t\t{\n\t\t\tif (dld_link(\"/usr/lib/libm.a\"))\n\t\t\t{\n\t\t\t\telog(WARNING, \"could not link math library\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dld_undefined_sym_count > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tcount = dld_undefined_sym_count;\n\t\t\t\tchar\t  **list = dld_list_undefined_sym();\n\n\t\t\t\t/* list the undefined symbols, if any */\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\t\tlist++;\n\t\t\t\t\tcount--;\n\t\t\t\t} while (count > 0);\n\n\t\t\t\tdld_unlink_by_file(filename, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) strdup(filename);\n#endif\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n#ifndef HAVE_DLD_H\n\treturn NULL;\n#else\n\treturn (PGFunction) dld_get_func((funcname));\n#endif\n}\n\nvoid\npg_dlclose(void *handle)\n{\n#ifndef HAVE_DLD_H\n#else\n\tdld_unlink_by_file(handle, 1);\n\tfree(handle);\n#endif\n}\n\nchar *\npg_dlerror(void)\n{\n#ifndef HAVE_DLD_H\n\treturn \"dynaloader unspported\";\n#else\n\treturn dld_strerror(dld_errno);\n#endif\n}\n\n#endif   /* !HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/freebsd.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/freebsd.c,v 1.28 2008/01/01 19:45:51 momjian Exp $ */\n\n/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/nextstep.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/nextstep.c,v 1.6 2006/03/11 04:38:31 momjian Exp $ */\n\n#include \"postgres.h\"\n\n#include \"mach-o/rld.h\"\n#include \"streams/streams.h\"\n\nstatic char *lastError = NULL;\n\nstatic NXStream *\nOpenError()\n{\n\treturn NXOpenMemory(NULL, 0, NX_WRITEONLY);\n}\n\nstatic void\nCloseError(NXStream * s)\n{\n\tif (s)\n\t\tNXCloseMemory(s, NX_FREEBUFFER);\n}\n\nstatic void\nTransferError(NXStream * s)\n{\n\tchar\t   *buffer;\n\tint\t\t\tlen,\n\t\t\t\tmaxlen;\n\n\tif (lastError)\n\t\tfree(lastError);\n\tNXGetMemoryBuffer(s, &buffer, &len, &maxlen);\n\tlastError = malloc(len + 1);\n\tif(!lastError)\n\t\tereport(ERROR, errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\terrmsg(\"Transer error failed: out of memory\"));\n\n\tstrcpy(lastError, buffer);\n}\n\nvoid *\nnext_dlopen(char *name)\n{\n\tint\t\t\trld_success;\n\tNXStream   *errorStream;\n\tchar\t   *result = NULL;\n\tchar\t  **p;\n\n\terrorStream = OpenError();\n\tp = calloc(2, sizeof(void *));\n\tp[0] = name;\n\trld_success = rld_load(errorStream, NULL, p, NULL);\n\tfree(p);\n\n\tif (!rld_success)\n\t{\n\t\tTransferError(errorStream);\n\t\tresult = (char *) 1;\n\t}\n\tCloseError(errorStream);\n\treturn result;\n}\n\nint\nnext_dlclose(void *handle)\n{\n\treturn 0;\n}\n\nvoid *\nnext_dlsym(void *handle, char *symbol)\n{\n\tNXStream   *errorStream = OpenError();\n\tchar\t\tsymbuf[1024];\n\tunsigned long symref = 0;\n\n\tsnprintf(symbuf, sizeof(symbuf), \"_%s\", symbol);\n\tif (!rld_lookup(errorStream, symbuf, &symref))\n\t\tTransferError(errorStream);\n\tCloseError(errorStream);\n\treturn (void *) symref;\n}\n\nchar *\nnext_dlerror(void)\n{\n\treturn lastError;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/openbsd.c": "/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/openbsd.c,v 1.22 2008/01/01 19:45:51 momjian Exp $\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/univel.h": "/*-------------------------------------------------------------------------\n *\n * univel.h\n *\t  port-specific prototypes for Intel x86/UNIXWARE\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * univel.h,v 1.2 1995/03/17 06:40:18 andrew Exp\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/README.dlfcn.aix": "libdl.a\n-------\n\nThis is an emulation library to emulate the SunOS/System V.4 functions\nto access the runtime linker. The functions are emulated by using the\nAIX load() function and by reading the .loader section of the loaded\nmodule to find the exports. The to be loaded module should be linked as\nfollows (if using AIX 3):\n\n\tcc -o module.so -bM:SRE -bE:module.exp -e _nostart $(OBJS)\n\nFor AIX 4:\n\n\tcc -o module.so -bM:SRE -bE:module.exp -bnoentry $(OBJS)\n\nThe module export file contains the symbols to be exported. Because\nthis library uses the loader section, the final module.so file can be\nstripped. C++ users should build their shared objects using the script\nmakeC++SharedLib (part of the IBM C++ compiler), this will make sure\nthat constructors and destructors for static and global objects will be\ncalled upon loading and unloading the module.\n\nUsage\n-----\n\nvoid *dlopen(const char *path, int mode);\n\nThis routine loads the module pointed to by path and reads its export\ntable. If the path does not contain a '/' character, dlopen will search\nfor the module using the LIBPATH environment variable. It returns an\nopaque handle to the module or NULL on error. The mode parameter can be\neither RTLD_LAZY (for lazy function binding) or RTLD_NOW for immediate\nfunction binding. The AIX implementation currently behaves as RTLD_NOW\neven if RTLD_LAZY is specified. The flag RTLD_GLOBAL might be or'ed into the\nmode parameter to allow loaded modules to bind to global variables or\nfunctions in other loaded modules loaded by dlopen(). If RTLD_GLOBAL is\nnot specified, only globals from the main part of the executable or\nshared libraries are used to look for undefined symbols in loaded\nmodules.\n\n\nvoid *dlsym(void *handle, const char *symbol);\n\nThis routine searches for the symbol in the module referred to by\nhandle and returns its address. If the symbol could not be found, the\nfunction returns NULL. The return value must be casted to a proper\nfunction pointer before it can be used. SunOS/System V.4 allow handle\nto be a NULL pointer to refer to the module the call is made from, this\nis not implemented.\n\nint dlclose(void *handle);\n\nThis routine unloads the module referred to by the handle and disposes\nof any local storage. this function returns -1 on failure.\n\nchar *dlerror(void);\n\nThis routine can be used to retrieve a text message describing the most\nrecent error that occured on on of the above routines. This function\nreturns NULL if there is not error information.\n\nInitialization and termination handlers\n---------------------------------------\n\nThe emulation provides for an initialization and a termination\nhandler.  The dlfcn.h file contains a structure declaration named\ndl_info with following members:\n\n\tvoid (*init)(void);\n\tvoid (*fini)(void);\n\nThe init function is called upon first referencing the library. The\nfini function is called at dlclose() time or when the process exits.\nThe module should declare a variable named dl_info that contains this\nstructure which must be exported.  These functions correspond to the\ndocumented _init() and _fini() functions of SunOS 4.x, but these are\nappearently not implemented in SunOS.  When using SunOS 5.0, these\ncorrespond to #pragma init and #pragma fini respectively. At the same\ntime any static or global C++ object's constructors or destructors will\nbe called.\n\nJens-Uwe Mager\n\nHELIOS Software GmbH\nLavesstr. 80\n30159 Hannover\nGermany\n\nPhone:\t\t+49 511 36482-0\nFAX:\t\t+49 511 36482-69\nAppleLink:\thelios.de\tAttn: Jens-Uwe Mager\nInternet:\tjum@helios.de\n\nRevison History\n---------------\n\nSCCS/s.dlfcn.h:\n\nD 1.4 95/04/25 09:36:52 jum 4 3\t00018/00004/00028\nMRs:\nCOMMENTS:\nadded RTLD_GLOBAL, include and C++ guards\n\nD 1.3 92/12/27 20:58:32 jum 3 2\t00001/00001/00031\nMRs:\nCOMMENTS:\nwe always have prototypes on RS/6000\n\nD 1.2 92/08/16 17:45:11 jum 2 1\t00009/00000/00023\nMRs:\nCOMMENTS:\nadded dl_info structure to implement initialize and terminate functions\n\nD 1.1 92/08/02 18:08:45 jum 1 0\t00023/00000/00000\nMRs:\nCOMMENTS:\nErstellungsdatum und -uhrzeit 92/08/02 18:08:45 von jum\n\nSCCS/s.dlfcn.c:\n\nD 1.7 95/08/14 19:08:38 jum 8 6\t00026/00004/00502\nMRs:\nCOMMENTS:\nIntegrated the fixes from Kirk Benell (kirk@rsinc.com) to allow loading of\nshared objects generated under AIX 4. Fixed bug that symbols with exactly\n8 characters would use garbage characters from the following symbol value.\n\nD 1.6 95/04/25 09:38:03 jum 6 5\t00046/00006/00460\nMRs:\nCOMMENTS:\nadded handling of C++ static constructors and destructors, added RTLD_GLOBAL to bind against other loaded modules\n\nD 1.5 93/02/14 20:14:17 jum 5 4\t00002/00000/00464\nMRs:\nCOMMENTS:\nadded path to dlopen error message to make clear where there error occured.\n\nD 1.4 93/01/03 19:13:56 jum 4 3\t00061/00005/00403\nMRs:\nCOMMENTS:\nto allow calling symbols in the main module call load with L_NOAUTODEFER and \ndo a loadbind later with the main module.\n\nD 1.3 92/12/27 20:59:55 jum 3 2\t00066/00008/00342\nMRs:\nCOMMENTS:\nadded search by L_GETINFO if module got loaded by LIBPATH\n\nD 1.2 92/08/16 17:45:43 jum 2 1\t00074/00006/00276\nMRs:\nCOMMENTS:\nimplemented initialize and terminate functions, added reference counting to avoid multiple loads of the same library\n\nD 1.1 92/08/02 18:08:45 jum 1 0\t00282/00000/00000\nMRs:\nCOMMENTS:\nErstellungsdatum und -uhrzeit 92/08/02 18:08:45 von jum\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/ultrix4.c": "/*-------------------------------------------------------------------------\n *\n * ultrix4.c\n *\t  This dynamic loader uses Andrew Yu's libdl-1.0 package for Ultrix 4.x.\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/ultrix4.c,v 1.26 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include \"dl.h\"\n#include \"utils/dynamic_loader.h\"\n\nextern char my_exec_path[];\n\nvoid *\npg_dlopen(char *filename)\n{\n\tstatic int\tdl_initialized = 0;\n\tvoid\t   *handle;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (!dl_init(my_exec_path))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_setLibraries(\"/usr/lib/libm_G0.a:/usr/lib/libc_G0.a\");\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * open the file. We do the symbol resolution right away so that we will\n\t * know if there are undefined symbols. (This is in fact the same\n\t * semantics as \"ld -A\". ie. you cannot have undefined symbols.\n\t */\n\tif ((handle = dl_open(filename, DL_NOW)) == NULL)\n\t{\n\t\tint\t\t\tcount;\n\t\tchar\t  **list = dl_undefinedSymbols(&count);\n\n\t\t/* list the undefined symbols, if any */\n\t\tif (count)\n\t\t{\n\t\t\twhile (*list)\n\t\t\t{\n\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\tlist++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) handle;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/bsdi.c": "/*-------------------------------------------------------------------------\n *\n * dynloader.c\n *\t  Dynamic Loader for Postgres for Linux, generated from those for\n *\t  Ultrix.\n *\n *\t  You need to install the dld library on your Linux system!\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/bsdi.c,v 1.30 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n#ifndef HAVE_DLOPEN\n\nextern char my_exec_path[];\n\nvoid *\npg_dlopen(char *filename)\n{\n\tstatic int\tdl_initialized = 0;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (dld_init(dld_find_executable(my_exec_path)))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * link the file, then check for undefined symbols!\n\t */\n\tif (dld_link(filename))\n\t\treturn NULL;\n\n\t/*\n\t * If undefined symbols: try to link with the C and math libraries! This\n\t * could be smarter, if the dynamic linker was able to handle shared libs!\n\t */\n\tif (dld_undefined_sym_count > 0)\n\t{\n\t\tif (dld_link(\"/usr/lib/libc.a\"))\n\t\t{\n\t\t\telog(WARNING, \"could not link C library\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dld_undefined_sym_count > 0)\n\t\t{\n\t\t\tif (dld_link(\"/usr/lib/libm.a\"))\n\t\t\t{\n\t\t\t\telog(WARNING, \"could not link math library\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dld_undefined_sym_count > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tcount = dld_undefined_sym_count;\n\t\t\t\tchar\t  **list = dld_list_undefined_sym();\n\n\t\t\t\t/* list the undefined symbols, if any */\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\t\tlist++;\n\t\t\t\t\tcount--;\n\t\t\t\t} while (count > 0);\n\n\t\t\t\tdld_unlink_by_file(filename, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) strdup(filename);\n}\n\nchar *\npg_dlerror()\n{\n\treturn dld_strerror(dld_errno);\n}\n\n#endif   /* not HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/irix.h": "/*-------------------------------------------------------------------------\n *\n * irix.h\n *\t  port-specific prototypes for Irix\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/irix.h,v 1.6 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SunOS 4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/hpux.c": "/*-------------------------------------------------------------------------\n *\n * dynloader.c\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/hpux.c,v 1.31 2008/01/01 19:45:51 momjian Exp $\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n/* System includes */\n#include <a.out.h>\n#include <dl.h>\n\n#include \"dynloader.h\"\n#include \"utils/dynamic_loader.h\"\n\nvoid *\npg_dlopen(char *filename)\n{\n\t/*\n\t * Use BIND_IMMEDIATE so that undefined symbols cause a failure return\n\t * from shl_load(), rather than an abort() later on when we attempt to\n\t * call the library!\n\t */\n\tshl_t\t\thandle = shl_load(filename,\n\t\t\t\t\t\t\t\tBIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH,\n\t\t\t\t\t\t\t\t  0L);\n\n\treturn (void *) handle;\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tPGFunction\tf;\n\n\tif (shl_findsym((shl_t *) & handle, funcname, TYPE_PROCEDURE, &f) == -1)\n\t\tf = (PGFunction) NULL;\n\treturn f;\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tshl_unload((shl_t) handle);\n}\n\nchar *\npg_dlerror(void)\n{\n\tstatic char errmsg[] = \"shl_load failed\";\n\n\tif (errno)\n\t\treturn strerror(errno);\n\n\treturn errmsg;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/linux.h": "/*-------------------------------------------------------------------------\n *\n * linux.h\n *\t\tPort-specific prototypes for Linux\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/linux.h,v 1.28 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\n\n#ifdef HAVE_DLOPEN\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n#endif   /* HAVE_DLOPEN */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/utils/fmgr/dfmgr.c": "/*-------------------------------------------------------------------------\n *\n * dfmgr.c\n *\t  Dynamic function manager code.\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/utils/fmgr/dfmgr.c,v 1.99.2.1 2009/09/03 22:11:13 tgl Exp $\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include <sys/stat.h>\n\n#ifndef WIN32_ONLY_COMPILER\n#include \"dynloader.h\"\n#else\n#include \"port/dynloader/win32.h\"\n#endif\n#include \"lib/stringinfo.h\"\n#include \"miscadmin.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"utils/hsearch.h\"\n\n\n/* signatures for PostgreSQL-specific library init/fini functions */\ntypedef void (*PG_init_t) (void);\ntypedef void (*PG_fini_t) (void);\n\n/* hashtable entry for rendezvous variables */\ntypedef struct\n{\n\tchar\t\tvarName[NAMEDATALEN];\t/* hash key (must be first) */\n\tvoid\t   *varValue;\n} rendezvousHashEntry;\n\n/*\n * List of dynamically loaded files (kept in malloc'd memory).\n */\n\ntypedef struct df_files\n{\n\tstruct df_files *next;\t\t/* List link */\n\tdev_t\t\tdevice;\t\t\t/* Device file is on */\n#ifndef WIN32\t\t\t\t\t/* ensures we never again depend on this under\n\t\t\t\t\t\t\t\t * win32 */\n\tino_t\t\tinode;\t\t\t/* Inode number of file */\n#endif\n\tvoid\t   *handle;\t\t\t/* a handle for pg_dl* functions */\n\tchar\t\tfilename[1];\t/* Full pathname of file */\n\n\t/*\n\t * we allocate the block big enough for actual length of pathname.\n\t * filename[] must be last item in struct!\n\t */\n} DynamicFileList;\n\nstatic DynamicFileList *file_list = NULL;\nstatic DynamicFileList *file_tail = NULL;\n\n/* stat() call under Win32 returns an st_ino field, but it has no meaning */\n#ifndef WIN32\n#define SAME_INODE(A,B) ((A).st_ino == (B).inode && (A).st_dev == (B).device)\n#else\n#define SAME_INODE(A,B) false\n#endif\n\nchar\t   *Dynamic_library_path;\n\nstatic void *internal_load_library(const char *libname);\nstatic void incompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data);\nstatic void internal_unload_library(const char *libname);\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\nstatic char *find_in_dynamic_libpath(const char *basename);\nstatic const char *get_magic_product(const Pg_magic_struct *module_magic_data);\n\n/* Magic structure that module needs to match to be accepted */\nstatic const Pg_magic_struct magic_data = PG_MODULE_MAGIC_DATA;\n\n\n/*\n * Load the specified dynamic-link library file, and look for a function\n * named funcname in it.\n *\n * If the function is not found, we raise an error if signalNotFound is true,\n * else return (PGFunction) NULL.  Note that errors in loading the library\n * will provoke ereport() regardless of signalNotFound.\n *\n * If filehandle is not NULL, then *filehandle will be set to a handle\n * identifying the library file.  The filehandle can be used with\n * lookup_external_function to lookup additional functions in the same file\n * at less cost than repeating load_external_function.\n */\nPGFunction\nload_external_function(char *filename, char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/* Look up the function within the library */\n\tretval = (PGFunction) pg_dlsym(lib_handle, funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}\n\n/*\n * This function loads a shlib file without looking up any particular\n * function in it.\tIf the same shlib has previously been loaded,\n * unload and reload it.\n *\n * When 'restricted' is true, only libraries in the presumed-secure\n * directory $libdir/plugins may be referenced.\n */\nvoid\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}\n\n/*\n * Lookup a function whose library file is already loaded.\n * Return (PGFunction) NULL if not found.\n */\nPGFunction\nlookup_external_function(void *filehandle, char *funcname)\n{\n\treturn (PGFunction) pg_dlsym(filehandle, funcname);\n}\n\n\n/*\n * Load the specified dynamic-link library file, unless it already is\n * loaded.\tReturn the pg_dl* handle for the file.\n *\n * Note: libname is expected to be an exact name for the library file.\n */\nstatic void *\ninternal_load_library(const char *libname)\n{\n\tDynamicFileList *file_scanner;\n\tPGModuleMagicFunction magic_func;\n\tchar\t   *load_error;\n\tstruct stat stat_buf;\n\tPG_init_t\tPG_init;\n\n\t/*\n\t * Scan the list of loaded FILES to see if the file has been loaded.\n\t */\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL &&\n\t\t strcmp(libname, file_scanner->filename) != 0;\n\t\t file_scanner = file_scanner->next)\n\t\t;\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * Check for same files - different paths (ie, symlink or link)\n\t\t */\n\t\tif (stat(libname, &stat_buf) == -1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tlibname)));\n\n\t\tfor (file_scanner = file_list;\n\t\t\t file_scanner != NULL &&\n\t\t\t !SAME_INODE(stat_buf, *file_scanner);\n\t\t\t file_scanner = file_scanner->next)\n\t\t\t;\n\t}\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * File not loaded yet.\n\t\t */\n\t\tfile_scanner = (DynamicFileList *)\n\t\t\tmalloc(sizeof(DynamicFileList) + strlen(libname));\n\t\tif (file_scanner == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\tMemSet(file_scanner, 0, sizeof(DynamicFileList));\n\t\tstrcpy(file_scanner->filename, libname);\n\t\tfile_scanner->device = stat_buf.st_dev;\n#ifndef WIN32\n\t\tfile_scanner->inode = stat_buf.st_ino;\n#endif\n\t\tfile_scanner->next = NULL;\n\n\t\tfile_scanner->handle = pg_dlopen(file_scanner->filename);\n\t\tif (file_scanner->handle == NULL)\n\t\t{\n\t\t\tload_error = (char *) pg_dlerror();\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* errcode_for_file_access might not be appropriate here? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not load library \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tlibname, load_error)));\n\t\t}\n\n\t\t/* Check the magic function to determine compatibility */\n\t\tmagic_func = (PGModuleMagicFunction)\n\t\t\tpg_dlsym(file_scanner->handle, PG_MAGIC_FUNCTION_NAME_STRING);\n\t\tif (magic_func)\n\t\t{\n\t\t\tconst Pg_magic_struct *magic_data_ptr = (*magic_func) ();\n\n\t\t\tif (magic_data_ptr->len != magic_data.len ||\n\t\t\t\tmemcmp(magic_data_ptr, &magic_data, magic_data.len) != 0)\n\t\t\t{\n\t\t\t\t/* copy data block before unlinking library */\n\t\t\t\tPg_magic_struct module_magic_data = *magic_data_ptr;\n\n\t\t\t\t/* try to unlink library */\n\t\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\t\tfree((char *) file_scanner);\n\n\t\t\t\t/* issue suitable complaint */\n\t\t\t\tincompatible_module_error(libname, &module_magic_data);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try to unlink library */\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* complain */\n\t\t\tereport(ERROR,\n\t\t\t\t  (errmsg(\"incompatible library \\\"%s\\\": missing magic block\",\n\t\t\t\t\t\t  libname),\n\t\t\t\t   errhint(\"Extension libraries are required to use the PG_MODULE_MAGIC macro.\")));\n\t\t}\n\n\t\t/*\n\t\t * If the library has a _PG_init() function, call it.\n\t\t */\n\t\tPG_init = (PG_init_t) pg_dlsym(file_scanner->handle, \"_PG_init\");\n\t\tif (PG_init)\n\t\t\t(*PG_init) ();\n\n\t\t/* OK to link it into list */\n\t\tif (file_list == NULL)\n\t\t\tfile_list = file_scanner;\n\t\telse\n\t\t\tfile_tail->next = file_scanner;\n\t\tfile_tail = file_scanner;\n\t}\n\n\treturn file_scanner->handle;\n}\n\n/*\n * Identify what product a particular magic data was compiled for.\n */\nstatic const char*\nget_magic_product(const Pg_magic_struct *module_magic_data)\n{\n\t/*\n\t * Assume that any magic_data context that does not contain a product code\n\t * must be Postgres, probably.\n\t */\n\tif (module_magic_data->len <= offsetof(Pg_magic_struct, product))\n\t\treturn \"PostgreSQL\";\n\t\n\tswitch (module_magic_data->product)\n\t{\n\t\tcase PgMagicProductNone:\n\t\tcase PgMagicProductPostgres:\n\t\t\treturn \"PostgreSQL\";\n\n\t\tcase PgMagicProductGreenplum:\n\t\t\treturn \"Greenplum\";\n\n\t\t/* Handle Unrecognized product codes */\n\t\tdefault:\n\t\t\treturn psprintf(\"Product(%d)\", module_magic_data->product);\n\t}\n}\n\n\n/*\n * Report a suitable error for an incompatible magic block.\n */\nstatic void\nincompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data)\n{\n\tStringInfoData details;\n\tconst char *magic_product     = get_magic_product(&magic_data);\n\tconst char *mod_magic_product = get_magic_product(module_magic_data);\n\n\t/*\n\t * The default header version for module_magic_data is assumed to be 0\n\t * as it may not be recent enough to have the headerversion field\n\t */\n\tint lib_internal_version = 0;\n\n\t/* module_magic_data is recent enough to provide its own header version */\n\tif (module_magic_data->len > offsetof(Pg_magic_struct, headerversion))\n\t{\n\t\tlib_internal_version = module_magic_data->headerversion;\n\t}\n\n\t/*\n\t * If the version doesn't match, just report that, because the rest of the\n\t * block might not even have the fields we expect.\n\t */\n\tif (magic_data.version != module_magic_data->version ||\n\t\tmagic_data.product != module_magic_data->product ||\n\t\tmagic_data.headerversion != lib_internal_version)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"incompatible library \\\"%s\\\": version mismatch\",\n\t\t\t\t\t\tlibname),\n\t\t\t  errdetail(\"Server version is %s %d.%d (header version: %d), library is %s %d.%d (header version: %d).\",\n\t\t\t\t\t\tmagic_product,\n\t\t\t\t\t\tmagic_data.version / 100,\n\t\t\t\t\t\tmagic_data.version % 100,\n\t\t\t\t\t\tmagic_data.headerversion,\n\t\t\t\t\t\tmod_magic_product,\n\t\t\t\t\t\tmodule_magic_data->version / 100,\n\t\t\t\t\t\tmodule_magic_data->version % 100,\n\t\t\t\t\t\tlib_internal_version)\n\t\t\t\t)\n\t\t);\n\t}\n\n\t/*\n\t * Otherwise, spell out which fields don't agree.\n\t *\n\t * XXX this code has to be adjusted any time the set of fields in a magic\n\t * block change!\n\t */\n\tinitStringInfo(&details);\n\n\tif (module_magic_data->funcmaxargs != magic_data.funcmaxargs)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FUNC_MAX_ARGS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.funcmaxargs,\n\t\t\t\t\t\t module_magic_data->funcmaxargs);\n\t}\n\tif (module_magic_data->indexmaxkeys != magic_data.indexmaxkeys)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has INDEX_MAX_KEYS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.indexmaxkeys,\n\t\t\t\t\t\t module_magic_data->indexmaxkeys);\n\t}\n\tif (module_magic_data->namedatalen != magic_data.namedatalen)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has NAMEDATALEN = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.namedatalen,\n\t\t\t\t\t\t module_magic_data->namedatalen);\n\t}\n\tif (module_magic_data->float4byval != magic_data.float4byval)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT4PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float4byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float4byval ? \"true\" : \"false\");\n\t}\n\tif (module_magic_data->float8byval != magic_data.float8byval)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT8PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float8byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float8byval ? \"true\" : \"false\");\n\t}\n\n\tif (details.len == 0)\n\t{\n\t\tappendStringInfo(&details,\n\t\t\t  _(\"Magic block has unexpected length or padding difference.\"));\n\t}\n\n\tereport(ERROR,\n\t\t\t(errmsg(\"incompatible library \\\"%s\\\": magic block mismatch\",\n\t\t\t\t\tlibname),\n\t\t\t errdetail(\"%s\", details.data)));\n}\n\n/*\n * Unload the specified dynamic-link library file, if it is loaded.\n *\n * Note: libname is expected to be an exact name for the library file.\n *\n * XXX for the moment, this is disabled, resulting in LOAD of an already-loaded\n * library always being a no-op.  We might re-enable it someday if we can\n * convince ourselves we have safe protocols for un-hooking from hook function\n * pointers, releasing custom GUC variables, and perhaps other things that\n * are definitely unsafe currently.\n */\nstatic void\ninternal_unload_library(const char *libname)\n{\n#ifdef NOT_USED\n\tDynamicFileList *file_scanner,\n\t\t\t   *prv,\n\t\t\t   *nxt;\n\tstruct stat stat_buf;\n\tPG_fini_t\tPG_fini;\n\n\t/*\n\t * We need to do stat() in order to determine whether this is the same\n\t * file as a previously loaded file; it's also handy so as to give a good\n\t * error message if bogus file name given.\n\t */\n\tif (stat(libname, &stat_buf) == -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", libname)));\n\n\t/*\n\t * We have to zap all entries in the list that match on either filename or\n\t * inode, else internal_load_library() will still think it's present.\n\t */\n\tprv = NULL;\n\tfor (file_scanner = file_list; file_scanner != NULL; file_scanner = nxt)\n\t{\n\t\tnxt = file_scanner->next;\n\t\tif (strcmp(libname, file_scanner->filename) == 0 ||\n\t\t\tSAME_INODE(stat_buf, *file_scanner))\n\t\t{\n\t\t\tif (prv)\n\t\t\t\tprv->next = nxt;\n\t\t\telse\n\t\t\t\tfile_list = nxt;\n\n\t\t\t/*\n\t\t\t * If the library has a _PG_fini() function, call it.\n\t\t\t */\n\t\t\tPG_fini = (PG_fini_t) pg_dlsym(file_scanner->handle, \"_PG_fini\");\n\t\t\tif (PG_fini)\n\t\t\t\t(*PG_fini) ();\n\n\t\t\tclear_external_function_hash(file_scanner->handle);\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* prv does not change */\n\t\t}\n\t\telse\n\t\t\tprv = file_scanner;\n\t}\n#endif /* NOT_USED */\n}\n\nstatic bool\nfile_exists(const char *name)\n{\n\tstruct stat st;\n\n\tAssertArg(name != NULL);\n\n\tif (stat(name, &st) == 0)\n\t\treturn S_ISDIR(st.st_mode) ? false : true;\n\telse if (!(errno == ENOENT || errno == ENOTDIR || errno == EACCES))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", name)));\n\n\treturn false;\n}\n\n\n/* Example format: \".so\" */\n#ifndef DLSUFFIX\n#error \"DLSUFFIX must be defined to compile this file.\"\n#endif\n\n/*\n * If name contains a slash, check if the file exists, if so return\n * the name.  Else (no slash) try to expand using search path (see\n * find_in_dynamic_libpath below); if that works, return the fully\n * expanded file name.\tIf the previous failed, append DLSUFFIX and\n * try again.  If all fails, just return the original name.\n *\n * The result will always be freshly palloc'd.\n */\nstatic char *\nexpand_dynamic_library_name(const char *name)\n{\n\tbool\t\thave_slash;\n\tchar\t   *new;\n\tchar\t   *full;\n\n\tAssertArg(name);\n\n\thave_slash = (first_dir_separator(name) != NULL);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(name);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(name);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\tnew = palloc(strlen(name) + strlen(DLSUFFIX) + 1);\n\tstrcpy(new, name);\n\tstrcat(new, DLSUFFIX);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(new);\n\t\tpfree(new);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(new);\n\t\tpfree(new);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\t/*\n\t * If we can't find the file, just return the string as-is. The ensuing\n\t * load attempt will fail and report a suitable message.\n\t */\n\treturn pstrdup(name);\n}\n\n/*\n * Check a restricted library name.  It must begin with \"$libdir/plugins/\"\n * and there must not be any directory separators after that (this is\n * sufficient to prevent \"..\" style attacks).\n */\nstatic void\ncheck_restricted_library_name(const char *name)\n{\n\tif (strncmp(name, \"$libdir/plugins/\", 16) != 0 ||\n\t\tfirst_dir_separator(name + 16) != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"access to library \\\"%s\\\" is not allowed\",\n\t\t\t\t\t\tname)));\n}\n\n/*\n * Substitute for any macros appearing in the given string.\n * Result is always freshly palloc'd.\n */\nstatic char *\nsubstitute_libpath_macro(const char *name)\n{\n\tconst char *sep_ptr;\n\tchar\t   *ret;\n\n\tAssertArg(name != NULL);\n\n\t/* Currently, we only recognize $libdir at the start of the string */\n\tif (name[0] != '$')\n\t\treturn pstrdup(name);\n\n\tif ((sep_ptr = first_dir_separator(name)) == NULL)\n\t\tsep_ptr = name + strlen(name);\n\n\tif (strlen(\"$libdir\") != sep_ptr - name ||\n\t\tstrncmp(name, \"$libdir\", strlen(\"$libdir\")) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid macro name in dynamic library path: %s\",\n\t\t\t\t\t\tname)));\n\n\tret = palloc(strlen(pkglib_path) + strlen(sep_ptr) + 1);\n\n\tstrcpy(ret, pkglib_path);\n\tstrcat(ret, sep_ptr);\n\n\treturn ret;\n}\n\n\n/*\n * Search for a file called 'basename' in the colon-separated search\n * path Dynamic_library_path.  If the file is found, the full file name\n * is returned in freshly palloc'd memory.  If the file is not found,\n * return NULL.\n */\nstatic char *\nfind_in_dynamic_libpath(const char *basename)\n{\n\tconst char *p;\n\tsize_t\t\tbaselen;\n\n\tAssertArg(basename != NULL);\n\tAssertArg(first_dir_separator(basename) == NULL);\n\tAssertState(Dynamic_library_path != NULL);\n\n\tp = Dynamic_library_path;\n\tif (strlen(p) == 0)\n\t\treturn NULL;\n\n\tbaselen = strlen(basename);\n\n\tfor (;;)\n\t{\n\t\tsize_t\t\tlen;\n\t\tchar\t   *piece;\n\t\tchar\t   *mangled;\n\t\tchar\t   *full;\n\n\t\tpiece = first_path_separator(p);\n\t\tif (piece == p)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"zero-length component in parameter \\\"dynamic_library_path\\\"\")));\n\n\t\tif (piece == 0)\n\t\t\tlen = strlen(p);\n\t\telse\n\t\t\tlen = piece - p;\n\n\t\tpiece = palloc(len + 1);\n\t\tstrlcpy(piece, p, len + 1);\n\n\t\tmangled = substitute_libpath_macro(piece);\n\t\tpfree(piece);\n\n\t\tcanonicalize_path(mangled);\n\n\t\t/* only absolute paths */\n\t\tif (!is_absolute_path(mangled))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"component in parameter \\\"dynamic_library_path\\\" is not an absolute path\")));\n\n\t\tfull = palloc(strlen(mangled) + 1 + baselen + 1);\n\t\tsprintf(full, \"%s/%s\", mangled, basename);\n\t\tpfree(mangled);\n\n\t\telog(DEBUG3, \"find_in_dynamic_libpath: trying \\\"%s\\\"\", full);\n\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\n\t\tpfree(full);\n\n\t\tif (p[len] == '\\0')\n\t\t\tbreak;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Find (or create) a rendezvous variable that one dynamically\n * loaded library can use to meet up with another.\n *\n * On the first call of this function for a particular varName,\n * a \"rendezvous variable\" is created with the given name.\n * The value of the variable is a void pointer (initially set to NULL).\n * Subsequent calls with the same varName just return the address of\n * the existing variable.  Once created, a rendezvous variable lasts\n * for the life of the process.\n *\n * Dynamically loaded libraries can use rendezvous variables\n * to find each other and share information: they just need to agree\n * on the variable name and the data it will point to.\n */\nvoid\t  **\nfind_rendezvous_variable(const char *varName)\n{\n\tstatic HTAB *rendezvousHash = NULL;\n\n\trendezvousHashEntry *hentry;\n\tbool\t\tfound;\n\n\t/* Create a hashtable if we haven't already done so in this process */\n\tif (rendezvousHash == NULL)\n\t{\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = NAMEDATALEN;\n\t\tctl.entrysize = sizeof(rendezvousHashEntry);\n\t\trendezvousHash = hash_create(\"Rendezvous variable hash\",\n\t\t\t\t\t\t\t\t\t 16,\n\t\t\t\t\t\t\t\t\t &ctl,\n\t\t\t\t\t\t\t\t\t HASH_ELEM);\n\t}\n\n\t/* Find or create the hashtable entry for this varName */\n\thentry = (rendezvousHashEntry *) hash_search(rendezvousHash,\n\t\t\t\t\t\t\t\t\t\t\t\t varName,\n\t\t\t\t\t\t\t\t\t\t\t\t HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t\t &found);\n\n\t/* Initialize to NULL if first time */\n\tif (!found)\n\t\thentry->varValue = NULL;\n\n\treturn &hentry->varValue;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/pg_regress.c": "/*-------------------------------------------------------------------------\n *\n * pg_regress --- regression test driver\n *\n * This is a C implementation of the previous shell script for running\n * the regression tests, and should be mostly compatible with it.\n * Initial author of C translation: Magnus Hagander\n *\n * This code is released under the terms of the PostgreSQL License.\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/test/regress/pg_regress.c,v 1.41.2.4 2009/11/14 15:39:41 mha Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"pg_regress.h\"\n\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <unistd.h>\n\n#ifdef __linux__\n#include <mntent.h>\n#endif\n\n#ifdef HAVE_SYS_RESOURCE_H\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#include \"getopt_long.h\"\n#include \"pg_config_paths.h\"\n\n/* for resultmap we need a list of pairs of strings */\ntypedef struct _resultmap\n{\n\tchar\t   *test;\n\tchar\t   *type;\n\tchar\t   *resultfile;\n\tstruct _resultmap *next;\n}\t_resultmap;\n\n/*\n * Values obtained from pg_config_paths.h and Makefile.  The PG installation\n * paths are only used in temp_install mode: we use these strings to find\n * out where \"make install\" will put stuff under the temp_install directory.\n * In non-temp_install mode, the only thing we need is the location of psql,\n * which we expect to find in psqldir, or in the PATH if psqldir isn't given.\n *\n * XXX Because pg_regress is not installed in bindir, we can't support\n * this for relocatable trees as it is.  --psqldir would need to be\n * specified in those cases.\n */\nchar\t   *bindir = PGBINDIR;\nchar\t   *libdir = LIBDIR;\nchar\t   *datadir = PGSHAREDIR;\nchar\t   *host_platform = HOST_TUPLE;\n\n#ifndef WIN32_ONLY_COMPILER\nstatic char *makeprog = MAKEPROG;\n#endif\n\n#ifndef WIN32\t\t\t\t\t/* not used in WIN32 case */\nstatic char *shellprog = SHELLPROG;\n#endif\n\nstatic char gpdiffprog[MAXPGPATH];\nstatic char gpstringsubsprog[MAXPGPATH];\n\n/* currently we can use the same diff switches on all platforms */\n/* MPP:  Add stuff to ignore all the extra NOTICE messages we give */\nconst char *basic_diff_opts = \"-w -I HINT: -I CONTEXT: -I GP_IGNORE:\";\nconst char *pretty_diff_opts = \"-w -I HINT: -I CONTEXT: -I GP_IGNORE: -C3\";\n\n/* options settable from command line */\n_stringlist *dblist = NULL;\nbool\t\tdebug = false;\nchar\t   *inputdir = \".\";\nchar\t   *outputdir = \".\";\nchar\t   *psqldir = PGBINDIR;\nbool \t\toptimizer_enabled = false;\nbool \t\tresgroup_enabled = false;\nstatic _stringlist *loadlanguage = NULL;\nstatic int\tmax_connections = 0;\nstatic char *encoding = NULL;\nstatic _stringlist *schedulelist = NULL;\nstatic _stringlist *exclude_tests = NULL;\nstatic _stringlist *extra_tests = NULL;\nstatic char *temp_install = NULL;\nstatic char *temp_config = NULL;\nstatic char *top_builddir = NULL;\nstatic int\ttemp_port = 65432;\nstatic bool nolocale = false;\nstatic bool use_existing = false;\nstatic char *hostname = NULL;\nstatic int\tport = -1;\nstatic char *user = NULL;\nstatic char *srcdir = NULL;\nstatic _stringlist *extraroles = NULL;\nstatic char *initfile = NULL;\nstatic char *aodir = NULL;\nstatic char *resgroupdir = NULL;\n\n/* internal variables */\nstatic const char *progname;\nstatic char *logfilename;\nstatic FILE *logfile;\nstatic char *difffilename;\n\nstatic _resultmap *resultmap = NULL;\n\nstatic PID_TYPE postmaster_pid = INVALID_PID;\nstatic bool postmaster_running = false;\n\nstatic int\tsuccess_count = 0;\nstatic int\tfail_count = 0;\nstatic int\tfail_ignore_count = 0;\n\nstatic bool directory_exists(const char *dir);\nstatic void make_directory(const char *dir);\n\nstatic void create_database(const char *dbname);\nstatic void drop_database_if_exists(const char *dbname);\n\nstatic int\nrun_diff(const char *cmd, const char *filename);\n\nstatic bool should_exclude_test(char *test);\n\nstatic void\nheader(const char *fmt,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nstatic void\nstatus(const char *fmt,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nstatic void\npsql_command(const char *database, const char *query,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\n#ifdef WIN32\ntypedef BOOL (WINAPI * __CreateRestrictedToken) (HANDLE, DWORD, DWORD, PSID_AND_ATTRIBUTES, DWORD, PLUID_AND_ATTRIBUTES, DWORD, PSID_AND_ATTRIBUTES, PHANDLE);\n\n/* Windows API define missing from MingW headers */\n#define DISABLE_MAX_PRIVILEGE\t0x1\n#endif\n\nstatic bool detectCgroupMountPoint(char *cgdir, int len);\n\n/*\n * allow core files if possible.\n */\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_CORE)\nstatic void\nunlimit_core_size(void)\n{\n\tstruct rlimit lim;\n\n\tgetrlimit(RLIMIT_CORE, &lim);\n\tif (lim.rlim_max == 0)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not set core size: disallowed by hard limit\\n\"),\n\t\t\t\tprogname);\n\t\treturn;\n\t}\n\telse if (lim.rlim_max == RLIM_INFINITY || lim.rlim_cur < lim.rlim_max)\n\t{\n\t\tlim.rlim_cur = lim.rlim_max;\n\t\tsetrlimit(RLIMIT_CORE, &lim);\n\t}\n}\n#endif\n\n\n/*\n * Add an item at the end of a stringlist.\n */\nvoid\nadd_stringlist_item(_stringlist ** listhead, const char *str)\n{\n\t_stringlist *newentry = malloc(sizeof(_stringlist));\n\t_stringlist *oldentry;\n\n\tnewentry->str = strdup(str);\n\tnewentry->next = NULL;\n\tif (*listhead == NULL)\n\t\t*listhead = newentry;\n\telse\n\t{\n\t\tfor (oldentry = *listhead; oldentry->next; oldentry = oldentry->next)\n\t\t\t /* skip */ ;\n\t\toldentry->next = newentry;\n\t}\n}\n\n/*\n * Free a stringlist.\n */\nstatic void\nfree_stringlist(_stringlist ** listhead)\n{\n\tif (listhead == NULL || *listhead == NULL)\n\t\treturn;\n\tif ((*listhead)->next != NULL)\n\t\tfree_stringlist(&((*listhead)->next));\n\tfree((*listhead)->str);\n\tfree(*listhead);\n\t*listhead = NULL;\n}\n\n/*\n * Split a delimited string into a stringlist\n */\nstatic void\nsplit_to_stringlist(const char *s, const char *delim, _stringlist ** listhead)\n{\n\tchar\t   *sc = strdup(s);\n\tchar\t   *token = strtok(sc, delim);\n\n\twhile (token)\n\t{\n\t\tadd_stringlist_item(listhead, token);\n\t\ttoken = strtok(NULL, delim);\n\t}\n\tfree(sc);\n}\n\n/*\n * Print a progress banner on stdout.\n */\nstatic void\nheader(const char *fmt,...)\n{\n\tchar\t\ttmp[64];\n\tva_list\t\tap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(tmp, sizeof(tmp), fmt, ap);\n\tva_end(ap);\n\n\tfprintf(stdout, \"============== %-38s ==============\\n\", tmp);\n\tfflush(stdout);\n}\n\n/*\n * Print \"doing something ...\" --- supplied text should not end with newline\n */\nstatic void\nstatus(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stdout, fmt, ap);\n\tfflush(stdout);\n\tva_end(ap);\n\n\tif (logfile)\n\t{\n\t\tva_start(ap, fmt);\n\t\tvfprintf(logfile, fmt, ap);\n\t\tva_end(ap);\n\t}\n}\n\n/*\n * Done \"doing something ...\"\n */\nstatic void\nstatus_end(void)\n{\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (logfile)\n\t\tfprintf(logfile, \"\\n\");\n}\n\n/*\n * shut down temp postmaster\n */\nstatic void\nstop_postmaster(void)\n{\n\tif (postmaster_running)\n\t{\n\t\t/* We use pg_ctl to issue the kill and wait for stop */\n\t\tchar\t\tbuf[MAXPGPATH * 2];\n\t\tint\t\t\tr;\n\n\t\t/* On Windows, system() seems not to force fflush, so... */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"\\\"%s/pg_ctl\\\" stop -D \\\"%s/data\\\" -s -m fast\" SYSTEMQUOTE,\n\t\t\t\t bindir, temp_install);\n\t\tr = system(buf);\n\t\tif (r != 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not stop postmaster: exit code was %d\\n\"),\n\t\t\t\t\tprogname, r);\n\t\t\texit(2);\t\t\t/* not exit_nicely(), that would be recursive */\n\t\t}\n\n\t\tpostmaster_running = false;\n\t}\n}\n\n/*\n * Always exit through here, not through plain exit(), to ensure we make\n * an effort to shut down a temp postmaster\n */\nvoid\nexit_nicely(int code)\n{\n\tstop_postmaster();\n\texit(code);\n}\n\n/*\n * Check whether string matches pattern\n *\n * In the original shell script, this function was implemented using expr(1),\n * which provides basic regular expressions restricted to match starting at\n * the string start (in conventional regex terms, there's an implicit \"^\"\n * at the start of the pattern --- but no implicit \"$\" at the end).\n *\n * For now, we only support \".\" and \".*\" as non-literal metacharacters,\n * because that's all that anyone has found use for in resultmap.  This\n * code could be extended if more functionality is needed.\n */\nstatic bool\nstring_matches_pattern(const char *str, const char *pattern)\n{\n\twhile (*str && *pattern)\n\t{\n\t\tif (*pattern == '.' && pattern[1] == '*')\n\t\t{\n\t\t\tpattern += 2;\n\t\t\t/* Trailing .* matches everything. */\n\t\t\tif (*pattern == '\\0')\n\t\t\t\treturn true;\n\n\t\t\t/*\n\t\t\t * Otherwise, scan for a text position at which we can match the\n\t\t\t * rest of the pattern.\n\t\t\t */\n\t\t\twhile (*str)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Optimization to prevent most recursion: don't recurse\n\t\t\t\t * unless first pattern char might match this text char.\n\t\t\t\t */\n\t\t\t\tif (*str == *pattern || *pattern == '.')\n\t\t\t\t{\n\t\t\t\t\tif (string_matches_pattern(str, pattern))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tstr++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * End of text with no match.\n\t\t\t */\n\t\t\treturn false;\n\t\t}\n\t\telse if (*pattern != '.' && *str != *pattern)\n\t\t{\n\t\t\t/*\n\t\t\t * Not the single-character wildcard and no explicit match? Then\n\t\t\t * time to quit...\n\t\t\t */\n\t\t\treturn false;\n\t\t}\n\n\t\tstr++;\n\t\tpattern++;\n\t}\n\n\tif (*pattern == '\\0')\n\t\treturn true;\t\t\t/* end of pattern, so declare match */\n\n\t/* End of input string.  Do we have matching pattern remaining? */\n\twhile (*pattern == '.' && pattern[1] == '*')\n\t\tpattern += 2;\n\tif (*pattern == '\\0')\n\t\treturn true;\t\t\t/* end of pattern, so declare match */\n\n\treturn false;\n}\n\n/*\n * Replace all occurances of a string in a string with a different string.\n * NOTE: Assumes there is enough room in the target buffer!\n */\nvoid\nreplace_string(char *string, char *replace, char *replacement)\n{\n\tchar\t   *ptr;\n\n\twhile ((ptr = strstr(string, replace)) != NULL)\n\t{\n\t\tchar\t   *dup = strdup(string);\n\n\t\tstrlcpy(string, dup, ptr - string + 1);\n\t\tstrcat(string, replacement);\n\t\tstrcat(string, dup + (ptr - string) + strlen(replace));\n\t\tfree(dup);\n\t}\n}\n\ntypedef struct replacements\n{\n\tchar *abs_srcdir;\n\tchar *abs_builddir;\n\tchar *testtablespace;\n\tchar *dlsuffix;\n\tchar *bindir;\n\tchar *orientation;\n\tchar *cgroup_mnt_point;\n} replacements;\n\n/* Internal helper function to detect cgroup mount point at runtime.*/\nstatic bool\ndetectCgroupMountPoint(char *cgdir, int len)\n{\n#ifdef __linux__\n\tstruct mntent *me;\n\tFILE *fp;\n\tbool ret = false;\n\n\tfp = setmntent(\"/proc/self/mounts\", \"r\");\n\tif (fp == NULL)\n\t\treturn ret;\n\n\twhile ((me = getmntent(fp)))\n\t{\n\t\tchar *p;\n\n\t\tif (strcmp(me->mnt_type, \"cgroup\"))\n\t\t\tcontinue;\n\n\t\tstrncpy(cgdir, me->mnt_dir, len);\n\n\t\tp = strrchr(cgdir, '/');\n\t\tif (p != NULL)\n\t\t{\n\t\t\t*p = 0;\n\t\t\tret = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\tendmntent(fp);\n\treturn ret;\n#else\n\treturn false;\n#endif\n}\n\nstatic void\nconvert_line(char *line, replacements *repls)\n{\n\treplace_string(line, \"@cgroup_mnt_point@\", repls->cgroup_mnt_point);\n\treplace_string(line, \"@abs_srcdir@\", repls->abs_srcdir);\n\treplace_string(line, \"@abs_builddir@\", repls->abs_builddir);\n\treplace_string(line, \"@testtablespace@\", repls->testtablespace);\n\treplace_string(line, \"@DLSUFFIX@\", repls->dlsuffix);\n\treplace_string(line, \"@bindir@\", repls->bindir);\n\tif (repls->orientation)\n\t{\n\t\treplace_string(line, \"@orientation@\", repls->orientation);\n\t\tif (strcmp(repls->orientation, \"row\") == 0)\n\t\t\treplace_string(line, \"@aoseg@\", \"aoseg\");\n\t\telse\n\t\t\treplace_string(line, \"@aoseg@\", \"aocsseg\");\n\t}\n}\n\n/*\n * Generate two files for each UAO test case, one for row and the\n * other for column orientation.\n */\nstatic int\ngenerate_uao_sourcefiles(char *src_dir, char *dest_dir, char *suffix, replacements *repls)\n{\n\tstruct stat st;\n\tint\t\t\tret;\n\tchar\t  **name;\n\tchar\t  **names;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * Return silently if src_dir or dest_dir is not a directory, in\n\t * the same spirit as in convert_sourcefiles_in().\n\t */\n\tret = stat(src_dir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = stat(dest_dir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tnames = pgfnames(src_dir);\n\tif (!names)\n\t\t/* Error logged in pgfnames */\n\t\texit_nicely(2);\n\n\t/* finally loop on each file and generate the files */\n\tfor (name = names; *name; name++)\n\t{\n\t\tchar\t\tsrcfile[MAXPGPATH];\n\t\tchar\t\tdestfile_row[MAXPGPATH];\n\t\tchar\t\tdestfile_col[MAXPGPATH];\n\t\tchar\t\tprefix[MAXPGPATH];\n\t\tFILE\t   *infile,\n\t\t\t\t   *outfile_row,\n\t\t\t\t   *outfile_col;\n\t\tchar\t\tline[1024];\n\t\tchar\t\tline_row[1024];\n\t\tbool\t\thas_tokens = false;\n\n\t\t/* reject filenames not finishing in \".source\" */\n\t\tif (strlen(*name) < 8)\n\t\t\tcontinue;\n\t\tif (strcmp(*name + strlen(*name) - 7, \".source\") != 0)\n\t\t\tcontinue;\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Build the full actual paths to open.  Optimizer specific\n\t\t * answer filenames must end with \"optimizer\".\n\t\t */\n\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", src_dir, *name);\n\t\tif (strlen(*name) > 17 &&\n\t\t\tstrcmp(*name + strlen(*name) - 17, \"_optimizer.source\") == 0)\n\t\t{\n\t\t\tsnprintf(prefix, strlen(*name) - 16, \"%s\", *name);\n\t\t\tsnprintf(destfile_row, MAXPGPATH, \"%s/%s_row_optimizer.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t\tsnprintf(destfile_col, MAXPGPATH, \"%s/%s_column_optimizer.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(prefix, strlen(*name) - 6, \"%s\", *name);\n\t\t\tsnprintf(destfile_row, MAXPGPATH, \"%s/%s_row.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t\tsnprintf(destfile_col, MAXPGPATH, \"%s/%s_column.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t}\n\n\t\tinfile = fopen(srcfile, \"r\");\n\t\tif (!infile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\t\tprogname, srcfile, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\toutfile_row = fopen(destfile_row, \"w\");\n\t\tif (!outfile_row)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile_row, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\toutfile_col = fopen(destfile_col, \"w\");\n\t\tif (!outfile_col)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile_col, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\twhile (fgets(line, sizeof(line), infile))\n\t\t{\n\t\t\tstrncpy(line_row, line, sizeof(line));\n\t\t\trepls->orientation = \"row\";\n\t\t\tconvert_line(line_row, repls);\n\t\t\trepls->orientation = \"column\";\n\t\t\tconvert_line(line, repls);\n\t\t\tfputs(line, outfile_col);\n\t\t\tfputs(line_row, outfile_row);\n\t\t\t/*\n\t\t\t * Remember if there are any more tokens that we didn't recognize.\n\t\t\t * They need to be handled by the gpstringsubs.pl script\n\t\t\t */\n\t\t\tif (!has_tokens && strchr(line, '@') != NULL)\n\t\t\t\thas_tokens = true;\n\t\t}\n\n\t\tfclose(infile);\n\t\tfclose(outfile_row);\n\t\tfclose(outfile_col);\n\t\tif (has_tokens)\n\t\t{\n\t\t\tchar\t\tcmd[MAXPGPATH * 3];\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t SYSTEMQUOTE \"%s %s\" SYSTEMQUOTE, gpstringsubsprog, destfile_row);\n\t\t\tif (run_diff(cmd, destfile_row) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile_row);\n\t\t\t}\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t SYSTEMQUOTE \"%s %s\" SYSTEMQUOTE, gpstringsubsprog, destfile_col);\n\t\t\tif (run_diff(cmd, destfile_col) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile_col);\n\t\t\t}\n\t\t}\n\t}\n\n\tpgfnames_cleanup(names);\n\treturn count;\n}\n\n/*\n * Convert *.source found in the \"source\" directory, replacing certain tokens\n * in the file contents with their intended values, and put the resulting files\n * in the \"dest\" directory, replacing the \".source\" prefix in their names with\n * the given suffix.\n */\nstatic int\nconvert_sourcefiles_in(char *source, char * dest_dir, char *dest, char *suffix)\n{\n\tchar\t\tabs_srcdir[MAXPGPATH];\n\tchar\t\tabs_builddir[MAXPGPATH];\n\tchar\t\ttesttablespace[MAXPGPATH];\n\tchar\t\tindir[MAXPGPATH];\n\tchar\t\tcgroup_mnt_point[MAXPGPATH];\n\treplacements repls;\n\tstruct stat st;\n\tint\t\t\tret;\n\tchar\t  **name;\n\tchar\t  **names;\n\tint\t\t\tcount = 0;\n\n#ifdef WIN32\n\tchar\t   *c;\n#endif\n\n\tif (!getcwd(abs_builddir, sizeof(abs_builddir)))\n\t{\n\t\tfprintf(stderr, _(\"%s: could not get current directory: %s\\n\"),\n\t\t\t\tprogname, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\t/*\n\t * in a VPATH build, use the provided source directory; otherwise, use the\n\t * current directory.\n\t */\n\tif (srcdir)\n\t\tstrlcpy(abs_srcdir, srcdir, MAXPGPATH);\n\telse\n\t\tstrlcpy(abs_srcdir, abs_builddir, MAXPGPATH);\n\n\tsnprintf(indir, MAXPGPATH, \"%s/%s\", abs_srcdir, source);\n\n\t/* Check that indir actually exists and is a directory */\n\tret = stat(indir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t{\n\t\t/*\n\t\t * No warning, to avoid noise in tests that do not have\n\t\t * these directories; for example, ecpg, contrib and src/pl.\n\t\t */\n\t\treturn count;\n\t}\n\n\tnames = pgfnames(indir);\n\tif (!names)\n\t\t/* Error logged in pgfnames */\n\t\texit_nicely(2);\n\n\t/* also create the output directory if not present */\n\t{\n\t\tchar\t\toutdir[MAXPGPATH];\n\n\t\tsnprintf(outdir, MAXPGPATH, \"%s/%s\", dest_dir, dest);\n\n\t\tif (!directory_exists(outdir))\n\t\t\tmake_directory(outdir);\n\t}\n\n#ifdef WIN32\n\t/* in Win32, replace backslashes with forward slashes */\n\tfor (c = abs_builddir; *c; c++)\n\t\tif (*c == '\\\\')\n\t\t\t*c = '/';\n\tfor (c = abs_srcdir; *c; c++)\n\t\tif (*c == '\\\\')\n\t\t\t*c = '/';\n#endif\n\n\tsnprintf(testtablespace, MAXPGPATH, \"%s/testtablespace\", abs_builddir);\n\n#ifdef WIN32\n\t/*\n\t * On Windows only, clean out the test tablespace dir, or create it if it\n\t * doesn't exist.  On other platforms we expect the Makefile to take\n\t * care of that.  (We don't migrate that functionality in here because\n\t * it'd be harder to cope with platform-specific issues such as SELinux.)\n\t *\n\t * XXX it would be better if pg_regress.c had nothing at all to do with\n\t * testtablespace, and this were handled by a .BAT file or similar on\n\t * Windows.  See pgsql-hackers discussion of 2008-01-18.\n\t */\n\tif (directory_exists(testtablespace))\n\t\trmtree(testtablespace, true);\n\tmake_directory(testtablespace);\n#endif\n\n\tmemset(cgroup_mnt_point, 0, sizeof(cgroup_mnt_point));\n\tif (!detectCgroupMountPoint(cgroup_mnt_point,\n\t\t\t\t\t\t\t\tsizeof(cgroup_mnt_point) - 1))\n\t\tstrcpy(cgroup_mnt_point, \"/sys/fs/cgroup\");\n\n\tmemset(&repls, 0, sizeof(repls));\n\trepls.abs_srcdir = abs_srcdir;\n\trepls.abs_builddir = abs_builddir;\n\trepls.testtablespace = testtablespace;\n\trepls.dlsuffix = DLSUFFIX;\n\trepls.bindir = bindir;\n\trepls.cgroup_mnt_point = cgroup_mnt_point;\n\n\t/* finally loop on each file and do the replacement */\n\tfor (name = names; *name; name++)\n\t{\n\t\tchar\t\tsrcfile[MAXPGPATH];\n\t\tchar\t\tdestfile[MAXPGPATH];\n\t\tchar\t\tprefix[MAXPGPATH];\n\t\tFILE\t   *infile,\n\t\t\t\t   *outfile;\n\t\tchar\t\tline[1024];\n\t\tbool\t\thas_tokens = false;\n\n\n\t\tif (aodir && strncmp(*name, aodir, strlen(aodir)) == 0 &&\n\t\t\t(strlen(*name) < 8 || strcmp(*name + strlen(*name) - 7, \".source\") != 0))\n\t\t{\n\t\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\",  indir, *name);\n\t\t\tsnprintf(destfile, MAXPGPATH, \"%s/%s/%s\", dest_dir, dest, *name);\n\t\t\tcount += generate_uao_sourcefiles(srcfile, destfile, suffix, &repls);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (resgroupdir && strncmp(*name, resgroupdir, strlen(resgroupdir)) == 0 &&\n\t\t\t(strlen(*name) < 8 || strcmp(*name + strlen(*name) - 7, \".source\") != 0))\n\t\t{\n\t\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", source, *name);\n\t\t\tsnprintf(destfile, MAXPGPATH, \"%s/%s/%s\", dest_dir, dest, *name);\n\t\t\tcount += convert_sourcefiles_in(srcfile, dest_dir, destfile, suffix);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* reject filenames not finishing in \".source\" */\n\t\tif (strlen(*name) < 8)\n\t\t\tcontinue;\n\t\tif (strcmp(*name + strlen(*name) - 7, \".source\") != 0)\n\t\t\tcontinue;\n\n\t\tcount++;\n\n\t\t/* build the full actual paths to open */\n\t\tsnprintf(prefix, strlen(*name) - 6, \"%s\", *name);\n\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", indir, *name);\n\t\tsnprintf(destfile, MAXPGPATH, \"%s/%s/%s.%s\", dest_dir, dest, \n\t\t\t\t prefix, suffix);\n\n\t\tinfile = fopen(srcfile, \"r\");\n\t\tif (!infile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\t\tprogname, srcfile, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\toutfile = fopen(destfile, \"w\");\n\t\tif (!outfile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\twhile (fgets(line, sizeof(line), infile))\n\t\t{\n\t\t\tconvert_line(line, &repls);\n\t\t\tfputs(line, outfile);\n\n\t\t\t/*\n\t\t\t * Remember if there are any more tokens that we didn't recognize.\n\t\t\t * They need to be handled by the gpstringsubs.pl script\n\t\t\t */\n\t\t\tif (!has_tokens && strchr(line, '@') != NULL)\n\t\t\t\thas_tokens = true;\n\t\t}\n\t\tfclose(infile);\n\t\tfclose(outfile);\n\n\t\tif (has_tokens)\n\t\t{\n\t\t\tchar\t\tcmd[MAXPGPATH * 3];\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t SYSTEMQUOTE \"%s %s\" SYSTEMQUOTE, gpstringsubsprog, destfile);\n\t\t\tif (run_diff(cmd, destfile) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * If we didn't process any files, complain because it probably means\n\t * somebody neglected to pass the needed --inputdir argument.\n\t */\n\tif (count <= 0)\n\t{\n\t\tfprintf(stderr, _(\"%s: no *.source files found in \\\"%s\\\"\\n\"),\n\t\t\t\tprogname, indir);\n\t\texit_nicely(2);\n\t}\n\n\tpgfnames_cleanup(names);\n\n\treturn count;\n}\n\n/* Create the .sql, .out and .yml files from the .source files, if any */\nstatic void\nconvert_sourcefiles(void)\n{\n\tconvert_sourcefiles_in(\"input\", outputdir, \"sql\", \"sql\");\n\tconvert_sourcefiles_in(\"output\", outputdir, \"expected\", \"out\");\n\n\tconvert_sourcefiles_in(\"yml_in\", inputdir, \"yml\", \"yml\");\n}\n\n/*\n * Scan resultmap file to find which platform-specific expected files to use.\n *\n * The format of each line of the file is\n *\t\t   testname/hostplatformpattern=substitutefile\n * where the hostplatformpattern is evaluated per the rules of expr(1),\n * namely, it is a standard regular expression with an implicit ^ at the start.\n * (We currently support only a very limited subset of regular expressions,\n * see string_matches_pattern() above.)  What hostplatformpattern will be\n * matched against is the config.guess output.\t(In the shell-script version,\n * we also provided an indication of whether gcc or another compiler was in\n * use, but that facility isn't used anymore.)\n */\nstatic void\nload_resultmap(void)\n{\n\tchar\t\tbuf[MAXPGPATH];\n\tFILE\t   *f;\n\n\t/* scan the file ... */\n\tsnprintf(buf, sizeof(buf), \"%s/resultmap\", inputdir);\n\tf = fopen(buf, \"r\");\n\tif (!f)\n\t{\n\t\t/* OK if it doesn't exist, else complain */\n\t\tif (errno == ENOENT)\n\t\t\treturn;\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, buf, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f))\n\t{\n\t\tchar\t   *platform;\n\t\tchar\t   *file_type;\n\t\tchar\t   *expected;\n\t\tint\t\t\ti;\n\n\t\t/* strip trailing whitespace, especially the newline */\n\t\ti = strlen(buf);\n\t\twhile (i > 0 && isspace((unsigned char) buf[i - 1]))\n\t\t\tbuf[--i] = '\\0';\n\n\t\t/* parse out the line fields */\n\t\tfile_type = strchr(buf, ':');\n\t\tif (!file_type)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit_nicely(2);\n\t\t}\n\t\t*file_type++ = '\\0';\n\n\t\tplatform = strchr(file_type, ':');\n\t\tif (!platform)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit_nicely(2);\n\t\t}\n\t\t*platform++ = '\\0';\n\t\texpected = strchr(platform, '=');\n\t\tif (!expected)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit_nicely(2);\n\t\t}\n\t\t*expected++ = '\\0';\n\n\t\t/*\n\t\t * if it's for current platform, save it in resultmap list. Note: by\n\t\t * adding at the front of the list, we ensure that in ambiguous cases,\n\t\t * the last match in the resultmap file is used. This mimics the\n\t\t * behavior of the old shell script.\n\t\t */\n\t\tif (string_matches_pattern(host_platform, platform))\n\t\t{\n\t\t\t_resultmap *entry = malloc(sizeof(_resultmap));\n\n\t\t\tentry->test = strdup(buf);\n\t\t\tentry->type = strdup(file_type);\n\t\t\tentry->resultfile = strdup(expected);\n\t\t\tentry->next = resultmap;\n\t\t\tresultmap = entry;\n\t\t}\n\t}\n\tfclose(f);\n}\n\n/*\n * Check in resultmap if we should be looking at a different file\n */\nstatic\nconst char *\nget_expectfile(const char *testname, const char *file)\n{\n\tchar\t   *file_type;\n\t_resultmap *rm;\n\n\t/*\n\t * Determine the file type from the file name. This is just what is\n\t * following the last dot in the file name.\n\t */\n\tif (!file || !(file_type = strrchr(file, '.')))\n\t\treturn NULL;\n\n\tfile_type++;\n\n\tfor (rm = resultmap; rm != NULL; rm = rm->next)\n\t{\n\t\tif (strcmp(testname, rm->test) == 0 && strcmp(file_type, rm->type) == 0)\n\t\t{\n\t\t\treturn rm->resultfile;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Handy subroutine for setting an environment variable \"var\" to \"val\"\n */\nstatic void\ndoputenv(const char *var, const char *val)\n{\n\tchar\t   *s = malloc(strlen(var) + strlen(val) + 2);\n\n\tsprintf(s, \"%s=%s\", var, val);\n\tputenv(s);\n}\n\n/*\n * Set the environment variable \"pathname\", prepending \"addval\" to its\n * old value (if any).\n */\nstatic void\nadd_to_path(const char *pathname, char separator, const char *addval)\n{\n\tchar\t   *oldval = getenv(pathname);\n\tchar\t   *newval;\n\n\tif (!oldval || !oldval[0])\n\t{\n\t\t/* no previous value */\n\t\tnewval = malloc(strlen(pathname) + strlen(addval) + 2);\n\t\tsprintf(newval, \"%s=%s\", pathname, addval);\n\t}\n\telse\n\t{\n\t\tnewval = malloc(strlen(pathname) + strlen(addval) + strlen(oldval) + 3);\n\t\tsprintf(newval, \"%s=%s%c%s\", pathname, addval, separator, oldval);\n\t}\n\tputenv(newval);\n}\n\n/*\n * Prepare environment variables for running regression tests\n */\nstatic void\ninitialize_environment(void)\n{\n\tchar\t   *tmp;\n\n\tif (nolocale)\n\t{\n\t\t/*\n\t\t * Clear out any non-C locale settings\n\t\t */\n\t\tunsetenv(\"LC_COLLATE\");\n\t\tunsetenv(\"LC_CTYPE\");\n\t\tunsetenv(\"LC_MONETARY\");\n\t\tunsetenv(\"LC_NUMERIC\");\n\t\tunsetenv(\"LC_TIME\");\n\t\tunsetenv(\"LANG\");\n\t\t/* On Windows the default locale cannot be English, so force it */\n#if defined(WIN32) || defined(__CYGWIN__)\n\t\tputenv(\"LANG=en\");\n#endif\n\t}\n\n\t/*\n\t * Set translation-related settings to English; otherwise psql will\n\t * produce translated messages and produce diffs.  (XXX If we ever support\n\t * translation of pg_regress, this needs to be moved elsewhere, where psql\n\t * is actually called.)\n\t */\n\tunsetenv(\"LANGUAGE\");\n\tunsetenv(\"LC_ALL\");\n\tputenv(\"LC_MESSAGES=C\");\n\n\t/*\n\t * Set multibyte as requested\n\t */\n\tif (encoding && strlen(encoding) > 0)\n\t\tdoputenv(\"PGCLIENTENCODING\", encoding);\n\telse\n\t\tunsetenv(\"PGCLIENTENCODING\");\n\n\t/*\n\t * Set timezone and datestyle for datetime-related tests\n\t */\n\tputenv(\"PGTZ=PST8PDT\");\n\tputenv(\"PGDATESTYLE=Postgres, MDY\");\n\n\t/*\n\t * Likewise set intervalstyle to ensure consistent results.  This is a bit\n\t * more painful because we must use PGOPTIONS, and we want to preserve the\n\t * user's ability to set other variables through that.\n\t */\n\t{\n\t\tconst char *my_pgoptions = \"-c intervalstyle=postgres_verbose\";\n\t\tconst char *old_pgoptions = getenv(\"PGOPTIONS\");\n\t\tchar\t   *new_pgoptions;\n\n\t\tif (!old_pgoptions)\n\t\t\told_pgoptions = \"\";\n\t\tnew_pgoptions = malloc(strlen(old_pgoptions) + strlen(my_pgoptions) + 12);\n\t\tsprintf(new_pgoptions, \"PGOPTIONS=%s %s\", old_pgoptions, my_pgoptions);\n\t\tputenv(new_pgoptions);\n\t}\n\n\tif (temp_install)\n\t{\n\t\t/*\n\t\t * Clear out any environment vars that might cause psql to connect to\n\t\t * the wrong postmaster, or otherwise behave in nondefault ways. (Note\n\t\t * we also use psql's -X switch consistently, so that ~/.psqlrc files\n\t\t * won't mess things up.)  Also, set PGPORT to the temp port, and set\n\t\t * or unset PGHOST depending on whether we are using TCP or Unix\n\t\t * sockets.\n\t\t */\n\t\tunsetenv(\"PGDATABASE\");\n\t\tunsetenv(\"PGUSER\");\n\t\tunsetenv(\"PGSERVICE\");\n\t\tunsetenv(\"PGSSLMODE\");\n\t\tunsetenv(\"PGREQUIRESSL\");\n\t\tunsetenv(\"PGCONNECT_TIMEOUT\");\n\t\tunsetenv(\"PGDATA\");\n\t\tif (hostname != NULL)\n\t\t\tdoputenv(\"PGHOST\", hostname);\n\t\telse\n\t\t\tunsetenv(\"PGHOST\");\n\t\tunsetenv(\"PGHOSTADDR\");\n\t\tif (port != -1)\n\t\t{\n\t\t\tchar\t\ts[16];\n\n\t\t\tsprintf(s, \"%d\", port);\n\t\t\tdoputenv(\"PGPORT\", s);\n\t\t}\n\n\t\t/*\n\t\t * GNU make stores some flags in the MAKEFLAGS environment variable to\n\t\t * pass arguments to its own children.\tIf we are invoked by make,\n\t\t * that causes the make invoked by us to think its part of the make\n\t\t * task invoking us, and so it tries to communicate with the toplevel\n\t\t * make.  Which fails.\n\t\t *\n\t\t * Unset the variable to protect against such problems.  We also reset\n\t\t * MAKELEVEL to be certain the child doesn't notice the make above us.\n\t\t */\n\t\tunsetenv(\"MAKEFLAGS\");\n\t\tunsetenv(\"MAKELEVEL\");\n\n\t\t/*\n\t\t * Adjust path variables to point into the temp-install tree\n\t\t */\n\t\ttmp = malloc(strlen(temp_install) + 32 + strlen(bindir));\n\t\tsprintf(tmp, \"%s/install/%s\", temp_install, bindir);\n\t\tbindir = tmp;\n\n\t\ttmp = malloc(strlen(temp_install) + 32 + strlen(libdir));\n\t\tsprintf(tmp, \"%s/install/%s\", temp_install, libdir);\n\t\tlibdir = tmp;\n\n\t\ttmp = malloc(strlen(temp_install) + 32 + strlen(datadir));\n\t\tsprintf(tmp, \"%s/install/%s\", temp_install, datadir);\n\t\tdatadir = tmp;\n\n\t\t/* psql will be installed into temp-install bindir */\n\t\tpsqldir = bindir;\n\n\t\t/*\n\t\t * Set up shared library paths to include the temp install.\n\t\t *\n\t\t * LD_LIBRARY_PATH covers many platforms.  DYLD_LIBRARY_PATH works on\n\t\t * Darwin, and maybe other Mach-based systems.\tLIBPATH is for AIX.\n\t\t * Windows needs shared libraries in PATH (only those linked into\n\t\t * executables, not dlopen'ed ones). Feel free to account for others\n\t\t * as well.\n\t\t */\n\t\tadd_to_path(\"LD_LIBRARY_PATH\", ':', libdir);\n\t\tadd_to_path(\"DYLD_LIBRARY_PATH\", ':', libdir);\n\t\tadd_to_path(\"LIBPATH\", ':', libdir);\n#if defined(WIN32)\n\t\tadd_to_path(\"PATH\", ';', libdir);\n#elif defined(__CYGWIN__)\n\t\tadd_to_path(\"PATH\", ':', libdir);\n#endif\n\t}\n\telse\n\t{\n\t\tconst char *pghost;\n\t\tconst char *pgport;\n\n\t\t/*\n\t\t * When testing an existing install, we honor existing environment\n\t\t * variables, except if they're overridden by command line options.\n\t\t */\n\t\tif (hostname != NULL)\n\t\t{\n\t\t\tdoputenv(\"PGHOST\", hostname);\n\t\t\tunsetenv(\"PGHOSTADDR\");\n\t\t}\n\t\tif (port != -1)\n\t\t{\n\t\t\tchar\t\ts[16];\n\n\t\t\tsprintf(s, \"%d\", port);\n\t\t\tdoputenv(\"PGPORT\", s);\n\t\t}\n\t\tif (user != NULL)\n\t\t\tdoputenv(\"PGUSER\", user);\n\n\t\t/*\n\t\t * Report what we're connecting to\n\t\t */\n\t\tpghost = getenv(\"PGHOST\");\n\t\tpgport = getenv(\"PGPORT\");\n#ifndef HAVE_UNIX_SOCKETS\n\t\tif (!pghost)\n\t\t\tpghost = \"localhost\";\n#endif\n\n\t\tif (pghost && pgport)\n\t\t\tprintf(_(\"(using postmaster on %s, port %s)\\n\"), pghost, pgport);\n\t\tif (pghost && !pgport)\n\t\t\tprintf(_(\"(using postmaster on %s, default port)\\n\"), pghost);\n\t\tif (!pghost && pgport)\n\t\t\tprintf(_(\"(using postmaster on Unix socket, port %s)\\n\"), pgport);\n\t\tif (!pghost && !pgport)\n\t\t\tprintf(_(\"(using postmaster on Unix socket, default port)\\n\"));\n\t}\n\n\tconvert_sourcefiles();\n\tload_resultmap();\n}\n\n/*\n * Issue a command via psql, connecting to the specified database\n *\n * Since we use system(), this doesn't return until the operation finishes\n */\nstatic void\npsql_command(const char *database, const char *query,...)\n{\n\tchar\t\tquery_formatted[1024];\n\tchar\t\tquery_escaped[2048];\n\tchar\t\tpsql_cmd[MAXPGPATH + 2048];\n\tva_list\t\targs;\n\tchar\t   *s;\n\tchar\t   *d;\n\n\t/* Generate the query with insertion of sprintf arguments */\n\tva_start(args, query);\n\tvsnprintf(query_formatted, sizeof(query_formatted), query, args);\n\tva_end(args);\n\n\t/* Now escape any shell double-quote metacharacters */\n\td = query_escaped;\n\tfor (s = query_formatted; *s; s++)\n\t{\n\t\tif (strchr(\"\\\\\\\"$`\", *s))\n\t\t\t*d++ = '\\\\';\n\t\t*d++ = *s;\n\t}\n\t*d = '\\0';\n\n\t/* And now we can build and execute the shell command */\n\tsnprintf(psql_cmd, sizeof(psql_cmd),\n\t\t\t SYSTEMQUOTE \"\\\"%s%spsql\\\" -X -c \\\"%s\\\" \\\"%s\\\"\" SYSTEMQUOTE,\n\t\t\t psqldir ? psqldir : \"\",\n\t\t\t psqldir ? \"/\" : \"\",\n\t\t\t query_escaped,\n\t\t\t database);\n\n\tif (system(psql_cmd) != 0)\n\t{\n\t\t/* psql probably already reported the error */\n\t\tfprintf(stderr, _(\"command failed: %s\\n\"), psql_cmd);\n\t\texit_nicely(2);\n\t}\n}\n\n/*\n * Spawn a process to execute the given shell command; don't wait for it\n *\n * Returns the process ID (or HANDLE) so we can wait for it later\n */\nPID_TYPE\nspawn_process(const char *cmdline)\n{\n#ifndef WIN32\n\tpid_t\t\tpid;\n\n\t/*\n\t * Must flush I/O buffers before fork.\tIdeally we'd use fflush(NULL) here\n\t * ... does anyone still care about systems where that doesn't work?\n\t */\n\tfflush(stdout);\n\tfflush(stderr);\n\tif (logfile)\n\t\tfflush(logfile);\n\n\tpid = fork();\n\tif (pid == -1)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not fork: %s\\n\"),\n\t\t\t\tprogname, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\tif (pid == 0)\n\t{\n\t\t/*\n\t\t * In child\n\t\t *\n\t\t * Instead of using system(), exec the shell directly, and tell it to\n\t\t * \"exec\" the command too.\tThis saves two useless processes per\n\t\t * parallel test case.\n\t\t */\n\t\tchar\t   *cmdline2 = malloc(strlen(cmdline) + 6);\n\n\t\tsprintf(cmdline2, \"exec %s\", cmdline);\n\t\texecl(shellprog, shellprog, \"-c\", cmdline2, (char *) NULL);\n\t\tfprintf(stderr, _(\"%s: could not exec \\\"%s\\\": %s\\n\"),\n\t\t\t\tprogname, shellprog, strerror(errno));\n\t\texit(1);\t\t\t\t/* not exit_nicely here... */\n\t}\n\t/* in parent */\n\treturn pid;\n#else\n\tchar\t   *cmdline2;\n\tBOOL\t\tb;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tHANDLE\t\torigToken;\n\tHANDLE\t\trestrictedToken;\n\tSID_IDENTIFIER_AUTHORITY NtAuthority = {SECURITY_NT_AUTHORITY};\n\tSID_AND_ATTRIBUTES dropSids[2];\n\t__CreateRestrictedToken _CreateRestrictedToken = NULL;\n\tHANDLE\t\tAdvapi32Handle;\n\n\tZeroMemory(&si, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tAdvapi32Handle = LoadLibrary(\"ADVAPI32.DLL\");\n\tif (Advapi32Handle != NULL)\n\t{\n\t\t_CreateRestrictedToken = (__CreateRestrictedToken) GetProcAddress(Advapi32Handle, \"CreateRestrictedToken\");\n\t}\n\n\tif (_CreateRestrictedToken == NULL)\n\t{\n\t\tif (Advapi32Handle != NULL)\n\t\t\tFreeLibrary(Advapi32Handle);\n\t\tfprintf(stderr, _(\"%s: cannot create restricted tokens on this platform\\n\"),\n\t\t\t\tprogname);\n\t\texit_nicely(2);\n\t}\n\n\t/* Open the current token to use as base for the restricted one */\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &origToken))\n\t{\n\t\tfprintf(stderr, _(\"could not open process token: %lu\\n\"),\n\t\t\t\tGetLastError());\n\t\texit_nicely(2);\n\t}\n\n\t/* Allocate list of SIDs to remove */\n\tZeroMemory(&dropSids, sizeof(dropSids));\n\tif (!AllocateAndInitializeSid(&NtAuthority, 2,\n\t\t\t\t\t\t\t\t  SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &dropSids[0].Sid) ||\n\t\t!AllocateAndInitializeSid(&NtAuthority, 2,\n\t\t\t\t\t\t\t\t  SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &dropSids[1].Sid))\n\t{\n\t\tfprintf(stderr, _(\"could not allocate SIDs: %lu\\n\"), GetLastError());\n\t\texit_nicely(2);\n\t}\n\n\tb = _CreateRestrictedToken(origToken,\n\t\t\t\t\t\t\t   DISABLE_MAX_PRIVILEGE,\n\t\t\t\t\t\t\t   sizeof(dropSids) / sizeof(dropSids[0]),\n\t\t\t\t\t\t\t   dropSids,\n\t\t\t\t\t\t\t   0, NULL,\n\t\t\t\t\t\t\t   0, NULL,\n\t\t\t\t\t\t\t   &restrictedToken);\n\n\tFreeSid(dropSids[1].Sid);\n\tFreeSid(dropSids[0].Sid);\n\tCloseHandle(origToken);\n\tFreeLibrary(Advapi32Handle);\n\n\tif (!b)\n\t{\n\t\tfprintf(stderr, _(\"could not create restricted token: %lu\\n\"),\n\t\t\t\tGetLastError());\n\t\texit_nicely(2);\n\t}\n\n\tcmdline2 = malloc(strlen(cmdline) + 8);\n\tsprintf(cmdline2, \"cmd /c %s\", cmdline);\n\n#ifndef __CYGWIN__\n\tAddUserToTokenDacl(restrictedToken);\n#endif\n\n\tif (!CreateProcessAsUser(restrictedToken,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t cmdline2,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t TRUE,\n\t\t\t\t\t\t\t CREATE_SUSPENDED,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t &si,\n\t\t\t\t\t\t\t &pi))\n\t{\n\t\tfprintf(stderr, _(\"could not start process for \\\"%s\\\": %lu\\n\"),\n\t\t\t\tcmdline2, GetLastError());\n\t\texit_nicely(2);\n\t}\n\n\tfree(cmdline2);\n\n    ResumeThread(pi.hThread);\n\tCloseHandle(pi.hThread);\n\treturn pi.hProcess;\n#endif\n}\n\n/*\n * Count bytes in file\n */\nstatic long\nfile_size(const char *file)\n{\n\tlong\t\tr;\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, file, strerror(errno));\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tr = ftell(f);\n\tfclose(f);\n\treturn r;\n}\n\n/*\n * Count lines in file\n */\nstatic int\nfile_line_count(const char *file)\n{\n\tint\t\t\tc;\n\tint\t\t\tl = 0;\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, file, strerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((c = fgetc(f)) != EOF)\n\t{\n\t\tif (c == '\\n')\n\t\t\tl++;\n\t}\n\tfclose(f);\n\treturn l;\n}\n\nbool\nfile_exists(const char *file)\n{\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t\treturn false;\n\tfclose(f);\n\treturn true;\n}\n\nstatic bool\ndirectory_exists(const char *dir)\n{\n\tstruct stat st;\n\n\tif (stat(dir, &st) != 0)\n\t\treturn false;\n\tif (S_ISDIR(st.st_mode))\n\t\treturn true;\n\treturn false;\n}\n\n/* Create a directory */\nstatic void\nmake_directory(const char *dir)\n{\n\tif (mkdir(dir, S_IRWXU | S_IRWXG | S_IRWXO) < 0)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not create directory \\\"%s\\\": %s\\n\"),\n\t\t\t\tprogname, dir, strerror(errno));\n\t\texit_nicely(2);\n\t}\n}\n\n/*\n * In: filename.ext, Return: filename_i.ext, where 0 < i <= 9\n */\nstatic char *\nget_alternative_expectfile(const char *expectfile, int i)\n{\n\tchar\t   *last_dot;\n\tint\t\t\tssize = strlen(expectfile) + 2 + 1;\n\tchar\t   *tmp = (char *) malloc(ssize);\n\tchar\t   *s = (char *) malloc(ssize);\n\n\tstrcpy(tmp, expectfile);\n\tlast_dot = strrchr(tmp, '.');\n\tif (!last_dot)\n\t{\n\t\tfree(tmp);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\t*last_dot = '\\0';\n\tsnprintf(s, ssize, \"%s_%d.%s\", tmp, i, last_dot + 1);\n\tfree(tmp);\n\treturn s;\n}\n\n/*\n * Run a \"diff\" command and also check that it didn't crash\n */\nstatic int\nrun_diff(const char *cmd, const char *filename)\n{\n\tint\t\t\tr;\n\n\tr = system(cmd);\n\tif (!WIFEXITED(r) || WEXITSTATUS(r) > 1)\n\t{\n\t\tfprintf(stderr, _(\"diff command failed with status %d: %s\\n\"), r, cmd);\n\t\texit_nicely(2);\n\t}\n#ifdef WIN32\n\n\t/*\n\t * On WIN32, if the 'diff' command cannot be found, system() returns 1,\n\t * but produces nothing to stdout, so we check for that here.\n\t */\n\tif (WEXITSTATUS(r) == 1 && file_size(filename) <= 0)\n\t{\n\t\tfprintf(stderr, _(\"diff command not found: %s\\n\"), cmd);\n\t\texit_nicely(2);\n\t}\n#else\n\tUnusedArg(filename);\n#endif\n\n\treturn WEXITSTATUS(r);\n}\n\n/*\n * Check the actual result file for the given test against expected results\n *\n * Returns true if different (failure), false if correct match found.\n * In the true case, the diff is appended to the diffs file.\n */\nstatic bool\nresults_differ(const char *testname, const char *resultsfile, const char *default_expectfile)\n{\n\tchar\t\texpectfile[MAXPGPATH];\n\tchar\t\tdiff[MAXPGPATH];\n\tchar\t\tcmd[MAXPGPATH * 3];\n\tchar\t\tbest_expect_file[MAXPGPATH];\n    char        diff_opts[MAXPGPATH];\n    char        m_pretty_diff_opts[MAXPGPATH];\n\tFILE\t   *difffile;\n\tint\t\t\tbest_line_count;\n\tint\t\t\ti;\n\tint\t\t\tl;\n\tconst char *platform_expectfile;\n\n\t/*\n\t * We can pass either the resultsfile or the expectfile, they should have\n\t * the same type (filename.type) anyway.\n\t */\n\tplatform_expectfile = get_expectfile(testname, resultsfile);\n\n\tstrlcpy(expectfile, default_expectfile, sizeof(expectfile));\n\tif (platform_expectfile)\n\t{\n\t\t/*\n\t\t * Replace everything afer the last slash in expectfile with what the\n\t\t * platform_expectfile contains.\n\t\t */\n\t\tchar\t   *p = strrchr(expectfile, '/');\n\n\t\tif (p)\n\t\t\tstrcpy(++p, platform_expectfile);\n\t}\n\n\t/* Name to use for temporary diff file */\n\tsnprintf(diff, sizeof(diff), \"%s.diff\", resultsfile);\n    \n\t/* Add init file arguments if provided via commandline */\n\tif (initfile)\n\t{\n\t  snprintf(diff_opts, sizeof(diff_opts),\n\t\t\t   \"%s --gpd_init %s\", basic_diff_opts, initfile);\n\n\t  snprintf(m_pretty_diff_opts, sizeof(m_pretty_diff_opts),\n\t\t\t   \"%s --gpd_init %s\", pretty_diff_opts, initfile);\n\t}\n\telse\n\t{\n\t\tsnprintf(diff_opts, sizeof(diff_opts),\n\t\t\t   \"%s\", basic_diff_opts);\n\n\t\tsnprintf(m_pretty_diff_opts, sizeof(m_pretty_diff_opts),\n                 \"%s\", pretty_diff_opts);\n\t}\n\n\t/* OK, run the diff */\n\tsnprintf(cmd, sizeof(cmd),\n\t\t\t SYSTEMQUOTE \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\" SYSTEMQUOTE,\n\t\t\t gpdiffprog, diff_opts, expectfile, resultsfile, diff);\n\n\t/* Is the diff file empty? */\n\tif (run_diff(cmd, diff) == 0)\n\t{\n\t\tunlink(diff);\n\t\treturn false;\n\t}\n\n\t/* There may be secondary comparison files that match better */\n\tbest_line_count = file_line_count(diff);\n\tstrcpy(best_expect_file, expectfile);\n\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tchar\t   *alt_expectfile;\n\n\t\talt_expectfile = get_alternative_expectfile(expectfile, i);\n\t\tif (!file_exists(alt_expectfile))\n\t\t\tcontinue;\n\n\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t SYSTEMQUOTE \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\" SYSTEMQUOTE,\n\t\t\t\t gpdiffprog, diff_opts, alt_expectfile, resultsfile, diff);\n\n\t\tif (run_diff(cmd, diff) == 0)\n\t\t{\n\t\t\tunlink(diff);\n\t\t\treturn false;\n\t\t}\n\n\t\tl = file_line_count(diff);\n\t\tif (l < best_line_count)\n\t\t{\n\t\t\t/* This diff was a better match than the last one */\n\t\t\tbest_line_count = l;\n\t\t\tstrlcpy(best_expect_file, alt_expectfile, sizeof(best_expect_file));\n\t\t}\n\t\tfree(alt_expectfile);\n\t}\n\n\t/*\n\t * fall back on the canonical results file if we haven't tried it yet and\n\t * haven't found a complete match yet.\n\t */\n\n\tif (platform_expectfile)\n\t{\n\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t SYSTEMQUOTE \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\" SYSTEMQUOTE,\n\t\t\t\t gpdiffprog, diff_opts, default_expectfile, resultsfile, diff);\n\n\t\tif (run_diff(cmd, diff) == 0)\n\t\t{\n\t\t\t/* No diff = no changes = good */\n\t\t\tunlink(diff);\n\t\t\treturn false;\n\t\t}\n\n\t\tl = file_line_count(diff);\n\t\tif (l < best_line_count)\n\t\t{\n\t\t\t/* This diff was a better match than the last one */\n\t\t\tbest_line_count = l;\n\t\t\tstrlcpy(best_expect_file, default_expectfile, sizeof(best_expect_file));\n\t\t}\n\t}\n\n\t/*\n\t * Use the best comparison file to generate the \"pretty\" diff, which we\n\t * append to the diffs summary file.\n\t */\n\tsnprintf(cmd, sizeof(cmd),\n\t\t\t SYSTEMQUOTE \"%s %s \\\"%s\\\" \\\"%s\\\" >> \\\"%s\\\"\" SYSTEMQUOTE,\n\t\t\t gpdiffprog, m_pretty_diff_opts, best_expect_file, resultsfile, difffilename);\n\trun_diff(cmd, difffilename);\n\n\t/* And append a separator */\n\tdifffile = fopen(difffilename, \"a\");\n\tif (difffile)\n\t{\n\t\tfprintf(difffile,\n\t\t\t\t\"\\n======================================================================\\n\\n\");\n\t\tfclose(difffile);\n\t}\n\n\tunlink(diff);\n\treturn true;\n}\n\n/*\n * Wait for specified subprocesses to finish, and return their exit\n * statuses into statuses[]\n *\n * If names isn't NULL, print each subprocess's name as it finishes\n *\n * Note: it's OK to scribble on the pids array, but not on the names array\n */\nstatic void\nwait_for_tests(PID_TYPE *pids, int *statuses, char **names, struct timeval *end_times, int num_tests)\n{\n\tint\t\t\ttests_left;\n\tint\t\t\ti;\n\n#ifdef WIN32\n\tPID_TYPE   *active_pids = malloc(num_tests * sizeof(PID_TYPE));\n\n\tmemcpy(active_pids, pids, num_tests * sizeof(PID_TYPE));\n#endif\n\n\ttests_left = num_tests;\n\twhile (tests_left > 0)\n\t{\n\t\tPID_TYPE\tp;\n\n#ifndef WIN32\n\t\tint\t\t\texit_status;\n\n\t\tp = wait(&exit_status);\n\n\t\tif (p == INVALID_PID)\n\t\t{\n\t\t\tfprintf(stderr, _(\"failed to wait for subprocesses: %s\\n\"),\n\t\t\t\t\tstrerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n#else\n\t\tDWORD\t\texit_status;\n\t\tint\t\t\tr;\n\n\t\tr = WaitForMultipleObjects(tests_left, active_pids, FALSE, INFINITE);\n\t\tif (r < WAIT_OBJECT_0 || r >= WAIT_OBJECT_0 + tests_left)\n\t\t{\n\t\t\tfprintf(stderr, _(\"failed to wait for subprocesses: %lu\\n\"),\n\t\t\t\t\tGetLastError());\n\t\t\texit_nicely(2);\n\t\t}\n\t\tp = active_pids[r - WAIT_OBJECT_0];\n\t\t/* compact the active_pids array */\n\t\tactive_pids[r - WAIT_OBJECT_0] = active_pids[tests_left - 1];\n#endif   /* WIN32 */\n\n\t\tfor (i = 0; i < num_tests; i++)\n\t\t{\n\t\t\tif (p == pids[i])\n\t\t\t{\n#ifdef WIN32\n\t\t\t\tGetExitCodeProcess(pids[i], &exit_status);\n\t\t\t\tCloseHandle(pids[i]);\n#endif\n\t\t\t\tpids[i] = INVALID_PID;\n\t\t\t\tstatuses[i] = (int) exit_status;\n\t\t\t\tif (names)\n\t\t\t\t\tstatus(\" %s\", names[i]);\n\t\t\t\tif (end_times)\n\t\t\t\t\tgettimeofday(&end_times[i], NULL);\n\t\t\t\ttests_left--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WIN32\n\tfree(active_pids);\n#endif\n}\n\n/*\n * report nonzero exit code from a test process\n */\nstatic void\nlog_child_failure(int exitstatus)\n{\n\tif (WIFEXITED(exitstatus))\n\t\tstatus(_(\" (test process exited with exit code %d)\"),\n\t\t\t   WEXITSTATUS(exitstatus));\n\telse if (WIFSIGNALED(exitstatus))\n\t{\n#if defined(WIN32)\n\t\tstatus(_(\" (test process was terminated by exception 0x%X)\"),\n\t\t\t   WTERMSIG(exitstatus));\n#elif defined(HAVE_DECL_SYS_SIGLIST) && HAVE_DECL_SYS_SIGLIST\n\t\tstatus(_(\" (test process was terminated by signal %d: %s)\"),\n\t\t\t   WTERMSIG(exitstatus),\n\t\t\t   WTERMSIG(exitstatus) < NSIG ?\n\t\t\t   sys_siglist[WTERMSIG(exitstatus)] : \"(unknown))\");\n#else\n\t\tstatus(_(\" (test process was terminated by signal %d)\"),\n\t\t\t   WTERMSIG(exitstatus));\n#endif\n\t}\n\telse\n\t\tstatus(_(\" (test process exited with unrecognized status %d)\"),\n\t\t\t   exitstatus);\n}\n\n/*\n * Run all the tests specified in one schedule file\n */\nstatic void\nrun_schedule(const char *schedule, test_function tfunc)\n{\n#define MAX_PARALLEL_TESTS 100\n\tchar\t   *tests[MAX_PARALLEL_TESTS];\n\t_stringlist *resultfiles[MAX_PARALLEL_TESTS];\n\t_stringlist *expectfiles[MAX_PARALLEL_TESTS];\n\t_stringlist *tags[MAX_PARALLEL_TESTS];\n\tPID_TYPE\tpids[MAX_PARALLEL_TESTS];\n\tint\t\t\tstatuses[MAX_PARALLEL_TESTS];\n\tstruct timeval end_times[MAX_PARALLEL_TESTS];\n\t_stringlist *ignorelist = NULL;\n\tchar\t\tscbuf[1024];\n\tFILE\t   *scf;\n\tint\t\t\tline_num = 0;\n\n\tmemset(resultfiles, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(expectfiles, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(tags, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(end_times, 0, sizeof(struct timeval) * MAX_PARALLEL_TESTS);\n\n\tscf = fopen(schedule, \"r\");\n\tif (!scf)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, schedule, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\twhile (fgets(scbuf, sizeof(scbuf), scf))\n\t{\n\t\tchar\t   *test = NULL;\n\t\tchar\t   *c;\n\t\tint\t\t\tnum_tests;\n\t\tbool\t\tinword;\n\t\tint\t\t\ti;\n\t\tstruct timeval start_time;\n\n\t\tline_num++;\n\n\t\tfor (i = 0; i < MAX_PARALLEL_TESTS; i++)\n\t\t{\n\t\t\tif (resultfiles[i] == NULL)\n\t\t\t\tbreak;\n\t\t\tfree_stringlist(&resultfiles[i]);\n\t\t\tfree_stringlist(&expectfiles[i]);\n\t\t\tfree_stringlist(&tags[i]);\n\t\t}\n\n\t\t/* strip trailing whitespace, especially the newline */\n\t\ti = strlen(scbuf);\n\t\twhile (i > 0 && isspace((unsigned char) scbuf[i - 1]))\n\t\t\tscbuf[--i] = '\\0';\n\n\t\tif (scbuf[0] == '\\0' || scbuf[0] == '#')\n\t\t\tcontinue;\n\t\tif (strncmp(scbuf, \"test: \", 6) == 0)\n\t\t\ttest = scbuf + 6;\n\t\telse if (strncmp(scbuf, \"ignore: \", 8) == 0)\n\t\t{\n\t\t\tc = scbuf + 8;\n\t\t\twhile (*c && isspace((unsigned char) *c))\n\t\t\t\tc++;\n\t\t\tadd_stringlist_item(&ignorelist, c);\n\n\t\t\t/*\n\t\t\t * Note: ignore: lines do not run the test, they just say that\n\t\t\t * failure of this test when run later on is to be ignored. A bit\n\t\t\t * odd but that's how the shell-script version did it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, _(\"syntax error in schedule file \\\"%s\\\" line %d: %s\\n\"),\n\t\t\t\t\tschedule, line_num, scbuf);\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\tnum_tests = 0;\n\t\tinword = false;\n\t\tfor (c = test; *c; c++)\n\t\t{\n\t\t\tif (isspace((unsigned char) *c))\n\t\t\t{\n\t\t\t\t*c = '\\0';\n\t\t\t\tinword = false;\n\t\t\t}\n\t\t\telse if (!inword)\n\t\t\t{\n\t\t\t\tif (num_tests >= MAX_PARALLEL_TESTS)\n\t\t\t\t{\n\t\t\t\t\t/* can't print scbuf here, it's already been trashed */\n\t\t\t\t\tfprintf(stderr, _(\"too many parallel tests in schedule file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\tschedule, line_num);\n\t\t\t\t\texit_nicely(2);\n\t\t\t\t}\n\n\t\t\t\tif (num_tests - 1 >= 0 && should_exclude_test(tests[num_tests - 1]))\n\t\t\t\t\tnum_tests--;\n\n\t\t\t\ttests[num_tests] = c;\n\t\t\t\tnum_tests++;\n\t\t\t\tinword = true;\n\t\t\t}\n\t\t}\n\n\t\t/* The last test in the line needs to be checked for exclusion */\n\t\tif (num_tests - 1 >= 0 && should_exclude_test(tests[num_tests - 1]))\n\t\t{\n\t\t\tnum_tests--;\n\n\t\t\t/* All tests in this line are to be excluded, so go to the next line */\n\t\t\tif (num_tests == 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (num_tests == 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"syntax error in schedule file \\\"%s\\\" line %d: %s\\n\"),\n\t\t\t\t\tschedule, line_num, scbuf);\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\tgettimeofday(&start_time, NULL);\n\t\tif (num_tests == 1)\n\t\t{\n#ifdef TEST_EACH_SCRIPT_IN_ITS_OWN_DB\n\t\t    _stringlist *strList;\n            for (strList = dblist; strList; strList = strList->next)\n        \t    drop_database_if_exists(strList->str);\n            for (strList = dblist; strList; strList = strList->next)\n        \t\tcreate_database(strList->str);\n#endif\n\t\t\tstatus(_(\"test %-20s ... \"), tests[0]);\n\t\t\tpids[0] = (tfunc) (tests[0], &resultfiles[0], &expectfiles[0], &tags[0]);\n\t\t\twait_for_tests(pids, statuses, NULL, end_times, 1);\n\t\t\t/* status line is finished below */\n\t\t}\n\t\telse if (max_connections > 0 && max_connections < num_tests)\n\t\t{\n\t\t\tint\t\t\toldest = 0;\n\n\t\t\tstatus(_(\"parallel group (%d tests, in groups of %d): \"),\n\t\t\t\t   num_tests, max_connections);\n\t\t\tfor (i = 0; i < num_tests; i++)\n\t\t\t{\n\t\t\t\tif (i - oldest >= max_connections)\n\t\t\t\t{\n\t\t\t\t\twait_for_tests(pids + oldest, statuses + oldest,\n\t\t\t\t\t\t\t\t   tests + oldest, end_times + oldest, i - oldest);\n\t\t\t\t\toldest = i;\n\t\t\t\t}\n\t\t\t\tpids[i] = (tfunc) (tests[i], &resultfiles[i], &expectfiles[i], &tags[i]);\n\t\t\t}\n\t\t\twait_for_tests(pids + oldest, statuses + oldest,\n\t\t\t\t\t\t   tests + oldest, end_times + oldest, i - oldest);\n\t\t\tstatus_end();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus(_(\"parallel group (%d tests): \"), num_tests);\n\t\t\tfor (i = 0; i < num_tests; i++)\n\t\t\t{\n\t\t\t\tpids[i] = (tfunc) (tests[i], &resultfiles[i], &expectfiles[i], &tags[i]);\n\t\t\t}\n\t\t\twait_for_tests(pids, statuses, tests, end_times, num_tests);\n\t\t\tstatus_end();\n\t\t}\n\n\t\t/* Check results for all tests */\n\t\tfor (i = 0; i < num_tests; i++)\n\t\t{\n\t\t\t_stringlist *rl,\n\t\t\t\t\t   *el,\n\t\t\t\t\t   *tl;\n\t\t\tbool\t\tdiffer = false;\n\t\t\tdouble\t\tdiff_secs = 0, diff_elapse = 0;\n\t\t\tstruct timeval diff_start_time, diff_end_time;\n\n\t\t\tif (num_tests > 1)\n\t\t\t\tstatus(_(\"     %-20s ... \"), tests[i]);\n\n\t\t\tdiff_secs = end_times[i].tv_usec - start_time.tv_usec;\n\t\t\tdiff_secs /= 1000000;\n\t\t\tdiff_secs += end_times[i].tv_sec - start_time.tv_sec;\n\t\t\t/*\n\t\t\t * Advance over all three lists simultaneously.\n\t\t\t *\n\t\t\t * Compare resultfiles[j] with expectfiles[j] always. Tags are\n\t\t\t * optional but if there are tags, the tag list has the same\n\t\t\t * length as the other two lists.\n\t\t\t */\n\n\t\t\tgettimeofday(&diff_start_time, NULL);\n\t\t\tfor (rl = resultfiles[i], el = expectfiles[i], tl = tags[i];\n\t\t\t\t rl != NULL;\t/* rl and el have the same length */\n\t\t\t\t rl = rl->next, el = el->next)\n\t\t\t{\n\t\t\t\tbool\t\tnewdiff;\n\n\t\t\t\tif (tl)\n\t\t\t\t\ttl = tl->next;\t\t/* tl has the same lengt has rl and el\n\t\t\t\t\t\t\t\t\t\t * if it exists */\n\n\t\t\t\tnewdiff = results_differ(tests[i], rl->str, el->str);\n\t\t\t\tif (newdiff && tl)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%s \", tl->str);\n\t\t\t\t}\n\t\t\t\tdiffer |= newdiff;\n\t\t\t}\n\t\t\tgettimeofday(&diff_end_time, NULL);\n\n\t\t\tdiff_elapse = diff_end_time.tv_usec - diff_start_time.tv_usec;\n\t\t\tdiff_elapse /= 1000000;\n\t\t\tdiff_elapse += diff_end_time.tv_sec - diff_start_time.tv_sec;\n\n\t\t\tif (differ)\n\t\t\t{\n\t\t\t\tbool\t\tignore = false;\n\t\t\t\t_stringlist *sl;\n\n\t\t\t\tfor (sl = ignorelist; sl != NULL; sl = sl->next)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(tests[i], sl->str) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tignore = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ignore)\n\t\t\t\t{\n\t\t\t\t\tstatus(_(\"failed (ignored)\"));\n\t\t\t\t\tfail_ignore_count++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus(_(\"FAILED\"));\n    \t\t\t\tstatus(_(\" (%.2f sec)  (diff:%.2f sec)\"), diff_secs, diff_elapse);\n\t\t\t\t\tfail_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatus(_(\"ok\"));\n\t\t\t\tstatus(_(\" (%.2f sec)  (diff:%.2f sec)\"), diff_secs, diff_elapse);\n\t\t\t\tsuccess_count++;\n\t\t\t}\n\n\t\t\tif (statuses[i] != 0)\n\t\t\t\tlog_child_failure(statuses[i]);\n\n\t\t\tstatus_end();\n\t\t}\n\t}\n\n\tfclose(scf);\n}\n\n/*\n * Run a single test\n */\nstatic void\nrun_single_test(const char *test, test_function tfunc)\n{\n\tPID_TYPE\tpid;\n\tint\t\t\texit_status;\n\t_stringlist *resultfiles = NULL;\n\t_stringlist *expectfiles = NULL;\n\t_stringlist *tags = NULL;\n\t_stringlist *rl,\n\t\t\t   *el,\n\t\t\t   *tl;\n\tbool\t\tdiffer = false;\n\n\tstatus(_(\"test %-20s ... \"), test);\n\tpid = (tfunc) (test, &resultfiles, &expectfiles, &tags);\n\twait_for_tests(&pid, &exit_status, NULL, NULL, 1);\n\n\t/*\n\t * Advance over all three lists simultaneously.\n\t *\n\t * Compare resultfiles[j] with expectfiles[j] always. Tags are optional\n\t * but if there are tags, the tag list has the same length as the other\n\t * two lists.\n\t */\n\tfor (rl = resultfiles, el = expectfiles, tl = tags;\n\t\t rl != NULL;\t\t\t/* rl and el have the same length */\n\t\t rl = rl->next, el = el->next)\n\t{\n\t\tbool\t\tnewdiff;\n\n\t\tif (tl)\n\t\t\ttl = tl->next;\t\t/* tl has the same lengt has rl and el if it\n\t\t\t\t\t\t\t\t * exists */\n\n\t\tnewdiff = results_differ(test, rl->str, el->str);\n\t\tif (newdiff && tl)\n\t\t{\n\t\t\tprintf(\"%s \", tl->str);\n\t\t}\n\t\tdiffer |= newdiff;\n\t}\n\n\tif (differ)\n\t{\n\t\tstatus(_(\"FAILED\"));\n\t\tfail_count++;\n\t}\n\telse\n\t{\n\t\tstatus(_(\"ok\"));\n\t\tsuccess_count++;\n\t}\n\n\tif (exit_status != 0)\n\t\tlog_child_failure(exit_status);\n\n\tstatus_end();\n}\n\n/*\n * Find the other binaries that we need. Currently, gpdiff.pl and\n * gpstringsubs.pl.\n */\nstatic void\nfind_helper_programs(const char *argv0)\n{\n\tif (find_other_exec(argv0, \"gpdiff.pl\", NULL, gpdiffprog) != 0)\n\t{\n\t\tchar\t\tfull_path[MAXPGPATH];\n\n\t\tif (find_my_exec(argv0, full_path) < 0)\n\t\t\tstrlcpy(full_path, progname, sizeof(full_path));\n\n\t\tfprintf(stderr,\n\t\t\t\t_(\"The program \\\"gpdiff.pl\\\" is needed by %s \"\n\t\t\t\t  \"but was not found in the same directory as \\\"%s\\\".\\n\"),\n\t\t\t\tprogname, full_path);\n\t\texit(1);\n\t}\n\tif (find_other_exec(argv0, \"gpstringsubs.pl\", NULL, gpstringsubsprog) != 0)\n\t{\n\t\tchar\t\tfull_path[MAXPGPATH];\n\n\t\tif (find_my_exec(argv0, full_path) < 0)\n\t\t\tstrlcpy(full_path, progname, sizeof(full_path));\n\n\t\tfprintf(stderr,\n\t\t\t\t_(\"The program \\\"gpstringsubs.pl\\\" is needed by %s \"\n\t\t\t\t  \"but was not found in the same directory as \\\"%s\\\".\\n\"),\n\t\t\t\tprogname, full_path);\n\t\texit(1);\n\t}\n}\n/*\n * Create the summary-output files (making them empty if already existing)\n */\nstatic void\nopen_result_files(void)\n{\n\tchar\t\tfile[MAXPGPATH];\n\tFILE\t   *difffile;\n\n\t/* create the log file (copy of running status output) */\n\tsnprintf(file, sizeof(file), \"%s/regression.out\", outputdir);\n\tlogfilename = strdup(file);\n\tlogfile = fopen(logfilename, \"w\");\n\tif (!logfile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, logfilename, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\t/* create the diffs file as empty */\n\tsnprintf(file, sizeof(file), \"%s/regression.diffs\", outputdir);\n\tdifffilename = strdup(file);\n\tdifffile = fopen(difffilename, \"w\");\n\tif (!difffile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, difffilename, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\t/* we don't keep the diffs file open continuously */\n\tfclose(difffile);\n\n\t/* also create the output directory if not present */\n\tsnprintf(file, sizeof(file), \"%s/results\", outputdir);\n\tif (!directory_exists(file))\n\t\tmake_directory(file);\n}\n\nstatic void\ndrop_database_if_exists(const char *dbname)\n{\n\theader(_(\"dropping database \\\"%s\\\"\"), dbname);\n\tpsql_command(\"postgres\", \"DROP DATABASE IF EXISTS \\\"%s\\\"\", dbname);\n}\n\nstatic void\ncreate_database(const char *dbname)\n{\n\t_stringlist *sl;\n\n\t/*\n\t * We use template0 so that any installation-local cruft in template1 will\n\t * not mess up the tests.\n\t */\n\theader(_(\"creating database \\\"%s\\\"\"), dbname);\n\tif (encoding && strlen(encoding) > 0)\n\t\tpsql_command(\"postgres\", \"CREATE DATABASE \\\"%s\\\" TEMPLATE=template0 ENCODING='%s'\", dbname, encoding);\n\telse\n\t\tpsql_command(\"postgres\", \"CREATE DATABASE \\\"%s\\\" TEMPLATE=template0\", dbname);\n\tpsql_command(dbname,\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_messages TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_monetary TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_numeric TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_time TO 'C';\"\n\t\t\t\"ALTER DATABASE \\\"%s\\\" SET timezone_abbreviations TO 'Default';\",\n\t\t\t\t dbname, dbname, dbname, dbname, dbname);\n\n\t/*\n\t * Install any requested procedural languages\n\t */\n\tfor (sl = loadlanguage; sl != NULL; sl = sl->next)\n\t{\n\t\theader(_(\"installing %s\"), sl->str);\n\t\tpsql_command(dbname, \"CREATE LANGUAGE \\\"%s\\\"\", sl->str);\n\t}\n}\n\nstatic void\ndrop_role_if_exists(const char *rolename)\n{\n\theader(_(\"dropping role \\\"%s\\\"\"), rolename);\n\tpsql_command(\"postgres\", \"DROP ROLE IF EXISTS \\\"%s\\\"\", rolename);\n}\n\nstatic void\ncreate_role(const char *rolename, const _stringlist * granted_dbs)\n{\n\theader(_(\"creating role \\\"%s\\\"\"), rolename);\n\tpsql_command(\"postgres\", \"CREATE ROLE \\\"%s\\\" WITH LOGIN\", rolename);\n\tfor (; granted_dbs != NULL; granted_dbs = granted_dbs->next)\n\t{\n\t\tpsql_command(\"postgres\", \"GRANT ALL ON DATABASE \\\"%s\\\" TO \\\"%s\\\"\",\n\t\t\t\t\t granted_dbs->str, rolename);\n\t}\n}\n\nstatic char *\nmake_absolute_path(const char *in)\n{\n\tchar\t   *result;\n\n\tif (is_absolute_path(in))\n\t\tresult = strdup(in);\n\telse\n\t{\n\t\tstatic char cwdbuf[MAXPGPATH];\n\n\t\tif (!cwdbuf[0])\n\t\t{\n\t\t\tif (!getcwd(cwdbuf, sizeof(cwdbuf)))\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"could not get current working directory: %s\\n\"), strerror(errno));\n\t\t\t\texit_nicely(2);\n\t\t\t}\n\t\t}\n\n\t\tresult = malloc(strlen(cwdbuf) + strlen(in) + 2);\n\t\tsprintf(result, \"%s/%s\", cwdbuf, in);\n\t}\n\n\tcanonicalize_path(result);\n\treturn result;\n}\n\nstatic char *\ntrim_white_space(char *str)\n{\n\tchar *end;\n\twhile (isspace((unsigned char)*str))\n\t{\n\t\tstr++;\n\t}\n\n\tif (*str == 0)\n\t{\n\t\treturn str;\n\t}\n\n\tend = str + strlen(str) - 1;\n\twhile (end > str && isspace((unsigned char)*end))\n\t{\n\t\tend--;\n\t}\n\n\t*(end+1) = 0;\n\treturn str;\n}\n\n/*\n * Should the test be excluded from running\n */\nstatic bool\nshould_exclude_test(char *test)\n{\n\t_stringlist *sl;\n\tfor (sl = exclude_tests; sl != NULL; sl = sl->next)\n\t{\n\t\tif (strcmp(test, sl->str) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * @brief Check whether a feature (e.g. optimizer) is on or off.\n * If the input feature is optimizer, then set the global\n * variable \"optimizer_enabled\" accordingly.\n *\n * @param feature_name Name of the feature to be checked (e.g. optimizer)\n * @param feature_value Expected value when the feature is enabled (i.e., on or group)\n * @param on_msg Message to be printed when the feature is enabled\n * @param off_msg Message to be printed when the feature is disabled\n * @return true if the feature is enabled; false otherwise\n */\nstatic bool\ncheck_feature_status(const char *feature_name, const char *feature_value,\n\t\t\t\t\t const char *on_msg, const char *off_msg)\n{\n\tchar psql_cmd[MAXPGPATH];\n\tchar statusfilename[MAXPGPATH];\n\tchar line[1024];\n\tbool isEnabled = false;\n\tint len;\n\n\theader(_(\"checking %s status\"), feature_name);\n\n\tsnprintf(statusfilename, sizeof(statusfilename), SYSTEMQUOTE \"%s/%s_status.out\" SYSTEMQUOTE, outputdir, feature_name);\n\n\tlen = snprintf(psql_cmd, sizeof(psql_cmd),\n\t\t\tSYSTEMQUOTE \"\\\"%s%spsql\\\" -X -t -c \\\"show %s;\\\" -o \\\"%s\\\" -d \\\"postgres\\\"\" SYSTEMQUOTE,\n\t\t\tpsqldir ? psqldir : \"\",\n\t\t\tpsqldir ? \"/\" : \"\",\n\t\t\tfeature_name,\n\t\t\tstatusfilename);\n\n\tif (len >= sizeof(psql_cmd))\n\t\texit_nicely(2);\n\n\tif (system(psql_cmd) != 0)\n\t\texit_nicely(2);\n\n\tFILE *statusfile = fopen(statusfilename, \"r\");\n\tif (!statusfile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, statusfilename, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\twhile (fgets(line, sizeof(line), statusfile))\n\t{\n\t\tchar *trimmed = trim_white_space(line);\n\t\tif (strcmp(trimmed, feature_value) == 0)\n\t\t{\n\t\t\tstatus(_(\"%s\"), on_msg);\n\t\t\tisEnabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!isEnabled)\n\t\tstatus(_(\"%s\"), off_msg);\n\n\tstatus_end();\n\tfclose(statusfile);\n\tunlink(statusfilename);\n\treturn isEnabled;\n}\n\nstatic void\nhelp(void)\n{\n\tprintf(_(\"PostgreSQL regression test driver\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Usage: %s [options...] [extra tests...]\\n\"), progname);\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options:\\n\"));\n\tprintf(_(\"  --dbname=DB               use database DB (default \\\"regression\\\")\\n\"));\n\tprintf(_(\"  --debug                   turn on debug mode in programs that are run\\n\"));\n\tprintf(_(\"  --inputdir=DIR            take input files from DIR (default \\\".\\\")\\n\"));\n\tprintf(_(\"  --load-language=lang      load the named language before running the\\n\"));\n\tprintf(_(\"                            tests; can appear multiple times\\n\"));\n\tprintf(_(\"  --create-role=ROLE        create the specified role before testing\\n\"));\n\tprintf(_(\"  --max-connections=N       maximum number of concurrent connections\\n\"));\n\tprintf(_(\"                            (default is 0 meaning unlimited)\\n\"));\n\tprintf(_(\"  --multibyte=ENCODING      use ENCODING as the multibyte encoding\\n\"));\n\tprintf(_(\"  --outputdir=DIR           place output files in DIR (default \\\".\\\")\\n\"));\n\tprintf(_(\"  --schedule=FILE           use test ordering schedule from FILE\\n\"));\n\tprintf(_(\"                            (can be used multiple times to concatenate)\\n\"));\n\tprintf(_(\"  --exclude-tests=TEST      command or space delimited tests to exclude from running\\n\"));\n\tprintf(_(\"  --srcdir=DIR              absolute path to source directory (for VPATH builds)\\n\"));\n\tprintf(_(\"  --temp-install=DIR        create a temporary installation in DIR\\n\"));\n    printf(_(\" --init-file=GPD_INIT_FILE  init file to be used for gpdiff\\n\"));\n\tprintf(_(\"  --ao-dir=DIR              directory name prefix containing generic\\n\"));\n\tprintf(_(\"                            UAO row and column tests\\n\"));\n\tprintf(_(\"  --resgroup-dir=DIR        directory name prefix containing resgroup tests\\n\"));\n\tprintf(_(\"  --use-existing            use an existing installation\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options for \\\"temp-install\\\" mode:\\n\"));\n\tprintf(_(\"  --no-locale               use C locale\\n\"));\n\tprintf(_(\"  --top-builddir=DIR        (relative) path to top level build directory\\n\"));\n\tprintf(_(\"  --temp-port=PORT          port number to start temp postmaster on\\n\"));\n\tprintf(_(\"  --temp-config=PATH        append contents of PATH to temporary config\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options for using an existing installation:\\n\"));\n\tprintf(_(\"  --host=HOST               use postmaster running on HOST\\n\"));\n\tprintf(_(\"  --port=PORT               use postmaster running at PORT\\n\"));\n\tprintf(_(\"  --user=USER               connect as USER\\n\"));\n\tprintf(_(\"  --psqldir=DIR             use psql in DIR (default: find in PATH)\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"The exit status is 0 if all tests passed, 1 if some tests failed, and 2\\n\"));\n\tprintf(_(\"if the tests could not be run for some reason.\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Report bugs to <bugs@greenplum.org>.\\n\"));\n}\n\nint\nregression_main(int argc, char *argv[], init_function ifunc, test_function tfunc)\n{\n\t_stringlist *sl;\n\tint\t\t\tc;\n\tint\t\t\ti;\n\tint\t\t\toption_index;\n\tchar\t\tbuf[MAXPGPATH * 4];\n\n\tstatic struct option long_options[] = {\n\t\t{\"help\", no_argument, NULL, 'h'},\n\t\t{\"version\", no_argument, NULL, 'V'},\n\t\t{\"dbname\", required_argument, NULL, 1},\n\t\t{\"debug\", no_argument, NULL, 2},\n\t\t{\"inputdir\", required_argument, NULL, 3},\n\t\t{\"load-language\", required_argument, NULL, 4},\n\t\t{\"max-connections\", required_argument, NULL, 5},\n\t\t{\"multibyte\", required_argument, NULL, 6},\n\t\t{\"outputdir\", required_argument, NULL, 7},\n\t\t{\"schedule\", required_argument, NULL, 8},\n\t\t{\"temp-install\", required_argument, NULL, 9},\n\t\t{\"no-locale\", no_argument, NULL, 10},\n\t\t{\"top-builddir\", required_argument, NULL, 11},\n\t\t{\"temp-port\", required_argument, NULL, 12},\n\t\t{\"host\", required_argument, NULL, 13},\n\t\t{\"port\", required_argument, NULL, 14},\n\t\t{\"user\", required_argument, NULL, 15},\n\t\t{\"psqldir\", required_argument, NULL, 16},\n\t\t{\"srcdir\", required_argument, NULL, 17},\n\t\t{\"create-role\", required_argument, NULL, 18},\n\t\t{\"temp-config\", required_argument, NULL, 19},\n        {\"init-file\", required_argument, NULL, 20},\n        {\"ao-dir\", required_argument, NULL, 21},\n        {\"resgroup-dir\", required_argument, NULL, 22},\n        {\"exclude-tests\", required_argument, NULL, 23},\n        {\"use-existing\", no_argument, NULL, 24},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\tprogname = get_progname(argv[0]);\n\tset_pglocale_pgservice(argv[0], PG_TEXTDOMAIN(\"pg_regress\"));\n\n#ifndef HAVE_UNIX_SOCKETS\n\t/* no unix domain sockets available, so change default */\n\thostname = \"localhost\";\n#endif\n\n\t/*\n\t * We call the initialization function here because that way we can set\n\t * default parameters and let them be overwritten by the commandline.\n\t */\n\tifunc();\n\n\twhile ((c = getopt_long(argc, argv, \"hV\", long_options, &option_index)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\tcase 'h':\n\t\t\t\thelp();\n\t\t\t\texit_nicely(0);\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\tputs(\"pg_regress (PostgreSQL) \" PG_VERSION);\n\t\t\t\texit_nicely(0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\n\t\t\t\t/*\n\t\t\t\t * If a default database was specified, we need to remove it\n\t\t\t\t * before we add the specified one.\n\t\t\t\t */\n\t\t\t\tfree_stringlist(&dblist);\n\t\t\t\tsplit_to_stringlist(strdup(optarg), \", \", &dblist);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tinputdir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tadd_stringlist_item(&loadlanguage, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tmax_connections = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tencoding = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\toutputdir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tadd_stringlist_item(&schedulelist, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\ttemp_install = make_absolute_path(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tnolocale = true;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\ttop_builddir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tp = atoi(optarg);\n\n\t\t\t\t\t/* Since Makefile isn't very bright, check port range */\n\t\t\t\t\tif (p >= 1024 && p <= 65535)\n\t\t\t\t\t\ttemp_port = p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\thostname = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\tport = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tuser = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\t/* \"--psqldir=\" should mean to use PATH */\n\t\t\t\tif (strlen(optarg))\n\t\t\t\t\tpsqldir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 17:\n\t\t\t\tsrcdir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 18:\n\t\t\t\tsplit_to_stringlist(strdup(optarg), \", \", &extraroles);\n\t\t\t\tbreak;\n\t\t\tcase 19:\n\t\t\t\ttemp_config = strdup(optarg);\n\t\t\t\tbreak;\n            case 20:\n                initfile = strdup(optarg);\n                break;\n            case 21:\n                aodir = strdup(optarg);\n                break;\n            case 22:\n                resgroupdir = strdup(optarg);\n                break;\n            case 23:\n                split_to_stringlist(strdup(optarg), \", \", &exclude_tests);\n                break;\n            case 24:\n                use_existing = true;\n                break;\n\t\t\tdefault:\n\t\t\t\t/* getopt_long already emitted a complaint */\n\t\t\t\tfprintf(stderr, _(\"\\nTry \\\"%s -h\\\" for more information.\\n\"),\n\t\t\t\t\t\tprogname);\n\t\t\t\texit_nicely(2);\n\t\t}\n\t}\n\n\t/*\n\t * if we still have arguments, they are extra tests to run\n\t */\n\twhile (argc - optind >= 1)\n\t{\n\t\tadd_stringlist_item(&extra_tests, argv[optind]);\n\t\toptind++;\n\t}\n\n\tif (temp_install)\n\t\tport = temp_port;\n\n\t/*\n\t * Initialization\n\t */\n\tfind_helper_programs(argv[0]);\n\topen_result_files();\n\n\tinitialize_environment();\n\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_CORE)\n\tunlimit_core_size();\n#endif\n\n\tif (temp_install)\n\t{\n\t\t/*\n\t\t * Prepare the temp installation\n\t\t */\n\t\tif (!top_builddir)\n\t\t{\n\t\t\tfprintf(stderr, _(\"--top-builddir must be specified when using --temp-install\\n\"));\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\tif (directory_exists(temp_install))\n\t\t{\n\t\t\theader(_(\"removing existing temp installation\"));\n\t\t\trmtree(temp_install, true);\n\t\t}\n\n\t\theader(_(\"creating temporary installation\"));\n\n\t\t/* make the temp install top directory */\n\t\tmake_directory(temp_install);\n\n\t\t/* and a directory for log files */\n\t\tsnprintf(buf, sizeof(buf), \"%s/log\", outputdir);\n\t\tif (!directory_exists(buf))\n\t\t\tmake_directory(buf);\n\n\t\t/* \"make install\" */\n#ifndef WIN32_ONLY_COMPILER\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"\\\"%s\\\" -C \\\"%s\\\" DESTDIR=\\\"%s/install\\\" install with_perl=no with_python=no > \\\"%s/log/install.log\\\" 2>&1\" SYSTEMQUOTE,\n\t\t\t\t makeprog, top_builddir, temp_install, outputdir);\n#else\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"perl \\\"%s/src/tools/msvc/install.pl\\\" \\\"%s/install\\\" >\\\"%s/log/install.log\\\" 2>&1\" SYSTEMQUOTE,\n\t\t\t\t top_builddir, temp_install, outputdir);\n#endif\n\t\tif (system(buf))\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: installation failed\\nExamine %s/log/install.log for the reason.\\nCommand was: %s\\n\"), progname, outputdir, buf);\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\t/* initdb */\n\t\theader(_(\"initializing database system\"));\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"\\\"%s/initdb\\\" -D \\\"%s/data\\\" -L \\\"%s\\\" --noclean%s%s > \\\"%s/log/initdb.log\\\" 2>&1\" SYSTEMQUOTE,\n\t\t\t\t bindir, temp_install, datadir,\n\t\t\t\t debug ? \" --debug\" : \"\",\n\t\t\t\t nolocale ? \" --no-locale\" : \"\",\n\t\t\t\t outputdir);\n\t\tif (system(buf))\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: initdb failed\\nExamine %s/log/initdb.log for the reason.\\nCommand was: %s\\n\"), progname, outputdir, buf);\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\t/* add any extra config specified to the postgresql.conf */\n\t\tif (temp_config != NULL)\n\t\t{\n\t\t\tFILE\t   *extra_conf;\n\t\t\tFILE\t   *pg_conf;\n\t\t\tchar\t\tline_buf[1024];\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%s/data/postgresql.conf\", temp_install);\n\t\t\tpg_conf = fopen(buf, \"a\");\n\t\t\tif (pg_conf == NULL)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not open %s for adding extra config:\\nError was %s\\n\"), progname, buf, strerror(errno));\n\t\t\t\texit_nicely(2);\n\t\t\t}\n\t\t\textra_conf = fopen(temp_config, \"r\");\n\t\t\tif (extra_conf == NULL)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not open %s to read extra config:\\nError was %s\\n\"), progname, temp_config, strerror(errno));\n\t\t\t\texit_nicely(2);\n\t\t\t}\n\t\t\twhile (fgets(line_buf, sizeof(line_buf), extra_conf) != NULL)\n\t\t\t\tfputs(line_buf, pg_conf);\n\t\t\tfclose(extra_conf);\n\t\t\tfclose(pg_conf);\n\t\t}\n\n\t\t/*\n\t\t * Start the temp postmaster\n\t\t */\n\t\theader(_(\"starting postmaster\"));\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"\\\"%s/postgres\\\" -D \\\"%s/data\\\" -F%s -c \\\"listen_addresses=%s\\\" > \\\"%s/log/postmaster.log\\\" 2>&1\" SYSTEMQUOTE,\n\t\t\t\t bindir, temp_install,\n\t\t\t\t debug ? \" -d 5\" : \"\",\n\t\t\t\t hostname ? hostname : \"\",\n\t\t\t\t outputdir);\n\t\tpostmaster_pid = spawn_process(buf);\n\t\tif (postmaster_pid == INVALID_PID)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not spawn postmaster: %s\\n\"),\n\t\t\t\t\tprogname, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\t/*\n\t\t * Wait till postmaster is able to accept connections (normally only a\n\t\t * second or so, but Cygwin is reportedly *much* slower).  Don't wait\n\t\t * forever, however.\n\t\t */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t SYSTEMQUOTE \"\\\"%s/psql\\\" -X postgres <%s 2>%s\" SYSTEMQUOTE,\n\t\t\t\t bindir, DEVNULL, DEVNULL);\n\t\tfor (i = 0; i < 60; i++)\n\t\t{\n\t\t\t/* Done if psql succeeds */\n\t\t\tif (system(buf) == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Fail immediately if postmaster has exited\n\t\t\t */\n#ifndef WIN32\n\t\t\tif (kill(postmaster_pid, 0) != 0)\n#else\n\t\t\tif (WaitForSingleObject(postmaster_pid, 0) == WAIT_OBJECT_0)\n#endif\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: postmaster failed\\nExamine %s/log/postmaster.log for the reason\\n\"), progname, outputdir);\n\t\t\t\texit_nicely(2);\n\t\t\t}\n\n\t\t\tpg_usleep(1000000L);\n\t\t}\n\t\tif (i >= 60)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: postmaster did not respond within 60 seconds\\nExamine %s/log/postmaster.log for the reason\\n\"), progname, outputdir);\n\n\t\t\t/*\n\t\t\t * If we get here, the postmaster is probably wedged somewhere in\n\t\t\t * startup.  Try to kill it ungracefully rather than leaving a\n\t\t\t * stuck postmaster that might interfere with subsequent test\n\t\t\t * attempts.\n\t\t\t */\n#ifndef WIN32\n\t\t\tif (kill(postmaster_pid, SIGKILL) != 0 &&\n\t\t\t\terrno != ESRCH)\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not kill failed postmaster: %s\\n\"),\n\t\t\t\t\t\tprogname, strerror(errno));\n#else\n\t\t\tif (TerminateProcess(postmaster_pid, 255) == 0)\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not kill failed postmaster: %lu\\n\"),\n\t\t\t\t\t\tprogname, GetLastError());\n#endif\n\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\tpostmaster_running = true;\n\n\t\tprintf(_(\"running on port %d with pid %lu\\n\"),\n\t\t\t   temp_port, (unsigned long) postmaster_pid);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Using an existing installation, so may need to get rid of\n\t\t * pre-existing database(s) and role(s)\n\t\t */\n\t\tif (!use_existing)\n\t\t{\n\t\t\tfor (sl = dblist; sl; sl = sl->next)\n\t\t\t\tdrop_database_if_exists(sl->str);\n\t\t\tfor (sl = extraroles; sl; sl = sl->next)\n\t\t\t\tdrop_role_if_exists(sl->str);\n\t\t}\n\t}\n\n\t/*\n\t * Create the test database(s) and role(s)\n\t */\n\tif (!use_existing)\n\t{\n\t\tfor (sl = dblist; sl; sl = sl->next)\n\t\t\tcreate_database(sl->str);\n\t\tfor (sl = extraroles; sl; sl = sl->next)\n\t\t\tcreate_role(sl->str, dblist);\n\t}\n\n\t/*\n\t * Find out if optimizer is on or off\n\t */\n\toptimizer_enabled = check_feature_status(\"optimizer\", \"on\",\n\t\t\t\"Optimizer enabled. Using optimizer answer files whenever possible\",\n\t\t\t\"Optimizer disabled. Using planner answer files\");\n\n\t/*\n\t * Find out if gp_resource_manager is group or not\n\t */\n\tresgroup_enabled = check_feature_status(\"gp_resource_manager\", \"group\",\n\t\t\t\"Resource group enabled. Using resource group answer files whenever possible\",\n\t\t\t\"Resource group disabled. Using default answer files\");\n\n\t/*\n\t * Ready to run the tests\n\t */\n\theader(_(\"running regression test queries\"));\n\n\tfor (sl = schedulelist; sl != NULL; sl = sl->next)\n\t{\n\t\trun_schedule(sl->str, tfunc);\n\t}\n\n\tfor (sl = extra_tests; sl != NULL; sl = sl->next)\n\t{\n\t\trun_single_test(sl->str, tfunc);\n\t}\n\n\t/*\n\t * Shut down temp installation's postmaster\n\t */\n\tif (temp_install)\n\t{\n\t\theader(_(\"shutting down postmaster\"));\n\t\tstop_postmaster();\n\t}\n\n\tfclose(logfile);\n\n\t/*\n\t * Emit nice-looking summary message\n\t */\n\tif (fail_count == 0 && fail_ignore_count == 0)\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" All %d tests passed. \"),\n\t\t\t\t success_count);\n\telse if (fail_count == 0)\t/* fail_count=0, fail_ignore_count>0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests passed, %d failed test(s) ignored. \"),\n\t\t\t\t success_count,\n\t\t\t\t success_count + fail_ignore_count,\n\t\t\t\t fail_ignore_count);\n\telse if (fail_ignore_count == 0)\t/* fail_count>0 && fail_ignore_count=0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests failed. \"),\n\t\t\t\t fail_count,\n\t\t\t\t success_count + fail_count);\n\telse\n\t\t/* fail_count>0 && fail_ignore_count>0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests failed, %d of these failures ignored. \"),\n\t\t\t\t fail_count + fail_ignore_count,\n\t\t\t\t success_count + fail_count + fail_ignore_count,\n\t\t\t\t fail_ignore_count);\n\n\tputchar('\\n');\n\tfor (i = strlen(buf); i > 0; i--)\n\t\tputchar('=');\n\tprintf(\"\\n%s\\n\", buf);\n\tfor (i = strlen(buf); i > 0; i--)\n\t\tputchar('=');\n\tputchar('\\n');\n\tputchar('\\n');\n\n\tif (file_size(difffilename) > 0)\n\t{\n\t\tprintf(_(\"The differences that caused some tests to fail can be viewed in the\\n\"\n\t\t\t\t \"file \\\"%s\\\".  A copy of the test summary that you see\\n\"\n\t\t\t\t \"above is saved in the file \\\"%s\\\".\\n\\n\"),\n\t\t\t   difffilename, logfilename);\n\t}\n\telse\n\t{\n\t\tunlink(difffilename);\n\t\tunlink(logfilename);\n\t}\n\n\tif (fail_count != 0)\n\t\texit_nicely(1);\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/pg_upgrade/page.c": "/*\n *\tpage.c\n *\n *\tper-page conversion operations\n *\n *\tCopyright (c) 2010, PostgreSQL Global Development Group\n *\t$PostgreSQL: pgsql/contrib/pg_upgrade/page.c,v 1.5 2010/07/03 16:33:14 momjian Exp $\n */\n\n#include \"pg_upgrade.h\"\n\n#include \"storage/bufpage.h\"\n\n\n#ifdef PAGE_CONVERSION\n\n\nstatic const char *getPageVersion(migratorContext *ctx,\n\t\t\t   uint16 *version, const char *pathName);\nstatic pageCnvCtx *loadConverterPlugin(migratorContext *ctx,\n\t\t\t\t\tuint16 newPageVersion, uint16 oldPageVersion);\n\n\n/*\n * setupPageConverter()\n *\n *\tThis function determines the PageLayoutVersion of the old cluster and\n *\tthe PageLayoutVersion of the new cluster.  If the versions differ, this\n *\tfunction loads a converter plugin and returns a pointer to a pageCnvCtx\n *\tobject (in *result) that knows how to convert pages from the old format\n *\tto the new format.  If the versions are identical, this function just\n *\treturns a NULL pageCnvCtx pointer to indicate that page-by-page conversion\n *\tis not required.\n *\n *\tIf successful this function sets *result and returns NULL.  If an error\n *\toccurs, this function returns an error message in the form of an null-terminated\n *\tstring.\n */\nconst char *\nsetupPageConverter(migratorContext *ctx, pageCnvCtx **result)\n{\n\tuint16\t\toldPageVersion;\n\tuint16\t\tnewPageVersion;\n\tpageCnvCtx *converter;\n\tconst char *msg;\n\tchar\t\tdstName[MAXPGPATH];\n\tchar\t\tsrcName[MAXPGPATH];\n\n\tsnprintf(dstName, sizeof(dstName), \"%s/global/%u\", ctx->new.pgdata,\n\t\t\t ctx->new.pg_database_oid);\n\tsnprintf(srcName, sizeof(srcName), \"%s/global/%u\", ctx->old.pgdata,\n\t\t\t ctx->old.pg_database_oid);\n\n\tif ((msg = getPageVersion(ctx, &oldPageVersion, srcName)) != NULL)\n\t\treturn msg;\n\n\tif ((msg = getPageVersion(ctx, &newPageVersion, dstName)) != NULL)\n\t\treturn msg;\n\n\t/*\n\t * If the old cluster and new cluster use the same page layouts, then we\n\t * don't need a page converter.\n\t */\n\tif (newPageVersion == oldPageVersion)\n\t{\n\t\t*result = NULL;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * The clusters use differing page layouts, see if we can find a plugin\n\t * that knows how to convert from the old page layout to the new page\n\t * layout.\n\t */\n\n\tif ((converter = loadConverterPlugin(ctx, newPageVersion, oldPageVersion)) == NULL)\n\t\treturn \"can't find plugin to convert from old page layout to new page layout\";\n\telse\n\t{\n\t\t*result = converter;\n\t\treturn NULL;\n\t}\n}\n\n\n/*\n * getPageVersion()\n *\n *\tRetrieves the PageLayoutVersion for the given relation.\n *\n *\tReturns NULL on success (and stores the PageLayoutVersion at *version),\n *\tif an error occurs, this function returns an error message (in the form\n *\tof a null-terminated string).\n */\nstatic const char *\ngetPageVersion(migratorContext *ctx, uint16 *version, const char *pathName)\n{\n\tint\t\t\trelfd;\n\tPageHeaderData page;\n\tssize_t\t\tbytesRead;\n\n\tif ((relfd = open(pathName, O_RDONLY, 0)) < 0)\n\t\treturn \"can't open relation\";\n\n\tif ((bytesRead = read(relfd, &page, sizeof(page))) != sizeof(page))\n\t{\n\t\tclose(relfd);\n\t\treturn \"can't read page header\";\n\t}\n\n\t*version = PageGetPageLayoutVersion(&page);\n\n\tclose(relfd);\n\n\treturn NULL;\n}\n\n\n/*\n * loadConverterPlugin()\n *\n *\tThis function loads a page-converter plugin library and grabs a\n *\tpointer to each of the (interesting) functions provided by that\n *\tplugin.  The name of the plugin library is derived from the given\n *\tnewPageVersion and oldPageVersion.  If a plugin is found, this\n *\tfunction returns a pointer to a pageCnvCtx object (which will contain\n *\ta collection of plugin function pointers). If the required plugin\n *\tis not found, this function returns NULL.\n */\nstatic pageCnvCtx *\nloadConverterPlugin(migratorContext *ctx, uint16 newPageVersion, uint16 oldPageVersion)\n{\n\tchar\t\tpluginName[MAXPGPATH];\n\tvoid\t   *plugin;\n\n\t/*\n\t * Try to find a plugin that can convert pages of oldPageVersion into\n\t * pages of newPageVersion.  For example, if we oldPageVersion = 3 and\n\t * newPageVersion is 4, we search for a plugin named:\n\t * plugins/convertLayout_3_to_4.dll\n\t */\n\n\t/*\n\t * FIXME: we are searching for plugins relative to the current directory,\n\t * we should really search relative to our own executable instead.\n\t */\n\tsnprintf(pluginName, sizeof(pluginName), \"./plugins/convertLayout_%d_to_%d%s\",\n\t\t\t oldPageVersion, newPageVersion, DLSUFFIX);\n\n\tif ((plugin = pg_dlopen(pluginName)) == NULL)\n\t\treturn NULL;\n\telse\n\t{\n\t\tpageCnvCtx *result = (pageCnvCtx *) pg_malloc(ctx, sizeof(*result));\n\n\t\tresult->old.PageVersion = oldPageVersion;\n\t\tresult->new.PageVersion = newPageVersion;\n\n\t\tresult->startup = (pluginStartup) pg_dlsym(plugin, \"init\");\n\t\tresult->convertFile = (pluginConvertFile) pg_dlsym(plugin, \"convertFile\");\n\t\tresult->convertPage = (pluginConvertPage) pg_dlsym(plugin, \"convertPage\");\n\t\tresult->shutdown = (pluginShutdown) pg_dlsym(plugin, \"fini\");\n\t\tresult->pluginData = NULL;\n\n\t\t/*\n\t\t * If the plugin has exported an initializer, go ahead and invoke it.\n\t\t */\n\t\tif (result->startup)\n\t\t\tresult->startup(MIGRATOR_API_VERSION, &result->pluginVersion,\n\t\t\t\t\t\tnewPageVersion, oldPageVersion, &result->pluginData);\n\n\t\treturn result;\n\t}\n}\n\n\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/bin/gpfdist/regress/data/exttab1/nation.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/timezone/tznames/Europe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/port/dynloader/darwin.c",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/backend/utils/mb/conversion_procs/README.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/port/win32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/big5.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/sjis.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/big5.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/sjis.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/mb/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/regress/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/tinc/tincrepo/mpp/gpdb/lib/datagen/query_execution_db/compressed_data/mpp18457.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/gr-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/test-de.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-upper.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/de-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/koi8-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/test/locale/koi8-r/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/tools/backend/flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/src/tools/vagrant/pictures/gpdb_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/markdown/cloud/graphics/gcp-disk-rates.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/markdown/pxf/graphics/pxfarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/markdown/pxf/graphics/pxfreadwrite.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/book/master_middleman/source/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/best_practices/graphics/group-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/best_practices/graphics/block-mirrors-4x8.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/best_practices/graphics/spread-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/ref_guide/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/queryscreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/pg_admin_III_callout.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/resgroupmem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gptransfer-slow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/pg3_queryplan.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_dump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-pgadmin-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_hadoop.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/gptransfer-fast.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/admin_guide/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gp_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gptransfer-slow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/mirrorsegs.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gp_dump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/gptransfer-fast.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/spread-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/piv-opt.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/slice_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/sne_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/multi_switch_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/build_gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/mapreducejob.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/hardware_stack.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/gp_dump.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/resource_queues.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/partitions.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/group-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/highlevel_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/mirrorsegs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/standby_master.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/multi_nic_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/disk_raid.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/physical_storage.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/star_schema.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/gp_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/targeted_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/recovermatrix.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables_multinic.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/gangs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/rack_diagrams.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/mapred_flow.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/parallel_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/nonpar_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/gp_query_priority.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/monitor_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/load-xml.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpdb-doc/dita/graphics/source_files/memory.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/releng/images/logo-greenplum.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/extensions/gphdfs/src/test/data/decimal.pq",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/extensions/gphdfs/src/test/data/short.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/extensions/gphdfs/src/test/data/short.avro",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/extensions/gphdfs/src/test/data/alertlog.avro",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/extensions/gphdfs/regression/integrate/data/optional_parquet.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/info.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/exclamic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/Up.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/removico.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/completi.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/New.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/bannrbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/Thumbs.db",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/custicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/repairic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/insticon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpAux/client/install/src/windows/Binary/dlgbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/formatter_fixedwidth/data/fixedwidth_small_correct.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/pg_upgrade/test/upgrade-test-cluster-4.3.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/isn/isn.h",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/isn/isn.c",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/pgrowlocks/README.pgrowlocks.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/xlogdump/test/xlog.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/contrib/xlogdump/doc/xlogdump.1",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/doc/src/sgml/ref/create_type.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/doc/src/sgml/ref/drop_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/doc/src/sgml/ref/create_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpMgmt/demo/gppkg/sample-sources.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.23.0-tmxzfsf4z4rdd6227mbp3ayiifcs4nnx/spack-src/gpMgmt/test/behave/mgmt_utils/steps/data/sample.gppkg"
    ],
    "total_files": 13904
}