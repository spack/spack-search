{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/configure.in": "dnl Process this file with autoconf to produce a configure script.\ndnl configure.in\ndnl\ndnl Developers, please strive to achieve this order:\ndnl\ndnl 0. Initialization and options processing\ndnl 1. Programs\ndnl 2. Libraries\ndnl 3. Header files\ndnl 4. Types\ndnl 5. Structures\ndnl 6. Compiler characteristics\ndnl 7. Functions, global variables\ndnl 8. System services\ndnl\ndnl Read the Autoconf manual for details.\ndnl\nm4_pattern_forbid(^PGAC_)dnl to catch undefined macros\n\ndnl The PACKAGE_VERSION from upstream PostgreSQL is maintained in the\ndnl PG_PACKAGE_VERSION variable, when merging make sure to update this\ndnl variable with the merge conflict from the AC_INIT() statement.\nAC_INIT([Greenplum Database], [6.0.0-beta.1], [support@greenplum.org])\n[PG_PACKAGE_VERSION=9.4.24]\nAC_SUBST(PG_PACKAGE_VERSION)\n\ndnl m4_if(m4_defn([m4_PACKAGE_VERSION]), [2.69], [], [m4_fatal([Autoconf version 2.69 is required.\ndnl Untested combinations of 'autoconf' and PostgreSQL versions are not\ndnl recommended.  You can remove the check from 'configure.in' but it is then\ndnl your responsibility whether the result works or not.])])\nAC_COPYRIGHT([Copyright (c) 1996-2014, PostgreSQL Global Development Group])\nAC_CONFIG_SRCDIR([src/backend/access/common/heaptuple.c])\nAC_CONFIG_AUX_DIR(config)\nAC_PREFIX_DEFAULT(/usr/local/gpdb)\nAC_SUBST(configure_args, [$ac_configure_args])\n\n[PG_MAJORVERSION=`expr \"$PG_PACKAGE_VERSION\" : '\\([0-9][0-9]*\\.[0-9][0-9]*\\)'`]\nAC_SUBST(PG_MAJORVERSION)\nAC_DEFINE_UNQUOTED(PG_MAJORVERSION, \"$PG_MAJORVERSION\", [PostgreSQL major version as a string])\n\n[PG_VERSION=\"$PG_PACKAGE_VERSION\"]\nPGAC_ARG_REQ(with, extra-version, [STRING], [append STRING to version], [], [])\nAC_DEFINE_UNQUOTED(PG_VERSION, \"$PG_PACKAGE_VERSION\", [Postgres version Greenplum Database is based on])\n\nAC_CANONICAL_HOST\n\ntemplate=\nAC_MSG_CHECKING([which template to use])\n\nPGAC_ARG_REQ(with, template, [NAME], [override operating system template],\n[\n  case $withval in\n    list)   echo; ls \"$srcdir/src/template\"; exit;;\n    *)      if test -f \"$srcdir/src/template/$with_template\" ; then\n              template=$withval\n            else\n              AC_MSG_ERROR(['$withval' is not a valid template name. Use 'list' for a list.])\n            fi;;\n  esac\n],\n[\n# --with-template not given\n\ncase $host_os in\n     aix*) template=aix ;;\n  cygwin*) template=cygwin ;;\n  darwin*) template=darwin ;;\ndragonfly*) template=netbsd ;;\n freebsd*) template=freebsd ;;\n    hpux*) template=hpux ;;\n linux*|gnu*|k*bsd*-gnu)\n           template=linux ;;\n   mingw*) template=win32 ;;\n  netbsd*) template=netbsd ;;\n openbsd*) template=openbsd ;;\n     osf*) template=osf ;;\n     sco*) template=sco ;;\n solaris*) template=solaris ;;\n   sysv5*) template=unixware ;;\nesac\n\n  if test x\"$template\" = x\"\" ; then\n    AC_MSG_ERROR([[\n*******************************************************************\nPostgreSQL has apparently not been ported to your platform yet.\nTo try a manual configuration, look into the src/template directory\nfor a similar platform and use the '--with-template=' option.\n\nPlease also contact <bugs@greenplum.org> to see about\nrectifying this.  Include the above 'checking host system type...'\nline.\n*******************************************************************\n]])\n  fi\n\n])\n\nAC_MSG_RESULT([$template])\n\nPORTNAME=$template\nAC_SUBST(PORTNAME)\n\n# Initialize default assumption that we do not need separate assembly code\n# for TAS (test-and-set).  This can be overridden by the template file\n# when it's executed.\nneed_tas=no\ntas_file=dummy.s\n\n\n\n##\n## Command line options\n##\n\n#\n# Add non-standard directories to the include path\n#\nPGAC_ARG_REQ(with, includes, [DIRS], [look for additional header files in DIRS])\n\n\n#\n# Add non-standard directories to the library search path\n#\nPGAC_ARG_REQ(with, libraries, [DIRS], [look for additional libraries in DIRS],\n             [LIBRARY_DIRS=$withval])\n\nPGAC_ARG_REQ(with, libs,      [DIRS], [alternative spelling of --with-libraries],\n             [LIBRARY_DIRS=$withval])\n\n\n#\n# 64-bit integer date/time storage: enabled by default.\n#\nAC_MSG_CHECKING([whether to build with 64-bit integer date/time support])\nPGAC_ARG_BOOL(enable, integer-datetimes, yes, [disable 64-bit integer date/time support],\n              [AC_DEFINE([USE_INTEGER_DATETIMES], 1,\n                         [Define to 1 if you want 64-bit integer timestamp and interval support. (--enable-integer-datetimes)])])\nAC_MSG_RESULT([$enable_integer_datetimes])\n\n\n#\n# NLS\n#\n# NLS is not supported in Greenplum. There's no fundamental reason for it,\n# but no-one's kept the translations up-to-date. The .po files have been\n# removed from the repository, so it won't work if you just uncomment the\n# below block. If we wanted to enable NLS support, we should come up with a\n# scheme to use the upstream PostgreSQL .po files as is, to make merging\n# easier, and provide additional .po files for all the Greenplum-specific\n# strings.\n# to the users to let them build with very incomplete translations.\n#AC_MSG_CHECKING([whether NLS is wanted])\n#PGAC_ARG_OPTARG(enable, nls,\n#                [LANGUAGES], [enable Native Language Support],\n#                [],\n#                [WANTED_LANGUAGES=$enableval],\n#                [AC_DEFINE(ENABLE_NLS, 1,\n#                           [Define to 1 if you want National Language Support. (--enable-nls)])])\n#AC_MSG_RESULT([$enable_nls])\n#AC_SUBST(enable_nls)\n#AC_SUBST(WANTED_LANGUAGES)\n\n#\n# Default port number (--with-pgport), default 5432\n#\nAC_MSG_CHECKING([for default port number])\nPGAC_ARG_REQ(with, pgport, [PORTNUM], [set default port number [5432]],\n             [default_port=$withval],\n             [default_port=5432])\nAC_MSG_RESULT([$default_port])\n# Need both of these because some places want an integer and some a string\nAC_DEFINE_UNQUOTED(DEF_PGPORT, ${default_port},\n[Define to the default TCP port number on which the server listens and\nto which clients will try to connect.  This can be overridden at run-time,\nbut it's convenient if your clients have the right default compiled in.\n(--with-pgport=PORTNUM)])\nAC_DEFINE_UNQUOTED(DEF_PGPORT_STR, \"${default_port}\",\n                   [Define to the default TCP port number as a string constant.])\nAC_SUBST(default_port)\n\n#\n# '-rpath'-like feature can be disabled\n#\nPGAC_ARG_BOOL(enable, rpath, yes,\n              [do not embed shared library search path in executables])\nAC_SUBST(enable_rpath)\n\n#\n# Spinlocks\n#\nPGAC_ARG_BOOL(enable, spinlocks, yes,\n              [do not use spinlocks])\n\n#\n# Atomic operations\n#\nPGAC_ARG_BOOL(enable, atomics, yes,\n              [do not use atomic operations])\n\n#\n# gpfdist\n#\nPGAC_ARG_BOOL(enable, gpfdist, yes,\n             [do not use gpfdist])\nAC_SUBST(enable_gpfdist)\n\n#\n# pxf\n#\nPGAC_ARG_BOOL(enable, pxf, yes,\n             [do not build pxf])\nAC_SUBST(enable_pxf)\n\n#\n# include debug extensions in gpcontrib\n#\nPGAC_ARG_BOOL(enable, debug-extensions, no,\n              [include debug extensions in gpcontrib])\nAC_SUBST(enable_debug_extensions)\n\n#\n# orafce\n#\nPGAC_ARG_BOOL(enable, orafce, no,\n             [build with Oracle compatibility functions])\nAC_SUBST(enable_orafce)\n\n#\n# --enable-gpperfmon\n#\nPGAC_ARG_BOOL(enable, gpperfmon, no,\n              [build with gpperfmon])\nAC_SUBST(enable_gpperfmon)\n\n#\n# --enable-debug adds -g to compiler flags\n#\nPGAC_ARG_BOOL(enable, debug, no,\n              [build with debugging symbols (-g)])\nAC_SUBST(enable_debug)\n\n#\n# --enable-profiling enables gcc profiling\n#\nPGAC_ARG_BOOL(enable, profiling, no,\n              [build with profiling enabled ])\n\n#\n# --enable-coverage enables generation of code coverage metrics with gcov\n#\nPGAC_ARG_BOOL(enable, coverage, no,\n              [build with coverage testing instrumentation],\n[AC_CHECK_PROGS(GCOV, gcov)\nif test -z \"$GCOV\"; then\n  AC_MSG_ERROR([gcov not found])\nfi\nAC_CHECK_PROGS(LCOV, lcov)\nif test -z \"$LCOV\"; then\n  AC_MSG_ERROR([lcov not found])\nfi\nAC_CHECK_PROGS(GENHTML, genhtml)\nif test -z \"$GENHTML\"; then\n  AC_MSG_ERROR([genhtml not found])\nfi])\nAC_SUBST(enable_coverage)\n\n#\n# DTrace\n#\nPGAC_ARG_BOOL(enable, dtrace, no,\n              [build with DTrace support],\n[AC_CHECK_PROGS(DTRACE, dtrace)\nif test -z \"$DTRACE\"; then\n  AC_MSG_ERROR([dtrace not found])\nfi\nAC_SUBST(DTRACEFLAGS)])\nAC_SUBST(enable_dtrace)\n\n#\n# TAP tests\n#\nPGAC_ARG_BOOL(enable, tap-tests, no,\n              [enable TAP tests (requires Perl and IPC::Run)])\nAC_SUBST(enable_tap_tests)\n\n#\n# Block size\n#\nAC_MSG_CHECKING([for block size])\nPGAC_ARG_REQ(with, blocksize, [BLOCKSIZE], [set table block size in kB [8]],\n             [blocksize=$withval],\n             [blocksize=32])\ncase ${blocksize} in\n  1) BLCKSZ=1024;;\n  2) BLCKSZ=2048;;\n  4) BLCKSZ=4096;;\n  8) BLCKSZ=8192;;\n 16) BLCKSZ=16384;;\n 32) BLCKSZ=32768;;\n  *) AC_MSG_ERROR([Invalid block size. Allowed values are 1,2,4,8,16,32.])\nesac\nAC_MSG_RESULT([${blocksize}kB])\n\nAC_DEFINE_UNQUOTED([BLCKSZ], ${BLCKSZ}, [\n Size of a disk block --- this also limits the size of a tuple.  You\n can set it bigger if you need bigger tuples (although TOAST should\n reduce the need to have large tuples, since fields can be spread\n across multiple tuples).\n\n BLCKSZ must be a power of 2.  The maximum possible value of BLCKSZ\n is currently 2^15 (32768).  This is determined by the 15-bit widths\n of the lp_off and lp_len fields in ItemIdData (see\n include/storage/itemid.h).\n\n Changing BLCKSZ requires an initdb.\n])\n\n#\n# Relation segment size\n#\nAC_MSG_CHECKING([for segment size])\nPGAC_ARG_REQ(with, segsize, [SEGSIZE], [set table segment size in GB [1]],\n             [segsize=$withval],\n             [segsize=1])\n# this expression is set up to avoid unnecessary integer overflow\n# blocksize is already guaranteed to be a factor of 1024\nRELSEG_SIZE=`expr '(' 1024 / ${blocksize} ')' '*' ${segsize} '*' 1024`\ntest $? -eq 0 || exit 1\nAC_MSG_RESULT([${segsize}GB])\n\nAC_DEFINE_UNQUOTED([RELSEG_SIZE], ${RELSEG_SIZE}, [\n RELSEG_SIZE is the maximum number of blocks allowed in one disk file.\n Thus, the maximum size of a single file is RELSEG_SIZE * BLCKSZ;\n relations bigger than that are divided into multiple files.\n\n RELSEG_SIZE * BLCKSZ must be less than your OS' limit on file size.\n This is often 2 GB or 4GB in a 32-bit operating system, unless you\n have large file support enabled.  By default, we make the limit 1 GB\n to avoid any possible integer-overflow problems within the OS.\n A limit smaller than necessary only means we divide a large\n relation into more chunks than necessary, so it seems best to err\n in the direction of a small limit.\n\n A power-of-2 value is recommended to save a few cycles in md.c,\n but is not absolutely required.\n\n Changing RELSEG_SIZE requires an initdb.\n])\n\n#\n# WAL block size\n#\nAC_MSG_CHECKING([for WAL block size])\nPGAC_ARG_REQ(with, wal-blocksize, [BLOCKSIZE], [set WAL block size in kB [8]],\n             [wal_blocksize=$withval],\n             [wal_blocksize=32])\ncase ${wal_blocksize} in\n  1) XLOG_BLCKSZ=1024;;\n  2) XLOG_BLCKSZ=2048;;\n  4) XLOG_BLCKSZ=4096;;\n  8) XLOG_BLCKSZ=8192;;\n 16) XLOG_BLCKSZ=16384;;\n 32) XLOG_BLCKSZ=32768;;\n 64) XLOG_BLCKSZ=65536;;\n  *) AC_MSG_ERROR([Invalid WAL block size. Allowed values are 1,2,4,8,16,32,64.])\nesac\nAC_MSG_RESULT([${wal_blocksize}kB])\n\nAC_DEFINE_UNQUOTED([XLOG_BLCKSZ], ${XLOG_BLCKSZ}, [\n Size of a WAL file block.  This need have no particular relation to BLCKSZ.\n XLOG_BLCKSZ must be a power of 2, and if your system supports O_DIRECT I/O,\n XLOG_BLCKSZ must be a multiple of the alignment requirement for direct-I/O\n buffers, else direct I/O may fail.\n\n Changing XLOG_BLCKSZ requires an initdb.\n])\n\n#\n# WAL segment size\n#\nAC_MSG_CHECKING([for WAL segment size])\nPGAC_ARG_REQ(with, wal-segsize, [SEGSIZE], [set WAL segment size in MB [16]],\n             [wal_segsize=$withval],\n             [wal_segsize=64])\ncase ${wal_segsize} in\n  1) ;;\n  2) ;;\n  4) ;;\n  8) ;;\n 16) ;;\n 32) ;;\n 64) ;;\n  *) AC_MSG_ERROR([Invalid WAL segment size. Allowed values are 1,2,4,8,16,32,64.])\nesac\nAC_MSG_RESULT([${wal_segsize}MB])\n\nAC_DEFINE_UNQUOTED([XLOG_SEG_SIZE], [(${wal_segsize} * 1024 * 1024)], [\n XLOG_SEG_SIZE is the size of a single WAL file.  This must be a power of 2\n and larger than XLOG_BLCKSZ (preferably, a great deal larger than\n XLOG_BLCKSZ).\n\n Changing XLOG_SEG_SIZE requires an initdb.\n])\n\n#\n# C compiler\n#\n\n# For historical reasons you can also use --with-CC to specify the C compiler\n# to use, although the standard way to do this is to set the CC environment\n# variable.\nPGAC_ARG_REQ(with, CC, [CMD], [set compiler (deprecated)], [CC=$with_CC])\n\ncase $template in\n  aix) pgac_cc_list=\"gcc xlc\";;\n    *) pgac_cc_list=\"gcc cc\";;\nesac\n\nAC_PROG_CC([$pgac_cc_list])\n\n#\n# C++ compiler\n#\n#\n# AC_PROG_CXX will add \"-g -O2\" to CXXFLAGS, if CXXFLAGS was not already set.\n# We don't want that, because we derive CXXFLAGS from CFLAGS later on. Set\n# CXXFLAGS to an empty string explicitly before invoking AC_PROG_CXX, to\n# avoid that.\nac_save_CXXFLAGS=$CXXFLAGS\nCXXFLAGS=\"\"\nAC_PROG_CXX\nCXXFLAGS=$ac_save_CXXFLAGS\n\n# Check if it's Intel's compiler, which (usually) pretends to be gcc,\n# but has idiosyncrasies of its own.  We assume icc will define\n# __INTEL_COMPILER regardless of CFLAGS.\nAC_TRY_COMPILE([], [@%:@ifndef __INTEL_COMPILER\nchoke me\n@%:@endif], [ICC=[yes]], [ICC=[no]])\n\n# Check if it's Sun Studio compiler. We assume that\n# __SUNPRO_C will be defined for Sun Studio compilers\nAC_TRY_COMPILE([], [@%:@ifndef __SUNPRO_C\nchoke me\n@%:@endif], [SUN_STUDIO_CC=yes], [SUN_STUDIO_CC=no])\n\nAC_SUBST(SUN_STUDIO_CC)\n\nunset CFLAGS\n\n#\n# Read the template\n#\n. \"$srcdir/src/template/$template\" || exit\n\n# CFLAGS are selected so:\n# If the user specifies something in the environment, that is used.\n# else:  If the template file set something, that is used.\n# else:  If coverage was enabled, don't set anything.\n# else:  If the compiler is GCC, then we use -O3.\n# else:  If the compiler is something else, then we use -O, unless debugging.\n\nif test \"$ac_env_CFLAGS_set\" = set; then\n  CFLAGS=$ac_env_CFLAGS_value\nelif test \"${CFLAGS+set}\" = set; then\n  : # (keep what template set)\nelif test \"$enable_coverage\" = yes; then\n  : # no optimization by default\nelif test \"$GCC\" = yes; then\n  CFLAGS=\"-O3\"\nelse\n  # if the user selected debug mode, don't use -O\n  if test \"$enable_debug\" != yes; then\n    CFLAGS=\"-O\"\n  fi\nfi\n\n# For GPDB, Use C99, rather than C89, compile rules\n#\n#\nif test \"$GCC\" = yes; then\n  if test \"$ICC\" = yes; then\n    CFLAGS=\"$CFLAGS -c99 \"\n  else\n    CFLAGS=\"$CFLAGS -std=gnu99 \"\n  fi\nfi\n\n\n# Check for x86 cpuid instruction to determine if we can perform a\n# runtime check\nAC_CACHE_CHECK([for __get_cpuid], [pgac_cv__get_cpuid],\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <cpuid.h>],\n  [[unsigned int exx[4] = {0, 0, 0, 0};\n  __get_cpuid(1, &exx[0], &exx[1], &exx[2], &exx[3]);\n  ]])],\n  [pgac_cv__get_cpuid=\"yes\"],\n  [pgac_cv__get_cpuid=\"no\"])])\nif test x\"$pgac_cv__get_cpuid\" = x\"yes\"; then\n  AC_DEFINE(HAVE__GET_CPUID, 1, [Define to 1 if you have __get_cpuid.])\nfi\n\nAC_CACHE_CHECK([for __cpuid], [pgac_cv__cpuid],\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <intrin.h>],\n  [[unsigned int exx[4] = {0, 0, 0, 0};\n  __get_cpuid(exx[0], 1);\n  ]])],\n  [pgac_cv__cpuid=\"yes\"],\n  [pgac_cv__cpuid=\"no\"])])\nif test x\"$pgac_cv__cpuid\" = x\"yes\"; then\n  AC_DEFINE(HAVE__CPUID, 1, [Define to 1 if you have __cpuid.])\nfi\n\n# Check for Intel SSE 4.2 intrinsics to do CRC calculations.\n#\n# First check if the _mm_crc32_u8 and _mm_crc32_u64 intrinsics can be used\n# with the default compiler flags. If not, check if adding the -msse4.2\n# flag helps. CFLAGS_SSE42 is set to -msse4.2 if that's required.\nPGAC_SSE42_CRC32_INTRINSICS([])\nif test x\"$pgac_sse42_crc32_intrinsics\" != x\"yes\"; then\n  PGAC_SSE42_CRC32_INTRINSICS([-msse4.2])\nfi\nAC_SUBST(CFLAGS_SSE42)\n\n# Are we targeting a processor that supports SSE 4.2? gcc, clang and icc all\n# define __SSE4_2__ in that case.\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [\n#ifndef __SSE4_2__\n#error __SSE4_2__ not defined\n#endif\n])], [SSE4_2_TARGETED=1])\n\n# Select CRC-32C implementation.\n#\n# If we are targeting a processor that has SSE 4.2 instructions, we can use the\n# special CRC instructions for calculating CRC-32C. If we're not targeting such\n# a processor, but we can nevertheless produce code that uses the SSE\n# intrinsics, perhaps with some extra CFLAGS, compile both implementations and\n# select which one to use at runtime, depending on whether SSE 4.2 is supported\n# by the processor we're running on.\n#\n# You can override this logic by setting the appropriate USE_*_CRC32 flag to 1\n# in the template or configure command line.\nif test x\"$USE_SSE42_CRC32C\" = x\"\" && test x\"$USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\" = x\"\" && test x\"$USE_SLICING_BY_8_CRC32C\" = x\"\"; then\n  if test x\"$pgac_sse42_crc32_intrinsics\" = x\"yes\" && test x\"$SSE4_2_TARGETED\" = x\"1\" ; then\n    USE_SSE42_CRC32C=1\n  else\n    # the CPUID instruction is needed for the runtime check.\n    if test x\"$pgac_sse42_crc32_intrinsics\" = x\"yes\" && (test x\"$pgac_cv__get_cpuid\" = x\"yes\" || test x\"$pgac_cv__cpuid\" = x\"yes\"); then\n      USE_SSE42_CRC32C_WITH_RUNTIME_CHECK=1\n    else\n      # fall back to slicing-by-8 algorithm which doesn't require any special\n      # CPU support.\n      USE_SLICING_BY_8_CRC32C=1\n    fi\n  fi\nfi\n\n# Set PG_CRC32C_OBJS appropriately depending on the selected implementation.\nAC_MSG_CHECKING([which CRC-32C implementation to use])\nif test x\"$USE_SSE42_CRC32C\" = x\"1\"; then\n  AC_DEFINE(USE_SSE42_CRC32C, 1, [Define to 1 use Intel SSE 4.2 CRC instructions.])\n  PG_CRC32C_OBJS=\"pg_crc32c_sse42.o\"\n  AC_MSG_RESULT(SSE 4.2)\nelse\n  if test x\"$USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\" = x\"1\"; then\n    AC_DEFINE(USE_SSE42_CRC32C_WITH_RUNTIME_CHECK, 1, [Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check.])\n    PG_CRC32C_OBJS=\"pg_crc32c_sse42.o pg_crc32c_sb8.o pg_crc32c_choose.o\"\n    AC_MSG_RESULT(SSE 4.2 with runtime check)\n  else\n    AC_DEFINE(USE_SLICING_BY_8_CRC32C, 1, [Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check.])\n    PG_CRC32C_OBJS=\"pg_crc32c_sb8.o\"\n    AC_MSG_RESULT(slicing-by-8)\n  fi\nfi\nAC_SUBST(PG_CRC32C_OBJS)\n\n# CFLAGS we determined above will be added back at the end\nuser_CFLAGS=$CFLAGS\nCFLAGS=\"\"\n\n# set CFLAGS_VECTOR from the environment, if available\nif test \"$ac_env_CFLAGS_VECTOR_set\" = set; then\n  CFLAGS_VECTOR=$ac_env_CFLAGS_VECTOR_value\nfi\n\n# Some versions of GCC support some additional useful warning flags.\n# Check whether they are supported, and add them to CFLAGS if so.\n# ICC pretends to be GCC but it's lying; it doesn't support these flags,\n# but has its own.  Also check other compiler-specific flags here.\n\nif test \"$GCC\" = yes -a \"$ICC\" = no; then\n  CFLAGS=\"-Wall -Wmissing-prototypes -Wpointer-arith\"\n  # These work in some but not all gcc versions\n  # GPDB code is full of declarations after statement.\n  #PGAC_PROG_CC_CFLAGS_OPT([-Wdeclaration-after-statement])\n  PGAC_PROG_CC_CFLAGS_OPT([-Wendif-labels])\n  PGAC_PROG_CC_CFLAGS_OPT([-Wmissing-format-attribute])\n  # This was included in -Wall/-Wformat in older GCC versions\n  PGAC_PROG_CC_CFLAGS_OPT([-Wformat-security])\n  # Disable strict-aliasing rules; needed for gcc 3.3+\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-strict-aliasing])\n  # Disable optimizations that assume no overflow; needed for gcc 4.3+\n  PGAC_PROG_CC_CFLAGS_OPT([-fwrapv])\n  # Disable FP optimizations that cause various errors on gcc 4.5+ or maybe 4.6+\n  PGAC_PROG_CC_CFLAGS_OPT([-fexcess-precision=standard])\n  # Disable loop optimizations that get confused by variable-length struct\n  # declarations in gcc 4.8+\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-aggressive-loop-optimizations])\n\n  # Silence compiler warnings that you get with modern versions of GCC.\n  # All of these warnings have been fixed in later versions of PostgreSQL,\n  # but GPDB is based on 8.2, so you get these. TODO: Remove when we catch up\n  # with later PostgreSQL releases.\n  PGAC_PROG_CC_CFLAGS_OPT([-Wno-unused-but-set-variable])\n  PGAC_PROG_CC_CFLAGS_OPT([-Wno-address])\n\n  PGAC_PROG_CC_CFLAGS_OPT([-Wimplicit-fallthrough])\n  PGAC_PROG_CC_CFLAGS_OPT([-Werror=implicit-fallthrough])\n\n  #-Wno-error=enum-compare -Wno-error=address -Wno-error=maybe-uninitialized\n\n  # Optimization flags for specific files that benefit from vectorization\n  PGAC_PROG_CC_VAR_OPT(CFLAGS_VECTOR, [-funroll-loops])\n  PGAC_PROG_CC_VAR_OPT(CFLAGS_VECTOR, [-ftree-vectorize])\n  # We want to suppress clang's unhelpful unused-command-line-argument warnings\n  # but gcc won't complain about unrecognized -Wno-foo switches, so we have to\n  # test for the positive form and if that works, add the negative form\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wunused-command-line-argument])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-unused-command-line-argument\"\n  fi\n  # Similarly disable useless truncation warnings from gcc 8+\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wformat-truncation])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-format-truncation\"\n  fi\n  NOT_THE_CFLAGS=\"\"\n  PGAC_PROG_CC_VAR_OPT(NOT_THE_CFLAGS, [-Wstringop-truncation])\n  if test -n \"$NOT_THE_CFLAGS\"; then\n    CFLAGS=\"$CFLAGS -Wno-stringop-truncation\"\n  fi\nelif test \"$ICC\" = yes; then\n  # Intel's compiler has a bug/misoptimization in checking for\n  # division by NAN (NaN == 0), -mp1 fixes it, so add it to the CFLAGS.\n  PGAC_PROG_CC_CFLAGS_OPT([-mp1])\n  # Make sure strict aliasing is off (though this is said to be the default)\n  PGAC_PROG_CC_CFLAGS_OPT([-fno-strict-aliasing])\nelif test \"$PORTNAME\" = \"aix\"; then\n  # AIX's xlc has to have strict aliasing turned off too\n  PGAC_PROG_CC_CFLAGS_OPT([-qnoansialias])\n  PGAC_PROG_CC_CFLAGS_OPT([-qlonglong])\nelif test \"$PORTNAME\" = \"hpux\"; then\n  # On some versions of HP-UX, libm functions do not set errno by default.\n  # Fix that by using +Olibmerrno if the compiler recognizes it.\n  PGAC_PROG_CC_CFLAGS_OPT([+Olibmerrno])\nfi\n\nAC_SUBST(CFLAGS_VECTOR, $CFLAGS_VECTOR)\n\n# supply -g if --enable-debug\nif test \"$enable_debug\" = yes && test \"$ac_cv_prog_cc_g\" = yes; then\n  if test \"$GCC\" = yes; then\n  \tCFLAGS=\"$CFLAGS -g -ggdb\"\n  else\n    CFLAGS=\"$CFLAGS -g\"\n  fi\nfi\n\n# enable code coverage if --enable-coverage\nif test \"$enable_coverage\" = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"$CFLAGS -fprofile-arcs -ftest-coverage\"\n  else\n    AC_MSG_ERROR([--enable-coverage is supported only when using GCC])\n  fi\nfi\n\n# enable code coverage if --enable-coverage\nif test \"$enable_coverage\" = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"$CFLAGS -fprofile-arcs -ftest-coverage\"\n  else\n    AC_MSG_ERROR([--enable-coverage is supported only when using GCC])\n  fi\nfi\n\n# enable profiling if --enable-profiling\nif test \"$enable_profiling\" = yes && test \"$ac_cv_prog_cc_g\" = yes; then\n  if test \"$GCC\" = yes; then\n    AC_DEFINE([PROFILE_PID_DIR], 1,\n           [Define to 1 to allow profiling output to be saved separately for each process.])\n    CFLAGS=\"$CFLAGS -pg $PLATFORM_PROFILE_FLAGS\"\n  else\n    AC_MSG_ERROR([--enable-profiling is supported only when using GCC])\n  fi\nfi\n\n# We already have this in Makefile.win32, but configure needs it too\nif test \"$PORTNAME\" = \"win32\"; then\n  CPPFLAGS=\"$CPPFLAGS -I$srcdir/src/include/port/win32 -IgpAux/ext/win32/kfw-3-2-2/inc/krb5 -IgpAux/ext/win32/kfw-3-2-2/inc/krb5/gssapi -LgpAux/ext/win32/kfw-3-2-2/lib  -DEXEC_BACKEND -DUNSAFE_STAT_OK\"\n\nfi\n\n# Now that we're done automatically adding stuff to CFLAGS, put back the\n# user-specified flags (if any) at the end.  This lets users override\n# the automatic additions.\nCFLAGS=\"$CFLAGS $user_CFLAGS\"\n\n# Check if the compiler still works with the final flag settings\nAC_MSG_CHECKING([whether the C compiler still works])\nAC_TRY_LINK([], [return 0;],\n  [AC_MSG_RESULT(yes)],\n  [AC_MSG_RESULT(no)\n   AC_MSG_ERROR([cannot proceed])])\n\n# Defend against gcc -ffast-math\nif test \"$GCC\" = yes; then\nAC_TRY_COMPILE([], [@%:@ifdef __FAST_MATH__\nchoke me\n@%:@endif], [], [AC_MSG_ERROR([do not put -ffast-math in CFLAGS])])\nfi\n\n# Since PostgreSQL is written in pure C, all the tests in this file\n# add necessary flags to CFLAGS only. We have some C++ code in\n# src/backend/gpopt, so we must also configure CXXFLAGS in the same way.\n# However, some CFLAGS might not be applicable to C++, so we cannot just\n# use CFLAGS as is with the C++ compiler. Derive CXXFLAGS from CFLAGS,\n# by picking those CFLAGS that also work with the C++ compiler.\n#\n# This assumes that the C++ compiler is roughly compatible with the C\n# compiler, and accepts the same flags. While we test that each flag works\n# with the C++ compiler, we would miss any flags that we would need for\n# the C++ compiler, but not for the C compiler. For example, if you tried\n# to use CC=clang and CXX=g++, we would not know to apply flags that are\n# needed for g++, but not by clang. So don't mix and match compiler\n# families!\n\n# Loop over all options in CFLAGS, and check if they also work with CXX.\n# Add to CXXFLAGS those that do.\nfor cflag in $CFLAGS; do\n  PGAC_PROG_CXX_CXXFLAGS_OPT($cflag)\ndone\n\n# Defend against clang being used on x86-32 without SSE2 enabled.  As current\n# versions of clang do not understand -fexcess-precision=standard, the use of\n# x87 floating point operations leads to problems like isinf possibly returning\n# false for a value that is infinite when converted from the 80bit register to\n# the 8byte memory representation.\n#\n# Only perform the test if the compiler doesn't understand\n# -fexcess-precision=standard, that way a potentially fixed compiler will work\n# automatically.\nif test \"$pgac_cv_prog_cc_cflags__fexcess_precision_standard\" = no; then\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [\n@%:@if defined(__clang__) && defined(__i386__) && !defined(__SSE2_MATH__)\nchoke me\n@%:@endif\n])], [],\n[AC_MSG_ERROR([Compiling PostgreSQL with clang, on 32bit x86, requires SSE2 support. Use -msse2 or use gcc.])])\nfi\n\nAC_PROG_CPP\nAC_SUBST(GCC)\n\n#\n# Set up TAS assembly code if needed; the template file has now had its\n# chance to request this.\n#\nAC_CONFIG_LINKS([src/backend/port/tas.s:src/backend/port/tas/${tas_file}])\n\nif test \"$need_tas\" = yes ; then\n  TAS=tas.o\nelse\n  TAS=\"\"\nfi\nAC_SUBST(TAS)\n\n\n#\n# Automatic dependency tracking\n#\nPGAC_ARG_BOOL(enable, depend, no, [turn on automatic dependency tracking],\n              [autodepend=yes])\nAC_SUBST(autodepend)\n\n\n#\n# Enable assert checks\n#\nPGAC_ARG_BOOL(enable, cassert, no, [enable assertion checks (for debugging)],\n              [AC_DEFINE([USE_ASSERT_CHECKING], 1,\n                         [Define to 1 to build with assertion checks. (--enable-cassert)])])\n\n# Enable debug ntuplestore\nPGAC_ARG_BOOL(enable, debugntuplestore, no, [enable debug_ntuplestore (for debugging)],\n              [AC_DEFINE([USE_DEBUG_NTUPLESTORE], 1,\n                         [Define to 1 to build with debug_ntuplestore. (--enable-ntuplestore)])])\n\n#\n# Enable Greenplum ORCA optimizer\n#\nPGAC_ARG_BOOL(enable, orca, yes, [disable ORCA optimizer],\n              [AC_DEFINE([USE_ORCA], 1,\n                         [Define to 1 to build with Greenplum ORCA optimizer. (--enable-orca)])])\nAC_MSG_RESULT([checking whether to build with ORCA... $enable_orca])\nAC_SUBST(enable_orca)\n\n#\n# --enable-mapreduce enables GPMapreduce support\n#\nPGAC_ARG_BOOL(enable, mapreduce, no, [enable Greenplum Mapreduce support],\n              [AC_DEFINE([USE_MAPREDUCE], 1,\n\t\t\t             [Define to 1 to build with Mapreduce capabilities (--enable-mapreduce)])])\nAC_MSG_RESULT([checking whether to build with Greenplum Mapreduce... $enable_mapreduce])\nAC_SUBST(enable_mapreduce)\n\n#\n# gpcloud, enabled by default\n#\nPGAC_ARG_BOOL(enable, gpcloud, yes, [disable gpcloud support],\n              [AC_DEFINE([USE_GPCLOUD], 1,\n\t\t\t             [Define to 1 to build with gpcloud (--enable-gpcloud)])])\nAC_MSG_RESULT([checking whether to build with gpcloud... $enable_gpcloud])\nAC_SUBST(enable_gpcloud)\n\nAS_IF([test \"$enable_gpcloud\" = yes],\n[ # then\n  AX_CXX_COMPILE_STDCXX([11], [noext], [mandatory])\n]) # fi\n\n#\n# Include directories\n#\nac_save_IFS=$IFS\nIFS=\"${IFS}${PATH_SEPARATOR}\"\n# SRCH_INC comes from the template file\nfor dir in $with_includes $SRCH_INC; do\n  if test -d \"$dir\"; then\n    INCLUDES=\"$INCLUDES -I$dir\"\n  else\n    AC_MSG_WARN([*** Include directory $dir does not exist.])\n  fi\ndone\nIFS=$ac_save_IFS\nAC_SUBST(INCLUDES)\n\n\n#\n# Library directories\n#\nac_save_IFS=$IFS\nIFS=\"${IFS}${PATH_SEPARATOR}\"\n# LIBRARY_DIRS comes from command line, SRCH_LIB from template file.\nfor dir in $LIBRARY_DIRS $SRCH_LIB; do\n  if test -d \"$dir\"; then\n    LIBDIRS=\"$LIBDIRS -L$dir\"\n  else\n    AC_MSG_WARN([*** Library directory $dir does not exist.])\n  fi\ndone\nIFS=$ac_save_IFS\n\n#\n# Enable thread-safe client libraries\n#\nAC_MSG_CHECKING([allow thread-safe client libraries])\nPGAC_ARG_BOOL(enable, thread-safety, yes, [disable thread-safety in client libraries])\nif test \"$enable_thread_safety\" = yes; then\n  AC_DEFINE([ENABLE_THREAD_SAFETY], 1,\n          [Define to 1 to build client libraries as thread-safe code. (--enable-thread-safety)])\nfi\nAC_MSG_RESULT([$enable_thread_safety])\nAC_SUBST(enable_thread_safety)\n\n#\n# Optionally build Tcl modules (PL/Tcl)\n#\nAC_MSG_CHECKING([whether to build with Tcl])\nPGAC_ARG_BOOL(with, tcl, no, [build Tcl modules (PL/Tcl)])\nAC_MSG_RESULT([$with_tcl])\nAC_SUBST([with_tcl])\n\n# We see if the path to the Tcl/Tk configuration scripts is specified.\n# This will override the use of tclsh to find the paths to search.\n\nPGAC_ARG_REQ(with, tclconfig, [DIR], [tclConfig.sh is in DIR])\n\n#\n# Optionally build Perl modules (PL/Perl)\n#\nAC_MSG_CHECKING([whether to build Perl modules])\nPGAC_ARG_BOOL(with, perl, no, [build Perl modules (PL/Perl)])\nAC_MSG_RESULT([$with_perl])\nAC_SUBST(with_perl)\n\n#\n# Optionally build Python modules (PL/Python)\n#\nAC_MSG_CHECKING([whether to build Python modules])\nPGAC_ARG_BOOL(with, python, no, [build Python modules (PL/Python)])\nAC_MSG_RESULT([$with_python])\nAC_SUBST(with_python)\n\n#\n# GSSAPI\n#\nAC_MSG_CHECKING([whether to build with GSSAPI support])\nPGAC_ARG_BOOL(with, gssapi, no, [build with GSSAPI support],\n[\n  AC_DEFINE(ENABLE_GSS, 1, [Define to build with GSSAPI support. (--with-gssapi)])\n  krb_srvtab=\"FILE:\\$(sysconfdir)/krb5.keytab\"\n])\nAC_MSG_RESULT([$with_gssapi])\n\n\nAC_SUBST(krb_srvtab)\n\n\n#\n# Kerberos configuration parameters\n#\nPGAC_ARG_REQ(with, krb-srvnam,\n             [NAME], [default service principal name in Kerberos (GSSAPI) [postgres]],\n             [],\n             [with_krb_srvnam=\"postgres\"])\nAC_DEFINE_UNQUOTED([PG_KRB_SRVNAM], [\"$with_krb_srvnam\"],\n                   [Define to the name of the default PostgreSQL service principal in Kerberos (GSSAPI). (--with-krb-srvnam=NAME)])\n\n\n#\n# PAM\n#\nAC_MSG_CHECKING([whether to build with PAM support])\nPGAC_ARG_BOOL(with, pam, no,\n              [build with PAM support],\n              [AC_DEFINE([USE_PAM], 1, [Define to 1 to build with PAM support. (--with-pam)])])\nAC_MSG_RESULT([$with_pam])\n\n\n#\n# LDAP\n#\nAC_MSG_CHECKING([whether to build with LDAP support])\nPGAC_ARG_BOOL(with, ldap, no,\n              [build with LDAP support],\n              [AC_DEFINE([USE_LDAP], 1, [Define to 1 to build with LDAP support. (--with-ldap)])])\nAC_MSG_RESULT([$with_ldap])\n\n\n#\n# Bonjour\n#\nAC_MSG_CHECKING([whether to build with Bonjour support])\nPGAC_ARG_BOOL(with, bonjour, no,\n              [build with Bonjour support],\n              [AC_DEFINE([USE_BONJOUR], 1, [Define to 1 to build with Bonjour support. (--with-bonjour)])])\nAC_MSG_RESULT([$with_bonjour])\n\n\n#\n# OpenSSL\n#\nAC_MSG_CHECKING([whether to build with OpenSSL support])\nPGAC_ARG_BOOL(with, openssl, no, [build with OpenSSL support],\n              [AC_DEFINE([USE_SSL], 1, [Define to build with (Open)SSL support. (--with-openssl)])])\nAC_MSG_RESULT([$with_openssl])\nAC_SUBST(with_openssl)\n\n#\n# SELinux\n#\nAC_MSG_CHECKING([whether to build with SELinux support])\nPGAC_ARG_BOOL(with, selinux, no, [build with SELinux support])\nAC_SUBST(with_selinux)\nAC_MSG_RESULT([$with_selinux])\n\n#\n# Readline\n#\nPGAC_ARG_BOOL(with, readline, yes,\n              [do not use GNU Readline nor BSD Libedit for editing])\n# readline on MinGW has problems with backslashes in psql and other bugs.\n# This is particularly a problem with non-US code pages.\n# Therefore disable its use until we understand the cause. 2004-07-20\nif test \"$PORTNAME\" = \"win32\"; then\n  if test \"$with_readline\" = yes; then\n    AC_MSG_WARN([*** Readline does not work on MinGW --- disabling])\n    with_readline=no\n  fi\nfi\n\n\n#\n# Prefer libedit\n#\nPGAC_ARG_BOOL(with, libedit-preferred, no,\n              [prefer BSD Libedit over GNU Readline])\n\n\n#\n# UUID library\n#\n# There are at least three UUID libraries in common use: the FreeBSD/NetBSD\n# library, the e2fsprogs libuuid (now part of util-linux-ng), and the OSSP\n# UUID library.  More than one of these might be present on a given platform,\n# so we make the user say which one she wants.\n#\nPGAC_ARG_REQ(with, uuid, [LIB], [build contrib/uuid-ossp using LIB (bsd,e2fs,ossp)])\nif test x\"$with_uuid\" = x\"\" ; then\n  with_uuid=no\nfi\nPGAC_ARG_BOOL(with, ossp-uuid, no, [obsolete spelling of --with-uuid=ossp])\nif test \"$with_ossp_uuid\" = yes ; then\n  with_uuid=ossp\nfi\n\nif test \"$with_uuid\" = bsd ; then\n  AC_DEFINE([HAVE_UUID_BSD], 1, [Define to 1 if you have BSD UUID support.])\n  UUID_EXTRA_OBJS=\"md5.o sha1.o\"\nelif test \"$with_uuid\" = e2fs ; then\n  AC_DEFINE([HAVE_UUID_E2FS], 1, [Define to 1 if you have E2FS UUID support.])\n  UUID_EXTRA_OBJS=\"md5.o sha1.o\"\nelif test \"$with_uuid\" = ossp ; then\n  AC_DEFINE([HAVE_UUID_OSSP], 1, [Define to 1 if you have OSSP UUID support.])\n  UUID_EXTRA_OBJS=\"\"\nelif test \"$with_uuid\" = no ; then\n  UUID_EXTRA_OBJS=\"\"\nelse\n  AC_MSG_ERROR([--with-uuid must specify one of bsd, e2fs, or ossp])\nfi\nAC_SUBST(with_uuid)\nAC_SUBST(UUID_EXTRA_OBJS)\n\n\n#\n# XML\n#\nPGAC_ARG_BOOL(with, libxml, no, [build with XML support],\n              [AC_DEFINE([USE_LIBXML], 1, [Define to 1 to build with XML support. (--with-libxml)])])\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_PROGS(XML2_CONFIG, xml2-config)\n  if test -n \"$XML2_CONFIG\"; then\n    for pgac_option in `$XML2_CONFIG --cflags`; do\n      case $pgac_option in\n        -I*|-D*) CPPFLAGS=\"$CPPFLAGS $pgac_option\";;\n      esac\n    done\n    for pgac_option in `$XML2_CONFIG --libs`; do\n      case $pgac_option in\n        -L*) LDFLAGS=\"$LDFLAGS $pgac_option\";;\n      esac\n    done\n  fi\nfi\n\nAC_SUBST(with_libxml)\n\n#\n# XSLT\n#\nPGAC_ARG_BOOL(with, libxslt, no, [use XSLT support when building contrib/xml2],\n              [AC_DEFINE([USE_LIBXSLT], 1, [Define to 1 to use XSLT support when building contrib/xml2. (--with-libxslt)])])\n\n\nAC_SUBST(with_libxslt)\n\n#\n# tzdata\n#\nPGAC_ARG_REQ(with, system-tzdata,\n             [DIR], [use system time zone data in DIR])\nAC_SUBST(with_system_tzdata)\n\n#\n# Zlib\n#\nPGAC_ARG_BOOL(with, zlib, yes,\n              [do not use Zlib])\nAC_SUBST(with_zlib)\n\n#\n# bzip2\n#\nPGAC_ARG_BOOL(with, libbz2, yes,\n              [do not use bzip2])\nAC_SUBST(with_libbz2)\n\n#\n# zstd\n#\nPGAC_ARG_BOOL(with, zstd, yes,\n              [do not build with Zstandard])\nAC_SUBST(with_zstd)\n\n#\n# quicklz\n#\nPGAC_ARG_BOOL(with, quicklz, no,\n              [build with QuickLZ support (requires quicklz library)])\nAC_SUBST(with_quicklz)\n\n#\n# Realtime library\n#\nPGAC_ARG_BOOL(with, rt, yes,\n              [do not use Realtime Library])\nAC_SUBST(with_rt)\n\n#\n# libcurl. Used for external table support and the PXF extension\n#\nPGAC_ARG_BOOL(with, libcurl, yes,\n              [do not use libcurl])\nAC_SUBST(with_libcurl)\n\nif test \"$with_libcurl\" = \"no\" && test \"$enable_pxf\" = \"yes\"; then\n  AC_MSG_ERROR([libcurl is required by PXF])\nfi\n\n#\n# libapr. Used for gpfdist and gpperfmon\n#\nPGAC_ARG_REQ(with, apr-config,\n             [PATH], [path to apr-1-config utility])\nAC_SUBST(with_apr_config)\n\n#\n# libapu. Used for gpperfmon.\n#\nPGAC_ARG_REQ(with, apu-config,\n             [PATH], [path to apu-1-config utility])\nAC_SUBST(with_apu_config)\n\n#\n# Elf\n#\n\n# Assume system is ELF if it predefines __ELF__ as 1,\n# otherwise believe host_os based default.PostgreSQL\ncase $host_os in\n    freebsd1*|freebsd2*) elf=no;;\n    freebsd3*|freebsd4*) elf=yes;;\nesac\n\nAC_EGREP_CPP(yes,\n[#if __ELF__\n  yes\n#endif\n],\n[ELF_SYS=true],\n[if test \"X$elf\" = \"Xyes\" ; then\n  ELF_SYS=true\nelse\n  ELF_SYS=\nfi])\nAC_SUBST(ELF_SYS)\n\n#\n# Assignments\n#\n\nCPPFLAGS=\"$CPPFLAGS $INCLUDES\"\nLDFLAGS=\"$LDFLAGS $LIBDIRS\"\n\nAC_ARG_VAR(LDFLAGS_EX, [extra linker flags for linking executables only])\nAC_ARG_VAR(LDFLAGS_SL, [extra linker flags for linking shared libraries only])\n\nAC_MSG_NOTICE([using CPPFLAGS=$CPPFLAGS])\nAC_MSG_NOTICE([using LDFLAGS=$LDFLAGS])\n\nPGAC_PROG_LD\nAC_SUBST(LD)\nAC_SUBST(with_gnu_ld)\ncase $host_os in sysv5*)\n  AC_CACHE_CHECK([whether ld -R works], [pgac_cv_prog_ld_R],\n  [\n    pgac_save_LDFLAGS=$LDFLAGS; LDFLAGS=\"$LDFLAGS -Wl,-R/usr/lib\"\n    AC_TRY_LINK([], [], [pgac_cv_prog_ld_R=yes], [pgac_cv_prog_ld_R=no])\n    LDFLAGS=$pgac_save_LDFLAGS\n  ])\n  ld_R_works=$pgac_cv_prog_ld_R\n  AC_SUBST(ld_R_works)\nesac\nAC_PROG_RANLIB\nPGAC_CHECK_STRIP\nAC_CHECK_TOOL(AR, ar, ar)\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_CHECK_TOOL(DLLTOOL, dlltool, dlltool)\n  AC_CHECK_TOOL(DLLWRAP, dllwrap, dllwrap)\n  AC_CHECK_TOOL(WINDRES, windres, windres)\nfi\n\nAC_PROG_INSTALL\n# When Autoconf chooses install-sh as install program it tries to generate\n# a relative path to it in each makefile where it substitutes it. This clashes\n# with our Makefile.global concept. This workaround helps.\ncase $INSTALL in\n  *install-sh*) install_bin='';;\n  *) install_bin=$INSTALL;;\nesac\nAC_SUBST(install_bin)\n\nAC_PATH_PROG(TAR, tar)\nAC_PROG_LN_S\nAC_PROG_AWK\nAC_PROG_MKDIR_P\n# When Autoconf chooses install-sh as mkdir -p program it tries to generate\n# a relative path to it in each makefile where it substitutes it. This clashes\n# with our Makefile.global concept. This workaround helps.\ncase $MKDIR_P in\n  *install-sh*) MKDIR_P='\\${SHELL} \\${top_srcdir}/config/install-sh -c -d';;\nesac\n\nPGAC_PATH_BISON\nPGAC_PATH_FLEX\n\nPGAC_PATH_PERL\nif test \"$with_perl\" = yes; then\n  if test -z \"$PERL\"; then\n    AC_MSG_ERROR([Perl not found])\n  fi\n  PGAC_CHECK_PERL_CONFIGS([archlibexp,privlibexp,useshrplib])\n  # On most platforms, archlibexp is also where the Perl include files live ...\n  perl_includespec=\"-I$perl_archlibexp/CORE\"\n  # ... but on newer macOS versions, we must use -iwithsysroot to look\n  # under $PG_SYSROOT\n  if test \\! -f \"$perl_archlibexp/CORE/perl.h\" ; then\n    if test -f \"$PG_SYSROOT$perl_archlibexp/CORE/perl.h\" ; then\n      perl_includespec=\"-iwithsysroot $perl_archlibexp/CORE\"\n    fi\n  fi\n  AC_SUBST(perl_includespec)dnl\n  PGAC_CHECK_PERL_EMBED_CCFLAGS\n  PGAC_CHECK_PERL_EMBED_LDFLAGS\nfi\n\nif test \"$with_python\" = yes; then\n  PGAC_PATH_PYTHON\n  PGAC_CHECK_PYTHON_EMBED_SETUP\nfi\n\nif test \"$cross_compiling\" = yes && test -z \"$with_system_tzdata\"; then\n  AC_PATH_PROG(ZIC, zic)\n  if test -z \"$ZIC\"; then\n    AC_MSG_ERROR([\nWhen cross-compiling, either use the option --with-system-tzdata to use\nexisting time-zone data, or set the environment variable ZIC to a zic\nprogram to use during the build.])\n  fi\nfi\n\n#\n# Pthreads\n#\n# For each platform, we need to know about any special compile and link\n# libraries, and whether the normal C function names are thread-safe.\n# See the comment at the top of src/port/thread.c for more information.\n# WIN32 doesn't need the pthread tests;  it always uses threads\n#\n# These tests are run before the library-tests, because linking with the\n# other libraries can pull in the pthread functions as a side-effect.  We\n# want to use the -pthread or similar flags directly, and not rely on\n# the side-effects of linking with some other library.\n#\n# note: We have to use AS_IF here rather than plain if. The AC_CHECK_HEADER\n# invocation below is the first one in the script, and autoconf generates\n# additional code for that, which must not be inside the if-block. AS_IF\n# knows how to do that.\nAS_IF([test \"$enable_thread_safety\" = yes -a \"$PORTNAME\" != \"win32\"],\n[ # then\nAX_PTHREAD\t# set thread flags\n\n# Some platforms use these, so just define them.  They can't hurt if they\n# are not supported.  For example, on Solaris -D_POSIX_PTHREAD_SEMANTICS\n# enables 5-arg getpwuid_r, among other things.\nPTHREAD_CFLAGS=\"$PTHREAD_CFLAGS -D_REENTRANT -D_THREAD_SAFE -D_POSIX_PTHREAD_SEMANTICS\"\n\n# Check for *_r functions\n_CFLAGS=\"$CFLAGS\"\n_LIBS=\"$LIBS\"\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS\"\nLIBS=\"$LIBS $PTHREAD_LIBS\"\n\nAC_CHECK_HEADER(pthread.h, [], [AC_MSG_ERROR([\npthread.h not found;  use --disable-thread-safety to disable thread safety])])\n\nAC_CHECK_FUNCS([strerror_r getpwuid_r gethostbyname_r])\n\n# Do test here with the proper thread flags\nPGAC_FUNC_GETPWUID_R_5ARG\nPGAC_FUNC_STRERROR_R_INT\n\nCFLAGS=\"$_CFLAGS\"\nLIBS=\"$_LIBS\"\n\n], [ # else\n# do not use values from template file\nPTHREAD_CFLAGS=\nPTHREAD_LIBS=\n]) # fi\n\nAC_SUBST(PTHREAD_CFLAGS)\nAC_SUBST(PTHREAD_LIBS)\n\n\n##\n## Libraries\n##\n## Most libraries are included only if they demonstrably provide a function\n## we need, but libm is an exception: always include it, because there are\n## too many compilers that play cute optimization games that will break\n## probes for standard functions such as pow().\n##\n\nAC_CHECK_LIB(m, main)\nAC_SEARCH_LIBS(setproctitle, util)\nAC_SEARCH_LIBS(dlopen, dl)\nAC_SEARCH_LIBS(socket, [socket wsock32])\nAC_SEARCH_LIBS(shl_load, dld)\n# We only use libld in port/dynloader/aix.c\ncase $host_os in\n     aix*)\n\tAC_SEARCH_LIBS(ldopen, ld)\n\t;;\nesac\nAC_SEARCH_LIBS(getopt_long, [getopt gnugetopt])\nAC_SEARCH_LIBS(crypt, crypt)\nAC_SEARCH_LIBS(shm_open, rt)\nAC_SEARCH_LIBS(shm_unlink, rt)\n# Solaris:\nAC_SEARCH_LIBS(fdatasync, [rt posix4])\n# Required for thread_test.c on Solaris\nAC_SEARCH_LIBS(sched_yield, rt)\n# Required for thread_test.c on Solaris 2.5:\n# Other ports use it too (HP-UX) so test unconditionally\nAC_SEARCH_LIBS(gethostbyname_r, nsl)\n# Cygwin:\nAC_SEARCH_LIBS(shmget, cygipc)\n\nif test \"$with_readline\" = yes; then\n  PGAC_CHECK_READLINE\n  if test x\"$pgac_cv_check_readline\" = x\"no\"; then\n    AC_MSG_ERROR([readline library not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])\n  fi\nfi\n\nif test \"$with_zlib\" = yes; then\n  AC_CHECK_LIB(z, inflate, [],\n               [AC_MSG_ERROR([zlib library not found\nIf you have zlib already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-zlib to disable zlib support.])])\nfi\n\nif test \"$with_zstd\" = yes; then\n  AC_CHECK_LIB(zstd, ZSTD_compressCCtx, [],\n               [AC_MSG_ERROR([zstd library not found\nIf you have libzstd already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-zstd to disable zstd support.])])\nfi\n\nif test \"$with_quicklz\" = yes; then\n  AC_CHECK_LIB(quicklz, qlz_compress, [],\n               [AC_MSG_ERROR([quicklz library not found.])])\nfi\n\nif test \"$enable_spinlocks\" = yes; then\n  AC_DEFINE(HAVE_SPINLOCKS, 1, [Define to 1 if you have spinlocks.])\nelse\n  AC_MSG_WARN([\n*** Not using spinlocks will cause poor performance.])\nfi\n\nif test \"$enable_atomics\" = yes; then\n  AC_DEFINE(HAVE_ATOMICS, 1, [Define to 1 if you want to use atomics.])\nelse\n  AC_MSG_WARN([\n*** Not using atomic operations will cause poor performance.])\nfi\n\nif test \"$with_gssapi\" = yes ; then\n  if test \"$PORTNAME\" != \"win32\"; then\n    AC_SEARCH_LIBS(gss_init_sec_context, [gssapi_krb5 gss 'gssapi -lkrb5 -lcrypto'], [],\n                   [AC_MSG_ERROR([could not find function 'gss_init_sec_context' required for GSSAPI])])\n  else\n    LIBS=\"$LIBS -lgssapi32\"\n  fi\nfi\n\nAC_DEFUN([CHECK_APR], [\n  GPAC_PATH_APR_1_CONFIG\n  # If the 'apr-1-config --link-ld' produced correct output, -lapr-1 is already\n  # in LIBS, hence AC_SEARCH_LIBS rather than AC_CHECK_LIB. (and the autoconf\n  # manual recommends always using AC_SEARCH_LIBS rather than AC_CHECK_LIB\n  # anyway)\n  _LIBS=\"$LIBS\"\n  LIBS=\"$LIBS $apr_link_ld_libs\"\n  AC_SEARCH_LIBS(apr_getopt_long, [apr-1], [], [AC_MSG_ERROR([libapr-1 is required by gpfdist and gpperfmon])])\n ])\n\nif test \"$enable_gpfdist\" = yes ; then\n  CHECK_APR()\n  AC_SEARCH_LIBS(event_add, [event], [], [AC_MSG_ERROR([libevent is required for gpfdist])])\n\n  AC_SEARCH_LIBS(yaml_parser_initialize, [yaml], [have_yaml=yes], [AC_MSG_WARN([libyaml is not found. disabling transformations for gpfdist.])])\n  LIBS=\"$_LIBS\"\n  AC_SUBST(have_yaml)\nfi\n\nif test \"$enable_mapreduce\" = yes; then\n  AC_SEARCH_LIBS(yaml_parser_initialize, [yaml], [have_yaml=yes], [AC_MSG_ERROR([libyaml is required for Greenplum Mapreduce])])\n  AC_SUBST(have_yaml)\nfi\n\nif test \"$enable_gpperfmon\" = yes; then\n  CHECK_APR()\n  GPAC_PATH_APU_1_CONFIG\n  LIBS=\"$LIBS $apu_link_ld_libs\"\n  AC_SEARCH_LIBS(event_add, [event], [], [AC_MSG_ERROR([libevent is required for gpperfrmon])])\n  AC_SEARCH_LIBS(apr_queue_push, [aprutil-1], [], [AC_MSG_ERROR([libaprutil-1 is required for gpperfmon])])\n\n  AC_SEARCH_LIBS(sigar_open, [sigar], [with_libsigar=yes], [AC_MSG_ERROR([libsigar is required for gpperfmon])])\n  LIBS=\"$_LIBS\"\n  AC_SUBST(with_libsigar)\nfi\n\n\nif test \"$with_openssl\" = yes ; then\n  dnl Order matters!\n  if test \"$PORTNAME\" != \"win32\"; then\n     AC_CHECK_LIB(crypto, CRYPTO_new_ex_data, [], [AC_MSG_ERROR([library 'crypto' is required for OpenSSL])])\n     AC_CHECK_LIB(ssl,    SSL_new, [], [AC_MSG_ERROR([library 'ssl' is required for OpenSSL])])\n  else\n     AC_SEARCH_LIBS(CRYPTO_new_ex_data, [eay32 crypto], [], [AC_MSG_ERROR([library 'eay32' or 'crypto' is required for OpenSSL])])\n     AC_SEARCH_LIBS(SSL_new, [ssleay32 ssl], [], [AC_MSG_ERROR([library 'ssleay32' or 'ssl' is required for OpenSSL])])\n  fi\n  AC_CHECK_FUNCS([SSL_get_current_compression])\n  # Functions introduced in OpenSSL 1.1.0. We used to check for\n  # OPENSSL_VERSION_NUMBER, but that didn't work with 1.1.0, because LibreSSL\n  # defines OPENSSL_VERSION_NUMBER to claim version 2.0.0, even though it\n  # doesn't have these OpenSSL 1.1.0 functions. So check for individual\n  # functions.\n  AC_CHECK_FUNCS([OPENSSL_init_ssl BIO_meth_new ASN1_STRING_get0_data RAND_OpenSSL])\n  # OpenSSL versions before 1.1.0 required setting callback functions, for\n  # thread-safety. In 1.1.0, it's no longer required, and CRYPTO_lock()\n  # function was removed.\n  AC_CHECK_FUNCS([CRYPTO_lock])\nfi\n\nif test \"$with_rt\" = yes ; then\n  AC_CHECK_LIB(rt, clock_gettime, [],\n                [AC_MSG_WARN([Realtime library not found])])\nfi\n\nif test \"$with_pam\" = yes ; then\n  AC_CHECK_LIB(pam,    pam_start, [], [AC_MSG_ERROR([library 'pam' is required for PAM])])\nfi\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_LIB(xml2, xmlSaveToBuffer, [], [AC_MSG_ERROR([library 'xml2' (version >= 2.6.23) is required for XML support])])\nfi\n\n# Check for curl.\n# CURLOPT_MAIL_FROM is introduced in curl 7.20 and only needed for email alerts.\nif test \"$with_libcurl\" = yes ; then\n  AC_CHECK_CURL([7.19.0])\n  CFLAGS=\"$CFLAGS $CURL_CFLAGS\"\n  LIBS=\"$LIBS $CURL_LIBS\"\n  AC_DEFINE([USE_CURL], 1,\n          [Define to 1 to build with libcurl support. (--with-libcurl)])\n  AC_CHECK_DECLS([CURLOPT_MAIL_FROM], [], [], [#include <curl/curl.h>])\nfi\n\n# Check for bzip2\nif test \"$with_libbz2\" = yes ; then\n  AC_CHECK_LIB(bz2, BZ2_bzDecompress, [], [AC_MSG_ERROR([library 'bz2' is required for bzip2 support])])\nfi\n\nif test \"$with_libxslt\" = yes ; then\n  AC_CHECK_LIB(xslt, xsltCleanupGlobals, [], [AC_MSG_ERROR([library 'xslt' is required for XSLT support])])\nfi\n\n# Note: We can test for libldap_r only after we know PTHREAD_LIBS\nif test \"$with_ldap\" = yes ; then\n  _LIBS=\"$LIBS\"\n  if test \"$PORTNAME\" != \"win32\"; then\n    AC_CHECK_LIB(ldap, ldap_bind, [],\n\t\t [AC_MSG_ERROR([library 'ldap' is required for LDAP])],\n\t\t [$EXTRA_LDAP_LIBS])\n    LDAP_LIBS_BE=\"-lldap $EXTRA_LDAP_LIBS\"\n    if test \"$enable_thread_safety\" = yes; then\n      # on some platforms ldap_r fails to link without PTHREAD_LIBS\n      AC_CHECK_LIB(ldap_r, ldap_simple_bind, [],\n\t\t   [AC_MSG_ERROR([library 'ldap_r' is required for LDAP])],\n\t\t   [$PTHREAD_CFLAGS $PTHREAD_LIBS $EXTRA_LDAP_LIBS])\n      LDAP_LIBS_FE=\"-lldap_r $EXTRA_LDAP_LIBS\"\n    else\n      LDAP_LIBS_FE=\"-lldap $EXTRA_LDAP_LIBS\"\n    fi\n  else\n    AC_CHECK_LIB(wldap32, ldap_bind, [], [AC_MSG_ERROR([library 'wldap32' is required for LDAP])])\n    LDAP_LIBS_FE=\"-lwldap32\"\n    LDAP_LIBS_BE=\"-lwldap32\"\n  fi\n  LIBS=\"$_LIBS\"\nfi\nAC_SUBST(LDAP_LIBS_FE)\nAC_SUBST(LDAP_LIBS_BE)\n\n# for contrib/sepgsql\nif test \"$with_selinux\" = yes; then\n  AC_CHECK_LIB(selinux, security_compute_create_name, [],\n               [AC_MSG_ERROR([library 'libselinux', version 2.1.10 or newer, is required for SELinux support])])\nfi\n\n# for contrib/uuid-ossp\nif test \"$with_uuid\" = bsd ; then\n  # On BSD, the UUID functions are in libc\n  AC_CHECK_FUNC(uuid_to_string,\n    [UUID_LIBS=\"\"],\n    [AC_MSG_ERROR([BSD UUID functions are not present])])\nelif test \"$with_uuid\" = e2fs ; then\n  # On OS X, the UUID functions are in libc\n  AC_CHECK_FUNC(uuid_generate,\n    [UUID_LIBS=\"\"],\n    [AC_CHECK_LIB(uuid, uuid_generate,\n      [UUID_LIBS=\"-luuid\"],\n      [AC_MSG_ERROR([library 'uuid' is required for E2FS UUID])])])\nelif test \"$with_uuid\" = ossp ; then\n  AC_CHECK_LIB(ossp-uuid, uuid_export,\n    [UUID_LIBS=\"-lossp-uuid\"],\n    [AC_CHECK_LIB(uuid, uuid_export,\n      [UUID_LIBS=\"-luuid\"],\n      [AC_MSG_ERROR([library 'ossp-uuid' or 'uuid' is required for OSSP UUID])])])\nfi\nAC_SUBST(UUID_LIBS)\n\n# Check for Greenplum Query Optimizer (orca) libraries.\nif test \"$enable_orca\" = yes; then\n  PGAC_CHECK_ORCA_XERCES\n  PGAC_CHECK_ORCA_LIBS\nfi\n\n# OpenBSD requires libexecinfo from ports for backtrace() as it's a glibc addition\nif test \"$PORTNAME\" = \"openbsd\"; then\n  AC_CHECK_LIB(execinfo, backtrace, [], [AC_MSG_ERROR([library 'execinfo' is required for backtrace support])])\nfi\n\n##\n## Header files\n##\n\ndnl sys/socket.h is required by AC_FUNC_ACCEPT_ARGTYPES\nAC_CHECK_HEADERS([atomic.h crypt.h dld.h fp_class.h getopt.h ieeefp.h ifaddrs.h langinfo.h mbarrier.h poll.h pwd.h sys/ioctl.h sys/ipc.h sys/poll.h sys/pstat.h sys/resource.h sys/select.h sys/sem.h sys/shm.h sys/socket.h sys/sockio.h sys/tas.h sys/time.h sys/un.h termios.h ucred.h utime.h wchar.h wctype.h ])\n\n# On BSD, test for net/if.h will fail unless sys/socket.h\n# is included first.\nAC_CHECK_HEADERS(net/if.h, [], [],\n[AC_INCLUDES_DEFAULT\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n])\n\n# On OpenBSD, test for sys/ucred.h will fail unless sys/param.h\n# is included first.\nAC_CHECK_HEADERS(sys/ucred.h, [], [],\n[AC_INCLUDES_DEFAULT\n#include <sys/param.h>\n])\n\n# At least on IRIX, test for netinet/tcp.h will fail unless\n# netinet/in.h is included first.\nAC_CHECK_HEADERS(netinet/in.h)\nAC_CHECK_HEADERS(netinet/tcp.h, [], [],\n[AC_INCLUDES_DEFAULT\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n])\n\nif expr x\"$pgac_cv_check_readline\" : 'x-lreadline' >/dev/null ; then\n  AC_CHECK_HEADERS(readline/readline.h, [],\n        [AC_CHECK_HEADERS(readline.h, [],\n                [AC_MSG_ERROR([readline header not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])])])\n  AC_CHECK_HEADERS(readline/history.h, [],\n        [AC_CHECK_HEADERS(history.h, [],\n                [AC_MSG_ERROR([history header not found\nIf you have readline already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable readline support.])])])\nfi\n\nif expr x\"$pgac_cv_check_readline\" : 'x-ledit' >/dev/null ; then\n# Some installations of libedit usurp /usr/include/readline/, which seems\n# bad practice, since in combined installations readline will have its headers\n# there.  We might have to resort to AC_EGREP checks to make sure we found\n# the proper header...\n  AC_CHECK_HEADERS(editline/readline.h, [],\n        [AC_CHECK_HEADERS(readline.h, [],\n                [AC_CHECK_HEADERS(readline/readline.h, [],\n                        [AC_MSG_ERROR([readline header not found\nIf you have libedit already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-readline to disable libedit support.])])])])\n# Note: in a libedit installation, history.h is sometimes a dummy, and may\n# not be there at all.  Hence, don't complain if not found.  We must check\n# though, since in yet other versions it is an independent header.\n  AC_CHECK_HEADERS(editline/history.h, [],\n        [AC_CHECK_HEADERS(history.h, [],\n                [AC_CHECK_HEADERS(readline/history.h)])])\nfi\n\nif test \"$enable_gpfdist\" = yes; then\n  if test \"$PORTNAME\" = \"win32\"; then\n    AC_CHECK_HEADERS([winsock2.h])\n  fi\n\n  AC_CHECK_HEADERS(yaml.h, [], [AC_MSG_WARN([header file <yaml.h> is not found. disabling transformations for gpfdist.])])\n  AC_CHECK_HEADERS(event.h, [], [AC_MSG_ERROR([header file <event.h> is required for gpfdist])])\n\n  ac_save_CPPFLAGS=$CPPFLAGS\n  CPPFLAGS=\"$apr_includes $CPPFLAGS\"\n  AC_CHECK_HEADERS(apr_getopt.h, [], [AC_MSG_ERROR(['header file <apr_getopt.h> is required for gpfdist'])])\n  CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\nif test \"enable_gpperfmon\" = yes; then\n  AC_CHECK_HEADERS(event.h, [], [AC_MSG_ERROR([header file <event.h> is required for gpperfmon])])\nfi\n\nif test \"$with_zlib\" = yes; then\n  AC_CHECK_HEADER(zlib.h, [], [AC_MSG_ERROR([zlib header not found\nIf you have zlib already installed, see config.log for details on the\nfailure.  It is possible the compiler isn't looking in the proper directory.\nUse --without-zlib to disable zlib support.])])\nfi\n\n# Check for bzlib.h\nif test \"$with_libbz2\" = yes ; then\n  AC_CHECK_HEADER(bzlib.h, [], [AC_MSG_ERROR([header file <bzlib.h> is required for bzip2 support])], [])\nfi\n\n# Check for zstd.h and zstd_errors.h\nif test \"$with_zstd\" = yes; then\n  AC_CHECK_HEADER(zstd.h, [], [AC_MSG_ERROR([header file <zstd.h> is required for zstd support])])\n  AC_CHECK_HEADER(zstd_errors.h, [], [AC_MSG_ERROR([header file <zstd_errors.h> is required for zstd support])])\nfi\n\n# Check for quicklz.h\nif test \"$with_quicklz\" = yes; then\n  AC_CHECK_HEADER(quicklz.h, [], [AC_MSG_ERROR([header file <quicklz.h> is required for QuickLZ support])])\nfi\n\nif test \"$with_gssapi\" = yes ; then\n  AC_CHECK_HEADERS(gssapi/gssapi.h, [],\n\t[AC_CHECK_HEADERS(gssapi.h, [], [AC_MSG_ERROR([gssapi.h header file is required for GSSAPI])])])\nfi\n\nif test \"$with_openssl\" = yes ; then\n  AC_CHECK_HEADER(openssl/ssl.h, [], [AC_MSG_ERROR([header file <openssl/ssl.h> is required for OpenSSL])])\n  AC_CHECK_HEADER(openssl/err.h, [], [AC_MSG_ERROR([header file <openssl/err.h> is required for OpenSSL])])\nfi\n\nif test \"$with_pam\" = yes ; then\n  AC_CHECK_HEADERS(security/pam_appl.h, [],\n                   [AC_CHECK_HEADERS(pam/pam_appl.h, [],\n                                     [AC_MSG_ERROR([header file <security/pam_appl.h> or <pam/pam_appl.h> is required for PAM.])])])\nfi\n\nif test \"$with_libxml\" = yes ; then\n  AC_CHECK_HEADER(libxml/parser.h, [], [AC_MSG_ERROR([header file <libxml/parser.h> is required for XML support])])\nfi\n\nif test \"$with_libxslt\" = yes ; then\n  AC_CHECK_HEADER(libxslt/xslt.h, [], [AC_MSG_ERROR([header file <libxslt/xslt.h> is required for XSLT support])])\nfi\n\n# PGAC_LDAP_SAFE\n# --------------\n# PostgreSQL sometimes loads libldap_r and plain libldap into the same\n# process.  Check for OpenLDAP versions known not to tolerate doing so; assume\n# non-OpenLDAP implementations are safe.  The dblink test suite exercises the\n# hazardous interaction directly.\n\nAC_DEFUN([PGAC_LDAP_SAFE],\n[AC_CACHE_CHECK([for compatible LDAP implementation], [pgac_cv_ldap_safe],\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[#include <ldap.h>\n#if !defined(LDAP_VENDOR_VERSION) || \\\n     (defined(LDAP_API_FEATURE_X_OPENLDAP) && \\\n      LDAP_VENDOR_VERSION >= 20424 && LDAP_VENDOR_VERSION <= 20431)\nchoke me\n#endif], [])],\n[pgac_cv_ldap_safe=yes],\n[pgac_cv_ldap_safe=no])])\n\nif test \"$pgac_cv_ldap_safe\" != yes; then\n  AC_MSG_WARN([\n*** With OpenLDAP versions 2.4.24 through 2.4.31, inclusive, each backend\n*** process that loads libpq (via WAL receiver, dblink, or postgres_fdw) and\n*** also uses LDAP will crash on exit.])\nfi])\n\n\n\nif test \"$with_ldap\" = yes ; then\n  if test \"$PORTNAME\" != \"win32\"; then\n     AC_CHECK_HEADERS(ldap.h, [],\n                      [AC_MSG_ERROR([header file <ldap.h> is required for LDAP])])\n     PGAC_LDAP_SAFE\n  else\n     AC_CHECK_HEADERS(winldap.h, [],\n                      [AC_MSG_ERROR([header file <winldap.h> is required for LDAP])],\n                      [AC_INCLUDES_DEFAULT\n#include <windows.h>\n                      ])\n  fi\nfi\n\nif test \"$with_bonjour\" = yes ; then\n  AC_CHECK_HEADER(dns_sd.h, [], [AC_MSG_ERROR([header file <dns_sd.h> is required for Bonjour])])\ndnl At some point we might add something like\ndnl AC_SEARCH_LIBS(DNSServiceRegister, dns_sd)\ndnl but right now, what that would mainly accomplish is to encourage\ndnl people to try to use the avahi implementation, which does not work.\ndnl If you want to use Apple's own Bonjour code on another platform,\ndnl just add -ldns_sd to LIBS manually.\nfi\n\n# for contrib/uuid-ossp\nif test \"$with_uuid\" = bsd ; then\n  AC_CHECK_HEADERS(uuid.h,\n    [AC_EGREP_HEADER([uuid_to_string], uuid.h, [],\n      [AC_MSG_ERROR([header file <uuid.h> does not match BSD UUID library])])],\n    [AC_MSG_ERROR([header file <uuid.h> is required for BSD UUID])])\nelif test \"$with_uuid\" = e2fs ; then\n  AC_CHECK_HEADERS(uuid/uuid.h,\n    [AC_EGREP_HEADER([uuid_generate], uuid/uuid.h, [],\n      [AC_MSG_ERROR([header file <uuid/uuid.h> does not match E2FS UUID library])])],\n    [AC_CHECK_HEADERS(uuid.h,\n      [AC_EGREP_HEADER([uuid_generate], uuid.h, [],\n        [AC_MSG_ERROR([header file <uuid.h> does not match E2FS UUID library])])],\n      [AC_MSG_ERROR([header file <uuid/uuid.h> or <uuid.h> is required for E2FS UUID])])])\nelif test \"$with_uuid\" = ossp ; then\n  AC_CHECK_HEADERS(ossp/uuid.h,\n    [AC_EGREP_HEADER([uuid_export], ossp/uuid.h, [],\n      [AC_MSG_ERROR([header file <ossp/uuid.h> does not match OSSP UUID library])])],\n    [AC_CHECK_HEADERS(uuid.h,\n      [AC_EGREP_HEADER([uuid_export], uuid.h, [],\n        [AC_MSG_ERROR([header file <uuid.h> does not match OSSP UUID library])])],\n      [AC_MSG_ERROR([header file <ossp/uuid.h> or <uuid.h> is required for OSSP UUID])])])\nfi\n\n# For processor affinity support in Linux on NUMA platforms such as\n# AMD x86_64, the 'numactl' or 'libnuma' package is required.  See\n#  http://lwn.net/Articles/67005/\n#  http://www.x86-64.org/pipermail/discuss/2003-May/003528.html\ncase $template in\n  linux*)\n    AC_CHECK_LIB(numa, numa_available)\n    AC_CHECK_HEADERS([numa.h])\n    ;;\nesac\n\n# realtime library header\nif test \"$with_rt\" = yes; then\n\tAC_CHECK_HEADERS([time.h], [],\n\t\t\t [AC_MSG_ERROR([header file <time.h> is required for realtime library support])])\nfi\n\nif test \"$enable_mapreduce\" = yes; then\n  if test \"$with_perl\" = no; then\n    AC_MSG_ERROR([Greenplum Mapreduce requires Perl, reconfigure with --with-perl])\n  fi\n  AC_CHECK_HEADERS(yaml.h, [], [AC_MSG_ERROR([header file <yaml.h> is required for Greenplum Mapreduce])])\nfi\n\n# Check for Greenplum Query Optimizer (orca) and supporting Greenplum OS header files.\nif test \"$enable_orca\" = yes; then\n  PGAC_CHECK_ORCA_HEADERS\n  PGAC_CHECK_ORCA_VERSION\nfi\n\nif test \"$PORTNAME\" = \"win32\" ; then\n   AC_CHECK_HEADERS(crtdefs.h)\nfi\n\n# OpenBSD requires libexecinfo from ports for backtrace() as it's a glibc addition\nif test \"$PORTNAME\" = \"openbsd\"; then\n  AC_CHECK_HEADERS([execinfo.h], [], [AC_MSG_ERROR([header file <execinfo.h> is required for backtrace support])])\nfi\n\n##\n## Types, structures, compiler characteristics\n##\n\nm4_defun([AC_PROG_CC_STDC], []) dnl We don't want that.\nAC_C_BIGENDIAN\nPGAC_C_INLINE\nPGAC_PRINTF_ARCHETYPE\nAC_C_FLEXIBLE_ARRAY_MEMBER\nPGAC_C_SIGNED\nPGAC_C_FUNCNAME_SUPPORT\nPGAC_C_STATIC_ASSERT\nPGAC_C_TYPES_COMPATIBLE\nPGAC_C_BUILTIN_CONSTANT_P\nPGAC_C_BUILTIN_UNREACHABLE\nPGAC_C_VA_ARGS\nPGAC_STRUCT_TIMEZONE\nPGAC_UNION_SEMUN\nPGAC_STRUCT_SOCKADDR_UN\nPGAC_STRUCT_SOCKADDR_STORAGE\nPGAC_STRUCT_SOCKADDR_STORAGE_MEMBERS\nPGAC_STRUCT_ADDRINFO\nAC_TYPE_INTPTR_T\nAC_TYPE_UINTPTR_T\nAC_TYPE_LONG_LONG_INT\n\nPGAC_TYPE_LOCALE_T\n\nAC_CHECK_TYPES([struct cmsgcred], [], [],\n[#include <sys/socket.h>\n#include <sys/param.h>\n#ifdef HAVE_SYS_UCRED_H\n#include <sys/ucred.h>\n#endif])\n\nAC_CHECK_TYPES([struct option], [], [],\n[#ifdef HAVE_GETOPT_H\n#include <getopt.h>\n#endif])\n\nif test \"$with_zlib\" = yes; then\n  # Check that <zlib.h> defines z_streamp (versions before about 1.0.4\n  # did not).  While we could work around the lack of z_streamp, it\n  # seems unwise to encourage people to use such old zlib versions...\n  AC_CHECK_TYPE(z_streamp, [], [AC_MSG_ERROR([zlib version is too old\nUse --without-zlib to disable zlib support.])],\n                [#include <zlib.h>])\nfi\n\n# On PPC, check if assembler supports LWARX instruction's mutex hint bit\ncase $host_cpu in\n  ppc*|powerpc*)\n    AC_MSG_CHECKING([whether assembler supports lwarx hint bit])\n    AC_TRY_COMPILE([],\n\t[int a = 0; int *p = &a; int r;\n\t __asm__ __volatile__ (\" lwarx %0,0,%1,1\\n\" : \"=&r\"(r) : \"r\"(p));],\n\t[pgac_cv_have_ppc_mutex_hint=yes],\n\t[pgac_cv_have_ppc_mutex_hint=no])\n    AC_MSG_RESULT([$pgac_cv_have_ppc_mutex_hint])\n    if test x\"$pgac_cv_have_ppc_mutex_hint\" = xyes ; then\n\tAC_DEFINE(HAVE_PPC_LWARX_MUTEX_HINT, 1, [Define to 1 if the assembler supports PPC's LWARX mutex hint bit.])\n    fi\n  ;;\nesac\n\n# Check largefile support.  You might think this is a system service not a\n# compiler characteristic, but you'd be wrong.  We must check this before\n# probing existence of related functions such as fseeko, since the largefile\n# defines can affect what is generated for that.\nif test \"$PORTNAME\" != \"win32\"; then\n   AC_SYS_LARGEFILE\n   dnl Autoconf 2.69's AC_SYS_LARGEFILE believes it's a good idea to #define\n   dnl _DARWIN_USE_64_BIT_INODE, but it isn't: on OS X 10.5 that activates a\n   dnl bug that causes readdir() to sometimes return EINVAL.  On later OS X\n   dnl versions where the feature actually works, it's on by default anyway.\n   AH_VERBATIM([_DARWIN_USE_64_BIT_INODE],[])\nfi\n\n# Check for largefile support (must be after AC_SYS_LARGEFILE)\nAC_CHECK_SIZEOF([off_t])\n\n# If we don't have largefile support, can't handle segsize >= 2GB.\nif test \"$ac_cv_sizeof_off_t\" -lt 8 -a \"$segsize\" != \"1\"; then\n   AC_MSG_ERROR([Large file support is not enabled. Segment size cannot be larger than 1GB.])\nfi\n\n\n##\n## Functions, global variables\n##\n\nPGAC_VAR_INT_TIMEZONE\nAC_FUNC_ACCEPT_ARGTYPES\nPGAC_FUNC_GETTIMEOFDAY_1ARG\nPGAC_FUNC_WCSTOMBS_L\n\n# Some versions of libedit contain strlcpy(), setproctitle(), and other\n# symbols that that library has no business exposing to the world.  Pending\n# acquisition of a clue by those developers, ignore libedit (including its\n# possible alias of libreadline) while checking for everything else.\nLIBS_including_readline=\"$LIBS\"\nLIBS=`echo \"$LIBS\" | sed -e 's/-ledit//g' -e 's/-lreadline//g'`\n\n# net-snmp has the same problem..\nLIBS=`echo \"$LIBS\" | sed -e 's/-lnetsnmp//g'`\n\nAC_CHECK_FUNCS(m4_normalize([\n\tcbrt\n\tdlopen\n\tfdatasync\n\tgetifaddrs\n\tgetpeerucred\n\tgetrlimit\n\tmbstowcs_l\n\tmemmove\n\tpoll\n\tposix_fallocate\n\tpstat\n\tpthread_is_threaded_np\n\treadlink\n\tsetproctitle\n\tsetsid\n\tshm_open\n\tsigprocmask\n\tsymlink\n\tsync_file_range\n\ttowlower\n\tuselocale\n\tutime\n\tutimes\n\twcstombs\n\twcstombs_l\n]))\n\nAC_REPLACE_FUNCS(fseeko)\ncase $host_os in\n\t# NetBSD uses a custom fseeko/ftello built on fsetpos/fgetpos\n\t# Mingw uses macros to access Win32 API calls\n\tnetbsd*|mingw*)\n\t\tAC_DEFINE(HAVE_FSEEKO, 1, [Define to 1 because replacement version used.])\n\t\tac_cv_func_fseeko=yes;;\n\t*)\n\t\tAC_FUNC_FSEEKO;;\nesac\n\n# posix_fadvise() is a no-op on Solaris, so don't incur function overhead\n# by calling it, 2009-04-02\n# http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/gen/posix_fadvise.c\ndnl must use AS_IF here, else AC_REQUIRES inside AC_CHECK_DECLS malfunctions\nAS_IF([test \"$PORTNAME\" != \"solaris\"], [\nAC_CHECK_FUNCS(posix_fadvise)\nAC_CHECK_DECLS(posix_fadvise, [], [], [#include <fcntl.h>])\n]) # fi\n\nAC_CHECK_DECLS(fdatasync, [], [], [#include <unistd.h>])\nAC_CHECK_DECLS([strlcat, strlcpy])\n# This is probably only present on Darwin, but may as well check always\nAC_CHECK_DECLS(F_FULLFSYNC, [], [], [#include <fcntl.h>])\n\nHAVE_IPV6=no\nAC_CHECK_TYPE([struct sockaddr_in6],\n        [AC_DEFINE(HAVE_IPV6, 1, [Define to 1 if you have support for IPv6.])\n         HAVE_IPV6=yes],\n        [],\n[$ac_includes_default\n#include <netinet/in.h>])\nAC_SUBST(HAVE_IPV6)\n\nAC_CACHE_CHECK([for PS_STRINGS], [pgac_cv_var_PS_STRINGS],\n[AC_TRY_LINK(\n[#include <machine/vmparam.h>\n#include <sys/exec.h>\n],\n[PS_STRINGS->ps_nargvstr = 1;\nPS_STRINGS->ps_argvstr = \"foo\";],\n[pgac_cv_var_PS_STRINGS=yes],\n[pgac_cv_var_PS_STRINGS=no])])\nif test \"$pgac_cv_var_PS_STRINGS\" = yes ; then\n  AC_DEFINE([HAVE_PS_STRINGS], 1, [Define to 1 if the PS_STRINGS thing exists.])\nfi\n\n\n# We use our snprintf.c emulation if either snprintf() or vsnprintf()\n# is missing.  Yes, there are machines that have only one.  We may\n# also decide to use snprintf.c if snprintf() is present but does not\n# have all the features we need --- see below.\n\nif test \"$PORTNAME\" = \"win32\"; then\n  # Win32 gets snprintf.c built unconditionally.\n  #\n  # To properly translate all NLS languages strings, we must support the\n  # *printf() %$ format, which allows *printf() arguments to be selected\n  # by position in the translated string.\n  #\n  # libintl versions < 0.13 use the native *printf() functions, and Win32\n  # *printf() doesn't understand %$, so we must use our /port versions,\n  # which do understand %$. libintl versions >= 0.13 include their own\n  # *printf versions on Win32.  The libintl 0.13 release note text is:\n  #\n  #   C format strings with positions, as they arise when a translator\n  #   needs to reorder a sentence, are now supported on all platforms.\n  #   On those few platforms (NetBSD and Woe32) for which the native\n  #   printf()/fprintf()/... functions don't support such format\n  #   strings, replacements are provided through <libintl.h>.\n  #\n  # We could use libintl >= 0.13's *printf() if we were sure that we had\n  # a litint >= 0.13 at runtime, but seeing that there is no clean way\n  # to guarantee that, it is best to just use our own, so we are sure to\n  # get %$ support. In include/port.h we disable the *printf() macros\n  # that might have been defined by libintl.\n  #\n  # We do this unconditionally whether NLS is used or not so we are sure\n  # that all Win32 libraries and binaries behave the same.\n  pgac_need_repl_snprintf=yes\nelse\n  pgac_need_repl_snprintf=no\n  AC_CHECK_FUNCS(snprintf, [], pgac_need_repl_snprintf=yes)\n  AC_CHECK_FUNCS(vsnprintf, [], pgac_need_repl_snprintf=yes)\nfi\n\n\n# Check whether <stdio.h> declares snprintf() and vsnprintf(); if not,\n# include/c.h will provide declarations.  Note this is a separate test\n# from whether the functions exist in the C library --- there are\n# systems that have the functions but don't bother to declare them :-(\n\nAC_CHECK_DECLS([snprintf, vsnprintf])\n\n\ndnl Cannot use AC_CHECK_FUNC because isinf may be a macro\nAC_CACHE_CHECK([for isinf], ac_cv_func_isinf,\n[AC_TRY_LINK([\n#include <math.h>\ndouble glob_double;\n],\n[return isinf(glob_double) ? 0 : 1;],\n[ac_cv_func_isinf=yes],\n[ac_cv_func_isinf=no])])\n\nif test $ac_cv_func_isinf = yes ; then\n  AC_DEFINE(HAVE_ISINF, 1, [Define to 1 if you have isinf().])\nelse\n  AC_LIBOBJ(isinf)\n  # Look for a way to implement a substitute for isinf()\n  AC_CHECK_FUNCS([fpclass fp_class fp_class_d class], [break])\nfi\n\nAC_REPLACE_FUNCS([crypt fls getopt getrusage inet_aton mkdtemp random rint srandom strerror strlcat strlcpy])\n\ncase $host_os in\n\n        # Windows uses a specialised env handler\n        # and doesn't need a replacement getpeereid because it doesn't use\n        # Unix sockets.\n        mingw*)\n                AC_DEFINE(HAVE_UNSETENV, 1, [Define to 1 because replacement version used.])\n                AC_DEFINE(HAVE_GETPEEREID, 1, [Define to 1 because function not required.])\n                ac_cv_func_unsetenv=yes\n                ac_cv_func_getpeereid=yes;;\n        *)\n                AC_REPLACE_FUNCS([unsetenv getpeereid])\n\t\t;;\nesac\n\n# System's version of getaddrinfo(), if any, may be used only if we found\n# a definition for struct addrinfo; see notes in src/include/getaddrinfo.h.\n# (Note: the AC_REPLACE_FUNCS probe fails on Windows, where the available\n# versions of getaddrinfo don't follow normal C call protocol.  This is OK\n# because we want to use our own getaddrinfo.c on Windows anyway.)\nif test x\"$ac_cv_type_struct_addrinfo\" = xyes ; then\n  AC_REPLACE_FUNCS([getaddrinfo])\nelse\n  AC_LIBOBJ(getaddrinfo)\nfi\n\n# Similarly, use system's getopt_long() only if system provides struct option.\nif test x\"$ac_cv_type_struct_option\" = xyes ; then\n  AC_REPLACE_FUNCS([getopt_long])\nelse\n  AC_LIBOBJ(getopt_long)\nfi\n\n# On OpenBSD and Solaris, getopt() doesn't do what we want for long options\n# (i.e., allow '-' as a flag character), so use our version on those platforms.\nif test \"$PORTNAME\" = \"openbsd\" -o \"$PORTNAME\" = \"solaris\"; then\n  AC_LIBOBJ(getopt)\nfi\n\n# mingw has adopted a GNU-centric interpretation of optind/optreset,\n# so always use our version on Windows.\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_LIBOBJ(getopt)\n  AC_LIBOBJ(getopt_long)\nfi\n\n# Win32 (really MinGW) support\nif test \"$PORTNAME\" = \"win32\"; then\n  AC_CHECK_FUNCS(_configthreadlocale)\n  AC_REPLACE_FUNCS(gettimeofday)\n  AC_LIBOBJ(dirmod)\n  AC_LIBOBJ(kill)\n  AC_LIBOBJ(open)\n  AC_LIBOBJ(system)\n  AC_LIBOBJ(win32env)\n  AC_LIBOBJ(win32error)\n  AC_LIBOBJ(win32setlocale)\n  AC_DEFINE([HAVE_SYMLINK], 1,\n            [Define to 1 if you have the `symlink' function.])\n  AC_CHECK_TYPES(MINIDUMP_TYPE, [pgac_minidump_type=yes], [pgac_minidump_type=no], [\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <string.h>\n#include <dbghelp.h>])\nfi\nif test x\"$pgac_minidump_type\" = x\"yes\" ; then\n  AC_SUBST(have_win32_dbghelp,yes)\nelse\n  AC_SUBST(have_win32_dbghelp,no)\nfi\n\n# Cygwin needs only a bit of that\nif test \"$PORTNAME\" = \"cygwin\"; then\n  AC_LIBOBJ(dirmod)\nfi\n\ndnl Cannot use AC_CHECK_FUNC because sigsetjmp may be a macro\ndnl (especially on GNU libc)\ndnl See also comments in c.h.\nAC_CACHE_CHECK([for sigsetjmp], pgac_cv_func_sigsetjmp,\n[AC_TRY_LINK([#include <setjmp.h>],\n            [sigjmp_buf x; sigsetjmp(x, 1);],\n            [pgac_cv_func_sigsetjmp=yes],\n            [pgac_cv_func_sigsetjmp=no])])\nif test x\"$pgac_cv_func_sigsetjmp\" = x\"yes\"; then\n  AC_DEFINE(HAVE_SIGSETJMP, 1, [Define to 1 if you have sigsetjmp().])\nfi\n\nAC_DECL_SYS_SIGLIST\n\nAC_CHECK_FUNC(syslog,\n              [AC_CHECK_HEADER(syslog.h,\n                               [AC_DEFINE(HAVE_SYSLOG, 1, [Define to 1 if you have the syslog interface.])])])\n\nAC_CACHE_CHECK([for opterr], pgac_cv_var_int_opterr,\n[AC_TRY_LINK([#include <unistd.h>],\n  [extern int opterr; opterr = 1;],\n  [pgac_cv_var_int_opterr=yes],\n  [pgac_cv_var_int_opterr=no])])\nif test x\"$pgac_cv_var_int_opterr\" = x\"yes\"; then\n  AC_DEFINE(HAVE_INT_OPTERR, 1, [Define to 1 if you have the global variable 'int opterr'.])\nfi\n\nAC_CACHE_CHECK([for optreset], pgac_cv_var_int_optreset,\n[AC_TRY_LINK([#include <unistd.h>],\n  [extern int optreset; optreset = 1;],\n  [pgac_cv_var_int_optreset=yes],\n  [pgac_cv_var_int_optreset=no])])\nif test x\"$pgac_cv_var_int_optreset\" = x\"yes\"; then\n  AC_DEFINE(HAVE_INT_OPTRESET, 1, [Define to 1 if you have the global variable 'int optreset'.])\nfi\n\nAC_CHECK_FUNCS([strtoll __strtoll strtoq], [break])\nAC_CHECK_FUNCS([strtoull __strtoull strtouq], [break])\n# strto[u]ll may exist but not be declared\nAC_CHECK_DECLS([strtoll, strtoull])\n\nAC_CACHE_CHECK([for builtin locking functions], pgac_cv_gcc_int_atomics,\n[AC_TRY_LINK([],\n  [int lock = 0;\n   __sync_lock_test_and_set(&lock, 1);\n   __sync_lock_release(&lock);],\n  [pgac_cv_gcc_int_atomics=\"yes\"],\n  [pgac_cv_gcc_int_atomics=\"no\"])])\nif test x\"$pgac_cv_gcc_int_atomics\" = x\"yes\"; then\n  AC_DEFINE(HAVE_GCC_INT_ATOMICS, 1, [Define to 1 if you have __sync_lock_test_and_set(int *) and friends.])\nfi\n\n# Lastly, restore full LIBS list and check for readline/libedit symbols\nLIBS=\"$LIBS_including_readline\"\n\nif test \"$with_readline\" = yes; then\n  PGAC_VAR_RL_COMPLETION_APPEND_CHARACTER\n  AC_CHECK_FUNCS([rl_completion_matches rl_filename_completion_function rl_reset_screen_size])\n  AC_CHECK_FUNCS([append_history history_truncate_file])\nfi\n\n\n# This test makes sure that run tests work at all.  Sometimes a shared\n# library is found by the linker, but the runtime linker can't find it.\n# This check should come after all modifications of compiler or linker\n# variables, and before any other run tests.\nAC_MSG_CHECKING([test program])\nAC_TRY_RUN([int main() { return 0; }],\n[AC_MSG_RESULT(ok)],\n[AC_MSG_RESULT(failed)\nAC_MSG_ERROR([[\nCould not execute a simple test program.  This may be a problem\nrelated to locating shared libraries.  Check the file 'config.log'\nfor the exact reason.]])],\n[AC_MSG_RESULT([cross-compiling])])\n\n# --------------------\n# Run tests below here\n# --------------------\n\n# Force use of our snprintf if system's doesn't do arg control\n# See comment above at snprintf test for details.\nif test \"$enable_nls\" = yes -a \"$pgac_need_repl_snprintf\" = no; then\n  PGAC_FUNC_SNPRINTF_ARG_CONTROL\n  if test $pgac_cv_snprintf_arg_control != yes ; then\n    pgac_need_repl_snprintf=yes\n  fi\nfi\n\n\ndnl Check to see if we have a working 64-bit integer type.\ndnl This breaks down into two steps:\ndnl (1) figure out if the compiler has a 64-bit int type with working\ndnl arithmetic, and if so\ndnl (2) see whether snprintf() can format the type correctly.  (Currently,\ndnl snprintf is the only library routine we really need for int8 support.)\ndnl It's entirely possible to have a compiler that handles a 64-bit type\ndnl when the C library doesn't; this is fairly likely when using gcc on\ndnl an older platform, for example.\ndnl If there is no native snprintf() or it does not handle the 64-bit type,\ndnl we force our own version of snprintf() to be used instead.\ndnl Note this test must be run after our initial check for snprintf/vsnprintf.\n\ndnl As of Postgres 8.4, we no longer support compilers without a working\ndnl 64-bit type.  But we still handle the case of snprintf being broken.\n\nPGAC_TYPE_64BIT_INT([long int])\n\nif test x\"$HAVE_LONG_INT_64\" = x\"yes\" ; then\n  pg_int64_type=\"long int\"\nelse\n  PGAC_TYPE_64BIT_INT([long long int])\n  if test x\"$HAVE_LONG_LONG_INT_64\" = x\"yes\" ; then\n    pg_int64_type=\"long long int\"\n  else\n    AC_MSG_ERROR([Cannot find a working 64-bit integer type.])\n  fi\nfi\n\nAC_DEFINE_UNQUOTED(PG_INT64_TYPE, $pg_int64_type,\n  [Define to the name of a signed 64-bit integer type.])\n\n# If we found \"long int\" is 64 bits, assume snprintf handles it.  If\n# we found we need to use \"long long int\", better check.  We cope with\n# snprintfs that use %lld, %qd, or %I64d as the format.  If none of these\n# work, fall back to our own snprintf emulation (which we know uses %lld).\n\nif test \"$HAVE_LONG_LONG_INT_64\" = yes ; then\n  if test $pgac_need_repl_snprintf = no; then\n    PGAC_FUNC_SNPRINTF_LONG_LONG_INT_FORMAT\n    if test \"$LONG_LONG_INT_FORMAT\" = \"\"; then\n      # Force usage of our own snprintf, since system snprintf is broken\n      pgac_need_repl_snprintf=yes\n      LONG_LONG_INT_FORMAT='%lld'\n    fi\n  else\n    # Here if we previously decided we needed to use our own snprintf\n    LONG_LONG_INT_FORMAT='%lld'\n  fi\n  LONG_LONG_UINT_FORMAT=`echo \"$LONG_LONG_INT_FORMAT\" | sed 's/d$/u/'`\n  INT64_FORMAT=\"\\\"$LONG_LONG_INT_FORMAT\\\"\"\n  UINT64_FORMAT=\"\\\"$LONG_LONG_UINT_FORMAT\\\"\"\nelse\n  # Here if we are not using 'long long int' at all\n  INT64_FORMAT='\"%ld\"'\n  UINT64_FORMAT='\"%lu\"'\nfi\n\nAC_DEFINE_UNQUOTED(INT64_FORMAT, $INT64_FORMAT,\n                   [Define to the appropriate snprintf format for 64-bit ints.])\n\nAC_DEFINE_UNQUOTED(UINT64_FORMAT, $UINT64_FORMAT,\n                   [Define to the appropriate snprintf format for unsigned 64-bit ints.])\n\n# Also force use of our snprintf if the system's doesn't support the %z flag.\nif test \"$pgac_need_repl_snprintf\" = no; then\n  PGAC_FUNC_SNPRINTF_SIZE_T_SUPPORT\n  if test \"$pgac_cv_snprintf_size_t_support\" != yes; then\n    pgac_need_repl_snprintf=yes\n  fi\nfi\n\n# Now we have checked all the reasons to replace snprintf\nif test $pgac_need_repl_snprintf = yes; then\n  AC_DEFINE(USE_REPL_SNPRINTF, 1, [Use replacement snprintf() functions.])\n  AC_LIBOBJ(snprintf)\nfi\n\n# Check size of void *, size_t (enables tweaks for > 32bit address space)\nAC_CHECK_SIZEOF([void *])\nAC_CHECK_SIZEOF([size_t])\nAC_CHECK_SIZEOF([long])\n\n# In GPDB, float4 and float8 are always passed by value. There is\n# GPDB-specific code that assumes that in various places, so it's not\n# configurable.\nfloat4passbyval=true\nAC_DEFINE([USE_FLOAT4_BYVAL], 1, [Define to 1 if you want float4 values to be passed by value. (Always defined in GPDB)])\nAC_DEFINE_UNQUOTED([FLOAT4PASSBYVAL], [$float4passbyval], [float4 values are passed by value if 'true', by reference if 'false' (always true in GPDB)])\n\n# Note: this setting also controls int8 and related types such as timestamp.\nfloat8passbyval=true\nAC_DEFINE([USE_FLOAT8_BYVAL], 1, [Define to 1 if you want float8, int8, etc values to be passed by value. (Always defined in GPDB)])\nAC_DEFINE_UNQUOTED([FLOAT8PASSBYVAL], [$float8passbyval], [float8, int8, and related values are passed by value if 'true', by reference if 'false' (always true in GPDB)])\n\n# Determine memory alignment requirements for the basic C data types.\n\nAC_CHECK_ALIGNOF(short)\nAC_CHECK_ALIGNOF(int)\nAC_CHECK_ALIGNOF(long)\nif test x\"$HAVE_LONG_LONG_INT_64\" = x\"yes\" ; then\n  AC_CHECK_ALIGNOF(long long int)\nfi\nAC_CHECK_ALIGNOF(double)\n\n# Compute maximum alignment of any basic type.\n# We assume long's alignment is at least as strong as char, short, or int;\n# but we must check long long (if it is being used for int64) and double.\n# Note that we intentionally do not consider any types wider than 64 bits,\n# as allowing MAXIMUM_ALIGNOF to exceed 8 would be too much of a penalty\n# for disk and memory space.\n\nMAX_ALIGNOF=$ac_cv_alignof_long\nif test $MAX_ALIGNOF -lt $ac_cv_alignof_double ; then\n  MAX_ALIGNOF=$ac_cv_alignof_double\nfi\nif test x\"$HAVE_LONG_LONG_INT_64\" = xyes && test $MAX_ALIGNOF -lt $ac_cv_alignof_long_long_int ; then\n  MAX_ALIGNOF=\"$ac_cv_alignof_long_long_int\"\nfi\nAC_DEFINE_UNQUOTED(MAXIMUM_ALIGNOF, $MAX_ALIGNOF, [Define as the maximum alignment requirement of any C data type.])\n\n\n# Some platforms predefine the types int8, int16, etc.  Only check\n# a (hopefully) representative subset.\nAC_CHECK_TYPES([int8, uint8, int64, uint64], [], [],\n[#include <stdio.h>])\n\n# We also check for sig_atomic_t, which *should* be defined per ANSI\n# C, but is missing on some old platforms.\nAC_CHECK_TYPES(sig_atomic_t, [], [], [#include <signal.h>])\n\n# Some compilers offer a 128-bit integer scalar type.\nPGAC_TYPE_128BIT_INT\n\n# Check for various atomic operations now that we have checked how to declare\n# 64bit integers.\nPGAC_HAVE_GCC__SYNC_CHAR_TAS\nPGAC_HAVE_GCC__SYNC_INT32_TAS\nPGAC_HAVE_GCC__SYNC_INT32_CAS\nPGAC_HAVE_GCC__SYNC_INT64_CAS\nPGAC_HAVE_GCC__ATOMIC_INT32_CAS\nPGAC_HAVE_GCC__ATOMIC_INT64_CAS\n\n\nif test \"$PORTNAME\" != \"win32\"\nthen\nPGAC_FUNC_POSIX_SIGNALS\nif test \"$pgac_cv_func_posix_signals\" != yes -a \"$enable_thread_safety\" = yes; then\n  AC_MSG_ERROR([\nThread-safety requires POSIX signals, which are not supported by this\noperating system;  use --disable-thread-safety to disable thread safety.])\nfi\nfi\n\nif test $ac_cv_func_fseeko = yes; then\nAC_SYS_LARGEFILE\nenable_largefile=yes\nelse\nenable_largefile=no\nfi\nAC_SUBST(enable_largefile)\n\n# Check for largefile support (must be after AC_SYS_LARGEFILE)\nAC_CHECK_SIZEOF([off_t])\n\nif test \"$PORTNAME\" != \"win32\"; then\n# If we don't have largefile support, can't handle segsize >= 2GB.\nif test \"$ac_cv_sizeof_off_t\" -lt 8 -a \"$segsize\" != \"1\"; then\n   AC_MSG_ERROR([Large file support is not enabled. Segment size cannot be larger than 1GB.])\nfi\nfi\n\n\n# Select semaphore implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  if test x\"$USE_NAMED_POSIX_SEMAPHORES\" = x\"1\" ; then\n    AC_DEFINE(USE_NAMED_POSIX_SEMAPHORES, 1, [Define to select named POSIX semaphores.])\n    SEMA_IMPLEMENTATION=\"src/backend/port/posix_sema.c\"\n  else\n    if test x\"$USE_UNNAMED_POSIX_SEMAPHORES\" = x\"1\" ; then\n      AC_DEFINE(USE_UNNAMED_POSIX_SEMAPHORES, 1, [Define to select unnamed POSIX semaphores.])\n      SEMA_IMPLEMENTATION=\"src/backend/port/posix_sema.c\"\n    else\n  AC_DEFINE(USE_SYSV_SEMAPHORES, 1, [Define to select SysV-style semaphores.])\n  SEMA_IMPLEMENTATION=\"src/backend/port/sysv_sema.c\"\n    fi\n  fi\nelse\n  AC_DEFINE(USE_WIN32_SEMAPHORES, 1, [Define to select Win32-style semaphores.])\n  SEMA_IMPLEMENTATION=\"src/backend/port/win32_sema.c\"\nfi\n\n\n# Select shared-memory implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  AC_DEFINE(USE_SYSV_SHARED_MEMORY, 1, [Define to select SysV-style shared memory.])\n  SHMEM_IMPLEMENTATION=\"src/backend/port/sysv_shmem.c\"\nelse\n  AC_DEFINE(USE_WIN32_SHARED_MEMORY, 1, [Define to select Win32-style shared memory.])\n  SHMEM_IMPLEMENTATION=\"src/backend/port/win32_shmem.c\"\nfi\n\n# Select latch implementation type.\nif test \"$PORTNAME\" != \"win32\"; then\n  LATCH_IMPLEMENTATION=\"src/backend/port/unix_latch.c\"\nelse\n  LATCH_IMPLEMENTATION=\"src/backend/port/win32_latch.c\"\nfi\n\n# If not set in template file, set bytes to use libc memset()\nif test x\"$MEMSET_LOOP_LIMIT\" = x\"\" ; then\n  MEMSET_LOOP_LIMIT=1024\nfi\nAC_DEFINE_UNQUOTED(MEMSET_LOOP_LIMIT, ${MEMSET_LOOP_LIMIT}, [Define bytes to use libc memset().])\n\n\nif test \"$enable_nls\" = yes ; then\n  PGAC_CHECK_GETTEXT\nfi\n\n# Check for Tcl configuration script tclConfig.sh\nif test \"$with_tcl\" = yes; then\n    PGAC_PATH_TCLCONFIGSH([$with_tclconfig])\n    PGAC_EVAL_TCLCONFIGSH([$TCL_CONFIG_SH],\n                          [TCL_INCLUDE_SPEC,TCL_LIB_FILE,TCL_LIBS,TCL_LIB_SPEC,TCL_SHARED_BUILD])\n    AC_SUBST(TCL_SHLIB_LD_LIBS)dnl don't want to double-evaluate that one\n    # now that we have TCL_INCLUDE_SPEC, we can check for <tcl.h>\n    ac_save_CPPFLAGS=$CPPFLAGS\n    CPPFLAGS=\"$TCL_INCLUDE_SPEC $CPPFLAGS\"\n    AC_CHECK_HEADER(tcl.h, [], [AC_MSG_ERROR([header file <tcl.h> is required for Tcl])])\n    CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\n# check for <perl.h>\nif test \"$with_perl\" = yes; then\n  ac_save_CPPFLAGS=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $perl_includespec\"\n  AC_CHECK_HEADER(perl.h, [], [AC_MSG_ERROR([header file <perl.h> is required for Perl])],\n                  [#include <EXTERN.h>])\n  # While we're at it, check that we can link to libperl.\n  # On most platforms, if perl.h is there then libperl.so will be too, but at\n  # this writing Debian packages them separately.  There is no known reason to\n  # waste cycles on separate probes for the Tcl or Python libraries, though.\n  pgac_save_LIBS=$LIBS\n  LIBS=\"$perl_embed_ldflags\"\n  AC_MSG_CHECKING([for libperl])\n  AC_TRY_LINK([\n#include <EXTERN.h>\n#include <perl.h>\n],  [perl_alloc();],\n    [AC_MSG_RESULT(yes)],\n    [AC_MSG_RESULT(no)\n     AC_MSG_ERROR([libperl library is required for Perl])])\n  LIBS=$pgac_save_LIBS\n  CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\n# check for <Python.h>\nif test \"$with_python\" = yes; then\n  ac_save_CPPFLAGS=$CPPFLAGS\n  CPPFLAGS=\"$python_includespec $CPPFLAGS\"\n  AC_CHECK_HEADER(Python.h, [], [AC_MSG_ERROR([header file <Python.h> is required for Python])])\n  CPPFLAGS=$ac_save_CPPFLAGS\nfi\n\n#\n# Check for DocBook and tools\n#\nPGAC_PROG_NSGMLS\nPGAC_PROG_JADE\nPGAC_CHECK_DOCBOOK(4.2)\nPGAC_PATH_DOCBOOK_STYLESHEETS\nPGAC_PATH_COLLATEINDEX\nAC_CHECK_PROGS(XSLTPROC, xsltproc)\nAC_CHECK_PROGS(OSX, [osx sgml2xml sx])\n\n#\n# Check for test tools\n#\nif test \"$enable_tap_tests\" = yes; then\n  AC_CHECK_PROGS(PROVE, prove)\n  if test -z \"$PROVE\"; then\n    AC_MSG_ERROR([prove not found])\n  fi\n  if test -z \"$PERL\"; then\n    AC_MSG_ERROR([Perl not found])\n  fi\n  # Check for necessary modules\n  AX_PROG_PERL_MODULES([IPC::Run Test::More=0.82], ,\n    AC_MSG_ERROR([Perl modules IPC::Run and Test::More 0.82 are required to run TAP tests]))\nfi\n\n# Thread testing\n\n# We have to run the thread test near the end so we have all our symbols\n# defined.  Cross compiling throws a warning.\n#\nif test \"$enable_thread_safety\" = yes; then\nif test \"$PORTNAME\" != \"win32\"\nthen\nAC_MSG_CHECKING([thread safety of required library functions])\n\n_CFLAGS=\"$CFLAGS\"\n_LIBS=\"$LIBS\"\nCFLAGS=\"$CFLAGS $PTHREAD_CFLAGS -DIN_CONFIGURE\"\nLIBS=\"$LIBS $PTHREAD_LIBS\"\nAC_TRY_RUN([#include \"$srcdir/src/test/thread/thread_test.c\"],\n  [AC_MSG_RESULT(yes)],\n  [AC_MSG_RESULT(no)\n  AC_MSG_ERROR([thread test program failed\nThis platform is not thread-safe.  Check the file 'config.log' or compile\nand run src/test/thread/thread_test for the exact reason.\nUse --disable-thread-safety to disable thread safety.])],\n  [AC_MSG_RESULT(maybe)\n  AC_MSG_WARN([\n*** Skipping thread test program because of cross-compile build.\n*** Run the program in src/test/thread on the target machine.\n])])\nCFLAGS=\"$_CFLAGS\"\nLIBS=\"$_LIBS\"\nelse\nAC_MSG_WARN([*** skipping thread test on Win32])\nfi\nfi\n\n# If compiler will take -Wl,--as-needed (or various platform-specific\n# spellings thereof) then add that to LDFLAGS.  This is much easier than\n# trying to filter LIBS to the minimum for each executable.\n# On (at least) some Red-Hat-derived systems, this switch breaks linking to\n# libreadline; therefore we postpone testing it until we know what library\n# dependencies readline has.  The test code will try to link with $LIBS.\nif test \"$with_readline\" = yes; then\n  link_test_func=readline\nelse\n  link_test_func=exit\nfi\n\nif test \"$PORTNAME\" = \"darwin\"; then\n  PGAC_PROG_CC_LDFLAGS_OPT([-Wl,-dead_strip_dylibs], $link_test_func)\nelif test \"$PORTNAME\" = \"openbsd\"; then\n  PGAC_PROG_CC_LDFLAGS_OPT([-Wl,-Bdynamic], $link_test_func)\nelse\n  PGAC_PROG_CC_LDFLAGS_OPT([-Wl,--as-needed], $link_test_func)\nfi\n\n# Many of the autoconf tests produce warnings, or even compiler errors, on\n# purpose as they run through the conftest programs. So, treating warning as\n# error should be last step after all autoconf checks are performed, otherwise\n# false side-effects happens.\nif test \"$GCC\" = yes -a \"$ICC\" = no; then\n  PGAC_PROG_CC_CFLAGS_OPT([-Werror=uninitialized])\n  PGAC_PROG_CC_CFLAGS_OPT([-Werror=implicit-function-declaration])\nfi\n\n# Begin output steps\n\nAC_MSG_NOTICE([using CFLAGS=$CFLAGS])\nAC_MSG_NOTICE([using CPPFLAGS=$CPPFLAGS])\nAC_MSG_NOTICE([using LDFLAGS=$LDFLAGS])\nAC_MSG_NOTICE([using LIBS=$LIBS])\n\n[BLD_ARCH=`echo $BLD_ARCH`]\nAC_SUBST(BLD_ARCH)\n\n# Get the Greenplum version string from VERSION\n\nGP_VERSION_LONG=`bash ./getversion`\n\nGP_VERSION_LONG=\"$GP_VERSION_LONG$with_extra_version\"\n\necho $GP_VERSION_LONG > VERSION\nGP_VERSION=`cat VERSION`\n\nGP_VERSION_SHORT=`bash ./getversion --short`\nGP_VERSION_SHORT=\"$GP_VERSION_SHORT$with_extra_version\"\nAC_SUBST(GP_VERSION_SHORT)\n\nGP_VERSION_IN=\"src/include/catalog/gp_version.in\"\nGP_VERSION_HEADER=\"src/include/catalog/gp_version.h\"\nif grep '\\$\\$' $GP_VERSION_IN > /dev/null 2>&1 ; then\n    sed \"s,\\\\$.*\\\\$\\\\$,$GP_VERSION,\" $GP_VERSION_IN > $GP_VERSION_HEADER\nfi\n\nGP_BASH_VERSION_IN=\"gpMgmt/bin/lib/gp_bash_version.sh.in\"\nGP_BASH_VERSION_SH=\"gpMgmt/bin/lib/gp_bash_version.sh\"\nif grep '##' $GP_BASH_VERSION_IN > /dev/null 2>&1 ; then\n    sed \"s,##.*##,$GP_VERSION,\" $GP_BASH_VERSION_IN > $GP_BASH_VERSION_SH\nfi\n\nGPTEST_IN=\"src/test/regress/GPTest.pm.in\"\nGPTEST_PM=\"src/test/regress/GPTest.pm\"\nif grep '##' $GPTEST_IN > /dev/null 2>&1 ; then\n    sed \"s,##.*##,$GP_VERSION,\" $GPTEST_IN > $GPTEST_PM\nfi\n\nAC_DEFINE_UNQUOTED(GP_VERSION,\n                   [\"$GP_VERSION\"],\n                   [A string containing the Greenplum version number])\n\n[GP_MAJORVERSION=`expr \"$GP_VERSION\" : '\\([0-9][0-9]*\\)'`]\nAC_SUBST(GP_MAJORVERSION)\nAC_DEFINE_UNQUOTED(GP_MAJORVERSION, \"$GP_MAJORVERSION\", [Greenplum major version as a string])\n\n# Create compiler version string\nif test x\"$GCC\" = x\"yes\" ; then\n  cc_string=`${CC} --version | sed q`\n  case $cc_string in [[A-Za-z]]*) ;; *) cc_string=\"GCC $cc_string\";; esac\nelif test x\"$SUN_STUDIO_CC\" = x\"yes\" ; then\n  cc_string=`${CC} -V 2>&1 | sed q`\nelse\n  cc_string=$CC\nfi\n\nAC_DEFINE_UNQUOTED(PG_VERSION_STR,\n                   [\"PostgreSQL $PG_VERSION (Greenplum Database $GP_VERSION) on $host, compiled by $cc_string, `expr $ac_cv_sizeof_void_p \\* 8`-bit\"],\n                   [A string containing the version number, platform, and C compiler])\n\n# Supply a numeric version string for use by 3rd party add-ons\n# awk -F is a regex on some platforms, and not on others, so make \".\" a tab\n[PG_VERSION_NUM=\"`echo \"$PG_PACKAGE_VERSION\" | sed 's/[A-Za-z].*$//' |\ntr '.' '\t' |\n$AWK '{printf \"%d%02d%02d\", $1, $2, (NF >= 3) ? $3 : 0}'`\"]\nAC_DEFINE_UNQUOTED(PG_VERSION_NUM, $PG_VERSION_NUM, [PostgreSQL version as a number])\nAC_SUBST(PG_VERSION_NUM)\n\n# If we are inserting PG_SYSROOT into CPPFLAGS, do so symbolically not\n# literally, so that it's possible to override it at build time using\n# a command like \"make ... PG_SYSROOT=path\".  This has to be done after\n# we've finished all configure checks that depend on CPPFLAGS.\nif test x\"$PG_SYSROOT\" != x; then\n  CPPFLAGS=`echo \"$CPPFLAGS\" | sed -e \"s| $PG_SYSROOT | \\\\\\$(PG_SYSROOT) |\"`\nfi\nAC_SUBST(PG_SYSROOT)\n\n#\n[GP_VERSION_NUM=\"`echo \"$PACKAGE_VERSION\" | sed 's/[A-Za-z].*$//' |\ntr '.' '\t' |\n$AWK '{printf \"%d%02d%02d\", $1, $2, (NF >= 3) ? $3 : 0}'`\"]\nAC_DEFINE_UNQUOTED(GP_VERSION_NUM, $GP_VERSION_NUM, [Greenplum version as a number])\n\n\n# Begin output steps\n\nAC_MSG_NOTICE([using compiler=$cc_string])\nAC_MSG_NOTICE([using CFLAGS=$CFLAGS])\nAC_MSG_NOTICE([using CPPFLAGS=$CPPFLAGS])\nAC_MSG_NOTICE([using LDFLAGS=$LDFLAGS])\n\n# prepare build tree if outside source tree\n# Note 1: test -ef might not exist, but it's more reliable than `pwd`.\n# Note 2: /bin/pwd might be better than shell's built-in at getting\n#         a symlink-free name.\nif ( test \"$srcdir\" -ef . ) >/dev/null 2>&1 || test \"`cd $srcdir && /bin/pwd`\" = \"`/bin/pwd`\"; then\n  vpath_build=no\nelse\n  vpath_build=yes\n  if test \"$no_create\" != yes; then\n    _AS_ECHO_N([preparing build tree... ])\n    pgac_abs_top_srcdir=`cd \"$srcdir\" && pwd`\n    $SHELL \"$ac_aux_dir/prep_buildtree\" \"$pgac_abs_top_srcdir\" \".\" \\\n      || AC_MSG_ERROR(failed)\n    AC_MSG_RESULT(done)\n  fi\nfi\nAC_SUBST(vpath_build)\n\n\nAC_CONFIG_FILES([GNUmakefile src/Makefile.global])\n\nAC_CONFIG_LINKS([\n  src/backend/port/dynloader.c:src/backend/port/dynloader/${template}.c\n  src/backend/port/pg_sema.c:${SEMA_IMPLEMENTATION}\n  src/backend/port/pg_shmem.c:${SHMEM_IMPLEMENTATION}\n  src/backend/port/pg_latch.c:${LATCH_IMPLEMENTATION}\n  src/include/dynloader.h:src/backend/port/dynloader/${template}.h\n  src/include/pg_config_os.h:src/include/port/${template}.h\n  src/Makefile.port:src/makefiles/Makefile.${template}\n])\n\nif test \"$PORTNAME\" = \"win32\"; then\nAC_CONFIG_COMMANDS([check_win32_symlinks],[\n# Links sometimes fail undetected on Mingw -\n# so here we detect it and warn the user\nfor FILE in $CONFIG_LINKS\n do\n\t# test -e works for symlinks in the MinGW console\n\ttest -e `expr \"$FILE\" : '\\([[^:]]*\\)'` || AC_MSG_WARN([*** link for $FILE -- please fix by hand])\n done\n])\nfi\n\nAC_CONFIG_HEADERS([src/include/pg_config.h],\n[\n# Update timestamp for pg_config.h (see Makefile.global)\necho >src/include/stamp-h\n])\n\nAC_CONFIG_HEADERS([src/include/pg_config_ext.h],\n[\n# Update timestamp for pg_config_ext.h (see Makefile.global)\necho >src/include/stamp-ext-h\n])\n\nAC_CONFIG_HEADERS([src/interfaces/ecpg/include/ecpg_config.h],\n                  [echo >src/interfaces/ecpg/include/stamp-h])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/include/pg_config.h.win32": "/* src/include/pg_config.h.  Generated by configure.  */\n/* src/include/pg_config.h.in.  Generated from configure.in by autoheader.  */\n\n#if defined(__i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n#if defined(__amd64) && !defined(__amd64__)\n#define __amd64__\n#endif\n\n#if defined(__x86_64) && !defined(__x86_64__)\n#define __x86_64__\n#endif\n\n#if defined(__sparc) && !defined(__sparc__)\n#define __sparc__\n#endif\n\n#ifndef\t\t\tBIG_ENDIAN\n#define\t\t\tBIG_ENDIAN\t\t4321\n#endif\n#ifndef\t\t\tLITTLE_ENDIAN\n#define\t\t\tLITTLE_ENDIAN\t1234\n#endif\n#ifndef\t\t\tPDP_ENDIAN\n#define\t\t\tPDP_ENDIAN\t\t3412\n#endif\n\n#ifndef\t\t\tBYTE_ORDER\n\n#ifdef __sparc__\n#define\t\t  BYTE_ORDER\t  BIG_ENDIAN\n#endif\n#if defined(__i386__) || defined(__x86_64__)\n#define\t\t BYTE_ORDER\t\t LITTLE_ENDIAN\n#endif\n#endif\n\n/* This file is generated from MingW ./configure, and with the following\n * changes to be valid for Visual C++ (and compatible):\n *\n * HAVE_CBRT, HAVE_FUNCNAME_FUNC, HAVE_FUNCNAME_FUNCTION, HAVE_GETOPT,\n * HAVE_GETOPT_H, HAVE_GETOPT_LONG, HAVE_LOCALE_T, HAVE_RINT, HAVE_STRINGS_H,\n * HAVE_STRTOLL, HAVE_STRTOULL, HAVE_STRUCT_OPTION, ENABLE_THREAD_SAFETY,\n * PG_USE_INLINE, inline, USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n *\n */\n\n/* Define to the type of arg 1 of 'accept' */\n#define ACCEPT_TYPE_ARG1 unsigned int\n\n/* Define to the type of arg 2 of 'accept' */\n#define ACCEPT_TYPE_ARG2 struct sockaddr *\n\n/* Define to the type of arg 3 of 'accept' */\n#define ACCEPT_TYPE_ARG3 int\n\n/* Define to the return type of 'accept' */\n#define ACCEPT_TYPE_RETURN unsigned int PASCAL\n\n/* The alignment requirement of a `double'. */\n#define ALIGNOF_DOUBLE 8\n\n/* The alignment requirement of a `int'. */\n#define ALIGNOF_INT 4\n\n/* The alignment requirement of a `long'. */\n#define ALIGNOF_LONG 4\n\n/* The alignment requirement of a `long long int'. */\n#define ALIGNOF_LONG_LONG_INT 8\n\n/* The normal alignment of `PG_INT128_TYPE', in bytes. */\n#undef ALIGNOF_PG_INT128_TYPE\n\n/* The alignment requirement of a `short'. */\n#define ALIGNOF_SHORT 2\n\n/* Define to the default TCP port number on which the server listens and to\n   which clients will try to connect. This can be overridden at run-time, but\n   it's convenient if your clients have the right default compiled in.\n   (--with-pgport=PORTNUM) */\n#define DEF_PGPORT 5432\n\n/* Define to the default TCP port number as a string constant. */\n#define DEF_PGPORT_STR \"5432\"\n\n/* Define to nothing if C supports flexible array members, and to 1 if it does\n   not. That way, with a declaration like `struct s { int n; double\n   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99\n   compilers. When computing the size of such an object, don't use 'sizeof\n   (struct s)' as it overestimates the size. Use 'offsetof (struct s, d)'\n   instead. Don't use 'offsetof (struct s, d[0])', as this doesn't work with\n   MSVC and with C++ compilers. */\n#define FLEXIBLE_ARRAY_MEMBER\n\n/* Define to 1 if you want National Language Support. (--enable-nls) */\n/* #undef ENABLE_NLS */\n\n/* Define to 1 to build client libraries as thread-safe code.\n   (--enable-thread-safety) */\n#define ENABLE_THREAD_SAFETY 1\n\n/* Define to 1 if getpwuid_r() takes a 5th argument. */\n/* #undef GETPWUID_R_5ARG */\n\n/* Define to 1 if gettimeofday() takes only 1 argument. */\n/* #undef GETTIMEOFDAY_1ARG */\n\n#ifdef GETTIMEOFDAY_1ARG\n# define gettimeofday(a,b) gettimeofday(a)\n#endif\n\n/* Define to 1 if you have the `cbrt' function. */\n//#define HAVE_CBRT 1\n\n/* Define to 1 if you have the `class' function. */\n/* #undef HAVE_CLASS */\n\n/* Define to 1 if you have the `crypt' function. */\n/* #undef HAVE_CRYPT */\n\n/* Define to 1 if you have the <crypt.h> header file. */\n/* #undef HAVE_CRYPT_H */\n\n/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you\n   don't. */\n#define HAVE_DECL_FDATASYNC 0\n\n/* Define to 1 if you have the declaration of `F_FULLFSYNC', and to 0 if you\n   don't. */\n#define HAVE_DECL_F_FULLFSYNC 0\n\n/* Define to 1 if you have the declaration of `snprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL_SNPRINTF 1\n\n/* Define to 1 if you have the declaration of `strtoll', and to 0 if you\n   don't. */\n#define HAVE_DECL_STRTOLL 1\n\n/* Define to 1 if you have the declaration of `strtoull', and to 0 if you\n   don't. */\n#define HAVE_DECL_STRTOULL 1\n\n/* Define to 1 if you have the declaration of `vsnprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL_VSNPRINTF 1\n\n/* Define to 1 if you have the <dld.h> header file. */\n/* #undef HAVE_DLD_H */\n\n/* Define to 1 if you have the `dlopen' function. */\n/* #undef HAVE_DLOPEN */\n\n/* Define to 1 if you have the <editline/history.h> header file. */\n/* #undef HAVE_EDITLINE_HISTORY_H */\n\n/* Define to 1 if you have the <editline/readline.h> header file. */\n/* #undef HAVE_EDITLINE_READLINE_H */\n\n/* Define to 1 if you have the `fcvt' function. */\n#define HAVE_FCVT 1\n\n/* Define to 1 if you have the `fdatasync' function. */\n/* #undef HAVE_FDATASYNC */\n\n/* Define to 1 if you have finite(). */\n#define HAVE_FINITE 1\n\n/* Define to 1 if you have the `fpclass' function. */\n/* #undef HAVE_FPCLASS */\n\n/* Define to 1 if you have the `fp_class' function. */\n/* #undef HAVE_FP_CLASS */\n\n/* Define to 1 if you have the `fp_class_d' function. */\n/* #undef HAVE_FP_CLASS_D */\n\n/* Define to 1 if you have the <fp_class.h> header file. */\n/* #undef HAVE_FP_CLASS_H */\n\n/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */\n#define HAVE_FSEEKO 1\n\n/* Define to 1 if your compiler understands __func__. */\n//#define HAVE_FUNCNAME__FUNC 1\n\n/* Define to 1 if your compiler understands __FUNCTION__. */\n#define HAVE_FUNCNAME__FUNCTION 1\n\n/* Define to 1 if you have getaddrinfo(). */\n/* #undef HAVE_GETADDRINFO */\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n/* #undef HAVE_GETHOSTBYNAME_R */\n\n/* Define to 1 if you have the `getopt' function. */\n//#define HAVE_GETOPT 1\n\n/* Define to 1 if you have the <getopt.h> header file. */\n//#define HAVE_GETOPT_H 1\n\n/* Define to 1 if you have the `getopt_long' function. */\n//#define HAVE_GETOPT_LONG 1\n\n/* Define to 1 if you have the `getpeereid' function. */\n/* #undef HAVE_GETPEEREID */\n\n/* Define to 1 if you have the `getpwuid_r' function. */\n/* #undef HAVE_GETPWUID_R */\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #undef HAVE_GETRUSAGE */\n\n/* Define to 1 if you have the <history.h> header file. */\n/* #undef HAVE_HISTORY_H */\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n/* #undef HAVE_IEEEFP_H */\n\n/* Define to 1 if you have the `inet_aton' function. */\n/* #undef HAVE_INET_ATON */\n\n/* Define to 1 if the system has the type `int64'. */\n/* #undef HAVE_INT64 */\n\n/* Define to 1 if the system has the type `int8'. */\n/* #undef HAVE_INT8 */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n//#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the global variable 'int timezone'. */\n#define HAVE_INT_TIMEZONE 1\n\n/* Define to 1 if you have support for IPv6. */\n#define HAVE_IPV6 1\n\n/* Define to 1 if you have isinf(). */\n#define HAVE_ISINF 1\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n/* #undef HAVE_LANGINFO_H */\n\n/* Define to 1 if you have the <ldap.h> header file. */\n/* #undef HAVE_LDAP_H */\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n/* #undef HAVE_LIBCRYPTO */\n\n/* Define to 1 if you have the `ldap' library (-lldap). */\n/* #undef HAVE_LIBLDAP */\n\n/* Define to 1 if you have the `pam' library (-lpam). */\n/* #undef HAVE_LIBPAM */\n\n/* Define to 1 if you have the `quicklz' library (-lquicklz). */\n/* #undef HAVE_LIBQUICKLZ */\n\n/* Define if you have a function readline library */\n/* #undef HAVE_LIBREADLINE */\n\n/* Define to 1 if you have the `ssl' library (-lssl). */\n/* #undef HAVE_LIBSSL */\n\n/* Define to 1 if you have the `wldap32' library (-lwldap32). */\n/* #undef HAVE_LIBWLDAP32 */\n\n/* Define to 1 if you have the `z' library (-lz). */\n/* #undef HAVE_LIBZ */\n\n/* Define to 1 if the system has the type `locale_t'. */\n#define HAVE_LOCALE_T 1\n\n/* Define to 1 if `long int' works and is 64 bits. */\n/* #undef HAVE_LONG_INT_64 */\n\n/* Define to 1 if the system has the type `long long int'. */\n#if (_MSC_VER > 1200)\n#define HAVE_LONG_LONG_INT 1\n#endif\n\n/* Define to 1 if `long long int' works and is 64 bits. */\n#if (_MSC_VER > 1200)\n#define HAVE_LONG_LONG_INT_64 1\n#endif\n\n/* Define to 1 if you have the `mbstowcs_l' function. */\n#define HAVE_MBSTOWCS_L 1\n\n/* Define to 1 if you have the `memmove' function. */\n#define HAVE_MEMMOVE 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if the system has the type `MINIDUMP_TYPE'. */\n#define HAVE_MINIDUMP_TYPE 1\n\n/* Define to 1 if you have the `mkdtemp' function. */\n/* #undef HAVE_MKDTEMP */\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#define HAVE_NETINET_IN_H 1\n\n/* Define to 1 if you have the <netinet/tcp.h> header file. */\n/* #undef HAVE_NETINET_TCP_H */\n\n/* Define to 1 if you have the <pam/pam_appl.h> header file. */\n/* #undef HAVE_PAM_PAM_APPL_H */\n\n/* Define to 1 if you have the `poll' function. */\n/* #undef HAVE_POLL */\n\n/* Define to 1 if you have the <poll.h> header file. */\n/* #undef HAVE_POLL_H */\n\n/* Define to 1 if you have the `posix_fallocate' function. */\n/* #undef HAVE_POSIX_FALLOCATE */\n\n/* Define to 1 if you have the POSIX signal interface. */\n/* #undef HAVE_POSIX_SIGNALS */\n\n/* Define to 1 if you have the `pstat' function. */\n/* #undef HAVE_PSTAT */\n\n/* Define to 1 if the PS_STRINGS thing exists. */\n/* #undef HAVE_PS_STRINGS */\n\n/* Define if you have POSIX threads libraries and header files. */\n/* #undef HAVE_PTHREAD */\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#define HAVE_PWD_H 1\n\n/* Define to 1 if you have the `random' function. */\n/* #undef HAVE_RANDOM */\n\n/* Define to 1 if you have the <readline.h> header file. */\n/* #undef HAVE_READLINE_H */\n\n/* Define to 1 if you have the <readline/history.h> header file. */\n/* #undef HAVE_READLINE_HISTORY_H */\n\n/* Define to 1 if you have the <readline/readline.h> header file. */\n/* #undef HAVE_READLINE_READLINE_H */\n\n/* Define to 1 if you have the `readlink' function. */\n/* #undef HAVE_READLINK */\n\n/* Define to 1 if you have the `rint' function. */\n#if (_MSC_VER >= 1800)\n#define HAVE_RINT 1\n#endif\n\n\n/* Define to 1 if you have the global variable\n   'rl_completion_append_character'. */\n/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */\n\n/* Define to 1 if you have the `rl_completion_matches' function. */\n/* #undef HAVE_RL_COMPLETION_MATCHES */\n\n/* Define to 1 if you have the `rl_filename_completion_function' function. */\n/* #undef HAVE_RL_FILENAME_COMPLETION_FUNCTION */\n\n/* Define to 1 if you have the <security/pam_appl.h> header file. */\n/* #undef HAVE_SECURITY_PAM_APPL_H */\n\n/* Define to 1 if you have the `setproctitle' function. */\n/* #undef HAVE_SETPROCTITLE */\n\n/* Define to 1 if you have the `setsid' function. */\n/* #undef HAVE_SETSID */\n\n/* Define to 1 if you have the `sigprocmask' function. */\n/* #undef HAVE_SIGPROCMASK */\n\n/* Define to 1 if you have sigsetjmp(). */\n/* #undef HAVE_SIGSETJMP */\n\n/* Define to 1 if the system has the type `sig_atomic_t'. */\n#define HAVE_SIG_ATOMIC_T 1\n\n/* Define to 1 if you have the `snprintf' function. */\n/* #undef HAVE_SNPRINTF */\n\n/* Define to 1 if you have spinlocks. */\n#define HAVE_SPINLOCKS 1\n\n/* Define to 1 if you have atomics. */\n#define HAVE_ATOMICS 1\n\n/* Define to 1 if you have the `srandom' function. */\n/* #undef HAVE_SRANDOM */\n\n/* Define to 1 if you have the `SSL_get_current_compression' function. */\n#define HAVE_SSL_GET_CURRENT_COMPRESSION 1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n/* #undef HAVE_STDINT_H */\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef HAVE_STRERROR\n#define HAVE_STRERROR 1\n#endif\n\n/* Define to 1 if you have the `strerror_r' function. */\n/* #undef HAVE_STRERROR_R */\n\n/* Define to 1 if you have the <strings.h> header file. */\n/*#define HAVE_STRINGS_H 1 */\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the `strtoll' function. */\n#ifdef HAVE_LONG_LONG_INT_64\n#define HAVE_STRTOLL 1\n/* Before VS2013, use Microsoft's nonstandard equivalent function */\n#if (_MSC_VER < 1800)\n#define strtoll _strtoi64\n#endif\n#endif\n\n/* Define to 1 if you have the `strtoull' function. */\n#ifdef HAVE_LONG_LONG_INT_64\n#define HAVE_STRTOULL 1\n/* Before VS2013, use Microsoft's nonstandard equivalent function */\n#if (_MSC_VER < 1800)\n#define strtoull _strtoui64\n#endif\n#endif\n\n/* Define to 1 if the system has the type `struct addrinfo'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_ADDRINFO 1\n#endif\n\n/* Define to 1 if the system has the type `struct cmsgcred'. */\n/* #undef HAVE_STRUCT_CMSGCRED */\n\n/* Define to 1 if the system has the type `struct option'. */\n//#define HAVE_STRUCT_OPTION 1\n\n/* Define to 1 if `sa_len' is member of `struct sockaddr'. */\n/* #undef HAVE_STRUCT_SOCKADDR_SA_LEN */\n\n/* Define to 1 if the system has the type `struct sockaddr_storage'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n#endif\n\n/* Define to 1 if `ss_family' is member of `struct sockaddr_storage'. */\n#if (_MSC_VER > 1200)\n#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1\n#endif\n\n/* Define to 1 if `ss_len' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN */\n\n/* Define to 1 if `__ss_family' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */\n\n/* Define to 1 if `__ss_len' is member of `struct sockaddr_storage'. */\n/* #undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_LEN */\n\n/* Define to 1 if the system has the type `struct sockaddr_un'. */\n/* #undef HAVE_STRUCT_SOCKADDR_UN */\n\n/* Define to 1 if `tm_zone' is member of `struct tm'. */\n/* #undef HAVE_STRUCT_TM_TM_ZONE */\n\n/* Define to 1 if you have the `symlink' function. */\n#define HAVE_SYMLINK 1\n\n/* Define to 1 if you have the `sync_file_range' function. */\n/* #undef HAVE_SYNC_FILE_RANGE */\n\n/* Define to 1 if you have the `sysconf' function. */\n/* #undef HAVE_SYSCONF */\n\n/* Define to 1 if you have the syslog interface. */\n/* #undef HAVE_SYSLOG */\n\n/* Define to 1 if you have the <sys/ipc.h> header file. */\n/* #undef HAVE_SYS_IPC_H */\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n/* #undef HAVE_SYS_POLL_H */\n\n/* Define to 1 if you have the <sys/pstat.h> header file. */\n/* #undef HAVE_SYS_PSTAT_H */\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n/* #undef HAVE_SYS_SELECT_H */\n\n/* Define to 1 if you have the <sys/sem.h> header file. */\n/* #undef HAVE_SYS_SEM_H */\n\n/* Define to 1 if you have the <sys/shm.h> header file. */\n/* #undef HAVE_SYS_SHM_H */\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H 1\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/ucred.h> header file. */\n/* #undef HAVE_SYS_UCRED_H */\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n/* #undef HAVE_SYS_UN_H */\n\n/* Define to 1 if you have the <termios.h> header file. */\n/* #undef HAVE_TERMIOS_H */\n\n/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use\n   `HAVE_STRUCT_TM_TM_ZONE' instead. */\n/* #undef HAVE_TM_ZONE */\n\n/* Define to 1 if you have the `towlower' function. */\n#define HAVE_TOWLOWER 1\n\n/* Define to 1 if you have the external array `tzname'. */\n/* #undef HAVE_TZNAME */\n\n/* Define to 1 if the system has the type `uint64'. */\n/* #undef HAVE_UINT64 */\n\n/* Define to 1 if the system has the type `uint8'. */\n/* #undef HAVE_UINT8 */\n\n/* Define to 1 if the system has the type `union semun'. */\n/* #undef HAVE_UNION_SEMUN */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have unix sockets. */\n/* #undef HAVE_UNIX_SOCKETS */\n\n/* Define to 1 if you have the `unsetenv' function. */\n/* #undef HAVE_UNSETENV */\n\n/* Define to 1 if you have the `uselocale' function. */\n/* #undef HAVE_USELOCALE */\n\n/* Define to 1 if you have the `utime' function. */\n#define HAVE_UTIME 1\n\n/* Define to 1 if you have the `utimes' function. */\n/* #undef HAVE_UTIMES */\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H 1\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#define HAVE_VSNPRINTF 1\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#define HAVE_WCHAR_H 1\n\n/* Define to 1 if you have the `wcstombs' function. */\n#define HAVE_WCSTOMBS 1\n\n/* Define to 1 if you have the `wcstombs_l' function. */\n#define HAVE_WCSTOMBS_L 1\n\n/* Define to 1 if you have the <wctype.h> header file. */\n#define HAVE_WCTYPE_H 1\n\n/* Define to 1 if you have the <winldap.h> header file. */\n/* #undef HAVE_WINLDAP_H */\n\n/* Define to 1 if you have __cpuid. */\n#define HAVE__CPUID 1\n\n/* Define to 1 if you have __get_cpuid. */\n#undef HAVE__GET_CPUID\n\n/* Define to 1 if your compiler understands __builtin_constant_p. */\n/* #undef HAVE__BUILTIN_CONSTANT_P */\n\n/* Define to 1 if your compiler understands __builtin_types_compatible_p. */\n/* #undef HAVE__BUILTIN_TYPES_COMPATIBLE_P */\n\n/* Define to 1 if your compiler understands __builtin_unreachable. */\n/* #undef HAVE__BUILTIN_UNREACHABLE */\n\n/* Define to 1 if you have the `_configthreadlocale' function. */\n#define HAVE__CONFIGTHREADLOCALE 1\n\n/* Define to 1 if your compiler understands _Static_assert. */\n/* #undef HAVE__STATIC_ASSERT */\n\n/* Define to 1 if your compiler understands __VA_ARGS__ in macros. */\n#define HAVE__VA_ARGS 1\n\n/* Define to the appropriate snprintf format for 64-bit ints, if any. */\n#define INT64_FORMAT \"%lld\"\n\n/* Define to 1 if `locale_t' requires <xlocale.h>. */\n/* #undef LOCALE_T_IN_XLOCALE */\n\n/* Define to the location of locale files. */\n/* #undef LOCALEDIR */\n\n/* Define as the maximum alignment requirement of any C data type. */\n#define MAXIMUM_ALIGNOF 8\n\n/* Define bytes to use libc memset(). */\n#define MEMSET_LOOP_LIMIT 1024\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"support@greenplum.com\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"Greenplum Database\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"Greenplum Database 6.0.0-alpha\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"9.4.24\"\n\n/* Define to the name of a signed 64-bit integer type. */\n#define PG_INT64_TYPE long long int\n\n/* Define to the name of a signed 128-bit integer type. */\n#undef PG_INT128_TYPE\n\n/* PostgreSQL version as a string */\n#define PG_VERSION \"9.4.24\"\n\n/* PostgreSQL version as a number */\n#define PG_VERSION_NUM 90424\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"greenplum\"\n\n/* Define to the name of the default PostgreSQL service principal in Kerberos.\n   (--with-krb-srvnam=NAME) */\n#define PG_KRB_SRVNAM \"postgres\"\n\n/* A string containing the version number, platform, and C compiler */\n#define PG_VERSION_STR \"Uninitialized version string (win32)\"\n\n/* Define to the necessary symbol if this constant uses a non-standard name on\n   your system. */\n/* #undef PTHREAD_CREATE_JOINABLE */\n\n/* The size of `long', as computed by sizeof. */\n#define SIZEOF_LONG 4\n\n/* The size of `size_t', as computed by sizeof. */\n#ifndef _WIN64\n#define SIZEOF_SIZE_T 4\n#else\n#define SIZEOF_SIZE_T 8\n#endif\n\n/* The size of `void *', as computed by sizeof. */\n#ifndef _WIN64\n#define SIZEOF_VOID_P 4\n#else\n#define SIZEOF_VOID_P 8\n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define to 1 if strerror_r() returns int. */\n/* #undef STRERROR_R_INT */\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n/* #undef TM_IN_SYS_TIME */\n\n/* Define to the appropriate snprintf format for unsigned 64-bit ints, if any.\n   */\n#define UINT64_FORMAT \"%llu\"\n\n/* Define to 1 to build with assertion checks. (--enable-cassert) */\n/* #undef USE_ASSERT_CHECKING */\n\n/* Define to 1 to build with Bonjour support. (--with-bonjour) */\n/* #undef USE_BONJOUR */\n\n/* Define to 1 if \"static inline\" works without unwanted warnings from\n   compilations where static inline functions are defined but not called. */\n#define PG_USE_INLINE 1\n\n/* Define to 1 if you want 64-bit integer timestamp and interval support.\n   (--enable-integer-datetimes) */\n/* #undef USE_INTEGER_DATETIMES */\n\n/* Define to 1 to build with LDAP support. (--with-ldap) */\n/* #undef USE_LDAP */\n\n/* Define to select named POSIX semaphores. */\n/* #undef USE_NAMED_POSIX_SEMAPHORES */\n\n/* Define to 1 to build with PAM support. (--with-pam) */\n/* #undef USE_PAM */\n\n/* Use replacement snprintf() functions. */\n#define USE_REPL_SNPRINTF 1\n\n/* Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check. */\n#if (_MSC_VER < 1500)\n#define USE_SLICING_BY_8_CRC32C 1\n#endif\n\n/* Define to 1 use Intel SSE 4.2 CRC instructions. */\n/* #undef USE_SSE42_CRC32C */\n\n/* Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check. */\n#if (_MSC_VER >= 1500)\n#define USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n#endif\n\n/* Define to build with (Open)SSL support. (--with-openssl) */\n/* #undef USE_SSL */\n\n/* Define to select SysV-style semaphores. */\n/* #undef USE_SYSV_SEMAPHORES */\n\n/* Define to select SysV-style shared memory. */\n#define USE_SYSV_SHARED_MEMORY 1\n\n/* Define to select unnamed POSIX semaphores. */\n/* #undef USE_UNNAMED_POSIX_SEMAPHORES */\n\n/* Define to select Win32-style semaphores. */\n#define USE_WIN32_SEMAPHORES 1\n\n/* Define to 1 if `wcstombs_l' requires <xlocale.h>. */\n/* #undef WCSTOMBS_L_IN_XLOCALE */\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n/* #undef _FILE_OFFSET_BITS */\n\n/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n/* #undef _LARGEFILE_SOURCE */\n\n/* Define for large files, on AIX-style hosts. */\n/* #undef _LARGE_FILES */\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#define inline __inline\n#endif\n\n/* Define to empty if the C compiler does not understand signed types. */\n/* #undef signed */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/include/pg_config.h.in": "/* src/include/pg_config.h.in.  Generated from configure.in by autoheader.  */\n\n/* Define to the type of arg 1 of 'accept' */\n#undef ACCEPT_TYPE_ARG1\n\n/* Define to the type of arg 2 of 'accept' */\n#undef ACCEPT_TYPE_ARG2\n\n/* Define to the type of arg 3 of 'accept' */\n#undef ACCEPT_TYPE_ARG3\n\n/* Define to the return type of 'accept' */\n#undef ACCEPT_TYPE_RETURN\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* The normal alignment of `double', in bytes. */\n#undef ALIGNOF_DOUBLE\n\n/* The normal alignment of `int', in bytes. */\n#undef ALIGNOF_INT\n\n/* The normal alignment of `long', in bytes. */\n#undef ALIGNOF_LONG\n\n/* The normal alignment of `long long int', in bytes. */\n#undef ALIGNOF_LONG_LONG_INT\n\n/* The normal alignment of `PG_INT128_TYPE', in bytes. */\n#undef ALIGNOF_PG_INT128_TYPE\n\n/* The normal alignment of `short', in bytes. */\n#undef ALIGNOF_SHORT\n\n/* Size of a disk block --- this also limits the size of a tuple. You can set\n   it bigger if you need bigger tuples (although TOAST should reduce the need\n   to have large tuples, since fields can be spread across multiple tuples).\n   BLCKSZ must be a power of 2. The maximum possible value of BLCKSZ is\n   currently 2^15 (32768). This is determined by the 15-bit widths of the\n   lp_off and lp_len fields in ItemIdData (see include/storage/itemid.h).\n   Changing BLCKSZ requires an initdb. */\n#undef BLCKSZ\n\n/* Define to the default TCP port number on which the server listens and to\n   which clients will try to connect. This can be overridden at run-time, but\n   it's convenient if your clients have the right default compiled in.\n   (--with-pgport=PORTNUM) */\n#undef DEF_PGPORT\n\n/* Define to the default TCP port number as a string constant. */\n#undef DEF_PGPORT_STR\n\n/* Define to build with GSSAPI support. (--with-gssapi) */\n#undef ENABLE_GSS\n\n/* Define to 1 to build client libraries as thread-safe code.\n   (--enable-thread-safety) */\n#undef ENABLE_THREAD_SAFETY\n\n/* Define to nothing if C supports flexible array members, and to 1 if it does\n   not. That way, with a declaration like `struct s { int n; double\n   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99\n   compilers. When computing the size of such an object, don't use 'sizeof\n   (struct s)' as it overestimates the size. Use 'offsetof (struct s, d)'\n   instead. Don't use 'offsetof (struct s, d[0])', as this doesn't work with\n   MSVC and with C++ compilers. */\n#undef FLEXIBLE_ARRAY_MEMBER\n\n/* float4 values are passed by value if 'true', by reference if 'false'\n   (always true in GPDB) */\n#undef FLOAT4PASSBYVAL\n\n/* float8, int8, and related values are passed by value if 'true', by\n   reference if 'false' (always true in GPDB) */\n#undef FLOAT8PASSBYVAL\n\n/* Define to 1 if getpwuid_r() takes a 5th argument. */\n#undef GETPWUID_R_5ARG\n\n/* Define to 1 if gettimeofday() takes only 1 argument. */\n#undef GETTIMEOFDAY_1ARG\n\n#ifdef GETTIMEOFDAY_1ARG\n# define gettimeofday(a,b) gettimeofday(a)\n#endif\n\n/* Greenplum major version as a string */\n#undef GP_MAJORVERSION\n\n/* A string containing the Greenplum version number */\n#undef GP_VERSION\n\n/* Greenplum version as a number */\n#undef GP_VERSION_NUM\n\n/* Define to 1 if you have the `append_history' function. */\n#undef HAVE_APPEND_HISTORY\n\n/* Define to 1 if you have the <apr_getopt.h> header file. */\n#undef HAVE_APR_GETOPT_H\n\n/* Define to 1 if you have the `ASN1_STRING_get0_data' function. */\n#undef HAVE_ASN1_STRING_GET0_DATA\n\n/* Define to 1 if you want to use atomics. */\n#undef HAVE_ATOMICS\n\n/* Define to 1 if you have the <atomic.h> header file. */\n#undef HAVE_ATOMIC_H\n\n/* Define to 1 if you have the `BIO_meth_new' function. */\n#undef HAVE_BIO_METH_NEW\n\n/* Define to 1 if you have the `cbrt' function. */\n#undef HAVE_CBRT\n\n/* Define to 1 if you have the `class' function. */\n#undef HAVE_CLASS\n\n/* Define to 1 if you have the <crtdefs.h> header file. */\n#undef HAVE_CRTDEFS_H\n\n/* Define to 1 if you have the `crypt' function. */\n#undef HAVE_CRYPT\n\n/* Define to 1 if you have the `CRYPTO_lock' function. */\n#undef HAVE_CRYPTO_LOCK\n\n/* Define to 1 if you have the <crypt.h> header file. */\n#undef HAVE_CRYPT_H\n\n/* define if the compiler supports basic C++11 syntax */\n#undef HAVE_CXX11\n\n/* Define to 1 if you have the declaration of `CURLOPT_MAIL_FROM', and to 0 if\n   you don't. */\n#undef HAVE_DECL_CURLOPT_MAIL_FROM\n\n/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you\n   don't. */\n#undef HAVE_DECL_FDATASYNC\n\n/* Define to 1 if you have the declaration of `F_FULLFSYNC', and to 0 if you\n   don't. */\n#undef HAVE_DECL_F_FULLFSYNC\n\n/* Define to 1 if you have the declaration of `posix_fadvise', and to 0 if you\n   don't. */\n#undef HAVE_DECL_POSIX_FADVISE\n\n/* Define to 1 if you have the declaration of `snprintf', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SNPRINTF\n\n/* Define to 1 if you have the declaration of `strlcat', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRLCAT\n\n/* Define to 1 if you have the declaration of `strlcpy', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRLCPY\n\n/* Define to 1 if you have the declaration of `strtoll', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRTOLL\n\n/* Define to 1 if you have the declaration of `strtoull', and to 0 if you\n   don't. */\n#undef HAVE_DECL_STRTOULL\n\n/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SYS_SIGLIST\n\n/* Define to 1 if you have the declaration of `vsnprintf', and to 0 if you\n   don't. */\n#undef HAVE_DECL_VSNPRINTF\n\n/* Define to 1 if you have the <dld.h> header file. */\n#undef HAVE_DLD_H\n\n/* Define to 1 if you have the `dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the <editline/history.h> header file. */\n#undef HAVE_EDITLINE_HISTORY_H\n\n/* Define to 1 if you have the <editline/readline.h> header file. */\n#undef HAVE_EDITLINE_READLINE_H\n\n/* Define to 1 if you have the <event.h> header file. */\n#undef HAVE_EVENT_H\n\n/* Define to 1 if you have the <execinfo.h> header file. */\n#undef HAVE_EXECINFO_H\n\n/* Define to 1 if you have the `fdatasync' function. */\n#undef HAVE_FDATASYNC\n\n/* Define to 1 if you have the `fls' function. */\n#undef HAVE_FLS\n\n/* Define to 1 if you have the `fpclass' function. */\n#undef HAVE_FPCLASS\n\n/* Define to 1 if you have the `fp_class' function. */\n#undef HAVE_FP_CLASS\n\n/* Define to 1 if you have the `fp_class_d' function. */\n#undef HAVE_FP_CLASS_D\n\n/* Define to 1 if you have the <fp_class.h> header file. */\n#undef HAVE_FP_CLASS_H\n\n/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */\n#undef HAVE_FSEEKO\n\n/* Define to 1 if your compiler understands __func__. */\n#undef HAVE_FUNCNAME__FUNC\n\n/* Define to 1 if your compiler understands __FUNCTION__. */\n#undef HAVE_FUNCNAME__FUNCTION\n\n/* Define to 1 if you have __sync_lock_test_and_set(int *) and friends. */\n#undef HAVE_GCC_INT_ATOMICS\n\n/* Define to 1 if you have __atomic_compare_exchange_n(int *, int *, int). */\n#undef HAVE_GCC__ATOMIC_INT32_CAS\n\n/* Define to 1 if you have __atomic_compare_exchange_n(int64 *, int *, int64).\n   */\n#undef HAVE_GCC__ATOMIC_INT64_CAS\n\n/* Define to 1 if you have __sync_lock_test_and_set(char *) and friends. */\n#undef HAVE_GCC__SYNC_CHAR_TAS\n\n/* Define to 1 if you have __sync_compare_and_swap(int *, int, int). */\n#undef HAVE_GCC__SYNC_INT32_CAS\n\n/* Define to 1 if you have __sync_lock_test_and_set(int *) and friends. */\n#undef HAVE_GCC__SYNC_INT32_TAS\n\n/* Define to 1 if you have __sync_compare_and_swap(int64 *, int64, int64). */\n#undef HAVE_GCC__SYNC_INT64_CAS\n\n/* Define to 1 if you have the `getaddrinfo' function. */\n#undef HAVE_GETADDRINFO\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n#undef HAVE_GETHOSTBYNAME_R\n\n/* Define to 1 if you have the `getifaddrs' function. */\n#undef HAVE_GETIFADDRS\n\n/* Define to 1 if you have the `getopt' function. */\n#undef HAVE_GETOPT\n\n/* Define to 1 if you have the <getopt.h> header file. */\n#undef HAVE_GETOPT_H\n\n/* Define to 1 if you have the `getopt_long' function. */\n#undef HAVE_GETOPT_LONG\n\n/* Define to 1 if you have the `getpeereid' function. */\n#undef HAVE_GETPEEREID\n\n/* Define to 1 if you have the `getpeerucred' function. */\n#undef HAVE_GETPEERUCRED\n\n/* Define to 1 if you have the `getpwuid_r' function. */\n#undef HAVE_GETPWUID_R\n\n/* Define to 1 if you have the `getrlimit' function. */\n#undef HAVE_GETRLIMIT\n\n/* Define to 1 if you have the `getrusage' function. */\n#undef HAVE_GETRUSAGE\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the <gpdbcost/CCostModelGPDB.h> header file. */\n#undef HAVE_GPDBCOST_CCOSTMODELGPDB_H\n\n/* Define to 1 if you have the <gpopt/init.h> header file. */\n#undef HAVE_GPOPT_INIT_H\n\n/* Define to 1 if you have the <gpos/_api.h> header file. */\n#undef HAVE_GPOS__API_H\n\n/* Define to 1 if you have the <gssapi/gssapi.h> header file. */\n#undef HAVE_GSSAPI_GSSAPI_H\n\n/* Define to 1 if you have the <gssapi.h> header file. */\n#undef HAVE_GSSAPI_H\n\n/* Define to 1 if you have the <history.h> header file. */\n#undef HAVE_HISTORY_H\n\n/* Define to 1 if you have the `history_truncate_file' function. */\n#undef HAVE_HISTORY_TRUNCATE_FILE\n\n/* Define to 1 if you have the <ieeefp.h> header file. */\n#undef HAVE_IEEEFP_H\n\n/* Define to 1 if you have the <ifaddrs.h> header file. */\n#undef HAVE_IFADDRS_H\n\n/* Define to 1 if you have the `inet_aton' function. */\n#undef HAVE_INET_ATON\n\n/* Define to 1 if the system has the type `int64'. */\n#undef HAVE_INT64\n\n/* Define to 1 if the system has the type `int8'. */\n#undef HAVE_INT8\n\n/* Define to 1 if the system has the type `intptr_t'. */\n#undef HAVE_INTPTR_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the global variable 'int opterr'. */\n#undef HAVE_INT_OPTERR\n\n/* Define to 1 if you have the global variable 'int optreset'. */\n#undef HAVE_INT_OPTRESET\n\n/* Define to 1 if you have the global variable 'int timezone'. */\n#undef HAVE_INT_TIMEZONE\n\n/* Define to 1 if you have support for IPv6. */\n#undef HAVE_IPV6\n\n/* Define to 1 if you have isinf(). */\n#undef HAVE_ISINF\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H\n\n/* Define to 1 if you have the <ldap.h> header file. */\n#undef HAVE_LDAP_H\n\n/* Define to 1 if you have the `bz2' library (-lbz2). */\n#undef HAVE_LIBBZ2\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n#undef HAVE_LIBCRYPTO\n\n/* Define to 1 if you have the `execinfo' library (-lexecinfo). */\n#undef HAVE_LIBEXECINFO\n\n/* Define to 1 if you have the `gpdbcost' library (-lgpdbcost). */\n#undef HAVE_LIBGPDBCOST\n\n/* Define to 1 if you have the `gpopt' library (-lgpopt). */\n#undef HAVE_LIBGPOPT\n\n/* Define to 1 if you have the `gpos' library (-lgpos). */\n#undef HAVE_LIBGPOS\n\n/* Define to 1 if you have the `ldap' library (-lldap). */\n#undef HAVE_LIBLDAP\n\n/* Define to 1 if you have the `ldap_r' library (-lldap_r). */\n#undef HAVE_LIBLDAP_R\n\n/* Define to 1 if you have the `m' library (-lm). */\n#undef HAVE_LIBM\n\n/* Define to 1 if you have the `naucrates' library (-lnaucrates). */\n#undef HAVE_LIBNAUCRATES\n\n/* Define to 1 if you have the `numa' library (-lnuma). */\n#undef HAVE_LIBNUMA\n\n/* Define to 1 if you have the `pam' library (-lpam). */\n#undef HAVE_LIBPAM\n\n/* Define to 1 if you have the `quicklz' library (-lquicklz). */\n#undef HAVE_LIBQUICKLZ\n\n/* Define if you have a function readline library */\n#undef HAVE_LIBREADLINE\n\n/* Define to 1 if you have the `rt' library (-lrt). */\n#undef HAVE_LIBRT\n\n/* Define to 1 if you have the `selinux' library (-lselinux). */\n#undef HAVE_LIBSELINUX\n\n/* Define to 1 if you have the `ssl' library (-lssl). */\n#undef HAVE_LIBSSL\n\n/* Define to 1 if you have the `wldap32' library (-lwldap32). */\n#undef HAVE_LIBWLDAP32\n\n/* Define to 1 if you have the `xerces-c' library (-lxerces-c). */\n#undef HAVE_LIBXERCES_C\n\n/* Define to 1 if you have the `xml2' library (-lxml2). */\n#undef HAVE_LIBXML2\n\n/* Define to 1 if you have the `xslt' library (-lxslt). */\n#undef HAVE_LIBXSLT\n\n/* Define to 1 if you have the `z' library (-lz). */\n#undef HAVE_LIBZ\n\n/* Define to 1 if you have the `zstd' library (-lzstd). */\n#undef HAVE_LIBZSTD\n\n/* Define to 1 if the system has the type `locale_t'. */\n#undef HAVE_LOCALE_T\n\n/* Define to 1 if `long int' works and is 64 bits. */\n#undef HAVE_LONG_INT_64\n\n/* Define to 1 if the system has the type `long long int'. */\n#undef HAVE_LONG_LONG_INT\n\n/* Define to 1 if `long long int' works and is 64 bits. */\n#undef HAVE_LONG_LONG_INT_64\n\n/* Define to 1 if you have the <mbarrier.h> header file. */\n#undef HAVE_MBARRIER_H\n\n/* Define to 1 if you have the `mbstowcs_l' function. */\n#undef HAVE_MBSTOWCS_L\n\n/* Define to 1 if you have the `memmove' function. */\n#undef HAVE_MEMMOVE\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if the system has the type `MINIDUMP_TYPE'. */\n#undef HAVE_MINIDUMP_TYPE\n\n/* Define to 1 if you have the `mkdtemp' function. */\n#undef HAVE_MKDTEMP\n\n/* Define to 1 if you have the <naucrates/init.h> header file. */\n#undef HAVE_NAUCRATES_INIT_H\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#undef HAVE_NETINET_IN_H\n\n/* Define to 1 if you have the <netinet/tcp.h> header file. */\n#undef HAVE_NETINET_TCP_H\n\n/* Define to 1 if you have the <net/if.h> header file. */\n#undef HAVE_NET_IF_H\n\n/* Define to 1 if you have the <numa.h> header file. */\n#undef HAVE_NUMA_H\n\n/* Define to 1 if you have the `OPENSSL_init_ssl' function. */\n#undef HAVE_OPENSSL_INIT_SSL\n\n/* Define to 1 if you have the <ossp/uuid.h> header file. */\n#undef HAVE_OSSP_UUID_H\n\n/* Define to 1 if you have the <pam/pam_appl.h> header file. */\n#undef HAVE_PAM_PAM_APPL_H\n\n/* Define to 1 if you have the `poll' function. */\n#undef HAVE_POLL\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the `posix_fadvise' function. */\n#undef HAVE_POSIX_FADVISE\n\n/* Define to 1 if you have the `posix_fallocate' function. */\n#undef HAVE_POSIX_FALLOCATE\n\n/* Define to 1 if you have the POSIX signal interface. */\n#undef HAVE_POSIX_SIGNALS\n\n/* Define to 1 if the assembler supports PPC's LWARX mutex hint bit. */\n#undef HAVE_PPC_LWARX_MUTEX_HINT\n\n/* Define to 1 if you have the `pstat' function. */\n#undef HAVE_PSTAT\n\n/* Define to 1 if the PS_STRINGS thing exists. */\n#undef HAVE_PS_STRINGS\n\n/* Define if you have POSIX threads libraries and header files. */\n#undef HAVE_PTHREAD\n\n/* Define to 1 if you have the `pthread_is_threaded_np' function. */\n#undef HAVE_PTHREAD_IS_THREADED_NP\n\n/* Have PTHREAD_PRIO_INHERIT. */\n#undef HAVE_PTHREAD_PRIO_INHERIT\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#undef HAVE_PWD_H\n\n/* Define to 1 if you have the `random' function. */\n#undef HAVE_RANDOM\n\n/* Define to 1 if you have the `RAND_OpenSSL' function. */\n#undef HAVE_RAND_OPENSSL\n\n/* Define to 1 if you have the <readline.h> header file. */\n#undef HAVE_READLINE_H\n\n/* Define to 1 if you have the <readline/history.h> header file. */\n#undef HAVE_READLINE_HISTORY_H\n\n/* Define to 1 if you have the <readline/readline.h> header file. */\n#undef HAVE_READLINE_READLINE_H\n\n/* Define to 1 if you have the `readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the `rint' function. */\n#undef HAVE_RINT\n\n/* Define to 1 if you have the global variable\n   'rl_completion_append_character'. */\n#undef HAVE_RL_COMPLETION_APPEND_CHARACTER\n\n/* Define to 1 if you have the `rl_completion_matches' function. */\n#undef HAVE_RL_COMPLETION_MATCHES\n\n/* Define to 1 if you have the `rl_filename_completion_function' function. */\n#undef HAVE_RL_FILENAME_COMPLETION_FUNCTION\n\n/* Define to 1 if you have the `rl_reset_screen_size' function. */\n#undef HAVE_RL_RESET_SCREEN_SIZE\n\n/* Define to 1 if you have the <security/pam_appl.h> header file. */\n#undef HAVE_SECURITY_PAM_APPL_H\n\n/* Define to 1 if you have the `setproctitle' function. */\n#undef HAVE_SETPROCTITLE\n\n/* Define to 1 if you have the `setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the `shm_open' function. */\n#undef HAVE_SHM_OPEN\n\n/* Define to 1 if you have the `sigprocmask' function. */\n#undef HAVE_SIGPROCMASK\n\n/* Define to 1 if you have sigsetjmp(). */\n#undef HAVE_SIGSETJMP\n\n/* Define to 1 if the system has the type `sig_atomic_t'. */\n#undef HAVE_SIG_ATOMIC_T\n\n/* Define to 1 if you have the `snprintf' function. */\n#undef HAVE_SNPRINTF\n\n/* Define to 1 if you have spinlocks. */\n#undef HAVE_SPINLOCKS\n\n/* Define to 1 if you have the `srandom' function. */\n#undef HAVE_SRANDOM\n\n/* Define to 1 if you have the `SSL_get_current_compression' function. */\n#undef HAVE_SSL_GET_CURRENT_COMPRESSION\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `strerror' function. */\n#undef HAVE_STRERROR\n\n/* Define to 1 if you have the `strerror_r' function. */\n#undef HAVE_STRERROR_R\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strlcat' function. */\n#undef HAVE_STRLCAT\n\n/* Define to 1 if you have the `strlcpy' function. */\n#undef HAVE_STRLCPY\n\n/* Define to 1 if you have the `strtoll' function. */\n#undef HAVE_STRTOLL\n\n/* Define to 1 if you have the `strtoq' function. */\n#undef HAVE_STRTOQ\n\n/* Define to 1 if you have the `strtoull' function. */\n#undef HAVE_STRTOULL\n\n/* Define to 1 if you have the `strtouq' function. */\n#undef HAVE_STRTOUQ\n\n/* Define to 1 if the system has the type `struct addrinfo'. */\n#undef HAVE_STRUCT_ADDRINFO\n\n/* Define to 1 if the system has the type `struct cmsgcred'. */\n#undef HAVE_STRUCT_CMSGCRED\n\n/* Define to 1 if the system has the type `struct option'. */\n#undef HAVE_STRUCT_OPTION\n\n/* Define to 1 if `sa_len' is a member of `struct sockaddr'. */\n#undef HAVE_STRUCT_SOCKADDR_SA_LEN\n\n/* Define to 1 if the system has the type `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE\n\n/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY\n\n/* Define to 1 if `ss_len' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n\n/* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY\n\n/* Define to 1 if `__ss_len' is a member of `struct sockaddr_storage'. */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_LEN\n\n/* Define to 1 if `tm_zone' is a member of `struct tm'. */\n#undef HAVE_STRUCT_TM_TM_ZONE\n\n/* Define to 1 if you have the `symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the `sync_file_range' function. */\n#undef HAVE_SYNC_FILE_RANGE\n\n/* Define to 1 if you have the syslog interface. */\n#undef HAVE_SYSLOG\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#undef HAVE_SYS_IOCTL_H\n\n/* Define to 1 if you have the <sys/ipc.h> header file. */\n#undef HAVE_SYS_IPC_H\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#undef HAVE_SYS_POLL_H\n\n/* Define to 1 if you have the <sys/pstat.h> header file. */\n#undef HAVE_SYS_PSTAT_H\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#undef HAVE_SYS_RESOURCE_H\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#undef HAVE_SYS_SELECT_H\n\n/* Define to 1 if you have the <sys/sem.h> header file. */\n#undef HAVE_SYS_SEM_H\n\n/* Define to 1 if you have the <sys/shm.h> header file. */\n#undef HAVE_SYS_SHM_H\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#undef HAVE_SYS_SOCKET_H\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#undef HAVE_SYS_SOCKIO_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/tas.h> header file. */\n#undef HAVE_SYS_TAS_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/ucred.h> header file. */\n#undef HAVE_SYS_UCRED_H\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <time.h> header file. */\n#undef HAVE_TIME_H\n\n/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use\n   `HAVE_STRUCT_TM_TM_ZONE' instead. */\n#undef HAVE_TM_ZONE\n\n/* Define to 1 if you have the `towlower' function. */\n#undef HAVE_TOWLOWER\n\n/* Define to 1 if you have the external array `tzname'. */\n#undef HAVE_TZNAME\n\n/* Define to 1 if you have the <ucred.h> header file. */\n#undef HAVE_UCRED_H\n\n/* Define to 1 if the system has the type `uint64'. */\n#undef HAVE_UINT64\n\n/* Define to 1 if the system has the type `uint8'. */\n#undef HAVE_UINT8\n\n/* Define to 1 if the system has the type `uintptr_t'. */\n#undef HAVE_UINTPTR_T\n\n/* Define to 1 if the system has the type `union semun'. */\n#undef HAVE_UNION_SEMUN\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have unix sockets. */\n#undef HAVE_UNIX_SOCKETS\n\n/* Define to 1 if you have the `unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define to 1 if the system has the type `unsigned long long int'. */\n#undef HAVE_UNSIGNED_LONG_LONG_INT\n\n/* Define to 1 if you have the `uselocale' function. */\n#undef HAVE_USELOCALE\n\n/* Define to 1 if you have the `utime' function. */\n#undef HAVE_UTIME\n\n/* Define to 1 if you have the `utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#undef HAVE_UTIME_H\n\n/* Define to 1 if you have BSD UUID support. */\n#undef HAVE_UUID_BSD\n\n/* Define to 1 if you have E2FS UUID support. */\n#undef HAVE_UUID_E2FS\n\n/* Define to 1 if you have the <uuid.h> header file. */\n#undef HAVE_UUID_H\n\n/* Define to 1 if you have OSSP UUID support. */\n#undef HAVE_UUID_OSSP\n\n/* Define to 1 if you have the <uuid/uuid.h> header file. */\n#undef HAVE_UUID_UUID_H\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#undef HAVE_VSNPRINTF\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#undef HAVE_WCHAR_H\n\n/* Define to 1 if you have the `wcstombs' function. */\n#undef HAVE_WCSTOMBS\n\n/* Define to 1 if you have the `wcstombs_l' function. */\n#undef HAVE_WCSTOMBS_L\n\n/* Define to 1 if you have the <wctype.h> header file. */\n#undef HAVE_WCTYPE_H\n\n/* Define to 1 if you have the <winldap.h> header file. */\n#undef HAVE_WINLDAP_H\n\n/* Define to 1 if you have the <winsock2.h> header file. */\n#undef HAVE_WINSOCK2_H\n\n/* Define to 1 if you have the <yaml.h> header file. */\n#undef HAVE_YAML_H\n\n/* Define to 1 if your compiler understands __builtin_constant_p. */\n#undef HAVE__BUILTIN_CONSTANT_P\n\n/* Define to 1 if your compiler understands __builtin_types_compatible_p. */\n#undef HAVE__BUILTIN_TYPES_COMPATIBLE_P\n\n/* Define to 1 if your compiler understands __builtin_unreachable. */\n#undef HAVE__BUILTIN_UNREACHABLE\n\n/* Define to 1 if you have the `_configthreadlocale' function. */\n#undef HAVE__CONFIGTHREADLOCALE\n\n/* Define to 1 if you have __cpuid. */\n#undef HAVE__CPUID\n\n/* Define to 1 if you have __get_cpuid. */\n#undef HAVE__GET_CPUID\n\n/* Define to 1 if your compiler understands _Static_assert. */\n#undef HAVE__STATIC_ASSERT\n\n/* Define to 1 if your compiler understands __VA_ARGS__ in macros. */\n#undef HAVE__VA_ARGS\n\n/* Define to 1 if you have the `__strtoll' function. */\n#undef HAVE___STRTOLL\n\n/* Define to 1 if you have the `__strtoull' function. */\n#undef HAVE___STRTOULL\n\n/* Define to the appropriate snprintf format for 64-bit ints. */\n#undef INT64_FORMAT\n\n/* Define to 1 if `locale_t' requires <xlocale.h>. */\n#undef LOCALE_T_IN_XLOCALE\n\n/* Define as the maximum alignment requirement of any C data type. */\n#undef MAXIMUM_ALIGNOF\n\n/* Define bytes to use libc memset(). */\n#undef MEMSET_LOOP_LIMIT\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to the name of a signed 128-bit integer type. */\n#undef PG_INT128_TYPE\n\n/* Define to the name of a signed 64-bit integer type. */\n#undef PG_INT64_TYPE\n\n/* Define to the name of the default PostgreSQL service principal in Kerberos\n   (GSSAPI). (--with-krb-srvnam=NAME) */\n#undef PG_KRB_SRVNAM\n\n/* PostgreSQL major version as a string */\n#undef PG_MAJORVERSION\n\n/* Define to gnu_printf if compiler supports it, else printf. */\n#undef PG_PRINTF_ATTRIBUTE\n\n/* Define to 1 if \"static inline\" works without unwanted warnings from\n   compilations where static inline functions are defined but not called. */\n#undef PG_USE_INLINE\n\n/* Postgres version Greenplum Database is based on */\n#undef PG_VERSION\n\n/* PostgreSQL version as a number */\n#undef PG_VERSION_NUM\n\n/* A string containing the version number, platform, and C compiler */\n#undef PG_VERSION_STR\n\n/* Define to 1 to allow profiling output to be saved separately for each\n   process. */\n#undef PROFILE_PID_DIR\n\n/* Define to necessary symbol if this constant uses a non-standard name on\n   your system. */\n#undef PTHREAD_CREATE_JOINABLE\n\n/* RELSEG_SIZE is the maximum number of blocks allowed in one disk file. Thus,\n   the maximum size of a single file is RELSEG_SIZE * BLCKSZ; relations bigger\n   than that are divided into multiple files. RELSEG_SIZE * BLCKSZ must be\n   less than your OS' limit on file size. This is often 2 GB or 4GB in a\n   32-bit operating system, unless you have large file support enabled. By\n   default, we make the limit 1 GB to avoid any possible integer-overflow\n   problems within the OS. A limit smaller than necessary only means we divide\n   a large relation into more chunks than necessary, so it seems best to err\n   in the direction of a small limit. A power-of-2 value is recommended to\n   save a few cycles in md.c, but is not absolutely required. Changing\n   RELSEG_SIZE requires an initdb. */\n#undef RELSEG_SIZE\n\n/* The size of `long', as computed by sizeof. */\n#undef SIZEOF_LONG\n\n/* The size of `off_t', as computed by sizeof. */\n#undef SIZEOF_OFF_T\n\n/* The size of `size_t', as computed by sizeof. */\n#undef SIZEOF_SIZE_T\n\n/* The size of `void *', as computed by sizeof. */\n#undef SIZEOF_VOID_P\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define to 1 if strerror_r() returns int. */\n#undef STRERROR_R_INT\n\n/* Define to 1 if your <sys/time.h> declares `struct tm'. */\n#undef TM_IN_SYS_TIME\n\n/* Define to the appropriate snprintf format for unsigned 64-bit ints. */\n#undef UINT64_FORMAT\n\n/* Define to 1 to build with assertion checks. (--enable-cassert) */\n#undef USE_ASSERT_CHECKING\n\n/* Define to 1 to build with Bonjour support. (--with-bonjour) */\n#undef USE_BONJOUR\n\n/* Define to 1 to build with libcurl support. (--with-libcurl) */\n#undef USE_CURL\n\n/* Define to 1 to build with debug_ntuplestore. (--enable-ntuplestore) */\n#undef USE_DEBUG_NTUPLESTORE\n\n/* Define to 1 if you want float4 values to be passed by value. (Always\n   defined in GPDB) */\n#undef USE_FLOAT4_BYVAL\n\n/* Define to 1 if you want float8, int8, etc values to be passed by value.\n   (Always defined in GPDB) */\n#undef USE_FLOAT8_BYVAL\n\n/* Define to 1 to build with gpcloud (--enable-gpcloud) */\n#undef USE_GPCLOUD\n\n/* Define to 1 if you want 64-bit integer timestamp and interval support.\n   (--enable-integer-datetimes) */\n#undef USE_INTEGER_DATETIMES\n\n/* Define to 1 to build with LDAP support. (--with-ldap) */\n#undef USE_LDAP\n\n/* Define to 1 to build with XML support. (--with-libxml) */\n#undef USE_LIBXML\n\n/* Define to 1 to use XSLT support when building contrib/xml2.\n   (--with-libxslt) */\n#undef USE_LIBXSLT\n\n/* Define to 1 to build with Mapreduce capabilities (--enable-mapreduce) */\n#undef USE_MAPREDUCE\n\n/* Define to select named POSIX semaphores. */\n#undef USE_NAMED_POSIX_SEMAPHORES\n\n/* Define to 1 to build with Greenplum ORCA optimizer. (--enable-orca) */\n#undef USE_ORCA\n\n/* Define to 1 to build with PAM support. (--with-pam) */\n#undef USE_PAM\n\n/* Use replacement snprintf() functions. */\n#undef USE_REPL_SNPRINTF\n\n/* Define to 1 to use Intel SSE 4.2 CRC instructions with a runtime check. */\n#undef USE_SLICING_BY_8_CRC32C\n\n/* Define to 1 use Intel SSE 4.2 CRC instructions. */\n#undef USE_SSE42_CRC32C\n\n/* Define to 1 to use Intel SSSE 4.2 CRC instructions with a runtime check. */\n#undef USE_SSE42_CRC32C_WITH_RUNTIME_CHECK\n\n/* Define to build with (Open)SSL support. (--with-openssl) */\n#undef USE_SSL\n\n/* Define to select SysV-style semaphores. */\n#undef USE_SYSV_SEMAPHORES\n\n/* Define to select SysV-style shared memory. */\n#undef USE_SYSV_SHARED_MEMORY\n\n/* Define to select unnamed POSIX semaphores. */\n#undef USE_UNNAMED_POSIX_SEMAPHORES\n\n/* Define to select Win32-style semaphores. */\n#undef USE_WIN32_SEMAPHORES\n\n/* Define to select Win32-style shared memory. */\n#undef USE_WIN32_SHARED_MEMORY\n\n/* Define to 1 if `wcstombs_l' requires <xlocale.h>. */\n#undef WCSTOMBS_L_IN_XLOCALE\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Size of a WAL file block. This need have no particular relation to BLCKSZ.\n   XLOG_BLCKSZ must be a power of 2, and if your system supports O_DIRECT I/O,\n   XLOG_BLCKSZ must be a multiple of the alignment requirement for direct-I/O\n   buffers, else direct I/O may fail. Changing XLOG_BLCKSZ requires an initdb.\n   */\n#undef XLOG_BLCKSZ\n\n/* XLOG_SEG_SIZE is the size of a single WAL file. This must be a power of 2\n   and larger than XLOG_BLCKSZ (preferably, a great deal larger than\n   XLOG_BLCKSZ). Changing XLOG_SEG_SIZE requires an initdb. */\n#undef XLOG_SEG_SIZE\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#undef _FILE_OFFSET_BITS\n\n/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */\n#undef _LARGEFILE_SOURCE\n\n/* Define for large files, on AIX-style hosts. */\n#undef _LARGE_FILES\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#undef inline\n#endif\n\n/* Define to the type of a signed integer type wide enough to hold a pointer,\n   if such a type exists, and if the system does not define it. */\n#undef intptr_t\n\n/* Define to empty if the C compiler does not understand signed types. */\n#undef signed\n\n/* Define to the type of an unsigned integer type wide enough to hold a\n   pointer, if such a type exists, and if the system does not define it. */\n#undef uintptr_t\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/include/utils/dynamic_loader.h": "/*-------------------------------------------------------------------------\n *\n * dynamic_loader.h\n *\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/utils/dynamic_loader.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef DYNAMIC_LOADER_H\n#define DYNAMIC_LOADER_H\n\n#include \"fmgr.h\"\n\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n\n#endif   /* DYNAMIC_LOADER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/win32.h": "/*\n * src/backend/port/dynloader/win32.h\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n#define pg_dlopen(f)\tdlopen((f), 1)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/cygwin.h": "/*-------------------------------------------------------------------------\n *\n * Dynamic loader declarations for Cygwin\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/cygwin.h\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/freebsd.h": "/*-------------------------------------------------------------------------\n *\n * freebsd.h\n *\t  port-specific prototypes for FreeBSD\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/freebsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/darwin.h": "/* src/backend/port/dynloader/darwin.h */\n\n#include \"fmgr.h\"\n\nvoid\t   *pg_dlopen(char *filename);\nPGFunction\tpg_dlsym(void *handle, char *funcname);\nvoid\t\tpg_dlclose(void *handle);\nchar\t   *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/sco.h": "/*-------------------------------------------------------------------------\n *\n * sco.h\n *\t  port-specific prototypes for SCO 3.2v5.2\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/sco.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on SCO 3.2v5.0.2\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/win32.c": "/* src/backend/port/dynloader/win32.c */\n\n#include \"postgres.h\"\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\nstatic char last_dyn_error[512];\n\nstatic void\nset_dl_error(void)\n{\n\tDWORD\t\terr = GetLastError();\n\n\tif (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t\t\t  FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  err,\n\t\t\t\t\t  MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),\n\t\t\t\t\t  last_dyn_error,\n\t\t\t\t\t  sizeof(last_dyn_error) - 1,\n\t\t\t\t\t  NULL) == 0)\n\t{\n\t\tsnprintf(last_dyn_error, sizeof(last_dyn_error) - 1,\n\t\t\t\t \"unknown error %lu\", err);\n\t}\n}\n\nchar *\ndlerror(void)\n{\n\tif (last_dyn_error[0])\n\t\treturn last_dyn_error;\n\telse\n\t\treturn NULL;\n}\n\nint\ndlclose(void *handle)\n{\n\tif (!FreeLibrary((HMODULE) handle))\n\t{\n\t\tset_dl_error();\n\t\treturn 1;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn 0;\n}\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n\tvoid\t   *ptr;\n\n\tptr = GetProcAddress((HMODULE) handle, symbol);\n\tif (!ptr)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn ptr;\n}\n\nvoid *\ndlopen(const char *path, int mode)\n{\n\tHMODULE\t\th;\n\tint\t\t\tprevmode;\n\n\t/* Disable popup error messages when loading DLLs */\n\tprevmode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\th = LoadLibrary(path);\n\tSetErrorMode(prevmode);\n\n\tif (!h)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn (void *) h;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/hpux.h": "/*-------------------------------------------------------------------------\n *\n * dynloader.h\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/hpux.h\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n/* System includes */\n#include \"fmgr.h\"\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/osf.h": "/*-------------------------------------------------------------------------\n *\n * osf.h\n *\t  prototypes for OSF/1-specific routines\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/osf.h\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on Alpha OSF/1.x\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/solaris.h": "/*-------------------------------------------------------------------------\n *\n * solaris.h\n *\t  port-specific prototypes for Solaris\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/solaris.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/netbsd.c": "/*\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/netbsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif   /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/aix.h": "/*-------------------------------------------------------------------------\n *\n * aix.h\n *\t  prototypes for AIX-specific routines\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/aix.h\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/netbsd.h": "/*-------------------------------------------------------------------------\n *\n * netbsd.h\n *\t  port-specific prototypes for NetBSD\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/netbsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/unixware.h": "/*\n * src/backend/port/dynloader/unixware.h\n *\n *-------------------------------------------------------------------------\n *\n * unixware.h\n *\t  port-specific prototypes for Intel x86/UNIXWARE 7\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * unixware.h,v 1.2 1995/03/17 06:40:18 andrew Exp\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on UnixWare.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/openbsd.h": "/*-------------------------------------------------------------------------\n *\n * openbsd.h\n *\t  port-specific prototypes for OpenBSD\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/openbsd.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/linux.c": "/*-------------------------------------------------------------------------\n *\n * linux.c\n *\t  Dynamic Loader for Postgres for Linux, generated from those for\n *\t  Ultrix.\n *\n *\t  You need to install the dld library on your Linux system!\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/linux.c\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#ifdef HAVE_DLD_H\n#include <dld.h>\n#endif\n\n#include \"dynloader.h\"\n#include \"miscadmin.h\"\n\n\n#ifndef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n#ifndef HAVE_DLD_H\n\telog(ERROR, \"dynamic load not supported\");\n\treturn NULL;\n#else\n\tstatic int\tdl_initialized = 0;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (dld_init(dld_find_executable(my_exec_path)))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * link the file, then check for undefined symbols!\n\t */\n\tif (dld_link(filename))\n\t\treturn NULL;\n\n\t/*\n\t * If undefined symbols: try to link with the C and math libraries! This\n\t * could be smarter, if the dynamic linker was able to handle shared libs!\n\t */\n\tif (dld_undefined_sym_count > 0)\n\t{\n\t\tif (dld_link(\"/usr/lib/libc.a\"))\n\t\t{\n\t\t\telog(WARNING, \"could not link C library\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dld_undefined_sym_count > 0)\n\t\t{\n\t\t\tif (dld_link(\"/usr/lib/libm.a\"))\n\t\t\t{\n\t\t\t\telog(WARNING, \"could not link math library\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dld_undefined_sym_count > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tcount = dld_undefined_sym_count;\n\t\t\t\tchar\t  **list = dld_list_undefined_sym();\n\n\t\t\t\t/* list the undefined symbols, if any */\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\t\tlist++;\n\t\t\t\t\tcount--;\n\t\t\t\t} while (count > 0);\n\n\t\t\t\tdld_unlink_by_file(filename, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) strdup(filename);\n#endif\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n#ifndef HAVE_DLD_H\n\treturn NULL;\n#else\n\treturn (PGFunction) dld_get_func((funcname));\n#endif\n}\n\nvoid\npg_dlclose(void *handle)\n{\n#ifndef HAVE_DLD_H\n#else\n\tdld_unlink_by_file(handle, 1);\n\tfree(handle);\n#endif\n}\n\nchar *\npg_dlerror(void)\n{\n#ifndef HAVE_DLD_H\n\treturn \"dynaloader unsupported\";\n#else\n\treturn dld_strerror(dld_errno);\n#endif\n}\n\n#endif   /* !HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/freebsd.c": "/*\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/freebsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif   /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/nextstep.c": "/* src/backend/port/dynloader/nextstep.c */\n\n#include \"postgres.h\"\n\n#include \"mach-o/rld.h\"\n#include \"streams/streams.h\"\n\nstatic char *lastError = NULL;\n\nstatic NXStream *\nOpenError()\n{\n\treturn NXOpenMemory(NULL, 0, NX_WRITEONLY);\n}\n\nstatic void\nCloseError(NXStream * s)\n{\n\tif (s)\n\t\tNXCloseMemory(s, NX_FREEBUFFER);\n}\n\nstatic void\nTransferError(NXStream * s)\n{\n\tchar\t   *buffer;\n\tint\t\t\tlen,\n\t\t\t\tmaxlen;\n\n\tif (lastError)\n\t\tfree(lastError);\n\tNXGetMemoryBuffer(s, &buffer, &len, &maxlen);\n\tlastError = malloc(len + 1);\n\tif(!lastError)\n\t\tereport(ERROR, errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\terrmsg(\"Transer error failed: out of memory\"));\n\n\tstrcpy(lastError, buffer);\n}\n\nvoid *\nnext_dlopen(char *name)\n{\n\tint\t\t\trld_success;\n\tNXStream   *errorStream;\n\tchar\t   *result = NULL;\n\tchar\t  **p;\n\n\terrorStream = OpenError();\n\tp = calloc(2, sizeof(void *));\n\tp[0] = name;\n\trld_success = rld_load(errorStream, NULL, p, NULL);\n\tfree(p);\n\n\tif (!rld_success)\n\t{\n\t\tTransferError(errorStream);\n\t\tresult = (char *) 1;\n\t}\n\tCloseError(errorStream);\n\treturn result;\n}\n\nint\nnext_dlclose(void *handle)\n{\n\treturn 0;\n}\n\nvoid *\nnext_dlsym(void *handle, char *symbol)\n{\n\tNXStream   *errorStream = OpenError();\n\tchar\t\tsymbuf[1024];\n\tunsigned long symref = 0;\n\n\tsnprintf(symbuf, sizeof(symbuf), \"_%s\", symbol);\n\tif (!rld_lookup(errorStream, symbuf, &symref))\n\t\tTransferError(errorStream);\n\tCloseError(errorStream);\n\treturn (void *) symref;\n}\n\nchar *\nnext_dlerror(void)\n{\n\treturn lastError;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/openbsd.c": "/*\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * src/backend/port/dynloader/openbsd.c\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif   /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/darwin.c": "/*\n * Dynamic loading support for Darwin\n *\n * If dlopen() is available (Darwin 10.3 and later), we just use it.\n * Otherwise we emulate it with the older, now deprecated, NSLinkModule API.\n *\n * src/backend/port/dynloader/darwin.c\n */\n#include \"postgres.h\"\n\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#else\n#include <mach-o/dyld.h>\n#endif\n\n#include \"dynloader.h\"\n\n\n#ifdef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n\treturn dlopen(filename, RTLD_NOW | RTLD_GLOBAL);\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tdlclose(handle);\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\t/* Do not prepend an underscore: see dlopen(3) */\n\treturn dlsym(handle, funcname);\n}\n\nchar *\npg_dlerror(void)\n{\n\treturn dlerror();\n}\n#else\t\t\t\t\t\t\t/* !HAVE_DLOPEN */\n\n/*\n * These routines were taken from the Apache source, but were made\n * available with a PostgreSQL-compatible license.  Kudos Wilfredo\n * S\u00e1nchez <wsanchez@apple.com>.\n */\n\nstatic NSObjectFileImageReturnCode cofiff_result = NSObjectFileImageFailure;\n\nvoid *\npg_dlopen(char *filename)\n{\n\tNSObjectFileImage image;\n\n\tcofiff_result = NSCreateObjectFileImageFromFile(filename, &image);\n\tif (cofiff_result != NSObjectFileImageSuccess)\n\t\treturn NULL;\n\treturn NSLinkModule(image, filename,\n\t\t\t\t\t\tNSLINKMODULE_OPTION_BINDNOW |\n\t\t\t\t\t\tNSLINKMODULE_OPTION_RETURN_ON_ERROR);\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tNSUnLinkModule(handle, FALSE);\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tNSSymbol symbol;\n\tchar\t   *symname = (char *) malloc(strlen(funcname) + 2);\n\n\tsprintf(symname, \"_%s\", funcname);\n\tif (NSIsSymbolNameDefined(symname))\n\t{\n\t\tsymbol = NSLookupAndBindSymbol(symname);\n\n\t\tfree(symname);\n\t\treturn (PGFunction) NSAddressOfSymbol(symbol);\n\t}\n\telse\n\t{\n\t\tfree(symname);\n\t\treturn NULL;\n\t}\n}\n\nchar *\npg_dlerror(void)\n{\n\tNSLinkEditErrors c;\n\tint\t\t\terrorNumber;\n\tconst char *fileName;\n\tconst char *errorString = NULL;\n\n\tswitch (cofiff_result)\n\t{\n\t\tcase NSObjectFileImageSuccess:\n\t\t\t/* must have failed in NSLinkModule */\n\t\t\tNSLinkEditError(&c, &errorNumber, &fileName, &errorString);\n\t\t\tif (errorString == NULL || *errorString == '\\0')\n\t\t\t\terrorString = \"unknown link-edit failure\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageFailure:\n\t\t\terrorString = \"failed to open object file\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageInappropriateFile:\n\t\t\terrorString = \"inappropriate object file\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageArch:\n\t\t\terrorString = \"object file is for wrong architecture\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageFormat:\n\t\t\terrorString = \"object file has wrong format\";\n\t\t\tbreak;\n\t\tcase NSObjectFileImageAccess:\n\t\t\terrorString = \"insufficient permissions for object file\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrorString = \"unknown failure to open object file\";\n\t\t\tbreak;\n\t}\n\n\treturn (char *) errorString;\n}\n\n#endif   /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/hpux.c": "/*-------------------------------------------------------------------------\n *\n * dynloader.c\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/port/dynloader/hpux.c\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n/* System includes */\n#include <a.out.h>\n#include <dl.h>\n\n#include \"dynloader.h\"\n#include \"utils/dynamic_loader.h\"\n\nvoid *\npg_dlopen(char *filename)\n{\n\t/*\n\t * Use BIND_IMMEDIATE so that undefined symbols cause a failure return\n\t * from shl_load(), rather than an abort() later on when we attempt to\n\t * call the library!\n\t */\n\tshl_t\t\thandle = shl_load(filename,\n\t\t\t\t\t\t\t\tBIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH,\n\t\t\t\t\t\t\t\t  0L);\n\n\treturn (void *) handle;\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tPGFunction\tf;\n\n\tif (shl_findsym((shl_t *) & handle, funcname, TYPE_PROCEDURE, &f) == -1)\n\t\tf = (PGFunction) NULL;\n\treturn f;\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tshl_unload((shl_t) handle);\n}\n\nchar *\npg_dlerror(void)\n{\n\tstatic char errmsg[] = \"shl_load failed\";\n\n\tif (errno)\n\t\treturn strerror(errno);\n\n\treturn errmsg;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/port/dynloader/linux.h": "/*-------------------------------------------------------------------------\n *\n * linux.h\n *\t\tPort-specific prototypes for Linux\n *\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/backend/port/dynloader/linux.h\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\t\t/* pgrminclude ignore */\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\n\n#ifdef HAVE_DLOPEN\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n#endif   /* HAVE_DLOPEN */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/utils/fmgr/dfmgr.c": "/*-------------------------------------------------------------------------\n *\n * dfmgr.c\n *\t  Dynamic function manager code.\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  src/backend/utils/fmgr/dfmgr.c\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include <sys/stat.h>\n\n#include \"dynloader.h\"\n#include \"lib/stringinfo.h\"\n#include \"miscadmin.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"utils/hsearch.h\"\n\n\n/* signatures for PostgreSQL-specific library init/fini functions */\ntypedef void (*PG_init_t) (void);\ntypedef void (*PG_fini_t) (void);\n\n/* hashtable entry for rendezvous variables */\ntypedef struct\n{\n\tchar\t\tvarName[NAMEDATALEN];\t/* hash key (must be first) */\n\tvoid\t   *varValue;\n} rendezvousHashEntry;\n\n/*\n * List of dynamically loaded files (kept in malloc'd memory).\n */\n\ntypedef struct df_files\n{\n\tstruct df_files *next;\t\t/* List link */\n\tdev_t\t\tdevice;\t\t\t/* Device file is on */\n#ifndef WIN32\t\t\t\t\t/* ensures we never again depend on this under\n\t\t\t\t\t\t\t\t * win32 */\n\tino_t\t\tinode;\t\t\t/* Inode number of file */\n#endif\n\tvoid\t   *handle;\t\t\t/* a handle for pg_dl* functions */\n\tchar\t\tfilename[1];\t/* Full pathname of file */\n\n\t/*\n\t * we allocate the block big enough for actual length of pathname.\n\t * filename[] must be last item in struct!\n\t */\n} DynamicFileList;\n\nstatic DynamicFileList *file_list = NULL;\nstatic DynamicFileList *file_tail = NULL;\n\n/* stat() call under Win32 returns an st_ino field, but it has no meaning */\n#ifndef WIN32\n#define SAME_INODE(A,B) ((A).st_ino == (B).inode && (A).st_dev == (B).device)\n#else\n#define SAME_INODE(A,B) false\n#endif\n\nchar\t   *Dynamic_library_path;\n\nstatic void *internal_load_library(const char *libname);\nstatic void incompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data);\nstatic void internal_unload_library(const char *libname);\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\nstatic char *find_in_dynamic_libpath(const char *basename);\nstatic const char *get_magic_product(const Pg_magic_struct *module_magic_data);\n\n/* Magic structure that module needs to match to be accepted */\nstatic const Pg_magic_struct magic_data = PG_MODULE_MAGIC_DATA;\n\n\n/*\n * Load the specified dynamic-link library file, and look for a function\n * named funcname in it.\n *\n * If the function is not found, we raise an error if signalNotFound is true,\n * else return (PGFunction) NULL.  Note that errors in loading the library\n * will provoke ereport() regardless of signalNotFound.\n *\n * If filehandle is not NULL, then *filehandle will be set to a handle\n * identifying the library file.  The filehandle can be used with\n * lookup_external_function to lookup additional functions in the same file\n * at less cost than repeating load_external_function.\n */\nPGFunction\nload_external_function(char *filename, char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/* Look up the function within the library */\n\tretval = (PGFunction) pg_dlsym(lib_handle, funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}\n\n/*\n * This function loads a shlib file without looking up any particular\n * function in it.  If the same shlib has previously been loaded,\n * unload and reload it.\n *\n * When 'restricted' is true, only libraries in the presumed-secure\n * directory $libdir/plugins may be referenced.\n */\nvoid\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}\n\n/*\n * Lookup a function whose library file is already loaded.\n * Return (PGFunction) NULL if not found.\n */\nPGFunction\nlookup_external_function(void *filehandle, char *funcname)\n{\n\treturn (PGFunction) pg_dlsym(filehandle, funcname);\n}\n\n\n/*\n * Load the specified dynamic-link library file, unless it already is\n * loaded.  Return the pg_dl* handle for the file.\n *\n * Note: libname is expected to be an exact name for the library file.\n */\nstatic void *\ninternal_load_library(const char *libname)\n{\n\tDynamicFileList *file_scanner;\n\tPGModuleMagicFunction magic_func;\n\tchar\t   *load_error;\n\tstruct stat stat_buf;\n\tPG_init_t\tPG_init;\n\n\t/*\n\t * Scan the list of loaded FILES to see if the file has been loaded.\n\t */\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL &&\n\t\t strcmp(libname, file_scanner->filename) != 0;\n\t\t file_scanner = file_scanner->next)\n\t\t;\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * Check for same files - different paths (ie, symlink or link)\n\t\t */\n\t\tif (stat(libname, &stat_buf) == -1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tlibname)));\n\n\t\tfor (file_scanner = file_list;\n\t\t\t file_scanner != NULL &&\n\t\t\t !SAME_INODE(stat_buf, *file_scanner);\n\t\t\t file_scanner = file_scanner->next)\n\t\t\t;\n\t}\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * File not loaded yet.\n\t\t */\n\t\tfile_scanner = (DynamicFileList *)\n\t\t\tmalloc(sizeof(DynamicFileList) + strlen(libname));\n\t\tif (file_scanner == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\tMemSet(file_scanner, 0, sizeof(DynamicFileList));\n\t\tstrcpy(file_scanner->filename, libname);\n\t\tfile_scanner->device = stat_buf.st_dev;\n#ifndef WIN32\n\t\tfile_scanner->inode = stat_buf.st_ino;\n#endif\n\t\tfile_scanner->next = NULL;\n\n\t\tfile_scanner->handle = pg_dlopen(file_scanner->filename);\n\t\tif (file_scanner->handle == NULL)\n\t\t{\n\t\t\tload_error = (char *) pg_dlerror();\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* errcode_for_file_access might not be appropriate here? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not load library \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tlibname, load_error)));\n\t\t}\n\n\t\t/* Check the magic function to determine compatibility */\n\t\tmagic_func = (PGModuleMagicFunction)\n\t\t\tpg_dlsym(file_scanner->handle, PG_MAGIC_FUNCTION_NAME_STRING);\n\t\tif (magic_func)\n\t\t{\n\t\t\tconst Pg_magic_struct *magic_data_ptr = (*magic_func) ();\n\n\t\t\tif (magic_data_ptr->len != magic_data.len ||\n\t\t\t\tmemcmp(magic_data_ptr, &magic_data, magic_data.len) != 0)\n\t\t\t{\n\t\t\t\t/* copy data block before unlinking library */\n\t\t\t\tPg_magic_struct module_magic_data = *magic_data_ptr;\n\n\t\t\t\t/* try to unlink library */\n\t\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\t\tfree((char *) file_scanner);\n\n\t\t\t\t/* issue suitable complaint */\n\t\t\t\tincompatible_module_error(libname, &module_magic_data);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try to unlink library */\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* complain */\n\t\t\tereport(ERROR,\n\t\t\t\t  (errmsg(\"incompatible library \\\"%s\\\": missing magic block\",\n\t\t\t\t\t\t  libname),\n\t\t\t\t   errhint(\"Extension libraries are required to use the PG_MODULE_MAGIC macro.\")));\n\t\t}\n\n\t\t/*\n\t\t * If the library has a _PG_init() function, call it.\n\t\t */\n\t\tPG_init = (PG_init_t) pg_dlsym(file_scanner->handle, \"_PG_init\");\n\t\tif (PG_init)\n\t\t\t(*PG_init) ();\n\n\t\t/* OK to link it into list */\n\t\tif (file_list == NULL)\n\t\t\tfile_list = file_scanner;\n\t\telse\n\t\t\tfile_tail->next = file_scanner;\n\t\tfile_tail = file_scanner;\n\t}\n\n\treturn file_scanner->handle;\n}\n\n/*\n * Identify what product a particular magic data was compiled for.\n */\nstatic const char*\nget_magic_product(const Pg_magic_struct *module_magic_data)\n{\n\t/*\n\t * Assume that any magic_data context that does not contain a product code\n\t * must be Postgres, probably.\n\t */\n\tif (module_magic_data->len <= offsetof(Pg_magic_struct, product))\n\t\treturn \"PostgreSQL\";\n\t\n\tswitch (module_magic_data->product)\n\t{\n\t\tcase PgMagicProductNone:\n\t\tcase PgMagicProductPostgres:\n\t\t\treturn \"PostgreSQL\";\n\n\t\tcase PgMagicProductGreenplum:\n\t\t\treturn \"Greenplum\";\n\n\t\t/* Handle Unrecognized product codes */\n\t\tdefault:\n\t\t\treturn psprintf(\"Product(%d)\", module_magic_data->product);\n\t}\n}\n\n\n/*\n * Report a suitable error for an incompatible magic block.\n */\nstatic void\nincompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data)\n{\n\tStringInfoData details;\n\tconst char *magic_product     = get_magic_product(&magic_data);\n\tconst char *mod_magic_product = get_magic_product(module_magic_data);\n\n\t/*\n\t * The default header version for module_magic_data is assumed to be 0\n\t * as it may not be recent enough to have the headerversion field\n\t */\n\tint lib_internal_version = 0;\n\n\t/* module_magic_data is recent enough to provide its own header version */\n\tif (module_magic_data->len > offsetof(Pg_magic_struct, headerversion))\n\t{\n\t\tlib_internal_version = module_magic_data->headerversion;\n\t}\n\n\t/*\n\t * If the version doesn't match, just report that, because the rest of the\n\t * block might not even have the fields we expect.\n\t */\n\tif (magic_data.version != module_magic_data->version ||\n\t\tmagic_data.product != module_magic_data->product ||\n\t\tmagic_data.headerversion != lib_internal_version)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"incompatible library \\\"%s\\\": version mismatch\",\n\t\t\t\t\t\tlibname),\n\t\t\t  errdetail(\"Server version is %s %d.%d (header version: %d), library is %s %d.%d (header version: %d).\",\n\t\t\t\t\t\tmagic_product,\n\t\t\t\t\t\tmagic_data.version / 100,\n\t\t\t\t\t\tmagic_data.version % 100,\n\t\t\t\t\t\tmagic_data.headerversion,\n\t\t\t\t\t\tmod_magic_product,\n\t\t\t\t\t\tmodule_magic_data->version / 100,\n\t\t\t\t\t\tmodule_magic_data->version % 100,\n\t\t\t\t\t\tlib_internal_version)\n\t\t\t\t)\n\t\t);\n\t}\n\n\t/*\n\t * Otherwise, spell out which fields don't agree.\n\t *\n\t * XXX this code has to be adjusted any time the set of fields in a magic\n\t * block change!\n\t */\n\tinitStringInfo(&details);\n\n\tif (module_magic_data->funcmaxargs != magic_data.funcmaxargs)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FUNC_MAX_ARGS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.funcmaxargs,\n\t\t\t\t\t\t module_magic_data->funcmaxargs);\n\t}\n\tif (module_magic_data->indexmaxkeys != magic_data.indexmaxkeys)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has INDEX_MAX_KEYS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.indexmaxkeys,\n\t\t\t\t\t\t module_magic_data->indexmaxkeys);\n\t}\n\tif (module_magic_data->namedatalen != magic_data.namedatalen)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has NAMEDATALEN = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.namedatalen,\n\t\t\t\t\t\t module_magic_data->namedatalen);\n\t}\n\tif (module_magic_data->float4byval != magic_data.float4byval)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT4PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float4byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float4byval ? \"true\" : \"false\");\n\t}\n\tif (module_magic_data->float8byval != magic_data.float8byval)\n\t{\n\t\tif (details.len)\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT8PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float8byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float8byval ? \"true\" : \"false\");\n\t}\n\n\tif (details.len == 0)\n\t\tappendStringInfoString(&details,\n\t\t\t  _(\"Magic block has unexpected length or padding difference.\"));\n\n\tereport(ERROR,\n\t\t\t(errmsg(\"incompatible library \\\"%s\\\": magic block mismatch\",\n\t\t\t\t\tlibname),\n\t\t\t errdetail_internal(\"%s\", details.data)));\n}\n\n/*\n * Unload the specified dynamic-link library file, if it is loaded.\n *\n * Note: libname is expected to be an exact name for the library file.\n *\n * XXX for the moment, this is disabled, resulting in LOAD of an already-loaded\n * library always being a no-op.  We might re-enable it someday if we can\n * convince ourselves we have safe protocols for un-hooking from hook function\n * pointers, releasing custom GUC variables, and perhaps other things that\n * are definitely unsafe currently.\n */\nstatic void\ninternal_unload_library(const char *libname)\n{\n#ifdef NOT_USED\n\tDynamicFileList *file_scanner,\n\t\t\t   *prv,\n\t\t\t   *nxt;\n\tstruct stat stat_buf;\n\tPG_fini_t\tPG_fini;\n\n\t/*\n\t * We need to do stat() in order to determine whether this is the same\n\t * file as a previously loaded file; it's also handy so as to give a good\n\t * error message if bogus file name given.\n\t */\n\tif (stat(libname, &stat_buf) == -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", libname)));\n\n\t/*\n\t * We have to zap all entries in the list that match on either filename or\n\t * inode, else internal_load_library() will still think it's present.\n\t */\n\tprv = NULL;\n\tfor (file_scanner = file_list; file_scanner != NULL; file_scanner = nxt)\n\t{\n\t\tnxt = file_scanner->next;\n\t\tif (strcmp(libname, file_scanner->filename) == 0 ||\n\t\t\tSAME_INODE(stat_buf, *file_scanner))\n\t\t{\n\t\t\tif (prv)\n\t\t\t\tprv->next = nxt;\n\t\t\telse\n\t\t\t\tfile_list = nxt;\n\n\t\t\t/*\n\t\t\t * If the library has a _PG_fini() function, call it.\n\t\t\t */\n\t\t\tPG_fini = (PG_fini_t) pg_dlsym(file_scanner->handle, \"_PG_fini\");\n\t\t\tif (PG_fini)\n\t\t\t\t(*PG_fini) ();\n\n\t\t\tclear_external_function_hash(file_scanner->handle);\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* prv does not change */\n\t\t}\n\t\telse\n\t\t\tprv = file_scanner;\n\t}\n#endif   /* NOT_USED */\n}\n\nstatic bool\nfile_exists(const char *name)\n{\n\tstruct stat st;\n\n\tAssertArg(name != NULL);\n\n\tif (stat(name, &st) == 0)\n\t\treturn S_ISDIR(st.st_mode) ? false : true;\n\telse if (!(errno == ENOENT || errno == ENOTDIR || errno == EACCES))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", name)));\n\n\treturn false;\n}\n\n\n/* Example format: \".so\" */\n#ifndef DLSUFFIX\n#error \"DLSUFFIX must be defined to compile this file.\"\n#endif\n\n/*\n * If name contains a slash, check if the file exists, if so return\n * the name.  Else (no slash) try to expand using search path (see\n * find_in_dynamic_libpath below); if that works, return the fully\n * expanded file name.  If the previous failed, append DLSUFFIX and\n * try again.  If all fails, just return the original name.\n *\n * The result will always be freshly palloc'd.\n */\nstatic char *\nexpand_dynamic_library_name(const char *name)\n{\n\tbool\t\thave_slash;\n\tchar\t   *new;\n\tchar\t   *full;\n\n\tAssertArg(name);\n\n\thave_slash = (first_dir_separator(name) != NULL);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(name);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(name);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\tnew = psprintf(\"%s%s\", name, DLSUFFIX);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(new);\n\t\tpfree(new);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(new);\n\t\tpfree(new);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\t/*\n\t * If we can't find the file, just return the string as-is. The ensuing\n\t * load attempt will fail and report a suitable message.\n\t */\n\treturn pstrdup(name);\n}\n\n/*\n * Check a restricted library name.  It must begin with \"$libdir/plugins/\"\n * and there must not be any directory separators after that (this is\n * sufficient to prevent \"..\" style attacks).\n */\nstatic void\ncheck_restricted_library_name(const char *name)\n{\n\tif (strncmp(name, \"$libdir/plugins/\", 16) != 0 ||\n\t\tfirst_dir_separator(name + 16) != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"access to library \\\"%s\\\" is not allowed\",\n\t\t\t\t\t\tname)));\n}\n\n/*\n * Substitute for any macros appearing in the given string.\n * Result is always freshly palloc'd.\n */\nstatic char *\nsubstitute_libpath_macro(const char *name)\n{\n\tconst char *sep_ptr;\n\n\tAssertArg(name != NULL);\n\n\t/* Currently, we only recognize $libdir at the start of the string */\n\tif (name[0] != '$')\n\t\treturn pstrdup(name);\n\n\tif ((sep_ptr = first_dir_separator(name)) == NULL)\n\t\tsep_ptr = name + strlen(name);\n\n\tif (strlen(\"$libdir\") != sep_ptr - name ||\n\t\tstrncmp(name, \"$libdir\", strlen(\"$libdir\")) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid macro name in dynamic library path: %s\",\n\t\t\t\t\t\tname)));\n\n\treturn psprintf(\"%s%s\", pkglib_path, sep_ptr);\n}\n\n\n/*\n * Search for a file called 'basename' in the colon-separated search\n * path Dynamic_library_path.  If the file is found, the full file name\n * is returned in freshly palloc'd memory.  If the file is not found,\n * return NULL.\n */\nstatic char *\nfind_in_dynamic_libpath(const char *basename)\n{\n\tconst char *p;\n\tsize_t\t\tbaselen;\n\n\tAssertArg(basename != NULL);\n\tAssertArg(first_dir_separator(basename) == NULL);\n\tAssertState(Dynamic_library_path != NULL);\n\n\tp = Dynamic_library_path;\n\tif (strlen(p) == 0)\n\t\treturn NULL;\n\n\tbaselen = strlen(basename);\n\n\tfor (;;)\n\t{\n\t\tsize_t\t\tlen;\n\t\tchar\t   *piece;\n\t\tchar\t   *mangled;\n\t\tchar\t   *full;\n\n\t\tpiece = first_path_var_separator(p);\n\t\tif (piece == p)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"zero-length component in parameter \\\"dynamic_library_path\\\"\")));\n\n\t\tif (piece == NULL)\n\t\t\tlen = strlen(p);\n\t\telse\n\t\t\tlen = piece - p;\n\n\t\tpiece = palloc(len + 1);\n\t\tstrlcpy(piece, p, len + 1);\n\n\t\tmangled = substitute_libpath_macro(piece);\n\t\tpfree(piece);\n\n\t\tcanonicalize_path(mangled);\n\n\t\t/* only absolute paths */\n\t\tif (!is_absolute_path(mangled))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"component in parameter \\\"dynamic_library_path\\\" is not an absolute path\")));\n\n\t\tfull = palloc(strlen(mangled) + 1 + baselen + 1);\n\t\tsprintf(full, \"%s/%s\", mangled, basename);\n\t\tpfree(mangled);\n\n\t\telog(DEBUG3, \"find_in_dynamic_libpath: trying \\\"%s\\\"\", full);\n\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\n\t\tpfree(full);\n\n\t\tif (p[len] == '\\0')\n\t\t\tbreak;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Find (or create) a rendezvous variable that one dynamically\n * loaded library can use to meet up with another.\n *\n * On the first call of this function for a particular varName,\n * a \"rendezvous variable\" is created with the given name.\n * The value of the variable is a void pointer (initially set to NULL).\n * Subsequent calls with the same varName just return the address of\n * the existing variable.  Once created, a rendezvous variable lasts\n * for the life of the process.\n *\n * Dynamically loaded libraries can use rendezvous variables\n * to find each other and share information: they just need to agree\n * on the variable name and the data it will point to.\n */\nvoid\t  **\nfind_rendezvous_variable(const char *varName)\n{\n\tstatic HTAB *rendezvousHash = NULL;\n\n\trendezvousHashEntry *hentry;\n\tbool\t\tfound;\n\n\t/* Create a hashtable if we haven't already done so in this process */\n\tif (rendezvousHash == NULL)\n\t{\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = NAMEDATALEN;\n\t\tctl.entrysize = sizeof(rendezvousHashEntry);\n\t\trendezvousHash = hash_create(\"Rendezvous variable hash\",\n\t\t\t\t\t\t\t\t\t 16,\n\t\t\t\t\t\t\t\t\t &ctl,\n\t\t\t\t\t\t\t\t\t HASH_ELEM);\n\t}\n\n\t/* Find or create the hashtable entry for this varName */\n\thentry = (rendezvousHashEntry *) hash_search(rendezvousHash,\n\t\t\t\t\t\t\t\t\t\t\t\t varName,\n\t\t\t\t\t\t\t\t\t\t\t\t HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t\t &found);\n\n\t/* Initialize to NULL if first time */\n\tif (!found)\n\t\thentry->varValue = NULL;\n\n\treturn &hentry->varValue;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/regress/pg_regress.c": "/*-------------------------------------------------------------------------\n *\n * pg_regress --- regression test driver\n *\n * This is a C implementation of the previous shell script for running\n * the regression tests, and should be mostly compatible with it.\n * Initial author of C translation: Magnus Hagander\n *\n * This code is released under the terms of the PostgreSQL License.\n *\n * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/test/regress/pg_regress.c\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"pg_regress.h\"\n\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <unistd.h>\n\n#ifdef __linux__\n#include <mntent.h>\n#endif\n\n#ifdef HAVE_SYS_RESOURCE_H\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#include \"common/username.h\"\n#include \"getopt_long.h\"\n#include \"libpq/pqcomm.h\"\t\t/* needed for UNIXSOCK_PATH() */\n#include \"pg_config_paths.h\"\n\n/* for resultmap we need a list of pairs of strings */\ntypedef struct _resultmap\n{\n\tchar\t   *test;\n\tchar\t   *type;\n\tchar\t   *resultfile;\n\tstruct _resultmap *next;\n} _resultmap;\n\n/*\n * Values obtained from pg_config_paths.h and Makefile.  The PG installation\n * paths are only used in temp_install mode: we use these strings to find\n * out where \"make install\" will put stuff under the temp_install directory.\n * In non-temp_install mode, the only thing we need is the location of psql,\n * which we expect to find in psqldir, or in the PATH if psqldir isn't given.\n *\n * XXX Because pg_regress is not installed in bindir, we can't support\n * this for relocatable trees as it is.  --psqldir would need to be\n * specified in those cases.\n */\nchar\t   *bindir = PGBINDIR;\nchar\t   *libdir = LIBDIR;\nchar\t   *datadir = PGSHAREDIR;\nchar\t   *host_platform = HOST_TUPLE;\n\n#ifndef WIN32_ONLY_COMPILER\nstatic char *makeprog = MAKEPROG;\n#endif\n\n#ifndef WIN32\t\t\t\t\t/* not used in WIN32 case */\nstatic char *shellprog = SHELLPROG;\n#endif\n\nstatic char gpdiffprog[MAXPGPATH];\nstatic char gpstringsubsprog[MAXPGPATH];\n\n/*\n * On Windows we use -w in diff switches to avoid problems with inconsistent\n * newline representation.  The actual result files will generally have\n * Windows-style newlines, but the comparison files might or might not.\n */\n#ifndef WIN32\n/* GPDB:  Add stuff to ignore all the extra NOTICE messages we give */\nconst char *basic_diff_opts = \"-I HINT: -I CONTEXT: -I GP_IGNORE:\";\nconst char *pretty_diff_opts = \"-I HINT: -I CONTEXT: -I GP_IGNORE: -U3\";\n#else\nconst char *basic_diff_opts = \"-w\";\nconst char *pretty_diff_opts = \"-w -C3\";\n#endif\n\n/* options settable from command line */\n_stringlist *dblist = NULL;\nbool\t\tdebug = false;\nchar\t   *inputdir = \".\";\nchar\t   *outputdir = \".\";\nchar\t   *prehook = \"\";\nchar\t   *psqldir = PGBINDIR;\nchar\t   *launcher = NULL;\nbool        print_failure_diffs_is_enabled = false;\nbool \t\toptimizer_enabled = false;\nbool \t\tresgroup_enabled = false;\nstatic _stringlist *loadlanguage = NULL;\nstatic _stringlist *loadextension = NULL;\nstatic int\tmax_connections = 0;\nstatic char *encoding = NULL;\nstatic _stringlist *schedulelist = NULL;\nstatic _stringlist *exclude_tests = NULL;\nstatic _stringlist *extra_tests = NULL;\nstatic char *temp_install = NULL;\nstatic char *temp_config = NULL;\nstatic char *top_builddir = NULL;\nstatic bool nolocale = false;\nstatic bool use_existing = false;\nstatic char *hostname = NULL;\nstatic int\tport = -1;\nstatic bool port_specified_by_user = false;\nstatic char *dlpath = PKGLIBDIR;\nstatic char *user = NULL;\nstatic _stringlist *extraroles = NULL;\nstatic _stringlist *extra_install = NULL;\nstatic char *initfile = NULL;\nstatic char *config_auth_datadir = NULL;\nstatic bool  ignore_plans = false;\n\n/* internal variables */\nstatic const char *progname;\nstatic char *logfilename;\nstatic FILE *logfile;\nstatic char *difffilename;\nstatic const char *sockdir;\n#ifdef HAVE_UNIX_SOCKETS\nstatic const char *temp_sockdir;\nstatic char sockself[MAXPGPATH];\nstatic char socklock[MAXPGPATH];\n#endif\n\nstatic _resultmap *resultmap = NULL;\n\nstatic PID_TYPE postmaster_pid = INVALID_PID;\nstatic bool postmaster_running = false;\n\nstatic int\tsuccess_count = 0;\nstatic int\tfail_count = 0;\nstatic int\tfail_ignore_count = 0;\n\nstatic bool directory_exists(const char *dir);\nstatic void make_directory(const char *dir);\n\nstatic void create_database(const char *dbname);\nstatic void drop_database_if_exists(const char *dbname);\n\nstatic int\nrun_diff(const char *cmd, const char *filename);\n\nstatic bool should_exclude_test(char *test);\n\nstatic void\nheader(const char *fmt,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nstatic void\nstatus(const char *fmt,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nstatic void\npsql_command(const char *database, const char *query,...)\n/* This extension allows gcc to check the format string for consistency with\n   the supplied arguments. */\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\n#ifdef WIN32\ntypedef BOOL (WINAPI * __CreateRestrictedToken) (HANDLE, DWORD, DWORD, PSID_AND_ATTRIBUTES, DWORD, PLUID_AND_ATTRIBUTES, DWORD, PSID_AND_ATTRIBUTES, PHANDLE);\n\n/* Windows API define missing from some versions of MingW headers */\n#ifndef  DISABLE_MAX_PRIVILEGE\n#define DISABLE_MAX_PRIVILEGE\t0x1\n#endif\n#endif\n\nstatic bool detectCgroupMountPoint(char *cgdir, int len);\n\nstatic char *content_zero_hostname = NULL;\nstatic char *get_host_name(int16 contentid, char role);\n\n/*\n * allow core files if possible.\n */\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_CORE)\nstatic void\nunlimit_core_size(void)\n{\n\tstruct rlimit lim;\n\n\tgetrlimit(RLIMIT_CORE, &lim);\n\tif (lim.rlim_max == 0)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not set core size: disallowed by hard limit\\n\"),\n\t\t\t\tprogname);\n\t\treturn;\n\t}\n\telse if (lim.rlim_max == RLIM_INFINITY || lim.rlim_cur < lim.rlim_max)\n\t{\n\t\tlim.rlim_cur = lim.rlim_max;\n\t\tsetrlimit(RLIMIT_CORE, &lim);\n\t}\n}\n#endif\n\n\n/*\n * Add an item at the end of a stringlist.\n */\nvoid\nadd_stringlist_item(_stringlist **listhead, const char *str)\n{\n\t_stringlist *newentry = malloc(sizeof(_stringlist));\n\t_stringlist *oldentry;\n\n\tnewentry->str = strdup(str);\n\tnewentry->next = NULL;\n\tif (*listhead == NULL)\n\t\t*listhead = newentry;\n\telse\n\t{\n\t\tfor (oldentry = *listhead; oldentry->next; oldentry = oldentry->next)\n\t\t\t /* skip */ ;\n\t\toldentry->next = newentry;\n\t}\n}\n\n/*\n * Free a stringlist.\n */\nstatic void\nfree_stringlist(_stringlist **listhead)\n{\n\tif (listhead == NULL || *listhead == NULL)\n\t\treturn;\n\tif ((*listhead)->next != NULL)\n\t\tfree_stringlist(&((*listhead)->next));\n\tfree((*listhead)->str);\n\tfree(*listhead);\n\t*listhead = NULL;\n}\n\n/*\n * Split a delimited string into a stringlist\n */\nstatic void\nsplit_to_stringlist(const char *s, const char *delim, _stringlist **listhead)\n{\n\tchar\t   *sc = strdup(s);\n\tchar\t   *token = strtok(sc, delim);\n\n\twhile (token)\n\t{\n\t\tadd_stringlist_item(listhead, token);\n\t\ttoken = strtok(NULL, delim);\n\t}\n\tfree(sc);\n}\n\n/*\n * Print a progress banner on stdout.\n */\nstatic void\nheader(const char *fmt,...)\n{\n\tchar\t\ttmp[64];\n\tva_list\t\tap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(tmp, sizeof(tmp), fmt, ap);\n\tva_end(ap);\n\n\tfprintf(stdout, \"============== %-38s ==============\\n\", tmp);\n\tfflush(stdout);\n}\n\n/*\n * Print \"doing something ...\" --- supplied text should not end with newline\n */\nstatic void\nstatus(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stdout, fmt, ap);\n\tfflush(stdout);\n\tva_end(ap);\n\n\tif (logfile)\n\t{\n\t\tva_start(ap, fmt);\n\t\tvfprintf(logfile, fmt, ap);\n\t\tva_end(ap);\n\t}\n}\n\n/*\n * Done \"doing something ...\"\n */\nstatic void\nstatus_end(void)\n{\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (logfile)\n\t\tfprintf(logfile, \"\\n\");\n}\n\n/*\n * shut down temp postmaster\n */\nstatic void\nstop_postmaster(void)\n{\n\tif (postmaster_running)\n\t{\n\t\t/* We use pg_ctl to issue the kill and wait for stop */\n\t\tchar\t\tbuf[MAXPGPATH * 2];\n\t\tint\t\t\tr;\n\n\t\t/* On Windows, system() seems not to force fflush, so... */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t \"\\\"%s/pg_ctl\\\" stop -D \\\"%s/data\\\" -s -m fast\",\n\t\t\t\t bindir, temp_install);\n\t\tr = system(buf);\n\t\tif (r != 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not stop postmaster: exit code was %d\\n\"),\n\t\t\t\t\tprogname, r);\n\t\t\t_exit(2);\t\t\t/* not exit(), that could be recursive */\n\t\t}\n\n\t\tpostmaster_running = false;\n\t}\n}\n\n#ifdef HAVE_UNIX_SOCKETS\n/*\n * Remove the socket temporary directory.  pg_regress never waits for a\n * postmaster exit, so it is indeterminate whether the postmaster has yet to\n * unlink the socket and lock file.  Unlink them here so we can proceed to\n * remove the directory.  Ignore errors; leaking a temporary directory is\n * unimportant.  This can run from a signal handler.  The code is not\n * acceptable in a Windows signal handler (see initdb.c:trapsig()), but\n * Windows is not a HAVE_UNIX_SOCKETS platform.\n */\nstatic void\nremove_temp(void)\n{\n\tAssert(temp_sockdir);\n\tunlink(sockself);\n\tunlink(socklock);\n\trmdir(temp_sockdir);\n}\n\n/*\n * Signal handler that calls remove_temp() and reraises the signal.\n */\nstatic void\nsignal_remove_temp(int signum)\n{\n\tremove_temp();\n\n\tpqsignal(signum, SIG_DFL);\n\traise(signum);\n}\n\n/*\n * Create a temporary directory suitable for the server's Unix-domain socket.\n * The directory will have mode 0700 or stricter, so no other OS user can open\n * our socket to exploit our use of trust authentication.  Most systems\n * constrain the length of socket paths well below _POSIX_PATH_MAX, so we\n * place the directory under /tmp rather than relative to the possibly-deep\n * current working directory.\n *\n * Compared to using the compiled-in DEFAULT_PGSOCKET_DIR, this also permits\n * testing to work in builds that relocate it to a directory not writable to\n * the build/test user.\n */\nstatic const char *\nmake_temp_sockdir(void)\n{\n\tchar\t   *template = strdup(\"/tmp/pg_regress-XXXXXX\");\n\n\ttemp_sockdir = mkdtemp(template);\n\tif (temp_sockdir == NULL)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not create directory \\\"%s\\\": %s\\n\"),\n\t\t\t\tprogname, template, strerror(errno));\n\t\texit(2);\n\t}\n\n\t/* Stage file names for remove_temp().  Unsafe in a signal handler. */\n\tUNIXSOCK_PATH(sockself, port, temp_sockdir);\n\tsnprintf(socklock, sizeof(socklock), \"%s.lock\", sockself);\n\n\t/* Remove the directory during clean exit. */\n\tatexit(remove_temp);\n\n\t/*\n\t * Remove the directory before dying to the usual signals.  Omit SIGQUIT,\n\t * preserving it as a quick, untidy exit.\n\t */\n\tpqsignal(SIGHUP, signal_remove_temp);\n\tpqsignal(SIGINT, signal_remove_temp);\n\tpqsignal(SIGPIPE, signal_remove_temp);\n\tpqsignal(SIGTERM, signal_remove_temp);\n\n\treturn temp_sockdir;\n}\n#endif   /* HAVE_UNIX_SOCKETS */\n\n/*\n * Always exit through here, not through plain exit(), to ensure we make\n * an effort to shut down a temp postmaster\n */\nvoid\nexit_nicely(int code)\n{\n\tstop_postmaster();\n\texit(code);\n}\n\n/*\n * Check whether string matches pattern\n *\n * In the original shell script, this function was implemented using expr(1),\n * which provides basic regular expressions restricted to match starting at\n * the string start (in conventional regex terms, there's an implicit \"^\"\n * at the start of the pattern --- but no implicit \"$\" at the end).\n *\n * For now, we only support \".\" and \".*\" as non-literal metacharacters,\n * because that's all that anyone has found use for in resultmap.  This\n * code could be extended if more functionality is needed.\n */\nstatic bool\nstring_matches_pattern(const char *str, const char *pattern)\n{\n\twhile (*str && *pattern)\n\t{\n\t\tif (*pattern == '.' && pattern[1] == '*')\n\t\t{\n\t\t\tpattern += 2;\n\t\t\t/* Trailing .* matches everything. */\n\t\t\tif (*pattern == '\\0')\n\t\t\t\treturn true;\n\n\t\t\t/*\n\t\t\t * Otherwise, scan for a text position at which we can match the\n\t\t\t * rest of the pattern.\n\t\t\t */\n\t\t\twhile (*str)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Optimization to prevent most recursion: don't recurse\n\t\t\t\t * unless first pattern char might match this text char.\n\t\t\t\t */\n\t\t\t\tif (*str == *pattern || *pattern == '.')\n\t\t\t\t{\n\t\t\t\t\tif (string_matches_pattern(str, pattern))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tstr++;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * End of text with no match.\n\t\t\t */\n\t\t\treturn false;\n\t\t}\n\t\telse if (*pattern != '.' && *str != *pattern)\n\t\t{\n\t\t\t/*\n\t\t\t * Not the single-character wildcard and no explicit match? Then\n\t\t\t * time to quit...\n\t\t\t */\n\t\t\treturn false;\n\t\t}\n\n\t\tstr++;\n\t\tpattern++;\n\t}\n\n\tif (*pattern == '\\0')\n\t\treturn true;\t\t\t/* end of pattern, so declare match */\n\n\t/* End of input string.  Do we have matching pattern remaining? */\n\twhile (*pattern == '.' && pattern[1] == '*')\n\t\tpattern += 2;\n\tif (*pattern == '\\0')\n\t\treturn true;\t\t\t/* end of pattern, so declare match */\n\n\treturn false;\n}\n\n/*\n * Replace all occurrences of a string in a string with a different string.\n * NOTE: Assumes there is enough room in the target buffer!\n */\nvoid\nreplace_string(char *string, char *replace, char *replacement)\n{\n\tchar\t   *ptr;\n\n\twhile ((ptr = strstr(string, replace)) != NULL)\n\t{\n\t\tchar\t   *dup = strdup(string);\n\n\t\tstrlcpy(string, dup, ptr - string + 1);\n\t\tstrcat(string, replacement);\n\t\tstrcat(string, dup + (ptr - string) + strlen(replace));\n\t\tfree(dup);\n\t}\n}\n\ntypedef struct replacements\n{\n\tchar *abs_srcdir;\n\tchar *abs_builddir;\n\tchar *testtablespace;\n\tchar *dlpath;\n\tchar *dlsuffix;\n\tchar *bindir;\n\tchar *orientation;\n\tchar *cgroup_mnt_point;\n\tchar *content_zero_hostname;\n\tconst char *username;\n} replacements;\n\n/* Internal helper function to detect cgroup mount point at runtime.*/\nstatic bool\ndetectCgroupMountPoint(char *cgdir, int len)\n{\n#ifdef __linux__\n\tstruct mntent *me;\n\tFILE *fp;\n\tbool ret = false;\n\n\tfp = setmntent(\"/proc/self/mounts\", \"r\");\n\tif (fp == NULL)\n\t\treturn ret;\n\n\twhile ((me = getmntent(fp)))\n\t{\n\t\tchar *p;\n\n\t\tif (strcmp(me->mnt_type, \"cgroup\"))\n\t\t\tcontinue;\n\n\t\tstrncpy(cgdir, me->mnt_dir, len);\n\n\t\tp = strrchr(cgdir, '/');\n\t\tif (p != NULL)\n\t\t{\n\t\t\t*p = 0;\n\t\t\tret = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\tendmntent(fp);\n\treturn ret;\n#else\n\treturn false;\n#endif\n}\n\nstatic void\nconvert_line(char *line, replacements *repls)\n{\n\treplace_string(line, \"@cgroup_mnt_point@\", repls->cgroup_mnt_point);\n\treplace_string(line, \"@abs_srcdir@\", repls->abs_srcdir);\n\treplace_string(line, \"@abs_builddir@\", repls->abs_builddir);\n\treplace_string(line, \"@testtablespace@\", repls->testtablespace);\n\treplace_string(line, \"@libdir@\", repls->dlpath);\n\treplace_string(line, \"@DLSUFFIX@\", repls->dlsuffix);\n\treplace_string(line, \"@bindir@\", repls->bindir);\n\treplace_string(line, \"@hostname@\", repls->content_zero_hostname);\n\treplace_string(line, \"@curusername@\", (char *) repls->username);\n\tif (repls->orientation)\n\t{\n\t\treplace_string(line, \"@orientation@\", repls->orientation);\n\t\tif (strcmp(repls->orientation, \"row\") == 0)\n\t\t\treplace_string(line, \"@aoseg@\", \"aoseg\");\n\t\telse\n\t\t\treplace_string(line, \"@aoseg@\", \"aocsseg\");\n\t}\n}\n\n/*\n * Generate two files for each UAO test case, one for row and the\n * other for column orientation.\n */\nstatic int\ngenerate_uao_sourcefiles(char *src_dir, char *dest_dir, char *suffix, replacements *repls)\n{\n\tstruct stat st;\n\tint\t\t\tret;\n\tchar\t  **name;\n\tchar\t  **names;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * Return silently if src_dir or dest_dir is not a directory, in\n\t * the same spirit as in convert_sourcefiles_in().\n\t */\n\tret = stat(src_dir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tret = stat(dest_dir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tnames = pgfnames(src_dir);\n\tif (!names)\n\t\t/* Error logged in pgfnames */\n\t\texit_nicely(2);\n\n\t/* finally loop on each file and generate the files */\n\tfor (name = names; *name; name++)\n\t{\n\t\tchar\t\tsrcfile[MAXPGPATH];\n\t\tchar\t\tdestfile_row[MAXPGPATH];\n\t\tchar\t\tdestfile_col[MAXPGPATH];\n\t\tchar\t\tprefix[MAXPGPATH];\n\t\tFILE\t   *infile,\n\t\t\t\t   *outfile_row,\n\t\t\t\t   *outfile_col;\n\t\tchar\t\tline[1024];\n\t\tchar\t\tline_row[1024];\n\t\tbool\t\thas_tokens = false;\n\n\t\t/* reject filenames not finishing in \".source\" */\n\t\tif (strlen(*name) < 8)\n\t\t\tcontinue;\n\t\tif (strcmp(*name + strlen(*name) - 7, \".source\") != 0)\n\t\t\tcontinue;\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Build the full actual paths to open.  Optimizer specific\n\t\t * answer filenames must end with \"optimizer\".\n\t\t */\n\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", src_dir, *name);\n\t\tif (strlen(*name) > 17 &&\n\t\t\tstrcmp(*name + strlen(*name) - 17, \"_optimizer.source\") == 0)\n\t\t{\n\t\t\tsnprintf(prefix, strlen(*name) - 16, \"%s\", *name);\n\t\t\tsnprintf(destfile_row, MAXPGPATH, \"%s/%s_row_optimizer.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t\tsnprintf(destfile_col, MAXPGPATH, \"%s/%s_column_optimizer.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(prefix, strlen(*name) - 6, \"%s\", *name);\n\t\t\tsnprintf(destfile_row, MAXPGPATH, \"%s/%s_row.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t\tsnprintf(destfile_col, MAXPGPATH, \"%s/%s_column.%s\",\n\t\t\t\t\t dest_dir, prefix, suffix);\n\t\t}\n\n\t\tinfile = fopen(srcfile, \"r\");\n\t\tif (!infile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\t\tprogname, srcfile, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\toutfile_row = fopen(destfile_row, \"w\");\n\t\tif (!outfile_row)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile_row, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\t\toutfile_col = fopen(destfile_col, \"w\");\n\t\tif (!outfile_col)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile_col, strerror(errno));\n\t\t\texit_nicely(2);\n\t\t}\n\n\t\twhile (fgets(line, sizeof(line), infile))\n\t\t{\n\t\t\tstrlcpy(line_row, line, sizeof(line_row));\n\t\t\trepls->orientation = \"row\";\n\t\t\tconvert_line(line_row, repls);\n\t\t\trepls->orientation = \"column\";\n\t\t\tconvert_line(line, repls);\n\t\t\tfputs(line, outfile_col);\n\t\t\tfputs(line_row, outfile_row);\n\t\t\t/*\n\t\t\t * Remember if there are any more tokens that we didn't recognize.\n\t\t\t * They need to be handled by the gpstringsubs.pl script\n\t\t\t */\n\t\t\tif (!has_tokens && strstr(line, \"@gp\") != NULL)\n\t\t\t\thas_tokens = true;\n\t\t}\n\n\t\tfclose(infile);\n\t\tfclose(outfile_row);\n\t\tfclose(outfile_col);\n\n\t\tif (has_tokens)\n\t\t{\n\t\t\tchar\t\tcmd[MAXPGPATH * 3];\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t \"%s %s\", gpstringsubsprog, destfile_row);\n\t\t\tif (run_diff(cmd, destfile_row) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile_row);\n\t\t\t}\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t \"%s %s\", gpstringsubsprog, destfile_col);\n\t\t\tif (run_diff(cmd, destfile_col) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile_col);\n\t\t\t}\n\t\t}\n\t}\n\n\tpgfnames_cleanup(names);\n\treturn count;\n}\n\n/*\n * Convert *.source found in the \"source\" directory, replacing certain tokens\n * in the file contents with their intended values, and put the resulting files\n * in the \"dest\" directory, replacing the \".source\" prefix in their names with\n * the given suffix.\n */\nstatic int\nconvert_sourcefiles_in(char *source_subdir, char *dest_dir, char *dest_subdir, char *suffix)\n{\n\tchar\t\ttesttablespace[MAXPGPATH];\n\tchar\t\tindir[MAXPGPATH];\n\tchar\t\tcgroup_mnt_point[MAXPGPATH];\n\treplacements repls;\n\tstruct stat st;\n\tint\t\t\tret;\n\tchar\t  **name;\n\tchar\t  **names;\n\tint\t\t\tcount = 0;\n\tchar *errstr;\n\n\tsnprintf(indir, MAXPGPATH, \"%s/%s\", inputdir, source_subdir);\n\n\t/* Check that indir actually exists and is a directory */\n\tret = stat(indir, &st);\n\tif (ret != 0 || !S_ISDIR(st.st_mode))\n\t{\n\t\t/*\n\t\t * No warning, to avoid noise in tests that do not have these\n\t\t * directories; for example, ecpg, contrib and src/pl.\n\t\t */\n\t\treturn count;\n\t}\n\n\tnames = pgfnames(indir);\n\tif (!names)\n\t\t/* Error logged in pgfnames */\n\t\texit(2);\n\n\t/* also create the output directory if not present */\n\tif (!directory_exists(dest_subdir))\n\t\tmake_directory(dest_subdir);\n\n\tsnprintf(testtablespace, MAXPGPATH, \"%s/testtablespace\", outputdir);\n\n#ifdef WIN32\n\n\t/*\n\t * On Windows only, clean out the test tablespace dir, or create it if it\n\t * doesn't exist.  On other platforms we expect the Makefile to take care\n\t * of that.  (We don't migrate that functionality in here because it'd be\n\t * harder to cope with platform-specific issues such as SELinux.)\n\t *\n\t * XXX it would be better if pg_regress.c had nothing at all to do with\n\t * testtablespace, and this were handled by a .BAT file or similar on\n\t * Windows.  See pgsql-hackers discussion of 2008-01-18.\n\t */\n\tif (directory_exists(testtablespace))\n\t\tif (!rmtree(testtablespace, true))\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not remove test tablespace \\\"%s\\\"\\n\"),\n\t\t\t\t\tprogname, testtablespace);\n\t\t\texit(2);\n\t\t}\n\tmake_directory(testtablespace);\n#endif\n\n\tmemset(cgroup_mnt_point, 0, sizeof(cgroup_mnt_point));\n\tif (!detectCgroupMountPoint(cgroup_mnt_point,\n\t\t\t\t\t\t\t\tsizeof(cgroup_mnt_point) - 1))\n\t\tstrcpy(cgroup_mnt_point, \"/sys/fs/cgroup\");\n\n\tmemset(&repls, 0, sizeof(repls));\n\trepls.abs_srcdir = inputdir;\n\trepls.abs_builddir = outputdir;\n\trepls.testtablespace = testtablespace;\n\trepls.dlpath = dlpath;\n\trepls.dlsuffix = DLSUFFIX;\n\trepls.bindir = bindir;\n\trepls.cgroup_mnt_point = cgroup_mnt_point;\n\trepls.content_zero_hostname = content_zero_hostname;\n\trepls.username = get_user_name(&errstr);\n\n\tif (repls.username == NULL)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, errstr);\n\t\texit_nicely(2);\n\t}\n\n\t/* finally loop on each file and do the replacement */\n\tfor (name = names; *name; name++)\n\t{\n\t\tchar\t\tsrcfile[MAXPGPATH];\n\t\tchar\t\tdestfile[MAXPGPATH];\n\t\tchar\t\tprefix[MAXPGPATH];\n\t\tFILE\t   *infile,\n\t\t\t\t   *outfile;\n\t\tchar\t\tline[1024];\n\t\tbool\t\thas_tokens = false;\n\t\tstruct stat fst;\n\n\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\",  indir, *name);\n\t\tif (stat(srcfile, &fst) < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: stat failed for \\\"%s\\\"\\n\"),\n\t\t\t\t\tprogname, srcfile);\n\t\t\texit(2);\n\t\t}\n\n\t\t/* recurse if it's a directory */\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t{\n\t\t\tchar generate_uao_file[MAXPGPATH];\n\t\t\tsnprintf(generate_uao_file, MAXPGPATH, \"%s/%s\",  srcfile, \"GENERATE_ROW_AND_COLUMN_FILES\");\n\n\t\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", source_subdir, *name);\n\t\t\tsnprintf(destfile, MAXPGPATH, \"%s/%s\", dest_subdir, *name);\n\n\t\t\tif (access(generate_uao_file, F_OK) != -1)\n\t\t\t\tcount += generate_uao_sourcefiles(srcfile, destfile, suffix, &repls);\n\t\t\telse\n\t\t\t\tcount += convert_sourcefiles_in(srcfile, dest_dir, destfile, suffix);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* reject filenames not finishing in \".source\" */\n\t\tif (strlen(*name) < 8)\n\t\t\tcontinue;\n\t\tif (strcmp(*name + strlen(*name) - 7, \".source\") != 0)\n\t\t\tcontinue;\n\n\t\tcount++;\n\n\t\t/* build the full actual paths to open */\n\t\tsnprintf(prefix, strlen(*name) - 6, \"%s\", *name);\n\t\tsnprintf(srcfile, MAXPGPATH, \"%s/%s\", indir, *name);\n\t\tsnprintf(destfile, MAXPGPATH, \"%s/%s/%s.%s\", dest_dir, dest_subdir,\n\t\t\t\t prefix, suffix);\n\n\t\tinfile = fopen(srcfile, \"r\");\n\t\tif (!infile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\t\tprogname, srcfile, strerror(errno));\n\t\t\texit(2);\n\t\t}\n\t\toutfile = fopen(destfile, \"w\");\n\t\tif (!outfile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\tprogname, destfile, strerror(errno));\n\t\t\texit(2);\n\t\t}\n\t\twhile (fgets(line, sizeof(line), infile))\n\t\t{\n\t\t\tconvert_line(line, &repls);\n\t\t\tfputs(line, outfile);\n\n\t\t\t/*\n\t\t\t * Remember if there are any more tokens that we didn't recognize.\n\t\t\t * They need to be handled by the gpstringsubs.pl script\n\t\t\t */\n\t\t\tif (!has_tokens && strstr(line, \"@gp\") != NULL)\n\t\t\t\thas_tokens = true;\n\t\t}\n\t\tfclose(infile);\n\t\tfclose(outfile);\n\n\t\tif (has_tokens)\n\t\t{\n\t\t\tchar\t\tcmd[MAXPGPATH * 3];\n\t\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t\t \"%s %s\", gpstringsubsprog, destfile);\n\t\t\tif (run_diff(cmd, destfile) != 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not convert %s\\n\"),\n\t\t\t\t\t\tprogname, destfile);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * If we didn't process any files, complain because it probably means\n\t * somebody neglected to pass the needed --inputdir argument.\n\t */\n\tif (count <= 0)\n\t{\n\t\tfprintf(stderr, _(\"%s: no *.source files found in \\\"%s\\\"\\n\"),\n\t\t\t\tprogname, indir);\n\t\texit(2);\n\t}\n\n\tpgfnames_cleanup(names);\n\n\treturn count;\n}\n\n/* Create the .sql, .out and .yml files from the .source files, if any */\nstatic void\nconvert_sourcefiles(void)\n{\n\tcontent_zero_hostname = get_host_name(0, 'p');\n\n\tconvert_sourcefiles_in(\"input\", outputdir, \"sql\", \"sql\");\n\tconvert_sourcefiles_in(\"output\", outputdir, \"expected\", \"out\");\n\n\tconvert_sourcefiles_in(\"yml_in\", inputdir, \"yml\", \"yml\");\n}\n\n/*\n * Scan resultmap file to find which platform-specific expected files to use.\n *\n * The format of each line of the file is\n *\t\t   testname/hostplatformpattern=substitutefile\n * where the hostplatformpattern is evaluated per the rules of expr(1),\n * namely, it is a standard regular expression with an implicit ^ at the start.\n * (We currently support only a very limited subset of regular expressions,\n * see string_matches_pattern() above.)  What hostplatformpattern will be\n * matched against is the config.guess output.  (In the shell-script version,\n * we also provided an indication of whether gcc or another compiler was in\n * use, but that facility isn't used anymore.)\n */\nstatic void\nload_resultmap(void)\n{\n\tchar\t\tbuf[MAXPGPATH];\n\tFILE\t   *f;\n\n\t/* scan the file ... */\n\tsnprintf(buf, sizeof(buf), \"%s/resultmap\", inputdir);\n\tf = fopen(buf, \"r\");\n\tif (!f)\n\t{\n\t\t/* OK if it doesn't exist, else complain */\n\t\tif (errno == ENOENT)\n\t\t\treturn;\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, buf, strerror(errno));\n\t\texit(2);\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f))\n\t{\n\t\tchar\t   *platform;\n\t\tchar\t   *file_type;\n\t\tchar\t   *expected;\n\t\tint\t\t\ti;\n\n\t\t/* strip trailing whitespace, especially the newline */\n\t\ti = strlen(buf);\n\t\twhile (i > 0 && isspace((unsigned char) buf[i - 1]))\n\t\t\tbuf[--i] = '\\0';\n\n\t\t/* parse out the line fields */\n\t\tfile_type = strchr(buf, ':');\n\t\tif (!file_type)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit(2);\n\t\t}\n\t\t*file_type++ = '\\0';\n\n\t\tplatform = strchr(file_type, ':');\n\t\tif (!platform)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit(2);\n\t\t}\n\t\t*platform++ = '\\0';\n\t\texpected = strchr(platform, '=');\n\t\tif (!expected)\n\t\t{\n\t\t\tfprintf(stderr, _(\"incorrectly formatted resultmap entry: %s\\n\"),\n\t\t\t\t\tbuf);\n\t\t\texit(2);\n\t\t}\n\t\t*expected++ = '\\0';\n\n\t\t/*\n\t\t * if it's for current platform, save it in resultmap list. Note: by\n\t\t * adding at the front of the list, we ensure that in ambiguous cases,\n\t\t * the last match in the resultmap file is used. This mimics the\n\t\t * behavior of the old shell script.\n\t\t */\n\t\tif (string_matches_pattern(host_platform, platform))\n\t\t{\n\t\t\t_resultmap *entry = malloc(sizeof(_resultmap));\n\n\t\t\tentry->test = strdup(buf);\n\t\t\tentry->type = strdup(file_type);\n\t\t\tentry->resultfile = strdup(expected);\n\t\t\tentry->next = resultmap;\n\t\t\tresultmap = entry;\n\t\t}\n\t}\n\tfclose(f);\n}\n\n/*\n * Check in resultmap if we should be looking at a different file\n */\nstatic\nconst char *\nget_expectfile(const char *testname, const char *file, const char *default_expectfile)\n{\n\tchar\t\texpectpath[MAXPGPATH];\n\tchar\t   *file_type;\n\tchar\t   *file_name;\n\tchar\t\tbase_file[MAXPGPATH];\n\t_resultmap *rm;\n\tchar\t\tbuf[MAXPGPATH];\n\n\t/*\n\t * Determine the file type from the file name. This is just what is\n\t * following the last dot in the file name.\n\t */\n\tif (!file || !(file_type = strrchr(file, '.')))\n\t\treturn NULL;\n\n\tfile_type++;\n\n\t/*\n\t * Also determine the base file name from the result full path.\n\t */\n\tif (!(file_name = strrchr(file, '/')))\n\t\treturn NULL;\n\n\tfile_name ++;\n\n\tif (file_type < file_name)\n\t\treturn NULL;\n\tstrlcpy(base_file, file_name, (file_type) - file_name);\n\n\t/*\n\t * Find the directory the default expected file is in. That is, everything\n\t * up to the last slash.\n\t */\n\t{\n\t\tchar\t   *p = strrchr(default_expectfile, '/');\n\n\t\tif (!p)\n\t\t\treturn NULL;\n\n\t\tstrlcpy(expectpath, default_expectfile, p - default_expectfile + 1);\n\t}\n\n\tfor (rm = resultmap; rm != NULL; rm = rm->next)\n\t{\n\t\tif (strcmp(testname, rm->test) == 0 && strcmp(file_type, rm->type) == 0)\n\t\t{\n\t\t\tsnprintf(buf, sizeof(buf), \"%s/%s\", expectpath, rm->resultfile);\n\t\t\treturn strdup(buf);\n\t\t}\n\t}\n\n\t/* Use ORCA or resgroup expected outputs, if available */\n\tif  (optimizer_enabled && resgroup_enabled)\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"%s/%s_optimizer_resgroup.%s\", expectpath, base_file, file_type);\n\t\tif (file_exists(buf))\n\t\t\treturn strdup(buf);\n\t}\n\tif  (optimizer_enabled)\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"%s/%s_optimizer.%s\", expectpath, base_file, file_type);\n\t\tif (file_exists(buf))\n\t\t\treturn strdup(buf);\n\t}\n\tif  (resgroup_enabled)\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"%s/%s_resgroup.%s\", expectpath, base_file, file_type);\n\t\tif (file_exists(buf))\n\t\t\treturn strdup(buf);\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Handy subroutine for setting an environment variable \"var\" to \"val\"\n */\nstatic void\ndoputenv(const char *var, const char *val)\n{\n\tchar\t   *s;\n\n\ts = psprintf(\"%s=%s\", var, val);\n\tputenv(s);\n}\n\n/*\n * Set the environment variable \"pathname\", prepending \"addval\" to its\n * old value (if any).\n */\nstatic void\nadd_to_path(const char *pathname, char separator, const char *addval)\n{\n\tchar\t   *oldval = getenv(pathname);\n\tchar\t   *newval;\n\n\tif (!oldval || !oldval[0])\n\t{\n\t\t/* no previous value */\n\t\tnewval = psprintf(\"%s=%s\", pathname, addval);\n\t}\n\telse\n\t\tnewval = psprintf(\"%s=%s%c%s\", pathname, addval, separator, oldval);\n\n\tputenv(newval);\n}\n\n/*\n * Prepare environment variables for running regression tests\n */\nstatic void\ninitialize_environment(void)\n{\n\tputenv(\"PGAPPNAME=pg_regress\");\n\n\tif (nolocale)\n\t{\n\t\t/*\n\t\t * Clear out any non-C locale settings\n\t\t */\n\t\tunsetenv(\"LC_COLLATE\");\n\t\tunsetenv(\"LC_CTYPE\");\n\t\tunsetenv(\"LC_MONETARY\");\n\t\tunsetenv(\"LC_NUMERIC\");\n\t\tunsetenv(\"LC_TIME\");\n\t\tunsetenv(\"LANG\");\n\n\t\t/*\n\t\t * Most platforms have adopted the POSIX locale as their\n\t\t * implementation-defined default locale.  Exceptions include native\n\t\t * Windows, Darwin with --enable-nls, and Cygwin with --enable-nls.\n\t\t * (Use of --enable-nls matters because libintl replaces setlocale().)\n\t\t * Also, PostgreSQL does not support Darwin with locale environment\n\t\t * variables unset; see PostmasterMain().\n\t\t */\n#if defined(WIN32) || defined(__CYGWIN__) || defined(__darwin__)\n\t\tputenv(\"LANG=C\");\n#endif\n\t}\n\n\t/*\n\t * Set translation-related settings to English; otherwise psql will\n\t * produce translated messages and produce diffs.  (XXX If we ever support\n\t * translation of pg_regress, this needs to be moved elsewhere, where psql\n\t * is actually called.)\n\t */\n\tunsetenv(\"LANGUAGE\");\n\tunsetenv(\"LC_ALL\");\n\tputenv(\"LC_MESSAGES=C\");\n\n\t/*\n\t * Set encoding as requested\n\t */\n\tif (encoding)\n\t\tdoputenv(\"PGCLIENTENCODING\", encoding);\n\telse\n\t\tunsetenv(\"PGCLIENTENCODING\");\n\n\t/*\n\t * Set timezone and datestyle for datetime-related tests\n\t */\n\tputenv(\"PGTZ=PST8PDT\");\n\tputenv(\"PGDATESTYLE=Postgres, MDY\");\n\n\t/*\n\t * Likewise set intervalstyle to ensure consistent results.  This is a bit\n\t * more painful because we must use PGOPTIONS, and we want to preserve the\n\t * user's ability to set other variables through that.\n\t */\n\t{\n\t\tconst char *my_pgoptions = \"-c intervalstyle=postgres_verbose\";\n\t\tconst char *old_pgoptions = getenv(\"PGOPTIONS\");\n\t\tchar\t   *new_pgoptions;\n\n\t\tif (!old_pgoptions)\n\t\t\told_pgoptions = \"\";\n\t\tnew_pgoptions = psprintf(\"PGOPTIONS=%s %s\",\n\t\t\t\t\t\t\t\t old_pgoptions, my_pgoptions);\n\t\tputenv(new_pgoptions);\n\t}\n\n\tif (temp_install)\n\t{\n\t\t/*\n\t\t * Clear out any environment vars that might cause psql to connect to\n\t\t * the wrong postmaster, or otherwise behave in nondefault ways. (Note\n\t\t * we also use psql's -X switch consistently, so that ~/.psqlrc files\n\t\t * won't mess things up.)  Also, set PGPORT to the temp port, and set\n\t\t * PGHOST depending on whether we are using TCP or Unix sockets.\n\t\t */\n\t\tunsetenv(\"PGDATABASE\");\n\t\tunsetenv(\"PGUSER\");\n\t\tunsetenv(\"PGSERVICE\");\n\t\tunsetenv(\"PGSSLMODE\");\n\t\tunsetenv(\"PGREQUIRESSL\");\n\t\tunsetenv(\"PGCONNECT_TIMEOUT\");\n\t\tunsetenv(\"PGDATA\");\n#ifdef HAVE_UNIX_SOCKETS\n\t\tif (hostname != NULL)\n\t\t\tdoputenv(\"PGHOST\", hostname);\n\t\telse\n\t\t{\n\t\t\tsockdir = getenv(\"PG_REGRESS_SOCK_DIR\");\n\t\t\tif (!sockdir)\n\t\t\t\tsockdir = make_temp_sockdir();\n\t\t\tdoputenv(\"PGHOST\", sockdir);\n\t\t}\n#else\n\t\tAssert(hostname != NULL);\n\t\tdoputenv(\"PGHOST\", hostname);\n#endif\n\t\tunsetenv(\"PGHOSTADDR\");\n\t\tif (port != -1)\n\t\t{\n\t\t\tchar\t\ts[16];\n\n\t\t\tsprintf(s, \"%d\", port);\n\t\t\tdoputenv(\"PGPORT\", s);\n\t\t}\n\n\t\t/*\n\t\t * GNU make stores some flags in the MAKEFLAGS environment variable to\n\t\t * pass arguments to its own children.  If we are invoked by make,\n\t\t * that causes the make invoked by us to think its part of the make\n\t\t * task invoking us, and so it tries to communicate with the toplevel\n\t\t * make.  Which fails.\n\t\t *\n\t\t * Unset the variable to protect against such problems.  We also reset\n\t\t * MAKELEVEL to be certain the child doesn't notice the make above us.\n\t\t */\n\t\tunsetenv(\"MAKEFLAGS\");\n\t\tunsetenv(\"MAKELEVEL\");\n\n\t\t/*\n\t\t * Adjust path variables to point into the temp-install tree\n\t\t */\n\t\tbindir = psprintf(\"%s/install/%s\", temp_install, bindir);\n\n\t\tlibdir = psprintf(\"%s/install/%s\", temp_install, libdir);\n\n\t\tdatadir = psprintf(\"%s/install/%s\", temp_install, datadir);\n\n\t\t/* psql will be installed into temp-install bindir */\n\t\tpsqldir = bindir;\n\n\t\t/*\n\t\t * Set up shared library paths to include the temp install.\n\t\t *\n\t\t * LD_LIBRARY_PATH covers many platforms.  DYLD_LIBRARY_PATH works on\n\t\t * Darwin, and maybe other Mach-based systems.  LIBPATH is for AIX.\n\t\t * Windows needs shared libraries in PATH (only those linked into\n\t\t * executables, not dlopen'ed ones). Feel free to account for others\n\t\t * as well.\n\t\t */\n\t\tadd_to_path(\"LD_LIBRARY_PATH\", ':', libdir);\n\t\tadd_to_path(\"DYLD_LIBRARY_PATH\", ':', libdir);\n\t\tadd_to_path(\"LIBPATH\", ':', libdir);\n#if defined(WIN32)\n\t\tadd_to_path(\"PATH\", ';', libdir);\n#elif defined(__CYGWIN__)\n\t\tadd_to_path(\"PATH\", ':', libdir);\n#endif\n\t}\n\telse\n\t{\n\t\tconst char *pghost;\n\t\tconst char *pgport;\n\n\t\t/*\n\t\t * When testing an existing install, we honor existing environment\n\t\t * variables, except if they're overridden by command line options.\n\t\t */\n\t\tif (hostname != NULL)\n\t\t{\n\t\t\tdoputenv(\"PGHOST\", hostname);\n\t\t\tunsetenv(\"PGHOSTADDR\");\n\t\t}\n\t\tif (port != -1)\n\t\t{\n\t\t\tchar\t\ts[16];\n\n\t\t\tsprintf(s, \"%d\", port);\n\t\t\tdoputenv(\"PGPORT\", s);\n\t\t}\n\t\tif (user != NULL)\n\t\t\tdoputenv(\"PGUSER\", user);\n\n\t\t/*\n\t\t * Report what we're connecting to\n\t\t */\n\t\tpghost = getenv(\"PGHOST\");\n\t\tpgport = getenv(\"PGPORT\");\n#ifndef HAVE_UNIX_SOCKETS\n\t\tif (!pghost)\n\t\t\tpghost = \"localhost\";\n#endif\n\n\t\tif (pghost && pgport)\n\t\t\tprintf(_(\"(using postmaster on %s, port %s)\\n\"), pghost, pgport);\n\t\tif (pghost && !pgport)\n\t\t\tprintf(_(\"(using postmaster on %s, default port)\\n\"), pghost);\n\t\tif (!pghost && pgport)\n\t\t\tprintf(_(\"(using postmaster on Unix socket, port %s)\\n\"), pgport);\n\t\tif (!pghost && !pgport)\n\t\t\tprintf(_(\"(using postmaster on Unix socket, default port)\\n\"));\n\t}\n\n\tconvert_sourcefiles();\n\tload_resultmap();\n}\n\n#ifdef ENABLE_SSPI\n/*\n * Get account and domain/realm names for the current user.  This is based on\n * pg_SSPI_recvauth().  The returned strings use static storage.\n */\nstatic void\ncurrent_windows_user(const char **acct, const char **dom)\n{\n\tstatic char accountname[MAXPGPATH];\n\tstatic char domainname[MAXPGPATH];\n\tHANDLE\t\ttoken;\n\tTOKEN_USER *tokenuser;\n\tDWORD\t\tretlen;\n\tDWORD\t\taccountnamesize = sizeof(accountname);\n\tDWORD\t\tdomainnamesize = sizeof(domainname);\n\tSID_NAME_USE accountnameuse;\n\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &token))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not open process token: error code %lu\\n\"),\n\t\t\t\tprogname, GetLastError());\n\t\texit(2);\n\t}\n\n\tif (!GetTokenInformation(token, TokenUser, NULL, 0, &retlen) && GetLastError() != 122)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not get token user size: error code %lu\\n\"),\n\t\t\t\tprogname, GetLastError());\n\t\texit(2);\n\t}\n\ttokenuser = malloc(retlen);\n\tif (!GetTokenInformation(token, TokenUser, tokenuser, retlen, &retlen))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not get token user: error code %lu\\n\"),\n\t\t\t\tprogname, GetLastError());\n\t\texit(2);\n\t}\n\n\tif (!LookupAccountSid(NULL, tokenuser->User.Sid, accountname, &accountnamesize,\n\t\t\t\t\t\t  domainname, &domainnamesize, &accountnameuse))\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: could not look up account SID: error code %lu\\n\"),\n\t\t\t\tprogname, GetLastError());\n\t\texit(2);\n\t}\n\n\tfree(tokenuser);\n\n\t*acct = accountname;\n\t*dom = domainname;\n}\n\n/*\n * Rewrite pg_hba.conf and pg_ident.conf to use SSPI authentication.  Permit\n * the current OS user to authenticate as the bootstrap superuser and as any\n * user named in a --create-role option.\n */\nstatic void\nconfig_sspi_auth(const char *pgdata)\n{\n\tconst char *accountname,\n\t\t\t   *domainname;\n\tconst char *username;\n\tchar\t   *errstr;\n\tbool\t\thave_ipv6;\n\tchar\t\tfname[MAXPGPATH];\n\tint\t\t\tres;\n\tFILE\t   *hba,\n\t\t\t   *ident;\n\t_stringlist *sl;\n\n\t/*\n\t * \"username\", the initdb-chosen bootstrap superuser name, may always\n\t * match \"accountname\", the value SSPI authentication discovers.  The\n\t * underlying system functions do not clearly guarantee that.\n\t */\n\tcurrent_windows_user(&accountname, &domainname);\n\tusername = get_user_name(&errstr);\n\tif (username == NULL)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, errstr);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Like initdb.c:setup_config(), determine whether the platform recognizes\n\t * ::1 (IPv6 loopback) as a numeric host address string.\n\t */\n\t{\n\t\tstruct addrinfo *gai_result;\n\t\tstruct addrinfo hints;\n\t\tWSADATA\t\twsaData;\n\n\t\thints.ai_flags = AI_NUMERICHOST;\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = 0;\n\t\thints.ai_protocol = 0;\n\t\thints.ai_addrlen = 0;\n\t\thints.ai_canonname = NULL;\n\t\thints.ai_addr = NULL;\n\t\thints.ai_next = NULL;\n\n\t\thave_ipv6 = (WSAStartup(MAKEWORD(2, 2), &wsaData) == 0 &&\n\t\t\t\t\t getaddrinfo(\"::1\", NULL, &hints, &gai_result) == 0);\n\t}\n\n\t/* Check a Write outcome and report any error. */\n#define CW(cond)\t\\\n\tdo { \\\n\t\tif (!(cond)) \\\n\t\t{ \\\n\t\t\tfprintf(stderr, _(\"%s: could not write to file \\\"%s\\\": %s\\n\"), \\\n\t\t\t\t\tprogname, fname, strerror(errno)); \\\n\t\t\texit(2); \\\n\t\t} \\\n\t} while (0)\n\n\tres = snprintf(fname, sizeof(fname), \"%s/pg_hba.conf\", pgdata);\n\tif (res < 0 || res >= sizeof(fname))\n\t{\n\t\t/*\n\t\t * Truncating this name is a fatal error, because we must not fail to\n\t\t * overwrite an original trust-authentication pg_hba.conf.\n\t\t */\n\t\tfprintf(stderr, _(\"%s: directory name too long\\n\"), progname);\n\t\texit(2);\n\t}\n\thba = fopen(fname, \"w\");\n\tif (hba == NULL)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, fname, strerror(errno));\n\t\texit(2);\n\t}\n\tCW(fputs(\"# Configuration written by config_sspi_auth()\\n\", hba) >= 0);\n\tCW(fputs(\"host all all 127.0.0.1/32  sspi include_realm=1 map=regress\\n\",\n\t\t\t hba) >= 0);\n\tif (have_ipv6)\n\t\tCW(fputs(\"host all all ::1/128  sspi include_realm=1 map=regress\\n\",\n\t\t\t\t hba) >= 0);\n\tCW(fclose(hba) == 0);\n\n\tsnprintf(fname, sizeof(fname), \"%s/pg_ident.conf\", pgdata);\n\tident = fopen(fname, \"w\");\n\tif (ident == NULL)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, fname, strerror(errno));\n\t\texit(2);\n\t}\n\tCW(fputs(\"# Configuration written by config_sspi_auth()\\n\", ident) >= 0);\n\n\t/*\n\t * Double-quote for the benefit of account names containing whitespace or\n\t * '#'.  Windows forbids the double-quote character itself, so don't\n\t * bother escaping embedded double-quote characters.\n\t */\n\tCW(fprintf(ident, \"regress  \\\"%s@%s\\\"  \\\"%s\\\"\\n\",\n\t\t\t   accountname, domainname, username) >= 0);\n\tfor (sl = extraroles; sl; sl = sl->next)\n\t\tCW(fprintf(ident, \"regress  \\\"%s@%s\\\"  \\\"%s\\\"\\n\",\n\t\t\t\t   accountname, domainname, sl->str) >= 0);\n\tCW(fclose(ident) == 0);\n}\n#endif\n\n/*\n * Issue a command via psql, connecting to the specified database\n *\n * Since we use system(), this doesn't return until the operation finishes\n */\nstatic void\npsql_command(const char *database, const char *query,...)\n{\n\tchar\t\tquery_formatted[1024];\n\tchar\t\tquery_escaped[2048];\n\tchar\t\tpsql_cmd[MAXPGPATH + 2048];\n\tva_list\t\targs;\n\tchar\t   *s;\n\tchar\t   *d;\n\n\t/* Generate the query with insertion of sprintf arguments */\n\tva_start(args, query);\n\tvsnprintf(query_formatted, sizeof(query_formatted), query, args);\n\tva_end(args);\n\n\t/* Now escape any shell double-quote metacharacters */\n\td = query_escaped;\n\tfor (s = query_formatted; *s; s++)\n\t{\n\t\tif (strchr(\"\\\\\\\"$`\", *s))\n\t\t\t*d++ = '\\\\';\n\t\t*d++ = *s;\n\t}\n\t*d = '\\0';\n\n\t/* And now we can build and execute the shell command */\n\tsnprintf(psql_cmd, sizeof(psql_cmd),\n\t\t\t \"\\\"%s%spsql\\\" -X -c \\\"%s\\\" \\\"%s\\\"\",\n\t\t\t psqldir ? psqldir : \"\",\n\t\t\t psqldir ? \"/\" : \"\",\n\t\t\t query_escaped,\n\t\t\t database);\n\n\tif (system(psql_cmd) != 0)\n\t{\n\t\t/* psql probably already reported the error */\n\t\tfprintf(stderr, _(\"command failed: %s\\n\"), psql_cmd);\n\t\texit(2);\n\t}\n}\n\n/*\n * Spawn a process to execute the given shell command; don't wait for it\n *\n * Returns the process ID (or HANDLE) so we can wait for it later\n */\nPID_TYPE\nspawn_process(const char *cmdline)\n{\n#ifndef WIN32\n\tpid_t\t\tpid;\n\n\t/*\n\t * Must flush I/O buffers before fork.  Ideally we'd use fflush(NULL) here\n\t * ... does anyone still care about systems where that doesn't work?\n\t */\n\tfflush(stdout);\n\tfflush(stderr);\n\tif (logfile)\n\t\tfflush(logfile);\n\n\tpid = fork();\n\tif (pid == -1)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not fork: %s\\n\"),\n\t\t\t\tprogname, strerror(errno));\n\t\texit(2);\n\t}\n\tif (pid == 0)\n\t{\n\t\t/*\n\t\t * In child\n\t\t *\n\t\t * Instead of using system(), exec the shell directly, and tell it to\n\t\t * \"exec\" the command too.  This saves two useless processes per\n\t\t * parallel test case.\n\t\t */\n\t\tchar\t   *cmdline2;\n\n\t\tcmdline2 = psprintf(\"exec %s\", cmdline);\n\t\texecl(shellprog, shellprog, \"-c\", cmdline2, (char *) NULL);\n\t\tfprintf(stderr, _(\"%s: could not exec \\\"%s\\\": %s\\n\"),\n\t\t\t\tprogname, shellprog, strerror(errno));\n\t\t_exit(1);\t\t\t\t/* not exit() here... */\n\t}\n\t/* in parent */\n\treturn pid;\n#else\n\tchar\t   *cmdline2;\n\tBOOL\t\tb;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tHANDLE\t\torigToken;\n\tHANDLE\t\trestrictedToken;\n\tSID_IDENTIFIER_AUTHORITY NtAuthority = {SECURITY_NT_AUTHORITY};\n\tSID_AND_ATTRIBUTES dropSids[2];\n\t__CreateRestrictedToken _CreateRestrictedToken = NULL;\n\tHANDLE\t\tAdvapi32Handle;\n\n\tZeroMemory(&si, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tAdvapi32Handle = LoadLibrary(\"ADVAPI32.DLL\");\n\tif (Advapi32Handle != NULL)\n\t{\n\t\t_CreateRestrictedToken = (__CreateRestrictedToken) GetProcAddress(Advapi32Handle, \"CreateRestrictedToken\");\n\t}\n\n\tif (_CreateRestrictedToken == NULL)\n\t{\n\t\tif (Advapi32Handle != NULL)\n\t\t\tFreeLibrary(Advapi32Handle);\n\t\tfprintf(stderr, _(\"%s: cannot create restricted tokens on this platform\\n\"),\n\t\t\t\tprogname);\n\t\texit(2);\n\t}\n\n\t/* Open the current token to use as base for the restricted one */\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &origToken))\n\t{\n\t\tfprintf(stderr, _(\"could not open process token: error code %lu\\n\"),\n\t\t\t\tGetLastError());\n\t\texit(2);\n\t}\n\n\t/* Allocate list of SIDs to remove */\n\tZeroMemory(&dropSids, sizeof(dropSids));\n\tif (!AllocateAndInitializeSid(&NtAuthority, 2,\n\t\t\t\t\t\t\t\t  SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &dropSids[0].Sid) ||\n\t\t!AllocateAndInitializeSid(&NtAuthority, 2,\n\t\t\t\t\t\t\t\t  SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &dropSids[1].Sid))\n\t{\n\t\tfprintf(stderr, _(\"could not allocate SIDs: error code %lu\\n\"), GetLastError());\n\t\texit(2);\n\t}\n\n\tb = _CreateRestrictedToken(origToken,\n\t\t\t\t\t\t\t   DISABLE_MAX_PRIVILEGE,\n\t\t\t\t\t\t\t   sizeof(dropSids) / sizeof(dropSids[0]),\n\t\t\t\t\t\t\t   dropSids,\n\t\t\t\t\t\t\t   0, NULL,\n\t\t\t\t\t\t\t   0, NULL,\n\t\t\t\t\t\t\t   &restrictedToken);\n\n\tFreeSid(dropSids[1].Sid);\n\tFreeSid(dropSids[0].Sid);\n\tCloseHandle(origToken);\n\tFreeLibrary(Advapi32Handle);\n\n\tif (!b)\n\t{\n\t\tfprintf(stderr, _(\"could not create restricted token: error code %lu\\n\"),\n\t\t\t\tGetLastError());\n\t\texit(2);\n\t}\n\n\tcmdline2 = psprintf(\"cmd /c \\\"%s\\\"\", cmdline);\n\n#ifndef __CYGWIN__\n\tAddUserToTokenDacl(restrictedToken);\n#endif\n\n\tif (!CreateProcessAsUser(restrictedToken,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t cmdline2,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t TRUE,\n\t\t\t\t\t\t\t CREATE_SUSPENDED,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t &si,\n\t\t\t\t\t\t\t &pi))\n\t{\n\t\tfprintf(stderr, _(\"could not start process for \\\"%s\\\": error code %lu\\n\"),\n\t\t\t\tcmdline2, GetLastError());\n\t\texit(2);\n\t}\n\n\tfree(cmdline2);\n\n\tResumeThread(pi.hThread);\n\tCloseHandle(pi.hThread);\n\treturn pi.hProcess;\n#endif\n}\n\n/*\n * Count bytes in file\n */\nstatic long\nfile_size(const char *file)\n{\n\tlong\t\tr;\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, file, strerror(errno));\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tr = ftell(f);\n\tfclose(f);\n\treturn r;\n}\n\n/*\n * Count lines in file\n */\nstatic int\nfile_line_count(const char *file)\n{\n\tint\t\t\tc;\n\tint\t\t\tl = 0;\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, file, strerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((c = fgetc(f)) != EOF)\n\t{\n\t\tif (c == '\\n')\n\t\t\tl++;\n\t}\n\tfclose(f);\n\treturn l;\n}\n\nstatic FILE *\nopen_file_for_reading(const char *filename) {\n\tFILE *file = fopen(filename, \"r\");\n\n\tif (!file)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, filename, strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn file;\n}\n\nstatic void\nprint_contents_of_file(const char* filename) {\n\tFILE *file;\n\tchar string[1024];\n\n\tfile = open_file_for_reading(filename);\n\twhile (fgets(string, sizeof(string), file))\n\t\tfprintf(stdout, \"%s\", string);\n\n\tfclose(file);\n}\n\nbool\nfile_exists(const char *file)\n{\n\tFILE\t   *f = fopen(file, \"r\");\n\n\tif (!f)\n\t\treturn false;\n\tfclose(f);\n\treturn true;\n}\n\nstatic bool\ndirectory_exists(const char *dir)\n{\n\tstruct stat st;\n\n\tif (stat(dir, &st) != 0)\n\t\treturn false;\n\tif (S_ISDIR(st.st_mode))\n\t\treturn true;\n\treturn false;\n}\n\n/* Create a directory */\nstatic void\nmake_directory(const char *dir)\n{\n\tif (mkdir(dir, S_IRWXU | S_IRWXG | S_IRWXO) < 0)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not create directory \\\"%s\\\": %s\\n\"),\n\t\t\t\tprogname, dir, strerror(errno));\n\t\texit(2);\n\t}\n}\n\n/*\n * In: filename.ext, Return: filename_i.ext, where 0 < i <= 9\n */\nstatic char *\nget_alternative_expectfile(const char *expectfile, int i)\n{\n\tchar\t   *last_dot;\n\tint\t\t\tssize = strlen(expectfile) + 2 + 1;\n\tchar\t   *tmp;\n\tchar\t   *s;\n\n\tif (!(tmp = (char *) malloc(ssize)))\n\t\treturn NULL;\n\n\tif (!(s = (char *) malloc(ssize)))\n\t{\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(tmp, expectfile);\n\tlast_dot = strrchr(tmp, '.');\n\tif (!last_dot)\n\t{\n\t\tfree(tmp);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\t*last_dot = '\\0';\n\tsnprintf(s, ssize, \"%s_%d.%s\", tmp, i, last_dot + 1);\n\tfree(tmp);\n\treturn s;\n}\n\n/*\n * Run a \"diff\" command and also check that it didn't crash\n */\nstatic int\nrun_diff(const char *cmd, const char *filename)\n{\n\tint\t\t\tr;\n\n\tr = system(cmd);\n\tif (!WIFEXITED(r) || WEXITSTATUS(r) > 1)\n\t{\n\t\tfprintf(stderr, _(\"diff command failed with status %d: %s\\n\"), r, cmd);\n\t\texit(2);\n\t}\n#ifdef WIN32\n\n\t/*\n\t * On WIN32, if the 'diff' command cannot be found, system() returns 1,\n\t * but produces nothing to stdout, so we check for that here.\n\t */\n\tif (WEXITSTATUS(r) == 1 && file_size(filename) <= 0)\n\t{\n\t\tfprintf(stderr, _(\"diff command not found: %s\\n\"), cmd);\n\t\texit(2);\n\t}\n#else\n\tUnusedArg(filename);\n#endif\n\n\treturn WEXITSTATUS(r);\n}\n\n/*\n * Check the actual result file for the given test against expected results\n *\n * Returns true if different (failure), false if correct match found.\n * In the true case, the diff is appended to the diffs file.\n */\nstatic bool\nresults_differ(const char *testname, const char *resultsfile, const char *default_expectfile)\n{\n\tchar\t\texpectfile[MAXPGPATH];\n\tchar\t\tdiff[MAXPGPATH];\n\tchar\t\tcmd[MAXPGPATH * 3];\n\tchar\t\tbest_expect_file[MAXPGPATH];\n    char        diff_opts[MAXPGPATH];\n    char        m_pretty_diff_opts[MAXPGPATH];\n\tFILE\t   *difffile;\n\tint\t\t\tbest_line_count;\n\tint\t\t\ti;\n\tint\t\t\tl;\n\tconst char *platform_expectfile;\n\tconst char *ignore_plans_opts;\n\n\t/*\n\t * We can pass either the resultsfile or the expectfile, they should have\n\t * the same type (filename.type) anyway.\n\t */\n\tplatform_expectfile = get_expectfile(testname, resultsfile, default_expectfile);\n\n\tif (platform_expectfile)\n\t\tstrlcpy(expectfile, platform_expectfile, sizeof(expectfile));\n\telse\n\t\tstrlcpy(expectfile, default_expectfile, sizeof(expectfile));\n\n\tif (ignore_plans)\n\t\tignore_plans_opts = \" -gpd_ignore_plans\";\n\telse\n\t\tignore_plans_opts = \"\";\n\n\t/* Name to use for temporary diff file */\n\tsnprintf(diff, sizeof(diff), \"%s.diff\", resultsfile);\n    \n\t/* Add init file arguments if provided via commandline */\n\tif (initfile)\n\t{\n\t  snprintf(diff_opts, sizeof(diff_opts),\n\t\t\t   \"%s%s --gpd_init %s\", basic_diff_opts, ignore_plans_opts, initfile);\n\n\t  snprintf(m_pretty_diff_opts, sizeof(m_pretty_diff_opts),\n\t\t\t   \"%s%s --gpd_init %s\", pretty_diff_opts, ignore_plans_opts, initfile);\n\t}\n\telse\n\t{\n\t\tsnprintf(diff_opts, sizeof(diff_opts),\n\t\t\t   \"%s%s\", basic_diff_opts, ignore_plans_opts);\n\n\t\tsnprintf(m_pretty_diff_opts, sizeof(m_pretty_diff_opts),\n\t\t\t\t \"%s%s\", pretty_diff_opts, ignore_plans_opts);\n\t}\n\n\t/* OK, run the diff */\n\tsnprintf(cmd, sizeof(cmd),\n\t\t\t \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\",\n\t\t\t gpdiffprog, diff_opts, expectfile, resultsfile, diff);\n\n\t/* Is the diff file empty? */\n\tif (run_diff(cmd, diff) == 0)\n\t{\n\t\tunlink(diff);\n\t\treturn false;\n\t}\n\n\t/* There may be secondary comparison files that match better */\n\tbest_line_count = file_line_count(diff);\n\tstrcpy(best_expect_file, expectfile);\n\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tchar\t   *alt_expectfile;\n\n\t\talt_expectfile = get_alternative_expectfile(expectfile, i);\n\t\tif (!alt_expectfile)\n\t\t{\n\t\t\tfprintf(stderr, _(\"Unable to check secondary comparison files: %s\\n\"),\n\t\t\t\t\tstrerror(errno));\n\t\t\texit(2);\n\t\t}\n\n\t\tif (!file_exists(alt_expectfile))\n\t\t{\n\t\t\tfree(alt_expectfile);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\",\n\t\t\t\t gpdiffprog, diff_opts, alt_expectfile, resultsfile, diff);\n\n\t\tif (run_diff(cmd, diff) == 0)\n\t\t{\n\t\t\tunlink(diff);\n\t\t\tfree(alt_expectfile);\n\t\t\treturn false;\n\t\t}\n\n\t\tl = file_line_count(diff);\n\t\tif (l < best_line_count)\n\t\t{\n\t\t\t/* This diff was a better match than the last one */\n\t\t\tbest_line_count = l;\n\t\t\tstrlcpy(best_expect_file, alt_expectfile, sizeof(best_expect_file));\n\t\t}\n\t\tfree(alt_expectfile);\n\t}\n\n\t/*\n\t * fall back on the canonical results file if we haven't tried it yet and\n\t * haven't found a complete match yet.\n\t *\n\t * In GPDB, platform_expectfile is used for determining ORCA/planner/resgroup\n\t * expect files, wheras in upstream that is not the case and it is based on\n\t * the underlying platform. Thus, it is unnecessary and confusing to compare\n\t * against default answer file even when platform_expect file exists. It gets\n\t * confusing because the below block chooses the best expect file based on\n\t * the number of lines in diff file.\n\t */\n\n#if 0\n\tif (platform_expectfile)\n\t{\n\t\tsnprintf(cmd, sizeof(cmd),\n\t\t\t\t \"%s %s \\\"%s\\\" \\\"%s\\\" > \\\"%s\\\"\",\n\t\t\t\t gpdiffprog, diff_opts, default_expectfile, resultsfile, diff);\n\n\t\tif (run_diff(cmd, diff) == 0)\n\t\t{\n\t\t\t/* No diff = no changes = good */\n\t\t\tunlink(diff);\n\t\t\treturn false;\n\t\t}\n\n\t\tl = file_line_count(diff);\n\t\tif (l < best_line_count)\n\t\t{\n\t\t\t/* This diff was a better match than the last one */\n\t\t\tbest_line_count = l;\n\t\t\tstrlcpy(best_expect_file, default_expectfile, sizeof(best_expect_file));\n\t\t}\n\t}\n#endif\n\t/*\n\t * Use the best comparison file to generate the \"pretty\" diff, which we\n\t * append to the diffs summary file.\n\t */\n\tsnprintf(cmd, sizeof(cmd),\n\t\t\t \"%s %s \\\"%s\\\" \\\"%s\\\" >> \\\"%s\\\"\",\n\t\t\t gpdiffprog, m_pretty_diff_opts, best_expect_file, resultsfile, difffilename);\n\trun_diff(cmd, difffilename);\n\n\t/* And append a separator */\n\tdifffile = fopen(difffilename, \"a\");\n\tif (difffile)\n\t{\n\t\tfprintf(difffile,\n\t\t\t\t\"\\n======================================================================\\n\\n\");\n\t\tfclose(difffile);\n\t}\n\n\tunlink(diff);\n\treturn true;\n}\n\n/*\n * Wait for specified subprocesses to finish, and return their exit\n * statuses into statuses[]\n *\n * If names isn't NULL, print each subprocess's name as it finishes\n *\n * Note: it's OK to scribble on the pids array, but not on the names array\n */\nstatic void\nwait_for_tests(PID_TYPE *pids, int *statuses, char **names, struct timeval *end_times, int num_tests)\n{\n\tint\t\t\ttests_left;\n\tint\t\t\ti;\n\n#ifdef WIN32\n\tPID_TYPE   *active_pids = malloc(num_tests * sizeof(PID_TYPE));\n\n\tmemcpy(active_pids, pids, num_tests * sizeof(PID_TYPE));\n#endif\n\n\ttests_left = num_tests;\n\twhile (tests_left > 0)\n\t{\n\t\tPID_TYPE\tp;\n\n#ifndef WIN32\n\t\tint\t\t\texit_status;\n\n\t\tp = wait(&exit_status);\n\n\t\tif (p == INVALID_PID)\n\t\t{\n\t\t\tfprintf(stderr, _(\"failed to wait for subprocesses: %s\\n\"),\n\t\t\t\t\tstrerror(errno));\n\t\t\texit(2);\n\t\t}\n#else\n\t\tDWORD\t\texit_status;\n\t\tint\t\t\tr;\n\n\t\tr = WaitForMultipleObjects(tests_left, active_pids, FALSE, INFINITE);\n\t\tif (r < WAIT_OBJECT_0 || r >= WAIT_OBJECT_0 + tests_left)\n\t\t{\n\t\t\tfprintf(stderr, _(\"failed to wait for subprocesses: error code %lu\\n\"),\n\t\t\t\t\tGetLastError());\n\t\t\texit(2);\n\t\t}\n\t\tp = active_pids[r - WAIT_OBJECT_0];\n\t\t/* compact the active_pids array */\n\t\tactive_pids[r - WAIT_OBJECT_0] = active_pids[tests_left - 1];\n#endif   /* WIN32 */\n\n\t\tfor (i = 0; i < num_tests; i++)\n\t\t{\n\t\t\tif (p == pids[i])\n\t\t\t{\n#ifdef WIN32\n\t\t\t\tGetExitCodeProcess(pids[i], &exit_status);\n\t\t\t\tCloseHandle(pids[i]);\n#endif\n\t\t\t\tpids[i] = INVALID_PID;\n\t\t\t\tstatuses[i] = (int) exit_status;\n\t\t\t\tif (names)\n\t\t\t\t\tstatus(\" %s\", names[i]);\n\t\t\t\tif (end_times)\n\t\t\t\t\tgettimeofday(&end_times[i], NULL);\n\t\t\t\ttests_left--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WIN32\n\tfree(active_pids);\n#endif\n}\n\n/*\n * report nonzero exit code from a test process\n */\nstatic void\nlog_child_failure(int exitstatus)\n{\n\tif (WIFEXITED(exitstatus))\n\t\tstatus(_(\" (test process exited with exit code %d)\"),\n\t\t\t   WEXITSTATUS(exitstatus));\n\telse if (WIFSIGNALED(exitstatus))\n\t{\n#if defined(WIN32)\n\t\tstatus(_(\" (test process was terminated by exception 0x%X)\"),\n\t\t\t   WTERMSIG(exitstatus));\n#elif defined(HAVE_DECL_SYS_SIGLIST) && HAVE_DECL_SYS_SIGLIST\n\t\tstatus(_(\" (test process was terminated by signal %d: %s)\"),\n\t\t\t   WTERMSIG(exitstatus),\n\t\t\t   WTERMSIG(exitstatus) < NSIG ?\n\t\t\t   sys_siglist[WTERMSIG(exitstatus)] : \"(unknown))\");\n#else\n\t\tstatus(_(\" (test process was terminated by signal %d)\"),\n\t\t\t   WTERMSIG(exitstatus));\n#endif\n\t}\n\telse\n\t\tstatus(_(\" (test process exited with unrecognized status %d)\"),\n\t\t\t   exitstatus);\n}\n\n/*\n * Run all the tests specified in one schedule file\n */\nstatic void\nrun_schedule(const char *schedule, test_function tfunc)\n{\n#define MAX_PARALLEL_TESTS 100\n\tchar\t   *tests[MAX_PARALLEL_TESTS];\n\t_stringlist *resultfiles[MAX_PARALLEL_TESTS];\n\t_stringlist *expectfiles[MAX_PARALLEL_TESTS];\n\t_stringlist *tags[MAX_PARALLEL_TESTS];\n\tPID_TYPE\tpids[MAX_PARALLEL_TESTS];\n\tint\t\t\tstatuses[MAX_PARALLEL_TESTS];\n\tstruct timeval end_times[MAX_PARALLEL_TESTS];\n\t_stringlist *ignorelist = NULL;\n\tchar\t\tscbuf[1024];\n\tFILE\t   *scf;\n\tint\t\t\tline_num = 0;\n\n\tmemset(resultfiles, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(expectfiles, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(tags, 0, sizeof(_stringlist *) * MAX_PARALLEL_TESTS);\n\tmemset(end_times, 0, sizeof(struct timeval) * MAX_PARALLEL_TESTS);\n\n\tscf = fopen(schedule, \"r\");\n\tif (!scf)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, schedule, strerror(errno));\n\t\texit(2);\n\t}\n\n\twhile (fgets(scbuf, sizeof(scbuf), scf))\n\t{\n\t\tchar\t   *test = NULL;\n\t\tchar\t   *c;\n\t\tint\t\t\tnum_tests;\n\t\tbool\t\tinword;\n\t\tint\t\t\ti;\n\t\tstruct timeval start_time;\n\n\t\tline_num++;\n\n\t\tfor (i = 0; i < MAX_PARALLEL_TESTS; i++)\n\t\t{\n\t\t\tif (resultfiles[i] == NULL)\n\t\t\t\tbreak;\n\t\t\tfree_stringlist(&resultfiles[i]);\n\t\t\tfree_stringlist(&expectfiles[i]);\n\t\t\tfree_stringlist(&tags[i]);\n\t\t}\n\n\t\t/* strip trailing whitespace, especially the newline */\n\t\ti = strlen(scbuf);\n\t\twhile (i > 0 && isspace((unsigned char) scbuf[i - 1]))\n\t\t\tscbuf[--i] = '\\0';\n\n\t\tif (scbuf[0] == '\\0' || scbuf[0] == '#')\n\t\t\tcontinue;\n\t\tif (strncmp(scbuf, \"test: \", 6) == 0)\n\t\t\ttest = scbuf + 6;\n\t\telse if (strncmp(scbuf, \"ignore: \", 8) == 0)\n\t\t{\n\t\t\tc = scbuf + 8;\n\t\t\twhile (*c && isspace((unsigned char) *c))\n\t\t\t\tc++;\n\t\t\tadd_stringlist_item(&ignorelist, c);\n\n\t\t\t/*\n\t\t\t * Note: ignore: lines do not run the test, they just say that\n\t\t\t * failure of this test when run later on is to be ignored. A bit\n\t\t\t * odd but that's how the shell-script version did it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, _(\"syntax error in schedule file \\\"%s\\\" line %d: %s\\n\"),\n\t\t\t\t\tschedule, line_num, scbuf);\n\t\t\texit(2);\n\t\t}\n\n\t\tnum_tests = 0;\n\t\tinword = false;\n\t\tfor (c = test; *c; c++)\n\t\t{\n\t\t\tif (isspace((unsigned char) *c))\n\t\t\t{\n\t\t\t\t*c = '\\0';\n\t\t\t\tinword = false;\n\t\t\t}\n\t\t\telse if (!inword)\n\t\t\t{\n\t\t\t\tif (num_tests >= MAX_PARALLEL_TESTS)\n\t\t\t\t{\n\t\t\t\t\t/* can't print scbuf here, it's already been trashed */\n\t\t\t\t\tfprintf(stderr, _(\"too many parallel tests in schedule file \\\"%s\\\", line %d\\n\"),\n\t\t\t\t\t\t\tschedule, line_num);\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\n\t\t\t\tif (num_tests - 1 >= 0 && should_exclude_test(tests[num_tests - 1]))\n\t\t\t\t\tnum_tests--;\n\n\t\t\t\ttests[num_tests] = c;\n\t\t\t\tnum_tests++;\n\t\t\t\tinword = true;\n\t\t\t}\n\t\t}\n\n\t\t/* The last test in the line needs to be checked for exclusion */\n\t\tif (num_tests - 1 >= 0 && should_exclude_test(tests[num_tests - 1]))\n\t\t{\n\t\t\tnum_tests--;\n\n\t\t\t/* All tests in this line are to be excluded, so go to the next line */\n\t\t\tif (num_tests == 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (num_tests == 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"syntax error in schedule file \\\"%s\\\" line %d: %s\\n\"),\n\t\t\t\t\tschedule, line_num, scbuf);\n\t\t\texit(2);\n\t\t}\n\n\t\tgettimeofday(&start_time, NULL);\n\t\tif (num_tests == 1)\n\t\t{\n\t\t\tstatus(_(\"test %-24s ... \"), tests[0]);\n\t\t\tpids[0] = (tfunc) (tests[0], &resultfiles[0], &expectfiles[0], &tags[0]);\n\t\t\twait_for_tests(pids, statuses, NULL, end_times, 1);\n\t\t\t/* status line is finished below */\n\t\t}\n\t\telse if (max_connections > 0 && max_connections < num_tests)\n\t\t{\n\t\t\tint\t\t\toldest = 0;\n\n\t\t\tstatus(_(\"parallel group (%d tests, in groups of %d): \"),\n\t\t\t\t   num_tests, max_connections);\n\t\t\tfor (i = 0; i < num_tests; i++)\n\t\t\t{\n\t\t\t\tif (i - oldest >= max_connections)\n\t\t\t\t{\n\t\t\t\t\twait_for_tests(pids + oldest, statuses + oldest,\n\t\t\t\t\t\t\t\t   tests + oldest, end_times + oldest, i - oldest);\n\t\t\t\t\toldest = i;\n\t\t\t\t}\n\t\t\t\tpids[i] = (tfunc) (tests[i], &resultfiles[i], &expectfiles[i], &tags[i]);\n\t\t\t}\n\t\t\twait_for_tests(pids + oldest, statuses + oldest,\n\t\t\t\t\t\t   tests + oldest, end_times + oldest, i - oldest);\n\t\t\tstatus_end();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus(_(\"parallel group (%d tests): \"), num_tests);\n\t\t\tfor (i = 0; i < num_tests; i++)\n\t\t\t{\n\t\t\t\tpids[i] = (tfunc) (tests[i], &resultfiles[i], &expectfiles[i], &tags[i]);\n\t\t\t}\n\t\t\twait_for_tests(pids, statuses, tests, end_times, num_tests);\n\t\t\tstatus_end();\n\t\t}\n\n\t\t/* Check results for all tests */\n\t\tfor (i = 0; i < num_tests; i++)\n\t\t{\n\t\t\t_stringlist *rl,\n\t\t\t\t\t   *el,\n\t\t\t\t\t   *tl;\n\t\t\tbool\t\tdiffer = false;\n\t\t\tdouble\t\tdiff_secs = 0, diff_elapse = 0;\n\t\t\tstruct timeval diff_start_time, diff_end_time;\n\n\t\t\tif (num_tests > 1)\n\t\t\t\tstatus(_(\"     %-24s ... \"), tests[i]);\n\n\t\t\tdiff_secs = end_times[i].tv_usec - start_time.tv_usec;\n\t\t\tdiff_secs /= 1000000;\n\t\t\tdiff_secs += end_times[i].tv_sec - start_time.tv_sec;\n\t\t\t/*\n\t\t\t * Advance over all three lists simultaneously.\n\t\t\t *\n\t\t\t * Compare resultfiles[j] with expectfiles[j] always. Tags are\n\t\t\t * optional but if there are tags, the tag list has the same\n\t\t\t * length as the other two lists.\n\t\t\t */\n\n\t\t\tgettimeofday(&diff_start_time, NULL);\n\t\t\tfor (rl = resultfiles[i], el = expectfiles[i], tl = tags[i];\n\t\t\t\t rl != NULL;\t/* rl and el have the same length */\n\t\t\t\t rl = rl->next, el = el->next,\n\t\t\t\t tl = tl ? tl->next : NULL)\n\t\t\t{\n\t\t\t\tbool\t\tnewdiff;\n\n\t\t\t\tnewdiff = results_differ(tests[i], rl->str, el->str);\n\t\t\t\tif (newdiff && tl)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%s \", tl->str);\n\t\t\t\t}\n\t\t\t\tdiffer |= newdiff;\n\t\t\t}\n\t\t\tgettimeofday(&diff_end_time, NULL);\n\n\t\t\tdiff_elapse = diff_end_time.tv_usec - diff_start_time.tv_usec;\n\t\t\tdiff_elapse /= 1000000;\n\t\t\tdiff_elapse += diff_end_time.tv_sec - diff_start_time.tv_sec;\n\n\t\t\tif (differ)\n\t\t\t{\n\t\t\t\tbool\t\tignore = false;\n\t\t\t\t_stringlist *sl;\n\n\t\t\t\tfor (sl = ignorelist; sl != NULL; sl = sl->next)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(tests[i], sl->str) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tignore = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ignore)\n\t\t\t\t{\n\t\t\t\t\tstatus(_(\"failed (ignored)\"));\n\t\t\t\t\tfail_ignore_count++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus(_(\"FAILED\"));\n    \t\t\t\tstatus(_(\" (%.2f sec)  (diff:%.2f sec)\"), diff_secs, diff_elapse);\n\t\t\t\t\tfail_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatus(_(\"ok\"));\n\t\t\t\tstatus(_(\" (%.2f sec)  (diff:%.2f sec)\"), diff_secs, diff_elapse);\n\t\t\t\tsuccess_count++;\n\t\t\t}\n\n\t\t\tif (statuses[i] != 0)\n\t\t\t\tlog_child_failure(statuses[i]);\n\n\t\t\tstatus_end();\n\t\t}\n\t}\n\n\tfree_stringlist(&ignorelist);\n\n\tfclose(scf);\n}\n\n/*\n * Run a single test\n */\nstatic void\nrun_single_test(const char *test, test_function tfunc)\n{\n\tPID_TYPE\tpid;\n\tint\t\t\texit_status;\n\t_stringlist *resultfiles = NULL;\n\t_stringlist *expectfiles = NULL;\n\t_stringlist *tags = NULL;\n\t_stringlist *rl,\n\t\t\t   *el,\n\t\t\t   *tl;\n\tbool\t\tdiffer = false;\n\n\tstatus(_(\"test %-24s ... \"), test);\n\tpid = (tfunc) (test, &resultfiles, &expectfiles, &tags);\n\twait_for_tests(&pid, &exit_status, NULL, NULL, 1);\n\n\t/*\n\t * Advance over all three lists simultaneously.\n\t *\n\t * Compare resultfiles[j] with expectfiles[j] always. Tags are optional\n\t * but if there are tags, the tag list has the same length as the other\n\t * two lists.\n\t */\n\tfor (rl = resultfiles, el = expectfiles, tl = tags;\n\t\t rl != NULL;\t\t\t/* rl and el have the same length */\n\t\t rl = rl->next, el = el->next,\n\t\t tl = tl ? tl->next : NULL)\n\t{\n\t\tbool\t\tnewdiff;\n\n\t\tnewdiff = results_differ(test, rl->str, el->str);\n\t\tif (newdiff && tl)\n\t\t{\n\t\t\tprintf(\"%s \", tl->str);\n\t\t}\n\t\tdiffer |= newdiff;\n\t}\n\n\tif (differ)\n\t{\n\t\tstatus(_(\"FAILED\"));\n\t\tfail_count++;\n\t}\n\telse\n\t{\n\t\tstatus(_(\"ok\"));\n\t\tsuccess_count++;\n\t}\n\n\tif (exit_status != 0)\n\t\tlog_child_failure(exit_status);\n\n\tstatus_end();\n}\n\n/*\n * Find the other binaries that we need. Currently, gpdiff.pl and\n * gpstringsubs.pl.\n */\nstatic void\nfind_helper_programs(const char *argv0)\n{\n\tif (find_other_exec(argv0, \"gpdiff.pl\", NULL, gpdiffprog) != 0)\n\t{\n\t\tchar\t\tfull_path[MAXPGPATH];\n\n\t\tif (find_my_exec(argv0, full_path) < 0)\n\t\t\tstrlcpy(full_path, progname, sizeof(full_path));\n\n\t\tfprintf(stderr,\n\t\t\t\t_(\"The program \\\"gpdiff.pl\\\" is needed by %s \"\n\t\t\t\t  \"but was not found in the same directory as \\\"%s\\\".\\n\"),\n\t\t\t\tprogname, full_path);\n\t\texit(1);\n\t}\n\tif (find_other_exec(argv0, \"gpstringsubs.pl\", NULL, gpstringsubsprog) != 0)\n\t{\n\t\tchar\t\tfull_path[MAXPGPATH];\n\n\t\tif (find_my_exec(argv0, full_path) < 0)\n\t\t\tstrlcpy(full_path, progname, sizeof(full_path));\n\n\t\tfprintf(stderr,\n\t\t\t\t_(\"The program \\\"gpstringsubs.pl\\\" is needed by %s \"\n\t\t\t\t  \"but was not found in the same directory as \\\"%s\\\".\\n\"),\n\t\t\t\tprogname, full_path);\n\t\texit(1);\n\t}\n}\n/*\n * Create the summary-output files (making them empty if already existing)\n */\nstatic void\nopen_result_files(void)\n{\n\tchar\t\tfile[MAXPGPATH];\n\tFILE\t   *difffile;\n\n\t/* create the log file (copy of running status output) */\n\tsnprintf(file, sizeof(file), \"%s/regression.out\", outputdir);\n\tlogfilename = strdup(file);\n\tlogfile = fopen(logfilename, \"w\");\n\tif (!logfile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, logfilename, strerror(errno));\n\t\texit(2);\n\t}\n\n\t/* create the diffs file as empty */\n\tsnprintf(file, sizeof(file), \"%s/regression.diffs\", outputdir);\n\tdifffilename = strdup(file);\n\tdifffile = fopen(difffilename, \"w\");\n\tif (!difffile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\tprogname, difffilename, strerror(errno));\n\t\texit(2);\n\t}\n\t/* we don't keep the diffs file open continuously */\n\tfclose(difffile);\n\n\t/* also create the output directory if not present */\n\tsnprintf(file, sizeof(file), \"%s/results\", outputdir);\n\tif (!directory_exists(file))\n\t\tmake_directory(file);\n}\n\nstatic void\ndrop_database_if_exists(const char *dbname)\n{\n\theader(_(\"dropping database \\\"%s\\\"\"), dbname);\n\tpsql_command(\"postgres\", \"DROP DATABASE IF EXISTS \\\"%s\\\"\", dbname);\n}\n\nstatic void\ncreate_database(const char *dbname)\n{\n\t_stringlist *sl;\n\n\t/*\n\t * We use template0 so that any installation-local cruft in template1 will\n\t * not mess up the tests.\n\t */\n\theader(_(\"creating database \\\"%s\\\"\"), dbname);\n\tif (encoding)\n\t\tpsql_command(\"postgres\", \"CREATE DATABASE \\\"%s\\\" TEMPLATE=template0 ENCODING='%s'\", dbname, encoding);\n\telse\n\t\tpsql_command(\"postgres\", \"CREATE DATABASE \\\"%s\\\" TEMPLATE=template0%s\", dbname,\n\t\t\t\t\t (nolocale) ? \" LC_COLLATE='C' LC_CTYPE='C'\" : \"\");\n\tpsql_command(dbname,\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_messages TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_monetary TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_numeric TO 'C';\"\n\t\t\t\t \"ALTER DATABASE \\\"%s\\\" SET lc_time TO 'C';\"\n\t\t\t\"ALTER DATABASE \\\"%s\\\" SET timezone_abbreviations TO 'Default';\",\n\t\t\t\t dbname, dbname, dbname, dbname, dbname);\n\n\t/*\n\t * Install any requested procedural languages.  We use CREATE OR REPLACE\n\t * so that this will work whether or not the language is preinstalled.\n\t */\n\tfor (sl = loadlanguage; sl != NULL; sl = sl->next)\n\t{\n\t\theader(_(\"installing %s\"), sl->str);\n\t\tpsql_command(dbname, \"CREATE OR REPLACE LANGUAGE \\\"%s\\\"\", sl->str);\n\t}\n\n\t/*\n\t * Install any requested extensions.  We use CREATE IF NOT EXISTS so that\n\t * this will work whether or not the extension is preinstalled.\n\t */\n\tfor (sl = loadextension; sl != NULL; sl = sl->next)\n\t{\n\t\theader(_(\"installing %s\"), sl->str);\n\t\tpsql_command(dbname, \"CREATE EXTENSION IF NOT EXISTS \\\"%s\\\"\", sl->str);\n\t}\n}\n\nstatic void\ndrop_role_if_exists(const char *rolename)\n{\n\theader(_(\"dropping role \\\"%s\\\"\"), rolename);\n\tpsql_command(\"postgres\", \"DROP ROLE IF EXISTS \\\"%s\\\"\", rolename);\n}\n\nstatic void\ncreate_role(const char *rolename, const _stringlist *granted_dbs)\n{\n\theader(_(\"creating role \\\"%s\\\"\"), rolename);\n\tpsql_command(\"postgres\", \"CREATE ROLE \\\"%s\\\" WITH LOGIN\", rolename);\n\tfor (; granted_dbs != NULL; granted_dbs = granted_dbs->next)\n\t{\n\t\tpsql_command(\"postgres\", \"GRANT ALL ON DATABASE \\\"%s\\\" TO \\\"%s\\\"\",\n\t\t\t\t\t granted_dbs->str, rolename);\n\t}\n}\n\nstatic char *\ntrim_white_space(char *str)\n{\n\tchar *end;\n\twhile (isspace((unsigned char)*str))\n\t{\n\t\tstr++;\n\t}\n\n\tif (*str == 0)\n\t{\n\t\treturn str;\n\t}\n\n\tend = str + strlen(str) - 1;\n\twhile (end > str && isspace((unsigned char)*end))\n\t{\n\t\tend--;\n\t}\n\n\t*(end+1) = 0;\n\treturn str;\n}\n\n/*\n * Should the test be excluded from running\n */\nstatic bool\nshould_exclude_test(char *test)\n{\n\t_stringlist *sl;\n\tfor (sl = exclude_tests; sl != NULL; sl = sl->next)\n\t{\n\t\tif (strcmp(test, sl->str) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * @brief Check whether a feature (e.g. optimizer) is on or off.\n * If the input feature is optimizer, then set the global\n * variable \"optimizer_enabled\" accordingly.\n *\n * @param feature_name Name of the feature to be checked (e.g. optimizer)\n * @param feature_value Expected value when the feature is enabled (i.e., on or group)\n * @param on_msg Message to be printed when the feature is enabled\n * @param off_msg Message to be printed when the feature is disabled\n * @return true if the feature is enabled; false otherwise\n */\nstatic bool\ncheck_feature_status(const char *feature_name, const char *feature_value,\n\t\t\t\t\t const char *on_msg, const char *off_msg)\n{\n\tchar psql_cmd[MAXPGPATH];\n\tchar statusfilename[MAXPGPATH];\n\tchar line[1024];\n\tbool isEnabled = false;\n\tint len;\n\n\theader(_(\"checking %s status\"), feature_name);\n\n\tsnprintf(statusfilename, sizeof(statusfilename), \"%s/%s_status.out\", outputdir, feature_name);\n\n\tlen = snprintf(psql_cmd, sizeof(psql_cmd),\n\t\t\t\"\\\"%s%spsql\\\" -X -t -c \\\"show %s;\\\" -o \\\"%s\\\" -d \\\"postgres\\\"\",\n\t\t\tpsqldir ? psqldir : \"\",\n\t\t\tpsqldir ? \"/\" : \"\",\n\t\t\tfeature_name,\n\t\t\tstatusfilename);\n\n\tif (len >= sizeof(psql_cmd))\n\t\texit_nicely(2);\n\n\tif (system(psql_cmd) != 0)\n\t\texit_nicely(2);\n\n\tFILE *statusfile = fopen(statusfilename, \"r\");\n\tif (!statusfile)\n\t{\n\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\tprogname, statusfilename, strerror(errno));\n\t\texit_nicely(2);\n\t}\n\n\twhile (fgets(line, sizeof(line), statusfile))\n\t{\n\t\tchar *trimmed = trim_white_space(line);\n\t\tif (strcmp(trimmed, feature_value) == 0)\n\t\t{\n\t\t\tstatus(_(\"%s\"), on_msg);\n\t\t\tisEnabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!isEnabled)\n\t\tstatus(_(\"%s\"), off_msg);\n\n\tstatus_end();\n\tfclose(statusfile);\n\tunlink(statusfilename);\n\treturn isEnabled;\n}\n\nstatic void\nhelp(void)\n{\n\tprintf(_(\"PostgreSQL regression test driver\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Usage:\\n  %s [OPTION]... [EXTRA-TEST]...\\n\"), progname);\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options:\\n\"));\n\tprintf(_(\"  --config-auth=DATADIR     update authentication settings for DATADIR\\n\"));\n\tprintf(_(\"  --create-role=ROLE        create the specified role before testing\\n\"));\n\tprintf(_(\"  --dbname=DB               use database DB (default \\\"regression\\\")\\n\"));\n\tprintf(_(\"  --debug                   turn on debug mode in programs that are run\\n\"));\n\tprintf(_(\"  --dlpath=DIR              look for dynamic libraries in DIR\\n\"));\n\tprintf(_(\"  --encoding=ENCODING       use ENCODING as the encoding\\n\"));\n\tprintf(_(\"  --inputdir=DIR            take input files from DIR (default \\\".\\\")\\n\"));\n\tprintf(_(\"  --launcher=CMD            use CMD as launcher of psql\\n\"));\n\tprintf(_(\"  --load-extension=EXT      load the named extension before running the\\n\"));\n\tprintf(_(\"                            tests; can appear multiple times\\n\"));\n\tprintf(_(\"  --load-language=LANG      load the named language before running the\\n\"));\n\tprintf(_(\"                            tests; can appear multiple times\\n\"));\n\tprintf(_(\"  --max-connections=N       maximum number of concurrent connections\\n\"));\n\tprintf(_(\"                            (default is 0, meaning unlimited)\\n\"));\n\tprintf(_(\"  --outputdir=DIR           place output files in DIR (default \\\".\\\")\\n\"));\n\tprintf(_(\"  --prehook=NAME            pre-hook name (default \\\"\\\")\\n\"));\n\tprintf(_(\"  --schedule=FILE           use test ordering schedule from FILE\\n\"));\n\tprintf(_(\"                            (can be used multiple times to concatenate)\\n\"));\n\tprintf(_(\"  --temp-install=DIR        create a temporary installation in DIR\\n\"));\n\tprintf(_(\"  --use-existing            use an existing installation\\n\"));\n\t/* Please put GPDB speicifc options at the end. */\n\tprintf(_(\"  --exclude-tests=TEST      command or space delimited tests to exclude from running\\n\"));\n    printf(_(\" --init-file=GPD_INIT_FILE  init file to be used for gpdiff\\n\"));\n\tprintf(_(\"  --ignore-plans            ignore any explain plan diffs\\n\"));\n\tprintf(_(\"  --print-failure-diffs     Print the diff file to standard out after a failure\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options for \\\"temp-install\\\" mode:\\n\"));\n\tprintf(_(\"  --extra-install=DIR       additional directory to install (e.g., contrib)\\n\"));\n\tprintf(_(\"  --no-locale               use C locale\\n\"));\n\tprintf(_(\"  --port=PORT               start postmaster on PORT\\n\"));\n\tprintf(_(\"  --temp-config=FILE        append contents of FILE to temporary config\\n\"));\n\tprintf(_(\"  --top-builddir=DIR        (relative) path to top level build directory\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options for using an existing installation:\\n\"));\n\tprintf(_(\"  --host=HOST               use postmaster running on HOST\\n\"));\n\tprintf(_(\"  --port=PORT               use postmaster running at PORT\\n\"));\n\tprintf(_(\"  --user=USER               connect as USER\\n\"));\n\tprintf(_(\"  --psqldir=DIR             use psql in DIR (default: configured bindir)\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"The exit status is 0 if all tests passed, 1 if some tests failed, and 2\\n\"));\n\tprintf(_(\"if the tests could not be run for some reason.\\n\"));\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Report bugs to <bugs@greenplum.org>.\\n\"));\n}\n\nint\nregression_main(int argc, char *argv[], init_function ifunc, test_function tfunc)\n{\n\tstatic struct option long_options[] = {\n\t\t{\"help\", no_argument, NULL, 'h'},\n\t\t{\"version\", no_argument, NULL, 'V'},\n\t\t{\"dbname\", required_argument, NULL, 1},\n\t\t{\"debug\", no_argument, NULL, 2},\n\t\t{\"inputdir\", required_argument, NULL, 3},\n\t\t{\"load-language\", required_argument, NULL, 4},\n\t\t{\"max-connections\", required_argument, NULL, 5},\n\t\t{\"encoding\", required_argument, NULL, 6},\n\t\t{\"outputdir\", required_argument, NULL, 7},\n\t\t{\"schedule\", required_argument, NULL, 8},\n\t\t{\"temp-install\", required_argument, NULL, 9},\n\t\t{\"no-locale\", no_argument, NULL, 10},\n\t\t{\"top-builddir\", required_argument, NULL, 11},\n\t\t{\"host\", required_argument, NULL, 13},\n\t\t{\"port\", required_argument, NULL, 14},\n\t\t{\"user\", required_argument, NULL, 15},\n\t\t{\"psqldir\", required_argument, NULL, 16},\n\t\t{\"dlpath\", required_argument, NULL, 17},\n\t\t{\"create-role\", required_argument, NULL, 18},\n\t\t{\"temp-config\", required_argument, NULL, 19},\n\t\t{\"use-existing\", no_argument, NULL, 20},\n\t\t{\"launcher\", required_argument, NULL, 21},\n\t\t{\"load-extension\", required_argument, NULL, 22},\n\t\t{\"extra-install\", required_argument, NULL, 23},\n\t\t{\"config-auth\", required_argument, NULL, 24},\n\t\t{\"init-file\", required_argument, NULL, 25},\n\t\t{\"exclude-tests\", required_argument, NULL, 26},\n\t\t{\"ignore-plans\", no_argument, NULL, 27},\n\t\t{\"prehook\", required_argument, NULL, 28},\n\t\t{\"print-failure-diffs\", no_argument, NULL, 29},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t_stringlist *sl;\n\tint\t\t\tc;\n\tint\t\t\ti;\n\tint\t\t\toption_index;\n\tchar\t\tbuf[MAXPGPATH * 4];\n\tchar\t\tbuf2[MAXPGPATH * 4];\n\n\tprogname = get_progname(argv[0]);\n\tset_pglocale_pgservice(argv[0], PG_TEXTDOMAIN(\"pg_regress\"));\n\n\tatexit(stop_postmaster);\n\n#ifndef HAVE_UNIX_SOCKETS\n\t/* no unix domain sockets available, so change default */\n\thostname = \"localhost\";\n#endif\n\n\t/*\n\t * We call the initialization function here because that way we can set\n\t * default parameters and let them be overwritten by the commandline.\n\t */\n\tifunc(argc, argv);\n\n\tif (getenv(\"PG_REGRESS_DIFF_OPTS\"))\n\t\tpretty_diff_opts = getenv(\"PG_REGRESS_DIFF_OPTS\");\n\n\twhile ((c = getopt_long(argc, argv, \"hV\", long_options, &option_index)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\tcase 'h':\n\t\t\t\thelp();\n\t\t\t\texit(0);\n\t\t\tcase 'V':\n\t\t\t\tputs(\"pg_regress (PostgreSQL) \" PG_VERSION);\n\t\t\t\texit(0);\n\t\t\tcase 1:\n\n\t\t\t\t/*\n\t\t\t\t * If a default database was specified, we need to remove it\n\t\t\t\t * before we add the specified one.\n\t\t\t\t */\n\t\t\t\tfree_stringlist(&dblist);\n\t\t\t\tsplit_to_stringlist(strdup(optarg), \", \", &dblist);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tinputdir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tadd_stringlist_item(&loadlanguage, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tmax_connections = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tencoding = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\toutputdir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tadd_stringlist_item(&schedulelist, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\ttemp_install = make_absolute_path(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tnolocale = true;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\ttop_builddir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\thostname = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\tport = atoi(optarg);\n\t\t\t\tport_specified_by_user = true;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tuser = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\t/* \"--psqldir=\" should mean to use PATH */\n\t\t\t\tif (strlen(optarg))\n\t\t\t\t\tpsqldir = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 17:\n\t\t\t\tdlpath = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 18:\n\t\t\t\tsplit_to_stringlist(strdup(optarg), \", \", &extraroles);\n\t\t\t\tbreak;\n\t\t\tcase 19:\n\t\t\t\ttemp_config = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tuse_existing = true;\n\t\t\t\tbreak;\n\t\t\tcase 21:\n\t\t\t\tlauncher = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tadd_stringlist_item(&loadextension, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tadd_stringlist_item(&extra_install, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tconfig_auth_datadir = pstrdup(optarg);\n\t\t\t\tbreak;\n            case 25:\n                initfile = strdup(optarg);\n                break;\n            case 26:\n                split_to_stringlist(strdup(optarg), \", \", &exclude_tests);\n                break;\n\t\t\tcase 27:\n\t\t\t\tignore_plans = true;\n\t\t\t\tbreak;\n\t\t\tcase 28:\n\t\t\t\tprehook = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 29:\n\t\t\t\tprint_failure_diffs_is_enabled = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* getopt_long already emitted a complaint */\n\t\t\t\tfprintf(stderr, _(\"\\nTry \\\"%s -h\\\" for more information.\\n\"),\n\t\t\t\t\t\tprogname);\n\t\t\t\texit(2);\n\t\t}\n\t}\n\n\t/*\n\t * if we still have arguments, they are extra tests to run\n\t */\n\twhile (argc - optind >= 1)\n\t{\n\t\tadd_stringlist_item(&extra_tests, argv[optind]);\n\t\toptind++;\n\t}\n\n\tif (config_auth_datadir)\n\t{\n#ifdef ENABLE_SSPI\n\t\tconfig_sspi_auth(config_auth_datadir);\n#endif\n\t\texit(0);\n\t}\n\n\tif (temp_install && !port_specified_by_user)\n\n\t\t/*\n\t\t * To reduce chances of interference with parallel installations, use\n\t\t * a port number starting in the private range (49152-65535)\n\t\t * calculated from the version number.  This aids !HAVE_UNIX_SOCKETS\n\t\t * systems; elsewhere, the use of a private socket directory already\n\t\t * prevents interference.\n\t\t */\n\t\tport = 0xC000 | (PG_VERSION_NUM & 0x3FFF);\n\n\tinputdir = make_absolute_path(inputdir);\n\toutputdir = make_absolute_path(outputdir);\n\tdlpath = make_absolute_path(dlpath);\n\n\t/*\n\t * Initialization\n\t */\n\tfind_helper_programs(argv[0]);\n\topen_result_files();\n\n\tif (prehook[0])\n\t{\n\t\tchar\t   *fullname = malloc(strlen(inputdir) +\n\t\t\t\t\t\t\t\t\t  strlen(\"/sql/hooks/\") +\n\t\t\t\t\t\t\t\t\t  strlen(prehook) +\n\t\t\t\t\t\t\t\t\t  strlen(\".sql\") +\n\t\t\t\t\t\t\t\t\t  1 /* '\\0' */);\n\t\tsprintf(fullname, \"%s/sql/hooks/%s.sql\", inputdir, prehook);\n\t\tprehook = fullname;\n\n\t\tif (!file_exists(prehook))\n\t\t{\n\t\t\tconvert_sourcefiles_in(\"input/hooks\", outputdir, \"sql/hooks\", \"sql\");\n\n\t\t\tif (!file_exists(prehook))\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"%s: could not open file \\\"%s\\\" for reading: %s\\n\"),\n\t\t\t\t\t\tprogname, prehook, strerror(errno));\n\t\t\t\texit(2);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitialize_environment();\n\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_CORE)\n\tunlimit_core_size();\n#endif\n\n\tif (temp_install)\n\t{\n\t\tFILE\t   *pg_conf;\n\t\t_stringlist *sl;\n\t\tconst char *env_wait;\n\t\tint\t\t\twait_seconds;\n\n\t\t/*\n\t\t * Prepare the temp installation\n\t\t */\n\t\tif (!top_builddir)\n\t\t{\n\t\t\tfprintf(stderr, _(\"--top-builddir must be specified when using --temp-install\\n\"));\n\t\t\texit(2);\n\t\t}\n\n\t\tif (directory_exists(temp_install))\n\t\t{\n\t\t\theader(_(\"removing existing temp installation\"));\n\t\t\tif (!rmtree(temp_install, true))\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not remove temp installation \\\"%s\\\"\\n\"),\n\t\t\t\t\t\tprogname, temp_install);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t}\n\n\t\theader(_(\"creating temporary installation\"));\n\n\t\t/* make the temp install top directory */\n\t\tmake_directory(temp_install);\n\n\t\t/* and a directory for log files */\n\t\tsnprintf(buf, sizeof(buf), \"%s/log\", outputdir);\n\t\tif (!directory_exists(buf))\n\t\t\tmake_directory(buf);\n\n\t\t/* \"make install\" */\n#ifndef WIN32_ONLY_COMPILER\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t \"\\\"%s\\\" -C \\\"%s\\\" DESTDIR=\\\"%s/install\\\" install > \\\"%s/log/install.log\\\" 2>&1\",\n\t\t\t\t makeprog, top_builddir, temp_install, outputdir);\n#else\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t \"perl \\\"%s/src/tools/msvc/install.pl\\\" \\\"%s/install\\\" >\\\"%s/log/install.log\\\" 2>&1\",\n\t\t\t\t top_builddir, temp_install, outputdir);\n#endif\n\t\tif (system(buf))\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: installation failed\\nExamine %s/log/install.log for the reason.\\nCommand was: %s\\n\"), progname, outputdir, buf);\n\t\t\texit(2);\n\t\t}\n\n\t\tfor (sl = extra_install; sl != NULL; sl = sl->next)\n\t\t{\n#ifndef WIN32_ONLY_COMPILER\n\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"\\\"%s\\\" -C \\\"%s/%s\\\" DESTDIR=\\\"%s/install\\\" install >> \\\"%s/log/install.log\\\" 2>&1\",\n\t\t\t\t   makeprog, top_builddir, sl->str, temp_install, outputdir);\n#else\n\t\t\tfprintf(stderr, _(\"\\n%s: --extra-install option not supported on this platform\\n\"), progname);\n\t\t\texit(2);\n#endif\n\n\t\t\tif (system(buf))\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: installation failed\\nExamine %s/log/install.log for the reason.\\nCommand was: %s\\n\"), progname, outputdir, buf);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t}\n\n\t\t/* initdb */\n\t\theader(_(\"initializing database system\"));\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t \"\\\"%s/initdb\\\" -D \\\"%s/data\\\" -L \\\"%s\\\" --noclean --nosync%s%s > \\\"%s/log/initdb.log\\\" 2>&1\",\n\t\t\t\t bindir, temp_install, datadir,\n\t\t\t\t debug ? \" --debug\" : \"\",\n\t\t\t\t nolocale ? \" --no-locale\" : \"\",\n\t\t\t\t outputdir);\n\t\tif (system(buf))\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: initdb failed\\nExamine %s/log/initdb.log for the reason.\\nCommand was: %s\\n\"), progname, outputdir, buf);\n\t\t\texit(2);\n\t\t}\n\n\t\t/*\n\t\t * Adjust the default postgresql.conf as needed for regression\n\t\t * testing. The user can specify a file to be appended; in any case we\n\t\t * set max_prepared_transactions to enable testing of prepared xacts.\n\t\t * (Note: to reduce the probability of unexpected shmmax failures,\n\t\t * don't set max_prepared_transactions any higher than actually needed\n\t\t * by the prepared_xacts regression test.)\n\t\t */\n\t\tsnprintf(buf, sizeof(buf), \"%s/data/postgresql.conf\", temp_install);\n\t\tpg_conf = fopen(buf, \"a\");\n\t\tif (pg_conf == NULL)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not open \\\"%s\\\" for adding extra config: %s\\n\"), progname, buf, strerror(errno));\n\t\t\texit(2);\n\t\t}\n\t\tfputs(\"\\n# Configuration added by pg_regress\\n\\n\", pg_conf);\n\t\tfputs(\"max_prepared_transactions = 2\\n\", pg_conf);\n\n\t\tif (temp_config != NULL)\n\t\t{\n\t\t\tFILE\t   *extra_conf;\n\t\t\tchar\t\tline_buf[1024];\n\n\t\t\textra_conf = fopen(temp_config, \"r\");\n\t\t\tif (extra_conf == NULL)\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not open \\\"%s\\\" to read extra config: %s\\n\"), progname, temp_config, strerror(errno));\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\twhile (fgets(line_buf, sizeof(line_buf), extra_conf) != NULL)\n\t\t\t\tfputs(line_buf, pg_conf);\n\t\t\tfclose(extra_conf);\n\t\t}\n\n\t\tfclose(pg_conf);\n\n#ifdef ENABLE_SSPI\n\n\t\t/*\n\t\t * Since we successfully used the same buffer for the much-longer\n\t\t * \"initdb\" command, this can't truncate.\n\t\t */\n\t\tsnprintf(buf, sizeof(buf), \"%s/data\", temp_install);\n\t\tconfig_sspi_auth(buf);\n#elif !defined(HAVE_UNIX_SOCKETS)\n#error Platform has no means to secure the test installation.\n#endif\n\n\t\t/*\n\t\t * Check if there is a postmaster running already.\n\t\t */\n\t\tsnprintf(buf2, sizeof(buf2),\n\t\t\t\t \"\\\"%s/psql\\\" -X postgres <%s 2>%s\",\n\t\t\t\t bindir, DEVNULL, DEVNULL);\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t{\n\t\t\tif (system(buf2) == 0)\n\t\t\t{\n\t\t\t\tchar\t\ts[16];\n\n\t\t\t\tif (port_specified_by_user || i == 15)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr, _(\"port %d apparently in use\\n\"), port);\n\t\t\t\t\tif (!port_specified_by_user)\n\t\t\t\t\t\tfprintf(stderr, _(\"%s: could not determine an available port\\n\"), progname);\n\t\t\t\t\tfprintf(stderr, _(\"Specify an unused port using the --port option or shut down any conflicting PostgreSQL servers.\\n\"));\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr, _(\"port %d apparently in use, trying %d\\n\"), port, port + 1);\n\t\t\t\tport++;\n\t\t\t\tsprintf(s, \"%d\", port);\n\t\t\t\tdoputenv(\"PGPORT\", s);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Start the temp postmaster\n\t\t */\n\t\theader(_(\"starting postmaster\"));\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t \"\\\"%s/postgres\\\" -D \\\"%s/data\\\" -F%s \"\n\t\t\t\t \"-c \\\"listen_addresses=%s\\\" -k \\\"%s\\\" \"\n\t\t\t\t \"> \\\"%s/log/postmaster.log\\\" 2>&1\",\n\t\t\t\t bindir, temp_install, debug ? \" -d 5\" : \"\",\n\t\t\t\t hostname ? hostname : \"\", sockdir ? sockdir : \"\",\n\t\t\t\t outputdir);\n\t\tpostmaster_pid = spawn_process(buf);\n\t\tif (postmaster_pid == INVALID_PID)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: could not spawn postmaster: %s\\n\"),\n\t\t\t\t\tprogname, strerror(errno));\n\t\t\texit(2);\n\t\t}\n\n\t\t/*\n\t\t * Wait till postmaster is able to accept connections; normally this\n\t\t * is only a second or so, but Cygwin is reportedly *much* slower, and\n\t\t * test builds using Valgrind or similar tools might be too.  Hence,\n\t\t * allow the default timeout of 60 seconds to be overridden from the\n\t\t * PGCTLTIMEOUT environment variable.\n\t\t */\n\t\tenv_wait = getenv(\"PGCTLTIMEOUT\");\n\t\tif (env_wait != NULL)\n\t\t{\n\t\t\twait_seconds = atoi(env_wait);\n\t\t\tif (wait_seconds <= 0)\n\t\t\t\twait_seconds = 60;\n\t\t}\n\t\telse\n\t\t\twait_seconds = 60;\n\n\t\tfor (i = 0; i < wait_seconds; i++)\n\t\t{\n\t\t\t/* Done if psql succeeds */\n\t\t\tif (system(buf2) == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Fail immediately if postmaster has exited\n\t\t\t */\n#ifndef WIN32\n\t\t\tif (waitpid(postmaster_pid, NULL, WNOHANG) == postmaster_pid)\n#else\n\t\t\tif (WaitForSingleObject(postmaster_pid, 0) == WAIT_OBJECT_0)\n#endif\n\t\t\t{\n\t\t\t\tfprintf(stderr, _(\"\\n%s: postmaster failed\\nExamine %s/log/postmaster.log for the reason\\n\"), progname, outputdir);\n\t\t\t\texit(2);\n\t\t\t}\n\n\t\t\tpg_usleep(1000000L);\n\t\t}\n\t\tif (i >= wait_seconds)\n\t\t{\n\t\t\tfprintf(stderr, _(\"\\n%s: postmaster did not respond within %d seconds\\nExamine %s/log/postmaster.log for the reason\\n\"),\n\t\t\t\t\tprogname, wait_seconds, outputdir);\n\n\t\t\t/*\n\t\t\t * If we get here, the postmaster is probably wedged somewhere in\n\t\t\t * startup.  Try to kill it ungracefully rather than leaving a\n\t\t\t * stuck postmaster that might interfere with subsequent test\n\t\t\t * attempts.\n\t\t\t */\n#ifndef WIN32\n\t\t\tif (kill(postmaster_pid, SIGKILL) != 0 &&\n\t\t\t\terrno != ESRCH)\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not kill failed postmaster: %s\\n\"),\n\t\t\t\t\t\tprogname, strerror(errno));\n#else\n\t\t\tif (TerminateProcess(postmaster_pid, 255) == 0)\n\t\t\t\tfprintf(stderr, _(\"\\n%s: could not kill failed postmaster: error code %lu\\n\"),\n\t\t\t\t\t\tprogname, GetLastError());\n#endif\n\n\t\t\texit(2);\n\t\t}\n\n\t\tpostmaster_running = true;\n\n#ifdef WIN64\n/* need a series of two casts to convert HANDLE without compiler warning */\n#define ULONGPID(x) (unsigned long) (unsigned long long) (x)\n#else\n#define ULONGPID(x) (unsigned long) (x)\n#endif\n\t\tprintf(_(\"running on port %d with PID %lu\\n\"),\n\t\t\t   port, ULONGPID(postmaster_pid));\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Using an existing installation, so may need to get rid of\n\t\t * pre-existing database(s) and role(s)\n\t\t */\n\t\tif (!use_existing)\n\t\t{\n\t\t\tfor (sl = dblist; sl; sl = sl->next)\n\t\t\t\tdrop_database_if_exists(sl->str);\n\t\t\tfor (sl = extraroles; sl; sl = sl->next)\n\t\t\t\tdrop_role_if_exists(sl->str);\n\t\t}\n\t}\n\n\t/*\n\t * Create the test database(s) and role(s)\n\t */\n\tif (!use_existing)\n\t{\n\t\tfor (sl = dblist; sl; sl = sl->next)\n\t\t\tcreate_database(sl->str);\n\t\tfor (sl = extraroles; sl; sl = sl->next)\n\t\t\tcreate_role(sl->str, dblist);\n\t}\n\n\t/*\n\t * Find out if optimizer is on or off\n\t */\n\toptimizer_enabled = check_feature_status(\"optimizer\", \"on\",\n\t\t\t\"Optimizer enabled. Using optimizer answer files whenever possible\",\n\t\t\t\"Optimizer disabled. Using planner answer files\");\n\n\t/*\n\t * Find out if gp_resource_manager is group or not\n\t */\n\tresgroup_enabled = check_feature_status(\"gp_resource_manager\", \"group\",\n\t\t\t\"Resource group enabled. Using resource group answer files whenever possible\",\n\t\t\t\"Resource group disabled. Using default answer files\");\n\n\t/*\n\t * Ready to run the tests\n\t */\n\theader(_(\"running regression test queries\"));\n\n\tfor (sl = schedulelist; sl != NULL; sl = sl->next)\n\t{\n\t\trun_schedule(sl->str, tfunc);\n\t}\n\n\tfor (sl = extra_tests; sl != NULL; sl = sl->next)\n\t{\n\t\trun_single_test(sl->str, tfunc);\n\t}\n\n\t/*\n\t * Shut down temp installation's postmaster\n\t */\n\tif (temp_install)\n\t{\n\t\theader(_(\"shutting down postmaster\"));\n\t\tstop_postmaster();\n\t}\n\n\t/*\n\t * If there were no errors, remove the temp installation immediately to\n\t * conserve disk space.  (If there were errors, we leave the installation\n\t * in place for possible manual investigation.)\n\t */\n\tif (temp_install && fail_count == 0 && fail_ignore_count == 0)\n\t{\n\t\theader(_(\"removing temporary installation\"));\n\t\tif (!rmtree(temp_install, true))\n\t\t\tfprintf(stderr, _(\"\\n%s: could not remove temp installation \\\"%s\\\"\\n\"),\n\t\t\t\t\tprogname, temp_install);\n\t}\n\n\tfclose(logfile);\n\n\t/*\n\t * Emit nice-looking summary message\n\t */\n\tif (fail_count == 0 && fail_ignore_count == 0)\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" All %d tests passed. \"),\n\t\t\t\t success_count);\n\telse if (fail_count == 0)\t/* fail_count=0, fail_ignore_count>0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests passed, %d failed test(s) ignored. \"),\n\t\t\t\t success_count,\n\t\t\t\t success_count + fail_ignore_count,\n\t\t\t\t fail_ignore_count);\n\telse if (fail_ignore_count == 0)\t/* fail_count>0 && fail_ignore_count=0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests failed. \"),\n\t\t\t\t fail_count,\n\t\t\t\t success_count + fail_count);\n\telse\n\t\t/* fail_count>0 && fail_ignore_count>0 */\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t _(\" %d of %d tests failed, %d of these failures ignored. \"),\n\t\t\t\t fail_count + fail_ignore_count,\n\t\t\t\t success_count + fail_count + fail_ignore_count,\n\t\t\t\t fail_ignore_count);\n\n\tputchar('\\n');\n\tfor (i = strlen(buf); i > 0; i--)\n\t\tputchar('=');\n\tprintf(\"\\n%s\\n\", buf);\n\tfor (i = strlen(buf); i > 0; i--)\n\t\tputchar('=');\n\tputchar('\\n');\n\tputchar('\\n');\n\n\tif (file_size(difffilename) > 0)\n\t{\n\t\tif (print_failure_diffs_is_enabled)\n\t\t\tprint_contents_of_file(difffilename);\n\n\t\tprintf(_(\"The differences that caused some tests to fail can be viewed in the\\n\"\n\t\t\t\t \"file \\\"%s\\\".  A copy of the test summary that you see\\n\"\n\t\t\t\t \"above is saved in the file \\\"%s\\\".\\n\\n\"),\n\t\t\t   difffilename, logfilename);\n\t}\n\telse\n\t{\n\t\tunlink(difffilename);\n\t\tunlink(logfilename);\n\t}\n\n\tif (fail_count != 0)\n\t\texit(1);\n\n\treturn 0;\n}\n\nstatic char *\nget_host_name(int16 contentid, char role)\n{\n\tchar psql_cmd[MAXPGPATH];\n\tFILE       *fp;\n\tchar line[1024];\n\tint len;\n\tchar *hostname = NULL;\n\n\tlen = snprintf(psql_cmd, sizeof(psql_cmd),\n\t\t\t\"\\\"%s%spsql\\\" -X -t -c \\\"select hostname from gp_segment_configuration where role=\\'%c\\' and content = %d;\\\" -d \\\"postgres\\\"\",\n\t\t\t\t   bindir ? bindir : \"\",\n\t\t\t\t   bindir ? \"/\" : \"\",\n\t\t\t\t   role,\n\t\t\t\t   contentid);\n\n\tif (len >= sizeof(psql_cmd))\n\t\texit_nicely(2);\n\n\t/* Execute the command with pipe and read the standard output. */\n\tif ((fp = popen(psql_cmd, \"r\")) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s: cannot launch shell command\\n\", progname);\n\t\texit_nicely(2);\n\t}\n\n\tif (fgets(line, sizeof(line), fp) == NULL)\n\t{\n\t\tfprintf(stderr, \"%s: cannot read the result\\n\", progname);\n\t\t(void) pclose(fp);\n\t\texit_nicely(2);\n\t}\n\n\tif (pclose(fp) < 0)\n\t{\n\t\tfprintf(stderr, \"%s: cannot close shell command\\n\", progname);\n\t\texit_nicely(2);\n\t}\n\n\thostname = psprintf(\"%s\", trim_white_space(line));\n\n\tif (strcmp(\"\", hostname) == 0)\n\t{\n\t\tfprintf(stderr, _(\"%s: failed to determine hostname for content 0 primary\\n\"),\n\t\t\t\tprogname);\n\t\texit_nicely(2);\n\t}\n\n\treturn hostname;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/contrib/pg_upgrade/page.c": "/*\n *\tpage.c\n *\n *\tper-page conversion operations\n *\n *\tCopyright (c) 2010-2014, PostgreSQL Global Development Group\n *\tcontrib/pg_upgrade/page.c\n */\n\n#include \"postgres_fe.h\"\n\n#include \"pg_upgrade.h\"\n\n#include \"storage/bufpage.h\"\n\n\n#ifdef PAGE_CONVERSION\n\n\nstatic void getPageVersion(\n\t\t\t   uint16 *version, const char *pathName);\nstatic pageCnvCtx *loadConverterPlugin(\n\t\t\t\t\tuint16 newPageVersion, uint16 oldPageVersion);\n\n\n/*\n * setupPageConverter()\n *\n *\tThis function determines the PageLayoutVersion of the old cluster and\n *\tthe PageLayoutVersion of the new cluster.  If the versions differ, this\n *\tfunction loads a converter plugin and returns a pointer to a pageCnvCtx\n *\tobject (in *result) that knows how to convert pages from the old format\n *\tto the new format.  If the versions are identical, this function just\n *\treturns a NULL pageCnvCtx pointer to indicate that page-by-page conversion\n *\tis not required.\n */\npageCnvCtx *\nsetupPageConverter(void)\n{\n\tuint16\t\toldPageVersion;\n\tuint16\t\tnewPageVersion;\n\tpageCnvCtx *converter;\n\tconst char *msg;\n\tchar\t\tdstName[MAXPGPATH];\n\tchar\t\tsrcName[MAXPGPATH];\n\n\tsnprintf(dstName, sizeof(dstName), \"%s/global/%u\", new_cluster.pgdata,\n\t\t\t new_cluster.pg_database_oid);\n\tsnprintf(srcName, sizeof(srcName), \"%s/global/%u\", old_cluster.pgdata,\n\t\t\t old_cluster.pg_database_oid);\n\n\tgetPageVersion(&oldPageVersion, srcName);\n\tgetPageVersion(&newPageVersion, dstName);\n\n\t/*\n\t * If the old cluster and new cluster use the same page layouts, then we\n\t * don't need a page converter.\n\t */\n\tif (newPageVersion != oldPageVersion)\n\t{\n\t\t/*\n\t\t * The clusters use differing page layouts, see if we can find a\n\t\t * plugin that knows how to convert from the old page layout to the\n\t\t * new page layout.\n\t\t */\n\n\t\tif ((converter = loadConverterPlugin(newPageVersion, oldPageVersion)) == NULL)\n\t\t\tpg_fatal(\"could not find plugin to convert from old page layout to new page layout\\n\");\n\n\t\treturn converter;\n\t}\n\telse\n\t\treturn NULL;\n}\n\n\n/*\n * getPageVersion()\n *\n *\tRetrieves the PageLayoutVersion for the given relation.\n *\n *\tReturns NULL on success (and stores the PageLayoutVersion at *version),\n *\tif an error occurs, this function returns an error message (in the form\n *\tof a null-terminated string).\n */\nstatic void\ngetPageVersion(uint16 *version, const char *pathName)\n{\n\tint\t\t\trelfd;\n\tPageHeaderData page;\n\tssize_t\t\tbytesRead;\n\n\tif ((relfd = open(pathName, O_RDONLY, 0)) < 0)\n\t\tpg_fatal(\"could not open relation %s\\n\", pathName);\n\n\tif ((bytesRead = read(relfd, &page, sizeof(page))) != sizeof(page))\n\t\tpg_fatal(\"could not read page header of %s\\n\", pathName);\n\n\t*version = PageGetPageLayoutVersion(&page);\n\n\tclose(relfd);\n\n\treturn;\n}\n\n\n/*\n * loadConverterPlugin()\n *\n *\tThis function loads a page-converter plugin library and grabs a\n *\tpointer to each of the (interesting) functions provided by that\n *\tplugin.  The name of the plugin library is derived from the given\n *\tnewPageVersion and oldPageVersion.  If a plugin is found, this\n *\tfunction returns a pointer to a pageCnvCtx object (which will contain\n *\ta collection of plugin function pointers). If the required plugin\n *\tis not found, this function returns NULL.\n */\nstatic pageCnvCtx *\nloadConverterPlugin(uint16 newPageVersion, uint16 oldPageVersion)\n{\n\tchar\t\tpluginName[MAXPGPATH];\n\tvoid\t   *plugin;\n\n\t/*\n\t * Try to find a plugin that can convert pages of oldPageVersion into\n\t * pages of newPageVersion.  For example, if we oldPageVersion = 3 and\n\t * newPageVersion is 4, we search for a plugin named:\n\t * plugins/convertLayout_3_to_4.dll\n\t */\n\n\t/*\n\t * FIXME: we are searching for plugins relative to the current directory,\n\t * we should really search relative to our own executable instead.\n\t */\n\tsnprintf(pluginName, sizeof(pluginName), \"./plugins/convertLayout_%d_to_%d%s\",\n\t\t\t oldPageVersion, newPageVersion, DLSUFFIX);\n\n\tif ((plugin = pg_dlopen(pluginName)) == NULL)\n\t\treturn NULL;\n\telse\n\t{\n\t\tpageCnvCtx *result = (pageCnvCtx *) pg_malloc(sizeof(*result));\n\n\t\tresult->old.PageVersion = oldPageVersion;\n\t\tresult->new.PageVersion = newPageVersion;\n\n\t\tresult->startup = (pluginStartup) pg_dlsym(plugin, \"init\");\n\t\tresult->convertFile = (pluginConvertFile) pg_dlsym(plugin, \"convertFile\");\n\t\tresult->convertPage = (pluginConvertPage) pg_dlsym(plugin, \"convertPage\");\n\t\tresult->shutdown = (pluginShutdown) pg_dlsym(plugin, \"fini\");\n\t\tresult->pluginData = NULL;\n\n\t\t/*\n\t\t * If the plugin has exported an initializer, go ahead and invoke it.\n\t\t */\n\t\tif (result->startup)\n\t\t\tresult->startup(MIGRATOR_API_VERSION, &result->pluginVersion,\n\t\t\t\t\t\tnewPageVersion, oldPageVersion, &result->pluginData);\n\n\t\treturn result;\n\t}\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/logo-greenplum.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/bin/gpfdist/regress/data/exttab1/nation.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/timezone/tznames/Europe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/backend/utils/mb/conversion_procs/README.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/port/win32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/big5.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/sjis.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/big5.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/sjis.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/mb/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/regress/data/latin1_encoding.csv",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/regress/expected/dispatch_encoding.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/regress/expected/gpcopy_encoding.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/gr-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/test-de.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-upper.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/de-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/koi8-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/test/locale/koi8-r/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/src/tools/vagrant/pictures/gpdb_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/sql_migration/gif/Inventory_Management_Database.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/sql_migration/gif/Staff_Management_Database.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/sql_migration/gif/Thumbs.db",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/sql_migration/gif/STRPOSB.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LNNVL.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TO_CHAR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_PIPE_flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TO_DATE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_RANDOM.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NVARCHAR2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/RPAD.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/RTRIM.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/SUBSTRB.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/MEDIAN.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NEXT_DAY.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_ASSERT.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LTRIM.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_OUTPUT.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/SINH.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/UTL_FILE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/SUBSTR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LAST_DAY.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NVL2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/INSTR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/Thumbs.db",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NLSSORT.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DUMP.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TANH.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/VARCHAR2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/ADD_MONTHS.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_ALERT_flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LISTAGG.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NVL.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBTIMEZONE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LENGTHB.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/MONTHS_BETWEEN.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_PIPE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TO_MULTI_BYTE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DECODE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/ROUND.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TO_NUMBER.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_ALERT.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/SESSIONTIMEZONE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TO_SINGLE_BYTE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/NANVL.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LENGTH.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/SYSDATE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/TRUNC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/BITAND.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DATE.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/BTRIM.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/DBMS_UTILITY.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/LPAD.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/COSH.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpcontrib/orafce/doc/orafce_documentation/gif/STRPOSB.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/markdown/cloud/graphics/gcp-disk-rates.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/markdown/pxf/graphics/pxfarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/markdown/pxf/graphics/pxfreadwrite.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/book/master_middleman/source/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/multi_switch_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/hardware_stack.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/disk_raid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/cc_arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/install_guide/graphics/multi_nic_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/best_practices/graphics/group-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/best_practices/graphics/block-mirrors-4x8.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/best_practices/graphics/spread-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/queryscreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/pg_admin_III_callout.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/resgroupmem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/pg3_queryplan.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_dump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-pgadmin-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_hadoop.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/admin_guide/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/GPdiskquota.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/mirrorsegs.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/spread-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/piv-opt.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/slice_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/sne_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/multi_switch_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/build_gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/mapreducejob.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/hardware_stack.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/gp_dump.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/resource_queues.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/partitions.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/group-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/highlevel_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/mirrorsegs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/standby_master.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/multi_nic_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/disk_raid.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/physical_storage.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/star_schema.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/gp_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/targeted_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/recovermatrix.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables_multinic.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/gangs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/rack_diagrams.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/mapred_flow.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/parallel_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/nonpar_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/gp_query_priority.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/monitor_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/load-xml.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpdb-doc/dita/graphics/source_files/memory.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/info.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/exclamic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/Up.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/removico.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/completi.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/New.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/bannrbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/Thumbs.db",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/custicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/repairic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/insticon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpAux/client/install/src/windows/Binary/dlgbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/contrib/formatter_fixedwidth/data/fixedwidth_small_correct.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/contrib/unaccent/expected/unaccent.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/contrib/unaccent/sql/unaccent.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/contrib/pgrowlocks/README.pgrowlocks.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/doc/src/sgml/ref/drop_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/doc/src/sgml/ref/create_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpMgmt/demo/gppkg/sample-sources.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpMgmt/demo/gppkg/data/sample-0.0-1.amd64.deb",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-6.1.0-xphs3lbaospehfrkrt46jn5l2bvaerj6/spack-src/gpMgmt/demo/gppkg/data/sample-0.0.1-noop.x86_64.rpm"
    ],
    "total_files": 8154
}