{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/GridApplicInterface.hpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        GridApplicInterface\n//- Description:  Derived class for the case when analysis code simulators are\n//-               invoked using a Condor/Globus computational grid\n//- Owner:        Mike Eldred\n//- Version: $Id: GridApplicInterface.hpp 6492 2009-12-19 00:04:28Z briadam $\n\n#ifndef GRID_APPLIC_INTERFACE_H\n#define GRID_APPLIC_INTERFACE_H\n\n#include \"SysCallApplicationInterface.hpp\"\n\n\nnamespace Dakota {\n\nextern \"C\" {\n/// definition of start grid computing type (function pointer)\ntypedef int  (*start_grid_computing_t)(char *analysis_driver_script,\n\t\t\t\t       char *params_file, char *results_file);\n/// definition of perform analysis type (function pointer)\ntypedef int  (*perform_analysis_t)(char *iteration_num);\n/// definition of get completed jobs type (function pointer)\ntypedef int* (*get_jobs_completed_t)();\n/// definition of stop grid computing type (function pointer)\ntypedef int  (*stop_grid_computing_t)();\n}\n\n\n/// Derived application interface class which spawns simulation codes\n/// using grid services such as Condor or Globus.\n\n/** This class is currently a modified copy of SysCallApplicInterface\n    adapted for use with an external grid dervices library which was\n    dynamically linked using dlopen() services. */\n\nclass GridApplicInterface: public SysCallApplicInterface\n{\npublic:\n\n  //\n  //- Heading: Constructors and destructor\n  //\n\n  /// constructor\n  GridApplicInterface(const ProblemDescDB& problem_db);\n\n  /// destructor\n  ~GridApplicInterface();\n\n  //\n  //- Heading: Virtual function redefinitions\n  //\n\n  ///\n  void derived_map(const Variables& vars, const ActiveSet& set,\n\t\t   Response& response, int fn_eval_id);\n\n  ///\n  void derived_map_asynch(const ParamResponsePair& pair);\n\n  ///\n  void wait_local_evaluations(PRPQueue& prp_queue)\n\t{\n  \twhile (completionSet.empty())\n          test_local_evaluations(prp_queue);\n\t}\n\n  ///\n  void test_local_evaluations(PRPQueue& prp_queue);\n\n  /** This code provides the derived function used by\n   *  ApplicationInterface::serve_analyses_synch().\n   */\n  int synchronous_local_analysis(int analysis_id)\n\t{\n\t///\n\t/// TODO - allow local analyses?????\n\t///\n  \tspawn_analysis_to_shell(analysis_id, BLOCK);\n  \treturn 0; // used for failure codes in DirectFn case\n\t}\n\nprotected:\n\n  //\n  //- Heading: Methods\n  //\n\n  /// test file(s) for existence based on root_file name \n  bool grid_file_test(const String& root_file);\n\n  //\n  //- Heading: Data\n  //\n\n  /// Set of function evaluation id's for active asynchronous\n  /// system call evaluations\n  IntSet idSet;\n\n  /// map linking function evaluation id's to number of response read failures\n  IntShortMap failCountMap; \n\n  /// handle to dynamically linked start_grid_computing function\n  start_grid_computing_t start_grid_computing;\n  /// handle to dynamically linked perform_analysis grid function\n  perform_analysis_t     perform_analysis;\n  /// handle to dynamically linked get_jobs_completed grid function\n  get_jobs_completed_t   get_jobs_completed;\n  /// handle to dynamically linked stop_grid_computing function\n  stop_grid_computing_t  stop_grid_computing;\n};\n\n} // namespace Dakota\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/GridApplicInterface.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        GridApplicInterface\n//- Description:  Class implementation\n//- Owner:        Mike Eldred\n\n#ifdef DAKOTA_GRID\n\n#include <dlfcn.h>\n#include <link.h>\n#include <sys/types.h> // MAY REQUIRE ifndef(HPUX)\n#include <sys/stat.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h> // for usleep()\n#endif\n#include \"DakotaResponse.hpp\"\n#include \"ParamResponsePair.hpp\"\n#include \"GridApplicInterface.hpp\"\n#include \"dakota_system_defs.hpp\"\n#include \"ProblemDescDB.hpp\"\n\n//#define TESTING_GRID\n\n//extern \"C\" int start_grid_computing(char *analysis_driver_script,\n//                                    char *params_file, char *results_file);\n//extern \"C\" int perform_analysis(char *iteration_num);\n//extern \"C\" int *get_jobs_completed();\n//extern \"C\" int stop_grid_computing();\n/*\nThis api returns the pointer to a pre-allocated fixed interger array.\nThe first element contains the number of returned iteration nums ;\nthe following elements contain the iteration nums.\n    e.g.  3 1 3 5 \n          returns 3 iteration nums 1, 3, 5\n         \n          0\n          no iteration num returned\n*/\n\n\nnamespace Dakota {\n\n\nGridApplicInterface::\nGridApplicInterface(const ProblemDescDB& problem_db):\n  SysCallApplicInterface(problem_db)\n{ \n  void* handle = dlopen(\"foo.so\", RTLD_NOW);\n  if (!handle) {\n    Cerr << \"Problem loading shared object file: foo.so\" << std::endl;\n    abort_handler(-1);\n  }\n  start_grid_computing\n    = (start_grid_computing_t)(dlsym(handle, \"start_grid_computing\"));\n  const char* error;\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading start_grid_computing function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  stop_grid_computing\n    = (stop_grid_computing_t)dlsym(handle, \"stop_grid_computing\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading stop_grid_computing function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  perform_analysis = (perform_analysis_t)dlsym(handle, \"perform_analysis\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading perform_analysis function: \" << error << std::endl;\n    abort_handler(-1);\n  }\n  get_jobs_completed = (get_jobs_completed_t)dlsym(handle,\"get_jobs_completed\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading get_jobs_completed function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  int status = (*start_grid_computing)(programNames[0].data(),\n\t\t\t\t       paramsFileName.data(), \n\t\t\t\t       resultsFileName.data());\n  //fileSaveFlag=true;\n}\n\n\nGridApplicInterface::~GridApplicInterface() \n{\n  int status = (*stop_grid_computing)();\n  // TODO - ERROR CHECKING\n}\n\n\nvoid GridApplicInterface::\nderived_map(const Variables& vars, const ActiveSet& set, Response& response,\n\t    int fn_eval_id)\n{\n  //\n  // Launch the grid solver (asynchronously)\n  //\n  ParamResponsePair prp(vars, interfaceId, response, fn_eval_id);\n  derived_map_asynch(prp);\n  //\n  // Call wait_local_evaluations() until our id is in the set\n  //\n  PRPQueue prp_queue;\n  prp_queue.push_back(prp);\n  if (!completionSet.empty()) {\n    Cerr << \"derived_map - should start with an empty completion set\\n\";\n    abort_handler(-1);\n  }\n  wait_local_evaluations(prp_queue); // rebuilds completionSet\n  response = prp_queue.front().response();\n  completionSet.clear();\n#if 0\n  //\n  // Read the params file and handle exceptions\n  //\n  try {\n    if (evalCommRank == 0)\n      read_results_files(response, fn_eval_id);\n  }\n  catch(const FileReadException& fr_except) {\n    // a FileReadException exception involves detection of an\n    // incomplete file/data set.  In the synchronous case, there is no\n    // potential for an incomplete file resulting from a race\n    // condition -> echo the error and abort.\n    Cerr << \"\\nError reading results file:\\n  \" << fr_except.what() << std::endl;\n    abort_handler(INTERFACE_ERROR);\n  }\n  catch(const FunctionEvalFailure& fneval_except) {\n    // The approach here is to have catch(FunctionEvalFailure) rethrow\n    // the exception to an outer catch (either the catch within\n    // manage_failure or a catch that calls manage_failure).\n    throw;\n  }\n#endif\n}\n\n\nvoid GridApplicInterface::derived_map_asynch(const ParamResponsePair& pair)\n{\n  //\n  // Write the params file\n  //\n  int fn_eval_id = pair.eval_id();\n  define_filenames(fn_eval_id);\n  write_parameters_files(pair.variables(), pair.active_set(),\n\t\t\t pair.response(),  fn_eval_id);\n  //\n  // Launch the grid solver\n  //\n  // TODO - ERROR CHECKING\n  //\n  String tmp;\n  tmp += fn_eval_id;\n  int status = (*perform_analysis)(tmp.data());\n  //\n  // Insert the evaluation ID into our current set\n  //\n  idSet.insert(fn_eval_id);\n}\n\n\n/// Convenience function for common code between wait and nowait case.\nvoid GridApplicInterface::test_local_evaluations(PRPQueue& prp_queue)\n{\n  //\n  // Iterate through the set of requests\n  //\n  for (ISIter it=idSet.begin(); it!=idSet.end(); it++) {\n    //\n    // Test for existence of the results file(s) corresponding to this eval\n    //\n    int fn_eval_id = *it;\n    bool err_msg_caught = false;\n    const String& file_to_test = fileNameMap[fn_eval_id].second;\n    if (grid_file_test(file_to_test)) {\n      //\n      // File exists; test for complete/valid set of results (an incomplete\n      // set can result from a race condition in which Dakota is reading a\n      // file that a simulator has not finished writing).  Response::read\n      // throws a FileReadException if data is missing/misformatted.\n      //\n      PRPQueueIter queue_it = lookup_by_eval_id(prp_queue, fn_eval_id);\n      if (queue_it == prp_queue.end()) {\n\tCerr << \"Error: failure in queue lookup within GridApplicInterface::\"\n\t     << \"test_local_evaluations().\" << std::endl;\n\tabort_handler(-1);\n      }\n      Response response = queue_it->response(); // shallow copy\n\n      try { read_results_files(response, fn_eval_id); }\n      catch(const FileReadException& fr_except) {\n\t//\n\t// If a FileReadException exception (incomplete file) is caught, set\n\t// err_msg_caught to true so that processing is not performed below.\n\t// The for loop will then cycle through the other active asynch. evals.\n\t// before coming back to the one with the exception.  This should allow\n\t// file writing by a simulator to complete.  100 failures are currently\n\t// allowed for any fn_eval_id before it is assumed that the error is\n\t// real (not race condition related) and aborting.\n\t//\n\terr_msg_caught = true;\n\tIntShMIter map_iter = failCountMap.find(fn_eval_id);\n\tif (map_iter != failCountMap.end()) {\n\t  if (++map_iter->second > 100) {\n\t    Cerr << \"Error: too many failed reads for results file \" \n\t\t << file_to_test\n\t\t << \"\\n       check data format and completeness;\\n       \" \n\t\t << fr_except.what() << std::endl;\n\t    abort_handler(-1);\n\t  }\n\t}\n\telse\n\t  failCountMap[fn_eval_id] = 1;\n#ifdef HAVE_UNISTD_H\n\t//\n\t// Sleep for 1 millisecond\n\t//\n\tusleep(1000);\n#endif // HAVE_UNISTD_H\n#ifdef ASYNCH_DEBUG\n\tCerr << \"Warning: exception caught in reading response file \"\n\t     << file_to_test << \"\\nException = \\\"\" << fr_except.what()\n\t     << \"\\\"\\nException recovery: returning \" << file_to_test\n\t     << \" to processing queue.\\n\";\n#endif\n      }\n      catch(const FunctionEvalFailure& fneval_except) {\n\t//\n\t// If a FunctionEvalFailure (\"fail\" detected in results file) is caught,\n\t// call manage_failure which will either (1) repair the failure and\n\t// populate response, or (2) abort the run.\n\t//\n\tmanage_failure(queue_it->variables(), response.active_set(),\n\t\t       response, fn_eval_id);\n      }\n      //\n      // Process successful results for this asynchronous eval.  Set\n      // the response within the PRPair, remove entry in failCountMap, and\n      // add evaluation id to completion set.\n      //\n      if (!err_msg_caught) {\n\t//queue_it->response(response);                    // not needed\n\t//replace_by_eval_id(prp_queue, fn_eval_id, *queue_it);// not needed\n\tcompletionSet.insert(fn_eval_id);\n\tfailCountMap.erase(fn_eval_id); // if present\n      }\n    }\n  }\n\n#ifdef HAVE_UNISTD_H\n  // reduce processor load from DAKOTA testing if jobs are not finishing\n  if (completionSet.empty()) // no jobs completed in pass through entire set\n    usleep(1000); // 1000 microseconds = 1 millisec\n#endif // HAVE_UNISTD_H\n  // Remove completed jobs from idSet\n  for (ISIter it = completionSet.begin(); it != completionSet.end(); it++)\n    idSet.erase(*it);\n}\n\n\nbool GridApplicInterface::grid_file_test(const String& root_file)\n{\n  // Unix stat utility returns 0 if successful in gathering file statistics,\n  // -1 if there's an error (e.g., the file does not exist).\n  struct stat buf; // see man pages for info available from buf (not used here)\n  size_t num_progs = programNames.length();\n  if ( num_progs > 1 && oFilterName().empty() ) {\n    char prog_num[16];\n\n#ifdef __SUNPRO_CC\n    // Sun Solaris has been observed to have problems with the final results\n    // file existing before previous results files exist (I/O threading?)\n    for (size_t i=0; i<num_progs; i++) {\n      std::sprintf(prog_num, \".%d\", i+1);\n      String tagged_file;\n      tagged_file = root_file + prog_num;\n      if ( stat((char*)tagged_file.data(), &buf) == -1 )\n        return false;\n    }\n    return true;\n#else\n    // Testing all files is usually overkill for sequential analyses.  It's only\n    // really necessary to check the last tagged_file: root_file.[num_progs]\n    std::sprintf(prog_num, \".%d\", num_progs);\n    String tagged_file;\n    tagged_file = root_file + prog_num;\n    return ( stat((char*)tagged_file.data(), &buf) == -1 ) ? false : true;\n#endif // __SUNPRO_CC\n  }\n  else\n    return ( stat((char*)root_file.data(), &buf) == -1 ) ? false : true;\n}\n\n\n#if defined(TESTING_GRID)\n/** sample function prototype for launching grid computing */\nextern \"C\" int start_grid_computing(char *analysis_driver_script, \n\t\t\t\t    char *params_file, char *results_file)\n{ return 0; }\n\n/** sample function prototype for terminating grid computing */\nextern \"C\" int stop_grid_computing()\n{ return 0; }\n\n/** sample function prototype for submitting a grid evaluation */\nextern \"C\" int perform_analysis(char *iteration_num)\n{ spawn_evaluation_to_shell(true); return 0; }\n#endif\n\n} // namespace Dakota\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/NIDRProblemDescDB.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n// Class:        NIDRProblemDescDB\n//- Description: Implementation code for the New IDR ProblemDescDB class.\n//-              It defines the keyword handlers that yacc calls to populate\n//-              the database based on the parsed input.\n//- Owner:       David M. Gay\n//- Checked by:\n//- Version: $Id$\n\n#include \"NIDRProblemDescDB.hpp\"\n#include \"ParallelLibrary.hpp\"\n#include \"WorkdirHelper.hpp\"     // for copy/link file op utilities\n#include \"dakota_data_util.hpp\"\n#include \"pecos_stat_util.hpp\"\n#include <functional>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <boost/algorithm/string.hpp>\n#ifdef HAVE_OPTPP\n#include \"globals.h\"\n#endif\n\n#ifdef DAKOTA_DL_SOLVER\n#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define dlopen(x,y) LoadLibrary(x)\n#else\n#include <dlfcn.h>\n#endif\n#endif /*DAKOTA_DL_SOLVER*/\n\n/// Set input to NIDR via string argument instead of input file\nextern \"C\" void nidr_set_input_string(const char *);\n\nextern \"C\" void nidr_lib_cleanup(void);\n\nnamespace Dakota {\nextern ProblemDescDB *Dak_pddb;\n\nextern \"C\" FILE *nidrin;\nextern \"C\" int nidr_parse(const char*, FILE*);\n\n/// maximum error length is roughly 100 lines at 80 char; using fixed\n/// error length instead of investing in converting to vsnprintf (C++11)\nconst size_t NIDR_MAX_ERROR_LEN = 8192;\n\nint NIDRProblemDescDB::nerr = 0;\nNIDRProblemDescDB* NIDRProblemDescDB::pDDBInstance(NULL);\n\n\nNIDRProblemDescDB::NIDRProblemDescDB(ParallelLibrary& parallel_lib):\n  ProblemDescDB(BaseConstructor(), parallel_lib)\n{}\n\n\nNIDRProblemDescDB::~NIDRProblemDescDB()\n{\n#ifndef NO_NIDR_DYNLIB\n  nidr_lib_cleanup(); // close any explicitly opened shared libraries\n#endif\n}\n\nvoid NIDRProblemDescDB::botch(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nError: \" << msg << \".\\n\";\n\n  abort_handler(PARSE_ERROR);\n}\n\nvoid NIDRProblemDescDB::squawk(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nError: \" << msg << \".\\n\";\n\n  ++nerr;\n}\n\nvoid NIDRProblemDescDB::warn(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nWarning: \" << msg << \".\\n\";\n}\n\n/** Parse the input file using the Input Deck Reader (IDR) parsing system.\n    IDR populates the IDRProblemDescDB object with the input file data. */\nvoid NIDRProblemDescDB::\nderived_parse_inputs(const ProgramOptions& prog_opts)\n{\n  // set the pDDBInstance\n  pDDBInstance = this;\n\n  const String& dakota_input_file = prog_opts.input_file();\n  const String& dakota_input_string = prog_opts.input_string();\n  const String& parser_options = prog_opts.parser_options();\n\n  // Open the dakota input file passed in and \"attach\" it to stdin\n  // (required by nidr_parse)\n  if (!dakota_input_file.empty()) {\n\n    Cout << \"Using Dakota input file '\" << dakota_input_file << \"'\" << std::endl;\n    if (dakota_input_file.size() == 1 && dakota_input_file[0] == '-')\n      nidrin = stdin;\n    else if( !(nidrin = std::fopen(dakota_input_file.c_str(), \"r\")) )\n      botch(\"cannot open \\\"%s\\\"\", dakota_input_file.c_str());\n\n  } \n  else if (!dakota_input_string.empty()) {\n\n    Cout << \"Using provided Dakota input string\" << std::endl;\n    // BMA TODO: output the string contents if verbose\n    nidr_set_input_string(dakota_input_string.c_str());\n\n  }\n  else {\n    Cerr << \"\\nError: NIDR parser called with no input.\" << std::endl;\n    abort_handler(PARSE_ERROR);\n  }\n\n  // // nidr_parse parses the input file and invokes the keyword handlers\n  // // NIDR expects a null pointer if unused, not an empty string\n  // const char* ptr_parse_opts = NULL;\n  // if (!parser_options.empty())\n  //   ptr_parse_opts = parser_options.c_str();\n  FILE *dump_file = NULL;\n  if (nidr_parse(parser_options.c_str(), dump_file)) {\n    //Cerr << \"\\nErrors parsing input file.\" << std::endl;\n    abort_handler(PARSE_ERROR); // allows proper abort in parallel case\n  }\n  if (nerr)\n    abort_handler(PARSE_ERROR);\n  if (parallel_library().command_line_run()) {\n    const char *s;\n    // manage dynamic solver plugins specified in the input\n#ifdef DAKOTA_DL_SOLVER\n    std::list<DataMethod>::iterator\n      Dml  = dataMethodList.begin(),\n      Dmle = dataMethodList.end();\n    DataMethodRep *Dr;\n    const char *s0;\n    char *s1;\n    size_t L;\n\n    for(; Dml != Dmle; ++Dml) {\n      Dr = Dml->dataMethodRep;\n      if ((s0 = Dr->dlDetails) && *(s = s0) > ' ') {\n\twhile(*s > ' ')\n\t  ++s;\n\ts1 = 0;\n\tif (*s) {\n\t  L = s - s0;\n\t  s1 = new char[L+1];\n\t  memcpy(s1, s0, L);\n\t  s1[L] = 0;\n\t  s0 = s1;\n\t}\n\tif (!(Dr->dlLib = dlopen(s0, RTLD_NOW))) {\n#ifndef _WIN32\n\t  const char *se;\n\t  if ((se = dlerror()))\n\t    squawk(\"Cannot open dl_solver \\\"%s\\\":\\n\\t%s\", s0, se);\n\t  else\n#endif\n\t    squawk(\"Cannot open dl_solver \\\"%s\\\"\", s0);\n\t}\n\tif (s1)\n\t  delete[] s1;\n      }\n    }\n#endif\n  }\n}\n\n\nvoid NIDRProblemDescDB::derived_broadcast()\n{ \n  check_variables(&dataVariablesList); \n  check_responses(&dataResponsesList); \n}\n// check_variables() invokes check_variables_node(), either directly or after\n// some manip of interval/histogram/correlation data.  check_variables_node\n// does label processing (?) followed by additional processing in\n// make_variable_defaults() below, which calls BuildLabels().  Need to\n// understand the reason for this step.\n\n// Basic flow should be:\n// (1) db.parse_inputs(file), db.insert_node(), db.set(), or some combination\n//     only on rank 0.\n// (2) perform sanity checking (once) on sets of vector inputs across all kw's,\n//     but for only those vector inputs that have been provided (see 4).\n//     Note: if only sanity checking (no set up), then derived_broadcast() only\n//           as a pre-processor on rank 0.\n// (3) send (minimal) db buffer from rank 0 to all other ranks\n// (4) define (large-scale) vector defaults across all keywords for all ranks,\n//     retaining sanity from 2\n//\n// Q: is 2 really needed, or would it be OK to perform all checks in 4?\n//    Evolution: checks/defaults as part of parsing (original)\n//           --> checks after parsing/mixed input and defaults after DB\n//               send/receive (current)\n//           --> checks/defaults after DB send/receive (proposed new)\n\n\nvoid NIDRProblemDescDB::derived_post_process()\n{\n  // finish processing dataVariableList\n  make_variable_defaults(&dataVariablesList);\n  // finish processing dataResponsesList\n  make_response_defaults(&dataResponsesList);\n}\n\n\n#define Squawk NIDRProblemDescDB::squawk\n#define Warn NIDRProblemDescDB::warn\n\ntypedef unsigned long UL;\n\nstruct Iface_Info {\n  DataInterfaceRep *di;\n  DataInterface *di_handle;\n};\n\nstruct Iface_mp_Rlit {\n  String DataInterfaceRep::* sp;\n  RealVector DataInterfaceRep::* rv;\n  const char *lit;\n};\n\nstruct Iface_mp_ilit {\n  String DataInterfaceRep::* sp;\n  int DataInterfaceRep::* iv;\n  const char *lit;\n};\n\nstruct Iface_mp_lit {\n  String DataInterfaceRep::* sp;\n  const char *lit;\n};\n\nstruct Iface_mp_type {\n  short DataInterfaceRep::* sp;\n  short type;\n};\n\nstruct Iface_mp_utype {\n  unsigned short DataInterfaceRep::* sp;\n  unsigned short type;\n};\n\nstruct Meth_Info {\n  DataMethodRep *dme;\n  DataMethod *dme0;\n};\n\nstruct Method_mp_ilit2 {\n  String DataMethodRep::* sp;\n  int DataMethodRep::* ip;\n  const char *lit;\n};\n\nstruct Method_mp_ilit2z {\n  String DataMethodRep::* sp;\n  size_t DataMethodRep::* ip;\n  const char *lit;\n};\n\nstruct Method_mp_lit {\n  String DataMethodRep::* sp;\n  const char *lit;\n};\n\nstruct Method_mp_litc {\n  String DataMethodRep::* sp;\n  Real DataMethodRep::* rp;\n  const char *lit;\n};\n\nstruct Method_mp_litrv {\n  String DataMethodRep::* sp;\n  RealVector DataMethodRep::* rp;\n  const char *lit;\n};\n\nstruct Method_mp_slit2 {\n  String DataMethodRep::* sp;\n  String DataMethodRep::* sp2;\n  const char *lit;\n};\n\nstruct Method_mp_utype_lit {\n  unsigned short DataMethodRep::* ip;\n  String DataMethodRep::* sp;\n  unsigned short utype;\n};\n\nstruct Method_mp_type {\n  short DataMethodRep::* ip;\n  short type;\n};\n\nstruct Method_mp_utype {\n  unsigned short DataMethodRep::* ip;\n  unsigned short utype;\n};\n\nstruct Mod_Info {\n  DataModelRep *dmo;\n  DataModel *dmo0;\n};\n\nstruct Model_mp_lit {\n  String DataModelRep::* sp;\n  const char *lit;\n};\n\nstruct Model_mp_ord {\n  short DataModelRep::* sp;\n  int ord;\n};\n\nstruct Model_mp_type {\n  short DataModelRep::* sp;\n  short type;\n};\n\nstruct Model_mp_utype {\n  unsigned short DataModelRep::* sp;\n  unsigned short utype;\n};\n\nstruct Resp_Info {\n  DataResponsesRep *dr;\n  DataResponses *dr0;\n};\n\nstruct Resp_mp_lit {\n  String DataResponsesRep::* sp;\n  const char *lit;\n};\n\nstruct Resp_mp_utype {\n  unsigned short DataResponsesRep::* sp;\n  unsigned short utype;\n};\n\n//struct Env_mp_lit {\n//  String DataEnvironmentRep::* sp;\n//  const char *lit;\n//};\n\nstruct Env_mp_utype {\n  unsigned short DataEnvironmentRep::* sp;\n  unsigned short utype;\n};\n\nenum { // kinds of continuous aleatory uncertain variables\n  CAUVar_normal = 0,\n  CAUVar_lognormal = 1,\n  CAUVar_uniform = 2,\n  CAUVar_loguniform = 3,\n  CAUVar_triangular = 4,\n  CAUVar_exponential = 5,\n  CAUVar_beta = 6,\n  CAUVar_gamma = 7,\n  CAUVar_gumbel = 8,\n  CAUVar_frechet = 9,\n  CAUVar_weibull = 10,\n  CAUVar_histogram_bin = 11,\n  CAUVar_Nkinds = 12\t// number of kinds of cauv variables\n};\n\nenum { // kinds of discrete aleatory uncertain integer variables\n  DAUIVar_poisson = 0,\n  DAUIVar_binomial = 1,\n  DAUIVar_negative_binomial = 2,\n  DAUIVar_geometric = 3,\n  DAUIVar_hypergeometric = 4,\n  DAUIVar_histogram_point_int = 5,\n  DAUIVar_Nkinds = 6\t// number of kinds of dauiv variables\n};\n\nenum { // kinds of discrete aleatory uncertain string variables\n  DAUSVar_histogram_point_str = 0,\n  DAUSVar_Nkinds = 1\t// number of kinds of dausv variables\n};\n\nenum { // kinds of discrete aleatory uncertain real variables\n  DAURVar_histogram_point_real = 0,\n  DAURVar_Nkinds = 1\t// number of kinds of daurv variables\n};\n\nenum { // kinds of continuous epistemic uncertain variables\n  CEUVar_interval = 0,\n  CEUVar_Nkinds = 1\t// number of kinds of cauv variables\n};\n\nenum { // kinds of discrete epistemic uncertain integer variables\n  DEUIVar_interval = 0,\n  DEUIVar_set_int = 1,\n  DEUIVar_Nkinds = 2\t// number of kinds of deuiv variables\n};\n\nenum { // kinds of discrete epistemic uncertain string variables\n  DEUSVar_set_str = 0,\n  DEUSVar_Nkinds = 1\t// number of kinds of deusv variables\n};\n\nenum { // kinds of discrete epistemic uncertain real variables\n  DEURVar_set_real = 0,\n  DEURVar_Nkinds = 1\t// number of kinds of deurv variables\n};\n\nenum { // kinds of discrete set variables\n  DiscSetVar_design_set_int = 0,\n  DiscSetVar_design_set_str = 1,\n  DiscSetVar_design_set_real = 2,\n  DiscSetVar_state_set_int = 3,\n  DiscSetVar_state_set_str = 4,\n  DiscSetVar_state_set_real = 5,\n  DiscSetVar_Nkinds = 6\t// number of kinds of discrete set variables\n};\n\nstruct VarLabel {\n  size_t n;\n  const char **s;\n};\n\nstruct Var_Info {\n  DataVariablesRep *dv;\n  DataVariables    *dv_handle;\n  VarLabel  CAUv[ CAUVar_Nkinds],  CEUv[ CEUVar_Nkinds];\n  VarLabel DAUIv[DAUIVar_Nkinds], DAUSv[DAUSVar_Nkinds], DAURv[DAURVar_Nkinds];\n  VarLabel DEUIv[DEUIVar_Nkinds], DEUSv[DEUSVar_Nkinds], DEURv[DEURVar_Nkinds];\n  IntArray   *nddsi, *nddss, *nddsr, *nCI, *nDI, *nhbp,\n             *nhpip, *nhpsp, *nhprp, \n             *ndusi, *nduss, *ndusr,\n             *ndssi, *ndsss, *ndssr;\n             \n  RealVector *ddsr, *CIlb, *CIub, *CIp, *DIp, *DSIp, *DSSp, *DSRp, *dusr,\n             *hba, *hbo, *hbc, \n             *hpic, *hpsc, *hpra, *hprc,\n             *ucm, *dssr;\n  IntVector  *ddsi, *DIlb, *DIub, *hpia, *dusi, *dssi, *ddsia, *ddssa, *ddsra;\n  StringArray *ddss, *hpsa, *duss, *dsss;\n};\n\nstruct Var_check\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n};\n\n/// structure for verifying bounds and initial point for real-valued vars\nstruct Var_rcheck\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n  RealVector  DataVariablesRep::* L;   // when static, initialized to NULL\n  RealVector  DataVariablesRep::* U;   // when static, initialized to NULL\n  RealVector  DataVariablesRep::* V;   // when static, initialized to NULL\n  StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n};\n\n/// structure for verifying bounds and initial point for string-valued vars\n// struct Var_scheck\n// {\n//   const char *name;\n//   size_t DataVariablesRep::* n;\n//   void (*vgen)(DataVariablesRep*, size_t);\n//   StringArray DataVariablesRep::* L;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* U;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* V;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n// };\n\n/// structure for verifying bounds and initial point for integer-valued vars\nstruct Var_icheck\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n  IntVector   DataVariablesRep::* L;   // when static, initialized to NULL\n  IntVector   DataVariablesRep::* U;   // when static, initialized to NULL\n  IntVector   DataVariablesRep::* V;   // when static, initialized to NULL\n  StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n};\n\nstruct Var_uinfo {\n  const char *lbl;\n  const char *vkind;\n  size_t DataVariablesRep::* n;\n  void(*vchk)(DataVariablesRep*, size_t, Var_Info*);\n};\n\nstruct Var_brv {\n  RealVector DataVariablesRep::* rv;\n  Real b;\n};\n\nstruct Var_biv {\n  IntVector DataVariablesRep::* iv;\n  int b;\n};\n\nstruct Var_mp_type {\n  short DataVariablesRep::* sp;\n  short type;\n};\n\nvoid NIDRProblemDescDB::\niface_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(Real DataInterfaceRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\niface_Rlit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  Iface_mp_Rlit *R = (Iface_mp_Rlit*)v;\n  Real *r;\n  RealVector *rv;\n  size_t i, n;\n\n  di->*R->sp = R->lit;\n  rv = &(di->*R->rv);\n  n = val->n;\n  rv->sizeUninitialized(n);\n  r = val->r;\n  for(i = 0; i < n; ++i)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\niface_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(bool DataInterfaceRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\niface_ilit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  Iface_mp_ilit *I = (Iface_mp_ilit*)v;\n\n  di->*I->sp = I->lit;\n  di->*I->iv = *val->i;\n}\n\nvoid NIDRProblemDescDB::\niface_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Iface_Info**)g)->di->**(int DataInterfaceRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\niface_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->*((Iface_mp_lit*)v)->sp = ((Iface_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\niface_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Iface_Info *ii;\n\n  if (!(ii = new Iface_Info))\n  Botch:\t\tbotch(\"new failure in iface_start\");\n  if (!(ii->di_handle = new DataInterface))\n    goto Botch;\n  ii->di = ii->di_handle->dataIfaceRep;\n  *g = (void*)ii;\n}\n\nvoid NIDRProblemDescDB::\niface_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(bool DataInterfaceRep::**)v = true;\n}\n\n\n#ifdef DEBUG_LEGACY_WORKDIR\n\nextern const char** arg_list_adjust(const char **, void **);\n\n/*\n *  not_executable(const char *driver_name) checks whether driver_name is an \n *  executable file appearing somewhere in $PATH and returns 0 if so,\n *  1 if not found, 2 if found but not executable.\n */\nint not_executable(const char *driver_name, const char *tdir)\n{\n  static const char *p0;\n  struct stat sb;\n  const char *p;\n  const char *p1;\n  char *b, buf[2048];\n  const char *a2[2], **al;\n  int rc, sv;\n  size_t clen, dlen, plen, tlen;\n  void *a0;\n  std::string cwd = boost::filesystem::current_path().string();\n\n#ifdef _WIN32\n  char dbuf[128];\n#else\n  static uid_t myuid;\n  static gid_t mygid;\n#endif\n\n  /* allow shell assignments and quotes around executable names */\n  /* that may involve blanks */\n  a2[0] = driver_name;\n  a2[1] = 0;\n  al = arg_list_adjust(a2,&a0);\n  driver_name = al[0];\n\n  rc = 0;\n  if (!p0) {\n    p0 = std::getenv(\"PATH\");\n#ifdef _WIN32\n    if (!p0)\n      p0 = std::getenv(\"Path\");\n#else\n    myuid = geteuid();\n    mygid = getegid();\n#endif\n    if (p0)\n      while(*p0 <= ' ' && *p0)\n\t++p0;\n    else\n      p0 = \"\";\n  }\n#ifdef _WIN32\n  // make sure we have a suitable suffix\n  if ((p = strrchr(driver_name, '.'))) {\n    if (std::strlen(++p) != 3)\n      p = 0;\n    else {\n      for(b = dbuf; *p; ++b, ++p)\n\t*b = tolower(*p);\n      *b = 0;\n      if (std::strcmp(dbuf, \"exe\") && std::strcmp(dbuf, \"bat\") &&\n\t  std::strcmp(dbuf, \"cmd\"))\n\tp = 0;\n    }\n  }\n  if (!p) {\n    dlen = std::strlen(driver_name);\n    if (dlen + 5 > sizeof(dbuf)) {\n      rc = 1;\n      goto ret;\n    }\n    std::strcpy(dbuf, driver_name);\n    std::strcpy(dbuf+dlen, \".exe\");\n    driver_name = dbuf;\n  }\n\n  // . is always implicitly in $Path under MS Windows; check it now\n  if (!stat(driver_name, &sb))\n    goto ret;\n#endif\n\n  cwd = boost::filesystem::current_path().string();\n  clen = cwd.size();\n  dlen = std::strlen(driver_name);\n  tlen = std::strlen(tdir);\n  rc = 1;\n  p = p0;\n  if (std::strchr(driver_name, '/')\n#ifdef _WIN32\n      || std::strchr(driver_name, '\\\\')\n      || (dlen > 2 && driver_name[1] == ':')\n#endif\n      )\n    p = \"\";\n\n  else if (clen + dlen + 2 < sizeof(buf)) {\n    std::memcpy(buf,cwd.c_str(),clen);\n    buf[clen] = '/';\n    std::strcpy(buf+clen+1, driver_name);\n    sv = stat(buf,&sb);\n    if (sv == 0)\n      goto stat_check;\n  }\n  else if (tdir && *tdir && tlen + dlen + 2 < sizeof(buf)) {\n    std::memcpy(buf,tdir,tlen);\n    buf[tlen] = '/';\n    std::strcpy(buf+tlen+1, driver_name);\n    sv = stat(buf,&sb);\n    if (sv == 0)\n      goto stat_check;\n  }\n  for(;;) {\n    for(p1 = p;; ++p1) {\n      switch(*p1) {\n      case 0:\n#ifdef _WIN32\n      case ';':\n#else\n      case ':':\n#endif\n\tgoto break2;\n      }\n    }\n  break2:\n    if (p1 == p || (p1 == p + 1 && *p == '.'))\n      sv = stat(driver_name, &sb);\n    else {\n      plen = p1 - p;\n      while(plen && p[plen-1] <= ' ')\n\t--plen;\n      if (plen + dlen + 2 > sizeof(buf))\n\tsv = 1;\n      else {\n\tstd::strncpy(buf,p,plen);\n\tb = buf + plen;\n\t*b++ = '/';\n\tstd::strcpy(b, driver_name);\n\tsv = stat(buf, &sb);\n      }\n    }\n    if (!sv) {\n    stat_check:\n#ifdef __CYGWIN__\n      rc = 2;\n      if (sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\trc = 0;\n\tgoto ret;\n      }\n#elif defined(_WIN32) || defined(_WIN64)\n      rc = 0;\n      goto ret;\n#else\n      rc = 2;\n      if (sb.st_uid == myuid) {\n\tif (sb.st_mode & S_IXUSR)\n\t  goto ret0;\n      }\n      else if (sb.st_gid == mygid) {\n\tif (sb.st_mode & S_IXGRP)\n\t  goto ret0;\n      }\n      else if (sb.st_mode & S_IXOTH) {\n      ret0:                          rc = 0;\n\tgoto ret;\n      }\n#endif\n    }\n    if (p1 == 0)\n      goto ret;\n    else if (!*p1)\n      break;\n    for(p = p1 + 1; *p <= ' '; ++p)\n      while(*p <= ' ' && *p)\n\tif (!*p)\n\t  goto ret;\n  }\n ret:\n  if (a0)\n    std::free(a0);\n  return rc;\n}\n\n#endif  // DEBUG_LEGACY_WORKDIR\n\n\nvoid NIDRProblemDescDB::\niface_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Iface_Info *ii = *(Iface_Info**)g;\n  DataInterfaceRep *di = ii->di;\n\n  StringArray& analysis_drivers = di->analysisDrivers;\n  int nd = analysis_drivers.size();\n  int ac = di->asynchLocalAnalysisConcurrency;\n  int ec = di->asynchLocalEvalConcurrency;\n\n  if (di->algebraicMappings == \"\" && nd == 0)\n    squawk(\"interface specification must provide algebraic_mappings,\\n\\t\"\n\t   \"analysis_drivers, or both\");\n  if (nd > 0 && di->asynchLocalAnalysisConcurrency > nd) {\n    warn(\"analysis_concurrency specification greater than length of\\n\\t\"\n\t \"analysis_drivers list.  Truncating analysis_concurrency to %d\",nd);\n    di->asynchLocalAnalysisConcurrency = nd;\n  }\n  if (ec && ec < 2 && ac && ac < 2) {\n    warn(\"asynchronous option not required for evaluation and analysis.\\n\\t\"\n\t \"Concurrency limited to %d and %d.\\n\\t\"\n\t \"Synchronous operations will be used\", ec, ac);\n    di->interfaceSynchronization = SYNCHRONOUS_INTERFACE;\n  }\n\n  // validate each of the analysis_drivers\n  if ( di->interfaceType == SYSTEM_INTERFACE || \n       di->interfaceType == FORK_INTERFACE )\n    for(size_t i = 0; i < nd; ++i) {\n      // trim any leading whitespace from the driver, in place\n      boost::trim(analysis_drivers[i]);\n      check_driver(analysis_drivers[i], di->linkFiles, di->copyFiles);\n    }\n\n  if (!di->workDir.empty()) {\n\n#if defined(_WIN32) || defined(_WIN64)\n    // Note: some Windows versions may support symlinks, if files and\n    // directories are managed separately.\n    if (!di->linkFiles.empty()) {\n      Cerr << \"\\nError: link_files not supported on Windows; use copy_files.\"\n\t   << std::endl;\n      ++nerr;\n    }\n#endif\n\n  // Check to make sure none of the linkFiles nor copyFiles are the\n  // same as the workDir (could combine into single loop with above)\n    if (WorkdirHelper::check_equivalent_dest(di->linkFiles, di->workDir) ||\n\tWorkdirHelper::check_equivalent_dest(di->copyFiles, di->workDir))\n      ++nerr;\n  }\n\n  pDDBInstance->dataInterfaceList.push_back(*ii->di_handle);\n  delete ii->di_handle;\n  delete ii;\n}\n\n/** returns 1 if not found, 2 if found, but not executable, 0 if found (no error) in case we want to return to error on not found... */\nint NIDRProblemDescDB::check_driver(const String& an_driver,\n\t\t\t\t    const StringArray& link_files,\n\t\t\t\t    const StringArray& copy_files)\n{\n  StringArray driver_and_args = WorkdirHelper::tokenize_driver(an_driver);\n  if (driver_and_args.size() == 0)\n    squawk(\"Empty analysis_driver string\");\n  else {\n\n    // the executable program name to check\n    const String& program_name = driver_and_args[0];\n\n    if (program_name.empty())\n      squawk(\"Empty analysis_driver string\");\n    else {\n\n      // Drivers can be found in $PATH:WORKDIR(.):RUNDIR\n      // Therefore have to check PATH, link/copy files, PWD\n\n      // check PATH and RUNDIR (since . is already on the search path)\n      bfs::path driver_found = WorkdirHelper::which(program_name);\n      if ( !driver_found.empty() )\n\treturn 0;\n\n      // check against link/copy files that will appear in workdir\n\n      // TODO: if they are specified with ./subdirA/subdir1/foo.sh\n      // would have been found above which might be an error if subdir\n      // is not linked or copied file\n\n      if (WorkdirHelper::find_driver(link_files, program_name))\n\treturn 0;\n\n      if (WorkdirHelper::find_driver(copy_files, program_name))\n\treturn 0;\n\n      const char* s = program_name.c_str();\n      warn(\"analysis driver \\\"%s\\\" %s\", s, \"not found\");\n\n      // BMA TODO: check whether the driver is executable and if not, return 2\n      // : \"exists but is not executable\");\n\n    }\n\n  }\n\n  return 1;\n}\n\nvoid NIDRProblemDescDB::\niface_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(String DataInterfaceRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\niface_str2D(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  String2DArray *sa2 = &(di->**(String2DArray DataInterfaceRep::**)v);\n  StringArray *sa;\n  const char **s = val->s;\n  size_t i, j, k, n, nc, nd;\n\n  // This is for analysisComponents -- only String2DArray in a DataInterfaceRep\n\n  nd = di->analysisDrivers.size();\n  n = val->n;\n  if (nd <= 0)\n    botch(\"num_drivers = %d in iface_str2D\", (int)nd);\n  if (n % nd) {\n    squawk(\"number of analysis_components not evenly divisible \"\n\t   \"by number of analysis_drivers\");\n    return;\n  }\n  nc = n / nd;\n  sa2->resize(nd);\n  for(i = k = 0; i < nd; i++) {\n    sa = &((*sa2)[i]);\n    sa->resize(nc);\n    for(j = 0; j < nc; ++j, ++k)\n      (*sa)[j] = s[k];\n  }\n}\n\nvoid NIDRProblemDescDB::\niface_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(Iface_Info**)g)->di->**(StringArray DataInterfaceRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\niface_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->*((Iface_mp_type*)v)->sp = ((Iface_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Real01(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t < 0. || t > 1.)\n    botch(\"%s must be in [0, 1]\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  RealVector DataMethodRep::* sa = *(RealVector DataMethodRep::**)v;\n  Real *r = val->r;\n  size_t i, n = val->n;\n\n  (dm->*sa).sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (dm->*sa)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_RealLlit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r;\n  RealVector *rv = &(dm->*((Method_mp_litrv*)v)->rp);\n  size_t i, n;\n  dm->*((Method_mp_litrv*)v)->sp = ((Method_mp_litrv*)v)->lit;\n  r = val->r;\n  n = val->n;\n  rv->resize(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_Realp(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t <= 0.)\n    botch(\"%s must be positive\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Realz(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t < 0.)\n    botch(\"%s must be nonnegative\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\n// MSE: This function just sets two values for one keyword.\nvoid NIDRProblemDescDB::\nmethod_piecewise(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->expansionType  = STD_UNIFORM_U;\n  dm->piecewiseBasis = true;\n}\n\nvoid NIDRProblemDescDB::\nmethod_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(bool DataMethodRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nmethod_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  int *z = val->i;\n  IntVector *iv = &(dm->**(IntVector DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  iv->resize(n);\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_ilit2(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->*((Method_mp_ilit2*)v)->sp = ((Method_mp_ilit2*)v)->lit;\n  dm->*((Method_mp_ilit2*)v)->ip = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ilit2p(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->*((Method_mp_ilit2z*)v)->sp = ((Method_mp_ilit2z*)v)->lit;\n  if ((dm->*((Method_mp_ilit2z*)v)->ip = *val->i) <= 0)\n    botch(\"%s must be positive\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_lit*)v)->sp = ((Method_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litc(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  if (dm->*((Method_mp_litc*)v)->rp > 0.)\n    dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litp(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real t = *val->r;\n  if (t <= 0.)\n    botch(\"%s must be positive\",keyname);\n  dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n  dm->*((Method_mp_litc*)v)->rp = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litz(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real t = *val->r;\n  if (t < 0.)\n    botch(\"%s must be nonnegative\",keyname);\n  if ((dm->*((Method_mp_litc*)v)->rp = t) == 0.)\n    dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_nnint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_sizet(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(size_t DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_num_resplevs(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  RealVector *ra = &(*rva)[0];\n  int m, *z = val->i;\n  size_t i, i1, j, je, k, n;\n\n  n = val->n;\n  for(i = k = 0; i < n; ++i)\n    k += z[i];\n  if (ra->length() != (int)k)\n    botch(\"number of %s = %u does not match\\n\"\n\t  \"%s specification of %u response levels\",\n\t  keyname+4, (Uint)ra->length(), keyname, (Uint)k);\n  r = new Real[k];\n  for(i = 0; i < k; i++)\n    r[i] = (*ra)[i];\n  (*rva).resize(n);\n  for(i = j = je = 0; i < n; i++) {\n    m = z[i];\n    (*rva)[i].resize(m);\n    ra = &(*rva)[i];\n    for(i1 = 0, je += m; j < je; ++i1, ++j)\n      (*ra)[i1] = r[j];\n  }\n  delete[] r;\n}\n\nvoid NIDRProblemDescDB::\nmethod_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_pintz(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(size_t DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_resplevs(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r = val->r;\n  RealVector *ra;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  (*rva).resize(1);\n  ra = &(*rva)[0];\n  ra->resize(n);\n  for(i = 0; i < n; ++i)\n    (*ra)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_resplevs01(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r = val->r, t;\n  RealVector *ra;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  (*rva).resize(1);\n  ra = &(*rva)[0];\n  ra->resize(n);\n  for(i = 0; i < n; ++i) {\n    (*ra)[i] = t = r[i];\n    if (t < 0. || t > 1.)\n      botch(\"%s must be between 0 and 1\", keyname);\n  }\n}\n\nvoid NIDRProblemDescDB::\nmethod_shint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(short DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ushint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(unsigned short DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_usharray(const char *keyname, Values *val, void **g, void *v)\n{\n  UShortArray *usa\n    = &((*(Meth_Info**)g)->dme->**(UShortArray DataMethodRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  usa->resize(n);\n  for (i=0; i<n; ++i)\n    if (z[i] >= 0)\n      (*usa)[i] = z[i];\n    else\n      botch(\"%s must have non-negative values\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_szarray(const char *keyname, Values *val, void **g, void *v)\n{\n  SizetArray *sza\n    = &((*(Meth_Info**)g)->dme->**(SizetArray DataMethodRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  sza->resize(n);\n  for (i=0; i<n; ++i)\n    if (z[i] >= 0)\n      (*sza)[i] = z[i];\n    else\n      botch(\"%s must have non-negative values\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_slit2(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n\n  dm->*((Method_mp_slit2*)v)->sp  = ((Method_mp_slit2*)v)->lit;\n  dm->*((Method_mp_slit2*)v)->sp2 = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_utype_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    = ((Method_mp_utype*)v)->utype;\n  dm->*((Method_mp_utype_lit*)v)->sp = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Meth_Info *mi;\n\n  if (!(mi = new Meth_Info))\n  Botch:\t\tbotch(\"new failure in method_start\");\n  if (!(mi->dme0 = new DataMethod))\n    goto Botch;\n  mi->dme = mi->dme0->dataMethodRep;\n  *g = (void*)mi;\n}\n\nstatic void\nscale_chk(StringArray &ST, RealVector &S, const char *what, const char **univ)\n{\n  const char *s, **u;\n  size_t i, n, nbad, vseen;\n\n  n = ST.size();\n  for(i = nbad = vseen = 0; i < n; ++i) {\n    s = ST[i].data();\n    if (!strcmp(s,\"value\")) {\n      ++vseen;\n      goto break2;\n    }\n    for(u = univ; *u; ++u)\n      if (!strcmp(s,*u)) {\n\tgoto break2;\n      }\n    NIDRProblemDescDB::squawk(\"\\\"%s\\\" cannot appear in %s_scale_types\",\n\t\t\t      s, what);\n    ++nbad;\n  break2:\t;\n  }\n  if (vseen && S.length() <= 0)\n    NIDRProblemDescDB::squawk(\n      \"\\\"value\\\" in %s_scale_types requires at least one value for %s_scales\",\n      what, what);\n}\n\nstatic const char *aln_scaletypes[] = { \"auto\", \"log\", \"none\", 0 };\n\nvoid NIDRProblemDescDB::\nmethod_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  static const char *mr_scaletypes[] = { \"auto\", \"none\", 0 };\n  Meth_Info *mi = *(Meth_Info**)g;\n  DataMethodRep *dm = mi->dme;\n  scale_chk(dm->linearIneqScaleTypes, dm->linearIneqScales,\n\t    \"linear_inequality\", mr_scaletypes);\n  scale_chk(dm->linearEqScaleTypes, dm->linearEqScales,\n\t    \"linear_equality\", mr_scaletypes);\n  pDDBInstance->dataMethodList.push_back(*mi->dme0);\n  delete mi->dme0;\n  delete mi;\n}\n\nvoid NIDRProblemDescDB::\nmethod_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(String DataMethodRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa = &((*(Meth_Info**)g)->dme->**(StringArray DataMethodRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(bool DataMethodRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nmethod_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_type*)v)->ip\n    = ((Method_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmethod_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    = ((Method_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmethod_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    |= ((Method_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(Real DataModelRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\nmodel_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  Real *r = val->r;\n  RealVector *rdv = &((*(Mod_Info**)g)->dmo->**(RealVector DataModelRep::**)v);\n  size_t i, n = val->n;\n\n  rdv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rdv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmodel_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(bool DataModelRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nmodel_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(int DataModelRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmodel_intsetm1(const char *keyname, Values *val, void **g, void *v)\n{\n  IntSet *is = &((*(Mod_Info**)g)->dmo->**(IntSet DataModelRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  for(i = 0; i < n; i++)\n    is->insert(z[i] - 1); // model converts ids -> indices\n}\n\nvoid NIDRProblemDescDB::\nmodel_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_lit*)v)->sp = ((Model_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmodel_order(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_ord*)v)->sp = ((Model_mp_ord*)v)->ord;\n}\n\nvoid NIDRProblemDescDB::\nmodel_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Mod_Info**)g)->dmo->**(int DataModelRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmodel_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_type*)v)->sp = ((Model_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmodel_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_utype*)v)->sp = \n    ((Model_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_utype*)v)->sp |= \n    ((Model_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_shint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(short DataModelRep::**)v = (short)*val->i;\n}\n\nvoid NIDRProblemDescDB::\nmodel_start(const char *keyname, Values *val, void **g, void *v)\n{\n  DataModelRep *dm;\n  Mod_Info *mi;\n\n  if (!(mi = new Mod_Info))\n  Botch:\t\tbotch(\"new failure in model_start\");\n  if (!(mi->dmo0 = new DataModel))\n    goto Botch;\n  dm = mi->dmo = mi->dmo0->dataModelRep;\n  *g = (void*)mi;\n}\n\nvoid NIDRProblemDescDB::\nmodel_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Mod_Info *mi = *(Mod_Info**)g;\n  pDDBInstance->dataModelList.push_back(*mi->dmo0);\n  delete mi->dmo0;\n  delete mi;\n}\n\nvoid NIDRProblemDescDB::\nmodel_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(String DataModelRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmodel_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  DataModelRep *dm = (*(Mod_Info**)g)->dmo;\n  StringArray DataModelRep::* sa = *(StringArray DataModelRep::**)v;\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  (dm->*sa).resize(n);\n  for(i = 0; i < n; i++)\n    (dm->*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmodel_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(bool DataModelRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nresp_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  Real *r = val->r;\n  RealVector *rv = &((*(Resp_Info**)g)->dr->**(RealVector DataResponsesRep::**)v);\n  size_t i, n = val->n;\n\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_RealL(const char *keyname, Values *val, void **g, void *v)\n{\n  NIDRProblemDescDB::resp_RealDL(keyname, val, g, v);\n}\n\nvoid NIDRProblemDescDB::\nresp_intset(const char *keyname, Values *val, void **g, void *v)\n{\n  IntSet *is = &((*(Resp_Info**)g)->dr->**(IntSet DataResponsesRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  for (i=0; i<n; ++i)\n    is->insert(z[i]);\n}\n\nvoid NIDRProblemDescDB::\nresp_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  DataResponsesRep *dr = (*(Resp_Info**)g)->dr;\n  IntVector *iv = &(dr->**(IntVector DataResponsesRep::**)v);\n  size_t i, n = val->n;\n  iv->sizeUninitialized(n);\n\n  int *z = val->i;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_lit*)v)->sp = ((Resp_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nresp_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_utype*)v)->sp\n    = ((Resp_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nresp_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_utype*)v)->sp\n    |= ((Resp_mp_utype*)v)->utype;\n}\n\n\nvoid NIDRProblemDescDB::\nresp_sizet(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Resp_Info**)g)->dr->**(size_t DataResponsesRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nresp_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Resp_Info *ri;\n\n  if (!(ri = new Resp_Info))\n  Botch:\t\tbotch(\"new failure in resp_start\");\n  if (!(ri->dr0 = new DataResponses))\n    goto Botch;\n  ri->dr = ri->dr0->dataRespRep;\n  *g = (void*)ri;\n}\n\nstatic void\nBuildLabels(StringArray *sa, size_t nsa, size_t n1, size_t n2, const char *stub)\n{\n  char buf[64];\n  size_t i, n0;\n  if (nsa)\n    sa->resize(nsa);\n  i = n0 = n1;\n  while(n1 < n2) {\n    std::sprintf(buf, \"%s%lu\", stub, (UL)(++n1 - n0));\n    (*sa)[i++] = buf;\n  }\n}\n\nstatic int mixed_check(IntSet *S, int n, IntArray *iv, const char *what)\n{\n  int nbad, j;\n\n  nbad = 0;\n  for(ISCIter it = S->begin(), ite = S->end(); it != ite; ++it) {\n    j = *it;\n    if (j < 1 || j > n) {\n      if (!nbad++)\n\tSquawk(\"%s values must be between 1 and %d\", what, n);\n    }\n    else {\n      ++(iv->operator[](j-1));\n    }\n  }\n  return nbad;\n}\n\nstatic void\nmixed_check2(size_t n, IntArray *iv, const char *what)\n{\n  int j;\n  size_t i;\n\n  for(i = 0; i < n; ) {\n    j = (*iv)[i++];\n    if (j == 0)\n      Squawk(\"Function %lu missing from mixed %s lists\", (UL)i);\n    else if (j > 1)\n      Squawk(\"Function %lu replicated in mixed %s lists\", (UL)i);\n  }\n}\n\nvoid NIDRProblemDescDB::\nresp_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  size_t k, n;\n  static const char *osc[] = { \"log\", \"none\", 0 };\n  Resp_Info *ri = *(Resp_Info**)g;\n  DataResponsesRep *dr = ri->dr;\n  scale_chk(dr->primaryRespFnScaleTypes, dr->primaryRespFnScales,\n\t    dr->numLeastSqTerms ? \"least_squares_term\" : \"objective_function\", osc);\n  scale_chk(dr->nonlinearIneqScaleTypes, dr->nonlinearIneqScales,\n\t    \"nonlinear_inequality\", aln_scaletypes);\n  scale_chk(dr->nonlinearEqScaleTypes, dr->nonlinearEqScales,\n\t    \"nonlinear_equality\", aln_scaletypes);\n  if ( dr->primaryRespFnWeights.length() > 0 && dr->varianceType.size() > 0 ) {\n    squawk(\"Specify calibration weights or experimental errors, not both.\");\n  }\n  if ((n = dr->responseLabels.size()) > 0) {\n    if (!(k = dr->numResponseFunctions)) {\n      if (!(k = dr->numObjectiveFunctions))\n\tk = dr->numLeastSqTerms;\n      k += dr->numNonlinearIneqConstraints + dr->numNonlinearEqConstraints;\n    }\n    if (n != k)\n      squawk(\"Expected %ld response descriptors but found %ld\",\n\t     (long)k, (long) n);\n  }\n  pDDBInstance->dataResponsesList.push_back(*ri->dr0);\n  delete ri->dr0;\n  delete ri;\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_responses(std::list<DataResponses>* drl)\n{\n  // TO DO: move Schk from below?\n\n  // validate descriptors. The string arrays are empty unless the user\n  // explicitly set descriptors.\n  std::list<DataResponses>::iterator It = drl->begin(), Ite = drl->end();\n  for(; It != Ite; ++It) {\n    const DataResponsesRep* drr = It->data_rep();\n    check_descriptors(drr->responseLabels);\n  }\n}\n\n\nvoid NIDRProblemDescDB::\nmake_response_defaults(std::list<DataResponses>* drl)\n{\n  IntArray *iv;\n  StringArray *rl;\n  int ni;\n  size_t i, n, n1, nf, no, nrl;\n  struct RespStr_chk {\n    const char *what;\n    size_t DataResponsesRep::* n;\n    StringArray DataResponsesRep::* sa;\n  } *sc;\n  struct RespDVec_chk {\n    const char *what;\n    size_t DataResponsesRep::* n;\n    RealVector DataResponsesRep::* rv;\n  } *rdvc;\n#define Schk(a,b,c) {#a,&DataResponsesRep::b, &DataResponsesRep::c}\n  static RespStr_chk Str_chk[] = {  // for StringArray checking\n    Schk(least_squares_term_scale_types,numLeastSqTerms,primaryRespFnScaleTypes),\n    Schk(nonlinear_equality_scale_types,numNonlinearEqConstraints,nonlinearEqScaleTypes),\n    Schk(nonlinear_inequality_scale_types,numNonlinearIneqConstraints,nonlinearIneqScaleTypes),\n    Schk(objective_function_scale_types,numObjectiveFunctions,primaryRespFnScaleTypes)\n  };\n  static RespDVec_chk RespVec_chk_Bound[] = {// Bounds:  length must be right\n    Schk(least_squares_weights,numLeastSqTerms,primaryRespFnWeights),\n    Schk(multi_objective_weights,numObjectiveFunctions,primaryRespFnWeights),\n    Schk(nonlinear_equality_targets,numNonlinearEqConstraints,nonlinearEqTargets),\n    Schk(nonlinear_inequality_lower_bounds,numNonlinearIneqConstraints,nonlinearIneqLowerBnds),\n    Schk(nonlinear_inequality_upper_bounds,numNonlinearIneqConstraints,nonlinearIneqUpperBnds)\n  };\n  static RespDVec_chk RespVec_chk_Scale[] = {// Scales:  length must be right\n    Schk(least_squares_term_scales,numLeastSqTerms,primaryRespFnScales),\n    Schk(nonlinear_equality_scales,numNonlinearEqConstraints,nonlinearEqScales),\n    Schk(nonlinear_inequality_scales,numNonlinearIneqConstraints,nonlinearIneqScales),\n    Schk(objective_function_scales,numObjectiveFunctions,primaryRespFnScales)\n  };\n#undef Schk\n#define Numberof(x) sizeof(x)/sizeof(x[0])\n\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n  std::list<DataResponses>::iterator It = drl->begin(), Ite = drl->end();\n  for(; It != Ite; It++) {\n\n    DataResponsesRep *dr = It->dataRespRep;\n\n    for(sc = Str_chk, i = 0; i < Numberof(Str_chk); ++sc, ++i)\n      if ((n1 = dr->*sc->n) && (n = (dr->*sc->sa).size()) > 0\n\t  && n != n1 && n != 1)\n\tsquawk(\"%s must have length 1 or %lu, not %lu\",\n\t       sc->what, (UL)n1, (UL)n);\n    rl = &dr->responseLabels;\n    nrl = rl->size();\n    no = dr->numObjectiveFunctions;\n    if ((n = dr->numLeastSqTerms)) {\n      nf = n + dr->numNonlinearEqConstraints + dr->numNonlinearIneqConstraints;\n      if (!nrl) {\n\tBuildLabels(rl, nf, 0, n, \"least_sq_term_\");\n\tn1 = n + dr->numNonlinearIneqConstraints;\n\tBuildLabels(rl, 0, n, n1, \"nln_ineq_con_\");\n\tBuildLabels(rl, 0, n1, nf, \"nln_eq_con_\");\n      }\n    }\n    else if ((nf = no + dr->numNonlinearEqConstraints + dr->numNonlinearIneqConstraints)) {\n      if (!nrl) {\n\trl->resize(nf);\n\tif (no == 1)\n\t  (*rl)[0] = \"obj_fn\";\n\telse\n\t  BuildLabels(rl, 0, 0, no, \"obj_fn_\");\n\tn1 = no + dr->numNonlinearIneqConstraints;\n\tBuildLabels(rl, 0, no, n1, \"nln_ineq_con_\");\n\tBuildLabels(rl, 0, n1, nf, \"nln_eq_con_\");\n      }\n    }\n    else if ((nf = dr->numResponseFunctions)) {\n      if (!nrl)\n\tBuildLabels(rl, nf, 0, nf, \"response_fn_\");\n    }\n    for(rdvc = RespVec_chk_Bound, i = 0; i < Numberof(RespVec_chk_Bound); ++rdvc, ++i)\n      if ((n1 = dr->*rdvc->n) && (n = (dr->*rdvc->rv).length()) && n != n1)\n\tsquawk(\"%s needs %lu elements, not %lu\",\n\t       rdvc->what, (UL)(dr->*rdvc->n), (UL)n);\n    for(rdvc = RespVec_chk_Scale, i = 0; i < Numberof(RespVec_chk_Scale); ++rdvc, ++i)\n      if ((n1 = dr->*rdvc->n) && (n = (dr->*rdvc->rv).length())\n\t  && n != n1 && n != 1)\n\tsquawk(\"%s needs %lu elements (or just one), not %lu\",\n\t       rdvc->what, (UL)n1, (UL)n);\n    if (dr->methodSource == \"vendor\" && dr->fdGradStepSize.length() > 1)\n      squawk(\"vendor numerical gradients only support a single fd_gradient_step_size\");\n\n    ni = (int)nf;\n    if (dr->gradientType == \"mixed\") {\n      iv = new IntArray;\n      //iv->resize(nf);\n      iv->assign(nf, 0);\n      if (!(mixed_check(&dr->idAnalyticGrads, ni, iv, \"id_analytic_gradients\")\n\t    + mixed_check(&dr->idNumericalGrads, ni, iv, \"id_numerical_gradients\")))\n\tmixed_check2(nf, iv, \"gradient\");\n      delete iv;\n    }\n    if ((n = dr->numNonlinearEqConstraints) > 0\n\t&& dr->nonlinearEqTargets.length() == 0) {\n      dr->nonlinearEqTargets.sizeUninitialized(n);\n      dr->nonlinearEqTargets = 0.;\n    }\n    if ((n = dr->numNonlinearIneqConstraints) > 0) {\n      if (dr->nonlinearIneqLowerBnds.length() == 0) {\n\tdr->nonlinearIneqLowerBnds.sizeUninitialized(n);\n\tdr->nonlinearIneqLowerBnds = -dbl_inf;\n      }\n      if (dr->nonlinearIneqUpperBnds.length() == 0) {\n\tdr->nonlinearIneqUpperBnds.sizeUninitialized(n);\n\tdr->nonlinearIneqUpperBnds = 0.;\n\t// default is a one-sided inequality <= 0.0\n      }\n    }\n    if (dr->hessianType == \"mixed\") {\n      iv = new IntArray;\n      //iv->resize(nf);\n      iv->assign(nf, 0);\n      if (!(mixed_check(&dr->idAnalyticHessians, ni, iv, \"id_analytic_hessians\")\n\t    + mixed_check(&dr->idNumericalHessians, ni, iv, \"id_numerical_hessians\")\n\t    + mixed_check(&dr->idQuasiHessians, ni, iv, \"id_quasi_hessians\")))\n\tmixed_check2(nf, iv, \"Hessian\");\n      delete iv;\n    }\n    if (nerr)\n      abort_handler(PARSE_ERROR);\n  }\n}\n\nvoid NIDRProblemDescDB::\nresp_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(String DataResponsesRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nresp_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(Resp_Info**)g)->dr->**(StringArray DataResponsesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(bool DataResponsesRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nresp_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(bool DataResponsesRep::**)v = true;\n}\n\n// void NIDRProblemDescDB::\n// env_Real(const char *keyname, Values *val, void **g, void *v)\n// {\n//   (*(DataEnvironmentRep**)g)->**(Real DataEnvironmentRep::**)v = *val->r;\n// }\n\n// void NIDRProblemDescDB::\n// env_RealL(const char *keyname, Values *val, void **g, void *v)\n// {\n//   Real *r = val->r;\n//   RealVector *rdv\n//     = &((*(DataEnvironmentRep**)g)->**(RealVector DataEnvironmentRep::**)v);\n//   size_t i, n = val->n;\n\n//   rdv->sizeUninitialized(n);\n//   for(i = 0; i < n; i++)\n//     (*rdv)[i] = r[i];\n// }\n\nvoid NIDRProblemDescDB::\nenv_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(bool DataEnvironmentRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nenv_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(int DataEnvironmentRep::**)v = *val->i;\n}\n\n// void NIDRProblemDescDB::\n// env_lit(const char *keyname, Values *val, void **g, void *v)\n// {\n//   (*(DataEnvironmentRep**)g)->*((Environment_mp_lit*)v)->sp\n//     = ((Environment_mp_lit*)v)->lit;\n// }\n\nvoid NIDRProblemDescDB::\nenv_start(const char *keyname, Values *val, void **g, void *v)\n{\n  *g = (void*)pDDBInstance->environmentSpec.dataEnvRep;\n}\n\nvoid NIDRProblemDescDB::\nenv_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(String DataEnvironmentRep::**)v = *val->s;\n}\n\n/// set a value for an unsigned short type\nvoid NIDRProblemDescDB::\nenv_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->*((Env_mp_utype*)v)->sp = \n    ((Env_mp_utype*)v)->utype;\n}\n\n/// augment an unsigned short type with |=\nvoid NIDRProblemDescDB::\nenv_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->*((Env_mp_utype*)v)->sp |= \n    ((Env_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nenv_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(DataEnvironmentRep**)g)->**(StringArray DataEnvironmentRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_tr_final(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep &data_method = *(*(Meth_Info**)g)->dme;\n\n  // sanity checks on trust region user-defined values\n  if ( data_method.surrBasedLocalTRInitSize <= 0.0 ||\n       data_method.surrBasedLocalTRInitSize >  1.0 )\n    botch(\"initial_size must be in (0,1]\");\n  if ( data_method.surrBasedLocalTRMinSize <= 0.0 ||\n       data_method.surrBasedLocalTRMinSize >  1.0 ||\n       data_method.surrBasedLocalTRMinSize >\n       data_method.surrBasedLocalTRInitSize )\n    botch(\"minimum_size must be in (0,1]\");\n  if( data_method.surrBasedLocalTRContractTrigger <= 0.0 ||\n      data_method.surrBasedLocalTRContractTrigger >\n      data_method.surrBasedLocalTRExpandTrigger        ||\n      data_method.surrBasedLocalTRExpandTrigger   >  1.0 )\n    botch(\"expand/contract threshold values must satisfy\\n\\t\"\n\t  \"0 < contract_threshold <= expand_threshold < 1\");\n  if ( data_method.surrBasedLocalTRContract == 1.0 )\n    warn(\"contraction_factor = 1.0 is valid, but should be < 1\\n\\t\"\n\t \"to assure convergence of the surrrogate_based_opt method\");\n  if ( data_method.surrBasedLocalTRContract <= 0.0 ||\n       data_method.surrBasedLocalTRContract >  1.0 )\n    botch(\"contraction_factor must be in (0,1]\");\n  if (data_method.surrBasedLocalTRExpand < 1.0)\n    botch(\"expansion_factor must be >= 1\");\n}\n\n\nvoid NIDRProblemDescDB::\nvar_RealLb(const char *keyname, Values *val, void **g, void *v)\n{\n  Real b, *r;\n  RealVector *rv;\n  Var_brv *V;\n  size_t i, n;\n\n  V = (Var_brv*)v;\n  rv = &((*(Var_Info**)g)->dv->*V->rv);\n  b = V->b;\n  r = val->r;\n  n = val->n;\n  for(i = 0; i < n; i++)\n    if (r[i] <= b) {\n      squawk(\"%s values must be > %g\", keyname, b);\n      break;\n    }\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_RealUb(const char *keyname, Values *val, void **g, void *v)\n{\n  Real b, *r;\n  RealVector *rv;\n  Var_brv *V;\n  size_t i, n;\n\n  V = (Var_brv*)v;\n  rv = &((*(Var_Info**)g)->dv->*V->rv);\n  b = V->b;\n  r = val->r;\n  n = val->n;\n  for(i = 0; i < n; i++)\n    if (r[i] >= b) {\n      squawk(\"%s values must be < %g\", keyname, b);\n      break;\n    }\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_IntLb(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_biv *V = (Var_biv*)v;\n  IntVector *iv = &((*(Var_Info**)g)->dv->*V->iv);\n  int b = V->b;\n  int *z = val->i;\n  size_t i, n = val->n;\n  for(i = 0; i < n; i++)\n    if (z[i] <= b) {\n      squawk(\"%s values must be > %g\", keyname, b);\n      break;\n    }\n  iv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\n\n/// Map an NIDR STRINGLIST to a BoolDeque based on string values; for\n/// now we require user to specify all N values\nvoid NIDRProblemDescDB::\nvar_categorical(const char *keyname, Values *val, void **g, void *v)\n{\n  BitArray *ba\n    = &((*(Var_Info**)g)->dv->**(BitArray DataVariablesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  // allow strings beginning y Y or T t (yes/true)\n  ba->resize(n);\n  for(i = 0; i < n; i++) {\n    String str_lower(strtolower(s[i]));\n    (*ba)[i] = strbegins(str_lower, \"y\") || strbegins(str_lower, \"t\");\n  }\n}\n\n\nvoid NIDRProblemDescDB::\nvar_newrvec(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  RealVector *rv;\n  size_t i, n = val->n;\n  Real *r = val->r;\n\n  if (!(rv = new RealVector(n, false)))\n    botch(\"new failure in var_newrvec\");\n  vi->**(RealVector *Var_Info::**)v = rv;\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newivec(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  IntVector *iv;\n  size_t i, n = val->n;\n  int *z = val->i;\n\n  if (!(iv = new IntVector(n, false)))\n    botch(\"new failure in var_newivec\");\n  vi->**(IntVector *Var_Info::**)v = iv;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newiarray(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  IntArray *iv;\n  size_t i, n = val->n;\n  int *z = val->i;\n\n  if (!(iv = new IntArray(n)))\n    botch(\"new failure in var_intarray\");\n  vi->**(IntArray *Var_Info::**)v = iv;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newsarray(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  StringArray *sa;\n  size_t i, n = val->n;\n  const char **z = val->s;\n\n  if (!(sa = new StringArray(n)))\n    botch(\"new failure in var_newsarray\");\n  vi->**(StringArray *Var_Info::**)v = sa;\n  for(i = 0; i < n; i++)\n    (*sa)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_rvec(const char *keyname, Values *val, void **g, void *v)\n{\n  RealVector *rv\n    = &((*(Var_Info**)g)->dv->**(RealVector DataVariablesRep::**)v);\n  size_t i, n = val->n;\n  rv->sizeUninitialized(n);\n\n  Real *r = val->r;\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  IntVector *iv = &((*(Var_Info**)g)->dv->**(IntVector DataVariablesRep::**)v);\n  size_t i, n = val->n;\n  iv->sizeUninitialized(n);\n\n  int *z = val->i;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\n// BMA TODO: I believe this duplicative of var_strL.\n// void NIDRProblemDescDB::\n// var_svec(const char *keyname, Values *val, void **g, void *v)\n// {\n//   StringArray *sa = &((*(Var_Info**)g)->dv->**(StringArray DataVariablesRep::**)v);\n//   size_t i, n = val->n;\n//   sa->resize(n);\n\n//   const char **z = val->s;\n//   for(i = 0; i < n; i++)\n//     (*sa)[i] = z[i];\n// }\n\nvoid NIDRProblemDescDB::\nvar_pintz(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Var_Info**)g)->dv->**(size_t DataVariablesRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nvar_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->*((Var_mp_type*)v)->sp = ((Var_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nvar_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi;\n\n  if (!(vi = new Var_Info))\n  Botch:\t\tbotch(\"new failure in var_start\");\n  memset(vi, 0, sizeof(Var_Info));\n  if (!(vi->dv_handle = new DataVariables))\n    goto Botch;\n  vi->dv = vi->dv_handle->dataVarsRep;\n  *g = (void*)vi;\n}\n\nvoid NIDRProblemDescDB::\nvar_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->**(bool DataVariablesRep::**)v = true;\n}\n\nstatic int wronglen(size_t n, RealVector *V, const char *what)\n{\n  size_t n1 = V->length();\n  if (n != n1) {\n    Squawk(\"Expected %d numbers for %s, but got %d\", (int)n, what, (int)n1);\n    return 1;\n  }\n  return 0;\n}\n\nstatic int wronglen(size_t n, IntVector *V, const char *what)\n{\n  size_t n1 = V->length();\n  if (n != n1) {\n    Squawk(\"Expected %d numbers for %s, but got %d\", (int)n, what, (int)n1);\n    return 1;\n  }\n  return 0;\n}\n\nstatic void Vcopyup(RealVector *V, RealVector *M, size_t i, size_t n)\n{\n  size_t j;\n  for(j = 0; j < n; ++i, ++j)\n    (*V)[i] = (*M)[j];\n}\n\nstatic void Set_rv(RealVector *V, double d, size_t n)\n{\n  size_t i;\n  V->sizeUninitialized(n);\n  for(i = 0; i < n; ++i)\n    (*V)[i] = d;\n}\n\nstatic void Set_iv(IntVector *V, int d, size_t n)\n{\n  size_t i;\n  V->sizeUninitialized(n);\n  for(i = 0; i < n; ++i)\n    (*V)[i] = d;\n}\n\nstatic void\nwrong_number(const char *what, const char *kind, size_t nsv, size_t m)\n{\n  Squawk(\"Expected %d %s for %s, not %d\", (int)nsv, what, kind, (int)m);\n}\n\nstatic void too_small(const char *kind)\n{\n  Squawk(\"num_set_values values for %s must be >= 1\", kind);\n}\n\nstatic void not_div(const char *kind, size_t nsv, size_t m)\n{\n  Squawk(\"Number of %s set_values (%d) not evenly divisible by number of variables (%d); use num_set_values for unequal apportionment\",\n\t kind, (int)nsv, (int)m);\n}\n\nstatic void suppressed(const char *kind, int ndup, int *ip, String *sp, Real *rp)\n{\n  const char *s;\n  int i, nother;\n\n  nother = 0;\n  if (ndup > 2) {\n    nother = ndup - 1;\n    ndup = 1;\n  }\n  for(i = 0; i < ndup; ++i)\n    if (ip)\n      Squawk(\"Duplicate %s value %d\", kind, ip[i]);\n    else if (sp)\n      Squawk(\"Duplicate %s value %s\", kind, sp[i].c_str());\n    else\n      Squawk(\"Duplicate %s value %.17g\", kind, rp[i]);\n  if (nother) {\n    s = \"s\" + (nother == 1);\n    Squawk(\"Warning%s of %d other duplicate %s value%s suppressed\",\n\t   s, nother, kind, s);\n  }\n}\n\nstatic void bad_initial_ivalue(const char *kind, int val)\n{\n  Squawk(\"invalid initial value %d for %s\", val, kind);\n}\n\nstatic void bad_initial_svalue(const char *kind, String val)\n{\n  Squawk(\"invalid initial value %s for %s\", val.c_str(), kind);\n}\n\nstatic void bad_initial_rvalue(const char *kind, Real val)\n{\n  Squawk(\"invalid initial value %.17g for %s\", val, kind);\n}\n\n// *****************************************************************************\n//  Vchk functions called earlier from within check_variables_node(), which\n//   immediately {precedes,follows} DB buffer {send,receive} in broadcast().\n// Vgen functions called later from within make_variable_defaults()\n//   (from within post_process() following broadcast()).\n// As documented in ProblemDescDB::manage_inputs(), Vchk applies to minimal\n//   spec data, whereas Vgen constructs any large inferred vectors.\n// *****************************************************************************\nstatic void Vgen_ContinuousDes(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V;\n  size_t i, n = dv->numContinuousDesVars;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  L = &dv->continuousDesignLowerBnds;\n  U = &dv->continuousDesignUpperBnds;\n  V = &dv->continuousDesignVars;\n  if (L->length() == 0)\n    Set_rv(L, -dbl_inf, n);\n  if (U->length() == 0)\n    Set_rv(U, dbl_inf, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; i++) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0.) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0.) (*V)[i] = (*U)[i];\n      else                   (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_DiscreteDesRange(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V;\n  size_t i, n = dv->numDiscreteDesRangeVars;\n\n  L = &dv->discreteDesignRangeLowerBnds;\n  U = &dv->discreteDesignRangeUpperBnds;\n  V = &dv->discreteDesignRangeVars;\n  if (L->length() == 0)\n    Set_iv(L, INT_MIN, n);\n  if (U->length() == 0)\n    Set_iv(U, INT_MAX, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; ++i) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0) (*V)[i] = (*U)[i];\n      else                  (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_ContinuousState(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V;\n  size_t i, n = dv->numContinuousStateVars;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  L = &dv->continuousStateLowerBnds;\n  U = &dv->continuousStateUpperBnds;\n  V = &dv->continuousStateVars;\n  if (L->length() == 0)\n    Set_rv(L, -dbl_inf, n);\n  if (U->length() == 0)\n    Set_rv(U, dbl_inf, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; i++) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0.) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0.) (*V)[i] = (*U)[i];\n      else                   (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_DiscreteStateRange(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V;\n  size_t i, n = dv->numDiscreteStateRangeVars;\n\n  L = &dv->discreteStateRangeLowerBnds;\n  U = &dv->discreteStateRangeUpperBnds;\n  V = &dv->discreteStateRangeVars;\n  if (L->length() == 0)\n    Set_iv(L, INT_MIN, n);\n  if (U->length() == 0)\n    Set_iv(U, INT_MAX, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; ++i) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0) (*V)[i] = (*U)[i];\n      else                  (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vchk_NormalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *B, *M, *Sd;\n\n  n = dv->numNormalUncVars;\n  if (wronglen(n,  M = &dv->normalUncMeans,   \"nuv_means\") ||\n      wronglen(n, Sd = &dv->normalUncStdDevs, \"nuv_std_deviations\"))\n    return;\n  B = &dv->normalUncLowerBnds;\n  if (B->length() && wronglen(n, B, \"nuv_lower_bounds\"))\n    return;\n  B = &dv->normalUncUpperBnds;\n  if (B->length() && wronglen(n, B, \"nuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_NormalUnc(DataVariablesRep *dv, size_t offset)\n{\n  short bds = 0; // 2 bits indicated LB and UB specs\n  size_t i, j, n;\n  Real mean, stdev, nudge, lower, upper;\n  RealVector *B, *L, *M, *Sd, *U, *V, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  n  =  dv->numNormalUncVars;\n  M  = &dv->normalUncMeans;      Sd = &dv->normalUncStdDevs;\n  L  = &dv->normalUncLowerBnds;  U  = &dv->normalUncUpperBnds;\n  IP = &dv->normalUncVars;       V  = &dv->continuousAleatoryUncVars;\n\n  // process lower bounds\n  B = &dv->continuousAleatoryUncLowerBnds;\n  if (L->length()) {\n    Vcopyup(B, L, offset, n); // global = distribution\n    bds |= 1;\n  }\n  else {\n    Set_rv(L, -dbl_inf, n); // distribution\n    for(j = 0; j < n; ++j)\n      (*B)[offset+j] = (*M)[j] - 3.*(*Sd)[j]; // inferred global\n  }\n\n  // process upper bounds\n  B = &dv->continuousAleatoryUncUpperBnds;\n  if (U->length()) {\n    Vcopyup(B, U, offset, n); // global = distribution\n    bds |= 2;\n  }\n  else {\n    Set_rv(U, dbl_inf, n); // distribution\n    for(j = 0; j < n; ++j)\n      (*B)[offset+j] = (*M)[j] + 3.*(*Sd)[j]; // inferred global\n  }\n\n  // Set initial values and repair to bounds, if needed\n  if (IP->length()) { // in this case, don't nudge since not a default value\n\n    dv->uncertainVarsInitPt = true;\n\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else { // > bds is 0, 1, 2, or 3 (0 ==> no bounds given, nothing more to do)\n\n    // Note: in the case of BoundedNormalRandomVariable, we are initializing\n    // to the gaussMean parameter of the unbounded normal and repairing to the\n    // bounds.  To assign to the mean of the bounded normal (bounds repair not\n    // necessary), use BoundedNormalRandomVariable::mean().\n    switch(bds) {\n    case 0: // no bounds\n      Vcopyup(V, M, offset, n);\n      break;\n    case 1: // only lower bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j)\n\tif ((*M)[j] <= (*L)[j]) (*V)[i] = (*L)[j] + 0.5*(*Sd)[j];\n\telse                    (*V)[i] = (*M)[j];\n      break;\n\n    case 2: // only upper bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j)\n\tif ((*M)[j] >= (*U)[j]) (*V)[i] = (*U)[j] - 0.5*(*Sd)[j];\n\telse                    (*V)[i] = (*M)[j];\n      break;\n\n    case 3: // both lower and upper bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j) {\n\tlower  = (*L)[j]; upper = (*U)[j];\n\tnudge  = 0.5 * std::min((*Sd)[j], upper - lower);\n\tlower += nudge;   upper -= nudge;  mean = (*M)[j];\n \tif      (mean < lower) (*V)[i] = lower;\n\telse if (mean > upper) (*V)[i] = upper;\n\telse                   (*V)[i] = mean;\n      }\n      break;\n    }\n  }\n}\n\nstatic void Vchk_LognormalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *B, *L, *M, *Sd, *Ef, *Z;\n\n  // lambda/zeta, mean/std_deviation, or mean/error_factor\n  n = dv->numLognormalUncVars;\n  L = &dv->lognormalUncLambdas;\n  M = &dv->lognormalUncMeans;\n  if (L->length()) {\n    if (wronglen(n, L, \"lnuv_lambdas\"))\n      return;\n    if (wronglen(n, Z = &dv->lognormalUncZetas, \"lnuv_zetas\"))\n      return;\n  }\n  else if (M->length()) {\n    if (wronglen(n, M, \"lnuv_means\"))\n      return;\n    Sd = &dv->lognormalUncStdDevs;\n    Ef = &dv->lognormalUncErrFacts;\n    if (Sd->length())\n      { if (wronglen(n, Sd, \"lnuv_std_deviations\")) return; }\n    else if (Ef->length())\n      { if (wronglen(n, Ef, \"lnuv_error_factors\"))  return; }\n    //else error, but this should be trapped elsewhere\n  }\n\n  // lower bounds\n  B = &dv->lognormalUncLowerBnds;\n  if (B->length() && wronglen(n, B, \"lnuv_lower_bounds\"))\n    return;\n\n  // upper bounds\n  B = &dv->lognormalUncUpperBnds;\n  if (B->length() && wronglen(n, B, \"lnuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_LognormalUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real mean, stdev, nudge, lower, upper;\n  RealVector *B, *Ef, *Lam, *L, *M, *Sd, *U, *V, *Z, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  // lambda/zeta, mean/std_deviation, or mean/error_factor\n  n  = dv->numLognormalUncVars;    Lam = &dv->lognormalUncLambdas;\n  Z  = &dv->lognormalUncZetas;     Ef  = &dv->lognormalUncErrFacts;\n  M  = &dv->lognormalUncMeans;     Sd  = &dv->lognormalUncStdDevs;\n  L  = &dv->lognormalUncLowerBnds; U   = &dv->lognormalUncUpperBnds; \n  IP = &dv->lognormalUncVars;      V   = &dv->continuousAleatoryUncVars;\n\n  size_t num_Sd = Sd->length(), num_Lam = Lam->length(), num_IP = IP->length(),\n    num_L = L->length(), num_U = U->length();\n\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  // manage distribution and global bounds.  Global are inferred if\n  // distribution are not specified.\n  if (!num_L) L->size(n); // inits L to zeros --> default {dist,global}\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n); // global = dist\n  B = &dv->continuousAleatoryUncUpperBnds;\n  if (num_U) Vcopyup(B, U, offset, n); // global = dist\n  else       Set_rv(U, dbl_inf, n);    // default dist; global inferred below\n\n  for (i = offset, j = 0; j < n; ++i, ++j) {\n\n    // extract mean & stdev, if needed\n    if (!num_IP || !num_U) {\n      if (num_Lam)  // lambda/zeta\n\tPecos::LognormalRandomVariable::\n\t  moments_from_params((*Lam)[j], (*Z)[j], mean, stdev);\n      else {\n\tmean = (*M)[j];\n\tif (num_Sd) // mean/std_deviation\n\t  stdev = (*Sd)[j];\n\telse        // mean/error_factor\n\t  Pecos::LognormalRandomVariable::\n\t    std_deviation_from_error_factor(mean, (*Ef)[j], stdev);\n      }\n    }\n\n    // Repair initial values to bounds, if needed\n    if (num_IP) { // in this case, don't nudge since not a default value\n\n      // TO DO: set user spec flag\n\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n    }\n    else {\n      // repair bounds exceedance in default value, if needed\n      lower  = (*L)[j]; upper = (*U)[j];\n      nudge  = 0.5 * std::min(stdev, upper - lower);\n      lower += nudge;   upper -= nudge;\n      if      (mean < lower) (*V)[i] = lower;\n      else if (mean > upper) (*V)[i] = upper;\n      else                   (*V)[i] = mean;\n      // Note: in the case of BoundedLognormalRandomVariable, we are\n      // initializing to the mean parameter of the unbounded lognormal\n      // and repairing to the bounds.  To assign to the mean of the\n      // bounded lognormal (bounds repair not necessary), use\n      // BoundedLognormalRandomVariable::mean().\n    }\n\n    // infer global bounds if no distribution bounds spec\n    if (!num_U)\n      (*B)[i] = mean + 3.*stdev;\n  }\n}\n\nstatic void Vchk_UniformUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *L, *U;\n\n  n = dv->numUniformUncVars;\n  L = &dv->uniformUncLowerBnds;\n  U = &dv->uniformUncUpperBnds;\n  if (wronglen(n, L, \"uuv_lower_bounds\") || wronglen(n, U, \"uuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_UniformUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *U, *V, *IP;\n\n  n = dv->numUniformUncVars;   IP = &dv->uniformUncVars;\n  L = &dv->uniformUncLowerBnds; U = &dv->uniformUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::UniformRandomVariable::\n\tmoments_from_params((*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void \nVchk_LoguniformUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t j, n;\n  Real Lj, Uj;\n  RealVector *L, *U;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  n = dv->numLoguniformUncVars;\n  L = &dv->loguniformUncLowerBnds;\n  U = &dv->loguniformUncUpperBnds;\n  if (wronglen(n, L, \"luuv_lower_bounds\") ||\n      wronglen(n, U, \"luuv_upper_bounds\"))\n    return;\n  for(j = 0; j < n; ++j) {\n    Lj = (*L)[j];\n    Uj = (*U)[j];\n    if (Lj <= 0. || Uj <= 0.) {\n      Squawk(\"loguniform bounds must be positive\");\n      return;\n    }\n    if (Lj == dbl_inf || Uj == dbl_inf) {\n      Squawk(\"loguniform bounds must be finite\");\n      return;\n    }\n    if (Lj > Uj) {\n      Squawk(\"loguniform lower bound greater than upper bound\");\n      return;\n    }\n  }\n}\n\nstatic void Vgen_LoguniformUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *U, *V, *IP;\n\n  n = dv->numLoguniformUncVars;   IP = &dv->loguniformUncVars;\n  L = &dv->loguniformUncLowerBnds; U = &dv->loguniformUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::LoguniformRandomVariable::\n\tmoments_from_params((*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void Vchk_TriangularUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t j, n;\n  Real Lj, Mj, Uj;\n  RealVector *L, *M, *U;\n\n  n = dv->numTriangularUncVars;    M = &dv->triangularUncModes;\n  L = &dv->triangularUncLowerBnds; U = &dv->triangularUncUpperBnds;\n  if (wronglen(n, L, \"tuv_lower_bounds\") || wronglen(n, M, \"tuv_modes\") ||\n      wronglen(n, U, \"tuv_upper_bounds\"))\n    return;\n  for(j = 0; j < n; ++j) {\n    Lj = (*L)[j]; Mj = (*M)[j]; Uj = (*U)[j];\n    if (Lj > Mj || Mj > Uj) {\n      Squawk(\"triangular uncertain variables must have\\n\\t\"\n\t     \"tuv_lower_bounds <= tuv_modes <= tuv_upper_bounds\");\n      return;\n    }\n  }\n}\n\nstatic void Vgen_TriangularUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *M, *U, *V, *IP;\n\n  n = dv->numTriangularUncVars;   IP = &dv->triangularUncVars;\n  L = &dv->triangularUncLowerBnds; U = &dv->triangularUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else {\n    M = &dv->triangularUncModes;\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::TriangularRandomVariable::\n\tmoments_from_params((*L)[j], (*M)[j], (*U)[j], (*V)[i], stdev);\n  }\n}\n\nstatic void \nVchk_ExponentialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numExponentialUncVars;\n  RealVector *B = &dv->exponentialUncBetas;\n  if (wronglen(n, B, \"euv_betas\"))\n    return;\n}\n\nstatic void Vgen_ExponentialUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *B, *L, *U, *V, *IP;\n\n  B = &dv->exponentialUncBetas; IP = &dv->exponentialUncVars;\n  V = &dv->continuousAleatoryUncVars;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  size_t i, j, n = dv->numExponentialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::ExponentialRandomVariable::moments_from_params((*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_BetaUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B, *L, *U;\n\n  A = &dv->betaUncAlphas;    B = &dv->betaUncBetas;\n  L = &dv->betaUncLowerBnds; U = &dv->betaUncUpperBnds;\n\n  size_t n = dv->numBetaUncVars;\n  if (wronglen(n, A, \"buv_alphas\")       || wronglen(n, B, \"buv_betas\") ||\n      wronglen(n, L, \"buv_lower_bounds\") || wronglen(n, U, \"buv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_BetaUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  size_t i, j, n = dv->numBetaUncVars;\n  A = &dv->betaUncAlphas;    B = &dv->betaUncBetas;\n  L = &dv->betaUncLowerBnds; U = &dv->betaUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->betaUncVars;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::BetaRandomVariable::\n\tmoments_from_params((*A)[j], (*B)[j], (*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void Vchk_GammaUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numGammaUncVars;\n  A = &dv->gammaUncAlphas; B = &dv->gammaUncBetas;\n  if (wronglen(n, A, \"gauv_alphas\") || wronglen(n, B, \"gauv_betas\"))\n    return;\n}\n\nstatic void Vgen_GammaUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->gammaUncAlphas; B = &dv->gammaUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->gammaUncVars;\n  size_t i, j, n = dv->numGammaUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::GammaRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_GumbelUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numGumbelUncVars;\n  A = &dv->gumbelUncAlphas; B = &dv->gumbelUncBetas;\n  if (wronglen(n, A, \"guuv_alphas\") || wronglen(n, B, \"guuv_betas\"))\n    return;\n}\n\nstatic void Vgen_GumbelUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->gumbelUncAlphas; B = &dv->gumbelUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->gumbelUncVars;\n  size_t i, j, n = dv->numGumbelUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::GumbelRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = mean - 3.*stdev;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_FrechetUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numFrechetUncVars;\n  A = &dv->frechetUncAlphas; B = &dv->frechetUncBetas;\n  if (wronglen(n, A, \"fuv_alphas\") || wronglen(n, B, \"fuv_betas\"))\n    return;\n}\n\nstatic void Vgen_FrechetUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->frechetUncAlphas; B = &dv->frechetUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->frechetUncVars;\n  size_t i, j, n = dv->numFrechetUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::FrechetRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_WeibullUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numWeibullUncVars;\n  A = &dv->weibullUncAlphas; B = &dv->weibullUncBetas;\n  if (wronglen(n, A, \"wuv_alphas\") || wronglen(n, B, \"wuv_betas\"))\n    return;\n}\n\nstatic void Vgen_WeibullUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->weibullUncAlphas; B = &dv->weibullUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->weibullUncVars;\n  size_t i, j, n = dv->numWeibullUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::WeibullRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\n\n/// Check the histogram bin input data, normalize the counts and\n/// populate the histogramUncBinPairs map data structure; map keys are\n/// guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramBinUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhbp;\n  RealVector *hba, *hbo, *hbc;\n  int nhbpi, avg_nhbpi;\n  size_t i, j, num_a, num_o, num_c, m, n, tothbp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hba = vi->hba) { // abscissas are required\n    num_a = hba->length();                         // abscissas\n    hbo = vi->hbo; num_o = (hbo) ? hbo->length() : 0; // ordinates\n    hbc = vi->hbc; num_c = (hbc) ? hbc->length() : 0; // counts\n    if (num_o && num_o != num_a) {\n      Squawk(\"Expected %d ordinates, not %d\", num_a, num_o);\n      return;\n    }\n    if (num_c && num_c != num_a) {\n      Squawk(\"Expected %d counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhbp = vi->nhbp) {\n      key = true;\n      m = nhbp->size();\n      //dv->numHistogramBinUncVars = m;\n      for(i=tothbp=0; i<m; ++i) {\n\ttothbp += nhbpi = (*nhbp)[i];\n\tif (nhbpi < 2) {\n\t  Squawk(\"pairs_per_variable must be >= 2\");\n\t  return;\n\t}\n      }\n      if (num_a != tothbp) {\n\tSquawk(\"Expected %d abscissas, not %d\", tothbp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramBinUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhbpi = num_a / m;\n    }\n    RealRealMapArray& hbp = dv->histogramUncBinPairs;\n    hbp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhbpi = (key) ? (*nhbp)[i] : avg_nhbpi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      RealRealMap& hbpi = hbp[i];\n      count_sum = 0.;\n      for (j=0; j<nhbpi; ++j, ++cntr) {\n\tReal x = (*hba)[cntr];                          // abscissas\n\tReal y = (num_o) ? (*hbo)[cntr] : (*hbc)[cntr]; // ordinates/counts\n\tif (j<nhbpi-1) {\n\t  Real bin_width = (*hba)[cntr+1] - x;\n\t  if (bin_width <= 0.) {\n\t    Squawk(\"histogram bin x values must increase\");\n\t    return;\n\t  }\n\t  if (y <= 0.) {\n\t    Squawk(\"nonpositive intermediate histogram bin y value\");\n\t    return;\n\t  }\n\t  if (num_o) // convert from ordinates (probability density) to counts\n\t    y *= bin_width;\n\t  count_sum += y;\n\t}\n\telse if (y != 0) {\n\t  Squawk(\"histogram bin y values must end with 0\");\n\t  return;\n\t}\n\t// insert without checking since keys (abscissas) must increase\n\thbpi[x] = y;\n      }\n      // normalize counts to sum to 1, omitting last value\n      RRMCIter it_end = --(hbpi.end());\n      for (RRMIter it = hbpi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n/// Infer lower/upper bounds for histogram and set initial variable\n/// values based on initial_point or moments, snapping to bounds as\n/// needed.  (Histogram bin doesn't have lower/upper bounds specifcation)\nstatic void Vgen_HistogramBinUnc(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V, *IP;\n  Real mean, stdev;\n\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->histogramBinUncVars;\n  const RealRealMapArray& A = dv->histogramUncBinPairs;\n  size_t i, j, n = dv->numHistogramBinUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    // the pairs are sorted, so take the first and next to last\n    // (omitting the trailing zero)\n    const RealRealMap& hist_bin_pairs = A[j];\n    (*L)[i] = hist_bin_pairs.begin()->first;\n    (*U)[i] = (--hist_bin_pairs.end())->first;\n    if (num_IP) {\n      if      ((*IP)[j] < (*L)[i]) (*V)[i] =  (*L)[i];\n      else if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                         (*V)[i] = (*IP)[j];\n    }\n    else\n      Pecos::HistogramBinRandomVariable::\n\tmoments_from_params(hist_bin_pairs, (*V)[i], stdev);\n  }\n}\n\nstatic void Vchk_PoissonUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numPoissonUncVars;\n  RealVector *A = &dv->poissonUncLambdas;\n  if (wronglen(n, A, \"lambdas\"))\n    return;\n}\n\nstatic void Vgen_PoissonUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Lam;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars;\n  IP = &dv->poissonUncVars; Lam = &dv->poissonUncLambdas;\n  size_t i, j, n = dv->numPoissonUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::PoissonRandomVariable::moments_from_params((*Lam)[j], mean, std_dev);\n    (*L)[i] = 0;\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_BinomialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numBinomialUncVars;\n  RealVector *A = &dv->binomialUncProbPerTrial;\n  IntVector  *B = &dv->binomialUncNumTrials;\n  if (wronglen(n, A, \"prob_per_trial\") ||  wronglen(n, B, \"num_trials\"))\n    return;\n}\n\nstatic void Vgen_BinomialUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *NT, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->binomialUncVars;\n  NT = &dv->binomialUncNumTrials;      Pr = &dv->binomialUncProbPerTrial;\n  size_t i, j, n = dv->numBinomialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    (*U)[i] = (*NT)[j];\n    if (num_IP) {\n      if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else {\n      Pecos::BinomialRandomVariable::\n\tmoments_from_params((*NT)[j], (*Pr)[j], mean, std_dev);\n      (*V)[i] = (int)mean;\n    }\n  }\n}\n\nstatic void \nVchk_NegBinomialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numNegBinomialUncVars;\n  RealVector *A = &dv->negBinomialUncProbPerTrial;\n  IntVector  *B = &dv->negBinomialUncNumTrials;\n  if (wronglen(n, A, \"prob_per_trial\") || wronglen(n, B, \"num_trials\"))\n    return;\n}\n\nstatic void Vgen_NegBinomialUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *NT, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->negBinomialUncVars;\n  NT = &dv->negBinomialUncNumTrials;   Pr = &dv->negBinomialUncProbPerTrial;\n  size_t i, j, n = dv->numNegBinomialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::NegBinomialRandomVariable::\n      moments_from_params((*NT)[j], (*Pr)[j], mean, std_dev);\n    (*L)[i] = (*NT)[j];\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) {\n      if ((*IP)[j] < (*L)[i]) (*V)[i] =  (*L)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else                      (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_GeometricUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numGeometricUncVars;\n  RealVector *A = &dv->geometricUncProbPerTrial;\n  if (wronglen(n, A, \"prob_per_trial\"))\n    return;\n}\n\nstatic void Vgen_GeometricUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->geometricUncVars;\n  Pr = &dv->geometricUncProbPerTrial;\n  size_t i, j, n = dv->numGeometricUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    Pecos::GeometricRandomVariable::\n      moments_from_params((*Pr)[j], mean, std_dev);\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_HyperGeomUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntVector *A, *B, *C;\n\n  size_t n = dv->numHyperGeomUncVars;\n  A = &dv->hyperGeomUncTotalPop;\n  B = &dv->hyperGeomUncSelectedPop;\n  C = &dv->hyperGeomUncNumDrawn;\n  if (wronglen(n, A, \"total_population\")    ||\n      wronglen(n, B, \"selected_population\") || wronglen(n, C, \"num_drawn\"))\n    return;\n}\n\nstatic void Vgen_HyperGeomUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *ND, *NS, *TP, *U, *V, *IP;\n  Real mean, std_dev;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars;\n  ND = &dv->hyperGeomUncNumDrawn; NS = &dv->hyperGeomUncSelectedPop;\n  TP = &dv->hyperGeomUncTotalPop; IP = &dv->hyperGeomUncVars;\n  size_t i, j, n = dv->numHyperGeomUncVars, num_IP = IP->length();\n  int d, s;\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    d = (*ND)[j]; s = (*NS)[j];\n    (*U)[i] = std::min(d, s);\n    if (num_IP) {\n      if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else {\n      Pecos::HypergeometricRandomVariable::\n\tmoments_from_params((*TP)[j], s, d, mean, std_dev);\n      (*V)[i] = (int)mean;\n    }\n  }\n}\n\n\n/// Check the histogram point integer input data, normalize the\n/// counts, and populate DataVariables::histogramUncPointIntPairs; map\n/// keys are guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramPtIntUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhpip;\n  IntVector *hpia;\n  RealVector *hpic;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real y, bin_width, count_sum;\n  int x;\n\n  if (hpia = vi->hpia) {\n    num_a = hpia->length();              // abscissas\n    hpic = vi->hpic; num_c = hpic->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhpip = vi->nhpip) {\n      key = true;\n      m = nhpip->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhpip)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtIntUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    IntRealMapArray& hpp = dv->histogramUncPointIntPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhpip)[i] : avg_nhppi;\n      // hbpi is map<Int value, Real probability> for a single variable i\n      IntRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tint x = (*hpia)[cntr]; // abscissas\n\tReal y = (*hpic)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpia)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      IRMCIter it_end = hppi.end();\n      for (IRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the integer-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using value closest to\n/// mean if no initial point.\nstatic void Vgen_HistogramPtIntUnc(DataVariablesRep *dv, size_t offset)\n{\n  const IntRealMapArray& A = dv->histogramUncPointIntPairs; \n\n  IntVector& L = dv->discreteIntAleatoryUncLowerBnds;\n  IntVector& U = dv->discreteIntAleatoryUncUpperBnds;\n  IntVector& V = dv->discreteIntAleatoryUncVars;\n  IntVector&  IP = dv->histogramPointIntUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtIntUncVars;\n  size_t num_IP = IP.length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const IntRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tIRMCIter it = hist_pt_prs.begin(), it_end = hist_pt_prs.end();\n\t// find value immediately right of mean (can't be past the end)\n\tfor( ; it != it_end, it->first <= mean; ++it);\n\t// bracket the mean\n\tint right_val = it->first;\n\tint left_val = (--it)->first;\n\t// initialize with value closest to mean\n\tV[i] = (mean - right_val < left_val - mean) ? right_val : left_val;\n      }\n    }\n  }\n}\n\n/// Check the histogram point string input data, normalize the counts,\n/// and populate DataVariables::histogramUncPointStrPairs; map keys\n/// are guaranteed unique since the abscissas must increase\n/// (lexicographically)\nstatic void \nVchk_HistogramPtStrUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhpsp;\n  StringArray *hpsa;\n  RealVector *hpsc;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hpsa = vi->hpsa) {\n    num_a = hpsa->size();              // abscissas\n    hpsc = vi->hpsc; num_c = hpsc->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhpsp = vi->nhpsp) {\n      key = true;\n      m = nhpsp->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhpsp)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtStrUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    StringRealMapArray& hpp = dv->histogramUncPointStrPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhpsp)[i] : avg_nhppi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      StringRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tString x = (*hpsa)[cntr]; // abscissas\n\tReal y = (*hpsc)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpsa)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      SRMCIter it_end = hppi.end();\n      for (SRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the string-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using index closest to\n/// mean index if no initial point.\nstatic void Vgen_HistogramPtStrUnc(DataVariablesRep *dv, size_t offset)\n{\n  const StringRealMapArray& A = dv->histogramUncPointStrPairs; \n\n  StringArray& L = dv->discreteStrAleatoryUncLowerBnds;\n  StringArray& U = dv->discreteStrAleatoryUncUpperBnds;\n  StringArray& V = dv->discreteStrAleatoryUncVars;\n  StringArray& IP = dv->histogramPointStrUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtStrUncVars;\n  size_t num_IP = IP.size();\n\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const StringRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      // for string-valued histograms, mean and stddev are of\n      // zero-based indices from beginning of the map\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tsize_t mean_index = boost::math::iround(mean);\n\tSRMCIter it = hist_pt_prs.begin();\n\tstd::advance(it, mean_index);\n\t// initialize with value closest to mean\n\tV[i] = it->first;\n      }\n    }\n  }\n}\n\n\n/// Check the histogram point integer real data, normalize the counts,\n/// and populate DataVariables::histogramUncPointRealPairs; map keys\n/// are guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramPtRealUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhprp;\n  RealVector *hpra, *hprc;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hpra = vi->hpra) {\n    num_a = hpra->length();              // abscissas\n    hprc = vi->hprc; num_c = hprc->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhprp = vi->nhprp) {\n      key = true;\n      m = nhprp->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhprp)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtRealUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    RealRealMapArray& hpp = dv->histogramUncPointRealPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhprp)[i] : avg_nhppi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      RealRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tReal x = (*hpra)[cntr]; // abscissas\n\tReal y = (*hprc)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpra)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      RRMCIter it_end = hppi.end();\n      for (RRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the real-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using value closest to\n/// mean if no initial point.\nstatic void Vgen_HistogramPtRealUnc(DataVariablesRep *dv, size_t offset)\n{\n  const RealRealMapArray& A = dv->histogramUncPointRealPairs; \n\n  RealVector& L = dv->discreteRealAleatoryUncLowerBnds;\n  RealVector& U = dv->discreteRealAleatoryUncUpperBnds;\n  RealVector& V = dv->discreteRealAleatoryUncVars;\n  RealVector& IP = dv->histogramPointRealUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtRealUncVars;\n  size_t num_IP = IP.length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const RealRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tRRMCIter it = hist_pt_prs.begin(), it_end = hist_pt_prs.end();\n\t// find value immediately right of mean (can't be past the end)\n\tfor( ; it != it_end, it->first <= mean; ++it);\n\t// bracket the mean\n\tReal right_val = it->first;\n\tReal left_val = (--it)->first;\n\t// initialize with value closest to mean\n\tV[i] = (mean - right_val < left_val - mean) ? right_val : left_val;\n      }\n    }\n  }\n}\n\n\n/// Check the continuous interval uncertain input data and populate\n/// DataVariables::continuousIntervalUncBasicProbs; map keys (real\n/// intervals) are checked for uniqueness because we don't have a\n/// theoretically sound way to combine duplicate intervals\nstatic void\nVchk_ContinuousIntervalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t i, j, k, m, num_p = 0, num_lb, num_ub;\n  IntArray *nI;\n  int tot_nI, nIi, avg_nI;\n  Real lb, lbj, ub, ubj, default_p;\n  RealVector *Ilb, *Iub, *Ip;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  if ((Ilb = vi->CIlb) && (Iub = vi->CIub)) {\n    num_lb = Ilb->length(); // interval lower_bounds\n    num_ub = Iub->length(); // interval upper_bounds\n\n    // error check on array lengths; bounds are reqd, probs are optional\n    if ((Ip = vi->CIp)) {\n      num_p = Ip->length(); // interval_probs\n      if (num_lb != num_p || num_ub != num_p) {\n\tSquawk(\"Expected as many lower bounds (%d) and upper bounds (%d) as probabilities (%d)\", num_lb, num_ub, num_p);\n\treturn;\n      }\n    }\n    else if (num_lb != num_ub) {\n      Squawk(\"Expected as many lower bounds (%d) as upper bounds (%d)\", num_lb, num_ub);\n      return;\n    }\n\n    // define apportionment\n    bool key;\n    if (nI = vi->nCI) {\n      key = true;\n      m = nI->size();\n      if (m != dv->numContinuousIntervalUncVars) {\n\tSquawk(\"Expected %d numbers for num_intervals, but got %d\",\n\t       dv->numContinuousIntervalUncVars, m);\n\treturn;\n      }\n      for(i=tot_nI=0; i<m; ++i) {\n\ttot_nI += nIi = (*nI)[i];\n\tif (nIi < 1) {\n\t  Squawk(\"num_intervals values should be positive\");\n\t  return;\n\t}\n      }\n      if ( (num_p && wronglen(tot_nI,  Ip, \"interval_probs\") ) ||\n\t   wronglen(tot_nI, Ilb, \"interval lower_bounds\") ||\n\t   wronglen(tot_nI, Iub, \"interval upper_bounds\"))\n\treturn;\n    }\n    else {\n      key = false;\n      m = dv->numContinuousIntervalUncVars;\n      if (num_lb % m) {\n\tSquawk(\"Number of bounds (%d) not evenly divisible by number of variables (%d); Use num_intervals for unequal apportionment\", num_lb, m);\n\treturn;\n      }\n      else\n\tavg_nI = num_lb / m;\n    }\n    RealRealPairRealMapArray& P = dv->continuousIntervalUncBasicProbs;   \n    P.resize(m);\n    for(i = k = 0; i < m; ++i) {\n      nIi = (key) ? (*nI)[i] : avg_nI;\n      RealRealPairRealMap& Pi = P[i];  // map from an interval to a probability\n      ub = -(lb = dbl_inf);\n      if (!num_p) default_p = 1./nIi; // default = equal probability per cell\n      for(j=0; j<nIi; ++j, ++k) {\n\tlbj = (*Ilb)[k];\n\tubj = (*Iub)[k];\n\tRealRealPair interval(lbj, ubj);\n\tReal probability = (num_p) ? (*Ip)[k] : default_p;\n\tif (!Pi.insert(make_pair(interval, probability)).second)\n\t  Squawk(\"Continuous interval [%g, %g] specified more than once for variable %d\", interval.first, interval.second, i);\n\tif (lb > lbj) lb = lbj;\n\tif (ub < ubj) ub = ubj;\n      }\n      if (lb > ub)\n\tSquawk(\"Inconsistent interval uncertain bounds: %g > %g\", lb, ub);\n    }\n  }\n}\n\nstatic void Vgen_ContinuousIntervalUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real lb, lbk, ub, ubk, stdev;\n  RealVector *ceuLB, *ceuUB, *V, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  ceuLB = &dv->continuousEpistemicUncLowerBnds;\n  ceuUB = &dv->continuousEpistemicUncUpperBnds;\n  V     = &dv->continuousEpistemicUncVars;\n  const RealRealPairRealMapArray& P = dv->continuousIntervalUncBasicProbs;\n  IP    = &dv->continuousIntervalUncVars;\n  size_t i, j, n = dv->numContinuousIntervalUncVars,\n    num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    lb = dbl_inf; ub = -dbl_inf;\n    const RealRealPairRealMap& Pj = P[j];\n    RealRealPairRealMap::const_iterator it = Pj.begin();\n    RealRealPairRealMap::const_iterator it_end = Pj.end();\n    for ( ; it != it_end; ++it) {\n      const RealRealPair& interval = it->first;\n      lbk = interval.first; \n      ubk = interval.second;\n      if (lb > lbk) lb = lbk;\n      if (ub < ubk) ub = ubk;\n    }\n    (*ceuLB)[i] = lb; (*ceuUB)[i] = ub;\n    if (num_IP) {\n      if      ((*IP)[j] < lb) (*V)[i] = lb;\n      else if ((*IP)[j] > ub) (*V)[i] = ub;\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else\n      Pecos::UniformRandomVariable::moments_from_params(lb, ub, (*V)[i], stdev);\n    // TO DO: if disjoint cells, repair V[i] to lie inside nearest cell\n  }\n}\n\n/// Check the discrete interval uncertain input data and populate\n/// DataVariables::discreteIntervalUncBasicProbs; map keys (integer\n/// intervals) are checked for uniqueness because we don't have a\n/// theoretically sound way to combine duplicate intervals\nstatic void \nVchk_DiscreteIntervalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t i, j, k, m, num_p = 0, num_lb, num_ub;\n  IntArray *nI;\n  int tot_nI, nIi, avg_nI, lb, lbj, ub, ubj;\n  Real default_p;\n  RealVector *Ip;\n  IntVector *Ilb, *Iub;\n\n  if ((Ilb = vi->DIlb) && (Iub = vi->DIub)) {\n    num_lb = Ilb->length(); // interval lower_bounds\n    num_ub = Iub->length(); // interval upper_bounds\n\n    // error check on array lengths; bounds are reqd, probs are optional\n    if ((Ip = vi->DIp)) {\n      num_p = Ip->length(); // interval_probs\n      if (num_lb != num_p || num_ub != num_p) {\n\tSquawk(\"Expected as many lower bounds (%d) and upper bounds (%d) as probabilities (%d)\", num_lb, num_ub, num_p);\n\treturn;\n      }\n    }\n    else if (num_lb != num_ub) {\n      Squawk(\"Expected as many lower bounds (%d) as upper bounds (%d)\", num_lb, num_ub);\n      return;\n    }\n\n    // define apportionment\n    bool key;\n    if (nI = vi->nDI) {\n      key = true;\n      m = nI->size();\n      if (m != dv->numDiscreteIntervalUncVars) {\n\tSquawk(\"Expected %d numbers for num_intervals, but got %d\",\n\t       dv->numDiscreteIntervalUncVars, m);\n\treturn;\n      }\n      for(i=tot_nI=0; i<m; ++i) {\n\ttot_nI += nIi = (*nI)[i];\n\tif (nIi < 1) {\n\t  Squawk(\"num_intervals values should be positive\");\n\t  return;\n\t}\n      }\n      if ( (num_p && wronglen(tot_nI,  Ip, \"interval_probs\") ) ||\n\t   wronglen(tot_nI, Ilb, \"interval lower_bounds\") ||\n\t   wronglen(tot_nI, Iub, \"interval upper_bounds\"))\n\treturn;\n    }\n    else {\n      key = false;\n      m = dv->numDiscreteIntervalUncVars;\n      if (num_lb % m) {\n\tSquawk(\"Number of bounds (%d) not evenly divisible by number of variables (%d); Use num_intervals for unequal apportionment\", num_lb, m);\n\treturn;\n      }\n      else\n\tavg_nI = num_lb / m;\n    }\n    IntIntPairRealMapArray& P = dv->discreteIntervalUncBasicProbs;   \n    P.resize(m);\n    for(i = k = 0; i < m; ++i) {\n      nIi = (key) ? (*nI)[i] : avg_nI;\n      IntIntPairRealMap& Pi = P[i];   // map from an interval to a probability\n      lb = INT_MAX; ub = INT_MIN;\n      if (!num_p) default_p = 1./nIi; // default = equal probability per cell\n      for(j=0; j<nIi; ++j, ++k) {\n\tlbj = (*Ilb)[k];      \n\tubj = (*Iub)[k];\n\tIntIntPair interval(lbj, ubj);\n\tReal probability =  (num_p) ? (*Ip)[k] : default_p;\n\tif (!Pi.insert(make_pair(interval, probability)).second)\n\t  Squawk(\"Discrete interval [%d, %d] specified more than once for variable %d\", interval.first, interval.second, i);\n\tif (lb > lbj) lb = lbj;\n\tif (ub < ubj) ub = ubj;\n      }\n      if (lb > ub)\n\tSquawk(\"Inconsistent interval uncertain bounds: %g > %g\", lb, ub);\n    }\n  }\n}\n\nstatic void Vgen_DiscreteIntervalUnc(DataVariablesRep *dv, size_t offset)\n{\n  int lb, lbk, ub, ubk, stdev;\n  IntVector *deuLB, *deuUB, *V, *IP;\n\n  deuLB = &dv->discreteIntEpistemicUncLowerBnds;\n  deuUB = &dv->discreteIntEpistemicUncUpperBnds;\n  V     = &dv->discreteIntEpistemicUncVars;\n  const IntIntPairRealMapArray& P = dv->discreteIntervalUncBasicProbs;\n  IP    = &dv->discreteIntervalUncVars;\n  size_t i, j, n = dv->numDiscreteIntervalUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    ub = INT_MIN; lb = INT_MAX;\n    const IntIntPairRealMap& Pj = P[j];\n    IntIntPairRealMap::const_iterator it = Pj.begin();\n    IntIntPairRealMap::const_iterator it_end = Pj.end();\n    for ( ; it != it_end; ++it) {\n      const IntIntPair& interval = it->first;\n      lbk = interval.first; \n      ubk = interval.second;\n      if (lb > lbk) lb = lbk;\n      if (ub < ubk) ub = ubk;\n    }    \n    (*deuLB)[i] = lb; (*deuUB)[i] = ub;\n    if (num_IP) {\n      if      ((*IP)[j] < lb) (*V)[i] = lb;\n      else if ((*IP)[j] > ub) (*V)[i] = ub;\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else\n      (*V)[i] = (lb + ub) / 2; // int truncation if odd sum\n    // TO DO: if disjoint cells, repair V[offset] to lie inside nearest cell\n  }\n}\n\n\n/// validate the number of set elements (values) given the number of\n/// variables and an optional apportionment with\n/// elements_per_variable; return the average number per variable if\n/// equally distributed\nstatic bool \ncheck_set_keys(size_t num_v, size_t ds_len, const char *kind,\n\t       IntArray *input_nds, int& avg_num_ds)\n{\n  // Process num_set_values key or define default allocation\n  bool key = (input_nds);\n  if (key) {\n    if (input_nds->size() != num_v) {\n      wrong_number(\"num_set_values value(s)\", kind, num_v, input_nds->size());\n      return key;\n    }\n    int num_ds_i, total_ds = 0;\n    for (size_t i=0; i<num_v; ++i) {\n      total_ds += num_ds_i = (*input_nds)[i];\n      if (num_ds_i < 1)\n\t{ too_small(kind); return key; }\n    }\n    if (ds_len != total_ds)\n      { wrong_number(\"set_values\", kind, total_ds, ds_len); return key; }\n  }\n  else { // num_set_values is optional; use average len if no spec\n    if (ds_len % num_v)\n      { not_div(kind, ds_len, num_v); return key; }\n    else\n      avg_num_ds = ds_len / num_v;\n  }\n  return key;\n}\n\n\n/// check discrete sets of integers (design and state variables);\n/// error if a duplicate value is specified\n/// error if not ordered to prevent user confusion\nstatic void \nVchk_DIset(size_t num_v, const char *kind, IntArray *input_ndsi,\n\t   IntVector *input_dsi, IntSetArray& dsi_all, IntVector& dsi_init_pt)\n{\n  if (!input_dsi)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsi, ndup, dupval[2], num_dsi_i, val;\n  size_t i, j, cntr, dsi_len = input_dsi->length();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsi_len, kind, input_ndsi, avg_num_dsi);\n\n  // Insert values into the IntSetArray\n  dsi_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dsi_i = (key) ? (*input_ndsi)[i] : avg_num_dsi;\n    IntSet& dsi_all_i = dsi_all[i];\n    for (j=0; j<num_dsi_i; ++j, ++cntr) {\n      val = (*input_dsi)[cntr];\n      if (!dsi_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsi_i-1 && val >= (*input_dsi)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, dupval, 0, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsi_init_pt.empty()) {\n    if (dsi_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsi_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tIntSet& dsi_all_i = dsi_all[i]; val = dsi_init_pt[i];\n\tif (dsi_all_i.find(val) == dsi_all_i.end())\n\t  bad_initial_ivalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n/// check discrete sets of integers (uncertain variables);\n/// error if a duplicate value is specified\n/// error if not ordered to prevent user confusion\nstatic void \nVchk_DIset(size_t num_v, const char *kind, IntArray *input_ndsi,\n\t   IntVector *input_dsi, RealVector *input_dsip,\n\t   IntRealMapArray& dsi_vals_probs, IntVector& dsi_init_pt)\n{\n  if (!input_dsi)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsi, ndup, dupval[2], num_dsi_i, val;\n  size_t i, j, cntr, dsi_len = input_dsi->length(),\n    num_p = (input_dsip) ? input_dsip->length() : 0;\n  if (num_p && num_p != dsi_len)\n    wrong_number(\"set_probabilities\", kind, dsi_len, num_p);\n  Real prob, default_p;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsi_len, kind, input_ndsi, avg_num_dsi);\n\n  // Insert values into the IntRealMapArray\n  dsi_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    IntRealMap& dsi_v_p_i = dsi_vals_probs[i];\n    num_dsi_i = (key) ? (*input_ndsi)[i] : avg_num_dsi;\n    if (!num_p) default_p = 1./num_dsi_i;\n    for (j=0; j<num_dsi_i; ++j, ++cntr) {\n      val  = (*input_dsi)[cntr];\n      prob = (num_p) ? (*input_dsip)[cntr] : default_p;\n      if (dsi_v_p_i.find(val) == dsi_v_p_i.end())\n\tdsi_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dsi_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsi_i-1 && val >= (*input_dsi)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, dupval, 0, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsi_init_pt.empty()) {\n    if (dsi_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsi_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tIntRealMap& dsi_v_p_i = dsi_vals_probs[i]; val = dsi_init_pt[i];\n\tif (dsi_v_p_i.find(val) == dsi_v_p_i.end())\n\t  bad_initial_ivalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\nstatic void \nVchk_DSset(size_t num_v, const char *kind, IntArray *input_ndss,\n\t   StringArray *input_dss, StringSetArray& dss_all, StringArray& dss_init_pt)\n{\n  if (!input_dss)\n    return;\n\n  std::vector<bool> misordered(num_v,false);\n  int avg_num_dss, ndup, num_dss_i;\n  String dupval[2], val;\n  size_t i, j, cntr, dss_len = input_dss->size();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dss_len, kind, input_ndss, avg_num_dss);\n\n  // Insert values into the StringSetArray\n  dss_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dss_i = (key) ? (*input_ndss)[i] : avg_num_dss;\n    StringSet& dss_all_i = dss_all[i];\n    for (j=0; j<num_dss_i; ++j, ++cntr) {\n      val = (*input_dss)[cntr];\n      if (!dss_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dss_i-1 && val >= (*input_dss)[cntr+1])\n\tmisordered[i] = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, dupval, 0);\n  // Check for misordered elements and print out in the expected order\n  for(i=0; i<num_v; ++i) {\n    if (misordered[i]) {\n\tstd::stringstream mss;\n\tstd::copy(dss_all[i].begin(), dss_all[i].end(),\n\t    std::ostream_iterator<std::string>(mss, \" \"));\n        Squawk(\"Elements of %s variables must be provided in ascending order ( %s)\",\n\t    kind, mss.str().c_str());\n     }\n  }\n\n  // Checks on user-specified initial pt array\n  if (!dss_init_pt.empty()) {\n    if (dss_init_pt.size() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dss_init_pt.size());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tStringSet& dss_all_i = dss_all[i]; val = dss_init_pt[i];\n\tif (dss_all_i.find(val) == dss_all_i.end())\n\t  bad_initial_svalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DSset\n}\n\nstatic void \nVchk_DSset(size_t num_v, const char *kind, IntArray *input_ndss,\n\t   StringArray *input_dss, RealVector *input_dssp,\n\t   StringRealMapArray& dss_vals_probs, StringArray& dss_init_pt)\n{\n  if (!input_dss)\n    return;\n\n  bool misordered = false;\n  int avg_num_dss, ndup, num_dss_i;\n  String dupval[2], val;\n  size_t i, j, cntr, dss_len = input_dss->size(),\n    num_p = (input_dssp) ? input_dssp->length() : 0;\n  if (num_p && num_p != dss_len)\n    wrong_number(\"set_probabilities\", kind, dss_len, num_p);\n  Real prob, default_p;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dss_len, kind, input_ndss, avg_num_dss);\n\n  // Insert values into the StringRealMapArray\n  dss_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    StringRealMap& dss_v_p_i = dss_vals_probs[i];\n    num_dss_i = (key) ? (*input_ndss)[i] : avg_num_dss;\n    if (!num_p) default_p = 1./num_dss_i;\n    for (j=0; j<num_dss_i; ++j, ++cntr) {\n      val  = (*input_dss)[cntr];\n      prob = (num_p) ? (*input_dssp)[cntr] : default_p;\n      if (dss_v_p_i.find(val) == dss_v_p_i.end())\n\tdss_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dss_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dss_i-1 && val >= (*input_dss)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, dupval, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dss_init_pt.empty()) {\n    if (dss_init_pt.size() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dss_init_pt.size());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tStringRealMap& dss_v_p_i = dss_vals_probs[i]; val = dss_init_pt[i];\n\tif (dss_v_p_i.find(val) == dss_v_p_i.end())\n\t  bad_initial_svalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n\nstatic void \nVchk_DRset(size_t num_v, const char *kind, IntArray  *input_ndsr,\n\t   RealVector *input_dsr, RealSetArray& dsr_all,\n\t   RealVector& dsr_init_pt)\n{\n  if (!input_dsr)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsr, ndup, num_dsr_i;\n  Real dupval[2], val;\n  size_t i, j, cntr, dsr_len = input_dsr->length();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsr_len, kind, input_ndsr, avg_num_dsr);\n\n  // Insert values into the RealSetArray\n  dsr_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dsr_i = (key) ? (*input_ndsr)[i] : avg_num_dsr;\n    RealSet& dsr_all_i = dsr_all[i];\n    for (j=0; j<num_dsr_i; ++j, ++cntr) {\n      val = (*input_dsr)[cntr];\n      if (!dsr_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsr_i-1 && val >= (*input_dsr)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, 0, dupval);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsr_init_pt.empty()) {\n    if (dsr_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsr_init_pt.length());\n    else\n      for (i=0; i<num_v; ++i) {\n\tRealSet& dsr_all_i = dsr_all[i]; val = dsr_init_pt[i];\n\tif (dsr_all_i.find(val) == dsr_all_i.end())\n\t  bad_initial_rvalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DRset\n}\n\nstatic void \nVchk_DRset(size_t num_v, const char *kind, IntArray  *input_ndsr,\n\t   RealVector *input_dsr, RealVector* input_dsrp,\n\t   RealRealMapArray& dsr_vals_probs, RealVector& dsr_init_pt)\n{\n  if (!input_dsr)\n    return;\n\n  bool misordered = false;\n  size_t i, j, cntr, dsr_len = input_dsr->length();\n  int avg_num_dsr, ndup, num_dsr_i,\n    num_p = (input_dsrp) ? input_dsrp->length() : 0;\n  if (num_p && num_p != dsr_len)\n    wrong_number(\"set_probabilities\", kind, dsr_len, num_p);\n  Real prob, default_p, dupval[2], val;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsr_len, kind, input_ndsr, avg_num_dsr);\n\n  // Insert values into the RealRealMapArray\n  dsr_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    RealRealMap& dsr_v_p_i = dsr_vals_probs[i];\n    num_dsr_i = (key) ? (*input_ndsr)[i] : avg_num_dsr;\n    if (!num_p) default_p = 1./num_dsr_i;\n    for (j=0; j<num_dsr_i; ++j, ++cntr) {\n      val  = (*input_dsr)[cntr];\n      prob = (num_p) ? (*input_dsrp)[cntr] : default_p;\n      if (dsr_v_p_i.find(val) == dsr_v_p_i.end())\n\tdsr_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dsr_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsr_i-1 && val >= (*input_dsr)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, 0, dupval);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsr_init_pt.empty()) {\n    if (dsr_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsr_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tRealRealMap& dsr_v_p_i = dsr_vals_probs[i]; val = dsr_init_pt[i];\n\tif (dsr_v_p_i.find(val) == dsr_v_p_i.end())\n\t  bad_initial_rvalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n// Validate adjacency matrices \nstatic void \nVchk_Adjacency(size_t num_v, const char *kind, const IntArray &num_e,\n\t\tconst IntVector &input_ddsa, RealMatrixArray &dda_all)  {\n  size_t expected_size = 0;\n  for(size_t i = 0; i < num_v; ++i)\n    expected_size += num_e[i]*num_e[i];\n    if(expected_size != input_ddsa.length())\n      Squawk(\"adjacency list for %s has incorrect length\", kind);\n    else {\n      size_t e_ctr = 0;\n      for(size_t i = 0; i < num_v; ++i) {\n        RealMatrix a_tmp(num_e[i],num_e[i]);\n        for(size_t j = 0; j < num_e[i]; ++j)  \n          for(size_t k = 0; k < num_e[i]; ++k) \n            a_tmp[j][k] = input_ddsa[e_ctr++];\n        dda_all.push_back(a_tmp);\n      }\n    }\n}\n\nstatic bool \ncheck_LUV_size(size_t num_v, IntVector& L, IntVector& U, IntVector& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.length() || max_index >= U.length() ||\n\tmax_index >= V.length())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DIset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DIset\",\n\t     (int)offset);\n    L.sizeUninitialized(num_v);\n    U.sizeUninitialized(num_v);\n    if (V.length() == num_v) // user spec --> already assigned by var_ivec()\n      init_V = false;\n    else\n      V.sizeUninitialized(num_v);\n  }\n  return init_V;\n}\n\nstatic bool \ncheck_LUV_size(size_t num_v, StringArray& L, StringArray& U, StringArray& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.size() || max_index >= U.size() ||\n\tmax_index >= V.size())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DSset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DSset\",\n\t     (int)offset);\n    L.resize(num_v);\n    U.resize(num_v);\n    if (V.size() == num_v) // user spec --> already assigned by var_ivec()\n      init_V = false;\n    else\n      V.resize(num_v);\n  }\n  return init_V;\n}\n\n\n\nstatic bool \ncheck_LUV_size(size_t num_v, RealVector& L, RealVector& U, RealVector& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.length() || max_index >= U.length() ||\n\tmax_index >= V.length())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DRset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DRset\",\n\t     (int)offset);\n    L.sizeUninitialized(num_v);\n    U.sizeUninitialized(num_v);\n    if (V.length() == num_v) // user spec --> already assigned by var_rvec()\n      init_V = false;\n    else\n      V.sizeUninitialized(num_v);\n  }\n  return init_V;\n}\n\nstatic void \nVgen_DIset(size_t num_v, IntSetArray& sets, IntVector& L, IntVector& U,\n\t   IntVector& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  ISCIter ie, it;\n  Real avg_val, r_val;\n  int i, i_val, i_left, i_right;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    IntSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = 0;\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ie; it != ie; ++it)\n\t  avg_val += *it;\n\tavg_val /= num_set_i;\n\t// bracket avg_val between [i_left,i_right]\n\ti_left = L[offset]; i_right = U[offset];\n\tfor(it = set_i.begin(); it != ie; ++it) {\n\t  r_val = i_val = *it;\n\t  if (r_val > avg_val) {      // update nearest neighbor to right\n\t    if (i_val < i_right)\n\t      i_right = i_val;\n\t  }\n\t  else if (r_val < avg_val) { // update nearest neighbor to left\n\t    if (i_val > i_left)\n\t      i_left = i_val;\n\t  }\n\t  else { // r_val equals avg_val\n\t    i_left = i_right = i_val;\n\t    break;\n\t  }\n\t}\n\tV[offset] = (i_right - avg_val < avg_val - i_left) ? i_right : i_left;\n      }\n    }\n  }\n}\n\n\n/// generate lower, upper, and initial point for string-valued sets\nstatic void \nVgen_DSset(size_t num_v, StringSetArray& sets, StringArray& L, StringArray& U,\n\t   StringArray& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  SSCIter ie, it;\n  int i;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    StringSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = \"\";\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\tsize_t mid_index = 0;\n\t// initial value is at middle index or the one directly below\n\tif ( (num_set_i % 2 == 0) )\n\t  // initial value is to the left of middle\n\t  mid_index = num_set_i / 2 - 1;\n\telse \n\t  mid_index = (num_set_i + 1) / 2 - 1;\n\tstd::advance(it, mid_index);\n\tV[offset] = *it;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DIset(size_t num_v, IntRealMapArray& vals_probs, IntVector& IP,\n\t   IntVector& L, IntVector& U, IntVector& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  IRMCIter ite, it;\n  Real avg_val, r_val;\n  int i_val, i_left, i_right;\n  size_t i, j, num_vp_j, num_IP = IP.length();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    IntRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = 0;\n      V[i] = (num_IP) ? IP[j] : 0;\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;      // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j]; // presence of value w/i set already checked\n      else if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ite; it != ite; ++it)\n\t  avg_val += it->first;\n\tavg_val /= num_vp_j;\n\t// bracket avg_val between [i_left,i_right]\n\ti_left = L[offset]; i_right = U[offset];\n\tfor(it = vp_j.begin(); it != ite; ++it) {\n\t  r_val = i_val = it->first;\n\t  if (r_val > avg_val) {      // update nearest neighbor to right\n\t    if (i_val < i_right)\n\t      i_right = i_val;\n\t  }\n\t  else if (r_val < avg_val) { // update nearest neighbor to left\n\t    if (i_val > i_left)\n\t      i_left = i_val;\n\t  }\n\t  else { // r_val equals avg_val\n\t    i_left = i_right = i_val;\n\t    break;\n\t  }\n\t}\n\tV[i] = (i_right - avg_val < avg_val - i_left) ? i_right : i_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DRset(size_t num_v, RealSetArray& sets, RealVector& L, RealVector& U,\n\t   RealVector& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  RSCIter ie, it;\n  int i;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    RealSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = 0.;\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ie; it != ie; ++it)\n\t  avg_val += *it;\n\tavg_val /= num_set_i;\n\t// bracket avg_val between [s_left,s_right]\n\ts_left = L[offset]; s_right = U[offset];\n\tfor(it = set_i.begin(); it != ie; ++it) {\n\t  set_val = *it;\n\t  if (set_val > avg_val) {      // update nearest neighbor to right\n\t    if (set_val < s_right)\n\t      s_right = set_val;\n\t  }\n\t  else if (set_val < avg_val) { // update nearest neighbor to left\n\t    if (set_val > s_left)\n\t      s_left = set_val;\n\t  }\n\t  else { // set_val equals avg_val\n\t    s_left = s_right = set_val;\n\t    break;\n\t  }\n\t}\n\tV[offset] = (s_right - avg_val < avg_val - s_left) ? s_right : s_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DRset(size_t num_v, RealRealMapArray& vals_probs, RealVector& IP,\n\t   RealVector& L, RealVector& U, RealVector& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  RRMCIter ite, it;\n  size_t i, j, num_vp_j, num_IP = IP.length();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    RealRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = V[i] = 0.;\n      V[i] = (num_IP) ? IP[j] : 0.;\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;      // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j];\n      else if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ite; it != ite; ++it)\n\t  avg_val += it->first;\n\tavg_val /= num_vp_j;\n\t// bracket avg_val between [s_left,s_right]\n\ts_left = L[i]; s_right = U[i];\n\tfor(it = vp_j.begin(); it != ite; ++it) {\n\t  set_val = it->first;\n\t  if (set_val > avg_val) {      // update nearest neighbor to right\n\t    if (set_val < s_right)\n\t      s_right = set_val;\n\t  }\n\t  else if (set_val < avg_val) { // update nearest neighbor to left\n\t    if (set_val > s_left)\n\t      s_left = set_val;\n\t  }\n\t  else { // set_val equals avg_val\n\t    s_left = s_right = set_val;\n\t    break;\n\t  }\n\t}\n\tV[i] = (s_right - avg_val < avg_val - s_left) ? s_right : s_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DSset(size_t num_v, StringRealMapArray& vals_probs, StringArray& IP,\n\t   StringArray& L, StringArray& U, StringArray& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  SRMCIter ite, it;\n  size_t i, j, num_vp_j, num_IP = IP.size();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    StringRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = V[i] = \"\";\n      V[i] = (num_IP) ? IP[j] : \"\";\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;     // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j];\n      else if (init_V) {\n\tsize_t mid_index = 0;\n\t// initial value is at middle index or the one directly below\n\tif ( (num_vp_j % 2 == 0) )\n\t  // initial value is to the left of middle\n\t  mid_index = num_vp_j / 2 - 1;\n\telse \n\t  mid_index = (num_vp_j + 1) / 2 - 1;\n\tstd::advance(it, mid_index);\n\tV[i] = it->first;\n      }\n    }\n  }\n}\n\nstatic void \nVchk_DiscreteDesSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_integer\";\n  Vchk_DIset(dv->numDiscreteDesSetIntVars, kind, vi->nddsi, vi->ddsi,\n\t     dv->discreteDesignSetInt, dv->discreteDesignSetIntVars);\n  if(vi->ddsia) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetIntVars; i++)\n      num_e.push_back(dv->discreteDesignSetInt[i].size());\n      Vchk_Adjacency(dv->numDiscreteDesSetIntVars, kind, num_e, *vi->ddsia,\n\t\t      dv->discreteDesignSetIntAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteDesSetIntVars, dv->discreteDesignSetInt,\n\t     dv->discreteDesignSetIntLowerBnds,\n\t     dv->discreteDesignSetIntUpperBnds,\n\t     dv->discreteDesignSetIntVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteDesSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_string\";\n  Vchk_DSset(dv->numDiscreteDesSetStrVars, kind, vi->nddss, vi->ddss,\n\t     dv->discreteDesignSetStr, dv->discreteDesignSetStrVars);\n  if(vi->ddssa) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetStrVars; i++)\n\t    num_e.push_back(dv->discreteDesignSetStr[i].size());\n    Vchk_Adjacency(dv->numDiscreteDesSetStrVars, kind, num_e, *vi->ddssa,\n\t\t    dv->discreteDesignSetStrAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteDesSetStrVars, dv->discreteDesignSetStr,\n\t     dv->discreteDesignSetStrLowerBnds,\n\t     dv->discreteDesignSetStrUpperBnds,\n\t     dv->discreteDesignSetStrVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteDesSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_real\";\n  Vchk_DRset(dv->numDiscreteDesSetRealVars, kind, vi->nddsr, vi->ddsr,\n\t     dv->discreteDesignSetReal, dv->discreteDesignSetRealVars);\n  if(vi->ddsra) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetRealVars; i++)\n      num_e.push_back(dv->discreteDesignSetReal[i].size());\n    Vchk_Adjacency(dv->numDiscreteDesSetRealVars, kind, num_e,\n\t\t    *vi->ddsra, dv->discreteDesignSetRealAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteDesSetRealVars, dv->discreteDesignSetReal,\n\t     dv->discreteDesignSetRealLowerBnds,\n\t     dv->discreteDesignSetRealUpperBnds,\n\t     dv->discreteDesignSetRealVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteUncSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_integer\";\n  Vchk_DIset(dv->numDiscreteUncSetIntVars, kind, vi->ndusi, vi->dusi, vi->DSIp,\n\t     dv->discreteUncSetIntValuesProbs, dv->discreteUncSetIntVars);\n}\n\nstatic void Vgen_DiscreteUncSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteUncSetIntVars, dv->discreteUncSetIntValuesProbs,\n\t     dv->discreteUncSetIntVars, dv->discreteIntEpistemicUncLowerBnds,\n\t     dv->discreteIntEpistemicUncUpperBnds,\n\t     dv->discreteIntEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetIntVars.length()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteUncSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_string\";\n  Vchk_DSset(dv->numDiscreteUncSetStrVars, kind, vi->nduss, vi->duss, vi->DSSp,\n\t     dv->discreteUncSetStrValuesProbs, dv->discreteUncSetStrVars);\n}\n\nstatic void Vgen_DiscreteUncSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteUncSetStrVars, dv->discreteUncSetStrValuesProbs,\n\t     dv->discreteUncSetStrVars, dv->discreteStrEpistemicUncLowerBnds,\n\t     dv->discreteStrEpistemicUncUpperBnds,\n\t     dv->discreteStrEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetStrVars.size()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteUncSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_real\";\n  Vchk_DRset(dv->numDiscreteUncSetRealVars, kind, vi->ndusr, vi->dusr, vi->DSRp,\n\t     dv->discreteUncSetRealValuesProbs, dv->discreteUncSetRealVars);\n}\n\nstatic void Vgen_DiscreteUncSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteUncSetRealVars, dv->discreteUncSetRealValuesProbs,\n\t     dv->discreteUncSetRealVars, dv->discreteRealEpistemicUncLowerBnds,\n\t     dv->discreteRealEpistemicUncUpperBnds,\n\t     dv->discreteRealEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetRealVars.length()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteStateSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_integer\";\n  Vchk_DIset(dv->numDiscreteStateSetIntVars, kind, vi->ndssi, vi->dssi, \n\t     dv->discreteStateSetInt, dv->discreteStateSetIntVars);\n}\n\nstatic void Vgen_DiscreteStateSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteStateSetIntVars, dv->discreteStateSetInt,\n\t     dv->discreteStateSetIntLowerBnds,\n\t     dv->discreteStateSetIntUpperBnds,\n\t     dv->discreteStateSetIntVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteStateSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_string\";\n  Vchk_DSset(dv->numDiscreteStateSetStrVars, kind, vi->ndsss, vi->dsss, \n\t     dv->discreteStateSetStr, dv->discreteStateSetStrVars);\n}\n\nstatic void Vgen_DiscreteStateSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteStateSetStrVars, dv->discreteStateSetStr,\n\t     dv->discreteStateSetStrLowerBnds,\n\t     dv->discreteStateSetStrUpperBnds,\n\t     dv->discreteStateSetStrVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteStateSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_real\";\n  Vchk_DRset(dv->numDiscreteStateSetRealVars, kind, vi->ndssr, vi->dssr,\n\t     dv->discreteStateSetReal, dv->discreteStateSetRealVars);\n}\n\nstatic void Vgen_DiscreteStateSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteStateSetRealVars, dv->discreteStateSetReal,\n\t     dv->discreteStateSetRealLowerBnds,\n\t     dv->discreteStateSetRealUpperBnds,\n\t     dv->discreteStateSetRealVars); // no offset, not aggregate L/U/V\n}\n\nstatic const char *\nVar_Name(StringArray *sa, char *buf, size_t i)\n{\n  if (sa)\n    return (*sa)[i].data();\n  std::sprintf(buf,\"%lu\", (UL)(i+1));\n  return (const char*)buf;\n}\n\n/// For real-valued variables: verify lengths of bounds and initial\n/// point, validate bounds and adjust initial point to bounds\nstatic void Var_RealBoundIPCheck(DataVariablesRep *dv, Var_rcheck *b)\n{\n  RealVector *L, *U, *V;\n  StringArray *sa;\n  char namebuf[32];\n  int i, n, ndflt; // length() values here are int rather than size_t\n\n  if ((n = dv->*b->n) == 0)\n    return;\n  ndflt = -1;\n  if (b->L) {\n    ndflt = 0;\n    L = &(dv->*b->L);\n    if (L->length() == 0)\n      ++ndflt;\n    else if (L->length() != n) {\n      Squawk(\"%s_lower_bounds needs %lu elements, not %lu\",\n\t     b->name, (UL)n, (UL)L->length());\n      return;\n    }\n    U = &(dv->*b->U);\n    if (U->length() == 0)\n      ++ndflt;\n    else if (U->length() != n) {\n      Squawk(\"%s_upper_bounds needs %lu elements, not %lu\",\n\t     b->name, (UL)n, (UL)L->length());\n      return;\n    }\n  }\n  sa = 0;\n  if (b->Lbl) {\n    sa = &(dv->*b->Lbl);\n    if (sa->size() == 0)\n      sa = 0;\n  }\n  if (ndflt == 0)\n    for(i = 0; i < n; i++) {\n      if ((*L)[i] > (*U)[i])\n\tSquawk(\"lower bound for %s variable %s exceeds upper bound\",\n\t       b->name, Var_Name(sa,namebuf,i));\n    }\n  if (b->V == 0)\n    return;\n  V = &(dv->*b->V);\n  if (V->length() == 0)\n    return;\n  if (V->length() != n) {\n    Squawk(\"initial point for %s needs %lu elements, not %lu\",\n\t   b->name, (UL)n, (UL)V->length());\n    return;\n  }\n  if (L->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] < (*L)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its lower bound\",\n\t     b->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*L)[i];\n      }\n  }\n  if (U->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] > (*U)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its upper bound\",\n\t     b->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*U)[i];\n      }\n  }\n}\n\n/// For integer-valued variables: verify lengths of bounds and initial\n/// point, validate bounds and initial point against bounds\nstatic void Var_IntBoundIPCheck(DataVariablesRep *dv, Var_icheck *ib)\n{\n  IntVector *L, *U, *V;\n  StringArray *sa;\n  char namebuf[32];\n  int i, n, ndflt; // length() values here are int rather than size_t\n\n  if ((n = dv->*ib->n) == 0)\n    return;\n  L = &(dv->*ib->L);\n  ndflt = 0;\n  if (L->length() == 0)\n    ++ndflt;\n  else if (L->length() != n) {\n    Squawk(\"%s_lower_bounds needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)L->length());\n    return;\n  }\n  U = &(dv->*ib->U);\n  if (U->length() == 0)\n    ++ndflt;\n  else if (U->length() != n) {\n    Squawk(\"%s_upper_bounds needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)L->length());\n    return;\n  }\n  sa = 0;\n  if (ib->Lbl) {\n    sa = &(dv->*ib->Lbl);\n    if (sa->size() == 0)\n      sa = 0;\n  }\n  if (ndflt == 0)\n    for(i = 0; i < n; i++) {\n      if ((*L)[i] > (*U)[i])\n\tSquawk(\"lower bound for %s variable %s exceeds upper bound\",\n\t       ib->name, Var_Name(sa,namebuf,i));\n    }\n  if (ib->V == 0)\n    return;\t// won't happen for discrete variables\n  V = &(dv->*ib->V);\n  if (V->length() == 0)\n    return;\n  if (V->length() != n) {\n    Squawk(\"initial point for %s needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)V->length());\n    return;\n  }\n  if (L->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] < (*L)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its lower bound\",\n\t     ib->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*L)[i];\n      }\n  }\n  if (U->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] > (*U)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its upper bound\",\n\t     ib->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*U)[i];\n      }\n  }\n}\n\n\n// setup the Vchk functions for each of the uncertain variable\n// contiguous containers, and for discrete sets\n#define VarLabelInfo(a,b)     { #a, #b, &DataVariablesRep::num##b##Vars, Vchk_##b }\nstatic Var_uinfo CAUVLbl[CAUVar_Nkinds] = {\n  VarLabelInfo(nuv_, NormalUnc),\n  VarLabelInfo(lnuv_, LognormalUnc),\n  VarLabelInfo(uuv_, UniformUnc),\n  VarLabelInfo(luuv_, LoguniformUnc),\n  VarLabelInfo(tuv_, TriangularUnc),\n  VarLabelInfo(euv_, ExponentialUnc),\n  VarLabelInfo(beuv_, BetaUnc),\n  VarLabelInfo(gauv_, GammaUnc),\n  VarLabelInfo(guuv_, GumbelUnc),\n  VarLabelInfo(fuv_, FrechetUnc),\n  VarLabelInfo(wuv_, WeibullUnc),\n  VarLabelInfo(hbuv_, HistogramBinUnc)\n};\nstatic Var_uinfo DAUIVLbl[DAUIVar_Nkinds] = {\n  VarLabelInfo(puv_, PoissonUnc),\n  VarLabelInfo(biuv_, BinomialUnc),\n  VarLabelInfo(nbuv_, NegBinomialUnc),\n  VarLabelInfo(geuv_, GeometricUnc),\n  VarLabelInfo(hguv_, HyperGeomUnc),\n  VarLabelInfo(hpiuv_, HistogramPtIntUnc)\n};\nstatic Var_uinfo DAUSVLbl[DAUSVar_Nkinds] = {\n  VarLabelInfo(hpsuv_, HistogramPtStrUnc)\n};\nstatic Var_uinfo DAURVLbl[DAURVar_Nkinds] = {\n  VarLabelInfo(hpruv_, HistogramPtRealUnc)\n};\nstatic Var_uinfo CEUVLbl[CEUVar_Nkinds] = {\n  VarLabelInfo(ciuv_, ContinuousIntervalUnc)\n};\nstatic Var_uinfo DEUIVLbl[DEUIVar_Nkinds] = {\n  VarLabelInfo(diuv_, DiscreteIntervalUnc),\n  VarLabelInfo(dusiv_, DiscreteUncSetInt)\n};\nstatic Var_uinfo DEUSVLbl[DEUSVar_Nkinds] = {\n  VarLabelInfo(dussv_, DiscreteUncSetStr)\n};\nstatic Var_uinfo DEURVLbl[DEURVar_Nkinds] = {\n  VarLabelInfo(dusrv_, DiscreteUncSetReal)\n};\nstatic Var_uinfo DiscSetLbl[DiscSetVar_Nkinds] = {\n  VarLabelInfo(ddsiv_, DiscreteDesSetInt),\n  VarLabelInfo(ddssv_, DiscreteDesSetStr),\n  VarLabelInfo(ddsrv_, DiscreteDesSetReal),\n  VarLabelInfo(dssiv_, DiscreteStateSetInt),\n  VarLabelInfo(dsssv_, DiscreteStateSetStr),\n  VarLabelInfo(dssrv_, DiscreteStateSetReal)\n};\n#undef VarLabelInfo\n\nvoid NIDRProblemDescDB::\nvar_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  DataVariablesRep *dv = vi->dv;\n  scale_chk(dv->continuousDesignScaleTypes, dv->continuousDesignScales,\n\t    \"cdv\", aln_scaletypes);\n  pDDBInstance->VIL.push_back(vi);\n  pDDBInstance->dataVariablesList.push_back(*vi->dv_handle);\n  delete vi->dv_handle;\n}\n\nstruct VarLabelChk {\n  size_t DataVariablesRep::* n;\n  StringArray DataVariablesRep::* sa;\n  const char *stub;\n  const char *name;\n};\n\n\n// For validation to be performed in check_variables_node(), each\n// variable type must be included in at least one of\n// DesignAndStateLabelsCheck, LUncertainInt, VLUncertainStr,\n// VLUncertainReal, or DiscSetLbl.  Design and state discrete sets are\n// currently in both DesignAndStateLabelsCheck (check lengths) and\n// DiscSetLbl (duplicates and STL population)\n\n#define AVI &DataVariablesRep::\n/// Variables label array designations for design and state.  All\n/// non-uncertain variables need to be in this array.  Used in\n/// check_variables_node to check lengths and make_variable_defaults\n/// to build labels.\nstatic VarLabelChk DesignAndStateLabelsCheck[] = {\n  { AVI numContinuousDesVars, AVI continuousDesignLabels, \"cdv_\", \"cdv_descriptors\" },\n  { AVI numDiscreteDesRangeVars, AVI discreteDesignRangeLabels, \"ddriv_\", \"ddriv_descriptors\" },\n  { AVI numDiscreteDesSetIntVars, AVI discreteDesignSetIntLabels, \"ddsiv_\", \"ddsiv_descriptors\" },\n  { AVI numDiscreteDesSetStrVars, AVI discreteDesignSetStrLabels, \"ddssv_\", \"ddssv_descriptors\" },\n  { AVI numDiscreteDesSetRealVars, AVI discreteDesignSetRealLabels, \"ddsrv_\", \"ddsrv_descriptors\" },\n  { AVI numContinuousStateVars, AVI continuousStateLabels, \"csv_\", \"csv_descriptors\" },\n  { AVI numDiscreteStateRangeVars, AVI discreteStateRangeLabels, \"dsriv_\", \"dsriv_descriptors\" },\n  { AVI numDiscreteStateSetIntVars, AVI discreteStateSetIntLabels, \"dssiv_\", \"dssiv_descriptors\" },\n  { AVI numDiscreteStateSetStrVars, AVI discreteStateSetStrLabels, \"dsssv_\", \"dsssv_descriptors\" },\n  { AVI numDiscreteStateSetRealVars, AVI discreteStateSetRealLabels, \"dssrv_\", \"dssrv_descriptors\" },\n  { AVI numContinuousDesVars, AVI continuousDesignScaleTypes, 0, \"cdv_scale_types\" }\n};\n#undef  AVI\n\n/// structure for validating real uncertain variable labels, bounds, values\nstruct VLreal {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  RealVector DataVariablesRep::* LowerBnds;\n  RealVector DataVariablesRep::* UpperBnds;\n  RealVector DataVariablesRep::* UncVars;\n};\n\n/// structure for validating integer uncertain variable labels, bounds, values\nstruct VLint {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  IntVector DataVariablesRep::* LowerBnds;\n  IntVector DataVariablesRep::* UpperBnds;\n  IntVector DataVariablesRep::* UncVars;\n};\n\n/// structure for validating string uncertain variable labels, bounds, values\nstruct VLstr {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  StringArray DataVariablesRep::* LowerBnds;\n  StringArray DataVariablesRep::* UpperBnds;\n  StringArray DataVariablesRep::* UncVars;\n};\n\n/// number of real-valued   uncertain contiguous containers\nenum { NUM_UNC_REAL_CONT = 4 };\n/// number of int-valued    uncertain contiguous containers\nenum { NUM_UNC_INT_CONT = 2 }; \n/// number of string-valued uncertain contiguous containers\nenum { NUM_UNC_STR_CONT = 2 }; \n\n#define AVI (VarLabel Var_Info::*) &Var_Info::\t// cast to bypass g++ bug\n#define DVR &DataVariablesRep::\n\n/// Variables labels/bounds/values check array for real-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., CAUVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLreal VLUncertainReal[NUM_UNC_REAL_CONT] = {\n {CAUVar_Nkinds,  AVI CAUv,  CAUVLbl,\n\tDVR continuousAleatoryUncLabels,\n\tDVR continuousAleatoryUncLowerBnds,\n\tDVR continuousAleatoryUncUpperBnds,\n\tDVR continuousAleatoryUncVars},\n {CEUVar_Nkinds,  AVI CEUv,  CEUVLbl,\n\tDVR continuousEpistemicUncLabels,\n\tDVR continuousEpistemicUncLowerBnds,\n\tDVR continuousEpistemicUncUpperBnds,\n\tDVR continuousEpistemicUncVars},\n {DAURVar_Nkinds, AVI DAURv, DAURVLbl,\n\tDVR discreteRealAleatoryUncLabels,\n\tDVR discreteRealAleatoryUncLowerBnds,\n\tDVR discreteRealAleatoryUncUpperBnds,\n        DVR discreteRealAleatoryUncVars},\n {DEURVar_Nkinds, AVI DEURv, DEURVLbl,\n\tDVR discreteRealEpistemicUncLabels,\n\tDVR discreteRealEpistemicUncLowerBnds,\n\tDVR discreteRealEpistemicUncUpperBnds,\n\tDVR discreteRealEpistemicUncVars}};\n\n/// Variables labels/bounds/values check array for integer-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., DAUIVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLint VLUncertainInt[NUM_UNC_INT_CONT] = {\n {DAUIVar_Nkinds, AVI DAUIv, DAUIVLbl,\n\tDVR discreteIntAleatoryUncLabels,\n        DVR discreteIntAleatoryUncLowerBnds,\n        DVR discreteIntAleatoryUncUpperBnds,\n        DVR discreteIntAleatoryUncVars},\n {DEUIVar_Nkinds, AVI DEUIv, DEUIVLbl,\n\tDVR discreteIntEpistemicUncLabels,\n\tDVR discreteIntEpistemicUncLowerBnds,\n\tDVR discreteIntEpistemicUncUpperBnds,\n\tDVR discreteIntEpistemicUncVars}};\n\n/// Variables labels/bounds/values check array for string-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., DAUSVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLstr VLUncertainStr[NUM_UNC_STR_CONT] = {\n {DAUSVar_Nkinds, AVI DAUSv, DAUSVLbl,\n\tDVR discreteStrAleatoryUncLabels,\n\tDVR discreteStrAleatoryUncLowerBnds,\n\tDVR discreteStrAleatoryUncUpperBnds,\n        DVR discreteStrAleatoryUncVars},\n {DEUSVar_Nkinds, AVI DEUSv, DEUSVLbl,\n\tDVR discreteStrEpistemicUncLabels,\n\tDVR discreteStrEpistemicUncLowerBnds,\n\tDVR discreteStrEpistemicUncUpperBnds,\n\tDVR discreteStrEpistemicUncVars}};\n\n//#undef RDVR\n#undef\tDVR\n#undef  AVI\n\n/// which uncertain real check array containers are aleatory (true = 1)\nstatic int VLR_aleatory[NUM_UNC_REAL_CONT] = { 1, 0, 1, 0 };\n/// which uncertain integer check array containers are aleatory (true = 1)\nstatic int VLI_aleatory[NUM_UNC_INT_CONT] = { 1, 0 };\n/// which uncertain string check array containers are aleatory (true = 1)\nstatic int VLS_aleatory[NUM_UNC_STR_CONT] = { 1, 0 };\n\n\n/// Generate check data for variables with just name, size, and a\n/// generator function\n#define Vchk_3(x,y) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y}\n\n/// Generate check data for variables additionally with lower and\n/// upper bounds.  Some compilers in debug mode (MSVC) don't\n/// initialize the trailing two entries to NULL, so be explicit:\n#define Vchk_5(x,y,z) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y,&DataVariablesRep::z##LowerBnds,&DataVariablesRep::z##UpperBnds,NULL,NULL}\n\n/// Generate check data for variables additionally with initial point\n/// and labels\n#define Vchk_7(x,y,z) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y,&DataVariablesRep::z##LowerBnds,&DataVariablesRep::z##UpperBnds,&DataVariablesRep::z##Vars,&DataVariablesRep::z##Labels}\n\n// Trailing pointers in these initialization lists will be NULL. From C++ 2003:\n//   \"Objects with static storage shall be zero-initialized before any other\n//    initialization takes place.\"\n\n// These are used within make_variable_defaults(): Vgen_##y is applied\n// to generate bounds, adjust initial values\nstatic Var_check\n  var_mp_check_cv[] = {\n\tVchk_3(continuous_design,ContinuousDes),\n\tVchk_3(continuous_state,ContinuousState) },\n  var_mp_check_dset[] = {\n\tVchk_3(discrete_design_set_integer,DiscreteDesSetInt),\n\tVchk_3(discrete_design_set_string,DiscreteDesSetStr),\n\tVchk_3(discrete_design_set_real,DiscreteDesSetReal),\n\tVchk_3(discrete_state_set_integer,DiscreteStateSetInt),\n\tVchk_3(discrete_state_set_string,DiscreteStateSetStr),\n\tVchk_3(discrete_state_set_real,DiscreteStateSetReal) },\n  var_mp_check_cau[] = {\n\tVchk_3(normal_uncertain,NormalUnc),\n\tVchk_3(lognormal_uncertain,LognormalUnc),\n\tVchk_3(uniform_uncertain,UniformUnc),\n\tVchk_3(loguniform_uncertain,LoguniformUnc),\n\tVchk_3(triangular_uncertain,TriangularUnc),\n\tVchk_3(exponential_uncertain,ExponentialUnc),\n\tVchk_3(beta_uncertain,BetaUnc),\n\tVchk_3(gamma_uncertain,GammaUnc),\n\tVchk_3(gumbel_uncertain,GumbelUnc),\n\tVchk_3(frechet_uncertain,FrechetUnc),\n\tVchk_3(weibull_uncertain,WeibullUnc),\n\tVchk_3(histogram_bin_uncertain,HistogramBinUnc) },\n  var_mp_check_daui[] = {\n\tVchk_3(poisson_uncertain,PoissonUnc),\n\tVchk_3(binomial_uncertain,BinomialUnc),\n\tVchk_3(negative_binomial_uncertain,NegBinomialUnc),\n\tVchk_3(geometric_uncertain,GeometricUnc),\n\tVchk_3(hypergeometric_uncertain,HyperGeomUnc),\n\tVchk_3(histogram_point_int_uncertain,HistogramPtIntUnc) },\n  var_mp_check_daus[] = {\n\tVchk_3(histogram_point_str_uncertain,HistogramPtStrUnc) },\n  var_mp_check_daur[] = {\n\tVchk_3(histogram_point_real_uncertain,HistogramPtRealUnc) },\n  var_mp_check_ceu[] = {\n\tVchk_3(continuous_interval_uncertain,ContinuousIntervalUnc) },\n  var_mp_check_deui[] = {\n\tVchk_3(discrete_interval_uncertain,DiscreteIntervalUnc),\n\tVchk_3(discrete_uncertain_set_integer,DiscreteUncSetInt) },\n  var_mp_check_deus[] = {\n        Vchk_3(discrete_uncertain_set_string,DiscreteUncSetStr) },\n  var_mp_check_deur[] = {\n\tVchk_3(discrete_uncertain_set_real,DiscreteUncSetReal) };\n\n/// This is used within check_variables_node(): Var_RealBoundIPCheck()\n/// is applied to validate bounds and initial points\nstatic Var_rcheck\n  var_mp_cbound[] = {\n\tVchk_7(continuous_design,ContinuousDes,continuousDesign),\n\tVchk_7(continuous_state,ContinuousState,continuousState),\n\t// BMA: I believe these should these be promoted to Vchk_7,\n\t// but not easy to do since their labels are stored in an\n\t// aggregated array instead of individually\n\tVchk_5(normal_uncertain,NormalUnc,normalUnc),\n\tVchk_5(lognormal_uncertain,LognormalUnc,lognormalUnc),\n\tVchk_5(uniform_uncertain,UniformUnc,uniformUnc),\n\tVchk_5(loguniform_uncertain,LoguniformUnc,loguniformUnc),\n\tVchk_5(triangular_uncertain,TriangularUnc,triangularUnc),\n\tVchk_5(beta_uncertain,BetaUnc,betaUnc) };\n// gamma, gumbel, frechet, weibull, histogram_bin don't support bounds\n// from user input, so are omitted here?\n\n/// This is used in check_variables_node(): Var_IntBoundIPCheck() is\n/// applied to validate bounds and initial points, and in\n/// make_variable_defaults(): Vgen_* is called to infer bounds.\nstatic Var_icheck\n  var_mp_drange[] = {\n\tVchk_7(discrete_design_range,DiscreteDesRange,discreteDesignRange),\n\tVchk_7(discrete_state_range,DiscreteStateRange,discreteStateRange) };\n\n// would be used to check initial point, but those are covered in DiscSetLbl\n// static Var_scheck\n// var_mp_sbound[] = {\n//   Vchk_7(discrete_design_set_string,DiscreteDesSetStr,discreteDesignSetStr) };\n\n#undef Vchk_7\n#undef Vchk_5\n#undef Vchk_3\n\n\n/** Size arrays for contiguous storage of aggregated uncertain types.\n    For each variable type, call Vgen_* to generate inferred bounds\n    and initial point, repairing initial if needed. */\nvoid NIDRProblemDescDB::\nmake_variable_defaults(std::list<DataVariables>* dvl)\n{\n  DataVariablesRep *dv;\n  IntVector *IL, *IU, *IV;\n  StringArray *SL, *SU, *SV;\n  RealVector *L, *U, *V;\n  StringArray *sa;\n  VLreal *vlr;\n  VLint  *vli;\n  VLstr  *vls;\n  VarLabel *vl;\n  VarLabelChk *vlc, *vlce;\n  Var_uinfo *vui, *vuie;\n  char buf[32];\n  size_t i, j, k, n, nu, nursave[NUM_UNC_REAL_CONT], nuisave[NUM_UNC_INT_CONT], \n    nussave[NUM_UNC_STR_CONT];\n  static const char Inconsistent_bounds[] =\n    \"Inconsistent bounds on %s uncertain variables\";\n\n  /// size the aggregate arrays for uncertain (design and state are\n  /// stored separately\n  std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n  for(; It != Ite; ++It) {\n    dv = It->dataVarsRep;\n    // size the aggregate labels, bounds, values arrays for\n    // real-valued uncertain\n    for(k = 0; k < NUM_UNC_REAL_CONT; ++k) {\n      vlr = &VLUncertainReal[k];\n      vui = vlr->vui;\n      vuie = vui + vlr->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nursave[k] = nu;\n      if (!nu)\n\tcontinue;\n      L = &(dv->*vlr->LowerBnds);\n      U = &(dv->*vlr->UpperBnds);\n      V = &(dv->*vlr->UncVars);\n      L->sizeUninitialized(nu);\n      U->sizeUninitialized(nu);\n      V->sizeUninitialized(nu);\n    }\n    // size the aggregate labels, bounds, values arrays for\n    // integer-valued uncertain\n    for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n      vli = &VLUncertainInt[k];\n      vui = vli->vui;\n      vuie = vui + vli->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nuisave[k] = nu;\n      if (!nu)\n\tcontinue;\n      IL = &(dv->*vli->LowerBnds);\n      IU = &(dv->*vli->UpperBnds);\n      IV = &(dv->*vli->UncVars);\n      IL->sizeUninitialized(nu);\n      IU->sizeUninitialized(nu);\n      IV->sizeUninitialized(nu);\n    }\n    // size the aggregate labels, bounds, values arrays for\n    // string-valued uncertain\n    for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n      vls = &VLUncertainStr[k];\n      vui = vls->vui;\n      vuie = vui + vls->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nussave[k] = nu;\n      if (!nu)\n\tcontinue;\n      SL = &(dv->*vls->LowerBnds);\n      SU = &(dv->*vls->UpperBnds);\n      SV = &(dv->*vls->UncVars);\n      SL->resize(nu);\n      SU->resize(nu);\n      SV->resize(nu);\n    }\n\n    // inferred bound generation for continuous variable types;\n    // populates the individual (design/state) or aggregate\n    // (uncertain) arrays of bounds and values by applying Vgen_##y\n\n    // loop over cdv/csv\n    Var_check *c, *ce;\n    // the offset into the aggregated aleatory or epistemic arrays\n    size_t offset = 0; \n    for(c=var_mp_check_cv, ce = c + Numberof(var_mp_check_cv); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t(*c->vgen)(dv, offset); // offset not used\n    // loop over nuv/lnuv/uuv/luuv/truv/euv/buv/gauv/guuv/fuv/wuv/hbuv\n    // working with continuousAleatoryUnc*\n    for(c=var_mp_check_cau, ce=c + Numberof(var_mp_check_cau); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // continuous epistemic uncertain\n    offset = 0; // reset for combined epistemic arrays\n    for(c=var_mp_check_ceu, ce=c + Numberof(var_mp_check_ceu); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n\n    // inferred bound generation for discrete variable types;\n    // populates the individual (design/state) or aggregate\n    // (uncertain) arrays of bounds and values by applying Vgen_##y\n\n    // discrete design,state ranges\n    Var_icheck *ic, *ice;\n    offset = 0;\n    for(ic=var_mp_drange, ice=ic + Numberof(var_mp_drange); ic<ice; ++ic)\n      if ((n = dv->*ic->n) > 0)\n\t{ (*ic->vgen)(dv, offset); } // offset not used\n    // discrete int aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteIntAleatoryUnc*\n    for(c=var_mp_check_daui, ce=c + Numberof(var_mp_check_daui); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete string aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteStrAleatoryUnc*\n    offset = 0.;\n    for(c=var_mp_check_daus, ce=c + Numberof(var_mp_check_daus); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete real aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteRealAleatoryUnc*\n    offset = 0;\n    for(c=var_mp_check_daur, ce=c + Numberof(var_mp_check_daur); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete int epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteIntEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deui, ce=c + Numberof(var_mp_check_deui); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete string epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteStrEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deus, ce=c + Numberof(var_mp_check_deus); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete real epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteRealEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deur, ce=c + Numberof(var_mp_check_deur); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    \n    // check discrete design and state set types\n    // these don't use an offset passed into Vgen_Discrete*Set*\n    offset = 0;\n    for(c=var_mp_check_dset, ce=c + Numberof(var_mp_check_dset); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t(*c->vgen)(dv, offset); // offset not used\n\n\n    // Validate bounds (again?) for uncertain variables and set\n    // default labels for all types\n\n    // uncertain real: bounds check and label generation\n    for(k = 0; k < NUM_UNC_REAL_CONT; ++k) {\n      nu = nursave[k];\n      if (!nu)\n\tcontinue;\n      vlr = &VLUncertainReal[k];\n      vui = vlr->vui;\n      vuie = vui + vlr->n;\n      L = &(dv->*vlr->LowerBnds);\n      U = &(dv->*vlr->UpperBnds);\n      V = &(dv->*vlr->UncVars);\n      sa = &(dv->*vlr->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vlr->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*L)[i+j] > (*U)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // uncertain integer: bounds check and label generation\n    for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n      nu = nuisave[k];\n      if (!nu)\n\tcontinue;\n      vli = &VLUncertainInt[k];\n      vui = vli->vui;\n      vuie = vui + vli->n;\n      IL = &(dv->*vli->LowerBnds);\n      IU = &(dv->*vli->UpperBnds);\n      IV = &(dv->*vli->UncVars);\n      sa = &(dv->*vli->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vli->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*IL)[i+j] > (*IU)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // uncertain string: bounds check and label generation\n    for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n      nu = nussave[k];\n      if (!nu)\n\tcontinue;\n      vls = &VLUncertainStr[k];\n      vui = vls->vui;\n      vuie = vui + vls->n;\n      SL = &(dv->*vls->LowerBnds);\n      SU = &(dv->*vls->UpperBnds);\n      SV = &(dv->*vls->UncVars);\n      sa = &(dv->*vls->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vls->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*SL)[i+j] > (*SU)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // build labels for all design and state variables if needed\n    for(vlc = DesignAndStateLabelsCheck, vlce = vlc + Numberof(DesignAndStateLabelsCheck); vlc < vlce; ++vlc)\n      if (vlc->stub && (n = dv->*vlc->n)) {\n\tsa = &(dv->*vlc->sa);\n\tif (sa->size() == 0)\n\t  BuildLabels(sa, n, 0, n, vlc->stub);\n      }\n  }\n}\n\nvoid NIDRProblemDescDB::check_variables_node(void *v)\n{\n  IntArray *Ia; IntVector *Iv; RealVector *Rv; RealSymMatrix *Rm;\n  StringArray *sa, *Sa;\n  VLreal *vlr; VLint *vli; VLstr *vls;\n  VarLabel *vl;\n  VarLabelChk *vlc, *vlce;\n  Var_uinfo *vui, *vuie;\n  const char **sp;\n  int havelabels;\n  size_t i, j, k, n, nd, nu, nuk, nutot, nv;\n\n#define AVI &Var_Info::\n  // Used for deallocation of Var_Info temporary data\n  static IntArray   *Var_Info::* Ia_delete[]\n    = { AVI nddsi, AVI nddss, AVI nddsr, AVI nCI, AVI nDI, AVI nhbp, \n\tAVI nhpip, AVI nhpsp, AVI nhprp, AVI ndusi, AVI nduss, AVI ndusr, \n\tAVI ndssi, AVI ndssr };\n  static RealVector *Var_Info::* Rv_delete[]\n    = { AVI ddsr, AVI CIlb, AVI CIub, AVI CIp, AVI DIp,\n\tAVI DSIp, AVI DSSp, AVI DSRp,\n\tAVI dusr, AVI hba, AVI hbo, AVI hbc, \n\tAVI hpic, AVI hpsc, AVI hpra, AVI hprc, \n\tAVI ucm,\n\tAVI dssr };\n  static IntVector *Var_Info::* Iv_delete[]\n    = { AVI ddsi, AVI DIlb, AVI DIub, AVI dusi, AVI dssi };\n  static StringArray *Var_Info::* Sa_delete[]\n    = { AVI ddss, AVI duss, AVI dsss };\n#undef AVI\n\n  Var_Info *vi = (Var_Info*)v;\n  DataVariablesRep *dv = vi->dv;\n\n  // check label lengths for design and state variables, if present\n  nv = 0;\n  for(vlc = DesignAndStateLabelsCheck, vlce = vlc + Numberof(DesignAndStateLabelsCheck); \n      vlc < vlce; ++vlc)\n    if ((n = dv->*vlc->n)) {\n      if (vlc->stub)\n\tnv += n;\n      sa = &(dv->*vlc->sa);\n      if ((nu = sa->size())) {\n\tif (nu != n) {\n\t  if (nu == 1 && !vlc->stub)\n\t    continue;\n\t  squawk(\"Found %lu rather than %lu %s values\",\n\t\t (UL)nu, (UL)n, vlc->name);\n\t}\n      }\n    }\n\n  // Now check uncertain variables.  Calls the Vchk_* functions (e.g.,\n  // Vchk_NormalUnc) for each variable type, which for simple\n  // uncertain variables check lengths, but for histograms and\n  // intervals, translate the data into arrays of maps.\n\n  // uncertain real\n  for(k = nu = nutot = 0; k < NUM_UNC_REAL_CONT; ++k) {\n    vlr = &VLUncertainReal[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vlr->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vlr->vui;\n    for(vuie = vui + vlr->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLR_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vlr->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vlr->VL);\n      for(vui = vlr->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain integer\n  for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n    vli = &VLUncertainInt[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vli->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vli->vui;\n    for(vuie = vui + vli->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLI_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vli->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vli->VL);\n      for(vui = vli->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain string\n  for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n    vls = &VLUncertainStr[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vls->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vls->vui;\n    for(vuie = vui + vls->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLS_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vls->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vls->VL);\n      for(vui = vls->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain_correlation_matrix\n  if ((Rv = vi->ucm)) {\n    n = Rv->length();\n    if (n != nu*nu) {\n      static char ucmerr[]\n\t= \"Got %lu entries for the uncertain_correlation_matrix\\n\\\n\tbut needed %lu for %lu uncertain variables\";\n      squawk(ucmerr, (UL)n, (UL)nu*nu, (UL)nu);\n    }\n    else {\n      Rm = &dv->uncertainCorrelations;\n      Rm->reshape(nu);\n      for(i = k = 0; i < nu; ++i) {\n\tfor(j = 0; j < nu;)\n\t  (*Rm)(i,j++) = (*Rv)[k++];\n      }\n    }\n  }\n\n  // The above functions don't validate the initial point; those below do\n\n  // Check discrete design and state set variables.  Call Vchk_* for\n  // the discrete design and state set (integer/string/real) types,\n  // e.g, Vchk_DiscreteDesSetInt; these check for duplicates, validate\n  // that initial point is in the set, and populate arrays of maps or\n  // other STL data structures\n  nd = 0;\n  for(vui=DiscSetLbl, vuie=DiscSetLbl+DiscSetVar_Nkinds; vui<vuie; ++vui) {\n    if ((n = dv->*vui->n) > 0) {\n      vui->vchk(dv,0,vi);\n      nd += n;\n    }\n  }\n\n  if (nd + nv + nutot == 0)\n    squawk(\"at least one variable must be specified\");\n\n  // Check bounds and adjust initial points for remaining types.\n\n  // TODO: these don't support explicit bounds, but their initial\n  // point could still be validated here: gamma, gumbel, frechet,\n  // weibull, histogram_bin, poisson, binomial, negative_binomial,\n  // geometric, hypergeometric, histogram_point\n\n  // TODO: continuous and discrete interval, initial point not checked\n  // anywhere?\n\n  // Continuous bound specs: cdv/csv/nuv/lnuv/uuv/luuv/truv/buv\n  Var_rcheck *rc, *rce;\n  for(rc = var_mp_cbound, rce = rc + Numberof(var_mp_cbound); rc < rce; ++rc)\n    Var_RealBoundIPCheck(dv, rc);\n\n  // Discrete bound specs: design,state ranges\n  Var_icheck *ic, *ice;\n  for(ic = var_mp_drange, ice = ic + Numberof(var_mp_drange); ic < ice; ++ic)\n    Var_IntBoundIPCheck(dv, ic);\n  \n\n  // deallocate temporary Var_Info data\n  n = Numberof(Ia_delete);\n  for(i = 0; i < n; i++)\n    if ((Ia = vi->*Ia_delete[i]))\n      delete Ia;\n  n = Numberof(Rv_delete);\n  for(i = 0; i < n; i++)\n    if ((Rv = vi->*Rv_delete[i]))\n      delete Rv;\n  n = Numberof(Iv_delete);\n  for(i = 0; i < n; i++)\n    if ((Iv = vi->*Iv_delete[i]))\n      delete Iv;\n  n = Numberof(Sa_delete);\n  for(i = 0; i < n; i++)\n    if ((Sa = vi->*Sa_delete[i]))\n      delete Sa;\n  delete vi;\n\n  if (nerr)\n    abort_handler(PARSE_ERROR);\n}\n\n\nstatic void flatten_rva(RealVectorArray *rva, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv, *rv_i;\n\n  m = rva->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rva)[i].length();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rv_i = &(*rva)[i];\n    n = rv_i->length();\n    for(j = 0; j < n; ++j, ++k)\n      (*rv)[k] = (*rv_i)[j];\n  }\n}\n\nstatic void flatten_iva(IntVectorArray *iva, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv, *iv_i;\n\n  m = iva->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*iva)[i].length();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    iv_i = &(*iva)[i];\n    n = iv_i->length();\n    for(j = 0; j < n; ++j, ++k)\n      (*iv)[k] = (*iv_i)[j];\n  }\n}\n\nstatic void flatten_rsm(RealSymMatrix *rsm, RealVector **prv)\n{\n  size_t i, j, m, n;\n  RealVector *rv;\n\n  m = rsm->numRows();\n  *prv = rv = new RealVector(m*m, false);\n  for(i = n = 0; i < m; ++i)\n    for(j = 0; j < m; ++j, ++n)\n      (*rv)[n] = (*rsm)(i,j);\n}\n\nstatic void flatten_rsa(RealSetArray *rsa, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealSet *rs_i;\n  RealSet::iterator rs_it, rs_ite;\n\n  m = rsa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rsa)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rs_i = &(*rsa)[i];\n    for(rs_it=rs_i->begin(), rs_ite=rs_i->end(); rs_it!=rs_ite; ++rs_it, ++k)\n      (*rv)[k] = *rs_it;\n  }\n}\n\nstatic void flatten_ssa(StringSetArray *ssa, StringArray **psa)\n{\n  size_t i, j, k, m, n;\n  StringArray *sa;\n  StringSet *ss_i;\n  SSIter ss_it, ss_ite;\n\n  m = ssa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*ssa)[i].size();\n  *psa = sa = new StringArray(n);\n  for(i = k = 0; i < m; ++i) {\n    ss_i = &(*ssa)[i];\n    for(ss_it=ss_i->begin(), ss_ite=ss_i->end(); ss_it!=ss_ite; ++ss_it, ++k)\n      (*sa)[k] = *ss_it;\n  }\n}\n\nstatic void flatten_isa(IntSetArray *isa, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv;\n  IntSet *is_i;\n  IntSet::iterator is_it, is_ite;\n\n  m = isa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*isa)[i].size();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    is_i = &(*isa)[i];\n    for(is_it=is_i->begin(), is_ite=is_i->end(); is_it!=is_ite; ++is_it, ++k)\n      (*iv)[k] = *is_it;\n  }\n}\n\nstatic void flatten_rrma_keys(RealRealMapArray *rrma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealRealMap *rrm_i;\n  RealRealMap::iterator rrm_it, rrm_ite;\n\n  m = rrma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rrma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rrm_i = &(*rrma)[i];\n    for (rrm_it=rrm_i->begin(), rrm_ite=rrm_i->end();\n\t rrm_it!=rrm_ite; ++rrm_it, ++k)\n      (*rv)[k] = rrm_it->first;\n  }\n}\n\nstatic void flatten_rrma_values(RealRealMapArray *rrma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealRealMap *rrm_i;\n  RealRealMap::iterator rrm_it, rrm_ite;\n\n  m = rrma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rrma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rrm_i = &(*rrma)[i];\n    for (rrm_it=rrm_i->begin(), rrm_ite=rrm_i->end();\n\t rrm_it!=rrm_ite; ++rrm_it, ++k)\n      (*rv)[k] = rrm_it->second;\n  }\n}\n\nstatic void flatten_irma_keys(IntRealMapArray *irma, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv;\n  IntRealMap *irm_i;\n  IntRealMap::iterator irm_it, irm_ite;\n\n  m = irma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*irma)[i].size();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    irm_i = &(*irma)[i];\n    for (irm_it=irm_i->begin(), irm_ite=irm_i->end();\n\t irm_it!=irm_ite; ++irm_it, ++k)\n      (*iv)[k] = irm_it->first;\n  }\n}\n\nstatic void flatten_irma_values(IntRealMapArray *irma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  IntRealMap *irm_i;\n  IntRealMap::iterator irm_it, irm_ite;\n\n  m = irma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*irma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    irm_i = &(*irma)[i];\n    for (irm_it=irm_i->begin(), irm_ite=irm_i->end();\n\t irm_it!=irm_ite; ++irm_it, ++k)\n      (*rv)[k] = irm_it->second;\n  }\n}\n\nstatic void flatten_srma_keys(StringRealMapArray *srma, StringArray **psa)\n{\n  size_t i, j, k, m, n;\n  StringArray *sa;\n  StringRealMap *srm_i;\n  StringRealMap::iterator srm_it, srm_ite;\n\n  m = srma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*srma)[i].size();\n  *psa = sa = new StringArray(n);\n  for(i = k = 0; i < m; ++i) {\n    srm_i = &(*srma)[i];\n    for (srm_it=srm_i->begin(), srm_ite=srm_i->end();\n\t srm_it!=srm_ite; ++srm_it, ++k)\n      (*sa)[k] = srm_it->first;\n  }\n}\n\nstatic void flatten_srma_values(StringRealMapArray *srma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  StringRealMap *srm_i;\n  StringRealMap::iterator srm_it, srm_ite;\n\n  m = srma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*srma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    srm_i = &(*srma)[i];\n    for (srm_it=srm_i->begin(), srm_ite=srm_i->end();\n\t srm_it!=srm_ite; ++srm_it, ++k)\n      (*rv)[k] = srm_it->second;\n  }\n}\n\n/// Flatten real-valued interval uncertain variable intervals and\n/// probabilities back into separate arrays.\nstatic void flatten_real_intervals(const RealRealPairRealMapArray& rrprma, \n\t\t\t\t   RealVector **probs, \n\t\t\t\t   RealVector **lb, RealVector** ub)\n{\n  size_t i, j, k, m, n;\n  RealVector *rvp, *rvlb, *rvub;\n\n  m = rrprma.size();\n  for(i = n = 0; i < m; ++i)\n    n += rrprma[i].size();\n  *probs = rvp = new RealVector(n, false);\n  *lb = rvlb = new RealVector(n, false);\n  *ub = rvub = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    const RealRealPairRealMap& rrprm_i = (rrprma)[i];\n    RealRealPairRealMap::const_iterator rrprm_it = rrprm_i.begin();\n    RealRealPairRealMap::const_iterator rrprm_ite = rrprm_i.end();\n    for ( ; rrprm_it != rrprm_ite; ++rrprm_it, ++k) {\n      const RealRealPair& interval = rrprm_it->first;\n      Real prob = rrprm_it->second;\n      (*rvp)[k] = prob;\n      (*rvlb)[k] = interval.first;\n      (*rvub)[k] = interval.second;\n    }\n  }\n}\n\n/// Flatten integer-valued interval uncertain variable intervals and\n/// probabilities back into separate arrays.\nstatic void flatten_int_intervals(const IntIntPairRealMapArray& iiprma, \n\t\t\t\t  RealVector **probs, \n\t\t\t\t  IntVector **lb, IntVector** ub)\n{\n  size_t i, j, k, m, n;\n  RealVector *ivp;\n  IntVector *ivlb, *ivub;\n\n  m = iiprma.size();\n  for(i = n = 0; i < m; ++i)\n    n += iiprma[i].size();\n  *probs = ivp = new RealVector(n, false);\n  *lb = ivlb = new IntVector(n, false);\n  *ub = ivub = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    const IntIntPairRealMap& iiprm_i = iiprma[i];\n    IntIntPairRealMap::const_iterator iiprm_it = iiprm_i.begin();\n    IntIntPairRealMap::const_iterator iiprm_ite = iiprm_i.end();\n    for ( ; iiprm_it != iiprm_ite; ++iiprm_it, ++k) {\n      const IntIntPair& interval = iiprm_it->first;\n      Real prob = iiprm_it->second;\n      (*ivp)[k] = prob;\n      (*ivlb)[k] = interval.first;\n      (*ivub)[k] = interval.second;\n    }\n  }\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_descriptors(const StringArray& labels) {\n  StringArray::const_iterator li = labels.begin();\n  String::const_iterator si;\n  for(; li != labels.end(); ++li) {\n    // error if descriptor contains whitespace\n    for(si = li->begin(); si != li->end(); ++si) {\n      if(isspace(*si)) {\n        Squawk(\"Descriptor \\\"%s\\\" is invalid: whitespace not permitted\", \n              li->c_str());\n        break;\n      }\n    }\n    if(isfloat(*li)) {\n      Squawk(\"Descriptor \\\"%s\\\" is invalid: floating point numbers not permitted\",\n          li->c_str());\n    }\n  }\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_variables(std::list<DataVariables>* dvl)\n{\n  // BMA: If parse was called, then the Var_Info objects have already\n  // been populated; in the case of pure DB insertion in library mode,\n  // they won't be and some data from DataVariables needs to be mapped\n  // back to the flat Var_Info structures.  Not sure if this correctly\n  // captures the case where a parse is followed by a DB update of an\n  // input keyword not accounted for below\n\n\n  // validate descriptors. The string arrays are empty unless the user\n  // explicitly set descriptors.\n  std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n  for(; It != Ite; ++It) {\n    const DataVariablesRep* dvr = It->data_rep();\n    check_descriptors(dvr->continuousDesignLabels);\n    check_descriptors(dvr->discreteDesignRangeLabels);\n    check_descriptors(dvr->discreteDesignSetIntLabels);\n    check_descriptors(dvr->discreteDesignSetStrLabels);\n    check_descriptors(dvr->discreteDesignSetRealLabels);\n    check_descriptors(dvr->continuousStateLabels);\n    check_descriptors(dvr->discreteStateRangeLabels);\n    check_descriptors(dvr->discreteStateSetIntLabels);\n    check_descriptors(dvr->discreteStateSetStrLabels);\n    check_descriptors(dvr->discreteStateSetRealLabels);\n    check_descriptors(dvr->continuousAleatoryUncLabels);\n    check_descriptors(dvr->discreteIntAleatoryUncLabels);\n    check_descriptors(dvr->discreteStrAleatoryUncLabels);\n    check_descriptors(dvr->discreteRealAleatoryUncLabels);\n    check_descriptors(dvr->continuousEpistemicUncLabels);\n    check_descriptors(dvr->discreteIntEpistemicUncLabels);\n    check_descriptors(dvr->discreteStrEpistemicUncLabels);\n    check_descriptors(dvr->discreteRealEpistemicUncLabels);\n  }\n\n  if (pDDBInstance) {\n    std::list<void*>::iterator It, Ite = pDDBInstance->VIL.end();\n    for(It = pDDBInstance->VIL.begin(); It != Ite; ++It)\n      check_variables_node(*It);\n    pDDBInstance->VIL.clear();\n  }\n  else {\n    // library mode with manual provision of everything\n    // map all data back into NIDR Var_Info structures\n    DataVariablesRep *dv;\n    IntArray *ia;\n    RealSymMatrix *rsm;\n    IntVector *iv_a;\n    StringArray *sa_a;\n    RealVector *rv, *rv_a, *rv_c;\n    RealVectorArray *rva;\n    Var_Info *vi;\n    size_t i, j, m, n, cntr;\n    int num_prs_i, total_prs;\n\n    // copy from DataVariables into Var_Info so that check_variables_node() can\n    // go the other direction.  TO DO: can we eliminate this circular update?\n    std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n    for(; It != Ite; ++It) {\n\n      // create new Var_Info instance to hold DataVariables data\n\n      vi = new Var_Info;\n      memset(vi, 0, sizeof(Var_Info));\n      vi->dv_handle = &*It;\n      vi->dv = dv = It->dataVarsRep;\n\n      // flatten 2D {Real,Int}{Vector,Set}Arrays back into Var_Info 1D arrays\n\n      // discrete design set int vars\n      if ((n = dv->numDiscreteDesSetIntVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetInt, &vi->nddsi);\n\tflatten_isa(&dv->discreteDesignSetInt,     &vi->ddsi);\n      }\n      // discrete design set string vars\n      if ((n = dv->numDiscreteDesSetStrVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetStr, &vi->nddss);\n\tflatten_ssa(&dv->discreteDesignSetStr,     &vi->ddss);\n      }\n      // discrete design set real vars\n      if ((n = dv->numDiscreteDesSetRealVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetReal, &vi->nddsr);\n\tflatten_rsa(&dv->discreteDesignSetReal,     &vi->ddsr);\n      }\n      // histogram bin uncertain vars\n      // convert RealRealMapArray to RealVectors of abscissas and counts\n      const RealRealMapArray& hbp = dv->histogramUncBinPairs;\n      if ((m = hbp.size())) {\n\tvi->nhbp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hbp[i].size();\n\tvi->hba = rv_a = new RealVector(total_prs); // abscissas\n\tvi->hbc = rv_c = new RealVector(total_prs); // counts\n\tvi->hbo = NULL;                            // no ordinates\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  RRMCIter it = hbp[i].begin();\n\t  RRMCIter it_end = hbp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*rv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramBinUnc going other direction\n\t}\n      }\n\n      // histogram point int uncertain vars\n      // convert IntRealMapArray to Int/RealVectors of abscissas and counts\n      const IntRealMapArray& hpip = dv->histogramUncPointIntPairs;\n      if ((m = hpip.size())) {\n\tvi->nhpip = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hpip[i].size();\n\tvi->hpia = iv_a = new IntVector(total_prs); // abscissas\n\tvi->hpic = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  IRMCIter it = hpip[i].begin();\n\t  IRMCIter it_end = hpip[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*iv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // histogram point string uncertain vars\n      // convert StringRealMapArray to String/RealVectors of abscissas and counts\n      const StringRealMapArray& hpsp = dv->histogramUncPointStrPairs;\n      if ((m = hpsp.size())) {\n\tvi->nhpsp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hpsp[i].size();\n\tvi->hpsa = sa_a = new StringArray(total_prs); // abscissas\n\tvi->hpsc = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  SRMCIter it = hpsp[i].begin();\n\t  SRMCIter it_end = hpsp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*sa_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // histogram point real uncertain vars\n      // convert RealRealMapArray to RealVectors of abscissas and counts\n      const RealRealMapArray& hprp = dv->histogramUncPointRealPairs;\n      if ((m = hprp.size())) {\n\tvi->nhprp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hprp[i].size();\n\tvi->hpra = rv_a = new RealVector(total_prs); // abscissas\n\tvi->hprc = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  RRMCIter it = hprp[i].begin();\n\t  RRMCIter it_end = hprp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*rv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // uncertain correlation matrix\n      if (dv->uncertainCorrelations.numRows())\n\tflatten_rsm(&dv->uncertainCorrelations, &vi->ucm);\n      // continuous interval uncertain vars\n      if ((n = dv->numContinuousIntervalUncVars)) {\n\tflatten_num_array(dv->continuousIntervalUncBasicProbs, &vi->nCI);\n\t// unroll the array of maps in to separate variables (p, lb, ub)\n\tflatten_real_intervals(dv->continuousIntervalUncBasicProbs, \n\t\t\t       &vi->CIp, &vi->CIlb, &vi->CIub);\n      }\n      // discrete interval uncertain vars\n      if ((n = dv->numDiscreteIntervalUncVars)) {\n\tflatten_num_array(dv->discreteIntervalUncBasicProbs, &vi->nDI);\n\t// unroll the array of maps in to separate variables (p, lb, ub)\n\tflatten_int_intervals(dv->discreteIntervalUncBasicProbs, \n\t\t\t      &vi->DIp, &vi->DIlb, &vi->DIub);\n      }\n      // discrete uncertain set int vars\n      if ((n = dv->numDiscreteUncSetIntVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetIntValuesProbs,    &vi->ndusi);\n\tflatten_irma_keys(&dv->discreteUncSetIntValuesProbs,   &vi->dusi);\n\tflatten_irma_values(&dv->discreteUncSetIntValuesProbs, &vi->DSIp);\n      }\n      // discrete uncertain set str vars\n      if ((n = dv->numDiscreteUncSetStrVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetStrValuesProbs,    &vi->nduss);\n\tflatten_srma_keys(&dv->discreteUncSetStrValuesProbs,   &vi->duss);\n\tflatten_srma_values(&dv->discreteUncSetStrValuesProbs, &vi->DSSp);\n      }\n      // discrete uncertain set real vars\n      if ((n = dv->numDiscreteUncSetRealVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetRealValuesProbs,    &vi->ndusr);\n\tflatten_rrma_keys(&dv->discreteUncSetRealValuesProbs,   &vi->dusr);\n\tflatten_rrma_values(&dv->discreteUncSetRealValuesProbs, &vi->DSRp);\n      }\n      // discrete state set int vars\n      if ((n = dv->numDiscreteStateSetIntVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetInt, &vi->ndssi);\n\tflatten_isa(&dv->discreteStateSetInt,     &vi->dssi);\n      }\n      // discrete state set string vars\n      if ((n = dv->numDiscreteStateSetStrVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetStr, &vi->ndsss);\n\tflatten_ssa(&dv->discreteStateSetStr,     &vi->dsss);\n      }\n      // discrete state set real vars\n      if ((n = dv->numDiscreteStateSetRealVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetReal, &vi->ndssr);\n\tflatten_rsa(&dv->discreteStateSetReal,     &vi->dssr);\n      }\n\n      check_variables_node((void*)vi);\n    }\n  }\n}\n\nvoid NIDRProblemDescDB::\nvar_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->**(String DataVariablesRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nvar_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa = &((*(Var_Info**)g)->dv->**(StringArray DataVariablesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nstatic void\nvar_iulbl(const char *keyname, Values *val, VarLabel *vl)\n{\n  char *t;\n  const char **s, **sl;\n  size_t i, L, n;\n\n  L = n = val->n;\t// n for null\n  s = val->s;\n  for(i = 0; i < n; i++)\n    L += strlen(s[i]);\n  vl->s = sl = (const char **)malloc(n*sizeof(char*) + L);\n  if (!sl)\n    NIDRProblemDescDB::botch(\"malloc failure in var_ulbl\");\n  vl->n = n;\n  t = (char*)(sl + n);\n  for(i = 0; i < n; i++) {\n    strcpy(t, s[i]);\n    sl[i] = (const char*)t;\n    t += strlen(t) + 1;\n  }\n}\n\nvoid NIDRProblemDescDB::\nvar_caulbl(const char *keyname, Values *val, void **g, void *v)\n{\n  // IRIX disallows (int)v, so we use the circumlocution (char*)v - (char*)0.\n  VarLabel *vl = &(*(Var_Info**)g)->CAUv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_ceulbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->CEUv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_dauilbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAUIv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deuilbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEUIv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_dauslbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAUSv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deuslbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEUSv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_daurlbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAURv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deurlbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEURv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\n#define MP_(x) DataInterfaceRep::* iface_mp_##x = &DataInterfaceRep::x\n#define MP2(x,y) iface_mp_##x##_##y = {&DataInterfaceRep::x,#y}\n#define MP2s(x,y) iface_mp_##x##_##y = {&DataInterfaceRep::x,y}\n#define MP3(x,y,z) iface_mp_TYPE_DATA_##x##_##z = {&DataInterfaceRep::x,&DataInterfaceRep::y,#z}\n\nstatic Iface_mp_Rlit\n\tMP3(failAction,recoveryFnVals,recover);\n\nstatic Iface_mp_ilit\n\tMP3(failAction,retryLimit,retry);\n\nstatic Iface_mp_lit\n\tMP2(failAction,abort),\n\tMP2(failAction,continuation);\n\nstatic Iface_mp_type\n\tMP2s(analysisScheduling,MASTER_SCHEDULING),\n\tMP2s(analysisScheduling,PEER_SCHEDULING),\n      //MP2s(analysisScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(analysisScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(evalScheduling,MASTER_SCHEDULING),\n\tMP2s(evalScheduling,PEER_DYNAMIC_SCHEDULING),\n\tMP2s(evalScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(asynchLocalEvalScheduling,DYNAMIC_SCHEDULING),\n        MP2s(asynchLocalEvalScheduling,STATIC_SCHEDULING),\n        MP2s(interfaceSynchronization,ASYNCHRONOUS_INTERFACE),\n        MP2s(interfaceSynchronization,SYNCHRONOUS_INTERFACE);\n\nstatic Iface_mp_utype\n\tMP2s(interfaceType,TEST_INTERFACE),\n\tMP2s(interfaceType,FORK_INTERFACE),\n\tMP2s(interfaceType,GRID_INTERFACE),\n\tMP2s(interfaceType,MATLAB_INTERFACE),\n\tMP2s(interfaceType,PYTHON_INTERFACE),\n\tMP2s(interfaceType,SCILAB_INTERFACE),\n\tMP2s(interfaceType,SYSTEM_INTERFACE),\n\t//MP2s(resultsFileFormat,FLEXIBLE_RESULTS), // re-enable when more formats added?\n\tMP2s(resultsFileFormat,LABELED_RESULTS);\n\nstatic String\n\tMP_(algebraicMappings),\n\tMP_(idInterface),\n\tMP_(inputFilter),\n\tMP_(outputFilter),\n\tMP_(parametersFile),\n\tMP_(resultsFile),\n\tMP_(workDir);\n\nstatic String2DArray\n\tMP_(analysisComponents);\n\nstatic StringArray\n\tMP_(analysisDrivers),\n        MP_(copyFiles),\n\tMP_(linkFiles);\n\nstatic bool\n\tMP_(activeSetVectorFlag),\n\tMP_(allowExistingResultsFlag),\n\tMP_(apreproFlag),\n\tMP_(dirSave),\n\tMP_(dirTag),\n\tMP_(evalCacheFlag),\n\tMP_(fileSaveFlag),\n\tMP_(fileTagFlag),\n\tMP_(nearbyEvalCacheFlag),\n\tMP_(numpyFlag),\n\tMP_(restartFileFlag),\n\tMP_(templateReplace),\n\tMP_(useWorkdir),\n\tMP_(verbatimFlag);\n\nstatic int\n\tMP_(analysisServers),\n\tMP_(asynchLocalAnalysisConcurrency),\n\tMP_(asynchLocalEvalConcurrency),\n\tMP_(evalServers),\n\tMP_(procsPerAnalysis),\n\tMP_(procsPerEval);\n\nstatic Real\n\tMP_(nearbyEvalCacheTol);\n\n#undef MP3\n#undef MP2s\n#undef MP2\n#undef MP_\n\n\n// Macros for Method\n\n#define MP_(x) DataMethodRep::* method_mp_##x = &DataMethodRep::x\n#define MP2(x,y) method_mp_##x##_##y = {&DataMethodRep::x,#y}\n#define MP2s(x,y) method_mp_##x##_##y = {&DataMethodRep::x,y}\n#if HAVE_OPTPP\n#  define MP2o(x,y) method_mp_##x##_##y = {&DataMethodRep::x,OPTPP::y}\n#else\n#  define MP2o(x,y) method_mp_##x##_##y = {NULL, NULL}\n#endif\n#define MP2p(x,y) method_mp_##x##_##y = {&DataMethodRep::x,Pecos::y}\n#define MP3(x,y,z) method_mp_TYPE_DATA_##x##_##z = {&DataMethodRep::x,&DataMethodRep::y,#z}\n#define MP3s(x,y,z) method_mp_TYPE_DATA_##x##_##z = {&DataMethodRep::x,&DataMethodRep::y,z}\n\nstatic IntVector\n\tMP_(primeBase),\n\tMP_(sequenceLeap),\n\tMP_(sequenceStart),\n\tMP_(stepsPerVariable);\n\nstatic Method_mp_ilit2\n\tMP3(replacementType,numberRetained,chc),\n\tMP3(replacementType,numberRetained,elitist),\n\tMP3(replacementType,numberRetained,random);\n\nstatic Method_mp_ilit2z\n\tMP3(crossoverType,numCrossPoints,multi_point_binary),\n\tMP3(crossoverType,numCrossPoints,multi_point_parameterized_binary),\n\tMP3(crossoverType,numCrossPoints,multi_point_real);\n\nstatic Method_mp_lit\n\tMP2(batchSelectionType,naive),\n\tMP2(batchSelectionType,distance_penalty),\n\tMP2(batchSelectionType,topology),\n\tMP2(batchSelectionType,constant_liar),\n\tMP2(boxDivision,all_dimensions),\n\tMP2(boxDivision,major_dimension),\n\tMP2(convergenceType,average_fitness_tracker),\n\tMP2(convergenceType,best_fitness_tracker),\n\tMP2(convergenceType,metric_tracker),\n\tMP2(crossoverType,blend),\n\tMP2(crossoverType,two_point),\n\tMP2(crossoverType,uniform),\n        MP2(dataDistCovInputType,diagonal),\n        MP2(dataDistCovInputType,matrix),\n      //MP2(dataDistType,gaussian),\n      //MP2(dataDistType,user),\n\tMP2(evalSynchronize,blocking),\n\tMP2(evalSynchronize,nonblocking),\n\tMP2(expansionSampleType,incremental_lhs),\n\tMP2(exploratoryMoves,adaptive),\n\tMP2(exploratoryMoves,multi_step),\n\tMP2(exploratoryMoves,simple),\n\tMP2(fitnessType,domination_count),\n\tMP2(fitnessType,layer_rank),\n\tMP2(fitnessType,linear_rank),\n\tMP2(fitnessType,merit_function),\n\tMP2(fitnessType,proportional),\n\tMP2(fitnessMetricType,predicted_variance),\n\tMP2(fitnessMetricType,distance),\n\tMP2(fitnessMetricType,gradient),\n      //MP2(hybridCollabType,abo),\n      //MP2(hybridCollabType,hops),\n      //MP2(seqHybridType,adaptive),\n\tMP2(initializationType,random),\n\tMP2(initializationType,unique_random),\n\tMP2(lipschitzType,global),\n\tMP2(lipschitzType,local),\n        MP2(meritFunction,merit_max),\n        MP2(meritFunction,merit_max_smooth),\n        MP2(meritFunction,merit1),\n        MP2(meritFunction,merit1_smooth),\n        MP2(meritFunction,merit2),\n        MP2(meritFunction,merit2_smooth),\n        MP2(meritFunction,merit2_squared),\n\tMP2(mcmcType,adaptive_metropolis),\n\tMP2(mcmcType,delayed_rejection),\n\tMP2(mcmcType,dram),\n\tMP2(mcmcType,metropolis_hastings),\n\tMP2(mcmcType,multilevel),\n\tMP2(mutationType,bit_random),\n\tMP2(mutationType,offset_cauchy),\n\tMP2(mutationType,offset_normal),\n\tMP2(mutationType,offset_uniform),\n\tMP2(mutationType,replace_uniform),\n\tMP2(patternBasis,coordinate),\n\tMP2(patternBasis,simplex),\n\tMP2(pointReuse,all),\n        MP2(proposalCovInputType,diagonal),\n        MP2(proposalCovInputType,matrix),\n        MP2(proposalCovType,derivatives),\n        MP2(proposalCovType,prior),\n        MP2(proposalCovType,user),\n\tMP2(reliabilityIntegration,first_order),\n\tMP2(reliabilityIntegration,second_order),\n\tMP2(replacementType,elitist),\n\tMP2(replacementType,favor_feasible),\n\tMP2(replacementType,roulette_wheel),\n\tMP2(replacementType,unique_roulette_wheel),\n\tMP2(rngName,mt19937),\n\tMP2(rngName,rnum2),\n\tMP2(searchMethod,gradient_based_line_search),\n\tMP2(searchMethod,tr_pds),\n\tMP2(searchMethod,trust_region),\n\tMP2(searchMethod,value_based_line_search),\n\tMP2(trialType,grid),\n\tMP2(trialType,halton),\n\tMP2(trialType,random);\n\nstatic Method_mp_litc\n\tMP3(crossoverType,crossoverRate,shuffle_random),\n\tMP3(crossoverType,crossoverRate,null_crossover),\n\tMP3(mutationType,mutationRate,null_mutation),\n\tMP3(mutationType,mutationRate,offset_cauchy),\n\tMP3(mutationType,mutationRate,offset_normal),\n\tMP3(mutationType,mutationRate,offset_uniform),\n\tMP3(replacementType,fitnessLimit,below_limit);\n\nstatic Method_mp_litrv\n\tMP3(nichingType,nicheVector,distance),\n\tMP3(nichingType,nicheVector,max_designs),\n\tMP3(nichingType,nicheVector,radial),\n\tMP3(postProcessorType,distanceVector,distance_postprocessor);\n\nstatic Method_mp_slit2\n\tMP3(initializationType,flatFile,flat_file);\n\nstatic Method_mp_utype_lit\n        MP3s(methodName,dlDetails,DL_SOLVER); // struct order: ip, sp, utype\n\nstatic Real\n\tMP_(absConvTol),\n\tMP_(centeringParam),\n\tMP_(collocationRatio),\n\tMP_(collocRatioTermsOrder),\n\tMP_(constraintPenalty),\n\tMP_(constrPenalty),\n\tMP_(constraintTolerance),\n\tMP_(contractFactor),\n\tMP_(contractStepLength),\n\tMP_(convergenceTolerance),\n\tMP_(crossoverRate),\n\tMP_(falseConvTol),\n\tMP_(functionPrecision),\n\tMP_(globalBalanceParam),\n\tMP_(gradientTolerance),\n      //MP_(hybridProgThresh),\n\tMP_(hybridLSProb),\n\tMP_(grThreshold),\n\tMP_(initDelta),\n\tMP_(initStepLength),\n\tMP_(initTRRadius),\n\tMP_(lineSearchTolerance),\n\tMP_(localBalanceParam),\n\tMP_(maxBoxSize),\n\tMP_(maxStep),\n\tMP_(minBoxSize),\n\tMP_(mutationRate),\n\tMP_(mutationScale),\n\tMP_(percentVarianceExplained),\n\tMP_(refinementRate),\n\tMP_(regressionL2Penalty),\n\tMP_(shrinkagePercent),\t// should be called shrinkageFraction\n\tMP_(singConvTol),\n\tMP_(singRadius),\n        MP_(smoothFactor),\n \tMP_(solnTarget),\n\tMP_(stepLenToBoundary),\n\tMP_(surrBasedLocalTRContract),\n\tMP_(surrBasedLocalTRContractTrigger),\n\tMP_(surrBasedLocalTRExpand),\n\tMP_(surrBasedLocalTRExpandTrigger),\n\tMP_(surrBasedLocalTRInitSize),\n\tMP_(surrBasedLocalTRMinSize),\n\tMP_(threshDelta),\n\tMP_(threshStepLength),\n\tMP_(vbdDropTolerance),\n\tMP_(volBoxSize),\n\tMP_(vns),\n\tMP_(xConvTol);\n\nstatic RealVector\n\tMP_(anisoDimPref),\n\tMP_(concurrentParameterSets),\n\tMP_(dataDistCovariance),\n\tMP_(dataDistMeans),\n\tMP_(finalPoint),\n\tMP_(hyperPriorAlphas),\n\tMP_(hyperPriorBetas),\n\tMP_(linearEqConstraintCoeffs),\n\tMP_(linearEqScales),\n\tMP_(linearEqTargets),\n\tMP_(linearIneqConstraintCoeffs),\n\tMP_(linearIneqLowerBnds),\n\tMP_(linearIneqUpperBnds),\n\tMP_(linearIneqScales),\n\tMP_(listOfPoints),\n\tMP_(proposalCovData),\n\tMP_(regressionNoiseTol),\n\tMP_(stepVector);\n\nstatic RealVectorArray\n\tMP_(genReliabilityLevels),\n\tMP_(probabilityLevels),\n\tMP_(reliabilityLevels),\n\tMP_(responseLevels);\n\nstatic unsigned short\n\tMP_(adaptedBasisAdvancements),\n      //MP_(adaptedBasisInitLevel),\n\tMP_(cubIntOrder),\n\tMP_(softConvLimit),\n\tMP_(vbdOrder);\n\nstatic SizetArray\n\tMP_(collocationPoints),\n\tMP_(expansionSamples);\n\nstatic UShortArray\n        MP_(expansionOrder),\n        MP_(quadratureOrder),\n\tMP_(sparseGridLevel),\n        MP_(tensorGridOrder),\n\tMP_(varPartitions);\n\nstatic String\n        MP_(betaSolverName),\n        MP_(dataDistFile),\n        MP_(displayFormat),\n\tMP_(exportApproxPtsFile),\n\tMP_(exportExpansionFile),\n\tMP_(exportMCMCPtsFile),\n\tMP_(historyFile),\n\tMP_(hybridGlobalMethodName),\n\tMP_(hybridGlobalMethodPointer),\n\tMP_(hybridGlobalModelPointer),\n\tMP_(hybridLocalMethodName),\n\tMP_(hybridLocalMethodPointer),\n\tMP_(hybridLocalModelPointer),\n\tMP_(idMethod),\n\tMP_(importApproxPtsFile),\n\tMP_(importBuildPtsFile),\n\tMP_(importExpansionFile),\n\tMP_(logFile),\n\tMP_(modelPointer),\n        MP_(posteriorDensityExportFilename),\n        MP_(posteriorSamplesExportFilename),\n        MP_(posteriorSamplesImportFilename),\n\tMP_(proposalCovFile),\n\tMP_(pstudyFilename),\n\tMP_(subMethodName),\n        MP_(subMethodPointer),\n        MP_(subModelPointer);\n\nstatic StringArray\n\tMP_(hybridMethodNames),\n\tMP_(hybridMethodPointers),\n\tMP_(hybridModelPointers),\n\tMP_(linearEqScaleTypes),\n\tMP_(linearIneqScaleTypes),\n        MP_(miscOptions);\n\nstatic bool\n\tMP_(adaptPosteriorRefine),\n\tMP_(backfillFlag),\n\tMP_(constantPenalty),\n\tMP_(crossValidation),\n        MP_(evaluatePosteriorDensity),\n\tMP_(expansionFlag),\n\tMP_(fixedSeedFlag),\n\tMP_(fixedSequenceFlag),\n        MP_(generatePosteriorSamples),\n\tMP_(importApproxActive),\n\tMP_(importBuildActive),\n\tMP_(latinizeFlag),\n\tMP_(logitTransform),\n\tMP_(mainEffectsFlag),\n\tMP_(methodScaling),\n\tMP_(methodUseDerivsFlag),\n\tMP_(mutationAdaptive),\n\tMP_(normalizedCoeffs),\n\tMP_(pcaFlag),\n\tMP_(printPopFlag),\n\tMP_(pstudyFileActive),\n\tMP_(randomizeOrderFlag),\n\tMP_(regressDiag),\n\tMP_(showAllEval),\n\tMP_(showMiscOptions),\n\tMP_(speculativeFlag),\n\tMP_(standardizedSpace),\n\tMP_(tensorGridFlag),\n\tMP_(surrBasedGlobalReplacePts),\n\tMP_(surrBasedLocalLayerBypass),\n\tMP_(vbdFlag),\n\tMP_(volQualityFlag);\n\nstatic short\n        MP_(expansionType),\n\tMP_(nestingOverride),\n\tMP_(refinementType);\n\nstatic int\n\tMP_(batchSize),\n\tMP_(concurrentRandomJobs),\n\tMP_(contractAfterFail),\n\tMP_(covarianceType),\n        MP_(crossoverChainPairs),\n        MP_(emulatorOrder),\n\tMP_(emulatorSamples),\n\tMP_(expandAfterSuccess),\n        MP_(iteratorServers),\n\tMP_(jumpStep),\n\tMP_(maxFunctionEvaluations),\n\tMP_(maxIterations),\n\tMP_(mutationRange),\n        MP_(neighborOrder),\n\tMP_(newSolnsGenerated),\n\tMP_(numChains),\n\tMP_(numCR),\n\tMP_(numSamples),\n\tMP_(numSteps),\n\tMP_(numSymbols),\n\tMP_(numTrials),\n\tMP_(populationSize),\n\tMP_(previousSamples),\n        MP_(procsPerIterator),\n        MP_(proposalCovUpdates),\n\tMP_(randomSeed),\n\tMP_(refineSamples),\n\tMP_(searchSchemeSize),\n\tMP_(totalPatternSize),\n\tMP_(verifyLevel);\n\nstatic size_t\n        MP_(numDesigns),\n        MP_(numFinalSolutions),\n\tMP_(numGenerations),\n\tMP_(numOffspring),\n\tMP_(numParents);\n\nstatic Method_mp_type\n\tMP2s(covarianceControl,DIAGONAL_COVARIANCE),\n\tMP2s(covarianceControl,FULL_COVARIANCE),\n\tMP2s(distributionType,COMPLEMENTARY),\n\tMP2s(distributionType,CUMULATIVE),\n\tMP2s(emulatorType,GP_EMULATOR),\n\tMP2s(emulatorType,KRIGING_EMULATOR),\n\tMP2s(emulatorType,PCE_EMULATOR),\n\tMP2s(emulatorType,SC_EMULATOR),\n\tMP2s(emulatorType,VPS_EMULATOR),\n\tMP2p(expansionBasisType,ADAPTED_BASIS_EXPANDING_FRONT),\n\tMP2p(expansionBasisType,ADAPTED_BASIS_GENERALIZED),\n\tMP2p(expansionBasisType,HIERARCHICAL_INTERPOLANT),\n\tMP2p(expansionBasisType,NODAL_INTERPOLANT),\n\tMP2p(expansionBasisType,TENSOR_PRODUCT_BASIS),\n\tMP2p(expansionBasisType,TOTAL_ORDER_BASIS),\n\tMP2s(expansionType,ASKEY_U),\n\tMP2s(expansionType,STD_NORMAL_U),\n\tMP2p(growthOverride,RESTRICTED),                   // Pecos enumeration\n\tMP2p(growthOverride,UNRESTRICTED),                 // Pecos enumeration\n\tMP2s(iteratorScheduling,MASTER_SCHEDULING),\n\tMP2s(iteratorScheduling,PEER_SCHEDULING),\n      //MP2s(iteratorScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(iteratorScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(lsRegressionType,EQ_CON_LS),\n\tMP2s(lsRegressionType,SVD_LS),\n\tMP2o(meritFn,ArgaezTapia),                         // OPTPP enumeration\n\tMP2o(meritFn,NormFmu),                             // OPTPP enumeration\n\tMP2o(meritFn,VanShanno),                           // OPTPP enumeration\n\tMP2s(methodOutput,DEBUG_OUTPUT),\n\tMP2s(methodOutput,NORMAL_OUTPUT),\n\tMP2s(methodOutput,QUIET_OUTPUT),\n\tMP2s(methodOutput,SILENT_OUTPUT),\n\tMP2s(methodOutput,VERBOSE_OUTPUT),\n\tMP2p(nestingOverride,NESTED),                      // Pecos enumeration\n\tMP2p(nestingOverride,NON_NESTED),                  // Pecos enumeration\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_GENERALIZED),// Pecos\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_DECAY),      // Pecos\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_SOBOL),      // Pecos\n\tMP2p(refinementControl,LOCAL_ADAPTIVE_CONTROL),                // Pecos\n\tMP2p(refinementControl,UNIFORM_CONTROL),                       // Pecos\n\tMP2p(refinementType,P_REFINEMENT),                 // Pecos enumeration\n        MP2p(refinementType,H_REFINEMENT),                 // Pecos enumeration\n\tMP2p(regressionType,BASIS_PURSUIT),                // Pecos enumeration\n\tMP2p(regressionType,BASIS_PURSUIT_DENOISING),      // Pecos enumeration\n\tMP2p(regressionType,DEFAULT_LEAST_SQ_REGRESSION),  // Pecos enumeration\n\tMP2p(regressionType,LASSO_REGRESSION),             // Pecos enumeration\n\tMP2p(regressionType,LEAST_ANGLE_REGRESSION),       // Pecos enumeration\n\tMP2p(regressionType,ORTHOG_LEAST_INTERPOLATION),   // Pecos enumeration\n\tMP2p(regressionType,ORTHOG_MATCH_PURSUIT),         // Pecos enumeration\n\tMP2s(responseLevelTarget,GEN_RELIABILITIES),\n\tMP2s(responseLevelTarget,PROBABILITIES),\n\tMP2s(responseLevelTarget,RELIABILITIES),\n\tMP2s(responseLevelTargetReduce,SYSTEM_PARALLEL),\n\tMP2s(responseLevelTargetReduce,SYSTEM_SERIES),\n\tMP2s(surrBasedLocalAcceptLogic,FILTER),\n\tMP2s(surrBasedLocalAcceptLogic,TR_RATIO),\n\tMP2s(surrBasedLocalConstrRelax,HOMOTOPY),\n\tMP2s(surrBasedLocalMeritFn,ADAPTIVE_PENALTY_MERIT),\n\tMP2s(surrBasedLocalMeritFn,AUGMENTED_LAGRANGIAN_MERIT),\n\tMP2s(surrBasedLocalMeritFn,LAGRANGIAN_MERIT),\n\tMP2s(surrBasedLocalMeritFn,PENALTY_MERIT),\n\tMP2s(surrBasedLocalSubProbCon,LINEARIZED_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbCon,NO_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbCon,ORIGINAL_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbObj,AUGMENTED_LAGRANGIAN_OBJECTIVE),\n\tMP2s(surrBasedLocalSubProbObj,LAGRANGIAN_OBJECTIVE),\n\tMP2s(surrBasedLocalSubProbObj,ORIGINAL_PRIMARY),\n\tMP2s(surrBasedLocalSubProbObj,SINGLE_OBJECTIVE);\n\nstatic Method_mp_utype\n  MP2s(calibrateErrorMode,CALIBRATE_ONE),\n  MP2s(calibrateErrorMode,CALIBRATE_PER_EXPER),\n  MP2s(calibrateErrorMode,CALIBRATE_PER_RESP),\n  MP2s(calibrateErrorMode,CALIBRATE_BOTH),\n        MP2s(exportApproxFormat,TABULAR_NONE),\n        MP2s(exportApproxFormat,TABULAR_HEADER),\n        MP2s(exportApproxFormat,TABULAR_EVAL_ID),\n        MP2s(exportApproxFormat,TABULAR_IFACE_ID),\n        MP2s(exportApproxFormat,TABULAR_ANNOTATED),\n        MP2s(exportMCMCFormat,TABULAR_NONE),\n        MP2s(exportMCMCFormat,TABULAR_HEADER),\n        MP2s(exportMCMCFormat,TABULAR_EVAL_ID),\n        MP2s(exportMCMCFormat,TABULAR_IFACE_ID),\n        MP2s(exportMCMCFormat,TABULAR_ANNOTATED),\n        MP2s(importApproxFormat,TABULAR_NONE),\n        MP2s(importApproxFormat,TABULAR_HEADER),\n        MP2s(importApproxFormat,TABULAR_EVAL_ID),\n        MP2s(importApproxFormat,TABULAR_IFACE_ID),\n        MP2s(importApproxFormat,TABULAR_ANNOTATED),\n        MP2s(importBuildFormat,TABULAR_NONE),\n        MP2s(importBuildFormat,TABULAR_HEADER),\n        MP2s(importBuildFormat,TABULAR_EVAL_ID),\n        MP2s(importBuildFormat,TABULAR_IFACE_ID),\n        MP2s(importBuildFormat,TABULAR_ANNOTATED),\n  MP2s(integrationRefine,AIS),\n\tMP2s(integrationRefine,IS),\n\tMP2s(integrationRefine,MMAIS),\n\tMP2s(methodName,ASYNCH_PATTERN_SEARCH),\n\tMP2s(methodName,BRANCH_AND_BOUND),\n\tMP2s(methodName,COLINY_BETA),\n\tMP2s(methodName,COLINY_COBYLA),\n\tMP2s(methodName,COLINY_DIRECT),\n\tMP2s(methodName,COLINY_EA),\n\tMP2s(methodName,COLINY_PATTERN_SEARCH),\n\tMP2s(methodName,COLINY_SOLIS_WETS),\n\tMP2s(methodName,CONMIN_FRCG),\n\tMP2s(methodName,CONMIN_MFD),\n\tMP2s(methodName,DACE),\n\tMP2s(methodName,DOT_BFGS),\n\tMP2s(methodName,DOT_FRCG),\n\tMP2s(methodName,DOT_MMFD),\n\tMP2s(methodName,DOT_SLP),\n\tMP2s(methodName,DOT_SQP),\n\tMP2s(methodName,EFFICIENT_GLOBAL),\n\tMP2s(methodName,FSU_CVT),\n\tMP2s(methodName,FSU_HALTON),\n\tMP2s(methodName,FSU_HAMMERSLEY),\n\tMP2s(methodName,HYBRID),\n\tMP2s(methodName,MESH_ADAPTIVE_SEARCH),\n\tMP2s(methodName,MOGA),\n\tMP2s(methodName,MULTI_START),\n\tMP2s(methodName,NCSU_DIRECT),\n\tMP2s(methodName,NL2SOL),\n\tMP2s(methodName,NLPQL_SQP),\n\tMP2s(methodName,NLSSOL_SQP),\n        MP2s(methodName,ADAPTIVE_SAMPLING),\n\tMP2s(methodName,BAYES_CALIBRATION),\n\tMP2s(methodName,EFFICIENT_SUBSPACE),\n\tMP2s(methodName,GENIE_DIRECT),\n\tMP2s(methodName,GENIE_OPT_DARTS),\n        MP2s(methodName,GPAIS),\n\tMP2s(methodName,GLOBAL_EVIDENCE),\n        MP2s(methodName,GLOBAL_INTERVAL_EST),\n\tMP2s(methodName,GLOBAL_RELIABILITY),\n        MP2s(methodName,IMPORTANCE_SAMPLING),\n \tMP2s(methodName,LOCAL_EVIDENCE),\n        MP2s(methodName,LOCAL_INTERVAL_EST),\n\tMP2s(methodName,LOCAL_RELIABILITY),\n        MP2s(methodName,POF_DARTS),\n    MP2s(methodName,RKD_DARTS),\n\tMP2s(methodName,POLYNOMIAL_CHAOS),\n\tMP2s(methodName,RANDOM_SAMPLING),\n\tMP2s(methodName,STOCH_COLLOCATION),\n\tMP2s(methodName,NONLINEAR_CG),\n\tMP2s(methodName,NPSOL_SQP),\n\tMP2s(methodName,OPTPP_CG),\n\tMP2s(methodName,OPTPP_FD_NEWTON),\n\tMP2s(methodName,OPTPP_G_NEWTON),\n\tMP2s(methodName,OPTPP_NEWTON),\n\tMP2s(methodName,OPTPP_PDS),\n\tMP2s(methodName,OPTPP_Q_NEWTON),\n\tMP2s(methodName,PARETO_SET),\n\tMP2s(methodName,PSUADE_MOAT),\n\tMP2s(methodName,RICHARDSON_EXTRAP),\n\tMP2s(methodName,SOGA),\n\tMP2s(methodName,SURROGATE_BASED_GLOBAL),\n\tMP2s(methodName,SURROGATE_BASED_LOCAL),\n\tMP2s(methodName,VECTOR_PARAMETER_STUDY),\n\tMP2s(methodName,LIST_PARAMETER_STUDY),\n\tMP2s(methodName,CENTERED_PARAMETER_STUDY),\n\tMP2s(methodName,MULTIDIM_PARAMETER_STUDY),\n\tMP2s(preSolveMethod,SUBMETHOD_NIP),\n\tMP2s(preSolveMethod,SUBMETHOD_SQP),\n\tMP2s(pstudyFileFormat,TABULAR_NONE),\n        MP2s(pstudyFileFormat,TABULAR_HEADER),\n        MP2s(pstudyFileFormat,TABULAR_EVAL_ID),\n        MP2s(pstudyFileFormat,TABULAR_IFACE_ID),\n        MP2s(pstudyFileFormat,TABULAR_ANNOTATED),\n\tMP2s(reliabilitySearchType,AMV_PLUS_U),\n\tMP2s(reliabilitySearchType,AMV_PLUS_X),\n\tMP2s(reliabilitySearchType,AMV_U),\n\tMP2s(reliabilitySearchType,AMV_X),\n\tMP2s(reliabilitySearchType,EGRA_U),\n\tMP2s(reliabilitySearchType,EGRA_X),\n\tMP2s(reliabilitySearchType,NO_APPROX),\n\tMP2s(reliabilitySearchType,TANA_U),\n\tMP2s(reliabilitySearchType,TANA_X),\n\tMP2s(sampleType,SUBMETHOD_INCREMENTAL_LHS),\n\tMP2s(sampleType,SUBMETHOD_INCREMENTAL_RANDOM),\n\tMP2s(sampleType,SUBMETHOD_LHS),\n\tMP2s(sampleType,SUBMETHOD_RANDOM),\n\tMP2s(subMethod,SUBMETHOD_COLLABORATIVE),\n\tMP2s(subMethod,SUBMETHOD_EMBEDDED),\n\tMP2s(subMethod,SUBMETHOD_SEQUENTIAL),\n\tMP2s(subMethod,SUBMETHOD_DREAM),\n\tMP2s(subMethod,SUBMETHOD_WASABI),\n\tMP2s(subMethod,SUBMETHOD_GPMSA),\n\tMP2s(subMethod,SUBMETHOD_QUESO),\n\tMP2s(subMethod,SUBMETHOD_NIP),\n\tMP2s(subMethod,SUBMETHOD_SQP),\n\tMP2s(subMethod,SUBMETHOD_EA),\n\tMP2s(subMethod,SUBMETHOD_EGO),\n\tMP2s(subMethod,SUBMETHOD_SBO),\n\tMP2s(subMethod,SUBMETHOD_LHS),\n\tMP2s(subMethod,SUBMETHOD_RANDOM),\n\tMP2s(subMethod,SUBMETHOD_OA_LHS),\n\tMP2s(subMethod,SUBMETHOD_OAS),\n\tMP2s(subMethod,SUBMETHOD_BOX_BEHNKEN),\n\tMP2s(subMethod,SUBMETHOD_CENTRAL_COMPOSITE),\n\tMP2s(subMethod,SUBMETHOD_GRID),\n\tMP2s(subMethod,SUBMETHOD_CONVERGE_ORDER),\n\tMP2s(subMethod,SUBMETHOD_CONVERGE_QOI),\n        MP2s(subMethod,SUBMETHOD_ESTIMATE_ORDER);\n\n#undef MP3s\n#undef MP3\n#undef MP2p\n#undef MP2o\n#undef MP2s\n#undef MP2\n#undef MP_\n\n\n// Macros for handling Model data\n\n#define MP_(x) DataModelRep::* model_mp_##x = &DataModelRep::x\n#define MP2(x,y) model_mp_##x##_##y = {&DataModelRep::x,#y}\n#define MP2s(x,y) model_mp_##x##_##y = {&DataModelRep::x,y}\n\nstatic IntSet\n\tMP_(surrogateFnIndices);\n\nstatic Model_mp_lit\n\tMP2(approxPointReuse,all),\n\tMP2(approxPointReuse,none),\n\tMP2(approxPointReuse,region),\n\tMP2(marsInterpolation,linear),\n\tMP2(marsInterpolation,cubic),\n\tMP2(modelType,nested),\n\tMP2(modelType,single),\n\tMP2(modelType,surrogate),\n\tMP2(surrogateType,hierarchical),\n\tMP2(surrogateType,global_gaussian),\n\tMP2(surrogateType,global_kriging),\n\tMP2(surrogateType,global_mars),\n\tMP2(surrogateType,global_moving_least_squares),\n\tMP2(surrogateType,global_neural_network),\n\tMP2(surrogateType,global_polynomial),\n\tMP2(surrogateType,global_radial_basis),\n\tMP2(surrogateType,global_voronoi_surrogate),\n\tMP2(surrogateType,local_taylor),\n        MP2(surrogateType,multipoint_tana),\n        MP2(trendOrder,constant),\n        MP2(trendOrder,linear),\n        MP2(trendOrder,reduced_quadratic),\n        MP2(trendOrder,quadratic);\n\nstatic Model_mp_ord\n\tMP2s(approxCorrectionOrder,0),\n\tMP2s(approxCorrectionOrder,1),\n\tMP2s(approxCorrectionOrder,2),\n\tMP2s(polynomialOrder,1),\n\tMP2s(polynomialOrder,2),\n        MP2s(polynomialOrder,3);\n\nstatic Model_mp_type\n\tMP2s(approxCorrectionType,ADDITIVE_CORRECTION),\n\tMP2s(approxCorrectionType,COMBINED_CORRECTION),\n\tMP2s(approxCorrectionType,MULTIPLICATIVE_CORRECTION),\n\tMP2s(pointsManagement,MINIMUM_POINTS),\n\tMP2s(pointsManagement,RECOMMENDED_POINTS),\n\tMP2s(subMethodScheduling,MASTER_SCHEDULING),\n\tMP2s(subMethodScheduling,PEER_SCHEDULING);\n      //MP2s(subMethodScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(subMethodScheduling,PEER_STATIC_SCHEDULING),\n        \n\nstatic Model_mp_utype\n        MP2s(exportApproxFormat,TABULAR_NONE),\n        MP2s(exportApproxFormat,TABULAR_HEADER),\n        MP2s(exportApproxFormat,TABULAR_EVAL_ID),\n        MP2s(exportApproxFormat,TABULAR_IFACE_ID),\n        MP2s(exportApproxFormat,TABULAR_ANNOTATED),\n      //MP2s(importApproxFormat,TABULAR_NONE),\n      //MP2s(importApproxFormat,TABULAR_HEADER),\n      //MP2s(importApproxFormat,TABULAR_EVAL_ID),\n      //MP2s(importApproxFormat,TABULAR_IFACE_ID),\n      //MP2s(importApproxFormat,TABULAR_ANNOTATED),\n        MP2s(importBuildFormat,TABULAR_NONE),\n        MP2s(importBuildFormat,TABULAR_HEADER),\n        MP2s(importBuildFormat,TABULAR_EVAL_ID),\n        MP2s(importBuildFormat,TABULAR_IFACE_ID),\n        MP2s(importBuildFormat,TABULAR_ANNOTATED),\n        MP2s(importChallengeFormat,TABULAR_NONE),\n        MP2s(importChallengeFormat,TABULAR_HEADER),\n        MP2s(importChallengeFormat,TABULAR_EVAL_ID),\n        MP2s(importChallengeFormat,TABULAR_IFACE_ID),\n        MP2s(importChallengeFormat,TABULAR_ANNOTATED),\n        MP2s(modelExportFormat,TEXT_ARCHIVE),\n        MP2s(modelExportFormat,BINARY_ARCHIVE),\n        MP2s(modelExportFormat,ALGEBRAIC_FILE),\n        MP2s(modelExportFormat,ALGEBRAIC_CONSOLE);\n\nstatic Real\n\tMP_(annRange),\n        MP_(discontGradThresh),\n        MP_(discontJumpThresh),\n\tMP_(krigingNugget),\n\tMP_(percentFold);\n\nstatic RealVector\n\tMP_(krigingCorrelations),\n      //MP_(krigingMaxCorrelations),\n      //MP_(krigingMinCorrelations),\n\tMP_(primaryRespCoeffs),\n\tMP_(secondaryRespCoeffs);\n\nstatic String\n\tMP_(decompCellType),\n\tMP_(exportApproxPtsFile),\n\tMP_(idModel),\n      //MP_(importApproxPtsFile),\n\tMP_(importBuildPtsFile),\n\tMP_(importChallengePtsFile),\n\tMP_(interfacePointer),\n\tMP_(krigingOptMethod),\n\tMP_(lowFidelityModelPointer),\n\tMP_(modelExportPrefix),\n\tMP_(optionalInterfRespPointer),\n\tMP_(responsesPointer),\n\tMP_(subMethodPointer),\n\tMP_(truthModelPointer),\n\tMP_(variablesPointer);\n\nstatic StringArray\n\tMP_(primaryVarMaps),\n        MP_(secondaryVarMaps),\n        MP_(diagMetrics);\n\nstatic bool\n\tMP_(crossValidateFlag),\n\tMP_(decompDiscontDetect),\n\tMP_(exportSurrogate),\n\tMP_(hierarchicalTags),\n      //MP_(importApproxActive),\n\tMP_(importBuildActive),\n\tMP_(importChallengeActive),\n\tMP_(modelUseDerivsFlag),\n        MP_(domainDecomp),\n        MP_(pointSelection),\n        MP_(pressFlag);\n\nstatic short\n\tMP_(annNodes),\n\tMP_(annRandomWeight),\n\tMP_(krigingFindNugget),\n\tMP_(krigingMaxTrials),\n\tMP_(marsMaxBases),\n\tMP_(mlsWeightFunction),\n\tMP_(polynomialOrder),\n\tMP_(rbfBases),\n\tMP_(rbfMaxPts),\n\tMP_(rbfMaxSubsets),\n\tMP_(rbfMinPartition);\n\nstatic int\n        MP_(decompSupportLayers),\n        MP_(numFolds),\n        MP_(pointsTotal),\n        MP_(subMethodProcs),\n        MP_(subMethodServers);\n\n#undef MP2s\n#undef MP2\n#undef MP_\n\n#define MP_(x) DataResponsesRep::* resp_mp_##x = &DataResponsesRep::x\n#define MP2(x,y) resp_mp_##x##_##y = {&DataResponsesRep::x,#y}\n#define MP2s(x,y) resp_mp_##x##_##y = {&DataResponsesRep::x,y}\n\nstatic IntSet\n\tMP_(idAnalyticGrads),\n\tMP_(idAnalyticHessians),\n\tMP_(idNumericalGrads),\n\tMP_(idNumericalHessians),\n\tMP_(idQuasiHessians);\n\nstatic IntVector\n\tMP_(fieldLengths),\n\tMP_(numCoordsPerField);\n\nstatic RealVector\n\tMP_(expConfigVars),\n\tMP_(expObservations),\n\tMP_(primaryRespFnWeights),\n\tMP_(nonlinearEqTargets),\n\tMP_(nonlinearIneqLowerBnds),\n\tMP_(nonlinearIneqUpperBnds),\n\tMP_(fdGradStepSize),\n\tMP_(fdHessStepSize),\n\tMP_(primaryRespFnScales),\n\tMP_(nonlinearEqScales),\n\tMP_(nonlinearIneqScales);\n\nstatic Resp_mp_lit\n\tMP2(gradientType,analytic),\n\tMP2(gradientType,mixed),\n\tMP2(gradientType,none),\n\tMP2(gradientType,numerical),\n\tMP2(hessianType,analytic),\n\tMP2(hessianType,mixed),\n\tMP2(hessianType,none),\n\tMP2(hessianType,numerical),\n\tMP2(hessianType,quasi),\n\tMP2(intervalType,central),\n\tMP2(intervalType,forward),\n\tMP2(methodSource,dakota),\n\tMP2(methodSource,vendor),\n        MP2(fdGradStepType,absolute),\n        MP2(fdGradStepType,bounds),\n        MP2(fdGradStepType,relative),\n        MP2(fdHessStepType,absolute),\n        MP2(fdHessStepType,bounds),\n        MP2(fdHessStepType,relative),\n\tMP2(quasiHessianType,bfgs),\n\tMP2(quasiHessianType,damped_bfgs),\n\tMP2(quasiHessianType,sr1);\n\nstatic String\n\tMP_(scalarDataFileName),\n        MP_(idResponses);\n\nstatic StringArray\n\tMP_(nonlinearEqScaleTypes),\n\tMP_(nonlinearIneqScaleTypes),\n\tMP_(primaryRespFnScaleTypes),\n\tMP_(primaryRespFnSense),\n\tMP_(responseLabels),\n\tMP_(varianceType);\n\nstatic bool\n\tMP_(calibrationDataFlag),\n\tMP_(centralHess),\n\tMP_(interpolateFlag),\n        MP_(ignoreBounds),\n        MP_(readFieldCoords);\n\nstatic size_t\n\tMP_(numExpConfigVars),\n        MP_(numExperiments),\n\tMP_(numFieldLeastSqTerms),\n\tMP_(numFieldObjectiveFunctions),\n\tMP_(numFieldResponseFunctions),\n\tMP_(numLeastSqTerms),\n\tMP_(numNonlinearEqConstraints),\n\tMP_(numNonlinearIneqConstraints),\n\tMP_(numObjectiveFunctions),\n\tMP_(numResponseFunctions),\n\tMP_(numScalarLeastSqTerms),\n\tMP_(numScalarObjectiveFunctions),\n\tMP_(numScalarResponseFunctions);\n\nstatic Resp_mp_utype\n        MP2s(scalarDataFormat,TABULAR_NONE),\n        MP2s(scalarDataFormat,TABULAR_HEADER),\n        MP2s(scalarDataFormat,TABULAR_EVAL_ID),\n        MP2s(scalarDataFormat,TABULAR_EXPER_ANNOT);\n \n#undef MP2s\n#undef MP2\n#undef MP_\n\n// Macros for Environment\n\n#define MP_(x) DataEnvironmentRep::* env_mp_##x = &DataEnvironmentRep::x\n#define MP2s(x,y) env_mp_##x##_##y = {&DataEnvironmentRep::x,y}\n\n//static Env_mp_lit\n//      MP2(,);\n\nstatic Env_mp_utype\n        MP2s(postRunInputFormat,TABULAR_NONE),\n        MP2s(postRunInputFormat,TABULAR_HEADER),\n        MP2s(postRunInputFormat,TABULAR_EVAL_ID),\n        MP2s(postRunInputFormat,TABULAR_IFACE_ID),\n        MP2s(postRunInputFormat,TABULAR_ANNOTATED),\n        MP2s(preRunOutputFormat,TABULAR_NONE),\n        MP2s(preRunOutputFormat,TABULAR_HEADER),\n        MP2s(preRunOutputFormat,TABULAR_EVAL_ID),\n        MP2s(preRunOutputFormat,TABULAR_IFACE_ID),\n        MP2s(preRunOutputFormat,TABULAR_ANNOTATED),\n        MP2s(tabularFormat,TABULAR_NONE),\n        MP2s(tabularFormat,TABULAR_HEADER),\n        MP2s(tabularFormat,TABULAR_EVAL_ID),\n        MP2s(tabularFormat,TABULAR_IFACE_ID),\n        MP2s(tabularFormat,TABULAR_ANNOTATED);\n\nstatic String\n        MP_(errorFile),\n        MP_(outputFile),\n        MP_(postRunInput),\n        MP_(postRunOutput),\n        MP_(preRunInput),\n        MP_(preRunOutput),\n        MP_(readRestart),\n        MP_(resultsOutputFile),\n        MP_(runInput),\n        MP_(runOutput),\n\tMP_(tabularDataFile),\n        MP_(topMethodPointer),\n        MP_(writeRestart);\n\nstatic bool\n\tMP_(checkFlag),\n\tMP_(graphicsFlag),\n\tMP_(postRunFlag),\n\tMP_(preRunFlag),\n        MP_(resultsOutputFlag),\n\tMP_(runFlag),\n\tMP_(tabularDataFlag);\n\nstatic int\n        MP_(outputPrecision),\n        MP_(stopRestart);\n\n//#undef MP2\n#undef MP2s\n#undef MP_\n\n#define MP_(x) DataVariablesRep::* var_mp_##x = &DataVariablesRep::x\n#define MP2s(x,y) var_mp_##x = {&DataVariablesRep::x,y}\n#define VP_(x) *Var_Info::* var_mp_Var_Info_##x = &Var_Info::x\n#define Vtype(x,y) var_mp_##x##_##y = {&DataVariablesRep::x,y}\n\nstatic size_t\n\tMP_(numBetaUncVars),\n\tMP_(numBinomialUncVars),\n\tMP_(numContinuousDesVars),\n\tMP_(numContinuousIntervalUncVars),\n\tMP_(numContinuousStateVars),\n\tMP_(numDiscreteDesRangeVars),\n\tMP_(numDiscreteDesSetIntVars),\n\tMP_(numDiscreteDesSetStrVars),\n\tMP_(numDiscreteDesSetRealVars),\n\tMP_(numDiscreteIntervalUncVars),\n\tMP_(numDiscreteStateRangeVars),\n\tMP_(numDiscreteStateSetIntVars),\n\tMP_(numDiscreteStateSetStrVars),\n\tMP_(numDiscreteStateSetRealVars),\n\tMP_(numDiscreteUncSetIntVars),\n\tMP_(numDiscreteUncSetStrVars),\n\tMP_(numDiscreteUncSetRealVars),\n\tMP_(numExponentialUncVars),\n\tMP_(numFrechetUncVars),\n\tMP_(numGammaUncVars),\n\tMP_(numGeometricUncVars),\n\tMP_(numGumbelUncVars),\n\tMP_(numHistogramBinUncVars),\n\tMP_(numHistogramPtIntUncVars),\n\tMP_(numHistogramPtStrUncVars),\n\tMP_(numHistogramPtRealUncVars),\n\tMP_(numHyperGeomUncVars),\n\tMP_(numLognormalUncVars),\n\tMP_(numLoguniformUncVars),\n\tMP_(numNegBinomialUncVars),\n\tMP_(numNormalUncVars),\n\tMP_(numPoissonUncVars),\n\tMP_(numTriangularUncVars),\n\tMP_(numUniformUncVars),\n\tMP_(numWeibullUncVars);\n\nstatic IntVector\n\tVP_(ddsi),\n\tVP_(DIlb),\n\tMP_(discreteDesignRangeLowerBnds),\n\tMP_(discreteDesignRangeUpperBnds),\n\tMP_(discreteDesignRangeVars),\n\tMP_(discreteDesignSetIntVars),\n\tMP_(discreteIntervalUncVars),\n        MP_(discreteStateRangeLowerBnds),\n\tMP_(discreteStateRangeUpperBnds),\n\tMP_(discreteStateRangeVars),\n\tMP_(discreteStateSetIntVars),\n\tMP_(discreteUncSetIntVars),\n\tVP_(DIub),\n        MP_(histogramPointIntUncVars),\n        VP_(hpia),\n        VP_(dssi),\n        VP_(ddsia),\n        VP_(ddssa),\n        VP_(ddsra),\n        VP_(dusi);\n\nstatic IntArray\n\tVP_(nddsi),\n\tVP_(nddss),\n\tVP_(nddsr),\n\tVP_(ndssi),\n\tVP_(ndsss),\n\tVP_(ndssr),\n\tVP_(ndusi),\n\tVP_(nduss),\n\tVP_(ndusr),\n\tVP_(nhbp),\n\tVP_(nhpip),\n\tVP_(nhpsp),\n\tVP_(nhprp),\n\tVP_(nCI),\n\tVP_(nDI);\n\nstatic RealVector\n\tMP_(betaUncLowerBnds),\n\tMP_(betaUncUpperBnds),\n\tMP_(betaUncVars),\n        MP_(binomialUncProbPerTrial),\n        MP_(continuousDesignLowerBnds),\n\tMP_(continuousDesignUpperBnds),\n\tMP_(continuousDesignVars),\n\tMP_(continuousDesignScales),\n\tMP_(continuousIntervalUncVars),\n\tMP_(continuousStateLowerBnds),\n\tMP_(continuousStateUpperBnds),\n\tMP_(continuousStateVars),\n\tMP_(discreteDesignSetRealVars),\n\tMP_(discreteStateSetRealVars),\n\tMP_(discreteUncSetRealVars),\n\tMP_(frechetUncBetas),\n\tMP_(frechetUncVars),\n        MP_(geometricUncProbPerTrial),\n\tMP_(gumbelUncBetas),\n\tMP_(gumbelUncVars),\n\tMP_(histogramBinUncVars),\n        MP_(histogramPointRealUncVars),\n        MP_(negBinomialUncProbPerTrial),\n\tMP_(normalUncLowerBnds),\n\tMP_(normalUncMeans),\n\tMP_(normalUncUpperBnds),\n\tMP_(normalUncVars),\n\tMP_(triangularUncModes),\n\tMP_(triangularUncVars),\n\tMP_(uniformUncVars),\n\tMP_(weibullUncVars),\n\tVP_(ddsr),\n\tVP_(dssr),\n\tVP_(dusr),\n\tVP_(CIlb),\n\tVP_(CIub),\n\tVP_(CIp),\n\tVP_(DIp),\n\tVP_(DSIp),\n\tVP_(DSSp),\n\tVP_(DSRp),\n\tVP_(hba),\n\tVP_(hbo),\n\tVP_(hbc),\n\tVP_(hpic),\n\tVP_(hpsc),\n\tVP_(hpra),\n\tVP_(hprc),\n\tVP_(ucm);\n\nstatic String\n\tMP_(idVariables);\n\nstatic StringArray\n\tMP_(continuousDesignLabels),\n\tMP_(continuousDesignScaleTypes),\n\tMP_(continuousStateLabels),\n\tMP_(discreteDesignRangeLabels),\n\tMP_(discreteDesignSetIntLabels),\n\tMP_(discreteDesignSetStrLabels),\n\tMP_(discreteDesignSetRealLabels),\n\tMP_(discreteStateRangeLabels),\n\tMP_(discreteStateSetIntLabels),\n\tMP_(discreteStateSetStrLabels),\n        MP_(discreteStateSetRealLabels),\n\tMP_(discreteDesignSetStrVars),\n\tMP_(discreteUncSetStrVars),\n\tMP_(discreteStateSetStrVars),\n        MP_(histogramPointStrUncVars),\n        VP_(hpsa),\n        VP_(ddss),\n        VP_(duss),\n        VP_(dsss);\n\nstatic BitArray\n        MP_(discreteDesignSetIntCat),\n        MP_(discreteDesignSetRealCat),\n        MP_(discreteStateSetIntCat),\n        MP_(discreteStateSetRealCat),\n        MP_(discreteUncSetIntCat),\n        MP_(discreteUncSetRealCat);\n\nstatic Var_brv\n\tMP2s(betaUncAlphas,0.),\n\tMP2s(betaUncBetas,0.),\n\tMP2s(exponentialUncBetas,0.),\n\tMP2s(exponentialUncVars,0.),\n\tMP2s(frechetUncAlphas,2.),\n\tMP2s(gammaUncAlphas,0.),\n\tMP2s(gammaUncBetas,0.),\n\tMP2s(gammaUncVars,0.),\n\tMP2s(gumbelUncAlphas,0.),\n\tMP2s(lognormalUncErrFacts,1.),\n\tMP2s(lognormalUncLambdas,0.),\n\tMP2s(lognormalUncLowerBnds,0.),\n\tMP2s(lognormalUncMeans,0.),\n\tMP2s(lognormalUncStdDevs,0.),\n\tMP2s(lognormalUncUpperBnds,std::numeric_limits<Real>::infinity()),\n\tMP2s(lognormalUncVars,0.),\n\tMP2s(lognormalUncZetas,0.),\n\tMP2s(loguniformUncLowerBnds,0.),\n\tMP2s(loguniformUncUpperBnds,std::numeric_limits<Real>::infinity()),\n\tMP2s(loguniformUncVars,0.),\n\tMP2s(normalUncStdDevs,0.),\n\tMP2s(poissonUncLambdas,0.),\n\tMP2s(triangularUncLowerBnds,-std::numeric_limits<Real>::infinity()),\n\tMP2s(triangularUncUpperBnds, std::numeric_limits<Real>::infinity()),\n\tMP2s(uniformUncLowerBnds,-std::numeric_limits<Real>::infinity()),\n\tMP2s(uniformUncUpperBnds, std::numeric_limits<Real>::infinity()),\n\tMP2s(weibullUncAlphas,0.),\n\tMP2s(weibullUncBetas,0.);\n\nstatic Var_biv\n\tMP2s(binomialUncNumTrials,0),\n\tMP2s(binomialUncVars,0),\n\tMP2s(geometricUncVars,0),\n\tMP2s(hyperGeomUncNumDrawn,0),\n\tMP2s(hyperGeomUncSelectedPop,0),\n\tMP2s(hyperGeomUncTotalPop,0),\n\tMP2s(hyperGeomUncVars,0),\n\tMP2s(negBinomialUncNumTrials,0),\n\tMP2s(negBinomialUncVars,0),\n\tMP2s(poissonUncVars,0);\n\nstatic Var_mp_type\n\tVtype(varsDomain,MIXED_DOMAIN),\n\tVtype(varsDomain,RELAXED_DOMAIN),\n\tVtype(varsView,ALL_VIEW),\n\tVtype(varsView,DESIGN_VIEW),\n\tVtype(varsView,UNCERTAIN_VIEW),\n\tVtype(varsView,ALEATORY_UNCERTAIN_VIEW),\n\tVtype(varsView,EPISTEMIC_UNCERTAIN_VIEW),\n        Vtype(varsView,STATE_VIEW);\n\n#undef Vtype\n#undef VP_\n#undef MP2s\n#undef MP_\n\n} // namespace Dakota\n\n#undef Warn\n#undef Squawk\n\n#define N_ifm(x,y)\tNIDRProblemDescDB::iface_##x,&iface_mp_##y\n#define N_ifm3(x,y,z)\tNIDRProblemDescDB::iface_##x,y,NIDRProblemDescDB::iface_##z\n#define N_mdm(x,y)\tNIDRProblemDescDB::method_##x,&method_mp_##y\n//#define N_mdf(x,y)\tN_mdm(x,y),NIDRProblemDescDB::method_##x##_final\n#define N_mdm3(x,y,z)\tNIDRProblemDescDB::method_##x,y,NIDRProblemDescDB::method_##z\n#define N_mom(x,y)\tNIDRProblemDescDB::model_##x,&model_mp_##y\n#define N_mof(x,y)\tN_mom(x,y),NIDRProblemDescDB::model_##x##_final\n#define N_mom3(x,y,z)\tNIDRProblemDescDB::model_##x,y,NIDRProblemDescDB::model_##z\n#define N_rem(x,y)\tNIDRProblemDescDB::resp_##x,&resp_mp_##y\n#define N_rem3(x,y,z)\tNIDRProblemDescDB::resp_##x,y,NIDRProblemDescDB::resp_##z\n#define N_stm(x,y)\tNIDRProblemDescDB::env_##x,&env_mp_##y\n#define N_vae(x,y)\tNIDRProblemDescDB::var_##x,(void*)y\n#define N_vam(x,y)\tNIDRProblemDescDB::var_##x,&var_mp_##y\n#define N_vam3(x,y,z)\tNIDRProblemDescDB::var_##x,y,NIDRProblemDescDB::var_##z\n\n#include \"NIDR_keywds.hpp\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/DLSolver.cpp": "#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (dl_constructor_t)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (dl_constructor_t)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#include <stdarg.h>\n#include \"DLSolver.hpp\"\n#include \"ProblemDescDB.hpp\"\n\n#ifdef DLSOLVER_DEBUG_UNLOCK\n// This is only needed for the simplest example, dlsolvers/dl_npsol.C,\n// which uses as much of DAKOTA's machinery for NPSOL as possible.\n// (This machinery is compiled into DAKOTA unless configured with --without-npsol).\n// The corresponding dl_npsol.dll is not loaded until the database is locked,\n// but dl_npsol.dll then invokes \"new NPSOLOptimizer(...)\", which needs to\n// have the database unlocked.  Note that unlocking then may give wrong results\n// in multi-specification runs.  The configure machinery does not know about\n// compilation with -DDLSOLVER_DEBUG_UNLOCK, since it is only meant for use\n// in special cases by knowledgeable developers.\n#define DEBUG_unlock probDescDB.unlock();\n#define DEBUG_lock probDescDB.lock();\n#else\n#define DEBUG_unlock /*default: do nothing*/\n#define DEBUG_lock   /*default: do nothing*/\n#endif\n\n#define NO_DAKOTA_DLSOLVER_FUNCS_INLINE\n#include \"DLSfuncs.hpp\"\n\nnamespace Dakota {\n\n static RealVector const *\ncontinuous_lower_bounds1(Optimizer1 *o)\n{ return &o->M->continuous_lower_bounds(); }\n\n static RealVector const *\ncontinuous_upper_bounds1(Optimizer1 *o)\n{ return &o->M->continuous_upper_bounds(); }\n\n static RealVector const *\nnonlinear_ineq_constraint_lower_bounds1(Optimizer1 *o)\n{ return &o->M->nonlinear_ineq_constraint_lower_bounds(); }\n\n static RealVector const *\nnonlinear_ineq_constraint_upper_bounds1(Optimizer1 *o)\n{ return &o->M->nonlinear_ineq_constraint_upper_bounds(); }\n\n static RealVector const *\nnonlinear_eq_constraint_targets1(Optimizer1 *o)\n{ return &o->M->nonlinear_eq_constraint_targets(); }\n\n static RealVector const *\nlinear_ineq_constraint_lower_bounds1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_lower_bounds(); }\n\n static RealVector const *\nlinear_ineq_constraint_upper_bounds1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_upper_bounds(); }\n\n static RealVector const *\nlinear_eq_constraint_targets1(Optimizer1 *o)\n{ return &o->M->linear_eq_constraint_targets(); }\n\n static RealMatrix const *\nlinear_eq_constraint_coeffs1(Optimizer1 *o)\n{ return &o->M->linear_eq_constraint_coeffs(); }\n\n static RealMatrix const *\nlinear_ineq_constraint_coeffs1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_coeffs(); }\n\n static void\nComputeResponses1(Optimizer1 *o, int mode, int n, double *x)\n{\n\t// without the printf, g++ generates incorrect code\n\tif (n < 0)\n\t\tprintf(\"ComputeResponses1 has o = #%x, mode = %d, n = %d, x = #%x\\n\",\n\t\t\to, mode, n, x);\n\tRealVector lx(n);\n\tcopy_data(x, n, lx);\n\to->M->continuous_variables(lx);\n\to->activeSet_()->request_values(mode);\n\to->M->compute_response(*o->activeSet_());\n\t}\n\n static void\nGetFuncs1(Optimizer1 *o, int m0, int m1, double *f)\n{\n\tResponse const *R = &o->M->current_response();\n\tRealVector const *RV = &R->function_values();\n\tfor(int i = m0; i < m1; i++)\n\t\tf[i-m0] = (*RV)[i];\n\t}\n\n static void\nGetGrads1(Optimizer1 *o, int m0, int m1, int n, int is, int js, double *g)\n{\n\tint i, i1, j;\n\tResponse const *R = &o->M->current_response();\n\tRealMatrix const *RM = &R->function_gradients();\n\tReal const *RV;\n\n\tfor(i1 = 0, i = m0; i < m1; i++, i1 += is) {\n\t\tRV = (*RM)[i];\n\t\tfor(j = 0; j < n; j++)\n\t\t\tg[i1 + j*js] = RV[j];\n\t\t}\n\t}\n\n static void\nGetContVars1(Optimizer1 *o, int n, double *x)\n{ memcpy(x, &o->M->continuous_variables()[0], n*sizeof(double)); }\n\n static void\nSetBestContVars1(Optimizer1 *o, int n, double *x)\n{\n\tint i;\n\tRealVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestVariables_()->continuous_variables(X);\n\t}\n\n static void\nSetBestDiscVars1(Optimizer1 *o, int n, int *x)\n{\n\tint i;\n\tIntVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestVariables_()->discrete_int_variables(X);\n\t}\n\n static void\nSetBestRespFns1(Optimizer1 *o, int n, double *x)\n{\n\tint i;\n\tRealVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestResponse_()->function_values(X);\n\t}\n\n static double\nGet_Real1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_real(name);\n\t}\n\n static int\nGet_Int1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_int(name);\n\t}\n\n static bool\nGet_Bool1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_bool(name);\n\t}\n\nDakota_funcs DakFuncs0 = {\n\tfprintf,\n\tabort_handler,\n\tdlsolver_option,\n\tcontinuous_lower_bounds1,\n\tcontinuous_upper_bounds1,\n\tnonlinear_ineq_constraint_lower_bounds1,\n\tnonlinear_ineq_constraint_upper_bounds1,\n\tnonlinear_eq_constraint_targets1,\n\tlinear_ineq_constraint_lower_bounds1,\n\tlinear_ineq_constraint_upper_bounds1,\n\tlinear_eq_constraint_targets1,\n\tlinear_ineq_constraint_coeffs1,\n\tlinear_eq_constraint_coeffs1,\n\tComputeResponses1,\n\tGetFuncs1,\n\tGetGrads1,\n\tGetContVars1,\n\tSetBestContVars1,\n\tSetBestDiscVars1,\n\tSetBestRespFns1,\n\tGet_Real1,\n\tGet_Int1,\n\tGet_Bool1\n\t};\n\n void\nDLSolver::cleanup()\n{\n\tvoid *h;\n\tif (h = dlLib) {\n\t\tdlLib = NULL;\n\t\tif (dl_destructor)\n\t\t\t(*dl_destructor)(&dl_Optimizer);\n\t\tdlclose(h);\n\t\tif (pdlLib)\n\t\t\t*pdlLib = 0;\n\t\t}\n\tif (details) {\n\t\tdelete[] details;\n\t\tdetails = 0;\n\t\t}\n\tif (DF) {\n\t\tdelete DF;\n\t\tDF = 0;\n\t\t}\n\t}\n\n void\nDLSolver::botch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\nDLSolver Error: \");\n\tvfprintf(stderr, fmt, ap);\n\tputc('\\n', stderr);\n\tva_end(ap);\n\tfflush(stderr);\n\tcleanup();\n\tabort_handler(-1);\n\t}\n\nDLSolver::DLSolver(Model& model):\n\tOptimizer1(model), dl_find_optimum(0), dl_destructor(0), dlLib(0)\n{\n\tconst String &dlDetails = probDescDB.get_string(\"method.dl_solver.dlDetails\");\n\tchar *s, *s0;\n\tsize_t L;\n\tvoid *h, **vp;\n\n\tDF = 0;\n\tL = strlen(s0 = dlDetails.data()) + 1;\n\tdetails = s = new char[L];\n\tif (!s)\n\t\tbotch(\"new(%lu) failure in DLSolver::DLSolver.\", (unsigned long) L);\n\tmemcpy(s, s0, L);\n\tvp = probDescDB.get_voidss(\"method.dl_solver.dlLib\");\n\tpdlLib = *vp ? vp : 0;\n\t}\n\nDLSolver::~DLSolver()\n{ cleanup(); }\n\n void\nDLSolver::find_optimum()\n{\n\tDakota_funcs *df;\n\tDakota_probsize ps;\n\tchar *s, *s0;\n\ttypedef void* (*dl_constructor_t)(Optimizer1*, Dakota_funcs*,\n\t\t\tdl_find_optimum_t*, dl_destructor_t*);\n\tdl_constructor_t dl_constructor;\n\tvoid *h;\n\tif (!dl_find_optimum) {\t// Load the shared library if this is\n\t\t\t\t// the first find_optimum() invocation.\n\t\tdf = DF = new Dakota_funcs;\n\t\tif (!df)\n\t\t\tbotch(\"new Dakota_Funcs failure\");\n\t\tmemcpy(df, &DakFuncs0, sizeof(Dakota_funcs));\n\t\tfor(s0 = s = details; *s > ' '; s++);\n\t\tif (s == s0)\n\t\t\tbotch(\"dlDetails not given for dl_solver.\");\n\t\tif (*s)\n\t\t\t*s++ = 0;\n\t\tif (pdlLib)\n\t\t\th = *pdlLib;\n\t\telse\n\t\t\th = dlopen(s0, RTLD_NOW/*RTLD_LAZY*/);\n\t\tif (!h)\n#ifdef NO_DLERROR\n\t\t\tbotch(\"dlopen(\\\"%s\\\") failure\", s0);\n#else\n\t\t\tbotch(\"dlopen(\\\"%s\\\") failure:\\n%s\", s0, dlerror());\n#endif\n\t\tdlLib = h;\n\t\tif (!(find_dlsym(dl_constructor, h, \"dl_constructor\")))\n\t\t\tbotch(\"dlsym(\\\"dl_constructor\\\") failed in \\\"%s\\\"\", s0);\n\t\twhile(*s && *s <= ' ')\n\t\t\t++s;\n\t\toptions = s;\n\t\tdf->Stderr = stderr;\n\t\tdf->dakota_cerr = dakota_cerr;\n\t\tdf->dakota_cout = dakota_cout;\n\t\tDEBUG_unlock\n\t\tdl_Optimizer = (*dl_constructor)(this, df, &dl_find_optimum, &dl_destructor);\n\t\tDEBUG_lock\n\t\t}\n\tif (dl_find_optimum) {\n\t\tdf = DF;\n\t\tdf->Stderr = stderr;\n\t\tdf->dakota_cerr = dakota_cerr;\n\t\tdf->dakota_cout = dakota_cout;\n\t\tps.n_var = numContinuousVars_();\n\t\tps.n_linc = numLinearConstraints_();\n\t\tps.n_nlinc = numNonlinearConstraints_();\n\t\tps.n_obj = numObjectiveFunctions_();\n\t\tps.maxfe = maxFunctionEvals_();\n\t\tps.numgflag = vendorNumericalGradFlag_();\n\t\tps.objrecast = localObjectiveRecast_();\n\t\tdf->ps = &ps;\n\t\tM = iteratedModel_();\n\t\t(*dl_find_optimum)(dl_Optimizer, this, options);\n\t\t}\n\telse\n\t\tbotch(\"dl_find_optimum is null in find_optimum\");\n\t}\n\n int\ndlsolver_option(Opt_Info *Oi)\n{\n\tchar *in, *in0, *s, *val0;\n\tint c;\n\n\tif (!(in = Oi->begin))\n\t\treturn 0;\n\twhile(*in <= ' ')\n\t\tif (!*in++)\n\t\t\treturn 0;\n\tOi->name = in0 = in;\n\tfor(; (c = *in) > ' '; ++in) {\n\t\tif (c == '_')\n\t\t\t*in = Oi->und_repl;\n\t\telse if (c == '=') {\n\t\t\t*in = Oi->eq_repl;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tOi->name_len = in - in0;\n\tif (c == '=')\n\t\t++in;\n\tif (!*in) {\n no_val:\n\t\tOi->val = 0;\n\t\tOi->val_len = 0;\n\t\tOi->begin = in;\n\t\tOi->all_len = Oi->name_len;\n\t\treturn 1;\n\t\t}\n\tfor(; (c = *in) <= ' '; ++in) {\n\t\tif (!c)\n\t\t\tgoto no_val;\n\t\t}\n\tif (c == '=') {\n\t\t*in++ = Oi->eq_repl;\n\t\twhile((c = *++in) <= ' ') {\n\t\t\tif (!c)\n\t\t\t\tgoto no_val;\n\t\t\t}\n\t\t}\n\tOi->val = val0 = in;\n\tif (c == '\\'') {\n\t\tfor(s = in;;) {\n\t\t\tc = *++in;\n\t\t\tif (c == '\\'') {\n\t\t\t\tif (*++in != '\\'')\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\telse if (!c)\n\t\t\t\tbreak;\n\t\t\t*s++ = c;\n\t\t\t}\n\t\t*s = 0;\n\t\tOi->val_len = s - val0;\n\t\t}\n\telse {\n\t\twhile(*++in > ' ');\n\t\tOi->val_len = in - val0;\n\t\t}\n\twhile((c = *in) && c <= ' ')\n\t\t++in;\n\tOi->begin = in;\n\tOi->all_len = in - in0;\n\treturn 1;\n\t}\n\n} // namespace Dakota\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/DLSolverLoadLibManager.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        Iterator\n//- Description:  Dynamic library load manager for third-party solver packages.\n//- Version: $Id$\n\n// NOTE:  THIS IS NOT ACTIVE CODE\n//\n// It is just a \"buffer\" to maintain a record of a commit that is no longer\n// maintained.  Revs related to DLib management (in the mid-May 2010)\n// were deemed inappropriate to add to the top of DakotaIterator.cpp from\n// the perperspective of DAKOTA code design/modularity.  Therefore, the\n// code has been de-activated and moved into this source file for posterity.\n//\n// Assuming we do want to maintain \"DL LoadManagement\" capabability, these\n// typedefs/functions/\"iterator\" prototypes should be re-designed and \n// implemented in a new component for DAKOTA (e.g. DynLoadLib Manager?).\n\n#include \"dakota_system_defs.hpp\"\n#include \"dakota_global_defs.hpp\"\n\n/* WJB: re-enable dependencies class-wrappers only if necessary\n#ifdef HAVE_DOT\n#include \"DOTOptimizer.hpp\"\n#endif\n#ifdef HAVE_NLPQL\n#include \"NLPQLPOptimizer.hpp\"\n#endif\n#ifdef HAVE_NPSOL\n#include \"NPSOLOptimizer.hpp\"\n#include \"NLSSOLLeastSq.hpp\"\n#endif\n// WJB: end of re-enable dependencies comment */\n\n#if(defined(HAVE_DOT) || defined(HAVE_JEGA) || defined(HAVE_NLPQL) ||               defined(HAVE_NPSOL)) \n\n#ifdef DAKOTA_SHLIB\n#undef DAKOTA_DYNLIB\n\ntypedef void (*p_vf)(void);\n\n// WJB - ToDo: prefer function over macro\n#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define find_dlsym(a,b,c) (a = (p_vf)GetProcAddress((HINSTANCE)(b),c))\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = dlsym(b,c))\n#undef NO_DLERROR\n#endif\n\n\ntypedef struct Libentry\n{\n  const char *name;\n  p_vf f;\n} Libentry;\n\ntypedef struct SharedLib\n{\n  const char *libname;\n  size_t nentries;\n  Libentry *Entries;\n} SharedLib;\n\nstruct NIDR_KWlib;\nextern \"C\" NIDR_KWlib *nidr_lib_record(void *, const char*);\nextern \"C\" void *nidr_dlopen(const char*);\n\n\nstatic p_vf Lib_load(SharedLib *L, int k)\n{\n  Libentry *e, *ee;\n  const char *lname;\n\n  void* h = nidr_dlopen(lname = L->libname);\n  if (!h) {\n#ifndef NO_DLERROR\n    if ((const char* s = dlerror()))\n      std::cerr << \"Cannot open library \\\"\" << lname << \"\\\":\\n\\t\" << s;\n    else\n#endif\n      std::cerr << \"Cannot open library \\\"\" << lname << \"\\n\";\n    std::exit(1);\n  }\n  nidr_lib_record(h, L->libname); // for cleanup (e.g., dlclose()) at endOf exec\n  e = L->Entries;\n  ee = e + L->nentries;\n\n  for(ee = e + L->nentries; e < ee; ++e)\n    if (!find_dlsym(e->f, h, e->name)) {\n      std::cerr << \"Could not find \" << e->name << \" in library \"\n                << lname << \"\\n\";\n      std::exit(2);\n    }\n\n  return L->Entries[k].f;\n}\n\n\nstatic Libentry\n  Dot_entries[] = { {\"dot_\"}, {\"dot510_\"} },\n  Npsol_entries[] = { {\"npsol_\"}, {\"nlssol_\"}, {\"npoptn2_\"} },\n  Nlpql_entries[] = { {\"nlpqlp_\"}, {\"ql_\"} };\n\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n\nstatic SharedLib\n  Dot_lib = { \"libdot.dll\", NumberOf(Dot_entries), Dot_entries },\n  Npsol_lib = { \"libnpsol.dll\", NumberOf(Npsol_entries), Npsol_entries },\n  Nlpql_lib = { \"libnlpql.dll\", NumberOf(Nlpql_entries), Nlpql_entries };\n\n\n// WJB - Dakota C++ style: obtain prototypes from their respective header files\n#define DOT F77_FUNC(dot,DOT)\n#define DOT510 F77_FUNC(dot510,DOT510)\n#define NPSOL F77_FUNC(npsol,NPSOL)\n#define NLSSOL F77_FUNC(nlssol,NLSSOL)\n#define NPOPTN2 F77_FUNC(npoptn2,NPOPTN2)\n#define NLPQLP F77_FUNC(nlpqlp,NLPQLP)\n#define QL F77_FUNC(ql,QL)\n\n/* WJB - ToDo:  verify redeclaration of an existing function and REMOVE!\nextern \"C\" void DOT(int *info, int *ngotoz, int *method,\n        int *iprint, int *ndv, int *ncon, double *x,\n        double *xl, double *xu, double *obj, int *minmax,\n        double *g, double *rprm, int *iprm, double *wk,\n        int *nrwk, int *iwk, int *nriwk)\n{\n        typedef void (*DOT_t)(int *, int *, int *,\n                        int *, int *, int *, double *,\n                        double *, double *, double *, int *,\n                        double *, double *, int *, double *,\n                        int *, int *, int *);\n        DOT_t f;\n        if (!(f = (DOT_t)Dot_entries[0].f))\n                f = (DOT_t)Lib_load(&Dot_lib, 0);\n        f(info, ngotoz, method, iprint, ndv, ncon, x, xl, xu, obj,\n          minmax, g, rprm, iprm, wk, nrwk, iwk, nriwk);\n}\n\nextern \"C\" void DOT510(int *ndv, int *ncon, int *ncola,  int *method, int *nrwk,\n        int *nriwk, int *nrb, int *ngmax, double *xl, double *xu)\n{\n        typedef void (*DOT510_t)(int *, int *, int *,  int *, int *, int *,\n                                int *, int *, double *, double *);\n        DOT510_t f;\n        if (!(f = (DOT510_t)Dot_entries[1].f))\n                f = (DOT510_t)Lib_load(&Dot_lib, 1);\n        f(ndv, ncon, ncola,  method, nrwk, nriwk, nrb, ngmax, xl, xu);\n}\n\nextern \"C\" void NPSOL(int *n, int *nclin, int *ncnln,\n        int *lda, int *ldju, int *ldr, double *a, double *bl, double *bu,\n        p_vf funcon, p_vf funobj, int *inform,  int *iter, int *istate,\n        double *c, double *cjacu, double *clamda, double *objf,\n        double *gradu, double *r, double *x, int *iw, int *leniw,\n        double *w, int *lenw)\n{\n        typedef void (*NPSOL_t)(int *, int *, int *, int *, int *,\n                        int *, double *, double *, double *, p_vf, p_vf,\n                        int *, int *, int *, double *, double *, double *,\n                        double *, double *, double *, double *, int *,\n                        int *, double *, int *);\n        NPSOL_t f;\n        if (!(f = (NPSOL_t)Npsol_entries[0].f))\n                f = (NPSOL_t)Lib_load(&Npsol_lib, 0);\n        f(n, nclin, ncnln, lda, ldju, ldr, a, bl, bu, funcon, funobj,\n          inform, iter, istate, c, cjacu, clamda, objf, gradu, r, x,\n          iw, leniw, w, lenw);\n}\n\nextern \"C\" void NLSSOL(int *m, int *n, int *nclin, int *ncnln, int *lda,\n        int *ldcju, int *ldfju, int *ldr, double *a, double *bl, double *bu,\n        p_vf funcon, p_vf funobj, int *inform, int *iter, int *istate,\n        double *c, double *cjacu, double *y, double *f, double *fjacu,\n        double *clamda, double *objf, double *r, double *x, int *iw,\n        int *leniw, double *w, int *lenw)\n{\n        typedef void (*NLSSOL_t)(int *, int *, int *, int *, int *, int *,\n                int *, int *, double *, double *, double *, p_vf, p_vf,\n                int *, int *, int *, double *, double *, double *,\n                double *, double *, double *, double *, double *,\n                double *, int *, int *, double *, int *);\n        NLSSOL_t F;\n        if (!(F = (NLSSOL_t)Npsol_entries[1].f))\n                F = (NLSSOL_t)Lib_load(&Npsol_lib, 1);\n        F(m, n, nclin, ncnln, lda, ldcju, ldfju, ldr, a, bl, bu,\n          funcon, funobj, inform, iter, istate, c, cjacu, y, f,\n          fjacu, clamda, objf, r, x, iw, leniw, w, lenw);\n}\n\nextern \"C\" void NPOPTN2(char *string, size_t string_len)\n{\n        typedef void (*NPOPTN2_t)(char *, size_t);\n        NPOPTN2_t f;\n        if (!(f = (NPOPTN2_t)Npsol_entries[2].f))\n                f = (NPOPTN2_t)Lib_load(&Npsol_lib, 2);\n        f(string, string_len);\n}\n\n\nextern \"C\" void NLPQLP(int *l, int *m, int *me, int *mmax, int *n, int *nmax, in\nt *mnn2,\n        double *x, double *f, double *g, double *df, double *dg, double *u,\n        double *xl, double *xu, double *c, double *d, double *acc,\n        double *accqp, double *stpmin, int *maxfun, int *maxit, int *max_nm,\n        double *tol_nm, int *iprint, int *mode, int *iout, int *ifail,\n        double *wa, int *lwa, int *kwa, int *lkwa, int *active,\n        int *lactiv, int *lql, p_vf qpsolve)\n{\n        typedef void (*NLPQLP_t)(int *, int *, int *, int *, int *, int *,\n                        int *mnn2, double *, double *, double *, double *,\n                        double *, double *, double *, double *, double *,                               double *, double *, double *, double *, int *, int *,\n                        int *, double *, int *, int *, int *, int *, double *,\n                        int *, int *, int *, int *, int *, int *, p_vf);\n        NLPQLP_t F;\n        if (!(F = (NLPQLP_t)Nlpql_entries[0].f))\n                F = (NLPQLP_t)Lib_load(&Nlpql_lib, 0);\n        F(l, m, me, mmax, n, nmax, mnn2, x, f, g, df, dg, u, xl, xu, c, d, acc,\n          accqp, stpmin, maxfun, maxit, max_nm, tol_nm, iprint, mode, iout,\n          ifail, wa, lwa, kwa, lkwa, active, lactiv, lql, qpsolve);\n}\n\nextern \"C\" void QL(int *m, int *me, int *mmax, int *n, int *nmax, int *mnn,\n   double *c, double *d, double *a, double *b, double *xl, double *xu,double *x,\n   double *u, double *eps, int *mode, int *iout, int *ifail, int *iprint,\n   double *war, int *lwar, int *iwar, int *liwar)\n{\n        typedef void (*QL_t)(int *, int *, int *, int *, int *, int *,\n                        double *, double *, double *, double *, double *,\n                        double *, double *, double *, double *, int *, int *,\n                        int *, int *, double *, int *, int *, int *);\n        QL_t f;\n        if (!(f = (QL_t)Nlpql_entries[1].f))\n                f = (QL_t)Lib_load(&Nlpql_lib, 1);\n        f(m, me, mmax, n, nmax, mnn, c, d, a, b, xl, xu, x, u, eps, mode,\n         iout, ifail, iprint, war, lwar, iwar, liwar);\n}\n// WJB: end of long ToDo verify redeclaration comment block */\n\n#endif // DAKOTA_SHLIB\n#endif // HAVE_DOT or NPSOL or JEGA or NPPQL\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8)\nproject(Acro CXX C)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING \n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\n#assume any modern compiler has STD\nadd_definitions(-DHAVE_STD)\n\nfunction(AcroCheckDirExists dirPath)\n  get_filename_component(dirName ${dirPath} NAME)\n  if(EXISTS ${dirPath})\n    string(TOUPPER \"${dirName}\" DIRNAME)\n    option(HAVE_${DIRNAME} \"Build with ${dirName} enabled?\" ON)\n  endif()\nendfunction()\n\n\noption(ACRO_HAVE_DLOPEN \"Enable dlopen in Acro\" ON)\nif (ACRO_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    # Use the same definition as autotools build\n    add_definitions(\"-DHAVE_DLOPEN\")\n    # TODO: add include path in relevant subdirs?\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\noption(ENABLE_TESTS \"Enable testing in Acro\" OFF)\n\nif(ENABLE_TESTS)\n\n  # Install Python virtual environment for testing\n  find_package(PythonInterp)\n  if (NOT PYTHONINTERP_FOUND)\n    message(SEND_ERROR \"Python interpreter required for ENABLE_TESTS\")\n  endif()\n\n  file(GLOB acro_python_packages packages/*/python)\n  foreach(x ${acro_python_packages})\n    list(APPEND PYTHON_PACKAGES \" -p %s/${x}\")\n  endforeach()\n\n  # TODO: OUTPUT python binary  OUTPUT python/bin/python\n  add_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python\n           ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t   ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen\n    MAIN_DEPENDENCY ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/vpykit/bin/install_python\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n    COMMAND ${CMAKE_COMMAND}\n    ARGS -E remove_directory ${CMAKE_CURRENT_BINARY_DIR}/python\n    COMMAND ${PYTHON_EXECUTABLE}\n    ARGS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/vpykit/bin/install_python\n         --src ${CMAKE_CURRENT_SOURCE_DIR}\n\t --build ${CMAKE_CURRENT_BINARY_DIR}\n\t --logfile ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t -c ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n\t -z ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n\t -p %s/admin/acro-admin\n\t -p %s/tpl/cxxtest/python\n\t ${PYTHON_PACKAGES}\n  )\n\n  add_custom_target(acro-python-env DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python)\n  add_custom_target(acro-cxxtestgen\n    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen)\n\nendif() # ENABLE_TESTS\n\n# In Acro, presence of a local tecuhos/optpp means Acro needs it,\n# but it might be provided externally by the user, e.g., in Trilinos.\n# Take care in case HAVE_TEUCHOS set by a parent instead of locally.\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/teuchos)\n  option(HAVE_TEUCHOS \"Build with Teuchos enabled?\" ON)\n  # when building inside Trilinos, the path to Teuchos will already be set\n  if (NOT BUILD_IN_TRILINOS)\n    # first probe for system-installed Trilinos\n    # this will respect Trilinos_DIR if already set\n    find_package(Trilinos QUIET)\n    if (NOT Trilinos_DIR)\n      # if no one has configured a local src Teuchos, do so\n      # this will respect Teuchos_DIR if already set\n      if(NOT Teuchos_DIR)\n        set(Teuchos_DIR ${CMAKE_CURRENT_BINARY_DIR}/tpl/teuchos)\n        message(\"Setting Teuchos_DIR to ${Teuchos_DIR}\")\n        add_subdirectory(tpl/teuchos)\n      else()\n        message(\"in ${CMAKE_CURRENT_BINARY_DIR} Teuchos_DIR already set to ${Teuchos_DIR}\")\n      endif()\n      find_package(Teuchos NO_MODULE REQUIRED)\n    else()\n      message(\"Using system trilinos in ${Trilinos_DIR}\")\n    endif()\n  endif()\nendif()\n\nadd_subdirectory(tpl)\n\nset(Coin_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/coin-cbc/cbc)\nset(TINYXML_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/tinyxml)\nset(COBYLA_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/3po/cobyla2c)\n\nadd_subdirectory(packages)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/config/acx_func_dlopen.m4": "dnl @synopsis ACX_FUNC_DLOPEN([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])\ndnl\ndnl This macro looks for the dlopen function and identifies the library\ndnl that is required to use it. On success, it sets the DLOPEN_LIBS output\ndnl variable to hold the requisite library linkages.\ndnl\ndnl ACTION-IF-FOUND is a list of shell commands to run if DLOPEN\ndnl is found, and ACTION-IF-NOT-FOUND is a list of commands\ndnl to run it if it is not found.  If ACTION-IF-FOUND is not specified,\ndnl the default action will define HAVE_DLOPEN.\ndnl\n\nAC_DEFUN([ACX_FUNC_DLOPEN], [\nacx_func_dlopen_ok=no\n\n# DLOPEN linked to by default?\nif test $acx_func_dlopen_ok = no; then\n        save_LIBS=\"$LIBS\"; LIBS=\"$LIBS\"\n        AC_CHECK_FUNC([dlopen], [acx_func_dlopen_ok=yes])\n        LIBS=\"$save_LIBS\"\nfi\n\n# DLOPEN in Standard DL library? \nif test $acx_func_dlopen_ok = no; then\n        AC_CHECK_LIB(dl, [dlopen], [acx_func_dlopen_ok=yes; DLOPEN_LIBS=\"-ldl\"])\nfi\n\nAC_SUBST(DLOPEN_LIBS)\n\n# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:\nif test x\"$acx_func_dlopen_ok\" = xyes; then\n        ifelse([$1],,AC_DEFINE(HAVE_DLOPEN,1,[Define if you have the dlopen function.]),[$1])\n        :\nelse\n        acx_func_dlopen_ok=no\n        $2\nfi\n\n])dnl ACX_FUNC_DLOPEN\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/config/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/bootstrap/root/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8)\nproject(Acro CXX C)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING \n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\n#assume any modern compiler has STD\nadd_definitions(-DHAVE_STD)\n\nfunction(AcroCheckDirExists dirPath)\n  get_filename_component(dirName ${dirPath} NAME)\n  if(EXISTS ${dirPath})\n    string(TOUPPER \"${dirName}\" DIRNAME)\n    option(HAVE_${DIRNAME} \"Build with ${dirName} enabled?\" ON)\n  endif()\nendfunction()\n\n\noption(ACRO_HAVE_DLOPEN \"Enable dlopen in Acro\" ON)\nif (ACRO_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    # Use the same definition as autotools build\n    add_definitions(\"-DHAVE_DLOPEN\")\n    # TODO: add include path in relevant subdirs?\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\noption(ENABLE_TESTS \"Enable testing in Acro\" OFF)\n\nif(ENABLE_TESTS)\n\n  # Install Python virtual environment for testing\n  find_package(PythonInterp)\n  if (NOT PYTHONINTERP_FOUND)\n    message(SEND_ERROR \"Python interpreter required for ENABLE_TESTS\")\n  endif()\n\n  file(GLOB acro_python_packages packages/*/python)\n  foreach(x ${acro_python_packages})\n    list(APPEND PYTHON_PACKAGES \" -p %s/${x}\")\n  endforeach()\n\n  # TODO: OUTPUT python binary  OUTPUT python/bin/python\n  add_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python\n           ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t   ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen\n    MAIN_DEPENDENCY ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/vpykit/bin/install_python\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n    COMMAND ${CMAKE_COMMAND}\n    ARGS -E remove_directory ${CMAKE_CURRENT_BINARY_DIR}/python\n    COMMAND ${PYTHON_EXECUTABLE}\n    ARGS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/vpykit/bin/install_python\n         --src ${CMAKE_CURRENT_SOURCE_DIR}\n\t --build ${CMAKE_CURRENT_BINARY_DIR}\n\t --logfile ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t -c ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n\t -z ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n\t -p %s/admin/acro-admin\n\t -p %s/tpl/cxxtest/python\n\t ${PYTHON_PACKAGES}\n  )\n\n  add_custom_target(acro-python-env DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python)\n  add_custom_target(acro-cxxtestgen\n    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen)\n\nendif() # ENABLE_TESTS\n\n# In Acro, presence of a local tecuhos/optpp means Acro needs it,\n# but it might be provided externally by the user, e.g., in Trilinos.\n# Take care in case HAVE_TEUCHOS set by a parent instead of locally.\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/teuchos)\n  option(HAVE_TEUCHOS \"Build with Teuchos enabled?\" ON)\n  # when building inside Trilinos, the path to Teuchos will already be set\n  if (NOT BUILD_IN_TRILINOS)\n    # first probe for system-installed Trilinos\n    # this will respect Trilinos_DIR if already set\n    find_package(Trilinos QUIET)\n    if (NOT Trilinos_DIR)\n      # if no one has configured a local src Teuchos, do so\n      # this will respect Teuchos_DIR if already set\n      if(NOT Teuchos_DIR)\n        set(Teuchos_DIR ${CMAKE_CURRENT_BINARY_DIR}/tpl/teuchos)\n        message(\"Setting Teuchos_DIR to ${Teuchos_DIR}\")\n        add_subdirectory(tpl/teuchos)\n      else()\n        message(\"in ${CMAKE_CURRENT_BINARY_DIR} Teuchos_DIR already set to ${Teuchos_DIR}\")\n      endif()\n      find_package(Teuchos NO_MODULE REQUIRED)\n    else()\n      message(\"Using system trilinos in ${Trilinos_DIR}\")\n    endif()\n  endif()\nendif()\n\nadd_subdirectory(tpl)\n\nset(Coin_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/coin-cbc/cbc)\nset(TINYXML_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/tinyxml)\nset(COBYLA_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/3po/cobyla2c)\n\nadd_subdirectory(packages)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/ampl/funcadd1.c": "/****************************************************************\nCopyright (C) 1998, 1999, 2000 Lucent Technologies\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name of Lucent or any of its entities\nnot be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#ifdef NO_FUNCADD\n#include \"funcadd.h\"\n\nchar *ix_details_ASL[] = {0};\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{ ae = ae; /* shut up non-use warning */ }\n\n#else\n\n#ifdef _WIN32\n#undef WIN32\n#define WIN32\n#endif\n\n#ifdef WIN32\n#include \"windows.h\"\n#undef Char\n#endif\n\n#define _POSIX_SOURCE\t/* for HP-UX */\n\n#include \"funcadd.h\"\n#include \"string.h\"\n\n#ifdef Old_APPLE\t/* formerly __APPLE__, for earlier versions of Mac OS X */\n#define FUNCADD \"_funcadd_ASL\"\n#endif\n#ifndef FUNCADD\n#define FUNCADD \"funcadd_ASL\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\nextern int libload_ASL(AmplExports *ae, char *s, int ns, int warn);\n#endif\n\ntypedef void Funcadd ANSI((AmplExports*));\n\nextern Char *mymalloc_ASL ANSI((size_t));\n#undef mymalloc\n#define mymalloc(x) mymalloc_ASL((size_t)(x))\n#ifndef KR_headers\nextern void free(void*);\n#endif\n\nchar *ix_details_ASL[] = {\n\t\"? {show -i options}\",\n\t\"- {do not import functions: do not access amplfunc.dll}\",\n\t\"dir {look for amplfunc.dll in directory dir}\",\n\t\"file {import functions from file rather than amplfunc.dll}\",\n\t\"\",\n\t\"If no -i option appears but $ampl_funclibs is set, assume\",\n\t\"-i $ampl_funclibs.  Otherwise, if $AMPLFUNC is set, assume\",\n\t\"-i $AMPLFUNC.  Otherwise look for amplfunc.dll in the\",\n\t\"directory that is current when execution begins.\",\n\t\"\",\n\t\"-ix and -i x are treated alike.\",\n\t0 };\n#define afdll afdll_ASL\nextern int aflibname_ASL ANSI((AmplExports*, char*, char*, int, Funcadd*, int, void(*)(void*), void*));\nextern char *i_option_ASL;\n\n#ifdef __cplusplus\n\t}\n#endif\n\nstatic int first = 1;\n\n#ifdef WIN32\n\n#define SLASH '\\\\'\nchar afdll[] = \"\\\\amplfunc.dll\";\ntypedef HINSTANCE shl_t;\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (Funcadd*)GetProcAddress(b,c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#define reg_file(x) 1\n\n static int\nAbspath(char *s)\n{\n\tint c = *s;\n\tif ((c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')\n\t && s[1] == ':'\n\t && (c = s[2]) == '\\\\' || c == '/')\n\t\treturn 1;\n\treturn 0;\n\t}\n\n#else /* !WIN32 */\n\n#define SLASH '/'\n\nchar afdll[] = \"/amplfunc.dll\";\n\n#define Abspath(s) (*(s) == '/')\n\n#ifdef KR_headers\nextern char *getcwd();\n#else\n#include \"unistd.h\"\t/* for getcwd */\n#endif\n#define GetCurrentDirectory(a,b) getcwd(b,(int)(a))\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n static int\n#ifdef KR_headers\nreg_file(name) char *name;\n#else\nreg_file(char *name)\n#endif\n{\n\tstruct stat sb;\n\treturn stat(name,&sb) ? 0 : S_ISREG(sb.st_mode);\n\t}\n\n#ifdef __hpux\n#include \"dl.h\"\n#define dlopen(x,y) shl_load(x, BIND_IMMEDIATE, 0)\n#define find_dlsym(a,b,c) !shl_findsym(&b, c, TYPE_PROCEDURE, &a)\n#define dlclose(x) shl_unload((shl_t)x)\n#define NO_DLERROR\n#else\n#ifdef Old_APPLE\n#include <mach-o/dyld.h>\ntypedef struct {\n\tNSObjectFileImage ofi;\n\tNSModule m;\n\tchar *name;\n\t} NS_pair;\ntypedef NS_pair *shl_t;\n\n static void*\nfind_sym_addr(NS_pair *p, const char *name)\n{\n\tNSSymbol nss;\n\n\tif (nss = NSLookupSymbolInModule(p->m, name))\n\t\treturn NSAddressOfSymbol(nss);\n\treturn 0;\n\t}\n\n#define find_dlsym(a,b,c) (a = find_sym_addr(b,c))\n\n static void\ndlclose(NS_pair *p)\n{\n\tif (NSUnLinkModule(p->m, NSUNLINKMODULE_OPTION_NONE))\n\t\tNSDestroyObjectFileImage(p->ofi);\n\tfree(p);\n\t}\n#define NO_DLERROR\n#else\n#include \"dlfcn.h\"\ntypedef void *shl_t;\n#define find_dlsym(a,b,c) (a = (Funcadd*)dlsym(b,c))\n#ifdef sun\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#endif /* sun */\n#endif /* Old_APPLE */\n#endif /* __hpux */\n#endif /* WIN32 */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n static shl_t\n#ifdef KR_headers\ndl_open(ae, name, warned) AmplExports *ae; char *name; int *warned;\n#else\ndl_open(AmplExports *ae, char *name, int *warned)\n#endif\n{\n/* This is a bit aggressive, but a first cut */\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tshl_t h;\n\tFILE *f;\n#ifndef KR_headers\n\tconst\n#endif\n\t      char *s;\n\n#ifdef Old_APPLE\n\tNS_pair p;\n\tNSObjectFileImageReturnCode irc;\n\tirc = NSCreateObjectFileImageFromFile(name,&p.ofi);\n\th = 0;\n\tif (irc == NSObjectFileImageSuccess) {\n\t\tp.m = NSLinkModule(p.ofi, name,\n\t\t\t  NSLINKMODULE_OPTION_BINDNOW\n\t\t\t| NSLINKMODULE_OPTION_PRIVATE\n\t\t\t| NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n\t\tif (!p.m)\n\t\t\tfprintf(stderr, \"NSLinkModule(\\\"%s\\\") failed.\\n\", name);\n\t\telse {\n\t\t\th = (NS_pair*)mymalloc(sizeof(NS_pair) + strlen(name) + 1);\n\t\t\tstrcpy(p.name = (char*)(h+1), name);\n\t\t\tmemcpy(h, &p, sizeof(NS_pair));\n\t\t\t}\n\t\t}\n\telse if (irc != NSObjectFileImageAccess)\n\t\tfprintf(stderr,\n\t\t\t\"return %d from NSCreateObjectFileImageFromFile(\\\"%s\\\")\\n\",\n\t\t\tirc, name);\n#else\n\th = dlopen(name, RTLD_NOW);\n#endif\n\tif (!h && warned && (f = fopen(name,\"rb\"))) {\n\t\tfclose(f);\n\t\tif (reg_file(name)) {\n\t\t\t*warned = 1;\n#ifdef NO_DLERROR\n\t\t\tfprintf(Stderr, \"Cannot load library %s.\\n\", name);\n#else\n\t\t\tfprintf(Stderr, \"Cannot load library %s\", name);\n\t\t\ts = dlerror();\n\t\t\tfprintf(Stderr, s ? \":\\n%s\\n\" : \".\\n\", s);\n#endif\n\t\t\t}\n\t\t}\n\treturn h;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 0;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\ndl_close(h) void *h;\n#else\ndl_close(void *h)\n#endif\n{\n#ifdef CLOSE_AT_RESET\n\tfirst = 1;\n#endif\n\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tif (h)\n\t\tdlclose(h);\n#endif\n\t}\n\n int\n#ifdef KR_headers\nlibload_ASL(ae, s, ns, warn) AmplExports *ae; char *s; int ns; int warn;\n#else\nlibload_ASL(AmplExports *ae, char *s, int ns, int warn)\n#endif\n{\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tFuncadd *fa;\n\tchar buf0[2048], *buf;\n\tint rc, warned;\n\tshl_t h;\n\tunsigned int n, nx;\n\n\tnx = 0;\n\tbuf = buf0;\n\tif (!Abspath(s)) {\n\t\tif (!GetCurrentDirectory(sizeof(buf0),buf0))\n\t\t\treturn 2;\n\t\tnx = strlen(buf0);\n\t\t}\n\tn = ns + sizeof(afdll) + nx;\n\tif (n > sizeof(buf0)) {\n\t\tbuf = (char*)mymalloc(n);\n\t\tif (nx)\n\t\t\tmemcpy(buf, buf0, nx);\n\t\t}\n\tif (nx)\n\t\tbuf[nx++] = SLASH;\n\tstrncpy(buf+nx, s, ns);\n\tbuf[nx+ns] = 0;\n\twarned = 0;\n\tif (h = dl_open(ae, buf, &warned)) {\n found:\n\t\tif (find_dlsym(fa, h, FUNCADD)\n\t\t || find_dlsym(fa, h, \"funcadd\")) {\n\t\t\trc = 0;\n#ifdef CLOSE_AT_RESET\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,0,dl_close,h);\n\t\t\t\t/* -DCLOSE_AT_RESET is for use in shared */\n\t\t\t\t/* libraries, such as MATLAB mex functions, */\n\t\t\t\t/* that may be loaded and unloaded several */\n\t\t\t\t/* times during execution of the program. */\n#else\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,1,dl_close,h);\n#endif\n\t\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Could not find funcadd in %s\\n\", buf);\n\t\t\tdl_close(h);\n\t\t\trc = 3;\n\t\t\t}\n\t\t}\n\telse if (warn) {\n\t\tif (!warned) {\n\t\t\tstrcpy(buf+nx+ns, afdll);\n\t\t\tif (h = dl_open(ae, buf, &warned))\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tif (warned)\n\t\t\trc = 2;\n\t\telse\n\t\t\tgoto notfound;\n\t\t}\n\telse {\n notfound:\n\t\tif (warn)\n\t\t\tfprintf(Stderr, \"Cannot find library %.*s\\nor %.*s%s\\n\",\n\t\t\t\tns, s, ns, s, afdll);\n\t\trc = 1;\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 3;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\nlibloop(ae, s) AmplExports *ae; char *s;\n#else\nlibloop(AmplExports *ae, char *s)\n#endif\n{\n\tchar *s1;\n\tint ns;\n\n\tfor(;; s = s1) {\n\t\twhile(*s <= ' ')\n\t\t\tif (!*s++)\n\t\t\t\treturn;\n\t\tfor(s1 = s; *++s1 >= ' '; );\n\t\twhile(s1[-1] == ' ')\n\t\t\t--s1;\n\t\tns = s1 - s;\n\t\tlibload_ASL(ae, s, ns, 1);\n\t\t}\n\t}\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{\n\tchar *s;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tif (s = i_option_ASL) {\n\t\t\tif (!*s || *s == '-' && !s[1])\n\t\t\t\treturn;\n\t\t\tlibloop(ae, s);\n\t\t\t}\n\t\telse\n\t\t\tlibload_ASL(ae, afdll+1, (int)sizeof(afdll)-2, 0);\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NO_FUNCADD */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/ampl/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/ampl/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8.4)\nproject(amplsolver)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING\n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\nset(AMPL_INCLUDE_DIRS ${amplsolver_SOURCE_DIR}\n                      ${amplsolver_BINARY_DIR} PARENT_SCOPE)\n                      \ninclude_directories(${amplsolver_SOURCE_DIR}\n                    ${amplsolver_BINARY_DIR})\n\nset(genarith_srcs arithchk.c)\nif(WIN32)\n  set_source_files_properties(arithchk.c PROPERTIES COMPILE_FLAGS \"-DNO_FPINIT\")\nelse()\n  list(APPEND genarith_srcs fpinit.c)\nendif()\nadd_executable(genarith ${genarith_srcs})\nif(UNIX)\n  target_link_libraries(genarith m)\nendif()\n\n\nconfigure_file(${amplsolver_SOURCE_DIR}/stdio1.h0 \n  ${amplsolver_BINARY_DIR}/stdio1.h)\n\nif(UNIX)\n  find_program(UNAME uname)\n  if(UNAME)\n    execute_process(COMMAND ${UNAME} -sr OUTPUT_VARIABLE System_details)\n  endif()\nelse()\n  set(System_details \"${CMAKE_SYSTEM_NAME}\")\nendif()\nstring(REPLACE \"\\n\" \"\"  System_details \"${System_details}\")\nconfigure_file(${amplsolver_SOURCE_DIR}/details.c0.cmake.in\n  ${amplsolver_BINARY_DIR}/details.c)\n\n# If genarith command fails, a zero length arith.h will be generated,\n# so remove on failure to cause later build failure\nadd_custom_command(\n  OUTPUT ${amplsolver_BINARY_DIR}/arith.h\n  COMMAND genarith > ${amplsolver_BINARY_DIR}/arith.h || \n    ${CMAKE_COMMAND} -E remove ${amplsolver_BINARY_DIR}/arith.h\n) \n\nset(amplsolver_SRCS\n  ${amplsolver_BINARY_DIR}/arith.h\n  ${amplsolver_BINARY_DIR}/details.c\n  asldate.c\n  atof.c\n  auxinfo.c\n  avldelete.c\n  avltree.c\n  b_search.c\n  basename.c\n  bscanf.c\n  com2eval.c\n  comeval.c\n  con1ival.c\n  con2ival.c\n  con2val.c\n  conadj.c\n  conpval.c\n  conscale.c\n  conval.c\n  derprop.c\n  dtoa1.c\n  duthes.c\n  dynlink.c\n  f_read.c\n  fg_read.c\n  fg_write.c\n  fgh_read.c\n  fpecatch.c\n  fpinit.c\n  fullhes.c\n  func_add.c\n  funcadd1.c\n  g_fmt.c\n  genrowno.c\n  getenv.c\n  getstub.c\n  htcl.c\n  jac0dim.c\n  jac2dim.c\n  jacdim.c\n  jacinc.c\n  jacinc1.c\n  mach.c\n  mainexit.c\n  mip_pri.c\n  misc.c\n  mypow.c\n  names.c\n  nl_obj.c\n  nqpcheck.c\n  obj2val.c\n  obj_prec.c\n  objconst.c\n  objval.c\n  objval_.c\n  op_type.c\n  pfg_read.c\n  pfghread.c\n  printf.c\n  pshvprod.c\n  punknown.c\n  qp_read.c\n  qpcheck.c\n  qsortv.c\n  readsol.c\n  repwhere.c\n  rops.c\n  rops2.c\n  sigcatch.c\n  sos_add.c\n  sphes.c\n  sscanf.c\n  stderr.c\n  studchk0.c\n  suf_sos.c\n  value.c\n  writesol.c\n  wrtsol_.c\n  ws_desc.c\n  wsu_desc.c\n  x2check.c\n  xectim.c\n  xp1known.c\n  xp2known.c)\n\nadd_library(amplsolver ${amplsolver_SRCS})\n\noption(AMPL_HAVE_DLOPEN \"Toggle support for dlopen in AMPL\" OFF)\nif (AMPL_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    add_definitions(\"-DAMPL_HAVE_DLOPEN\")\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\nif(UNIX)\n  target_link_libraries(amplsolver ${DL_LIBRARY})\nendif()\n\n# Allow AMPL build to be shared among several source packages\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/AMPLConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/AMPLConfig.cmake\n)\n\ninstall(TARGETS amplsolver EXPORT ${ExportTarget} DESTINATION lib)\n#install(TARGETS genarith EXPORT ${ExportTarget} DESTINATION bin)\n\nfile(GLOB ampl_headers *.h *.hd)\ninstall(FILES ${ampl_headers} DESTINATION include/ampl)\ninstall(FILES ${amplsolver_BINARY_DIR}/arith.h ${amplsolver_BINARY_DIR}/stdio1.h\n  DESTINATION include/ampl)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/colin/src/libs/LibLoader.cpp": "/*  _________________________________________________________________________\n *\n *  Acro: A Common Repository for Optimizers\n *  Copyright (c) 2008 Sandia Corporation.\n *  This software is distributed under the BSD License.\n *  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n *  the U.S. Government retains certain rights in this software.\n *  For more information, see the README.txt file in the top Acro directory.\n *  _________________________________________________________________________\n */\n\n#include <acro_config.h>\n#include <colin/XMLProcessor.h>\n#include <utilib/TinyXML_helper.h>\n\n// This is a bit aggressive, but a first cut\n#if defined(_WIN32) || defined(HAVE_DLOPEN)\n\n#ifdef _WIN32\n  #include <windows.h>\n  typedef HINSTANCE LIB_POINTER;\n  #define LIB_EXTENSION \".dll\"\n#else\n  #include <unistd.h>\n  #include <dlfcn.h>\n  typedef void* LIB_POINTER;\n  #define LIB_EXTENSION \".so\"\n#endif\n\n#ifdef _WIN32\n#include <direct.h>\n#define IS_REG_FILE(STAT) (( _S_IFREG & (STAT).st_mode ) > 0 )\n#else\n#define IS_REG_FILE(STAT) S_ISREG((STAT).st_mode)\n#endif\n\n\n#define DEBUG_LIBLOADER 0 \n\n#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <sys/stat.h>\n#include <iostream>\n\nusing std::cerr;\nusing std::endl;\nusing std::string;\n\n\nnamespace colin {\n\n\nLIB_POINTER load(string name)\n{\n   LIB_POINTER lib_handle;\n\n   // Ideally, we should look in common paths and for platform-specific\n   // extensions, but for now, we will assume that the full (correct)\n   // path is being provided.\n   struct stat fs;\n   if ( ! (( stat( name.c_str(), &fs ) == 0 ) && IS_REG_FILE(fs) ) )\n   {\n      cerr << \"ERROR: load(): cannot find library '\"\n                << name << \"'\" << endl;\n      return NULL;\n   }\n\n   // The actual loading stuff\n#ifdef _WIN32\n   unsigned int err_code = SetErrorMode(SEM_FAILCRITICALERRORS);\n   lib_handle = LoadLibrary(name.c_str());\n#else\n   lib_handle = dlopen(name.c_str(), RTLD_LAZY);\n#endif\n   if (!lib_handle) \n   {\n      cerr << endl << \"Module \" << name << endl;\n      cerr << \"Error during load(): \";\n#ifdef _WIN32\n      const int buflen = 1024;\n      char buf[buflen];\n      err_code = GetLastError();\n      FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, err_code, \n                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), \n                     (LPTSTR)buf, buflen, NULL );\n      cerr << buf << endl;\n#else\n      cerr << dlerror() << endl;\n#endif\n      return NULL;\n   }\n#ifdef _WIN32\n   else\n   {\n      SetLastError(0); \n   }\n#endif\n\n   return lib_handle;\n}\n\n\nclass LibraryLoadElement : public XML_Processor::ElementFunctor\n{\npublic:\n   LibraryLoadElement()\n   {}\n\n   virtual void process(TiXmlElement* root, int version)\n   {\n      string lib_name;\n      utilib::get_string_attribute(root, \"file\", lib_name);\n      if ( ! load(lib_name) )\n         EXCEPTION_MNGR(std::runtime_error, \"ERROR: Loading library '\"\n                        << lib_name << \"' failed.\");\n   }\n\n   virtual void describe(std::ostream &os, size_t indent = 0) const\n   {\n      for( ; indent > 0; --indent )\n         os << XML_Processor::indent_string;\n      os << \"Please implement LibraryLoadElement::describe\" << endl;\n   }\n  \n};\n\n\n//---------------------------------------------------------------------\n\nnamespace StaticInitializers {\nnamespace {\n\nbool RegisterFunctor()\n{\n   XMLProcessor().register_element(\"LoadLibrary\", 1, new LibraryLoadElement);\n   return true;\n}\n\n} // namespace colin::StaticInitializers::(local)\n\nextern const volatile bool library_loader = RegisterFunctor();\n\n} // namespace colin::StaticInitializers\n} // namespace colin\n\n#else  // defined(_WIN32) || defined(HAVE_DLOPEN)\n// keep this separate to avoid intermingling the namespaces with the ifdefs\nnamespace colin {\n  namespace StaticInitializers {\n    extern const volatile bool library_loader = false;\n  } // namespace colin::StaticInitializers\n} // namespace colin\n\n#endif  // defined(_WIN32) || defined(HAVE_DLOPEN)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/colin/test/unit/CMakeLists.txt": "if(ENABLE_TESTS)\n\n  include(AcroAddCxxtestRunner)\n\n  set (runner_cxxtest_src\n    TObjectType.cpp\n    TRealDomain.cpp\n    TIntDomain.cpp\n    TGradient.cpp\n    TConstraints.cpp\n    TConstraintPenalty.cpp\n    TDowncast.cpp\n    TFiniteDifference_Real.cpp\n    TFiniteDifference_MixedInt.cpp\n    TLinearConstraints.cpp\n    TNonD_Constraints.cpp\n    TNonlinearConstraints.cpp\n    TRelaxableMixedIntDomain.cpp\n    TTestApplications.cpp\n    TUnconMultiobj.cpp\n    TWeightedSum.cpp\n    TAmplApplication.cpp\n    TCache.cpp\n    TView_Pareto.cpp\n    # TReformulation_NLP1_NLP0.cpp\n    )\n\n  set(runner_static_src\n    # NONE\n    )\n\n  set(runner_include_directories\n    ${Acro_SOURCE_DIR}/packages/utilib/src\n    ${Acro_BINARY_DIR}/packages/utilib/src\n    ${Acro_SOURCE_DIR}/packages/colin/src\n    ${Acro_SOURCE_DIR}/tpl/cxxtest\n    )    \n\n  set(runner_link_libraries colin utilib)    # Need m dlopen?\n  if(HAVE_AMPL)\n    list(APPEND runner_link_libraries amplsolver)\n  endif()\n\n  # This call will add an executable called runner\n  acro_add_cxxtest_runner(colin\n    \"${runner_cxxtest_src}\" \"${runner_static_src}\" \n    \"${runner_include_directories}\" \"${runner_link_libraries}\"\n    )\n \n\n  # Auxilliary test files\n  file(GLOB all_test_inputs RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \n    print_summary*.txt example*.xml)\n  foreach(test_file ${all_test_inputs})\n    configure_file(${test_file} ${CMAKE_CURRENT_BINARY_DIR}/${test_file} COPYONLY)\n  endforeach()\n\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/mvs/v8/colin/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n#ifndef ACRO_USING_AMPL\n#define ACRO_USING_AMPL\n#endif\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n/* #ifndef ACRO_USING_COBYLA */\n/* #define ACRO_USING_COBYLA  1 */\n/* #endif */\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* Define if want to build with tinyxml enabled */\n#ifndef ACRO_USING_TINYXML\n#define ACRO_USING_TINYXML\n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/mvs/v8/coliny/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n#ifndef ACRO_USING_AMPL\n#define ACRO_USING_AMPL\n#endif\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n/* #ifndef ACRO_USING_COBYLA */\n/* #define ACRO_USING_COBYLA  1 */\n/* #endif */\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/mvs/v8/pico/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n/* #undef ACRO_USING_AMPL */\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n#ifndef ACRO_USING_COBYLA \n#define ACRO_USING_COBYLA  1 \n#endif\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#include <acro_config_bool.h>\n#include <acro_config_explicit.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/mvs/v8/pebbl/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n/* #undef ACRO_USING_AMPL */\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n#ifndef ACRO_USING_COBYLA \n#define ACRO_USING_COBYLA  1 \n#endif\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#include <acro_config_bool.h>\n#include <acro_config_explicit.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/cmake/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 56 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"X$cc_temp\" | $Xsed -e 's%.*/%%' -e \"s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n_LT_PROG_ECHO_BACKSLASH\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"X$][$1\" | $Xsed -e \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"X$<var>\" | $Xsed -e \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Fix-up fallback echo if it was mangled by the above quoting rules.\ncase \\$lt_ECHO in\n*'\\\\\\[$]0 --fallback-echo\"')dnl \"\n  lt_ECHO=\\`\\$ECHO \"X\\$lt_ECHO\" | \\$Xsed -e 's/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[$]0 --fallback-echo\"\\[$]/\\[$]0 --fallback-echo\"/'\\`\n  ;;\nesac\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\ncat >\"$CONFIG_LT\" <<_LTEOF\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate a libtool stub with the current configuration.\n\nlt_cl_silent=false\nSHELL=\\${CONFIG_SHELL-$SHELL}\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAS_SHELL_SANITIZE\n_AS_PREPARE\n\nexec AS_MESSAGE_FD>&1\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2008 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nif test \"$no_create\" != yes; then\n  lt_cl_success=:\n  test \"$silent\" = yes &&\n    lt_config_lt_args=\"$lt_config_lt_args --quiet\"\n  exec AS_MESSAGE_LOG_FD>/dev/null\n  $SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\n  exec AS_MESSAGE_LOG_FD>>config.log\n  $lt_cl_success || AS_EXIT(1)\nfi\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '/^# Generated shell functions inserted here/q' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_XSI_SHELLFNS\n\n  sed -n '/^# Generated shell functions inserted here/,$p' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\tif test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES\n# --------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=echo\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX\n# -----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nAC_LINK_IFELSE(AC_LANG_PROGRAM,[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[ifdef([AC_DIVERSION_NOTICE],\n\t     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],\n\t [AC_DIVERT_PUSH(NOTICE)])\n$1\nAC_DIVERT_POP\n])# _LT_SHELL_INIT\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Add some code to the start of the generated configure script which\n# will find an echo command which doesn't interpret backslashes.\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[_LT_SHELL_INIT([\n# Check that we are running under the correct shell.\nSHELL=${CONFIG_SHELL-/bin/sh}\n\ncase X$lt_ECHO in\nX*--fallback-echo)\n  # Remove one level of quotation (which was required for Make).\n  ECHO=`echo \"$lt_ECHO\" | sed 's,\\\\\\\\\\[$]\\\\[$]0,'[$]0','`\n  ;;\nesac\n\nECHO=${lt_ECHO-echo}\nif test \"X[$]1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X[$]1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' ; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell.\n  exec $SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\nfi\n\nif test \"X[$]1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<_LT_EOF\n[$]*\n_LT_EOF\n  exit 0\nfi\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nif test -z \"$lt_ECHO\"; then\n  if test \"X${echo_test_string+set}\" != Xset; then\n    # find a string as large as possible, as long as the shell can cope with it\n    for cmd in 'sed 50q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 2q \"[$]0\"' 'echo test'; do\n      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...\n      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&\n\t { test \"X$echo_test_string\" = \"X$echo_test_string\"; } 2>/dev/null\n      then\n        break\n      fi\n    done\n  fi\n\n  if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n     echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n    :\n  else\n    # The Solaris, AIX, and Digital Unix default echo programs unquote\n    # backslashes.  This makes it impossible to quote backslashes using\n    #   echo \"$something\" | sed 's/\\\\/\\\\\\\\/g'\n    #\n    # So, first we look for a working echo in the user's PATH.\n\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for dir in $PATH /usr/ucb; do\n      IFS=\"$lt_save_ifs\"\n      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&\n         test \"X`($dir/echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`($dir/echo \"$echo_test_string\") 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        ECHO=\"$dir/echo\"\n        break\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n\n    if test \"X$ECHO\" = Xecho; then\n      # We didn't find a better echo, so look for alternatives.\n      if test \"X`{ print -r '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`{ print -r \"$echo_test_string\"; } 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        # This shell has a builtin print -r that does the trick.\n        ECHO='print -r'\n      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&\n\t   test \"X$CONFIG_SHELL\" != X/bin/ksh; then\n        # If we have ksh, try running configure again with it.\n        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n        export ORIGINAL_CONFIG_SHELL\n        CONFIG_SHELL=/bin/ksh\n        export CONFIG_SHELL\n        exec $CONFIG_SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\n      else\n        # Try using printf.\n        ECHO='printf %s\\n'\n        if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n\t   echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  # Cool, printf works\n\t  :\n        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL\n\t  export CONFIG_SHELL\n\t  SHELL=\"$CONFIG_SHELL\"\n\t  export SHELL\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        elif echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        else\n\t  # maybe with a smaller string...\n\t  prev=:\n\n\t  for cmd in 'echo test' 'sed 2q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 50q \"[$]0\"'; do\n\t    if { test \"X$echo_test_string\" = \"X`eval $cmd`\"; } 2>/dev/null\n\t    then\n\t      break\n\t    fi\n\t    prev=\"$cmd\"\n\t  done\n\n\t  if test \"$prev\" != 'sed 50q \"[$]0\"'; then\n\t    echo_test_string=`eval $prev`\n\t    export echo_test_string\n\t    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} \"[$]0\" ${1+\"[$]@\"}\n\t  else\n\t    # Oops.  We lost completely, so just stick with echo.\n\t    ECHO=echo\n\t  fi\n        fi\n      fi\n    fi\n  fi\nfi\n\n# Copy echo and quote the copy suitably for passing to libtool from\n# the Makefile, instead of quoting the original, which is used later.\nlt_ECHO=$ECHO\nif test \"X$lt_ECHO\" = \"X$CONFIG_SHELL [$]0 --fallback-echo\"; then\n   lt_ECHO=\"$CONFIG_SHELL \\\\\\$\\[$]0 --fallback-echo\"\nfi\n\nAC_SUBST(lt_ECHO)\n])\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1],\n    [An echo program that does not interpret backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_i386\"\n\t    ;;\n\t  ppc64-*linux*|powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  ppc*-*linux*|powerpc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[AC_CHECK_TOOL(AR, ar, false)\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1])\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"X$_lt_linker_boilerplate\" | $Xsed -e '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring$teststring\" 2>/dev/null` \\\n\t         = \"XX$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\nvoid fnord() { int i=42;}\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else if (dlsym( self,\"_fnord\")) status = $lt_dlneed_uscore;\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n  if $ECHO \"$lt_search_path_spec\" | $GREP ';' >/dev/null ; then\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED -e 's/;/ /g'`\n  else\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n  fi\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO \"X$lib\" | $Xsed -e '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=\"/usr/lib /lib/w32api /lib /usr/local/lib\"\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP \"^libraries:\" | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH printed by\n        # mingw gcc, but we are running on Cygwin. Gcc prints its search\n        # path with ; separators, and with drive letters. We can handle the\n        # drive letters (cygwin fileutils understands them), so leave them,\n        # especially as we might pass files found there to a mingw objdump,\n        # which wouldn't understand a cygwinified path. Ahh.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd1*)\n  dynamic_linker=no\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[123]]*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555.\n  postinstall_cmds='chmod 555 $lib'\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  # Some binutils ld are patched to set DT_RUNPATH\n  save_LDFLAGS=$LDFLAGS\n  save_libdir=$libdir\n  eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n       LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n    [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n       [shlibpath_overrides_runpath=yes])])\n  LDFLAGS=$save_LDFLAGS\n  libdir=$save_libdir\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_DECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_DECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method == \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  AC_CHECK_TOOLS(DUMPBIN, [\"dumpbin -symbols\" \"link -dump -symbols\"], :)\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:__oline__: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| $lt_cv_sys_global_symbol_pipe \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nconst struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC*)\n\t    # IBM XL 8.0 on PPC\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl*)\n\t# IBM XL C 8.0/Fortran 10.1 on PPC\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\t*Sun\\ F*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\nAC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw* | cegcc*)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n  if test \"$with_gnu_ld\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.9.1, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to modify your PATH\n*** so that a non-GNU linker is found, and then restart.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95*)\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]*)\t\t\t# IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  # Exported symbols can be pulled into shared objects from archives\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `$ECHO \"X$deplibs\" | $Xsed -e '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    freebsd1*)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n        save_LDFLAGS=\"$LDFLAGS\"\n        LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n        AC_LINK_IFELSE(int foo(void) {},\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n        )\n        LDFLAGS=\"$save_LDFLAGS\"\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_MSG_CHECKING([whether -lc should be explicitly linked in])\n      $RM conftest*\n      echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n        soname=conftest\n        lib=conftest\n        libobjs=conftest.$ac_objext\n        deplibs=\n        wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\tpic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n        compiler_flags=-v\n        linker_flags=-v\n        verstring=\n        output_objdir=.\n        libname=conftest\n        lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n        _LT_TAGVAR(allow_undefined_flag, $1)=\n        if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n        then\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        else\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n        fi\n        _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n      else\n        cat conftest.err 1>&5\n      fi\n      $RM conftest*\n      AC_MSG_RESULT([$_LT_TAGVAR(archive_cmds_need_lc, $1)])\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],\n    [[If ld is used when linking, flag to hardcode $libdir into a binary\n    during linking.  This must work even if $libdir does not exist]])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [fix_srcfile_path], [1],\n    [Fix the shell variable $srcfile for the compiler])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_PROG_CXX\n# ------------\n# Since AC_PROG_CXX is broken, in that it returns g++ if there is no c++\n# compiler, we have our own version here.\nm4_defun([_LT_PROG_CXX],\n[\npushdef([AC_MSG_ERROR], [_lt_caught_CXX_error=yes])\nAC_PROG_CXX\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_CXX\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_CXX], [])\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[AC_REQUIRE([_LT_PROG_CXX])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n        # as there is no search path for DLLs.\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n        _LT_TAGVAR(always_export_symbols, $1)=no\n        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n          # If the export-symbols file already is a .def file (1st line\n          # is EXPORTS), use it as is; otherwise, prepend...\n          _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    cp $export_symbols $output_objdir/$soname.def;\n          else\n\t    echo EXPORTS > $output_objdir/$soname.def;\n\t    cat $export_symbols >> $output_objdir/$soname.def;\n          fi~\n          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n        else\n          _LT_TAGVAR(ld_shlibs, $1)=no\n        fi\n        ;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd[[12]]*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]]* | *pgcpp\\ [[1-5]]*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 will use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  xl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='echo'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=echo\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='echo'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_PROG_F77\n# ------------\n# Since AC_PROG_F77 is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_F77],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_F77=yes])\nAC_PROG_F77\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_F77\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_F77], [])\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_REQUIRE([_LT_PROG_F77])dnl\nAC_LANG_PUSH(Fortran 77)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${F77-\"f77\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_PROG_FC\n# -----------\n# Since AC_PROG_FC is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_FC],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_FC=yes])\nAC_PROG_FC\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_FC\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_FC], [])\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_REQUIRE([_LT_PROG_FC])dnl\nAC_LANG_PUSH(Fortran)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${FC-\"f95\"}\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_XSI_SHELLFNS\n# ---------------------\n# Bourne and XSI compatible variants of some useful shell functions.\nm4_defun([_LT_PROG_XSI_SHELLFNS],\n[case $xsi_shell in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nfunc_stripname ()\n{\n  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n  # positional parameters, so assign one to ordinary parameter first.\n  func_stripname_result=${3}\n  func_stripname_result=${func_stripname_result#\"${1}\"}\n  func_stripname_result=${func_stripname_result%\"${2}\"}\n}\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=${1%%=*}\n  func_opt_split_arg=${1#*=}\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  case ${1} in\n    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n    *)    func_lo2o_result=${1} ;;\n  esac\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=${1%.*}.lo\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=$(( $[*] ))\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=${#1}\n}\n\n_LT_EOF\n    ;;\n  *) # Bourne compatible functions.\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\ndnl func_dirname_and_basename\ndnl A portable version of this function is already defined in general.m4sh\ndnl so there is no need for it here.\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n  case ${2} in\n    .*) func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%\\\\\\\\${2}\\$%%\"`;;\n    *)  func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%${2}\\$%%\"`;;\n  esac\n}\n\n# sed scripts:\nmy_sed_long_opt='1s/^\\(-[[^=]]*\\)=.*/\\1/;q'\nmy_sed_long_arg='1s/^-[[^=]]*=//'\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_opt\"`\n  func_opt_split_arg=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_arg\"`\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  func_lo2o_result=`$ECHO \"X${1}\" | $Xsed -e \"$lo2o\"`\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=`$ECHO \"X${1}\" | $Xsed -e 's/\\.[[^.]]*$/.lo/'`\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=`expr \"$[@]\"`\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=`expr \"$[1]\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n}\n\n_LT_EOF\nesac\n\ncase $lt_shell_append in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]+=\\$[2]\"\n}\n_LT_EOF\n    ;;\n  *)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]=\\$$[1]\\$[2]\"\n}\n\n_LT_EOF\n    ;;\n  esac\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/m4/ltoptions.m4": "# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 6 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option `$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl `shared' nor `disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n  \t\t   [_LT_ENABLE_FAST_INSTALL])\n  ])\n])# _LT_SET_OPTIONS\n\n\n## --------------------------------- ##\n## Macros to handle LT_INIT options. ##\n## --------------------------------- ##\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [0], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [0], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [0], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the `shared' and\n# `disable-shared' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the `static' and\n# `disable-static' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the `fast-install'\n# and `disable-fast-install' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the `pic-only' and `no-pic'\n# LT_INIT options.\n# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [pic_mode=\"$withval\"],\n    [pic_mode=default])\n\ntest -z \"$pic_mode\" && pic_mode=m4_default([$1], [default])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n## ----------------- ##\n## LTDL_INIT Options ##\n## ----------------- ##\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/build-aux/ltmain.sh": "# Generated from ltmain.m4sh.\n\n# ltmain.sh (GNU libtool) 2.2.6b\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#     --config             show all configuration variables\n#     --debug              enable verbose shell tracing\n# -n, --dry-run            display commands without modifying any files\n#     --features           display basic configuration information and exit\n#     --mode=MODE          use operation mode MODE\n#     --preserve-dup-deps  don't remove duplicate dependency libraries\n#     --quiet, --silent    don't print informational messages\n#     --tag=TAG            use configuration variables from tag TAG\n# -v, --verbose            print informational messages (default)\n#     --version            print version information\n# -h, --help               print short or long help message\n#\n# MODE must be one of the following:\n#\n#       clean              remove files from the build directory\n#       compile            compile a source file into a libtool object\n#       execute            automatically set library path, then run a program\n#       finish             complete the installation of libtool libraries\n#       install            install libraries or executables\n#       link               create a library or an executable\n#       uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#       host-triplet:\t$host\n#       shell:\t\t$SHELL\n#       compiler:\t\t$LTCC\n#       compiler flags:\t\t$LTCFLAGS\n#       linker:\t\t$LD (gnu? $with_gnu_ld)\n#       $progname:\t\t(GNU libtool) 2.2.6b\n#       automake:\t\t$automake_version\n#       autoconf:\t\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n\nPROGRAM=ltmain.sh\nPACKAGE=libtool\nVERSION=2.2.6b\nTIMESTAMP=\"\"\npackage_revision=1.3017\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# NLS nuisances: We save the old values to restore during execute mode.\n# Only set LANG and LC_ALL to C if already set.\n# These must not be set unconditionally because not all systems understand\n# e.g. LANG=C (notably SCO).\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\n\n$lt_unset CDPATH\n\n\n\n\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"echo\"}\n: ${EGREP=\"/bin/grep -E\"}\n: ${FGREP=\"/bin/grep -F\"}\n: ${GREP=\"/bin/grep\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SED=\"/bin/sed\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\n# Generated shell functions inserted here.\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n# The name of this program:\n# In the unlikely event $progname began with a '-', it would play havoc with\n# func_echo (imagine progname=-n), so we prepend ./ in that case:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\ncase $progname in\n  -*) progname=./$progname ;;\nesac\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=:\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname${mode+: }$mode: $*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname${mode+: }$mode: \"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname${mode+: }$mode: warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"X$my_directory_path\" | $Xsed -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"X$my_dir_list\" | $Xsed -e 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"X$my_tmpdir\" | $Xsed\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"X$1\" | $Xsed -e \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"X$1\" | $Xsed \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $SED -n '/^# Usage:/,/# -h/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    $ECHO\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(automake --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(autoconf --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n     }' < \"$progpath\"\n    exit $?\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    func_error \"missing argument for $1\"\n    exit_cmd=exit\n}\n\nexit_cmd=:\n\n\n\n\n\n# Check that we have a working $ECHO.\nif test \"X$1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X$1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t'; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell, and then maybe $ECHO will work.\n  exec $SHELL \"$progpath\" --no-reexec ${1+\"$@\"}\nfi\n\nif test \"X$1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<EOF\n$*\nEOF\n  exit $EXIT_SUCCESS\nfi\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\n# $mode is unset\nnonopt=\nexecute_dlfiles=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\nopt_dry_run=false\nopt_duplicate_deps=false\nopt_silent=false\nopt_debug=:\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    $ECHO \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      $ECHO \"enable shared libraries\"\n    else\n      $ECHO \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      $ECHO \"enable static libraries\"\n    else\n      $ECHO \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# Parse options once, thoroughly.  This comes as soon as possible in\n# the script to make things like `libtool --version' happen quickly.\n{\n\n  # Shorthand for --mode=foo, only valid as the first argument\n  case $1 in\n  clean|clea|cle|cl)\n    shift; set dummy --mode clean ${1+\"$@\"}; shift\n    ;;\n  compile|compil|compi|comp|com|co|c)\n    shift; set dummy --mode compile ${1+\"$@\"}; shift\n    ;;\n  execute|execut|execu|exec|exe|ex|e)\n    shift; set dummy --mode execute ${1+\"$@\"}; shift\n    ;;\n  finish|finis|fini|fin|fi|f)\n    shift; set dummy --mode finish ${1+\"$@\"}; shift\n    ;;\n  install|instal|insta|inst|ins|in|i)\n    shift; set dummy --mode install ${1+\"$@\"}; shift\n    ;;\n  link|lin|li|l)\n    shift; set dummy --mode link ${1+\"$@\"}; shift\n    ;;\n  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n    shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n    ;;\n  esac\n\n  # Parse non-mode specific arguments:\n  while test \"$#\" -gt 0; do\n    opt=\"$1\"\n    shift\n\n    case $opt in\n      --config)\t\tfunc_config\t\t\t\t\t;;\n\n      --debug)\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\topt_debug='set -x'\n\t\t\t$opt_debug\n\t\t\t;;\n\n      -dlopen)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\texecute_dlfiles=\"$execute_dlfiles $1\"\n\t\t\tshift\n\t\t\t;;\n\n      --dry-run | -n)\topt_dry_run=:\t\t\t\t\t;;\n      --features)       func_features\t\t\t\t\t;;\n      --finish)\t\tmode=\"finish\"\t\t\t\t\t;;\n\n      --mode)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tcase $1 in\n\t\t\t  # Valid mode arguments:\n\t\t\t  clean)\t;;\n\t\t\t  compile)\t;;\n\t\t\t  execute)\t;;\n\t\t\t  finish)\t;;\n\t\t\t  install)\t;;\n\t\t\t  link)\t\t;;\n\t\t\t  relink)\t;;\n\t\t\t  uninstall)\t;;\n\n\t\t\t  # Catch anything else as an error\n\t\t\t  *) func_error \"invalid argument for $opt\"\n\t\t\t     exit_cmd=exit\n\t\t\t     break\n\t\t\t     ;;\n\t\t        esac\n\n\t\t\tmode=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\n      --preserve-dup-deps)\n\t\t\topt_duplicate_deps=:\t\t\t\t;;\n\n      --quiet|--silent)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=:\n\t\t\t;;\n\n      --verbose| -v)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\t;;\n\n      --tag)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tpreserve_args=\"$preserve_args $opt $1\"\n\t\t\tfunc_enable_tag \"$1\"\t# tagname is set here\n\t\t\tshift\n\t\t\t;;\n\n      # Separate optargs to long options:\n      -dlopen=*|--mode=*|--tag=*)\n\t\t\tfunc_opt_split \"$opt\"\n\t\t\tset dummy \"$func_opt_split_opt\" \"$func_opt_split_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t\t;;\n      --help)\t\topt_help=:\t\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t\t;;\n\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\"\t;;\n\n      *)\t\tnonopt=\"$opt\"\n\t\t\tbreak\n\t\t\t;;\n    esac\n  done\n\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps\n      ;;\n  esac\n\n  # Having warned about all mis-specified options, bail out if\n  # anything was wrong.\n  $exit_cmd $EXIT_FAILURE\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n$opt_help || {\n  # Sanity checks first:\n  func_check_version_match\n\n  if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n    func_fatal_configuration \"not configured to build any kind of library\"\n  fi\n\n  test -z \"$mode\" && func_fatal_error \"error: you must specify a MODE.\"\n\n\n  # Darwin sucks\n  eval std_shrext=\\\"$shrext_cmds\\\"\n\n\n  # Only execute mode is allowed to have -dlopen flags.\n  if test -n \"$execute_dlfiles\" && test \"$mode\" != execute; then\n    func_error \"unrecognized option \\`-dlopen'\"\n    $ECHO \"$help\" 1>&2\n    exit $EXIT_FAILURE\n  fi\n\n  # Change the help message to a mode-specific one.\n  generic_help=\"$help\"\n  help=\"Try \\`$progname --help --mode=$mode' for more information.\"\n}\n\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_ltwrapper_scriptname_result=\"\"\n    if func_ltwrapper_executable_p \"$1\"; then\n\tfunc_dirname_and_basename \"$1\" \"\" \".\"\n\tfunc_stripname '' '.exe' \"$func_basename_result\"\n\tfunc_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n    fi\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n        func_quote_for_eval \"$arg\"\n\tCC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n      done\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_quote_for_eval \"$arg\"\n\t      CC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n\t    done\n\t    case \"$@ \" in\n\t      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          pie_flag=\"$pie_flag $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  later=\"$later $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_quote_for_eval \"$arg\"\n\t    lastarg=\"$lastarg $func_quote_for_eval_result\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  base_compile=\"$base_compile $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_quote_for_eval \"$lastarg\"\n      base_compile=\"$base_compile $func_quote_for_eval_result\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.obj | *.sx)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"X$srcfile\" | $Xsed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      removelist=\"$removelist $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    removelist=\"$removelist $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    if test -n \"$fix_srcfile_path\"; then\n      eval srcfile=\\\"$fix_srcfile_path\\\"\n    fi\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tcommand=\"$command -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tcommand=\"$command -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      command=\"$command$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\ntest \"$mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to building PIC objects only\n  -prefer-non-pic   try to building non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$mode'\"\n        ;;\n    esac\n\n    $ECHO\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n\n    exit $?\n}\n\n  # Now that we've collected a possible --mode arg, show help if necessary\n  $opt_help && func_mode_help\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $execute_dlfiles; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  dir=\"$dir/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -*) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_quote_for_eval \"$file\"\n      args=\"$args $func_quote_for_eval_result\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\t$ECHO \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libdirs=\"$nonopt\"\n    admincmds=\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for dir\n      do\n\tlibdirs=\"$libdirs $dir\"\n      done\n\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || admincmds=\"$admincmds\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    $ECHO \"Libraries have been installed in:\"\n    for libdir in $libdirs; do\n      $ECHO \"   $libdir\"\n    done\n    $ECHO\n    $ECHO \"If you ever happen to want to link against installed libraries\"\n    $ECHO \"in a given directory, LIBDIR, you must either use libtool, and\"\n    $ECHO \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n    $ECHO \"flag during linking and do at least one of the following:\"\n    if test -n \"$shlibpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n      $ECHO \"     during execution\"\n    fi\n    if test -n \"$runpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n      $ECHO \"     during linking\"\n    fi\n    if test -n \"$hardcode_libdir_flag_spec\"; then\n      libdir=LIBDIR\n      eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n      $ECHO \"   - use the \\`$flag' linker flag\"\n    fi\n    if test -n \"$admincmds\"; then\n      $ECHO \"   - have your system administrator run these commands:$admincmds\"\n    fi\n    if test -f /etc/ld.so.conf; then\n      $ECHO \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n    fi\n    $ECHO\n\n    $ECHO \"See any operating system documentation about shared libraries for\"\n    case $host in\n      solaris2.[6789]|solaris2.1[0-9])\n        $ECHO \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t$ECHO \"pages.\"\n\t;;\n      *)\n        $ECHO \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n        ;;\n    esac\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    exit $EXIT_SUCCESS\n}\n\ntest \"$mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       $ECHO \"X$nonopt\" | $GREP shtool >/dev/null; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    install_prog=\"$install_prog$func_quote_for_eval_result\"\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    for arg\n    do\n      if test -n \"$dest\"; then\n\tfiles=\"$files $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tcase \" $install_prog \" in\n\t*[\\\\\\ /]cp\\ *) ;;\n\t*) prev=$arg ;;\n\tesac\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      install_prog=\"$install_prog $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tstaticlibs=\"$staticlibs $file\"\n\t;;\n\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) current_libdirs=\"$current_libdirs $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) future_libdirs=\"$future_libdirs $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tdir=\"$dir$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"X$destdir\" | $Xsed -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && staticlibs=\"$staticlibs $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"X$lib\" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"X$relink_command\" | $Xsed -e 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"X$file$stripped_ext\" | $Xsed -e \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"X$objs$old_deplibs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_verbose \"extracting global C symbols from \\`$progfile'\"\n\t    $opt_dry_run || eval \"$NM $progfile | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n\t  $opt_dry_run || {\n\t    eval '$ECHO \": $name \" >> \"$nlist\"'\n\t    eval \"$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t  }\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    $ECHO '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\n\"\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* )\n\t    $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n/* DATA imports from DLLs on WIN32 con't be const, because\n   runtime relocations are performed -- see ld's documentation\n   on pseudo-relocs.  */\"\n\t    lt_dlsym_const= ;;\n\t  *osf5*)\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* This system does not cope well with relocations in const data */\"\n\t    lt_dlsym_const= ;;\n\t  *)\n\t    lt_dlsym_const=const ;;\n\t  esac\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\nextern $lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\n$lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) symtab_cflags=\"$symtab_cflags $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then\n      win32_nmres=`eval $NM -f posix -A $1 |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" 'exit $?'\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n\n# func_emit_wrapper_part1 [arg=no]\n#\n# Emit the first part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part1 ()\n{\n\tfunc_emit_wrapper_part1_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part1_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed='${SED} -e 1s/^X//'\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    ECHO=\\\"$qecho\\\"\n    file=\\\"\\$0\\\"\n    # Make sure echo works.\n    if test \\\"X\\$1\\\" = X--no-reexec; then\n      # Discard the --no-reexec flag, and continue.\n      shift\n    elif test \\\"X\\`{ \\$ECHO '\\t'; } 2>/dev/null\\`\\\" = 'X\\t'; then\n      # Yippee, \\$ECHO works!\n      :\n    else\n      # Restart under the correct shell, and then maybe \\$ECHO will work.\n      exec $SHELL \\\"\\$0\\\" --no-reexec \\${1+\\\"\\$@\\\"}\n    fi\n  fi\\\n\"\n\t$ECHO \"\\\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  done\n\"\n}\n# end: func_emit_wrapper_part1\n\n# func_emit_wrapper_part2 [arg=no]\n#\n# Emit the second part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part2 ()\n{\n\tfunc_emit_wrapper_part2_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part2_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"X\\$thisdir\\\" | \\$Xsed -e 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"X\\$$shlibpath_var\\\" | \\$Xsed -e 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t# fixup the dll searchpath if we need to.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n\"\n\tcase $host in\n\t# Backslashes separate directories on plain windows\n\t*-*-mingw | *-*-os2* | *-cegcc*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\n\t*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\tesac\n\t$ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    $ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n# end: func_emit_wrapper_part2\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_arg1=$1\n\tfi\n\n\t# split this up so that func_emit_cwrapperexe_src\n\t# can call each part independently.\n\tfunc_emit_wrapper_part1 \"${func_emit_wrapper_arg1}\"\n\tfunc_emit_wrapper_part2 \"${func_emit_wrapper_arg1}\"\n}\n\n\n# func_to_host_path arg\n#\n# Convert paths to host format when used with build tools.\n# Intended for use with \"native\" mingw (where libtool itself\n# is running under the msys shell), or in the following cross-\n# build environments:\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n# where wine is equipped with the `winepath' executable.\n# In the native mingw case, the (msys) shell automatically\n# converts paths for any non-msys applications it launches,\n# but that facility isn't available from inside the cwrapper.\n# Similar accommodations are necessary for $host mingw and\n# $build cygwin.  Calling this function does no harm for other\n# $host/$build combinations not listed above.\n#\n# ARG is the path (on $build) that should be converted to\n# the proper representation for $host. The result is stored\n# in $func_to_host_path_result.\nfunc_to_host_path ()\n{\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        case $build in\n          *mingw* ) # actually, msys\n            # awkward: cmd appends spaces to result\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_path_tmp1=`( cmd //c echo \"$1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_path_tmp1=`cygpath -w \"$1\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # Unfortunately, winepath does not exit with a non-zero\n            # error code, so we are forced to check the contents of\n            # stdout. On the other hand, if the command is not\n            # found, the shell will set an exit code of 127 and print\n            # *an error message* to stdout. So we must check for both\n            # error code of zero AND non-empty stdout, which explains\n            # the odd construction:\n            func_to_host_path_tmp1=`winepath -w \"$1\" 2>/dev/null`\n            if test \"$?\" -eq 0 && test -n \"${func_to_host_path_tmp1}\"; then\n              func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n                $SED -e \"$lt_sed_naive_backslashify\"`\n            else\n              # Allow warning below.\n              func_to_host_path_result=\"\"\n            fi\n            ;;\n        esac\n        if test -z \"$func_to_host_path_result\" ; then\n          func_error \"Could not determine host path corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback:\n          func_to_host_path_result=\"$1\"\n        fi\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_path\n\n# func_to_host_pathlist arg\n#\n# Convert pathlists to host format when used with build tools.\n# See func_to_host_path(), above. This function supports the\n# following $build/$host combinations (but does no harm for\n# combinations not listed here):\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n#\n# Path separators are also converted from $build format to\n# $host format. If ARG begins or ends with a path separator\n# character, it is preserved (but converted to $host format)\n# on output.\n#\n# ARG is a pathlist (on $build) that should be converted to\n# the proper representation on $host. The result is stored\n# in $func_to_host_pathlist_result.\nfunc_to_host_pathlist ()\n{\n  func_to_host_pathlist_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        # Remove leading and trailing path separator characters from\n        # ARG. msys behavior is inconsistent here, cygpath turns them\n        # into '.;' and ';.', and winepath ignores them completely.\n        func_to_host_pathlist_tmp2=\"$1\"\n        # Once set for this call, this variable should not be\n        # reassigned. It is used in tha fallback case.\n        func_to_host_pathlist_tmp1=`echo \"$func_to_host_pathlist_tmp2\" |\\\n          $SED -e 's|^:*||' -e 's|:*$||'`\n        case $build in\n          *mingw* ) # Actually, msys.\n            # Awkward: cmd appends spaces to result.\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_pathlist_tmp2=`( cmd //c echo \"$func_to_host_pathlist_tmp1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_pathlist_tmp2=`cygpath -w -p \"$func_to_host_pathlist_tmp1\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # unfortunately, winepath doesn't convert pathlists\n            func_to_host_pathlist_result=\"\"\n            func_to_host_pathlist_oldIFS=$IFS\n            IFS=:\n            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do\n              IFS=$func_to_host_pathlist_oldIFS\n              if test -n \"$func_to_host_pathlist_f\" ; then\n                func_to_host_path \"$func_to_host_pathlist_f\"\n                if test -n \"$func_to_host_path_result\" ; then\n                  if test -z \"$func_to_host_pathlist_result\" ; then\n                    func_to_host_pathlist_result=\"$func_to_host_path_result\"\n                  else\n                    func_to_host_pathlist_result=\"$func_to_host_pathlist_result;$func_to_host_path_result\"\n                  fi\n                fi\n              fi\n              IFS=:\n            done\n            IFS=$func_to_host_pathlist_oldIFS\n            ;;\n        esac\n        if test -z \"$func_to_host_pathlist_result\" ; then\n          func_error \"Could not determine the host path(s) corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback. This may break if $1 contains DOS-style drive\n          # specifications. The fix is not to complicate the expression\n          # below, but for the user to provide a working wine installation\n          # with winepath so that path translation in the cross-to-mingw\n          # case works properly.\n          lt_replace_pathsep_nix_to_dos=\"s|:|;|g\"\n          func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp1\" |\\\n            $SED -e \"$lt_replace_pathsep_nix_to_dos\"`\n        fi\n        # Now, add the leading and trailing path separators back\n        case \"$1\" in\n          :* ) func_to_host_pathlist_result=\";$func_to_host_pathlist_result\"\n            ;;\n        esac\n        case \"$1\" in\n          *: ) func_to_host_pathlist_result=\"$func_to_host_pathlist_result;\"\n            ;;\n        esac\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_pathlist\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n\n   Currently, it simply execs the wrapper *script* \"$SHELL $output\",\n   but could eventually absorb all of the scripts functionality and\n   exec $objdir/$outputname directly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n# define setmode _setmode\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n#  define HAVE_SETENV\n#  ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n#  endif\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n#ifdef _MSC_VER\n# define S_IXUSR _S_IEXEC\n# define stat _stat\n# ifndef _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifdef __CYGWIN__\n# define FOPEN_WB \"wb\"\n#endif\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#undef LTWRAPPER_DEBUGPRINTF\n#if defined DEBUGWRAPPER\n# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args\nstatic void\nltwrapper_debugprintf (const char *fmt, ...)\n{\n    va_list args;\n    va_start (args, fmt);\n    (void) vfprintf (stderr, fmt, args);\n    va_end (args);\n}\n#else\n# define LTWRAPPER_DEBUGPRINTF(args)\n#endif\n\nconst char *program_name = NULL;\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_fatal (const char *message, ...);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_opt_process_env_set (const char *arg);\nvoid lt_opt_process_env_prepend (const char *arg);\nvoid lt_opt_process_env_append (const char *arg);\nint lt_split_name_value (const char *arg, char** name, char** value);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\n\nstatic const char *script_text_part1 =\nEOF\n\n\t    func_emit_wrapper_part1 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\t    cat <<EOF\n\nstatic const char *script_text_part2 =\nEOF\n\t    func_emit_wrapper_part2 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\n\t    cat <<EOF\nconst char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_pathlist \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_pathlist \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n#define LTWRAPPER_OPTION_PREFIX_LENGTH  5\n\nstatic const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\n\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\n\nstatic const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;\nstatic const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX \"env-set\";\n  /* argument is putenv-style \"foo=bar\", value of foo is set to bar */\n\nstatic const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;\nstatic const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX \"env-prepend\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is bar${foo} */\n\nstatic const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;\nstatic const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX \"env-append\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is ${foo}bar */\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) argv[0]      : %s\\n\", argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) program_name : %s\\n\", program_name));\n\n  /* very simple arg parsing; don't want to rely on getopt */\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  printf (\"%s\", script_text_part1);\n\t  printf (\"%s\", script_text_part2);\n\t  return 0;\n\t}\n    }\n\n  newargz = XMALLOC (char *, argc + 1);\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (\"Couldn't find %s\", argv[0]);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (before symlink chase) at : %s\\n\",\n\t\t\t  tmp_pathspec));\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (after symlink chase) at : %s\\n\",\n\t\t\t  actual_cwrapper_path));\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(main) libtool target name: %s\\n\",\n\t\t\t  target_name));\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)\n        {\n          if (argv[i][env_set_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_set_opt_len + 1;\n              lt_opt_process_env_set (p);\n            }\n          else if (argv[i][env_set_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_set (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_set_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)\n        {\n          if (argv[i][env_prepend_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_prepend_opt_len + 1;\n              lt_opt_process_env_prepend (p);\n            }\n          else if (argv[i][env_prepend_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_prepend (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_prepend_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)\n        {\n          if (argv[i][env_append_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_append_opt_len + 1;\n              lt_opt_process_env_append (p);\n            }\n          else if (argv[i][env_append_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_append (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_append_opt);\n          continue;\n        }\n      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (\"Unrecognized option in %s namespace: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\n  LTWRAPPER_DEBUGPRINTF     ((\"(main) lt_argv_zero : %s\\n\", (lt_argv_zero ? lt_argv_zero : \"<NULL>\")));\n  for (i = 0; i < newargc; i++)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"(main) newargz[%d]   : %s\\n\", i, (newargz[i] ? newargz[i] : \"<NULL>\")));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      LTWRAPPER_DEBUGPRINTF ((\"(main) failed to launch target \\\"%s\\\": errno = %d\\n\", lt_argv_zero, errno));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (\"Memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(check_executable)  : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(make_executable)   : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(find_executable)   : %s\\n\",\n\t\t\t  wrapper ? (*wrapper ? wrapper : \"EMPTY!\") : \"NULL!\"));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (\"getcwd failed\");\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (\"getcwd failed\");\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"checking path component for symlinks: %s\\n\",\n\t\t\t      tmp_pathspec));\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  char *errstr = strerror (errno);\n\t  lt_fatal (\"Error accessing file %s (%s)\", tmp_pathspec, errstr);\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (\"Could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nstatic void\nlt_error_core (int exit_status, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s: %s: \", program_name, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_setenv) setting '%s' to '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nint\nlt_split_name_value (const char *arg, char** name, char** value)\n{\n  const char *p;\n  int len;\n  if (!arg || !*arg)\n    return 1;\n\n  p = strchr (arg, (int)'=');\n\n  if (!p)\n    return 1;\n\n  *value = xstrdup (++p);\n\n  len = strlen (arg) - strlen (*value);\n  *name = XMALLOC (char, len);\n  strncpy (*name, arg, len-1);\n  (*name)[len - 1] = '\\0';\n\n  return 0;\n}\n\nvoid\nlt_opt_process_env_set (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_set_opt, arg);\n    }\n\n  lt_setenv (name, value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_prepend (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_prepend_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 0);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_append (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_append_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 1);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\n\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      dlfiles=\"$dlfiles $arg\"\n\t    else\n\t      dlprefiles=\"$dlprefiles $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) deplibs=\"$deplibs $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      moreargs=\"$moreargs $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      dlfiles=\"$dlfiles $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    dlprefiles=\"$dlprefiles $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) rpath=\"$rpath $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) xrpath=\"$xrpath $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  weak_libs=\"$weak_libs $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname '-L' '' \"$arg\"\n\tdir=$func_stripname_result\n\tif test -z \"$dir\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"*) ;;\n\t*)\n\t  deplibs=\"$deplibs -L$dir\"\n\t  lib_search_path=\"$lib_search_path $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"X$dir\" | $Xsed -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tdeplibs=\"$deplibs $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) xrpath=\"$xrpath $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $wl$func_quote_for_eval_result\"\n\t  linker_flags=\"$linker_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler\n      # -r[0-9][0-9]* specifies the processor on the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler\n      # +DA*, +DD* enable 64-bit mode on the HP compiler\n      # -q* pass through compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* pass through architecture-specific\n      # compiler args for GCC\n      # -F/path gives path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC\n      # @file GCC response files\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        compiler_flags=\"$compiler_flags $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tobjs=\"$objs $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tdlfiles=\"$dlfiles $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      dlprefiles=\"$dlprefiles $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tdeplibs=\"$deplibs $arg\"\n\told_deplibs=\"$old_deplibs $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  dlfiles=\"$dlfiles $arg\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  dlprefiles=\"$dlprefiles $arg\"\n\t  prev=\n\telse\n\t  deplibs=\"$deplibs $arg\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"X\\${$shlibpath_var}\\\" \\| \\$Xsed -e \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_duplicate_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\tesac\n      fi\n      libs=\"$libs $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) specialdeplibs=\"$specialdeplibs $pre_post_deps\" ;;\n\t  esac\n\t  pre_post_deps=\"$pre_post_deps $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  case $lib in\n\t  *.la)\tfunc_source \"$lib\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n            deplib_base=`$ECHO \"X$deplib\" | $Xsed -e \"$basename\"`\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) deplibs=\"$deplibs $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    compiler_flags=\"$compiler_flags $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    dir=$func_stripname_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) xrpath=\"$xrpath $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la) lib=\"$deplib\" ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"X$deplib\\\"\" 2>/dev/null | $Xsed -e 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\t$ECHO \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      newdlprefiles=\"$newdlprefiles $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      newdlfiles=\"$newdlfiles $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"X$inherited_linker_flags\" | $Xsed -e 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) new_inherited_linker_flags=\"$new_inherited_linker_flags $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \"X $dependency_libs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && dlfiles=\"$dlfiles $dlopen\"\n\t  test -n \"$dlpreopen\" && dlprefiles=\"$dlprefiles $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    convenience=\"$convenience $ladir/$objdir/$old_library\"\n\t    old_convenience=\"$old_convenience $ladir/$objdir/$old_library\"\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tfor l in $old_library $library_names; do\n\t  linklib=\"$l\"\n\tdone\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    dlprefiles=\"$dlprefiles $lib $dependency_libs\"\n\t  else\n\t    newdlfiles=\"$newdlfiles $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$libdir\"\n\t    absdir=\"$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t  # are required to link).\n\t  if test -n \"$old_library\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$old_library\"\n\t    # Keep a list of preopened convenience libraries to check\n\t    # that they are being used correctly in the link pass.\n\t    test -z \"$libdir\" && \\\n\t\tdlpreconveniencelibs=\"$dlpreconveniencelibs $dir/$old_library\"\n\t  # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t  elif test -n \"$dlname\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$dlname\"\n\t  else\n\t    newdlprefiles=\"$newdlprefiles $dir/$linklib\"\n\t  fi\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  newlib_search_path=\"$newlib_search_path $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) temp_rpath=\"$temp_rpath$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    $ECHO\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  $ECHO\n\t\t\t  $ECHO \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  $ECHO \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$dir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) compile_shlibpath=\"$compile_shlibpath$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    $ECHO\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t    $ECHO \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      $ECHO \"*** But as you try to build a module library, libtool will still create \"\n\t      $ECHO \"*** a static module, that should work as long as the dlopening application\"\n\t      $ECHO \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\t$ECHO\n\t\t$ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t\t$ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\t$ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t\t$ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) xrpath=\"$xrpath $temp_xrpath\";;\n\t\t   esac;;\n\t      *) temp_deplibs=\"$temp_deplibs $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  newlib_search_path=\"$newlib_search_path $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=\"$func_dirname_result\"\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      compiler_flags=\"$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      linker_flags=\"$linker_flags -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) lib_search_path=\"$lib_search_path $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  tmp_libs=\"$tmp_libs $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      objs=\"$objs$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  $ECHO\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  libobjs=\"$libobjs $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  verstring=\"$verstring:${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      libobjs=\"$libobjs $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       removelist=\"$removelist $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\toldlibs=\"$oldlibs $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}'$/d' -e \"$lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"X$lib_search_path \" | $Xsed -e \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"X$deplibs \" | $Xsed -e \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"X$dependency_libs \" | $Xsed -e \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  temp_xrpath=\"$temp_xrpath -R$libdir\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlfiles=\"$dlfiles $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlprefiles=\"$dlprefiles $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      deplibs=\"$deplibs -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    $ECHO\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    $ECHO \"*** shared version of the library, which I believe you do not have\"\n\t\t    $ECHO \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    $ECHO \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      $ECHO\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t      $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      $ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t      $ECHO \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      $ECHO \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  $ECHO\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  $ECHO \"*** make it link in!  You will probably need to install it or some\"\n\t\t  $ECHO \"*** library that it depends on before this library will be fully\"\n\t\t  $ECHO \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"X$potlib\" | $Xsed -e 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tnewdeplibs=\"$newdeplibs $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"X$potent_lib\\\"\" 2>/dev/null | $Xsed -e 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \"X $deplibs\" | $Xsed \\\n\t      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \"X $tmp_deplibs\" | $Xsed -e \"s,$i,,\"`\n\t    done\n\t  fi\n\t  if $ECHO \"X $tmp_deplibs\" | $Xsed -e 's/[\t ]//g' |\n\t     $GREP . >/dev/null; then\n\t    $ECHO\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      $ECHO \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      $ECHO \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    $ECHO \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t  fi\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    $ECHO\n\t    $ECHO \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    $ECHO \"*** a static module, that should work as long as the dlopening\"\n\t    $ECHO \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      $ECHO\n\t      $ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t      $ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      $ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t      $ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    $ECHO \"*** The inter-library dependencies that have been dropped here will be\"\n\t    $ECHO \"*** automatically added whenever a program is linked with this library\"\n\t    $ECHO \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      $ECHO\n\t      $ECHO \"*** Since this library must not contain undefined symbols,\"\n\t      $ECHO \"*** because either the platform does not support them or\"\n\t      $ECHO \"*** it was explicitly requested with -no-undefined,\"\n\t      $ECHO \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \"X $deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    hardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tdep_rpath=\"$dep_rpath $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    if test -n \"$hardcode_libdir_flag_spec_ld\"; then\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec_ld\\\"\n\t    else\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\n\t    fi\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      rpath=\"$rpath$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  linknames=\"$linknames $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  delfiles=\"$delfiles $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      eval cmd=\\\"$cmd\\\"\n\t      func_len \" $cmd\"\n\t      len=$func_len_result\n\t      if test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    tmp_deplibs=\"$tmp_deplibs $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    generated=\"$generated $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    libobjs=\"$libobjs $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  linker_flags=\"$linker_flags $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  output_la=`$ECHO \"X$output\" | $Xsed -e \"$basename\"`\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    $ECHO 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    $ECHO ')' >> $output\n\t    delfiles=\"$delfiles $output\"\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    delfiles=\"$delfiles $output\"\n\t    output=$firstobj\\\"$file_list_spec$output\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    eval concat_cmds=\\\"$reload_cmds $objlist $last_robj\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds $objlist $last_robj~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=$obj\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds $objlist $last_robj\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      delfiles=\"$delfiles $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  libobjs=\"$libobjs $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"X$tmp_whole_archive_flags\" | $Xsed -e 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}$'/d' -e '/\\.lib$/d' -e \"$lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      compile_command=\"$compile_command ${wl}-bind_at_load\"\n\t      finalize_command=\"$finalize_command ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      compile_command=\"$compile_command $compile_deplibs\"\n      finalize_command=\"$finalize_command $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_perm_rpath=\"$finalize_perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"X$compile_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"X$finalize_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *cegcc)\n        # Disable wrappers for cegcc, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"X$compile_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"X$compile_var$compile_command$compile_rpath\" | $Xsed -e 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Quote $ECHO for shipping.\n      if test \"X$ECHO\" = \"X$SHELL $progpath --fallback-echo\"; then\n\tcase $progpath in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) qecho=\"$SHELL $progpath --fallback-echo\";;\n\t*) qecho=\"$SHELL `pwd`/$progpath --fallback-echo\";;\n\tesac\n\tqecho=`$ECHO \"X$qecho\" | $Xsed -e \"$sed_quote_subst\"`\n      else\n\tqecho=`$ECHO \"X$ECHO\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    oldobjs=\"$oldobjs $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tgenerated=\"$generated $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\toldobjs=\"$oldobjs $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  oldobjs=\"$oldobjs $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  $ECHO \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      oldobjs=\"$oldobjs $gentop/$newobj\"\n\t      ;;\n\t    *) oldobjs=\"$oldobjs $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tnewdependency_libs=\"$newdependency_libs $libdir/$name\"\n\t\t;;\n\t      *) newdependency_libs=\"$newdependency_libs $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlfiles=\"$newdlfiles $libdir/$name\"\n\t\t;;\n\t      *) newdlfiles=\"$newdlfiles $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlprefiles=\"$newdlprefiles $libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlfiles=\"$newdlfiles $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlprefiles=\"$newdlprefiles $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$mode\" = link || test \"$mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) RM=\"$RM $arg\"; rmforce=yes ;;\n      -*) RM=\"$RM $arg\" ;;\n      *) files=\"$files $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    origobjdir=\"$objdir\"\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\tobjdir=\"$origobjdir\"\n      else\n\tobjdir=\"$dir/$origobjdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$mode\" = uninstall && objdir=\"$dir\"\n\n      # Remember objdir for removal later, being careful to avoid duplicates\n      if test \"$mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $objdir \"*) ;;\n\t  *) rmdirs=\"$rmdirs $objdir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    rmfiles=\"$rmfiles $objdir/$n\"\n\t  done\n\t  test -n \"$old_library\" && rmfiles=\"$rmfiles $objdir/$old_library\"\n\n\t  case \"$mode\" in\n\t  clean)\n\t    case \"  $library_names \" in\n\t    # \"  \" in the beginning catches empty $dlname\n\t    *\" $dlname \"*) ;;\n\t    *) rmfiles=\"$rmfiles $objdir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && rmfiles=\"$rmfiles $objdir/$name $objdir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    rmfiles=\"$rmfiles $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      rmfiles=\"$rmfiles $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    rmfiles=\"$rmfiles $objdir/$name $objdir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      rmfiles=\"$rmfiles $objdir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      rmfiles=\"$rmfiles $objdir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n    objdir=\"$origobjdir\"\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$mode\" = uninstall || test \"$mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/ampl/funcadd1.c": "/****************************************************************\nCopyright (C) 1998, 1999, 2000 Lucent Technologies\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name of Lucent or any of its entities\nnot be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#ifdef NO_FUNCADD\n#include \"funcadd.h\"\n\nchar *ix_details_ASL[] = {0};\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{ ae = ae; /* shut up non-use warning */ }\n\n#else\n\n#ifdef _WIN32\n#undef WIN32\n#define WIN32\n#endif\n\n#ifdef WIN32\n#include \"windows.h\"\n#undef Char\n#endif\n\n#define _POSIX_SOURCE\t/* for HP-UX */\n\n#include \"funcadd.h\"\n#include \"string.h\"\n\n#ifdef Old_APPLE\t/* formerly __APPLE__, for earlier versions of Mac OS X */\n#define FUNCADD \"_funcadd_ASL\"\n#endif\n#ifndef FUNCADD\n#define FUNCADD \"funcadd_ASL\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\nextern int libload_ASL(AmplExports *ae, char *s, int ns, int warn);\n#endif\n\ntypedef void Funcadd ANSI((AmplExports*));\n\nextern Char *mymalloc_ASL ANSI((size_t));\n#undef mymalloc\n#define mymalloc(x) mymalloc_ASL((size_t)(x))\n#ifndef KR_headers\nextern void free(void*);\n#endif\n\nchar *ix_details_ASL[] = {\n\t\"? {show -i options}\",\n\t\"- {do not import functions: do not access amplfunc.dll}\",\n\t\"dir {look for amplfunc.dll in directory dir}\",\n\t\"file {import functions from file rather than amplfunc.dll}\",\n\t\"\",\n\t\"If no -i option appears but $ampl_funclibs is set, assume\",\n\t\"-i $ampl_funclibs.  Otherwise, if $AMPLFUNC is set, assume\",\n\t\"-i $AMPLFUNC.  Otherwise look for amplfunc.dll in the\",\n\t\"directory that is current when execution begins.\",\n\t\"\",\n\t\"-ix and -i x are treated alike.\",\n\t0 };\n#define afdll afdll_ASL\nextern int aflibname_ASL ANSI((AmplExports*, char*, char*, int, Funcadd*, int, void(*)(void*), void*));\nextern char *i_option_ASL;\n\n#ifdef __cplusplus\n\t}\n#endif\n\nstatic int first = 1;\n\n#ifdef WIN32\n\n#define SLASH '\\\\'\nchar afdll[] = \"\\\\amplfunc.dll\";\ntypedef HINSTANCE shl_t;\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (Funcadd*)GetProcAddress(b,c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#define reg_file(x) 1\n\n static int\nAbspath(char *s)\n{\n\tint c = *s;\n\tif ((c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')\n\t && s[1] == ':'\n\t && (c = s[2]) == '\\\\' || c == '/')\n\t\treturn 1;\n\treturn 0;\n\t}\n\n#else /* !WIN32 */\n\n#define SLASH '/'\n\nchar afdll[] = \"/amplfunc.dll\";\n\n#define Abspath(s) (*(s) == '/')\n\n#ifdef KR_headers\nextern char *getcwd();\n#else\n#include \"unistd.h\"\t/* for getcwd */\n#endif\n#define GetCurrentDirectory(a,b) getcwd(b,(int)(a))\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n static int\n#ifdef KR_headers\nreg_file(name) char *name;\n#else\nreg_file(char *name)\n#endif\n{\n\tstruct stat sb;\n\treturn stat(name,&sb) ? 0 : S_ISREG(sb.st_mode);\n\t}\n\n#ifdef __hpux\n#include \"dl.h\"\n#define dlopen(x,y) shl_load(x, BIND_IMMEDIATE, 0)\n#define find_dlsym(a,b,c) !shl_findsym(&b, c, TYPE_PROCEDURE, &a)\n#define dlclose(x) shl_unload((shl_t)x)\n#define NO_DLERROR\n#else\n#ifdef Old_APPLE\n#include <mach-o/dyld.h>\ntypedef struct {\n\tNSObjectFileImage ofi;\n\tNSModule m;\n\tchar *name;\n\t} NS_pair;\ntypedef NS_pair *shl_t;\n\n static void*\nfind_sym_addr(NS_pair *p, const char *name)\n{\n\tNSSymbol nss;\n\n\tif (nss = NSLookupSymbolInModule(p->m, name))\n\t\treturn NSAddressOfSymbol(nss);\n\treturn 0;\n\t}\n\n#define find_dlsym(a,b,c) (a = find_sym_addr(b,c))\n\n static void\ndlclose(NS_pair *p)\n{\n\tif (NSUnLinkModule(p->m, NSUNLINKMODULE_OPTION_NONE))\n\t\tNSDestroyObjectFileImage(p->ofi);\n\tfree(p);\n\t}\n#define NO_DLERROR\n#else\n#include \"dlfcn.h\"\ntypedef void *shl_t;\n#define find_dlsym(a,b,c) (a = (Funcadd*)dlsym(b,c))\n#ifdef sun\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#endif /* sun */\n#endif /* Old_APPLE */\n#endif /* __hpux */\n#endif /* WIN32 */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n static shl_t\n#ifdef KR_headers\ndl_open(ae, name, warned) AmplExports *ae; char *name; int *warned;\n#else\ndl_open(AmplExports *ae, char *name, int *warned)\n#endif\n{\n/* This is a bit aggressive, but a first cut */\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tshl_t h;\n\tFILE *f;\n#ifndef KR_headers\n\tconst\n#endif\n\t      char *s;\n\n#ifdef Old_APPLE\n\tNS_pair p;\n\tNSObjectFileImageReturnCode irc;\n\tirc = NSCreateObjectFileImageFromFile(name,&p.ofi);\n\th = 0;\n\tif (irc == NSObjectFileImageSuccess) {\n\t\tp.m = NSLinkModule(p.ofi, name,\n\t\t\t  NSLINKMODULE_OPTION_BINDNOW\n\t\t\t| NSLINKMODULE_OPTION_PRIVATE\n\t\t\t| NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n\t\tif (!p.m)\n\t\t\tfprintf(stderr, \"NSLinkModule(\\\"%s\\\") failed.\\n\", name);\n\t\telse {\n\t\t\th = (NS_pair*)mymalloc(sizeof(NS_pair) + strlen(name) + 1);\n\t\t\tstrcpy(p.name = (char*)(h+1), name);\n\t\t\tmemcpy(h, &p, sizeof(NS_pair));\n\t\t\t}\n\t\t}\n\telse if (irc != NSObjectFileImageAccess)\n\t\tfprintf(stderr,\n\t\t\t\"return %d from NSCreateObjectFileImageFromFile(\\\"%s\\\")\\n\",\n\t\t\tirc, name);\n#else\n\th = dlopen(name, RTLD_NOW);\n#endif\n\tif (!h && warned && (f = fopen(name,\"rb\"))) {\n\t\tfclose(f);\n\t\tif (reg_file(name)) {\n\t\t\t*warned = 1;\n#ifdef NO_DLERROR\n\t\t\tfprintf(Stderr, \"Cannot load library %s.\\n\", name);\n#else\n\t\t\tfprintf(Stderr, \"Cannot load library %s\", name);\n\t\t\ts = dlerror();\n\t\t\tfprintf(Stderr, s ? \":\\n%s\\n\" : \".\\n\", s);\n#endif\n\t\t\t}\n\t\t}\n\treturn h;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 0;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\ndl_close(h) void *h;\n#else\ndl_close(void *h)\n#endif\n{\n#ifdef CLOSE_AT_RESET\n\tfirst = 1;\n#endif\n\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tif (h)\n\t\tdlclose(h);\n#endif\n\t}\n\n int\n#ifdef KR_headers\nlibload_ASL(ae, s, ns, warn) AmplExports *ae; char *s; int ns; int warn;\n#else\nlibload_ASL(AmplExports *ae, char *s, int ns, int warn)\n#endif\n{\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tFuncadd *fa;\n\tchar buf0[2048], *buf;\n\tint rc, warned;\n\tshl_t h;\n\tunsigned int n, nx;\n\n\tnx = 0;\n\tbuf = buf0;\n\tif (!Abspath(s)) {\n\t\tif (!GetCurrentDirectory(sizeof(buf0),buf0))\n\t\t\treturn 2;\n\t\tnx = strlen(buf0);\n\t\t}\n\tn = ns + sizeof(afdll) + nx;\n\tif (n > sizeof(buf0)) {\n\t\tbuf = (char*)mymalloc(n);\n\t\tif (nx)\n\t\t\tmemcpy(buf, buf0, nx);\n\t\t}\n\tif (nx)\n\t\tbuf[nx++] = SLASH;\n\tstrncpy(buf+nx, s, ns);\n\tbuf[nx+ns] = 0;\n\twarned = 0;\n\tif (h = dl_open(ae, buf, &warned)) {\n found:\n\t\tif (find_dlsym(fa, h, FUNCADD)\n\t\t || find_dlsym(fa, h, \"funcadd\")) {\n\t\t\trc = 0;\n#ifdef CLOSE_AT_RESET\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,0,dl_close,h);\n\t\t\t\t/* -DCLOSE_AT_RESET is for use in shared */\n\t\t\t\t/* libraries, such as MATLAB mex functions, */\n\t\t\t\t/* that may be loaded and unloaded several */\n\t\t\t\t/* times during execution of the program. */\n#else\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,1,dl_close,h);\n#endif\n\t\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Could not find funcadd in %s\\n\", buf);\n\t\t\tdl_close(h);\n\t\t\trc = 3;\n\t\t\t}\n\t\t}\n\telse if (warn) {\n\t\tif (!warned) {\n\t\t\tstrcpy(buf+nx+ns, afdll);\n\t\t\tif (h = dl_open(ae, buf, &warned))\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tif (warned)\n\t\t\trc = 2;\n\t\telse\n\t\t\tgoto notfound;\n\t\t}\n\telse {\n notfound:\n\t\tif (warn)\n\t\t\tfprintf(Stderr, \"Cannot find library %.*s\\nor %.*s%s\\n\",\n\t\t\t\tns, s, ns, s, afdll);\n\t\trc = 1;\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 3;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\nlibloop(ae, s) AmplExports *ae; char *s;\n#else\nlibloop(AmplExports *ae, char *s)\n#endif\n{\n\tchar *s1;\n\tint ns;\n\n\tfor(;; s = s1) {\n\t\twhile(*s <= ' ')\n\t\t\tif (!*s++)\n\t\t\t\treturn;\n\t\tfor(s1 = s; *++s1 >= ' '; );\n\t\twhile(s1[-1] == ' ')\n\t\t\t--s1;\n\t\tns = s1 - s;\n\t\tlibload_ASL(ae, s, ns, 1);\n\t\t}\n\t}\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{\n\tchar *s;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tif (s = i_option_ASL) {\n\t\t\tif (!*s || *s == '-' && !s[1])\n\t\t\t\treturn;\n\t\t\tlibloop(ae, s);\n\t\t\t}\n\t\telse\n\t\t\tlibload_ASL(ae, afdll+1, (int)sizeof(afdll)-2, 0);\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NO_FUNCADD */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/ampl/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/ampl/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8.4)\nproject(amplsolver)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING\n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\nset(AMPL_INCLUDE_DIRS ${amplsolver_SOURCE_DIR}\n                      ${amplsolver_BINARY_DIR} PARENT_SCOPE)\n                      \ninclude_directories(${amplsolver_SOURCE_DIR}\n                    ${amplsolver_BINARY_DIR})\n\nset(genarith_srcs arithchk.c)\nif(WIN32)\n  set_source_files_properties(arithchk.c PROPERTIES COMPILE_FLAGS \"-DNO_FPINIT\")\nelse()\n  list(APPEND genarith_srcs fpinit.c)\nendif()\nadd_executable(genarith ${genarith_srcs})\nif(UNIX)\n  target_link_libraries(genarith m)\nendif()\n\n\nconfigure_file(${amplsolver_SOURCE_DIR}/stdio1.h0 \n  ${amplsolver_BINARY_DIR}/stdio1.h)\n\nif(UNIX)\n  find_program(UNAME uname)\n  if(UNAME)\n    execute_process(COMMAND ${UNAME} -sr OUTPUT_VARIABLE System_details)\n  endif()\nelse()\n  set(System_details \"${CMAKE_SYSTEM_NAME}\")\nendif()\nstring(REPLACE \"\\n\" \"\"  System_details \"${System_details}\")\nconfigure_file(${amplsolver_SOURCE_DIR}/details.c0.cmake.in\n  ${amplsolver_BINARY_DIR}/details.c)\n\n# If genarith command fails, a zero length arith.h will be generated,\n# so remove on failure to cause later build failure\nadd_custom_command(\n  OUTPUT ${amplsolver_BINARY_DIR}/arith.h\n  COMMAND genarith > ${amplsolver_BINARY_DIR}/arith.h || \n    ${CMAKE_COMMAND} -E remove ${amplsolver_BINARY_DIR}/arith.h\n) \n\nset(amplsolver_SRCS\n  ${amplsolver_BINARY_DIR}/arith.h\n  ${amplsolver_BINARY_DIR}/details.c\n  asldate.c\n  atof.c\n  auxinfo.c\n  avldelete.c\n  avltree.c\n  b_search.c\n  basename.c\n  bscanf.c\n  com2eval.c\n  comeval.c\n  con1ival.c\n  con2ival.c\n  con2val.c\n  conadj.c\n  conpval.c\n  conscale.c\n  conval.c\n  derprop.c\n  dtoa1.c\n  duthes.c\n  dynlink.c\n  f_read.c\n  fg_read.c\n  fg_write.c\n  fgh_read.c\n  fpecatch.c\n  fpinit.c\n  fullhes.c\n  func_add.c\n  funcadd1.c\n  g_fmt.c\n  genrowno.c\n  getenv.c\n  getstub.c\n  htcl.c\n  jac0dim.c\n  jac2dim.c\n  jacdim.c\n  jacinc.c\n  jacinc1.c\n  mach.c\n  mainexit.c\n  mip_pri.c\n  misc.c\n  mypow.c\n  names.c\n  nl_obj.c\n  nqpcheck.c\n  obj2val.c\n  obj_prec.c\n  objconst.c\n  objval.c\n  objval_.c\n  op_type.c\n  pfg_read.c\n  pfghread.c\n  printf.c\n  pshvprod.c\n  punknown.c\n  qp_read.c\n  qpcheck.c\n  qsortv.c\n  readsol.c\n  repwhere.c\n  rops.c\n  rops2.c\n  sigcatch.c\n  sos_add.c\n  sphes.c\n  sscanf.c\n  stderr.c\n  studchk0.c\n  suf_sos.c\n  value.c\n  writesol.c\n  wrtsol_.c\n  ws_desc.c\n  wsu_desc.c\n  x2check.c\n  xectim.c\n  xp1known.c\n  xp2known.c)\n\nadd_library(amplsolver ${amplsolver_SRCS})\n\noption(AMPL_HAVE_DLOPEN \"Toggle support for dlopen in AMPL\" OFF)\nif (AMPL_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    add_definitions(\"-DAMPL_HAVE_DLOPEN\")\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\nif(UNIX)\n  target_link_libraries(amplsolver ${DL_LIBRARY})\nendif()\n\n# Allow AMPL build to be shared among several source packages\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/AMPLConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/AMPLConfig.cmake\n)\n\ninstall(TARGETS amplsolver EXPORT ${ExportTarget} DESTINATION lib)\n#install(TARGETS genarith EXPORT ${ExportTarget} DESTINATION bin)\n\nfile(GLOB ampl_headers *.h *.hd)\ninstall(FILES ${ampl_headers} DESTINATION include/ampl)\ninstall(FILES ${amplsolver_BINARY_DIR}/arith.h ${amplsolver_BINARY_DIR}/stdio1.h\n  DESTINATION include/ampl)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/userman_cmake.tex": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\clearpage\n\\section{More About CMake}\n\\label{sec:cmake}\n\nDocumentation for CMake is part of the CMake installation\n(Section~\\ref{subinstall:CM}), and can be found on the CMake web site\n(\\href{http://cmake.org/}{http://cmake.org/}).\nFiles in the HOPSPACK source distribution named {\\sf CMakeLists.txt} or files\nthat end with the suffix {\\sf .cmake} were written for HOPSPACK.\nAny of these CMake files can be examined and potentially edited to alter\nCMake behavior.  The remainder of this section describes specific situations\nwhere you might want to alter behavior when building HOPSPACK.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Debugging the Build Process}\n\nSometimes it helps to see more makefile output during compilation.\nOn makefile systems detailed output is enabled by editing\n{\\sf ConfigureBuildType.cmake} and uncommenting the line\n\n\\hspace{0.2in}\n{\\tt SET (CMAKE\\_VERBOSE\\_MAKEFILE ON)}\n\n\\noindent\nThen you should call {\\tt cmake} in a clean ``out of source'' directory to\nrebuild the HOPSPACK makefiles.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Building a Debug Version of the Code}\n\nTo compile a HOPSPACK executable with debugging symbols, use the command line\noption {\\tt -DHOPSPACK\\_DEBUG:BOOL=true}.  For example, on a Linux machine\nstart in a clean ``out of source'' directory and call:\n\n\\hspace{0.2in}\n{\\tt > cmake ../hopspack-\\HOPSVER.x $\\;$ -DHOPSPACK\\_DEBUG:BOOL=true}\n\n\\noindent\nThen, of course, all files must be recompiled.\nOn Windows machines using the Visual Studio compiler, the debug option is\nusually true by default.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Specifying a Different Compiler}\n\nEarly in its configuration process, CMake chooses a C++ compiler to use.\nThe command line version usually prints messages about its choice; for example,\nhere is some of the output from the build of a serial HOPSPACK executable\non Linux:\n\\vspace{-11pt}\n\\begin{verbatim}\n      -- The CXX compiler identification is GNU\n      -- The C compiler identification is GNU\n      -- Check for working CXX compiler: /usr/bin/c++\n      -- Check for working CXX compiler: /usr/bin/c++ -- works\n      ...\n\\end{verbatim}\n\nYou can force CMake to use a different compiler by altering the environment\nvariables {\\tt CXX} and {\\tt CC}.  In addition, you can add compiler flags\nby setting {\\tt CXXFLAGS} and tell the linker to include certain libraries\nby setting {\\tt CMAKE\\_EXE\\_LINKER\\_FLAGS}.\nAs an example, suppose the Intel C++ compiler (version 8.1) is installed\non a Linux machine.  Assume the {\\sf bin} directory containing the\ncompiler {\\tt icc} is in {\\tt PATH}, and that the libraries directory is\nplaced in {\\tt LD\\_LIBRARY\\_PATH}.\nThen you instruct CMake to build a makefile system as follows:\n\\vspace{-11pt}\n\\begin{tabbing}\n  xxx \\= xxxxxxxxx \\= \\kill\n  \\> {\\tt > mkdir build\\_serial} \\\\\n  \\> {\\tt > cd build\\_serial} \\\\\n  \\> {\\tt > export CXX=icc} \\\\\n  \\> {\\tt > export CC=icc} \\\\\n  \\> {\\tt > export CXXFLAGS=-cxxlib-icc} \\\\\n  \\> {\\tt > cmake ../hopspack-\\HOPSVER.x  $\\; \\backslash$} \\\\\n  \\> \\> {\\tt -DCMAKE\\_EXE\\_LINKER\\_FLAGS=\"-lcprts -lcxa -lunwind\"} \\\\\n  \\> {\\tt -- The CXX compiler identification is Intel} \\\\\n  \\> {\\tt -- The C compiler identification is Intel} \\\\\n  \\> {\\tt ...}\n\\end{tabbing}\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Fortran Compiler Warnings}\n\nCMake configuration files are capable of linking with LAPACK Fortran\nlibraries (see \\SECREF{subinstall:LA}).  For this reason, the initial\nCMake configuration step may look for a Fortran compiler and warn\nif one cannot be found:\n\\vspace{-11pt}\n\\begin{tabbing}\n  xxx \\= xxxxxxxxx \\= \\kill\n  \\> {\\tt ...} \\\\\n  \\> {\\tt -- Looking for a Fortran compiler} \\\\\n  \\> {\\tt -- Looking for a Fortran compiler - NOTFOUND} \\\\\n  \\> {\\tt ...}\n\\end{tabbing}\n\n\\noindent\nThis warning can be ignored unless LAPACK is based on Fortran libraries,\nin which case the build will probably fail.  If LAPACK is Fortran-based,\nthen the Fortran compiler may be invoked to generate adaptive function\ndeclarations in {\\sf src/src-shared/HOPSPACK\\_LapackWrappers.cpp}.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Adding Libraries to an Executable}\n\\label{subsec:cmakeaddlib}\n\nIf source code modifications introduce dependencies on external libraries,\nthen CMake must be given the library names so they can be linked with the\nexecutables.\n\nA simple way is to add the library name explicitly in the CMake\nconfiguration file that generates an executable.  For example, suppose the\nserial version of HOPSPACK on a Linux machine needs to link with the {\\sf dl}\nsystem library (perhaps the function {\\tt dlopen()} was called in a custom\nevaluator such as the one described in \\SECREF{subcalleval:inlineeval}).\nA simple fix is to edit {\\sf src/src-main/CMakeLists.txt} and add\n{\\tt -ldl} in the list of {\\tt TARGET\\_LINK\\_LIBRARIES} at the bottom of\nthe file.  Assuming the library is in the system's load path, CMake will\nfind it the next time the executable is built.\n\nThe simple fix described above is hard-coded for Linux.  If the library\nexists on all platforms, then CMake has a better way.\nFor example, suppose you want to link a personal library of utility functions\nnamed ``myutils''.  On Linux this would typically be named {\\sf libmyutils.a}\nor {\\sf libmyutils.so}, while Windows would typically name it {\\sf myutils.dll}.\nCMake provides a utility that finds the platform-specific name:\n\n\\hspace{0.2in}\n{\\tt FIND LIBRARY (MY\\_UTILS\\_VAR NAMES myutils DOC \"find myutils\")}\n\n\\noindent\nThis stores the platform-specific name in the CMake variable named\n{\\tt MY\\_UTILS\\_VAR}.  Add the variable to the list of\n{\\tt TARGET\\_LINK\\_LIBRARIES} instead of a hard-coded name.\n\nFor more examples, look at {\\sf ConfigureLapack.cmake} and\n{\\sf ConfigureSysLibs.cmake} in the top directory of the HOPSPACK distribution.\n\n\n\n%TBD...Rollin Thomas needs a little explanation of CMake where to put -I and -L\n\n\n\n%TBD...name and describe ConfigureLapack.cmake, the g2c location\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/configure.ac": "# See notes in Makefile.am\n\n# TODO\n# * Probe for necessary headers/libs?\n# * Manage optional libraries for dlopen\n#   and also use a more generic name than dl_solver\n\nAC_PREREQ([2.60])\nAC_INIT([NIDR],[1.201006],[dakota-developers@development.sandia.gov])\n\nAM_INIT_AUTOMAKE([1.9 foreign])\nAM_MAINTAINER_MODE\n\nAC_LANG([C])\n\ndnl DL_SOLVER package check (toggles NIDR DL features and DL_SOLVER).\nAC_ARG_WITH([dl_solver],\n            AS_HELP_STRING([--with-dl_solver], [turn DL_SOLVER support on]),\n\t    [with_dl_solver=$withval], [with_dl_solver=no])\ndnl if no dl_solver, -DNO_NIDR_DYNLIB set in src/Makefile.am\nAM_CONDITIONAL([WITH_DL_SOLVER], [test \"x$with_dl_solver\" = xyes ])\n\n\ndnl Specification maintenance mode; must be enabled to update NIDR\ndnl itself or the specification of programs depending on it\nAC_ARG_ENABLE([spec-maint],\n              AS_HELP_STRING([--enable-spec-maint], \n                             [enable specification maintenance]),\n              [enable_spec_maint=$enableval], [enable_spec_maint=no])\nAM_CONDITIONAL([ENABLE_SPEC_MAINT], [test \"x$enable_spec_maint\" = xyes ])\n\nAC_PROG_CC\nAC_PROG_RANLIB\n\ndnl Probe for programs needed to regenerate spec or NIDR itself\n#if test \"x$enable_spec_maint\" = xyes; then\n#  AC_PROG_LEX\n#  AC_PROG_YACC\n#  AC_PROG_SED\n#fi\nLEX=lex\nAC_SUBST(LEX) \nYACC=\"bison -y\"\nAC_SUBST(YACC) \nSED=sed\nAC_SUBST(SED) \n\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/nidrgen.c": "/* A lexical scanner generated by flex*/\n\n/* Scanner skeleton version:\n * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $\n */\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION 2\n#define YY_FLEX_MINOR_VERSION 5\n\n#include <stdio.h>\n#include <unistd.h>\n\n\n/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */\n#ifdef c_plusplus\n#ifndef __cplusplus\n#define __cplusplus\n#endif\n#endif\n\n\n#ifdef __cplusplus\n\n#include <stdlib.h>\n\n/* Use prototypes in function declarations. */\n#define YY_USE_PROTOS\n\n/* The \"const\" storage-class-modifier is valid. */\n#define YY_USE_CONST\n\n#else\t/* ! __cplusplus */\n\n#if __STDC__\n\n#define YY_USE_PROTOS\n#define YY_USE_CONST\n\n#endif\t/* __STDC__ */\n#endif\t/* ! __cplusplus */\n\n#ifdef __TURBOC__\n #pragma warn -rch\n #pragma warn -use\n#include <io.h>\n#include <stdlib.h>\n#define YY_USE_CONST\n#define YY_USE_PROTOS\n#endif\n\n#ifdef YY_USE_CONST\n#define yyconst const\n#else\n#define yyconst\n#endif\n\n\n#ifdef YY_USE_PROTOS\n#define YY_PROTO(proto) proto\n#else\n#define YY_PROTO(proto) ()\n#endif\n\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n\n/* Promotes a possibly negative, possibly signed char to an unsigned\n * integer for use as an array index.  If the signed char is negative,\n * we want to instead treat it as an 8-bit unsigned char, hence the\n * double cast.\n */\n#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN yy_start = 1 + 2 *\n\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START ((yy_start - 1) / 2)\n#define YYSTATE YY_START\n\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin )\n\n#define YY_END_OF_BUFFER_CHAR 0\n\n/* Size of default input buffer. */\n#define YY_BUF_SIZE 16384\n\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n\nextern int yyleng;\nextern FILE *yyin, *yyout;\n\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n\n/* The funky do-while in the following #define is used to turn the definition\n * int a single C statement (which needs a semi-colon terminator).  This\n * avoids problems with code like:\n *\n * \tif ( condition_holds )\n *\t\tyyless( 5 );\n *\telse\n *\t\tdo_something_else();\n *\n * Prior to using the do-while the compiler would get upset at the\n * \"else\" because it interpreted the \"if\" statement as being all\n * done when it reached the ';' after the yyless() call.\n */\n\n/* Return all but the first 'n' matched characters back to the input stream. */\n\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\t*yy_cp = yy_hold_char; \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tyy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n\n#define unput(c) yyunput( c, yytext_ptr )\n\n/* Some routines like yy_flex_realloc() are emitted as static but are\n   not called by all lexers. This generates warnings in some compilers,\n   notably GCC. Arrange to suppress these. */\n#ifdef __GNUC__\n#define YY_MAY_BE_UNUSED __attribute__((unused))\n#else\n#define YY_MAY_BE_UNUSED\n#endif\n\n/* The following is because we cannot portably get our hands on size_t\n * (without autoconf's help, which isn't available because we want\n * flex-generated scanners to compile on their own).\n */\ntypedef unsigned int yy_size_t;\n\n\nstruct yy_buffer_state\n\t{\n\tFILE *yy_input_file;\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tyy_size_t yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * characters.\n\t */\n\tint yy_n_chars;\n\n\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n\t * and can realloc() it to grow it, and should free() it to\n\t * delete it.\n\t */\n\tint yy_is_our_buffer;\n\n\t/* Whether this is an \"interactive\" input source; if so, and\n\t * if we're using stdio for input, then we want to use getc()\n\t * instead of fread(), to make sure we stop fetching input after\n\t * each newline.\n\t */\n\tint yy_is_interactive;\n\n\t/* Whether we're considered to be at the beginning of a line.\n\t * If so, '^' rules will be active on the next match, otherwise\n\t * not.\n\t */\n\tint yy_at_bol;\n\n\t/* Whether to try to fill the input buffer when we reach the\n\t * end of it.\n\t */\n\tint yy_fill_buffer;\n\n\tint yy_buffer_status;\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n\t * shouldn't try reading from the input source any more.  We might\n\t * still have a bunch of tokens to match, though, because of\n\t * possible backing-up.\n\t *\n\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n\t};\n\nstatic YY_BUFFER_STATE yy_current_buffer = 0;\n\n/* We provide macros for accessing buffer states in case in the\n * future we want to put the buffer states in a more general\n * \"scanner state\".\n */\n#define YY_CURRENT_BUFFER yy_current_buffer\n\n\n/* yy_hold_char holds the character lost when yytext is formed. */\nstatic char yy_hold_char;\n\nstatic int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\n\n\nint yyleng;\n\n/* Points to current character in buffer. */\nstatic char *yy_c_buf_p = (char *) 0;\nstatic int yy_init = 1;\t\t/* whether we need to initialize */\nstatic int yy_start = 0;\t/* start state number */\n\n/* Flag which is used to allow yywrap()'s to do buffer switches\n * instead of setting up a fresh yyin.  A bit of a hack ...\n */\nstatic int yy_did_buffer_switch_on_eof;\n\nvoid yyrestart YY_PROTO(( FILE *input_file ));\n\nvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));\nvoid yy_load_buffer_state YY_PROTO(( void ));\nYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));\nvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));\nvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));\nvoid yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));\n#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )\n\nYY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));\nYY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));\nYY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));\n\nstatic void *yy_flex_alloc YY_PROTO(( yy_size_t ));\nstatic void *yy_flex_realloc YY_PROTO(( void *, yy_size_t )) YY_MAY_BE_UNUSED;\nstatic void yy_flex_free YY_PROTO(( void * ));\n\n#define yy_new_buffer yy_create_buffer\n\n#define yy_set_interactive(is_interactive) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_is_interactive = is_interactive; \\\n\t}\n\n#define yy_set_bol(at_bol) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_at_bol = at_bol; \\\n\t}\n\n#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)\n\ntypedef unsigned char YY_CHAR;\nFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\ntypedef int yy_state_type;\nextern char *yytext;\n#define yytext_ptr yytext\n\nstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));\nstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));\nstatic int yy_get_next_buffer YY_PROTO(( void ));\nstatic void yy_fatal_error YY_PROTO(( yyconst char msg[] ));\n\n/* Done after the current pattern has been matched and before the\n * corresponding action - sets up yytext.\n */\n#define YY_DO_BEFORE_ACTION \\\n\tyytext_ptr = yy_bp; \\\n\tyyleng = (int) (yy_cp - yy_bp); \\\n\tyy_hold_char = *yy_cp; \\\n\t*yy_cp = '\\0'; \\\n\tyy_c_buf_p = yy_cp;\n\n#define YY_NUM_RULES 43\n#define YY_END_OF_BUFFER 44\nstatic yyconst short int yy_accept[128] =\n    {   0,\n        0,    0,    0,    0,    0,    0,   44,   42,    2,    1,\n       42,   34,   35,   42,   42,   16,   27,   25,   42,   42,\n       42,   42,   42,   42,   42,   42,   42,   36,   37,   15,\n       31,   33,   32,   34,   35,   38,   39,   30,   42,   42,\n       29,   28,    2,    0,   40,   41,   23,   26,   24,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n       15,   38,    0,   29,   29,   29,    0,   28,    0,    0,\n        0,    0,    0,    0,   22,    0,    0,    0,   18,   29,\n        0,   29,    0,   17,    0,    0,    0,    0,   21,    0,\n       11,    0,    0,    0,   19,    0,    0,    0,    0,    0,\n\n        0,   20,    0,    0,    0,    0,   13,    3,    4,    6,\n       10,    0,    0,    3,    0,    0,    7,   12,    0,    0,\n        8,    9,    0,    0,   14,    5,    0\n    } ;\n\nstatic yyconst int yy_ec[256] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    2,    1,    4,    5,    1,    1,    1,    1,    6,\n        7,    8,    9,   10,    9,   11,   12,   13,   14,   15,\n       16,   16,   16,   16,   16,   16,   16,   17,   18,   19,\n       20,   21,    1,    1,   22,   23,   24,   25,   26,   27,\n       28,   27,   29,   27,   30,   31,   32,   33,   34,   35,\n       27,   36,   37,   38,   39,   27,   40,   27,   41,   27,\n       42,    1,   43,    1,   44,    1,   45,   45,   45,   45,\n\n       46,   45,   45,   45,   45,   45,   45,   45,   45,   45,\n       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,\n       45,   45,   47,   48,   49,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1\n    } ;\n\nstatic yyconst int yy_meta[50] =\n    {   0,\n        1,    2,    1,    1,    1,    2,    2,    2,    2,    2,\n        2,    2,    3,    3,    3,    3,    2,    1,    2,    1,\n        2,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    2,    2,    3,    3,    3,    1,    1,    1\n    } ;\n\nstatic yyconst short int yy_base[131] =\n    {   0,\n        0,    0,   49,    0,   98,    0,  315,  316,  312,  316,\n      310,  316,  316,  304,  291,  316,  290,  289,  277,  122,\n      271,  273,  279,  123,  278,  265,  280,  316,  316,  140,\n      316,  316,  316,    0,    0,    0,  316,  316,  146,  151,\n      157,    0,  299,  297,  316,  316,  316,  316,  316,  270,\n      261,  264,  262,  257,  253,  260,  269,  269,  254,  261,\n      161,    0,  165,  176,  182,  197,  205,    0,  266,  263,\n      255,  246,  258,  243,  260,  240,  241,  239,  316,  211,\n      216,  220,  230,  316,  237,  230,  236,  229,  316,  240,\n      230,  227,  257,  235,  316,  230,  219,  222,  224,  224,\n\n      148,  316,  215,  225,  223,  211,  211,  225,  186,  186,\n      316,  178,  186,  231,  180,  190,  186,  316,  151,  145,\n      316,  316,  131,  120,  316,  316,  316,  277,  279,  148\n    } ;\n\nstatic yyconst short int yy_def[131] =\n    {   0,\n      127,    1,  127,    3,  127,    5,  127,  127,  127,  127,\n      128,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  129,  129,  129,  127,  127,  127,  127,\n      127,  130,  127,  128,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  129,  127,  127,  127,  127,  127,  130,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,    0,  127,  127,  127\n    } ;\n\nstatic yyconst short int yy_nxt[366] =\n    {   0,\n        8,    9,   10,    8,   11,   12,   13,    8,    8,    8,\n        8,   14,    8,    8,    8,    8,   15,   16,   17,    8,\n       18,   19,    8,    8,   20,    8,    8,   21,   22,   23,\n       24,    8,    8,    8,    8,   25,   26,   27,    8,    8,\n        8,   28,   29,    8,   30,   30,   31,   32,   33,    8,\n        9,   10,    8,   11,   34,   35,    8,    8,    8,    8,\n       14,   36,   36,   36,   36,    8,   37,    8,    8,    8,\n       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,\n       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,\n       28,   29,   36,   36,   36,   31,   32,   33,    8,    9,\n\n       10,   38,   11,   12,   13,    8,   39,    8,   40,   14,\n       41,   41,   41,   41,    8,    8,    8,    8,    8,   42,\n       42,   42,   42,   42,   42,   42,   42,   42,   42,   42,\n       42,   42,   42,   42,   42,   42,   42,   42,   42,   28,\n       29,    8,   42,   42,   31,   32,   33,   51,   56,  101,\n       68,   57,   61,   61,   61,   61,   63,  126,   64,   64,\n       64,   64,   52,   65,   65,   65,   65,   66,  125,   64,\n       64,   64,   64,   61,   61,   61,   61,   65,   65,   65,\n       65,  124,   67,   61,   61,   61,   66,  123,   64,   64,\n       64,   64,  108,  108,   65,   65,   65,   65,  116,  117,\n\n      122,   67,   67,  121,   61,   61,   61,   67,  120,   80,\n       80,   80,   80,   81,  119,  118,  115,   82,   82,   82,\n       82,   67,   67,   80,   80,   80,   80,   67,   82,   82,\n       82,   82,   82,   82,   82,   82,   67,  114,  114,  114,\n      114,  113,   67,  114,  114,  114,  114,  112,  111,  110,\n      109,  107,  106,  105,  104,  103,   67,  102,  101,  100,\n       99,   98,   97,   96,   95,   94,   93,   92,  114,  114,\n      114,   91,   90,   89,  114,  114,  114,   44,   44,   44,\n       62,   62,   88,   87,   86,   85,   84,   83,   79,   78,\n       77,   76,   75,   74,   73,   72,   71,   70,   69,   45,\n\n       43,   60,   59,   58,   55,   54,   53,   50,   49,   48,\n       47,   46,   45,   43,  127,    7,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127\n    } ;\n\nstatic yyconst short int yy_chk[366] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    5,    5,\n\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,   20,   24,  101,\n      130,   24,   30,   30,   30,   30,   39,  124,   39,   39,\n       39,   39,   20,   40,   40,   40,   40,   41,  123,   41,\n       41,   41,   41,   61,   61,   61,   61,   63,   63,   63,\n       63,  120,   41,   30,   30,   30,   64,  119,   64,   64,\n       64,   64,  101,  101,   65,   65,   65,   65,  110,  110,\n\n      117,   64,   41,  116,   61,   61,   61,   65,  115,   66,\n       66,   66,   66,   67,  113,  112,  109,   67,   67,   67,\n       67,   64,   66,   80,   80,   80,   80,   65,   81,   81,\n       81,   81,   82,   82,   82,   82,   80,  108,  108,  108,\n      108,  107,   66,  114,  114,  114,  114,  106,  105,  104,\n      103,  100,   99,   98,   97,   96,   80,   94,   93,   92,\n       91,   90,   88,   87,   86,   85,   83,   78,  108,  108,\n      108,   77,   76,   75,  114,  114,  114,  128,  128,  128,\n      129,  129,   74,   73,   72,   71,   70,   69,   60,   59,\n       58,   57,   56,   55,   54,   53,   52,   51,   50,   44,\n\n       43,   27,   26,   25,   23,   22,   21,   19,   18,   17,\n       15,   14,   11,    9,    7,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127\n    } ;\n\nstatic yy_state_type yy_last_accepting_state;\nstatic char *yy_last_accepting_cpos;\n\n/* The intent behind this definition is that it'll catch\n * any uses of REJECT which flex missed.\n */\n#define REJECT reject_used_but_not_detected\n#define yymore() yymore_used_but_not_detected\n#define YY_MORE_ADJ 0\n#define YY_RESTORE_YY_MORE_OFFSET\nchar *yytext;\n/* #line 1 \"nidrgen.l\" */\n#define INITIAL 0\n/* #line 2 \"nidrgen.l\" */\n/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"nidr.h\"\t/* for KeyWordKind */\n\n#ifndef NO_NIDR_DYNLIB\ntypedef KeyWord *(*KW_ADD)(void);\n#ifdef _WIN32\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#endif\n\n#ifndef DMBLK_GULP\n#define DMBLK_GULP 1024\n#endif\n#ifndef DMLBK_SGULP\n#define DMBLK_SGULP 16000\n#endif\n#ifndef MBLK_GULP\n#define MBLK_GULP 8191\n#endif\n#ifndef KWSTACKLEN\n#define KWSTACKLEN 100\t/*should be overkill*/\n#endif\n#ifndef DEFTAGLEN\n#define DEFTAGLEN 2048\t/* should be overkill*/\n#endif\n\n typedef union\nYYSTYPE { char *s; } YYSTYPE;\n\n enum LastSeen {\n\tSaw_kwname\t= 1,\n\tSaw_type\t= 2,\n\tSaw_func\t= 3,\n\tSaw_dflt\t= 4,\n\tSaw_dfltname\t= 5,\n\tSaw_lt\t\t= 6,\n\tSaw_le\t\t= 7,\n\tSaw_ge\t\t= 8,\n\tSaw_gt\t\t= 9,\n\tSaw_desc\t= 10,\n\tSaw_group\t= 11,\n\tSaw_tag\t\t= 12,\n\tSaw_len\t\t= 13,\n\tSaw_dy\t\t= 14\n\t};\n\n static const char *tokname[] = {\n\t\"<bug>\",\n\t\"kwname\",\n\t\"type\",\n\t\"{funcspec}\",\n\t\":=\",\n\t\"#define name for :=\",\n\t\"<\",\n\t\"<=\",\n\t\">=\",\n\t\">\",\n\t\"DESC\",\n\t\"GROUP\",\n\t\"TAG\",\n\t\"LEN\"\n\t};\n\n enum ParState {\n\t/* parstate values... */\n\tPPar_emtpy\t= 0,\n\tPPar_starting\t= 1,\n\tPPar_started\t= 2,\n\tPPar_leftpar\t= 3,\n\tDupchecking\t= 4,\n\tDupchecked\t= 5,\n\tPrinting\t= 6,\n\tKwStacked\t= 7,\n\tSorted\t\t= 8,\n\tLeftput\t\t= 9,\n\tParchecked\t= 10\n\t};\n\n /* values for lastseen also include single characters ( [ { } ] ) ; */\n\n /* enums to make constants visible to debuggers */\n enum {\n\tDMblk_gulp\t= DMBLK_GULP,\n\tDmblk_sgulp\t= DMBLK_SGULP,\n\tMblk_gulp\t= MBLK_GULP,\n\tKW_stacklen\t= KWSTACKLEN,\n\tBr_stacklen\t= 2*KW_stacklen,\n\tDHTlen\t\t= 997,\n\tDHTfactor\t= 43,\n\tHTlen\t\t= 127,\n\tKWPlen\t\t= 32,\n\tKWOUTlen0\t= 128 };\n\n typedef struct Defhash Defhash;\n typedef struct DefhashHead DefhashHead;\n typedef struct DefhashTab DefhashTab;\n typedef struct HashHead HashHead;\n typedef struct KWctx KWctx;\n typedef struct Mblk Mblk;\n typedef struct Taghash Taghash;\n typedef struct StrList StrList;\n\n struct\nDefhashHead {\n\tDefhashHead *hnext, *thread;\n\tchar *name;\n\t};\n\n struct\nDefhash {\n\tDefhashHead hh;\n\tchar *value;\n\tint qkeep;\n\t};\n\n struct\nTaghash {\n\tDefhashHead hh;\n\tKWctx *kw;\n\tint uses;\n\t};\n\n struct\nDefhashTab {\n\tDefhashHead *Tab[DHTlen];\n\tDefhashHead *lastdh;\n\tsize_t nalloc;\t/* size of new entry allocations in units of sizeof(void*) */\n\tint nent;\n\t};\n\n struct\nMblk {\n\tMblk *next;\n\tvoid *stuff[Mblk_gulp];\n\t};\n\n struct\nHashHead { HashHead *hnext, *hprev; };\n\n struct\nStrList {\n\tHashHead h;\n\tStrList *next;\n\tchar *val;\n\tint Lineno;\n\tint primary;\n\tint seqno;\n\tint needrev;\n\t};\n\n struct\nKWctx {\n\tKWctx *next;\n\tStrList *names;\t/* list of name and aliases */\n\tchar *name1;\t/* first name (for tagout) */\n\tKWctx *kw;\t/* list of contained keywords */\n\tKWctx *master;\t/* non-null ==> this is an alias; use master's kwkno */\n\tKWctx *pmaster;\t/* used in computing paoff */\n\tKWctx *pparent;\t/* paren parent, for ((...)|(...) ...) */\n\tKWctx *rparent;\t/* \"real\" parent, for stuff inside ((...)) */\n\tStrList *funcs;\t/* pre- and post order functions and (void*) args */\n\tchar *Br_top;\t/* Br_top when this keyword began */\n\tchar *lb;\t/* lower bound (if kind & KWKind_Lb is nonzero) */\n\tchar *ub;\t/* upper bound (if kind & KWKind_Ub is nonzero) */\n\tchar *init;\t/* initial value (if kind & KWKind_init is nonzero) and */\n\t\t\t/* kind & KWKind_Mask is 1 or 2 (KWKind_Int or KWKind_Real) */\n\tchar *cinit;\t/* initial value for STRING-valued keyword,\t*/\n\t\t\t/* ==> (kind & (KWKind_Mask | KWKind_init))\t*/\n\t\t\t/*\t== (KWKind_Str | KWKind_init)\t\t*/\n\tchar *defname;\t/* name of preprocessor token to be #defined */\n\tchar *desc;\n\tchar *dylib;\n\tchar *group;\n\tchar *tag;\n\tchar *len;\t/* keyword giving array length */\n\tsize_t dtnext;\t/* for adjusting deftag when this keyword goes out of scope */\n\tsize_t name1len;\n\tint alt;\t/* alternative group number of this keyword */\n\tint kind;\t/* kind of values for this keyword */\n\tint kno;\t/* number of this keyword, for generating kw_n names */\n\tint kwkno;\t/* number of this keyword's kw array (if any) */\n\tint kwknop;\t/* if this is a pparent and has a pparent, kwkno for this and parents */\n\tint nalt;\t/* number of alternative groups in contained keywords */\n\tint nfcn;\t/* number of function and arg entries in funcs */\n\tint nkw;\t/* number of contained keywords */\n\tint nreq;\t/* number of required elements in contained keywords */\n\tint req;\t/* required group for this keyword (0 if optional) */\n\tenum ParState parstate;\t/* state in handling ((...)) */\n\tint altoffset;\t/* for expand */\n\tint reqoffset;\t/* for expand */\n\tint level;\n\tint objno;\t/* for kwcomp2 */\n\tint agroup;\t/* for GuiKeyWord */\n\tint paoff;\t/* offset of primary keyword */\n\t};\n\n static int lastagroup, lastobjno, nalias, seqno;\n\n Defhash *lastdef;\n DefhashTab DHTab, TagTab;\n FILE *mtagout, *tagin, *tagout;\n HashHead HTab[HTlen];\n KWctx KWbase, *lastkw, *lastkw1;\n KWctx *KWStack[KW_stacklen], **KWtop = KWStack;\n Mblk FirstMblk, *CurMblk = &FirstMblk;\n YYSTYPE yyval;\n char Br_stack[Br_stacklen], *Br_top = Br_stack;\n char deftag[DEFTAGLEN], *dtend = deftag + DEFTAGLEN - 2, *dtnext = deftag;\n char *infname, *lasttag, *progname, *specfile, *tagfname;\n int Lineno = 1, dfltgroup = 1, startwarn = 1, wantfuncs = 1;\n int brace, btype, dupnames, dynlibseen, dynline, expand, guikeywds, ignoretags;\n int kwmult, lastkno, lastseen, liberror, libexpand, missing, needcomma, nsquawk;\n int or_mode, saweof;\n size_t mbavail = Mblk_gulp;\n void **mbnext = FirstMblk.stuff;\n static void Eat_comment(void);\n static void Keywd(const char *);\n static void Saw_num(const char*);\n static void Saw_quote(void);\n static void Saw_tok(int, int);\n\n /* Possible values for *Br_top:\n //\t 0  ==> empty (for Br_stack[0] only)\n //\t'(' ==> open paren seen, awaiting ')'\n //\t'[' ==> open square bracket, awaiting ']'\n */\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s:\\n\\tbotch on line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s: line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\t++nsquawk;\n\t}\n\n static void*\nMalloc(size_t L, const char *where)\n{\n\tvoid *rv = malloc(L);\n\tif (!rv)\n\t\tbotch(\"malloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n static void*\nRealloc(void *rv, size_t L, const char *where)\n{\n\trv = realloc(rv, L);\n\tif (!rv)\n\t\tbotch(\"ralloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n void\nunexpected(const char *what)\n{ botch(\"unexpected \\\"%s\\\"\", what); }\n\n static void *\nAlloc(size_t len)\n{\n\tMblk *mb;\n\tsize_t L;\n\tvoid *rv;\n\n\tL = (len + sizeof(void*) - 1)/sizeof(void*);\n\tif (L >= Mblk_gulp)\n\t\tbotch(\"Alloc(%lu) failure\", (unsigned long)len);\n\tif (L > mbavail) {\n\t\tif (!(mb = CurMblk->next)) {\n\t\t\tmb = (Mblk*)Malloc(sizeof(Mblk), \"Alloc\");\n\t\t\tCurMblk->next = mb;\n\t\t\t}\n\t\tCurMblk = mb;\n\t\tmbavail = Mblk_gulp;\n\t\tmbnext = mb->stuff;\n\t\tmb->next = 0;\n\t\tmemset(mbnext, 0, sizeof(mb->stuff));\n\t\t}\n\trv = mbnext;\n\tmbnext += L;\n\tmbavail -= L;\n\treturn rv;\n\t}\n\n StrList *\nnew_StrList(const char *s, StrList *nxt)\n{\n\tsize_t L = strlen(s) + 1;\n\tStrList *rv = (StrList*)Alloc(sizeof(StrList) + L);\n\tstrcpy(rv->val = (char*)(rv + 1), s);\n\tif ((rv->next = nxt))\n\t\trv->needrev = 1;\n\trv->Lineno = Lineno;\n\treturn rv;\n\t}\n\n static void\nAlias(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\n\tif (lastseen != Saw_kwname)\n\t\tbotch(\"ALIAS out of place\");\n\tkw = lastkw;\n\tfor(s += 6; *s <= ' '; s++);\n\tsl = kw->names = new_StrList(s, kw->names);\n\t++nalias;\n\tsl->seqno = ++seqno;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nreqchk(const char *a, const char *s)\n{\n\tif (a)\n\t\twhile(*a)\n\t\t\tif (*a++ == lastseen)\n\t\t\t\treturn;\n\tbotch(\"\\\"%s\\\" out of place\", s);\n\t}\n\n static void\nreqchk1(const char *a, const char *s)\n{\n\tint c;\n\n\tif (*Br_top != *s) {\n\t\tif ((c = *Br_top)) {\n\t\t\tswitch(c) {\n\t\t\t case '[': c = ']'; break;\n\t\t\t case '(': c = ')'; break;\n\t\t\t default:  c = '?';\n\t\t\t }\n\t\t\tbotch(\"Missing '%c'\", c);\n\t\t\t}\n\t\telse\n\t\t\ta = 0;\n\t\t}\n\treqchk(a, s+1);\n\t}\n\n static void\nBar(void)\n{\n\tstatic char allowed[] = { /*(*/ ')', Saw_kwname, Saw_type, 0 };\n\treqchk(KWtop - KWStack > 1 || KWtop[0]->kw ? allowed : \"\", \"|\");\n\tlastseen = '|';\n\tlastkw = lastkw1 = 0;\n\tor_mode = 1;\n\t}\n\n static void\nLpar(void)\n{\n\tKWctx *kw;\n\tint olastseen = lastseen;\n\tstatic char allowed[] = { '(', '[', '|', ']', ')', Saw_kwname, Saw_type, 0 };\n\n\treqchk(allowed, \"(\"/*)*/);\n\tlastseen = '('; /*)*/\n\tif (KWtop > KWStack) {\n\t\tkw = KWtop[0];\n\t\tif (or_mode && kw->parstate == PPar_leftpar && !kw->kw) {\n\t\t\tdtnext = deftag + kw->dtnext;\n\t\t\t--KWtop;\n\t\t\tKeywd(0);\n\t\t\tkw->pparent = KWtop[0];\n\t\t\t}\n\t\telse if (olastseen == '(' || olastseen == '[' /*])*/)\n\t\t\tKeywd(0);\n\t\tlastseen = '(' /*)*/;\n\t\t}\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\t*Br_top = '('; /*)*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLsqb(void)\n{\n\tstatic char allowed[] = { /*([*/ ']', ')', Saw_kwname, Saw_type, 0 };\n\treqchk(allowed, \"[\"/*]*/);\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\tlastseen = *Br_top = '['; /*]*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRpar(void)\n{\n\tstatic char allowed[] =  {/*[(*/ ')', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"()\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\tif (!KWtop[0]->kw && KWtop - KWStack > 2\n\t && KWtop[-1]->parstate == PPar_starting)\n\t\tKWtop[-1]->Br_top = Br_top;\n\t--KWtop;\n\tlastseen = /*(*/ ')';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRsqb(void)\n{\n\tstatic char allowed[] = {/*(*/')', '[', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"[]\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\t--KWtop;\n\tlastseen = /*[*/ ']';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLbrace(void)\n{\n\tif (brace++ || (lastseen != Saw_kwname && lastseen != Saw_type))\n\t\tunexpected(\"{\");\n\tlastseen = '{'; /*}}*/\n\t}\n\n static void\nRbrace(void)\n{\n\tif (--brace || (lastseen != Saw_func && lastseen != ';'))\n\t\t/*{{*/unexpected(\"}\");\n\tlastseen = Saw_type;\n\t}\n\n static void\nType(int n, const char *s)\n{\n\tif (lastseen != Saw_kwname || !lastkw)\n\t\tbotch(\"type %s out of place\", s);\n\tlastkw->kind |= n;\n\tlastkw = 0;\n\tlastseen = Saw_type;\n\t}\n\n static char *\ndef_name(const char *s0)\n{\n\tchar *s;\n\tconst char *s1;\n\tsize_t L, L1;\n\tstatic char *slast, *snext;\n\n\ts1 = s0;\n\twhile(*s1++);\n\tL = s1 - s0;\n\tif (snext + L > slast) {\n\t\tsnext = (char*)Malloc(L1 = Dmblk_sgulp + L, \"def_name\");\n\t\tslast = snext + L1;\n\t\t}\n\tstrcpy(s = snext, s0);\n\tsnext += L;\n\treturn s;\n\t}\n\nstatic void **DHHlast, **DHHnext;\t/* Could be private to DHHlookup, but here */\n\t\t\t\t\t/* to make them visible to debuggers. */\n static DefhashHead *\nDHHlookup(const char *s0, DefhashTab *Htab, int add)\n{\n\tDefhashHead *h, **hp;\n\tconst char *s;\n\tsize_t L;\n\tunsigned int c, x;\n\n\tfor(x = 0, s = s0; (c = *(unsigned char*)s); ++s)\n\t\tx += DHTfactor*x + c;\n\tx %= DHTlen;\n\tfor(hp = &Htab->Tab[x]; (h = *hp); hp = &h->hnext) {\n\t\tif (!strcmp(s0, h->name))\n\t\t\treturn h;\n\t\t}\n\tif (!add)\n\t\treturn h;\n\tHtab->nent++;\n\tif (DHHnext + Htab->nalloc >= DHHlast) {\n\t\tDHHnext = (void**)Malloc(L = DMblk_gulp*sizeof(void*), \"DHHlookup\");\n\t\tDHHlast = DHHnext + DMblk_gulp;\n\t\tmemset(DHHnext, 0, L);\n\t\t}\n\t*hp = h = (DefhashHead*)DHHnext;\n\tDHHnext += Htab->nalloc;\n\th->name = def_name(s0);\n\th->thread = Htab->lastdh;\n\treturn Htab->lastdh = h;\n\t}\n\n static void\nbothplaces(KWctx *kw, const char *name)\n{ squawk(\"For %s, %s appears both in specfile and tagfile\", kw->names->val, name); }\n\n static void\ntagimport(KWctx *kw, KWctx *tw)\n{\n\ttypedef struct KWimport KWimport;\n\tstruct KWimport { const char *name; size_t off; };\n\tstatic KWimport Imp[] = {\n\t\t{ \"lower bound\",\toffsetof(KWctx,lb) },\n\t\t{ \"upper bound\",\toffsetof(KWctx,ub) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,init) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,cinit) },\n\t\t{ \"defname\",\t\toffsetof(KWctx,defname) },\n\t\t{ \"DESC\",\t\toffsetof(KWctx,desc) },\n\t\t{ \"GROUP\",\t\toffsetof(KWctx,group) },\n\t\t{ \"LEN\",\t\toffsetof(KWctx,len) },\n\t\t{0}};\n\tKWimport *ki;\n#define field(k,n) *(char**)((char*)k+n)\n\tfor(ki = Imp; ki->name; ++ki) {\n\t\tif (field(tw,ki->off)) {\n\t\t\tif (field(kw,ki->off))\n\t\t\t\tbothplaces(kw, ki->name);\n\t\t\telse\n\t\t\t\tfield(kw,ki->off) = field(tw,ki->off);\n\t\t\t}\n\t\t}\n#undef field\n\t}\n\n#ifndef NO_NIDR_DYNLIB\n\nstatic const char *typename[8] = {\n\t\"no value\", \"INTEGER\", \"REAL\", \"STRING\",\n\t\"(Bug! no value LIST)\", \"INTEGERLIST\", \"REALLIST\", \"STRINGLIST\" };\n\n static int\nkwseqnocomp(const void *a, const void *b)\n{\n\tconst KeyWordx *ka, *kb;\n\n\tka = *(KeyWordx**)a;\n\tkb = *(KeyWordx**)b;\n\treturn (int)ka->seqno - (int)kb->seqno;\n\t}\n\n static void\nLsqbpar(void)\n{\n\tLsqb();\n\tLpar();\n\t}\n\n static void\nRparsqb(void)\n{\n\tRpar();\n\tRsqb();\n\t}\n\n static void\nNobrak(void) {}\n\n typedef struct\nKW_Cstak { KeyWordx **Cstak; Uint n, nmax; } KW_Cstak;\n\n static void kw_finish(int);\n static void kw_insert(KeyWord*, KW_Cstak*, int);\n\n static KeyWord*\nkw_stakadj(KeyWord *kw, KW_Cstak *Stk, int needbar, int n0, KeyWord *okw3)\n{\n\tKeyWordx *kw1, *kw2, **x;\n\tUint i, j, k, nst, nz;\n\n\tkw1 = (KeyWordx*)kw;\n\tnz = 0;\n\twhile(!kw1[++nz].kw.name);\n\tif (nz == 1 && *kw1[nz].kw.name)\n\t\tokw3 = 0;\n\tnst = Stk->n;\n\tx = Stk->Cstak;\n\tkw2 = (KeyWordx*)kw1->kw.kw;\n\tfor(i = 0; i < nst; ++i) {\n\t\tif (x[i]->kw.kw == &kw2->kw) {\n\t\t\tj = i;\n\t\t\t++kw1;\n\t\t\t/* No need to test kw1->kw.name in the following loop */\n\t\t\t/* as the == test will fail if kw1->kw.name is nonzero. */\n\t\t\twhile(++j < nst && x[j]->kw.kw == kw1->kw.kw)\n\t\t\t\t++kw1;\n\t\t\tk = nz - (j-i);\n\t\t\tgoto have_jk;\n\t\t\t}\n\t\t}\n\tk = nz;\n\tj = n0;\n have_jk:\n\twhile(nst > j) {\n\t\tkw_insert(&x[--nst]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (needbar)\n\t\tBar();\n\tif (k) {\n\t\tif (nst + k > Stk->nmax)\n\t\t\tx = Stk->Cstak = (KeyWordx**)Realloc(x,\n\t\t\t\t(Stk->nmax = 2)*sizeof(KeyWordx*), \"kw_stakadj\");\n\t\tdo {\n\t\t\tif (kw1->kw.kw != okw3)\n\t\t\t\tLpar();\n\t\t\tx[j++] = kw1++;\n\t\t\t}\n\t\t\twhile(--k);\n\t\tnst = j;\n\t\t}\n\tStk->n = nst;\n\tif (!*kw1->kw.name)\n\t\treturn 0;\n\treturn &kw1->kw;\n\t}\n\n static int\nsame_funcs(KeyWordx *kw1, KeyWordx *kw2)\n{\n\tKeyWordx *kw3, *kw4;\n\n\tif (!kw1->kw.nkw || !kw2->kw.nkw)\n\t\treturn 0;\n\tkw3 = (KeyWordx*)kw1->kw.kw;\n\tkw4 = (KeyWordx*)kw2->kw.kw;\n\tif (kw3 == kw4)\n\t\treturn 1;\n\tif (kw4->kw.name)\n\t\treturn 0;\n\tkw4 = (KeyWordx*)kw4->kw.kw;\n\treturn kw3 == kw4;\n\t}\n\n static char *\nStrCpy(const char *s)\n{\n\tchar *t;\n\tsize_t L;\n\n\tif (!s)\n\t\treturn 0;\n\tL = strlen(s);\n\tt = (char*)Alloc(L+1);\n\tstrcpy(t,s);\n\treturn t;\n\t}\n\n static int Saw_name(const char*);\n static void Saw_stok(int, size_t);\n\n static void\nkw_insert(KeyWord *kw, KW_Cstak *Stk, int top)\n{\n\tenum { NKW0 = 32 };\n\tKeyWord *kw3, *kw30, *okw3;\n\tKeyWordx *kw0, *kw1, *kw2, *kw4, **x, *x0[NKW0];\n\tUint i, j, k, knd, nkw, nst0, nst1;\n\tchar buf[32];\n\tint alt2, incc, needbar, needbar1, samef0, samef1;\n\ttypedef void (*Brak)(void);\n\tBrak Lbrak, Rbrak;\n\n\tkw1 = (KeyWordx*)kw->kw;\n\twhile(!kw1->kw.name)\n\t\t++kw1;\n\tnkw = kw->nkw;\n\tx = x0;\n\tif (nkw > NKW0)\n\t\tx = (KeyWordx**)Malloc(nkw * sizeof(KeyWordx*), \"kw_insert\");\n\tfor(i = 0; i < nkw; ++i)\n\t\tx[i] = kw1++;\n\tif (nkw > 1)\n\t\tqsort(x, nkw, sizeof(KeyWordx*), kwseqnocomp);\n\tkw0 = 0;\n\tkw30 = 0;\n\tnst0 = Stk->n;\n\tfor(i = j = samef0 = 0; i < nkw; i = j) {\n\t\tkw1 = x[i];\n\t\tkw2 = 0;\n\t\twhile(++j < nkw) {\n\t\t\tkw2 = x[j];\n\t\t\tif (!kw2->kw.paoff)\n\t\t\t\tbreak;\n\t\t\tkw2 = 0;\n\t\t\t}\n\t\tLbrak = Rbrak = 0;\n\t\tokw3 = kw30;\n\t\tif (top) {\n\t\t\tkw_finish(kw1->kw.kind & KWKind_12);\n\t\t\tkw3 = kw1->kw.kw;\n\t\t\tRbrak = Nobrak;\n\t\t\tgoto nobrak;\n\t\t\t}\n\t\tneedbar = needbar1 = kw0 && kw0->kw.alt == kw1->kw.alt;\n\t\tnst1 = Stk->n;\n\t\talt2 = incc = 0;\n\t\tkw4 = 0;\n\t\tif (kw2) {\n\t\t\talt2 = kw1->kw.alt == kw2->kw.alt;\n\t\t\tkw4 = (KeyWordx*)kw2->kw.kw;\n\t\t\t}\n\t\tif ((kw3 = kw30 = kw1->kw.kw)) {\n\t\t\tif (!kw3->name) {\n\t\t\t\tkw3 = kw_stakadj(kw3, Stk, needbar, nst0, okw3);\n\t\t\t\tneedbar1 = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\twhile(Stk->n > nst0) {\n\t\t\t\t\tif (Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n\t\t\t\t\t\tif (kw4 && kw4->kw.kw == kw3)\n\t\t\t\t\t\t\tincc = 1; /* in contained context */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\t\tRpar();\n\t\t\t\t\t}\n\t\t\t}\n\t\telse while(Stk->n > nst0) {\n\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\tRpar();\n\t\t\t}\n\t\tsamef0 = needbar && same_funcs(kw1,kw0);\n\t\tsamef1 = alt2    && same_funcs(kw1,kw2);\n\t\tif (kw3) {\n\t\t\tif (samef1) {\n\t\t\t\tif (!needbar)\n\t\t\t\t\tLbrak = kw1->kw.req ? Lpar : Lsqbpar;\n\t\t\t\telse if (!samef0 && kw3->name)\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\tkw3 = 0;\n\t\t\t\tgoto barchk;\n\t\t\t\t}\n\t\t\telse if (needbar) {\n\t\t\t\tif (!incc)\n\t\t\t\t\tRbrak = alt2 || kw1->kw.req ? Rpar : Rparsqb;\n\t\t\t\tif (!samef0\n\t\t\t\t && (Stk->n <= nst1\n\t\t\t\t    || !kw0 || kw0->kw.kw != Stk->Cstak[Stk->n-1]->kw.kw))\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\t}\n\t\t\telse if (kw1->kw.req) {\n\t\t\t\tLbrak = Lpar;\n\t\t\t\tRbrak = Rpar;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tLbrak = Lsqb;\n\t\t\t\tRbrak = Rsqb;\n\t\t\t\tif (alt2) {\n\t\t\t\t\tLbrak = Lsqbpar;\n\t\t\t\t\tRbrak = Rpar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw2) {\n\t\t\t\tif (kw4 && !kw4->kw.name && kw4->kw.kw == kw3)\n\t\t\t\t\tgoto zap_kw3;\n\t\t\t\tif (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3)\n\t\t\t\t\t--Stk->n;\n\t\t\t\t}\n\t\t\telse if (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n zap_kw3:\n\t\t\t\tRbrak = 0;\n\t\t\t\tkw3 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!kw1->kw.req) {\n\t\t\tif (!needbar)\n\t\t\t\tLbrak = Lsqb;\n\t\t\tif (!alt2)\n\t\t\t\tRbrak = Rsqb;\n\t\t\t}\n barchk:\n\t\tif (needbar1)\n\t\t\tBar();\n\t\tif (Lbrak)\n\t\t\tLbrak();\n nobrak:\n\t\tKeywd(kw1->kw.name);\n\t\twhile(++i < j) {\n\t\t\tkw2 = x[i];\n\t\t\tAlias(kw2->kw.name - 6);\t/* Alias will increment by 6 */\n\t\t\t}\n\t\tknd = kw1->kw.kind;\n\t\tif ((k = knd & (KWKind_Mask|KWKind_List)))\n\t\t\tType(k, typename[k]);\n\t\tif ((k = knd & KWKind_Lb)) {\n\t\t\tSaw_tok(knd & KWKind_strictLb ? Saw_gt : Saw_ge, KWKind_Lb);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Lb);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif ((k = knd & KWKind_Ub)) {\n\t\t\tSaw_tok(knd & KWKind_strictUb ? Saw_lt : Saw_le, KWKind_Ub);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Ub);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif (kw1->init || kw1->cinit) {\n\t\t\tSaw_tok(Saw_dflt, KWKind_init);\n\t\t\tlastdef = 0;\n\t\t\tif (kw1->defname)\n\t\t\t\tSaw_name(kw1->defname);\n\t\t\tif (kw1->init)\n\t\t\t\tSaw_num(kw1->init);\n\t\t\telse\n\t\t\t\tlastkw1->cinit = StrCpy(kw1->cinit);\n\t\t\t}\n\t\tif (kw1->funcs)\n\t\t\tlastkw1->funcs = new_StrList(kw1->funcs, 0);\n\t\telse if (kw1->kw.f.vf && !kw1->kw.f.final) {\n\t\t\tlastkw1->dylib = StrCpy((const char*)kw1->kw.f.vf);\n\t\t\tdynlibseen = 1;\n\t\t\t}\n\t\telse\n\t\t\tlastkw1->funcs = new_StrList(\"0\", 0);\n\t\tlastkw1->desc  = StrCpy(kw1->desc);\n\t\tlastkw1->group = StrCpy(kw1->group);\n\t\tif (kw1->alen) {\n\t\t\tSaw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\tlastkw1->kind |= knd & KWKind_Len1OK;\n\t\t\tSaw_name(kw1->alen);\n\t\t\t}\n\t\tif (Rbrak) {\n\t\t\tif (kw3)\n\t\t\t\tkw_insert((KeyWord*)kw1, Stk, 0);\n\t\t\tRbrak();\n\t\t\t}\n\t\tkw0 = kw1;\n\t\tif (top) {\n\t\t\twhile(Stk->n > 0) {\n\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\tRpar();\n\t\t\t\t}\n\t\t\tif (!kw2)\n\t\t\t\tkw_finish(-1);\n\t\t\t}\n\t\t}\n\twhile(Stk->n > nst0) {\n\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nkw_insert1(KeyWord *kw, int top)\n{\n\tKW_Cstak Stk;\n\n\tStk.n = 0;\n\tStk.Cstak = (KeyWordx**)Malloc((Stk.nmax = 64)*sizeof(KeyWordx*), \"kw_insert1\");\n\tif (top) {\n\t\tKWtop = KWStack;\n\t\tKWbase.kw = 0;\n\t\t}\n\tkw_insert(kw, &Stk, top);\n\twhile(Stk.n > 0) {\n\t\tkw_insert(&Stk.Cstak[--Stk.n]->kw, &Stk, 0);\n\t\tRpar();\n\t\t}\n\tfree(Stk.Cstak);\n\t}\n\n static int\nlibread1(const char *kname, const char *lname, Uint n, int allow_top)\n{\n\tKW_ADD kwa;\n\tKeyWord *kw, kw0;\n\tUint i;\n\tconst char *s;\n\tvoid *h, (*Botch)(const char*, ...);\n\n\th = dlopen(lname, RTLD_NOW);\n\tif (!h) {\n\t\tBotch = botch;\n\t\tif (kname && libexpand)\n\t\t\tBotch = squawk;\n#ifndef _WIN32\n\t\tif ((s = dlerror()))\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\t\tlname, kname, s);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\",\n\t\t\t\t\tlname, s);\n\t\telse\n#endif\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\t\tlname, kname);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\"\", lname);\n\t\treturn ++liberror;\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw = (*kwa)();\n\tif (!(s = kw->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tif (allow_top) {\n\t\tif (strcmp(s, \"KeywordTop\")) {\n\t\t\tif (allow_top == 2) {\n\t\t\t\tmemset(&kw0, 0, sizeof(KeyWord));\n\t\t\t\tkw0.kw = kw;\n\t\t\t\tkw = &kw0;\n\t\t\t\tkw0.nkw = 1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tallow_top = 0;\n\t\t\t}\n\t\telse\n\t\t\tkname = 0;\n\t\t}\n\telse if (kname && strcmp(s, kname)) {\n namebotch:\n\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\tlname, kname, s);\n\t\t}\n\tif (kname) {\n\t\ti = kw->kind & (KWKind_Mask|KWKind_List);\n\t\tif (i != n)\n\t\t\tbotch(\"Library %s: expected %s to be %s, but got %s\",\n\t\t\t\tlname, kname, typename[n], typename[i]);\n\t\t}\n\tif (kw->kw)\n\t\tkw_insert1(kw, allow_top);\n\tdlclose(h);\n\treturn 0;\n\t}\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tconst char *kname, *lname;\n\n\tkname = kc->name1;\n\tlname = kc->dylib;\n\tkc->dylib = 0;\n\treturn libread1(kname, lname, kc->kind & (KWKind_Mask|KWKind_List), allow_top);\n\t}\n#else\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", kc->dylib);\n\treturn 1;\n\t}\n#endif\n\n static void\nKeywd(const char *s)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2, *kwm, **kwp;\n\tStrList *nam;\n\tTaghash *th;\n\tchar *s1;\n\tint alt, lsave, req;\n\tsize_t L, L1;\n\tstatic char allowed[] = { '(',')','[',']','|', Saw_kwname, Saw_type, 0 };\n\n\tif (tagin)\n\t\tbotch(\"Inappropriate text \\\"%s\\\" in tagfile \\\"%s\\\"\", s, tagfname);\n\tkw1 = *KWtop;\n#ifndef NO_NIDR_DYNLIB\n\tif (kw1->dylib && libexpand && !lib_read(kw1,0))\n\t\tkw1 = *KWtop;\n#endif\n\tkw0 = kw1;\n\tkwm = 0;\n\tif (!kw1->names && s) {\n\t\tswitch(kw1->parstate) {\n\t\t  case PPar_emtpy:\n\t\t\tdo {\n\t\t\t\tkw1->parstate = PPar_starting;\n\t\t\t\tkw1 = kw1->pparent;\n\t\t\t\t}\n\t\t\t\twhile(kw1 && kw1->parstate == PPar_emtpy);\n\t\t\tkw1 = kw0->rparent;\n\t\t\tbreak;\n\t\t  case PPar_starting:\n\t\t\tif (or_mode)\n\t\t\t\tkw1 = kw0->rparent;\n\t\t\telse\n\t\t\t\tkw1->parstate = PPar_started;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\tif (or_mode && !kw1->kw) {\n\t\tkw2 = KWtop[-1];\n\t\tif (!kw2->names && kw2->parstate == PPar_starting)\n\t\t\tkw2 = kw2->rparent;\n\t\tif (s)\n\t\t\tkw1->master = kwm = kw1;\n\t\tkw1 = kw2;\n\t\t}\n\tL = alt = req = 0;\n\tif (s) {\n\t\tkwp = KWStack + kw1->level + 1;\n\t\tif (kwp > KWtop)\n\t\t\tkwp = KWtop;\n\t\twhile(kwp > KWStack) {\n\t\t\tkw2 = *kwp--;\n\t\t\tif (kw2->name1) {\n\t\t\t\tdtnext = deftag + kw2->dtnext;\n\t\t\t\tL = kw2->name1len;\n\t\t\t\tstrcpy(dtnext-L, kw2->name1);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\talt = ++kw1->nalt;\n\t\tif (*Br_top != '['/*]*/ || Br_top == kw1->Br_top) {\n\t\t\treq = ++kw1->nreq;\n\t\t\tif (*Br_top == '(' /*)*/) /* allow [(...)|...] */\n\t\t\t\tfor(s1 = Br_top; --s1 > kw1->Br_top; ) {\n\t\t\t\t\tif (*s1 != '(' /*)*/) {\n\t\t\t\t\t\tif (*s1 == '[' /*]*/) {\n\t\t\t\t\t\t\t--kw1->nreq;\n\t\t\t\t\t\t\treq = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\tif (or_mode) {\n\t\t\talt = --kw1->nalt;\n\t\t\tif (req)\n\t\t\t\treq = --kw1->nreq;\n\t\t\t}\n\t\tif (lastseen)\n\t\t\treqchk(allowed, s);\n\t\tor_mode = 0;\n\t\t}\n\tlastkw = lastkw1 = kw = (KWctx*) Alloc(sizeof(KWctx));\n\tif (!kw0->names)\n\t\tkw->pparent = kw0;\n\tif (s) {\n\t\tkw->names = nam = new_StrList(s,0);\n\t\tkw->name1 = nam->val;\n\t\tkw->name1len = L = strlen(s);\n\t\tfor(kwp = KWtop; kwp > KWStack; --kwp) {\n\t\t\tkw2 = *kwp;\n\t\t\tif (kw2->names) {\n\t\t\t\tif (kwp < KWtop) {\n\t\t\t\t\tL1 = kw2->dtnext + L + 1;\n\t\t\t\t\twhile(++kwp <= KWtop) {\n\t\t\t\t\t\tkw2 = *kwp;\n\t\t\t\t\t\tif (!kw2->name1) {\n\t\t\t\t\t\t\tkw2->name1 = kw->name1;\n\t\t\t\t\t\t\tkw2->name1len = L;\n\t\t\t\t\t\t\tkw2->dtnext = L1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kw1->dylib) {\n\t\t\tlsave = Lineno;\n\t\t\tLineno = dynline; /* Line where DYNLIB appeared */\n\t\t\tsquawk(\"Suppressing DYNLIB for %s to parse contained keywords\",\n\t\t\t\tkw1->names ? kw1->names->val : \"???? (bug!)\");\n\t\t\tLineno = lsave;\n\t\t\tkw1->dylib = 0;\n\t\t\t}\n\t\tnam->primary = KWKind_primary;\n\t\tnam->seqno = ++seqno;\n\t\tkw->next = kw1->kw;\n\t\tkw1->kw = kw;\n\t\tif (lastseen == '(' /*)*/)\n\t\t\tkw->parstate = PPar_leftpar;\n\t\tkw->agroup = lastagroup++;\n\t\t}\n\telse {\n\t\tkw->objno = ++lastobjno;\n\t\tif (!kw1->kw && (kw->rparent = kw1->rparent))\n\t\t\tkw1 = kw->rparent;\n\t\telse\n\t\t\tkw->rparent = kw1;\n\t\talt = kw1->alt;\n\t\treq = kw1->req;\n\t\t}\n\tkw->alt = alt;\n\tkw->req = req;\n\tkw->Br_top = Br_top;\n\tkw->master = kwm;\n\tkw->level = KWtop - KWStack;\n\tif (lastseen == '(' || lastseen == '[' /*])*/ || KWtop == KWStack) {\n\t\tif (++KWtop - KWStack >= KW_stacklen)\n\t\t\tbotch(\"KW stack overflow\");\n\t\t*KWtop = kw;\n\t\t}\n\tlasttag = 0;\n\tif (s) {\n\t\tif (dtnext > deftag)\n\t\t\t*dtnext++ = '/';\n\t\tif (dtnext + L >= dtend)\n\t\t\tbotch(\"deftag overflow\");\n\t\tmemcpy(dtnext, s, L);\n\t\t*(dtnext += L) = 0;\n\t\tif (tagout)\n\t\t\tfprintf(tagout, \"TAG \\\"%s\\\"\\n\", deftag);\n\t\tif (tagfname) {\n\t\t\tif ((th = (Taghash*)DHHlookup(deftag, &TagTab, ignoretags))) {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (mtagout)\n\t\t\t\tfprintf(mtagout, \"TAG \\\"%s\\\" #missing\\n\", deftag);\n\t\t\t}\n\t\t}\n\tkw->dtnext = dtnext - deftag;\n\tif (lastseen == 0)\n\t\tkw->kind = kwmult;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nkw_finish(int nextkind)\n{\n\tKWctx *kw;\n\n\tif (*Br_top)\n\t\tbotch(\"unmatched '%c'\", *Br_top);\n\tif (KWtop - KWStack > 1)\n\t\tbotch(\"bug: KW stack botch in kw_finish\");\n\tif (KWtop > KWStack) {\n\t\tkw = *KWtop;\n\t\tif (kw->dylib && libexpand)\n\t\t\tlib_read(kw, nextkind == -1);\n\t\t}\n\tKWtop = KWStack;\n\tdtnext = deftag;\n\tlastseen = 0;\n\tkwmult = nextkind < 0 ? 0 : nextkind;\n\t}\n\n static void\nfuncbotch(KWctx *kw)\n{\n\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions cannot be used with DYNLIB\"\n\t\t\".\\n\\t\\tThey must be supplied by the dynamically loaded library\",\n\t\tkw->names->val);\n\t}\n\n static void\nFnc(char *s)\n{\n\tKWctx *kw;\n\n\tif (!(kw = lastkw1))\n\t\tbotch(\"misplaced {...}\");\n\tif (++kw->nfcn > 4)\n\t\tbotch(\"too many functions in {...}\");\n\telse if (kw->dylib)\n\t\tfuncbotch(kw);\n\telse if (kw->kind & KWKind_Libname)\n\t\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions \"\n\t\t\t\"cannot be used with LIBNAME.\",\n\t\t\tkw->names->val);\n\tkw->funcs = wantfuncs ? new_StrList(s, kw->funcs) : 0;\n\tlastseen = Saw_func;\n\t}\n\n static const char*\ntname_adj(const char *tname, int what, int kbits)\n{\n\tUint k = lastkw1->kind;\n\n\tswitch(what) {\n\t case Saw_lt:\n\t\tif (k & KWKind_caneqUb)\n\t\t\ttname = \"<=\";\n\t\tbreak;\n\t case Saw_le:\n\t\tif (k & KWKind_strictUb)\n\t\t\ttname = \"<\";\n\t\tbreak;\n\t case Saw_ge:\n\t\tif (k & KWKind_strictLb)\n\t\t\ttname = \">\";\n\t\tbreak;\n\t case Saw_gt:\n\t\tif (k & KWKind_caneqLb)\n\t\t\ttname = \">=\";\n\t }\n\treturn tname;\n\t}\n\n static void\nSaw_tok(int what, int kbits)\n{\n\tconst char *tname;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (lastkw1->kind & kbits) {\n\t\t\ttname = tokname[what];\n\t\t\tif (kbits & (KWKind_Lb | KWKind_Ub))\n\t\t\t\ttname = tname_adj(tname, what, kbits);\n\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\ttname, lastkw1->names->val);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static void\nSaw_stok(int what, size_t woff)\n{\n\tStrList *sl;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (*(void**)((char*)lastkw1 + woff)) {\n\t\t\tif ((sl = lastkw1->names))\n\t\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\t\ttokname[what], sl->val);\n\t\t\telse\n\t\t\t\tbotch(\"%s already seen\", tokname[what]);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static KWctx *\nlenfind(const char *s)\n{\n\tKWctx *kw, *kw0, **pkw;\n\tStrList *sl;\n\n\tkw0 = lastkw1;\n\tfor(pkw = KWtop; pkw > KWStack; --pkw) {\n\t\tkw = *pkw;\n\t\tfor(kw = kw->kw; kw; kw = kw->next) {\n\t\t\tfor(sl = kw->names; sl; sl = sl->next)\n\t\t\t\tif (!strcmp(sl->val, s))\n\t\t\t\t\treturn kw;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n\n static void\nalreadyseen(const char *what)\n{\n\tsquawk(\"%s already given for %s\", what, lastkw1->names->val);\n\t}\n\n static int\nSaw_name(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\tTaghash *th;\n\tconst char *s1;\n\tstatic const char notfound[] =\n\t\t\"keyword \\\"%s\\\" not found in this or an enclosing context\";\n\n\tif (lastkw1) {\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t\tlastseen = Saw_dfltname;\n\t\t\tlastdef = (Defhash*)DHHlookup(s, &DHTab, 1);\n\t\t\tif (!lastkw1->defname)\n\t\t\t\tlastkw1->defname = def_name(s);\n\t\t\telse if (lastdef->value\n\t\t\t\t && ((s1 = lastkw1->init) || (s1 = lastkw1->cinit))\n\t\t\t\t && strcmp(s1, lastdef->value))\n\t\t\t\t\tsquawk(\"Inconsistent definitions for %s: %s and %s\\n\",\n\t\t\t\t\t\tlastdef->hh.name, lastdef->value, s1);\n\t\t\treturn 0;\n\t\t  case Saw_len:\n\t\t\tif (lastkw1->len) {\n\t\t\t\talreadyseen(\"LEN\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tkw = lenfind(s);\n\t\t\tif (!kw)\n\t\t\t\tsquawk(notfound,s);\n\t\t\telse {\n\t\t\t\tif ((kw->kind & KWKind_Mask) != KWKind_Int)\n\t\t\t\t\tsquawk(\"%s is not of type INTEGER\", kw->names->val);\n\t\t\t\tfor(sl = kw->names; sl->next; sl = sl->next);\n\t\t\t\tlastkw1->len = sl->val;\n\t\t\t\t}\n\t\t\tgoto ret1;\n\t\t  case Saw_group:\n\t\t\tif (lastkw1->group)\n\t\t\t\talreadyseen(\"GROUP\");\n\t\t\telse\n\t\t\t\tstrcpy(lastkw1->group = (char*)Alloc(strlen(s)+1), s);\n\t\t\tgoto ret1;\n\t\t  case Saw_tag:\n\t\t\tif (tagin)\n\t\t\t\tgoto new_tag;\n\t\t\tif (lasttag) {\n\t\t\t\talreadyseen(\"TAG\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tif (!tagfname && !ignoretags) {\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found: no tag file given\", s);\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tth = (Taghash*)DHHlookup(s, &TagTab, ignoretags);\n\t\t\tif (!th)\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found in tag file \\\"%s\\\"\", s, tagfname);\n\t\t\telse {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n ret1:\n\t\t\tlastseen = Saw_type;\n\t\t\treturn 1;\n\t\t  }\n\t\t}\n\telse if (tagin) {\n new_tag:\n\t\tth = (Taghash*)DHHlookup(s, &TagTab, 1);\n\t\tif (th->kw)\n\t\t\tsquawk(\"Tag \\\"%s\\\" already seen in tagfile %s\\n\", s, tagfname);\n\t\telse\n\t\t\tth->kw = lastkw1 = (KWctx*) Alloc(sizeof(KWctx));\n\t\tgoto ret1;\n\t\t}\n\tbotch(\"unexpected name \\\"%s\\\"\", s);\n\treturn 0; /* not reached */\n\t}\n\n static void\nboundalready(const char *what)\n{\n\tsquawk(\"%s bound already given for %s\", what, lastkw1->names->val);\n\t}\n\n static void\nset_lastdef(const char *s, int qkeep)\n{\n\tif (!lastdef->value) {\n\t\tlastdef->value = def_name(s);\n\t\tlastdef->qkeep = qkeep;\n\t\t}\n\telse if (strcmp(s, lastdef->value))\n\t\tsquawk(\"Two := values for %s: %s and %s\", lastdef->hh.name,\n\t\t\tlastdef->value, s);\n\t}\n\n static void\nSaw_num(const char *s)\n{\n\tDefhash *ld;\n\tdouble x, xa;\n\tchar *se, **sp;\n\tint k;\n\tstatic double b[3];\n\n\tstatic char allowed[] = { Saw_dflt, Saw_dfltname, Saw_lt, Saw_le, Saw_ge, Saw_gt, 0 };\n\n\treqchk(allowed, \"number\");\n\tx = strtod(s,&se);\n\tif (*se)\n\t\tbotch(\"invalid number: \\\"%s\\\"\", s);\n\tld = 0;\n\tsp = 0;\n\tswitch(lastseen) {\n\t\tcase Saw_dflt:\n\t\tcase Saw_dfltname:\n\t\t\tsp = &lastkw1->init;\n\t\t\tlastkw1->kind |= KWKind_init;\n\t\t\tld = lastdef;\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int)\n\t\t\t\tx = x >= 0. ? floor(x) : ceil(x);\n\t\t\tb[2] = x;\n\t\t\tif (lastkw1->lb && x < b[0])\n\t\t\t\tsquawk(\"default value inconsistent with lower bound\");\n\t\t\tif (lastkw1->ub && x > b[1])\n\t\t\t\tsquawk(\"default value inconsistent with upper bound\");\n\t\t\tbreak;\n\t\tcase Saw_gt:\n\t\tcase Saw_ge:\n\t\t\tif (lastkw1->lb) {\n\t\t\t\tboundalready(\"lower\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = ceil(x);\n\t\t\t\tif (xa > x) {\n\t\t\t\t\tif (btype == KWKind_strictLb)\n\t\t\t\t\t\tbtype = KWKind_caneqLb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->lb;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[0] = x;\n\t\t\tif (lastkw1->ub && x >= b[1])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x > b[2])\n\t\t\t\tsquawk(\"lower bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tcase Saw_le:\n\t\tcase Saw_lt:\n\t\t\tif (lastkw1->ub) {\n\t\t\t\tboundalready(\"upper\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = floor(x);\n\t\t\t\tif (xa < x) {\n\t\t\t\t\tif (btype == KWKind_strictUb)\n\t\t\t\t\t\tbtype = KWKind_caneqUb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->ub;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[1] = x;\n\t\t\tif (lastkw1->lb && x <= b[0])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x < b[2])\n\t\t\t\tsquawk(\"upper bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunexpected(s);\n\t\t}\n\tk = lastkw1->kind & KWKind_Mask;\n\tif ((k == KWKind_Void && !tagin) || k == KWKind_Str)\n\t\tsquawk(\"cannot accept a %s value\", tokname[lastseen]);\n\telse {\n\t\tstrcpy(*sp = (char*)Alloc(strlen(s)+1), s);\n\t\tif (ld)\n\t\t\tset_lastdef(s, 0);\n\t\t}\n ret:\n\tlastseen = Saw_type;\n\t}\n\n#define FNC 1\n#define VAL 2\n\n/* #line 2011 \"nidrgen.c\" */\n\n/* Macros after this point can all be overridden by user definitions in\n * section 1.\n */\n\n#ifndef YY_SKIP_YYWRAP\n#ifdef __cplusplus\nextern \"C\" int yywrap YY_PROTO(( void ));\n#else\nextern int yywrap YY_PROTO(( void ));\n#endif\n#endif\n\n#ifndef YY_NO_UNPUT\nstatic void yyunput YY_PROTO(( int c, char *buf_ptr ));\n#endif\n\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));\n#endif\n\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen YY_PROTO(( yyconst char * ));\n#endif\n\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\nstatic int yyinput YY_PROTO(( void ));\n#else\nstatic int input YY_PROTO(( void ));\n#endif\n#endif\n\n#if YY_STACK_USED\nstatic int yy_start_stack_ptr = 0;\nstatic int yy_start_stack_depth = 0;\nstatic int *yy_start_stack = 0;\n#ifndef YY_NO_PUSH_STATE\nstatic void yy_push_state YY_PROTO(( int new_state ));\n#endif\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state YY_PROTO(( void ));\n#endif\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state YY_PROTO(( void ));\n#endif\n\n#else\n#define YY_NO_PUSH_STATE 1\n#define YY_NO_POP_STATE 1\n#define YY_NO_TOP_STATE 1\n#endif\n\n#ifdef YY_MALLOC_DECL\nYY_MALLOC_DECL\n#else\n#if __STDC__\n#ifndef __cplusplus\n#include <stdlib.h>\n#endif\n#else\n/* Just try to get by without declaring the routines.  This will fail\n * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)\n * or sizeof(void*) != sizeof(int).\n */\n#endif\n#endif\n\n/* Amount of stuff to slurp up with each read. */\n#ifndef YY_READ_BUF_SIZE\n#define YY_READ_BUF_SIZE 8192\n#endif\n\n/* Copy whatever the last rule matched to the standard output. */\n\n#ifndef ECHO\n/* This used to be an fputs(), but since the string might contain NUL's,\n * we now use fwrite().\n */\n#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )\n#endif\n\n/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n * is returned in \"result\".\n */\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n\tif ( yy_current_buffer->yy_is_interactive ) \\\n\t\t{ \\\n\t\tint c = '*', n; \\\n\t\tfor ( n = 0; n < max_size && \\\n\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n\t\t\tbuf[n] = (char) c; \\\n\t\tif ( c == '\\n' ) \\\n\t\t\tbuf[n++] = (char) c; \\\n\t\tif ( c == EOF && ferror( yyin ) ) \\\n\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n\t\tresult = n; \\\n\t\t} \\\n\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\n\t\t  && ferror( yyin ) ) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n#endif\n\n/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n * we don't want an extra ';' after the \"return\" because that will cause\n * some compilers to complain about unreachable statements.\n */\n#ifndef yyterminate\n#define yyterminate() return YY_NULL\n#endif\n\n/* Number of entries by which start-condition stack grows. */\n#ifndef YY_START_STACK_INCR\n#define YY_START_STACK_INCR 25\n#endif\n\n/* Report a fatal error. */\n#ifndef YY_FATAL_ERROR\n#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n#endif\n\n/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL int yylex YY_PROTO(( void ))\n#endif\n\n/* Code executed at the beginning of each rule, after yytext and yyleng\n * have been set up.\n */\n#ifndef YY_USER_ACTION\n#define YY_USER_ACTION\n#endif\n\n/* Code executed at the end of each rule. */\n#ifndef YY_BREAK\n#define YY_BREAK break;\n#endif\n\n#define YY_RULE_SETUP \\\n\tYY_USER_ACTION\n\nYY_DECL\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp = NULL, *yy_bp = NULL;\n\tregister int yy_act;\n\n/* #line 1528 \"nidrgen.l\" */\n\n\n/* #line 2165 \"nidrgen.c\" */\n\n\tif ( yy_init )\n\t\t{\n\t\tyy_init = 0;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yy_start )\n\t\t\tyy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! yy_current_buffer )\n\t\t\tyy_current_buffer =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\n\n\t\tyy_load_buffer_state();\n\t\t}\n\n\twhile ( 1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tregister YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 128 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_base[yy_current_state] != 316 );\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\t\tif ( yy_act == 0 )\n\t\t\t{ /* have to back up */\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tyy_act = yy_accept[yy_current_state];\n\t\t\t}\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yy_hold_char;\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n/* #line 1530 \"nidrgen.l\" */\n{ ++Lineno; }\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n/* #line 1531 \"nidrgen.l\" */\n{}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n/* #line 1532 \"nidrgen.l\" */\n{ Alias(yytext); }\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n/* #line 1533 \"nidrgen.l\" */\n{ Type(KWKind_Int, yytext); }\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n/* #line 1534 \"nidrgen.l\" */\n{ Type(KWKind_Int | KWKind_List, yytext); }\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n/* #line 1535 \"nidrgen.l\" */\n{ kw_finish(0); }\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n/* #line 1536 \"nidrgen.l\" */\n{ kw_finish(KWKind_1); }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n/* #line 1537 \"nidrgen.l\" */\n{ kw_finish(KWKind_01); }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n/* #line 1538 \"nidrgen.l\" */\n{ kw_finish(KWKind_12); }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n/* #line 1539 \"nidrgen.l\" */\n{ Type(KWKind_Str|KWKind_Libname, yytext); }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n/* #line 1540 \"nidrgen.l\" */\n{ Type(KWKind_Real, yytext); }\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n/* #line 1541 \"nidrgen.l\" */\n{ Type(KWKind_Real | KWKind_List, yytext); }\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n/* #line 1542 \"nidrgen.l\" */\n{ Type(KWKind_Str, yytext); }\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n/* #line 1543 \"nidrgen.l\" */\n{ Type(KWKind_Str | KWKind_List, yytext); }\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n/* #line 1544 \"nidrgen.l\" */\n{ Keywd(yytext); }\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n/* #line 1545 \"nidrgen.l\" */\n{ kw_finish(-1); }\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n/* #line 1546 \"nidrgen.l\" */\n{ Saw_stok(Saw_desc, offsetof(KWctx,desc));\tBEGIN VAL; }\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n/* #line 1547 \"nidrgen.l\" */\n{ Saw_stok(Saw_tag, offsetof(KWctx,tag));\tBEGIN VAL; }\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n/* #line 1548 \"nidrgen.l\" */\n{ Saw_stok(Saw_group, offsetof(KWctx,group));\tBEGIN VAL; }\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n/* #line 1549 \"nidrgen.l\" */\n{ Saw_tok(Saw_dy, offsetof(KWctx,dylib));\n\t\t\t  dynlibseen = 1; dynline = Lineno;\t\tBEGIN VAL; }\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n/* #line 1551 \"nidrgen.l\" */\n{ Saw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\t  lastkw1->kind |= KWKind_Len1OK;\t\tBEGIN VAL; }\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n/* #line 1553 \"nidrgen.l\" */\n{ Saw_stok(Saw_len, offsetof(KWctx,len));\tBEGIN VAL; }\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n/* #line 1554 \"nidrgen.l\" */\n{ Saw_tok(Saw_dflt, KWKind_init); lastdef = 0;\tBEGIN VAL; }\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n/* #line 1555 \"nidrgen.l\" */\n{ Saw_tok(Saw_ge, KWKind_Lb); btype = KWKind_caneqLb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n/* #line 1556 \"nidrgen.l\" */\n{ Saw_tok(Saw_gt, KWKind_Lb); btype = KWKind_strictLb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n/* #line 1557 \"nidrgen.l\" */\n{ Saw_tok(Saw_le, KWKind_Ub); btype = KWKind_caneqUb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n/* #line 1558 \"nidrgen.l\" */\n{ Saw_tok(Saw_lt, KWKind_Ub); btype = KWKind_strictUb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n/* #line 1559 \"nidrgen.l\" */\n{ if (Saw_name(yytext))\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n/* #line 1560 \"nidrgen.l\" */\n{ Saw_num(yytext);\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 30:\nYY_RULE_SETUP\n/* #line 1561 \"nidrgen.l\" */\n{ Saw_quote();\t\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n/* #line 1563 \"nidrgen.l\" */\n{ Lbrace(); BEGIN FNC; }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n/* #line 1564 \"nidrgen.l\" */\n{ Rbrace(); BEGIN INITIAL; }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n/* #line 1565 \"nidrgen.l\" */\n{ Bar(); }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n/* #line 1566 \"nidrgen.l\" */\n{ Lpar(); }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n/* #line 1567 \"nidrgen.l\" */\n{ Rpar(); }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n/* #line 1568 \"nidrgen.l\" */\n{ Lsqb(); }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n/* #line 1569 \"nidrgen.l\" */\n{ Rsqb(); }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n/* #line 1570 \"nidrgen.l\" */\n{ Fnc(yytext); }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n/* #line 1571 \"nidrgen.l\" */\n{}\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n/* #line 1572 \"nidrgen.l\" */\n{++Lineno;}\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n/* #line 1573 \"nidrgen.l\" */\n{ Eat_comment(); }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n/* #line 1574 \"nidrgen.l\" */\n{ botch(\"\\\"%s\\\" unexpected\", yytext); }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n/* #line 1576 \"nidrgen.l\" */\nECHO;\n\tYY_BREAK\n/* #line 2465 \"nidrgen.c\" */\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(FNC):\ncase YY_STATE_EOF(VAL):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between yy_current_buffer and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\t\t\tyy_current_buffer->yy_input_file = yyin;\n\t\t\tyy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\n\n\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer() )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap() )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t\tyytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of yylex */\n\n\n/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n\nstatic int yy_get_next_buffer()\n\t{\n\tregister char *dest = yy_current_buffer->yy_ch_buf;\n\tregister char *source = yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( yy_current_buffer->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\tint num_to_read =\n\t\t\tyy_current_buffer->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n#ifdef YY_USES_REJECT\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n#else\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = yy_current_buffer;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyy_flex_realloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = yy_current_buffer->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n#endif\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\n\t\t\tyy_n_chars, num_to_read );\n\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tif ( yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tyy_current_buffer->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tyy_n_chars += number_to_move;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];\n\n\treturn ret_val;\n\t}\n\n\n/* yy_get_previous_state - get the state just before the EOB char was reached */\n\nstatic yy_state_type yy_get_previous_state()\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n\n\tyy_current_state = yy_start;\n\n\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 128 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n\t}\n\n\n/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n\n#ifdef YY_USE_PROTOS\nstatic yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )\n#else\nstatic yy_state_type yy_try_NUL_trans( yy_current_state )\nyy_state_type yy_current_state;\n#endif\n\t{\n\tregister int yy_is_jam;\n\tregister char *yy_cp = yy_c_buf_p;\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyy_last_accepting_state = yy_current_state;\n\t\tyy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 128 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 127);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n\t}\n\n\n#ifndef YY_NO_UNPUT\n#ifdef YY_USE_PROTOS\nstatic void yyunput( int c, register char *yy_bp )\n#else\nstatic void yyunput( c, yy_bp )\nint c;\nregister char *yy_bp;\n#endif\n\t{\n\tregister char *yy_cp = yy_c_buf_p;\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = yy_hold_char;\n\n\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = yy_n_chars + 2;\n\t\tregister char *dest = &yy_current_buffer->yy_ch_buf[\n\t\t\t\t\tyy_current_buffer->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > yy_current_buffer->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tyy_current_buffer->yy_n_chars =\n\t\t\tyy_n_chars = yy_current_buffer->yy_buf_size;\n\n\t\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\n\tyytext_ptr = yy_bp;\n\tyy_hold_char = *yy_cp;\n\tyy_c_buf_p = yy_cp;\n\t}\n#endif\t/* ifndef YY_NO_UNPUT */\n\n\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\nstatic int yyinput()\n#else\nstatic int input()\n#endif\n\t{\n\tint c;\n\n\t*yy_c_buf_p = yy_hold_char;\n\n\tif ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = yy_c_buf_p - yytext_ptr;\n\t\t\t++yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer() )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin );\n\n\t\t\t\t\t/* fall through */\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap() )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyy_hold_char = *++yy_c_buf_p;\n\n\n\treturn c;\n\t}\n#endif /* YY_NO_INPUT */\n\n#ifdef YY_USE_PROTOS\nvoid yyrestart( FILE *input_file )\n#else\nvoid yyrestart( input_file )\nFILE *input_file;\n#endif\n\t{\n\tif ( ! yy_current_buffer )\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );\n\n\tyy_init_buffer( yy_current_buffer, input_file );\n\tyy_load_buffer_state();\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n#else\nvoid yy_switch_to_buffer( new_buffer )\nYY_BUFFER_STATE new_buffer;\n#endif\n\t{\n\tif ( yy_current_buffer == new_buffer )\n\t\treturn;\n\n\tif ( yy_current_buffer )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yy_c_buf_p = yy_hold_char;\n\t\tyy_current_buffer->yy_buf_pos = yy_c_buf_p;\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tyy_current_buffer = new_buffer;\n\tyy_load_buffer_state();\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyy_did_buffer_switch_on_eof = 1;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_load_buffer_state( void )\n#else\nvoid yy_load_buffer_state()\n#endif\n\t{\n\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\n\tyyin = yy_current_buffer->yy_input_file;\n\tyy_hold_char = *yy_c_buf_p;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n#else\nYY_BUFFER_STATE yy_create_buffer( file, size )\nFILE *file;\nint size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer( b, file );\n\n\treturn b;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_delete_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_delete_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_current_buffer = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyy_flex_free( (void *) b->yy_ch_buf );\n\n\tyy_flex_free( (void *) b );\n\t}\n\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )\n#else\nvoid yy_init_buffer( b, file )\nYY_BUFFER_STATE b;\nFILE *file;\n#endif\n\n\n\t{\n\tyy_flush_buffer( b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n#if YY_ALWAYS_INTERACTIVE\n\tb->yy_is_interactive = 1;\n#else\n#if YY_NEVER_INTERACTIVE\n\tb->yy_is_interactive = 0;\n#else\n\tb->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n#endif\n#endif\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_flush_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_flush_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_load_buffer_state();\n\t}\n\n\n#ifndef YY_NO_SCAN_BUFFER\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )\n#else\nYY_BUFFER_STATE yy_scan_buffer( base, size )\nchar *base;\nyy_size_t size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b );\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_STRING\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )\n#else\nYY_BUFFER_STATE yy_scan_string( yy_str )\nyyconst char *yy_str;\n#endif\n\t{\n\tint len;\n\tfor ( len = 0; yy_str[len]; ++len )\n\t\t;\n\n\treturn yy_scan_bytes( yy_str, len );\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_BYTES\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )\n#else\nYY_BUFFER_STATE yy_scan_bytes( bytes, len )\nyyconst char *bytes;\nint len;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n\n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = len + 2;\n\tbuf = (char *) yy_flex_alloc( n );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < len; ++i )\n\t\tbuf[i] = bytes[i];\n\n\tbuf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_PUSH_STATE\n#ifdef YY_USE_PROTOS\nstatic void yy_push_state( int new_state )\n#else\nstatic void yy_push_state( new_state )\nint new_state;\n#endif\n\t{\n\tif ( yy_start_stack_ptr >= yy_start_stack_depth )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tyy_start_stack_depth += YY_START_STACK_INCR;\n\t\tnew_size = yy_start_stack_depth * sizeof( int );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tyy_start_stack = (int *) yy_flex_alloc( new_size );\n\n\t\telse\n\t\t\tyy_start_stack = (int *) yy_flex_realloc(\n\t\t\t\t\t(void *) yy_start_stack, new_size );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tYY_FATAL_ERROR(\n\t\t\t\"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tyy_start_stack[yy_start_stack_ptr++] = YY_START;\n\n\tBEGIN(new_state);\n\t}\n#endif\n\n\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state()\n\t{\n\tif ( --yy_start_stack_ptr < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(yy_start_stack[yy_start_stack_ptr]);\n\t}\n#endif\n\n\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state()\n\t{\n\treturn yy_start_stack[yy_start_stack_ptr - 1];\n\t}\n#endif\n\n#ifndef YY_EXIT_FAILURE\n#define YY_EXIT_FAILURE 2\n#endif\n\n#ifdef YY_USE_PROTOS\nstatic void yy_fatal_error( yyconst char msg[] )\n#else\nstatic void yy_fatal_error( msg )\nchar msg[];\n#endif\n\t{\n\t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n\t}\n\n\n\n/* Redefine yyless() so it works in section 3 code. */\n\n#undef yyless\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\tyytext[yyleng] = yy_hold_char; \\\n\t\tyy_c_buf_p = yytext + n; \\\n\t\tyy_hold_char = *yy_c_buf_p; \\\n\t\t*yy_c_buf_p = '\\0'; \\\n\t\tyyleng = n; \\\n\t\t} \\\n\twhile ( 0 )\n\n\n/* Internal utility routines. */\n\n#ifndef yytext_ptr\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_strncpy( char *s1, yyconst char *s2, int n )\n#else\nstatic void yy_flex_strncpy( s1, s2, n )\nchar *s1;\nyyconst char *s2;\nint n;\n#endif\n\t{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n\t}\n#endif\n\n#ifdef YY_NEED_STRLEN\n#ifdef YY_USE_PROTOS\nstatic int yy_flex_strlen( yyconst char *s )\n#else\nstatic int yy_flex_strlen( s )\nyyconst char *s;\n#endif\n\t{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n\t}\n#endif\n\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_alloc( yy_size_t size )\n#else\nstatic void *yy_flex_alloc( size )\nyy_size_t size;\n#endif\n\t{\n\treturn (void *) malloc( size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_realloc( void *ptr, yy_size_t size )\n#else\nstatic void *yy_flex_realloc( ptr, size )\nvoid *ptr;\nyy_size_t size;\n#endif\n\t{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_free( void *ptr )\n#else\nstatic void yy_flex_free( ptr )\nvoid *ptr;\n#endif\n\t{\n\tfree( ptr );\n\t}\n\n#if YY_MAIN\nint main()\n\t{\n\tyylex();\n\treturn 0;\n\t}\n#endif\n/* #line 1576 \"nidrgen.l\" */\n\n\n static void\ncantopen(char *what)\n{ fprintf(stderr, \"%s: cannot open \\\"%s\\\"\\n\", progname, what); }\n\n int\nyywrap(void)\n{\n\tif (tagin) {\n\t\tif (tagin != stdin)\n\t\t\tfclose(tagin);\n\t\ttagin = 0;\n\t\tLineno = 1;\n\t\tsaweof = 1;\n\t\tif (*specfile == '-' && !specfile[1]) {\n\t\t\tyyin = stdin;\n\t\t\tinfname = 0;\n\t\t\treturn 0;\n\t\t\t}\n\t\tif ((yyin = fopen(infname = specfile, \"r\")))\n\t\t\treturn 0;\n\t\tcantopen(specfile);\n\t\texit(1);\n\t\t}\n\treturn 1;\n\t}\n\n static void\nEat_comment(void)\n{\n\tint c;\n\n\tfor(;;) {\n\t\tc = input();\n c_check:\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within /* comment */\");\n\t\tif (c == '*') {\n\t\t\tc = input();\n\t\t\tif (c == '/')\n\t\t\t\treturn;\n\t\t\tgoto c_check;\n\t\t\t}\n\t\tif (c == '\\n')\n\t\t\t++Lineno;\n\t\t}\n\t}\n\n static void\nSaw_quote(void)\n{\n\tKWctx *kw, *kw1, *kw2;\n\tchar buf[1024];\n\tchar *b, *b0, *be, *lname;\n\tint c, c0;\n\tsize_t L, L0, L1;\n\tunsigned char *us;\n\n\tstatic char escname[32];\n\tstatic char hexdig[16] = \"0123456789abcdef\";\n\tstatic unsigned char esetup[] = \"\\aa\\bb\\ff\\nn\\rr\\tt\\vv\";\n\n\tif (!escname['\\a'])\n\t\tfor(us = esetup; *us; us += 2)\n\t\t\tescname[*us] = us[1];\t/* assuming ASCII */\n\tb0 = b = buf;\n\tL = sizeof(buf);\n\tbe = b + L - 3;\t/* allow room for /xhh */\n\tc0 = 0;\n\tsaweof = 0;\n\tfor(;;) {\n\t\tc = input();\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within quoted string\");\n\t\tif (b >= be) {\n\t\t\tL1 = b - b0;\n\t\t\tL0 = L;\n\t\t\tL <<= 1;\n\t\t\tbe = (char*)Malloc(L, \"Saw_quote\");\n\t\t\tmemcpy(be, b0, L1);\n\t\t\tif (b0 != buf)\n\t\t\t\tfree(b0);\n\t\t\tb0 = be;\n\t\t\tb = b0 + L1;\n\t\t\tbe = b0 + L - 3;\n\t\t\t}\n\t\tif (c < ' ') {\n\t\t\t*b++ = '\\\\';\n\t\t\tif (escname[c]) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\t++Lineno;\n\t\t\t\tc = escname[c];\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t*b++ = 'x';\n\t\t\t\t*b++ = '0' + (c >> 4);\n\t\t\t\tc = hexdig[c & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t*b++ = c;\n\t\tif (c0 == '\\\\')\n\t\t\tc0 = 0;\n\t\telse {\n\t\t\tc0 = c;\n\t\t\tif (c == '\"') {\n\t\t\t\twhile((c = input()) <= ' ') {\n\t\t\t\t\tif (c == EOF || !c) {\n\t\t\t\t\t\tc = ';';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (c == '\\n')\n\t\t\t\t\t\t++Lineno;\n\t\t\t\t\t}\n\t\t\t\tif (c == '\"' && !saweof) {\n\t\t\t\t\t--b;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tb[-1] = 0;\t/* replacing \" */\n\tif (lastseen == Saw_tag) {\n\t\tif (saweof) /* kludge around poor flex design */ {\n\t\t\ttagin = stdin;\n\t\t\tSaw_name(b0);\n\t\t\ttagin = 0;\n\t\t\t}\n\t\telse\n\t\t\tSaw_name(b0);\n\t\t}\n\telse {\n\t\tL = b - b0;\n\t\tbe = (char*)Alloc(L);\n\t\tmemcpy(be, b0, L);\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t  case Saw_dfltname:\n\t\t\tif ((lastkw1->kind & KWKind_Mask) != KWKind_Str)\n\t\t\t\tbotch(\"%s cannot have a string-valued := value\",\n\t\t\t\t\tlastkw1->names->val);\n\t\t\tlastkw1->cinit = be;\n\t\t\tif (lastdef)\n\t\t\t\tset_lastdef(b0, 1);\n\t\t\tbreak;\n\t\t  case Saw_desc:\n\t\t\tlastkw1->desc = be;\n\t\t\tbreak;\n\t\t  case Saw_dy:\n\t\t\tlastkw1->dylib = be;\n\t\t\tif (lastkw1->nfcn > 0)\n\t\t\t\tfuncbotch(lastkw1);\n\t\t\tif (libexpand) {\n\t\t\t\tkw = *KWtop;\n\t\t\t\tlastseen = Saw_kwname;\n\t\t\t\tif (kw == lastkw1)\n\t\t\t\t\tkw = *--KWtop;\n\t\t\t\telse if ((kw2 = kw->rparent))\n\t\t\t\t\tkw = kw2;\n\t\t\t\tkw1 = lastkw1;\n\t\t\t\tif ((kw2 = kw->kw) == kw1) {\n\t\t\t\t\tif ((kw2 = kw->kw = kw2->next)\n\t\t\t\t\t && kw2->alt == kw1->alt)\n\t\t\t\t\t\tBar();\n\t\t\t\t\telse  {\n\t\t\t\t\t\t--kw->alt;\n\t\t\t\t\t\tif (kw1->req)\n\t\t\t\t\t\t\t--kw->nreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tLpar();\n\t\t\t\tKeywd(kw1->name1);\n\t\t\t\tlname = kw1->dylib;\n\t\t\t\tif (lib_read(kw1,0))\n\t\t\t\t\tlastkw1->dylib = lname;\n\t\t\t\tRpar();\n\t\t\t\tif (kw1->parstate == PPar_leftpar)\n\t\t\t\t\t++KWtop;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t  case Saw_group:\n\t\t\tlastkw1->group = be;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tunexpected(\"string\");\n\t\t  }\n\t\t}\n\tif (b0 != buf)\n\t\tfree(b0);\n\tlastseen = Saw_type;\n\t}\n\n static int\nusage(int rc)\n{\n\tfprintf(rc ? stderr : stdout,\n\t\"Usage: %s [options] specfile [tagfile [defs_out [keywds_out]]]\\n\\\n\twhere the last two are output files, \\\".\\\" means \\\"omit\\\", and \\\"-\\\"\\n\\\n\tmeans write to stdout.  Missing trailing arguments are not read\\n\\\n\tor written, except that if all outputs are missing, \\\". -\\\" is assumed.\\n\\\n\tOptions may modify this behavior.\\noptions:\\n\\\n\t-D\t\t{ just write definitions to stdout }\\n\\\n\t-d\t\t{ suppress test for ambiguity from duplicate keywords }\\n\\\n\t-e\t\t{ expand ((...)) for debugging }\\n\\\n\t-f\t\t{ omit functions, i.e., {...} with -p; without -p,\\n\\\n\t\t\t  supply NULL function pointers }\\n\\\n\t-G\t\t{ for keywords with a TAG but not GROUP, do not assume\\n\\\n\t\t\t  that implictly GROUP == TAG }\\n\\\n\t-g\t\t{ write GuiKeyWord rather than KeyWord header;\\n\\\n\t\t\t  with -p, include GUI details: TAG, DESC, GROUP, LEN }\\n\\\n\t-h headername\t{ Specify header file(s), e.g., \\\"-h nidr.h\\\";\\n\\\n\t\t\t  several -h options can be given;\\n\\\n\t\t\t  default = -h- ==> no headers }\\n\\\n\t-j specsum\t{ write file specsum for use by \\\"dakreord specsum ...\\\"\\n\\\n\t\t\t  and \\\"dakreorder -j specsum ...\\\" }\\n\\\n\t-k keyname\t{ library mode with input containing several keywords\\n\\\n\t\t\t  to be contained in keyword keyname; implies -l and\\n\\\n\t\t\t  has no other effect if -D, -g, -j, -p, or -s is given.\\n\\\n\t\t\t  If -l is given without -k and several keywords appear\\n\\\n\t\t\t  in the input, assume \\\"-k KeywordTop\\\". }\\n\\\n\t-L libname\t{ obtain keyword details from library libname (compiled\\n\\\n\t\t\t  from source produced by an earlier \\\"nidrgen -l ...\\\"\\n\\\n\t\t\t  invocation); non-option arguments in this case are\\n\\\n\t\t\t  [defs_out [keywds_out]] }\\n\\\n\t-l\t\t{ library mode: with -D, -g, -j, -p, or -s, attempt to\\n\\\n\t\t\t  load libraries specified with \\\"DYNLIB libname\\\" and\\n\\\n\t\t\t  incorporate keyword specifications provided by the\\n\\\n\t\t\t  loaded libraries; otherwise generate source for\\n\\\n\t\t\t  compilation into a shared library for loading when a\\n\\\n\t\t\t  keyword marked with \\\"DYNLIB libname\\\" (in a separate\\n\\\n\t\t\t  run of nidrgen) is seen.  The library provides\\n\\\n\t\t\t  contained keywords and any needed final routine for\\n\\\n\t\t\t  the marked keyword. }\\n\\\n\t-m mtagfile\t{ just write to mtagfile tags not found in tagfile }\\n\\\n\t-n namespname\t{ assume namespace namespname;\\n\\\n\t\t\t  default = -n Dakota\\n\\\n\t\t\t  -n- ==> no namespace }\\n\\\n\t-p[w]\t\t{ pretty-print rather than produce KeyWord header;\\n\\\n\t\t\t  add w spaces (default 2) for each nested context. }\\n\\\n\t-s[w]\t\t{ like -p[w], but sort the keywords }\\n\\\n\t-T outtagfile\t{ write dummy tagfile to outtagfile (and quit) }\\n\\\n\t-t\t\t{ ignore TAG fields if tagfile is not given }\\n\\\n\t-w\t\t{ cancel warn mode: do not report (on stderr)\\n\\\n\t\t\t  the number of implicitly named start routines;\\n\\\n\t\t\t  still flag their names  with /*!!*/ }\\n\",\n\t\tprogname);\n\treturn rc;\n\t}\n\n static StrList *\nreverse(StrList **x)\n{\n\tStrList *s, *t, *u;\n\n\tif (!(s = *x) || !s->next)\n\t\treturn s;\n\tfor(t = 0; s; s = u) {\n\t\tu = s->next;\n\t\ts->next = t;\n\t\tt = s;\n\t\t}\n\treturn *x = t;\n\t}\n\n static int\nkwcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const KWctx**)a)->names->val, (*(const KWctx**)b)->names->val);\n\t}\n\n static KWctx *\nkwsort(KWctx *kw0)\n{\n\t/* Sort keywords after expanding kw list with aliases; compute nkw, */\n\t/* including aliases. */\n\n\tKWctx *kw, *kw1, *kw2, *kwm, **x, **x0, **xe, *x00[512];\n\tStrList *dname, *minname, *nam, **pmin, **pnam;\n\tchar *descsave, *groupsave;\n\tint agadj, nk;\n\tsize_t L, nkw, nkwa, onkwa;\n\n\treverse(&kw0->funcs);\n\tnkw = nkwa = 0;\n\tfor(kw = kw0->kw; kw; kw = kw->next) {\n\t\t++nkw;\n\t\tpmin = &kw->names;\n\t\tminname = *pmin;\n\t\tpnam = &minname->next;\n\t\tonkwa = nkwa;\n\t\twhile((nam = *pnam)) {\n\t\t\tdname = nam;\n\t\t\t++nkwa;\n\t\t\tif (strcmp(nam->val, minname->val) < 0) {\n\t\t\t\tpmin = pnam;\n\t\t\t\tminname = nam;\n\t\t\t\t}\n\t\t\tpnam = &nam->next;\n\t\t\t}\n\t\tagadj = 2*kw->agroup;\n\t\tkw->agroup = agadj + 1;\n\t\tif (nkwa > onkwa) {\n\t\t\t*pmin = minname->next;\n\t\t\tminname->next = kw->names;\n\t\t\tnam = kw->names = minname;\n\t\t\tnk = kw->kno;\t/* ALias() made room for nk use below */\n\t\t\tdescsave = kw->desc;\n\t\t\tgroupsave = kw->group;\n\t\t\tif (dname != minname) {\n\t\t\t\tkw->desc = kw->group = 0;\n\t\t\t\tkw->agroup = agadj;\n\t\t\t\t}\n\t\t\tkwm = kw;\n\t\t\tkw = kw2 = 0;\n\t\t\tif (nam->primary)\n\t\t\t\tkw2 = kwm;\n\t\t\twhile((nam = nam->next)) {\n\t\t\t\tkw1 = (KWctx*)Alloc(sizeof(KWctx));\n\t\t\t\tif (!kw)\n\t\t\t\t\tkw = kw1;\t/* so kw->next is right */\n\t\t\t\tkw1->next = kwm->next;\n\t\t\t\tkwm->next = kw1;\n\t\t\t\tkw1->names = nam;\n\t\t\t\tkw1->master = kwm;\n\t\t\t\tkw1->kind = kwm->kind;\n\t\t\t\tkw1->kno = ++nk;\n\t\t\t\tkw1->agroup = agadj;\n\t\t\t\tif (nam == dname) {\n\t\t\t\t\tkw1->desc = descsave;\n\t\t\t\t\tkw1->group = groupsave;\n\t\t\t\t\tkw1->agroup = agadj + 1;\n\t\t\t\t\t}\n\t\t\t\tif (nam->primary)\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t}\n\t\t\tif (kw2 != kwm && !guikeywds) {\n\t\t\t\tkw2->defname = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->len;\n\t\t\t\tkwm->len = 0;\n\t\t\t\tkw2->init = kwm->init;\n\t\t\t\tkwm->init = 0;\n\t\t\t\tkw2->cinit = kwm->cinit;\n\t\t\t\tkwm->cinit = 0;\n\t\t\t\tkw2->dylib = kwm->dylib;\n\t\t\t\t/* no need to change kwm->dylib */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwm;; kw1 = kw1->next) {\n\t\t\t\tif (kw1 != kw2)\n\t\t\t\t\tkw1->pmaster = kw2;\n\t\t\t\tif (kw1 == kw)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tkw0->nkw = (int)(nkw += nkwa);\n\tif (nkw <= 1)\n\t\treturn kw0->kw;\n\tx0 = x00;\n\tif (nkw > sizeof(x00)/sizeof(x00[0]))\n\t\tx0 = (KWctx**)Malloc(L = nkw*sizeof(KWctx*), \"kwsort\");\n\tfor(x = x0, kw = kw0->kw; kw; kw = kw->next)\n\t\t*x++ = kw;\n\tqsort(x0, nkw, sizeof(KWctx*), kwcomp);\n\tfor(xe = x - 1, x = x0; x < xe; ++x) {\n\t\tif (!strcmp(x[0]->names->val, x[1]->names->val)) {\n\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\tprogname, x[0]->names->val);\n\t\t\t++dupnames;\n\t\t\t}\n\t\tx[0]->next = x[1];\n\t\t}\n\tx[0]->next = 0;\n\tfor(x = x0, ++xe; x < xe; ++x)\n\t\t(*x)->paoff = x - x0;\n\tfor(x = x0; x < xe; ++x)\n\t\tif ((kw1 = (kw = *x)->pmaster))\n\t\t\tkw->paoff = kw1->paoff - kw->paoff;\n\tfor(x = x0; x < xe; ++x)\n\t\tif (!(kw = *x)->pmaster)\n\t\t\tkw->paoff = 0;\n\tkw0->kw = kw = x0[0];\n\tif (x0 != x00)\n\t\tfree(x0);\n\treturn kw;\n\t}\n\n static int\nalphanum(char *s)\n{\n\tfor(; *s; ++s)\n\t\tif (!isalnum(*s))\n\t\t\treturn 0;\n\treturn 1;\n\t}\n\n enum CommaState {\n\tCS_Comma = 0,\n\tCS_Clbra = 1,\n\tCS_rbraC = 2,\n\tCS_lrbrC = 3,\n\tCS_rbr2C = 4\n\t};\n\n static const char\n\t*Commasx[5] = { \",\", \",{\", \"},\", \",{},\",/*{{*/ \"}},\" },\n\t*Commas0[5] = { \",\", \",\", \",\", \",\", \",\" };\n static const char **Comma;\n\n typedef struct Zbuf Zbuf;\n struct\nZbuf {\n\tchar buf[80];\t/* overkill */\n\tchar *b;\n\tint nnz;\n\tenum CommaState cs;\n\t};\n\n static void\niput(int i, Zbuf *z)\n{\n\tchar *s;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (i == 0) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s%d\", t, i);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nnput(char *s, Zbuf *z)\n{\n\tchar *fmt, *s1;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s || (strtod(s,&s1) == 0. && !*s1)) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\t*s++ = '.';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tfmt = \"%s%s.\";\n\t\tfor(s1 = s; *s1; ++s1)\n\t\t\tswitch(*s1) {\n\t\t\t\tcase '.':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'E':\n\t\t\t\t\tfmt = \"%s%s\";\n\t\t\t\t\tgoto have_fmt;\n\t\t\t\t}\n have_fmt:\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(fmt, t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nsput(char *s, Zbuf *z)\n{\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s\\\"%s\\\"\", t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nzbclear(Zbuf *z)\n{\n\tif (z->b > z->buf) {\n\t\t*z->b = 0;\n\t\tprintf(\"%s\", z->b = z->buf);\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n typedef struct\nFCat { char *b, *b0, *be; } FCat;\n\n static char *\nfunc_cat(FCat *fc, StrList *f)\n{\n\tchar *b, *b1, *be;\n\tint k, n;\n\tsize_t L, L1, L2, L3;\n\n\tif (!f)\n\t\treturn 0;\n\tif (!f->next)\n\t\treturn f->val;\n\tb = fc->b;\n\tbe = fc->be;\n\tfor(n = k = 0; f; f = f->next, ++n) {\n\t\tL = L1 = strlen(f->val);\n\t\tif (n) {\n\t\t\t++L1;\n\t\t\tif (n & 1) {\n\t\t\t\tif (alphanum(f->val)) {\n\t\t\t\t\tk = 2;\n\t\t\t\t\tL1 += 7;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = 3;\n\t\t\t\t\tL1 += 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tk = 1;\n\t\t\t}\n\t\tif (L1 > be - b) {\n\t\t\tL2 = b - fc->b;\n\t\t\tL3 = 2*(be - fc->b + L1);\n\t\t\tb1 = (char*)Malloc(L3, \"func_cat\");\n\t\t\tif (L2)\n\t\t\t\tmemcpy(b1, fc->b, L2);\n\t\t\tif (fc->b != fc->b0)\n\t\t\t\tfree(fc->b);\n\t\t\tfc->b = b1;\n\t\t\tbe = fc->be = b1 + L3;\n\t\t\tb = b1 + L2;\n\t\t\t}\n\t\tswitch(k) {\n\t\t\tcase 0: break;\n\t\t\tcase 1: *b++ = ',';\n\t\t\t\tbreak;\n\t\t\tcase 2: memcpy(b, \",(void*)\", 8);\n\t\t\t\tb += 8;\n\t\t\t\tbreak;\n\t\t\tcase 3: memcpy(b, \",(void*)(\", 9);\n\t\t\t\tb += 9;\n\t\t\t}\n\t\tstrcpy(b, f->val);\n\t\tb += L;\n\t\tif (k == 3)\n\t\t\t*b++ = ')';\n\t\t*b = 0;\n\t\t}\n\treturn fc->b;\n\t}\n\n static void\nkwout(KWctx *kw, KWctx **kwtop, Uint xflag)\n{\n\tFCat fc;\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, **kws, **x, *x0[KWOUTlen0];\n\tStrList *S, *nam;\n\tZbuf z;\n\tchar fbuf[256], *funcs, *s;\n\tconst char *fmt, *ffmt;\n\tint aoff, k, i, m, m1, n, roff, sentinnel, skipfuncs;\n\n\tif (expand && !kw->names)\n\t\treturn;\n\tif (needcomma) {\n\t\tprintf(\",\\n\");\n\t\tneedcomma = 0;\n\t\t}\n\tkw1 = kw->kw;\n\tn = 0;\n\tfc.b = fc.b0 = fbuf;\n\tfc.be = fbuf + sizeof(fbuf);\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastkno + 1;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastkno + 1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tif (expand)\n\t\tfor(kw0 = kw1; kw0 && !kw0->names; kw0 = kw0->next)\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next)\n\t\t\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwout\");\n\tm = 0;\n\tkw0 = kw1;\n\tif (expand) {\n\t\taoff = kw->nalt;\n\t\troff = kw->nreq;\n\t\tfor(; kw0 && !kw0->names; kw0 = kw0->next) {\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next) {\n\t\t\t\tkw2->altoffset = aoff;\n\t\t\t\tkw2->reqoffset = roff;\n\t\t\t\tx[m++] = kw2;\n\t\t\t\t}\n\t\t\taoff += kw0->nalt;\n\t\t\troff += kw0->nreq;\n\t\t\t}\n\t\tkw->nalt = aoff;\n\t\tkw->nreq = roff;\n\t\t}\n\tfor(; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tsentinnel = 0;\n\tif (expand) {\n\t\tkw->nkw = m;\n\t\tqsort(x, m, sizeof(KWctx*), kwcomp);\n\t\tfor(i = 1; i < m; ++i)\n\t\t\tif (!strcmp(x[i-1]->names->val, x[i]->names->val)) {\n\t\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\t\tprogname, x[i]->names->val);\n\t\t\t\t++dupnames;\n\t\t\t\t}\n\t\t}\n\telse if (kw->nkw == 0)\n\t\tsentinnel = 1;\n\tm1 = m + sentinnel;\n\tprintf(\"\\tkw_%d[%d] = {\\n\" /*}*/, kw->kwkno = ++lastkno, m1);\n\tneedcomma = 1;\n\tz.nnz = 0;\n\tskipfuncs = !wantfuncs && !xflag;\n\tfor(i = 0; i < m;) {\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tif (!(kwp = kw1->pmaster))\n\t\t\tkwp = kw1;\n\t\tfputs(xflag ? \"\\t\\t{{\" : \"\\t\\t{\" /*}}}*/, stdout);\n\t\tz.b = z.buf;\n\t\tz.cs = CS_Comma;\n\t\tif ((nam = kw1->names)) {\n\t\t\tk = kwp->kind | kw1->names->primary | xflag;\n\t\t\tif (kwp->dylib)\n\t\t\t\tk |= KWKind_Dynlib;\n\t\t\tprintf(k < 16\n\t\t\t\t? \"\\\"%s\\\",%d\"\n\t\t\t\t: \"\\\"%s\\\",0x%x\", kw1->names->val, k);\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(kwm->alt + kwm->altoffset, &z);\n\t\t\tiput(kwm->req ? kwm->req + kwm->reqoffset : 0, &z);\n\t\t\t}\n\t\telse {\n\t\t\tif (xflag)\n\t\t\t\tprintf(\"0,0x%x\", xflag);\n\t\t\telse\n\t\t\t\tprintf(\"0,0\");\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(0, &z);\n\t\t\tiput(0, &z);\n\t\t\t}\n\t\tif (guikeywds)\n\t\t\tiput(kw1->agroup, &z);\n\t\tif ((n = kwm->kwkno)) {\n\t\t\tzbclear(&z);\n\t\t\tprintf(xflag ? \",(KeyWord*)kw_%d\": \",kw_%d\", n);\n\t\t\t}\n\t\telse\n\t\t\tiput(0, &z);\n\t\tnput(kwp->lb, &z);\n\t\tnput(kwp->ub, &z);\n\t\tffmt = /*{{{*/ !xflag ? \"}%s\" : \"}}%s\";\n\t\tif (guikeywds) {\n\t\t\tnput(kwm->init, &z);\n\t\t\tsput(kwm->cinit, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tif (!(s = kw1->group) && dfltgroup)\n\t\t\t\ts = kw1->tag;\n\t\t\tsput(s, &z);\n\t\t\tif (kwm->len)\n\t\t\t\tsput(kwm->len, &z);\n\t\t\tif (kwm->dylib)\n\t\t\t\tsput(kwm->dylib, &z);\n\t\t\tgoto nofuncs;\n\t\t\t}\n\t\tiput(kw1->paoff, &z);\n\t\tif (skipfuncs && !kwp->dylib)\n\t\t\tgoto nofuncs;\n\t\tz.nnz = 0;\n\t\tfuncs = 0;\n\t\tif (kwp->dylib) {\n\t\t\tz.cs = CS_Clbra;\n\t\t\tfor(n = 0; n < 3; ++n)\n\t\t\t\tiput(0,&z);\n\t\t\tzbclear(&z);\n\t\t\tprintf(\",(void*)\\\"%s\\\"\", kwp->dylib);\n\t\t\tz.cs = CS_rbr2C;\n\t\t\tz.nnz = 0;\n\t\t\t}\n\t\telse if ((S = kwp->funcs)) {\n\t\t\tif (!S->next && !strcmp(S->val,\"0\"))\n\t\t\t\tgoto xcheck;\n\t\t\tif (!kwp->kw && S->needrev)\n\t\t\t\tS = reverse(&kwp->funcs);\n\t\t\tfuncs = func_cat(&fc, S);\n\t\t\tgoto funcput;\n\t\t\t}\n\t\telse if ((S = kwm->funcs)) {\n\t\t\tfuncs = func_cat(&fc, S);\n funcput:\n\t\t\tz.cs = CS_lrbrC;\n\t\t\tif (funcs && wantfuncs & 1) {\n\t\t\t\tzbclear(&z);\n\t\t\t\tprintf(\",%s\", funcs);\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tiput(0,&z);\n\t\t\t}\n\t\telse if (kwm->names && wantfuncs & 1 && !(kwm->kind & KWKind_Libname)) {\n\t\t\t++missing;\n\t\t\tprintf(\",/*!!*/\");\n\t\t\tfor(kws = KWStack; ++kws <= kwtop; ) {\n\t\t\t\tif (!(kw2 = *kws)->names)\n\t\t\t\t\tkw2 = kw2->rparent;\n\t\t\t\tprintf(\"%s_\", kw2->names->val);\n\t\t\t\t}\n\t\t\tprintf(\"%s_start\", kwm->names->val);\n\t\t\t}\n xcheck:\n\t\tif (xflag) {\n\t\t\tif (z.nnz) {\n\t\t\t\tz.cs = z.cs == CS_rbraC ? CS_rbr2C : CS_rbraC;\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\t\tz.nnz = 0;\n\t\t\t\t}\n\t\t\telse if (z.cs == CS_rbr2C)\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\telse {\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\tffmt = /*{{*/ \"}}%s\";\n\t\t\t\t}\n\t\t\tz.b = z.buf;\n\t\t\tiput(nam ? nam->seqno : 0, &z);\n\t\t\tiput(kw1->agroup, &z);\n\t\t\tsput(funcs, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tsput(kw1->group, &z);\n\t\t\tsput(kw1->defname, &z);\n\t\t\tsput(kw1->len, &z);\n\t\t\tsput(kw1->init, &z);\n\t\t\tsput(kw1->cinit, &z);\n\t\t\tif (z.nnz)\n\t\t\t\tffmt = /*{*/ \"}%s\";\n\t\t\t}\n nofuncs:\n\t\tprintf(ffmt, i < m1 ? \",\\n\" : \"\\n\");\n\t\t}\n\tif (sentinnel)\n\t\tfputs(\"\\t\\t{\\\"\\\"}\\n\", stdout);\n\tprintf(/*{*/\"\\t\\t}\");\n\tif (x != x0)\n\t\tfree(x);\n\tif (fc.b != fbuf)\n\t\tfree(fc.b);\n\t}\n\n static void\nhashclear(KWctx *kw)\n{\n\tStrList *sl;\n\n\tkw->parstate = Dupchecked;\n\tfor(kw = kw->kw; kw; kw = kw->next)\n\t\tfor(sl = kw->names; sl; sl = sl->next) {\n\t\t\tsl->h.hnext->hprev = sl->h.hprev;\n\t\t\tsl->h.hprev->hnext = sl->h.hnext;\n\t\t\tsl->h.hprev = sl->h.hnext = 0;\n\t\t\t}\n\t}\n\n static void\ndupfound(HashHead *h0, StrList *sl, StrList *sl1)\n{\n\tStrList *sl2, *sl3;\n\n\t++dupnames;\n\tfor(sl2 = sl1; sl2->h.hnext != h0; sl2 = sl3) {\n\t\tsl3 = (StrList*)sl2->h.hnext;\n\t\tif (strcmp(sl->val, sl3->val))\n\t\t\tbreak;\n\t\t}\n\tfprintf(stderr, \"Warning: \\\"%s\\\" on line %d also appears on line%s %d\",\n\t\tsl->val, sl->Lineno, \"s\" + (sl2 == sl1), sl1->Lineno);\n\twhile(sl1 != sl2) {\n\t\tsl1 = (StrList*)sl1->h.hnext;\n\t\tfprintf(stderr, \", %d\", sl1->Lineno);\n\t\t}\n\tfputs(\".\\n\", stderr);\n\t}\n\n static KWctx **\nhashadd(KWctx *kw, KWctx **kwtop)\n{\n\tHashHead *h, *h0;\n\tKWctx *kw1;\n\tStrList *sl, *sl1;\n\tchar *s;\n\tint n;\n\tunsigned int c, x;\n\n\tkw->parstate = Dupchecking;\n\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\tfor(sl = kw1->names; sl; sl = sl->next) {\n\t\t\tx = 0;\n\t\t\ts = sl->val;\n\t\t\twhile((c = *(unsigned char*)s++))\n\t\t\t\tx = 43*x + c - ' ';\n\t\t\th0 = &HTab[x % HTlen];\n\t\t\tfor(h = h0->hnext; h != h0; h = h->hnext) {\n\t\t\t\tsl1 = (StrList*)h;\n\t\t\t\tn = strcmp(sl->val, sl1->val);\n\t\t\t\tif (n <= 0) {\n\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\tdupfound(h0,sl,sl1);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsl->h.hnext = h;\n\t\t\th->hprev = (sl->h.hprev = h->hprev)->hnext = (HashHead *)sl;\n\t\t\t}\n\tif ((kw1 = kw->kw))\n\t\t*++kwtop = kw1;\n\treturn kwtop;\n\t}\n\n static void\ndup_check(void)\n{\n\tHashHead *h, *he;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tfor(h = HTab, he = h + HTlen; h < he; ++h)\n\t\th->hnext = h->hprev = h;\n\tplist = 0;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;) {\n\t\tkw = *kwtop;\n\t\tlev = kw->level;\n\t\twhile(plist && plist->level >= lev) {\n\t\t\thashclear(plist);\n\t\t\tplist = plist->next;\n\t\t\t}\n\t\tif (kw->parstate == Dupchecking) {\n\t\t\thashclear(kw);\n\t\t\tif ((*kwtop = kw->next))\n\t\t\t\tcontinue;\n\t\t\tif (kwtop <= kwbot)\n\t\t\t\tbreak;\n\t\t\t--kwtop;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif ((kw1 = kw->pparent) && kw1->parstate != Dupchecking) {\n\t\t\tfor(kw2 = kw1; plist && kw2; plist = plist->next) {\n\t\t\t\twhile(kw2->level > plist->level && (kw2 = kw2->pparent));\n\t\t\t\tif (kw2 != plist)\n\t\t\t\t\tbreak;\n\t\t\t\thashclear(plist);\n\t\t\t\t}\n\t\t\tkw2 = 0;\n\t\t\tdo {\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tkw1->next = kw2;\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Dupchecking);\n\t\t\twhile(kw2) {\n\t\t\t\tkwtop = hashadd(kw2, kwtop);\n\t\t\t\tkw1 = kw2;\n\t\t\t\tkw2 = kw2->next;\n\t\t\t\tkw1->next = plist;\n\t\t\t\tplist = kw1;\n\t\t\t\t}\n\t\t\t}\n\t\tkwtop = hashadd(kw, kwtop);\n\t\t}\n\t}\n\n static void\nprkwname(KWctx *kw, const char *suf, int needrev)\n{\n\tint k;\n\tStrList *S;\n\tstatic const char *kname[] = { \"BUG\", \"INTEGER\", \"REAL\", \"STRING\" };\n\n\tif (needrev)\n\t\treverse(&kw->names);\n\tS = kw->names;\n\tprintf(\"%s\", S->val);\n\twhile((S = S->next))\n\t\tprintf(\" ALIAS %s\", S->val);\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tprintf(\" %s\", kname[k]);\n\t\tif (kw->kind & KWKind_List)\n\t\t\tprintf(\"LIST\");\n\t\t}\n\tif (kw->lb)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictLb ? \">\" : \">=\", kw->lb);\n\tif (kw->ub)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictUb ? \"<\" : \"<=\", kw->ub);\n\tif (kw->defname && wantfuncs & 1) {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s %s\", kw->defname, kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := %s \\\"%s\\\"\", kw->defname, kw->cinit);\n\t\t}\n\telse {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s\", kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := \\\"%s\\\"\", kw->cinit);\n\t\t}\n\tif (!(wantfuncs&1))\n\t\tgoto sufchk;\n\tif (kw->tag)\n\t\tprintf(ignoretags ? \" TAG \\\"%s\\\"\" : \" /*TAG \\\"%s\\\"*/\", kw->tag);\n\tif (kw->funcs) {\n\t\tfputs(\" {\", stdout);\n\t\treverse(&kw->funcs);\n\t\tfor(S = kw->funcs;;) {\n\t\t\tfputs(S->val, stdout);\n\t\t\tif (!(S = S->next))\n\t\t\t\tbreak;\n\t\t\tputchar(',');\n\t\t\t}\n\t\tputchar('}');\n\t\t}\n\tif (kw->len)\n\t\tprintf(\" LEN %s\", kw->len);\n\tif (kw->group)\n\t\tprintf(\" GROUP \\\"%s\\\"\", kw->group);\n\tif (kw->desc)\n\t\tprintf(\" DESC \\\"%s\\\"\", kw->desc);\n sufchk:\n\tif (kw->dylib)\n\t\tprintf(\" DYNLIB \\\"%s\\\"\", kw->dylib);\n\tif (suf)\n\t\tfputs(suf, stdout);\n\tif (needrev == 2)\n\t\treverse(&kw->names);\n\t}\n\n static KWctx *\nkwrev(KWctx **pkw)\n{\n\tKWctx *kw, *kw0, *kw1;\n\tkw1 = *pkw;\n\tfor(kw0 = 0; (kw = kw1); kw0 = kw) {\n\t\tkw1 = kw->next;\n\t\tkw->next = kw0;\n\t\t}\n\treturn *pkw = kw0;\n\t}\n\n static int\nStrListcmp(StrList *sl1, StrList *sl2)\n{\n\tif (sl1 == sl2)\n\t\treturn 0;\n\twhile(sl1) {\n\t\tif (!sl2 || strcmp(sl1->val, sl2->val))\n\t\t\treturn 1;\n\t\tsl1 = sl1->next;\n\t\tsl2 = sl2->next;\n\t\t}\n\treturn sl2 != 0;\n\t}\n\n#if 0\t/* Could hash keywords and use the following samekw to find duplicate  */\n\t/* contained keywords, noting duplicates when found in a new, normally */\n\t/* NULL pointer in KWctx, but so far this does not appear worthwhile.  */\n#define OffsetOf(T,f) ((char*)&((T*)0)->f - (char*)0)\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n#define ValueOf(T,x,o) (*(T*)((char*)x + o))\n\n static int\nsamekw(KWctx *kw1, KWctx *kw2)\n{\n\tchar *s1, *s2;\n\tsize_t *sp, *spe;\n\n\tstatic size_t\n\t\tIntoff[] = {\n\t\t\tOffsetOf(KWctx,alt),\n\t\t\tOffsetOf(KWctx,kind),\n\t\t\tOffsetOf(KWctx,nalt),\n\t\t\tOffsetOf(KWctx,nkw),\n\t\t\tOffsetOf(KWctx,nreq),\n\t\t\tOffsetOf(KWctx,req)\n\t\t\t},\n\t\tStroff[] = {\n\t\t\tOffsetOf(KWctx,lb),\n\t\t\tOffsetOf(KWctx,ub),\n\t\t\tOffsetOf(KWctx,init),\n\t\t\tOffsetOf(KWctx,cinit),\n\t\t\tOffsetOf(KWctx,defname),\n\t\t\tOffsetOf(KWctx,desc),\n\t\t\tOffsetOf(KWctx,dylib),\n\t\t\tOffsetOf(KWctx,group),\n\t\t\tOffsetOf(KWctx,len)\n\t\t\t};\n\twhile(kw1) {\n\t\tif (!kw2)\n\t\t\treturn 0;\n\t\tif (kw1->pparent != kw2->pparent\n\t\t || kw1->rparent != kw2->rparent)\n\t\t\treturn 0;\n\t\tif (StrListcmp(kw1->names, kw2->names)\n\t\t || StrListcmp(kw1->funcs, kw2->funcs))\n\t\t\treturn 0;\n\t\tfor(sp = Intoff, spe = sp + NumberOf(Intoff); sp < spe; ++sp)\n\t\t\tif (ValueOf(int,kw1,*sp) != ValueOf(int,kw2,*sp))\n\t\t\t\treturn 0;\n\t\tfor(sp = Stroff, spe = sp + NumberOf(Stroff); sp < spe; ++sp) {\n\t\t\ts1 = ValueOf(char*,kw1,*sp);\n\t\t\ts2 = ValueOf(char*,kw2,*sp);\n\t\t\tif (s1 != s2 && (!s1 || !s2 || strcmp(s1,s2)))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tkw1 = kw1->next;\n\t\tkw2 = kw2->next;\n\t\t}\n\treturn kw2 == 0;\n\t}\n#undef ValueOf\n#undef NumberOf\n#undef OffsetOf\n#endif\n\n static void\nparadj(int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, **kwp, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (needrev)\n\t\tkwrev(kwtop);\n\n\t/* remove extra parens */\n\n\tfor(;; --kwtop) {\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n top:\n\t\t\tif (needrev && (kw1 = kw->kw) && kw1->next)\n\t\t\t\tkwrev(&kw->kw);\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Parchecked) {\n\t\t\t\tkwp = &kw->pparent;\n\t\t\t\tplist = kw;\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif (kw1->kw) {\n\t\t\t\t\t\t*kwtop++ = kw1;\n\t\t\t\t\t\tkw1->parstate = Parchecked;\n\t\t\t\t\t\t*kwp = kw1;\n\t\t\t\t\t\tkwp = &kw1->pparent;\n\t\t\t\t\t\tkw1->next = plist;\n\t\t\t\t\t\tplist = kw1;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!(*kwp = kw1->pparent)) {\n\t\t\t\t\t\tlev = kw1->level;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw1 = *kwp;\n\t\t\t\t\tif (kw1->parstate == Parchecked) {\n\t\t\t\t\t\tlev = kw1->level + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tfor(;; plist = kw1) {\n\t\t\t\t\tplist->level = lev++;\n\t\t\t\t\tif (plist == kw)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tkw1 = plist->next;\n\t\t\t\t\tplist->next = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = kw->kw;\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static KWctx *\nmasteradj(KWctx *kw)\n{\n\t/* to help print (nm1 | nm2 foo goo), make nm2 \"master\" */\n\tKWctx *kw1, *kw2, *kw3, *kwm, *rv;\n\n\tfor(kw1 = kw, kw3 = 0; kw1; kw1 = kw1->next) {\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn kw;\n\tfor(rv = kw; kw; kw = kw->next) {\n\t\tkwm = kw->master;\n\t\tif ((kw1 = kw->next) && kw1->master == kwm && kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in masteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->next) && kw1->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tkw = kw2;\n\t\t\t}\n\t\t}\n\treturn rv;\n\t}\n\n static void\nxmasteradj(KWctx **x, int n)\n{\n\t/* variant of masteradj for pretty_ex1 */\n\tKWctx *kw, *kw1, *kw2, *kw3, *kwm;\n\tint i, j;\n\n\tfor(i = 0, kw3 = 0; i < n; ++i) {\n\t\tkw1 = x[i];\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn;\n\tfor(i = 0; i < n; i = j) {\n\t\tj = i + 1;\n\t\tkw = x[i];\n\t\tkwm = kw->master;\n\t\tif (j < n && kwm && (kw1 = x[j])->master == kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in xmasteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(++j < n && (kw1 = x[j])->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = x[++i]) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;; kw = x[++i]) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n static void\ndo_indent(int indent)\n{\n\tfor(indent += 8; indent >= 8; indent -= 8)\n\t\tputchar('\\t');\n\tfor(; indent > 0; --indent)\n\t\tputchar(' ');\n\t}\n\n static void\ndo_indent1(int indent)\t/* write indent-1 spaces */\n{\n\twhile(--indent > 0)\n\t\tputchar(' ');\n\t}\n\n static const char *KEYKIND[4] = { \"KEYWORD \", \"KEYWORD01 \", \"KEYWORD1 \", \"KEYWORD12 \" };\n\n static void\npretty_print(int iinc, int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, *kw3, **kwtop, **kwbot, *plist;\n\tconst char *s;\n\tint alt, indent, lev, needindent, needspace;\n\n\tkwtop = kwbot = KWStack;\n\tindent = 0;\n\tplist = 0;\n\tneedindent = 1;\n\tfor(kw1 = KWbase.kw; kw1;) {\n\t\tfputs(KEYKIND[(kw1->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw1, \"\\n\", needrev);\n\t\t*kwtop = masteradj(kw1->kw);\n\t\talt = 0;\n\t\tfor(;;--kwtop) {\n\t top:\n\t\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\t\tlev = kw->level;\n\t\t\t\tif (needindent) {\n\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\tneedindent = 0;\n\t\t\t\t\t}\n\t\t\t\tif (plist\n\t\t\t\t && (plist->level > lev\n\t\t\t\t  || (plist->level == lev && plist != kw->pparent))) {\n finishpar:\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = plist;\n\t\t\t\t\t*++kwtop = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Printing) {\n\t\t\t\t\ts = !kw->names || /*[(*/kw->req ? \")\\n\" : \"]\\n\";\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\ts = /*(*/ \")\\n\";\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tfputs(s, stdout);\n\t\t\t\t\tneedindent = 1;\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tindent -= iinc;\n\t\t\t\t\tif (!kw->names) {\n\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\tgoto bot;\n\t\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (plist)\n\t\t\t\t\tfor (kw2 = kw->pparent;\n\t\t\t\t\t\t\tkw2 && kw2->parstate != Printing;\n\t\t\t\t\t\t\tkw2 = kw2->pparent) {\n\t\t\t\t\t\tif (plist->level >= kw2->level)\n\t\t\t\t\t\t\tgoto finishpar;\n\t\t\t\t\t\t}\n\t\t\t\tneedindent = 1;\n\t\t\t\tneedspace = 0;\n\t\t\t\tif (alt == kw->alt) {\n\t\t\t\t\tputchar('|');\n\t\t\t\t\tneedspace = 1;\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->pparent) && kw2->parstate != Printing) {\n\t\t\t\t\tkw3 = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (kw2->parstate == Printing)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (kw2->kw) {\n\t\t\t\t\t\t\tkw2->next = kw3;\n\t\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t\tkw2->parstate = Printing;\n\t\t\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\t\t\tneedspace = 0;\n\t\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t\tputchar('('); /*)*/\n\t\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((kw2 = kw2->pparent));\n\t\t\t\t\twhile(kw3) {\n\t\t\t\t\t\tkw2 = kw3->next;\n\t\t\t\t\t\tkw3->next = plist;\n\t\t\t\t\t\tplist = kw3;\n\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->master) && kw == kw2)\n\t\t\t\t\tkw2 = 0;\n\t\t\t\tif (!kw->kw && (!kw2 || kw2->parstate == Leftput)) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t\tif (!kw->req) {\n\t\t\t\t\t\tif (alt != kw->alt) {\n\t\t\t\t\t\t\tfputs(\"[ \", stdout);\n\t\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\ts = /*[*/ \" ]\\n\";\n\t\t\t\t\t\tif ((kw2 = kw->next) && kw2->alt == alt)\n\t\t\t\t\t\t\ts = \"\\n\";\n\t\t\t\t\t\tprkwname(kw, s, needrev);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Leftput) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tgoto putspace;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\tputchar(kw->req ? '(' : '['); /*])*/\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\tputchar('('/*)*/);\n\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tindent += iinc;\n putspace:\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t}\n\t\t\t\tkw->parstate = Printing;\n\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\tif (kw2) {\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tkw2->parstate = Leftput;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\talt = 0;\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = masteradj(kw->kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n bot:\n\t\t\tif (kwtop == kwbot) {\n\t\t\t\tif (plist) {\n\t\t\t\t\t*kwtop++ = plist;\n\t\t\t\t\t*kwtop++ = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (indent) {\n\t\t\t\t\t\tif (needindent)\n\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\tfputs(/*(*/\")\\n\", stdout);\n\t\t\t\t\t\tneedindent = 1;\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (!(kw1 = kw1->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static void\nnslist(StrList *h, const char *fmt)\n{\n\tfor(; h; h = h->next)\n\t\tprintf(fmt, h->val);\n\t}\n\n static void\nOutput(StrList *headers, StrList *nsname, int hwant, const char *kname, int libmode, int nwant)\n{\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tStrList *h;\n\tUint xflag;\n\tconst char *fmt;\n\tint kwkno;\n\tstatic char\n\t\tlibfmt1[] = \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n\"\n\t\t\t\"KeyWord *keyword_add(void);\\n}\\n#endif\\n\\n\"\n\t\t\t\" KeyWord*\\nkeyword_add(void) {\\n\\t\",\n\t\tlibfmt2[] = \"kw_%d[0].kw;\\n\\t}\\n\",\n\t\tlibfmt3[] = /*{*/ \"kw_%d.kw;\\n\\t}\\n\";\n\n\tif (hwant && headers) {\n\t\tfor(h = reverse(&headers); h; h = h->next)\n\t\t\tprintf(*h->val == '<' /*>*/\n\t\t\t\t? \"#include %s\\n\"\n\t\t\t\t: \"#include \\\"%s\\\"\\n\", h->val);\n\t\t}\n\tif (nwant) {\n\t\tif (nsname)\n\t\t\treverse(&nsname);\n\t\telse\n\t\t\tnsname = new_StrList(\"Dakota\", nsname);\n\t\tputchar('\\n');\n\t\tnslist(nsname, \"namespace %s {\\n\" /*}*/);\n\t\t}\n\tprintf(\"\\n/** %d distinct keywords (plus %d aliases) **/\\n\\nstatic %sKeyWord%s\\n\",\n\t\tlastagroup, nalias, guikeywds ? \"Gui\" : \"\", libmode ? \"x\" : \"\");\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (libmode) {\n\t\txflag = KWKind_Extended;\n\t\tComma = Commasx;\n\t\t}\n\telse {\n\t\txflag = 0;\n\t\tComma = Commas0;\n\t\t}\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwout(kw, kwtop, xflag);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tprintf(\";\\n\\n\");\n\tif (nwant) {\n\t\tnslist(reverse(&nsname), /*{*/\"} // namespace %s\\n\");\n\t\tputchar('\\n');\n\t\treverse(&nsname);\n\t\t}\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"extern \\\"C\\\" {\\n\");\n\tprintf(\"#endif\\n\");\n\n\tkwkno = KWbase.kwkno;\n\tif (libmode) {\n\t\tif (KWbase.nkw > 1 && !kname)\n\t\t\tkname = \"KeywordTop\";\n\t\tprintf(libfmt1);\n\t\tfmt = libfmt2;\n\t\tif (kname) {\n\t\t\tprintf(\"static KeyWordx kw_%d = { \\\"%s\\\", 0x%x,%d,%d,%d,(KeyWord*)\",\n\t\t\t\tkwkno + 1, kname, KWKind_Dynmult, KWbase.nkw,\n\t\t\t\tKWbase.alt, KWbase.req);\n\t\t\tif (nwant) {\n\t\t\t\tnslist(nsname, \"%s::\");\n\t\t\t\tnwant = 0;\n\t\t\t\t}\n\t\t\tprintf(\"kw_%d };\\n\\t\", kwkno++);\n\t\t\tfmt = libfmt3;\n\t\t\t}\n\t\tprintf(\"return &\");\n\t\t}\n\telse {\n\t\tprintf(\"KeyWord Dakota_Keyword_Top = {\\\"KeywordTop\\\",0,%d,%d,%d,\",\n\t\t\tKWbase.nkw, KWbase.alt, KWbase.req);\n\t\tfmt = \"kw_%d};\\n\";\n\t\t}\n\tif (nwant)\n\t\tnslist(nsname, \"%s::\");\n\tprintf(fmt, kwkno);\n\n        printf(\"#ifdef __cplusplus\\n\");\n        printf(\"}\\n\");\n        printf(\"#endif\\n\");\n\n\tif (startwarn && missing && !guikeywds)\n\t\tfprintf(stderr, \"%s: %d start routines implicitly named.\\n\",\n\t\t\tprogname, missing);\n\t}\n\n typedef struct Valhash Valhash;\n\n struct\nValhash {\n\tDefhashHead hh;\n\tUint n;\n\tValhash *thread;\n\t};\n\n static Kwpack *kwpack, *kwpack0, *kwpacke;\n static size_t kwpack_len, strtab_len = 1;\n static DefhashTab FpTab, StrTab;\n static Valhash *FpTabLast, *StrTabLast;\n\n static Uint\nNumOff(char *name)\n{\n\tValhash *v;\n\tif (!name || !*name || (*name == '0' && !name[1]))\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &FpTab, 1);\n\tif (!v->n) {\n\t\tv->n = FpTab.nent;\n\t\tv->thread = FpTabLast;\n\t\tFpTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static Uint\nStrOff(char *name)\n{\n\tValhash *v;\n\tif (!name)\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &StrTab, 1);\n\tif (!v->n) {\n\t\tv->n = strtab_len;\n\t\tstrtab_len += strlen(name) + 1;\n\t\tv->thread = StrTabLast;\n\t\tStrTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static void\nkwjout(KWctx *kw, KWctx **kwtop)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, **x, *x0[KWOUTlen0];\n\tKwpack *p;\n\tUint lastknoj;\n\tint i, m, n;\n\tsize_t L;\n\n\tkw1 = kw->kw;\n\tn = 0;\n\tlastknoj = kwpack - kwpack0 + 1;\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastknoj;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastknoj;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwjout\");\n\tm = 0;\n\tfor(kw0 = kw1; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tkw->kwkno = lastknoj;\n\t++lastkno;\n\tfor(i = 0; i < m;) {\n\t\tif (++kwpack >= kwpacke) {\n\t\t\tL = 2*kwpack_len;\n\t\t\tkwpack0 = (Kwpack*)Realloc(kwpack0, L*sizeof(Kwpack), \"kwjout\");\n\t\t\tkwpacke = kwpack0 + L;\n\t\t\tkwpack = kwpack0 + kwpack_len;\n\t\t\tmemset(kwpack, 0, kwpack_len*sizeof(Kwpack));\n\t\t\tkwpack_len = L;\n\t\t\t}\n\t\tp = kwpack;\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tp->nkw = kwm->nkw;\n\t\tif (kw1->names) {\n\t\t\tp->name = StrOff(kw1->names->val);\n\t\t\tp->kind = kw1->kind | kw1->names->primary;\n\t\t\tp->alt = kwm->alt + kwm->altoffset;\n\t\t\tif (kwm->req)\n\t\t\t\tp->req = kwm->req + kwm->reqoffset;\n\t\t\tif (kwm->dylib) {\n\t\t\t\tp->dylib = StrOff(kwm->dylib);\n\t\t\t\tp->kind |= KWKind_Dynlib;\n\t\t\t\t}\n\t\t\t}\n\t\tp->kw = kwm->kwkno;\n\t\tp->Lb = NumOff(kw1->lb);\n\t\tp->Ub = NumOff(kw1->ub);\n\t\tp->poff = kw1->paoff;\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static Valhash *\nVreverse(Valhash *sh)\n{\n\tValhash *sh0, *sh1;\n\tfor(sh0 = 0; sh; sh = sh1) {\n\t\tsh1 = sh->thread;\n\t\tsh->thread = sh0;\n\t\tsh0 = sh;\n\t\t}\n\treturn sh0;\n\t}\n\n static void\nkwpack_adjust(Kwpack *kp, Uint nkw)\n{\n\tKwpack0 *qp, *qpe;\n\n\tqp = (Kwpack0*)kp;\n\tfor(qpe = qp + nkw; qp < qpe; ++kp, ++qp) {\n\t\tmemcpy(qp, kp, sizeof(Kwpack0) - sizeof(int));\n\t\tqp->poff = kp->poff;\n\t\t}\n\t}\n\n static void\njOutput(char *jfname)\n{\n\tFILE *f;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tKwpack *kp;\n\tUint nkw0;\n\tValhash *vh;\n\tdouble d;\n\tsize_t L, Lkw, Ls;\n\tstatic KwpHead head = { \"DakreorderKwds\\n\", 1e13, 0x1234abcd };\n\tstatic double zbuf[2];\n\n\tFpTab.nalloc  = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tStrTab.nalloc = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tkwpack_len = 128;\n\tkwpack = kwpack0 = (Kwpack*)Malloc(kwpack_len * sizeof(Kwpack), \"jOutput\");\n\tmemset(kwpack, 0, kwpack_len * sizeof(Kwpack));\n\tkwpacke = kwpack0 + kwpack_len;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwjout(kw, kwtop);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tStrTabLast = Vreverse(StrTabLast);\n\tFpTabLast = Vreverse(FpTabLast);\n\tnkw0 = kwpack - kwpack0;\n\thead.nkw = nkw0 + 1;\n\tkp = kwpack0;\n\tkp->kw = nkw0 - KWbase.nkw + 1;\n\tkp->nkw = KWbase.nkw;\n\tkp->alt = KWbase.alt;\n\tkp->req = KWbase.req;\n\thead.strtab_offset = (FpTab.nent+1)*sizeof(double);\n\tLs = (strtab_len + 7) & ~7;\n\thead.kw_offset = head.strtab_offset + Ls;\n\tif ((head.pad = dynlibseen))\n\t\tLkw = sizeof(Kwpack);\n\telse {\n\t\tLkw = sizeof(Kwpack0);\n\t\tkwpack_adjust(kp, head.nkw);\n\t\t}\n\thead.end_offset = head.kw_offset + head.nkw * Lkw;\n\tf = fopen(jfname, \"wb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open \\\"%s\\\"\\n\", jfname);\n\t\texit(1);\n\t\t}\n\tfwrite(&head, sizeof(head), 1, f);\n\tfor(vh = FpTabLast; vh; vh = vh->thread) {\n\t\td = strtod(vh->hh.name,0);\n\t\tfwrite(&d, sizeof(double), 1, f);\n\t\t}\n\tfwrite(&zbuf,9,1,f);\n\tfor(vh = StrTabLast; vh; vh = vh->thread)\n\t\tfwrite(vh->hh.name, strlen(vh->hh.name) + 1, 1, f);\n\tif ((L = Ls - strtab_len))\n\t\tfwrite(&zbuf, L, 1, f);\t/* align */\n\tfwrite(kp, Lkw, head.nkw, f);\n\tfclose(f);\n\t}\n\n typedef int (*KWcomp)(const void*, const void*);\n\n static const char **zalt;\n\n static int\nkwcomp1(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static int\nkwcomp2(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb, *pa, *pb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tpa = ka->master ? ka->master->pparent : ka->pparent;\n\t\tpb = kb->master ? kb->master->pparent : kb->pparent;\n\t\tif (pa != pb)\n\t\t\treturn ka->objno - kb->objno;\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static void\ndo_sort(KWctx *kw, KWcomp KWcmp)\n{\n\tKWctx *kw1, *kwm, **x, *x0[KWPlen];\n\tconst char *z0[KWPlen];\n\tint i, n, na;\n\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\t++n;\n\t\treverse(&kw1->names);\n\t\t}\n\tif (n <= 1)\n\t\treturn;\n\tx = n > KWPlen ? (KWctx**)Malloc(n*sizeof(KWctx*), \"do_sort\") : x0;\n\tna = kw->nalt + 1;\n\tzalt = na <= KWPlen ? z0 : (const char**)Malloc(na*sizeof(const char*), \"do_sort\");\n\tmemset(zalt, 0, na*sizeof(const char*));\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\tx[n++] = kw1;\n\t\tif ((kwm = kw1->master))\n\t\t\tkwm->master = kwm;\n\t\tif (!zalt[i = kw1->alt]\n\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\tzalt[i] = kw1->names->val;\n\t\t}\n\tqsort(x, n--, sizeof(KWctx*), KWcmp);\n\tfor(i = 0; i < n; ++i)\n\t\tx[i]->next = x[i+1];\n\tx[n]->next = 0;\n\tkw->kw = x[0];\n\tif (zalt != z0)\n\t\tfree(zalt);\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nksort(KWcomp KWcmp)\n{\n\tKWctx *kw, *kw1, **kwtop, **kwtop0, **kwbot;\n\n\tkwtop = kwbot = KWStack;\n\n\tfor(*kwtop = &KWbase;; --kwtop) {\n top:\n\t\tkw = *kwtop;\n top1:\n\t\twhile(kw) {\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Sorted) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\tkwtop0 = kwtop;\n\t\t\t\tdo {\n\t\t\t\t\tkw1->parstate = Sorted;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t}\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Sorted);\n\t\t\t\tif (kwtop > kwtop0)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tdo_sort(kw, KWcmp);\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = *kwtop = kw->kw;\n\t\t\t\tgoto top1;\n\t\t\t\t}\n\t\t\tkw = kw->next;\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static void\npretty_ex1(KWctx *kw, KWctx *prevkw, KWctx *nextkw, int indent, int iinc, int needrev)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, *kwp0, **x, *y, *y1;\n\tconst char *suf, *z0[KWPlen];\n\tint ep, i, i0, ia, j, n, na, np;\n\n\tn = 0;\n\tx = 0;\n\ty = 0;\n\tkw1 = kw->kw;\n\tif (needrev == 1)\n\t\tneedrev = 2;\n\tif ((kwp0 = kwp = kw->pparent) && (!kw->master || kw->master == kw)) {\n\t\tfor(;;) {\n\t\t\tif (kwp->parstate != Printing) {\n\t\t\t\tkwp->parstate = Printing;\n\t\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t\tkw1->pparent = 0;\t/* avoid infinite loops */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t++n;\n\t\t\tif (!(kw1 = kwp->pparent))\n\t\t\t\tbreak;\n\t\t\tkwp = kwp->pparent = kw1;\n\t\t\t}\n\t\tnp = n;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\t++n;\n\t\ty = y1 = (KWctx*)Malloc(np*sizeof(KWctx) + n*sizeof(KWctx*), \"pretty_ex1\");\n\t\tx = (KWctx**)(y + np);\n\t\tfor(i = 0, kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\tx[i++] = kw1;\n\t\ti0 = i;\n\t\tfor(kwp = kwp0; kwp; kwp = kwp->pparent) {\n\t\t\tj = i;\n\t\t\tna = i + kwp->nalt;\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next, ++y1) {\n\t\t\t\tmemcpy(y1, kw1, sizeof(KWctx));\n\t\t\t\tx[i++] = y1;\n\t\t\t\ty1->alt += j;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!needrev) {\n\t\t\tfor(j = i0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t}\n\t\t\tzalt = ++na <= KWPlen ? z0\n\t\t\t\t: (const char**)Malloc(na*sizeof(const char*), \"pretty_ex1\");\n\t\t\tmemset(zalt, 0, na*sizeof(const char*));\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif ((kwm = kw1->master))\n\t\t\t\t\tkwm->master = kwm;\n\t\t\t\tif (!zalt[i = kw1->alt]\n\t\t\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\t\t\tzalt[i] = kw1->names->val;\n\t\t\t\t}\n\t\t\tqsort(x, n, sizeof(KWctx*), kwcomp1);\n\t\t\tif (zalt != z0)\n\t\t\t\tfree(zalt);\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif (kw1->nreq < 0) {\n\t\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t\tkw1->pparent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tkw1 = x[0];\n\t\txmasteradj(x, n);\n\t\t}\n\tif (kw1) {\n\t\tif (!x)\n\t\t\tkw1 = masteradj(kw->kw);\n\t\tep = kw->req;\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tia = kw->master && kw->master == prevkw->master ? iinc : 0;\n\t\t\tdo_indent(indent + ia);\n\t\t\tif (!prevkw->master || prevkw->master != kw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent + ia);\n\t\t\t\tputchar('(');\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tputchar('|');\n\t\t\t}\n\t\telse {\n\t\t\tdo_indent(indent);\n\t\t\tif (kw->req)\n\t\t\t\tputchar('('/*)*/);\n\t\t\telse {\n\t\t\t\tputchar('[');\n\t\t\t\tif (nextkw && !nextkw->req && kw->alt == nextkw->alt) {\n\t\t\t\t\tep = 1;\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\tputchar('(');\n\t\t\t\t\tindent += iinc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdo_indent1(iinc);\n\t\tindent += iinc;\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\ti = 0;\n\t\tkw0 = 0;\n\t\twhile(kw1) {\n\t\t\tif (x)\n\t\t\t\tkw2 = ++i >= n ? 0 : x[i];\n\t\t\telse\n\t\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, indent, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\tkw1 = kw2;\n\t\t\t}\n\t\tif (x)\n\t\t\tfree(y);\n\t\tdo_indent(indent);\n\t\tfputs(ep ? \")\\n\" : \"]\\n\", stdout);\n\t\t}\n\telse {\n\t\tif (prevkw && kw->alt == prevkw->alt\n\t\t && kw->master && kw->master == prevkw->master)\n\t\t\tindent += iinc;\n\t\tdo_indent(indent);\n\t\tsuf = \"\\n\";\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tif (kw->master && kw->master != prevkw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent);\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfputs(\"| \", stdout);\n\t\t\t\tif (!kw->req)\n\t\t\t\t\tgoto rbcheck;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (kw->req) {\n\t\t\tif (prevkw) {\n\t\t\t\tif (prevkw->master != kw->master)\n\t\t\t\t\tgoto putlpar;\n\t\t\t\t}\n\t\t\telse if (kw != kw->master && kw->master) {\n putlpar:\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tfputs(\"[ \", stdout);\n rbcheck:\n\t\t\tif (!nextkw || nextkw->alt != kw->alt)\n\t\t\t\tsuf = \" ]\\n\";\n\t\t\t}\n\t\tprkwname(kw, suf, needrev);\n\t\t}\n\t}\n\n static void\npretty_expand(int iinc, int needrev)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2;\n\n\tif ((kw = KWbase.kw)) for(;;) {\n\t\tmasteradj(kw->kw);\n\t\tfputs(KEYKIND[(kw->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\tkw0 = 0;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw2) {\n\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, 0, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\t}\n\t\tif (!(kw = kw->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static int\nStr_option(char *s, char ***pav, int *want, StrList **ps)\n{\n\tif (*++s || (s = *++*pav)) {\n\t\tif (*s == '-' && ! s[1])\n\t\t\t*want = 0;\n\t\telse\n\t\t\t*ps = new_StrList(s, *ps);\n\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}\n\n static int\nversion(void)\n{\n\tprintf(\"nidrgen version 20100528\\n\");\n\treturn 0;\n\t}\n\n static int\ntagcomp(const void *a, const void *b)\n{\n\treturn strcmp(*(const char**)a, *(const char**)b);\n\t}\n\n static int\nunused_tags()\n{\n\tTaghash *th;\n\tchar **x;\n\tsize_t i, nbad;\n\n\tnbad = 0;\n\tfor(th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\t++nbad;\n\tif (!nbad)\n\t\treturn 0;\n\tx = (char**)Malloc(nbad*sizeof(char*), \"unsed_tags\");\n\tfor(i = 0, th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\tx[i++] = th->hh.name;\n\tfprintf(stderr, \"%lu unused tag definition%s in %s:\\n\",\n\t\t(unsigned long)nbad, \"s\" + (nbad == 1), tagfname);\n\tif (nbad > 1)\n\t\tqsort(x, nbad, sizeof(char*), tagcomp);\n\tfor(i = 0; i < nbad; ++i)\n\t\tfprintf(stderr, \"\\t\\\"%s\\\"\\n\", x[i]);\n\tfree(x);\n\treturn 1;\n\t}\n\n static int\ndefcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const Defhash**)a)->hh.name, (*(const Defhash**)b)->hh.name);\n\t}\n\n static void\nwrite_defs(FILE *f)\n{\n\tDefhash *d, **x, **x1;\n\tDefhashHead *dh;\n\tsize_t i, n;\n\n\tn = DHTab.nent;\n\tx = x1 = (Defhash**)Malloc(n*sizeof(Defhash*), \"write_defs\");\n\tfor(dh = DHTab.lastdh, i = 0; dh; dh = dh->thread) {\n\t\tif (++i > n)\n\t\t\tbotch(\"lastdef count botch\");\n\t\t*x1++ = (Defhash*)dh;\n\t\t}\n\tqsort(x, n, sizeof(Defhash*), defcomp);\n\tfor(i = 0; i < n; ++i) {\n\t\td = x[i];\n\t\tfprintf(f, d->qkeep ? \"#define %s \\\"%s\\\"\\n\"\n\t\t\t: \"#define %s %s\\n\",\n\t\t\td->hh.name, d->value);\n\t\t}\n\t}\n\n int\nmain(int argc, char **argv)\n{\n\tFILE *f;\n\tStrList *headers, *mtagname, *nsname, *outtagname;\n\tchar *defsout, *jfname, *ofname, *s, *se;\n\tconst char *kname, *libex, *libname;\n\tint defwrite, dupcheck, hwant, libmode, needrev, nwant, pprint, sort, x;\n\n\tKWStack[0] = &KWbase;\n\tDHTab.nalloc  = (sizeof(Defhash) + sizeof(void*) - 1)/sizeof(void*);\n\tTagTab.nalloc = (sizeof(Taghash) + sizeof(void*) - 1)/sizeof(void*);\n\tKWbase.names = new_StrList(\"$top\",0);\n\tprogname = argv[0];\n\tif (argc <= 1)\n usage1:\treturn usage(1);\n\theaders = mtagname = nsname = outtagname = 0;\n\tkname = libex = libname = defsout = jfname = ofname = 0;\n\tdupcheck = hwant = needrev = nwant = 1;\n\tdefwrite = libmode = pprint = sort = 0;\n nextopt:\n\twhile((s = *++argv) && *s == '-' && s[1]) {\n\t\twhile(*++s)\n\t\tswitch(*s) {\n\t\t case 'D':\n\t\t\tdefwrite = libexpand = 1;\n\t\t\tlibex = \"-D\";\n\t\t\tbreak;\n\t\t case 'T':\n\t\t\tif (Str_option(s, &argv, &hwant, &outtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'd':\n\t\t\tdupcheck = 0;\n\t\t\tbreak;\n\t\t case 'e':\n\t\t\texpand = 1;\n\t\t\tbreak;\n\t\t case 'f':\n\t\t\twantfuncs = 0;\n\t\t\tbreak;\n\t\t case 'g':\n\t\t\tguikeywds = libexpand = 1;\n\t\t\tlibex = \"-g\";\n\t\t\tbreak;\n\t\t case 'G':\n\t\t\tdfltgroup = 0;\n\t\t\tbreak;\n\t\t case 'h':\n\t\t\tif (Str_option(s, &argv, &hwant, &headers))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'j':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tjfname = s;\n\t\t\tlibexpand = 1;\n\t\t\tlibex = \"-j\";\n\t\t\tgoto nextopt;\n\t\t case 'k':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tkname = s;\n\t\t\tlibmode = 1;\n\t\t\tgoto nextopt;\n\t\t case 'l':\n\t\t\tlibmode = 1;\n\t\t\tbreak;\n\t\t case 'L':\n have_L:\n\t\t\tif (*++s)\n\t\t\t\tlibname = s;\n\t\t\telse if (!(libname = *++argv))\n\t\t\t\treturn usage(1);\n\t\t\tgoto nextopt;\n\t\t case 'm':\n\t\t\tif (Str_option(s, &argv, &hwant, &mtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'n':\n\t\t\tif (Str_option(s, &argv, &nwant, &nsname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 't':\n\t\t\tignoretags = 1;\n\t\t\tbreak;\n\t\t case 's':\n\t\t\tsort = 1;\n\t\t\tneedrev = 0;\n\t\t\tlibex = \"-s\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L': ++s; goto have_L;\n\t\t\t\t  case 'e': expand = 1;\n\t\t\t\t\t    continue;\n\t\t\t\t  case 'f': wantfuncs = 0;\n\t\t\t\t  case 'p': continue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t case 'p':\n\t\t\tlibexpand = 1;\n\t\t\tpprint = 2;\n\t\t\tif (!libex)\n\t\t\t\tlibex = \"-p\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L':\n\t\t\t\t\t++s;\n\t\t\t\t\tgoto have_L;\n\t\t\t\t  case 'e':\n\t\t\t\t\texpand = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 'f':\n\t\t\t\t\twantfuncs = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 's':\n\t\t\t\t\tsort = 1;\n\t\t\t\t\tneedrev = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 't':\n\t\t\t\t\tignoretags = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (*++s) {\n\t\t\t\tpprint = (int)strtol(s,&se,10);\n\t\t\t\tif (pprint < 1 || se)\n\t\t\t\t\tgoto usage1;\n\t\t\t\t}\n\t\t\tgoto nextopt;\n\t\t case 'v':\n\t\t\treturn version();\n\t\t case 'w':\n\t\t\tstartwarn = 0;\n\t\t\tbreak;\n\t\t case '?':\n\t\t\treturn usage(s[1] != 0);\n\t\t case '-':\n\t\t\tif (!strcmp(++s,\"help\"))\n\t\t\t\treturn usage(0);\n\t\t\tif (!strcmp(s,\"version\"))\n\t\t\t\treturn version();\n\t\t\tif (!*s) {\n\t\t\t\ts = *++argv;\n\t\t\t\tgoto argsdone;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t  default:\n\t\t\tgoto usage1;\n\t\t  }\n\t\t}\n argsdone:\n\tif (libname) {\n\t\tif (s && argv[1] && argv[2])\n\t\t\treturn usage(1);\n\t\tif ((defsout = s))\n\t\t\tofname = argv[1];\n\t\tif (mtagname) {\n\t\t\tfprintf(stderr, \"\\n%s: ignoreing -m due to -L\\n\", progname);\n\t\t\tmtagname = 0;\n\t\t\t}\n\t\tgoto lcheck;\n\t\t}\n\tif (!s || (argv[1] && argv[2] && argv[3] && argv[4]))\n\t\treturn usage(1);\n\tif ((tagfname = argv[1])) {\n\t\tspecfile = s;\n\t\ts = tagfname;\n\t\tlastseen = Saw_kwname;\n\t\tlastkw1 = &KWbase;\n\t\tif ((defsout = argv[2]))\n\t\t\tofname = argv[3];\n\t\t}\n\telse if (mtagout) {\n\t\tfprintf(stderr, \"%s: -m specified but no tagfile given.\\n\", progname);\n\t\treturn 1;\n\t\t}\n\tif (*s == '-' && !s[1])\n\t\tyyin = stdin;\n\telse if (!(yyin = fopen(infname = s, \"r\"))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n\tif (specfile)\n\t\ttagin = yyin;\n\tif ((mtagname && (!(mtagout = fopen(s = mtagname->val, \"w\"))))\n\t || (outtagname && !(tagout = fopen(s = outtagname->val, \"w\")))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n lcheck:\n\tif (libmode) {\n\t\twantfuncs |= 2;\n\t\tif (libexpand && kname) {\n\t\t\tlibmode = 0;\n\t\t\tfprintf(stderr, \"\\n%s: ignoring -k due to %s\\n\",\n\t\t\t\tprogname, libex);\n\t\t\t}\n\t\t}\n\telse\n\t\tlibexpand = 0;\n\tif (libname)\n#ifndef NO_NIDR_DYNLIB\n\t\tlibread1(0, libname, 0, 2);\n#else\n\t\t{\n\t\tfprintf(stderr, \"\\ndlopen for \\\"%s\\\" is NOT SUPPORTED\\n\", libname);\n\t\treturn usage(1);\n\t\t}\n#endif\n\telse if ((x = yylex())) {\n\t\tfprintf(stderr, \"\\n%s: Surprise return %d from yylex()\\n\", progname, x);\n\t\treturn x;\n\t\t}\n\tif (mtagout)\n\t\tfclose(mtagout);\n\tif (tagout)\n\t\tfclose(tagout);\n\tif (tagout || mtagout)\n\t\tgoto done;\n\tif (Br_top > Br_stack) {\n\t\tfputs(\"Missing \", stderr);\n\t\tdo putc(/*[*/ *Br_top-- == '(' ? ')' : ']', stderr);\n\t\t\twhile(Br_top >Br_stack);\n\t\tfputs(\" at end of file.\\n\", stderr);\n\t\treturn 1;\n\t\t}\n\tif (nsquawk > liberror)\n\t\treturn 1;\n\tif (tagfname && unused_tags())\n\t\treturn 1;\n\tif (KWbase.kw) {\n\t\tparadj(needrev);\n\t\tif (dupcheck)\n\t\t\tdup_check();\n\t\t}\n\tif (jfname)\n\t\tofname = 0;\n\telse if (ofname && !freopen(ofname, \"w\", stdout)) {\n\t\tfprintf(stderr, \"%s: Cannot open output file \\\"%s\\\"\\n\", progname, ofname);\n\t\treturn 1;\n\t\t}\n\tif (KWbase.kw) {\n\t\tif (pprint) {\n\t\t\tif (expand) {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp1);\n\t\t\t\tpretty_expand(pprint, needrev);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp2);\n\t\t\t\tpretty_print(pprint, needrev);\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!defwrite) {\n\t\t\tif (jfname)\n\t\t\t\tjOutput(jfname);\n\t\t\telse\n\t\t\t\tOutput(headers, nsname, hwant, kname,\n\t\t\t\t\tguikeywds ? 0 : libmode, nwant);\n\t\t\t}\n\t\telse if (DHTab.lastdh)\n\t\t\twrite_defs(stdout);\n\t\t}\n\tif (!defwrite && defsout) {\n\t\tf = fopen(defsout,\"w\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s:  cannot open defs file \\\"%s\\\"\\n\",\n\t\t\t\tprogname, defsout);\n\t\t\treturn 1;\n\t\t\t}\n\t\twrite_defs(f);\n\t\tfclose(f);\n\t\t}\n done:\n\treturn dupnames > 0 ? 1 : liberror ? 2 : 0;\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/nidr.c": "/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n/* nidr.c */\n\n#ifndef NIDR_H\t/* for $DAKOTA/src/nidr.c */\n#include \"nidr.h\"\n#endif\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"avltree.h\"\n\n#ifndef NIDR_SQUAWKMAX\n#define NIDR_SQUAWKMAX 10\n#endif\n\n#if !(defined(_WIN32) || defined(_WIN64))\n/* for isatty(), getegid() */\n#include <unistd.h>\n#endif\n\n#ifndef NO_NIDR_DYNLIB /*{*/\ntypedef KeyWord *(*KW_ADD)(void);\nstatic KeyWord *kwfind(const char *, KeyWord *, int, int *);\nstatic KeyWord *toomany(const char *, KeyWord *, int);\n#ifdef _WIN32 /*{{*/\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else /*}{*/\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif /*}}*/\n#endif /*}*/\n\n extern KeyWord Dakota_Keyword_Top;\n extern int nidrLineNumber;\n static KeyWord* Keyword_Top = &Dakota_Keyword_Top;\n static void *KW_g;\n void (*nidr_comment)(const char*);\n static void nidr_keyword_finish(void);\n static Comment *OutsideComment;\n static void kw_finish2(void), kw_finish3(void);\n static void kw_setup1(KeyWord *);\n static FILE *dumpfile;\n static KeyWord **ToClear, **ToClear0, **ToClearEnd;\n static int dumplev, nsquawk, nparse_errors, primary, strict;\n\n int NIDR_disallow_missing_start = 1;\n\n enum {n_KWStack0 = 64};\n\n static KWinfo KWStack0[n_KWStack0];\n\n static Uint n_KWStack = n_KWStack0;\n\n static KeyWord *curid, *curkw;\n static KWinfo\t*KWStack = KWStack0,\n\t\t*KWStackBot = KWStack0,\n\t\t*KWStackEnd = KWStack0 + n_KWStack0;\n\n static Values KWval, KWvalmax;\n static Real *KWvalbuf;\n static Uint nKWvalbuf;\n\n typedef struct Sbuf Sbuf;\n enum { n_KWsbuf = 8192 };\n struct Sbuf {\n\tchar buf[n_KWsbuf];\n\tSbuf *next;\n\t};\n\n typedef struct KWseen KWseen;\n\n struct\nKWseen {\n\tconst char *name;\n\tKeyWord *kw;\n\tKWseen *mnext, *mprev;\t/* for identifiers so far unrequited when kw == 0 */\n\t\t\t\t/* kw != 0 ==> mprev = first child, and mnext = next sibling */\n\tKWseen *parent;\n\tKWseen **lcn;\t\t/* &mprev field of last child; lcn == 0 when this */\n\t\t\t\t/* keyword was entered into the AVL tree because */\n\t\t\t\t/* its parent was seen. */\n\tComment *comment;\n\tchar **svals;\n\tReal *rvals;\n\tsize_t nvals;\n\t};\n\n static KWseen *KW_cur;\n NIDR_KWlib *NIDR_Libs;\n\n void\nnidr_lib_cleanup(void)\n{\n\tKeyWord *kw;\n\tNIDR_KWlib *L, *L1;\n\n\tL1 = NIDR_Libs;\n\tNIDR_Libs = 0;\n\twhile((L = L1)) {\n\t\tif (L->oldtop)\n\t\t\tKeyword_Top = L->oldtop;\n\t\tif ((kw = L->kw0)) {\n\t\t\tkw->f.vs = 0;\n\t\t\tkw->kind &= ~KWKind_Loaded;\n\t\t\t}\n#ifndef NO_NIDR_DYNLIB /*{{*/\n\t\tdlclose(L->h);\n#else  /*}{*/\n\t\t/* botch(\"dlclose is NOT SUPPORTED for current configuration\"); */\n\t\tfprintf(stderr, \"\\ndlclose is NOT SUPPORTED for current configuration\");\n#endif /*}}*/\n\t\tL1 = L->next;\n\t\tfree(L);\n\t\t}\n\t}\n\n static Sbuf KWsbuf0, *KWsbuf = &KWsbuf0;\n static char *KWsbuf1 = KWsbuf0.buf, *KWsbufe = KWsbuf0.buf + n_KWsbuf;\n static KWseen *curkws;\n static const char *valkind[3] = {\"integer\",\"numeric\",\"string\"};\n\n int\nnidr_parse_error(void)\n{\n\tint n;\n\tif ((n = nsquawk - NIDR_SQUAWKMAX) > 0)\n\t\tfprintf(stderr, \"\\n%d error message%s suppressed.\\n\",\n\t\t\tn, \"s\" + (n == 1));\n\treturn nsquawk + nparse_errors;\n\t}\n\n void\nnidr_signal_parse_error(void)\n{ ++nparse_errors; }\n\n void\nnidr_tolower(char *s)\n{\n\tfor(; *s; ++s)\n\t\t*s = tolower(*s);\n\t}\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\nBotch:  \");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tif (++nsquawk <= NIDR_SQUAWKMAX) {\n\t\tfprintf(stderr, \"Input line %d: \", nidrLineNumber);\n\t\tva_start(ap, fmt);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfputs(\".\\n\", stderr);\n\t\tva_end(ap);\n\t\t}\n\t}\n\n#ifdef NIDR_MALLOC_DEBUG\n typedef struct MallocDebug MallocDebug;\n struct MallocDebug\n{\n\tMallocDebug *next, *prev;\n\tchar *where;\n\tint nalloc;\n\t};\n\n static MallocDebug MDtop = {&MDtop, &MDtop, 0, 0};\n int MallocDebugCount, MallocDebugCount1;\n\n static void*\nAlloc(const char *where, size_t len)\n{\n\tMallocDebug *md = malloc(len + sizeof(MallocDebug));\n\tif (!md) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in %s\\n\", (unsigned long)len, where);\n\t\texit(1);\n\t\t}\n\t(md->next = MDtop.next)->prev = md;\n\t(md->prev = &MDtop)->next = md;\n\tmd->where = where;\n\tif ((md->nalloc = ++MallocDebugCount) == MallocDebugCount1)\n\t\tprintf(\"Hit %d\\n\", md->nalloc);\n\treturn (void*)(md + 1);\n\t}\n\n static void\nMallocDebugFree(void *v)\n{\n\tMallocDebug *md = (MallocDebug *)v - 1;\n\tmd->next->prev = md->prev;\n\tmd->prev->next = md->next;\n\tfree(md);\n\t}\n#define free MallocDebugFree\n\n#else //!NIDR_MALLOC_DEBUG\n static void*\nAlloc(const char *where, size_t len)\n{\n\tvoid *rv = malloc(len);\n\tif (!rv) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in %s\\n\", (unsigned long)len, where);\n\t\texit(1);\n\t\t}\n\treturn rv;\n\t}\n#endif //NIDR_MALLOC_DEBUG\n\n const char *\nnidr_basename(const char *p)\n{\n\tconst char *b;\n\n#ifdef _WIN32\n\tif (p[0] && p[1] == ':')\n\t\tp += 2;\n\telse if (p[0] == '\\\\' && p[1] == '\\\\')\n\t\tfor(p += 2; *p; )\n\t\t\tswitch(*p++) {\n\t\t\t case '/':\n\t\t\t case '\\\\':\n\t\t\t\tgoto break2;\n\t\t\t}\n break2:\n#endif\n\tb = p;\n\twhile(*p)\n\t\tswitch(*p++) {\n\t\t case '/':\n#ifdef _WIN32\n\t\t case '\\\\':\n#endif\n\t\t\tb = p;\n\t\t}\n\treturn b;\n\t}\n\n const char *nidr_exedir;\n int nidr_exedir_len = -1; /* allow resetting to -1 for debugging */\n\n#ifndef _WIN32\n static int\nIs_executable(uid_t myuid, gid_t mygid, struct stat *sb)\n{\n\tif (sb->st_uid == myuid) {\n\t\tif (sb->st_mode & S_IXUSR)\n\t\t\treturn 1;\n\t\t}\n\telse if (sb->st_gid == mygid) {\n\t\tif (sb->st_mode & S_IXGRP)\n\t\t\treturn 1;\n\t\t}\n\telse if (sb->st_mode & S_IXOTH)\n\t\treturn 1;\n\treturn 0;\n\t}\n#endif\n\n int\nnidr_save_exedir(const char *argv0, int pathadj)\n{\n\t/* pathadj & 1 ==> add exedir to $PATH */\n\t/* pathadj & 2 ==> add . to $PATH */\n\t/* (in both cases if not already there) */\n\n    /* These conditionals don't seem to work (perhaps expected) for Cygwin \n\t   binaries run from Windows command prompt as the compile-time is \n\t   unix-style, but runtime the path is windows-like.  For now comment\n\t   out warning when on Cygwin build */\n#ifdef _WIN32\n#define Pathname \"Path\"\n#define Sep ';'\n#define Slash '\\\\'\n#define Executable(x) !stat(x,&sb)\n#else\n#define Pathname \"PATH\"\n#define Sep ':'\n#define Slash '/'\n#define Executable(x) !stat(x,&sb) && Is_executable(myuid, mygid, &sb)\n#endif\n\tchar *buf, buf0[4096], *s;\n\tconst char *av0, *p, *p0, *p1, *p2;\n\tint dotseen, finaldot, rc;\n\tsize_t buflen, L, L1, L2, L3;\n\tstruct stat sb;\n\tstatic const char dotslash[3] = { '.', Slash, 0 };\n#ifdef _WIN32\n\tint c;\n\tpathadj &= 1;\t/* . is implicitly in $PATH under _WIN32 */\n#else\n\tgid_t mygid;\n\tuid_t myuid;\n#endif\n\tif (nidr_exedir_len != -1) {\n\t\tfprintf(stderr, \"\\nIgnoring extra call on nidr_save_argv0()\\n\");\n\t\treturn 1;\n\t\t}\n\tnidr_exedir_len = 0;\n\tif (!(av0 = argv0))\n\t\treturn 2;\n\tif (!(p = getenv(Pathname))) {\n\t\tfprintf(stderr, \"\\nnidr_save_exedir: no $%s\\n\", Pathname);\n\t\treturn 3;\n\t\t}\n\tdotseen = finaldot = rc = 0;\n\tbuf = buf0;\n\tbuflen = sizeof(buf0);\n\tp0 = p2 = p;\n\tp1 = nidr_basename(av0);\n\tif ((L = p1 - av0) > 0) {\n\t\tmemcpy(s = (char*)Alloc(\"nidr_save_argv0\", L+1), av0, L);\n\t\ts[L] = 0;\n\t\tnidr_exedir = s;\n\t\tnidr_exedir_len = (int)L;\n#ifdef _WIN32\n\t\tfor(L1 = 0; L1 < L; ++L1)\n\t\t\tif (s[L1] == '/')\n\t\t\t\ts[L1] = '\\\\';\n#endif\n\t\tif (!pathadj)\n\t\t\treturn 0;\n\t\tif (*p == Sep)\n\t\t\tdotseen = 1;\n\t\twhile(*p) {\n\t\t\tif (*p == Sep && (p[1] == Sep || p[1] == 0)) {\n\t\t\t\tdotseen = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t++p;\n\t\t\t}\n\t\tif (s[0] == '.' && s[1] == Slash && L == 2) {\n#ifdef _WIN32\n\t\t\treturn 0;\n#else\n\t\t\tif (!dotseen)\n\t\t\t\tgoto dot_add;\n#endif\n\t\t\t}\n\t\tL1 = L - 1;\n\t\tfor(p = p0;;) {\n\t\t\twhile(*p == Sep)\n\t\t\t\t++p;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t\tif (!strncmp(p, s, L1)) {\n#ifdef _WIN32\n\t\t\t\treturn 0;\n#else\n\t\t\t\tif (!(pathadj &= ~1) || *p0 == Sep)\n\t\t\t\t\treturn 0;\n\t\t\t\tfor(p = p0;;) {\n\t\t\t\t\tif (*p == Sep || (*p == '.' && p[1] == Sep))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\twhile(*p != Sep) {\n\t\t\t\t\t\tif (!*p)\n\t\t\t\t\t\t\tgoto dot_add;\n\t\t\t\t\t\t++p;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!*++p)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\twhile(*++p != Sep)\n\t\t\t\tif (!*p)\n\t\t\t\t\tgoto break2;\n\t\t\tif (!*++p) {\n#ifdef _WIN32\n\t\t\t\tfinaldot = 1; /* leave at 0 for !_WIN32 */\n#endif\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n break2:\n\t\tL1 = strlen(Pathname);\n\t\tL2 = strlen(p0);\n\t\tif (!pathadj & 2)\n\t\t\tdotseen = 1;\n\t\tL3 = L1 + L2 + L + 3;\n\t\ts = (char*)Alloc(\"nidr_save_argv0\", L3);\n\t\tmemcpy(s, Pathname, L1);\n\t\ts[L1++] = '=';\n\t\tmemcpy(s+L1, p0, L2);\n\t\tL1 += L2;\n\t\tif (!finaldot)\n\t\t\ts[L1++] = Sep;\n\t\tmemcpy(s+L1, nidr_exedir, --L);\n\t\tL1 += L;\n\t\tif (!dotseen)\n\t\t\ts[L1++] = Sep;\n\t\ts[L1] = 0;\t/* omit final slash */\n\t\tputenv(s);\n\t\treturn 0;\n\t\t}\n\tL = strlen(av0);\n#ifdef _WIN32\n\tif (L < 5 || av0[L-4] != '.'\n\t|| ((c = av0[L-3]) != 'e' && c != 'E')\n\t|| ((c = av0[L-2]) != 'x' && c != 'X')\n\t|| ((c = av0[L-1]) != 'e' && c != 'E')) {\n\t\tmemcpy(s = (char*)Alloc(\"nidr_save_argv0\", L + 5), av0, L);\n\t\tstrcpy(s+L, \".exe\");\n\t\tL += 4;\n\t\tav0 = s;\n\t\t}\n\tif (Executable(av0)) {\n\t\t/* handle implicit . */\n\t\tdotseen = 1;\n\t\tnidr_exedir = dotslash;\n\t\t}\n\telse /* do for loop */\n#else\n\tmyuid = geteuid();\n\tmygid = getegid();\n#endif\n\tfor(; *p; p = p2) {\n\t\tfor(p1 = p;; ++p1) {\n\t\t\tif (*p1 == Sep) {\n\t\t\t\tp2 = p1 + 1;\n\t\t\t\tif (!*p2)\n\t\t\t\t\tfinaldot = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!*p1) {\n\t\t\t\tp2 = p1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (p1 == p || (*p == '.' && p1 == p + 1)) {\n\t\t\tif (!dotseen) {\n\t\t\t\tdotseen = 1;\n\t\t\t\tif (Executable(av0)) {\n\t\t\t\t\tnidr_exedir = dotslash;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tL1 = p1 - p;\n\t\t\tL2 = L + L1 + 2;\n\t\t\tif (L2 > buflen) {\n\t\t\t\tif (buf != buf0)\n\t\t\t\t\tfree(buf);\n\t\t\t\tbuf = (char*)Alloc(\"nidr_save_argv0\", L2);\n\t\t\t\tbuflen = L2;\n\t\t\t\t}\n\t\t\tmemcpy(buf, p, L1);\n\t\t\tbuf[L1++] = Slash;\n\t\t\tstrcpy(buf+L1, av0);\n\t\t\tif (Executable(buf)) {\n\t\t\t\ts = (char*)Alloc(\"nidr_save_argv0\", L1+1);\n\t\t\t\tmemcpy(s, buf, L1);\n\t\t\t\ts[L1] = 0;\n\t\t\t\tnidr_exedir = s;\n\t\t\t\tnidr_exedir_len = (int)L1;\n\t\t\t\tpathadj &= ~1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (dotseen)\n\t\tpathadj &= ~2;\n\tif (!finaldot && *p2) {\n\t\twhile(p2[1])\n\t\t\t++p2;\n\t\tif (*p2 == Sep)\n\t\t\tfinaldot = 1;\n\t\t}\n\tif (finaldot && !dotseen && !nidr_exedir) {\n\t\tdotseen = 1;\n\t\tif (Executable(av0))\n\t\t\tnidr_exedir = dotslash;\n\t\t}\n\tif (nidr_exedir == dotslash)\n\t\tnidr_exedir_len = 2;\n\telse {\n\t\tif (pathadj & 2 && !finaldot) {\n#ifndef _WIN32\n dot_add:\n#endif\n\t\t\tL = strlen(p0);\n\t\t\tL1 = strlen(Pathname);\n\t\t\tL2 = L + L1 + 3;\n\t\t\ts = (char*)Alloc(\"nidr_save_argv0\", L2);\n\t\t\tmemcpy(s, Pathname, L1);\n\t\t\ts[L1++] = '=';\n\t\t\tmemcpy(s+L1, p0, L);\n\t\t\ts[L += L1] = Sep;\n\t\t\ts[L+1] = 0;\n\t\t\tputenv(s);\n\t\t\t}\n\t\tif (!nidr_exedir) {\n/* Suppress warning for Cygwin and Windows, where path isn't resolved correctly above */\n#if !defined(__CYGWIN__) && !defined(_MSC_VER)\n\t\t\tfprintf(stderr, \"\\nnidr_save_exedir: could not find \\\"%s\\\" in $%s\\n\",\n\t\t\t\tav0, Pathname);\n#endif\n\t\t\trc = 4;\n\t\t\t}\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n\t}\n\n void *\nnidr_dlopen(const char *libname)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"dlopen for \\\"%s\\\" is NOT SUPPORTED\", libname);\n\treturn (void*)libname;\n#else /*}{*/\n\tchar buf0[4096], *buf;\n\tconst char *b;\n\tsize_t buflen, L, L1;\n\tvoid *h;\n\n\tb = nidr_basename(libname);\n\tif (b > libname)\n\t\treturn dlopen(libname, RTLD_NOW);\n\tbuf = buf0;\n\tbuflen = sizeof(buf0);\n\tL = strlen(libname);\n\tif (nidr_exedir) {\n\t\tL1 = L + nidr_exedir_len + 1;\n\t\tif (L1 > buflen) {\n\t\t\tbuf = (char*)Alloc(\"nidr_dlopen\", L1);\n\t\t\tbuflen = L1;\n\t\t\t}\n\t\tmemcpy(buf, nidr_exedir, nidr_exedir_len);\n\t\tstrcpy(buf + nidr_exedir_len, libname);\n\t\tif ((h = dlopen(buf, RTLD_NOW)))\n\t\t\tgoto ret;\n\t\t}\n\tif (!(h = dlopen(libname, RTLD_NOW))) {\n\t\tL1 = L + 3;\n\t\tif (L1 > buflen) {\n\t\t\tbuf = (char*)Alloc(\"nidr_dlopen\", L1);\n\t\t\tbuflen = L1;\n\t\t\t}\n\t\tbuf[0] = '.';\n\t\tbuf[1] = Slash;\n\t\tstrcpy(buf+2, libname);\n\t\tif (!(h = dlopen(buf, RTLD_NOW)))\n\t\t\th = dlopen(libname, RTLD_NOW); \t/* for dlerror */\n\t\t}\n ret:\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn h;\n#endif  /*}}*/\n\t}\n\n#undef Executable\n#undef Slash\n#undef Sep\n#undef Pathname\n\n\n struct\nComment {\n\tint k;\t\t/* subscript for comfree */\n\tsize_t avail;\t/* bytes left (from tnext) */\n\tchar *text;\t/* text of comment */\n\tchar *tnext;\t/* null byte at end of comment */\n\tComment *fnext;\t/* next free Comment */\n\t};\n\n enum { Comment_kmax = 7 };\n\n static Comment *comfree[Comment_kmax+1];\n static size_t Comment_maxlen[Comment_kmax+1];\n\n static void\ncomment_free(Comment *c)\n{\n\tint k = c->k;\n\n\tif (k > Comment_kmax)\n\t\tfree(c);\n\telse {\n\t\tc->fnext = comfree[k];\n\t\tcomfree[k] = c;\n\t\t}\n\t}\n\n static Comment*\nalloc_comment(int k, size_t L)\n{\n\tComment *c;\n\n\tfor(; k <= Comment_kmax; ++k) {\n\t\tif (L <= Comment_maxlen[k]) {\n\t\t\tL = Comment_maxlen[k];\n\t\t\tif ((c = comfree[k])) {\n\t\t\t\tcomfree[k] = c->fnext;\n\t\t\t\tgoto have_c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tc = (Comment*)Alloc(\"save_comment\", L + sizeof(Comment) + 1);\n\tc->k = k;\n\tc->text = (char*)(c+1);\n have_c:\n\tc->avail = L;\n\tc->tnext = c->text;\n\treturn c;\n\t}\n\n static void\nsave_comment(const char *s)\n{\n\tComment *c, *c1, **cp;\n\tsize_t L, L1;\n\n\tL = strlen(s);\n\tcp = curid ? &curid->comment : curkws ? &curkws->comment : &OutsideComment;\n\tif ((c = *cp)) {\n\t\tif (c->avail >= L)\n\t\t\tgoto cupdate;\n\t\tL1 = c->tnext - c->text;\n\t\tc1 = alloc_comment(c->k + 1, L + L1);\n\t\tmemcpy(c1->text, c->text, L1);\n\t\tc1->tnext = c1->text + L1;\n\t\tc1->avail -= L1;\n\t\tcomment_free(c);\n\t\tc = c1;\n\t\t}\n \telse\n\t\tc = alloc_comment(0, L);\n cupdate:\n\tmemcpy(c->tnext, s, L+1);\n\tc->tnext += L;\n\tc->avail -= L;\n\t*cp = c;\n\t}\n\n static void\ncomment_setup(void)\n{\n\tint i;\n\tsize_t L;\n\tnidr_comment = save_comment;\n\t/* \"- 1\" to allow for terminating '\\0' */\n\tfor(L = 64; L <= sizeof(Comment) - 1; L <<= 1);\n\tfor(i = 0; i <= Comment_kmax; ++i, L <<= 1)\n\t\tComment_maxlen[i] = L - sizeof(Comment) - 1;\n\t}\n\n static void\ncomment_reset(void)\n{\n\tComment *c, *c1;\n\tint i;\n\n\tfor(i = 0; i <= Comment_kmax; ++i) {\n\t\tc1 = comfree[i];\n\t\tcomfree[i] = 0;\n\t\twhile((c = c1)) {\n\t\t\tc1 = c->fnext;\n\t\t\tfree(c);\n\t\t\t}\n\t\t}\n\tnidr_comment = 0;\n\t}\n\n static void\ndumpcomment(Comment **cp)\n{\n\tComment *c = *cp;\n\t*cp = 0;\n\tfprintf(dumpfile, \"%s\", c->text);\n\tcomment_free(c);\n\t}\n\n static void\ndumpname(int hasval, KeyWord *kw)\n{\n\tconst char *fmt[2] = { \"%s\", \"%s =\" };\n\tint i;\n\tif (OutsideComment)\n\t\tdumpcomment(&OutsideComment);\n\tif (primary)\n\t\tkw += kw->paoff;\n\tfor(i = 0; i < dumplev; ++i)\n\t\tputc(' ', dumpfile);\n\tfprintf(dumpfile,fmt[hasval],kw->name);\n\tif (!hasval) {\n\t\tif (kw->comment)\n\t\t\tdumpcomment(&kw->comment);\n\t\telse if (kw != curkw)\n\t\t\tputc('\\n', dumpfile);\n\t\t}\n\t}\n\n static void\ndumpstring(const char *s0)\n{\n\tconst char *s;\n\tint c, n1, n2, q;\n\n\tn1 = n2 = 0;\n\tfor(s = s0;;)\n\t\tswitch(*s++) {\n\t\t  case 0: goto break2;\n\t\t  case '\\'':\n\t\t\t++n1;\n\t\t\tbreak;\n\t\t  case '\"':\n\t\t\t++n2;\n\t\t  }\n break2:\n\tq = '\\'';\n\tif (n1 > n2)\n\t\tq = '\"';\n\tputc(' ', dumpfile);\n\tputc(q, dumpfile);\n\ts = s0;\n\twhile((c = *s++)) {\n\t\tif (c == q)\n\t\t\tputc(q, dumpfile);\n\t\tputc(c, dumpfile);\n\t\t}\n\tputc(q, dumpfile);\n\t}\n\n static void\ndumpvals0(KeyWord *kw)\n{\n\tReal *r;\n\tconst char **sp;\n\tint i, *ip, indent, j, n;\n\n\tip = 0; /* shut up warning of possible use without initialization */\n\tsp = 0; /* ditto */\n\tif (!(r = KWval.r) && !(ip = KWval.i) && !(sp = KWval.s))\n\t\treturn;\n\tn = KWval.n;\n\tputc((indent = n > 1) ? '\\n' : ' ', dumpfile);\n\tfor(i = 0;;) {\n\t\tif (indent) {\n\t\t\tputc('\\t', dumpfile);\n\t\t\tfor(j = 0; j < dumplev; ++j)\n\t\t\t\tputc(' ', dumpfile);\n\t\t\t}\n\t\tif (r)\n\t\t\tfprintf(dumpfile, \"%.15g\", r[i]);\n\t\telse if (ip)\n\t\t\tfprintf(dumpfile, \"%d\", ip[i]);\n\t\telse\n\t\t\tdumpstring(sp[i]);\n\t\tif (++i >= n)\n\t\t\tbreak;\n\t\tindent = 1;\n\t\tputc('\\n', dumpfile);\n\t\t}\n\tif (kw->comment)\n\t\tdumpcomment(&kw->comment);\n\telse\n\t\tputc('\\n', dumpfile);\n\t}\n\n static void (*dumpvals)(KeyWord *kw) = dumpvals0;\n\n static void\ndumpvals1(KeyWord *kw)\n{\n\tReal *r;\n\tconst char **sp;\n\tint i, *ip, n;\n\n\tip = 0; /* shut up warning of possible use without initialization */\n\tsp = 0; /* ditto */\n\tif ((r = KWval.r) || (ip = KWval.i) || (sp = KWval.s)) {\n\t\tn = KWval.n;\n\t\tfor(i = 0; i < n; ++i) {\n\t\t\tif (r)\n\t\t\t\tfprintf(dumpfile, \" %.15g\", r[i]);\n\t\t\telse if (ip)\n\t\t\t\tfprintf(dumpfile, \" %d\", ip[i]);\n\t\t\telse\n\t\t\t\tdumpstring(sp[i]);\n\t\t\t}\n\t\t}\n\tif (kw->comment)\n\t\tdumpcomment(&kw->comment);\n\telse\n\t\tputc('\\n', dumpfile);\n\t}\n\n char *\nnidr_KWscopy(const char *s)\n{\n\tSbuf *sb;\n\tchar *rv;\n\n\tsize_t L = strlen(s) + 1;\n\tif (L >= n_KWsbuf)\n\t\tbotch(\"String too long in KWscopy\");\n\tif (KWsbufe - KWsbuf1 < L) {\n\t\tif (!KWsbuf->next) {\n\t\t\tKWsbuf->next = sb = (Sbuf*)Alloc(\"KWscopy\", sizeof(Sbuf));\n\t\t\tsb->next = 0;\n\t\t\t}\n\t\tKWsbuf = KWsbuf->next;\n\t\tKWsbuf1 = KWsbuf->buf;\n\t\tKWsbufe = KWsbuf1 + n_KWsbuf;\n\t\t}\n\tstrcpy(KWsbuf1, s);\n\trv = KWsbuf1;\n\tKWsbuf1 += L;\n\treturn rv;\n\t}\n\n static void\nKWvalbuf_inc(void)\n{\n\tReal *r;\n\tUint n;\n\n\tn = nKWvalbuf << 1;\n\tr = (Real*)Alloc(\"KWvalbuf\", n*sizeof(Real));\n\tmemcpy(r, KWvalbuf, nKWvalbuf*sizeof(Real));\n\tfree(KWvalbuf);\n\tKWvalbuf = r;\n\tnKWvalbuf = n;\n\tKWvalmax.n <<= 1;\n\tif (KWval.r) {\n\t\tKWval.r = r;\n\t\tKWvalmax.r = r + n;\n\t\t}\n\telse if (KWval.i) {\n\t\tKWval.i = (int*) r;\n\t\tKWvalmax.i = (int*)(r + n);\n\t\t}\n\telse if (KWval.s) {\n\t\tKWval.s = (const char**)r;\n\t\tKWvalmax.s = (const char**)(r + n);\n\t\t}\n\telse\n\t\tbotch(\"Unexpected case in KWvalbuf_inc\");\n\t}\n\n/* KWval.rstate values...\n *\tvalue\tform seen\n *\t0\tv\n *\t1\tL:u\n *\t2\tL:s:u\n *\t3\tn*v\n *\t4\tn*L:u\n *\t5\tn*L:s:u\n */\n\n static void\nfinish_rexpand(void)\n{\n\tint i, k, n, os;\n\tReal sgn, st, u, v, x;\n\n\tos = KWval.rstate;\n\tKWval.rstate = 0;\n\tn = KWval.n;\n\tk = 1;\n\tif (os >= 3) {\n\t\tKWval.n = n -= os-1;\n\t\tk = KWval.r[n];\n\t\tif (k != KWval.r[n]) {\n\t\t\tsquawk(\"Noninteger replication factor %.17g\", KWval.r[n]);\n\t\t\treturn;\n\t\t\t}\n\t\telse if (k < 1) {\n\t\t\tsquawk(\"Nonpositive replication factor %d\", k);\n\t\t\treturn;\n\t\t\t}\n\t\t++n;\n\t\tos -= 3;\n\t\t}\n\telse\n\t\tKWval.n = n -= os + 1;\n\tv = KWval.r[n++];\n\tu = st = 0.;\t/* Shut up warning of not being initialized. */\n\t\t\t/* Both will be assigned before being used. */\n\tswitch(os) {\n\t  case 0:\n\t\tn = KWval.n;\n\t\tfor(i = 0; i < k; ++i) {\n\t\t\tif (n >= KWvalmax.n)\n\t\t\t\tKWvalbuf_inc();\n\t\t\tKWval.r[n++] = v;\n\t\t\t}\n\t\tKWval.n = n;\n\t\treturn;\n\t  case 1:\n\t\tst = 1;\n\t\tu = KWval.r[n];\n\t\tbreak;\n\t  case 2:\n\t\tst = KWval.r[n];\n\t\tif (st == 0.) {\n\t\t\tsquawk(\"Invalid stride == zero.\");\n\t\t\treturn;\n\t\t\t}\n\t\tu = KWval.r[n+1];\n\t  }\n\tsgn = 1.;\n\tif (st < 0.)\n\t\tsgn = -1.;\n\tif (sgn*(u - v) < 0.) {\n\t\tsquawk(\"Empty sequence.\");\n\t\treturn;\n\t\t}\n\tn = KWval.n;\n\tdo {\n\t\tfor(i = 0; sgn*(u - (x = v + i*st)) >= 0.; ++i) {\n\t\t\tif (n >= KWvalmax.n)\n\t\t\t\tKWvalbuf_inc();\n\t\t\tKWval.r[n++] = x;\n\t\t\t}\n\t\t}\n\t\twhile(--k > 0);\n\tKWval.n = n;\n\t}\n\n static void\nrexpand(int state)\n{\n\tint os;\n\n\tos = KWval.rstate;\n\tKWval.rstate = 0;\n\tswitch(state) {\n\t  case 1: /* just saw *v */\n\t\tif (os == 0)\n\t\t\tKWval.rstate = 3;\n\t\telse\n\t\t\tsquawk(\"Unexpected '*'\");\n\t\tbreak;\n\t  case 2: /* just saw :v */\n\t\tif (os == 2 || os == 5)\n\t\t\tsquawk(\"Unexpected ':'\");\n\t\telse\n\t\t\tKWval.rstate = os + 1;\n\t\tbreak;\n\t  }\n\t}\n\n static void\nnidr_bufr_strict(Real r, int state)\n{\n\tint k, n;\n\n\tif (KWval.s) {\n\t\tsquawk(\"expected a quoted string, but found a number\");\n\t\treturn;\n\t\t}\n\tif (KWval.rstate && !state)\n\t\tfinish_rexpand();\n\tif (!KWval.r && !KWval.i) {\n\t\tsquawk(\"No values may be specified for %s\", KWStack->kw->name);\n\t\treturn;\n\t\t}\n\tif ((n = KWval.n) >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tif (KWval.r)\n\t\tKWval.r[n] = r;\n\telse {\n\t\tk = (int)r;\n\t\tif (k != r)\n\t\t\tsquawk(\"truncating %.17g to %d\", r, k);\n\t\tKWval.i[n] = k;\n\t\t}\n\t++KWval.n;\n\tif (state | KWval.rstate)\n\t\trexpand(state);\n\t}\n\n static void\nnidr_bufs_strict(const char *s)\n{\n\tif (!KWval.s) {\n\t\tif (KWval.r)\n\t\t\tsquawk(\"Expected a number, but found a quoted string\");\n\t\telse\n\t\t\tsquawk(\"Misplaced quoted string\");\n\t\treturn;\n\t\t}\n\tif (KWval.n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.s[KWval.n++] = s;\n\t}\n\n void\nnidr_reset(void)\n{\n\t/* Originally did this in case KWKind_Str of kw_setup(), */\n\t/* but this leads to confusion with erroneous input. */\n\tif (curkw)\n\t\tnidr_keyword_finish();\n\tKWsbuf = &KWsbuf0;\n\tKWsbuf1 = KWsbuf0.buf;\n\tKWsbufe = KWsbuf0.buf + n_KWsbuf;\n\t}\n\n NIDR_KWlib *\nnidr_lib_record(void *h, const char *libname)\n{\n\tNIDR_KWlib *Lib;\n\tsize_t L;\n\n\tL = strlen(libname) + 1;\n\tLib = (NIDR_KWlib*)Alloc(\"NIDR_lib_record\", sizeof(NIDR_KWlib) + L);\n\tmemset(Lib, 0, sizeof(NIDR_KWlib));\n\tmemcpy(Lib->libname = (char*)(Lib+1), libname, L);\n\tif (!(Lib->next = NIDR_Libs))\n\t\tatexit(nidr_lib_cleanup);\n\tNIDR_Libs = Lib;\n\tLib->h = h;\n\treturn Lib;\n\t}\n\n static KeyWord*\nkw_insert(KeyWord *kw, int *tryagain)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"Loading library \\\"%s\\\" for %s is disallowed\",\n\t\tkw->f.vf, kw->name);\n#else /*}{*/\n\tKW_ADD kwa;\n\tKeyWord *kw0, *kw1, *kw2;\n\tNIDR_KWlib *Lib;\n\tUint u1, ui;\n\tconst char *lname, *s;\n\tint newtop, nmatch;\n\tvoid *h;\n\n\tif (tryagain)\n\t\t*tryagain = 0;\n\tif (kw->kind & KWKind_Loaded)\n\t\treturn (KeyWord*)kw->f.vs;\n\th = nidr_dlopen(lname = (const char*)kw->f.vf);\n\tif (!h) {\n#ifndef NO_DLERROR\n\t\tif ((s = dlerror()))\n\t\t\tbotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\tlname, kw->name, s);\n\t\telse\n#endif\n\t\t\tbotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\tlname, kw->name);\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw1 = (*kwa)();\n\tif (!(s = kw1->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tnewtop = 0;\n\tif (strcmp(s, kw->name)) {\n\t\tif (!KW_cur && !strcmp(s,\"KeywordTop\") && kw1->kind & KWKind_Dynmult)\n\t\t\tnewtop = 1;\n\t\telse if (tryagain && kw1->nkw > 0\n\t\t && (kw2 = kwfind(kw->name, kw1->kw, kw1->nkw, &nmatch))) {\n\t\t\tif (nmatch > 1) {\n\t\t\t\ttoomany(kw->name, kw1, nmatch);\n\t\t\t\tbotch(\"Too many matches in library %s\", lname);\n\t\t\t\t}\n\t\t\t*tryagain = 1;\n\t\t\t}\n\t\telse\n namebotch:\n\t\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\t\tlname, kw->name, s);\n\t\t}\n\tui = kw->kind  & (KWKind_Mask|KWKind_List);\n\tu1 = kw1->kind & (KWKind_Mask|KWKind_List);\n\tif (ui != u1)\n\t\tbotch(\"Library %s: expected kind %u for %s, but got %u\",\n\t\t\tlname, ui, s, u1);\n\tLib = nidr_lib_record(h, lname);\n\tLib->kw0 = kw0 = kw;\n\tmemcpy(&Lib->kw, kw, sizeof(KeyWord));\n\tkw = &Lib->kw;\n\tkw->kw = kw1->kw;\n\tkw->nkw = kw1->nkw;\n\tkw->f = kw1->f;\n\tkw0->f.vs = (void*)kw;\n\tkw0->kind |= KWKind_Loaded;\n\tif (newtop) {\n\t\tLib->oldtop = Keyword_Top;\n\t\tKeyword_Top = kw;\n\t\tkw->kind |= KWKind_Dynmult;\n\t\t}\n#endif\t/*}}*/\n\treturn kw;\n\t}\n\n static void\nkwnext_setup(KeyWord *kw, Uint n)\n{\n\tKeyWord *kwe;\n\n\tif (kw->kwnext || (n <= 1 && kw->name))\n\t\treturn;\n#ifndef NO_NIDR_DYNLIB /*{*/\n\tif (kw->kind & KWKind_Extended) {\n\t\tKeyWordx *kx1, *kxe;\n\t\tfor(kx1 = (KeyWordx*)kw; !kx1->kw.name; ++kx1)\n\t\t\tkx1->kw.kwnext = (KeyWord*)(kx1 + 1);\n\t\tfor(kxe = kx1 + n - 1; kx1 < kxe; ++kx1)\n\t\t\tkx1->kw.kwnext = (KeyWord*)(kx1 + 1);\n\t\treturn;\n\t\t}\n#endif\n\tfor(; !kw->name; ++kw)\n\t\tkw->kwnext = kw + 1;\n\tfor(kwe = kw + n - 1; kw < kwe; ++kw)\n\t\tkw->kwnext = kw + 1;\n\t}\n\n static void\nKWStack_inc(void)\n{\n\tKWinfo *kwi;\n\tUint nn;\n\tsize_t len;\n\n\tnn = n_KWStack << 1;\n\tkwi = (KWinfo*)Alloc(\"kw_setup\", len = nn*sizeof(KWinfo));\n\tmemcpy(kwi, KWStackBot, len >> 1);\n\tif (KWStackBot != KWStack0)\n\t\tfree(KWStackBot);\n\tKWStackBot = kwi;\n\tKWStackEnd = kwi + nn;\n\tKWStack = kwi + n_KWStack;\n\tn_KWStack = nn;\n\t}\n\n static KeyWord*\nkw_setup(KeyWord *kw, void *g, const char *name)\n{\n\tKWinfo *kwi;\n\tKeyWord **alt, *kw1, **req;\n\n\tUint k, nalt, nn, nreq;\n\tint *altct, deferred;\n\tsize_t len;\n\n\tdeferred = 0;\n\tif (kw->kind & KWKind_Dynlib) {\n\t\tif (kw->kw)\n\t\t\tdeferred = 1;\n\t\telse\n\t\t\tkw = kw_insert(kw, 0);\n\t\t}\n top:\n\tif ((kw1 = kw->kw)) {\n\t\tkwnext_setup(kw1, kw->nkw);\n\t\tif (kw->kind & KWKind_Dynmult)\n\t\t\treturn kw;\n\t\twhile(!kw1->name) {\n\t\t\tif (!(kw1->kind & KWKind_Stacked)) {\n\t\t\t\tkw1->kind |= KWKind_Stacked;\n\t\t\t\tkw_setup(kw1, g, name);\n\t\t\t\t}\n\t\t\tkw1 = kw1->kwnext;\n\t\t\t}\n\t\t}\n\tif (!curkw) {\n\t\tKWStack = KWStackBot = KWStack0;\n\t\tKWStackEnd = KWStack0 + n_KWStack0;\n\t\tcurkw = kw;\n\t\t}\n\telse if (++KWStack >= KWStackEnd)\n\t\tKWStack_inc();\n\tkwi = KWStack;\n\tkwi->name = name;\n\tkwi->kw = kw;\n\tkwi->kw1 = kw1;\n\tnalt = nreq = 0;\n\tif (kw1)\n\t\tfor(; kw1; kw1 = kw1->kwnext) {\n\t\t\tif (nalt < kw1->alt)\n\t\t\t\tnalt = kw1->alt;\n\t\t\tif (nreq < kw1->req)\n\t\t\t\tnreq = kw1->req;\n\t\t\t}\n\tkwi->nalt = nalt;\n\tkwi->nreq = nreq;\n\talt = req = 0;\n\taltct = 0;\n\tif ((nn = nalt + nreq) > 0) {\n\t\tnn += 2;\n\t\talt = (KeyWord**)Alloc(\"kw_setup(alt)\",\n\t\t\t\tlen = nn*sizeof(KeyWord*) + (nalt+1)*sizeof(int));\n\t\tmemset(alt, 0, len);\n\t\treq = alt + nalt + 1;\n\t\taltct = (int*)(req + nreq + 1);\n\t\t/* altct[0], alt[0] and req[0] = \"don't care\" slots */\n\t\t}\n\tkwi->alt = alt;\n\tkwi->req = req;\n\tkwi->altct = altct;\n\tif (nreq)\n\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\treq[kw1->req] = kw1;\n\tif (nalt)\n\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\tif (kw1->kind & KWKind_primary)\n\t\t\t\t++altct[kw1->alt];\n\tkwi->g = g;\n\tKWval.n = 0;\n\tKWval.i = 0;\n\tKWval.r = 0;\n\tKWval.s = 0;\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tif (!KWvalmax.r)\n\t\t\tKWvalbuf = (Real *)Alloc(\"kw_setup(KWvalbuf)\",\n\t\t\t\t\t\t(nKWvalbuf = 128)*sizeof(Real));\n\t\tswitch(k) {\n\n\t\t  case KWKind_Int:\n\t\t\tKWval.i = (int*)KWvalbuf;\n\t\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(int);\n\t\t\tKWvalmax.i = KWval.i + KWvalmax.n;\n\t\t\tbreak;\n\n\t\t  case KWKind_Real:\n\t\t\tKWval.r = KWvalbuf;\n\t\t\tKWvalmax.r = KWvalbuf + (KWvalmax.n = nKWvalbuf);\n\t\t\tbreak;\n\n\t\t  case KWKind_Str:\n\t\t\tKWval.s = (const char**)KWvalbuf;\n\t\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t  }\n\t\t}\n\tif (deferred) {\n\t\tkw = kw_insert(kw, 0);\n\t\tdeferred = 0;\n\t\tgoto top;\n\t\t}\n\tif (!(kwi->needstart = kw->kind & KWKind_Mask)) {\n\t\tif (kw->name) {\n\t\t\tif (dumpfile)\n\t\t\t\tdumpname(0, kw);\n\t\t\t++dumplev;\n\t\t\t}\n\t\tif (kw->f.start)\n\t\t\t(*kw->f.start)(kw->name, 0, &KWStack->g, kw->f.vs);\n\t\t}\n\telse if (!kw->f.start && NIDR_disallow_missing_start)\n\t\tbotch(\"No start routine for %s\", kw->name);\n\treturn kw;\n\t}\n\n static KeyWord *\nkwfind(const char *name, KeyWord *keywds, int n, int *nmatch)\n{\n\tKeyWord *kn, *kn1;\n\tint k, n0, n1, n2, nn;\n\tsize_t L;\n\n\t*nmatch = 0;\n\tif (n <= 0)\n\t\treturn 0;\n\tL = strlen(name);\n\tn0 = 0;\n\tnn = n;\n#ifndef NO_NIDR_DYNLIB /*{*/\n\tif (n > 0 && keywds->kind & KWKind_Extended) {\n\t    while(n > 0) {\n\t\tn1 = n >> 1;\n\t\tkn = (KeyWord*)((KeyWordx*)keywds + n1);\n\t\tk = strncmp(name, kn->name, L);\n\t\tif (k < 0)\n\t\t\tn = n1;\n\t\telse if (k > 0) {\n\t\t\tn -= ++n1;\n\t\t\tn0 += n1;\n\t\t\tkeywds = (KeyWord*)((KeyWordx*)kn + 1);\n\t\t\t}\n\t\telse {\n\t\t\t/* Found -- check for range of matches. */\n\t\t\t/* Here we use linear search, as we expect */\n\t\t\t/* the range to be small. */\n\t\t\tn = n1 + n0;\n\t\t\tn2 = n + 1;\n\t\t\tif (kn->name[L]) {\n\t\t\t\tfor(kn1 = kn; n2 < nn; ++n2) {\n\t\t\t\t\tkn1 = (KeyWord*)((KeyWordx*)kn1 + 1);\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t}\n\t\t\t\tkn1 = kn;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tkn1 = (KeyWord*)((KeyWordx*)kn1 - 1);\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t--n;\n\t\t\t\t\tkn = kn1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t*nmatch = n2 - n;\n\t\t\treturn kn;\n\t\t\t}\n\t\t}\n\t    }\n\telse\n#endif\t/*}*/\n\twhile(n > 0) {\n\t\tn1 = n >> 1;\n\t\tkn = keywds + n1;\n\t\tk = strncmp(name, kn->name, L);\n\t\tif (k < 0)\n\t\t\tn = n1;\n\t\telse if (k > 0) {\n\t\t\tn -= ++n1;\n\t\t\tn0 += n1;\n\t\t\tkeywds = kn + 1;\n\t\t\t}\n\t\telse {\n\t\t\t/* Found -- check for range of matches. */\n\t\t\t/* Here we use linear search, as we expect */\n\t\t\t/* the range to be small. */\n\t\t\tn = n1 + n0;\n\t\t\tn2 = n + 1;\n\t\t\tif (kn->name[L]) {\n\t\t\t\tfor(kn1 = kn; n2 < nn; ++n2) {\n\t\t\t\t\t++kn1;\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t}\n\t\t\t\tkn1 = kn;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\t--kn1;\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L]) {\n found1:\n\t\t\t\t\t\t*nmatch = 1;\n\t\t\t\t\t\treturn kn1;\n\t\t\t\t\t\t}\n\t\t\t\t\t--n;\n\t\t\t\t\tkn = kn1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t*nmatch = n2 - n;\n\t\t\treturn kn;\n\t\t\t}\n\t\t}\n\treturn 0;\t/* not found */\n\t}\n\n static KeyWord *\ntoomany(const char *name, KeyWord *kw, int nmatch)\n{\n\tint i;\n\tsquawk(\"\\\"%s\\\" is ambiguous; possible matches..\", name);\n\tif (nsquawk <=  NIDR_SQUAWKMAX)\n\t\tfor(i = 0; i < nmatch; i++, kw++)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", kw->name);\n\treturn 0;\n\t}\n\n KeyWord *\nnidr_keyword(const char *name)\n{\n\tint nmatch;\n\tKeyWord *kw, *kw1;\n\n\tkw = kwfind(name, Keyword_Top->kw, Keyword_Top->nkw, &nmatch);\n\tif (nmatch > 1)\n\t\treturn toomany(name, kw, nmatch);\n\telse if (kw) {\n\t\tif (!(kw1 = curkw)) {\n\t\t\tkw = kw_setup(kw, KW_g, name);\n\t\t\tif (kw->kind & KWKind_Dynmult)\n\t\t\t\treturn kw;\n\t\t\t}\n\t\tif (!strict) {\n\t\t\tif (kw1)\n\t\t\t\tnidr_keyword_finish();\n\t\t\tkw_setup1(kw);\n\t\t\t}\n\t\t}\n\treturn kw;\n\t}\n\n static void\nvalcheck(KeyWord *kw)\n{\n\tReal *r;\n\tint *z;\n\tint i, k, n;\n\n\tn = KWval.n;\n\tswitch(k = kw->kind & KWKind_Mask) {\n\t  case KWKind_Int:\n\t\tz = KWval.i;\n\t\tif (kw->kind & KWKind_strictLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] <= kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be > %.0f\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] < kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be >= %.0f\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif (kw->kind & KWKind_strictUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] >= kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be < %.0f\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] > kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be >= %.0f\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tbreak;\n\t  case KWKind_Real:\n\t\tr = KWval.r;\n\t\tif (kw->kind & KWKind_strictLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] <= kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be > %g\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] < kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be >= %g\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif (kw->kind & KWKind_strictUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] >= kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be < %g\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] > kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be >= %g\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tbreak;\n\t  default:\n\t\tbotch(\"Bug: unexpected (kw->kind & KWKind_Mask) = %d in valcheck\",n);\n\t  }\n\t}\n\n static void\nread_lib(const char *libname, KeyWord *kw)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"LIBNAME is disallowed: cannot read \\\"%s\\\"\", libname);\n#else /*}{*/\n\tKeyWord *kw1;\n\tKW_ADD kwa;\n\tNIDR_KWlib *Lib;\n\tvoid *h;\n\n\th = nidr_dlopen(libname);\n\tif (!h) {\n#ifndef NO_DLERROR\n\t\tconst char *s;\n\t\tif ((s = dlerror()))\n\t\t\tbotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\", libname, s);\n\t\telse\n#endif\n\t\t\tbotch(\"Cannot open library \\\"%s\\\"\", libname);\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", libname);\n\tkw1 = (*kwa)();\n\tLib = nidr_lib_record(h, libname);\n\tkw->nkw = kw1->nkw;\n\tkw->kw = kw1->kw;\n\tkw->f = kw1->f;\n\tkw->kind |= KWKind_Loaded;\n#endif\t/*}}*/\n\t}\n\n static void\nnidr_id_strict_finish(KWinfo *kwi, KeyWord *kw, const char *name)\n{\n\tKeyWord *kw1;\n\tint n;\n\n\tif (kw->alt) {\n\t\tif ((kw1 = kwi->alt[n = kw->alt])) {\n\t\t\tif (strcmp(kw1->name, name))\n\t\t\t\tsquawk(\"%s and %s are mutually exclusive\",\n\t\t\t\t\tkw1->name, name);\n\t\t\telse\n\t\t\t\tsquawk(\"%s was already specified\", name);\n\t\t\t}\n\t\telse\n\t\t\tkwi->alt[n] = kw;\n\t\t}\n\tif (kw->req) {\n\t\tif (kwi->req[n = kw->req])\n\t\t\tkwi->req[n] = 0;\n\t\telse if (!kw->alt)\n\t\t\tsquawk(\"%s specified more than once\", name);\n\t\t}\n\t}\n\n static KWinfo *\ndispatch_val(KWinfo *kwi)\n{\n\tKeyWord *kw = kwi->kw;\n\n\tkwi->needstart = 0;\n\tif (KWval.n) {\n\t\tif (KWval.rstate)\n\t\t\tfinish_rexpand();\n\t\tif (dumpfile) {\n\t\t\tdumpname(1, kw);\n\t\t\tdumpvals(kw);\n\t\t\t}\n\t\tif (kw->kind & (KWKind_Lb|KWKind_Ub))\n\t\t\tvalcheck(kw);\n\t\tif (kw->f.start)\n\t\t\t(*kw->f.start)(kw->name, &KWval, &kwi->g, kw->f.vs);\n\t\telse if ((kw->kind & (KWKind_Libname | KWKind_Loaded)) == KWKind_Libname) {\n\t\t\tread_lib(KWval.s[0], kw);\n\t\t\tkw = kw_setup(kw, kwi->g, kw->name);\n\t\t\tif (kw->f.start)\n\t\t\t\t(*kw->f.start)(kw->name, &KWval, &kwi->g, kw->f.vs);\n\t\t\tif (kw == kwi->kw) {\n\t\t\t\t*kwi = *KWStack;\n\t\t\t\t--KWStack;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tkwi = KWStack;\n\t\t\t}\n\t\tKWval.n = 0;\n\t\t}\n\telse if ((kw->kind & (KWKind_Libname|KWKind_Loaded))\n\t\t\t  != (KWKind_Libname|KWKind_Loaded))\n\t\tsquawk(\"expected %sone %s value for %s\",\n\t\t\tkw->kind & KWKind_List ? \"at least \" : \"\",\n\t\t\tvalkind[(kw->kind & KWKind_Mask)-1], kw->name);\n\t++dumplev;\n\treturn kwi;\n\t}\n\n static void\noneof(KeyWord *kw, int alt, int n)\n{\n\tKeyWord *kw1;\n\n\tsquawk(\"One of the following %d entities\\nmust be specified for %s..\",\n\t\tn, kw->name);\n\tfor(kw1 = kw->kw; !kw1->name; kw1 = kw1->kwnext);\n\tfor(; kw1; kw1 = kw1->kwnext)\n\t\tif (kw1->alt == alt && kw1->kind & KWKind_primary)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", kw1->name);\n\t}\n\n static void\nmissing_chk(KeyWord *kw1, KWinfo *kwi)\n{\n\tKeyWord *kw0, *kw2, **req;\n\tUint a;\n\tchar seen0[1024], *seen;\n\tconst char *kwname;\n\tint n;\n\tsize_t nreq;\n\n\t/* only issue one error message per missing keyword */\n\n\tnreq = 0;\n\tfor(kw0 = kw1; kw1; kw1 = kw1->kwnext)\n\t\tif (nreq < kw1->req)\n\t\t\tnreq = kw1->req;\n\tseen = seen0;\n\tif (++nreq > sizeof(seen0))\n\t\tseen = (char*)Alloc(\"missing_chk\", nreq);\n\tmemset(seen, 0, nreq);\n\treq = kwi->req;\n\tfor(kw1 = kw0; kw1; kw1 = kw1->kwnext) {\n\t\tif (kw1->req && req[kw1->req] && !seen[kw1->req] && kw1->kind & KWKind_primary) {\n\t\t\tseen[kw1->req] = 1;\n\t\t\ta = -1;\n\t\t\tif (!kw1->alt || (n = kwi->altct[a = kw1->alt]) <= 1) {\n\t\t\t\tif (!(kwname = kwi->name))\n\t\t\t\t\tkwname = \"<NIDRBUG>\";\n\t\t\t\tfor(kw2 = kw1;;) {\n\t\t\t\t\tif (kw2->alt == a && kw2->kind & KWKind_primary)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(kw2 = kw2->kwnext))\n\t\t\t\t\t\tbotch(\"Bug in missing_chk\");\n\t\t\t\t\t}\n\t\t\t\tsquawk(\"%s must be specified for %s\",\n\t\t\t\t\tkw2->name, kwname);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\toneof(kwi->kw, kw1->alt, n);\n\t\t\t}\n\t\t}\n\tif (seen != seen0)\n\t\tfree(seen);\n\t}\n\n static void\nfinalize(KWinfo *kwi)\n{\n\tKeyWord *kw, *kw1, **req;\n\n\tkw = kwi->kw;\n\tkw->kind &= ~KWKind_Stacked;\n\tif (kwi->needstart)\n\t\tkwi = dispatch_val(kwi);\n\tif (kw->name)\n\t\t--dumplev;\n\tif (kw->f.final)\n\t\t(*kw->f.final)(kw->name, 0, &kwi->g, kw->f.vf);\n\tif (kwi->alt) {\n\t\tif (kwi->nreq) {\n\t\t\treq = kwi->req;\n\t\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\t\tif (kw1->req && req[kw1->req]) {\n\t\t\t\t\tmissing_chk(kw1, kwi);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tfree(kwi->alt);\n\t\t}\n\t}\n\n static KeyWord *\nnidr_identifier_strict(const char *name)\n{\n\tKWinfo *kwi, *kwi1;\n\tKeyWord *kw, *kw1;\n\tint nmatch;\n\tsize_t height;\n\n\tif (!curkw)\n\t\tbotch(\"curkw = 0 in nidr_identifier\");\n\tkwi = KWStack;\n\tif (kwi->needstart)\n\t\tkwi = dispatch_val(kwi);\n\tfor(kwi1 = kwi;;) {\n\t\tkw1 = kwi->kw;\n\t\tif ((kw = kwfind(name, kwi->kw1, kw1->nkw, &nmatch)))\n\t\t\tbreak;\n\t\tif (kwi == KWStackBot)\n\t\t\treturn 0;\n\t\tif ((--kwi)->kw->name && !(kwi->kw->kind & KWKind_Loaded))\n\t\t\tkwi1 = kwi;\n\t\t}\n\tif (nmatch > 1)\n\t\treturn toomany(name, kw, nmatch);\n\twhile(KWStack > kwi1)\n\t\tfinalize(KWStack--);\n\tif ((kw->kind & (KWKind_Libname | KWKind_Loaded)) == KWKind_Libname) {\n\t\tnidr_id_strict_finish(kwi, kw, name);\n\t\tif (!KWvalmax.r)\n\t\t\tKWvalbuf = (Real *)Alloc(\"nidr_identifier_strict\",\n\t\t\t\t\t\t(nKWvalbuf = 128)*sizeof(Real));\n\t\tif (++KWStack >= KWStackEnd)\n\t\t\tKWStack_inc();\n\t\tkwi = KWStack;\n\t\tkwi->kw = kw;\n\t\tkwi->needstart = 1;\n\t\tKWval.s = (const char**)KWvalbuf;\n\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t}\n\telse {\n\t\theight = kwi - KWStackBot;\n\t\tkw = kw_setup(kw, kwi->g, name);\n\t\tkwi = KWStackBot + height; /* in case kw_setup reallocated KWStack */\n\t\tnidr_id_strict_finish(kwi, kw, name);\n\t\t}\n\treturn kw;\n\t}\n\n static void\nnidr_keyword_finish(void)\n{\n\tif (!strict)\n\t\tkw_finish2();\n\tfor(;;--KWStack) {\n\t\tfinalize(KWStack);\n\t\tif (KWStack == KWStackBot)\n\t\t\tbreak;\n\t\t}\n\tif (!strict)\n\t\tkw_finish3();\n\tcurid = curkw = 0;\n\t}\n\n const char*\nnidr_keyword_name(void)\n{ return curkw ? curkw->name : \"<none>\"; }\n\n/* Some of the above assumes strict nesting according to dakota.input.nspec. */\n/* Code here is meant to relax this assumption, allowing more flexibility in */\n/* the order of identifiers within a DAKOTA \"keyword\". */\n\n typedef struct KWpair KWpair;\n typedef struct KWmblk KWmblk;\n\n struct\nKWmblk {\n\tKWmblk *next;\n\tsize_t len;\n\t/* memory of length len immediately follows */\n\t};\n\n struct\nKWpair {\n\tKeyWord *kw;\n\tKWseen *kws;\n\t};\n\n enum{ KWmblk_gulp = 32000 };\n\n static AVL_Tree *AVLT, *AVLKWP;\n static KWseen **KW_p, **KW_pe, KWmissing, *KWs0;\n static KWmblk *KWmblk0, *KWmblk1;\n static const char *KWmem0, *KWmem1;\n\n typedef struct\nAVLCmpInfo {\n\tKWseen **found[2];\n\tint nfound;\n\tint inexact;\n\t} AVLCmpInfo;\n\n static int\navlcmp(void *v, KWseen **a, KWseen **b)\n{\n\tAVLCmpInfo *AI = (AVLCmpInfo*)v;\n\tKWseen *ksa, *ksb;\n\tconst char *s, *t;\n\n\ts = (ksa = *a)->name;\n\tt = (ksb = *b)->name;\n\tfor(; *s == *t; ++s, ++t)\n\t\tif (!*s)\n\t\t\treturn 0;\n\tif ((!*s && !ksa->kw && ksb->kw)\n\t  ||(!*t && !ksb->kw && ksa->kw)) {\n\t\t/* inexact match */\n\t\tif (AI->nfound == 0\n\t\t|| (AI->nfound == 1 && AI->found[0] != b))\n\t\t\tAI->found[AI->nfound++] = b;\n\t\treturn AI->inexact;\n\t\t}\n\treturn *s - *t;\n\t}\n\n static int\nkwpcmp(void *v, KWpair *a, KWpair *b)\n{\n\tif (a->kw == b->kw)\n\t\treturn 0;\n\treturn a->kw > b->kw ? 1 : -1;\n\t}\n\n static void\nKWmeminit(void)\n{\n\tKWmblk0 = KWmblk1 = (KWmblk*)Alloc(\"KWmeminit\",\n\t\t\tsizeof(KWmblk) + KWmblk_gulp);\n\tKWmem0 = (char*)(KWmblk0 + 1);\n\tKWmem1 = KWmem0 + KWmblk_gulp;\n\tKWmblk0->len = KWmblk_gulp;\n\tKWmblk0->next = 0;\n\tKWmissing.mnext = KWmissing.mprev = &KWmissing;\n\tKW_cur = 0;\n\tmemset(&KWval, 0, sizeof(KWval));\n\tKWvalbuf = (Real *)Alloc(\"kw_setup(KWValbuf)\", (nKWvalbuf = 128)*sizeof(Real));\n\tToClear = ToClear0 = (KeyWord**)Alloc(\"kw_setup(ToClear)\", 256*sizeof(KeyWord*));\n\tToClearEnd = ToClear0 + 256;\n\t}\n\n static void\nKWmembump(size_t L)\n{\n\tKWmblk *mb, *mb1;\n\tsize_t L1;\n\n\tfor(L1 = KWmblk_gulp; L1 < L; L1 <<= 1);\n\tif ((mb = mb1 = KWmblk1->next) && L1 <= mb->len)\n\t\tL1 = mb->len;\n\telse {\n\t\tKWmblk1->next = mb = (KWmblk*)Alloc(\"KWmembump\", L1 + sizeof(KWmblk));\n\t\tmb->len = L1;\n\t\tmb->next = mb1;\n\t\t}\n\tKWmblk1 = mb;\n\tKWmem0 = (char*)(mb+1);\n\tKWmem1 = KWmem0 + L1;\n\t}\n\n static void *\nKWgetmem(size_t L)\t/* for aligned memory */\n{\n\tvoid *rv;\n\n\tL = (L + sizeof(Real) - 1) & ~(sizeof(Real) - 1);\n\tif (KWmem1 - KWmem0 < L)\n\t\tKWmembump(L);\n\trv = (void*)KWmem0;\n\tKWmem0 += L;\n\treturn rv;\n\t}\n\n static KWseen **\nKWhash(const char *s, KeyWord *kw)\n{\n\tAVLCmpInfo AI;\n\tKWseen KW0, *KW0p, *kws, **kwsp;\n\tchar **ps;\n\tconst char *sa, *sb;\n\n\tAI.nfound = 0;\n\tAI.inexact = -1;\n\tAVL_setv(AVLT, &AI);\n\tKW0.name = s;\n\tKW0.kw = kw;\n\tKW0p = &KW0;\n\tcurkws = 0;\n\tif ((kwsp = (KWseen**)AVL_find((const Element*)&KW0p, AVLT)))\n\t\treturn kwsp;\n\tif (AI.nfound) {\n\t\tif (AI.nfound == 1) {\n\t\t\tAI.inexact = 1;\n\t\t\tAVL_find((const Element*)&KW0p, AVLT);\n\t\t\tif (AI.nfound == 1) {\n\t\t\t\tif (kw && (kw->kind & (KWKind_Libname | KWKind_Loaded))\n\t\t\t\t\t\t== KWKind_Libname\n\t\t\t\t && (ps = (*AI.found[0])->svals))\n\t\t\t\t\tread_lib(ps[0], kw);\n\t\t\t\treturn AI.found[0];\n\t\t\t\t}\n\t\t\t}\n\t\tsa = (*AI.found[0])->name;\n\t\tsb = (*AI.found[1])->name;\n\t\tif (kw)\n\t\t\tsquawk(\"Both '%s' and '%s' match '%s'\",\n\t\t\t\tsa, sb, s);\n\t\telse\n\t\t\tsquawk(\"'%s' is ambiguous:\\n\\tit matches both '%s' and '%s'\",\n\t\t\t\ts, sa, sb);\n\t\treturn AI.found[0];\n\t\t}\n\tkws = (KWseen*)KWgetmem(sizeof(KWseen));\n\tmemset(kws, 0, sizeof(KWseen));\n\tif ((kws->kw = kw))\n\t\ts = kw->name;\n\telse {\n\t\tcurkws = kws;\n\t\tkws->mnext = &KWmissing;\n\t\tKWmissing.mprev = (kws->mprev = KWmissing.mprev)->mnext = kws;\n\t\ts = nidr_KWscopy(s);\n\t\t}\n\tkws->name = s;\n\tif (KW_p >= KW_pe) {\n\t\tKW_p = (KWseen**)KWgetmem(32*sizeof(KWseen*));\n\t\tKW_pe = KW_p + 32;\n\t\t}\n\t*(kwsp = KW_p++) = kws;\n\tAVL_insert((const Element*)kwsp, AVLT);\n\treturn kwsp;\n\t}\n\n static void\nmixed_squawk(void)\n{\n\tsquawk(\"values for %s cannot be both strings and numbers\",\n\t\tKW_cur->name);\n\t}\n\n static void\nnidr_bufr_relaxed(Real r, int state)\n{\n\tint n;\n\n\tif (KWval.rstate && !state)\n\t\tfinish_rexpand();\n\tif (!(n = KWval.n)) {\n\t\tKWval.r = KWvalbuf;\n\t\tKWvalmax.r = KWvalbuf + (KWvalmax.n = nKWvalbuf);\n\t\t}\n\telse if (KWval.s) {\n\t\tmixed_squawk();\n\t\treturn;\n\t\t}\n\tif (n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.r[KWval.n++] = r;\n\tif (state | KWval.rstate)\n\t\trexpand(state);\n\t}\n\n static void\nnidr_bufs_relaxed(const char *s)\n{\n\tint n;\n\n\tif (!(n = KWval.n)) {\n\t\tKWval.s = (const char**)KWvalbuf;\n\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t}\n\telse if (KWval.r) {\n\t\tmixed_squawk();\n\t\treturn;\n\t\t}\n\tif (n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.s[KWval.n++] = s;\n\t}\n\n static void kw_setup2(KWseen*);\n\n static void\nkw_finish1(KWseen *kws)\n{\n\tKeyWord *kw;\n\tint n;\n\tsize_t L;\n\n\tif (KWval.rstate)\n\t\tfinish_rexpand();\n\tkws->nvals = n = KWval.n;\n\tKWval.n = 0;\n\tif (KWval.r) {\n\t\tL = n*sizeof(Real);\n\t\tmemcpy(kws->rvals = (Real*)KWgetmem(L), KWval.r, L);\n\t\tKWval.r = 0;\n\t\t}\n\telse if (KWval.s) {\n\t\tL = n*sizeof(char*);\n\t\tmemcpy(kws->svals = (char**)KWgetmem(L), KWval.s, L);\n\t\tif ((kw = kws->kw) && kw->kind & KWKind_Libname) {\n\t\t\tread_lib(KWval.s[0], kw);\n\t\t\tif (kw->kw)\n\t\t\t\tkw_setup2(kws);\n\t\t\t}\n\t\tKWval.s = 0;\n\t\t}\n\t}\n\n static void*\nAlloc1(size_t len)\n{\n\tvoid *rv = malloc(len);\n\tif (!rv) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in Alloc1\\n\", (unsigned long)len);\n\t\texit(1);\n\t\t}\n\treturn rv;\n\t}\n\n static void\nAVL_Clear(void)\n{\n\twhile(ToClear > ToClear0)\n\t\t(*--ToClear)->kind &= ~KWKind_Hashed;\n\tAVL_Tree_free(&AVLT);\n\tif (AVLKWP)\n\t\tAVL_Tree_free(&AVLKWP);\n\t}\n\n static void\nkw_setup1(KeyWord *kw)\n{\n\tKWseen *kws, *kws1;\n\tKeyWord *kw1;\n\n\tif ((kw1 = kw->kw))\n\t\tkwnext_setup(kw1, kw->nkw);\n\tif (!KWmblk0)\n\t\tKWmeminit();\n\tif (AVLT)\n\t\tAVL_Clear();\n\tAVLT = AVL_Tree_alloc(0, (AVL_Elcomp)avlcmp, Alloc1);\n\tKW_cur = KWs0 = kws = (KWseen*)KWgetmem(sizeof(KWseen));\n\tmemset(kws, 0, sizeof(KWseen));\n\tkws->name = kw->name;\n\tkws->kw = kw;\n\tkws->lcn = &kws->mprev;\n\tif (kw1) {\n\t\twhile(!kw1->name)\n\t\t\tkw1 = kw1->kwnext;\n\t\tfor(; kw1; kw1 = kw1->kwnext) {\n\t\t\tkws1 = *KWhash(kw1->name, kw1);\n\t\t\tkws1->parent = kws;\n\t\t\t}\n\t\t}\n\t}\n\n static KWseen**\nkw_setup3(KWseen **kwtodo1, KWseen *kws, KeyWord *kw)\n{\n\tKWseen *kws1, **kwsp;\n\n\tfor(; kw; kw = kw->kwnext) {\n\t\tkwsp = KWhash(kw->name, kw);\n\t\tkws1 = *kwsp;\n\t\tif (kws1->comment) {\n\t\t\tkw->comment = kws1->comment;\n\t\t\tkws1->comment = 0;\n\t\t\t}\n\t\tif (kws1->parent) {\n\t\t\tkws1 = (KWseen*)KWgetmem(sizeof(KWseen));\n\t\t\tmemset(kws1, 0, sizeof(KWseen));\n\t\t\tkws1->kw = kw;\n\t\t\tkws1->name = kw->name;\n\t\t\t*kwsp = kws1;\n\t\t\t}\n\t\tkws1->parent = kws;\n\t\tif (!kws1->kw) {\n\t\t\tkws1->mprev->mnext = kws1->mnext;\n\t\t\tkws1->mnext->mprev = kws1->mprev;\n\t\t\t*kwtodo1 = kws1;\n\t\t\tkwtodo1 = kws1->lcn = &kws1->mprev;\n\t\t\t*kws->lcn = kws1;\n\t\t\tkws->lcn = &kws1->mnext;\n\t\t\t}\n\t\tkws1->kw = kw;\n\t\t}\n\treturn kwtodo1;\n\t}\n\n static void\nbumpToClear(void)\n{\n\tKeyWord **ntc;\n\tsize_t L, L1;\n\n\tL = ToClearEnd - ToClear0;\n\tL1 = L << 1;\n\tntc = (KeyWord**)Alloc(\"bumpToClear\", L1*sizeof(KeyWord*));\n\tmemcpy(ntc, ToClear0, L*sizeof(KeyWord*));\n\tfree(ToClear0);\n\tToClear0 = ntc;\n\tToClear  = ntc + L;\n\tToClearEnd = ntc + L1;\n\t}\n\n static void\nkw_setup2(KWseen *kws)\n{\n\tKWpair kwp, *pkwp;\n\tKWseen *kws1, *kws2, *kws3, *kwtodo, **kwtodo1, **pkws;\n\tKeyWord *kw, *kw1;\n\n\tkwtodo1 = &kwtodo;\n\tfor(;;) {\n\t\tkw = kws->kw;\n\t\tif ((kw1 = kw->kw)) {\n\t\t\tkwnext_setup(kw1, kw->nkw);\n\t\t\tkws2 = kws;\n\t\t\twhile(!kw1->name) {\n\t\t\t\tif (!AVLKWP)\n\t\t\t\t\tAVLKWP = AVL_Tree_alloc(0, (AVL_Elcomp)kwpcmp, Alloc1);\n\t\t\t\tif (kw1->kind & KWKind_Hashed) {\n\t\t\t\t\tkwp.kw = kw1->kw;\n\t\t\t\t\tkwp.kws = 0;\n\t\t\t\t\tpkwp = (KWpair*)AVL_find((const Element*)&kwp, AVLKWP);\n\t\t\t\t\tkws2 = pkwp->kws;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ToClear >= ToClearEnd)\n\t\t\t\t\t\tbumpToClear();\n\t\t\t\t\t*ToClear++ = kw1;\n\t\t\t\t\tkw1->kind |= KWKind_Hashed;\n\t\t\t\t\tpkwp = (KWpair*)KWgetmem(sizeof(KWpair) + sizeof(KWseen));\n\t\t\t\t\tkws1 = (KWseen*)(pkwp + 1);\n\t\t\t\t\tpkwp->kw = kw1->kw;\n\t\t\t\t\tpkwp->kws = kws1;\n\t\t\t\t\tmemset(kws1, 0, sizeof(KWseen));\n\t\t\t\t\tkws1->kw = kw1;\n\t\t\t\t\tkws1->name = kws->name;\n\t\t\t\t\tkws1->lcn = &kws1->mprev;\n\t\t\t\t\tkws1->parent = kws2;\n\t\t\t\t\t*kws2->lcn = 0;\n\t\t\t\t\tfor(pkws = &kws2->mprev;\n\t\t\t\t\t\t(kws3 = *pkws) && !kws3->name;\n\t\t\t\t\t\tpkws = &kws3->mnext);\n\t\t\t\t\tkws1->mnext = *pkws;\n\t\t\t\t\tif (pkws == kws2->lcn)\n\t\t\t\t\t\tkws2->lcn = &kws1->mnext;\n\t\t\t\t\tkws2 = *pkws = kws1;\n\t\t\t\t\tkwnext_setup(kw1->kw, kw1->nkw);\n\t\t\t\t\tkwtodo1 = kw_setup3(kwtodo1, kws1, kw1->kw);\n\t\t\t\t\tAVL_insert((const Element*)pkwp, AVLKWP);\n\t\t\t\t\t}\n\t\t\t\tkw1 = kw1->kwnext;\n\t\t\t\t}\n\t\t\tif (kw->nkw)\n\t\t\t\tkwtodo1 = kw_setup3(kwtodo1, kws2, kw1);\n\t\t\t}\n\t\t*kwtodo1 = 0;\n\t\tif (!kwtodo)\n\t\t\tbreak;\n\t\tkws = kwtodo;\n\t\tkw = kws->kw;\n\t\tif (!(kwtodo = kwtodo->mprev))\n\t\t\tkwtodo1 = &kwtodo;\n\t\t}\n\t}\n\n static KeyWord *\nnidr_identifier_relaxed(const char *name)\n{\n\tKWseen *kws, *kws1;\n\tKeyWord *kw;\n\tint tryagain;\n\n\tkw_finish1(KW_cur);\n top:\n\tKW_cur = kws = *KWhash(name, 0);\n\tif ((kw = kws->kw)) {\n\t\tcurid = kw;\n\t\tif (kws->lcn)\n\t\t\tsquawk(\"'%s' already seen\", kw->name);\n\t\telse {\n\t\t\tif (kws->comment) {\n\t\t\t\tkw->comment = kws->comment;\n\t\t\t\tkws->comment = 0;\n\t\t\t\t}\n\t\t\tkws->lcn = &kws->mprev;\n\t\t\tkws1 = kws->parent;\n\t\t\t*kws1->lcn = kws;\n\t\t\tkws1->lcn = &kws->mnext;\n\t\t\tif (kw->kw)\n\t\t\t\tkw_setup2(kws);\n\t\t\tif (kw->kind & KWKind_Dynlib) {\n\t\t\t\tkw = kw_insert(kw, &tryagain);\n\t\t\t\tif (kw->kw) {\n\t\t\t\t\tkws->kw = kw;\n\t\t\t\t\tkw_setup2(kws);\n\t\t\t\t\t}\n\t\t\t\tif (tryagain)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn (KeyWord*)kws;\t/* just needs to be nonzero; won't be dereferenced */\n\t}\n\n static void\nnum_expected(KeyWord *kw, int n)\n{\n\tsquawk(\"expected numerical value%s for %s, not quoted strings\",\n\t\t\"s\" + (n == 1), kw->name);\n\t}\n\n static void\nkw_process(KWseen *kws)\n{\n\tKWseen *kws1;\n\tKeyWord *kw;\n\tReal *r;\n\tUint k;\n\tint i, n;\n\n\tkw = kws->kw;\n\tif (kw->name) {\n\t\tif (kws != KWs0 && !nidr_identifier_strict(kw->name))\n\t\t\tbotch(\"nidr_identifier_strict did not find \\\"%s\\\"\", kw->name);\n\t\tif ((n = KWval.n = kws->nvals)) {\n\t\t\tKWval.i = 0;\n\t\t\tKWval.r = 0;\n\t\t\tKWval.s = 0;\n\t\t\tKWval.rstate = 0;\n\t\t\tswitch(k = kw->kind & KWKind_Mask) {\n\t\t\t  case 0:\n\t\t\t\tsquawk(\"No values may be specified for %s\", kw->name);\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Int:\n\t\t\t\tif (!(r = kws->rvals)) {\n\t\t\t\t\tnum_expected(kw,n);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tKWval.i = (int*)KWvalbuf;\n\t\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\t\tKWval.i[i] = (int)r[i];\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Real:\n\t\t\t\tif (!(r = kws->rvals)) {\n\t\t\t\t\tnum_expected(kw,n);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tKWval.r = r;\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Str:\n\t\t\t\tif (!(KWval.s = (const char **)kws->svals))\n\t\t\t\t\tsquawk(\"expected string value%s for %s\",\n\t\t\t\t\t\t\"s\" + (n == 1), kw->name);\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t*kws->lcn = 0;\n\tfor(kws1 = kws->mprev; kws1; kws1 = kws1->mnext)\n\t\tkw_process(kws1);\n\t}\n\n static void\nkw_finish2(void)\n{\n\tKWseen *kws, *kwe;\n\n\tkw_finish1(KW_cur);\n\tkwe = &KWmissing;\n\tfor(kws = KWmissing.mnext; kws != kwe; kws = kws->mnext) {\n\t\tsquawk(\"unrecognized identifier '%s'\", kws->name);\n\t\t}\n\tKWmissing.mnext = KWmissing.mprev = &KWmissing;\n\tkw_process(KWs0);\n\tKWs0 = 0;\n\tAVL_Clear();\n\t}\n\n static void\nkw_finish3(void)\n{\n\tKWmblk1 = KWmblk0;\n\tKWmem0 = (char*)(KWmblk0 + 1);\n\tKWmem1 = KWmem0 + KWmblk_gulp;\n\tKW_p = KW_pe = 0;\n\t}\n\n void (*nidr_bufr)(Real,int) = nidr_bufr_relaxed;\n void (*nidr_bufs)(const char*) = nidr_bufs_relaxed;\n KeyWord *(*nidr_identifier)(const char*) = nidr_identifier_relaxed;\n\n void\nnidr_set_strict(int n)\n{\n\tif ((strict = n)) {\n\t\tnidr_bufr = nidr_bufr_strict;\n\t\tnidr_bufs = nidr_bufs_strict;\n\t\tnidr_identifier = nidr_identifier_strict;\n\t\t}\n\telse {\n\t\tnidr_bufr = nidr_bufr_relaxed;\n\t\tnidr_bufs = nidr_bufs_relaxed;\n\t\tnidr_identifier = nidr_identifier_relaxed;\n\t\t}\n\t}\n\n int\nnidr_cleanup(void)\n{\n\tKWmblk *mb, *mb1;\n\tSbuf *sb, *sb1;\n\n\tif (curkw)\n\t\tnidr_keyword_finish();\n\tif (dumpfile) {\n\t\tif (OutsideComment)\n\t\t\tdumpcomment(&OutsideComment);\n\t\tif (dumpfile != stdout) {\n\t\t\tfclose(dumpfile);\n\t\t\tdumpfile = 0;\n\t\t\t}\n\t\tif (nidr_comment)\n\t\t\tcomment_reset();\n\t\t}\n\tif (ToClear0) {\n\t\tfree(ToClear0);\n\t\tToClear = ToClear0 = 0;\n\t\t}\n\tif ((mb1 = KWmblk0)) {\n\t\tKWmblk0 = 0;\n\t\tdo {\n\t\t\tmb = mb1;\n\t\t\tmb1 = mb->next;\n\t\t\tfree(mb);\n\t\t\t} while(mb1);\n\t\t}\n\tif (KWvalbuf) {\n\t\tfree(KWvalbuf);\n\t\tKWvalbuf = 0;\n\t\t}\n\tif ((sb1 = KWsbuf0.next)) {\n\t\tKWsbuf0.next = 0;\n\t\tdo {\n\t\t\tsb = sb1;\n\t\t\tsb1 = sb->next;\n\t\t\tfree(sb);\n\t\t\t} while(sb1);\n\t\t}\n\tif (AVLT)\n\t\tAVL_Clear();\n\treturn nidr_parse_error();\n\t}\n\n void\nnidr_setup(const char *parser, FILE *df)\n{\n\tconst char *s;\n\tint comkeep, oneline;\n\n\tif (!(s = parser))\n\t\treturn;\n\tif (!strncmp(s,\"nidr\",4))\n\t\ts += 4;\n\tif (!strncmp(parser,\"strict\",6)) {\n\t\tnidr_set_strict(1);\n\t\ts += 6;\n\t\t}\n\tcomkeep = oneline = 0;\n\tif (*s == '-') for(;;) {\n\t\tswitch(*++s) {\n\t\t  case '1':\n\t\t\t++oneline;\n\t\t\tcontinue;\n\t\t  case 'p':\n\t\t\t++primary;\n\t\t\tcontinue;\n\t\t  case 'c':\n\t\t\t++comkeep;\n\t\t\tcontinue;\n\t\t  }\n\t\tbreak;\n\t\t}\n\tif (df)\n\t\tdumpfile = df;\n\telse if (s[0] == ':' && s[1]) {\n\t\tif (s[1] == '-' && !s[2])\n\t\t\tdumpfile = df = stdout;\n\t\telse {\n\t\t\tdumpfile = df = fopen(++s,\"w\");\n\t\t\tif (!dumpfile) {\n\t\t\t\tfprintf(stderr, \"Cannot open \\\"%s\\\"\\n\", s);\n\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (df) {\n\t\tif (oneline)\n\t\t\tdumpvals = dumpvals1;\n\t\tif (comkeep)\n\t\t\tcomment_setup();\n\t\t}\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/nidrgen.l": "%{\n/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"nidr.h\"\t/* for KeyWordKind */\n\n#ifndef NO_NIDR_DYNLIB\ntypedef KeyWord *(*KW_ADD)(void);\n#ifdef _WIN32\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#endif\n\n#ifndef DMBLK_GULP\n#define DMBLK_GULP 1024\n#endif\n#ifndef DMLBK_SGULP\n#define DMBLK_SGULP 16000\n#endif\n#ifndef MBLK_GULP\n#define MBLK_GULP 8191\n#endif\n#ifndef KWSTACKLEN\n#define KWSTACKLEN 100\t/*should be overkill*/\n#endif\n#ifndef DEFTAGLEN\n#define DEFTAGLEN 2048\t/* should be overkill*/\n#endif\n\n typedef union\nYYSTYPE { char *s; } YYSTYPE;\n\n enum LastSeen {\n\tSaw_kwname\t= 1,\n\tSaw_type\t= 2,\n\tSaw_func\t= 3,\n\tSaw_dflt\t= 4,\n\tSaw_dfltname\t= 5,\n\tSaw_lt\t\t= 6,\n\tSaw_le\t\t= 7,\n\tSaw_ge\t\t= 8,\n\tSaw_gt\t\t= 9,\n\tSaw_desc\t= 10,\n\tSaw_group\t= 11,\n\tSaw_tag\t\t= 12,\n\tSaw_len\t\t= 13,\n\tSaw_dy\t\t= 14\n\t};\n\n static const char *tokname[] = {\n\t\"<bug>\",\n\t\"kwname\",\n\t\"type\",\n\t\"{funcspec}\",\n\t\":=\",\n\t\"#define name for :=\",\n\t\"<\",\n\t\"<=\",\n\t\">=\",\n\t\">\",\n\t\"DESC\",\n\t\"GROUP\",\n\t\"TAG\",\n\t\"LEN\"\n\t};\n\n enum ParState {\n\t/* parstate values... */\n\tPPar_emtpy\t= 0,\n\tPPar_starting\t= 1,\n\tPPar_started\t= 2,\n\tPPar_leftpar\t= 3,\n\tDupchecking\t= 4,\n\tDupchecked\t= 5,\n\tPrinting\t= 6,\n\tKwStacked\t= 7,\n\tSorted\t\t= 8,\n\tLeftput\t\t= 9,\n\tParchecked\t= 10\n\t};\n\n /* values for lastseen also include single characters ( [ { } ] ) ; */\n\n /* enums to make constants visible to debuggers */\n enum {\n\tDMblk_gulp\t= DMBLK_GULP,\n\tDmblk_sgulp\t= DMBLK_SGULP,\n\tMblk_gulp\t= MBLK_GULP,\n\tKW_stacklen\t= KWSTACKLEN,\n\tBr_stacklen\t= 2*KW_stacklen,\n\tDHTlen\t\t= 997,\n\tDHTfactor\t= 43,\n\tHTlen\t\t= 127,\n\tKWPlen\t\t= 32,\n\tKWOUTlen0\t= 128 };\n\n typedef struct Defhash Defhash;\n typedef struct DefhashHead DefhashHead;\n typedef struct DefhashTab DefhashTab;\n typedef struct HashHead HashHead;\n typedef struct KWctx KWctx;\n typedef struct Mblk Mblk;\n typedef struct Taghash Taghash;\n typedef struct StrList StrList;\n\n struct\nDefhashHead {\n\tDefhashHead *hnext, *thread;\n\tchar *name;\n\t};\n\n struct\nDefhash {\n\tDefhashHead hh;\n\tchar *value;\n\tint qkeep;\n\t};\n\n struct\nTaghash {\n\tDefhashHead hh;\n\tKWctx *kw;\n\tint uses;\n\t};\n\n struct\nDefhashTab {\n\tDefhashHead *Tab[DHTlen];\n\tDefhashHead *lastdh;\n\tsize_t nalloc;\t/* size of new entry allocations in units of sizeof(void*) */\n\tint nent;\n\t};\n\n struct\nMblk {\n\tMblk *next;\n\tvoid *stuff[Mblk_gulp];\n\t};\n\n struct\nHashHead { HashHead *hnext, *hprev; };\n\n struct\nStrList {\n\tHashHead h;\n\tStrList *next;\n\tchar *val;\n\tint Lineno;\n\tint primary;\n\tint seqno;\n\tint needrev;\n\t};\n\n struct\nKWctx {\n\tKWctx *next;\n\tStrList *names;\t/* list of name and aliases */\n\tchar *name1;\t/* first name (for tagout) */\n\tKWctx *kw;\t/* list of contained keywords */\n\tKWctx *master;\t/* non-null ==> this is an alias; use master's kwkno */\n\tKWctx *pmaster;\t/* used in computing paoff */\n\tKWctx *pparent;\t/* paren parent, for ((...)|(...) ...) */\n\tKWctx *rparent;\t/* \"real\" parent, for stuff inside ((...)) */\n\tStrList *funcs;\t/* pre- and post order functions and (void*) args */\n\tchar *Br_top;\t/* Br_top when this keyword began */\n\tchar *lb;\t/* lower bound (if kind & KWKind_Lb is nonzero) */\n\tchar *ub;\t/* upper bound (if kind & KWKind_Ub is nonzero) */\n\tchar *init;\t/* initial value (if kind & KWKind_init is nonzero) and */\n\t\t\t/* kind & KWKind_Mask is 1 or 2 (KWKind_Int or KWKind_Real) */\n\tchar *cinit;\t/* initial value for STRING-valued keyword,\t*/\n\t\t\t/* ==> (kind & (KWKind_Mask | KWKind_init))\t*/\n\t\t\t/*\t== (KWKind_Str | KWKind_init)\t\t*/\n\tchar *defname;\t/* name of preprocessor token to be #defined */\n\tchar *desc;\n\tchar *dylib;\n\tchar *group;\n\tchar *tag;\n\tchar *len;\t/* keyword giving array length */\n\tsize_t dtnext;\t/* for adjusting deftag when this keyword goes out of scope */\n\tsize_t name1len;\n\tint alt;\t/* alternative group number of this keyword */\n\tint kind;\t/* kind of values for this keyword */\n\tint kno;\t/* number of this keyword, for generating kw_n names */\n\tint kwkno;\t/* number of this keyword's kw array (if any) */\n\tint kwknop;\t/* if this is a pparent and has a pparent, kwkno for this and parents */\n\tint nalt;\t/* number of alternative groups in contained keywords */\n\tint nfcn;\t/* number of function and arg entries in funcs */\n\tint nkw;\t/* number of contained keywords */\n\tint nreq;\t/* number of required elements in contained keywords */\n\tint req;\t/* required group for this keyword (0 if optional) */\n\tenum ParState parstate;\t/* state in handling ((...)) */\n\tint altoffset;\t/* for expand */\n\tint reqoffset;\t/* for expand */\n\tint level;\n\tint objno;\t/* for kwcomp2 */\n\tint agroup;\t/* for GuiKeyWord */\n\tint paoff;\t/* offset of primary keyword */\n\t};\n\n static int lastagroup, lastobjno, nalias, seqno;\n\n Defhash *lastdef;\n DefhashTab DHTab, TagTab;\n FILE *mtagout, *tagin, *tagout;\n HashHead HTab[HTlen];\n KWctx KWbase, *lastkw, *lastkw1;\n KWctx *KWStack[KW_stacklen], **KWtop = KWStack;\n Mblk FirstMblk, *CurMblk = &FirstMblk;\n YYSTYPE yyval;\n char Br_stack[Br_stacklen], *Br_top = Br_stack;\n char deftag[DEFTAGLEN], *dtend = deftag + DEFTAGLEN - 2, *dtnext = deftag;\n char *infname, *lasttag, *progname, *specfile, *tagfname;\n int Lineno = 1, dfltgroup = 1, startwarn = 1, wantfuncs = 1;\n int brace, btype, dupnames, dynlibseen, dynline, expand, guikeywds, ignoretags;\n int kwmult, lastkno, lastseen, liberror, libexpand, missing, needcomma, nsquawk;\n int or_mode, saweof;\n size_t mbavail = Mblk_gulp;\n void **mbnext = FirstMblk.stuff;\n static void Eat_comment(void);\n static void Keywd(const char *);\n static void Saw_num(const char*);\n static void Saw_quote(void);\n static void Saw_tok(int, int);\n\n /* Possible values for *Br_top:\n //\t 0  ==> empty (for Br_stack[0] only)\n //\t'(' ==> open paren seen, awaiting ')'\n //\t'[' ==> open square bracket, awaiting ']'\n */\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s:\\n\\tbotch on line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s: line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\t++nsquawk;\n\t}\n\n static void*\nMalloc(size_t L, const char *where)\n{\n\tvoid *rv = malloc(L);\n\tif (!rv)\n\t\tbotch(\"malloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n static void*\nRealloc(void *rv, size_t L, const char *where)\n{\n\trv = realloc(rv, L);\n\tif (!rv)\n\t\tbotch(\"ralloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n void\nunexpected(const char *what)\n{ botch(\"unexpected \\\"%s\\\"\", what); }\n\n static void *\nAlloc(size_t len)\n{\n\tMblk *mb;\n\tsize_t L;\n\tvoid *rv;\n\n\tL = (len + sizeof(void*) - 1)/sizeof(void*);\n\tif (L >= Mblk_gulp)\n\t\tbotch(\"Alloc(%lu) failure\", (unsigned long)len);\n\tif (L > mbavail) {\n\t\tif (!(mb = CurMblk->next)) {\n\t\t\tmb = (Mblk*)Malloc(sizeof(Mblk), \"Alloc\");\n\t\t\tCurMblk->next = mb;\n\t\t\t}\n\t\tCurMblk = mb;\n\t\tmbavail = Mblk_gulp;\n\t\tmbnext = mb->stuff;\n\t\tmb->next = 0;\n\t\tmemset(mbnext, 0, sizeof(mb->stuff));\n\t\t}\n\trv = mbnext;\n\tmbnext += L;\n\tmbavail -= L;\n\treturn rv;\n\t}\n\n StrList *\nnew_StrList(const char *s, StrList *nxt)\n{\n\tsize_t L = strlen(s) + 1;\n\tStrList *rv = (StrList*)Alloc(sizeof(StrList) + L);\n\tstrcpy(rv->val = (char*)(rv + 1), s);\n\tif ((rv->next = nxt))\n\t\trv->needrev = 1;\n\trv->Lineno = Lineno;\n\treturn rv;\n\t}\n\n static void\nAlias(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\n\tif (lastseen != Saw_kwname)\n\t\tbotch(\"ALIAS out of place\");\n\tkw = lastkw;\n\tfor(s += 6; *s <= ' '; s++);\n\tsl = kw->names = new_StrList(s, kw->names);\n\t++nalias;\n\tsl->seqno = ++seqno;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nreqchk(const char *a, const char *s)\n{\n\tif (a)\n\t\twhile(*a)\n\t\t\tif (*a++ == lastseen)\n\t\t\t\treturn;\n\tbotch(\"\\\"%s\\\" out of place\", s);\n\t}\n\n static void\nreqchk1(const char *a, const char *s)\n{\n\tint c;\n\n\tif (*Br_top != *s) {\n\t\tif ((c = *Br_top)) {\n\t\t\tswitch(c) {\n\t\t\t case '[': c = ']'; break;\n\t\t\t case '(': c = ')'; break;\n\t\t\t default:  c = '?';\n\t\t\t }\n\t\t\tbotch(\"Missing '%c'\", c);\n\t\t\t}\n\t\telse\n\t\t\ta = 0;\n\t\t}\n\treqchk(a, s+1);\n\t}\n\n static void\nBar(void)\n{\n\tstatic char allowed[] = { /*(*/ ')', Saw_kwname, Saw_type, 0 };\n\treqchk(KWtop - KWStack > 1 || KWtop[0]->kw ? allowed : \"\", \"|\");\n\tlastseen = '|';\n\tlastkw = lastkw1 = 0;\n\tor_mode = 1;\n\t}\n\n static void\nLpar(void)\n{\n\tKWctx *kw;\n\tint olastseen = lastseen;\n\tstatic char allowed[] = { '(', '[', '|', ']', ')', Saw_kwname, Saw_type, 0 };\n\n\treqchk(allowed, \"(\"/*)*/);\n\tlastseen = '('; /*)*/\n\tif (KWtop > KWStack) {\n\t\tkw = KWtop[0];\n\t\tif (or_mode && kw->parstate == PPar_leftpar && !kw->kw) {\n\t\t\tdtnext = deftag + kw->dtnext;\n\t\t\t--KWtop;\n\t\t\tKeywd(0);\n\t\t\tkw->pparent = KWtop[0];\n\t\t\t}\n\t\telse if (olastseen == '(' || olastseen == '[' /*])*/)\n\t\t\tKeywd(0);\n\t\tlastseen = '(' /*)*/;\n\t\t}\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\t*Br_top = '('; /*)*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLsqb(void)\n{\n\tstatic char allowed[] = { /*([*/ ']', ')', Saw_kwname, Saw_type, 0 };\n\treqchk(allowed, \"[\"/*]*/);\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\tlastseen = *Br_top = '['; /*]*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRpar(void)\n{\n\tstatic char allowed[] =  {/*[(*/ ')', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"()\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\tif (!KWtop[0]->kw && KWtop - KWStack > 2\n\t && KWtop[-1]->parstate == PPar_starting)\n\t\tKWtop[-1]->Br_top = Br_top;\n\t--KWtop;\n\tlastseen = /*(*/ ')';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRsqb(void)\n{\n\tstatic char allowed[] = {/*(*/')', '[', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"[]\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\t--KWtop;\n\tlastseen = /*[*/ ']';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLbrace(void)\n{\n\tif (brace++ || (lastseen != Saw_kwname && lastseen != Saw_type))\n\t\tunexpected(\"{\");\n\tlastseen = '{'; /*}}*/\n\t}\n\n static void\nRbrace(void)\n{\n\tif (--brace || (lastseen != Saw_func && lastseen != ';'))\n\t\t/*{{*/unexpected(\"}\");\n\tlastseen = Saw_type;\n\t}\n\n static void\nType(int n, const char *s)\n{\n\tif (lastseen != Saw_kwname || !lastkw)\n\t\tbotch(\"type %s out of place\", s);\n\tlastkw->kind |= n;\n\tlastkw = 0;\n\tlastseen = Saw_type;\n\t}\n\n static char *\ndef_name(const char *s0)\n{\n\tchar *s;\n\tconst char *s1;\n\tsize_t L, L1;\n\tstatic char *slast, *snext;\n\n\ts1 = s0;\n\twhile(*s1++);\n\tL = s1 - s0;\n\tif (snext + L > slast) {\n\t\tsnext = (char*)Malloc(L1 = Dmblk_sgulp + L, \"def_name\");\n\t\tslast = snext + L1;\n\t\t}\n\tstrcpy(s = snext, s0);\n\tsnext += L;\n\treturn s;\n\t}\n\nstatic void **DHHlast, **DHHnext;\t/* Could be private to DHHlookup, but here */\n\t\t\t\t\t/* to make them visible to debuggers. */\n static DefhashHead *\nDHHlookup(const char *s0, DefhashTab *Htab, int add)\n{\n\tDefhashHead *h, **hp;\n\tconst char *s;\n\tsize_t L;\n\tunsigned int c, x;\n\n\tfor(x = 0, s = s0; (c = *(unsigned char*)s); ++s)\n\t\tx += DHTfactor*x + c;\n\tx %= DHTlen;\n\tfor(hp = &Htab->Tab[x]; (h = *hp); hp = &h->hnext) {\n\t\tif (!strcmp(s0, h->name))\n\t\t\treturn h;\n\t\t}\n\tif (!add)\n\t\treturn h;\n\tHtab->nent++;\n\tif (DHHnext + Htab->nalloc >= DHHlast) {\n\t\tDHHnext = (void**)Malloc(L = DMblk_gulp*sizeof(void*), \"DHHlookup\");\n\t\tDHHlast = DHHnext + DMblk_gulp;\n\t\tmemset(DHHnext, 0, L);\n\t\t}\n\t*hp = h = (DefhashHead*)DHHnext;\n\tDHHnext += Htab->nalloc;\n\th->name = def_name(s0);\n\th->thread = Htab->lastdh;\n\treturn Htab->lastdh = h;\n\t}\n\n static void\nbothplaces(KWctx *kw, const char *name)\n{ squawk(\"For %s, %s appears both in specfile and tagfile\", kw->names->val, name); }\n\n static void\ntagimport(KWctx *kw, KWctx *tw)\n{\n\ttypedef struct KWimport KWimport;\n\tstruct KWimport { const char *name; size_t off; };\n\tstatic KWimport Imp[] = {\n\t\t{ \"lower bound\",\toffsetof(KWctx,lb) },\n\t\t{ \"upper bound\",\toffsetof(KWctx,ub) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,init) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,cinit) },\n\t\t{ \"defname\",\t\toffsetof(KWctx,defname) },\n\t\t{ \"DESC\",\t\toffsetof(KWctx,desc) },\n\t\t{ \"GROUP\",\t\toffsetof(KWctx,group) },\n\t\t{ \"LEN\",\t\toffsetof(KWctx,len) },\n\t\t{0}};\n\tKWimport *ki;\n#define field(k,n) *(char**)((char*)k+n)\n\tfor(ki = Imp; ki->name; ++ki) {\n\t\tif (field(tw,ki->off)) {\n\t\t\tif (field(kw,ki->off))\n\t\t\t\tbothplaces(kw, ki->name);\n\t\t\telse\n\t\t\t\tfield(kw,ki->off) = field(tw,ki->off);\n\t\t\t}\n\t\t}\n#undef field\n\t}\n\n#ifndef NO_NIDR_DYNLIB\n\nstatic const char *typename[8] = {\n\t\"no value\", \"INTEGER\", \"REAL\", \"STRING\",\n\t\"(Bug! no value LIST)\", \"INTEGERLIST\", \"REALLIST\", \"STRINGLIST\" };\n\n static int\nkwseqnocomp(const void *a, const void *b)\n{\n\tconst KeyWordx *ka, *kb;\n\n\tka = *(KeyWordx**)a;\n\tkb = *(KeyWordx**)b;\n\treturn (int)ka->seqno - (int)kb->seqno;\n\t}\n\n static void\nLsqbpar(void)\n{\n\tLsqb();\n\tLpar();\n\t}\n\n static void\nRparsqb(void)\n{\n\tRpar();\n\tRsqb();\n\t}\n\n static void\nNobrak(void) {}\n\n typedef struct\nKW_Cstak { KeyWordx **Cstak; Uint n, nmax; } KW_Cstak;\n\n static void kw_finish(int);\n static void kw_insert(KeyWord*, KW_Cstak*, int);\n\n static KeyWord*\nkw_stakadj(KeyWord *kw, KW_Cstak *Stk, int needbar, int n0, KeyWord *okw3)\n{\n\tKeyWordx *kw1, *kw2, **x;\n\tUint i, j, k, nst, nz;\n\n\tkw1 = (KeyWordx*)kw;\n\tnz = 0;\n\twhile(!kw1[++nz].kw.name);\n\tif (nz == 1 && *kw1[nz].kw.name)\n\t\tokw3 = 0;\n\tnst = Stk->n;\n\tx = Stk->Cstak;\n\tkw2 = (KeyWordx*)kw1->kw.kw;\n\tfor(i = 0; i < nst; ++i) {\n\t\tif (x[i]->kw.kw == &kw2->kw) {\n\t\t\tj = i;\n\t\t\t++kw1;\n\t\t\t/* No need to test kw1->kw.name in the following loop */\n\t\t\t/* as the == test will fail if kw1->kw.name is nonzero. */\n\t\t\twhile(++j < nst && x[j]->kw.kw == kw1->kw.kw)\n\t\t\t\t++kw1;\n\t\t\tk = nz - (j-i);\n\t\t\tgoto have_jk;\n\t\t\t}\n\t\t}\n\tk = nz;\n\tj = n0;\n have_jk:\n\twhile(nst > j) {\n\t\tkw_insert(&x[--nst]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (needbar)\n\t\tBar();\n\tif (k) {\n\t\tif (nst + k > Stk->nmax)\n\t\t\tx = Stk->Cstak = (KeyWordx**)Realloc(x,\n\t\t\t\t(Stk->nmax = 2)*sizeof(KeyWordx*), \"kw_stakadj\");\n\t\tdo {\n\t\t\tif (kw1->kw.kw != okw3)\n\t\t\t\tLpar();\n\t\t\tx[j++] = kw1++;\n\t\t\t}\n\t\t\twhile(--k);\n\t\tnst = j;\n\t\t}\n\tStk->n = nst;\n\tif (!*kw1->kw.name)\n\t\treturn 0;\n\treturn &kw1->kw;\n\t}\n\n static int\nsame_funcs(KeyWordx *kw1, KeyWordx *kw2)\n{\n\tKeyWordx *kw3, *kw4;\n\n\tif (!kw1->kw.nkw || !kw2->kw.nkw)\n\t\treturn 0;\n\tkw3 = (KeyWordx*)kw1->kw.kw;\n\tkw4 = (KeyWordx*)kw2->kw.kw;\n\tif (kw3 == kw4)\n\t\treturn 1;\n\tif (kw4->kw.name)\n\t\treturn 0;\n\tkw4 = (KeyWordx*)kw4->kw.kw;\n\treturn kw3 == kw4;\n\t}\n\n static char *\nStrCpy(const char *s)\n{\n\tchar *t;\n\tsize_t L;\n\n\tif (!s)\n\t\treturn 0;\n\tL = strlen(s);\n\tt = (char*)Alloc(L+1);\n\tstrcpy(t,s);\n\treturn t;\n\t}\n\n static int Saw_name(const char*);\n static void Saw_stok(int, size_t);\n\n static void\nkw_insert(KeyWord *kw, KW_Cstak *Stk, int top)\n{\n\tenum { NKW0 = 32 };\n\tKeyWord *kw3, *kw30, *okw3;\n\tKeyWordx *kw0, *kw1, *kw2, *kw4, **x, *x0[NKW0];\n\tUint i, j, k, knd, nkw, nst0, nst1;\n\tchar buf[32];\n\tint alt2, incc, needbar, needbar1, samef0, samef1;\n\ttypedef void (*Brak)(void);\n\tBrak Lbrak, Rbrak;\n\n\tkw1 = (KeyWordx*)kw->kw;\n\twhile(!kw1->kw.name)\n\t\t++kw1;\n\tnkw = kw->nkw;\n\tx = x0;\n\tif (nkw > NKW0)\n\t\tx = (KeyWordx**)Malloc(nkw * sizeof(KeyWordx*), \"kw_insert\");\n\tfor(i = 0; i < nkw; ++i)\n\t\tx[i] = kw1++;\n\tif (nkw > 1)\n\t\tqsort(x, nkw, sizeof(KeyWordx*), kwseqnocomp);\n\tkw0 = 0;\n\tkw30 = 0;\n\tnst0 = Stk->n;\n\tfor(i = j = samef0 = 0; i < nkw; i = j) {\n\t\tkw1 = x[i];\n\t\tkw2 = 0;\n\t\twhile(++j < nkw) {\n\t\t\tkw2 = x[j];\n\t\t\tif (!kw2->kw.paoff)\n\t\t\t\tbreak;\n\t\t\tkw2 = 0;\n\t\t\t}\n\t\tLbrak = Rbrak = 0;\n\t\tokw3 = kw30;\n\t\tif (top) {\n\t\t\tkw_finish(kw1->kw.kind & KWKind_12);\n\t\t\tkw3 = kw1->kw.kw;\n\t\t\tRbrak = Nobrak;\n\t\t\tgoto nobrak;\n\t\t\t}\n\t\tneedbar = needbar1 = kw0 && kw0->kw.alt == kw1->kw.alt;\n\t\tnst1 = Stk->n;\n\t\talt2 = incc = 0;\n\t\tkw4 = 0;\n\t\tif (kw2) {\n\t\t\talt2 = kw1->kw.alt == kw2->kw.alt;\n\t\t\tkw4 = (KeyWordx*)kw2->kw.kw;\n\t\t\t}\n\t\tif ((kw3 = kw30 = kw1->kw.kw)) {\n\t\t\tif (!kw3->name) {\n\t\t\t\tkw3 = kw_stakadj(kw3, Stk, needbar, nst0, okw3);\n\t\t\t\tneedbar1 = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\twhile(Stk->n > nst0) {\n\t\t\t\t\tif (Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n\t\t\t\t\t\tif (kw4 && kw4->kw.kw == kw3)\n\t\t\t\t\t\t\tincc = 1; /* in contained context */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\t\tRpar();\n\t\t\t\t\t}\n\t\t\t}\n\t\telse while(Stk->n > nst0) {\n\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\tRpar();\n\t\t\t}\n\t\tsamef0 = needbar && same_funcs(kw1,kw0);\n\t\tsamef1 = alt2    && same_funcs(kw1,kw2);\n\t\tif (kw3) {\n\t\t\tif (samef1) {\n\t\t\t\tif (!needbar)\n\t\t\t\t\tLbrak = kw1->kw.req ? Lpar : Lsqbpar;\n\t\t\t\telse if (!samef0 && kw3->name)\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\tkw3 = 0;\n\t\t\t\tgoto barchk;\n\t\t\t\t}\n\t\t\telse if (needbar) {\n\t\t\t\tif (!incc)\n\t\t\t\t\tRbrak = alt2 || kw1->kw.req ? Rpar : Rparsqb;\n\t\t\t\tif (!samef0\n\t\t\t\t && (Stk->n <= nst1\n\t\t\t\t    || !kw0 || kw0->kw.kw != Stk->Cstak[Stk->n-1]->kw.kw))\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\t}\n\t\t\telse if (kw1->kw.req) {\n\t\t\t\tLbrak = Lpar;\n\t\t\t\tRbrak = Rpar;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tLbrak = Lsqb;\n\t\t\t\tRbrak = Rsqb;\n\t\t\t\tif (alt2) {\n\t\t\t\t\tLbrak = Lsqbpar;\n\t\t\t\t\tRbrak = Rpar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw2) {\n\t\t\t\tif (kw4 && !kw4->kw.name && kw4->kw.kw == kw3)\n\t\t\t\t\tgoto zap_kw3;\n\t\t\t\tif (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3)\n\t\t\t\t\t--Stk->n;\n\t\t\t\t}\n\t\t\telse if (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n zap_kw3:\n\t\t\t\tRbrak = 0;\n\t\t\t\tkw3 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!kw1->kw.req) {\n\t\t\tif (!needbar)\n\t\t\t\tLbrak = Lsqb;\n\t\t\tif (!alt2)\n\t\t\t\tRbrak = Rsqb;\n\t\t\t}\n barchk:\n\t\tif (needbar1)\n\t\t\tBar();\n\t\tif (Lbrak)\n\t\t\tLbrak();\n nobrak:\n\t\tKeywd(kw1->kw.name);\n\t\twhile(++i < j) {\n\t\t\tkw2 = x[i];\n\t\t\tAlias(kw2->kw.name - 6);\t/* Alias will increment by 6 */\n\t\t\t}\n\t\tknd = kw1->kw.kind;\n\t\tif ((k = knd & (KWKind_Mask|KWKind_List)))\n\t\t\tType(k, typename[k]);\n\t\tif ((k = knd & KWKind_Lb)) {\n\t\t\tSaw_tok(knd & KWKind_strictLb ? Saw_gt : Saw_ge, KWKind_Lb);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Lb);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif ((k = knd & KWKind_Ub)) {\n\t\t\tSaw_tok(knd & KWKind_strictUb ? Saw_lt : Saw_le, KWKind_Ub);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Ub);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif (kw1->init || kw1->cinit) {\n\t\t\tSaw_tok(Saw_dflt, KWKind_init);\n\t\t\tlastdef = 0;\n\t\t\tif (kw1->defname)\n\t\t\t\tSaw_name(kw1->defname);\n\t\t\tif (kw1->init)\n\t\t\t\tSaw_num(kw1->init);\n\t\t\telse\n\t\t\t\tlastkw1->cinit = StrCpy(kw1->cinit);\n\t\t\t}\n\t\tif (kw1->funcs)\n\t\t\tlastkw1->funcs = new_StrList(kw1->funcs, 0);\n\t\telse if (kw1->kw.f.vf && !kw1->kw.f.final) {\n\t\t\tlastkw1->dylib = StrCpy((const char*)kw1->kw.f.vf);\n\t\t\tdynlibseen = 1;\n\t\t\t}\n\t\telse\n\t\t\tlastkw1->funcs = new_StrList(\"0\", 0);\n\t\tlastkw1->desc  = StrCpy(kw1->desc);\n\t\tlastkw1->group = StrCpy(kw1->group);\n\t\tif (kw1->alen) {\n\t\t\tSaw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\tlastkw1->kind |= knd & KWKind_Len1OK;\n\t\t\tSaw_name(kw1->alen);\n\t\t\t}\n\t\tif (Rbrak) {\n\t\t\tif (kw3)\n\t\t\t\tkw_insert((KeyWord*)kw1, Stk, 0);\n\t\t\tRbrak();\n\t\t\t}\n\t\tkw0 = kw1;\n\t\tif (top) {\n\t\t\twhile(Stk->n > 0) {\n\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\tRpar();\n\t\t\t\t}\n\t\t\tif (!kw2)\n\t\t\t\tkw_finish(-1);\n\t\t\t}\n\t\t}\n\twhile(Stk->n > nst0) {\n\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nkw_insert1(KeyWord *kw, int top)\n{\n\tKW_Cstak Stk;\n\n\tStk.n = 0;\n\tStk.Cstak = (KeyWordx**)Malloc((Stk.nmax = 64)*sizeof(KeyWordx*), \"kw_insert1\");\n\tif (top) {\n\t\tKWtop = KWStack;\n\t\tKWbase.kw = 0;\n\t\t}\n\tkw_insert(kw, &Stk, top);\n\twhile(Stk.n > 0) {\n\t\tkw_insert(&Stk.Cstak[--Stk.n]->kw, &Stk, 0);\n\t\tRpar();\n\t\t}\n\tfree(Stk.Cstak);\n\t}\n\n static int\nlibread1(const char *kname, const char *lname, Uint n, int allow_top)\n{\n\tKW_ADD kwa;\n\tKeyWord *kw, kw0;\n\tUint i;\n\tconst char *s;\n\tvoid *h, (*Botch)(const char*, ...);\n\n\th = dlopen(lname, RTLD_NOW);\n\tif (!h) {\n\t\tBotch = botch;\n\t\tif (kname && libexpand)\n\t\t\tBotch = squawk;\n#ifndef _WIN32\n\t\tif ((s = dlerror()))\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\t\tlname, kname, s);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\",\n\t\t\t\t\tlname, s);\n\t\telse\n#endif\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\t\tlname, kname);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\"\", lname);\n\t\treturn ++liberror;\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw = (*kwa)();\n\tif (!(s = kw->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tif (allow_top) {\n\t\tif (strcmp(s, \"KeywordTop\")) {\n\t\t\tif (allow_top == 2) {\n\t\t\t\tmemset(&kw0, 0, sizeof(KeyWord));\n\t\t\t\tkw0.kw = kw;\n\t\t\t\tkw = &kw0;\n\t\t\t\tkw0.nkw = 1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tallow_top = 0;\n\t\t\t}\n\t\telse\n\t\t\tkname = 0;\n\t\t}\n\telse if (kname && strcmp(s, kname)) {\n namebotch:\n\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\tlname, kname, s);\n\t\t}\n\tif (kname) {\n\t\ti = kw->kind & (KWKind_Mask|KWKind_List);\n\t\tif (i != n)\n\t\t\tbotch(\"Library %s: expected %s to be %s, but got %s\",\n\t\t\t\tlname, kname, typename[n], typename[i]);\n\t\t}\n\tif (kw->kw)\n\t\tkw_insert1(kw, allow_top);\n\tdlclose(h);\n\treturn 0;\n\t}\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tconst char *kname, *lname;\n\n\tkname = kc->name1;\n\tlname = kc->dylib;\n\tkc->dylib = 0;\n\treturn libread1(kname, lname, kc->kind & (KWKind_Mask|KWKind_List), allow_top);\n\t}\n#else\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", kc->dylib);\n\treturn 1;\n\t}\n#endif\n\n static void\nKeywd(const char *s)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2, *kwm, **kwp;\n\tStrList *nam;\n\tTaghash *th;\n\tchar *s1;\n\tint alt, lsave, req;\n\tsize_t L, L1;\n\tstatic char allowed[] = { '(',')','[',']','|', Saw_kwname, Saw_type, 0 };\n\n\tif (tagin)\n\t\tbotch(\"Inappropriate text \\\"%s\\\" in tagfile \\\"%s\\\"\", s, tagfname);\n\tkw1 = *KWtop;\n#ifndef NO_NIDR_DYNLIB\n\tif (kw1->dylib && libexpand && !lib_read(kw1,0))\n\t\tkw1 = *KWtop;\n#endif\n\tkw0 = kw1;\n\tkwm = 0;\n\tif (!kw1->names && s) {\n\t\tswitch(kw1->parstate) {\n\t\t  case PPar_emtpy:\n\t\t\tdo {\n\t\t\t\tkw1->parstate = PPar_starting;\n\t\t\t\tkw1 = kw1->pparent;\n\t\t\t\t}\n\t\t\t\twhile(kw1 && kw1->parstate == PPar_emtpy);\n\t\t\tkw1 = kw0->rparent;\n\t\t\tbreak;\n\t\t  case PPar_starting:\n\t\t\tif (or_mode)\n\t\t\t\tkw1 = kw0->rparent;\n\t\t\telse\n\t\t\t\tkw1->parstate = PPar_started;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\tif (or_mode && !kw1->kw) {\n\t\tkw2 = KWtop[-1];\n\t\tif (!kw2->names && kw2->parstate == PPar_starting)\n\t\t\tkw2 = kw2->rparent;\n\t\tif (s)\n\t\t\tkw1->master = kwm = kw1;\n\t\tkw1 = kw2;\n\t\t}\n\tL = alt = req = 0;\n\tif (s) {\n\t\tkwp = KWStack + kw1->level + 1;\n\t\tif (kwp > KWtop)\n\t\t\tkwp = KWtop;\n\t\twhile(kwp > KWStack) {\n\t\t\tkw2 = *kwp--;\n\t\t\tif (kw2->name1) {\n\t\t\t\tdtnext = deftag + kw2->dtnext;\n\t\t\t\tL = kw2->name1len;\n\t\t\t\tstrcpy(dtnext-L, kw2->name1);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\talt = ++kw1->nalt;\n\t\tif (*Br_top != '['/*]*/ || Br_top == kw1->Br_top) {\n\t\t\treq = ++kw1->nreq;\n\t\t\tif (*Br_top == '(' /*)*/) /* allow [(...)|...] */\n\t\t\t\tfor(s1 = Br_top; --s1 > kw1->Br_top; ) {\n\t\t\t\t\tif (*s1 != '(' /*)*/) {\n\t\t\t\t\t\tif (*s1 == '[' /*]*/) {\n\t\t\t\t\t\t\t--kw1->nreq;\n\t\t\t\t\t\t\treq = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\tif (or_mode) {\n\t\t\talt = --kw1->nalt;\n\t\t\tif (req)\n\t\t\t\treq = --kw1->nreq;\n\t\t\t}\n\t\tif (lastseen)\n\t\t\treqchk(allowed, s);\n\t\tor_mode = 0;\n\t\t}\n\tlastkw = lastkw1 = kw = (KWctx*) Alloc(sizeof(KWctx));\n\tif (!kw0->names)\n\t\tkw->pparent = kw0;\n\tif (s) {\n\t\tkw->names = nam = new_StrList(s,0);\n\t\tkw->name1 = nam->val;\n\t\tkw->name1len = L = strlen(s);\n\t\tfor(kwp = KWtop; kwp > KWStack; --kwp) {\n\t\t\tkw2 = *kwp;\n\t\t\tif (kw2->names) {\n\t\t\t\tif (kwp < KWtop) {\n\t\t\t\t\tL1 = kw2->dtnext + L + 1;\n\t\t\t\t\twhile(++kwp <= KWtop) {\n\t\t\t\t\t\tkw2 = *kwp;\n\t\t\t\t\t\tif (!kw2->name1) {\n\t\t\t\t\t\t\tkw2->name1 = kw->name1;\n\t\t\t\t\t\t\tkw2->name1len = L;\n\t\t\t\t\t\t\tkw2->dtnext = L1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kw1->dylib) {\n\t\t\tlsave = Lineno;\n\t\t\tLineno = dynline; /* Line where DYNLIB appeared */\n\t\t\tsquawk(\"Suppressing DYNLIB for %s to parse contained keywords\",\n\t\t\t\tkw1->names ? kw1->names->val : \"???? (bug!)\");\n\t\t\tLineno = lsave;\n\t\t\tkw1->dylib = 0;\n\t\t\t}\n\t\tnam->primary = KWKind_primary;\n\t\tnam->seqno = ++seqno;\n\t\tkw->next = kw1->kw;\n\t\tkw1->kw = kw;\n\t\tif (lastseen == '(' /*)*/)\n\t\t\tkw->parstate = PPar_leftpar;\n\t\tkw->agroup = lastagroup++;\n\t\t}\n\telse {\n\t\tkw->objno = ++lastobjno;\n\t\tif (!kw1->kw && (kw->rparent = kw1->rparent))\n\t\t\tkw1 = kw->rparent;\n\t\telse\n\t\t\tkw->rparent = kw1;\n\t\talt = kw1->alt;\n\t\treq = kw1->req;\n\t\t}\n\tkw->alt = alt;\n\tkw->req = req;\n\tkw->Br_top = Br_top;\n\tkw->master = kwm;\n\tkw->level = KWtop - KWStack;\n\tif (lastseen == '(' || lastseen == '[' /*])*/ || KWtop == KWStack) {\n\t\tif (++KWtop - KWStack >= KW_stacklen)\n\t\t\tbotch(\"KW stack overflow\");\n\t\t*KWtop = kw;\n\t\t}\n\tlasttag = 0;\n\tif (s) {\n\t\tif (dtnext > deftag)\n\t\t\t*dtnext++ = '/';\n\t\tif (dtnext + L >= dtend)\n\t\t\tbotch(\"deftag overflow\");\n\t\tmemcpy(dtnext, s, L);\n\t\t*(dtnext += L) = 0;\n\t\tif (tagout)\n\t\t\tfprintf(tagout, \"TAG \\\"%s\\\"\\n\", deftag);\n\t\tif (tagfname) {\n\t\t\tif ((th = (Taghash*)DHHlookup(deftag, &TagTab, ignoretags))) {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (mtagout)\n\t\t\t\tfprintf(mtagout, \"TAG \\\"%s\\\" #missing\\n\", deftag);\n\t\t\t}\n\t\t}\n\tkw->dtnext = dtnext - deftag;\n\tif (lastseen == 0)\n\t\tkw->kind = kwmult;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nkw_finish(int nextkind)\n{\n\tKWctx *kw;\n\n\tif (*Br_top)\n\t\tbotch(\"unmatched '%c'\", *Br_top);\n\tif (KWtop - KWStack > 1)\n\t\tbotch(\"bug: KW stack botch in kw_finish\");\n\tif (KWtop > KWStack) {\n\t\tkw = *KWtop;\n\t\tif (kw->dylib && libexpand)\n\t\t\tlib_read(kw, nextkind == -1);\n\t\t}\n\tKWtop = KWStack;\n\tdtnext = deftag;\n\tlastseen = 0;\n\tkwmult = nextkind < 0 ? 0 : nextkind;\n\t}\n\n static void\nfuncbotch(KWctx *kw)\n{\n\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions cannot be used with DYNLIB\"\n\t\t\".\\n\\t\\tThey must be supplied by the dynamically loaded library\",\n\t\tkw->names->val);\n\t}\n\n static void\nFnc(char *s)\n{\n\tKWctx *kw;\n\n\tif (!(kw = lastkw1))\n\t\tbotch(\"misplaced {...}\");\n\tif (++kw->nfcn > 4)\n\t\tbotch(\"too many functions in {...}\");\n\telse if (kw->dylib)\n\t\tfuncbotch(kw);\n\telse if (kw->kind & KWKind_Libname)\n\t\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions \"\n\t\t\t\"cannot be used with LIBNAME.\",\n\t\t\tkw->names->val);\n\tkw->funcs = wantfuncs ? new_StrList(s, kw->funcs) : 0;\n\tlastseen = Saw_func;\n\t}\n\n static const char*\ntname_adj(const char *tname, int what, int kbits)\n{\n\tUint k = lastkw1->kind;\n\n\tswitch(what) {\n\t case Saw_lt:\n\t\tif (k & KWKind_caneqUb)\n\t\t\ttname = \"<=\";\n\t\tbreak;\n\t case Saw_le:\n\t\tif (k & KWKind_strictUb)\n\t\t\ttname = \"<\";\n\t\tbreak;\n\t case Saw_ge:\n\t\tif (k & KWKind_strictLb)\n\t\t\ttname = \">\";\n\t\tbreak;\n\t case Saw_gt:\n\t\tif (k & KWKind_caneqLb)\n\t\t\ttname = \">=\";\n\t }\n\treturn tname;\n\t}\n\n static void\nSaw_tok(int what, int kbits)\n{\n\tconst char *tname;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (lastkw1->kind & kbits) {\n\t\t\ttname = tokname[what];\n\t\t\tif (kbits & (KWKind_Lb | KWKind_Ub))\n\t\t\t\ttname = tname_adj(tname, what, kbits);\n\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\ttname, lastkw1->names->val);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static void\nSaw_stok(int what, size_t woff)\n{\n\tStrList *sl;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (*(void**)((char*)lastkw1 + woff)) {\n\t\t\tif ((sl = lastkw1->names))\n\t\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\t\ttokname[what], sl->val);\n\t\t\telse\n\t\t\t\tbotch(\"%s already seen\", tokname[what]);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static KWctx *\nlenfind(const char *s)\n{\n\tKWctx *kw, *kw0, **pkw;\n\tStrList *sl;\n\n\tkw0 = lastkw1;\n\tfor(pkw = KWtop; pkw > KWStack; --pkw) {\n\t\tkw = *pkw;\n\t\tfor(kw = kw->kw; kw; kw = kw->next) {\n\t\t\tfor(sl = kw->names; sl; sl = sl->next)\n\t\t\t\tif (!strcmp(sl->val, s))\n\t\t\t\t\treturn kw;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n\n static void\nalreadyseen(const char *what)\n{\n\tsquawk(\"%s already given for %s\", what, lastkw1->names->val);\n\t}\n\n static int\nSaw_name(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\tTaghash *th;\n\tconst char *s1;\n\tstatic const char notfound[] =\n\t\t\"keyword \\\"%s\\\" not found in this or an enclosing context\";\n\n\tif (lastkw1) {\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t\tlastseen = Saw_dfltname;\n\t\t\tlastdef = (Defhash*)DHHlookup(s, &DHTab, 1);\n\t\t\tif (!lastkw1->defname)\n\t\t\t\tlastkw1->defname = def_name(s);\n\t\t\telse if (lastdef->value\n\t\t\t\t && ((s1 = lastkw1->init) || (s1 = lastkw1->cinit))\n\t\t\t\t && strcmp(s1, lastdef->value))\n\t\t\t\t\tsquawk(\"Inconsistent definitions for %s: %s and %s\\n\",\n\t\t\t\t\t\tlastdef->hh.name, lastdef->value, s1);\n\t\t\treturn 0;\n\t\t  case Saw_len:\n\t\t\tif (lastkw1->len) {\n\t\t\t\talreadyseen(\"LEN\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tkw = lenfind(s);\n\t\t\tif (!kw)\n\t\t\t\tsquawk(notfound,s);\n\t\t\telse {\n\t\t\t\tif ((kw->kind & KWKind_Mask) != KWKind_Int)\n\t\t\t\t\tsquawk(\"%s is not of type INTEGER\", kw->names->val);\n\t\t\t\tfor(sl = kw->names; sl->next; sl = sl->next);\n\t\t\t\tlastkw1->len = sl->val;\n\t\t\t\t}\n\t\t\tgoto ret1;\n\t\t  case Saw_group:\n\t\t\tif (lastkw1->group)\n\t\t\t\talreadyseen(\"GROUP\");\n\t\t\telse\n\t\t\t\tstrcpy(lastkw1->group = (char*)Alloc(strlen(s)+1), s);\n\t\t\tgoto ret1;\n\t\t  case Saw_tag:\n\t\t\tif (tagin)\n\t\t\t\tgoto new_tag;\n\t\t\tif (lasttag) {\n\t\t\t\talreadyseen(\"TAG\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tif (!tagfname && !ignoretags) {\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found: no tag file given\", s);\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tth = (Taghash*)DHHlookup(s, &TagTab, ignoretags);\n\t\t\tif (!th)\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found in tag file \\\"%s\\\"\", s, tagfname);\n\t\t\telse {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n ret1:\n\t\t\tlastseen = Saw_type;\n\t\t\treturn 1;\n\t\t  }\n\t\t}\n\telse if (tagin) {\n new_tag:\n\t\tth = (Taghash*)DHHlookup(s, &TagTab, 1);\n\t\tif (th->kw)\n\t\t\tsquawk(\"Tag \\\"%s\\\" already seen in tagfile %s\\n\", s, tagfname);\n\t\telse\n\t\t\tth->kw = lastkw1 = (KWctx*) Alloc(sizeof(KWctx));\n\t\tgoto ret1;\n\t\t}\n\tbotch(\"unexpected name \\\"%s\\\"\", s);\n\treturn 0; /* not reached */\n\t}\n\n static void\nboundalready(const char *what)\n{\n\tsquawk(\"%s bound already given for %s\", what, lastkw1->names->val);\n\t}\n\n static void\nset_lastdef(const char *s, int qkeep)\n{\n\tif (!lastdef->value) {\n\t\tlastdef->value = def_name(s);\n\t\tlastdef->qkeep = qkeep;\n\t\t}\n\telse if (strcmp(s, lastdef->value))\n\t\tsquawk(\"Two := values for %s: %s and %s\", lastdef->hh.name,\n\t\t\tlastdef->value, s);\n\t}\n\n static void\nSaw_num(const char *s)\n{\n\tDefhash *ld;\n\tdouble x, xa;\n\tchar *se, **sp;\n\tint k;\n\tstatic double b[3];\n\n\tstatic char allowed[] = { Saw_dflt, Saw_dfltname, Saw_lt, Saw_le, Saw_ge, Saw_gt, 0 };\n\n\treqchk(allowed, \"number\");\n\tx = strtod(s,&se);\n\tif (*se)\n\t\tbotch(\"invalid number: \\\"%s\\\"\", s);\n\tld = 0;\n\tsp = 0;\n\tswitch(lastseen) {\n\t\tcase Saw_dflt:\n\t\tcase Saw_dfltname:\n\t\t\tsp = &lastkw1->init;\n\t\t\tlastkw1->kind |= KWKind_init;\n\t\t\tld = lastdef;\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int)\n\t\t\t\tx = x >= 0. ? floor(x) : ceil(x);\n\t\t\tb[2] = x;\n\t\t\tif (lastkw1->lb && x < b[0])\n\t\t\t\tsquawk(\"default value inconsistent with lower bound\");\n\t\t\tif (lastkw1->ub && x > b[1])\n\t\t\t\tsquawk(\"default value inconsistent with upper bound\");\n\t\t\tbreak;\n\t\tcase Saw_gt:\n\t\tcase Saw_ge:\n\t\t\tif (lastkw1->lb) {\n\t\t\t\tboundalready(\"lower\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = ceil(x);\n\t\t\t\tif (xa > x) {\n\t\t\t\t\tif (btype == KWKind_strictLb)\n\t\t\t\t\t\tbtype = KWKind_caneqLb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->lb;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[0] = x;\n\t\t\tif (lastkw1->ub && x >= b[1])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x > b[2])\n\t\t\t\tsquawk(\"lower bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tcase Saw_le:\n\t\tcase Saw_lt:\n\t\t\tif (lastkw1->ub) {\n\t\t\t\tboundalready(\"upper\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = floor(x);\n\t\t\t\tif (xa < x) {\n\t\t\t\t\tif (btype == KWKind_strictUb)\n\t\t\t\t\t\tbtype = KWKind_caneqUb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->ub;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[1] = x;\n\t\t\tif (lastkw1->lb && x <= b[0])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x < b[2])\n\t\t\t\tsquawk(\"upper bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunexpected(s);\n\t\t}\n\tk = lastkw1->kind & KWKind_Mask;\n\tif ((k == KWKind_Void && !tagin) || k == KWKind_Str)\n\t\tsquawk(\"cannot accept a %s value\", tokname[lastseen]);\n\telse {\n\t\tstrcpy(*sp = (char*)Alloc(strlen(s)+1), s);\n\t\tif (ld)\n\t\t\tset_lastdef(s, 0);\n\t\t}\n ret:\n\tlastseen = Saw_type;\n\t}\n\n%}\n\nALias\t\"ALIAS\"[ \\t]+[a-z][a-z_0-9]*\nD\t[0-9]\nKword\t[a-z][a-z_0-9]*\nFunc\t[a-zA-Z_0-9()][,a-zA-Z_0-9<>():.+*/\\-\\[\\] \\t]*\nNum\t[\\-+]?({D}+(\".\"{D}*)?|\".\"{D}+)([eE]([\\-+]?){D}+)?\nPPname\t[a-zA-Z][a-zA-Z0-9_]*\nws\t[ \\t]+\n\n%s FNC VAL\n\n%%\n\n\\n\t\t{ ++Lineno; }\n{ws}\t\t{}\n<INITIAL>{ALias}\t{ Alias(yytext); }\n<INITIAL>\"INTEGER\"\t{ Type(KWKind_Int, yytext); }\n<INITIAL>\"INTEGERLIST\"\t{ Type(KWKind_Int | KWKind_List, yytext); }\n<INITIAL>\"KEYWORD\"\t{ kw_finish(0); }\n<INITIAL>\"KEYWORD1\"\t{ kw_finish(KWKind_1); }\n<INITIAL>\"KEYWORD01\"\t{ kw_finish(KWKind_01); }\n<INITIAL>\"KEYWORD12\"\t{ kw_finish(KWKind_12); }\n<INITIAL>\"LIBNAME\"\t{ Type(KWKind_Str|KWKind_Libname, yytext); }\n<INITIAL>\"REAL\"\t\t{ Type(KWKind_Real, yytext); }\n<INITIAL>\"REALLIST\"\t{ Type(KWKind_Real | KWKind_List, yytext); }\n<INITIAL>\"STRING\"\t{ Type(KWKind_Str, yytext); }\n<INITIAL>\"STRINGLIST\"\t{ Type(KWKind_Str | KWKind_List, yytext); }\n<INITIAL>{Kword}\t{ Keywd(yytext); }\n<INITIAL>\";\"\t\t{ kw_finish(-1); }\n<INITIAL>\"DESC\"\t\t{ Saw_stok(Saw_desc, offsetof(KWctx,desc));\tBEGIN VAL; }\n<INITIAL>\"TAG\"\t\t{ Saw_stok(Saw_tag, offsetof(KWctx,tag));\tBEGIN VAL; }\n<INITIAL>\"GROUP\"\t{ Saw_stok(Saw_group, offsetof(KWctx,group));\tBEGIN VAL; }\n<INITIAL>\"DYNLIB\"\t{ Saw_tok(Saw_dy, offsetof(KWctx,dylib));\n\t\t\t  dynlibseen = 1; dynline = Lineno;\t\tBEGIN VAL; }\n<INITIAL>\"LEN1\"\t\t{ Saw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\t  lastkw1->kind |= KWKind_Len1OK;\t\tBEGIN VAL; }\n<INITIAL>\"LEN\"\t\t{ Saw_stok(Saw_len, offsetof(KWctx,len));\tBEGIN VAL; }\n<INITIAL>\":=\"\t\t{ Saw_tok(Saw_dflt, KWKind_init); lastdef = 0;\tBEGIN VAL; }\n<INITIAL>\">=\"\t\t{ Saw_tok(Saw_ge, KWKind_Lb); btype = KWKind_caneqLb;\tBEGIN VAL; }\n<INITIAL>\">\"\t\t{ Saw_tok(Saw_gt, KWKind_Lb); btype = KWKind_strictLb;\tBEGIN VAL; }\n<INITIAL>\"<=\"\t\t{ Saw_tok(Saw_le, KWKind_Ub); btype = KWKind_caneqUb;\tBEGIN VAL; }\n<INITIAL>\"<\"\t\t{ Saw_tok(Saw_lt, KWKind_Ub); btype = KWKind_strictUb;\tBEGIN VAL; }\n<VAL>{PPname}\t\t{ if (Saw_name(yytext))\tBEGIN INITIAL; }\n<VAL>{Num}\t\t{ Saw_num(yytext);\tBEGIN INITIAL; }\n<VAL>\\\"\t\t\t{ Saw_quote();\t\tBEGIN INITIAL; }\n\n\"{\"\t\t{ Lbrace(); BEGIN FNC; }\n\"}\"\t\t{ Rbrace(); BEGIN INITIAL; }\n\"|\"\t\t{ Bar(); }\n\"(\"\t\t{ Lpar(); }\n\")\"\t\t{ Rpar(); }\n\"[\"\t\t{ Lsqb(); }\n\"]\"\t\t{ Rsqb(); }\n<FNC>{Func}\t{ Fnc(yytext); }\n<FNC>\";\"\t{}\n\"#\".*\\n\t\t{++Lineno;}\n\"/*\"\t\t{ Eat_comment(); }\n.\t{ botch(\"\\\"%s\\\" unexpected\", yytext); }\n\n%%\n\n static void\ncantopen(char *what)\n{ fprintf(stderr, \"%s: cannot open \\\"%s\\\"\\n\", progname, what); }\n\n int\nyywrap(void)\n{\n\tif (tagin) {\n\t\tif (tagin != stdin)\n\t\t\tfclose(tagin);\n\t\ttagin = 0;\n\t\tLineno = 1;\n\t\tsaweof = 1;\n\t\tif (*specfile == '-' && !specfile[1]) {\n\t\t\tyyin = stdin;\n\t\t\tinfname = 0;\n\t\t\treturn 0;\n\t\t\t}\n\t\tif ((yyin = fopen(infname = specfile, \"r\")))\n\t\t\treturn 0;\n\t\tcantopen(specfile);\n\t\texit(1);\n\t\t}\n\treturn 1;\n\t}\n\n static void\nEat_comment(void)\n{\n\tint c;\n\n\tfor(;;) {\n\t\tc = input();\n c_check:\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within /* comment */\");\n\t\tif (c == '*') {\n\t\t\tc = input();\n\t\t\tif (c == '/')\n\t\t\t\treturn;\n\t\t\tgoto c_check;\n\t\t\t}\n\t\tif (c == '\\n')\n\t\t\t++Lineno;\n\t\t}\n\t}\n\n static void\nSaw_quote(void)\n{\n\tKWctx *kw, *kw1, *kw2;\n\tchar buf[1024];\n\tchar *b, *b0, *be, *lname;\n\tint c, c0;\n\tsize_t L, L0, L1;\n\tunsigned char *us;\n\n\tstatic char escname[32];\n\tstatic char hexdig[16] = \"0123456789abcdef\";\n\tstatic unsigned char esetup[] = \"\\aa\\bb\\ff\\nn\\rr\\tt\\vv\";\n\n\tif (!escname['\\a'])\n\t\tfor(us = esetup; *us; us += 2)\n\t\t\tescname[*us] = us[1];\t/* assuming ASCII */\n\tb0 = b = buf;\n\tL = sizeof(buf);\n\tbe = b + L - 3;\t/* allow room for /xhh */\n\tc0 = 0;\n\tsaweof = 0;\n\tfor(;;) {\n\t\tc = input();\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within quoted string\");\n\t\tif (b >= be) {\n\t\t\tL1 = b - b0;\n\t\t\tL0 = L;\n\t\t\tL <<= 1;\n\t\t\tbe = (char*)Malloc(L, \"Saw_quote\");\n\t\t\tmemcpy(be, b0, L1);\n\t\t\tif (b0 != buf)\n\t\t\t\tfree(b0);\n\t\t\tb0 = be;\n\t\t\tb = b0 + L1;\n\t\t\tbe = b0 + L - 3;\n\t\t\t}\n\t\tif (c < ' ') {\n\t\t\t*b++ = '\\\\';\n\t\t\tif (escname[c]) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\t++Lineno;\n\t\t\t\tc = escname[c];\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t*b++ = 'x';\n\t\t\t\t*b++ = '0' + (c >> 4);\n\t\t\t\tc = hexdig[c & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t*b++ = c;\n\t\tif (c0 == '\\\\')\n\t\t\tc0 = 0;\n\t\telse {\n\t\t\tc0 = c;\n\t\t\tif (c == '\"') {\n\t\t\t\twhile((c = input()) <= ' ') {\n\t\t\t\t\tif (c == EOF || !c) {\n\t\t\t\t\t\tc = ';';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (c == '\\n')\n\t\t\t\t\t\t++Lineno;\n\t\t\t\t\t}\n\t\t\t\tif (c == '\"' && !saweof) {\n\t\t\t\t\t--b;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tb[-1] = 0;\t/* replacing \" */\n\tif (lastseen == Saw_tag) {\n\t\tif (saweof) /* kludge around poor flex design */ {\n\t\t\ttagin = stdin;\n\t\t\tSaw_name(b0);\n\t\t\ttagin = 0;\n\t\t\t}\n\t\telse\n\t\t\tSaw_name(b0);\n\t\t}\n\telse {\n\t\tL = b - b0;\n\t\tbe = (char*)Alloc(L);\n\t\tmemcpy(be, b0, L);\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t  case Saw_dfltname:\n\t\t\tif ((lastkw1->kind & KWKind_Mask) != KWKind_Str)\n\t\t\t\tbotch(\"%s cannot have a string-valued := value\",\n\t\t\t\t\tlastkw1->names->val);\n\t\t\tlastkw1->cinit = be;\n\t\t\tif (lastdef)\n\t\t\t\tset_lastdef(b0, 1);\n\t\t\tbreak;\n\t\t  case Saw_desc:\n\t\t\tlastkw1->desc = be;\n\t\t\tbreak;\n\t\t  case Saw_dy:\n\t\t\tlastkw1->dylib = be;\n\t\t\tif (lastkw1->nfcn > 0)\n\t\t\t\tfuncbotch(lastkw1);\n\t\t\tif (libexpand) {\n\t\t\t\tkw = *KWtop;\n\t\t\t\tlastseen = Saw_kwname;\n\t\t\t\tif (kw == lastkw1)\n\t\t\t\t\tkw = *--KWtop;\n\t\t\t\telse if ((kw2 = kw->rparent))\n\t\t\t\t\tkw = kw2;\n\t\t\t\tkw1 = lastkw1;\n\t\t\t\tif ((kw2 = kw->kw) == kw1) {\n\t\t\t\t\tif ((kw2 = kw->kw = kw2->next)\n\t\t\t\t\t && kw2->alt == kw1->alt)\n\t\t\t\t\t\tBar();\n\t\t\t\t\telse  {\n\t\t\t\t\t\t--kw->alt;\n\t\t\t\t\t\tif (kw1->req)\n\t\t\t\t\t\t\t--kw->nreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tLpar();\n\t\t\t\tKeywd(kw1->name1);\n\t\t\t\tlname = kw1->dylib;\n\t\t\t\tif (lib_read(kw1,0))\n\t\t\t\t\tlastkw1->dylib = lname;\n\t\t\t\tRpar();\n\t\t\t\tif (kw1->parstate == PPar_leftpar)\n\t\t\t\t\t++KWtop;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t  case Saw_group:\n\t\t\tlastkw1->group = be;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tunexpected(\"string\");\n\t\t  }\n\t\t}\n\tif (b0 != buf)\n\t\tfree(b0);\n\tlastseen = Saw_type;\n\t}\n\n static int\nusage(int rc)\n{\n\tfprintf(rc ? stderr : stdout,\n\t\"Usage: %s [options] specfile [tagfile [defs_out [keywds_out]]]\\n\\\n\twhere the last two are output files, \\\".\\\" means \\\"omit\\\", and \\\"-\\\"\\n\\\n\tmeans write to stdout.  Missing trailing arguments are not read\\n\\\n\tor written, except that if all outputs are missing, \\\". -\\\" is assumed.\\n\\\n\tOptions may modify this behavior.\\noptions:\\n\\\n\t-D\t\t{ just write definitions to stdout }\\n\\\n\t-d\t\t{ suppress test for ambiguity from duplicate keywords }\\n\\\n\t-e\t\t{ expand ((...)) for debugging }\\n\\\n\t-f\t\t{ omit functions, i.e., {...} with -p; without -p,\\n\\\n\t\t\t  supply NULL function pointers }\\n\\\n\t-G\t\t{ for keywords with a TAG but not GROUP, do not assume\\n\\\n\t\t\t  that implictly GROUP == TAG }\\n\\\n\t-g\t\t{ write GuiKeyWord rather than KeyWord header;\\n\\\n\t\t\t  with -p, include GUI details: TAG, DESC, GROUP, LEN }\\n\\\n\t-h headername\t{ Specify header file(s), e.g., \\\"-h nidr.h\\\";\\n\\\n\t\t\t  several -h options can be given;\\n\\\n\t\t\t  default = -h- ==> no headers }\\n\\\n\t-j specsum\t{ write file specsum for use by \\\"dakreord specsum ...\\\"\\n\\\n\t\t\t  and \\\"dakreorder -j specsum ...\\\" }\\n\\\n\t-k keyname\t{ library mode with input containing several keywords\\n\\\n\t\t\t  to be contained in keyword keyname; implies -l and\\n\\\n\t\t\t  has no other effect if -D, -g, -j, -p, or -s is given.\\n\\\n\t\t\t  If -l is given without -k and several keywords appear\\n\\\n\t\t\t  in the input, assume \\\"-k KeywordTop\\\". }\\n\\\n\t-L libname\t{ obtain keyword details from library libname (compiled\\n\\\n\t\t\t  from source produced by an earlier \\\"nidrgen -l ...\\\"\\n\\\n\t\t\t  invocation); non-option arguments in this case are\\n\\\n\t\t\t  [defs_out [keywds_out]] }\\n\\\n\t-l\t\t{ library mode: with -D, -g, -j, -p, or -s, attempt to\\n\\\n\t\t\t  load libraries specified with \\\"DYNLIB libname\\\" and\\n\\\n\t\t\t  incorporate keyword specifications provided by the\\n\\\n\t\t\t  loaded libraries; otherwise generate source for\\n\\\n\t\t\t  compilation into a shared library for loading when a\\n\\\n\t\t\t  keyword marked with \\\"DYNLIB libname\\\" (in a separate\\n\\\n\t\t\t  run of nidrgen) is seen.  The library provides\\n\\\n\t\t\t  contained keywords and any needed final routine for\\n\\\n\t\t\t  the marked keyword. }\\n\\\n\t-m mtagfile\t{ just write to mtagfile tags not found in tagfile }\\n\\\n\t-n namespname\t{ assume namespace namespname;\\n\\\n\t\t\t  default = -n Dakota\\n\\\n\t\t\t  -n- ==> no namespace }\\n\\\n\t-p[w]\t\t{ pretty-print rather than produce KeyWord header;\\n\\\n\t\t\t  add w spaces (default 2) for each nested context. }\\n\\\n\t-s[w]\t\t{ like -p[w], but sort the keywords }\\n\\\n\t-T outtagfile\t{ write dummy tagfile to outtagfile (and quit) }\\n\\\n\t-t\t\t{ ignore TAG fields if tagfile is not given }\\n\\\n\t-w\t\t{ cancel warn mode: do not report (on stderr)\\n\\\n\t\t\t  the number of implicitly named start routines;\\n\\\n\t\t\t  still flag their names  with /*!!*/ }\\n\",\n\t\tprogname);\n\treturn rc;\n\t}\n\n static StrList *\nreverse(StrList **x)\n{\n\tStrList *s, *t, *u;\n\n\tif (!(s = *x) || !s->next)\n\t\treturn s;\n\tfor(t = 0; s; s = u) {\n\t\tu = s->next;\n\t\ts->next = t;\n\t\tt = s;\n\t\t}\n\treturn *x = t;\n\t}\n\n static int\nkwcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const KWctx**)a)->names->val, (*(const KWctx**)b)->names->val);\n\t}\n\n static KWctx *\nkwsort(KWctx *kw0)\n{\n\t/* Sort keywords after expanding kw list with aliases; compute nkw, */\n\t/* including aliases. */\n\n\tKWctx *kw, *kw1, *kw2, *kwm, **x, **x0, **xe, *x00[512];\n\tStrList *dname, *minname, *nam, **pmin, **pnam;\n\tchar *descsave, *groupsave;\n\tint agadj, nk;\n\tsize_t L, nkw, nkwa, onkwa;\n\n\treverse(&kw0->funcs);\n\tnkw = nkwa = 0;\n\tfor(kw = kw0->kw; kw; kw = kw->next) {\n\t\t++nkw;\n\t\tpmin = &kw->names;\n\t\tminname = *pmin;\n\t\tpnam = &minname->next;\n\t\tonkwa = nkwa;\n\t\twhile((nam = *pnam)) {\n\t\t\tdname = nam;\n\t\t\t++nkwa;\n\t\t\tif (strcmp(nam->val, minname->val) < 0) {\n\t\t\t\tpmin = pnam;\n\t\t\t\tminname = nam;\n\t\t\t\t}\n\t\t\tpnam = &nam->next;\n\t\t\t}\n\t\tagadj = 2*kw->agroup;\n\t\tkw->agroup = agadj + 1;\n\t\tif (nkwa > onkwa) {\n\t\t\t*pmin = minname->next;\n\t\t\tminname->next = kw->names;\n\t\t\tnam = kw->names = minname;\n\t\t\tnk = kw->kno;\t/* ALias() made room for nk use below */\n\t\t\tdescsave = kw->desc;\n\t\t\tgroupsave = kw->group;\n\t\t\tif (dname != minname) {\n\t\t\t\tkw->desc = kw->group = 0;\n\t\t\t\tkw->agroup = agadj;\n\t\t\t\t}\n\t\t\tkwm = kw;\n\t\t\tkw = kw2 = 0;\n\t\t\tif (nam->primary)\n\t\t\t\tkw2 = kwm;\n\t\t\twhile((nam = nam->next)) {\n\t\t\t\tkw1 = (KWctx*)Alloc(sizeof(KWctx));\n\t\t\t\tif (!kw)\n\t\t\t\t\tkw = kw1;\t/* so kw->next is right */\n\t\t\t\tkw1->next = kwm->next;\n\t\t\t\tkwm->next = kw1;\n\t\t\t\tkw1->names = nam;\n\t\t\t\tkw1->master = kwm;\n\t\t\t\tkw1->kind = kwm->kind;\n\t\t\t\tkw1->kno = ++nk;\n\t\t\t\tkw1->agroup = agadj;\n\t\t\t\tif (nam == dname) {\n\t\t\t\t\tkw1->desc = descsave;\n\t\t\t\t\tkw1->group = groupsave;\n\t\t\t\t\tkw1->agroup = agadj + 1;\n\t\t\t\t\t}\n\t\t\t\tif (nam->primary)\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t}\n\t\t\tif (kw2 != kwm && !guikeywds) {\n\t\t\t\tkw2->defname = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->len;\n\t\t\t\tkwm->len = 0;\n\t\t\t\tkw2->init = kwm->init;\n\t\t\t\tkwm->init = 0;\n\t\t\t\tkw2->cinit = kwm->cinit;\n\t\t\t\tkwm->cinit = 0;\n\t\t\t\tkw2->dylib = kwm->dylib;\n\t\t\t\t/* no need to change kwm->dylib */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwm;; kw1 = kw1->next) {\n\t\t\t\tif (kw1 != kw2)\n\t\t\t\t\tkw1->pmaster = kw2;\n\t\t\t\tif (kw1 == kw)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tkw0->nkw = (int)(nkw += nkwa);\n\tif (nkw <= 1)\n\t\treturn kw0->kw;\n\tx0 = x00;\n\tif (nkw > sizeof(x00)/sizeof(x00[0]))\n\t\tx0 = (KWctx**)Malloc(L = nkw*sizeof(KWctx*), \"kwsort\");\n\tfor(x = x0, kw = kw0->kw; kw; kw = kw->next)\n\t\t*x++ = kw;\n\tqsort(x0, nkw, sizeof(KWctx*), kwcomp);\n\tfor(xe = x - 1, x = x0; x < xe; ++x) {\n\t\tif (!strcmp(x[0]->names->val, x[1]->names->val)) {\n\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\tprogname, x[0]->names->val);\n\t\t\t++dupnames;\n\t\t\t}\n\t\tx[0]->next = x[1];\n\t\t}\n\tx[0]->next = 0;\n\tfor(x = x0, ++xe; x < xe; ++x)\n\t\t(*x)->paoff = x - x0;\n\tfor(x = x0; x < xe; ++x)\n\t\tif ((kw1 = (kw = *x)->pmaster))\n\t\t\tkw->paoff = kw1->paoff - kw->paoff;\n\tfor(x = x0; x < xe; ++x)\n\t\tif (!(kw = *x)->pmaster)\n\t\t\tkw->paoff = 0;\n\tkw0->kw = kw = x0[0];\n\tif (x0 != x00)\n\t\tfree(x0);\n\treturn kw;\n\t}\n\n static int\nalphanum(char *s)\n{\n\tfor(; *s; ++s)\n\t\tif (!isalnum(*s))\n\t\t\treturn 0;\n\treturn 1;\n\t}\n\n enum CommaState {\n\tCS_Comma = 0,\n\tCS_Clbra = 1,\n\tCS_rbraC = 2,\n\tCS_lrbrC = 3,\n\tCS_rbr2C = 4\n\t};\n\n static const char\n\t*Commasx[5] = { \",\", \",{\", \"},\", \",{},\",/*{{*/ \"}},\" },\n\t*Commas0[5] = { \",\", \",\", \",\", \",\", \",\" };\n static const char **Comma;\n\n typedef struct Zbuf Zbuf;\n struct\nZbuf {\n\tchar buf[80];\t/* overkill */\n\tchar *b;\n\tint nnz;\n\tenum CommaState cs;\n\t};\n\n static void\niput(int i, Zbuf *z)\n{\n\tchar *s;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (i == 0) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s%d\", t, i);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nnput(char *s, Zbuf *z)\n{\n\tchar *fmt, *s1;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s || (strtod(s,&s1) == 0. && !*s1)) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\t*s++ = '.';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tfmt = \"%s%s.\";\n\t\tfor(s1 = s; *s1; ++s1)\n\t\t\tswitch(*s1) {\n\t\t\t\tcase '.':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'E':\n\t\t\t\t\tfmt = \"%s%s\";\n\t\t\t\t\tgoto have_fmt;\n\t\t\t\t}\n have_fmt:\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(fmt, t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nsput(char *s, Zbuf *z)\n{\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s\\\"%s\\\"\", t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nzbclear(Zbuf *z)\n{\n\tif (z->b > z->buf) {\n\t\t*z->b = 0;\n\t\tprintf(\"%s\", z->b = z->buf);\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n typedef struct\nFCat { char *b, *b0, *be; } FCat;\n\n static char *\nfunc_cat(FCat *fc, StrList *f)\n{\n\tchar *b, *b1, *be;\n\tint k, n;\n\tsize_t L, L1, L2, L3;\n\n\tif (!f)\n\t\treturn 0;\n\tif (!f->next)\n\t\treturn f->val;\n\tb = fc->b;\n\tbe = fc->be;\n\tfor(n = k = 0; f; f = f->next, ++n) {\n\t\tL = L1 = strlen(f->val);\n\t\tif (n) {\n\t\t\t++L1;\n\t\t\tif (n & 1) {\n\t\t\t\tif (alphanum(f->val)) {\n\t\t\t\t\tk = 2;\n\t\t\t\t\tL1 += 7;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = 3;\n\t\t\t\t\tL1 += 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tk = 1;\n\t\t\t}\n\t\tif (L1 > be - b) {\n\t\t\tL2 = b - fc->b;\n\t\t\tL3 = 2*(be - fc->b + L1);\n\t\t\tb1 = (char*)Malloc(L3, \"func_cat\");\n\t\t\tif (L2)\n\t\t\t\tmemcpy(b1, fc->b, L2);\n\t\t\tif (fc->b != fc->b0)\n\t\t\t\tfree(fc->b);\n\t\t\tfc->b = b1;\n\t\t\tbe = fc->be = b1 + L3;\n\t\t\tb = b1 + L2;\n\t\t\t}\n\t\tswitch(k) {\n\t\t\tcase 0: break;\n\t\t\tcase 1: *b++ = ',';\n\t\t\t\tbreak;\n\t\t\tcase 2: memcpy(b, \",(void*)\", 8);\n\t\t\t\tb += 8;\n\t\t\t\tbreak;\n\t\t\tcase 3: memcpy(b, \",(void*)(\", 9);\n\t\t\t\tb += 9;\n\t\t\t}\n\t\tstrcpy(b, f->val);\n\t\tb += L;\n\t\tif (k == 3)\n\t\t\t*b++ = ')';\n\t\t*b = 0;\n\t\t}\n\treturn fc->b;\n\t}\n\n static void\nkwout(KWctx *kw, KWctx **kwtop, Uint xflag)\n{\n\tFCat fc;\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, **kws, **x, *x0[KWOUTlen0];\n\tStrList *S, *nam;\n\tZbuf z;\n\tchar fbuf[256], *funcs, *s;\n\tconst char *fmt, *ffmt;\n\tint aoff, k, i, m, m1, n, roff, sentinnel, skipfuncs;\n\n\tif (expand && !kw->names)\n\t\treturn;\n\tif (needcomma) {\n\t\tprintf(\",\\n\");\n\t\tneedcomma = 0;\n\t\t}\n\tkw1 = kw->kw;\n\tn = 0;\n\tfc.b = fc.b0 = fbuf;\n\tfc.be = fbuf + sizeof(fbuf);\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastkno + 1;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastkno + 1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tif (expand)\n\t\tfor(kw0 = kw1; kw0 && !kw0->names; kw0 = kw0->next)\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next)\n\t\t\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwout\");\n\tm = 0;\n\tkw0 = kw1;\n\tif (expand) {\n\t\taoff = kw->nalt;\n\t\troff = kw->nreq;\n\t\tfor(; kw0 && !kw0->names; kw0 = kw0->next) {\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next) {\n\t\t\t\tkw2->altoffset = aoff;\n\t\t\t\tkw2->reqoffset = roff;\n\t\t\t\tx[m++] = kw2;\n\t\t\t\t}\n\t\t\taoff += kw0->nalt;\n\t\t\troff += kw0->nreq;\n\t\t\t}\n\t\tkw->nalt = aoff;\n\t\tkw->nreq = roff;\n\t\t}\n\tfor(; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tsentinnel = 0;\n\tif (expand) {\n\t\tkw->nkw = m;\n\t\tqsort(x, m, sizeof(KWctx*), kwcomp);\n\t\tfor(i = 1; i < m; ++i)\n\t\t\tif (!strcmp(x[i-1]->names->val, x[i]->names->val)) {\n\t\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\t\tprogname, x[i]->names->val);\n\t\t\t\t++dupnames;\n\t\t\t\t}\n\t\t}\n\telse if (kw->nkw == 0)\n\t\tsentinnel = 1;\n\tm1 = m + sentinnel;\n\tprintf(\"\\tkw_%d[%d] = {\\n\" /*}*/, kw->kwkno = ++lastkno, m1);\n\tneedcomma = 1;\n\tz.nnz = 0;\n\tskipfuncs = !wantfuncs && !xflag;\n\tfor(i = 0; i < m;) {\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tif (!(kwp = kw1->pmaster))\n\t\t\tkwp = kw1;\n\t\tfputs(xflag ? \"\\t\\t{{\" : \"\\t\\t{\" /*}}}*/, stdout);\n\t\tz.b = z.buf;\n\t\tz.cs = CS_Comma;\n\t\tif ((nam = kw1->names)) {\n\t\t\tk = kwp->kind | kw1->names->primary | xflag;\n\t\t\tif (kwp->dylib)\n\t\t\t\tk |= KWKind_Dynlib;\n\t\t\tprintf(k < 16\n\t\t\t\t? \"\\\"%s\\\",%d\"\n\t\t\t\t: \"\\\"%s\\\",0x%x\", kw1->names->val, k);\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(kwm->alt + kwm->altoffset, &z);\n\t\t\tiput(kwm->req ? kwm->req + kwm->reqoffset : 0, &z);\n\t\t\t}\n\t\telse {\n\t\t\tif (xflag)\n\t\t\t\tprintf(\"0,0x%x\", xflag);\n\t\t\telse\n\t\t\t\tprintf(\"0,0\");\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(0, &z);\n\t\t\tiput(0, &z);\n\t\t\t}\n\t\tif (guikeywds)\n\t\t\tiput(kw1->agroup, &z);\n\t\tif ((n = kwm->kwkno)) {\n\t\t\tzbclear(&z);\n\t\t\tprintf(xflag ? \",(KeyWord*)kw_%d\": \",kw_%d\", n);\n\t\t\t}\n\t\telse\n\t\t\tiput(0, &z);\n\t\tnput(kwp->lb, &z);\n\t\tnput(kwp->ub, &z);\n\t\tffmt = /*{{{*/ !xflag ? \"}%s\" : \"}}%s\";\n\t\tif (guikeywds) {\n\t\t\tnput(kwm->init, &z);\n\t\t\tsput(kwm->cinit, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tif (!(s = kw1->group) && dfltgroup)\n\t\t\t\ts = kw1->tag;\n\t\t\tsput(s, &z);\n\t\t\tif (kwm->len)\n\t\t\t\tsput(kwm->len, &z);\n\t\t\tif (kwm->dylib)\n\t\t\t\tsput(kwm->dylib, &z);\n\t\t\tgoto nofuncs;\n\t\t\t}\n\t\tiput(kw1->paoff, &z);\n\t\tif (skipfuncs && !kwp->dylib)\n\t\t\tgoto nofuncs;\n\t\tz.nnz = 0;\n\t\tfuncs = 0;\n\t\tif (kwp->dylib) {\n\t\t\tz.cs = CS_Clbra;\n\t\t\tfor(n = 0; n < 3; ++n)\n\t\t\t\tiput(0,&z);\n\t\t\tzbclear(&z);\n\t\t\tprintf(\",(void*)\\\"%s\\\"\", kwp->dylib);\n\t\t\tz.cs = CS_rbr2C;\n\t\t\tz.nnz = 0;\n\t\t\t}\n\t\telse if ((S = kwp->funcs)) {\n\t\t\tif (!S->next && !strcmp(S->val,\"0\"))\n\t\t\t\tgoto xcheck;\n\t\t\tif (!kwp->kw && S->needrev)\n\t\t\t\tS = reverse(&kwp->funcs);\n\t\t\tfuncs = func_cat(&fc, S);\n\t\t\tgoto funcput;\n\t\t\t}\n\t\telse if ((S = kwm->funcs)) {\n\t\t\tfuncs = func_cat(&fc, S);\n funcput:\n\t\t\tz.cs = CS_lrbrC;\n\t\t\tif (funcs && wantfuncs & 1) {\n\t\t\t\tzbclear(&z);\n\t\t\t\tprintf(\",%s\", funcs);\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tiput(0,&z);\n\t\t\t}\n\t\telse if (kwm->names && wantfuncs & 1 && !(kwm->kind & KWKind_Libname)) {\n\t\t\t++missing;\n\t\t\tprintf(\",/*!!*/\");\n\t\t\tfor(kws = KWStack; ++kws <= kwtop; ) {\n\t\t\t\tif (!(kw2 = *kws)->names)\n\t\t\t\t\tkw2 = kw2->rparent;\n\t\t\t\tprintf(\"%s_\", kw2->names->val);\n\t\t\t\t}\n\t\t\tprintf(\"%s_start\", kwm->names->val);\n\t\t\t}\n xcheck:\n\t\tif (xflag) {\n\t\t\tif (z.nnz) {\n\t\t\t\tz.cs = z.cs == CS_rbraC ? CS_rbr2C : CS_rbraC;\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\t\tz.nnz = 0;\n\t\t\t\t}\n\t\t\telse if (z.cs == CS_rbr2C)\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\telse {\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\tffmt = /*{{*/ \"}}%s\";\n\t\t\t\t}\n\t\t\tz.b = z.buf;\n\t\t\tiput(nam ? nam->seqno : 0, &z);\n\t\t\tiput(kw1->agroup, &z);\n\t\t\tsput(funcs, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tsput(kw1->group, &z);\n\t\t\tsput(kw1->defname, &z);\n\t\t\tsput(kw1->len, &z);\n\t\t\tsput(kw1->init, &z);\n\t\t\tsput(kw1->cinit, &z);\n\t\t\tif (z.nnz)\n\t\t\t\tffmt = /*{*/ \"}%s\";\n\t\t\t}\n nofuncs:\n\t\tprintf(ffmt, i < m1 ? \",\\n\" : \"\\n\");\n\t\t}\n\tif (sentinnel)\n\t\tfputs(\"\\t\\t{\\\"\\\"}\\n\", stdout);\n\tprintf(/*{*/\"\\t\\t}\");\n\tif (x != x0)\n\t\tfree(x);\n\tif (fc.b != fbuf)\n\t\tfree(fc.b);\n\t}\n\n static void\nhashclear(KWctx *kw)\n{\n\tStrList *sl;\n\n\tkw->parstate = Dupchecked;\n\tfor(kw = kw->kw; kw; kw = kw->next)\n\t\tfor(sl = kw->names; sl; sl = sl->next) {\n\t\t\tsl->h.hnext->hprev = sl->h.hprev;\n\t\t\tsl->h.hprev->hnext = sl->h.hnext;\n\t\t\tsl->h.hprev = sl->h.hnext = 0;\n\t\t\t}\n\t}\n\n static void\ndupfound(HashHead *h0, StrList *sl, StrList *sl1)\n{\n\tStrList *sl2, *sl3;\n\n\t++dupnames;\n\tfor(sl2 = sl1; sl2->h.hnext != h0; sl2 = sl3) {\n\t\tsl3 = (StrList*)sl2->h.hnext;\n\t\tif (strcmp(sl->val, sl3->val))\n\t\t\tbreak;\n\t\t}\n\tfprintf(stderr, \"Warning: \\\"%s\\\" on line %d also appears on line%s %d\",\n\t\tsl->val, sl->Lineno, \"s\" + (sl2 == sl1), sl1->Lineno);\n\twhile(sl1 != sl2) {\n\t\tsl1 = (StrList*)sl1->h.hnext;\n\t\tfprintf(stderr, \", %d\", sl1->Lineno);\n\t\t}\n\tfputs(\".\\n\", stderr);\n\t}\n\n static KWctx **\nhashadd(KWctx *kw, KWctx **kwtop)\n{\n\tHashHead *h, *h0;\n\tKWctx *kw1;\n\tStrList *sl, *sl1;\n\tchar *s;\n\tint n;\n\tunsigned int c, x;\n\n\tkw->parstate = Dupchecking;\n\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\tfor(sl = kw1->names; sl; sl = sl->next) {\n\t\t\tx = 0;\n\t\t\ts = sl->val;\n\t\t\twhile((c = *(unsigned char*)s++))\n\t\t\t\tx = 43*x + c - ' ';\n\t\t\th0 = &HTab[x % HTlen];\n\t\t\tfor(h = h0->hnext; h != h0; h = h->hnext) {\n\t\t\t\tsl1 = (StrList*)h;\n\t\t\t\tn = strcmp(sl->val, sl1->val);\n\t\t\t\tif (n <= 0) {\n\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\tdupfound(h0,sl,sl1);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsl->h.hnext = h;\n\t\t\th->hprev = (sl->h.hprev = h->hprev)->hnext = (HashHead *)sl;\n\t\t\t}\n\tif ((kw1 = kw->kw))\n\t\t*++kwtop = kw1;\n\treturn kwtop;\n\t}\n\n static void\ndup_check(void)\n{\n\tHashHead *h, *he;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tfor(h = HTab, he = h + HTlen; h < he; ++h)\n\t\th->hnext = h->hprev = h;\n\tplist = 0;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;) {\n\t\tkw = *kwtop;\n\t\tlev = kw->level;\n\t\twhile(plist && plist->level >= lev) {\n\t\t\thashclear(plist);\n\t\t\tplist = plist->next;\n\t\t\t}\n\t\tif (kw->parstate == Dupchecking) {\n\t\t\thashclear(kw);\n\t\t\tif ((*kwtop = kw->next))\n\t\t\t\tcontinue;\n\t\t\tif (kwtop <= kwbot)\n\t\t\t\tbreak;\n\t\t\t--kwtop;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif ((kw1 = kw->pparent) && kw1->parstate != Dupchecking) {\n\t\t\tfor(kw2 = kw1; plist && kw2; plist = plist->next) {\n\t\t\t\twhile(kw2->level > plist->level && (kw2 = kw2->pparent));\n\t\t\t\tif (kw2 != plist)\n\t\t\t\t\tbreak;\n\t\t\t\thashclear(plist);\n\t\t\t\t}\n\t\t\tkw2 = 0;\n\t\t\tdo {\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tkw1->next = kw2;\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Dupchecking);\n\t\t\twhile(kw2) {\n\t\t\t\tkwtop = hashadd(kw2, kwtop);\n\t\t\t\tkw1 = kw2;\n\t\t\t\tkw2 = kw2->next;\n\t\t\t\tkw1->next = plist;\n\t\t\t\tplist = kw1;\n\t\t\t\t}\n\t\t\t}\n\t\tkwtop = hashadd(kw, kwtop);\n\t\t}\n\t}\n\n static void\nprkwname(KWctx *kw, const char *suf, int needrev)\n{\n\tint k;\n\tStrList *S;\n\tstatic const char *kname[] = { \"BUG\", \"INTEGER\", \"REAL\", \"STRING\" };\n\n\tif (needrev)\n\t\treverse(&kw->names);\n\tS = kw->names;\n\tprintf(\"%s\", S->val);\n\twhile((S = S->next))\n\t\tprintf(\" ALIAS %s\", S->val);\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tprintf(\" %s\", kname[k]);\n\t\tif (kw->kind & KWKind_List)\n\t\t\tprintf(\"LIST\");\n\t\t}\n\tif (kw->lb)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictLb ? \">\" : \">=\", kw->lb);\n\tif (kw->ub)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictUb ? \"<\" : \"<=\", kw->ub);\n\tif (kw->defname && wantfuncs & 1) {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s %s\", kw->defname, kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := %s \\\"%s\\\"\", kw->defname, kw->cinit);\n\t\t}\n\telse {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s\", kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := \\\"%s\\\"\", kw->cinit);\n\t\t}\n\tif (!(wantfuncs&1))\n\t\tgoto sufchk;\n\tif (kw->tag)\n\t\tprintf(ignoretags ? \" TAG \\\"%s\\\"\" : \" /*TAG \\\"%s\\\"*/\", kw->tag);\n\tif (kw->funcs) {\n\t\tfputs(\" {\", stdout);\n\t\treverse(&kw->funcs);\n\t\tfor(S = kw->funcs;;) {\n\t\t\tfputs(S->val, stdout);\n\t\t\tif (!(S = S->next))\n\t\t\t\tbreak;\n\t\t\tputchar(',');\n\t\t\t}\n\t\tputchar('}');\n\t\t}\n\tif (kw->len)\n\t\tprintf(\" LEN %s\", kw->len);\n\tif (kw->group)\n\t\tprintf(\" GROUP \\\"%s\\\"\", kw->group);\n\tif (kw->desc)\n\t\tprintf(\" DESC \\\"%s\\\"\", kw->desc);\n sufchk:\n\tif (kw->dylib)\n\t\tprintf(\" DYNLIB \\\"%s\\\"\", kw->dylib);\n\tif (suf)\n\t\tfputs(suf, stdout);\n\tif (needrev == 2)\n\t\treverse(&kw->names);\n\t}\n\n static KWctx *\nkwrev(KWctx **pkw)\n{\n\tKWctx *kw, *kw0, *kw1;\n\tkw1 = *pkw;\n\tfor(kw0 = 0; (kw = kw1); kw0 = kw) {\n\t\tkw1 = kw->next;\n\t\tkw->next = kw0;\n\t\t}\n\treturn *pkw = kw0;\n\t}\n\n static int\nStrListcmp(StrList *sl1, StrList *sl2)\n{\n\tif (sl1 == sl2)\n\t\treturn 0;\n\twhile(sl1) {\n\t\tif (!sl2 || strcmp(sl1->val, sl2->val))\n\t\t\treturn 1;\n\t\tsl1 = sl1->next;\n\t\tsl2 = sl2->next;\n\t\t}\n\treturn sl2 != 0;\n\t}\n\n#if 0\t/* Could hash keywords and use the following samekw to find duplicate  */\n\t/* contained keywords, noting duplicates when found in a new, normally */\n\t/* NULL pointer in KWctx, but so far this does not appear worthwhile.  */\n#define OffsetOf(T,f) ((char*)&((T*)0)->f - (char*)0)\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n#define ValueOf(T,x,o) (*(T*)((char*)x + o))\n\n static int\nsamekw(KWctx *kw1, KWctx *kw2)\n{\n\tchar *s1, *s2;\n\tsize_t *sp, *spe;\n\n\tstatic size_t\n\t\tIntoff[] = {\n\t\t\tOffsetOf(KWctx,alt),\n\t\t\tOffsetOf(KWctx,kind),\n\t\t\tOffsetOf(KWctx,nalt),\n\t\t\tOffsetOf(KWctx,nkw),\n\t\t\tOffsetOf(KWctx,nreq),\n\t\t\tOffsetOf(KWctx,req)\n\t\t\t},\n\t\tStroff[] = {\n\t\t\tOffsetOf(KWctx,lb),\n\t\t\tOffsetOf(KWctx,ub),\n\t\t\tOffsetOf(KWctx,init),\n\t\t\tOffsetOf(KWctx,cinit),\n\t\t\tOffsetOf(KWctx,defname),\n\t\t\tOffsetOf(KWctx,desc),\n\t\t\tOffsetOf(KWctx,dylib),\n\t\t\tOffsetOf(KWctx,group),\n\t\t\tOffsetOf(KWctx,len)\n\t\t\t};\n\twhile(kw1) {\n\t\tif (!kw2)\n\t\t\treturn 0;\n\t\tif (kw1->pparent != kw2->pparent\n\t\t || kw1->rparent != kw2->rparent)\n\t\t\treturn 0;\n\t\tif (StrListcmp(kw1->names, kw2->names)\n\t\t || StrListcmp(kw1->funcs, kw2->funcs))\n\t\t\treturn 0;\n\t\tfor(sp = Intoff, spe = sp + NumberOf(Intoff); sp < spe; ++sp)\n\t\t\tif (ValueOf(int,kw1,*sp) != ValueOf(int,kw2,*sp))\n\t\t\t\treturn 0;\n\t\tfor(sp = Stroff, spe = sp + NumberOf(Stroff); sp < spe; ++sp) {\n\t\t\ts1 = ValueOf(char*,kw1,*sp);\n\t\t\ts2 = ValueOf(char*,kw2,*sp);\n\t\t\tif (s1 != s2 && (!s1 || !s2 || strcmp(s1,s2)))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tkw1 = kw1->next;\n\t\tkw2 = kw2->next;\n\t\t}\n\treturn kw2 == 0;\n\t}\n#undef ValueOf\n#undef NumberOf\n#undef OffsetOf\n#endif\n\n static void\nparadj(int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, **kwp, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (needrev)\n\t\tkwrev(kwtop);\n\n\t/* remove extra parens */\n\n\tfor(;; --kwtop) {\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n top:\n\t\t\tif (needrev && (kw1 = kw->kw) && kw1->next)\n\t\t\t\tkwrev(&kw->kw);\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Parchecked) {\n\t\t\t\tkwp = &kw->pparent;\n\t\t\t\tplist = kw;\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif (kw1->kw) {\n\t\t\t\t\t\t*kwtop++ = kw1;\n\t\t\t\t\t\tkw1->parstate = Parchecked;\n\t\t\t\t\t\t*kwp = kw1;\n\t\t\t\t\t\tkwp = &kw1->pparent;\n\t\t\t\t\t\tkw1->next = plist;\n\t\t\t\t\t\tplist = kw1;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!(*kwp = kw1->pparent)) {\n\t\t\t\t\t\tlev = kw1->level;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw1 = *kwp;\n\t\t\t\t\tif (kw1->parstate == Parchecked) {\n\t\t\t\t\t\tlev = kw1->level + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tfor(;; plist = kw1) {\n\t\t\t\t\tplist->level = lev++;\n\t\t\t\t\tif (plist == kw)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tkw1 = plist->next;\n\t\t\t\t\tplist->next = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = kw->kw;\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static KWctx *\nmasteradj(KWctx *kw)\n{\n\t/* to help print (nm1 | nm2 foo goo), make nm2 \"master\" */\n\tKWctx *kw1, *kw2, *kw3, *kwm, *rv;\n\n\tfor(kw1 = kw, kw3 = 0; kw1; kw1 = kw1->next) {\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn kw;\n\tfor(rv = kw; kw; kw = kw->next) {\n\t\tkwm = kw->master;\n\t\tif ((kw1 = kw->next) && kw1->master == kwm && kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in masteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->next) && kw1->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tkw = kw2;\n\t\t\t}\n\t\t}\n\treturn rv;\n\t}\n\n static void\nxmasteradj(KWctx **x, int n)\n{\n\t/* variant of masteradj for pretty_ex1 */\n\tKWctx *kw, *kw1, *kw2, *kw3, *kwm;\n\tint i, j;\n\n\tfor(i = 0, kw3 = 0; i < n; ++i) {\n\t\tkw1 = x[i];\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn;\n\tfor(i = 0; i < n; i = j) {\n\t\tj = i + 1;\n\t\tkw = x[i];\n\t\tkwm = kw->master;\n\t\tif (j < n && kwm && (kw1 = x[j])->master == kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in xmasteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(++j < n && (kw1 = x[j])->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = x[++i]) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;; kw = x[++i]) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n static void\ndo_indent(int indent)\n{\n\tfor(indent += 8; indent >= 8; indent -= 8)\n\t\tputchar('\\t');\n\tfor(; indent > 0; --indent)\n\t\tputchar(' ');\n\t}\n\n static void\ndo_indent1(int indent)\t/* write indent-1 spaces */\n{\n\twhile(--indent > 0)\n\t\tputchar(' ');\n\t}\n\n static const char *KEYKIND[4] = { \"KEYWORD \", \"KEYWORD01 \", \"KEYWORD1 \", \"KEYWORD12 \" };\n\n static void\npretty_print(int iinc, int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, *kw3, **kwtop, **kwbot, *plist;\n\tconst char *s;\n\tint alt, indent, lev, needindent, needspace;\n\n\tkwtop = kwbot = KWStack;\n\tindent = 0;\n\tplist = 0;\n\tneedindent = 1;\n\tfor(kw1 = KWbase.kw; kw1;) {\n\t\tfputs(KEYKIND[(kw1->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw1, \"\\n\", needrev);\n\t\t*kwtop = masteradj(kw1->kw);\n\t\talt = 0;\n\t\tfor(;;--kwtop) {\n\t top:\n\t\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\t\tlev = kw->level;\n\t\t\t\tif (needindent) {\n\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\tneedindent = 0;\n\t\t\t\t\t}\n\t\t\t\tif (plist\n\t\t\t\t && (plist->level > lev\n\t\t\t\t  || (plist->level == lev && plist != kw->pparent))) {\n finishpar:\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = plist;\n\t\t\t\t\t*++kwtop = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Printing) {\n\t\t\t\t\ts = !kw->names || /*[(*/kw->req ? \")\\n\" : \"]\\n\";\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\ts = /*(*/ \")\\n\";\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tfputs(s, stdout);\n\t\t\t\t\tneedindent = 1;\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tindent -= iinc;\n\t\t\t\t\tif (!kw->names) {\n\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\tgoto bot;\n\t\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (plist)\n\t\t\t\t\tfor (kw2 = kw->pparent;\n\t\t\t\t\t\t\tkw2 && kw2->parstate != Printing;\n\t\t\t\t\t\t\tkw2 = kw2->pparent) {\n\t\t\t\t\t\tif (plist->level >= kw2->level)\n\t\t\t\t\t\t\tgoto finishpar;\n\t\t\t\t\t\t}\n\t\t\t\tneedindent = 1;\n\t\t\t\tneedspace = 0;\n\t\t\t\tif (alt == kw->alt) {\n\t\t\t\t\tputchar('|');\n\t\t\t\t\tneedspace = 1;\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->pparent) && kw2->parstate != Printing) {\n\t\t\t\t\tkw3 = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (kw2->parstate == Printing)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (kw2->kw) {\n\t\t\t\t\t\t\tkw2->next = kw3;\n\t\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t\tkw2->parstate = Printing;\n\t\t\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\t\t\tneedspace = 0;\n\t\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t\tputchar('('); /*)*/\n\t\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((kw2 = kw2->pparent));\n\t\t\t\t\twhile(kw3) {\n\t\t\t\t\t\tkw2 = kw3->next;\n\t\t\t\t\t\tkw3->next = plist;\n\t\t\t\t\t\tplist = kw3;\n\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->master) && kw == kw2)\n\t\t\t\t\tkw2 = 0;\n\t\t\t\tif (!kw->kw && (!kw2 || kw2->parstate == Leftput)) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t\tif (!kw->req) {\n\t\t\t\t\t\tif (alt != kw->alt) {\n\t\t\t\t\t\t\tfputs(\"[ \", stdout);\n\t\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\ts = /*[*/ \" ]\\n\";\n\t\t\t\t\t\tif ((kw2 = kw->next) && kw2->alt == alt)\n\t\t\t\t\t\t\ts = \"\\n\";\n\t\t\t\t\t\tprkwname(kw, s, needrev);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Leftput) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tgoto putspace;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\tputchar(kw->req ? '(' : '['); /*])*/\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\tputchar('('/*)*/);\n\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tindent += iinc;\n putspace:\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t}\n\t\t\t\tkw->parstate = Printing;\n\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\tif (kw2) {\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tkw2->parstate = Leftput;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\talt = 0;\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = masteradj(kw->kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n bot:\n\t\t\tif (kwtop == kwbot) {\n\t\t\t\tif (plist) {\n\t\t\t\t\t*kwtop++ = plist;\n\t\t\t\t\t*kwtop++ = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (indent) {\n\t\t\t\t\t\tif (needindent)\n\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\tfputs(/*(*/\")\\n\", stdout);\n\t\t\t\t\t\tneedindent = 1;\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (!(kw1 = kw1->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static void\nnslist(StrList *h, const char *fmt)\n{\n\tfor(; h; h = h->next)\n\t\tprintf(fmt, h->val);\n\t}\n\n static void\nOutput(StrList *headers, StrList *nsname, int hwant, const char *kname, int libmode, int nwant)\n{\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tStrList *h;\n\tUint xflag;\n\tconst char *fmt;\n\tint kwkno;\n\tstatic char\n\t\tlibfmt1[] = \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n\"\n\t\t\t\"KeyWord *keyword_add(void);\\n}\\n#endif\\n\\n\"\n\t\t\t\" KeyWord*\\nkeyword_add(void) {\\n\\t\",\n\t\tlibfmt2[] = \"kw_%d[0].kw;\\n\\t}\\n\",\n\t\tlibfmt3[] = /*{*/ \"kw_%d.kw;\\n\\t}\\n\";\n\n\tif (hwant && headers) {\n\t\tfor(h = reverse(&headers); h; h = h->next)\n\t\t\tprintf(*h->val == '<' /*>*/\n\t\t\t\t? \"#include %s\\n\"\n\t\t\t\t: \"#include \\\"%s\\\"\\n\", h->val);\n\t\t}\n\tif (nwant) {\n\t\tif (nsname)\n\t\t\treverse(&nsname);\n\t\telse\n\t\t\tnsname = new_StrList(\"Dakota\", nsname);\n\t\tputchar('\\n');\n\t\tnslist(nsname, \"namespace %s {\\n\" /*}*/);\n\t\t}\n\tprintf(\"\\n/** %d distinct keywords (plus %d aliases) **/\\n\\nstatic %sKeyWord%s\\n\",\n\t\tlastagroup, nalias, guikeywds ? \"Gui\" : \"\", libmode ? \"x\" : \"\");\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (libmode) {\n\t\txflag = KWKind_Extended;\n\t\tComma = Commasx;\n\t\t}\n\telse {\n\t\txflag = 0;\n\t\tComma = Commas0;\n\t\t}\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwout(kw, kwtop, xflag);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tprintf(\";\\n\\n\");\n\tif (nwant) {\n\t\tnslist(reverse(&nsname), /*{*/\"} // namespace %s\\n\");\n\t\tputchar('\\n');\n\t\treverse(&nsname);\n\t\t}\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"extern \\\"C\\\" {\\n\");\n\tprintf(\"#endif\\n\");\n\n\tkwkno = KWbase.kwkno;\n\tif (libmode) {\n\t\tif (KWbase.nkw > 1 && !kname)\n\t\t\tkname = \"KeywordTop\";\n\t\tprintf(libfmt1);\n\t\tfmt = libfmt2;\n\t\tif (kname) {\n\t\t\tprintf(\"static KeyWordx kw_%d = { \\\"%s\\\", 0x%x,%d,%d,%d,(KeyWord*)\",\n\t\t\t\tkwkno + 1, kname, KWKind_Dynmult, KWbase.nkw,\n\t\t\t\tKWbase.alt, KWbase.req);\n\t\t\tif (nwant) {\n\t\t\t\tnslist(nsname, \"%s::\");\n\t\t\t\tnwant = 0;\n\t\t\t\t}\n\t\t\tprintf(\"kw_%d };\\n\\t\", kwkno++);\n\t\t\tfmt = libfmt3;\n\t\t\t}\n\t\tprintf(\"return &\");\n\t\t}\n\telse {\n\t\tprintf(\"KeyWord Dakota_Keyword_Top = {\\\"KeywordTop\\\",0,%d,%d,%d,\",\n\t\t\tKWbase.nkw, KWbase.alt, KWbase.req);\n\t\tfmt = \"kw_%d};\\n\";\n\t\t}\n\tif (nwant)\n\t\tnslist(nsname, \"%s::\");\n\tprintf(fmt, kwkno);\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"}\\n\");\n\tprintf(\"#endif\\n\");\n\n\tif (startwarn && missing && !guikeywds)\n\t\tfprintf(stderr, \"%s: %d start routines implicitly named.\\n\",\n\t\t\tprogname, missing);\n\t}\n\n typedef struct Valhash Valhash;\n\n struct\nValhash {\n\tDefhashHead hh;\n\tUint n;\n\tValhash *thread;\n\t};\n\n static Kwpack *kwpack, *kwpack0, *kwpacke;\n static size_t kwpack_len, strtab_len = 1;\n static DefhashTab FpTab, StrTab;\n static Valhash *FpTabLast, *StrTabLast;\n\n static Uint\nNumOff(char *name)\n{\n\tValhash *v;\n\tif (!name || !*name || (*name == '0' && !name[1]))\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &FpTab, 1);\n\tif (!v->n) {\n\t\tv->n = FpTab.nent;\n\t\tv->thread = FpTabLast;\n\t\tFpTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static Uint\nStrOff(char *name)\n{\n\tValhash *v;\n\tif (!name)\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &StrTab, 1);\n\tif (!v->n) {\n\t\tv->n = strtab_len;\n\t\tstrtab_len += strlen(name) + 1;\n\t\tv->thread = StrTabLast;\n\t\tStrTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static void\nkwjout(KWctx *kw, KWctx **kwtop)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, **x, *x0[KWOUTlen0];\n\tKwpack *p;\n\tUint lastknoj;\n\tint i, m, n;\n\tsize_t L;\n\n\tkw1 = kw->kw;\n\tn = 0;\n\tlastknoj = kwpack - kwpack0 + 1;\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastknoj;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastknoj;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwjout\");\n\tm = 0;\n\tfor(kw0 = kw1; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tkw->kwkno = lastknoj;\n\t++lastkno;\n\tfor(i = 0; i < m;) {\n\t\tif (++kwpack >= kwpacke) {\n\t\t\tL = 2*kwpack_len;\n\t\t\tkwpack0 = (Kwpack*)Realloc(kwpack0, L*sizeof(Kwpack), \"kwjout\");\n\t\t\tkwpacke = kwpack0 + L;\n\t\t\tkwpack = kwpack0 + kwpack_len;\n\t\t\tmemset(kwpack, 0, kwpack_len*sizeof(Kwpack));\n\t\t\tkwpack_len = L;\n\t\t\t}\n\t\tp = kwpack;\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tp->nkw = kwm->nkw;\n\t\tif (kw1->names) {\n\t\t\tp->name = StrOff(kw1->names->val);\n\t\t\tp->kind = kw1->kind | kw1->names->primary;\n\t\t\tp->alt = kwm->alt + kwm->altoffset;\n\t\t\tif (kwm->req)\n\t\t\t\tp->req = kwm->req + kwm->reqoffset;\n\t\t\tif (kwm->dylib) {\n\t\t\t\tp->dylib = StrOff(kwm->dylib);\n\t\t\t\tp->kind |= KWKind_Dynlib;\n\t\t\t\t}\n\t\t\t}\n\t\tp->kw = kwm->kwkno;\n\t\tp->Lb = NumOff(kw1->lb);\n\t\tp->Ub = NumOff(kw1->ub);\n\t\tp->poff = kw1->paoff;\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static Valhash *\nVreverse(Valhash *sh)\n{\n\tValhash *sh0, *sh1;\n\tfor(sh0 = 0; sh; sh = sh1) {\n\t\tsh1 = sh->thread;\n\t\tsh->thread = sh0;\n\t\tsh0 = sh;\n\t\t}\n\treturn sh0;\n\t}\n\n static void\nkwpack_adjust(Kwpack *kp, Uint nkw)\n{\n\tKwpack0 *qp, *qpe;\n\n\tqp = (Kwpack0*)kp;\n\tfor(qpe = qp + nkw; qp < qpe; ++kp, ++qp) {\n\t\tmemcpy(qp, kp, sizeof(Kwpack0) - sizeof(int));\n\t\tqp->poff = kp->poff;\n\t\t}\n\t}\n\n static void\njOutput(char *jfname)\n{\n\tFILE *f;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tKwpack *kp;\n\tUint nkw0;\n\tValhash *vh;\n\tdouble d;\n\tsize_t L, Lkw, Ls;\n\tstatic KwpHead head = { \"DakreorderKwds\\n\", 1e13, 0x1234abcd };\n\tstatic double zbuf[2];\n\n\tFpTab.nalloc  = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tStrTab.nalloc = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tkwpack_len = 128;\n\tkwpack = kwpack0 = (Kwpack*)Malloc(kwpack_len * sizeof(Kwpack), \"jOutput\");\n\tmemset(kwpack, 0, kwpack_len * sizeof(Kwpack));\n\tkwpacke = kwpack0 + kwpack_len;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwjout(kw, kwtop);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tStrTabLast = Vreverse(StrTabLast);\n\tFpTabLast = Vreverse(FpTabLast);\n\tnkw0 = kwpack - kwpack0;\n\thead.nkw = nkw0 + 1;\n\tkp = kwpack0;\n\tkp->kw = nkw0 - KWbase.nkw + 1;\n\tkp->nkw = KWbase.nkw;\n\tkp->alt = KWbase.alt;\n\tkp->req = KWbase.req;\n\thead.strtab_offset = (FpTab.nent+1)*sizeof(double);\n\tLs = (strtab_len + 7) & ~7;\n\thead.kw_offset = head.strtab_offset + Ls;\n\tif ((head.pad = dynlibseen))\n\t\tLkw = sizeof(Kwpack);\n\telse {\n\t\tLkw = sizeof(Kwpack0);\n\t\tkwpack_adjust(kp, head.nkw);\n\t\t}\n\thead.end_offset = head.kw_offset + head.nkw * Lkw;\n\tf = fopen(jfname, \"wb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open \\\"%s\\\"\\n\", jfname);\n\t\texit(1);\n\t\t}\n\tfwrite(&head, sizeof(head), 1, f);\n\tfor(vh = FpTabLast; vh; vh = vh->thread) {\n\t\td = strtod(vh->hh.name,0);\n\t\tfwrite(&d, sizeof(double), 1, f);\n\t\t}\n\tfwrite(&zbuf,9,1,f);\n\tfor(vh = StrTabLast; vh; vh = vh->thread)\n\t\tfwrite(vh->hh.name, strlen(vh->hh.name) + 1, 1, f);\n\tif ((L = Ls - strtab_len))\n\t\tfwrite(&zbuf, L, 1, f);\t/* align */\n\tfwrite(kp, Lkw, head.nkw, f);\n\tfclose(f);\n\t}\n\n typedef int (*KWcomp)(const void*, const void*);\n\n static const char **zalt;\n\n static int\nkwcomp1(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static int\nkwcomp2(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb, *pa, *pb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tpa = ka->master ? ka->master->pparent : ka->pparent;\n\t\tpb = kb->master ? kb->master->pparent : kb->pparent;\n\t\tif (pa != pb)\n\t\t\treturn ka->objno - kb->objno;\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static void\ndo_sort(KWctx *kw, KWcomp KWcmp)\n{\n\tKWctx *kw1, *kwm, **x, *x0[KWPlen];\n\tconst char *z0[KWPlen];\n\tint i, n, na;\n\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\t++n;\n\t\treverse(&kw1->names);\n\t\t}\n\tif (n <= 1)\n\t\treturn;\n\tx = n > KWPlen ? (KWctx**)Malloc(n*sizeof(KWctx*), \"do_sort\") : x0;\n\tna = kw->nalt + 1;\n\tzalt = na <= KWPlen ? z0 : (const char**)Malloc(na*sizeof(const char*), \"do_sort\");\n\tmemset(zalt, 0, na*sizeof(const char*));\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\tx[n++] = kw1;\n\t\tif ((kwm = kw1->master))\n\t\t\tkwm->master = kwm;\n\t\tif (!zalt[i = kw1->alt]\n\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\tzalt[i] = kw1->names->val;\n\t\t}\n\tqsort(x, n--, sizeof(KWctx*), KWcmp);\n\tfor(i = 0; i < n; ++i)\n\t\tx[i]->next = x[i+1];\n\tx[n]->next = 0;\n\tkw->kw = x[0];\n\tif (zalt != z0)\n\t\tfree(zalt);\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nksort(KWcomp KWcmp)\n{\n\tKWctx *kw, *kw1, **kwtop, **kwtop0, **kwbot;\n\n\tkwtop = kwbot = KWStack;\n\n\tfor(*kwtop = &KWbase;; --kwtop) {\n top:\n\t\tkw = *kwtop;\n top1:\n\t\twhile(kw) {\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Sorted) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\tkwtop0 = kwtop;\n\t\t\t\tdo {\n\t\t\t\t\tkw1->parstate = Sorted;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t}\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Sorted);\n\t\t\t\tif (kwtop > kwtop0)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tdo_sort(kw, KWcmp);\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = *kwtop = kw->kw;\n\t\t\t\tgoto top1;\n\t\t\t\t}\n\t\t\tkw = kw->next;\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static void\npretty_ex1(KWctx *kw, KWctx *prevkw, KWctx *nextkw, int indent, int iinc, int needrev)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, *kwp0, **x, *y, *y1;\n\tconst char *suf, *z0[KWPlen];\n\tint ep, i, i0, ia, j, n, na, np;\n\n\tn = 0;\n\tx = 0;\n\ty = 0;\n\tkw1 = kw->kw;\n\tif (needrev == 1)\n\t\tneedrev = 2;\n\tif ((kwp0 = kwp = kw->pparent) && (!kw->master || kw->master == kw)) {\n\t\tfor(;;) {\n\t\t\tif (kwp->parstate != Printing) {\n\t\t\t\tkwp->parstate = Printing;\n\t\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t\tkw1->pparent = 0;\t/* avoid infinite loops */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t++n;\n\t\t\tif (!(kw1 = kwp->pparent))\n\t\t\t\tbreak;\n\t\t\tkwp = kwp->pparent = kw1;\n\t\t\t}\n\t\tnp = n;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\t++n;\n\t\ty = y1 = (KWctx*)Malloc(np*sizeof(KWctx) + n*sizeof(KWctx*), \"pretty_ex1\");\n\t\tx = (KWctx**)(y + np);\n\t\tfor(i = 0, kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\tx[i++] = kw1;\n\t\ti0 = i;\n\t\tfor(kwp = kwp0; kwp; kwp = kwp->pparent) {\n\t\t\tj = i;\n\t\t\tna = i + kwp->nalt;\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next, ++y1) {\n\t\t\t\tmemcpy(y1, kw1, sizeof(KWctx));\n\t\t\t\tx[i++] = y1;\n\t\t\t\ty1->alt += j;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!needrev) {\n\t\t\tfor(j = i0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t}\n\t\t\tzalt = ++na <= KWPlen ? z0\n\t\t\t\t: (const char**)Malloc(na*sizeof(const char*), \"pretty_ex1\");\n\t\t\tmemset(zalt, 0, na*sizeof(const char*));\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif ((kwm = kw1->master))\n\t\t\t\t\tkwm->master = kwm;\n\t\t\t\tif (!zalt[i = kw1->alt]\n\t\t\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\t\t\tzalt[i] = kw1->names->val;\n\t\t\t\t}\n\t\t\tqsort(x, n, sizeof(KWctx*), kwcomp1);\n\t\t\tif (zalt != z0)\n\t\t\t\tfree(zalt);\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif (kw1->nreq < 0) {\n\t\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t\tkw1->pparent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tkw1 = x[0];\n\t\txmasteradj(x, n);\n\t\t}\n\tif (kw1) {\n\t\tif (!x)\n\t\t\tkw1 = masteradj(kw->kw);\n\t\tep = kw->req;\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tia = kw->master && kw->master == prevkw->master ? iinc : 0;\n\t\t\tdo_indent(indent + ia);\n\t\t\tif (!prevkw->master || prevkw->master != kw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent + ia);\n\t\t\t\tputchar('(');\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tputchar('|');\n\t\t\t}\n\t\telse {\n\t\t\tdo_indent(indent);\n\t\t\tif (kw->req)\n\t\t\t\tputchar('('/*)*/);\n\t\t\telse {\n\t\t\t\tputchar('[');\n\t\t\t\tif (nextkw && !nextkw->req && kw->alt == nextkw->alt) {\n\t\t\t\t\tep = 1;\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\tputchar('(');\n\t\t\t\t\tindent += iinc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdo_indent1(iinc);\n\t\tindent += iinc;\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\ti = 0;\n\t\tkw0 = 0;\n\t\twhile(kw1) {\n\t\t\tif (x)\n\t\t\t\tkw2 = ++i >= n ? 0 : x[i];\n\t\t\telse\n\t\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, indent, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\tkw1 = kw2;\n\t\t\t}\n\t\tif (x)\n\t\t\tfree(y);\n\t\tdo_indent(indent);\n\t\tfputs(ep ? \")\\n\" : \"]\\n\", stdout);\n\t\t}\n\telse {\n\t\tif (prevkw && kw->alt == prevkw->alt\n\t\t && kw->master && kw->master == prevkw->master)\n\t\t\tindent += iinc;\n\t\tdo_indent(indent);\n\t\tsuf = \"\\n\";\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tif (kw->master && kw->master != prevkw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent);\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfputs(\"| \", stdout);\n\t\t\t\tif (!kw->req)\n\t\t\t\t\tgoto rbcheck;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (kw->req) {\n\t\t\tif (prevkw) {\n\t\t\t\tif (prevkw->master != kw->master)\n\t\t\t\t\tgoto putlpar;\n\t\t\t\t}\n\t\t\telse if (kw != kw->master && kw->master) {\n putlpar:\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tfputs(\"[ \", stdout);\n rbcheck:\n\t\t\tif (!nextkw || nextkw->alt != kw->alt)\n\t\t\t\tsuf = \" ]\\n\";\n\t\t\t}\n\t\tprkwname(kw, suf, needrev);\n\t\t}\n\t}\n\n static void\npretty_expand(int iinc, int needrev)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2;\n\n\tif ((kw = KWbase.kw)) for(;;) {\n\t\tmasteradj(kw->kw);\n\t\tfputs(KEYKIND[(kw->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\tkw0 = 0;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw2) {\n\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, 0, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\t}\n\t\tif (!(kw = kw->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static int\nStr_option(char *s, char ***pav, int *want, StrList **ps)\n{\n\tif (*++s || (s = *++*pav)) {\n\t\tif (*s == '-' && ! s[1])\n\t\t\t*want = 0;\n\t\telse\n\t\t\t*ps = new_StrList(s, *ps);\n\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}\n\n static int\nversion(void)\n{\n\tprintf(\"nidrgen version 20100528\\n\");\n\treturn 0;\n\t}\n\n static int\ntagcomp(const void *a, const void *b)\n{\n\treturn strcmp(*(const char**)a, *(const char**)b);\n\t}\n\n static int\nunused_tags()\n{\n\tTaghash *th;\n\tchar **x;\n\tsize_t i, nbad;\n\n\tnbad = 0;\n\tfor(th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\t++nbad;\n\tif (!nbad)\n\t\treturn 0;\n\tx = (char**)Malloc(nbad*sizeof(char*), \"unsed_tags\");\n\tfor(i = 0, th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\tx[i++] = th->hh.name;\n\tfprintf(stderr, \"%lu unused tag definition%s in %s:\\n\",\n\t\t(unsigned long)nbad, \"s\" + (nbad == 1), tagfname);\n\tif (nbad > 1)\n\t\tqsort(x, nbad, sizeof(char*), tagcomp);\n\tfor(i = 0; i < nbad; ++i)\n\t\tfprintf(stderr, \"\\t\\\"%s\\\"\\n\", x[i]);\n\tfree(x);\n\treturn 1;\n\t}\n\n static int\ndefcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const Defhash**)a)->hh.name, (*(const Defhash**)b)->hh.name);\n\t}\n\n static void\nwrite_defs(FILE *f)\n{\n\tDefhash *d, **x, **x1;\n\tDefhashHead *dh;\n\tsize_t i, n;\n\n\tn = DHTab.nent;\n\tx = x1 = (Defhash**)Malloc(n*sizeof(Defhash*), \"write_defs\");\n\tfor(dh = DHTab.lastdh, i = 0; dh; dh = dh->thread) {\n\t\tif (++i > n)\n\t\t\tbotch(\"lastdef count botch\");\n\t\t*x1++ = (Defhash*)dh;\n\t\t}\n\tqsort(x, n, sizeof(Defhash*), defcomp);\n\tfor(i = 0; i < n; ++i) {\n\t\td = x[i];\n\t\tfprintf(f, d->qkeep ? \"#define %s \\\"%s\\\"\\n\"\n\t\t\t: \"#define %s %s\\n\",\n\t\t\td->hh.name, d->value);\n\t\t}\n\t}\n\n int\nmain(int argc, char **argv)\n{\n\tFILE *f;\n\tStrList *headers, *mtagname, *nsname, *outtagname;\n\tchar *defsout, *jfname, *ofname, *s, *se;\n\tconst char *kname, *libex, *libname;\n\tint defwrite, dupcheck, hwant, libmode, needrev, nwant, pprint, sort, x;\n\n\tKWStack[0] = &KWbase;\n\tDHTab.nalloc  = (sizeof(Defhash) + sizeof(void*) - 1)/sizeof(void*);\n\tTagTab.nalloc = (sizeof(Taghash) + sizeof(void*) - 1)/sizeof(void*);\n\tKWbase.names = new_StrList(\"$top\",0);\n\tprogname = argv[0];\n\tif (argc <= 1)\n usage1:\treturn usage(1);\n\theaders = mtagname = nsname = outtagname = 0;\n\tkname = libex = libname = defsout = jfname = ofname = 0;\n\tdupcheck = hwant = needrev = nwant = 1;\n\tdefwrite = libmode = pprint = sort = 0;\n nextopt:\n\twhile((s = *++argv) && *s == '-' && s[1]) {\n\t\twhile(*++s)\n\t\tswitch(*s) {\n\t\t case 'D':\n\t\t\tdefwrite = libexpand = 1;\n\t\t\tlibex = \"-D\";\n\t\t\tbreak;\n\t\t case 'T':\n\t\t\tif (Str_option(s, &argv, &hwant, &outtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'd':\n\t\t\tdupcheck = 0;\n\t\t\tbreak;\n\t\t case 'e':\n\t\t\texpand = 1;\n\t\t\tbreak;\n\t\t case 'f':\n\t\t\twantfuncs = 0;\n\t\t\tbreak;\n\t\t case 'g':\n\t\t\tguikeywds = libexpand = 1;\n\t\t\tlibex = \"-g\";\n\t\t\tbreak;\n\t\t case 'G':\n\t\t\tdfltgroup = 0;\n\t\t\tbreak;\n\t\t case 'h':\n\t\t\tif (Str_option(s, &argv, &hwant, &headers))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'j':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tjfname = s;\n\t\t\tlibexpand = 1;\n\t\t\tlibex = \"-j\";\n\t\t\tgoto nextopt;\n\t\t case 'k':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tkname = s;\n\t\t\tlibmode = 1;\n\t\t\tgoto nextopt;\n\t\t case 'l':\n\t\t\tlibmode = 1;\n\t\t\tbreak;\n\t\t case 'L':\n have_L:\n\t\t\tif (*++s)\n\t\t\t\tlibname = s;\n\t\t\telse if (!(libname = *++argv))\n\t\t\t\treturn usage(1);\n\t\t\tgoto nextopt;\n\t\t case 'm':\n\t\t\tif (Str_option(s, &argv, &hwant, &mtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'n':\n\t\t\tif (Str_option(s, &argv, &nwant, &nsname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 't':\n\t\t\tignoretags = 1;\n\t\t\tbreak;\n\t\t case 's':\n\t\t\tsort = 1;\n\t\t\tneedrev = 0;\n\t\t\tlibex = \"-s\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L': ++s; goto have_L;\n\t\t\t\t  case 'e': expand = 1;\n\t\t\t\t\t    continue;\n\t\t\t\t  case 'f': wantfuncs = 0;\n\t\t\t\t  case 'p': continue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t case 'p':\n\t\t\tlibexpand = 1;\n\t\t\tpprint = 2;\n\t\t\tif (!libex)\n\t\t\t\tlibex = \"-p\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L':\n\t\t\t\t\t++s;\n\t\t\t\t\tgoto have_L;\n\t\t\t\t  case 'e':\n\t\t\t\t\texpand = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 'f':\n\t\t\t\t\twantfuncs = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 's':\n\t\t\t\t\tsort = 1;\n\t\t\t\t\tneedrev = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 't':\n\t\t\t\t\tignoretags = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (*++s) {\n\t\t\t\tpprint = (int)strtol(s,&se,10);\n\t\t\t\tif (pprint < 1 || se)\n\t\t\t\t\tgoto usage1;\n\t\t\t\t}\n\t\t\tgoto nextopt;\n\t\t case 'v':\n\t\t\treturn version();\n\t\t case 'w':\n\t\t\tstartwarn = 0;\n\t\t\tbreak;\n\t\t case '?':\n\t\t\treturn usage(s[1] != 0);\n\t\t case '-':\n\t\t\tif (!strcmp(++s,\"help\"))\n\t\t\t\treturn usage(0);\n\t\t\tif (!strcmp(s,\"version\"))\n\t\t\t\treturn version();\n\t\t\tif (!*s) {\n\t\t\t\ts = *++argv;\n\t\t\t\tgoto argsdone;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t  default:\n\t\t\tgoto usage1;\n\t\t  }\n\t\t}\n argsdone:\n\tif (libname) {\n\t\tif (s && argv[1] && argv[2])\n\t\t\treturn usage(1);\n\t\tif ((defsout = s))\n\t\t\tofname = argv[1];\n\t\tif (mtagname) {\n\t\t\tfprintf(stderr, \"\\n%s: ignoreing -m due to -L\\n\", progname);\n\t\t\tmtagname = 0;\n\t\t\t}\n\t\tgoto lcheck;\n\t\t}\n\tif (!s || (argv[1] && argv[2] && argv[3] && argv[4]))\n\t\treturn usage(1);\n\tif ((tagfname = argv[1])) {\n\t\tspecfile = s;\n\t\ts = tagfname;\n\t\tlastseen = Saw_kwname;\n\t\tlastkw1 = &KWbase;\n\t\tif ((defsout = argv[2]))\n\t\t\tofname = argv[3];\n\t\t}\n\telse if (mtagout) {\n\t\tfprintf(stderr, \"%s: -m specified but no tagfile given.\\n\", progname);\n\t\treturn 1;\n\t\t}\n\tif (*s == '-' && !s[1])\n\t\tyyin = stdin;\n\telse if (!(yyin = fopen(infname = s, \"r\"))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n\tif (specfile)\n\t\ttagin = yyin;\n\tif ((mtagname && (!(mtagout = fopen(s = mtagname->val, \"w\"))))\n\t || (outtagname && !(tagout = fopen(s = outtagname->val, \"w\")))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n lcheck:\n\tif (libmode) {\n\t\twantfuncs |= 2;\n\t\tif (libexpand && kname) {\n\t\t\tlibmode = 0;\n\t\t\tfprintf(stderr, \"\\n%s: ignoring -k due to %s\\n\",\n\t\t\t\tprogname, libex);\n\t\t\t}\n\t\t}\n\telse\n\t\tlibexpand = 0;\n\tif (libname)\n#ifndef NO_NIDR_DYNLIB\n\t\tlibread1(0, libname, 0, 2);\n#else\n\t\t{\n\t\tfprintf(stderr, \"\\ndlopen for \\\"%s\\\" is NOT SUPPORTED\\n\", libname);\n\t\treturn usage(1);\n#endif\n\t\t}\n\telse if ((x = yylex())) {\n\t\tfprintf(stderr, \"\\n%s: Surprise return %d from yylex()\\n\", progname, x);\n\t\treturn x;\n\t\t}\n\tif (mtagout)\n\t\tfclose(mtagout);\n\tif (tagout)\n\t\tfclose(tagout);\n\tif (tagout || mtagout)\n\t\tgoto done;\n\tif (Br_top > Br_stack) {\n\t\tfputs(\"Missing \", stderr);\n\t\tdo putc(/*[*/ *Br_top-- == '(' ? ')' : ']', stderr);\n\t\t\twhile(Br_top >Br_stack);\n\t\tfputs(\" at end of file.\\n\", stderr);\n\t\treturn 1;\n\t\t}\n\tif (nsquawk > liberror)\n\t\treturn 1;\n\tif (tagfname && unused_tags())\n\t\treturn 1;\n\tif (KWbase.kw) {\n\t\tparadj(needrev);\n\t\tif (dupcheck)\n\t\t\tdup_check();\n\t\t}\n\tif (jfname)\n\t\tofname = 0;\n\telse if (ofname && !freopen(ofname, \"w\", stdout)) {\n\t\tfprintf(stderr, \"%s: Cannot open output file \\\"%s\\\"\\n\", progname, ofname);\n\t\treturn 1;\n\t\t}\n\tif (KWbase.kw) {\n\t\tif (pprint) {\n\t\t\tif (expand) {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp1);\n\t\t\t\tpretty_expand(pprint, needrev);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp2);\n\t\t\t\tpretty_print(pprint, needrev);\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!defwrite) {\n\t\t\tif (jfname)\n\t\t\t\tjOutput(jfname);\n\t\t\telse\n\t\t\t\tOutput(headers, nsname, hwant, kname,\n\t\t\t\t\tguikeywds ? 0 : libmode, nwant);\n\t\t\t}\n\t\telse if (DHTab.lastdh)\n\t\t\twrite_defs(stdout);\n\t\t}\n\tif (!defwrite && defsout) {\n\t\tf = fopen(defsout,\"w\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s:  cannot open defs file \\\"%s\\\"\\n\",\n\t\t\t\tprogname, defsout);\n\t\t\treturn 1;\n\t\t\t}\n\t\twrite_defs(f);\n\t\tfclose(f);\n\t\t}\n done:\n\treturn dupnames > 0 ? 1 : liberror ? 2 : 0;\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/cmake/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/DDACEDesignCompExp.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/src/java_utils/antlr-runtime-4.1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge.resu",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge_opt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/script_interfaces/TankExamples/VVTankProblem.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/script_interfaces/Abaqus/tpb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/script_interfaces/VisualBasic/Rosenbrock.xls",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/script_interfaces/Nastran/cylinder/modal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/eval_surrogate/eval_surrogate.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/training/201508/examples/pstudy_pics/demo_lhs_norm.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/training/201508/examples/pstudy_pics/demo_lhs_unif.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/training/201508/examples/pstudy_pics/demo_grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/training/201508/examples/pstudy_pics/demo_centered.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/linked_interfaces/ModelCenter/lib/i686-cygwin-cygwinNT/libPHXCppApi.a",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/linked_interfaces/ModelCenter/lib/i686-cygwin-cygwinNT/PHXCppApi.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/examples/parallelism/Dakota_Application_Parallelism.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/admin/vpy/python.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/3po/mvs/v8/Debug/hooke.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/3po/mvs/v8/Release/cobyla2c.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/3po/mvs/v8/Release/python25.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/tinyxml/tinyxml/xmltest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/tinyxml/tinyxml/utf8test.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/tinyxml/tinyxml/tinystr.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/vpykit/python.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/guide.epub",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/example.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/prev.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/next.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/home.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/caution.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/tip.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/note.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/important.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/cxxtest/doc/images/icons/callouts/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/momhlib/MOMHLib/HGA/hgabase.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/momhlib/NewProblemTemplate/NewProblemTemplate.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/momhlib/moscp/MOSCP.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/tpl/momhlib/MOKP/mokp.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/refs.dox",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/refs.html",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/form_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/uguide/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/interfaces/doc/figs/GSGA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/colin/test/driver/simple1.nl",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/colin/doc/05-01-ICS-COLIN.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/src/utilib/bimap.h",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/test/studies/fserialstream.ref",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/doc/userman.pdf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/doc/uguide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/utilib/doc/uguide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/refs.dox",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/refs.html",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/form_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/uguide/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/scolib/doc/figs/GSGA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/sample-load-graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4.1/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.3/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/packages/pebbl/doc/uguide/1.4/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/doc/uguide/userman.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/doc/uguide/acro.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/doc/uguide/acro.tif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/acro/doc/coliny/ColinyCommand_3_0.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/DDACE/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/DDACE/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/DDACE/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/CONMIN/Conmin_manual/conmin_manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/lib/optMaui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/lbllogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/nersclogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/doxygen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/gensetMin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_opt++.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_classpath.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/sandialogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/tBird2D.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_subroutine.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_arrays.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/opt++_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_nips.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/gensetBox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_config.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_startup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_application.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/gensetStd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_noaction.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/csmrlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/maui_advanced.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/OPTPP/docs/images/bckgnd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/QUESO_users_manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/doxygen/fig_common/circle-logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/doxygen/fig_common/circle-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/examples/infinite_dim/gaussian_fields/mesh.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/queso/examples/infinite_dim/operator/mesh.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NCSUOpt/userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/interfaces/DLL/single_obj/bb.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/interfaces/DLL/bi_obj/bb.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/advanced/plot/GUI/f1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/advanced/plot/GUI/f2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/advanced/plot/GUI/bbe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/advanced/plot/GUI/obj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/basic/library/single_obj/basic_lib.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/examples/basic/batch/single_obj/bb.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/tools/SENSITIVITY/2739.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/tools/SENSITIVITY/problems/cube/detailed/cache.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/tools/PSD-MADS/SJE001150.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/user_guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/logos/nomad_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/logos/nomadTransp.icns",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/logos/nomad_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/logos/Nomad_background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/NOMAD/doc/logos/nomadIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/motif/src/Widgets/SciPlotDocs/new.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/motif/src/Widgets/SciPlotDocs/SciPlotTitle.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/motif/src/Widgets/SciPlotDocs/SciPlotDemo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/motif/src/Widgets/SciPlotDocs/SciPlotExample.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/website/HOPSPACK_Logo_120x118.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/website/HOPSPACK_SNL_NNSA_100x734.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/website/usermanual_image_tiny.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/BlockDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/winmsvc_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalWithMpiClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalWithMpi.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/GssHierarchyDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/BlockDiagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/winconsole_cmake.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalDiagramClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalWithMt.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/EvalWithMtClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/GssHierarchyDiagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/doc/winconsole_cmake_msvc.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/hopspack/community_problems/community_appspack.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/examples/SamplingTechniques/random.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/examples/SamplingTechniques/oas.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/examples/ValidationData/Overall_GP_comparison.xls",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/docs/TimingMatrixOp/kriging_times_50to3000.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/docs/TimingMatrixOp/timing_poly2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/surfpack/docs/TimingMatrixOp/timing_poly2_0to5000_estimates.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/lib/x86/pthreadVSE2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/lib/x86/pthreadVC2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/lib/x64/pthreadVC2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/dll/x86/pthreadVSE2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/dll/x86/pthreadGC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/dll/x86/pthreadGCE2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/dll/x86/pthreadVC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/eddy/threads/pthreads/dll/x64/pthreadVC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/FrontEnd/Managed/vc71/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/FrontEnd/Managed/vc90/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/FrontEnd/Managed/vc80/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/images/JEGAFlow.doc",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/images/mogatest1_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/images/scope_trace.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/images/pareto_front.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/images/JEGAFlow.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/JEGA/docs/users/bibliography/bibliography.bib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/teuchos/cmake/tribits/python/GeneralScriptSupport.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/teuchos/cmake/tribits/python/TribitsDependencies.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/dylib_test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/dylib_test3.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/packages/nidr/dylib_test2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/pattern_search.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/direct1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/logo_3d_halfsize.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/logo_3d.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/ga.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/dakota-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/logo_halfsize.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/images/logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/SANDreport/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/SANDreport/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/algorithm2e.sty",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/compressed-sensing-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/basis-adaptation-algorithm-summary.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/isogrid_N2_q6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/PivotCholSelectEqnAlgorithm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/rosen_restart_mle_map.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/index-expansion.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/rosen_00_pce_hessian.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/rosen_pce_m11_50up_stdnormal_rejection.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/pce-tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/rosen_restart_reject.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/rosen_00_prior.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-theory/images/tau_updates.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/ObsErrorCovariance.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/sbo_3d_surface.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/textbook_history.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_nond_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/end_cap.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/branch_history.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/moat_mustar_sigma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/cdf_form.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_mogatest1_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/TensorQuad5_Gauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/SparseLevel4_LinGauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/short_col_cdf_ria.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/mss_rel_eff_3lev_determ.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/belief_plaus.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_2d_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_mogatest3_pareto_set.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/CalibrateOne.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/textbook_contours.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dak_graphics_ps_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/log_ratio_cdf_pma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/inputfile_block_layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/textbook_opt_hist.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/multi_d_pstudy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/CalibratePerExperiment.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_pce_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_ea_final.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/comm_partitioning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/CalibratePerResponse.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/container_graphic_options.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/classDakota_1_1Model.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/short_col_cdf_pma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/DAK5pt2_2D_shubert.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_sc_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dak_graphics_grad_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dak_graphics_vector.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/nonlin_paramest_hist.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/recursive_partitioning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/log_ratio_cdf_ria.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/SparseLevel4_NonlinGauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/sbo_df.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_vect_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/sbo_mh.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_components.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/CalibrateBoth.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_3d_surf.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_flowchart.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_ea_init.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/cdf_tran_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_mogatest2_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_ps_opt_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/sbouu.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/mss_rel_speedup_3lev_determ.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_2d_surf.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/nested_ouu.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/input_samples5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_ps_opt_pts2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/dakota_mogatest3_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/ex_in_hy_job_management.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/cantilever_beam.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/textbook_closeup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/rosen_grad_opt_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/horsetail.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/centered_pstudy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/lhs_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/input_samples10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/graphical_container_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/container_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/DAK5pt2_2D__herbie__smooth_herbie.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.3-d6x3c7itjavexkuneqy5gxbyensxov7w/spack-src/docs/latex-user/images/cdf_orig_graphic.png"
    ],
    "total_files": 8792
}