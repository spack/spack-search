{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/GridApplicInterface.hpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        GridApplicInterface\n//- Description:  Derived class for the case when analysis code simulators are\n//-               invoked using a Condor/Globus computational grid\n//- Owner:        Mike Eldred\n//- Version: $Id: GridApplicInterface.hpp 6492 2009-12-19 00:04:28Z briadam $\n\n#ifndef GRID_APPLIC_INTERFACE_H\n#define GRID_APPLIC_INTERFACE_H\n\n#include \"SysCallApplicationInterface.hpp\"\n\n\nnamespace Dakota {\n\nextern \"C\" {\n/// definition of start grid computing type (function pointer)\ntypedef int  (*start_grid_computing_t)(char *analysis_driver_script,\n\t\t\t\t       char *params_file, char *results_file);\n/// definition of perform analysis type (function pointer)\ntypedef int  (*perform_analysis_t)(char *iteration_num);\n/// definition of get completed jobs type (function pointer)\ntypedef int* (*get_jobs_completed_t)();\n/// definition of stop grid computing type (function pointer)\ntypedef int  (*stop_grid_computing_t)();\n}\n\n\n/// Derived application interface class which spawns simulation codes\n/// using grid services such as Condor or Globus.\n\n/** This class is currently a modified copy of SysCallApplicInterface\n    adapted for use with an external grid dervices library which was\n    dynamically linked using dlopen() services. */\n\nclass GridApplicInterface: public SysCallApplicInterface\n{\npublic:\n\n  //\n  //- Heading: Constructors and destructor\n  //\n\n  /// constructor\n  GridApplicInterface(const ProblemDescDB& problem_db);\n\n  /// destructor\n  ~GridApplicInterface();\n\n  //\n  //- Heading: Virtual function redefinitions\n  //\n\n  ///\n  void derived_map(const Variables& vars, const ActiveSet& set,\n\t\t   Response& response, int fn_eval_id);\n\n  ///\n  void derived_map_asynch(const ParamResponsePair& pair);\n\n  ///\n  void wait_local_evaluations(PRPQueue& prp_queue)\n\t{\n  \twhile (completionSet.empty())\n          test_local_evaluations(prp_queue);\n\t}\n\n  ///\n  void test_local_evaluations(PRPQueue& prp_queue);\n\n  /** This code provides the derived function used by\n   *  ApplicationInterface::serve_analyses_synch().\n   */\n  int synchronous_local_analysis(int analysis_id)\n\t{\n\t///\n\t/// TODO - allow local analyses?????\n\t///\n  \tspawn_analysis_to_shell(analysis_id, BLOCK);\n  \treturn 0; // used for failure codes in DirectFn case\n\t}\n\nprotected:\n\n  //\n  //- Heading: Methods\n  //\n\n  /// test file(s) for existence based on root_file name \n  bool grid_file_test(const String& root_file);\n\n  //\n  //- Heading: Data\n  //\n\n  /// Set of function evaluation id's for active asynchronous\n  /// system call evaluations\n  IntSet idSet;\n\n  /// map linking function evaluation id's to number of response read failures\n  IntShortMap failCountMap; \n\n  /// handle to dynamically linked start_grid_computing function\n  start_grid_computing_t start_grid_computing;\n  /// handle to dynamically linked perform_analysis grid function\n  perform_analysis_t     perform_analysis;\n  /// handle to dynamically linked get_jobs_completed grid function\n  get_jobs_completed_t   get_jobs_completed;\n  /// handle to dynamically linked stop_grid_computing function\n  stop_grid_computing_t  stop_grid_computing;\n};\n\n} // namespace Dakota\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/GridApplicInterface.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        GridApplicInterface\n//- Description:  Class implementation\n//- Owner:        Mike Eldred\n\n#ifdef DAKOTA_GRID\n\n#include <dlfcn.h>\n#include <link.h>\n#include <sys/types.h> // MAY REQUIRE ifndef(HPUX)\n#include <sys/stat.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h> // for usleep()\n#endif\n#include \"DakotaResponse.hpp\"\n#include \"ParamResponsePair.hpp\"\n#include \"GridApplicInterface.hpp\"\n#include \"dakota_system_defs.hpp\"\n#include \"ProblemDescDB.hpp\"\n\n//#define TESTING_GRID\n\n//extern \"C\" int start_grid_computing(char *analysis_driver_script,\n//                                    char *params_file, char *results_file);\n//extern \"C\" int perform_analysis(char *iteration_num);\n//extern \"C\" int *get_jobs_completed();\n//extern \"C\" int stop_grid_computing();\n/*\nThis api returns the pointer to a pre-allocated fixed interger array.\nThe first element contains the number of returned iteration nums ;\nthe following elements contain the iteration nums.\n    e.g.  3 1 3 5 \n          returns 3 iteration nums 1, 3, 5\n         \n          0\n          no iteration num returned\n*/\n\n\nnamespace Dakota {\n\n\nGridApplicInterface::\nGridApplicInterface(const ProblemDescDB& problem_db):\n  SysCallApplicInterface(problem_db)\n{ \n  void* handle = dlopen(\"foo.so\", RTLD_NOW);\n  if (!handle) {\n    Cerr << \"Problem loading shared object file: foo.so\" << std::endl;\n    abort_handler(-1);\n  }\n  start_grid_computing\n    = (start_grid_computing_t)(dlsym(handle, \"start_grid_computing\"));\n  const char* error;\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading start_grid_computing function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  stop_grid_computing\n    = (stop_grid_computing_t)dlsym(handle, \"stop_grid_computing\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading stop_grid_computing function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  perform_analysis = (perform_analysis_t)dlsym(handle, \"perform_analysis\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading perform_analysis function: \" << error << std::endl;\n    abort_handler(-1);\n  }\n  get_jobs_completed = (get_jobs_completed_t)dlsym(handle,\"get_jobs_completed\");\n  if ((error = dlerror()) != NULL) {\n    Cerr << \"Problem loading get_jobs_completed function: \" << error\n         << std::endl;\n    abort_handler(-1);\n  }\n  int status = (*start_grid_computing)(programNames[0].data(),\n\t\t\t\t       paramsFileName.data(), \n\t\t\t\t       resultsFileName.data());\n  //fileSaveFlag=true;\n}\n\n\nGridApplicInterface::~GridApplicInterface() \n{\n  int status = (*stop_grid_computing)();\n  // TODO - ERROR CHECKING\n}\n\n\nvoid GridApplicInterface::\nderived_map(const Variables& vars, const ActiveSet& set, Response& response,\n\t    int fn_eval_id)\n{\n  //\n  // Launch the grid solver (asynchronously)\n  //\n  ParamResponsePair prp(vars, interfaceId, response, fn_eval_id);\n  derived_map_asynch(prp);\n  //\n  // Call wait_local_evaluations() until our id is in the set\n  //\n  PRPQueue prp_queue;\n  prp_queue.push_back(prp);\n  if (!completionSet.empty()) {\n    Cerr << \"derived_map - should start with an empty completion set\\n\";\n    abort_handler(-1);\n  }\n  wait_local_evaluations(prp_queue); // rebuilds completionSet\n  response = prp_queue.front().response();\n  completionSet.clear();\n#if 0\n  //\n  // Read the params file and handle exceptions\n  //\n  try {\n    if (evalCommRank == 0)\n      read_results_files(response, fn_eval_id);\n  }\n  catch(const FileReadException& fr_except) {\n    // a FileReadException exception involves detection of an\n    // incomplete file/data set.  In the synchronous case, there is no\n    // potential for an incomplete file resulting from a race\n    // condition -> echo the error and abort.\n    Cerr << \"\\nError reading results file:\\n  \" << fr_except.what() << std::endl;\n    abort_handler(INTERFACE_ERROR);\n  }\n  catch(const FunctionEvalFailure& fneval_except) {\n    // The approach here is to have catch(FunctionEvalFailure) rethrow\n    // the exception to an outer catch (either the catch within\n    // manage_failure or a catch that calls manage_failure).\n    throw;\n  }\n#endif\n}\n\n\nvoid GridApplicInterface::derived_map_asynch(const ParamResponsePair& pair)\n{\n  //\n  // Write the params file\n  //\n  int fn_eval_id = pair.eval_id();\n  define_filenames(fn_eval_id);\n  write_parameters_files(pair.variables(), pair.active_set(),\n\t\t\t pair.response(),  fn_eval_id);\n  //\n  // Launch the grid solver\n  //\n  // TODO - ERROR CHECKING\n  //\n  String tmp;\n  tmp += fn_eval_id;\n  int status = (*perform_analysis)(tmp.data());\n  //\n  // Insert the evaluation ID into our current set\n  //\n  idSet.insert(fn_eval_id);\n}\n\n\n/// Convenience function for common code between wait and nowait case.\nvoid GridApplicInterface::test_local_evaluations(PRPQueue& prp_queue)\n{\n  //\n  // Iterate through the set of requests\n  //\n  for (ISIter it=idSet.begin(); it!=idSet.end(); it++) {\n    //\n    // Test for existence of the results file(s) corresponding to this eval\n    //\n    int fn_eval_id = *it;\n    bool err_msg_caught = false;\n    const String& file_to_test = fileNameMap[fn_eval_id].second;\n    if (grid_file_test(file_to_test)) {\n      //\n      // File exists; test for complete/valid set of results (an incomplete\n      // set can result from a race condition in which Dakota is reading a\n      // file that a simulator has not finished writing).  Response::read\n      // throws a FileReadException if data is missing/misformatted.\n      //\n      PRPQueueIter queue_it = lookup_by_eval_id(prp_queue, fn_eval_id);\n      if (queue_it == prp_queue.end()) {\n\tCerr << \"Error: failure in queue lookup within GridApplicInterface::\"\n\t     << \"test_local_evaluations().\" << std::endl;\n\tabort_handler(-1);\n      }\n      Response response = queue_it->response(); // shallow copy\n\n      try { read_results_files(response, fn_eval_id); }\n      catch(const FileReadException& fr_except) {\n\t//\n\t// If a FileReadException exception (incomplete file) is caught, set\n\t// err_msg_caught to true so that processing is not performed below.\n\t// The for loop will then cycle through the other active asynch. evals.\n\t// before coming back to the one with the exception.  This should allow\n\t// file writing by a simulator to complete.  100 failures are currently\n\t// allowed for any fn_eval_id before it is assumed that the error is\n\t// real (not race condition related) and aborting.\n\t//\n\terr_msg_caught = true;\n\tIntShMIter map_iter = failCountMap.find(fn_eval_id);\n\tif (map_iter != failCountMap.end()) {\n\t  if (++map_iter->second > 100) {\n\t    Cerr << \"Error: too many failed reads for results file \" \n\t\t << file_to_test\n\t\t << \"\\n       check data format and completeness;\\n       \" \n\t\t << fr_except.what() << std::endl;\n\t    abort_handler(-1);\n\t  }\n\t}\n\telse\n\t  failCountMap[fn_eval_id] = 1;\n#ifdef HAVE_UNISTD_H\n\t//\n\t// Sleep for 1 millisecond\n\t//\n\tusleep(1000);\n#endif // HAVE_UNISTD_H\n#ifdef ASYNCH_DEBUG\n\tCerr << \"Warning: exception caught in reading response file \"\n\t     << file_to_test << \"\\nException = \\\"\" << fr_except.what()\n\t     << \"\\\"\\nException recovery: returning \" << file_to_test\n\t     << \" to processing queue.\\n\";\n#endif\n      }\n      catch(const FunctionEvalFailure& fneval_except) {\n\t//\n\t// If a FunctionEvalFailure (\"fail\" detected in results file) is caught,\n\t// call manage_failure which will either (1) repair the failure and\n\t// populate response, or (2) abort the run.\n\t//\n\tmanage_failure(queue_it->variables(), response.active_set(),\n\t\t       response, fn_eval_id);\n      }\n      //\n      // Process successful results for this asynchronous eval.  Set\n      // the response within the PRPair, remove entry in failCountMap, and\n      // add evaluation id to completion set.\n      //\n      if (!err_msg_caught) {\n\t//queue_it->response(response);                    // not needed\n\t//replace_by_eval_id(prp_queue, fn_eval_id, *queue_it);// not needed\n\tcompletionSet.insert(fn_eval_id);\n\tfailCountMap.erase(fn_eval_id); // if present\n      }\n    }\n  }\n\n#ifdef HAVE_UNISTD_H\n  // reduce processor load from DAKOTA testing if jobs are not finishing\n  if (completionSet.empty()) // no jobs completed in pass through entire set\n    usleep(1000); // 1000 microseconds = 1 millisec\n#endif // HAVE_UNISTD_H\n  // Remove completed jobs from idSet\n  for (ISIter it = completionSet.begin(); it != completionSet.end(); it++)\n    idSet.erase(*it);\n}\n\n\nbool GridApplicInterface::grid_file_test(const String& root_file)\n{\n  // Unix stat utility returns 0 if successful in gathering file statistics,\n  // -1 if there's an error (e.g., the file does not exist).\n  struct stat buf; // see man pages for info available from buf (not used here)\n  size_t num_progs = programNames.length();\n  if ( num_progs > 1 && oFilterName().empty() ) {\n    char prog_num[16];\n\n#ifdef __SUNPRO_CC\n    // Sun Solaris has been observed to have problems with the final results\n    // file existing before previous results files exist (I/O threading?)\n    for (size_t i=0; i<num_progs; i++) {\n      std::sprintf(prog_num, \".%d\", i+1);\n      String tagged_file;\n      tagged_file = root_file + prog_num;\n      if ( stat((char*)tagged_file.data(), &buf) == -1 )\n        return false;\n    }\n    return true;\n#else\n    // Testing all files is usually overkill for sequential analyses.  It's only\n    // really necessary to check the last tagged_file: root_file.[num_progs]\n    std::sprintf(prog_num, \".%d\", num_progs);\n    String tagged_file;\n    tagged_file = root_file + prog_num;\n    return ( stat((char*)tagged_file.data(), &buf) == -1 ) ? false : true;\n#endif // __SUNPRO_CC\n  }\n  else\n    return ( stat((char*)root_file.data(), &buf) == -1 ) ? false : true;\n}\n\n\n#if defined(TESTING_GRID)\n/** sample function prototype for launching grid computing */\nextern \"C\" int start_grid_computing(char *analysis_driver_script, \n\t\t\t\t    char *params_file, char *results_file)\n{ return 0; }\n\n/** sample function prototype for terminating grid computing */\nextern \"C\" int stop_grid_computing()\n{ return 0; }\n\n/** sample function prototype for submitting a grid evaluation */\nextern \"C\" int perform_analysis(char *iteration_num)\n{ spawn_evaluation_to_shell(true); return 0; }\n#endif\n\n} // namespace Dakota\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/NIDRProblemDescDB.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n// Class:        NIDRProblemDescDB\n//- Description: Implementation code for the New IDR ProblemDescDB class.\n//-              It defines the keyword handlers that yacc calls to populate\n//-              the database based on the parsed input.\n//- Owner:       David M. Gay\n//- Checked by:\n//- Version: $Id$\n\n#include \"NIDRProblemDescDB.hpp\"\n#include \"ParallelLibrary.hpp\"\n#include \"WorkdirHelper.hpp\"     // for copy/link file op utilities\n#include \"dakota_data_util.hpp\"\n#include \"pecos_stat_util.hpp\"\n#include <functional>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <boost/algorithm/string.hpp>\n#ifdef HAVE_OPTPP\n#include \"globals.h\"\n#endif\n\n#ifdef DAKOTA_DL_SOLVER\n#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define dlopen(x,y) LoadLibrary(x)\n#else\n#include <dlfcn.h>\n#endif\n#endif /*DAKOTA_DL_SOLVER*/\n\n/// Set input to NIDR via string argument instead of input file\nextern \"C\" void nidr_set_input_string(const char *);\n\nextern \"C\" void nidr_lib_cleanup(void);\n\nnamespace Dakota {\nextern ProblemDescDB *Dak_pddb;\n\nextern \"C\" FILE *nidrin;\nextern \"C\" int nidr_parse(const char*, FILE*);\n\n/// maximum error length is roughly 100 lines at 80 char; using fixed\n/// error length instead of investing in converting to vsnprintf (C++11)\nconst size_t NIDR_MAX_ERROR_LEN = 8192;\n\nint NIDRProblemDescDB::nerr = 0;\nNIDRProblemDescDB* NIDRProblemDescDB::pDDBInstance(NULL);\n\n\nNIDRProblemDescDB::NIDRProblemDescDB(ParallelLibrary& parallel_lib):\n  ProblemDescDB(BaseConstructor(), parallel_lib)\n{}\n\n\nNIDRProblemDescDB::~NIDRProblemDescDB()\n{\n#ifndef NO_NIDR_DYNLIB\n  nidr_lib_cleanup(); // close any explicitly opened shared libraries\n#endif\n}\n\nvoid NIDRProblemDescDB::botch(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nError: \" << msg << \".\\n\";\n\n  abort_handler(PARSE_ERROR);\n}\n\nvoid NIDRProblemDescDB::squawk(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nError: \" << msg << \".\\n\";\n\n  ++nerr;\n}\n\nvoid NIDRProblemDescDB::warn(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  char msg[NIDR_MAX_ERROR_LEN];\n  std::vsprintf(msg, fmt, ap);\n  va_end(ap);\n  Cerr << \"\\nWarning: \" << msg << \".\\n\";\n}\n\n/** Parse the input file using the Input Deck Reader (IDR) parsing system.\n    IDR populates the IDRProblemDescDB object with the input file data. */\nvoid NIDRProblemDescDB::\nderived_parse_inputs(const ProgramOptions& prog_opts)\n{\n  // set the pDDBInstance\n  pDDBInstance = this;\n\n  const String& dakota_input_file = prog_opts.input_file();\n  const String& dakota_input_string = prog_opts.input_string();\n  const String& parser_options = prog_opts.parser_options();\n\n  // Open the dakota input file passed in and \"attach\" it to stdin\n  // (required by nidr_parse)\n  if(!dakota_input_string.empty()) {\n    Cout << \"Using provided Dakota input string\" << std::endl;\n    // BMA TODO: output the string contents if verbose\n    nidr_set_input_string(dakota_input_string.c_str());\n  } else if (!dakota_input_file.empty()) {\n      Cout << \"Using Dakota input file '\" << dakota_input_file << \"'\" << std::endl;\n      if( !(nidrin = std::fopen(dakota_input_file.c_str(), \"r\")) )\n        botch(\"cannot open \\\"%s\\\"\", dakota_input_file.c_str());\n  } else {\n    Cerr << \"\\nError: NIDR parser called with no input.\" << std::endl;\n    abort_handler(PARSE_ERROR);\n  }\n\n  // // nidr_parse parses the input file and invokes the keyword handlers\n  // // NIDR expects a null pointer if unused, not an empty string\n  // const char* ptr_parse_opts = NULL;\n  // if (!parser_options.empty())\n  //   ptr_parse_opts = parser_options.c_str();\n  FILE *dump_file = NULL;\n  if (nidr_parse(parser_options.c_str(), dump_file)) {\n    //Cerr << \"\\nErrors parsing input file.\" << std::endl;\n    abort_handler(PARSE_ERROR); // allows proper abort in parallel case\n  }\n  if (nerr)\n    abort_handler(PARSE_ERROR);\n  if (parallel_library().command_line_run()) {\n    const char *s;\n    // manage dynamic solver plugins specified in the input\n#ifdef DAKOTA_DL_SOLVER\n    std::list<DataMethod>::iterator\n      Dml  = dataMethodList.begin(),\n      Dmle = dataMethodList.end();\n    DataMethodRep *Dr;\n    const char *s0;\n    char *s1;\n    size_t L;\n\n    for(; Dml != Dmle; ++Dml) {\n      Dr = Dml->dataMethodRep;\n      if ((s0 = Dr->dlDetails) && *(s = s0) > ' ') {\n\twhile(*s > ' ')\n\t  ++s;\n\ts1 = 0;\n\tif (*s) {\n\t  L = s - s0;\n\t  s1 = new char[L+1];\n\t  memcpy(s1, s0, L);\n\t  s1[L] = 0;\n\t  s0 = s1;\n\t}\n\tif (!(Dr->dlLib = dlopen(s0, RTLD_NOW))) {\n#ifndef _WIN32\n\t  const char *se;\n\t  if ((se = dlerror()))\n\t    squawk(\"Cannot open dl_solver \\\"%s\\\":\\n\\t%s\", s0, se);\n\t  else\n#endif\n\t    squawk(\"Cannot open dl_solver \\\"%s\\\"\", s0);\n\t}\n\tif (s1)\n\t  delete[] s1;\n      }\n    }\n#endif\n  }\n}\n\n\nvoid NIDRProblemDescDB::derived_broadcast()\n{ \n  check_variables(&dataVariablesList); \n  check_responses(&dataResponsesList); \n}\n// check_variables() invokes check_variables_node(), either directly or after\n// some manip of interval/histogram/correlation data.  check_variables_node\n// does label processing (?) followed by additional processing in\n// make_variable_defaults() below, which calls BuildLabels().  Need to\n// understand the reason for this step.\n\n// Basic flow should be:\n// (1) db.parse_inputs(file), db.insert_node(), db.set(), or some combination\n//     only on rank 0.\n// (2) perform sanity checking (once) on sets of vector inputs across all kw's,\n//     but for only those vector inputs that have been provided (see 4).\n//     Note: if only sanity checking (no set up), then derived_broadcast() only\n//           as a pre-processor on rank 0.\n// (3) send (minimal) db buffer from rank 0 to all other ranks\n// (4) define (large-scale) vector defaults across all keywords for all ranks,\n//     retaining sanity from 2\n//\n// Q: is 2 really needed, or would it be OK to perform all checks in 4?\n//    Evolution: checks/defaults as part of parsing (original)\n//           --> checks after parsing/mixed input and defaults after DB\n//               send/receive (current)\n//           --> checks/defaults after DB send/receive (proposed new)\n\n\nvoid NIDRProblemDescDB::derived_post_process()\n{\n  // finish processing dataVariableList\n  make_variable_defaults(&dataVariablesList);\n  // finish processing dataResponsesList\n  make_response_defaults(&dataResponsesList);\n}\n\n\n#define Squawk NIDRProblemDescDB::squawk\n#define Warn NIDRProblemDescDB::warn\n\ntypedef unsigned long UL;\n\nstruct Iface_Info {\n  DataInterfaceRep *di;\n  DataInterface *di_handle;\n};\n\nstruct Iface_mp_Rlit {\n  String DataInterfaceRep::* sp;\n  RealVector DataInterfaceRep::* rv;\n  const char *lit;\n};\n\nstruct Iface_mp_ilit {\n  String DataInterfaceRep::* sp;\n  int DataInterfaceRep::* iv;\n  const char *lit;\n};\n\nstruct Iface_mp_lit {\n  String DataInterfaceRep::* sp;\n  const char *lit;\n};\n\nstruct Iface_mp_type {\n  short DataInterfaceRep::* sp;\n  short type;\n};\n\nstruct Iface_mp_utype {\n  unsigned short DataInterfaceRep::* sp;\n  unsigned short type;\n};\n\nstruct Meth_Info {\n  DataMethodRep *dme;\n  DataMethod *dme0;\n};\n\nstruct Method_mp_ilit2 {\n  String DataMethodRep::* sp;\n  int DataMethodRep::* ip;\n  const char *lit;\n};\n\nstruct Method_mp_ilit2z {\n  String DataMethodRep::* sp;\n  size_t DataMethodRep::* ip;\n  const char *lit;\n};\n\nstruct Method_mp_lit {\n  String DataMethodRep::* sp;\n  const char *lit;\n};\n\nstruct Method_mp_litc {\n  String DataMethodRep::* sp;\n  Real DataMethodRep::* rp;\n  const char *lit;\n};\n\nstruct Method_mp_litrv {\n  String DataMethodRep::* sp;\n  RealVector DataMethodRep::* rp;\n  const char *lit;\n};\n\nstruct Method_mp_slit2 {\n  String DataMethodRep::* sp;\n  String DataMethodRep::* sp2;\n  const char *lit;\n};\n\nstruct Method_mp_utype_lit {\n  unsigned short DataMethodRep::* ip;\n  String DataMethodRep::* sp;\n  unsigned short utype;\n};\n\nstruct Method_mp_ord {\n  short DataMethodRep::* sp;\n  int ord;\n};\n\nstruct Method_mp_type {\n  short DataMethodRep::* ip;\n  short type;\n};\n\nstruct Method_mp_utype {\n  unsigned short DataMethodRep::* ip;\n  unsigned short utype;\n};\n\nstruct Mod_Info {\n  DataModelRep *dmo;\n  DataModel *dmo0;\n};\n\nstruct Model_mp_lit {\n  String DataModelRep::* sp;\n  const char *lit;\n};\n\nstruct Model_mp_ord {\n  short DataModelRep::* sp;\n  int ord;\n};\n\nstruct Model_mp_type {\n  short DataModelRep::* sp;\n  short type;\n};\n\nstruct Model_mp_utype {\n  unsigned short DataModelRep::* sp;\n  unsigned short utype;\n};\n\nstruct Resp_Info {\n  DataResponsesRep *dr;\n  DataResponses *dr0;\n};\n\nstruct Resp_mp_lit {\n  String DataResponsesRep::* sp;\n  const char *lit;\n};\n\nstruct Resp_mp_utype {\n  unsigned short DataResponsesRep::* sp;\n  unsigned short utype;\n};\n\n//struct Env_mp_lit {\n//  String DataEnvironmentRep::* sp;\n//  const char *lit;\n//};\n\nstruct Env_mp_utype {\n  unsigned short DataEnvironmentRep::* sp;\n  unsigned short utype;\n};\n\nenum { // kinds of continuous aleatory uncertain variables\n  CAUVar_normal = 0,\n  CAUVar_lognormal = 1,\n  CAUVar_uniform = 2,\n  CAUVar_loguniform = 3,\n  CAUVar_triangular = 4,\n  CAUVar_exponential = 5,\n  CAUVar_beta = 6,\n  CAUVar_gamma = 7,\n  CAUVar_gumbel = 8,\n  CAUVar_frechet = 9,\n  CAUVar_weibull = 10,\n  CAUVar_histogram_bin = 11,\n  CAUVar_Nkinds = 12\t// number of kinds of cauv variables\n};\n\nenum { // kinds of discrete aleatory uncertain integer variables\n  DAUIVar_poisson = 0,\n  DAUIVar_binomial = 1,\n  DAUIVar_negative_binomial = 2,\n  DAUIVar_geometric = 3,\n  DAUIVar_hypergeometric = 4,\n  DAUIVar_histogram_point_int = 5,\n  DAUIVar_Nkinds = 6\t// number of kinds of dauiv variables\n};\n\nenum { // kinds of discrete aleatory uncertain string variables\n  DAUSVar_histogram_point_str = 0,\n  DAUSVar_Nkinds = 1\t// number of kinds of dausv variables\n};\n\nenum { // kinds of discrete aleatory uncertain real variables\n  DAURVar_histogram_point_real = 0,\n  DAURVar_Nkinds = 1\t// number of kinds of daurv variables\n};\n\nenum { // kinds of continuous epistemic uncertain variables\n  CEUVar_interval = 0,\n  CEUVar_Nkinds = 1\t// number of kinds of cauv variables\n};\n\nenum { // kinds of discrete epistemic uncertain integer variables\n  DEUIVar_interval = 0,\n  DEUIVar_set_int = 1,\n  DEUIVar_Nkinds = 2\t// number of kinds of deuiv variables\n};\n\nenum { // kinds of discrete epistemic uncertain string variables\n  DEUSVar_set_str = 0,\n  DEUSVar_Nkinds = 1\t// number of kinds of deusv variables\n};\n\nenum { // kinds of discrete epistemic uncertain real variables\n  DEURVar_set_real = 0,\n  DEURVar_Nkinds = 1\t// number of kinds of deurv variables\n};\n\nenum { // kinds of discrete set variables\n  DiscSetVar_design_set_int = 0,\n  DiscSetVar_design_set_str = 1,\n  DiscSetVar_design_set_real = 2,\n  DiscSetVar_state_set_int = 3,\n  DiscSetVar_state_set_str = 4,\n  DiscSetVar_state_set_real = 5,\n  DiscSetVar_Nkinds = 6\t// number of kinds of discrete set variables\n};\n\nstruct VarLabel {\n  size_t n;\n  const char **s;\n};\n\nstruct Var_Info {\n  DataVariablesRep *dv;\n  DataVariables    *dv_handle;\n  VarLabel  CAUv[ CAUVar_Nkinds],  CEUv[ CEUVar_Nkinds];\n  VarLabel DAUIv[DAUIVar_Nkinds], DAUSv[DAUSVar_Nkinds], DAURv[DAURVar_Nkinds];\n  VarLabel DEUIv[DEUIVar_Nkinds], DEUSv[DEUSVar_Nkinds], DEURv[DEURVar_Nkinds];\n  IntArray   *nddsi, *nddss, *nddsr, *nCI, *nDI, *nhbp,\n             *nhpip, *nhpsp, *nhprp, \n             *ndusi, *nduss, *ndusr,\n             *ndssi, *ndsss, *ndssr;\n             \n  RealVector *ddsr, *CIlb, *CIub, *CIp, *DIp, *DSIp, *DSSp, *DSRp, *dusr,\n             *hba, *hbo, *hbc, \n             *hpic, *hpsc, *hpra, *hprc,\n             *ucm, *dssr;\n  IntVector  *ddsi, *DIlb, *DIub, *hpia, *dusi, *dssi, *ddsia, *ddssa, *ddsra;\n  StringArray *ddss, *hpsa, *duss, *dsss;\n};\n\nstruct Var_check\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n};\n\n/// structure for verifying bounds and initial point for real-valued vars\nstruct Var_rcheck\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n  RealVector  DataVariablesRep::* L;   // when static, initialized to NULL\n  RealVector  DataVariablesRep::* U;   // when static, initialized to NULL\n  RealVector  DataVariablesRep::* V;   // when static, initialized to NULL\n  StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n};\n\n/// structure for verifying bounds and initial point for string-valued vars\n// struct Var_scheck\n// {\n//   const char *name;\n//   size_t DataVariablesRep::* n;\n//   void (*vgen)(DataVariablesRep*, size_t);\n//   StringArray DataVariablesRep::* L;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* U;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* V;   // when static, initialized to NULL\n//   StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n// };\n\n/// structure for verifying bounds and initial point for integer-valued vars\nstruct Var_icheck\n{\n  const char *name;\n  size_t DataVariablesRep::* n;\n  void (*vgen)(DataVariablesRep*, size_t);\n  IntVector   DataVariablesRep::* L;   // when static, initialized to NULL\n  IntVector   DataVariablesRep::* U;   // when static, initialized to NULL\n  IntVector   DataVariablesRep::* V;   // when static, initialized to NULL\n  StringArray DataVariablesRep::* Lbl; // when static, initialized to NULL\n};\n\nstruct Var_uinfo {\n  const char *lbl;\n  const char *vkind;\n  size_t DataVariablesRep::* n;\n  void(*vchk)(DataVariablesRep*, size_t, Var_Info*);\n};\n\nstruct Var_brv {\n  RealVector DataVariablesRep::* rv;\n  Real b;\n};\n\nstruct Var_biv {\n  IntVector DataVariablesRep::* iv;\n  int b;\n};\n\nstruct Var_mp_type {\n  short DataVariablesRep::* sp;\n  short type;\n};\n\nvoid NIDRProblemDescDB::\niface_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(Real DataInterfaceRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\niface_Rlit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  Iface_mp_Rlit *R = (Iface_mp_Rlit*)v;\n  Real *r;\n  RealVector *rv;\n  size_t i, n;\n\n  di->*R->sp = R->lit;\n  rv = &(di->*R->rv);\n  n = val->n;\n  rv->sizeUninitialized(n);\n  r = val->r;\n  for(i = 0; i < n; ++i)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\niface_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(bool DataInterfaceRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\niface_ilit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  Iface_mp_ilit *I = (Iface_mp_ilit*)v;\n\n  di->*I->sp = I->lit;\n  di->*I->iv = *val->i;\n}\n\nvoid NIDRProblemDescDB::\niface_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Iface_Info**)g)->di->**(int DataInterfaceRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\niface_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->*((Iface_mp_lit*)v)->sp = ((Iface_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\niface_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Iface_Info *ii;\n\n  if (!(ii = new Iface_Info))\n  Botch:\t\tbotch(\"new failure in iface_start\");\n  if (!(ii->di_handle = new DataInterface))\n    goto Botch;\n  ii->di = ii->di_handle->dataIfaceRep;\n  *g = (void*)ii;\n}\n\nvoid NIDRProblemDescDB::\niface_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(bool DataInterfaceRep::**)v = true;\n}\n\n\n#ifdef DEBUG_LEGACY_WORKDIR\n\nextern const char** arg_list_adjust(const char **, void **);\n\n/*\n *  not_executable(const char *driver_name) checks whether driver_name is an \n *  executable file appearing somewhere in $PATH and returns 0 if so,\n *  1 if not found, 2 if found but not executable.\n */\nint not_executable(const char *driver_name, const char *tdir)\n{\n  static const char *p0;\n  struct stat sb;\n  const char *p;\n  const char *p1;\n  char *b, buf[2048];\n  const char *a2[2], **al;\n  int rc, sv;\n  size_t clen, dlen, plen, tlen;\n  void *a0;\n  std::string cwd = boost::filesystem::current_path().string();\n\n#ifdef _WIN32\n  char dbuf[128];\n#else\n  static uid_t myuid;\n  static gid_t mygid;\n#endif\n\n  /* allow shell assignments and quotes around executable names */\n  /* that may involve blanks */\n  a2[0] = driver_name;\n  a2[1] = 0;\n  al = arg_list_adjust(a2,&a0);\n  driver_name = al[0];\n\n  rc = 0;\n  if (!p0) {\n    p0 = std::getenv(\"PATH\");\n#ifdef _WIN32\n    if (!p0)\n      p0 = std::getenv(\"Path\");\n#else\n    myuid = geteuid();\n    mygid = getegid();\n#endif\n    if (p0)\n      while(*p0 <= ' ' && *p0)\n\t++p0;\n    else\n      p0 = \"\";\n  }\n#ifdef _WIN32\n  // make sure we have a suitable suffix\n  if ((p = strrchr(driver_name, '.'))) {\n    if (std::strlen(++p) != 3)\n      p = 0;\n    else {\n      for(b = dbuf; *p; ++b, ++p)\n\t*b = tolower(*p);\n      *b = 0;\n      if (std::strcmp(dbuf, \"exe\") && std::strcmp(dbuf, \"bat\") &&\n\t  std::strcmp(dbuf, \"cmd\"))\n\tp = 0;\n    }\n  }\n  if (!p) {\n    dlen = std::strlen(driver_name);\n    if (dlen + 5 > sizeof(dbuf)) {\n      rc = 1;\n      goto ret;\n    }\n    std::strcpy(dbuf, driver_name);\n    std::strcpy(dbuf+dlen, \".exe\");\n    driver_name = dbuf;\n  }\n\n  // . is always implicitly in $Path under MS Windows; check it now\n  if (!stat(driver_name, &sb))\n    goto ret;\n#endif\n\n  cwd = boost::filesystem::current_path().string();\n  clen = cwd.size();\n  dlen = std::strlen(driver_name);\n  tlen = std::strlen(tdir);\n  rc = 1;\n  p = p0;\n  if (std::strchr(driver_name, '/')\n#ifdef _WIN32\n      || std::strchr(driver_name, '\\\\')\n      || (dlen > 2 && driver_name[1] == ':')\n#endif\n      )\n    p = \"\";\n\n  else if (clen + dlen + 2 < sizeof(buf)) {\n    std::memcpy(buf,cwd.c_str(),clen);\n    buf[clen] = '/';\n    std::strcpy(buf+clen+1, driver_name);\n    sv = stat(buf,&sb);\n    if (sv == 0)\n      goto stat_check;\n  }\n  else if (tdir && *tdir && tlen + dlen + 2 < sizeof(buf)) {\n    std::memcpy(buf,tdir,tlen);\n    buf[tlen] = '/';\n    std::strcpy(buf+tlen+1, driver_name);\n    sv = stat(buf,&sb);\n    if (sv == 0)\n      goto stat_check;\n  }\n  for(;;) {\n    for(p1 = p;; ++p1) {\n      switch(*p1) {\n      case 0:\n#ifdef _WIN32\n      case ';':\n#else\n      case ':':\n#endif\n\tgoto break2;\n      }\n    }\n  break2:\n    if (p1 == p || (p1 == p + 1 && *p == '.'))\n      sv = stat(driver_name, &sb);\n    else {\n      plen = p1 - p;\n      while(plen && p[plen-1] <= ' ')\n\t--plen;\n      if (plen + dlen + 2 > sizeof(buf))\n\tsv = 1;\n      else {\n\tstd::strncpy(buf,p,plen);\n\tb = buf + plen;\n\t*b++ = '/';\n\tstd::strcpy(b, driver_name);\n\tsv = stat(buf, &sb);\n      }\n    }\n    if (!sv) {\n    stat_check:\n#ifdef __CYGWIN__\n      rc = 2;\n      if (sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\trc = 0;\n\tgoto ret;\n      }\n#elif defined(_WIN32) || defined(_WIN64)\n      rc = 0;\n      goto ret;\n#else\n      rc = 2;\n      if (sb.st_uid == myuid) {\n\tif (sb.st_mode & S_IXUSR)\n\t  goto ret0;\n      }\n      else if (sb.st_gid == mygid) {\n\tif (sb.st_mode & S_IXGRP)\n\t  goto ret0;\n      }\n      else if (sb.st_mode & S_IXOTH) {\n      ret0:                          rc = 0;\n\tgoto ret;\n      }\n#endif\n    }\n    if (p1 == 0)\n      goto ret;\n    else if (!*p1)\n      break;\n    for(p = p1 + 1; *p <= ' '; ++p)\n      while(*p <= ' ' && *p)\n\tif (!*p)\n\t  goto ret;\n  }\n ret:\n  if (a0)\n    std::free(a0);\n  return rc;\n}\n\n#endif  // DEBUG_LEGACY_WORKDIR\n\n\nvoid NIDRProblemDescDB::\niface_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Iface_Info *ii = *(Iface_Info**)g;\n  DataInterfaceRep *di = ii->di;\n\n  StringArray& analysis_drivers = di->analysisDrivers;\n  int nd = analysis_drivers.size();\n  int ac = di->asynchLocalAnalysisConcurrency;\n  int ec = di->asynchLocalEvalConcurrency;\n\n  if (di->algebraicMappings == \"\" && nd == 0)\n    squawk(\"interface specification must provide algebraic_mappings,\\n\\t\"\n\t   \"analysis_drivers, or both\");\n  if (nd > 0 && di->asynchLocalAnalysisConcurrency > nd) {\n    warn(\"analysis_concurrency specification greater than length of\\n\\t\"\n\t \"analysis_drivers list.  Truncating analysis_concurrency to %d\",nd);\n    di->asynchLocalAnalysisConcurrency = nd;\n  }\n  if (ec && ec < 2 && ac && ac < 2) {\n    warn(\"asynchronous option not required for evaluation and analysis.\\n\\t\"\n\t \"Concurrency limited to %d and %d.\\n\\t\"\n\t \"Synchronous operations will be used\", ec, ac);\n    di->interfaceSynchronization = SYNCHRONOUS_INTERFACE;\n  }\n\n  // validate each of the analysis_drivers\n  if ( di->interfaceType == SYSTEM_INTERFACE || \n       di->interfaceType == FORK_INTERFACE )\n    for(size_t i = 0; i < nd; ++i) {\n      // trim any leading whitespace from the driver, in place\n      boost::trim(analysis_drivers[i]);\n      check_driver(analysis_drivers[i], di->linkFiles, di->copyFiles);\n    }\n\n  if (!di->workDir.empty()) {\n\n#if defined(_WIN32) || defined(_WIN64)\n    // Note: some Windows versions may support symlinks, if files and\n    // directories are managed separately.\n    if (!di->linkFiles.empty()) {\n      Cerr << \"\\nError: link_files not supported on Windows; use copy_files.\"\n\t   << std::endl;\n      ++nerr;\n    }\n#endif\n\n  // Check to make sure none of the linkFiles nor copyFiles are the\n  // same as the workDir (could combine into single loop with above)\n    if (WorkdirHelper::check_equivalent_dest(di->linkFiles, di->workDir) ||\n\tWorkdirHelper::check_equivalent_dest(di->copyFiles, di->workDir))\n      ++nerr;\n  }\n\n  pDDBInstance->dataInterfaceList.push_back(*ii->di_handle);\n  delete ii->di_handle;\n  delete ii;\n}\n\n/** returns 1 if not found, 2 if found, but not executable, 0 if found (no error) in case we want to return to error on not found... */\nint NIDRProblemDescDB::check_driver(const String& an_driver,\n\t\t\t\t    const StringArray& link_files,\n\t\t\t\t    const StringArray& copy_files)\n{\n  StringArray driver_and_args = WorkdirHelper::tokenize_driver(an_driver);\n  if (driver_and_args.size() == 0)\n    squawk(\"Empty analysis_driver string\");\n  else {\n\n    // the executable program name to check\n    const String& program_name = driver_and_args[0];\n\n    if (program_name.empty())\n      squawk(\"Empty analysis_driver string\");\n    else {\n\n      // Drivers can be found in $PATH:WORKDIR(.):RUNDIR\n      // Therefore have to check PATH, link/copy files, PWD\n\n      // check PATH and RUNDIR (since . is already on the search path)\n      bfs::path driver_found = WorkdirHelper::which(program_name);\n      if ( !driver_found.empty() )\n\treturn 0;\n\n      // check against link/copy files that will appear in workdir\n\n      // TODO: if they are specified with ./subdirA/subdir1/foo.sh\n      // would have been found above which might be an error if subdir\n      // is not linked or copied file\n\n      if (WorkdirHelper::find_driver(link_files, program_name))\n\treturn 0;\n\n      if (WorkdirHelper::find_driver(copy_files, program_name))\n\treturn 0;\n\n      const char* s = program_name.c_str();\n      warn(\"analysis driver \\\"%s\\\" %s\", s, \"not found\");\n\n      // BMA TODO: check whether the driver is executable and if not, return 2\n      // : \"exists but is not executable\");\n\n    }\n\n  }\n\n  return 1;\n}\n\nvoid NIDRProblemDescDB::\niface_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->**(String DataInterfaceRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\niface_str2D(const char *keyname, Values *val, void **g, void *v)\n{\n  DataInterfaceRep *di = (*(Iface_Info**)g)->di;\n  String2DArray *sa2 = &(di->**(String2DArray DataInterfaceRep::**)v);\n  StringArray *sa;\n  const char **s = val->s;\n  size_t i, j, k, n, nc, nd;\n\n  // This is for analysisComponents -- only String2DArray in a DataInterfaceRep\n\n  nd = di->analysisDrivers.size();\n  n = val->n;\n  if (nd <= 0)\n    botch(\"num_drivers = %d in iface_str2D\", (int)nd);\n  if (n % nd) {\n    squawk(\"number of analysis_components not evenly divisible \"\n\t   \"by number of analysis_drivers\");\n    return;\n  }\n  nc = n / nd;\n  sa2->resize(nd);\n  for(i = k = 0; i < nd; i++) {\n    sa = &((*sa2)[i]);\n    sa->resize(nc);\n    for(j = 0; j < nc; ++j, ++k)\n      (*sa)[j] = s[k];\n  }\n}\n\nvoid NIDRProblemDescDB::\niface_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(Iface_Info**)g)->di->**(StringArray DataInterfaceRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\niface_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Iface_Info**)g)->di->*((Iface_mp_type*)v)->sp = ((Iface_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Real01(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t < 0. || t > 1.)\n    botch(\"%s must be in [0, 1]\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  RealVector DataMethodRep::* sa = *(RealVector DataMethodRep::**)v;\n  Real *r = val->r;\n  size_t i, n = val->n;\n\n  (dm->*sa).sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (dm->*sa)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_RealLlit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r;\n  RealVector *rv = &(dm->*((Method_mp_litrv*)v)->rp);\n  size_t i, n;\n  dm->*((Method_mp_litrv*)v)->sp = ((Method_mp_litrv*)v)->lit;\n  r = val->r;\n  n = val->n;\n  rv->resize(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_Realp(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t <= 0.)\n    botch(\"%s must be positive\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_Realz(const char *keyname, Values *val, void **g, void *v)\n{\n  Real t = *val->r;\n  if (t < 0.)\n    botch(\"%s must be nonnegative\", keyname);\n  (*(Meth_Info**)g)->dme->**(Real DataMethodRep::**)v = t;\n}\n\n// MSE: This function just sets two values for one keyword.\nvoid NIDRProblemDescDB::\nmethod_piecewise(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->expansionType  = STD_UNIFORM_U;\n  dm->piecewiseBasis = true;\n}\n\nvoid NIDRProblemDescDB::\nmethod_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(bool DataMethodRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nmethod_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  int *z = val->i;\n  IntVector *iv = &(dm->**(IntVector DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  iv->resize(n);\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_ilit2(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->*((Method_mp_ilit2*)v)->sp = ((Method_mp_ilit2*)v)->lit;\n  dm->*((Method_mp_ilit2*)v)->ip = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ilit2p(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  dm->*((Method_mp_ilit2z*)v)->sp = ((Method_mp_ilit2z*)v)->lit;\n  if ((dm->*((Method_mp_ilit2z*)v)->ip = *val->i) <= 0)\n    botch(\"%s must be positive\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_lit*)v)->sp = ((Method_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litc(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  if (dm->*((Method_mp_litc*)v)->rp > 0.)\n    dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litp(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real t = *val->r;\n  if (t <= 0.)\n    botch(\"%s must be positive\",keyname);\n  dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n  dm->*((Method_mp_litc*)v)->rp = t;\n}\n\nvoid NIDRProblemDescDB::\nmethod_litz(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real t = *val->r;\n  if (t < 0.)\n    botch(\"%s must be nonnegative\",keyname);\n  if ((dm->*((Method_mp_litc*)v)->rp = t) == 0.)\n    dm->*((Method_mp_litc*)v)->sp = ((Method_mp_litc*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmethod_order(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_ord*)v)->sp = ((Method_mp_ord*)v)->ord;\n}\n\nvoid NIDRProblemDescDB::\nmethod_nnint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_sizet(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(size_t DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_num_resplevs(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  RealVector *ra = &(*rva)[0];\n  int m, *z = val->i;\n  size_t i, i1, j, je, k, n;\n\n  n = val->n;\n  for(i = k = 0; i < n; ++i)\n    k += z[i];\n  if (ra->length() != (int)k)\n    botch(\"number of %s = %u does not match\\n\"\n\t  \"%s specification of %u response levels\",\n\t  keyname+4, (Uint)ra->length(), keyname, (Uint)k);\n  r = new Real[k];\n  for(i = 0; i < k; i++)\n    r[i] = (*ra)[i];\n  (*rva).resize(n);\n  for(i = j = je = 0; i < n; i++) {\n    m = z[i];\n    (*rva)[i].resize(m);\n    ra = &(*rva)[i];\n    for(i1 = 0, je += m; j < je; ++i1, ++j)\n      (*ra)[i1] = r[j];\n  }\n  delete[] r;\n}\n\nvoid NIDRProblemDescDB::\nmethod_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(int DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_pintz(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Meth_Info**)g)->dme->**(size_t DataMethodRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmethod_resplevs(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r = val->r;\n  RealVector *ra;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  (*rva).resize(1);\n  ra = &(*rva)[0];\n  ra->resize(n);\n  for(i = 0; i < n; ++i)\n    (*ra)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_resplevs01(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n  Real *r = val->r, t;\n  RealVector *ra;\n  RealVectorArray *rva = &(dm->**(RealVectorArray DataMethodRep::**)v);\n  size_t i, n = val->n;\n\n  (*rva).resize(1);\n  ra = &(*rva)[0];\n  ra->resize(n);\n  for(i = 0; i < n; ++i) {\n    (*ra)[i] = t = r[i];\n    if (t < 0. || t > 1.)\n      botch(\"%s must be between 0 and 1\", keyname);\n  }\n}\n\nvoid NIDRProblemDescDB::\nmethod_shint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(short DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_ushint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(unsigned short DataMethodRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmethod_usharray(const char *keyname, Values *val, void **g, void *v)\n{\n  UShortArray *usa\n    = &((*(Meth_Info**)g)->dme->**(UShortArray DataMethodRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  usa->resize(n);\n  for (i=0; i<n; ++i)\n    if (z[i] >= 0)\n      (*usa)[i] = z[i];\n    else\n      botch(\"%s must have non-negative values\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_szarray(const char *keyname, Values *val, void **g, void *v)\n{\n  SizetArray *sza\n    = &((*(Meth_Info**)g)->dme->**(SizetArray DataMethodRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  sza->resize(n);\n  for (i=0; i<n; ++i)\n    if (z[i] >= 0)\n      (*sza)[i] = z[i];\n    else\n      botch(\"%s must have non-negative values\", keyname);\n}\n\nvoid NIDRProblemDescDB::\nmethod_slit2(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n\n  dm->*((Method_mp_slit2*)v)->sp  = ((Method_mp_slit2*)v)->lit;\n  dm->*((Method_mp_slit2*)v)->sp2 = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_utype_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep *dm = (*(Meth_Info**)g)->dme;\n\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    = ((Method_mp_utype*)v)->utype;\n  dm->*((Method_mp_utype_lit*)v)->sp = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Meth_Info *mi;\n\n  if (!(mi = new Meth_Info))\n  Botch:\t\tbotch(\"new failure in method_start\");\n  if (!(mi->dme0 = new DataMethod))\n    goto Botch;\n  mi->dme = mi->dme0->dataMethodRep;\n  *g = (void*)mi;\n}\n\nstatic void\nscale_chk(StringArray &ST, RealVector &S, const char *what, const char **univ)\n{\n  const char *s, **u;\n  size_t i, n, nbad, vseen;\n\n  n = ST.size();\n  for(i = nbad = vseen = 0; i < n; ++i) {\n    s = ST[i].data();\n    if (!strcmp(s,\"value\")) {\n      ++vseen;\n      goto break2;\n    }\n    for(u = univ; *u; ++u)\n      if (!strcmp(s,*u)) {\n\tgoto break2;\n      }\n    NIDRProblemDescDB::squawk(\"\\\"%s\\\" cannot appear in %s_scale_types\",\n\t\t\t      s, what);\n    ++nbad;\n  break2:\t;\n  }\n  if (vseen && S.length() <= 0)\n    NIDRProblemDescDB::squawk(\n      \"\\\"value\\\" in %s_scale_types requires at least one value for %s_scales\",\n      what, what);\n}\n\nstatic const char *aln_scaletypes[] = { \"auto\", \"log\", \"none\", 0 };\n\nvoid NIDRProblemDescDB::\nmethod_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Meth_Info *mi = *(Meth_Info**)g;\n  //DataMethodRep *dm = mi->dme;\n  // ... any checks ...\n  pDDBInstance->dataMethodList.push_back(*mi->dme0);\n  delete mi->dme0;\n  delete mi;\n}\n\nvoid NIDRProblemDescDB::\nmethod_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(String DataMethodRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmethod_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa = &((*(Meth_Info**)g)->dme->**(StringArray DataMethodRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->**(bool DataMethodRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nmethod_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_type*)v)->ip\n    = ((Method_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmethod_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    = ((Method_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmethod_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Meth_Info**)g)->dme->*((Method_mp_utype*)v)->ip\n    |= ((Method_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_Real(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(Real DataModelRep::**)v = *val->r;\n}\n\nvoid NIDRProblemDescDB::\nmodel_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  Real *r = val->r;\n  RealVector *rdv = &((*(Mod_Info**)g)->dmo->**(RealVector DataModelRep::**)v);\n  size_t i, n = val->n;\n\n  rdv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rdv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nmodel_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  DataModelRep *dm = (*(Mod_Info**)g)->dmo;\n  IntVector *iv = &(dm->**(IntVector DataModelRep::**)v);\n  size_t i, n = val->n;\n  iv->sizeUninitialized(n);\n\n  int *z = val->i;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nmodel_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(bool DataModelRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nmodel_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(int DataModelRep::**)v = *val->i;\n}\n\nvoid NIDRProblemDescDB::\nmodel_intsetm1(const char *keyname, Values *val, void **g, void *v)\n{\n  IntSet *is = &((*(Mod_Info**)g)->dmo->**(IntSet DataModelRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  for(i = 0; i < n; i++)\n    is->insert(z[i] - 1); // model converts ids -> indices\n}\n\nvoid NIDRProblemDescDB::\nmodel_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_lit*)v)->sp = ((Model_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nmodel_order(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_ord*)v)->sp = ((Model_mp_ord*)v)->ord;\n}\n\nvoid NIDRProblemDescDB::\nmodel_pint(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i;\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Mod_Info**)g)->dmo->**(int DataModelRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nmodel_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_type*)v)->sp = ((Model_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nmodel_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_utype*)v)->sp = \n    ((Model_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->*((Model_mp_utype*)v)->sp |= \n    ((Model_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nmodel_shint(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(short DataModelRep::**)v = (short)*val->i;\n}\n\nvoid NIDRProblemDescDB::\nmodel_start(const char *keyname, Values *val, void **g, void *v)\n{\n  DataModelRep *dm;\n  Mod_Info *mi;\n\n  if (!(mi = new Mod_Info))\n  Botch:\t\tbotch(\"new failure in model_start\");\n  if (!(mi->dmo0 = new DataModel))\n    goto Botch;\n  dm = mi->dmo = mi->dmo0->dataModelRep;\n  *g = (void*)mi;\n}\n\nvoid NIDRProblemDescDB::\nmodel_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  Mod_Info *mi = *(Mod_Info**)g;\n  pDDBInstance->dataModelList.push_back(*mi->dmo0);\n  delete mi->dmo0;\n  delete mi;\n}\n\nvoid NIDRProblemDescDB::\nmodel_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(String DataModelRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nmodel_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  DataModelRep *dm = (*(Mod_Info**)g)->dmo;\n  StringArray DataModelRep::* sa = *(StringArray DataModelRep::**)v;\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  (dm->*sa).resize(n);\n  for(i = 0; i < n; i++)\n    (dm->*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmodel_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Mod_Info**)g)->dmo->**(bool DataModelRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nresp_RealDL(const char *keyname, Values *val, void **g, void *v)\n{\n  Real *r = val->r;\n  RealVector *rv = &((*(Resp_Info**)g)->dr->**(RealVector DataResponsesRep::**)v);\n  size_t i, n = val->n;\n\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_RealL(const char *keyname, Values *val, void **g, void *v)\n{\n  NIDRProblemDescDB::resp_RealDL(keyname, val, g, v);\n}\n\nvoid NIDRProblemDescDB::\nresp_intset(const char *keyname, Values *val, void **g, void *v)\n{\n  IntSet *is = &((*(Resp_Info**)g)->dr->**(IntSet DataResponsesRep::**)v);\n  int *z = val->i;\n  size_t i, n = val->n;\n\n  for (i=0; i<n; ++i)\n    is->insert(z[i]);\n}\n\nvoid NIDRProblemDescDB::\nresp_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  DataResponsesRep *dr = (*(Resp_Info**)g)->dr;\n  IntVector *iv = &(dr->**(IntVector DataResponsesRep::**)v);\n  size_t i, n = val->n;\n  iv->sizeUninitialized(n);\n\n  int *z = val->i;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_lit(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_lit*)v)->sp = ((Resp_mp_lit*)v)->lit;\n}\n\nvoid NIDRProblemDescDB::\nresp_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_utype*)v)->sp\n    = ((Resp_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nresp_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->*((Resp_mp_utype*)v)->sp\n    |= ((Resp_mp_utype*)v)->utype;\n}\n\n\nvoid NIDRProblemDescDB::\nresp_sizet(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n < 0) /* now handled by INTEGER >= 0 in the .nspec file */\n    botch(\"%s must be non-negative\", keyname);\n#endif\n  (*(Resp_Info**)g)->dr->**(size_t DataResponsesRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nresp_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Resp_Info *ri;\n\n  if (!(ri = new Resp_Info))\n  Botch:\t\tbotch(\"new failure in resp_start\");\n  if (!(ri->dr0 = new DataResponses))\n    goto Botch;\n  ri->dr = ri->dr0->dataRespRep;\n  *g = (void*)ri;\n}\n\nstatic void\nBuildLabels(StringArray *sa, size_t nsa, size_t n1, size_t n2, const char *stub)\n{\n  char buf[64];\n  size_t i, n0;\n  if (nsa)\n    sa->resize(nsa);\n  i = n0 = n1;\n  while(n1 < n2) {\n    std::sprintf(buf, \"%s%lu\", stub, (UL)(++n1 - n0));\n    (*sa)[i++] = buf;\n  }\n}\n\nstatic int mixed_check(IntSet *S, int n, IntArray *iv, const char *what)\n{\n  int nbad, j;\n\n  nbad = 0;\n  for(ISCIter it = S->begin(), ite = S->end(); it != ite; ++it) {\n    j = *it;\n    if (j < 1 || j > n) {\n      if (!nbad++)\n\tSquawk(\"%s values must be between 1 and %d\", what, n);\n    }\n    else {\n      ++(iv->operator[](j-1));\n    }\n  }\n  return nbad;\n}\n\nstatic void\nmixed_check2(size_t n, IntArray *iv, const char *what)\n{\n  int j;\n  size_t i;\n\n  for(i = 0; i < n; ) {\n    j = (*iv)[i++];\n    if (j == 0)\n      Squawk(\"Function %lu missing from mixed %s lists\", (UL)i);\n    else if (j > 1)\n      Squawk(\"Function %lu replicated in mixed %s lists\", (UL)i);\n  }\n}\n\nvoid NIDRProblemDescDB::\nresp_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  size_t k, n;\n  static const char *osc[] = { \"log\", \"none\", 0 };\n  Resp_Info *ri = *(Resp_Info**)g;\n  DataResponsesRep *dr = ri->dr;\n  scale_chk(dr->primaryRespFnScaleTypes, dr->primaryRespFnScales,\n\t    dr->numLeastSqTerms ? \"least_squares_term\" : \"objective_function\", osc);\n  scale_chk(dr->nonlinearIneqScaleTypes, dr->nonlinearIneqScales,\n\t    \"nonlinear_inequality\", aln_scaletypes);\n  scale_chk(dr->nonlinearEqScaleTypes, dr->nonlinearEqScales,\n\t    \"nonlinear_equality\", aln_scaletypes);\n  if ( dr->primaryRespFnWeights.length() > 0 && dr->varianceType.size() > 0 ) {\n    squawk(\"Specify calibration weights or experimental errors, not both.\");\n  }\n  if ((n = dr->responseLabels.size()) > 0) {\n    if (!(k = dr->numResponseFunctions)) {\n      if (!(k = dr->numObjectiveFunctions))\n\tk = dr->numLeastSqTerms;\n      k += dr->numNonlinearIneqConstraints + dr->numNonlinearEqConstraints;\n    }\n    if (n != k)\n      squawk(\"Expected %ld response descriptors but found %ld\",\n\t     (long)k, (long) n);\n  }\n  pDDBInstance->dataResponsesList.push_back(*ri->dr0);\n  delete ri->dr0;\n  delete ri;\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_descriptors_for_repeats(const StringArray& labels) {\n  StringArray sorted(labels.size());\n  std::copy(labels.begin(), labels.end(), sorted.begin());\n  // error if descriptors are repeated\n  std::sort(sorted.begin(), sorted.end());\n  StringArray::iterator sorted_i = \n    std::adjacent_find(sorted.begin(), sorted.end());\n  if(sorted_i != sorted.end())\n    Squawk(\"Repeated descriptors (\\\"%s\\\") are not permitted\",sorted_i->c_str()); \n}\n\nvoid NIDRProblemDescDB::\ncheck_descriptors_for_repeats(const StringArray &cd_labels,\n                               const StringArray &ddr_labels,\n                               const StringArray &ddsi_labels,\n                               const StringArray &ddss_labels,\n                               const StringArray &ddsr_labels,\n                               const StringArray &cs_labels,\n                               const StringArray &dsr_labels,\n                               const StringArray &dssi_labels,\n                               const StringArray &dsss_labels,\n                               const StringArray &dssr_labels,\n                               const StringArray &cau_labels,\n                               const StringArray &diau_labels,\n                               const StringArray &dsau_labels,\n                               const StringArray &drau_labels,\n                               const StringArray &ceu_labels,\n                               const StringArray &dieu_labels,\n                               const StringArray &dseu_labels,\n                               const StringArray &dreu_labels) {\n  StringArray sorted;\n  std::copy(cd_labels.begin(),   cd_labels.end(),   std::back_inserter(sorted));\n  std::copy(ddr_labels.begin(),  ddr_labels.end(),  std::back_inserter(sorted));\n  std::copy(ddsi_labels.begin(), ddsi_labels.end(), std::back_inserter(sorted));\n  std::copy(ddss_labels.begin(), ddss_labels.end(), std::back_inserter(sorted));\n  std::copy(ddsr_labels.begin(), ddsr_labels.end(), std::back_inserter(sorted));\n  std::copy(cs_labels.begin(),   cs_labels.end(),   std::back_inserter(sorted));\n  std::copy(dsr_labels.begin(),  dsr_labels.end(),  std::back_inserter(sorted));\n  std::copy(dssi_labels.begin(), dssi_labels.end(), std::back_inserter(sorted));\n  std::copy(dsss_labels.begin(), dsss_labels.end(), std::back_inserter(sorted));\n  std::copy(dssr_labels.begin(), dssr_labels.end(), std::back_inserter(sorted));\n  std::copy(cau_labels.begin(),  cau_labels.end(),  std::back_inserter(sorted));\n  std::copy(diau_labels.begin(), diau_labels.end(), std::back_inserter(sorted));\n  std::copy(dsau_labels.begin(), dsau_labels.end(), std::back_inserter(sorted));\n  std::copy(drau_labels.begin(), drau_labels.end(), std::back_inserter(sorted));\n  std::copy(ceu_labels.begin(),  ceu_labels.end(),  std::back_inserter(sorted));\n  std::copy(dieu_labels.begin(), dieu_labels.end(), std::back_inserter(sorted));\n  std::copy(dseu_labels.begin(), dseu_labels.end(), std::back_inserter(sorted));\n  std::copy(dreu_labels.begin(), dreu_labels.end(), std::back_inserter(sorted));\n  std::sort(sorted.begin(), sorted.end());\n  StringArray::iterator sorted_i = \n    std::adjacent_find(sorted.begin(), sorted.end());\n  if(sorted_i != sorted.end())\n    Squawk(\"Repeated descriptors (\\\"%s\\\") are not permitted\",sorted_i->c_str()); \n}\n\n\nvoid NIDRProblemDescDB::\ncheck_responses(std::list<DataResponses>* drl)\n{\n  // TO DO: move Schk from below?\n\n  // validate descriptors. The string arrays are empty unless the user\n  // explicitly set descriptors.\n  std::list<DataResponses>::iterator It = drl->begin(), Ite = drl->end();\n  for(; It != Ite; ++It) {\n    const DataResponsesRep* drr = It->data_rep();\n    check_descriptor_format(drr->responseLabels);\n    check_descriptors_for_repeats(drr->responseLabels);\n  }\n}\n\nvoid NIDRProblemDescDB::\nmake_response_defaults(std::list<DataResponses>* drl)\n{\n  IntArray *iv;\n  StringArray *rl;\n  int ni;\n  size_t i, n, n1, nf, no, nrl;\n  struct RespStr_chk {\n    const char *what;\n    size_t DataResponsesRep::* n;\n    StringArray DataResponsesRep::* sa;\n  } *sc;\n  struct RespDVec_chk {\n    const char *what;\n    size_t DataResponsesRep::* n;\n    RealVector DataResponsesRep::* rv;\n  } *rdvc;\n#define Schk(a,b,c) {#a,&DataResponsesRep::b, &DataResponsesRep::c}\n  static RespStr_chk Str_chk[] = {  // for StringArray checking\n    Schk(least_squares_term_scale_types,numLeastSqTerms,primaryRespFnScaleTypes),\n    Schk(nonlinear_equality_scale_types,numNonlinearEqConstraints,nonlinearEqScaleTypes),\n    Schk(nonlinear_inequality_scale_types,numNonlinearIneqConstraints,nonlinearIneqScaleTypes),\n    Schk(objective_function_scale_types,numObjectiveFunctions,primaryRespFnScaleTypes)\n  };\n  static RespDVec_chk RespVec_chk_Bound[] = {// Bounds:  length must be right\n    Schk(least_squares_weights,numLeastSqTerms,primaryRespFnWeights),\n    Schk(multi_objective_weights,numObjectiveFunctions,primaryRespFnWeights),\n    Schk(nonlinear_equality_targets,numNonlinearEqConstraints,nonlinearEqTargets),\n    Schk(nonlinear_inequality_lower_bounds,numNonlinearIneqConstraints,nonlinearIneqLowerBnds),\n    Schk(nonlinear_inequality_upper_bounds,numNonlinearIneqConstraints,nonlinearIneqUpperBnds)\n  };\n  static RespDVec_chk RespVec_chk_Scale[] = {// Scales:  length must be right\n    Schk(least_squares_term_scales,numLeastSqTerms,primaryRespFnScales),\n    Schk(nonlinear_equality_scales,numNonlinearEqConstraints,nonlinearEqScales),\n    Schk(nonlinear_inequality_scales,numNonlinearIneqConstraints,nonlinearIneqScales),\n    Schk(objective_function_scales,numObjectiveFunctions,primaryRespFnScales)\n  };\n#undef Schk\n#define Numberof(x) sizeof(x)/sizeof(x[0])\n\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n  std::list<DataResponses>::iterator It = drl->begin(), Ite = drl->end();\n  for(; It != Ite; It++) {\n\n    DataResponsesRep *dr = It->dataRespRep;\n\n    for(sc = Str_chk, i = 0; i < Numberof(Str_chk); ++sc, ++i)\n      if ((n1 = dr->*sc->n) && (n = (dr->*sc->sa).size()) > 0\n\t  && n != n1 && n != 1)\n\tsquawk(\"%s must have length 1 or %lu, not %lu\",\n\t       sc->what, (UL)n1, (UL)n);\n    rl = &dr->responseLabels;\n    nrl = rl->size();\n    no = dr->numObjectiveFunctions;\n    if ((n = dr->numLeastSqTerms)) {\n      nf = n + dr->numNonlinearEqConstraints + dr->numNonlinearIneqConstraints;\n      if (!nrl) {\n\tBuildLabels(rl, nf, 0, n, \"least_sq_term_\");\n\tn1 = n + dr->numNonlinearIneqConstraints;\n\tBuildLabels(rl, 0, n, n1, \"nln_ineq_con_\");\n\tBuildLabels(rl, 0, n1, nf, \"nln_eq_con_\");\n      }\n    }\n    else if ((nf = no + dr->numNonlinearEqConstraints + dr->numNonlinearIneqConstraints)) {\n      if (!nrl) {\n\trl->resize(nf);\n\tif (no == 1)\n\t  (*rl)[0] = \"obj_fn\";\n\telse\n\t  BuildLabels(rl, 0, 0, no, \"obj_fn_\");\n\tn1 = no + dr->numNonlinearIneqConstraints;\n\tBuildLabels(rl, 0, no, n1, \"nln_ineq_con_\");\n\tBuildLabels(rl, 0, n1, nf, \"nln_eq_con_\");\n      }\n    }\n    else if ((nf = dr->numResponseFunctions)) {\n      if (!nrl)\n\tBuildLabels(rl, nf, 0, nf, \"response_fn_\");\n    }\n    for(rdvc = RespVec_chk_Bound, i = 0; i < Numberof(RespVec_chk_Bound); ++rdvc, ++i)\n      if ((n1 = dr->*rdvc->n) && (n = (dr->*rdvc->rv).length()) && n != n1)\n\tsquawk(\"%s needs %lu elements, not %lu\",\n\t       rdvc->what, (UL)(dr->*rdvc->n), (UL)n);\n    for(rdvc = RespVec_chk_Scale, i = 0; i < Numberof(RespVec_chk_Scale); ++rdvc, ++i)\n      if ((n1 = dr->*rdvc->n) && (n = (dr->*rdvc->rv).length())\n\t  && n != n1 && n != 1)\n\tsquawk(\"%s needs %lu elements (or just one), not %lu\",\n\t       rdvc->what, (UL)n1, (UL)n);\n    if (dr->methodSource == \"vendor\" && dr->fdGradStepSize.length() > 1)\n      squawk(\"vendor numerical gradients only support a single fd_gradient_step_size\");\n\n    ni = (int)nf;\n    if (dr->gradientType == \"mixed\") {\n      iv = new IntArray;\n      //iv->resize(nf);\n      iv->assign(nf, 0);\n      if (!(mixed_check(&dr->idAnalyticGrads, ni, iv, \"id_analytic_gradients\")\n\t    + mixed_check(&dr->idNumericalGrads, ni, iv, \"id_numerical_gradients\")))\n\tmixed_check2(nf, iv, \"gradient\");\n      delete iv;\n    }\n    if ((n = dr->numNonlinearEqConstraints) > 0\n\t&& dr->nonlinearEqTargets.length() == 0) {\n      dr->nonlinearEqTargets.sizeUninitialized(n);\n      dr->nonlinearEqTargets = 0.;\n    }\n    if ((n = dr->numNonlinearIneqConstraints) > 0) {\n      if (dr->nonlinearIneqLowerBnds.length() == 0) {\n\tdr->nonlinearIneqLowerBnds.sizeUninitialized(n);\n\tdr->nonlinearIneqLowerBnds = -dbl_inf;\n      }\n      if (dr->nonlinearIneqUpperBnds.length() == 0) {\n\tdr->nonlinearIneqUpperBnds.sizeUninitialized(n);\n\tdr->nonlinearIneqUpperBnds = 0.;\n\t// default is a one-sided inequality <= 0.0\n      }\n    }\n    if (dr->hessianType == \"mixed\") {\n      iv = new IntArray;\n      //iv->resize(nf);\n      iv->assign(nf, 0);\n      if (!(mixed_check(&dr->idAnalyticHessians, ni, iv, \"id_analytic_hessians\")\n\t    + mixed_check(&dr->idNumericalHessians, ni, iv, \"id_numerical_hessians\")\n\t    + mixed_check(&dr->idQuasiHessians, ni, iv, \"id_quasi_hessians\")))\n\tmixed_check2(nf, iv, \"Hessian\");\n      delete iv;\n    }\n    if (nerr)\n      abort_handler(PARSE_ERROR);\n  }\n}\n\nvoid NIDRProblemDescDB::\nresp_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(String DataResponsesRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nresp_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(Resp_Info**)g)->dr->**(StringArray DataResponsesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nresp_false(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(bool DataResponsesRep::**)v = false;\n}\n\nvoid NIDRProblemDescDB::\nresp_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Resp_Info**)g)->dr->**(bool DataResponsesRep::**)v = true;\n}\n\n// void NIDRProblemDescDB::\n// env_Real(const char *keyname, Values *val, void **g, void *v)\n// {\n//   (*(DataEnvironmentRep**)g)->**(Real DataEnvironmentRep::**)v = *val->r;\n// }\n\n// void NIDRProblemDescDB::\n// env_RealL(const char *keyname, Values *val, void **g, void *v)\n// {\n//   Real *r = val->r;\n//   RealVector *rdv\n//     = &((*(DataEnvironmentRep**)g)->**(RealVector DataEnvironmentRep::**)v);\n//   size_t i, n = val->n;\n\n//   rdv->sizeUninitialized(n);\n//   for(i = 0; i < n; i++)\n//     (*rdv)[i] = r[i];\n// }\n\nvoid NIDRProblemDescDB::\nenv_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(bool DataEnvironmentRep::**)v = true;\n}\n\nvoid NIDRProblemDescDB::\nenv_int(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(int DataEnvironmentRep::**)v = *val->i;\n}\n\n// void NIDRProblemDescDB::\n// env_lit(const char *keyname, Values *val, void **g, void *v)\n// {\n//   (*(DataEnvironmentRep**)g)->*((Environment_mp_lit*)v)->sp\n//     = ((Environment_mp_lit*)v)->lit;\n// }\n\nvoid NIDRProblemDescDB::\nenv_start(const char *keyname, Values *val, void **g, void *v)\n{\n  *g = (void*)pDDBInstance->environmentSpec.dataEnvRep;\n}\n\nvoid NIDRProblemDescDB::\nenv_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->**(String DataEnvironmentRep::**)v = *val->s;\n}\n\n/// set a value for an unsigned short type\nvoid NIDRProblemDescDB::\nenv_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->*((Env_mp_utype*)v)->sp = \n    ((Env_mp_utype*)v)->utype;\n}\n\n/// augment an unsigned short type with |=\nvoid NIDRProblemDescDB::\nenv_augment_utype(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(DataEnvironmentRep**)g)->*((Env_mp_utype*)v)->sp |= \n    ((Env_mp_utype*)v)->utype;\n}\n\nvoid NIDRProblemDescDB::\nenv_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa\n    = &((*(DataEnvironmentRep**)g)->**(StringArray DataEnvironmentRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nvoid NIDRProblemDescDB::\nmethod_tr_final(const char *keyname, Values *val, void **g, void *v)\n{\n  DataMethodRep &data_method = *(*(Meth_Info**)g)->dme;\n\n  // sanity checks on trust region user-defined values\n  size_t i, num_init = data_method.trustRegionInitSize.length();\n  Real min_init_size = 1.;\n  for (i=0; i<num_init; ++i) {\n    Real init_size_i = data_method.trustRegionInitSize[i];\n    if ( init_size_i <= 0. || init_size_i > 1. )\n      botch(\"specified initial TR size must be in (0,1]\");\n    if (init_size_i < min_init_size)\n      min_init_size = init_size_i;\n  }\n  if ( data_method.trustRegionMinSize > min_init_size ) {\n    if (num_init) botch(\"specified initial TR size less than minimum TR size\");\n    else          botch(\"minimum TR size must be <= 1.\");\n  }\n  // allow 0 for min size spec (conv control becomes inactive)\n  if ( data_method.trustRegionMinSize < 0. ||\n       data_method.trustRegionMinSize > 1. )\n    botch(\"specified minimum TR size must be in [0,1]\");\n  if( data_method.trustRegionContractTrigger <= 0. ||\n      data_method.trustRegionContractTrigger >\n      data_method.trustRegionExpandTrigger         ||\n      data_method.trustRegionExpandTrigger   >  1. )\n    botch(\"expand/contract threshold values must satisfy\\n\\t\"\n\t  \"0 < contract_threshold <= expand_threshold <= 1\");\n  if ( data_method.trustRegionContract <= 0. ||\n       data_method.trustRegionContract >  1. )\n    botch(\"contraction_factor must be in (0,1]\");\n  else if ( data_method.trustRegionContract == 1. )\n    warn(\"contraction_factor = 1.0 is valid, but should be < 1\\n\\t\"\n\t \"to assure convergence of the surrogate_based_opt method\");\n  if ( data_method.trustRegionExpand < 1. )\n    botch(\"expansion_factor must be >= 1\");\n}\n\n\nvoid NIDRProblemDescDB::\nvar_RealLb(const char *keyname, Values *val, void **g, void *v)\n{\n  Real b, *r;\n  RealVector *rv;\n  Var_brv *V;\n  size_t i, n;\n\n  V = (Var_brv*)v;\n  rv = &((*(Var_Info**)g)->dv->*V->rv);\n  b = V->b;\n  r = val->r;\n  n = val->n;\n  for(i = 0; i < n; i++)\n    if (r[i] <= b) {\n      squawk(\"%s values must be > %g\", keyname, b);\n      break;\n    }\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_RealUb(const char *keyname, Values *val, void **g, void *v)\n{\n  Real b, *r;\n  RealVector *rv;\n  Var_brv *V;\n  size_t i, n;\n\n  V = (Var_brv*)v;\n  rv = &((*(Var_Info**)g)->dv->*V->rv);\n  b = V->b;\n  r = val->r;\n  n = val->n;\n  for(i = 0; i < n; i++)\n    if (r[i] >= b) {\n      squawk(\"%s values must be < %g\", keyname, b);\n      break;\n    }\n  rv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_IntLb(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_biv *V = (Var_biv*)v;\n  IntVector *iv = &((*(Var_Info**)g)->dv->*V->iv);\n  int b = V->b;\n  int *z = val->i;\n  size_t i, n = val->n;\n  for(i = 0; i < n; i++)\n    if (z[i] <= b) {\n      squawk(\"%s values must be > %g\", keyname, b);\n      break;\n    }\n  iv->sizeUninitialized(n);\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\n\n/// Map an NIDR STRINGLIST to a BoolDeque based on string values; for\n/// now we require user to specify all N values\nvoid NIDRProblemDescDB::\nvar_categorical(const char *keyname, Values *val, void **g, void *v)\n{\n  BitArray *ba\n    = &((*(Var_Info**)g)->dv->**(BitArray DataVariablesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  // allow strings beginning y Y or T t (yes/true)\n  ba->resize(n);\n  for(i = 0; i < n; i++) {\n    String str_lower(strtolower(s[i]));\n    (*ba)[i] = strbegins(str_lower, \"y\") || strbegins(str_lower, \"t\");\n  }\n}\n\n\nvoid NIDRProblemDescDB::\nvar_newrvec(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  RealVector *rv;\n  size_t i, n = val->n;\n  Real *r = val->r;\n\n  if (!(rv = new RealVector(n, false)))\n    botch(\"new failure in var_newrvec\");\n  vi->**(RealVector *Var_Info::**)v = rv;\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newivec(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  IntVector *iv;\n  size_t i, n = val->n;\n  int *z = val->i;\n\n  if (!(iv = new IntVector(n, false)))\n    botch(\"new failure in var_newivec\");\n  vi->**(IntVector *Var_Info::**)v = iv;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newiarray(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  IntArray *iv;\n  size_t i, n = val->n;\n  int *z = val->i;\n\n  if (!(iv = new IntArray(n)))\n    botch(\"new failure in var_intarray\");\n  vi->**(IntArray *Var_Info::**)v = iv;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_newsarray(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi = *(Var_Info**)g;\n  StringArray *sa;\n  size_t i, n = val->n;\n  const char **z = val->s;\n\n  if (!(sa = new StringArray(n)))\n    botch(\"new failure in var_newsarray\");\n  vi->**(StringArray *Var_Info::**)v = sa;\n  for(i = 0; i < n; i++)\n    (*sa)[i] = z[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_rvec(const char *keyname, Values *val, void **g, void *v)\n{\n  RealVector *rv\n    = &((*(Var_Info**)g)->dv->**(RealVector DataVariablesRep::**)v);\n  size_t i, n = val->n;\n  rv->sizeUninitialized(n);\n\n  Real *r = val->r;\n  for(i = 0; i < n; i++)\n    (*rv)[i] = r[i];\n}\n\nvoid NIDRProblemDescDB::\nvar_ivec(const char *keyname, Values *val, void **g, void *v)\n{\n  IntVector *iv = &((*(Var_Info**)g)->dv->**(IntVector DataVariablesRep::**)v);\n  size_t i, n = val->n;\n  iv->sizeUninitialized(n);\n\n  int *z = val->i;\n  for(i = 0; i < n; i++)\n    (*iv)[i] = z[i];\n}\n\n// BMA TODO: I believe this duplicative of var_strL.\n// void NIDRProblemDescDB::\n// var_svec(const char *keyname, Values *val, void **g, void *v)\n// {\n//   StringArray *sa = &((*(Var_Info**)g)->dv->**(StringArray DataVariablesRep::**)v);\n//   size_t i, n = val->n;\n//   sa->resize(n);\n\n//   const char **z = val->s;\n//   for(i = 0; i < n; i++)\n//     (*sa)[i] = z[i];\n// }\n\nvoid NIDRProblemDescDB::\nvar_pintz(const char *keyname, Values *val, void **g, void *v)\n{\n  int n = *val->i; // test value as int, prior to storage as size_t\n#ifdef REDUNDANT_INT_CHECKS\n  if (n <= 0) /* now handled by INTEGER > 0 in the .nspec file */\n    botch(\"%s must be positive\", keyname);\n#endif\n  (*(Var_Info**)g)->dv->**(size_t DataVariablesRep::**)v = n;\n}\n\nvoid NIDRProblemDescDB::\nvar_type(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->*((Var_mp_type*)v)->sp = ((Var_mp_type*)v)->type;\n}\n\nvoid NIDRProblemDescDB::\nvar_start(const char *keyname, Values *val, void **g, void *v)\n{\n  Var_Info *vi;\n\n  if (!(vi = new Var_Info))\n  Botch:\t\tbotch(\"new failure in var_start\");\n  memset(vi, 0, sizeof(Var_Info));\n  if (!(vi->dv_handle = new DataVariables))\n    goto Botch;\n  vi->dv = vi->dv_handle->dataVarsRep;\n  *g = (void*)vi;\n}\n\nvoid NIDRProblemDescDB::\nvar_true(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->**(bool DataVariablesRep::**)v = true;\n}\n\nstatic int wronglen(size_t n, RealVector *V, const char *what)\n{\n  size_t n1 = V->length();\n  if (n != n1) {\n    Squawk(\"Expected %d numbers for %s, but got %d\", (int)n, what, (int)n1);\n    return 1;\n  }\n  return 0;\n}\n\nstatic int wronglen(size_t n, IntVector *V, const char *what)\n{\n  size_t n1 = V->length();\n  if (n != n1) {\n    Squawk(\"Expected %d numbers for %s, but got %d\", (int)n, what, (int)n1);\n    return 1;\n  }\n  return 0;\n}\n\nstatic void Vcopyup(RealVector *V, RealVector *M, size_t i, size_t n)\n{\n  size_t j;\n  for(j = 0; j < n; ++i, ++j)\n    (*V)[i] = (*M)[j];\n}\n\nstatic void Set_rv(RealVector *V, double d, size_t n)\n{\n  size_t i;\n  V->sizeUninitialized(n);\n  for(i = 0; i < n; ++i)\n    (*V)[i] = d;\n}\n\nstatic void Set_iv(IntVector *V, int d, size_t n)\n{\n  size_t i;\n  V->sizeUninitialized(n);\n  for(i = 0; i < n; ++i)\n    (*V)[i] = d;\n}\n\nstatic void\nwrong_number(const char *what, const char *kind, size_t nsv, size_t m)\n{\n  Squawk(\"Expected %d %s for %s, not %d\", (int)nsv, what, kind, (int)m);\n}\n\nstatic void too_small(const char *kind)\n{\n  Squawk(\"num_set_values values for %s must be >= 1\", kind);\n}\n\nstatic void not_div(const char *kind, size_t nsv, size_t m)\n{\n  Squawk(\"Number of %s set_values (%d) not evenly divisible by number of variables (%d); use num_set_values for unequal apportionment\",\n\t kind, (int)nsv, (int)m);\n}\n\nstatic void suppressed(const char *kind, int ndup, int *ip, String *sp, Real *rp)\n{\n  const char *s;\n  int i, nother;\n\n  nother = 0;\n  if (ndup > 2) {\n    nother = ndup - 1;\n    ndup = 1;\n  }\n  for(i = 0; i < ndup; ++i)\n    if (ip)\n      Squawk(\"Duplicate %s value %d\", kind, ip[i]);\n    else if (sp)\n      Squawk(\"Duplicate %s value %s\", kind, sp[i].c_str());\n    else\n      Squawk(\"Duplicate %s value %.17g\", kind, rp[i]);\n  if (nother) {\n    s = \"s\" + (nother == 1);\n    Squawk(\"Warning%s of %d other duplicate %s value%s suppressed\",\n\t   s, nother, kind, s);\n  }\n}\n\nstatic void bad_initial_ivalue(const char *kind, int val)\n{\n  Squawk(\"invalid initial value %d for %s\", val, kind);\n}\n\nstatic void bad_initial_svalue(const char *kind, String val)\n{\n  Squawk(\"invalid initial value %s for %s\", val.c_str(), kind);\n}\n\nstatic void bad_initial_rvalue(const char *kind, Real val)\n{\n  Squawk(\"invalid initial value %.17g for %s\", val, kind);\n}\n\n// *****************************************************************************\n//  Vchk functions called earlier from within check_variables_node(), which\n//   immediately {precedes,follows} DB buffer {send,receive} in broadcast().\n// Vgen functions called later from within make_variable_defaults()\n//   (from within post_process() following broadcast()).\n// As documented in ProblemDescDB::manage_inputs(), Vchk applies to minimal\n//   spec data, whereas Vgen constructs any large inferred vectors.\n// *****************************************************************************\nstatic void Vgen_ContinuousDes(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V;\n  size_t i, n = dv->numContinuousDesVars;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  L = &dv->continuousDesignLowerBnds;\n  U = &dv->continuousDesignUpperBnds;\n  V = &dv->continuousDesignVars;\n  if (L->length() == 0)\n    Set_rv(L, -dbl_inf, n);\n  if (U->length() == 0)\n    Set_rv(U, dbl_inf, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; i++) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0.) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0.) (*V)[i] = (*U)[i];\n      else                   (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_DiscreteDesRange(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V;\n  size_t i, n = dv->numDiscreteDesRangeVars;\n\n  L = &dv->discreteDesignRangeLowerBnds;\n  U = &dv->discreteDesignRangeUpperBnds;\n  V = &dv->discreteDesignRangeVars;\n  if (L->length() == 0)\n    Set_iv(L, INT_MIN, n);\n  if (U->length() == 0)\n    Set_iv(U, INT_MAX, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; ++i) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0) (*V)[i] = (*U)[i];\n      else                  (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_ContinuousState(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V;\n  size_t i, n = dv->numContinuousStateVars;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  L = &dv->continuousStateLowerBnds;\n  U = &dv->continuousStateUpperBnds;\n  V = &dv->continuousStateVars;\n  if (L->length() == 0)\n    Set_rv(L, -dbl_inf, n);\n  if (U->length() == 0)\n    Set_rv(U, dbl_inf, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; i++) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0.) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0.) (*V)[i] = (*U)[i];\n      else                   (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vgen_DiscreteStateRange(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V;\n  size_t i, n = dv->numDiscreteStateRangeVars;\n\n  L = &dv->discreteStateRangeLowerBnds;\n  U = &dv->discreteStateRangeUpperBnds;\n  V = &dv->discreteStateRangeVars;\n  if (L->length() == 0)\n    Set_iv(L, INT_MIN, n);\n  if (U->length() == 0)\n    Set_iv(U, INT_MAX, n);\n  if (V->length() == 0) {\n    V->sizeUninitialized(n);\n    for(i = 0; i < n; ++i) { // init to 0, repairing to bounds if needed\n      if      ((*L)[i] > 0) (*V)[i] = (*L)[i];\n      else if ((*U)[i] < 0) (*V)[i] = (*U)[i];\n      else                  (*V)[i] = 0;\n    }\n  }\n}\n\nstatic void Vchk_NormalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *B, *M, *Sd;\n\n  n = dv->numNormalUncVars;\n  if (wronglen(n,  M = &dv->normalUncMeans,   \"nuv_means\") ||\n      wronglen(n, Sd = &dv->normalUncStdDevs, \"nuv_std_deviations\"))\n    return;\n  B = &dv->normalUncLowerBnds;\n  if (B->length() && wronglen(n, B, \"nuv_lower_bounds\"))\n    return;\n  B = &dv->normalUncUpperBnds;\n  if (B->length() && wronglen(n, B, \"nuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_NormalUnc(DataVariablesRep *dv, size_t offset)\n{\n  short bds = 0; // 2 bits indicated LB and UB specs\n  size_t i, j, n;\n  Real mean, stdev, nudge, lower, upper;\n  RealVector *B, *L, *M, *Sd, *U, *V, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  n  =  dv->numNormalUncVars;\n  M  = &dv->normalUncMeans;      Sd = &dv->normalUncStdDevs;\n  L  = &dv->normalUncLowerBnds;  U  = &dv->normalUncUpperBnds;\n  IP = &dv->normalUncVars;       V  = &dv->continuousAleatoryUncVars;\n\n  // process lower bounds\n  B = &dv->continuousAleatoryUncLowerBnds;\n  if (L->length()) {\n    Vcopyup(B, L, offset, n); // global = distribution\n    bds |= 1;\n  }\n  else {\n    Set_rv(L, -dbl_inf, n); // distribution\n    for(j = 0; j < n; ++j)\n      (*B)[offset+j] = (*M)[j] - 3.*(*Sd)[j]; // inferred global\n  }\n\n  // process upper bounds\n  B = &dv->continuousAleatoryUncUpperBnds;\n  if (U->length()) {\n    Vcopyup(B, U, offset, n); // global = distribution\n    bds |= 2;\n  }\n  else {\n    Set_rv(U, dbl_inf, n); // distribution\n    for(j = 0; j < n; ++j)\n      (*B)[offset+j] = (*M)[j] + 3.*(*Sd)[j]; // inferred global\n  }\n\n  // Set initial values and repair to bounds, if needed\n  if (IP->length()) { // in this case, don't nudge since not a default value\n\n    dv->uncertainVarsInitPt = true;\n\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else { // > bds is 0, 1, 2, or 3 (0 ==> no bounds given, nothing more to do)\n\n    // Note: in the case of BoundedNormalRandomVariable, we are initializing\n    // to the gaussMean parameter of the unbounded normal and repairing to the\n    // bounds.  To assign to the mean of the bounded normal (bounds repair not\n    // necessary), use BoundedNormalRandomVariable::mean().\n    switch(bds) {\n    case 0: // no bounds\n      Vcopyup(V, M, offset, n);\n      break;\n    case 1: // only lower bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j)\n\tif ((*M)[j] <= (*L)[j]) (*V)[i] = (*L)[j] + 0.5*(*Sd)[j];\n\telse                    (*V)[i] = (*M)[j];\n      break;\n\n    case 2: // only upper bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j)\n\tif ((*M)[j] >= (*U)[j]) (*V)[i] = (*U)[j] - 0.5*(*Sd)[j];\n\telse                    (*V)[i] = (*M)[j];\n      break;\n\n    case 3: // both lower and upper bounds given\n      for (i = offset, j = 0; j < n; ++i, ++j) {\n\tlower  = (*L)[j]; upper = (*U)[j];\n\tnudge  = 0.5 * std::min((*Sd)[j], upper - lower);\n\tlower += nudge;   upper -= nudge;  mean = (*M)[j];\n \tif      (mean < lower) (*V)[i] = lower;\n\telse if (mean > upper) (*V)[i] = upper;\n\telse                   (*V)[i] = mean;\n      }\n      break;\n    }\n  }\n}\n\nstatic void Vchk_LognormalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *B, *L, *M, *Sd, *Ef, *Z;\n\n  // lambda/zeta, mean/std_deviation, or mean/error_factor\n  n = dv->numLognormalUncVars;\n  L = &dv->lognormalUncLambdas;\n  M = &dv->lognormalUncMeans;\n  if (L->length()) {\n    if (wronglen(n, L, \"lnuv_lambdas\"))\n      return;\n    if (wronglen(n, Z = &dv->lognormalUncZetas, \"lnuv_zetas\"))\n      return;\n  }\n  else if (M->length()) {\n    if (wronglen(n, M, \"lnuv_means\"))\n      return;\n    Sd = &dv->lognormalUncStdDevs;\n    Ef = &dv->lognormalUncErrFacts;\n    if (Sd->length())\n      { if (wronglen(n, Sd, \"lnuv_std_deviations\")) return; }\n    else if (Ef->length())\n      { if (wronglen(n, Ef, \"lnuv_error_factors\"))  return; }\n    //else error, but this should be trapped elsewhere\n  }\n\n  // lower bounds\n  B = &dv->lognormalUncLowerBnds;\n  if (B->length() && wronglen(n, B, \"lnuv_lower_bounds\"))\n    return;\n\n  // upper bounds\n  B = &dv->lognormalUncUpperBnds;\n  if (B->length() && wronglen(n, B, \"lnuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_LognormalUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real mean, stdev, nudge, lower, upper;\n  RealVector *B, *Ef, *Lam, *L, *M, *Sd, *U, *V, *Z, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  // lambda/zeta, mean/std_deviation, or mean/error_factor\n  n  = dv->numLognormalUncVars;    Lam = &dv->lognormalUncLambdas;\n  Z  = &dv->lognormalUncZetas;     Ef  = &dv->lognormalUncErrFacts;\n  M  = &dv->lognormalUncMeans;     Sd  = &dv->lognormalUncStdDevs;\n  L  = &dv->lognormalUncLowerBnds; U   = &dv->lognormalUncUpperBnds; \n  IP = &dv->lognormalUncVars;      V   = &dv->continuousAleatoryUncVars;\n\n  size_t num_Sd = Sd->length(), num_Lam = Lam->length(), num_IP = IP->length(),\n    num_L = L->length(), num_U = U->length();\n\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  // manage distribution and global bounds.  Global are inferred if\n  // distribution are not specified.\n  if (!num_L) L->size(n); // inits L to zeros --> default {dist,global}\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n); // global = dist\n  B = &dv->continuousAleatoryUncUpperBnds;\n  if (num_U) Vcopyup(B, U, offset, n); // global = dist\n  else       Set_rv(U, dbl_inf, n);    // default dist; global inferred below\n\n  for (i = offset, j = 0; j < n; ++i, ++j) {\n\n    // extract mean & stdev, if needed\n    if (!num_IP || !num_U) {\n      if (num_Lam)  // lambda/zeta\n\tPecos::LognormalRandomVariable::\n\t  moments_from_params((*Lam)[j], (*Z)[j], mean, stdev);\n      else {\n\tmean = (*M)[j];\n\tif (num_Sd) // mean/std_deviation\n\t  stdev = (*Sd)[j];\n\telse        // mean/error_factor\n\t  Pecos::LognormalRandomVariable::\n\t    std_deviation_from_error_factor(mean, (*Ef)[j], stdev);\n      }\n    }\n\n    // Repair initial values to bounds, if needed\n    if (num_IP) { // in this case, don't nudge since not a default value\n\n      // TO DO: set user spec flag\n\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n    }\n    else {\n      // repair bounds exceedance in default value, if needed\n      lower  = (*L)[j]; upper = (*U)[j];\n      nudge  = 0.5 * std::min(stdev, upper - lower);\n      lower += nudge;   upper -= nudge;\n      if      (mean < lower) (*V)[i] = lower;\n      else if (mean > upper) (*V)[i] = upper;\n      else                   (*V)[i] = mean;\n      // Note: in the case of BoundedLognormalRandomVariable, we are\n      // initializing to the mean parameter of the unbounded lognormal\n      // and repairing to the bounds.  To assign to the mean of the\n      // bounded lognormal (bounds repair not necessary), use\n      // BoundedLognormalRandomVariable::mean().\n    }\n\n    // infer global bounds if no distribution bounds spec\n    if (!num_U)\n      (*B)[i] = mean + 3.*stdev;\n  }\n}\n\nstatic void Vchk_UniformUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n;\n  RealVector *L, *U;\n\n  n = dv->numUniformUncVars;\n  L = &dv->uniformUncLowerBnds;\n  U = &dv->uniformUncUpperBnds;\n  if (wronglen(n, L, \"uuv_lower_bounds\") || wronglen(n, U, \"uuv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_UniformUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *U, *V, *IP;\n\n  n = dv->numUniformUncVars;   IP = &dv->uniformUncVars;\n  L = &dv->uniformUncLowerBnds; U = &dv->uniformUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::UniformRandomVariable::\n\tmoments_from_params((*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void \nVchk_LoguniformUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t j, n;\n  Real Lj, Uj;\n  RealVector *L, *U;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  n = dv->numLoguniformUncVars;\n  L = &dv->loguniformUncLowerBnds;\n  U = &dv->loguniformUncUpperBnds;\n  if (wronglen(n, L, \"luuv_lower_bounds\") ||\n      wronglen(n, U, \"luuv_upper_bounds\"))\n    return;\n  for(j = 0; j < n; ++j) {\n    Lj = (*L)[j];\n    Uj = (*U)[j];\n    if (Lj <= 0. || Uj <= 0.) {\n      Squawk(\"loguniform bounds must be positive\");\n      return;\n    }\n    if (Lj == dbl_inf || Uj == dbl_inf) {\n      Squawk(\"loguniform bounds must be finite\");\n      return;\n    }\n    if (Lj > Uj) {\n      Squawk(\"loguniform lower bound greater than upper bound\");\n      return;\n    }\n  }\n}\n\nstatic void Vgen_LoguniformUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *U, *V, *IP;\n\n  n = dv->numLoguniformUncVars;   IP = &dv->loguniformUncVars;\n  L = &dv->loguniformUncLowerBnds; U = &dv->loguniformUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::LoguniformRandomVariable::\n\tmoments_from_params((*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void Vchk_TriangularUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t j, n;\n  Real Lj, Mj, Uj;\n  RealVector *L, *M, *U;\n\n  n = dv->numTriangularUncVars;    M = &dv->triangularUncModes;\n  L = &dv->triangularUncLowerBnds; U = &dv->triangularUncUpperBnds;\n  if (wronglen(n, L, \"tuv_lower_bounds\") || wronglen(n, M, \"tuv_modes\") ||\n      wronglen(n, U, \"tuv_upper_bounds\"))\n    return;\n  for(j = 0; j < n; ++j) {\n    Lj = (*L)[j]; Mj = (*M)[j]; Uj = (*U)[j];\n    if (Lj > Mj || Mj > Uj) {\n      Squawk(\"triangular uncertain variables must have\\n\\t\"\n\t     \"tuv_lower_bounds <= tuv_modes <= tuv_upper_bounds\");\n      return;\n    }\n  }\n}\n\nstatic void Vgen_TriangularUnc(DataVariablesRep *dv, size_t offset)\n{\n  size_t i, j, n;\n  Real stdev;\n  RealVector *L, *M, *U, *V, *IP;\n\n  n = dv->numTriangularUncVars;   IP = &dv->triangularUncVars;\n  L = &dv->triangularUncLowerBnds; U = &dv->triangularUncUpperBnds;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  V = &dv->continuousAleatoryUncVars;\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else {\n    M = &dv->triangularUncModes;\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::TriangularRandomVariable::\n\tmoments_from_params((*L)[j], (*M)[j], (*U)[j], (*V)[i], stdev);\n  }\n}\n\nstatic void \nVchk_ExponentialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numExponentialUncVars;\n  RealVector *B = &dv->exponentialUncBetas;\n  if (wronglen(n, B, \"euv_betas\"))\n    return;\n}\n\nstatic void Vgen_ExponentialUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *B, *L, *U, *V, *IP;\n\n  B = &dv->exponentialUncBetas; IP = &dv->exponentialUncVars;\n  V = &dv->continuousAleatoryUncVars;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  size_t i, j, n = dv->numExponentialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::ExponentialRandomVariable::moments_from_params((*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_BetaUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B, *L, *U;\n\n  A = &dv->betaUncAlphas;    B = &dv->betaUncBetas;\n  L = &dv->betaUncLowerBnds; U = &dv->betaUncUpperBnds;\n\n  size_t n = dv->numBetaUncVars;\n  if (wronglen(n, A, \"buv_alphas\")       || wronglen(n, B, \"buv_betas\") ||\n      wronglen(n, L, \"buv_lower_bounds\") || wronglen(n, U, \"buv_upper_bounds\"))\n    return;\n}\n\nstatic void Vgen_BetaUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  size_t i, j, n = dv->numBetaUncVars;\n  A = &dv->betaUncAlphas;    B = &dv->betaUncBetas;\n  L = &dv->betaUncLowerBnds; U = &dv->betaUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->betaUncVars;\n  Vcopyup(&dv->continuousAleatoryUncLowerBnds, L, offset, n);\n  Vcopyup(&dv->continuousAleatoryUncUpperBnds, U, offset, n);\n  if (IP->length()) {\n    dv->uncertainVarsInitPt = true;\n    for (i = offset, j = 0; j < n; ++i, ++j)\n      if      ((*IP)[j] < (*L)[j]) (*V)[i] =  (*L)[j];\n      else if ((*IP)[j] > (*U)[j]) (*V)[i] =  (*U)[j];\n      else                         (*V)[i] = (*IP)[j];\n  }\n  else\n    for(i = offset, j = 0; j < n; ++i, ++j)\n      Pecos::BetaRandomVariable::\n\tmoments_from_params((*A)[j], (*B)[j], (*L)[j], (*U)[j], (*V)[i], stdev);\n}\n\nstatic void Vchk_GammaUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numGammaUncVars;\n  A = &dv->gammaUncAlphas; B = &dv->gammaUncBetas;\n  if (wronglen(n, A, \"gauv_alphas\") || wronglen(n, B, \"gauv_betas\"))\n    return;\n}\n\nstatic void Vgen_GammaUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->gammaUncAlphas; B = &dv->gammaUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->gammaUncVars;\n  size_t i, j, n = dv->numGammaUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::GammaRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_GumbelUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numGumbelUncVars;\n  A = &dv->gumbelUncAlphas; B = &dv->gumbelUncBetas;\n  if (wronglen(n, A, \"guuv_alphas\") || wronglen(n, B, \"guuv_betas\"))\n    return;\n}\n\nstatic void Vgen_GumbelUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->gumbelUncAlphas; B = &dv->gumbelUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->gumbelUncVars;\n  size_t i, j, n = dv->numGumbelUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::GumbelRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = mean - 3.*stdev;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_FrechetUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numFrechetUncVars;\n  A = &dv->frechetUncAlphas; B = &dv->frechetUncBetas;\n  if (wronglen(n, A, \"fuv_alphas\") || wronglen(n, B, \"fuv_betas\"))\n    return;\n}\n\nstatic void Vgen_FrechetUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->frechetUncAlphas; B = &dv->frechetUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->frechetUncVars;\n  size_t i, j, n = dv->numFrechetUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::FrechetRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\nstatic void Vchk_WeibullUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  RealVector *A, *B;\n\n  size_t n = dv->numWeibullUncVars;\n  A = &dv->weibullUncAlphas; B = &dv->weibullUncBetas;\n  if (wronglen(n, A, \"wuv_alphas\") || wronglen(n, B, \"wuv_betas\"))\n    return;\n}\n\nstatic void Vgen_WeibullUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real mean, stdev;\n  RealVector *A, *B, *L, *U, *V, *IP;\n\n  A = &dv->weibullUncAlphas; B = &dv->weibullUncBetas;\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->weibullUncVars;\n  size_t i, j, n = dv->numWeibullUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::WeibullRandomVariable::\n      moments_from_params((*A)[j], (*B)[j], mean, stdev);\n    (*L)[i] = 0.;\n    (*U)[i] = mean + 3.*stdev;\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = mean;\n  }\n}\n\n\n/// Check the histogram bin input data, normalize the counts and\n/// populate the histogramUncBinPairs map data structure; map keys are\n/// guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramBinUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhbp;\n  RealVector *hba, *hbo, *hbc;\n  int nhbpi, avg_nhbpi;\n  size_t i, j, num_a, num_o, num_c, m, n, tothbp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hba = vi->hba) { // abscissas are required\n    num_a = hba->length();                         // abscissas\n    hbo = vi->hbo; num_o = (hbo) ? hbo->length() : 0; // ordinates\n    hbc = vi->hbc; num_c = (hbc) ? hbc->length() : 0; // counts\n    if (num_o && num_o != num_a) {\n      Squawk(\"Expected %d ordinates, not %d\", num_a, num_o);\n      return;\n    }\n    if (num_c && num_c != num_a) {\n      Squawk(\"Expected %d counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhbp = vi->nhbp) {\n      key = true;\n      m = nhbp->size();\n      //dv->numHistogramBinUncVars = m;\n      for(i=tothbp=0; i<m; ++i) {\n\ttothbp += nhbpi = (*nhbp)[i];\n\tif (nhbpi < 2) {\n\t  Squawk(\"pairs_per_variable must be >= 2\");\n\t  return;\n\t}\n      }\n      if (num_a != tothbp) {\n\tSquawk(\"Expected %d abscissas, not %d\", tothbp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramBinUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhbpi = num_a / m;\n    }\n    RealRealMapArray& hbp = dv->histogramUncBinPairs;\n    hbp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhbpi = (key) ? (*nhbp)[i] : avg_nhbpi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      RealRealMap& hbpi = hbp[i];\n      count_sum = 0.;\n      for (j=0; j<nhbpi; ++j, ++cntr) {\n\tReal x = (*hba)[cntr];                          // abscissas\n\tReal y = (num_o) ? (*hbo)[cntr] : (*hbc)[cntr]; // ordinates/counts\n\tif (j<nhbpi-1) {\n\t  Real bin_width = (*hba)[cntr+1] - x;\n\t  if (bin_width <= 0.) {\n\t    Squawk(\"histogram bin x values must increase\");\n\t    return;\n\t  }\n\t  if (y <= 0.) {\n\t    Squawk(\"nonpositive intermediate histogram bin y value\");\n\t    return;\n\t  }\n\t  if (num_o) // convert from ordinates (probability density) to counts\n\t    y *= bin_width;\n\t  count_sum += y;\n\t}\n\telse if (y != 0) {\n\t  Squawk(\"histogram bin y values must end with 0\");\n\t  return;\n\t}\n\t// insert without checking since keys (abscissas) must increase\n\thbpi[x] = y;\n      }\n      // normalize counts to sum to 1, omitting last value\n      RRMCIter it_end = --(hbpi.end());\n      for (RRMIter it = hbpi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n/// Infer lower/upper bounds for histogram and set initial variable\n/// values based on initial_point or moments, snapping to bounds as\n/// needed.  (Histogram bin doesn't have lower/upper bounds specifcation)\nstatic void Vgen_HistogramBinUnc(DataVariablesRep *dv, size_t offset)\n{\n  RealVector *L, *U, *V, *IP;\n  Real mean, stdev;\n\n  L = &dv->continuousAleatoryUncLowerBnds;\n  U = &dv->continuousAleatoryUncUpperBnds;\n  V = &dv->continuousAleatoryUncVars; IP = &dv->histogramBinUncVars;\n  const RealRealMapArray& A = dv->histogramUncBinPairs;\n  size_t i, j, n = dv->numHistogramBinUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    // the pairs are sorted, so take the first and next to last\n    // (omitting the trailing zero)\n    const RealRealMap& hist_bin_pairs = A[j];\n    (*L)[i] = hist_bin_pairs.begin()->first;\n    (*U)[i] = (--hist_bin_pairs.end())->first;\n    if (num_IP) {\n      if      ((*IP)[j] < (*L)[i]) (*V)[i] =  (*L)[i];\n      else if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                         (*V)[i] = (*IP)[j];\n    }\n    else\n      Pecos::HistogramBinRandomVariable::\n\tmoments_from_params(hist_bin_pairs, (*V)[i], stdev);\n  }\n}\n\nstatic void Vchk_PoissonUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numPoissonUncVars;\n  RealVector *A = &dv->poissonUncLambdas;\n  if (wronglen(n, A, \"lambdas\"))\n    return;\n}\n\nstatic void Vgen_PoissonUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Lam;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars;\n  IP = &dv->poissonUncVars; Lam = &dv->poissonUncLambdas;\n  size_t i, j, n = dv->numPoissonUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::PoissonRandomVariable::moments_from_params((*Lam)[j], mean, std_dev);\n    (*L)[i] = 0;\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_BinomialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numBinomialUncVars;\n  RealVector *A = &dv->binomialUncProbPerTrial;\n  IntVector  *B = &dv->binomialUncNumTrials;\n  if (wronglen(n, A, \"prob_per_trial\") ||  wronglen(n, B, \"num_trials\"))\n    return;\n}\n\nstatic void Vgen_BinomialUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *NT, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->binomialUncVars;\n  NT = &dv->binomialUncNumTrials;      Pr = &dv->binomialUncProbPerTrial;\n  size_t i, j, n = dv->numBinomialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    (*U)[i] = (*NT)[j];\n    if (num_IP) {\n      if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else {\n      Pecos::BinomialRandomVariable::\n\tmoments_from_params((*NT)[j], (*Pr)[j], mean, std_dev);\n      (*V)[i] = (int)mean;\n    }\n  }\n}\n\nstatic void \nVchk_NegBinomialUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numNegBinomialUncVars;\n  RealVector *A = &dv->negBinomialUncProbPerTrial;\n  IntVector  *B = &dv->negBinomialUncNumTrials;\n  if (wronglen(n, A, \"prob_per_trial\") || wronglen(n, B, \"num_trials\"))\n    return;\n}\n\nstatic void Vgen_NegBinomialUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *NT, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->negBinomialUncVars;\n  NT = &dv->negBinomialUncNumTrials;   Pr = &dv->negBinomialUncProbPerTrial;\n  size_t i, j, n = dv->numNegBinomialUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    Pecos::NegBinomialRandomVariable::\n      moments_from_params((*NT)[j], (*Pr)[j], mean, std_dev);\n    (*L)[i] = (*NT)[j];\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) {\n      if ((*IP)[j] < (*L)[i]) (*V)[i] =  (*L)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else                      (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_GeometricUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t n = dv->numGeometricUncVars;\n  RealVector *A = &dv->geometricUncProbPerTrial;\n  if (wronglen(n, A, \"prob_per_trial\"))\n    return;\n}\n\nstatic void Vgen_GeometricUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *U, *V, *IP;\n  Real mean, std_dev;\n  RealVector *Pr;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars; IP = &dv->geometricUncVars;\n  Pr = &dv->geometricUncProbPerTrial;\n  size_t i, j, n = dv->numGeometricUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    Pecos::GeometricRandomVariable::\n      moments_from_params((*Pr)[j], mean, std_dev);\n    (*U)[i] = (int)std::ceil(mean + 3.*std_dev);\n    if (num_IP) (*V)[i] = (*IP)[j];\n    else        (*V)[i] = (int)mean;\n  }\n}\n\nstatic void Vchk_HyperGeomUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntVector *A, *B, *C;\n\n  size_t n = dv->numHyperGeomUncVars;\n  A = &dv->hyperGeomUncTotalPop;\n  B = &dv->hyperGeomUncSelectedPop;\n  C = &dv->hyperGeomUncNumDrawn;\n  if (wronglen(n, A, \"total_population\")    ||\n      wronglen(n, B, \"selected_population\") || wronglen(n, C, \"num_drawn\"))\n    return;\n}\n\nstatic void Vgen_HyperGeomUnc(DataVariablesRep *dv, size_t offset)\n{\n  IntVector *L, *ND, *NS, *TP, *U, *V, *IP;\n  Real mean, std_dev;\n\n  L = &dv->discreteIntAleatoryUncLowerBnds;\n  U = &dv->discreteIntAleatoryUncUpperBnds;\n  V = &dv->discreteIntAleatoryUncVars;\n  ND = &dv->hyperGeomUncNumDrawn; NS = &dv->hyperGeomUncSelectedPop;\n  TP = &dv->hyperGeomUncTotalPop; IP = &dv->hyperGeomUncVars;\n  size_t i, j, n = dv->numHyperGeomUncVars, num_IP = IP->length();\n  int d, s;\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    (*L)[i] = 0;\n    d = (*ND)[j]; s = (*NS)[j];\n    (*U)[i] = std::min(d, s);\n    if (num_IP) {\n      if ((*IP)[j] > (*U)[i]) (*V)[i] =  (*U)[i];\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else {\n      Pecos::HypergeometricRandomVariable::\n\tmoments_from_params((*TP)[j], s, d, mean, std_dev);\n      (*V)[i] = (int)mean;\n    }\n  }\n}\n\n\n/// Check the histogram point integer input data, normalize the\n/// counts, and populate DataVariables::histogramUncPointIntPairs; map\n/// keys are guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramPtIntUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhpip;\n  IntVector *hpia;\n  RealVector *hpic;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real y, bin_width, count_sum;\n  int x;\n\n  if (hpia = vi->hpia) {\n    num_a = hpia->length();              // abscissas\n    hpic = vi->hpic; num_c = hpic->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhpip = vi->nhpip) {\n      key = true;\n      m = nhpip->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhpip)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtIntUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    IntRealMapArray& hpp = dv->histogramUncPointIntPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhpip)[i] : avg_nhppi;\n      // hbpi is map<Int value, Real probability> for a single variable i\n      IntRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tint x = (*hpia)[cntr]; // abscissas\n\tReal y = (*hpic)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpia)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      IRMCIter it_end = hppi.end();\n      for (IRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the integer-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using value closest to\n/// mean if no initial point.\nstatic void Vgen_HistogramPtIntUnc(DataVariablesRep *dv, size_t offset)\n{\n  const IntRealMapArray& A = dv->histogramUncPointIntPairs; \n\n  IntVector& L = dv->discreteIntAleatoryUncLowerBnds;\n  IntVector& U = dv->discreteIntAleatoryUncUpperBnds;\n  IntVector& V = dv->discreteIntAleatoryUncVars;\n  IntVector&  IP = dv->histogramPointIntUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtIntUncVars;\n  size_t num_IP = IP.length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const IntRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tIRMCIter it = hist_pt_prs.begin(), it_end = hist_pt_prs.end();\n\t// find value immediately right of mean (can't be past the end)\n\tfor( ; it != it_end, it->first <= mean; ++it);\n\t// bracket the mean\n\tint right_val = it->first;\n\tint left_val = (--it)->first;\n\t// initialize with value closest to mean\n\tV[i] = (mean - right_val < left_val - mean) ? right_val : left_val;\n      }\n    }\n  }\n}\n\n/// Check the histogram point string input data, normalize the counts,\n/// and populate DataVariables::histogramUncPointStrPairs; map keys\n/// are guaranteed unique since the abscissas must increase\n/// (lexicographically)\nstatic void \nVchk_HistogramPtStrUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhpsp;\n  StringArray *hpsa;\n  RealVector *hpsc;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hpsa = vi->hpsa) {\n    num_a = hpsa->size();              // abscissas\n    hpsc = vi->hpsc; num_c = hpsc->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhpsp = vi->nhpsp) {\n      key = true;\n      m = nhpsp->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhpsp)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtStrUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    StringRealMapArray& hpp = dv->histogramUncPointStrPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhpsp)[i] : avg_nhppi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      StringRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tString x = (*hpsa)[cntr]; // abscissas\n\tReal y = (*hpsc)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpsa)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      SRMCIter it_end = hppi.end();\n      for (SRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the string-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using index closest to\n/// mean index if no initial point.\nstatic void Vgen_HistogramPtStrUnc(DataVariablesRep *dv, size_t offset)\n{\n  const StringRealMapArray& A = dv->histogramUncPointStrPairs; \n\n  StringArray& L = dv->discreteStrAleatoryUncLowerBnds;\n  StringArray& U = dv->discreteStrAleatoryUncUpperBnds;\n  StringArray& V = dv->discreteStrAleatoryUncVars;\n  StringArray& IP = dv->histogramPointStrUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtStrUncVars;\n  size_t num_IP = IP.size();\n\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const StringRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      // for string-valued histograms, mean and stddev are of\n      // zero-based indices from beginning of the map\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tsize_t mean_index = boost::math::iround(mean);\n\tSRMCIter it = hist_pt_prs.begin();\n\tstd::advance(it, mean_index);\n\t// initialize with value closest to mean\n\tV[i] = it->first;\n      }\n    }\n  }\n}\n\n\n/// Check the histogram point integer real data, normalize the counts,\n/// and populate DataVariables::histogramUncPointRealPairs; map keys\n/// are guaranteed unique since the abscissas must increase\nstatic void \nVchk_HistogramPtRealUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  IntArray *nhprp;\n  RealVector *hpra, *hprc;\n  int nhppi, avg_nhppi;\n  size_t i, j, num_a, num_c, m, n, tothpp, cntr;\n  Real x, y, bin_width, count_sum;\n\n  if (hpra = vi->hpra) {\n    num_a = hpra->length();              // abscissas\n    hprc = vi->hprc; num_c = hprc->length(); // counts\n    if (num_c != num_a) {\n      Squawk(\"Expected %d point counts, not %d\", num_a, num_c);\n      return;\n    }\n    bool key;\n    if (nhprp = vi->nhprp) {\n      key = true;\n      m = nhprp->size();\n      //dv->numHistogramPtUncVars = m;\n      for(i=tothpp=0; i<m; ++i) {\n\ttothpp += nhppi = (*nhprp)[i];\n\tif (nhppi < 1) {\n\t  Squawk(\"pairs_per_variable must be >= 1\");\n\t  return;\n\t}\n      }\n      if (num_a != tothpp) {\n\tSquawk(\"Expected %d point abscissas, not %d\", tothpp, num_a);\n\treturn;\n      }\n    }\n    else {\n      key = false;\n      m = dv->numHistogramPtRealUncVars;\n      if (num_a % m) {\n\tSquawk(\"Number of abscissas (%d) not evenly divisible by number of variables (%d); Use pairs_per_variable for unequal apportionment\", num_a, m);\n\treturn;\n      }\n      else\n\tavg_nhppi = num_a / m;\n    }\n    RealRealMapArray& hpp = dv->histogramUncPointRealPairs;\n    hpp.resize(m);\n    for (i=cntr=0; i<m; ++i) {\n      nhppi = (key) ? (*nhprp)[i] : avg_nhppi;\n      // hbpi is map<Real value, Real probability> for a single variable i\n      RealRealMap& hppi = hpp[i];\n      count_sum = 0.;\n      for (j=0; j<nhppi; ++j, ++cntr) {\n\tReal x = (*hpra)[cntr]; // abscissas\n\tReal y = (*hprc)[cntr]; // counts\n\tif (j<nhppi-1 && x >= (*hpra)[cntr+1]) {\n\t  Squawk(\"histogram point x values must increase\");\n\t  return;\n\t}\n\tif (y <= 0.) {\n\t  Squawk(\"nonpositive intermediate histogram point y value\");\n\t  return;\n\t}\n\thppi[x] = y;\n\tcount_sum += y;\n      }\n      // normalize counts to sum to 1\n      RRMCIter it_end = hppi.end();\n      for (RRMIter it = hppi.begin(); it != it_end; ++it)\n\tit->second /= count_sum;\n    }\n  }\n}\n\n\n/// Use the real-valued point histogram data to initialize the lower,\n/// upper, and initial values of the variables, using value closest to\n/// mean if no initial point.\nstatic void Vgen_HistogramPtRealUnc(DataVariablesRep *dv, size_t offset)\n{\n  const RealRealMapArray& A = dv->histogramUncPointRealPairs; \n\n  RealVector& L = dv->discreteRealAleatoryUncLowerBnds;\n  RealVector& U = dv->discreteRealAleatoryUncUpperBnds;\n  RealVector& V = dv->discreteRealAleatoryUncVars;\n  RealVector& IP = dv->histogramPointRealUncVars;\n\n  size_t i, j, k, last, n = dv->numHistogramPtRealUncVars;\n  size_t num_IP = IP.length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    const RealRealMap& hist_pt_prs = A[j];\n    L[i] = hist_pt_prs.begin()->first;\n    U[i] = (--hist_pt_prs.end())->first;\n    if (num_IP) {\n      if      (IP[j] < L[i]) V[i] =  L[i];\n      else if (IP[j] > U[i]) V[i] =  U[i];\n      else                   V[i] = IP[j];\n    }\n    else {\n      Real mean, stdev;\n      Pecos::HistogramPtRandomVariable::\n\tmoments_from_params(hist_pt_prs, mean, stdev);\n      if (hist_pt_prs.size() == 1)\n\tV[i] = hist_pt_prs.begin()->first;\n      else {\n\tRRMCIter it = hist_pt_prs.begin(), it_end = hist_pt_prs.end();\n\t// find value immediately right of mean (can't be past the end)\n\tfor( ; it != it_end, it->first <= mean; ++it);\n\t// bracket the mean\n\tReal right_val = it->first;\n\tReal left_val = (--it)->first;\n\t// initialize with value closest to mean\n\tV[i] = (mean - right_val < left_val - mean) ? right_val : left_val;\n      }\n    }\n  }\n}\n\n\n/// Check the continuous interval uncertain input data and populate\n/// DataVariables::continuousIntervalUncBasicProbs; map keys (real\n/// intervals) are checked for uniqueness because we don't have a\n/// theoretically sound way to combine duplicate intervals\nstatic void\nVchk_ContinuousIntervalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t i, j, k, m, num_p = 0, num_lb, num_ub;\n  IntArray *nI;\n  int tot_nI, nIi, avg_nI;\n  Real lb, lbj, ub, ubj, default_p;\n  RealVector *Ilb, *Iub, *Ip;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  if ((Ilb = vi->CIlb) && (Iub = vi->CIub)) {\n    num_lb = Ilb->length(); // interval lower_bounds\n    num_ub = Iub->length(); // interval upper_bounds\n\n    // error check on array lengths; bounds are reqd, probs are optional\n    if ((Ip = vi->CIp)) {\n      num_p = Ip->length(); // interval_probs\n      if (num_lb != num_p || num_ub != num_p) {\n\tSquawk(\"Expected as many lower bounds (%d) and upper bounds (%d) as probabilities (%d)\", num_lb, num_ub, num_p);\n\treturn;\n      }\n    }\n    else if (num_lb != num_ub) {\n      Squawk(\"Expected as many lower bounds (%d) as upper bounds (%d)\", num_lb, num_ub);\n      return;\n    }\n\n    // define apportionment\n    bool key;\n    if (nI = vi->nCI) {\n      key = true;\n      m = nI->size();\n      if (m != dv->numContinuousIntervalUncVars) {\n\tSquawk(\"Expected %d numbers for num_intervals, but got %d\",\n\t       dv->numContinuousIntervalUncVars, m);\n\treturn;\n      }\n      for(i=tot_nI=0; i<m; ++i) {\n\ttot_nI += nIi = (*nI)[i];\n\tif (nIi < 1) {\n\t  Squawk(\"num_intervals values should be positive\");\n\t  return;\n\t}\n      }\n      if ( (num_p && wronglen(tot_nI,  Ip, \"interval_probs\") ) ||\n\t   wronglen(tot_nI, Ilb, \"interval lower_bounds\") ||\n\t   wronglen(tot_nI, Iub, \"interval upper_bounds\"))\n\treturn;\n    }\n    else {\n      key = false;\n      m = dv->numContinuousIntervalUncVars;\n      if (num_lb % m) {\n\tSquawk(\"Number of bounds (%d) not evenly divisible by number of variables (%d); Use num_intervals for unequal apportionment\", num_lb, m);\n\treturn;\n      }\n      else\n\tavg_nI = num_lb / m;\n    }\n    RealRealPairRealMapArray& P = dv->continuousIntervalUncBasicProbs;   \n    P.resize(m);\n    for(i = k = 0; i < m; ++i) {\n      nIi = (key) ? (*nI)[i] : avg_nI;\n      RealRealPairRealMap& Pi = P[i];  // map from an interval to a probability\n      lb = dbl_inf;\n      ub = -dbl_inf;\n      if (!num_p) \n        default_p = 1./nIi; // default = equal probability per cell\n      else {\n        double total_prob=0.0; \n        size_t s = k;\n        for(j=0; j<nIi; ++j, ++s) {  // normalize the probabilities to sum to one\n          total_prob+=(*Ip)[s];\n        }         \n        if (fabs(total_prob-1.0) > 1.E-10) {\n          s = k;\n          {for(j=0; j<nIi; ++j,++s)  // normalize the probabilities to sum to one\n            (*Ip)[s]/=total_prob;\n          }       \n          Warn(\"Renormalized probability assignments to sum to one for variable %d\",i);\n        } \n      }\n      for(j=0; j<nIi; ++j, ++k) {\n\tlbj = (*Ilb)[k];\n\tubj = (*Iub)[k];\n\tRealRealPair interval(lbj, ubj);\n\tReal probability = (num_p) ? (*Ip)[k] : default_p;\n\tif (!Pi.insert(make_pair(interval, probability)).second)\n\t  Squawk(\"Continuous interval [%g, %g] specified more than once for variable %d\", interval.first, interval.second, i);\n\tif (lb > lbj) lb = lbj;\n\tif (ub < ubj) ub = ubj;\n        if (lbj > ubj)\n\t  Squawk(\"Upper bound less than lower bound: [%g, %g] for interval variable %d\", lbj, ubj,i);\n      }\n      if (lb > ub)\n\tSquawk(\"Inconsistent interval uncertain bounds: %g > %g\", lb, ub);\n    }\n  }\n}\n\nstatic void Vgen_ContinuousIntervalUnc(DataVariablesRep *dv, size_t offset)\n{\n  Real lb, lbk, ub, ubk, stdev;\n  RealVector *ceuLB, *ceuUB, *V, *IP;\n  Real dbl_inf = std::numeric_limits<Real>::infinity();\n\n  ceuLB = &dv->continuousEpistemicUncLowerBnds;\n  ceuUB = &dv->continuousEpistemicUncUpperBnds;\n  V     = &dv->continuousEpistemicUncVars;\n  const RealRealPairRealMapArray& P = dv->continuousIntervalUncBasicProbs;\n  IP    = &dv->continuousIntervalUncVars;\n  size_t i, j, n = dv->numContinuousIntervalUncVars,\n    num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    lb = dbl_inf; ub = -dbl_inf;\n    const RealRealPairRealMap& Pj = P[j];\n    RealRealPairRealMap::const_iterator it = Pj.begin();\n    RealRealPairRealMap::const_iterator it_end = Pj.end();\n    for ( ; it != it_end; ++it) {\n      const RealRealPair& interval = it->first;\n      lbk = interval.first; \n      ubk = interval.second;\n      if (lb > lbk) lb = lbk;\n      if (ub < ubk) ub = ubk;\n    }\n    (*ceuLB)[i] = lb; (*ceuUB)[i] = ub;\n    if (num_IP) {\n      if      ((*IP)[j] < lb) (*V)[i] = lb;\n      else if ((*IP)[j] > ub) (*V)[i] = ub;\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else\n      Pecos::UniformRandomVariable::moments_from_params(lb, ub, (*V)[i], stdev);\n    // TO DO: if disjoint cells, repair V[i] to lie inside nearest cell\n  }\n}\n\n/// Check the discrete interval uncertain input data and populate\n/// DataVariables::discreteIntervalUncBasicProbs; map keys (integer\n/// intervals) are checked for uniqueness because we don't have a\n/// theoretically sound way to combine duplicate intervals\nstatic void \nVchk_DiscreteIntervalUnc(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  size_t i, j, k, m, num_p = 0, num_lb, num_ub;\n  IntArray *nI;\n  int tot_nI, nIi, avg_nI, lb, lbj, ub, ubj;\n  Real default_p;\n  RealVector *Ip;\n  IntVector *Ilb, *Iub;\n\n  if ((Ilb = vi->DIlb) && (Iub = vi->DIub)) {\n    num_lb = Ilb->length(); // interval lower_bounds\n    num_ub = Iub->length(); // interval upper_bounds\n\n    // error check on array lengths; bounds are reqd, probs are optional\n    if ((Ip = vi->DIp)) {\n      num_p = Ip->length(); // interval_probs\n      if (num_lb != num_p || num_ub != num_p) {\n\tSquawk(\"Expected as many lower bounds (%d) and upper bounds (%d) as probabilities (%d)\", num_lb, num_ub, num_p);\n\treturn;\n      }\n    }\n    else if (num_lb != num_ub) {\n      Squawk(\"Expected as many lower bounds (%d) as upper bounds (%d)\", num_lb, num_ub);\n      return;\n    }\n\n    // define apportionment\n    bool key;\n    if (nI = vi->nDI) {\n      key = true;\n      m = nI->size();\n      if (m != dv->numDiscreteIntervalUncVars) {\n\tSquawk(\"Expected %d numbers for num_intervals, but got %d\",\n\t       dv->numDiscreteIntervalUncVars, m);\n\treturn;\n      }\n      for(i=tot_nI=0; i<m; ++i) {\n\ttot_nI += nIi = (*nI)[i];\n\tif (nIi < 1) {\n\t  Squawk(\"num_intervals values should be positive\");\n\t  return;\n\t}\n      }\n      if ( (num_p && wronglen(tot_nI,  Ip, \"interval_probs\") ) ||\n\t   wronglen(tot_nI, Ilb, \"interval lower_bounds\") ||\n\t   wronglen(tot_nI, Iub, \"interval upper_bounds\"))\n\treturn;\n    }\n    else {\n      key = false;\n      m = dv->numDiscreteIntervalUncVars;\n      if (num_lb % m) {\n\tSquawk(\"Number of bounds (%d) not evenly divisible by number of variables (%d); Use num_intervals for unequal apportionment\", num_lb, m);\n\treturn;\n      }\n      else\n\tavg_nI = num_lb / m;\n    }\n    IntIntPairRealMapArray& P = dv->discreteIntervalUncBasicProbs;   \n    P.resize(m);\n    for(i = k = 0; i < m; ++i) {\n      nIi = (key) ? (*nI)[i] : avg_nI;\n      IntIntPairRealMap& Pi = P[i];   // map from an interval to a probability\n      lb = INT_MAX; ub = INT_MIN;\n      if (!num_p) default_p = 1./nIi; // default = equal probability per cell\n      for(j=0; j<nIi; ++j, ++k) {\n\tlbj = (*Ilb)[k];      \n\tubj = (*Iub)[k];\n\tIntIntPair interval(lbj, ubj);\n\tReal probability =  (num_p) ? (*Ip)[k] : default_p;\n\tif (!Pi.insert(make_pair(interval, probability)).second)\n\t  Squawk(\"Discrete interval [%d, %d] specified more than once for variable %d\", interval.first, interval.second, i);\n\tif (lb > lbj) lb = lbj;\n\tif (ub < ubj) ub = ubj;\n      }\n      if (lb > ub)\n\tSquawk(\"Inconsistent interval uncertain bounds: %g > %g\", lb, ub);\n    }\n  }\n}\n\nstatic void Vgen_DiscreteIntervalUnc(DataVariablesRep *dv, size_t offset)\n{\n  int lb, lbk, ub, ubk, stdev;\n  IntVector *deuLB, *deuUB, *V, *IP;\n\n  deuLB = &dv->discreteIntEpistemicUncLowerBnds;\n  deuUB = &dv->discreteIntEpistemicUncUpperBnds;\n  V     = &dv->discreteIntEpistemicUncVars;\n  const IntIntPairRealMapArray& P = dv->discreteIntervalUncBasicProbs;\n  IP    = &dv->discreteIntervalUncVars;\n  size_t i, j, n = dv->numDiscreteIntervalUncVars, num_IP = IP->length();\n  if (num_IP) dv->uncertainVarsInitPt = true;\n\n  for(i = offset, j = 0; j < n; ++i, ++j) {\n    ub = INT_MIN; lb = INT_MAX;\n    const IntIntPairRealMap& Pj = P[j];\n    IntIntPairRealMap::const_iterator it = Pj.begin();\n    IntIntPairRealMap::const_iterator it_end = Pj.end();\n    for ( ; it != it_end; ++it) {\n      const IntIntPair& interval = it->first;\n      lbk = interval.first; \n      ubk = interval.second;\n      if (lb > lbk) lb = lbk;\n      if (ub < ubk) ub = ubk;\n    }    \n    (*deuLB)[i] = lb; (*deuUB)[i] = ub;\n    if (num_IP) {\n      if      ((*IP)[j] < lb) (*V)[i] = lb;\n      else if ((*IP)[j] > ub) (*V)[i] = ub;\n      else                    (*V)[i] = (*IP)[j];\n    }\n    else\n      (*V)[i] = (lb + ub) / 2; // int truncation if odd sum\n    // TO DO: if disjoint cells, repair V[offset] to lie inside nearest cell\n  }\n}\n\n\n/// validate the number of set elements (values) given the number of\n/// variables and an optional apportionment with\n/// elements_per_variable; return the average number per variable if\n/// equally distributed\nstatic bool \ncheck_set_keys(size_t num_v, size_t ds_len, const char *kind,\n\t       IntArray *input_nds, int& avg_num_ds)\n{\n  // Process num_set_values key or define default allocation\n  bool key = (input_nds);\n  if (key) {\n    if (input_nds->size() != num_v) {\n      wrong_number(\"num_set_values value(s)\", kind, num_v, input_nds->size());\n      return key;\n    }\n    int num_ds_i, total_ds = 0;\n    for (size_t i=0; i<num_v; ++i) {\n      total_ds += num_ds_i = (*input_nds)[i];\n      if (num_ds_i < 1)\n\t{ too_small(kind); return key; }\n    }\n    if (ds_len != total_ds)\n      { wrong_number(\"set_values\", kind, total_ds, ds_len); return key; }\n  }\n  else { // num_set_values is optional; use average len if no spec\n    if (ds_len % num_v)\n      { not_div(kind, ds_len, num_v); return key; }\n    else\n      avg_num_ds = ds_len / num_v;\n  }\n  return key;\n}\n\n\n/// check discrete sets of integers (design and state variables);\n/// error if a duplicate value is specified\n/// error if not ordered to prevent user confusion\nstatic void \nVchk_DIset(size_t num_v, const char *kind, IntArray *input_ndsi,\n\t   IntVector *input_dsi, IntSetArray& dsi_all, IntVector& dsi_init_pt)\n{\n  if (!input_dsi)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsi, ndup, dupval[2], num_dsi_i, val;\n  size_t i, j, cntr, dsi_len = input_dsi->length();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsi_len, kind, input_ndsi, avg_num_dsi);\n\n  // Insert values into the IntSetArray\n  dsi_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dsi_i = (key) ? (*input_ndsi)[i] : avg_num_dsi;\n    IntSet& dsi_all_i = dsi_all[i];\n    for (j=0; j<num_dsi_i; ++j, ++cntr) {\n      val = (*input_dsi)[cntr];\n      if (!dsi_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsi_i-1 && val >= (*input_dsi)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, dupval, 0, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsi_init_pt.empty()) {\n    if (dsi_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsi_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tIntSet& dsi_all_i = dsi_all[i]; val = dsi_init_pt[i];\n\tif (dsi_all_i.find(val) == dsi_all_i.end())\n\t  bad_initial_ivalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n/// check discrete sets of integers (uncertain variables);\n/// error if a duplicate value is specified\n/// error if not ordered to prevent user confusion\nstatic void \nVchk_DIset(size_t num_v, const char *kind, IntArray *input_ndsi,\n\t   IntVector *input_dsi, RealVector *input_dsip,\n\t   IntRealMapArray& dsi_vals_probs, IntVector& dsi_init_pt)\n{\n  if (!input_dsi)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsi, ndup, dupval[2], num_dsi_i, val;\n  size_t i, j, cntr, dsi_len = input_dsi->length(),\n    num_p = (input_dsip) ? input_dsip->length() : 0;\n  if (num_p && num_p != dsi_len)\n    wrong_number(\"set_probabilities\", kind, dsi_len, num_p);\n  Real prob, default_p;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsi_len, kind, input_ndsi, avg_num_dsi);\n\n  // Insert values into the IntRealMapArray\n  dsi_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    IntRealMap& dsi_v_p_i = dsi_vals_probs[i];\n    num_dsi_i = (key) ? (*input_ndsi)[i] : avg_num_dsi;\n    if (!num_p) default_p = 1./num_dsi_i;\n    for (j=0; j<num_dsi_i; ++j, ++cntr) {\n      val  = (*input_dsi)[cntr];\n      prob = (num_p) ? (*input_dsip)[cntr] : default_p;\n      if (dsi_v_p_i.find(val) == dsi_v_p_i.end())\n\tdsi_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dsi_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsi_i-1 && val >= (*input_dsi)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, dupval, 0, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsi_init_pt.empty()) {\n    if (dsi_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsi_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tIntRealMap& dsi_v_p_i = dsi_vals_probs[i]; val = dsi_init_pt[i];\n\tif (dsi_v_p_i.find(val) == dsi_v_p_i.end())\n\t  bad_initial_ivalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\nstatic void \nVchk_DSset(size_t num_v, const char *kind, IntArray *input_ndss,\n\t   StringArray *input_dss, StringSetArray& dss_all, StringArray& dss_init_pt)\n{\n  if (!input_dss)\n    return;\n\n  std::vector<bool> misordered(num_v,false);\n  int avg_num_dss, ndup, num_dss_i;\n  String dupval[2], val;\n  size_t i, j, cntr, dss_len = input_dss->size();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dss_len, kind, input_ndss, avg_num_dss);\n\n  // Insert values into the StringSetArray\n  dss_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dss_i = (key) ? (*input_ndss)[i] : avg_num_dss;\n    StringSet& dss_all_i = dss_all[i];\n    for (j=0; j<num_dss_i; ++j, ++cntr) {\n      val = (*input_dss)[cntr];\n      if (!dss_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dss_i-1 && val >= (*input_dss)[cntr+1])\n\tmisordered[i] = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, dupval, 0);\n  // Check for misordered elements and print out in the expected order\n  for(i=0; i<num_v; ++i) {\n    if (misordered[i]) {\n\tstd::stringstream mss;\n\tstd::copy(dss_all[i].begin(), dss_all[i].end(),\n\t    std::ostream_iterator<std::string>(mss, \" \"));\n        Squawk(\"Elements of %s variables must be provided in ascending order ( %s)\",\n\t    kind, mss.str().c_str());\n     }\n  }\n\n  // Checks on user-specified initial pt array\n  if (!dss_init_pt.empty()) {\n    if (dss_init_pt.size() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dss_init_pt.size());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tStringSet& dss_all_i = dss_all[i]; val = dss_init_pt[i];\n\tif (dss_all_i.find(val) == dss_all_i.end())\n\t  bad_initial_svalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DSset\n}\n\nstatic void \nVchk_DSset(size_t num_v, const char *kind, IntArray *input_ndss,\n\t   StringArray *input_dss, RealVector *input_dssp,\n\t   StringRealMapArray& dss_vals_probs, StringArray& dss_init_pt)\n{\n  if (!input_dss)\n    return;\n\n  bool misordered = false;\n  int avg_num_dss, ndup, num_dss_i;\n  String dupval[2], val;\n  size_t i, j, cntr, dss_len = input_dss->size(),\n    num_p = (input_dssp) ? input_dssp->length() : 0;\n  if (num_p && num_p != dss_len)\n    wrong_number(\"set_probabilities\", kind, dss_len, num_p);\n  Real prob, default_p;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dss_len, kind, input_ndss, avg_num_dss);\n\n  // Insert values into the StringRealMapArray\n  dss_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    StringRealMap& dss_v_p_i = dss_vals_probs[i];\n    num_dss_i = (key) ? (*input_ndss)[i] : avg_num_dss;\n    if (!num_p) default_p = 1./num_dss_i;\n    for (j=0; j<num_dss_i; ++j, ++cntr) {\n      val  = (*input_dss)[cntr];\n      prob = (num_p) ? (*input_dssp)[cntr] : default_p;\n      if (dss_v_p_i.find(val) == dss_v_p_i.end())\n\tdss_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dss_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dss_i-1 && val >= (*input_dss)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, dupval, 0);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dss_init_pt.empty()) {\n    if (dss_init_pt.size() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dss_init_pt.size());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tStringRealMap& dss_v_p_i = dss_vals_probs[i]; val = dss_init_pt[i];\n\tif (dss_v_p_i.find(val) == dss_v_p_i.end())\n\t  bad_initial_svalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n\nstatic void \nVchk_DRset(size_t num_v, const char *kind, IntArray  *input_ndsr,\n\t   RealVector *input_dsr, RealSetArray& dsr_all,\n\t   RealVector& dsr_init_pt)\n{\n  if (!input_dsr)\n    return;\n\n  bool misordered = false;\n  int avg_num_dsr, ndup, num_dsr_i;\n  Real dupval[2], val;\n  size_t i, j, cntr, dsr_len = input_dsr->length();\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsr_len, kind, input_ndsr, avg_num_dsr);\n\n  // Insert values into the RealSetArray\n  dsr_all.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    num_dsr_i = (key) ? (*input_ndsr)[i] : avg_num_dsr;\n    RealSet& dsr_all_i = dsr_all[i];\n    for (j=0; j<num_dsr_i; ++j, ++cntr) {\n      val = (*input_dsr)[cntr];\n      if (!dsr_all_i.insert(val).second) { // insert returns pair<iterator,bool>\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsr_i-1 && val >= (*input_dsr)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, 0, dupval);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsr_init_pt.empty()) {\n    if (dsr_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsr_init_pt.length());\n    else\n      for (i=0; i<num_v; ++i) {\n\tRealSet& dsr_all_i = dsr_all[i]; val = dsr_init_pt[i];\n\tif (dsr_all_i.find(val) == dsr_all_i.end())\n\t  bad_initial_rvalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DRset\n}\n\nstatic void \nVchk_DRset(size_t num_v, const char *kind, IntArray  *input_ndsr,\n\t   RealVector *input_dsr, RealVector* input_dsrp,\n\t   RealRealMapArray& dsr_vals_probs, RealVector& dsr_init_pt)\n{\n  if (!input_dsr)\n    return;\n\n  bool misordered = false;\n  size_t i, j, cntr, dsr_len = input_dsr->length();\n  int avg_num_dsr, ndup, num_dsr_i,\n    num_p = (input_dsrp) ? input_dsrp->length() : 0;\n  if (num_p && num_p != dsr_len)\n    wrong_number(\"set_probabilities\", kind, dsr_len, num_p);\n  Real prob, default_p, dupval[2], val;\n\n  // Process num_set_values key or define default allocation\n  bool key = check_set_keys(num_v, dsr_len, kind, input_ndsr, avg_num_dsr);\n\n  // Insert values into the RealRealMapArray\n  dsr_vals_probs.resize(num_v);\n  for (i=cntr=ndup=0; i<num_v; ++i) {\n    RealRealMap& dsr_v_p_i = dsr_vals_probs[i];\n    num_dsr_i = (key) ? (*input_ndsr)[i] : avg_num_dsr;\n    if (!num_p) default_p = 1./num_dsr_i;\n    for (j=0; j<num_dsr_i; ++j, ++cntr) {\n      val  = (*input_dsr)[cntr];\n      prob = (num_p) ? (*input_dsrp)[cntr] : default_p;\n      if (dsr_v_p_i.find(val) == dsr_v_p_i.end())\n\tdsr_v_p_i[val]  = prob; // insert new\n      else {\n\t// don't want to aggregate the probability; just error\n\t//dsr_v_p_i[val] += prob; // add to existing\n\tif (++ndup <= 2) // warnings suppressed beyond two duplicates\n\t  dupval[ndup-1] = val;\n      }\n      if (j<num_dsr_i-1 && val >= (*input_dsr)[cntr+1])\n\tmisordered = true;\n    }\n  }\n  if (ndup)\n    suppressed(kind, ndup, 0, 0, dupval);\n  if (misordered)\n    Squawk(\"Set values for each %s variable must increase\", kind);\n\n  // Checks on user-specified initial pt array\n  if (!dsr_init_pt.empty()) {\n    if (dsr_init_pt.length() != num_v)\n      wrong_number(\"initial_point value(s)\", kind, num_v, dsr_init_pt.length());\n    else // check within admissible set for specified initial pt\n      for (i=0; i<num_v; ++i) {\n\tRealRealMap& dsr_v_p_i = dsr_vals_probs[i]; val = dsr_init_pt[i];\n\tif (dsr_v_p_i.find(val) == dsr_v_p_i.end())\n\t  bad_initial_rvalue(kind, val);\n      }\n  }\n  //else: default initialization performed in Vgen_DIset\n}\n\n// Validate adjacency matrices \nstatic void \nVchk_Adjacency(size_t num_v, const char *kind, const IntArray &num_e,\n\t\tconst IntVector &input_ddsa, RealMatrixArray &dda_all)  {\n  size_t expected_size = 0;\n  for(size_t i = 0; i < num_v; ++i)\n    expected_size += num_e[i]*num_e[i];\n    if(expected_size != input_ddsa.length())\n      Squawk(\"adjacency list for %s has incorrect length\", kind);\n    else {\n      size_t e_ctr = 0;\n      for(size_t i = 0; i < num_v; ++i) {\n        RealMatrix a_tmp(num_e[i],num_e[i]);\n        for(size_t j = 0; j < num_e[i]; ++j)  \n          for(size_t k = 0; k < num_e[i]; ++k) \n            a_tmp[j][k] = input_ddsa[e_ctr++];\n        dda_all.push_back(a_tmp);\n      }\n    }\n}\n\nstatic bool \ncheck_LUV_size(size_t num_v, IntVector& L, IntVector& U, IntVector& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.length() || max_index >= U.length() ||\n\tmax_index >= V.length())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DIset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DIset\",\n\t     (int)offset);\n    L.sizeUninitialized(num_v);\n    U.sizeUninitialized(num_v);\n    if (V.length() == num_v) // user spec --> already assigned by var_ivec()\n      init_V = false;\n    else\n      V.sizeUninitialized(num_v);\n  }\n  return init_V;\n}\n\nstatic bool \ncheck_LUV_size(size_t num_v, StringArray& L, StringArray& U, StringArray& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.size() || max_index >= U.size() ||\n\tmax_index >= V.size())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DSset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DSset\",\n\t     (int)offset);\n    L.resize(num_v);\n    U.resize(num_v);\n    if (V.size() == num_v) // user spec --> already assigned by var_ivec()\n      init_V = false;\n    else\n      V.resize(num_v);\n  }\n  return init_V;\n}\n\n\n\nstatic bool \ncheck_LUV_size(size_t num_v, RealVector& L, RealVector& U, RealVector& V,\n\t       bool aggregate_LUV, size_t offset)\n{\n  bool init_V = true;\n  if (aggregate_LUV) {\n    int max_index = offset + num_v - 1;\n    if (max_index >= L.length() || max_index >= U.length() ||\n\tmax_index >= V.length())\n      Squawk(\"max index %d out of range for aggregate updates in Vgen_DRset\",\n\t     max_index);\n  }\n  else {\n    if (offset)\n      Squawk(\"unexpected offset (%d) for non-aggregate mode in Vgen_DRset\",\n\t     (int)offset);\n    L.sizeUninitialized(num_v);\n    U.sizeUninitialized(num_v);\n    if (V.length() == num_v) // user spec --> already assigned by var_rvec()\n      init_V = false;\n    else\n      V.sizeUninitialized(num_v);\n  }\n  return init_V;\n}\n\nstatic void \nVgen_DIset(size_t num_v, IntSetArray& sets, IntVector& L, IntVector& U,\n\t   IntVector& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  ISCIter ie, it;\n  Real avg_val, r_val;\n  int i, i_val, i_left, i_right;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    IntSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = 0;\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ie; it != ie; ++it)\n\t  avg_val += *it;\n\tavg_val /= num_set_i;\n\t// bracket avg_val between [i_left,i_right]\n\ti_left = L[offset]; i_right = U[offset];\n\tfor(it = set_i.begin(); it != ie; ++it) {\n\t  r_val = i_val = *it;\n\t  if (r_val > avg_val) {      // update nearest neighbor to right\n\t    if (i_val < i_right)\n\t      i_right = i_val;\n\t  }\n\t  else if (r_val < avg_val) { // update nearest neighbor to left\n\t    if (i_val > i_left)\n\t      i_left = i_val;\n\t  }\n\t  else { // r_val equals avg_val\n\t    i_left = i_right = i_val;\n\t    break;\n\t  }\n\t}\n\tV[offset] = (i_right - avg_val < avg_val - i_left) ? i_right : i_left;\n      }\n    }\n  }\n}\n\n\n/// generate lower, upper, and initial point for string-valued sets\nstatic void \nVgen_DSset(size_t num_v, StringSetArray& sets, StringArray& L, StringArray& U,\n\t   StringArray& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  SSCIter ie, it;\n  int i;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    StringSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = \"\";\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\tsize_t mid_index = 0;\n\t// initial value is at middle index or the one directly below\n\tif ( (num_set_i % 2 == 0) )\n\t  // initial value is to the left of middle\n\t  mid_index = num_set_i / 2 - 1;\n\telse \n\t  mid_index = (num_set_i + 1) / 2 - 1;\n\tstd::advance(it, mid_index);\n\tV[offset] = *it;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DIset(size_t num_v, IntRealMapArray& vals_probs, IntVector& IP,\n\t   IntVector& L, IntVector& U, IntVector& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  IRMCIter ite, it;\n  Real avg_val, r_val;\n  int i_val, i_left, i_right;\n  size_t i, j, num_vp_j, num_IP = IP.length();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    IntRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = 0;\n      V[i] = (num_IP) ? IP[j] : 0;\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;      // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j]; // presence of value w/i set already checked\n      else if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ite; it != ite; ++it)\n\t  avg_val += it->first;\n\tavg_val /= num_vp_j;\n\t// bracket avg_val between [i_left,i_right]\n\ti_left = L[offset]; i_right = U[offset];\n\tfor(it = vp_j.begin(); it != ite; ++it) {\n\t  r_val = i_val = it->first;\n\t  if (r_val > avg_val) {      // update nearest neighbor to right\n\t    if (i_val < i_right)\n\t      i_right = i_val;\n\t  }\n\t  else if (r_val < avg_val) { // update nearest neighbor to left\n\t    if (i_val > i_left)\n\t      i_left = i_val;\n\t  }\n\t  else { // r_val equals avg_val\n\t    i_left = i_right = i_val;\n\t    break;\n\t  }\n\t}\n\tV[i] = (i_right - avg_val < avg_val - i_left) ? i_right : i_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DRset(size_t num_v, RealSetArray& sets, RealVector& L, RealVector& U,\n\t   RealVector& V, bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  RSCIter ie, it;\n  int i;\n  size_t num_set_i;\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = 0; i < num_v; ++i, ++offset) {\n    RealSet& set_i = sets[i];\n    it = set_i.begin(); ie = set_i.end(); num_set_i = set_i.size();\n    if (num_set_i == 0) // should not occur\n      L[offset] = U[offset] = V[offset] = 0.;\n    else if (num_set_i == 1)\n      L[offset] = U[offset] = V[offset] = *it;\n    else {\n      L[offset] = *it;     // lower bound is first value\n      U[offset] = *(--ie); // upper bound is final value\n      if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ie; it != ie; ++it)\n\t  avg_val += *it;\n\tavg_val /= num_set_i;\n\t// bracket avg_val between [s_left,s_right]\n\ts_left = L[offset]; s_right = U[offset];\n\tfor(it = set_i.begin(); it != ie; ++it) {\n\t  set_val = *it;\n\t  if (set_val > avg_val) {      // update nearest neighbor to right\n\t    if (set_val < s_right)\n\t      s_right = set_val;\n\t  }\n\t  else if (set_val < avg_val) { // update nearest neighbor to left\n\t    if (set_val > s_left)\n\t      s_left = set_val;\n\t  }\n\t  else { // set_val equals avg_val\n\t    s_left = s_right = set_val;\n\t    break;\n\t  }\n\t}\n\tV[offset] = (s_right - avg_val < avg_val - s_left) ? s_right : s_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DRset(size_t num_v, RealRealMapArray& vals_probs, RealVector& IP,\n\t   RealVector& L, RealVector& U, RealVector& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  RRMCIter ite, it;\n  size_t i, j, num_vp_j, num_IP = IP.length();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    RealRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = V[i] = 0.;\n      V[i] = (num_IP) ? IP[j] : 0.;\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;      // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j];\n      else if (init_V) {\n\t// select the initial value to be closest set value to avg_val\n\tfor(avg_val = 0., ++ite; it != ite; ++it)\n\t  avg_val += it->first;\n\tavg_val /= num_vp_j;\n\t// bracket avg_val between [s_left,s_right]\n\ts_left = L[i]; s_right = U[i];\n\tfor(it = vp_j.begin(); it != ite; ++it) {\n\t  set_val = it->first;\n\t  if (set_val > avg_val) {      // update nearest neighbor to right\n\t    if (set_val < s_right)\n\t      s_right = set_val;\n\t  }\n\t  else if (set_val < avg_val) { // update nearest neighbor to left\n\t    if (set_val > s_left)\n\t      s_left = set_val;\n\t  }\n\t  else { // set_val equals avg_val\n\t    s_left = s_right = set_val;\n\t    break;\n\t  }\n\t}\n\tV[i] = (s_right - avg_val < avg_val - s_left) ? s_right : s_left;\n      }\n    }\n  }\n}\n\nstatic void \nVgen_DSset(size_t num_v, StringRealMapArray& vals_probs, StringArray& IP,\n\t   StringArray& L, StringArray& U, StringArray& V,\n\t   bool aggregate_LUV = false, size_t offset = 0)\n{\n  Real avg_val, set_val, s_left, s_right;\n  SRMCIter ite, it;\n  size_t i, j, num_vp_j, num_IP = IP.size();\n\n  bool init_V = check_LUV_size(num_v, L, U, V, aggregate_LUV, offset);\n\n  for(i = offset, j = 0; j < num_v; ++i, ++j) {\n    StringRealMap& vp_j = vals_probs[j];\n    it = vp_j.begin(); ite = vp_j.end(); num_vp_j = vp_j.size();\n    if (num_vp_j == 0) { // should not occur\n      L[i] = U[i] = V[i] = \"\";\n      V[i] = (num_IP) ? IP[j] : \"\";\n    }\n    else if (num_vp_j == 1) {\n      L[i] = U[i] = it->first;\n      V[i] = (num_IP) ? IP[j] : it->first;\n    }\n    else {\n      L[i] = it->first;     // lower bound is first value\n      U[i] = (--ite)->first; // upper bound is final value\n      if (num_IP) V[i] = IP[j];\n      else if (init_V) {\n\tsize_t mid_index = 0;\n\t// initial value is at middle index or the one directly below\n\tif ( (num_vp_j % 2 == 0) )\n\t  // initial value is to the left of middle\n\t  mid_index = num_vp_j / 2 - 1;\n\telse \n\t  mid_index = (num_vp_j + 1) / 2 - 1;\n\tstd::advance(it, mid_index);\n\tV[i] = it->first;\n      }\n    }\n  }\n}\n\nstatic void \nVchk_DiscreteDesSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_integer\";\n  Vchk_DIset(dv->numDiscreteDesSetIntVars, kind, vi->nddsi, vi->ddsi,\n\t     dv->discreteDesignSetInt, dv->discreteDesignSetIntVars);\n  if(vi->ddsia) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetIntVars; i++)\n      num_e.push_back(dv->discreteDesignSetInt[i].size());\n      Vchk_Adjacency(dv->numDiscreteDesSetIntVars, kind, num_e, *vi->ddsia,\n\t\t      dv->discreteDesignSetIntAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteDesSetIntVars, dv->discreteDesignSetInt,\n\t     dv->discreteDesignSetIntLowerBnds,\n\t     dv->discreteDesignSetIntUpperBnds,\n\t     dv->discreteDesignSetIntVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteDesSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_string\";\n  Vchk_DSset(dv->numDiscreteDesSetStrVars, kind, vi->nddss, vi->ddss,\n\t     dv->discreteDesignSetStr, dv->discreteDesignSetStrVars);\n  if(vi->ddssa) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetStrVars; i++)\n\t    num_e.push_back(dv->discreteDesignSetStr[i].size());\n    Vchk_Adjacency(dv->numDiscreteDesSetStrVars, kind, num_e, *vi->ddssa,\n\t\t    dv->discreteDesignSetStrAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteDesSetStrVars, dv->discreteDesignSetStr,\n\t     dv->discreteDesignSetStrLowerBnds,\n\t     dv->discreteDesignSetStrUpperBnds,\n\t     dv->discreteDesignSetStrVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteDesSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_design_set_real\";\n  Vchk_DRset(dv->numDiscreteDesSetRealVars, kind, vi->nddsr, vi->ddsr,\n\t     dv->discreteDesignSetReal, dv->discreteDesignSetRealVars);\n  if(vi->ddsra) {\n    IntArray num_e;\n    for(size_t i = 0; i < dv->numDiscreteDesSetRealVars; i++)\n      num_e.push_back(dv->discreteDesignSetReal[i].size());\n    Vchk_Adjacency(dv->numDiscreteDesSetRealVars, kind, num_e,\n\t\t    *vi->ddsra, dv->discreteDesignSetRealAdj);\n  }\n}\n\nstatic void Vgen_DiscreteDesSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteDesSetRealVars, dv->discreteDesignSetReal,\n\t     dv->discreteDesignSetRealLowerBnds,\n\t     dv->discreteDesignSetRealUpperBnds,\n\t     dv->discreteDesignSetRealVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteUncSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_integer\";\n  Vchk_DIset(dv->numDiscreteUncSetIntVars, kind, vi->ndusi, vi->dusi, vi->DSIp,\n\t     dv->discreteUncSetIntValuesProbs, dv->discreteUncSetIntVars);\n}\n\nstatic void Vgen_DiscreteUncSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteUncSetIntVars, dv->discreteUncSetIntValuesProbs,\n\t     dv->discreteUncSetIntVars, dv->discreteIntEpistemicUncLowerBnds,\n\t     dv->discreteIntEpistemicUncUpperBnds,\n\t     dv->discreteIntEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetIntVars.length()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteUncSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_string\";\n  Vchk_DSset(dv->numDiscreteUncSetStrVars, kind, vi->nduss, vi->duss, vi->DSSp,\n\t     dv->discreteUncSetStrValuesProbs, dv->discreteUncSetStrVars);\n}\n\nstatic void Vgen_DiscreteUncSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteUncSetStrVars, dv->discreteUncSetStrValuesProbs,\n\t     dv->discreteUncSetStrVars, dv->discreteStrEpistemicUncLowerBnds,\n\t     dv->discreteStrEpistemicUncUpperBnds,\n\t     dv->discreteStrEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetStrVars.size()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteUncSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_uncertain_set_real\";\n  Vchk_DRset(dv->numDiscreteUncSetRealVars, kind, vi->ndusr, vi->dusr, vi->DSRp,\n\t     dv->discreteUncSetRealValuesProbs, dv->discreteUncSetRealVars);\n}\n\nstatic void Vgen_DiscreteUncSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteUncSetRealVars, dv->discreteUncSetRealValuesProbs,\n\t     dv->discreteUncSetRealVars, dv->discreteRealEpistemicUncLowerBnds,\n\t     dv->discreteRealEpistemicUncUpperBnds,\n\t     dv->discreteRealEpistemicUncVars, true, offset);\n  if (dv->discreteUncSetRealVars.length()) dv->uncertainVarsInitPt = true;\n}\n\nstatic void \nVchk_DiscreteStateSetInt(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_integer\";\n  Vchk_DIset(dv->numDiscreteStateSetIntVars, kind, vi->ndssi, vi->dssi, \n\t     dv->discreteStateSetInt, dv->discreteStateSetIntVars);\n}\n\nstatic void Vgen_DiscreteStateSetInt(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DIset(dv->numDiscreteStateSetIntVars, dv->discreteStateSetInt,\n\t     dv->discreteStateSetIntLowerBnds,\n\t     dv->discreteStateSetIntUpperBnds,\n\t     dv->discreteStateSetIntVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteStateSetStr(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_string\";\n  Vchk_DSset(dv->numDiscreteStateSetStrVars, kind, vi->ndsss, vi->dsss, \n\t     dv->discreteStateSetStr, dv->discreteStateSetStrVars);\n}\n\nstatic void Vgen_DiscreteStateSetStr(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DSset(dv->numDiscreteStateSetStrVars, dv->discreteStateSetStr,\n\t     dv->discreteStateSetStrLowerBnds,\n\t     dv->discreteStateSetStrUpperBnds,\n\t     dv->discreteStateSetStrVars); // no offset, not aggregate L/U/V\n}\n\nstatic void \nVchk_DiscreteStateSetReal(DataVariablesRep *dv, size_t offset, Var_Info *vi)\n{\n  static char kind[] = \"discrete_state_set_real\";\n  Vchk_DRset(dv->numDiscreteStateSetRealVars, kind, vi->ndssr, vi->dssr,\n\t     dv->discreteStateSetReal, dv->discreteStateSetRealVars);\n}\n\nstatic void Vgen_DiscreteStateSetReal(DataVariablesRep *dv, size_t offset)\n{\n  Vgen_DRset(dv->numDiscreteStateSetRealVars, dv->discreteStateSetReal,\n\t     dv->discreteStateSetRealLowerBnds,\n\t     dv->discreteStateSetRealUpperBnds,\n\t     dv->discreteStateSetRealVars); // no offset, not aggregate L/U/V\n}\n\nstatic const char *\nVar_Name(StringArray *sa, char *buf, size_t i)\n{\n  if (sa)\n    return (*sa)[i].data();\n  std::sprintf(buf,\"%lu\", (UL)(i+1));\n  return (const char*)buf;\n}\n\n/// For real-valued variables: verify lengths of bounds and initial\n/// point, validate bounds and adjust initial point to bounds\nstatic void Var_RealBoundIPCheck(DataVariablesRep *dv, Var_rcheck *b)\n{\n  RealVector *L, *U, *V;\n  StringArray *sa;\n  char namebuf[32];\n  int i, n, ndflt; // length() values here are int rather than size_t\n\n  if ((n = dv->*b->n) == 0)\n    return;\n  ndflt = -1;\n  if (b->L) {\n    ndflt = 0;\n    L = &(dv->*b->L);\n    if (L->length() == 0)\n      ++ndflt;\n    else if (L->length() != n) {\n      Squawk(\"%s_lower_bounds needs %lu elements, not %lu\",\n\t     b->name, (UL)n, (UL)L->length());\n      return;\n    }\n    U = &(dv->*b->U);\n    if (U->length() == 0)\n      ++ndflt;\n    else if (U->length() != n) {\n      Squawk(\"%s_upper_bounds needs %lu elements, not %lu\",\n\t     b->name, (UL)n, (UL)U->length());\n      return;\n    }\n  }\n  sa = 0;\n  if (b->Lbl) {\n    sa = &(dv->*b->Lbl);\n    if (sa->size() == 0)\n      sa = 0;\n  }\n  if (ndflt == 0)\n    for(i = 0; i < n; i++) {\n      if ((*L)[i] > (*U)[i])\n\tSquawk(\"lower bound for %s variable %s exceeds upper bound\",\n\t       b->name, Var_Name(sa,namebuf,i));\n    }\n  if (b->V == 0)\n    return;\n  V = &(dv->*b->V);\n  if (V->length() == 0)\n    return;\n  if (V->length() != n) {\n    Squawk(\"initial point for %s needs %lu elements, not %lu\",\n\t   b->name, (UL)n, (UL)V->length());\n    return;\n  }\n  if (L->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] < (*L)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its lower bound\",\n\t     b->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*L)[i];\n      }\n  }\n  if (U->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] > (*U)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its upper bound\",\n\t     b->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*U)[i];\n      }\n  }\n}\n\n/// For integer-valued variables: verify lengths of bounds and initial\n/// point, validate bounds and initial point against bounds\nstatic void Var_IntBoundIPCheck(DataVariablesRep *dv, Var_icheck *ib)\n{\n  IntVector *L, *U, *V;\n  StringArray *sa;\n  char namebuf[32];\n  int i, n, ndflt; // length() values here are int rather than size_t\n\n  if ((n = dv->*ib->n) == 0)\n    return;\n  L = &(dv->*ib->L);\n  ndflt = 0;\n  if (L->length() == 0)\n    ++ndflt;\n  else if (L->length() != n) {\n    Squawk(\"%s_lower_bounds needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)L->length());\n    return;\n  }\n  U = &(dv->*ib->U);\n  if (U->length() == 0)\n    ++ndflt;\n  else if (U->length() != n) {\n    Squawk(\"%s_upper_bounds needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)L->length());\n    return;\n  }\n  sa = 0;\n  if (ib->Lbl) {\n    sa = &(dv->*ib->Lbl);\n    if (sa->size() == 0)\n      sa = 0;\n  }\n  if (ndflt == 0)\n    for(i = 0; i < n; i++) {\n      if ((*L)[i] > (*U)[i])\n\tSquawk(\"lower bound for %s variable %s exceeds upper bound\",\n\t       ib->name, Var_Name(sa,namebuf,i));\n    }\n  if (ib->V == 0)\n    return;\t// won't happen for discrete variables\n  V = &(dv->*ib->V);\n  if (V->length() == 0)\n    return;\n  if (V->length() != n) {\n    Squawk(\"initial point for %s needs %lu elements, not %lu\",\n\t   ib->name, (UL)n, (UL)V->length());\n    return;\n  }\n  if (L->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] < (*L)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its lower bound\",\n\t     ib->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*L)[i];\n      }\n  }\n  if (U->length() > 0) {\n    for(i = 0; i < n; i++)\n      if ((*V)[i] > (*U)[i]) {\n\tWarn(\"Setting initial_value for %s variable %s to its upper bound\",\n\t     ib->name, Var_Name(sa,namebuf,i));\n\t(*V)[i] = (*U)[i];\n      }\n  }\n}\n\n\n// setup the Vchk functions for each of the uncertain variable\n// contiguous containers, and for discrete sets\n#define VarLabelInfo(a,b)     { #a, #b, &DataVariablesRep::num##b##Vars, Vchk_##b }\nstatic Var_uinfo CAUVLbl[CAUVar_Nkinds] = {\n  VarLabelInfo(nuv_, NormalUnc),\n  VarLabelInfo(lnuv_, LognormalUnc),\n  VarLabelInfo(uuv_, UniformUnc),\n  VarLabelInfo(luuv_, LoguniformUnc),\n  VarLabelInfo(tuv_, TriangularUnc),\n  VarLabelInfo(euv_, ExponentialUnc),\n  VarLabelInfo(beuv_, BetaUnc),\n  VarLabelInfo(gauv_, GammaUnc),\n  VarLabelInfo(guuv_, GumbelUnc),\n  VarLabelInfo(fuv_, FrechetUnc),\n  VarLabelInfo(wuv_, WeibullUnc),\n  VarLabelInfo(hbuv_, HistogramBinUnc)\n};\nstatic Var_uinfo DAUIVLbl[DAUIVar_Nkinds] = {\n  VarLabelInfo(puv_, PoissonUnc),\n  VarLabelInfo(biuv_, BinomialUnc),\n  VarLabelInfo(nbuv_, NegBinomialUnc),\n  VarLabelInfo(geuv_, GeometricUnc),\n  VarLabelInfo(hguv_, HyperGeomUnc),\n  VarLabelInfo(hpiuv_, HistogramPtIntUnc)\n};\nstatic Var_uinfo DAUSVLbl[DAUSVar_Nkinds] = {\n  VarLabelInfo(hpsuv_, HistogramPtStrUnc)\n};\nstatic Var_uinfo DAURVLbl[DAURVar_Nkinds] = {\n  VarLabelInfo(hpruv_, HistogramPtRealUnc)\n};\nstatic Var_uinfo CEUVLbl[CEUVar_Nkinds] = {\n  VarLabelInfo(ciuv_, ContinuousIntervalUnc)\n};\nstatic Var_uinfo DEUIVLbl[DEUIVar_Nkinds] = {\n  VarLabelInfo(diuv_, DiscreteIntervalUnc),\n  VarLabelInfo(dusiv_, DiscreteUncSetInt)\n};\nstatic Var_uinfo DEUSVLbl[DEUSVar_Nkinds] = {\n  VarLabelInfo(dussv_, DiscreteUncSetStr)\n};\nstatic Var_uinfo DEURVLbl[DEURVar_Nkinds] = {\n  VarLabelInfo(dusrv_, DiscreteUncSetReal)\n};\nstatic Var_uinfo DiscSetLbl[DiscSetVar_Nkinds] = {\n  VarLabelInfo(ddsiv_, DiscreteDesSetInt),\n  VarLabelInfo(ddssv_, DiscreteDesSetStr),\n  VarLabelInfo(ddsrv_, DiscreteDesSetReal),\n  VarLabelInfo(dssiv_, DiscreteStateSetInt),\n  VarLabelInfo(dsssv_, DiscreteStateSetStr),\n  VarLabelInfo(dssrv_, DiscreteStateSetReal)\n};\n#undef VarLabelInfo\n\nvoid NIDRProblemDescDB::\nvar_stop(const char *keyname, Values *val, void **g, void *v)\n{\n  static const char *mr_scaletypes[] = { \"auto\", \"none\", 0 };\n\n  Var_Info *vi = *(Var_Info**)g;\n  DataVariablesRep *dv = vi->dv;\n\n  scale_chk(dv->continuousDesignScaleTypes, dv->continuousDesignScales,\n\t    \"cdv\", aln_scaletypes);\n  scale_chk(dv->linearIneqScaleTypes, dv->linearIneqScales,\n\t    \"linear_inequality\", mr_scaletypes);\n  scale_chk(dv->linearEqScaleTypes, dv->linearEqScales,\n\t    \"linear_equality\", mr_scaletypes);\n\n  pDDBInstance->VIL.push_back(vi);\n  pDDBInstance->dataVariablesList.push_back(*vi->dv_handle);\n  delete vi->dv_handle;\n}\n\nstruct VarLabelChk {\n  size_t DataVariablesRep::* n;\n  StringArray DataVariablesRep::* sa;\n  const char *stub;\n  const char *name;\n};\n\n\n// For validation to be performed in check_variables_node(), each\n// variable type must be included in at least one of\n// DesignAndStateLabelsCheck, LUncertainInt, VLUncertainStr,\n// VLUncertainReal, or DiscSetLbl.  Design and state discrete sets are\n// currently in both DesignAndStateLabelsCheck (check lengths) and\n// DiscSetLbl (duplicates and STL population)\n\n#define AVI &DataVariablesRep::\n/// Variables label array designations for design and state.  All\n/// non-uncertain variables need to be in this array.  Used in\n/// check_variables_node to check lengths and make_variable_defaults\n/// to build labels.\nstatic VarLabelChk DesignAndStateLabelsCheck[] = {\n  { AVI numContinuousDesVars, AVI continuousDesignLabels, \"cdv_\", \"cdv_descriptors\" },\n  { AVI numDiscreteDesRangeVars, AVI discreteDesignRangeLabels, \"ddriv_\", \"ddriv_descriptors\" },\n  { AVI numDiscreteDesSetIntVars, AVI discreteDesignSetIntLabels, \"ddsiv_\", \"ddsiv_descriptors\" },\n  { AVI numDiscreteDesSetStrVars, AVI discreteDesignSetStrLabels, \"ddssv_\", \"ddssv_descriptors\" },\n  { AVI numDiscreteDesSetRealVars, AVI discreteDesignSetRealLabels, \"ddsrv_\", \"ddsrv_descriptors\" },\n  { AVI numContinuousStateVars, AVI continuousStateLabels, \"csv_\", \"csv_descriptors\" },\n  { AVI numDiscreteStateRangeVars, AVI discreteStateRangeLabels, \"dsriv_\", \"dsriv_descriptors\" },\n  { AVI numDiscreteStateSetIntVars, AVI discreteStateSetIntLabels, \"dssiv_\", \"dssiv_descriptors\" },\n  { AVI numDiscreteStateSetStrVars, AVI discreteStateSetStrLabels, \"dsssv_\", \"dsssv_descriptors\" },\n  { AVI numDiscreteStateSetRealVars, AVI discreteStateSetRealLabels, \"dssrv_\", \"dssrv_descriptors\" },\n  { AVI numContinuousDesVars, AVI continuousDesignScaleTypes, 0, \"cdv_scale_types\" }\n};\n#undef  AVI\n\n/// structure for validating real uncertain variable labels, bounds, values\nstruct VLreal {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  RealVector DataVariablesRep::* LowerBnds;\n  RealVector DataVariablesRep::* UpperBnds;\n  RealVector DataVariablesRep::* UncVars;\n};\n\n/// structure for validating integer uncertain variable labels, bounds, values\nstruct VLint {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  IntVector DataVariablesRep::* LowerBnds;\n  IntVector DataVariablesRep::* UpperBnds;\n  IntVector DataVariablesRep::* UncVars;\n};\n\n/// structure for validating string uncertain variable labels, bounds, values\nstruct VLstr {\n  int n;\n  VarLabel Var_Info::* VL; // should be \"VarLabel *Var_Info::* VL\"\n  // but g++ is buggy (versions 4.3.1, 4.4.2 anyway)\n  Var_uinfo *vui;\n  StringArray DataVariablesRep::* Labels;\n  StringArray DataVariablesRep::* LowerBnds;\n  StringArray DataVariablesRep::* UpperBnds;\n  StringArray DataVariablesRep::* UncVars;\n};\n\n/// number of real-valued   uncertain contiguous containers\nenum { NUM_UNC_REAL_CONT = 4 };\n/// number of int-valued    uncertain contiguous containers\nenum { NUM_UNC_INT_CONT = 2 }; \n/// number of string-valued uncertain contiguous containers\nenum { NUM_UNC_STR_CONT = 2 }; \n\n#define AVI (VarLabel Var_Info::*) &Var_Info::\t// cast to bypass g++ bug\n#define DVR &DataVariablesRep::\n\n/// Variables labels/bounds/values check array for real-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., CAUVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLreal VLUncertainReal[NUM_UNC_REAL_CONT] = {\n {CAUVar_Nkinds,  AVI CAUv,  CAUVLbl,\n\tDVR continuousAleatoryUncLabels,\n\tDVR continuousAleatoryUncLowerBnds,\n\tDVR continuousAleatoryUncUpperBnds,\n\tDVR continuousAleatoryUncVars},\n {CEUVar_Nkinds,  AVI CEUv,  CEUVLbl,\n\tDVR continuousEpistemicUncLabels,\n\tDVR continuousEpistemicUncLowerBnds,\n\tDVR continuousEpistemicUncUpperBnds,\n\tDVR continuousEpistemicUncVars},\n {DAURVar_Nkinds, AVI DAURv, DAURVLbl,\n\tDVR discreteRealAleatoryUncLabels,\n\tDVR discreteRealAleatoryUncLowerBnds,\n\tDVR discreteRealAleatoryUncUpperBnds,\n        DVR discreteRealAleatoryUncVars},\n {DEURVar_Nkinds, AVI DEURv, DEURVLbl,\n\tDVR discreteRealEpistemicUncLabels,\n\tDVR discreteRealEpistemicUncLowerBnds,\n\tDVR discreteRealEpistemicUncUpperBnds,\n\tDVR discreteRealEpistemicUncVars}};\n\n/// Variables labels/bounds/values check array for integer-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., DAUIVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLint VLUncertainInt[NUM_UNC_INT_CONT] = {\n {DAUIVar_Nkinds, AVI DAUIv, DAUIVLbl,\n\tDVR discreteIntAleatoryUncLabels,\n        DVR discreteIntAleatoryUncLowerBnds,\n        DVR discreteIntAleatoryUncUpperBnds,\n        DVR discreteIntAleatoryUncVars},\n {DEUIVar_Nkinds, AVI DEUIv, DEUIVLbl,\n\tDVR discreteIntEpistemicUncLabels,\n\tDVR discreteIntEpistemicUncLowerBnds,\n\tDVR discreteIntEpistemicUncUpperBnds,\n\tDVR discreteIntEpistemicUncVars}};\n\n/// Variables labels/bounds/values check array for string-valued\n/// uncertain variables; one array entry per contiguous container.\n/// These associate the individual variables given by, e.g., DAUSVLbl,\n/// with the contiguous container in which they are stored.\nstatic VLstr VLUncertainStr[NUM_UNC_STR_CONT] = {\n {DAUSVar_Nkinds, AVI DAUSv, DAUSVLbl,\n\tDVR discreteStrAleatoryUncLabels,\n\tDVR discreteStrAleatoryUncLowerBnds,\n\tDVR discreteStrAleatoryUncUpperBnds,\n        DVR discreteStrAleatoryUncVars},\n {DEUSVar_Nkinds, AVI DEUSv, DEUSVLbl,\n\tDVR discreteStrEpistemicUncLabels,\n\tDVR discreteStrEpistemicUncLowerBnds,\n\tDVR discreteStrEpistemicUncUpperBnds,\n\tDVR discreteStrEpistemicUncVars}};\n\n//#undef RDVR\n#undef\tDVR\n#undef  AVI\n\n/// which uncertain real check array containers are aleatory (true = 1)\nstatic int VLR_aleatory[NUM_UNC_REAL_CONT] = { 1, 0, 1, 0 };\n/// which uncertain integer check array containers are aleatory (true = 1)\nstatic int VLI_aleatory[NUM_UNC_INT_CONT] = { 1, 0 };\n/// which uncertain string check array containers are aleatory (true = 1)\nstatic int VLS_aleatory[NUM_UNC_STR_CONT] = { 1, 0 };\n\n\n/// Generate check data for variables with just name, size, and a\n/// generator function\n#define Vchk_3(x,y) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y}\n\n/// Generate check data for variables additionally with lower and\n/// upper bounds.  Some compilers in debug mode (MSVC) don't\n/// initialize the trailing two entries to NULL, so be explicit:\n#define Vchk_5(x,y,z) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y,&DataVariablesRep::z##LowerBnds,&DataVariablesRep::z##UpperBnds,NULL,NULL}\n\n/// Generate check data for variables additionally with initial point\n/// and labels\n#define Vchk_7(x,y,z) {#x,&DataVariablesRep::num##y##Vars,Vgen_##y,&DataVariablesRep::z##LowerBnds,&DataVariablesRep::z##UpperBnds,&DataVariablesRep::z##Vars,&DataVariablesRep::z##Labels}\n\n// Trailing pointers in these initialization lists will be NULL. From C++ 2003:\n//   \"Objects with static storage shall be zero-initialized before any other\n//    initialization takes place.\"\n\n// These are used within make_variable_defaults(): Vgen_##y is applied\n// to generate bounds, adjust initial values\nstatic Var_check\n  var_mp_check_cv[] = {\n\tVchk_3(continuous_design,ContinuousDes),\n\tVchk_3(continuous_state,ContinuousState) },\n  var_mp_check_dset[] = {\n\tVchk_3(discrete_design_set_integer,DiscreteDesSetInt),\n\tVchk_3(discrete_design_set_string,DiscreteDesSetStr),\n\tVchk_3(discrete_design_set_real,DiscreteDesSetReal),\n\tVchk_3(discrete_state_set_integer,DiscreteStateSetInt),\n\tVchk_3(discrete_state_set_string,DiscreteStateSetStr),\n\tVchk_3(discrete_state_set_real,DiscreteStateSetReal) },\n  var_mp_check_cau[] = {\n\tVchk_3(normal_uncertain,NormalUnc),\n\tVchk_3(lognormal_uncertain,LognormalUnc),\n\tVchk_3(uniform_uncertain,UniformUnc),\n\tVchk_3(loguniform_uncertain,LoguniformUnc),\n\tVchk_3(triangular_uncertain,TriangularUnc),\n\tVchk_3(exponential_uncertain,ExponentialUnc),\n\tVchk_3(beta_uncertain,BetaUnc),\n\tVchk_3(gamma_uncertain,GammaUnc),\n\tVchk_3(gumbel_uncertain,GumbelUnc),\n\tVchk_3(frechet_uncertain,FrechetUnc),\n\tVchk_3(weibull_uncertain,WeibullUnc),\n\tVchk_3(histogram_bin_uncertain,HistogramBinUnc) },\n  var_mp_check_daui[] = {\n\tVchk_3(poisson_uncertain,PoissonUnc),\n\tVchk_3(binomial_uncertain,BinomialUnc),\n\tVchk_3(negative_binomial_uncertain,NegBinomialUnc),\n\tVchk_3(geometric_uncertain,GeometricUnc),\n\tVchk_3(hypergeometric_uncertain,HyperGeomUnc),\n\tVchk_3(histogram_point_int_uncertain,HistogramPtIntUnc) },\n  var_mp_check_daus[] = {\n\tVchk_3(histogram_point_str_uncertain,HistogramPtStrUnc) },\n  var_mp_check_daur[] = {\n\tVchk_3(histogram_point_real_uncertain,HistogramPtRealUnc) },\n  var_mp_check_ceu[] = {\n\tVchk_3(continuous_interval_uncertain,ContinuousIntervalUnc) },\n  var_mp_check_deui[] = {\n\tVchk_3(discrete_interval_uncertain,DiscreteIntervalUnc),\n\tVchk_3(discrete_uncertain_set_integer,DiscreteUncSetInt) },\n  var_mp_check_deus[] = {\n        Vchk_3(discrete_uncertain_set_string,DiscreteUncSetStr) },\n  var_mp_check_deur[] = {\n\tVchk_3(discrete_uncertain_set_real,DiscreteUncSetReal) };\n\n/// This is used within check_variables_node(): Var_RealBoundIPCheck()\n/// is applied to validate bounds and initial points\nstatic Var_rcheck\n  var_mp_cbound[] = {\n\tVchk_7(continuous_design,ContinuousDes,continuousDesign),\n\tVchk_7(continuous_state,ContinuousState,continuousState),\n\t// BMA: I believe these should these be promoted to Vchk_7,\n\t// but not easy to do since their labels are stored in an\n\t// aggregated array instead of individually\n\tVchk_5(normal_uncertain,NormalUnc,normalUnc),\n\tVchk_5(lognormal_uncertain,LognormalUnc,lognormalUnc),\n\tVchk_5(uniform_uncertain,UniformUnc,uniformUnc),\n\tVchk_5(loguniform_uncertain,LoguniformUnc,loguniformUnc),\n\tVchk_5(triangular_uncertain,TriangularUnc,triangularUnc),\n\tVchk_5(beta_uncertain,BetaUnc,betaUnc) };\n// gamma, gumbel, frechet, weibull, histogram_bin don't support bounds\n// from user input, so are omitted here?\n\n/// This is used in check_variables_node(): Var_IntBoundIPCheck() is\n/// applied to validate bounds and initial points, and in\n/// make_variable_defaults(): Vgen_* is called to infer bounds.\nstatic Var_icheck\n  var_mp_drange[] = {\n\tVchk_7(discrete_design_range,DiscreteDesRange,discreteDesignRange),\n\tVchk_7(discrete_state_range,DiscreteStateRange,discreteStateRange) };\n\n// would be used to check initial point, but those are covered in DiscSetLbl\n// static Var_scheck\n// var_mp_sbound[] = {\n//   Vchk_7(discrete_design_set_string,DiscreteDesSetStr,discreteDesignSetStr) };\n\n#undef Vchk_7\n#undef Vchk_5\n#undef Vchk_3\n\n\n/** Size arrays for contiguous storage of aggregated uncertain types.\n    For each variable type, call Vgen_* to generate inferred bounds\n    and initial point, repairing initial if needed. */\nvoid NIDRProblemDescDB::\nmake_variable_defaults(std::list<DataVariables>* dvl)\n{\n  DataVariablesRep *dv;\n  IntVector *IL, *IU, *IV;\n  StringArray *SL, *SU, *SV;\n  RealVector *L, *U, *V;\n  StringArray *sa;\n  VLreal *vlr;\n  VLint  *vli;\n  VLstr  *vls;\n  VarLabel *vl;\n  VarLabelChk *vlc, *vlce;\n  Var_uinfo *vui, *vuie;\n  char buf[32];\n  size_t i, j, k, n, nu, nursave[NUM_UNC_REAL_CONT], nuisave[NUM_UNC_INT_CONT], \n    nussave[NUM_UNC_STR_CONT];\n  static const char Inconsistent_bounds[] =\n    \"Inconsistent bounds on %s uncertain variables\";\n\n  /// size the aggregate arrays for uncertain (design and state are\n  /// stored separately\n  std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n  for(; It != Ite; ++It) {\n    dv = It->dataVarsRep;\n    // size the aggregate labels, bounds, values arrays for\n    // real-valued uncertain\n    for(k = 0; k < NUM_UNC_REAL_CONT; ++k) {\n      vlr = &VLUncertainReal[k];\n      vui = vlr->vui;\n      vuie = vui + vlr->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nursave[k] = nu;\n      if (!nu)\n\tcontinue;\n      L = &(dv->*vlr->LowerBnds);\n      U = &(dv->*vlr->UpperBnds);\n      V = &(dv->*vlr->UncVars);\n      L->sizeUninitialized(nu);\n      U->sizeUninitialized(nu);\n      V->sizeUninitialized(nu);\n    }\n    // size the aggregate labels, bounds, values arrays for\n    // integer-valued uncertain\n    for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n      vli = &VLUncertainInt[k];\n      vui = vli->vui;\n      vuie = vui + vli->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nuisave[k] = nu;\n      if (!nu)\n\tcontinue;\n      IL = &(dv->*vli->LowerBnds);\n      IU = &(dv->*vli->UpperBnds);\n      IV = &(dv->*vli->UncVars);\n      IL->sizeUninitialized(nu);\n      IU->sizeUninitialized(nu);\n      IV->sizeUninitialized(nu);\n    }\n    // size the aggregate labels, bounds, values arrays for\n    // string-valued uncertain\n    for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n      vls = &VLUncertainStr[k];\n      vui = vls->vui;\n      vuie = vui + vls->n;\n      for(nu = 0; vui < vuie; ++vui)\n\tnu += dv->*vui->n;\n      nussave[k] = nu;\n      if (!nu)\n\tcontinue;\n      SL = &(dv->*vls->LowerBnds);\n      SU = &(dv->*vls->UpperBnds);\n      SV = &(dv->*vls->UncVars);\n      SL->resize(nu);\n      SU->resize(nu);\n      SV->resize(nu);\n    }\n\n    // inferred bound generation for continuous variable types;\n    // populates the individual (design/state) or aggregate\n    // (uncertain) arrays of bounds and values by applying Vgen_##y\n\n    // loop over cdv/csv\n    Var_check *c, *ce;\n    // the offset into the aggregated aleatory or epistemic arrays\n    size_t offset = 0; \n    for(c=var_mp_check_cv, ce = c + Numberof(var_mp_check_cv); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t(*c->vgen)(dv, offset); // offset not used\n    // loop over nuv/lnuv/uuv/luuv/truv/euv/buv/gauv/guuv/fuv/wuv/hbuv\n    // working with continuousAleatoryUnc*\n    for(c=var_mp_check_cau, ce=c + Numberof(var_mp_check_cau); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // continuous epistemic uncertain\n    offset = 0; // reset for combined epistemic arrays\n    for(c=var_mp_check_ceu, ce=c + Numberof(var_mp_check_ceu); c < ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n\n    // inferred bound generation for discrete variable types;\n    // populates the individual (design/state) or aggregate\n    // (uncertain) arrays of bounds and values by applying Vgen_##y\n\n    // discrete design,state ranges\n    Var_icheck *ic, *ice;\n    offset = 0;\n    for(ic=var_mp_drange, ice=ic + Numberof(var_mp_drange); ic<ice; ++ic)\n      if ((n = dv->*ic->n) > 0)\n\t{ (*ic->vgen)(dv, offset); } // offset not used\n    // discrete int aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteIntAleatoryUnc*\n    for(c=var_mp_check_daui, ce=c + Numberof(var_mp_check_daui); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete string aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteStrAleatoryUnc*\n    offset = 0.;\n    for(c=var_mp_check_daus, ce=c + Numberof(var_mp_check_daus); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete real aleatory uncertain use offset passed into Vgen_*Unc\n    // working with discreteRealAleatoryUnc*\n    offset = 0;\n    for(c=var_mp_check_daur, ce=c + Numberof(var_mp_check_daur); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete int epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteIntEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deui, ce=c + Numberof(var_mp_check_deui); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete string epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteStrEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deus, ce=c + Numberof(var_mp_check_deus); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    // discrete real epistemic uncertain use offset passed into Vgen_*Unc\n    // working with discreteRealEpistemicUnc*\n    offset = 0;\n    for(c=var_mp_check_deur, ce=c + Numberof(var_mp_check_deur); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t{ (*c->vgen)(dv, offset); offset += n; }\n    \n    // check discrete design and state set types\n    // these don't use an offset passed into Vgen_Discrete*Set*\n    offset = 0;\n    for(c=var_mp_check_dset, ce=c + Numberof(var_mp_check_dset); c<ce; ++c)\n      if ((n = dv->*c->n) > 0)\n\t(*c->vgen)(dv, offset); // offset not used\n\n\n    // Validate bounds (again?) for uncertain variables and set\n    // default labels for all types\n\n    // uncertain real: bounds check and label generation\n    for(k = 0; k < NUM_UNC_REAL_CONT; ++k) {\n      nu = nursave[k];\n      if (!nu)\n\tcontinue;\n      vlr = &VLUncertainReal[k];\n      vui = vlr->vui;\n      vuie = vui + vlr->n;\n      L = &(dv->*vlr->LowerBnds);\n      U = &(dv->*vlr->UpperBnds);\n      V = &(dv->*vlr->UncVars);\n      sa = &(dv->*vlr->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vlr->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*L)[i+j] > (*U)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // uncertain integer: bounds check and label generation\n    for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n      nu = nuisave[k];\n      if (!nu)\n\tcontinue;\n      vli = &VLUncertainInt[k];\n      vui = vli->vui;\n      vuie = vui + vli->n;\n      IL = &(dv->*vli->LowerBnds);\n      IU = &(dv->*vli->UpperBnds);\n      IV = &(dv->*vli->UncVars);\n      sa = &(dv->*vli->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vli->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*IL)[i+j] > (*IU)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // uncertain string: bounds check and label generation\n    for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n      nu = nussave[k];\n      if (!nu)\n\tcontinue;\n      vls = &VLUncertainStr[k];\n      vui = vls->vui;\n      vuie = vui + vls->n;\n      SL = &(dv->*vls->LowerBnds);\n      SU = &(dv->*vls->UpperBnds);\n      SV = &(dv->*vls->UncVars);\n      sa = &(dv->*vls->Labels);\n      if (!sa->size())\n\tsa->resize(nu);\n      i = 0;\n      for(vui = vls->vui; vui < vuie; ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tfor(j = 0; j < n; ++j)\n\t  if ((*SL)[i+j] > (*SU)[i+j]) {\n\t    squawk(Inconsistent_bounds, vui->vkind);\n\t    break;\n\t  }\n\tif ((*sa)[i] == \"\")\n\t  for(j = 1; j <= n; ++j) {\n\t    std::sprintf(buf, \"%s%d\", vui->lbl, (int)j);\n\t    (*sa)[i++] = buf;\n\t  }\n\telse\n\t  i += n;\n      }\n    }\n\n    // build labels for all design and state variables if needed\n    for(vlc = DesignAndStateLabelsCheck, vlce = vlc + Numberof(DesignAndStateLabelsCheck); vlc < vlce; ++vlc)\n      if (vlc->stub && (n = dv->*vlc->n)) {\n\tsa = &(dv->*vlc->sa);\n\tif (sa->size() == 0)\n\t  BuildLabels(sa, n, 0, n, vlc->stub);\n      }\n  }\n}\n\nvoid NIDRProblemDescDB::check_variables_node(void *v)\n{\n  IntArray *Ia; IntVector *Iv; RealVector *Rv; RealSymMatrix *Rm;\n  StringArray *sa, *Sa;\n  VLreal *vlr; VLint *vli; VLstr *vls;\n  VarLabel *vl;\n  VarLabelChk *vlc, *vlce;\n  Var_uinfo *vui, *vuie;\n  const char **sp;\n  int havelabels;\n  size_t i, j, k, n, nd, nu, nuk, nutot, nv;\n\n#define AVI &Var_Info::\n  // Used for deallocation of Var_Info temporary data\n  static IntArray   *Var_Info::* Ia_delete[]\n    = { AVI nddsi, AVI nddss, AVI nddsr, AVI nCI, AVI nDI, AVI nhbp, \n\tAVI nhpip, AVI nhpsp, AVI nhprp, AVI ndusi, AVI nduss, AVI ndusr, \n\tAVI ndssi, AVI ndssr };\n  static RealVector *Var_Info::* Rv_delete[]\n    = { AVI ddsr, AVI CIlb, AVI CIub, AVI CIp, AVI DIp,\n\tAVI DSIp, AVI DSSp, AVI DSRp,\n\tAVI dusr, AVI hba, AVI hbo, AVI hbc, \n\tAVI hpic, AVI hpsc, AVI hpra, AVI hprc, \n\tAVI ucm,\n\tAVI dssr };\n  static IntVector *Var_Info::* Iv_delete[]\n    = { AVI ddsi, AVI DIlb, AVI DIub, AVI dusi, AVI dssi };\n  static StringArray *Var_Info::* Sa_delete[]\n    = { AVI ddss, AVI duss, AVI dsss };\n#undef AVI\n\n  Var_Info *vi = (Var_Info*)v;\n  DataVariablesRep *dv = vi->dv;\n\n  // check label lengths for design and state variables, if present\n  nv = 0;\n  for(vlc = DesignAndStateLabelsCheck, vlce = vlc + Numberof(DesignAndStateLabelsCheck); \n      vlc < vlce; ++vlc)\n    if ((n = dv->*vlc->n)) {\n      if (vlc->stub)\n\tnv += n;\n      sa = &(dv->*vlc->sa);\n      if ((nu = sa->size())) {\n\tif (nu != n) {\n\t  if (nu == 1 && !vlc->stub)\n\t    continue;\n\t  squawk(\"Found %lu rather than %lu %s values\",\n\t\t (UL)nu, (UL)n, vlc->name);\n\t}\n      }\n    }\n\n  // Now check uncertain variables.  Calls the Vchk_* functions (e.g.,\n  // Vchk_NormalUnc) for each variable type, which for simple\n  // uncertain variables check lengths, but for histograms and\n  // intervals, translate the data into arrays of maps.\n\n  // uncertain real\n  for(k = nu = nutot = 0; k < NUM_UNC_REAL_CONT; ++k) {\n    vlr = &VLUncertainReal[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vlr->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vlr->vui;\n    for(vuie = vui + vlr->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLR_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vlr->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vlr->VL);\n      for(vui = vlr->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain integer\n  for(k = 0; k < NUM_UNC_INT_CONT; ++k) {\n    vli = &VLUncertainInt[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vli->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vli->vui;\n    for(vuie = vui + vli->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLI_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vli->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vli->VL);\n      for(vui = vli->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain string\n  for(k = 0; k < NUM_UNC_STR_CONT; ++k) {\n    vls = &VLUncertainStr[k];\n    havelabels = 0;\n    nuk = 0;\n    vl = &(vi->*vls->VL);\t// \"&(...)\" to bypass a g++ bug\n    vui = vls->vui;\n    for(vuie = vui + vls->n; vui < vuie; ++vl, ++vui) {\n      nuk += dv->*vui->n;\n      if (vl->s)\n\t++havelabels;\n    }\n    if (nuk > 0) {\n      nutot += nuk;\n      if (VLS_aleatory[k])\n\tnu += nuk;\n      if (havelabels)\n\t(sa = &(dv->*vls->Labels))->resize(nuk);\n      i = 0;\n      vl = &(vi->*vls->VL);\n      for(vui = vls->vui; vui < vuie; ++vl, ++vui) {\n\tif ((n = dv->*vui->n) == 0)\n\t  continue;\n\tvui->vchk(dv,i,vi);\n\tif ((sp = vl->s)) {\n\t  if (vl->n != n)\n\t    squawk(\"Expected %d %s_descriptors, but got %d\",\n\t\t   n, vui->lbl, vl->n);\n\t  else\n\t    for(j = 0; j < n; ++i, ++j)\n\t      (*sa)[i] = sp[j];\n\t  free(sp);\n\t}\n\telse\n\t  i += n;\n      }\n    }\n  }\n\n  // uncertain_correlation_matrix\n  if ((Rv = vi->ucm)) {\n    n = Rv->length();\n    if (n != nu*nu) {\n      static char ucmerr[]\n\t= \"Got %lu entries for the uncertain_correlation_matrix\\n\\\n\tbut needed %lu for %lu uncertain variables\";\n      squawk(ucmerr, (UL)n, (UL)nu*nu, (UL)nu);\n    }\n    else {\n      Rm = &dv->uncertainCorrelations;\n      Rm->reshape(nu);\n      for(i = k = 0; i < nu; ++i) {\n\tfor(j = 0; j < nu;)\n\t  (*Rm)(i,j++) = (*Rv)[k++];\n      }\n    }\n  }\n\n  // The above functions don't validate the initial point; those below do\n\n  // Check discrete design and state set variables.  Call Vchk_* for\n  // the discrete design and state set (integer/string/real) types,\n  // e.g, Vchk_DiscreteDesSetInt; these check for duplicates, validate\n  // that initial point is in the set, and populate arrays of maps or\n  // other STL data structures\n  nd = 0;\n  for(vui=DiscSetLbl, vuie=DiscSetLbl+DiscSetVar_Nkinds; vui<vuie; ++vui) {\n    if ((n = dv->*vui->n) > 0) {\n      vui->vchk(dv,0,vi);\n      nd += n;\n    }\n  }\n\n  if (nd + nv + nutot == 0)\n    squawk(\"at least one variable must be specified\");\n\n  // Check bounds and adjust initial points for remaining types.\n\n  // TODO: these don't support explicit bounds, but their initial\n  // point could still be validated here: gamma, gumbel, frechet,\n  // weibull, histogram_bin, poisson, binomial, negative_binomial,\n  // geometric, hypergeometric, histogram_point\n\n  // TODO: continuous and discrete interval, initial point not checked\n  // anywhere?\n\n  // Continuous bound specs: cdv/csv/nuv/lnuv/uuv/luuv/truv/buv\n  Var_rcheck *rc, *rce;\n  for(rc = var_mp_cbound, rce = rc + Numberof(var_mp_cbound); rc < rce; ++rc)\n    Var_RealBoundIPCheck(dv, rc);\n\n  // Discrete bound specs: design,state ranges\n  Var_icheck *ic, *ice;\n  for(ic = var_mp_drange, ice = ic + Numberof(var_mp_drange); ic < ice; ++ic)\n    Var_IntBoundIPCheck(dv, ic);\n  \n\n  // deallocate temporary Var_Info data\n  n = Numberof(Ia_delete);\n  for(i = 0; i < n; i++)\n    if ((Ia = vi->*Ia_delete[i]))\n      delete Ia;\n  n = Numberof(Rv_delete);\n  for(i = 0; i < n; i++)\n    if ((Rv = vi->*Rv_delete[i]))\n      delete Rv;\n  n = Numberof(Iv_delete);\n  for(i = 0; i < n; i++)\n    if ((Iv = vi->*Iv_delete[i]))\n      delete Iv;\n  n = Numberof(Sa_delete);\n  for(i = 0; i < n; i++)\n    if ((Sa = vi->*Sa_delete[i]))\n      delete Sa;\n  delete vi;\n\n  if (nerr)\n    abort_handler(PARSE_ERROR);\n}\n\n\nstatic void flatten_rva(RealVectorArray *rva, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv, *rv_i;\n\n  m = rva->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rva)[i].length();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rv_i = &(*rva)[i];\n    n = rv_i->length();\n    for(j = 0; j < n; ++j, ++k)\n      (*rv)[k] = (*rv_i)[j];\n  }\n}\n\nstatic void flatten_iva(IntVectorArray *iva, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv, *iv_i;\n\n  m = iva->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*iva)[i].length();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    iv_i = &(*iva)[i];\n    n = iv_i->length();\n    for(j = 0; j < n; ++j, ++k)\n      (*iv)[k] = (*iv_i)[j];\n  }\n}\n\nstatic void flatten_rsm(RealSymMatrix *rsm, RealVector **prv)\n{\n  size_t i, j, m, n;\n  RealVector *rv;\n\n  m = rsm->numRows();\n  *prv = rv = new RealVector(m*m, false);\n  for(i = n = 0; i < m; ++i)\n    for(j = 0; j < m; ++j, ++n)\n      (*rv)[n] = (*rsm)(i,j);\n}\n\nstatic void flatten_rsa(RealSetArray *rsa, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealSet *rs_i;\n  RealSet::iterator rs_it, rs_ite;\n\n  m = rsa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rsa)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rs_i = &(*rsa)[i];\n    for(rs_it=rs_i->begin(), rs_ite=rs_i->end(); rs_it!=rs_ite; ++rs_it, ++k)\n      (*rv)[k] = *rs_it;\n  }\n}\n\nstatic void flatten_ssa(StringSetArray *ssa, StringArray **psa)\n{\n  size_t i, j, k, m, n;\n  StringArray *sa;\n  StringSet *ss_i;\n  SSIter ss_it, ss_ite;\n\n  m = ssa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*ssa)[i].size();\n  *psa = sa = new StringArray(n);\n  for(i = k = 0; i < m; ++i) {\n    ss_i = &(*ssa)[i];\n    for(ss_it=ss_i->begin(), ss_ite=ss_i->end(); ss_it!=ss_ite; ++ss_it, ++k)\n      (*sa)[k] = *ss_it;\n  }\n}\n\nstatic void flatten_isa(IntSetArray *isa, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv;\n  IntSet *is_i;\n  IntSet::iterator is_it, is_ite;\n\n  m = isa->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*isa)[i].size();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    is_i = &(*isa)[i];\n    for(is_it=is_i->begin(), is_ite=is_i->end(); is_it!=is_ite; ++is_it, ++k)\n      (*iv)[k] = *is_it;\n  }\n}\n\nstatic void flatten_rrma_keys(RealRealMapArray *rrma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealRealMap *rrm_i;\n  RealRealMap::iterator rrm_it, rrm_ite;\n\n  m = rrma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rrma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rrm_i = &(*rrma)[i];\n    for (rrm_it=rrm_i->begin(), rrm_ite=rrm_i->end();\n\t rrm_it!=rrm_ite; ++rrm_it, ++k)\n      (*rv)[k] = rrm_it->first;\n  }\n}\n\nstatic void flatten_rrma_values(RealRealMapArray *rrma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  RealRealMap *rrm_i;\n  RealRealMap::iterator rrm_it, rrm_ite;\n\n  m = rrma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*rrma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    rrm_i = &(*rrma)[i];\n    for (rrm_it=rrm_i->begin(), rrm_ite=rrm_i->end();\n\t rrm_it!=rrm_ite; ++rrm_it, ++k)\n      (*rv)[k] = rrm_it->second;\n  }\n}\n\nstatic void flatten_irma_keys(IntRealMapArray *irma, IntVector **piv)\n{\n  size_t i, j, k, m, n;\n  IntVector *iv;\n  IntRealMap *irm_i;\n  IntRealMap::iterator irm_it, irm_ite;\n\n  m = irma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*irma)[i].size();\n  *piv = iv = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    irm_i = &(*irma)[i];\n    for (irm_it=irm_i->begin(), irm_ite=irm_i->end();\n\t irm_it!=irm_ite; ++irm_it, ++k)\n      (*iv)[k] = irm_it->first;\n  }\n}\n\nstatic void flatten_irma_values(IntRealMapArray *irma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  IntRealMap *irm_i;\n  IntRealMap::iterator irm_it, irm_ite;\n\n  m = irma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*irma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    irm_i = &(*irma)[i];\n    for (irm_it=irm_i->begin(), irm_ite=irm_i->end();\n\t irm_it!=irm_ite; ++irm_it, ++k)\n      (*rv)[k] = irm_it->second;\n  }\n}\n\nstatic void flatten_srma_keys(StringRealMapArray *srma, StringArray **psa)\n{\n  size_t i, j, k, m, n;\n  StringArray *sa;\n  StringRealMap *srm_i;\n  StringRealMap::iterator srm_it, srm_ite;\n\n  m = srma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*srma)[i].size();\n  *psa = sa = new StringArray(n);\n  for(i = k = 0; i < m; ++i) {\n    srm_i = &(*srma)[i];\n    for (srm_it=srm_i->begin(), srm_ite=srm_i->end();\n\t srm_it!=srm_ite; ++srm_it, ++k)\n      (*sa)[k] = srm_it->first;\n  }\n}\n\nstatic void flatten_srma_values(StringRealMapArray *srma, RealVector **prv)\n{\n  size_t i, j, k, m, n;\n  RealVector *rv;\n  StringRealMap *srm_i;\n  StringRealMap::iterator srm_it, srm_ite;\n\n  m = srma->size();\n  for(i = n = 0; i < m; ++i)\n    n += (*srma)[i].size();\n  *prv = rv = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    srm_i = &(*srma)[i];\n    for (srm_it=srm_i->begin(), srm_ite=srm_i->end();\n\t srm_it!=srm_ite; ++srm_it, ++k)\n      (*rv)[k] = srm_it->second;\n  }\n}\n\n/// Flatten real-valued interval uncertain variable intervals and\n/// probabilities back into separate arrays.\nstatic void flatten_real_intervals(const RealRealPairRealMapArray& rrprma, \n\t\t\t\t   RealVector **probs, \n\t\t\t\t   RealVector **lb, RealVector** ub)\n{\n  size_t i, j, k, m, n;\n  RealVector *rvp, *rvlb, *rvub;\n\n  m = rrprma.size();\n  for(i = n = 0; i < m; ++i)\n    n += rrprma[i].size();\n  *probs = rvp = new RealVector(n, false);\n  *lb = rvlb = new RealVector(n, false);\n  *ub = rvub = new RealVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    const RealRealPairRealMap& rrprm_i = (rrprma)[i];\n    RealRealPairRealMap::const_iterator rrprm_it = rrprm_i.begin();\n    RealRealPairRealMap::const_iterator rrprm_ite = rrprm_i.end();\n    for ( ; rrprm_it != rrprm_ite; ++rrprm_it, ++k) {\n      const RealRealPair& interval = rrprm_it->first;\n      Real prob = rrprm_it->second;\n      (*rvp)[k] = prob;\n      (*rvlb)[k] = interval.first;\n      (*rvub)[k] = interval.second;\n    }\n  }\n}\n\n/// Flatten integer-valued interval uncertain variable intervals and\n/// probabilities back into separate arrays.\nstatic void flatten_int_intervals(const IntIntPairRealMapArray& iiprma, \n\t\t\t\t  RealVector **probs, \n\t\t\t\t  IntVector **lb, IntVector** ub)\n{\n  size_t i, j, k, m, n;\n  RealVector *ivp;\n  IntVector *ivlb, *ivub;\n\n  m = iiprma.size();\n  for(i = n = 0; i < m; ++i)\n    n += iiprma[i].size();\n  *probs = ivp = new RealVector(n, false);\n  *lb = ivlb = new IntVector(n, false);\n  *ub = ivub = new IntVector(n, false);\n  for(i = k = 0; i < m; ++i) {\n    const IntIntPairRealMap& iiprm_i = iiprma[i];\n    IntIntPairRealMap::const_iterator iiprm_it = iiprm_i.begin();\n    IntIntPairRealMap::const_iterator iiprm_ite = iiprm_i.end();\n    for ( ; iiprm_it != iiprm_ite; ++iiprm_it, ++k) {\n      const IntIntPair& interval = iiprm_it->first;\n      Real prob = iiprm_it->second;\n      (*ivp)[k] = prob;\n      (*ivlb)[k] = interval.first;\n      (*ivub)[k] = interval.second;\n    }\n  }\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_descriptor_format(const StringArray& labels) {\n  StringArray::const_iterator li = labels.begin();\n  String::const_iterator si;\n  for(; li != labels.end(); ++li) {\n    // error if descriptor contains whitespace\n    for(si = li->begin(); si != li->end(); ++si) {\n      if(isspace(*si)) {\n        Squawk(\"Descriptor \\\"%s\\\" is invalid: whitespace not permitted\", \n              li->c_str());\n        break;\n      }\n    }\n    if(isfloat(*li)) \n      Squawk(\"Descriptor \\\"%s\\\" is invalid: floating point numbers not permitted\",\n          li->c_str());\n    if(li->empty())\n      Squawk(\"Empty variable or response descriptors are not permitted\");\n  }\n}\n\n\nvoid NIDRProblemDescDB::\ncheck_variables(std::list<DataVariables>* dvl)\n{\n  // BMA: If parse was called, then the Var_Info objects have already\n  // been populated; in the case of pure DB insertion in library mode,\n  // they won't be and some data from DataVariables needs to be mapped\n  // back to the flat Var_Info structures.  Not sure if this correctly\n  // captures the case where a parse is followed by a DB update of an\n  // input keyword not accounted for below\n\n\n\n  if (pDDBInstance) {\n    std::list<void*>::iterator It, Ite = pDDBInstance->VIL.end();\n    for(It = pDDBInstance->VIL.begin(); It != Ite; ++It)\n      check_variables_node(*It);\n    pDDBInstance->VIL.clear();\n  }\n  else {\n    // library mode with manual provision of everything\n    // map all data back into NIDR Var_Info structures\n    DataVariablesRep *dv;\n    IntArray *ia;\n    RealSymMatrix *rsm;\n    IntVector *iv_a;\n    StringArray *sa_a;\n    RealVector *rv, *rv_a, *rv_c;\n    RealVectorArray *rva;\n    Var_Info *vi;\n    size_t i, j, m, n, cntr;\n    int num_prs_i, total_prs;\n\n    // copy from DataVariables into Var_Info so that check_variables_node() can\n    // go the other direction.  TO DO: can we eliminate this circular update?\n    std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n    for(; It != Ite; ++It) {\n\n      // create new Var_Info instance to hold DataVariables data\n\n      vi = new Var_Info;\n      memset(vi, 0, sizeof(Var_Info));\n      vi->dv_handle = &*It;\n      vi->dv = dv = It->dataVarsRep;\n\n      // flatten 2D {Real,Int}{Vector,Set}Arrays back into Var_Info 1D arrays\n\n      // discrete design set int vars\n      if ((n = dv->numDiscreteDesSetIntVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetInt, &vi->nddsi);\n\tflatten_isa(&dv->discreteDesignSetInt,     &vi->ddsi);\n      }\n      // discrete design set string vars\n      if ((n = dv->numDiscreteDesSetStrVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetStr, &vi->nddss);\n\tflatten_ssa(&dv->discreteDesignSetStr,     &vi->ddss);\n      }\n      // discrete design set real vars\n      if ((n = dv->numDiscreteDesSetRealVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteDesignSetReal, &vi->nddsr);\n\tflatten_rsa(&dv->discreteDesignSetReal,     &vi->ddsr);\n      }\n      // histogram bin uncertain vars\n      // convert RealRealMapArray to RealVectors of abscissas and counts\n      const RealRealMapArray& hbp = dv->histogramUncBinPairs;\n      if ((m = hbp.size())) {\n\tvi->nhbp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hbp[i].size();\n\tvi->hba = rv_a = new RealVector(total_prs); // abscissas\n\tvi->hbc = rv_c = new RealVector(total_prs); // counts\n\tvi->hbo = NULL;                            // no ordinates\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  RRMCIter it = hbp[i].begin();\n\t  RRMCIter it_end = hbp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*rv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramBinUnc going other direction\n\t}\n      }\n\n      // histogram point int uncertain vars\n      // convert IntRealMapArray to Int/RealVectors of abscissas and counts\n      const IntRealMapArray& hpip = dv->histogramUncPointIntPairs;\n      if ((m = hpip.size())) {\n\tvi->nhpip = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hpip[i].size();\n\tvi->hpia = iv_a = new IntVector(total_prs); // abscissas\n\tvi->hpic = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  IRMCIter it = hpip[i].begin();\n\t  IRMCIter it_end = hpip[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*iv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // histogram point string uncertain vars\n      // convert StringRealMapArray to String/RealVectors of abscissas and counts\n      const StringRealMapArray& hpsp = dv->histogramUncPointStrPairs;\n      if ((m = hpsp.size())) {\n\tvi->nhpsp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hpsp[i].size();\n\tvi->hpsa = sa_a = new StringArray(total_prs); // abscissas\n\tvi->hpsc = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  SRMCIter it = hpsp[i].begin();\n\t  SRMCIter it_end = hpsp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*sa_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // histogram point real uncertain vars\n      // convert RealRealMapArray to RealVectors of abscissas and counts\n      const RealRealMapArray& hprp = dv->histogramUncPointRealPairs;\n      if ((m = hprp.size())) {\n\tvi->nhprp = ia = new IntArray(m);\n\tfor(i = 0; i < m; ++i)\n\t  total_prs += (*ia)[i] = hprp[i].size();\n\tvi->hpra = rv_a = new RealVector(total_prs); // abscissas\n\tvi->hprc = rv_c = new RealVector(total_prs); // counts\n\tfor(i = cntr = 0; i < m; ++i) {\n\t  RRMCIter it = hprp[i].begin();\n\t  RRMCIter it_end = hprp[i].end();\n\t  for( ; it != it_end; ++cntr) {\n\t    (*rv_a)[cntr] = it->first;   // abscissas\n\t    (*rv_c)[cntr] = it->second; // counts only (no ordinates)\n\t  }\n\t  // normalization occurs in Vchk_HistogramPtUnc going other direction\n\t}\n      }\n\n      // uncertain correlation matrix\n      if (dv->uncertainCorrelations.numRows())\n\tflatten_rsm(&dv->uncertainCorrelations, &vi->ucm);\n      // continuous interval uncertain vars\n      if ((n = dv->numContinuousIntervalUncVars)) {\n\tflatten_num_array(dv->continuousIntervalUncBasicProbs, &vi->nCI);\n\t// unroll the array of maps in to separate variables (p, lb, ub)\n\tflatten_real_intervals(dv->continuousIntervalUncBasicProbs, \n\t\t\t       &vi->CIp, &vi->CIlb, &vi->CIub);\n      }\n      // discrete interval uncertain vars\n      if ((n = dv->numDiscreteIntervalUncVars)) {\n\tflatten_num_array(dv->discreteIntervalUncBasicProbs, &vi->nDI);\n\t// unroll the array of maps in to separate variables (p, lb, ub)\n\tflatten_int_intervals(dv->discreteIntervalUncBasicProbs, \n\t\t\t      &vi->DIp, &vi->DIlb, &vi->DIub);\n      }\n      // discrete uncertain set int vars\n      if ((n = dv->numDiscreteUncSetIntVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetIntValuesProbs,    &vi->ndusi);\n\tflatten_irma_keys(&dv->discreteUncSetIntValuesProbs,   &vi->dusi);\n\tflatten_irma_values(&dv->discreteUncSetIntValuesProbs, &vi->DSIp);\n      }\n      // discrete uncertain set str vars\n      if ((n = dv->numDiscreteUncSetStrVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetStrValuesProbs,    &vi->nduss);\n\tflatten_srma_keys(&dv->discreteUncSetStrValuesProbs,   &vi->duss);\n\tflatten_srma_values(&dv->discreteUncSetStrValuesProbs, &vi->DSSp);\n      }\n      // discrete uncertain set real vars\n      if ((n = dv->numDiscreteUncSetRealVars)) {\n\t// Note: map consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteUncSetRealValuesProbs,    &vi->ndusr);\n\tflatten_rrma_keys(&dv->discreteUncSetRealValuesProbs,   &vi->dusr);\n\tflatten_rrma_values(&dv->discreteUncSetRealValuesProbs, &vi->DSRp);\n      }\n      // discrete state set int vars\n      if ((n = dv->numDiscreteStateSetIntVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetInt, &vi->ndssi);\n\tflatten_isa(&dv->discreteStateSetInt,     &vi->dssi);\n      }\n      // discrete state set string vars\n      if ((n = dv->numDiscreteStateSetStrVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetStr, &vi->ndsss);\n\tflatten_ssa(&dv->discreteStateSetStr,     &vi->dsss);\n      }\n      // discrete state set real vars\n      if ((n = dv->numDiscreteStateSetRealVars)) {\n\t// Note: set consolidation and/or reordering cannot be undone\n\tflatten_num_array(dv->discreteStateSetReal, &vi->ndssr);\n\tflatten_rsa(&dv->discreteStateSetReal,     &vi->dssr);\n      }\n\n      check_variables_node((void*)vi);\n    }\n  }\n  // validate descriptors. The string arrays are empty unless the user\n  // explicitly set descriptors.\n  std::list<DataVariables>::iterator It = dvl->begin(), Ite = dvl->end();\n  for(; It != Ite; ++It) {\n    const DataVariablesRep* dvr = It->data_rep();\n    check_descriptor_format(dvr->continuousDesignLabels);\n    check_descriptor_format(dvr->discreteDesignRangeLabels);\n    check_descriptor_format(dvr->discreteDesignSetIntLabels);\n    check_descriptor_format(dvr->discreteDesignSetStrLabels);\n    check_descriptor_format(dvr->discreteDesignSetRealLabels);\n    check_descriptor_format(dvr->continuousStateLabels);\n    check_descriptor_format(dvr->discreteStateRangeLabels);\n    check_descriptor_format(dvr->discreteStateSetIntLabels);\n    check_descriptor_format(dvr->discreteStateSetStrLabels);\n    check_descriptor_format(dvr->discreteStateSetRealLabels);\n    check_descriptor_format(dvr->continuousAleatoryUncLabels);\n    check_descriptor_format(dvr->discreteIntAleatoryUncLabels);\n    check_descriptor_format(dvr->discreteStrAleatoryUncLabels);\n    check_descriptor_format(dvr->discreteRealAleatoryUncLabels);\n    check_descriptor_format(dvr->continuousEpistemicUncLabels);\n    check_descriptor_format(dvr->discreteIntEpistemicUncLabels);\n    check_descriptor_format(dvr->discreteStrEpistemicUncLabels);\n    check_descriptor_format(dvr->discreteRealEpistemicUncLabels);\n\n    check_descriptors_for_repeats(dvr->continuousDesignLabels,\n                                  dvr->discreteDesignRangeLabels,\n                                  dvr->discreteDesignSetIntLabels,\n                                  dvr->discreteDesignSetStrLabels,\n                                  dvr->discreteDesignSetRealLabels,\n                                  dvr->continuousStateLabels,\n                                  dvr->discreteStateRangeLabels,\n                                  dvr->discreteStateSetIntLabels,\n                                  dvr->discreteStateSetStrLabels,\n                                  dvr->discreteStateSetRealLabels,\n                                  dvr->continuousAleatoryUncLabels,\n                                  dvr->discreteIntAleatoryUncLabels,\n                                  dvr->discreteStrAleatoryUncLabels,\n                                  dvr->discreteRealAleatoryUncLabels,\n                                  dvr->continuousEpistemicUncLabels,\n                                  dvr->discreteIntEpistemicUncLabels,\n                                  dvr->discreteStrEpistemicUncLabels,\n                                  dvr->discreteRealEpistemicUncLabels);\n  }\n}\n\nvoid NIDRProblemDescDB::\nvar_str(const char *keyname, Values *val, void **g, void *v)\n{\n  (*(Var_Info**)g)->dv->**(String DataVariablesRep::**)v = *val->s;\n}\n\nvoid NIDRProblemDescDB::\nvar_strL(const char *keyname, Values *val, void **g, void *v)\n{\n  StringArray *sa = &((*(Var_Info**)g)->dv->**(StringArray DataVariablesRep::**)v);\n  const char **s = val->s;\n  size_t i, n = val->n;\n\n  sa->resize(n);\n  for(i = 0; i < n; i++)\n    (*sa)[i] = s[i];\n}\n\nstatic void\nvar_iulbl(const char *keyname, Values *val, VarLabel *vl)\n{\n  char *t;\n  const char **s, **sl;\n  size_t i, L, n;\n\n  L = n = val->n;\t// n for null\n  s = val->s;\n  for(i = 0; i < n; i++)\n    L += strlen(s[i]);\n  vl->s = sl = (const char **)malloc(n*sizeof(char*) + L);\n  if (!sl)\n    NIDRProblemDescDB::botch(\"malloc failure in var_ulbl\");\n  vl->n = n;\n  t = (char*)(sl + n);\n  for(i = 0; i < n; i++) {\n    strcpy(t, s[i]);\n    sl[i] = (const char*)t;\n    t += strlen(t) + 1;\n  }\n}\n\nvoid NIDRProblemDescDB::\nvar_caulbl(const char *keyname, Values *val, void **g, void *v)\n{\n  // IRIX disallows (int)v, so we use the circumlocution (char*)v - (char*)0.\n  VarLabel *vl = &(*(Var_Info**)g)->CAUv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_ceulbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->CEUv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_dauilbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAUIv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deuilbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEUIv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_dauslbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAUSv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deuslbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEUSv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_daurlbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DAURv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\nvoid NIDRProblemDescDB::\nvar_deurlbl(const char *keyname, Values *val, void **g, void *v)\n{\n  VarLabel *vl = &(*(Var_Info**)g)->DEURv[(char*)v - (char*)0];\n  var_iulbl(keyname, val, vl);\n}\n\n#define MP_(x) DataInterfaceRep::* iface_mp_##x = &DataInterfaceRep::x\n#define MP2(x,y) iface_mp_##x##_##y = {&DataInterfaceRep::x,#y}\n#define MP2s(x,y) iface_mp_##x##_##y = {&DataInterfaceRep::x,y}\n#define MP3(x,y,z) iface_mp_TYPE_DATA_##x##_##z = {&DataInterfaceRep::x,&DataInterfaceRep::y,#z}\n\nstatic Iface_mp_Rlit\n\tMP3(failAction,recoveryFnVals,recover);\n\nstatic Iface_mp_ilit\n\tMP3(failAction,retryLimit,retry);\n\nstatic Iface_mp_lit\n\tMP2(failAction,abort),\n\tMP2(failAction,continuation);\n\nstatic Iface_mp_type\n\tMP2s(analysisScheduling,MASTER_SCHEDULING),\n\tMP2s(analysisScheduling,PEER_SCHEDULING),\n      //MP2s(analysisScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(analysisScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(evalScheduling,MASTER_SCHEDULING),\n\tMP2s(evalScheduling,PEER_DYNAMIC_SCHEDULING),\n\tMP2s(evalScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(asynchLocalEvalScheduling,DYNAMIC_SCHEDULING),\n        MP2s(asynchLocalEvalScheduling,STATIC_SCHEDULING),\n        MP2s(interfaceSynchronization,ASYNCHRONOUS_INTERFACE),\n        MP2s(interfaceSynchronization,SYNCHRONOUS_INTERFACE);\n\nstatic Iface_mp_utype\n\tMP2s(interfaceType,TEST_INTERFACE),\n\tMP2s(interfaceType,FORK_INTERFACE),\n\tMP2s(interfaceType,GRID_INTERFACE),\n\tMP2s(interfaceType,MATLAB_INTERFACE),\n\tMP2s(interfaceType,PYTHON_INTERFACE),\n\tMP2s(interfaceType,SCILAB_INTERFACE),\n\tMP2s(interfaceType,SYSTEM_INTERFACE),\n\t//MP2s(resultsFileFormat,FLEXIBLE_RESULTS), // re-enable when more formats added?\n\tMP2s(resultsFileFormat,LABELED_RESULTS);\n\nstatic String\n\tMP_(algebraicMappings),\n\tMP_(idInterface),\n\tMP_(inputFilter),\n\tMP_(outputFilter),\n\tMP_(parametersFile),\n\tMP_(resultsFile),\n\tMP_(workDir);\n\nstatic String2DArray\n\tMP_(analysisComponents);\n\nstatic StringArray\n\tMP_(analysisDrivers),\n        MP_(copyFiles),\n\tMP_(linkFiles);\n\nstatic bool\n\tMP_(activeSetVectorFlag),\n\tMP_(allowExistingResultsFlag),\n\tMP_(apreproFlag),\n\tMP_(dirSave),\n\tMP_(dirTag),\n\tMP_(evalCacheFlag),\n\tMP_(fileSaveFlag),\n\tMP_(fileTagFlag),\n\tMP_(nearbyEvalCacheFlag),\n\tMP_(numpyFlag),\n\tMP_(restartFileFlag),\n\tMP_(templateReplace),\n\tMP_(useWorkdir),\n\tMP_(verbatimFlag);\n\nstatic int\n\tMP_(analysisServers),\n\tMP_(asynchLocalAnalysisConcurrency),\n\tMP_(asynchLocalEvalConcurrency),\n\tMP_(evalServers),\n\tMP_(procsPerAnalysis),\n\tMP_(procsPerEval);\n\nstatic Real\n\tMP_(nearbyEvalCacheTol);\n\n#undef MP3\n#undef MP2s\n#undef MP2\n#undef MP_\n\n\n// Macros for Method\n\n#define MP_(x) DataMethodRep::* method_mp_##x = &DataMethodRep::x\n#define MP2(x,y) method_mp_##x##_##y = {&DataMethodRep::x,#y}\n#define MP2s(x,y) method_mp_##x##_##y = {&DataMethodRep::x,y}\n#if HAVE_OPTPP\n#  define MP2o(x,y) method_mp_##x##_##y = {&DataMethodRep::x,OPTPP::y}\n#else\n#  define MP2o(x,y) method_mp_##x##_##y = {NULL, NULL}\n#endif\n#define MP2p(x,y) method_mp_##x##_##y = {&DataMethodRep::x,Pecos::y}\n#define MP3(x,y,z) method_mp_TYPE_DATA_##x##_##z = {&DataMethodRep::x,&DataMethodRep::y,#z}\n#define MP3s(x,y,z) method_mp_TYPE_DATA_##x##_##z = {&DataMethodRep::x,&DataMethodRep::y,z}\n\nstatic IntVector\n\tMP_(primeBase),\n\tMP_(refineSamples),\n\tMP_(sequenceLeap),\n\tMP_(sequenceStart),\n\tMP_(stepsPerVariable);\n\nstatic Method_mp_ilit2\n\tMP3(replacementType,numberRetained,chc),\n\tMP3(replacementType,numberRetained,elitist),\n\tMP3(replacementType,numberRetained,random);\n\nstatic Method_mp_ilit2z\n\tMP3(crossoverType,numCrossPoints,multi_point_binary),\n\tMP3(crossoverType,numCrossPoints,multi_point_parameterized_binary),\n\tMP3(crossoverType,numCrossPoints,multi_point_real);\n\nstatic Method_mp_lit\n\tMP2(batchSelectionType,naive),\n\tMP2(batchSelectionType,distance),\n\tMP2(batchSelectionType,topology),\n\tMP2(batchSelectionType,cl),\n\tMP2(boxDivision,all_dimensions),\n\tMP2(boxDivision,major_dimension),\n\tMP2(convergenceType,average_fitness_tracker),\n\tMP2(convergenceType,best_fitness_tracker),\n\tMP2(convergenceType,metric_tracker),\n\tMP2(crossoverType,blend),\n\tMP2(crossoverType,two_point),\n\tMP2(crossoverType,uniform),\n        MP2(dataDistCovInputType,diagonal),\n        MP2(dataDistCovInputType,matrix),\n      //MP2(dataDistType,gaussian),\n      //MP2(dataDistType,user),\n\tMP2(evalSynchronize,blocking),\n\tMP2(evalSynchronize,nonblocking),\n\tMP2(expansionSampleType,incremental_lhs),\n\tMP2(exploratoryMoves,adaptive),\n\tMP2(exploratoryMoves,multi_step),\n\tMP2(exploratoryMoves,simple),\n\tMP2(fitnessType,domination_count),\n\tMP2(fitnessType,layer_rank),\n\tMP2(fitnessType,linear_rank),\n\tMP2(fitnessType,merit_function),\n\tMP2(fitnessType,proportional),\n\tMP2(fitnessMetricType,predicted_variance),\n\tMP2(fitnessMetricType,distance),\n\tMP2(fitnessMetricType,gradient),\n      //MP2(hybridCollabType,abo),\n      //MP2(hybridCollabType,hops),\n      //MP2(seqHybridType,adaptive),\n\tMP2(initializationType,random),\n\tMP2(initializationType,unique_random),\n\tMP2(lipschitzType,global),\n\tMP2(lipschitzType,local),\n        MP2(meritFunction,merit_max),\n        MP2(meritFunction,merit_max_smooth),\n        MP2(meritFunction,merit1),\n        MP2(meritFunction,merit1_smooth),\n        MP2(meritFunction,merit2),\n        MP2(meritFunction,merit2_smooth),\n        MP2(meritFunction,merit2_squared),\n\tMP2(mcmcType,adaptive_metropolis),\n\tMP2(mcmcType,delayed_rejection),\n\tMP2(mcmcType,dram),\n\tMP2(mcmcType,metropolis_hastings),\n\tMP2(mcmcType,multilevel),\n\tMP2(modelDiscrepancyType,global_kriging),\n\tMP2(modelDiscrepancyType,global_polynomial),\n\tMP2(mutationType,bit_random),\n\tMP2(mutationType,offset_cauchy),\n\tMP2(mutationType,offset_normal),\n\tMP2(mutationType,offset_uniform),\n\tMP2(mutationType,replace_uniform),\n\tMP2(patternBasis,coordinate),\n\tMP2(patternBasis,simplex),\n\tMP2(pointReuse,all),\n        MP2(proposalCovInputType,diagonal),\n        MP2(proposalCovInputType,matrix),\n        MP2(proposalCovType,derivatives),\n        MP2(proposalCovType,prior),\n        MP2(proposalCovType,user),\n\tMP2(reliabilityIntegration,first_order),\n\tMP2(reliabilityIntegration,second_order),\n\tMP2(replacementType,elitist),\n\tMP2(replacementType,favor_feasible),\n\tMP2(replacementType,roulette_wheel),\n\tMP2(replacementType,unique_roulette_wheel),\n\tMP2(rngName,mt19937),\n\tMP2(rngName,rnum2),\n\tMP2(searchMethod,gradient_based_line_search),\n\tMP2(searchMethod,tr_pds),\n\tMP2(searchMethod,trust_region),\n\tMP2(searchMethod,value_based_line_search),\n\tMP2(trialType,grid),\n\tMP2(trialType,halton),\n\tMP2(trialType,random),\n        MP2(useSurrogate,inform_search),\n        MP2(useSurrogate,optimize);\n\nstatic Method_mp_litc\n\tMP3(crossoverType,crossoverRate,shuffle_random),\n\tMP3(crossoverType,crossoverRate,null_crossover),\n\tMP3(mutationType,mutationRate,null_mutation),\n\tMP3(mutationType,mutationRate,offset_cauchy),\n\tMP3(mutationType,mutationRate,offset_normal),\n\tMP3(mutationType,mutationRate,offset_uniform),\n\tMP3(replacementType,fitnessLimit,below_limit);\n\nstatic Method_mp_litrv\n\tMP3(nichingType,nicheVector,distance),\n\tMP3(nichingType,nicheVector,max_designs),\n\tMP3(nichingType,nicheVector,radial),\n\tMP3(postProcessorType,distanceVector,distance_postprocessor);\n\nstatic Method_mp_slit2\n\tMP3(initializationType,flatFile,flat_file);\n\nstatic Method_mp_utype_lit\n        MP3s(methodName,dlDetails,DL_SOLVER); // struct order: ip, sp, utype\n\nstatic Method_mp_ord\n\tMP2s(approxCorrectionOrder,0),\n\tMP2s(approxCorrectionOrder,1),\n\tMP2s(approxCorrectionOrder,2);\n\nstatic Real\n\tMP_(absConvTol),\n\tMP_(centeringParam),\n\tMP_(collocationRatio),\n\tMP_(collocRatioTermsOrder),\n\tMP_(constraintPenalty),\n\tMP_(constrPenalty),\n\tMP_(constraintTolerance),\n\tMP_(contractFactor),\n\tMP_(contractStepLength),\n\tMP_(convergenceTolerance),\n\tMP_(crossoverRate),\n\tMP_(falseConvTol),\n\tMP_(functionPrecision),\n\tMP_(globalBalanceParam),\n\tMP_(gradientTolerance),\n      //MP_(hybridProgThresh),\n\tMP_(hybridLSProb),\n\tMP_(grThreshold),\n\tMP_(initDelta),\n\tMP_(initMeshSize),\n\tMP_(initStepLength),\n\tMP_(initTRRadius),\n\tMP_(lineSearchTolerance),\n\tMP_(localBalanceParam),\n\tMP_(maxBoxSize),\n\tMP_(maxStep),\n\tMP_(minBoxSize),\n\tMP_(minMeshSize),\n\tMP_(multilevEstimatorRate),\n\tMP_(mutationRate),\n\tMP_(mutationScale),\n\tMP_(percentVarianceExplained),\n        MP_(priorPropCovMult),\n\tMP_(refinementRate),\n\tMP_(regressionL2Penalty),\n\tMP_(shrinkagePercent),\t// should be called shrinkageFraction\n\tMP_(singConvTol),\n\tMP_(singRadius),\n        MP_(smoothFactor),\n \tMP_(solnTarget),\n\tMP_(stepLenToBoundary),\n\tMP_(threshDelta),\n\tMP_(threshStepLength),\n\tMP_(trustRegionContract),\n\tMP_(trustRegionContractTrigger),\n\tMP_(trustRegionExpand),\n\tMP_(trustRegionExpandTrigger),\n\tMP_(trustRegionMinSize),\n\tMP_(vbdDropTolerance),\n\tMP_(volBoxSize),\n\tMP_(vns),\n\tMP_(wilksConfidenceLevel),\n\tMP_(xConvTol);\n\nstatic RealVector\n\tMP_(anisoDimPref),\n\tMP_(concurrentParameterSets),\n\tMP_(dataDistCovariance),\n\tMP_(dataDistMeans),\n\tMP_(finalPoint),\n\tMP_(hyperPriorAlphas),\n\tMP_(hyperPriorBetas),\n\tMP_(listOfPoints),\n\tMP_(predictionConfigList),\n\tMP_(proposalCovData),\n\tMP_(regressionNoiseTol),\n        MP_(stepVector),\n\tMP_(trustRegionInitSize);\n\nstatic RealVectorArray\n\tMP_(genReliabilityLevels),\n\tMP_(probabilityLevels),\n\tMP_(reliabilityLevels),\n\tMP_(responseLevels);\n\nstatic unsigned short\n\tMP_(adaptedBasisAdvancements),\n      //MP_(adaptedBasisInitLevel),\n\tMP_(cubIntOrder),\n        MP_(expansionOrder),\n        MP_(quadratureOrder),\n\tMP_(softConvLimit),\n\tMP_(sparseGridLevel),\n\tMP_(vbdOrder),\n\tMP_(wilksOrder);\n\nstatic SizetArray\n\tMP_(collocationPointsSeq),\n        MP_(expansionSamplesSeq),\n  \tMP_(pilotSamples);\n\nstatic UShortArray\n        MP_(expansionOrderSeq),\n        MP_(quadratureOrderSeq),\n\tMP_(sparseGridLevelSeq),\n        MP_(tensorGridOrder),\n\tMP_(varPartitions);\n\nstatic String\n        MP_(advancedOptionsFilename),\n        MP_(betaSolverName),\n        MP_(dataDistFile),\n        MP_(displayFormat),\n\tMP_(exportApproxPtsFile),\n\tMP_(exportCorrModelFile),\n\tMP_(exportCorrVarFile),\n\tMP_(exportDiscrepFile),\n\tMP_(exportExpansionFile),\n\tMP_(exportMCMCPtsFile),\n\tMP_(historyFile),\n\tMP_(hybridGlobalMethodName),\n\tMP_(hybridGlobalMethodPointer),\n\tMP_(hybridGlobalModelPointer),\n\tMP_(hybridLocalMethodName),\n\tMP_(hybridLocalMethodPointer),\n\tMP_(hybridLocalModelPointer),\n\tMP_(idMethod),\n\tMP_(importApproxPtsFile),\n\tMP_(importBuildPtsFile),\n\tMP_(importCandPtsFile),\n\tMP_(importExpansionFile),\n\tMP_(importPredConfigs),\n\tMP_(logFile),\n\tMP_(lowFidModelPointer),\n\tMP_(modelPointer),\n        MP_(posteriorDensityExportFilename),\n        MP_(posteriorSamplesExportFilename),\n        MP_(posteriorSamplesImportFilename),\n\tMP_(proposalCovFile),\n\tMP_(pstudyFilename),\n\tMP_(subMethodName),\n        MP_(subMethodPointer),\n        MP_(subModelPointer);\n\nstatic StringArray\n\tMP_(hybridMethodNames),\n\tMP_(hybridMethodPointers),\n\tMP_(hybridModelPointers),\n        MP_(miscOptions);\n\nstatic bool\n\tMP_(adaptExpDesign),\n\tMP_(adaptPosteriorRefine),\n\tMP_(backfillFlag),\n\tMP_(calModelDiscrepancy),\n\tMP_(constantPenalty),\n\tMP_(crossValidation),\n\tMP_(crossValidNoiseOnly),\n\tMP_(dOptimal),\n        MP_(evaluatePosteriorDensity),\n\tMP_(expansionFlag),\n\tMP_(exportSampleSeqFlag),\n\tMP_(fixedSeedFlag),\n\tMP_(fixedSequenceFlag),\n        MP_(generatePosteriorSamples),\n\tMP_(gpmsaNormalize),\n\tMP_(importApproxActive),\n\tMP_(importBuildActive),\n\tMP_(latinizeFlag),\n\tMP_(logitTransform),\n\tMP_(mainEffectsFlag),\n\tMP_(methodScaling),\n\tMP_(methodUseDerivsFlag),\n        MP_(modelEvidence),\n        MP_(modelEvidLaplace),\n        MP_(modelEvidMC),\n\tMP_(mutualInfoKSG2),\n\tMP_(mutationAdaptive),\n\tMP_(normalizedCoeffs),\n\tMP_(pcaFlag),\n\tMP_(posteriorStatsKL),\n\tMP_(posteriorStatsKDE),\n\tMP_(posteriorStatsMutual),\n\tMP_(printPopFlag),\n\tMP_(pstudyFileActive),\n\tMP_(randomizeOrderFlag),\n\tMP_(regressDiag),\n\tMP_(showAllEval),\n\tMP_(showMiscOptions),\n\tMP_(speculativeFlag),\n\tMP_(standardizedSpace),\n\tMP_(tensorGridFlag),\n\tMP_(surrBasedGlobalReplacePts),\n\tMP_(surrBasedLocalLayerBypass),\n\tMP_(vbdFlag),\n\tMP_(volQualityFlag),\n\tMP_(wilksFlag);\n\nstatic short\n        MP_(expansionType),\n\tMP_(nestingOverride),\n\tMP_(refinementType),\n\tMP_(wilksSidedInterval);\n\nstatic int\n\tMP_(batchSize),\n\tMP_(buildSamples),\n\tMP_(burnInSamples),\n\tMP_(chainSamples),\n\tMP_(concurrentRandomJobs),\n\tMP_(contractAfterFail),\n\tMP_(covarianceType),\n        MP_(crossoverChainPairs),\n        MP_(emulatorOrder),\n\tMP_(expandAfterSuccess),\n        MP_(evidenceSamples),\n        MP_(iteratorServers),\n\tMP_(jumpStep),\n\tMP_(maxFunctionEvaluations),\n\tMP_(maxHifiEvals),\n\tMP_(maxIterations),\n\tMP_(maxRefineIterations),\n\tMP_(maxSolverIterations),\n\tMP_(mutationRange),\n        MP_(neighborOrder),\n\tMP_(newSolnsGenerated),\n\tMP_(numChains),\n\tMP_(numCR),\n\tMP_(numSamples),\n\tMP_(numSteps),\n\tMP_(numSymbols),\n\tMP_(numTrials),\n\tMP_(populationSize),\n        MP_(procsPerIterator),\n        MP_(proposalCovUpdatePeriod),\n\tMP_(numPushforwardSamples),\n\tMP_(randomSeed),\n\tMP_(samplesOnEmulator),\n\tMP_(searchSchemeSize),\n\tMP_(subSamplingPeriod),\n\tMP_(totalPatternSize),\n\tMP_(verifyLevel);\n\nstatic size_t\n\tMP_(collocationPoints),\n        MP_(expansionSamples),\n        MP_(numCandidateDesigns),\n\tMP_(numCandidates),\n        MP_(numDesigns),\n        MP_(numFinalSolutions),\n\tMP_(numGenerations),\n\tMP_(numOffspring),\n\tMP_(numParents),\n  \tMP_(numPredConfigs);\n\nstatic Method_mp_type\n\tMP2s(covarianceControl,DIAGONAL_COVARIANCE),\n\tMP2s(covarianceControl,FULL_COVARIANCE),\n\tMP2s(distributionType,COMPLEMENTARY),\n\tMP2s(distributionType,CUMULATIVE),\n\tMP2s(emulatorType,GP_EMULATOR),\n\tMP2s(emulatorType,KRIGING_EMULATOR),\n\tMP2s(emulatorType,MF_PCE_EMULATOR),\n\tMP2s(emulatorType,MF_SC_EMULATOR),\n\tMP2s(emulatorType,ML_PCE_EMULATOR),\n\tMP2s(emulatorType,PCE_EMULATOR),\n\tMP2s(emulatorType,SC_EMULATOR),\n\tMP2s(emulatorType,VPS_EMULATOR),\n\tMP2p(expansionBasisType,ADAPTED_BASIS_EXPANDING_FRONT),\n\tMP2p(expansionBasisType,ADAPTED_BASIS_GENERALIZED),\n\tMP2p(expansionBasisType,HIERARCHICAL_INTERPOLANT),\n\tMP2p(expansionBasisType,NODAL_INTERPOLANT),\n\tMP2p(expansionBasisType,TENSOR_PRODUCT_BASIS),\n\tMP2p(expansionBasisType,TOTAL_ORDER_BASIS),\n\tMP2s(expansionType,ASKEY_U),\n\tMP2s(expansionType,STD_NORMAL_U),\n\tMP2s(finalMomentsType,CENTRAL_MOMENTS),\n\tMP2s(finalMomentsType,NO_MOMENTS),\n\tMP2s(finalMomentsType,STANDARD_MOMENTS),\n\tMP2p(growthOverride,RESTRICTED),                   // Pecos enumeration\n\tMP2p(growthOverride,UNRESTRICTED),                 // Pecos enumeration\n\tMP2s(iteratorScheduling,MASTER_SCHEDULING),\n\tMP2s(iteratorScheduling,PEER_SCHEDULING),\n      //MP2s(iteratorScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(iteratorScheduling,PEER_STATIC_SCHEDULING),\n\tMP2s(lsRegressionType,EQ_CON_LS),\n\tMP2s(lsRegressionType,SVD_LS),\n\tMP2o(meritFn,ArgaezTapia),                         // OPTPP enumeration\n\tMP2o(meritFn,NormFmu),                             // OPTPP enumeration\n\tMP2o(meritFn,VanShanno),                           // OPTPP enumeration\n\tMP2s(methodOutput,DEBUG_OUTPUT),\n\tMP2s(methodOutput,NORMAL_OUTPUT),\n\tMP2s(methodOutput,QUIET_OUTPUT),\n\tMP2s(methodOutput,SILENT_OUTPUT),\n\tMP2s(methodOutput,VERBOSE_OUTPUT),\n\tMP2s(multilevDiscrepEmulation,DISTINCT_EMULATION),\n\tMP2s(multilevDiscrepEmulation,RECURSIVE_EMULATION),\n\tMP2p(nestingOverride,NESTED),                      // Pecos enumeration\n\tMP2p(nestingOverride,NON_NESTED),                  // Pecos enumeration\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_GENERALIZED),// Pecos\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_DECAY),      // Pecos\n\tMP2p(refinementControl,DIMENSION_ADAPTIVE_CONTROL_SOBOL),      // Pecos\n\tMP2p(refinementControl,LOCAL_ADAPTIVE_CONTROL),                // Pecos\n\tMP2p(refinementControl,UNIFORM_CONTROL),                       // Pecos\n\tMP2p(refinementType,P_REFINEMENT),                 // Pecos enumeration\n        MP2p(refinementType,H_REFINEMENT),                 // Pecos enumeration\n\tMP2p(regressionType,BASIS_PURSUIT),                // Pecos enumeration\n\tMP2p(regressionType,BASIS_PURSUIT_DENOISING),      // Pecos enumeration\n\tMP2p(regressionType,DEFAULT_LEAST_SQ_REGRESSION),  // Pecos enumeration\n\tMP2p(regressionType,LASSO_REGRESSION),             // Pecos enumeration\n\tMP2p(regressionType,LEAST_ANGLE_REGRESSION),       // Pecos enumeration\n\tMP2p(regressionType,ORTHOG_LEAST_INTERPOLATION),   // Pecos enumeration\n\tMP2p(regressionType,ORTHOG_MATCH_PURSUIT),         // Pecos enumeration\n\tMP2s(responseLevelTarget,GEN_RELIABILITIES),\n\tMP2s(responseLevelTarget,PROBABILITIES),\n\tMP2s(responseLevelTarget,RELIABILITIES),\n\tMP2s(responseLevelTargetReduce,SYSTEM_PARALLEL),\n\tMP2s(responseLevelTargetReduce,SYSTEM_SERIES),\n\tMP2s(surrBasedLocalAcceptLogic,FILTER),\n\tMP2s(surrBasedLocalAcceptLogic,TR_RATIO),\n\tMP2s(surrBasedLocalConstrRelax,HOMOTOPY),\n\tMP2s(surrBasedLocalMeritFn,ADAPTIVE_PENALTY_MERIT),\n\tMP2s(surrBasedLocalMeritFn,AUGMENTED_LAGRANGIAN_MERIT),\n\tMP2s(surrBasedLocalMeritFn,LAGRANGIAN_MERIT),\n\tMP2s(surrBasedLocalMeritFn,PENALTY_MERIT),\n\tMP2s(surrBasedLocalSubProbCon,LINEARIZED_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbCon,NO_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbCon,ORIGINAL_CONSTRAINTS),\n\tMP2s(surrBasedLocalSubProbObj,AUGMENTED_LAGRANGIAN_OBJECTIVE),\n\tMP2s(surrBasedLocalSubProbObj,LAGRANGIAN_OBJECTIVE),\n\tMP2s(surrBasedLocalSubProbObj,ORIGINAL_PRIMARY),\n\tMP2s(surrBasedLocalSubProbObj,SINGLE_OBJECTIVE),\n\tMP2s(wilksSidedInterval,ONE_SIDED_LOWER),\n\tMP2s(wilksSidedInterval,ONE_SIDED_UPPER),\n\tMP2s(wilksSidedInterval,TWO_SIDED);\n\nstatic Method_mp_utype\n\tMP2s(calibrateErrorMode,CALIBRATE_ONE),\n\tMP2s(calibrateErrorMode,CALIBRATE_PER_EXPER),\n\tMP2s(calibrateErrorMode,CALIBRATE_PER_RESP),\n\tMP2s(calibrateErrorMode,CALIBRATE_BOTH),\n        MP2s(exportApproxFormat,TABULAR_NONE),\n        MP2s(exportApproxFormat,TABULAR_HEADER),\n        MP2s(exportApproxFormat,TABULAR_EVAL_ID),\n        MP2s(exportApproxFormat,TABULAR_IFACE_ID),\n        MP2s(exportApproxFormat,TABULAR_ANNOTATED),\n        MP2s(exportCorrModelFormat,TABULAR_NONE),\n        MP2s(exportCorrModelFormat,TABULAR_HEADER),\n        MP2s(exportCorrModelFormat,TABULAR_EVAL_ID),\n        MP2s(exportCorrModelFormat,TABULAR_IFACE_ID),\n        MP2s(exportCorrModelFormat,TABULAR_ANNOTATED),\n        MP2s(exportCorrVarFormat,TABULAR_NONE),\n        MP2s(exportCorrVarFormat,TABULAR_HEADER),\n        MP2s(exportCorrVarFormat,TABULAR_EVAL_ID),\n        MP2s(exportCorrVarFormat,TABULAR_IFACE_ID),\n        MP2s(exportCorrVarFormat,TABULAR_ANNOTATED),\n        MP2s(exportDiscrepFormat,TABULAR_NONE),\n        MP2s(exportDiscrepFormat,TABULAR_HEADER),\n        MP2s(exportDiscrepFormat,TABULAR_EVAL_ID),\n        MP2s(exportDiscrepFormat,TABULAR_IFACE_ID),\n        MP2s(exportDiscrepFormat,TABULAR_ANNOTATED),\n        MP2s(exportSamplesFormat,TABULAR_NONE),\n        MP2s(exportSamplesFormat,TABULAR_HEADER),\n        MP2s(exportSamplesFormat,TABULAR_EVAL_ID),\n        MP2s(exportSamplesFormat,TABULAR_IFACE_ID),\n        MP2s(exportSamplesFormat,TABULAR_ANNOTATED),\n        MP2s(importApproxFormat,TABULAR_NONE),\n        MP2s(importApproxFormat,TABULAR_HEADER),\n        MP2s(importApproxFormat,TABULAR_EVAL_ID),\n        MP2s(importApproxFormat,TABULAR_IFACE_ID),\n        MP2s(importApproxFormat,TABULAR_ANNOTATED),\n        MP2s(importBuildFormat,TABULAR_NONE),\n        MP2s(importBuildFormat,TABULAR_HEADER),\n        MP2s(importBuildFormat,TABULAR_EVAL_ID),\n        MP2s(importBuildFormat,TABULAR_IFACE_ID),\n        MP2s(importBuildFormat,TABULAR_ANNOTATED),\n        MP2s(importCandFormat,TABULAR_NONE),\n        MP2s(importCandFormat,TABULAR_HEADER),\n        MP2s(importCandFormat,TABULAR_EVAL_ID),\n        MP2s(importCandFormat,TABULAR_IFACE_ID),\n        MP2s(importCandFormat,TABULAR_ANNOTATED),\n        MP2s(importPredConfigFormat,TABULAR_NONE),\n        MP2s(importPredConfigFormat,TABULAR_HEADER),\n        MP2s(importPredConfigFormat,TABULAR_EVAL_ID),\n        MP2s(importPredConfigFormat,TABULAR_IFACE_ID),\n        MP2s(importPredConfigFormat,TABULAR_ANNOTATED),\n\tMP2s(integrationRefine,AIS),\n\tMP2s(integrationRefine,IS),\n\tMP2s(integrationRefine,MMAIS),\n\tMP2s(methodName,ASYNCH_PATTERN_SEARCH),\n\tMP2s(methodName,BRANCH_AND_BOUND),\n\tMP2s(methodName,COLINY_BETA),\n\tMP2s(methodName,COLINY_COBYLA),\n\tMP2s(methodName,COLINY_DIRECT),\n\tMP2s(methodName,COLINY_EA),\n\tMP2s(methodName,COLINY_PATTERN_SEARCH),\n\tMP2s(methodName,COLINY_SOLIS_WETS),\n\tMP2s(methodName,CONMIN_FRCG),\n\tMP2s(methodName,CONMIN_MFD),\n\tMP2s(methodName,DACE),\n\tMP2s(methodName,DATA_FIT_SURROGATE_BASED_LOCAL),\n\tMP2s(methodName,DOT_BFGS),\n\tMP2s(methodName,DOT_FRCG),\n\tMP2s(methodName,DOT_MMFD),\n\tMP2s(methodName,DOT_SLP),\n\tMP2s(methodName,DOT_SQP),\n\tMP2s(methodName,EFFICIENT_GLOBAL),\n\tMP2s(methodName,FSU_CVT),\n\tMP2s(methodName,FSU_HALTON),\n\tMP2s(methodName,FSU_HAMMERSLEY),\n\tMP2s(methodName,HIERARCH_SURROGATE_BASED_LOCAL),\n\tMP2s(methodName,HYBRID),\n\tMP2s(methodName,MESH_ADAPTIVE_SEARCH),\n\tMP2s(methodName,MOGA),\n\tMP2s(methodName,MULTI_START),\n  MP2s(methodName,NCSU_DIRECT),\n  MP2s(methodName,ROL),\n\tMP2s(methodName,NL2SOL),\n\tMP2s(methodName,NLPQL_SQP),\n\tMP2s(methodName,NLSSOL_SQP),\n\tMP2s(methodName,MIT_NOWPAC),\n\tMP2s(methodName,MIT_SNOWPAC),\n        MP2s(methodName,ADAPTIVE_SAMPLING),\n\tMP2s(methodName,BAYES_CALIBRATION),\n\tMP2s(methodName,GENIE_DIRECT),\n\tMP2s(methodName,GENIE_OPT_DARTS),\n        MP2s(methodName,GPAIS),\n\tMP2s(methodName,GLOBAL_EVIDENCE),\n        MP2s(methodName,GLOBAL_INTERVAL_EST),\n\tMP2s(methodName,GLOBAL_RELIABILITY),\n        MP2s(methodName,IMPORTANCE_SAMPLING),\n \tMP2s(methodName,LOCAL_EVIDENCE),\n        MP2s(methodName,LOCAL_INTERVAL_EST),\n\tMP2s(methodName,LOCAL_RELIABILITY),\n\tMP2s(methodName,MULTIFIDELITY_POLYNOMIAL_CHAOS),\n\tMP2s(methodName,MULTIFIDELITY_STOCH_COLLOCATION),\n\tMP2s(methodName,MULTILEVEL_POLYNOMIAL_CHAOS),\n\tMP2s(methodName,MULTILEVEL_SAMPLING),\n        MP2s(methodName,POF_DARTS),\n\tMP2s(methodName,RKD_DARTS),\n\tMP2s(methodName,POLYNOMIAL_CHAOS),\n\tMP2s(methodName,RANDOM_SAMPLING),\n\tMP2s(methodName,STOCH_COLLOCATION),\n\tMP2s(methodName,NONLINEAR_CG),\n\tMP2s(methodName,NPSOL_SQP),\n\tMP2s(methodName,OPTPP_CG),\n\tMP2s(methodName,OPTPP_FD_NEWTON),\n\tMP2s(methodName,OPTPP_G_NEWTON),\n\tMP2s(methodName,OPTPP_NEWTON),\n\tMP2s(methodName,OPTPP_PDS),\n\tMP2s(methodName,OPTPP_Q_NEWTON),\n\tMP2s(methodName,PARETO_SET),\n\tMP2s(methodName,PSUADE_MOAT),\n\tMP2s(methodName,RICHARDSON_EXTRAP),\n\tMP2s(methodName,SOGA),\n\tMP2s(methodName,SURROGATE_BASED_GLOBAL),\n\tMP2s(methodName,SURROGATE_BASED_LOCAL),\n\tMP2s(methodName,VECTOR_PARAMETER_STUDY),\n\tMP2s(methodName,LIST_PARAMETER_STUDY),\n\tMP2s(methodName,CENTERED_PARAMETER_STUDY),\n\tMP2s(methodName,MULTIDIM_PARAMETER_STUDY),\n\tMP2s(preSolveMethod,SUBMETHOD_NIP),\n\tMP2s(preSolveMethod,SUBMETHOD_NONE),\n\tMP2s(preSolveMethod,SUBMETHOD_SQP),\n\tMP2s(pstudyFileFormat,TABULAR_NONE),\n        MP2s(pstudyFileFormat,TABULAR_HEADER),\n        MP2s(pstudyFileFormat,TABULAR_EVAL_ID),\n        MP2s(pstudyFileFormat,TABULAR_IFACE_ID),\n        MP2s(pstudyFileFormat,TABULAR_ANNOTATED),\n\tMP2s(reliabilitySearchType,AMV_PLUS_U),\n\tMP2s(reliabilitySearchType,AMV_PLUS_X),\n\tMP2s(reliabilitySearchType,AMV_U),\n\tMP2s(reliabilitySearchType,AMV_X),\n\tMP2s(reliabilitySearchType,EGRA_U),\n\tMP2s(reliabilitySearchType,EGRA_X),\n\tMP2s(reliabilitySearchType,NO_APPROX),\n\tMP2s(reliabilitySearchType,TANA_U),\n\tMP2s(reliabilitySearchType,TANA_X),\n\tMP2s(sampleType,SUBMETHOD_LHS),\n\tMP2s(sampleType,SUBMETHOD_RANDOM),\n\tMP2s(subMethod,SUBMETHOD_COLLABORATIVE),\n\tMP2s(subMethod,SUBMETHOD_EMBEDDED),\n\tMP2s(subMethod,SUBMETHOD_SEQUENTIAL),\n\tMP2s(subMethod,SUBMETHOD_DREAM),\n\tMP2s(subMethod,SUBMETHOD_WASABI),\n\tMP2s(subMethod,SUBMETHOD_GPMSA),\n\tMP2s(subMethod,SUBMETHOD_QUESO),\n\tMP2s(subMethod,SUBMETHOD_NIP),\n\tMP2s(subMethod,SUBMETHOD_SQP),\n\tMP2s(subMethod,SUBMETHOD_EA),\n\tMP2s(subMethod,SUBMETHOD_EGO),\n\tMP2s(subMethod,SUBMETHOD_SBO),\n\tMP2s(subMethod,SUBMETHOD_LHS),\n\tMP2s(subMethod,SUBMETHOD_RANDOM),\n\tMP2s(subMethod,SUBMETHOD_OA_LHS),\n\tMP2s(subMethod,SUBMETHOD_OAS),\n\tMP2s(subMethod,SUBMETHOD_BOX_BEHNKEN),\n\tMP2s(subMethod,SUBMETHOD_CENTRAL_COMPOSITE),\n\tMP2s(subMethod,SUBMETHOD_GRID),\n\tMP2s(subMethod,SUBMETHOD_CONVERGE_ORDER),\n\tMP2s(subMethod,SUBMETHOD_CONVERGE_QOI),\n        MP2s(subMethod,SUBMETHOD_ESTIMATE_ORDER);\n\n#undef MP3s\n#undef MP3\n#undef MP2p\n#undef MP2o\n#undef MP2s\n#undef MP2\n#undef MP_\n\n\n// Macros for handling Model data\n\n#define MP_(x) DataModelRep::* model_mp_##x = &DataModelRep::x\n#define MP2(x,y) model_mp_##x##_##y = {&DataModelRep::x,#y}\n#define MP2s(x,y) model_mp_##x##_##y = {&DataModelRep::x,y}\n\nstatic IntSet\n\tMP_(surrogateFnIndices);\n\nstatic Model_mp_lit\n\tMP2(approxPointReuse,all),\n\tMP2(approxPointReuse,none),\n\tMP2(approxPointReuse,region),\n\tMP2(marsInterpolation,linear),\n\tMP2(marsInterpolation,cubic),\n\tMP2(modelType,active_subspace),\n\tMP2(modelType,adapted_basis),\n\tMP2(modelType,nested),\n\tMP2(modelType,random_field),\n\tMP2(modelType,simulation),\n\tMP2(modelType,surrogate),\n\tMP2(surrogateType,hierarchical),\n\tMP2(surrogateType,global_gaussian),\n\tMP2(surrogateType,global_kriging),\n\tMP2(surrogateType,global_mars),\n\tMP2(surrogateType,global_moving_least_squares),\n\tMP2(surrogateType,global_neural_network),\n\tMP2(surrogateType,global_polynomial),\n\tMP2(surrogateType,global_radial_basis),\n\tMP2(surrogateType,global_voronoi_surrogate),\n\tMP2(surrogateType,local_taylor),\n        MP2(surrogateType,multipoint_tana),\n        MP2(trendOrder,constant),\n        MP2(trendOrder,linear),\n        MP2(trendOrder,reduced_quadratic),\n        MP2(trendOrder,quadratic);\n\nstatic Model_mp_ord\n\tMP2s(approxCorrectionOrder,0),\n\tMP2s(approxCorrectionOrder,1),\n\tMP2s(approxCorrectionOrder,2),\n\tMP2s(polynomialOrder,1),\n\tMP2s(polynomialOrder,2),\n        MP2s(polynomialOrder,3);\n\nstatic Model_mp_type\n\tMP2s(approxCorrectionType,ADDITIVE_CORRECTION),\n\tMP2s(approxCorrectionType,COMBINED_CORRECTION),\n\tMP2s(approxCorrectionType,MULTIPLICATIVE_CORRECTION),\n\tMP2s(pointsManagement,MINIMUM_POINTS),\n\tMP2s(pointsManagement,RECOMMENDED_POINTS),\n\tMP2s(subMethodScheduling,MASTER_SCHEDULING),\n\tMP2s(subMethodScheduling,PEER_SCHEDULING);\n      //MP2s(subMethodScheduling,PEER_DYNAMIC_SCHEDULING),\n      //MP2s(subMethodScheduling,PEER_STATIC_SCHEDULING),\n        \n\nstatic Model_mp_utype\n        MP2s(analyticCovIdForm,EXP_L2),\n        MP2s(analyticCovIdForm,EXP_L1),\n        MP2s(exportApproxFormat,TABULAR_NONE),\n        MP2s(exportApproxFormat,TABULAR_HEADER),\n        MP2s(exportApproxFormat,TABULAR_EVAL_ID),\n        MP2s(exportApproxFormat,TABULAR_IFACE_ID),\n        MP2s(exportApproxFormat,TABULAR_ANNOTATED),\n      //MP2s(importApproxFormat,TABULAR_NONE),\n      //MP2s(importApproxFormat,TABULAR_HEADER),\n      //MP2s(importApproxFormat,TABULAR_EVAL_ID),\n      //MP2s(importApproxFormat,TABULAR_IFACE_ID),\n      //MP2s(importApproxFormat,TABULAR_ANNOTATED),\n        MP2s(importBuildFormat,TABULAR_NONE),\n        MP2s(importBuildFormat,TABULAR_HEADER),\n        MP2s(importBuildFormat,TABULAR_EVAL_ID),\n        MP2s(importBuildFormat,TABULAR_IFACE_ID),\n        MP2s(importBuildFormat,TABULAR_ANNOTATED),\n        MP2s(importChallengeFormat,TABULAR_NONE),\n        MP2s(importChallengeFormat,TABULAR_HEADER),\n        MP2s(importChallengeFormat,TABULAR_EVAL_ID),\n        MP2s(importChallengeFormat,TABULAR_IFACE_ID),\n        MP2s(importChallengeFormat,TABULAR_ANNOTATED),\n        MP2s(modelExportFormat,TEXT_ARCHIVE),\n        MP2s(modelExportFormat,BINARY_ARCHIVE),\n        MP2s(modelExportFormat,ALGEBRAIC_FILE),\n        MP2s(modelExportFormat,ALGEBRAIC_CONSOLE),\n        MP2s(randomFieldIdForm,RF_KARHUNEN_LOEVE),\n        MP2s(randomFieldIdForm,RF_PCA_GP),\n\t      MP2s(subspaceNormalization,SUBSPACE_NORM_MEAN_VALUE),\n\t      MP2s(subspaceNormalization,SUBSPACE_NORM_MEAN_GRAD),\n\t      MP2s(subspaceNormalization,SUBSPACE_NORM_LOCAL_GRAD),\n\t      MP2s(subspaceSampleType,SUBMETHOD_LHS),\n\t      MP2s(subspaceSampleType,SUBMETHOD_RANDOM),\n\t      MP2s(subspaceIdCVMethod,MINIMUM_METRIC),\n\t      MP2s(subspaceIdCVMethod,RELATIVE_TOLERANCE),\n\t      MP2s(subspaceIdCVMethod,DECREASE_TOLERANCE);\n\nstatic Real\n        MP_(adaptedBasisCollocRatio),\n        MP_(annRange),\n\tMP_(convergenceTolerance),\n        MP_(discontGradThresh),\n        MP_(discontJumpThresh),\n\tMP_(krigingNugget),\n\tMP_(percentFold),\n\tMP_(truncationTolerance),\n\tMP_(relTolerance),\n\tMP_(decreaseTolerance);\n\nstatic RealVector\n\tMP_(krigingCorrelations),\n      //MP_(krigingMaxCorrelations),\n      //MP_(krigingMinCorrelations),\n\tMP_(primaryRespCoeffs),\n\tMP_(secondaryRespCoeffs),\n  \tMP_(solutionLevelCost);\n\nstatic IntVector\n\tMP_(refineSamples);\n\nstatic String\n\tMP_(actualModelPointer),\n\tMP_(decompCellType),\n\tMP_(exportApproxPtsFile),\n\tMP_(idModel),\n      //MP_(importApproxPtsFile),\n\tMP_(importBuildPtsFile),\n\tMP_(importChallengePtsFile),\n\tMP_(interfacePointer),\n\tMP_(krigingOptMethod),\n\tMP_(modelExportPrefix),\n\tMP_(optionalInterfRespPointer),\n\tMP_(propagationModelPointer),\n\tMP_(refineCVMetric),\n\tMP_(responsesPointer),\n\tMP_(rfDataFileName),\n\tMP_(solutionLevelControl),\n\tMP_(subMethodPointer),\n\tMP_(variablesPointer);\n\nstatic StringArray\n        MP_(diagMetrics),\n\tMP_(orderedModelPointers),\n\tMP_(primaryVarMaps),\n        MP_(secondaryVarMaps);\n\nstatic bool\n\tMP_(autoRefine),\n\tMP_(crossValidateFlag),\n\tMP_(decompDiscontDetect),\n\tMP_(exportSurrogate),\n\tMP_(hierarchicalTags),\n        MP_(identityRespMap),\n      //MP_(importApproxActive),\n\tMP_(importBuildActive),\n\tMP_(importChallengeActive),\n\tMP_(modelUseDerivsFlag),\n        MP_(domainDecomp),\n        MP_(pointSelection),\n        MP_(pressFlag),\n  MP_(subspaceIdBingLi),\n  MP_(subspaceIdConstantine),\n  MP_(subspaceIdEnergy),\n  MP_(subspaceBuildSurrogate),\n  MP_(subspaceIdCV),\n  MP_(subspaceCVIncremental);\n\nstatic unsigned short\n\tMP_(adaptedBasisSparseGridLev),\n\tMP_(adaptedBasisExpOrder);\n\nstatic short\n\tMP_(annNodes),\n\tMP_(annRandomWeight),\n\tMP_(krigingFindNugget),\n\tMP_(krigingMaxTrials),\n\tMP_(marsMaxBases),\n\tMP_(mlsWeightFunction),\n\tMP_(polynomialOrder),\n\tMP_(rbfBases),\n\tMP_(rbfMaxPts),\n\tMP_(rbfMaxSubsets),\n\tMP_(rbfMinPartition);\n\nstatic int\n        MP_(decompSupportLayers),\n        MP_(initialSamples),\n        MP_(maxFunctionEvals),\n        MP_(maxIterations),\n        MP_(numFolds),\n        MP_(numReplicates),\n        MP_(pointsTotal),\n        MP_(refineCVFolds),\n        MP_(softConvergenceLimit),\n        MP_(subMethodProcs),\n        MP_(subMethodServers),\n        MP_(subspaceDimension),\n        MP_(subspaceCVMaxRank);\n\n#undef MP2s\n#undef MP2\n#undef MP_\n\n#define MP_(x) DataResponsesRep::* resp_mp_##x = &DataResponsesRep::x\n#define MP2(x,y) resp_mp_##x##_##y = {&DataResponsesRep::x,#y}\n#define MP2s(x,y) resp_mp_##x##_##y = {&DataResponsesRep::x,y}\n\nstatic IntSet\n\tMP_(idAnalyticGrads),\n\tMP_(idAnalyticHessians),\n\tMP_(idNumericalGrads),\n\tMP_(idNumericalHessians),\n\tMP_(idQuasiHessians);\n\nstatic IntVector\n\tMP_(fieldLengths),\n\tMP_(numCoordsPerField);\n\nstatic RealVector\n\tMP_(expConfigVars),\n\tMP_(expObservations),\n\tMP_(primaryRespFnWeights),\n\tMP_(nonlinearEqTargets),\n\tMP_(nonlinearIneqLowerBnds),\n\tMP_(nonlinearIneqUpperBnds),\n\tMP_(simVariance),\n\tMP_(fdGradStepSize),\n\tMP_(fdHessStepSize),\n\tMP_(primaryRespFnScales),\n\tMP_(nonlinearEqScales),\n\tMP_(nonlinearIneqScales);\n\nstatic Resp_mp_lit\n\tMP2(gradientType,analytic),\n\tMP2(gradientType,mixed),\n\tMP2(gradientType,none),\n\tMP2(gradientType,numerical),\n\tMP2(hessianType,analytic),\n\tMP2(hessianType,mixed),\n\tMP2(hessianType,none),\n\tMP2(hessianType,numerical),\n\tMP2(hessianType,quasi),\n\tMP2(intervalType,central),\n\tMP2(intervalType,forward),\n\tMP2(methodSource,dakota),\n\tMP2(methodSource,vendor),\n        MP2(fdGradStepType,absolute),\n        MP2(fdGradStepType,bounds),\n        MP2(fdGradStepType,relative),\n        MP2(fdHessStepType,absolute),\n        MP2(fdHessStepType,bounds),\n        MP2(fdHessStepType,relative),\n\tMP2(quasiHessianType,bfgs),\n\tMP2(quasiHessianType,damped_bfgs),\n\tMP2(quasiHessianType,sr1);\n\nstatic String\n\tMP_(scalarDataFileName),\n        MP_(idResponses);\n\nstatic StringArray\n\tMP_(nonlinearEqScaleTypes),\n\tMP_(nonlinearIneqScaleTypes),\n\tMP_(primaryRespFnScaleTypes),\n\tMP_(primaryRespFnSense),\n\tMP_(responseLabels),\n\tMP_(varianceType);\n\nstatic bool\n\tMP_(calibrationDataFlag),\n\tMP_(centralHess),\n\tMP_(interpolateFlag),\n        MP_(ignoreBounds),\n        MP_(readFieldCoords);\n\nstatic size_t\n\tMP_(numExpConfigVars),\n        MP_(numExperiments),\n\tMP_(numFieldLeastSqTerms),\n\tMP_(numFieldObjectiveFunctions),\n\tMP_(numFieldResponseFunctions),\n\tMP_(numLeastSqTerms),\n\tMP_(numNonlinearEqConstraints),\n\tMP_(numNonlinearIneqConstraints),\n\tMP_(numObjectiveFunctions),\n\tMP_(numResponseFunctions),\n\tMP_(numScalarLeastSqTerms),\n\tMP_(numScalarObjectiveFunctions),\n\tMP_(numScalarResponseFunctions);\n\nstatic Resp_mp_utype\n        MP2s(scalarDataFormat,TABULAR_NONE),\n        MP2s(scalarDataFormat,TABULAR_HEADER),\n        MP2s(scalarDataFormat,TABULAR_EVAL_ID),\n        MP2s(scalarDataFormat,TABULAR_EXPER_ANNOT);\n \n#undef MP2s\n#undef MP2\n#undef MP_\n\n// Macros for Environment\n\n#define MP_(x) DataEnvironmentRep::* env_mp_##x = &DataEnvironmentRep::x\n#define MP2s(x,y) env_mp_##x##_##y = {&DataEnvironmentRep::x,y}\n\n//static Env_mp_lit\n//      MP2(,);\n\nstatic Env_mp_utype\n        MP2s(postRunInputFormat,TABULAR_NONE),\n        MP2s(postRunInputFormat,TABULAR_HEADER),\n        MP2s(postRunInputFormat,TABULAR_EVAL_ID),\n        MP2s(postRunInputFormat,TABULAR_IFACE_ID),\n        MP2s(postRunInputFormat,TABULAR_ANNOTATED),\n        MP2s(preRunOutputFormat,TABULAR_NONE),\n        MP2s(preRunOutputFormat,TABULAR_HEADER),\n        MP2s(preRunOutputFormat,TABULAR_EVAL_ID),\n        MP2s(preRunOutputFormat,TABULAR_IFACE_ID),\n        MP2s(preRunOutputFormat,TABULAR_ANNOTATED),\n        MP2s(tabularFormat,TABULAR_NONE),\n        MP2s(tabularFormat,TABULAR_HEADER),\n        MP2s(tabularFormat,TABULAR_EVAL_ID),\n        MP2s(tabularFormat,TABULAR_IFACE_ID),\n        MP2s(tabularFormat,TABULAR_ANNOTATED),\n        MP2s(resultsOutputFormat,RESULTS_OUTPUT_TEXT),\n        MP2s(resultsOutputFormat,RESULTS_OUTPUT_HDF5);\n\nstatic String\n        MP_(errorFile),\n        MP_(outputFile),\n        MP_(postRunInput),\n        MP_(postRunOutput),\n        MP_(preRunInput),\n        MP_(preRunOutput),\n        MP_(readRestart),\n        MP_(resultsOutputFile),\n        MP_(runInput),\n        MP_(runOutput),\n\tMP_(tabularDataFile),\n        MP_(topMethodPointer),\n        MP_(writeRestart);\n\nstatic bool\n\tMP_(checkFlag),\n\tMP_(graphicsFlag),\n\tMP_(postRunFlag),\n\tMP_(preRunFlag),\n        MP_(resultsOutputFlag),\n\tMP_(runFlag),\n\tMP_(tabularDataFlag);\n\nstatic int\n        MP_(outputPrecision),\n        MP_(stopRestart);\n\n//#undef MP2\n#undef MP2s\n#undef MP_\n\n#define MP_(x) DataVariablesRep::* var_mp_##x = &DataVariablesRep::x\n#define MP2s(x,y) var_mp_##x = {&DataVariablesRep::x,y}\n#define VP_(x) *Var_Info::* var_mp_Var_Info_##x = &Var_Info::x\n#define Vtype(x,y) var_mp_##x##_##y = {&DataVariablesRep::x,y}\n\nstatic size_t\n\tMP_(numBetaUncVars),\n\tMP_(numBinomialUncVars),\n\tMP_(numContinuousDesVars),\n\tMP_(numContinuousIntervalUncVars),\n\tMP_(numContinuousStateVars),\n\tMP_(numDiscreteDesRangeVars),\n\tMP_(numDiscreteDesSetIntVars),\n\tMP_(numDiscreteDesSetStrVars),\n\tMP_(numDiscreteDesSetRealVars),\n\tMP_(numDiscreteIntervalUncVars),\n\tMP_(numDiscreteStateRangeVars),\n\tMP_(numDiscreteStateSetIntVars),\n\tMP_(numDiscreteStateSetStrVars),\n\tMP_(numDiscreteStateSetRealVars),\n\tMP_(numDiscreteUncSetIntVars),\n\tMP_(numDiscreteUncSetStrVars),\n\tMP_(numDiscreteUncSetRealVars),\n\tMP_(numExponentialUncVars),\n\tMP_(numFrechetUncVars),\n\tMP_(numGammaUncVars),\n\tMP_(numGeometricUncVars),\n\tMP_(numGumbelUncVars),\n\tMP_(numHistogramBinUncVars),\n\tMP_(numHistogramPtIntUncVars),\n\tMP_(numHistogramPtStrUncVars),\n\tMP_(numHistogramPtRealUncVars),\n\tMP_(numHyperGeomUncVars),\n\tMP_(numLognormalUncVars),\n\tMP_(numLoguniformUncVars),\n\tMP_(numNegBinomialUncVars),\n\tMP_(numNormalUncVars),\n\tMP_(numPoissonUncVars),\n\tMP_(numTriangularUncVars),\n\tMP_(numUniformUncVars),\n\tMP_(numWeibullUncVars);\n\nstatic IntVector\n\tVP_(ddsi),\n\tVP_(DIlb),\n\tMP_(discreteDesignRangeLowerBnds),\n\tMP_(discreteDesignRangeUpperBnds),\n\tMP_(discreteDesignRangeVars),\n\tMP_(discreteDesignSetIntVars),\n\tMP_(discreteIntervalUncVars),\n        MP_(discreteStateRangeLowerBnds),\n\tMP_(discreteStateRangeUpperBnds),\n\tMP_(discreteStateRangeVars),\n\tMP_(discreteStateSetIntVars),\n\tMP_(discreteUncSetIntVars),\n\tVP_(DIub),\n        MP_(histogramPointIntUncVars),\n        VP_(hpia),\n        VP_(dssi),\n        VP_(ddsia),\n        VP_(ddssa),\n        VP_(ddsra),\n        VP_(dusi);\n\nstatic IntArray\n\tVP_(nddsi),\n\tVP_(nddss),\n\tVP_(nddsr),\n\tVP_(ndssi),\n\tVP_(ndsss),\n\tVP_(ndssr),\n\tVP_(ndusi),\n\tVP_(nduss),\n\tVP_(ndusr),\n\tVP_(nhbp),\n\tVP_(nhpip),\n\tVP_(nhpsp),\n\tVP_(nhprp),\n\tVP_(nCI),\n\tVP_(nDI);\n\nstatic RealVector\n\tMP_(betaUncLowerBnds),\n\tMP_(betaUncUpperBnds),\n\tMP_(betaUncVars),\n        MP_(binomialUncProbPerTrial),\n        MP_(continuousDesignLowerBnds),\n\tMP_(continuousDesignUpperBnds),\n\tMP_(continuousDesignVars),\n\tMP_(continuousDesignScales),\n\tMP_(continuousIntervalUncVars),\n\tMP_(continuousStateLowerBnds),\n\tMP_(continuousStateUpperBnds),\n\tMP_(continuousStateVars),\n\tMP_(discreteDesignSetRealVars),\n\tMP_(discreteStateSetRealVars),\n\tMP_(discreteUncSetRealVars),\n\tMP_(frechetUncBetas),\n\tMP_(frechetUncVars),\n        MP_(geometricUncProbPerTrial),\n\tMP_(gumbelUncBetas),\n\tMP_(gumbelUncVars),\n\tMP_(histogramBinUncVars),\n        MP_(histogramPointRealUncVars),\n\tMP_(linearEqConstraintCoeffs),\n\tMP_(linearEqScales),\n\tMP_(linearEqTargets),\n\tMP_(linearIneqConstraintCoeffs),\n\tMP_(linearIneqLowerBnds),\n\tMP_(linearIneqUpperBnds),\n\tMP_(linearIneqScales),\n        MP_(negBinomialUncProbPerTrial),\n\tMP_(normalUncLowerBnds),\n\tMP_(normalUncMeans),\n\tMP_(normalUncUpperBnds),\n\tMP_(normalUncVars),\n\tMP_(triangularUncModes),\n\tMP_(triangularUncVars),\n\tMP_(uniformUncVars),\n\tMP_(weibullUncVars),\n\tVP_(ddsr),\n\tVP_(dssr),\n\tVP_(dusr),\n\tVP_(CIlb),\n\tVP_(CIub),\n\tVP_(CIp),\n\tVP_(DIp),\n\tVP_(DSIp),\n\tVP_(DSSp),\n\tVP_(DSRp),\n\tVP_(hba),\n\tVP_(hbo),\n\tVP_(hbc),\n\tVP_(hpic),\n\tVP_(hpsc),\n\tVP_(hpra),\n\tVP_(hprc),\n\tVP_(ucm);\n\nstatic String\n\tMP_(idVariables);\n\nstatic StringArray\n\tMP_(continuousDesignLabels),\n\tMP_(continuousDesignScaleTypes),\n\tMP_(continuousStateLabels),\n\tMP_(discreteDesignRangeLabels),\n\tMP_(discreteDesignSetIntLabels),\n\tMP_(discreteDesignSetStrLabels),\n\tMP_(discreteDesignSetRealLabels),\n\tMP_(discreteStateRangeLabels),\n\tMP_(discreteStateSetIntLabels),\n\tMP_(discreteStateSetStrLabels),\n        MP_(discreteStateSetRealLabels),\n\tMP_(discreteDesignSetStrVars),\n\tMP_(discreteUncSetStrVars),\n\tMP_(discreteStateSetStrVars),\n        MP_(histogramPointStrUncVars),\n\tMP_(linearEqScaleTypes),\n\tMP_(linearIneqScaleTypes),\n        VP_(hpsa),\n        VP_(ddss),\n        VP_(duss),\n        VP_(dsss);\n\nstatic BitArray\n        MP_(discreteDesignSetIntCat),\n        MP_(discreteDesignSetRealCat),\n        MP_(discreteStateSetIntCat),\n        MP_(discreteStateSetRealCat),\n        MP_(discreteUncSetIntCat),\n        MP_(discreteUncSetRealCat);\n\nstatic Var_brv\n\tMP2s(betaUncAlphas,0.),\n\tMP2s(betaUncBetas,0.),\n\tMP2s(exponentialUncBetas,0.),\n\tMP2s(exponentialUncVars,0.),\n\tMP2s(frechetUncAlphas,2.),\n\tMP2s(gammaUncAlphas,0.),\n\tMP2s(gammaUncBetas,0.),\n\tMP2s(gammaUncVars,0.),\n\tMP2s(gumbelUncAlphas,0.),\n\tMP2s(lognormalUncErrFacts,1.),\n\tMP2s(lognormalUncLambdas,0.),\n\tMP2s(lognormalUncLowerBnds,0.),\n\tMP2s(lognormalUncMeans,0.),\n\tMP2s(lognormalUncStdDevs,0.),\n\tMP2s(lognormalUncUpperBnds,std::numeric_limits<Real>::infinity()),\n\tMP2s(lognormalUncVars,0.),\n\tMP2s(lognormalUncZetas,0.),\n\tMP2s(loguniformUncLowerBnds,0.),\n\tMP2s(loguniformUncUpperBnds,std::numeric_limits<Real>::infinity()),\n\tMP2s(loguniformUncVars,0.),\n\tMP2s(normalUncStdDevs,0.),\n\tMP2s(poissonUncLambdas,0.),\n\tMP2s(triangularUncLowerBnds,-std::numeric_limits<Real>::infinity()),\n\tMP2s(triangularUncUpperBnds, std::numeric_limits<Real>::infinity()),\n\tMP2s(uniformUncLowerBnds,-std::numeric_limits<Real>::infinity()),\n\tMP2s(uniformUncUpperBnds, std::numeric_limits<Real>::infinity()),\n\tMP2s(weibullUncAlphas,0.),\n\tMP2s(weibullUncBetas,0.);\n\nstatic Var_biv\n\tMP2s(binomialUncNumTrials,0),\n\tMP2s(binomialUncVars,0),\n\tMP2s(geometricUncVars,0),\n\tMP2s(hyperGeomUncNumDrawn,0),\n\tMP2s(hyperGeomUncSelectedPop,0),\n\tMP2s(hyperGeomUncTotalPop,0),\n\tMP2s(hyperGeomUncVars,0),\n\tMP2s(negBinomialUncNumTrials,0),\n\tMP2s(negBinomialUncVars,0),\n\tMP2s(poissonUncVars,0);\n\nstatic Var_mp_type\n\tVtype(varsDomain,MIXED_DOMAIN),\n\tVtype(varsDomain,RELAXED_DOMAIN),\n\tVtype(varsView,ALL_VIEW),\n\tVtype(varsView,DESIGN_VIEW),\n\tVtype(varsView,UNCERTAIN_VIEW),\n\tVtype(varsView,ALEATORY_UNCERTAIN_VIEW),\n\tVtype(varsView,EPISTEMIC_UNCERTAIN_VIEW),\n        Vtype(varsView,STATE_VIEW);\n\n#undef Vtype\n#undef VP_\n#undef MP2s\n#undef MP_\n\n} // namespace Dakota\n\n#undef Warn\n#undef Squawk\n\n#define N_ifm(x,y)\tNIDRProblemDescDB::iface_##x,&iface_mp_##y\n#define N_ifm3(x,y,z)\tNIDRProblemDescDB::iface_##x,y,NIDRProblemDescDB::iface_##z\n#define N_mdm(x,y)\tNIDRProblemDescDB::method_##x,&method_mp_##y\n//#define N_mdf(x,y)\tN_mdm(x,y),NIDRProblemDescDB::method_##x##_final\n#define N_mdm3(x,y,z)\tNIDRProblemDescDB::method_##x,y,NIDRProblemDescDB::method_##z\n#define N_mom(x,y)\tNIDRProblemDescDB::model_##x,&model_mp_##y\n#define N_mof(x,y)\tN_mom(x,y),NIDRProblemDescDB::model_##x##_final\n#define N_mom3(x,y,z)\tNIDRProblemDescDB::model_##x,y,NIDRProblemDescDB::model_##z\n#define N_rem(x,y)\tNIDRProblemDescDB::resp_##x,&resp_mp_##y\n#define N_rem3(x,y,z)\tNIDRProblemDescDB::resp_##x,y,NIDRProblemDescDB::resp_##z\n#define N_stm(x,y)\tNIDRProblemDescDB::env_##x,&env_mp_##y\n#define N_vae(x,y)\tNIDRProblemDescDB::var_##x,(void*)y\n#define N_vam(x,y)\tNIDRProblemDescDB::var_##x,&var_mp_##y\n#define N_vam3(x,y,z)\tNIDRProblemDescDB::var_##x,y,NIDRProblemDescDB::var_##z\n\n#include \"NIDR_keywds.hpp\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/DLSolver.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (dl_constructor_t)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (dl_constructor_t)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#include <stdarg.h>\n#include \"DLSolver.hpp\"\n#include \"ProblemDescDB.hpp\"\n\n#ifdef DLSOLVER_DEBUG_UNLOCK\n// This is only needed for the simplest example, dlsolvers/dl_npsol.C,\n// which uses as much of DAKOTA's machinery for NPSOL as possible.\n// (This machinery is compiled into DAKOTA unless configured with --without-npsol).\n// The corresponding dl_npsol.dll is not loaded until the database is locked,\n// but dl_npsol.dll then invokes \"new NPSOLOptimizer(...)\", which needs to\n// have the database unlocked.  Note that unlocking then may give wrong results\n// in multi-specification runs.  The configure machinery does not know about\n// compilation with -DDLSOLVER_DEBUG_UNLOCK, since it is only meant for use\n// in special cases by knowledgeable developers.\n#define DEBUG_unlock probDescDB.unlock();\n#define DEBUG_lock probDescDB.lock();\n#else\n#define DEBUG_unlock /*default: do nothing*/\n#define DEBUG_lock   /*default: do nothing*/\n#endif\n\n#define NO_DAKOTA_DLSOLVER_FUNCS_INLINE\n#include \"DLSfuncs.hpp\"\n\nnamespace Dakota {\n\n static RealVector const *\ncontinuous_lower_bounds1(Optimizer1 *o)\n{ return &o->M->continuous_lower_bounds(); }\n\n static RealVector const *\ncontinuous_upper_bounds1(Optimizer1 *o)\n{ return &o->M->continuous_upper_bounds(); }\n\n static RealVector const *\nnonlinear_ineq_constraint_lower_bounds1(Optimizer1 *o)\n{ return &o->M->nonlinear_ineq_constraint_lower_bounds(); }\n\n static RealVector const *\nnonlinear_ineq_constraint_upper_bounds1(Optimizer1 *o)\n{ return &o->M->nonlinear_ineq_constraint_upper_bounds(); }\n\n static RealVector const *\nnonlinear_eq_constraint_targets1(Optimizer1 *o)\n{ return &o->M->nonlinear_eq_constraint_targets(); }\n\n static RealVector const *\nlinear_ineq_constraint_lower_bounds1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_lower_bounds(); }\n\n static RealVector const *\nlinear_ineq_constraint_upper_bounds1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_upper_bounds(); }\n\n static RealVector const *\nlinear_eq_constraint_targets1(Optimizer1 *o)\n{ return &o->M->linear_eq_constraint_targets(); }\n\n static RealMatrix const *\nlinear_eq_constraint_coeffs1(Optimizer1 *o)\n{ return &o->M->linear_eq_constraint_coeffs(); }\n\n static RealMatrix const *\nlinear_ineq_constraint_coeffs1(Optimizer1 *o)\n{ return &o->M->linear_ineq_constraint_coeffs(); }\n\n static void\nComputeResponses1(Optimizer1 *o, int mode, int n, double *x)\n{\n\t// without the printf, g++ generates incorrect code\n\tif (n < 0)\n\t\tprintf(\"ComputeResponses1 has o = #%x, mode = %d, n = %d, x = #%x\\n\",\n\t\t\to, mode, n, x);\n\tRealVector lx(n);\n\tcopy_data(x, n, lx);\n\to->M->continuous_variables(lx);\n\to->activeSet_()->request_values(mode);\n\to->M->evaluate(*o->activeSet_());\n\t}\n\n static void\nGetFuncs1(Optimizer1 *o, int m0, int m1, double *f)\n{\n\tResponse const *R = &o->M->current_response();\n\tRealVector const *RV = &R->function_values();\n\tfor(int i = m0; i < m1; i++)\n\t\tf[i-m0] = (*RV)[i];\n\t}\n\n static void\nGetGrads1(Optimizer1 *o, int m0, int m1, int n, int is, int js, double *g)\n{\n\tint i, i1, j;\n\tResponse const *R = &o->M->current_response();\n\tRealMatrix const *RM = &R->function_gradients();\n\tReal const *RV;\n\n\tfor(i1 = 0, i = m0; i < m1; i++, i1 += is) {\n\t\tRV = (*RM)[i];\n\t\tfor(j = 0; j < n; j++)\n\t\t\tg[i1 + j*js] = RV[j];\n\t\t}\n\t}\n\n static void\nGetContVars1(Optimizer1 *o, int n, double *x)\n{ memcpy(x, &o->M->continuous_variables()[0], n*sizeof(double)); }\n\n static void\nSetBestContVars1(Optimizer1 *o, int n, double *x)\n{\n\tint i;\n\tRealVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestVariables_()->continuous_variables(X);\n\t}\n\n static void\nSetBestDiscVars1(Optimizer1 *o, int n, int *x)\n{\n\tint i;\n\tIntVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestVariables_()->discrete_int_variables(X);\n\t}\n\n static void\nSetBestRespFns1(Optimizer1 *o, int n, double *x)\n{\n\tint i;\n\tRealVector X(n);\n\tfor(i = 0; i < n; i++)\n\t\tX[i] = x[i];\n\to->bestResponse_()->function_values(X);\n\t}\n\n static double\nGet_Real1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_real(name);\n\t}\n\n static int\nGet_Int1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_int(name);\n\t}\n\n static bool\nGet_Bool1(Optimizer1*o, const char* name)\n{\n\treturn o->problem_description_db().get_bool(name);\n\t}\n\nDakota_funcs DakFuncs0 = {\n\tfprintf,\n\tabort_handler,\n\tdlsolver_option,\n\tcontinuous_lower_bounds1,\n\tcontinuous_upper_bounds1,\n\tnonlinear_ineq_constraint_lower_bounds1,\n\tnonlinear_ineq_constraint_upper_bounds1,\n\tnonlinear_eq_constraint_targets1,\n\tlinear_ineq_constraint_lower_bounds1,\n\tlinear_ineq_constraint_upper_bounds1,\n\tlinear_eq_constraint_targets1,\n\tlinear_ineq_constraint_coeffs1,\n\tlinear_eq_constraint_coeffs1,\n\tComputeResponses1,\n\tGetFuncs1,\n\tGetGrads1,\n\tGetContVars1,\n\tSetBestContVars1,\n\tSetBestDiscVars1,\n\tSetBestRespFns1,\n\tGet_Real1,\n\tGet_Int1,\n\tGet_Bool1\n\t};\n\n void\nDLSolver::cleanup()\n{\n\tvoid *h;\n\tif (h = dlLib) {\n\t\tdlLib = NULL;\n\t\tif (dl_destructor)\n\t\t\t(*dl_destructor)(&dl_Optimizer);\n\t\tdlclose(h);\n\t\tif (pdlLib)\n\t\t\t*pdlLib = 0;\n\t\t}\n\tif (details) {\n\t\tdelete[] details;\n\t\tdetails = 0;\n\t\t}\n\tif (DF) {\n\t\tdelete DF;\n\t\tDF = 0;\n\t\t}\n\t}\n\n void\nDLSolver::botch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\nDLSolver Error: \");\n\tvfprintf(stderr, fmt, ap);\n\tputc('\\n', stderr);\n\tva_end(ap);\n\tfflush(stderr);\n\tcleanup();\n\tabort_handler(-1);\n\t}\n\nDLSolver::DLSolver(Model& model):\n\tOptimizer1(model, std::shared_ptr<TraitsBase>(new DLSolverTraits())),\n\tdl_core_run(0), dl_destructor(0), dlLib(0)\n{\n\tconst String &dlDetails = probDescDB.get_string(\"method.dl_solver.dlDetails\");\n\tchar *s, *s0;\n\tsize_t L;\n\tvoid *h, **vp;\n\n\tDF = 0;\n\tL = strlen(s0 = dlDetails.data()) + 1;\n\tdetails = s = new char[L];\n\tif (!s)\n\t\tbotch(\"new(%lu) failure in DLSolver::DLSolver.\", (unsigned long) L);\n\tmemcpy(s, s0, L);\n\tvp = probDescDB.get_voidss(\"method.dl_solver.dlLib\");\n\tpdlLib = *vp ? vp : 0;\n\t}\n\nDLSolver::~DLSolver()\n{ cleanup(); }\n\n void\nDLSolver::core_run()\n{\n\tDakota_funcs *df;\n\tDakota_probsize ps;\n\tchar *s, *s0;\n\ttypedef void* (*dl_constructor_t)(Optimizer1*, Dakota_funcs*,\n\t\t\tdl_core_run_t*, dl_destructor_t*);\n\tdl_constructor_t dl_constructor;\n\tvoid *h;\n\tif (!dl_core_run) {\t// Load the shared library if this is\n\t\t\t\t// the first core_run() invocation.\n\t\tdf = DF = new Dakota_funcs;\n\t\tif (!df)\n\t\t\tbotch(\"new Dakota_Funcs failure\");\n\t\tmemcpy(df, &DakFuncs0, sizeof(Dakota_funcs));\n\t\tfor(s0 = s = details; *s > ' '; s++);\n\t\tif (s == s0)\n\t\t\tbotch(\"dlDetails not given for dl_solver.\");\n\t\tif (*s)\n\t\t\t*s++ = 0;\n\t\tif (pdlLib)\n\t\t\th = *pdlLib;\n\t\telse\n\t\t\th = dlopen(s0, RTLD_NOW/*RTLD_LAZY*/);\n\t\tif (!h)\n#ifdef NO_DLERROR\n\t\t\tbotch(\"dlopen(\\\"%s\\\") failure\", s0);\n#else\n\t\t\tbotch(\"dlopen(\\\"%s\\\") failure:\\n%s\", s0, dlerror());\n#endif\n\t\tdlLib = h;\n\t\tif (!(find_dlsym(dl_constructor, h, \"dl_constructor\")))\n\t\t\tbotch(\"dlsym(\\\"dl_constructor\\\") failed in \\\"%s\\\"\", s0);\n\t\twhile(*s && *s <= ' ')\n\t\t\t++s;\n\t\toptions = s;\n\t\tdf->Stderr = stderr;\n\t\tdf->dakota_cerr = dakota_cerr;\n\t\tdf->dakota_cout = dakota_cout;\n\t\tDEBUG_unlock\n\t\tdl_Optimizer = (*dl_constructor)(this, df, &dl_core_run, &dl_destructor);\n\t\tDEBUG_lock\n\t\t}\n\tif (dl_core_run) {\n\t\tdf = DF;\n\t\tdf->Stderr = stderr;\n\t\tdf->dakota_cerr = dakota_cerr;\n\t\tdf->dakota_cout = dakota_cout;\n\t\tps.n_var = numContinuousVars_();\n\t\tps.n_linc = numLinearConstraints_();\n\t\tps.n_nlinc = numNonlinearConstraints_();\n\t\tps.n_obj = numObjectiveFunctions_();\n\t\tps.maxfe = maxFunctionEvals_();\n\t\tps.numgflag = vendorNumericalGradFlag_();\n\t\tps.objrecast = localObjectiveRecast_();\n\t\tdf->ps = &ps;\n\t\tM = iteratedModel_();\n\t\t(*dl_core_run)(dl_Optimizer, this, options);\n\t\t}\n\telse\n\t\tbotch(\"dl_core_run is null in core_run\");\n\t}\n\n int\ndlsolver_option(Opt_Info *Oi)\n{\n\tchar *in, *in0, *s, *val0;\n\tint c;\n\n\tif (!(in = Oi->begin))\n\t\treturn 0;\n\twhile(*in <= ' ')\n\t\tif (!*in++)\n\t\t\treturn 0;\n\tOi->name = in0 = in;\n\tfor(; (c = *in) > ' '; ++in) {\n\t\tif (c == '_')\n\t\t\t*in = Oi->und_repl;\n\t\telse if (c == '=') {\n\t\t\t*in = Oi->eq_repl;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tOi->name_len = in - in0;\n\tif (c == '=')\n\t\t++in;\n\tif (!*in) {\n no_val:\n\t\tOi->val = 0;\n\t\tOi->val_len = 0;\n\t\tOi->begin = in;\n\t\tOi->all_len = Oi->name_len;\n\t\treturn 1;\n\t\t}\n\tfor(; (c = *in) <= ' '; ++in) {\n\t\tif (!c)\n\t\t\tgoto no_val;\n\t\t}\n\tif (c == '=') {\n\t\t*in++ = Oi->eq_repl;\n\t\twhile((c = *++in) <= ' ') {\n\t\t\tif (!c)\n\t\t\t\tgoto no_val;\n\t\t\t}\n\t\t}\n\tOi->val = val0 = in;\n\tif (c == '\\'') {\n\t\tfor(s = in;;) {\n\t\t\tc = *++in;\n\t\t\tif (c == '\\'') {\n\t\t\t\tif (*++in != '\\'')\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\telse if (!c)\n\t\t\t\tbreak;\n\t\t\t*s++ = c;\n\t\t\t}\n\t\t*s = 0;\n\t\tOi->val_len = s - val0;\n\t\t}\n\telse {\n\t\twhile(*++in > ' ');\n\t\tOi->val_len = in - val0;\n\t\t}\n\twhile((c = *in) && c <= ' ')\n\t\t++in;\n\tOi->begin = in;\n\tOi->all_len = in - in0;\n\treturn 1;\n\t}\n\n} // namespace Dakota\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/DLSolverLoadLibManager.cpp": "/*  _______________________________________________________________________\n\n    DAKOTA: Design Analysis Kit for Optimization and Terascale Applications\n    Copyright 2014 Sandia Corporation.\n    This software is distributed under the GNU Lesser General Public License.\n    For more information, see the README file in the top Dakota directory.\n    _______________________________________________________________________ */\n\n//- Class:        Iterator\n//- Description:  Dynamic library load manager for third-party solver packages.\n//- Version: $Id$\n\n// NOTE:  THIS IS NOT ACTIVE CODE\n//\n// It is just a \"buffer\" to maintain a record of a commit that is no longer\n// maintained.  Revs related to DLib management (in the mid-May 2010)\n// were deemed inappropriate to add to the top of DakotaIterator.cpp from\n// the perperspective of DAKOTA code design/modularity.  Therefore, the\n// code has been de-activated and moved into this source file for posterity.\n//\n// Assuming we do want to maintain \"DL LoadManagement\" capabability, these\n// typedefs/functions/\"iterator\" prototypes should be re-designed and \n// implemented in a new component for DAKOTA (e.g. DynLoadLib Manager?).\n\n#include \"dakota_system_defs.hpp\"\n#include \"dakota_global_defs.hpp\"\n\n/* WJB: re-enable dependencies class-wrappers only if necessary\n#ifdef HAVE_DOT\n#include \"DOTOptimizer.hpp\"\n#endif\n#ifdef HAVE_NLPQL\n#include \"NLPQLPOptimizer.hpp\"\n#endif\n#ifdef HAVE_NPSOL\n#include \"NPSOLOptimizer.hpp\"\n#include \"NLSSOLLeastSq.hpp\"\n#endif\n// WJB: end of re-enable dependencies comment */\n\n#if(defined(HAVE_DOT) || defined(HAVE_JEGA) || defined(HAVE_NLPQL) ||               defined(HAVE_NPSOL)) \n\n#ifdef DAKOTA_SHLIB\n#undef DAKOTA_DYNLIB\n\ntypedef void (*p_vf)(void);\n\n// WJB - ToDo: prefer function over macro\n#ifdef _WIN32\n#include \"dakota_windows.h\"\n#define find_dlsym(a,b,c) (a = (p_vf)GetProcAddress((HINSTANCE)(b),c))\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = dlsym(b,c))\n#undef NO_DLERROR\n#endif\n\n\ntypedef struct Libentry\n{\n  const char *name;\n  p_vf f;\n} Libentry;\n\ntypedef struct SharedLib\n{\n  const char *libname;\n  size_t nentries;\n  Libentry *Entries;\n} SharedLib;\n\nstruct NIDR_KWlib;\nextern \"C\" NIDR_KWlib *nidr_lib_record(void *, const char*);\nextern \"C\" void *nidr_dlopen(const char*);\n\n\nstatic p_vf Lib_load(SharedLib *L, int k)\n{\n  Libentry *e, *ee;\n  const char *lname;\n\n  void* h = nidr_dlopen(lname = L->libname);\n  if (!h) {\n#ifndef NO_DLERROR\n    if ((const char* s = dlerror()))\n      std::cerr << \"Cannot open library \\\"\" << lname << \"\\\":\\n\\t\" << s;\n    else\n#endif\n      std::cerr << \"Cannot open library \\\"\" << lname << \"\\n\";\n    std::exit(1);\n  }\n  nidr_lib_record(h, L->libname); // for cleanup (e.g., dlclose()) at endOf exec\n  e = L->Entries;\n  ee = e + L->nentries;\n\n  for(ee = e + L->nentries; e < ee; ++e)\n    if (!find_dlsym(e->f, h, e->name)) {\n      std::cerr << \"Could not find \" << e->name << \" in library \"\n                << lname << \"\\n\";\n      std::exit(2);\n    }\n\n  return L->Entries[k].f;\n}\n\n\nstatic Libentry\n  Dot_entries[] = { {\"dot_\"}, {\"dot510_\"} },\n  Npsol_entries[] = { {\"npsol_\"}, {\"nlssol_\"}, {\"npoptn2_\"} },\n  Nlpql_entries[] = { {\"nlpqlp_\"}, {\"ql_\"} };\n\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n\nstatic SharedLib\n  Dot_lib = { \"libdot.dll\", NumberOf(Dot_entries), Dot_entries },\n  Npsol_lib = { \"libnpsol.dll\", NumberOf(Npsol_entries), Npsol_entries },\n  Nlpql_lib = { \"libnlpql.dll\", NumberOf(Nlpql_entries), Nlpql_entries };\n\n\n// WJB - Dakota C++ style: obtain prototypes from their respective header files\n#define DOT F77_FUNC(dot,DOT)\n#define DOT510 F77_FUNC(dot510,DOT510)\n#define NPSOL F77_FUNC(npsol,NPSOL)\n#define NLSSOL F77_FUNC(nlssol,NLSSOL)\n// BMA (20160315): Changed to use Fortran 2003 ISO C bindings.\n// The Fortran symbol will be lowercase with same name as if in C\n//#define NPOPTN2 F77_FUNC(npoptn2,NPOPTN2)\n#define NPOPTN2 npoptn2\n#define NLPQLP F77_FUNC(nlpqlp,NLPQLP)\n#define QL F77_FUNC(ql,QL)\n\n/* WJB - ToDo:  verify redeclaration of an existing function and REMOVE!\nextern \"C\" void DOT(int *info, int *ngotoz, int *method,\n        int *iprint, int *ndv, int *ncon, double *x,\n        double *xl, double *xu, double *obj, int *minmax,\n        double *g, double *rprm, int *iprm, double *wk,\n        int *nrwk, int *iwk, int *nriwk)\n{\n        typedef void (*DOT_t)(int *, int *, int *,\n                        int *, int *, int *, double *,\n                        double *, double *, double *, int *,\n                        double *, double *, int *, double *,\n                        int *, int *, int *);\n        DOT_t f;\n        if (!(f = (DOT_t)Dot_entries[0].f))\n                f = (DOT_t)Lib_load(&Dot_lib, 0);\n        f(info, ngotoz, method, iprint, ndv, ncon, x, xl, xu, obj,\n          minmax, g, rprm, iprm, wk, nrwk, iwk, nriwk);\n}\n\nextern \"C\" void DOT510(int *ndv, int *ncon, int *ncola,  int *method, int *nrwk,\n        int *nriwk, int *nrb, int *ngmax, double *xl, double *xu)\n{\n        typedef void (*DOT510_t)(int *, int *, int *,  int *, int *, int *,\n                                int *, int *, double *, double *);\n        DOT510_t f;\n        if (!(f = (DOT510_t)Dot_entries[1].f))\n                f = (DOT510_t)Lib_load(&Dot_lib, 1);\n        f(ndv, ncon, ncola,  method, nrwk, nriwk, nrb, ngmax, xl, xu);\n}\n\nextern \"C\" void NPSOL(int *n, int *nclin, int *ncnln,\n        int *lda, int *ldju, int *ldr, double *a, double *bl, double *bu,\n        p_vf funcon, p_vf funobj, int *inform,  int *iter, int *istate,\n        double *c, double *cjacu, double *clamda, double *objf,\n        double *gradu, double *r, double *x, int *iw, int *leniw,\n        double *w, int *lenw)\n{\n        typedef void (*NPSOL_t)(int *, int *, int *, int *, int *,\n                        int *, double *, double *, double *, p_vf, p_vf,\n                        int *, int *, int *, double *, double *, double *,\n                        double *, double *, double *, double *, int *,\n                        int *, double *, int *);\n        NPSOL_t f;\n        if (!(f = (NPSOL_t)Npsol_entries[0].f))\n                f = (NPSOL_t)Lib_load(&Npsol_lib, 0);\n        f(n, nclin, ncnln, lda, ldju, ldr, a, bl, bu, funcon, funobj,\n          inform, iter, istate, c, cjacu, clamda, objf, gradu, r, x,\n          iw, leniw, w, lenw);\n}\n\nextern \"C\" void NLSSOL(int *m, int *n, int *nclin, int *ncnln, int *lda,\n        int *ldcju, int *ldfju, int *ldr, double *a, double *bl, double *bu,\n        p_vf funcon, p_vf funobj, int *inform, int *iter, int *istate,\n        double *c, double *cjacu, double *y, double *f, double *fjacu,\n        double *clamda, double *objf, double *r, double *x, int *iw,\n        int *leniw, double *w, int *lenw)\n{\n        typedef void (*NLSSOL_t)(int *, int *, int *, int *, int *, int *,\n                int *, int *, double *, double *, double *, p_vf, p_vf,\n                int *, int *, int *, double *, double *, double *,\n                double *, double *, double *, double *, double *,\n                double *, int *, int *, double *, int *);\n        NLSSOL_t F;\n        if (!(F = (NLSSOL_t)Npsol_entries[1].f))\n                F = (NLSSOL_t)Lib_load(&Npsol_lib, 1);\n        F(m, n, nclin, ncnln, lda, ldcju, ldfju, ldr, a, bl, bu,\n          funcon, funobj, inform, iter, istate, c, cjacu, y, f,\n          fjacu, clamda, objf, r, x, iw, leniw, w, lenw);\n}\n\nextern \"C\" void NPOPTN2(char *string, size_t string_len)\n{\n        typedef void (*NPOPTN2_t)(char *, size_t);\n        NPOPTN2_t f;\n        if (!(f = (NPOPTN2_t)Npsol_entries[2].f))\n                f = (NPOPTN2_t)Lib_load(&Npsol_lib, 2);\n        f(string, string_len);\n}\n\n\nextern \"C\" void NLPQLP(int *l, int *m, int *me, int *mmax, int *n, int *nmax, in\nt *mnn2,\n        double *x, double *f, double *g, double *df, double *dg, double *u,\n        double *xl, double *xu, double *c, double *d, double *acc,\n        double *accqp, double *stpmin, int *maxfun, int *maxit, int *max_nm,\n        double *tol_nm, int *iprint, int *mode, int *iout, int *ifail,\n        double *wa, int *lwa, int *kwa, int *lkwa, int *active,\n        int *lactiv, int *lql, p_vf qpsolve)\n{\n        typedef void (*NLPQLP_t)(int *, int *, int *, int *, int *, int *,\n                        int *mnn2, double *, double *, double *, double *,\n                        double *, double *, double *, double *, double *,                               double *, double *, double *, double *, int *, int *,\n                        int *, double *, int *, int *, int *, int *, double *,\n                        int *, int *, int *, int *, int *, int *, p_vf);\n        NLPQLP_t F;\n        if (!(F = (NLPQLP_t)Nlpql_entries[0].f))\n                F = (NLPQLP_t)Lib_load(&Nlpql_lib, 0);\n        F(l, m, me, mmax, n, nmax, mnn2, x, f, g, df, dg, u, xl, xu, c, d, acc,\n          accqp, stpmin, maxfun, maxit, max_nm, tol_nm, iprint, mode, iout,\n          ifail, wa, lwa, kwa, lkwa, active, lactiv, lql, qpsolve);\n}\n\nextern \"C\" void QL(int *m, int *me, int *mmax, int *n, int *nmax, int *mnn,\n   double *c, double *d, double *a, double *b, double *xl, double *xu,double *x,\n   double *u, double *eps, int *mode, int *iout, int *ifail, int *iprint,\n   double *war, int *lwar, int *iwar, int *liwar)\n{\n        typedef void (*QL_t)(int *, int *, int *, int *, int *, int *,\n                        double *, double *, double *, double *, double *,\n                        double *, double *, double *, double *, int *, int *,\n                        int *, int *, double *, int *, int *, int *);\n        QL_t f;\n        if (!(f = (QL_t)Nlpql_entries[1].f))\n                f = (QL_t)Lib_load(&Nlpql_lib, 1);\n        f(m, me, mmax, n, nmax, mnn, c, d, a, b, xl, xu, x, u, eps, mode,\n         iout, ifail, iprint, war, lwar, iwar, liwar);\n}\n// WJB: end of long ToDo verify redeclaration comment block */\n\n#endif // DAKOTA_SHLIB\n#endif // HAVE_DOT or NPSOL or JEGA or NPPQL\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8)\nproject(Acro CXX C)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING \n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\n#assume any modern compiler has STD\nadd_definitions(-DHAVE_STD)\n\nfunction(AcroCheckDirExists dirPath)\n  get_filename_component(dirName ${dirPath} NAME)\n  if(EXISTS ${dirPath})\n    string(TOUPPER \"${dirName}\" DIRNAME)\n    option(HAVE_${DIRNAME} \"Build with ${dirName} enabled?\" ON)\n  endif()\nendfunction()\n\n\noption(ACRO_HAVE_DLOPEN \"Enable dlopen in Acro\" ON)\nif (ACRO_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    # Use the same definition as autotools build\n    add_definitions(\"-DHAVE_DLOPEN\")\n    # TODO: add include path in relevant subdirs?\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\noption(ENABLE_TESTS \"Enable testing in Acro\" OFF)\n\nif(ENABLE_TESTS)\n\n  # Install Python virtual environment for testing\n  find_package(PythonInterp)\n  if (NOT PYTHONINTERP_FOUND)\n    message(SEND_ERROR \"Python interpreter required for ENABLE_TESTS\")\n  endif()\n\n  #file(GLOB acro_python_packages packages/*/python)\n  #foreach(x ${acro_python_packages})\n  #  list(APPEND PYTHON_PACKAGES \" -p %s/${x}\")\n  #endforeach()\n\n  # TODO: OUTPUT python binary  OUTPUT python/bin/python\n  add_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python\n           ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t   ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen\n    MAIN_DEPENDENCY ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/bin/pyomo_install\n            ${CMAKE_CURRENT_SOURCE_DIR}/setup\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/setup.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n    COMMAND ${CMAKE_COMMAND}\n    ARGS -E remove_directory ${CMAKE_CURRENT_BINARY_DIR}/python\n    COMMAND ${PYTHON_EXECUTABLE}\n    ARGS ${CMAKE_CURRENT_SOURCE_DIR}/setup\n  )\n\n  add_custom_target(acro-python-env DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python)\n  add_custom_target(acro-cxxtestgen\n    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen)\n\nendif() # ENABLE_TESTS\n\n# In Acro, presence of a local tecuhos/optpp means Acro needs it,\n# but it might be provided externally by the user, e.g., in Trilinos.\n# Take care in case HAVE_TEUCHOS set by a parent instead of locally.\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/teuchos)\n  option(HAVE_TEUCHOS \"Build with Teuchos enabled?\" ON)\n  # when building inside Trilinos, the path to Teuchos will already be set\n  if (NOT BUILD_IN_TRILINOS)\n    # first probe for system-installed Trilinos\n    # this will respect Trilinos_DIR if already set\n    find_package(Trilinos QUIET)\n    if (NOT Trilinos_DIR)\n      # if no one has configured a local src Teuchos, do so\n      # this will respect Teuchos_DIR if already set\n      if(NOT Teuchos_DIR)\n        set(Teuchos_DIR ${CMAKE_CURRENT_BINARY_DIR}/tpl/teuchos)\n        message(\"Setting Teuchos_DIR to ${Teuchos_DIR}\")\n        add_subdirectory(tpl/teuchos)\n      else()\n        message(\"in ${CMAKE_CURRENT_BINARY_DIR} Teuchos_DIR already set to ${Teuchos_DIR}\")\n      endif()\n      find_package(Teuchos NO_MODULE REQUIRED)\n    else()\n      message(\"Using system trilinos in ${Trilinos_DIR}\")\n    endif()\n  endif()\nendif()\n\nadd_subdirectory(tpl)\n\nset(Coin_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/coin-cbc/cbc)\nset(TINYXML_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/tinyxml)\nset(COBYLA_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/3po/cobyla2c)\n\nadd_subdirectory(packages)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/config/acx_func_dlopen.m4": "dnl @synopsis ACX_FUNC_DLOPEN([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])\ndnl\ndnl This macro looks for the dlopen function and identifies the library\ndnl that is required to use it. On success, it sets the DLOPEN_LIBS output\ndnl variable to hold the requisite library linkages.\ndnl\ndnl ACTION-IF-FOUND is a list of shell commands to run if DLOPEN\ndnl is found, and ACTION-IF-NOT-FOUND is a list of commands\ndnl to run it if it is not found.  If ACTION-IF-FOUND is not specified,\ndnl the default action will define HAVE_DLOPEN.\ndnl\n\nAC_DEFUN([ACX_FUNC_DLOPEN], [\nacx_func_dlopen_ok=no\n\n# DLOPEN linked to by default?\nif test $acx_func_dlopen_ok = no; then\n        save_LIBS=\"$LIBS\"; LIBS=\"$LIBS\"\n        AC_CHECK_FUNC([dlopen], [acx_func_dlopen_ok=yes])\n        LIBS=\"$save_LIBS\"\nfi\n\n# DLOPEN in Standard DL library? \nif test $acx_func_dlopen_ok = no; then\n        AC_CHECK_LIB(dl, [dlopen], [acx_func_dlopen_ok=yes; DLOPEN_LIBS=\"-ldl\"])\nfi\n\nAC_SUBST(DLOPEN_LIBS)\n\n# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:\nif test x\"$acx_func_dlopen_ok\" = xyes; then\n        ifelse([$1],,AC_DEFINE(HAVE_DLOPEN,1,[Define if you have the dlopen function.]),[$1])\n        :\nelse\n        acx_func_dlopen_ok=no\n        $2\nfi\n\n])dnl ACX_FUNC_DLOPEN\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/config/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/bootstrap/root/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8)\nproject(Acro CXX C)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING \n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\n#assume any modern compiler has STD\nadd_definitions(-DHAVE_STD)\n\nfunction(AcroCheckDirExists dirPath)\n  get_filename_component(dirName ${dirPath} NAME)\n  if(EXISTS ${dirPath})\n    string(TOUPPER \"${dirName}\" DIRNAME)\n    option(HAVE_${DIRNAME} \"Build with ${dirName} enabled?\" ON)\n  endif()\nendfunction()\n\n\noption(ACRO_HAVE_DLOPEN \"Enable dlopen in Acro\" ON)\nif (ACRO_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    # Use the same definition as autotools build\n    add_definitions(\"-DHAVE_DLOPEN\")\n    # TODO: add include path in relevant subdirs?\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\noption(ENABLE_TESTS \"Enable testing in Acro\" OFF)\n\nif(ENABLE_TESTS)\n\n  # Install Python virtual environment for testing\n  find_package(PythonInterp)\n  if (NOT PYTHONINTERP_FOUND)\n    message(SEND_ERROR \"Python interpreter required for ENABLE_TESTS\")\n  endif()\n\n  #file(GLOB acro_python_packages packages/*/python)\n  #foreach(x ${acro_python_packages})\n  #  list(APPEND PYTHON_PACKAGES \" -p %s/${x}\")\n  #endforeach()\n\n  # TODO: OUTPUT python binary  OUTPUT python/bin/python\n  add_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/python\n           ${CMAKE_CURRENT_BINARY_DIR}/python.log\n\t   ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen\n    MAIN_DEPENDENCY ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/python.zip\n    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/bin/pyomo_install\n            ${CMAKE_CURRENT_SOURCE_DIR}/setup\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/setup.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/admin/vpy/dev.ini\n    COMMAND ${CMAKE_COMMAND}\n    ARGS -E remove_directory ${CMAKE_CURRENT_BINARY_DIR}/python\n    COMMAND ${PYTHON_EXECUTABLE}\n    ARGS ${CMAKE_CURRENT_SOURCE_DIR}/setup\n  )\n\n  add_custom_target(acro-python-env DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python)\n  add_custom_target(acro-cxxtestgen\n    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/python/bin/cxxtestgen)\n\nendif() # ENABLE_TESTS\n\n# In Acro, presence of a local tecuhos/optpp means Acro needs it,\n# but it might be provided externally by the user, e.g., in Trilinos.\n# Take care in case HAVE_TEUCHOS set by a parent instead of locally.\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tpl/teuchos)\n  option(HAVE_TEUCHOS \"Build with Teuchos enabled?\" ON)\n  # when building inside Trilinos, the path to Teuchos will already be set\n  if (NOT BUILD_IN_TRILINOS)\n    # first probe for system-installed Trilinos\n    # this will respect Trilinos_DIR if already set\n    find_package(Trilinos QUIET)\n    if (NOT Trilinos_DIR)\n      # if no one has configured a local src Teuchos, do so\n      # this will respect Teuchos_DIR if already set\n      if(NOT Teuchos_DIR)\n        set(Teuchos_DIR ${CMAKE_CURRENT_BINARY_DIR}/tpl/teuchos)\n        message(\"Setting Teuchos_DIR to ${Teuchos_DIR}\")\n        add_subdirectory(tpl/teuchos)\n      else()\n        message(\"in ${CMAKE_CURRENT_BINARY_DIR} Teuchos_DIR already set to ${Teuchos_DIR}\")\n      endif()\n      find_package(Teuchos NO_MODULE REQUIRED)\n    else()\n      message(\"Using system trilinos in ${Trilinos_DIR}\")\n    endif()\n  endif()\nendif()\n\nadd_subdirectory(tpl)\n\nset(Coin_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/coin-cbc/cbc)\nset(TINYXML_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/tinyxml)\nset(COBYLA_DIR ${CMAKE_CURRENT_SOURCE_DIR}/tpl/3po/cobyla2c)\n\nadd_subdirectory(packages)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/ampl/funcadd1.c": "/****************************************************************\nCopyright (C) 1998, 1999, 2000 Lucent Technologies\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name of Lucent or any of its entities\nnot be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#ifdef NO_FUNCADD\n#include \"funcadd.h\"\n\nchar *ix_details_ASL[] = {0};\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{ ae = ae; /* shut up non-use warning */ }\n\n#else\n\n#ifdef _WIN32\n#undef WIN32\n#define WIN32\n#endif\n\n#ifdef WIN32\n#include \"windows.h\"\n#undef Char\n#endif\n\n#define _POSIX_SOURCE\t/* for HP-UX */\n\n#include \"funcadd.h\"\n#include \"string.h\"\n\n#ifdef Old_APPLE\t/* formerly __APPLE__, for earlier versions of Mac OS X */\n#define FUNCADD \"_funcadd_ASL\"\n#endif\n#ifndef FUNCADD\n#define FUNCADD \"funcadd_ASL\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\nextern int libload_ASL(AmplExports *ae, char *s, int ns, int warn);\n#endif\n\ntypedef void Funcadd ANSI((AmplExports*));\n\nextern Char *mymalloc_ASL ANSI((size_t));\n#undef mymalloc\n#define mymalloc(x) mymalloc_ASL((size_t)(x))\n#ifndef KR_headers\nextern void free(void*);\n#endif\n\nchar *ix_details_ASL[] = {\n\t\"? {show -i options}\",\n\t\"- {do not import functions: do not access amplfunc.dll}\",\n\t\"dir {look for amplfunc.dll in directory dir}\",\n\t\"file {import functions from file rather than amplfunc.dll}\",\n\t\"\",\n\t\"If no -i option appears but $ampl_funclibs is set, assume\",\n\t\"-i $ampl_funclibs.  Otherwise, if $AMPLFUNC is set, assume\",\n\t\"-i $AMPLFUNC.  Otherwise look for amplfunc.dll in the\",\n\t\"directory that is current when execution begins.\",\n\t\"\",\n\t\"-ix and -i x are treated alike.\",\n\t0 };\n#define afdll afdll_ASL\nextern int aflibname_ASL ANSI((AmplExports*, char*, char*, int, Funcadd*, int, void(*)(void*), void*));\nextern char *i_option_ASL;\n\n#ifdef __cplusplus\n\t}\n#endif\n\nstatic int first = 1;\n\n#ifdef WIN32\n\n#define SLASH '\\\\'\nchar afdll[] = \"\\\\amplfunc.dll\";\ntypedef HINSTANCE shl_t;\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (Funcadd*)GetProcAddress(b,c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#define reg_file(x) 1\n\n static int\nAbspath(char *s)\n{\n\tint c = *s;\n\tif ((c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')\n\t && s[1] == ':'\n\t && (c = s[2]) == '\\\\' || c == '/')\n\t\treturn 1;\n\treturn 0;\n\t}\n\n#else /* !WIN32 */\n\n#define SLASH '/'\n\nchar afdll[] = \"/amplfunc.dll\";\n\n#define Abspath(s) (*(s) == '/')\n\n#ifdef KR_headers\nextern char *getcwd();\n#else\n#include \"unistd.h\"\t/* for getcwd */\n#endif\n#define GetCurrentDirectory(a,b) getcwd(b,(int)(a))\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n static int\n#ifdef KR_headers\nreg_file(name) char *name;\n#else\nreg_file(char *name)\n#endif\n{\n\tstruct stat sb;\n\treturn stat(name,&sb) ? 0 : S_ISREG(sb.st_mode);\n\t}\n\n#ifdef __hpux\n#include \"dl.h\"\n#define dlopen(x,y) shl_load(x, BIND_IMMEDIATE, 0)\n#define find_dlsym(a,b,c) !shl_findsym(&b, c, TYPE_PROCEDURE, &a)\n#define dlclose(x) shl_unload((shl_t)x)\n#define NO_DLERROR\n#else\n#ifdef Old_APPLE\n#include <mach-o/dyld.h>\ntypedef struct {\n\tNSObjectFileImage ofi;\n\tNSModule m;\n\tchar *name;\n\t} NS_pair;\ntypedef NS_pair *shl_t;\n\n static void*\nfind_sym_addr(NS_pair *p, const char *name)\n{\n\tNSSymbol nss;\n\n\tif (nss = NSLookupSymbolInModule(p->m, name))\n\t\treturn NSAddressOfSymbol(nss);\n\treturn 0;\n\t}\n\n#define find_dlsym(a,b,c) (a = find_sym_addr(b,c))\n\n static void\ndlclose(NS_pair *p)\n{\n\tif (NSUnLinkModule(p->m, NSUNLINKMODULE_OPTION_NONE))\n\t\tNSDestroyObjectFileImage(p->ofi);\n\tfree(p);\n\t}\n#define NO_DLERROR\n#else\n#include \"dlfcn.h\"\ntypedef void *shl_t;\n#define find_dlsym(a,b,c) (a = (Funcadd*)dlsym(b,c))\n#ifdef sun\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#endif /* sun */\n#endif /* Old_APPLE */\n#endif /* __hpux */\n#endif /* WIN32 */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n static shl_t\n#ifdef KR_headers\ndl_open(ae, name, warned) AmplExports *ae; char *name; int *warned;\n#else\ndl_open(AmplExports *ae, char *name, int *warned)\n#endif\n{\n/* This is a bit aggressive, but a first cut */\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tshl_t h;\n\tFILE *f;\n#ifndef KR_headers\n\tconst\n#endif\n\t      char *s;\n\n#ifdef Old_APPLE\n\tNS_pair p;\n\tNSObjectFileImageReturnCode irc;\n\tirc = NSCreateObjectFileImageFromFile(name,&p.ofi);\n\th = 0;\n\tif (irc == NSObjectFileImageSuccess) {\n\t\tp.m = NSLinkModule(p.ofi, name,\n\t\t\t  NSLINKMODULE_OPTION_BINDNOW\n\t\t\t| NSLINKMODULE_OPTION_PRIVATE\n\t\t\t| NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n\t\tif (!p.m)\n\t\t\tfprintf(stderr, \"NSLinkModule(\\\"%s\\\") failed.\\n\", name);\n\t\telse {\n\t\t\th = (NS_pair*)mymalloc(sizeof(NS_pair) + strlen(name) + 1);\n\t\t\tstrcpy(p.name = (char*)(h+1), name);\n\t\t\tmemcpy(h, &p, sizeof(NS_pair));\n\t\t\t}\n\t\t}\n\telse if (irc != NSObjectFileImageAccess)\n\t\tfprintf(stderr,\n\t\t\t\"return %d from NSCreateObjectFileImageFromFile(\\\"%s\\\")\\n\",\n\t\t\tirc, name);\n#else\n\th = dlopen(name, RTLD_NOW);\n#endif\n\tif (!h && warned && (f = fopen(name,\"rb\"))) {\n\t\tfclose(f);\n\t\tif (reg_file(name)) {\n\t\t\t*warned = 1;\n#ifdef NO_DLERROR\n\t\t\tfprintf(Stderr, \"Cannot load library %s.\\n\", name);\n#else\n\t\t\tfprintf(Stderr, \"Cannot load library %s\", name);\n\t\t\ts = dlerror();\n\t\t\tfprintf(Stderr, s ? \":\\n%s\\n\" : \".\\n\", s);\n#endif\n\t\t\t}\n\t\t}\n\treturn h;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 0;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\ndl_close(h) void *h;\n#else\ndl_close(void *h)\n#endif\n{\n#ifdef CLOSE_AT_RESET\n\tfirst = 1;\n#endif\n\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tif (h)\n\t\tdlclose(h);\n#endif\n\t}\n\n int\n#ifdef KR_headers\nlibload_ASL(ae, s, ns, warn) AmplExports *ae; char *s; int ns; int warn;\n#else\nlibload_ASL(AmplExports *ae, char *s, int ns, int warn)\n#endif\n{\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tFuncadd *fa;\n\tchar buf0[2048], *buf;\n\tint rc, warned;\n\tshl_t h;\n\tunsigned int n, nx;\n\n\tnx = 0;\n\tbuf = buf0;\n\tif (!Abspath(s)) {\n\t\tif (!GetCurrentDirectory(sizeof(buf0),buf0))\n\t\t\treturn 2;\n\t\tnx = strlen(buf0);\n\t\t}\n\tn = ns + sizeof(afdll) + nx;\n\tif (n > sizeof(buf0)) {\n\t\tbuf = (char*)mymalloc(n);\n\t\tif (nx)\n\t\t\tmemcpy(buf, buf0, nx);\n\t\t}\n\tif (nx)\n\t\tbuf[nx++] = SLASH;\n\tstrncpy(buf+nx, s, ns);\n\tbuf[nx+ns] = 0;\n\twarned = 0;\n\tif (h = dl_open(ae, buf, &warned)) {\n found:\n\t\tif (find_dlsym(fa, h, FUNCADD)\n\t\t || find_dlsym(fa, h, \"funcadd\")) {\n\t\t\trc = 0;\n#ifdef CLOSE_AT_RESET\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,0,dl_close,h);\n\t\t\t\t/* -DCLOSE_AT_RESET is for use in shared */\n\t\t\t\t/* libraries, such as MATLAB mex functions, */\n\t\t\t\t/* that may be loaded and unloaded several */\n\t\t\t\t/* times during execution of the program. */\n#else\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,1,dl_close,h);\n#endif\n\t\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Could not find funcadd in %s\\n\", buf);\n\t\t\tdl_close(h);\n\t\t\trc = 3;\n\t\t\t}\n\t\t}\n\telse if (warn) {\n\t\tif (!warned) {\n\t\t\tstrcpy(buf+nx+ns, afdll);\n\t\t\tif (h = dl_open(ae, buf, &warned))\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tif (warned)\n\t\t\trc = 2;\n\t\telse\n\t\t\tgoto notfound;\n\t\t}\n\telse {\n notfound:\n\t\tif (warn)\n\t\t\tfprintf(Stderr, \"Cannot find library %.*s\\nor %.*s%s\\n\",\n\t\t\t\tns, s, ns, s, afdll);\n\t\trc = 1;\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 3;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\nlibloop(ae, s) AmplExports *ae; char *s;\n#else\nlibloop(AmplExports *ae, char *s)\n#endif\n{\n\tchar *s1;\n\tint ns;\n\n\tfor(;; s = s1) {\n\t\twhile(*s <= ' ')\n\t\t\tif (!*s++)\n\t\t\t\treturn;\n\t\tfor(s1 = s; *++s1 >= ' '; );\n\t\twhile(s1[-1] == ' ')\n\t\t\t--s1;\n\t\tns = s1 - s;\n\t\tlibload_ASL(ae, s, ns, 1);\n\t\t}\n\t}\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{\n\tchar *s;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tif (s = i_option_ASL) {\n\t\t\tif (!*s || *s == '-' && !s[1])\n\t\t\t\treturn;\n\t\t\tlibloop(ae, s);\n\t\t\t}\n\t\telse\n\t\t\tlibload_ASL(ae, afdll+1, (int)sizeof(afdll)-2, 0);\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NO_FUNCADD */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/ampl/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/ampl/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8.4)\nproject(amplsolver)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING\n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\nset(AMPL_INCLUDE_DIRS ${amplsolver_SOURCE_DIR}\n                      ${amplsolver_BINARY_DIR} PARENT_SCOPE)\n                      \ninclude_directories(${amplsolver_SOURCE_DIR}\n                    ${amplsolver_BINARY_DIR})\n\nset(genarith_srcs arithchk.c)\nif(WIN32)\n  set_source_files_properties(arithchk.c PROPERTIES COMPILE_FLAGS \"-DNO_FPINIT\")\nelse()\n  list(APPEND genarith_srcs fpinit.c)\nendif()\nadd_executable(genarith ${genarith_srcs})\nif(UNIX)\n  target_link_libraries(genarith m)\nendif()\n\n\nconfigure_file(${amplsolver_SOURCE_DIR}/stdio1.h0 \n  ${amplsolver_BINARY_DIR}/stdio1.h)\n\nif(UNIX)\n  find_program(UNAME uname)\n  if(UNAME)\n    execute_process(COMMAND ${UNAME} -sr OUTPUT_VARIABLE System_details)\n  endif()\nelse()\n  set(System_details \"${CMAKE_SYSTEM_NAME}\")\nendif()\nstring(REPLACE \"\\n\" \"\"  System_details \"${System_details}\")\nconfigure_file(${amplsolver_SOURCE_DIR}/details.c0.cmake.in\n  ${amplsolver_BINARY_DIR}/details.c)\n\n# If genarith command fails, a zero length arith.h will be generated,\n# so remove on failure to cause later build failure\nadd_custom_command(\n  OUTPUT ${amplsolver_BINARY_DIR}/arith.h\n  COMMAND genarith > ${amplsolver_BINARY_DIR}/arith.h || \n    ${CMAKE_COMMAND} -E remove ${amplsolver_BINARY_DIR}/arith.h\n) \n\nset(amplsolver_SRCS\n  ${amplsolver_BINARY_DIR}/arith.h\n  ${amplsolver_BINARY_DIR}/details.c\n  asldate.c\n  atof.c\n  auxinfo.c\n  avldelete.c\n  avltree.c\n  b_search.c\n  basename.c\n  bscanf.c\n  com2eval.c\n  comeval.c\n  con1ival.c\n  con2ival.c\n  con2val.c\n  conadj.c\n  conpval.c\n  conscale.c\n  conval.c\n  derprop.c\n  dtoa1.c\n  duthes.c\n  dynlink.c\n  f_read.c\n  fg_read.c\n  fg_write.c\n  fgh_read.c\n  fpecatch.c\n  fpinit.c\n  fullhes.c\n  func_add.c\n  funcadd1.c\n  g_fmt.c\n  genrowno.c\n  getenv.c\n  getstub.c\n  htcl.c\n  jac0dim.c\n  jac2dim.c\n  jacdim.c\n  jacinc.c\n  jacinc1.c\n  mach.c\n  mainexit.c\n  mip_pri.c\n  misc.c\n  mypow.c\n  names.c\n  nl_obj.c\n  nqpcheck.c\n  obj2val.c\n  obj_prec.c\n  objconst.c\n  objval.c\n  objval_.c\n  op_type.c\n  pfg_read.c\n  pfghread.c\n  printf.c\n  pshvprod.c\n  punknown.c\n  qp_read.c\n  qpcheck.c\n  qsortv.c\n  readsol.c\n  repwhere.c\n  rops.c\n  rops2.c\n  sigcatch.c\n  sos_add.c\n  sphes.c\n  sscanf.c\n  stderr.c\n  studchk0.c\n  suf_sos.c\n  value.c\n  writesol.c\n  wrtsol_.c\n  ws_desc.c\n  wsu_desc.c\n  x2check.c\n  xectim.c\n  xp1known.c\n  xp2known.c)\n\nadd_library(amplsolver ${amplsolver_SRCS})\n\noption(AMPL_HAVE_DLOPEN \"Toggle support for dlopen in AMPL\" OFF)\nif (AMPL_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    add_definitions(\"-DAMPL_HAVE_DLOPEN\")\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\nif(UNIX)\n  target_link_libraries(amplsolver ${DL_LIBRARY})\nendif()\n\n# Allow AMPL build to be shared among several source packages\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/AMPLConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/AMPLConfig.cmake\n)\n\ninstall(TARGETS amplsolver EXPORT ${ExportTarget} DESTINATION lib)\n#install(TARGETS genarith EXPORT ${ExportTarget} DESTINATION bin)\n\nfile(GLOB ampl_headers *.h *.hd)\ninstall(FILES ${ampl_headers} DESTINATION include/ampl)\ninstall(FILES ${amplsolver_BINARY_DIR}/arith.h ${amplsolver_BINARY_DIR}/stdio1.h\n  DESTINATION include/ampl)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/colin/src/libs/LibLoader.cpp": "/*  _________________________________________________________________________\n *\n *  Acro: A Common Repository for Optimizers\n *  Copyright (c) 2008 Sandia Corporation.\n *  This software is distributed under the BSD License.\n *  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n *  the U.S. Government retains certain rights in this software.\n *  For more information, see the README.txt file in the top Acro directory.\n *  _________________________________________________________________________\n */\n\n#include <acro_config.h>\n#include <colin/XMLProcessor.h>\n#include <utilib/TinyXML_helper.h>\n\n// This is a bit aggressive, but a first cut\n#if defined(_WIN32) || defined(HAVE_DLOPEN)\n\n#ifdef _WIN32\n  #include <windows.h>\n  typedef HINSTANCE LIB_POINTER;\n  #define LIB_EXTENSION \".dll\"\n#else\n  #include <unistd.h>\n  #include <dlfcn.h>\n  typedef void* LIB_POINTER;\n  #define LIB_EXTENSION \".so\"\n#endif\n\n#ifdef _WIN32\n#include <direct.h>\n#define IS_REG_FILE(STAT) (( _S_IFREG & (STAT).st_mode ) > 0 )\n#else\n#define IS_REG_FILE(STAT) S_ISREG((STAT).st_mode)\n#endif\n\n\n#define DEBUG_LIBLOADER 0 \n\n#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <sys/stat.h>\n#include <iostream>\n\nusing std::cerr;\nusing std::endl;\nusing std::string;\n\n\nnamespace colin {\n\n\nLIB_POINTER load(string name)\n{\n   LIB_POINTER lib_handle;\n\n   // Ideally, we should look in common paths and for platform-specific\n   // extensions, but for now, we will assume that the full (correct)\n   // path is being provided.\n   struct stat fs;\n   if ( ! (( stat( name.c_str(), &fs ) == 0 ) && IS_REG_FILE(fs) ) )\n   {\n      cerr << \"ERROR: load(): cannot find library '\"\n                << name << \"'\" << endl;\n      return NULL;\n   }\n\n   // The actual loading stuff\n#ifdef _WIN32\n   unsigned int err_code = SetErrorMode(SEM_FAILCRITICALERRORS);\n   lib_handle = LoadLibrary(name.c_str());\n#else\n   lib_handle = dlopen(name.c_str(), RTLD_LAZY);\n#endif\n   if (!lib_handle) \n   {\n      cerr << endl << \"Module \" << name << endl;\n      cerr << \"Error during load(): \";\n#ifdef _WIN32\n      const int buflen = 1024;\n      char buf[buflen];\n      err_code = GetLastError();\n      FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, err_code, \n                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), \n                     (LPTSTR)buf, buflen, NULL );\n      cerr << buf << endl;\n#else\n      cerr << dlerror() << endl;\n#endif\n      return NULL;\n   }\n#ifdef _WIN32\n   else\n   {\n      SetLastError(0); \n   }\n#endif\n\n   return lib_handle;\n}\n\n\nclass LibraryLoadElement : public XML_Processor::ElementFunctor\n{\npublic:\n   LibraryLoadElement()\n   {}\n\n   virtual void process(TiXmlElement* root, int version)\n   {\n      string lib_name;\n      utilib::get_string_attribute(root, \"file\", lib_name);\n      if ( ! load(lib_name) )\n         EXCEPTION_MNGR(std::runtime_error, \"ERROR: Loading library '\"\n                        << lib_name << \"' failed.\");\n   }\n\n   virtual void describe(std::ostream &os, size_t indent = 0) const\n   {\n      for( ; indent > 0; --indent )\n         os << XML_Processor::indent_string;\n      os << \"Please implement LibraryLoadElement::describe\" << endl;\n   }\n  \n};\n\n\n//---------------------------------------------------------------------\n\nnamespace StaticInitializers {\nnamespace {\n\nbool RegisterFunctor()\n{\n   XMLProcessor().register_element(\"LoadLibrary\", 1, new LibraryLoadElement);\n   return true;\n}\n\n} // namespace colin::StaticInitializers::(local)\n\nextern const volatile bool library_loader = RegisterFunctor();\n\n} // namespace colin::StaticInitializers\n} // namespace colin\n\n#else  // defined(_WIN32) || defined(HAVE_DLOPEN)\n// keep this separate to avoid intermingling the namespaces with the ifdefs\nnamespace colin {\n  namespace StaticInitializers {\n    extern const volatile bool library_loader = false;\n  } // namespace colin::StaticInitializers\n} // namespace colin\n\n#endif  // defined(_WIN32) || defined(HAVE_DLOPEN)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/colin/test/unit/CMakeLists.txt": "if(ENABLE_TESTS)\n\n  include(AcroAddCxxtestRunner)\n\n  set (runner_cxxtest_src\n    TObjectType.cpp\n    TRealDomain.cpp\n    TIntDomain.cpp\n    TGradient.cpp\n    TConstraints.cpp\n    TConstraintPenalty.cpp\n    TDowncast.cpp\n    TFiniteDifference_Real.cpp\n    TFiniteDifference_MixedInt.cpp\n    TLinearConstraints.cpp\n    TNonD_Constraints.cpp\n    TNonlinearConstraints.cpp\n    TRelaxableMixedIntDomain.cpp\n    TTestApplications.cpp\n    TUnconMultiobj.cpp\n    TWeightedSum.cpp\n    TAmplApplication.cpp\n    TCache.cpp\n    TView_Pareto.cpp\n    # TReformulation_NLP1_NLP0.cpp\n    )\n\n  set(runner_static_src\n    # NONE\n    )\n\n  set(runner_include_directories\n    ${Acro_SOURCE_DIR}/packages/utilib/src\n    ${Acro_BINARY_DIR}/packages/utilib/src\n    ${Acro_SOURCE_DIR}/packages/colin/src\n    ${Acro_SOURCE_DIR}/tpl/cxxtest\n    )    \n\n  set(runner_link_libraries colin utilib)    # Need m dlopen?\n  if(HAVE_AMPL)\n    list(APPEND runner_link_libraries amplsolver)\n  endif()\n\n  # This call will add an executable called runner\n  acro_add_cxxtest_runner(colin\n    \"${runner_cxxtest_src}\" \"${runner_static_src}\" \n    \"${runner_include_directories}\" \"${runner_link_libraries}\"\n    )\n \n\n  # Auxilliary test files\n  file(GLOB all_test_inputs RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \n    print_summary*.txt example*.xml)\n  foreach(test_file ${all_test_inputs})\n    configure_file(${test_file} ${CMAKE_CURRENT_BINARY_DIR}/${test_file} COPYONLY)\n  endforeach()\n\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/mvs/v8/colin/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n#ifndef ACRO_USING_AMPL\n#define ACRO_USING_AMPL\n#endif\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n/* #ifndef ACRO_USING_COBYLA */\n/* #define ACRO_USING_COBYLA  1 */\n/* #endif */\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* Define if want to build with tinyxml enabled */\n#ifndef ACRO_USING_TINYXML\n#define ACRO_USING_TINYXML\n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/mvs/v8/coliny/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n#ifndef ACRO_USING_AMPL\n#define ACRO_USING_AMPL\n#endif\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n/* #ifndef ACRO_USING_COBYLA */\n/* #define ACRO_USING_COBYLA  1 */\n/* #endif */\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/mvs/v8/pico/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n/* #undef ACRO_USING_AMPL */\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n#ifndef ACRO_USING_COBYLA \n#define ACRO_USING_COBYLA  1 \n#endif\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#include <acro_config_bool.h>\n#include <acro_config_explicit.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/mvs/v8/pebbl/acro_config.h": "#ifndef _INCLUDE_ACRO_CONFIG_H\n#define _INCLUDE_ACRO_CONFIG_H 1\n \n/* include/acro_config.h. Generated automatically at end of configure. */\n/* include/config.h.  Generated by configure.  */\n/* include/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* software build cpu is sparc */\n/* #undef ACRO_BUILD_CPU_SPARC */\n\n/* software build cpu is x86 */\n#ifndef ACRO_BUILD_CPU_X86 \n#define ACRO_BUILD_CPU_X86  1 \n#endif\n\n/* software build cpu is 64 bit x86 */\n/* #undef ACRO_BUILD_CPU_X86_64 */\n\n/* software build os is cygwin */\n#ifndef ACRO_BUILD_CYGWIN \n#define ACRO_BUILD_CYGWIN  1 \n#endif\n\n/* software build os is linux */\n/* #undef ACRO_BUILD_LINUX */\n\n/* software build os is solaris */\n/* #undef ACRO_BUILD_SOLARIS */\n\n/* Define to dummy `main' function (if any) required to link to the Fortran\n   libraries. */\n/* #undef ACRO_F77_DUMMY_MAIN */\n\n/* Define to a macro mangling the given C identifier (in lower and upper\n   case), which must not contain underscores, for linking with Fortran. */\n#ifndef ACRO_F77_FUNC \n#define ACRO_F77_FUNC (name,NAME) name ## _ \n#endif\n\n/* As F77_FUNC, but for C identifiers containing underscores. */\n#ifndef ACRO_F77_FUNC_ \n#define ACRO_F77_FUNC_ (name,NAME) name ## __ \n#endif\n\n/* Define if F77 and FC dummy `main' functions are identical. */\n/* #undef ACRO_FC_DUMMY_MAIN_EQ_F77 */\n\n/* Define if you have a BLAS library. */\n/* #undef ACRO_HAVE_BLAS */\n\n/* Define if you have CPLEX library. */\n/* #undef ACRO_HAVE_CPLEX */\n\n/* Define if you have the dlopen function. */\n#ifndef ACRO_HAVE_DLOPEN \n#define ACRO_HAVE_DLOPEN  1 \n#endif\n\n/* define if the compiler supports exceptions */\n#ifndef ACRO_HAVE_EXCEPTIONS \n#define ACRO_HAVE_EXCEPTIONS   \n#endif\n\n/* define if the compiler supports the explicit keyword */\n#ifndef ACRO_HAVE_EXPLICIT \n#define ACRO_HAVE_EXPLICIT   \n#endif\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #ifndef ACRO_HAVE_GETRUSAGE  */\n/* #define ACRO_HAVE_GETRUSAGE  1  */\n/* #endif */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#ifndef ACRO_HAVE_INTTYPES_H \n#define ACRO_HAVE_INTTYPES_H  1 \n#endif\n\n/* Define if you have LAPACK library. */\n/* #undef ACRO_HAVE_LAPACK */\n\n/* define if the compiler supports member templates */\n#ifndef ACRO_HAVE_MEMBER_TEMPLATES \n#define ACRO_HAVE_MEMBER_TEMPLATES   \n#endif\n\n/* Define to 1 if you have the <memory.h> header file. */\n#ifndef ACRO_HAVE_MEMORY_H \n#define ACRO_HAVE_MEMORY_H  1 \n#endif\n\n/* define that mpi is being used */\n/* #undef ACRO_HAVE_MPI */\n\n/* define if the compiler implements namespaces */\n#ifndef ACRO_HAVE_NAMESPACES \n#define ACRO_HAVE_NAMESPACES   \n#endif\n\n/* Define if you have NPSOL library. */\n/* #undef ACRO_HAVE_NPSOL */\n\n/* define if the compiler has stringstream */\n#ifndef ACRO_HAVE_SSTREAM \n#define ACRO_HAVE_SSTREAM   \n#endif\n\n/* define if the compiler supports ISO C++ standard library */\n#ifndef ACRO_HAVE_STD \n#define ACRO_HAVE_STD   \n#endif\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#ifndef ACRO_HAVE_STDINT_H \n#define ACRO_HAVE_STDINT_H  1 \n#endif\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#ifndef ACRO_HAVE_STDLIB_H \n#define ACRO_HAVE_STDLIB_H  1 \n#endif\n\n/* Define to 1 if you have the `strerror' function. */\n#ifndef ACRO_HAVE_STRERROR \n#define ACRO_HAVE_STRERROR  1 \n#endif\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #ifndef ACRO_HAVE_STRINGS_H  */\n/* #define ACRO_HAVE_STRINGS_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <string.h> header file. */\n#ifndef ACRO_HAVE_STRING_H \n#define ACRO_HAVE_STRING_H  1 \n#endif\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_STAT_H  */\n/* #define ACRO_HAVE_SYS_STAT_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #ifndef ACRO_HAVE_SYS_TYPES_H  */\n/* #define ACRO_HAVE_SYS_TYPES_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #ifndef ACRO_HAVE_UNISTD_H  */\n/* #define ACRO_HAVE_UNISTD_H  1  */\n/* #endif */\n\n/* Define to 1 if you have the <values.h> header file. */\n/* #undef ACRO_HAVE_VALUES_H */\n\n/* software host will be cygwin */\n#ifndef ACRO_HOST_CYGWIN \n#define ACRO_HOST_CYGWIN  1 \n#endif\n\n/* software host is GNU */\n/* #undef ACRO_HOST_GNU */\n\n/* software host will be linux */\n/* #undef ACRO_HOST_LINUX */\n\n/* software host will be mingw */\n/* #undef ACRO_HOST_MINGW */\n\n/* software host will be solaris */\n/* #undef ACRO_HOST_SOLARIS */\n\n/* Name of package */\n#ifndef ACRO_PACKAGE \n#define ACRO_PACKAGE  \"acro\" \n#endif\n\n/* Define to the address where bug reports for this package should be sent. */\n#ifndef ACRO_PACKAGE_BUGREPORT \n#define ACRO_PACKAGE_BUGREPORT  \"acro-help@software.sandia.gov\" \n#endif\n\n/* Define to the full name of this package. */\n#ifndef ACRO_PACKAGE_NAME \n#define ACRO_PACKAGE_NAME  \"acro\" \n#endif\n\n/* Define to the full name and version of this package. */\n#ifndef ACRO_PACKAGE_STRING \n#define ACRO_PACKAGE_STRING  \"acro VOTD\" \n#endif\n\n/* Define to the one symbol short name of this package. */\n#ifndef ACRO_PACKAGE_TARNAME \n#define ACRO_PACKAGE_TARNAME  \"acro\" \n#endif\n\n/* Define to the version of this package. */\n#ifndef ACRO_PACKAGE_VERSION \n#define ACRO_PACKAGE_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if you have the ANSI C header files. */\n/* #ifndef ACRO_STDC_HEADERS  */\n/* #define ACRO_STDC_HEADERS  1  */\n/* #endif */\n\n/* software target will be cygwin */\n#ifndef ACRO_TARGET_CYGWIN \n#define ACRO_TARGET_CYGWIN  1 \n#endif\n\n/* software target will be linux */\n/* #undef ACRO_TARGET_LINUX */\n\n/* software target will be mingw */\n/* #undef ACRO_TARGET_MINGW */\n\n/* software target will be solaris */\n/* #undef ACRO_TARGET_SOLARIS */\n\n/* Define if want to build with ampl enabled */\n/* #undef ACRO_USING_AMPL */\n\n/* Define if want to build with appspack enabled */\n/* #undef ACRO_USING_APPSPACK */\n\n/* define that clp is being used */\n#ifndef ACRO_USING_CLP \n#define ACRO_USING_CLP  1 \n#endif\n\n/* define that cobyla is being used */\n#ifndef ACRO_USING_COBYLA \n#define ACRO_USING_COBYLA  1 \n#endif\n\n/* Define if want to build with coin enabled */\n/* #undef ACRO_USING_COIN */\n\n/* Define if want to build with colin enabled */\n/* #undef ACRO_USING_COLIN */\n\n/* Define if want to build with coliny enabled */\n/* #undef ACRO_USING_COLINY */\n\n/* Define if want to build with dscpack enabled */\n/* #undef ACRO_USING_DSCPACK */\n\n/* Define if want to build with exact enabled */\n#ifndef ACRO_USING_EXACT \n#define ACRO_USING_EXACT   \n#endif\n\n/* Define if want to build with filib enabled */\n/* #undef ACRO_USING_FILIB */\n\n/* Define if want to build with glpk enabled */\n/* #undef ACRO_USING_GLPK */\n\n/* Define if want to build with gnlp enabled */\n/* #undef ACRO_USING_GNLP */\n\n/* Define if want to build with ipopt enabled */\n/* #undef ACRO_USING_IPOPT */\n\n/* Define if want to build with mtl enabled */\n/* #undef ACRO_USING_MTL */\n\n/* Define if want to build with optpp enabled */\n/* #undef ACRO_USING_OPTPP */\n\n/* Define if want to build with parpcx enabled */\n/* #undef ACRO_USING_PARPCX */\n\n/* Define if want to build with pebbl enabled */\n/* #undef ACRO_USING_PEBBL */\n\n/* Define if want to build with pico enabled */\n/* #undef ACRO_USING_PICO */\n\n/* define that plgo is being used */\n#ifndef ACRO_USING_PLGO \n#define ACRO_USING_PLGO  1 \n#endif\n\n/* Define if want to build with soplex enabled */\n/* #undef ACRO_USING_SOPLEX */\n\n/* Define if want to build with 3po enabled */\n/* #undef ACRO_USING_THREEPO */\n\n/* Define if want to build with tmf enabled */\n/* #undef ACRO_USING_TMF */\n\n/* Define if want to build with tracecache enabled */\n/* #undef ACRO_USING_TRACECACHE */\n\n/* Define if want to build with trilinos enabled */\n/* #undef ACRO_USING_TRILINOS */\n\n/* Define if want to build with utilib enabled */\n#ifndef ACRO_USING_UTILIB \n#define ACRO_USING_UTILIB   \n#endif\n\n/* turn on code validation tests */\n/* #undef ACRO_VALIDATING */\n\n/* Version number of package */\n#ifndef ACRO_VERSION \n#define ACRO_VERSION  \"VOTD\" \n#endif\n\n/* Define to 1 if your processor stores words with the most significant byte\n   first (like Motorola and SPARC, unlike Intel and VAX). */\n/* #undef ACRO_WORDS_BIGENDIAN */\n\n/* define whether checksum function is included in utilib */\n#ifndef ACRO_YES_CHECKSUM \n#define ACRO_YES_CHECKSUM   \n#endif\n\n/* define whether CommonIO is included in utilib */\n#ifndef ACRO_YES_COMMONIO \n#define ACRO_YES_COMMONIO   \n#endif\n\n/* define whether memdebug is included in utilib */\n/* #undef ACRO_YES_MEMDEBUG */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef _acro_size_t */\n\n#ifdef ACRO_USING_UTILIB\n#include <utilib/utilib_config.h>\n#include <acro_config_bool.h>\n#include <acro_config_explicit.h>\n#endif\n\n \n/* once: _INCLUDE_ACRO_CONFIG_H */\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/cmake/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/ampl/funcadd1.c": "/****************************************************************\nCopyright (C) 1998, 1999, 2000 Lucent Technologies\nAll Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby\ngranted, provided that the above copyright notice appear in all\ncopies and that both that the copyright notice and this\npermission notice and warranty disclaimer appear in supporting\ndocumentation, and that the name of Lucent or any of its entities\nnot be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nLUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\nIN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\nSPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n****************************************************************/\n\n#ifdef NO_FUNCADD\n#include \"funcadd.h\"\n\nchar *ix_details_ASL[] = {0};\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{ ae = ae; /* shut up non-use warning */ }\n\n#else\n\n#ifdef _WIN32\n#undef WIN32\n#define WIN32\n#endif\n\n#ifdef WIN32\n#include \"windows.h\"\n#undef Char\n#endif\n\n#define _POSIX_SOURCE\t/* for HP-UX */\n\n#include \"funcadd.h\"\n#include \"string.h\"\n\n#ifdef Old_APPLE\t/* formerly __APPLE__, for earlier versions of Mac OS X */\n#define FUNCADD \"_funcadd_ASL\"\n#endif\n#ifndef FUNCADD\n#define FUNCADD \"funcadd_ASL\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\nextern int libload_ASL(AmplExports *ae, char *s, int ns, int warn);\n#endif\n\ntypedef void Funcadd ANSI((AmplExports*));\n\nextern Char *mymalloc_ASL ANSI((size_t));\n#undef mymalloc\n#define mymalloc(x) mymalloc_ASL((size_t)(x))\n#ifndef KR_headers\nextern void free(void*);\n#endif\n\nchar *ix_details_ASL[] = {\n\t\"? {show -i options}\",\n\t\"- {do not import functions: do not access amplfunc.dll}\",\n\t\"dir {look for amplfunc.dll in directory dir}\",\n\t\"file {import functions from file rather than amplfunc.dll}\",\n\t\"\",\n\t\"If no -i option appears but $ampl_funclibs is set, assume\",\n\t\"-i $ampl_funclibs.  Otherwise, if $AMPLFUNC is set, assume\",\n\t\"-i $AMPLFUNC.  Otherwise look for amplfunc.dll in the\",\n\t\"directory that is current when execution begins.\",\n\t\"\",\n\t\"-ix and -i x are treated alike.\",\n\t0 };\n#define afdll afdll_ASL\nextern int aflibname_ASL ANSI((AmplExports*, char*, char*, int, Funcadd*, int, void(*)(void*), void*));\nextern char *i_option_ASL;\n\n#ifdef __cplusplus\n\t}\n#endif\n\nstatic int first = 1;\n\n#ifdef WIN32\n\n#define SLASH '\\\\'\nchar afdll[] = \"\\\\amplfunc.dll\";\ntypedef HINSTANCE shl_t;\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (Funcadd*)GetProcAddress(b,c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#define reg_file(x) 1\n\n static int\nAbspath(char *s)\n{\n\tint c = *s;\n\tif ((c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')\n\t && s[1] == ':'\n\t && (c = s[2]) == '\\\\' || c == '/')\n\t\treturn 1;\n\treturn 0;\n\t}\n\n#else /* !WIN32 */\n\n#define SLASH '/'\n\nchar afdll[] = \"/amplfunc.dll\";\n\n#define Abspath(s) (*(s) == '/')\n\n#ifdef KR_headers\nextern char *getcwd();\n#else\n#include \"unistd.h\"\t/* for getcwd */\n#endif\n#define GetCurrentDirectory(a,b) getcwd(b,(int)(a))\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n static int\n#ifdef KR_headers\nreg_file(name) char *name;\n#else\nreg_file(char *name)\n#endif\n{\n\tstruct stat sb;\n\treturn stat(name,&sb) ? 0 : S_ISREG(sb.st_mode);\n\t}\n\n#ifdef __hpux\n#include \"dl.h\"\n#define dlopen(x,y) shl_load(x, BIND_IMMEDIATE, 0)\n#define find_dlsym(a,b,c) !shl_findsym(&b, c, TYPE_PROCEDURE, &a)\n#define dlclose(x) shl_unload((shl_t)x)\n#define NO_DLERROR\n#else\n#ifdef Old_APPLE\n#include <mach-o/dyld.h>\ntypedef struct {\n\tNSObjectFileImage ofi;\n\tNSModule m;\n\tchar *name;\n\t} NS_pair;\ntypedef NS_pair *shl_t;\n\n static void*\nfind_sym_addr(NS_pair *p, const char *name)\n{\n\tNSSymbol nss;\n\n\tif (nss = NSLookupSymbolInModule(p->m, name))\n\t\treturn NSAddressOfSymbol(nss);\n\treturn 0;\n\t}\n\n#define find_dlsym(a,b,c) (a = find_sym_addr(b,c))\n\n static void\ndlclose(NS_pair *p)\n{\n\tif (NSUnLinkModule(p->m, NSUNLINKMODULE_OPTION_NONE))\n\t\tNSDestroyObjectFileImage(p->ofi);\n\tfree(p);\n\t}\n#define NO_DLERROR\n#else\n#include \"dlfcn.h\"\ntypedef void *shl_t;\n#define find_dlsym(a,b,c) (a = (Funcadd*)dlsym(b,c))\n#ifdef sun\n#ifndef RTLD_NOW\n#define RTLD_NOW RTLD_LAZY\n#endif\n#endif /* sun */\n#endif /* Old_APPLE */\n#endif /* __hpux */\n#endif /* WIN32 */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n static shl_t\n#ifdef KR_headers\ndl_open(ae, name, warned) AmplExports *ae; char *name; int *warned;\n#else\ndl_open(AmplExports *ae, char *name, int *warned)\n#endif\n{\n/* This is a bit aggressive, but a first cut */\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tshl_t h;\n\tFILE *f;\n#ifndef KR_headers\n\tconst\n#endif\n\t      char *s;\n\n#ifdef Old_APPLE\n\tNS_pair p;\n\tNSObjectFileImageReturnCode irc;\n\tirc = NSCreateObjectFileImageFromFile(name,&p.ofi);\n\th = 0;\n\tif (irc == NSObjectFileImageSuccess) {\n\t\tp.m = NSLinkModule(p.ofi, name,\n\t\t\t  NSLINKMODULE_OPTION_BINDNOW\n\t\t\t| NSLINKMODULE_OPTION_PRIVATE\n\t\t\t| NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n\t\tif (!p.m)\n\t\t\tfprintf(stderr, \"NSLinkModule(\\\"%s\\\") failed.\\n\", name);\n\t\telse {\n\t\t\th = (NS_pair*)mymalloc(sizeof(NS_pair) + strlen(name) + 1);\n\t\t\tstrcpy(p.name = (char*)(h+1), name);\n\t\t\tmemcpy(h, &p, sizeof(NS_pair));\n\t\t\t}\n\t\t}\n\telse if (irc != NSObjectFileImageAccess)\n\t\tfprintf(stderr,\n\t\t\t\"return %d from NSCreateObjectFileImageFromFile(\\\"%s\\\")\\n\",\n\t\t\tirc, name);\n#else\n\th = dlopen(name, RTLD_NOW);\n#endif\n\tif (!h && warned && (f = fopen(name,\"rb\"))) {\n\t\tfclose(f);\n\t\tif (reg_file(name)) {\n\t\t\t*warned = 1;\n#ifdef NO_DLERROR\n\t\t\tfprintf(Stderr, \"Cannot load library %s.\\n\", name);\n#else\n\t\t\tfprintf(Stderr, \"Cannot load library %s\", name);\n\t\t\ts = dlerror();\n\t\t\tfprintf(Stderr, s ? \":\\n%s\\n\" : \".\\n\", s);\n#endif\n\t\t\t}\n\t\t}\n\treturn h;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 0;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\ndl_close(h) void *h;\n#else\ndl_close(void *h)\n#endif\n{\n#ifdef CLOSE_AT_RESET\n\tfirst = 1;\n#endif\n\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tif (h)\n\t\tdlclose(h);\n#endif\n\t}\n\n int\n#ifdef KR_headers\nlibload_ASL(ae, s, ns, warn) AmplExports *ae; char *s; int ns; int warn;\n#else\nlibload_ASL(AmplExports *ae, char *s, int ns, int warn)\n#endif\n{\n#if defined(WIN32) || defined(AMPL_HAVE_DLOPEN)\n\tFuncadd *fa;\n\tchar buf0[2048], *buf;\n\tint rc, warned;\n\tshl_t h;\n\tunsigned int n, nx;\n\n\tnx = 0;\n\tbuf = buf0;\n\tif (!Abspath(s)) {\n\t\tif (!GetCurrentDirectory(sizeof(buf0),buf0))\n\t\t\treturn 2;\n\t\tnx = strlen(buf0);\n\t\t}\n\tn = ns + sizeof(afdll) + nx;\n\tif (n > sizeof(buf0)) {\n\t\tbuf = (char*)mymalloc(n);\n\t\tif (nx)\n\t\t\tmemcpy(buf, buf0, nx);\n\t\t}\n\tif (nx)\n\t\tbuf[nx++] = SLASH;\n\tstrncpy(buf+nx, s, ns);\n\tbuf[nx+ns] = 0;\n\twarned = 0;\n\tif (h = dl_open(ae, buf, &warned)) {\n found:\n\t\tif (find_dlsym(fa, h, FUNCADD)\n\t\t || find_dlsym(fa, h, \"funcadd\")) {\n\t\t\trc = 0;\n#ifdef CLOSE_AT_RESET\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,0,dl_close,h);\n\t\t\t\t/* -DCLOSE_AT_RESET is for use in shared */\n\t\t\t\t/* libraries, such as MATLAB mex functions, */\n\t\t\t\t/* that may be loaded and unloaded several */\n\t\t\t\t/* times during execution of the program. */\n#else\n\t\t\taflibname_ASL(ae,buf,s,ns,fa,1,dl_close,h);\n#endif\n\t\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Could not find funcadd in %s\\n\", buf);\n\t\t\tdl_close(h);\n\t\t\trc = 3;\n\t\t\t}\n\t\t}\n\telse if (warn) {\n\t\tif (!warned) {\n\t\t\tstrcpy(buf+nx+ns, afdll);\n\t\t\tif (h = dl_open(ae, buf, &warned))\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tif (warned)\n\t\t\trc = 2;\n\t\telse\n\t\t\tgoto notfound;\n\t\t}\n\telse {\n notfound:\n\t\tif (warn)\n\t\t\tfprintf(Stderr, \"Cannot find library %.*s\\nor %.*s%s\\n\",\n\t\t\t\tns, s, ns, s, afdll);\n\t\trc = 1;\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n#else /* !( #if defined(WIN32) || defined(HAVE_DLOPEN) ) */\n\treturn 3;\n#endif\n\t}\n\n static void\n#ifdef KR_headers\nlibloop(ae, s) AmplExports *ae; char *s;\n#else\nlibloop(AmplExports *ae, char *s)\n#endif\n{\n\tchar *s1;\n\tint ns;\n\n\tfor(;; s = s1) {\n\t\twhile(*s <= ' ')\n\t\t\tif (!*s++)\n\t\t\t\treturn;\n\t\tfor(s1 = s; *++s1 >= ' '; );\n\t\twhile(s1[-1] == ' ')\n\t\t\t--s1;\n\t\tns = s1 - s;\n\t\tlibload_ASL(ae, s, ns, 1);\n\t\t}\n\t}\n\n void\n#ifdef KR_headers\nfuncadd(ae) AmplExports *ae;\n#else\nfuncadd(AmplExports *ae)\n#endif\n{\n\tchar *s;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tif (s = i_option_ASL) {\n\t\t\tif (!*s || *s == '-' && !s[1])\n\t\t\t\treturn;\n\t\t\tlibloop(ae, s);\n\t\t\t}\n\t\telse\n\t\t\tlibload_ASL(ae, afdll+1, (int)sizeof(afdll)-2, 0);\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NO_FUNCADD */\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/ampl/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/ampl/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8.4)\nproject(amplsolver)\n\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_MODULE_PATH})\n\nset(ExportTarget ${CMAKE_PROJECT_NAME}-targets CACHE STRING\n  \"Name for the export target for ${CMAKE_PROJECT_NAME}\")\n\nset(AMPL_INCLUDE_DIRS ${amplsolver_SOURCE_DIR}\n                      ${amplsolver_BINARY_DIR} PARENT_SCOPE)\n                      \ninclude_directories(${amplsolver_SOURCE_DIR}\n                    ${amplsolver_BINARY_DIR})\n\nset(genarith_srcs arithchk.c)\nif(WIN32)\n  set_source_files_properties(arithchk.c PROPERTIES COMPILE_FLAGS \"-DNO_FPINIT\")\nelse()\n  list(APPEND genarith_srcs fpinit.c)\nendif()\nadd_executable(genarith ${genarith_srcs})\nif(UNIX)\n  target_link_libraries(genarith m)\nendif()\n\n\nconfigure_file(${amplsolver_SOURCE_DIR}/stdio1.h0 \n  ${amplsolver_BINARY_DIR}/stdio1.h)\n\nif(UNIX)\n  find_program(UNAME uname)\n  if(UNAME)\n    execute_process(COMMAND ${UNAME} -sr OUTPUT_VARIABLE System_details)\n  endif()\nelse()\n  set(System_details \"${CMAKE_SYSTEM_NAME}\")\nendif()\nstring(REPLACE \"\\n\" \"\"  System_details \"${System_details}\")\nconfigure_file(${amplsolver_SOURCE_DIR}/details.c0.cmake.in\n  ${amplsolver_BINARY_DIR}/details.c)\n\n# If genarith command fails, a zero length arith.h will be generated,\n# so remove on failure to cause later build failure\nadd_custom_command(\n  OUTPUT ${amplsolver_BINARY_DIR}/arith.h\n  COMMAND genarith > ${amplsolver_BINARY_DIR}/arith.h || \n    ${CMAKE_COMMAND} -E remove ${amplsolver_BINARY_DIR}/arith.h\n) \n\nset(amplsolver_SRCS\n  ${amplsolver_BINARY_DIR}/arith.h\n  ${amplsolver_BINARY_DIR}/details.c\n  asldate.c\n  atof.c\n  auxinfo.c\n  avldelete.c\n  avltree.c\n  b_search.c\n  basename.c\n  bscanf.c\n  com2eval.c\n  comeval.c\n  con1ival.c\n  con2ival.c\n  con2val.c\n  conadj.c\n  conpval.c\n  conscale.c\n  conval.c\n  derprop.c\n  dtoa1.c\n  duthes.c\n  dynlink.c\n  f_read.c\n  fg_read.c\n  fg_write.c\n  fgh_read.c\n  fpecatch.c\n  fpinit.c\n  fullhes.c\n  func_add.c\n  funcadd1.c\n  g_fmt.c\n  genrowno.c\n  getenv.c\n  getstub.c\n  htcl.c\n  jac0dim.c\n  jac2dim.c\n  jacdim.c\n  jacinc.c\n  jacinc1.c\n  mach.c\n  mainexit.c\n  mip_pri.c\n  misc.c\n  mypow.c\n  names.c\n  nl_obj.c\n  nqpcheck.c\n  obj2val.c\n  obj_prec.c\n  objconst.c\n  objval.c\n  objval_.c\n  op_type.c\n  pfg_read.c\n  pfghread.c\n  printf.c\n  pshvprod.c\n  punknown.c\n  qp_read.c\n  qpcheck.c\n  qsortv.c\n  readsol.c\n  repwhere.c\n  rops.c\n  rops2.c\n  sigcatch.c\n  sos_add.c\n  sphes.c\n  sscanf.c\n  stderr.c\n  studchk0.c\n  suf_sos.c\n  value.c\n  writesol.c\n  wrtsol_.c\n  ws_desc.c\n  wsu_desc.c\n  x2check.c\n  xectim.c\n  xp1known.c\n  xp2known.c)\n\nadd_library(amplsolver ${amplsolver_SRCS})\n\noption(AMPL_HAVE_DLOPEN \"Toggle support for dlopen in AMPL\" OFF)\nif (AMPL_HAVE_DLOPEN)\n  find_package(DL)\n  if (DL_FOUND)\n    add_definitions(\"-DAMPL_HAVE_DLOPEN\")\n  else()\n    message(WARNING \"dlopen requested, but not found\")\n  endif()\nendif()\n\nif(UNIX)\n  target_link_libraries(amplsolver ${DL_LIBRARY})\nendif()\n\n# Allow AMPL build to be shared among several source packages\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/AMPLConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/AMPLConfig.cmake\n)\n\ninstall(TARGETS amplsolver EXPORT ${ExportTarget} DESTINATION lib)\n#install(TARGETS genarith EXPORT ${ExportTarget} DESTINATION bin)\n\nfile(GLOB ampl_headers *.h *.hd)\ninstall(FILES ${ampl_headers} DESTINATION include/ampl)\ninstall(FILES ${amplsolver_BINARY_DIR}/arith.h ${amplsolver_BINARY_DIR}/stdio1.h\n  DESTINATION include/ampl)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/userman_cmake.tex": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\clearpage\n\\section{More About CMake}\n\\label{sec:cmake}\n\nDocumentation for CMake is part of the CMake installation\n(Section~\\ref{subinstall:CM}), and can be found on the CMake web site\n(\\href{http://cmake.org/}{http://cmake.org/}).\nFiles in the HOPSPACK source distribution named {\\sf CMakeLists.txt} or files\nthat end with the suffix {\\sf .cmake} were written for HOPSPACK.\nAny of these CMake files can be examined and potentially edited to alter\nCMake behavior.  The remainder of this section describes specific situations\nwhere you might want to alter behavior when building HOPSPACK.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Debugging the Build Process}\n\nSometimes it helps to see more makefile output during compilation.\nOn makefile systems detailed output is enabled by editing\n{\\sf ConfigureBuildType.cmake} and uncommenting the line\n\n\\hspace{0.2in}\n{\\tt SET (CMAKE\\_VERBOSE\\_MAKEFILE ON)}\n\n\\noindent\nThen you should call {\\tt cmake} in a clean ``out of source'' directory to\nrebuild the HOPSPACK makefiles.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Building a Debug Version of the Code}\n\nTo compile a HOPSPACK executable with debugging symbols, use the command line\noption {\\tt -DHOPSPACK\\_DEBUG:BOOL=true}.  For example, on a Linux machine\nstart in a clean ``out of source'' directory and call:\n\n\\hspace{0.2in}\n{\\tt > cmake ../hopspack-\\HOPSVER.x $\\;$ -DHOPSPACK\\_DEBUG:BOOL=true}\n\n\\noindent\nThen, of course, all files must be recompiled.\nOn Windows machines using the Visual Studio compiler, the debug option is\nusually true by default.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Specifying a Different Compiler}\n\nEarly in its configuration process, CMake chooses a C++ compiler to use.\nThe command line version usually prints messages about its choice; for example,\nhere is some of the output from the build of a serial HOPSPACK executable\non Linux:\n\\vspace{-11pt}\n\\begin{verbatim}\n      -- The CXX compiler identification is GNU\n      -- The C compiler identification is GNU\n      -- Check for working CXX compiler: /usr/bin/c++\n      -- Check for working CXX compiler: /usr/bin/c++ -- works\n      ...\n\\end{verbatim}\n\nYou can force CMake to use a different compiler by altering the environment\nvariables {\\tt CXX} and {\\tt CC}.  In addition, you can add compiler flags\nby setting {\\tt CXXFLAGS} and tell the linker to include certain libraries\nby setting {\\tt CMAKE\\_EXE\\_LINKER\\_FLAGS}.\nAs an example, suppose the Intel C++ compiler (version 8.1) is installed\non a Linux machine.  Assume the {\\sf bin} directory containing the\ncompiler {\\tt icc} is in {\\tt PATH}, and that the libraries directory is\nplaced in {\\tt LD\\_LIBRARY\\_PATH}.\nThen you instruct CMake to build a makefile system as follows:\n\\vspace{-11pt}\n\\begin{tabbing}\n  xxx \\= xxxxxxxxx \\= \\kill\n  \\> {\\tt > mkdir build\\_serial} \\\\\n  \\> {\\tt > cd build\\_serial} \\\\\n  \\> {\\tt > export CXX=icc} \\\\\n  \\> {\\tt > export CC=icc} \\\\\n  \\> {\\tt > export CXXFLAGS=-cxxlib-icc} \\\\\n  \\> {\\tt > cmake ../hopspack-\\HOPSVER.x  $\\; \\backslash$} \\\\\n  \\> \\> {\\tt -DCMAKE\\_EXE\\_LINKER\\_FLAGS=\"-lcprts -lcxa -lunwind\"} \\\\\n  \\> {\\tt -- The CXX compiler identification is Intel} \\\\\n  \\> {\\tt -- The C compiler identification is Intel} \\\\\n  \\> {\\tt ...}\n\\end{tabbing}\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Fortran Compiler Warnings}\n\nCMake configuration files are capable of linking with LAPACK Fortran\nlibraries (see \\SECREF{subinstall:LA}).  For this reason, the initial\nCMake configuration step may look for a Fortran compiler and warn\nif one cannot be found:\n\\vspace{-11pt}\n\\begin{tabbing}\n  xxx \\= xxxxxxxxx \\= \\kill\n  \\> {\\tt ...} \\\\\n  \\> {\\tt -- Looking for a Fortran compiler} \\\\\n  \\> {\\tt -- Looking for a Fortran compiler - NOTFOUND} \\\\\n  \\> {\\tt ...}\n\\end{tabbing}\n\n\\noindent\nThis warning can be ignored unless LAPACK is based on Fortran libraries,\nin which case the build will probably fail.  If LAPACK is Fortran-based,\nthen the Fortran compiler may be invoked to generate adaptive function\ndeclarations in {\\sf src/src-shared/HOPSPACK\\_LapackWrappers.cpp}.\n\n\n%%%%%%%%%%%%%%%%%%%%\n\\subsection{Adding Libraries to an Executable}\n\\label{subsec:cmakeaddlib}\n\nIf source code modifications introduce dependencies on external libraries,\nthen CMake must be given the library names so they can be linked with the\nexecutables.\n\nA simple way is to add the library name explicitly in the CMake\nconfiguration file that generates an executable.  For example, suppose the\nserial version of HOPSPACK on a Linux machine needs to link with the {\\sf dl}\nsystem library (perhaps the function {\\tt dlopen()} was called in a custom\nevaluator such as the one described in \\SECREF{subcalleval:inlineeval}).\nA simple fix is to edit {\\sf src/src-main/CMakeLists.txt} and add\n{\\tt -ldl} in the list of {\\tt TARGET\\_LINK\\_LIBRARIES} at the bottom of\nthe file.  Assuming the library is in the system's load path, CMake will\nfind it the next time the executable is built.\n\nThe simple fix described above is hard-coded for Linux.  If the library\nexists on all platforms, then CMake has a better way.\nFor example, suppose you want to link a personal library of utility functions\nnamed ``myutils''.  On Linux this would typically be named {\\sf libmyutils.a}\nor {\\sf libmyutils.so}, while Windows would typically name it {\\sf myutils.dll}.\nCMake provides a utility that finds the platform-specific name:\n\n\\hspace{0.2in}\n{\\tt FIND LIBRARY (MY\\_UTILS\\_VAR NAMES myutils DOC \"find myutils\")}\n\n\\noindent\nThis stores the platform-specific name in the CMake variable named\n{\\tt MY\\_UTILS\\_VAR}.  Add the variable to the list of\n{\\tt TARGET\\_LINK\\_LIBRARIES} instead of a hard-coded name.\n\nFor more examples, look at {\\sf ConfigureLapack.cmake} and\n{\\sf ConfigureSysLibs.cmake} in the top directory of the HOPSPACK distribution.\n\n\n\n%TBD...Rollin Thomas needs a little explanation of CMake where to put -I and -L\n\n\n\n%TBD...name and describe ConfigureLapack.cmake, the g2c location\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/configure.ac": "# See notes in Makefile.am\n\n# TODO\n# * Probe for necessary headers/libs?\n# * Manage optional libraries for dlopen\n#   and also use a more generic name than dl_solver\n\nAC_PREREQ([2.60])\nAC_INIT([NIDR],[1.201006],[dakota-developers@development.sandia.gov])\n\nAM_INIT_AUTOMAKE([1.9 foreign])\nAM_MAINTAINER_MODE\n\nAC_LANG([C])\n\ndnl DL_SOLVER package check (toggles NIDR DL features and DL_SOLVER).\nAC_ARG_WITH([dl_solver],\n            AS_HELP_STRING([--with-dl_solver], [turn DL_SOLVER support on]),\n\t    [with_dl_solver=$withval], [with_dl_solver=no])\ndnl if no dl_solver, -DNO_NIDR_DYNLIB set in src/Makefile.am\nAM_CONDITIONAL([WITH_DL_SOLVER], [test \"x$with_dl_solver\" = xyes ])\n\n\ndnl Specification maintenance mode; must be enabled to update NIDR\ndnl itself or the specification of programs depending on it\nAC_ARG_ENABLE([spec-maint],\n              AS_HELP_STRING([--enable-spec-maint], \n                             [enable specification maintenance]),\n              [enable_spec_maint=$enableval], [enable_spec_maint=no])\nAM_CONDITIONAL([ENABLE_SPEC_MAINT], [test \"x$enable_spec_maint\" = xyes ])\n\nAC_PROG_CC\nAC_PROG_RANLIB\n\ndnl Probe for programs needed to regenerate spec or NIDR itself\n#if test \"x$enable_spec_maint\" = xyes; then\n#  AC_PROG_LEX\n#  AC_PROG_YACC\n#  AC_PROG_SED\n#fi\nLEX=lex\nAC_SUBST(LEX) \nYACC=\"bison -y\"\nAC_SUBST(YACC) \nSED=sed\nAC_SUBST(SED) \n\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/nidrgen.c": "/* A lexical scanner generated by flex*/\n\n/* Scanner skeleton version:\n * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $\n */\n\n#define FLEX_SCANNER\n#define YY_FLEX_MAJOR_VERSION 2\n#define YY_FLEX_MINOR_VERSION 5\n\n#include <stdio.h>\n\n/* for isatty() */\n#if defined(_WIN32) || defined(_WIN64)\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */\n#ifdef c_plusplus\n#ifndef __cplusplus\n#define __cplusplus\n#endif\n#endif\n\n\n#ifdef __cplusplus\n\n#include <stdlib.h>\n\n/* Use prototypes in function declarations. */\n#define YY_USE_PROTOS\n\n/* The \"const\" storage-class-modifier is valid. */\n#define YY_USE_CONST\n\n#else\t/* ! __cplusplus */\n\n#if __STDC__\n\n#define YY_USE_PROTOS\n#define YY_USE_CONST\n\n#endif\t/* __STDC__ */\n#endif\t/* ! __cplusplus */\n\n#ifdef __TURBOC__\n #pragma warn -rch\n #pragma warn -use\n#include <io.h>\n#include <stdlib.h>\n#define YY_USE_CONST\n#define YY_USE_PROTOS\n#endif\n\n#ifdef YY_USE_CONST\n#define yyconst const\n#else\n#define yyconst\n#endif\n\n\n#ifdef YY_USE_PROTOS\n#define YY_PROTO(proto) proto\n#else\n#define YY_PROTO(proto) ()\n#endif\n\n/* Returned upon end-of-file. */\n#define YY_NULL 0\n\n/* Promotes a possibly negative, possibly signed char to an unsigned\n * integer for use as an array index.  If the signed char is negative,\n * we want to instead treat it as an 8-bit unsigned char, hence the\n * double cast.\n */\n#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n\n/* Enter a start condition.  This macro really ought to take a parameter,\n * but we do it the disgusting crufty way forced on us by the ()-less\n * definition of BEGIN.\n */\n#define BEGIN yy_start = 1 + 2 *\n\n/* Translate the current start state into a value that can be later handed\n * to BEGIN to return to the state.  The YYSTATE alias is for lex\n * compatibility.\n */\n#define YY_START ((yy_start - 1) / 2)\n#define YYSTATE YY_START\n\n/* Action number for EOF rule of a given start state. */\n#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n\n/* Special action meaning \"start processing a new file\". */\n#define YY_NEW_FILE yyrestart( yyin )\n\n#define YY_END_OF_BUFFER_CHAR 0\n\n/* Size of default input buffer. */\n#define YY_BUF_SIZE 16384\n\ntypedef struct yy_buffer_state *YY_BUFFER_STATE;\n\nextern int yyleng;\nextern FILE *yyin, *yyout;\n\n#define EOB_ACT_CONTINUE_SCAN 0\n#define EOB_ACT_END_OF_FILE 1\n#define EOB_ACT_LAST_MATCH 2\n\n/* The funky do-while in the following #define is used to turn the definition\n * int a single C statement (which needs a semi-colon terminator).  This\n * avoids problems with code like:\n *\n * \tif ( condition_holds )\n *\t\tyyless( 5 );\n *\telse\n *\t\tdo_something_else();\n *\n * Prior to using the do-while the compiler would get upset at the\n * \"else\" because it interpreted the \"if\" statement as being all\n * done when it reached the ';' after the yyless() call.\n */\n\n/* Return all but the first 'n' matched characters back to the input stream. */\n\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\t*yy_cp = yy_hold_char; \\\n\t\tYY_RESTORE_YY_MORE_OFFSET \\\n\t\tyy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\\n\t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n\t\t} \\\n\twhile ( 0 )\n\n#define unput(c) yyunput( c, yytext_ptr )\n\n/* Some routines like yy_flex_realloc() are emitted as static but are\n   not called by all lexers. This generates warnings in some compilers,\n   notably GCC. Arrange to suppress these. */\n#ifdef __GNUC__\n#define YY_MAY_BE_UNUSED __attribute__((unused))\n#else\n#define YY_MAY_BE_UNUSED\n#endif\n\n/* The following is because we cannot portably get our hands on size_t\n * (without autoconf's help, which isn't available because we want\n * flex-generated scanners to compile on their own).\n */\ntypedef unsigned int yy_size_t;\n\n\nstruct yy_buffer_state\n\t{\n\tFILE *yy_input_file;\n\n\tchar *yy_ch_buf;\t\t/* input buffer */\n\tchar *yy_buf_pos;\t\t/* current position in input buffer */\n\n\t/* Size of input buffer in bytes, not including room for EOB\n\t * characters.\n\t */\n\tyy_size_t yy_buf_size;\n\n\t/* Number of characters read into yy_ch_buf, not including EOB\n\t * characters.\n\t */\n\tint yy_n_chars;\n\n\t/* Whether we \"own\" the buffer - i.e., we know we created it,\n\t * and can realloc() it to grow it, and should free() it to\n\t * delete it.\n\t */\n\tint yy_is_our_buffer;\n\n\t/* Whether this is an \"interactive\" input source; if so, and\n\t * if we're using stdio for input, then we want to use getc()\n\t * instead of fread(), to make sure we stop fetching input after\n\t * each newline.\n\t */\n\tint yy_is_interactive;\n\n\t/* Whether we're considered to be at the beginning of a line.\n\t * If so, '^' rules will be active on the next match, otherwise\n\t * not.\n\t */\n\tint yy_at_bol;\n\n\t/* Whether to try to fill the input buffer when we reach the\n\t * end of it.\n\t */\n\tint yy_fill_buffer;\n\n\tint yy_buffer_status;\n#define YY_BUFFER_NEW 0\n#define YY_BUFFER_NORMAL 1\n\t/* When an EOF's been seen but there's still some text to process\n\t * then we mark the buffer as YY_EOF_PENDING, to indicate that we\n\t * shouldn't try reading from the input source any more.  We might\n\t * still have a bunch of tokens to match, though, because of\n\t * possible backing-up.\n\t *\n\t * When we actually see the EOF, we change the status to \"new\"\n\t * (via yyrestart()), so that the user can continue scanning by\n\t * just pointing yyin at a new input file.\n\t */\n#define YY_BUFFER_EOF_PENDING 2\n\t};\n\nstatic YY_BUFFER_STATE yy_current_buffer = 0;\n\n/* We provide macros for accessing buffer states in case in the\n * future we want to put the buffer states in a more general\n * \"scanner state\".\n */\n#define YY_CURRENT_BUFFER yy_current_buffer\n\n\n/* yy_hold_char holds the character lost when yytext is formed. */\nstatic char yy_hold_char;\n\nstatic int yy_n_chars;\t\t/* number of characters read into yy_ch_buf */\n\n\nint yyleng;\n\n/* Points to current character in buffer. */\nstatic char *yy_c_buf_p = (char *) 0;\nstatic int yy_init = 1;\t\t/* whether we need to initialize */\nstatic int yy_start = 0;\t/* start state number */\n\n/* Flag which is used to allow yywrap()'s to do buffer switches\n * instead of setting up a fresh yyin.  A bit of a hack ...\n */\nstatic int yy_did_buffer_switch_on_eof;\n\nvoid yyrestart YY_PROTO(( FILE *input_file ));\n\nvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));\nvoid yy_load_buffer_state YY_PROTO(( void ));\nYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));\nvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));\nvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));\nvoid yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));\n#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )\n\nYY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));\nYY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));\nYY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));\n\nstatic void *yy_flex_alloc YY_PROTO(( yy_size_t ));\nstatic void *yy_flex_realloc YY_PROTO(( void *, yy_size_t )) YY_MAY_BE_UNUSED;\nstatic void yy_flex_free YY_PROTO(( void * ));\n\n#define yy_new_buffer yy_create_buffer\n\n#define yy_set_interactive(is_interactive) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_is_interactive = is_interactive; \\\n\t}\n\n#define yy_set_bol(at_bol) \\\n\t{ \\\n\tif ( ! yy_current_buffer ) \\\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \\\n\tyy_current_buffer->yy_at_bol = at_bol; \\\n\t}\n\n#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)\n\ntypedef unsigned char YY_CHAR;\nFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;\ntypedef int yy_state_type;\nextern char *yytext;\n#define yytext_ptr yytext\n\nstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));\nstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));\nstatic int yy_get_next_buffer YY_PROTO(( void ));\nstatic void yy_fatal_error YY_PROTO(( yyconst char msg[] ));\n\n/* Done after the current pattern has been matched and before the\n * corresponding action - sets up yytext.\n */\n#define YY_DO_BEFORE_ACTION \\\n\tyytext_ptr = yy_bp; \\\n\tyyleng = (int) (yy_cp - yy_bp); \\\n\tyy_hold_char = *yy_cp; \\\n\t*yy_cp = '\\0'; \\\n\tyy_c_buf_p = yy_cp;\n\n#define YY_NUM_RULES 43\n#define YY_END_OF_BUFFER 44\nstatic yyconst short int yy_accept[128] =\n    {   0,\n        0,    0,    0,    0,    0,    0,   44,   42,    2,    1,\n       42,   34,   35,   42,   42,   16,   27,   25,   42,   42,\n       42,   42,   42,   42,   42,   42,   42,   36,   37,   15,\n       31,   33,   32,   34,   35,   38,   39,   30,   42,   42,\n       29,   28,    2,    0,   40,   41,   23,   26,   24,    0,\n        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n       15,   38,    0,   29,   29,   29,    0,   28,    0,    0,\n        0,    0,    0,    0,   22,    0,    0,    0,   18,   29,\n        0,   29,    0,   17,    0,    0,    0,    0,   21,    0,\n       11,    0,    0,    0,   19,    0,    0,    0,    0,    0,\n\n        0,   20,    0,    0,    0,    0,   13,    3,    4,    6,\n       10,    0,    0,    3,    0,    0,    7,   12,    0,    0,\n        8,    9,    0,    0,   14,    5,    0\n    } ;\n\nstatic yyconst int yy_ec[256] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    2,    1,    4,    5,    1,    1,    1,    1,    6,\n        7,    8,    9,   10,    9,   11,   12,   13,   14,   15,\n       16,   16,   16,   16,   16,   16,   16,   17,   18,   19,\n       20,   21,    1,    1,   22,   23,   24,   25,   26,   27,\n       28,   27,   29,   27,   30,   31,   32,   33,   34,   35,\n       27,   36,   37,   38,   39,   27,   40,   27,   41,   27,\n       42,    1,   43,    1,   44,    1,   45,   45,   45,   45,\n\n       46,   45,   45,   45,   45,   45,   45,   45,   45,   45,\n       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,\n       45,   45,   47,   48,   49,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1\n    } ;\n\nstatic yyconst int yy_meta[50] =\n    {   0,\n        1,    2,    1,    1,    1,    2,    2,    2,    2,    2,\n        2,    2,    3,    3,    3,    3,    2,    1,    2,    1,\n        2,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    2,    2,    3,    3,    3,    1,    1,    1\n    } ;\n\nstatic yyconst short int yy_base[131] =\n    {   0,\n        0,    0,   49,    0,   98,    0,  315,  316,  312,  316,\n      310,  316,  316,  304,  291,  316,  290,  289,  277,  122,\n      271,  273,  279,  123,  278,  265,  280,  316,  316,  140,\n      316,  316,  316,    0,    0,    0,  316,  316,  146,  151,\n      157,    0,  299,  297,  316,  316,  316,  316,  316,  270,\n      261,  264,  262,  257,  253,  260,  269,  269,  254,  261,\n      161,    0,  165,  176,  182,  197,  205,    0,  266,  263,\n      255,  246,  258,  243,  260,  240,  241,  239,  316,  211,\n      216,  220,  230,  316,  237,  230,  236,  229,  316,  240,\n      230,  227,  257,  235,  316,  230,  219,  222,  224,  224,\n\n      148,  316,  215,  225,  223,  211,  211,  225,  186,  186,\n      316,  178,  186,  231,  180,  190,  186,  316,  151,  145,\n      316,  316,  131,  120,  316,  316,  316,  277,  279,  148\n    } ;\n\nstatic yyconst short int yy_def[131] =\n    {   0,\n      127,    1,  127,    3,  127,    5,  127,  127,  127,  127,\n      128,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  129,  129,  129,  127,  127,  127,  127,\n      127,  130,  127,  128,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  129,  127,  127,  127,  127,  127,  130,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,    0,  127,  127,  127\n    } ;\n\nstatic yyconst short int yy_nxt[366] =\n    {   0,\n        8,    9,   10,    8,   11,   12,   13,    8,    8,    8,\n        8,   14,    8,    8,    8,    8,   15,   16,   17,    8,\n       18,   19,    8,    8,   20,    8,    8,   21,   22,   23,\n       24,    8,    8,    8,    8,   25,   26,   27,    8,    8,\n        8,   28,   29,    8,   30,   30,   31,   32,   33,    8,\n        9,   10,    8,   11,   34,   35,    8,    8,    8,    8,\n       14,   36,   36,   36,   36,    8,   37,    8,    8,    8,\n       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,\n       36,   36,   36,   36,   36,   36,   36,   36,   36,   36,\n       28,   29,   36,   36,   36,   31,   32,   33,    8,    9,\n\n       10,   38,   11,   12,   13,    8,   39,    8,   40,   14,\n       41,   41,   41,   41,    8,    8,    8,    8,    8,   42,\n       42,   42,   42,   42,   42,   42,   42,   42,   42,   42,\n       42,   42,   42,   42,   42,   42,   42,   42,   42,   28,\n       29,    8,   42,   42,   31,   32,   33,   51,   56,  101,\n       68,   57,   61,   61,   61,   61,   63,  126,   64,   64,\n       64,   64,   52,   65,   65,   65,   65,   66,  125,   64,\n       64,   64,   64,   61,   61,   61,   61,   65,   65,   65,\n       65,  124,   67,   61,   61,   61,   66,  123,   64,   64,\n       64,   64,  108,  108,   65,   65,   65,   65,  116,  117,\n\n      122,   67,   67,  121,   61,   61,   61,   67,  120,   80,\n       80,   80,   80,   81,  119,  118,  115,   82,   82,   82,\n       82,   67,   67,   80,   80,   80,   80,   67,   82,   82,\n       82,   82,   82,   82,   82,   82,   67,  114,  114,  114,\n      114,  113,   67,  114,  114,  114,  114,  112,  111,  110,\n      109,  107,  106,  105,  104,  103,   67,  102,  101,  100,\n       99,   98,   97,   96,   95,   94,   93,   92,  114,  114,\n      114,   91,   90,   89,  114,  114,  114,   44,   44,   44,\n       62,   62,   88,   87,   86,   85,   84,   83,   79,   78,\n       77,   76,   75,   74,   73,   72,   71,   70,   69,   45,\n\n       43,   60,   59,   58,   55,   54,   53,   50,   49,   48,\n       47,   46,   45,   43,  127,    7,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127\n    } ;\n\nstatic yyconst short int yy_chk[366] =\n    {   0,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n        1,    1,    1,    1,    1,    1,    1,    1,    1,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,\n        3,    3,    3,    3,    3,    3,    3,    3,    5,    5,\n\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,\n        5,    5,    5,    5,    5,    5,    5,   20,   24,  101,\n      130,   24,   30,   30,   30,   30,   39,  124,   39,   39,\n       39,   39,   20,   40,   40,   40,   40,   41,  123,   41,\n       41,   41,   41,   61,   61,   61,   61,   63,   63,   63,\n       63,  120,   41,   30,   30,   30,   64,  119,   64,   64,\n       64,   64,  101,  101,   65,   65,   65,   65,  110,  110,\n\n      117,   64,   41,  116,   61,   61,   61,   65,  115,   66,\n       66,   66,   66,   67,  113,  112,  109,   67,   67,   67,\n       67,   64,   66,   80,   80,   80,   80,   65,   81,   81,\n       81,   81,   82,   82,   82,   82,   80,  108,  108,  108,\n      108,  107,   66,  114,  114,  114,  114,  106,  105,  104,\n      103,  100,   99,   98,   97,   96,   80,   94,   93,   92,\n       91,   90,   88,   87,   86,   85,   83,   78,  108,  108,\n      108,   77,   76,   75,  114,  114,  114,  128,  128,  128,\n      129,  129,   74,   73,   72,   71,   70,   69,   60,   59,\n       58,   57,   56,   55,   54,   53,   52,   51,   50,   44,\n\n       43,   27,   26,   25,   23,   22,   21,   19,   18,   17,\n       15,   14,   11,    9,    7,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127,  127,  127,  127,  127,  127,\n      127,  127,  127,  127,  127\n    } ;\n\nstatic yy_state_type yy_last_accepting_state;\nstatic char *yy_last_accepting_cpos;\n\n/* The intent behind this definition is that it'll catch\n * any uses of REJECT which flex missed.\n */\n#define REJECT reject_used_but_not_detected\n#define yymore() yymore_used_but_not_detected\n#define YY_MORE_ADJ 0\n#define YY_RESTORE_YY_MORE_OFFSET\nchar *yytext;\n/* #line 1 \"nidrgen.l\" */\n#define INITIAL 0\n/* #line 2 \"nidrgen.l\" */\n/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"nidr.h\"\t/* for KeyWordKind */\n\n#ifndef NO_NIDR_DYNLIB\ntypedef KeyWord *(*KW_ADD)(void);\n#ifdef _WIN32\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#endif\n\n#ifndef DMBLK_GULP\n#define DMBLK_GULP 1024\n#endif\n#ifndef DMLBK_SGULP\n#define DMBLK_SGULP 16000\n#endif\n#ifndef MBLK_GULP\n#define MBLK_GULP 8191\n#endif\n#ifndef KWSTACKLEN\n#define KWSTACKLEN 100\t/*should be overkill*/\n#endif\n#ifndef DEFTAGLEN\n#define DEFTAGLEN 2048\t/* should be overkill*/\n#endif\n\n typedef union\nYYSTYPE { char *s; } YYSTYPE;\n\n enum LastSeen {\n\tSaw_kwname\t= 1,\n\tSaw_type\t= 2,\n\tSaw_func\t= 3,\n\tSaw_dflt\t= 4,\n\tSaw_dfltname\t= 5,\n\tSaw_lt\t\t= 6,\n\tSaw_le\t\t= 7,\n\tSaw_ge\t\t= 8,\n\tSaw_gt\t\t= 9,\n\tSaw_desc\t= 10,\n\tSaw_group\t= 11,\n\tSaw_tag\t\t= 12,\n\tSaw_len\t\t= 13,\n\tSaw_dy\t\t= 14\n\t};\n\n static const char *tokname[] = {\n\t\"<bug>\",\n\t\"kwname\",\n\t\"type\",\n\t\"{funcspec}\",\n\t\":=\",\n\t\"#define name for :=\",\n\t\"<\",\n\t\"<=\",\n\t\">=\",\n\t\">\",\n\t\"DESC\",\n\t\"GROUP\",\n\t\"TAG\",\n\t\"LEN\"\n\t};\n\n enum ParState {\n\t/* parstate values... */\n\tPPar_emtpy\t= 0,\n\tPPar_starting\t= 1,\n\tPPar_started\t= 2,\n\tPPar_leftpar\t= 3,\n\tDupchecking\t= 4,\n\tDupchecked\t= 5,\n\tPrinting\t= 6,\n\tKwStacked\t= 7,\n\tSorted\t\t= 8,\n\tLeftput\t\t= 9,\n\tParchecked\t= 10\n\t};\n\n /* values for lastseen also include single characters ( [ { } ] ) ; */\n\n /* enums to make constants visible to debuggers */\n enum {\n\tDMblk_gulp\t= DMBLK_GULP,\n\tDmblk_sgulp\t= DMBLK_SGULP,\n\tMblk_gulp\t= MBLK_GULP,\n\tKW_stacklen\t= KWSTACKLEN,\n\tBr_stacklen\t= 2*KW_stacklen,\n\tDHTlen\t\t= 997,\n\tDHTfactor\t= 43,\n\tHTlen\t\t= 127,\n\tKWPlen\t\t= 32,\n\tKWOUTlen0\t= 128 };\n\n typedef struct Defhash Defhash;\n typedef struct DefhashHead DefhashHead;\n typedef struct DefhashTab DefhashTab;\n typedef struct HashHead HashHead;\n typedef struct KWctx KWctx;\n typedef struct Mblk Mblk;\n typedef struct Taghash Taghash;\n typedef struct StrList StrList;\n\n struct\nDefhashHead {\n\tDefhashHead *hnext, *thread;\n\tchar *name;\n\t};\n\n struct\nDefhash {\n\tDefhashHead hh;\n\tchar *value;\n\tint qkeep;\n\t};\n\n struct\nTaghash {\n\tDefhashHead hh;\n\tKWctx *kw;\n\tint uses;\n\t};\n\n struct\nDefhashTab {\n\tDefhashHead *Tab[DHTlen];\n\tDefhashHead *lastdh;\n\tsize_t nalloc;\t/* size of new entry allocations in units of sizeof(void*) */\n\tint nent;\n\t};\n\n struct\nMblk {\n\tMblk *next;\n\tvoid *stuff[Mblk_gulp];\n\t};\n\n struct\nHashHead { HashHead *hnext, *hprev; };\n\n struct\nStrList {\n\tHashHead h;\n\tStrList *next;\n\tchar *val;\n\tint Lineno;\n\tint primary;\n\tint seqno;\n\tint needrev;\n\t};\n\n struct\nKWctx {\n\tKWctx *next;\n\tStrList *names;\t/* list of name and aliases */\n\tchar *name1;\t/* first name (for tagout) */\n\tKWctx *kw;\t/* list of contained keywords */\n\tKWctx *master;\t/* non-null ==> this is an alias; use master's kwkno */\n\tKWctx *pmaster;\t/* used in computing paoff */\n\tKWctx *pparent;\t/* paren parent, for ((...)|(...) ...) */\n\tKWctx *rparent;\t/* \"real\" parent, for stuff inside ((...)) */\n\tStrList *funcs;\t/* pre- and post order functions and (void*) args */\n\tchar *Br_top;\t/* Br_top when this keyword began */\n\tchar *lb;\t/* lower bound (if kind & KWKind_Lb is nonzero) */\n\tchar *ub;\t/* upper bound (if kind & KWKind_Ub is nonzero) */\n\tchar *init;\t/* initial value (if kind & KWKind_init is nonzero) and */\n\t\t\t/* kind & KWKind_Mask is 1 or 2 (KWKind_Int or KWKind_Real) */\n\tchar *cinit;\t/* initial value for STRING-valued keyword,\t*/\n\t\t\t/* ==> (kind & (KWKind_Mask | KWKind_init))\t*/\n\t\t\t/*\t== (KWKind_Str | KWKind_init)\t\t*/\n\tchar *defname;\t/* name of preprocessor token to be #defined */\n\tchar *desc;\n\tchar *dylib;\n\tchar *group;\n\tchar *tag;\n\tchar *len;\t/* keyword giving array length */\n\tsize_t dtnext;\t/* for adjusting deftag when this keyword goes out of scope */\n\tsize_t name1len;\n\tint alt;\t/* alternative group number of this keyword */\n\tint kind;\t/* kind of values for this keyword */\n\tint kno;\t/* number of this keyword, for generating kw_n names */\n\tint kwkno;\t/* number of this keyword's kw array (if any) */\n\tint kwknop;\t/* if this is a pparent and has a pparent, kwkno for this and parents */\n\tint nalt;\t/* number of alternative groups in contained keywords */\n\tint nfcn;\t/* number of function and arg entries in funcs */\n\tint nkw;\t/* number of contained keywords */\n\tint nreq;\t/* number of required elements in contained keywords */\n\tint req;\t/* required group for this keyword (0 if optional) */\n\tenum ParState parstate;\t/* state in handling ((...)) */\n\tint altoffset;\t/* for expand */\n\tint reqoffset;\t/* for expand */\n\tint level;\n\tint objno;\t/* for kwcomp2 */\n\tint agroup;\t/* for GuiKeyWord */\n\tint paoff;\t/* offset of primary keyword */\n\t};\n\n static int lastagroup, lastobjno, nalias, seqno;\n\n Defhash *lastdef;\n DefhashTab DHTab, TagTab;\n FILE *mtagout, *tagin, *tagout;\n HashHead HTab[HTlen];\n KWctx KWbase, *lastkw, *lastkw1;\n KWctx *KWStack[KW_stacklen], **KWtop = KWStack;\n Mblk FirstMblk, *CurMblk = &FirstMblk;\n YYSTYPE yyval;\n char Br_stack[Br_stacklen], *Br_top = Br_stack;\n char deftag[DEFTAGLEN], *dtend = deftag + DEFTAGLEN - 2, *dtnext = deftag;\n char *infname, *lasttag, *progname, *specfile, *tagfname;\n int Lineno = 1, dfltgroup = 1, startwarn = 1, wantfuncs = 1;\n int brace, btype, dupnames, dynlibseen, dynline, expand, guikeywds, ignoretags;\n int kwmult, lastkno, lastseen, liberror, libexpand, missing, needcomma, nsquawk;\n int or_mode, saweof;\n size_t mbavail = Mblk_gulp;\n void **mbnext = FirstMblk.stuff;\n static void Eat_comment(void);\n static void Keywd(const char *);\n static void Saw_num(const char*);\n static void Saw_quote(void);\n static void Saw_tok(int, int);\n\n /* Possible values for *Br_top:\n //\t 0  ==> empty (for Br_stack[0] only)\n //\t'(' ==> open paren seen, awaiting ')'\n //\t'[' ==> open square bracket, awaiting ']'\n */\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s:\\n\\tbotch on line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s: line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\t++nsquawk;\n\t}\n\n static void*\nMalloc(size_t L, const char *where)\n{\n\tvoid *rv = malloc(L);\n\tif (!rv)\n\t\tbotch(\"malloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n static void*\nRealloc(void *rv, size_t L, const char *where)\n{\n\trv = realloc(rv, L);\n\tif (!rv)\n\t\tbotch(\"ralloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n void\nunexpected(const char *what)\n{ botch(\"unexpected \\\"%s\\\"\", what); }\n\n static void *\nAlloc(size_t len)\n{\n\tMblk *mb;\n\tsize_t L;\n\tvoid *rv;\n\n\tL = (len + sizeof(void*) - 1)/sizeof(void*);\n\tif (L >= Mblk_gulp)\n\t\tbotch(\"Alloc(%lu) failure\", (unsigned long)len);\n\tif (L > mbavail) {\n\t\tif (!(mb = CurMblk->next)) {\n\t\t\tmb = (Mblk*)Malloc(sizeof(Mblk), \"Alloc\");\n\t\t\tCurMblk->next = mb;\n\t\t\t}\n\t\tCurMblk = mb;\n\t\tmbavail = Mblk_gulp;\n\t\tmbnext = mb->stuff;\n\t\tmb->next = 0;\n\t\tmemset(mbnext, 0, sizeof(mb->stuff));\n\t\t}\n\trv = mbnext;\n\tmbnext += L;\n\tmbavail -= L;\n\treturn rv;\n\t}\n\n StrList *\nnew_StrList(const char *s, StrList *nxt)\n{\n\tsize_t L = strlen(s) + 1;\n\tStrList *rv = (StrList*)Alloc(sizeof(StrList) + L);\n\tstrcpy(rv->val = (char*)(rv + 1), s);\n\tif ((rv->next = nxt))\n\t\trv->needrev = 1;\n\trv->Lineno = Lineno;\n\treturn rv;\n\t}\n\n static void\nAlias(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\n\tif (lastseen != Saw_kwname)\n\t\tbotch(\"ALIAS out of place\");\n\tkw = lastkw;\n\tfor(s += 6; *s <= ' '; s++);\n\tsl = kw->names = new_StrList(s, kw->names);\n\t++nalias;\n\tsl->seqno = ++seqno;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nreqchk(const char *a, const char *s)\n{\n\tif (a)\n\t\twhile(*a)\n\t\t\tif (*a++ == lastseen)\n\t\t\t\treturn;\n\tbotch(\"\\\"%s\\\" out of place\", s);\n\t}\n\n static void\nreqchk1(const char *a, const char *s)\n{\n\tint c;\n\n\tif (*Br_top != *s) {\n\t\tif ((c = *Br_top)) {\n\t\t\tswitch(c) {\n\t\t\t case '[': c = ']'; break;\n\t\t\t case '(': c = ')'; break;\n\t\t\t default:  c = '?';\n\t\t\t }\n\t\t\tbotch(\"Missing '%c'\", c);\n\t\t\t}\n\t\telse\n\t\t\ta = 0;\n\t\t}\n\treqchk(a, s+1);\n\t}\n\n static void\nBar(void)\n{\n\tstatic char allowed[] = { /*(*/ ')', Saw_kwname, Saw_type, 0 };\n\treqchk(KWtop - KWStack > 1 || KWtop[0]->kw ? allowed : \"\", \"|\");\n\tlastseen = '|';\n\tlastkw = lastkw1 = 0;\n\tor_mode = 1;\n\t}\n\n static void\nLpar(void)\n{\n\tKWctx *kw;\n\tint olastseen = lastseen;\n\tstatic char allowed[] = { '(', '[', '|', ']', ')', Saw_kwname, Saw_type, 0 };\n\n\treqchk(allowed, \"(\"/*)*/);\n\tlastseen = '('; /*)*/\n\tif (KWtop > KWStack) {\n\t\tkw = KWtop[0];\n\t\tif (or_mode && kw->parstate == PPar_leftpar && !kw->kw) {\n\t\t\tdtnext = deftag + kw->dtnext;\n\t\t\t--KWtop;\n\t\t\tKeywd(0);\n\t\t\tkw->pparent = KWtop[0];\n\t\t\t}\n\t\telse if (olastseen == '(' || olastseen == '[' /*])*/)\n\t\t\tKeywd(0);\n\t\tlastseen = '(' /*)*/;\n\t\t}\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\t*Br_top = '('; /*)*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLsqb(void)\n{\n\tstatic char allowed[] = { /*([*/ ']', ')', Saw_kwname, Saw_type, 0 };\n\treqchk(allowed, \"[\"/*]*/);\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\tlastseen = *Br_top = '['; /*]*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRpar(void)\n{\n\tstatic char allowed[] =  {/*[(*/ ')', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"()\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\tif (!KWtop[0]->kw && KWtop - KWStack > 2\n\t && KWtop[-1]->parstate == PPar_starting)\n\t\tKWtop[-1]->Br_top = Br_top;\n\t--KWtop;\n\tlastseen = /*(*/ ')';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRsqb(void)\n{\n\tstatic char allowed[] = {/*(*/')', '[', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"[]\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\t--KWtop;\n\tlastseen = /*[*/ ']';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLbrace(void)\n{\n\tif (brace++ || (lastseen != Saw_kwname && lastseen != Saw_type))\n\t\tunexpected(\"{\");\n\tlastseen = '{'; /*}}*/\n\t}\n\n static void\nRbrace(void)\n{\n\tif (--brace || (lastseen != Saw_func && lastseen != ';'))\n\t\t/*{{*/unexpected(\"}\");\n\tlastseen = Saw_type;\n\t}\n\n static void\nType(int n, const char *s)\n{\n\tif (lastseen != Saw_kwname || !lastkw)\n\t\tbotch(\"type %s out of place\", s);\n\tlastkw->kind |= n;\n\tlastkw = 0;\n\tlastseen = Saw_type;\n\t}\n\n static char *\ndef_name(const char *s0)\n{\n\tchar *s;\n\tconst char *s1;\n\tsize_t L, L1;\n\tstatic char *slast, *snext;\n\n\ts1 = s0;\n\twhile(*s1++);\n\tL = s1 - s0;\n\tif (snext + L > slast) {\n\t\tsnext = (char*)Malloc(L1 = Dmblk_sgulp + L, \"def_name\");\n\t\tslast = snext + L1;\n\t\t}\n\tstrcpy(s = snext, s0);\n\tsnext += L;\n\treturn s;\n\t}\n\nstatic void **DHHlast, **DHHnext;\t/* Could be private to DHHlookup, but here */\n\t\t\t\t\t/* to make them visible to debuggers. */\n static DefhashHead *\nDHHlookup(const char *s0, DefhashTab *Htab, int add)\n{\n\tDefhashHead *h, **hp;\n\tconst char *s;\n\tsize_t L;\n\tunsigned int c, x;\n\n\tfor(x = 0, s = s0; (c = *(unsigned char*)s); ++s)\n\t\tx += DHTfactor*x + c;\n\tx %= DHTlen;\n\tfor(hp = &Htab->Tab[x]; (h = *hp); hp = &h->hnext) {\n\t\tif (!strcmp(s0, h->name))\n\t\t\treturn h;\n\t\t}\n\tif (!add)\n\t\treturn h;\n\tHtab->nent++;\n\tif (DHHnext + Htab->nalloc >= DHHlast) {\n\t\tDHHnext = (void**)Malloc(L = DMblk_gulp*sizeof(void*), \"DHHlookup\");\n\t\tDHHlast = DHHnext + DMblk_gulp;\n\t\tmemset(DHHnext, 0, L);\n\t\t}\n\t*hp = h = (DefhashHead*)DHHnext;\n\tDHHnext += Htab->nalloc;\n\th->name = def_name(s0);\n\th->thread = Htab->lastdh;\n\treturn Htab->lastdh = h;\n\t}\n\n static void\nbothplaces(KWctx *kw, const char *name)\n{ squawk(\"For %s, %s appears both in specfile and tagfile\", kw->names->val, name); }\n\n static void\ntagimport(KWctx *kw, KWctx *tw)\n{\n\ttypedef struct KWimport KWimport;\n\tstruct KWimport { const char *name; size_t off; };\n\tstatic KWimport Imp[] = {\n\t\t{ \"lower bound\",\toffsetof(KWctx,lb) },\n\t\t{ \"upper bound\",\toffsetof(KWctx,ub) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,init) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,cinit) },\n\t\t{ \"defname\",\t\toffsetof(KWctx,defname) },\n\t\t{ \"DESC\",\t\toffsetof(KWctx,desc) },\n\t\t{ \"GROUP\",\t\toffsetof(KWctx,group) },\n\t\t{ \"LEN\",\t\toffsetof(KWctx,len) },\n\t\t{0}};\n\tKWimport *ki;\n#define field(k,n) *(char**)((char*)k+n)\n\tfor(ki = Imp; ki->name; ++ki) {\n\t\tif (field(tw,ki->off)) {\n\t\t\tif (field(kw,ki->off))\n\t\t\t\tbothplaces(kw, ki->name);\n\t\t\telse\n\t\t\t\tfield(kw,ki->off) = field(tw,ki->off);\n\t\t\t}\n\t\t}\n#undef field\n\t}\n\n#ifndef NO_NIDR_DYNLIB\n\nstatic const char *typename[8] = {\n\t\"no value\", \"INTEGER\", \"REAL\", \"STRING\",\n\t\"(Bug! no value LIST)\", \"INTEGERLIST\", \"REALLIST\", \"STRINGLIST\" };\n\n static int\nkwseqnocomp(const void *a, const void *b)\n{\n\tconst KeyWordx *ka, *kb;\n\n\tka = *(KeyWordx**)a;\n\tkb = *(KeyWordx**)b;\n\treturn (int)ka->seqno - (int)kb->seqno;\n\t}\n\n static void\nLsqbpar(void)\n{\n\tLsqb();\n\tLpar();\n\t}\n\n static void\nRparsqb(void)\n{\n\tRpar();\n\tRsqb();\n\t}\n\n static void\nNobrak(void) {}\n\n typedef struct\nKW_Cstak { KeyWordx **Cstak; Uint n, nmax; } KW_Cstak;\n\n static void kw_finish(int);\n static void kw_insert(KeyWord*, KW_Cstak*, int);\n\n static KeyWord*\nkw_stakadj(KeyWord *kw, KW_Cstak *Stk, int needbar, int n0, KeyWord *okw3)\n{\n\tKeyWordx *kw1, *kw2, **x;\n\tUint i, j, k, nst, nz;\n\n\tkw1 = (KeyWordx*)kw;\n\tnz = 0;\n\twhile(!kw1[++nz].kw.name);\n\tif (nz == 1 && *kw1[nz].kw.name)\n\t\tokw3 = 0;\n\tnst = Stk->n;\n\tx = Stk->Cstak;\n\tkw2 = (KeyWordx*)kw1->kw.kw;\n\tfor(i = 0; i < nst; ++i) {\n\t\tif (x[i]->kw.kw == &kw2->kw) {\n\t\t\tj = i;\n\t\t\t++kw1;\n\t\t\t/* No need to test kw1->kw.name in the following loop */\n\t\t\t/* as the == test will fail if kw1->kw.name is nonzero. */\n\t\t\twhile(++j < nst && x[j]->kw.kw == kw1->kw.kw)\n\t\t\t\t++kw1;\n\t\t\tk = nz - (j-i);\n\t\t\tgoto have_jk;\n\t\t\t}\n\t\t}\n\tk = nz;\n\tj = n0;\n have_jk:\n\twhile(nst > j) {\n\t\tkw_insert(&x[--nst]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (needbar)\n\t\tBar();\n\tif (k) {\n\t\tif (nst + k > Stk->nmax)\n\t\t\tx = Stk->Cstak = (KeyWordx**)Realloc(x,\n\t\t\t\t(Stk->nmax = 2)*sizeof(KeyWordx*), \"kw_stakadj\");\n\t\tdo {\n\t\t\tif (kw1->kw.kw != okw3)\n\t\t\t\tLpar();\n\t\t\tx[j++] = kw1++;\n\t\t\t}\n\t\t\twhile(--k);\n\t\tnst = j;\n\t\t}\n\tStk->n = nst;\n\tif (!*kw1->kw.name)\n\t\treturn 0;\n\treturn &kw1->kw;\n\t}\n\n static int\nsame_funcs(KeyWordx *kw1, KeyWordx *kw2)\n{\n\tKeyWordx *kw3, *kw4;\n\n\tif (!kw1->kw.nkw || !kw2->kw.nkw)\n\t\treturn 0;\n\tkw3 = (KeyWordx*)kw1->kw.kw;\n\tkw4 = (KeyWordx*)kw2->kw.kw;\n\tif (kw3 == kw4)\n\t\treturn 1;\n\tif (kw4->kw.name)\n\t\treturn 0;\n\tkw4 = (KeyWordx*)kw4->kw.kw;\n\treturn kw3 == kw4;\n\t}\n\n static char *\nStrCpy(const char *s)\n{\n\tchar *t;\n\tsize_t L;\n\n\tif (!s)\n\t\treturn 0;\n\tL = strlen(s);\n\tt = (char*)Alloc(L+1);\n\tstrcpy(t,s);\n\treturn t;\n\t}\n\n static int Saw_name(const char*);\n static void Saw_stok(int, size_t);\n\n static void\nkw_insert(KeyWord *kw, KW_Cstak *Stk, int top)\n{\n\tenum { NKW0 = 32 };\n\tKeyWord *kw3, *kw30, *okw3;\n\tKeyWordx *kw0, *kw1, *kw2, *kw4, **x, *x0[NKW0];\n\tUint i, j, k, knd, nkw, nst0, nst1;\n\tchar buf[32];\n\tint alt2, incc, needbar, needbar1, samef0, samef1;\n\ttypedef void (*Brak)(void);\n\tBrak Lbrak, Rbrak;\n\n\tkw1 = (KeyWordx*)kw->kw;\n\twhile(!kw1->kw.name)\n\t\t++kw1;\n\tnkw = kw->nkw;\n\tx = x0;\n\tif (nkw > NKW0)\n\t\tx = (KeyWordx**)Malloc(nkw * sizeof(KeyWordx*), \"kw_insert\");\n\tfor(i = 0; i < nkw; ++i)\n\t\tx[i] = kw1++;\n\tif (nkw > 1)\n\t\tqsort(x, nkw, sizeof(KeyWordx*), kwseqnocomp);\n\tkw0 = 0;\n\tkw30 = 0;\n\tnst0 = Stk->n;\n\tfor(i = j = samef0 = 0; i < nkw; i = j) {\n\t\tkw1 = x[i];\n\t\tkw2 = 0;\n\t\twhile(++j < nkw) {\n\t\t\tkw2 = x[j];\n\t\t\tif (!kw2->kw.paoff)\n\t\t\t\tbreak;\n\t\t\tkw2 = 0;\n\t\t\t}\n\t\tLbrak = Rbrak = 0;\n\t\tokw3 = kw30;\n\t\tif (top) {\n\t\t\tkw_finish(kw1->kw.kind & KWKind_12);\n\t\t\tkw3 = kw1->kw.kw;\n\t\t\tRbrak = Nobrak;\n\t\t\tgoto nobrak;\n\t\t\t}\n\t\tneedbar = needbar1 = kw0 && kw0->kw.alt == kw1->kw.alt;\n\t\tnst1 = Stk->n;\n\t\talt2 = incc = 0;\n\t\tkw4 = 0;\n\t\tif (kw2) {\n\t\t\talt2 = kw1->kw.alt == kw2->kw.alt;\n\t\t\tkw4 = (KeyWordx*)kw2->kw.kw;\n\t\t\t}\n\t\tif ((kw3 = kw30 = kw1->kw.kw)) {\n\t\t\tif (!kw3->name) {\n\t\t\t\tkw3 = kw_stakadj(kw3, Stk, needbar, nst0, okw3);\n\t\t\t\tneedbar1 = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\twhile(Stk->n > nst0) {\n\t\t\t\t\tif (Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n\t\t\t\t\t\tif (kw4 && kw4->kw.kw == kw3)\n\t\t\t\t\t\t\tincc = 1; /* in contained context */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\t\tRpar();\n\t\t\t\t\t}\n\t\t\t}\n\t\telse while(Stk->n > nst0) {\n\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\tRpar();\n\t\t\t}\n\t\tsamef0 = needbar && same_funcs(kw1,kw0);\n\t\tsamef1 = alt2    && same_funcs(kw1,kw2);\n\t\tif (kw3) {\n\t\t\tif (samef1) {\n\t\t\t\tif (!needbar)\n\t\t\t\t\tLbrak = kw1->kw.req ? Lpar : Lsqbpar;\n\t\t\t\telse if (!samef0 && kw3->name)\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\tkw3 = 0;\n\t\t\t\tgoto barchk;\n\t\t\t\t}\n\t\t\telse if (needbar) {\n\t\t\t\tif (!incc)\n\t\t\t\t\tRbrak = alt2 || kw1->kw.req ? Rpar : Rparsqb;\n\t\t\t\tif (!samef0\n\t\t\t\t && (Stk->n <= nst1\n\t\t\t\t    || !kw0 || kw0->kw.kw != Stk->Cstak[Stk->n-1]->kw.kw))\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\t}\n\t\t\telse if (kw1->kw.req) {\n\t\t\t\tLbrak = Lpar;\n\t\t\t\tRbrak = Rpar;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tLbrak = Lsqb;\n\t\t\t\tRbrak = Rsqb;\n\t\t\t\tif (alt2) {\n\t\t\t\t\tLbrak = Lsqbpar;\n\t\t\t\t\tRbrak = Rpar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw2) {\n\t\t\t\tif (kw4 && !kw4->kw.name && kw4->kw.kw == kw3)\n\t\t\t\t\tgoto zap_kw3;\n\t\t\t\tif (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3)\n\t\t\t\t\t--Stk->n;\n\t\t\t\t}\n\t\t\telse if (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n zap_kw3:\n\t\t\t\tRbrak = 0;\n\t\t\t\tkw3 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!kw1->kw.req) {\n\t\t\tif (!needbar)\n\t\t\t\tLbrak = Lsqb;\n\t\t\tif (!alt2)\n\t\t\t\tRbrak = Rsqb;\n\t\t\t}\n barchk:\n\t\tif (needbar1)\n\t\t\tBar();\n\t\tif (Lbrak)\n\t\t\tLbrak();\n nobrak:\n\t\tKeywd(kw1->kw.name);\n\t\twhile(++i < j) {\n\t\t\tkw2 = x[i];\n\t\t\tAlias(kw2->kw.name - 6);\t/* Alias will increment by 6 */\n\t\t\t}\n\t\tknd = kw1->kw.kind;\n\t\tif ((k = knd & (KWKind_Mask|KWKind_List)))\n\t\t\tType(k, typename[k]);\n\t\tif ((k = knd & KWKind_Lb)) {\n\t\t\tSaw_tok(knd & KWKind_strictLb ? Saw_gt : Saw_ge, KWKind_Lb);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Lb);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif ((k = knd & KWKind_Ub)) {\n\t\t\tSaw_tok(knd & KWKind_strictUb ? Saw_lt : Saw_le, KWKind_Ub);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Ub);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif (kw1->init || kw1->cinit) {\n\t\t\tSaw_tok(Saw_dflt, KWKind_init);\n\t\t\tlastdef = 0;\n\t\t\tif (kw1->defname)\n\t\t\t\tSaw_name(kw1->defname);\n\t\t\tif (kw1->init)\n\t\t\t\tSaw_num(kw1->init);\n\t\t\telse\n\t\t\t\tlastkw1->cinit = StrCpy(kw1->cinit);\n\t\t\t}\n\t\tif (kw1->funcs)\n\t\t\tlastkw1->funcs = new_StrList(kw1->funcs, 0);\n\t\telse if (kw1->kw.f.vf && !kw1->kw.f.final) {\n\t\t\tlastkw1->dylib = StrCpy((const char*)kw1->kw.f.vf);\n\t\t\tdynlibseen = 1;\n\t\t\t}\n\t\telse\n\t\t\tlastkw1->funcs = new_StrList(\"0\", 0);\n\t\tlastkw1->desc  = StrCpy(kw1->desc);\n\t\tlastkw1->group = StrCpy(kw1->group);\n\t\tif (kw1->alen) {\n\t\t\tSaw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\tlastkw1->kind |= knd & KWKind_Len1OK;\n\t\t\tSaw_name(kw1->alen);\n\t\t\t}\n\t\tif (Rbrak) {\n\t\t\tif (kw3)\n\t\t\t\tkw_insert((KeyWord*)kw1, Stk, 0);\n\t\t\tRbrak();\n\t\t\t}\n\t\tkw0 = kw1;\n\t\tif (top) {\n\t\t\twhile(Stk->n > 0) {\n\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\tRpar();\n\t\t\t\t}\n\t\t\tif (!kw2)\n\t\t\t\tkw_finish(-1);\n\t\t\t}\n\t\t}\n\twhile(Stk->n > nst0) {\n\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nkw_insert1(KeyWord *kw, int top)\n{\n\tKW_Cstak Stk;\n\n\tStk.n = 0;\n\tStk.Cstak = (KeyWordx**)Malloc((Stk.nmax = 64)*sizeof(KeyWordx*), \"kw_insert1\");\n\tif (top) {\n\t\tKWtop = KWStack;\n\t\tKWbase.kw = 0;\n\t\t}\n\tkw_insert(kw, &Stk, top);\n\twhile(Stk.n > 0) {\n\t\tkw_insert(&Stk.Cstak[--Stk.n]->kw, &Stk, 0);\n\t\tRpar();\n\t\t}\n\tfree(Stk.Cstak);\n\t}\n\n static int\nlibread1(const char *kname, const char *lname, Uint n, int allow_top)\n{\n\tKW_ADD kwa;\n\tKeyWord *kw, kw0;\n\tUint i;\n\tconst char *s;\n\tvoid *h, (*Botch)(const char*, ...);\n\n\th = dlopen(lname, RTLD_NOW);\n\tif (!h) {\n\t\tBotch = botch;\n\t\tif (kname && libexpand)\n\t\t\tBotch = squawk;\n#ifndef _WIN32\n\t\tif ((s = dlerror()))\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\t\tlname, kname, s);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\",\n\t\t\t\t\tlname, s);\n\t\telse\n#endif\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\t\tlname, kname);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\"\", lname);\n\t\treturn ++liberror;\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw = (*kwa)();\n\tif (!(s = kw->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tif (allow_top) {\n\t\tif (strcmp(s, \"KeywordTop\")) {\n\t\t\tif (allow_top == 2) {\n\t\t\t\tmemset(&kw0, 0, sizeof(KeyWord));\n\t\t\t\tkw0.kw = kw;\n\t\t\t\tkw = &kw0;\n\t\t\t\tkw0.nkw = 1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tallow_top = 0;\n\t\t\t}\n\t\telse\n\t\t\tkname = 0;\n\t\t}\n\telse if (kname && strcmp(s, kname)) {\n namebotch:\n\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\tlname, kname, s);\n\t\t}\n\tif (kname) {\n\t\ti = kw->kind & (KWKind_Mask|KWKind_List);\n\t\tif (i != n)\n\t\t\tbotch(\"Library %s: expected %s to be %s, but got %s\",\n\t\t\t\tlname, kname, typename[n], typename[i]);\n\t\t}\n\tif (kw->kw)\n\t\tkw_insert1(kw, allow_top);\n\tdlclose(h);\n\treturn 0;\n\t}\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tconst char *kname, *lname;\n\n\tkname = kc->name1;\n\tlname = kc->dylib;\n\tkc->dylib = 0;\n\treturn libread1(kname, lname, kc->kind & (KWKind_Mask|KWKind_List), allow_top);\n\t}\n#else\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", kc->dylib);\n\treturn 1;\n\t}\n#endif\n\n static void\nKeywd(const char *s)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2, *kwm, **kwp;\n\tStrList *nam;\n\tTaghash *th;\n\tchar *s1;\n\tint alt, lsave, req;\n\tsize_t L, L1;\n\tstatic char allowed[] = { '(',')','[',']','|', Saw_kwname, Saw_type, 0 };\n\n\tif (tagin)\n\t\tbotch(\"Inappropriate text \\\"%s\\\" in tagfile \\\"%s\\\"\", s, tagfname);\n\tkw1 = *KWtop;\n#ifndef NO_NIDR_DYNLIB\n\tif (kw1->dylib && libexpand && !lib_read(kw1,0))\n\t\tkw1 = *KWtop;\n#endif\n\tkw0 = kw1;\n\tkwm = 0;\n\tif (!kw1->names && s) {\n\t\tswitch(kw1->parstate) {\n\t\t  case PPar_emtpy:\n\t\t\tdo {\n\t\t\t\tkw1->parstate = PPar_starting;\n\t\t\t\tkw1 = kw1->pparent;\n\t\t\t\t}\n\t\t\t\twhile(kw1 && kw1->parstate == PPar_emtpy);\n\t\t\tkw1 = kw0->rparent;\n\t\t\tbreak;\n\t\t  case PPar_starting:\n\t\t\tif (or_mode)\n\t\t\t\tkw1 = kw0->rparent;\n\t\t\telse\n\t\t\t\tkw1->parstate = PPar_started;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\tif (or_mode && !kw1->kw) {\n\t\tkw2 = KWtop[-1];\n\t\tif (!kw2->names && kw2->parstate == PPar_starting)\n\t\t\tkw2 = kw2->rparent;\n\t\tif (s)\n\t\t\tkw1->master = kwm = kw1;\n\t\tkw1 = kw2;\n\t\t}\n\tL = alt = req = 0;\n\tif (s) {\n\t\tkwp = KWStack + kw1->level + 1;\n\t\tif (kwp > KWtop)\n\t\t\tkwp = KWtop;\n\t\twhile(kwp > KWStack) {\n\t\t\tkw2 = *kwp--;\n\t\t\tif (kw2->name1) {\n\t\t\t\tdtnext = deftag + kw2->dtnext;\n\t\t\t\tL = kw2->name1len;\n\t\t\t\tstrcpy(dtnext-L, kw2->name1);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\talt = ++kw1->nalt;\n\t\tif (*Br_top != '['/*]*/ || Br_top == kw1->Br_top) {\n\t\t\treq = ++kw1->nreq;\n\t\t\tif (*Br_top == '(' /*)*/) /* allow [(...)|...] */\n\t\t\t\tfor(s1 = Br_top; --s1 > kw1->Br_top; ) {\n\t\t\t\t\tif (*s1 != '(' /*)*/) {\n\t\t\t\t\t\tif (*s1 == '[' /*]*/) {\n\t\t\t\t\t\t\t--kw1->nreq;\n\t\t\t\t\t\t\treq = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\tif (or_mode) {\n\t\t\talt = --kw1->nalt;\n\t\t\tif (req)\n\t\t\t\treq = --kw1->nreq;\n\t\t\t}\n\t\tif (lastseen)\n\t\t\treqchk(allowed, s);\n\t\tor_mode = 0;\n\t\t}\n\tlastkw = lastkw1 = kw = (KWctx*) Alloc(sizeof(KWctx));\n\tif (!kw0->names)\n\t\tkw->pparent = kw0;\n\tif (s) {\n\t\tkw->names = nam = new_StrList(s,0);\n\t\tkw->name1 = nam->val;\n\t\tkw->name1len = L = strlen(s);\n\t\tfor(kwp = KWtop; kwp > KWStack; --kwp) {\n\t\t\tkw2 = *kwp;\n\t\t\tif (kw2->names) {\n\t\t\t\tif (kwp < KWtop) {\n\t\t\t\t\tL1 = kw2->dtnext + L + 1;\n\t\t\t\t\twhile(++kwp <= KWtop) {\n\t\t\t\t\t\tkw2 = *kwp;\n\t\t\t\t\t\tif (!kw2->name1) {\n\t\t\t\t\t\t\tkw2->name1 = kw->name1;\n\t\t\t\t\t\t\tkw2->name1len = L;\n\t\t\t\t\t\t\tkw2->dtnext = L1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kw1->dylib) {\n\t\t\tlsave = Lineno;\n\t\t\tLineno = dynline; /* Line where DYNLIB appeared */\n\t\t\tsquawk(\"Suppressing DYNLIB for %s to parse contained keywords\",\n\t\t\t\tkw1->names ? kw1->names->val : \"???? (bug!)\");\n\t\t\tLineno = lsave;\n\t\t\tkw1->dylib = 0;\n\t\t\t}\n\t\tnam->primary = KWKind_primary;\n\t\tnam->seqno = ++seqno;\n\t\tkw->next = kw1->kw;\n\t\tkw1->kw = kw;\n\t\tif (lastseen == '(' /*)*/)\n\t\t\tkw->parstate = PPar_leftpar;\n\t\tkw->agroup = lastagroup++;\n\t\t}\n\telse {\n\t\tkw->objno = ++lastobjno;\n\t\tif (!kw1->kw && (kw->rparent = kw1->rparent))\n\t\t\tkw1 = kw->rparent;\n\t\telse\n\t\t\tkw->rparent = kw1;\n\t\talt = kw1->alt;\n\t\treq = kw1->req;\n\t\t}\n\tkw->alt = alt;\n\tkw->req = req;\n\tkw->Br_top = Br_top;\n\tkw->master = kwm;\n\tkw->level = KWtop - KWStack;\n\tif (lastseen == '(' || lastseen == '[' /*])*/ || KWtop == KWStack) {\n\t\tif (++KWtop - KWStack >= KW_stacklen)\n\t\t\tbotch(\"KW stack overflow\");\n\t\t*KWtop = kw;\n\t\t}\n\tlasttag = 0;\n\tif (s) {\n\t\tif (dtnext > deftag)\n\t\t\t*dtnext++ = '/';\n\t\tif (dtnext + L >= dtend)\n\t\t\tbotch(\"deftag overflow\");\n\t\tmemcpy(dtnext, s, L);\n\t\t*(dtnext += L) = 0;\n\t\tif (tagout)\n\t\t\tfprintf(tagout, \"TAG \\\"%s\\\"\\n\", deftag);\n\t\tif (tagfname) {\n\t\t\tif ((th = (Taghash*)DHHlookup(deftag, &TagTab, ignoretags))) {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (mtagout)\n\t\t\t\tfprintf(mtagout, \"TAG \\\"%s\\\" #missing\\n\", deftag);\n\t\t\t}\n\t\t}\n\tkw->dtnext = dtnext - deftag;\n\tif (lastseen == 0)\n\t\tkw->kind = kwmult;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nkw_finish(int nextkind)\n{\n\tKWctx *kw;\n\n\tif (*Br_top)\n\t\tbotch(\"unmatched '%c'\", *Br_top);\n\tif (KWtop - KWStack > 1)\n\t\tbotch(\"bug: KW stack botch in kw_finish\");\n\tif (KWtop > KWStack) {\n\t\tkw = *KWtop;\n\t\tif (kw->dylib && libexpand)\n\t\t\tlib_read(kw, nextkind == -1);\n\t\t}\n\tKWtop = KWStack;\n\tdtnext = deftag;\n\tlastseen = 0;\n\tkwmult = nextkind < 0 ? 0 : nextkind;\n\t}\n\n static void\nfuncbotch(KWctx *kw)\n{\n\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions cannot be used with DYNLIB\"\n\t\t\".\\n\\t\\tThey must be supplied by the dynamically loaded library\",\n\t\tkw->names->val);\n\t}\n\n static void\nFnc(char *s)\n{\n\tKWctx *kw;\n\n\tif (!(kw = lastkw1))\n\t\tbotch(\"misplaced {...}\");\n\tif (++kw->nfcn > 4)\n\t\tbotch(\"too many functions in {...}\");\n\telse if (kw->dylib)\n\t\tfuncbotch(kw);\n\telse if (kw->kind & KWKind_Libname)\n\t\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions \"\n\t\t\t\"cannot be used with LIBNAME.\",\n\t\t\tkw->names->val);\n\tkw->funcs = wantfuncs ? new_StrList(s, kw->funcs) : 0;\n\tlastseen = Saw_func;\n\t}\n\n static const char*\ntname_adj(const char *tname, int what, int kbits)\n{\n\tUint k = lastkw1->kind;\n\n\tswitch(what) {\n\t case Saw_lt:\n\t\tif (k & KWKind_caneqUb)\n\t\t\ttname = \"<=\";\n\t\tbreak;\n\t case Saw_le:\n\t\tif (k & KWKind_strictUb)\n\t\t\ttname = \"<\";\n\t\tbreak;\n\t case Saw_ge:\n\t\tif (k & KWKind_strictLb)\n\t\t\ttname = \">\";\n\t\tbreak;\n\t case Saw_gt:\n\t\tif (k & KWKind_caneqLb)\n\t\t\ttname = \">=\";\n\t }\n\treturn tname;\n\t}\n\n static void\nSaw_tok(int what, int kbits)\n{\n\tconst char *tname;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (lastkw1->kind & kbits) {\n\t\t\ttname = tokname[what];\n\t\t\tif (kbits & (KWKind_Lb | KWKind_Ub))\n\t\t\t\ttname = tname_adj(tname, what, kbits);\n\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\ttname, lastkw1->names->val);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static void\nSaw_stok(int what, size_t woff)\n{\n\tStrList *sl;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (*(void**)((char*)lastkw1 + woff)) {\n\t\t\tif ((sl = lastkw1->names))\n\t\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\t\ttokname[what], sl->val);\n\t\t\telse\n\t\t\t\tbotch(\"%s already seen\", tokname[what]);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static KWctx *\nlenfind(const char *s)\n{\n\tKWctx *kw, *kw0, **pkw;\n\tStrList *sl;\n\n\tkw0 = lastkw1;\n\tfor(pkw = KWtop; pkw > KWStack; --pkw) {\n\t\tkw = *pkw;\n\t\tfor(kw = kw->kw; kw; kw = kw->next) {\n\t\t\tfor(sl = kw->names; sl; sl = sl->next)\n\t\t\t\tif (!strcmp(sl->val, s))\n\t\t\t\t\treturn kw;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n\n static void\nalreadyseen(const char *what)\n{\n\tsquawk(\"%s already given for %s\", what, lastkw1->names->val);\n\t}\n\n static int\nSaw_name(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\tTaghash *th;\n\tconst char *s1;\n\tstatic const char notfound[] =\n\t\t\"keyword \\\"%s\\\" not found in this or an enclosing context\";\n\n\tif (lastkw1) {\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t\tlastseen = Saw_dfltname;\n\t\t\tlastdef = (Defhash*)DHHlookup(s, &DHTab, 1);\n\t\t\tif (!lastkw1->defname)\n\t\t\t\tlastkw1->defname = def_name(s);\n\t\t\telse if (lastdef->value\n\t\t\t\t && ((s1 = lastkw1->init) || (s1 = lastkw1->cinit))\n\t\t\t\t && strcmp(s1, lastdef->value))\n\t\t\t\t\tsquawk(\"Inconsistent definitions for %s: %s and %s\\n\",\n\t\t\t\t\t\tlastdef->hh.name, lastdef->value, s1);\n\t\t\treturn 0;\n\t\t  case Saw_len:\n\t\t\tif (lastkw1->len) {\n\t\t\t\talreadyseen(\"LEN\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tkw = lenfind(s);\n\t\t\tif (!kw)\n\t\t\t\tsquawk(notfound,s);\n\t\t\telse {\n\t\t\t\tif ((kw->kind & KWKind_Mask) != KWKind_Int)\n\t\t\t\t\tsquawk(\"%s is not of type INTEGER\", kw->names->val);\n\t\t\t\tfor(sl = kw->names; sl->next; sl = sl->next);\n\t\t\t\tlastkw1->len = sl->val;\n\t\t\t\t}\n\t\t\tgoto ret1;\n\t\t  case Saw_group:\n\t\t\tif (lastkw1->group)\n\t\t\t\talreadyseen(\"GROUP\");\n\t\t\telse\n\t\t\t\tstrcpy(lastkw1->group = (char*)Alloc(strlen(s)+1), s);\n\t\t\tgoto ret1;\n\t\t  case Saw_tag:\n\t\t\tif (tagin)\n\t\t\t\tgoto new_tag;\n\t\t\tif (lasttag) {\n\t\t\t\talreadyseen(\"TAG\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tif (!tagfname && !ignoretags) {\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found: no tag file given\", s);\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tth = (Taghash*)DHHlookup(s, &TagTab, ignoretags);\n\t\t\tif (!th)\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found in tag file \\\"%s\\\"\", s, tagfname);\n\t\t\telse {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n ret1:\n\t\t\tlastseen = Saw_type;\n\t\t\treturn 1;\n\t\t  }\n\t\t}\n\telse if (tagin) {\n new_tag:\n\t\tth = (Taghash*)DHHlookup(s, &TagTab, 1);\n\t\tif (th->kw)\n\t\t\tsquawk(\"Tag \\\"%s\\\" already seen in tagfile %s\\n\", s, tagfname);\n\t\telse\n\t\t\tth->kw = lastkw1 = (KWctx*) Alloc(sizeof(KWctx));\n\t\tgoto ret1;\n\t\t}\n\tbotch(\"unexpected name \\\"%s\\\"\", s);\n\treturn 0; /* not reached */\n\t}\n\n static void\nboundalready(const char *what)\n{\n\tsquawk(\"%s bound already given for %s\", what, lastkw1->names->val);\n\t}\n\n static void\nset_lastdef(const char *s, int qkeep)\n{\n\tif (!lastdef->value) {\n\t\tlastdef->value = def_name(s);\n\t\tlastdef->qkeep = qkeep;\n\t\t}\n\telse if (strcmp(s, lastdef->value))\n\t\tsquawk(\"Two := values for %s: %s and %s\", lastdef->hh.name,\n\t\t\tlastdef->value, s);\n\t}\n\n static void\nSaw_num(const char *s)\n{\n\tDefhash *ld;\n\tdouble x, xa;\n\tchar *se, **sp;\n\tint k;\n\tstatic double b[3];\n\n\tstatic char allowed[] = { Saw_dflt, Saw_dfltname, Saw_lt, Saw_le, Saw_ge, Saw_gt, 0 };\n\n\treqchk(allowed, \"number\");\n\tx = strtod(s,&se);\n\tif (*se)\n\t\tbotch(\"invalid number: \\\"%s\\\"\", s);\n\tld = 0;\n\tsp = 0;\n\tswitch(lastseen) {\n\t\tcase Saw_dflt:\n\t\tcase Saw_dfltname:\n\t\t\tsp = &lastkw1->init;\n\t\t\tlastkw1->kind |= KWKind_init;\n\t\t\tld = lastdef;\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int)\n\t\t\t\tx = x >= 0. ? floor(x) : ceil(x);\n\t\t\tb[2] = x;\n\t\t\tif (lastkw1->lb && x < b[0])\n\t\t\t\tsquawk(\"default value inconsistent with lower bound\");\n\t\t\tif (lastkw1->ub && x > b[1])\n\t\t\t\tsquawk(\"default value inconsistent with upper bound\");\n\t\t\tbreak;\n\t\tcase Saw_gt:\n\t\tcase Saw_ge:\n\t\t\tif (lastkw1->lb) {\n\t\t\t\tboundalready(\"lower\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = ceil(x);\n\t\t\t\tif (xa > x) {\n\t\t\t\t\tif (btype == KWKind_strictLb)\n\t\t\t\t\t\tbtype = KWKind_caneqLb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->lb;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[0] = x;\n\t\t\tif (lastkw1->ub && x >= b[1])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x > b[2])\n\t\t\t\tsquawk(\"lower bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tcase Saw_le:\n\t\tcase Saw_lt:\n\t\t\tif (lastkw1->ub) {\n\t\t\t\tboundalready(\"upper\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = floor(x);\n\t\t\t\tif (xa < x) {\n\t\t\t\t\tif (btype == KWKind_strictUb)\n\t\t\t\t\t\tbtype = KWKind_caneqUb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->ub;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[1] = x;\n\t\t\tif (lastkw1->lb && x <= b[0])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x < b[2])\n\t\t\t\tsquawk(\"upper bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunexpected(s);\n\t\t}\n\tk = lastkw1->kind & KWKind_Mask;\n\tif ((k == KWKind_Void && !tagin) || k == KWKind_Str)\n\t\tsquawk(\"cannot accept a %s value\", tokname[lastseen]);\n\telse {\n\t\tstrcpy(*sp = (char*)Alloc(strlen(s)+1), s);\n\t\tif (ld)\n\t\t\tset_lastdef(s, 0);\n\t\t}\n ret:\n\tlastseen = Saw_type;\n\t}\n\n#define FNC 1\n#define VAL 2\n\n/* #line 2011 \"nidrgen.c\" */\n\n/* Macros after this point can all be overridden by user definitions in\n * section 1.\n */\n\n#ifndef YY_SKIP_YYWRAP\n#ifdef __cplusplus\nextern \"C\" int yywrap YY_PROTO(( void ));\n#else\nextern int yywrap YY_PROTO(( void ));\n#endif\n#endif\n\n#ifndef YY_NO_UNPUT\nstatic void yyunput YY_PROTO(( int c, char *buf_ptr ));\n#endif\n\n#ifndef yytext_ptr\nstatic void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));\n#endif\n\n#ifdef YY_NEED_STRLEN\nstatic int yy_flex_strlen YY_PROTO(( yyconst char * ));\n#endif\n\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\nstatic int yyinput YY_PROTO(( void ));\n#else\nstatic int input YY_PROTO(( void ));\n#endif\n#endif\n\n#if YY_STACK_USED\nstatic int yy_start_stack_ptr = 0;\nstatic int yy_start_stack_depth = 0;\nstatic int *yy_start_stack = 0;\n#ifndef YY_NO_PUSH_STATE\nstatic void yy_push_state YY_PROTO(( int new_state ));\n#endif\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state YY_PROTO(( void ));\n#endif\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state YY_PROTO(( void ));\n#endif\n\n#else\n#define YY_NO_PUSH_STATE 1\n#define YY_NO_POP_STATE 1\n#define YY_NO_TOP_STATE 1\n#endif\n\n#ifdef YY_MALLOC_DECL\nYY_MALLOC_DECL\n#else\n#if __STDC__\n#ifndef __cplusplus\n#include <stdlib.h>\n#endif\n#else\n/* Just try to get by without declaring the routines.  This will fail\n * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)\n * or sizeof(void*) != sizeof(int).\n */\n#endif\n#endif\n\n/* Amount of stuff to slurp up with each read. */\n#ifndef YY_READ_BUF_SIZE\n#define YY_READ_BUF_SIZE 8192\n#endif\n\n/* Copy whatever the last rule matched to the standard output. */\n\n#ifndef ECHO\n/* This used to be an fputs(), but since the string might contain NUL's,\n * we now use fwrite().\n */\n#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )\n#endif\n\n/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n * is returned in \"result\".\n */\n#ifndef YY_INPUT\n#define YY_INPUT(buf,result,max_size) \\\n\tif ( yy_current_buffer->yy_is_interactive ) \\\n\t\t{ \\\n\t\tint c = '*', n; \\\n\t\tfor ( n = 0; n < max_size && \\\n\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n\t\t\tbuf[n] = (char) c; \\\n\t\tif ( c == '\\n' ) \\\n\t\t\tbuf[n++] = (char) c; \\\n\t\tif ( c == EOF && ferror( yyin ) ) \\\n\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\\n\t\tresult = n; \\\n\t\t} \\\n\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\\n\t\t  && ferror( yyin ) ) \\\n\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );\n#endif\n\n/* No semi-colon after return; correct usage is to write \"yyterminate();\" -\n * we don't want an extra ';' after the \"return\" because that will cause\n * some compilers to complain about unreachable statements.\n */\n#ifndef yyterminate\n#define yyterminate() return YY_NULL\n#endif\n\n/* Number of entries by which start-condition stack grows. */\n#ifndef YY_START_STACK_INCR\n#define YY_START_STACK_INCR 25\n#endif\n\n/* Report a fatal error. */\n#ifndef YY_FATAL_ERROR\n#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )\n#endif\n\n/* Default declaration of generated scanner - a define so the user can\n * easily add parameters.\n */\n#ifndef YY_DECL\n#define YY_DECL int yylex YY_PROTO(( void ))\n#endif\n\n/* Code executed at the beginning of each rule, after yytext and yyleng\n * have been set up.\n */\n#ifndef YY_USER_ACTION\n#define YY_USER_ACTION\n#endif\n\n/* Code executed at the end of each rule. */\n#ifndef YY_BREAK\n#define YY_BREAK break;\n#endif\n\n#define YY_RULE_SETUP \\\n\tYY_USER_ACTION\n\nYY_DECL\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp = NULL, *yy_bp = NULL;\n\tregister int yy_act;\n\n/* #line 1528 \"nidrgen.l\" */\n\n\n/* #line 2165 \"nidrgen.c\" */\n\n\tif ( yy_init )\n\t\t{\n\t\tyy_init = 0;\n\n#ifdef YY_USER_INIT\n\t\tYY_USER_INIT;\n#endif\n\n\t\tif ( ! yy_start )\n\t\t\tyy_start = 1;\t/* first start state */\n\n\t\tif ( ! yyin )\n\t\t\tyyin = stdin;\n\n\t\tif ( ! yyout )\n\t\t\tyyout = stdout;\n\n\t\tif ( ! yy_current_buffer )\n\t\t\tyy_current_buffer =\n\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE );\n\n\t\tyy_load_buffer_state();\n\t\t}\n\n\twhile ( 1 )\t\t/* loops until end-of-file is reached */\n\t\t{\n\t\tyy_cp = yy_c_buf_p;\n\n\t\t/* Support of yytext. */\n\t\t*yy_cp = yy_hold_char;\n\n\t\t/* yy_bp points to the position in yy_ch_buf of the start of\n\t\t * the current run.\n\t\t */\n\t\tyy_bp = yy_cp;\n\n\t\tyy_current_state = yy_start;\nyy_match:\n\t\tdo\n\t\t\t{\n\t\t\tregister YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n\t\t\tif ( yy_accept[yy_current_state] )\n\t\t\t\t{\n\t\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t\t}\n\t\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t\t{\n\t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\t\tif ( yy_current_state >= 128 )\n\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t\t}\n\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t\t++yy_cp;\n\t\t\t}\n\t\twhile ( yy_base[yy_current_state] != 316 );\n\nyy_find_action:\n\t\tyy_act = yy_accept[yy_current_state];\n\t\tif ( yy_act == 0 )\n\t\t\t{ /* have to back up */\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tyy_act = yy_accept[yy_current_state];\n\t\t\t}\n\n\t\tYY_DO_BEFORE_ACTION;\n\n\ndo_action:\t/* This label is used only to access EOF actions. */\n\n\n\t\tswitch ( yy_act )\n\t{ /* beginning of action switch */\n\t\t\tcase 0: /* must back up */\n\t\t\t/* undo the effects of YY_DO_BEFORE_ACTION */\n\t\t\t*yy_cp = yy_hold_char;\n\t\t\tyy_cp = yy_last_accepting_cpos;\n\t\t\tyy_current_state = yy_last_accepting_state;\n\t\t\tgoto yy_find_action;\n\ncase 1:\nYY_RULE_SETUP\n/* #line 1530 \"nidrgen.l\" */\n{ ++Lineno; }\n\tYY_BREAK\ncase 2:\nYY_RULE_SETUP\n/* #line 1531 \"nidrgen.l\" */\n{}\n\tYY_BREAK\ncase 3:\nYY_RULE_SETUP\n/* #line 1532 \"nidrgen.l\" */\n{ Alias(yytext); }\n\tYY_BREAK\ncase 4:\nYY_RULE_SETUP\n/* #line 1533 \"nidrgen.l\" */\n{ Type(KWKind_Int, yytext); }\n\tYY_BREAK\ncase 5:\nYY_RULE_SETUP\n/* #line 1534 \"nidrgen.l\" */\n{ Type(KWKind_Int | KWKind_List, yytext); }\n\tYY_BREAK\ncase 6:\nYY_RULE_SETUP\n/* #line 1535 \"nidrgen.l\" */\n{ kw_finish(0); }\n\tYY_BREAK\ncase 7:\nYY_RULE_SETUP\n/* #line 1536 \"nidrgen.l\" */\n{ kw_finish(KWKind_1); }\n\tYY_BREAK\ncase 8:\nYY_RULE_SETUP\n/* #line 1537 \"nidrgen.l\" */\n{ kw_finish(KWKind_01); }\n\tYY_BREAK\ncase 9:\nYY_RULE_SETUP\n/* #line 1538 \"nidrgen.l\" */\n{ kw_finish(KWKind_12); }\n\tYY_BREAK\ncase 10:\nYY_RULE_SETUP\n/* #line 1539 \"nidrgen.l\" */\n{ Type(KWKind_Str|KWKind_Libname, yytext); }\n\tYY_BREAK\ncase 11:\nYY_RULE_SETUP\n/* #line 1540 \"nidrgen.l\" */\n{ Type(KWKind_Real, yytext); }\n\tYY_BREAK\ncase 12:\nYY_RULE_SETUP\n/* #line 1541 \"nidrgen.l\" */\n{ Type(KWKind_Real | KWKind_List, yytext); }\n\tYY_BREAK\ncase 13:\nYY_RULE_SETUP\n/* #line 1542 \"nidrgen.l\" */\n{ Type(KWKind_Str, yytext); }\n\tYY_BREAK\ncase 14:\nYY_RULE_SETUP\n/* #line 1543 \"nidrgen.l\" */\n{ Type(KWKind_Str | KWKind_List, yytext); }\n\tYY_BREAK\ncase 15:\nYY_RULE_SETUP\n/* #line 1544 \"nidrgen.l\" */\n{ Keywd(yytext); }\n\tYY_BREAK\ncase 16:\nYY_RULE_SETUP\n/* #line 1545 \"nidrgen.l\" */\n{ kw_finish(-1); }\n\tYY_BREAK\ncase 17:\nYY_RULE_SETUP\n/* #line 1546 \"nidrgen.l\" */\n{ Saw_stok(Saw_desc, offsetof(KWctx,desc));\tBEGIN VAL; }\n\tYY_BREAK\ncase 18:\nYY_RULE_SETUP\n/* #line 1547 \"nidrgen.l\" */\n{ Saw_stok(Saw_tag, offsetof(KWctx,tag));\tBEGIN VAL; }\n\tYY_BREAK\ncase 19:\nYY_RULE_SETUP\n/* #line 1548 \"nidrgen.l\" */\n{ Saw_stok(Saw_group, offsetof(KWctx,group));\tBEGIN VAL; }\n\tYY_BREAK\ncase 20:\nYY_RULE_SETUP\n/* #line 1549 \"nidrgen.l\" */\n{ Saw_tok(Saw_dy, offsetof(KWctx,dylib));\n\t\t\t  dynlibseen = 1; dynline = Lineno;\t\tBEGIN VAL; }\n\tYY_BREAK\ncase 21:\nYY_RULE_SETUP\n/* #line 1551 \"nidrgen.l\" */\n{ Saw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\t  lastkw1->kind |= KWKind_Len1OK;\t\tBEGIN VAL; }\n\tYY_BREAK\ncase 22:\nYY_RULE_SETUP\n/* #line 1553 \"nidrgen.l\" */\n{ Saw_stok(Saw_len, offsetof(KWctx,len));\tBEGIN VAL; }\n\tYY_BREAK\ncase 23:\nYY_RULE_SETUP\n/* #line 1554 \"nidrgen.l\" */\n{ Saw_tok(Saw_dflt, KWKind_init); lastdef = 0;\tBEGIN VAL; }\n\tYY_BREAK\ncase 24:\nYY_RULE_SETUP\n/* #line 1555 \"nidrgen.l\" */\n{ Saw_tok(Saw_ge, KWKind_Lb); btype = KWKind_caneqLb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 25:\nYY_RULE_SETUP\n/* #line 1556 \"nidrgen.l\" */\n{ Saw_tok(Saw_gt, KWKind_Lb); btype = KWKind_strictLb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 26:\nYY_RULE_SETUP\n/* #line 1557 \"nidrgen.l\" */\n{ Saw_tok(Saw_le, KWKind_Ub); btype = KWKind_caneqUb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 27:\nYY_RULE_SETUP\n/* #line 1558 \"nidrgen.l\" */\n{ Saw_tok(Saw_lt, KWKind_Ub); btype = KWKind_strictUb;\tBEGIN VAL; }\n\tYY_BREAK\ncase 28:\nYY_RULE_SETUP\n/* #line 1559 \"nidrgen.l\" */\n{ if (Saw_name(yytext))\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 29:\nYY_RULE_SETUP\n/* #line 1560 \"nidrgen.l\" */\n{ Saw_num(yytext);\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 30:\nYY_RULE_SETUP\n/* #line 1561 \"nidrgen.l\" */\n{ Saw_quote();\t\tBEGIN INITIAL; }\n\tYY_BREAK\ncase 31:\nYY_RULE_SETUP\n/* #line 1563 \"nidrgen.l\" */\n{ Lbrace(); BEGIN FNC; }\n\tYY_BREAK\ncase 32:\nYY_RULE_SETUP\n/* #line 1564 \"nidrgen.l\" */\n{ Rbrace(); BEGIN INITIAL; }\n\tYY_BREAK\ncase 33:\nYY_RULE_SETUP\n/* #line 1565 \"nidrgen.l\" */\n{ Bar(); }\n\tYY_BREAK\ncase 34:\nYY_RULE_SETUP\n/* #line 1566 \"nidrgen.l\" */\n{ Lpar(); }\n\tYY_BREAK\ncase 35:\nYY_RULE_SETUP\n/* #line 1567 \"nidrgen.l\" */\n{ Rpar(); }\n\tYY_BREAK\ncase 36:\nYY_RULE_SETUP\n/* #line 1568 \"nidrgen.l\" */\n{ Lsqb(); }\n\tYY_BREAK\ncase 37:\nYY_RULE_SETUP\n/* #line 1569 \"nidrgen.l\" */\n{ Rsqb(); }\n\tYY_BREAK\ncase 38:\nYY_RULE_SETUP\n/* #line 1570 \"nidrgen.l\" */\n{ Fnc(yytext); }\n\tYY_BREAK\ncase 39:\nYY_RULE_SETUP\n/* #line 1571 \"nidrgen.l\" */\n{}\n\tYY_BREAK\ncase 40:\nYY_RULE_SETUP\n/* #line 1572 \"nidrgen.l\" */\n{++Lineno;}\n\tYY_BREAK\ncase 41:\nYY_RULE_SETUP\n/* #line 1573 \"nidrgen.l\" */\n{ Eat_comment(); }\n\tYY_BREAK\ncase 42:\nYY_RULE_SETUP\n/* #line 1574 \"nidrgen.l\" */\n{ botch(\"\\\"%s\\\" unexpected\", yytext); }\n\tYY_BREAK\ncase 43:\nYY_RULE_SETUP\n/* #line 1576 \"nidrgen.l\" */\nECHO;\n\tYY_BREAK\n/* #line 2465 \"nidrgen.c\" */\ncase YY_STATE_EOF(INITIAL):\ncase YY_STATE_EOF(FNC):\ncase YY_STATE_EOF(VAL):\n\tyyterminate();\n\n\tcase YY_END_OF_BUFFER:\n\t\t{\n\t\t/* Amount of text matched not including the EOB char. */\n\t\tint yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;\n\n\t\t/* Undo the effects of YY_DO_BEFORE_ACTION. */\n\t\t*yy_cp = yy_hold_char;\n\t\tYY_RESTORE_YY_MORE_OFFSET\n\n\t\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )\n\t\t\t{\n\t\t\t/* We're scanning a new file or input source.  It's\n\t\t\t * possible that this happened because the user\n\t\t\t * just pointed yyin at a new source and called\n\t\t\t * yylex().  If so, then we have to assure\n\t\t\t * consistency between yy_current_buffer and our\n\t\t\t * globals.  Here is the right place to do so, because\n\t\t\t * this is the first action (other than possibly a\n\t\t\t * back-up) that will match for the new input source.\n\t\t\t */\n\t\t\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\t\t\tyy_current_buffer->yy_input_file = yyin;\n\t\t\tyy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;\n\t\t\t}\n\n\t\t/* Note that here we test for yy_c_buf_p \"<=\" to the position\n\t\t * of the first EOB in the buffer, since yy_c_buf_p will\n\t\t * already have been incremented past the NUL character\n\t\t * (since all states make transitions on EOB to the\n\t\t * end-of-buffer state).  Contrast this with the test\n\t\t * in input().\n\t\t */\n\t\tif ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t{ /* This was really a NUL. */\n\t\t\tyy_state_type yy_next_state;\n\n\t\t\tyy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;\n\n\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t/* Okay, we're now positioned to make the NUL\n\t\t\t * transition.  We couldn't have\n\t\t\t * yy_get_previous_state() go ahead and do it\n\t\t\t * for us because it doesn't know how to deal\n\t\t\t * with the possibility of jamming (and we don't\n\t\t\t * want to build jamming into it because then it\n\t\t\t * will run more slowly).\n\t\t\t */\n\n\t\t\tyy_next_state = yy_try_NUL_trans( yy_current_state );\n\n\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\tif ( yy_next_state )\n\t\t\t\t{\n\t\t\t\t/* Consume the NUL. */\n\t\t\t\tyy_cp = ++yy_c_buf_p;\n\t\t\t\tyy_current_state = yy_next_state;\n\t\t\t\tgoto yy_match;\n\t\t\t\t}\n\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tgoto yy_find_action;\n\t\t\t\t}\n\t\t\t}\n\n\t\telse switch ( yy_get_next_buffer() )\n\t\t\t{\n\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t{\n\t\t\t\tyy_did_buffer_switch_on_eof = 0;\n\n\t\t\t\tif ( yywrap() )\n\t\t\t\t\t{\n\t\t\t\t\t/* Note: because we've taken care in\n\t\t\t\t\t * yy_get_next_buffer() to have set up\n\t\t\t\t\t * yytext, we can now set up\n\t\t\t\t\t * yy_c_buf_p so that if some total\n\t\t\t\t\t * hoser (like flex itself) wants to\n\t\t\t\t\t * call the scanner after we return the\n\t\t\t\t\t * YY_NULL, it'll still work - another\n\t\t\t\t\t * YY_NULL will get returned.\n\t\t\t\t\t */\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + YY_MORE_ADJ;\n\n\t\t\t\t\tyy_act = YY_STATE_EOF(YY_START);\n\t\t\t\t\tgoto do_action;\n\t\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t\tyytext_ptr + yy_amount_of_matched_text;\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_match;\n\n\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\tyy_c_buf_p =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[yy_n_chars];\n\n\t\t\t\tyy_current_state = yy_get_previous_state();\n\n\t\t\t\tyy_cp = yy_c_buf_p;\n\t\t\t\tyy_bp = yytext_ptr + YY_MORE_ADJ;\n\t\t\t\tgoto yy_find_action;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tYY_FATAL_ERROR(\n\t\t\t\"fatal flex scanner internal error--no action found\" );\n\t} /* end of action switch */\n\t\t} /* end of scanning one token */\n\t} /* end of yylex */\n\n\n/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n\nstatic int yy_get_next_buffer()\n\t{\n\tregister char *dest = yy_current_buffer->yy_ch_buf;\n\tregister char *source = yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( yy_current_buffer->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\tint num_to_read =\n\t\t\tyy_current_buffer->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n#ifdef YY_USES_REJECT\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n#else\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = yy_current_buffer;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyy_flex_realloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = yy_current_buffer->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n#endif\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\n\t\t\tyy_n_chars, num_to_read );\n\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tif ( yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tyy_current_buffer->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tyy_n_chars += number_to_move;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];\n\n\treturn ret_val;\n\t}\n\n\n/* yy_get_previous_state - get the state just before the EOB char was reached */\n\nstatic yy_state_type yy_get_previous_state()\n\t{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n\n\tyy_current_state = yy_start;\n\n\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 128 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n\t}\n\n\n/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n\n#ifdef YY_USE_PROTOS\nstatic yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )\n#else\nstatic yy_state_type yy_try_NUL_trans( yy_current_state )\nyy_state_type yy_current_state;\n#endif\n\t{\n\tregister int yy_is_jam;\n\tregister char *yy_cp = yy_c_buf_p;\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyy_last_accepting_state = yy_current_state;\n\t\tyy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 128 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 127);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n\t}\n\n\n#ifndef YY_NO_UNPUT\n#ifdef YY_USE_PROTOS\nstatic void yyunput( int c, register char *yy_bp )\n#else\nstatic void yyunput( c, yy_bp )\nint c;\nregister char *yy_bp;\n#endif\n\t{\n\tregister char *yy_cp = yy_c_buf_p;\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = yy_hold_char;\n\n\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = yy_n_chars + 2;\n\t\tregister char *dest = &yy_current_buffer->yy_ch_buf[\n\t\t\t\t\tyy_current_buffer->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&yy_current_buffer->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > yy_current_buffer->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tyy_current_buffer->yy_n_chars =\n\t\t\tyy_n_chars = yy_current_buffer->yy_buf_size;\n\n\t\tif ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\n\tyytext_ptr = yy_bp;\n\tyy_hold_char = *yy_cp;\n\tyy_c_buf_p = yy_cp;\n\t}\n#endif\t/* ifndef YY_NO_UNPUT */\n\n\n#ifndef YY_NO_INPUT\n#ifdef __cplusplus\nstatic int yyinput()\n#else\nstatic int input()\n#endif\n\t{\n\tint c;\n\n\t*yy_c_buf_p = yy_hold_char;\n\n\tif ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = yy_c_buf_p - yytext_ptr;\n\t\t\t++yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer() )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart( yyin );\n\n\t\t\t\t\t/* fall through */\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap() )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyy_c_buf_p = yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyy_hold_char = *++yy_c_buf_p;\n\n\n\treturn c;\n\t}\n#endif /* YY_NO_INPUT */\n\n#ifdef YY_USE_PROTOS\nvoid yyrestart( FILE *input_file )\n#else\nvoid yyrestart( input_file )\nFILE *input_file;\n#endif\n\t{\n\tif ( ! yy_current_buffer )\n\t\tyy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );\n\n\tyy_init_buffer( yy_current_buffer, input_file );\n\tyy_load_buffer_state();\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n#else\nvoid yy_switch_to_buffer( new_buffer )\nYY_BUFFER_STATE new_buffer;\n#endif\n\t{\n\tif ( yy_current_buffer == new_buffer )\n\t\treturn;\n\n\tif ( yy_current_buffer )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yy_c_buf_p = yy_hold_char;\n\t\tyy_current_buffer->yy_buf_pos = yy_c_buf_p;\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tyy_current_buffer = new_buffer;\n\tyy_load_buffer_state();\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyy_did_buffer_switch_on_eof = 1;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_load_buffer_state( void )\n#else\nvoid yy_load_buffer_state()\n#endif\n\t{\n\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\n\tyyin = yy_current_buffer->yy_input_file;\n\tyy_hold_char = *yy_c_buf_p;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n#else\nYY_BUFFER_STATE yy_create_buffer( file, size )\nFILE *file;\nint size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer( b, file );\n\n\treturn b;\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_delete_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_delete_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_current_buffer = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyy_flex_free( (void *) b->yy_ch_buf );\n\n\tyy_flex_free( (void *) b );\n\t}\n\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )\n#else\nvoid yy_init_buffer( b, file )\nYY_BUFFER_STATE b;\nFILE *file;\n#endif\n\n\n\t{\n\tyy_flush_buffer( b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n#if YY_ALWAYS_INTERACTIVE\n\tb->yy_is_interactive = 1;\n#else\n#if YY_NEVER_INTERACTIVE\n\tb->yy_is_interactive = 0;\n#else\n\tb->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n#endif\n#endif\n\t}\n\n\n#ifdef YY_USE_PROTOS\nvoid yy_flush_buffer( YY_BUFFER_STATE b )\n#else\nvoid yy_flush_buffer( b )\nYY_BUFFER_STATE b;\n#endif\n\n\t{\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == yy_current_buffer )\n\t\tyy_load_buffer_state();\n\t}\n\n\n#ifndef YY_NO_SCAN_BUFFER\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )\n#else\nYY_BUFFER_STATE yy_scan_buffer( base, size )\nchar *base;\nyy_size_t size;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b );\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_STRING\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )\n#else\nYY_BUFFER_STATE yy_scan_string( yy_str )\nyyconst char *yy_str;\n#endif\n\t{\n\tint len;\n\tfor ( len = 0; yy_str[len]; ++len )\n\t\t;\n\n\treturn yy_scan_bytes( yy_str, len );\n\t}\n#endif\n\n\n#ifndef YY_NO_SCAN_BYTES\n#ifdef YY_USE_PROTOS\nYY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )\n#else\nYY_BUFFER_STATE yy_scan_bytes( bytes, len )\nyyconst char *bytes;\nint len;\n#endif\n\t{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n\n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = len + 2;\n\tbuf = (char *) yy_flex_alloc( n );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < len; ++i )\n\t\tbuf[i] = bytes[i];\n\n\tbuf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer( buf, n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n\t}\n#endif\n\n\n#ifndef YY_NO_PUSH_STATE\n#ifdef YY_USE_PROTOS\nstatic void yy_push_state( int new_state )\n#else\nstatic void yy_push_state( new_state )\nint new_state;\n#endif\n\t{\n\tif ( yy_start_stack_ptr >= yy_start_stack_depth )\n\t\t{\n\t\tyy_size_t new_size;\n\n\t\tyy_start_stack_depth += YY_START_STACK_INCR;\n\t\tnew_size = yy_start_stack_depth * sizeof( int );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tyy_start_stack = (int *) yy_flex_alloc( new_size );\n\n\t\telse\n\t\t\tyy_start_stack = (int *) yy_flex_realloc(\n\t\t\t\t\t(void *) yy_start_stack, new_size );\n\n\t\tif ( ! yy_start_stack )\n\t\t\tYY_FATAL_ERROR(\n\t\t\t\"out of memory expanding start-condition stack\" );\n\t\t}\n\n\tyy_start_stack[yy_start_stack_ptr++] = YY_START;\n\n\tBEGIN(new_state);\n\t}\n#endif\n\n\n#ifndef YY_NO_POP_STATE\nstatic void yy_pop_state()\n\t{\n\tif ( --yy_start_stack_ptr < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(yy_start_stack[yy_start_stack_ptr]);\n\t}\n#endif\n\n\n#ifndef YY_NO_TOP_STATE\nstatic int yy_top_state()\n\t{\n\treturn yy_start_stack[yy_start_stack_ptr - 1];\n\t}\n#endif\n\n#ifndef YY_EXIT_FAILURE\n#define YY_EXIT_FAILURE 2\n#endif\n\n#ifdef YY_USE_PROTOS\nstatic void yy_fatal_error( yyconst char msg[] )\n#else\nstatic void yy_fatal_error( msg )\nchar msg[];\n#endif\n\t{\n\t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n\t}\n\n\n\n/* Redefine yyless() so it works in section 3 code. */\n\n#undef yyless\n#define yyless(n) \\\n\tdo \\\n\t\t{ \\\n\t\t/* Undo effects of setting up yytext. */ \\\n\t\tyytext[yyleng] = yy_hold_char; \\\n\t\tyy_c_buf_p = yytext + n; \\\n\t\tyy_hold_char = *yy_c_buf_p; \\\n\t\t*yy_c_buf_p = '\\0'; \\\n\t\tyyleng = n; \\\n\t\t} \\\n\twhile ( 0 )\n\n\n/* Internal utility routines. */\n\n#ifndef yytext_ptr\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_strncpy( char *s1, yyconst char *s2, int n )\n#else\nstatic void yy_flex_strncpy( s1, s2, n )\nchar *s1;\nyyconst char *s2;\nint n;\n#endif\n\t{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n\t}\n#endif\n\n#ifdef YY_NEED_STRLEN\n#ifdef YY_USE_PROTOS\nstatic int yy_flex_strlen( yyconst char *s )\n#else\nstatic int yy_flex_strlen( s )\nyyconst char *s;\n#endif\n\t{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n\t}\n#endif\n\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_alloc( yy_size_t size )\n#else\nstatic void *yy_flex_alloc( size )\nyy_size_t size;\n#endif\n\t{\n\treturn (void *) malloc( size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void *yy_flex_realloc( void *ptr, yy_size_t size )\n#else\nstatic void *yy_flex_realloc( ptr, size )\nvoid *ptr;\nyy_size_t size;\n#endif\n\t{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n\t}\n\n#ifdef YY_USE_PROTOS\nstatic void yy_flex_free( void *ptr )\n#else\nstatic void yy_flex_free( ptr )\nvoid *ptr;\n#endif\n\t{\n\tfree( ptr );\n\t}\n\n#if YY_MAIN\nint main()\n\t{\n\tyylex();\n\treturn 0;\n\t}\n#endif\n/* #line 1576 \"nidrgen.l\" */\n\n\n static void\ncantopen(char *what)\n{ fprintf(stderr, \"%s: cannot open \\\"%s\\\"\\n\", progname, what); }\n\n int\nyywrap(void)\n{\n\tif (tagin) {\n\t\tif (tagin != stdin)\n\t\t\tfclose(tagin);\n\t\ttagin = 0;\n\t\tLineno = 1;\n\t\tsaweof = 1;\n\t\tif (*specfile == '-' && !specfile[1]) {\n\t\t\tyyin = stdin;\n\t\t\tinfname = 0;\n\t\t\treturn 0;\n\t\t\t}\n\t\tif ((yyin = fopen(infname = specfile, \"r\")))\n\t\t\treturn 0;\n\t\tcantopen(specfile);\n\t\texit(1);\n\t\t}\n\treturn 1;\n\t}\n\n static void\nEat_comment(void)\n{\n\tint c;\n\n\tfor(;;) {\n\t\tc = input();\n c_check:\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within /* comment */\");\n\t\tif (c == '*') {\n\t\t\tc = input();\n\t\t\tif (c == '/')\n\t\t\t\treturn;\n\t\t\tgoto c_check;\n\t\t\t}\n\t\tif (c == '\\n')\n\t\t\t++Lineno;\n\t\t}\n\t}\n\n static void\nSaw_quote(void)\n{\n\tKWctx *kw, *kw1, *kw2;\n\tchar buf[1024];\n\tchar *b, *b0, *be, *lname;\n\tint c, c0;\n\tsize_t L, L0, L1;\n\tunsigned char *us;\n\n\tstatic char escname[32];\n\tstatic char hexdig[16] = \"0123456789abcdef\";\n\tstatic unsigned char esetup[] = \"\\aa\\bb\\ff\\nn\\rr\\tt\\vv\";\n\n\tif (!escname['\\a'])\n\t\tfor(us = esetup; *us; us += 2)\n\t\t\tescname[*us] = us[1];\t/* assuming ASCII */\n\tb0 = b = buf;\n\tL = sizeof(buf);\n\tbe = b + L - 3;\t/* allow room for /xhh */\n\tc0 = 0;\n\tsaweof = 0;\n\tfor(;;) {\n\t\tc = input();\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within quoted string\");\n\t\tif (b >= be) {\n\t\t\tL1 = b - b0;\n\t\t\tL0 = L;\n\t\t\tL <<= 1;\n\t\t\tbe = (char*)Malloc(L, \"Saw_quote\");\n\t\t\tmemcpy(be, b0, L1);\n\t\t\tif (b0 != buf)\n\t\t\t\tfree(b0);\n\t\t\tb0 = be;\n\t\t\tb = b0 + L1;\n\t\t\tbe = b0 + L - 3;\n\t\t\t}\n\t\tif (c < ' ') {\n\t\t\t*b++ = '\\\\';\n\t\t\tif (escname[c]) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\t++Lineno;\n\t\t\t\tc = escname[c];\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t*b++ = 'x';\n\t\t\t\t*b++ = '0' + (c >> 4);\n\t\t\t\tc = hexdig[c & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t*b++ = c;\n\t\tif (c0 == '\\\\')\n\t\t\tc0 = 0;\n\t\telse {\n\t\t\tc0 = c;\n\t\t\tif (c == '\"') {\n\t\t\t\twhile((c = input()) <= ' ') {\n\t\t\t\t\tif (c == EOF || !c) {\n\t\t\t\t\t\tc = ';';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (c == '\\n')\n\t\t\t\t\t\t++Lineno;\n\t\t\t\t\t}\n\t\t\t\tif (c == '\"' && !saweof) {\n\t\t\t\t\t--b;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tb[-1] = 0;\t/* replacing \" */\n\tif (lastseen == Saw_tag) {\n\t\tif (saweof) /* kludge around poor flex design */ {\n\t\t\ttagin = stdin;\n\t\t\tSaw_name(b0);\n\t\t\ttagin = 0;\n\t\t\t}\n\t\telse\n\t\t\tSaw_name(b0);\n\t\t}\n\telse {\n\t\tL = b - b0;\n\t\tbe = (char*)Alloc(L);\n\t\tmemcpy(be, b0, L);\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t  case Saw_dfltname:\n\t\t\tif ((lastkw1->kind & KWKind_Mask) != KWKind_Str)\n\t\t\t\tbotch(\"%s cannot have a string-valued := value\",\n\t\t\t\t\tlastkw1->names->val);\n\t\t\tlastkw1->cinit = be;\n\t\t\tif (lastdef)\n\t\t\t\tset_lastdef(b0, 1);\n\t\t\tbreak;\n\t\t  case Saw_desc:\n\t\t\tlastkw1->desc = be;\n\t\t\tbreak;\n\t\t  case Saw_dy:\n\t\t\tlastkw1->dylib = be;\n\t\t\tif (lastkw1->nfcn > 0)\n\t\t\t\tfuncbotch(lastkw1);\n\t\t\tif (libexpand) {\n\t\t\t\tkw = *KWtop;\n\t\t\t\tlastseen = Saw_kwname;\n\t\t\t\tif (kw == lastkw1)\n\t\t\t\t\tkw = *--KWtop;\n\t\t\t\telse if ((kw2 = kw->rparent))\n\t\t\t\t\tkw = kw2;\n\t\t\t\tkw1 = lastkw1;\n\t\t\t\tif ((kw2 = kw->kw) == kw1) {\n\t\t\t\t\tif ((kw2 = kw->kw = kw2->next)\n\t\t\t\t\t && kw2->alt == kw1->alt)\n\t\t\t\t\t\tBar();\n\t\t\t\t\telse  {\n\t\t\t\t\t\t--kw->alt;\n\t\t\t\t\t\tif (kw1->req)\n\t\t\t\t\t\t\t--kw->nreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tLpar();\n\t\t\t\tKeywd(kw1->name1);\n\t\t\t\tlname = kw1->dylib;\n\t\t\t\tif (lib_read(kw1,0))\n\t\t\t\t\tlastkw1->dylib = lname;\n\t\t\t\tRpar();\n\t\t\t\tif (kw1->parstate == PPar_leftpar)\n\t\t\t\t\t++KWtop;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t  case Saw_group:\n\t\t\tlastkw1->group = be;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tunexpected(\"string\");\n\t\t  }\n\t\t}\n\tif (b0 != buf)\n\t\tfree(b0);\n\tlastseen = Saw_type;\n\t}\n\n static int\nusage(int rc)\n{\n\tfprintf(rc ? stderr : stdout,\n\t\"Usage: %s [options] specfile [tagfile [defs_out [keywds_out]]]\\n\\\n\twhere the last two are output files, \\\".\\\" means \\\"omit\\\", and \\\"-\\\"\\n\\\n\tmeans write to stdout.  Missing trailing arguments are not read\\n\\\n\tor written, except that if all outputs are missing, \\\". -\\\" is assumed.\\n\\\n\tOptions may modify this behavior.\\noptions:\\n\\\n\t-D\t\t{ just write definitions to stdout }\\n\\\n\t-d\t\t{ suppress test for ambiguity from duplicate keywords }\\n\\\n\t-e\t\t{ expand ((...)) for debugging }\\n\\\n\t-f\t\t{ omit functions, i.e., {...} with -p; without -p,\\n\\\n\t\t\t  supply NULL function pointers }\\n\\\n\t-G\t\t{ for keywords with a TAG but not GROUP, do not assume\\n\\\n\t\t\t  that implictly GROUP == TAG }\\n\\\n\t-g\t\t{ write GuiKeyWord rather than KeyWord header;\\n\\\n\t\t\t  with -p, include GUI details: TAG, DESC, GROUP, LEN }\\n\\\n\t-h headername\t{ Specify header file(s), e.g., \\\"-h nidr.h\\\";\\n\\\n\t\t\t  several -h options can be given;\\n\\\n\t\t\t  default = -h- ==> no headers }\\n\\\n\t-j specsum\t{ write file specsum for use by \\\"dakreord specsum ...\\\"\\n\\\n\t\t\t  and \\\"dakreorder -j specsum ...\\\" }\\n\\\n\t-k keyname\t{ library mode with input containing several keywords\\n\\\n\t\t\t  to be contained in keyword keyname; implies -l and\\n\\\n\t\t\t  has no other effect if -D, -g, -j, -p, or -s is given.\\n\\\n\t\t\t  If -l is given without -k and several keywords appear\\n\\\n\t\t\t  in the input, assume \\\"-k KeywordTop\\\". }\\n\\\n\t-L libname\t{ obtain keyword details from library libname (compiled\\n\\\n\t\t\t  from source produced by an earlier \\\"nidrgen -l ...\\\"\\n\\\n\t\t\t  invocation); non-option arguments in this case are\\n\\\n\t\t\t  [defs_out [keywds_out]] }\\n\\\n\t-l\t\t{ library mode: with -D, -g, -j, -p, or -s, attempt to\\n\\\n\t\t\t  load libraries specified with \\\"DYNLIB libname\\\" and\\n\\\n\t\t\t  incorporate keyword specifications provided by the\\n\\\n\t\t\t  loaded libraries; otherwise generate source for\\n\\\n\t\t\t  compilation into a shared library for loading when a\\n\\\n\t\t\t  keyword marked with \\\"DYNLIB libname\\\" (in a separate\\n\\\n\t\t\t  run of nidrgen) is seen.  The library provides\\n\\\n\t\t\t  contained keywords and any needed final routine for\\n\\\n\t\t\t  the marked keyword. }\\n\\\n\t-m mtagfile\t{ just write to mtagfile tags not found in tagfile }\\n\\\n\t-n namespname\t{ assume namespace namespname;\\n\\\n\t\t\t  default = -n Dakota\\n\\\n\t\t\t  -n- ==> no namespace }\\n\\\n\t-p[w]\t\t{ pretty-print rather than produce KeyWord header;\\n\\\n\t\t\t  add w spaces (default 2) for each nested context. }\\n\\\n\t-s[w]\t\t{ like -p[w], but sort the keywords }\\n\\\n\t-T outtagfile\t{ write dummy tagfile to outtagfile (and quit) }\\n\\\n\t-t\t\t{ ignore TAG fields if tagfile is not given }\\n\\\n\t-w\t\t{ cancel warn mode: do not report (on stderr)\\n\\\n\t\t\t  the number of implicitly named start routines;\\n\\\n\t\t\t  still flag their names  with /*!!*/ }\\n\",\n\t\tprogname);\n\treturn rc;\n\t}\n\n static StrList *\nreverse(StrList **x)\n{\n\tStrList *s, *t, *u;\n\n\tif (!(s = *x) || !s->next)\n\t\treturn s;\n\tfor(t = 0; s; s = u) {\n\t\tu = s->next;\n\t\ts->next = t;\n\t\tt = s;\n\t\t}\n\treturn *x = t;\n\t}\n\n static int\nkwcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const KWctx**)a)->names->val, (*(const KWctx**)b)->names->val);\n\t}\n\n static KWctx *\nkwsort(KWctx *kw0)\n{\n\t/* Sort keywords after expanding kw list with aliases; compute nkw, */\n\t/* including aliases. */\n\n\tKWctx *kw, *kw1, *kw2, *kwm, **x, **x0, **xe, *x00[512];\n\tStrList *dname, *minname, *nam, **pmin, **pnam;\n\tchar *descsave, *groupsave;\n\tint agadj, nk;\n\tsize_t L, nkw, nkwa, onkwa;\n\n\treverse(&kw0->funcs);\n\tnkw = nkwa = 0;\n\tfor(kw = kw0->kw; kw; kw = kw->next) {\n\t\t++nkw;\n\t\tpmin = &kw->names;\n\t\tminname = *pmin;\n\t\tpnam = &minname->next;\n\t\tonkwa = nkwa;\n\t\twhile((nam = *pnam)) {\n\t\t\tdname = nam;\n\t\t\t++nkwa;\n\t\t\tif (strcmp(nam->val, minname->val) < 0) {\n\t\t\t\tpmin = pnam;\n\t\t\t\tminname = nam;\n\t\t\t\t}\n\t\t\tpnam = &nam->next;\n\t\t\t}\n\t\tagadj = 2*kw->agroup;\n\t\tkw->agroup = agadj + 1;\n\t\tif (nkwa > onkwa) {\n\t\t\t*pmin = minname->next;\n\t\t\tminname->next = kw->names;\n\t\t\tnam = kw->names = minname;\n\t\t\tnk = kw->kno;\t/* ALias() made room for nk use below */\n\t\t\tdescsave = kw->desc;\n\t\t\tgroupsave = kw->group;\n\t\t\tif (dname != minname) {\n\t\t\t\tkw->desc = kw->group = 0;\n\t\t\t\tkw->agroup = agadj;\n\t\t\t\t}\n\t\t\tkwm = kw;\n\t\t\tkw = kw2 = 0;\n\t\t\tif (nam->primary)\n\t\t\t\tkw2 = kwm;\n\t\t\twhile((nam = nam->next)) {\n\t\t\t\tkw1 = (KWctx*)Alloc(sizeof(KWctx));\n\t\t\t\tif (!kw)\n\t\t\t\t\tkw = kw1;\t/* so kw->next is right */\n\t\t\t\tkw1->next = kwm->next;\n\t\t\t\tkwm->next = kw1;\n\t\t\t\tkw1->names = nam;\n\t\t\t\tkw1->master = kwm;\n\t\t\t\tkw1->kind = kwm->kind;\n\t\t\t\tkw1->kno = ++nk;\n\t\t\t\tkw1->agroup = agadj;\n\t\t\t\tif (nam == dname) {\n\t\t\t\t\tkw1->desc = descsave;\n\t\t\t\t\tkw1->group = groupsave;\n\t\t\t\t\tkw1->agroup = agadj + 1;\n\t\t\t\t\t}\n\t\t\t\tif (nam->primary)\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t}\n\t\t\tif (kw2 != kwm && !guikeywds) {\n\t\t\t\tkw2->defname = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->len;\n\t\t\t\tkwm->len = 0;\n\t\t\t\tkw2->init = kwm->init;\n\t\t\t\tkwm->init = 0;\n\t\t\t\tkw2->cinit = kwm->cinit;\n\t\t\t\tkwm->cinit = 0;\n\t\t\t\tkw2->dylib = kwm->dylib;\n\t\t\t\t/* no need to change kwm->dylib */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwm;; kw1 = kw1->next) {\n\t\t\t\tif (kw1 != kw2)\n\t\t\t\t\tkw1->pmaster = kw2;\n\t\t\t\tif (kw1 == kw)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tkw0->nkw = (int)(nkw += nkwa);\n\tif (nkw <= 1)\n\t\treturn kw0->kw;\n\tx0 = x00;\n\tif (nkw > sizeof(x00)/sizeof(x00[0]))\n\t\tx0 = (KWctx**)Malloc(L = nkw*sizeof(KWctx*), \"kwsort\");\n\tfor(x = x0, kw = kw0->kw; kw; kw = kw->next)\n\t\t*x++ = kw;\n\tqsort(x0, nkw, sizeof(KWctx*), kwcomp);\n\tfor(xe = x - 1, x = x0; x < xe; ++x) {\n\t\tif (!strcmp(x[0]->names->val, x[1]->names->val)) {\n\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\tprogname, x[0]->names->val);\n\t\t\t++dupnames;\n\t\t\t}\n\t\tx[0]->next = x[1];\n\t\t}\n\tx[0]->next = 0;\n\tfor(x = x0, ++xe; x < xe; ++x)\n\t\t(*x)->paoff = x - x0;\n\tfor(x = x0; x < xe; ++x)\n\t\tif ((kw1 = (kw = *x)->pmaster))\n\t\t\tkw->paoff = kw1->paoff - kw->paoff;\n\tfor(x = x0; x < xe; ++x)\n\t\tif (!(kw = *x)->pmaster)\n\t\t\tkw->paoff = 0;\n\tkw0->kw = kw = x0[0];\n\tif (x0 != x00)\n\t\tfree(x0);\n\treturn kw;\n\t}\n\n static int\nalphanum(char *s)\n{\n\tfor(; *s; ++s)\n\t\tif (!isalnum(*s))\n\t\t\treturn 0;\n\treturn 1;\n\t}\n\n enum CommaState {\n\tCS_Comma = 0,\n\tCS_Clbra = 1,\n\tCS_rbraC = 2,\n\tCS_lrbrC = 3,\n\tCS_rbr2C = 4\n\t};\n\n static const char\n\t*Commasx[5] = { \",\", \",{\", \"},\", \",{},\",/*{{*/ \"}},\" },\n\t*Commas0[5] = { \",\", \",\", \",\", \",\", \",\" };\n static const char **Comma;\n\n typedef struct Zbuf Zbuf;\n struct\nZbuf {\n\tchar buf[80];\t/* overkill */\n\tchar *b;\n\tint nnz;\n\tenum CommaState cs;\n\t};\n\n static void\niput(int i, Zbuf *z)\n{\n\tchar *s;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (i == 0) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s%d\", t, i);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nnput(char *s, Zbuf *z)\n{\n\tchar *fmt, *s1;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s || (strtod(s,&s1) == 0. && !*s1)) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\t*s++ = '.';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tfmt = \"%s%s.\";\n\t\tfor(s1 = s; *s1; ++s1)\n\t\t\tswitch(*s1) {\n\t\t\t\tcase '.':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'E':\n\t\t\t\t\tfmt = \"%s%s\";\n\t\t\t\t\tgoto have_fmt;\n\t\t\t\t}\n have_fmt:\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(fmt, t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nsput(char *s, Zbuf *z)\n{\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s\\\"%s\\\"\", t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nzbclear(Zbuf *z)\n{\n\tif (z->b > z->buf) {\n\t\t*z->b = 0;\n\t\tprintf(\"%s\", z->b = z->buf);\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n typedef struct\nFCat { char *b, *b0, *be; } FCat;\n\n static char *\nfunc_cat(FCat *fc, StrList *f)\n{\n\tchar *b, *b1, *be;\n\tint k, n;\n\tsize_t L, L1, L2, L3;\n\n\tif (!f)\n\t\treturn 0;\n\tif (!f->next)\n\t\treturn f->val;\n\tb = fc->b;\n\tbe = fc->be;\n\tfor(n = k = 0; f; f = f->next, ++n) {\n\t\tL = L1 = strlen(f->val);\n\t\tif (n) {\n\t\t\t++L1;\n\t\t\tif (n & 1) {\n\t\t\t\tif (alphanum(f->val)) {\n\t\t\t\t\tk = 2;\n\t\t\t\t\tL1 += 7;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = 3;\n\t\t\t\t\tL1 += 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tk = 1;\n\t\t\t}\n\t\tif (L1 > be - b) {\n\t\t\tL2 = b - fc->b;\n\t\t\tL3 = 2*(be - fc->b + L1);\n\t\t\tb1 = (char*)Malloc(L3, \"func_cat\");\n\t\t\tif (L2)\n\t\t\t\tmemcpy(b1, fc->b, L2);\n\t\t\tif (fc->b != fc->b0)\n\t\t\t\tfree(fc->b);\n\t\t\tfc->b = b1;\n\t\t\tbe = fc->be = b1 + L3;\n\t\t\tb = b1 + L2;\n\t\t\t}\n\t\tswitch(k) {\n\t\t\tcase 0: break;\n\t\t\tcase 1: *b++ = ',';\n\t\t\t\tbreak;\n\t\t\tcase 2: memcpy(b, \",(void*)\", 8);\n\t\t\t\tb += 8;\n\t\t\t\tbreak;\n\t\t\tcase 3: memcpy(b, \",(void*)(\", 9);\n\t\t\t\tb += 9;\n\t\t\t}\n\t\tstrcpy(b, f->val);\n\t\tb += L;\n\t\tif (k == 3)\n\t\t\t*b++ = ')';\n\t\t*b = 0;\n\t\t}\n\treturn fc->b;\n\t}\n\n static void\nkwout(KWctx *kw, KWctx **kwtop, Uint xflag)\n{\n\tFCat fc;\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, **kws, **x, *x0[KWOUTlen0];\n\tStrList *S, *nam;\n\tZbuf z;\n\tchar fbuf[256], *funcs, *s;\n\tconst char *fmt, *ffmt;\n\tint aoff, k, i, m, m1, n, roff, sentinnel, skipfuncs;\n\n\tif (expand && !kw->names)\n\t\treturn;\n\tif (needcomma) {\n\t\tprintf(\",\\n\");\n\t\tneedcomma = 0;\n\t\t}\n\tkw1 = kw->kw;\n\tn = 0;\n\tfc.b = fc.b0 = fbuf;\n\tfc.be = fbuf + sizeof(fbuf);\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastkno + 1;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastkno + 1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tif (expand)\n\t\tfor(kw0 = kw1; kw0 && !kw0->names; kw0 = kw0->next)\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next)\n\t\t\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwout\");\n\tm = 0;\n\tkw0 = kw1;\n\tif (expand) {\n\t\taoff = kw->nalt;\n\t\troff = kw->nreq;\n\t\tfor(; kw0 && !kw0->names; kw0 = kw0->next) {\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next) {\n\t\t\t\tkw2->altoffset = aoff;\n\t\t\t\tkw2->reqoffset = roff;\n\t\t\t\tx[m++] = kw2;\n\t\t\t\t}\n\t\t\taoff += kw0->nalt;\n\t\t\troff += kw0->nreq;\n\t\t\t}\n\t\tkw->nalt = aoff;\n\t\tkw->nreq = roff;\n\t\t}\n\tfor(; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tsentinnel = 0;\n\tif (expand) {\n\t\tkw->nkw = m;\n\t\tqsort(x, m, sizeof(KWctx*), kwcomp);\n\t\tfor(i = 1; i < m; ++i)\n\t\t\tif (!strcmp(x[i-1]->names->val, x[i]->names->val)) {\n\t\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\t\tprogname, x[i]->names->val);\n\t\t\t\t++dupnames;\n\t\t\t\t}\n\t\t}\n\telse if (kw->nkw == 0)\n\t\tsentinnel = 1;\n\tm1 = m + sentinnel;\n\tprintf(\"\\tkw_%d[%d] = {\\n\" /*}*/, kw->kwkno = ++lastkno, m1);\n\tneedcomma = 1;\n\tz.nnz = 0;\n\tskipfuncs = !wantfuncs && !xflag;\n\tfor(i = 0; i < m;) {\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tif (!(kwp = kw1->pmaster))\n\t\t\tkwp = kw1;\n\t\tfputs(xflag ? \"\\t\\t{{\" : \"\\t\\t{\" /*}}}*/, stdout);\n\t\tz.b = z.buf;\n\t\tz.cs = CS_Comma;\n\t\tif ((nam = kw1->names)) {\n\t\t\tk = kwp->kind | kw1->names->primary | xflag;\n\t\t\tif (kwp->dylib)\n\t\t\t\tk |= KWKind_Dynlib;\n\t\t\tprintf(k < 16\n\t\t\t\t? \"\\\"%s\\\",%d\"\n\t\t\t\t: \"\\\"%s\\\",0x%x\", kw1->names->val, k);\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(kwm->alt + kwm->altoffset, &z);\n\t\t\tiput(kwm->req ? kwm->req + kwm->reqoffset : 0, &z);\n\t\t\t}\n\t\telse {\n\t\t\tif (xflag)\n\t\t\t\tprintf(\"0,0x%x\", xflag);\n\t\t\telse\n\t\t\t\tprintf(\"0,0\");\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(0, &z);\n\t\t\tiput(0, &z);\n\t\t\t}\n\t\tif (guikeywds)\n\t\t\tiput(kw1->agroup, &z);\n\t\tif ((n = kwm->kwkno)) {\n\t\t\tzbclear(&z);\n\t\t\tprintf(xflag ? \",(KeyWord*)kw_%d\": \",kw_%d\", n);\n\t\t\t}\n\t\telse\n\t\t\tiput(0, &z);\n\t\tnput(kwp->lb, &z);\n\t\tnput(kwp->ub, &z);\n\t\tffmt = /*{{{*/ !xflag ? \"}%s\" : \"}}%s\";\n\t\tif (guikeywds) {\n\t\t\tnput(kwm->init, &z);\n\t\t\tsput(kwm->cinit, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tif (!(s = kw1->group) && dfltgroup)\n\t\t\t\ts = kw1->tag;\n\t\t\tsput(s, &z);\n\t\t\tif (kwm->len)\n\t\t\t\tsput(kwm->len, &z);\n\t\t\tif (kwm->dylib)\n\t\t\t\tsput(kwm->dylib, &z);\n\t\t\tgoto nofuncs;\n\t\t\t}\n\t\tiput(kw1->paoff, &z);\n\t\tif (skipfuncs && !kwp->dylib)\n\t\t\tgoto nofuncs;\n\t\tz.nnz = 0;\n\t\tfuncs = 0;\n\t\tif (kwp->dylib) {\n\t\t\tz.cs = CS_Clbra;\n\t\t\tfor(n = 0; n < 3; ++n)\n\t\t\t\tiput(0,&z);\n\t\t\tzbclear(&z);\n\t\t\tprintf(\",(void*)\\\"%s\\\"\", kwp->dylib);\n\t\t\tz.cs = CS_rbr2C;\n\t\t\tz.nnz = 0;\n\t\t\t}\n\t\telse if ((S = kwp->funcs)) {\n\t\t\tif (!S->next && !strcmp(S->val,\"0\"))\n\t\t\t\tgoto xcheck;\n\t\t\tif (!kwp->kw && S->needrev)\n\t\t\t\tS = reverse(&kwp->funcs);\n\t\t\tfuncs = func_cat(&fc, S);\n\t\t\tgoto funcput;\n\t\t\t}\n\t\telse if ((S = kwm->funcs)) {\n\t\t\tfuncs = func_cat(&fc, S);\n funcput:\n\t\t\tz.cs = CS_lrbrC;\n\t\t\tif (funcs && wantfuncs & 1) {\n\t\t\t\tzbclear(&z);\n\t\t\t\tprintf(\",%s\", funcs);\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tiput(0,&z);\n\t\t\t}\n\t\telse if (kwm->names && wantfuncs & 1 && !(kwm->kind & KWKind_Libname)) {\n\t\t\t++missing;\n\t\t\tprintf(\",/*!!*/\");\n\t\t\tfor(kws = KWStack; ++kws <= kwtop; ) {\n\t\t\t\tif (!(kw2 = *kws)->names)\n\t\t\t\t\tkw2 = kw2->rparent;\n\t\t\t\tprintf(\"%s_\", kw2->names->val);\n\t\t\t\t}\n\t\t\tprintf(\"%s_start\", kwm->names->val);\n\t\t\t}\n xcheck:\n\t\tif (xflag) {\n\t\t\tif (z.nnz) {\n\t\t\t\tz.cs = z.cs == CS_rbraC ? CS_rbr2C : CS_rbraC;\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\t\tz.nnz = 0;\n\t\t\t\t}\n\t\t\telse if (z.cs == CS_rbr2C)\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\telse {\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\tffmt = /*{{*/ \"}}%s\";\n\t\t\t\t}\n\t\t\tz.b = z.buf;\n\t\t\tiput(nam ? nam->seqno : 0, &z);\n\t\t\tiput(kw1->agroup, &z);\n\t\t\tsput(funcs, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tsput(kw1->group, &z);\n\t\t\tsput(kw1->defname, &z);\n\t\t\tsput(kw1->len, &z);\n\t\t\tsput(kw1->init, &z);\n\t\t\tsput(kw1->cinit, &z);\n\t\t\tif (z.nnz)\n\t\t\t\tffmt = /*{*/ \"}%s\";\n\t\t\t}\n nofuncs:\n\t\tprintf(ffmt, i < m1 ? \",\\n\" : \"\\n\");\n\t\t}\n\tif (sentinnel)\n\t\tfputs(\"\\t\\t{\\\"\\\"}\\n\", stdout);\n\tprintf(/*{*/\"\\t\\t}\");\n\tif (x != x0)\n\t\tfree(x);\n\tif (fc.b != fbuf)\n\t\tfree(fc.b);\n\t}\n\n static void\nhashclear(KWctx *kw)\n{\n\tStrList *sl;\n\n\tkw->parstate = Dupchecked;\n\tfor(kw = kw->kw; kw; kw = kw->next)\n\t\tfor(sl = kw->names; sl; sl = sl->next) {\n\t\t\tsl->h.hnext->hprev = sl->h.hprev;\n\t\t\tsl->h.hprev->hnext = sl->h.hnext;\n\t\t\tsl->h.hprev = sl->h.hnext = 0;\n\t\t\t}\n\t}\n\n static void\ndupfound(HashHead *h0, StrList *sl, StrList *sl1)\n{\n\tStrList *sl2, *sl3;\n\n\t++dupnames;\n\tfor(sl2 = sl1; sl2->h.hnext != h0; sl2 = sl3) {\n\t\tsl3 = (StrList*)sl2->h.hnext;\n\t\tif (strcmp(sl->val, sl3->val))\n\t\t\tbreak;\n\t\t}\n\tfprintf(stderr, \"Warning: \\\"%s\\\" on line %d also appears on line%s %d\",\n\t\tsl->val, sl->Lineno, \"s\" + (sl2 == sl1), sl1->Lineno);\n\twhile(sl1 != sl2) {\n\t\tsl1 = (StrList*)sl1->h.hnext;\n\t\tfprintf(stderr, \", %d\", sl1->Lineno);\n\t\t}\n\tfputs(\".\\n\", stderr);\n\t}\n\n static KWctx **\nhashadd(KWctx *kw, KWctx **kwtop)\n{\n\tHashHead *h, *h0;\n\tKWctx *kw1;\n\tStrList *sl, *sl1;\n\tchar *s;\n\tint n;\n\tunsigned int c, x;\n\n\tkw->parstate = Dupchecking;\n\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\tfor(sl = kw1->names; sl; sl = sl->next) {\n\t\t\tx = 0;\n\t\t\ts = sl->val;\n\t\t\twhile((c = *(unsigned char*)s++))\n\t\t\t\tx = 43*x + c - ' ';\n\t\t\th0 = &HTab[x % HTlen];\n\t\t\tfor(h = h0->hnext; h != h0; h = h->hnext) {\n\t\t\t\tsl1 = (StrList*)h;\n\t\t\t\tn = strcmp(sl->val, sl1->val);\n\t\t\t\tif (n <= 0) {\n\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\tdupfound(h0,sl,sl1);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsl->h.hnext = h;\n\t\t\th->hprev = (sl->h.hprev = h->hprev)->hnext = (HashHead *)sl;\n\t\t\t}\n\tif ((kw1 = kw->kw))\n\t\t*++kwtop = kw1;\n\treturn kwtop;\n\t}\n\n static void\ndup_check(void)\n{\n\tHashHead *h, *he;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tfor(h = HTab, he = h + HTlen; h < he; ++h)\n\t\th->hnext = h->hprev = h;\n\tplist = 0;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;) {\n\t\tkw = *kwtop;\n\t\tlev = kw->level;\n\t\twhile(plist && plist->level >= lev) {\n\t\t\thashclear(plist);\n\t\t\tplist = plist->next;\n\t\t\t}\n\t\tif (kw->parstate == Dupchecking) {\n\t\t\thashclear(kw);\n\t\t\tif ((*kwtop = kw->next))\n\t\t\t\tcontinue;\n\t\t\tif (kwtop <= kwbot)\n\t\t\t\tbreak;\n\t\t\t--kwtop;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif ((kw1 = kw->pparent) && kw1->parstate != Dupchecking) {\n\t\t\tfor(kw2 = kw1; plist && kw2; plist = plist->next) {\n\t\t\t\twhile(kw2->level > plist->level && (kw2 = kw2->pparent));\n\t\t\t\tif (kw2 != plist)\n\t\t\t\t\tbreak;\n\t\t\t\thashclear(plist);\n\t\t\t\t}\n\t\t\tkw2 = 0;\n\t\t\tdo {\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tkw1->next = kw2;\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Dupchecking);\n\t\t\twhile(kw2) {\n\t\t\t\tkwtop = hashadd(kw2, kwtop);\n\t\t\t\tkw1 = kw2;\n\t\t\t\tkw2 = kw2->next;\n\t\t\t\tkw1->next = plist;\n\t\t\t\tplist = kw1;\n\t\t\t\t}\n\t\t\t}\n\t\tkwtop = hashadd(kw, kwtop);\n\t\t}\n\t}\n\n static void\nprkwname(KWctx *kw, const char *suf, int needrev)\n{\n\tint k;\n\tStrList *S;\n\tstatic const char *kname[] = { \"BUG\", \"INTEGER\", \"REAL\", \"STRING\" };\n\n\tif (needrev)\n\t\treverse(&kw->names);\n\tS = kw->names;\n\tprintf(\"%s\", S->val);\n\twhile((S = S->next))\n\t\tprintf(\" ALIAS %s\", S->val);\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tprintf(\" %s\", kname[k]);\n\t\tif (kw->kind & KWKind_List)\n\t\t\tprintf(\"LIST\");\n\t\t}\n\tif (kw->lb)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictLb ? \">\" : \">=\", kw->lb);\n\tif (kw->ub)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictUb ? \"<\" : \"<=\", kw->ub);\n\tif (kw->defname && wantfuncs & 1) {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s %s\", kw->defname, kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := %s \\\"%s\\\"\", kw->defname, kw->cinit);\n\t\t}\n\telse {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s\", kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := \\\"%s\\\"\", kw->cinit);\n\t\t}\n\tif (!(wantfuncs&1))\n\t\tgoto sufchk;\n\tif (kw->tag)\n\t\tprintf(ignoretags ? \" TAG \\\"%s\\\"\" : \" /*TAG \\\"%s\\\"*/\", kw->tag);\n\tif (kw->funcs) {\n\t\tfputs(\" {\", stdout);\n\t\treverse(&kw->funcs);\n\t\tfor(S = kw->funcs;;) {\n\t\t\tfputs(S->val, stdout);\n\t\t\tif (!(S = S->next))\n\t\t\t\tbreak;\n\t\t\tputchar(',');\n\t\t\t}\n\t\tputchar('}');\n\t\t}\n\tif (kw->len)\n\t\tprintf(\" LEN %s\", kw->len);\n\tif (kw->group)\n\t\tprintf(\" GROUP \\\"%s\\\"\", kw->group);\n\tif (kw->desc)\n\t\tprintf(\" DESC \\\"%s\\\"\", kw->desc);\n sufchk:\n\tif (kw->dylib)\n\t\tprintf(\" DYNLIB \\\"%s\\\"\", kw->dylib);\n\tif (suf)\n\t\tfputs(suf, stdout);\n\tif (needrev == 2)\n\t\treverse(&kw->names);\n\t}\n\n static KWctx *\nkwrev(KWctx **pkw)\n{\n\tKWctx *kw, *kw0, *kw1;\n\tkw1 = *pkw;\n\tfor(kw0 = 0; (kw = kw1); kw0 = kw) {\n\t\tkw1 = kw->next;\n\t\tkw->next = kw0;\n\t\t}\n\treturn *pkw = kw0;\n\t}\n\n static int\nStrListcmp(StrList *sl1, StrList *sl2)\n{\n\tif (sl1 == sl2)\n\t\treturn 0;\n\twhile(sl1) {\n\t\tif (!sl2 || strcmp(sl1->val, sl2->val))\n\t\t\treturn 1;\n\t\tsl1 = sl1->next;\n\t\tsl2 = sl2->next;\n\t\t}\n\treturn sl2 != 0;\n\t}\n\n#if 0\t/* Could hash keywords and use the following samekw to find duplicate  */\n\t/* contained keywords, noting duplicates when found in a new, normally */\n\t/* NULL pointer in KWctx, but so far this does not appear worthwhile.  */\n#define OffsetOf(T,f) ((char*)&((T*)0)->f - (char*)0)\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n#define ValueOf(T,x,o) (*(T*)((char*)x + o))\n\n static int\nsamekw(KWctx *kw1, KWctx *kw2)\n{\n\tchar *s1, *s2;\n\tsize_t *sp, *spe;\n\n\tstatic size_t\n\t\tIntoff[] = {\n\t\t\tOffsetOf(KWctx,alt),\n\t\t\tOffsetOf(KWctx,kind),\n\t\t\tOffsetOf(KWctx,nalt),\n\t\t\tOffsetOf(KWctx,nkw),\n\t\t\tOffsetOf(KWctx,nreq),\n\t\t\tOffsetOf(KWctx,req)\n\t\t\t},\n\t\tStroff[] = {\n\t\t\tOffsetOf(KWctx,lb),\n\t\t\tOffsetOf(KWctx,ub),\n\t\t\tOffsetOf(KWctx,init),\n\t\t\tOffsetOf(KWctx,cinit),\n\t\t\tOffsetOf(KWctx,defname),\n\t\t\tOffsetOf(KWctx,desc),\n\t\t\tOffsetOf(KWctx,dylib),\n\t\t\tOffsetOf(KWctx,group),\n\t\t\tOffsetOf(KWctx,len)\n\t\t\t};\n\twhile(kw1) {\n\t\tif (!kw2)\n\t\t\treturn 0;\n\t\tif (kw1->pparent != kw2->pparent\n\t\t || kw1->rparent != kw2->rparent)\n\t\t\treturn 0;\n\t\tif (StrListcmp(kw1->names, kw2->names)\n\t\t || StrListcmp(kw1->funcs, kw2->funcs))\n\t\t\treturn 0;\n\t\tfor(sp = Intoff, spe = sp + NumberOf(Intoff); sp < spe; ++sp)\n\t\t\tif (ValueOf(int,kw1,*sp) != ValueOf(int,kw2,*sp))\n\t\t\t\treturn 0;\n\t\tfor(sp = Stroff, spe = sp + NumberOf(Stroff); sp < spe; ++sp) {\n\t\t\ts1 = ValueOf(char*,kw1,*sp);\n\t\t\ts2 = ValueOf(char*,kw2,*sp);\n\t\t\tif (s1 != s2 && (!s1 || !s2 || strcmp(s1,s2)))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tkw1 = kw1->next;\n\t\tkw2 = kw2->next;\n\t\t}\n\treturn kw2 == 0;\n\t}\n#undef ValueOf\n#undef NumberOf\n#undef OffsetOf\n#endif\n\n static void\nparadj(int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, **kwp, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (needrev)\n\t\tkwrev(kwtop);\n\n\t/* remove extra parens */\n\n\tfor(;; --kwtop) {\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n top:\n\t\t\tif (needrev && (kw1 = kw->kw) && kw1->next)\n\t\t\t\tkwrev(&kw->kw);\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Parchecked) {\n\t\t\t\tkwp = &kw->pparent;\n\t\t\t\tplist = kw;\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif (kw1->kw) {\n\t\t\t\t\t\t*kwtop++ = kw1;\n\t\t\t\t\t\tkw1->parstate = Parchecked;\n\t\t\t\t\t\t*kwp = kw1;\n\t\t\t\t\t\tkwp = &kw1->pparent;\n\t\t\t\t\t\tkw1->next = plist;\n\t\t\t\t\t\tplist = kw1;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!(*kwp = kw1->pparent)) {\n\t\t\t\t\t\tlev = kw1->level;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw1 = *kwp;\n\t\t\t\t\tif (kw1->parstate == Parchecked) {\n\t\t\t\t\t\tlev = kw1->level + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tfor(;; plist = kw1) {\n\t\t\t\t\tplist->level = lev++;\n\t\t\t\t\tif (plist == kw)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tkw1 = plist->next;\n\t\t\t\t\tplist->next = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = kw->kw;\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static KWctx *\nmasteradj(KWctx *kw)\n{\n\t/* to help print (nm1 | nm2 foo goo), make nm2 \"master\" */\n\tKWctx *kw1, *kw2, *kw3, *kwm, *rv;\n\n\tfor(kw1 = kw, kw3 = 0; kw1; kw1 = kw1->next) {\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn kw;\n\tfor(rv = kw; kw; kw = kw->next) {\n\t\tkwm = kw->master;\n\t\tif ((kw1 = kw->next) && kw1->master == kwm && kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in masteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->next) && kw1->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tkw = kw2;\n\t\t\t}\n\t\t}\n\treturn rv;\n\t}\n\n static void\nxmasteradj(KWctx **x, int n)\n{\n\t/* variant of masteradj for pretty_ex1 */\n\tKWctx *kw, *kw1, *kw2, *kw3, *kwm;\n\tint i, j;\n\n\tfor(i = 0, kw3 = 0; i < n; ++i) {\n\t\tkw1 = x[i];\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn;\n\tfor(i = 0; i < n; i = j) {\n\t\tj = i + 1;\n\t\tkw = x[i];\n\t\tkwm = kw->master;\n\t\tif (j < n && kwm && (kw1 = x[j])->master == kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in xmasteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(++j < n && (kw1 = x[j])->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = x[++i]) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;; kw = x[++i]) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n static void\ndo_indent(int indent)\n{\n\tfor(indent += 8; indent >= 8; indent -= 8)\n\t\tputchar('\\t');\n\tfor(; indent > 0; --indent)\n\t\tputchar(' ');\n\t}\n\n static void\ndo_indent1(int indent)\t/* write indent-1 spaces */\n{\n\twhile(--indent > 0)\n\t\tputchar(' ');\n\t}\n\n static const char *KEYKIND[4] = { \"KEYWORD \", \"KEYWORD01 \", \"KEYWORD1 \", \"KEYWORD12 \" };\n\n static void\npretty_print(int iinc, int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, *kw3, **kwtop, **kwbot, *plist;\n\tconst char *s;\n\tint alt, indent, lev, needindent, needspace;\n\n\tkwtop = kwbot = KWStack;\n\tindent = 0;\n\tplist = 0;\n\tneedindent = 1;\n\tfor(kw1 = KWbase.kw; kw1;) {\n\t\tfputs(KEYKIND[(kw1->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw1, \"\\n\", needrev);\n\t\t*kwtop = masteradj(kw1->kw);\n\t\talt = 0;\n\t\tfor(;;--kwtop) {\n\t top:\n\t\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\t\tlev = kw->level;\n\t\t\t\tif (needindent) {\n\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\tneedindent = 0;\n\t\t\t\t\t}\n\t\t\t\tif (plist\n\t\t\t\t && (plist->level > lev\n\t\t\t\t  || (plist->level == lev && plist != kw->pparent))) {\n finishpar:\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = plist;\n\t\t\t\t\t*++kwtop = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Printing) {\n\t\t\t\t\ts = !kw->names || /*[(*/kw->req ? \")\\n\" : \"]\\n\";\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\ts = /*(*/ \")\\n\";\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tfputs(s, stdout);\n\t\t\t\t\tneedindent = 1;\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tindent -= iinc;\n\t\t\t\t\tif (!kw->names) {\n\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\tgoto bot;\n\t\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (plist)\n\t\t\t\t\tfor (kw2 = kw->pparent;\n\t\t\t\t\t\t\tkw2 && kw2->parstate != Printing;\n\t\t\t\t\t\t\tkw2 = kw2->pparent) {\n\t\t\t\t\t\tif (plist->level >= kw2->level)\n\t\t\t\t\t\t\tgoto finishpar;\n\t\t\t\t\t\t}\n\t\t\t\tneedindent = 1;\n\t\t\t\tneedspace = 0;\n\t\t\t\tif (alt == kw->alt) {\n\t\t\t\t\tputchar('|');\n\t\t\t\t\tneedspace = 1;\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->pparent) && kw2->parstate != Printing) {\n\t\t\t\t\tkw3 = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (kw2->parstate == Printing)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (kw2->kw) {\n\t\t\t\t\t\t\tkw2->next = kw3;\n\t\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t\tkw2->parstate = Printing;\n\t\t\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\t\t\tneedspace = 0;\n\t\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t\tputchar('('); /*)*/\n\t\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((kw2 = kw2->pparent));\n\t\t\t\t\twhile(kw3) {\n\t\t\t\t\t\tkw2 = kw3->next;\n\t\t\t\t\t\tkw3->next = plist;\n\t\t\t\t\t\tplist = kw3;\n\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->master) && kw == kw2)\n\t\t\t\t\tkw2 = 0;\n\t\t\t\tif (!kw->kw && (!kw2 || kw2->parstate == Leftput)) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t\tif (!kw->req) {\n\t\t\t\t\t\tif (alt != kw->alt) {\n\t\t\t\t\t\t\tfputs(\"[ \", stdout);\n\t\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\ts = /*[*/ \" ]\\n\";\n\t\t\t\t\t\tif ((kw2 = kw->next) && kw2->alt == alt)\n\t\t\t\t\t\t\ts = \"\\n\";\n\t\t\t\t\t\tprkwname(kw, s, needrev);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Leftput) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tgoto putspace;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\tputchar(kw->req ? '(' : '['); /*])*/\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\tputchar('('/*)*/);\n\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tindent += iinc;\n putspace:\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t}\n\t\t\t\tkw->parstate = Printing;\n\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\tif (kw2) {\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tkw2->parstate = Leftput;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\talt = 0;\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = masteradj(kw->kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n bot:\n\t\t\tif (kwtop == kwbot) {\n\t\t\t\tif (plist) {\n\t\t\t\t\t*kwtop++ = plist;\n\t\t\t\t\t*kwtop++ = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (indent) {\n\t\t\t\t\t\tif (needindent)\n\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\tfputs(/*(*/\")\\n\", stdout);\n\t\t\t\t\t\tneedindent = 1;\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (!(kw1 = kw1->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static void\nnslist(StrList *h, const char *fmt)\n{\n\tfor(; h; h = h->next)\n\t\tprintf(fmt, h->val);\n\t}\n\n static void\nOutput(StrList *headers, StrList *nsname, int hwant, const char *kname, int libmode, int nwant)\n{\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tStrList *h;\n\tUint xflag;\n\tconst char *fmt;\n\tint kwkno;\n\tstatic char\n\t\tlibfmt1[] = \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n\"\n\t\t\t\"KeyWord *keyword_add(void);\\n}\\n#endif\\n\\n\"\n\t\t\t\" KeyWord*\\nkeyword_add(void) {\\n\\t\",\n\t\tlibfmt2[] = \"kw_%d[0].kw;\\n\\t}\\n\",\n\t\tlibfmt3[] = /*{*/ \"kw_%d.kw;\\n\\t}\\n\";\n\n\tif (hwant && headers) {\n\t\tfor(h = reverse(&headers); h; h = h->next)\n\t\t\tprintf(*h->val == '<' /*>*/\n\t\t\t\t? \"#include %s\\n\"\n\t\t\t\t: \"#include \\\"%s\\\"\\n\", h->val);\n\t\t}\n\tif (nwant) {\n\t\tif (nsname)\n\t\t\treverse(&nsname);\n\t\telse\n\t\t\tnsname = new_StrList(\"Dakota\", nsname);\n\t\tputchar('\\n');\n\t\tnslist(nsname, \"namespace %s {\\n\" /*}*/);\n\t\t}\n\t/* BMA (20160923): Suppress keyword count summary to avoid merge conflicts */\n\t//printf(\"\\n/** %d distinct keywords (plus %d aliases) **/\\n\", lastagroup, nalias);\n\tprintf(\"\\nstatic %sKeyWord%s\\n\", guikeywds ? \"Gui\" : \"\", libmode ? \"x\" : \"\");\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (libmode) {\n\t\txflag = KWKind_Extended;\n\t\tComma = Commasx;\n\t\t}\n\telse {\n\t\txflag = 0;\n\t\tComma = Commas0;\n\t\t}\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwout(kw, kwtop, xflag);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tprintf(\";\\n\\n\");\n\tif (nwant) {\n\t\tnslist(reverse(&nsname), /*{*/\"} // namespace %s\\n\");\n\t\tputchar('\\n');\n\t\treverse(&nsname);\n\t\t}\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"extern \\\"C\\\" {\\n\");\n\tprintf(\"#endif\\n\");\n\n\tkwkno = KWbase.kwkno;\n\tif (libmode) {\n\t\tif (KWbase.nkw > 1 && !kname)\n\t\t\tkname = \"KeywordTop\";\n\t\tprintf(libfmt1);\n\t\tfmt = libfmt2;\n\t\tif (kname) {\n\t\t\tprintf(\"static KeyWordx kw_%d = { \\\"%s\\\", 0x%x,%d,%d,%d,(KeyWord*)\",\n\t\t\t\tkwkno + 1, kname, KWKind_Dynmult, KWbase.nkw,\n\t\t\t\tKWbase.alt, KWbase.req);\n\t\t\tif (nwant) {\n\t\t\t\tnslist(nsname, \"%s::\");\n\t\t\t\tnwant = 0;\n\t\t\t\t}\n\t\t\tprintf(\"kw_%d };\\n\\t\", kwkno++);\n\t\t\tfmt = libfmt3;\n\t\t\t}\n\t\tprintf(\"return &\");\n\t\t}\n\telse {\n\t\tprintf(\"KeyWord Dakota_Keyword_Top = {\\\"KeywordTop\\\",0,%d,%d,%d,\",\n\t\t\tKWbase.nkw, KWbase.alt, KWbase.req);\n\t\tfmt = \"kw_%d};\\n\";\n\t\t}\n\tif (nwant)\n\t\tnslist(nsname, \"%s::\");\n\tprintf(fmt, kwkno);\n\n        printf(\"#ifdef __cplusplus\\n\");\n        printf(\"}\\n\");\n        printf(\"#endif\\n\");\n\n\tif (startwarn && missing && !guikeywds)\n\t\tfprintf(stderr, \"%s: %d start routines implicitly named.\\n\",\n\t\t\tprogname, missing);\n\t}\n\n typedef struct Valhash Valhash;\n\n struct\nValhash {\n\tDefhashHead hh;\n\tUint n;\n\tValhash *thread;\n\t};\n\n static Kwpack *kwpack, *kwpack0, *kwpacke;\n static size_t kwpack_len, strtab_len = 1;\n static DefhashTab FpTab, StrTab;\n static Valhash *FpTabLast, *StrTabLast;\n\n static Uint\nNumOff(char *name)\n{\n\tValhash *v;\n\tif (!name || !*name || (*name == '0' && !name[1]))\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &FpTab, 1);\n\tif (!v->n) {\n\t\tv->n = FpTab.nent;\n\t\tv->thread = FpTabLast;\n\t\tFpTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static Uint\nStrOff(char *name)\n{\n\tValhash *v;\n\tif (!name)\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &StrTab, 1);\n\tif (!v->n) {\n\t\tv->n = strtab_len;\n\t\tstrtab_len += strlen(name) + 1;\n\t\tv->thread = StrTabLast;\n\t\tStrTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static void\nkwjout(KWctx *kw, KWctx **kwtop)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, **x, *x0[KWOUTlen0];\n\tKwpack *p;\n\tUint lastknoj;\n\tint i, m, n;\n\tsize_t L;\n\n\tkw1 = kw->kw;\n\tn = 0;\n\tlastknoj = kwpack - kwpack0 + 1;\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastknoj;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastknoj;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwjout\");\n\tm = 0;\n\tfor(kw0 = kw1; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tkw->kwkno = lastknoj;\n\t++lastkno;\n\tfor(i = 0; i < m;) {\n\t\tif (++kwpack >= kwpacke) {\n\t\t\tL = 2*kwpack_len;\n\t\t\tkwpack0 = (Kwpack*)Realloc(kwpack0, L*sizeof(Kwpack), \"kwjout\");\n\t\t\tkwpacke = kwpack0 + L;\n\t\t\tkwpack = kwpack0 + kwpack_len;\n\t\t\tmemset(kwpack, 0, kwpack_len*sizeof(Kwpack));\n\t\t\tkwpack_len = L;\n\t\t\t}\n\t\tp = kwpack;\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tp->nkw = kwm->nkw;\n\t\tif (kw1->names) {\n\t\t\tp->name = StrOff(kw1->names->val);\n\t\t\tp->kind = kw1->kind | kw1->names->primary;\n\t\t\tp->alt = kwm->alt + kwm->altoffset;\n\t\t\tif (kwm->req)\n\t\t\t\tp->req = kwm->req + kwm->reqoffset;\n\t\t\tif (kwm->dylib) {\n\t\t\t\tp->dylib = StrOff(kwm->dylib);\n\t\t\t\tp->kind |= KWKind_Dynlib;\n\t\t\t\t}\n\t\t\t}\n\t\tp->kw = kwm->kwkno;\n\t\tp->Lb = NumOff(kw1->lb);\n\t\tp->Ub = NumOff(kw1->ub);\n\t\tp->poff = kw1->paoff;\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static Valhash *\nVreverse(Valhash *sh)\n{\n\tValhash *sh0, *sh1;\n\tfor(sh0 = 0; sh; sh = sh1) {\n\t\tsh1 = sh->thread;\n\t\tsh->thread = sh0;\n\t\tsh0 = sh;\n\t\t}\n\treturn sh0;\n\t}\n\n static void\nkwpack_adjust(Kwpack *kp, Uint nkw)\n{\n\tKwpack0 *qp, *qpe;\n\n\tqp = (Kwpack0*)kp;\n\tfor(qpe = qp + nkw; qp < qpe; ++kp, ++qp) {\n\t\tmemcpy(qp, kp, sizeof(Kwpack0) - sizeof(int));\n\t\tqp->poff = kp->poff;\n\t\t}\n\t}\n\n static void\njOutput(char *jfname)\n{\n\tFILE *f;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tKwpack *kp;\n\tUint nkw0;\n\tValhash *vh;\n\tdouble d;\n\tsize_t L, Lkw, Ls;\n\tstatic KwpHead head = { \"DakreorderKwds\\n\", 1e13, 0x1234abcd };\n\tstatic double zbuf[2];\n\n\tFpTab.nalloc  = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tStrTab.nalloc = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tkwpack_len = 128;\n\tkwpack = kwpack0 = (Kwpack*)Malloc(kwpack_len * sizeof(Kwpack), \"jOutput\");\n\tmemset(kwpack, 0, kwpack_len * sizeof(Kwpack));\n\tkwpacke = kwpack0 + kwpack_len;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwjout(kw, kwtop);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tStrTabLast = Vreverse(StrTabLast);\n\tFpTabLast = Vreverse(FpTabLast);\n\tnkw0 = kwpack - kwpack0;\n\thead.nkw = nkw0 + 1;\n\tkp = kwpack0;\n\tkp->kw = nkw0 - KWbase.nkw + 1;\n\tkp->nkw = KWbase.nkw;\n\tkp->alt = KWbase.alt;\n\tkp->req = KWbase.req;\n\thead.strtab_offset = (FpTab.nent+1)*sizeof(double);\n\tLs = (strtab_len + 7) & ~7;\n\thead.kw_offset = head.strtab_offset + Ls;\n\tif ((head.pad = dynlibseen))\n\t\tLkw = sizeof(Kwpack);\n\telse {\n\t\tLkw = sizeof(Kwpack0);\n\t\tkwpack_adjust(kp, head.nkw);\n\t\t}\n\thead.end_offset = head.kw_offset + head.nkw * Lkw;\n\tf = fopen(jfname, \"wb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open \\\"%s\\\"\\n\", jfname);\n\t\texit(1);\n\t\t}\n\tfwrite(&head, sizeof(head), 1, f);\n\tfor(vh = FpTabLast; vh; vh = vh->thread) {\n\t\td = strtod(vh->hh.name,0);\n\t\tfwrite(&d, sizeof(double), 1, f);\n\t\t}\n\tfwrite(&zbuf,9,1,f);\n\tfor(vh = StrTabLast; vh; vh = vh->thread)\n\t\tfwrite(vh->hh.name, strlen(vh->hh.name) + 1, 1, f);\n\tif ((L = Ls - strtab_len))\n\t\tfwrite(&zbuf, L, 1, f);\t/* align */\n\tfwrite(kp, Lkw, head.nkw, f);\n\tfclose(f);\n\t}\n\n typedef int (*KWcomp)(const void*, const void*);\n\n static const char **zalt;\n\n static int\nkwcomp1(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static int\nkwcomp2(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb, *pa, *pb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tpa = ka->master ? ka->master->pparent : ka->pparent;\n\t\tpb = kb->master ? kb->master->pparent : kb->pparent;\n\t\tif (pa != pb)\n\t\t\treturn ka->objno - kb->objno;\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static void\ndo_sort(KWctx *kw, KWcomp KWcmp)\n{\n\tKWctx *kw1, *kwm, **x, *x0[KWPlen];\n\tconst char *z0[KWPlen];\n\tint i, n, na;\n\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\t++n;\n\t\treverse(&kw1->names);\n\t\t}\n\tif (n <= 1)\n\t\treturn;\n\tx = n > KWPlen ? (KWctx**)Malloc(n*sizeof(KWctx*), \"do_sort\") : x0;\n\tna = kw->nalt + 1;\n\tzalt = na <= KWPlen ? z0 : (const char**)Malloc(na*sizeof(const char*), \"do_sort\");\n\tmemset(zalt, 0, na*sizeof(const char*));\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\tx[n++] = kw1;\n\t\tif ((kwm = kw1->master))\n\t\t\tkwm->master = kwm;\n\t\tif (!zalt[i = kw1->alt]\n\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\tzalt[i] = kw1->names->val;\n\t\t}\n\tqsort(x, n--, sizeof(KWctx*), KWcmp);\n\tfor(i = 0; i < n; ++i)\n\t\tx[i]->next = x[i+1];\n\tx[n]->next = 0;\n\tkw->kw = x[0];\n\tif (zalt != z0)\n\t\tfree(zalt);\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nksort(KWcomp KWcmp)\n{\n\tKWctx *kw, *kw1, **kwtop, **kwtop0, **kwbot;\n\n\tkwtop = kwbot = KWStack;\n\n\tfor(*kwtop = &KWbase;; --kwtop) {\n top:\n\t\tkw = *kwtop;\n top1:\n\t\twhile(kw) {\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Sorted) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\tkwtop0 = kwtop;\n\t\t\t\tdo {\n\t\t\t\t\tkw1->parstate = Sorted;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t}\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Sorted);\n\t\t\t\tif (kwtop > kwtop0)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tdo_sort(kw, KWcmp);\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = *kwtop = kw->kw;\n\t\t\t\tgoto top1;\n\t\t\t\t}\n\t\t\tkw = kw->next;\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static void\npretty_ex1(KWctx *kw, KWctx *prevkw, KWctx *nextkw, int indent, int iinc, int needrev)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, *kwp0, **x, *y, *y1;\n\tconst char *suf, *z0[KWPlen];\n\tint ep, i, i0, ia, j, n, na, np;\n\n\tn = 0;\n\tx = 0;\n\ty = 0;\n\tkw1 = kw->kw;\n\tif (needrev == 1)\n\t\tneedrev = 2;\n\tif ((kwp0 = kwp = kw->pparent) && (!kw->master || kw->master == kw)) {\n\t\tfor(;;) {\n\t\t\tif (kwp->parstate != Printing) {\n\t\t\t\tkwp->parstate = Printing;\n\t\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t\tkw1->pparent = 0;\t/* avoid infinite loops */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t++n;\n\t\t\tif (!(kw1 = kwp->pparent))\n\t\t\t\tbreak;\n\t\t\tkwp = kwp->pparent = kw1;\n\t\t\t}\n\t\tnp = n;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\t++n;\n\t\ty = y1 = (KWctx*)Malloc(np*sizeof(KWctx) + n*sizeof(KWctx*), \"pretty_ex1\");\n\t\tx = (KWctx**)(y + np);\n\t\tfor(i = 0, kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\tx[i++] = kw1;\n\t\ti0 = i;\n\t\tfor(kwp = kwp0; kwp; kwp = kwp->pparent) {\n\t\t\tj = i;\n\t\t\tna = i + kwp->nalt;\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next, ++y1) {\n\t\t\t\tmemcpy(y1, kw1, sizeof(KWctx));\n\t\t\t\tx[i++] = y1;\n\t\t\t\ty1->alt += j;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!needrev) {\n\t\t\tfor(j = i0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t}\n\t\t\tzalt = ++na <= KWPlen ? z0\n\t\t\t\t: (const char**)Malloc(na*sizeof(const char*), \"pretty_ex1\");\n\t\t\tmemset(zalt, 0, na*sizeof(const char*));\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif ((kwm = kw1->master))\n\t\t\t\t\tkwm->master = kwm;\n\t\t\t\tif (!zalt[i = kw1->alt]\n\t\t\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\t\t\tzalt[i] = kw1->names->val;\n\t\t\t\t}\n\t\t\tqsort(x, n, sizeof(KWctx*), kwcomp1);\n\t\t\tif (zalt != z0)\n\t\t\t\tfree(zalt);\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif (kw1->nreq < 0) {\n\t\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t\tkw1->pparent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tkw1 = x[0];\n\t\txmasteradj(x, n);\n\t\t}\n\tif (kw1) {\n\t\tif (!x)\n\t\t\tkw1 = masteradj(kw->kw);\n\t\tep = kw->req;\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tia = kw->master && kw->master == prevkw->master ? iinc : 0;\n\t\t\tdo_indent(indent + ia);\n\t\t\tif (!prevkw->master || prevkw->master != kw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent + ia);\n\t\t\t\tputchar('(');\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tputchar('|');\n\t\t\t}\n\t\telse {\n\t\t\tdo_indent(indent);\n\t\t\tif (kw->req)\n\t\t\t\tputchar('('/*)*/);\n\t\t\telse {\n\t\t\t\tputchar('[');\n\t\t\t\tif (nextkw && !nextkw->req && kw->alt == nextkw->alt) {\n\t\t\t\t\tep = 1;\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\tputchar('(');\n\t\t\t\t\tindent += iinc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdo_indent1(iinc);\n\t\tindent += iinc;\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\ti = 0;\n\t\tkw0 = 0;\n\t\twhile(kw1) {\n\t\t\tif (x)\n\t\t\t\tkw2 = ++i >= n ? 0 : x[i];\n\t\t\telse\n\t\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, indent, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\tkw1 = kw2;\n\t\t\t}\n\t\tif (x)\n\t\t\tfree(y);\n\t\tdo_indent(indent);\n\t\tfputs(ep ? \")\\n\" : \"]\\n\", stdout);\n\t\t}\n\telse {\n\t\tif (prevkw && kw->alt == prevkw->alt\n\t\t && kw->master && kw->master == prevkw->master)\n\t\t\tindent += iinc;\n\t\tdo_indent(indent);\n\t\tsuf = \"\\n\";\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tif (kw->master && kw->master != prevkw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent);\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfputs(\"| \", stdout);\n\t\t\t\tif (!kw->req)\n\t\t\t\t\tgoto rbcheck;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (kw->req) {\n\t\t\tif (prevkw) {\n\t\t\t\tif (prevkw->master != kw->master)\n\t\t\t\t\tgoto putlpar;\n\t\t\t\t}\n\t\t\telse if (kw != kw->master && kw->master) {\n putlpar:\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tfputs(\"[ \", stdout);\n rbcheck:\n\t\t\tif (!nextkw || nextkw->alt != kw->alt)\n\t\t\t\tsuf = \" ]\\n\";\n\t\t\t}\n\t\tprkwname(kw, suf, needrev);\n\t\t}\n\t}\n\n static void\npretty_expand(int iinc, int needrev)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2;\n\n\tif ((kw = KWbase.kw)) for(;;) {\n\t\tmasteradj(kw->kw);\n\t\tfputs(KEYKIND[(kw->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\tkw0 = 0;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw2) {\n\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, 0, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\t}\n\t\tif (!(kw = kw->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static int\nStr_option(char *s, char ***pav, int *want, StrList **ps)\n{\n\tif (*++s || (s = *++*pav)) {\n\t\tif (*s == '-' && ! s[1])\n\t\t\t*want = 0;\n\t\telse\n\t\t\t*ps = new_StrList(s, *ps);\n\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}\n\n static int\nversion(void)\n{\n\tprintf(\"nidrgen version 20100528\\n\");\n\treturn 0;\n\t}\n\n static int\ntagcomp(const void *a, const void *b)\n{\n\treturn strcmp(*(const char**)a, *(const char**)b);\n\t}\n\n static int\nunused_tags()\n{\n\tTaghash *th;\n\tchar **x;\n\tsize_t i, nbad;\n\n\tnbad = 0;\n\tfor(th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\t++nbad;\n\tif (!nbad)\n\t\treturn 0;\n\tx = (char**)Malloc(nbad*sizeof(char*), \"unsed_tags\");\n\tfor(i = 0, th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\tx[i++] = th->hh.name;\n\tfprintf(stderr, \"%lu unused tag definition%s in %s:\\n\",\n\t\t(unsigned long)nbad, \"s\" + (nbad == 1), tagfname);\n\tif (nbad > 1)\n\t\tqsort(x, nbad, sizeof(char*), tagcomp);\n\tfor(i = 0; i < nbad; ++i)\n\t\tfprintf(stderr, \"\\t\\\"%s\\\"\\n\", x[i]);\n\tfree(x);\n\treturn 1;\n\t}\n\n static int\ndefcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const Defhash**)a)->hh.name, (*(const Defhash**)b)->hh.name);\n\t}\n\n static void\nwrite_defs(FILE *f)\n{\n\tDefhash *d, **x, **x1;\n\tDefhashHead *dh;\n\tsize_t i, n;\n\n\tn = DHTab.nent;\n\tx = x1 = (Defhash**)Malloc(n*sizeof(Defhash*), \"write_defs\");\n\tfor(dh = DHTab.lastdh, i = 0; dh; dh = dh->thread) {\n\t\tif (++i > n)\n\t\t\tbotch(\"lastdef count botch\");\n\t\t*x1++ = (Defhash*)dh;\n\t\t}\n\tqsort(x, n, sizeof(Defhash*), defcomp);\n\tfor(i = 0; i < n; ++i) {\n\t\td = x[i];\n\t\tfprintf(f, d->qkeep ? \"#define %s \\\"%s\\\"\\n\"\n\t\t\t: \"#define %s %s\\n\",\n\t\t\td->hh.name, d->value);\n\t\t}\n\t}\n\n int\nmain(int argc, char **argv)\n{\n\tFILE *f;\n\tStrList *headers, *mtagname, *nsname, *outtagname;\n\tchar *defsout, *jfname, *ofname, *s, *se;\n\tconst char *kname, *libex, *libname;\n\tint defwrite, dupcheck, hwant, libmode, needrev, nwant, pprint, sort, x;\n\n\tKWStack[0] = &KWbase;\n\tDHTab.nalloc  = (sizeof(Defhash) + sizeof(void*) - 1)/sizeof(void*);\n\tTagTab.nalloc = (sizeof(Taghash) + sizeof(void*) - 1)/sizeof(void*);\n\tKWbase.names = new_StrList(\"$top\",0);\n\tprogname = argv[0];\n\tif (argc <= 1)\n usage1:\treturn usage(1);\n\theaders = mtagname = nsname = outtagname = 0;\n\tkname = libex = libname = defsout = jfname = ofname = 0;\n\tdupcheck = hwant = needrev = nwant = 1;\n\tdefwrite = libmode = pprint = sort = 0;\n nextopt:\n\twhile((s = *++argv) && *s == '-' && s[1]) {\n\t\twhile(*++s)\n\t\tswitch(*s) {\n\t\t case 'D':\n\t\t\tdefwrite = libexpand = 1;\n\t\t\tlibex = \"-D\";\n\t\t\tbreak;\n\t\t case 'T':\n\t\t\tif (Str_option(s, &argv, &hwant, &outtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'd':\n\t\t\tdupcheck = 0;\n\t\t\tbreak;\n\t\t case 'e':\n\t\t\texpand = 1;\n\t\t\tbreak;\n\t\t case 'f':\n\t\t\twantfuncs = 0;\n\t\t\tbreak;\n\t\t case 'g':\n\t\t\tguikeywds = libexpand = 1;\n\t\t\tlibex = \"-g\";\n\t\t\tbreak;\n\t\t case 'G':\n\t\t\tdfltgroup = 0;\n\t\t\tbreak;\n\t\t case 'h':\n\t\t\tif (Str_option(s, &argv, &hwant, &headers))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'j':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tjfname = s;\n\t\t\tlibexpand = 1;\n\t\t\tlibex = \"-j\";\n\t\t\tgoto nextopt;\n\t\t case 'k':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tkname = s;\n\t\t\tlibmode = 1;\n\t\t\tgoto nextopt;\n\t\t case 'l':\n\t\t\tlibmode = 1;\n\t\t\tbreak;\n\t\t case 'L':\n have_L:\n\t\t\tif (*++s)\n\t\t\t\tlibname = s;\n\t\t\telse if (!(libname = *++argv))\n\t\t\t\treturn usage(1);\n\t\t\tgoto nextopt;\n\t\t case 'm':\n\t\t\tif (Str_option(s, &argv, &hwant, &mtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'n':\n\t\t\tif (Str_option(s, &argv, &nwant, &nsname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 't':\n\t\t\tignoretags = 1;\n\t\t\tbreak;\n\t\t case 's':\n\t\t\tsort = 1;\n\t\t\tneedrev = 0;\n\t\t\tlibex = \"-s\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L': ++s; goto have_L;\n\t\t\t\t  case 'e': expand = 1;\n\t\t\t\t\t    continue;\n\t\t\t\t  case 'f': wantfuncs = 0;\n\t\t\t\t  case 'p': continue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t case 'p':\n\t\t\tlibexpand = 1;\n\t\t\tpprint = 2;\n\t\t\tif (!libex)\n\t\t\t\tlibex = \"-p\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L':\n\t\t\t\t\t++s;\n\t\t\t\t\tgoto have_L;\n\t\t\t\t  case 'e':\n\t\t\t\t\texpand = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 'f':\n\t\t\t\t\twantfuncs = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 's':\n\t\t\t\t\tsort = 1;\n\t\t\t\t\tneedrev = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 't':\n\t\t\t\t\tignoretags = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (*++s) {\n\t\t\t\tpprint = (int)strtol(s,&se,10);\n\t\t\t\tif (pprint < 1 || se)\n\t\t\t\t\tgoto usage1;\n\t\t\t\t}\n\t\t\tgoto nextopt;\n\t\t case 'v':\n\t\t\treturn version();\n\t\t case 'w':\n\t\t\tstartwarn = 0;\n\t\t\tbreak;\n\t\t case '?':\n\t\t\treturn usage(s[1] != 0);\n\t\t case '-':\n\t\t\tif (!strcmp(++s,\"help\"))\n\t\t\t\treturn usage(0);\n\t\t\tif (!strcmp(s,\"version\"))\n\t\t\t\treturn version();\n\t\t\tif (!*s) {\n\t\t\t\ts = *++argv;\n\t\t\t\tgoto argsdone;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t  default:\n\t\t\tgoto usage1;\n\t\t  }\n\t\t}\n argsdone:\n\tif (libname) {\n\t\tif (s && argv[1] && argv[2])\n\t\t\treturn usage(1);\n\t\tif ((defsout = s))\n\t\t\tofname = argv[1];\n\t\tif (mtagname) {\n\t\t\tfprintf(stderr, \"\\n%s: ignoreing -m due to -L\\n\", progname);\n\t\t\tmtagname = 0;\n\t\t\t}\n\t\tgoto lcheck;\n\t\t}\n\tif (!s || (argv[1] && argv[2] && argv[3] && argv[4]))\n\t\treturn usage(1);\n\tif ((tagfname = argv[1])) {\n\t\tspecfile = s;\n\t\ts = tagfname;\n\t\tlastseen = Saw_kwname;\n\t\tlastkw1 = &KWbase;\n\t\tif ((defsout = argv[2]))\n\t\t\tofname = argv[3];\n\t\t}\n\telse if (mtagout) {\n\t\tfprintf(stderr, \"%s: -m specified but no tagfile given.\\n\", progname);\n\t\treturn 1;\n\t\t}\n\tif (*s == '-' && !s[1])\n\t\tyyin = stdin;\n\telse if (!(yyin = fopen(infname = s, \"r\"))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n\tif (specfile)\n\t\ttagin = yyin;\n\tif ((mtagname && (!(mtagout = fopen(s = mtagname->val, \"w\"))))\n\t || (outtagname && !(tagout = fopen(s = outtagname->val, \"w\")))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n lcheck:\n\tif (libmode) {\n\t\twantfuncs |= 2;\n\t\tif (libexpand && kname) {\n\t\t\tlibmode = 0;\n\t\t\tfprintf(stderr, \"\\n%s: ignoring -k due to %s\\n\",\n\t\t\t\tprogname, libex);\n\t\t\t}\n\t\t}\n\telse\n\t\tlibexpand = 0;\n\tif (libname)\n#ifndef NO_NIDR_DYNLIB\n\t\tlibread1(0, libname, 0, 2);\n#else\n\t\t{\n\t\tfprintf(stderr, \"\\ndlopen for \\\"%s\\\" is NOT SUPPORTED\\n\", libname);\n\t\treturn usage(1);\n\t\t}\n#endif\n\telse if ((x = yylex())) {\n\t\tfprintf(stderr, \"\\n%s: Surprise return %d from yylex()\\n\", progname, x);\n\t\treturn x;\n\t\t}\n\tif (mtagout)\n\t\tfclose(mtagout);\n\tif (tagout)\n\t\tfclose(tagout);\n\tif (tagout || mtagout)\n\t\tgoto done;\n\tif (Br_top > Br_stack) {\n\t\tfputs(\"Missing \", stderr);\n\t\tdo putc(/*[*/ *Br_top-- == '(' ? ')' : ']', stderr);\n\t\t\twhile(Br_top >Br_stack);\n\t\tfputs(\" at end of file.\\n\", stderr);\n\t\treturn 1;\n\t\t}\n\tif (nsquawk > liberror)\n\t\treturn 1;\n\tif (tagfname && unused_tags())\n\t\treturn 1;\n\tif (KWbase.kw) {\n\t\tparadj(needrev);\n\t\tif (dupcheck)\n\t\t\tdup_check();\n\t\t}\n\tif (jfname)\n\t\tofname = 0;\n\telse if (ofname && !freopen(ofname, \"w\", stdout)) {\n\t\tfprintf(stderr, \"%s: Cannot open output file \\\"%s\\\"\\n\", progname, ofname);\n\t\treturn 1;\n\t\t}\n\tif (KWbase.kw) {\n\t\tif (pprint) {\n\t\t\tif (expand) {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp1);\n\t\t\t\tpretty_expand(pprint, needrev);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp2);\n\t\t\t\tpretty_print(pprint, needrev);\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!defwrite) {\n\t\t\tif (jfname)\n\t\t\t\tjOutput(jfname);\n\t\t\telse\n\t\t\t\tOutput(headers, nsname, hwant, kname,\n\t\t\t\t\tguikeywds ? 0 : libmode, nwant);\n\t\t\t}\n\t\telse if (DHTab.lastdh)\n\t\t\twrite_defs(stdout);\n\t\t}\n\tif (!defwrite && defsout) {\n\t\tf = fopen(defsout,\"w\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s:  cannot open defs file \\\"%s\\\"\\n\",\n\t\t\t\tprogname, defsout);\n\t\t\treturn 1;\n\t\t\t}\n\t\twrite_defs(f);\n\t\tfclose(f);\n\t\t}\n done:\n\treturn dupnames > 0 ? 1 : liberror ? 2 : 0;\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/nidr.c": "/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n/* nidr.c */\n\n#ifndef NIDR_H\t/* for $DAKOTA/src/nidr.c */\n#include \"nidr.h\"\n#endif\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"avltree.h\"\n\n#ifndef NIDR_SQUAWKMAX\n#define NIDR_SQUAWKMAX 10\n#endif\n\n/* for isatty(), getegid() */\n#if defined(_WIN32) || defined(_WIN64)\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifndef NO_NIDR_DYNLIB /*{*/\ntypedef KeyWord *(*KW_ADD)(void);\nstatic KeyWord *kwfind(const char *, KeyWord *, int, int *);\nstatic KeyWord *toomany(const char *, KeyWord *, int);\n#ifdef _WIN32 /*{{*/\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else /*}{*/\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif /*}}*/\n#endif /*}*/\n\n extern KeyWord Dakota_Keyword_Top;\n extern int nidrLineNumber;\n static KeyWord* Keyword_Top = &Dakota_Keyword_Top;\n static void *KW_g;\n void (*nidr_comment)(const char*);\n static void nidr_keyword_finish(void);\n static Comment *OutsideComment;\n static void kw_finish2(void), kw_finish3(void);\n static void kw_setup1(KeyWord *);\n static FILE *dumpfile;\n static KeyWord **ToClear, **ToClear0, **ToClearEnd;\n static int dumplev, nsquawk, nparse_errors, primary, strict;\n\n int NIDR_disallow_missing_start = 1;\n\n enum {n_KWStack0 = 64};\n\n static KWinfo KWStack0[n_KWStack0];\n\n static Uint n_KWStack = n_KWStack0;\n\n static KeyWord *curid, *curkw;\n static KWinfo\t*KWStack = KWStack0,\n\t\t*KWStackBot = KWStack0,\n\t\t*KWStackEnd = KWStack0 + n_KWStack0;\n\n static Values KWval, KWvalmax;\n static Real *KWvalbuf;\n static Uint nKWvalbuf;\n\n typedef struct Sbuf Sbuf;\n enum { n_KWsbuf = 8192 };\n struct Sbuf {\n\tchar buf[n_KWsbuf];\n\tSbuf *next;\n\t};\n\n typedef struct KWseen KWseen;\n\n struct\nKWseen {\n\tconst char *name;\n\tKeyWord *kw;\n\tKWseen *mnext, *mprev;\t/* for identifiers so far unrequited when kw == 0 */\n\t\t\t\t/* kw != 0 ==> mprev = first child, and mnext = next sibling */\n\tKWseen *parent;\n\tKWseen **lcn;\t\t/* &mprev field of last child; lcn == 0 when this */\n\t\t\t\t/* keyword was entered into the AVL tree because */\n\t\t\t\t/* its parent was seen. */\n\tComment *comment;\n\tchar **svals;\n\tReal *rvals;\n\tsize_t nvals;\n\t};\n\n static KWseen *KW_cur;\n NIDR_KWlib *NIDR_Libs;\n\n void\nnidr_lib_cleanup(void)\n{\n\tKeyWord *kw;\n\tNIDR_KWlib *L, *L1;\n\n\tL1 = NIDR_Libs;\n\tNIDR_Libs = 0;\n\twhile((L = L1)) {\n\t\tif (L->oldtop)\n\t\t\tKeyword_Top = L->oldtop;\n\t\tif ((kw = L->kw0)) {\n\t\t\tkw->f.vs = 0;\n\t\t\tkw->kind &= ~KWKind_Loaded;\n\t\t\t}\n#ifndef NO_NIDR_DYNLIB /*{{*/\n\t\tdlclose(L->h);\n#else  /*}{*/\n\t\t/* botch(\"dlclose is NOT SUPPORTED for current configuration\"); */\n\t\tfprintf(stderr, \"\\ndlclose is NOT SUPPORTED for current configuration\");\n#endif /*}}*/\n\t\tL1 = L->next;\n\t\tfree(L);\n\t\t}\n\t}\n\n static Sbuf KWsbuf0, *KWsbuf = &KWsbuf0;\n static char *KWsbuf1 = KWsbuf0.buf, *KWsbufe = KWsbuf0.buf + n_KWsbuf;\n static KWseen *curkws;\n static const char *valkind[3] = {\"integer\",\"numeric\",\"string\"};\n\n int\nnidr_parse_error(void)\n{\n\tint n;\n\tif ((n = nsquawk - NIDR_SQUAWKMAX) > 0)\n\t\tfprintf(stderr, \"\\n%d error message%s suppressed.\\n\",\n\t\t\tn, \"s\" + (n == 1));\n\treturn nsquawk + nparse_errors;\n\t}\n\n void\nnidr_signal_parse_error(void)\n{ ++nparse_errors; }\n\n void\nnidr_tolower(char *s)\n{\n\tfor(; *s; ++s)\n\t\t*s = tolower(*s);\n\t}\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\nBotch:  \");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tif (++nsquawk <= NIDR_SQUAWKMAX) {\n\t\tfprintf(stderr, \"Input line %d: \", nidrLineNumber);\n\t\tva_start(ap, fmt);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfputs(\".\\n\", stderr);\n\t\tva_end(ap);\n\t\t}\n\t}\n\n#ifdef NIDR_MALLOC_DEBUG\n typedef struct MallocDebug MallocDebug;\n struct MallocDebug\n{\n\tMallocDebug *next, *prev;\n\tchar *where;\n\tint nalloc;\n\t};\n\n static MallocDebug MDtop = {&MDtop, &MDtop, 0, 0};\n int MallocDebugCount, MallocDebugCount1;\n\n static void*\nAlloc(const char *where, size_t len)\n{\n\tMallocDebug *md = malloc(len + sizeof(MallocDebug));\n\tif (!md) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in %s\\n\", (unsigned long)len, where);\n\t\texit(1);\n\t\t}\n\t(md->next = MDtop.next)->prev = md;\n\t(md->prev = &MDtop)->next = md;\n\tmd->where = where;\n\tif ((md->nalloc = ++MallocDebugCount) == MallocDebugCount1)\n\t\tprintf(\"Hit %d\\n\", md->nalloc);\n\treturn (void*)(md + 1);\n\t}\n\n static void\nMallocDebugFree(void *v)\n{\n\tMallocDebug *md = (MallocDebug *)v - 1;\n\tmd->next->prev = md->prev;\n\tmd->prev->next = md->next;\n\tfree(md);\n\t}\n#define free MallocDebugFree\n\n#else //!NIDR_MALLOC_DEBUG\n static void*\nAlloc(const char *where, size_t len)\n{\n\tvoid *rv = malloc(len);\n\tif (!rv) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in %s\\n\", (unsigned long)len, where);\n\t\texit(1);\n\t\t}\n\treturn rv;\n\t}\n#endif //NIDR_MALLOC_DEBUG\n\n const char *\nnidr_basename(const char *p)\n{\n\tconst char *b;\n\n#ifdef _WIN32\n\tif (p[0] && p[1] == ':')\n\t\tp += 2;\n\telse if (p[0] == '\\\\' && p[1] == '\\\\')\n\t\tfor(p += 2; *p; )\n\t\t\tswitch(*p++) {\n\t\t\t case '/':\n\t\t\t case '\\\\':\n\t\t\t\tgoto break2;\n\t\t\t}\n break2:\n#endif\n\tb = p;\n\twhile(*p)\n\t\tswitch(*p++) {\n\t\t case '/':\n#ifdef _WIN32\n\t\t case '\\\\':\n#endif\n\t\t\tb = p;\n\t\t}\n\treturn b;\n\t}\n\n const char *nidr_exedir;\n int nidr_exedir_len = -1; /* allow resetting to -1 for debugging */\n\n#ifndef _WIN32\n static int\nIs_executable(uid_t myuid, gid_t mygid, struct stat *sb)\n{\n\tif (sb->st_uid == myuid) {\n\t\tif (sb->st_mode & S_IXUSR)\n\t\t\treturn 1;\n\t\t}\n\telse if (sb->st_gid == mygid) {\n\t\tif (sb->st_mode & S_IXGRP)\n\t\t\treturn 1;\n\t\t}\n\telse if (sb->st_mode & S_IXOTH)\n\t\treturn 1;\n\treturn 0;\n\t}\n#endif\n\n int\nnidr_save_exedir(const char *argv0, int pathadj)\n{\n\t/* pathadj & 1 ==> add exedir to $PATH */\n\t/* pathadj & 2 ==> add . to $PATH */\n\t/* (in both cases if not already there) */\n\n    /* These conditionals don't seem to work (perhaps expected) for Cygwin \n\t   binaries run from Windows command prompt as the compile-time is \n\t   unix-style, but runtime the path is windows-like.  For now comment\n\t   out warning when on Cygwin build */\n#ifdef _WIN32\n#define Pathname \"Path\"\n#define Sep ';'\n#define Slash '\\\\'\n#define Executable(x) !stat(x,&sb)\n#else\n#define Pathname \"PATH\"\n#define Sep ':'\n#define Slash '/'\n#define Executable(x) !stat(x,&sb) && Is_executable(myuid, mygid, &sb)\n#endif\n\tchar *buf, buf0[4096], *s;\n\tconst char *av0, *p, *p0, *p1, *p2;\n\tint dotseen, finaldot, rc;\n\tsize_t buflen, L, L1, L2, L3;\n\tstruct stat sb;\n\tstatic const char dotslash[3] = { '.', Slash, 0 };\n#ifdef _WIN32\n\tint c;\n\tpathadj &= 1;\t/* . is implicitly in $PATH under _WIN32 */\n#else\n\tgid_t mygid;\n\tuid_t myuid;\n#endif\n\tif (nidr_exedir_len != -1) {\n\t\tfprintf(stderr, \"\\nIgnoring extra call on nidr_save_argv0()\\n\");\n\t\treturn 1;\n\t\t}\n\tnidr_exedir_len = 0;\n\tif (!(av0 = argv0))\n\t\treturn 2;\n\tif (!(p = getenv(Pathname))) {\n\t\tfprintf(stderr, \"\\nnidr_save_exedir: no $%s\\n\", Pathname);\n\t\treturn 3;\n\t\t}\n\tdotseen = finaldot = rc = 0;\n\tbuf = buf0;\n\tbuflen = sizeof(buf0);\n\tp0 = p2 = p;\n\tp1 = nidr_basename(av0);\n\tif ((L = p1 - av0) > 0) {\n\t\tmemcpy(s = (char*)Alloc(\"nidr_save_argv0\", L+1), av0, L);\n\t\ts[L] = 0;\n\t\tnidr_exedir = s;\n\t\tnidr_exedir_len = (int)L;\n#ifdef _WIN32\n\t\tfor(L1 = 0; L1 < L; ++L1)\n\t\t\tif (s[L1] == '/')\n\t\t\t\ts[L1] = '\\\\';\n#endif\n\t\tif (!pathadj)\n\t\t\treturn 0;\n\t\tif (*p == Sep)\n\t\t\tdotseen = 1;\n\t\twhile(*p) {\n\t\t\tif (*p == Sep && (p[1] == Sep || p[1] == 0)) {\n\t\t\t\tdotseen = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t++p;\n\t\t\t}\n\t\tif (s[0] == '.' && s[1] == Slash && L == 2) {\n#ifdef _WIN32\n\t\t\treturn 0;\n#else\n\t\t\tif (!dotseen)\n\t\t\t\tgoto dot_add;\n#endif\n\t\t\t}\n\t\tL1 = L - 1;\n\t\tfor(p = p0;;) {\n\t\t\twhile(*p == Sep)\n\t\t\t\t++p;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t\tif (!strncmp(p, s, L1)) {\n#ifdef _WIN32\n\t\t\t\treturn 0;\n#else\n\t\t\t\tif (!(pathadj &= ~1) || *p0 == Sep)\n\t\t\t\t\treturn 0;\n\t\t\t\tfor(p = p0;;) {\n\t\t\t\t\tif (*p == Sep || (*p == '.' && p[1] == Sep))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\twhile(*p != Sep) {\n\t\t\t\t\t\tif (!*p)\n\t\t\t\t\t\t\tgoto dot_add;\n\t\t\t\t\t\t++p;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!*++p)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\twhile(*++p != Sep)\n\t\t\t\tif (!*p)\n\t\t\t\t\tgoto break2;\n\t\t\tif (!*++p) {\n#ifdef _WIN32\n\t\t\t\tfinaldot = 1; /* leave at 0 for !_WIN32 */\n#endif\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n break2:\n\t\tL1 = strlen(Pathname);\n\t\tL2 = strlen(p0);\n\t\tif (!pathadj & 2)\n\t\t\tdotseen = 1;\n\t\tL3 = L1 + L2 + L + 3;\n\t\ts = (char*)Alloc(\"nidr_save_argv0\", L3);\n\t\tmemcpy(s, Pathname, L1);\n\t\ts[L1++] = '=';\n\t\tmemcpy(s+L1, p0, L2);\n\t\tL1 += L2;\n\t\tif (!finaldot)\n\t\t\ts[L1++] = Sep;\n\t\tmemcpy(s+L1, nidr_exedir, --L);\n\t\tL1 += L;\n\t\tif (!dotseen)\n\t\t\ts[L1++] = Sep;\n\t\ts[L1] = 0;\t/* omit final slash */\n\t\tputenv(s);\n\t\treturn 0;\n\t\t}\n\tL = strlen(av0);\n#ifdef _WIN32\n\tif (L < 5 || av0[L-4] != '.'\n\t|| ((c = av0[L-3]) != 'e' && c != 'E')\n\t|| ((c = av0[L-2]) != 'x' && c != 'X')\n\t|| ((c = av0[L-1]) != 'e' && c != 'E')) {\n\t\tmemcpy(s = (char*)Alloc(\"nidr_save_argv0\", L + 5), av0, L);\n\t\tstrcpy(s+L, \".exe\");\n\t\tL += 4;\n\t\tav0 = s;\n\t\t}\n\tif (Executable(av0)) {\n\t\t/* handle implicit . */\n\t\tdotseen = 1;\n\t\tnidr_exedir = dotslash;\n\t\t}\n\telse /* do for loop */\n#else\n\tmyuid = geteuid();\n\tmygid = getegid();\n#endif\n\tfor(; *p; p = p2) {\n\t\tfor(p1 = p;; ++p1) {\n\t\t\tif (*p1 == Sep) {\n\t\t\t\tp2 = p1 + 1;\n\t\t\t\tif (!*p2)\n\t\t\t\t\tfinaldot = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!*p1) {\n\t\t\t\tp2 = p1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (p1 == p || (*p == '.' && p1 == p + 1)) {\n\t\t\tif (!dotseen) {\n\t\t\t\tdotseen = 1;\n\t\t\t\tif (Executable(av0)) {\n\t\t\t\t\tnidr_exedir = dotslash;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tL1 = p1 - p;\n\t\t\tL2 = L + L1 + 2;\n\t\t\tif (L2 > buflen) {\n\t\t\t\tif (buf != buf0)\n\t\t\t\t\tfree(buf);\n\t\t\t\tbuf = (char*)Alloc(\"nidr_save_argv0\", L2);\n\t\t\t\tbuflen = L2;\n\t\t\t\t}\n\t\t\tmemcpy(buf, p, L1);\n\t\t\tbuf[L1++] = Slash;\n\t\t\tstrcpy(buf+L1, av0);\n\t\t\tif (Executable(buf)) {\n\t\t\t\ts = (char*)Alloc(\"nidr_save_argv0\", L1+1);\n\t\t\t\tmemcpy(s, buf, L1);\n\t\t\t\ts[L1] = 0;\n\t\t\t\tnidr_exedir = s;\n\t\t\t\tnidr_exedir_len = (int)L1;\n\t\t\t\tpathadj &= ~1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (dotseen)\n\t\tpathadj &= ~2;\n\tif (!finaldot && *p2) {\n\t\twhile(p2[1])\n\t\t\t++p2;\n\t\tif (*p2 == Sep)\n\t\t\tfinaldot = 1;\n\t\t}\n\tif (finaldot && !dotseen && !nidr_exedir) {\n\t\tdotseen = 1;\n\t\tif (Executable(av0))\n\t\t\tnidr_exedir = dotslash;\n\t\t}\n\tif (nidr_exedir == dotslash)\n\t\tnidr_exedir_len = 2;\n\telse {\n\t\tif (pathadj & 2 && !finaldot) {\n#ifndef _WIN32\n dot_add:\n#endif\n\t\t\tL = strlen(p0);\n\t\t\tL1 = strlen(Pathname);\n\t\t\tL2 = L + L1 + 3;\n\t\t\ts = (char*)Alloc(\"nidr_save_argv0\", L2);\n\t\t\tmemcpy(s, Pathname, L1);\n\t\t\ts[L1++] = '=';\n\t\t\tmemcpy(s+L1, p0, L);\n\t\t\ts[L += L1] = Sep;\n\t\t\ts[L+1] = 0;\n\t\t\tputenv(s);\n\t\t\t}\n\t\tif (!nidr_exedir) {\n/* Suppress warning for Cygwin and Windows, where path isn't resolved correctly above */\n#if !defined(__CYGWIN__) && !defined(_MSC_VER)\n\t\t\tfprintf(stderr, \"\\nnidr_save_exedir: could not find \\\"%s\\\" in $%s\\n\",\n\t\t\t\tav0, Pathname);\n#endif\n\t\t\trc = 4;\n\t\t\t}\n\t\t}\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn rc;\n\t}\n\n void *\nnidr_dlopen(const char *libname)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"dlopen for \\\"%s\\\" is NOT SUPPORTED\", libname);\n\treturn (void*)libname;\n#else /*}{*/\n\tchar buf0[4096], *buf;\n\tconst char *b;\n\tsize_t buflen, L, L1;\n\tvoid *h;\n\n\tb = nidr_basename(libname);\n\tif (b > libname)\n\t\treturn dlopen(libname, RTLD_NOW);\n\tbuf = buf0;\n\tbuflen = sizeof(buf0);\n\tL = strlen(libname);\n\tif (nidr_exedir) {\n\t\tL1 = L + nidr_exedir_len + 1;\n\t\tif (L1 > buflen) {\n\t\t\tbuf = (char*)Alloc(\"nidr_dlopen\", L1);\n\t\t\tbuflen = L1;\n\t\t\t}\n\t\tmemcpy(buf, nidr_exedir, nidr_exedir_len);\n\t\tstrcpy(buf + nidr_exedir_len, libname);\n\t\tif ((h = dlopen(buf, RTLD_NOW)))\n\t\t\tgoto ret;\n\t\t}\n\tif (!(h = dlopen(libname, RTLD_NOW))) {\n\t\tL1 = L + 3;\n\t\tif (L1 > buflen) {\n\t\t\tbuf = (char*)Alloc(\"nidr_dlopen\", L1);\n\t\t\tbuflen = L1;\n\t\t\t}\n\t\tbuf[0] = '.';\n\t\tbuf[1] = Slash;\n\t\tstrcpy(buf+2, libname);\n\t\tif (!(h = dlopen(buf, RTLD_NOW)))\n\t\t\th = dlopen(libname, RTLD_NOW); \t/* for dlerror */\n\t\t}\n ret:\n\tif (buf != buf0)\n\t\tfree(buf);\n\treturn h;\n#endif  /*}}*/\n\t}\n\n#undef Executable\n#undef Slash\n#undef Sep\n#undef Pathname\n\n\n struct\nComment {\n\tint k;\t\t/* subscript for comfree */\n\tsize_t avail;\t/* bytes left (from tnext) */\n\tchar *text;\t/* text of comment */\n\tchar *tnext;\t/* null byte at end of comment */\n\tComment *fnext;\t/* next free Comment */\n\t};\n\n enum { Comment_kmax = 7 };\n\n static Comment *comfree[Comment_kmax+1];\n static size_t Comment_maxlen[Comment_kmax+1];\n\n static void\ncomment_free(Comment *c)\n{\n\tint k = c->k;\n\n\tif (k > Comment_kmax)\n\t\tfree(c);\n\telse {\n\t\tc->fnext = comfree[k];\n\t\tcomfree[k] = c;\n\t\t}\n\t}\n\n static Comment*\nalloc_comment(int k, size_t L)\n{\n\tComment *c;\n\n\tfor(; k <= Comment_kmax; ++k) {\n\t\tif (L <= Comment_maxlen[k]) {\n\t\t\tL = Comment_maxlen[k];\n\t\t\tif ((c = comfree[k])) {\n\t\t\t\tcomfree[k] = c->fnext;\n\t\t\t\tgoto have_c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tc = (Comment*)Alloc(\"save_comment\", L + sizeof(Comment) + 1);\n\tc->k = k;\n\tc->text = (char*)(c+1);\n have_c:\n\tc->avail = L;\n\tc->tnext = c->text;\n\treturn c;\n\t}\n\n static void\nsave_comment(const char *s)\n{\n\tComment *c, *c1, **cp;\n\tsize_t L, L1;\n\n\tL = strlen(s);\n\tcp = curid ? &curid->comment : curkws ? &curkws->comment : &OutsideComment;\n\tif ((c = *cp)) {\n\t\tif (c->avail >= L)\n\t\t\tgoto cupdate;\n\t\tL1 = c->tnext - c->text;\n\t\tc1 = alloc_comment(c->k + 1, L + L1);\n\t\tmemcpy(c1->text, c->text, L1);\n\t\tc1->tnext = c1->text + L1;\n\t\tc1->avail -= L1;\n\t\tcomment_free(c);\n\t\tc = c1;\n\t\t}\n \telse\n\t\tc = alloc_comment(0, L);\n cupdate:\n\tmemcpy(c->tnext, s, L+1);\n\tc->tnext += L;\n\tc->avail -= L;\n\t*cp = c;\n\t}\n\n static void\ncomment_setup(void)\n{\n\tint i;\n\tsize_t L;\n\tnidr_comment = save_comment;\n\t/* \"- 1\" to allow for terminating '\\0' */\n\tfor(L = 64; L <= sizeof(Comment) - 1; L <<= 1);\n\tfor(i = 0; i <= Comment_kmax; ++i, L <<= 1)\n\t\tComment_maxlen[i] = L - sizeof(Comment) - 1;\n\t}\n\n static void\ncomment_reset(void)\n{\n\tComment *c, *c1;\n\tint i;\n\n\tfor(i = 0; i <= Comment_kmax; ++i) {\n\t\tc1 = comfree[i];\n\t\tcomfree[i] = 0;\n\t\twhile((c = c1)) {\n\t\t\tc1 = c->fnext;\n\t\t\tfree(c);\n\t\t\t}\n\t\t}\n\tnidr_comment = 0;\n\t}\n\n static void\ndumpcomment(Comment **cp)\n{\n\tComment *c = *cp;\n\t*cp = 0;\n\tfprintf(dumpfile, \"%s\", c->text);\n\tcomment_free(c);\n\t}\n\n static void\ndumpname(int hasval, KeyWord *kw)\n{\n\tconst char *fmt[2] = { \"%s\", \"%s =\" };\n\tint i;\n\tif (OutsideComment)\n\t\tdumpcomment(&OutsideComment);\n\tif (primary)\n\t\tkw += kw->paoff;\n\tfor(i = 0; i < dumplev; ++i)\n\t\tputc(' ', dumpfile);\n\tfprintf(dumpfile,fmt[hasval],kw->name);\n\tif (!hasval) {\n\t\tif (kw->comment)\n\t\t\tdumpcomment(&kw->comment);\n\t\telse if (kw != curkw)\n\t\t\tputc('\\n', dumpfile);\n\t\t}\n\t}\n\n static void\ndumpstring(const char *s0)\n{\n\tconst char *s;\n\tint c, n1, n2, q;\n\n\tn1 = n2 = 0;\n\tfor(s = s0;;)\n\t\tswitch(*s++) {\n\t\t  case 0: goto break2;\n\t\t  case '\\'':\n\t\t\t++n1;\n\t\t\tbreak;\n\t\t  case '\"':\n\t\t\t++n2;\n\t\t  }\n break2:\n\tq = '\\'';\n\tif (n1 > n2)\n\t\tq = '\"';\n\tputc(' ', dumpfile);\n\tputc(q, dumpfile);\n\ts = s0;\n\twhile((c = *s++)) {\n\t\tif (c == q)\n\t\t\tputc(q, dumpfile);\n\t\tputc(c, dumpfile);\n\t\t}\n\tputc(q, dumpfile);\n\t}\n\n static void\ndumpvals0(KeyWord *kw)\n{\n\tReal *r;\n\tconst char **sp;\n\tint i, *ip, indent, j, n;\n\n\tip = 0; /* shut up warning of possible use without initialization */\n\tsp = 0; /* ditto */\n\tif (!(r = KWval.r) && !(ip = KWval.i) && !(sp = KWval.s))\n\t\treturn;\n\tn = KWval.n;\n\tputc((indent = n > 1) ? '\\n' : ' ', dumpfile);\n\tfor(i = 0;;) {\n\t\tif (indent) {\n\t\t\tputc('\\t', dumpfile);\n\t\t\tfor(j = 0; j < dumplev; ++j)\n\t\t\t\tputc(' ', dumpfile);\n\t\t\t}\n\t\tif (r)\n\t\t\tfprintf(dumpfile, \"%.15g\", r[i]);\n\t\telse if (ip)\n\t\t\tfprintf(dumpfile, \"%d\", ip[i]);\n\t\telse\n\t\t\tdumpstring(sp[i]);\n\t\tif (++i >= n)\n\t\t\tbreak;\n\t\tindent = 1;\n\t\tputc('\\n', dumpfile);\n\t\t}\n\tif (kw->comment)\n\t\tdumpcomment(&kw->comment);\n\telse\n\t\tputc('\\n', dumpfile);\n\t}\n\n static void (*dumpvals)(KeyWord *kw) = dumpvals0;\n\n static void\ndumpvals1(KeyWord *kw)\n{\n\tReal *r;\n\tconst char **sp;\n\tint i, *ip, n;\n\n\tip = 0; /* shut up warning of possible use without initialization */\n\tsp = 0; /* ditto */\n\tif ((r = KWval.r) || (ip = KWval.i) || (sp = KWval.s)) {\n\t\tn = KWval.n;\n\t\tfor(i = 0; i < n; ++i) {\n\t\t\tif (r)\n\t\t\t\tfprintf(dumpfile, \" %.15g\", r[i]);\n\t\t\telse if (ip)\n\t\t\t\tfprintf(dumpfile, \" %d\", ip[i]);\n\t\t\telse\n\t\t\t\tdumpstring(sp[i]);\n\t\t\t}\n\t\t}\n\tif (kw->comment)\n\t\tdumpcomment(&kw->comment);\n\telse\n\t\tputc('\\n', dumpfile);\n\t}\n\n char *\nnidr_KWscopy(const char *s)\n{\n\tSbuf *sb;\n\tchar *rv;\n\n\tsize_t L = strlen(s) + 1;\n\tif (L >= n_KWsbuf)\n\t\tbotch(\"String too long in KWscopy\");\n\tif (KWsbufe - KWsbuf1 < L) {\n\t\tif (!KWsbuf->next) {\n\t\t\tKWsbuf->next = sb = (Sbuf*)Alloc(\"KWscopy\", sizeof(Sbuf));\n\t\t\tsb->next = 0;\n\t\t\t}\n\t\tKWsbuf = KWsbuf->next;\n\t\tKWsbuf1 = KWsbuf->buf;\n\t\tKWsbufe = KWsbuf1 + n_KWsbuf;\n\t\t}\n\tstrcpy(KWsbuf1, s);\n\trv = KWsbuf1;\n\tKWsbuf1 += L;\n\treturn rv;\n\t}\n\n static void\nKWvalbuf_inc(void)\n{\n\tReal *r;\n\tUint n;\n\n\tn = nKWvalbuf << 1;\n\tr = (Real*)Alloc(\"KWvalbuf\", n*sizeof(Real));\n\tmemcpy(r, KWvalbuf, nKWvalbuf*sizeof(Real));\n\tfree(KWvalbuf);\n\tKWvalbuf = r;\n\tnKWvalbuf = n;\n\tKWvalmax.n <<= 1;\n\tif (KWval.r) {\n\t\tKWval.r = r;\n\t\tKWvalmax.r = r + n;\n\t\t}\n\telse if (KWval.i) {\n\t\tKWval.i = (int*) r;\n\t\tKWvalmax.i = (int*)(r + n);\n\t\t}\n\telse if (KWval.s) {\n\t\tKWval.s = (const char**)r;\n\t\tKWvalmax.s = (const char**)(r + n);\n\t\t}\n\telse\n\t\tbotch(\"Unexpected case in KWvalbuf_inc\");\n\t}\n\n/* KWval.rstate values...\n *\tvalue\tform seen\n *\t0\tv\n *\t1\tL:u\n *\t2\tL:s:u\n *\t3\tn*v\n *\t4\tn*L:u\n *\t5\tn*L:s:u\n */\n\n static void\nfinish_rexpand(void)\n{\n\tint i, k, n, os;\n\tReal sgn, st, u, v, x;\n\n\tos = KWval.rstate;\n\tKWval.rstate = 0;\n\tn = KWval.n;\n\tk = 1;\n\tif (os >= 3) {\n\t\tKWval.n = n -= os-1;\n\t\tk = KWval.r[n];\n\t\tif (k != KWval.r[n]) {\n\t\t\tsquawk(\"Noninteger replication factor %.17g\", KWval.r[n]);\n\t\t\treturn;\n\t\t\t}\n\t\telse if (k < 1) {\n\t\t\tsquawk(\"Nonpositive replication factor %d\", k);\n\t\t\treturn;\n\t\t\t}\n\t\t++n;\n\t\tos -= 3;\n\t\t}\n\telse\n\t\tKWval.n = n -= os + 1;\n\tv = KWval.r[n++];\n\tu = st = 0.;\t/* Shut up warning of not being initialized. */\n\t\t\t/* Both will be assigned before being used. */\n\tswitch(os) {\n\t  case 0:\n\t\tn = KWval.n;\n\t\tfor(i = 0; i < k; ++i) {\n\t\t\tif (n >= KWvalmax.n)\n\t\t\t\tKWvalbuf_inc();\n\t\t\tKWval.r[n++] = v;\n\t\t\t}\n\t\tKWval.n = n;\n\t\treturn;\n\t  case 1:\n\t\tst = 1;\n\t\tu = KWval.r[n];\n\t\tbreak;\n\t  case 2:\n\t\tst = KWval.r[n];\n\t\tif (st == 0.) {\n\t\t\tsquawk(\"Invalid stride == zero.\");\n\t\t\treturn;\n\t\t\t}\n\t\tu = KWval.r[n+1];\n\t  }\n\tsgn = 1.;\n\tif (st < 0.)\n\t\tsgn = -1.;\n\tif (sgn*(u - v) < 0.) {\n\t\tsquawk(\"Empty sequence.\");\n\t\treturn;\n\t\t}\n\tn = KWval.n;\n\tdo {\n\t\tfor(i = 0; sgn*(u - (x = v + i*st)) >= 0.; ++i) {\n\t\t\tif (n >= KWvalmax.n)\n\t\t\t\tKWvalbuf_inc();\n\t\t\tKWval.r[n++] = x;\n\t\t\t}\n\t\t}\n\t\twhile(--k > 0);\n\tKWval.n = n;\n\t}\n\n static void\nrexpand(int state)\n{\n\tint os;\n\n\tos = KWval.rstate;\n\tKWval.rstate = 0;\n\tswitch(state) {\n\t  case 1: /* just saw *v */\n\t\tif (os == 0)\n\t\t\tKWval.rstate = 3;\n\t\telse\n\t\t\tsquawk(\"Unexpected '*'\");\n\t\tbreak;\n\t  case 2: /* just saw :v */\n\t\tif (os == 2 || os == 5)\n\t\t\tsquawk(\"Unexpected ':'\");\n\t\telse\n\t\t\tKWval.rstate = os + 1;\n\t\tbreak;\n\t  }\n\t}\n\n static void\nnidr_bufr_strict(Real r, int state)\n{\n\tint k, n;\n\n\tif (KWval.s) {\n\t\tsquawk(\"expected a quoted string, but found a number\");\n\t\treturn;\n\t\t}\n\tif (KWval.rstate && !state)\n\t\tfinish_rexpand();\n\tif (!KWval.r && !KWval.i) {\n\t\tsquawk(\"No values may be specified for %s\", KWStack->kw->name);\n\t\treturn;\n\t\t}\n\tif ((n = KWval.n) >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tif (KWval.r)\n\t\tKWval.r[n] = r;\n\telse {\n\t\tk = (int)r;\n\t\tif (k != r)\n\t\t\tsquawk(\"truncating %.17g to %d\", r, k);\n\t\tKWval.i[n] = k;\n\t\t}\n\t++KWval.n;\n\tif (state | KWval.rstate)\n\t\trexpand(state);\n\t}\n\n static void\nnidr_bufs_strict(const char *s)\n{\n\tif (!KWval.s) {\n\t\tif (KWval.r)\n\t\t\tsquawk(\"Expected a number, but found a quoted string\");\n\t\telse\n\t\t\tsquawk(\"Misplaced quoted string\");\n\t\treturn;\n\t\t}\n\tif (KWval.n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.s[KWval.n++] = s;\n\t}\n\n void\nnidr_reset(void)\n{\n\t/* Originally did this in case KWKind_Str of kw_setup(), */\n\t/* but this leads to confusion with erroneous input. */\n\tif (curkw)\n\t\tnidr_keyword_finish();\n\tKWsbuf = &KWsbuf0;\n\tKWsbuf1 = KWsbuf0.buf;\n\tKWsbufe = KWsbuf0.buf + n_KWsbuf;\n\t}\n\n NIDR_KWlib *\nnidr_lib_record(void *h, const char *libname)\n{\n\tNIDR_KWlib *Lib;\n\tsize_t L;\n\n\tL = strlen(libname) + 1;\n\tLib = (NIDR_KWlib*)Alloc(\"NIDR_lib_record\", sizeof(NIDR_KWlib) + L);\n\tmemset(Lib, 0, sizeof(NIDR_KWlib));\n\tmemcpy(Lib->libname = (char*)(Lib+1), libname, L);\n\tif (!(Lib->next = NIDR_Libs))\n\t\tatexit(nidr_lib_cleanup);\n\tNIDR_Libs = Lib;\n\tLib->h = h;\n\treturn Lib;\n\t}\n\n static KeyWord*\nkw_insert(KeyWord *kw, int *tryagain)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"Loading library \\\"%s\\\" for %s is disallowed\",\n\t\tkw->f.vf, kw->name);\n#else /*}{*/\n\tKW_ADD kwa;\n\tKeyWord *kw0, *kw1, *kw2;\n\tNIDR_KWlib *Lib;\n\tUint u1, ui;\n\tconst char *lname, *s;\n\tint newtop, nmatch;\n\tvoid *h;\n\n\tif (tryagain)\n\t\t*tryagain = 0;\n\tif (kw->kind & KWKind_Loaded)\n\t\treturn (KeyWord*)kw->f.vs;\n\th = nidr_dlopen(lname = (const char*)kw->f.vf);\n\tif (!h) {\n#ifndef NO_DLERROR\n\t\tif ((s = dlerror()))\n\t\t\tbotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\tlname, kw->name, s);\n\t\telse\n#endif\n\t\t\tbotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\tlname, kw->name);\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw1 = (*kwa)();\n\tif (!(s = kw1->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tnewtop = 0;\n\tif (strcmp(s, kw->name)) {\n\t\tif (!KW_cur && !strcmp(s,\"KeywordTop\") && kw1->kind & KWKind_Dynmult)\n\t\t\tnewtop = 1;\n\t\telse if (tryagain && kw1->nkw > 0\n\t\t && (kw2 = kwfind(kw->name, kw1->kw, kw1->nkw, &nmatch))) {\n\t\t\tif (nmatch > 1) {\n\t\t\t\ttoomany(kw->name, kw1, nmatch);\n\t\t\t\tbotch(\"Too many matches in library %s\", lname);\n\t\t\t\t}\n\t\t\t*tryagain = 1;\n\t\t\t}\n\t\telse\n namebotch:\n\t\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\t\tlname, kw->name, s);\n\t\t}\n\tui = kw->kind  & (KWKind_Mask|KWKind_List);\n\tu1 = kw1->kind & (KWKind_Mask|KWKind_List);\n\tif (ui != u1)\n\t\tbotch(\"Library %s: expected kind %u for %s, but got %u\",\n\t\t\tlname, ui, s, u1);\n\tLib = nidr_lib_record(h, lname);\n\tLib->kw0 = kw0 = kw;\n\tmemcpy(&Lib->kw, kw, sizeof(KeyWord));\n\tkw = &Lib->kw;\n\tkw->kw = kw1->kw;\n\tkw->nkw = kw1->nkw;\n\tkw->f = kw1->f;\n\tkw0->f.vs = (void*)kw;\n\tkw0->kind |= KWKind_Loaded;\n\tif (newtop) {\n\t\tLib->oldtop = Keyword_Top;\n\t\tKeyword_Top = kw;\n\t\tkw->kind |= KWKind_Dynmult;\n\t\t}\n#endif\t/*}}*/\n\treturn kw;\n\t}\n\n static void\nkwnext_setup(KeyWord *kw, Uint n)\n{\n\tKeyWord *kwe;\n\n\tif (kw->kwnext || (n <= 1 && kw->name))\n\t\treturn;\n#ifndef NO_NIDR_DYNLIB /*{*/\n\tif (kw->kind & KWKind_Extended) {\n\t\tKeyWordx *kx1, *kxe;\n\t\tfor(kx1 = (KeyWordx*)kw; !kx1->kw.name; ++kx1)\n\t\t\tkx1->kw.kwnext = (KeyWord*)(kx1 + 1);\n\t\tfor(kxe = kx1 + n - 1; kx1 < kxe; ++kx1)\n\t\t\tkx1->kw.kwnext = (KeyWord*)(kx1 + 1);\n\t\treturn;\n\t\t}\n#endif\n\tfor(; !kw->name; ++kw)\n\t\tkw->kwnext = kw + 1;\n\tfor(kwe = kw + n - 1; kw < kwe; ++kw)\n\t\tkw->kwnext = kw + 1;\n\t}\n\n static void\nKWStack_inc(void)\n{\n\tKWinfo *kwi;\n\tUint nn;\n\tsize_t len;\n\n\tnn = n_KWStack << 1;\n\tkwi = (KWinfo*)Alloc(\"kw_setup\", len = nn*sizeof(KWinfo));\n\tmemcpy(kwi, KWStackBot, len >> 1);\n\tif (KWStackBot != KWStack0)\n\t\tfree(KWStackBot);\n\tKWStackBot = kwi;\n\tKWStackEnd = kwi + nn;\n\tKWStack = kwi + n_KWStack;\n\tn_KWStack = nn;\n\t}\n\n static KeyWord*\nkw_setup(KeyWord *kw, void *g, const char *name)\n{\n\tKWinfo *kwi;\n\tKeyWord **alt, *kw1, **req;\n\n\tUint k, nalt, nn, nreq;\n\tint *altct, deferred;\n\tsize_t len;\n\n\tdeferred = 0;\n\tif (kw->kind & KWKind_Dynlib) {\n\t\tif (kw->kw)\n\t\t\tdeferred = 1;\n\t\telse\n\t\t\tkw = kw_insert(kw, 0);\n\t\t}\n top:\n\tif ((kw1 = kw->kw)) {\n\t\tkwnext_setup(kw1, kw->nkw);\n\t\tif (kw->kind & KWKind_Dynmult)\n\t\t\treturn kw;\n\t\twhile(!kw1->name) {\n\t\t\tif (!(kw1->kind & KWKind_Stacked)) {\n\t\t\t\tkw1->kind |= KWKind_Stacked;\n\t\t\t\tkw_setup(kw1, g, name);\n\t\t\t\t}\n\t\t\tkw1 = kw1->kwnext;\n\t\t\t}\n\t\t}\n\tif (!curkw) {\n\t\tKWStack = KWStackBot = KWStack0;\n\t\tKWStackEnd = KWStack0 + n_KWStack0;\n\t\tcurkw = kw;\n\t\t}\n\telse if (++KWStack >= KWStackEnd)\n\t\tKWStack_inc();\n\tkwi = KWStack;\n\tkwi->name = name;\n\tkwi->kw = kw;\n\tkwi->kw1 = kw1;\n\tnalt = nreq = 0;\n\tif (kw1)\n\t\tfor(; kw1; kw1 = kw1->kwnext) {\n\t\t\tif (nalt < kw1->alt)\n\t\t\t\tnalt = kw1->alt;\n\t\t\tif (nreq < kw1->req)\n\t\t\t\tnreq = kw1->req;\n\t\t\t}\n\tkwi->nalt = nalt;\n\tkwi->nreq = nreq;\n\talt = req = 0;\n\taltct = 0;\n\tif ((nn = nalt + nreq) > 0) {\n\t\tnn += 2;\n\t\talt = (KeyWord**)Alloc(\"kw_setup(alt)\",\n\t\t\t\tlen = nn*sizeof(KeyWord*) + (nalt+1)*sizeof(int));\n\t\tmemset(alt, 0, len);\n\t\treq = alt + nalt + 1;\n\t\taltct = (int*)(req + nreq + 1);\n\t\t/* altct[0], alt[0] and req[0] = \"don't care\" slots */\n\t\t}\n\tkwi->alt = alt;\n\tkwi->req = req;\n\tkwi->altct = altct;\n\tif (nreq)\n\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\treq[kw1->req] = kw1;\n\tif (nalt)\n\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\tif (kw1->kind & KWKind_primary)\n\t\t\t\t++altct[kw1->alt];\n\tkwi->g = g;\n\tKWval.n = 0;\n\tKWval.i = 0;\n\tKWval.r = 0;\n\tKWval.s = 0;\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tif (!KWvalmax.r)\n\t\t\tKWvalbuf = (Real *)Alloc(\"kw_setup(KWvalbuf)\",\n\t\t\t\t\t\t(nKWvalbuf = 128)*sizeof(Real));\n\t\tswitch(k) {\n\n\t\t  case KWKind_Int:\n\t\t\tKWval.i = (int*)KWvalbuf;\n\t\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(int);\n\t\t\tKWvalmax.i = KWval.i + KWvalmax.n;\n\t\t\tbreak;\n\n\t\t  case KWKind_Real:\n\t\t\tKWval.r = KWvalbuf;\n\t\t\tKWvalmax.r = KWvalbuf + (KWvalmax.n = nKWvalbuf);\n\t\t\tbreak;\n\n\t\t  case KWKind_Str:\n\t\t\tKWval.s = (const char**)KWvalbuf;\n\t\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t  }\n\t\t}\n\tif (deferred) {\n\t\tkw = kw_insert(kw, 0);\n\t\tdeferred = 0;\n\t\tgoto top;\n\t\t}\n\tif (!(kwi->needstart = kw->kind & KWKind_Mask)) {\n\t\tif (kw->name) {\n\t\t\tif (dumpfile)\n\t\t\t\tdumpname(0, kw);\n\t\t\t++dumplev;\n\t\t\t}\n\t\tif (kw->f.start)\n\t\t\t(*kw->f.start)(kw->name, 0, &KWStack->g, kw->f.vs);\n\t\t}\n\telse if (!kw->f.start && NIDR_disallow_missing_start)\n\t\tbotch(\"No start routine for %s\", kw->name);\n\treturn kw;\n\t}\n\n static KeyWord *\nkwfind(const char *name, KeyWord *keywds, int n, int *nmatch)\n{\n\tKeyWord *kn, *kn1;\n\tint k, n0, n1, n2, nn;\n\tsize_t L;\n\n\t*nmatch = 0;\n\tif (n <= 0)\n\t\treturn 0;\n\tL = strlen(name);\n\tn0 = 0;\n\tnn = n;\n#ifndef NO_NIDR_DYNLIB /*{*/\n\tif (n > 0 && keywds->kind & KWKind_Extended) {\n\t    while(n > 0) {\n\t\tn1 = n >> 1;\n\t\tkn = (KeyWord*)((KeyWordx*)keywds + n1);\n\t\tk = strncmp(name, kn->name, L);\n\t\tif (k < 0)\n\t\t\tn = n1;\n\t\telse if (k > 0) {\n\t\t\tn -= ++n1;\n\t\t\tn0 += n1;\n\t\t\tkeywds = (KeyWord*)((KeyWordx*)kn + 1);\n\t\t\t}\n\t\telse {\n\t\t\t/* Found -- check for range of matches. */\n\t\t\t/* Here we use linear search, as we expect */\n\t\t\t/* the range to be small. */\n\t\t\tn = n1 + n0;\n\t\t\tn2 = n + 1;\n\t\t\tif (kn->name[L]) {\n\t\t\t\tfor(kn1 = kn; n2 < nn; ++n2) {\n\t\t\t\t\tkn1 = (KeyWord*)((KeyWordx*)kn1 + 1);\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t}\n\t\t\t\tkn1 = kn;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tkn1 = (KeyWord*)((KeyWordx*)kn1 - 1);\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t--n;\n\t\t\t\t\tkn = kn1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t*nmatch = n2 - n;\n\t\t\treturn kn;\n\t\t\t}\n\t\t}\n\t    }\n\telse\n#endif\t/*}*/\n\twhile(n > 0) {\n\t\tn1 = n >> 1;\n\t\tkn = keywds + n1;\n\t\tk = strncmp(name, kn->name, L);\n\t\tif (k < 0)\n\t\t\tn = n1;\n\t\telse if (k > 0) {\n\t\t\tn -= ++n1;\n\t\t\tn0 += n1;\n\t\t\tkeywds = kn + 1;\n\t\t\t}\n\t\telse {\n\t\t\t/* Found -- check for range of matches. */\n\t\t\t/* Here we use linear search, as we expect */\n\t\t\t/* the range to be small. */\n\t\t\tn = n1 + n0;\n\t\t\tn2 = n + 1;\n\t\t\tif (kn->name[L]) {\n\t\t\t\tfor(kn1 = kn; n2 < nn; ++n2) {\n\t\t\t\t\t++kn1;\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L])\n\t\t\t\t\t\tgoto found1;\n\t\t\t\t\t}\n\t\t\t\tkn1 = kn;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\t--kn1;\n\t\t\t\t\tif (strncmp(name, kn1->name, L))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!kn1->name[L]) {\n found1:\n\t\t\t\t\t\t*nmatch = 1;\n\t\t\t\t\t\treturn kn1;\n\t\t\t\t\t\t}\n\t\t\t\t\t--n;\n\t\t\t\t\tkn = kn1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t*nmatch = n2 - n;\n\t\t\treturn kn;\n\t\t\t}\n\t\t}\n\treturn 0;\t/* not found */\n\t}\n\n static KeyWord *\ntoomany(const char *name, KeyWord *kw, int nmatch)\n{\n\tint i;\n\tsquawk(\"\\\"%s\\\" is ambiguous; possible matches..\", name);\n\tif (nsquawk <=  NIDR_SQUAWKMAX)\n\t\tfor(i = 0; i < nmatch; i++, kw++)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", kw->name);\n\treturn 0;\n\t}\n\n KeyWord *\nnidr_keyword(const char *name)\n{\n\tint nmatch;\n\tKeyWord *kw, *kw1;\n\n\tkw = kwfind(name, Keyword_Top->kw, Keyword_Top->nkw, &nmatch);\n\tif (nmatch > 1)\n\t\treturn toomany(name, kw, nmatch);\n\telse if (kw) {\n\t\tif (!(kw1 = curkw)) {\n\t\t\tkw = kw_setup(kw, KW_g, name);\n\t\t\tif (kw->kind & KWKind_Dynmult)\n\t\t\t\treturn kw;\n\t\t\t}\n\t\tif (!strict) {\n\t\t\tif (kw1)\n\t\t\t\tnidr_keyword_finish();\n\t\t\tkw_setup1(kw);\n\t\t\t}\n\t\t}\n\treturn kw;\n\t}\n\n static void\nvalcheck(KeyWord *kw)\n{\n\tReal *r;\n\tint *z;\n\tint i, k, n;\n\n\tn = KWval.n;\n\tswitch(k = kw->kind & KWKind_Mask) {\n\t  case KWKind_Int:\n\t\tz = KWval.i;\n\t\tif (kw->kind & KWKind_strictLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] <= kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be > %.0f\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] < kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be >= %.0f\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif (kw->kind & KWKind_strictUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] >= kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be < %.0f\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (z[i] > kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be >= %.0f\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tbreak;\n\t  case KWKind_Real:\n\t\tr = KWval.r;\n\t\tif (kw->kind & KWKind_strictLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] <= kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be > %g\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqLb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] < kw->Lb) {\n\t\t\t\t\tsquawk(\"%s must be >= %g\", kw->name, kw->Lb);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif (kw->kind & KWKind_strictUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] >= kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be < %g\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\telse if (kw->kind & KWKind_caneqUb) {\n\t\t\tfor(i = 0; i < n; ++i)\n\t\t\t\tif (r[i] > kw->Ub) {\n\t\t\t\t\tsquawk(\"%s must be >= %g\", kw->name, kw->Ub);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tbreak;\n\t  default:\n\t\tbotch(\"Bug: unexpected (kw->kind & KWKind_Mask) = %d in valcheck\",n);\n\t  }\n\t}\n\n static void\nread_lib(const char *libname, KeyWord *kw)\n{\n#ifdef NO_NIDR_DYNLIB /*{{*/\n\tbotch(\"LIBNAME is disallowed: cannot read \\\"%s\\\"\", libname);\n#else /*}{*/\n\tKeyWord *kw1;\n\tKW_ADD kwa;\n\tNIDR_KWlib *Lib;\n\tvoid *h;\n\n\th = nidr_dlopen(libname);\n\tif (!h) {\n#ifndef NO_DLERROR\n\t\tconst char *s;\n\t\tif ((s = dlerror()))\n\t\t\tbotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\", libname, s);\n\t\telse\n#endif\n\t\t\tbotch(\"Cannot open library \\\"%s\\\"\", libname);\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", libname);\n\tkw1 = (*kwa)();\n\tLib = nidr_lib_record(h, libname);\n\tkw->nkw = kw1->nkw;\n\tkw->kw = kw1->kw;\n\tkw->f = kw1->f;\n\tkw->kind |= KWKind_Loaded;\n#endif\t/*}}*/\n\t}\n\n static void\nnidr_id_strict_finish(KWinfo *kwi, KeyWord *kw, const char *name)\n{\n\tKeyWord *kw1;\n\tint n;\n\n\tif (kw->alt) {\n\t\tif ((kw1 = kwi->alt[n = kw->alt])) {\n\t\t\tif (strcmp(kw1->name, name))\n\t\t\t\tsquawk(\"%s and %s are mutually exclusive\",\n\t\t\t\t\tkw1->name, name);\n\t\t\telse\n\t\t\t\tsquawk(\"%s was already specified\", name);\n\t\t\t}\n\t\telse\n\t\t\tkwi->alt[n] = kw;\n\t\t}\n\tif (kw->req) {\n\t\tif (kwi->req[n = kw->req])\n\t\t\tkwi->req[n] = 0;\n\t\telse if (!kw->alt)\n\t\t\tsquawk(\"%s specified more than once\", name);\n\t\t}\n\t}\n\n static KWinfo *\ndispatch_val(KWinfo *kwi)\n{\n\tKeyWord *kw = kwi->kw;\n\n\tkwi->needstart = 0;\n\tif (KWval.n) {\n\t\tif (KWval.rstate)\n\t\t\tfinish_rexpand();\n\t\tif (dumpfile) {\n\t\t\tdumpname(1, kw);\n\t\t\tdumpvals(kw);\n\t\t\t}\n\t\tif (kw->kind & (KWKind_Lb|KWKind_Ub))\n\t\t\tvalcheck(kw);\n\t\tif (kw->f.start)\n\t\t\t(*kw->f.start)(kw->name, &KWval, &kwi->g, kw->f.vs);\n\t\telse if ((kw->kind & (KWKind_Libname | KWKind_Loaded)) == KWKind_Libname) {\n\t\t\tread_lib(KWval.s[0], kw);\n\t\t\tkw = kw_setup(kw, kwi->g, kw->name);\n\t\t\tif (kw->f.start)\n\t\t\t\t(*kw->f.start)(kw->name, &KWval, &kwi->g, kw->f.vs);\n\t\t\tif (kw == kwi->kw) {\n\t\t\t\t*kwi = *KWStack;\n\t\t\t\t--KWStack;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tkwi = KWStack;\n\t\t\t}\n\t\tKWval.n = 0;\n\t\t}\n\telse if ((kw->kind & (KWKind_Libname|KWKind_Loaded))\n\t\t\t  != (KWKind_Libname|KWKind_Loaded))\n\t\tsquawk(\"expected %sone %s value for %s\",\n\t\t\tkw->kind & KWKind_List ? \"at least \" : \"\",\n\t\t\tvalkind[(kw->kind & KWKind_Mask)-1], kw->name);\n\t++dumplev;\n\treturn kwi;\n\t}\n\n static void\noneof(KeyWord *kw, int alt, int n)\n{\n\tKeyWord *kw1;\n\n\tsquawk(\"One of the following %d entities\\nmust be specified for %s..\",\n\t\tn, kw->name);\n\tfor(kw1 = kw->kw; !kw1->name; kw1 = kw1->kwnext);\n\tfor(; kw1; kw1 = kw1->kwnext)\n\t\tif (kw1->alt == alt && kw1->kind & KWKind_primary)\n\t\t\tfprintf(stderr, \"\\t%s\\n\", kw1->name);\n\t}\n\n static void\nmissing_chk(KeyWord *kw1, KWinfo *kwi)\n{\n\tKeyWord *kw0, *kw2, **req;\n\tUint a;\n\tchar seen0[1024], *seen;\n\tconst char *kwname;\n\tint n;\n\tsize_t nreq;\n\n\t/* only issue one error message per missing keyword */\n\n\tnreq = 0;\n\tfor(kw0 = kw1; kw1; kw1 = kw1->kwnext)\n\t\tif (nreq < kw1->req)\n\t\t\tnreq = kw1->req;\n\tseen = seen0;\n\tif (++nreq > sizeof(seen0))\n\t\tseen = (char*)Alloc(\"missing_chk\", nreq);\n\tmemset(seen, 0, nreq);\n\treq = kwi->req;\n\tfor(kw1 = kw0; kw1; kw1 = kw1->kwnext) {\n\t\tif (kw1->req && req[kw1->req] && !seen[kw1->req] && kw1->kind & KWKind_primary) {\n\t\t\tseen[kw1->req] = 1;\n\t\t\ta = -1;\n\t\t\tif (!kw1->alt || (n = kwi->altct[a = kw1->alt]) <= 1) {\n\t\t\t\tif (!(kwname = kwi->name))\n\t\t\t\t\tkwname = \"<NIDRBUG>\";\n\t\t\t\tfor(kw2 = kw1;;) {\n\t\t\t\t\tif (kw2->alt == a && kw2->kind & KWKind_primary)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(kw2 = kw2->kwnext))\n\t\t\t\t\t\tbotch(\"Bug in missing_chk\");\n\t\t\t\t\t}\n\t\t\t\tsquawk(\"%s must be specified for %s\",\n\t\t\t\t\tkw2->name, kwname);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\toneof(kwi->kw, kw1->alt, n);\n\t\t\t}\n\t\t}\n\tif (seen != seen0)\n\t\tfree(seen);\n\t}\n\n static void\nfinalize(KWinfo *kwi)\n{\n\tKeyWord *kw, *kw1, **req;\n\n\tkw = kwi->kw;\n\tkw->kind &= ~KWKind_Stacked;\n\tif (kwi->needstart)\n\t\tkwi = dispatch_val(kwi);\n\tif (kw->name)\n\t\t--dumplev;\n\tif (kw->f.final)\n\t\t(*kw->f.final)(kw->name, 0, &kwi->g, kw->f.vf);\n\tif (kwi->alt) {\n\t\tif (kwi->nreq) {\n\t\t\treq = kwi->req;\n\t\t\tfor(kw1 = kwi->kw1; kw1; kw1 = kw1->kwnext)\n\t\t\t\tif (kw1->req && req[kw1->req]) {\n\t\t\t\t\tmissing_chk(kw1, kwi);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tfree(kwi->alt);\n\t\t}\n\t}\n\n static KeyWord *\nnidr_identifier_strict(const char *name)\n{\n\tKWinfo *kwi, *kwi1;\n\tKeyWord *kw, *kw1;\n\tint nmatch;\n\tsize_t height;\n\n\tif (!curkw)\n\t\tbotch(\"curkw = 0 in nidr_identifier\");\n\tkwi = KWStack;\n\tif (kwi->needstart)\n\t\tkwi = dispatch_val(kwi);\n\tfor(kwi1 = kwi;;) {\n\t\tkw1 = kwi->kw;\n\t\tif ((kw = kwfind(name, kwi->kw1, kw1->nkw, &nmatch)))\n\t\t\tbreak;\n\t\tif (kwi == KWStackBot)\n\t\t\treturn 0;\n\t\tif ((--kwi)->kw->name && !(kwi->kw->kind & KWKind_Loaded))\n\t\t\tkwi1 = kwi;\n\t\t}\n\tif (nmatch > 1)\n\t\treturn toomany(name, kw, nmatch);\n\twhile(KWStack > kwi1)\n\t\tfinalize(KWStack--);\n\tif ((kw->kind & (KWKind_Libname | KWKind_Loaded)) == KWKind_Libname) {\n\t\tnidr_id_strict_finish(kwi, kw, name);\n\t\tif (!KWvalmax.r)\n\t\t\tKWvalbuf = (Real *)Alloc(\"nidr_identifier_strict\",\n\t\t\t\t\t\t(nKWvalbuf = 128)*sizeof(Real));\n\t\tif (++KWStack >= KWStackEnd)\n\t\t\tKWStack_inc();\n\t\tkwi = KWStack;\n\t\tkwi->kw = kw;\n\t\tkwi->needstart = 1;\n\t\tKWval.s = (const char**)KWvalbuf;\n\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t}\n\telse {\n\t\theight = kwi - KWStackBot;\n\t\tkw = kw_setup(kw, kwi->g, name);\n\t\tkwi = KWStackBot + height; /* in case kw_setup reallocated KWStack */\n\t\tnidr_id_strict_finish(kwi, kw, name);\n\t\t}\n\treturn kw;\n\t}\n\n static void\nnidr_keyword_finish(void)\n{\n\tif (!strict)\n\t\tkw_finish2();\n\tfor(;;--KWStack) {\n\t\tfinalize(KWStack);\n\t\tif (KWStack == KWStackBot)\n\t\t\tbreak;\n\t\t}\n\tif (!strict)\n\t\tkw_finish3();\n\tcurid = curkw = 0;\n\t}\n\n const char*\nnidr_keyword_name(void)\n{ return curkw ? curkw->name : \"<none>\"; }\n\n/* Some of the above assumes strict nesting according to dakota.input.nspec. */\n/* Code here is meant to relax this assumption, allowing more flexibility in */\n/* the order of identifiers within a DAKOTA \"keyword\". */\n\n typedef struct KWpair KWpair;\n typedef struct KWmblk KWmblk;\n\n struct\nKWmblk {\n\tKWmblk *next;\n\tsize_t len;\n\t/* memory of length len immediately follows */\n\t};\n\n struct\nKWpair {\n\tKeyWord *kw;\n\tKWseen *kws;\n\t};\n\n enum{ KWmblk_gulp = 32000 };\n\n static AVL_Tree *AVLT, *AVLKWP;\n static KWseen **KW_p, **KW_pe, KWmissing, *KWs0;\n static KWmblk *KWmblk0, *KWmblk1;\n static const char *KWmem0, *KWmem1;\n\n typedef struct\nAVLCmpInfo {\n\tKWseen **found[2];\n\tint nfound;\n\tint inexact;\n\t} AVLCmpInfo;\n\n static int\navlcmp(void *v, KWseen **a, KWseen **b)\n{\n\tAVLCmpInfo *AI = (AVLCmpInfo*)v;\n\tKWseen *ksa, *ksb;\n\tconst char *s, *t;\n\n\ts = (ksa = *a)->name;\n\tt = (ksb = *b)->name;\n\tfor(; *s == *t; ++s, ++t)\n\t\tif (!*s)\n\t\t\treturn 0;\n\tif ((!*s && !ksa->kw && ksb->kw)\n\t  ||(!*t && !ksb->kw && ksa->kw)) {\n\t\t/* inexact match */\n\t\tif (AI->nfound == 0\n\t\t|| (AI->nfound == 1 && AI->found[0] != b))\n\t\t\tAI->found[AI->nfound++] = b;\n\t\treturn AI->inexact;\n\t\t}\n\treturn *s - *t;\n\t}\n\n static int\nkwpcmp(void *v, KWpair *a, KWpair *b)\n{\n\tif (a->kw == b->kw)\n\t\treturn 0;\n\treturn a->kw > b->kw ? 1 : -1;\n\t}\n\n static void\nKWmeminit(void)\n{\n\tKWmblk0 = KWmblk1 = (KWmblk*)Alloc(\"KWmeminit\",\n\t\t\tsizeof(KWmblk) + KWmblk_gulp);\n\tKWmem0 = (char*)(KWmblk0 + 1);\n\tKWmem1 = KWmem0 + KWmblk_gulp;\n\tKWmblk0->len = KWmblk_gulp;\n\tKWmblk0->next = 0;\n\tKWmissing.mnext = KWmissing.mprev = &KWmissing;\n\tKW_cur = 0;\n\tmemset(&KWval, 0, sizeof(KWval));\n\tKWvalbuf = (Real *)Alloc(\"kw_setup(KWValbuf)\", (nKWvalbuf = 128)*sizeof(Real));\n\tToClear = ToClear0 = (KeyWord**)Alloc(\"kw_setup(ToClear)\", 256*sizeof(KeyWord*));\n\tToClearEnd = ToClear0 + 256;\n\t}\n\n static void\nKWmembump(size_t L)\n{\n\tKWmblk *mb, *mb1;\n\tsize_t L1;\n\n\tfor(L1 = KWmblk_gulp; L1 < L; L1 <<= 1);\n\tif ((mb = mb1 = KWmblk1->next) && L1 <= mb->len)\n\t\tL1 = mb->len;\n\telse {\n\t\tKWmblk1->next = mb = (KWmblk*)Alloc(\"KWmembump\", L1 + sizeof(KWmblk));\n\t\tmb->len = L1;\n\t\tmb->next = mb1;\n\t\t}\n\tKWmblk1 = mb;\n\tKWmem0 = (char*)(mb+1);\n\tKWmem1 = KWmem0 + L1;\n\t}\n\n static void *\nKWgetmem(size_t L)\t/* for aligned memory */\n{\n\tvoid *rv;\n\n\tL = (L + sizeof(Real) - 1) & ~(sizeof(Real) - 1);\n\tif (KWmem1 - KWmem0 < L)\n\t\tKWmembump(L);\n\trv = (void*)KWmem0;\n\tKWmem0 += L;\n\treturn rv;\n\t}\n\n static KWseen **\nKWhash(const char *s, KeyWord *kw)\n{\n\tAVLCmpInfo AI;\n\tKWseen KW0, *KW0p, *kws, **kwsp;\n\tchar **ps;\n\tconst char *sa, *sb;\n\n\tAI.nfound = 0;\n\tAI.inexact = -1;\n\tAVL_setv(AVLT, &AI);\n\tKW0.name = s;\n\tKW0.kw = kw;\n\tKW0p = &KW0;\n\tcurkws = 0;\n\tif ((kwsp = (KWseen**)AVL_find((const Element*)&KW0p, AVLT)))\n\t\treturn kwsp;\n\tif (AI.nfound) {\n\t\tif (AI.nfound == 1) {\n\t\t\tAI.inexact = 1;\n\t\t\tAVL_find((const Element*)&KW0p, AVLT);\n\t\t\tif (AI.nfound == 1) {\n\t\t\t\tif (kw && (kw->kind & (KWKind_Libname | KWKind_Loaded))\n\t\t\t\t\t\t== KWKind_Libname\n\t\t\t\t && (ps = (*AI.found[0])->svals))\n\t\t\t\t\tread_lib(ps[0], kw);\n\t\t\t\treturn AI.found[0];\n\t\t\t\t}\n\t\t\t}\n\t\tsa = (*AI.found[0])->name;\n\t\tsb = (*AI.found[1])->name;\n\t\tif (kw)\n\t\t\tsquawk(\"Both '%s' and '%s' match '%s'\",\n\t\t\t\tsa, sb, s);\n\t\telse\n\t\t\tsquawk(\"'%s' is ambiguous:\\n\\tit matches both '%s' and '%s'\",\n\t\t\t\ts, sa, sb);\n\t\treturn AI.found[0];\n\t\t}\n\tkws = (KWseen*)KWgetmem(sizeof(KWseen));\n\tmemset(kws, 0, sizeof(KWseen));\n\tif ((kws->kw = kw))\n\t\ts = kw->name;\n\telse {\n\t\tcurkws = kws;\n\t\tkws->mnext = &KWmissing;\n\t\tKWmissing.mprev = (kws->mprev = KWmissing.mprev)->mnext = kws;\n\t\ts = nidr_KWscopy(s);\n\t\t}\n\tkws->name = s;\n\tif (KW_p >= KW_pe) {\n\t\tKW_p = (KWseen**)KWgetmem(32*sizeof(KWseen*));\n\t\tKW_pe = KW_p + 32;\n\t\t}\n\t*(kwsp = KW_p++) = kws;\n\tAVL_insert((const Element*)kwsp, AVLT);\n\treturn kwsp;\n\t}\n\n static void\nmixed_squawk(void)\n{\n\tsquawk(\"values for %s cannot be both strings and numbers\",\n\t\tKW_cur->name);\n\t}\n\n static void\nnidr_bufr_relaxed(Real r, int state)\n{\n\tint n;\n\n\tif (KWval.rstate && !state)\n\t\tfinish_rexpand();\n\tif (!(n = KWval.n)) {\n\t\tKWval.r = KWvalbuf;\n\t\tKWvalmax.r = KWvalbuf + (KWvalmax.n = nKWvalbuf);\n\t\t}\n\telse if (KWval.s) {\n\t\tmixed_squawk();\n\t\treturn;\n\t\t}\n\tif (n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.r[KWval.n++] = r;\n\tif (state | KWval.rstate)\n\t\trexpand(state);\n\t}\n\n static void\nnidr_bufs_relaxed(const char *s)\n{\n\tint n;\n\n\tif (!(n = KWval.n)) {\n\t\tKWval.s = (const char**)KWvalbuf;\n\t\tKWvalmax.n = (nKWvalbuf*sizeof(Real))/sizeof(char*);\n\t\tKWvalmax.s = KWval.s + KWvalmax.n;\n\t\t}\n\telse if (KWval.r) {\n\t\tmixed_squawk();\n\t\treturn;\n\t\t}\n\tif (n >= KWvalmax.n)\n\t\tKWvalbuf_inc();\n\tKWval.s[KWval.n++] = s;\n\t}\n\n static void kw_setup2(KWseen*);\n\n static void\nkw_finish1(KWseen *kws)\n{\n\tKeyWord *kw;\n\tint n;\n\tsize_t L;\n\n\tif (KWval.rstate)\n\t\tfinish_rexpand();\n\tkws->nvals = n = KWval.n;\n\tKWval.n = 0;\n\tif (KWval.r) {\n\t\tL = n*sizeof(Real);\n\t\tmemcpy(kws->rvals = (Real*)KWgetmem(L), KWval.r, L);\n\t\tKWval.r = 0;\n\t\t}\n\telse if (KWval.s) {\n\t\tL = n*sizeof(char*);\n\t\tmemcpy(kws->svals = (char**)KWgetmem(L), KWval.s, L);\n\t\tif ((kw = kws->kw) && kw->kind & KWKind_Libname) {\n\t\t\tread_lib(KWval.s[0], kw);\n\t\t\tif (kw->kw)\n\t\t\t\tkw_setup2(kws);\n\t\t\t}\n\t\tKWval.s = 0;\n\t\t}\n\t}\n\n static void*\nAlloc1(size_t len)\n{\n\tvoid *rv = malloc(len);\n\tif (!rv) {\n\t\tfprintf(stderr, \"malloc(%lu) failure in Alloc1\\n\", (unsigned long)len);\n\t\texit(1);\n\t\t}\n\treturn rv;\n\t}\n\n static void\nAVL_Clear(void)\n{\n\twhile(ToClear > ToClear0)\n\t\t(*--ToClear)->kind &= ~KWKind_Hashed;\n\tAVL_Tree_free(&AVLT);\n\tif (AVLKWP)\n\t\tAVL_Tree_free(&AVLKWP);\n\t}\n\n static void\nkw_setup1(KeyWord *kw)\n{\n\tKWseen *kws, *kws1;\n\tKeyWord *kw1;\n\n\tif ((kw1 = kw->kw))\n\t\tkwnext_setup(kw1, kw->nkw);\n\tif (!KWmblk0)\n\t\tKWmeminit();\n\tif (AVLT)\n\t\tAVL_Clear();\n\tAVLT = AVL_Tree_alloc(0, (AVL_Elcomp)avlcmp, Alloc1);\n\tKW_cur = KWs0 = kws = (KWseen*)KWgetmem(sizeof(KWseen));\n\tmemset(kws, 0, sizeof(KWseen));\n\tkws->name = kw->name;\n\tkws->kw = kw;\n\tkws->lcn = &kws->mprev;\n\tif (kw1) {\n\t\twhile(!kw1->name)\n\t\t\tkw1 = kw1->kwnext;\n\t\tfor(; kw1; kw1 = kw1->kwnext) {\n\t\t\tkws1 = *KWhash(kw1->name, kw1);\n\t\t\tkws1->parent = kws;\n\t\t\t}\n\t\t}\n\t}\n\n static KWseen**\nkw_setup3(KWseen **kwtodo1, KWseen *kws, KeyWord *kw)\n{\n\tKWseen *kws1, **kwsp;\n\n\tfor(; kw; kw = kw->kwnext) {\n\t\tkwsp = KWhash(kw->name, kw);\n\t\tkws1 = *kwsp;\n\t\tif (kws1->comment) {\n\t\t\tkw->comment = kws1->comment;\n\t\t\tkws1->comment = 0;\n\t\t\t}\n\t\tif (kws1->parent) {\n\t\t\tkws1 = (KWseen*)KWgetmem(sizeof(KWseen));\n\t\t\tmemset(kws1, 0, sizeof(KWseen));\n\t\t\tkws1->kw = kw;\n\t\t\tkws1->name = kw->name;\n\t\t\t*kwsp = kws1;\n\t\t\t}\n\t\tkws1->parent = kws;\n\t\tif (!kws1->kw) {\n\t\t\tkws1->mprev->mnext = kws1->mnext;\n\t\t\tkws1->mnext->mprev = kws1->mprev;\n\t\t\t*kwtodo1 = kws1;\n\t\t\tkwtodo1 = kws1->lcn = &kws1->mprev;\n\t\t\t*kws->lcn = kws1;\n\t\t\tkws->lcn = &kws1->mnext;\n\t\t\t}\n\t\tkws1->kw = kw;\n\t\t}\n\treturn kwtodo1;\n\t}\n\n static void\nbumpToClear(void)\n{\n\tKeyWord **ntc;\n\tsize_t L, L1;\n\n\tL = ToClearEnd - ToClear0;\n\tL1 = L << 1;\n\tntc = (KeyWord**)Alloc(\"bumpToClear\", L1*sizeof(KeyWord*));\n\tmemcpy(ntc, ToClear0, L*sizeof(KeyWord*));\n\tfree(ToClear0);\n\tToClear0 = ntc;\n\tToClear  = ntc + L;\n\tToClearEnd = ntc + L1;\n\t}\n\n static void\nkw_setup2(KWseen *kws)\n{\n\tKWpair kwp, *pkwp;\n\tKWseen *kws1, *kws2, *kws3, *kwtodo, **kwtodo1, **pkws;\n\tKeyWord *kw, *kw1;\n\n\tkwtodo1 = &kwtodo;\n\tfor(;;) {\n\t\tkw = kws->kw;\n\t\tif ((kw1 = kw->kw)) {\n\t\t\tkwnext_setup(kw1, kw->nkw);\n\t\t\tkws2 = kws;\n\t\t\twhile(!kw1->name) {\n\t\t\t\tif (!AVLKWP)\n\t\t\t\t\tAVLKWP = AVL_Tree_alloc(0, (AVL_Elcomp)kwpcmp, Alloc1);\n\t\t\t\tif (kw1->kind & KWKind_Hashed) {\n\t\t\t\t\tkwp.kw = kw1->kw;\n\t\t\t\t\tkwp.kws = 0;\n\t\t\t\t\tpkwp = (KWpair*)AVL_find((const Element*)&kwp, AVLKWP);\n\t\t\t\t\tkws2 = pkwp->kws;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ToClear >= ToClearEnd)\n\t\t\t\t\t\tbumpToClear();\n\t\t\t\t\t*ToClear++ = kw1;\n\t\t\t\t\tkw1->kind |= KWKind_Hashed;\n\t\t\t\t\tpkwp = (KWpair*)KWgetmem(sizeof(KWpair) + sizeof(KWseen));\n\t\t\t\t\tkws1 = (KWseen*)(pkwp + 1);\n\t\t\t\t\tpkwp->kw = kw1->kw;\n\t\t\t\t\tpkwp->kws = kws1;\n\t\t\t\t\tmemset(kws1, 0, sizeof(KWseen));\n\t\t\t\t\tkws1->kw = kw1;\n\t\t\t\t\tkws1->name = kws->name;\n\t\t\t\t\tkws1->lcn = &kws1->mprev;\n\t\t\t\t\tkws1->parent = kws2;\n\t\t\t\t\t*kws2->lcn = 0;\n\t\t\t\t\tfor(pkws = &kws2->mprev;\n\t\t\t\t\t\t(kws3 = *pkws) && !kws3->name;\n\t\t\t\t\t\tpkws = &kws3->mnext);\n\t\t\t\t\tkws1->mnext = *pkws;\n\t\t\t\t\tif (pkws == kws2->lcn)\n\t\t\t\t\t\tkws2->lcn = &kws1->mnext;\n\t\t\t\t\tkws2 = *pkws = kws1;\n\t\t\t\t\tkwnext_setup(kw1->kw, kw1->nkw);\n\t\t\t\t\tkwtodo1 = kw_setup3(kwtodo1, kws1, kw1->kw);\n\t\t\t\t\tAVL_insert((const Element*)pkwp, AVLKWP);\n\t\t\t\t\t}\n\t\t\t\tkw1 = kw1->kwnext;\n\t\t\t\t}\n\t\t\tif (kw->nkw)\n\t\t\t\tkwtodo1 = kw_setup3(kwtodo1, kws2, kw1);\n\t\t\t}\n\t\t*kwtodo1 = 0;\n\t\tif (!kwtodo)\n\t\t\tbreak;\n\t\tkws = kwtodo;\n\t\tkw = kws->kw;\n\t\tif (!(kwtodo = kwtodo->mprev))\n\t\t\tkwtodo1 = &kwtodo;\n\t\t}\n\t}\n\n static KeyWord *\nnidr_identifier_relaxed(const char *name)\n{\n\tKWseen *kws, *kws1;\n\tKeyWord *kw;\n\tint tryagain;\n\n\tkw_finish1(KW_cur);\n top:\n\tKW_cur = kws = *KWhash(name, 0);\n\tif ((kw = kws->kw)) {\n\t\tcurid = kw;\n\t\tif (kws->lcn)\n\t\t\tsquawk(\"'%s' already seen\", kw->name);\n\t\telse {\n\t\t\tif (kws->comment) {\n\t\t\t\tkw->comment = kws->comment;\n\t\t\t\tkws->comment = 0;\n\t\t\t\t}\n\t\t\tkws->lcn = &kws->mprev;\n\t\t\tkws1 = kws->parent;\n\t\t\t*kws1->lcn = kws;\n\t\t\tkws1->lcn = &kws->mnext;\n\t\t\tif (kw->kw)\n\t\t\t\tkw_setup2(kws);\n\t\t\tif (kw->kind & KWKind_Dynlib) {\n\t\t\t\tkw = kw_insert(kw, &tryagain);\n\t\t\t\tif (kw->kw) {\n\t\t\t\t\tkws->kw = kw;\n\t\t\t\t\tkw_setup2(kws);\n\t\t\t\t\t}\n\t\t\t\tif (tryagain)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn (KeyWord*)kws;\t/* just needs to be nonzero; won't be dereferenced */\n\t}\n\n static void\nnum_expected(KeyWord *kw, int n)\n{\n\tsquawk(\"expected numerical value%s for %s, not quoted strings\",\n\t\t\"s\" + (n == 1), kw->name);\n\t}\n\n static void\nkw_process(KWseen *kws)\n{\n\tKWseen *kws1;\n\tKeyWord *kw;\n\tReal *r;\n\tUint k;\n\tint i, n;\n\n\tkw = kws->kw;\n\tif (kw->name) {\n\t\tif (kws != KWs0 && !nidr_identifier_strict(kw->name))\n\t\t\tbotch(\"nidr_identifier_strict did not find \\\"%s\\\"\", kw->name);\n\t\tif ((n = KWval.n = kws->nvals)) {\n\t\t\tKWval.i = 0;\n\t\t\tKWval.r = 0;\n\t\t\tKWval.s = 0;\n\t\t\tKWval.rstate = 0;\n\t\t\tswitch(k = kw->kind & KWKind_Mask) {\n\t\t\t  case 0:\n\t\t\t\tsquawk(\"No values may be specified for %s\", kw->name);\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Int:\n\t\t\t\tif (!(r = kws->rvals)) {\n\t\t\t\t\tnum_expected(kw,n);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tKWval.i = (int*)KWvalbuf;\n\t\t\t\tfor(i = 0; i < n; i++)\n\t\t\t\t\tKWval.i[i] = (int)r[i];\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Real:\n\t\t\t\tif (!(r = kws->rvals)) {\n\t\t\t\t\tnum_expected(kw,n);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tKWval.r = r;\n\t\t\t\tbreak;\n\n\t\t\t  case KWKind_Str:\n\t\t\t\tif (!(KWval.s = (const char **)kws->svals))\n\t\t\t\t\tsquawk(\"expected string value%s for %s\",\n\t\t\t\t\t\t\"s\" + (n == 1), kw->name);\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t*kws->lcn = 0;\n\tfor(kws1 = kws->mprev; kws1; kws1 = kws1->mnext)\n\t\tkw_process(kws1);\n\t}\n\n static void\nkw_finish2(void)\n{\n\tKWseen *kws, *kwe;\n\n\tkw_finish1(KW_cur);\n\tkwe = &KWmissing;\n\tfor(kws = KWmissing.mnext; kws != kwe; kws = kws->mnext) {\n\t\tsquawk(\"unrecognized identifier '%s'\", kws->name);\n\t\t}\n\tKWmissing.mnext = KWmissing.mprev = &KWmissing;\n\tkw_process(KWs0);\n\tKWs0 = 0;\n\tAVL_Clear();\n\t}\n\n static void\nkw_finish3(void)\n{\n\tKWmblk1 = KWmblk0;\n\tKWmem0 = (char*)(KWmblk0 + 1);\n\tKWmem1 = KWmem0 + KWmblk_gulp;\n\tKW_p = KW_pe = 0;\n\t}\n\n void (*nidr_bufr)(Real,int) = nidr_bufr_relaxed;\n void (*nidr_bufs)(const char*) = nidr_bufs_relaxed;\n KeyWord *(*nidr_identifier)(const char*) = nidr_identifier_relaxed;\n\n void\nnidr_set_strict(int n)\n{\n\tif ((strict = n)) {\n\t\tnidr_bufr = nidr_bufr_strict;\n\t\tnidr_bufs = nidr_bufs_strict;\n\t\tnidr_identifier = nidr_identifier_strict;\n\t\t}\n\telse {\n\t\tnidr_bufr = nidr_bufr_relaxed;\n\t\tnidr_bufs = nidr_bufs_relaxed;\n\t\tnidr_identifier = nidr_identifier_relaxed;\n\t\t}\n\t}\n\n int\nnidr_cleanup(void)\n{\n\tKWmblk *mb, *mb1;\n\tSbuf *sb, *sb1;\n\n\tif (curkw)\n\t\tnidr_keyword_finish();\n\tif (dumpfile) {\n\t\tif (OutsideComment)\n\t\t\tdumpcomment(&OutsideComment);\n\t\tif (dumpfile != stdout) {\n\t\t\tfclose(dumpfile);\n\t\t\tdumpfile = 0;\n\t\t\t}\n\t\tif (nidr_comment)\n\t\t\tcomment_reset();\n\t\t}\n\tif (ToClear0) {\n\t\tfree(ToClear0);\n\t\tToClear = ToClear0 = 0;\n\t\t}\n\tif ((mb1 = KWmblk0)) {\n\t\tKWmblk0 = 0;\n\t\tdo {\n\t\t\tmb = mb1;\n\t\t\tmb1 = mb->next;\n\t\t\tfree(mb);\n\t\t\t} while(mb1);\n\t\t}\n\tif (KWvalbuf) {\n\t\tfree(KWvalbuf);\n\t\tKWvalbuf = 0;\n\t\t}\n\tif ((sb1 = KWsbuf0.next)) {\n\t\tKWsbuf0.next = 0;\n\t\tdo {\n\t\t\tsb = sb1;\n\t\t\tsb1 = sb->next;\n\t\t\tfree(sb);\n\t\t\t} while(sb1);\n\t\t}\n\tif (AVLT)\n\t\tAVL_Clear();\n\treturn nidr_parse_error();\n\t}\n\n void\nnidr_setup(const char *parser, FILE *df)\n{\n\tconst char *s;\n\tint comkeep, oneline;\n\n\tif (!(s = parser))\n\t\treturn;\n\tif (!strncmp(s,\"nidr\",4))\n\t\ts += 4;\n\tif (!strncmp(parser,\"strict\",6)) {\n\t\tnidr_set_strict(1);\n\t\ts += 6;\n\t\t}\n\tcomkeep = oneline = 0;\n\tif (*s == '-') for(;;) {\n\t\tswitch(*++s) {\n\t\t  case '1':\n\t\t\t++oneline;\n\t\t\tcontinue;\n\t\t  case 'p':\n\t\t\t++primary;\n\t\t\tcontinue;\n\t\t  case 'c':\n\t\t\t++comkeep;\n\t\t\tcontinue;\n\t\t  }\n\t\tbreak;\n\t\t}\n\tif (df)\n\t\tdumpfile = df;\n\telse if (s[0] == ':' && s[1]) {\n\t\tif (s[1] == '-' && !s[2])\n\t\t\tdumpfile = df = stdout;\n\t\telse {\n\t\t\tdumpfile = df = fopen(++s,\"w\");\n\t\t\tif (!dumpfile) {\n\t\t\t\tfprintf(stderr, \"Cannot open \\\"%s\\\"\\n\", s);\n\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (df) {\n\t\tif (oneline)\n\t\t\tdumpvals = dumpvals1;\n\t\tif (comkeep)\n\t\t\tcomment_setup();\n\t\t}\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/nidrgen.l": "%{\n/*********************************************************************\nCopyright 2008, 2010 Sandia Corporation.  Under the terms of Contract\nDE-AC04-94AL85000 with Sandia Corporation, the U.S. Government\nretains certain rights in this software.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n* Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n* Neither the name of Sandia Corporation nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n***********************************************************************/\n\n#include <ctype.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"nidr.h\"\t/* for KeyWordKind */\n\n#ifndef NO_NIDR_DYNLIB\ntypedef KeyWord *(*KW_ADD)(void);\n#ifdef _WIN32\n#include <windows.h>\n#define dlopen(x,y) LoadLibrary(x)\n#define find_dlsym(a,b,c) (a = (KW_ADD)GetProcAddress((HINSTANCE)(b),c))\n#define dlclose(x) FreeLibrary((HMODULE)x)\n#define NO_DLERROR\n#else\n#include <dlfcn.h>\n#define find_dlsym(a,b,c) (a = (KW_ADD)dlsym(b,c))\n#undef NO_DLERROR\n#endif\n#endif\n\n#ifndef DMBLK_GULP\n#define DMBLK_GULP 1024\n#endif\n#ifndef DMLBK_SGULP\n#define DMBLK_SGULP 16000\n#endif\n#ifndef MBLK_GULP\n#define MBLK_GULP 8191\n#endif\n#ifndef KWSTACKLEN\n#define KWSTACKLEN 100\t/*should be overkill*/\n#endif\n#ifndef DEFTAGLEN\n#define DEFTAGLEN 2048\t/* should be overkill*/\n#endif\n\n typedef union\nYYSTYPE { char *s; } YYSTYPE;\n\n enum LastSeen {\n\tSaw_kwname\t= 1,\n\tSaw_type\t= 2,\n\tSaw_func\t= 3,\n\tSaw_dflt\t= 4,\n\tSaw_dfltname\t= 5,\n\tSaw_lt\t\t= 6,\n\tSaw_le\t\t= 7,\n\tSaw_ge\t\t= 8,\n\tSaw_gt\t\t= 9,\n\tSaw_desc\t= 10,\n\tSaw_group\t= 11,\n\tSaw_tag\t\t= 12,\n\tSaw_len\t\t= 13,\n\tSaw_dy\t\t= 14\n\t};\n\n static const char *tokname[] = {\n\t\"<bug>\",\n\t\"kwname\",\n\t\"type\",\n\t\"{funcspec}\",\n\t\":=\",\n\t\"#define name for :=\",\n\t\"<\",\n\t\"<=\",\n\t\">=\",\n\t\">\",\n\t\"DESC\",\n\t\"GROUP\",\n\t\"TAG\",\n\t\"LEN\"\n\t};\n\n enum ParState {\n\t/* parstate values... */\n\tPPar_emtpy\t= 0,\n\tPPar_starting\t= 1,\n\tPPar_started\t= 2,\n\tPPar_leftpar\t= 3,\n\tDupchecking\t= 4,\n\tDupchecked\t= 5,\n\tPrinting\t= 6,\n\tKwStacked\t= 7,\n\tSorted\t\t= 8,\n\tLeftput\t\t= 9,\n\tParchecked\t= 10\n\t};\n\n /* values for lastseen also include single characters ( [ { } ] ) ; */\n\n /* enums to make constants visible to debuggers */\n enum {\n\tDMblk_gulp\t= DMBLK_GULP,\n\tDmblk_sgulp\t= DMBLK_SGULP,\n\tMblk_gulp\t= MBLK_GULP,\n\tKW_stacklen\t= KWSTACKLEN,\n\tBr_stacklen\t= 2*KW_stacklen,\n\tDHTlen\t\t= 997,\n\tDHTfactor\t= 43,\n\tHTlen\t\t= 127,\n\tKWPlen\t\t= 32,\n\tKWOUTlen0\t= 128 };\n\n typedef struct Defhash Defhash;\n typedef struct DefhashHead DefhashHead;\n typedef struct DefhashTab DefhashTab;\n typedef struct HashHead HashHead;\n typedef struct KWctx KWctx;\n typedef struct Mblk Mblk;\n typedef struct Taghash Taghash;\n typedef struct StrList StrList;\n\n struct\nDefhashHead {\n\tDefhashHead *hnext, *thread;\n\tchar *name;\n\t};\n\n struct\nDefhash {\n\tDefhashHead hh;\n\tchar *value;\n\tint qkeep;\n\t};\n\n struct\nTaghash {\n\tDefhashHead hh;\n\tKWctx *kw;\n\tint uses;\n\t};\n\n struct\nDefhashTab {\n\tDefhashHead *Tab[DHTlen];\n\tDefhashHead *lastdh;\n\tsize_t nalloc;\t/* size of new entry allocations in units of sizeof(void*) */\n\tint nent;\n\t};\n\n struct\nMblk {\n\tMblk *next;\n\tvoid *stuff[Mblk_gulp];\n\t};\n\n struct\nHashHead { HashHead *hnext, *hprev; };\n\n struct\nStrList {\n\tHashHead h;\n\tStrList *next;\n\tchar *val;\n\tint Lineno;\n\tint primary;\n\tint seqno;\n\tint needrev;\n\t};\n\n struct\nKWctx {\n\tKWctx *next;\n\tStrList *names;\t/* list of name and aliases */\n\tchar *name1;\t/* first name (for tagout) */\n\tKWctx *kw;\t/* list of contained keywords */\n\tKWctx *master;\t/* non-null ==> this is an alias; use master's kwkno */\n\tKWctx *pmaster;\t/* used in computing paoff */\n\tKWctx *pparent;\t/* paren parent, for ((...)|(...) ...) */\n\tKWctx *rparent;\t/* \"real\" parent, for stuff inside ((...)) */\n\tStrList *funcs;\t/* pre- and post order functions and (void*) args */\n\tchar *Br_top;\t/* Br_top when this keyword began */\n\tchar *lb;\t/* lower bound (if kind & KWKind_Lb is nonzero) */\n\tchar *ub;\t/* upper bound (if kind & KWKind_Ub is nonzero) */\n\tchar *init;\t/* initial value (if kind & KWKind_init is nonzero) and */\n\t\t\t/* kind & KWKind_Mask is 1 or 2 (KWKind_Int or KWKind_Real) */\n\tchar *cinit;\t/* initial value for STRING-valued keyword,\t*/\n\t\t\t/* ==> (kind & (KWKind_Mask | KWKind_init))\t*/\n\t\t\t/*\t== (KWKind_Str | KWKind_init)\t\t*/\n\tchar *defname;\t/* name of preprocessor token to be #defined */\n\tchar *desc;\n\tchar *dylib;\n\tchar *group;\n\tchar *tag;\n\tchar *len;\t/* keyword giving array length */\n\tsize_t dtnext;\t/* for adjusting deftag when this keyword goes out of scope */\n\tsize_t name1len;\n\tint alt;\t/* alternative group number of this keyword */\n\tint kind;\t/* kind of values for this keyword */\n\tint kno;\t/* number of this keyword, for generating kw_n names */\n\tint kwkno;\t/* number of this keyword's kw array (if any) */\n\tint kwknop;\t/* if this is a pparent and has a pparent, kwkno for this and parents */\n\tint nalt;\t/* number of alternative groups in contained keywords */\n\tint nfcn;\t/* number of function and arg entries in funcs */\n\tint nkw;\t/* number of contained keywords */\n\tint nreq;\t/* number of required elements in contained keywords */\n\tint req;\t/* required group for this keyword (0 if optional) */\n\tenum ParState parstate;\t/* state in handling ((...)) */\n\tint altoffset;\t/* for expand */\n\tint reqoffset;\t/* for expand */\n\tint level;\n\tint objno;\t/* for kwcomp2 */\n\tint agroup;\t/* for GuiKeyWord */\n\tint paoff;\t/* offset of primary keyword */\n\t};\n\n static int lastagroup, lastobjno, nalias, seqno;\n\n Defhash *lastdef;\n DefhashTab DHTab, TagTab;\n FILE *mtagout, *tagin, *tagout;\n HashHead HTab[HTlen];\n KWctx KWbase, *lastkw, *lastkw1;\n KWctx *KWStack[KW_stacklen], **KWtop = KWStack;\n Mblk FirstMblk, *CurMblk = &FirstMblk;\n YYSTYPE yyval;\n char Br_stack[Br_stacklen], *Br_top = Br_stack;\n char deftag[DEFTAGLEN], *dtend = deftag + DEFTAGLEN - 2, *dtnext = deftag;\n char *infname, *lasttag, *progname, *specfile, *tagfname;\n int Lineno = 1, dfltgroup = 1, startwarn = 1, wantfuncs = 1;\n int brace, btype, dupnames, dynlibseen, dynline, expand, guikeywds, ignoretags;\n int kwmult, lastkno, lastseen, liberror, libexpand, missing, needcomma, nsquawk;\n int or_mode, saweof;\n size_t mbavail = Mblk_gulp;\n void **mbnext = FirstMblk.stuff;\n static void Eat_comment(void);\n static void Keywd(const char *);\n static void Saw_num(const char*);\n static void Saw_quote(void);\n static void Saw_tok(int, int);\n\n /* Possible values for *Br_top:\n //\t 0  ==> empty (for Br_stack[0] only)\n //\t'(' ==> open paren seen, awaiting ')'\n //\t'[' ==> open square bracket, awaiting ']'\n */\n\n static void\nbotch(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s:\\n\\tbotch on line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\texit(1);\n\t}\n\n static void\nsquawk(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"\\n%s: line %d\", progname, Lineno);\n\tif (infname)\n\t\tfprintf(stderr, \" of \\\"%s\\\"\", infname);\n\tfprintf(stderr, \":\\n\\t\");\n\tvfprintf(stderr, fmt, ap);\n\tfputs(\".\\n\", stderr);\n\tva_end(ap);\n\t++nsquawk;\n\t}\n\n static void*\nMalloc(size_t L, const char *where)\n{\n\tvoid *rv = malloc(L);\n\tif (!rv)\n\t\tbotch(\"malloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n static void*\nRealloc(void *rv, size_t L, const char *where)\n{\n\trv = realloc(rv, L);\n\tif (!rv)\n\t\tbotch(\"ralloc(%lu) failure in %s()\", (unsigned long)L);\n\treturn rv;\n\t}\n\n void\nunexpected(const char *what)\n{ botch(\"unexpected \\\"%s\\\"\", what); }\n\n static void *\nAlloc(size_t len)\n{\n\tMblk *mb;\n\tsize_t L;\n\tvoid *rv;\n\n\tL = (len + sizeof(void*) - 1)/sizeof(void*);\n\tif (L >= Mblk_gulp)\n\t\tbotch(\"Alloc(%lu) failure\", (unsigned long)len);\n\tif (L > mbavail) {\n\t\tif (!(mb = CurMblk->next)) {\n\t\t\tmb = (Mblk*)Malloc(sizeof(Mblk), \"Alloc\");\n\t\t\tCurMblk->next = mb;\n\t\t\t}\n\t\tCurMblk = mb;\n\t\tmbavail = Mblk_gulp;\n\t\tmbnext = mb->stuff;\n\t\tmb->next = 0;\n\t\tmemset(mbnext, 0, sizeof(mb->stuff));\n\t\t}\n\trv = mbnext;\n\tmbnext += L;\n\tmbavail -= L;\n\treturn rv;\n\t}\n\n StrList *\nnew_StrList(const char *s, StrList *nxt)\n{\n\tsize_t L = strlen(s) + 1;\n\tStrList *rv = (StrList*)Alloc(sizeof(StrList) + L);\n\tstrcpy(rv->val = (char*)(rv + 1), s);\n\tif ((rv->next = nxt))\n\t\trv->needrev = 1;\n\trv->Lineno = Lineno;\n\treturn rv;\n\t}\n\n static void\nAlias(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\n\tif (lastseen != Saw_kwname)\n\t\tbotch(\"ALIAS out of place\");\n\tkw = lastkw;\n\tfor(s += 6; *s <= ' '; s++);\n\tsl = kw->names = new_StrList(s, kw->names);\n\t++nalias;\n\tsl->seqno = ++seqno;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nreqchk(const char *a, const char *s)\n{\n\tif (a)\n\t\twhile(*a)\n\t\t\tif (*a++ == lastseen)\n\t\t\t\treturn;\n\tbotch(\"\\\"%s\\\" out of place\", s);\n\t}\n\n static void\nreqchk1(const char *a, const char *s)\n{\n\tint c;\n\n\tif (*Br_top != *s) {\n\t\tif ((c = *Br_top)) {\n\t\t\tswitch(c) {\n\t\t\t case '[': c = ']'; break;\n\t\t\t case '(': c = ')'; break;\n\t\t\t default:  c = '?';\n\t\t\t }\n\t\t\tbotch(\"Missing '%c'\", c);\n\t\t\t}\n\t\telse\n\t\t\ta = 0;\n\t\t}\n\treqchk(a, s+1);\n\t}\n\n static void\nBar(void)\n{\n\tstatic char allowed[] = { /*(*/ ')', Saw_kwname, Saw_type, 0 };\n\treqchk(KWtop - KWStack > 1 || KWtop[0]->kw ? allowed : \"\", \"|\");\n\tlastseen = '|';\n\tlastkw = lastkw1 = 0;\n\tor_mode = 1;\n\t}\n\n static void\nLpar(void)\n{\n\tKWctx *kw;\n\tint olastseen = lastseen;\n\tstatic char allowed[] = { '(', '[', '|', ']', ')', Saw_kwname, Saw_type, 0 };\n\n\treqchk(allowed, \"(\"/*)*/);\n\tlastseen = '('; /*)*/\n\tif (KWtop > KWStack) {\n\t\tkw = KWtop[0];\n\t\tif (or_mode && kw->parstate == PPar_leftpar && !kw->kw) {\n\t\t\tdtnext = deftag + kw->dtnext;\n\t\t\t--KWtop;\n\t\t\tKeywd(0);\n\t\t\tkw->pparent = KWtop[0];\n\t\t\t}\n\t\telse if (olastseen == '(' || olastseen == '[' /*])*/)\n\t\t\tKeywd(0);\n\t\tlastseen = '(' /*)*/;\n\t\t}\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\t*Br_top = '('; /*)*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLsqb(void)\n{\n\tstatic char allowed[] = { /*([*/ ']', ')', Saw_kwname, Saw_type, 0 };\n\treqchk(allowed, \"[\"/*]*/);\n\tif (++Br_top - Br_stack >= Br_stacklen)\n\t\tbotch(\"Br_stack overflow\");\n\tlastseen = *Br_top = '['; /*]*/\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRpar(void)\n{\n\tstatic char allowed[] =  {/*[(*/ ')', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"()\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\tif (!KWtop[0]->kw && KWtop - KWStack > 2\n\t && KWtop[-1]->parstate == PPar_starting)\n\t\tKWtop[-1]->Br_top = Br_top;\n\t--KWtop;\n\tlastseen = /*(*/ ')';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nRsqb(void)\n{\n\tstatic char allowed[] = {/*(*/')', '[', ']', Saw_kwname, Saw_type, 0 };\n\treqchk1(allowed, \"[]\");\n\tif (KWtop <= KWStack)\n\t\tbotch(\"bug: KW stack error\");\n\t--Br_top;\n\t--KWtop;\n\tlastseen = /*[*/ ']';\n\tlastkw = lastkw1 = 0;\n\t}\n\n static void\nLbrace(void)\n{\n\tif (brace++ || (lastseen != Saw_kwname && lastseen != Saw_type))\n\t\tunexpected(\"{\");\n\tlastseen = '{'; /*}}*/\n\t}\n\n static void\nRbrace(void)\n{\n\tif (--brace || (lastseen != Saw_func && lastseen != ';'))\n\t\t/*{{*/unexpected(\"}\");\n\tlastseen = Saw_type;\n\t}\n\n static void\nType(int n, const char *s)\n{\n\tif (lastseen != Saw_kwname || !lastkw)\n\t\tbotch(\"type %s out of place\", s);\n\tlastkw->kind |= n;\n\tlastkw = 0;\n\tlastseen = Saw_type;\n\t}\n\n static char *\ndef_name(const char *s0)\n{\n\tchar *s;\n\tconst char *s1;\n\tsize_t L, L1;\n\tstatic char *slast, *snext;\n\n\ts1 = s0;\n\twhile(*s1++);\n\tL = s1 - s0;\n\tif (snext + L > slast) {\n\t\tsnext = (char*)Malloc(L1 = Dmblk_sgulp + L, \"def_name\");\n\t\tslast = snext + L1;\n\t\t}\n\tstrcpy(s = snext, s0);\n\tsnext += L;\n\treturn s;\n\t}\n\nstatic void **DHHlast, **DHHnext;\t/* Could be private to DHHlookup, but here */\n\t\t\t\t\t/* to make them visible to debuggers. */\n static DefhashHead *\nDHHlookup(const char *s0, DefhashTab *Htab, int add)\n{\n\tDefhashHead *h, **hp;\n\tconst char *s;\n\tsize_t L;\n\tunsigned int c, x;\n\n\tfor(x = 0, s = s0; (c = *(unsigned char*)s); ++s)\n\t\tx += DHTfactor*x + c;\n\tx %= DHTlen;\n\tfor(hp = &Htab->Tab[x]; (h = *hp); hp = &h->hnext) {\n\t\tif (!strcmp(s0, h->name))\n\t\t\treturn h;\n\t\t}\n\tif (!add)\n\t\treturn h;\n\tHtab->nent++;\n\tif (DHHnext + Htab->nalloc >= DHHlast) {\n\t\tDHHnext = (void**)Malloc(L = DMblk_gulp*sizeof(void*), \"DHHlookup\");\n\t\tDHHlast = DHHnext + DMblk_gulp;\n\t\tmemset(DHHnext, 0, L);\n\t\t}\n\t*hp = h = (DefhashHead*)DHHnext;\n\tDHHnext += Htab->nalloc;\n\th->name = def_name(s0);\n\th->thread = Htab->lastdh;\n\treturn Htab->lastdh = h;\n\t}\n\n static void\nbothplaces(KWctx *kw, const char *name)\n{ squawk(\"For %s, %s appears both in specfile and tagfile\", kw->names->val, name); }\n\n static void\ntagimport(KWctx *kw, KWctx *tw)\n{\n\ttypedef struct KWimport KWimport;\n\tstruct KWimport { const char *name; size_t off; };\n\tstatic KWimport Imp[] = {\n\t\t{ \"lower bound\",\toffsetof(KWctx,lb) },\n\t\t{ \"upper bound\",\toffsetof(KWctx,ub) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,init) },\n\t\t{ \"default (:= value)\",\toffsetof(KWctx,cinit) },\n\t\t{ \"defname\",\t\toffsetof(KWctx,defname) },\n\t\t{ \"DESC\",\t\toffsetof(KWctx,desc) },\n\t\t{ \"GROUP\",\t\toffsetof(KWctx,group) },\n\t\t{ \"LEN\",\t\toffsetof(KWctx,len) },\n\t\t{0}};\n\tKWimport *ki;\n#define field(k,n) *(char**)((char*)k+n)\n\tfor(ki = Imp; ki->name; ++ki) {\n\t\tif (field(tw,ki->off)) {\n\t\t\tif (field(kw,ki->off))\n\t\t\t\tbothplaces(kw, ki->name);\n\t\t\telse\n\t\t\t\tfield(kw,ki->off) = field(tw,ki->off);\n\t\t\t}\n\t\t}\n#undef field\n\t}\n\n#ifndef NO_NIDR_DYNLIB\n\nstatic const char *typename[8] = {\n\t\"no value\", \"INTEGER\", \"REAL\", \"STRING\",\n\t\"(Bug! no value LIST)\", \"INTEGERLIST\", \"REALLIST\", \"STRINGLIST\" };\n\n static int\nkwseqnocomp(const void *a, const void *b)\n{\n\tconst KeyWordx *ka, *kb;\n\n\tka = *(KeyWordx**)a;\n\tkb = *(KeyWordx**)b;\n\treturn (int)ka->seqno - (int)kb->seqno;\n\t}\n\n static void\nLsqbpar(void)\n{\n\tLsqb();\n\tLpar();\n\t}\n\n static void\nRparsqb(void)\n{\n\tRpar();\n\tRsqb();\n\t}\n\n static void\nNobrak(void) {}\n\n typedef struct\nKW_Cstak { KeyWordx **Cstak; Uint n, nmax; } KW_Cstak;\n\n static void kw_finish(int);\n static void kw_insert(KeyWord*, KW_Cstak*, int);\n\n static KeyWord*\nkw_stakadj(KeyWord *kw, KW_Cstak *Stk, int needbar, int n0, KeyWord *okw3)\n{\n\tKeyWordx *kw1, *kw2, **x;\n\tUint i, j, k, nst, nz;\n\n\tkw1 = (KeyWordx*)kw;\n\tnz = 0;\n\twhile(!kw1[++nz].kw.name);\n\tif (nz == 1 && *kw1[nz].kw.name)\n\t\tokw3 = 0;\n\tnst = Stk->n;\n\tx = Stk->Cstak;\n\tkw2 = (KeyWordx*)kw1->kw.kw;\n\tfor(i = 0; i < nst; ++i) {\n\t\tif (x[i]->kw.kw == &kw2->kw) {\n\t\t\tj = i;\n\t\t\t++kw1;\n\t\t\t/* No need to test kw1->kw.name in the following loop */\n\t\t\t/* as the == test will fail if kw1->kw.name is nonzero. */\n\t\t\twhile(++j < nst && x[j]->kw.kw == kw1->kw.kw)\n\t\t\t\t++kw1;\n\t\t\tk = nz - (j-i);\n\t\t\tgoto have_jk;\n\t\t\t}\n\t\t}\n\tk = nz;\n\tj = n0;\n have_jk:\n\twhile(nst > j) {\n\t\tkw_insert(&x[--nst]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (needbar)\n\t\tBar();\n\tif (k) {\n\t\tif (nst + k > Stk->nmax)\n\t\t\tx = Stk->Cstak = (KeyWordx**)Realloc(x,\n\t\t\t\t(Stk->nmax = 2)*sizeof(KeyWordx*), \"kw_stakadj\");\n\t\tdo {\n\t\t\tif (kw1->kw.kw != okw3)\n\t\t\t\tLpar();\n\t\t\tx[j++] = kw1++;\n\t\t\t}\n\t\t\twhile(--k);\n\t\tnst = j;\n\t\t}\n\tStk->n = nst;\n\tif (!*kw1->kw.name)\n\t\treturn 0;\n\treturn &kw1->kw;\n\t}\n\n static int\nsame_funcs(KeyWordx *kw1, KeyWordx *kw2)\n{\n\tKeyWordx *kw3, *kw4;\n\n\tif (!kw1->kw.nkw || !kw2->kw.nkw)\n\t\treturn 0;\n\tkw3 = (KeyWordx*)kw1->kw.kw;\n\tkw4 = (KeyWordx*)kw2->kw.kw;\n\tif (kw3 == kw4)\n\t\treturn 1;\n\tif (kw4->kw.name)\n\t\treturn 0;\n\tkw4 = (KeyWordx*)kw4->kw.kw;\n\treturn kw3 == kw4;\n\t}\n\n static char *\nStrCpy(const char *s)\n{\n\tchar *t;\n\tsize_t L;\n\n\tif (!s)\n\t\treturn 0;\n\tL = strlen(s);\n\tt = (char*)Alloc(L+1);\n\tstrcpy(t,s);\n\treturn t;\n\t}\n\n static int Saw_name(const char*);\n static void Saw_stok(int, size_t);\n\n static void\nkw_insert(KeyWord *kw, KW_Cstak *Stk, int top)\n{\n\tenum { NKW0 = 32 };\n\tKeyWord *kw3, *kw30, *okw3;\n\tKeyWordx *kw0, *kw1, *kw2, *kw4, **x, *x0[NKW0];\n\tUint i, j, k, knd, nkw, nst0, nst1;\n\tchar buf[32];\n\tint alt2, incc, needbar, needbar1, samef0, samef1;\n\ttypedef void (*Brak)(void);\n\tBrak Lbrak, Rbrak;\n\n\tkw1 = (KeyWordx*)kw->kw;\n\twhile(!kw1->kw.name)\n\t\t++kw1;\n\tnkw = kw->nkw;\n\tx = x0;\n\tif (nkw > NKW0)\n\t\tx = (KeyWordx**)Malloc(nkw * sizeof(KeyWordx*), \"kw_insert\");\n\tfor(i = 0; i < nkw; ++i)\n\t\tx[i] = kw1++;\n\tif (nkw > 1)\n\t\tqsort(x, nkw, sizeof(KeyWordx*), kwseqnocomp);\n\tkw0 = 0;\n\tkw30 = 0;\n\tnst0 = Stk->n;\n\tfor(i = j = samef0 = 0; i < nkw; i = j) {\n\t\tkw1 = x[i];\n\t\tkw2 = 0;\n\t\twhile(++j < nkw) {\n\t\t\tkw2 = x[j];\n\t\t\tif (!kw2->kw.paoff)\n\t\t\t\tbreak;\n\t\t\tkw2 = 0;\n\t\t\t}\n\t\tLbrak = Rbrak = 0;\n\t\tokw3 = kw30;\n\t\tif (top) {\n\t\t\tkw_finish(kw1->kw.kind & KWKind_12);\n\t\t\tkw3 = kw1->kw.kw;\n\t\t\tRbrak = Nobrak;\n\t\t\tgoto nobrak;\n\t\t\t}\n\t\tneedbar = needbar1 = kw0 && kw0->kw.alt == kw1->kw.alt;\n\t\tnst1 = Stk->n;\n\t\talt2 = incc = 0;\n\t\tkw4 = 0;\n\t\tif (kw2) {\n\t\t\talt2 = kw1->kw.alt == kw2->kw.alt;\n\t\t\tkw4 = (KeyWordx*)kw2->kw.kw;\n\t\t\t}\n\t\tif ((kw3 = kw30 = kw1->kw.kw)) {\n\t\t\tif (!kw3->name) {\n\t\t\t\tkw3 = kw_stakadj(kw3, Stk, needbar, nst0, okw3);\n\t\t\t\tneedbar1 = 0;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\twhile(Stk->n > nst0) {\n\t\t\t\t\tif (Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n\t\t\t\t\t\tif (kw4 && kw4->kw.kw == kw3)\n\t\t\t\t\t\t\tincc = 1; /* in contained context */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\t\tRpar();\n\t\t\t\t\t}\n\t\t\t}\n\t\telse while(Stk->n > nst0) {\n\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\tRpar();\n\t\t\t}\n\t\tsamef0 = needbar && same_funcs(kw1,kw0);\n\t\tsamef1 = alt2    && same_funcs(kw1,kw2);\n\t\tif (kw3) {\n\t\t\tif (samef1) {\n\t\t\t\tif (!needbar)\n\t\t\t\t\tLbrak = kw1->kw.req ? Lpar : Lsqbpar;\n\t\t\t\telse if (!samef0 && kw3->name)\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\tkw3 = 0;\n\t\t\t\tgoto barchk;\n\t\t\t\t}\n\t\t\telse if (needbar) {\n\t\t\t\tif (!incc)\n\t\t\t\t\tRbrak = alt2 || kw1->kw.req ? Rpar : Rparsqb;\n\t\t\t\tif (!samef0\n\t\t\t\t && (Stk->n <= nst1\n\t\t\t\t    || !kw0 || kw0->kw.kw != Stk->Cstak[Stk->n-1]->kw.kw))\n\t\t\t\t\tLbrak = Lpar;\n\t\t\t\t}\n\t\t\telse if (kw1->kw.req) {\n\t\t\t\tLbrak = Lpar;\n\t\t\t\tRbrak = Rpar;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tLbrak = Lsqb;\n\t\t\t\tRbrak = Rsqb;\n\t\t\t\tif (alt2) {\n\t\t\t\t\tLbrak = Lsqbpar;\n\t\t\t\t\tRbrak = Rpar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw2) {\n\t\t\t\tif (kw4 && !kw4->kw.name && kw4->kw.kw == kw3)\n\t\t\t\t\tgoto zap_kw3;\n\t\t\t\tif (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3)\n\t\t\t\t\t--Stk->n;\n\t\t\t\t}\n\t\t\telse if (Stk->n > 0 && Stk->Cstak[Stk->n-1]->kw.kw == kw3) {\n zap_kw3:\n\t\t\t\tRbrak = 0;\n\t\t\t\tkw3 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!kw1->kw.req) {\n\t\t\tif (!needbar)\n\t\t\t\tLbrak = Lsqb;\n\t\t\tif (!alt2)\n\t\t\t\tRbrak = Rsqb;\n\t\t\t}\n barchk:\n\t\tif (needbar1)\n\t\t\tBar();\n\t\tif (Lbrak)\n\t\t\tLbrak();\n nobrak:\n\t\tKeywd(kw1->kw.name);\n\t\twhile(++i < j) {\n\t\t\tkw2 = x[i];\n\t\t\tAlias(kw2->kw.name - 6);\t/* Alias will increment by 6 */\n\t\t\t}\n\t\tknd = kw1->kw.kind;\n\t\tif ((k = knd & (KWKind_Mask|KWKind_List)))\n\t\t\tType(k, typename[k]);\n\t\tif ((k = knd & KWKind_Lb)) {\n\t\t\tSaw_tok(knd & KWKind_strictLb ? Saw_gt : Saw_ge, KWKind_Lb);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Lb);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif ((k = knd & KWKind_Ub)) {\n\t\t\tSaw_tok(knd & KWKind_strictUb ? Saw_lt : Saw_le, KWKind_Ub);\n\t\t\tbtype = k;\n\t\t\tsnprintf(buf, sizeof(buf), \"%g\", kw1->kw.Ub);\n\t\t\tSaw_num(buf);\n\t\t\t}\n\t\tif (kw1->init || kw1->cinit) {\n\t\t\tSaw_tok(Saw_dflt, KWKind_init);\n\t\t\tlastdef = 0;\n\t\t\tif (kw1->defname)\n\t\t\t\tSaw_name(kw1->defname);\n\t\t\tif (kw1->init)\n\t\t\t\tSaw_num(kw1->init);\n\t\t\telse\n\t\t\t\tlastkw1->cinit = StrCpy(kw1->cinit);\n\t\t\t}\n\t\tif (kw1->funcs)\n\t\t\tlastkw1->funcs = new_StrList(kw1->funcs, 0);\n\t\telse if (kw1->kw.f.vf && !kw1->kw.f.final) {\n\t\t\tlastkw1->dylib = StrCpy((const char*)kw1->kw.f.vf);\n\t\t\tdynlibseen = 1;\n\t\t\t}\n\t\telse\n\t\t\tlastkw1->funcs = new_StrList(\"0\", 0);\n\t\tlastkw1->desc  = StrCpy(kw1->desc);\n\t\tlastkw1->group = StrCpy(kw1->group);\n\t\tif (kw1->alen) {\n\t\t\tSaw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\tlastkw1->kind |= knd & KWKind_Len1OK;\n\t\t\tSaw_name(kw1->alen);\n\t\t\t}\n\t\tif (Rbrak) {\n\t\t\tif (kw3)\n\t\t\t\tkw_insert((KeyWord*)kw1, Stk, 0);\n\t\t\tRbrak();\n\t\t\t}\n\t\tkw0 = kw1;\n\t\tif (top) {\n\t\t\twhile(Stk->n > 0) {\n\t\t\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\t\t\tRpar();\n\t\t\t\t}\n\t\t\tif (!kw2)\n\t\t\t\tkw_finish(-1);\n\t\t\t}\n\t\t}\n\twhile(Stk->n > nst0) {\n\t\tkw_insert(&Stk->Cstak[--Stk->n]->kw, Stk, 0);\n\t\tRpar();\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nkw_insert1(KeyWord *kw, int top)\n{\n\tKW_Cstak Stk;\n\n\tStk.n = 0;\n\tStk.Cstak = (KeyWordx**)Malloc((Stk.nmax = 64)*sizeof(KeyWordx*), \"kw_insert1\");\n\tif (top) {\n\t\tKWtop = KWStack;\n\t\tKWbase.kw = 0;\n\t\t}\n\tkw_insert(kw, &Stk, top);\n\twhile(Stk.n > 0) {\n\t\tkw_insert(&Stk.Cstak[--Stk.n]->kw, &Stk, 0);\n\t\tRpar();\n\t\t}\n\tfree(Stk.Cstak);\n\t}\n\n static int\nlibread1(const char *kname, const char *lname, Uint n, int allow_top)\n{\n\tKW_ADD kwa;\n\tKeyWord *kw, kw0;\n\tUint i;\n\tconst char *s;\n\tvoid *h, (*Botch)(const char*, ...);\n\n\th = dlopen(lname, RTLD_NOW);\n\tif (!h) {\n\t\tBotch = botch;\n\t\tif (kname && libexpand)\n\t\t\tBotch = squawk;\n#ifndef _WIN32\n\t\tif ((s = dlerror()))\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s:\\n\\t%s\",\n\t\t\t\t\tlname, kname, s);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\":\\n\\t%s\",\n\t\t\t\t\tlname, s);\n\t\telse\n#endif\n\t\t\tif (kname)\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\" for %s\",\n\t\t\t\t\tlname, kname);\n\t\t\telse\n\t\t\t\tBotch(\"Cannot open library \\\"%s\\\"\", lname);\n\t\treturn ++liberror;\n\t\t}\n\tif (!find_dlsym(kwa, h, \"keyword_add\"))\n\t\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", lname);\n\tkw = (*kwa)();\n\tif (!(s = kw->name)) {\n\t\ts = \"<NULL>\";\n\t\tgoto namebotch;\n\t\t}\n\tif (allow_top) {\n\t\tif (strcmp(s, \"KeywordTop\")) {\n\t\t\tif (allow_top == 2) {\n\t\t\t\tmemset(&kw0, 0, sizeof(KeyWord));\n\t\t\t\tkw0.kw = kw;\n\t\t\t\tkw = &kw0;\n\t\t\t\tkw0.nkw = 1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tallow_top = 0;\n\t\t\t}\n\t\telse\n\t\t\tkname = 0;\n\t\t}\n\telse if (kname && strcmp(s, kname)) {\n namebotch:\n\t\tbotch(\"Library %s: expected top keyword to be %s but got %s\",\n\t\t\tlname, kname, s);\n\t\t}\n\tif (kname) {\n\t\ti = kw->kind & (KWKind_Mask|KWKind_List);\n\t\tif (i != n)\n\t\t\tbotch(\"Library %s: expected %s to be %s, but got %s\",\n\t\t\t\tlname, kname, typename[n], typename[i]);\n\t\t}\n\tif (kw->kw)\n\t\tkw_insert1(kw, allow_top);\n\tdlclose(h);\n\treturn 0;\n\t}\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tconst char *kname, *lname;\n\n\tkname = kc->name1;\n\tlname = kc->dylib;\n\tkc->dylib = 0;\n\treturn libread1(kname, lname, kc->kind & (KWKind_Mask|KWKind_List), allow_top);\n\t}\n#else\n\n static int\nlib_read(KWctx *kc, int allow_top)\n{\n\tbotch(\"dlsym(\\\"keyword_add\\\") failed for %s\", kc->dylib);\n\treturn 1;\n\t}\n#endif\n\n static void\nKeywd(const char *s)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2, *kwm, **kwp;\n\tStrList *nam;\n\tTaghash *th;\n\tchar *s1;\n\tint alt, lsave, req;\n\tsize_t L, L1;\n\tstatic char allowed[] = { '(',')','[',']','|', Saw_kwname, Saw_type, 0 };\n\n\tif (tagin)\n\t\tbotch(\"Inappropriate text \\\"%s\\\" in tagfile \\\"%s\\\"\", s, tagfname);\n\tkw1 = *KWtop;\n#ifndef NO_NIDR_DYNLIB\n\tif (kw1->dylib && libexpand && !lib_read(kw1,0))\n\t\tkw1 = *KWtop;\n#endif\n\tkw0 = kw1;\n\tkwm = 0;\n\tif (!kw1->names && s) {\n\t\tswitch(kw1->parstate) {\n\t\t  case PPar_emtpy:\n\t\t\tdo {\n\t\t\t\tkw1->parstate = PPar_starting;\n\t\t\t\tkw1 = kw1->pparent;\n\t\t\t\t}\n\t\t\t\twhile(kw1 && kw1->parstate == PPar_emtpy);\n\t\t\tkw1 = kw0->rparent;\n\t\t\tbreak;\n\t\t  case PPar_starting:\n\t\t\tif (or_mode)\n\t\t\t\tkw1 = kw0->rparent;\n\t\t\telse\n\t\t\t\tkw1->parstate = PPar_started;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\tif (or_mode && !kw1->kw) {\n\t\tkw2 = KWtop[-1];\n\t\tif (!kw2->names && kw2->parstate == PPar_starting)\n\t\t\tkw2 = kw2->rparent;\n\t\tif (s)\n\t\t\tkw1->master = kwm = kw1;\n\t\tkw1 = kw2;\n\t\t}\n\tL = alt = req = 0;\n\tif (s) {\n\t\tkwp = KWStack + kw1->level + 1;\n\t\tif (kwp > KWtop)\n\t\t\tkwp = KWtop;\n\t\twhile(kwp > KWStack) {\n\t\t\tkw2 = *kwp--;\n\t\t\tif (kw2->name1) {\n\t\t\t\tdtnext = deftag + kw2->dtnext;\n\t\t\t\tL = kw2->name1len;\n\t\t\t\tstrcpy(dtnext-L, kw2->name1);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\talt = ++kw1->nalt;\n\t\tif (*Br_top != '['/*]*/ || Br_top == kw1->Br_top) {\n\t\t\treq = ++kw1->nreq;\n\t\t\tif (*Br_top == '(' /*)*/) /* allow [(...)|...] */\n\t\t\t\tfor(s1 = Br_top; --s1 > kw1->Br_top; ) {\n\t\t\t\t\tif (*s1 != '(' /*)*/) {\n\t\t\t\t\t\tif (*s1 == '[' /*]*/) {\n\t\t\t\t\t\t\t--kw1->nreq;\n\t\t\t\t\t\t\treq = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\tif (or_mode) {\n\t\t\talt = --kw1->nalt;\n\t\t\tif (req)\n\t\t\t\treq = --kw1->nreq;\n\t\t\t}\n\t\tif (lastseen)\n\t\t\treqchk(allowed, s);\n\t\tor_mode = 0;\n\t\t}\n\tlastkw = lastkw1 = kw = (KWctx*) Alloc(sizeof(KWctx));\n\tif (!kw0->names)\n\t\tkw->pparent = kw0;\n\tif (s) {\n\t\tkw->names = nam = new_StrList(s,0);\n\t\tkw->name1 = nam->val;\n\t\tkw->name1len = L = strlen(s);\n\t\tfor(kwp = KWtop; kwp > KWStack; --kwp) {\n\t\t\tkw2 = *kwp;\n\t\t\tif (kw2->names) {\n\t\t\t\tif (kwp < KWtop) {\n\t\t\t\t\tL1 = kw2->dtnext + L + 1;\n\t\t\t\t\twhile(++kwp <= KWtop) {\n\t\t\t\t\t\tkw2 = *kwp;\n\t\t\t\t\t\tif (!kw2->name1) {\n\t\t\t\t\t\t\tkw2->name1 = kw->name1;\n\t\t\t\t\t\t\tkw2->name1len = L;\n\t\t\t\t\t\t\tkw2->dtnext = L1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kw1->dylib) {\n\t\t\tlsave = Lineno;\n\t\t\tLineno = dynline; /* Line where DYNLIB appeared */\n\t\t\tsquawk(\"Suppressing DYNLIB for %s to parse contained keywords\",\n\t\t\t\tkw1->names ? kw1->names->val : \"???? (bug!)\");\n\t\t\tLineno = lsave;\n\t\t\tkw1->dylib = 0;\n\t\t\t}\n\t\tnam->primary = KWKind_primary;\n\t\tnam->seqno = ++seqno;\n\t\tkw->next = kw1->kw;\n\t\tkw1->kw = kw;\n\t\tif (lastseen == '(' /*)*/)\n\t\t\tkw->parstate = PPar_leftpar;\n\t\tkw->agroup = lastagroup++;\n\t\t}\n\telse {\n\t\tkw->objno = ++lastobjno;\n\t\tif (!kw1->kw && (kw->rparent = kw1->rparent))\n\t\t\tkw1 = kw->rparent;\n\t\telse\n\t\t\tkw->rparent = kw1;\n\t\talt = kw1->alt;\n\t\treq = kw1->req;\n\t\t}\n\tkw->alt = alt;\n\tkw->req = req;\n\tkw->Br_top = Br_top;\n\tkw->master = kwm;\n\tkw->level = KWtop - KWStack;\n\tif (lastseen == '(' || lastseen == '[' /*])*/ || KWtop == KWStack) {\n\t\tif (++KWtop - KWStack >= KW_stacklen)\n\t\t\tbotch(\"KW stack overflow\");\n\t\t*KWtop = kw;\n\t\t}\n\tlasttag = 0;\n\tif (s) {\n\t\tif (dtnext > deftag)\n\t\t\t*dtnext++ = '/';\n\t\tif (dtnext + L >= dtend)\n\t\t\tbotch(\"deftag overflow\");\n\t\tmemcpy(dtnext, s, L);\n\t\t*(dtnext += L) = 0;\n\t\tif (tagout)\n\t\t\tfprintf(tagout, \"TAG \\\"%s\\\"\\n\", deftag);\n\t\tif (tagfname) {\n\t\t\tif ((th = (Taghash*)DHHlookup(deftag, &TagTab, ignoretags))) {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (mtagout)\n\t\t\t\tfprintf(mtagout, \"TAG \\\"%s\\\" #missing\\n\", deftag);\n\t\t\t}\n\t\t}\n\tkw->dtnext = dtnext - deftag;\n\tif (lastseen == 0)\n\t\tkw->kind = kwmult;\n\tlastseen = Saw_kwname;\n\t}\n\n static void\nkw_finish(int nextkind)\n{\n\tKWctx *kw;\n\n\tif (*Br_top)\n\t\tbotch(\"unmatched '%c'\", *Br_top);\n\tif (KWtop - KWStack > 1)\n\t\tbotch(\"bug: KW stack botch in kw_finish\");\n\tif (KWtop > KWStack) {\n\t\tkw = *KWtop;\n\t\tif (kw->dylib && libexpand)\n\t\t\tlib_read(kw, nextkind == -1);\n\t\t}\n\tKWtop = KWStack;\n\tdtnext = deftag;\n\tlastseen = 0;\n\tkwmult = nextkind < 0 ? 0 : nextkind;\n\t}\n\n static void\nfuncbotch(KWctx *kw)\n{\n\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions cannot be used with DYNLIB\"\n\t\t\".\\n\\t\\tThey must be supplied by the dynamically loaded library\",\n\t\tkw->names->val);\n\t}\n\n static void\nFnc(char *s)\n{\n\tKWctx *kw;\n\n\tif (!(kw = lastkw1))\n\t\tbotch(\"misplaced {...}\");\n\tif (++kw->nfcn > 4)\n\t\tbotch(\"too many functions in {...}\");\n\telse if (kw->dylib)\n\t\tfuncbotch(kw);\n\telse if (kw->kind & KWKind_Libname)\n\t\tbotch(\"Keyword %s:\\n\\t\\t\\\"start\\\" and \\\"final\\\" functions \"\n\t\t\t\"cannot be used with LIBNAME.\",\n\t\t\tkw->names->val);\n\tkw->funcs = wantfuncs ? new_StrList(s, kw->funcs) : 0;\n\tlastseen = Saw_func;\n\t}\n\n static const char*\ntname_adj(const char *tname, int what, int kbits)\n{\n\tUint k = lastkw1->kind;\n\n\tswitch(what) {\n\t case Saw_lt:\n\t\tif (k & KWKind_caneqUb)\n\t\t\ttname = \"<=\";\n\t\tbreak;\n\t case Saw_le:\n\t\tif (k & KWKind_strictUb)\n\t\t\ttname = \"<\";\n\t\tbreak;\n\t case Saw_ge:\n\t\tif (k & KWKind_strictLb)\n\t\t\ttname = \">\";\n\t\tbreak;\n\t case Saw_gt:\n\t\tif (k & KWKind_caneqLb)\n\t\t\ttname = \">=\";\n\t }\n\treturn tname;\n\t}\n\n static void\nSaw_tok(int what, int kbits)\n{\n\tconst char *tname;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (lastkw1->kind & kbits) {\n\t\t\ttname = tokname[what];\n\t\t\tif (kbits & (KWKind_Lb | KWKind_Ub))\n\t\t\t\ttname = tname_adj(tname, what, kbits);\n\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\ttname, lastkw1->names->val);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static void\nSaw_stok(int what, size_t woff)\n{\n\tStrList *sl;\n\n\tif ((lastseen == Saw_kwname || lastseen == Saw_type) && lastkw1) {\n\t\tif (*(void**)((char*)lastkw1 + woff)) {\n\t\t\tif ((sl = lastkw1->names))\n\t\t\t\tbotch(\"%s already seen for keyword %s\",\n\t\t\t\t\ttokname[what], sl->val);\n\t\t\telse\n\t\t\t\tbotch(\"%s already seen\", tokname[what]);\n\t\t\t}\n\t\tlastseen = what;\n\t\t}\n\telse\n\t\tunexpected(tokname[what]);\n\t}\n\n static KWctx *\nlenfind(const char *s)\n{\n\tKWctx *kw, *kw0, **pkw;\n\tStrList *sl;\n\n\tkw0 = lastkw1;\n\tfor(pkw = KWtop; pkw > KWStack; --pkw) {\n\t\tkw = *pkw;\n\t\tfor(kw = kw->kw; kw; kw = kw->next) {\n\t\t\tfor(sl = kw->names; sl; sl = sl->next)\n\t\t\t\tif (!strcmp(sl->val, s))\n\t\t\t\t\treturn kw;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}\n\n static void\nalreadyseen(const char *what)\n{\n\tsquawk(\"%s already given for %s\", what, lastkw1->names->val);\n\t}\n\n static int\nSaw_name(const char *s)\n{\n\tKWctx *kw;\n\tStrList *sl;\n\tTaghash *th;\n\tconst char *s1;\n\tstatic const char notfound[] =\n\t\t\"keyword \\\"%s\\\" not found in this or an enclosing context\";\n\n\tif (lastkw1) {\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t\tlastseen = Saw_dfltname;\n\t\t\tlastdef = (Defhash*)DHHlookup(s, &DHTab, 1);\n\t\t\tif (!lastkw1->defname)\n\t\t\t\tlastkw1->defname = def_name(s);\n\t\t\telse if (lastdef->value\n\t\t\t\t && ((s1 = lastkw1->init) || (s1 = lastkw1->cinit))\n\t\t\t\t && strcmp(s1, lastdef->value))\n\t\t\t\t\tsquawk(\"Inconsistent definitions for %s: %s and %s\\n\",\n\t\t\t\t\t\tlastdef->hh.name, lastdef->value, s1);\n\t\t\treturn 0;\n\t\t  case Saw_len:\n\t\t\tif (lastkw1->len) {\n\t\t\t\talreadyseen(\"LEN\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tkw = lenfind(s);\n\t\t\tif (!kw)\n\t\t\t\tsquawk(notfound,s);\n\t\t\telse {\n\t\t\t\tif ((kw->kind & KWKind_Mask) != KWKind_Int)\n\t\t\t\t\tsquawk(\"%s is not of type INTEGER\", kw->names->val);\n\t\t\t\tfor(sl = kw->names; sl->next; sl = sl->next);\n\t\t\t\tlastkw1->len = sl->val;\n\t\t\t\t}\n\t\t\tgoto ret1;\n\t\t  case Saw_group:\n\t\t\tif (lastkw1->group)\n\t\t\t\talreadyseen(\"GROUP\");\n\t\t\telse\n\t\t\t\tstrcpy(lastkw1->group = (char*)Alloc(strlen(s)+1), s);\n\t\t\tgoto ret1;\n\t\t  case Saw_tag:\n\t\t\tif (tagin)\n\t\t\t\tgoto new_tag;\n\t\t\tif (lasttag) {\n\t\t\t\talreadyseen(\"TAG\");\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tif (!tagfname && !ignoretags) {\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found: no tag file given\", s);\n\t\t\t\tgoto ret1;\n\t\t\t\t}\n\t\t\tth = (Taghash*)DHHlookup(s, &TagTab, ignoretags);\n\t\t\tif (!th)\n\t\t\t\tsquawk(\"TAG \\\"%s\\\" not found in tag file \\\"%s\\\"\", s, tagfname);\n\t\t\telse {\n\t\t\t\t++th->uses;\n\t\t\t\tlasttag = th->hh.name;\n\t\t\t\tif (!ignoretags) {\n\t\t\t\t\tlastkw1->tag = lasttag;\n\t\t\t\t\ttagimport(lastkw1, th->kw);\n\t\t\t\t\t}\n\t\t\t\t}\n ret1:\n\t\t\tlastseen = Saw_type;\n\t\t\treturn 1;\n\t\t  }\n\t\t}\n\telse if (tagin) {\n new_tag:\n\t\tth = (Taghash*)DHHlookup(s, &TagTab, 1);\n\t\tif (th->kw)\n\t\t\tsquawk(\"Tag \\\"%s\\\" already seen in tagfile %s\\n\", s, tagfname);\n\t\telse\n\t\t\tth->kw = lastkw1 = (KWctx*) Alloc(sizeof(KWctx));\n\t\tgoto ret1;\n\t\t}\n\tbotch(\"unexpected name \\\"%s\\\"\", s);\n\treturn 0; /* not reached */\n\t}\n\n static void\nboundalready(const char *what)\n{\n\tsquawk(\"%s bound already given for %s\", what, lastkw1->names->val);\n\t}\n\n static void\nset_lastdef(const char *s, int qkeep)\n{\n\tif (!lastdef->value) {\n\t\tlastdef->value = def_name(s);\n\t\tlastdef->qkeep = qkeep;\n\t\t}\n\telse if (strcmp(s, lastdef->value))\n\t\tsquawk(\"Two := values for %s: %s and %s\", lastdef->hh.name,\n\t\t\tlastdef->value, s);\n\t}\n\n static void\nSaw_num(const char *s)\n{\n\tDefhash *ld;\n\tdouble x, xa;\n\tchar *se, **sp;\n\tint k;\n\tstatic double b[3];\n\n\tstatic char allowed[] = { Saw_dflt, Saw_dfltname, Saw_lt, Saw_le, Saw_ge, Saw_gt, 0 };\n\n\treqchk(allowed, \"number\");\n\tx = strtod(s,&se);\n\tif (*se)\n\t\tbotch(\"invalid number: \\\"%s\\\"\", s);\n\tld = 0;\n\tsp = 0;\n\tswitch(lastseen) {\n\t\tcase Saw_dflt:\n\t\tcase Saw_dfltname:\n\t\t\tsp = &lastkw1->init;\n\t\t\tlastkw1->kind |= KWKind_init;\n\t\t\tld = lastdef;\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int)\n\t\t\t\tx = x >= 0. ? floor(x) : ceil(x);\n\t\t\tb[2] = x;\n\t\t\tif (lastkw1->lb && x < b[0])\n\t\t\t\tsquawk(\"default value inconsistent with lower bound\");\n\t\t\tif (lastkw1->ub && x > b[1])\n\t\t\t\tsquawk(\"default value inconsistent with upper bound\");\n\t\t\tbreak;\n\t\tcase Saw_gt:\n\t\tcase Saw_ge:\n\t\t\tif (lastkw1->lb) {\n\t\t\t\tboundalready(\"lower\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = ceil(x);\n\t\t\t\tif (xa > x) {\n\t\t\t\t\tif (btype == KWKind_strictLb)\n\t\t\t\t\t\tbtype = KWKind_caneqLb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->lb;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[0] = x;\n\t\t\tif (lastkw1->ub && x >= b[1])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x > b[2])\n\t\t\t\tsquawk(\"lower bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tcase Saw_le:\n\t\tcase Saw_lt:\n\t\t\tif (lastkw1->ub) {\n\t\t\t\tboundalready(\"upper\");\n\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\tif ((lastkw1->kind & KWKind_Mask) == KWKind_Int) {\n\t\t\t\txa = floor(x);\n\t\t\t\tif (xa < x) {\n\t\t\t\t\tif (btype == KWKind_strictUb)\n\t\t\t\t\t\tbtype = KWKind_caneqUb;\n\t\t\t\t\tx = xa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsp = &lastkw1->ub;\n\t\t\tlastkw1->kind |= btype;\n\t\t\tb[1] = x;\n\t\t\tif (lastkw1->lb && x <= b[0])\n\t\t\t\tsquawk(\"inconsistent bounds\");\n\t\t\tif (lastkw1->init && x < b[2])\n\t\t\t\tsquawk(\"upper bound inconsistent with default value\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunexpected(s);\n\t\t}\n\tk = lastkw1->kind & KWKind_Mask;\n\tif ((k == KWKind_Void && !tagin) || k == KWKind_Str)\n\t\tsquawk(\"cannot accept a %s value\", tokname[lastseen]);\n\telse {\n\t\tstrcpy(*sp = (char*)Alloc(strlen(s)+1), s);\n\t\tif (ld)\n\t\t\tset_lastdef(s, 0);\n\t\t}\n ret:\n\tlastseen = Saw_type;\n\t}\n\n%}\n\nALias\t\"ALIAS\"[ \\t]+[a-z][a-z_0-9]*\nD\t[0-9]\nKword\t[a-z][a-z_0-9]*\nFunc\t[a-zA-Z_0-9()][,a-zA-Z_0-9<>():.+*/\\-\\[\\] \\t]*\nNum\t[\\-+]?({D}+(\".\"{D}*)?|\".\"{D}+)([eE]([\\-+]?){D}+)?\nPPname\t[a-zA-Z][a-zA-Z0-9_]*\nws\t[ \\t]+\n\n%s FNC VAL\n\n%%\n\n\\n\t\t{ ++Lineno; }\n{ws}\t\t{}\n<INITIAL>{ALias}\t{ Alias(yytext); }\n<INITIAL>\"INTEGER\"\t{ Type(KWKind_Int, yytext); }\n<INITIAL>\"INTEGERLIST\"\t{ Type(KWKind_Int | KWKind_List, yytext); }\n<INITIAL>\"KEYWORD\"\t{ kw_finish(0); }\n<INITIAL>\"KEYWORD1\"\t{ kw_finish(KWKind_1); }\n<INITIAL>\"KEYWORD01\"\t{ kw_finish(KWKind_01); }\n<INITIAL>\"KEYWORD12\"\t{ kw_finish(KWKind_12); }\n<INITIAL>\"LIBNAME\"\t{ Type(KWKind_Str|KWKind_Libname, yytext); }\n<INITIAL>\"REAL\"\t\t{ Type(KWKind_Real, yytext); }\n<INITIAL>\"REALLIST\"\t{ Type(KWKind_Real | KWKind_List, yytext); }\n<INITIAL>\"STRING\"\t{ Type(KWKind_Str, yytext); }\n<INITIAL>\"STRINGLIST\"\t{ Type(KWKind_Str | KWKind_List, yytext); }\n<INITIAL>{Kword}\t{ Keywd(yytext); }\n<INITIAL>\";\"\t\t{ kw_finish(-1); }\n<INITIAL>\"DESC\"\t\t{ Saw_stok(Saw_desc, offsetof(KWctx,desc));\tBEGIN VAL; }\n<INITIAL>\"TAG\"\t\t{ Saw_stok(Saw_tag, offsetof(KWctx,tag));\tBEGIN VAL; }\n<INITIAL>\"GROUP\"\t{ Saw_stok(Saw_group, offsetof(KWctx,group));\tBEGIN VAL; }\n<INITIAL>\"DYNLIB\"\t{ Saw_tok(Saw_dy, offsetof(KWctx,dylib));\n\t\t\t  dynlibseen = 1; dynline = Lineno;\t\tBEGIN VAL; }\n<INITIAL>\"LEN1\"\t\t{ Saw_stok(Saw_len, offsetof(KWctx,len));\n\t\t\t  lastkw1->kind |= KWKind_Len1OK;\t\tBEGIN VAL; }\n<INITIAL>\"LEN\"\t\t{ Saw_stok(Saw_len, offsetof(KWctx,len));\tBEGIN VAL; }\n<INITIAL>\":=\"\t\t{ Saw_tok(Saw_dflt, KWKind_init); lastdef = 0;\tBEGIN VAL; }\n<INITIAL>\">=\"\t\t{ Saw_tok(Saw_ge, KWKind_Lb); btype = KWKind_caneqLb;\tBEGIN VAL; }\n<INITIAL>\">\"\t\t{ Saw_tok(Saw_gt, KWKind_Lb); btype = KWKind_strictLb;\tBEGIN VAL; }\n<INITIAL>\"<=\"\t\t{ Saw_tok(Saw_le, KWKind_Ub); btype = KWKind_caneqUb;\tBEGIN VAL; }\n<INITIAL>\"<\"\t\t{ Saw_tok(Saw_lt, KWKind_Ub); btype = KWKind_strictUb;\tBEGIN VAL; }\n<VAL>{PPname}\t\t{ if (Saw_name(yytext))\tBEGIN INITIAL; }\n<VAL>{Num}\t\t{ Saw_num(yytext);\tBEGIN INITIAL; }\n<VAL>\\\"\t\t\t{ Saw_quote();\t\tBEGIN INITIAL; }\n\n\"{\"\t\t{ Lbrace(); BEGIN FNC; }\n\"}\"\t\t{ Rbrace(); BEGIN INITIAL; }\n\"|\"\t\t{ Bar(); }\n\"(\"\t\t{ Lpar(); }\n\")\"\t\t{ Rpar(); }\n\"[\"\t\t{ Lsqb(); }\n\"]\"\t\t{ Rsqb(); }\n<FNC>{Func}\t{ Fnc(yytext); }\n<FNC>\";\"\t{}\n\"#\".*\\n\t\t{++Lineno;}\n\"/*\"\t\t{ Eat_comment(); }\n.\t{ botch(\"\\\"%s\\\" unexpected\", yytext); }\n\n%%\n\n static void\ncantopen(char *what)\n{ fprintf(stderr, \"%s: cannot open \\\"%s\\\"\\n\", progname, what); }\n\n int\nyywrap(void)\n{\n\tif (tagin) {\n\t\tif (tagin != stdin)\n\t\t\tfclose(tagin);\n\t\ttagin = 0;\n\t\tLineno = 1;\n\t\tsaweof = 1;\n\t\tif (*specfile == '-' && !specfile[1]) {\n\t\t\tyyin = stdin;\n\t\t\tinfname = 0;\n\t\t\treturn 0;\n\t\t\t}\n\t\tif ((yyin = fopen(infname = specfile, \"r\")))\n\t\t\treturn 0;\n\t\tcantopen(specfile);\n\t\texit(1);\n\t\t}\n\treturn 1;\n\t}\n\n static void\nEat_comment(void)\n{\n\tint c;\n\n\tfor(;;) {\n\t\tc = input();\n c_check:\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within /* comment */\");\n\t\tif (c == '*') {\n\t\t\tc = input();\n\t\t\tif (c == '/')\n\t\t\t\treturn;\n\t\t\tgoto c_check;\n\t\t\t}\n\t\tif (c == '\\n')\n\t\t\t++Lineno;\n\t\t}\n\t}\n\n static void\nSaw_quote(void)\n{\n\tKWctx *kw, *kw1, *kw2;\n\tchar buf[1024];\n\tchar *b, *b0, *be, *lname;\n\tint c, c0;\n\tsize_t L, L0, L1;\n\tunsigned char *us;\n\n\tstatic char escname[32];\n\tstatic char hexdig[16] = \"0123456789abcdef\";\n\tstatic unsigned char esetup[] = \"\\aa\\bb\\ff\\nn\\rr\\tt\\vv\";\n\n\tif (!escname['\\a'])\n\t\tfor(us = esetup; *us; us += 2)\n\t\t\tescname[*us] = us[1];\t/* assuming ASCII */\n\tb0 = b = buf;\n\tL = sizeof(buf);\n\tbe = b + L - 3;\t/* allow room for /xhh */\n\tc0 = 0;\n\tsaweof = 0;\n\tfor(;;) {\n\t\tc = input();\n\t\tif (c == EOF)\n\t\t\tbotch(\"EOF within quoted string\");\n\t\tif (b >= be) {\n\t\t\tL1 = b - b0;\n\t\t\tL0 = L;\n\t\t\tL <<= 1;\n\t\t\tbe = (char*)Malloc(L, \"Saw_quote\");\n\t\t\tmemcpy(be, b0, L1);\n\t\t\tif (b0 != buf)\n\t\t\t\tfree(b0);\n\t\t\tb0 = be;\n\t\t\tb = b0 + L1;\n\t\t\tbe = b0 + L - 3;\n\t\t\t}\n\t\tif (c < ' ') {\n\t\t\t*b++ = '\\\\';\n\t\t\tif (escname[c]) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\t++Lineno;\n\t\t\t\tc = escname[c];\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t*b++ = 'x';\n\t\t\t\t*b++ = '0' + (c >> 4);\n\t\t\t\tc = hexdig[c & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t*b++ = c;\n\t\tif (c0 == '\\\\')\n\t\t\tc0 = 0;\n\t\telse {\n\t\t\tc0 = c;\n\t\t\tif (c == '\"') {\n\t\t\t\twhile((c = input()) <= ' ') {\n\t\t\t\t\tif (c == EOF || !c) {\n\t\t\t\t\t\tc = ';';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (c == '\\n')\n\t\t\t\t\t\t++Lineno;\n\t\t\t\t\t}\n\t\t\t\tif (c == '\"' && !saweof) {\n\t\t\t\t\t--b;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tunput(c);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tb[-1] = 0;\t/* replacing \" */\n\tif (lastseen == Saw_tag) {\n\t\tif (saweof) /* kludge around poor flex design */ {\n\t\t\ttagin = stdin;\n\t\t\tSaw_name(b0);\n\t\t\ttagin = 0;\n\t\t\t}\n\t\telse\n\t\t\tSaw_name(b0);\n\t\t}\n\telse {\n\t\tL = b - b0;\n\t\tbe = (char*)Alloc(L);\n\t\tmemcpy(be, b0, L);\n\t\tswitch(lastseen) {\n\t\t  case Saw_dflt:\n\t\t  case Saw_dfltname:\n\t\t\tif ((lastkw1->kind & KWKind_Mask) != KWKind_Str)\n\t\t\t\tbotch(\"%s cannot have a string-valued := value\",\n\t\t\t\t\tlastkw1->names->val);\n\t\t\tlastkw1->cinit = be;\n\t\t\tif (lastdef)\n\t\t\t\tset_lastdef(b0, 1);\n\t\t\tbreak;\n\t\t  case Saw_desc:\n\t\t\tlastkw1->desc = be;\n\t\t\tbreak;\n\t\t  case Saw_dy:\n\t\t\tlastkw1->dylib = be;\n\t\t\tif (lastkw1->nfcn > 0)\n\t\t\t\tfuncbotch(lastkw1);\n\t\t\tif (libexpand) {\n\t\t\t\tkw = *KWtop;\n\t\t\t\tlastseen = Saw_kwname;\n\t\t\t\tif (kw == lastkw1)\n\t\t\t\t\tkw = *--KWtop;\n\t\t\t\telse if ((kw2 = kw->rparent))\n\t\t\t\t\tkw = kw2;\n\t\t\t\tkw1 = lastkw1;\n\t\t\t\tif ((kw2 = kw->kw) == kw1) {\n\t\t\t\t\tif ((kw2 = kw->kw = kw2->next)\n\t\t\t\t\t && kw2->alt == kw1->alt)\n\t\t\t\t\t\tBar();\n\t\t\t\t\telse  {\n\t\t\t\t\t\t--kw->alt;\n\t\t\t\t\t\tif (kw1->req)\n\t\t\t\t\t\t\t--kw->nreq;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tLpar();\n\t\t\t\tKeywd(kw1->name1);\n\t\t\t\tlname = kw1->dylib;\n\t\t\t\tif (lib_read(kw1,0))\n\t\t\t\t\tlastkw1->dylib = lname;\n\t\t\t\tRpar();\n\t\t\t\tif (kw1->parstate == PPar_leftpar)\n\t\t\t\t\t++KWtop;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t  case Saw_group:\n\t\t\tlastkw1->group = be;\n\t\t\tbreak;\n\t\t  default:\n\t\t\tunexpected(\"string\");\n\t\t  }\n\t\t}\n\tif (b0 != buf)\n\t\tfree(b0);\n\tlastseen = Saw_type;\n\t}\n\n static int\nusage(int rc)\n{\n\tfprintf(rc ? stderr : stdout,\n\t\"Usage: %s [options] specfile [tagfile [defs_out [keywds_out]]]\\n\\\n\twhere the last two are output files, \\\".\\\" means \\\"omit\\\", and \\\"-\\\"\\n\\\n\tmeans write to stdout.  Missing trailing arguments are not read\\n\\\n\tor written, except that if all outputs are missing, \\\". -\\\" is assumed.\\n\\\n\tOptions may modify this behavior.\\noptions:\\n\\\n\t-D\t\t{ just write definitions to stdout }\\n\\\n\t-d\t\t{ suppress test for ambiguity from duplicate keywords }\\n\\\n\t-e\t\t{ expand ((...)) for debugging }\\n\\\n\t-f\t\t{ omit functions, i.e., {...} with -p; without -p,\\n\\\n\t\t\t  supply NULL function pointers }\\n\\\n\t-G\t\t{ for keywords with a TAG but not GROUP, do not assume\\n\\\n\t\t\t  that implictly GROUP == TAG }\\n\\\n\t-g\t\t{ write GuiKeyWord rather than KeyWord header;\\n\\\n\t\t\t  with -p, include GUI details: TAG, DESC, GROUP, LEN }\\n\\\n\t-h headername\t{ Specify header file(s), e.g., \\\"-h nidr.h\\\";\\n\\\n\t\t\t  several -h options can be given;\\n\\\n\t\t\t  default = -h- ==> no headers }\\n\\\n\t-j specsum\t{ write file specsum for use by \\\"dakreord specsum ...\\\"\\n\\\n\t\t\t  and \\\"dakreorder -j specsum ...\\\" }\\n\\\n\t-k keyname\t{ library mode with input containing several keywords\\n\\\n\t\t\t  to be contained in keyword keyname; implies -l and\\n\\\n\t\t\t  has no other effect if -D, -g, -j, -p, or -s is given.\\n\\\n\t\t\t  If -l is given without -k and several keywords appear\\n\\\n\t\t\t  in the input, assume \\\"-k KeywordTop\\\". }\\n\\\n\t-L libname\t{ obtain keyword details from library libname (compiled\\n\\\n\t\t\t  from source produced by an earlier \\\"nidrgen -l ...\\\"\\n\\\n\t\t\t  invocation); non-option arguments in this case are\\n\\\n\t\t\t  [defs_out [keywds_out]] }\\n\\\n\t-l\t\t{ library mode: with -D, -g, -j, -p, or -s, attempt to\\n\\\n\t\t\t  load libraries specified with \\\"DYNLIB libname\\\" and\\n\\\n\t\t\t  incorporate keyword specifications provided by the\\n\\\n\t\t\t  loaded libraries; otherwise generate source for\\n\\\n\t\t\t  compilation into a shared library for loading when a\\n\\\n\t\t\t  keyword marked with \\\"DYNLIB libname\\\" (in a separate\\n\\\n\t\t\t  run of nidrgen) is seen.  The library provides\\n\\\n\t\t\t  contained keywords and any needed final routine for\\n\\\n\t\t\t  the marked keyword. }\\n\\\n\t-m mtagfile\t{ just write to mtagfile tags not found in tagfile }\\n\\\n\t-n namespname\t{ assume namespace namespname;\\n\\\n\t\t\t  default = -n Dakota\\n\\\n\t\t\t  -n- ==> no namespace }\\n\\\n\t-p[w]\t\t{ pretty-print rather than produce KeyWord header;\\n\\\n\t\t\t  add w spaces (default 2) for each nested context. }\\n\\\n\t-s[w]\t\t{ like -p[w], but sort the keywords }\\n\\\n\t-T outtagfile\t{ write dummy tagfile to outtagfile (and quit) }\\n\\\n\t-t\t\t{ ignore TAG fields if tagfile is not given }\\n\\\n\t-w\t\t{ cancel warn mode: do not report (on stderr)\\n\\\n\t\t\t  the number of implicitly named start routines;\\n\\\n\t\t\t  still flag their names  with /*!!*/ }\\n\",\n\t\tprogname);\n\treturn rc;\n\t}\n\n static StrList *\nreverse(StrList **x)\n{\n\tStrList *s, *t, *u;\n\n\tif (!(s = *x) || !s->next)\n\t\treturn s;\n\tfor(t = 0; s; s = u) {\n\t\tu = s->next;\n\t\ts->next = t;\n\t\tt = s;\n\t\t}\n\treturn *x = t;\n\t}\n\n static int\nkwcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const KWctx**)a)->names->val, (*(const KWctx**)b)->names->val);\n\t}\n\n static KWctx *\nkwsort(KWctx *kw0)\n{\n\t/* Sort keywords after expanding kw list with aliases; compute nkw, */\n\t/* including aliases. */\n\n\tKWctx *kw, *kw1, *kw2, *kwm, **x, **x0, **xe, *x00[512];\n\tStrList *dname, *minname, *nam, **pmin, **pnam;\n\tchar *descsave, *groupsave;\n\tint agadj, nk;\n\tsize_t L, nkw, nkwa, onkwa;\n\n\treverse(&kw0->funcs);\n\tnkw = nkwa = 0;\n\tfor(kw = kw0->kw; kw; kw = kw->next) {\n\t\t++nkw;\n\t\tpmin = &kw->names;\n\t\tminname = *pmin;\n\t\tpnam = &minname->next;\n\t\tonkwa = nkwa;\n\t\twhile((nam = *pnam)) {\n\t\t\tdname = nam;\n\t\t\t++nkwa;\n\t\t\tif (strcmp(nam->val, minname->val) < 0) {\n\t\t\t\tpmin = pnam;\n\t\t\t\tminname = nam;\n\t\t\t\t}\n\t\t\tpnam = &nam->next;\n\t\t\t}\n\t\tagadj = 2*kw->agroup;\n\t\tkw->agroup = agadj + 1;\n\t\tif (nkwa > onkwa) {\n\t\t\t*pmin = minname->next;\n\t\t\tminname->next = kw->names;\n\t\t\tnam = kw->names = minname;\n\t\t\tnk = kw->kno;\t/* ALias() made room for nk use below */\n\t\t\tdescsave = kw->desc;\n\t\t\tgroupsave = kw->group;\n\t\t\tif (dname != minname) {\n\t\t\t\tkw->desc = kw->group = 0;\n\t\t\t\tkw->agroup = agadj;\n\t\t\t\t}\n\t\t\tkwm = kw;\n\t\t\tkw = kw2 = 0;\n\t\t\tif (nam->primary)\n\t\t\t\tkw2 = kwm;\n\t\t\twhile((nam = nam->next)) {\n\t\t\t\tkw1 = (KWctx*)Alloc(sizeof(KWctx));\n\t\t\t\tif (!kw)\n\t\t\t\t\tkw = kw1;\t/* so kw->next is right */\n\t\t\t\tkw1->next = kwm->next;\n\t\t\t\tkwm->next = kw1;\n\t\t\t\tkw1->names = nam;\n\t\t\t\tkw1->master = kwm;\n\t\t\t\tkw1->kind = kwm->kind;\n\t\t\t\tkw1->kno = ++nk;\n\t\t\t\tkw1->agroup = agadj;\n\t\t\t\tif (nam == dname) {\n\t\t\t\t\tkw1->desc = descsave;\n\t\t\t\t\tkw1->group = groupsave;\n\t\t\t\t\tkw1->agroup = agadj + 1;\n\t\t\t\t\t}\n\t\t\t\tif (nam->primary)\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t}\n\t\t\tif (kw2 != kwm && !guikeywds) {\n\t\t\t\tkw2->defname = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->defname;\n\t\t\t\tkwm->defname = 0;\n\t\t\t\tkw2->len = kwm->len;\n\t\t\t\tkwm->len = 0;\n\t\t\t\tkw2->init = kwm->init;\n\t\t\t\tkwm->init = 0;\n\t\t\t\tkw2->cinit = kwm->cinit;\n\t\t\t\tkwm->cinit = 0;\n\t\t\t\tkw2->dylib = kwm->dylib;\n\t\t\t\t/* no need to change kwm->dylib */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwm;; kw1 = kw1->next) {\n\t\t\t\tif (kw1 != kw2)\n\t\t\t\t\tkw1->pmaster = kw2;\n\t\t\t\tif (kw1 == kw)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tkw0->nkw = (int)(nkw += nkwa);\n\tif (nkw <= 1)\n\t\treturn kw0->kw;\n\tx0 = x00;\n\tif (nkw > sizeof(x00)/sizeof(x00[0]))\n\t\tx0 = (KWctx**)Malloc(L = nkw*sizeof(KWctx*), \"kwsort\");\n\tfor(x = x0, kw = kw0->kw; kw; kw = kw->next)\n\t\t*x++ = kw;\n\tqsort(x0, nkw, sizeof(KWctx*), kwcomp);\n\tfor(xe = x - 1, x = x0; x < xe; ++x) {\n\t\tif (!strcmp(x[0]->names->val, x[1]->names->val)) {\n\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\tprogname, x[0]->names->val);\n\t\t\t++dupnames;\n\t\t\t}\n\t\tx[0]->next = x[1];\n\t\t}\n\tx[0]->next = 0;\n\tfor(x = x0, ++xe; x < xe; ++x)\n\t\t(*x)->paoff = x - x0;\n\tfor(x = x0; x < xe; ++x)\n\t\tif ((kw1 = (kw = *x)->pmaster))\n\t\t\tkw->paoff = kw1->paoff - kw->paoff;\n\tfor(x = x0; x < xe; ++x)\n\t\tif (!(kw = *x)->pmaster)\n\t\t\tkw->paoff = 0;\n\tkw0->kw = kw = x0[0];\n\tif (x0 != x00)\n\t\tfree(x0);\n\treturn kw;\n\t}\n\n static int\nalphanum(char *s)\n{\n\tfor(; *s; ++s)\n\t\tif (!isalnum(*s))\n\t\t\treturn 0;\n\treturn 1;\n\t}\n\n enum CommaState {\n\tCS_Comma = 0,\n\tCS_Clbra = 1,\n\tCS_rbraC = 2,\n\tCS_lrbrC = 3,\n\tCS_rbr2C = 4\n\t};\n\n static const char\n\t*Commasx[5] = { \",\", \",{\", \"},\", \",{},\",/*{{*/ \"}},\" },\n\t*Commas0[5] = { \",\", \",\", \",\", \",\", \",\" };\n static const char **Comma;\n\n typedef struct Zbuf Zbuf;\n struct\nZbuf {\n\tchar buf[80];\t/* overkill */\n\tchar *b;\n\tint nnz;\n\tenum CommaState cs;\n\t};\n\n static void\niput(int i, Zbuf *z)\n{\n\tchar *s;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (i == 0) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s%d\", t, i);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nnput(char *s, Zbuf *z)\n{\n\tchar *fmt, *s1;\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s || (strtod(s,&s1) == 0. && !*s1)) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\t*s++ = '.';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tfmt = \"%s%s.\";\n\t\tfor(s1 = s; *s1; ++s1)\n\t\t\tswitch(*s1) {\n\t\t\t\tcase '.':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'E':\n\t\t\t\t\tfmt = \"%s%s\";\n\t\t\t\t\tgoto have_fmt;\n\t\t\t\t}\n have_fmt:\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(fmt, t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nsput(char *s, Zbuf *z)\n{\n\tconst char *t;\n\n\tt = Comma[z->cs];\n\tif (!s) {\n\t\ts = z->b;\n\t\tfor(; (*s = *t); ++s, ++t);\n\t\t*s++ = '0';\n\t\tz->b = s;\n\t\t}\n\telse {\n\t\tif (z->b > z->buf) {\n\t\t\t*z->b = 0;\n\t\t\tprintf(z->b = z->buf);\n\t\t\t}\n\t\tprintf(\"%s\\\"%s\\\"\", t, s);\n\t\t++z->nnz;\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n static void\nzbclear(Zbuf *z)\n{\n\tif (z->b > z->buf) {\n\t\t*z->b = 0;\n\t\tprintf(\"%s\", z->b = z->buf);\n\t\t}\n\tz->cs = CS_Comma;\n\t}\n\n typedef struct\nFCat { char *b, *b0, *be; } FCat;\n\n static char *\nfunc_cat(FCat *fc, StrList *f)\n{\n\tchar *b, *b1, *be;\n\tint k, n;\n\tsize_t L, L1, L2, L3;\n\n\tif (!f)\n\t\treturn 0;\n\tif (!f->next)\n\t\treturn f->val;\n\tb = fc->b;\n\tbe = fc->be;\n\tfor(n = k = 0; f; f = f->next, ++n) {\n\t\tL = L1 = strlen(f->val);\n\t\tif (n) {\n\t\t\t++L1;\n\t\t\tif (n & 1) {\n\t\t\t\tif (alphanum(f->val)) {\n\t\t\t\t\tk = 2;\n\t\t\t\t\tL1 += 7;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = 3;\n\t\t\t\t\tL1 += 9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tk = 1;\n\t\t\t}\n\t\tif (L1 > be - b) {\n\t\t\tL2 = b - fc->b;\n\t\t\tL3 = 2*(be - fc->b + L1);\n\t\t\tb1 = (char*)Malloc(L3, \"func_cat\");\n\t\t\tif (L2)\n\t\t\t\tmemcpy(b1, fc->b, L2);\n\t\t\tif (fc->b != fc->b0)\n\t\t\t\tfree(fc->b);\n\t\t\tfc->b = b1;\n\t\t\tbe = fc->be = b1 + L3;\n\t\t\tb = b1 + L2;\n\t\t\t}\n\t\tswitch(k) {\n\t\t\tcase 0: break;\n\t\t\tcase 1: *b++ = ',';\n\t\t\t\tbreak;\n\t\t\tcase 2: memcpy(b, \",(void*)\", 8);\n\t\t\t\tb += 8;\n\t\t\t\tbreak;\n\t\t\tcase 3: memcpy(b, \",(void*)(\", 9);\n\t\t\t\tb += 9;\n\t\t\t}\n\t\tstrcpy(b, f->val);\n\t\tb += L;\n\t\tif (k == 3)\n\t\t\t*b++ = ')';\n\t\t*b = 0;\n\t\t}\n\treturn fc->b;\n\t}\n\n static void\nkwout(KWctx *kw, KWctx **kwtop, Uint xflag)\n{\n\tFCat fc;\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, **kws, **x, *x0[KWOUTlen0];\n\tStrList *S, *nam;\n\tZbuf z;\n\tchar fbuf[256], *funcs, *s;\n\tconst char *fmt, *ffmt;\n\tint aoff, k, i, m, m1, n, roff, sentinnel, skipfuncs;\n\n\tif (expand && !kw->names)\n\t\treturn;\n\tif (needcomma) {\n\t\tprintf(\",\\n\");\n\t\tneedcomma = 0;\n\t\t}\n\tkw1 = kw->kw;\n\tn = 0;\n\tfc.b = fc.b0 = fbuf;\n\tfc.be = fbuf + sizeof(fbuf);\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastkno + 1;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastkno + 1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tif (expand)\n\t\tfor(kw0 = kw1; kw0 && !kw0->names; kw0 = kw0->next)\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next)\n\t\t\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwout\");\n\tm = 0;\n\tkw0 = kw1;\n\tif (expand) {\n\t\taoff = kw->nalt;\n\t\troff = kw->nreq;\n\t\tfor(; kw0 && !kw0->names; kw0 = kw0->next) {\n\t\t\tfor(kw2 = kw0->kw; kw2; kw2 = kw2->next) {\n\t\t\t\tkw2->altoffset = aoff;\n\t\t\t\tkw2->reqoffset = roff;\n\t\t\t\tx[m++] = kw2;\n\t\t\t\t}\n\t\t\taoff += kw0->nalt;\n\t\t\troff += kw0->nreq;\n\t\t\t}\n\t\tkw->nalt = aoff;\n\t\tkw->nreq = roff;\n\t\t}\n\tfor(; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tsentinnel = 0;\n\tif (expand) {\n\t\tkw->nkw = m;\n\t\tqsort(x, m, sizeof(KWctx*), kwcomp);\n\t\tfor(i = 1; i < m; ++i)\n\t\t\tif (!strcmp(x[i-1]->names->val, x[i]->names->val)) {\n\t\t\t\tfprintf(stderr, \"%s: duplicate appearance of \\\"%s\\\"\\n\",\n\t\t\t\t\tprogname, x[i]->names->val);\n\t\t\t\t++dupnames;\n\t\t\t\t}\n\t\t}\n\telse if (kw->nkw == 0)\n\t\tsentinnel = 1;\n\tm1 = m + sentinnel;\n\tprintf(\"\\tkw_%d[%d] = {\\n\" /*}*/, kw->kwkno = ++lastkno, m1);\n\tneedcomma = 1;\n\tz.nnz = 0;\n\tskipfuncs = !wantfuncs && !xflag;\n\tfor(i = 0; i < m;) {\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tif (!(kwp = kw1->pmaster))\n\t\t\tkwp = kw1;\n\t\tfputs(xflag ? \"\\t\\t{{\" : \"\\t\\t{\" /*}}}*/, stdout);\n\t\tz.b = z.buf;\n\t\tz.cs = CS_Comma;\n\t\tif ((nam = kw1->names)) {\n\t\t\tk = kwp->kind | kw1->names->primary | xflag;\n\t\t\tif (kwp->dylib)\n\t\t\t\tk |= KWKind_Dynlib;\n\t\t\tprintf(k < 16\n\t\t\t\t? \"\\\"%s\\\",%d\"\n\t\t\t\t: \"\\\"%s\\\",0x%x\", kw1->names->val, k);\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(kwm->alt + kwm->altoffset, &z);\n\t\t\tiput(kwm->req ? kwm->req + kwm->reqoffset : 0, &z);\n\t\t\t}\n\t\telse {\n\t\t\tif (xflag)\n\t\t\t\tprintf(\"0,0x%x\", xflag);\n\t\t\telse\n\t\t\t\tprintf(\"0,0\");\n\t\t\tiput(kwm->nkw, &z);\n\t\t\tiput(0, &z);\n\t\t\tiput(0, &z);\n\t\t\t}\n\t\tif (guikeywds)\n\t\t\tiput(kw1->agroup, &z);\n\t\tif ((n = kwm->kwkno)) {\n\t\t\tzbclear(&z);\n\t\t\tprintf(xflag ? \",(KeyWord*)kw_%d\": \",kw_%d\", n);\n\t\t\t}\n\t\telse\n\t\t\tiput(0, &z);\n\t\tnput(kwp->lb, &z);\n\t\tnput(kwp->ub, &z);\n\t\tffmt = /*{{{*/ !xflag ? \"}%s\" : \"}}%s\";\n\t\tif (guikeywds) {\n\t\t\tnput(kwm->init, &z);\n\t\t\tsput(kwm->cinit, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tif (!(s = kw1->group) && dfltgroup)\n\t\t\t\ts = kw1->tag;\n\t\t\tsput(s, &z);\n\t\t\tif (kwm->len)\n\t\t\t\tsput(kwm->len, &z);\n\t\t\tif (kwm->dylib)\n\t\t\t\tsput(kwm->dylib, &z);\n\t\t\tgoto nofuncs;\n\t\t\t}\n\t\tiput(kw1->paoff, &z);\n\t\tif (skipfuncs && !kwp->dylib)\n\t\t\tgoto nofuncs;\n\t\tz.nnz = 0;\n\t\tfuncs = 0;\n\t\tif (kwp->dylib) {\n\t\t\tz.cs = CS_Clbra;\n\t\t\tfor(n = 0; n < 3; ++n)\n\t\t\t\tiput(0,&z);\n\t\t\tzbclear(&z);\n\t\t\tprintf(\",(void*)\\\"%s\\\"\", kwp->dylib);\n\t\t\tz.cs = CS_rbr2C;\n\t\t\tz.nnz = 0;\n\t\t\t}\n\t\telse if ((S = kwp->funcs)) {\n\t\t\tif (!S->next && !strcmp(S->val,\"0\"))\n\t\t\t\tgoto xcheck;\n\t\t\tif (!kwp->kw && S->needrev)\n\t\t\t\tS = reverse(&kwp->funcs);\n\t\t\tfuncs = func_cat(&fc, S);\n\t\t\tgoto funcput;\n\t\t\t}\n\t\telse if ((S = kwm->funcs)) {\n\t\t\tfuncs = func_cat(&fc, S);\n funcput:\n\t\t\tz.cs = CS_lrbrC;\n\t\t\tif (funcs && wantfuncs & 1) {\n\t\t\t\tzbclear(&z);\n\t\t\t\tprintf(\",%s\", funcs);\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tiput(0,&z);\n\t\t\t}\n\t\telse if (kwm->names && wantfuncs & 1 && !(kwm->kind & KWKind_Libname)) {\n\t\t\t++missing;\n\t\t\tprintf(\",/*!!*/\");\n\t\t\tfor(kws = KWStack; ++kws <= kwtop; ) {\n\t\t\t\tif (!(kw2 = *kws)->names)\n\t\t\t\t\tkw2 = kw2->rparent;\n\t\t\t\tprintf(\"%s_\", kw2->names->val);\n\t\t\t\t}\n\t\t\tprintf(\"%s_start\", kwm->names->val);\n\t\t\t}\n xcheck:\n\t\tif (xflag) {\n\t\t\tif (z.nnz) {\n\t\t\t\tz.cs = z.cs == CS_rbraC ? CS_rbr2C : CS_rbraC;\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\t\tz.nnz = 0;\n\t\t\t\t}\n\t\t\telse if (z.cs == CS_rbr2C)\n\t\t\t\tffmt = /*{{{*/ \"}}}%s\";\n\t\t\telse {\n\t\t\t\tz.cs = CS_rbraC;\n\t\t\t\tffmt = /*{{*/ \"}}%s\";\n\t\t\t\t}\n\t\t\tz.b = z.buf;\n\t\t\tiput(nam ? nam->seqno : 0, &z);\n\t\t\tiput(kw1->agroup, &z);\n\t\t\tsput(funcs, &z);\n\t\t\tsput(kw1->desc, &z);\n\t\t\tsput(kw1->group, &z);\n\t\t\tsput(kw1->defname, &z);\n\t\t\tsput(kw1->len, &z);\n\t\t\tsput(kw1->init, &z);\n\t\t\tsput(kw1->cinit, &z);\n\t\t\tif (z.nnz)\n\t\t\t\tffmt = /*{*/ \"}%s\";\n\t\t\t}\n nofuncs:\n\t\tprintf(ffmt, i < m1 ? \",\\n\" : \"\\n\");\n\t\t}\n\tif (sentinnel)\n\t\tfputs(\"\\t\\t{\\\"\\\"}\\n\", stdout);\n\tprintf(/*{*/\"\\t\\t}\");\n\tif (x != x0)\n\t\tfree(x);\n\tif (fc.b != fbuf)\n\t\tfree(fc.b);\n\t}\n\n static void\nhashclear(KWctx *kw)\n{\n\tStrList *sl;\n\n\tkw->parstate = Dupchecked;\n\tfor(kw = kw->kw; kw; kw = kw->next)\n\t\tfor(sl = kw->names; sl; sl = sl->next) {\n\t\t\tsl->h.hnext->hprev = sl->h.hprev;\n\t\t\tsl->h.hprev->hnext = sl->h.hnext;\n\t\t\tsl->h.hprev = sl->h.hnext = 0;\n\t\t\t}\n\t}\n\n static void\ndupfound(HashHead *h0, StrList *sl, StrList *sl1)\n{\n\tStrList *sl2, *sl3;\n\n\t++dupnames;\n\tfor(sl2 = sl1; sl2->h.hnext != h0; sl2 = sl3) {\n\t\tsl3 = (StrList*)sl2->h.hnext;\n\t\tif (strcmp(sl->val, sl3->val))\n\t\t\tbreak;\n\t\t}\n\tfprintf(stderr, \"Warning: \\\"%s\\\" on line %d also appears on line%s %d\",\n\t\tsl->val, sl->Lineno, \"s\" + (sl2 == sl1), sl1->Lineno);\n\twhile(sl1 != sl2) {\n\t\tsl1 = (StrList*)sl1->h.hnext;\n\t\tfprintf(stderr, \", %d\", sl1->Lineno);\n\t\t}\n\tfputs(\".\\n\", stderr);\n\t}\n\n static KWctx **\nhashadd(KWctx *kw, KWctx **kwtop)\n{\n\tHashHead *h, *h0;\n\tKWctx *kw1;\n\tStrList *sl, *sl1;\n\tchar *s;\n\tint n;\n\tunsigned int c, x;\n\n\tkw->parstate = Dupchecking;\n\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\tfor(sl = kw1->names; sl; sl = sl->next) {\n\t\t\tx = 0;\n\t\t\ts = sl->val;\n\t\t\twhile((c = *(unsigned char*)s++))\n\t\t\t\tx = 43*x + c - ' ';\n\t\t\th0 = &HTab[x % HTlen];\n\t\t\tfor(h = h0->hnext; h != h0; h = h->hnext) {\n\t\t\t\tsl1 = (StrList*)h;\n\t\t\t\tn = strcmp(sl->val, sl1->val);\n\t\t\t\tif (n <= 0) {\n\t\t\t\t\tif (n == 0)\n\t\t\t\t\t\tdupfound(h0,sl,sl1);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsl->h.hnext = h;\n\t\t\th->hprev = (sl->h.hprev = h->hprev)->hnext = (HashHead *)sl;\n\t\t\t}\n\tif ((kw1 = kw->kw))\n\t\t*++kwtop = kw1;\n\treturn kwtop;\n\t}\n\n static void\ndup_check(void)\n{\n\tHashHead *h, *he;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tfor(h = HTab, he = h + HTlen; h < he; ++h)\n\t\th->hnext = h->hprev = h;\n\tplist = 0;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;) {\n\t\tkw = *kwtop;\n\t\tlev = kw->level;\n\t\twhile(plist && plist->level >= lev) {\n\t\t\thashclear(plist);\n\t\t\tplist = plist->next;\n\t\t\t}\n\t\tif (kw->parstate == Dupchecking) {\n\t\t\thashclear(kw);\n\t\t\tif ((*kwtop = kw->next))\n\t\t\t\tcontinue;\n\t\t\tif (kwtop <= kwbot)\n\t\t\t\tbreak;\n\t\t\t--kwtop;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif ((kw1 = kw->pparent) && kw1->parstate != Dupchecking) {\n\t\t\tfor(kw2 = kw1; plist && kw2; plist = plist->next) {\n\t\t\t\twhile(kw2->level > plist->level && (kw2 = kw2->pparent));\n\t\t\t\tif (kw2 != plist)\n\t\t\t\t\tbreak;\n\t\t\t\thashclear(plist);\n\t\t\t\t}\n\t\t\tkw2 = 0;\n\t\t\tdo {\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tkw1->next = kw2;\n\t\t\t\t\tkw2 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Dupchecking);\n\t\t\twhile(kw2) {\n\t\t\t\tkwtop = hashadd(kw2, kwtop);\n\t\t\t\tkw1 = kw2;\n\t\t\t\tkw2 = kw2->next;\n\t\t\t\tkw1->next = plist;\n\t\t\t\tplist = kw1;\n\t\t\t\t}\n\t\t\t}\n\t\tkwtop = hashadd(kw, kwtop);\n\t\t}\n\t}\n\n static void\nprkwname(KWctx *kw, const char *suf, int needrev)\n{\n\tint k;\n\tStrList *S;\n\tstatic const char *kname[] = { \"BUG\", \"INTEGER\", \"REAL\", \"STRING\" };\n\n\tif (needrev)\n\t\treverse(&kw->names);\n\tS = kw->names;\n\tprintf(\"%s\", S->val);\n\twhile((S = S->next))\n\t\tprintf(\" ALIAS %s\", S->val);\n\tif ((k = kw->kind & KWKind_Mask)) {\n\t\tprintf(\" %s\", kname[k]);\n\t\tif (kw->kind & KWKind_List)\n\t\t\tprintf(\"LIST\");\n\t\t}\n\tif (kw->lb)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictLb ? \">\" : \">=\", kw->lb);\n\tif (kw->ub)\n\t\tprintf(\" %s %s\", kw->kind & KWKind_strictUb ? \"<\" : \"<=\", kw->ub);\n\tif (kw->defname && wantfuncs & 1) {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s %s\", kw->defname, kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := %s \\\"%s\\\"\", kw->defname, kw->cinit);\n\t\t}\n\telse {\n\t\tif (kw->init)\n\t\t\tprintf(\" := %s\", kw->init);\n\t\telse if (kw->cinit)\n\t\t\tprintf(\" := \\\"%s\\\"\", kw->cinit);\n\t\t}\n\tif (!(wantfuncs&1))\n\t\tgoto sufchk;\n\tif (kw->tag)\n\t\tprintf(ignoretags ? \" TAG \\\"%s\\\"\" : \" /*TAG \\\"%s\\\"*/\", kw->tag);\n\tif (kw->funcs) {\n\t\tfputs(\" {\", stdout);\n\t\treverse(&kw->funcs);\n\t\tfor(S = kw->funcs;;) {\n\t\t\tfputs(S->val, stdout);\n\t\t\tif (!(S = S->next))\n\t\t\t\tbreak;\n\t\t\tputchar(',');\n\t\t\t}\n\t\tputchar('}');\n\t\t}\n\tif (kw->len)\n\t\tprintf(\" LEN %s\", kw->len);\n\tif (kw->group)\n\t\tprintf(\" GROUP \\\"%s\\\"\", kw->group);\n\tif (kw->desc)\n\t\tprintf(\" DESC \\\"%s\\\"\", kw->desc);\n sufchk:\n\tif (kw->dylib)\n\t\tprintf(\" DYNLIB \\\"%s\\\"\", kw->dylib);\n\tif (suf)\n\t\tfputs(suf, stdout);\n\tif (needrev == 2)\n\t\treverse(&kw->names);\n\t}\n\n static KWctx *\nkwrev(KWctx **pkw)\n{\n\tKWctx *kw, *kw0, *kw1;\n\tkw1 = *pkw;\n\tfor(kw0 = 0; (kw = kw1); kw0 = kw) {\n\t\tkw1 = kw->next;\n\t\tkw->next = kw0;\n\t\t}\n\treturn *pkw = kw0;\n\t}\n\n static int\nStrListcmp(StrList *sl1, StrList *sl2)\n{\n\tif (sl1 == sl2)\n\t\treturn 0;\n\twhile(sl1) {\n\t\tif (!sl2 || strcmp(sl1->val, sl2->val))\n\t\t\treturn 1;\n\t\tsl1 = sl1->next;\n\t\tsl2 = sl2->next;\n\t\t}\n\treturn sl2 != 0;\n\t}\n\n#if 0\t/* Could hash keywords and use the following samekw to find duplicate  */\n\t/* contained keywords, noting duplicates when found in a new, normally */\n\t/* NULL pointer in KWctx, but so far this does not appear worthwhile.  */\n#define OffsetOf(T,f) ((char*)&((T*)0)->f - (char*)0)\n#define NumberOf(x) (sizeof(x)/sizeof(x[0]))\n#define ValueOf(T,x,o) (*(T*)((char*)x + o))\n\n static int\nsamekw(KWctx *kw1, KWctx *kw2)\n{\n\tchar *s1, *s2;\n\tsize_t *sp, *spe;\n\n\tstatic size_t\n\t\tIntoff[] = {\n\t\t\tOffsetOf(KWctx,alt),\n\t\t\tOffsetOf(KWctx,kind),\n\t\t\tOffsetOf(KWctx,nalt),\n\t\t\tOffsetOf(KWctx,nkw),\n\t\t\tOffsetOf(KWctx,nreq),\n\t\t\tOffsetOf(KWctx,req)\n\t\t\t},\n\t\tStroff[] = {\n\t\t\tOffsetOf(KWctx,lb),\n\t\t\tOffsetOf(KWctx,ub),\n\t\t\tOffsetOf(KWctx,init),\n\t\t\tOffsetOf(KWctx,cinit),\n\t\t\tOffsetOf(KWctx,defname),\n\t\t\tOffsetOf(KWctx,desc),\n\t\t\tOffsetOf(KWctx,dylib),\n\t\t\tOffsetOf(KWctx,group),\n\t\t\tOffsetOf(KWctx,len)\n\t\t\t};\n\twhile(kw1) {\n\t\tif (!kw2)\n\t\t\treturn 0;\n\t\tif (kw1->pparent != kw2->pparent\n\t\t || kw1->rparent != kw2->rparent)\n\t\t\treturn 0;\n\t\tif (StrListcmp(kw1->names, kw2->names)\n\t\t || StrListcmp(kw1->funcs, kw2->funcs))\n\t\t\treturn 0;\n\t\tfor(sp = Intoff, spe = sp + NumberOf(Intoff); sp < spe; ++sp)\n\t\t\tif (ValueOf(int,kw1,*sp) != ValueOf(int,kw2,*sp))\n\t\t\t\treturn 0;\n\t\tfor(sp = Stroff, spe = sp + NumberOf(Stroff); sp < spe; ++sp) {\n\t\t\ts1 = ValueOf(char*,kw1,*sp);\n\t\t\ts2 = ValueOf(char*,kw2,*sp);\n\t\t\tif (s1 != s2 && (!s1 || !s2 || strcmp(s1,s2)))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tkw1 = kw1->next;\n\t\tkw2 = kw2->next;\n\t\t}\n\treturn kw2 == 0;\n\t}\n#undef ValueOf\n#undef NumberOf\n#undef OffsetOf\n#endif\n\n static void\nparadj(int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, **kwp, **kwtop, **kwbot, *plist;\n\tint lev;\n\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (needrev)\n\t\tkwrev(kwtop);\n\n\t/* remove extra parens */\n\n\tfor(;; --kwtop) {\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n top:\n\t\t\tif (needrev && (kw1 = kw->kw) && kw1->next)\n\t\t\t\tkwrev(&kw->kw);\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Parchecked) {\n\t\t\t\tkwp = &kw->pparent;\n\t\t\t\tplist = kw;\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif (kw1->kw) {\n\t\t\t\t\t\t*kwtop++ = kw1;\n\t\t\t\t\t\tkw1->parstate = Parchecked;\n\t\t\t\t\t\t*kwp = kw1;\n\t\t\t\t\t\tkwp = &kw1->pparent;\n\t\t\t\t\t\tkw1->next = plist;\n\t\t\t\t\t\tplist = kw1;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!(*kwp = kw1->pparent)) {\n\t\t\t\t\t\tlev = kw1->level;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tkw1 = *kwp;\n\t\t\t\t\tif (kw1->parstate == Parchecked) {\n\t\t\t\t\t\tlev = kw1->level + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tfor(;; plist = kw1) {\n\t\t\t\t\tplist->level = lev++;\n\t\t\t\t\tif (plist == kw)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tkw1 = plist->next;\n\t\t\t\t\tplist->next = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = kw->kw;\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static KWctx *\nmasteradj(KWctx *kw)\n{\n\t/* to help print (nm1 | nm2 foo goo), make nm2 \"master\" */\n\tKWctx *kw1, *kw2, *kw3, *kwm, *rv;\n\n\tfor(kw1 = kw, kw3 = 0; kw1; kw1 = kw1->next) {\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn kw;\n\tfor(rv = kw; kw; kw = kw->next) {\n\t\tkwm = kw->master;\n\t\tif ((kw1 = kw->next) && kw1->master == kwm && kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in masteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile((kw1 = kw1->next) && kw1->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;;kw = kw->next) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tkw = kw2;\n\t\t\t}\n\t\t}\n\treturn rv;\n\t}\n\n static void\nxmasteradj(KWctx **x, int n)\n{\n\t/* variant of masteradj for pretty_ex1 */\n\tKWctx *kw, *kw1, *kw2, *kw3, *kwm;\n\tint i, j;\n\n\tfor(i = 0, kw3 = 0; i < n; ++i) {\n\t\tkw1 = x[i];\n\t\tif ((kw2 = kw1->master))\n\t\t\tkw3 = kw2->master = kw2;\n\t\t}\n\tif (!kw3)\n\t\treturn;\n\tfor(i = 0; i < n; i = j) {\n\t\tj = i + 1;\n\t\tkw = x[i];\n\t\tkwm = kw->master;\n\t\tif (j < n && kwm && (kw1 = x[j])->master == kwm) {\n\t\t\tkw3 = kw->kw ? kw : 0;\n\t\t\tdo {\n\t\t\t\tkw2 = kw1;\n\t\t\t\tif (kw1->kw) {\n\t\t\t\t\tif (kw3)\n\t\t\t\t\t\tbotch(\"Two masters in xmasteradj!\");\n\t\t\t\t\tkw3 = kw1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(++j < n && (kw1 = x[j])->master == kwm);\n\t\t\tif (kw3 || kw2->pparent) {\n\t\t\t\tif (kw2 != kw3) {\n\t\t\t\t\tkw2->pparent = kw3->pparent;\n\t\t\t\t\tkw2->kw = kw3->kw;\n\t\t\t\t\tkw3->kw = 0;\n\t\t\t\t\t}\n\t\t\t\tfor(;;kw = x[++i]) {\n\t\t\t\t\tkw->master = kw2;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor(;; kw = x[++i]) {\n\t\t\t\t\tkw->master = 0;\n\t\t\t\t\tif (kw == kw2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n static void\ndo_indent(int indent)\n{\n\tfor(indent += 8; indent >= 8; indent -= 8)\n\t\tputchar('\\t');\n\tfor(; indent > 0; --indent)\n\t\tputchar(' ');\n\t}\n\n static void\ndo_indent1(int indent)\t/* write indent-1 spaces */\n{\n\twhile(--indent > 0)\n\t\tputchar(' ');\n\t}\n\n static const char *KEYKIND[4] = { \"KEYWORD \", \"KEYWORD01 \", \"KEYWORD1 \", \"KEYWORD12 \" };\n\n static void\npretty_print(int iinc, int needrev)\n{\n\tKWctx *kw, *kw1, *kw2, *kw3, **kwtop, **kwbot, *plist;\n\tconst char *s;\n\tint alt, indent, lev, needindent, needspace;\n\n\tkwtop = kwbot = KWStack;\n\tindent = 0;\n\tplist = 0;\n\tneedindent = 1;\n\tfor(kw1 = KWbase.kw; kw1;) {\n\t\tfputs(KEYKIND[(kw1->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw1, \"\\n\", needrev);\n\t\t*kwtop = masteradj(kw1->kw);\n\t\talt = 0;\n\t\tfor(;;--kwtop) {\n\t top:\n\t\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\t\tlev = kw->level;\n\t\t\t\tif (needindent) {\n\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\tneedindent = 0;\n\t\t\t\t\t}\n\t\t\t\tif (plist\n\t\t\t\t && (plist->level > lev\n\t\t\t\t  || (plist->level == lev && plist != kw->pparent))) {\n finishpar:\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = plist;\n\t\t\t\t\t*++kwtop = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Printing) {\n\t\t\t\t\ts = !kw->names || /*[(*/kw->req ? \")\\n\" : \"]\\n\";\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\ts = /*(*/ \")\\n\";\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tfputs(s, stdout);\n\t\t\t\t\tneedindent = 1;\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tindent -= iinc;\n\t\t\t\t\tif (!kw->names) {\n\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\tgoto bot;\n\t\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (plist)\n\t\t\t\t\tfor (kw2 = kw->pparent;\n\t\t\t\t\t\t\tkw2 && kw2->parstate != Printing;\n\t\t\t\t\t\t\tkw2 = kw2->pparent) {\n\t\t\t\t\t\tif (plist->level >= kw2->level)\n\t\t\t\t\t\t\tgoto finishpar;\n\t\t\t\t\t\t}\n\t\t\t\tneedindent = 1;\n\t\t\t\tneedspace = 0;\n\t\t\t\tif (alt == kw->alt) {\n\t\t\t\t\tputchar('|');\n\t\t\t\t\tneedspace = 1;\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->pparent) && kw2->parstate != Printing) {\n\t\t\t\t\tkw3 = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (kw2->parstate == Printing)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (kw2->kw) {\n\t\t\t\t\t\t\tkw2->next = kw3;\n\t\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t\tkw2->parstate = Printing;\n\t\t\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\t\t\tneedspace = 0;\n\t\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t\tputchar('('); /*)*/\n\t\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile((kw2 = kw2->pparent));\n\t\t\t\t\twhile(kw3) {\n\t\t\t\t\t\tkw2 = kw3->next;\n\t\t\t\t\t\tkw3->next = plist;\n\t\t\t\t\t\tplist = kw3;\n\t\t\t\t\t\tkw3 = kw2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif ((kw2 = kw->master) && kw == kw2)\n\t\t\t\t\tkw2 = 0;\n\t\t\t\tif (!kw->kw && (!kw2 || kw2->parstate == Leftput)) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t\tif (!kw->req) {\n\t\t\t\t\t\tif (alt != kw->alt) {\n\t\t\t\t\t\t\tfputs(\"[ \", stdout);\n\t\t\t\t\t\t\talt = kw->alt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\ts = /*[*/ \" ]\\n\";\n\t\t\t\t\t\tif ((kw2 = kw->next) && kw2->alt == alt)\n\t\t\t\t\t\t\ts = \"\\n\";\n\t\t\t\t\t\tprkwname(kw, s, needrev);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tif (kw->parstate == Leftput) {\n\t\t\t\t\tif (needspace)\n\t\t\t\t\t\tgoto putspace;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (needspace) {\n\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\tputchar(kw->req ? '(' : '['); /*])*/\n\t\t\t\t\tif (kw->kw && !kw->req\n\t\t\t\t\t && kw->next && kw->next->alt == kw->alt) {\n\t\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t\tputchar('('/*)*/);\n\t\t\t\t\t\tindent += iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tindent += iinc;\n putspace:\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\t}\n\t\t\t\tkw->parstate = Printing;\n\t\t\t\tprkwname(kw, \"\\n\", needrev);\n\t\t\t\tif (kw2) {\n\t\t\t\t\talt = kw->alt;\n\t\t\t\t\tkw2->parstate = Leftput;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\talt = 0;\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = masteradj(kw->kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n bot:\n\t\t\tif (kwtop == kwbot) {\n\t\t\t\tif (plist) {\n\t\t\t\t\t*kwtop++ = plist;\n\t\t\t\t\t*kwtop++ = masteradj(plist->kw);\n\t\t\t\t\tplist->alt = alt;\n\t\t\t\t\talt = 0;\n\t\t\t\t\tplist = plist->next;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (indent) {\n\t\t\t\t\t\tif (needindent)\n\t\t\t\t\t\t\tdo_indent(indent);\n\t\t\t\t\t\tfputs(/*(*/\")\\n\", stdout);\n\t\t\t\t\t\tneedindent = 1;\n\t\t\t\t\t\tindent -= iinc;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (!(kw1 = kw1->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static void\nnslist(StrList *h, const char *fmt)\n{\n\tfor(; h; h = h->next)\n\t\tprintf(fmt, h->val);\n\t}\n\n static void\nOutput(StrList *headers, StrList *nsname, int hwant, const char *kname, int libmode, int nwant)\n{\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tStrList *h;\n\tUint xflag;\n\tconst char *fmt;\n\tint kwkno;\n\tstatic char\n\t\tlibfmt1[] = \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n\"\n\t\t\t\"KeyWord *keyword_add(void);\\n}\\n#endif\\n\\n\"\n\t\t\t\" KeyWord*\\nkeyword_add(void) {\\n\\t\",\n\t\tlibfmt2[] = \"kw_%d[0].kw;\\n\\t}\\n\",\n\t\tlibfmt3[] = /*{*/ \"kw_%d.kw;\\n\\t}\\n\";\n\n\tif (hwant && headers) {\n\t\tfor(h = reverse(&headers); h; h = h->next)\n\t\t\tprintf(*h->val == '<' /*>*/\n\t\t\t\t? \"#include %s\\n\"\n\t\t\t\t: \"#include \\\"%s\\\"\\n\", h->val);\n\t\t}\n\tif (nwant) {\n\t\tif (nsname)\n\t\t\treverse(&nsname);\n\t\telse\n\t\t\tnsname = new_StrList(\"Dakota\", nsname);\n\t\tputchar('\\n');\n\t\tnslist(nsname, \"namespace %s {\\n\" /*}*/);\n\t\t}\n\t/* BMA (20160923): Suppress keyword count summary to avoid merge conflicts */\n\t//printf(\"\\n/** %d distinct keywords (plus %d aliases) **/\\n\", lastagroup, nalias);\n\tprintf(\"\\nstatic %sKeyWord%s\\n\", guikeywds ? \"Gui\" : \"\", libmode ? \"x\" : \"\");\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tif (libmode) {\n\t\txflag = KWKind_Extended;\n\t\tComma = Commasx;\n\t\t}\n\telse {\n\t\txflag = 0;\n\t\tComma = Commas0;\n\t\t}\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwout(kw, kwtop, xflag);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tprintf(\";\\n\\n\");\n\tif (nwant) {\n\t\tnslist(reverse(&nsname), /*{*/\"} // namespace %s\\n\");\n\t\tputchar('\\n');\n\t\treverse(&nsname);\n\t\t}\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"extern \\\"C\\\" {\\n\");\n\tprintf(\"#endif\\n\");\n\n\tkwkno = KWbase.kwkno;\n\tif (libmode) {\n\t\tif (KWbase.nkw > 1 && !kname)\n\t\t\tkname = \"KeywordTop\";\n\t\tprintf(libfmt1);\n\t\tfmt = libfmt2;\n\t\tif (kname) {\n\t\t\tprintf(\"static KeyWordx kw_%d = { \\\"%s\\\", 0x%x,%d,%d,%d,(KeyWord*)\",\n\t\t\t\tkwkno + 1, kname, KWKind_Dynmult, KWbase.nkw,\n\t\t\t\tKWbase.alt, KWbase.req);\n\t\t\tif (nwant) {\n\t\t\t\tnslist(nsname, \"%s::\");\n\t\t\t\tnwant = 0;\n\t\t\t\t}\n\t\t\tprintf(\"kw_%d };\\n\\t\", kwkno++);\n\t\t\tfmt = libfmt3;\n\t\t\t}\n\t\tprintf(\"return &\");\n\t\t}\n\telse {\n\t\tprintf(\"KeyWord Dakota_Keyword_Top = {\\\"KeywordTop\\\",0,%d,%d,%d,\",\n\t\t\tKWbase.nkw, KWbase.alt, KWbase.req);\n\t\tfmt = \"kw_%d};\\n\";\n\t\t}\n\tif (nwant)\n\t\tnslist(nsname, \"%s::\");\n\tprintf(fmt, kwkno);\n\n\tprintf(\"#ifdef __cplusplus\\n\");\n\tprintf(\"}\\n\");\n\tprintf(\"#endif\\n\");\n\n\tif (startwarn && missing && !guikeywds)\n\t\tfprintf(stderr, \"%s: %d start routines implicitly named.\\n\",\n\t\t\tprogname, missing);\n\t}\n\n typedef struct Valhash Valhash;\n\n struct\nValhash {\n\tDefhashHead hh;\n\tUint n;\n\tValhash *thread;\n\t};\n\n static Kwpack *kwpack, *kwpack0, *kwpacke;\n static size_t kwpack_len, strtab_len = 1;\n static DefhashTab FpTab, StrTab;\n static Valhash *FpTabLast, *StrTabLast;\n\n static Uint\nNumOff(char *name)\n{\n\tValhash *v;\n\tif (!name || !*name || (*name == '0' && !name[1]))\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &FpTab, 1);\n\tif (!v->n) {\n\t\tv->n = FpTab.nent;\n\t\tv->thread = FpTabLast;\n\t\tFpTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static Uint\nStrOff(char *name)\n{\n\tValhash *v;\n\tif (!name)\n\t\treturn 0;\n\tv = (Valhash*)DHHlookup(name, &StrTab, 1);\n\tif (!v->n) {\n\t\tv->n = strtab_len;\n\t\tstrtab_len += strlen(name) + 1;\n\t\tv->thread = StrTabLast;\n\t\tStrTabLast = v;\n\t\t}\n\treturn v->n;\n\t}\n\n static void\nkwjout(KWctx *kw, KWctx **kwtop)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, **x, *x0[KWOUTlen0];\n\tKwpack *p;\n\tUint lastknoj;\n\tint i, m, n;\n\tsize_t L;\n\n\tkw1 = kw->kw;\n\tn = 0;\n\tlastknoj = kwpack - kwpack0 + 1;\n\tif (kw->names) {\n\t\tkw0 = kw1;\n\t\tif (kw->parstate != KwStacked)\n\t\t\tfor(kw2 = kw->pparent; kw2; kw2 = kw2->pparent) {\n\t\t\t\tkw2->next = kw1;\n\t\t\t\tkw1 = kw2;\n\t\t\t\t++n;\n\t\t\t\t}\n\t\tif (!kw0) {\n\t\t\tif (!--n) {\n\t\t\t\tkw->nkw = kw1->nkw;\n\t\t\t\tif (kw1->kwkno) {\n\t\t\t\t\tkw->kwkno = kw1->kwkno;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw->kwkno = lastknoj;\n\t\t\t\tkw = kw1;\n\t\t\t\tkw1 = kw->kw;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tkw2 = kw->pparent;\n\t\t\t\tif (kw2->kwknop) {\n\t\t\t\t\tkw->kwkno = kw2->kwknop;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tkw2->kwknop = lastknoj;\n\t\t\t\tkw1 = kw2;\n\t\t\t\twhile((kw2 = kw2->pparent)) {\n\t\t\t\t\tkw2->next = kw1;\n\t\t\t\t\tkw1 = kw2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(m = 0, kw0 = kw1; kw0; kw0 = kw0->next)\n\t\t++m;\n\tx = x0;\n\tif (m > KWOUTlen0)\n\t\tx = (KWctx**)Malloc(m*sizeof(KWctx*), \"kwjout\");\n\tm = 0;\n\tfor(kw0 = kw1; kw0; kw0 = kw0->next)\n\t\tx[m++] = kw0;\n\tkw->kwkno = lastknoj;\n\t++lastkno;\n\tfor(i = 0; i < m;) {\n\t\tif (++kwpack >= kwpacke) {\n\t\t\tL = 2*kwpack_len;\n\t\t\tkwpack0 = (Kwpack*)Realloc(kwpack0, L*sizeof(Kwpack), \"kwjout\");\n\t\t\tkwpacke = kwpack0 + L;\n\t\t\tkwpack = kwpack0 + kwpack_len;\n\t\t\tmemset(kwpack, 0, kwpack_len*sizeof(Kwpack));\n\t\t\tkwpack_len = L;\n\t\t\t}\n\t\tp = kwpack;\n\t\tkw1 = x[i++];\n\t\tif (!(kwm = kw1->master))\n\t\t\tkwm = kw1;\n\t\tp->nkw = kwm->nkw;\n\t\tif (kw1->names) {\n\t\t\tp->name = StrOff(kw1->names->val);\n\t\t\tp->kind = kw1->kind | kw1->names->primary;\n\t\t\tp->alt = kwm->alt + kwm->altoffset;\n\t\t\tif (kwm->req)\n\t\t\t\tp->req = kwm->req + kwm->reqoffset;\n\t\t\tif (kwm->dylib) {\n\t\t\t\tp->dylib = StrOff(kwm->dylib);\n\t\t\t\tp->kind |= KWKind_Dynlib;\n\t\t\t\t}\n\t\t\t}\n\t\tp->kw = kwm->kwkno;\n\t\tp->Lb = NumOff(kw1->lb);\n\t\tp->Ub = NumOff(kw1->ub);\n\t\tp->poff = kw1->paoff;\n\t\t}\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static Valhash *\nVreverse(Valhash *sh)\n{\n\tValhash *sh0, *sh1;\n\tfor(sh0 = 0; sh; sh = sh1) {\n\t\tsh1 = sh->thread;\n\t\tsh->thread = sh0;\n\t\tsh0 = sh;\n\t\t}\n\treturn sh0;\n\t}\n\n static void\nkwpack_adjust(Kwpack *kp, Uint nkw)\n{\n\tKwpack0 *qp, *qpe;\n\n\tqp = (Kwpack0*)kp;\n\tfor(qpe = qp + nkw; qp < qpe; ++kp, ++qp) {\n\t\tmemcpy(qp, kp, sizeof(Kwpack0) - sizeof(int));\n\t\tqp->poff = kp->poff;\n\t\t}\n\t}\n\n static void\njOutput(char *jfname)\n{\n\tFILE *f;\n\tKWctx *kw, *kw1, *kw2, **kwtop, **kwbot;\n\tKwpack *kp;\n\tUint nkw0;\n\tValhash *vh;\n\tdouble d;\n\tsize_t L, Lkw, Ls;\n\tstatic KwpHead head = { \"DakreorderKwds\\n\", 1e13, 0x1234abcd };\n\tstatic double zbuf[2];\n\n\tFpTab.nalloc  = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tStrTab.nalloc = (sizeof(Valhash) + sizeof(void*) - 1)/sizeof(void*);\n\tkwpack_len = 128;\n\tkwpack = kwpack0 = (Kwpack*)Malloc(kwpack_len * sizeof(Kwpack), \"jOutput\");\n\tmemset(kwpack, 0, kwpack_len * sizeof(Kwpack));\n\tkwpacke = kwpack0 + kwpack_len;\n\tkwtop = kwbot = KWStack;\n\t*kwtop = &KWbase;\n\tfor(;;--kwtop) {\n top:\n\t\tfor(kw = *kwtop; kw; kw = kw->next) {\n\t\t\tif ((kw->master && kw->master != kw)\n\t\t\t|| ((!(kw1 = kw->pparent) || kw->parstate == KwStacked) && !kw->kw)\n\t\t\t|| kw->kwkno)\n\t\t\t\tcontinue;\n\t\t\tif (kw1 && kw1->parstate != KwStacked) {\n\t\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t*kwtop = kw;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != KwStacked) {\n\t\t\t\t\t\tkw1->parstate = KwStacked;\n\t\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t\tkw2 = *++kwtop = kwsort(kw1);\n\t\t\t\t\t\tdo kw2->parstate = KwStacked;\n\t\t\t\t\t\t\twhile((kw2 = kw2->next));\n\t\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t\t}\n\t\t\t\tif (!kw1 && !kw->kw)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif (!kw->nkw && kw->kw) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\t*++kwtop = kwsort(kw);\n\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tkwjout(kw, kwtop);\n\t\t\t}\n\t\tif (kwtop == kwbot)\n\t\t\tbreak;\n\t\t}\n\tStrTabLast = Vreverse(StrTabLast);\n\tFpTabLast = Vreverse(FpTabLast);\n\tnkw0 = kwpack - kwpack0;\n\thead.nkw = nkw0 + 1;\n\tkp = kwpack0;\n\tkp->kw = nkw0 - KWbase.nkw + 1;\n\tkp->nkw = KWbase.nkw;\n\tkp->alt = KWbase.alt;\n\tkp->req = KWbase.req;\n\thead.strtab_offset = (FpTab.nent+1)*sizeof(double);\n\tLs = (strtab_len + 7) & ~7;\n\thead.kw_offset = head.strtab_offset + Ls;\n\tif ((head.pad = dynlibseen))\n\t\tLkw = sizeof(Kwpack);\n\telse {\n\t\tLkw = sizeof(Kwpack0);\n\t\tkwpack_adjust(kp, head.nkw);\n\t\t}\n\thead.end_offset = head.kw_offset + head.nkw * Lkw;\n\tf = fopen(jfname, \"wb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open \\\"%s\\\"\\n\", jfname);\n\t\texit(1);\n\t\t}\n\tfwrite(&head, sizeof(head), 1, f);\n\tfor(vh = FpTabLast; vh; vh = vh->thread) {\n\t\td = strtod(vh->hh.name,0);\n\t\tfwrite(&d, sizeof(double), 1, f);\n\t\t}\n\tfwrite(&zbuf,9,1,f);\n\tfor(vh = StrTabLast; vh; vh = vh->thread)\n\t\tfwrite(vh->hh.name, strlen(vh->hh.name) + 1, 1, f);\n\tif ((L = Ls - strtab_len))\n\t\tfwrite(&zbuf, L, 1, f);\t/* align */\n\tfwrite(kp, Lkw, head.nkw, f);\n\tfclose(f);\n\t}\n\n typedef int (*KWcomp)(const void*, const void*);\n\n static const char **zalt;\n\n static int\nkwcomp1(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static int\nkwcomp2(const void *a, const void *b)\n{\n\tconst KWctx *ka, *kb, *pa, *pb;\n\n\tka = *(const KWctx**)a;\n\tkb = *(const KWctx**)b;\n\tif (ka->req) {\n\t\tif (!kb->req)\n\t\t\treturn -1;\n\t\t}\n\telse if (kb->req)\n\t\treturn 1;\n\tif (ka->alt == kb->alt) {\n\t\tpa = ka->master ? ka->master->pparent : ka->pparent;\n\t\tpb = kb->master ? kb->master->pparent : kb->pparent;\n\t\tif (pa != pb)\n\t\t\treturn ka->objno - kb->objno;\n\t\tif (ka->master != kb->master) {\n\t\t\tif (!ka->master)\n\t\t\t\treturn -1;\n\t\t\tif (!kb->master)\n\t\t\t\treturn 1;\n\t\t\tka = ka->master;\n\t\t\tkb = kb->master;\n\t\t\t}\n\t\treturn strcmp(ka->names->val, kb->names->val);\n\t\t}\n\treturn strcmp(zalt[ka->alt], zalt[kb->alt]);\n\t}\n\n static void\ndo_sort(KWctx *kw, KWcomp KWcmp)\n{\n\tKWctx *kw1, *kwm, **x, *x0[KWPlen];\n\tconst char *z0[KWPlen];\n\tint i, n, na;\n\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\t++n;\n\t\treverse(&kw1->names);\n\t\t}\n\tif (n <= 1)\n\t\treturn;\n\tx = n > KWPlen ? (KWctx**)Malloc(n*sizeof(KWctx*), \"do_sort\") : x0;\n\tna = kw->nalt + 1;\n\tzalt = na <= KWPlen ? z0 : (const char**)Malloc(na*sizeof(const char*), \"do_sort\");\n\tmemset(zalt, 0, na*sizeof(const char*));\n\tfor(n = 0, kw1 = kw->kw; kw1; kw1 = kw1->next) {\n\t\tx[n++] = kw1;\n\t\tif ((kwm = kw1->master))\n\t\t\tkwm->master = kwm;\n\t\tif (!zalt[i = kw1->alt]\n\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\tzalt[i] = kw1->names->val;\n\t\t}\n\tqsort(x, n--, sizeof(KWctx*), KWcmp);\n\tfor(i = 0; i < n; ++i)\n\t\tx[i]->next = x[i+1];\n\tx[n]->next = 0;\n\tkw->kw = x[0];\n\tif (zalt != z0)\n\t\tfree(zalt);\n\tif (x != x0)\n\t\tfree(x);\n\t}\n\n static void\nksort(KWcomp KWcmp)\n{\n\tKWctx *kw, *kw1, **kwtop, **kwtop0, **kwbot;\n\n\tkwtop = kwbot = KWStack;\n\n\tfor(*kwtop = &KWbase;; --kwtop) {\n top:\n\t\tkw = *kwtop;\n top1:\n\t\twhile(kw) {\n\t\t\tif ((kw1 = kw->pparent) && kw1->parstate != Sorted) {\n\t\t\t\t*kwtop = kw;\n\t\t\t\tkwtop0 = kwtop;\n\t\t\t\tdo {\n\t\t\t\t\tkw1->parstate = Sorted;\n\t\t\t\t\t*++kwtop = kw1;\n\t\t\t\t\t}\n\t\t\t\t\twhile((kw1 = kw1->pparent) && kw1->parstate != Sorted);\n\t\t\t\tif (kwtop > kwtop0)\n\t\t\t\t\tgoto top;\n\t\t\t\t}\n\t\t\tif (kw->kw) {\n\t\t\t\tdo_sort(kw, KWcmp);\n\t\t\t\tif ((*kwtop = kw->next))\n\t\t\t\t\t++kwtop;\n\t\t\t\tkw = *kwtop = kw->kw;\n\t\t\t\tgoto top1;\n\t\t\t\t}\n\t\t\tkw = kw->next;\n\t\t\t}\n\t\tif (kwtop <= kwbot)\n\t\t\tbreak;\n\t\t}\n\t}\n\n static void\npretty_ex1(KWctx *kw, KWctx *prevkw, KWctx *nextkw, int indent, int iinc, int needrev)\n{\n\tKWctx *kw0, *kw1, *kw2, *kwm, *kwp, *kwp0, **x, *y, *y1;\n\tconst char *suf, *z0[KWPlen];\n\tint ep, i, i0, ia, j, n, na, np;\n\n\tn = 0;\n\tx = 0;\n\ty = 0;\n\tkw1 = kw->kw;\n\tif (needrev == 1)\n\t\tneedrev = 2;\n\tif ((kwp0 = kwp = kw->pparent) && (!kw->master || kw->master == kw)) {\n\t\tfor(;;) {\n\t\t\tif (kwp->parstate != Printing) {\n\t\t\t\tkwp->parstate = Printing;\n\t\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t\tkw1->pparent = 0;\t/* avoid infinite loops */\n\t\t\t\t}\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next)\n\t\t\t\t++n;\n\t\t\tif (!(kw1 = kwp->pparent))\n\t\t\t\tbreak;\n\t\t\tkwp = kwp->pparent = kw1;\n\t\t\t}\n\t\tnp = n;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\t++n;\n\t\ty = y1 = (KWctx*)Malloc(np*sizeof(KWctx) + n*sizeof(KWctx*), \"pretty_ex1\");\n\t\tx = (KWctx**)(y + np);\n\t\tfor(i = 0, kw1 = kw->kw; kw1; kw1 = kw1->next)\n\t\t\tx[i++] = kw1;\n\t\ti0 = i;\n\t\tfor(kwp = kwp0; kwp; kwp = kwp->pparent) {\n\t\t\tj = i;\n\t\t\tna = i + kwp->nalt;\n\t\t\tfor(kw1 = kwp->kw; kw1; kw1 = kw1->next, ++y1) {\n\t\t\t\tmemcpy(y1, kw1, sizeof(KWctx));\n\t\t\t\tx[i++] = y1;\n\t\t\t\ty1->alt += j;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!needrev) {\n\t\t\tfor(j = i0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t}\n\t\t\tzalt = ++na <= KWPlen ? z0\n\t\t\t\t: (const char**)Malloc(na*sizeof(const char*), \"pretty_ex1\");\n\t\t\tmemset(zalt, 0, na*sizeof(const char*));\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif ((kwm = kw1->master))\n\t\t\t\t\tkwm->master = kwm;\n\t\t\t\tif (!zalt[i = kw1->alt]\n\t\t\t\t || strcmp(kw1->names->val, zalt[i]) < 0)\n\t\t\t\t\tzalt[i] = kw1->names->val;\n\t\t\t\t}\n\t\t\tqsort(x, n, sizeof(KWctx*), kwcomp1);\n\t\t\tif (zalt != z0)\n\t\t\t\tfree(zalt);\n\t\t\tfor(j = 0; j < n; ++j) {\n\t\t\t\tkw1 = x[j];\n\t\t\t\tif (kw1->nreq < 0) {\n\t\t\t\t\tkw1->nreq = -(kw1->nreq + 1);\n\t\t\t\t\tkw1->pparent = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tkw1 = x[0];\n\t\txmasteradj(x, n);\n\t\t}\n\tif (kw1) {\n\t\tif (!x)\n\t\t\tkw1 = masteradj(kw->kw);\n\t\tep = kw->req;\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tia = kw->master && kw->master == prevkw->master ? iinc : 0;\n\t\t\tdo_indent(indent + ia);\n\t\t\tif (!prevkw->master || prevkw->master != kw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent + ia);\n\t\t\t\tputchar('(');\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tputchar('|');\n\t\t\t}\n\t\telse {\n\t\t\tdo_indent(indent);\n\t\t\tif (kw->req)\n\t\t\t\tputchar('('/*)*/);\n\t\t\telse {\n\t\t\t\tputchar('[');\n\t\t\t\tif (nextkw && !nextkw->req && kw->alt == nextkw->alt) {\n\t\t\t\t\tep = 1;\n\t\t\t\t\tdo_indent1(iinc);\n\t\t\t\t\tputchar('(');\n\t\t\t\t\tindent += iinc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdo_indent1(iinc);\n\t\tindent += iinc;\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\ti = 0;\n\t\tkw0 = 0;\n\t\twhile(kw1) {\n\t\t\tif (x)\n\t\t\t\tkw2 = ++i >= n ? 0 : x[i];\n\t\t\telse\n\t\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, indent, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\tkw1 = kw2;\n\t\t\t}\n\t\tif (x)\n\t\t\tfree(y);\n\t\tdo_indent(indent);\n\t\tfputs(ep ? \")\\n\" : \"]\\n\", stdout);\n\t\t}\n\telse {\n\t\tif (prevkw && kw->alt == prevkw->alt\n\t\t && kw->master && kw->master == prevkw->master)\n\t\t\tindent += iinc;\n\t\tdo_indent(indent);\n\t\tsuf = \"\\n\";\n\t\tif (prevkw && kw->alt == prevkw->alt) {\n\t\t\tif (kw->master && kw->master != prevkw->master) {\n\t\t\t\tfputs(\"|\\n\", stdout);\n\t\t\t\tdo_indent(indent);\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tfputs(\"| \", stdout);\n\t\t\t\tif (!kw->req)\n\t\t\t\t\tgoto rbcheck;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (kw->req) {\n\t\t\tif (prevkw) {\n\t\t\t\tif (prevkw->master != kw->master)\n\t\t\t\t\tgoto putlpar;\n\t\t\t\t}\n\t\t\telse if (kw != kw->master && kw->master) {\n putlpar:\n\t\t\t\tfputs(\"( \", stdout);\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tfputs(\"[ \", stdout);\n rbcheck:\n\t\t\tif (!nextkw || nextkw->alt != kw->alt)\n\t\t\t\tsuf = \" ]\\n\";\n\t\t\t}\n\t\tprkwname(kw, suf, needrev);\n\t\t}\n\t}\n\n static void\npretty_expand(int iinc, int needrev)\n{\n\tKWctx *kw, *kw0, *kw1, *kw2;\n\n\tif ((kw = KWbase.kw)) for(;;) {\n\t\tmasteradj(kw->kw);\n\t\tfputs(KEYKIND[(kw->kind >> KWtopshift) & 3], stdout);\n\t\tprkwname(kw, \"\\n\", needrev);\n\t\tkw0 = 0;\n\t\tfor(kw1 = kw->kw; kw1; kw1 = kw2) {\n\t\t\tkw2 = kw1->next;\n\t\t\tpretty_ex1(kw1, kw0, kw2, 0, iinc, needrev);\n\t\t\tkw0 = kw1;\n\t\t\t}\n\t\tif (!(kw = kw->next))\n\t\t\tbreak;\n\t\tputchar('\\n');\n\t\t}\n\t}\n\n static int\nStr_option(char *s, char ***pav, int *want, StrList **ps)\n{\n\tif (*++s || (s = *++*pav)) {\n\t\tif (*s == '-' && ! s[1])\n\t\t\t*want = 0;\n\t\telse\n\t\t\t*ps = new_StrList(s, *ps);\n\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}\n\n static int\nversion(void)\n{\n\tprintf(\"nidrgen version 20100528\\n\");\n\treturn 0;\n\t}\n\n static int\ntagcomp(const void *a, const void *b)\n{\n\treturn strcmp(*(const char**)a, *(const char**)b);\n\t}\n\n static int\nunused_tags()\n{\n\tTaghash *th;\n\tchar **x;\n\tsize_t i, nbad;\n\n\tnbad = 0;\n\tfor(th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\t++nbad;\n\tif (!nbad)\n\t\treturn 0;\n\tx = (char**)Malloc(nbad*sizeof(char*), \"unsed_tags\");\n\tfor(i = 0, th = (Taghash*)TagTab.lastdh; th; th = (Taghash*)th->hh.thread)\n\t\tif (!th->uses)\n\t\t\tx[i++] = th->hh.name;\n\tfprintf(stderr, \"%lu unused tag definition%s in %s:\\n\",\n\t\t(unsigned long)nbad, \"s\" + (nbad == 1), tagfname);\n\tif (nbad > 1)\n\t\tqsort(x, nbad, sizeof(char*), tagcomp);\n\tfor(i = 0; i < nbad; ++i)\n\t\tfprintf(stderr, \"\\t\\\"%s\\\"\\n\", x[i]);\n\tfree(x);\n\treturn 1;\n\t}\n\n static int\ndefcomp(const void *a, const void *b)\n{\n\treturn strcmp((*(const Defhash**)a)->hh.name, (*(const Defhash**)b)->hh.name);\n\t}\n\n static void\nwrite_defs(FILE *f)\n{\n\tDefhash *d, **x, **x1;\n\tDefhashHead *dh;\n\tsize_t i, n;\n\n\tn = DHTab.nent;\n\tx = x1 = (Defhash**)Malloc(n*sizeof(Defhash*), \"write_defs\");\n\tfor(dh = DHTab.lastdh, i = 0; dh; dh = dh->thread) {\n\t\tif (++i > n)\n\t\t\tbotch(\"lastdef count botch\");\n\t\t*x1++ = (Defhash*)dh;\n\t\t}\n\tqsort(x, n, sizeof(Defhash*), defcomp);\n\tfor(i = 0; i < n; ++i) {\n\t\td = x[i];\n\t\tfprintf(f, d->qkeep ? \"#define %s \\\"%s\\\"\\n\"\n\t\t\t: \"#define %s %s\\n\",\n\t\t\td->hh.name, d->value);\n\t\t}\n\t}\n\n int\nmain(int argc, char **argv)\n{\n\tFILE *f;\n\tStrList *headers, *mtagname, *nsname, *outtagname;\n\tchar *defsout, *jfname, *ofname, *s, *se;\n\tconst char *kname, *libex, *libname;\n\tint defwrite, dupcheck, hwant, libmode, needrev, nwant, pprint, sort, x;\n\n\tKWStack[0] = &KWbase;\n\tDHTab.nalloc  = (sizeof(Defhash) + sizeof(void*) - 1)/sizeof(void*);\n\tTagTab.nalloc = (sizeof(Taghash) + sizeof(void*) - 1)/sizeof(void*);\n\tKWbase.names = new_StrList(\"$top\",0);\n\tprogname = argv[0];\n\tif (argc <= 1)\n usage1:\treturn usage(1);\n\theaders = mtagname = nsname = outtagname = 0;\n\tkname = libex = libname = defsout = jfname = ofname = 0;\n\tdupcheck = hwant = needrev = nwant = 1;\n\tdefwrite = libmode = pprint = sort = 0;\n nextopt:\n\twhile((s = *++argv) && *s == '-' && s[1]) {\n\t\twhile(*++s)\n\t\tswitch(*s) {\n\t\t case 'D':\n\t\t\tdefwrite = libexpand = 1;\n\t\t\tlibex = \"-D\";\n\t\t\tbreak;\n\t\t case 'T':\n\t\t\tif (Str_option(s, &argv, &hwant, &outtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'd':\n\t\t\tdupcheck = 0;\n\t\t\tbreak;\n\t\t case 'e':\n\t\t\texpand = 1;\n\t\t\tbreak;\n\t\t case 'f':\n\t\t\twantfuncs = 0;\n\t\t\tbreak;\n\t\t case 'g':\n\t\t\tguikeywds = libexpand = 1;\n\t\t\tlibex = \"-g\";\n\t\t\tbreak;\n\t\t case 'G':\n\t\t\tdfltgroup = 0;\n\t\t\tbreak;\n\t\t case 'h':\n\t\t\tif (Str_option(s, &argv, &hwant, &headers))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'j':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tjfname = s;\n\t\t\tlibexpand = 1;\n\t\t\tlibex = \"-j\";\n\t\t\tgoto nextopt;\n\t\t case 'k':\n\t\t\tif (!*++s && !(s = *++argv))\n\t\t\t\tgoto usage1;\n\t\t\tkname = s;\n\t\t\tlibmode = 1;\n\t\t\tgoto nextopt;\n\t\t case 'l':\n\t\t\tlibmode = 1;\n\t\t\tbreak;\n\t\t case 'L':\n have_L:\n\t\t\tif (*++s)\n\t\t\t\tlibname = s;\n\t\t\telse if (!(libname = *++argv))\n\t\t\t\treturn usage(1);\n\t\t\tgoto nextopt;\n\t\t case 'm':\n\t\t\tif (Str_option(s, &argv, &hwant, &mtagname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 'n':\n\t\t\tif (Str_option(s, &argv, &nwant, &nsname))\n\t\t\t\tgoto usage1;\n\t\t\tgoto nextopt;\n\t\t case 't':\n\t\t\tignoretags = 1;\n\t\t\tbreak;\n\t\t case 's':\n\t\t\tsort = 1;\n\t\t\tneedrev = 0;\n\t\t\tlibex = \"-s\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L': ++s; goto have_L;\n\t\t\t\t  case 'e': expand = 1;\n\t\t\t\t\t    continue;\n\t\t\t\t  case 'f': wantfuncs = 0;\n\t\t\t\t  case 'p': continue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t case 'p':\n\t\t\tlibexpand = 1;\n\t\t\tpprint = 2;\n\t\t\tif (!libex)\n\t\t\t\tlibex = \"-p\";\n\t\t\tfor(;;++s) {\n\t\t\t\tswitch(s[1]) {\n\t\t\t\t  case 'L':\n\t\t\t\t\t++s;\n\t\t\t\t\tgoto have_L;\n\t\t\t\t  case 'e':\n\t\t\t\t\texpand = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 'f':\n\t\t\t\t\twantfuncs = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 's':\n\t\t\t\t\tsort = 1;\n\t\t\t\t\tneedrev = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t  case 't':\n\t\t\t\t\tignoretags = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (*++s) {\n\t\t\t\tpprint = (int)strtol(s,&se,10);\n\t\t\t\tif (pprint < 1 || se)\n\t\t\t\t\tgoto usage1;\n\t\t\t\t}\n\t\t\tgoto nextopt;\n\t\t case 'v':\n\t\t\treturn version();\n\t\t case 'w':\n\t\t\tstartwarn = 0;\n\t\t\tbreak;\n\t\t case '?':\n\t\t\treturn usage(s[1] != 0);\n\t\t case '-':\n\t\t\tif (!strcmp(++s,\"help\"))\n\t\t\t\treturn usage(0);\n\t\t\tif (!strcmp(s,\"version\"))\n\t\t\t\treturn version();\n\t\t\tif (!*s) {\n\t\t\t\ts = *++argv;\n\t\t\t\tgoto argsdone;\n\t\t\t\t}\n\t\t\t/* no break */\n\t\t  default:\n\t\t\tgoto usage1;\n\t\t  }\n\t\t}\n argsdone:\n\tif (libname) {\n\t\tif (s && argv[1] && argv[2])\n\t\t\treturn usage(1);\n\t\tif ((defsout = s))\n\t\t\tofname = argv[1];\n\t\tif (mtagname) {\n\t\t\tfprintf(stderr, \"\\n%s: ignoreing -m due to -L\\n\", progname);\n\t\t\tmtagname = 0;\n\t\t\t}\n\t\tgoto lcheck;\n\t\t}\n\tif (!s || (argv[1] && argv[2] && argv[3] && argv[4]))\n\t\treturn usage(1);\n\tif ((tagfname = argv[1])) {\n\t\tspecfile = s;\n\t\ts = tagfname;\n\t\tlastseen = Saw_kwname;\n\t\tlastkw1 = &KWbase;\n\t\tif ((defsout = argv[2]))\n\t\t\tofname = argv[3];\n\t\t}\n\telse if (mtagout) {\n\t\tfprintf(stderr, \"%s: -m specified but no tagfile given.\\n\", progname);\n\t\treturn 1;\n\t\t}\n\tif (*s == '-' && !s[1])\n\t\tyyin = stdin;\n\telse if (!(yyin = fopen(infname = s, \"r\"))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n\tif (specfile)\n\t\ttagin = yyin;\n\tif ((mtagname && (!(mtagout = fopen(s = mtagname->val, \"w\"))))\n\t || (outtagname && !(tagout = fopen(s = outtagname->val, \"w\")))) {\n\t\tcantopen(s);\n\t\treturn 1;\n\t\t}\n lcheck:\n\tif (libmode) {\n\t\twantfuncs |= 2;\n\t\tif (libexpand && kname) {\n\t\t\tlibmode = 0;\n\t\t\tfprintf(stderr, \"\\n%s: ignoring -k due to %s\\n\",\n\t\t\t\tprogname, libex);\n\t\t\t}\n\t\t}\n\telse\n\t\tlibexpand = 0;\n\tif (libname)\n#ifndef NO_NIDR_DYNLIB\n\t\tlibread1(0, libname, 0, 2);\n#else\n\t\t{\n\t\tfprintf(stderr, \"\\ndlopen for \\\"%s\\\" is NOT SUPPORTED\\n\", libname);\n\t\treturn usage(1);\n#endif\n\t\t}\n\telse if ((x = yylex())) {\n\t\tfprintf(stderr, \"\\n%s: Surprise return %d from yylex()\\n\", progname, x);\n\t\treturn x;\n\t\t}\n\tif (mtagout)\n\t\tfclose(mtagout);\n\tif (tagout)\n\t\tfclose(tagout);\n\tif (tagout || mtagout)\n\t\tgoto done;\n\tif (Br_top > Br_stack) {\n\t\tfputs(\"Missing \", stderr);\n\t\tdo putc(/*[*/ *Br_top-- == '(' ? ')' : ']', stderr);\n\t\t\twhile(Br_top >Br_stack);\n\t\tfputs(\" at end of file.\\n\", stderr);\n\t\treturn 1;\n\t\t}\n\tif (nsquawk > liberror)\n\t\treturn 1;\n\tif (tagfname && unused_tags())\n\t\treturn 1;\n\tif (KWbase.kw) {\n\t\tparadj(needrev);\n\t\tif (dupcheck)\n\t\t\tdup_check();\n\t\t}\n\tif (jfname)\n\t\tofname = 0;\n\telse if (ofname && !freopen(ofname, \"w\", stdout)) {\n\t\tfprintf(stderr, \"%s: Cannot open output file \\\"%s\\\"\\n\", progname, ofname);\n\t\treturn 1;\n\t\t}\n\tif (KWbase.kw) {\n\t\tif (pprint) {\n\t\t\tif (expand) {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp1);\n\t\t\t\tpretty_expand(pprint, needrev);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sort)\n\t\t\t\t\tksort(kwcomp2);\n\t\t\t\tpretty_print(pprint, needrev);\n\t\t\t\t}\n\t\t\t}\n\t\telse if (!defwrite) {\n\t\t\tif (jfname)\n\t\t\t\tjOutput(jfname);\n\t\t\telse\n\t\t\t\tOutput(headers, nsname, hwant, kname,\n\t\t\t\t\tguikeywds ? 0 : libmode, nwant);\n\t\t\t}\n\t\telse if (DHTab.lastdh)\n\t\t\twrite_defs(stdout);\n\t\t}\n\tif (!defwrite && defsout) {\n\t\tf = fopen(defsout,\"w\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"%s:  cannot open defs file \\\"%s\\\"\\n\",\n\t\t\t\tprogname, defsout);\n\t\t\treturn 1;\n\t\t\t}\n\t\twrite_defs(f);\n\t\tfclose(f);\n\t\t}\n done:\n\treturn dupnames > 0 ? 1 : liberror ? 2 : 0;\n\t}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/cmake/FindDL.cmake": "###############################################################################\n# CMake macro to find libdl library.\n#\n# On success, the macro sets the following variables:\n# DL_FOUND       = if the library found\n# DL_LIBRARY     = full path to the library\n# DL_INCLUDE_DIR = where to find the library headers \n#\n# Author: Mateusz Loskot <mateusz@loskot.net>\n#\n# Redistribution and use is allowed according to the terms of the BSD license.\n# For details see the accompanying COPYING-CMAKE-SCRIPTS file.\n#\n###############################################################################\nif(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/src/java_utils/antlr-runtime-4.1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge.resu",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/compiled_interfaces/Scilab/Bridge/bridge_opt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/script_interfaces/TankExamples/VVTankProblem.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/script_interfaces/Abaqus/tpb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/script_interfaces/VisualBasic/Rosenbrock.xls",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/script_interfaces/Nastran/cylinder/modal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/eval_surrogate/eval_surrogate.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/training/solutions/optimization/cantilever_contours.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/training/examples/pstudy_pics/demo_lhs_norm.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/training/examples/pstudy_pics/demo_lhs_unif.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/training/examples/pstudy_pics/demo_grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/training/examples/pstudy_pics/demo_centered.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/linked_interfaces/ModelCenter/lib/i686-cygwin-cygwinNT/libPHXCppApi.a",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/linked_interfaces/ModelCenter/lib/i686-cygwin-cygwinNT/PHXCppApi.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/hdf5/incremental_sampling/dakota_results.h5",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/hdf5/centered_parameter_study/dakota_results.h5",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/examples/parallelism/Dakota_Application_Parallelism.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/admin/vpy/python.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/3po/mvs/v8/Debug/hooke.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/3po/mvs/v8/Release/cobyla2c.exe",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/3po/mvs/v8/Release/python25.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/tinyxml/tinyxml/xmltest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/tinyxml/tinyxml/utf8test.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/tinyxml/tinyxml/tinystr.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/vpykit/python.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/guide.epub",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/example.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/prev.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/next.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/home.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/caution.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/tip.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/note.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/important.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/cxxtest/doc/images/icons/callouts/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/momhlib/MOMHLib/HGA/hgabase.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/momhlib/NewProblemTemplate/NewProblemTemplate.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/momhlib/moscp/MOSCP.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/tpl/momhlib/MOKP/mokp.opt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/refs.dox",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/refs.html",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/form_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/uguide/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/interfaces/doc/figs/GSGA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/colin/test/driver/simple1.nl",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/colin/doc/05-01-ICS-COLIN.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/src/utilib/bimap.h",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/test/studies/fserialstream.ref",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/doc/userman.pdf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/doc/uguide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/utilib/doc/uguide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/refs.dox",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/refs.html",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/form_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/uguide/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/scolib/doc/figs/GSGA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/sample-load-graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4.1/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/sample-load-graph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.6/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.3/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/parinherit-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/layers.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/globalsub.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/framework.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/framework.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/threads-new.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/states-horizontal.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/threads-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/states-horizontal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/layers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/globalsub.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/packages/pebbl/doc/uguide/1.4/parinherit-new.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/doc/uguide/userman.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/doc/uguide/acro.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/doc/uguide/acro.tif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/acro/doc/coliny/ColinyCommand_3_0.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/DDACE/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/DDACE/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/DDACE/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/CONMIN/Conmin_manual/conmin_manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/config/ac_cxx_compiler_vendor.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/config/_ac_c_ifdef.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/config/ac_cxx_cppflags_std_lang.m4",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/lib/optMaui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/lbllogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/nersclogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/doxygen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/gensetMin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_opt++.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_classpath.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/sandialogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/tBird2D.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_subroutine.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_arrays.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/opt++_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_nips.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/gensetBox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_config.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_startup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_application.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/gensetStd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_noaction.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/csmrlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/maui_advanced.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/OPTPP/docs/images/bckgnd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/queso/QUESO_users_manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/queso/src/contrib/ANN/doc/ANNmanual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/queso/test/test_StatisticalInverseProblem/output_test_parallel_h5_expected.h5",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/experimental/crtp/src/vector/.XROL_Vector_SimOpt.hpp.swo",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick1.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/wheel1.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/wheel0.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick2.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/thermal-fluids/tf-cube.cub",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/poisson/p-cube-8x8x8.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/example/PDE-OPT/poisson/p-cube-4x4x4.e",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/rol_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/rol_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/ROL_Doxygen_Dec-11-2013.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/rol.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/rol.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/trilinos/packages/rol/doc/rol.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NCSUOpt/userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/interfaces/DLL/single_obj/bb.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/interfaces/DLL/bi_obj/bb.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/interfaces/Matlab_MEX/nomadset.m",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/advanced/plot/GUI/f1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/advanced/plot/GUI/f2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/advanced/plot/GUI/bbe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/examples/advanced/plot/GUI/obj.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/tools/SENSITIVITY/2739.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/tools/SENSITIVITY/problems/cube/detailed/cache.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/tools/PSD-MADS_library_mode/SJE001150.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/tools/PSD-MADS/SJE001150.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/user_guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/logos/nomad_logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/logos/nomadTransp.icns",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/logos/nomad_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/logos/Nomad_background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/NOMAD/doc/logos/nomadIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/approxnn/doc/ANNmanual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/sciplot/SciPlotDocs/new.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/sciplot/SciPlotDocs/SciPlotTitle.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/sciplot/SciPlotDocs/SciPlotDemo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/sciplot/SciPlotDocs/SciPlotExample.gif",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/website/HOPSPACK_Logo_120x118.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/website/HOPSPACK_SNL_NNSA_100x734.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/website/usermanual_image_tiny.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/BlockDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/winmsvc_build.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalWithMpiClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalWithMpi.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/GssHierarchyDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/BlockDiagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/winconsole_cmake.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalDiagramClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalWithMt.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/EvalWithMtClipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/GssHierarchyDiagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/doc/winconsole_cmake_msvc.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/hopspack/community_problems/community_appspack.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/lib/x86/pthreadVSE2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/lib/x86/pthreadVC2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/lib/x64/pthreadVC2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/dll/x86/pthreadVSE2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/dll/x86/pthreadGC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/dll/x86/pthreadGCE2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/dll/x86/pthreadVC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/eddy/threads/pthreads/dll/x64/pthreadVC2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/FrontEnd/Managed/vc71/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/FrontEnd/Managed/vc90/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/FrontEnd/Managed/vc80/app.ico",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/images/JEGAFlow.doc",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/images/mogatest1_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/images/scope_trace.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/images/pareto_front.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/images/JEGAFlow.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/JEGA/docs/users/bibliography/bibliography.bib",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/dylib_test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/dylib_test3.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/external/nidr/dylib_test2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/examples/SamplingTechniques/random.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/examples/SamplingTechniques/oas.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/examples/ValidationData/Overall_GP_comparison.xls",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/docs/TimingMatrixOp/kriging_times_50to3000.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/docs/TimingMatrixOp/timing_poly2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/surfpack/docs/TimingMatrixOp/timing_poly2_0to5000_estimates.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/images/peaks-points-surface.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/surrogate-hierachy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1VariableTransformation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/iterator-heirachy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/function-class-members.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1AffineVariableTransformation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1Function.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1CppFunction.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/DAKOTA_Arrow.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1PolynomialChaosExpansion.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/dakota_model.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1Monomial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1PolynomialApproximation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1BoundedVariables.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1LinearSystemSolver.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1Function.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/bounded-vars-members.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/sparsesolverclass.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/classSurrogates_1_1Variables.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/surrogates/doc/design/dakota-surrogate-design.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/python_src/PyDakota/unit/data/pce_data.csv.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/python_src/PyDakota/unit/data/pce_coef.csv.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/python_src/PyDakota/unit/data/diabetes_target.csv.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/python_src/PyDakota/unit/data/pce_target.csv.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/python_src/PyDakota/unit/data/diabetes_data.csv.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/tutorials/DAKOTA_Arrow_Name_Tag_horiz-transparent.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/packages/pecos/python/tutorials/dakota-slide-image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/scripts/pyprepro/test_files/windows_unicode.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/scripts/pyprepro/test_files/windows_unicode2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/scripts/pyprepro/test_files/windows_ansi.txt",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/ObsErrorCovariance.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/pattern_search.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/direct1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/hdf5_layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/DAKOTA_Arrow_Name.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/DAKOTA_Arrow_Name_77x55.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/images/ga.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/SANDreport/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/SANDreport/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/algorithm2e.sty",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_PredT2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/compressed-sensing-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/basis-adaptation-algorithm-summary.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/isogrid_N2_q6.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_PredT10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_ExpUncorr.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/PivotCholSelectEqnAlgorithm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_GPt7.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rosen_restart_mle_map.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_PredT8.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_ExpAllData.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_PredT4.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/index-expansion.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rosen_00_pce_hessian.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_correctedlowmidhigh.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_TruthExpModel.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_GPt5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rotated_example.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rosen_pce_m11_50up_stdnormal_rejection.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/pce-tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_TruthExpModelGPlines.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rosen_restart_reject.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/unrotated_example.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/moddiscrep_TruthExp.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/rosen_00_prior.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-theory/images/tau_updates.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/ObsErrorCovariance.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sbo_3d_surface.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/textbook_history.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_nond_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/end_cap.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/branch_history.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/moat_mustar_sigma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/cdf_form.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_mogatest1_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/TensorQuad5_Gauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sobol_rational.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/SparseLevel4_LinGauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/short_col_cdf_ria.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sobol_g_function.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/mss_rel_eff_3lev_determ.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/belief_plaus.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_2d_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_mogatest3_pareto_set.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/CalibrateOne.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/textbook_contours.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dak_graphics_ps_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/log_ratio_cdf_pma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/inputfile_block_layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/textbook_opt_hist.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/multi_d_pstudy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/CalibratePerExperiment.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_pce_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_ea_final.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/comm_partitioning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/CalibratePerResponse.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/container_graphic_options.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/classDakota_1_1Model.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/short_col_cdf_pma.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/DAK5pt2_2D_shubert.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_sc_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dak_graphics_grad_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dak_graphics_vector.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/nonlin_paramest_hist.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/recursive_partitioning.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/log_ratio_cdf_ria.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/SparseLevel4_NonlinGauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sbo_df.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_vect_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sbo_mh.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_components.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/CalibrateBoth.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_3d_surf.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_flowchart.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_ea_init.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/cdf_tran_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_mogatest2_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_ps_opt_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sbouu.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/mss_rel_speedup_3lev_determ.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_2d_surf.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/nested_ouu.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/input_samples5.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_ps_opt_pts2.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/dakota_mogatest3_pareto_front.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/ex_in_hy_job_management.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/cantilever_beam.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/textbook_closeup.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/rosen_grad_opt_pts.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/horsetail.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/centered_pstudy.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/sobol_ishigami.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/lhs_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/input_samples10.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/InputBlocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/graphical_container_opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/container_graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/DAK5pt2_2D__herbie__smooth_herbie.png",
        "/tmp/vanessa/spack-stage/spack-stage-dakota-6.9-qdiiqhcl4elogbasv3ri67fqh3665zik/spack-src/docs/latex-user/images/cdf_orig_graphic.png"
    ],
    "total_files": 11237
}