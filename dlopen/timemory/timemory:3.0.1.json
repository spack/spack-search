{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/source/timemory/utility/signals.hpp": "// MIT License\n//\n// Copyright (c) 2020, The Regents of the University of California,\n// through Lawrence Berkeley National Laboratory (subject to receipt of any\n// required approvals from the U.S. Dept. of Energy).  All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n/** \\file timemory/utility/signals.hpp\n * \\headerfile utility/signals.hpp \"timemory/utility/signals.hpp\"\n * Handles signals emitted by application\n *\n */\n\n//======================================================================================//\n/// This global method should be used on LINUX or MacOSX platforms with gcc,\n/// clang, or intel compilers for activating signal detection and forcing\n/// exception being thrown that can be handled when detected.\n//======================================================================================//\n\n#pragma once\n\n#include \"timemory/backends/dmp.hpp\"\n#include \"timemory/backends/signals.hpp\"\n#include \"timemory/settings.hpp\"\n#include \"timemory/utility/macros.hpp\"\n#include \"timemory/utility/utility.hpp\"\n\n#include <cfenv>\n#include <csignal>\n\n#if defined(SIGNAL_AVAILABLE)\n#    include <dlfcn.h>\n#endif\n\n//======================================================================================//\n\nnamespace tim\n{\n// No    Name         Default Action       Description\n// 1     SIGHUP       terminate process    terminal line hangup\n// 2     SIGINT       terminate process    interrupt program\n// 3     SIGQUIT      create core image    quit program\n// 4     SIGILL       create core image    illegal instruction\n// 5     SIGTRAP      create core image    trace trap\n// 6     SIGABRT      create core image    abort program (formerly SIGIOT)\n// 7     SIGEMT       create core image    emulate instruction executed\n// 8     SIGFPE       create core image    floating-point exception\n// 9     SIGKILL      terminate process    kill program\n// 10    SIGBUS       create core image    bus error\n// 11    SIGSEGV      create core image    segmentation violation\n// 12    SIGSYS       create core image    non-existent system call invoked\n// 13    SIGPIPE      terminate process    write on a pipe with no reader\n// 14    SIGALRM      terminate process    real-time timer expired\n// 15    SIGTERM      terminate process    software termination signal\n// 16    SIGURG       discard signal       urgent condition present on socket\n// 18    SIGTSTP      stop process         stop signal generated from keyboard\n// 24    SIGXCPU      terminate process    cpu time limit exceeded (see\n// setrlimit(2)) 25    SIGXFSZ      terminate process    file size limit\n// exceeded (see setrlimit(2)) 26    SIGVTALRM    terminate process    virtual\n// time alarm (see setitimer(2)) 27    SIGPROF      terminate process profiling\n// timer alarm (see setitimer(2))\n\n//--------------------------------------------------------------------------------------//\n\nenum class sys_signal : int\n{\n    Hangup       = SIGHUP,   // 1\n    Interrupt    = SIGINT,   // 2\n    Quit         = SIGQUIT,  // 3\n    Illegal      = SIGILL,\n    Trap         = SIGTRAP,\n    Abort        = SIGABRT,\n    Emulate      = SIGEMT,\n    FPE          = SIGFPE,\n    Kill         = SIGKILL,\n    Bus          = SIGBUS,\n    SegFault     = SIGSEGV,\n    System       = SIGSYS,\n    Pipe         = SIGPIPE,\n    Alarm        = SIGALRM,\n    Terminate    = SIGTERM,\n    Urgent       = SIGURG,\n    Stop         = SIGTSTP,\n    CPUtime      = SIGXCPU,\n    FileSize     = SIGXFSZ,\n    VirtualAlarm = SIGVTALRM,\n    ProfileAlarm = SIGPROF,\n    User1        = SIGUSR1,\n    User2        = SIGUSR2\n};\n\n//--------------------------------------------------------------------------------------//\n\nclass signal_settings\n{\npublic:\n    using signal_set_t      = std::set<sys_signal>;\n    using signal_function_t = std::function<void(int)>;\n\npublic:\n    static bool        is_active();\n    static void        set_active(bool val);\n    static void        enable(const sys_signal&);\n    static void        disable(const sys_signal&);\n    static std::string str(const sys_signal&);\n    static std::string str();\n    static void        check_environment();\n    static void        set_exit_action(signal_function_t _f);\n    static void        exit_action(int errcode);\n\n    static const signal_set_t& enabled();\n    static const signal_set_t& disabled();\n    static const signal_set_t& get_enabled();\n    static const signal_set_t& get_disabled();\n    static const signal_set_t& get_default();\n\nprotected:\n    struct signals_data_t\n    {\n        signals_data_t();\n        bool              signals_active;\n        signal_set_t      signals_default;\n        signal_set_t      signals_enabled;\n        signal_set_t      signals_disabled;\n        signal_function_t signals_exit_func;\n    };\n\n    static signals_data_t& f_signals()\n    {\n        static signal_settings::signals_data_t instance;\n        return instance;\n    }\n};\n\n//--------------------------------------------------------------------------------------//\n\n// declarations\ninline bool enable_signal_detection(\n    signal_settings::signal_set_t = signal_settings::get_default());\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection();\n\n//--------------------------------------------------------------------------------------//\n\ninline void\nupdate_signal_detection(const signal_settings::signal_set_t& _signals)\n{\n    if(settings::allow_signal_handler())\n    {\n        disable_signal_detection();\n        enable_signal_detection(_signals);\n    }\n}\n\n//--------------------------------------------------------------------------------------//\n#if defined(SIGNAL_AVAILABLE)\nstatic void\ntermination_signal_message(int sig, siginfo_t* sinfo, std::ostream& message);\n#endif\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#if defined(SIGNAL_AVAILABLE)\n\ninline std::string\ntimemory_stack_demangle(const std::string& name)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    size_t found_end = name.find_first_of(\"+)\", 0, 2);\n    if(found_end == std::string::npos)\n    {\n        found_end = name.size();\n    }\n    size_t found_parenthesis = name.find_first_of(\"(\");\n    size_t start             = found_parenthesis + 1;\n    if(found_parenthesis == std::string::npos)\n        start = 0;\n\n    // PRINT_HERE(\"%s\", \"substr\");\n    std::string s = name.substr(start, found_end - start);\n\n    if(s.length() != 0)\n    {\n        int    status        = 0;\n        char*  output_buffer = nullptr;\n        size_t length        = s.length();\n        char*  d = abi::__cxa_demangle(s.c_str(), output_buffer, &length, &status);\n        if(status == 0 && d != nullptr)\n        {\n            s = d;\n            free(d);\n        }\n    }\n    // PRINT_HERE(\"%s\", \"special-case\");\n    // Special cases for \"main\" and \"start\" on Mac\n    if(s.length() == 0)\n    {\n        if(name == \"main\" || name == \"start\")\n        {\n            s = name;\n        }\n    }\n    // PRINT_HERE(\"%s\", \"returning\");\n    return s;\n}\n//--------------------------------------------------------------------------------------//\n\ninline void\ntimemory_stack_backtrace(std::ostream& os)\n{\n    using size_type = std::string::size_type;\n    // PRINT_HERE(\"%s\", \"\");\n\n    //   from http://linux.die.net/man/3/backtrace_symbols_fd\n#    define BSIZE 100\n    void* buffer[BSIZE];\n    for(size_type j = 0; j < BSIZE; ++j)\n        buffer[j] = nullptr;\n    size_type nptrs   = backtrace(buffer, BSIZE);\n    char**    strings = backtrace_symbols(buffer, nptrs);\n    if(strings == NULL)\n    {\n        perror(\"backtrace_symbols\");\n        return;\n    }\n\n    std::vector<std::vector<std::string>> dmang_buf;\n    std::vector<size_type>                dmang_len;\n\n    // lambda for demangling a string when delimiting\n    auto _transform = [](std::string s) {\n        int    status        = 0;\n        char*  output_buffer = nullptr;\n        size_t length        = s.length();\n        char*  d = abi::__cxa_demangle(s.c_str(), output_buffer, &length, &status);\n        if(status == 0 && d != nullptr)\n        {\n            s = d;\n            free(d);\n        }\n        return s;\n    };\n\n    dmang_buf.resize(nptrs, std::vector<std::string>(0, \"\"));\n\n    for(size_type j = 0; j < nptrs; ++j)\n    {\n        std::string _str = const_cast<const char*>(strings[j]);\n\n        auto _delim = tim::delimit(_str, \" ;\\t\\n\\r()[]\");\n\n        if(_delim.size() > 0)\n            _delim[0] = _transform(_delim[0]);\n\n        /*\n        if(_delim.size() > 1)\n        {\n            int _line = 0;\n            std::stringstream ss;\n            ss << std::hex << _delim[1];\n            ss >> _line;\n            _delim[1] = std::to_string(_line);\n        }\n\n        if(_delim.size() > 2)\n        {\n            std::string _file = \"\";\n            std::stringstream ss;\n            ss << std::hex << _delim[2];\n            ss >> _file;\n            _delim[2] = _file;\n        }\n        */\n\n        for(auto& itr : _delim)\n            itr = _transform(itr);\n\n        /*\n        std::vector<std::string> _dladdr;\n        for(const auto& itr : _delim)\n        {\n            auto idx = itr.find(\"(+\");\n            if(idx == std::string::npos)\n            {\n                _dladdr.push_back(itr);\n            }\n            else\n            {\n                auto edx = itr.find_last_of(')');\n                if(edx == std::string::npos)\n                {\n                    _dladdr.push_back(itr);\n                }\n                else\n                {\n                    auto _funcn = itr.substr(0, idx);\n                    auto _remain = itr.substr(idx+2, edx);\n                    while(_remain.find(')') != std::string::npos)\n                        _remain.erase(_remain.find(')'), 1);\n\n                    _dladdr.push_back(_funcn);\n                    _dladdr.push_back(_remain);\n\n                    // PRINT_HERE(\"%s\", \"dlopen\");\n                    auto _dlopen = dlopen(NULL, RTLD_NOW);\n                    if(_dlopen)\n                    {\n                        // PRINT_HERE(\"%s\", \"dlsym\");\n                        auto _dlsym = dlsym(_dlopen, _remain.c_str());\n                        // PRINT_HERE(\"%s\", \"dladdr\");\n                        Dl_info _info;\n                        auto _ret = dladdr(_dlsym, &_info);\n                        // PRINT_HERE(\"ret: %i\", (int) _ret);\n                        if(_ret != 0 && _info.dli_fname != NULL)\n                        {\n                            // PRINT_HERE(\"%s\", _info.dli_fname);\n                            _dladdr.push_back(std::string(_info.dli_fname));\n                        }\n                    }\n                }\n            }\n        }*/\n\n        // PRINT_HERE(\"iteration %i - accumulate\", (int) j);\n        dmang_len.resize(std::max(dmang_len.size(), _delim.size()), 0);\n\n        // accumulate the max lengths of the strings\n        for(size_type i = 0; i < _delim.size(); ++i)\n            dmang_len[i] = std::max(dmang_len[i], _delim[i].length());\n\n        // add\n        dmang_buf[j] = _delim;\n    }\n\n    // PRINT_HERE(\"%s\", \"\");\n    free(strings);\n\n    std::stringstream _oss;\n\n    _oss << std::endl << \"Call Stack:\" << std::endl;\n    int nwidth = std::max(2, static_cast<int32_t>(std::log10(nptrs)) + 1);\n    for(size_type j = 0; j < nptrs; ++j)\n    {\n        // print the back-trace numver\n        _oss << \"[\" << std::setw(nwidth) << nptrs - j - 1 << \"/\" << std::setw(nwidth)\n             << nptrs << \"] : \";\n\n        // loop over fields\n        for(size_type i = 0; i < dmang_len.size(); ++i)\n        {\n            std::stringstream _ss;\n            // if last param, don't set width\n            int mwidth = (i + 1 < dmang_len.size()) ? dmang_len.at(i) : 0;\n            _ss << std::setw(mwidth) << std::left\n                << ((i < dmang_buf.at(j).size()) ? dmang_buf.at(j).at(i)\n                                                 : std::string(\" \"));\n            _oss << _ss.str() << \"  \";\n            // std::cout << _ss.str() << \"  \";\n        }\n        _oss << std::endl;\n        // std::cout << std::endl;\n    }\n\n    _oss << std::flush;\n    os << _oss.str() << std::flush;\n    // c++filt can demangle:\n    // http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic void\ntimemory_termination_signal_handler(int sig, siginfo_t* sinfo, void* /* context */)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    tim::sys_signal _sig = (tim::sys_signal)(sig);\n\n    if(tim::signal_settings::get_enabled().find(_sig) ==\n       tim::signal_settings::get_enabled().end())\n    {\n        std::stringstream ss;\n        ss << \"signal \" << sig << \" not caught\";\n        throw std::runtime_error(ss.str());\n    }\n    {\n        std::stringstream message;\n        tim::termination_signal_message(sig, sinfo, message);\n        std::cerr << message.str() << std::flush;\n    }\n\n    tim::disable_signal_detection();\n\n    std::stringstream message;\n    message << \"\\n\\n\";\n\n#    if defined(PSIGINFO_AVAILABLE)\n    if(sinfo)\n    {\n        psiginfo(sinfo, message.str().c_str());\n    }\n    else\n    {\n        std::cerr << message.str() << std::endl;\n    }\n#    else\n    std::cerr << message.str() << std::endl;\n#    endif\n    // std::raise(sig);\n    exit(sig);\n}\n\n//======================================================================================//\n\nnamespace tim\n{\n//--------------------------------------------------------------------------------------//\n\nstatic struct sigaction&\ntim_signal_termaction()\n{\n    static struct sigaction timemory_sigaction_instance_new;\n    return timemory_sigaction_instance_new;\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic struct sigaction&\ntim_signal_oldaction()\n{\n    static struct sigaction timemory_sigaction_instance_old;\n    return timemory_sigaction_instance_old;\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic void\ntermination_signal_message(int sig, siginfo_t* sinfo, std::ostream& os)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    std::stringstream message;\n    sys_signal        _sig = (sys_signal)(sig);\n\n    message << \"\\n### ERROR ### \";\n    if(dmp::is_initialized())\n        message << \" [ rank : \" << dmp::rank() << \" ] \";\n    message << \"Error code : \" << sig;\n    if(sinfo)\n        message << \" @ \" << sinfo->si_addr;\n    message << \" : \" << signal_settings::str(_sig);\n\n    if(sig == SIGSEGV)\n    {\n        if(sinfo)\n        {\n            switch(sinfo->si_code)\n            {\n                case SEGV_MAPERR: message << \"Address not mapped to object.\"; break;\n                case SEGV_ACCERR:\n                    message << \"Invalid permissions for mapped object.\";\n                    break;\n                default:\n                    message << \"Unknown segmentation fault error: \" << sinfo->si_code\n                            << \".\";\n                    break;\n            }\n        }\n        else\n        {\n            message << \"Segmentation fault (unknown).\";\n        }\n    }\n    else if(sig == SIGFPE)\n    {\n        if(sinfo)\n        {\n            switch(sinfo->si_code)\n            {\n                case FE_DIVBYZERO: message << \"Floating point divide by zero.\"; break;\n                case FE_OVERFLOW: message << \"Floating point overflow.\"; break;\n                case FE_UNDERFLOW: message << \"Floating point underflow.\"; break;\n                case FE_INEXACT: message << \"Floating point inexact result.\"; break;\n                case FE_INVALID: message << \"Floating point invalid operation.\"; break;\n                default:\n                    message << \"Unknown floating point exception error: \"\n                            << sinfo->si_code << \".\";\n                    break;\n            }\n        }\n        else\n        {\n            message << \"Unknown error.\";\n        }\n    }\n\n    message << std::endl;\n    try\n    {\n        signal_settings::disable(_sig);\n        signal_settings::exit_action(sig);\n    } catch(std::exception& e)\n    {\n        std::cerr << \"signal_settings::exit_action(\" << sig << \") threw an exception\"\n                  << std::endl;\n        std::cerr << e.what() << std::endl;\n    }\n\n    timemory_stack_backtrace(message);\n    os << message.str() << std::flush;\n}\n\n//--------------------------------------------------------------------------------------//\n\ninline bool\nenable_signal_detection(signal_settings::signal_set_t operations)\n{\n    if(!settings::allow_signal_handler())\n    {\n        if(signal_settings::is_active())\n            disable_signal_detection();\n        return false;\n    }\n\n    // don't re-enable\n    if(signal_settings::is_active())\n        return false;\n\n    if(operations.empty())\n        operations = signal_settings::enabled();\n    else\n    {\n        for(auto& itr : signal_settings::get_enabled())\n            signal_settings::disable(itr);\n        signal_settings::check_environment();\n        for(auto& itr : operations)\n            signal_settings::enable(itr);\n    }\n\n    std::set<int> _signals;\n    for(auto itr = operations.cbegin(); itr != operations.cend(); ++itr)\n        _signals.insert(static_cast<int>(*itr));\n\n    sigfillset(&tim_signal_termaction().sa_mask);\n    for(auto& itr : _signals)\n        sigdelset(&tim_signal_termaction().sa_mask, itr);\n    tim_signal_termaction().sa_sigaction = timemory_termination_signal_handler;\n    tim_signal_termaction().sa_flags     = SA_SIGINFO;\n    for(auto& itr : _signals)\n    {\n        sigaction(itr, &tim_signal_termaction(), &tim_signal_oldaction());\n    }\n    signal_settings::set_active(true);\n\n    if(settings::verbose() > 0 || settings::debug())\n        std::cout << signal_settings::str() << std::endl;\n\n    return true;\n}\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection()\n{\n    // don't re-disable\n    if(!signal_settings::is_active())\n        return;\n\n    sigemptyset(&tim_signal_termaction().sa_mask);\n    tim_signal_termaction().sa_handler = SIG_DFL;\n\n    auto _disable = [](signal_settings::signal_set_t _set) {\n        for(auto itr = _set.cbegin(); itr != _set.cend(); ++itr)\n        {\n            int _itr = static_cast<int>(*itr);\n            sigaction(_itr, &tim_signal_termaction(), 0);\n        }\n    };\n\n    _disable(signal_settings::get_enabled());\n    _disable(signal_settings::get_disabled());\n\n    signal_settings::set_active(false);\n}\n\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#else /* Not a supported architecture */\n\n//======================================================================================//\n\nnamespace tim\n{\n//--------------------------------------------------------------------------------------//\n\ninline bool enable_signal_detection(signal_settings::signal_set_t) { return false; }\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection()\n{}\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ntimemory_stack_backtrace(std::ostream& os)\n{\n    os << \"timemory_stack_backtrace() not available.\" << std::endl;\n}\n\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#endif\n\n#include \"timemory/utility/bits/signals.hpp\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/src/hash.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"libc_wrappers.h\"\n#include \"hash.h\"\n\n#define EMPTY 0\n#define TOMBSTONE 1\n#define INUSE 2\n\nstruct hash_entry_t {\n   hash_key_t key;\n   hash_data_t data;\n   hash_hashvalue_t hash_value;\n   struct hash_entry_t *next;\n   struct hash_entry_t *prev;\n   uint32_t status;\n};\n\ntypedef struct hash_entry_t hash_entry_t;\n\nint create_hashtable(hash_table_t *table, size_t initial_size, hash_func_t hashfunc, \n                     hash_cmp_t keycmp)\n{\n   hash_entry_t *newtable;\n   int entries_per_page;\n\n   entries_per_page = gotcha_getpagesize() / sizeof(hash_entry_t);\n   if (initial_size % entries_per_page)\n      initial_size += entries_per_page - (initial_size % entries_per_page);\n\n   newtable = (hash_entry_t *) gotcha_malloc(initial_size * sizeof(hash_entry_t));\n   if (!newtable)\n      return -1;\n   gotcha_memset(newtable, 0, initial_size * sizeof(hash_entry_t));\n\n   table->table_size = initial_size;\n   table->entry_count = 0;\n   table->hashfunc = hashfunc;\n   table->keycmp = keycmp;\n   table->table = newtable;\n   table->head = NULL;\n   \n   return 0;\n}\n\nstatic hash_entry_t *insert(hash_table_t *table, hash_key_t key, hash_data_t data, hash_hashvalue_t value)\n{\n   unsigned long index = (unsigned long)value % table->table_size;\n   unsigned long startindex = index;\n\n   hash_entry_t *entry = NULL;\n   do {\n      entry = table->table + index;\n      if (entry->status == EMPTY || entry->status == TOMBSTONE) {\n         entry->key = key;\n         entry->data = data;\n         entry->hash_value = value;\n         entry->status = INUSE;\n         break;\n      }\n      index++;\n      if (index == table->table_size)\n         index = 0;\n   } while (index != startindex);\n\n   if (!entry)\n      return NULL;\n\n   entry->next = table->head;\n   entry->prev = NULL;\n   if (table->head)\n      table->head->prev = entry;\n   table->head = entry;\n   table->entry_count++;         \n\n   return entry;\n}\n\nint grow_hashtable(hash_table_t *table, size_t new_size)\n{\n   hash_table_t newtable;\n   hash_entry_t *result;\n   size_t i;\n\n   newtable.table_size = new_size;\n   newtable.entry_count = 0;\n   newtable.hashfunc = table->hashfunc;\n   newtable.keycmp = table->keycmp;\n   newtable.table = (hash_entry_t *) gotcha_malloc(new_size * sizeof(hash_entry_t));\n   newtable.head = NULL;\n   gotcha_memset(newtable.table, 0, new_size * sizeof(hash_entry_t));\n\n   for (i = 0; i < table->table_size; i++) {\n      if (table->table[i].status == EMPTY || table->table[i].status == TOMBSTONE)\n         continue;\n      result = insert(&newtable, table->table[i].key, table->table[i].data,\n                      table->table[i].hash_value);\n      if (!result) {\n         return -1;\n      }\n   }\n\n   destroy_hashtable(table);\n   *table = newtable;\n   return 0;\n}\n\nint destroy_hashtable(hash_table_t *table)\n{\n   gotcha_free(table->table);\n   table->table_size = 0;\n   table->entry_count = 0;\n   table->hashfunc = NULL;\n   table->keycmp = NULL;\n   table->table = NULL;\n   table->head = NULL;\n   return 0;\n}\n\nstatic int lookup(hash_table_t *table, hash_key_t key, hash_entry_t **entry)\n{\n   size_t index, startindex;\n   hash_hashvalue_t hashval;\n\n   hashval = table->hashfunc(key);\n   index = hashval % table->table_size;\n   startindex = index;\n   \n   for (;;) {\n      hash_entry_t *cur = table->table + index;\n      if ((cur->status == INUSE) && \n          (cur->hash_value == hashval) && \n          (table->keycmp(cur->key, key) == 0)) {\n         *entry = cur;\n         return 0;\n      }\n\n      if (cur->status == EMPTY)\n         return -1;\n      index++;\n      if (index == table->table_size)\n         index = 0;\n      if (index == startindex)\n         return -1;\n   }\n}\n\nint lookup_hashtable(hash_table_t *table, hash_key_t key, hash_data_t *data)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n   *data = entry->data;\n   return 0;\n}\n\nint addto_hashtable(hash_table_t *table, hash_key_t key, hash_data_t data)\n{\n   size_t newsize;\n   int result;\n   hash_hashvalue_t val;\n   hash_entry_t *entry;\n\n   newsize = table->table_size;\n   while (table->entry_count > newsize/2)\n      newsize *= 2;\n   if (newsize != table->table_size) {\n      result = grow_hashtable(table, newsize);\n      if (result == -1)\n         return -1;\n   }\n\n   val = table->hashfunc(key);\n   entry = insert(table, key, data, val);\n   if (!entry)\n      return -1;\n\n   return 0;\n}\n\nint removefrom_hashtable(hash_table_t *table, hash_key_t key)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n\n   entry->key = NULL;\n   entry->data = NULL;\n   entry->hash_value = 0;\n   entry->status = TOMBSTONE;\n   if (entry->next)\n      entry->next->prev = entry->prev;\n   if (entry->prev)\n      entry->prev->next = entry->next;\n   if (table->head == entry)\n      table->head = entry->next;\n   //Do not set entry->next to NULL, which would break the iterate & delete\n   //idiom used under dlopen_wrapper.\n   \n   table->entry_count--;\n   return 0;\n}\n\nint foreach_hash_entry(hash_table_t *table, void *opaque, int (*cb)(hash_key_t key, hash_data_t data, void *opaque))\n{\n   int result;\n   struct hash_entry_t *i;\n   for (i = table->head; i != NULL; i = i->next) {\n      result = cb(i->key, i->data, opaque);\n      if (result != 0)\n         return result;\n   }\n   return 0;\n}\n\nhash_hashvalue_t strhash(const char *str)\n{\n   unsigned long hash = 5381;\n   int c;\n\n   while ((c = *str++))\n      hash = hash * 33 + c;\n\n   return (hash_hashvalue_t) hash;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/src/gotcha.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"translations.h\"\n#include \"libc_wrappers.h\"\n#include \"gotcha/gotcha.h\"\n#include \"gotcha/gotcha_types.h\"\n#include \"gotcha_utils.h\"\n#include \"gotcha_auxv.h\"\n#include \"gotcha_dl.h\"\n#include \"elf_ops.h\"\n#include \"tool.h\"\n\nstatic void writeAddress(void* write, void* value){\n  *(void**)write = value;\n}\n\nstatic void** getBindingAddressPointer(struct gotcha_binding_t* in){\n  return (void**)in->function_handle;\n}\n\nstatic void setBindingAddressPointer(struct gotcha_binding_t* in, void* value){\n   void **target = getBindingAddressPointer(in);\n   debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n   writeAddress(target, value);\n}\n\nstatic void** getInternalBindingAddressPointer(struct internal_binding_t** in){\n  return (void**)&((*in)->wrappee_pointer);\n}\n\nstatic void setInternalBindingAddressPointer(void** in, void* value){\n  void** target = getInternalBindingAddressPointer((struct internal_binding_t**)in);\n  debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n  writeAddress(target, value);\n}\n\nint prepare_symbol(struct internal_binding_t *binding)\n{\n   int result;\n   struct link_map *lib;\n   struct gotcha_binding_t *user_binding = binding->user_binding;\n\n   debug_printf(2, \"Looking up exported symbols for %s\\n\", user_binding->name);\n   for (lib = _r_debug.r_map; lib != 0; lib = lib->l_next) {\n      struct library_t *int_library = get_library(lib);\n      if (!int_library) {\n         debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(lib));\n         int_library = add_library(lib);\n      }\n      \n      if (is_vdso(lib)) {\n         debug_printf(2, \"Skipping VDSO library at 0x%lx with name %s\\n\",\n                      lib->l_addr, LIB_NAME(lib));\n         continue;\n      }\n      debug_printf(2, \"Searching for exported symbols in %s\\n\", LIB_NAME(lib));\n      INIT_DYNAMIC(lib);\n\n      if (!gnu_hash && !elf_hash) {\n         debug_printf(3, \"Library %s does not export or import symbols\\n\", LIB_NAME(lib));\n         continue;\n      }\n      result = -1;\n      if (gnu_hash) {\n         debug_printf(3, \"Checking GNU hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_gnu_hash_symbol(user_binding->name, symtab, strtab,\n                                         (struct gnu_hash_header *) gnu_hash);\n      }\n      if (elf_hash && result == -1) {\n         debug_printf(3, \"Checking ELF hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_elf_hash_symbol(user_binding->name, symtab, strtab,\n                                         (ElfW(Word) *)elf_hash);\n      }\n      if (result == -1) {\n         debug_printf(3, \"%s not found in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n      if (! GOTCHA_CHECK_VISIBILITY(symtab[result])) {\n         debug_printf(3, \"Symbol %s found but not exported in %s\\n\", \n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n\n      debug_printf(2, \"Symbol %s found in %s at 0x%lx\\n\", \n                   user_binding->name, LIB_NAME(lib),\n                   symtab[result].st_value + lib->l_addr);\n      setInternalBindingAddressPointer(user_binding->function_handle,(void *)(symtab[result].st_value + lib->l_addr));\n      return 0;\n   }\n   debug_printf(1, \"Symbol %s was found in program\\n\", user_binding->name);\n   return -1;\n}\n\nstatic void insert_at_head(struct internal_binding_t *binding, struct internal_binding_t *head)\n{\n   binding->next_binding = head;\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, head->user_binding->wrapper_pointer);\n   removefrom_hashtable(&function_hash_table, (void*) binding->user_binding->name);\n   addto_hashtable(&function_hash_table, (void*)binding->user_binding->name, (void*)binding);\n}\n\nstatic void insert_after_pos(struct internal_binding_t *binding, struct internal_binding_t *pos)\n{\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, pos->wrappee_pointer);\n   setInternalBindingAddressPointer(pos->user_binding->function_handle, binding->user_binding->wrapper_pointer);\n   binding->next_binding = pos->next_binding;\n   pos->next_binding = binding;\n}\n\n#define RWO_NOCHANGE 0\n#define RWO_NEED_LOOKUP (1 << 0)\n#define RWO_NEED_BINDING (1 << 1)\nstatic int rewrite_wrapper_orders(struct internal_binding_t* binding)\n{\n  const char* name = binding->user_binding->name;\n  int insert_priority = get_priority(binding->associated_binding_table->tool);\n  \n  if(gotcha_strcmp(name,\"main\")==0){\n    if(!main_wrapped){\n      debug_printf(2, \"Wrapping main with Gotcha's internal wrappers\");\n      main_wrapped = 1;\n      gotcha_wrap(libc_main_wrappers,1,\"gotcha\");\n      gotcha_wrap(main_wrappers,1,\"gotcha\");\n    }\n  }\n\n  debug_printf(2, \"gotcha_rewrite_wrapper_orders for binding %s in tool %s of priority %d\\n\",\n               name, binding->associated_binding_table->tool->tool_name, insert_priority);\n\n  struct internal_binding_t* head;\n  int hash_result;\n  hash_result = lookup_hashtable(&function_hash_table, (void*)name, (void**)&head);\n  if(hash_result != 0) {\n    debug_printf(2, \"Adding new entry for %s to hash table\\n\", name);\n    addto_hashtable(&function_hash_table, (void *) name, (void *) binding);\n    return (RWO_NEED_LOOKUP | RWO_NEED_BINDING);\n  }\n\n  int head_priority = get_priority(head->associated_binding_table->tool);\n    if (head_priority < insert_priority) {\n     debug_printf(2, \"New binding priority %d is greater than head priority %d, adding to head\\n\",\n                   insert_priority, head_priority);\n     insert_at_head(binding, head);\n     return RWO_NEED_BINDING;\n  }\n\n  struct internal_binding_t* cur;\n  for (cur = head; cur->next_binding; cur = cur->next_binding) {\n     int next_priority = get_priority(cur->next_binding->associated_binding_table->tool);\n     debug_printf(3, \"Comparing binding for new insertion %d to binding for tool %s at %d\\n\",\n                   insert_priority, cur->next_binding->associated_binding_table->tool->tool_name,\n                   next_priority);\n     if (next_priority < insert_priority) {\n        break;\n     }\n     if (cur->user_binding->wrapper_pointer == binding->user_binding->wrapper_pointer) {\n        debug_printf(3, \"Tool is already inserted.  Skipping binding rewrite\\n\");\n        return RWO_NOCHANGE;\n     }\n  }\n  debug_printf(2, \"Inserting binding after tool %s\\n\", cur->associated_binding_table->tool->tool_name);\n  insert_after_pos(binding, cur);\n  return RWO_NOCHANGE;\n}\n\nstatic int update_lib_bindings(ElfW(Sym) * symbol KNOWN_UNUSED, char *name, ElfW(Addr) offset,\n                               struct link_map *lmap, hash_table_t *lookuptable)\n{\n  int result;\n  struct internal_binding_t *internal_binding;\n  void **got_address;\n\n  result = lookup_hashtable(lookuptable, name, (void **) &internal_binding);\n  if (result != 0)\n     return 0;\n  got_address = (void**) (lmap->l_addr + offset);\n  writeAddress(got_address, internal_binding->user_binding->wrapper_pointer);\n  debug_printf(3, \"Remapped call to %s at 0x%lx in %s to wrapper at 0x%p\\n\",\n             name, (lmap->l_addr + offset), LIB_NAME(lmap),\n             internal_binding->user_binding->wrapper_pointer);\n  return 0;\n}\n\n#ifndef MAX\n#define MAX(a,b) (a>b?a:b)\n#endif\n\nstatic int mark_got_writable(struct link_map *lib)\n{\n   static unsigned int page_size = 0;\n   INIT_DYNAMIC(lib);\n   if (!got)\n      return 0;\n\n   if (!page_size)\n      page_size = gotcha_getpagesize();\n\n   size_t protect_size = MAX(rel_size, page_size);\n   if(protect_size % page_size){\n      protect_size += page_size -  ((protect_size) %page_size);\n   }\n   ElfW(Addr) prot_address = BOUNDARY_BEFORE(got,(ElfW(Addr))page_size);\n   debug_printf(3, \"Setting library %s GOT table from %p to +%lu to writeable\\n\",\n                LIB_NAME(lib), (void *) prot_address, protect_size);\n   int res = gotcha_mprotect((void*)prot_address,protect_size,PROT_READ | PROT_WRITE | PROT_EXEC );\n   if(res == -1){ // mprotect returns -1 on an error\n      error_printf(\"GOTCHA attempted to mark the GOT table as writable and was unable to do so, \"\n                   \"calls to wrapped functions may likely fail.\\n\");\n   }\n\n   return 0;\n}\n\nstatic int update_library_got(struct link_map *map, hash_table_t *bindingtable)\n{\n   struct library_t *lib = get_library(map);\n   if (!lib) {\n      debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(map));\n      lib = add_library(map);\n   }\n\n   if (!libraryFilterFunc(map)) {\n      debug_printf(3, \"Skipping library %s due to libraryFilterFunc\\n\", LIB_NAME(map));\n      return 0;\n   }\n\n   if (lib->generation == current_generation) {\n      debug_printf(2, \"Library %s is already up-to-date.  Skipping GOT rewriting\\n\", LIB_NAME(map));\n      return 0;\n   }\n   \n   if (!(lib->flags & LIB_GOT_MARKED_WRITEABLE)) {\n      mark_got_writable(map);\n      lib->flags |= LIB_GOT_MARKED_WRITEABLE;\n   }\n\n   FOR_EACH_PLTREL(map, update_lib_bindings, map, bindingtable);\n\n   lib->generation = current_generation;\n   return 0;\n}\n\nvoid update_all_library_gots(hash_table_t *bindings)\n{\n   struct link_map *lib_iter;\n   debug_printf(2, \"Searching all callsites for %lu bindings\\n\", (unsigned long) bindings->entry_count);\n   for (lib_iter = _r_debug.r_map; lib_iter != 0; lib_iter = lib_iter->l_next) {\n      update_library_got(lib_iter, bindings);\n   }   \n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_wrap(struct gotcha_binding_t* user_bindings, int num_actions, const char* tool_name)\n{\n  int i, not_found = 0, new_bindings_count = 0;\n  tool_t *tool;\n  hash_table_t new_bindings;\n\n  gotcha_init();\n\n  debug_printf(1, \"User called gotcha_wrap for tool %s with %d bindings\\n\",\n               tool_name, num_actions);\n  if (debug_level >= 3) {\n    for (i = 0; i < num_actions; i++) {\n       debug_bare_printf(3, \"\\t%d: %s will map to %p\\n\", i, user_bindings[i].name,\n                         user_bindings[i].wrapper_pointer);\n    }\n  }\n  debug_printf(3, \"Initializing %d user binding entries to NULL\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n    setBindingAddressPointer(&user_bindings[i], NULL);\n  }\n\n  if (!tool_name)\n     tool_name = \"[UNSPECIFIED]\";\n  tool = get_tool(tool_name);\n  if (!tool)\n     tool = create_tool(tool_name);\n  if (!tool) {\n     error_printf(\"Failed to create tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  current_generation++;\n  debug_printf(2, \"Moved current_generation to %u in gotcha_wrap\\n\", current_generation);\n\n  debug_printf(2, \"Creating internal binding data structures and adding binding to tool\\n\");\n  binding_t *bindings = add_binding_to_tool(tool, user_bindings, num_actions);\n  if (!bindings) {\n     error_printf(\"Failed to create bindings for tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  debug_printf(2, \"Processing %d bindings\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n     struct internal_binding_t *binding = bindings->internal_bindings + i;\n\n     int result = rewrite_wrapper_orders(binding);\n     if (result & RWO_NEED_LOOKUP) {\n        debug_printf(2, \"Symbol %s needs lookup operation\\n\", binding->user_binding->name);\n        int presult = prepare_symbol(binding);\n        if (presult == -1) {\n           debug_printf(2, \"Stashing %s in notfound_binding table to re-lookup on dlopens\\n\",\n                        binding->user_binding->name);\n           addto_hashtable(&notfound_binding_table, (hash_key_t) binding->user_binding->name, (hash_data_t) binding);\n           not_found++;\n        }\n     }\n     if (result & RWO_NEED_BINDING) {\n        debug_printf(2, \"Symbol %s needs binding from application\\n\", binding->user_binding->name);\n        if (!new_bindings_count) {\n           create_hashtable(&new_bindings, num_actions*2, (hash_func_t) strhash, (hash_cmp_t) gotcha_strcmp);\n        }\n        addto_hashtable(&new_bindings, (void *) binding->user_binding->name, (void *) binding);\n        new_bindings_count++;\n     }\n  }\n  \n  if (new_bindings_count) {\n     update_all_library_gots(&new_bindings);\n     destroy_hashtable(&new_bindings);\n  }\n\n  if (not_found) {\n     debug_printf(1, \"Could not find bindings for %d / %d functions\\n\", not_found, num_actions);\n     return GOTCHA_FUNCTION_NOT_FOUND;\n  }\n  debug_printf(1, \"Gotcha wrap completed successfully\\n\");\n  return GOTCHA_SUCCESS;\n}\n\nstatic enum gotcha_error_t gotcha_configure_int(const char* tool_name, enum gotcha_config_key_t configuration_key , int value){\n  tool_t * tool = get_tool(tool_name);\n  if(tool==NULL){\n    tool = create_tool(tool_name);\n  }\n  if( configuration_key == GOTCHA_PRIORITY){\n    tool->config.priority = value;\n  }\n  else{\n    error_printf(\"Invalid property being configured on tool %s\\n\", tool_name);\n    return GOTCHA_INTERNAL;\n  }\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_set_priority(const char* tool_name, int value){\n  gotcha_init();\n  debug_printf(1, \"User called gotcha_set_priority(%s, %d)\\n\", tool_name, value);\n  enum gotcha_error_t error_on_set = gotcha_configure_int(tool_name, GOTCHA_PRIORITY, value);\n  if(error_on_set != GOTCHA_SUCCESS) {\n    return error_on_set;\n  }\n  tool_t* tool_to_place = get_tool(tool_name);\n  if(!tool_to_place){\n     tool_to_place = create_tool(tool_name);\n  }\n  remove_tool_from_list(tool_to_place);\n  reorder_tool(tool_to_place);\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_get_priority(const char* tool_name, int *priority){\n  gotcha_init();\n  return get_configuration_value(tool_name, GOTCHA_PRIORITY, priority);\n}\n\nGOTCHA_EXPORT void* gotcha_get_wrappee(gotcha_wrappee_handle_t handle){\n  return ((struct internal_binding_t*)handle)->wrappee_pointer;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/CMakeLists.txt": "\n# by checking here instead of parent CMakeLists.txt, this CMakeLists.txt will show up in IDEs\nif(NOT GOTCHA_ENABLE_TESTS)\n    return()\nendif()\n\ninclude(gotcha_testing)\nsetup_coverage_target()\n\nadd_subdirectory(rogot)\nadd_subdirectory(unit)\nadd_subdirectory(dlopen)\nadd_subdirectory(stack)\nadd_subdirectory(priority)\nadd_subdirectory(multi_agent_dlopen)\nadd_subdirectory(ppc_stress_multi_module)\nadd_subdirectory(wrap_main)\n\nif(CMAKE_VERSION VERSION_LESS 3.3)\n    set(_MSG \"\\n Current CMake version (== ${CMAKE_VERSION}) is quite old...\\n\")\n    set(_MSG \"${_MSG} Probability suggests that an outdated CMake would correlate to an outdated C++ compiler...\\n\")\n    set(_MSG \"${_MSG} Thus, it would be probable that the C++ compiler does not support C++11...\\n\")\n    set(_MSG \"${_MSG} Checking for C++11 in an compiler-agnostic manner requires CMake >= 3.3...\\n\")\n    set(_MSG \"${_MSG} Disabling testing C++ example as a result...\\n\")\n    message(AUTHOR_WARNING \"${_MSG}\")\n    return()\nendif()\n\n# enables if(... IN_LIST ...)\ncmake_policy(SET CMP0057 NEW)\n\ninclude(CheckLanguage)\n\ncheck_language(CXX)         # look for working C++ compiler\nif(CMAKE_CXX_COMPILER)      # if compiler found\n    enable_language(CXX)    # enable C++\n    # get the known features\n    get_property(CXX_KNOWN_FEATURES GLOBAL PROPERTY CMAKE_CXX_KNOWN_FEATURES)\n    # if C++11 is supported, add subdirectory\n    if(\"cxx_std_11\" IN_LIST CXX_KNOWN_FEATURES)\n        set(CMAKE_CXX_STANDARD 11)\n        set(CMAKE_CXX_EXTENSIONS ON)\n        set(CMAKE_CXX_STANDARD_REQUIRED ON)\n        add_subdirectory(hammer)\n    endif()\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/dlopen/test_dlopen.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"gotcha/gotcha.h\"\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n#ifndef LIB_NAME_RAW\n#define LIB_NAME_RAW libnum.so\n#endif\n\n#define LIB_NAME QUOTE(LIB_NAME_RAW)\nint correct_return_four()\n{\n   return 4;\n}\n\nint return_five() \n{\n   /* Intentional bug, gotcha will correct this to return 5*/\n   return 3;\n}\n\nint correct_return_five()\n{\n   return 5;\n}\n\n\nstatic gotcha_wrappee_handle_t buggy_return_four;\nstatic gotcha_wrappee_handle_t buggy_return_five;\nstruct gotcha_binding_t funcs[] = {\n   { \"return_four\", correct_return_four, &buggy_return_four },\n   { \"return_five\", correct_return_five, &buggy_return_five }\n};\n\nint main()\n{\n   void *libnum;\n   int (*retfour)(void);\n   int (*test_retfive)(void);\n   int had_error = 0;\n   int result;\n\n   result = gotcha_wrap(funcs, 2, \"dlopen_test\");\n   if(result != GOTCHA_FUNCTION_NOT_FOUND){\n     fprintf(stderr, \"GOTCHA should have failed to find a function, but found it\\n\");\n     return -1;\n   }\n\n   libnum = dlopen(LIB_NAME, RTLD_NOW);\n   if (!libnum) {\n      fprintf(stderr, \"ERROR: Test failed to dlopen libnum.so\\n\");\n      return -1;\n   }\n\n   /* Test 1: Check if a dlsym generated indirect call gets re-routed by gotcha */\n   retfour = (int (*)(void)) dlsym(libnum, \"return_four\");\n   if (retfour() != 4) {\n      fprintf(stderr, \"ERROR: dlsym returned original function, not wrapped\\n\");\n      had_error = -1;\n   }\n\n   /* Test 2: Does a call in a dlopen'd library get rerouted by gotcha */\n   test_retfive = (int (*)(void)) dlsym(libnum, \"test_return_five\");\n   if (test_retfive() != 5) {\n      fprintf(stderr, \"ERROR: call to return_five in libnum.so was not wrapped by correct_return_five\\n\");\n      had_error = -1;\n   }\n\n   return had_error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/dlopen/CMakeLists.txt": "add_library(num SHARED num.c)\nadd_executable(test_dlopen test_dlopen.c)\nset_target_properties(test_dlopen\n  PROPERTIES COMPILE_FLAGS \"-DLIB_NAME_RAW=\\\"\\\"${CMAKE_CURRENT_BINARY_DIR}/libnum.so\\\"\\\"\"\n  )\ntarget_link_libraries(test_dlopen gotcha dl)\ngotcha_add_test(dlopen_test test_dlopen)\nenvironment_add(dlopen_test TEST \"GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\nset_tests_properties(dlopen_test PROPERTIES\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n)\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/multi_agent_dlopen/dlsym.c": "/*\n *  dlsym.c  -->  libsym.so\n *\n *  Override dlsym() and replace with __libc_dlsym().\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MYNAME  \"libsym.so\"\n\ntypedef void * dlsym_fcn_t(void *, const char *);\ntypedef void * dlopen_mode_fcn_t(const char *, int);\n\ndlsym_fcn_t __libc_dlsym;\ndlopen_mode_fcn_t __libc_dlopen_mode;\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n    fprintf(stderr, \"%s:  enter dlsym:  sym = %s\\n\", MYNAME, symbol);\n\n    void * dl_handle = __libc_dlopen_mode(\"libdl.so\", RTLD_LAZY);\n\n    if (dl_handle == NULL) {\n\terr(1, \"__libc_dlopen_mode failed\");\n    }\n\n    dlsym_fcn_t * the_dlsym = __libc_dlsym(dl_handle, \"dlsym\");\n\n    if (the_dlsym == NULL) {\n\terr(1, \"__libc_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  mid   dlsym:  dlsym = %p\\n\", MYNAME, the_dlsym);\n\n#if 0\n    if (handle == RTLD_NEXT) { handle = RTLD_DEFAULT; }\n#endif\n\n    void *ans = the_dlsym(handle, symbol);\n\n    if (ans == NULL) {\n\terr(1, \"the_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  exit  dlsym:  ans = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/multi_agent_dlopen/monitor.c": "/*\n *  monitor.c  -->  libmon.so\n *\n *  Override dlopen() use dlsym(RTLD_NEXT).\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n#include <gotcha/gotcha.h>\n\n#define MYNAME  \"libmon.so\"\n\ntypedef void *dlopen_fcn_t(const char *, int);\n\ngotcha_wrappee_handle_t reel_dlopen_handle;\n\nvoid *\nwrap_dlopen(const char *file, int flag)\n{\n    typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n    fprintf(stderr, \"ENTER WRAP: %p\\n\", reel_dlopen);\n    fprintf(stderr, \"%s:  enter dlopen:  file = %s\\n\", MYNAME, file);\n\n    void *ans = reel_dlopen ? (reel_dlopen)(file, flag) : NULL;\n    if(!ans){\n      fprintf(stderr, \"Real dlopen not found\\n\");\n    }\n    fprintf(stderr, \"%s:  exit  dlopen:  handle = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\nvoid* opaque;\nstruct gotcha_binding_t binds[] = {\n  { \"dlopen\", wrap_dlopen, &reel_dlopen_handle}\n};\nvoid fix_things(){\n  reel_dlopen_handle = NULL;\n  gotcha_wrap(binds, 1, \"silly\");\n  typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n  fprintf(stderr, \"IMMEDIATE WRITE: %p\\n\", reel_dlopen);\n}\n__attribute__((constructor)) void startup_fix_things(){\n  fix_things(); \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/multi_agent_dlopen/main.c": "/*\n *  Try dlopen(libm.so, ...) and call sin().\n */\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <math.h>\n#include <stdio.h>\n\n#define MYNAME  \"main\"\n\ntypedef double sin_fcn_t(double);\n\nint\nmain(int argc, char **argv)\n{\n    sin_fcn_t *sin_fcn = NULL;\n    double val = 4.0;\n    double ans = 0.0;\n\n    fprintf(stderr, \"%s:  val = %.6f\\n\", MYNAME, val);\n\n    void *handle = dlopen(\"libm.so\", RTLD_NOW);\n    if (handle == NULL) {\n\terr(1, \"dlopen failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    sin_fcn = dlsym(handle, \"sin\");\n    if (sin_fcn == NULL) {\n\terr(1, \"dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    ans = (*sin_fcn)(val);\n\n    fprintf(stderr, \"%s:  ans = %.6f\\n\", MYNAME, ans);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/gotcha/test/multi_agent_dlopen/CMakeLists.txt": "set(CMAKE_C_FLAGS \"-g -O -fPIC\")\nadd_library(multi_agent_sym SHARED dlsym.c)\nadd_library(multi_agent_mon SHARED monitor.c)\nadd_executable(multi_agent_main main.c)\ntarget_link_libraries(multi_agent_main dl)\ntarget_link_libraries(multi_agent_mon dl gotcha)\ngotcha_add_test(multi_agent_dlopen multi_agent_main)\nenvironment_add(multi_agent_dlopen TEST \"LD_PRELOAD=${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_sym.so:${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_mon.so GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/google-test/googletest/cmake/libgtest.la.in": "# libgtest.la - a libtool library file\n# Generated by libtool (GNU libtool) 2.4.6\n\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Names of this library.\nlibrary_names='libgtest.so'\n\n# Is this an already installed library?\ninstalled=yes\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=no\n\n# Files to dlopen/dlpreopen\ndlopen=''\ndlpreopen=''\n\n# Directory that this library needs to be installed in:\nlibdir='@CMAKE_INSTALL_FULL_LIBDIR@'\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/pybind11/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 3\n\n/// On MSVC, debug and release builds are not ABI-compatible!\n#if defined(_MSC_VER) && defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n/// Let's assume that different compilers are ABI-incompatible.\n#if defined(_MSC_VER)\n#   define PYBIND11_COMPILER_TYPE \"_msvc\"\n#elif defined(__INTEL_COMPILER)\n#   define PYBIND11_COMPILER_TYPE \"_icc\"\n#elif defined(__clang__)\n#   define PYBIND11_COMPILER_TYPE \"_clang\"\n#elif defined(__PGI)\n#   define PYBIND11_COMPILER_TYPE \"_pgi\"\n#elif defined(__MINGW32__)\n#   define PYBIND11_COMPILER_TYPE \"_mingw\"\n#elif defined(__CYGWIN__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc_cygwin\"\n#elif defined(__GNUC__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc\"\n#else\n#   define PYBIND11_COMPILER_TYPE \"_unknown\"\n#endif\n\n#if defined(_LIBCPP_VERSION)\n#  define PYBIND11_STDLIB \"_libcpp\"\n#elif defined(__GLIBCXX__) || defined(__GLIBCPP__)\n#  define PYBIND11_STDLIB \"_libstdcpp\"\n#else\n#  define PYBIND11_STDLIB \"\"\n#endif\n\n/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.\n#if defined(__GXX_ABI_VERSION)\n#  define PYBIND11_BUILD_ABI \"_cxxabi\" PYBIND11_TOSTRING(__GXX_ABI_VERSION)\n#else\n#  define PYBIND11_BUILD_ABI \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\ninline void translate_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)           { e.restore();                                    return;\n    } catch (const builtin_exception &e)     { e.set_error();                                  return;\n    } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n    } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n    } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n    } catch (...) {\n        PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n        return;\n    }\n}\n\n#if !defined(__GLIBCXX__)\ninline void translate_local_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)       { e.restore();   return;\n    } catch (const builtin_exception &e) { e.set_error(); return;\n    }\n}\n#endif\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    // Ensure that the GIL is held since we will need to make Python calls.\n    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.\n    struct gil_scoped_acquire_local {\n        gil_scoped_acquire_local() : state (PyGILState_Ensure()) {}\n        ~gil_scoped_acquire_local() { PyGILState_Release(state); }\n        const PyGILState_STATE state;\n    } gil;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(&translate_exception);\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/pybind11/docs/faq.rst": "Frequently asked questions\n##########################\n\n\"ImportError: dynamic module does not define init function\"\n===========================================================\n\n1. Make sure that the name specified in PYBIND11_MODULE is identical to the\nfilename of the extension library (without prefixes such as .so)\n\n2. If the above did not fix the issue, you are likely using an incompatible\nversion of Python (for instance, the extension library was compiled against\nPython 2, while the interpreter is running on top of some version of Python\n3, or vice versa).\n\n\"Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``\"\n========================================================================\n\nSee the first answer.\n\n\"SystemError: dynamic module not initialized properly\"\n======================================================\n\nSee the first answer.\n\nThe Python interpreter immediately crashes when importing my module\n===================================================================\n\nSee the first answer.\n\nCMake doesn't detect the right Python version\n=============================================\n\nThe CMake-based build system will try to automatically detect the installed\nversion of Python and link against that. When this fails, or when there are\nmultiple versions of Python and it finds the wrong one, delete\n``CMakeCache.txt`` and then invoke CMake as follows:\n\n.. code-block:: bash\n\n    cmake -DPYTHON_EXECUTABLE:FILEPATH=<path-to-python-executable> .\n\n.. _faq_reference_arguments:\n\nLimitations involving reference arguments\n=========================================\n\nIn C++, it's fairly common to pass arguments using mutable references or\nmutable pointers, which allows both read and write access to the value\nsupplied by the caller. This is sometimes done for efficiency reasons, or to\nrealize functions that have multiple return values. Here are two very basic\nexamples:\n\n.. code-block:: cpp\n\n    void increment(int &i) { i++; }\n    void increment_ptr(int *i) { (*i)++; }\n\nIn Python, all arguments are passed by reference, so there is no general\nissue in binding such code from Python.\n\nHowever, certain basic Python types (like ``str``, ``int``, ``bool``,\n``float``, etc.) are **immutable**. This means that the following attempt\nto port the function to Python doesn't have the same effect on the value\nprovided by the caller -- in fact, it does nothing at all.\n\n.. code-block:: python\n\n    def increment(i):\n        i += 1 # nope..\n\npybind11 is also affected by such language-level conventions, which means that\nbinding ``increment`` or ``increment_ptr`` will also create Python functions\nthat don't modify their arguments.\n\nAlthough inconvenient, one workaround is to encapsulate the immutable types in\na custom type that does allow modifications.\n\nAn other alternative involves binding a small wrapper lambda function that\nreturns a tuple with all output arguments (see the remainder of the\ndocumentation for examples on binding lambda functions). An example:\n\n.. code-block:: cpp\n\n    int foo(int &i) { i++; return 123; }\n\nand the binding code\n\n.. code-block:: cpp\n\n   m.def(\"foo\", [](int i) { int rv = foo(i); return std::make_tuple(rv, i); });\n\n\nHow can I reduce the build time?\n================================\n\nIt's good practice to split binding code over multiple files, as in the\nfollowing example:\n\n:file:`example.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex1(py::module &);\n    void init_ex2(py::module &);\n    /* ... */\n\n    PYBIND11_MODULE(example, m) {\n        init_ex1(m);\n        init_ex2(m);\n        /* ... */\n    }\n\n:file:`ex1.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex1(py::module &m) {\n        m.def(\"add\", [](int a, int b) { return a + b; });\n    }\n\n:file:`ex2.cpp`:\n\n.. code-block:: cpp\n\n    void init_ex2(py::module &m) {\n        m.def(\"sub\", [](int a, int b) { return a - b; });\n    }\n\n:command:`python`:\n\n.. code-block:: pycon\n\n    >>> import example\n    >>> example.add(1, 2)\n    3\n    >>> example.sub(1, 1)\n    0\n\nAs shown above, the various ``init_ex`` functions should be contained in\nseparate files that can be compiled independently from one another, and then\nlinked together into the same final shared object.  Following this approach\nwill:\n\n1. reduce memory requirements per compilation unit.\n\n2. enable parallel builds (if desired).\n\n3. allow for faster incremental builds. For instance, when a single class\n   definition is changed, only a subset of the binding code will generally need\n   to be recompiled.\n\n\"recursive template instantiation exceeded maximum depth of 256\"\n================================================================\n\nIf you receive an error about excessive recursive template evaluation, try\nspecifying a larger value, e.g. ``-ftemplate-depth=1024`` on GCC/Clang. The\nculprit is generally the generation of function signatures at compile time\nusing C++14 template metaprogramming.\n\n.. _`faq:hidden_visibility`:\n\n\"\u2018SomeClass\u2019 declared with greater visibility than the type of its field \u2018SomeClass::member\u2019 [-Wattributes]\"\n============================================================================================================\n\nThis error typically indicates that you are compiling without the required\n``-fvisibility`` flag.  pybind11 code internally forces hidden visibility on\nall internal code, but if non-hidden (and thus *exported*) code attempts to\ninclude a pybind type (for example, ``py::object`` or ``py::list``) you can run\ninto this warning.\n\nTo avoid it, make sure you are specifying ``-fvisibility=hidden`` when\ncompiling pybind code.\n\nAs to why ``-fvisibility=hidden`` is necessary, because pybind modules could\nhave been compiled under different versions of pybind itself, it is also\nimportant that the symbols defined in one module do not clash with the\npotentially-incompatible symbols defined in another.  While Python extension\nmodules are usually loaded with localized symbols (under POSIX systems\ntypically using ``dlopen`` with the ``RTLD_LOCAL`` flag), this Python default\ncan be changed, but even if it isn't it is not always enough to guarantee\ncomplete independence of the symbols involved when not using\n``-fvisibility=hidden``.\n\nAdditionally, ``-fvisiblity=hidden`` can deliver considerably binary size\nsavings.  (See the following section for more details).\n\n\n.. _`faq:symhidden`:\n\nHow can I create smaller binaries?\n==================================\n\nTo do its job, pybind11 extensively relies on a programming technique known as\n*template metaprogramming*, which is a way of performing computation at compile\ntime using type information. Template metaprogamming usually instantiates code\ninvolving significant numbers of deeply nested types that are either completely\nremoved or reduced to just a few instructions during the compiler's optimization\nphase. However, due to the nested nature of these types, the resulting symbol\nnames in the compiled extension library can be extremely long. For instance,\nthe included test suite contains the following symbol:\n\n.. only:: html\n\n    .. code-block:: none\n\n        _\u200b_\u200bZ\u200bN\u200b8\u200bp\u200by\u200bb\u200bi\u200bn\u200bd\u200b1\u200b1\u200b1\u200b2\u200bc\u200bp\u200bp\u200b_\u200bf\u200bu\u200bn\u200bc\u200bt\u200bi\u200bo\u200bn\u200bC\u200b1\u200bI\u200bv\u200b8\u200bE\u200bx\u200ba\u200bm\u200bp\u200bl\u200be\u200b2\u200bJ\u200bR\u200bN\u200bS\u200bt\u200b3\u200b_\u200b_\u200b1\u200b6\u200bv\u200be\u200bc\u200bt\u200bo\u200br\u200bI\u200bN\u200bS\u200b3\u200b_\u200b1\u200b2\u200bb\u200ba\u200bs\u200bi\u200bc\u200b_\u200bs\u200bt\u200br\u200bi\u200bn\u200bg\u200bI\u200bw\u200bN\u200bS\u200b3\u200b_\u200b1\u200b1\u200bc\u200bh\u200ba\u200br\u200b_\u200bt\u200br\u200ba\u200bi\u200bt\u200bs\u200bI\u200bw\u200bE\u200bE\u200bN\u200bS\u200b3\u200b_\u200b9\u200ba\u200bl\u200bl\u200bo\u200bc\u200ba\u200bt\u200bo\u200br\u200bI\u200bw\u200bE\u200bE\u200bE\u200bE\u200bN\u200bS\u200b8\u200b_\u200bI\u200bS\u200bA\u200b_\u200bE\u200bE\u200bE\u200bE\u200bE\u200bJ\u200bN\u200bS\u200b_\u200b4\u200bn\u200ba\u200bm\u200be\u200bE\u200bN\u200bS\u200b_\u200b7\u200bs\u200bi\u200bb\u200bl\u200bi\u200bn\u200bg\u200bE\u200bN\u200bS\u200b_\u200b9\u200bi\u200bs\u200b_\u200bm\u200be\u200bt\u200bh\u200bo\u200bd\u200bE\u200bA\u200b2\u200b8\u200b_\u200bc\u200bE\u200bE\u200bE\u200bM\u200bT\u200b0\u200b_\u200bF\u200bT\u200b_\u200bD\u200bp\u200bT\u200b1\u200b_\u200bE\u200bD\u200bp\u200bR\u200bK\u200bT\u200b2\u200b_\n\n.. only:: not html\n\n    .. code-block:: cpp\n\n        __ZN8pybind1112cpp_functionC1Iv8Example2JRNSt3__16vectorINS3_12basic_stringIwNS3_11char_traitsIwEENS3_9allocatorIwEEEENS8_ISA_EEEEEJNS_4nameENS_7siblingENS_9is_methodEA28_cEEEMT0_FT_DpT1_EDpRKT2_\n\nwhich is the mangled form of the following function type:\n\n.. code-block:: cpp\n\n    pybind11::cpp_function::cpp_function<void, Example2, std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&, pybind11::name, pybind11::sibling, pybind11::is_method, char [28]>(void (Example2::*)(std::__1::vector<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >, std::__1::allocator<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> > > >&), pybind11::name const&, pybind11::sibling const&, pybind11::is_method const&, char const (&) [28])\n\nThe memory needed to store just the mangled name of this function (196 bytes)\nis larger than the actual piece of code (111 bytes) it represents! On the other\nhand, it's silly to even give this function a name -- after all, it's just a\ntiny cog in a bigger piece of machinery that is not exposed to the outside\nworld. So we'll generally only want to export symbols for those functions which\nare actually called from the outside.\n\nThis can be achieved by specifying the parameter ``-fvisibility=hidden`` to GCC\nand Clang, which sets the default symbol visibility to *hidden*, which has a\ntremendous impact on the final binary size of the resulting extension library.\n(On Visual Studio, symbols are already hidden by default, so nothing needs to\nbe done there.)\n\nIn addition to decreasing binary size, ``-fvisibility=hidden`` also avoids\npotential serious issues when loading multiple modules and is required for\nproper pybind operation.  See the previous FAQ entry for more details.\n\nWorking with ancient Visual Studio 2008 builds on Windows\n=========================================================\n\nThe official Windows distributions of Python are compiled using truly\nancient versions of Visual Studio that lack good C++11 support. Some users\nimplicitly assume that it would be impossible to load a plugin built with\nVisual Studio 2015 into a Python distribution that was compiled using Visual\nStudio 2008. However, no such issue exists: it's perfectly legitimate to\ninterface DLLs that are built with different compilers and/or C libraries.\nCommon gotchas to watch out for involve not ``free()``-ing memory region\nthat that were ``malloc()``-ed in another shared library, using data\nstructures with incompatible ABIs, and so on. pybind11 is very careful not\nto make these types of mistakes.\n\nInconsistent detection of Python version in CMake and pybind11\n==============================================================\n\nThe functions ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` provided by CMake\nfor Python version detection are not used by pybind11 due to unreliability and limitations that make\nthem unsuitable for pybind11's needs. Instead pybind provides its own, more reliable Python detection\nCMake code. Conflicts can arise, however, when using pybind11 in a project that *also* uses the CMake\nPython detection in a system with several Python versions installed.\n\nThis difference may cause inconsistencies and errors if *both* mechanisms are used in the same project. Consider the following\nCmake code executed in a system with Python 2.7 and 3.x installed:\n\n.. code-block:: cmake\n\n    find_package(PythonInterp)\n    find_package(PythonLibs)\n    find_package(pybind11)\n\nIt will detect Python 2.7 and pybind11 will pick it as well.\n\nIn contrast this code:\n\n.. code-block:: cmake\n\n    find_package(pybind11)\n    find_package(PythonInterp)\n    find_package(PythonLibs)\n\nwill detect Python 3.x for pybind11 and may crash on ``find_package(PythonLibs)`` afterwards.\n\nIt is advised to avoid using ``find_package(PythonInterp)`` and ``find_package(PythonLibs)`` from CMake and rely\non pybind11 in detecting Python version. If this is not possible CMake machinery should be called *before* including pybind11.\n\nHow to cite this project?\n=========================\n\nWe suggest the following BibTeX template to cite pybind11 in scientific\ndiscourse:\n\n.. code-block:: bash\n\n    @misc{pybind11,\n       author = {Wenzel Jakob and Jason Rhinelander and Dean Moldovan},\n       year = {2017},\n       note = {https://github.com/pybind/pybind11},\n       title = {pybind11 -- Seamless operability between C++11 and Python}\n    }\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/ext/gotcha/src/hash.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"libc_wrappers.h\"\n#include \"hash.h\"\n\n#define EMPTY 0\n#define TOMBSTONE 1\n#define INUSE 2\n\nstruct hash_entry_t {\n   hash_key_t key;\n   hash_data_t data;\n   hash_hashvalue_t hash_value;\n   struct hash_entry_t *next;\n   struct hash_entry_t *prev;\n   uint32_t status;\n};\n\ntypedef struct hash_entry_t hash_entry_t;\n\nint create_hashtable(hash_table_t *table, size_t initial_size, hash_func_t hashfunc, \n                     hash_cmp_t keycmp)\n{\n   hash_entry_t *newtable;\n   int entries_per_page;\n\n   entries_per_page = gotcha_getpagesize() / sizeof(hash_entry_t);\n   if (initial_size % entries_per_page)\n      initial_size += entries_per_page - (initial_size % entries_per_page);\n\n   newtable = (hash_entry_t *) gotcha_malloc(initial_size * sizeof(hash_entry_t));\n   if (!newtable)\n      return -1;\n   gotcha_memset(newtable, 0, initial_size * sizeof(hash_entry_t));\n\n   table->table_size = initial_size;\n   table->entry_count = 0;\n   table->hashfunc = hashfunc;\n   table->keycmp = keycmp;\n   table->table = newtable;\n   table->head = NULL;\n   \n   return 0;\n}\n\nstatic hash_entry_t *insert(hash_table_t *table, hash_key_t key, hash_data_t data, hash_hashvalue_t value)\n{\n   unsigned long index = (unsigned long)value % table->table_size;\n   unsigned long startindex = index;\n\n   hash_entry_t *entry = NULL;\n   do {\n      entry = table->table + index;\n      if (entry->status == EMPTY || entry->status == TOMBSTONE) {\n         entry->key = key;\n         entry->data = data;\n         entry->hash_value = value;\n         entry->status = INUSE;\n         break;\n      }\n      index++;\n      if (index == table->table_size)\n         index = 0;\n   } while (index != startindex);\n\n   if (!entry)\n      return NULL;\n\n   entry->next = table->head;\n   entry->prev = NULL;\n   if (table->head)\n      table->head->prev = entry;\n   table->head = entry;\n   table->entry_count++;         \n\n   return entry;\n}\n\nint grow_hashtable(hash_table_t *table, size_t new_size)\n{\n   hash_table_t newtable;\n   hash_entry_t *result;\n   size_t i;\n\n   newtable.table_size = new_size;\n   newtable.entry_count = 0;\n   newtable.hashfunc = table->hashfunc;\n   newtable.keycmp = table->keycmp;\n   newtable.table = (hash_entry_t *) gotcha_malloc(new_size * sizeof(hash_entry_t));\n   newtable.head = NULL;\n   gotcha_memset(newtable.table, 0, new_size * sizeof(hash_entry_t));\n\n   for (i = 0; i < table->table_size; i++) {\n      if (table->table[i].status == EMPTY || table->table[i].status == TOMBSTONE)\n         continue;\n      result = insert(&newtable, table->table[i].key, table->table[i].data,\n                      table->table[i].hash_value);\n      if (!result) {\n         return -1;\n      }\n   }\n\n   destroy_hashtable(table);\n   *table = newtable;\n   return 0;\n}\n\nint destroy_hashtable(hash_table_t *table)\n{\n   gotcha_free(table->table);\n   table->table_size = 0;\n   table->entry_count = 0;\n   table->hashfunc = NULL;\n   table->keycmp = NULL;\n   table->table = NULL;\n   table->head = NULL;\n   return 0;\n}\n\nstatic int lookup(hash_table_t *table, hash_key_t key, hash_entry_t **entry)\n{\n   size_t index, startindex;\n   hash_hashvalue_t hashval;\n\n   hashval = table->hashfunc(key);\n   index = hashval % table->table_size;\n   startindex = index;\n   \n   for (;;) {\n      hash_entry_t *cur = table->table + index;\n      if ((cur->status == INUSE) && \n          (cur->hash_value == hashval) && \n          (table->keycmp(cur->key, key) == 0)) {\n         *entry = cur;\n         return 0;\n      }\n\n      if (cur->status == EMPTY)\n         return -1;\n      index++;\n      if (index == table->table_size)\n         index = 0;\n      if (index == startindex)\n         return -1;\n   }\n}\n\nint lookup_hashtable(hash_table_t *table, hash_key_t key, hash_data_t *data)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n   *data = entry->data;\n   return 0;\n}\n\nint addto_hashtable(hash_table_t *table, hash_key_t key, hash_data_t data)\n{\n   size_t newsize;\n   int result;\n   hash_hashvalue_t val;\n   hash_entry_t *entry;\n\n   newsize = table->table_size;\n   while (table->entry_count > newsize/2)\n      newsize *= 2;\n   if (newsize != table->table_size) {\n      result = grow_hashtable(table, newsize);\n      if (result == -1)\n         return -1;\n   }\n\n   val = table->hashfunc(key);\n   entry = insert(table, key, data, val);\n   if (!entry)\n      return -1;\n\n   return 0;\n}\n\nint removefrom_hashtable(hash_table_t *table, hash_key_t key)\n{\n   hash_entry_t *entry;\n   int result;\n\n   result = lookup(table, key, &entry);\n   if (result == -1)\n      return -1;\n\n   entry->key = NULL;\n   entry->data = NULL;\n   entry->hash_value = 0;\n   entry->status = TOMBSTONE;\n   if (entry->next)\n      entry->next->prev = entry->prev;\n   if (entry->prev)\n      entry->prev->next = entry->next;\n   if (table->head == entry)\n      table->head = entry->next;\n   //Do not set entry->next to NULL, which would break the iterate & delete\n   //idiom used under dlopen_wrapper.\n   \n   table->entry_count--;\n   return 0;\n}\n\nint foreach_hash_entry(hash_table_t *table, void *opaque, int (*cb)(hash_key_t key, hash_data_t data, void *opaque))\n{\n   int result;\n   struct hash_entry_t *i;\n   for (i = table->head; i != NULL; i = i->next) {\n      result = cb(i->key, i->data, opaque);\n      if (result != 0)\n         return result;\n   }\n   return 0;\n}\n\nhash_hashvalue_t strhash(const char *str)\n{\n   unsigned long hash = 5381;\n   int c;\n\n   while ((c = *str++))\n      hash = hash * 33 + c;\n\n   return (hash_hashvalue_t) hash;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/ext/gotcha/src/gotcha.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"translations.h\"\n#include \"libc_wrappers.h\"\n#include \"gotcha/gotcha.h\"\n#include \"gotcha/gotcha_types.h\"\n#include \"gotcha_utils.h\"\n#include \"gotcha_auxv.h\"\n#include \"gotcha_dl.h\"\n#include \"elf_ops.h\"\n#include \"tool.h\"\n\nstatic void writeAddress(void* write, void* value){\n  *(void**)write = value;\n}\n\nstatic void** getBindingAddressPointer(struct gotcha_binding_t* in){\n  return (void**)in->function_handle;\n}\n\nstatic void setBindingAddressPointer(struct gotcha_binding_t* in, void* value){\n   void **target = getBindingAddressPointer(in);\n   debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n   writeAddress(target, value);\n}\n\nstatic void** getInternalBindingAddressPointer(struct internal_binding_t** in){\n  return (void**)&((*in)->wrappee_pointer);\n}\n\nstatic void setInternalBindingAddressPointer(void** in, void* value){\n  void** target = getInternalBindingAddressPointer((struct internal_binding_t**)in);\n  debug_printf(3, \"Updating binding address pointer at %p to %p\\n\", target, value);\n  writeAddress(target, value);\n}\n\nint prepare_symbol(struct internal_binding_t *binding)\n{\n   int result;\n   struct link_map *lib;\n   struct gotcha_binding_t *user_binding = binding->user_binding;\n\n   debug_printf(2, \"Looking up exported symbols for %s\\n\", user_binding->name);\n   for (lib = _r_debug.r_map; lib != 0; lib = lib->l_next) {\n      struct library_t *int_library = get_library(lib);\n      if (!int_library) {\n         debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(lib));\n         int_library = add_library(lib);\n      }\n      \n      if (is_vdso(lib)) {\n         debug_printf(2, \"Skipping VDSO library at 0x%lx with name %s\\n\",\n                      lib->l_addr, LIB_NAME(lib));\n         continue;\n      }\n      debug_printf(2, \"Searching for exported symbols in %s\\n\", LIB_NAME(lib));\n      INIT_DYNAMIC(lib);\n\n      if (!gnu_hash && !elf_hash) {\n         debug_printf(3, \"Library %s does not export or import symbols\\n\", LIB_NAME(lib));\n         continue;\n      }\n      result = -1;\n      if (gnu_hash) {\n         debug_printf(3, \"Checking GNU hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_gnu_hash_symbol(user_binding->name, symtab, strtab,\n                                         (struct gnu_hash_header *) gnu_hash);\n      }\n      if (elf_hash && result == -1) {\n         debug_printf(3, \"Checking ELF hash for %s in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         result = lookup_elf_hash_symbol(user_binding->name, symtab, strtab,\n                                         (ElfW(Word) *)elf_hash);\n      }\n      if (result == -1) {\n         debug_printf(3, \"%s not found in %s\\n\",\n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n      if (! GOTCHA_CHECK_VISIBILITY(symtab[result])) {\n         debug_printf(3, \"Symbol %s found but not exported in %s\\n\", \n                      user_binding->name, LIB_NAME(lib));\n         continue;\n      }\n\n      debug_printf(2, \"Symbol %s found in %s at 0x%lx\\n\", \n                   user_binding->name, LIB_NAME(lib),\n                   symtab[result].st_value + lib->l_addr);\n      setInternalBindingAddressPointer(user_binding->function_handle,(void *)(symtab[result].st_value + lib->l_addr));\n      return 0;\n   }\n   debug_printf(1, \"Symbol %s was found in program\\n\", user_binding->name);\n   return -1;\n}\n\nstatic void insert_at_head(struct internal_binding_t *binding, struct internal_binding_t *head)\n{\n   binding->next_binding = head;\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, head->user_binding->wrapper_pointer);\n   removefrom_hashtable(&function_hash_table, (void*) binding->user_binding->name);\n   addto_hashtable(&function_hash_table, (void*)binding->user_binding->name, (void*)binding);\n}\n\nstatic void insert_after_pos(struct internal_binding_t *binding, struct internal_binding_t *pos)\n{\n   setInternalBindingAddressPointer(binding->user_binding->function_handle, pos->wrappee_pointer);\n   setInternalBindingAddressPointer(pos->user_binding->function_handle, binding->user_binding->wrapper_pointer);\n   binding->next_binding = pos->next_binding;\n   pos->next_binding = binding;\n}\n\n#define RWO_NOCHANGE 0\n#define RWO_NEED_LOOKUP (1 << 0)\n#define RWO_NEED_BINDING (1 << 1)\nstatic int rewrite_wrapper_orders(struct internal_binding_t* binding)\n{\n  const char* name = binding->user_binding->name;\n  int insert_priority = get_priority(binding->associated_binding_table->tool);\n  \n  if(gotcha_strcmp(name,\"main\")==0){\n    if(!main_wrapped){\n      debug_printf(2, \"Wrapping main with Gotcha's internal wrappers\");\n      main_wrapped = 1;\n      gotcha_wrap(libc_main_wrappers,1,\"gotcha\");\n      gotcha_wrap(main_wrappers,1,\"gotcha\");\n    }\n  }\n\n  debug_printf(2, \"gotcha_rewrite_wrapper_orders for binding %s in tool %s of priority %d\\n\",\n               name, binding->associated_binding_table->tool->tool_name, insert_priority);\n\n  struct internal_binding_t* head;\n  int hash_result;\n  hash_result = lookup_hashtable(&function_hash_table, (void*)name, (void**)&head);\n  if(hash_result != 0) {\n    debug_printf(2, \"Adding new entry for %s to hash table\\n\", name);\n    addto_hashtable(&function_hash_table, (void *) name, (void *) binding);\n    return (RWO_NEED_LOOKUP | RWO_NEED_BINDING);\n  }\n\n  int head_priority = get_priority(head->associated_binding_table->tool);\n    if (head_priority < insert_priority) {\n     debug_printf(2, \"New binding priority %d is greater than head priority %d, adding to head\\n\",\n                   insert_priority, head_priority);\n     insert_at_head(binding, head);\n     return RWO_NEED_BINDING;\n  }\n\n  struct internal_binding_t* cur;\n  for (cur = head; cur->next_binding; cur = cur->next_binding) {\n     int next_priority = get_priority(cur->next_binding->associated_binding_table->tool);\n     debug_printf(3, \"Comparing binding for new insertion %d to binding for tool %s at %d\\n\",\n                   insert_priority, cur->next_binding->associated_binding_table->tool->tool_name,\n                   next_priority);\n     if (next_priority < insert_priority) {\n        break;\n     }\n     if (cur->user_binding->wrapper_pointer == binding->user_binding->wrapper_pointer) {\n        debug_printf(3, \"Tool is already inserted.  Skipping binding rewrite\\n\");\n        return RWO_NOCHANGE;\n     }\n  }\n  debug_printf(2, \"Inserting binding after tool %s\\n\", cur->associated_binding_table->tool->tool_name);\n  insert_after_pos(binding, cur);\n  return RWO_NOCHANGE;\n}\n\nstatic int update_lib_bindings(ElfW(Sym) * symbol KNOWN_UNUSED, char *name, ElfW(Addr) offset,\n                               struct link_map *lmap, hash_table_t *lookuptable)\n{\n  int result;\n  struct internal_binding_t *internal_binding;\n  void **got_address;\n\n  result = lookup_hashtable(lookuptable, name, (void **) &internal_binding);\n  if (result != 0)\n     return 0;\n  got_address = (void**) (lmap->l_addr + offset);\n  writeAddress(got_address, internal_binding->user_binding->wrapper_pointer);\n  debug_printf(3, \"Remapped call to %s at 0x%lx in %s to wrapper at 0x%p\\n\",\n             name, (lmap->l_addr + offset), LIB_NAME(lmap),\n             internal_binding->user_binding->wrapper_pointer);\n  return 0;\n}\n\n#ifndef MAX\n#define MAX(a,b) (a>b?a:b)\n#endif\n\nstatic int mark_got_writable(struct link_map *lib)\n{\n   static unsigned int page_size = 0;\n   INIT_DYNAMIC(lib);\n   if (!got)\n      return 0;\n\n   if (!page_size)\n      page_size = gotcha_getpagesize();\n\n   size_t protect_size = MAX(rel_size, page_size);\n   if(protect_size % page_size){\n      protect_size += page_size -  ((protect_size) %page_size);\n   }\n   ElfW(Addr) prot_address = BOUNDARY_BEFORE(got,(ElfW(Addr))page_size);\n   debug_printf(3, \"Setting library %s GOT table from %p to +%lu to writeable\\n\",\n                LIB_NAME(lib), (void *) prot_address, protect_size);\n   int res = gotcha_mprotect((void*)prot_address,protect_size,PROT_READ | PROT_WRITE | PROT_EXEC );\n   if(res == -1){ // mprotect returns -1 on an error\n      error_printf(\"GOTCHA attempted to mark the GOT table as writable and was unable to do so, \"\n                   \"calls to wrapped functions may likely fail.\\n\");\n   }\n\n   return 0;\n}\n\nstatic int update_library_got(struct link_map *map, hash_table_t *bindingtable)\n{\n   struct library_t *lib = get_library(map);\n   if (!lib) {\n      debug_printf(3, \"Creating new library object for %s\\n\", LIB_NAME(map));\n      lib = add_library(map);\n   }\n\n   if (!libraryFilterFunc(map)) {\n      debug_printf(3, \"Skipping library %s due to libraryFilterFunc\\n\", LIB_NAME(map));\n      return 0;\n   }\n\n   if (lib->generation == current_generation) {\n      debug_printf(2, \"Library %s is already up-to-date.  Skipping GOT rewriting\\n\", LIB_NAME(map));\n      return 0;\n   }\n   \n   if (!(lib->flags & LIB_GOT_MARKED_WRITEABLE)) {\n      mark_got_writable(map);\n      lib->flags |= LIB_GOT_MARKED_WRITEABLE;\n   }\n\n   FOR_EACH_PLTREL(map, update_lib_bindings, map, bindingtable);\n\n   lib->generation = current_generation;\n   return 0;\n}\n\nvoid update_all_library_gots(hash_table_t *bindings)\n{\n   struct link_map *lib_iter;\n   debug_printf(2, \"Searching all callsites for %lu bindings\\n\", (unsigned long) bindings->entry_count);\n   for (lib_iter = _r_debug.r_map; lib_iter != 0; lib_iter = lib_iter->l_next) {\n      update_library_got(lib_iter, bindings);\n   }   \n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_wrap(struct gotcha_binding_t* user_bindings, int num_actions, const char* tool_name)\n{\n  int i, not_found = 0, new_bindings_count = 0;\n  tool_t *tool;\n  hash_table_t new_bindings;\n\n  gotcha_init();\n\n  debug_printf(1, \"User called gotcha_wrap for tool %s with %d bindings\\n\",\n               tool_name, num_actions);\n  if (debug_level >= 3) {\n    for (i = 0; i < num_actions; i++) {\n       debug_bare_printf(3, \"\\t%d: %s will map to %p\\n\", i, user_bindings[i].name,\n                         user_bindings[i].wrapper_pointer);\n    }\n  }\n  debug_printf(3, \"Initializing %d user binding entries to NULL\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n    setBindingAddressPointer(&user_bindings[i], NULL);\n  }\n\n  if (!tool_name)\n     tool_name = \"[UNSPECIFIED]\";\n  tool = get_tool(tool_name);\n  if (!tool)\n     tool = create_tool(tool_name);\n  if (!tool) {\n     error_printf(\"Failed to create tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  current_generation++;\n  debug_printf(2, \"Moved current_generation to %u in gotcha_wrap\\n\", current_generation);\n\n  debug_printf(2, \"Creating internal binding data structures and adding binding to tool\\n\");\n  binding_t *bindings = add_binding_to_tool(tool, user_bindings, num_actions);\n  if (!bindings) {\n     error_printf(\"Failed to create bindings for tool %s\\n\", tool_name);\n     return GOTCHA_INTERNAL;\n  }\n\n  debug_printf(2, \"Processing %d bindings\\n\", num_actions);\n  for (i = 0; i < num_actions; i++) {\n     struct internal_binding_t *binding = bindings->internal_bindings + i;\n\n     int result = rewrite_wrapper_orders(binding);\n     if (result & RWO_NEED_LOOKUP) {\n        debug_printf(2, \"Symbol %s needs lookup operation\\n\", binding->user_binding->name);\n        int presult = prepare_symbol(binding);\n        if (presult == -1) {\n           debug_printf(2, \"Stashing %s in notfound_binding table to re-lookup on dlopens\\n\",\n                        binding->user_binding->name);\n           addto_hashtable(&notfound_binding_table, (hash_key_t) binding->user_binding->name, (hash_data_t) binding);\n           not_found++;\n        }\n     }\n     if (result & RWO_NEED_BINDING) {\n        debug_printf(2, \"Symbol %s needs binding from application\\n\", binding->user_binding->name);\n        if (!new_bindings_count) {\n           create_hashtable(&new_bindings, num_actions*2, (hash_func_t) strhash, (hash_cmp_t) gotcha_strcmp);\n        }\n        addto_hashtable(&new_bindings, (void *) binding->user_binding->name, (void *) binding);\n        new_bindings_count++;\n     }\n  }\n  \n  if (new_bindings_count) {\n     update_all_library_gots(&new_bindings);\n     destroy_hashtable(&new_bindings);\n  }\n\n  if (not_found) {\n     debug_printf(1, \"Could not find bindings for %d / %d functions\\n\", not_found, num_actions);\n     return GOTCHA_FUNCTION_NOT_FOUND;\n  }\n  debug_printf(1, \"Gotcha wrap completed successfully\\n\");\n  return GOTCHA_SUCCESS;\n}\n\nstatic enum gotcha_error_t gotcha_configure_int(const char* tool_name, enum gotcha_config_key_t configuration_key , int value){\n  tool_t * tool = get_tool(tool_name);\n  if(tool==NULL){\n    tool = create_tool(tool_name);\n  }\n  if( configuration_key == GOTCHA_PRIORITY){\n    tool->config.priority = value;\n  }\n  else{\n    error_printf(\"Invalid property being configured on tool %s\\n\", tool_name);\n    return GOTCHA_INTERNAL;\n  }\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_set_priority(const char* tool_name, int value){\n  gotcha_init();\n  debug_printf(1, \"User called gotcha_set_priority(%s, %d)\\n\", tool_name, value);\n  enum gotcha_error_t error_on_set = gotcha_configure_int(tool_name, GOTCHA_PRIORITY, value);\n  if(error_on_set != GOTCHA_SUCCESS) {\n    return error_on_set;\n  }\n  tool_t* tool_to_place = get_tool(tool_name);\n  if(!tool_to_place){\n     tool_to_place = create_tool(tool_name);\n  }\n  remove_tool_from_list(tool_to_place);\n  reorder_tool(tool_to_place);\n  return GOTCHA_SUCCESS;\n}\n\nGOTCHA_EXPORT enum gotcha_error_t gotcha_get_priority(const char* tool_name, int *priority){\n  gotcha_init();\n  return get_configuration_value(tool_name, GOTCHA_PRIORITY, priority);\n}\n\nGOTCHA_EXPORT void* gotcha_get_wrappee(gotcha_wrappee_handle_t handle){\n  return ((struct internal_binding_t*)handle)->wrappee_pointer;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/cmake/Modules/BuildSettings.cmake": "# include guard\ninclude_guard(DIRECTORY)\n\n##########################################################################################\n#\n#        Handles the build settings\n#\n##########################################################################################\n\n\ninclude(GNUInstallDirs)\ninclude(Compilers)\n\n\nfind_library(dl_LIBRARY NAMES dl)\nif(dl_LIBRARY)\n    target_link_libraries(timemory-compile-options INTERFACE ${dl_LIBRARY})\nendif()\n\nif(WIN32)\n    set(OS_FLAG \"/bigobj\")\nelse()\n    set(OS_FLAG \"-Wall\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# set the compiler flags\nadd_flag_if_avail(\n    \"-W\" \"${OS_FLAG}\" \"-Wno-unknown-pragmas\" \"-Wno-ignored-attributes\"\n    \"-Wno-attributes\" \"-Wno-cast-function-type\"\n    \"-Wno-unused-command-line-argument\")\n\nadd_cxx_flag_if_avail(\"-Wno-class-memaccess\")\n\nif(TIMEMORY_BUILD_QUIET)\n    add_flag_if_avail(\"-Wno-unused-value\" \"-Wno-unused-function\"\n        \"-Wno-unknown-pragmas\" \"-Wno-reserved-id-macro\" \"-Wno-deprecated-declarations\"\n        \"-Wno-implicit-fallthrough\" \"-Wno-deprecated-declarations\")\nendif()\n\nif(NOT CMAKE_CXX_COMPILER_IS_GNU)\n    # these flags succeed with GNU compiler but are unknown (clang flags)\n    # add_cxx_flag_if_avail(\"-Wno-exceptions\")\n    # add_cxx_flag_if_avail(\"-Wno-reserved-id-macro\")\n    # add_cxx_flag_if_avail(\"-Wno-unused-private-field\")\nelse()\n    # add_cxx_flag_if_avail(\"-Wno-class-memaccess\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# non-debug optimizations\n#\nif(NOT \"${CMAKE_BUILD_TYPE}\" STREQUAL \"Debug\" AND TIMEMORY_BUILD_EXTRA_OPTIMIZATIONS)\n    add_flag_if_avail(\"-finline-functions\" \"-funroll-loops\"\n        \"-ftree-vectorize\" \"-ftree-loop-optimize\" \"-ftree-loop-vectorize\")\n    # add_flag_if_avail(\"-freciprocal-math\" \"-fno-signed-zeros\" \"-mfast-fp\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# debug-safe optimizations\n#\nadd_cxx_flag_if_avail(\"-faligned-new\")\nif(NOT TIMEMORY_USE_SANITIZER)\n    add_cxx_flag_if_avail(\"-ftls-model=${TIMEMORY_TLS_MODEL}\")\nendif()\n\nif(TIMEMORY_BUILD_LTO)\n    add_flag_if_avail(\"-flto\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# print compilation timing reports (Clang compiler)\n#\nadd_interface_library(timemory-compile-timing)\nadd_target_flag_if_avail(timemory-compile-timing \"-ftime-report\")\nif(TIMEMORY_USE_COMPILE_TIMING)\n    target_link_libraries(timemory-compile-options INTERFACE timemory-compile-timing)\nendif()\n\n#----------------------------------------------------------------------------------------#\n# developer build flags\n#\nadd_interface_library(timemory-develop-options)\nif(TIMEMORY_BUILD_DEVELOPER)\n    add_target_flag_if_avail(timemory-develop-options \"-Wshadow\" \"-Wextra\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# developer build flags\n#\nif(dl_LIBRARY)\n    # This instructs the linker to add all symbols, not only used ones, to the dynamic\n    # symbol table. This option is needed for some uses of dlopen or to allow obtaining\n    # backtraces from within a program.\n    add_flag_if_avail(\"-rdynamic\")\nendif()\n\n#----------------------------------------------------------------------------------------#\n# architecture optimizations\n#\nadd_interface_library(timemory-vector)\nadd_interface_library(timemory-arch)\ntarget_link_libraries(timemory-compile-options INTERFACE timemory-vector)\n\nset(VECTOR_DEFINITION               TIMEMORY_VEC)\nset(VECTOR_INTERFACE_TARGET         timemory-vector)\nset(ARCH_INTERFACE_TARGET           timemory-arch)\n\ninclude(ArchConfig)\n\n#----------------------------------------------------------------------------------------#\n# sanitizer\n#\nif(TIMEMORY_USE_SANITIZER)\n    set(SANITIZER_TYPES address memory thread leak)\n\n    set(asan_key \"address\")\n    set(msan_key \"memory\")\n    set(tsan_key \"thread\")\n    set(lsan_key \"leak\")\n\n    set(address_lib asan)\n    set(memory_lib msan)\n    set(thread_lib tsan)\n    set(leak_lib lsan)\n\n    find_library(SANITIZER_asan_LIBRARY NAMES asan)\n    find_library(SANITIZER_msan_LIBRARY NAMES msan)\n    find_library(SANITIZER_tsan_LIBRARY NAMES tsan)\n    find_library(SANITIZER_lsan_LIBRARY NAMES lsan)\n\n    string(TOLOWER \"${SANITIZER_TYPE}\" SANITIZER_TYPE)\n    list(REMOVE_ITEM SANITIZER_TYPES ${SANITIZER_TYPE})\n    set(SANITIZER_TYPES ${SANITIZER_TYPE} ${SANITIZER_TYPES})\n\n    foreach(_TYPE ${SANITIZER_TYPES})\n        set(_LIB ${${_TYPE}_lib})\n        add_interface_library(timemory-${_TYPE}-sanitizer)\n        add_target_flag_if_avail(timemory-${_TYPE}-sanitizer \"-fsanitize=${SANITIZER_TYPE}\")\n        target_link_libraries(timemory-${_TYPE}-sanitizer INTERFACE ${SANITIZER_${_LIB}_LIBRARY})\n    endforeach()\n\n    foreach(_TYPE ${SANITIZER_TYPE} ${SANITIZER_TYPES})\n        set(_LIB ${${_TYPE}_lib})\n        if((c_timemory_${_TYPE}_sanitizer_fsanitize_${SANITIZER_TYPE} OR\n                cxx_timemory_${_TYPE}_sanitizer_fsanitize_${SANITIZER_TYPE}) AND\n                SANITIZER_${_LIB}_LIBRARY)\n            add_interface_library(timemory-sanitizer)\n            add_target_flag_if_avail(timemory-sanitizer \"-fno-omit-frame-pointer\")\n            target_compile_definitions(timemory-sanitizer INTERFACE TIMEMORY_USE_SANITIZER)\n            target_link_libraries(timemory-sanitizer INTERFACE timemory-${_TYPE}-sanitizer)\n            break()\n        else()\n            message(STATUS \"${_TYPE} sanitizer not found. library: ${SANITIZER_${_LIB}_LIBRARY}...\")\n        endif()\n    endforeach()\n\n    if(NOT TARGET timemory-sanitizer)\n        message(WARNING \"TIMEMORY_USE_SANITIZER not found. Tried: ${SANITIZER_TYPES}\")\n        unset(SANITIZER_TYPE CACHE)\n        set(TIMEMORY_USE_SANITIZER OFF)\n    endif()\n\nendif()\n\n\n#----------------------------------------------------------------------------------------#\n# user customization\n#\nadd_user_flags(timemory-compile-options \"C\")\nadd_user_flags(timemory-compile-options \"CXX\")\nadd_user_flags(timemory-compile-options \"CUDA\")\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/objects/pack/pack-5a05a0780ec0222a0c8c94de9448023f2506072d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/objects/pack/pack-5a05a0780ec0222a0c8c94de9448023f2506072d.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/google-test/objects/pack/pack-3454c027b2259102d773c5396a18d51457b1c2d7.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/google-test/objects/pack/pack-3454c027b2259102d773c5396a18d51457b1c2d7.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/python/pybind11/objects/pack/pack-f6106ed7755d1d4d6d5a8b8460a29186942bd4ce.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/python/pybind11/objects/pack/pack-f6106ed7755d1d4d6d5a8b8460a29186942bd4ce.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/cereal/objects/pack/pack-c9b82d8ec64b3ecaa05a1a2a6df1301f03ec6511.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/source/cereal/objects/pack/pack-c9b82d8ec64b3ecaa05a1a2a6df1301f03ec6511.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/pybind11/docs/pybind11_vs_boost_python1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/pybind11/docs/pybind11-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/pybind11/docs/pybind11_vs_boost_python2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/src/mpi-rt/services/mpit/mpitdesign/design.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/src/mpi-rt/services/mpit/mpitdesign/caliper.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/doc/sphinx/caliper-services-workflow.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/external/caliper/doc/sphinx/caliper-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/docs/components/mpi_macro_dp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/docs/components/work_macro_sp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.1-j4ucwugmqb6ihr7mib7qjxmmspm2bcj3/spack-src/docs/getting_started/roofline.jpg"
    ],
    "total_files": 1743
}