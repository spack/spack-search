{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/chainerx_cc/chainerx/context.cc": "#include \"chainerx/context.h\"\n\n#include <algorithm>\n#include <atomic>\n#include <mutex>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include <absl/types/optional.h>\n#include <gsl/gsl>\n\n#ifdef CHAINERX_ENABLE_CUDA\n#include \"chainerx/cuda/cuda_backend.h\"\n#endif  // CHAINERX_ENABLE_CUDA\n#include \"chainerx/dynamic_lib.h\"\n#include \"chainerx/error.h\"\n#include \"chainerx/macro.h\"\n#include \"chainerx/native/native_backend.h\"\n#include \"chainerx/thread_local_state.h\"\n#include \"chainerx/util.h\"\n\nnamespace chainerx {\nnamespace {\n\nstd::atomic<Context*> g_global_default_context{nullptr};\n\nstd::string GetChainerxPath() {\n    if (absl::optional<std::string> chainerx_path = GetEnv(\"CHAINERX_PATH\")) {\n        return *chainerx_path;\n    }\n    if (absl::optional<std::string> home_path = GetEnv(\"HOME\")) {\n        return *home_path + \"/.chainerx\";\n    }\n    throw ChainerxError{\"ChainerX path is not defined. Set either CHAINERX_PATH or HOME.\"};\n}\n\n}  // namespace\n\nContext::Context() {\n    // Register the default backprop ID\n    static constexpr const char* kDefaultBackpropName = \"<default>\";\n    MakeBackpropId(kDefaultBackpropName);\n}\n\nContext::~Context() {\n    // Need to call dtor of all backends before closing shared objects\n    backends_.clear();\n    for (void* handle : dlopen_handles_) {\n        try {\n            DlClose(handle);\n        } catch (...) {\n            // dtor should not throw any exception.\n        }\n    }\n}\n\nnative::NativeBackend& Context::GetNativeBackend() {\n    Backend& backend = GetBackend(native::NativeBackend::kDefaultName);\n    return static_cast<native::NativeBackend&>(backend);  // NOLINT\n}\n\nBackend& Context::GetBackend(const std::string& backend_name) {\n    {\n        std::lock_guard<std::mutex> lock{mutex_};\n        auto it = backends_.find(backend_name);\n        if (it != backends_.end()) {\n            return *it->second;\n        }\n    }\n\n    // Ctor of each backend may call member functions of Context.\n    // Lock is released here to avoid any deadlocks.\n    std::unique_ptr<Backend, context_detail::BackendDeleter> backend;\n    if (backend_name == native::NativeBackend::kDefaultName) {\n        backend = std::unique_ptr<Backend, context_detail::BackendDeleter>{\n                new native::NativeBackend{*this}, context_detail::BackendDeleter{[](gsl::owner<Backend*> ptr) { delete ptr; }}};\n#ifdef CHAINERX_ENABLE_CUDA\n    } else if (backend_name == cuda::CudaBackend::kDefaultName) {\n        backend = std::unique_ptr<Backend, context_detail::BackendDeleter>{\n                new cuda::CudaBackend{*this}, context_detail::BackendDeleter{[](gsl::owner<Backend*> ptr) { delete ptr; }}};\n#endif  // CHAINERX_ENABLE_CUDA\n    } else {\n        // Load .so file\n        std::string so_file_path = GetChainerxPath() + \"/backends/\" + backend_name + \".so\";\n        void* handle{nullptr};\n        try {\n            handle = DlOpen(so_file_path);\n        } catch (const ChainerxError&) {\n            throw BackendError{\"Backend not found: '\", backend_name, \"'\"};\n        }\n        {\n            std::lock_guard<std::mutex> lock{mutex_};\n            dlopen_handles_.push_back(handle);\n        }\n\n        // Create backend\n        void* ptr_create_backend = DlSym(handle, \"CreateBackend\");\n        void* ptr_destroy_backend = DlSym(handle, \"DestroyBackend\");\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n        auto create_backend = reinterpret_cast<Backend* (*)(Context&)>(ptr_create_backend);\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n        auto destroy_backend = reinterpret_cast<void (*)(Backend*)>(ptr_destroy_backend);\n        if (create_backend == nullptr) {\n            throw BackendError{\"Invalid backend plugin: CreateBackend is not found in '\", so_file_path, \"'.\"};\n        }\n        if (destroy_backend == nullptr) {\n            throw BackendError{\"Invalid backend plugin: DestroyBackend is not found in '\", so_file_path, \"'.\"};\n        }\n        backend = std::unique_ptr<Backend, context_detail::BackendDeleter>{create_backend(*this),\n                                                                           context_detail::BackendDeleter{destroy_backend}};\n    }\n\n    return RegisterBackend(backend_name, std::move(backend)).first;\n}\n\nDevice& Context::GetDevice(const DeviceId& device_id) {\n    Backend& backend = GetBackend(device_id.backend_name());\n    return backend.GetDevice(device_id.index());\n}\n\nBackpropId Context::MakeBackpropId(std::string backprop_name) {\n    // Create new backprop ID\n    std::lock_guard<std::mutex> lock{mutex_};\n    backprop_set_.emplace_back(next_backprop_ordinal_, std::move(backprop_name));\n    return BackpropId{*this, next_backprop_ordinal_++};\n}\n\nvoid Context::ReleaseBackpropId(const BackpropId& backprop_id) {\n    CheckValidBackpropId(backprop_id);\n\n    if (backprop_id.ordinal() == 0) {\n        throw ChainerxError{\"The default backprop ID cannot be released.\"};\n    }\n\n    ReleaseBackpropIdNoExcept(backprop_id);\n}\n\nvoid Context::ReleaseBackpropIdNoExcept(const BackpropId& backprop_id) noexcept {\n    std::lock_guard<std::mutex> lock{mutex_};\n    BackpropSetItem* item = GetBackpropSetItem(backprop_id.ordinal());\n    if (item == nullptr) {\n        return;\n    }\n\n    // Remove the connection pairs involving the backprop ID\n    backprop_connections_.erase(\n            std::remove_if(\n                    backprop_connections_.begin(),\n                    backprop_connections_.end(),\n                    [ordinal = backprop_id.ordinal()](const std::pair<BackpropOrdinal, BackpropOrdinal>& pair) {\n                        return pair.first == ordinal || pair.second == ordinal;\n                    }),\n            backprop_connections_.end());\n\n    // Remove the backprop ID.\n    backprop_set_.erase(\n            std::find_if(backprop_set_.begin(), backprop_set_.end(), [ordinal = backprop_id.ordinal()](const BackpropSetItem& item) {\n                return item.ordinal == ordinal;\n            }));\n}\n\nvoid Context::CheckValidBackpropId(const BackpropId& backprop_id) const {\n    if (&backprop_id.context() != this) {\n        throw ChainerxError{\"Invalid context in backprop ID: \", backprop_id};\n    }\n\n    std::lock_guard<std::mutex> lock{mutex_};\n    if (GetBackpropSetItem(backprop_id.ordinal()) == nullptr) {\n        throw ChainerxError{\"Invalid backprop ID, maybe already expired: \", ToBackpropIdString(backprop_id.ordinal())};\n    }\n}\n\nvoid Context::ConnectBackpropIds(const BackpropId& backprop_id1, const BackpropId& backprop_id2) {\n    CHAINERX_ASSERT(&backprop_id1.context() == this);\n    CHAINERX_ASSERT(&backprop_id2.context() == this);\n    if (backprop_id1 == backprop_id2) {\n        // They are identical\n        return;\n    }\n\n    std::lock_guard<std::mutex> lock{mutex_};\n\n    BackpropSetItem* item1 = GetBackpropSetItem(backprop_id1.ordinal());\n    BackpropSetItem* item2 = GetBackpropSetItem(backprop_id2.ordinal());\n    if (item1 == nullptr || item2 == nullptr) {\n        // At least one cannot be found\n        return;\n    }\n\n    std::pair<BackpropOrdinal, BackpropOrdinal> pair = std::minmax(backprop_id1.ordinal(), backprop_id2.ordinal());\n    if (backprop_connections_.end() != std::find(backprop_connections_.begin(), backprop_connections_.end(), pair)) {\n        // Already in connection\n        return;\n    }\n\n    // Add a new connection\n    backprop_connections_.emplace_back(pair);\n}\n\nstd::string Context::GetBackpropName(const BackpropId& backprop_id) {\n    // Note: backprop name cannot be returned by reference, as the reference may be invalidated when a new graph is pushed to the backprop\n    // set.\n    std::lock_guard<std::mutex> lock{mutex_};\n    return ToBackpropIdString(backprop_id.ordinal());\n}\n\nvoid Context::CheckBackpropAllowed(const BackpropId& backprop_id) {\n    std::lock_guard<std::mutex> lock{mutex_};\n    BackpropSetItem* item = GetBackpropSetItem(backprop_id.ordinal());\n    if (item == nullptr) {\n        throw ChainerxError{\"Backprop ID not found: \", ToBackpropIdString(backprop_id.ordinal())};\n    }\n    if (item->prohibiting_ordinal.has_value()) {\n        throw ChainerxError{\"Cannot backward for backprop ID '\",\n                            ToBackpropIdString(backprop_id.ordinal()),\n                            \"' because an connected backprop ID '\",\n                            ToBackpropIdString(*item->prohibiting_ordinal),\n                            \"' which has been created earlier, has already been backpropped.\"};\n    }\n}\n\nvoid Context::SetBackpropDone(const BackpropId& backprop_id) {\n    std::lock_guard<std::mutex> lock{mutex_};\n\n    CHAINERX_ASSERT(GetBackpropSetItem(backprop_id.ordinal()) != nullptr);\n\n    // Find connected backprop IDs\n    std::vector<BackpropOrdinal> ordinals_to_prohibit;\n    for (const std::pair<BackpropOrdinal, BackpropOrdinal>& pair : backprop_connections_) {\n        if (pair.first == backprop_id.ordinal()) {\n            ordinals_to_prohibit.emplace_back(pair.second);\n        }\n    }\n\n    // Mark connected backprop IDs as prohibited.\n    for (BackpropOrdinal ord : ordinals_to_prohibit) {\n        BackpropSetItem* item2 = GetBackpropSetItem(ord);\n        if (!item2->prohibiting_ordinal.has_value()) {\n            item2->prohibiting_ordinal = backprop_id.ordinal();\n        }\n    }\n}\n\nstd::vector<BackpropId> Context::GetInnerBackpropIds(const BackpropId& backprop_id) {\n    std::vector<BackpropId> inner_backprop_ids;\n\n    std::lock_guard<std::mutex> lock{mutex_};\n    inner_backprop_ids.reserve(backprop_set_.size());\n    for (const std::pair<BackpropOrdinal, BackpropOrdinal>& pair : backprop_connections_) {\n        if (pair.first == backprop_id.ordinal()) {\n            inner_backprop_ids.emplace_back(BackpropId{*this, pair.second});\n        }\n    }\n    return inner_backprop_ids;\n}\n\nstd::pair<Backend&, bool> Context::RegisterBackend(\n        const std::string& backend_name, std::unique_ptr<Backend, context_detail::BackendDeleter> backend) {\n    // In a multi-threaded case, backends_[backend_name] may already exist at this point.\n    // In that case, the backend created in `Context::GetBackend` is thrown away.\n    std::lock_guard<std::mutex> lock{mutex_};\n    auto pair = backends_.emplace(backend_name, std::move(backend));\n    // Initialize the backend only if emplaced.\n    if (!pair.second) {\n        return {*pair.first->second, false};\n    }\n    pair.first->second->Initialize();\n    return {*pair.first->second, true};\n}\n\ntemplate <typename ThisPtr, typename ReturnType>\nReturnType Context::GetBackpropSetItemImpl(ThisPtr this_ptr, BackpropOrdinal ordinal) {\n    // using reverse iterator because it's more likely to find earlier\n    auto it = std::find_if(this_ptr->backprop_set_.rbegin(), this_ptr->backprop_set_.rend(), [ordinal](const BackpropSetItem& item) {\n        return item.ordinal == ordinal;\n    });\n    if (it == this_ptr->backprop_set_.rend()) {\n        return nullptr;\n    }\n    return &*it;\n}\n\nstd::string Context::ToBackpropIdString(BackpropOrdinal ordinal) const {\n    static constexpr const char* kExpiredBackpropDisplayName = \"<expired>\";\n\n    const BackpropSetItem* item = GetBackpropSetItem(ordinal);\n    if (item == nullptr) {\n        return kExpiredBackpropDisplayName;\n    }\n    return item->name;\n}\n\nContext& GetGlobalDefaultContext() {\n    Context* context = g_global_default_context;\n    if (context == nullptr) {\n        throw ContextError{\"Global default context is not set.\"};\n    }\n    return *context;\n}\n\nvoid SetGlobalDefaultContext(Context* context) { g_global_default_context = context; }\n\nnamespace internal {\n\nContext* GetDefaultContextNoExcept() noexcept {\n    Context* default_context = internal::GetInternalThreadLocalState().default_context;\n    if (default_context == nullptr) {\n        return g_global_default_context;\n    }\n    return default_context;\n}\n\n}  // namespace internal\n\nContext& GetDefaultContext() {\n    Context* default_context = internal::GetInternalThreadLocalState().default_context;\n    if (default_context == nullptr) {\n        return GetGlobalDefaultContext();  // can throw\n    }\n    return *default_context;\n}\n\nvoid SetDefaultContext(Context* context) {\n    Context*& default_context = internal::GetInternalThreadLocalState().default_context;\n    if (default_context != context) {\n        default_context = context;\n        SetDefaultDevice(nullptr);\n    }\n}\n\n}  // namespace chainerx\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/chainerx_cc/chainerx/context.h": "#pragma once\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include <absl/types/optional.h>\n\n#include \"chainerx/backend.h\"\n#include \"chainerx/device.h\"\n#include \"chainerx/device_id.h\"\n#include \"chainerx/graph.h\"\n#include \"chainerx/macro.h\"\n\nnamespace chainerx {\nnamespace native {\n\nclass NativeBackend;\n\n}  // namespace native\n\nnamespace context_detail {\n\n// Deleter for backend object whose memory may be managed by external module.\nclass BackendDeleter {\npublic:\n    BackendDeleter()\n        : destroy_backend_func_{[](Backend*) {\n              CHAINERX_NEVER_REACH();  // Default-ctor is only for default-constructed unique_ptr which never calls deleter.\n          }} {}\n    explicit BackendDeleter(void (*destroy_backend_func)(Backend*)) : destroy_backend_func_{destroy_backend_func} {}\n\n    void operator()(Backend* backend) { destroy_backend_func_(backend); }\n\nprivate:\n    void (*destroy_backend_func_)(Backend*);\n};\n\n}  // namespace context_detail\n\n// TODO(sonots): Hide BackpropId-related functions from users.\n// TODO(sonots): Move implementations of BackpropId-releated functions into another class.\n// TODO(niboshi): Make BackpropId-related functions thread-safe.\nclass Context {\npublic:\n    Context();\n    ~Context();\n\n    Context(const Context&) = delete;\n    Context(Context&&) = delete;\n    Context& operator=(const Context&) = delete;\n    Context& operator=(Context&&) = delete;\n\n    // Gets the backend specified by the name.\n    // If the backend does not exist, this function automatically creates it.\n    Backend& GetBackend(const std::string& backend_name);\n\n    // Gets the native backend.\n    native::NativeBackend& GetNativeBackend();\n\n    // Registers the backend.\n    template <typename BackendType, typename... Args>\n    Backend& CreateBackend(const std::string& backend_name, Args&&... args) {\n        auto backend = std::unique_ptr<Backend, context_detail::BackendDeleter>{\n                new BackendType{*this, std::forward<Args>(args)...},\n                context_detail::BackendDeleter{[](gsl::owner<Backend*> ptr) { delete ptr; }}};\n        auto pair = RegisterBackend(backend_name, std::move(backend));\n        if (!pair.second) {\n            throw ContextError{\"Backend is already registered: \", backend_name};\n        }\n        return pair.first;\n    }\n\n    // Gets the device specified by the device ID.\n    // If the backend and/or device do not exist, this function automatically creates them.\n    Device& GetDevice(const DeviceId& device_id);\n\n    BackpropId MakeBackpropId(std::string backprop_name);\n\n    void ReleaseBackpropId(const BackpropId& backprop_id);\n\n    // TODO(sonots): Hide from users\n    void ReleaseBackpropIdNoExcept(const BackpropId& backprop_id) noexcept;\n\n    // Checks the specified backprop ID is valid, i.e. not released.\n    void CheckValidBackpropId(const BackpropId& backprop_id) const;\n\n    // Declares that the two backprop IDs co-exist in any portion of computation graph.\n    // Backpropping on the backprop ID with the lower ordinal will prohibit future backprop on the other.\n    // TODO(sonots): Hide from users\n    void ConnectBackpropIds(const BackpropId& backprop_id1, const BackpropId& backprop_id2);\n\n    // Return the name of the backprop.\n    // ChainerxError is thrown if the backprop ID is expired or non-existent in the context.\n    // TODO(sonots): Hide from users\n    std::string GetBackpropName(const BackpropId& backprop_id);\n\n    // Checks if the backprop ID is allowed to be backpropped.\n    // Backprop is allowed if the order of backprop IDs which have been backpropped is not reversed in any of the previous backprop scopes.\n    // ChainerxError is thrown if the check fails.\n    // TODO(sonots): Hide from users\n    void CheckBackpropAllowed(const BackpropId& backprop_id);\n\n    // Flags the backprop ID that it has been backpropped.\n    // TODO(sonots): Hide from users\n    void SetBackpropDone(const BackpropId& backprop_id);\n\n    // Returns all backprop IDs created after the queried graph.\n    // In many cases, these are also the graphs created in inner scopes.\n    // The queried graph is excluded from the returned container.\n    // TODO(sonots): Hide from users\n    std::vector<BackpropId> GetInnerBackpropIds(const BackpropId& backprop_id);\n\n    BackpropId default_backprop_id() {\n        // The first entry is always the default backprop ID.\n        std::lock_guard<std::mutex> lock{mutex_};\n        CHAINERX_ASSERT(!backprop_set_.empty());\n        return BackpropId{*this, backprop_set_.front().ordinal};\n    }\n\nprivate:\n    // If a backend associated with backend_name is already registered, returns a pair of the a reference to the backend already registered\n    // and true. Otherwise, registers the given backend and returns a pair of a reference to it and false\n    std::pair<Backend&, bool> RegisterBackend(\n            const std::string& backend_name, std::unique_ptr<Backend, context_detail::BackendDeleter> backend);\n\n    // TODO(niboshi): Support multi-thread usage\n    struct BackpropSetItem {\n        BackpropSetItem(BackpropOrdinal ordinal, std::string name) : ordinal{ordinal}, name{std::move(name)} {}\n\n        BackpropOrdinal ordinal;\n        std::string name;\n\n        // If this member has a value, it indicates that this Backprop ID is prohibited for further backprop.\n        // Its value is the backprop ID which caused the prohibition.\n        absl::optional<BackpropOrdinal> prohibiting_ordinal{absl::nullopt};\n    };\n\n    // Finds the BackpropSetItem instance.\n    // Note that this function is not thread safe.\n    const BackpropSetItem* GetBackpropSetItem(BackpropOrdinal ordinal) const {\n        return GetBackpropSetItemImpl<const Context*, const BackpropSetItem*>(this, ordinal);\n    }\n\n    // Finds the BackpropSetItem instance.\n    // Note that this function is not thread safe.\n    BackpropSetItem* GetBackpropSetItem(BackpropOrdinal ordinal) {\n        return GetBackpropSetItemImpl<Context*, BackpropSetItem*>(this, ordinal);\n    }\n\n    template <typename ThisPtr, typename ReturnType>\n    static ReturnType GetBackpropSetItemImpl(ThisPtr this_ptr, BackpropOrdinal ordinal);\n\n    // Returns a string representation of a backprop ID given its ordinal.\n    // A special string is returned if the given ordinal has already expired.\n    // Note that this function is not thread safe.\n    std::string ToBackpropIdString(BackpropOrdinal ordinal) const;\n\n    std::unordered_map<std::string, std::unique_ptr<Backend, context_detail::BackendDeleter>> backends_;\n    std::vector<void*> dlopen_handles_;\n    mutable std::mutex mutex_;\n\n    BackpropOrdinal next_backprop_ordinal_{0};\n\n    std::vector<BackpropSetItem> backprop_set_{};\n\n    // List of pairs of connected backprop IDs.\n    // The first ordinal is always less than the second, which means backpropping on the first will prohibit future backprop on the second.\n    std::vector<std::pair<BackpropOrdinal, BackpropOrdinal>> backprop_connections_;\n};\n\n// Gets/sets the context that used by default when current context is not set.\nContext& GetGlobalDefaultContext();\nvoid SetGlobalDefaultContext(Context* context);\n\nnamespace internal {\n\n// Returns the thread-local default context if it is set.\n// Otherwise returns the global default context, which can be nullptr.\nContext* GetDefaultContextNoExcept() noexcept;\n\n}  // namespace internal\n\n// Returns the thread-local default context if it is set.\n// Otherwise returns the global default context.\n// If it is also unset, ContextException will be thrown.\nContext& GetDefaultContext();\n\n// Sets thread local default context.\n//\n// The thread local default device is reset to null if given context is different with previous default context.\nvoid SetDefaultContext(Context* context);\n\n// Returns the specified device on the default context.\ninline Device& GetDevice(const DeviceId& device_id) { return GetDefaultContext().GetDevice(device_id); }\n\n// Returns the specified backend on the default context.\ninline Backend& GetBackend(const std::string& backend_name) { return GetDefaultContext().GetBackend(backend_name); }\n\n// Returns the native backend on the default context.\ninline native::NativeBackend& GetNativeBackend() { return GetDefaultContext().GetNativeBackend(); }\n\n// Scope object that switches the default context by RAII.\nclass ContextScope {\npublic:\n    ContextScope() : orig_ctx_{internal::GetDefaultContextNoExcept()}, orig_device_{internal::GetDefaultDeviceNoExcept()}, exited_{false} {}\n    explicit ContextScope(Context& context) : ContextScope{} { SetDefaultContext(&context); }\n\n    ContextScope(const ContextScope&) = delete;\n    ContextScope& operator=(const ContextScope&) = delete;\n    ContextScope& operator=(ContextScope&& other) = delete;\n\n    ContextScope(ContextScope&& other) noexcept : orig_ctx_{other.orig_ctx_}, orig_device_{other.orig_device_}, exited_{other.exited_} {\n        other.exited_ = true;\n    }\n\n    ~ContextScope() { Exit(); }\n\n    // Explicitly recovers the original context. It will invalidate the scope object so that dtor will do nothing.\n    void Exit() {\n        if (!exited_) {\n            try {\n                SetDefaultContext(orig_ctx_);\n                SetDefaultDevice(orig_device_);\n            } catch (...) {\n                CHAINERX_NEVER_REACH();\n            }\n            exited_ = true;\n        }\n    }\n\nprivate:\n    Context* orig_ctx_;\n    Device* orig_device_;\n    bool exited_;\n};\n\n}  // namespace chainerx\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/chainerx_cc/chainerx/platform.cc": "#include \"chainerx/platform.h\"\n\n#ifdef _WIN32\n#include \"chainerx/platform/windows.h\"\n#else  // _WIN32\n// Windows doesn't support it currently\n#include <dlfcn.h>\n// NOLINTNEXTLINE(modernize-deprecated-headers): clang-tidy recommends to use cstdlib, but setenv is not included in cstdlib\n#include <stdlib.h>\n\n#include <cerrno>\n#include <cstring>\n#include <string>\n\n#include \"chainerx/error.h\"\n#endif  // _WIN32\n\nnamespace chainerx {\nnamespace platform {\n\n#ifdef _WIN32\n\nvoid SetEnv(const std::string& name, const std::string& value) { windows::SetEnv(name, value); }\n\nvoid UnsetEnv(const std::string& name) { windows::UnsetEnv(name); }\n\nvoid* DlOpen(const std::string& filename) { return windows::DlOpen(filename); }\n\nvoid DlClose(void* handle) { windows::DlClose(handle); }\n\nvoid* DlSym(void* handle, const std::string& name) { return windows::DlSym(handle, name); }\n\n#else  // _WIN32\n\nvoid SetEnv(const std::string& name, const std::string& value) {\n    if (0 != ::setenv(name.c_str(), value.c_str(), 1)) {\n        throw ChainerxError{\"Failed to set environment variable '\", name, \"' to '\", value, \"': \", std::strerror(errno)};\n    }\n}\n\nvoid UnsetEnv(const std::string& name) {\n    if (0 != ::unsetenv(name.c_str())) {\n        throw ChainerxError{\"Failed to unset environment variable '\", name, \"': \", std::strerror(errno)};\n    }\n}\n\nvoid* DlOpen(const std::string& filename) {\n    if (void* handle = ::dlopen(filename.c_str(), RTLD_NOW | RTLD_LOCAL)) {\n        return handle;\n    }\n    throw ChainerxError{\"Failed to load shared object '\", filename, \"': \", ::dlerror()};\n}\n\nvoid DlClose(void* handle) {\n    if (0 != ::dlclose(handle)) {\n        throw ChainerxError{\"Failed to close shared object: \", ::dlerror()};\n    }\n}\n\nvoid* DlSym(void* handle, const std::string& name) {\n    if (void* symbol = ::dlsym(handle, name.c_str())) {\n        return symbol;\n    }\n\n    throw ChainerxError{\"Failed to get symbol: \", ::dlerror()};\n}\n\n#endif  // _WIN32\n\n}  // namespace platform\n}  // namespace chainerx\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/chainerx_cc/chainerx/CMakeLists.txt": "include_directories(\"${PROJECT_SOURCE_DIR}\")\n\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${CHAINERX_CXX_FLAGS}\")\n\nadd_subdirectory(kernels)\nadd_subdirectory(routines)\nadd_subdirectory(native)\nadd_subdirectory(testing)\nif(${CUDA_FOUND})\n    add_subdirectory(cuda)\nendif()\nif(${CHAINERX_BUILD_PYTHON})\n    add_subdirectory(python)\nendif()\n\ninstall(FILES\n    arithmetic_ops.h\n    array.h\n    array_body.h\n    array_body_leak_detection.h\n    array_fwd.h\n    array_index.h\n    array_node.h\n    array_repr.h\n    axes.h\n    backend.h\n    backend_util.h\n    backprop_mode.h\n    backprop_scope.h\n    backward.h\n    backward_builder.h\n    backward_context.h\n    backward_fwd.h\n    chainerx.h\n    check_backward.h\n    constant.h\n    context.h\n    device.h\n    device_id.h\n    dims.h\n    dtype.h\n    dynamic_lib.h\n    enum.h\n    error.h\n    float16.h\n    graph.h\n    hash_combine.h\n    index_iterator.h\n    indexable_array.h\n    indexer.h\n    kernel.h\n    kernel_registry.h\n    macro.h\n    numerical_gradient.h\n    numeric.h\n    numeric_limits.h\n    op_node.h\n    optional_container_arg.h\n    platform.h\n    reduction_kernel_arg.h\n    scalar.h\n    shape.h\n    slice.h\n    squash_dims.h\n    stack_vector.h\n    strides.h\n    thread_local_state.h\n    util.h\n    DESTINATION include/chainerx\n    )\n\nset(chainerx_srcs\n    array.cc\n    array_body.cc\n    array_body_leak_detection.cc\n    array_index.cc\n    array_repr.cc\n    axes.cc\n    backend.cc\n    backprop_mode.cc\n    backward.cc\n    backward_builder.cc\n    backward_context.cc\n    check_backward.cc\n    context.cc\n    device.cc\n    device_id.cc\n    dims.cc\n    dtype.cc\n    dynamic_lib.cc\n    float16.cc\n    graph.cc\n    numeric.cc\n    numerical_gradient.cc\n    op_node.cc\n    platform.cc\n    reduction_kernel_arg.cc\n    scalar.cc\n    shape.cc\n    strides.cc\n    thread_local_state.cc\n    util.cc\n    )\n\nadd_library(chainerx_base STATIC ${chainerx_srcs})\n\nif(MSVC)\n    install(FILES\n        platform/windows.h\n        DESTINATION include/chainerx/platform\n        )\n\n    set(chainerx_srcs\n        \"${chainerx_srcs}\"\n        platform/windows.cc\n        )\n    add_library(chainerx STATIC empty.cc)\nelse()\n    add_library(chainerx SHARED empty.cc)\nendif()\n\n# abseil\ntarget_link_libraries(\n    chainerx\n    PUBLIC\n    absl::failure_signal_handler\n    absl::bad_optional_access\n    PRIVATE\n    absl::flat_hash_map\n    )\n\n# dlopen / dlclose\ntarget_link_libraries(chainerx PUBLIC ${CMAKE_DL_LIBS})\n\n# ChainerX\nset(chainerx_sub_libs\n    chainerx_base\n    chainerx_routines\n    chainerx_native\n    chainerx_testing\n    )\n\nif(${CUDA_FOUND})\n    set(chainerx_sub_libs ${chainerx_sub_libs} chainerx_cuda)\nendif()\n\nif(MSVC)\n    target_link_libraries(chainerx PRIVATE ${chainerx_sub_libs})\n    foreach(lib ${chainerx_sub_libs})\n        target_link_options(chainerx PUBLIC /wholearchive:$<TARGET_FILE:${lib}>)\n    endforeach(lib)\nelseif(${APPLE})\n    foreach(lib ${chainerx_sub_libs})\n        target_link_libraries(chainerx PRIVATE -Wl,-force_load ${lib})\n    endforeach(lib)\n    target_link_libraries(chainerx PRIVATE -Wl,-noall_load)\nelse()\n    target_link_libraries(chainerx\n        PRIVATE\n        -Wl,--whole-archive\n        ${chainerx_sub_libs}\n        -Wl,--no-whole-archive\n        )\nendif()\n\ninstall(TARGETS chainerx DESTINATION lib)\n\nif(${CHAINERX_BUILD_TEST})\n    add_subdirectory(backend_testdata)\n    set(srcs\n        array_body_leak_detection_test.cc\n        array_device_test.cc\n        array_repr_test.cc\n        array_test.cc\n        array_to_device_test.cc\n        axes_test.cc\n        backprop_mode_test.cc\n        backward_builder_test.cc\n        backward_test.cc\n        check_backward_test.cc\n        context_test.cc\n        device_test.cc\n        dims_test.cc\n        dtype_test.cc\n        float16_test.cc\n        index_iterator_test.cc\n        indexable_array_test.cc\n        indexer_test.cc\n        kernel_registry_test.cc\n        numeric_limits_test.cc\n        numerical_gradient_test.cc\n        numeric_test.cc\n        optional_container_arg_test.cc\n        scalar_test.cc\n        shape_test.cc\n        squash_dims_test.cc\n        stack_vector_test.cc\n        strides_test.cc\n        thread_local_state_test.cc\n        )\n    if(${CUDA_FOUND})\n        CUDA_ADD_EXECUTABLE(chainerx_test ${srcs})\n    else()\n        add_executable(chainerx_test ${srcs})\n    endif()\n\n    target_compile_definitions(chainerx_test PRIVATE\n        CHAINERX_TEST_DIR=\"${CMAKE_CURRENT_BINARY_DIR}\")\n\n    target_link_libraries(chainerx_test\n        chainerx\n        chainerx_test_main\n        # gtest is linked via chainerx_testing.\n        )\n    add_test(NAME chainerx_test COMMAND chainerx_test)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/chainerx_cc/chainerx/platform/windows.cc": "#include \"chainerx/platform/windows.h\"\n\n#include <cerrno>\n#include <cstring>\n#include <string>\n\n#include \"chainerx/error.h\"\n\nnamespace chainerx {\nnamespace platform {\nnamespace windows {\n\nvoid SetEnv(const std::string& name, const std::string& value) {\n    errno_t err = ::_putenv_s(name.c_str(), value.c_str());\n    if (err != 0) {\n        throw ChainerxError{\"Failed to set environment variable '\", name, \"' to '\", value, \"': \", std::strerror(errno)};\n    }\n}\n\nvoid UnsetEnv(const std::string& name) {\n    errno_t err = ::_putenv_s(name.c_str(), \"\");\n    if (err != 0) {\n        throw ChainerxError{\"Failed to unset environment variable '\", name, \"': \", std::strerror(errno)};\n    }\n}\n\nvoid* DlOpen(const std::string& filename) {\n    // TODO(hvy): Implement dlopen for Windows.\n    throw ChainerxError{\"dlopen not implemented for Windows.\"};\n}\n\nvoid DlClose(void* handle) {\n    // TODO(hvy): Implement dlclose for Windows.\n    throw ChainerxError{\"dlclose not implemented for Windows.\"};\n}\n\nvoid* DlSym(void* handle, const std::string& name) {\n    // TODO(swd): Implement dlsym for Windows.\n    throw ChainerxError{\"dlsym not implemented for Windows.\"};\n}\n\n}  // namespace windows\n}  // namespace platform\n}  // namespace chainerx\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/tests/chainer_tests/datasets_tests/image_dataset/chainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/tests/chainer_tests/datasets_tests/image_dataset/chainer_grey.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/tests/chainer_tests/datasets_tests/image_dataset/zipped_images_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/tests/chainer_tests/datasets_tests/image_dataset/zipped_images_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/onnx_chainer/examples/images/cat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/imagenet/mean.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/dcgan/example_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/mnist/parallelism_axis.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/mnist/dual_parallel.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/mnist/model_parallel.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/chainermn/parallel_convolution/parallel-conv.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/imagenet/mean.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/imagenet/.testdata/images/chainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/dcgan/example_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/examples/pix2pix/image/example.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/parallelism.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/iteration_chainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/googlenet.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/polynomial.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/chainer_red_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/chainermn1000px.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/iteration_chainermn.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-model.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-dataset.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-trainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/loss.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-iterator.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-optimizer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-extensions.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/accuracy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer-updater.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/glance/trainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/seq2seq/lstm-rnn.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/seq2seq/seq2seq.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/generated-image-epoch1000.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/generated-images.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/update-gan.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/gan-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/class-generative-model.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/dcgan/dcgan.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/train_loop/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/train_loop/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/pseudo_connect_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/parallel_conv.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/averaging.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/delegate_variable_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/comm_split.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/scatter_dataset.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/seq2seq_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/model_parallel_mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/seq2seq_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/delegate_variable_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/multi_node_iterator.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/pseudo_connect_0.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/empty_dataset.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/communication_as_function.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/model_parallel/spmd.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/word2vec/skipgram_detail.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/word2vec/center_context_word.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/trainer/mnist_graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/trainer/mnist_loss.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/trainer/mnist_output.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/trainer/trainer.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/trainer/mnist_accuracy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/ptb/rnnlm.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-chainer-7.2.0-qfy336dhsv6ooc5snngbtsawhb7nsygs/spack-src/docs/image/ptb/rnnlm_example.png"
    ],
    "total_files": 1793
}