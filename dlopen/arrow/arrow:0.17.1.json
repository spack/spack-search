{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/cpp/src/arrow/io/hdfs_internal.cc": "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// This shim interface to libhdfs (for runtime shared library loading) has been\n// adapted from the SFrame project, released under the ASF-compatible 3-clause\n// BSD license\n//\n// Using this required having the $JAVA_HOME and $HADOOP_HOME environment\n// variables set, so that libjvm and libhdfs can be located easily\n\n// Copyright (C) 2015 Dato, Inc.\n// All rights reserved.\n//\n// This software may be modified and distributed under the terms\n// of the BSD license. See the LICENSE file for details.\n\n#include \"arrow/io/hdfs_internal.h\"\n\n#include <cstdint>\n#include <cstdlib>\n#include <mutex>\n#include <sstream>  // IWYU pragma: keep\n#include <string>\n#include <utility>\n#include <vector>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#endif\n\n#include \"arrow/result.h\"\n#include \"arrow/status.h\"\n#include \"arrow/util/io_util.h\"\n#include \"arrow/util/logging.h\"\n\nnamespace arrow {\n\nusing internal::GetEnvVarNative;\nusing internal::PlatformFilename;\n#ifdef _WIN32\nusing internal::WinErrorMessage;\n#endif\n\nnamespace io {\nnamespace internal {\n\nnamespace {\n\nvoid* GetLibrarySymbol(LibraryHandle handle, const char* symbol) {\n  if (handle == NULL) return NULL;\n#ifndef _WIN32\n  return dlsym(handle, symbol);\n#else\n\n  void* ret = reinterpret_cast<void*>(GetProcAddress(handle, symbol));\n  if (ret == NULL) {\n    // logstream(LOG_INFO) << \"GetProcAddress error: \"\n    //                     << get_last_err_str(GetLastError()) << std::endl;\n  }\n  return ret;\n#endif\n}\n\n#define GET_SYMBOL_REQUIRED(SHIM, SYMBOL_NAME)                         \\\n  do {                                                                 \\\n    if (!SHIM->SYMBOL_NAME) {                                          \\\n      *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =                  \\\n          GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME);             \\\n    }                                                                  \\\n    if (!SHIM->SYMBOL_NAME)                                            \\\n      return Status::IOError(\"Getting symbol \" #SYMBOL_NAME \"failed\"); \\\n  } while (0)\n\n#define GET_SYMBOL(SHIM, SYMBOL_NAME)                    \\\n  if (!SHIM->SYMBOL_NAME) {                              \\\n    *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =      \\\n        GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME); \\\n  }\n\nLibraryHandle libjvm_handle = nullptr;\n\n// Helper functions for dlopens\nResult<std::vector<PlatformFilename>> get_potential_libjvm_paths();\nResult<std::vector<PlatformFilename>> get_potential_libhdfs_paths();\nResult<LibraryHandle> try_dlopen(const std::vector<PlatformFilename>& potential_paths,\n                                 const char* name);\n\nResult<std::vector<PlatformFilename>> MakeFilenameVector(\n    const std::vector<std::string>& names) {\n  std::vector<PlatformFilename> filenames(names.size());\n  for (size_t i = 0; i < names.size(); ++i) {\n    ARROW_ASSIGN_OR_RAISE(filenames[i], PlatformFilename::FromString(names[i]));\n  }\n  return filenames;\n}\n\nvoid AppendEnvVarFilename(const char* var_name,\n                          std::vector<PlatformFilename>* filenames) {\n  auto maybe_env_var = GetEnvVarNative(var_name);\n  if (maybe_env_var.ok()) {\n    filenames->emplace_back(std::move(*maybe_env_var));\n  }\n}\n\nvoid AppendEnvVarFilename(const char* var_name, const char* suffix,\n                          std::vector<PlatformFilename>* filenames) {\n  auto maybe_env_var = GetEnvVarNative(var_name);\n  if (maybe_env_var.ok()) {\n    auto maybe_env_var_with_suffix =\n        PlatformFilename(std::move(*maybe_env_var)).Join(suffix);\n    if (maybe_env_var_with_suffix.ok()) {\n      filenames->emplace_back(std::move(*maybe_env_var_with_suffix));\n    }\n  }\n}\n\nvoid InsertEnvVarFilename(const char* var_name,\n                          std::vector<PlatformFilename>* filenames) {\n  auto maybe_env_var = GetEnvVarNative(var_name);\n  if (maybe_env_var.ok()) {\n    filenames->emplace(filenames->begin(), PlatformFilename(std::move(*maybe_env_var)));\n  }\n}\n\nResult<std::vector<PlatformFilename>> get_potential_libhdfs_paths() {\n  std::vector<PlatformFilename> potential_paths;\n  std::string file_name;\n\n// OS-specific file name\n#ifdef _WIN32\n  file_name = \"hdfs.dll\";\n#elif __APPLE__\n  file_name = \"libhdfs.dylib\";\n#else\n  file_name = \"libhdfs.so\";\n#endif\n\n  // Common paths\n  ARROW_ASSIGN_OR_RAISE(auto search_paths, MakeFilenameVector({\"\", \".\"}));\n\n  // Path from environment variable\n  AppendEnvVarFilename(\"HADOOP_HOME\", \"lib/native\", &search_paths);\n  AppendEnvVarFilename(\"ARROW_LIBHDFS_DIR\", &search_paths);\n\n  // All paths with file name\n  for (const auto& path : search_paths) {\n    ARROW_ASSIGN_OR_RAISE(auto full_path, path.Join(file_name));\n    potential_paths.push_back(std::move(full_path));\n  }\n\n  return potential_paths;\n}\n\nResult<std::vector<PlatformFilename>> get_potential_libjvm_paths() {\n  std::vector<PlatformFilename> potential_paths;\n\n  std::vector<PlatformFilename> search_prefixes;\n  std::vector<PlatformFilename> search_suffixes;\n  std::string file_name;\n\n// From heuristics\n#ifdef __WIN32\n  ARROW_ASSIGN_OR_RAISE(search_prefixes, MakeFilenameVector({\"\"}));\n  ARROW_ASSIGN_OR_RAISE(search_suffixes,\n                        MakeFilenameVector({\"/jre/bin/server\", \"/bin/server\"}));\n  file_name = \"jvm.dll\";\n#elif __APPLE__\n  ARROW_ASSIGN_OR_RAISE(search_prefixes, MakeFilenameVector({\"\"}));\n  ARROW_ASSIGN_OR_RAISE(search_suffixes,\n                        MakeFilenameVector({\"/jre/lib/server\", \"/lib/server\"}));\n  file_name = \"libjvm.dylib\";\n\n// SFrame uses /usr/libexec/java_home to find JAVA_HOME; for now we are\n// expecting users to set an environment variable\n#else\n  ARROW_ASSIGN_OR_RAISE(\n      search_prefixes,\n      MakeFilenameVector({\n          \"/usr/lib/jvm/default-java\",                // ubuntu / debian distros\n          \"/usr/lib/jvm/java\",                        // rhel6\n          \"/usr/lib/jvm\",                             // centos6\n          \"/usr/lib64/jvm\",                           // opensuse 13\n          \"/usr/local/lib/jvm/default-java\",          // alt ubuntu / debian distros\n          \"/usr/local/lib/jvm/java\",                  // alt rhel6\n          \"/usr/local/lib/jvm\",                       // alt centos6\n          \"/usr/local/lib64/jvm\",                     // alt opensuse 13\n          \"/usr/local/lib/jvm/java-8-openjdk-amd64\",  // alt ubuntu / debian distros\n          \"/usr/lib/jvm/java-8-openjdk-amd64\",        // alt ubuntu / debian distros\n          \"/usr/local/lib/jvm/java-7-openjdk-amd64\",  // alt ubuntu / debian distros\n          \"/usr/lib/jvm/java-7-openjdk-amd64\",        // alt ubuntu / debian distros\n          \"/usr/local/lib/jvm/java-6-openjdk-amd64\",  // alt ubuntu / debian distros\n          \"/usr/lib/jvm/java-6-openjdk-amd64\",        // alt ubuntu / debian distros\n          \"/usr/lib/jvm/java-7-oracle\",               // alt ubuntu\n          \"/usr/lib/jvm/java-8-oracle\",               // alt ubuntu\n          \"/usr/lib/jvm/java-6-oracle\",               // alt ubuntu\n          \"/usr/local/lib/jvm/java-7-oracle\",         // alt ubuntu\n          \"/usr/local/lib/jvm/java-8-oracle\",         // alt ubuntu\n          \"/usr/local/lib/jvm/java-6-oracle\",         // alt ubuntu\n          \"/usr/lib/jvm/default\",                     // alt centos\n          \"/usr/java/latest\",                         // alt centos\n      }));\n  ARROW_ASSIGN_OR_RAISE(search_suffixes,\n                        MakeFilenameVector({\"\", \"/jre/lib/amd64/server\",\n                                            \"/lib/amd64/server\", \"/lib/server\"}));\n  file_name = \"libjvm.so\";\n#endif\n\n  // From direct environment variable\n  InsertEnvVarFilename(\"JAVA_HOME\", &search_prefixes);\n\n  // Generate cross product between search_prefixes, search_suffixes, and file_name\n  for (auto& prefix : search_prefixes) {\n    for (auto& suffix : search_suffixes) {\n      ARROW_ASSIGN_OR_RAISE(auto path, prefix.Join(suffix).Join(file_name));\n      potential_paths.push_back(std::move(path));\n    }\n  }\n\n  return potential_paths;\n}\n\n#ifndef _WIN32\nResult<LibraryHandle> try_dlopen(const std::vector<PlatformFilename>& potential_paths,\n                                 const char* name) {\n  std::string error_message = \"unknown error\";\n  LibraryHandle handle;\n\n  for (const auto& p : potential_paths) {\n    handle = dlopen(p.ToNative().c_str(), RTLD_NOW | RTLD_LOCAL);\n\n    if (handle != NULL) {\n      return handle;\n    } else {\n      const char* err_msg = dlerror();\n      if (err_msg != NULL) {\n        error_message = err_msg;\n      }\n    }\n  }\n\n  return Status::IOError(\"Unable to load \", name, \": \", error_message);\n}\n\n#else\nResult<LibraryHandle> try_dlopen(const std::vector<PlatformFilename>& potential_paths,\n                                 const char* name) {\n  std::string error_message;\n  LibraryHandle handle;\n\n  for (const auto& p : potential_paths) {\n    handle = LoadLibraryW(p.ToNative().c_str());\n    if (handle != NULL) {\n      return handle;\n    } else {\n      error_message = WinErrorMessage(GetLastError());\n    }\n  }\n\n  return Status::IOError(\"Unable to load \", name, \": \", error_message);\n}\n#endif  // _WIN32\n\nLibHdfsShim libhdfs_shim;\n\n}  // namespace\n\nStatus LibHdfsShim::GetRequiredSymbols() {\n  GET_SYMBOL_REQUIRED(this, hdfsNewBuilder);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNode);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNodePort);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetUserName);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetKerbTicketCachePath);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetForceNewInstance);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConfSetStr);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConnect);\n  GET_SYMBOL_REQUIRED(this, hdfsCreateDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsDelete);\n  GET_SYMBOL_REQUIRED(this, hdfsDisconnect);\n  GET_SYMBOL_REQUIRED(this, hdfsExists);\n  GET_SYMBOL_REQUIRED(this, hdfsFreeFileInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsGetCapacity);\n  GET_SYMBOL_REQUIRED(this, hdfsGetUsed);\n  GET_SYMBOL_REQUIRED(this, hdfsGetPathInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsListDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsChown);\n  GET_SYMBOL_REQUIRED(this, hdfsChmod);\n\n  // File methods\n  GET_SYMBOL_REQUIRED(this, hdfsCloseFile);\n  GET_SYMBOL_REQUIRED(this, hdfsFlush);\n  GET_SYMBOL_REQUIRED(this, hdfsOpenFile);\n  GET_SYMBOL_REQUIRED(this, hdfsRead);\n  GET_SYMBOL_REQUIRED(this, hdfsSeek);\n  GET_SYMBOL_REQUIRED(this, hdfsTell);\n  GET_SYMBOL_REQUIRED(this, hdfsWrite);\n\n  return Status::OK();\n}\n\nStatus ConnectLibHdfs(LibHdfsShim** driver) {\n  static std::mutex lock;\n  std::lock_guard<std::mutex> guard(lock);\n\n  LibHdfsShim* shim = &libhdfs_shim;\n\n  static bool shim_attempted = false;\n  if (!shim_attempted) {\n    shim_attempted = true;\n\n    shim->Initialize();\n\n    ARROW_ASSIGN_OR_RAISE(auto libjvm_potential_paths, get_potential_libjvm_paths());\n    ARROW_ASSIGN_OR_RAISE(libjvm_handle, try_dlopen(libjvm_potential_paths, \"libjvm\"));\n\n    ARROW_ASSIGN_OR_RAISE(auto libhdfs_potential_paths, get_potential_libhdfs_paths());\n    ARROW_ASSIGN_OR_RAISE(shim->handle, try_dlopen(libhdfs_potential_paths, \"libhdfs\"));\n  } else if (shim->handle == nullptr) {\n    return Status::IOError(\"Prior attempt to load libhdfs failed\");\n  }\n\n  *driver = shim;\n  return shim->GetRequiredSymbols();\n}\n\n///////////////////////////////////////////////////////////////////////////\n// HDFS thin wrapper methods\n\nhdfsBuilder* LibHdfsShim::NewBuilder(void) { return this->hdfsNewBuilder(); }\n\nvoid LibHdfsShim::BuilderSetNameNode(hdfsBuilder* bld, const char* nn) {\n  this->hdfsBuilderSetNameNode(bld, nn);\n}\n\nvoid LibHdfsShim::BuilderSetNameNodePort(hdfsBuilder* bld, tPort port) {\n  this->hdfsBuilderSetNameNodePort(bld, port);\n}\n\nvoid LibHdfsShim::BuilderSetUserName(hdfsBuilder* bld, const char* userName) {\n  this->hdfsBuilderSetUserName(bld, userName);\n}\n\nvoid LibHdfsShim::BuilderSetKerbTicketCachePath(hdfsBuilder* bld,\n                                                const char* kerbTicketCachePath) {\n  this->hdfsBuilderSetKerbTicketCachePath(bld, kerbTicketCachePath);\n}\n\nvoid LibHdfsShim::BuilderSetForceNewInstance(hdfsBuilder* bld) {\n  this->hdfsBuilderSetForceNewInstance(bld);\n}\n\nhdfsFS LibHdfsShim::BuilderConnect(hdfsBuilder* bld) {\n  return this->hdfsBuilderConnect(bld);\n}\n\nint LibHdfsShim::BuilderConfSetStr(hdfsBuilder* bld, const char* key, const char* val) {\n  return this->hdfsBuilderConfSetStr(bld, key, val);\n}\n\nint LibHdfsShim::Disconnect(hdfsFS fs) { return this->hdfsDisconnect(fs); }\n\nhdfsFile LibHdfsShim::OpenFile(hdfsFS fs, const char* path, int flags, int bufferSize,\n                               short replication, tSize blocksize) {  // NOLINT\n  return this->hdfsOpenFile(fs, path, flags, bufferSize, replication, blocksize);\n}\n\nint LibHdfsShim::CloseFile(hdfsFS fs, hdfsFile file) {\n  return this->hdfsCloseFile(fs, file);\n}\n\nint LibHdfsShim::Exists(hdfsFS fs, const char* path) {\n  return this->hdfsExists(fs, path);\n}\n\nint LibHdfsShim::Seek(hdfsFS fs, hdfsFile file, tOffset desiredPos) {\n  return this->hdfsSeek(fs, file, desiredPos);\n}\n\ntOffset LibHdfsShim::Tell(hdfsFS fs, hdfsFile file) { return this->hdfsTell(fs, file); }\n\ntSize LibHdfsShim::Read(hdfsFS fs, hdfsFile file, void* buffer, tSize length) {\n  return this->hdfsRead(fs, file, buffer, length);\n}\n\nbool LibHdfsShim::HasPread() {\n  GET_SYMBOL(this, hdfsPread);\n  return this->hdfsPread != nullptr;\n}\n\ntSize LibHdfsShim::Pread(hdfsFS fs, hdfsFile file, tOffset position, void* buffer,\n                         tSize length) {\n  GET_SYMBOL(this, hdfsPread);\n  DCHECK(this->hdfsPread);\n  return this->hdfsPread(fs, file, position, buffer, length);\n}\n\ntSize LibHdfsShim::Write(hdfsFS fs, hdfsFile file, const void* buffer, tSize length) {\n  return this->hdfsWrite(fs, file, buffer, length);\n}\n\nint LibHdfsShim::Flush(hdfsFS fs, hdfsFile file) { return this->hdfsFlush(fs, file); }\n\nint LibHdfsShim::Available(hdfsFS fs, hdfsFile file) {\n  GET_SYMBOL(this, hdfsAvailable);\n  if (this->hdfsAvailable)\n    return this->hdfsAvailable(fs, file);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Copy(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsCopy);\n  if (this->hdfsCopy)\n    return this->hdfsCopy(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Move(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsMove);\n  if (this->hdfsMove)\n    return this->hdfsMove(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Delete(hdfsFS fs, const char* path, int recursive) {\n  return this->hdfsDelete(fs, path, recursive);\n}\n\nint LibHdfsShim::Rename(hdfsFS fs, const char* oldPath, const char* newPath) {\n  GET_SYMBOL(this, hdfsRename);\n  if (this->hdfsRename)\n    return this->hdfsRename(fs, oldPath, newPath);\n  else\n    return 0;\n}\n\nchar* LibHdfsShim::GetWorkingDirectory(hdfsFS fs, char* buffer, size_t bufferSize) {\n  GET_SYMBOL(this, hdfsGetWorkingDirectory);\n  if (this->hdfsGetWorkingDirectory) {\n    return this->hdfsGetWorkingDirectory(fs, buffer, bufferSize);\n  } else {\n    return NULL;\n  }\n}\n\nint LibHdfsShim::SetWorkingDirectory(hdfsFS fs, const char* path) {\n  GET_SYMBOL(this, hdfsSetWorkingDirectory);\n  if (this->hdfsSetWorkingDirectory) {\n    return this->hdfsSetWorkingDirectory(fs, path);\n  } else {\n    return 0;\n  }\n}\n\nint LibHdfsShim::MakeDirectory(hdfsFS fs, const char* path) {\n  return this->hdfsCreateDirectory(fs, path);\n}\n\nint LibHdfsShim::SetReplication(hdfsFS fs, const char* path, int16_t replication) {\n  GET_SYMBOL(this, hdfsSetReplication);\n  if (this->hdfsSetReplication) {\n    return this->hdfsSetReplication(fs, path, replication);\n  } else {\n    return 0;\n  }\n}\n\nhdfsFileInfo* LibHdfsShim::ListDirectory(hdfsFS fs, const char* path, int* numEntries) {\n  return this->hdfsListDirectory(fs, path, numEntries);\n}\n\nhdfsFileInfo* LibHdfsShim::GetPathInfo(hdfsFS fs, const char* path) {\n  return this->hdfsGetPathInfo(fs, path);\n}\n\nvoid LibHdfsShim::FreeFileInfo(hdfsFileInfo* hdfsFileInfo, int numEntries) {\n  this->hdfsFreeFileInfo(hdfsFileInfo, numEntries);\n}\n\nchar*** LibHdfsShim::GetHosts(hdfsFS fs, const char* path, tOffset start,\n                              tOffset length) {\n  GET_SYMBOL(this, hdfsGetHosts);\n  if (this->hdfsGetHosts) {\n    return this->hdfsGetHosts(fs, path, start, length);\n  } else {\n    return NULL;\n  }\n}\n\nvoid LibHdfsShim::FreeHosts(char*** blockHosts) {\n  GET_SYMBOL(this, hdfsFreeHosts);\n  if (this->hdfsFreeHosts) {\n    this->hdfsFreeHosts(blockHosts);\n  }\n}\n\ntOffset LibHdfsShim::GetDefaultBlockSize(hdfsFS fs) {\n  GET_SYMBOL(this, hdfsGetDefaultBlockSize);\n  if (this->hdfsGetDefaultBlockSize) {\n    return this->hdfsGetDefaultBlockSize(fs);\n  } else {\n    return 0;\n  }\n}\n\ntOffset LibHdfsShim::GetCapacity(hdfsFS fs) { return this->hdfsGetCapacity(fs); }\n\ntOffset LibHdfsShim::GetUsed(hdfsFS fs) { return this->hdfsGetUsed(fs); }\n\nint LibHdfsShim::Chown(hdfsFS fs, const char* path, const char* owner,\n                       const char* group) {\n  return this->hdfsChown(fs, path, owner, group);\n}\n\nint LibHdfsShim::Chmod(hdfsFS fs, const char* path, short mode) {  // NOLINT\n  return this->hdfsChmod(fs, path, mode);\n}\n\nint LibHdfsShim::Utime(hdfsFS fs, const char* path, tTime mtime, tTime atime) {\n  GET_SYMBOL(this, hdfsUtime);\n  if (this->hdfsUtime) {\n    return this->hdfsUtime(fs, path, mtime, atime);\n  } else {\n    return 0;\n  }\n}\n\n}  // namespace internal\n}  // namespace io\n}  // namespace arrow\n",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/r/README.md": "# arrow\n\n[![cran](https://www.r-pkg.org/badges/version-last-release/arrow)](https://cran.r-project.org/package=arrow)\n[![CI](https://github.com/apache/arrow/workflows/R/badge.svg?event=push)](https://github.com/apache/arrow/actions?query=workflow%3AR+branch%3Amaster+event%3Apush)\n[![conda-forge](https://img.shields.io/conda/vn/conda-forge/r-arrow.svg)](https://anaconda.org/conda-forge/r-arrow)\n[![codecov](https://codecov.io/gh/ursa-labs/arrow-r-nightly/branch/master/graph/badge.svg)](https://codecov.io/gh/ursa-labs/arrow-r-nightly)\n\n[Apache Arrow](https://arrow.apache.org/) is a cross-language\ndevelopment platform for in-memory data. It specifies a standardized\nlanguage-independent columnar memory format for flat and hierarchical\ndata, organized for efficient analytic operations on modern hardware. It\nalso provides computational libraries and zero-copy streaming messaging\nand interprocess communication.\n\nThe `arrow` package exposes an interface to the Arrow C++ library to\naccess many of its features in R. This includes support for analyzing\nlarge, multi-file datasets (`open_dataset()`), working with individual\nParquet (`read_parquet()`, `write_parquet()`) and Feather\n(`read_feather()`, `write_feather()`) files, as well as lower-level\naccess to Arrow memory and messages.\n\n## Installation\n\nInstall the latest release of `arrow` from CRAN with\n\n```r\ninstall.packages(\"arrow\")\n```\n\nConda users on Linux and macOS can install `arrow` from conda-forge with\n\n```\nconda install -c conda-forge --strict-channel-priority r-arrow\n```\n\nInstalling a released version of the `arrow` package requires no\nadditional system dependencies. For macOS and Windows, CRAN hosts binary\npackages that contain the Arrow C++ library. On Linux, source package\ninstallation will also build necessary C++ dependencies. For a faster,\nmore complete installation, set the environment variable `NOT_CRAN=true`.\nSee `vignette(\"install\", package = \"arrow\")` for details.\n\nIf you install the `arrow` package from source and the C++ library is\nnot found, the R package functions will notify you that Arrow is not\navailable. Call\n\n```r\narrow::install_arrow()\n```\n\nto retry installation with dependencies.\n\nNote that `install_arrow()` is available as a standalone script, so you can\naccess it for convenience without first installing the package:\n\n```r\nsource(\"https://raw.githubusercontent.com/apache/arrow/master/r/R/install-arrow.R\")\ninstall_arrow()\n```\n\n## Installing a development version\n\nDevelopment versions of the package (binary and source) are built daily and hosted at\n<https://dl.bintray.com/ursalabs/arrow-r/>. To install from there:\n\n``` r\ninstall.packages(\"arrow\", repos = \"https://dl.bintray.com/ursalabs/arrow-r\")\n```\n\nOr\n\n```r\ninstall_arrow(nightly = TRUE)\n```\n\nThese daily package builds are not official Apache releases and are not\nrecommended for production use. They may be useful for testing bug fixes\nand new features under active development.\n\n## Developing\n\nWindows and macOS users who wish to contribute to the R package and\ndon\u2019t need to alter the Arrow C++ library may be able to obtain a\nrecent version of the library without building from source. On macOS,\nyou may install the C++ library using [Homebrew](https://brew.sh/):\n\n``` shell\n# For the released version:\nbrew install apache-arrow\n# Or for a development version, you can try:\nbrew install apache-arrow --HEAD\n```\n\nOn Windows, you can download a .zip file with the arrow dependencies from the\n[nightly bintray repository](https://dl.bintray.com/ursalabs/arrow-r/libarrow/bin/windows-35/),\nand then set the `RWINLIB_LOCAL` environment variable to point to that\nzip file before installing the `arrow` R package. Version numbers in that\nrepository correspond to dates, and you will likely want the most recent.\n\nIf you need to alter both the Arrow C++ library and the R package code,\nor if you can\u2019t get a binary version of the latest C++ library\nelsewhere, you\u2019ll need to build it from source too.\n\nFirst, install the C++ library. See the [developer\nguide](https://arrow.apache.org/docs/developers/cpp/building.html) for details.\n\nNote that after any change to the C++ library, you must reinstall it and\nrun `make clean` or `git clean -fdx .` to remove any cached object code\nin the `r/src/` directory before reinstalling the R package. This is\nonly necessary if you make changes to the C++ library source; you do not\nneed to manually purge object files if you are only editing R or Rcpp\ncode inside `r/`.\n\nOnce you\u2019ve built the C++ library, you can install the R package and its\ndependencies, along with additional dev dependencies, from the git\ncheckout:\n\n``` shell\ncd ../../r\nR -e 'install.packages(c(\"devtools\", \"roxygen2\", \"pkgdown\", \"covr\")); devtools::install_dev_deps()'\nR CMD INSTALL .\n```\n\nIf you need to set any compilation flags while building the Rcpp\nextensions, you can use the `ARROW_R_CXXFLAGS` environment variable. For\nexample, if you are using `perf` to profile the R extensions, you may\nneed to set\n\n``` shell\nexport ARROW_R_CXXFLAGS=-fno-omit-frame-pointer\n```\n\nIf the package fails to install/load with an error like this:\n\n    ** testing if installed package can be loaded from temporary location\n    Error: package or namespace load failed for 'arrow' in dyn.load(file, DLLpath = DLLpath, ...):\n    unable to load shared object '/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so':\n    dlopen(/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so, 6): Library not loaded: @rpath/libarrow.14.dylib\n\ntry setting the environment variable `R_LD_LIBRARY_PATH` to wherever\nArrow C++ was put in `make install`, e.g.\u00a0`export\nR_LD_LIBRARY_PATH=/usr/local/lib`, and retry installing the R package.\n\nWhen installing from source, if the R and C++ library versions do not\nmatch, installation may fail. If you\u2019ve previously installed the\nlibraries and want to upgrade the R package, you\u2019ll need to update the\nArrow C++ library first.\n\nFor any other build/configuration challenges, see the [C++ developer\nguide](https://arrow.apache.org/docs/developers/cpp/building.html) and\n`vignette(\"install\", package = \"arrow\")`.\n\n### Editing Rcpp code\n\nThe `arrow` package uses some customized tools on top of `Rcpp` to\nprepare its C++ code in `src/`. If you change C++ code in the R package,\nyou will need to set the `ARROW_R_DEV` environment variable to `TRUE`\n(optionally, add it to your`~/.Renviron` file to persist across\nsessions) so that the `data-raw/codegen.R` file is used for code\ngeneration.\n\nThe codegen.R script has these additional dependencies:\n\n``` r\nremotes::install_github(\"nealrichardson/decor\")\ninstall.packages(\"glue\")\n```\n\nWe use Google C++ style in our C++ code. Check for style errors with\n\n    ./lint.sh\n\nFix any style issues before committing with\n\n    ./lint.sh --fix\n\nThe lint script requires Python 3 and `clang-format-8`. If the command\nisn\u2019t found, you can explicitly provide the path to it like\n`CLANG_FORMAT=$(which clang-format-8) ./lint.sh`. On macOS, you can get\nthis by installing LLVM via Homebrew and running the script as\n`CLANG_FORMAT=$(brew --prefix llvm@8)/bin/clang-format ./lint.sh`\n\n### Useful functions\n\nWithin an R session, these can help with package development:\n\n``` r\ndevtools::load_all() # Load the dev package\ndevtools::test(filter=\"^regexp$\") # Run the test suite, optionally filtering file names\ndevtools::document() # Update roxygen documentation\npkgdown::build_site() # To preview the documentation website\ndevtools::check() # All package checks; see also below\ncovr::package_coverage() # See test coverage statistics\n```\n\nAny of those can be run from the command line by wrapping them in `R -e\n'$COMMAND'`. There\u2019s also a `Makefile` to help with some common tasks\nfrom the command line (`make test`, `make doc`, `make clean`, etc.)\n\n### Full package validation\n\n``` shell\nR CMD build .\nR CMD check arrow_*.tar.gz --as-cran\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/r/vignettes/install.Rmd": "---\ntitle: \"Installing the Arrow Package on Linux\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Installing the Arrow Package on Linux}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\nOn macOS and Windows, when you `install.packages(\"arrow\")`,\nyou get a binary package that contains Arrow\u2019s C++ dependencies along with it.\nOn Linux, `install.packages()` retrieves a source package that has to be compiled locally,\nand C++ dependencies need to be resolved as well.\nGenerally for R packages with C++ dependencies,\nthis requires either installing system packages, which you may not have privileges to do,\nor building the C++ dependencies separately,\nwhich introduces all sorts of additional ways for things to go wrong.\n\nOur goal is to make `install.packages(\"arrow\")` \"just work\" for as many Linux distributions,\nversions, and configurations as possible.\nThis document describes how it works and the options for fine-tuning Linux installation.\nThe intended audience for this document is `arrow` R package users on Linux, not developers.\nIf you're contributing to the Arrow project,\nyou'll probably want to manage your C++ installation more directly.\nNote also that if you use `conda` to manage your R environment, this document does not apply.\nYou can `conda install -c conda-forge --strict-channel-priority r-arrow` and you'll get the latest official\nrelease of the R package along with any C++ dependencies.\n\n# Installation basics\n\nInstall the latest release of `arrow` from CRAN with\n\n```r\ninstall.packages(\"arrow\")\n```\n\nDaily development builds, which are not official releases,\ncan be installed from the Ursa Labs repository:\n\n```r\ninstall.packages(\"arrow\", repos = \"https://dl.bintray.com/ursalabs/arrow-r\")\n```\n\nThere currently are no daily `conda` builds.\n\nYou can also install the R package from a git checkout:\n\n```shell\ngit clone https://github.com/apache/arrow\ncd arrow/r\nR CMD INSTALL .\n```\n\nIf you don't already have the Arrow C++ libraries on your system,\nwhen installing the R package from source, it will also download and build\nthe Arrow C++ libraries for you. To speed installation up, you can set\n\n```shell\nexport LIBARROW_BINARY=true\n```\n\nto look for C++ binaries prebuilt for your Linux distribution/version.\nAlternatively, you can set\n\n```shell\nexport LIBARROW_MINIMAL=false\n```\n\nto build the Arrow libraries with optional features such as compression libraries\nenabled. This will increase the build time but provides many useful features.\nPrebuilt binaries are built with this flag enabled, so you get the full\nfunctionality by using them as well.\n\nBoth of these variables are also set this way if you have the `NOT_CRAN=true`\nenvironment variable set.\n\nIf you already have `arrow` installed and want to upgrade to a different version,\ninstall a development build, or try to reinstall and fix issues with Linux\nC++ binaries, you can call `install_arrow()`.\nThis function is part of the `arrow` package,\nand it is also available as a standalone script, so you can\naccess it for convenience without first installing the package:\n\n```r\nsource(\"https://raw.githubusercontent.com/apache/arrow/master/r/R/install-arrow.R\")\n```\n\n`install_arrow()` will install from CRAN,\nwhile `install_arrow(nightly = TRUE)` will give you a development build.\n`install_arrow()` does not require environment variables to be set in order to\nsatisfy C++ dependencies.\n\n<!-- TODO: does remotes::install_github(\"apache/arrow/r\") work now? -->\n\n# How dependencies are resolved\n\nIn order for the `arrow` R package to work, it needs the Arrow C++ library.\nThere are a number of ways you can get it: a system package; a library you've\nbuilt yourself outside of the context of installing the R package;\nor, if you don't already have it, the R package will attempt to resolve it\nautomatically when it installs.\n\nIf you are authorized to install system packages and you're installing a CRAN release,\nyou may want to use the official Apache Arrow release packages corresponding to the R package version.\nSee the [Arrow project installation page](https://arrow.apache.org/install/)\nto find pre-compiled binary packages for some common Linux distributions,\nincluding Debian, Ubuntu, and CentOS.\nYou'll need to install `libparquet-dev` on Debian and Ubuntu, or `parquet-devel` on CentOS.\nThis will also automatically install the Arrow C++ library as a dependency.\n\nWhen you install the `arrow` R package on Linux,\nit will first attempt to find the Arrow C++ libraries on your system using\nthe `pkg-config` command.\nThis will find either installed system packages or libraries you've built yourself.\nIn order for `install.packages(\"arrow\")` to work with these system packages,\nyou'll need to install them before installing the R package.\n\nIf no Arrow C++ libraries are found on the system,\nthe R package installation script will next attempt to download\nprebuilt static Arrow C++ libraries\nthat match your both your local operating system and `arrow` R package version.\nC++ libraries (source or binary) will only be retrieved if you have set the environment variable\n`LIBARROW_BINARY` or `NOT_CRAN`.\nIf found, they will be downloaded and bundled when your R package compiles.\nFor a list of supported distributions and versions,\nsee the [arrow-r-nightly](https://github.com/ursa-labs/arrow-r-nightly/blob/master/README.md) project.\n\nIf no binary is found, it will download the Arrow C++ source that matches the R package version\n(CRAN release or nightly build) and attempt to build it locally.\nIf no matching source bundle is found, it will also look to see if you are in\na checkout of the `apache/arrow` git repository and thus have the C++ source there.\nDepending on your system, building Arrow C++ from source likely will be slow;\nconsequently, it is designed to happen only when you\nrun `install.packages(\"arrow\")` or `R CMD INSTALL` but not when running `R CMD check`,\nunless you've set the `NOT_CRAN=true` environment variable.\n\nFor the mechanics of how all this works, see the R package `configure` script,\nwhich calls `tools/linuxlibs.R`.\nIf the C++ library is built from source, `inst/build_arrow_static.sh` is executed.\nThis build script is also what is used to generate the prebuilt binaries.\n\n# Troubleshooting and additional options\n\nThe intent is that `install.packages(\"arrow\")` will just work and handle all C++\ndependencies, but depending on your system, you may have better results if you\ntune one of several parameters. Here are some known complications and ways to address them.\n\n## Package installed without C++ dependencies\n\nIf you get an error like\n\n```\nCannot call io___MemoryMappedFile__Open(). Please use arrow::install_arrow() to install required runtime libraries.\n```\n\nfor every `arrow` function you call,\nthat means that installing the package failed to retrieve or build C++ libraries\ncompatible with the current version of the R package. `install_arrow()` provides\nsome convenience wrappers around the various environment variables described below\nand has defaults that should isolate the package installation and make it\nmore likely to succeed. See its help page for details.\n\nAs of version 0.17, it is expected that C++ dependencies should be built successfully\non all Linux distributions, so if you see this message because the C++ libraries\nerrored while building,\nplease [report an issue](https://issues.apache.org/jira/projects/ARROW/issues).\n\n## Using system libraries\n\nIf a system library or other installed Arrow is found but it doesn't match the R package version\n(for example, you have libarrow 0.14 on your system and are installing R package 0.15.1),\nit is likely that the R bindings will fail to compile.\nBecause the Apache Arrow project is under active development,\nis it essential that versions of the C++ and R libraries match.\nWhen `install.packages(\"arrow\")` has to download the C++ libraries,\nthe install script ensures that you fetch the C++ libraries that correspond to your R package version.\nHowever, if you are using Arrow libraries already on your system, version match isn't guaranteed.\n\nTo fix version mismatch, you can either update your system packages to match the R package version,\nor set the environment variable `ARROW_USE_PKG_CONFIG=FALSE`\nto tell the configure script not to look for system Arrow packages.\n(The latter is the default of `install_arrow()`.)\nSystem packages are available corresponding to all CRAN releases\nbut not for nightly or dev versions, so depending on the R package version you're installing,\nsystem packages may not be an option.\n\nNote also that once you have a working R package installation based on system (shared) libraries,\nif you update your system Arrow, you'll need to reinstall the R package to match its version.\nSimilarly, if you're using Arrow system libraries, running `update.packages()`\nafter a new release of the `arrow` package will likely fail unless you first\nupdate the system packages.\n\n## Using a local Arrow C++ build\n\nIf you've built the Arrow C++ libraries locally from source\nbut haven't installed them where `pkg-config` will find them,\nthere are a few options for telling the R package how to locate them.\nYou can set `PKG_CONFIG_PATH` to `/path/to/your/installation/pkgconfig`\n(that is, `PKG_CONFIG_PATH=${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}/pkgconfig`,\nif you've set those variables).\nAlternatively, you can set the `INCLUDE_DIR` and `LIB_DIR` environment variables\nto point to their location.\n\nIf the package fails to install/load with an error like this:\n\n```\n** testing if installed package can be loaded from temporary location\nError: package or namespace load failed for 'arrow' in dyn.load(file, DLLpath = DLLpath, ...):\nunable to load shared object '/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so':\ndlopen(/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so, 6): Library not loaded: @rpath/libarrow.14.dylib\n```\n\ntry setting the environment variable `R_LD_LIBRARY_PATH` to wherever Arrow C++\nwas put in `make install`, e.g. `export R_LD_LIBRARY_PATH=/usr/local/lib`, and\nretry installing the R package.\n\n## Using prebuilt binaries\n\nIf the R package finds and downloads a prebuilt binary of the C++ library,\nbut then the `arrow` package can't be loaded, perhaps with \"undefined symbols\" errors,\nplease [report an issue](https://issues.apache.org/jira/projects/ARROW/issues).\nThis is likely a compiler mismatch and may be resolvable by setting some\nenvironment variables to instruct R to compile the packages to match the C++ library.\n\nA workaround would be to set the environment variable `LIBARROW_BINARY=FALSE`\nand retry installation: this value instructs the package to build the C++ library from source\ninstead of downloading the prebuilt binary.\nThat should guarantee that the compiler settings match.\n\nIf a prebuilt binary wasn't found for your operating system but you think it should have been,\ncheck the logs for a message that says `*** Unable to identify current OS/version`,\nor a message that says `*** No C++ binaries found for` an invalid OS.\nIf you see either, please [report an issue](https://issues.apache.org/jira/projects/ARROW/issues).\nYou may also set the environment variable `ARROW_R_DEV=TRUE` for additional\ndebug messages.\n\nA workaround would be to set the environment variable `LIBARROW_BINARY`\nto a `distribution-version` that exists in the Ursa Labs repository.\nSetting `LIBARROW_BINARY` is also an option when there's not an exact match\nfor your OS but a similar version would work,\nsuch as if you're on `ubuntu-18.10` and there's only a binary for `ubuntu-18.04`.\n\nIf that workaround works for you, and you believe that it should work for everyone else too,\nyou may propose [adding an entry to this lookup table](https://github.com/ursa-labs/arrow-r-nightly/edit/master/linux/distro-map.csv).\nThis table is checked during the installation process\nand tells the script to use binaries built on a different operating system/version\nbecause they're known to work.\n\n## Building C++ from source\n\nIf building the C++ library from source fails, check the error message.\nThe install script attempts to install any necessary build dependencies,\nbut it's possible that some operating systems may require additional ones.\nYou may be able to install them and retry.\nRegardless, if the C++ library fails to compile,\nplease [report an issue](https://issues.apache.org/jira/projects/ARROW/issues)\nso that we can attempt to improve the script.\n\n## Summary of build environment variables\n\nBy default, these are all unset. All boolean variables are case-insensitive.\n\n* `ARROW_USE_PKG_CONFIG`: If set to `false`, the configure script\n  won't look for Arrow libraries on your system and instead will look to download/build them.\n  Use this if you have a version mismatch between installed system libraries\n  and the version of the R package you're installing.\n* `LIBARROW_DOWNLOAD`: Unless set to `false`, the build script\n  will attempt to download C++ binary or source bundles.\n  If you're in a checkout of the `apache/arrow` git repository\n  and want to build the C++ library from the local source, make this `false`.\n* `LIBARROW_BINARY`: If set to `true`, the script will try to download a binary\n  C++ library built for your operating system.\n  You may also set it to some other string,\n  a related \"distro-version\" that has binaries built that work for your OS.\n  If no binary is found, installation will fall back to building C++\n  dependencies from source.\n* `LIBARROW_BUILD`: If set to `false`, the build script\n  will not attempt to build the C++ from source. This means you will only get\n  a working `arrow` R package if a prebuilt binary is found.\n  Use this if you want to avoid compiling the C++ library, which may be slow\n  and resource-intensive, and ensure that you only use a prebuilt binary.\n* `LIBARROW_MINIMAL`: If set to `false`, the build script\n  will enable some optional features, including compression libraries and the\n  `jemalloc` memory allocator. This will increase the source build time but\n  results in a more fully functional library.\n* `NOT_CRAN`: If this variable is set to `true`, as the `devtools` package does,\n  the build script will set `LIBARROW_BINARY=true` and `LIBARROW_MINIMAL=false`\n  unless those environment variables are already set. This provides for a more\n  complete and fast installation experience for users who already have\n  `NOT_CRAN=true` as part of their workflow, without requiring additional\n  environment variables to be set.\n* `ARROW_R_DEV`: If set to `true`, more verbose messaging will be printed\n  in the build script. This variable also is needed if you're modifying `Rcpp`\n  code in the package: see \"Editing Rcpp code\" in the README.\n* `DEBUG_DIR`: If the C++ library building from source fails (`cmake`),\n  there may be messages telling you to check some log file in the build directory.\n  However, when the library is built during R package installation,\n  that location is in a temp directory that is already deleted.\n  To capture those logs, set this variable to an absolute (not relative) path\n  and the log files will be copied there.\n  The directory will be created if it does not exist.\n\n# Contributing\n\nAs mentioned above, please [report an issue](https://issues.apache.org/jira/projects/ARROW/issues)\nif you encounter ways to improve this. If you find that your Linux distribution\nor version is not supported, we welcome the contribution of Docker images\n(hosted on Docker Hub) that we can use in our continuous integration. These\nDocker images should be minimal, containing only R and the dependencies it\nrequires. (For reference, see the images that\n[R-hub](https://github.com/r-hub/rhub-linux-builders) uses.)\n\nYou can test the `arrow` R package installation using the `docker-compose`\nsetup included in the `apache/arrow` git repository. For example,\n\n```\nR_ORG=rhub R_IMAGE=ubuntu-gcc-release R_TAG=latest docker-compose build r\nR_ORG=rhub R_IMAGE=ubuntu-gcc-release R_TAG=latest docker-compose run r\n```\n\ninstalls the `arrow` R package, including the C++ source build, on the\n[rhub/ubuntu-gcc-release](https://hub.docker.com/r/rhub/ubuntu-gcc-release)\nimage.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/ruby/red-arrow/image/red-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/ruby/red-arrow/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/c_glib/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/decimal.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/orc/decimal.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.some-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.column-metadata-handling.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.all-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/r/inst/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/docs/source/format/Arrow.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/docs/source/format/Arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.17.1-cyeiojaiwlcxllnnzds7njgsyx56nnom/spack-src/csharp/ApacheArrow.snk"
    ],
    "total_files": 4381
}