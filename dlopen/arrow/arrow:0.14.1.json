{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/cpp/src/arrow/io/hdfs-internal.cc": "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// This shim interface to libhdfs (for runtime shared library loading) has been\n// adapted from the SFrame project, released under the ASF-compatible 3-clause\n// BSD license\n//\n// Using this required having the $JAVA_HOME and $HADOOP_HOME environment\n// variables set, so that libjvm and libhdfs can be located easily\n\n// Copyright (C) 2015 Dato, Inc.\n// All rights reserved.\n//\n// This software may be modified and distributed under the terms\n// of the BSD license. See the LICENSE file for details.\n\n#include \"arrow/io/hdfs-internal.h\"\n\n#include <cstdint>\n#include <cstdlib>\n#include <mutex>\n#include <sstream>  // IWYU pragma: keep\n#include <string>\n#include <vector>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#endif\n\n#include <boost/filesystem.hpp>  // NOLINT\n\n#include \"arrow/status.h\"\n#include \"arrow/util/logging.h\"\n\nnamespace fs = boost::filesystem;\n\n#ifndef _WIN32\nstatic void* libjvm_handle = NULL;\n#else\nstatic HINSTANCE libjvm_handle = NULL;\n#endif\n/*\n * All the shim pointers\n */\n\n// Helper functions for dlopens\nstatic std::vector<fs::path> get_potential_libjvm_paths();\nstatic std::vector<fs::path> get_potential_libhdfs_paths();\nstatic std::vector<fs::path> get_potential_libhdfs3_paths();\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n#ifndef _WIN32\n                                void*& out_handle);\n#else\n                                HINSTANCE& out_handle);\n#endif\n\nstatic std::vector<fs::path> get_potential_libhdfs_paths() {\n  std::vector<fs::path> libhdfs_potential_paths;\n  std::string file_name;\n\n// OS-specific file name\n#ifdef _WIN32\n  file_name = \"hdfs.dll\";\n#elif __APPLE__\n  file_name = \"libhdfs.dylib\";\n#else\n  file_name = \"libhdfs.so\";\n#endif\n\n  // Common paths\n  std::vector<fs::path> search_paths = {fs::path(\"\"), fs::path(\".\")};\n\n  // Path from environment variable\n  const char* hadoop_home = std::getenv(\"HADOOP_HOME\");\n  if (hadoop_home != nullptr) {\n    auto path = fs::path(hadoop_home) / \"lib/native\";\n    search_paths.push_back(path);\n  }\n\n  const char* libhdfs_dir = std::getenv(\"ARROW_LIBHDFS_DIR\");\n  if (libhdfs_dir != nullptr) {\n    search_paths.push_back(fs::path(libhdfs_dir));\n  }\n\n  // All paths with file name\n  for (auto& path : search_paths) {\n    libhdfs_potential_paths.push_back(path / file_name);\n  }\n\n  return libhdfs_potential_paths;\n}\n\nstatic std::vector<fs::path> get_potential_libhdfs3_paths() {\n  std::vector<fs::path> potential_paths;\n  std::string file_name;\n\n// OS-specific file name\n#ifdef _WIN32\n  file_name = \"hdfs3.dll\";\n#elif __APPLE__\n  file_name = \"libhdfs3.dylib\";\n#else\n  file_name = \"libhdfs3.so\";\n#endif\n\n  // Common paths\n  std::vector<fs::path> search_paths = {fs::path(\"\"), fs::path(\".\")};\n\n  const char* libhdfs3_dir = std::getenv(\"ARROW_LIBHDFS3_DIR\");\n  if (libhdfs3_dir != nullptr) {\n    search_paths.push_back(fs::path(libhdfs3_dir));\n  }\n\n  // All paths with file name\n  for (auto& path : search_paths) {\n    potential_paths.push_back(path / file_name);\n  }\n\n  return potential_paths;\n}\n\nstatic std::vector<fs::path> get_potential_libjvm_paths() {\n  std::vector<fs::path> libjvm_potential_paths;\n\n  std::vector<fs::path> search_prefixes;\n  std::vector<fs::path> search_suffixes;\n  std::string file_name;\n\n// From heuristics\n#ifdef __WIN32\n  search_prefixes = {\"\"};\n  search_suffixes = {\"/jre/bin/server\", \"/bin/server\"};\n  file_name = \"jvm.dll\";\n#elif __APPLE__\n  search_prefixes = {\"\"};\n  search_suffixes = {\"\", \"/jre/lib/server\", \"/lib/server\"};\n  file_name = \"libjvm.dylib\";\n\n// SFrame uses /usr/libexec/java_home to find JAVA_HOME; for now we are\n// expecting users to set an environment variable\n#else\n  search_prefixes = {\n      \"/usr/lib/jvm/default-java\",                // ubuntu / debian distros\n      \"/usr/lib/jvm/java\",                        // rhel6\n      \"/usr/lib/jvm\",                             // centos6\n      \"/usr/lib64/jvm\",                           // opensuse 13\n      \"/usr/local/lib/jvm/default-java\",          // alt ubuntu / debian distros\n      \"/usr/local/lib/jvm/java\",                  // alt rhel6\n      \"/usr/local/lib/jvm\",                       // alt centos6\n      \"/usr/local/lib64/jvm\",                     // alt opensuse 13\n      \"/usr/local/lib/jvm/java-7-openjdk-amd64\",  // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-7-openjdk-amd64\",        // alt ubuntu / debian distros\n      \"/usr/local/lib/jvm/java-6-openjdk-amd64\",  // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-6-openjdk-amd64\",        // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-7-oracle\",               // alt ubuntu\n      \"/usr/lib/jvm/java-8-oracle\",               // alt ubuntu\n      \"/usr/lib/jvm/java-6-oracle\",               // alt ubuntu\n      \"/usr/local/lib/jvm/java-7-oracle\",         // alt ubuntu\n      \"/usr/local/lib/jvm/java-8-oracle\",         // alt ubuntu\n      \"/usr/local/lib/jvm/java-6-oracle\",         // alt ubuntu\n      \"/usr/lib/jvm/default\",                     // alt centos\n      \"/usr/java/latest\",                         // alt centos\n  };\n  search_suffixes = {\"\", \"/jre/lib/amd64/server\", \"/lib/amd64/server\"};\n  file_name = \"libjvm.so\";\n#endif\n  // From direct environment variable\n  char* env_value = NULL;\n  if ((env_value = getenv(\"JAVA_HOME\")) != NULL) {\n    search_prefixes.insert(search_prefixes.begin(), env_value);\n  }\n\n  // Generate cross product between search_prefixes, search_suffixes, and file_name\n  for (auto& prefix : search_prefixes) {\n    for (auto& suffix : search_suffixes) {\n      auto path = (fs::path(prefix) / fs::path(suffix) / fs::path(file_name));\n      libjvm_potential_paths.push_back(path);\n    }\n  }\n\n  return libjvm_potential_paths;\n}\n\n#ifndef _WIN32\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n                                void*& out_handle) {\n  std::vector<std::string> error_messages;\n\n  for (auto& i : potential_paths) {\n    i.make_preferred();\n    out_handle = dlopen(i.native().c_str(), RTLD_NOW | RTLD_LOCAL);\n\n    if (out_handle != NULL) {\n      // std::cout << \"Loaded \" << i << std::endl;\n      break;\n    } else {\n      const char* err_msg = dlerror();\n      if (err_msg != NULL) {\n        error_messages.push_back(std::string(err_msg));\n      } else {\n        error_messages.push_back(std::string(\" returned NULL\"));\n      }\n    }\n  }\n\n  if (out_handle == NULL) {\n    return arrow::Status::IOError(\"Unable to load \", name);\n  }\n\n  return arrow::Status::OK();\n}\n\n#else\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n                                HINSTANCE& out_handle) {\n  std::vector<std::string> error_messages;\n\n  for (auto& i : potential_paths) {\n    i.make_preferred();\n    out_handle = LoadLibrary(i.string().c_str());\n\n    if (out_handle != NULL) {\n      break;\n    } else {\n      // error_messages.push_back(get_last_err_str(GetLastError()));\n    }\n  }\n\n  if (out_handle == NULL) {\n    return arrow::Status::IOError(\"Unable to load \", name);\n  }\n\n  return arrow::Status::OK();\n}\n#endif  // _WIN32\n\nstatic inline void* GetLibrarySymbol(void* handle, const char* symbol) {\n  if (handle == NULL) return NULL;\n#ifndef _WIN32\n  return dlsym(handle, symbol);\n#else\n\n  void* ret = reinterpret_cast<void*>(\n      GetProcAddress(reinterpret_cast<HINSTANCE>(handle), symbol));\n  if (ret == NULL) {\n    // logstream(LOG_INFO) << \"GetProcAddress error: \"\n    //                     << get_last_err_str(GetLastError()) << std::endl;\n  }\n  return ret;\n#endif\n}\n\n#define GET_SYMBOL_REQUIRED(SHIM, SYMBOL_NAME)                         \\\n  do {                                                                 \\\n    if (!SHIM->SYMBOL_NAME) {                                          \\\n      *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =                  \\\n          GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME);             \\\n    }                                                                  \\\n    if (!SHIM->SYMBOL_NAME)                                            \\\n      return Status::IOError(\"Getting symbol \" #SYMBOL_NAME \"failed\"); \\\n  } while (0)\n\n#define GET_SYMBOL(SHIM, SYMBOL_NAME)                    \\\n  if (!SHIM->SYMBOL_NAME) {                              \\\n    *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =      \\\n        GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME); \\\n  }\n\nnamespace arrow {\nnamespace io {\nnamespace internal {\n\nstatic LibHdfsShim libhdfs_shim;\nstatic LibHdfsShim libhdfs3_shim;\n\nhdfsBuilder* LibHdfsShim::NewBuilder(void) { return this->hdfsNewBuilder(); }\n\nvoid LibHdfsShim::BuilderSetNameNode(hdfsBuilder* bld, const char* nn) {\n  this->hdfsBuilderSetNameNode(bld, nn);\n}\n\nvoid LibHdfsShim::BuilderSetNameNodePort(hdfsBuilder* bld, tPort port) {\n  this->hdfsBuilderSetNameNodePort(bld, port);\n}\n\nvoid LibHdfsShim::BuilderSetUserName(hdfsBuilder* bld, const char* userName) {\n  this->hdfsBuilderSetUserName(bld, userName);\n}\n\nvoid LibHdfsShim::BuilderSetKerbTicketCachePath(hdfsBuilder* bld,\n                                                const char* kerbTicketCachePath) {\n  this->hdfsBuilderSetKerbTicketCachePath(bld, kerbTicketCachePath);\n}\n\nvoid LibHdfsShim::BuilderSetForceNewInstance(hdfsBuilder* bld) {\n  this->hdfsBuilderSetForceNewInstance(bld);\n}\n\nhdfsFS LibHdfsShim::BuilderConnect(hdfsBuilder* bld) {\n  return this->hdfsBuilderConnect(bld);\n}\n\nint LibHdfsShim::BuilderConfSetStr(hdfsBuilder* bld, const char* key, const char* val) {\n  return this->hdfsBuilderConfSetStr(bld, key, val);\n}\n\nint LibHdfsShim::Disconnect(hdfsFS fs) { return this->hdfsDisconnect(fs); }\n\nhdfsFile LibHdfsShim::OpenFile(hdfsFS fs, const char* path, int flags, int bufferSize,\n                               short replication, tSize blocksize) {  // NOLINT\n  return this->hdfsOpenFile(fs, path, flags, bufferSize, replication, blocksize);\n}\n\nint LibHdfsShim::CloseFile(hdfsFS fs, hdfsFile file) {\n  return this->hdfsCloseFile(fs, file);\n}\n\nint LibHdfsShim::Exists(hdfsFS fs, const char* path) {\n  return this->hdfsExists(fs, path);\n}\n\nint LibHdfsShim::Seek(hdfsFS fs, hdfsFile file, tOffset desiredPos) {\n  return this->hdfsSeek(fs, file, desiredPos);\n}\n\ntOffset LibHdfsShim::Tell(hdfsFS fs, hdfsFile file) { return this->hdfsTell(fs, file); }\n\ntSize LibHdfsShim::Read(hdfsFS fs, hdfsFile file, void* buffer, tSize length) {\n  return this->hdfsRead(fs, file, buffer, length);\n}\n\nbool LibHdfsShim::HasPread() {\n  GET_SYMBOL(this, hdfsPread);\n  return this->hdfsPread != nullptr;\n}\n\ntSize LibHdfsShim::Pread(hdfsFS fs, hdfsFile file, tOffset position, void* buffer,\n                         tSize length) {\n  GET_SYMBOL(this, hdfsPread);\n  DCHECK(this->hdfsPread);\n  return this->hdfsPread(fs, file, position, buffer, length);\n}\n\ntSize LibHdfsShim::Write(hdfsFS fs, hdfsFile file, const void* buffer, tSize length) {\n  return this->hdfsWrite(fs, file, buffer, length);\n}\n\nint LibHdfsShim::Flush(hdfsFS fs, hdfsFile file) { return this->hdfsFlush(fs, file); }\n\nint LibHdfsShim::Available(hdfsFS fs, hdfsFile file) {\n  GET_SYMBOL(this, hdfsAvailable);\n  if (this->hdfsAvailable)\n    return this->hdfsAvailable(fs, file);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Copy(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsCopy);\n  if (this->hdfsCopy)\n    return this->hdfsCopy(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Move(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsMove);\n  if (this->hdfsMove)\n    return this->hdfsMove(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Delete(hdfsFS fs, const char* path, int recursive) {\n  return this->hdfsDelete(fs, path, recursive);\n}\n\nint LibHdfsShim::Rename(hdfsFS fs, const char* oldPath, const char* newPath) {\n  GET_SYMBOL(this, hdfsRename);\n  if (this->hdfsRename)\n    return this->hdfsRename(fs, oldPath, newPath);\n  else\n    return 0;\n}\n\nchar* LibHdfsShim::GetWorkingDirectory(hdfsFS fs, char* buffer, size_t bufferSize) {\n  GET_SYMBOL(this, hdfsGetWorkingDirectory);\n  if (this->hdfsGetWorkingDirectory) {\n    return this->hdfsGetWorkingDirectory(fs, buffer, bufferSize);\n  } else {\n    return NULL;\n  }\n}\n\nint LibHdfsShim::SetWorkingDirectory(hdfsFS fs, const char* path) {\n  GET_SYMBOL(this, hdfsSetWorkingDirectory);\n  if (this->hdfsSetWorkingDirectory) {\n    return this->hdfsSetWorkingDirectory(fs, path);\n  } else {\n    return 0;\n  }\n}\n\nint LibHdfsShim::MakeDirectory(hdfsFS fs, const char* path) {\n  return this->hdfsCreateDirectory(fs, path);\n}\n\nint LibHdfsShim::SetReplication(hdfsFS fs, const char* path, int16_t replication) {\n  GET_SYMBOL(this, hdfsSetReplication);\n  if (this->hdfsSetReplication) {\n    return this->hdfsSetReplication(fs, path, replication);\n  } else {\n    return 0;\n  }\n}\n\nhdfsFileInfo* LibHdfsShim::ListDirectory(hdfsFS fs, const char* path, int* numEntries) {\n  return this->hdfsListDirectory(fs, path, numEntries);\n}\n\nhdfsFileInfo* LibHdfsShim::GetPathInfo(hdfsFS fs, const char* path) {\n  return this->hdfsGetPathInfo(fs, path);\n}\n\nvoid LibHdfsShim::FreeFileInfo(hdfsFileInfo* hdfsFileInfo, int numEntries) {\n  this->hdfsFreeFileInfo(hdfsFileInfo, numEntries);\n}\n\nchar*** LibHdfsShim::GetHosts(hdfsFS fs, const char* path, tOffset start,\n                              tOffset length) {\n  GET_SYMBOL(this, hdfsGetHosts);\n  if (this->hdfsGetHosts) {\n    return this->hdfsGetHosts(fs, path, start, length);\n  } else {\n    return NULL;\n  }\n}\n\nvoid LibHdfsShim::FreeHosts(char*** blockHosts) {\n  GET_SYMBOL(this, hdfsFreeHosts);\n  if (this->hdfsFreeHosts) {\n    this->hdfsFreeHosts(blockHosts);\n  }\n}\n\ntOffset LibHdfsShim::GetDefaultBlockSize(hdfsFS fs) {\n  GET_SYMBOL(this, hdfsGetDefaultBlockSize);\n  if (this->hdfsGetDefaultBlockSize) {\n    return this->hdfsGetDefaultBlockSize(fs);\n  } else {\n    return 0;\n  }\n}\n\ntOffset LibHdfsShim::GetCapacity(hdfsFS fs) { return this->hdfsGetCapacity(fs); }\n\ntOffset LibHdfsShim::GetUsed(hdfsFS fs) { return this->hdfsGetUsed(fs); }\n\nint LibHdfsShim::Chown(hdfsFS fs, const char* path, const char* owner,\n                       const char* group) {\n  return this->hdfsChown(fs, path, owner, group);\n}\n\nint LibHdfsShim::Chmod(hdfsFS fs, const char* path, short mode) {  // NOLINT\n  return this->hdfsChmod(fs, path, mode);\n}\n\nint LibHdfsShim::Utime(hdfsFS fs, const char* path, tTime mtime, tTime atime) {\n  GET_SYMBOL(this, hdfsUtime);\n  if (this->hdfsUtime) {\n    return this->hdfsUtime(fs, path, mtime, atime);\n  } else {\n    return 0;\n  }\n}\n\nStatus LibHdfsShim::GetRequiredSymbols() {\n  GET_SYMBOL_REQUIRED(this, hdfsNewBuilder);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNode);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNodePort);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetUserName);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetKerbTicketCachePath);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetForceNewInstance);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConfSetStr);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConnect);\n  GET_SYMBOL_REQUIRED(this, hdfsCreateDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsDelete);\n  GET_SYMBOL_REQUIRED(this, hdfsDisconnect);\n  GET_SYMBOL_REQUIRED(this, hdfsExists);\n  GET_SYMBOL_REQUIRED(this, hdfsFreeFileInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsGetCapacity);\n  GET_SYMBOL_REQUIRED(this, hdfsGetUsed);\n  GET_SYMBOL_REQUIRED(this, hdfsGetPathInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsListDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsChown);\n  GET_SYMBOL_REQUIRED(this, hdfsChmod);\n\n  // File methods\n  GET_SYMBOL_REQUIRED(this, hdfsCloseFile);\n  GET_SYMBOL_REQUIRED(this, hdfsFlush);\n  GET_SYMBOL_REQUIRED(this, hdfsOpenFile);\n  GET_SYMBOL_REQUIRED(this, hdfsRead);\n  GET_SYMBOL_REQUIRED(this, hdfsSeek);\n  GET_SYMBOL_REQUIRED(this, hdfsTell);\n  GET_SYMBOL_REQUIRED(this, hdfsWrite);\n\n  return Status::OK();\n}\n\nStatus ConnectLibHdfs(LibHdfsShim** driver) {\n  static std::mutex lock;\n  std::lock_guard<std::mutex> guard(lock);\n\n  LibHdfsShim* shim = &libhdfs_shim;\n\n  static bool shim_attempted = false;\n  if (!shim_attempted) {\n    shim_attempted = true;\n\n    shim->Initialize();\n\n    std::vector<fs::path> libjvm_potential_paths = get_potential_libjvm_paths();\n    RETURN_NOT_OK(try_dlopen(libjvm_potential_paths, \"libjvm\", libjvm_handle));\n\n    std::vector<fs::path> libhdfs_potential_paths = get_potential_libhdfs_paths();\n    RETURN_NOT_OK(try_dlopen(libhdfs_potential_paths, \"libhdfs\", shim->handle));\n  } else if (shim->handle == nullptr) {\n    return Status::IOError(\"Prior attempt to load libhdfs failed\");\n  }\n\n  *driver = shim;\n  return shim->GetRequiredSymbols();\n}\n\nStatus ConnectLibHdfs3(LibHdfsShim** driver) {\n  static std::mutex lock;\n  std::lock_guard<std::mutex> guard(lock);\n\n  LibHdfsShim* shim = &libhdfs3_shim;\n\n  static bool shim_attempted = false;\n  if (!shim_attempted) {\n    shim_attempted = true;\n\n    shim->Initialize();\n\n    std::vector<fs::path> libhdfs3_potential_paths = get_potential_libhdfs3_paths();\n    RETURN_NOT_OK(try_dlopen(libhdfs3_potential_paths, \"libhdfs3\", shim->handle));\n  } else if (shim->handle == nullptr) {\n    return Status::IOError(\"Prior attempt to load libhdfs3 failed\");\n  }\n\n  *driver = shim;\n  return shim->GetRequiredSymbols();\n}\n\n}  // namespace internal\n}  // namespace io\n}  // namespace arrow\n",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/r/README.Rmd": "---\noutput:\n  github_document:\n    html_preview: false\n---\n\n<!-- README.md is generated from README.Rmd. Please edit that file -->\n\n```{r setup, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n# arrow\n\n[![cran](https://www.r-pkg.org/badges/version-last-release/arrow)](https://cran.r-project.org/package=arrow) [![conda-forge](https://img.shields.io/conda/vn/conda-forge/r-arrow.svg)](https://anaconda.org/conda-forge/r-arrow)\n\n[Apache Arrow](https://arrow.apache.org/) is a cross-language development platform for in-memory data. It specifies a standardized language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic operations on modern hardware. It also provides computational libraries and zero-copy streaming messaging and interprocess communication.\n\nThe `arrow` package exposes an interface to the Arrow C++ library to access many of its features in R. This includes support for working with Parquet (`read_parquet()`, `write_parquet()`) and Feather (`read_feather()`, `write_feather()`) files, as well as lower-level access to Arrow memory and messages.\n\n## Installation\n\nInstall the latest release of `arrow` from CRAN with\n\n```r\ninstall.packages(\"arrow\")\n```\n\nOn macOS and Windows, installing a binary package from CRAN will handle Arrow's C++ dependencies for you. On Linux, you'll need to first install the C++ library. See the [Arrow project installation page](https://arrow.apache.org/install/) for a list of PPAs from which you can obtain it.\n\nIf you install the `arrow` package from source and the C++ library is not found, the R package functions will notify you that Arrow is not available. Call\n\n```r\narrow::install_arrow()\n```\n\nfor version- and platform-specific guidance on installing the Arrow C++ library.\n\n## Example\n\n```{r}\nlibrary(arrow)\nset.seed(24)\n\ntab <- arrow::table(x = 1:10, y = rnorm(10))\ntab$schema\ntab\nas.data.frame(tab)\n```\n\n## Installing a development version\n\nTo use the development version of the R package, you'll need to install it from source, which requires the additional C++ library setup. On macOS, you may install the C++ library using [Homebrew](https://brew.sh/):\n\n```shell\n# For the released version:\nbrew install apache-arrow\n# Or for a development version, you can try:\nbrew install apache-arrow --HEAD\n```\n\nOn Windows, you can download a .zip file with the arrow dependencies from the [rwinlib](https://github.com/rwinlib/arrow/releases) project, and then set the `RWINLIB_LOCAL` environment variable to point to that zip file before installing the `arrow` R package. That project contains released versions of the C++ library; for a development version, Windows users may be able to find a binary by going to the [Apache Arrow project's Appveyor](https://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow), selecting an R job from a recent build, and downloading the `build\\arrow-*.zip` file from the \"Artifacts\" tab.\n\nLinux users can get a released version of the library from our PPAs, as described above. If you need a development version of the C++ library, you will likely need to build it from source. See \"Development\" below.\n\nOnce you have the C++ library, you can install the R package from GitHub using the [`remotes`](https://remotes.r-lib.org/) package. From within an R session,\n\n```r\n# install.packages(\"remotes\") # Or install \"devtools\", which includes remotes\nremotes::install_github(\"apache/arrow/r\")\n```\n\nor if you prefer to stay at the command line,\n\n```shell\nR -e 'remotes::install_github(\"apache/arrow/r\")'\n```\n\nYou can specify a particular commit, branch, or [release](https://github.com/apache/arrow/releases) to install by including a `ref` argument to `install_github()`.\n\n## Developing\n\nIf you need to alter both the Arrow C++ library and the R package code, or if you can't get a binary version of the latest C++ library elsewhere, you'll need to build it from source too.\n\nFirst, clone the repository and install a release build of the C++ library.\n\n```shell\ngit clone https://github.com/apache/arrow.git\nmkdir arrow/cpp/build && cd arrow/cpp/build\ncmake .. -DARROW_PARQUET=ON -DARROW_BOOST_USE_SHARED:BOOL=Off -DARROW_INSTALL_NAME_RPATH=OFF\nmake install\n```\n\nThis likely will require additional system libraries to be installed, the specifics of which are platform dependent. See the [C++ developer guide](https://arrow.apache.org/docs/developers/cpp.html) for details.\n\nOnce you've built the C++ library, you can install the R package and its dependencies, along with additional dev dependencies, from the git checkout:\n\n```shell\ncd ../../r\nR -e 'install.packages(\"devtools\"); devtools::install_dev_deps()'\nR CMD INSTALL .\n```\n\nIf the package fails to install/load with an error like this:\n\n```\n** testing if installed package can be loaded from temporary location\nError: package or namespace load failed for 'arrow' in dyn.load(file, DLLpath = DLLpath, ...):\nunable to load shared object '/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so':\ndlopen(/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so, 6): Library not loaded: @rpath/libarrow.14.dylib\n```\n\ntry setting the environment variable `LD_LIBRARY_PATH` (or `DYLD_LIBRARY_PATH` on macOS) to wherever Arrow C++ was put in `make install`, e.g. `export LD_LIBRARY_PATH=/usr/local/lib`, and retry installing the R package.\n\nFor any other build/configuration challenges, see the [C++ developer guide](https://arrow.apache.org/docs/developers/cpp.html#building).\n\n### Editing Rcpp code\n\nThe `arrow` package uses some customized tools on top of `Rcpp` to prepare its C++ code in `src/`. If you change C++ code in the R package, you will need to set the `ARROW_R_DEV` environment variable to `TRUE` (optionally, add it to your`~/.Renviron` file to persist across sessions) so that the `data-raw/codegen.R` file is used for code generation.\n\nYou'll also need `remotes::install_github(\"romainfrancois/decor\")`.\n\n### Useful functions\n\nWithin an R session, these can help with package development:\n\n```r\ndevtools::load_all() # Load the dev package\ndevtools::test(filter=\"^regexp$\") # Run the test suite, optionally filtering file names\ndevtools::document() # Update roxygen documentation\nrmarkdown::render(\"README.Rmd\") # To rebuild README.md\npkgdown::build_site(run_dont_run=TRUE) # To preview the documentation website\ndevtools::check() # All package checks; see also below\n```\n\nAny of those can be run from the command line by wrapping them in `R -e '$COMMAND'`. There's also a `Makefile` to help with some common tasks from the command line (`make test`, `make doc`, `make clean`, etc.)\n\n### Full package validation\n\n```shell\nR CMD build --keep-empty-dirs .\nR CMD check arrow_*.tar.gz --as-cran --no-manual\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/r/README.md": "\n<!-- README.md is generated from README.Rmd. Please edit that file -->\n\n# arrow\n\n[![cran](https://www.r-pkg.org/badges/version-last-release/arrow)](https://cran.r-project.org/package=arrow)\n[![conda-forge](https://img.shields.io/conda/vn/conda-forge/r-arrow.svg)](https://anaconda.org/conda-forge/r-arrow)\n\n[Apache Arrow](https://arrow.apache.org/) is a cross-language\ndevelopment platform for in-memory data. It specifies a standardized\nlanguage-independent columnar memory format for flat and hierarchical\ndata, organized for efficient analytic operations on modern hardware. It\nalso provides computational libraries and zero-copy streaming messaging\nand interprocess communication.\n\nThe `arrow` package exposes an interface to the Arrow C++ library to\naccess many of its features in R. This includes support for working with\nParquet (`read_parquet()`, `write_parquet()`) and Feather\n(`read_feather()`, `write_feather()`) files, as well as lower-level\naccess to Arrow memory and messages.\n\n## Installation\n\nInstall the latest release of `arrow` from CRAN with\n\n``` r\ninstall.packages(\"arrow\")\n```\n\nOn macOS and Windows, installing a binary package from CRAN will handle\nArrow\u2019s C++ dependencies for you. On Linux, you\u2019ll need to first install\nthe C++ library. See the [Arrow project installation\npage](https://arrow.apache.org/install/) for a list of PPAs from which\nyou can obtain it.\n\nIf you install the `arrow` package from source and the C++ library is\nnot found, the R package functions will notify you that Arrow is not\navailable. Call\n\n``` r\narrow::install_arrow()\n```\n\nfor version- and platform-specific guidance on installing the Arrow C++\nlibrary.\n\n## Example\n\n``` r\nlibrary(arrow)\nset.seed(24)\n\ntab <- arrow::table(x = 1:10, y = rnorm(10))\ntab$schema\n#> arrow::Schema \n#> x: int32\n#> y: double\ntab\n#> arrow::Table\nas.data.frame(tab)\n#>     x            y\n#> 1   1 -0.545880758\n#> 2   2  0.536585304\n#> 3   3  0.419623149\n#> 4   4 -0.583627199\n#> 5   5  0.847460017\n#> 6   6  0.266021979\n#> 7   7  0.444585270\n#> 8   8 -0.466495124\n#> 9   9 -0.848370044\n#> 10 10  0.002311942\n```\n\n## Installing a development version\n\nTo use the development version of the R package, you\u2019ll need to install\nit from source, which requires the additional C++ library setup. On\nmacOS, you may install the C++ library using\n[Homebrew](https://brew.sh/):\n\n``` shell\n# For the released version:\nbrew install apache-arrow\n# Or for a development version, you can try:\nbrew install apache-arrow --HEAD\n```\n\nOn Windows, you can download a .zip file with the arrow dependencies\nfrom the [rwinlib](https://github.com/rwinlib/arrow/releases) project,\nand then set the `RWINLIB_LOCAL` environment variable to point to that\nzip file before installing the `arrow` R package. That project contains\nreleased versions of the C++ library; for a development version, Windows\nusers may be able to find a binary by going to the [Apache Arrow\nproject\u2019s\nAppveyor](https://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow),\nselecting an R job from a recent build, and downloading the\n`build\\arrow-*.zip` file from the \u201cArtifacts\u201d tab.\n\nLinux users can get a released version of the library from our PPAs, as\ndescribed above. If you need a development version of the C++ library,\nyou will likely need to build it from source. See \u201cDevelopment\u201d below.\n\nOnce you have the C++ library, you can install the R package from GitHub\nusing the [`remotes`](https://remotes.r-lib.org/) package. From within\nan R session,\n\n``` r\n# install.packages(\"remotes\") # Or install \"devtools\", which includes remotes\nremotes::install_github(\"apache/arrow/r\")\n```\n\nor if you prefer to stay at the command line,\n\n``` shell\nR -e 'remotes::install_github(\"apache/arrow/r\")'\n```\n\nYou can specify a particular commit, branch, or\n[release](https://github.com/apache/arrow/releases) to install by\nincluding a `ref` argument to `install_github()`.\n\n## Developing\n\nIf you need to alter both the Arrow C++ library and the R package code,\nor if you can\u2019t get a binary version of the latest C++ library\nelsewhere, you\u2019ll need to build it from source too.\n\nFirst, clone the repository and install a release build of the C++\nlibrary.\n\n``` shell\ngit clone https://github.com/apache/arrow.git\nmkdir arrow/cpp/build && cd arrow/cpp/build\ncmake .. -DARROW_PARQUET=ON -DARROW_BOOST_USE_SHARED:BOOL=Off -DARROW_INSTALL_NAME_RPATH=OFF\nmake install\n```\n\nThis likely will require additional system libraries to be installed,\nthe specifics of which are platform dependent. See the [C++ developer\nguide](https://arrow.apache.org/docs/developers/cpp.html) for details.\n\nOnce you\u2019ve built the C++ library, you can install the R package and its\ndependencies, along with additional dev dependencies, from the git\ncheckout:\n\n``` shell\ncd ../../r\nR -e 'install.packages(\"devtools\"); devtools::install_dev_deps()'\nR CMD INSTALL .\n```\n\nIf the package fails to install/load with an error like this:\n\n    ** testing if installed package can be loaded from temporary location\n    Error: package or namespace load failed for 'arrow' in dyn.load(file, DLLpath = DLLpath, ...):\n    unable to load shared object '/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so':\n    dlopen(/Users/you/R/00LOCK-r/00new/arrow/libs/arrow.so, 6): Library not loaded: @rpath/libarrow.14.dylib\n\ntry setting the environment variable `LD_LIBRARY_PATH` (or\n`DYLD_LIBRARY_PATH` on macOS) to wherever Arrow C++ was put in `make\ninstall`, e.g.\u00a0`export LD_LIBRARY_PATH=/usr/local/lib`, and retry\ninstalling the R package.\n\nFor any other build/configuration challenges, see the [C++ developer\nguide](https://arrow.apache.org/docs/developers/cpp.html#building).\n\n### Editing Rcpp code\n\nThe `arrow` package uses some customized tools on top of `Rcpp` to\nprepare its C++ code in `src/`. If you change C++ code in the R package,\nyou will need to set the `ARROW_R_DEV` environment variable to `TRUE`\n(optionally, add it to your`~/.Renviron` file to persist across\nsessions) so that the `data-raw/codegen.R` file is used for code\ngeneration.\n\nYou\u2019ll also need `remotes::install_github(\"romainfrancois/decor\")`.\n\n### Useful functions\n\nWithin an R session, these can help with package development:\n\n``` r\ndevtools::load_all() # Load the dev package\ndevtools::test(filter=\"^regexp$\") # Run the test suite, optionally filtering file names\ndevtools::document() # Update roxygen documentation\nrmarkdown::render(\"README.Rmd\") # To rebuild README.md\npkgdown::build_site(run_dont_run=TRUE) # To preview the documentation website\ndevtools::check() # All package checks; see also below\n```\n\nAny of those can be run from the command line by wrapping them in `R -e\n'$COMMAND'`. There\u2019s also a `Makefile` to help with some common tasks\nfrom the command line (`make test`, `make doc`, `make clean`, etc.)\n\n### Full package validation\n\n``` shell\nR CMD build --keep-empty-dirs .\nR CMD check arrow_*.tar.gz --as-cran --no-manual\n```\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/ruby/red-arrow/image/red-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/ruby/red-arrow/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/c_glib/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/decimal.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/orc/decimal.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.some-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.column-metadata-handling.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.all-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow-inverse-300px.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/native_go_implementation.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/shared.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow-r-spark-transforming.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/20190205-arrow-string.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/20190205-numpy-string.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/turbodbc_arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/simd.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow-r-spark-collecting.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow-r-spark-copying.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/arrow-inverse.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/img/copy.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/speedups0.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/speedups3.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/arrow_object.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/speedups2.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/speedups1.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/site/assets/fast_python_serialization_with_ray_and_arrow/python_object.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/r/inst/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/docs/source/format/Arrow.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/docs/source/format/Arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.14.1-ehmv2hnbbpepbrki5k5nozsnsvvmynii/spack-src/csharp/ApacheArrow.snk"
    ],
    "total_files": 3703
}