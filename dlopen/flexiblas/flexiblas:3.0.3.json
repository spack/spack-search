{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/ISSUES.md": "Issues using FlexiBLAS\n======================\n\nLast Update: Jun 16, 2020\n\nTable of Contents\n-----------------\n\n1. Profiling Numpy/Scipy with linked against FlexiBLAS\n2. CBLAS Tests with ATLAS and MKL\n3. Building software with FlexiBLAS\n4. FlexiBLAS-API is not linked.\n5. Crash with LAPACK interface on IBM Power\n6. CBLAS Interface of BLIS\n\n\n1. Profiling Numpy/Scipy with linked against FlexiBLAS\n------------------------------------------------------\nDue to the default behaviour of Python to open C-API modules with LAZY and local\nbinding, not all FlexiBLAS related symbols are integrated correctly in the\ncurrent address space. The profiling will not count all function calls\ncorrectly. Many of them will be passed directly to the loaded backend bypassing\nthe wrapper interface. Changing Python's default behaviour using\nsys.setdlopenflags may help in this case but it is not guaranteed.\n\nSolution: Compile and link Numpy/SciPy and all related packages against\nfleixblas-profile and load flexiblas-profile again via LD_PRELOAD.\n\n\n2. CBLAS Tests with ATLAS and MKL\n---------------------------------\n\nDue to some diffuclt internals of ATLAS and MKL it is not possible to call\n'make test' for the CBLAS interface if ATLAS or MKL is used as BLAS backend.\n\nSolution: Select Netlib or OpenBLAS to perform those tests.\n\n\n3. Building software with FlexiBLAS\n-----------------------------------\n\nThe configuration systems GNU autotools and CMake sometimes perform some strange\ntests to check if the BLAS libraries are working correctly and if they support\n64 bit integers or not. Therefore it is the best to use the NETLIB backend\ndruing the configuration. This can be easily achieved by setting the FLEXIBLAS\nor the FLEXIBLAS64 environment variable to \"NETLIB\" before starting the\nconfiguration process.\n\n4. FlexiBLAS-API is not linked\n------------------------------\n\nIf the FlexiBLAS-API library is used and the BLAS library is FlexiBLAS than\nlibflexiblas_api is not linked against your code if flexiblas_api comes\nafter flexiblas in the linker command line. The correct order is\n\n    gcc .... -lflexiblas_api -lflexiblas ...\n\nor in general\n\n    gcc .... -lflexiblas_api -lblas ...\n\nin order to avoid problems when switching the BLAS library via `update-alternatives`\nor similar tool. The reason for this behavior is that the flexiblas_api library\nand the flexiblas library have some common symbols which do not get resolved if\nflexiblas_api appear after flexiblas in the linking order.\n\n5. Crash with LAPACK interface on IBM Power\n-------------------------------------------\nIf FlexiBLAS is compiled on the ppc64 or ppc64le with the help of the gcc\ncompiler (up to version 5.4.0 and 6.3.0) most likely it will crash when calling\nan LAPACK function. The reason behind this is a code generation bug inside many\nversion of gcc. It prevents that recursive function calls work over shared\nobject boundaries. More detailed information about this bug can be found in the\nfollowing bug tracker entries:\n* https://bugzilla.redhat.com/show_bug.cgi?id=1420723\n* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79439\n* https://sourceware.org/bugzilla/show_bug.cgi?id=21116\n\nThere are two solution for this problem. On the one hand one can use the PGI\nCompiler Suite for OpenPOWER (the community edition is available at no cost)\nand compile FlexiBLAS using the PGI Compiler. This compiler correctly handles\nthe recursive calls.\n\nOtherwise one can use an gcc from svn. The svn revision need to be at least\nr245930. In the upcoming gcc versions this problem will be fixed.\n\n6. CBLAS Interface of BLIS\n--------------------------\nThe CBLAS wrapper in the BLIS library contains a call to `exit` in its\ncblas_xerbla implementation. This might alter the behavoir of a program and let\nthe CBLAS tests fail. For this reason FlexiBLAS does not load the BLIS-CBLAS\ninterface if it detects the BLIS library.\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/CMakeLists.txt": "PROJECT(FlexiBLAS LANGUAGES C)\nENABLE_LANGUAGE(Fortran)\ncmake_minimum_required(VERSION 3.3.0)\n\nIF (${CMAKE_MAJOR_VERSION} GREATER \"2\")\n\tcmake_policy(SET CMP0054 NEW)\nENDIF()\n\n#\n# FlexiBLAS version setup\n#\nSET(FLEXIBLAS_VERSION \"3.0.3\")\nSET(FLEXIBLAS_VERSION_MAJOR  3)\nSET(FLEXIBLAS_VERSION_MINOR  0)\nSET(FLEXIBLAS_VERSION_PATCH  3)\n\n\n\nSET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/libcscutils/CMakeModules ${PROJECT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\nSET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\nSET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\n\nINCLUDE (CheckFeatureNeeded)\nINCLUDE (PreventInSourceBuilds)\nINCLUDE (PreventInBuildInstalls)\nINCLUDE (CMakeHelpers)\n\n#\n# Options\n#\nOPTION(TESTS \"Enable Tests\" ON)\nOPTION(CBLAS \"Enable CBLAS Interface\" ON )\nOPTION(INTEGER8 \"Use 8 Byte Integer\" OFF)\nOPTION(BUILD_SHARED_LIBS \"Enable Shared Library\" ON)\nOPTION(LAPACK \"Enable LAPACK Support\" ON)\nOPTION(DEV \"Development Build\" OFF)\nOPTION(MKL_CUSTOM \"Build MKL support with Intel MKLs Custom library builder\" OFF)\nOPTION(EXAMPLES \"Build Examples\" ON)\nOPTION(BLAS_AUTO_DETECT \"Enabled the BLAS auto detection during configuration\" ON)\n\nIF (NOT DEFINED FLEXIBLAS_DEFAULT_BLAS)\n    SET(FLEXIBLAS_DEFAULT_BLAS \"NETLIB\")\nELSE()\n    STRING (TOUPPER \"${FLEXIBLAS_DEFAULT_BLAS}\" FLEXIBLAS_DEFAULT_BLAS)\nENDIF()\n\n#\n# build type\n#\nIF( NOT CMAKE_BUILD_TYPE )\n\tSET( CMAKE_BUILD_TYPE \"Release\" )\nENDIF( NOT CMAKE_BUILD_TYPE )\n\nIF ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" )\n\tSET ( DEBUG \"ON\" )\nENDIF ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" )\n\n#\n# Paths\n#\nINCLUDE(GNUInstallDirs)\n\nIF(DEFINED SYSCONFDIR)\n SET(CMAKE_INSTALL_FULL_SYSCONFDIR ${SYSCONFDIR})\nENDIF()\n\nMESSAGE(STATUS \"SYSCONFDIR: ${CMAKE_INSTALL_FULL_SYSCONFDIR}\")\nMESSAGE(STATUS \"LIBDIR:     ${CMAKE_INSTALL_FULL_LIBDIR}\")\nMESSAGE(STATUS \"BINDIR:     ${CMAKE_INSTALL_FULL_BINDIR}\")\nMESSAGE(STATUS \"INCLUDEDIR: ${CMAKE_INSTALL_FULL_INCLUDEDIR}\")\nMESSAGE(STATUS \"MANDIR:     ${CMAKE_INSTALL_FULL_MANDIR}\")\nMESSAGE(STATUS \"Compiler_ID: ${CMAKE_C_COMPILER_ID}\")\nMESSAGE(STATUS \"FCompiler_ID: ${CMAKE_Fortran_COMPILER_ID}\")\n\n#\n# Compiler Settings\n#\nSET(CMAKE_POSITION_INDEPENDENT_CODE ON)\nINCLUDE(CCompilerSettings)\nINCLUDE(FortranCompilerSettings)\n\n\n# Check C Compiler Version\nIF ( CMAKE_C_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_C_COMPILER_VERSION VERSION_LESS \"5.0.0\" )\n\tMESSAGE_COLOR(STATUS COLOR_BOLD_RED \"Your gcc is older than version 5.0.0. LAPACK will be loaded using DEEPBIND\")\n\tADD_DEFINITIONS(-DLAPACK_DEEP_BIND)\nENDIF()\n\nINCLUDE(ccache)\n\n\n\n\n#SET(BUILD_SHARED_LIBS ON)\nSET(LIBS m)\n\nIF ( ${CMAKE_C_COMPILER_ID} STREQUAL \"GNU\")\n\tSET( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=c99\")\nENDIF()\n\nIF (DEBUG STREQUAL ON)\n\tSET( CMAKE_BUILD_TYPE \"Debug\" )\n\tSET ( DEBUG TRUE)\n\tSET( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DDEBUG\")\nENDIF (DEBUG STREQUAL ON )\n\n\n\n\n\n\n\nIF (NOT DEFINED ABI)\n\tIF ( ${CMAKE_Fortran_COMPILER_ID} STREQUAL \"Intel\")\n\t\tSET(ABI \"Intel\" CACHE STRING \"ABI of the Fortran Interface\")\n\tELSEIF ( ${CMAKE_Fortran_COMPILER_ID} STREQUAL \"PGI\" )\n\t\tSET(ABI \"Intel\" CACHE STRING \"ABI of the Fortran Interface\")\n\tELSEIF ( ${CMAKE_Fortran_COMPILER_ID} STREQUAL \"XL\" )\n\t\tSET(ABI \"XL\" CACHE STREQUAL \"ABI of the Fortran Interface\")\n\tELSE()\n\t\tSET(USE_INTERFACE_INTEL FALSE)\n\t\tSET(ABI \"GNU\" CACHE STRING \"ABI of the Fortran Interface\")\n\tENDIF()\nELSE()\n\tIF (NOT ( ABI STREQUAL \"GNU\" OR ABI STREQUAL \"Intel\" OR ABI STREQUAL \"XL\"))\n\t\tMESSAGE(FATAL_ERROR \"ABI must be GNU or Intel\")\n\tENDIF()\nENDIF()\n\nIF ( ABI STREQUAL \"Intel\")\n\tSET(FLEXIBLAS_ABI_INTEL TRUE)\n\tSET(USE_INTERFACE_INTEL TRUE)\nELSEIF ( ABI STREQUAL \"XL\" )\n\tSET(FLEXIBLAS_ABI_IBM TRUE)\nELSE ()\n\tSET (FLEXIBLAS_ABI_GNU TRUE)\n\tSET(USE_INTERFACE_INTEL FALSE)\nENDIF()\n\n# Name Mangling\ninclude(FortranCInterface)\nFortranCInterface_HEADER(${PROJECT_BINARY_DIR}/include/fortran_mangle.h\n\t                 MACRO_NAMESPACE \"FC_\"\n\t\t\t SYMBOL_NAMESPACE \"FC_\")\nFortranCInterface_VERIFY()\n\ninclude(CheckThreadLocal)\n\nIF (DEFINED FALLBACK)\n\tSET (FALLBACK_NAME \"${FALLBACK}\")\nELSE()\n\tSET (FALLBACK_NAME FALSE)\nENDIF()\n\nSET ( INCLUDE_DIR ${INCLUDE_DIR} ${CMAKE_BINARY_DIR}/include ${CMAKE_SOURCE_DIR}/include ${CMAKE_BINARY_DIR} )\n\n\n\n\nLIST(REMOVE_DUPLICATES INCLUDE_DIR)\nIF (APPLE)\n\tSET ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -D_FILE_OFFSET_BITS=64 \")\nELSE()\n\tIF (WIN32)\n\t\tSET ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -D_FILE_OFFSET_BITS=64 -Wall\")\n\tELSE ()\n\t\tSET ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -D_FILE_OFFSET_BITS=64\")\n\t\tIF  ( CMAKE_Fortran_COMPILER_ID STREQUAL \"Intel\" OR CMAKE_Fortran_COMPILER_ID STREQUAL \"GNU\")\n            set (CMAKE_SHARED_LINKER_FLAGS \"-rdynamic -Wl,--export-dynamic\")\n\t\tENDIF()\n\t\t# SET ( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -D_FILE_OFFSET_BITS=64 \")\n\n\tENDIF()\nENDIF()\nSET ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -D_FILE_OFFSET_BITS=64 \")\n\nSET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\n\n\n#\n# Check Some files\n#\nINCLUDE (CheckIncludeFiles)\nIF (WIN32)\n\tMESSAGE(STATUS \"Building Windows Version\" )\n\tIF (MINGW)\n\t\tMESSAGE(STATUS \"Using MingW Compiler\")\n\tENDIF()\n\tSET(DL_LIB \"\")\nELSE()\n\t# CHECK_INCLUDE_FILES (stdatomic.h HAVE_STDATOMIC_H)\n\tCHECK_INCLUDE_FILES (dlfcn.h\t HAVE_DLFCN_H)\n\n\tINCLUDE (CheckSymbolExists)\n\tCHECK_SYMBOL_EXISTS(RTLD_GLOBAL   \"dlfcn.h\" HAVE_RTLD_GLOBAL)\n\tCHECK_SYMBOL_EXISTS(RTLD_DEEPBIND \"dlfcn.h\" HAVE_RTLD_DEEPBIND)\n\tCHECK_SYMBOL_EXISTS(RTLD_NOW\t  \"dlfcn.h\" HAVE_RTLD_NOW)\n\n\tINCLUDE (CheckFunctionExists)\n\tCHECK_FUNCTION_EXISTS(dlopen DLOPEN_C)\n\tSET(__CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n\tSET(CMAKE_REQUIRED_LIBRARIES dl)\n\tCHECK_FUNCTION_EXISTS(dlopen DLOPEN_DL)\n\tSET(CMAKE_REQUIRED_LIBRARIES ${__CMAKE_REQUIRED_LIBRARIES})\n\n\tIF (DLOPEN_DL)\n\t SET(LIBS ${LIBS} dl)\n\t SET(DL_LIB dl)\n\tENDIF()\n\tIF (NOT ( DLOPEN_DL OR DLOPEN_C ) )\n\t MESSAGE(ERROR \"No dlopen function found\")\n\tENDIF()\n\n\tIF ( NOT HAVE_DLFCN_H )\n\t\tMESSAGE(FATAL_ERROR \"dlfcn.h not found, aborting\")\n\tENDIF()\nENDIF()\n\nINCLUDE(CheckAttributeExists)\nCheck_Attribute_Exists( constructor HAVE_ATTR_CONSTRUCTOR)\nCheck_Attribute_Exists( \"alias(\\\"foo\\\")\" HAVE_ATTR_ALIAS)\nCheck_Attribute_Exists( \"visibility(\\\"hidden\\\")\" HAVE_ATTR_HIDDEN)\nCheck_Attribute_Exists( \"visibility(\\\"default\\\")\" HAVE_ATTR_DEFAULT)\nCheck_Attribute_Exists( unused HAVE_ATTR_UNUSED )\nSET(EXTRA_BLAS \"\")\n\n### libcscutils\nSET(CSCUTILS_FEATURES \"inifile;ds\")\nSET(CSCUTILS_OBJECT TRUE)\nadd_subdirectory(libcscutils)\nSET(LIBS ${LIBS})\nSET(INCLUDE_DIR ${INCLUDE_DIR} \"${PROJECT_SOURCE_DIR}/libcscutils/include\" \"${PROJECT_BINARY_DIR}/libcscutils/include\")\n\nIF (CBLAS STREQUAL ON)\n\tADD_DEFINITIONS(-DFLEXIBLAS_CBLAS)\nENDIF()\n\n\n### Setup Integer8 option\nIF ( INTEGER8 STREQUAL ON )\n\tADD_DEFINITIONS(-DINTEGER8)\n\tSET(FLEXIBLAS_INTEGER8 TRUE)\n\tSET(FLEXIBLAS_INCLUDE_PREFIX \"flexiblas64\")\n\tSET(FLEXIBLAS_LIBRARY_DIR \"flexiblas64\")\n\tSET(FLEXIBLAS_PKG_CONFIG \"flexiblas64.pc\")\n    SET(FLEXIBLAS_API_PKG_CONFIG \"flexiblas64_api.pc\")\n\n    set(flexiblasname flexiblas64)\n\tSET (FLEXIBLASRC flexiblas64rc)\n\tSET (FLEXIBLAS_RC \"flexiblas64rc\")\n    SET (FLEXIBLAS_RC_DIR \"flexiblas64rc.d\")\n    SET (FLEXIBLAS_PREFIX \"flexiblas64\")\n\n    IF ( ${CMAKE_C_COMPILER_ID} STREQUAL \"GNU\")\n\t\tMESSAGE(STATUS \"Setting GNU Compiler Flags\")\n\t\tSET(I8_FLAGS \"-fdefault-integer-8 \")\n\tELSEIF (${CMAKE_C_COMPILER_ID} STREQUAL \"Intel\" )\n\t\tSET ( I8_FLAGS \"-i8 \")\n\tELSEIF (${CMAKE_C_COMPILER_ID} STREQUAL \"PGI\" )\n\t\tSET ( I8_FLAGS \"-i8 \")\n\tENDIF()\n\tSET (CMAKE_Fortran_FLAGS \"${CMAKE_Fortran_FLAGS} ${I8_FLAGS}\")\n\nELSE()\n\tSET(FLEXIBLAS_INTEGER8 FALSE)\n\tSET(FLEXIBLAS_INCLUDE_PREFIX \"flexiblas\")\n\tSET(FLEXIBLAS_PKG_CONFIG \"flexiblas.pc\")\n    SET(FLEXIBLAS_API_PKG_CONFIG \"flexiblas_api.pc\")\n\tSET(FLEXIBLAS_LIBRARY_DIR \"flexiblas\")\n\tset(flexiblasname flexiblas)\n\tSET (FLEXIBLASRC flexiblasrc)\n    SET (FLEXIBLAS_RC \"flexiblasrc\")\n    SET (FLEXIBLAS_RC_DIR \"flexiblasrc.d\")\n    SET (FLEXIBLAS_PREFIX \"flexiblas\")\nENDIF (INTEGER8 STREQUAL ON)\nFILE(MAKE_DIRECTORY \"${CMAKE_BINARY_DIR}/${FLEXIBLAS_RC_DIR}\")\n\nIF (DEV STREQUAL ON)\n\tSET ( FLEXIBLAS_DEFAULT_LIB_PATH \"${CMAKE_BINARY_DIR}/lib:${CMAKE_BINARY_DIR}/contributed/netlib-blas:${CMAKE_BINARY_DIR}/contributed/:${CMAKE_BINARY_DIR}/src:\")\n    SET ( CMAKE_INSTALL_FULL_SYSCONFDIR \"${CMAKE_BINARY_DIR}\")\nELSE()\n    SET ( FLEXIBLAS_DEFAULT_LIB_PATH \"${CMAKE_INSTALL_FULL_LIBDIR}/${flexiblasname}/\")\nENDIF()\n\n\n\n# Check for Serveral Functions\nCHECK_FEATURE_NEEDED(strdup string.h HAVE_STRDUP STRDUP_FEATURE)\nIF( HAVE_STRDUP )\n\tADD_DEFINITIONS(\"${STRDUP_FEATURE}\")\nELSE ()\n\tMESSAGE(FATAL_ERROR \"strdup not found\")\nENDIF()\nCHECK_FEATURE_NEEDED(realpath stdlib.h HAVE_REALPATH REALPATH_FEATURE)\nIF( HAVE_REALPATH  )\n\tADD_DEFINITIONS(\"${REALPATH_FEATURE}\")\nELSE ()\n\tMESSAGE(FATAL_ERROR \"realpath not found\")\nENDIF()\n\n### Add Source\n\nIF(NOT SYS_BLAS_LIBRARY)\n    add_subdirectory(contributed/netlib-blas/)\nENDIF()\n\nINCLUDE(lapack)\n\nINCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/src)\n\n\nCONFIGURE_FILE(${CMAKE_SOURCE_DIR}/config.h.in ${CMAKE_BINARY_DIR}/include/flexiblas_config.h)\n\nadd_subdirectory(src)\n\nIF(EXAMPLES STREQUAL \"ON\")\nadd_subdirectory(examples)\nENDIF()\nIF(EXISTS tools/lapack_checks)\nadd_subdirectory(tools/lapack_checks)\nENDIF()\n\n### Install\nINSTALL(FILES   ${CMAKE_CURRENT_BINARY_DIR}/${FLEXIBLASRC} DESTINATION ${CMAKE_INSTALL_FULL_SYSCONFDIR} PERMISSIONS OWNER_WRITE  OWNER_READ  GROUP_READ WORLD_READ )\nINSTALL(FILES   ${CMAKE_SOURCE_DIR}/include/blas_gnu.h\n\t\t${CMAKE_SOURCE_DIR}/include/blas_intel.h\n\t\t${CMAKE_SOURCE_DIR}/include/cblas.h\n\t\t${CMAKE_BINARY_DIR}/include/flexiblas_config.h\n\t\t${CMAKE_BINARY_DIR}/include/fortran_mangle.h\n\t\tDESTINATION ${CMAKE_INSTALL_FULL_INCLUDEDIR}/${FLEXIBLAS_INCLUDE_PREFIX}/)\nIF(LAPACK STREQUAL ON)\n\tINSTALL(FILES   ${CMAKE_BINARY_DIR}/include/lapack.h\n\t\t${CMAKE_BINARY_DIR}/include/flexiblas_real_lapack.h\n\t\tDESTINATION ${CMAKE_INSTALL_FULL_INCLUDEDIR}/${FLEXIBLAS_INCLUDE_PREFIX}/)\n\nENDIF()\nINSTALL(FILES   ${CMAKE_SOURCE_DIR}/src/flexiblas_backend.h\n\t\t${CMAKE_SOURCE_DIR}/src/flexiblas_real_calls.h\n        ${CMAKE_SOURCE_DIR}/src/flexiblas_real_cblas_calls.h\n\t\t${CMAKE_SOURCE_DIR}/src/flexiblas_api.h\n\t\t${CMAKE_SOURCE_DIR}/src/flexiblas_dummy_fortran.h\n\t\t${CMAKE_SOURCE_DIR}/src/flexiblas_dummy_cblas.h\n\t\t${CMAKE_SOURCE_DIR}/src/flexiblas_mgmt.h\n\t\tDESTINATION ${CMAKE_INSTALL_FULL_INCLUDEDIR}/${FLEXIBLAS_INCLUDE_PREFIX}/)\n\nIF(CBLAS STREQUAL ON)\n\tINSTALL(FILES\t${CMAKE_SOURCE_DIR}/include/cblas.h DESTINATION ${CMAKE_INSTALL_FULL_INCLUDEDIR}/${FLEXIBLAS_INCLUDE_PREFIX}/)\nENDIF()\n\nCONFIGURE_FILE(\n  \"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n  IMMEDIATE @ONLY)\nADD_CUSTOM_TARGET(uninstall \"${CMAKE_COMMAND}\" -P \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\")\n\n### Setup PKG_CONFIG\nset(prefix ${CMAKE_INSTALL_PREFIX})\nset(libdir ${CMAKE_INSTALL_FULL_LIBDIR})\nset(PKG_CONFIG_DIR ${CMAKE_INSTALL_FULL_LIBDIR}/pkgconfig)\nset(includedir ${CMAKE_INSTALL_PREFIX}/include/${FLEXIBLAS_INCLUDE_PREFIX}/)\nCONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/flexiblas.pc.in ${CMAKE_CURRENT_BINARY_DIR}/${FLEXIBLAS_PKG_CONFIG})\nCONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/flexiblas_api.pc.in ${CMAKE_CURRENT_BINARY_DIR}/${FLEXIBLAS_API_PKG_CONFIG})\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${FLEXIBLAS_PKG_CONFIG}  DESTINATION ${PKG_CONFIG_DIR} )\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${FLEXIBLAS_API_PKG_CONFIG}  DESTINATION ${PKG_CONFIG_DIR} )\n\n\n### Setup Man Pages\ninstall(DIRECTORY doc/man/ DESTINATION ${CMAKE_INSTALL_FULL_MANDIR} FILES_MATCHING PATTERN \"*.[1-9]\")\nIF (INTEGER8 STREQUAL ON)\n    install(FILES doc/man/man1/flexiblas.1 DESTINATION ${CMAKE_INSTALL_FULL_MANDIR}/man1/ RENAME flexiblas64.1)\nENDIF()\n\nIF ( TESTS )\n\tMESSAGE( STATUS \"Enable Testing...\")\n\tENABLE_TESTING()\n\tadd_subdirectory(test/blas)\n\tIF ( LAPACK AND (LAPACK_API_VERSION STREQUAL \"3.6.1\" OR LAPACK_API_VERSION STREQUAL \"3.6.1-wodprc\"))\n\t\tFIND_PACKAGE(PythonInterp REQUIRED)\n\t\tadd_subdirectory(test/lapack-3.6.1)\n\tENDIF()\n\tIF ( LAPACK AND (LAPACK_API_VERSION STREQUAL \"3.7.0\" OR LAPACK_API_VERSION STREQUAL \"3.7.0-wodprc\"))\n\t\tFIND_PACKAGE(PythonInterp REQUIRED)\n\t\tadd_subdirectory(test/lapack-3.7.0)\n\tENDIF()\n\tIF ( LAPACK AND (LAPACK_API_VERSION STREQUAL \"3.7.1\" OR LAPACK_API_VERSION STREQUAL \"3.7.1-wodprc\"))\n\t\tFIND_PACKAGE(PythonInterp REQUIRED)\n\t\tadd_subdirectory(test/lapack-3.7.0)\n\tENDIF()\n\tIF ( LAPACK AND (LAPACK_API_VERSION STREQUAL \"3.8.0\" OR LAPACK_API_VERSION STREQUAL \"3.8.0-wodprc\"))\n\t\tFIND_PACKAGE(PythonInterp REQUIRED)\n\t\tadd_subdirectory(test/lapack-3.8.0)\n\tENDIF()\n\n    IF ( LAPACK AND (LAPACK_API_VERSION STREQUAL \"3.9.0\" OR LAPACK_API_VERSION STREQUAL \"3.9.0-wodprc\"))\n\t\tFIND_PACKAGE(PythonInterp REQUIRED)\n\t\tadd_subdirectory(test/lapack-3.9.0)\n\tENDIF()\n\nENDIF (TESTS)\n\n#\n# Final Status\n#\nMESSAGE(STATUS \"------------------------------------------------\")\nMESSAGE(STATUS \"      Final Configuration Status \")\nMESSAGE(STATUS \"------------------------------------------------\")\nMESSAGE(STATUS \"Build 8 byte integer: ${INTEGER8}\")\nMESSAGE(STATUS \"Build CBLAS interface: ${CBLAS}\")\nMESSAGE(STATUS \"Install path: ${CMAKE_INSTALL_PREFIX}\")\nMESSAGE(STATUS \"Extra BLAS search path: ${FLEXIBLAS_DEFAULT_LIB_PATH}\")\nMESSAGE(STATUS \"LAPACK Support: ${LAPACK}\")\nIF(LAPACK)\nMESSAGE(STATUS \"LAPACK_API_VERSION: ${LAPACK_API_VERSION}\")\nENDIF()\nMESSAGE(STATUS \"ABI: ${ABI}\")\nMESSAGE(STATUS \"Interface to Extra BLAS Libraries:\")\nFOREACH(EBLAS ${EXTRA_BLAS})\n    MESSAGE(STATUS \" ${${EBLAS}_BLAS_LIBRARIES} - ${EBLAS} \")\nENDFOREACH()\nMESSAGE(STATUS \"Default BLAS: ${FLEXIBLAS_DEFAULT}\")\nMESSAGE(STATUS \"\")\nMESSAGE(STATUS \"Compiler Options:\")\nMESSAGE(STATUS \" CMAKE_C_FLAGS               = ${CMAKE_C_FLAGS}\")\nMESSAGE(STATUS \" CMAKE_C_FLAGS_RELEASE       = ${CMAKE_C_FLAGS_RELEASE}\")\nMESSAGE(STATUS \" CMAKE_C_FLAGS_DEBUG         = ${CMAKE_C_FLAGS_DEBUG}\")\nMESSAGE(STATUS \" CMAKE_Fortran_FLAGS         = ${CMAKE_Fortran_FLAGS}\")\nMESSAGE(STATUS \" CMAKE_Fortran_FLAGS_RELEASE = ${CMAKE_Fortran_FLAGS_RELEASE}\")\nMESSAGE(STATUS \" CMAKE_Fortran_FLAGS_DEBUG   = ${CMAKE_Fortran_FLAGS_DEBUG}\")\nMESSAGE(STATUS \"------------------------------------------------\")\nIF ( DEV STREQUAL ON )\n\tMESSAGE (WARNING \"- This is an development build and can not be install. Please set add -DDEV=OFF to cmake. -\")\nENDIF()\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/hooks.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <ctype.h>\n\n#include \"cscutils/map.h\"\n\n#include \"flexiblas_backend.h\"\n#include \"hooks.h\"\n#include \"paths.h\"\n#include \"helper.h\"\n\nstatic csc_map_t * hook_map = NULL;\n\n\nHIDDEN void __flexiblas_list_hooks()\n{\n\n    int i ;\n    char *curpath;\n    DIR* folder;\n    struct dirent *dir_entry;\n    size_t len = strlen(\"libflexiblas_hook\");\n    struct stat st;\n    char *curfn;\n    size_t curfnl;\n    void * handle;\n    flexiblas_hook_register_t *reg;\n    flexiblas_option_t *opts;\n\n    for (i = 0; i < __flexiblas_count_additional_paths; i++) {\n        curpath = __flexiblas_additional_paths[i];\n\n        DPRINTF(0,\"Search in: %s\\n\", curpath);\n        folder = opendir(curpath);\n        if (!folder) continue;\n\n        while ((dir_entry = readdir(folder)) != NULL) {\n            if ( strncmp(dir_entry->d_name, \"..\", 2) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \".\", 1) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \"libflexiblas_hook\", len) != 0 ) continue;\n\n            curfnl  = (strlen(curpath) + strlen(dir_entry->d_name) + 5);\n            curfn = malloc(sizeof(char) * curfnl);\n\n            snprintf(curfn, curfnl, \"%s/%s\", curpath, dir_entry->d_name);\n            memset(&st, 0, sizeof(struct stat));\n            if ( stat(curfn, &st)) continue;\n            if ( ! ( S_ISREG(st.st_mode))) continue;\n\n            printf(\"%s\\n\", curfn);\n\n            handle  = __flexiblas_dlopen(curfn, RTLD_LAZY | RTLD_LOCAL , NULL);\n            if ( !handle) continue;\n\n            reg = dlsym(handle,\"flexiblas_register\");\n            if ( !reg ) {\n                DPRINTF(0, \"%s is not a hook\\n\");\n                dlclose(handle);\n                continue;\n            }\n\n            printf(\"Hook %s\\n\", curfn);\n            printf(\"-> Name:     %s\\n\", reg->name);\n            printf(\"-> Cfg-Name: %s\\n\", reg->cfg_name);\n            printf(\"-> Descr:    %s\\n\", reg->desc);\n            printf(\"-> Authors:  %s\\n\", reg->authors);\n\n            opts = dlsym(handle, \"flexiblas_options\");\n            if ( !opts) {\n                dlclose(handle);\n                continue;\n            }\n\n            while ( opts->name != NULL) {\n                printf(\"opts->name: %s\\n\", opts->name);\n                opts = opts + 1;\n\n            }\n\n\n            dlclose(handle);\n        }\n\n        closedir(folder);\n    }\n\n}\n\nstatic char *__struppercase(char *str) {\n\tchar *ret = str;\n\tif ( str == NULL ) return NULL;\n\twhile (*str != '\\0') {\n\t\t*str = toupper(*str);\n\t\tstr++;\n\t}\n\treturn ret;\n}\n\n\nHIDDEN void __flexiblas_add_hooks()\n{\n\n    int i ;\n    char *curpath;\n    DIR* folder;\n    struct dirent *dir_entry;\n    size_t len = strlen(\"libflexiblas_hook\");\n    struct stat st;\n    char *curfn;\n    size_t curfnl;\n    void * handle;\n    flexiblas_hook_register_t *reg;\n\n    hook_map = csc_map_new_string_key(257,free);\n\n    for (i = 0; i < __flexiblas_count_additional_paths; i++) {\n        curpath = __flexiblas_additional_paths[i];\n\n        folder = opendir(curpath);\n        if (!folder) continue;\n\n        while ((dir_entry = readdir(folder)) != NULL) {\n            if ( strncmp(dir_entry->d_name, \"..\", 2) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \".\", 1) == 0 ) continue;\n            if ( strncmp(dir_entry->d_name, \"libflexiblas_hook\", len) != 0 ) continue;\n\n            curfnl  = (strlen(curpath) + strlen(dir_entry->d_name) + 5);\n            curfn = malloc(sizeof(char) * curfnl);\n\n            snprintf(curfn, curfnl, \"%s/%s\", curpath, dir_entry->d_name);\n            memset(&st, 0, sizeof(struct stat));\n            if ( stat(curfn, &st)) continue;\n            if ( ! ( S_ISREG(st.st_mode))) continue;\n\n            handle  = __flexiblas_dlopen(curfn, RTLD_LAZY | RTLD_LOCAL , NULL);\n            if ( !handle) continue;\n\n\n            reg = dlsym(handle,\"flexiblas_register\");\n            if ( !reg ) {\n                DPRINTF(1, \"%s is not a hook\\n\", dir_entry->d_name);\n                dlclose(handle);\n                continue;\n            }\n\n            DPRINTF(1, \"Hook \\\"%s/%s\\\" found in %s\\n\", reg->name, reg->cfg_name, curfn);\n            char * insert_str = __struppercase(strdup(reg->cfg_name));\n            csc_map_insert(hook_map, insert_str, strdup(curfn));\n\n            free(curfn);\n            dlclose(handle);\n        }\n\n        closedir(folder);\n    }\n\n}\n\nHIDDEN char *  __flexiblas_hook_add_from_file(char *path)\n{\n    void * handle;\n    flexiblas_hook_register_t *reg;\n    char *ret;\n\n    handle  = __flexiblas_dlopen(path, RTLD_LAZY | RTLD_LOCAL , NULL);\n    if ( !handle) return NULL;\n\n    reg = dlsym(handle, \"flexiblas_register\");\n    if ( !reg ) return NULL;\n\n    ret = strdup(reg->cfg_name);\n\n    if ( csc_map_has_key(hook_map, reg->cfg_name)) {\n        DPRINTF_WARN(0, \"Hook %s from %s already exists in the configuration.\\n\", reg->cfg_name, path);\n        DPRINTF_WARN(0, \"The previously found hook (%s) will be replaced.\\n\", csc_map_get(hook_map, reg->cfg_name));\n        csc_map_replace(hook_map, reg->cfg_name, strdup(path));\n    } else {\n        csc_map_insert(hook_map, reg->cfg_name, strdup(path));\n    }\n\n    dlclose(handle);\n    return ret;\n}\n\nHIDDEN int __flexiblas_hook_exists(char *name)\n{\n    char *upper_name = __struppercase(strdup(name));\n    int ret = csc_map_has_key(hook_map, (void *) upper_name);\n    free(upper_name);\n    return ret;\n}\n\nHIDDEN char * __flexiblas_hook_sofile(char *name)\n{\n    if (__flexiblas_hook_exists(name)) {\n        return csc_map_get(hook_map, (void *) name);\n    } else {\n        return NULL;\n    }\n}\n\nHIDDEN void __flexiblas_exit_hook( )\n{\n    csc_map_free(hook_map);\n}\n\nHIDDEN void __flexiblas_hook_list(int *nelem, char ***list, char ***list2)\n{\n    int len;\n    char **ilist;\n    char **ilist2;\n    void *iter = NULL;\n    char *key;\n    int i = 0;\n\n    len = csc_map_len(hook_map);\n    ilist = (char * *) malloc(sizeof(char *) * (len));\n    if ( list2 != NULL) {\n        ilist2 = (char * *) malloc(sizeof(char *) * (len));\n    }\n\n    while ( (key = csc_map_iterate_key(hook_map, &iter)) != NULL) {\n        ilist[i] = strdup(key);\n        if (ilist2 !=NULL) {\n            ilist2[i] = strdup(csc_map_get(hook_map, key));\n        }\n        i++;\n    }\n\n    *nelem = len;\n    *list = ilist;\n    if ( list2 ) * list2=ilist2;\n    return;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/sh_utils.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n\n#ifndef _DEFAULT_SOURCE\n#define _DEFAULT_SOURCE\n#endif\n#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 500\n#endif\n\n#include \"flexiblas.h\"\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#ifndef __WIN32__\n#define DLOPEN_FLAGS (RTLD_NOW|RTLD_LOCAL)\n#else\n#define DLOPEN_FLAGS (0)\n#include <windows.h>\n#endif\n\n/*-----------------------------------------------------------------------------\n *  Return true if it is an absolute path.\n *-----------------------------------------------------------------------------*/\nstatic int is_absolute(const char * path )\n{\n\tif ( path == NULL) return 0;\n#ifdef __WIN32__\n\tif (strlen(path) < 2 ) return 0;\n\tif (( tolower(path[0]) >= 'a' && tolower(path[0]) <= 'z' && path[1]==':')\n\t\t\t|| ((path[0] == '\\\\' ) && (path[1] == '\\\\'))) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#else\n\tif ( ((char)path[0]) == '/' ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Return true if it is at least an relative path.\n *-----------------------------------------------------------------------------*/\nstatic int is_relative(const char * path)\n{\n\tif ( path == NULL) return 0;\n    if ( strstr(path,\"/\") != NULL) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int file_exists(const char * path )\n{\n\tstruct stat st_buf;\n\tmemset (&st_buf, 0, sizeof(struct stat));\n\tif ( stat( path, &st_buf) == 0){\n\t\tif ( (S_ISREG(st_buf.st_mode) || S_ISLNK (st_buf.st_mode) )){\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nHIDDEN void * __flexiblas_dlopen( const char *libname, int flags, char ** sofile ){\n\tchar *path = NULL;\n\tchar *filepath = NULL;\n\tsize_t len;\n\tvoid *handle;\n\tint found = 0 ;\n\tint path_count = 0;\n\n    if (libname == NULL) return NULL;\n\n\n\tif ( strstr(libname,\"/\") == NULL ) {\n        for ( path_count = -1 ; path_count < __flexiblas_count_additional_paths; path_count++){\n            if ( path_count == -1 ) {\n                if ( access(libname, R_OK) == 0 ) {\n                    filepath = strdup(libname);\n                } else {\n                    continue;\n                }\n            } else {\n    \t\t\tpath =  __flexiblas_additional_paths[path_count];\n\t    \t\tlen = strlen(path) + strlen(libname) + 5;\n\t\t    \tfilepath = malloc(len * sizeof ( char ));\n\t\t\t    snprintf(filepath, len -1, \"%s/%s\", path, libname);\n            }\n\t\t\tDPRINTF(1, \"Check if shared libary exist: %s\\n\", filepath);\n            if ( file_exists(filepath) ){\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree(filepath);\n\t\t\t\tfilepath = NULL;\n\t\t\t}\n\t\t}\n\t} else if (is_absolute(libname)) {\n\t\tif ( file_exists(libname) ) {\n\t\t\tfound = 1;\n\t\t\tfilepath = strdup( libname);\n\t\t}\n\t} else if ( is_relative(libname)) {\n\t\tlong path_max;\n\t\tchar * resolvepath;\n#ifdef PATH_MAX\n\t\tpath_max = PATH_MAX;\n#else\n\t\tpath_max = pathconf(path, _PC_PATH_MAX);\n\t\tif (path_max <= 0)\n\t\t\tpath_max = 32768;\n#endif\n\t\tresolvepath = calloc(path_max, sizeof(char));\n\n\t\tif ( realpath(libname, resolvepath) == NULL ) {\n\t\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s or file does not exists.\\n\",libname );\n\t\t\tfound = 0;\n\t\t\tif (filepath) free(filepath);\n\t\t\tfilepath = NULL;\n\t\t\tfree(resolvepath);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tfilepath = strdup(resolvepath);\n\t\t\tfree(resolvepath);\n\t\t\t/* DPRINTF_ERROR(2, \"Filepath: %s\\n\",filepath ); */\n\t\t}\n\t\tif (file_exists(filepath) ) {\n\t\t\tfound = 1;\n\t\t}\n\t} else {\n\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s\\n\",libname );\n\n\t\tfound = 0;\n\t\tif (filepath) free(filepath);\n\t\tfilepath = NULL;\n\t}\n\n\n\tif( found ) {\n#ifdef __WIN32__\n\t\thandle = LoadLibrary(filepath);\n#else\n\t\tvoid * ld_flags_sym_global;\n\t\tvoid * ld_flags_sym_lazy;\n\t\tint32_t ld_flags_global;\n\t\tint32_t ld_flags_lazy;\n#ifdef __linux__\n\t\tvoid * ld_flags_sym_deep = NULL;\n\t\tint32_t ld_flags_deep = 0 ;\n#endif\n\t\tif ( flags < 0 ) {\n\t\t\tdlerror();\n\t\t\thandle = dlopen(filepath, RTLD_LAZY | RTLD_LOCAL);\n\t\t\tif (!handle) {\n\t\t\t\tDPRINTF_ERROR(0, \"Failed to load %s - error: %s \\n\", filepath, dlerror());\n\t\t\t\tif ( filepath) free(filepath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tld_flags_sym_global = dlsym(handle, \"flexiblas_ld_global\");\n\t\t\tif ( ld_flags_sym_global == NULL) {\n\t\t\t\tld_flags_global = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_global = *((int32_t*) ld_flags_sym_global);\n\t\t\t}\n\n\t\t\tld_flags_sym_lazy = dlsym(handle, \"flexiblas_ld_lazy\");\n\t\t\tif ( ld_flags_sym_lazy == NULL) {\n\t\t\t\tld_flags_lazy = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_lazy = *((int32_t*) ld_flags_sym_lazy);\n\t\t\t}\n#ifdef __linux__\n\t\t\tld_flags_sym_deep = dlsym(handle, \"flexiblas_ld_deep\");\n\t\t\tif ( ld_flags_sym_deep == NULL) {\n\t\t\t\tld_flags_deep = 0;\n\t\t\t} else {\n\t\t\t\tld_flags_deep = *((int32_t*) ld_flags_sym_deep);\n\t\t\t}\n#endif\n\t\t\tdlclose(handle);\n\n\t\t\tif ( ld_flags_global != 0 ) {\n\t\t\t\tflags = RTLD_GLOBAL;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_GLOBAL\\n\");\n\t\t\t} else {\n\t\t\t\tflags = RTLD_LOCAL;\n\t\t\t}\n\n\t\t\tif ( ld_flags_lazy != 0 ) {\n\t\t\t\tflags |= RTLD_LAZY;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_LAZY\\n\");\n\t\t\t} else {\n\t\t\t\tflags |= RTLD_NOW;\n\t\t\t}\n\n#ifdef __linux__\n\t\t\tif ( ld_flags_deep != 0 ) {\n\t\t\t\tflags |= RTLD_DEEPBIND;\n\t\t\t\tDPRINTF(1, \"Load backend with RTLD_DEEPBIND\\n\");\n\t\t\t}\n#endif\n/* #if ( defined(__powerpc__) || defined(__powerpc64__)) && !defined(__IBMC__)\n\t\t\tflags |= RTLD_DEEPBIND;\n#endif  */\n\t\t}\n\n\t\thandle = dlopen(filepath, flags);\n#endif\n\n\n\n\t\tif (handle == NULL){\n#ifdef __WIN32__\n\t\t\tDPRINTF_ERROR(0, \"Unable to load library: %s\\r\\n\", filepath);\n#else\n\t\t\tDPRINTF_ERROR(0, \"dlopen: %s\\n\", dlerror());\n#endif\n\t\t}\n\t\tif (sofile != NULL) {\n\t\t\t*sofile = strdup(filepath);\n\t\t}\n\t\tfree(filepath);\n\t\treturn handle;\n\t} else {\n\t\tif ( filepath) free(filepath);\n\t\treturn NULL;\n\t}\n}\n\nHIDDEN int __flexiblas_dl_symbol_exist( const char *libname, const char *symbol_name )\n{\n\tchar *path = NULL;\n\tchar *filepath = NULL;\n\tsize_t len;\n\tvoid *handle;\n\tint found = 0 ;\n\tint path_count = 0;\n\n    if (libname == NULL) return 0;\n\n\n\tif ( strstr(libname,\"/\") == NULL ) {\n        for ( path_count = -1 ; path_count < __flexiblas_count_additional_paths; path_count++){\n            if ( path_count == -1 ) {\n                if ( access(libname, R_OK) == 0 ) {\n                    filepath = strdup(libname);\n                } else {\n                    continue;\n                }\n            } else {\n    \t\t\tpath =  __flexiblas_additional_paths[path_count];\n\t    \t\tlen = strlen(path) + strlen(libname) + 5;\n\t\t    \tfilepath = malloc(len * sizeof ( char ));\n\t\t\t    snprintf(filepath, len -1, \"%s/%s\", path, libname);\n            }\n\t\t\tDPRINTF(1, \"Check if shared libary exist: %s\\n\", filepath);\n            if ( file_exists(filepath) ){\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree(filepath);\n\t\t\t\tfilepath = NULL;\n\t\t\t}\n\t\t}\n\t} else if (is_absolute(libname)) {\n\t\tif ( file_exists(libname) ) {\n\t\t\tfound = 1;\n\t\t\tfilepath = strdup( libname);\n\t\t}\n\t} else if ( is_relative(libname)) {\n\t\tlong path_max;\n\t\tchar * resolvepath;\n#ifdef PATH_MAX\n\t\tpath_max = PATH_MAX;\n#else\n\t\tpath_max = pathconf(path, _PC_PATH_MAX);\n\t\tif (path_max <= 0)\n\t\t\tpath_max = 32768;\n#endif\n\t\tresolvepath = calloc(path_max, sizeof(char));\n\n\t\tif ( realpath(libname, resolvepath) == NULL ) {\n\t\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s or file does not exists.\\n\",libname );\n\t\t\tfound = 0;\n\t\t\tif (filepath) free(filepath);\n\t\t\tfilepath = NULL;\n\t\t\tfree(resolvepath);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfilepath = strdup(resolvepath);\n\t\t\tfree(resolvepath);\n\t\t\t/* DPRINTF_ERROR(2, \"Filepath: %s\\n\",filepath ); */\n\t\t}\n\t\tif (file_exists(filepath) ) {\n\t\t\tfound = 1;\n\t\t}\n\t} else {\n\t\tDPRINTF_ERROR(0,\"Cannot determine type to the path: %s\\n\",libname );\n\n\t\tfound = 0;\n\t\tif (filepath) free(filepath);\n\t\tfilepath = NULL;\n\t}\n\n\n\tif( found ) {\n        void *sym = NULL;\n        dlerror();\n        handle = dlopen(filepath, RTLD_LAZY | RTLD_LOCAL);\n        if (!handle) {\n            DPRINTF_ERROR(0, \"Failed to load %s - error: %s \\n\", filepath, dlerror());\n            if ( filepath) free(filepath);\n            return 0;\n        }\n        sym = dlsym(handle, symbol_name);\n        dlclose(handle);\n       \tif ( filepath) free(filepath);\n        return (sym == NULL) ? 0 : 1;\n    }\n\tif ( filepath) free(filepath);\n    return 0;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/helper.h": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#ifndef FLEXIBLAS_HELPER_H\n\n#define FLEXIBLAS_HELPER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    HIDDEN extern int __flexiblas_verbose;\n\n    void flexiblas_print_error(const char *prefix, const char *path, const int line, const char *fmt, ... );\n    void flexiblas_print_warning(const char *prefix, const char *fmt, ... );\n    void flexiblas_print_info(const char *prefix, const char *fmt, ... );\n\n    HIDDEN void * __flexiblas_dlopen( const char *libname, int flags, char **soname );\n    HIDDEN int __flexiblas_dl_symbol_exist( const char *libname, const char *symbol_name );\n\n\n    #define\tDPRINTF( level, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_info( \"flexiblas\", __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n    #define\tDPRINTFP( level, prefix, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_info( prefix, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n\n    #define\tDPRINTF_WARN( level, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_warning( \"flexiblas\", __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n    #define\tDPRINTFP_WARN( level, prefix, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_warning( prefix, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n\n#ifdef DEBUG\n    #define\tDPRINTF_ERROR( level, ... )\t    do { if ( __flexiblas_verbose >= (level)) {flexiblas_print_error(\"flexiblas\", __FILE__,__LINE__, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n    #define\tDPRINTFP_ERROR( level, prefix, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_error(prefix, __FILE__,__LINE__, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n#else\n    #define\tDPRINTF_ERROR( level, ... )\t    do { if ( __flexiblas_verbose >= (level)) {flexiblas_print_error(\"flexiblas\", NULL,0, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n    #define\tDPRINTFP_ERROR( level, prefix, ... )\tdo { if ( __flexiblas_verbose >= (level)) {flexiblas_print_error(prefix, NULL,0, __VA_ARGS__); } } while(0) // ... represents the \"text\" and optionally the \"args\"\n\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* end of include guard: FLEXIBLAS_HELPER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/flexiblas.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#ifdef __linux__\n#define __GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include \"flexiblas.h\"\n#include <errno.h>\n#include <stddef.h>\n#include <string.h>\n#include <strings.h>\n#include \"cscutils/strutils.h\"\n#include \"paths.h\"\n#include \"hooks.h\"\n\n#define DLOPEN_FLAGS_FROM_FILE -1\n#ifndef __WIN32__\n#include <dlfcn.h>\n#ifdef __linux__\n// Linux\n// #define DLOPEN_FLAGS (RTLD_LAZY)\n#define DLOPEN_FLAGS RTLD_LOCAL|RTLD_NOW\n#else\n// BSD\n#define DLOPEN_FLAGS (RTLD_LOCAL|RTLD_NOW)\n#endif\n#else\n// Windows\n#define DLOPEN_FLAGS (0)\n#define strtok_r strtok_s\n#include <windows.h>\n#endif\n\n/*  Initialize global variables. */\nHIDDEN int __flexiblas_initialized = 0;\nHIDDEN int __flexiblas_profile = 0;\nHIDDEN flexiblas_backend_t *current_backend = NULL;\nHIDDEN flexiblas_backend_t **loaded_backends = NULL;\nHIDDEN size_t                  nloaded_backends = 0;\nHIDDEN flexiblas_mgmt_t *__flexiblas_mgmt = NULL;\nHIDDEN flexiblas_hook_t *__flexiblas_hooks = NULL;\n\nHIDDEN flexiblas_exit_function_t hook_exit = NULL;\n\nHIDDEN void *__flexiblas_blas_fallback = NULL;\n#ifdef FLEXIBLAS_LAPACK\nHIDDEN void *__flexiblas_lapack_fallback = NULL;\n#endif\n\n// #include \"lapack_interface/syms-3.6.1.c\"\n/*-----------------------------------------------------------------------------\n *  Convert Chars to Upper Case\n *-----------------------------------------------------------------------------*/\nstatic char *uppercase(char *str) {\n    char *ret = str;\n    if ( str == NULL ) return NULL;\n    while (*str != '\\0') {\n        *str = (char)toupper(*str);\n        str++;\n    }\n    return ret;\n}\n\n\n\n/*-----------------------------------------------------------------------------\n *  Default Info Structure if none is given\n *-----------------------------------------------------------------------------*/\nstatic void h_info_default(flexiblas_info_t *info) {\n    info->flexiblas_integer_size = sizeof(Int);\n    info->backend_integer_size = 0;\n    info->intel_interface = 0 ;\n    info->post_init = 0;\n}\n\n\n\n\n\n\n\n/*-----------------------------------------------------------------------------\n *  Init the backend.\n *-----------------------------------------------------------------------------*/\nHIDDEN void __flexiblas_backend_init( flexiblas_backend_t * backend) {\n    int load = 0;\n    int failed = 0;\n\n\n    if (backend == NULL) {\n        DPRINTF(0, PRINT_PREFIX \" No current BLAS is set.\\n\");\n        abort();\n    }\n    pthread_mutex_lock(&(backend->post_init_mutex));\n    if ( backend->post_init != 0 ) {\n        if (backend->init_function != NULL) {\n            if ( backend->init_function() != 0 ) {\n                DPRINTF(0, PRINT_PREFIX \" Initialization of the backend library \\\"%s\\\" failed. \\n\", backend->name);\n                abort();\n            }\n        }\n        /*-----------------------------------------------------------------------------\n         *  Load FBLAS\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_load_fblas(backend, &load, &failed);\n\n        /*-----------------------------------------------------------------------------\n         *  Load CBLAS\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_load_cblas(backend);\n\n#ifdef FLEXIBLAS_LAPACK\n        /*-----------------------------------------------------------------------------\n         *  Load LAPACK\n         *-----------------------------------------------------------------------------*/\n        int nolapack = 0;\n        flexiblas_mgmt_location_t loc;\n        if ( getenv(ENV_FLEXIBLAS_NOLAPACK)) {\n            nolapack = atoi(getenv(ENV_FLEXIBLAS_NOLAPACK));\n        } else {\n            flexiblas_mgmt_get_active_property(__flexiblas_mgmt, &loc, FLEXIBLAS_PROP_NOLAPACK, &nolapack);\n        }\n        if ( nolapack ) {\n            DPRINTF(1,\"LAPACK is load from the fallback only. No LAPACK routines from the backend will be used.\\n\");\n            __flexiblas_load_flapack_fallback(backend, &load, &failed);\n        } else {\n            __flexiblas_load_flapack(backend, &load, &failed);\n        }\n#endif\n\n        /* Setup XERBLA */\n        __flexiblas_setup_xerbla(backend);\n#ifdef FLEXIBLAS_CBLAS\n        __flexiblas_setup_cblas_xerbla(backend);\n#endif\n        backend->post_init = 0;\n    }\n\n\n    pthread_mutex_unlock(&(backend->post_init_mutex));\n\n    if ( failed > 0) {\n        DPRINTF_ERROR(0,\" Failed to load the backend completely, some BLAS functions are missing. Abort!\\n\");\n        abort();\n    }\n}\n\n\n\n/*-----------------------------------------------------------------------------\n *  Load the Info section from the Backend\n *-----------------------------------------------------------------------------*/\nstatic void flexiblas_load_info(void *library, flexiblas_backend_t *backend)\n{\n    memset(&(backend->info),0,sizeof(flexiblas_info_t));\n    backend->info.flexiblas_integer_size = sizeof(Int);\n#ifdef __WIN32__\n    backend->info_function = (flexiblas_info_function_t) GetProcAddress(library, FLEXIBLAS_INFO_FUNCTION_NAME );\n    backend->init_function = (flexiblas_init_function_t) GetProcAddress(library, FLEXIBLAS_INIT_FUNCTION_NAME);\n    backend->exit_function = (flexiblas_exit_function_t) GetProcAddress(library, FLEXIBLAS_EXIT_FUNCTION_NAME);\n#else\n    backend->info_function = (flexiblas_info_function_t) dlsym(library, FLEXIBLAS_INFO_FUNCTION_NAME);\n    backend->init_function = (flexiblas_init_function_t) dlsym(library, FLEXIBLAS_INIT_FUNCTION_NAME);\n    backend->exit_function = (flexiblas_exit_function_t) dlsym(library, FLEXIBLAS_EXIT_FUNCTION_NAME);\n#endif\n\n    backend->library_handle = library;\n\n    /* Load the Environment information function   */\n    __flexiblas_load_set_num_threads(backend);\n    __flexiblas_load_get_num_threads(backend);\n    if ( backend->info_function ) {\n        backend->info_function(&(backend->info));\n    } else {\n        DPRINTF(1,\"No BLAS Info found in given backend. Using default.\\n\");\n        h_info_default(&(backend->info));\n    }\n}\n\n/*-----------------------------------------------------------------------------\n *  Print the Basic BLAS info\n *-----------------------------------------------------------------------------*/\nstatic void print_info(flexiblas_backend_t *backend)\n{\n    DPRINTF(1,\"BLAS info:\\n\");\n    DPRINTF(1,\" - intel_interface        = %d\\n\",backend->info.intel_interface);\n    DPRINTF(1,\" - flexiblas_integer_size = %d\\n\",backend->info.flexiblas_integer_size);\n    DPRINTF(1,\" - backend_integer_size   = %d\\n\",backend->info.backend_integer_size);\n    DPRINTF(1,\" - post_init              = %d\\n\",backend->info.post_init);\n}\n\nstatic flexiblas_backend_t * flexiblas_load_library_from_init (flexiblas_mgmt_t *config, char *blas_default_map ) {\n    char *env_FLEXIBLAS = NULL;\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n    char name[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n    char blas_name[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n\n    if ( getenv(ENV_FLEXIBLAS) == NULL) {\n        env_FLEXIBLAS = NULL;\n    } else {\n        env_FLEXIBLAS = strdup(getenv(ENV_FLEXIBLAS));\n    }\n    /*-----------------------------------------------------------------------------\n     *  Analyze the FLEXIBLAS environment variable\n     *-----------------------------------------------------------------------------*/\n    if (env_FLEXIBLAS== NULL) {\n        char clibrary[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n        flexiblas_mgmt_location_t loc;\n\n        if ( flexiblas_mgmt_get_active_default(config, &loc, blas_name)) {\n\n            DPRINTF_ERROR(0,\"Failed to get the default backend. Reset to FALLBACK.\\n\");\n            strncpy(blas_name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n        }\n\n        if ( flexiblas_mgmt_blas_get2(config, &loc, blas_name, clibrary, NULL)) {\n            DPRINTF_ERROR(0, \"Failed to get the BLAS backend (%s) from the configuration.\\n\", blas_name);\n            abort();\n        }\n\n        DPRINTF(1,\"Use default BLAS: %s - %s from %s\\n\", blas_name, clibrary, flexiblas_mgmt_location_to_string(loc) );\n        library = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE , NULL);\n        strncpy(name, blas_name, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n\n    } else {\n        /*-----------------------------------------------------------------------------\n         *  Try to open env_FLEXIBLAS directly and the get the value from the Hashtable\n         *-----------------------------------------------------------------------------*/\n        DPRINTF(1,\"Trying to use the content of \" ENV_FLEXIBLAS \": \\\"%s\\\" as shared library.\\n\", env_FLEXIBLAS);\n        library = __flexiblas_dlopen(env_FLEXIBLAS, DLOPEN_FLAGS_FROM_FILE, NULL);\n        strncpy(name, env_FLEXIBLAS, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n\n        /*  if env_FLEXIBLAS does not contain an .so file we look into the configuration  */\n        if ( library == NULL) {\n            char *clibrary = NULL;\n            flexiblas_mgmt_location_t loc;\n            char *tmp = strdup(env_FLEXIBLAS);\n            tmp = uppercase(tmp);\n            DPRINTF_WARN(1,\"\\\"%s\\\" does not seem to a shared library. Search inside the FlexiBLAS configuration..\\n\", tmp);\n\n            clibrary = (char*) malloc(sizeof(char)*32768);\n            if ( flexiblas_mgmt_blas_get2(config, &loc, tmp, clibrary, NULL)) {\n                free(clibrary);\n                clibrary = NULL;\n            }\n\n            /* Load the default BLAS if the env_FLEXIBLAS implementation was not found in the configuration */\n            if (clibrary == NULL ) {\n                if ( flexiblas_mgmt_get_active_default(config, &loc, blas_name)) {\n                    DPRINTF_ERROR(0,\"Failed to get the default backend. Reset to FALLBACK.\\n\");\n                    strncpy(blas_name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n                }\n                DPRINTF_ERROR(0, \"BLAS backend  \\\"%s\\\" not found. Loading default (%s) instead.\\n\", tmp, blas_name);\n\n                clibrary = (char*) malloc(sizeof(char)*32768);\n                if ( flexiblas_mgmt_blas_get2(config, &loc, blas_name, clibrary, NULL)) {\n                    DPRINTF_ERROR(0, \"Failed to get the BLAS backend (%s) from the configuration.\\n\", blas_name);\n                    abort();\n                }\n\n                strncpy(name, blas_name, FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n                free(tmp);\n                tmp = strdup(blas_name);\n            }\n\n            DPRINTF(1,\"Trying to load  %s\\n\", clibrary );\n            library  = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE , NULL);\n            if ( clibrary != NULL) free(clibrary);\n            free(tmp);\n        }\n    }\n\n    /* Load FallBack if non of the previously opened libraries worked. */\n    if ( library == NULL ) {\n        char *clibrary = NULL;\n        flexiblas_mgmt_location_t loc;\n        DPRINTF(0, \"No suitable BLAS backend could be loaded. Trying Fallback instead.\\n\");\n        clibrary = (char* ) malloc(sizeof(char) * 32768);\n        if ( flexiblas_mgmt_blas_get2(config, &loc, \"__FALLBACK__\", clibrary, NULL)) {\n            DPRINTF_ERROR(0, \"Failed to get the BLAS backend (__FALLBACK__) from the configuration.\\n\");\n            library = NULL;\n        } else {\n            library = __flexiblas_dlopen(clibrary,DLOPEN_FLAGS_FROM_FILE , NULL);\n        }\n        free(clibrary);\n        strncpy(name, \"__FALLBACK__\", FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n    }\n\n    if ( library == NULL ) {\n        fprintf(stderr, PRINT_PREFIX \"Unable to open any BLAS library (choosen: %s). Abort!\\n\",\n                (env_FLEXIBLAS == NULL)?blas_default_map:env_FLEXIBLAS);\n        abort();\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ) {\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(name);\n    uppercase(backend->name);\n\n    if ( env_FLEXIBLAS != NULL) {\n        free(env_FLEXIBLAS);\n    }\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n#ifdef FLEXIBLAS_INTEGER8\n        backend->info.backend_integer_size = sizeof(int64_t);\n#else\n        backend->info.backend_integer_size = sizeof(int32_t);\n#endif\n    }\n\n    backend->post_init =  backend->info.post_init;\n\n\n    backend->hook_init = 0;\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend uses post initialization.\\n\");\n    }\n\n    print_info(backend);\n    return backend;\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Load additional BLAS\n *-----------------------------------------------------------------------------*/\nstatic flexiblas_backend_t * __flexiblas_load_backend_from_config(const char *blas_name)\n{\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n    char clibrary[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n    flexiblas_mgmt_location_t loc;\n\n    if ( flexiblas_mgmt_blas_get2(__flexiblas_mgmt, &loc, blas_name, clibrary, NULL) != 0) {\n        DPRINTF_ERROR(0, \"BLAS %s not found in config.\\n\", blas_name);\n        return NULL;\n    }\n\n    DPRINTF(2, \" Try to load %s - %s\\n\", blas_name, clibrary);\n    library = __flexiblas_dlopen(clibrary, DLOPEN_FLAGS_FROM_FILE, (char **) NULL);\n\n    if ( library == NULL ) {\n        DPRINTF(2, \" failed.\\n\");\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ){\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(blas_name);\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n#ifdef FLEXIBLAS_INTEGER8\n        backend->info.backend_integer_size = sizeof(int64_t);\n#else\n        backend->info.backend_integer_size = sizeof(int32_t);\n#endif\n    }\n    print_info(backend);\n\n    backend->post_init =  backend->info.post_init;\n    backend->hook_init =  0;\n\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend %s uses post initialization.\\n\", blas_name);\n    }\n    return backend;\n}\n\n/*-----------------------------------------------------------------------------\n *  Load BLAS by name from config (API VERSION)\n *-----------------------------------------------------------------------------*/\nint flexiblas_load_backend(const char *name )\n{\n    flexiblas_backend_t * new_backend = NULL;\n    size_t i;\n\n    for (i = 0; i < nloaded_backends; i++) {\n        if ( csc_strcasecmp(name , loaded_backends[i]->name) == 0) {\n            /* Already loaded */\n            return (int)i;\n        }\n    }\n\n    DPRINTF(1,\"Backend %s not loaded until now. - %d \\n\", name, -1);\n    /* Not loaded */\n    new_backend = __flexiblas_load_backend_from_config(name);\t\t\t/* FIXME does accept const char* (yet) */\n    if ( new_backend != NULL ) {\n        size_t new_backend_pos = nloaded_backends;\n        flexiblas_backend_t ** new_loaded;\n        nloaded_backends++;\n        new_loaded  = realloc(loaded_backends, sizeof(flexiblas_backend_t*) * nloaded_backends);\n        if (new_loaded == NULL) {\n            DPRINTF(0, \"Failed to allocate memory to load the new backend. Abort\\n\");\n            abort();\n        } else {\n            loaded_backends = new_loaded;\n        }\n        loaded_backends[new_backend_pos] = new_backend;\n        // csc_ini_setinteger((csc_ini_file_t*) __flexiblas_mgmt->host_config, name, \"__loaded__\", new_backend_pos);\n        return (int)new_backend_pos;\n    }\n\n    /* Fails to load */\n    return -1;\n}\n\n\n\nstatic flexiblas_backend_t * __flexiblas_load_backend_from_file(const char *blas_sofile)\n{\n    flexiblas_backend_t *backend = NULL;\n    void *library = NULL;\n\n    DPRINTF(2, PRINT_PREFIX \" Try to load %s \\n\", blas_sofile);\n    library = __flexiblas_dlopen(blas_sofile, DLOPEN_FLAGS_FROM_FILE, (char **) NULL);\n\n    if ( library == NULL ) {\n        DPRINTF(2, PRINT_PREFIX \" failed.\\n\");\n        return NULL;\n    }\n\n    backend = (flexiblas_backend_t*) malloc(sizeof(flexiblas_backend_t));\n    if ( backend == NULL ){\n        DPRINTF(0, \" Failed to allocate space for backend structure.\\n\");\n        return NULL;\n    }\n    memset((void*) backend, 0, sizeof(flexiblas_backend_t));\n    pthread_mutex_init(&(backend->post_init_mutex),NULL);\n\n    backend->library_handle = library;\n    backend->name = strdup(blas_sofile);\n\n    /* load info */\n    flexiblas_load_info(library, backend);\n\n    /*-----------------------------------------------------------------------------\n     *  Get the integer size of the backend if not already set\n     *-----------------------------------------------------------------------------*/\n    if ( backend->info.backend_integer_size == 0 ) {\n        DPRINTF(0, \"BLAS %s does not provide an integer size hint. Assuming 4 Byte.\\n\", blas_sofile);\n        backend->info.backend_integer_size = sizeof(int32_t);\n    }\n    backend->post_init =  backend->info.post_init;\n    backend->hook_init =  0;\n\n\n    if ( backend->post_init == 0 ) {\n        backend->post_init = 1;\n        __flexiblas_backend_init(backend);\n    } else {\n        DPRINTF(0, \"BLAS backend %s uses post initialization.\\n\", blas_sofile);\n    }\n\n    print_info(backend);\n    return backend;\n}\n\n/*-----------------------------------------------------------------------------\n * Load backend from FILE (API VERSION)\n *-----------------------------------------------------------------------------*/\nint flexiblas_load_backend_library(const char *libname)\n{\n    flexiblas_backend_t * new_backend = NULL;\n    size_t i;\n\n    for (i = 0; i < nloaded_backends; i++) {\n        if ( csc_strcasecmp(libname , loaded_backends[i]->name) == 0) {\n            /* Already loaded */\n            return i;\n        }\n    }\n\n    DPRINTF(1,\"Backend %s not loaded until now. - %d \\n\", libname, -1);\n    /* Not loaded  */\n    new_backend = __flexiblas_load_backend_from_file(libname);\n    if ( new_backend != NULL ) {\n        size_t new_backend_pos = nloaded_backends;\n        flexiblas_backend_t **new_loaded;\n        nloaded_backends++;\n        new_loaded = realloc(loaded_backends, sizeof(flexiblas_backend_t*) * nloaded_backends);\n        if (new_loaded == NULL) {\n            DPRINTF(0, \"Failed to allocate memory to load the new backend. Abort\\n\");\n            abort();\n        } else {\n            loaded_backends = new_loaded;\n        }\n\n        loaded_backends[new_backend_pos] = new_backend;\n        // csc_ini_setinteger((csc_ini_file_t*) __flexiblas_mgmt->host_config, libname, \"__loaded__\", new_backend_pos);\n        return new_backend_pos;\n    }\n\n    /* Fails to load */\n    return -1;\n}\n\n\n/*-----------------------------------------------------------------------------\n *  Init Routine\n *-----------------------------------------------------------------------------*/\n#ifndef __WIN32__\n__attribute__((constructor))\n#endif\n    void flexiblas_init() {\n        char blas_default_map[FLEXIBLAS_MGMT_MAX_BUFFER_LEN] ;\n        char path[FLEXIBLAS_MGMT_MAX_BUFFER_LEN];\n        flexiblas_backend_t  *backend = NULL;\n        flexiblas_mgmt_location_t loc;\n\n        /*-----------------------------------------------------------------------------\n         *  Read Environment Variables\n         *-----------------------------------------------------------------------------*/\n        char *env_FLEXIBLAS_VERBOSE=getenv(ENV_FLEXIBLAS_VERBOSE);\n        char *env_FLEXIBLAS_COLOR_OUTPUT=getenv(ENV_FLEXIBLAS_COLOR_OUTPUT);\n        char *env_FLEXIBLAS_HOOK=getenv(ENV_FLEXIBLAS_HOOK);\n\n        if ( __flexiblas_initialized != 0) return;\n        __flexiblas_initialized = 1;\n        __flexiblas_mgmt_init = 1;\n\n        (void) flexiblas_verbosity();\n\n        /* Color Output */\n        if (env_FLEXIBLAS_COLOR_OUTPUT != NULL) {\n            int s = atoi(env_FLEXIBLAS_COLOR_OUTPUT);\n            flexiblas_set_color_output(s);\n        }\n        /* Load environemt variables   */\n        if ( env_FLEXIBLAS_VERBOSE != NULL ) {\n            __flexiblas_verbose = atoi(env_FLEXIBLAS_VERBOSE);\n        }\n\n        memset(path, '\\0', FLEXIBLAS_MGMT_MAX_BUFFER_LEN);\n        /*-----------------------------------------------------------------------------\n         *  Read mapping file\n         *  1. /etc/flexiblasrc  or its counterpart in the build directory\n         *  3. $HOME/.flexiblasrc\n         *-----------------------------------------------------------------------------*/\n        __flexiblas_mgmt = flexiblas_mgmt_load_config();\n        if ( __flexiblas_mgmt == NULL) {\n            DPRINTF_ERROR(0, \"Cannot initialize/load the configuration.\\n\");\n            abort();\n        }\n\n        if ( env_FLEXIBLAS_VERBOSE == NULL) {\n            /* Load Properties */\n            flexiblas_mgmt_get_active_property(__flexiblas_mgmt, &loc, FLEXIBLAS_PROP_VERBOSE, &__flexiblas_verbose);\n        }\n\n\n\n        /* Add additional search paths */\n        __flexiblas_add_path_from_environment();\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_ENV);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_HOST);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_USER);\n        __flexiblas_add_path_from_config(__flexiblas_mgmt, FLEXIBLAS_GLOBAL);\n        __flexiblas_init_default_paths();\n\n\n        /* Search all available hooks */\n        __flexiblas_add_hooks();\n\n\n        if (__flexiblas_insert_fallback_blas(__flexiblas_mgmt)) {\n            DPRINTF_ERROR(0, \"Failed to initialize the default and the fallback BLAS backend.\\n\");\n            abort();\n        }\n        /*  Load the active default BLAS */\n        if ( flexiblas_mgmt_get_active_default(__flexiblas_mgmt, &loc, blas_default_map) < 0 ) {\n            DPRINTF_ERROR(0, \"Failed to select the default BLAS backend.\\n\");\n            abort();\n        }\n\n        /*-----------------------------------------------------------------------------\n         *  Display Copyright\n         *-----------------------------------------------------------------------------*/\n        if ( __flexiblas_verbose) {\n            __flexiblas_print_copyright(1);\n        }\n\n        /*-----------------------------------------------------------------------------\n         *  Load Library\n         *-----------------------------------------------------------------------------*/\n        uppercase(blas_default_map);\n\n        /*-----------------------------------------------------------------------------\n         *  Load NETLIB Fallback\n         *-----------------------------------------------------------------------------*/\n        {\n            char *SO_EXTENSION = __flexiblas_getenv(FLEXIBLAS_ENV_SO_EXTENSION);\n            size_t len=strlen(FALLBACK_NAME)+strlen(SO_EXTENSION)+2;\n            char *blas_name = (char *) calloc(len,sizeof(char));\n            snprintf(blas_name,len, \"%s%s\", FALLBACK_NAME,SO_EXTENSION);\n            free(SO_EXTENSION);\n\n            __flexiblas_blas_fallback = __flexiblas_dlopen(blas_name, RTLD_LAZY | RTLD_GLOBAL , NULL);\n            if ( __flexiblas_blas_fallback == NULL ) {\n                DPRINTF_ERROR(0,\" Failed to load the BLAS fallback library.  Abort!\\n\");\n                abort();\n            }\n            free(blas_name);\n        }\n\n#ifdef FLEXIBLAS_LAPACK\n        /*-----------------------------------------------------------------------------\n         *  Load LAPACK Fallback\n         *-----------------------------------------------------------------------------*/\n        {\n            char *SO_EXTENSION = __flexiblas_getenv(FLEXIBLAS_ENV_SO_EXTENSION);\n            size_t len=strlen(LAPACK_FALLBACK_NAME)+strlen(SO_EXTENSION)+2;\n            char *lapack_name = (char *) calloc(len,sizeof(char));\n            snprintf(lapack_name,len, \"%s%s\", LAPACK_FALLBACK_NAME,SO_EXTENSION);\n            free(SO_EXTENSION);\n#ifdef LAPACK_DEEPBIND\n            __flexiblas_lapack_fallback = __flexiblas_dlopen(lapack_name, RTLD_LAZY | RTLD_DEEPBIND |  RTLD_GLOBAL , NULL);\n#else\n            __flexiblas_lapack_fallback = __flexiblas_dlopen(lapack_name, RTLD_LAZY | RTLD_GLOBAL , NULL);\n#endif\n            if ( __flexiblas_lapack_fallback == NULL ) {\n                DPRINTF_ERROR(0,\" Failed to load the LAPACK fallback library.  Abort!\\n\");\n                abort();\n            }\n            free(lapack_name);\n        }\n#endif\n\n\n        /*\n         * LOAD BLAS Backend.\n         */\n        backend = flexiblas_load_library_from_init(__flexiblas_mgmt, blas_default_map);\n        if ( backend == NULL ){\n            DPRINTF_ERROR(0, \"Loading Backend Failed.\\n\");\n            abort();\n        }\n        loaded_backends = (flexiblas_backend_t **) malloc(sizeof(flexiblas_backend_t*) * 1);\n        /* Set the loaded backend as default one.  */\n        nloaded_backends = 1;\n        loaded_backends[0] = backend;\n        current_backend  = backend;\n\n\n        /*\n         * Load Hooks\n         */\n        __flexiblas_hooks = (flexiblas_hook_t *) malloc(sizeof(flexiblas_hook_t) * (1));\n        if (!__flexiblas_hooks) {\n            DPRINTF_ERROR(0, \"Failed to allocate memory for hook management. Abort.\\n\");\n            abort();\n        }\n        memset(__flexiblas_hooks, 0, sizeof(flexiblas_hook_t));\n        __flexiblas_hooks->hooks_loaded = 0;\n        __flexiblas_hooks->initialized  = 0;\n\n        dlsym((void *) 0, \"flexiblas_verbosity\");\n\n        int hooks_to_load = 0;\n        char ** hook_load_list = NULL;\n        int ret = 0;\n        int i ;\n        if ( env_FLEXIBLAS_HOOK == NULL ){\n            // Load from Config\n            flexiblas_mgmt_location_t locx;\n            ret = flexiblas_mgmt_hook_get_active(__flexiblas_mgmt, &locx, &hooks_to_load, &hook_load_list);\n            if ( ret != 0 ) {\n                DPRINTF_ERROR(0, \"Failed to obtain list of enabled hooks from the configuration. Continue without hooks.\\n\");\n                goto continue_load;\n            }\n        } else {\n            // load from environment\n            char *nexttoken = NULL;\n            char *saveptr = NULL;\n            i = 0;\n            nexttoken = strtok_r(env_FLEXIBLAS_HOOK,\":,\", &saveptr);\n            while (nexttoken != NULL ){\n                i++;\n                if (!( __flexiblas_hook_exists(nexttoken))) {\n                    char *hook_name = __flexiblas_hook_add_from_file(nexttoken);\n                    if ( !hook_name) {\n                        DPRINTF_ERROR(0, \"Hook %s not found. Abort.\\n\", nexttoken);\n                        abort();\n                    }\n                    hook_load_list = realloc (hook_load_list, i * sizeof(char*));\n                    hook_load_list[i-1] = strdup(hook_name);\n\n                } else {\n                    hook_load_list = realloc (hook_load_list, i * sizeof(char*));\n                    hook_load_list[i-1] = strdup(nexttoken);\n                }\n                nexttoken = strtok_r(NULL,\":,\", &saveptr);\n            }\n            hooks_to_load = i;\n        }\n\n        int k = 0;\n        for (i = 0; i < hooks_to_load; i++) {\n            char * sofile;\n            void * handle = NULL;\n\n            sofile = __flexiblas_hook_sofile(hook_load_list[i]);\n            handle  = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL , NULL);\n            DPRINTF(1,\"Load hook: %s - %s\\n\", hook_load_list[i], sofile);\n            if ( ! handle ) {\n                DPRINTF_ERROR(0, \"Failed to load hook %s. Either it does not exists in the configuration or it is not a shared object.\\n\", hook_load_list[i]);\n                free(hook_load_list[i]);\n                continue;\n            }\n\n\n            __flexiblas_hooks->handles[k] = handle;\n            __flexiblas_hooks->hook_init[k] = (flexiblas_init_function_t) dlsym(handle, FLEXIBLAS_HOOK_INIT_FUNCTION_NAME);\n            __flexiblas_hooks->hook_exit[k] = (flexiblas_exit_function_t) dlsym(handle, FLEXIBLAS_HOOK_EXIT_FUNCTION_NAME);\n\n            __flexiblas_load_blas_hooks(__flexiblas_hooks, handle);\n\n            __flexiblas_hooks->hooks_loaded ++;\n            if ( __flexiblas_hooks->hooks_loaded >= FLEXIBLAS_MAX_HOOKS ) {\n                DPRINTF_ERROR(0, \"More than %d hook libraries loaded. Please reduce the number of hook libraries. Abort!\\n\", FLEXIBLAS_MAX_HOOKS);\n                abort();\n            }\n            k++;\n            free(hook_load_list[i]);\n        }\n        free(hook_load_list);\n\n        /* Init The Hook Library  */\n        if (__flexiblas_hooks->initialized == 0) {\n            __flexiblas_hooks->initialized = 1;\n            for (k = 0; k < __flexiblas_hooks->hooks_loaded; k++) {\n                __flexiblas_hooks->hook_init[k]();\n            }\n        }\n\n\n        continue_load:\n        return;\n\n\n\n\n\n    }\n\n\n\n/*-----------------------------------------------------------------------------\n *  Cleanup\n *-----------------------------------------------------------------------------*/\n#ifndef __WIN32__\n__attribute__((destructor))\n#endif\n    void flexiblas_exit() {\n        size_t i;\n        if (__flexiblas_verbose ) DPRINTF(1,\"cleanup\\n\");\n\n        int k;\n        for ( k = __flexiblas_hooks->hooks_loaded-1; k>=0; k--){\n            __flexiblas_hooks->hook_exit[k]();\n            dlclose(__flexiblas_hooks->handles[k]);\n        }\n        free(__flexiblas_hooks);\n        nloaded_backends = 0;\n        __flexiblas_free_paths();\n        __flexiblas_exit_hook();\n\n\n        for (i = 0; i < nloaded_backends ; i++) {\n            if ( loaded_backends[i]->exit_function != NULL) {\n                loaded_backends[i]->exit_function();\n            }\n            free(loaded_backends[i]->name);\n            if ( loaded_backends[i]->library_handle != NULL){\n#ifdef __WIN32__\n                FreeLibrary(loaded_backends[i]->library_handle);\n#else\n                dlclose(loaded_backends[i]->library_handle );\n#endif\n            }\n            free(loaded_backends[i]);\n        }\n        free(loaded_backends);\n\n        dlclose(__flexiblas_blas_fallback);\n#ifdef FLEXIBLAS_LAPACK\n        dlclose(__flexiblas_lapack_fallback);\n#endif\n        flexiblas_mgmt_free_config(__flexiblas_mgmt);\n    }\n\n\n\n\n\ndouble flexiblas_wtime()\n{\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    return (double)tv.tv_sec + (double)tv.tv_usec / 1e6;\n}\n\n\nint flexiblas_verbosity()\n{\n    return __flexiblas_verbose;\n}\n\n\n#ifdef __WIN32__\n#include <windows.h>\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch (fdwReason)\n    {\n        case DLL_PROCESS_ATTACH:\n            /* Code path executed when DLL is loaded into a process's address space. */\n            flexiblas_init();\n            break;\n\n        case DLL_THREAD_ATTACH:\n            /* Code path executed when a new thread is created within the process. */\n            break;\n\n        case DLL_THREAD_DETACH:\n            /* Code path executed when a thread within the process has exited *cleanly*. */\n            break;\n\n        case DLL_PROCESS_DETACH:\n            /* Code path executed when DLL is unloaded from a process's address space. */\n            flexiblas_exit();\n            break;\n    }\n\n    return TRUE;\n}\n#endif\n\n\nflexiblas_mgmt_t * flexiblas_mgmt()\n{\n    return __flexiblas_mgmt;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/src/tool/hookhandling.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * Linking FlexiBLAS statically or dynamically with other modules is making a\n * combined work based on FlexiBLAS. Thus, the terms and conditions of the GNU\n * General Public License cover the whole combination.\n *\n * As a special exception, the copyright holders of FlexiBLAS give you permission\n * to combine FlexiBLAS program with free software programs or libraries that are\n * released under the GNU LGPL and with independent modules that communicate with\n * FlexiBLAS solely through the BLAS/LAPACK interface as provided by the\n * BLAS/LAPACK reference implementation. You may copy and distribute such a system\n * following the terms of the GNU GPL for FlexiBLAS and the licenses of the other\n * code concerned, provided that you include the source code of that other code\n * when and as the GNU GPL requires distribution of source code and provided that\n * you do not modify the BLAS/LAPACK interface.\n *\n * Note that people who make modified versions of FlexiBLAS are not obligated to\n * grant this special exception for their modified versions; it is their choice\n * whether to do so. The GNU General Public License gives permission to release a\n * modified version without this exception; this exception also makes it possible\n * to release a modified version which carries forward this exception. If you\n * modify the BLAS/LAPACK interface, this exception does not apply to your\n * modified version of FlexiBLAS, and you must remove this exception when you\n * distribute your modified version.\n *\n * This exception is an additional permission under section 7 of the GNU General\n * Public License, version 3 (\u201cGPLv3\u201d)\n *\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2013-2020\n */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <dlfcn.h>\n#ifdef __linux__\n#define _GNU_SOURCE\n#endif\n\n#include \"flexiblas.h\"\n#include \"flexiblas_config.h\"\n#include \"paths.h\"\n#include \"helper.h\"\n#include \"hooks.h\"\n#include \"cscutils/strutils.h\"\n#include \"tool.h\"\n\nint disable_all_hooks(flexiblas_mgmt_location_t loc)\n{\n    flexiblas_mgmt_t *config;\n    int     ret = 0;\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n\n    flexiblas_mgmt_hook_disable_all(config, loc);\n\n    ret = flexiblas_mgmt_write_config2(config, loc);\n    flexiblas_mgmt_free_config(config);\n    if ( ret ) {\n        printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n        return 1;\n    }\n    return 0 ;\n\n}\n\nint disable_hook(flexiblas_mgmt_location_t loc, const char *name)\n{\n    flexiblas_mgmt_t *config;\n    int ret = 0;\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n    if ( flexiblas_mgmt_hook_disable(config, loc, name)) {\n        printf(\"Disabling hook %s failed.\\n\", name);\n    } else {\n        printf(\"Disable hook %s successful.\\n\", name);\n        ret = flexiblas_mgmt_write_config2(config,loc);\n        if ( ret ) {\n            flexiblas_mgmt_free_config(config);\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n            return 1;\n        }\n\n    }\n    flexiblas_mgmt_free_config(config);\n    return 0 ;\n}\n\nint enable_hook(flexiblas_mgmt_location_t loc, char *name)\n{\n    flexiblas_mgmt_t *config;\n    int ret = 0;\n    int ecode = 0;\n\n    if ( loc == FLEXIBLAS_GLOBAL) {\n        fprintf(stderr, \"Enabling global hooks is not allowed.\\n\");\n        exit(-1);\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if (config == NULL) {\n        printf(\"Failed to open configuration files. Abort.\\n\");\n        return 1;\n    }\n\n    if (!  __flexiblas_hook_exists(name)) {\n         printf(\"Hook %s does not exists.\\n\", name);\n         ecode = 1; goto fin;\n    }\n\n    if ( flexiblas_mgmt_hook_enable(config, loc, name)) {\n        printf(\"Enabling hook %s failed.\\n\", name);\n    } else {\n        printf(\"Enable hook %s successful.\\n\", name);\n        ret = flexiblas_mgmt_write_config2(config,loc);\n        if ( ret ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n            ecode = 1; goto fin;\n        }\n    }\n\nfin:\n    flexiblas_mgmt_free_config(config);\n    return ecode;\n}\n\nint  show_hook(char *name)\n{\n    char *sofile;\n    int ecode = 0;\n    void *handle = NULL;\n\n    if (! __flexiblas_hook_exists(name)) {\n         printf(\"No hook named %s is found.\\n\", name);\n         ecode = 1;\n         goto fin;\n    }\n\n    sofile = __flexiblas_hook_sofile(name);\n    if (!sofile) {\n         printf(\"No hook named %s is found.\\n\", name);\n         ecode = 1;\n         goto fin;\n    }\n\n    dlerror();\n    handle = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL, NULL);\n    if ( !handle) {\n        printf(\"Cannot open %s as shared library. (error = %s)\\n\", sofile, dlerror());\n        ecode = 1;\n        goto fin;\n    }\n\n    flexiblas_hook_register_t *reg = (flexiblas_hook_register_t *) dlsym(handle, \"flexiblas_register\");\n\n    printf(\"Name:          %s\\n\", reg->name);\n    printf(\"Configuration: %s\\n\", reg->cfg_name);\n    printf(\"Author(s):     %s\\n\", reg->authors);\n    printf(\"Description:   %s\\n\", reg->desc);\n\n    int cnt = 0;\n    int nopts = 0;\n    flexiblas_option_t *opts = (flexiblas_option_t *) dlsym(handle, \"flexiblas_options\");\n    if ( opts == NULL)\n        nopts = 0;\n    else {\n        cnt = 0;\n        while(opts[cnt].name != NULL) cnt++;\n        nopts = cnt;\n    }\n\n    for (cnt = 0; cnt < nopts; cnt++) {\n        printf(\"\\n\");\n        printf(\"Option:      %s\\n\", opts[cnt].name);\n        printf(\"Description: %s\\n\", opts[cnt].desc);\n        printf(\"Type:        \");\n        switch(opts[cnt].type) {\n            case FLEXIBLAS_OPTIONS_INT:\n                printf(\"Integer\\n\"); break;\n            case FLEXIBLAS_OPTIONS_STRING:\n                printf(\"String\\n\"); break;\n            case FLEXIBLAS_OPTIONS_FLOAT:\n                printf(\"Float\\n\");break;\n            default:\n                ;\n        }\n        printf(\"Default:     %s\\n\", opts[cnt].def);\n    }\nfin:\n    if ( handle != NULL) dlclose(handle);\n    return ecode;\n\n}\n\n\n\n\n\n\nint list_all_hooks()\n{\n    char **list1;\n    char **list2;\n    int nelem;\n    int i;\n\n    if ( !pipe_output ) printf(\"Available hooks:\\n\");\n    __flexiblas_hook_list(&nelem, &list1, &list2);\n    for ( i = 0 ; i < nelem; i++ ) {\n        if (pipe_output) {\n            printf(\"%s|%s\\n\", list1[i], list2[i]);\n        } else {\n            printf(\"  %s (%s)\\n\", list1[i], list2[i]);\n        }\n        free(list1[i]);\n        free(list2[i]);\n    }\n    free(list1);\n    free(list2);\n    return 0;\n\n}\n\nint list_enabled_hooks()\n{\n    int i, j;\n    flexiblas_mgmt_location_t loc;\n    flexiblas_mgmt_t *config;\n    int nelem;\n    char ** list;\n\n    config = flexiblas_mgmt_load_config();\n\n    if ( ! config ) return -1;\n\n    for ( i = 0; i < 3; i++)\n    {\n        if ( i == 0 )\n            loc = FLEXIBLAS_USER;\n        else if ( i == 1 )\n            loc = FLEXIBLAS_HOST;\n        else if ( i == 2 )\n            loc = FLEXIBLAS_ENV;\n\n        if ( flexiblas_mgmt_hook_get_active_internal(config, loc, &nelem, &list))\n            continue;\n\n        if (! pipe_output ) {\n            printf(\"Enabled Hooks in %s:\\n\", flexiblas_mgmt_location_to_string(loc));\n        } else {\n            if ( loc == FLEXIBLAS_USER)\n                printf(\"user|\");\n            else if ( loc == FLEXIBLAS_HOST )\n                printf(\"host|\");\n            else if ( loc == FLEXIBLAS_ENV )\n                printf(\"env|\");\n        }\n\n        for ( j = 0; j < nelem; j++) {\n            if (!pipe_output) {\n                printf(\"- %s\\n\", list[j]);\n            } else {\n                printf(\"%s\", list[j]);\n                if ( j < nelem-1 )\n                    printf(\"|\");\n            }\n            free(list[j]);\n        }\n\n        if (pipe_output) printf(\"\\n\");\n        free(list);\n    }\n\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return 0;\n\n}\n\nint list_active_hooks()\n{\n    int j;\n    flexiblas_mgmt_location_t loc;\n    flexiblas_mgmt_t *config;\n    int nelem;\n    char ** list;\n\n    config = flexiblas_mgmt_load_config();\n\n    if ( ! config ) return -1;\n\n    if ( flexiblas_mgmt_hook_get_active(config, &loc, &nelem, &list))\n    {\n        if ( pipe_output ) printf(\"none\\n\");\n        else printf(\"No hooks enabled.\\n\");\n        return 0;\n    }\n\n    if (! pipe_output ) {\n        printf(\"Currently active hooks from %s:\\n\", flexiblas_mgmt_location_to_string(loc));\n        if ( nelem == 0 ) {\n            printf(\"Hooks are explicitly disabled in the %s configuration.\\n\", flexiblas_mgmt_location_to_string(loc));\n            printf(\"You can remove the setting using the \\\"disableall\\\" subcommand.\\n\");\n        }\n    } else {\n        if ( loc == FLEXIBLAS_USER)\n            printf(\"user|\");\n        else if ( loc == FLEXIBLAS_HOST )\n            printf(\"host|\");\n        else if ( loc == FLEXIBLAS_ENV )\n            printf(\"env|\");\n    }\n\n    for ( j = 0; j < nelem; j++) {\n        if (!pipe_output) {\n            printf(\"- %s\\n\", list[j]);\n        } else {\n            printf(\"%s\", list[j]);\n            if ( j < nelem-1 )\n                printf(\"|\");\n        }\n        free(list[j]);\n    }\n\n    if (pipe_output) printf(\"\\n\");\n    free(list);\n\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return 0;\n\n}\n\n\n\nint hook_option_set(flexiblas_mgmt_location_t loc, char *hookname, char *option, char *value)\n{\n\n    char *sofile;\n    void *handle;\n    flexiblas_hook_register_t *reg = NULL;\n    flexiblas_option_t * opts = NULL;\n    int nopts, i, found;\n    int ecode = 0;\n    char *help;\n    flexiblas_mgmt_t *config = NULL ;\n\n\n\n    if ( ! __flexiblas_hook_exists(hookname)) {\n        printf(\"Hook %s does not exist.\\n\", hookname);\n        return -1;\n    }\n\n    sofile = __flexiblas_hook_sofile(hookname);\n    if (!sofile) {\n         printf(\"No hook named %s is found.\\n\", hookname);\n         return -1;\n    }\n\n    handle = __flexiblas_dlopen(sofile, RTLD_LAZY | RTLD_LOCAL, NULL);\n    if ( !handle) {\n        printf(\"Opening hook %s/%s failed.\\n\", hookname, sofile);\n        return -1;\n    }\n    reg = (flexiblas_hook_register_t *) dlsym(handle, \"flexiblas_register\");\n    opts = (flexiblas_option_t *) dlsym(handle, \"flexiblas_options\");\n\n    if ( reg == NULL) {\n        printf(\"The shared object %s is not a hook.\\n\", sofile);\n        dlclose(handle);\n        return -1;\n    }\n    if ( opts == NULL) {\n        printf(\"The hook %s does not have any options.\\n\", reg->cfg_name);\n        dlclose(handle);\n        return -1;\n    }\n\n    nopts = 0;\n    while(opts[nopts].name != NULL) nopts++;\n\n    found = -1;\n    for (i = 0; i < nopts; i++) {\n        if ( strcmp(opts[i].name, option) == 0 ) {\n            found = i;\n        }\n    }\n    if (found < 0) {\n        printf(\"Option %s not found in hook %s\\n\", option, hookname);\n        dlclose(handle);\n        return -1;\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if ( !config) {\n        printf(\"Failed to load config.\\n\");\n        ecode = -1;\n        goto fin;\n    }\n\n    switch ( opts[found].type) {\n        case FLEXIBLAS_OPTIONS_INT:\n            {\n                int v;\n                help = NULL;\n                v = strtol (value, &help, 10);\n                if ( help && !(help[0] == '\\0')) {\n                    printf(\"The option is required to be an integer but something different was provided. (value = %s, err = '%s')\\n\", value, help);\n                    ecode = 1;\n                    goto fin;\n                }\n                ecode = flexiblas_mgmt_hook_option_set_int(config, loc, reg->cfg_name, option, v);\n            }\n            break;\n        case FLEXIBLAS_OPTIONS_FLOAT:\n            {\n                double v;\n                v = strtod (value, &help);\n                if ( help == value || help[0] != '\\0') {\n                    printf(\"The option is required to be a float but something different was provided. (value = %s, err = '%s')\\n\", value, help);\n                    ecode = 1;\n                    goto fin;\n                }\n                ecode = flexiblas_mgmt_hook_option_set_float(config, loc, reg->cfg_name, option, v);\n            }\n            break;\n        case FLEXIBLAS_OPTIONS_STRING:\n            ecode = flexiblas_mgmt_hook_option_set_string(config, loc, reg->cfg_name, option, value);\n            break;\n        default:\n            ;\n\n    }\n    if (!ecode) {\n        ecode = flexiblas_mgmt_write_config2(config, loc);\n        if ( ecode ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n\n        }\n    }\n\nfin:\n    if ( config ) flexiblas_mgmt_free_config(config);\n    dlclose(handle);\n    return ecode;\n}\n\nint hook_option_unset(flexiblas_mgmt_location_t loc, char *hookname, char *option)\n{\n\n    int ecode = 0;\n    flexiblas_mgmt_t *config = NULL ;\n\n\n\n    if ( ! __flexiblas_hook_exists(hookname)) {\n        printf(\"Hook %s does not exist.\\n\", hookname);\n        return -1;\n    }\n\n    config = flexiblas_mgmt_load_config();\n    if ( !config) {\n        printf(\"Failed to load config.\\n\");\n        ecode = -1;\n        goto fin;\n    }\n\n    ecode = flexiblas_mgmt_hook_option_unset(config, loc, hookname, option);\n    if (ecode == -2) {\n        ecode = 0;\n    }\n\n    if (!ecode) {\n        ecode = flexiblas_mgmt_write_config2(config, loc);\n        if ( ecode ) {\n            printf(\"Failed to write the configuration to %s.\\n\", flexiblas_mgmt_location_to_string(loc));\n\n        }\n    }\n\nfin:\n    if ( config ) flexiblas_mgmt_free_config(config);\n    return ecode;\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.130.1.1 2017/04/19 17:20:42 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** unique key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const int CLIBS = 0;\n\n#define LIB_FAIL\t\"open\"\n\n\n#define setprogdir(L)           ((void)0)\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (lua_CFunction)(p))\n#else\n#define cast_func(p) ((lua_CFunction)(p))\n#endif\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_func(dlsym(lib, sym));\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\n#undef setprogdir\n\n\n/*\n** Replace in the path (on the top of the stack) any occurrence\n** of LUA_EXEC_DIR with the executable's path.\n*/\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);  /* get exec. name */\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';  /* cut name on the last '\\\\' to get the path */\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** {==================================================================\n** Set Paths\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR    \"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR   \"LUA_CPATH\"\n#endif\n\n\n#define AUXMARK         \"\\1\"\t/* auxiliary mark */\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\n/*\n** Set a path\n*/\nstatic void setpath (lua_State *L, const char *fieldname,\n                                   const char *envname,\n                                   const char *dft) {\n  const char *nver = lua_pushfstring(L, \"%s%s\", envname, LUA_VERSUFFIX);\n  const char *path = getenv(nver);  /* use versioned name */\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname);  /* try unversioned name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, dft);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, dft);\n    lua_remove(L, -2); /* remove result from 1st 'gsub' */\n  }\n  setprogdir(L);\n  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n  lua_pop(L, 1);  /* pop versioned variable name */\n}\n\n/* }================================================================== */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file '%s'\", filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, mark - modname);\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  /* push 'package.searchers' to index 3 in the stack */\n  if (lua_getfield(L, lua_upvalueindex(1), \"searchers\") != LUA_TTABLE)\n    luaL_error(L, \"'package.searchers' must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, 2, name);  /* LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, \"'module' not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  if (lua_getfield(L, -1, \"_NAME\") != LUA_TNIL)\n    lua_pop(L, 1);  /* table is an initialized module */\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field 'loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  lua_newtable(L);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set paths */\n  setpath(L, \"path\", LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  setpath(L, \"cpath\", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/tools/lapack_checks/lapack-check.c": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) Martin Koehler, 2016\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"cscutils/strutils.h\"\n\n#include \"lapack-3.0.h\"\n#include \"lapack-3.1.0.h\"\n#include \"lapack-3.1.1.h\"\n#include \"lapack-3.2.0.h\"\n#include \"lapack-3.2.1.h\"\n#include \"lapack-3.2.2.h\"\n#include \"lapack-3.3.0.h\"\n#include \"lapack-3.3.1.h\"\n#include \"lapack-3.4.0.h\"\n#include \"lapack-3.4.1.h\"\n#include \"lapack-3.4.2.h\"\n#include \"lapack-3.5.0.h\"\n#include \"lapack-3.6.0.h\"\n#include \"lapack-3.6.1.h\"\n#include \"lapack-3.7.0.h\"\n#include \"lapack-3.8.0.h\"\n\n#define LAPACK_3_0_0 0x01\n#define LAPACK_3_1_0 0x02\n#define LAPACK_3_1_1 0x03\n#define LAPACK_3_2_0 0x04\n#define LAPACK_3_2_1 0x05\n#define LAPACK_3_2_2 0x06\n#define LAPACK_3_3_0 0x07\n#define LAPACK_3_3_1 0x08\n#define LAPACK_3_4_0 0x09\n#define LAPACK_3_4_1 0x0A\n#define LAPACK_3_4_2 0x0B\n#define LAPACK_3_5_0 0x0C\n#define LAPACK_3_6_0 0x0D\n#define LAPACK_3_6_0_DPRC 0x0E\n#define LAPACK_3_6_1 0x0F\n#define LAPACK_3_6_1_DPRC 0x10\n#define LAPACK_3_7_0 0x11\n#define LAPACK_3_7_0_DPRC 0x12\n#define LAPACK_3_8_0 0x13\n#define LAPACK_3_8_0_DPRC 0x14\n\nchar * lapack_name(int ver) {\n    switch (ver) {\n        case LAPACK_3_0_0:\n            return \"3.0\";\n        case LAPACK_3_1_0:\n            return \"3.1.0\";\n        case LAPACK_3_1_1:\n            return \"3.1.1\";\n        case LAPACK_3_2_0:\n            return \"3.2.0\";\n        case LAPACK_3_2_1:\n            return \"3.2.1\";\n        case LAPACK_3_2_2:\n            return \"3.2.2\";\n        case LAPACK_3_3_0:\n            return \"3.3.0\";\n        case LAPACK_3_3_1:\n            return \"3.3.1\";\n        case LAPACK_3_4_0:\n            return \"3.4.0\";\n        case LAPACK_3_4_1:\n            return \"3.4.1\";\n        case LAPACK_3_4_2:\n            return \"3.4.2\";\n        case LAPACK_3_5_0:\n            return \"3.5.0\";\n        case LAPACK_3_6_0:\n            return \"3.6.0\";\n        case LAPACK_3_6_0_DPRC:\n            return \"3.6.0-DPRC\";\n        case LAPACK_3_6_1:\n            return \"3.6.1\";\n        case LAPACK_3_6_1_DPRC:\n            return \"3.6.1-DPRC\";\n        case LAPACK_3_7_0:\n            return \"3.7.0\";\n        case LAPACK_3_7_0_DPRC:\n            return \"3.7.0-DPRC\";\n        case LAPACK_3_8_0:\n            return \"3.8.0\";\n        case LAPACK_3_8_0_DPRC:\n            return \"3.8.0-DPRC\";\n\n        default:\n            return \"X.X.X\";\n    }\n    return \"X.X.X\";\n}\n\n\n\nchar *ignore_list [] = {\n    \"dlamc1\",\n    \"dlamc2\",\n    \"dlamc3\",\n    \"dlamc4\",\n    \"dlamc5\",\n    \"slamc1\",\n    \"slamc2\",\n    \"slamc3\",\n    \"slamc4\",\n    \"slamc5\",\n    \"dlasd9\",    /* Old relict from LAPACK < 3.0 but existing in 3.0  although not needed. */\n    \"slasd9\",\n    NULL\n};\n\nint is_in_list(char **haystack, char *needle)\n{\n    int i = 0;\n    while(haystack[i] != NULL) {\n        if (csc_strcasecmp(haystack[i], needle) == 0 ) return -1;\n        i++;\n    }\n    return 0;\n}\n\nvoid check_symbols(char **list, void *lib, int *found, int *missing, int *ignore)\n{\n    int i;\n    char name[128];\n    i = 0;\n    *found = 0;\n    *missing = 0;\n    *ignore = 0;\n\n\n    while ( list[i] != NULL )\n    {\n        void *sym1, *sym2;\n        snprintf(name, 128, \"%s_\", list[i]);\n        sym1 = dlsym ( lib, list[i] );\n        sym2 = dlsym ( lib, name );\n        if ( sym1 == NULL && sym2 == NULL) {\n            if ( ! is_in_list(ignore_list, list[i]) ) {\n                *missing = *missing +1;\n                printf(\"MISS : %s\\n\", list[i]);\n            } else {\n                *ignore = *ignore +1;\n                // printf(\"IGNORE: %s\\n\", list[i]);\n            }\n        } else {\n            *found = *found +1;\n            // printf(\"FOUND: %s at %lx\\n\", list[i], (long unsigned int) ((sym1==NULL)?sym2:sym1));\n        }\n        i++;\n    }\n}\n\nint main(int argc, char **argv)\n{\n    void *ptr;\n    int f = 0;\n    int m = 0;\n    int ign = 0;\n    char **symbolset;\n    int lapack_number;\n    int lapack_save = -1;\n\n\n    if ( argc != 2 )\n    {\n        printf(\"Usage: %s <sofile>\\n\", argv[0]);\n        return -1;\n    }\n\n    ptr = dlopen(argv[1], RTLD_LOCAL | RTLD_LAZY);\n    if ( ptr == NULL ) {\n        printf(\"Failed to open :%s\\n\", argv[1]);\n        return -1;\n    }\n    for (lapack_number = 1; lapack_number <= LAPACK_3_7_0_DPRC; lapack_number++) {\n        switch(lapack_number) {\n            case LAPACK_3_0_0:\n                symbolset = lapack_3_0;\n                break;\n            case LAPACK_3_1_0:\n                symbolset = lapack_3_1_0;\n                break;\n            case LAPACK_3_1_1:\n                symbolset = lapack_3_1_1;\n                break;\n            case LAPACK_3_2_0:\n                symbolset = lapack_3_2_0;\n                break;\n            case LAPACK_3_2_1:\n                symbolset = lapack_3_2_1;\n                break;\n            case LAPACK_3_2_2:\n                symbolset = lapack_3_2_2;\n                break;\n            case LAPACK_3_3_0:\n                symbolset = lapack_3_3_0;\n                break;\n            case LAPACK_3_3_1:\n                symbolset = lapack_3_3_1;\n                break;\n            case LAPACK_3_4_0:\n                symbolset = lapack_3_4_0;\n                break;\n            case LAPACK_3_4_1:\n                symbolset = lapack_3_4_1;\n                break;\n            case LAPACK_3_4_2:\n                symbolset = lapack_3_4_2;\n                break;\n            case LAPACK_3_5_0:\n                symbolset = lapack_3_5_0;\n                break;\n            case LAPACK_3_6_0_DPRC:\n                symbolset = lapack_3_6_0_full;\n                break;\n            case LAPACK_3_6_0:\n                symbolset = lapack_3_6_0;\n                break;\n            case LAPACK_3_6_1_DPRC:\n                symbolset = lapack_3_6_1_full;\n                break;\n            case LAPACK_3_6_1:\n                symbolset = lapack_3_6_1;\n                break;\n            case LAPACK_3_7_0_DPRC:\n                symbolset = lapack_3_7_0_full;\n                break;\n            case LAPACK_3_7_0:\n                symbolset = lapack_3_7_0;\n                break;\n            case LAPACK_3_8_0_DPRC:\n                symbolset = lapack_3_8_0_full;\n                break;\n            case LAPACK_3_8_0:\n                symbolset = lapack_3_8_0;\n                break;\n\n            default:\n                symbolset = NULL;\n\n        }\n\n        printf(\"Check for LAPACK %s\\n\", lapack_name(lapack_number));\n        check_symbols(symbolset, ptr, &f, &m, &ign);\n\n        if ( m == 0 ) {\n            lapack_save = lapack_number;\n        }\n\n        printf(\"%s - f = %d \\t m = %d\\n\", argv[1], f, m );\n\n    }\n\n    if ( lapack_save > 0 ) {\n        printf(\"%s is compatible to LAPACK %s\\n\", argv[1], lapack_name(lapack_save));\n    }\n\n    dlclose(ptr);\n    return 0;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.9.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.9.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.6.1/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.6.1/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.7.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.7.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.8.0/DOCS/lapack.png",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/contributed/lapack-3.8.0/DOCS/lapacke.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-flexiblas-3.0.3-s2625bmdiejx64iyoyyslucnzrbzkcw3/spack-src/libcscutils/contrib/lua/doc/osi-certified-72x60.png"
    ],
    "total_files": 16005
}