{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/tutorial/ndimage.rst": "Multidimensional image processing (`scipy.ndimage`)\n====================================================\n\n.. moduleauthor:: Peter Verveer <verveer@users.sourceforge.net>\n\n.. currentmodule:: scipy.ndimage\n\n.. _ndimage-introduction:\n\nIntroduction\n------------\n\nImage processing and analysis are generally seen as operations on\n2-D arrays of values. There are, however, a number of\nfields where images of higher dimensionality must be analyzed. Good\nexamples of these are medical imaging and biological imaging.\n:mod:`numpy` is suited very well for this type of applications due to\nits inherent multidimensional nature. The :mod:`scipy.ndimage`\npackages provides a number of general image processing and analysis\nfunctions that are designed to operate with arrays of arbitrary\ndimensionality. The packages currently includes: functions for\nlinear and non-linear filtering, binary morphology, B-spline\ninterpolation, and object measurements.\n\n.. _ndimage-properties-shared-by-all-functions:\n\nProperties shared by all functions\n----------------------------------\n\nAll functions share some common properties. Notably, all functions\nallow the specification of an output array with the *output*\nargument. With this argument, you can specify an array that will be\nchanged in-place with the result with the operation. In this case,\nthe result is not returned. Usually, using the *output* argument is\nmore efficient, since an existing array is used to store the\nresult.\n\nThe type of arrays returned is dependent on the type of operation,\nbut it is, in most cases, equal to the type of the input. If,\nhowever, the *output* argument is used, the type of the result is\nequal to the type of the specified output argument. If no output\nargument is given, it is still possible to specify what the result\nof the output should be. This is done by simply assigning the\ndesired `numpy` type object to the output argument. For example:\n\n.. code:: python\n\n    >>> from scipy.ndimage import correlate\n    >>> correlate(np.arange(10), [1, 2.5])\n    array([ 0,  2,  6,  9, 13, 16, 20, 23, 27, 30])\n    >>> correlate(np.arange(10), [1, 2.5], output=np.float64)\n    array([  0. ,   2.5,   6. ,   9.5,  13. ,  16.5,  20. ,  23.5,  27. ,  30.5])\n\n.. _ndimage-filter-functions:\n\nFilter functions\n----------------\n\nThe functions described in this section all perform some type of spatial\nfiltering of the input array: the elements in the output are some function\nof the values in the neighborhood of the corresponding input element. We refer\nto this neighborhood of elements as the filter kernel, which is often\nrectangular in shape but may also have an arbitrary footprint. Many\nof the functions described below allow you to define the footprint\nof the kernel by passing a mask through the *footprint* parameter.\nFor example, a cross-shaped kernel can be defined as follows:\n\n.. code:: python\n\n    >>> footprint = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    >>> footprint\n    array([[0, 1, 0],\n           [1, 1, 1],\n           [0, 1, 0]])\n\nUsually, the origin of the kernel is at the center calculated by\ndividing the dimensions of the kernel shape by two. For instance,\nthe origin of a 1-D kernel of length three is at the\nsecond element. Take, for example, the correlation of a\n1-D array with a filter of length 3 consisting of\nones:\n\n.. code:: python\n\n    >>> from scipy.ndimage import correlate1d\n    >>> a = [0, 0, 0, 1, 0, 0, 0]\n    >>> correlate1d(a, [1, 1, 1])\n    array([0, 0, 1, 1, 1, 0, 0])\n\nSometimes, it is convenient to choose a different origin for the\nkernel. For this reason, most functions support the *origin*\nparameter, which gives the origin of the filter relative to its\ncenter. For example:\n\n.. code:: python\n\n    >>> a = [0, 0, 0, 1, 0, 0, 0]\n    >>> correlate1d(a, [1, 1, 1], origin = -1)\n    array([0, 1, 1, 1, 0, 0, 0])\n\nThe effect is a shift of the result towards the left. This feature\nwill not be needed very often, but it may be useful, especially for\nfilters that have an even size. A good example is the calculation\nof backward and forward differences:\n\n.. code:: python\n\n    >>> a = [0, 0, 1, 1, 1, 0, 0]\n    >>> correlate1d(a, [-1, 1])               # backward difference\n    array([ 0,  0,  1,  0,  0, -1,  0])\n    >>> correlate1d(a, [-1, 1], origin = -1)  # forward difference\n    array([ 0,  1,  0,  0, -1,  0,  0])\n\nWe could also have calculated the forward difference as follows:\n\n.. code:: python\n\n    >>> correlate1d(a, [0, -1, 1])\n    array([ 0,  1,  0,  0, -1,  0,  0])\n\nHowever, using the origin parameter instead of a larger kernel is\nmore efficient. For multidimensional kernels, *origin* can be a\nnumber, in which case the origin is assumed to be equal along all\naxes, or a sequence giving the origin along each axis.\n\nSince the output elements are a function of elements in the\nneighborhood of the input elements, the borders of the array need to\nbe dealt with appropriately by providing the values outside the\nborders. This is done by assuming that the arrays are extended beyond\ntheir boundaries according to certain boundary conditions. In the\nfunctions described below, the boundary conditions can be selected\nusing the *mode* parameter, which must be a string with the name of the\nboundary condition. The following boundary conditions are currently\nsupported:\n\n ==========   ====================================   ====================\n \"nearest\"    use the value at the boundary          [1 2 3]->[1 1 2 3 3]\n \"wrap\"       periodically replicate the array       [1 2 3]->[3 1 2 3 1]\n \"reflect\"    reflect the array at the boundary      [1 2 3]->[1 1 2 3 3]\n \"constant\"   use a constant value, default is 0.0   [1 2 3]->[0 1 2 3 0]\n ==========   ====================================   ====================\n\nThe \"constant\" mode is special since it needs an additional\nparameter to specify the constant value that should be used.\n\n.. note::\n\n   The easiest way to implement such boundary conditions would be to\n   copy the data to a larger array and extend the data at the borders\n   according to the boundary conditions. For large arrays and large\n   filter kernels, this would be very memory consuming, and the\n   functions described below, therefore, use a different approach that\n   does not require allocating large temporary buffers.\n\nCorrelation and convolution\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- The :func:`correlate1d` function calculates a 1-D\n  correlation along the given axis. The lines of the array along the\n  given axis are correlated with the given *weights*. The *weights*\n  parameter must be a 1-D sequence of numbers.\n\n- The function :func:`correlate` implements multidimensional\n  correlation of the input array with a given kernel.\n\n- The :func:`convolve1d` function calculates a 1-D\n  convolution along the given axis. The lines of the array along the\n  given axis are convoluted with the given *weights*. The *weights*\n  parameter must be a 1-D sequence of numbers.\n\n- The function :func:`convolve` implements multidimensional\n  convolution of the input array with a given kernel.\n\n  .. note::\n\n     A convolution is essentially a correlation after mirroring the\n     kernel. As a result, the *origin* parameter behaves differently\n     than in the case of a correlation: the results is shifted in the\n     opposite direction.\n\n.. _ndimage-filter-functions-smoothing:\n\nSmoothing filters\n^^^^^^^^^^^^^^^^^\n\n- The :func:`gaussian_filter1d` function implements a 1-D\n  Gaussian filter. The standard deviation of the Gaussian filter is\n  passed through the parameter *sigma*. Setting *order* = 0\n  corresponds to convolution with a Gaussian kernel. An order of 1, 2,\n  or 3 corresponds to convolution with the first, second, or third\n  derivatives of a Gaussian. Higher-order derivatives are not\n  implemented.\n\n- The :func:`gaussian_filter` function implements a multidimensional\n  Gaussian filter. The standard deviations of the Gaussian filter\n  along each axis are passed through the parameter *sigma* as a\n  sequence or numbers. If *sigma* is not a sequence but a single\n  number, the standard deviation of the filter is equal along all\n  directions. The order of the filter can be specified separately for\n  each axis. An order of 0 corresponds to convolution with a Gaussian\n  kernel. An order of 1, 2, or 3 corresponds to convolution with the\n  first, second, or third derivatives of a Gaussian. Higher-order\n  derivatives are not implemented. The *order* parameter must be a\n  number, to specify the same order for all axes, or a sequence of\n  numbers to specify a different order for each axis.\n\n  .. note::\n\n     The multidimensional filter is implemented as a sequence of\n     1-D Gaussian filters. The intermediate arrays are\n     stored in the same data type as the output. Therefore, for\n     output types with a lower precision, the results may be imprecise\n     because intermediate results may be stored with insufficient\n     precision. This can be prevented by specifying a more precise\n     output type.\n\n- The :func:`uniform_filter1d` function calculates a 1-D\n  uniform filter of the given *size* along the given axis.\n\n- The :func:`uniform_filter` implements a multidimensional uniform\n  filter. The sizes of the uniform filter are given for each axis as a\n  sequence of integers by the *size* parameter. If *size* is not a\n  sequence, but a single number, the sizes along all axes are assumed\n  to be equal.\n\n  .. note::\n\n     The multidimensional filter is implemented as a sequence of\n     1-D uniform filters. The intermediate arrays are\n     stored in the same data type as the output. Therefore, for output\n     types with a lower precision, the results may be imprecise\n     because intermediate results may be stored with insufficient\n     precision. This can be prevented by specifying a more precise\n     output type.\n\nFilters based on order statistics\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- The :func:`minimum_filter1d` function calculates a 1-D\n  minimum filter of the given *size* along the given axis.\n\n- The :func:`maximum_filter1d` function calculates a 1-D\n  maximum filter of the given *size* along the given axis.\n\n- The :func:`minimum_filter` function calculates a multidimensional\n  minimum filter. Either the sizes of a rectangular kernel or the\n  footprint of the kernel must be provided. The *size* parameter, if\n  provided, must be a sequence of sizes or a single number, in which\n  case the size of the filter is assumed to be equal along each axis.\n  The *footprint*, if provided, must be an array that defines the\n  shape of the kernel by its non-zero elements.\n\n- The :func:`maximum_filter` function calculates a multidimensional\n  maximum filter. Either the sizes of a rectangular kernel or the\n  footprint of the kernel must be provided. The *size* parameter, if\n  provided, must be a sequence of sizes or a single number, in which\n  case the size of the filter is assumed to be equal along each axis.\n  The *footprint*, if provided, must be an array that defines the\n  shape of the kernel by its non-zero elements.\n\n- The :func:`rank_filter` function calculates a multidimensional rank\n  filter. The *rank* may be less then zero, i.e., *rank* = -1\n  indicates the largest element. Either the sizes of a rectangular\n  kernel or the footprint of the kernel must be provided. The *size*\n  parameter, if provided, must be a sequence of sizes or a single\n  number, in which case the size of the filter is assumed to be equal\n  along each axis. The *footprint*, if provided, must be an array that\n  defines the shape of the kernel by its non-zero elements.\n\n- The :func:`percentile_filter` function calculates a multidimensional\n  percentile filter. The *percentile* may be less then zero, i.e.,\n  *percentile* = -20 equals *percentile* = 80. Either the sizes of a\n  rectangular kernel or the footprint of the kernel must be provided.\n  The *size* parameter, if provided, must be a sequence of sizes or a\n  single number, in which case the size of the filter is assumed to be\n  equal along each axis. The *footprint*, if provided, must be an\n  array that defines the shape of the kernel by its non-zero elements.\n\n- The :func:`median_filter` function calculates a multidimensional\n  median filter. Either the sizes of a rectangular kernel or the\n  footprint of the kernel must be provided. The *size* parameter, if\n  provided, must be a sequence of sizes or a single number, in which\n  case the size of the filter is assumed to be equal along each\n  axis. The *footprint* if provided, must be an array that defines the\n  shape of the kernel by its non-zero elements.\n\nDerivatives\n^^^^^^^^^^^\n\nDerivative filters can be constructed in several ways. The function\n:func:`gaussian_filter1d`, described in\n:ref:`ndimage-filter-functions-smoothing`, can be used to calculate\nderivatives along a given axis using the *order* parameter. Other\nderivative filters are the Prewitt and Sobel filters:\n\n- The :func:`prewitt` function calculates a derivative along the given\n  axis.\n- The :func:`sobel` function calculates a derivative along the given\n  axis.\n\nThe Laplace filter is calculated by the sum of the second derivatives\nalong all axes. Thus, different Laplace filters can be constructed\nusing different second-derivative functions. Therefore, we provide a\ngeneral function that takes a function argument to calculate the\nsecond derivative along a given direction.\n\n- The function :func:`generic_laplace` calculates a Laplace filter\n  using the function passed through ``derivative2`` to calculate\n  second derivatives. The function ``derivative2`` should have the\n  following signature\n\n  .. code:: python\n\n     derivative2(input, axis, output, mode, cval, *extra_arguments, **extra_keywords)\n\n  It should calculate the second derivative along the dimension\n  *axis*. If *output* is not ``None``, it should use that for the\n  output and return ``None``, otherwise it should return the\n  result. *mode*, *cval* have the usual meaning.\n\n  The *extra_arguments* and *extra_keywords* arguments can be used\n  to pass a tuple of extra arguments and a dictionary of named\n  arguments that are passed to ``derivative2`` at each call.\n\n  For example\n\n  .. code:: python\n\n     >>> def d2(input, axis, output, mode, cval):\n     ...     return correlate1d(input, [1, -2, 1], axis, output, mode, cval, 0)\n     ...\n     >>> a = np.zeros((5, 5))\n     >>> a[2, 2] = 1\n     >>> from scipy.ndimage import generic_laplace\n     >>> generic_laplace(a, d2)\n     array([[ 0.,  0.,  0.,  0.,  0.],\n\t    [ 0.,  0.,  1.,  0.,  0.],\n\t    [ 0.,  1., -4.,  1.,  0.],\n            [ 0.,  0.,  1.,  0.,  0.],\n            [ 0.,  0.,  0.,  0.,  0.]])\n\n  To demonstrate the use of the *extra_arguments* argument, we could do\n\n  .. code:: python\n\n     >>> def d2(input, axis, output, mode, cval, weights):\n     ...     return correlate1d(input, weights, axis, output, mode, cval, 0,)\n     ...\n     >>> a = np.zeros((5, 5))\n     >>> a[2, 2] = 1\n     >>> generic_laplace(a, d2, extra_arguments = ([1, -2, 1],))\n     array([[ 0.,  0.,  0.,  0.,  0.],\n\t    [ 0.,  0.,  1.,  0.,  0.],\n            [ 0.,  1., -4.,  1.,  0.],\n            [ 0.,  0.,  1.,  0.,  0.],\n            [ 0.,  0.,  0.,  0.,  0.]])\n\n  or\n\n  .. code:: python\n\n     >>> generic_laplace(a, d2, extra_keywords = {'weights': [1, -2, 1]})\n     array([[ 0.,  0.,  0.,  0.,  0.],\n\t    [ 0.,  0.,  1.,  0.,  0.],\n\t    [ 0.,  1., -4.,  1.,  0.],\n\t    [ 0.,  0.,  1.,  0.,  0.],\n\t    [ 0.,  0.,  0.,  0.,  0.]])\n\nThe following two functions are implemented using\n:func:`generic_laplace` by providing appropriate functions for the\nsecond-derivative function:\n\n- The function :func:`laplace` calculates the Laplace using discrete\n  differentiation for the second derivative (i.e., convolution with\n  ``[1, -2, 1]``).\n\n- The function :func:`gaussian_laplace` calculates the Laplace filter\n  using :func:`gaussian_filter` to calculate the second\n  derivatives. The standard deviations of the Gaussian filter along\n  each axis are passed through the parameter *sigma* as a sequence or\n  numbers. If *sigma* is not a sequence but a single number, the\n  standard deviation of the filter is equal along all directions.\n\nThe gradient magnitude is defined as the square root of the sum of the\nsquares of the gradients in all directions. Similar to the generic\nLaplace function, there is a :func:`generic_gradient_magnitude`\nfunction that calculates the gradient magnitude of an array.\n\n- The function :func:`generic_gradient_magnitude` calculates a\n  gradient magnitude using the function passed through\n  ``derivative`` to calculate first derivatives. The function\n  ``derivative`` should have the following signature\n\n  .. code:: python\n\n     derivative(input, axis, output, mode, cval, *extra_arguments, **extra_keywords)\n\n  It should calculate the derivative along the dimension *axis*. If\n  *output* is not ``None``, it should use that for the output and return\n  ``None``, otherwise it should return the result. *mode*, *cval* have the\n  usual meaning.\n\n  The *extra_arguments* and *extra_keywords* arguments can be used to\n  pass a tuple of extra arguments and a dictionary of named arguments\n  that are passed to *derivative* at each call.\n\n  For example, the :func:`sobel` function fits the required signature\n\n  .. code:: python\n\n     >>> a = np.zeros((5, 5))\n     >>> a[2, 2] = 1\n     >>> from scipy.ndimage import sobel, generic_gradient_magnitude\n     >>> generic_gradient_magnitude(a, sobel)\n     array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ],\n\t    [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],\n            [ 0.        ,  2.        ,  0.        ,  2.        ,  0.        ],\n            [ 0.        ,  1.41421356,  2.        ,  1.41421356,  0.        ],\n            [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])\n\n  See the documentation of :func:`generic_laplace` for examples of\n  using the *extra_arguments* and *extra_keywords* arguments.\n\nThe :func:`sobel` and :func:`prewitt` functions fit the required\nsignature and can, therefore, be used directly with\n:func:`generic_gradient_magnitude`.\n\n- The function :func:`gaussian_gradient_magnitude` calculates the\n  gradient magnitude using :func:`gaussian_filter` to calculate the\n  first derivatives. The standard deviations of the Gaussian filter\n  along each axis are passed through the parameter *sigma* as a\n  sequence or numbers. If *sigma* is not a sequence but a single\n  number, the standard deviation of the filter is equal along all\n  directions.\n\n.. _ndimage-genericfilters:\n\nGeneric filter functions\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo implement filter functions, generic functions can be used that\naccept a callable object that implements the filtering operation. The\niteration over the input and output arrays is handled by these generic\nfunctions, along with such details as the implementation of the\nboundary conditions. Only a callable object implementing a callback\nfunction that does the actual filtering work must be provided. The\ncallback function can also be written in C and passed using a\n:c:type:`PyCapsule` (see :ref:`ndimage-ccallbacks` for more\ninformation).\n\n- The :func:`generic_filter1d` function implements a generic\n  1-D filter function, where the actual filtering\n  operation must be supplied as a python function (or other callable\n  object). The :func:`generic_filter1d` function iterates over the\n  lines of an array and calls ``function`` at each line. The\n  arguments that are passed to ``function`` are 1-D\n  arrays of the ``numpy.float64`` type. The first contains the values\n  of the current line. It is extended at the beginning and the end,\n  according to the *filter_size* and *origin* arguments. The second\n  array should be modified in-place to provide the output values of\n  the line. For example, consider a correlation along one dimension:\n\n  .. code:: python\n\n     >>> a = np.arange(12).reshape(3,4)\n     >>> correlate1d(a, [1, 2, 3])\n     array([[ 3,  8, 14, 17],\n\t    [27, 32, 38, 41],\n            [51, 56, 62, 65]])\n\n  The same operation can be implemented using :func:`generic_filter1d`,\n  as follows:\n\n  .. code:: python\n\n     >>> def fnc(iline, oline):\n     ...     oline[...] = iline[:-2] + 2 * iline[1:-1] + 3 * iline[2:]\n     ...\n     >>> from scipy.ndimage import generic_filter1d\n     >>> generic_filter1d(a, fnc, 3)\n     array([[ 3,  8, 14, 17],\n\t    [27, 32, 38, 41],\n            [51, 56, 62, 65]])\n\n  Here, the origin of the kernel was (by default) assumed to be in the\n  middle of the filter of length 3. Therefore, each input line had been\n  extended by one value at the beginning and at the end, before the\n  function was called.\n\n  Optionally, extra arguments can be defined and passed to the filter\n  function. The *extra_arguments* and *extra_keywords* arguments can\n  be used to pass a tuple of extra arguments and/or a dictionary of\n  named arguments that are passed to derivative at each call. For\n  example, we can pass the parameters of our filter as an argument\n\n  .. code:: python\n\n     >>> def fnc(iline, oline, a, b):\n     ...     oline[...] = iline[:-2] + a * iline[1:-1] + b * iline[2:]\n     ...\n     >>> generic_filter1d(a, fnc, 3, extra_arguments = (2, 3))\n     array([[ 3,  8, 14, 17],\n\t    [27, 32, 38, 41],\n            [51, 56, 62, 65]])\n\n  or\n\n  .. code:: python\n\n     >>> generic_filter1d(a, fnc, 3, extra_keywords = {'a':2, 'b':3})\n     array([[ 3,  8, 14, 17],\n\t    [27, 32, 38, 41],\n            [51, 56, 62, 65]])\n\n- The :func:`generic_filter` function implements a generic filter\n  function, where the actual filtering operation must be supplied as a\n  python function (or other callable object). The\n  :func:`generic_filter` function iterates over the array and calls\n  ``function`` at each element. The argument of ``function``\n  is a 1-D array of the ``numpy.float64`` type that\n  contains the values around the current element that are within the\n  footprint of the filter. The function should return a single value\n  that can be converted to a double precision number. For example,\n  consider a correlation:\n\n  .. code:: python\n\n     >>> a = np.arange(12).reshape(3,4)\n     >>> correlate(a, [[1, 0], [0, 3]])\n     array([[ 0,  3,  7, 11],\n\t    [12, 15, 19, 23],\n            [28, 31, 35, 39]])\n\n  The same operation can be implemented using *generic_filter*, as\n  follows:\n\n  .. code:: python\n\n     >>> def fnc(buffer):\n     ...     return (buffer * np.array([1, 3])).sum()\n     ...\n     >>> from scipy.ndimage import generic_filter\n     >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]])\n     array([[ 0,  3,  7, 11],\n\t    [12, 15, 19, 23],\n            [28, 31, 35, 39]])\n\n  Here, a kernel footprint was specified that contains only two\n  elements. Therefore, the filter function receives a buffer of length\n  equal to two, which was multiplied with the proper weights and the\n  result summed.\n\n  When calling :func:`generic_filter`, either the sizes of a\n  rectangular kernel or the footprint of the kernel must be\n  provided. The *size* parameter, if provided, must be a sequence of\n  sizes or a single number, in which case the size of the filter is\n  assumed to be equal along each axis. The *footprint*, if provided,\n  must be an array that defines the shape of the kernel by its\n  non-zero elements.\n\n  Optionally, extra arguments can be defined and passed to the filter\n  function. The *extra_arguments* and *extra_keywords* arguments can\n  be used to pass a tuple of extra arguments and/or a dictionary of\n  named arguments that are passed to derivative at each call. For\n  example, we can pass the parameters of our filter as an argument\n\n  .. code:: python\n\n     >>> def fnc(buffer, weights):\n     ...     weights = np.asarray(weights)\n     ...     return (buffer * weights).sum()\n     ...\n     >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]], extra_arguments = ([1, 3],))\n     array([[ 0,  3,  7, 11],\n\t    [12, 15, 19, 23],\n            [28, 31, 35, 39]])\n\n  or\n\n  .. code:: python\n\n     >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]], extra_keywords= {'weights': [1, 3]})\n     array([[ 0,  3,  7, 11],\n\t    [12, 15, 19, 23],\n\t    [28, 31, 35, 39]])\n\nThese functions iterate over the lines or elements starting at the\nlast axis, i.e., the last index changes the fastest. This order of\niteration is guaranteed for the case that it is important to adapt the\nfilter depending on spatial location. Here is an example of using a\nclass that implements the filter and keeps track of the current\ncoordinates while iterating. It performs the same filter operation as\ndescribed above for :func:`generic_filter`, but additionally prints\nthe current coordinates:\n\n.. code:: python\n\n   >>> a = np.arange(12).reshape(3,4)\n   >>>\n   >>> class fnc_class:\n   ...     def __init__(self, shape):\n   ...         # store the shape:\n   ...         self.shape = shape\n   ...         # initialize the coordinates:\n   ...         self.coordinates = [0] * len(shape)\n   ...\n   ...     def filter(self, buffer):\n   ...         result = (buffer * np.array([1, 3])).sum()\n   ...         print(self.coordinates)\n   ...         # calculate the next coordinates:\n   ...         axes = list(range(len(self.shape)))\n   ...         axes.reverse()\n   ...         for jj in axes:\n   ...             if self.coordinates[jj] < self.shape[jj] - 1:\n   ...                 self.coordinates[jj] += 1\n   ...                 break\n   ...             else:\n   ...                 self.coordinates[jj] = 0\n   ...         return result\n   ...\n   >>> fnc = fnc_class(shape = (3,4))\n   >>> generic_filter(a, fnc.filter, footprint = [[1, 0], [0, 1]])\n   [0, 0]\n   [0, 1]\n   [0, 2]\n   [0, 3]\n   [1, 0]\n   [1, 1]\n   [1, 2]\n   [1, 3]\n   [2, 0]\n   [2, 1]\n   [2, 2]\n   [2, 3]\n   array([[ 0,  3,  7, 11],\n\t  [12, 15, 19, 23],\n\t  [28, 31, 35, 39]])\n\nFor the :func:`generic_filter1d` function, the same approach works,\nexcept that this function does not iterate over the axis that is being\nfiltered. The example for :func:`generic_filter1d` then becomes this:\n\n.. code:: python\n\n   >>> a = np.arange(12).reshape(3,4)\n   >>>\n   >>> class fnc1d_class:\n   ...     def __init__(self, shape, axis = -1):\n   ...         # store the filter axis:\n   ...         self.axis = axis\n   ...         # store the shape:\n   ...         self.shape = shape\n   ...         # initialize the coordinates:\n   ...         self.coordinates = [0] * len(shape)\n   ...\n   ...     def filter(self, iline, oline):\n   ...         oline[...] = iline[:-2] + 2 * iline[1:-1] + 3 * iline[2:]\n   ...         print(self.coordinates)\n   ...         # calculate the next coordinates:\n   ...         axes = list(range(len(self.shape)))\n   ...         # skip the filter axis:\n   ...         del axes[self.axis]\n   ...         axes.reverse()\n   ...         for jj in axes:\n   ...             if self.coordinates[jj] < self.shape[jj] - 1:\n   ...                 self.coordinates[jj] += 1\n   ...                 break\n   ...             else:\n   ...                 self.coordinates[jj] = 0\n   ...\n   >>> fnc = fnc1d_class(shape = (3,4))\n   >>> generic_filter1d(a, fnc.filter, 3)\n   [0, 0]\n   [1, 0]\n   [2, 0]\n   array([[ 3,  8, 14, 17],\n\t  [27, 32, 38, 41],\n          [51, 56, 62, 65]])\n\nFourier domain filters\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe functions described in this section perform filtering\noperations in the Fourier domain. Thus, the input array of such a\nfunction should be compatible with an inverse Fourier transform\nfunction, such as the functions from the :mod:`numpy.fft` module. We,\ntherefore, have to deal with arrays that may be the result of a real\nor a complex Fourier transform. In the case of a real Fourier\ntransform, only half of the of the symmetric complex transform is\nstored. Additionally, it needs to be known what the length of the\naxis was that was transformed by the real fft. The functions\ndescribed here provide a parameter *n* that, in the case of a real\ntransform, must be equal to the length of the real transform axis\nbefore transformation. If this parameter is less than zero, it is\nassumed that the input array was the result of a complex Fourier\ntransform. The parameter *axis* can be used to indicate along which\naxis the real transform was executed.\n\n- The :func:`fourier_shift` function multiplies the input array with\n  the multidimensional Fourier transform of a shift operation for the\n  given shift. The *shift* parameter is a sequence of shifts for each\n  dimension or a single value for all dimensions.\n\n- The :func:`fourier_gaussian` function multiplies the input array\n  with the multidimensional Fourier transform of a Gaussian filter\n  with given standard deviations *sigma*. The *sigma* parameter is a\n  sequence of values for each dimension or a single value for all\n  dimensions.\n\n- The :func:`fourier_uniform` function multiplies the input array with\n  the multidimensional Fourier transform of a uniform filter with\n  given sizes *size*. The *size* parameter is a sequence of values\n  for each dimension or a single value for all dimensions.\n\n- The :func:`fourier_ellipsoid` function multiplies the input array\n  with the multidimensional Fourier transform of an elliptically-shaped\n  filter with given sizes *size*. The *size* parameter is a sequence\n  of values for each dimension or a single value for all dimensions.\n  This function is only implemented for dimensions 1, 2, and 3.\n\n.. _ndimage-interpolation:\n\nInterpolation functions\n-----------------------\n\nThis section describes various interpolation functions that are based\non B-spline theory. A good introduction to B-splines can be found\nin [1]_.\n\nSpline pre-filters\n^^^^^^^^^^^^^^^^^^\n\nInterpolation using splines of an order larger than 1 requires a\npre-filtering step. The interpolation functions described in section\n:ref:`ndimage-interpolation` apply pre-filtering by calling\n:func:`spline_filter`, but they can be instructed not to do this by\nsetting the *prefilter* keyword equal to False. This is useful if more\nthan one interpolation operation is done on the same array. In this\ncase, it is more efficient to do the pre-filtering only once and use a\npre-filtered array as the input of the interpolation functions. The\nfollowing two functions implement the pre-filtering:\n\n- The :func:`spline_filter1d` function calculates a 1-D\n  spline filter along the given axis. An output array can optionally\n  be provided. The order of the spline must be larger than 1 and less\n  than 6.\n\n- The :func:`spline_filter` function calculates a multidimensional\n  spline filter.\n\n  .. note::\n\n     The multidimensional filter is implemented as a sequence of\n     1-D spline filters. The intermediate arrays are\n     stored in the same data type as the output. Therefore, if an\n     output with a limited precision is requested, the results may be\n     imprecise because intermediate results may be stored with\n     insufficient precision. This can be prevented by specifying a\n     output type of high precision.\n\nInterpolation functions\n^^^^^^^^^^^^^^^^^^^^^^^\n\nThe following functions all employ spline interpolation to effect some\ntype of geometric transformation of the input array. This requires a\nmapping of the output coordinates to the input coordinates, and\ntherefore, the possibility arises that input values outside the\nboundaries may be needed. This problem is solved in the same way as\ndescribed in :ref:`ndimage-filter-functions` for the multidimensional\nfilter functions. Therefore, these functions all support a *mode*\nparameter that determines how the boundaries are handled, and a *cval*\nparameter that gives a constant value in case that the 'constant' mode\nis used.\n\n- The :func:`geometric_transform` function applies an arbitrary\n  geometric transform to the input. The given *mapping* function is\n  called at each point in the output to find the corresponding\n  coordinates in the input. *mapping* must be a callable object that\n  accepts a tuple of length equal to the output array rank and returns\n  the corresponding input coordinates as a tuple of length equal to\n  the input array rank. The output shape and output type can\n  optionally be provided. If not given, they are equal to the input\n  shape and type.\n\n  For example:\n\n  .. code:: python\n\n     >>> a = np.arange(12).reshape(4,3).astype(np.float64)\n     >>> def shift_func(output_coordinates):\n     ...     return (output_coordinates[0] - 0.5, output_coordinates[1] - 0.5)\n     ...\n     >>> from scipy.ndimage import geometric_transform\n     >>> geometric_transform(a, shift_func)\n     array([[ 0.    ,  0.    ,  0.    ],\n\t    [ 0.    ,  1.3625,  2.7375],\n            [ 0.    ,  4.8125,  6.1875],\n            [ 0.    ,  8.2625,  9.6375]])\n\n  Optionally, extra arguments can be defined and passed to the filter\n  function. The *extra_arguments* and *extra_keywords* arguments can\n  be used to pass a tuple of extra arguments and/or a dictionary of\n  named arguments that are passed to derivative at each call. For\n  example, we can pass the shifts in our example as arguments\n\n  .. code:: python\n\n     >>> def shift_func(output_coordinates, s0, s1):\n     ...     return (output_coordinates[0] - s0, output_coordinates[1] - s1)\n     ...\n     >>> geometric_transform(a, shift_func, extra_arguments = (0.5, 0.5))\n     array([[ 0.    ,  0.    ,  0.    ],\n\t    [ 0.    ,  1.3625,  2.7375],\n            [ 0.    ,  4.8125,  6.1875],\n            [ 0.    ,  8.2625,  9.6375]])\n\n  or\n\n  .. code:: python\n\n     >>> geometric_transform(a, shift_func, extra_keywords = {'s0': 0.5, 's1': 0.5})\n     array([[ 0.    ,  0.    ,  0.    ],\n\t    [ 0.    ,  1.3625,  2.7375],\n\t    [ 0.    ,  4.8125,  6.1875],\n\t    [ 0.    ,  8.2625,  9.6375]])\n\n  .. note::\n\n     The mapping function can also be written in C and passed using a\n     `scipy.LowLevelCallable`. See :ref:`ndimage-ccallbacks` for more\n     information.\n\n- The function :func:`map_coordinates` applies an arbitrary coordinate\n  transformation using the given array of coordinates. The shape of\n  the output is derived from that of the coordinate array by dropping\n  the first axis. The parameter *coordinates* is used to find for each\n  point in the output the corresponding coordinates in the input. The\n  values of *coordinates* along the first axis are the coordinates in\n  the input array at which the output value is found. (See also the\n  numarray `coordinates` function.) Since the coordinates may be non-\n  integer coordinates, the value of the input at these coordinates is\n  determined by spline interpolation of the requested order.\n\n  Here is an example that interpolates a 2D array at ``(0.5, 0.5)`` and\n  ``(1, 2)``:\n\n  .. code:: python\n\n     >>> a = np.arange(12).reshape(4,3).astype(np.float64)\n     >>> a\n     array([[  0.,   1.,   2.],\n\t    [  3.,   4.,   5.],\n\t    [  6.,   7.,   8.],\n\t    [  9.,  10.,  11.]])\n     >>> from scipy.ndimage import map_coordinates\n     >>> map_coordinates(a, [[0.5, 2], [0.5, 1]])\n     array([ 1.3625,  7.])\n\n- The :func:`affine_transform` function applies an affine\n  transformation to the input array. The given transformation *matrix*\n  and *offset* are used to find for each point in the output the\n  corresponding coordinates in the input. The value of the input at\n  the calculated coordinates is determined by spline interpolation of\n  the requested order. The transformation *matrix* must be\n  2-D or can also be given as a 1-D sequence\n  or array. In the latter case, it is assumed that the matrix is\n  diagonal. A more efficient interpolation algorithm is then applied\n  that exploits the separability of the problem. The output shape and\n  output type can optionally be provided. If not given, they are equal\n  to the input shape and type.\n\n- The :func:`shift` function returns a shifted version of the input,\n  using spline interpolation of the requested *order*.\n\n- The :func:`zoom` function returns a rescaled version of the input,\n  using spline interpolation of the requested *order*.\n\n- The :func:`rotate` function returns the input array rotated in the\n  plane defined by the two axes given by the parameter *axes*, using\n  spline interpolation of the requested *order*. The angle must be\n  given in degrees. If *reshape* is true, then the size of the output\n  array is adapted to contain the rotated input.\n\n.. _ndimage-morphology:\n\nMorphology\n----------\n\n.. _ndimage-binary-morphology:\n\nBinary morphology\n^^^^^^^^^^^^^^^^^\n\n- The :func:`generate_binary_structure` functions generates a binary\n  structuring element for use in binary morphology operations. The\n  *rank* of the structure must be provided. The size of the structure\n  that is returned is equal to three in each direction. The value of\n  each element is equal to one if the square of the Euclidean distance\n  from the element to the center is less than or equal to\n  *connectivity*. For instance, 2-D 4-connected and\n  8-connected structures are generated as follows:\n\n  .. code:: python\n\n     >>> from scipy.ndimage import generate_binary_structure\n     >>> generate_binary_structure(2, 1)\n     array([[False,  True, False],\n\t    [ True,  True,  True],\n            [False,  True, False]], dtype=bool)\n     >>> generate_binary_structure(2, 2)\n     array([[ True,  True,  True],\n\t    [ True,  True,  True],\n            [ True,  True,  True]], dtype=bool)\n\nMost binary morphology functions can be expressed in terms of the\nbasic operations erosion and dilation.\n\n- The :func:`binary_erosion` function implements binary erosion of\n  arrays of arbitrary rank with the given structuring element. The\n  origin parameter controls the placement of the structuring element,\n  as described in :ref:`ndimage-filter-functions`. If no structuring\n  element is provided, an element with connectivity equal to one is\n  generated using :func:`generate_binary_structure`. The\n  *border_value* parameter gives the value of the array outside\n  boundaries. The erosion is repeated *iterations* times. If\n  *iterations* is less than one, the erosion is repeated until the\n  result does not change anymore. If a *mask* array is given, only\n  those elements with a true value at the corresponding mask element\n  are modified at each iteration.\n\n- The :func:`binary_dilation` function implements binary dilation of\n  arrays of arbitrary rank with the given structuring element. The\n  origin parameter controls the placement of the structuring element,\n  as described in :ref:`ndimage-filter-functions`. If no structuring\n  element is provided, an element with connectivity equal to one is\n  generated using :func:`generate_binary_structure`. The\n  *border_value* parameter gives the value of the array outside\n  boundaries. The dilation is repeated *iterations* times. If\n  *iterations* is less than one, the dilation is repeated until the\n  result does not change anymore. If a *mask* array is given, only\n  those elements with a true value at the corresponding mask element\n  are modified at each iteration.\n\nHere is an example of using :func:`binary_dilation` to find all elements\nthat touch the border, by repeatedly dilating an empty array from\nthe border using the data array as the mask:\n\n.. code:: python\n\n   >>> struct = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n   >>> a = np.array([[1,0,0,0,0], [1,1,0,1,0], [0,0,1,1,0], [0,0,0,0,0]])\n   >>> a\n   array([[1, 0, 0, 0, 0],\n\t  [1, 1, 0, 1, 0],\n          [0, 0, 1, 1, 0],\n          [0, 0, 0, 0, 0]])\n   >>> from scipy.ndimage import binary_dilation\n   >>> binary_dilation(np.zeros(a.shape), struct, -1, a, border_value=1)\n   array([[ True, False, False, False, False],\n\t  [ True,  True, False, False, False],\n          [False, False, False, False, False],\n          [False, False, False, False, False]], dtype=bool)\n\nThe :func:`binary_erosion` and :func:`binary_dilation` functions both\nhave an *iterations* parameter, which allows the erosion or dilation to\nbe repeated a number of times. Repeating an erosion or a dilation with\na given structure *n* times is equivalent to an erosion or a dilation\nwith a structure that is *n-1* times dilated with itself. A function\nis provided that allows the calculation of a structure that is dilated\na number of times with itself:\n\n- The :func:`iterate_structure` function returns a structure by dilation\n  of the input structure *iteration* - 1 times with itself.\n\n  For instance:\n\n  .. code:: python\n\n     >>> struct = generate_binary_structure(2, 1)\n     >>> struct\n     array([[False,  True, False],\n\t    [ True,  True,  True],\n\t    [False,  True, False]], dtype=bool)\n     >>> from scipy.ndimage import iterate_structure\n     >>> iterate_structure(struct, 2)\n     array([[False, False,  True, False, False],\n\t    [False,  True,  True,  True, False],\n\t    [ True,  True,  True,  True,  True],\n\t    [False,  True,  True,  True, False],\n            [False, False,  True, False, False]], dtype=bool)\n\n     If the origin of the original structure is equal to 0, then it is\n     also equal to 0 for the iterated structure. If not, the origin\n     must also be adapted if the equivalent of the *iterations*\n     erosions or dilations must be achieved with the iterated\n     structure. The adapted origin is simply obtained by multiplying\n     with the number of iterations. For convenience, the\n     :func:`iterate_structure` also returns the adapted origin if the\n     *origin* parameter is not ``None``:\n\n     .. code:: python\n\n\t>>> iterate_structure(struct, 2, -1)\n\t(array([[False, False,  True, False, False],\n\t        [False,  True,  True,  True, False],\n\t\t[ True,  True,  True,  True,  True],\n\t\t[False,  True,  True,  True, False],\n\t\t[False, False,  True, False, False]], dtype=bool), [-2, -2])\n\nOther morphology operations can be defined in terms of erosion and\ndilation. The following functions provide a few of these operations\nfor convenience:\n\n- The :func:`binary_opening` function implements binary opening of\n  arrays of arbitrary rank with the given structuring element. Binary\n  opening is equivalent to a binary erosion followed by a binary\n  dilation with the same structuring element. The origin parameter\n  controls the placement of the structuring element, as described in\n  :ref:`ndimage-filter-functions`. If no structuring element is\n  provided, an element with connectivity equal to one is generated\n  using :func:`generate_binary_structure`. The *iterations* parameter\n  gives the number of erosions that is performed followed by the same\n  number of dilations.\n\n- The :func:`binary_closing` function implements binary closing of\n  arrays of arbitrary rank with the given structuring element. Binary\n  closing is equivalent to a binary dilation followed by a binary\n  erosion with the same structuring element. The origin parameter\n  controls the placement of the structuring element, as described in\n  :ref:`ndimage-filter-functions`. If no structuring element is\n  provided, an element with connectivity equal to one is generated\n  using :func:`generate_binary_structure`. The *iterations* parameter\n  gives the number of dilations that is performed followed by the same\n  number of erosions.\n\n- The :func:`binary_fill_holes` function is used to close holes in\n  objects in a binary image, where the structure defines the\n  connectivity of the holes. The origin parameter controls the\n  placement of the structuring element, as described in\n  :ref:`ndimage-filter-functions`. If no structuring element is\n  provided, an element with connectivity equal to one is generated\n  using :func:`generate_binary_structure`.\n\n- The :func:`binary_hit_or_miss` function implements a binary\n  hit-or-miss transform of arrays of arbitrary rank with the given\n  structuring elements. The hit-or-miss transform is calculated by\n  erosion of the input with the first structure, erosion of the\n  logical *not* of the input with the second structure, followed by\n  the logical *and* of these two erosions. The origin parameters\n  control the placement of the structuring elements, as described in\n  :ref:`ndimage-filter-functions`. If *origin2* equals ``None``, it is set\n  equal to the *origin1* parameter. If the first structuring element\n  is not provided, a structuring element with connectivity equal to\n  one is generated using :func:`generate_binary_structure`. If\n  *structure2* is not provided, it is set equal to the logical *not*\n  of *structure1*.\n\n.. _ndimage-grey-morphology:\n\nGrey-scale morphology\n^^^^^^^^^^^^^^^^^^^^^\n\nGrey-scale morphology operations are the equivalents of binary\nmorphology operations that operate on arrays with arbitrary values.\nBelow, we describe the grey-scale equivalents of erosion, dilation,\nopening and closing. These operations are implemented in a similar\nfashion as the filters described in :ref:`ndimage-filter-functions`,\nand we refer to this section for the description of filter kernels and\nfootprints, and the handling of array borders. The grey-scale\nmorphology operations optionally take a *structure* parameter that\ngives the values of the structuring element. If this parameter is not\ngiven, the structuring element is assumed to be flat with a value equal\nto zero. The shape of the structure can optionally be defined by the\n*footprint* parameter. If this parameter is not given, the structure\nis assumed to be rectangular, with sizes equal to the dimensions of\nthe *structure* array, or by the *size* parameter if *structure* is\nnot given. The *size* parameter is only used if both *structure* and\n*footprint* are not given, in which case the structuring element is\nassumed to be rectangular and flat with the dimensions given by\n*size*. The *size* parameter, if provided, must be a sequence of sizes\nor a single number in which case the size of the filter is assumed to\nbe equal along each axis. The *footprint* parameter, if provided, must\nbe an array that defines the shape of the kernel by its non-zero\nelements.\n\nSimilarly to binary erosion and dilation, there are operations for\ngrey-scale erosion and dilation:\n\n- The :func:`grey_erosion` function calculates a multidimensional\n  grey-scale erosion.\n\n- The :func:`grey_dilation` function calculates a multidimensional\n  grey-scale dilation.\n\nGrey-scale opening and closing operations can be defined similarly to\ntheir binary counterparts:\n\n- The :func:`grey_opening` function implements grey-scale opening of\n  arrays of arbitrary rank. Grey-scale opening is equivalent to a\n  grey-scale erosion followed by a grey-scale dilation.\n\n- The :func:`grey_closing` function implements grey-scale closing of\n  arrays of arbitrary rank. Grey-scale opening is equivalent to a\n  grey-scale dilation followed by a grey-scale erosion.\n\n- The :func:`morphological_gradient` function implements a grey-scale\n  morphological gradient of arrays of arbitrary rank. The grey-scale\n  morphological gradient is equal to the difference of a grey-scale\n  dilation and a grey-scale erosion.\n\n- The :func:`morphological_laplace` function implements a grey-scale\n  morphological laplace of arrays of arbitrary rank. The grey-scale\n  morphological laplace is equal to the sum of a grey-scale dilation\n  and a grey-scale erosion minus twice the input.\n\n- The :func:`white_tophat` function implements a white top-hat filter\n  of arrays of arbitrary rank. The white top-hat is equal to the\n  difference of the input and a grey-scale opening.\n\n- The :func:`black_tophat` function implements a black top-hat filter\n  of arrays of arbitrary rank. The black top-hat is equal to the\n  difference of a grey-scale closing and the input.\n\n.. _ndimage-distance-transforms:\n\nDistance transforms\n-------------------\n\nDistance transforms are used to calculate the minimum distance from\neach element of an object to the background. The following functions\nimplement distance transforms for three different distance metrics:\nEuclidean, city block, and chessboard distances.\n\n- The function :func:`distance_transform_cdt` uses a chamfer type\n  algorithm to calculate the distance transform of the input, by\n  replacing each object element (defined by values larger than zero)\n  with the shortest distance to the background (all non-object\n  elements). The structure determines the type of chamfering that is\n  done. If the structure is equal to 'cityblock', a structure is\n  generated using :func:`generate_binary_structure` with a squared\n  distance equal to 1. If the structure is equal to 'chessboard', a\n  structure is generated using :func:`generate_binary_structure` with\n  a squared distance equal to the rank of the array. These choices\n  correspond to the common interpretations of the city block and the\n  chessboard distance metrics in two dimensions.\n\n  In addition to the distance transform, the feature transform can be\n  calculated. In this case, the index of the closest background element\n  is returned along the first axis of the result. The\n  *return_distances*, and *return_indices* flags can be used to\n  indicate if the distance transform, the feature transform, or both\n  must be returned.\n\n  The *distances* and *indices* arguments can be used to give optional\n  output arrays that must be of the correct size and type (both\n  ``numpy.int32``). The basics of the algorithm used to implement this\n  function are described in [2]_.\n\n- The function :func:`distance_transform_edt` calculates the exact\n  Euclidean distance transform of the input, by replacing each object\n  element (defined by values larger than zero) with the shortest\n  Euclidean distance to the background (all non-object elements).\n\n  In addition to the distance transform, the feature transform can be\n  calculated. In this case, the index of the closest background element\n  is returned along the first axis of the result. The\n  *return_distances* and *return_indices* flags can be used to\n  indicate if the distance transform, the feature transform, or both\n  must be returned.\n\n  Optionally, the sampling along each axis can be given by the\n  *sampling* parameter, which should be a sequence of length equal to\n  the input rank, or a single number in which the sampling is assumed\n  to be equal along all axes.\n\n  The *distances* and *indices* arguments can be used to give optional\n  output arrays that must be of the correct size and type\n  (``numpy.float64`` and ``numpy.int32``).The algorithm used to\n  implement this function is described in [3]_.\n\n- The function :func:`distance_transform_bf` uses a brute-force\n  algorithm to calculate the distance transform of the input, by\n  replacing each object element (defined by values larger than zero)\n  with the shortest distance to the background (all non-object\n  elements). The metric must be one of \"euclidean\", \"cityblock\", or\n  \"chessboard\".\n\n  In addition to the distance transform, the feature transform can be\n  calculated. In this case, the index of the closest background element\n  is returned along the first axis of the result. The\n  *return_distances* and *return_indices* flags can be used to\n  indicate if the distance transform, the feature transform, or both\n  must be returned.\n\n  Optionally, the sampling along each axis can be given by the\n  *sampling* parameter, which should be a sequence of length equal to\n  the input rank, or a single number in which the sampling is assumed\n  to be equal along all axes. This parameter is only used in the case\n  of the Euclidean distance transform.\n\n  The *distances* and *indices* arguments can be used to give optional\n  output arrays that must be of the correct size and type\n  (``numpy.float64`` and ``numpy.int32``).\n\n  .. note::\n\n     This function uses a slow brute-force algorithm, the function\n     :func:`distance_transform_cdt` can be used to more efficiently\n     calculate city block and chessboard distance transforms. The\n     function :func:`distance_transform_edt` can be used to more\n     efficiently calculate the exact Euclidean distance transform.\n\nSegmentation and labeling\n-------------------------\n\nSegmentation is the process of separating objects of interest from\nthe background. The most simple approach is, probably, intensity\nthresholding, which is easily done with :mod:`numpy` functions:\n\n.. code:: python\n\n   >>> a = np.array([[1,2,2,1,1,0],\n   ...               [0,2,3,1,2,0],\n   ...               [1,1,1,3,3,2],\n   ...               [1,1,1,1,2,1]])\n   >>> np.where(a > 1, 1, 0)\n   array([[0, 1, 1, 0, 0, 0],\n\t  [0, 1, 1, 0, 1, 0],\n\t  [0, 0, 0, 1, 1, 1],\n\t  [0, 0, 0, 0, 1, 0]])\n\nThe result is a binary image, in which the individual objects still\nneed to be identified and labeled. The function :func:`label`\ngenerates an array where each object is assigned a unique number:\n\n- The :func:`label` function generates an array where the objects in\n  the input are labeled with an integer index. It returns a tuple\n  consisting of the array of object labels and the number of objects\n  found, unless the *output* parameter is given, in which case only\n  the number of objects is returned. The connectivity of the objects\n  is defined by a structuring element. For instance, in 2D\n  using a 4-connected structuring element gives:\n\n  .. code:: python\n\n     >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n     >>> s = [[0, 1, 0], [1,1,1], [0,1,0]]\n     >>> from scipy.ndimage import label\n     >>> label(a, s)\n     (array([[0, 1, 1, 0, 0, 0],\n\t     [0, 1, 1, 0, 2, 0],\n\t     [0, 0, 0, 2, 2, 2],\n\t     [0, 0, 0, 0, 2, 0]]), 2)\n\n  These two objects are not connected because there is no way in which\n  we can place the structuring element, such that it overlaps with both\n  objects. However, an 8-connected structuring element results in only\n  a single object:\n\n  .. code:: python\n\n     >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n     >>> s = [[1,1,1], [1,1,1], [1,1,1]]\n     >>> label(a, s)[0]\n     array([[0, 1, 1, 0, 0, 0],\n\t    [0, 1, 1, 0, 1, 0],\n            [0, 0, 0, 1, 1, 1],\n            [0, 0, 0, 0, 1, 0]])\n\n  If no structuring element is provided, one is generated by calling\n  :func:`generate_binary_structure` (see\n  :ref:`ndimage-binary-morphology`) using a connectivity of one (which\n  in 2D is the 4-connected structure of the first example). The input\n  can be of any type, any value not equal to zero is taken to be part\n  of an object. This is useful if you need to 're-label' an array of\n  object indices, for instance, after removing unwanted objects. Just\n  apply the label function again to the index array. For instance:\n\n  .. code:: python\n\n     >>> l, n = label([1, 0, 1, 0, 1])\n     >>> l\n     array([1, 0, 2, 0, 3])\n     >>> l = np.where(l != 2, l, 0)\n     >>> l\n     array([1, 0, 0, 0, 3])\n     >>> label(l)[0]\n     array([1, 0, 0, 0, 2])\n\n  .. note::\n\n     The structuring element used by :func:`label` is assumed to be\n     symmetric.\n\nThere is a large number of other approaches for segmentation, for\ninstance, from an estimation of the borders of the objects that can be\nobtained by derivative filters. One such approach is\nwatershed segmentation. The function :func:`watershed_ift` generates\nan array where each object is assigned a unique label, from an array\nthat localizes the object borders, generated, for instance, by a\ngradient magnitude filter. It uses an array containing initial markers\nfor the objects:\n\n- The :func:`watershed_ift` function applies a watershed from markers\n  algorithm, using an Iterative Forest Transform, as described in\n  [4]_.\n\n- The inputs of this function are the array to which the transform is\n  applied, and an array of markers that designate the objects by a\n  unique label, where any non-zero value is a marker. For instance:\n\n  .. code:: python\n\n     >>> input = np.array([[0, 0, 0, 0, 0, 0, 0],\n     ...                   [0, 1, 1, 1, 1, 1, 0],\n     ...                   [0, 1, 0, 0, 0, 1, 0],\n     ...                   [0, 1, 0, 0, 0, 1, 0],\n     ...                   [0, 1, 0, 0, 0, 1, 0],\n     ...                   [0, 1, 1, 1, 1, 1, 0],\n     ...                   [0, 0, 0, 0, 0, 0, 0]], np.uint8)\n     >>> markers = np.array([[1, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 2, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0]], np.int8)\n     >>> from scipy.ndimage import watershed_ift\n     >>> watershed_ift(input, markers)\n     array([[1, 1, 1, 1, 1, 1, 1],\n\t    [1, 1, 2, 2, 2, 1, 1],\n            [1, 2, 2, 2, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 1],\n            [1, 1, 2, 2, 2, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1]], dtype=int8)\n\n  Here, two markers were used to designate an object (*marker* = 2) and\n  the background (*marker* = 1). The order in which these are\n  processed is arbitrary: moving the marker for the background to the\n  lower-right corner of the array yields a different result:\n\n  .. code:: python\n\n     >>> markers = np.array([[0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 2, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 1]], np.int8)\n     >>> watershed_ift(input, markers)\n     array([[1, 1, 1, 1, 1, 1, 1],\n\t    [1, 1, 1, 1, 1, 1, 1],\n\t    [1, 1, 2, 2, 2, 1, 1],\n\t    [1, 1, 2, 2, 2, 1, 1],\n            [1, 1, 2, 2, 2, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1]], dtype=int8)\n\n  The result is that the object (*marker* = 2) is smaller because the\n  second marker was processed earlier. This may not be the desired\n  effect if the first marker was supposed to designate a background\n  object. Therefore, :func:`watershed_ift` treats markers with a\n  negative value explicitly as background markers and processes them\n  after the normal markers. For instance, replacing the first marker\n  by a negative marker gives a result similar to the first example:\n\n  .. code:: python\n\n     >>> markers = np.array([[0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 2, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, 0],\n     ...                     [0, 0, 0, 0, 0, 0, -1]], np.int8)\n     >>> watershed_ift(input, markers)\n     array([[-1, -1, -1, -1, -1, -1, -1],\n\t    [-1, -1,  2,  2,  2, -1, -1],\n\t    [-1,  2,  2,  2,  2,  2, -1],\n\t    [-1,  2,  2,  2,  2,  2, -1],\n            [-1,  2,  2,  2,  2,  2, -1],\n            [-1, -1,  2,  2,  2, -1, -1],\n            [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)\n\n  The connectivity of the objects is defined by a structuring\n  element. If no structuring element is provided, one is generated by\n  calling :func:`generate_binary_structure` (see\n  :ref:`ndimage-binary-morphology`) using a connectivity of one (which\n  in 2D is a 4-connected structure.) For example, using an 8-connected\n  structure with the last example yields a different object:\n\n  .. code:: python\n\n     >>> watershed_ift(input, markers,\n     ...               structure = [[1,1,1], [1,1,1], [1,1,1]])\n     array([[-1, -1, -1, -1, -1, -1, -1],\n\t    [-1,  2,  2,  2,  2,  2, -1],\n            [-1,  2,  2,  2,  2,  2, -1],\n            [-1,  2,  2,  2,  2,  2, -1],\n            [-1,  2,  2,  2,  2,  2, -1],\n            [-1,  2,  2,  2,  2,  2, -1],\n            [-1, -1, -1, -1, -1, -1, -1]], dtype=int8)\n\n  .. note::\n\n     The implementation of :func:`watershed_ift` limits the data types\n     of the input to ``numpy.uint8`` and ``numpy.uint16``.\n\n.. _ndimage-object-measurements:\n\nObject measurements\n-------------------\n\nGiven an array of labeled objects, the properties of the individual\nobjects can be measured. The :func:`find_objects` function can be used\nto generate a list of slices that for each object, give the\nsmallest sub-array that fully contains the object:\n\n- The :func:`find_objects` function finds all objects in a labeled\n  array and returns a list of slices that correspond to the smallest\n  regions in the array that contains the object.\n\n  For instance:\n\n  .. code:: python\n\n     >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n     >>> l, n = label(a)\n     >>> from scipy.ndimage import find_objects\n     >>> f = find_objects(l)\n     >>> a[f[0]]\n     array([[1, 1],\n\t    [1, 1]])\n     >>> a[f[1]]\n     array([[0, 1, 0],\n\t    [1, 1, 1],\n\t    [0, 1, 0]])\n\n  The function :func:`find_objects` returns slices for all objects,\n  unless the *max_label* parameter is larger then zero, in which case\n  only the first *max_label* objects are returned. If an index is\n  missing in the *label* array, ``None`` is return instead of a\n  slice. For example:\n\n  .. code:: python\n\n     >>> from scipy.ndimage import find_objects\n     >>> find_objects([1, 0, 3, 4], max_label = 3)\n     [(slice(0, 1, None),), None, (slice(2, 3, None),)]\n\nThe list of slices generated by :func:`find_objects` is useful to find\nthe position and dimensions of the objects in the array, but can also\nbe used to perform measurements on the individual objects. Say, we want\nto find the sum of the intensities of an object in image:\n\n.. code:: python\n\n   >>> image = np.arange(4 * 6).reshape(4, 6)\n   >>> mask = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n   >>> labels = label(mask)[0]\n   >>> slices = find_objects(labels)\n\nThen we can calculate the sum of the elements in the second object:\n\n.. code:: python\n\n   >>> np.where(labels[slices[1]] == 2, image[slices[1]], 0).sum()\n   80\n\nThat is, however, not particularly efficient and may also be more\ncomplicated for other types of measurements. Therefore, a few\nmeasurements functions are defined that accept the array of object\nlabels and the index of the object to be measured. For instance,\ncalculating the sum of the intensities can be done by:\n\n.. code:: python\n\n   >>> from scipy.ndimage import sum as ndi_sum\n   >>> ndi_sum(image, labels, 2)\n   80\n\nFor large arrays and small objects, it is more efficient to call the\nmeasurement functions after slicing the array:\n\n.. code:: python\n\n   >>> ndi_sum(image[slices[1]], labels[slices[1]], 2)\n   80\n\nAlternatively, we can do the measurements for a number of labels with\na single function call, returning a list of results. For instance, to\nmeasure the sum of the values of the background and the second object\nin our example, we give a list of labels:\n\n.. code:: python\n\n   >>> ndi_sum(image, labels, [0, 2])\n   array([178.0, 80.0])\n\nThe measurement functions described below all support the *index*\nparameter to indicate which object(s) should be measured. The default\nvalue of *index* is ``None``. This indicates that all elements where the\nlabel is larger than zero should be treated as a single object and\nmeasured. Thus, in this case the *labels* array is treated as a mask\ndefined by the elements that are larger than zero. If *index* is a\nnumber or a sequence of numbers it gives the labels of the objects\nthat are measured. If *index* is a sequence, a list of the results is\nreturned. Functions that return more than one result return their\nresult as a tuple if *index* is a single number, or as a tuple of\nlists if *index* is a sequence.\n\n- The :func:`sum` function calculates the sum of the elements of the\n  object with label(s) given by *index*, using the *labels* array for\n  the object labels. If *index* is ``None``, all elements with a\n  non-zero label value are treated as a single object. If *label* is\n  ``None``, all elements of *input* are used in the calculation.\n\n- The :func:`mean` function calculates the mean of the elements of the\n  object with label(s) given by *index*, using the *labels* array for\n  the object labels. If *index* is ``None``, all elements with a\n  non-zero label value are treated as a single object. If *label* is\n  ``None``, all elements of *input* are used in the calculation.\n\n- The :func:`variance` function calculates the variance of the\n  elements of the object with label(s) given by *index*, using the\n  *labels* array for the object labels. If *index* is ``None``, all\n  elements with a non-zero label value are treated as a single\n  object. If *label* is ``None``, all elements of *input* are used in\n  the calculation.\n\n- The :func:`standard_deviation` function calculates the standard\n  deviation of the elements of the object with label(s) given by\n  *index*, using the *labels* array for the object labels. If *index*\n  is ``None``, all elements with a non-zero label value are treated as\n  a single object. If *label* is ``None``, all elements of *input* are\n  used in the calculation.\n\n- The :func:`minimum` function calculates the minimum of the elements\n  of the object with label(s) given by *index*, using the *labels*\n  array for the object labels. If *index* is ``None``, all elements\n  with a non-zero label value are treated as a single object. If\n  *label* is ``None``, all elements of *input* are used in the\n  calculation.\n\n- The :func:`maximum` function calculates the maximum of the elements\n  of the object with label(s) given by *index*, using the *labels*\n  array for the object labels. If *index* is ``None``, all elements\n  with a non-zero label value are treated as a single object. If\n  *label* is ``None``, all elements of *input* are used in the\n  calculation.\n\n- The :func:`minimum_position` function calculates the position of the\n  minimum of the elements of the object with label(s) given by\n  *index*, using the *labels* array for the object labels. If *index*\n  is ``None``, all elements with a non-zero label value are treated as\n  a single object. If *label* is ``None``, all elements of *input* are\n  used in the calculation.\n\n- The :func:`maximum_position` function calculates the position of the\n  maximum of the elements of the object with label(s) given by\n  *index*, using the *labels* array for the object labels. If *index*\n  is ``None``, all elements with a non-zero label value are treated as\n  a single object. If *label* is ``None``, all elements of *input* are\n  used in the calculation.\n\n- The :func:`extrema` function calculates the minimum, the maximum,\n  and their positions, of the elements of the object with label(s)\n  given by *index*, using the *labels* array for the object labels. If\n  *index* is ``None``, all elements with a non-zero label value are\n  treated as a single object. If *label* is ``None``, all elements of\n  *input* are used in the calculation. The result is a tuple giving\n  the minimum, the maximum, the position of the minimum, and the\n  position of the maximum. The result is the same as a tuple formed by\n  the results of the functions *minimum*, *maximum*,\n  *minimum_position*, and *maximum_position* that are described above.\n\n- The :func:`center_of_mass` function calculates the center of mass of\n  the object with label(s) given by *index*, using the *labels*\n  array for the object labels. If *index* is ``None``, all elements\n  with a non-zero label value are treated as a single object. If\n  *label* is ``None``, all elements of *input* are used in the\n  calculation.\n\n- The :func:`histogram` function calculates a histogram of the\n  object with label(s) given by *index*, using the *labels* array for\n  the object labels. If *index* is ``None``, all elements with a\n  non-zero label value are treated as a single object. If *label* is\n  ``None``, all elements of *input* are used in the calculation.\n  Histograms are defined by their minimum (*min*), maximum (*max*), and\n  the number of bins (*bins*). They are returned as 1-D\n  arrays of type ``numpy.int32``.\n\n.. _ndimage-ccallbacks:\n\nExtending :mod:`scipy.ndimage` in C\n-----------------------------------\n\nA few functions in :mod:`scipy.ndimage` take a callback argument. This\ncan be either a python function or a `scipy.LowLevelCallable` containing a\npointer to a C function. Using a C function will generally be more\nefficient, since it avoids the overhead of calling a python function on\nmany elements of an array. To use a C function, you must write a C\nextension that contains the callback function and a Python function\nthat returns a `scipy.LowLevelCallable` containing a pointer to the\ncallback.\n\nAn example of a function that supports callbacks is\n:func:`geometric_transform`, which accepts a callback function that\ndefines a mapping from all output coordinates to corresponding\ncoordinates in the input array. Consider the following python example,\nwhich uses :func:`geometric_transform` to implement a shift function.\n\n.. code:: python\n\n   from scipy import ndimage\n\n   def transform(output_coordinates, shift):\n       input_coordinates = output_coordinates[0] - shift, output_coordinates[1] - shift\n       return input_coordinates\n\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   shift = 0.5\n   print(ndimage.geometric_transform(im, transform, extra_arguments=(shift,)))\n\nWe can also implement the callback function with the following C code:\n\n.. code:: c\n\n   /* example.c */\n\n   #include <Python.h>\n   #include <numpy/npy_common.h>\n\n   static int\n   _transform(npy_intp *output_coordinates, double *input_coordinates,\n              int output_rank, int input_rank, void *user_data)\n   {\n       npy_intp i;\n       double shift = *(double *)user_data;\n\n       for (i = 0; i < input_rank; i++) {\n           input_coordinates[i] = output_coordinates[i] - shift;\n       }\n       return 1;\n   }\n\n   static char *transform_signature = \"int (npy_intp *, double *, int, int, void *)\";\n\n   static PyObject *\n   py_get_transform(PyObject *obj, PyObject *args)\n   {\n       if (!PyArg_ParseTuple(args, \"\")) return NULL;\n       return PyCapsule_New(_transform, transform_signature, NULL);\n   }\n\n   static PyMethodDef ExampleMethods[] = {\n       {\"get_transform\", (PyCFunction)py_get_transform, METH_VARARGS, \"\"},\n       {NULL, NULL, 0, NULL}\n   };\n\n   /* Initialize the module */\n   static struct PyModuleDef example = {\n       PyModuleDef_HEAD_INIT,\n       \"example\",\n       NULL,\n       -1,\n       ExampleMethods,\n       NULL,\n       NULL,\n       NULL,\n       NULL\n   };\n\n   PyMODINIT_FUNC\n   PyInit_example(void)\n   {\n       return PyModule_Create(&example);\n   }\n\nMore information on writing Python extension modules can be found\n`here`__. If the C code is in the file ``example.c``, then it can be\ncompiled with the following ``setup.py``,\n\n__ https://docs.python.org/2/extending/extending.html\n\n.. code:: python\n\n   from distutils.core import setup, Extension\n   import numpy\n\n   shift = Extension('example',\n                     ['example.c'],\n                     include_dirs=[numpy.get_include()]\n   )\n\n   setup(name='example',\n         ext_modules=[shift]\n   )\n\nand now running the script\n\n.. code:: python\n\n   import ctypes\n   import numpy as np\n   from scipy import ndimage, LowLevelCallable\n\n   from example import get_transform\n\n   shift = 0.5\n\n   user_data = ctypes.c_double(shift)\n   ptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\n   callback = LowLevelCallable(get_transform(), ptr)\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   print(ndimage.geometric_transform(im, callback))\n\nproduces the same result as the original python script.\n\nIn the C version, ``_transform`` is the callback function and the\nparameters ``output_coordinates`` and ``input_coordinates`` play the\nsame role as they do in the python version, while ``output_rank`` and\n``input_rank`` provide the equivalents of ``len(output_coordinates)``\nand ``len(input_coordinates)``. The variable ``shift`` is passed\nthrough ``user_data`` instead of\n``extra_arguments``. Finally, the C callback function returns an integer\nstatus, which is one upon success and zero otherwise.\n\nThe function ``py_transform`` wraps the callback function in a\n:c:type:`PyCapsule`. The main steps are:\n\n- Initialize a :c:type:`PyCapsule`. The first argument is a pointer to\n  the callback function.\n\n- The second argument is the function signature, which must match exactly\n  the one expected by :mod:`~scipy.ndimage`.\n\n- Above, we used  `scipy.LowLevelCallable` to specify ``user_data``\n  that we generated with `ctypes`.\n\n  A different approach would be to supply the data in the capsule context,\n  that can be set by `PyCapsule_SetContext` and omit specifying\n  ``user_data`` in `scipy.LowLevelCallable`. However, in this approach we would\n  need to deal with allocation/freeing of the data --- freeing the data\n  after the capsule has been destroyed can be done by specifying a non-NULL\n  callback function in the third argument of `PyCapsule_New`.\n\nC callback functions for :mod:`~scipy.ndimage` all follow this scheme. The\nnext section lists the :mod:`~scipy.ndimage` functions that accept a C\ncallback function and gives the prototype of the function.\n\n.. seealso::\n\n   The functions that support low-level callback arguments are:\n\n   `generic_filter`, `generic_filter1d`, `geometric_transform`\n\nBelow, we show alternative ways to write the code, using Numba_, Cython_,\nctypes_, or cffi_ instead of writing wrapper code in C.\n\n.. _Numba: https://numba.pydata.org/\n.. _Cython: https://cython.org/\n.. _ctypes: https://docs.python.org/3/library/ctypes.html\n.. _cffi: https://cffi.readthedocs.io/\n\n.. rubric:: Numba\n\nNumba_ provides a way to write low-level functions easily in Python.\nWe can write the above using Numba as:\n\n.. code:: python\n\n   # example.py\n   import numpy as np\n   import ctypes\n   from scipy import ndimage, LowLevelCallable\n   from numba import cfunc, types, carray\n\n   @cfunc(types.intc(types.CPointer(types.intp),\n                     types.CPointer(types.double),\n                     types.intc,\n                     types.intc,\n                     types.voidptr))\n   def transform(output_coordinates_ptr, input_coordinates_ptr,\n                 output_rank, input_rank, user_data):\n       input_coordinates = carray(input_coordinates_ptr, (input_rank,))\n       output_coordinates = carray(output_coordinates_ptr, (output_rank,))\n       shift = carray(user_data, (1,), types.double)[0]\n\n       for i in range(input_rank):\n           input_coordinates[i] = output_coordinates[i] - shift\n\n       return 1\n\n   shift = 0.5\n\n   # Then call the function\n   user_data = ctypes.c_double(shift)\n   ptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\n   callback = LowLevelCallable(transform.ctypes, ptr)\n\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   print(ndimage.geometric_transform(im, callback))\n\n\n.. rubric:: Cython\n\nFunctionally the same code as above can be written in Cython with\nsomewhat less boilerplate as follows:\n\n.. code:: cython\n\n   # example.pyx\n\n   from numpy cimport npy_intp as intp\n\n   cdef api int transform(intp *output_coordinates, double *input_coordinates,\n                          int output_rank, int input_rank, void *user_data):\n       cdef intp i\n       cdef double shift = (<double *>user_data)[0]\n\n       for i in range(input_rank):\n           input_coordinates[i] = output_coordinates[i] - shift\n       return 1\n\n.. code:: python\n\n   # script.py\n\n   import ctypes\n   import numpy as np\n   from scipy import ndimage, LowLevelCallable\n\n   import example\n\n   shift = 0.5\n\n   user_data = ctypes.c_double(shift)\n   ptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\n   callback = LowLevelCallable.from_cython(example, \"transform\", ptr)\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   print(ndimage.geometric_transform(im, callback))\n\n\n.. rubric:: cffi\n\nWith cffi_, you can interface with a C function residing in a shared\nlibrary (DLL). First, we need to write the shared library, which we do\nin C --- this example is for Linux/OSX:\n\n.. code:: c\n\n   /*\n     example.c\n     Needs to be compiled with \"gcc -std=c99 -shared -fPIC -o example.so example.c\"\n     or similar\n    */\n\n   #include <stdint.h>\n\n   int\n   _transform(intptr_t *output_coordinates, double *input_coordinates,\n              int output_rank, int input_rank, void *user_data)\n   {\n       int i;\n       double shift = *(double *)user_data;\n\n       for (i = 0; i < input_rank; i++) {\n           input_coordinates[i] = output_coordinates[i] - shift;\n       }\n       return 1;\n   }\n\nThe Python code calling the library is:\n\n.. code:: python\n\n   import os\n   import numpy as np\n   from scipy import ndimage, LowLevelCallable\n   import cffi\n\n   # Construct the FFI object, and copypaste the function declaration\n   ffi = cffi.FFI()\n   ffi.cdef(\"\"\"\n   int _transform(intptr_t *output_coordinates, double *input_coordinates,\n                  int output_rank, int input_rank, void *user_data);\n   \"\"\")\n\n   # Open library\n   lib = ffi.dlopen(os.path.abspath(\"example.so\"))\n\n   # Do the function call\n   user_data = ffi.new('double *', 0.5)\n   callback = LowLevelCallable(lib._transform, user_data)\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   print(ndimage.geometric_transform(im, callback))\n\nYou can find more information in the cffi_ documentation.\n\n.. rubric:: ctypes\n\nWith *ctypes*, the C code and the compilation of the so/DLL is as for\ncffi above.  The Python code is different:\n\n.. code:: python\n\n   # script.py\n\n   import os\n   import ctypes\n   import numpy as np\n   from scipy import ndimage, LowLevelCallable\n\n   lib = ctypes.CDLL(os.path.abspath('example.so'))\n\n   shift = 0.5\n\n   user_data = ctypes.c_double(shift)\n   ptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\n\n   # Ctypes has no built-in intptr type, so override the signature\n   # instead of trying to get it via ctypes\n   callback = LowLevelCallable(lib._transform, ptr,\n       \"int _transform(intptr_t *, double *, int, int, void *)\")\n\n   # Perform the call\n   im = np.arange(12).reshape(4, 3).astype(np.float64)\n   print(ndimage.geometric_transform(im, callback))\n\nYou can find more information in the ctypes_ documentation.\n\n\nReferences\n----------\n\n.. [1] M. Unser, \"Splines: A Perfect Fit for Signal and Image\n       Processing,\" IEEE Signal Processing Magazine, vol. 16, no. 6, pp.\n       22-38, November 1999.\n\n.. [2] G. Borgefors, \"Distance transformations in arbitrary\n       dimensions.\", Computer Vision, Graphics, and Image Processing,\n       27:321-345, 1984.\n\n.. [3] C. R. Maurer, Jr., R. Qi, and V. Raghavan, \"A linear time\n       algorithm for computing exact euclidean distance transforms of\n       binary images in arbitrary dimensions. IEEE Trans. PAMI 25,\n       265-270, 2003.\n\n.. [4] P. Felkel, R. Wegenkittl, and M. Bruckschwaiger,\n       \"Implementation and Complexity of the Watershed-from-Markers Algorithm\n       Computed as a Minimal Cost Forest.\", Eurographics 2001, pp. C:26-35.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/ndimage/tests/dots.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/interpolate/tests/data/estimate_gradients_hang.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/interpolate/tests/data/bug-1310.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_complex64.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_scalars.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-sf8-11x1x10.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-48000Hz-2ch-64bit-float-le-wavex.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-8000Hz-le-2ch-1byteu.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/invalid_pointer.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_8d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_complex32.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_uint32.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_heap_pointer.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/example_1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_8d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointer_arrays_replicated.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-44100Hz-le-1ch-4bytes.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/various_compressed.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_int64.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-si4-15x10x22.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_scalars_replicated.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-8000Hz-le-1ch-1byte-ulaw.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_7d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_4d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_scalars_replicated_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_arrays_byte_idl80.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_int32.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-si4-11x1x10.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointers_replicated_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointer_arrays.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_5d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_2d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/example_2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_arrays_replicated_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_1d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_inherit.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointers_replicated.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_byte.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-44100Hz-le-1ch-4bytes-early-eof-no-data.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-44100Hz-2ch-32bit-float-le.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_7d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-44100Hz-2ch-32bit-float-be.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_arrays.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/null_pointer.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_float32.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_float64.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-sf8-1x1x5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/test-44100Hz-le-1ch-4bytes-early-eof.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_6d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointers.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_2d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_uint64.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-3x3d-2i.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_byte_descr.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/Transparent Busy.ani",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_int16.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_string.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_5d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/example_3_maskedvals.nc",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-sf8-1x1x7.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_1d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-sf8-1x3x5.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_arrays_replicated.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/fortran-sf8-15x10x22.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/struct_pointer_arrays_replicated_3d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_4d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/array_float32_pointer_6d.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/tests/data/scalar_uint16.sav",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructnest_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcell_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructnest_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststringarray_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcellnest_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcellnest_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/big_endian.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testunicode_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/test3dmatrix_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcellnest_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/broken_utf8.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testemptycell_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testobject_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testminus_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testvec_4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testdouble_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcomplex_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/test_skip_variable.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/logical_sparse.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testdouble_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmatrix_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmatrix_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmatrix_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcellnest_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsecomplex_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/parabola.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testemptycell_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/little_endian.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststring_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testminus_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcell_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/malformed1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/test3dmatrix_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testonechar_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/miuint32_for_miint32.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparse_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmulti_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/corrupted_zlib_data.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcomplex_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparse_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststringarray_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testminus_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststringarray_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcomplex_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparse_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testunicode_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsefloat_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/some_functions.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststring_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparse_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcomplex_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/bad_miuint32.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsecomplex_4.2c_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststring_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/sqr.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testdouble_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststring_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testdouble_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/corrupted_zlib_checksum.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsecomplex_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmulti_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testminus_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststring_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsimplecell.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testonechar_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsecomplex_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testobject_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcomplex_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparse_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststruct_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststruct_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testscalarcell_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructarr_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/test_mat4_le_floats.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcell_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststruct_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testminus_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructnest_6.5.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testsparsecomplex_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testmulti_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststruct_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructarr_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructnest_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testobject_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testdouble_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/teststructarr_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testhdf5_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testonechar_7.1_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/test_empty_struct.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testcell_6.1_SOL2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testfunc_7.4_GLNX86.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/single_empty_string.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/testbool_8_WIN64.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/io/matlab/tests/data/nasty_duplicate_fieldnames.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/special/tests/data/boost.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/special/tests/data/gsl.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/special/tests/data/local.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/carex_6_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/carex_15_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/gendare_20170120_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/carex_19_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/carex_18_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/linalg/tests/data/carex_20_data.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/sparse/tests/data/csc_py3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/sparse/tests/data/csc_py2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/fftpack/tests/fftw_double_ref.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/fftpack/tests/fftw_single_ref.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/fftpack/tests/fftw_longdouble_ref.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/fftpack/tests/test.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/spatial/tests/data/degenerate_pointset.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/optimize/_shgo_lib/sobol_vec.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/stats/tests/data/stable-cdf-sample-data.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/stats/tests/data/stable-pdf-sample-data.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/misc/ascent.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/misc/face.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/scipy/misc/ecg.dat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/QAP8.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCFXM3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCTAP2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PEROLD.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GREENBEA.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/E226.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCSD6.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/MAROS.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BANDM.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/25FV47.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCTAP1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STANDMPS.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/D2Q06C.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOT-JA.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/AGG.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FFFFF800.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/AFIRO.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/QAP12.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/MODSZK1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/CZPROB.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/AGG2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STANDATA.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/DEGEN3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCAGR25.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP12S.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/ADLITTLE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/DEGEN2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FIT2P.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCSD8.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/TUFF.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/D6CUBE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GREENBEB.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHARE1B.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STAIR.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BORE3D.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BNL1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOT-WE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOT4.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FIT1P.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GFRD-PNC.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP08L.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GROW22.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/DFL001.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP12L.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GANGES.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SC205.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/LOTFI.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FINNIS.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/ETAMACRO.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BRANDY.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCSD1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STOCFOR3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/WOODW.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/CYCLE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCRS8.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FIT2D.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GROW7.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SIERRA.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/AGG3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/FIT1D.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOTNOV.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/CAPRI.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/RECIPE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCFXM1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP04S.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP08S.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/80BAU3B.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCTAP3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SC50B.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHIP04L.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/QAP15.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/VTP-BASE.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BLEND.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCFXM2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/ISRAEL.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHARE2B.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/GROW15.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/TRUSS.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SC50A.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SHELL.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BEACONFD.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/BNL2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/MAROS-R7.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCORPION.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/KB2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STOCFOR2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/WOOD1P.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SC105.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOT.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/SCAGR7.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/STOCFOR1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/PILOT87.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/chemcom.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/ceria3d.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/refinery.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/forest6.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/bgindy.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/reactor.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/woodinfe.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/vol1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/bgprtr.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/ex72a.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/ex73a.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/gran.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/qual.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/pilot4i.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/bgdbg1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/klein3.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/box1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/itest6.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/bgetam.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/itest2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/klein2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/galenet.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/cplex2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/pang.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/cplex1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/mondou2.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/gosh.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/benchmarks/benchmarks/linprog_benchmark_files/infeasible/klein1.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/scipy_org_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/scipy-sphinx-theme/_static/scipyshiny_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/tutorial/octave_a.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/tutorial/octave_struct.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/tutorial/octave_cells.mat",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/dev/gitwash/forking_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/dev/gitwash/pull_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/_static/scipyshiny_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/_static/scipy-mathjax/extensions/a11y/invalid_keypress.mp3",
        "/tmp/vanessa/spack-stage/spack-stage-py-scipy-1.5.3-txv43r33i7ijocwxcnt765nxzhnthit3/spack-src/doc/source/_static/scipy-mathjax/extensions/a11y/invalid_keypress.ogg"
    ],
    "total_files": 2945
}