{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/lin_sys/lib_handler.c": "#include \"lib_handler.h\"\n#include <ctype.h> // Needed for tolower functions\n\n#include \"constants.h\"\n\nsoHandle_t lh_load_lib(const char *libName) {\n    soHandle_t h = OSQP_NULL;\n\n    if (!libName) {\n        #ifdef PRINTING\n        c_eprint(\"no library name given\");\n        #endif\n        return OSQP_NULL;\n    }\n\n#ifdef IS_WINDOWS\n    h = LoadLibrary (libName);\n    if (!h) {\n        #ifdef PRINTING\n        c_eprint(\"Windows error while loading dynamic library %s, error = %d\",\n                libName, (int)GetLastError());\n        #endif\n    }\n#else\n    h = dlopen (libName, RTLD_LAZY);\n    if (!h) {\n        #ifdef PRINTING\n        c_eprint(\"Error while loading dynamic library %s: %s\", libName, dlerror());\n        #endif\n    }\n#endif\n\n    return h;\n} /* lh_load_lib */\n\n\nc_int lh_unload_lib (soHandle_t h) {\n    c_int rc = 1;\n\n#ifdef IS_WINDOWS\n    rc = FreeLibrary (h);\n    rc = ! rc;\n#else\n    rc = dlclose (h);\n#endif\n\n    return rc;\n} /* LSL_unLoadLib */\n\n\n#ifdef IS_WINDOWS\ntypedef FARPROC symtype;\n#else\ntypedef void* symtype;\n#endif\n/** Loads a symbol from a dynamically linked library.\n * This function is not defined in the header to allow a workaround for the problem that dlsym returns an object instead of a function pointer.\n * However, Windows also needs special care.\n *\n * The method does six attempts to load the symbol. Next to its given name, it also tries variations of lower case and upper case form and with an extra underscore.\n * @param h Handle of dynamically linked library.\n * @param symName Name of the symbol to load.\n * @return A pointer to the symbol, or OSQP_NULL if not found.\n */\nsymtype lh_load_sym (soHandle_t h, const char *symName) {\n    symtype s;\n    const char *from;\n    char *to;\n    const char *tripSym;\n    char* err;\n    char lcbuf[257];\n    char ucbuf[257];\n    char ocbuf[257];\n    size_t symLen;\n    int trip;\n\n    s = OSQP_NULL;\n    err = OSQP_NULL;\n\n    /* search in this order:\n     *  1. original\n     *  2. lower_\n     *  3. upper_\n     *  4. original_\n     *  5. lower\n     *  6. upper\n     */\n\n    symLen = 0;\n    for (trip = 1;  trip <= 6;  trip++) {\n        switch (trip) {\n        case 1:                             /* original */\n            tripSym = symName;\n            break;\n        case 2:                             /* lower_ */\n            for (from = symName, to = lcbuf;  *from;  from++, to++) {\n                *to = tolower(*from);\n            }\n            symLen = from - symName;\n            *to++ = '_';\n            *to = '\\0';\n            tripSym = lcbuf;\n            break;\n        case 3:                             /* upper_ */\n            for (from = symName, to = ucbuf;  *from;  from++, to++) {\n                *to = toupper(*from);\n            }\n            *to++ = '_';\n            *to = '\\0';\n            tripSym = ucbuf;\n            break;\n        case 4:                             /* original_ */\n            memcpy (ocbuf, symName, symLen);\n            ocbuf[symLen] = '_';\n            ocbuf[symLen+1] = '\\0';\n            tripSym = ocbuf;\n            break;\n        case 5:                             /* lower */\n            lcbuf[symLen] = '\\0';\n            tripSym = lcbuf;\n            break;\n        case 6:                             /* upper */\n            ucbuf[symLen] = '\\0';\n            tripSym = ucbuf;\n            break;\n        default:\n            tripSym = symName;\n        } /* end switch */\n#ifdef IS_WINDOWS\n        s = GetProcAddress (h, tripSym);\n        if (s) {\n            return s;\n        } else {\n            #ifdef PRINTING\n            c_eprint(\"Cannot find symbol %s in dynamic library, error = %d\",\n                    symName, (int)GetLastError());\n            #endif\n        }\n#else\n        s = dlsym (h, tripSym);\n        err = dlerror();  /* we have only one chance; a successive call to dlerror() returns OSQP_NULL */\n        if (err) {\n            #ifdef PRINTING\n            c_eprint(\"Cannot find symbol %s in dynamic library, error = %s\",\n                    symName, err);\n            #endif\n        } else {\n            return s;\n        }\n#endif\n    } /* end loop over symbol name variations */\n\n    return OSQP_NULL;\n} /* lh_load_sym */\n",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/lin_sys/direct/qdldl/qdldl_sources/examples/julia/example.jl": "#These types must be the same as in the QDLDL header\nc_int   = Int64;\nc_float = Float64;\nc_bool  = Uint8;\n\n\nfunction qdMatExample()\n\n    i = [1, 7, 2, 3, 6, 10, 2, 3, 10, 4, 8, 5, 2, 6, 1, 7, 9, 4, 8, 7, 9, 2, 3, 10]\n    j = [1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 10]\n    s = [1.000000e+00, 3.503210e-01, 4.606408e-01, -1.211894e-01, -2.900576e-02, 1.824522e-01, -1.211894e-01, 4.179283e-01, -1.565056e+00, 1.778279e-01, -8.453948e-02, 1.000000e-01, -2.900576e-02, -1.000000e+00, 3.503210e-01, -4.410924e-01, 1.786632e-01, -8.453948e-02, -3.162278e-01, 1.786632e-01, -2.990768e-01, 1.824522e-01, -1.565056e+00, -1.000000e-01]\n\n    A = sparse(i,j,s)\nend\n\n\nldllibH = Libdl.dlopen(\"../../build/out/libqdldl.\" * Base.Libdl.dlext)\nQDLDL_etree    = Libdl.dlsym(ldllibH, :QDLDL_etree)\nQDLDL_factor   = Libdl.dlsym(ldllibH, :QDLDL_factor)\nQDLDL_Lsolve   = Libdl.dlsym(ldllibH, :QDLDL_Lsolve)\nQDLDL_Ltsolve  = Libdl.dlsym(ldllibH, :QDLDL_Ltsolve)\nQDLDL_solve    = Libdl.dlsym(ldllibH, :QDLDL_solve)\n\n\nA = qdMatExample()::SparseMatrixCSC{c_float,c_int}\nA = sparse([1.0 1.0;1.0 -1.0]);\nb = cumsum(ones(c_float(A.n)));\n\nA = A::SparseMatrixCSC{c_float,c_int}\n\nprintln(\"\\n-------------------\")\nprintln(\"Testing: QDLDL_etree\")\nprintln(\"-------------------\")\nwork   = zeros(c_int,A.n)\nLnz    = zeros(c_int,A.n)\netree  = zeros(c_int,A.n)\n\n#Julia matrices are 1-index.  C code is 0 indexed.\n#use only the upper triangle\nAtriu = triu(A);\nAp = Atriu.colptr-1;\nAi = Atriu.rowval-1;\nAx = Atriu.nzval;\n\n#Construct the elimination tree and column counts for A\nsumLnz = ccall(QDLDL_etree,c_int,(c_int,Ptr{c_int},Ptr{c_int},Ptr{c_int},Ptr{c_int},Ptr{c_int}),A.n,Ap,Ai,work,Lnz,etree)\n\n\nprintln(\"\\n-------------------\")\nprintln(\"Testing: QDLDL_factor\")\nprintln(\"-------------------  \")\n\n#allocate target matrix data for L\nLn = A.n;\nLp = zeros(c_int,A.n+1);\nLi = zeros(c_int,sumLnz);\nLx = zeros(c_float,sumLnz);\n\n#allocate D and its inverse\nD      = zeros(c_float,A.n)\nDinv   = zeros(c_float,A.n)\n\n#scratch workspace values\nfwork            = zeros(c_float,Ln)\niwork            = zeros(c_int,Ln*3)\nbwork            = zeros(c_bool,Ln)\n\n#call the C factorization function\nccall(QDLDL_factor,c_int,\n     (     c_int,              #n\n           Ptr{c_int},         #Ap\n           Ptr{c_int},         #Ai\n           Ptr{c_float},       #Ax\n           Ptr{c_int},         #Lp\n           Ptr{c_int},         #Li\n           Ptr{c_float},       #Lx\n           Ptr{c_float},       #D\n           Ptr{c_float},       #Dinv\n           Ptr{c_int},         #Lnz\n           Ptr{c_int},         #etree\n           Ptr{c_bool},        #bwork\n           Ptr{c_int},         #iwork\n           Ptr{c_float}),      #fwork\n      A.n,Ap,Ai,Ax,Lp,Li,Lx,D,Dinv,Lnz,etree,bwork,iwork,fwork)\n\n#Julia indexing is 1 based\nL = SparseMatrixCSC(Ln,Ln,Lp+1,Li+1,Lx)\nprintln(\"L = \", L)\nprintln(\"D = \", D)\nprintln(\"Inf-norm factorisation tolerance : \", norm( (L+I)*diagm(D)*(L'+I) - A, Inf)  );\n\n\nprintln(\"\\n-------------------\")\nprintln(\"Testing: QDLDL_solve\")\nprintln(\"-------------------  \")\n\n#call the C solve function\nx = copy(b)\nccall(QDLDL_solve,Void,\n     (     c_int,              #n\n           Ptr{c_int},         #Lp\n           Ptr{c_int},         #Li\n           Ptr{c_float},       #Lx\n           Ptr{c_float},       #Dinv\n           Ptr{c_float}),      #x (starts as b)\n        Ln,Lp,Li,Lx,Dinv,x)\n\nprintln(\"A\\b solve tolerance: \", norm(x-A\\b, Inf)  );\n\nLibdl.dlclose(ldllibH)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/.git/objects/pack/pack-7163a3c60bd08c45213b7fe18cf912365c2c934b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/.git/objects/pack/pack-7163a3c60bd08c45213b7fe18cf912365c2c934b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/.git/modules/lin_sys/direct/qdldl/qdldl_sources/objects/pack/pack-e8cc360625b8c93b2b6e6674c6bad5939bc3fe89.pack",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/.git/modules/lin_sys/direct/qdldl/qdldl_sources/objects/pack/pack-e8cc360625b8c93b2b6e6674c6bad5939bc3fe89.idx",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/docs/_static/img/logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/docs/_static/img/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-0.5.0-yyg2wu4jpfurqizjeagt4p5tlfp7ollc/spack-src/docs/_static/img/favicon.ico"
    ],
    "total_files": 231
}