{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/pthreads/include/pthread.h": "/*\n * Posix Threads library for Microsoft Windows\n *\n * Use at own risk, there is no implied warranty to this code.\n * It uses undocumented features of Microsoft Windows that can change\n * at any time in the future.\n *\n * (C) 2010 Lockless Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *  * Neither the name of Lockless Inc. nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AN\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * You may want to use the MingW64 winpthreads library instead.\n * It is based on this, but adds error checking.\n */\n\n/*\n * Version 1.0.1 Released 2 Feb 2012\n * Fixes pthread_barrier_destroy() to wait for threads to exit the barrier.\n */\n\n#ifndef WIN_PTHREADS\n#define WIN_PTHREADS\n\n\n#include <windows.h>\n#include <intrin.h>\n#include <setjmp.h>\n#include <errno.h>\n#include <sys/timeb.h>\n#include <process.h>\n\n#ifndef ETIMEDOUT\n#define ETIMEDOUT\t110\n#endif\n#ifndef ENOTSUP\n#define ENOTSUP\t\t134\n#endif\n\n#define PTHREAD_CANCEL_DISABLE 0\n#define PTHREAD_CANCEL_ENABLE 0x01\n\n#define PTHREAD_CANCEL_DEFERRED 0\n#define PTHREAD_CANCEL_ASYNCHRONOUS 0x02\n\n#define PTHREAD_CREATE_JOINABLE 0\n#define PTHREAD_CREATE_DETACHED 0x04\n\n#define PTHREAD_EXPLICT_SCHED 0\n#define PTHREAD_INHERIT_SCHED 0x08\n\n#define PTHREAD_SCOPE_PROCESS 0\n#define PTHREAD_SCOPE_SYSTEM 0x10\n\n#define PTHREAD_DEFAULT_ATTR (PTHREAD_CANCEL_ENABLE)\n\n#define PTHREAD_CANCELED ((void *) 0xDEADBEEF)\n\n#define PTHREAD_ONCE_INIT 0\n#define PTHREAD_MUTEX_INITIALIZER {(void*)-1,-1,0,0,0,0}\n#define PTHREAD_RWLOCK_INITIALIZER {0}\n#define PTHREAD_COND_INITIALIZER {0}\n#define PTHREAD_BARRIER_INITIALIZER \\\n\t{0,0,PTHREAD_MUTEX_INITIALIZER,PTHREAD_COND_INITIALIZER}\n#define PTHREAD_SPINLOCK_INITIALIZER 0\n\n#define PTHREAD_DESTRUCTOR_ITERATIONS 256\n#define PTHREAD_KEYS_MAX (1<<20)\n\n#define PTHREAD_MUTEX_NORMAL 0\n#define PTHREAD_MUTEX_ERRORCHECK 1\n#define PTHREAD_MUTEX_RECURSIVE 2\n#define PTHREAD_MUTEX_DEFAULT 3\n#define PTHREAD_MUTEX_SHARED 4\n#define PTHREAD_MUTEX_PRIVATE 0\n#define PTHREAD_PRIO_NONE 0\n#define PTHREAD_PRIO_INHERIT 8\n#define PTHREAD_PRIO_PROTECT 16\n#define PTHREAD_PRIO_MULT 32\n#define PTHREAD_PROCESS_SHARED 0\n#define PTHREAD_PROCESS_PRIVATE 1\n\n#define PTHREAD_BARRIER_SERIAL_THREAD 1\n\n#ifdef _X86_\n    #define INTERLOCKED_COMPARE_EXCHANGE(destination, exchange, comparand) _InterlockedCompareExchange((volatile long*) destination, (long) exchange, (long) comparand)\n#else\n    #define INTERLOCKED_COMPARE_EXCHANGE(destination, exchange, comparand) _InterlockedCompareExchangePointer((volatile PVOID*) destination, (void*) exchange, (void*) comparand)\n#endif\n\n#if defined(PTHREAD_BUILDING_SHARED_LIBRARY)\n    #define PTHREAD_EXPORT __declspec(dllexport)\n#elif defined(PTHREAD_BUILDING_STATIC_LIBRARY)\n    #define PTHREAD_EXPORT\n#else\n    #define PTHREAD_EXPORT __declspec(dllimport)\n#endif\n\n\n#if _MSC_VER >= 1900\n#include <ctime>\n#else\n/* Windows doesn't have this, so declare it ourselves. */\nstruct timespec\n{\n\t/* long long in windows is the same as long in unix for 64bit */\n\tlong long tv_sec;\n\tlong long tv_nsec;\n};\n#endif\n\ntypedef struct _pthread_cleanup _pthread_cleanup;\nstruct _pthread_cleanup\n{\n\tvoid (*func)(void *);\n\tvoid *arg;\n\t_pthread_cleanup *next;\n};\n\nstruct _pthread_v\n{\n\tvoid *ret_arg;\n\tvoid *(* func)(void *);\n\t_pthread_cleanup *clean;\n\tHANDLE h;\n\tint cancelled;\n\tunsigned p_state;\n\tint keymax;\n\tvoid **keyval;\n\n\tjmp_buf jb;\n};\n\ntypedef struct _pthread_v *pthread_t;\n\ntypedef struct pthread_barrier_t pthread_barrier_t;\nstruct pthread_barrier_t\n{\n\tint count;\n\tint total;\n\tCRITICAL_SECTION m;\n\tCONDITION_VARIABLE cv;\n};\n\ntypedef struct pthread_attr_t pthread_attr_t;\nstruct pthread_attr_t\n{\n\tunsigned p_state;\n\tvoid *stack;\n\tsize_t s_size;\n};\n\ntypedef long pthread_once_t;\ntypedef unsigned pthread_mutexattr_t;\ntypedef SRWLOCK pthread_rwlock_t;\ntypedef CRITICAL_SECTION pthread_mutex_t;\ntypedef unsigned pthread_key_t;\ntypedef void *pthread_barrierattr_t;\ntypedef long pthread_spinlock_t;\ntypedef int pthread_condattr_t;\ntypedef CONDITION_VARIABLE pthread_cond_t;\ntypedef int pthread_rwlockattr_t;\n\nextern PTHREAD_EXPORT volatile long _pthread_cancelling;\n\nextern PTHREAD_EXPORT int _pthread_concur;\n\n/* Will default to zero as needed */\nextern PTHREAD_EXPORT pthread_once_t _pthread_tls_once;\nextern PTHREAD_EXPORT DWORD _pthread_tls;\n\n/* Note initializer is zero, so this works */\nextern PTHREAD_EXPORT pthread_rwlock_t _pthread_key_lock;\nextern PTHREAD_EXPORT long _pthread_key_max;\nextern PTHREAD_EXPORT long _pthread_key_sch;\nextern PTHREAD_EXPORT void (**_pthread_key_dest)(void *);\n\n\n#define pthread_cleanup_push(F, A)\\\n{\\\n\tconst _pthread_cleanup _pthread_cup = {(F), (A), pthread_self()->clean};\\\n\t_ReadWriteBarrier();\\\n\tpthread_self()->clean = (_pthread_cleanup *) &_pthread_cup;\\\n\t_ReadWriteBarrier()\n\n/* Note that if async cancelling is used, then there is a race here */\n#define pthread_cleanup_pop(E)\\\n\t(pthread_self()->clean = _pthread_cup.next, (E?_pthread_cup.func(_pthread_cup.arg):0));}\n\nstatic void _pthread_once_cleanup(pthread_once_t *o)\n{\n\t*o = 0;\n}\n\nstatic pthread_t pthread_self(void);\nstatic int pthread_once(pthread_once_t *o, void (*func)(void))\n{\n\tlong state = *o;\n\n\t_ReadWriteBarrier();\n\n\twhile (state != 1)\n\t{\n\t\tif (!state)\n\t\t{\n\t\t\tif (!_InterlockedCompareExchange(o, 2, 0))\n\t\t\t{\n\t\t\t\t/* Success */\n#ifdef __cplusplus\n\t\t\t\tpthread_cleanup_push(reinterpret_cast<void (__cdecl *)(void *)>(_pthread_once_cleanup), o);\n#else\n                pthread_cleanup_push(_pthread_once_cleanup, o);\n#endif\n\t\t\t\tfunc();\n\t\t\t\tpthread_cleanup_pop(0);\n\n\t\t\t\t/* Mark as done */\n\t\t\t\t*o = 1;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tYieldProcessor();\n\n\t\t_ReadWriteBarrier();\n\n\t\tstate = *o;\n\t}\n\n\t/* Done */\n\treturn 0;\n}\n\nstatic int _pthread_once_raw(pthread_once_t *o, void (*func)(void))\n{\n\tlong state = *o;\n\n\t_ReadWriteBarrier();\n\n\twhile (state != 1)\n\t{\n\t\tif (!state)\n\t\t{\n\t\t\tif (!_InterlockedCompareExchange(o, 2, 0))\n\t\t\t{\n\t\t\t\t/* Success */\n\t\t\t\tfunc();\n\n\t\t\t\t/* Mark as done */\n\t\t\t\t*o = 1;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tYieldProcessor();\n\n\t\t_ReadWriteBarrier();\n\n\t\tstate = *o;\n\t}\n\n\t/* Done */\n\treturn 0;\n}\n\nstatic int pthread_mutex_lock(pthread_mutex_t *m)\n{\n\tEnterCriticalSection(m);\n\treturn 0;\n}\n\nstatic int pthread_mutex_unlock(pthread_mutex_t *m)\n{\n\tLeaveCriticalSection(m);\n\treturn 0;\n}\n\nstatic int pthread_mutex_trylock(pthread_mutex_t *m)\n{\n\treturn TryEnterCriticalSection(m) ? 0 : EBUSY;\n}\n\nstatic int pthread_mutex_init(pthread_mutex_t *m, pthread_mutexattr_t *a)\n{\n\t(void) a;\n\tInitializeCriticalSection(m);\n\n\treturn 0;\n}\n\nstatic int pthread_mutex_destroy(pthread_mutex_t *m)\n{\n\tDeleteCriticalSection(m);\n\treturn 0;\n}\n\n#define pthread_mutex_getprioceiling(M, P) ENOTSUP\n#define pthread_mutex_setprioceiling(M, P) ENOTSUP\n\nstatic int pthread_equal(pthread_t t1, pthread_t t2)\n{\n\treturn t1 == t2;\n}\n\nstatic void pthread_testcancel(void);\n\nstatic int pthread_rwlock_init(pthread_rwlock_t *l, pthread_rwlockattr_t *a)\n{\n\t(void) a;\n\tInitializeSRWLock(l);\n\n\treturn 0;\n}\n\nstatic int pthread_rwlock_destroy(pthread_rwlock_t *l)\n{\n\t(void) *l;\n\treturn 0;\n}\n\nstatic int pthread_rwlock_rdlock(pthread_rwlock_t *l)\n{\n\tpthread_testcancel();\n\tAcquireSRWLockShared(l);\n\n\treturn 0;\n}\n\nstatic int pthread_rwlock_wrlock(pthread_rwlock_t *l)\n{\n\tpthread_testcancel();\n\tAcquireSRWLockExclusive(l);\n\n\treturn 0;\n}\n\nstatic void pthread_tls_init(void)\n{\n\t_pthread_tls = TlsAlloc();\n\n\t/* Cannot continue if out of indexes */\n\tif (_pthread_tls == TLS_OUT_OF_INDEXES) abort();\n}\n\nstatic int pthread_rwlock_unlock(pthread_rwlock_t *l)\n{\n\tvoid *state = *(void **)l;\n\n\tif (state == (void *) 1)\n\t{\n\t\t/* Known to be an exclusive lock */\n\t\tReleaseSRWLockExclusive(l);\n\t}\n\telse\n\t{\n\t\t/* A shared unlock will work */\n\t\tReleaseSRWLockShared(l);\n\t}\n\n\treturn 0;\n}\n\nstatic void _pthread_cleanup_dest(pthread_t t)\n{\n\tint i, j;\n\n\tfor (j = 0; j < PTHREAD_DESTRUCTOR_ITERATIONS; j++)\n\t{\n\t\tint flag = 0;\n\n\t\tfor (i = 0; i < t->keymax; i++)\n\t\t{\n\t\t\tvoid *val = t->keyval[i];\n\n\t\t\tif (val)\n\t\t\t{\n\t\t\t\tpthread_rwlock_rdlock(&_pthread_key_lock);\n\t\t\t\tif ((uintptr_t) _pthread_key_dest[i] > 1)\n\t\t\t\t{\n\t\t\t\t\t/* Call destructor */\n\t\t\t\t\tt->keyval[i] = NULL;\n\t\t\t\t\t_pthread_key_dest[i](val);\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\t\t\t}\n\t\t}\n\n\t\t/* Nothing to do? */\n\t\tif (!flag) return;\n\t}\n}\n\nstatic pthread_t pthread_self(void)\n{\n\tpthread_t t;\n\n\t_pthread_once_raw(&_pthread_tls_once, pthread_tls_init);\n\n\tt = (pthread_t) TlsGetValue(_pthread_tls);\n\n\t/* Main thread? */\n\tif (!t)\n\t{\n\t\tt = (pthread_t) malloc(sizeof(struct _pthread_v));\n\n\t\t/* If cannot initialize main thread, then the only thing we can do is abort */\n\t\tif (!t) abort();\n\n\t\tt->ret_arg = NULL;\n\t\tt->func = NULL;\n\t\tt->clean = NULL;\n\t\tt->cancelled = 0;\n\t\tt->p_state = PTHREAD_DEFAULT_ATTR;\n\t\tt->keymax = 0;\n\t\tt->keyval = NULL;\n\t\tt->h = GetCurrentThread();\n\n\t\t/* Save for later */\n\t\tTlsSetValue(_pthread_tls, t);\n\n\t\tif (setjmp(t->jb))\n\t\t{\n\t\t\t/* Make sure we free ourselves if we are detached */\n\t\t\tif (!t->h) free(t);\n\n\t\t\t/* Time to die */\n\t\t\t_endthreadex(0);\n\t\t}\n\t}\n\n\treturn t;\n}\n\n\nstatic int pthread_rwlock_tryrdlock(pthread_rwlock_t *l)\n{\n\t/* Get the current state of the lock */\n\tvoid *state = *(void **) l;\n\n\tif (!state)\n\t{\n\t\t/* Unlocked to locked */\n\t\tif (!INTERLOCKED_COMPARE_EXCHANGE((volatile PVOID *) l, (void *)0x11, NULL)) return 0;\n\t\treturn EBUSY;\n\t}\n\n\t/* A single writer exists */\n\tif (state == (void *) 1) return EBUSY;\n\n\t/* Multiple writers exist? */\n\tif ((uintptr_t) state & 14) return EBUSY;\n\n\tif ((void*) INTERLOCKED_COMPARE_EXCHANGE((volatile PVOID *) l, (void *) ((uintptr_t)state + 16), state) == state) return 0;\n\n\treturn EBUSY;\n}\n\nstatic int pthread_rwlock_trywrlock(pthread_rwlock_t *l)\n{\n\t/* Try to grab lock if it has no users */\n\tif (!INTERLOCKED_COMPARE_EXCHANGE((volatile PVOID *) l, (void *)1, NULL)) return 0;\n\n\treturn EBUSY;\n}\n\nstatic unsigned long long _pthread_time_in_ms(void)\n{\n\tstruct __timeb64 tb;\n\n\t_ftime64(&tb);\n\n\treturn tb.time * 1000 + tb.millitm;\n}\n\nstatic unsigned long long _pthread_time_in_ms_from_timespec(const struct timespec *ts)\n{\n\tunsigned long long t = ts->tv_sec * 1000;\n\tt += ts->tv_nsec / 1000000;\n\n\treturn t;\n}\n\nstatic unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts)\n{\n\tunsigned long long t1 = _pthread_time_in_ms_from_timespec(ts);\n\tunsigned long long t2 = _pthread_time_in_ms();\n\n\t/* Prevent underflow */\n\tif (t1 < t2) return 0;\n\treturn t1 - t2;\n}\n\nstatic int pthread_rwlock_timedrdlock(pthread_rwlock_t *l, const struct timespec *ts)\n{\n\tunsigned long long ct = _pthread_time_in_ms();\n\tunsigned long long t = _pthread_time_in_ms_from_timespec(ts);\n\n\tpthread_testcancel();\n\n\t/* Use a busy-loop */\n\twhile (1)\n\t{\n\t\t/* Try to grab lock */\n\t\tif (!pthread_rwlock_tryrdlock(l)) return 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t) return ETIMEDOUT;\n\t}\n}\n\nstatic int pthread_rwlock_timedwrlock(pthread_rwlock_t *l, const struct timespec *ts)\n{\n\tunsigned long long ct = _pthread_time_in_ms();\n\tunsigned long long t = _pthread_time_in_ms_from_timespec(ts);\n\n\tpthread_testcancel();\n\n\t/* Use a busy-loop */\n\twhile (1)\n\t{\n\t\t/* Try to grab lock */\n\t\tif (!pthread_rwlock_trywrlock(l)) return 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t) return ETIMEDOUT;\n\t}\n}\n\nstatic int pthread_get_concurrency(int *val)\n{\n\t*val = _pthread_concur;\n\treturn 0;\n}\n\nstatic int pthread_set_concurrency(int val)\n{\n\t_pthread_concur = val;\n\treturn 0;\n}\n\n#define pthread_getschedparam(T, P, S) ENOTSUP\n#define pthread_setschedparam(T, P, S) ENOTSUP\n#define pthread_getcpuclockid(T, C) ENOTSUP\n\nstatic int pthread_exit(void *res)\n{\n\tpthread_t t = pthread_self();\n\n\tt->ret_arg = res;\n\n\t_pthread_cleanup_dest(t);\n\n\tlongjmp(t->jb, 1);\n}\n\n\nstatic void _pthread_invoke_cancel(void)\n{\n\t_pthread_cleanup *pcup;\n\n\t_InterlockedDecrement(&_pthread_cancelling);\n\n\t/* Call cancel queue */\n\tfor (pcup = pthread_self()->clean; pcup; pcup = pcup->next)\n\t{\n\t\tpcup->func(pcup->arg);\n\t}\n\n\tpthread_exit(PTHREAD_CANCELED);\n}\n\nstatic void pthread_testcancel(void)\n{\n\tif (_pthread_cancelling)\n\t{\n\t\tpthread_t t = pthread_self();\n\n\t\tif (t->cancelled && (t->p_state & PTHREAD_CANCEL_ENABLE))\n\t\t{\n\t\t\t_pthread_invoke_cancel();\n\t\t}\n\t}\n}\n\n\nstatic int pthread_cancel(pthread_t t)\n{\n\tif (t->p_state & PTHREAD_CANCEL_ASYNCHRONOUS)\n\t{\n\t\t/* Dangerous asynchronous cancelling */\n\t\tCONTEXT ctxt;\n\n\t\t/* Already done? */\n\t\tif (t->cancelled) return ESRCH;\n\n\t\tctxt.ContextFlags = CONTEXT_CONTROL;\n\n\t\tSuspendThread(t->h);\n\t\tGetThreadContext(t->h, &ctxt);\n#ifdef _M_X64\n\t\tctxt.Rip = (uintptr_t) _pthread_invoke_cancel;\n#else\n\t\tctxt.Eip = (uintptr_t) _pthread_invoke_cancel;\n#endif\n\t\tSetThreadContext(t->h, &ctxt);\n\n\t\t/* Also try deferred Cancelling */\n\t\tt->cancelled = 1;\n\n\t\t/* Notify everyone to look */\n\t\t_InterlockedIncrement(&_pthread_cancelling);\n\n\t\tResumeThread(t->h);\n\t}\n\telse\n\t{\n\t\t/* Safe deferred Cancelling */\n\t\tt->cancelled = 1;\n\n\t\t/* Notify everyone to look */\n\t\t_InterlockedIncrement(&_pthread_cancelling);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned _pthread_get_state(pthread_attr_t *attr, unsigned flag)\n{\n\treturn attr->p_state & flag;\n}\n\nstatic int _pthread_set_state(pthread_attr_t *attr, unsigned flag, unsigned val)\n{\n\tif (~flag & val) return EINVAL;\n\tattr->p_state &= ~flag;\n\tattr->p_state |= val;\n\n\treturn 0;\n}\n\nstatic int pthread_attr_init(pthread_attr_t *attr)\n{\n\tattr->p_state = PTHREAD_DEFAULT_ATTR;\n\tattr->stack = NULL;\n\tattr->s_size = 0;\n\treturn 0;\n}\n\nstatic int pthread_attr_destroy(pthread_attr_t *attr)\n{\n\t/* No need to do anything */\n\treturn 0;\n}\n\n\nstatic int pthread_attr_setdetachstate(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_CREATE_DETACHED, flag);\n}\n\nstatic int pthread_attr_getdetachstate(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_CREATE_DETACHED);\n\treturn 0;\n}\n\nstatic int pthread_attr_setinheritsched(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_INHERIT_SCHED, flag);\n}\n\nstatic int pthread_attr_getinheritsched(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_INHERIT_SCHED);\n\treturn 0;\n}\n\nstatic int pthread_attr_setscope(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_SCOPE_SYSTEM, flag);\n}\n\nstatic int pthread_attr_getscope(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_SCOPE_SYSTEM);\n\treturn 0;\n}\n\nstatic int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stack)\n{\n\t*stack = attr->stack;\n\treturn 0;\n}\n\nstatic int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack)\n{\n\tattr->stack = stack;\n\treturn 0;\n}\n\nstatic int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *size)\n{\n\t*size = attr->s_size;\n\treturn 0;\n}\n\nstatic int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)\n{\n\tattr->s_size = size;\n\treturn 0;\n}\n\n#define pthread_attr_getguardsize(A, S) ENOTSUP\n#define pthread_attr_setgaurdsize(A, S) ENOTSUP\n#define pthread_attr_getschedparam(A, S) ENOTSUP\n#define pthread_attr_setschedparam(A, S) ENOTSUP\n#define pthread_attr_getschedpolicy(A, S) ENOTSUP\n#define pthread_attr_setschedpolicy(A, S) ENOTSUP\n\n\nstatic int pthread_setcancelstate(int state, int *oldstate)\n{\n\tpthread_t t = pthread_self();\n\n\tif ((state & PTHREAD_CANCEL_ENABLE) != state) return EINVAL;\n\tif (oldstate) *oldstate = t->p_state & PTHREAD_CANCEL_ENABLE;\n\tt->p_state &= ~PTHREAD_CANCEL_ENABLE;\n\tt->p_state |= state;\n\n\treturn 0;\n}\n\nstatic int pthread_setcanceltype(int type, int *oldtype)\n{\n\tpthread_t t = pthread_self();\n\n\tif ((type & PTHREAD_CANCEL_ASYNCHRONOUS) != type) return EINVAL;\n\tif (oldtype) *oldtype = t->p_state & PTHREAD_CANCEL_ASYNCHRONOUS;\n\tt->p_state &= ~PTHREAD_CANCEL_ASYNCHRONOUS;\n\tt->p_state |= type;\n\n\treturn 0;\n}\n\nstatic int pthread_create_wrapper(void *args)\n{\n\tstruct _pthread_v *tv = (_pthread_v*) args;\n\tint i, j;\n\n\t_pthread_once_raw(&_pthread_tls_once, pthread_tls_init);\n\n\tTlsSetValue(_pthread_tls, tv);\n\n\tif (!setjmp(tv->jb))\n\t{\n\t\t/* Call function and save return value */\n\t\ttv->ret_arg = tv->func(tv->ret_arg);\n\n\t\t/* Clean up destructors */\n\t\t_pthread_cleanup_dest(tv);\n\t}\n\n\t/* If we exit too early, then we can race with create */\n\twhile (tv->h == (HANDLE) -1)\n\t{\n\t\tYieldProcessor();\n\t\t_ReadWriteBarrier();\n\t}\n\n\t/* Make sure we free ourselves if we are detached */\n\tif (!tv->h) free(tv);\n\n\treturn 0;\n}\n\nstatic int pthread_create(pthread_t *th, pthread_attr_t *attr, void *(* func)(void *), void *arg)\n{\n\tstruct _pthread_v *tv = (_pthread_v*) malloc(sizeof(struct _pthread_v));\n\tunsigned ssize = 0;\n\n\tif (!tv) return 1;\n\n\t*th = tv;\n\n\t/* Save data in pthread_t */\n\ttv->ret_arg = arg;\n\ttv->func = func;\n\ttv->clean = NULL;\n\ttv->cancelled = 0;\n\ttv->p_state = PTHREAD_DEFAULT_ATTR;\n\ttv->keymax = 0;\n\ttv->keyval = NULL;\n\ttv->h = (HANDLE) -1;\n\n\tif (attr)\n\t{\n\t\ttv->p_state = attr->p_state;\n\t\tssize = attr->s_size;\n\t}\n\n\t/* Make sure tv->h has value of -1 */\n\t_ReadWriteBarrier();\n\n#ifdef __cplusplus\n\ttv->h = (HANDLE) _beginthreadex(NULL, ssize, reinterpret_cast<unsigned int (__stdcall *)(void *)>(pthread_create_wrapper), tv, 0, NULL);\n#else\n    tv->h = (HANDLE) _beginthreadex(NULL, ssize, pthread_create_wrapper, tv, 0, NULL);\n#endif\n\n\t/* Failed */\n\tif (!tv->h) return 1;\n\n\tif (tv->p_state & PTHREAD_CREATE_DETACHED)\n\t{\n\t\tCloseHandle(tv->h);\n\t\t_ReadWriteBarrier();\n\t\ttv->h = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int pthread_join(pthread_t t, void **res)\n{\n\tstruct _pthread_v *tv = t;\n\n\tpthread_testcancel();\n\n\tWaitForSingleObject(tv->h, INFINITE);\n\tCloseHandle(tv->h);\n\n\t/* Obtain return value */\n\tif (res) *res = tv->ret_arg;\n\n\tfree(tv);\n\n\treturn 0;\n}\n\nstatic int pthread_detach(pthread_t t)\n{\n\tstruct _pthread_v *tv = t;\n\n\t/*\n\t * This can't race with thread exit because\n\t * our call would be undefined if called on a dead thread.\n\t */\n\n\tCloseHandle(tv->h);\n\t_ReadWriteBarrier();\n\ttv->h = 0;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_init(pthread_mutexattr_t *a)\n{\n\t*a = 0;\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_destroy(pthread_mutexattr_t *a)\n{\n\t(void) a;\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_gettype(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & 3;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type)\n{\n\tif ((unsigned) type > 3) return EINVAL;\n\t*a &= ~3;\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_getpshared(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & 4;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_setpshared(pthread_mutexattr_t * a, int type)\n{\n\tif ((type & 4) != type) return EINVAL;\n\n\t*a &= ~4;\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_getprotocol(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & (8 + 16);\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type)\n{\n\tif ((type & (8 + 16)) != 8 + 16) return EINVAL;\n\n\t*a &= ~(8 + 16);\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *a, int * prio)\n{\n\t*prio = *a / PTHREAD_PRIO_MULT;\n\treturn 0;\n}\n\nstatic int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio)\n{\n\t*a &= (PTHREAD_PRIO_MULT - 1);\n\t*a += prio * PTHREAD_PRIO_MULT;\n\n\treturn 0;\n}\n\nstatic int pthread_mutex_timedlock(pthread_mutex_t *m, struct timespec *ts)\n{\n\tunsigned long long t, ct;\n\n\tstruct _pthread_crit_t\n\t{\n\t\tvoid *debug;\n\t\tLONG count;\n\t\tLONG r_count;\n\t\tHANDLE owner;\n\t\tHANDLE sem;\n\t\tULONG_PTR spin;\n\t};\n\n\t/* Try to lock it without waiting */\n\tif (!pthread_mutex_trylock(m)) return 0;\n\n\tct = _pthread_time_in_ms();\n\tt = _pthread_time_in_ms_from_timespec(ts);\n\n\twhile (1)\n\t{\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t) return ETIMEDOUT;\n\n\t\t/* Wait on semaphore within critical section */\n\t\tWaitForSingleObject(((struct _pthread_crit_t *)m)->sem, t - ct);\n\n\t\t/* Try to grab lock */\n\t\tif (!pthread_mutex_trylock(m)) return 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\t}\n}\n\n#define _PTHREAD_BARRIER_FLAG (1<<30)\n\nstatic int pthread_barrier_destroy(pthread_barrier_t *b)\n{\n\tEnterCriticalSection(&b->m);\n\n\twhile (b->total > _PTHREAD_BARRIER_FLAG)\n\t{\n\t\t/* Wait until everyone exits the barrier */\n\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t}\n\n\tLeaveCriticalSection(&b->m);\n\n\tDeleteCriticalSection(&b->m);\n\n\treturn 0;\n}\n\nstatic int pthread_barrier_init(pthread_barrier_t *b, void *attr, int count)\n{\n\t/* Ignore attr */\n\t(void) attr;\n\n\tb->count = count;\n\tb->total = 0;\n\n\tInitializeCriticalSection(&b->m);\n\tInitializeConditionVariable(&b->cv);\n\n\treturn 0;\n}\n\nstatic int pthread_barrier_wait(pthread_barrier_t *b)\n{\n\tEnterCriticalSection(&b->m);\n\n\twhile (b->total > _PTHREAD_BARRIER_FLAG)\n\t{\n\t\t/* Wait until everyone exits the barrier */\n\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t}\n\n\t/* Are we the first to enter? */\n\tif (b->total == _PTHREAD_BARRIER_FLAG) b->total = 0;\n\n\tb->total++;\n\n\tif (b->total == b->count)\n\t{\n\t\tb->total += _PTHREAD_BARRIER_FLAG - 1;\n\t\tWakeAllConditionVariable(&b->cv);\n\n\t\tLeaveCriticalSection(&b->m);\n\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\twhile (b->total < _PTHREAD_BARRIER_FLAG)\n\t\t{\n\t\t\t/* Wait until enough threads enter the barrier */\n\t\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t\t}\n\n\t\tb->total--;\n\n\t\t/* Get entering threads to wake up */\n\t\tif (b->total == _PTHREAD_BARRIER_FLAG) WakeAllConditionVariable(&b->cv);\n\n\t\tLeaveCriticalSection(&b->m);\n\n\t\treturn 0;\n\t}\n}\n\nstatic int pthread_barrierattr_init(void **attr)\n{\n\t*attr = NULL;\n\treturn 0;\n}\n\nstatic int pthread_barrierattr_destroy(void **attr)\n{\n\t/* Ignore attr */\n\t(void) attr;\n\n\treturn 0;\n}\n\nstatic int pthread_barrierattr_setpshared(void **attr, int s)\n{\n\t*attr = (void *) s;\n\treturn 0;\n}\n\nstatic int pthread_barrierattr_getpshared(void **attr, int *s)\n{\n\t*s = (int) (size_t) *attr;\n\n\treturn 0;\n}\n\nstatic int pthread_key_create(pthread_key_t *key, void (* dest)(void *))\n{\n\tint i;\n\tlong nmax;\n\tvoid (**d)(void *);\n\n\tif (!key) return EINVAL;\n\n\tpthread_rwlock_wrlock(&_pthread_key_lock);\n\n\tfor (i = _pthread_key_sch; i < _pthread_key_max; i++)\n\t{\n\t\tif (!_pthread_key_dest[i])\n\t\t{\n\t\t\t*key = i;\n\t\t\tif (dest)\n\t\t\t{\n\t\t\t\t_pthread_key_dest[i] = dest;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_pthread_key_dest[i] = (void(*)(void *))1;\n\t\t\t}\n\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < _pthread_key_sch; i++)\n\t{\n\t\tif (!_pthread_key_dest[i])\n\t\t{\n\t\t\t*key = i;\n\t\t\tif (dest)\n\t\t\t{\n\t\t\t\t_pthread_key_dest[i] = dest;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_pthread_key_dest[i] = (void(*)(void *))1;\n\t\t\t}\n\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!_pthread_key_max) _pthread_key_max = 1;\n\tif (_pthread_key_max == PTHREAD_KEYS_MAX)\n\t{\n\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\treturn ENOMEM;\n\t}\n\n\tnmax = _pthread_key_max * 2;\n\tif (nmax > PTHREAD_KEYS_MAX) nmax = PTHREAD_KEYS_MAX;\n\n\t/* No spare room anywhere */\n#ifdef __cplusplus\n\td = reinterpret_cast<void (__cdecl **)(void *)>(realloc(_pthread_key_dest, nmax * sizeof(*d)));\n#else\n    d = realloc(_pthread_key_dest, nmax * sizeof(*d));\n#endif\n    if (!d)\n\t{\n\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\treturn ENOMEM;\n\t}\n\n\t/* Clear new region */\n\tmemset((void *) &d[_pthread_key_max], 0, (nmax-_pthread_key_max)*sizeof(void *));\n\n\t/* Use new region */\n\t_pthread_key_dest = d;\n\t_pthread_key_sch = _pthread_key_max + 1;\n\t*key = _pthread_key_max;\n\t_pthread_key_max = nmax;\n\n\tif (dest)\n\t{\n\t\t_pthread_key_dest[*key] = dest;\n\t}\n\telse\n\t{\n\t\t_pthread_key_dest[*key] = (void(*)(void *))1;\n\t}\n\n\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\treturn 0;\n}\n\nstatic int pthread_key_delete(pthread_key_t key)\n{\n\tif (key > _pthread_key_max) return EINVAL;\n\tif (!_pthread_key_dest) return EINVAL;\n\n\tpthread_rwlock_wrlock(&_pthread_key_lock);\n\t_pthread_key_dest[key] = NULL;\n\n\t/* Start next search from our location */\n\tif (_pthread_key_sch > key) _pthread_key_sch = key;\n\n\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\treturn 0;\n}\n\nstatic void *pthread_getspecific(pthread_key_t key)\n{\n\tpthread_t t = pthread_self();\n\n\tif (key >= t->keymax) return NULL;\n\n\treturn t->keyval[key];\n\n}\n\nstatic int pthread_setspecific(pthread_key_t key, const void *value)\n{\n\tpthread_t t = pthread_self();\n\n\tif (key > t->keymax)\n\t{\n\t\tint keymax = (key + 1) * 2;\n\t\tvoid **kv = (void**) realloc(t->keyval, keymax * sizeof(void *));\n\n\t\tif (!kv) return ENOMEM;\n\n\t\t/* Clear new region */\n\t\tmemset(&kv[t->keymax], 0, (keymax - t->keymax)*sizeof(void*));\n\n\t\tt->keyval = kv;\n\t\tt->keymax = keymax;\n\t}\n\n\tt->keyval[key] = (void *) value;\n\n\treturn 0;\n}\n\n\nstatic int pthread_spin_init(pthread_spinlock_t *l, int pshared)\n{\n\t(void) pshared;\n\n\t*l = 0;\n\treturn 0;\n}\n\nstatic int pthread_spin_destroy(pthread_spinlock_t *l)\n{\n\t(void) l;\n\treturn 0;\n}\n\n/* No-fair spinlock due to lack of knowledge of thread number */\nstatic int pthread_spin_lock(pthread_spinlock_t *l)\n{\n\twhile (_InterlockedExchange(l, EBUSY))\n\t{\n\t\t/* Don't lock the bus whilst waiting */\n\t\twhile (*l)\n\t\t{\n\t\t\tYieldProcessor();\n\n\t\t\t/* Compiler barrier.  Prevent caching of *l */\n\t\t\t_ReadWriteBarrier();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pthread_spin_trylock(pthread_spinlock_t *l)\n{\n\treturn _InterlockedExchange(l, EBUSY);\n}\n\nstatic int pthread_spin_unlock(pthread_spinlock_t *l)\n{\n\t/* Compiler barrier.  The store below acts with release symmantics */\n\t_ReadWriteBarrier();\n\n\t*l = 0;\n\n\treturn 0;\n}\n\nstatic int pthread_cond_init(pthread_cond_t *c, pthread_condattr_t *a)\n{\n\t(void) a;\n\n\tInitializeConditionVariable(c);\n\treturn 0;\n}\n\nstatic int pthread_cond_signal(pthread_cond_t *c)\n{\n\tWakeConditionVariable(c);\n\treturn 0;\n}\n\nstatic int pthread_cond_broadcast(pthread_cond_t *c)\n{\n\tWakeAllConditionVariable(c);\n\treturn 0;\n}\n\nstatic int pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)\n{\n\tpthread_testcancel();\n\tSleepConditionVariableCS(c, m, INFINITE);\n\treturn 0;\n}\n\nstatic int pthread_cond_destroy(pthread_cond_t *c)\n{\n\t(void) c;\n\treturn 0;\n}\n\nstatic int pthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m, struct timespec *t)\n{\n\tunsigned long long tm = _pthread_rel_time_in_ms(t);\n\n\tpthread_testcancel();\n\n\tif (!SleepConditionVariableCS(c, m, tm)) return ETIMEDOUT;\n\n\t/* We can have a spurious wakeup after the timeout */\n\tif (!_pthread_rel_time_in_ms(t)) return ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int pthread_condattr_destroy(pthread_condattr_t *a)\n{\n\t(void) a;\n\treturn 0;\n}\n\n#define pthread_condattr_getclock(A, C) ENOTSUP\n#define pthread_condattr_setclock(A, C) ENOTSUP\n\nstatic int pthread_condattr_init(pthread_condattr_t *a)\n{\n\t*a = 0;\n\treturn 0;\n}\n\nstatic int pthread_condattr_getpshared(pthread_condattr_t *a, int *s)\n{\n\t*s = *a;\n\treturn 0;\n}\n\nstatic int pthread_condattr_setpshared(pthread_condattr_t *a, int s)\n{\n\t*a = s;\n\treturn 0;\n}\n\nstatic int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a)\n{\n\t(void) a;\n\treturn 0;\n}\n\nstatic int pthread_rwlockattr_init(pthread_rwlockattr_t *a)\n{\n\t*a = 0;\n}\n\nstatic int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s)\n{\n\t*s = *a;\n\treturn 0;\n}\n\nstatic int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s)\n{\n\t*a = s;\n\treturn 0;\n}\n\n\n/* No fork() in windows - so ignore this */\n#define pthread_atfork(F1,F2,F3) 0\n\n/* Windows has rudimentary signals support */\n#define pthread_kill(T, S) 0\n#define pthread_sigmask(H, S1, S2) 0\n\n\n/* Wrap cancellation points */\n/*\n#define accept(...) (pthread_testcancel(), accept(__VA_ARGS__))\n#define aio_suspend(...) (pthread_testcancel(), aio_suspend(__VA_ARGS__))\n#define clock_nanosleep(...) (pthread_testcancel(), clock_nanosleep(__VA_ARGS__))\n#define close(...) (pthread_testcancel(), close(__VA_ARGS__))\n#define connect(...) (pthread_testcancel(), connect(__VA_ARGS__))\n#define creat(...) (pthread_testcancel(), creat(__VA_ARGS__))\n#define fcntl(...) (pthread_testcancel(), fcntl(__VA_ARGS__))\n#define fdatasync(...) (pthread_testcancel(), fdatasync(__VA_ARGS__))\n#define fsync(...) (pthread_testcancel(), fsync(__VA_ARGS__))\n#define getmsg(...) (pthread_testcancel(), getmsg(__VA_ARGS__))\n#define getpmsg(...) (pthread_testcancel(), getpmsg(__VA_ARGS__))\n#define lockf(...) (pthread_testcancel(), lockf(__VA_ARGS__))\n#define mg_receive(...) (pthread_testcancel(), mg_receive(__VA_ARGS__))\n#define mg_send(...) (pthread_testcancel(), mg_send(__VA_ARGS__))\n#define mg_timedreceive(...) (pthread_testcancel(), mg_timedreceive(__VA_ARGS__))\n#define mg_timessend(...) (pthread_testcancel(), mg_timedsend(__VA_ARGS__))\n#define msgrcv(...) (pthread_testcancel(), msgrecv(__VA_ARGS__))\n#define msgsnd(...) (pthread_testcancel(), msgsnd(__VA_ARGS__))\n#define msync(...) (pthread_testcancel(), msync(__VA_ARGS__))\n#define nanosleep(...) (pthread_testcancel(), nanosleep(__VA_ARGS__))\n#define open(...) (pthread_testcancel(), open(__VA_ARGS__))\n#define pause(...) (pthread_testcancel(), pause(__VA_ARGS__))\n#define poll(...) (pthread_testcancel(), poll(__VA_ARGS__))\n#define pread(...) (pthread_testcancel(), pread(__VA_ARGS__))\n#define pselect(...) (pthread_testcancel(), pselect(__VA_ARGS__))\n#define putmsg(...) (pthread_testcancel(), putmsg(__VA_ARGS__))\n#define putpmsg(...) (pthread_testcancel(), putpmsg(__VA_ARGS__))\n#define pwrite(...) (pthread_testcancel(), pwrite(__VA_ARGS__))\n#define read(...) (pthread_testcancel(), read(__VA_ARGS__))\n#define readv(...) (pthread_testcancel(), readv(__VA_ARGS__))\n#define recv(...) (pthread_testcancel(), recv(__VA_ARGS__))\n#define recvfrom(...) (pthread_testcancel(), recvfrom(__VA_ARGS__))\n#define recvmsg(...) (pthread_testcancel(), recvmsg(__VA_ARGS__))\n#define select(...) (pthread_testcancel(), select(__VA_ARGS__))\n#define sem_timedwait(...) (pthread_testcancel(), sem_timedwait(__VA_ARGS__))\n#define sem_wait(...) (pthread_testcancel(), sem_wait(__VA_ARGS__))\n#define send(...) (pthread_testcancel(), send(__VA_ARGS__))\n#define sendmsg(...) (pthread_testcancel(), sendmsg(__VA_ARGS__))\n#define sendto(...) (pthread_testcancel(), sendto(__VA_ARGS__))\n#define sigpause(...) (pthread_testcancel(), sigpause(__VA_ARGS__))\n#define sigsuspend(...) (pthread_testcancel(), sigsuspend(__VA_ARGS__))\n#define sigwait(...) (pthread_testcancel(), sigwait(__VA_ARGS__))\n#define sigwaitinfo(...) (pthread_testcancel(), sigwaitinfo(__VA_ARGS__))\n#define sleep(...) (pthread_testcancel(), sleep(__VA_ARGS__))\n//#define Sleep(...) (pthread_testcancel(), Sleep(__VA_ARGS__))\n#define system(...) (pthread_testcancel(), system(__VA_ARGS__))\n\n\n#define access(...) (pthread_testcancel(), access(__VA_ARGS__))\n#define asctime(...) (pthread_testcancel(), asctime(__VA_ARGS__))\n#define asctime_r(...) (pthread_testcancel(), asctime_r(__VA_ARGS__))\n#define catclose(...) (pthread_testcancel(), catclose(__VA_ARGS__))\n#define catgets(...) (pthread_testcancel(), catgets(__VA_ARGS__))\n#define catopen(...) (pthread_testcancel(), catopen(__VA_ARGS__))\n#define closedir(...) (pthread_testcancel(), closedir(__VA_ARGS__))\n#define closelog(...) (pthread_testcancel(), closelog(__VA_ARGS__))\n#define ctermid(...) (pthread_testcancel(), ctermid(__VA_ARGS__))\n#define ctime(...) (pthread_testcancel(), ctime(__VA_ARGS__))\n#define ctime_r(...) (pthread_testcancel(), ctime_r(__VA_ARGS__))\n#define dbm_close(...) (pthread_testcancel(), dbm_close(__VA_ARGS__))\n#define dbm_delete(...) (pthread_testcancel(), dbm_delete(__VA_ARGS__))\n#define dbm_fetch(...) (pthread_testcancel(), dbm_fetch(__VA_ARGS__))\n#define dbm_nextkey(...) (pthread_testcancel(), dbm_nextkey(__VA_ARGS__))\n#define dbm_open(...) (pthread_testcancel(), dbm_open(__VA_ARGS__))\n#define dbm_store(...) (pthread_testcancel(), dbm_store(__VA_ARGS__))\n#define dlclose(...) (pthread_testcancel(), dlclose(__VA_ARGS__))\n#define dlopen(...) (pthread_testcancel(), dlopen(__VA_ARGS__))\n#define endgrent(...) (pthread_testcancel(), endgrent(__VA_ARGS__))\n#define endhostent(...) (pthread_testcancel(), endhostent(__VA_ARGS__))\n#define endnetent(...) (pthread_testcancel(), endnetent(__VA_ARGS__))\n#define endprotoent(...) (pthread_testcancel(), endprotoend(__VA_ARGS__))\n#define endpwent(...) (pthread_testcancel(), endpwent(__VA_ARGS__))\n#define endservent(...) (pthread_testcancel(), endservent(__VA_ARGS__))\n#define endutxent(...) (pthread_testcancel(), endutxent(__VA_ARGS__))\n#define fclose(...) (pthread_testcancel(), fclose(__VA_ARGS__))\n#define fflush(...) (pthread_testcancel(), fflush(__VA_ARGS__))\n#define fgetc(...) (pthread_testcancel(), fgetc(__VA_ARGS__))\n#define fgetpos(...) (pthread_testcancel(), fgetpos(__VA_ARGS__))\n#define fgets(...) (pthread_testcancel(), fgets(__VA_ARGS__))\n#define fgetwc(...) (pthread_testcancel(), fgetwc(__VA_ARGS__))\n#define fgetws(...) (pthread_testcancel(), fgetws(__VA_ARGS__))\n#define fmtmsg(...) (pthread_testcancel(), fmtmsg(__VA_ARGS__))\n#define fopen(...) (pthread_testcancel(), fopen(__VA_ARGS__))\n#define fpathconf(...) (pthread_testcancel(), fpathconf(__VA_ARGS__))\n#define fprintf(...) (pthread_testcancel(), fprintf(__VA_ARGS__))\n#define fputc(...) (pthread_testcancel(), fputc(__VA_ARGS__))\n#define fputs(...) (pthread_testcancel(), fputs(__VA_ARGS__))\n#define fputwc(...) (pthread_testcancel(), fputwc(__VA_ARGS__))\n#define fputws(...) (pthread_testcancel(), fputws(__VA_ARGS__))\n#define fread(...) (pthread_testcancel(), fread(__VA_ARGS__))\n#define freopen(...) (pthread_testcancel(), freopen(__VA_ARGS__))\n#define fscanf(...) (pthread_testcancel(), fscanf(__VA_ARGS__))\n#define fseek(...) (pthread_testcancel(), fseek(__VA_ARGS__))\n#define fseeko(...) (pthread_testcancel(), fseeko(__VA_ARGS__))\n#define fsetpos(...) (pthread_testcancel(), fsetpos(__VA_ARGS__))\n#define fstat(...) (pthread_testcancel(), fstat(__VA_ARGS__))\n#define ftell(...) (pthread_testcancel(), ftell(__VA_ARGS__))\n#define ftello(...) (pthread_testcancel(), ftello(__VA_ARGS__))\n#define ftw(...) (pthread_testcancel(), ftw(__VA_ARGS__))\n#define fwprintf(...) (pthread_testcancel(), fwprintf(__VA_ARGS__))\n#define fwrite(...) (pthread_testcancel(), fwrite(__VA_ARGS__))\n#define fwscanf(...) (pthread_testcancel(), fwscanf(__VA_ARGS__))\n#define getaddrinfo(...) (pthread_testcancel(), getaddrinfo(__VA_ARGS__))\n#define getc(...) (pthread_testcancel(), getc(__VA_ARGS__))\n#define getc_unlocked(...) (pthread_testcancel(), getc_unlocked(__VA_ARGS__))\n#define getchar(...) (pthread_testcancel(), getchar(__VA_ARGS__))\n#define getchar_unlocked(...) (pthread_testcancel(), getchar_unlocked(__VA_ARGS__))\n#define getcwd(...) (pthread_testcancel(), getcwd(__VA_ARGS__))\n#define getdate(...) (pthread_testcancel(), getdate(__VA_ARGS__))\n#define getgrent(...) (pthread_testcancel(), getgrent(__VA_ARGS__))\n#define getgrgid(...) (pthread_testcancel(), getgrgid(__VA_ARGS__))\n#define getgrgid_r(...) (pthread_testcancel(), getgrgid_r(__VA_ARGS__))\n#define gergrnam(...) (pthread_testcancel(), getgrnam(__VA_ARGS__))\n#define getgrnam_r(...) (pthread_testcancel(), getgrnam_r(__VA_ARGS__))\n#define gethostbyaddr(...) (pthread_testcancel(), gethostbyaddr(__VA_ARGS__))\n#define gethostbyname(...) (pthread_testcancel(), gethostbyname(__VA_ARGS__))\n#define gethostent(...) (pthread_testcancel(), gethostent(__VA_ARGS__))\n#define gethostid(...) (pthread_testcancel(), gethostid(__VA_ARGS__))\n#define gethostname(...) (pthread_testcancel(), gethostname(__VA_ARGS__))\n#define getlogin(...) (pthread_testcancel(), getlogin(__VA_ARGS__))\n#define getlogin_r(...) (pthread_testcancel(), getlogin_r(__VA_ARGS__))\n#define getnameinfo(...) (pthread_testcancel(), getnameinfo(__VA_ARGS__))\n#define getnetbyaddr(...) (pthread_testcancel(), getnetbyaddr(__VA_ARGS__))\n#define getnetbyname(...) (pthread_testcancel(), getnetbyname(__VA_ARGS__))\n#define getnetent(...) (pthread_testcancel(), getnetent(__VA_ARGS__))\n#define getopt(...) (pthread_testcancel(), getopt(__VA_ARGS__))\n#define getprotobyname(...) (pthread_testcancel(), getprotobyname(__VA_ARGS__))\n#define getprotobynumber(...) (pthread_testcancel(), getprotobynumber(__VA_ARGS__))\n#define getprotoent(...) (pthread_testcancel(), getprotoent(__VA_ARGS__))\n#define getpwent(...) (pthread_testcancel(), getpwent(__VA_ARGS__))\n#define getpwnam(...) (pthread_testcancel(), getpwnam(__VA_ARGS__))\n#define getpwnam_r(...) (pthread_testcancel(), getpwnam_r(__VA_ARGS__))\n#define getpwuid(...) (pthread_testcancel(), getpwuid(__VA_ARGS__))\n#define getpwuid_r(...) (pthread_testcancel(), getpwuid_r(__VA_ARGS__))\n#define gets(...) (pthread_testcancel(), gets(__VA_ARGS__))\n#define getservbyname(...) (pthread_testcancel(), getservbyname(__VA_ARGS__))\n#define getservbyport(...) (pthread_testcancel(), getservbyport(__VA_ARGS__))\n#define getservent(...) (pthread_testcancel(), getservent(__VA_ARGS__))\n#define getutxent(...) (pthread_testcancel(), getutxent(__VA_ARGS__))\n#define getutxid(...) (pthread_testcancel(), getutxid(__VA_ARGS__))\n#define getutxline(...) (pthread_testcancel(), getutxline(__VA_ARGS__))\n#undef getwc\n#define getwc(...) (pthread_testcancel(), getwc(__VA_ARGS__))\n#undef getwchar\n#define getwchar(...) (pthread_testcancel(), getwchar(__VA_ARGS__))\n#define getwd(...) (pthread_testcancel(), getwd(__VA_ARGS__))\n#define glob(...) (pthread_testcancel(), glob(__VA_ARGS__))\n#define iconv_close(...) (pthread_testcancel(), iconv_close(__VA_ARGS__))\n#define iconv_open(...) (pthread_testcancel(), iconv_open(__VA_ARGS__))\n#define ioctl(...) (pthread_testcancel(), ioctl(__VA_ARGS__))\n#define link(...) (pthread_testcancel(), link(__VA_ARGS__))\n#define localtime(...) (pthread_testcancel(), localtime(__VA_ARGS__))\n#define localtime_r(...) (pthread_testcancel(), localtime_r(__VA_ARGS__))\n#define lseek(...) (pthread_testcancel(), lseek(__VA_ARGS__))\n#define lstat(...) (pthread_testcancel(), lstat(__VA_ARGS__))\n#define mkstemp(...) (pthread_testcancel(), mkstemp(__VA_ARGS__))\n#define nftw(...) (pthread_testcancel(), nftw(__VA_ARGS__))\n#define opendir(...) (pthread_testcancel(), opendir(__VA_ARGS__))\n#define openlog(...) (pthread_testcancel(), openlog(__VA_ARGS__))\n#define pathconf(...) (pthread_testcancel(), pathconf(__VA_ARGS__))\n#define pclose(...) (pthread_testcancel(), pclose(__VA_ARGS__))\n#define perror(...) (pthread_testcancel(), perror(__VA_ARGS__))\n#define popen(...) (pthread_testcancel(), popen(__VA_ARGS__))\n#define posix_fadvise(...) (pthread_testcancel(), posix_fadvise(__VA_ARGS__))\n#define posix_fallocate(...) (pthread_testcancel(), posix_fallocate(__VA_ARGS__))\n#define posix_madvise(...) (pthread_testcancel(), posix_madvise(__VA_ARGS__))\n#define posix_openpt(...) (pthread_testcancel(), posix_openpt(__VA_ARGS__))\n#define posix_spawn(...) (pthread_testcancel(), posix_spawn(__VA_ARGS__))\n#define posix_spawnp(...) (pthread_testcancel(), posix_spawnp(__VA_ARGS__))\n#define posix_trace_clear(...) (pthread_testcancel(), posix_trace_clear(__VA_ARGS__))\n#define posix_trace_close(...) (pthread_testcancel(), posix_trace_close(__VA_ARGS__))\n#define posix_trace_create(...) (pthread_testcancel(), posix_trace_create(__VA_ARGS__))\n#define posix_trace_create_withlog(...) (pthread_testcancel(), posix_trace_create_withlog(__VA_ARGS__))\n#define posix_trace_eventtypelist_getne(...) (pthread_testcancel(), posix_trace_eventtypelist_getne(__VA_ARGS__))\n#define posix_trace_eventtypelist_rewin(...) (pthread_testcancel(), posix_trace_eventtypelist_rewin(__VA_ARGS__))\n#define posix_trace_flush(...) (pthread_testcancel(), posix_trace_flush(__VA_ARGS__))\n#define posix_trace_get_attr(...) (pthread_testcancel(), posix_trace_get_attr(__VA_ARGS__))\n#define posix_trace_get_filter(...) (pthread_testcancel(), posix_trace_get_filter(__VA_ARGS__))\n#define posix_trace_get_status(...) (pthread_testcancel(), posix_trace_get_status(__VA_ARGS__))\n#define posix_trace_getnext_event(...) (pthread_testcancel(), posix_trace_getnext_event(__VA_ARGS__))\n#define posix_trace_open(...) (pthread_testcancel(), posix_trace_open(__VA_ARGS__))\n#define posix_trace_rewind(...) (pthread_testcancel(), posix_trace_rewind(__VA_ARGS__))\n#define posix_trace_setfilter(...) (pthread_testcancel(), posix_trace_setfilter(__VA_ARGS__))\n#define posix_trace_shutdown(...) (pthread_testcancel(), posix_trace_shutdown(__VA_ARGS__))\n#define posix_trace_timedgetnext_event(...) (pthread_testcancel(), posix_trace_timedgetnext_event(__VA_ARGS__))\n#define posix_typed_mem_open(...) (pthread_testcancel(), posix_typed_mem_open(__VA_ARGS__))\n#define printf(...) (pthread_testcancel(), printf(__VA_ARGS__))\n#define putc(...) (pthread_testcancel(), putc(__VA_ARGS__))\n#define putc_unlocked(...) (pthread_testcancel(), putc_unlocked(__VA_ARGS__))\n#define putchar(...) (pthread_testcancel(), putchar(__VA_ARGS__))\n#define putchar_unlocked(...) (pthread_testcancel(), putchar_unlocked(__VA_ARGS__))\n#define puts(...) (pthread_testcancel(), puts(__VA_ARGS__))\n#define pututxline(...) (pthread_testcancel(), pututxline(__VA_ARGS__))\n#undef putwc\n#define putwc(...) (pthread_testcancel(), putwc(__VA_ARGS__))\n#undef putwchar\n#define putwchar(...) (pthread_testcancel(), putwchar(__VA_ARGS__))\n#define readdir(...) (pthread_testcancel(), readdir(__VA_ARSG__))\n#define readdir_r(...) (pthread_testcancel(), readdir_r(__VA_ARGS__))\n#define remove(...) (pthread_testcancel(), remove(__VA_ARGS__))\n#define rename(...) (pthread_testcancel(), rename(__VA_ARGS__))\n#define rewind(...) (pthread_testcancel(), rewind(__VA_ARGS__))\n#define rewinddir(...) (pthread_testcancel(), rewinddir(__VA_ARGS__))\n#define scanf(...) (pthread_testcancel(), scanf(__VA_ARGS__))\n#define seekdir(...) (pthread_testcancel(), seekdir(__VA_ARGS__))\n#define semop(...) (pthread_testcancel(), semop(__VA_ARGS__))\n#define setgrent(...) (pthread_testcancel(), setgrent(__VA_ARGS__))\n#define sethostent(...) (pthread_testcancel(), sethostemt(__VA_ARGS__))\n#define setnetent(...) (pthread_testcancel(), setnetent(__VA_ARGS__))\n#define setprotoent(...) (pthread_testcancel(), setprotoent(__VA_ARGS__))\n#define setpwent(...) (pthread_testcancel(), setpwent(__VA_ARGS__))\n#define setservent(...) (pthread_testcancel(), setservent(__VA_ARGS__))\n#define setutxent(...) (pthread_testcancel(), setutxent(__VA_ARGS__))\n#define stat(...) (pthread_testcancel(), stat(__VA_ARGS__))\n#define strerror(...) (pthread_testcancel(), strerror(__VA_ARGS__))\n#define strerror_r(...) (pthread_testcancel(), strerror_r(__VA_ARGS__))\n#define strftime(...) (pthread_testcancel(), strftime(__VA_ARGS__))\n#define symlink(...) (pthread_testcancel(), symlink(__VA_ARGS__))\n#define sync(...) (pthread_testcancel(), sync(__VA_ARGS__))\n#define syslog(...) (pthread_testcancel(), syslog(__VA_ARGS__))\n#define tmpfile(...) (pthread_testcancel(), tmpfile(__VA_ARGS__))\n#define tmpnam(...) (pthread_testcancel(), tmpnam(__VA_ARGS__))\n#define ttyname(...) (pthread_testcancel(), ttyname(__VA_ARGS__))\n#define ttyname_r(...) (pthread_testcancel(), ttyname_r(__VA_ARGS__))\n#define tzset(...) (pthread_testcancel(), tzset(__VA_ARGS__))\n#define ungetc(...) (pthread_testcancel(), ungetc(__VA_ARGS__))\n#define ungetwc(...) (pthread_testcancel(), ungetwc(__VA_ARGS__))\n#define unlink(...) (pthread_testcancel(), unlink(__VA_ARGS__))\n#define vfprintf(...) (pthread_testcancel(), vfprintf(__VA_ARGS__))\n#define vfwprintf(...) (pthread_testcancel(), vfwprintf(__VA_ARGS__))\n#define vprintf(...) (pthread_testcancel(), vprintf(__VA_ARGS__))\n#define vwprintf(...) (pthread_testcancel(), vwprintf(__VA_ARGS__))\n#define wcsftime(...) (pthread_testcancel(), wcsftime(__VA_ARGS__))\n#define wordexp(...) (pthread_testcancel(), wordexp(__VA_ARGS__))\n#define wprintf(...) (pthread_testcancel(), wprintf(__VA_ARGS__))\n#define wscanf(...) (pthread_testcancel(), wscanf(__VA_ARGS__))\n*/\n#endif /* WIN_PTHREADS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/olla/src/Platform.cpp": "/* -------------------------------------------------------------------------- *\n *                                   OpenMM                                   *\n * -------------------------------------------------------------------------- *\n * This is part of the OpenMM molecular simulation toolkit originating from   *\n * Simbios, the NIH National Center for Physics-Based Simulation of           *\n * Biological Structures at Stanford, funded under the NIH Roadmap for        *\n * Medical Research, grant U54 GM072970. See https://simtk.org.               *\n *                                                                            *\n * Portions copyright (c) 2008-2016 Stanford University and the Authors.      *\n * Authors: Peter Eastman                                                     *\n * Contributors:                                                              *\n *                                                                            *\n * Permission is hereby granted, free of charge, to any person obtaining a    *\n * copy of this software and associated documentation files (the \"Software\"), *\n * to deal in the Software without restriction, including without limitation  *\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,   *\n * and/or sell copies of the Software, and to permit persons to whom the      *\n * Software is furnished to do so, subject to the following conditions:       *\n *                                                                            *\n * The above copyright notice and this permission notice shall be included in *\n * all copies or substantial portions of the Software.                        *\n *                                                                            *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   *\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    *\n * THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,    *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR      *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  *\n * USE OR OTHER DEALINGS IN THE SOFTWARE.                                     *\n * -------------------------------------------------------------------------- */\n\n#include \"openmm/Platform.h\"\n#include \"openmm/Context.h\"\n#include \"openmm/OpenMMException.h\"\n#include \"openmm/Kernel.h\"\n#include \"openmm/KernelFactory.h\"\n#include \"openmm/internal/ContextImpl.h\"\n#ifdef WIN32\n#include <windows.h>\n#else\n#ifndef __PNACL__\n    #include <dlfcn.h>\n#endif\n#include <dirent.h>\n#include <cstdlib>\n#endif\n#include <sstream>\n#include <set>\n#include <algorithm>\n\n#include \"ReferencePlatform.h\"\n\nusing namespace OpenMM;\nusing namespace std;\n\nstd::vector<std::string> Platform::pluginLoadFailures;\nstatic bool stringLengthComparator(string i, string j) {\n  return (i.size() < j.size());\n}\n\nstatic int registerPlatforms() {\n\n    // Register the Platforms built into the main library.  This should eventually be moved elsewhere.\n    \n    ReferencePlatform* platform = new ReferencePlatform();\n    Platform::registerPlatform(platform);\n    return 0;\n}\n\nstatic int platformInitializer = registerPlatforms();\n\nPlatform::~Platform() {\n    set<KernelFactory*> uniqueKernelFactories;\n    for (auto& factory : kernelFactories)\n        uniqueKernelFactories.insert(factory.second);\n    for (auto factory : uniqueKernelFactories)\n        delete factory;\n}\n\nconst vector<string>& Platform::getPropertyNames() const {\n    return platformProperties;\n}\n\nconst string& Platform::getPropertyValue(const Context& context, const string& property) const {\n    throw OpenMMException(\"getPropertyValue: Illegal property name\");\n}\n\nvoid Platform::setPropertyValue(Context& context, const string& property, const string& value) const {\n    throw OpenMMException(\"setPropertyValue: Illegal property name\");\n}\n\nconst string& Platform::getPropertyDefaultValue(const string& property) const {\n    string propertyName = property;\n    if (deprecatedPropertyReplacements.find(property) != deprecatedPropertyReplacements.end())\n        propertyName = deprecatedPropertyReplacements.find(property)->second;\n    map<string, string>::const_iterator value = defaultProperties.find(propertyName);\n    if (value == defaultProperties.end())\n        throw OpenMMException(\"getPropertyDefaultValue: Illegal property name\");\n    return value->second;\n}\n\nvoid Platform::setPropertyDefaultValue(const string& property, const string& value) {\n    string propertyName = property;\n    if (deprecatedPropertyReplacements.find(property) != deprecatedPropertyReplacements.end())\n        propertyName = deprecatedPropertyReplacements.find(property)->second;\n    for (auto& prop : platformProperties)\n        if (prop == propertyName) {\n            defaultProperties[propertyName] = value;\n            return;\n        }\n    throw OpenMMException(\"setPropertyDefaultValue: Illegal property name\");\n}\n\nvoid Platform::contextCreated(ContextImpl& context, const map<string, string>& properties) const {\n}\n\nvoid Platform::linkedContextCreated(ContextImpl& context, ContextImpl& originalContext) const {\n    // The default implementation just copies over the properties and calls contextCreated().\n    // Subclasses may override this to do something different.\n    \n    map<string, string> properties;\n    for (auto& name : getPropertyNames())\n        properties[name] = getPropertyValue(originalContext.getOwner(), name);\n    contextCreated(context, properties);\n}\n\nvoid Platform::contextDestroyed(ContextImpl& context) const {\n}\n\nvoid Platform::registerKernelFactory(const string& name, KernelFactory* factory) {\n    kernelFactories[name] = factory;\n}\n\nbool Platform::supportsKernels(const vector<string>& kernelNames) const {\n    for (auto& name : kernelNames)\n        if (kernelFactories.find(name) == kernelFactories.end())\n            return false;\n    return true;\n}\n\nKernel Platform::createKernel(const string& name, ContextImpl& context) const {\n    if (kernelFactories.find(name) == kernelFactories.end())\n        throw OpenMMException(\"Called createKernel() on a Platform which does not support the requested kernel\");\n    return Kernel(kernelFactories.find(name)->second->createKernelImpl(name, *this, context));\n}\nvector<Platform*>& Platform::getPlatforms() {\n    static vector<Platform*> platforms;\n    return platforms;\n}\n\nvoid Platform::registerPlatform(Platform* platform) {\n    getPlatforms().push_back(platform);\n}\n\nint Platform::getNumPlatforms() {\n    return getPlatforms().size();\n}\n\nPlatform& Platform::getPlatform(int index) {\n    if (index >= 0 && index < getNumPlatforms()) {\n        return *getPlatforms()[index];\n    }\n    throw OpenMMException(\"Invalid platform index\");\n}\n\nstd::vector<std::string> Platform::getPluginLoadFailures() {\n  return pluginLoadFailures;\n}\n\nPlatform& Platform::getPlatformByName(const string& name) {\n    for (int i = 0; i < getNumPlatforms(); i++)\n        if (getPlatform(i).getName() == name)\n            return getPlatform(i);\n    throw OpenMMException(\"There is no registered Platform called \\\"\"+name+\"\\\"\");\n}\n\nPlatform& Platform::findPlatform(const vector<string>& kernelNames) {\n    Platform* best = 0;\n    vector<Platform*>& platforms = getPlatforms();\n    double speed = 0.0;\n    for (auto platform : platforms) {\n        if (platform->supportsKernels(kernelNames) && platform->getSpeed() > speed) {\n            best = platform;\n            speed = best->getSpeed();\n        }\n    }\n    if (best == 0)\n        throw OpenMMException(\"No Platform supports all the requested kernels\");\n    return *best;\n}\n\n#ifdef WIN32\nstatic HMODULE loadOneLibrary(const string& file) {\n    // Tell Windows not to bother the user with ugly error boxes.\n    const UINT oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);\n    HMODULE handle = LoadLibrary(file.c_str());\n    SetErrorMode(oldErrorMode); // Restore previous error mode.\n    if (handle == NULL) {\n        stringstream message;\n        message << \"Error loading library \" << file << \": \" << GetLastError();\n        throw OpenMMException(message.str());\n    }\n    return handle;\n}\n\nstatic void initializePlugins(vector<HMODULE>& plugins) {\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = (void *) GetProcAddress(plugin, \"registerPlatforms\");\n        if (init != NULL)\n            (*init)();\n    }\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = (void *) GetProcAddress(plugin, \"registerKernelFactories\");\n        if (init != NULL)\n            (*init)();\n    }\n}\n#else\nstatic void* loadOneLibrary(const string& file) {\n#ifdef __PNACL__\n    throw OpenMMException(\"Loading dynamic libraries is not supported on PNaCl\");\n#else    \n    void *handle = dlopen(file.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (handle == NULL) {\n        throw OpenMMException(\"Error loading library \"+file+\": \"+dlerror());\n    }\n    return handle;\n#endif\n}\n\nstatic void initializePlugins(vector<void*>& plugins) {\n#ifndef __PNACL__\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = dlsym(plugin, \"registerPlatforms\");\n        if (init != NULL)\n            (*init)();\n    }\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = dlsym(plugin, \"registerKernelFactories\");\n        if (init != NULL)\n            (*init)();\n    }\n#endif\n}\n#endif\n\nvoid Platform::loadPluginLibrary(const string& file) {\n#ifdef WIN32\n    vector<HMODULE> plugins;\n#else\n    vector<void*> plugins;\n#endif\n    plugins.push_back(loadOneLibrary(file));\n    initializePlugins(plugins);\n}\n\nvector<string> Platform::loadPluginsFromDirectory(const string& directory) {\n    vector<string> files;\n    char dirSeparator;\n    char pathSeparator;\n    stringstream sdirectory(directory);\n#ifdef WIN32\n    dirSeparator = '\\\\';\n    pathSeparator = ';';\n    WIN32_FIND_DATA fileInfo;\n\n    for (string path; std::getline(sdirectory, path, pathSeparator);) {\n        string filePattern(path + dirSeparator + \"*.dll\");\n        HANDLE findHandle = FindFirstFile(filePattern.c_str(), &fileInfo);\n        if (findHandle != INVALID_HANDLE_VALUE) {\n            do {\n                if (fileInfo.cFileName[0] != '.')\n                    files.push_back(path+dirSeparator+string(fileInfo.cFileName));\n            } while (FindNextFile(findHandle, &fileInfo));\n            FindClose(findHandle);\n        }\n    }\n    vector<HMODULE> plugins;\n#else\n    DIR* dir;\n    dirSeparator = '/';\n    pathSeparator = ':';\n    struct dirent *entry;\n\n    for (string path; std::getline(sdirectory, path, pathSeparator);) {\n        dir = opendir(path.c_str());\n        if (dir != NULL) {\n            while ((entry = readdir(dir)) != NULL) {\n                if (entry->d_name[0] != '.')\n                    files.push_back(path+dirSeparator+string(entry->d_name));\n            }\n            closedir(dir);\n        }\n    }\n\n    vector<void*> plugins;\n#endif\n    vector<string> loadedLibraries;\n    pluginLoadFailures.resize(0);\n    std::sort (files.begin(), files.end(), stringLengthComparator);\n\n    for (unsigned int i = 0; i < files.size(); ++i) {\n        try {\n            plugins.push_back(loadOneLibrary(files[i]));\n            loadedLibraries.push_back(files[i]);\n        } catch (OpenMMException& ex) {\n\t    pluginLoadFailures.push_back(ex.what());\n        }\n    }\n    initializePlugins(plugins);\n    return loadedLibraries;\n}\n\nconst string& Platform::getDefaultPluginsDirectory() {\n    char* dir = getenv(\"OPENMM_PLUGIN_DIR\");\n    static string directory;\n#ifdef _MSC_VER\n    if (dir != NULL)\n        directory = string(dir);\n    else {\n        dir = getenv(\"PROGRAMFILES\");\n        if (dir == NULL)\n            directory = \"C:\\\\\\\\Program Files\\\\OpenMM\\\\lib\\\\plugins\";\n        else\n            directory = string(dir)+\"\\\\OpenMM\\\\lib\\\\plugins\";\n    }\n#else\n    if (dir == NULL)\n        directory = \"/usr/local/openmm/lib/plugins\";\n    else\n        directory = string(dir);\n#endif\n    return directory;\n}\n\n// Some bizarre preprocessor magic required to convert a macro to a string...\n#define STRING1(x) #x\n#define STRING(x) STRING1(x)\n\nconst string& Platform::getOpenMMVersion() {\n#if OPENMM_BUILD_VERSION == 0\n    static const string version = STRING(OPENMM_MAJOR_VERSION) \".\" STRING(OPENMM_MINOR_VERSION);\n#else\n    static const string version = STRING(OPENMM_MAJOR_VERSION) \".\" STRING(OPENMM_MINOR_VERSION) \".\" STRING(OPENMM_BUILD_VERSION);\n#endif\n    return version;\n}\n\nContextImpl& Platform::getContextImpl(Context& context) const {\n    return *context.impl;\n}\n\nconst ContextImpl& Platform::getContextImpl(const Context& context) const {\n    return *context.impl;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/irrxml/changes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/irrxml/example/irrXML.dsw",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/irrxml/example/irrXML.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/irrxml/include/irrString.h",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/libraries/irrxml/doc/irrXML.chm",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/wrappers/python/tests/systems/bcd-nabumetone_lig.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/wrappers/python/tests/systems/alanine-dipeptide-explicit-amber99SBILDN-tip3p.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/wrappers/python/tests/systems/bcd-nabumetone_rcpt.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/wrappers/python/tests/systems/amber.ncrst",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/Lepton User's Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/Lepton User's Manual.doc",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/VisualStudioLaunch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/SystemContextRelationships.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/ArchitectureLayers.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/VisualStudioSetConfiguration.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/Argon.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/OpenMMSetup.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/images/EnergyDrift.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/api-c++/_static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/docs-source/api-python/_static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/examples/input-charmm36.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-w2emylqcuvuughz4cvdcqrl7frpvtnec/spack-src/examples/input-charmm36-tip5p.dms"
    ],
    "total_files": 1666
}