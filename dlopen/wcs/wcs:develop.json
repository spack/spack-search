{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-wcs-develop-bx6mroakgfhny5agjyv7rr37ntddbtsi/spack-src/src/utils/graph_factory.hpp": "/******************************************************************************\n *                                                                            *\n *    Copyright 2020   Lawrence Livermore National Security, LLC and other    *\n *    Whole Cell Simulator Project Developers. See the top-level COPYRIGHT    *\n *    file for details.                                                       *\n *                                                                            *\n *    SPDX-License-Identifier: MIT                                            *\n *                                                                            *\n ******************************************************************************/\n\n#ifndef __WCS_UTILS_GRAPH_FACTORY_HPP__\n#define __WCS_UTILS_GRAPH_FACTORY_HPP__\n\n#include <string>\n#include <unordered_map>\n#include <type_traits>\n#include <dlfcn.h> //dlopen\n#include \"utils/file.hpp\"\n\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n\n#if defined(WCS_HAS_CONFIG)\n#include \"wcs_config.hpp\"\n#else\n#error \"no config\"\n#endif\n\n#if defined(WCS_HAS_SBML)\n#include <sbml/SBMLTypes.h>\n#include <sbml/common/extern.h>\n#endif // defined(WCS_HAS_SBML)\n\n// To suppress the gcc compiler warning 'maybe-uninitialized'\n// from the boost graph source code.\n// clang does not recognize this particular diagnostic flag.\n#include <boost/graph/graphml.hpp>\n#if !defined(__clang__) && defined(__GNUC__)\n#pragma GCC diagnostic pop\n#endif\n#include <bgl.hpp>\n\n#include <reaction_network/vertex_flat.hpp>\n#include <reaction_network/vertex.hpp>\n#include <reaction_network/edge.hpp>\n#include <reaction_network/species.hpp>\n#include <reaction_network/reaction.hpp>\n#include <utils/detect_methods.hpp>\n#include <utils/sbml_utils.hpp>\n\n\nnamespace wcs {\n/** \\addtogroup wcs_utils\n *  @{ */\n\ntypedef reaction_rate_t ( * rate_function_pointer)(const std::vector<reaction_rate_t>&);\n\nclass GraphFactory {\n public:\n  using v_prop_t = wcs::VertexFlat;\n  using e_prop_t = wcs::Edge;\n\n  using graph_t = boost::adjacency_list<boost::listS,\n                                        boost::listS,\n                                        boost::directedS,\n                                        v_prop_t,\n                                        e_prop_t>;\n\n  using v_desc_t = boost::graph_traits<graph_t>::vertex_descriptor;\n  using e_desc_t = boost::graph_traits<graph_t>::edge_descriptor;\n\n  using params_map_t = std::unordered_map <std::string, std::vector<std::string>>;\n  using rate_rules_dep_t = std::unordered_map <std::string, std::set<std::string>>;\n\n public:\n  GraphFactory();\n  GraphFactory(const GraphFactory &o);\n  const graph_t &graph() const;\n  bool read_graphml(const std::string &ifn);\n  /** Export the internal adjacency list to g, which might be of a different\n      type in terms of the random accessibility but of a compatible one (G). */\n  template<typename G> void copy_to(G& g) const;\n\n  #if defined(WCS_HAS_SBML)\n  template<typename G>\n  void convert_to(const LIBSBML_CPP_NAMESPACE::Model& model, G& g,\n    const std::string library_file,\n    const params_map_t& dep_params_f,\n    const params_map_t& dep_params_nf,\n    const rate_rules_dep_t& rate_rules_dep_map) const;\n  #endif // defined(WCS_HAS_SBML)\n\n  template<typename G>\n  typename std::shared_ptr<G> make_graph() const;\n\n private:\n  void setup_dynamic_property ();\n  graph_t m_g;\n  boost::dynamic_properties m_dp;\n};\n\n\ntemplate<typename G> void GraphFactory::copy_to(G& g) const\n{\n  using v_new_desc_t = typename boost::graph_traits<G>::vertex_descriptor;\n  std::unordered_map<v_desc_t, v_new_desc_t> v_desc_map;\n\n  if constexpr (has_reserve_for_vertex_list<G>::value) {\n    g.m_vertices.reserve(m_g.m_vertices.size());\n  }\n\n  using directed_category = typename boost::graph_traits<G>::directed_category;\n  constexpr bool is_bidirectional\n    = std::is_same<directed_category, boost::bidirectional_tag>::value;\n\n  typename boost::graph_traits<graph_t>::vertex_iterator vi, vi_end;\n\n  using in_reactions = std::unordered_map<v_desc_t, unsigned int> ;\n  typename in_reactions::const_iterator idit;\n  in_reactions in_degree_reaction;\n\n  //calculate the in_edges of each reaction\n  for (boost::tie(vi, vi_end) = boost::vertices(m_g); vi != vi_end; ++vi) {\n    const v_prop_t& v = m_g[*vi];\n    const auto vt = static_cast<v_prop_t::vertex_type>(v.get_typeid());\n\n    if (vt == v_prop_t::_species_) {\n      for (const auto ei_out :\n           boost::make_iterator_range(boost::out_edges(*vi, m_g)))\n      {\n        const auto vd_r = boost::target(ei_out, m_g);\n        in_degree_reaction[vd_r] += 1;\n      }\n    }\n  }\n\n\n  for (boost::tie(vi, vi_end) = boost::vertices(m_g); vi != vi_end; ++vi) {\n    const v_prop_t& v = m_g[*vi];\n    const auto vt = static_cast<v_prop_t::vertex_type>(v.get_typeid());\n    const auto num_out_edges = boost::out_degree(*vi, m_g);\n    v_new_desc_t vd;\n\n    if (vt == v_prop_t::_species_) {\n      vd = boost::add_vertex(wcs::Vertex{v, g}, g);\n      if constexpr (has_reserve_for_vertex_out_edges<G>::value) {\n        g.m_vertices[vd].m_out_edges.reserve(num_out_edges);\n      } else { (void) num_out_edges; }\n\n      if constexpr (has_reserve_for_vertex_in_edges<G>::value &&\n                    is_bidirectional)\n      {\n        g.m_vertices[vd].m_in_edges.reserve(num_in_edges_to_reserve);\n      }\n      v_desc_map[*vi] = vd;\n    } else if (vt == v_prop_t::_reaction_) {\n      idit = in_degree_reaction.find(*vi) ;\n      if (idit != in_degree_reaction.end() || num_out_edges != 0u) {\n        vd = boost::add_vertex(wcs::Vertex{v, g}, g);\n        if constexpr (has_reserve_for_vertex_out_edges<G>::value) {\n          g.m_vertices[vd].m_out_edges.reserve(num_out_edges);\n        }\n        if constexpr (has_reserve_for_vertex_in_edges<G>::value &&\n                      is_bidirectional)\n        {\n          g.m_vertices[vd].m_in_edges.reserve(num_in_edges_to_reserve);\n        }\n        v_desc_map[*vi] = vd;\n      }\n    }\n  }\n\n  typename boost::graph_traits<graph_t>::edge_iterator ei, ei_end;\n  for (boost::tie(ei, ei_end) = boost::edges(m_g); ei != ei_end; ++ei) {\n    const v_desc_t u = boost::source(*ei, m_g),\n                   v = boost::target(*ei, m_g);\n\n    v_new_desc_t u_new = v_desc_map.at(u);\n    v_new_desc_t v_new = v_desc_map.at(v);\n    const e_prop_t& e = m_g[*ei];\n    boost::add_edge(u_new, v_new, e_prop_t{e}, g);\n  }\n}\n\n#if defined(WCS_HAS_SBML)\n/// Create a Boost graph out of an SBML model\ntemplate<typename G> void\nGraphFactory::convert_to(\n  const LIBSBML_CPP_NAMESPACE::Model& model, G& g,\n  const std::string library_file,\n  const params_map_t& dep_params_f,\n  const params_map_t& dep_params_nf,\n  const rate_rules_dep_t& rate_rules_dep_map) const\n{\n  using v_new_desc_t = typename boost::graph_traits<G>::vertex_descriptor;\n  using e_new_desc_t = typename boost::graph_traits<G>::edge_descriptor;\n\n\n  if constexpr (has_reserve_for_vertex_list<G>::value) {\n    g.m_vertices.reserve(m_g.m_vertices.size());\n  }\n\n  using directed_category = typename boost::graph_traits<G>::directed_category;\n  constexpr bool is_bidirectional\n    = std::is_same<directed_category, boost::bidirectional_tag>::value;\n\n  const LIBSBML_CPP_NAMESPACE::ListOfReactions* reaction_list\n    = model.getListOfReactions();\n\n  if  (reaction_list == nullptr) {\n    WCS_THROW(\"Invalid reaction_list pointer\");\n    return;\n  }\n  unsigned int num_reactions = reaction_list->size();\n  const LIBSBML_CPP_NAMESPACE::ListOfSpecies* species_list\n    = model.getListOfSpecies();\n\n  using species_added_t = std::unordered_map<std::string, v_new_desc_t>;\n  typename species_added_t::const_iterator it;\n  species_added_t smap;\n\n  using edges_added_t = std::unordered_map<std::string, e_new_desc_t>;\n  typename edges_added_t::const_iterator eit;\n  edges_added_t emap;\n\n  using undeclared_reactants_t = std::unordered_set<std::string>;\n  typename undeclared_reactants_t::const_iterator urit;\n  undeclared_reactants_t urset;\n\n  using  all_species_t = std::unordered_set<std::string>;\n  typename all_species_t::const_iterator aspit;\n  all_species_t aspset;\n\n  // Create an unordered_set for all model species\n  unsigned int num_species = species_list->size();\n  for (unsigned int si = 0u; si < num_species; si++) {\n    aspset.insert(species_list->get(si)->getIdAttribute());\n  }\n\n  #if !defined(WCS_HAS_EXPRTK)\n  // Implement the interface to the dynamic linking loader\n\n  void* handle = dlopen((\"./\" + library_file).c_str(), RTLD_LAZY);\n\n  if (!handle) {\n    WCS_THROW(\"Cannot open library: \" + std::string(dlerror()) + \"\\n\");\n    return;\n  }\n\n  // reset errors\n  dlerror();\n  #endif // !defined(WCS_HAS_EXPRTK)\n\n  // Add reactions\n  for (unsigned int ri = 0u; ri < num_reactions; ri++) {\n    std::unordered_set<std::string> reaction_in_species;\n    std::unordered_set<std::string>::const_iterator risit;\n    if (reaction_list->get(ri) == nullptr) {\n      WCS_THROW(\"Invalid reaction pointer\");\n      return;\n    }\n    const auto &reaction = *(reaction_list->get(ri));\n\n    #if !defined(WCS_HAS_EXPRTK)\n    std::string rate_function = std::string(\"wcs__rate_\" + reaction.getIdAttribute());\n\n    void * const reaction_function_rate = dlsym(handle, rate_function.c_str());\n    const char *dlsym_error = dlerror();\n    if (dlsym_error) {\n      WCS_THROW(\"Cannot load symbol \" + reaction.getIdAttribute() + \": \" + dlsym_error + \"\\n\");\n      dlclose(handle);\n      return;\n    }\n\n    std::function<reaction_rate_t(const std::vector<reaction_rate_t>&)> f_rate =\n      reinterpret_cast<rate_function_pointer>(reaction_function_rate);\n    wcs::Vertex v(model, reaction, g, f_rate);\n    #else\n    wcs::Vertex v(model, reaction, g, NULL);\n    #endif // !defined(WCS_HAS_EXPRTK)\n\n    v_new_desc_t vd = boost::add_vertex(v, g);\n    unsigned int num_reactants = reaction.getNumReactants();\n    unsigned int num_products = reaction.getNumProducts();\n    unsigned int num_modifiers = reaction.getNumModifiers();\n\n    if constexpr (has_reserve_for_vertex_out_edges<G>::value) {\n        g.m_vertices[vd].m_out_edges.reserve(num_products);\n    }\n    if constexpr (has_reserve_for_vertex_in_edges<G>::value &&\n                  is_bidirectional)\n    {\n      g.m_vertices[vd].m_in_edges.reserve(num_reactants);\n    }\n\n    // Add reactants species\n    for (unsigned int si = 0u; si < num_reactants; si++) {\n      const auto &reactant = *(reaction.getReactant(si));\n\n      std::string s_label\n        = species_list->get(reactant.getSpecies())->getIdAttribute();\n      it = smap.find(s_label) ;\n      v_new_desc_t vds;\n      reaction_in_species.insert(s_label);\n\n      if (it == smap.cend()) {\n        wcs::Vertex vs(*species_list->get(reactant.getSpecies()), g);\n        vds = boost::add_vertex(vs, g);\n        smap.insert(std::make_pair(s_label,vds));\n      } else {\n        vds = it->second;\n      }\n\n      std::string e_label = g[vds].get_label() + '|' + g[vd].get_label();\n      eit = emap.find(e_label);\n\n      if (eit == emap.cend()) {\n        const auto ret = boost::add_edge(vds, vd, g);\n\n        if (!ret.second) {\n          WCS_THROW(\"Please check the reactions in your SBML file\");\n          return;\n        }\n        g[ret.first].set_stoichiometry_ratio(reactant.getStoichiometry());\n        g[ret.first].set_label(e_label);\n        emap.insert(std::make_pair(e_label, ret.first));\n      } else {\n        const auto& edge_found = eit->second;\n        stoic_t new_stoich = g[edge_found].get_stoichiometry_ratio()\n                           + reactant.getStoichiometry();\n        g[edge_found].set_stoichiometry_ratio(new_stoich);\n      }\n    }\n\n\n    // Add modifiers species\n    for (unsigned int si = 0u; si < num_modifiers; si++) {\n      const auto &modifier = *(reaction.getModifier(si));\n\n      std::string s_label\n        = species_list->get(modifier.getSpecies())->getIdAttribute();\n      it = smap.find(s_label) ;\n      v_new_desc_t vds;\n      reaction_in_species.insert(s_label);\n\n      if (it == smap.cend()) {\n        wcs::Vertex vs(*species_list->get(modifier.getSpecies()), g);\n        vds = boost::add_vertex(vs, g);\n        smap.insert(std::make_pair(s_label,vds));\n      } else {\n        vds = it->second;\n      }\n\n      std::string e_label = g[vds].get_label() + '|' + g[vd].get_label();\n      const auto ret = boost::add_edge(vds, vd, g);\n\n      if (!ret.second) {\n        WCS_THROW(\"Please check the reactions in your SBML file\");\n        return;\n      }\n      g[ret.first].set_stoichiometry_ratio(0);\n      g[ret.first].set_label(e_label);\n      emap.insert(std::make_pair(e_label, ret.first));\n    }\n\n    sbml_utils sbml_o;\n    urset = sbml_o.find_undeclared_species_in_reaction_formula(model, reaction);\n\n    // Check if all the elements of the undeclared elements are actually species\n    for  (const std::string& x: urset) {\n      std::string s_label = x;\n      aspit = aspset.find(s_label);\n      if (aspit == aspset.cend()) {\n        WCS_THROW(\"Unknown element \" + s_label + \" in the reaction \" +\n                  reaction.getIdAttribute() + \" of your SBML file\");\n        return;\n      }\n    }\n\n    // Add undeclared reactants species in the rate formula\n    for  (const std::string& x: urset) {\n      std::string s_label = x;\n      it = smap.find(s_label) ;\n      v_new_desc_t vds;\n      reaction_in_species.insert(s_label);\n\n      if (it == smap.cend()) {\n        wcs::Vertex vs(*species_list->get(x), g);\n        vds = boost::add_vertex(vs, g);\n        smap.insert(std::make_pair(s_label,vds));\n      } else {\n        vds = it->second;\n      }\n\n      std::string e_label = g[vds].get_label() + '|' + g[vd].get_label();\n      const auto ret = boost::add_edge(vds, vd, g);\n\n      if (!ret.second) {\n        WCS_THROW(\"Please check the reactions in your SBML file\");\n        return;\n      }\n      g[ret.first].set_stoichiometry_ratio(0);\n      g[ret.first].set_label(e_label);\n      emap.insert(std::make_pair(e_label, ret.first));\n    }\n\n    // Add transient parameters\n    typename params_map_t::const_iterator pit_f, pit_nf;\n    typename rate_rules_dep_t::const_iterator rrdit;\n    //transient parameters in formula\n    pit_f = dep_params_f.find(reaction.getIdAttribute());\n    if (pit_f != dep_params_f.cend()) {\n      const std::vector<std::string>& params_f = pit_f->second;\n      std::vector<std::string>::const_iterator itf;\n      for (itf = params_f.cbegin(); itf != params_f.cend(); itf++){\n        rrdit = rate_rules_dep_map.find(*itf);\n        if (rrdit != rate_rules_dep_map.cend()) {\n          const std::set<std::string>& params_rr = rrdit->second;\n          for (const auto& x: params_rr) {\n            it = smap.find(x);\n            v_new_desc_t vds;\n            risit = reaction_in_species.find(x);\n            if (risit == reaction_in_species.cend()) {\n              reaction_in_species.insert(x);\n              if (it == smap.cend()) {\n                wcs::Vertex vs(*species_list->get(x), g);\n                vds = boost::add_vertex(vs, g);\n                smap.insert(std::make_pair(x,vds));\n              } else {\n                vds = it->second;\n              }\n\n              std::string e_label = g[vds].get_label() + '|' + g[vd].get_label();\n              const auto ret = boost::add_edge(vds, vd, g);\n\n              if (!ret.second) {\n                WCS_THROW(\"Please check the reactions in your SBML file\");\n                return;\n              }\n              g[ret.first].set_stoichiometry_ratio(0);\n              g[ret.first].set_label(e_label);\n              emap.insert(std::make_pair(e_label, ret.first));\n            }\n          }\n        }\n      }\n    }\n\n    //transient parameters not in formula\n    pit_nf = dep_params_nf.find(reaction.getIdAttribute());\n    if (pit_nf != dep_params_nf.cend()) {\n      const std::vector<std::string>& params_nf = pit_nf->second;\n      std::vector<std::string>::const_iterator itf;\n      for (itf = params_nf.cbegin(); itf != params_nf.cend(); itf++){\n        rrdit = rate_rules_dep_map.find(*itf);\n        if (rrdit != rate_rules_dep_map.cend()) {\n          const std::set<std::string>& params_rr = rrdit->second;\n          for (const auto& x: params_rr) {\n            it = smap.find(x);\n            v_new_desc_t vds;\n            risit = reaction_in_species.find(x);\n            if (risit == reaction_in_species.cend()) {\n              if (it == smap.cend()) {\n                wcs::Vertex vs(*species_list->get(x), g);\n                vds = boost::add_vertex(vs, g);\n                smap.insert(std::make_pair(x,vds));\n              } else {\n                vds = it->second;\n              }\n\n              reaction_in_species.insert(x);\n              std::string e_label = g[vds].get_label() + '|' + g[vd].get_label();\n              const auto ret = boost::add_edge(vds, vd, g);\n\n              if (!ret.second) {\n                WCS_THROW(\"Please check the reactions in your SBML file\");\n                return;\n              }\n              g[ret.first].set_stoichiometry_ratio(0);\n              g[ret.first].set_label(e_label);\n              emap.insert(std::make_pair(e_label, ret.first));\n            }\n          }\n        }\n      }\n    }\n\n    // Add products species\n    for (unsigned int si = 0u; si < num_products; si++) {\n      const auto &product = *(reaction.getProduct(si));\n\n      std::string s_label\n        = species_list->get(product.getSpecies())->getIdAttribute();\n      it = smap.find(s_label);\n      v_new_desc_t vds;\n\n      if (it == smap.cend()) {\n        wcs::Vertex vs(*species_list->get(product.getSpecies()), g);\n        vds = boost::add_vertex(vs, g);\n        smap.insert(std::make_pair(s_label,vds));\n      } else {\n        vds = it->second;\n      }\n\n      std::string e_label = g[vd].get_label() + '|' + g[vds].get_label();\n      eit = emap.find(e_label);\n      if (eit == emap.cend()) {\n        const auto ret = boost::add_edge(vd, vds, g);\n\n        if (!ret.second) {\n          WCS_THROW(\"Please check the reactions in your SBML file\");\n          return;\n        }\n        g[ret.first].set_stoichiometry_ratio(product.getStoichiometry());\n        g[ret.first].set_label( g[vd].get_label() + '|' + g[vds].get_label());\n        emap.insert(std::make_pair(e_label, ret.first));\n      } else {\n        const auto& edge_found = eit->second;\n        stoic_t new_stoich = g[edge_found].get_stoichiometry_ratio()\n                           + product.getStoichiometry();\n        g[edge_found].set_stoichiometry_ratio(new_stoich);\n      }\n    }\n  }\n}\n#endif // defined(WCS_HAS_SBML)\n\n\n/**\n * Load the graph from GraphML file and return the shared pointer of the\n * graph object of type G.\n */\ntemplate<typename G>\ntypename std::shared_ptr<G> GraphFactory::make_graph() const\n{\n  std::shared_ptr<G> g = std::make_shared<G>();\n  copy_to(*g);\n  return g;\n}\n\n/**@}*/\n} // end of namespace wcs\n#endif // __WCS_UTILS_GRAPH_FACTORY_HPP__\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-wcs-develop-bx6mroakgfhny5agjyv7rr37ntddbtsi/spack-src/.git/objects/pack/pack-33179cd16dc30b8df568fb712bfed035a8aa04d9.idx",
        "/tmp/vanessa/spack-stage/spack-stage-wcs-develop-bx6mroakgfhny5agjyv7rr37ntddbtsi/spack-src/.git/objects/pack/pack-33179cd16dc30b8df568fb712bfed035a8aa04d9.pack"
    ],
    "total_files": 192
}