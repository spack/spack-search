{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/src/source.cpp": "#include \"openmc/source.h\"\n\n#if defined (__unix__) || (defined (__APPLE__) && defined (__MACH__))\n#define HAS_DYNAMIC_LINKING\n#endif\n\n#include <algorithm> // for move\n\n#ifdef HAS_DYNAMIC_LINKING\n#include <dlfcn.h> // for dlopen, dlsym, dlclose, dlerror\n#endif\n\n#include <fmt/core.h>\n#include \"xtensor/xadapt.hpp\"\n\n#include \"openmc/bank.h\"\n#include \"openmc/cell.h\"\n#include \"openmc/error.h\"\n#include \"openmc/file_utils.h\"\n#include \"openmc/hdf5_interface.h\"\n#include \"openmc/material.h\"\n#include \"openmc/message_passing.h\"\n#include \"openmc/mgxs_interface.h\"\n#include \"openmc/nuclide.h\"\n#include \"openmc/capi.h\"\n#include \"openmc/random_lcg.h\"\n#include \"openmc/search.h\"\n#include \"openmc/settings.h\"\n#include \"openmc/simulation.h\"\n#include \"openmc/state_point.h\"\n#include \"openmc/xml_interface.h\"\n\nnamespace openmc {\n\n//==============================================================================\n// Global variables\n//==============================================================================\n\nnamespace model {\n\nstd::vector<SourceDistribution> external_sources;\n\n}\n\nnamespace {\n\nusing sample_t = Particle::Bank (*)(uint64_t* seed);\nsample_t custom_source_function;\nvoid* custom_source_library;\n\n}\n\n\n//==============================================================================\n// SourceDistribution implementation\n//==============================================================================\n\nSourceDistribution::SourceDistribution(UPtrSpace space, UPtrAngle angle, UPtrDist energy)\n  : space_{std::move(space)}, angle_{std::move(angle)}, energy_{std::move(energy)} { }\n\nSourceDistribution::SourceDistribution(pugi::xml_node node)\n{\n  // Check for particle type\n  if (check_for_node(node, \"particle\")) {\n    auto temp_str = get_node_value(node, \"particle\", true, true);\n    if (temp_str == \"neutron\") {\n      particle_ = Particle::Type::neutron;\n    } else if (temp_str == \"photon\") {\n      particle_ = Particle::Type::photon;\n      settings::photon_transport = true;\n    } else {\n      fatal_error(std::string(\"Unknown source particle type: \") + temp_str);\n    }\n  }\n\n  // Check for source strength\n  if (check_for_node(node, \"strength\")) {\n    strength_ = std::stod(get_node_value(node, \"strength\"));\n  }\n\n  // Check for external source file\n  if (check_for_node(node, \"file\")) {\n    // Copy path of source file\n    settings::path_source = get_node_value(node, \"file\", false, true);\n\n    // Check if source file exists\n    if (!file_exists(settings::path_source)) {\n      fatal_error(fmt::format(\"Source file '{}' does not exist.\",\n        settings::path_source));\n    }\n  } else if (check_for_node(node, \"library\")) {\n    settings::path_source_library = get_node_value(node, \"library\", false, true);\n    if (!file_exists(settings::path_source_library)) {\n      fatal_error(fmt::format(\"Source library '{}' does not exist.\",\n        settings::path_source_library));\n    }\n  } else {\n\n    // Spatial distribution for external source\n    if (check_for_node(node, \"space\")) {\n      // Get pointer to spatial distribution\n      pugi::xml_node node_space = node.child(\"space\");\n\n      // Check for type of spatial distribution and read\n      std::string type;\n      if (check_for_node(node_space, \"type\"))\n        type = get_node_value(node_space, \"type\", true, true);\n      if (type == \"cartesian\") {\n        space_ = UPtrSpace{new CartesianIndependent(node_space)};\n      } else if (type == \"cylindrical\") {\n        space_ = UPtrSpace{new CylindricalIndependent(node_space)};\n      } else if (type == \"spherical\") {\n        space_ = UPtrSpace{new SphericalIndependent(node_space)};\n      } else if (type == \"box\") {\n        space_ = UPtrSpace{new SpatialBox(node_space)};\n      } else if (type == \"fission\") {\n        space_ = UPtrSpace{new SpatialBox(node_space, true)};\n      } else if (type == \"point\") {\n        space_ = UPtrSpace{new SpatialPoint(node_space)};\n      } else {\n        fatal_error(fmt::format(\n          \"Invalid spatial distribution for external source: {}\", type));\n      }\n\n    } else {\n      // If no spatial distribution specified, make it a point source\n      space_ = UPtrSpace{new SpatialPoint()};\n    }\n\n    // Determine external source angular distribution\n    if (check_for_node(node, \"angle\")) {\n      // Get pointer to angular distribution\n      pugi::xml_node node_angle = node.child(\"angle\");\n\n      // Check for type of angular distribution\n      std::string type;\n      if (check_for_node(node_angle, \"type\"))\n        type = get_node_value(node_angle, \"type\", true, true);\n      if (type == \"isotropic\") {\n        angle_ = UPtrAngle{new Isotropic()};\n      } else if (type == \"monodirectional\") {\n        angle_ = UPtrAngle{new Monodirectional(node_angle)};\n      } else if (type == \"mu-phi\") {\n        angle_ = UPtrAngle{new PolarAzimuthal(node_angle)};\n      } else {\n        fatal_error(fmt::format(\n          \"Invalid angular distribution for external source: {}\", type));\n      }\n\n    } else {\n      angle_ = UPtrAngle{new Isotropic()};\n    }\n\n    // Determine external source energy distribution\n    if (check_for_node(node, \"energy\")) {\n      pugi::xml_node node_dist = node.child(\"energy\");\n      energy_ = distribution_from_xml(node_dist);\n    } else {\n      // Default to a Watt spectrum with parameters 0.988 MeV and 2.249 MeV^-1\n      energy_ = UPtrDist{new Watt(0.988e6, 2.249e-6)};\n    }\n  }\n}\n\n\nParticle::Bank SourceDistribution::sample(uint64_t* seed) const\n{\n  Particle::Bank site;\n\n  // Set weight to one by default\n  site.wgt = 1.0;\n\n  // Repeat sampling source location until a good site has been found\n  bool found = false;\n  int n_reject = 0;\n  static int n_accept = 0;\n  while (!found) {\n    // Set particle type\n    site.particle = particle_;\n\n    // Sample spatial distribution\n    site.r = space_->sample(seed);\n    double xyz[] {site.r.x, site.r.y, site.r.z};\n\n    // Now search to see if location exists in geometry\n    int32_t cell_index, instance;\n    int err = openmc_find_cell(xyz, &cell_index, &instance);\n    found = (err != OPENMC_E_GEOMETRY);\n\n    // Check if spatial site is in fissionable material\n    if (found) {\n      auto space_box = dynamic_cast<SpatialBox*>(space_.get());\n      if (space_box) {\n        if (space_box->only_fissionable()) {\n          // Determine material\n          const auto& c = model::cells[cell_index];\n          auto mat_index = c->material_.size() == 1\n            ? c->material_[0] : c->material_[instance];\n\n          if (mat_index == MATERIAL_VOID) {\n            found = false;\n          } else {\n            if (!model::materials[mat_index]->fissionable_) found = false;\n          }\n        }\n      }\n    }\n\n    // Check for rejection\n    if (!found) {\n      ++n_reject;\n      if (n_reject >= EXTSRC_REJECT_THRESHOLD &&\n          static_cast<double>(n_accept)/n_reject <= EXTSRC_REJECT_FRACTION) {\n        fatal_error(\"More than 95% of external source sites sampled were \"\n                    \"rejected. Please check your external source definition.\");\n      }\n    }\n  }\n\n  // Increment number of accepted samples\n  ++n_accept;\n\n  // Sample angle\n  site.u = angle_->sample(seed);\n\n  // Check for monoenergetic source above maximum particle energy\n  auto p = static_cast<int>(particle_);\n  auto energy_ptr = dynamic_cast<Discrete*>(energy_.get());\n  if (energy_ptr) {\n    auto energies = xt::adapt(energy_ptr->x());\n    if (xt::any(energies > data::energy_max[p])) {\n      fatal_error(\"Source energy above range of energies of at least \"\n                  \"one cross section table\");\n    } else if (xt::any(energies < data::energy_min[p])) {\n      fatal_error(\"Source energy below range of energies of at least \"\n                  \"one cross section table\");\n    }\n  }\n\n  while (true) {\n    // Sample energy spectrum\n    site.E = energy_->sample(seed);\n\n    // Resample if energy falls outside minimum or maximum particle energy\n    if (site.E < data::energy_max[p] && site.E > data::energy_min[p]) break;\n  }\n\n  // Set delayed group\n  site.delayed_group = 0;\n\n  return site;\n}\n\n//==============================================================================\n// Non-member functions\n//==============================================================================\n\nvoid initialize_source()\n{\n  write_message(\"Initializing source particles...\", 5);\n\n  if (!settings::path_source.empty()) {\n    // Read the source from a binary file instead of sampling from some\n    // assumed source distribution\n\n    write_message(fmt::format(\"Reading source file from {}...\",\n      settings::path_source), 6);\n\n    // Open the binary file\n    hid_t file_id = file_open(settings::path_source, 'r', true);\n\n    // Read the file type\n    std::string filetype;\n    read_attribute(file_id, \"filetype\", filetype);\n\n    // Check to make sure this is a source file\n    if (filetype != \"source\" && filetype != \"statepoint\") {\n      fatal_error(\"Specified starting source file not a source file type.\");\n    }\n\n    // Read in the source bank\n    read_source_bank(file_id);\n\n    // Close file\n    file_close(file_id);\n  } else if (!settings::path_source_library.empty()) {\n\n    write_message(fmt::format(\"Sampling from library source {}...\",\n      settings::path_source), 6);\n\n    fill_source_bank_custom_source();\n\n  } else {\n    // Generation source sites from specified distribution in user input\n    for (int64_t i = 0; i < simulation::work_per_rank; ++i) {\n      // initialize random number seed\n      int64_t id = simulation::total_gen*settings::n_particles +\n        simulation::work_index[mpi::rank] + i + 1;\n      uint64_t seed = init_seed(id, STREAM_SOURCE);\n\n      // sample external source distribution\n      simulation::source_bank[i] = sample_external_source(&seed);\n    }\n  }\n\n  // Write out initial source\n  if (settings::write_initial_source) {\n    write_message(\"Writing out initial source...\", 5);\n    std::string filename = settings::path_output + \"initial_source.h5\";\n    hid_t file_id = file_open(filename, 'w', true);\n    write_source_bank(file_id);\n    file_close(file_id);\n  }\n}\n\nParticle::Bank sample_external_source(uint64_t* seed)\n{\n  // return values from custom source if using\n  if (!settings::path_source_library.empty()) {\n    return sample_custom_source_library(seed);\n  }\n\n  // Determine total source strength\n  double total_strength = 0.0;\n  for (auto& s : model::external_sources)\n    total_strength += s.strength();\n\n  // Sample from among multiple source distributions\n  int i = 0;\n  if (model::external_sources.size() > 1) {\n    double xi = prn(seed)*total_strength;\n    double c = 0.0;\n    for (; i < model::external_sources.size(); ++i) {\n      c += model::external_sources[i].strength();\n      if (xi < c) break;\n    }\n  }\n\n  // Sample source site from i-th source distribution\n  Particle::Bank site {model::external_sources[i].sample(seed)};\n\n  // If running in MG, convert site.E to group\n  if (!settings::run_CE) {\n    site.E = lower_bound_index(data::mg.rev_energy_bins_.begin(),\n      data::mg.rev_energy_bins_.end(), site.E);\n    site.E = data::mg.num_energy_groups_ - site.E - 1.;\n  }\n\n  return site;\n}\n\nvoid free_memory_source()\n{\n  model::external_sources.clear();\n}\n\nvoid load_custom_source_library()\n{\n#ifdef HAS_DYNAMIC_LINKING\n\n  // Open the library\n  custom_source_library = dlopen(settings::path_source_library.c_str(), RTLD_LAZY);\n  if (!custom_source_library) {\n    fatal_error(\"Couldn't open source library \" + settings::path_source_library);\n  }\n\n  // reset errors\n  dlerror();\n\n  // get the function from the library\n  using sample_t = Particle::Bank (*)(uint64_t* seed);\n  custom_source_function = reinterpret_cast<sample_t>(dlsym(custom_source_library, \"sample_source\"));\n\n  // check for any dlsym errors\n  auto dlsym_error = dlerror();\n  if (dlsym_error) {\n    dlclose(custom_source_library);\n    fatal_error(fmt::format(\"Couldn't open the sample_source symbol: {}\", dlsym_error));\n  }\n\n#else\n  fatal_error(\"Custom source libraries have not yet been implemented for \"\n    \"non-POSIX systems\");\n#endif\n}\n\nvoid close_custom_source_library()\n{\n#ifdef HAS_DYNAMIC_LINKING\n  dlclose(custom_source_library);\n#else\n  fatal_error(\"Custom source libraries have not yet been implemented for \"\n              \"non-POSIX systems\");\n#endif\n}\n\nParticle::Bank sample_custom_source_library(uint64_t* seed)\n{\n  return custom_source_function(seed);\n}\n\nvoid fill_source_bank_custom_source()\n{\n  // Load the custom library\n  load_custom_source_library();\n\n  // Generation source sites from specified distribution in the\n  // library source\n  for (int64_t i = 0; i < simulation::work_per_rank; ++i) {\n    // initialize random number seed\n    int64_t id = (simulation::total_gen + overall_generation()) *\n      settings::n_particles + simulation::work_index[mpi::rank] + i + 1;\n     uint64_t seed = init_seed(id, STREAM_SOURCE);\n\n    // sample custom library source\n    simulation::source_bank[i] = sample_custom_source_library(&seed);\n  }\n\n  // release the library\n  close_custom_source_library();\n}\n\n} // namespace openmc\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/include/openmc/source.h": "//! \\file source.h\n//! \\brief External source distributions\n\n#ifndef OPENMC_SOURCE_H\n#define OPENMC_SOURCE_H\n\n#include <memory>\n#include <vector>\n\n#include \"pugixml.hpp\"\n\n#include \"openmc/distribution_multi.h\"\n#include \"openmc/distribution_spatial.h\"\n#include \"openmc/particle.h\"\n\nnamespace openmc {\n\n//==============================================================================\n// Global variables\n//==============================================================================\n\nclass SourceDistribution;\n\nnamespace model {\n\nextern std::vector<SourceDistribution> external_sources;\n\n} // namespace model\n\n//==============================================================================\n//! External source distribution\n//==============================================================================\n\nclass SourceDistribution {\npublic:\n  // Constructors\n  SourceDistribution(UPtrSpace space, UPtrAngle angle, UPtrDist energy);\n  explicit SourceDistribution(pugi::xml_node node);\n\n  //! Sample from the external source distribution\n  //! \\param[inout] seed Pseudorandom seed pointer\n  //! \\return Sampled site\n  Particle::Bank sample(uint64_t* seed) const;\n\n  // Properties\n  Particle::Type particle_type() const { return particle_; }\n  double strength() const { return strength_; }\n\n  // Make observing pointers available\n  SpatialDistribution* space() const { return space_.get(); }\n  UnitSphereDistribution* angle() const { return angle_.get(); }\n  Distribution* energy() const { return energy_.get(); }\n\nprivate:\n  Particle::Type particle_ {Particle::Type::neutron}; //!< Type of particle emitted\n  double strength_ {1.0}; //!< Source strength\n  UPtrSpace space_; //!< Spatial distribution\n  UPtrAngle angle_; //!< Angular distribution\n  UPtrDist energy_; //!< Energy distribution\n};\n\n//==============================================================================\n// Functions\n//==============================================================================\n\n//! Initialize source bank from file/distribution\nextern \"C\" void initialize_source();\n\n//! Sample a site from all external source distributions in proportion to their\n//! source strength\n//! \\param[inout] seed Pseudorandom seed pointer\n//! \\return Sampled source site\nParticle::Bank sample_external_source(uint64_t* seed);\n\n//! Sample a site from custom source library\nParticle::Bank sample_custom_source_library(uint64_t* seed);\n\n//! Load custom source library\nvoid load_custom_source_library();\n\n//! Release custom source library\nvoid close_custom_source_library();\n\n//! Fill source bank at the end of a generation for dlopen based source simulation\nvoid fill_source_bank_custom_source();\n\nvoid free_memory_source();\n\n} // namespace openmc\n\n#endif // OPENMC_SOURCE_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/unit_tests/test_source.py": "import openmc\nimport openmc.stats\n\n\ndef test_source():\n    space = openmc.stats.Point()\n    energy = openmc.stats.Discrete([1.0e6], [1.0])\n    angle = openmc.stats.Isotropic()\n\n    src = openmc.Source(space=space, angle=angle, energy=energy)\n    assert src.space == space\n    assert src.angle == angle\n    assert src.energy == energy\n\n    elem = src.to_xml_element()\n    assert 'strength' in elem.attrib\n    assert elem.find('space') is not None\n    assert elem.find('angle') is not None\n    assert elem.find('energy') is not None\n\n    src = openmc.Source.from_xml_element(elem)\n    assert isinstance(src.angle, openmc.stats.Isotropic)\n    assert src.space.xyz == [0.0, 0.0, 0.0]\n    assert src.energy.x == [1.0e6]\n    assert src.energy.p == [1.0]\n    assert src.strength == 1.0\n\n\ndef test_source_file():\n    filename = 'source.h5'\n    src = openmc.Source(filename=filename)\n    assert src.file == filename\n\n    elem = src.to_xml_element()\n    assert 'strength' in elem.attrib\n    assert 'file' in elem.attrib\n\ndef test_source_dlopen():\n    library = './libsource.so'\n    src = openmc.Source(library=library)\n    assert src.library == library\n\n    elem = src.to_xml_element()\n    assert 'library' in elem.attrib\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/source_dlopen/test.py": "from pathlib import Path\nimport os\nimport shutil\nimport subprocess\nimport textwrap\n\nimport openmc\nimport pytest\n\nfrom tests.testing_harness import PyAPITestHarness\n\n\n@pytest.fixture\ndef compile_source(request):\n    \"\"\"Compile the external source\"\"\"\n\n    # Get build directory and write CMakeLists.txt file\n    openmc_dir = Path(str(request.config.rootdir)) / 'build'\n    with open('CMakeLists.txt', 'w') as f:\n        f.write(textwrap.dedent(\"\"\"\n            cmake_minimum_required(VERSION 3.3 FATAL_ERROR)\n            project(openmc_sources CXX)\n            add_library(source SHARED source_sampling.cpp)\n            find_package(OpenMC REQUIRED HINTS {})\n            target_link_libraries(source OpenMC::libopenmc)\n            \"\"\".format(openmc_dir)))\n\n    # Create temporary build directory and change to there\n    local_builddir = Path('build')\n    local_builddir.mkdir(exist_ok=True)\n    os.chdir(str(local_builddir))\n\n    # Run cmake/make to build the shared libary\n    subprocess.run(['cmake', os.path.pardir], check=True)\n    subprocess.run(['make'], check=True)\n    os.chdir(os.path.pardir)\n\n    yield\n\n    # Remove local build directory when test is complete\n    shutil.rmtree('build')\n    os.remove('CMakeLists.txt')\n\n\n@pytest.fixture\ndef model():\n    model = openmc.model.Model()\n    natural_lead = openmc.Material(name=\"natural_lead\")\n    natural_lead.add_element('Pb', 1.0)\n    natural_lead.set_density('g/cm3', 11.34)\n    model.materials.append(natural_lead)\n\n    # geometry\n    surface_sph1 = openmc.Sphere(r=100, boundary_type='vacuum')\n    cell_1 = openmc.Cell(fill=natural_lead, region=-surface_sph1)\n    model.geometry = openmc.Geometry([cell_1])\n\n    # settings\n    model.settings.batches = 10\n    model.settings.inactive = 0\n    model.settings.particles = 1000\n    model.settings.run_mode = 'fixed source'\n\n    # custom source from shared library\n    source = openmc.Source()\n    source.library = 'build/libsource.so'\n    model.settings.source = source\n\n    return model\n\n\ndef test_dlopen_source(compile_source, model):\n    harness = PyAPITestHarness('statepoint.10.h5', model)\n    harness.main()\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/source_dlopen/source_sampling.cpp": "#include <iostream>\n#include \"openmc/random_lcg.h\"\n#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\n// you must have external C linkage here otherwise \n// dlopen will not find the file\nextern \"C\" openmc::Particle::Bank sample_source(uint64_t *seed) {\n    openmc::Particle::Bank particle;\n    // wgt\n    particle.particle = openmc::Particle::Type::neutron;\n    particle.wgt = 1.0;\n    // position\n    \n    particle.r.x = 0.;\n    particle.r.y = 0.;\n    particle.r.z = 0.;\n    // angle\n    particle.u = {1.0, 0.0, 0.0};\n    particle.E = 14.08e6;\n    particle.delayed_group = 0;\n    return particle;    \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/custom_source/source_ring.cpp": "#include <cmath> // for M_PI\n\n#include \"openmc/random_lcg.h\"\n#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\n// you must have external C linkage here otherwise\n// dlopen will not find the file\nextern \"C\" openmc::Particle::Bank sample_source(uint64_t* seed)\n{\n  openmc::Particle::Bank particle;\n  // wgt\n  particle.particle = openmc::Particle::Type::neutron;\n  particle.wgt = 1.0;\n  // position\n  double angle = 2. * M_PI * openmc::prn(seed);\n  double radius = 3.0;\n  particle.r.x = radius * std::cos(angle);\n  particle.r.y = radius * std::sin(angle);\n  particle.r.z = 0.0;\n  // angle\n  particle.u = {1.0, 0.0, 0.0};\n  particle.E = 14.08e6;\n  particle.delayed_group = 0;\n  return particle;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/openmc/data/density_effect.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/openmc/data/compton_profiles.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/.git/objects/pack/pack-c6f22aabfaa160271b370af666ce3dbb6c8ac5db.pack",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/.git/objects/pack/pack-c6f22aabfaa160271b370af666ce3dbb6c8ac5db.idx",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/unit_tests/dagmc/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/unstructured_mesh/test_mesh_tets.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/unstructured_mesh/test_mesh_tets_w_holes.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/deplete/test_reference.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/dagmc/legacy/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/dagmc/uwuw/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/tests/regression_tests/dagmc/refl/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/c5g7.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/pin_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/teapot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/manifold_flux.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/umesh_flux.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/mgxs.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/flux3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/mdgxs.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/manifold-cad.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/manifold_pnt_cld.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/umesh_w_assembly.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/umesh_heating.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/examples/jupyter/images/cylinder_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/cosine-dist.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/plotmeshtally.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/fluxplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/master-slave.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/3dba.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/meshfig.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/loss.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/atr.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/cmfd_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/nearest-neighbor.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/prod.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/nearest-neighbor-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/openmc_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/3dcore.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/3dgeomplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/source/_images/Tracks.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/diagrams/overview.dia",
        "/tmp/vanessa/spack-stage/spack-stage-py-openmc-master-ae4jb3g3grnby2ystppcudzj7kz3dxy5/spack-src/docs/diagrams/cross_sections.dia"
    ],
    "total_files": 1212
}