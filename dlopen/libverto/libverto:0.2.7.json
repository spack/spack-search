{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libverto-0.2.7-xliqmhnvb7ldziydwwwboujnzcbq2iah/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\n\nAC_PREREQ(2.59)\nAC_INIT(libverto, 0.2.7)\n\nm4_ifdef([AC_USE_SYSTEM_EXTENSIONS],\n    [AC_USE_SYSTEM_EXTENSIONS],\n    [AC_GNU_SOURCE])\n\nAC_PROG_CC_C99\nCFLAGS=\"$CFLAGS -Wall -Wextra\"\n\nAC_CANONICAL_SYSTEM\nAM_INIT_AUTOMAKE([1.11])\n\nAC_PROG_LIBTOOL\nAC_CONFIG_MACRO_DIR([m4])\n\nm4_ifdef([AM_SILENT_RULES], [\n  AM_SILENT_RULES([yes])\n], [\n  AM_DEFAULT_VERBOSITY=1\n  AC_SUBST(AM_DEFAULT_VERBOSITY)\n])\n\nPKG_PROG_PKG_CONFIG\nAC_CHECK_LIB([dl],[dlopen])\n\nAC_ARG_WITH([pthread],\n            [AS_HELP_STRING([--with-pthread],\n                            [build pthread support @<:@default: automatic@:>@])],\n            [case $withval in\n                 no) WITH_PTHREAD=no;;\n                yes) WITH_PTHREAD=yes;;\n                  *) WITH_PTHREAD=auto;;\n             esac], [WITH_PTHREAD=auto])\nBUILD_PTHREAD=no\nif test x$WITH_PTHREAD != xno; then\n  AX_PTHREAD([PTHREAD_CFLAGS=\"$PTHREAD_CFLAGS -DHAVE_PTHREAD=1\";\n              CC=\"$PTHREAD_CC\";\n              BUILD_PTHREAD=yes],\n             [test x$WITH_PTHREAD = xyes && AC_MSG_ERROR(\"pthread not found\")])\nfi\n\nAC_ARG_WITH([glib],\n            [AS_HELP_STRING([--with-glib],\n                            [build the glib library @<:@default: automatic@:>@])],\n            [case $withval in\n                   no) WITH_GLIB=no;;\n                  yes) WITH_GLIB=yes;;\n              default) WITH_GLIB=default;;\n              builtin) WITH_GLIB=builtin;;\n                    *) WITH_GLIB=auto;;\n             esac], [WITH_GLIB=auto])\n\nAC_ARG_WITH([libev],\n            [AS_HELP_STRING([--with-libev],\n                            [build the libev library @<:@default: automatic@:>@])],\n            [case $withval in\n                   no) WITH_LIBEV=no;;\n                  yes) WITH_LIBEV=yes;;\n              default) WITH_LIBEV=default;;\n              builtin) WITH_LIBEV=builtin;;\n                    *) WITH_LIBEV=auto;;\n             esac], [WITH_LIBEV=auto])\n\nAC_ARG_WITH([libevent],\n            [AS_HELP_STRING([--with-libevent],\n                            [build the libevent library @<:@default: automatic@:>@])],\n            [case $withval in\n                   no) WITH_LIBEVENT=no;;\n                  yes) WITH_LIBEVENT=yes;;\n              default) WITH_LIBEVENT=default;;\n              builtin) WITH_LIBEVENT=builtin;;\n                    *) WITH_LIBEVENT=auto;;\n             esac], [WITH_LIBEVENT=auto])\n\nAC_ARG_WITH([tevent],\n            [AS_HELP_STRING([--with-tevent],\n                            [build the tevent library @<:@default: automatic@:>@])],\n            [case $withval in\n                 no) WITH_TEVENT=no;;\n                yes) WITH_TEVENT=yes;;\n                  *) WITH_TEVENT=auto;;\n             esac], [WITH_TEVENT=auto])\n\n# Ensure that if a builtin is chosen only one is built\nBUILTIN_MODULE=\nif test x$WITH_GLIB == xbuiltin; then\n  BUILTIN_MODULE=glib\n  WITH_LIBEV=no\n  WITH_LIBEVENT=no\n  WITH_TEVENT=no\nelif test x$WITH_LIBEV == xbuiltin; then\n  BUILTIN_MODULE=libev\n  WITH_LIBGLIB=no\n  WITH_LIBEVENT=no\n  WITH_TEVENT=no\nelif test x$WITH_LIBEVENT == xbuiltin; then\n  BUILTIN_MODULE=libevent\n  WITH_LIBGLIB=no\n  WITH_LIBEV=no\n  WITH_TEVENT=no\nelif test x$WITH_TEVENT == xbuiltin; then\n  BUILTIN_MODULE=tevent\n  WITH_GLIB=no\n  WITH_LIBEV=no\n  WITH_LIBEVENT=no\nfi\nAC_SUBST([BUILTIN_MODULE], $BUILTIN_MODULE)\nif test x$BUILTIN_MODULE != x; then\n  AC_DEFINE_UNQUOTED([BUILTIN_MODULE], $BUILTIN_MODULE)\nfi\n\n# Ensure that there is only one default (convert duplicate default to yes)\nif test x$WITH_GLIB == xdefault; then\n  AC_DEFINE([DEFUALT_MODULE], [glib])\n  test x$WITH_LIBEV    == xdefault && WITH_LIBEV=yes\n  test x$WITH_LIBEVENT == xdefault && WITH_LIBEVENT=yes\n  test x$WITH_TEVENT   == xdefault && WITH_TEVENT=yes\nfi\nif test x$WITH_LIBEV == xdefault; then\n  AC_DEFINE([DEFUALT_MODULE], [libev])\n  test x$WITH_LIBGLIB  == xdefault && WITH_GLIB=yes\n  test x$WITH_LIBEVENT == xdefault && WITH_LIBEVENT=yes\n  test x$WITH_TEVENT   == xdefault && WITH_TEVENT=yes\nfi\nif test x$WITH_LIBEVENT == xdefault; then\n  AC_DEFINE([DEFUALT_MODULE], [libevent])\n  test x$WITH_GLIB     == xdefault && WITH_GLIB=yes\n  test x$WITH_LIBEV    == xdefault && WITH_LIBEV=yes\n  test x$WITH_TEVENT   == xdefault && WITH_TEVENT=yes\nfi\nif test x$WITH_TEVENT == xdefault; then\n  AC_DEFINE([DEFUALT_MODULE], [tevent])\n  test x$WITH_GLIB     == xdefault && WITH_GLIB=yes\n  test x$WITH_LIBEV    == xdefault && WITH_LIBEV=yes\n  test x$WITH_LIBEVENT == xdefault && WITH_LIBEVENT=yes\nfi\n\nBUILD_GLIB=no\nBUILD_LIBEV=no\nBUILD_LIBEVENT=no\nBUILD_TEVENT=no\n\nif test x$WITH_GLIB != xno; then\n  PKG_CHECK_MODULES([glib], [glib-2.0], [BUILD_GLIB=$WITH_GLIB],\n                    [test x$WITH_GLIB != xauto && AC_MSG_ERROR(\"glib not found\")])\n  if test x$BUILD_GLIB == xauto; then\n    BUILD_GLIB=yes\n  fi\nfi\n\nif test x$WITH_LIBEV != xno; then\n  AC_CHECK_HEADER(\n    [ev.h],\n    AC_CHECK_LIB(\n      [ev], [ev_loop_new], [BUILD_LIBEV=$WITH_LIBEV],\n      [test x$WITH_LIBEV != xauto && AC_MSG_ERROR(\"libev not found\")]\n    ),\n    [test x$WITH_LIBEV != xauto && AC_MSG_ERROR(\"ev.h not found\")]\n  )\n  if test x$BUILD_LIBEV == xauto; then\n    BUILD_LIBEV=yes\n  fi\nfi\n\nif test x$WITH_LIBEVENT != xno; then\n  PKG_CHECK_MODULES([libevent], [libevent >= 2.0], [BUILD_LIBEVENT=$WITH_LIBEVENT],\n                    [test x$WITH_LIBEVENT != xauto && AC_MSG_ERROR(\"libevent not found\")])\n  if test x$BUILD_LIBEVENT == xauto; then\n    BUILD_LIBEVENT=yes\n  fi\nfi\n\nif test x$WITH_TEVENT != xno; then\n  PKG_CHECK_MODULES([tevent], [tevent], [BUILD_TEVENT=$WITH_TEVENT],\n                    [test x$WITH_TEVENT != xauto && AC_MSG_ERROR(\"tevent not found\")])\n  if test x$BUILD_TEVENT == xauto; then\n    BUILD_TEVENT=yes\n  fi\nfi\n\nAM_CONDITIONAL([MODULE_GLIB],      [test x$BUILTIN_MODULE == x && test x$BUILD_GLIB     != xno])\nAM_CONDITIONAL([MODULE_LIBEV],     [test x$BUILTIN_MODULE == x && test x$BUILD_LIBEV    != xno])\nAM_CONDITIONAL([MODULE_LIBEVENT],  [test x$BUILTIN_MODULE == x && test x$BUILD_LIBEVENT != xno])\nAM_CONDITIONAL([MODULE_TEVENT],    [test x$BUILTIN_MODULE == x && test x$BUILD_TEVENT   != xno])\nAM_CONDITIONAL([BUILTIN_GLIB],     [test x$BUILTIN_MODULE == xglib])\nAM_CONDITIONAL([BUILTIN_LIBEV],    [test x$BUILTIN_MODULE == xlibev])\nAM_CONDITIONAL([BUILTIN_LIBEVENT], [test x$BUILTIN_MODULE == xlibevent])\nAM_CONDITIONAL([BUILTIN_TEVENT],   [test x$BUILTIN_MODULE == xtevent])\n\nAC_MSG_NOTICE()\nAC_MSG_NOTICE([BUILD CONFIGURATION])\nAC_MSG_NOTICE(AS_HELP_STRING([pthread], [$BUILD_PTHREAD]))\nAC_MSG_NOTICE(AS_HELP_STRING([glib], [$BUILD_GLIB]))\nAC_MSG_NOTICE(AS_HELP_STRING([libev], [$BUILD_LIBEV]))\nAC_MSG_NOTICE(AS_HELP_STRING([libevent], [$BUILD_LIBEVENT]))\nAC_MSG_NOTICE(AS_HELP_STRING([tevent], [$BUILD_TEVENT]))\nAC_MSG_NOTICE()\n\nAC_CONFIG_FILES(Makefile\n                src/Makefile\n                tests/Makefile\n                libverto-glib.pc\n                libverto-libev.pc\n                libverto-libevent.pc\n                libverto-tevent.pc\n                libverto.pc)\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-libverto-0.2.7-xliqmhnvb7ldziydwwwboujnzcbq2iah/spack-src/src/module.c": "/*\n * Copyright 2011 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifdef WIN32\n#include <windows.h>\n#define dlltype HMODULE\nstatic char *\ndllerror(void) {\n    char *amsg;\n    LPTSTR msg;\n\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER\n                      | FORMAT_MESSAGE_FROM_SYSTEM\n                      | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL, GetLastError(),\n                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  (LPTSTR) &msg, 0, NULL);\n    amsg = strdup((const char*) msg);\n    LocalFree(msg);\n    return amsg;\n}\n#elif defined(aix)\n#include \"sys/ldr.h\"\n\nstruct Dl_info {\n  const char* dli_fname;\n};\n\nstatic int\ndladdr(void* s, Dl_info* i)\n{\n    static const size_t bufSize = 4096;\n    G__FastAllocString buf(bufSize);\n    char* pldi = buf;\n    int r;\n\n    r = loadquery(L_GETINFO, pldi, bufSize);\n    if (r == -1) {\n        i->dli_fname = NULL;\n        return 0;\n    }\n\n    for (ld_info* ldi = (ld_info*) buf;\n         ldi->ldinfo_next;\n         ldi += ldi->ldinfo_next) {\n        char* textBegin = (char*) ldi->ldinfo_textorg;\n        if (textBegin < s) {\n            char* textEnd = textBegin + ldi->ldinfo_textsize;\n            if (textEnd > s) {\n                i->dli_fname = ldi->ldinfo_filename;\n                return 1;\n            }\n        }\n    }\n\n    // First is main(), skip.\n    ld_info* ldi = (ld_info*) pldi;\n    while (ldi->ldinfo_next) {\n        pldi += ldi->ldinfo_next;\n        ldi = (ld_info*) pldi;\n\n    }\n\n    i->dli_fname = NULL;\n    return 0;\n}\n#else\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#define dlltype void *\n#define dllerror() strdup(dlerror())\n#endif\n\nint\nmodule_symbol_is_present(const char *modname, const char *symbname)\n{\n#ifdef WIN32\n    return (GetProcAddress(GetModuleHandle(modname), symbname) != NULL ||\n            GetProcAddress(GetModuleHandle(NULL), symbname) != NULL);\n#else  /* WIN32 */\n    void *mod;\n    (void) modname;\n\n    mod = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL);\n    if (mod) {\n        void* sym = dlsym(mod, symbname);\n        dlclose(mod);\n        return sym != NULL;\n    }\n#endif /* WIN32 */\n    return 0;\n}\n\nint\nmodule_get_filename_for_symbol(void *addr, char **filename)\n{\n#ifdef WIN32\n    MEMORY_BASIC_INFORMATION info;\n    HMODULE mod;\n    char tmp[MAX_PATH];\n\n    if (!VirtualQuery(addr, &info, sizeof(info)))\n        return 0;\n    mod = (HMODULE) info.AllocationBase;\n\n    if (!GetModuleFileNameA(mod, tmp, MAX_PATH))\n        return 0;\n#else\n    const char *tmp;\n    Dl_info dlinfo;\n\n    if (!dladdr(addr, &dlinfo))\n        return 0;\n    tmp = dlinfo.dli_fname;\n#endif\n\n    if (filename) {\n        *filename = strdup(tmp);\n        if (!*filename)\n            return 0;\n    }\n\n    return 1;\n}\n\nvoid\nmodule_close(void *dll)\n{\n    if (!dll)\n        return;\n\n#ifdef WIN32\n    FreeLibrary((dlltype) dll);\n#else  /* WIN32 */\n    dlclose((dlltype) dll);\n#endif /* WIN32 */\n}\n\nchar *\nmodule_load(const char *filename, const char *symbname,\n            int (*shouldload)(void *symb, void *misc, char **err), void *misc,\n            void **dll, void **symb)\n{\n    dlltype intdll = NULL;\n    void *  intsym = NULL;\n    char *  interr = NULL;\n\n    if (dll)\n        *dll = NULL;\n    if (symb)\n        *symb = NULL;\n\n    /* Open the module library */\n#ifdef WIN32\n    /* NOTE: DONT_RESOLVE_DLL_REFERENCES is evil. Don't use this in your own\n     * code. However, our design pattern avoids all the issues surrounding a\n     * more general use of this evil flag. */\n    intdll = LoadLibraryEx(filename, NULL, DONT_RESOLVE_DLL_REFERENCES);\n#else  /* WIN32 */\n    intdll = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);\n#endif /* WIN32 */\n    if (!intdll)\n        return dllerror();\n\n    /* Get the module symbol */\n#ifdef WIN32\n    intsym = (void *) GetProcAddress(intdll, symbname);\n#else /* WIN32 */\n    intsym = dlsym(intdll, symbname);\n#endif /* WIN32 */\n    if (!intsym) {\n        module_close(intdll);\n        return dllerror();\n    }\n\n    /* Figure out whether or not to load this module */\n    if (!shouldload(intsym, misc, &interr)) {\n        module_close(intdll);\n        return interr;\n    }\n\n    /* Re-open the module */\n    module_close(intdll);\n#ifdef WIN32\n    intdll = LoadLibrary(filename);\n#else  /* WIN32 */\n    intdll = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n#endif /* WIN32 */\n    if (!intdll) {\n        return dllerror();\n    }\n\n    /* Get the symbol again */\n#ifdef WIN32\n    intsym = (void *) GetProcAddress(intdll, symbname);\n#else /* WIN32 */\n    intsym = dlsym(intdll, symbname);\n#endif /* WIN32 */\n    if (!intsym) {\n        module_close(intdll);\n        return dllerror();\n    }\n\n    if (dll)\n        *dll = intdll;\n    if (symb)\n        *symb = intsym;\n    return NULL;\n}\n"
    },
    "skipped": [],
    "total_files": 45
}