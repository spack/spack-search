{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/nicstat.c": "/*\n * nicstat - print network traffic, Kb/s read and written.\n *\n * Copyright (c) 2005-2014, Brendan.Gregg@sun.com and Tim.Cook@sun.com\n *\n * nicstat is licensed under the Artistic License 2.0.  You can find\n * a copy of this license as LICENSE.txt included with the nicstat\n * distribution, or at http://www.perlfoundation.org/artistic_license_2_0\n */\n\n#define\tNICSTAT_VERSION\t\t\"1.95\"\n\n/* Is this GNU/Linux? */\n#if defined(__linux__) || defined(__linux) || defined(linux)\n#define\tOS_LINUX\t1\n#endif\n\n/* Is this Solaris? */\n#if defined(sun) || defined(__sun)\n#if defined(__SVR4) || defined(__svr4__)\n#define\tOS_SOLARIS\t1\n#endif\n#endif\n\n#if ! defined(OS_SOLARIS) && ! defined(OS_LINUX)\n#error\t\"nicstat is not supported on your OS yet\"\n#endif\n\n#ifndef\tDEBUG\n#define\tDEBUG\t0\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#include <sys/time.h>\n#include <time.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <signal.h>\n\n#ifdef OS_SOLARIS\n#include <sys/sockio.h>\n#include <kstat.h>\n#include <libgen.h>\n#ifdef USE_DLADM\n#include <libdladm.h>\n#include <libdllink.h>\n#include <dlfcn.h>\n#include <link.h>\n#ifdef HAVE_LIBNETCFG\n#include <libnetcfg.h>\n#endif\n#endif\n#ifndef LIFC_ALLZONES\t/* Comes from <net/if.h> in 5.10 & later */\n#define\tLIFC_ALLZONES\t0x08\n#endif\n#ifndef LIFC_UNDER_IPMP\t/* <net.if.h> in 5.11 */\n#define\tLIFC_UNDER_IPMP\t0x0\n#endif\n#ifndef LIFC_ENABLED\t/* <net.if.h> in 5.11 */\n#define\tLIFC_ENABLED\t0x0\n#endif\n#ifndef MAXLINKNAMELEN\t/* <net/if.h> in 5.11 */\n#define\tMAXLINKNAMELEN\tLIFNAMSIZ\n#endif\n#define\tLIFR_FLAGS_TYPE\tuint64_t\n#else /* OS_SOLARIS */\n#include <poll.h>\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\n/* #include <linux/if.h> */\n#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <linux/types.h>\n#include <linux/ethtool.h>\n#define\tPROC_NET_DEV_PATH\t\"/proc/net/dev\"\n#define\tPROC_NET_SNMP_PATH\t\"/proc/net/snmp\"\n#define\tPROC_NET_NETSTAT_PATH\t\"/proc/net/netstat\"\n#define\tPROC_NET_BUFSIZ\t\t(128 * 1024)\n#define\tPROC_UPTIME\t\t\"/proc/uptime\"\n/* Needs to be fixed if not built under ILP32 */\ntypedef unsigned long long\tuint64_t;\ntypedef unsigned int\t\tuint32_t;\nextern char *optarg;\nextern int optind, opterr, optopt;\n#endif /* OS_LINUX */\n\n#ifdef OS_LINUX\ntypedef __u8\t\t\tduplex_t;\n/* This may be defined by <linux/ethtool.h> */\n#ifndef\tDUPLEX_UNKNOWN\n#define\tDUPLEX_UNKNOWN\t\t0xFF\n#endif /* DUPLEX_UNKNOWN */\n#else\ntypedef uint32_t\t\tduplex_t;\n#define\tDUPLEX_UNKNOWN\t\t0\n#define\tDUPLEX_HALF\t\t1\n#define\tDUPLEX_FULL\t\t2\n#endif /* OS_LINUX */\n\n#ifndef\tB_TRUE\n#define\tB_TRUE\t\t1\n#define\tB_FALSE\t\t0\n#endif\n\n#ifndef\tstreql\n#define\tstreql(a, b)\t(strcmp((a), (b)) == 0)\n#endif\n\n#define\tPAGE_SIZE 20\n#define\tINTERVAL 1\n#define\tLOOP_MAX 1\n\n#ifdef OS_LINUX\n#define\tGETOPT_OPTIONS\t\t\"hi:sS:znplvxtuaMmU\"\n#else\n#define\tGETOPT_OPTIONS\t\t\"hi:sznpklvxtuaMmU\"\n#endif\n\n/*\n * UDP stats\n */\ntypedef struct udp_stats {\n\tstruct timeval tv;\t\t/* tv_sec, tv_usec */\n\tuint64_t inDatagrams;\n\tuint64_t outDatagrams;\n\tuint64_t inErrors;\n\tuint64_t outErrors;\n} udpstats_t;\n\nstatic udpstats_t *g_udp_old, *g_udp_new;\n\ntypedef struct tcp_stats {\n\tstruct timeval tv;\t\t/* tv_sec, tv_usec */\n\tuint64_t inDataInorderSegs;\n\tuint64_t outDataSegs;\n\tuint64_t inDataInorderBytes;\n\tuint64_t inDataUnorderSegs;\n\tuint64_t inDataUnorderBytes;\n\tuint64_t outDataBytes;\n\tuint64_t estabResets;\n\tuint64_t outRsts;\n\tuint64_t attemptFails;\n\tuint64_t retransBytes;\n\tuint64_t passiveOpens;\n\tuint64_t activeOpens;\n\tuint64_t halfOpenDrop;\n\tuint64_t listenDrop;\n\tuint64_t listenDropQ0;\n} tcpstats_t;\n\nstatic tcpstats_t *g_tcp_old, *g_tcp_new;\n\n#ifdef OS_SOLARIS\nstatic kstat_t *g_tcp_ksp, *g_udp_ksp;\n#endif\n\n/*\n * Interface stats\n */\ntypedef struct nic_stats {\n\tstruct timeval tv;\t\t/* tv_sec, tv_usec */\n\tuint64_t rbytes;\t\t/* total read bytes */\n\tuint64_t wbytes;\t\t/* total written bytes */\n\tuint64_t rpackets;\t\t/* total read packets */\n\tuint64_t wpackets;\t\t/* total written packets */\n\tuint64_t ierr;\t\t\t/* total input errors */\n\tuint64_t oerr;\t\t\t/* total output errors */\n\tuint64_t coll;\t\t\t/* total collisions */\n\tuint64_t nocp;\t\t\t/* total nocanput */\n\tuint64_t defer;\t\t\t/* total defers */\n\tuint64_t sat;\t\t\t/* saturation value */\n} nicstats_t;\n\ntypedef struct nicdata {\n\tstruct nicdata *next;\t/* pointer to next */\n\tchar *name;\t\t/* interface name (e.g. \"lo0\") */\n\tuint32_t flags;\n#ifdef OS_LINUX\n\tint report;\t\t/* non-zero means we intend to print */\n#endif\n#ifdef OS_SOLARIS\n\tkstat_t *ls_ksp;\n\tkstat_t *op_ksp;\n\tuint32_t ls_types;\n\tuint32_t op_types;\n\tLIFR_FLAGS_TYPE if_flags;\n#endif\n\tuint64_t speed;\t\t\t/* speed of interface */\n\tduplex_t duplex;\n\tstruct nic_stats old;\t/* stats from previous lookup */\n\tstruct nic_stats new;\t/* stats from current lookup */\n} nicdata_t;\n\ntypedef struct if_list {\n\tstruct if_list *next;\n\tchar *name;\n#ifdef OS_LINUX\n\tstruct nicdata *nicp;\n#endif\n} if_list_t;\n\n/*\n * kstat type flags\n *\n * These are in decreasing order of preference; i.e, the highest order\n * bit will be chosen as the preferred source.  These bits have been\n * chosen to allow addition above, below and in-between the existing\n * choices.\n */\n#define\tKS_LINK\t\t\t0x40000\t\t/* link:<n>:<if>:<stat> */\n#define\tKS_DRV_MAC\t\t0x10000\t\t/* <drv>:<n>:mac:<stat> */\n#define\tKS_DIN\t\t\t0x04000\t\t/* <drv>:<n>:<if>:<stat> */\n#define\tKS_DRV\t\t\t0x01000\t\t/* <drv>:<n>:*:<stat> */\n#define\tKS_NAME\t\t\t0x00400\t\t/* <if>:*:*:<stat> */\n\n/*\n * Other interface flags - for nicdata_t.flags\n */\n#define\tNIC_LIF_UP\t\t0x00000001\t/* IFF_UP */\n#define\tNIC_KS_UP\t\t0x00000002\t/* kstat link_state = 1 */\n#define\tNIC_LOOPBACK\t\t0x00000010\t/* Is a IFF_LOOPBACK */\n#define\tNIC_NO_GLIFFLAGS\t0x00000100\t/* no ioctl(,SIOCGLIFFLAGS,) */\n#define\tNIC_NO_KSTATS\t\t0x00000200\t/* Can't even get packets */\n#define\tNIC_NO_LINKSTATE\t0x00000400\t/* No :::link_state */\n#define\tNIC_NO_GSET\t\t0x00000800\t/* ETHTOOL_GSET fails */\n#define\tNIC_NO_SFLAG\t\t0x00000200\t/* No -S for this i'face */\n#define\tNIC_UP\t\t(NIC_KS_UP | NIC_LIF_UP)\n\n#define\tNIC_LK_IS_OK\t\t0x00001000\t/* ls_ksp == op_ksp */\n\n#define\tNIC_LK_UPDATED\t\t0x00010000\t/* ls_ksp up to date */\n#define\tNIC_OK_UPDATED\t\t0x00020000\t/* op_ksp up to date */\n#define\tNIC_KU_UPDATED\t\t0x00040000\t/* NIC_KS_UP up to date */\n#define\tNIC_LU_UPDATED\t\t0x00080000\t/* NIC_LIF_UP up to date */\n\n/* These bits indicate we have updated some data */\n#define\tNIC_UPDATED_FLAGS\t(NIC_LK_UPDATED | NIC_OK_UPDATED | \\\n\t\t\t\tNIC_KU_UPDATED | NIC_LU_UPDATED)\n\n/* These bits are capabilities - should be static */\n#define\tNIC_CAPAB\t(NIC_CAN_GLIFFLAGS | NIC_HAVE_KSTATS | NIC_LOOPBACK)\n\n#ifdef OS_LINUX\nstruct if_speed_list {\n\tstruct if_speed_list *next;\n\tchar *name;\n\tuint64_t speed;\n\tint duplex;\n};\nstatic struct if_speed_list *g_if_speed_list = NULL;\n#endif /* OS_LINUX */\n\n/*\n * This will contain everything we need to know about each interface, and\n * will be dynamically allocated.\n */\nstatic struct nicdata *g_nicdatap = NULL;\n\n/* Print style for NICs */\nenum { STYLE_FULL = 0, STYLE_FULL_UTIL, STYLE_SUMMARY, STYLE_PARSEABLE,\n\tSTYLE_EXTENDED, STYLE_EXTENDED_UTIL,\n\tSTYLE_EXTENDED_PARSEABLE, STYLE_NONE };\n\nstatic int g_nicdata_count = 0;\t\t/* number of if's we are tracking */\nstatic int g_style;\t\t\t/* output style */\nstatic int g_skipzero;\t\t\t/* skip zero value lines */\nstatic int g_nonlocal;\t\t\t/* list only non-local (exclude lo0) */\nstatic int g_someif;\t\t\t/* trace some interfaces only */\nstatic int g_list;\nstatic int g_udp;\t\t\t/* show UDP stats */\nstatic int g_tcp;\t\t\t/* show TCP stats */\nstatic int g_opt_x;\nstatic int g_opt_p;\nstatic int g_opt_k;\nstatic int g_verbose;\nstatic int g_forever;\t\t\t/* run forever */\nstatic char **g_tracked;\t\t/* tracked interfaces */\nstatic int g_line;\t\t\t/* output line counter */\nstatic char *g_progname;\t\t\t/* ptr to argv[0] */\nstatic int g_caught_cont;\t\t/* caught SIGCONT - were suspended */\nstatic int g_opt_m;\t\t\t/* show results in Mbps (megabits) */\nstatic int g_opt_U;\t\t\t/* show in and out %Util */\n\n/* Used in display headers - default is when displaying KB/s */\nstatic char *g_runit_1 = \"rKB/s\";\nstatic char *g_wunit_1 = \"wKB/s\";\nstatic char *g_runit_2 = \"RdKB\";\nstatic char *g_wunit_2 = \"WrKB\";\n\nstatic int g_sock;\t\t\t/* Socket for interface ioctl's */\n\n#ifdef OS_SOLARIS\nstatic kstat_ctl_t *g_kc;\t\t/* kstat chain pointer */\nstatic int g_new_kstat_chain = B_TRUE;\t/* kstat chain updated */\n#ifdef USE_DLADM\n/* This is set to TRUE if we can load the libdladm function we need */\nstatic int g_use_dladm;\nstatic dladm_handle_t g_handle = NULL;\n#endif\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\nstatic unsigned long g_boot_time;\t/* when we booted */\nstatic FILE *g_snmp = NULL;\nstatic FILE *g_netstat = NULL;\n#endif /* OS_LINUX */\n\n/*\n * diag - print stderr message.\n *\n * This subroutine prints an error message, possibly including the meaning\n * of errno.\n */\nstatic void\ndiag(int use_errno, char *format, ...)\n{\n\tva_list ap;\n\tchar *error_str;\n\n\t(void) fprintf(stderr, \"%s: \", g_progname);\n\tif (use_errno) {\n\t\terror_str = strerror(errno);\n\t\tif (! error_str)\n\t\t\terror_str = strerror(0);\n\t}\n\tva_start(ap, format);\n\t(void) vfprintf(stderr, format, ap);\n\tva_end(ap);\n\tif (use_errno)\n\t\t(void) fprintf(stderr, \": %s\\n\", error_str);\n\telse\n\t\t(void) fputc('\\n', stderr);\n}\n\n#define\tdie(...) \\\ndo { \\\n\tdiag(__VA_ARGS__);\t\t\t\\\n\texit(2);\t\t\t\t\\\n} while (0)\n\n/*\n * usage - print a usage message and exit.\n */\nstatic void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"USAGE: nicstat [-hvnsxpztualMU] [-i int[,int...]]\\n   \"\n#ifdef OS_LINUX\n\t    \"[-S int:mbps[,int:mbps...]] \"\n#endif\n\t    \"[interval [count]]\\n\"\n\t    \"\\n\"\n\t    \"         -h                 # help\\n\"\n\t    \"         -v                 # show version (\" NICSTAT_VERSION \")\\n\"\n\t    \"         -i interface       # track interface only\\n\"\n\t    \"         -n                 # show non-local interfaces only\"\n\t\t\t\t\t\" (exclude lo0)\\n\"\n\t    \"         -s                 # summary output\\n\"\n\t    \"         -x                 # extended output\\n\"\n\t    \"         -p                 # parseable output\\n\"\n\t    \"         -z                 # skip zero value lines\\n\"\n\t    \"         -t                 # show TCP statistics\\n\"\n\t    \"         -u                 # show UDP statistics\\n\"\n\t    \"         -a                 # equivalent to \\\"-x -u -t\\\"\\n\"\n\t    \"         -l                 # list interface(s)\\n\"\n\t    \"         -M                 # output in Mbits/sec\\n\"\n\t    \"         -U                 # separate %%rUtil and %%wUtil\\n\"\n#ifdef OS_LINUX\n\t    \"         -S int:mbps[fd|hd] # tell nicstat the interface\\n\"\n\t    \"                            # speed (Mbits/sec) and duplex\\n\"\n#endif\n\t    \"    eg,\\n\");\n\t(void) fprintf(stderr,\n\t    \"       nicstat              # print summary since boot only\\n\"\n\t    \"       nicstat 1            # print every 1 second\\n\"\n\t    \"       nicstat 1 5          # print 5 times only\\n\"\n\t    \"       nicstat -z 1         # print every 1 second, skip zero\"\n\t\t\t\t\t\" lines\\n\"\n\t    \"       nicstat -i hme0 1    # print hme0 only every 1 second\\n\");\n\texit(1);\n}\n\n/*\n * new_string - simply strdup(3), but terminate on failure\n */\nstatic char *\nnew_string(char *s)\n{\n\tchar *new;\n\n\tnew = strdup(s);\n\tif (! new)\n\t\tdie(1, \"strdup\", g_progname);\n\treturn (new);\n}\n\n/*\n * allocate() - calloc(3) - for zeroing, plus error handling\n */\nstatic inline void *\nallocate(size_t bytes)\n{\n\tvoid *p;\n\n\tp = calloc(1, bytes);\n\tif (p == NULL)\n\t\tdie(1, \"calloc\");\n\treturn (p);\n}\n\n/*\n * Return floating difference in timevals\n */\nstatic double\ntv_diff(struct timeval *new, struct timeval *old)\n{\n\tdouble new_d, old_d;\n\n\tnew_d = (double)new->tv_sec;\n\tnew_d += new->tv_usec / 1000000.0;\n\told_d = (double)old->tv_sec;\n\told_d += old->tv_usec / 1000000.0;\n\treturn (new_d - old_d);\n}\n\n/*\n * if_is_ignored - return true if interface is to be ignored\n */\nstatic int\nif_is_ignored(char *if_name)\n{\n\tchar **p;\n\n\tif (! g_someif)\n\t\treturn (B_FALSE);\n\tfor (p = g_tracked; *p; p++)\n\t\tif (streql(if_name, *p))\n\t\t\treturn (B_FALSE);\n\treturn (B_TRUE);\n}\n\n#ifdef OS_SOLARIS\n/*\n * Check interface list to see if an interface is in it\n */\nstatic int\ninterface_in_list(char *interface, nicdata_t *nicp)\n{\n\twhile (nicp) {\n\t\tif (streql(interface, nicp->name))\n\t\t\treturn (B_TRUE);\n\t\tnicp = nicp->next;\n\t}\n\treturn (B_FALSE);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * reclaim_nicdata - reclaim's a struct nicdata * from our global list\n *\n * Return a struct nicdata pointer; if it is found in the global list; and\n * also remove it from the list (we are in the process of re-building the\n * list).  Modifies g_nicdatap.\n */\nstatic struct nicdata *\nreclaim_nicdata(char *if_name)\n{\n\tstruct nicdata *matchp, *prevp;\n\n\tprevp = NULL;\n\tfor (matchp = g_nicdatap; matchp; matchp = matchp->next) {\n\t\tif (streql(matchp->name, if_name)) {\n\t\t\t/* Got a match */\n\t\t\tif (prevp)\n\t\t\t\t/* Splice head of list to tail of list */\n\t\t\t\tprevp->next = matchp->next;\n\t\t\telse\n\t\t\t\t/* We are at the head */\n\t\t\t\tg_nicdatap = matchp->next;\n\t\t\t/* Disassociate match with the tail of the list */\n\t\t\tmatchp->next = NULL;\n\t\t\treturn (matchp);\n\t\t}\n\t\tprevp = matchp;\n\t}\n\treturn (NULL);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * fetch64 - return a uint64_t value from kstat.\n *\n * The arguments are a kstat pointer, the value name,\n * and a default value in case the lookup fails.\n */\nstatic uint64_t\nfetch64(kstat_t *ksp, char *value64, uint64_t def)\n{\n\tkstat_named_t *knp;\t/* Kstat named pointer */\n\n\t/* try a lookup and return */\n\tif ((knp = kstat_data_lookup(ksp, value64)) != NULL)\n\t\t/* Rely on C type conversion to promote smaller size values */\n\t\tswitch (knp->data_type) {\n\t\tcase KSTAT_DATA_INT32:\n\t\t\treturn (knp->value.i32);\n\t\t\t/*NOTREACHED*/\n\t\tcase KSTAT_DATA_UINT32:\n\t\t\treturn (knp->value.ui32);\n\t\t\t/*NOTREACHED*/\n\t\tcase KSTAT_DATA_INT64:\n\t\t\treturn (knp->value.i64);\n\t\t\t/*NOTREACHED*/\n\t\tcase KSTAT_DATA_UINT64:\n\t\t\treturn (knp->value.ui64);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\treturn (def);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * fetch32 - return a uint32_t value from kstat.\n *\n * The arguments are a kstat pointer, the value name,\n * and a default value in case the lookup fails.\n */\nstatic uint32_t\nfetch32(kstat_t *ksp, char *value, uint32_t def)\n{\n\tkstat_named_t *knp;\t/* Kstat named pointer */\n\n\t/* try a lookup and return */\n\tif ((knp = kstat_data_lookup(ksp, value)) != NULL)\n\t\treturn (knp->value.ui32);\n\treturn (def);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * fetch6432 - return a uint64_t or a uint32_t value from kstat.\n *\n * The arguments are a kstat pointer, a potential ui64 value name,\n * a potential ui32 value name, and a default value in case both\n * lookup fails. The ui64 value is attempted first.\n */\nstatic uint64_t\nfetch6432(kstat_t *ksp, char *value64, char *value, uint64_t def)\n{\n\tkstat_named_t *knp;\t/* Kstat named pointer */\n\n\t/* try lookups and return */\n\tif ((knp = kstat_data_lookup(ksp, value64)) != NULL)\n\t\treturn (knp->value.ui64);\n\tif ((knp = kstat_data_lookup(ksp, value)) != NULL)\n\t\treturn (knp->value.ui32);\n\treturn (def);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * fetch_nocanput - return nocanput value, whose name(s) are driver-dependent.\n *\n * Most drivers have a kstat \"nocanput\", but the ce driver\n * at least has \"rx_nocanput\" and \"tx_nocanput\"\n */\nstatic uint32_t\nfetch_nocanput(kstat_t *ksp, uint32_t def)\n{\n\tkstat_named_t *knp;\t/* Kstat named pointer */\n\tuint32_t sum;\n\n\t/* These should go in order of decreasing prevalence */\n\tif ((knp = kstat_data_lookup(ksp, \"norcvbuf\")) != NULL)\n\t\treturn (knp->value.ui32);\n\tif ((knp = kstat_data_lookup(ksp, \"nocanput\")) != NULL)\n\t\treturn (knp->value.ui32);\n\tif ((knp = kstat_data_lookup(ksp, \"rx_nocanput\")) != NULL) {\n\t\tsum = knp->value.ui32;\n\t\tif ((knp = kstat_data_lookup(ksp, \"tx_nocanput\"))\n\t\t    != NULL) {\n\t\t\tsum += knp->value.ui32;\n\t\t\treturn (sum);\n\t\t}\n\t}\n\treturn (def);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\n/*\n * fetch_boot_time - return the boot time in secs.\n *\n * This takes a kstat control pointer and looks up the boot time\n * from unix:0:system_misc:boot:time. If found, this is returned,\n * else 0.\n */\nstatic time_t\nfetch_boot_time()\n{\n\tkstat_t *ksp;\t\t\t/* Kstat struct pointer */\n\tkstat_named_t *knp;\t\t/* Kstat named pointer */\n\tstatic time_t boot_time = 0;\t/* Cache it if we can */\n\n\tif (boot_time != 0)\n\t\treturn (boot_time);\n\tif ((ksp = kstat_lookup(g_kc, \"unix\", 0, \"system_misc\")) == NULL)\n\t\tdie(1, \"kstat_lookup: unix:0:system_misc\");\n\tif ((kstat_read(g_kc, ksp, NULL) != -1) &&\n\t    ((knp = kstat_data_lookup(ksp, \"boot_time\")) != NULL))\n\t\t/* summary since boot */\n\t\tboot_time = knp->value.ui32;\n\t/* This will be zero if kstat_data_lookup() failed */\n\treturn (boot_time);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\n/*\n * fetch_boot_time - return the boot time in secs.\n *\n * Gets the boot time from /proc.\n */\nstatic unsigned long\nfetch_boot_time()\n{\n\tchar buf[64];\n\tint uptime_fd, bufsiz, scanned;\n\tunsigned long uptime;\n\n\tuptime_fd = open(PROC_UPTIME, O_RDONLY, 0);\n\tif (uptime_fd < 0)\n\t\tdie(1, \"error opening %s for read\", PROC_UPTIME);\n\tbufsiz = read(uptime_fd, buf, sizeof (buf) - 1);\n\tif (bufsiz < 0)\n\t\tdie(1, \"read: %s\", PROC_UPTIME);\n\tbuf[bufsiz] = '\\0';\n\tscanned = sscanf(buf, \"%lu.\", &uptime);\n\tif (scanned != 1)\n\t\tdie(0, \"cannot get uptime from %s\", PROC_UPTIME);\n\treturn (time(0) - uptime);\n}\n#endif /* OS_LINUX */\n\n#ifdef OS_SOLARIS\nstatic if_list_t *g_getif_list = NULL;\t/* Used by the lifc & dladm routines */\n\nstatic if_list_t *\nget_if_list_lifc(if_list_t *p)\n{\n\tif_list_t *newp, *headp;\n\tstruct lifnum if_num;\t\t/* Includes # of if's */\n\tstruct lifconf if_conf;\t\t/* Includes ptr to list of names */\n\n\tstatic struct ifreq *current_lif = (struct ifreq *)NULL;\n\tstruct lifreq *if_reqp, req;\n\tint lif_size, lif_count, i;\n\n\theadp = p;\n\n\t/* Get number of interfaces on system */\n\tif_num.lifn_family = AF_UNSPEC;\n\tif_num.lifn_flags = LIFC_NOXMIT | LIFC_ALLZONES | LIFC_UNDER_IPMP\n\t\t| LIFC_ENABLED;\n\tif (ioctl(g_sock, SIOCGLIFNUM, &if_num) < 0)\n\t\tdie(1, \"ioctl(IFNUM)\");\n\n\t/* Allocate my struct ifreq array buffer */\n\tlif_size = (if_num.lifn_count + 1) * sizeof (struct lifreq);\n\tcurrent_lif = realloc(current_lif, lif_size);\n\tif (! current_lif)\n\t\tdie(1, \"realloc\");\n\n\t/* Get the current interface list via the ioctl() */\n\tif_conf.lifc_family = AF_UNSPEC;\n\tif_conf.lifc_flags = if_num.lifn_flags;\n\tif_conf.lifc_len = lif_size;\n\tif_conf.lifc_buf = (caddr_t)current_lif;\n\tif (ioctl(g_sock, SIOCGLIFCONF, &if_conf) < 0)\n\t\tdie(1, \"ioctl(IFCONF)\");\n\tlif_size = if_conf.lifc_len;\n\tlif_count = if_conf.lifc_len / sizeof (struct lifreq);\n\n\t/*\n\t * Loop through entries in lifc_req, making a list of interfaces\n\t */\n\tif_reqp = if_conf.lifc_req;\n\t(void) memset((void *) &req, 0, sizeof (struct lifreq));\n\tfor (i = lif_count; i; i--, if_reqp++) {\n\t\t/* Skip virtual IP's */\n\t\tif (strchr(if_reqp->lifr_name, ':'))\n\t\t\tcontinue;\n\t\t(void) strlcpy(req.lifr_name, if_reqp->lifr_name, LIFNAMSIZ);\n\n\t\t/*\n\t\t * Skip interface if \"-i\" was used, and it is not\n\t\t * a matching interface\n\t\t */\n\t\tif (if_is_ignored(if_reqp->lifr_name))\n\t\t\tcontinue;\n\n\t\t/* Add to list */\n\t\tif (p->name) {\n\t\t\t/* Need new tail */\n\t\t\tnewp = allocate(sizeof (if_list_t));\n\t\t\tp->next = newp;\n\t\t\tp = newp;\n\t\t}\n\t\tp->name = new_string(if_reqp->lifr_name);\n\t}\n\treturn (headp);\n}\n#endif\t/* OS_SOLARIS */\n\n#ifdef USE_DLADM\n/*\n * dladm_callback - Function called by dladm_walk_datalink_id() for each\n * link.\n */\n/* ARGSUSED */\nstatic int\ndladm_callback(dladm_handle_t dh, datalink_id_t linkid, void *arg)\n{\n\tdladm_status_t\t\tstatus;\n\tchar\t\t\tlink[MAXLINKNAMELEN];\n\tdatalink_class_t\tclass;\n\tuint_t\t\t\tmtu;\n\tuint32_t\t\tflags;\n\tstruct if_list\t\t*p, *newp;\n\n\tif ((status = dladm_datalink_id2info(g_handle, linkid, &flags, &class,\n\t    NULL, link, sizeof (link))) != DLADM_STATUS_OK) {\n\t\treturn (status);\n\t}\n\n\t/*\n\t * Skip interface if \"-i\" was used, and it is not\n\t * a matching interface\n\t */\n\tif (if_is_ignored(link))\n\t\treturn (DLADM_WALK_CONTINUE);\n\n\tp = g_getif_list;\n\tif (p->name) {\n\t\t/* Need new tail */\n\t\tnewp = allocate(sizeof (struct if_list));\n\t\tp->next = newp;\n\t\tp = newp;\n\t\tg_getif_list = newp;\n\t}\n\tp->name = new_string(link);\n\treturn (DLADM_WALK_CONTINUE);\n}\n\n/*\n * Get the current list of interfaces\n */\nstatic struct if_list *\nget_if_list_dl(if_list_t *p)\n{\n\tuint32_t flags = DLADM_OPT_ACTIVE;\n\n\t/* Start with \"lo0\" unless it is ignored */\n\tif (! g_nonlocal && (! if_is_ignored(\"lo0\"))) {\n\t\tp->name = new_string(\"lo0\");\n\t\tp->next = (struct if_list *)NULL;\n\t}\n\n\t/* dladm_callback() will append entries to g_getif_list */\n\tg_getif_list = p;\n\t(void) dladm_walk_datalink_id(dladm_callback, g_handle,\n\t    NULL, DATALINK_CLASS_ALL, DATALINK_ANY_MEDIATYPE,\n\t    flags);\n\n\treturn (g_getif_list = p);\n}\n#endif\t/* USE_DLADM */\n\n#ifdef OS_SOLARIS\n/*\n * Get the list from kstats, looking for one of:\n *\n *\tClass\t4-tuple\n *\t=====\t=======\n *\tnet\tlink::<ifname>:link_state\n *\tnet\t<drv>:<inst>:mac:link_state\n *\tmac\t<ifname>::<ifname>/xx:link_state\n *\n * with a value of \"1\".\n *\n * This is only useful on S10 or newer; where interfaces given\n * exclusively to non-global zones may not be visible via\n * get_if_list_lifc(); and where USE_DLADM is not available.\n */\nstatic if_list_t *\nget_if_list_kstat(if_list_t *p)\n{\n\tif_list_t *newp, *headp;\n\tkstat_t *ksp;\n\tkstat_named_t *knp;\n\tchar ifname[MAXLINKNAMELEN];\n\tchar *namep;\n\n\theadp = p;\n\n\t/* Start with \"lo0\" unless it is ignored */\n\tif (! g_nonlocal && (! if_is_ignored(\"lo0\"))) {\n\t\tp->name = new_string(\"lo0\");\n\t\tp->next = (struct if_list *)NULL;\n\t}\n\n\tfor (ksp = g_kc->kc_chain; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (ksp->ks_type != KSTAT_TYPE_NAMED)\n\t\t\tcontinue;\n\t\tif (streql(ksp->ks_class, \"net\")) {\n\t\t\tif (streql(ksp->ks_module, \"link\")) {\n\t\t\t\tnamep = ksp->ks_name;\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tif (streql(ksp->ks_name, \"mac\")) {\n\t\t\t\t(void) sprintf(ifname, \"%s%u\", ksp->ks_module,\n\t\t\t\t\tksp->ks_instance);\n\t\t\t\tnamep = ifname;\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (streql(ksp->ks_class, \"mac\")) {\n\t\t\tnamep = ksp->ks_module;\n\t\t\tgoto lookup;\n\t\t}\n\t\tcontinue;\n\n\tlookup:\n\t\tif (kstat_read(g_kc, ksp, NULL) < 0)\n\t\t\tdie(1, \"kstat_read\");\n\t\tif (! (knp = kstat_data_lookup(ksp, \"link_state\")))\n\t\t\tcontinue;\n\t\t/* We have a \"link_state\" */\n\t\tif (knp->data_type != KSTAT_DATA_UINT32)\n\t\t\tcontinue;\n\t\tif (knp->value.ui32 != 1)\n\t\t\tcontinue;\n\n\t\t/* We have a value of 1 - link is UP */\n\t\tif (if_is_ignored(ifname))\n\t\t\tcontinue;\n\n\t\t/* Add to list */\n\t\tif (p->name) {\n\t\t\t/* Need new tail */\n\t\t\tnewp = allocate(sizeof (if_list_t));\n\t\t\tp->next = newp;\n\t\t\tp = newp;\n\t\t}\n\t\tp->name = new_string(namep);\n\t}\n\treturn (headp);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\nstatic if_list_t *\nget_if_list()\n{\n\t/* Free g_getif_list if needed */\n\tif (g_getif_list) {\n\t\tstruct if_list *p, *next;\n\n\t\tfor (p = g_getif_list; p; ) {\n\t\t\tnext = p->next;\n\t\t\tif (p->name)\n\t\t\t\tfree(p->name);\n\t\t\tfree(p);\n\t\t\tp = next;\n\t\t}\n\t}\n\n\t/* Allocate new g_getif_list */\n\tg_getif_list = allocate(sizeof (if_list_t));\n\n\tif (g_opt_k)\n\t\treturn (get_if_list_kstat(g_getif_list));\n#ifdef USE_DLADM\n\tif (g_use_dladm)\n\t\treturn (get_if_list_dl(g_getif_list));\n#endif\n\treturn (get_if_list_lifc(g_getif_list));\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_SOLARIS\nstatic LIFR_FLAGS_TYPE\nget_lif_flags(char *if_name)\n{\n\tstruct lifreq req;\n\n\t(void) strlcpy(req.lifr_name, if_name, LIFNAMSIZ);\n\tif (ioctl(g_sock, SIOCGLIFINDEX, &req) == -1) {\n\t\treturn (0);\n\t}\n\tif (ioctl(g_sock, SIOCGLIFFLAGS, &req) == -1) {\n\t\treturn (0);\n\t}\n\treturn (req.lifr_flags);\n}\n\n/*\n * split_ifname()\n *\n * Splits interface names like \"bge0\", \"e1000g7001\" into driver/module name\n * and instance number.  The instance number is the largest set of trailing\n * digits.\n */\nstatic int\nsplit_ifname(char *if_name, char *drv, uint32_t *instance)\n{\n\tchar *p;\n\tint n, m;\n\n\tn = 0;\n\tfor (p = if_name; *p; p++)\n\t\tn++;\n\tif (n <= 1)\n\t\treturn (B_FALSE);\n\tm = n;\n\tfor (p--; isdigit(*p); p--)\n\t\tn--;\n\tif (m == n || n == 0)\n\t\treturn (B_FALSE);\n\t(void) strncpy(drv, if_name, n);\n\tdrv[n] = '\\0';\n\t*instance = (uint32_t)atol(++p);\n\treturn (B_TRUE);\n}\n\n/*\n * OUTPUTS\n *\tnic->ls_ksp\n *\tnic->op_ksp\n *\tnic->flags (NIC_KS_UP bit)\n */\nstatic nicdata_t *\ndiscover_kstats(char *if_name, nicdata_t *nic)\n{\n\tuint32_t if_instance;\n\tkstat_t *ksp;\n\tkstat_named_t *knp;\n\tint ks_link_state;\t/* :::link_state */\n\tint ks_opackets;\t/* :::opackets */\n\tint ks_link_module;\t/* link::: */\n\tint ks_drv_module;\t/* <drv>::: */\n\tint ks_ifname_module;\t/* <ifname>::: */\n\tuint32_t n;\n\tuint32_t ttype;\n\tchar if_drv[MAXLINKNAMELEN];\n\n\tif (! split_ifname(if_name, if_drv, &if_instance))\n\t\tdie(0, \"%s: %s: invalid interface name\\n\", g_progname,\n\t\t\tif_name);\n\n\tnic->ls_ksp = NULL;\n\tnic->op_ksp = NULL;\n\tfor (ksp = g_kc->kc_chain; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (ksp->ks_type != KSTAT_TYPE_NAMED)\n\t\t\tcontinue;\n\t\tif (strcmp(ksp->ks_class, \"net\") != 0)\n\t\t\tcontinue;\n\n\t\tks_link_module = ks_drv_module = ks_ifname_module = B_FALSE;\n\t\tif (streql(ksp->ks_module, \"link\"))\n\t\t\tks_link_module = B_TRUE;\n\t\telse if (streql(ksp->ks_module, if_drv) &&\n\t\t    (ksp->ks_instance == if_instance))\n\t\t\tks_drv_module = B_TRUE;\n\t\telse if (streql(ksp->ks_module, if_name))\n\t\t\tks_ifname_module = B_TRUE;\n\t\telse\n\t\t\tcontinue;\n\n\t\t/* We have [link:::], [<drv>:<instance>::] or [<ifname>:::] */\n\n\t\t(void) kstat_read(g_kc, ksp, NULL);\n\t\tknp = KSTAT_NAMED_PTR(ksp);\n\t\tfor (n = 0; n < ksp->ks_ndata; n++, knp++) {\n\t\t\tks_link_state = B_FALSE;\n\t\t\tks_opackets = B_FALSE;\n\t\t\tif (streql(knp->name, \"link_state\"))\n\t\t\t\tks_link_state = B_TRUE;\n\t\t\telse if (streql(knp->name, \"opackets\"))\n\t\t\t\tks_opackets = B_TRUE;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\t/* knp is one of our desired statistics */\n\t\t\tif (ks_link_module) {\n\t\t\t\tif (streql(ksp->ks_name, if_name)) {\n\t\t\t\t\tttype = KS_LINK;\n\t\t\t\t\tif (ks_link_state)\n\t\t\t\t\t\tgoto set_ls_kstat;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto set_op_kstat;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ks_drv_module &&\n\t\t\t    (ksp->ks_instance == if_instance)) {\n\t\t\t\tif (streql(ksp->ks_name, \"mac\")) {\n\t\t\t\t\tttype = KS_DRV_MAC;\n\t\t\t\t\tif (ks_link_state)\n\t\t\t\t\t\tgoto set_ls_kstat;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto set_op_kstat;\n\t\t\t\t} else if (streql(ksp->ks_name, if_name)) {\n\t\t\t\t\tttype = KS_DIN;\n\t\t\t\t\tif (ks_link_state)\n\t\t\t\t\t\tgoto set_ls_kstat;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto set_op_kstat;\n\t\t\t\t} else {\n\t\t\t\t\tttype = KS_DRV;\n\t\t\t\t\tif (ks_link_state)\n\t\t\t\t\t\tgoto set_ls_kstat;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto set_op_kstat;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ks_ifname_module) {\n\t\t\t\tttype = KS_NAME;\n\t\t\t\tif (ks_link_state)\n\t\t\t\t\tgoto set_ls_kstat;\n\t\t\t\telse\n\t\t\t\t\tgoto set_op_kstat;\n\t\t\t}\n\n\t\tset_ls_kstat:\n\t\t\tif (ttype > nic->ls_types) {\n\t\t\t\tnic->ls_ksp = ksp;\n\t\t\t\tif (knp->value.ui32 == 1)\n\t\t\t\t\tnic->flags |= NIC_KS_UP;\n\t\t\t\tnic->flags |= (NIC_LK_UPDATED |\n\t\t\t\t\tNIC_KU_UPDATED);\n\t\t\t}\n\t\t\tnic->ls_types |= ttype;\n\t\t\tcontinue;\n\n\t\tset_op_kstat:\n\t\t\tif (ttype > nic->op_types) {\n\t\t\t\tnic->op_ksp = ksp;\n\t\t\t\tnic->flags |= NIC_OK_UPDATED;\n\t\t\t}\n\t\t\tnic->op_types |= ttype;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (nic->ls_ksp == NULL) {\n\t\tnic->flags |= NIC_NO_LINKSTATE;\n\t\tif (nic->op_ksp == NULL)\n\t\t\tnic->flags |= NIC_NO_KSTATS;\n\t} else if (nic->ls_ksp == nic->op_ksp)\n\t\tnic->flags |= NIC_LK_IS_OK;\n\treturn (nic);\n}\n\nstatic kstat_t *\nfetch_ksp(char *module, uint32_t instance, char *name)\n{\n\tkstat_t *ksp;\n\n\tksp = kstat_lookup(g_kc, module, instance, name);\n\tif (! ksp)\n\t\tdie(1, \"kstat_lookup (\\\"%s:%u:%s\\\")\", module, instance, name);\n\tif (kstat_read(g_kc, ksp, NULL) == -1)\n\t\tdie(1, \"kstat_read (\\\"%s:%u:%s\\\")\", module, instance, name);\n\treturn (ksp);\n}\n\nstatic void\nupdate_ksp_by_type(kstat_t **kspp, uint32_t types, char *name)\n{\n\tchar drv[MAXLINKNAMELEN];\n\tuint32_t instance;\n\n\tif (*kspp && (! g_new_kstat_chain))\n\t\treturn;\n\n\t/* Need to get new ksp */\n\tif (types & KS_LINK) {\n\t\t*kspp = fetch_ksp(\"link\", 0, name);\n\t\treturn;\n\t}\n\t(void) split_ifname(name, drv, &instance);\n\tif (types & KS_DRV_MAC) {\n\t\t*kspp = fetch_ksp(drv, instance, \"mac\");\n\t\treturn;\n\t}\n\tif (types & KS_DIN) {\n\t\t*kspp = fetch_ksp(drv, instance, name);\n\t\treturn;\n\t}\n\tif (types & KS_DRV) {\n\t\t*kspp = fetch_ksp(drv, instance, NULL);\n\t\treturn;\n\t}\n\tif (types & KS_NAME) {\n\t\t*kspp = fetch_ksp(name, -1, NULL);\n\t\treturn;\n\t}\n\tdie(0, \"types = 0x%08x\", types);\n}\n\nstatic void\nupdate_linkstate(nicdata_t *nicp)\n{\n\tkstat_named_t *knp;\n\n\tknp = kstat_data_lookup(nicp->ls_ksp, \"link_state\");\n\tif (! knp)\n\t\tdie(1, \"kstat_data_lookup(\\\"link_state\\\")\");\n\tif (knp->value.ui32 == 1)\n\t\tnicp->flags |= NIC_KS_UP;\n\telse\n\t\tnicp->flags &= ~NIC_KS_UP;\n\tnicp->flags |= NIC_KU_UPDATED;\n}\n\n/*\n * update_nicdata_list - update global linked list of nic data\n *\n *\tget current list of nics\n *\tforeach (current nic)\n *\t\treclaim nicdata from g_nicdatap\n *\t\tif (ioctl available)\n *\t\t\tupdate NIC_IF_UP\n *\t\telse\n *\t\t\tupdate NIC_KS_UP\n *\t\tif (iface is up)\n *\t\t\tif (iface is new || kstat chain updated)\n *\t\t\t\tupdate kstat pointers\n *\t\tadd current nic to new list\n *\tfree any remaining on old list\n */\nstatic void\nupdate_nicdata_list()\n{\n\tstruct nicdata *nicp, *new_nicdatap, *old_nicdatap;\n\tstruct nicdata *new_headp, *new_tailp;\n\tstruct if_list *if_listp, *ifp;\n\tLIFR_FLAGS_TYPE if_flags;\n\tuint32_t new_nics;\n\n\tif_listp = get_if_list();\n\n\tnew_headp = NULL;\n\tnew_tailp = NULL;\n\tnew_nics = 0;\n\t/* Outer loop - if_listp */\n\tfor (ifp = if_listp; ifp && ifp->name; ifp = ifp->next) {\n\t\tif (interface_in_list(ifp->name, new_headp))\n\t\t\t/* Seen it */\n\t\t\tcontinue;\n\t\tnicp = reclaim_nicdata(ifp->name);\n\t\tif (! nicp) {\n\t\t\t/* Was not previously known */\n\t\t\tnicp = allocate(sizeof (nicdata_t));\n\t\t\tnicp->name = new_string(ifp->name);\n\t\t\tif_flags = get_lif_flags(ifp->name);\n\t\t\tif (if_flags == 0) {\n\t\t\t\tnicp->flags |= NIC_NO_GLIFFLAGS;\n\t\t\t} else {\n\t\t\t\tif (if_flags & IFF_UP)\n\t\t\t\t\tnicp->flags |= NIC_LIF_UP;\n\t\t\t\tnicp->flags |= NIC_LU_UPDATED;\n\t\t\t\tif (if_flags & IFF_LOOPBACK)\n\t\t\t\t\tnicp->flags |= NIC_LOOPBACK;\n\t\t\t}\n\t\t\tif (! discover_kstats(ifp->name, nicp))\n\t\t\t\tnicp->flags |= NIC_NO_KSTATS;\n\t\t} else {\n\t\t\t/* Assume state is now out of date */\n\t\t\tnicp->flags &= ~(NIC_UPDATED_FLAGS);\n\t\t}\n\n\t\t/* Add to new_nicdatap */\n\t\tif (new_tailp)\n\t\t\tnew_tailp->next = nicp;\n\t\telse\n\t\t\tnew_headp = nicp;\n\t\tnew_tailp = nicp;\n\n\t\tif (g_nonlocal && (nicp->flags & NIC_LOOPBACK))\n\t\t\tcontinue;\n\n\t\t/* Update UP/DOWN */\n\t\tif (nicp->flags & NIC_NO_GLIFFLAGS) {\n\t\t\tif ((nicp->flags & NIC_NO_KSTATS) ||\n\t\t\t    (nicp->flags & NIC_NO_LINKSTATE))\n\t\t\t\t/* We will never know */\n\t\t\t\tcontinue;\n\t\t\telse if (! (nicp->flags & NIC_LK_UPDATED)) {\n\t\t\t\tupdate_ksp_by_type(&(nicp->ls_ksp),\n\t\t\t\t\tnicp->ls_types, nicp->name);\n\t\t\t\tupdate_linkstate(nicp);\n\t\t\t\tnicp->flags |= (NIC_LK_UPDATED |\n\t\t\t\t\tNIC_KU_UPDATED);\n\t\t\t}\n\t\t} else {\n\t\t\tif (! (nicp->flags & NIC_LU_UPDATED)) {\n\t\t\t\tif_flags = get_lif_flags(ifp->name);\n\t\t\t\tif (if_flags & IFF_UP)\n\t\t\t\t\tnicp->flags |= NIC_LIF_UP;\n\t\t\t\telse\n\t\t\t\t\tnicp->flags &= ~NIC_LIF_UP;\n\t\t\t\tnicp->flags |= NIC_LU_UPDATED;\n\t\t\t}\n\t\t}\n\t\tif (! (nicp->flags & NIC_UP))\n\t\t    /* IF is down */\n\t\t\tif (! g_list)\n\t\t\t\tcontinue;\n\t\tnew_nics++;\n\t}\n\tg_nicdata_count = new_nics;\n\n\t/* Clean up any left in the old list */\n\tfor (new_nicdatap = g_nicdatap; new_nicdatap; ) {\n\t\told_nicdatap = new_nicdatap;\n\t\tnew_nicdatap = new_nicdatap->next;\n\t\tfree(old_nicdatap->name);\n\t\tfree(old_nicdatap);\n\t}\n\n\t/* Save the new list we just built in our global pointer */\n\tg_nicdatap = new_headp;\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\n/*\n * find_nicdatap - find a struct nicdata * from linked list\n *\n * We search the linked list starting from *lastp (or *headp if *lastp\n * is NULL).  All entries are searched until either:\n *\n * - matching if_name found, and we return the struct pointer\n *\n * - no match, so we initialise a new struct, add to the end of\n *   the list (or after *lastp if non-null) and return a pointer to it\n *\n * SIDE EFFECT - *lastp is always set to a pointer to the\n * matched (or newly-created) struct.  This allows an efficient\n * sequential update of the list.\n */\n\nenum search_state {HEAD, LAST, LAST_LOOPED};\n\nstatic struct nicdata *\nfind_nicdatap(struct nicdata **headp, struct nicdata **lastp, char *if_name)\n{\n\tstruct nicdata *prevp, *p;\n\tenum search_state state;\n\n\tprevp = NULL;\n\n\tif (*lastp && (*lastp)->next) {\n\t\tstate = LAST;\n\t\tp = (*lastp)->next;\n\t} else {\n\t\tstate = HEAD;\n\t\tp = *headp;\n\t}\n\twhile (p) {\n\t\t/* Check for a match */\n\t\tif (streql(p->name, if_name)) {\n\t\t\t/* We have a match */\n\t\t\t*lastp = p;\n\t\t\treturn (p);\n\t\t}\n\t\tprevp = p;\n\t\tp = p->next;\n\t\tif (p == NULL) {\n\t\t\tswitch (state) {\n\t\t\tcase HEAD:\n\t\t\tcase LAST_LOOPED:\n\t\t\t\t/* Will terminate loop */\n\t\t\t\tbreak;\n\t\t\tcase LAST:\n\t\t\t\t/* Start from head */\n\t\t\t\tstate = LAST_LOOPED;\n\t\t\t\tp = *headp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tif (state == LAST_LOOPED &&\n\t\t\t    p == *lastp)\n\t\t\t\t/* No match */\n\t\t\t\tbreak;\n\t}\n\n\t/* We get here if we have no match */\n\tp = allocate(sizeof (struct nicdata));\n\tp->name = new_string(if_name);\n\n\tif (state == HEAD) {\n\t\t/* prevp will point to the last struct in the list */\n\t\tif (prevp)\n\t\t\tprevp->next = p;\n\t\telse\n\t\t\t*headp = p;\n\t} else {\n\t\t/* Insert new entry after **lastp */\n\t\tprevp = (*lastp)->next;\n\t\t(*lastp)->next = p;\n\t\tp->next = prevp;\n\t}\n\n\t*lastp = p;\n\treturn (p);\n}\n#endif /* OS_LINUX */\n\n#ifdef OS_LINUX\nstatic int\nfind_interface_speed(struct nicdata *nicp)\n{\n\tstruct if_speed_list\t*if_speed_list_ptr;\n\n\tif_speed_list_ptr = g_if_speed_list;\n\n\twhile (if_speed_list_ptr != NULL) {\n\t\tif (streql(nicp->name, if_speed_list_ptr->name)) {\n\t\t\tnicp->speed = if_speed_list_ptr->speed;\n\t\t\tnicp->duplex = if_speed_list_ptr->duplex;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t\tif_speed_list_ptr = if_speed_list_ptr->next;\n\t}\n\tnicp->speed = 0;\n\tnicp->duplex = DUPLEX_UNKNOWN;\n\treturn (B_FALSE);\n}\n#endif /* OS_LINUX */\n\n#ifdef OS_SOLARIS\n\n#define\tTCP_UPDATE(field, kstat_name)\t\\\n\tg_tcp_new->field = fetch64(g_tcp_ksp, kstat_name, 0);\n#define\tUDP_UPDATE(field, kstat_name)\t\\\n\tg_udp_new->field = fetch64(g_udp_ksp, kstat_name, 0);\n\n/*\n * update_stats - update stats for interfaces we are tracking\n */\nstatic void\nupdate_stats()\n{\n\tstruct nicdata *nicp;\n\tstruct timeval now_tv;\n\n\t(void) gettimeofday(&now_tv, NULL);\n\n\tif (g_tcp) {\n\t\t/* Update TCP stats */\n\t\tif (g_new_kstat_chain) {\n\t\t\tg_tcp_ksp = kstat_lookup(g_kc, \"tcp\", -1, \"tcp\");\n\t\t\tif (! g_tcp_ksp)\n\t\t\t\tdie(1, \"kstat_lookup\");\n\t\t}\n\t\tif (kstat_read(g_kc, g_tcp_ksp, NULL) < 0)\n\t\t\tdie(1, \"kstat_read\");\n\t\tg_tcp_new->tv.tv_sec = now_tv.tv_sec;\n\t\tg_tcp_new->tv.tv_usec = now_tv.tv_usec;\n\t\tTCP_UPDATE(inDataInorderSegs, \"inDataInorderSegs\");\n\t\tTCP_UPDATE(outDataSegs, \"outDataSegs\");\n\t\tTCP_UPDATE(inDataInorderBytes, \"inDataInorderBytes\");\n\t\tTCP_UPDATE(inDataUnorderSegs, \"inDataUnorderSegs\");\n\t\tTCP_UPDATE(inDataUnorderBytes, \"inDataUnorderBytes\");\n\t\tTCP_UPDATE(outDataBytes, \"outDataBytes\");\n\t\tTCP_UPDATE(estabResets, \"estabResets\");\n\t\tTCP_UPDATE(outRsts, \"outRsts\");\n\t\tTCP_UPDATE(attemptFails, \"attemptFails\");\n\t\tTCP_UPDATE(retransBytes, \"retransBytes\");\n\t\tTCP_UPDATE(passiveOpens, \"passiveOpens\");\n\t\tTCP_UPDATE(activeOpens, \"activeOpens\");\n\t\tTCP_UPDATE(halfOpenDrop, \"halfOpenDrop\");\n\t\tTCP_UPDATE(listenDrop, \"listenDrop\");\n\t\tTCP_UPDATE(listenDropQ0, \"listenDropQ0\");\n\t}\n\tif (g_udp) {\n\t\t/* Update UDP stats */\n\t\tif (g_new_kstat_chain) {\n\t\t\tg_udp_ksp = kstat_lookup(g_kc, \"udp\", -1, \"udp\");\n\t\t\tif (! g_udp_ksp)\n\t\t\t\tdie(1, \"kstat_lookup\");\n\t\t}\n\t\tif (kstat_read(g_kc, g_udp_ksp, NULL) < 0)\n\t\t\tdie(1, \"kstat_read\");\n\t\tg_udp_new->tv.tv_sec = now_tv.tv_sec;\n\t\tg_udp_new->tv.tv_usec = now_tv.tv_usec;\n\t\tUDP_UPDATE(inDatagrams, \"inDatagrams\");\n\t\tUDP_UPDATE(outDatagrams, \"outDatagrams\");\n\t\tUDP_UPDATE(inErrors, \"inErrors\");\n\t\tUDP_UPDATE(outErrors, \"outErrors\");\n\t}\n\n\tif (g_style == STYLE_NONE && ! g_list)\n\t\treturn;\n\n\t/* Update interface stats */\n\tfor (nicp = g_nicdatap; nicp; nicp = nicp->next) {\n\t\tif (! (nicp->flags & NIC_UP))\n\t\t\t/* Link is not up */\n\t\t\tcontinue;\n\t\tif (g_nonlocal && (nicp->flags & NIC_LOOPBACK))\n\t\t\tcontinue;\n\t\tif (! (nicp->flags & NIC_OK_UPDATED))\n\t\t\tif (kstat_read(g_kc, nicp->op_ksp, NULL) < 0)\n\t\t\t\tdie(1, \"kstat_read\");\n\t\t/* Save network values */\n\t\tnicp->new.tv.tv_sec = now_tv.tv_sec;\n\t\tnicp->new.tv.tv_usec = now_tv.tv_usec;\n\t\tnicp->new.rbytes =\n\t\t\tfetch6432(nicp->op_ksp, \"rbytes64\", \"rbytes\", 0);\n\t\tnicp->new.wbytes =\n\t\t\tfetch6432(nicp->op_ksp, \"obytes64\", \"obytes\", 0);\n\t\tnicp->new.rpackets =\n\t\t\tfetch6432(nicp->op_ksp, \"ipackets64\", \"ipackets\", 0);\n\t\tnicp->new.wpackets =\n\t\t\tfetch6432(nicp->op_ksp, \"opackets64\", \"opackets\", 0);\n\t\tswitch (g_style) {\n\t\tcase STYLE_EXTENDED_PARSEABLE:\n\t\tcase STYLE_EXTENDED:\n\t\t\tnicp->new.ierr = fetch32(nicp->op_ksp, \"ierrors\", 0);\n\t\t\tnicp->new.oerr = fetch32(nicp->op_ksp, \"oerrors\", 0);\n\t\t\t/*FALLTHROUGH*/\n\t\tcase STYLE_FULL:\n\t\tcase STYLE_SUMMARY:\n\t\t\tnicp->new.coll = fetch32(nicp->op_ksp, \"collisions\",\n\t\t\t\t0);\n\t\t\tnicp->new.nocp = fetch_nocanput(nicp->op_ksp, 0);\n\t\t\tnicp->new.defer = fetch32(nicp->op_ksp, \"defer_xmts\",\n\t\t\t\t0);\n\t\t\tnicp->new.sat = nicp->new.defer + nicp->new.nocp +\n\t\t\t\tnicp->new.coll;\n\t\t\tnicp->new.sat += fetch32(nicp->op_ksp, \"noxmtbuf\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tnicp->speed = fetch64(nicp->op_ksp, \"ifspeed\", 0);\n\t\tnicp->duplex = fetch32(nicp->op_ksp, \"link_duplex\", 0);\n\t}\n\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\n/*\n * load_netstat() -\tReads PROC_NET_NETSTAT_PATH to get TCP stat(s)\n */\n\nstatic void\nload_netstat(FILE *netstat)\n{\n\tchar buf[2048];\n\tchar *p;\n\tint remaining;\n\tlong long ll[2];\n\n\tif (fseek(netstat, 0, SEEK_SET) != 0)\n\t\tdie(1, \"fseek: %s\", PROC_NET_NETSTAT_PATH);\n\tremaining = 1;\n\twhile (remaining) {\n\t\tp = fgets(buf, sizeof (buf), netstat);\n\t\tif (! p)\n\t\t\tbreak;\n\t\tif (g_tcp && strncmp(\"TcpExt: SyncookiesSent SyncookiesRecv \"\n\t\t    \"SyncookiesFailed EmbryonicRsts PruneCalled RcvPruned \"\n\t\t    \"OfoPruned OutOfWindowIcmps LockDroppedIcmps \"\n\t\t    \"ArpFilter TW TWRecycled TWKilled PAWSPassive \"\n\t\t    \"PAWSActive PAWSEstab DelayedACKs DelayedACKLocked \"\n\t\t    \"DelayedACKLost ListenOverflows ListenDrops \",\n\t\t    p, 273) == 0) {\n\t\t\t/* We are after field 20 and 21 */\n\t\t\tint n = fscanf(netstat, \"TcpExt: %*d %*d %*d \"\n\t\t\t\t\"%*d %*d %*d %*d %*d %*d %*d \"\n\t\t\t\t\"%*d %*d %*d %*d %*d %*d %*d \"\n\t\t\t\t\"%*d %*d %lld %lld \",\n\t\t\t\t&ll[0], &ll[1]);\n\t\t\tif (n == 2)\n\t\t\t\tg_tcp_new->listenDrop = ll[0] + ll[1];\n\t\t\tremaining--;\n\t\t}\n\t}\n}\n\n\n/*\n * load_snmp() -\tReads PROC_NET_SNMP_PATH to get TCP & UDP stats\n */\n\nstatic void\nload_snmp(FILE *snmp)\n{\n\tchar buf[2048];\n\tchar *p;\n\tint remaining;\n\tlong long ll[14];\n\n\t/* Load TCP and/or UDP stats from /proc/net/snmp */\n\tif (fseek(snmp, 0, SEEK_SET) != 0)\n\t\tdie(1, \"fseek: %s\", PROC_NET_SNMP_PATH);\n\tremaining = 0;\n\tif (g_tcp)\n\t\tremaining++;\n\tif (g_udp)\n\t\tremaining++;\n\twhile (remaining) {\n\t\tp = fgets(buf, sizeof (buf), snmp);\n\t\tif (! p)\n\t\t\tbreak;\n\t\tif (g_tcp && strncmp(\"Tcp: RtoAlgorithm RtoMin RtoMax MaxConn \"\n\t\t\t\t\"ActiveOpens PassiveOpens AttemptFails \"\n\t\t\t\t\"EstabResets CurrEstab InSegs OutSegs \"\n\t\t\t\t\"RetransSegs InErrs OutRsts\", p, 141) == 0) {\n\t\t\tint n;\n\t\t\tn = fscanf(snmp, \"Tcp: %lld %lld %lld %lld \"\n\t\t\t    \"%lld %lld %lld %lld %lld %lld \"\n\t\t\t    \"%lld %lld %lld %lld\\n\",\n\t\t\t    &ll[0], &ll[1], &ll[2], &ll[3],\n\t\t\t    &ll[4], &ll[5], &ll[6], &ll[7],\n\t\t\t    &ll[8], &ll[9], &ll[10], &ll[11],\n\t\t\t    &ll[12], &ll[13]);\n\t\t\tif (n == 14) {\n\t\t\t\tg_tcp_new->inDataInorderSegs = ll[9];\n\t\t\t\tg_tcp_new->outDataSegs = ll[10];\n\t\t\t\tg_tcp_new->estabResets = ll[7];\n\t\t\t\tg_tcp_new->outRsts = ll[13];\n\t\t\t\tg_tcp_new->attemptFails = ll[6];\n\t\t\t\t/* Note: bytes */\n\t\t\t\tg_tcp_new->retransBytes = ll[11];\n\t\t\t\tg_tcp_new->passiveOpens = ll[5];\n\t\t\t\tg_tcp_new->activeOpens = ll[4];\n\t\t\t}\n\t\t\tremaining--;\n\t\t} else if (g_udp && strncmp(\"Udp: InDatagrams NoPorts \"\n\t\t\t\t\"InErrors OutDatagrams RcvbufErrors \"\n\t\t\t\t\"SndbufErrors\\n\", p, 72) == 0) {\n\t\t\tint n;\n\t\t\tn = fscanf(snmp, \"Udp: %lld %lld %lld %lld \"\n\t\t\t    \"%lld %lld\\n\",\n\t\t\t    &ll[0], &ll[1], &ll[2], &ll[3],\n\t\t\t    &ll[4], &ll[5], &ll[6]);\n\t\t\tif (n == 6) {\n\t\t\t\tg_udp_new->inDatagrams = ll[0];\n\t\t\t\tg_udp_new->outDatagrams = ll[3];\n\t\t\t\tg_udp_new->inErrors = ll[2]; /* + ll[4]? */\n\t\t\t\tg_udp_new->outErrors = ll[5];\n\t\t\t}\n\t\t\tremaining--;\n\t\t}\n\t}\n}\n\n#endif /* OS_LINUX */\n\n#ifdef OS_LINUX\nstatic void\nget_speed_duplex(nicdata_t *nicp)\n{\n\tstruct ifreq ifr;\n\tstruct ethtool_cmd edata;\n\tint status;\n\n\tif (nicp->flags & NIC_NO_GSET) {\n\t\tif (nicp->speed > 0)\n\t\t\t/* Already got something */\n\t\t\treturn;\n\t\tif (nicp->flags & NIC_NO_SFLAG)\n\t\t\treturn;\n\t\tif (! find_interface_speed(nicp))\n\t\t\tnicp->flags |= NIC_NO_SFLAG;\n\t\treturn;\n\t}\n\n\t/* Try SIOCETHTOOL */\n\tstrncpy(ifr.ifr_name, nicp->name, sizeof (ifr.ifr_name));\n\tifr.ifr_data = (void *) &edata;\n\tedata.cmd = ETHTOOL_GSET;\n\tstatus = ioctl(g_sock, SIOCETHTOOL, &ifr);\n\tif (status < 0) {\n\t\tnicp->flags |= NIC_NO_GSET;\n\t\tget_speed_duplex(nicp);\n\t\treturn;\n\t}\n\tnicp->speed = edata.speed * 1000000;\n\tnicp->duplex = edata.duplex;\n}\n#endif /* OS_LINUX */\n\n#ifdef OS_LINUX\n\n/*\n * update_stats - update stats for interfaces we are tracking\n */\nstatic void\nupdate_stats(int net_dev)\n{\n\tstruct nicdata *nicp, *lastp;\n\tstruct timeval now_tv;\n\tstatic int validated_format = 0;\n\tstatic char proc_net_buffer[PROC_NET_BUFSIZ];\n\tchar *bufp;\n\tint bufsiz, buf_remain, ret, n, skip_to_newline;\n\tunsigned long long ll[16];\n\tchar if_name[32];\n\tint loopback;\n\n\t/*\n\t * Load PROC_NET_DEV\n\t */\n\tif (lseek(net_dev, 0, SEEK_SET) != 0)\n\t\tdie(1, \"lseek: %s\", PROC_NET_DEV_PATH);\n\tbufsiz = read(net_dev, (void *) proc_net_buffer,\n\t    sizeof (proc_net_buffer));\n\tif (bufsiz < 0)\n\t\tdie(1, \"read: %s\", PROC_NET_DEV_PATH);\n\telse if (bufsiz < 200)\n\t\tdie(0, \"%s: invalid format\\n\", PROC_NET_DEV_PATH);\n\n\t/*\n\t * Validate if we have not previously done so\n\t */\n\tif (! validated_format) {\n\t\tif (strncmp(proc_net_buffer,\n\t\t    \"Inter-|   Receive                                   \"\n\t\t    \"             |  Transmit\\n\"\n\t\t    \" face |bytes    packets errs drop fifo frame compressed\"\n\t\t    \" multicast|bytes    packets errs drop fifo colls carrier\"\n\t\t    \" compressed\\n\", 200) != 0)\n\t\t\tdie(0, \"%s: invalid format\\n\",\n\t\t\t    PROC_NET_DEV_PATH);\n\t\telse\n\t\t\tvalidated_format++;\n\t}\n\n\t/* Terminate our string */\n\tbufp = proc_net_buffer + 200;\n\tbuf_remain = bufsiz - 200;\n\tbufp[buf_remain + 1] = '\\0';\n\n\t(void) gettimeofday(&now_tv, NULL);\n\n\tskip_to_newline = 0;\n\tg_nicdata_count = 0;\n\tlastp = NULL;\n\twhile (*bufp) {\n\t\tif (skip_to_newline) {\n\t\t\t/* Need to skip over previous data */\n\t\t\tfor (; *bufp; bufp++)\n\t\t\t\tif (*bufp == '\\n') {\n\t\t\t\t\tbufp++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! *bufp)\n\t\t\t\tbreak;\n\t\t}\n\t\tskip_to_newline = 1;\n\n\t\t/* Get the interface name */\n\t\twhile (*bufp == ' ')\n\t\t\tbufp++;\n\t\t/* Check the format */\n\t\tn = strcspn(bufp, \":\");\n\t\tif (n >= sizeof (if_name))\n\t\t\tdie(0, \"%s: interface name too long\",\n\t\t\t\tPROC_NET_DEV_PATH);\n\t\t(void) strncpy(if_name, bufp, n);\n\t\tif_name[n] = '\\0';\n\t\t/*\n\t\t * Skip interface if not specifically interested in it\n\t\t */\n\t\tif (if_is_ignored(if_name)) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If g_nonlocal, skip \"lo\"\n\t\t */\n\t\tloopback = streql(\"lo\", if_name);\n\t\tif (g_nonlocal && loopback)\n\t\t\tcontinue;\n\n\t\t/* Scan in values */\n\t\tbufp += n + 1;\n\t\tret = sscanf(bufp, \"%llu %llu %llu %llu %llu %llu %llu\"\n\t\t\t\" %llu %llu %llu %llu %llu %llu %llu %llu %llu\\n\",\n\t\t\t&ll[0], &ll[1], &ll[2], &ll[3], &ll[4], &ll[5],\n\t\t\t&ll[6], &ll[7], &ll[8], &ll[9], &ll[10], &ll[11],\n\t\t\t&ll[12], &ll[13], &ll[14], &ll[15]);\n\t\tif (ret != 16)\n\t\t\tdie(0, \"%s: invalid format\", PROC_NET_DEV_PATH);\n\t\t/*\n\t\t * Skip interface if it has never seen a packet\n\t\t */\n\t\tif (ll[1] == 0 && ll[9] == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * OK, we'll keep this one\n\t\t */\n\t\tg_nicdata_count++;\n\t\tnicp = find_nicdatap(&g_nicdatap, &lastp, if_name);\n\t\tnicp->new.tv.tv_sec = now_tv.tv_sec;\n\t\tnicp->new.tv.tv_usec = now_tv.tv_usec;\n\t\tnicp->new.rbytes = ll[0];\n\t\tnicp->new.rpackets = ll[1];\n\t\tnicp->new.wbytes = ll[8];\n\t\tnicp->new.wpackets = ll[9];\n\t\tnicp->new.sat = ll[2];\n\t\tnicp->new.sat += ll[3];\n\t\tnicp->new.sat += ll[11];\n\t\tnicp->new.sat += ll[12];\n\t\tnicp->new.sat += ll[13];\n\t\tnicp->new.sat += ll[14];\n\t\tif (g_opt_x) {\n\t\t\tnicp->new.ierr = ll[2];\n\t\t\tnicp->new.oerr = ll[10];\n\t\t\tnicp->new.coll = ll[13];\n\t\t}\n\t\tif (loopback)\n\t\t\tnicp->flags |= NIC_LOOPBACK;\n\t\tget_speed_duplex(nicp);\n\t\tnicp->report = 1;\n\t}\n\tif (g_tcp || g_udp)\n\t\tload_snmp(g_snmp);\n\tif (g_tcp) {\n\t\tg_tcp_new->tv = now_tv;\n\t\tload_netstat(g_netstat);\n\t}\n\tif (g_udp)\n\t\tg_udp_new->tv = now_tv;\n}\n#endif /* OS_LINUX */\n\n/*\n * precision -\tfigure an optimal floating precision for a printf()\n */\nstatic inline int\nprecision(double value)\n{\n\tif (value < 100)\n\t\treturn (2);\n\telse if (value < 100000)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic inline int\nprecision4(double value)\n{\n\tif (value < 10)\n\t\treturn (2);\n\telse if (value < 100)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic inline int\nprecision_p(double value)\n{\n\tif (value < 100)\n\t\tif (value < 10)\n\t\t\treturn (3);\n\t\telse\n\t\t\treturn (2);\n\telse if (value < 10000)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic char g_timestr[16];\n\nstatic void\nupdate_timestr(time_t *tptr)\n{\n\tstruct tm *tm;\n\ttime_t t;\n\n\tif (tptr)\n\t\tt = *tptr;\n\telse\n\t\tt = time(NULL);\n\ttm = localtime(&t);\n\t(void) strftime(g_timestr, sizeof (g_timestr), \"%H:%M:%S\", tm);\n}\n\n#define\tTCPSTAT(field)\t(g_tcp_new->field - g_tcp_old->field)\n#define\tUDPSTAT(field)\t(g_udp_new->field - g_udp_old->field)\n\nstatic void\nprint_tcp()\n{\n\tdouble tdiff;\n\tuint64_t resets;\n\tdouble retrans_rate;\n\tuint64_t outbytes;\n\tdouble inkb, outkb, inseg, outseg, reset, attfail, inconn,\n\t\toutconn, drops;\n\ttcpstats_t *tsp;\n\n\tif (g_tcp_old->tv.tv_sec == 0)\n\t\t/* Not initialised */\n\t\tg_tcp_old->tv.tv_sec = fetch_boot_time();\n\t\t/* g_tcp_old->tv.tv_sec = g_tcp_new->tv.tv_sec - 100; */\n\ttdiff = tv_diff(&g_tcp_new->tv, &g_tcp_old->tv);\n\tif (tdiff == 0)\n\t\ttdiff = 1;\n\n\t/* Header */\n\tupdate_timestr(&(g_tcp_new->tv.tv_sec));\n\tif (! g_opt_p)\n\t\t(void) printf(\"%8s %7s %7s %7s %7s %5s %5s %4s %5s %5s %5s\\n\",\n\t\t\tg_timestr, \"InKB\", \"OutKB\", \"InSeg\", \"OutSeg\",\n\t\t\t\"Reset\", \"AttF\", \"%ReTX\", \"InConn\", \"OutCon\", \"Drops\");\n\n\tresets = (TCPSTAT(estabResets) + TCPSTAT(outRsts));\n\toutbytes = TCPSTAT(outDataBytes);\n\n\tinkb = (TCPSTAT(inDataInorderBytes) + TCPSTAT(inDataUnorderBytes)) /\n\t\t1024.0 / tdiff;\n\toutkb = outbytes / 1024.0 / tdiff;\n\tinseg = (TCPSTAT(inDataInorderSegs) + TCPSTAT(inDataUnorderSegs)) /\n\t\ttdiff;\n\toutseg = TCPSTAT(outDataSegs) / tdiff;\n\treset = resets / tdiff;\n\tattfail = TCPSTAT(attemptFails) / tdiff;\n\tif (outbytes == 0)\n\t\tretrans_rate = 0.0;\n\telse\n\t\tretrans_rate = TCPSTAT(retransBytes) * 100.0 /\n\t\t\t(double)outbytes;\n\tinconn = TCPSTAT(passiveOpens) / tdiff;\n\toutconn = TCPSTAT(activeOpens) / tdiff;\n\tdrops = (TCPSTAT(halfOpenDrop) + TCPSTAT(listenDrop) +\n\t\tTCPSTAT(listenDropQ0)) / tdiff;\n\n#ifdef NOTDEBUG\n\tdouble ods_rate = (g_tcp_new->outDataSegs - g_tcp_old->outDataSegs) /\n\t\ttdiff;\n\t(void) printf(\"old->outDataSegs = %llu, new->outDataSegs = %llu, \"\n\t\t\"  tdiff = %7.2f; rate = %7.2f\\n\",\n\t\tg_tcp_old->outDataSegs, g_tcp_new->outDataSegs,\n\t\ttdiff, ods_rate);\n#endif /* DEBUG */\n\tif (g_opt_p)\n\t\t(void) printf(\"%ld:TCP:%.*f:%.*f:%.*f:%.*f:%.*f:%.*f:\"\n\t\t\t\"%.*f:%.*f:%.*f:%.*f\\n\",\n\t\t\tg_tcp_new->tv.tv_sec,\n\t\t\tprecision_p(inkb), inkb,\n\t\t\tprecision_p(outkb), outkb,\n\t\t\tprecision_p(inseg), inseg,\n\t\t\tprecision_p(outseg), outseg,\n\t\t\tprecision_p(reset), reset,\n\t\t\tprecision_p(attfail), attfail,\n\t\t\tprecision_p(retrans_rate), retrans_rate,\n\t\t\tprecision_p(inconn), inconn,\n\t\t\tprecision_p(outconn), outconn,\n\t\t\tprecision_p(drops), drops);\n\telse\n\t\t(void) printf(\"TCP      %7.*f %7.*f %7.*f %7.*f %5.*f %5.*f \"\n\t\t\t\"%4.*f %6.*f %6.*f %5.*f\\n\",\n\t\t\tprecision(inkb), inkb,\n\t\t\tprecision(outkb), outkb,\n\t\t\tprecision(inseg), inseg,\n\t\t\tprecision(outseg), outseg,\n\t\t\tprecision4(reset), reset,\n\t\t\tprecision4(attfail), attfail,\n\t\t\tprecision_p(retrans_rate), retrans_rate,\n\t\t\tprecision4(inconn), inconn,\n\t\t\tprecision4(outconn), outconn,\n\t\t\tprecision4(drops), drops);\n\t/* Flip pointers to TCP stats */\n\ttsp = g_tcp_old;\n\tg_tcp_old = g_tcp_new;\n\tg_tcp_new = tsp;\n}\n\nstatic void\nprint_udp()\n{\n\tdouble indg, outdg, inerr, outerr;\n\tudpstats_t *usp;\n\tdouble tdiff;\n\n\tif (g_udp_old->tv.tv_sec == 0)\n\t\t/* Not initialised */\n\t\tg_udp_old->tv.tv_sec = fetch_boot_time();\n\ttdiff = tv_diff(&g_udp_new->tv, &g_udp_old->tv);\n\tif (tdiff == 0)\n\t\ttdiff = 1;\n\n\t/* Header */\n\tupdate_timestr(&(g_udp_new->tv.tv_sec));\n\tif (! g_opt_p)\n\t\t(void) printf(\"%8s                 %7s %7s   %7s %7s\\n\",\n\t\t\tg_timestr, \"InDG\", \"OutDG\", \"InErr\", \"OutErr\");\n\n\tindg = UDPSTAT(inDatagrams) / tdiff;\n\toutdg = UDPSTAT(outDatagrams) / tdiff;\n\tinerr = UDPSTAT(inErrors) / tdiff;\n\touterr = UDPSTAT(outErrors) / tdiff;\n\n\tif (g_opt_p)\n\t\t(void) printf(\"%ld:UDP:%.*f:%.*f:%.*f:%.*f\\n\",\n\t\t\tg_udp_new->tv.tv_sec,\n\t\t\tprecision_p(indg), indg,\n\t\t\tprecision_p(outdg), outdg,\n\t\t\tprecision_p(inerr), inerr,\n\t\t\tprecision_p(outerr), outerr);\n\telse\n\t\t(void) printf(\"UDP                      \"\n\t\t\t\"%7.*f %7.*f   %7.*f %7.*f\\n\",\n\t\t\tprecision(indg), indg,\n\t\t\tprecision(outdg), outdg,\n\t\t\tprecision(inerr), inerr,\n\t\t\tprecision(outerr), outerr);\n\n\t/* Flip pointers to TCP stats */\n\tusp = g_udp_old;\n\tg_udp_old = g_udp_new;\n\tg_udp_new = usp;\n}\n\n/*\n * print_header - print the header line.\n */\nstatic void\nprint_header(void)\n{\n#if DEBUG > 1\n\t(void) printf(\"<<nic_count = %d>>\\n\", g_nicdata_count);\n#endif\n\tswitch (g_style) {\n\tcase STYLE_SUMMARY:\n\t\t(void) printf(\"%8s %8s %14s %14s\\n\",\n\t\t    \"Time\", \"Int\", g_runit_1, g_wunit_1);\n\t\tbreak;\n\tcase STYLE_FULL:\n\t\t(void) printf(\"%8s %8s %7s %7s %7s \"\n\t\t    \"%7s %7s %7s %5s %6s\\n\",\n\t\t    \"Time\", \"Int\", g_runit_1, g_wunit_1, \"rPk/s\",\n\t\t    \"wPk/s\", \"rAvs\", \"wAvs\", \"%Util\", \"Sat\");\n\t\tbreak;\n\tcase STYLE_FULL_UTIL:\n\t\t(void) printf(\"%8s %8s %7s %7s %7s \"\n\t\t    \"%7s %7s %7s %6s %6s\\n\",\n\t\t    \"Time\", \"Int\", g_runit_1, g_wunit_1, \"rPk/s\",\n\t\t    \"wPk/s\", \"rAvs\", \"wAvs\", \"%rUtil\", \"%wUtil\");\n\t\tbreak;\n\tcase STYLE_EXTENDED:\n\t\tupdate_timestr(NULL);\n\t\t(void) printf(\"%-10s %7s %7s %7s %7s  \"\n\t\t    \"%5s %5s %5s %5s %5s  %5s\\n\",\n\t\t    g_timestr, g_runit_2, g_wunit_2, \"RdPkt\", \"WrPkt\",\n\t\t    \"IErr\", \"OErr\", \"Coll\", \"NoCP\", \"Defer\", \"%Util\");\n\t\tbreak;\n\tcase STYLE_EXTENDED_UTIL:\n\t\tupdate_timestr(NULL);\n\t\t(void) printf(\"%-10s %7s %7s %7s %7s  \"\n\t\t    \"%5s %5s %5s %5s %5s %6s %6s\\n\",\n\t\t    g_timestr, g_runit_2, g_wunit_2, \"RdPkt\", \"WrPkt\",\n\t\t    \"IErr\", \"OErr\", \"Coll\", \"NoCP\", \"Defer\",\n\t\t    \"%rUtil\", \"%wUtil\");\n\t\tbreak;\n\t}\n}\n\ninline static double\nmax(double d1, double d2)\n{\n\tif (d1 > d2)\n\t\treturn (d1);\n\treturn (d2);\n}\n\ninline static double\nmin(double d1, double d2)\n{\n\tif (d1 < d2)\n\t\treturn (d1);\n\treturn (d2);\n}\n\n/*\n * print_stats - generate output\n *\n * This routine runs through the linked list of interfaces, prints out\n * statistics where appropriate, then moves the \"new\" stats to the \"old\"\n * stats, ready for next time.\n */\nstatic void\nprint_stats()\n{\n\tstruct nicdata *nicp;\t/* ptr into g_nicdatap linked list */\n\tdouble rbps;\t\t/* read bytes per sec */\n\tdouble wbps;\t\t/* write bytes per sec */\n\tdouble rkps;\t\t/* read KB per sec */\n\tdouble wkps;\t\t/* write KB per sec */\n\tdouble rpps;\t\t/* read packets per sec */\n\tdouble wpps;\t\t/* write packets per sec */\n\tdouble ravs;\t\t/* read average packet size */\n\tdouble wavs;\t\t/* write average packet size */\n\tdouble sats;\t\t/* saturation value per sec */\n\tdouble ierrs;\n\tdouble oerrs;\n\tdouble colls;\n\tdouble nocps;\n\tdouble defers;\n\tdouble tdiff;\t\t/* time difference between samples */\n\tdouble util;\t\t/* utilisation */\n\tdouble rutil;\t\t/* In (read) utilisation */\n\tdouble wutil;\t\t/* Out (write) utilisation */\n\n\tif (g_tcp)\n\t\tprint_tcp();\n\tif (g_udp)\n\t\tprint_udp();\n\n\t/* Print header if needed */\n\tif (! g_list)\n\t\tif (g_tcp || g_udp || (g_line >= PAGE_SIZE)) {\n\t\t\tg_line = 0;\n\t\t\tprint_header();\n\t\t}\n\n\tfor (nicp = g_nicdatap; nicp; nicp = nicp->next) {\n#ifdef OS_SOLARIS\n\t\tif (! (nicp->flags & NIC_UP))\n\t\t\t/* Link is not up */\n\t\t\tcontinue;\n\t\tif (g_nonlocal && (nicp->flags & NIC_LOOPBACK))\n\t\t\tcontinue;\n#endif\n#ifdef OS_LINUX\n\t\tif (! nicp->report)\n\t\t\tcontinue;\n\t\tnicp->report = 0;\n#endif\n\t\t/* Calculate time difference */\n#ifdef OS_LINUX\n\t\tif (nicp->old.tv.tv_sec == 0)\n\t\t\t/* Not initialised, so numbers will be since boot */\n\t\t\tnicp->old.tv.tv_sec = g_boot_time;\n#endif\n\t\ttdiff = tv_diff(&nicp->new.tv, &nicp->old.tv);\n\t\tif (tdiff == 0)\n\t\t\ttdiff = 1;\n\n\t\t/* Calculate per second values */\n\t\trbps = (nicp->new.rbytes - nicp->old.rbytes) / tdiff;\n\t\twbps = (nicp->new.wbytes - nicp->old.wbytes) / tdiff;\n\t\trpps = (nicp->new.rpackets - nicp->old.rpackets) / tdiff;\n\t\twpps = (nicp->new.wpackets - nicp->old.wpackets) / tdiff;\n\t\tif (g_style == STYLE_EXTENDED ||\n\t\t    g_style == STYLE_EXTENDED_UTIL ||\n\t\t    g_style == STYLE_EXTENDED_PARSEABLE) {\n\t\t\tierrs = (nicp->new.ierr - nicp->old.ierr) / tdiff;\n\t\t\toerrs = (nicp->new.oerr - nicp->old.oerr) / tdiff;\n\t\t\tcolls = (nicp->new.coll - nicp->old.coll) / tdiff;\n\t\t\tnocps = (nicp->new.nocp - nicp->old.nocp) / tdiff;\n\t\t\tdefers = (nicp->new.defer - nicp->old.defer) / tdiff;\n\t\t} else if (g_style == STYLE_FULL ||\n\t\t    g_style == STYLE_FULL_UTIL) {\n\t\t\tif (rpps > 0)\n\t\t\t\travs = rbps / rpps;\n\t\t\telse\n\t\t\t\travs = 0;\n\t\t\tif (wpps > 0)\n\t\t\t\twavs = wbps / wpps;\n\t\t\telse\n\t\t\t\twavs = 0;\n\t\t}\n\t\tif (g_style == STYLE_FULL ||\n\t\t    g_style == STYLE_FULL_UTIL ||\n\t\t    g_style == STYLE_PARSEABLE ||\n\t\t    g_style == STYLE_EXTENDED_PARSEABLE)\n\t\t\tsats = (nicp->new.sat - nicp->old.sat) / tdiff;\n\t\tif (g_opt_m) {\n\t\t\t/* report in Mbps */\n\t\t\trkps = rbps / 1024 / 128;\n\t\t\twkps = wbps / 1024 / 128;\n\t\t} else {\n\t\t\t/* original KB/sec */\n\t\t\trkps = rbps / 1024;\n\t\t\twkps = wbps / 1024;\n\t\t}\n\n\t\t/* Calculate utilisation */\n\t\tif (nicp->speed > 0) {\n\t\t\t/*\n\t\t\t * The following have a mysterious \"800\", it is\n\t\t\t * 100 for the % conversion, and 8 for\n\t\t\t * bytes2bits.\n\t\t\t */\n\t\t\trutil = min(rbps * 800 / nicp->speed, 100);\n\t\t\twutil = min(wbps * 800 / nicp->speed, 100);\n\t\t\tif (nicp->duplex == 2) {\n\t\t\t\t/* Full duplex */\n\t\t\t\tutil = max(rutil, wutil);\n\t\t\t} else {\n\t\t\t\t/* Half Duplex */\n\t\t\t\tutil = min((rbps + wbps) * 800 / nicp->speed,\n\t\t\t\t    100);\n\t\t\t}\n\t\t} else {\n\t\t\tutil = 0;\n\t\t\trutil = 0;\n\t\t\twutil = 0;\n\t\t}\n\t\t/* always print header if there are multiple NICs */\n\t\tif (g_nicdata_count > 1)\n\t\t\tg_line += PAGE_SIZE;\n\t\telse\n\t\t\tg_line++;\n\n\t\t/* Skip zero lines */\n\t\tif (g_skipzero && wpps == 0 && rpps == 0)\n\t\t\tcontinue;\n\n\t\t/* Print output line */\n\t\tswitch (g_style) {\n\t\tcase STYLE_SUMMARY:\n\t\t\tupdate_timestr(&nicp->new.tv.tv_sec);\n\t\t\t(void) printf(\"%s %8s %14.3f %14.3f\\n\",\n\t\t\t\tg_timestr, nicp->name, rkps, wkps);\n\t\t\tbreak;\n\t\tcase STYLE_FULL:\n\t\t\tupdate_timestr(&nicp->new.tv.tv_sec);\n\t\t\t(void) printf(\"%s %8s %7.*f %7.*f %7.*f %7.*f \"\n\t\t\t\t\"%7.*f %7.*f %5.*f %6.*f\\n\",\n\t\t\t\tg_timestr, nicp->name,\n\t\t\t\tprecision(rkps), rkps,\n\t\t\t\tprecision(wkps), wkps,\n\t\t\t\tprecision(rpps), rpps,\n\t\t\t\tprecision(wpps), wpps,\n\t\t\t\tprecision(ravs), ravs,\n\t\t\t\tprecision(wavs), wavs,\n\t\t\t\tprecision4(util), util,\n\t\t\t\tprecision(sats), sats);\n\t\t\tbreak;\n\t\tcase STYLE_FULL_UTIL:\n\t\t\tupdate_timestr(&nicp->new.tv.tv_sec);\n\t\t\t(void) printf(\"%s %8s %7.*f %7.*f %7.*f %7.*f \"\n\t\t\t\t\"%7.*f %7.*f %6.*f %6.*f\\n\",\n\t\t\t\tg_timestr, nicp->name,\n\t\t\t\tprecision(rkps), rkps,\n\t\t\t\tprecision(wkps), wkps,\n\t\t\t\tprecision(rpps), rpps,\n\t\t\t\tprecision(wpps), wpps,\n\t\t\t\tprecision(ravs), ravs,\n\t\t\t\tprecision(wavs), wavs,\n\t\t\t\tprecision4(rutil), rutil,\n\t\t\t\tprecision4(wutil), wutil);\n\t\t\tbreak;\n\t\tcase STYLE_PARSEABLE:\n\t\t\t(void) printf(\"%ld:%s:%.*f:%.*f:%.*f:%.*f:\"\n\t\t\t\t\"%.*f:%.*f\\n\",\n\t\t\t\tnicp->new.tv.tv_sec, nicp->name,\n\t\t\t\tprecision_p(rkps), rkps,\n\t\t\t\tprecision_p(wkps), wkps,\n\t\t\t\tprecision_p(rpps), rpps,\n\t\t\t\tprecision_p(wpps), wpps,\n\t\t\t\tprecision4(util), util,\n\t\t\t\tprecision(sats), sats);\n\t\t\tbreak;\n\t\tcase STYLE_EXTENDED:\n\t\t\t(void) printf(\"%-10s %7.*f %7.*f %7.*f %7.*f  \"\n\t\t\t\t\"%5.*f %5.*f %5.*f %5.*f %5.*f  %5.*f\\n\",\n\t\t\t\tnicp->name,\n\t\t\t\tprecision(rkps), rkps,\n\t\t\t\tprecision(wkps), wkps,\n\t\t\t\tprecision(rpps), rpps,\n\t\t\t\tprecision(wpps), wpps,\n\t\t\t\tprecision4(ierrs), ierrs,\n\t\t\t\tprecision4(oerrs), oerrs,\n\t\t\t\tprecision4(colls), colls,\n\t\t\t\tprecision4(nocps), nocps,\n\t\t\t\tprecision4(defers), defers,\n\t\t\t\tprecision4(util), util);\n\t\t\tbreak;\n\t\tcase STYLE_EXTENDED_UTIL:\n\t\t\t(void) printf(\"%-10s %7.*f %7.*f %7.*f %7.*f  \"\n\t\t\t\t\"%5.*f %5.*f %5.*f %5.*f %5.*f %6.*f %6.*f\\n\",\n\t\t\t\tnicp->name,\n\t\t\t\tprecision(rkps), rkps,\n\t\t\t\tprecision(wkps), wkps,\n\t\t\t\tprecision(rpps), rpps,\n\t\t\t\tprecision(wpps), wpps,\n\t\t\t\tprecision4(ierrs), ierrs,\n\t\t\t\tprecision4(oerrs), oerrs,\n\t\t\t\tprecision4(colls), colls,\n\t\t\t\tprecision4(nocps), nocps,\n\t\t\t\tprecision4(defers), defers,\n\t\t\t\tprecision4(rutil), rutil,\n\t\t\t\tprecision4(wutil), wutil);\n\t\t\tbreak;\n\t\tcase STYLE_EXTENDED_PARSEABLE:\n\t\t\t/*\n\t\t\t * Use same initial order as STYLE_PARSEABLE\n\t\t\t * for backward compatibility\n\t\t\t */\n\t\t\t(void) printf(\"%ld:%s:%.*f:%.*f:%.*f:%.*f:\"\n\t\t\t\t\"%.*f:%.*f:%.*f:%.*f:%.*f:%.*f:%.*f\\n\",\n\t\t\t\tnicp->new.tv.tv_sec, nicp->name,\n\t\t\t\tprecision_p(rkps), rkps,\n\t\t\t\tprecision_p(wkps), wkps,\n\t\t\t\tprecision_p(rpps), rpps,\n\t\t\t\tprecision_p(wpps), wpps,\n\t\t\t\tprecision4(util), util,\n\t\t\t\tprecision(sats), sats,\n\t\t\t\tprecision(ierrs), ierrs,\n\t\t\t\tprecision(oerrs), oerrs,\n\t\t\t\tprecision(colls), colls,\n\t\t\t\tprecision(nocps), nocps,\n\t\t\t\tprecision(defers), defers);\n\t\t}\n\n\t\t/* Save the current values for next time */\n\t\tnicp->old = nicp->new;\n\t}\n}\n\nstatic void\ncont_handler(int sig_number)\n{\n\t/* Re-set the signal handler */\n\t(void) signal(sig_number, cont_handler);\n#if DEBUG > 0\n\t(void) fprintf(stderr, \"<< caught SIGCONT >>\\n\");\n#endif\n\tg_caught_cont = 1;\n}\n\n#ifdef OS_SOLARIS\n/*\n * sleep_for - sleep until start_n + period\n *\n * This Solaris version uses gethrtime() and nanosleep()\n */\nstatic void\nsleep_for(hrtime_t period, hrtime_t start_n)\n{\n\tstruct timespec pause_tv;\n\thrtime_t now_n, pause_n;\n\tint status;\n\n\tpause_n = period;\n\tdo {\n\t\tpause_tv.tv_sec = pause_n / NANOSEC;\n\t\tpause_tv.tv_nsec = pause_n % NANOSEC;\n\t\tstatus = nanosleep(&pause_tv, (struct timespec *)NULL);\n\t\tif (status < 0)\n\t\t\tif (errno == EINTR) {\n\t\t\t\tnow_n = gethrtime();\n\t\t\t\tpause_n = start_n + period - now_n;\n\t\t\t\tif (pause_n < 100)\n\t\t\t\t\t/* Forget about it */\n\t\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tdie(1, \"nanosleep\", g_progname);\n\t\t\t}\n\t} while (status != 0);\n}\n#endif /* OS_SOLARIS */\n\n#ifdef OS_LINUX\n/*\n * sleep_for - sleep until now + millisec\n */\nstatic inline void\nsleep_for(int period_ms, struct timeval *start_tv)\n{\n\tint status;\n\tint done = 0;\n\tstruct timeval then;\n\tint us;\n\n\tthen.tv_sec = 0;\n\tdo {\n\t\tstatus = poll(NULL, 0, period_ms);\n\t\tif (status < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tperror(\"poll\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t/* Interrupted - we are not done yet */\n\t\t\tif (then.tv_sec == 0) {\n\t\t\t\tthen.tv_sec = start_tv->tv_sec +\n\t\t\t\t\t(period_ms / 1000);\n\t\t\t\tus = ((period_ms % 1000) * 1000) +\n\t\t\t\t\tstart_tv->tv_usec;\n\t\t\t\tif (us > 1000000) {\n\t\t\t\t\t/* Wrapped */\n\t\t\t\t\tthen.tv_sec++;\n\t\t\t\t\tthen.tv_usec = us - 1000000;\n\t\t\t\t} else\n\t\t\t\t\tthen.tv_usec = us;\n\t\t\t}\n\t\t\t(void) gettimeofday(start_tv, NULL);\n\t\t\tperiod_ms = (then.tv_sec - start_tv->tv_sec) * 1000;\n\t\t\tperiod_ms += (then.tv_usec - start_tv->tv_usec) / 1000;\n\t\t\tif (period_ms <= 0)\n\t\t\t\tdone = 1;\n\t\t} else\n\t\t\tdone = 1;\n\t} while (! done);\n}\n#endif /* OS_LINUX */\n\n#ifdef OS_LINUX\nstatic void\ninit_if_speed_list(char *speed_list)\n{\n\tstruct if_speed_list\t*list_elem;\n\tchar\t\t\t*speed_list_save_ptr;\n\tchar\t\t\t*if_record;\n\tchar\t\t\t*if_record_save_ptr;\n\tchar\t\t\tname[32];\n\tuint64_t\t\tspeed;\n\tchar\t\t\tduplex_s[32];\n\tint\t\t\ttokens;\n\n\tif_record = strtok_r(speed_list, \",\", &speed_list_save_ptr);\n\twhile (if_record) {\n\t\tduplex_s[0] = '\\0';\n\t\ttokens = sscanf(if_record, \"%31[^:]:%llu%31s\",\n\t\t\tname, &speed, duplex_s);\n\t\tif (tokens == 0)\n\t\t\tcontinue;\n\t\tif (speed <= 0)\n\t\t\tdie(0, \"invalid speed for -S %s\", name, if_record);\n\t\tif (name == NULL)\n\t\t\tdie(0, \"invalid -S argument\");\n\n\t\tlist_elem = allocate(sizeof (struct if_speed_list));\n\t\tlist_elem->name = new_string(name);\n\t\t/* speed is in megabits/second */\n\t\tlist_elem->speed = speed * 1000000;\n\t\t/* Do we have a duplex suffix? */\n\t\tswitch (duplex_s[0]) {\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tlist_elem->duplex = DUPLEX_HALF;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\tcase 'F':\n\t\tcase '\\0':\t/* Not specified - default is full */\n\t\t\tlist_elem->duplex = DUPLEX_FULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlist_elem->duplex = DUPLEX_UNKNOWN;\n\t\t}\n#if DEBUG > 0\n\t\tfprintf(stderr, \"<< %s - %llu mbps, duplex = %d >>\\n\",\n\t\t\tname, speed, list_elem->duplex);\n#endif\n\t\tlist_elem->next = g_if_speed_list;\n\t\tg_if_speed_list = list_elem;\n\n\t\tif_record = strtok_r(NULL, \",\", &speed_list_save_ptr);\n\t}\n}\n#endif /* OS_LINUX */\n\n/*\n * split - Split a string of delimited fields, returning an array of char *\n *\n * NOTE: the input string gets modified by this routine\n */\nstatic char **\nsplit(char *string, char *delim, int *nitems)\n{\n\tint ndelim, i;\n\tchar *p;\n\tchar *lasts;\n\tchar **ptrs;\n\n\t/* How many delimiters do we have? */\n\tndelim = 0;\n\tfor (p = string; *p; p++)\n\t\tif (*p == *delim)\n\t\t\tndelim++;\n\n\t/* We need that many ptrs + 2 (max) */\n\tptrs = allocate((ndelim + 2) * sizeof (char *));\n\n\t/* Tokenize */\n\ti = 0;\n\tptrs[i] = strtok_r(string, delim, &lasts);\n\twhile (ptrs[i])\n\t\tptrs[++i] = strtok_r(NULL, delim, &lasts);\n\t*nitems = i;\n\treturn (ptrs);\n}\n\nstatic char *\nduplex_to_string(duplex_t duplex)\n{\n\tswitch (duplex) {\n#ifdef OS_LINUX\n\tcase DUPLEX_HALF:\n\t\treturn (\"half\");\n\tcase DUPLEX_FULL:\n\t\treturn (\"full\");\n#else\n\tcase 1:\n\t\treturn (\"half\");\n\tcase 2:\n\t\treturn (\"full\");\n#endif\n\tdefault:\n\t\treturn (\"unkn\");\n\t}\n}\n\nstatic void\nlist_ifs()\n{\n\tnicdata_t *p;\n\tint loopback;\n\tuint64_t speed;\n\tint verbose;\n\tint if_up;\n\n#ifdef OS_SOLARIS\n\tverbose = g_verbose;\n#else\n\tverbose = 0;\n#endif\n\n\tif (verbose)\n\t\t(void) printf(\"Int      Loopback   Mbit/s Duplex State\"\n\t\t\t\"    Flags ls_types op_types\\n\");\n\telse\n\t\t(void) printf(\"Int      Loopback   Mbit/s Duplex State\\n\");\n\tfor (p = g_nicdatap; p; p = p->next) {\n\t\tif (if_is_ignored(p->name))\n\t\t\tcontinue;\n\t\tloopback = p->flags & NIC_LOOPBACK;\n#ifdef OS_SOLARIS\n\t\tif_up = p->flags & NIC_UP;\n#else\n\t\tif_up = B_TRUE;\n#endif\n\t\tif (loopback)\n\t\t\t(void) printf(\"%-12s  Yes        -   %4s  %4s\",\n\t\t\t\tp->name, duplex_to_string(p->duplex),\n\t\t\t\tif_up ? \"up\" : \"down\");\n\t\telse {\n\t\t\tspeed = (p->speed) / 1000000;\n\t\t\t(void) printf(\"%-12s   No %8llu   %4s  %4s\",\n\t\t\t\tp->name, speed, duplex_to_string(p->duplex),\n\t\t\t\tif_up ? \"up\" : \"down\");\n\t\t}\n#ifdef OS_SOLARIS\n\t\tif (verbose) {\n\t\t\t(void) printf(\" %08x %08x %08x\\n\",\n\t\t\t\tp->flags, p->ls_types, p->op_types);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic void\ninit_tcp()\n{\n\tg_tcp_old = allocate(sizeof (tcpstats_t));\n\tg_tcp_new = allocate(sizeof (tcpstats_t));\n#ifdef OS_SOLARIS\n\tg_tcp_ksp = kstat_lookup(g_kc, \"tcp\", -1, \"tcp\");\n\tif (! g_tcp_ksp) {\n\t\tdiag(0, \"tcp kstats not found\");\n\t}\n#endif\n}\n\nstatic void\ninit_udp()\n{\n\tg_udp_old = allocate(sizeof (udpstats_t));\n\tg_udp_new = allocate(sizeof (udpstats_t));\n#ifdef OS_SOLARIS\n\tg_udp_ksp = kstat_lookup(g_kc, \"udp\", -1, \"udp\");\n\tif (! g_udp_ksp)\n\t\tdiag(0, \"udp kstats not found\");\n#endif\n}\n\n#ifdef USE_DLADM\n/*\n * Do not be confused - the prefix \"dl\" can stand for Dynamic Linking,\n * as well as \"Data Link\"...\n */\nstatic void\ninit_dladm()\n{\n\tvoid *handle;\n\tdladm_status_t (*fptr)();\n\tdladm_status_t dlstat;\n\n\tg_use_dladm = B_FALSE;\n\tif ((handle = dlopen(\"libdladm.so.1\", RTLD_LAZY)) == NULL)\n\t\treturn;\n\tif ((fptr = (dladm_status_t (*)())\n\t    dlsym(handle, \"dladm_datalink_id2info\")) == NULL) {\n\t\t(void) dlclose(handle);\n\t\treturn;\n\t}\n\tg_use_dladm = B_TRUE;\n\t/* Get a handle to use for libdladm call(s) */\n\t/* NOTE: This changed in S11.1 */\n#ifdef NETADM_ACTIVE_PROFILE\n\tdlstat = dladm_open(&g_handle, NULL);\n#else\n\tdlstat = dladm_open(&g_handle);\n#endif\n\tif (dlstat != DLADM_STATUS_OK) {\n\t\tchar errmsg[DLADM_STRSIZE];\n\n\t\tdie(0, \"could not open /dev/dld: %s\",\n\t\t    dladm_status2str(dlstat, errmsg));\n\t}\n}\n#endif /* USE_DLADM */\n\n/*\n * Main Program\n */\nint\nmain(int argc, char **argv)\n{\n\t/*\n\t * Variable Declaration\n\t */\n\tint interval;\t\t/* interval, secs */\n\tint loop_max;\t\t/* max output lines */\n\tint loop;\t\t/* current loop number */\n\tint option;\t\t/* command line switch */\n\tint tracked_ifs;\n\tint time_is_up;\n#ifdef OS_SOLARIS\n\thrtime_t period_n;\t/* period of each iteration in nanoseconds */\n\thrtime_t start_n;\t/* start point of an iteration, nsec */\n\thrtime_t end_n;\t\t/* end time of work in an iteration, nsec */\n\thrtime_t pause_n;\t/* time until start of next iteration, nsec */\n\tkid_t kc_id;\n#else /* OS_SOLARIS */\n\tint net_dev;\t\t/* file descriptor for stats file */\n\tint pause_m;\t\t/* time to pause, milliseconds */\n\tstruct timeval start;\t/* start point of an iteration */\n\tstruct timeval now;\n#endif /* OS_SOLARIS */\n#if DEBUG > 1\n\tstruct timeval debug_now;\n#endif\n\n\t/* defaults */\n\tinterval = INTERVAL;\n\tloop_max = LOOP_MAX;\n\tg_line = PAGE_SIZE;\n\tloop = 0;\n\tg_style = STYLE_FULL;\n\tg_skipzero = B_FALSE;\n\tg_nonlocal = B_FALSE;\n\tg_someif = B_FALSE;\n\tg_forever = B_FALSE;\n\tg_caught_cont = B_FALSE;\n\tg_opt_m = B_FALSE;\n#ifdef OS_SOLARIS\n\tg_list = B_FALSE;\n\tg_verbose = B_FALSE;\n\tg_opt_x = B_FALSE;\n\tg_opt_p = B_FALSE;\n\tg_opt_k = B_FALSE;\n#endif\n\n\t/*\n\t * Process arguments\n\t */\n\tg_progname = argv[0];\n\twhile ((option = getopt(argc, argv, GETOPT_OPTIONS)) != -1) {\n\t\tswitch (option) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tg_tracked = split(optarg, \",\", &tracked_ifs);\n\t\t\tg_someif = tracked_ifs > 0;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tg_style = STYLE_SUMMARY;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tg_verbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tg_skipzero = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tg_nonlocal = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tg_tcp = B_TRUE;\n\t\t\tif (g_style == STYLE_FULL)\n\t\t\t\tg_style = STYLE_NONE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tg_udp = B_TRUE;\n\t\t\tif (g_style == STYLE_FULL)\n\t\t\t\tg_style = STYLE_NONE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tg_opt_x = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tg_tcp = g_udp = B_TRUE;\n\t\t\tif (g_style == STYLE_FULL)\n\t\t\t\tg_opt_x = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\tcase 'm':\t/* Undocumented */\n\t\t\tg_opt_m = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tg_opt_p = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tg_list = B_TRUE;\n\t\t\tg_style = STYLE_NONE;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tg_opt_U = B_TRUE;\n\t\t\tbreak;\n#ifdef OS_LINUX\n\t\tcase 'S':\n\t\t\tinit_if_speed_list(optarg);\n\t\t\tbreak;\n#endif\n#ifdef OS_SOLARIS\n\t\tcase 'k':\n\t\t\tg_opt_k = B_TRUE;\n\t\t\tbreak;\n#endif /* OS_SOLARIS */\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tif (g_opt_p) {\n\t\tif (g_opt_x)\n\t\t\tg_style = STYLE_EXTENDED_PARSEABLE;\n\t\telse if (! g_tcp && ! g_udp)\n\t\t\tg_style = STYLE_PARSEABLE;\n\t\t/* Always output KB in the parseable format */\n\t\tg_opt_m = B_FALSE;\n\t} else\n\t\tif (g_opt_x)\n\t\t\tg_style = STYLE_EXTENDED;\n\tif (g_opt_U)\n\t\tswitch (g_style) {\n\t\tcase STYLE_FULL:\n\t\t\tg_style = STYLE_FULL_UTIL;\n\t\t\tbreak;\n\t\tcase STYLE_EXTENDED:\n\t\t\tg_style = STYLE_EXTENDED_UTIL;\n\t\t}\n\tif (g_opt_m) {\n\t\tg_runit_1 = \"rMbps\";\n\t\tg_wunit_1 = \"wMbps\";\n\t\tg_runit_2 = \"RdMbps\";\n\t\tg_wunit_2 = \"WrMbps\";\n\t}\n\n\targv += optind;\n\tif ((argc - optind) >= 1) {\n\t\tinterval = atoi(*argv);\n\t\tif (interval == 0)\n\t\t\tusage();\n\t\targv++;\n\t\tif ((argc - optind) >= 2)\n\t\t\tloop_max = atoi(*argv);\n\t\telse\n\t\t\tg_forever = 1;\n\t}\n\n#ifdef OS_SOLARIS\n\t/* Open Kstat */\n\tif ((g_kc = kstat_open()) == NULL)\n\t\tdie(1, \"kstat_open\");\n#endif\n\tif (g_tcp)\n\t\tinit_tcp();\n\tif (g_udp)\n\t\tinit_udp();\n#ifdef OS_SOLARIS\n\tif ((g_style == STYLE_NONE) && (g_tcp || g_udp))\n\t\tif ((! g_tcp_ksp) && (! g_udp_ksp))\n\t\t\t/* Nothing to show */\n\t\t\texit(1);\n\tg_tcp = g_tcp && g_tcp_ksp;\n\tg_udp = g_udp && g_udp_ksp;\n#endif\n\n#ifdef USE_DLADM\n\tinit_dladm();\n#endif\n\n\t/* Get a socket so I can do ioctl's */\n\tif ((g_sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\tdie(1, \"socket\");\n\n#ifdef OS_SOLARIS\n\t/* Calculate the period of each iteration */\n\tperiod_n = (hrtime_t)interval * NANOSEC;\n\n\t/* Get time when we started */\n\tstart_n = gethrtime();\n#else /* OS_SOLARIS */\n\t/* Open the file we got stats from (in Linux) */\n\tnet_dev = open(PROC_NET_DEV_PATH, O_RDONLY, 0);\n\tif (net_dev < 0)\n\t\tdie(1, \"open: %s\", PROC_NET_DEV_PATH);\n\tif (g_tcp || g_udp) {\n\t\tg_snmp = fopen(PROC_NET_SNMP_PATH, \"r\");\n\t\tif (! g_snmp)\n\t\t\tdie(1, \"fopen: %s\", PROC_NET_SNMP_PATH);\n\t}\n\tif (g_tcp) {\n\t\tg_netstat = fopen(PROC_NET_NETSTAT_PATH, \"r\");\n\t\tif (! g_netstat)\n\t\t\tdie(1, \"fopen: %s\", PROC_NET_NETSTAT_PATH);\n\t}\n\n\t/* Get boot-time */\n\tg_boot_time = fetch_boot_time();\n\n\t/* Get time when we started */\n\tif (gettimeofday(&start, (void *) NULL) < 0)\n\t\tdie(1, \"gettimeofday\");\n#endif /* OS_SOLARIS */\n\n\t/*\n\t * Set up signal handling\n\t */\n\t(void) signal(SIGCONT, cont_handler);\n\n\tif (g_verbose) {\n\t\t(void) printf(\"nicstat version \" NICSTAT_VERSION \"\\n\");\n\t}\n\n\t/*\n\t * Main Loop\n\t */\n\tfor (;;) {\n#if DEBUG > 1\n\t\tif (gettimeofday(&debug_now, (void *) NULL) < 0) {\n\t\t\tperror(\"gettimeofday\");\n\t\t\texit(2);\n\t\t}\n\t\tfprintf(stderr, \"        pre-op = %ld.%06ld\\n\",\n\t\t\tdebug_now.tv_sec, debug_now.tv_usec);\n#endif\n\n\t\t/*\n\t\t * Fetch data and update statistics\n\t\t */\n#ifdef OS_SOLARIS\n\t\tupdate_nicdata_list();\n\t\tupdate_stats();\n#else\n\t\tupdate_stats(net_dev);\n#endif\n\n\t\t/* Check we matched some NICs */\n\t\tif (g_nicdata_count <= 0)\n\t\t\tdie(0, \"no matching interface\");\n\n\t\t/*\n\t\t * Just a list?\n\t\t */\n\t\tif (g_list) {\n\t\t\tlist_ifs();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Print statistics\n\t\t */\n\t\tprint_stats();\n\n\t\t/* end point */\n\t\tif (! g_forever)\n\t\t\tif (++loop == loop_max) break;\n\n\t\t/* flush output */\n\t\tif (fflush(stdout) != 0)\n\t\t\tdie(1, \"fflush(stdout)\");\n\n\t\t/*\n\t\t * have a kip\n\t\t */\n#ifdef OS_SOLARIS\n\t\tend_n = gethrtime();\n\t\tpause_n = start_n + period_n - end_n;\n\t\ttime_is_up = pause_n <= 0 || pause_n < (period_n / 4);\n#else /* OS_SOLARIS */\n\t\t(void) gettimeofday(&now, NULL);\n\t\tstart.tv_sec += interval;\n\t\tpause_m = (start.tv_sec - now.tv_sec) * 1000;\n\t\tpause_m += (start.tv_usec - now.tv_usec) / 1000;\n\t\ttime_is_up = pause_m <= 0 || pause_m < (interval * 250);\n#endif /* OS_SOLARIS */\n\t\tif (time_is_up)\n\t\t\tif (g_forever || g_caught_cont) {\n\t\t\t\t/* Reset our cadence */\n#ifdef OS_SOLARIS\n\t\t\t\tstart_n = end_n + period_n;\n\t\t\t\tpause_n = period_n;\n#else /* OS_SOLARIS */\n\t\t\t\tstart.tv_sec = now.tv_sec + interval;\n\t\t\t\tstart.tv_usec = now.tv_usec;\n\t\t\t\tpause_m = interval * 1000;\n#endif /* OS_SOLARIS */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The case for better observability\n\t\t\t\t *\n\t\t\t\t * If we got here, then the time\n\t\t\t\t * between the output we just did, and\n\t\t\t\t * the scheduled time for the next\n\t\t\t\t * output is < 1/4 of our requested\n\t\t\t\t * interval AND the number of\n\t\t\t\t * intervals has been requested AND we\n\t\t\t\t * have never caught a SIGCONT (so we\n\t\t\t\t * have never been suspended).  In\n\t\t\t\t * this case, we'll try to get back to\n\t\t\t\t * the desired cadence, so we will\n\t\t\t\t * pause for 1/2 the normal interval\n\t\t\t\t * this time.\n\t\t\t\t */\n#ifdef OS_SOLARIS\n\t\t\t\tpause_n = period_n / 2;\n\t\t\t\tstart_n += period_n;\n#else /* OS_SOLARIS */\n\t\t\t\tpause_m = interval * 500;\n#endif /* OS_SOLARIS */\n\t\t\t}\n#ifdef OS_SOLARIS\n\t\telse\n\t\t\tstart_n += period_n;\n\t\tif (pause_n > 0)\n\t\t\tsleep_for(pause_n, end_n);\n\t\tif ((kc_id = kstat_chain_update(g_kc)) == -1)\n\t\t\tdie(1, \"kstat_chain_update\");\n\t\tg_new_kstat_chain = (kc_id != 0);\n#else /* OS_SOLARIS */\n\t\tif (pause_m > 0)\n\t\t\tsleep_for(pause_m, &now);\n#endif /* OS_SOLARIS */\n\t}\n\n\n\t/*\n\t * Close Kstat & socket\n\t */\n#ifdef OS_SOLARIS\n\t(void) kstat_close(g_kc);\n#endif\n\t(void) close(g_sock);\n\n\treturn (0);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_10_sparc",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Ubuntu_10_i386",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_10_i386",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_11_i386",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_9_i386",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_11_sparc",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.Solaris_9_sparc",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.RedHat_5_i386",
        "/tmp/vanessa/spack-stage/spack-stage-nicstat-1.95-rjj3d5rg2z3sccaeonh66giu6r4si6kp/spack-src/.nicstat.OEL_5_i386"
    ],
    "total_files": 18
}