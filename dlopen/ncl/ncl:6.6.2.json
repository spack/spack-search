{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/ncl/ncl.y": "%{\n#include <stdio.h>\n#ifdef IRIX\n#include <pfmt.h>\n#endif\n#include <ncarg/c.h>\n#include <ncarg/hlu/hluP.h>\n#include <ncarg/hlu/NresDB.h>\n#include \"defs.h\"\n#include \"NclDataDefs.h\"\n#include \"Symbol.h\"\n#include \"SrcTree.h\"\n#include \"Machine.h\"\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if defined(HPUX)\n#include <dl.h>\n#else\n#include <dlfcn.h>\n#endif\nint scopelevel = 0;\nextern int yydebug;\nextern char *yytext;\nextern FILE *thefptr;\nextern FILE *theoptr;\nextern int cmd_line;\nextern int cur_line_length;\nextern int cur_line_number;\nextern int last_line_length;\nextern char *cur_line_text;\nextern int ok_to_start_vsblk;\nextern void ResetCurLine(void);\nextern NhlErrorTypes _NclPreLoadScript(char *path, int status);\nextern int _NclTranslate(void *root, FILE *fp);\nextern int yylex (void);\n\n#define ERROR(x)  NhlPError(NhlFATAL,NhlEUNKNOWN,\"%s\",(x))\n#define PRINTLOCATION(errlev)\t\\\n\tif (loading > 0) \\\n\t\tNhlPError(errlev,NhlEUNKNOWN,\"error at line %d in file %s\\n\",cur_line_number,cur_load_file); \\\n\telse\\\n\t\tNhlPError(errlev,NhlEUNKNOWN,\"error at line %d\\n\",cur_line_number); \n\nint is_error = 0;\nint block_syntax_error = 0;\nint ret_urn = 0;\nExtStack *tmp_sym= NULL;\n/*\nextern int _NclTranslate(\n#ifdef NhlNeedProto\nvoid*,   \nFILE* \n#endif\n);\n*/\nextern void _NclTransTerminate(\n#ifdef NhlNeedProto\nvoid\n#endif\n);\n\nextern int rec; \nextern FILE* recfp;\nextern FILE* yyin;\n\nint loading = 0;\nint preloading = 0;\nint top_level_line;\nchar *cur_load_file = NULL;\nchar *ncl_cur_func = NULL;\n\n%}\n%union {\n\tint integer;\n\tlong long int_val;\n\tdouble real;\n\tchar  str[NCL_MAX_STRING];\n        char *sstr;\n\tstruct _NclSymbol *sym;\n\tvoid *src_node;\n\tstruct src_node_list *list;\n\tstruct ncl_rcl_list *array;\n\tstruct ncl_rcl_list *listvar;\n}\n\n%token\t<void> EOLN \n%token  <void> EOFF\n%token\t<void> RP LP RBC LBC RBK LBK COLON ',' SEMI MARKER LPSLSH SLSHRP DIM_MARKER FSTRING EFSTRING ASTRING CSTRING\n%token\t<void> GSTRING LBKSLSH SLSHRBK\n%token <integer> DIMNUM\n%token <int_val> INT\n%token <real> REAL\n%token <str> DIM DIMNAME ATTNAME COORDV FVAR \n%token <str> GVAR\n%token <sstr> STRING\n%token <sym> INTEGER UINT FLOAT LONG ULONG INT64 UINT64 DOUBLE BYTE UBYTE CHARACTER GRAPHIC STRNG\n%token <sym> NUMERIC ENUMERIC SNUMERIC FILETYPE SHORT USHORT LOGICAL\n%token <sym> GROUP GROUPTYPE COMPOUND UNDEFFILEGROUP\n%token <sym> UNDEF VAR WHILE DO QUIT  NPROC PIPROC IPROC UNDEFFILEVAR BREAK NOPARENT NCLNULL LIST\n%token <sym> BGIN END NFUNC IFUNC FDIM IF THEN VBLKNAME CONTINUE\n%token <sym> DFILE KEYFUNC KEYPROC ELSE ELSEIF EXTERNAL NCLEXTERNAL RETURN VSBLKGET NEW\n%token <sym> OBJVAR OBJTYPE RECORD VSBLKCREATE VSBLKSET LOCAL STOP NCLTRUE NCLFALSE NCLMISSING DLIB\n%token '='\n%token REASSIGN\n%token OR\n%token XOR\n%token AND\n%token GT \n%token GE \n%token LT \n%token LE \n%token EQ \n%token NE\n%token '<' \n%token '>'\n%token '+' \n%token '-'\n%token '*' \n%token '#' \n%token '/' \n%token '%'\n%token '^'\n%token UNOP \n%token NOT\n%right '='\n%right REASSIGN\n%left OR XOR\n%left AND\n%left GT GE LT LE EQ NE\n%left '<' '>'\n%left '+' '-'\n%left '*' '#' '/' '%'\n%left '^'\n%left UNOP NOT\n%type <array> expr_list\n%type <listvar> list_expr_list\n%type <src_node> statement assignment reassignment\n%type <src_node> procedure function_def procedure_def fp_block block do conditional elseif\n%type <src_node> visblk statement_list\n%type <src_node> declaration identifier expr v_parent \n%type <src_node> subscript0 subscript2 break_cont vcreate list_subscript \n%type <src_node> subscript3 subscript1 subexpr primary function array listvar error filevarselector coordvarselector attributeselector \n%type <src_node> filegroupselector\n%type <list> the_list arg_dec_list subscript_list opt_arg_list named_subscript_list normal_subscript_list\n%type <list> block_statement_list cond_block_list resource_list dim_size_list  \n%type <list> arg_list do_stmnt resource vset vget get_resource get_resource_list\n%type <sym> datatype pfname vname\n%type <sym> func_identifier proc_identifier anysym\n%%\n\n\nstatement_list :  statement eoln\t\t\t{\t\n\t\t\t\t\t\t\t\tint strt;\n\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"is_error0 %d\\n\",is_error);\n\t\t\t\t\t\t\t\tfflush(stdout);\n*/\n\t\t\t\t\t\t\t\tif(($1 != NULL)&&!(is_error||block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t_NclPrintTree($1,thefptr);\n\t\t\t\t\t\t\t\t\tstrt = _NclTranslate($1,thefptr);\n\t\t\t\t\t\t\t\t\t_NclTransTerminate();\n#ifdef NCLDEBUG\n\t\t\t\t\t\t\t\t\t_NclPrintMachine(strt,-1,theoptr);\n#endif\n#ifndef PRINTTREEONLY\n\t\t\t\t\t\t\t\t\t_NclExecute(strt);\n#endif\n\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t_NclFreeTree();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n\t\t\t\t\t\t\t\t\t_NclFreeTree();\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t\tif(block_syntax_error) {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Syntax Error in block, block not executed\");\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t\tblock_syntax_error = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| statement_list statement eoln\t\t\t{\t\t\n\t\t\t\t\t\t\t\tint strt;\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"is_error1 %d\\n\",is_error);\n\t\t\t\t\t\t\t\tfflush(stdout);\n*/\n\t\t\t\t\t\t\t\tif(($2 != NULL) && !(is_error||block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t_NclPrintTree($2,thefptr);\n\t\t\t\t\t\t\t\t\tstrt = _NclTranslate($2,thefptr);\n\t\t\t\t\t\t\t\t\t_NclTransTerminate();\n#ifdef NCLDEBUG\n\t\t\t\t\t\t\t\t\t_NclPrintMachine(strt,-1,theoptr);\n#endif\n#ifndef PRINTTREEONLY\n\t\t\t\t\t\t\t\t\t_NclExecute(strt);\n#endif\n\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t_NclFreeTree();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n\t\t\t\t\t\t\t\t\t_NclFreeTree();\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t\tif(block_syntax_error) {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Syntax Error in block, block not executed\");\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t\tblock_syntax_error = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| statement_list RECORD STRING eoln\t\t{ \n/*\n* These record statments have to occur here so that the record command isn't written out\n* by the scanner. The scanner writes each line when an EOLN is scanned.\n*/\n\t\t\t\t\t\t\t\trecfp = fopen(_NGResolvePath($3),\"w\"); \n\t\t\t\t\t\t\t\tif(recfp != NULL){ \n\t\t\t\t\t\t\t\t\trec =1;\n\t\t\t\t\t\t\t\t\tResetCurLine();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,errno,\"Could not open record file\");\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\trec = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| RECORD STRING eoln\t\t\t\t{ \n\t\t\t\t\t\t\t\trecfp = fopen(_NGResolvePath($2),\"w\"); \n\t\t\t\t\t\t\t\tif(recfp != NULL){ \n\t\t\t\t\t\t\t\t\trec =1;\n\t\t\t\t\t\t\t\t\tResetCurLine();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,errno,\"Could not open record file\");\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\trec = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| NCLEXTERNAL UNDEF STRING\t{\n\t\t\t\t\t\t\t\tchar buffer[4*NCL_MAX_STRING];\n\t\t\t\t\t\t\t\tExtStack *tm;\n\n\t\t\t\t\t\t\t\t$2->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = NULL;\n\t\t\t\t\t\t\t\tsprintf(buffer,\"%s\",_NGResolvePath($3));\n\n\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t_NclChangeSymbolType($2,DLIB);\n\t\t\t\t\t\t\t\t_NclPreLoadScript(buffer,0);\n\t\t\t\t\t\t\t\tif(tmp_sym == NULL) {\n\t\t\t\t\t\t\t\t\ttmp_sym = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\ttmp_sym->tmp_sym = $2;\n\t\t\t\t\t\t\t\t\ttmp_sym->next = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttm = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttm->tmp_sym = $2;\n\t\t\t\t\t\t\t\t\ttm->next = tmp_sym;\n\t\t\t\t\t\t\t\t\ttmp_sym = tm;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| EXTERNAL UNDEF STRING\teoln\t\t\t{\n\t\t\t\t\t\t\t\tvoid (*init_function)(void);\n\t\t\t\t\t\t\t\t$2->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"opening: %s\\n\",_NGResolvePath($3));\n*/\n#if defined(HPUX)\n\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = shl_load(_NGResolvePath($3),BIND_IMMEDIATE,0L);\n#else\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = dlopen(_NGResolvePath($3),RTLD_NOW);\n#endif\n\t\t\t\t\t\t\t\tif($2->u.package->so_handle == NULL) {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $3,strerror(errno));\n#else\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $3,dlerror());\n#endif\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t} else {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tinit_function = NULL;\n\t\t\t\t\t\t\t\t\t(void)shl_findsym(&($2->u.package->so_handle), \"Init\",TYPE_UNDEFINED,(void*)&init_function);\n#else\n\t\t\t\t\t\t\t\t\tinit_function = dlsym($2->u.package->so_handle, \"Init\");\n#endif\n\t\t\t\t\t\t\t\t\tif(init_function != NULL) {\n\t\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t\t\t_NclChangeSymbolType($2,DLIB);\n\t\t\t\t\t\t\t\t\t\t(*init_function)();\n\t\t\t\t\t\t\t\t\t\t$2->u.package->scope = _NclPopScope();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t\t  \"Could not find Init() in external file %s, file not loaded\",$3);\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\t\t$2->u.package->scope = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| statement_list NCLEXTERNAL UNDEF STRING {\n\t\t\t\t\t\t\t\tchar buffer[4*NCL_MAX_STRING];\n\t\t\t\t\t\t\t\tExtStack *tm;\n\n\t\t\t\t\t\t\t\t$3->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = NULL;\n\t\t\t\t\t\t\t\tsprintf(buffer,\"%s\",_NGResolvePath($4));\n\n\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t_NclChangeSymbolType($3,DLIB);\n\t\t\t\t\t\t\t\t_NclPreLoadScript(buffer,0);\n\t\t\t\t\t\t\t\tif(tmp_sym == NULL) {\n\t\t\t\t\t\t\t\t\ttmp_sym = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\ttmp_sym->tmp_sym = $3;\n\t\t\t\t\t\t\t\t\ttmp_sym->next = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttm = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttm->tmp_sym = $3;\n\t\t\t\t\t\t\t\t\ttm->next = tmp_sym;\n\t\t\t\t\t\t\t\t\ttmp_sym = tm;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| statement_list EXTERNAL UNDEF STRING eoln\t\t{\n\t\t\t\t\t\t\t\tvoid (*init_function)(void);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t$3->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"opening: %s\\n\",_NGResolvePath($4));\n*/\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = shl_load(_NGResolvePath($4),BIND_IMMEDIATE,0L);\n#else\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = dlopen(_NGResolvePath($4),RTLD_NOW);\n#endif\n\t\t\t\t\t\t\t\tif($3->u.package->so_handle == NULL) {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $4,strerror(errno));\n#else\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $4,dlerror());\n#endif\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t} else {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tinit_function = NULL;\n\t\t\t\t\t\t\t\t\t(void)shl_findsym(&($3->u.package->so_handle), \"Init\",TYPE_UNDEFINED,(void*)&init_function);\n#else\n\t\t\t\t\t\t\t\t\tinit_function = dlsym($3->u.package->so_handle, \"Init\");\n#endif\n\t\t\t\t\t\t\t\t\tif(init_function != NULL) {\n\t\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t\t\t_NclChangeSymbolType($3,DLIB);\n\t\t\t\t\t\t\t\t\t\t(*init_function)();\n\t\t\t\t\t\t\t\t\t\t$3->u.package->scope = _NclPopScope();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t\t  \"Could not find Init() in external file %s, file not loaded\",$4);\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\t\t$3->u.package->scope = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n;\n\n/* This was added 9/2017 to handle single-statement/single-line conditional statements */\ncond_block_list : statement { \t\t\t\t\t\n                                                           NclSrcListNode *tmp = NULL;\t\n                                                            if($1 != NULL) {\n                                                                $$ = _NclMakeNewListNode();\n                                                                $$->next = NULL;\n                                                                $$->node = $1;\n                                                            } \n                            }\n   | block_statement_list                                   {$$ = $1;}\n   ;\n   \nblock_statement_list : statement eoln { \t\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(is_error) {\n\t\t\t\t\t\t\t\t\tif(!cmd_line)\n\t\t\t\t\t\t\t\t\t\tblock_syntax_error = 1;\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\t\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t\t$1 = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif($1 != NULL) {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| block_statement_list statement eoln {\t\n/*\n* This looping is necessary because ordering needs to be maintained for statement_lists\n*/\n\t\t\t\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\t\t\t\tif(is_error) {\n\t\t\t\t\t\t\t\t\tif(!cmd_line)\n\t\t\t\t\t\t\t\t\t\tblock_syntax_error = 1;\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\t\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t\t$2 = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif($1 == NULL) {\n\t\t\t\t\t\t\t\t\tif($2 != NULL) {\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t\t\t$$->node = $2;\n\t\t\t\t\t\t\t\t\t} else if($2 == NULL) {\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if($2 != NULL){\n\t\t\t\t\t\t\t\t\tstep = $1;\n\t\t\t\t\t\t\t\t\twhile(step->next != NULL) {\n\t\t\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstep->next = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\tstep= step->next;\n\t\t\t\t\t\t\t\t\tstep->next = NULL;\n\t\t\t\t\t\t\t\t\tstep->node = $2;\n\t\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| block_statement_list RECORD STRING eoln\t\t\t\t{ \n\t\t\t\t\t\t\t\trecfp = fopen(_NGResolvePath($3),\"w\"); \n\t\t\t\t\t\t\t\tif(recfp != NULL){ \n\t\t\t\t\t\t\t\t\trec =1;\n\t\t\t\t\t\t\t\t\tResetCurLine();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,errno,\"Could not open record file\");\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\trec = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t| RECORD STRING eoln\t\t\t\t{ \n\t\t\t\t\t\t\t\trecfp = fopen(_NGResolvePath($2),\"w\"); \n\t\t\t\t\t\t\t\tif(recfp != NULL){ \n\t\t\t\t\t\t\t\t\trec =1;\n\t\t\t\t\t\t\t\t\tResetCurLine();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,errno,\"Could not open record file\");\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\trec = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t| NCLEXTERNAL UNDEF STRING\t{\n\t\t\t\t\t\t\t\tchar buffer[4*NCL_MAX_STRING];\n\t\t\t\t\t\t\t\tExtStack *tm;\n\n\t\t\t\t\t\t\t\t$2->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = NULL;\n\t\t\t\t\t\t\t\tsprintf(buffer,\"%s\",_NGResolvePath($3));\n\n\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t_NclChangeSymbolType($2,DLIB);\n\t\t\t\t\t\t\t\t_NclPreLoadScript(buffer,0);\n\t\t\t\t\t\t\t\tif(tmp_sym == NULL) {\n\t\t\t\t\t\t\t\t\ttmp_sym = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\ttmp_sym->tmp_sym = $2;\n\t\t\t\t\t\t\t\t\ttmp_sym->next = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttm = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttm->tmp_sym = $2;\n\t\t\t\t\t\t\t\t\ttm->next = tmp_sym;\n\t\t\t\t\t\t\t\t\ttmp_sym = tm;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| EXTERNAL UNDEF STRING\teoln\t\t\t{\n\t\t\t\t\t\t\t\tvoid (*init_function)(void);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t$2->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"opening: %s\\n\",_NGResolvePath($3));\n*/\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = shl_load(_NGResolvePath($3),BIND_IMMEDIATE,0L);\n#else\n\t\t\t\t\t\t\t\t$2->u.package->so_handle = dlopen(_NGResolvePath($3),RTLD_NOW);\n#endif\n\t\t\t\t\t\t\t\tif($2->u.package->so_handle == NULL) {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $3,strerror(errno));\n#else\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $3,dlerror());\n#endif\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t} else {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tinit_function = NULL;\n\t\t\t\t\t\t\t\t\t(void)shl_findsym(&($2->u.package->so_handle), \"Init\",TYPE_UNDEFINED,(void*)&init_function);\n#else\n\t\t\t\t\t\t\t\t\tinit_function = dlsym($2->u.package->so_handle, \"Init\");\n#endif\n\t\t\t\t\t\t\t\t\tif(init_function != NULL) {\n\t\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t\t_NclNewScope();\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t_NclChangeSymbolType($2,DLIB);\n\t\t\t\t\t\t\t\t\t\t(*init_function)();\n\t\t\t\t\t\t\t\t\t\t$2->u.package->scope = _NclPopScope();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t\t  \"Could not find Init() in external file %s, file not loaded\",$3);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\t\t$2->u.package->scope = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| block_statement_list NCLEXTERNAL UNDEF STRING {\n\t\t\t\t\t\t\t\tchar buffer[4*NCL_MAX_STRING];\n\t\t\t\t\t\t\t\tExtStack *tm;\n\n\t\t\t\t\t\t\t\t$3->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = NULL;\n\t\t\t\t\t\t\t\tsprintf(buffer,\"%s\",_NGResolvePath($4));\n\n\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t_NclNewScope();\n\t\t\t\t\t\t\t\t_NclChangeSymbolType($3,DLIB);\n\t\t\t\t\t\t\t\t_NclPreLoadScript(buffer,0);\n\t\t\t\t\t\t\t\tif(tmp_sym == NULL) {\n\t\t\t\t\t\t\t\t\ttmp_sym = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\ttmp_sym->tmp_sym = $3;\n\t\t\t\t\t\t\t\t\ttmp_sym->next = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttm = (ExtStack*)NclMalloc(sizeof(ExtStack));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttm->tmp_sym = $3;\n\t\t\t\t\t\t\t\t\ttm->next = tmp_sym;\n\t\t\t\t\t\t\t\t\ttmp_sym = tm;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t| block_statement_list EXTERNAL UNDEF STRING eoln\t{\n\n\t\t\t\t\t\t\t\tvoid (*init_function)(void);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t$3->u.package = NclMalloc(sizeof(NclSharedLibraryInfo));\n/*\n\t\t\t\t\t\t\t\tfprintf(stdout,\"opening: %s\\n\",_NGResolvePath($4));\n*/\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = shl_load(_NGResolvePath($4),BIND_IMMEDIATE,0L);\n#else\n\t\t\t\t\t\t\t\t$3->u.package->so_handle = dlopen(_NGResolvePath($4),RTLD_NOW);\n#endif\n\t\t\t\t\t\t\t\tif($3->u.package->so_handle == NULL) {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $4,strerror(errno));\n#else\n\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"An error occurred loading the external file %s, file not loaded\\n%s\",\n\t\t\t\t\t\t\t\t\t\t  $4,dlerror());\n#endif\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\n\t\t\t\t\t\t\t\t} else {\n#if defined(HPUX)\n\t\t\t\t\t\t\t\t\tinit_function = NULL;\n\t\t\t\t\t\t\t\t\t(void)shl_findsym(&($3->u.package->so_handle), \"Init\",TYPE_UNDEFINED,(void*)&init_function);\n#else\n\t\t\t\t\t\t\t\t\tinit_function = dlsym($3->u.package->so_handle, \"Init\");\n#endif\n\t\t\t\t\t\t\t\t\tif(init_function != NULL) {\n\t\t\t\t\t\t\t\t\t\t_NclResetNewSymStack();\n\t\t\t\t\t\t\t\t\t\t_NclNewScope();\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t_NclChangeSymbolType($3,DLIB);\n\t\t\t\t\t\t\t\t\t\t(*init_function)();\n\t\t\t\t\t\t\t\t\t\t$3->u.package->scope = _NclPopScope();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t\t  \"Could not find Init() in external file %s, file not loaded\",$4);\n\t\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t\t\t$3->u.package->scope = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n;\n\nopt_eoln : \t\t{ /* do nothing */ }\n\t| opt_eoln eoln\t{ \n\t\t\t\tyyerrok;\n\t\t\t}\t\n;\n\n\neoln : EOLN \t\t\t\t\t\t{ yyerrok; }\n\t| EOFF\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tExtStack *tm;\n\t\t\t\t\t\t\t\tyyerrok;\n\t\t\t\t\t\t\t\tif(tmp_sym != NULL) {\n\t\t\t\t\t\t\t\t\ttm = tmp_sym;\n\t\t\t\t\t\t\t\t\ttm->tmp_sym->u.package->scope = _NclPopScope();\n\t\t\t\t\t\t\t\t\ttmp_sym = tmp_sym->next;\n\t\t\t\t\t\t\t\t\tNclFree(tm);\n\t\t\t\t\t\t\t\t} \n\n#ifdef MAKEAPI\n\t\t\t\t\t\t\t\tret_urn = 1;\n#endif\n\t\t\t\t\t\t\t}\n;\n\nstatement :     \t\t\t\t\t{ $$ = NULL; }\n\t| \tassignment \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1; \n\t\t\t\t\t\t\t}\n\t| \treassignment \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1; \n\t\t\t\t\t\t\t}\n\t|\tprocedure \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t|\tfunction_def \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t|\tprocedure_def \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t| \tblock \t\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t|\tdo \t\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t| \tconditional\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t| \tbreak_cont\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t|\tvisblk \t\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t|\tRETURN expr \t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = _NclMakeReturn($2); \n\t\t\t\t\t\t\t}\n\t|\tRETURN \t\t\t\t\t{\n\t\t\t\t\t\t\t\t$$ = _NclMakeReturn(NULL); \n\t\t\t\t\t\t\t}\n\t| \tQUIT \t\t\t\t\t{ \n#ifndef MAKEAPI\n\t\t\t\t\t\t\t\treturn(-1);\n#else\n\t\t\t\t\t\t\t\t$$ = NULL;\n#endif\n\n\t\t\t\t\t\t\t}\n\t| \terror \t\t\t\t\t{ \n\t\t\t\t\t\t\t\t$$ = NULL ; \n\t\t\t\t\t\t\t\tERROR(\"error in statement\"); \n\t\t\t\t\t\t\t}\n\t| \tSTOP RECORD\t\t\t\t{\n/*\n* this goes here so that rec gets set to one before eoln comes from scanner.\n*/\n\t\t\t\t\t\t\t\tif(rec ==1 ) {\n\t\t\t\t\t\t\t\t\tfclose(recfp);\n\t\t\t\t\t\t\t\t\trecfp = NULL;\n\t\t\t\t\t\t\t\t\trec = 0;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n;\n\nbreak_cont : BREAK  {\n\t\t\t\t$$ = _NclMakeBreakCont($1);\n\t\t\t}\n\t| CONTINUE {\n\t\t\t\t$$ = _NclMakeBreakCont($1);\n\t\t}\n;\n\nelseif : elseif ELSEIF expr then cond_block_list       {  _NclAppendElseIfClause($1, $3, $5);\n                                                                $$ = $1;\n                                                            }\n        | ELSEIF expr then cond_block_list             {  $$ = _NclMakeIfThenElse($2,$4, NULL);  }\n;\n\nconditional : IF expr then cond_block_list elseif END IF {  \n            NclSrcListNode *tmp = NULL;\t\n\t    if($4 != NULL) {\n                tmp = _NclMakeNewListNode();\n\t\ttmp->next = NULL;\n\t\ttmp->node = $5;\n            }\n            $$ = _NclMakeIfThenElse($2,$4,tmp);  \n        }\n\n        | IF expr then cond_block_list elseif ELSE cond_block_list END IF {   \n            NclSrcListNode* tmp1 = _NclMakeNewListNode();\n            tmp1->node = $5;\n            tmp1->next = NULL;\n            _NclAppendElseIfElseClause($5, $7);\n            $$ = _NclMakeIfThenElse($2, $4, tmp1);\n        }\n        \n        | IF expr then cond_block_list END IF\t\t\t\t{  $$ = _NclMakeIfThen($2,$4);  }\n\t| IF expr then cond_block_list ELSE cond_block_list END IF\t{  $$ = _NclMakeIfThenElse($2,$4,$6);  }\n        \n        /* NCL-2655 */\n        /* When I added the elseif construct, I commented the following rules out because they appeared to be\n         * superfluous. Indeed they were for \"properly\" formatted if-then-else's. But in turns out they were intended\n         * to handle if-then-elses written on a single line. \"block_statement_lists\" expect EOLN terminated \"statement\"s,\n         * whereas the \"statement\" rule does not have the EOLN built in.  I created a new rule, cond_block_list, which\n         * now comprises the body of conditional statements; it expects either a \"statement\" or a block_statement_list.\n         * The following rules are now indeed superfluous with the addition of the cond_block_list rule.\n         * They should eventually be removed --RLB 9/2017 \n         */\n        \n        /* NCL-95 (original comment, superceded by above) */\n        /* The following rules appear to be superfluous for the purpose of parsing a conditional. That is, the parser\n         * always returns a block_statement_list object regardless of whether a single-statement or multiple statements,\n         * or even zero statements, are encountered. Commenting these out for now; eventually they should be removed.\n         */\n/**************************************************************************************************************\n\t| IF expr then statement END IF\t\t\t\t\t\t{  \n\t\t\t\t\t\t\t\t\t\t\tNclSrcListNode *tmp = NULL;\t\n\t\t\t\t\t\t\t\t\t\t\tif($4 != NULL) {\n\t\t\t\t\t\t\t\t\t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\t\t\ttmp->next = NULL;\n\t\t\t\t\t\t\t\t\t\t\t\ttmp->node = $4;\n\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeIfThen($2,tmp);  \n\t\t\t\t\t\t\t\t\t\t}\n\t| IF expr then statement ELSE block_statement_list END IF\t \t{  \n\t\t\t\t\t\t\t\t\t\t\tNclSrcListNode *tmp = NULL;\n\t\n\t\t\t\t\t\t\t\t\t\t\tif($4 != NULL) {\n                                                                                                tmp = _NclMakeNewListNode();\n                                                                                                tmp->next = NULL;\n                                                                                                tmp->node = $4;\n\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeIfThenElse($2,tmp,$6);  \n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\n\t| IF expr then statement ELSE statement END IF\t \t{  \n\t\t\t\t\t\t\t\t\t\tNclSrcListNode *tmp = NULL ,*tmp1 = NULL ;\n\t\t\t\t\t\t\t\t\t\tif($4 != NULL) {\n                                                                                        tmp = _NclMakeNewListNode();\n                                                                                        tmp->next = NULL;\n                                                                                        tmp->node = $4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif($6 != NULL) {\n                                                                                        tmp1 = _NclMakeNewListNode();\n                                                                                        tmp1->next = NULL;\n                                                                                        tmp1->node = $6;\n\t\t\t\t\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeIfThenElse($2,tmp,tmp1);  \n\t\t\t\t\t\t\t\t}\n\t| IF expr then block_statement_list ELSE statement END IF\t \t{  \n\t\t\t\t\t\t\t\t\t\t\tNclSrcListNode *tmp = NULL ;\n\t\t\t\t\t\t\t\t\t\t\tif($6 != NULL) {\n                                                                                        \ttmp = _NclMakeNewListNode();\n                                                                                        \ttmp->next = NULL;\n                                                                                        \ttmp->node = $6;\n\t                                                                                } \n\t\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeIfThenElse($2,$4,tmp);  \n\n\t\t\t\t\t\t\t\t\t\t}\n**************************************************************************************/\n;\n\nthen : \n\t| THEN \n;\n\nvisblk :   vset\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| vget\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n;\n\nv_parent: NOPARENT {\n\t\t\t$$ = NULL;\n\t\t   }\n\t| identifier {\n\t\t\t$$ = $1;\n\t\t     }\n;\n\n\nvcreate : VSBLKCREATE expr OBJTYPE v_parent resource_list END VSBLKCREATE\t{   \n\t\t\t\t\t\t\t\t\t$$ = _NclMakeVis($2,$3,$4,$5,Ncl_VISBLKCREATE);\n\t\t\t\t\t\t\t\t}\n\t| VSBLKCREATE expr OBJTYPE v_parent resource END VSBLKCREATE \t{   \n\t\t\t\t\t\t\t\t\t\tNclSrcListNode * tmp = NULL;\n\t\t\t\t\t\t\t\t\t\tif($5 != NULL) {\n\t\t\t\t\t\t \t\t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\t\ttmp->next = NULL;\n\t\t\t\t\t\t\t\t\t\t\ttmp->node = $5;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeVis($2,$3,$4,tmp,Ncl_VISBLKCREATE); \n\t\t\t\t\t\t\t\t}\n\t| VSBLKCREATE error \t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n;\n\nvset :  VSBLKSET expr resource END VSBLKSET\t\t{\n\t\t\t\t\t\t\t\t\tNclSrcListNode * tmp = NULL;\n\t\t\t\t\t\t\t\t\tif($3 != NULL) {\n\t\t\t\t\t\t \t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\ttmp->next = NULL;\n\t\t\t\t\t\t\t\t\t\ttmp->node = $3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeSGVis($2,tmp,Ncl_VISBLKSET); \n\t\t\t\t\t\t\t\t}\n\t| VSBLKSET expr resource_list END VSBLKSET\t{\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeSGVis($2,$3,Ncl_VISBLKSET);\n\t\t\t\t\t\t\t\t}\n\t| VSBLKSET error \t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n;\nvget : VSBLKGET expr get_resource END VSBLKGET\t\t{\n\t\t\t\t\t\t\t\t\tNclSrcListNode * tmp = NULL;\n\t\t\t\t\t\t\t\t\tif($3 != NULL) {\n\t\t\t\t\t\t \t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\ttmp->next = NULL;\n\t\t\t\t\t\t\t\t\t\ttmp->node = $3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeSGVis($2,tmp,Ncl_VISBLKGET); \n\t\t\t\t\t\t\t\t}\n\t| VSBLKGET expr get_resource_list END VSBLKGET  \t{\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeSGVis($2,$3,Ncl_VISBLKGET);\n\t\t\t\t\t\t\t\t}\n\t| VSBLKGET error {\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n;\n\n\nget_resource_list : get_resource eoln\t\t{\n\t\t\t\t\t\t\tif($1 != NULL) {\n\t\t\t\t\t\t \t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t| get_resource_list get_resource eoln\t{\n\t\t\t\t\t\t\tif($1 == NULL) {\n\t\t\t\t\t\t\t\tif($2 != NULL) {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t \t$$->node = $2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if($2 != NULL) {\n\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->next = $1;\n\t\t\t\t\t\t\t\t$$->node = $2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\tif((is_error)&&(cmd_line)) {\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n;\n\nget_resource : \t\t\t\t\t{\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON identifier\t\t{\n\t\t\t\t\t\t\t((NclGenericRefNode*)$3)->ref_type = Ncl_WRITEIT;\n\t\t\t\t\t\t \t$$ = _NclMakeGetResource(_NclMakeStringExpr($1),$3);\n\t\t\t\t\t\t\tNclFree($1);\n\n\t\t\t\t\t\t}\n\t| identifier COLON identifier\t\t{\n\t\t\t\t\t\t\t((NclGenericRefNode*)$3)->ref_type = Ncl_WRITEIT;\n\t\t\t\t\t\t \t$$ = _NclMakeGetResource($1,$3);\n\n\t\t\t\t\t\t}\n/*\n\t| STRING COLON UNDEF\t\t\t{\n\t\t\t\t\t\t \t$$ = _NclMakeGetResource($1,$3);\n\t\t\t\t\t\t\tif(cmd_line)\n\t\t\t\t\t\t\t\tif(!VerifyGetResExpr($3)) {\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t| STRING COLON identifier\t\t\t{\n\t\t\t\t\t\t \t$$ = _NclMakeGetResource($1,$3);\n\t\t\t\t\t\t}\n*/\n\t| error\t\t\t\t\t{\t\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n;\n\n\nresource_list : resource eoln\t\t\t{\n\t\t\t\t\t\t\tif($1 != NULL) {\n\t\t\t\t\t\t \t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t| resource_list resource eoln\t\t{\n\t\t\t\t\t\t\tif($1 == NULL) {\n\t\t\t\t\t\t\t\tif($2 != NULL) {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t \t$$->node = $2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if($2 != NULL) {\n\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->next = $1;\n\t\t\t\t\t\t\t\t$$->node = $2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\tif((is_error)&&(cmd_line)) {\n/*\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\t\t\n*/\n\t\t\t\t\t\t\t\t\tis_error = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\n\t| resource_list error eoln\t\t{\n\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\tis_error -= 1;\n/*\n\t\t\t\t\t\t\t_NclDeleteNewSymStack();\t\n*/\n\t\t\t\t\t\t}\n;\n\nresource : \t\t\t\t\t{\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON expr \t\t\t{\n\t\t\t\t\t\t \t$$ = _NclMakeResource(_NclMakeStringExpr($1),$3);\n\t\t\t\t\t\t\tNclFree($1);\n\t\t\t\t\t\t}\n\t| identifier COLON expr \t\t{\n\t\t\t\t\t\t \t$$ = _NclMakeResource($1,$3);\n\t\t\t\t\t\t}\n/*\n\t| STRING COLON RKEY FVAR\t\t{\n\t\t\t\t\t\t \t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON RKEY FVAR LP subscript_list RP\t{\n\t\t\t\t\t \t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON RKEY COORDV\t\t{\t\n\t\t\t\t\t\t \t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON RKEY COORDV LP subscript_list RP  \t{\n\t\t\t\t\t\t\t \t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t| STRING COLON RKEY ATTNAME\t\t{\n\t\t\t\t\t\t \t$$ = NULL;\n\t\t\t\t\t\t}\n\t| STRING COLON RKEY ATTNAME LP subscript_list RP\t{\n\t\t\t\t\t\t \t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n*/\n;\n\ndo_stmnt : block_statement_list\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\t\t}\n\t| statement\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tNclSrcListNode * tmp = NULL;\n\t\t\t\t\t\t\t\t\t\tif($1 != NULL ) {\n\t\t\t\t\t\t\t\t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t\t\t\ttmp->next = NULL;\n\t\t\t\t\t\t\t\t\t\t\ttmp->node = $1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$$ = tmp;\n\t\t\t\t\t\t\t\t\t}\n;\n\ndo : DO identifier '=' expr ',' expr do_stmnt END DO \t\t\t \t{ \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeDoFromTo($2,$4, $6, $7);\n\t\t\t\t\t\t\t\t\t}\n\t| DO identifier '=' expr ',' expr ',' expr do_stmnt END DO\t { \n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeDoFromToStride($2,$4,$6,$8,$9);\n\t\t\t\t\t\t\t\t\t}\n\t| DO WHILE expr block_statement_list END DO {   \n\t\t\t\t\t\t\t\t$$ = _NclMakeWhile($3,$4);\n\t\t\t\t\t\t\t}\n\t| DO WHILE expr statement END DO {   \n\t\t\t\t\t\t\t\tNclSrcListNode *tmp = NULL ;\n\t\t\t\t\t\t\t\tif($4 != NULL) {\n                                                               \t\ttmp = _NclMakeNewListNode();\n                                                                       \ttmp->next = NULL;\n                                                                       \ttmp->node = $4;\n\t                                                        } \n\t\t\t\t\t\t\t\t$$ = _NclMakeWhile($3,tmp);\n\t\t\t\t\t\t\t}\n;\n\nblock : BGIN block_statement_list END\t{ $$ = _NclMakeBlock($2); }\n\t| BGIN statement END\t{ \n\t\t\t\t\tNclSrcListNode *tmp = NULL ;\n\t\t\t\t\tif($2 != NULL) {\n                                       \t\ttmp = _NclMakeNewListNode();\n                                        \ttmp->next = NULL;\n                                               \ttmp->node = $2;\n\t                                } \n\t\t\t\t\t$$ = _NclMakeBlock(tmp); \n\t\t\t\t}\n;\nfp_block : BGIN block_statement_list END\t{ $$ = _NclMakeBlock($2); }\n\t| BGIN statement END\t{ \n\t\t\t\t\tNclSrcListNode *tmp = NULL ;\n\t\t\t\t\tif($2 != NULL) {\n                                       \t\ttmp = _NclMakeNewListNode();\n                                        \ttmp->next = NULL;\n                                               \ttmp->node = $2;\n\t                                } \n\t\t\t\t\t$$ = _NclMakeBlock(tmp); \n\t\t\t\t}\n;\n\nprocedure : IPROC opt_arg_list    {\n\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\t\n\t\t\t\t\tstep = $2;\n\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t}\n\t\t\t\t\tif(count != $1->u.procfunc->nargs) {\n\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,count);\n\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = _NclMakeProcCall($1,$2,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t}\n\t\t\t\t}\n\t| PIPROC opt_arg_list    {\n\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\t\tstep = $2;\n\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t}\n\t\t\t\t\tif(count != $1->u.procfunc->nargs) {\n\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,count);\n\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = _NclMakeProcCall($1,$2,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t}\n\t\t\t\t}\n\t| NPROC opt_arg_list\t{ \n\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\n\t\t\t\t\tstep = $2;\n\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t}\n\t\t\t\t\tif(count != $1->u.procfunc->nargs) {\n\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,count);\n\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = _NclMakeProcCall($1,$2,Ncl_PROCCALL); \n\t\t\t\t\t}\n\t\t\t\t}\n\t| PIPROC \t\t{ \n\t\t\t\t\tif($1->u.procfunc->nargs != 0) {\n\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,0);\n\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = _NclMakeProcCall($1,NULL,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t}\n\t\t\t\t}\n\t| IPROC \t\t{ \n\t\t\t\t\tif($1->u.procfunc->nargs != 0) {\n\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,0);\n\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = _NclMakeProcCall($1,NULL,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t}\n\t\t\t\t}\n\t| NPROC \t\t{ \n\t\t\t\t\t\tif($1->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,0);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeProcCall($1,NULL,Ncl_PROCCALL); \n\t\t\t\t\t\t}\n\t\t\t\t}\n\t| DLIB COLON COLON anysym\t{\n\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\tif($1->u.package != NULL) {\n\t\t\t\t\t\ts = _NclLookUpInScope($1->u.package->scope,$4->name);\n\t\t\t\t\t\tif(s == NULL) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: procedure %s is not defined in package %s\\n\",\n\t\t\t\t\t\t\t\t  $4->name,$1->name);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else if(s->type == IPROC) {\n\t\t\t\t\t\t\tif(s->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,0);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = _NclMakeProcCall(s,NULL,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t} else if(s->type == NPROC) {\n\t\t\t\t\t\t\tif(s->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,0);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = _NclMakeProcCall(s,NULL,Ncl_PROCCALL); \n\t\t\t\t\t\t\t} \t\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: %s is not a procedure in package %s\\n\",$4->name,$1->name);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t| DLIB COLON COLON anysym opt_arg_list {\n\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\t\n\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\tif($1->u.package != NULL) {\n\t\t\t\t\t\ts = _NclLookUpInScope($1->u.package->scope,$4->name);\n\t\t\t\t\t\tif(s == NULL) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: procedure %s is not defined in package %s\\n\",$4->name,$1->name);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else if(s->type == IPROC){\n\t\t\t\t\t\t\tstep = $5;\n\t\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(count != s->u.procfunc->nargs) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,count);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlWARNING);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = _NclMakeProcCall(s,$5,Ncl_INTRINSICPROCCALL); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(s->type == NPROC ) {\n\t\t\t\t\t\t\tstep = $5;\n\t\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(count != s->u.procfunc->nargs) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,count);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = _NclMakeProcCall(s,$5,Ncl_PROCCALL); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n                                                } else {\n                                                        NhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: %s is not a procedure in package %s\\n\",\n\t\t\t\t\t\t\t\t  $4->name,$1->name);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n                                                        $$ = NULL;\n                                                }\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n/*---------------------------------------------ERROR HANDLING BELOW THIS LINE-----------------------------------------------------*/\n        | IFUNC opt_arg_list\t{ $$ = NULL; \n\t\t  \t\t  NhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t    \"syntax error: %s is a function not a procedure; return value must be referenced\",ncl_cur_func); \n                                  PRINTLOCATION(NhlFATAL);\n                                }\n        | NFUNC opt_arg_list\t{ $$ = NULL; \n\t\t                  NhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t    \"syntax error: %s is a function not a procedure; return value must be referenced\",ncl_cur_func); \n\t\t\t\t  PRINTLOCATION(NhlFATAL);\n\t\t\t\t}\n\n;\n\nopt_arg_list : LP arg_list RP\t\t\t{ $$ = $2;    }\n\t| LP RP\t\t\t\t\t{ $$ = NULL;    }\n;\n\narg_list: expr\t\t\t\t\t{ \n\t\t\t\t\t\t/* Code to check type of expression, iff its and identifier then stamp it with\n\t\t\t\t\t\t\tthe Ncl_PARAMIT tag so the translator can add extra code */\n\t\t\t\t\t\t\tif(!is_error) {\n\t\t\t\t\t\t\t\tif(((NclGenericNode*)$1)->kind == Ncl_IDNEXPR) {\n\t\t\t\t\t\t\t\t\t((NclGenericRefNode*)((NclIdnExpr*)$1)->idn_ref_node)->ref_type =\n\t\t\t\t\t\t\t\t\t\tNcl_PARAMIT;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t| arg_list ',' expr  \t\t\t{\n\t\t\t\t\t\t\tNclSrcListNode * step;\n\t\t\t\t\t\t/* \n\t\t\t\t\t\t* ordering is important because arguments eventually must be pushed on stack in\n\t\t\t\t\t\t* appropriate order \n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif(!is_error) {\n\t\t\t\t\t\t\t\tstep = $1;\n\t\t\t\t\t\t\t\twhile(step->next != NULL) {\n\t\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Code to check type of expression, iff its and identifier then stamp it with\n\t\t\t\t\t\t\t\tthe Ncl_PARAMIT tag so the translator can add extra code */\n\t\t\t\t\t\t\t\tif(((NclGenericNode*)$3)->kind == Ncl_IDNEXPR) {\n\t\t\t\t\t\t\t\t\t((NclGenericRefNode*)((NclIdnExpr*)$3)->idn_ref_node)->ref_type =\n\t\t\t\t\t\t\t\t\t\tNcl_PARAMIT;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstep->next = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\tstep->next->next = NULL;\n\t\t\t\t\t\t\t\tstep->next->node = $3;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n;\nfunc_identifier: KEYFUNC UNDEF { _NclNewScope(); $$ = $2; }\n;\n\nlocal_list: vname {\n\t\t\t/* have to make sure that items in the local list are not added twice !! */\n\t\t\tint lv = _NclGetCurrentScopeLevel();\n\n\t\t\tif($1->level != lv) {\n\t\t\t\t_NclAddSym($1->name,UNDEF);\n\t\t\t}\n\t\t}\n\t| pfname {\n\t\t\tint lv = _NclGetCurrentScopeLevel();\n\t\t\tif($1->level != lv) {\n\t\t\t\t_NclAddSym($1->name,UNDEF);\n\t\t\t}\n\t\t}\n\t| local_list opt_eoln ',' opt_eoln vname {\n\t\t\tint lv = _NclGetCurrentScopeLevel();\n\t\t\tif($5->level != lv) {\n\t\t\t\t_NclAddSym($5->name,UNDEF);\n\t\t\t}\n\t\t\t}\n\t| local_list opt_eoln ',' opt_eoln pfname {\n\t\t\tint lv = _NclGetCurrentScopeLevel();\n\t\t\tif($5->level != lv) {\n\t\t\t\t_NclAddSym($5->name,UNDEF);\n\t\t\t}\n\t\t\t}\n;\nfunction_def :  func_identifier  LP arg_dec_list  RP opt_eoln {_NclChangeSymbolType($1,NFUNC);_NclAddProcFuncInfoToSym($1,$3); } fp_block\t\t\n\t\t\t\t\t\t\t\t{  \n\t\t\t\t\t\t\t\t\tNclScopeRec *tmp;\n\n\t\t\t\t\t\t\t\t\tif(is_error||((!cmd_line)&&block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n\t\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t\t\tis_error += 1;\t\n\t\t\t\t\t\t\t\t\t\t$1->type = UNDEF;\n\t\t\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeNFunctionDef($1,$3,$7,tmp);  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t|  func_identifier  LP arg_dec_list  RP opt_eoln LOCAL opt_eoln local_list opt_eoln {_NclChangeSymbolType($1,NFUNC); _NclAddProcFuncInfoToSym($1,$3); } fp_block\n\t\t\t\t\t\t\t\t{  \n\t\t\t\t\t\t\t\t\tNclScopeRec *tmp;\n\n\t\t\t\t\t\t\t\t\tif(is_error||(!cmd_line&&block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n\t\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\t\t\t$1->type = UNDEF;\n\t\t\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t\t$$ = _NclMakeNFunctionDef($1,$3,$11,tmp);  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n/*---------------------------------------------ERROR HANDLING BELOW THIS LINE-----------------------------------------------------*/\n\t| func_identifier error {\n\t\t\tis_error += 1;\n\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"syntax error: Possibly expecting a 'begin' or 'local'\");\n/*\n* Need to call this before new scope is poped so symbols can be found and freed\n*/\n\t\t\t_NclDeleteNewSymStack();\n/*\n* Need to call function to free scope\n*/\n\t\t\t(void)_NclPopScope();\n\t\t\t$1->type = UNDEF;\n\t}\n\t| KEYFUNC error {\n\t\tis_error += 1;\n\t\t NhlPError(NhlFATAL,NhlEUNKNOWN,\"Function identifier is defined\");\n\t\t$$ = NULL;\n\t}\n/*\n\t| EXTERNAL func_identifier LP arg_dec_list RP opt_eoln local_arg_dec_list eoln error {\n\t\t\t\t\t\tERROR(\"syntax error: EXPECTING A 'begin'\");\n\t}\n*/\n;\n\narg_dec_list : \t\t\t{ $$ = NULL; }\n\t| opt_eoln the_list { $$ = $2; }\n; \n\nthe_list: declaration opt_eoln\t\t\t{\t\n\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t}\n\t| declaration opt_eoln ',' opt_eoln the_list \t{ \n\t\t\t\t\t\t/* once again ordering not important as long as it is consistent with function \n\t\t\t\t\t\t\tand procedure ordering of argument lists */\n\t\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t\t$$->next = $5;\n\t\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t}\n;\n\ndeclaration : vname { \n\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\tint lv = _NclGetCurrentScopeLevel();\n\n\t\t\t\t\tif(($1->type != UNDEF)||($1->level != lv)) {\n\t\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts = $1;\n\t\t\t\t\t}\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,NULL,NULL); \n\t\t\t\t}\n\t| vname COLON datatype { \n\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\tint lv = _NclGetCurrentScopeLevel();\n\n\t\t\t\t\tif(($1->type != UNDEF)||($1->level != lv)) {\n\t\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts = $1;\n\t\t\t\t\t}\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,NULL,$3); \n\t\t\t\t}\n\t| vname dim_size_list { \n\t\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\t\tint lv = _NclGetCurrentScopeLevel();\n\t\t\t\t\t\tif(($1->type != UNDEF)||($1->level != lv)) {\n\t\t\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts = $1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,$2,NULL); \n\t\t\t\t\t}\n\t| vname dim_size_list COLON datatype { \n\t\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\t\tint lv = _NclGetCurrentScopeLevel();\n\t\t\t\t\t\tif(($1->type != UNDEF)||($1->level != lv)) {\n\t\t\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts = $1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,$2,$4); \n\t\t\t\t\t}\n\t| pfname { \n\t\t\t\t/* Need to intercept defined names and add them to current scope */\n\t\t\t\t\tNclSymbol *s;\n\n\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,NULL,NULL); \n\t\t\t\t}\n\t| pfname COLON datatype { \n\t\t\t\t\tNclSymbol *s;\n\n\t\t\t\t\ts= _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,NULL,$3); \n\t\t\t\t}\n\t| pfname dim_size_list { \n\t\t\t\t\tNclSymbol *s;\n\n\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,$2,NULL); \n\t\t\t\t}\n\t| pfname dim_size_list COLON datatype { \n\t\t\t\t\tNclSymbol *s;\n\n\t\t\t\t\ts = _NclAddSym($1->name,UNDEF);\n\t\t\t\t\t$$ = _NclMakeLocalVarDec(s,$2,$4); \n\t\t\t\t}\n;\n\npfname : IFUNC\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| PIPROC\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| NFUNC\t\t{\t\t\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| NPROC\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n;\n\ndatatype : FLOAT\t{ $$ = $1; }\n\t| LONG\t\t{ $$ = $1; }\n\t| ULONG\t\t{ $$ = $1; }\n\t| INT64\t\t{ $$ = $1; }\n\t| UINT64\t{ $$ = $1; }\n\t| INTEGER\t{ $$ = $1; }\n\t| UINT\t\t{ $$ = $1; }\n\t| SHORT\t\t{ $$ = $1; }\n\t| USHORT\t{ $$ = $1; }\n\t| DOUBLE\t{ $$ = $1; }\n\t| CHARACTER\t{ $$ = $1; }\n\t| BYTE\t\t{ $$ = $1; }\n\t| UBYTE\t\t{ $$ = $1; }\n\t| FILETYPE\t{ $$ = $1; }\n\t| GROUP\t\t{ $$ = $1; }\n\t| GROUPTYPE\t{ $$ = $1; }\n\t| COMPOUND\t{ $$ = $1; }\n\t| NUMERIC\t{ $$ = $1; }\n\t| ENUMERIC\t{ $$ = $1; }\n\t| SNUMERIC\t{ $$ = $1; }\n\t| GRAPHIC \t{ $$ = $1; }\n\t| STRNG\t \t{ $$ = $1; }\n\t| LOGICAL \t{ $$ = $1; }\n\t| LIST \t\t{ $$ = $1; }\n;\n\ndim_size_list : LBK INT RBK\t\t{ \n\t\t\t\t\t/* Dimension size list must be in order */\n\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t$$->node = _NclMakeDimSizeNode($2);\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\t| LBK '*' RBK \t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t$$->node = _NclMakeDimSizeNode(-1);\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\t| dim_size_list LBK INT RBK \t{   \t\n\t\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\t\t\n\t\t\t\t\t\tstep = $1;\n\t\t\t\t\t\twhile(step->next != NULL) \n\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\tstep->next = _NclMakeNewListNode();\n\t\t\t\t\t\tstep->next->next = NULL;\n\t\t\t\t\t\tstep->next->node = _NclMakeDimSizeNode($3);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t| dim_size_list LBK '*' RBK \t{   \n\t\t\t\t\t\tNclSrcListNode *step;\n                                                \n                                                step = $1;\n                                                while(step->next != NULL) \n                                                        step = step->next;\n                                                step->next = _NclMakeNewListNode();\n                                                step->next->next = NULL;\n                                                step->next->node = _NclMakeDimSizeNode(-1);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n;\n\nproc_identifier: KEYPROC UNDEF { _NclNewScope(); $$ = $2; }\n;\nprocedure_def : proc_identifier LP arg_dec_list RP opt_eoln LOCAL opt_eoln local_list opt_eoln {_NclChangeSymbolType($1,NPROC);_NclAddProcFuncInfoToSym($1,$3); } fp_block   {\n\t\t\t\t\t\t\t\tNclScopeRec *tmp;\n\t\t\t\t\t\t\t\tif(is_error||((!cmd_line)&&block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n                                                                \ttmp = _NclPopScope();\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t\tis_error +=1;\n\t\t\t\t\t\t\t\t\t$1->type = UNDEF;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeProcDef($1,$3,$11,tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t| proc_identifier LP arg_dec_list RP opt_eoln {_NclChangeSymbolType($1,NPROC);_NclAddProcFuncInfoToSym($1,$3); } fp_block   {\n\t\t\t\t\t\t\t\tNclScopeRec *tmp;\n\n\t\t\t\t\t\t\t\tif(is_error||((!cmd_line)&&block_syntax_error)) {\n\t\t\t\t\t\t\t\t\t_NclDeleteNewSymStack();\n                                                                \ttmp = _NclPopScope();\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t\tis_error +=1;\n\t\t\t\t\t\t\t\t\t$1->type = UNDEF;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttmp = _NclPopScope();\t\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeProcDef($1,$3,$7,tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t| proc_identifier error {\n\t\t\tis_error += 1;\n/*\n* Need to call this before new scope is poped so symbols can be found and freed\n*/\n\t\t\t_NclDeleteNewSymStack();\n/*\n* Need to call function to free scope\n*/\n\t\t\t(void)_NclPopScope();\n\t\t\t$1->type = UNDEF;\n\t\t\t$$ = NULL;\n\t}\n;\n\nassignment :  identifier '=' expr\t\t{\n\t\t\t\t\t\tif($1 != NULL) {\n\t\t\t\t\t\t\t((NclGenericRefNode*)$1)->ref_type = Ncl_WRITEIT;\n\t\t\t\t\t\t\t$$ = _NclMakeAssignment($1,$3);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t  \n\t\t\t\t\t}\n\t| identifier  error {\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"syntax error: possibly an undefined procedure\");\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n        | vname list_subscript LP RP error {\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"syntax error: possibly an undefined procedure\");\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n\t| identifier '='  error\t\t{\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n       \nreassignment :  identifier REASSIGN expr\t{\n\t\t\t\t\t\tif($1 != NULL) {\n\t\t\t\t\t\t\t((NclGenericRefNode*)$1)->ref_type = Ncl_REWRITEIT;\n\t\t\t\t\t\t\t$$ = _NclMakeReassignment($1,$3);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t  \n\t\t\t\t\t}\n\t| identifier REASSIGN  error\t{\n\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t}\n\nfilevarselector : FVAR {\n\t\t\t$$ = _NclMakeIdnExpr(_NclMakeStringExpr($1));\n\t\t}\n\t| FSTRING primary EFSTRING {\n\t\t_NclValOnly($2);\n\t\t$$ = $2;\n\t}\nfilegroupselector : GVAR {\n\t\t$$ = _NclMakeIdnExpr(_NclMakeStringExpr($1));\n\t}\n\t| GSTRING primary EFSTRING {\n\t\t_NclValOnly($2);\n\t\t$$ = $2;\n\t}\ncoordvarselector : COORDV{\n\t\t\t$$ = _NclMakeIdnExpr(_NclMakeStringExpr($1));\n\t}\n\t| CSTRING primary EFSTRING {\n\t\t_NclValOnly($2);\n\t\t$$ = $2;\n\t}\nattributeselector : ATTNAME{\n\t\t\t$$ = _NclMakeIdnExpr(_NclMakeStringExpr($1));\n\t}\n\t| ASTRING primary EFSTRING {\n\t\t_NclValOnly($2);\n\t\t$$ = $2;\n\t}\n\nidentifier : vname list_subscript \t{\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tvoid *node;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarRef($1,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n/*\n\t\t\t\t\t\t\tnode = _NclMakeVarRef(tmp0,NULL);\n\t\t\t\t\t\t\t_NclValOnly(node);\n*/\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarRef(tmp0,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t  \t\t\t}\n\t| vname list_subscript filevarselector {\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarRef($1,$3,NULL,Ncl_FILEVAR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarListRef($1,$2,$3,NULL);\n\t\t\t\t\t\t}\n\t\t\t \t\t}\n\t| vname list_subscript filegroupselector {\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileGroupRef($1,$3,Ncl_FILEGROUP);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFileGroupListRef($1,$2,$3,NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector MARKER\t\t{\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarRef($1,$3,NULL,Ncl_FILEVAR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarRef(tmp0,$3,NULL,Ncl_FILEVAR),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector LP subscript_list RP MARKER {\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tif($2 == NULL) {\t\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarRef($1,$3,$5,Ncl_FILEVAR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarRef(tmp0,$3,$5,Ncl_FILEVAR),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n/*\n\t| vname list_subscript filevarselector LP subscript_list RP\t{\t\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarRef($1,$3,$5,Ncl_FILEVAR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarRef(tmp0,$3,$5,Ncl_FILEVAR),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n*/\n\t| vname list_subscript filevarselector LP subscript_list RP\t{\t\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarRef($1,$3,$5,Ncl_FILEVAR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarListRef($1,$2,$3,(NclSrcListNode *)$5);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t| vname list_subscript filevarselector DIM_MARKER primary\t{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\t_NclValOnly($5);\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarDimRef($1,$3,$5);\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarDimRef(tmp0,$3,$5),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        | vname list_subscript filevarselector attributeselector {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarAttRef($1,$3,$4,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarAttRef(tmp0,$3,$4,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        | vname list_subscript filevarselector attributeselector LP subscript_list RP\t{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarAttRef($1,$3,$4,$6);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarAttRef(tmp0,$3,$4,$6),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector coordvarselector\t\t\t{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarCoordRef($1,$3,$4,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarCoordRef(tmp0,$3,$4,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector coordvarselector attributeselector{\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarCoordAttRef($1,$3,$4,$5,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarCoordAttRef(tmp0,$3,$4,$5,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector coordvarselector attributeselector LP subscript_list RP {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarCoordAttRef($1,$3,$4,$5,$7);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarCoordAttRef(tmp0,$3,$4,$5,$7),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript filevarselector coordvarselector LP subscript_list RP{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeFileVarCoordRef($1,$3,$4,$6);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeFileVarCoordRef(tmp0,$3,$4,$6),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript DIM_MARKER primary  {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\t_NclValOnly($4);\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarDimRef($1,$4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarDimRef(tmp0,$4),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        | vname list_subscript attributeselector {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarAttRef($1,$3,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarAttRef(tmp0,$3,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        | vname list_subscript attributeselector LP subscript_list RP\t{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarAttRef($1,$3,$5);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarAttRef(tmp0,$3,$5),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname MARKER\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeVarRef($1,NULL);\n\t\t\t\t\t}\n\t| vname list_subscript LP subscript_list RP MARKER     {\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarRef($1,$4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarRef(tmp0,$4),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n        | vname list_subscript LP subscript_list RP {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarRef($1,$4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarRef(tmp0,$4),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript coordvarselector{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarCoordRef($1,$3,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarCoordRef(tmp0,$3,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript coordvarselector LP subscript_list RP{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarCoordRef($1,$3,$5);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarCoordRef(tmp0,$3,$5),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript coordvarselector attributeselector\t\t{\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarCoordAttRef($1,$3,$4,NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarCoordAttRef(tmp0,$3,$4,NULL),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| vname list_subscript coordvarselector attributeselector LP subscript_list RP {\n\t\t\t\t\t\tNclSymbol *tmp0;\n\t\t\t\t\t\tNclSymbol *tmp;\n\t\t\t\t\t\tif($2 == NULL) {\n\t\t\t\t\t\t\t$$ = _NclMakeVarCoordAttRef($1,$3,$4,$6);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = _NclAddUniqueSym(\"tmp_list_\",UNDEF);\n\t\t\t\t\t\t\ttmp0 = _NclAddUniqueSym(\"tmp_list_var_\",UNDEF);\n\t\t\t\t\t\t\t$$ = _NclMakeListRef(_NclMakeVarCoordAttRef(tmp0,$3,$4,$6),tmp,$1,$2,tmp0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n;\n\nvname : OBJVAR\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| OBJTYPE\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| VAR\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n\t| DFILE\t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n/*\n\t| LIST \t\t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n*/\n\t| UNDEF \t{\n\t\t\t\t$$ = $1;\n\t\t\t}\n;\nlist_subscript : { \n\t\t$$ = NULL;\n\t}\n\t| LBK subexpr RBK {\n\t\t$$ = _NclMakeIntSubscript($2,NULL);\n\t}\n;\nsubscript_list : \n        named_subscript_list {\n\t\t\t$$ = $1;\n\t\t}\n\t| normal_subscript_list {\n\t\t$$ = $1;\n\t}\n\nnamed_subscript_list:  subscript2 \t{\n\t\t\t\t\t/* ordering of subscripts must be preserved */\n\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t}\n\t| LBC subscript3 RBC \t\t{\n\t\t\t\t\t/* ordering of subscripts must be preserved */\n                                                $$ = _NclMakeNewListNode();\n                                                $$->next = NULL;\n                                                $$->node = $2;\n\t\t\t\t\t}\n\t| named_subscript_list ',' subscript2 {\n\t\t\t\t\t\tNclSrcListNode *step;\n                                                \n                                                step = $1;\n\t\t\t\t\t\tif(!is_error) {\n                                                \twhile(step->next != NULL) \n                                                        \tstep = step->next;\n                                                \tstep->next = _NclMakeNewListNode();\n                                                \tstep->next->next = NULL;\n                                                \tstep->next->node = $3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t| named_subscript_list ',' LBC subscript3 RBC {\n\t\t\t\t\t\tNclSrcListNode *step;\n                                         \n                                                step = $1;\n\t\t\t\t\t\tif(!is_error) {\n                                                \twhile(step->next != NULL)\n                                                        \tstep = step->next;\n                                                \tstep->next = _NclMakeNewListNode();\n                                                \tstep->next->next = NULL;\n                                                \tstep->next->node = $4;\n\t\t\t\t\t\t}\n                                                \n\t\t\t\t\t}\n\t| named_subscript_list ',' error {\n\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t  \"Error in subscript, named subscripting is being used, make sure each subscript has a name\");\n\t\t\t\t\tis_error += 1;\n\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\n\n\t\t\t\t}\n;\nnormal_subscript_list:  subscript0 \t{\n\t\t\t\t\t/* ordering of subscripts must be preserved */\n\t\t\t\t\t\t$$ = _NclMakeNewListNode();\n\t\t\t\t\t\t$$->next = NULL;\n\t\t\t\t\t\t$$->node = $1;\n\t\t\t\t\t}\n\t| LBC subscript1 RBC \t\t{\n\t\t\t\t\t/* ordering of subscripts must be preserved */\n                                                $$ = _NclMakeNewListNode();\n                                                $$->next = NULL;\n                                                $$->node = $2;\n\t\t\t\t\t}\n\t| normal_subscript_list ',' subscript0 {\n\t\t\t\t\t\tNclSrcListNode *step;\n                                                \n                                                step = $1;\n\t\t\t\t\t\tif(!is_error){\n                                                \twhile(step->next != NULL) \n                                                        \tstep = step->next;\n                                                \tstep->next = _NclMakeNewListNode();\n                                                \tstep->next->next = NULL;\n                                                \tstep->next->node = $3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t| normal_subscript_list ',' LBC subscript1 RBC {\n\t\t\t\t\t\tNclSrcListNode *step;\n                                         \n                                                step = $1;\n\t\t\t\t\t\tif(!is_error){\n                                                \twhile(step->next != NULL)\n                                                        \tstep = step->next;\n                                                \tstep->next = _NclMakeNewListNode();\n                                                \tstep->next->next = NULL;\n                                                \tstep->next->node = $4;\n\t\t\t\t\t\t}\n                                                \n\t\t\t\t\t}\n\t| normal_subscript_list ',' error {\n\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t  \"Error in subscript, normal subscripting is being used, make sure named subscripting has not been used\");\n\t\t\t\t\tis_error += 1;\n\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\n\n\t\t\t\t}\n;\n\nsubscript0:  subexpr \t\t\t{  \n\t\t\t\t\t\t$$ = _NclMakeIntSubscript($1,NULL);\n\t\t\t\t\t\t \n\t\t\t\t\t}\n;\nsubscript2:  DIM subexpr\t\t\t{ \n\t\t\t\t\t\t$$ = _NclMakeIntSubscript($2,_NclMakeStringExpr($1));\n\t\t\t\t\t\t  \n\t\t\t\t\t}\n\t|  EFSTRING primary EFSTRING \"|\" subexpr {\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeIntSubscript($5,$2);\n\t\t\t\t\t}\n;\n\nsubscript1:  subexpr\t \t\t{  \n\t\t\t\t\t\t$$ = _NclMakeCoordSubscript($1,NULL);\n\t\t\t\t\t\t \n\t\t\t\t\t}\n;\nsubscript3:  DIM subexpr\t\t\t{ \n\t\t\t\t\t\t$$ = _NclMakeCoordSubscript($2,_NclMakeStringExpr($1));\n\t\t\t\t\t\t  \n\t\t\t\t\t}\n\t|  EFSTRING primary EFSTRING \"|\" subexpr {\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeCoordSubscript($5,$2);\n\t\t\t\t\t}\n\n;\n\nsubexpr: expr\t\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t$$ = _NclMakeSingleIndex($1);\n\t\t\t\t\t}\n\t|  COLON \t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,NULL,NULL);\n\t\t\t\t\t}\n\t| expr COLON expr\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,$3,NULL);\n\t\t\t\t\t}\n\t| COLON expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,$2,NULL);\n\t\t\t\t\t}\n\t| expr COLON \t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,NULL,NULL);\n\t\t\t\t\t}\n\t| expr COLON expr COLON \t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,$3,NULL);\n\t\t\t\t\t}\n\t| COLON expr COLON \t\t{\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,$2,NULL);\n\t\t\t\t\t}\n\t| expr COLON COLON\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,NULL,NULL);\n\t\t\t\t\t} \n\t| expr COLON expr COLON expr\t{\t\t\t\t\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t_NclValOnly($5);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,$3,$5);\n\t\t\t\t\t}\n\t| expr COLON COLON expr\t\t{\t\t\t\t\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($4);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex($1,NULL,$4);\n\t\t\t\t\t}\n\t| COLON expr COLON expr\t\t{\t\t\t\t\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t_NclValOnly($4);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,$2,$4);\n\t\t\t\t\t}\n\t| COLON COLON \t\t\t{\t\t\t\t\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,NULL,NULL);\n\t\t\t\t\t}\n\t| COLON COLON expr\t\t{\t\t\t\t\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeRangeIndex(NULL,NULL,$3);\n\t\t\t\t\t}\n/*\n\t| '*'\t\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeWildCardIndex();\n\t\t\t\t\t}\n*/\n;\nexpr :  primary\t\t\t\t{\n\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t}\n\t| '-' expr %prec UNOP\t\t{\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeUnaryExpr($2,Ncl_NEGEXPR);\n\t\t\t\t\t}\n\t| NOT expr %prec UNOP\t\t{\n\t\t\t\t\t\t_NclValOnly($2);\n\t\t\t\t\t\t$$ = _NclMakeUnaryExpr($2,Ncl_NOTEXPR);\n\t\t\t\t\t}\n\t| expr '%' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_MODEXPR);\n\t\t\t\t\t}\n\t| expr OR expr \t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_OREXPR);\n\t\t\t\t\t} \n\t| expr AND expr\t\t\t{\t\t\t\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_ANDEXPR);\n\t\t\t\t\t}\n\t| expr XOR expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_XOREXPR);\n\t\t\t\t\t}\n\t| expr '<' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_LTSELECTEXPR);\n\t\t\t\t\t}\n\t| expr '>' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_GTSELECTEXPR);\n\t\t\t\t\t}\n\t| expr '+' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_PLUSEXPR);\n\t\t\t\t\t}\n\t| expr '-' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_MINUSEXPR);\n\t\t\t\t\t}\n\t| expr '*' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_MULEXPR);\n\t\t\t\t\t}\n\t| expr '#' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_MATMULEXPR);\n\t\t\t\t\t}\n\t| expr '/' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_DIVEXPR);\n\t\t\t\t\t}\n\t| expr '^' expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_EXPEXPR);\n\t\t\t\t\t}\n\t| expr LE  expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_LEEXPR);\n\t\t\t\t\t}\n\t| expr GE expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_GEEXPR);\n\t\t\t\t\t}\n\t| expr GT expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_GTEXPR);\n\t\t\t\t\t}\n\t| expr LT expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_LTEXPR);\n\t\t\t\t\t}\n\t| expr EQ expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_EQEXPR);\n\t\t\t\t\t}\n\t| expr NE expr\t\t\t{\n\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeExpr($1,$3,Ncl_NEEXPR);\n\t\t\t\t\t}\n;\n\nanysym : FLOAT {\n\t\t$$ = $1;\n\t}\n\t| INTEGER {\n\t\t$$ = $1;\n\t}\n\t| UINT {\n\t\t$$ = $1;\n\t}\n\t| LONG {\n\t\t$$ = $1;\n\t}\n\t| ULONG {\n\t\t$$ = $1;\n\t}\n\t| INT64 {\n\t\t$$ = $1;\n\t}\n\t| UINT64 {\n\t\t$$ = $1;\n\t}\n\t| DOUBLE {\n\t\t$$ = $1;\n\t}\n\t| BYTE {\n\t\t$$ = $1;\n\t}\n\t| UBYTE {\n\t\t$$ = $1;\n\t}\n\t| CHARACTER {\n\t\t$$ = $1;\n\t}\n\t| GRAPHIC {\n\t\t$$ = $1;\n\t}\n\t| STRNG {\n\t\t$$ = $1;\n\t}\n\t| GROUP {\n\t\t$$ = $1;\n\t}\n\t| COMPOUND {\n\t\t$$ = $1;\n\t}\n\t| NUMERIC {\n\t\t$$ = $1;\n\t}\n\t| ENUMERIC {\n\t\t$$ = $1;\n\t}\n\t| SNUMERIC {\n\t\t$$ = $1;\n\t}\n\t| FILETYPE {\n\t\t$$ = $1;\n\t}\n\t| GROUPTYPE {\n\t\t$$ = $1;\n\t}\n\t| SHORT {\n\t\t$$ = $1;\n\t}\n\t| USHORT {\n\t\t$$ = $1;\n\t}\n\t| LOGICAL {\n\t\t$$ = $1;\n\t}\n\t| UNDEF {\n\t\t$$ = $1;\n\t}\n\t| VAR {\n\t\t$$ = $1;\n\t}\n\t| WHILE {\n\t\t$$ = $1;\n\t}\n\t| DO {\n\t\t$$ = $1;\n\t}\n\t| QUIT  {\n\t\t$$ = $1;\n\t}\n\t| NPROC {\n\t\t$$ = $1;\n\t}\n\t| PIPROC {\n\t\t$$ = $1;\n\t}\n\t| IPROC {\n\t\t$$ = $1;\n\t}\n\t| UNDEFFILEVAR {\n\t\t$$ = $1;\n\t}\n\t| UNDEFFILEGROUP {\n\t\t$$ = $1;\n\t}\n\t| BREAK {\n\t\t$$ = $1;\n\t}\n\t| NOPARENT {\n\t\t$$ = $1;\n\t}\n\t| BGIN {\n\t\t$$ = $1;\n\t}\n\t| END {\n\t\t$$ = $1;\n\t}\n\t| NFUNC {\n\t\t$$ = $1;\n\t}\n\t| IFUNC {\n\t\t$$ = $1;\n\t}\n\t| FDIM {\n\t\t$$ = $1;\n\t}\n\t| IF {\n\t\t$$ = $1;\n\t}\n\t| THEN {\n\t\t$$ = $1;\n\t}\n\t| VBLKNAME {\n\t\t$$ = $1;\n\t}\n\t| CONTINUE {\n\t\t$$ = $1;\n\t}\n\t| DFILE {\n\t\t$$ = $1;\n\t}\n\t| KEYFUNC {\n\t\t$$ = $1;\n\t}\n\t| KEYPROC {\n\t\t$$ = $1;\n\t}\n\t| ELSE {\n\t\t$$ = $1;\n\t}\n\t| EXTERNAL {\n\t\t$$ = $1;\n\t}\n\t| NCLEXTERNAL {\n\t\t$$ = $1;\n\t}\n\t| RETURN {\n\t\t$$ = $1;\n\t}\n\t| VSBLKGET {\n\t\t$$ = $1;\n\t}\n\t| NEW {\n\t\t$$ = $1;\n\t}\n\t| OBJVAR {\n\t\t$$ = $1;\n\t}\n\t| OBJTYPE {\n\t\t$$ = $1;\n\t}\n\t| RECORD {\n\t\t$$ = $1;\n\t}\n\t| VSBLKCREATE {\n\t\t$$ = $1;\n\t}\n\t| VSBLKSET {\n\t\t$$ = $1;\n\t}\n\t| LOCAL {\n\t\t$$ = $1;\n\t}\n\t| STOP {\n\t\t$$ = $1;\n\t}\n\t| NCLTRUE {\n\t\t$$ = $1;\n\t}\n\t| NCLFALSE {\n\t\t$$ = $1;\n\t}\n\t| NCLMISSING {\n\t\t$$ = $1;\n\t}\n\t| DLIB {\n\t\t$$ = $1;\n\t}\n;\n\nprimary : REAL\t\t\t\t{\n/*\n* Note all of the structures created below the primary rule are special! They\n* contain the ref_type field which is used to determine if the item\n* is a parameter to a function or a procedure. The LP expr RP is an\n* exception\n*/\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeRealExpr($1,yytext));\n\t\t\t\t\t}\n\t| INT\t\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeIntExpr($1,yytext));\n\t\t\t\t\t}\n\t| NCLTRUE\t\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeLogicalExpr(1,yytext));\n\t\t\t\t\t}\n\t| NCLFALSE \t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeLogicalExpr(0,yytext));\n\t\t\t\t\t}\n\t| NCLMISSING \t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeLogicalExpr(-1,yytext));\n\t\t\t\t\t}\n\t| STRING\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr(_NclMakeStringExpr($1));\n\t\t\t\t\t\tNclFree($1);\n\t\t\t\t\t}\n\t| function\t\t\t{\t\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr($1);\n\t\t\t\t\t}\n\t| identifier\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr($1);\n\t\t\t\t\t}\n\t| array \t\t \t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr($1);\n\t\t\t\t\t}\n\t| listvar \t\t \t{\n\t\t\t\t\t\t$$ = _NclMakeIdnExpr($1);\n\t\t\t\t\t}\n\t| vcreate\t\t\t{\n\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t}\n\t| LP expr RP\t\t\t{ \n\t\t\t\t\t\t$$ = $2;\n\t\t\t\t\t}\n\t| NEW LP expr ',' datatype ',' expr RP\t{\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t_NclValOnly($7);\n\t\t\t\t\t\t$$ = _NclMakeNewOp($3,$5,$7);\n\t\t\t\t\t}\n\t| NEW LP expr ',' datatype RP\t{\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeNewOp($3,$5,NULL);\n\t\t\t\t\t}\n\t| NEW LP expr ',' expr ',' expr RP\t{\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t_NclValOnly($5);\n\t\t\t\t\t\t_NclValOnly($7);\n\t\t\t\t\t\t$$ = _NclMakeExprNewOp($3,$5,$7);\n\t\t\t\t\t}\n\t| NEW LP expr ',' expr RP\t{\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t_NclValOnly($5);\n\t\t\t\t\t\t$$ = _NclMakeExprNewOp($3,$5,NULL);\n\t\t\t\t\t}\n\t| LBK expr RBK\t\t\t{ \n\t\t\t\t\t\t$$ = $2;\n\t\t\t\t\t}\n\t| NEW LBK expr ',' datatype RBK\t{\n\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t$$ = _NclMakeNewOp($3,$5,NULL);\n\t\t\t\t\t}\n\t| NCLNULL\t\t\t{\n\t\t\t\t\t\t$$ = _NclMakeNULLNode();\n\t\t\t\t\t}\n;\n\n\t\n\n\nfunction:  IFUNC opt_arg_list\t\t{\n\t\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\n\t\t\t\t\t\tstep = $2;\n\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(count != $1->u.procfunc->nargs) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,count);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFuncCall($1,$2,Ncl_INTRINSICFUNCCALL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| NFUNC opt_arg_list\t\t{\n\t\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\n\t\t\t\t\t\tstep = $2;\n\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(count != $1->u.procfunc->nargs) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,count);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFuncCall($1,$2,Ncl_FUNCCALL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| IFUNC \t\t\t\t{\n\t\t\t\t\t\tif($1->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,0);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFuncCall($1,NULL,Ncl_INTRINSICFUNCCALL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| NFUNC \t\t\t{\n\t\t\t\t\t\tif($1->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t  $1->name,$1->u.procfunc->nargs,0);\n\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = _NclMakeFuncCall($1,NULL,Ncl_FUNCCALL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t| DLIB COLON COLON anysym\t\t{\n\t\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\t\tif($1->u.package != NULL) {\n\t\t\t\t\t\t\ts = _NclLookUpInScope($1->u.package->scope,$4->name);\n\t\t\t\t\t\t\tif(s == NULL) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s is not defined in package %s\\n\",\n\t\t\t\t\t\t\t\t\t  $4->name,$1->name);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else if(s->type == IFUNC){\n\t\t\t\t\t\t\t\tif(s->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,0);\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeFuncCall(s,NULL,Ncl_INTRINSICFUNCCALL); \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(s->type == NFUNC) {\n\t\t\t\t\t\t\t\tif(s->u.procfunc->nargs != 0) {\n\t\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,0);\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeFuncCall(s,NULL,Ncl_FUNCCALL); \n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: %s is not a function in package %s\\n\",\n\t\t\t\t\t\t\t\t\t  $4->name,$1->name);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\n\t| DLIB COLON COLON anysym opt_arg_list\t{\n\t\t\t\t\t\tNclSrcListNode *step;\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tNclSymbol *s;\n\t\t\t\t\t\tif($1->u.package != NULL) {\n\t\t\t\t\t\t\ts = _NclLookUpInScope($1->u.package->scope,$4->name);\n\t\t\t\t\t\t\tif(s == NULL) {\n\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: procedure %s is not defined in package %s\\n\",\n\t\t\t\t\t\t\t\t\t  $4->name,$1->name);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t} else if(s->type == IFUNC){\n\t\t\t\t\t\t\t\tstep = $5;\n\t\t\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(count != s->u.procfunc->nargs) {\n\t\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,count);\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeFuncCall(s,$5,Ncl_INTRINSICFUNCCALL); \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(s->type == NFUNC) {\n\t\t\t\t\t\t\t\tstep = $5;\n\t\t\t\t\t\t\t\twhile(step != NULL) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\tstep = step->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(count != s->u.procfunc->nargs) {\n\t\t\t\t\t\t\t\t\tis_error += 1;\n\t\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t\t  \"syntax error: function %s expects %d arguments, got %d\",\n\t\t\t\t\t\t\t\t\t\t  s->name,s->u.procfunc->nargs,count);\n\t\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n\t\t\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$$ = _NclMakeFuncCall(s,$5,Ncl_FUNCCALL); \n\t\t\t\t\t\t\t\t}\n                                                \t} else {\n                                                        \tNhlPError(NhlFATAL,NhlEUNKNOWN,\n\t\t\t\t\t\t\t\t\t  \"syntax error: %s is not a function in package %s\\n\",$4->name,$1->name);\n\t\t\t\t\t\t\t\tPRINTLOCATION(NhlFATAL);\n                                                        \t$$ = NULL;\n                                                \t}\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$ = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n;\narray : LPSLSH expr_list SLSHRP\t { \n\t\t\t\t\t\t\t$$ = _NclMakeArrayNode($2);\n\t\t\t\t\t\t\t \n\t\t\t\t\t}\n\n;\nlistvar : LBKSLSH list_expr_list SLSHRBK\t{ \n\t\t\t\t\t\t\t$$ = _NclMakeListVarNode($2);\n\t\t\t\t\t}\n\n;\nlist_expr_list :  expr\t\t\t\t{\t\n\t\t\t\t\t\t\t$$ = _NclMakeRowList();\n\t\t\t\t\t\t\t$$->list = _NclMakeNewListNode();\n\t\t\t\t\t\t\t$$->list->next = NULL;\n\t\t\t\t\t\t\t$$->list->node = $1;\n\t\t\t\t\t\t\t$$->currentitem= NULL; \n\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t}\n\t| list_expr_list ',' expr   \t\t{ \n\t\t\t\t\t\t/* pushed on backwards so they can be popped of in correct order*/\n\t\t\t\t\t\t\tif($1 == NULL) {\n\t\t\t\t\t\t\t\t$$ = _NclMakeRowList();\n\t\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t\t\t$$->list = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->list->next = NULL;\n\t\t\t\t\t\t\t\t$$->list->node = $1;\n\t\t\t\t\t\t\t\t$$->currentitem= NULL; \n\t\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNclSrcListNode *tmp;\n\n\t\t\t\t\t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\ttmp->next = $1->list;\n\t\t\t\t\t\t\t\ttmp->node = $3;\n\t\t\t\t\t\t\t\t$1->list = tmp;\n\t\t\t\t\t\t\t\t$1->nelem++;\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n;\nexpr_list :  expr\t\t\t\t{\t\n\t\t\t\t\t\t\t_NclValOnly($1);\n\t\t\t\t\t\t\t$$ = _NclMakeRowList();\n\t\t\t\t\t\t\t$$->list = _NclMakeNewListNode();\n\t\t\t\t\t\t\t$$->list->next = NULL;\n\t\t\t\t\t\t\t$$->list->node = $1;\n\t\t\t\t\t\t\t$$->currentitem= NULL; \n\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t}\n\t| expr_list ',' expr   \t\t{ \n\t\t\t\t\t\t/* pushed on backwards so they can be popped of in correct order*/\n\t\t\t\t\t\t\t_NclValOnly($3);\n\t\t\t\t\t\t\tif($1 == NULL) {\n\t\t\t\t\t\t\t\t$$ = _NclMakeRowList();\n\t\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t\t\t$$->list = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\t$$->list->next = NULL;\n\t\t\t\t\t\t\t\t$$->list->node = $1;\n\t\t\t\t\t\t\t\t$$->currentitem= NULL; \n\t\t\t\t\t\t\t\t$$->nelem = 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNclSrcListNode *tmp;\n\n\t\t\t\t\t\t\t\ttmp = _NclMakeNewListNode();\n\t\t\t\t\t\t\t\ttmp->next = $1->list;\n\t\t\t\t\t\t\t\ttmp->node = $3;\n\t\t\t\t\t\t\t\t$1->list = tmp;\n\t\t\t\t\t\t\t\t$1->nelem++;\n\t\t\t\t\t\t\t\t$$ = $1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n;\n%%\nyyerror\n#if __STDC__\n(char *s)\n#else \n(s)\n\tchar *s;\n#endif\n{\n\textern int is_error;\n\tint i,len;\n\tchar error_buffer[1024];\n\t\n\n\tis_error += 1;\n\n\tif(is_error < NCL_MAX_ERROR) {\n\t\tif(yytext[0] == '\\n' || (yytext[0] == '\\r' && yytext[1] == '\\n')) {\n\t\t\tsprintf(error_buffer,\"%s\\n\",cur_line_text);\n\t\t\tlen = strlen(error_buffer);\n\t\t\tfor(i=0; i<last_line_length-1;i++) sprintf(&(error_buffer[len+i]),\"-\");\n\t\t\tsprintf(&(error_buffer[len+last_line_length-1]),\"^\");\n\t\t\tif(loading > 0) {\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d in file %s before or near \\\\n \\n%s\\n\",s,cur_line_number,cur_load_file,error_buffer);\n\t\t\t} else if(cmd_line){\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d before or near \\\\n \\n%s\\n\",s,cur_line_number,error_buffer);\n\t\t\t} else {\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d before or near \\\\n \\n%s\\n\",s,cur_line_number,error_buffer);\n\t\t\t} \n\t\t} else {\n\t\t\tsprintf((char*)&(error_buffer[0]),\"%s\\n\",cur_line_text);\n\t\t\tlen = strlen(error_buffer);\n\t\t\tfor(i=0; i<cur_line_length-1;i++) sprintf(&(error_buffer[len+i]),\"-\");\n\t\t\tsprintf(&(error_buffer[len+cur_line_length-1]),\"^\");\n\t\t\tif(loading > 0) {\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d in file %s before or near %s \\n%s\\n\",s,cur_line_number,cur_load_file,yytext,error_buffer);\n\t\t\t} else if(cmd_line){\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d before or near %s \\n%s\\n\",s,cur_line_number,yytext,error_buffer);\n\t\t\t} else {\n\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"%s: line %d before or near %s \\n%s\\n\",s,cur_line_number,yytext,error_buffer);\n\t\t\t}\n\t\t}\n\t} else if((is_error == NCL_MAX_ERROR)&&(cmd_line != 2)) {\n\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Maximum number of errors exceeded, terminating\");\n\t\t\t_NclExit(0);\n\t} else {\n/*\n* GUI STUFF\n*/\n\t}\n\treturn(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/ncl/NclDriver.c": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include   \"NclDriver.h\"\n\nint NclReturnStatus = NclNoError;\n\nint quark_comp(const void *q1, const void *q2)\n{\n\treturn(strcmp((const char*)NrmQuarkToString(*(NrmQuark *)q1),(const char*)NrmQuarkToString(*(NrmQuark *) q2)));\n}\n\nstatic int numberOfPreloadedScripts = 11;\n\nchar *preload_scripts[11] = {\"$NCARG_ROOT/lib/ncarg/nclscripts/utilities.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/gsn_code.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/gsn_csm.ncl\", /* must be loaded after gsn_code.ncl */\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/contributed.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/shea_util.ncl\", /* must be loaded after contributed.ncl */\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/esmf/ESMF_regridding.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/bootstrap.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/extval.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/crop.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/csm/heat_stress.ncl\",\n                             \"$NCARG_ROOT/lib/ncarg/nclscripts/wrf/WRFUserARW.ncl\" /* must be loaded after contributed.ncl */};\n\nint NclDriver(int argc, char **argv)\n{\n    int errid = -1;\n    int appid;\n    int i, k = 0;\n    int reset = 1;\n    short echoUserScript = 0;\n    DIR *d;\n    struct dirent   *ent;\n#if defined(HPUX)\n    shl_t so_handle;\n#else\n    void *so_handle;\n#endif /* defined(HPUX) */\n\n    char buffer[4 * NCL_MAX_STRING];\n    void (*init_function) (void);\n    char    *libpath;\n    char    *scriptpath;\n    char    *pt;\n    char    *tmp = NULL;\n\n    /*\n     * Variables for command line options/arguments\n     */\n\n#ifdef NCLDEBUG\n    char    **NCL_ARGV;\n    int NCL_ARGC;           /* local argv/argc -- future use for NCL scripts? */\n#endif\n\n    int c;\n\n    char    **cargs = NULL;\n    int nargs = 0;\n\n    struct stat sbuf;\n    int sr;\n\n    FILE    *tmpf = NULL;   /* file variables for creating arguments */\n    char    *tmpd = NULL;\n\n#ifdef YYDEBUG\n    extern int yydebug;\n    yydebug = 1;\n#endif /* YYDEBUG */\n\n#ifdef _OPENMP\n    /* make sure that only one OMP thread runs unless OMP_NUM_THREADS is explicitly defined  -- on Darwin at least the default is not a single thread */\n\n    if (! getenv(\"OMP_NUM_THREADS\")) {\n\t    omp_set_num_threads(1);\n    }\n#endif\n\n    strcpy(buffer,(char *)GetNCARGPath(\"tmp\"));\n    sr = access(buffer,W_OK|X_OK|F_OK);\n    if(sr != 0) {\n\t    NhlPError(NhlWARNING,NhlEUNKNOWN,\n\t\t      \"\\\"%s\\\" tmp dir does not exist or is not writable: NCL functionality may be limited -- check TMPDIR environment variable\",\n\t\t      buffer);\n    }\n\n    InitStdStreams(stdin, stdout, stderr);\n\t\n    ncopts = NC_VERBOSE;\n\n    cmd_line =isatty(fileno(stdin));\n\n#ifdef NCLDEBUG\n    /*\n     * Save NCL argv, for command line processing later use\n     */\n    NCL_ARGV = (char **) NclMalloc(argc  * sizeof(char *));\n    for (i = 0; i < argc; i++) {\n        NCL_ARGV[i] =  (char *) NclMalloc((strlen(argv[i]) + 1) * sizeof(char *));\n        (void) strcpy(NCL_ARGV[i], argv[i]);\n    }\n    NCL_ARGC = argc;\n\n    for (i = 0; i < NCL_ARGC; i++, *NCL_ARGV++)\n        (void) printf(\"NCL_ARGV[%d] = %s\\n\", i, *NCL_ARGV);\n#endif /* NCLDEBUG */\n\n    /*\n     * Defined arguments\n     *\n     *  -n      element print: don't enumerate elements in print()\n     *  -x      echo: turns on command echo\n     *  -Q      turn off echo of copyright and version information\n     *  -V      version: output NCARG/NCL version, exit\n     *  -m      turns on memory debug\n     *  -o      old behavior: retain former behavior for backwards incompatible changes\n     *  -h      help: output options and exit\n     *  -s      disable pre-loading of default script files\n     *\n     *  -X      override: echo every stmt regardless (unannounced option)\n     *  -Q      override: don't echo copyright notice (unannounced option)\n     */\n    opterr = 0;     /* turn off getopt() msgs */\n    while ((c = getopt (argc, argv, \"fhnodgmxVXQpsP\")) != -1) {\n        switch (c) {\n            case 'p':\n                NCLnoSysPager = 1;\n                break;\n\n            case 'n':\n                NCLnoPrintElem = 1;\n                break;\n\n            case 'o':\n                NCLoldBehavior = 1;\n                break;\n\n            case 'x':\n                echoUserScript = 1;\n                break;\n\n            case 's':\n\t\tNCLnoPreload = 1;\n                break;\n\n#ifdef NCLDEBUG\n            case 'm':\n                NCLdebug_on = 1;\n                break;\n\n            case 'd':\n                NCLdebug_on = 2;\n                break;\n\n            case 'g':\n                NCLdebug_on = 3;\n                break;\n\n#endif\n            /* NOT ADVERTISED!  Will override \"no echo\" and print EVERYTHING! */\n            case 'X':\n                NCLoverrideEcho = 1;\n                break;\n\n            /* NOT ADVERTISED!  Will not echo copyright notice! */\n            case 'Q':\n                NCLnoCopyright = 1;\n                break;\n\n            case 'V':\n                (void) fprintf(stdout, \"%s\\n\", GetNCLVersion());\n                exit(0);\n                break;\n\n            case 'f':\n                NCLuseAFS = 1;\n                break;\n\n            case 'P':\n                NCLprofiler = 1;\n                break;\n\n            case 'h':\n                (void) fprintf(stdout, \"Usage: ncl -fhnopxsPQV <args> <file.ncl>\\n\");\n\t        (void) fprintf(stdout, \"\\t -f: use new file structure and NetCDF4 features when possible\\n\");\n                (void) fprintf(stdout, \"\\t -h: print this message and exit\\n\");\n                (void) fprintf(stdout, \"\\t -n: don't enumerate values in print()\\n\");\n                (void) fprintf(stdout, \"\\t -o: retain former behavior for certain backwards-incompatible changes\\n\");\n                (void) fprintf(stdout, \"\\t -p: don't page output from the system() command\\n\");\n                (void) fprintf(stdout, \"\\t -x: echo NCL commands\\n\");\n                (void) fprintf(stdout, \"\\t -s: disable pre-loading of default script files\\n\");\n                (void) fprintf(stdout, \"\\t -P: enable NCL profiler\\n\");\n                (void) fprintf(stdout, \"\\t -Q: turn off echo of NCL version and copyright info\\n\");\n                (void) fprintf(stdout, \"\\t -V: print NCL version and exit\\n\");\n#ifdef NCLDEBUG\n                (void) fprintf(stdout, \"\\t -m: turns on memory debug.\\n\");\n                (void) fprintf(stdout, \"\\t -d: turns on detailed memory debug.\\n\");\n                (void) fprintf(stdout, \"\\t -g: turns on deep detailed memory debug.\\n\");\n#endif\n                exit(0);\n                break;\n\n           case '?':\n                if (isprint(optopt))\n                    (void) fprintf(stderr, \"Unknown option `-%c'\\n\", optopt);\n                else\n                    (void) fprintf(stderr, \"Unknown option character `\\\\x%x'\\n\", optopt);\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    /*\n     * Announce NCL copyright notice, etc.\n     */\n    if (!NCLnoCopyright) \n        (void) fprintf(stdout,\n            \" Copyright (C) 1995-2019 - All Rights Reserved\\n University Corporation for Atmospheric Research\\n NCAR Command Language Version %s\\n The use of this software is governed by a License Agreement.\\n See http://www.ncl.ucar.edu/ for more details.\\n\", GetNCLVersion());\n\n    if (NCLnoPreload) {\n\t    numberOfPreloadedScripts = 0;\n    }\n\n    /* Process any user-defined arguments */\n    for (i = optind; i < argc; i++) {\n#ifdef NCLDEBUG\n        (void) printf(\"Non-option argument %s\\n\", argv[i]);\n#endif /* NCLDEBUG */\n\n        /*\n         * Is this a file of NCL commands?  Can't assume \".ncl\" tag, unfortunately.\n         * Check for file's existence; the stat() call does not require access rights\n         * but does require search path rights, so if this fails, the file could exist\n         * but the user may not have permission to \"see\" it.\n         */\n        sr = stat(argv[i], &sbuf);\n        if (sr == 0) {\n#ifdef NCLDEBUG\n            (void) printf(\"NCL commands file: %s\\n\", argv[i]);\n#endif /* NCLDEBUG */\n            nclf = argv[i];\n            continue;\n        }\n\n        if (sr < 0) {\n            if (!strchr(argv[i], '=')) {\n                /* argument is intended to be a file; can't locate it */\n                NhlPError(NhlFATAL, NhlEUNKNOWN, \" can't find file \\\"%s\\\"\\n\", argv[i]);\n                exit(NhlFATAL);\n            } else {\n                /* user-defined argument */\n                if (nargs == 0)\n                    cargs = (char **) NclMalloc(sizeof(char *));\n                else\n                    cargs = (char **) NclRealloc(cargs, (nargs + 1) * sizeof(char *));\n\n                cargs[nargs] = (char *) NclMalloc((strlen(argv[i]) + 2) * sizeof(char *));\n                (void) sprintf(cargs[nargs], \"%s\\n\", argv[i]);\n                nargs++;\n            }\n        }\n    }\n\n\tif(nclf){\n\t\tNCL_PROF_INIT(nclf);\n\t}\n\telse{\n\t\tNCL_PROF_INIT(\"cmdline\");\n\t}\n\n    cur_line_text = NclMalloc((unsigned int) 512);\n    cur_line_maxsize = 512;\n    cur_line_text_pos = &(cur_line_text[0]);\n\n#ifdef NCLDEBUG\n    thefptr = fopen(\"ncl.tree\", \"w\");\n    theoptr = fopen(\"ncl.seq\", \"w\");\n#else\n    thefptr = NULL;\n    theoptr = NULL;\n#endif /* NCLDEBUG */\n\n    /*\n     * Note: child processes should use _exit() instead of exit() to avoid calling the atexit()\n     * functions prematurely \n     */\n\n    NhlInitialize();\n    NhlVACreate(&appid, \"ncl\", NhlappClass, NhlDEFAULT_APP,\n        NhlNappDefaultParent, 1, NhlNappUsrDir, \"./\", NULL);\n    NhlPalLoadColormapFiles(NhlworkstationClass,False);\n    errid = NhlErrGetID();\n    NhlVAGetValues(errid, NhlNerrFileName, &tmp, NULL);\n\t\n    if ((tmp == NULL) || (!strcmp(tmp, \"stderr\")))\n        NhlVASetValues(errid, NhlNerrFilePtr, stdout, NULL);\n\n    _NclInitMachine();\n    _NclInitSymbol();\t\n    _NclInitTypeClasses();\n    _NclInitDataClasses();\n    _NclInitFileClasses();\n    /* if the -o flag is specified do stuff to make NCL backwards compatible */\n    if (NCLoldBehavior) {\n\t    _NclSetDefaultFillValues(NCL_5_DEFAULT_FILLVALUES);\n    }\n\n    /* Handle default directories */\n    if ((libpath = getenv(\"NCL_DEF_LIB_DIR\")) != NULL) {\n        d = opendir(_NGResolvePath(libpath));\n        if (d != NULL) {\n            while((ent = readdir(d)) != NULL) {\n                if (*ent->d_name != '.') {\n                    (void) sprintf(buffer, \"%s/%s\", _NGResolvePath(libpath), ent->d_name);\n#if defined (HPUX)\n                    so_handle = shl_load(buffer, BIND_IMMEDIATE, 0L);\n#else\n                    so_handle = dlopen(buffer, RTLD_NOW);\n                    if (so_handle == NULL) {\n                        NhlPError(NhlFATAL, NhlEUNKNOWN,\n                            \"Could not open (%s): %s.\", buffer, dlerror());\n                    }\n#endif /* HPUX */\n           \n                    if (so_handle != NULL) {\n#if defined (HPUX)\n                        init_function = NULL;\n                        (void) shl_findsym(&so_handle, \"Init\",\n                                TYPE_UNDEFINED, (void *) &init_function);\n#else\n                        init_function = dlsym(so_handle, \"Init\");\n#endif /* HPUX */\n                        if (init_function != NULL) {\n                            (*init_function)();\n                        } else {\n#if defined (HPUX)\n                            shl_unload(so_handle);\n#else\n                            dlclose(so_handle);\n#endif /* HPUX */\n                            NhlPError(NhlWARNING, NhlEUNKNOWN,\n                                \"Could not find Init() in external file %s, file not loaded.\",\n                                buffer);\n                        }\n                    } \n                }\n            }\n        } else {\n            NhlPError(NhlWARNING, NhlEUNKNOWN,\n                \"Could not open default library path (%s), no libraries loaded.\", libpath);\n        }\n        _NclResetNewSymStack();\n    }\n\n    if (cmd_line == 1) {\n        InitializeReadLine(1);\n/*\n * This next line is only to deal with an optimization bug with gcc\n * version 4.0.1 on MacOS 10.4. It apparently saw that \"cmd_line\"\n * was already of value 1 before it went into NclSetPromptFunc, so \n * when it optimized the code, it ignored the \"cmd_line = 1\" line\n * right after the NclSetPromptFunc call.  Since NclSetPrompFunc\n * was setting cmd_line =2, this meant that the value of cmd_line\n * stayed 2, which is the wrong value.\n */\n        cmd_line = 0;\n        NclSetPromptFunc(nclprompt, NULL);\n        cmd_line = 1;\n        cmd_line_is_set = 1;\n    } else {\n        InitializeReadLine(0);\n    }\n\t\n    /* Load default scripts */\n    /* These need to be loaded in alphabetical order to ensure that users can control\n     * the order of loading. There is a BSD function scandir that would do it all but it \n     * might not be standardized enough to be uniformly available on all systems, so for\n     * now it must be coded just using readdir.\n     */\n    \n    if ((scriptpath = getenv(\"NCL_DEF_SCRIPTS_DIR\")) != NULL) {\n\t    d = opendir(_NGResolvePath(scriptpath));\n\t    if (d!= NULL) {\n\t\t    int script_count = 0, alloc_count = 32;\n\t\t    NrmQuark *qscript_names = NclMalloc(alloc_count * sizeof(NrmQuark));\n\t\t    while((ent = readdir(d)) != NULL) {\n\t\t\t    if (*ent->d_name != '.') {\n\t\t\t\t    (void) sprintf(buffer, \"%s/%s\", _NGResolvePath(scriptpath), ent->d_name);\n\t\t\t\t    pt = strrchr(buffer, '.');\n\t\t\t\t    if (pt != NULL) {\n\t\t\t\t\t    pt++;\n\t\t\t\t\t    if (strncmp(pt, \"ncl\", 3) == 0) {\n\t\t\t\t\t\t    if (script_count == alloc_count) {\n\t\t\t\t\t\t\t    alloc_count *= 2;\n\t\t\t\t\t\t\t    qscript_names = NclRealloc(qscript_names,alloc_count * sizeof(NrmQuark));\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    qscript_names[script_count++] = NrmStringToQuark(ent->d_name);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t\t    if (script_count == 0)  {\n\t\t\t    NhlPError(NhlWARNING, NhlEUNKNOWN,\n\t\t\t\t      \"No scripts found: scripts must have the \\\".ncl\\\" file extension.\");\n\t\t    }\n\t\t    else {\n\t\t\t    qsort(qscript_names,script_count,sizeof(NrmQuark),quark_comp);\n\t\t\t    for (i = 0; i < script_count; i++) {\n\t\t\t\t    (void) sprintf(buffer, \"%s/%s\", _NGResolvePath(scriptpath), NrmQuarkToString(qscript_names[i]));\n\t\t\t\t    if (_NclPreLoadScript(buffer, 1) == NhlFATAL) {\n\t\t\t\t\t    NhlPError(NhlFATAL, NhlEUNKNOWN, \"Error loading default script.\");\n\t\t\t\t    } else {\n\t\t\t\t\t    yyparse(reset);\n\t\t\t\t    }\n\t\t\t    }\n\t\t\t    NclFree(qscript_names);\n\t\t    }\n\t    } else {\n\t\t    NhlPError(NhlWARNING, NhlEUNKNOWN,\n\t\t\t      \" Could not open default script path (%s), no scripts loaded.\", scriptpath);\n\t    }\n    }\n\n    /*\n     * Create the new args\n     *\n     * Ideally this would be done using calls to the parser/stack engine but there is\n     * no clean interface to that process.  Investigate _NclParseString() in the future.\n     *\n     * For now, create a temporary file with NCL commands and execute it.\n     */\n    if (nargs) {\n        cmd_line = 0;   /* non-interactive */\n        tmpd = (char *) _NGGetNCARGEnv(\"tmp\");      /* defaults to: /tmp */\n        (void) sprintf(buffer, \"%s/ncl%d.ncl\", tmpd, getpid());\n\n        tmpf = fopen(buffer, \"w\");\n        for (k = 0; k < nargs; k++) {\n            if ((strstr(cargs[k], \"=\")) == (char *) NULL) \n                NhlPError(NhlWARNING, NhlEUNKNOWN, \" Improper assignment for variable %s\", cargs[k]);\n            else\n                (void) fwrite(cargs[k], strlen(cargs[k]), 1, tmpf);\n        }\n\n        /* don't forget last newline; NCL requires it */\n        (void) fwrite(\"\\n\", 1, 1, tmpf);\n        (void) fclose(tmpf);\n        \n        if (_NclPreLoadScript(buffer, 1) == NhlFATAL) {\n            NhlPError(NhlFATAL, NhlEUNKNOWN, \"Error initializing command line arguments.\");\n            (void) unlink(buffer);\n        } else {\n            yyparse(reset);\n        }\n\n        (void) unlink(buffer);\n        cmd_line = 1;       /* reset to default: interactive */\n    }\n\n    /* Pre-Load script */\n\n    for(i = 0; i < numberOfPreloadedScripts; ++i)\n    {\n        strcpy(buffer, _NGResolvePath(preload_scripts[i]));\n#ifdef NCLDEBUG\n        fprintf(stderr, \"\\tLoad predefined script %d: <%s>\\n\", i, preload_scripts[i]);\n#endif\n\n        sr = stat(buffer, &sbuf);\n        if(0 == sr)\n        {\n            if(_NclPreLoadScript(buffer, 1) == NhlFATAL)\n\t    {\n\t        NclReturnStatus = NclFileNotFound;\n                NhlPError(NhlINFO, NhlEUNKNOWN, \"Error loading NCL utility script.\");\n\t    }\n            else\n                yyparse(reset);\n        }\n    }\n\n#if 0\n#ifdef NCLDEBUG\n    if(NCLdebug_on)\n        _initializeNclMemoryRecord();\n#endif\n#endif\n\n    /* Load any provided script */\n    NCLecho = echoUserScript;\n    if (nclf != (char *) NULL) {\n        (void) strcpy(buffer, _NGResolvePath(nclf));\n        if (_NclPreLoadScript(buffer, 0) == NhlFATAL)\n\t{\n\t    NclReturnStatus = NclFileNotFound;\n            NhlPError(NhlFATAL, NhlEUNKNOWN, \"Error loading provided NCL script.\");\n\t}\n        else\n            yyparse(reset);\n    } else {\n        yyparse(reset);\n    }\n\n#if 0\n#ifdef NCLDEBUG\n        if(NCLdebug_on)\n                _finalizeNclMemoryRecord();\n#endif\n#endif\n\n#ifdef NCLDEBUG\n    (void) fclose(thefptr);\n    (void) fprintf(stdout,\"Number of unfreed objects %d\\n\",_NclNumObjs());\n    _NclObjsSize(stdout);\n    _NclNumGetObjCals(stdout);\n    _NclPrintUnfreedObjs(theoptr);\n    (void) fprintf(stdout,\"Number of constants used %d\\n\",number_of_constants);\n    (void) fclose(theoptr);\n#endif /* NCLDEBUG */\n\n    NclFree(cur_line_text);\n\n    _NclExit(NclReturnStatus);\n\n    return NclReturnStatus;\n}\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/ncl/NclApi.c": "/*\n *      $Id: NclApi.c,v 1.61 2008-07-11 23:05:47 dbrown Exp $\n */\n/************************************************************************\n*\t\t\t\t\t\t\t\t\t*\n*\t\t\t     Copyright (C)  1993\t\t\t*\n*\t     University Corporation for Atmospheric Research\t\t*\n*\t\t\t     All Rights Reserved\t\t\t*\n*\t\t\t\t\t\t\t\t\t*\n************************************************************************/\n/*\n *\tFile:\t\tncl_api.c\n *\n *\tAuthor:\t\tEthan Alpert\n *\t\t\tNational Center for Atmospheric Research\n *\t\t\tPO 3000, Boulder, Colorado\n *\n *\tDate:\t\tTue Aug 17 11:44:15 MDT 1993\n *\n *\tDescription:\tContains functions for initializing and using\n *\t\t\tncl from with in an application.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n#include <ncarg/hlu/hlu.h>\n#include <ncarg/hlu/NresDB.h>\n#include <ncarg/hlu/App.h>\n#include \"defs.h\"\n#include \"NclData.h\"\n#include \"Symbol.h\"\n#include \"Keywords.h\"\n#include \"NclVar.h\"\n#include \"ApiRecords.h\"\n#include \"NclApi.h\"\n#include <errno.h>\n#include <netcdf.h>\n#include \"DataSupport.h\"\n#include \"NclCallBacksI.h\"\n#include \"NclMdInc.h\"\n#include \"NclHLUObj.h\"\n#include \"NclHLUVar.h\"\n#include \"NclVar.h\"\n#include \"NclFile.h\"\n#include \"NclFileVar.h\"\n#include \"HLUSupport.h\"\n#include <dirent.h>\n#if defined(HPUX)\n#include <dl.h>\n#else\n#include <dlfcn.h>\n#endif\n\n#if 1\n#include \"NclDriver.h\"\n#else\nshort    NCLverbose = 0;\nshort    NCLecho = 0;\nshort   NCLoverrideEcho = 0;    /* override echo; non-advertised option */\nshort   NCLnoPrintElem = 0;     /* don't enumerate values in print() */\nshort   NCLnoSysPager = 0;\nchar   *nclf = NULL;\n#endif\n\nint force_reset = 0;\nint start_state = 0;\n\nextern int _NclParseString(\n#if NhlNeedProto\nchar * /*str*/,\nint  /*reset*/\n#endif\n);\n\nNhlErrorTypes NclHLUStringRef\n#if \tNhlNeedProto\n(int id , NclHLUStruct *ptr)\n#else\n( id , ptr)\nint id;\nNclHLUStruct *ptr;\n#endif\n{\n\tNclHLULookUpTable* tmp;\n\n\ttmp = _NclGetHLURefInfo(id);\n\n\tif(tmp == NULL) {\n\t\tptr->hlu_id = -1;\n\t\tptr->var_quark = -1;\n\t\tptr->att_quark = -1;\n\t\tptr->offset = -1;\n\t\tptr->n_offsets = 0;\n\t\tptr->n_refs = 0;\n\t\tptr->myprivate = NULL;\n\t\treturn(NhlFATAL);\n\t} else {\n\t\tptr->hlu_id = tmp->hlu_id;\n\t\tif(tmp->n_entries > 0) {\n\t\t\tptr->var_quark = tmp->ref_list[0].vq;\n\t\t\tptr->att_quark = tmp->ref_list[0].aq;\n\t\t\tptr->n_refs = tmp->n_entries;\n\t\t\tptr->n_offsets = tmp->ref_list[0].n_refs;\n\t\t\tptr->offset = tmp->ref_list[0].refs[0];\n\t\t\tptr->myprivate = (void*)tmp;\n\t\t} else {\n\t\t\tptr->var_quark = -1;\n\t\t\tptr->offset = -1;\n\t\t\tptr->n_offsets = 0;\n\t\t\tptr->n_refs = 0;\n\t\t\tptr->offset = -1;\n\t\t\tptr->myprivate = NULL;\n\t\t\treturn(NhlWARNING);\n\t\t}\n\t}\n\treturn(NhlNOERROR);\t\n}\n\n\nNhlErrorTypes NclApiRegisterCallback\n#if\tNhlNeedProto\n(NclApiObjTypes obj_type,unsigned int type, void* callback_function, void* user_data)\n#else\n(obj_type,type, callback_function, user_data)\nNclApiObjTypes obj_type;\nunsigned int type;\nvoid* callback_function;\nvoid* user_data;\n#endif\n{\n\treturn(_NclRegisterCallback((NclObjTypes)obj_type,type,callback_function,user_data));\n}\n\nFILE *the_err_file;\nint fd[2];\n\nextern char *the_input_buffer;\nextern char *the_input_buffer_ptr;\nextern int the_input_buffer_size;\n\nFILE *thefptr;\nFILE *theoptr;\nint cmd_line;\nextern int cur_line_number;\nextern char *cur_line_text;\nextern int cur_line_maxsize;\nextern char *cur_line_text_pos;\n\nextern void InitStdStreams(FILE* in, FILE* out, FILE* err);\n\nvoid NclResetServer\n#if \tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\tforce_reset = 1;\n\treturn;\n}\n\nint NclInitServer \n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n        DIR *d;\n        struct dirent *ent;\n        void *so_handle;\n        char buffer[4*NCL_MAX_STRING];\n        void (*init_function)(void);\n        char *libpath;\n        char *scriptpath;\n        char *pt;\n\tint reset = 1;\n\n#ifdef YYDEBUG\n/*\n#if     defined(SunOS) && (MAJOR == 4)\n        extern int ncldebug;\n        ncldebug = 1;\n#else\n*/\n        extern int yydebug;\n        yydebug = 1;\n/*\n#endif\n*/\n#endif\n\tncopts = NC_VERBOSE;\n\tcur_line_text = NclMalloc((unsigned)512);\n        cur_line_maxsize = 512;\n        cur_line_text_pos = &(cur_line_text[0]);\n\t/* init to -3 so begin/end determination of start_state isn't counted */\n\tcur_line_number = -3;\n\n        InitStdStreams(stdin, stdout, stderr);\n        \n\tNhlOpen();\n\n\t_NclInitMachine();\n\t_NclInitSymbol();\n\t_NclInitTypeClasses();\n\t_NclInitDataClasses();\n\n/*\n* Now handle default directories\n*/\n\tif((libpath = getenv(\"NCL_DEF_LIB_DIR\"))!=NULL) {\n\t\td = opendir(_NGResolvePath(libpath));\n\t\tif(d != NULL) {\n\t\t\twhile((ent = readdir(d)) != NULL) {\n\t\t\t\tif(*ent->d_name != '.') {\n\t\t\t\t\tsprintf(buffer,\"%s/%s\",_NGResolvePath(libpath),ent->d_name);\n#if defined(HPUX)\n\t\t\t\t\tso_handle = shl_load(buffer,BIND_IMMEDIATE,0L);\n#else\n\t\t\t\t\tso_handle = dlopen(buffer,RTLD_NOW);\n\t\t\t\t\tif(so_handle == NULL) {\n\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\" Could not open (%s): %s\",buffer,dlerror());\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif(so_handle != NULL) {\n#if defined(HPUX)\n\t\t\t\t\t\tinit_function = NULL;\n\t\t\t\t\t\t(void)shl_findsym(so_handle, \"Init\",TYPE_UNDEFINED,(void*)&init_function);\n#else\n\t\t\t\t\t\tinit_function = dlsym(so_handle, \"Init\");\n#endif\n\t\t\t\t\t\tif(init_function != NULL) {\n\t\t\t\t\t\t\t(*init_function)();\n\t\t\t\t\t\t} else {\n#if defined(HPUX)\n\t\t\t\t\t\t\tshl_unload(so_handle);\n#else\n\t\t\t\t\t\t\tdlclose(so_handle);\n#endif\n\t\t\t\t\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\"Could not find Init() in external file %s, file not loaded\",buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tNhlPError(NhlWARNING,NhlEUNKNOWN,\" Could not open (%s), no libraries loaded.\",libpath);\n\t\t}\n\t}\n\n\t_NclInitClass(nclHLUObjClass);\n\t_NclInitClass(nclHLUVarClass);\n\t_NclInitClass(nclVarClass);\n\t_NclInitClass(nclFileClass);\n\t_NclInitClass(nclFileVarClass);\n\n\tthe_input_buffer = \"begin\\nend\\n\\177\";\n\tthe_input_buffer_ptr = the_input_buffer;\n\tthe_input_buffer_size = strlen(\"begin\\nend\\n\");\n\tstart_state = _NclParseString(the_input_buffer,1);\n\tthe_input_buffer = NULL;\n\n\tif((scriptpath = getenv(\"NCL_DEF_SCRIPTS_DIR\"))!=NULL) {\n\t\td = opendir(_NGResolvePath(scriptpath));\n\t\tif(d!= NULL) {\n\t\t\twhile((ent = readdir(d)) != NULL) {\n\t\t\t\tif(*ent->d_name != '.') {\n\t\t\t\t\tsprintf(buffer,\"%s/%s\",_NGResolvePath(scriptpath),ent->d_name);\n\t\t\t\t\tpt = strrchr(buffer,'.');\n\t\t\t\t\tif(pt != NULL) {\n\t\t\t\t\t\tpt++;\n\t\t\t\t\t\tif(strncmp(pt,\"ncl\",3)==0) {\n\t\t\t\t\t\t\tif(_NclPreLoadScript(buffer,1) == NhlFATAL) {\n\t\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Error loading default script\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tyyparse(reset);\n/*\n\t\t\t\t\t\t\t\tif(reset)\n\t\t\t\t\t\t\t\t\treset = 0;\n*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Scripts must have the \\\".ncl\\\" file extension\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\tNhlPError(NhlFATAL,NhlEUNKNOWN,\"Scripts must have the \\\".ncl\\\" file extension\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n            NhlPError(NhlWARNING,NhlEUNKNOWN,\" Could not open (%s), no scripts loaded.\",scriptpath);\n\t\t}\n\n\t}\n\n\treturn(1);\t\n}\n\nvoid NclCloseServer\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\tNhlClose();\n}\n\nint NclSubmitBlock1\n#if\tNhlNeedProto\n(char *script,int script_size)\n#else\n(script,script_size)\n\tchar *script;\n\tint script_size;\n#endif\n{\n\tstatic int first = 1;\n\tint i;\n\tint state;\n\tchar *tmp = script;\n\tif(the_input_buffer != NULL) {\n\t\tNclFree(the_input_buffer);\n\t}\n\tthe_input_buffer = (char*)NclMalloc((unsigned)sizeof(char)*script_size +1);\n\tthe_input_buffer_ptr = the_input_buffer;\n\tfor(i = 0; i< script_size; i++) *the_input_buffer_ptr++ = *tmp++;\n\t*the_input_buffer_ptr = '\\n';\n\tthe_input_buffer_ptr = the_input_buffer;\n        the_input_buffer_size = script_size+1;\n\tif(force_reset) {\n\t\t_NclDeleteNewSymStack();\n\t}\n\tstate = _NclParseString(the_input_buffer,(first||force_reset? 1: 0));\n\tforce_reset = 0;\n\tfirst = 0;\n        return(state==start_state);\n}\n\nint NclSubmitBlock2\n#if\tNhlNeedProto\n(char *script[])\n#else\n(script)\n\tchar *script[];\n#endif\n{\n\tint i = 0;\n\tint size = 0;\n\tchar *tmp;\n\tstatic int first = 1;\n\tint state;\n\n\tfor(i =0; script[i] != NULL; i++)  \n\t\tsize += strlen(script[i]) + 1; \n\n\tif(the_input_buffer != NULL) {\n\t\tNclFree(the_input_buffer);\n\t}\n\tthe_input_buffer = (char*)NclMalloc((unsigned)sizeof(char)*size +1);\n\tthe_input_buffer_ptr = the_input_buffer;\n\tfor(i=0;script[i] != NULL;i++) {\n\t\ttmp = script[i];\n\t\twhile((*the_input_buffer_ptr = *tmp) != '\\0') {\n\t\t\tthe_input_buffer_ptr++;\n\t\t\ttmp++;\n\t\t}\n\t\t*(the_input_buffer_ptr) = '\\n';\n\t\tthe_input_buffer_ptr++;\n\t}\n\t*the_input_buffer_ptr = '\\n';\n\tthe_input_buffer_size = size +1;\n\tthe_input_buffer_ptr = the_input_buffer;\n\tif(force_reset) {\n                _NclDeleteNewSymStack();\n        }\n\tstate = _NclParseString(the_input_buffer,(first||force_reset? 1: 0));\n\tfirst = 0;\n\tforce_reset = 0;\n        return(state==start_state);\n}\n\nint NclSubmitCommand\n#if\tNhlNeedProto\n(char * command)\n#else\n(command)\n\tchar *command;\n#endif\n{\n\tstatic int first = 1;\n\tint state;\n\n\tif(the_input_buffer != NULL) {\n\t\tNclFree(the_input_buffer);\n\t}\n\tif(command[strlen(command)-2] == '\\n') {\n\t\tthe_input_buffer = (char*)NclMalloc((unsigned)strlen(command)+2);\n\t\tstrcpy(the_input_buffer,command);\n\t\tthe_input_buffer[strlen(command)+1] = '\\0';\n\t\tthe_input_buffer[strlen(command)] = '\\177';\n\t\n\t\tthe_input_buffer_size = strlen(command) + 2;\n\t} else {\n/*\n* All lines must be terminated by '\\n'\n* Since sometimes the calling environment appends a '\\n'\n* this if statement takes care of when the caller doesn't\n* append a '\\n'\n*/\n\t\tthe_input_buffer = (char*)NclMalloc((unsigned)strlen(command)+3);\n\t\tstrcpy(the_input_buffer,command);\n\t\tthe_input_buffer[strlen(command)] = '\\n';\n\t\tthe_input_buffer[strlen(command)+2] = '\\0';\n\t\tthe_input_buffer[strlen(command)+1] = '\\177';\n\t\n\t\tthe_input_buffer_size = strlen(command) + 3;\n\t}\n\n\tif(force_reset) {\n                _NclDeleteNewSymStack();\n/*\n\t\t(void)_NclPopScope();\n*/\n\n        }\n\n\tstate = _NclParseString(the_input_buffer,(first||force_reset? 1: 0));\n\tfirst = 0;\n\tforce_reset = 0;\n        return(state==start_state);\n}\n\nvoid NclPrintErrorMsgs\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\tint num,i;\n\tConst NhlErrMsg *msptr;\n\n\tnum = NhlErrNumMsgs();\n\tfor(i=0; i< num; i++) {\n\t\tNhlErrGetMsg(i,&msptr);\n\t\tNhlErrFPrintMsg(the_err_file,msptr);\n\t}\n\treturn;\n}\n\nint NclGetErrorId \n#if\tNhlNeedProto\n(void)\n#else \n()\n#endif\n{\n\treturn(NhlErrGetID());\n}\n\n\nstruct _NclApiDataList* NclGetProcFuncList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\treturn(_NclGetDefinedProcFuncInfo());\n} \n\nstruct _NclApiDataList* NclGetVarList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n        return(_NclGetDefinedVarInfo());\n}\nNclQuark* NclGetVarSymNames\n#if \tNhlNeedProto\n(int\t*num_names)\n#else\n(num_names)\nint\t*num_names;\n#endif\n{\n\treturn(_NclGetVarSymNames(num_names));\t\n}\nNhlClass *NclGetHLUClassPtrs\n#if     NhlNeedProto\n(int    *num_names)\n#else\n(num_names)\nint     *num_names;\n#endif\n{\n        return(_NclGetHLUClassPtrs(num_names));\n}\nNclQuark* NclGetFileSymNames\n#if \tNhlNeedProto\n(int\t*num_names)\n#else\n(num_names)\nint\t*num_names;\n#endif\n{\n\treturn(_NclGetFileSymNames(num_names));\t\n}\n\nNclQuark* NclGetHLUVarSymNames\n#if \tNhlNeedProto\n(int *num_names)\n#else\n(num_names)\nint *num_names;\n#endif\n{\n\treturn(_NclGetHLUVarSymNames(num_names));\n}\n\nNclQuark *NclGetProcFuncSymNames\n#if     NhlNeedProto\n(int *num_names)\n#else\n(num_names)\nint *num_names;\n#endif\n{\n        return(_NclGetProcFuncSymNames(num_names));\n}\n\n\nstruct _NclApiDataList *NclGetFileInfo\n#if\tNhlNeedProto\n(NclQuark file_sym_name)\n#else\n(file_sym_name)\nNclQuark file_sym_name\n#endif\n{\n\treturn(_NclGetFileInfo(file_sym_name));\n}\n\nstruct _NclExtValueRec * NclReadFileAtt\n#if  \tNhlNeedProto\n(NclQuark file_sym_name,NclQuark attname) \n#else\n(file_sym_name,attname) \nNclQuark file_sym_name;\nNclQuark attname;\n#endif\n{\n\treturn(_NclReadFileAtt(file_sym_name,attname));\n}\nstruct _NclApiDataList* NclGetFileList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\treturn(_NclGetDefinedFileInfo());\n}\n\nstruct _NclApiDataList* NclGetFileVarsList\n#if\tNhlNeedProto\n(NclQuark filevar)\n#else\n(filevar)\n\tNclQuark filevar;\n#endif\n{\n\treturn(_NclGetFileVarInfoList(filevar));\n}\n\nvoid NclFreeDataList\n#if\tNhlNeedProto\n(NclApiDataList *dlist)\n#else\n(dlist)\nNclApiDataList *dlist;\n#endif\n{\n\tif(dlist != NULL) \n\t\t_NclFreeApiDataList((void*)dlist);\n}\nNclExtValueRec *NclGetHLUObjId\n#if\tNhlNeedProto\n(char *varname)\n#else\n(varname)\n\tchar *varname;\n#endif\n{\n\treturn(_NclGetHLUObjId(varname));\n}\n\nstruct _NclApiDataList* NclGetHLUObjsList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\treturn(_NclGetDefinedHLUInfo());\n}\n\n\n\nstruct _NclExtValueRec *NclGetVarValue\n#if\tNhlNeedProto\n(char *var_name,int copy_data)\n#else\n(var_name,copy_data)\n\tchar * var_name;\n\tint copy_data;\n#endif\n{\n\tNclSymbol *s;\n\n\ts = _NclLookUp(var_name);\n\treturn(_NclGetVarValue(s,copy_data));\n}\nstruct _NclExtValueRec *NclReadVar\n#if\tNhlNeedProto\n(NclQuark var_name,long *start, long *finish, long* stride)\n#else\n(var_name,start,finish,stride)\n\tNclQuark var_name;\n\tlong *start;\n\tlong *finish;\n\tlong *stride;\n#endif\n{\n\tNclSymbol *s;\n\n\ts = _NclLookUp(NrmQuarkToString(var_name));\n\treturn(_NclReadVarValue(s,start,finish,stride));\n}\n\nNclExtValueRec *NclGetExprValue\n#if\tNhlNeedProto\n(char * expression)\n#else\n(expression)\n\tchar* expression;\n#endif\n{\n\tchar *tmp= NULL,*ptr = NULL;\n\tNclExtValueRec *tmp_val = NULL;\n\tng_usize_t size;\n/*\n\ts = _NclLookUp(NCLAPI_TMP_VAR);\n\n\tif((s != NULL)&&(s->type != UNDEF)) {\n\t\t\n\t}\n*/\n\tsize = strlen(expression);\n\tsize += strlen(NCLAPI_TMP_VAR);\n\tsize += 2; /* one for equals and one for '\\n' */\n\n\tptr = tmp = NclMalloc(size);\n\tmemcpy(ptr,NCLAPI_TMP_VAR,strlen(NCLAPI_TMP_VAR));\n\tptr += strlen(NCLAPI_TMP_VAR);\n\t*ptr++ = '=';\n\tmemcpy(ptr,expression,strlen(expression));\n\tptr += strlen(expression);\n\t*ptr = '\\0';\n\tNclSubmitCommand(tmp);\n\ttmp_val = NclGetVarValue(NCLAPI_TMP_VAR,1);\n\tNclSubmitCommand(NCLAPI_DEL_TMP_VAR);\n\t\n\treturn(tmp_val);\n}\n\nvoid NclFreeExtValue\n#if\tNhlNeedProto\n(NclExtValueRec* val)\n#else\n(val)\nNclExtValueRec* val;\n#endif\n{\n\tif(val != NULL) {\n\t\tif(!val->constant)\n\t\t\tNclFree(val->value);\n\t\tNclFree(val);\n\t\treturn;\n\t}\n}\nstatic NclApiDataList *new_list = NULL;\nstatic NclApiDataList *del_list = NULL;\n\nvoid _NclAddToNewList\n#if\tNhlNeedProto\n(int id,NclQuark name,NhlClass cl_ptr)\n#else\n(id,name,cl_ptr)\nint id;\nNclQuark name;\nNhlClass cl_ptr;\n#endif\n{\n\tNclApiDataList* tmp;\n\n\ttmp = NclMalloc(sizeof(NclApiDataList));\n\ttmp->u.hlu_obj =(NclApiHLUObjInfoRec*)NclMalloc(sizeof(NclApiHLUObjInfoRec));\n\ttmp->u.hlu_obj->name = name;\n\ttmp->u.hlu_obj->obj_id = id;\n\ttmp->u.hlu_obj->obj_class = cl_ptr;\n\ttmp->next = new_list;\n\tnew_list = tmp;\n\treturn;\n}\n\nvoid _NclAddToDelList\n#if\tNhlNeedProto\n(int id,NclQuark name,NhlClass cl_ptr)\n#else\n(id,name,cl_ptr)\nint id;\nNclQuark name;\nNhlClass cl_ptr;\n#endif\n{\n\tNclApiDataList* tmp;\n\n\ttmp = NclMalloc(sizeof(NclApiDataList));\n\ttmp->u.hlu_obj =(NclApiHLUObjInfoRec*)NclMalloc(sizeof(NclApiHLUObjInfoRec));\n\ttmp->u.hlu_obj->name = name;\n\ttmp->u.hlu_obj->obj_id = id;\n\ttmp->u.hlu_obj->obj_class = cl_ptr;\n\ttmp->next = del_list;\n\tdel_list = tmp;\n\treturn;\n}\n\nstruct _NclApiDataList* NclGetNewHLUObjsList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\tNclApiDataList *tmp;\n\n\ttmp = new_list;\n\tnew_list = NULL;\n\treturn(tmp);\n}\n\nstruct _NclApiDataList* NclGetDelHLUObjsList\n#if\tNhlNeedProto\n(void)\n#else\n()\n#endif\n{\n\tNclApiDataList *tmp;\n\n\ttmp = del_list;\n\tdel_list = NULL;\n\treturn(tmp);\n}\n\n\nNclQuark *NclGetFileVarNames\n#if\tNhlNeedProto\n(NclQuark file_sym_name,int *num_names)\n#else\n(file_sym_name,num_names)\nNclQuark file_sym_name;\nint *num_names;\n#endif\n{\n\treturn(_NclGetFileVarNames(file_sym_name,num_names));\n}\n\nstruct _NclApiDataList *NclGetFileVarInfo\n#if     NhlNeedProto\n(NclQuark file_sym_name,NclQuark file_var_name)\n#else\n(file_sym_name,file_var_name)\nNclQuark file_sym_name;\nNclQuark file_var_name;\n#endif\n{\n\treturn(_NclGetFileVarInfo(file_sym_name,file_var_name));\n}\n\nstruct _NclApiDataList * NclGetFileVarCoordInfo\n#if     NhlNeedProto\n(NclQuark file_sym_name,NclQuark file_var_name, NclQuark coord_name)\n#else\n(file_sym_name,file_var_name, coord_name)\nNclQuark file_sym_name;\nNclQuark file_var_name;\nNclQuark coord_name;\n#endif\n{\n\treturn(_NclGetFileVarCoordInfo(file_sym_name,file_var_name,coord_name));\n}\n\nstruct _NclExtValueRec *NclReadFileVar\n#if     NhlNeedProto\n(NclQuark file_sym_name,NclQuark file_var_name, long *start, long *finish, long *stride)\n#else\n(file_sym_name,file_var_name, start,finish, stride)\nNclQuark file_sym_name;\nNclQuark file_var_name;\nlong * start;\nlong * finish;\nlong * stride;\n#endif\n{\n\treturn(_NclReadFileVar(file_sym_name,file_var_name,start,finish,stride));\n}\n\nstruct _NclExtValueRec *NclReadFileVarAtt\n#if     NhlNeedProto\n(NclQuark file_sym_name,NclQuark file_var_name, NclQuark attname )\n#else\n(file_sym_name,file_var_name,attname )\nNclQuark file_sym_name;\nNclQuark file_var_name;\nNclQuark attname;\n#endif\n{\n\treturn(_NclReadFileVarAtt(file_sym_name,file_var_name,attname));\n}\n\nstruct _NclExtValueRec *NclReadFileVarCoord\n#if     NhlNeedProto\n(NclQuark file_sym_name,NclQuark file_var_name, NclQuark coordname, long *start, long* finish, long * stride)\n#else\n(file_sym_name,file_var_name,coordname,start,finish,stride)\nNclQuark file_sym_name;\nNclQuark file_var_name;\nNclQuark coordname;\nlong * start;\nlong * finish;\nlong * stride;\n#endif\n{\n\treturn(_NclReadFileVarCoord(file_sym_name,file_var_name,coordname, start,finish,stride));\n}\n\nstruct _NclApiDataList *NclGetVarInfo\n#if     NhlNeedProto\n(NclQuark var_sym_name)\n#else\n(var_sym_name)\nNclQuark var_sym_name;\n#endif\n{\n\treturn(_NclGetVarInfo(var_sym_name));\n}\n\n\nstruct _NclApiDataList *NclGetVarCoordInfo\n#if     NhlNeedProto\n(NclQuark var_sym_name,NclQuark coordname)\n#else\n(var_sym_name,coordname)\nNclQuark var_sym_name;\nNclQuark coordname;\n#endif\n{\n\treturn(_NclGetVarCoordInfo(var_sym_name,coordname));\n}\n\nstruct _NclExtValueRec *NclReadVarAtt\n#if     NhlNeedProto\n(NclQuark var_sym_name,NclQuark attname )\n#else\n(var_sym_name,attname)\nNclQuark var_sym_name;\nNclQuark attname;\n#endif\n{\n\treturn(_NclReadVarAtt(var_sym_name,attname));\n}\n\nstruct _NclExtValueRec *NclReadVarCoord\n#if     NhlNeedProto\n(NclQuark var_sym_name,NclQuark coordname, long *start, long *finish, long *stride)\n#else\n(var_sym_name,coordname,start, finish, stride)\nNclQuark var_sym_name;\nNclQuark coordname;\nlong *start;\nlong *finish;\nlong *stride;\n#endif\n{\n\treturn(_NclReadVarCoord(var_sym_name,coordname,start,finish,stride));\n}\n\nstruct _NclExtValueRec *NclReadVarCoordAtt\n#if     NhlNeedProto\n(NclQuark var_sym_name,NclQuark coordname, NclQuark attname)\n#else\n(var_sym_name,coordname,attname)\nNclQuark var_sym_name;\nNclQuark coordname;\nNclQuark attname\n#endif\n{\n\treturn(_NclReadVarCoordAtt(var_sym_name,coordname,attname));\n}\n\nchar *NclTypeToString\n#if \tNhlNeedProto\n(void *val, int data_type) \n#else\n(val, data_type) \nvoid *val;\nint data_type;\n#endif\n{\n\tchar buffer[256];\n\tchar *out;\n\n\n\tswitch(data_type) {\n\tcase NCLAPI_short:\n\t\tsprintf(buffer,nclTypeshortClassRec.type_class.format,*(short*)val);\n\t\tbreak;\n\tcase NCLAPI_int:\n\t\tsprintf(buffer,nclTypeintClassRec.type_class.format,*(int*)val);\n\t\tbreak;\n\tcase NCLAPI_long:\n\t\tsprintf(buffer,nclTypelongClassRec.type_class.format,*(long*)val);\n\t\tbreak;\n\tcase NCLAPI_float:\n\t\tsprintf(buffer,nclTypefloatClassRec.type_class.format,*(float*)val);\n\t\tbreak;\n\tcase NCLAPI_double:\n\t\tsprintf(buffer,nclTypedoubleClassRec.type_class.format,*(double*)val);\n\t\tbreak;\n\tcase NCLAPI_char:\n\t\tsprintf(buffer,nclTypecharClassRec.type_class.format,*(char*)val);\n\t\tbreak;\n\tcase NCLAPI_byte:\n\t\tsprintf(buffer,nclTypebyteClassRec.type_class.format,*(byte*)val);\n\t\tbreak;\n\tcase NCLAPI_string:\n\t\tout = (char*)NclMalloc(strlen(NrmQuarkToString(*(NclQuark*)val))+1);\n\t\tstrcpy(out,NrmQuarkToString(*(NclQuark*)val));\n\t\treturn(out);\n\t\tbreak;\n\tcase NCLAPI_logical:\n\t\tif(*(int*)val)  {\n\t\t\tsprintf(buffer,\"True\");\n\t\t} else {\n\t\t\tsprintf(buffer,\"False\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn(NULL);\n\t}\n\tout = (char*)NclMalloc(strlen(buffer)+1);\n\tstrcpy(out,buffer);\n\treturn(out);\n}\n\nNhlBoolean\nNclSymbolDefined\n#if\tNhlNeedProto\n(\n\tchar\t*sym\n)\n#else\n(sym)\n\tchar\t*sym;\n#endif\n{\n\tNclSymbol\t*s;\n\n\ts = _NclLookUp(sym);\n\n\tif(!s || (s->type == UNDEF))\n\t\treturn False;\n\telse\n\t\treturn True;\n}\n\n#ifdef __cplusplus\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/common/src/fontcap/umlaut_a.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/lib/nfp/NfpSrcList.xlsx",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/bin/ex01B1_uv300.hs.mdl",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/meccatemp.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/U500storm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/cn10n.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/hswm_d000000p000.g2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031807_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/950318_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031823_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/seam.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/Vstorm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031819_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ctcbay.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031821_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031805_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ced1.lf00.t00z.eta.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031820_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/941110_P.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031818_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031808_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/pop.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/sstanom.robinsonproj.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/color.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/traj_data.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/contour.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/nc4uvt.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/meteo_data.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031806_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031810_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031816_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ice5g_21k_1deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031811_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031809_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031814_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031803_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ex01B1_uv300.hs.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/climdiv_polygons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/941110_UV.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/landsea.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ctnccl.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/Pstorm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031802_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/sstdata_netcdf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/Ustorm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/Tstorm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031812_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031804_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031822_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/uv300.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031813_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/ocean.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/fice.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031817_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/vinth2p.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031801_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031800_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/panel2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/chi200_ud_smooth.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/sst30e_netcdf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/trinidad.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/hgt.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/V500storm.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/scatter1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/cdf/95031815_sao.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/200711210135_NCV_FLIGHTCAT_A.grb2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/MET9_IR108_cosmode_0909210000.grb2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/fh.0012_tl.press_gr.awp211.grb2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/200711210135_NCV_CEILING_A.grb2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/wafsgfs_L_t06z_intdsk60.grib2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/ced1.lf00.t00z.eta.grb",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/grb/200711210135_NCV_VISIBILITY_A.grb2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/hdf/avhrr.hdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/hdf/MLS-Aura_L2GP-IWC_v02-21-c02_2007d210.he5",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/hdf/MOD04_L2.A2001066.0000.004.2003078090622.he2",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/shp/mrb.shp",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/shp/states.shp",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/shp/mrb.shx",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/shp/states.shx",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/shp/states.dbf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod3_rcp45_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod4_rcp45_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/atm_phy_mag0004_1985.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod1_rcp45_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/HSURF_regional_model_0.44deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/rectilinear_grid_3D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/uas_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tos_ocean_bipolar_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod2_rcp45_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/HSURF_regional_model_0.11deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/orog_mod2_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/FR-LAND_regional_model_0.44deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/topo.bin",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/FR-LAND_regional_model_0.11deg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod2_hist_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod1_rcp85_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/sftlf_mod2_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod4_rcp85_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/orog_mod3_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod4_hist_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod2_rcp85_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/sftlf_mod1_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod3_hist_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/vas_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/triangular_grid_ICON.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod3_rcp85_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/uv300.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_mod1_hist_rectilin_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/sftlf_mod3_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/camse_unstructured_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/orog_mod1_rectilinear_grid_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/tas_rotated_grid_EUR11.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/examples/data/nug/ps_grads_model.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables/centers.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables/tigge/3/3.7.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables.previous/centers.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables.previous/ecmwf/3/3.7.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables.previous/tigge/3/3.7.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/db/grib2_codetables.previous/ncep/3/3.7.table",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ni/src/ncl/date.c",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/bin/psfltrs/ps.input.file",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/bin/pre2ncgm/conrec.pre",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/examples/eezmap/Europe.png",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/Aristarcoj2.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraBd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraBI.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraSe.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraMoBd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraMoIt.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraMono.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/cmsy10.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/cmex10.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraIt.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraMoBI.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/VeraSeBd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-ncl-6.6.2-cjxfetnkfeff4r52ts72cq2zar4yovmr/spack-src/ncarg2d/src/db/ftfonts/Vera.ttf"
    ],
    "total_files": 8729
}