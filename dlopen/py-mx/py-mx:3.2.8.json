{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/egenix_mx_base.py": "#!/usr/local/bin/python2.1\n\n\"\"\" Configuration for the eGenix mx Base Distribution\n\n    Copyright (c) 1997-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com\n    Copyright (c) 2000-2014, eGenix.com Software GmbH; mailto:info@egenix.com\n    See the documentation for further information on copyrights,\n    or contact the author. All Rights Reserved.\n\"\"\"\nimport sys\nfrom mxSetup import mx_Extension, mx_version\n\n#\n# Package version\n#\nversion = mx_version(3, 2, 8)\n\n#\n# Setup information\n#\nname = \"egenix-mx-base\"\n\n#\n# Meta-Data\n#\ndescription = \"eGenix mx Base Distribution for Python - mxDateTime, mxTextTools, mxProxy, mxTools, mxBeeBase, mxStack, mxQueue, mxURL, mxUID\"\nlong_description = \"\"\"\\\neGenix mx Base Distribution for Python\n--------------------------------------\n\nThe eGenix mx Extension Series are a collection of Python extensions\nwritten in ANSI C and Python which provide a large spectrum of useful\nadditions to everyday Python programming.\n\nWe are using the distribution on a daily basis on our own servers and\nfor client installations. Many large corporations are building their\nPython applications on parts of the eGenix.com mx Base Distribution.\nIt is also included in popular Linux distributions, such\nas RedHat, OpenSUSE, Debian, Ubuntu, etc.\n\n\nContents\n--------\n\nThe Base Distribution includes the Open Source subpackages of the\nseries and is needed by all other add-on packages of the series:\n\n**mxDateTime - Date/Time Library for Python**\n\n    mxDateTime implements three new object types, DateTime,\n    DateTimeDelta and RelativeDateTime and many tools based on these\n    for doing easy conversion between and parsing of various date/time\n    formats.\n\n    http://www.egenix.com/products/python/mxBase/mxDateTime/\n\n**mxTextTools - Fast Text Parsing and Processing Tools for Python**\n\n    mxTextTools provides several useful functions and types that\n    implement high-performance text parsing, processing and search\n    algorithms.\n\n    http://www.egenix.com/products/python/mxBase/mxTextTools/\n\n**mxProxy - Object Access Control for Python**\n\n    mxProxy implements a new proxy type to provide low-level object\n    access control, weak referencing and a cleanup protocol. It's\n    ideal for use in restricted execution environments.\n\n    http://www.egenix.com/products/python/mxBase/mxProxy/\n\n**mxBeeBase - On-disk B+Tree Based Database Kit for Python**\n\n    mxBeeBase is a high performance construction kit for disk based\n    indexed databases. It offers components which you can plug\n    together to easily build your own custom mid-sized databases.\n\n    http://www.egenix.com/products/python/mxBase/mxBeeBase/\n\n**mxURL - Flexible URL Data-Type for Python**\n\n    mxURL provides a new datatype for storing and manipulating URL\n    values as well as a few helpers related to URL building, encoding\n    and decoding.\n\n    http://www.egenix.com/products/python/mxBase/mxURL/\n\n**mxUID - Fast Universal Identifiers for Python**\n\n    mxUID implements a fast mechanism for generating universal\n    identification strings (UIDs).\n\n    http://www.egenix.com/products/python/mxBase/mxUID/\n\n**mxStack - Fast and Memory-Efficient Stack Type for Python**\n\n    mxStack implements a fast and memory efficient stack object type.\n\n    http://www.egenix.com/products/python/mxBase/mxStack/\n\n**mxQueue - Fast and Memory-Efficient Queue Type for Python**\n\n    mxQueue implements a fast and memory efficient queue object type.\n\n    http://www.egenix.com/products/python/mxBase/mxQueue/\n\n**mxTools - Fast Everyday Helpers for Python**\n\n    mxTools provides a collection of handy functions and objects for\n    every day Python programming. It includes many functions that\n    you've often missed in Python.\n\n    http://www.egenix.com/products/python/mxBase/mxTools/\n\n\nDownloads\n---------\n\nFor downloads, documentation, installation instructions and\nchangelogs, please visit the product page at:\n\n    http://www.egenix.com/products/python/mxBase/\n\n\nLicense\n-------\n\nThis open source software is brought to you by eGenix.com and\ndistributed under the eGenix.com Public License 1.1.0.\n\"\"\"\nlicense = (\n\"eGenix.com Public License 1.1.0; \"\n\"Copyright (c) 1997-2000, Marc-Andre Lemburg, All Rights Reserved; \"\n\"Copyright (c) 2000-2014, eGenix.com Software GmbH, All Rights Reserved\"\n)\nauthor = \"eGenix.com Software GmbH\"\nauthor_email = \"info@egenix.com\"\nmaintainer = \"eGenix.com Software GmbH\"\nmaintainer_email = \"info@egenix.com\"\nurl = \"http://www.egenix.com/products/python/mxBase/\"\ndownload_url = 'https://downloads.egenix.com/python/download_url/%s/%s/' % (\n    name,\n    version)\nplatforms = [\n    'Windows',\n    'Linux',\n    'FreeBSD',\n    'Solaris',\n    'Mac OS X',\n    'AIX',\n    ]\nclassifiers = [\n    \"Environment :: Console\",\n    \"Environment :: No Input/Output (Daemon)\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Python License (CNRI Python License)\",\n    \"License :: Freely Distributable\",\n    \"License :: Other/Proprietary License\",\n    \"Natural Language :: English\",\n    \"Operating System :: OS Independent\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Operating System :: POSIX\",\n    \"Operating System :: Unix\",\n    \"Operating System :: BeOS\",\n    \"Operating System :: MacOS\",\n    \"Operating System :: OS/2\",\n    \"Operating System :: Other OS\",\n    \"Programming Language :: C\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 2\",\n    \"Programming Language :: Python :: 2.4\",\n    \"Programming Language :: Python :: 2.5\",\n    \"Programming Language :: Python :: 2.6\",\n    \"Programming Language :: Python :: 2.7\",\n    \"Topic :: Communications\",\n    \"Topic :: Database\",\n    \"Topic :: Documentation\",\n    \"Topic :: Internet\",\n    \"Topic :: Internet :: WWW/HTTP\",\n    \"Topic :: Internet :: WWW/HTTP :: Dynamic Content\",\n    \"Topic :: Internet :: WWW/HTTP :: Dynamic Content :: CGI Tools/Libraries\",\n    \"Topic :: Internet :: WWW/HTTP :: Site Management :: Link Checking\",\n    \"Topic :: Scientific/Engineering\",\n    \"Topic :: Scientific/Engineering :: Interface Engine/Protocol Translator\",\n    \"Topic :: Software Development\",\n    \"Topic :: Software Development :: Libraries\",\n    \"Topic :: Software Development :: Libraries :: Application Frameworks\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Topic :: Text Processing\",\n    \"Topic :: Text Processing :: Filters\",\n    \"Topic :: Text Processing :: Markup\",\n    \"Topic :: Utilities \",\n    ]\nif 'a' in version:\n    classifiers.append(\"Development Status :: 3 - Alpha\")\nelif 'b' in version:\n    classifiers.append(\"Development Status :: 4 - Beta\")\nelse:\n    classifiers.append(\"Development Status :: 5 - Production/Stable\")\n    classifiers.append(\"Development Status :: 6 - Mature\")\nclassifiers.sort()\n\n#\n# Python packages\n#\npackages = [\n\n    # mx Extensions Base Package\n    'mx',\n\n    # mxDateTime\n    'mx.DateTime',\n    'mx.DateTime.mxDateTime',\n    'mx.DateTime.Examples',\n\n    # mxProxy\n    'mx.Proxy',\n    'mx.Proxy.mxProxy',\n\n    # mxQueue\n    'mx.Queue',\n    'mx.Queue.mxQueue',\n\n    # mxStack\n    'mx.Stack',\n    'mx.Stack.mxStack',\n\n    # mxTextTools\n    'mx.TextTools',\n    'mx.TextTools.mxTextTools',\n    'mx.TextTools.Constants',\n    'mx.TextTools.Examples',\n\n    # mxTools\n    'mx.Tools',\n    'mx.Tools.mxTools',\n    'mx.Tools.Examples',\n\n    # mxBeeBase\n    'mx.BeeBase',\n    'mx.BeeBase.mxBeeBase',\n\n    # mxURL\n    'mx.URL',\n    'mx.URL.mxURL',\n    \n    # mxUID\n    'mx.UID',\n    'mx.UID.mxUID',\n\n    # Misc. other modules\n    'mx.Misc',\n\n    ]\n\n#\n# C Extensions\n#\n\n# Determine optional platform-dependent features\nif sys.platform[:3] != 'win':\n    # Unix-like platforms\n    _mxDateTime_optional_libraries = [\n        # mxDateTime needs floor() and ceil() which are sometimes\n        # defined in libm. Python normally already references this\n        # library if necessary, so not finding the library is not\n        # necessarily a reason to fail building mxDateTime.\n        ('m', ['math.h']),\n        # mxDateTime can use the API clock_gettime() if available,\n        # but this sometimes needs the librt to be available.\n        ('rt', ['time.h']),\n        ]\n    _mxTools_optional_libraries = [\n        # The optional mx.Tools.dlopen() function needs the dl lib in\n        # order to load dynamic libaries on Unix platforms.\n        ('dl', ['dlfcn.h']),\n        ]\nelse:\n    # On Windows, the extra libs are not needed (or even available)\n    _mxDateTime_optional_libraries = []\n    _mxTools_optional_libraries = []\n    \n# Extension definitions\next_modules = [\n\n    # mxDateTime\n    mx_Extension('mx.DateTime.mxDateTime.mxDateTime',\n                 ['mx/DateTime/mxDateTime/mxDateTime.c'],\n                 # If mxDateTime doesn't compile, try removing the next line.\n                 define_macros=[('USE_FAST_GETCURRENTTIME', None)],\n                 #\n                 include_dirs=['mx/DateTime/mxDateTime'],\n                 optional_libraries=_mxDateTime_optional_libraries,\n                 ),\n\n    # mxProxy\n    mx_Extension('mx.Proxy.mxProxy.mxProxy',\n                 ['mx/Proxy/mxProxy/mxProxy.c'],\n                 include_dirs=['mx/Proxy/mxProxy']),\n\n    # mxQueue\n    mx_Extension('mx.Queue.mxQueue.mxQueue',\n                 ['mx/Queue/mxQueue/mxQueue.c'],\n                 include_dirs=['mx/Queue/mxQueue']),\n\n    # mxStack\n    mx_Extension('mx.Stack.mxStack.mxStack',\n                 ['mx/Stack/mxStack/mxStack.c'],\n                 include_dirs=['mx/Stack/mxStack']),\n\n    # mxTextTools\n    mx_Extension('mx.TextTools.mxTextTools.mxTextTools',\n                 ['mx/TextTools/mxTextTools/mxTextTools.c',\n                  'mx/TextTools/mxTextTools/mxte.c',\n                  'mx/TextTools/mxTextTools/mxbmse.c'],\n                 define_macros=[('MX_BUILDING_MXTEXTTOOLS', None)],\n                 include_dirs=['mx/TextTools/mxTextTools']),\n\n    # mxTools\n    mx_Extension('mx.Tools.mxTools.mxTools',\n                 ['mx/Tools/mxTools/mxTools.c'],\n                 define_macros=[\n\n                     # To enable mx.Tools.setproctitle(), you have to enable\n                     # the following line. Note that not all Python versions\n                     # expose the required Py_GetArgcArgv() API.\n                     # ('HAVE_PY_GETARGCARGV', None),\n                     \n                     # If you want to use the experimental mx.Tools.safecall()\n                     # API, you have to enable the following line.\n                     # ('MXTOOLS_ENABLE_SAFECALL', None),\n                     \n                 ],\n                 include_dirs=['mx/Tools/mxTools'],\n                 optional_libraries=_mxTools_optional_libraries,\n                 ),\n\n    # xmap is no longer supported\n    #mx_Extension('mx.Tools.mxTools.xmap',\n    #             ['mx/Tools/mxTools/xmap.c'],\n    #             include_dirs=['mx/Tools/mxTools']),\n\n    # mxBeeBase\n    mx_Extension('mx.BeeBase.mxBeeBase.mxBeeBase',\n                 ['mx/BeeBase/mxBeeBase/mxBeeBase.c',\n                  'mx/BeeBase/mxBeeBase/btr.c'],\n                 include_dirs=['mx/BeeBase/mxBeeBase']),\n\n    # mxURL\n    mx_Extension('mx.URL.mxURL.mxURL',\n                 ['mx/URL/mxURL/mxURL.c'],\n                 include_dirs=['mx/URL/mxURL']),\n\n    # mxUID\n    mx_Extension('mx.UID.mxUID.mxUID',\n                 ['mx/UID/mxUID/mxUID.c'],\n                 include_dirs=['mx/UID/mxUID']),\n\n    ]\n\n#\n# Data files\n#\ndata_files = [\n\n    # Copyright, licenses, READMEs\n    'mx/COPYRIGHT',\n    'mx/LICENSE',\n    'mx/README',\n\n    # Misc\n    'mx/Misc/LICENSE',\n    'mx/Misc/COPYRIGHT',\n\n    # mxDateTime\n    'mx/DateTime/Doc/mxDateTime.pdf',\n    'mx/DateTime/COPYRIGHT',\n    'mx/DateTime/LICENSE',\n    'mx/DateTime/README',\n    'mx/DateTime/mxDateTime/mxDateTime.h',\n    'mx/DateTime/mxDateTime/mxh.h',\n\n    # mxProxy\n    'mx/Proxy/Doc/mxProxy.pdf',\n    'mx/Proxy/COPYRIGHT',\n    'mx/Proxy/LICENSE',\n    'mx/Proxy/README',\n    'mx/Proxy/mxProxy/mxProxy.h',\n    'mx/Proxy/mxProxy/mxh.h',\n\n    # mxQueue\n    'mx/Queue/Doc/mxQueue.pdf',\n    'mx/Queue/COPYRIGHT',\n    'mx/Queue/LICENSE',\n    'mx/Queue/README',\n    'mx/Queue/mxQueue/mxQueue.h',\n    'mx/Queue/mxQueue/mxh.h',\n\n    # mxStack\n    'mx/Stack/Doc/mxStack.pdf',\n    'mx/Stack/COPYRIGHT',\n    'mx/Stack/LICENSE',\n    'mx/Stack/README',\n    'mx/Stack/mxStack/mxStack.h',\n    'mx/Stack/mxStack/mxh.h',\n\n    # mxTextTools\n    'mx/TextTools/Doc/mxTextTools.pdf',\n    'mx/TextTools/COPYRIGHT',\n    'mx/TextTools/LICENSE',\n    'mx/TextTools/README',\n    'mx/TextTools/mxTextTools/mxTextTools.h',\n    'mx/TextTools/mxTextTools/mxh.h',\n    'mx/TextTools/mxTextTools/mxbmse.h',\n    \n    # mxTools\n    'mx/Tools/Doc/mxTools.pdf',\n    'mx/Tools/COPYRIGHT',\n    'mx/Tools/LICENSE',\n    'mx/Tools/README',\n    'mx/Tools/mxTools/mxTools.h',\n    'mx/Tools/mxTools/mxh.h',\n\n    # mxBeeBase\n    'mx/BeeBase/Doc/mxBeeBase.pdf',\n    'mx/BeeBase/COPYRIGHT',\n    'mx/BeeBase/LICENSE',\n    'mx/BeeBase/README',\n    'mx/BeeBase/mxBeeBase/mxBeeBase.h',\n    'mx/BeeBase/mxBeeBase/mxh.h',\n    'mx/BeeBase/mxBeeBase/btr.h',\n\n    # mxURL\n    'mx/URL/Doc/mxURL.pdf',\n    'mx/URL/COPYRIGHT',\n    'mx/URL/LICENSE',\n    'mx/URL/README',\n    'mx/URL/mxURL/mxURL.h',\n    'mx/URL/mxURL/mxh.h',\n\n    # mxUID\n    'mx/UID/Doc/mxUID.pdf',\n    'mx/UID/COPYRIGHT',\n    'mx/UID/LICENSE',\n    'mx/UID/README',\n    'mx/UID/mxUID/mxUID.h',\n    'mx/UID/mxUID/mxh.h',\n\n    ]\n\n# Declare namespace packages (for building eggs)\nnamespace_packages = [\n    'mx',\n    ]\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Tools/mxTools/mxTools.c": "/* \n  mxTools -- Misc. utilities for Python\n\n  Copyright (c) 1997-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com\n  Copyright (c) 2000-2014, eGenix.com Software GmbH; mailto:info@egenix.com\n  See the documentation for further copyright information or contact\n  the author (mailto:mal@lemburg.com).\n\n*/\n\n/* Define this to aid in finding memory leaks */\n/*#define MAL_MEM_DEBUG*/\n/*#define MAL_DEBUG*/\n/*#define MAL_REF_DEBUG*/\n\n/* Logging file used by debugging facility */\n#ifndef MAL_DEBUG_OUTPUTFILE\n# define MAL_DEBUG_OUTPUTFILE \"mxTools.log\"\n#endif\n\n/* We want all our symbols to be exported */\n#define MX_BUILDING_MXTOOLS\n\n/* Mark the module as Py_ssize_t clean. */\n#define PY_SSIZE_T_CLEAN 1\n\n/* Setup mxstdlib memory management */\n#if 1\n# define MAL_USE_PYMALLOC\n#else\n# define MAL_USE_C_MALLOC\n#endif\n\n#include \"mx.h\"\n#include \"mxTools.h\"\n\n/* Needed for mxTools_EvalCodeString() */\n#include \"compile.h\"\n#include \"eval.h\"\n\n/* Needed for mxTools_cur_frame() */\n#include \"frameobject.h\"\n\n/* Needed for mxTools_dlopen(); HAVE_DL_LIB is defined by the\n   egenix_mx_base.py setup script if the dl library can be\n   found. HAVE_DLOPEN is defined by Python's configure script, if\n   dlopen() is available. */\n#if defined(HAVE_DL_LIB) && !defined(HAVE_DLOPEN)\n# define HAVE_DLOPEN 1\n#endif\n#ifdef HAVE_DLOPEN\n# include <dlfcn.h>\n#endif\n\n#define MXTOOLS_VERSION \"3.2.8\"\n\n/* To open up the playground for new ideas... */\n/*#define INCLUDE_FUNSTUFF*/\n\n/* Maximal size of the code cache used by mxTools_EvalCodeString() */\n#define MAX_CODECACHE_SIZE\t10\n\n/* --- module doc-string -------------------------------------------------- */\n\nstatic char *Module_docstring = \n\n MXTOOLS_MODULE\" -- A tool collection. Version \"MXTOOLS_VERSION\"\\n\\n\"\n\n \"Copyright (c) 1997-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com\\n\"\n \"Copyright (c) 2000-2014, eGenix.com Software GmbH; mailto:info@egenix.com\\n\\n\"\n \"                 All Rights Reserved\\n\\n\"\n \"See the documentation for further information on copyrights,\\n\"\n \"or contact the author.\"\n;\n\n/* --- module globals ----------------------------------------------------- */\n\nstatic PyObject *mxTools_Error;\t\t\t/* Error Exception\n\t\t\t\t\t\t   object */\n\nstatic PyObject *mxTools_ProgrammingError;\t/* ProgrammingError Exception\n\t\t\t\t\t\t   object */\n\nstatic PyObject *mxNotGiven;\t\t\t/* NotGiven singleton */\n\nstatic PyObject *mxTools_BaseobjAttribute;      /* Attribute to use for\n\t\t\t\t\t\t   acquire() per default */\n\n/* Flag telling us whether the module was initialized or not. */\nstatic int mxTools_Initialized = 0;\n\n/* --- forward declarations ----------------------------------------------- */\n\n/* --- internal macros ---------------------------------------------------- */\n\n/* --- module helpers ----------------------------------------------------- */\n\n/* Create an exception object, insert it into the module dictionary\n   under the given name and return the object pointer; this is NULL in\n   case an error occurred. */\n\nstatic \nPyObject *insexc(PyObject *moddict,\n\t\t char *name,\n\t\t PyObject *baseclass)\n{\n    PyObject *v;\n    char fullname[256];\n    char *modname;\n    char *dot;\n    \n    v = PyDict_GetItemString(moddict, \"__name__\");\n    if (v == NULL)\n\tmodname = NULL;\n    else\n\tmodname = PyString_AsString(v);\n    if (modname == NULL) {\n\tPyErr_Clear();\n\tmodname = MXTOOLS_MODULE;\n    }\n    /* The symbols from this extension are imported into\n       mx.<packagename>. We trim the name to not confuse the user with\n       an overly long package path. */\n    strcpy(fullname, modname);\n    dot = strchr(fullname, '.');\n    if (dot)\n\tdot = strchr(dot+1, '.');\n    if (dot)\n\tstrcpy(dot+1, name);\n    else\n\tsprintf(fullname, \"%s.%s\", modname, name);\n\n\n    v = PyErr_NewException(fullname, baseclass, NULL);\n    if (v == NULL)\n\treturn NULL;\n    if (PyDict_SetItemString(moddict,name,v))\n\treturn NULL;\n    return v;\n}\n\n#ifdef HAVE_DLOPEN\n/* Helper for adding integer constants. Check for errors with\n   PyErr_Occurred() */\nstatic \nvoid insint(PyObject *dict,\n\t    char *name,\n\t    int value)\n{\n    PyObject *v = PyInt_FromLong((long)value);\n    PyDict_SetItemString(dict, name, v);\n    Py_XDECREF(v);\n}\n#endif\n\n/* Helper for adding string constants to a dictionary. Check for\n   errors with PyErr_Occurred() */\nstatic \nvoid insstr(PyObject *dict,\n\t    char *name,\n\t    char *value)\n{\n    PyObject *v = PyString_FromString(value);\n    PyDict_SetItemString(dict, name, v);\n    Py_XDECREF(v);\n}\n\nstatic\nPyObject *notimplemented1(PyObject *v)\n{\n    Py_Error(PyExc_TypeError,\n\t     \"operation not implemented\");\n onError:\n    return NULL;\n}\n\nstatic\nPyObject *notimplemented2(PyObject *v, PyObject *w)\n{\n    Py_Error(PyExc_TypeError,\n\t     \"operation not implemented\");\n onError:\n    return NULL;\n}\n\nstatic\nPyObject *notimplemented3(PyObject *u, PyObject *v, PyObject *w)\n{\n    Py_Error(PyExc_TypeError,\n\t     \"operation not implemented\");\n onError:\n    return NULL;\n}\n\n/* --- Internal Functions ------------------------------------------------- */\n\n#ifdef INCLUDE_FUNSTUFF\nstatic\nPyObject *mxTools_EvalCodeString(PyObject *codestr)\n{\n    static PyObject *codecache;\n    PyObject *code;\n    PyObject *v;\n    \n    Py_Assert(PyString_Check(codestr),\n\t      PyExc_SystemError,\n\t      \"Bad internal call to mxTools_EvalCodeString\");\n\n    /* Init. codecache dictionary */\n    if (codecache == NULL) {\n\tcodecache = PyDict_New();\n\tif (!codecache)\n\t    goto onError;\n    }\n    \n    /* Get code object or compile the string */\n    code = PyDict_GetItem(codecache,codestr);\n    if (!code) {\n\tcode = Py_CompileString(PyString_AS_STRING(codestr),\n\t\t\t\t\"<string>\", Py_eval_input);\n\tif (!code)\n\t    goto onError;\n\tif (PyDict_Size(codecache) >= MAX_CODECACHE_SIZE)\n\t    PyDict_Clear(codecache);\n\tPyDict_SetItem(codecache,codestr,code);\n    }\n    else\n\tPy_INCREF(code);\n    \n    /* Run the code in the current context */\n    v = PyEval_EvalCode((PyCodeObject *)code,\n\t\t\tPyEval_GetGlobals(),\n\t\t\tPyEval_GetLocals());\n    Py_DECREF(code);\n    return v;\n\n onError:\n    return NULL;\n}\n#endif\n\n/* --- Interface ---------------------------------------------------------- */\n\nPy_C_Function( mxTools_napply,\n\t       \"napply(number_of_calls,function,args=(),kw={})\\n\\n\"\n\t       \"Calls the function number_of_calls times with the same\\n\"\n\t       \"arguments and returns a tuple with the return values.\")\n{\n    Py_ssize_t count;\n    register Py_ssize_t i;\n    PyObject *func,*arg = 0,*kw = 0;\n    PyObject *w = 0;\n\n    Py_Get4Args(Py_SSIZE_T_PARSERMARKER\n\t\t\"O|OO\",\n\t\tcount,func,arg,kw);\n\n    Py_XINCREF(arg);\n\n    w = PyTuple_New(count);\n    if (w == NULL)\n\tgoto onError;\n\n    if (arg == NULL)\n\targ = PyTuple_New(0);\n    if (arg == NULL)\n\tgoto onError;\n\n#ifdef PyCFunction_GET_FUNCTION\n    /* Short-cut for C functions, taken from ceval.c:call_builtin();\n       Note: this only works and is used together with my patched\n       version of the interpreter. XXX Update when ceval.c changes !!! */\n    if (PyCFunction_Check(func)) {\n\tregister PyCFunction meth = PyCFunction_GET_FUNCTION(func);\n\tregister PyObject *self = PyCFunction_GET_SELF(func);\n\tint flags = PyCFunction_GET_FLAGS(func);\n\n\tif (!(flags & METH_VARARGS)) {\n\t    Py_ssize_t size = PyTuple_GET_SIZE(arg);\n\t    if (size == 1)\n\t\targ = PyTuple_GET_ITEM(arg, 0);\n\t    else if (size == 0)\n\t\targ = NULL;\n\t}\n\tif (flags & METH_KEYWORDS)\n\t    for (i = 0; i < count; i++) {\n\t\tregister PyObject *v;\n\t    \n\t\tv = (*(PyCFunctionWithKeywords)meth)(self, arg, kw);\n\t\tif (v == NULL)\n\t\t    goto onError;\n\t\tPyTuple_SET_ITEM(w,i,v);\n\t    }\n\telse {\n\t    if (kw != NULL && PyDict_Size(kw) != 0) {\n\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\"this function takes no keyword arguments\");\n\t\treturn NULL;\n\t    }\n\t    for (i = 0; i < count; i++) {\n\t\tregister PyObject *v;\n\t    \n\t\tv = (*meth)(self, arg);\n\t\tif (v == NULL)\n\t\t    goto onError;\n\t\tPyTuple_SET_ITEM(w,i,v);\n\t    }\n\t}\n    }\n    else\n#endif\n\tfor (i = 0; i < count; i++) {\n\t    register PyObject *v;\n\t    \n\t    v = PyEval_CallObjectWithKeywords(func,arg,kw);\n\t    if (v == NULL)\n\t\tgoto onError;\n\t    PyTuple_SET_ITEM(w,i,v);\n\t}\n\n    Py_XDECREF(arg);\n    return w;\n\n onError:\n    Py_XDECREF(w);\n    Py_XDECREF(arg);\n    return NULL;\n}\n\nPy_C_Function( mxTools_mapply,\n\t       \"mapply(callable_objects,args=(),kw={})\\n\\n\"\n\t       \"Calls the callable_objects in the given order with the same\\n\"\n\t       \"arguments and returns a tuple with the return values.\")\n{\n    register Py_ssize_t i;\n    Py_ssize_t n;\n    PyObject *objects;\n    PyObject *arg = 0,*kw = 0;\n    PyObject *w = 0;\n\n    Py_Get3Args(\"O|OO\",\n\t\tobjects,arg,kw);\n\n    Py_XINCREF(arg);\n\n    n = PySequence_Length(objects);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"first argument must be a sequence\");\n\n    w = PyTuple_New(n);\n    if (w == NULL)\n\tgoto onError;\n\n    if (arg == NULL)\n\targ = PyTuple_New(0);\n    if (arg == NULL)\n\tgoto onError;\n\n    for (i = 0; i < n; i++) {\n\tregister PyObject *func;\n\tfunc = PySequence_GetItem(objects,i);\n\tif (!func)\n\t    goto onError;\n#ifdef PyCFunction_GET_FUNCTION\n\t/* Short-cut for C functions, taken from\n\t   ceval.c:call_builtin(); Note: this only works and is used\n\t   with my patched version of the interpreter. XXX Update when\n\t   ceval.c changes !!! */\n\tif (PyCFunction_Check(func)) {\n\t    PyObject *args = arg;\n\t    \n\t    if (!(PyCFunction_GET_FLAGS(func) & METH_VARARGS)) {\n\t\tPy_ssize_t size = PyTuple_GET_SIZE(args);\n\t\tif (size == 1)\n\t\t    args = PyTuple_GET_ITEM(args, 0);\n\t\telse if (size == 0)\n\t\t    args = NULL;\n\t    }\n\t    if (PyCFunction_GET_FLAGS(func) & METH_KEYWORDS) {\n\t\t    register PyObject *v;\n\t\t    v = (*(PyCFunctionWithKeywords)\\\n\t\t\t PyCFunction_GET_FUNCTION(func))\\\n\t\t\t  (PyCFunction_GET_SELF(func), \n\t\t\t   args, kw);\n\t\t    if (v == NULL) {\n\t\t\tPy_DECREF(func);\n\t\t\tgoto onError;\n\t\t    }\n\t\t    PyTuple_SET_ITEM(w,i,v);\n\t\t}\n\t    else {\n\t\tif (kw != NULL && PyDict_Size(kw) != 0) {\n\t\t    PyErr_SetString(PyExc_TypeError,\n\t\t\t\t  \"this function takes no keyword arguments\");\n\t\t    return NULL;\n\t\t} \n\t\telse {\n\t\t    register PyObject *v;\n\t\t    v = (*PyCFunction_GET_FUNCTION(func))\\\n\t\t\t(PyCFunction_GET_SELF(func), args);\n\t\t    if (v == NULL) {\n\t\t\tPy_DECREF(func);\n\t\t\tgoto onError;\n\t\t    }\n\t\t    PyTuple_SET_ITEM(w,i,v);\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t    {\n\t\tregister PyObject *v;\n\t\tv = PyEval_CallObjectWithKeywords(func,arg,kw);\n\t\tif (v == NULL) {\n\t\t    Py_DECREF(func);\n\t\t    goto onError;\n\t\t}\n\t\tPyTuple_SET_ITEM(w,i,v);\n\t    }\n\tPy_DECREF(func);\n    }\n    \n    Py_XDECREF(arg);\n    return w;\n\n onError:\n    Py_XDECREF(w);\n    Py_XDECREF(arg);\n    return NULL;\n}\n\nPy_C_Function( mxTools_method_mapply,\n\t       \"method_mapply(objects,methodname,args=(),kw={})\\n\\n\"\n\t       \"Calls the method methodname of all objects in the given\\n\"\n\t       \"order with the same arguments and returns a tuple with\\n\"\n\t       \"the return values.\")\n{\n    register Py_ssize_t i;\n    Py_ssize_t n;\n    PyObject *objects;\n    PyObject *arg = 0,*kw = 0;\n    PyObject *w = 0;\n    char *methodname;\n\n    Py_Get4Args(\"Os|OO\",\n\t\tobjects,methodname,arg,kw);\n\n    Py_XINCREF(arg);\n\n    n = PySequence_Length(objects);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"first argument must be a sequence\");\n\n    w = PyTuple_New(n);\n    if (w == NULL)\n\tgoto onError;\n\n    if (arg == NULL)\n\targ = PyTuple_New(0);\n    if (arg == NULL)\n\tgoto onError;\n\n    for (i = 0; i < n; i++) {\n\tregister PyObject *func;\n\t{\n\t    register PyObject *v;\n\t    v = PySequence_GetItem(objects,i);\n\t    if (!v)\n\t\tgoto onError;\n\t    func = PyObject_GetAttrString(v,methodname);\n\t    if (!func) {\n\t\tPy_DECREF(v);\n\t\tgoto onError;\n\t    }\n\t    Py_DECREF(v);\n\t}\n#ifdef PyCFunction_GET_FUNCTION\n\t/* Short-cut for C functions, taken from\n\t   ceval.c:call_builtin(); Note: this only works and is used\n\t   with my patched version of the interpreter. XXX Update when\n\t   ceval.c changes !!! */\n\tif (PyCFunction_Check(func)) {\n\t    PyObject *args = arg;\n\t    \n\t    if (!(PyCFunction_GET_FLAGS(func) & METH_VARARGS)) {\n\t\tPy_ssize_t size = PyTuple_GET_SIZE(args);\n\t\tif (size == 1)\n\t\t    args = PyTuple_GET_ITEM(args, 0);\n\t\telse if (size == 0)\n\t\t    args = NULL;\n\t    }\n\t    if (PyCFunction_GET_FLAGS(func) & METH_KEYWORDS) {\n\t\t    register PyObject *v;\n\t\t    v = (*(PyCFunctionWithKeywords)\\\n\t\t\t PyCFunction_GET_FUNCTION(func))\\\n\t\t\t  (PyCFunction_GET_SELF(func), \n\t\t\t   args, kw);\n\t\t    if (v == NULL) {\n\t\t\tPy_DECREF(func);\n\t\t\tgoto onError;\n\t\t    }\n\t\t    PyTuple_SET_ITEM(w,i,v);\n\t\t}\n\t    else {\n\t\tif (kw != NULL && PyDict_Size(kw) != 0) {\n\t\t    PyErr_SetString(PyExc_TypeError,\n\t\t\t\t  \"this function takes no keyword arguments\");\n\t\t    return NULL;\n\t\t} \n\t\telse {\n\t\t    register PyObject *v;\n\t\t    v = (*PyCFunction_GET_FUNCTION(func))\\\n\t\t\t(PyCFunction_GET_SELF(func), args);\n\t\t    if (v == NULL) {\n\t\t\tPy_DECREF(func);\n\t\t\tgoto onError;\n\t\t    }\n\t\t    PyTuple_SET_ITEM(w,i,v);\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t    {\n\t\tregister PyObject *v;\n\t\tv = PyEval_CallObjectWithKeywords(func,arg,kw);\n\t\tif (v == NULL) {\n\t\t    Py_DECREF(func);\n\t\t    goto onError;\n\t\t}\n\t\tPyTuple_SET_ITEM(w,i,v);\n\t    }\n\tPy_DECREF(func);\n    }\n    \n    Py_XDECREF(arg);\n    return w;\n\n onError:\n    Py_XDECREF(w);\n    Py_XDECREF(arg);\n    return NULL;\n}\n\nPy_C_Function( mxTools_trange,\n\t       \"trange([start=0,]stop[,step=1])\\n\\n\"\n\t       \"Returns tuple(range(start,stop,step))\")\n{\n    Py_ssize_t start, stop=INT_MAX, step=INT_MAX;\n    Py_ssize_t n;\n    register Py_ssize_t i;\n    register Py_ssize_t index;\n    PyObject *t = 0;\n\n    Py_Get3Args(Py_SSIZE_T_PARSERMARKER\n\t\t\"|\"\n\t\tPy_SSIZE_T_PARSERMARKER\n\t\tPy_SSIZE_T_PARSERMARKER,\n\t\tstart,stop,step);\n\n    /* Get the boundaries right... */\n    if (stop == INT_MAX) {\n\tstop = start;\n\tif (stop < 0)\n\t    stop = 0;\n\tstart = 0;\n\tstep = 1;\n\tn = stop;\n    }\n    else if (step == INT_MAX) {\n\tif (start > stop)\n\t    start = stop;\n\tstep = 1;\n\tn = stop - start;\n    }\n    else {\n\tPy_Assert(step != 0,\n\t\t  PyExc_ValueError,\n\t\t  \"step must not be zero\");\n\tif (step > 0) {\n\t    if (start > stop)\n\t\tstart = stop;\n\t    n = (stop - start + step - 1) / step;\n\t}\n\telse {\n\t    if (start < stop)\n\t\tstart = stop;\n\t    n = (start - stop - step - 1) / (-step);\n\t}\n    }\n\t\n    t = PyTuple_New(n);\n    if (!t)\n\tgoto onError;\n    \n    if (step == 1)\n\tfor (index = 0, i = start; index < n; index++, i++) {\n\t    register PyObject *v = PyInt_FromLong((long)i);\n\t    if (!v)\n\t\tgoto onError;\n\t    PyTuple_SET_ITEM(t,index,v);\n\t}\n    else\n\tfor (index = 0, i = start; index < n; index++, i += step) {\n\t    register PyObject *v = PyInt_FromLong((long)i);\n\t    if (!v)\n\t\tgoto onError;\n\t    PyTuple_SET_ITEM(t,index,v);\n\t}\n\t\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_indices,\n\t       \"indices(object)\\n\\n\"\n\t       \"Returns tuple(range(len(object))).\")\n{\n    register Py_ssize_t n;\n    register Py_ssize_t index;\n    register PyObject *t = 0;\n    PyObject *w;\n\n    Py_GetArgObject(w);\n\n    n = PyObject_Length(w);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"argument must have a __len__ method\");\n\n    t = PyTuple_New(n);\n    if (!t)\n\tgoto onError;\n    \n    for (index = 0; index < n; index++) {\n\tregister PyObject *v = PyInt_FromLong((long)index);\n\tif (!v)\n\t    goto onError;\n\tPyTuple_SET_ITEM(t,index,v);\n    }\n\t\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_range_len,\n\t       \"range_len(object)\\n\"\n\t       \"Returns range(len(object)).\")\n{\n    register Py_ssize_t n;\n    register Py_ssize_t index;\n    register PyObject *t = 0;\n    PyObject *w;\n\n    Py_GetArgObject(w);\n\n    n = PyObject_Length(w);\n    if (n < 0)\n\tgoto onError;\n\n    t = PyList_New(n);\n    if (!t)\n\tgoto onError;\n    \n    for (index = 0; index < n; index++) {\n\tregister PyObject *v = PyInt_FromLong((long)index);\n\tif (!v)\n\t    goto onError;\n\tPyList_SET_ITEM(t,index,v);\n    }\n\t\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_irange,\n\t       \"irange(object[,indices])\\n\\n\"\n\t       \"Returns a tuple of tuples (index,object[index]), one\\n\"\n\t       \"for each item in the sequence indices or, if this is not\\n\"\n\t       \"given, in trange(len(object)).\")\n{\n    register Py_ssize_t n;\n    register Py_ssize_t index;\n    PyObject *t = 0;\n    PyObject *w;\n    PyObject *indices = 0;\n\n    Py_Get2Args(\"O|O\",\n\t\tw,indices);\n\n    if (!indices) {\n\tn = PyObject_Length(w);\n\tif (n < 0)\n\t    Py_Error(PyExc_TypeError,\n\t\t     \"first argument must have a __len__ method\");\n    }\n    else {\n\tn = PyObject_Length(indices);\n\tif (n < 0)\n\t    Py_Error(PyExc_TypeError,\n\t\t     \"second argument must be a sequence\");\n    }\n\n    t = PyTuple_New(n);\n    if (!t)\n\tgoto onError;\n    \n    if (!indices)\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *u;\n\t    PyObject *v;\n\t    PyObject *x;\n\t    v = PyInt_FromLong((long)index);\n\t    if (!v)\n\t\tgoto onError;\n\t    u = PyTuple_New(2);\n\t    if (!u) {\n\t\tPy_DECREF(v);\n\t\tgoto onError;\n\t    }\n\t    x = PyObject_GetItem(w,v);\n\t    if (!x) {\n\t\tPy_DECREF(v);\n\t\tPy_DECREF(u);\n\t\tgoto onError;\n\t    }\n\t    PyTuple_SET_ITEM(u,0,v);\n\t    PyTuple_SET_ITEM(u,1,x);\n\t    PyTuple_SET_ITEM(t,index,u);\n\t}\n    else\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *u;\n\t    PyObject *x;\n\t    PyObject *v;\n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v)\n\t\tgoto onError;\n\t    u = PyTuple_New(2);\n\t    if (!u) {\n\t\tPy_DECREF(v);\n\t\tgoto onError;\n\t    }\n\t    x = PyObject_GetItem(w,v);\n\t    if (!x) {\n\t\tPy_DECREF(v);\n\t\tPy_DECREF(u);\n\t\tgoto onError;\n\t    }\n\t    PyTuple_SET_ITEM(u,0,v);\n\t    PyTuple_SET_ITEM(u,1,x);\n\t    PyTuple_SET_ITEM(t,index,u);\n\t}\n\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_get,\n\t       \"get(object,index[,default])\\n\\n\"\n\t       \"Returns object[index], or, if that fails, default.\")\n{\n    PyObject *x, *w, *index;\n    PyObject *def = mxNotGiven;\n\n    Py_Get3Args(\"OO|O\",\n\t\tw,index,def);\n\n    x = PyObject_GetItem(w,index);\n    if (!x) {\n\tif (def != mxNotGiven) {\n\t    PyErr_Clear();\n\t    x = def;\n\t    Py_INCREF(x);\n\t}\n\telse\n\t    goto onError;\n    }\n    return x;\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_extract,\n\t       \"extract(object,indices[,defaults])\\n\\n\"\n\t       \"Returns a list of entries object[index] for each index\\n\"\n\t       \"in the sequence indices. defaults must have the same length\\n\"\n\t       \"as indices and is used to provide default values in case\\n\"\n\t       \"the lookup fails.\")\n{\n    Py_ssize_t n = 0;\n    register Py_ssize_t index;\n    PyObject *t = 0;\n    PyObject *w;\n    PyObject *indices;\n    PyObject *defaults = 0;\n\n    Py_Get3Args(\"OO|O\",\n\t\tw,indices,defaults);\n\n    n = PyObject_Length(indices);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"second argument must be a sequence\");\n    \n    t = PyList_New(n);\n    if (!t)\n\tgoto onError;\n    \n    if (defaults)\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *x;\n\t    register PyObject *v;\n\n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v) {\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"index value nr. %ld not accessible\",\n\t\t\t     (long)index);\n\t\tgoto onError;\n\t    }\n\t    x = PyObject_GetItem(w,v);\n\t    Py_DECREF(v);\n\t    if (!x) {\n\t\t/* Use default value */\n\t\tPyErr_Clear();\n\t\tx = PySequence_GetItem(defaults,index);\n\t\tif (!x) {\n\t\t    PyErr_Format(\n\t\t\t     PyExc_IndexError,\n\t\t\t     \"default value for index nr. %ld not accessible\",\n\t\t\t     (long)index);\n\t\t    goto onError;\n\t\t}\n\t    }\n\t    PyList_SET_ITEM(t,index,x);\n\t}\n    else\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *x;\n\t    register PyObject *v;\n\n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v) {\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"index value nr. %ld not accessible\",\n\t\t\t     (long)index);\n\t\tgoto onError;\n\t    }\n\t    x = PyObject_GetItem(w,v);\n\t    Py_DECREF(v);\n\t    if (!x) {\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"default value for index nr. %ld not accessible\",\n\t\t\t     (long)index);\n\t\tgoto onError;\n\t    }\n\t    PyList_SET_ITEM(t,index,x);\n\t}\n\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_iremove,\n\t       \"iremove(object,indices)\\n\\n\"\n\t       \"Removes the items indexed by indices from object.\\n\"\n\t       \"For sequences the index list must be sorted ascending;\\n\"\n\t       \"an IndexError will be raised otherwise (object is then\\n\"\n\t       \"left in an undefined state).\"\n\t       )\n{\n    Py_ssize_t n = 0;\n    register Py_ssize_t index;\n    PyObject *w;\n    PyObject *indices;\n\n    Py_Get2Args(\"OO\",\n\t\tw,indices);\n\n    n = PyObject_Length(indices);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"second argument must be a sequence\");\n    \n    if (PyMapping_Check(w))\n\tfor (index = n - 1; index >= 0; index--) {\n\t    register PyObject *v;\n\t    register int rc;\n\t    \n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v) {\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"index %ld not accessible\",\n\t\t\t     (long)index);\n\t\tgoto onError;\n\t    }\n\t    rc = PyMapping_DelItem(w,v);\n\t    Py_DECREF(v);\n\t    if (rc)\n        \tgoto onError;\n\t}\n\n    else if (PySequence_Check(w)) {\n\tPy_ssize_t prev_index = INT_MAX;\n\t\n\tfor (index = n - 1; index >= 0; index--) {\n\t    register PyObject *v;\n\t    register Py_ssize_t i;\n\t    \n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v && PyInt_Check(v)) {\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"index %ld not accessible or not an integer\",\n\t\t\t     (long)index);\n\t\tgoto onError;\n\t    }\n\t    i = PyInt_AS_LONG(v);\n\t    Py_DECREF(v);\n\t    if (prev_index >= i) {\n\t\tif (PySequence_DelItem(w,i))\n\t\t    goto onError;\n\t\tprev_index = i;\n\t    }\n\t    else\n\t\tPy_Error(PyExc_IndexError,\n\t\t\t \"indices must be sorted ascending for sequences\");\n\t}\n    }\n    \n    else\n\tPy_Error(PyExc_TypeError,\n\t\t \"object must be a mapping or a sequence\");\n    \n    Py_ReturnNone();\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_ifilter,\n\t       \"ifilter(condition,object[,indices])\\n\\n\"\n\t       \"Returns a list of tuples (index,object[index]) such that\\n\"\n\t       \"condition(object[item]) is true and index is found in\\n\"\n\t       \"the sequence indices (defaulting to indices(object)).\\n\"\n\t       \"Order is preserved. condition must be a callable object.\")\n{\n    Py_ssize_t n;\n    register Py_ssize_t index;\n    PyObject *t = 0;\n    PyObject *w;\n    PyObject *indices = 0;\n    PyObject *condition;\n    PyObject *argtuple = 0;\n\n    Py_Get3Args(\"OO|O\",\n\t\tcondition,w,indices);\n\n    if (!indices) {\n\tn = PyObject_Length(w);\n\tif (n < 0)\n\t    Py_Error(PyExc_TypeError,\n\t\t     \"second argument must be have a __len__ method\");\n    }\n    else {\n\tn = PyObject_Length(indices);\n\tif (n < 0)\n\t    Py_Error(PyExc_TypeError,\n\t\t     \"third argument must be a sequence\");\n    }\n\n    t = PyList_New(0);\n    if (!t)\n\tgoto onError;\n    \n    argtuple = PyTuple_New(1);\n    if (!argtuple)\n\tgoto onError;\n\n    if (!indices)\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *v;\n\t    register PyObject *x;\n\t    register PyObject *z;\n\n\t    v = PyInt_FromLong((long)index);\n\t    if (!v)\n\t\tgoto onError;\n\t    x = PyObject_GetItem(w,v);\n\t    if (!x) {\n\t\tPy_DECREF(v);\n\t\tgoto onError;\n\t    }\n\t    /* Replace the argtuple entry with the new item x */\n\t    Py_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n\t    PyTuple_SET_ITEM(argtuple,0,x);\n\t    /* Add a tuple if condition says it's ok */\n\t    z = PyEval_CallObject(condition,argtuple);\n\t    if (!z)\n\t\tgoto onError;\n\t    if (PyObject_IsTrue(z)) {\n\t\tregister PyObject *u;\n\n\t\tu = PyTuple_New(2);\n\t\tif (!u) {\n\t\t    Py_DECREF(v);\n\t\t    Py_DECREF(z);\n\t\t    goto onError;\n\t\t}\n\t\tPy_INCREF(x);\n\t\tPyTuple_SET_ITEM(u,0,v);\n\t\tPyTuple_SET_ITEM(u,1,x);\n\t\tPyList_Append(t,u);\n\t\tPy_DECREF(u);\n\t    }\n\t    else\n\t\tPy_DECREF(v);\n\t    Py_DECREF(z);\n\t}\n    else\n\tfor (index = 0; index < n; index++) {\n\t    register PyObject *v;\n\t    register PyObject *x;\n\t    register PyObject *z;\n\n\t    v = PySequence_GetItem(indices,index);\n\t    if (!v)\n\t\tgoto onError;\n\t    x = PyObject_GetItem(w,v);\n\t    if (!x) {\n\t\tPy_DECREF(v);\n\t\tgoto onError;\n\t    }\n\t    /* Replace the argtuple entry with the new item x */\n\t    Py_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n\t    PyTuple_SET_ITEM(argtuple,0,x);\n\t    /* Add a tuple if condition says it's ok */\n\t    z = PyEval_CallObject(condition,argtuple);\n\t    if (!z)\n\t\tgoto onError;\n\t    if (PyObject_IsTrue(z)) {\n\t\tregister PyObject *u;\n\n\t\tu = PyTuple_New(2);\n\t\tif (!u) {\n\t\t    Py_DECREF(v);\n\t\t    Py_DECREF(z);\n\t\t    goto onError;\n\t\t}\n\t\tPy_INCREF(x);\n\t\tPyTuple_SET_ITEM(u,0,v);\n\t\tPyTuple_SET_ITEM(u,1,x);\n\t\tPyList_Append(t,u);\n\t\tPy_DECREF(u);\n\t    }\n\t    else\n\t\tPy_DECREF(v);\n\t    Py_DECREF(z);\n\t}\n\n    Py_DECREF(argtuple);\n    return t;\n\n onError:\n    Py_XDECREF(argtuple);\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_tuples,\n\t       \"tuples(sequence)\\n\\n\"\n\t       \"Returns a list much like apply(map,(None,)+tuple(sequence)))\\n\"\n\t       \"does. Only with a bit more intuitive name. This function does\\n\"\n\t       \"not optimize for the case where the sequences are of different\\n\"\n\t       \"size and the resulting list of tuples will always\\n\"\n\t       \"have the length of the first sequence. Missing entries\\n\"\n\t       \"from the other sequences are filled in with None.\"\n\t       )\n{\n    Py_ssize_t n,m;\n    register Py_ssize_t i;\n    register Py_ssize_t j;\n    PyObject *l = 0;\n    PyObject *arg,*w;\n\n    Py_GetArgObject(arg);\n\n    /* Get tuple size (m) */\n    m = PySequence_Length(arg);\n    Py_Assert(m > 0,\n              PyExc_TypeError,\n              \"sequence must have at least one element\");\n\n    /* Get list size (n) */\n    w = PySequence_GetItem(arg,0);\n    if (!w)\n\tgoto onError;\n    n = PySequence_Length(w);\n    Py_DECREF(w);\n    Py_Assert(n >= 0,\n\t      PyExc_TypeError,\n\t      \"sequence elements must be sequences\");\n\n    /* XXX Could speed this up by rearranging and joining the loops */\n\n    /* Create list of tuples */\n    l = PyList_New(n);\n    if (!l)\n\tgoto onError;\n    for (j = 0; j < n; j++) {\n        PyObject *v;\n        \n        v = PyTuple_New(m);\n\tif (!v)\n\t    goto onError;\n\tPyList_SET_ITEM(l,j,v);\n    }\n\n    /* Fill them in */\n    for (i = 0; i < m; i++) {\n\tPyObject *u;\n\t\n\tu = PySequence_GetItem(arg,i);\n\tif (!u)\n\t    goto onError;\n\t\n\tfor (j = 0; j < n; j++) {\n\t    PyObject *v;\n\t    \n\t    v = PySequence_GetItem(u,j);\n\t    if (!v) {\n\t\tif (PyErr_ExceptionMatches(PyExc_IndexError)) {\n\t\t    PyErr_Clear();\n\t\t    /* Fill up the rest with None */\n\t\t    for (; j < n; j++) {\n\t\t\tPy_INCREF(Py_None);\n\t\t\tPyTuple_SET_ITEM(PyList_GET_ITEM(l,j),i,Py_None);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\telse {\n\t\t    Py_DECREF(u);\n\t\t    goto onError;\n\t\t}\n\t    }\n\t    PyTuple_SET_ITEM(PyList_GET_ITEM(l,j),i,v);\n\t}\n\tPy_DECREF(u);\n    }\n    return l;\n\n onError:\n    Py_XDECREF(l);\n    return NULL;\n}\n\nPy_C_Function( mxTools_lists,\n\t       \"lists(sequence)\\n\\n\"\n\t       \"Same as tuples(), except that a tuple of lists is created.\"\n\t       )\n{\n    Py_ssize_t n,m;\n    register Py_ssize_t i;\n    register Py_ssize_t j;\n    PyObject *t = 0;\n    PyObject *arg,*w;\n\n    Py_GetArgObject(arg);\n\n    /* Get list size (n) */\n    n = PySequence_Length(arg);\n    Py_Assert(n > 0,\n              PyExc_TypeError,\n              \"sequence must have at least one element\");\n\n    /* Get tuple size (m) */\n    w = PySequence_GetItem(arg,0);\n    if (!w)\n\tgoto onError;\n    m = PySequence_Length(w);\n    Py_DECREF(w);\n    Py_Assert(m >= 0,\n\t      PyExc_TypeError,\n\t      \"sequence elements must be sequences\");\n\n    /* XXX Could speed this up by rearranging and joining the loops */\n    \n    /* Create tuple of lists */\n    t = PyTuple_New(m);\n    if (!t)\n        goto onError;\n    for (j = 0; j < m; j++) {\n        PyObject *v;\n        \n        v = PyList_New(n);\n        if (!v)\n            goto onError;\n        PyTuple_SET_ITEM(t,j,v);\n    }\n\n    /* Fill them in */\n    for (i = 0; i < n; i++) {\n\tPyObject *u;\n            \n\tu = PySequence_GetItem(arg,i);\n\tif (!u)\n\t    goto onError;\n\n\tfor (j = 0; j < m; j++) {\n\t    PyObject *v;\n                \n\t    v = PySequence_GetItem(u,j);\n\t    if (!v) {\n\t\tif (PyErr_ExceptionMatches(PyExc_IndexError)) {\n\t\t    PyErr_Clear();\n\t\t    /* Fill up the rest with None */\n\t\t    for (; j < n; j++) {\n\t\t\tPy_INCREF(Py_None);\n\t\t\tPyList_SET_ITEM(PyTuple_GET_ITEM(t,j),i,Py_None);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\telse {\n\t\t    Py_DECREF(u);\n\t\t    goto onError;\n\t\t}\n\t    }\n\t    PyList_SET_ITEM(PyTuple_GET_ITEM(t,j),i,v);\n\t}\n\tPy_DECREF(u);\n    }\n    return t;\n\n onError:\n    Py_XDECREF(t);\n    return NULL;\n}\n\nPy_C_Function( mxTools_count,\n\t       \"count(condition,sequence)\\n\\n\"\n\t       \"Count the number of objects in sequence for which the\\n\"\n\t       \"selection function condition returns true and return the\\n\"\n\t       \"result as integer.\")\n{\n    PyObject *condition;\n    PyObject *list;\n    PyObject *argtuple = 0;\n    register Py_ssize_t i;\n    register Py_ssize_t n;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tcondition,list);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"second argument must be a sequence\");\n\n    argtuple = PyTuple_New(1);\n    if (!argtuple)\n\tgoto onError;\n\n    for(i = 0, n = 0; i < length; i++) {\n\tregister PyObject *v;\n\tregister PyObject *w;\n\n\tv = PySequence_GetItem(list,i);\n\tif (!v)\n\t    goto onError;\n\n\t/* Replace the argtuple entry with the new item */\n\tPy_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n\tPyTuple_SET_ITEM(argtuple,0,v);\n\n\t/* Let's see what condition thinks about this item */\n\tw = PyEval_CallObject(condition,argtuple);\n\tif (!w)\n\t    goto onError;\n\tif (PyObject_IsTrue(w))\n\t    n++;\n\tPy_DECREF(w);\n    }\n\n    Py_DECREF(argtuple);\n    return PyInt_FromLong((long)n);\nonError:\n    Py_XDECREF(argtuple);\n    return NULL;\n}\n\nPy_C_Function( mxTools_exists,\n\t       \"exists(condition,sequence)\\n\"\n\t       \"Return 1 if and only if condition is true for at least one\\n\"\n\t       \"of the items in sequence and 0 otherwise. condition\\n\"\n\t       \"must be a callable object.\")\n{\n    PyObject *condition;\n    PyObject *list;\n    PyObject *argtuple = 0;\n    register Py_ssize_t i;\n    Py_ssize_t n;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tcondition,list);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"second argument must be a sequence\");\n\n    argtuple = PyTuple_New(1);\n    if (!argtuple)\n\tgoto onError;\n\n    for(i = 0, n = 0; i < length; i++) {\n\tregister PyObject *v;\n\tregister PyObject *w;\n\n\tv = PySequence_GetItem(list,i);\n\tif (!v)\n\t    goto onError;\n\n\t/* Replace the argtuple entry with the new item */\n\tPy_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n\tPyTuple_SET_ITEM(argtuple,0,v);\n\n\t/* Let's see what condition thinks about this item */\n\tw = PyEval_CallObject(condition,argtuple);\n\tif (!w)\n\t    goto onError;\n\tif (PyObject_IsTrue(w)) {\n\t    n = 1;\n\t    Py_DECREF(w);\n\t    break;\n\t}\n\tPy_DECREF(w);\n    }\n\n    Py_DECREF(argtuple);\n    return PyInt_FromLong((long)n);\n onError:\n    Py_XDECREF(argtuple);\n    return NULL;\n}\n\nPy_C_Function( mxTools_forall,\n\t       \"forall(condition,sequence)\\n\\n\"\n\t       \"Return 1 if and only if condition is true for all\\n\"\n\t       \"of the items in sequence and 0 otherwise. condition\\n\"\n\t       \"must be a callable object.\")\n{\n    PyObject *condition;\n    PyObject *list;\n    PyObject *argtuple = 0;\n    register Py_ssize_t i;\n    Py_ssize_t n;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tcondition,list);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"second argument must be a sequence\");\n\n    argtuple = PyTuple_New(1);\n    if (!argtuple)\n\tgoto onError;\n\n    for(i = 0, n = 1; i < length; i++) {\n\tregister PyObject *v;\n\tregister PyObject *w;\n\n\tv = PySequence_GetItem(list,i);\n\tif (!v)\n\t    goto onError;\n\n\t/* Replace the argtuple entry with the new item */\n\tPy_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n\tPyTuple_SET_ITEM(argtuple,0,v);\n\n\t/* Let's see what condition thinks about this item */\n\tw = PyEval_CallObject(condition,argtuple);\n\tif (!w)\n\t    goto onError;\n\tif (!PyObject_IsTrue(w)) {\n\t    n = 0;\n\t    Py_DECREF(w);\n\t    break;\n\t}\n\tPy_DECREF(w);\n    }\n\n    Py_DECREF(argtuple);\n    return PyInt_FromLong((long)n);\n onError:\n    Py_XDECREF(argtuple);\n    return NULL;\n}\n\nPy_C_Function( mxTools_index,\n               \"index(condition,sequence)\\n\\n\"\n               \"Return the index of the first item for which condition\\n\"\n\t       \"returns true. A ValueError is raised in case no item\\n\"\n\t       \"is found.\")\n{\n    PyObject *condition;\n    PyObject *list = 0;\n    PyObject *argtuple = 0;\n    register Py_ssize_t i;\n    Py_ssize_t n;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tcondition,list);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n        goto onError;\n\n    argtuple = PyTuple_New(1);\n    if (!argtuple)\n        goto onError;\n\n    for(i = 0, n = -1; i < length; i++) {\n        register PyObject *v;\n        register PyObject *w;\n\n        v = PySequence_GetItem(list,i);\n        if (!v)\n            goto onError;\n\n        /* Replace the argtuple entry with the new item */\n        Py_XDECREF(PyTuple_GET_ITEM(argtuple,0));\n        PyTuple_SET_ITEM(argtuple,0,v);\n\n        /* Let's see what condition thinks about this item */\n        w = PyEval_CallObject(condition,argtuple);\n        if (!w)\n            goto onError;\n        if (PyObject_IsTrue(w)) {\n            n = i;\n            Py_DECREF(w);\n            break;\n        }\n        Py_DECREF(w);\n    }\n    if (n == -1)\n\tPy_Error(PyExc_ValueError,\n\t\t \"condition is false for all items in sequence\");\n\n    Py_DECREF(argtuple);\n    return PyInt_FromLong((long)n);\n\n onError:\n    Py_XDECREF(argtuple);\n    return NULL;\n}\n\nPy_C_Function( mxTools_sizeof,\n\t       \"sizeof(object)\\n\\n\"\n\t       \"Returns the size in memory of the object in bytes.\\n\"\n\t       \"Note that this doesn't show any extra space allocated by\\n\"\n\t       \"the object.\")\n{\n    Py_ssize_t size;\n    register PyObject *w;\n    PyTypeObject *t;\n\n    Py_GetArgObject(w);\n    t = w->ob_type;\n    size = t->tp_basicsize;\n    if (t->tp_itemsize)\n\tsize += t->tp_itemsize * ((PyVarObject *)w)->ob_size;\n\t\n    return PyInt_FromLong((long)size);\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_findattr,\n\t       \"findattr(objectlist,attrname)\\n\\n\"\n\t       \"Returns the first attribute with name attrname found\\n\"\n\t       \"among the objects in the list.\")\n{\n    PyObject *list;\n    PyObject *name;\n    register Py_ssize_t i;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tlist,name);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"first argument must be a sequence\");\n\n    Py_Assert(PyString_Check(name),\n\t      PyExc_TypeError,\n\t      \"second argument must be a string\");\n\n    for(i = 0; i < length; i++) {\n\tPyObject *v;\n\tPyObject *w;\n\n\tv = PySequence_GetItem(list,i);\n\tif (!v)\n\t    goto onError;\n\n\tw = PyObject_GetAttr(v,name);\n\tif (w)\n\t    return w;\n\telse if (!PyErr_ExceptionMatches(PyExc_AttributeError))\n\t    goto onError;\n\telse\n\t    PyErr_Clear();\n    }\n    Py_Error(PyExc_AttributeError,\n\t     PyString_AS_STRING(name));\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_attrlist,\n\t       \"attrlist(objectlist,attrname)\\n\\n\"\n\t       \"Returns a list of all attributes with the given name\\n\"\n\t       \"found among the objects in objectlist.\"\n\t       )\n{\n    PyObject *list,*l=0;\n    PyObject *name;\n    register Py_ssize_t i;\n    Py_ssize_t length;\n\n    Py_Get2Args(\"OO\",\n\t\tlist,name);\n\n    length = PySequence_Length(list);\n    if (length < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"first argument must be a sequence\");\n\n    Py_Assert(PyString_Check(name),\n\t      PyExc_TypeError,\n\t      \"second argument must be a string\");\n\n    l = PyList_New(0);\n    if (!l)\n\tgoto onError;\n\n    for(i = 0; i < length; i++) {\n\tPyObject *v;\n\tPyObject *w;\n\n\tv = PySequence_GetItem(list,i);\n\tif (!v)\n\t    goto onError;\n\n\tw = PyObject_GetAttr(v,name);\n\tif (w) {\n\t    PyList_Append(l,w);\n\t    Py_DECREF(w);\n\t}\n\telse if (!PyErr_ExceptionMatches(PyExc_AttributeError))\n\t    goto onError;\n\telse\n\t    PyErr_Clear();\n    }\n    return l;\n\n onError:\n    Py_XDECREF(l);\n    return NULL;\n}\n\nPy_C_Function( mxTools_dict,\n\t       \"dict(seq)\\n\\n\"\n\t       \"Creates a dictionary from the given items sequence.\\n\"\n\t       \"The sequence must contain sub-sequences of at least length 2,\\n\"\n\t       \"the first entry being interpreted as the key and the second as\\n\"\n\t       \"the value.\")\n{\n    Py_ssize_t n;\n    PyObject *seq,*d = 0;\n    register Py_ssize_t i;\n    register PyObject *k = 0;\n    register PyObject *v = 0;\n\n    Py_GetArgObject(seq);\n    n = PySequence_Length(seq);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"argument must be a sequence\");\n\n    d = PyDict_New();\n    if (!d)\n\tgoto onError;\n\n    for (i = 0; i < n; i++) {\n\tregister PyObject *o;\n\n\to = PySequence_GetItem(seq,i);\n\tif (!o)\n\t    goto onError;\n\tk = PySequence_GetItem(o,0);\n\tv = PySequence_GetItem(o,1);\n\tPy_DECREF(o);\n\n\tif (!k || !v) {\n\t    PyErr_Format(PyExc_TypeError,\n\t\t\t \"item %ld in sequence doesn't have two entries\",\n\t\t\t (long)i);\n\t    goto onError;\n\t}\n\tif (PyDict_SetItem(d,k,v))\n\t    goto onError;\n\tPy_DECREF(k);\n\tPy_DECREF(v);\n    }\n\n    return d;\n onError:\n    Py_XDECREF(d);\n    Py_XDECREF(k);\n    Py_XDECREF(v);\n    return NULL;\n}\n\nPy_C_Function( mxTools_setdict,\n\t       \"setdict(seq,value=None)\\n\\n\"\n\t       \"Creates a dictionary from the given items sequence.\\n\"\n\t       \"The sequence must hashable entries which are used as\\n\"\n\t       \"dictionary keys. The values are all set to value.\"\n\t       )\n{\n    Py_ssize_t n;\n    PyObject *seq,*d = 0,*value = 0;\n    register Py_ssize_t i;\n\n    Py_Get2Args(\"O|O\",\n\t\tseq,value);\n    n = PySequence_Length(seq);\n    if (n < 0)\n\tPy_Error(PyExc_TypeError,\n\t\t \"argument must be a sequence\");\n\n    if (!value) {\n\tPy_INCREF(Py_None);\n\tvalue = Py_None;\n    }\n    else\n\tPy_INCREF(value);\n\n    d = PyDict_New();\n    if (!d)\n\tgoto onError;\n\n    for (i = 0; i < n; i++) {\n\tregister PyObject *k;\n\n\tk = PySequence_GetItem(seq,i);\n\tif (!k)\n\t    goto onError;\n\tif (PyDict_SetItem(d,k,value))\n\t    goto onError;\n\tPy_DECREF(k);\n    }\n\n    Py_DECREF(value);\n    return d;\n\n onError:\n    Py_XDECREF(d);\n    Py_XDECREF(value);\n    return NULL;\n}\n\nPy_C_Function( mxTools_invdict,\n\t       \"invdict(d)\\n\\n\"\n\t       \"Creates a dictionary with inverse mappings from the\\n\"\n\t       \"given dictionary d.\")\n{\n    Py_ssize_t pos;\n    PyObject *key,*value;\n    PyObject *d,*inv = 0;\n\n    Py_GetArgObject(d);\n    Py_Assert(PyDict_Check(d),\n\t      PyExc_TypeError,\n\t      \"argument must be a dictionary\");\n\n    inv = PyDict_New();\n    if (!inv)\n\tgoto onError;\n\n    pos = 0;\n    while (PyDict_Next(d, &pos, &key, &value)) {\n\tif (PyDict_SetItem(inv,value,key))\n\t    goto onError;\n    }\n\n    return inv;\n onError:\n    Py_XDECREF(inv);\n    return NULL;\n}\n\nPy_C_Function( mxTools_reverse,\n\t       \"reverse(seq)\\n\\n\"\n\t       \"Creates a new sequence with reversed order of the items in\\n\"\n\t       \"seq. If seq is a tuple, then a tuple is returned. Otherwise\\n\"\n\t       \"a list is returned.\")\n{\n    PyObject *seq,*w = 0;\n\n    Py_GetArgObject(seq);\n\n    if (PyTuple_Check(seq)) {\n\tregister Py_ssize_t i;\n\tregister Py_ssize_t n = PyTuple_GET_SIZE(seq);\n\t\n\tw = PyTuple_New(n);\n\tif (!w)\n\t    goto onError;\n\n\tfor(i = 0; i < n;) {\n\t    register PyObject *o;\n\n\t    o = PyTuple_GET_ITEM(seq,i);\n\t    Py_INCREF(o);\n\t    i++;\n\t    PyTuple_SET_ITEM(w,n-i,o);\n\t}\n    }\n    else if (PyList_Check(seq)) {\n\tregister Py_ssize_t i;\n\tregister Py_ssize_t n = PyList_GET_SIZE(seq);\n\t\n\tw = PyList_New(n);\n\tif (!w)\n\t    goto onError;\n\n\tfor(i = 0; i < n;) {\n\t    register PyObject *o;\n\n\t    o = PyList_GET_ITEM(seq,i);\n\t    Py_INCREF(o);\n\t    i++;\n\t    PyList_SET_ITEM(w,n-i,o);\n\t}\n    }\n    else {\n\tregister Py_ssize_t i;\n\tregister Py_ssize_t n = PySequence_Length(seq);\n\n\tif (n < 0)\n\t    Py_Error(PyExc_TypeError,\n\t\t     \"argument must be a sequence\");\n\n\tw = PyList_New(n);\n\tif (!w)\n\t    goto onError;\n\n\tfor(i = 0; i < n;) {\n\t    register PyObject *o;\n\n\t    o = PySequence_GetItem(seq,i);\n\t    if (!o)\n\t\tPyErr_Format(PyExc_IndexError,\n\t\t\t     \"item %ld of sequence\",\n\t\t\t     (long)i);\n\t    Py_INCREF(o);\n\t    i++;\n\t    PyList_SET_ITEM(w,n-i,o);\n\t}\n    }\n\n    return w;\n onError:\n    Py_XDECREF(w);\n    return NULL;\n}\n\n#ifdef INCLUDE_FUNSTUFF\nstatic\nvoid mxTools_free(void *p)\n{\n    free(p);\n}\n\nPy_C_Function( mxTools_malloc,\n\t       \"malloc(x)\\n\\n\")\n{\n    Py_ssize_t x;\n    char *p;\n    register Py_ssize_t i;\n    register char *c;\n\n    Py_GetSingleArg(Py_SSIZE_T_PARSERMARKER, x);\n\n    /* Allocate virtual memory */\n    p = (char *)malloc(x);\n    if (!p) {\n\tPyErr_NoMemory();\n\tgoto onError;\n    }\n\n    /* Turn the virtual memory into \"real\" one */\n    i = x;\n    c = p;\n    while (i--)\n\t*c++ = '\\0';\n\n    return PyCObject_FromVoidPtr(p,mxTools_free);\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_caching_eval,\n\t       \"caching_eval(code_string)\\n\\n\"\n\t       )\n{\n    PyObject *codestr;\n\n    Py_GetArg(\"O\", codestr);\n\n    Py_Assert(PyString_Check(codestr),\n\t      PyExc_TypeError,\n\t      \"arg must be a string\");\n\n    return mxTools_EvalCodeString(codestr);\n\n onError:\n    return NULL;\n}\n#endif\n\nPy_C_Function( mxTools_acquire,\n\t       \"acquire(self,name[,baseobjattr='baseobj'])\\n\\n\"\n\t       \"Tries to get the attribute name from self.<baseobjattr>.\\n\"\n\t       \"If this is not defined or None, an AttributeError is\\n\"\n\t       \"raised. Otherwise getattr(self.<baseobjattr>,name) is\\n\"\n\t       \"returned. Attribute names must not start with an\\n\"\n\t       \"underscore (this too raises an AttributeError).\\n\")\n{\n    PyObject *obj,*baseobj,*name;\n    PyObject *v,*baseobjattr = mxTools_BaseobjAttribute;\n\n    static int recdepth;\n\n    recdepth++;\n    Py_Assert(recdepth < 2000,\n\t      PyExc_SystemError,\n\t      \"maximum acquire() recursion depth exceeded\");\n\n    Py_Get3Args(\"OO|O\",\n\t\tobj,name,baseobjattr);\n\n    Py_Assert(PyString_Check(name),\n\t      PyExc_TypeError,\n\t      \"attribute name must be a string\");\n    \n    /* We don't acquire names starting with underscores */\n    Py_Assert(PyString_AS_STRING(name)[0] != '_',\n\t      PyExc_AttributeError,\n\t      PyString_AS_STRING(name));\n\n    /* baseobj = obj.<baseobjattr> */\n    baseobj = PyObject_GetAttr(obj,baseobjattr);\n    if (!baseobj || baseobj == Py_None) {\n\tPy_XDECREF(baseobj);\n\tPy_Error(PyExc_AttributeError,\n\t\t PyString_AS_STRING(name));\n    }\n    \n    /* Now return getattr(baseobj,name) */\n    v = PyObject_GetAttr(baseobj,name);\n    Py_DECREF(baseobj);\n    recdepth--;\n    return v;\n\n onError:\n    recdepth--;\n    return NULL;\n}\n\nPy_C_Function( mxTools_verbosity,\n\t       \"verbosity([level])\\n\\n\"\n\t       \"Sets the value of the interpreter's verbosity flag.\\n\"\n\t       \"Returns the flag's value before changing it or, when called\\n\"\n\t       \"without level, the current value.\"\n\t       )\n{\n    int value = Py_VerboseFlag,\n\told_value = value;\n\n    Py_GetArg(\"|i\", value);\n    Py_VerboseFlag = value;\n\n    return PyInt_FromLong((long)old_value);\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_debugging,\n\t       \"debugging([level])\\n\\n\"\n\t       \"Sets the value of the interpreter's debugging flag.\\n\"\n\t       \"Returns the flag's value before changing it or, when called\\n\"\n\t       \"without level, the current value.\"\n\t       )\n{\n    int value = Py_DebugFlag,\n\told_value = value;\n\n    Py_GetArg(\"|i\", value);\n    Py_DebugFlag = value;\n\n    return PyInt_FromLong((long)old_value);\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_optimization,\n\t       \"optimization([level])\\n\\n\"\n\t       \"Sets the value of the interpreter's optimization flag.\\n\"\n\t       \"Returns the flag's value before changing it or, when called\\n\"\n\t       \"without level, the current value.\"\n\t       )\n{\n    int value = Py_OptimizeFlag,\n\told_value = value;\n\n    Py_GetArg(\"|i\", value);\n    Py_OptimizeFlag = value;\n\n    return PyInt_FromLong((long)old_value);\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_interactive,\n\t       \"interactive([level])\\n\\n\"\n\t       \"Sets the value of the interpreter's interactive flag.\\n\"\n\t       \"Returns the flag's value before changing it or, when called\\n\"\n\t       \"without level, the current value.\"\n\t       )\n{\n    int value = Py_InteractiveFlag,\n\told_value = value;\n\n    Py_GetArg(\"|i\", value);\n    Py_InteractiveFlag = value;\n\n    return PyInt_FromLong((long)old_value);\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_cur_frame,\n\t       \"cur_frame([offset=0])\\n\\n\"\n\t       \"Returns the current execution frame, optionally going up the\\n\"\n\t       \"stack by offset levels. If there are less than offset\\n\"\n\t       \"frames on the stack, None is returned. The function is thread\\n\"\n\t       \"safe.\"\n\t       )\n{\n    PyFrameObject *frame = NULL;\n    PyObject *v;\n    Py_ssize_t offset = 0;\n\n    Py_GetArg(\"|\"Py_SSIZE_T_PARSERMARKER, offset);\n\n    /* Get requested frame object */\n    frame = (PyFrameObject *)PyEval_GetFrame();\n    for (;offset > 0;offset--) {\n\tif (frame == NULL)\n\t    break;\n\tframe = frame->f_back;\n    }\n\n    /* Return frame or None */\n    v = (PyObject *)frame;\n    if (v == NULL)\n\tv = Py_None;\n    Py_INCREF(v);\n    return v;\n\n onError:\n    return NULL;\n}\n\n#if 0\n\n/* XXX replace with a generic protocol query API, e.g. \n\n   hasmethods(obj,('__getitem__','__len__'))\n\n   which works for both instances *and* types !\n\n*/\n\nPy_C_Function( mxTools_issequence,\n\t       \"issequence(obj)\\n\\n\"\n\t       \"Returns 1 iff obj exposes the sequence slot protocol,\\n\"\n\t       \"and at least defines the __getitem__ method, 0 otherwise.\"\n\t       )\n{\n    int rc;\n    PyObject *v;\n\n    Py_GetArg(\"O\", v);\n    if (PyInstance_Check(v)) {\n\tPyObject *w;\n\t\n\tw = PyObject_GetAttrString(\"__getitem__\");\n\tif (!w) {\n\t    PyErr_Clear();\n\t    rc = 0;\n\t}\n\telse {\n\t    Py_DECREF(w);\n\t    rc = 1;\n\t}\n    }\n    else {\n\trc = (v->ob_type->tp_as_sequence &&\n\t      v->ob_type->tp_as_sequence->sq_item);\n    }\n    return rc;\n\n onError:\n    return NULL;\n}\n#endif\n\nPy_C_Function( mxTools_truth,\n\t       \"truth(object)\\n\\n\"\n\t       \"Return the truth value of object as True or False singleton.\"\n\t       \"Note that the two singletons are actually the integers 1 and 0.\"\n\t       )\n{\n    PyObject *obj;\n    int istrue;\n    \n    Py_GetArg(\"O\", obj);\n\n    istrue = PyObject_IsTrue(obj);\n    if (istrue < 0)\n\tgoto onError;\n    if (istrue)\n\tobj = Py_True;\n    else\n\tobj = Py_False;\n    Py_INCREF(obj);\n    return obj;\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_sign,\n\t       \"sign(number)\\n\\n\"\n\t       \"Returns the signum of the number, i.e. -1 for negative\\n\"\n\t       \"numbers, +1 for positive ones and 0 in case it is equal to 0\"\n\t       )\n{\n    PyObject *obj,*neg = 0;\n    int sign;\n    \n    Py_GetArg(\"O\", obj);\n\n    neg = PyNumber_Negative(obj);\n    if (!neg) \n\tgoto onError;\n    sign = PyObject_Compare(obj,neg);\n    if (PyErr_Occurred())\n\tgoto onError;\n    Py_DECREF(neg);\n    return PyInt_FromLong(sign);\n\n onError:\n    Py_XDECREF(neg);\n    return NULL;\n}\n\nPy_C_Function( mxTools_makeref,\n\t       \"makeref(id)\\n\\n\"\n\t       \"Provided that id is a valid address of a Python object,\\n\"\n\t       \"this function returns a new reference to it. You can use this\\n\"\n\t       \"function to reaccess objects lost during garbage collection.\\n\"\n\t       \"USE WITH CARE - since this can cause core dumps !\"\n\t       )\n{\n    long id;\n    PyObject *obj;\n    \n    Py_GetArg(\"l\", id);\n\n    /* Accessing the memory location at id can cause a core dump ! */\n    obj = (PyObject *)id;\n\n    /* Do some checks to prevent complete disasters... */\n    Py_Assert(obj->ob_refcnt > 0,\n\t      PyExc_ValueError,\n\t      \"object has zero or negative reference count\");\n    Py_Assert(obj->ob_type != NULL,\n\t      PyExc_ValueError,\n\t      \"object has no associated type object\");\n    Py_Assert(obj->ob_type != NULL,\n\t      PyExc_ValueError,\n\t      \"object has no associated type object\");\n    \n    Py_INCREF(obj);\n    return obj;\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_dictscan,\n\t       \"dictscan(dictobj[,prevposition=0])\\n\\n\"\n\t       \"Dictionary scanner. Returns a tuple (key,value,position)\\n\"\n\t       \"containing the key,value pair and slot position of the next\\n\"\n\t       \"item found in the dictionaries hash table after slot\\n\"\n\t       \"prevposition. Raises an IndexError when the end\\n\"\n\t       \"of the table is reached or the prevposition index is out of\\n\"\n\t       \"range.\"\n\t       )\n{\n    Py_ssize_t pos = 0;\n    PyObject *d,*key,*value;\n    \n    Py_Get2Args(\"O|\"Py_SSIZE_T_PARSERMARKER,\n\t\td, pos);\n\n    Py_Assert(PyDict_Check(d),\n\t      PyExc_TypeError,\n\t      \"object must be a dictionary\");\n    \n    if (!PyDict_Next(d,&pos,&key,&value))\n\tPy_Error(PyExc_IndexError,\n\t\t \"end of scan or illegal index\");\n    Py_Return3Args(\"OO\"Py_SSIZE_T_PARSERMARKER,\n\t\t   key,value,pos);\n\n onError:\n    return NULL;\n}\n\n#ifdef HAVE_PY_GETARGCARGV\n\n/* This API is available in all Python version since at least 2.1, but\n   not made public via the Python.h header file. */\nextern void Py_GetArgcArgv(int *argc, char ***argv);\n\nPy_C_Function( mxTools_setproctitle,\n\t       \"setproctitle(title)\\n\\n\"\n\t       \"Set the process title.\"\n\t       )\n{\n    char *title;\n    Py_ssize_t titlelen;\n    int argc;\n    char **argv;\n    int i, argv0_len;\n    char *argv0;\n    \n    Py_Get2Args(\"s#\", title, titlelen);\n\n    Py_GetArgcArgv(&argc, &argv);\n\n    /* Check how much space we can use to save the title. We have to\n       be careful here, since the argv array items may not be all\n       pointing to the same memory area. */\n    argv0 = argv[0];\n    argv0_len = strlen(argv0) + 1;\n    for (i = 1; i < argc; i++) {\n\tif (argv[i] == argv0 + argv0_len)\n\t    argv0_len += strlen(argv[i]) + 1;\n        else\n\t    break;\n    }\n\n    /* Don't count the last 0-termination byte */\n    argv0_len -= 1;\n\n    /* Copy the new title to the static buffer for the process title\n       and 0-terminate it. */\n    titlelen = min(titlelen, argv0_len);\n    memcpy(argv0, title, titlelen);\n    for (i = titlelen; i < argv0_len; i++)\n\targv0[i] = '\\0';\n\n    /* Truncate the argv list and set all remaining entries to NULL */\n    for (i = 1; i < argc; i++)\n\targv[i] = 0;\n    \n    Py_ReturnNone();\n\n onError:\n    return NULL;\n}\n\n#endif\n\n#ifdef HAVE_DLOPEN\n\nPy_C_Function( mxTools_dlopen,\n\t       \"dlopen(libname, mode)\\n\\n\"\n\t       \"Load the shared lib libname using the flags given in mode.\\n\"\n\t       \"mode defaults to Python's standard dlopenflags.\"\n\t       )\n{\n    char *libname;\n#if HAVE_INTERPRETER_DLOPENFLAGS\n    int mode = PyThreadState_GET()->interp->dlopenflags;\n#else\n# ifdef RTLD_NOW\n    int mode = RTLD_NOW;\n# else\n    intt mode = RTLD_LAZY;\n# endif\n#endif\n    void *handle = 0;\n    \n    Py_Get2Args(\"s|i\", libname, mode);\n\n    handle = dlopen(libname, mode);\n    if (handle == NULL) {\n\t/* Get error information */\n\tconst char *error = dlerror();\n\tif (error == NULL)\n\t    error = \"unknown dlopen() error\";\n\tPy_Error(PyExc_OSError, error);\n    }\n    return PyLong_FromVoidPtr(handle);\n\n onError:\n    return NULL;\n}\n\n#endif\n\n/* Helper for mxTools_verscmp */\n\nstatic\nPy_ssize_t parselevel(char *s,\n\t\t      Py_ssize_t len,\n\t\t      Py_ssize_t start,\n\t\t      int *number,\n\t\t      char *rest)\n{\n    Py_ssize_t i;\n    Py_ssize_t split = -1, number_len;\n    char buffer[256];\n\n    for (i = start; i < len; i++) {\n\tregister char c = s[i];\n\t\n\tif (c == '.')\n\t    break;\n\tif (split < 0 && \n\t    (c < '0' || c > '9'))\n\t    split = i;\n    }\n    if (split < 0) {\n\trest[0] = '\\0';\n\tsplit = i;\n    }\n    else {\n\tPy_ssize_t rest_len = i - split;\n\tmemcpy(rest,&s[split],rest_len);\n\trest[rest_len] = '\\0';\n    }\n    number_len = split - start;\n    if (0 < number_len && number_len < sizeof(buffer)) {\n\tmemcpy(buffer,&s[start],number_len);\n\tbuffer[number_len] = '\\0';\n\t*number = atoi(buffer);\n    }\n    else\n\t*number = 0;\n    return i + 1;\n}\n\nPy_C_Function( mxTools_verscmp,\n\t       \"verscmp(a,b)\\n\\n\"\n\t       \"Compares two version strings and returns -1,0,1 for\\n\"\n\t       \"<,==,> resp.\"\n\t       )\n{\n    char *a,*b;\n    Py_ssize_t a_len,b_len;\n    Py_ssize_t a_i,b_i;\n    int a_n,b_n;\n    char a_x[256],b_x[256];\n    int cmp = 0;\n    \n    Py_Get4Args(\"s#s#\",\n\t\ta, a_len, b, b_len);\n\n    Py_Assert(a_len < 255 && b_len < 255,\n\t      PyExc_TypeError,\n\t      \"version strings too long\");\n\n    DPRINTF(\"mxTools_verscmp: a: '%s' b: '%s'\\n\",a,b);\n\n    for (a_i = b_i = 0;;) {\n\ta_i = parselevel(a, a_len, a_i, &a_n, a_x);\n\tb_i = parselevel(b, b_len, b_i, &b_n, b_x);\n\tDPRINTF(\"mxTools_verscmp: a: %i %i '%s'\\n\",a_i,a_n,a_x);\n\tDPRINTF(\"mxTools_verscmp: b: %i %i '%s'\\n\",b_i,b_n,b_x);\n\n\tif (a_n == b_n) {\n\t    int a_x_empty = (a_x[0] == '\\0');\n\t    int b_x_empty = (b_x[0] == '\\0');\n\t    if (a_x_empty && b_x_empty)\n\t\t/* 1.1 == 1.1 */\n\t\t;\n\t    else if (!a_x_empty && b_x_empty) {\n\t\t/* 1.1alpha < 1.1 */\n\t\tcmp = -1;\n\t\tbreak;\n\t    }\n\t    else if (a_x_empty && !b_x_empty) {\n\t\t/* 1.1 > 1.1alpha */\n\t\tcmp = +1;\n\t\tbreak;\n\t    }\n\t    else {\n\t\tcmp = strcmp(a_x,b_x);\n\t\tDPRINTF(\"mxTools_verscmp: strcmp(a_x,b_x) = %i\\n\",cmp);\n\t\tif (cmp != 0)\n\t\t    /* e.g. 1.1alpha1 < 1.1alpha2 */\n\t\t    break;\n\t    }\n\t}\n\telse {\n\t    cmp = (a_n < b_n) ? -1 : +1;\n\t    break;\n\t}\n\tif (a_i >= a_len && b_i >= b_len) {\n\t    cmp = 0;\n\t    break;\n\t}\n    }\n\n    return PyInt_FromLong(cmp);\n\n onError:\n    return NULL;\n}\n\n/* --- Experimental safecall() API ---------------------------------- */\n\n/*#define MXTOOLS_ENABLE_SAFECALL*/\n\n#ifdef MXTOOLS_ENABLE_SAFECALL\n\n#include <setjmp.h>\n#include <signal.h>\n\n/* safecall() environment\n\n   This is *not* thread-safe, but then signals don't work reliably in\n   the presence of threads anyway.\n\n   XXX sigsetjmp et al. are not available on Windows and probably\n       other platforms as well !\n\n*/\nstatic int safecall_environment_initialized = 0;\nstatic sigjmp_buf safecall_environment;\n\n/* safecall() signal handler */\n\nstatic void safecall_handler(int signum) \n{\n    DPRINTF(\"SIGSEGV handler called\\n\");\n\n    /* Force SysV behavior: reset the signal handler to the default\n       handler */\n    signal(signum, SIG_DFL);\n\n    if (safecall_environment_initialized)\n\t/* Jump back to the environment saved in the safecall function. */\n\tsiglongjmp(safecall_environment, signum);\n    else\n\t/* Reraise the signal (forcing the use of the default handler) */\n\traise(signum);\n}\n\n/* Initialize the safecall_handler\n\n   Note that a signal that invokes the handler will automatically\n   cause the default handler to be installed again for the signal \n\n*/\nstatic int init_safecall_handler(void) \n{\n    DPRINTF(\"init SIGSEGV handler\\n\");\n    signal(SIGSEGV, safecall_handler);\n    signal(SIGBUS, safecall_handler);\n    signal(SIGABRT, safecall_handler);\n    signal(SIGILL, safecall_handler);\n    signal(SIGFPE, safecall_handler);\n    return 0;\n}\n\n\n/* Reset the signal handlers to their defaults */\n\nstatic int reset_safecall_handler(void) \n{\n    DPRINTF(\"reset SIGSEGV handler\\n\");\n    signal(SIGSEGV, SIG_DFL);\n    signal(SIGBUS, SIG_DFL);\n    signal(SIGABRT, SIG_DFL);\n    signal(SIGILL, SIG_DFL);\n    signal(SIGFPE, SIG_DFL);\n    return 0;\n}\n\nPy_C_Function( mxTools_safecall,\n\t       \"safecall(callable [,args, kws])\\n\\n\"\n\t       \"Calls the callable object callable using args and kws,\\n\"\n               \"if given. In the event of the call causing a segfault\\n\"\n\t       \"or similar serious problem, the function will raise an\\n\"\n\t       \"mx.Tools.ProgrammingError. The application can then terminate\\n\"\n\t       \"gracefully. Note: This function is not thread-safe !\"\n\t       )\n{\n    PyObject *callable, *callargs=NULL, *callkws=NULL;\n    PyObject *result = NULL;\n    PyObject *v;\n    int signum;\n\n    Py_Get3Args(\"O|OO\", \n\t\tcallable, callargs, callkws);\n\n    /* Save the current stack environment and call the callable */\n    DPRINTF(\"setjmp()\\n\");\n    signum = sigsetjmp(safecall_environment, 1);\n\n    if (signum == 0) {\n\t/* Call the callable object and return gracefully if\n\t   possible */\n\tsafecall_environment_initialized = 1;\n\tinit_safecall_handler();\n\tresult = PyEval_CallObjectWithKeywords(callable, callargs, callkws);\n\tsafecall_environment_initialized = 0;\n\treset_safecall_handler();\n\treturn result;\n    }\n\n    /* We got here by a longjmp(); signum is the signal triggering\n       this event. */\n    DPRINTF(\"processing longjmp()\\n\");\n    safecall_environment_initialized = 0;\n    reset_safecall_handler();\n    v = PyTuple_New(2);\n    PyTuple_SET_ITEM(v, 0, PyString_FromString(\"Bug in external routine\"));\n    PyTuple_SET_ITEM(v, 1, PyInt_FromLong(signum));\n    PyErr_SetObject(mxTools_ProgrammingError, v);\n\n onError:\n    return NULL;\n}\n\nPy_C_Function( mxTools_segfault,\n\t       \"segfault()\\n\\n\"\n\t       \"Cause a hard seg fault.\"\n\t       )\n{\n    char *p = NULL;\n    char buffer[10];\n    double a,b,c;\n    int errtype = 0;\n    \n    Py_GetArg(\"|i\", errtype);\n\n    switch (errtype) {\n\n    case 0:\n\t/* Cause a true seg fault by writing to a NULL pointer */\n\tmemset(p, 0, 100);\n\tbreak;\n\n    case 1:\n\t/* Double free() */\n\tp = malloc(100);\n\tfree(p);\n\tfree(p);\n\tbreak;\n\n    case 2:\n\t/* Buffer overrun on stack */\n\tmemset(buffer, 0, 20);\n\tbreak;\n\t\n    case 3:\n\t/* Buffer underrun on stack */\n\tmemset(buffer - 10, 0, 20);\n\tbreak;\n\n    case 4:\n\t/* Division by 0 */\n\ta = 1;\n\tb = 0;\n\tc = a / b;\n\tbreak;\n\t\n    default:\n\tPy_Error(PyExc_ValueError,\n\t\t \"segfault(): unknown error type\");\n\t\n    }\n    Py_ReturnNone();\n\n onError:\n    return NULL;\n}\n\n#endif\n\n/* --- NotGiven Singleton -------------------------------------------------- */\n\nstatic \nPyObject *mxNotGiven_Repr(PyObject *v)\n{\n    return PyString_FromString(\"NotGiven\");\n}\n\nstatic \nint mxNotGiven_NonZero(PyObject *v)\n{\n    return 0;\n}\n\ntypedef PyObject mxNotGivenObject;\n\nstatic\nPyNumberMethods mxNotGiven_TypeAsNumber = {\n\n    /* These slots are not NULL-checked, so we must provide dummy functions */\n    notimplemented2,\t\t\t\t/*nb_add*/\n    notimplemented2,\t\t\t\t/*nb_subtract*/\n    notimplemented2,\t\t\t\t/*nb_multiply*/\n    notimplemented2,\t\t\t\t/*nb_divide*/\n    notimplemented2,\t\t\t\t/*nb_remainder*/\n    notimplemented2,\t\t\t\t/*nb_divmod*/\n    notimplemented3,\t\t\t\t/*nb_power*/\n    notimplemented1,\t\t\t\t/*nb_negative*/\n    notimplemented1,\t\t\t\t/*nb_positive*/\n\n    /* Everything below this line EXCEPT nb_nonzero (!) is NULL checked */\n    0,\t\t\t\t\t\t/*nb_absolute*/\n    mxNotGiven_NonZero,\t\t\t\t/*nb_nonzero*/\n    0,\t\t\t\t\t\t/*nb_invert*/\n    0,\t\t\t\t\t\t/*nb_lshift*/\n    0,\t\t\t\t\t\t/*nb_rshift*/\n    0,\t\t\t\t\t\t/*nb_and*/\n    0,\t\t\t\t\t\t/*nb_xor*/\n    0,\t\t\t\t\t\t/*nb_or*/\n    0,\t\t\t\t\t\t/*nb_coerce*/\n    0,\t\t\t\t\t\t/*nb_int*/\n    0,\t\t\t\t\t\t/*nb_long*/\n    0,\t\t\t\t\t\t/*nb_float*/\n    0,\t\t\t\t\t\t/*nb_oct*/\n    0,\t\t\t\t\t\t/*nb_hex*/\n};\n\nstatic PyTypeObject mxNotGiven_Type = {\n    PyObject_HEAD_INIT(0)\t\t\t/* init at startup ! */\n    0,\t\t\t\t\t\t/*ob_size*/\n    \"NotGiven\",\t\t\t\t\t/*tp_name*/\n    sizeof(mxNotGivenObject),\t\t\t/*tp_basicsize*/\n    0,\t\t\t\t\t\t/*tp_itemsize*/\n    0,\t\t\t\t\t\t/*tp_dealloc; object always stays alive */\n    0,\t\t\t\t\t\t/*tp_print*/\n    0,\t\t\t\t\t\t/*tp_getattr*/\n    0,\t\t\t\t\t\t/*tp_setattr*/\n    0,\t\t\t\t\t\t/*tp_compare*/\n    mxNotGiven_Repr, \t\t\t\t/*tp_repr*/\n    &mxNotGiven_TypeAsNumber,\t\t\t/*tp_as_number*/\n    0,\t\t\t\t\t\t/*tp_as_sequence*/\n    0,\t\t\t\t\t\t/*tp_as_mapping*/\n    0,\t\t\t\t\t\t/*tp_hash */\n};\n\n/* --- module init --------------------------------------------------------- */\n\n/* Python Method Table */\n\nstatic \nPyMethodDef Module_methods[] =\n{   \n    Py_MethodListEntry(\"trange\", mxTools_trange),\n    Py_MethodListEntrySingleArg(\"trange_len\", mxTools_indices),\n    Py_MethodListEntrySingleArg(\"indices\", mxTools_indices),\n    Py_MethodListEntrySingleArg(\"range_len\", mxTools_range_len),\n    Py_MethodListEntry(\"irange\", mxTools_irange),\n    Py_MethodListEntry(\"ifilter\", mxTools_ifilter),\n    Py_MethodListEntry(\"get\", mxTools_get),\n    Py_MethodListEntry(\"extract\", mxTools_extract),\n    Py_MethodListEntry(\"iremove\", mxTools_iremove),\n    Py_MethodListEntry(\"mget\", mxTools_extract),\n    Py_MethodListEntry(\"mgetattr\", mxTools_findattr),\n    Py_MethodListEntry(\"findattr\", mxTools_findattr),\n    Py_MethodListEntry(\"attrlist\", mxTools_attrlist),\n    Py_MethodListEntry(\"mapply\", mxTools_mapply),\n    Py_MethodListEntry(\"method_mapply\", mxTools_method_mapply),\n    Py_MethodListEntry(\"count\", mxTools_count),\n    Py_MethodListEntry(\"exists\", mxTools_exists),\n    Py_MethodListEntry(\"forall\", mxTools_forall),\n    Py_MethodListEntry(\"index\", mxTools_index),\n    Py_MethodListEntry(\"napply\", mxTools_napply),\n    Py_MethodListEntrySingleArg(\"sizeof\", mxTools_sizeof),\n    Py_MethodListEntrySingleArg(\"dict\", mxTools_dict),\n    Py_MethodListEntrySingleArg(\"invdict\", mxTools_invdict),\n    Py_MethodListEntry(\"setdict\", mxTools_setdict),\n    Py_MethodListEntrySingleArg(\"reverse\", mxTools_reverse),\n    Py_MethodListEntrySingleArg(\"tuples\", mxTools_tuples),\n    Py_MethodListEntrySingleArg(\"lists\", mxTools_lists),\n    Py_MethodListEntry(\"acquire\", mxTools_acquire),\n    Py_MethodListEntry(\"verbosity\", mxTools_verbosity),\n    Py_MethodListEntry(\"optimization\", mxTools_optimization),\n    Py_MethodListEntry(\"interactive\", mxTools_interactive),\n    Py_MethodListEntry(\"debugging\", mxTools_debugging),\n    Py_MethodListEntry(\"cur_frame\", mxTools_cur_frame),\n    Py_MethodListEntry(\"truth\", mxTools_truth),\n    Py_MethodListEntry(\"sign\", mxTools_sign),\n    Py_MethodListEntry(\"makeref\", mxTools_makeref),\n    Py_MethodListEntry(\"dictscan\", mxTools_dictscan),\n    Py_MethodListEntry(\"verscmp\", mxTools_verscmp),\n#ifdef HAVE_PY_GETARGCARGV\n    Py_MethodListEntry(\"setproctitle\", mxTools_setproctitle),\n#endif\n#ifdef HAVE_DLOPEN\n    Py_MethodListEntry(\"dlopen\",  mxTools_dlopen),\n#endif\n#ifdef INCLUDE_FUNSTUFF\n    Py_MethodListEntrySingleArg(\"malloc\", mxTools_malloc),\n    Py_MethodListEntry(\"caching_eval\", mxTools_caching_eval),\n#endif\n#ifdef MXTOOLS_ENABLE_SAFECALL\n    Py_MethodListEntry(\"safecall\", mxTools_safecall),\n    Py_MethodListEntry(\"segfault\", mxTools_segfault),\n#endif\n    {NULL,NULL} /* end of list */\n};\n\n/* Cleanup function */\nstatic \nvoid mxToolsModule_Cleanup(void)\n{\n    Py_XDECREF(mxTools_BaseobjAttribute);\n    mxTools_BaseobjAttribute = 0;\n\n    /* Reset mxTools_Initialized flag */\n    mxTools_Initialized = 0;\n}\n\n/* create PyMethodObjects and register them in the module's dict */\nMX_EXPORT(void) \n     initmxTools(void)\n{\n    PyObject *module, *moddict;\n\n    if (mxTools_Initialized)\n\tPy_Error(PyExc_SystemError,\n\t\t \"can't initialize \"MXTOOLS_MODULE\" more than once\");\n\n    /* Init type objects */\n    PyType_Init(mxNotGiven_Type);\n\n    /* create module */\n    module = Py_InitModule4(MXTOOLS_MODULE, /* Module name */\n\t\t\t    Module_methods, /* Method list */\n\t\t\t    Module_docstring, /* Module doc-string */\n\t\t\t    (PyObject *)NULL, /* always pass this as *self */\n\t\t\t    PYTHON_API_VERSION); /* API Version */\n    if (!module)\n\tgoto onError;\n\n    /* Register cleanup function */\n    if (Py_AtExit(mxToolsModule_Cleanup))\n\t/* XXX what to do if we can't register that function ??? */;\n\n    /* Create NotGiven singleton */\n    mxNotGiven = PyObject_NEW(PyObject,&mxNotGiven_Type);\n    if (!mxNotGiven)\n\tgoto onError;\n\n    /* Create acquire default argument for baseobjattr */\n    mxTools_BaseobjAttribute = PyString_InternFromString(\"baseobj\");\n    if (!mxTools_BaseobjAttribute)\n\tgoto onError;\n\n    /* Add some constants to the module's dict */\n    moddict = PyModule_GetDict(module);\n    insstr(moddict, \"__version__\", MXTOOLS_VERSION);\n    PyDict_SetItemString(moddict,\n\t\t\t \"NotGiven\",\n\t\t\t mxNotGiven);\n\n    /* dlopen() mode flags */\n#ifdef RTLD_LAZY\n    insint(moddict, \"RTLD_LAZY\", RTLD_LAZY);\n#endif\n#ifdef RTLD_NOW\n    insint(moddict, \"RTLD_NOW\", RTLD_NOW);\n#endif\n#ifdef RTLD_NOLOAD\n    insint(moddict, \"RTLD_NOLOAD\", RTLD_NOLOAD);\n#endif\n#ifdef RTLD_DEEPBIND\n    insint(moddict, \"RTLD_DEEPBIND\", RTLD_DEEPBIND);\n#endif\n#ifdef RTLD_GLOBAL\n    insint(moddict, \"RTLD_GLOBAL\", RTLD_GLOBAL);\n#endif\n#ifdef RTLD_LOCAL\n    insint(moddict, \"RTLD_LOCAL\", RTLD_LOCAL);\n#endif\n#ifdef RTLD_NODELETE\n    insint(moddict, \"RTLD_NODELETE\", RTLD_NODELETE);\n#endif\n\n    /* Errors */\n    if (!(mxTools_Error = insexc(moddict, \"Error\", NULL)))\n\tgoto onError;\n    if (!(mxTools_ProgrammingError = insexc(moddict, \"ProgrammingError\",\n\t\t\t\t\t    PyExc_RuntimeError)))\n\tgoto onError;\n\n    /* We are now initialized */\n    mxTools_Initialized = 1;\n\n onError:\n    /* Check for errors and report them */\n    if (PyErr_Occurred())\n\tPy_ReportModuleInitError(MXTOOLS_MODULE);\n    return;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/installer.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/URL/Doc/mxURL.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/URL/mxURL/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/Parser.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/Timezone.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/Locale.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/mxDateTime/vms_config_mxdatetime.txt",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/mxDateTime/config_mxdatetime.txt",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/mxDateTime/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/DateTime/Doc/mxDateTime.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/BeeBase/BeeStorage.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/BeeBase/Doc/mxBeeBase.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/BeeBase/mxBeeBase/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Tools/mxTools/maclibs.sit",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Tools/mxTools/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Tools/Doc/mxTools.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Proxy/mxProxy/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Proxy/Doc/mxProxy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Queue/Doc/mxQueue.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Queue/mxQueue/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Stack/mxStack/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/Stack/Doc/mxStack.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/UID/mxUID/test.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/UID/mxUID/mx.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/UID/Doc/mxUID.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/TextTools/Doc/mxTextTools.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/TextTools/Constants/Sets.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/TextTools/mxTextTools/test.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-mx-3.2.8-g762poqddt4shabpfdc67odiisbehkvl/spack-src/mx/TextTools/mxTextTools/mx.h"
    ],
    "total_files": 254
}