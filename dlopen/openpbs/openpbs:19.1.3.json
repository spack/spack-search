{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/configure.ac": "\n#\n# Copyright (C) 1994-2018 Altair Engineering, Inc.\n# For more information, contact Altair at www.altair.com.\n#\n# This file is part of the PBS Professional (\"PBS Pro\") software.\n#\n# Open Source License Information:\n#\n# PBS Pro is free software. You can redistribute it and/or modify it under the\n# terms of the GNU Affero General Public License as published by the Free\n# Software Foundation, either version 3 of the License, or (at your option) any\n# later version.\n#\n# PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.\n# See the GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n# Commercial License Information:\n#\n# For a copy of the commercial license terms and conditions,\n# go to: (http://www.pbspro.com/UserArea/agreement.html)\n# or contact the Altair Legal Department.\n#\n# Altair\u2019s dual-license business model allows companies, individuals, and\n# organizations to create proprietary derivative works of PBS Pro and\n# distribute them - whether embedded or bundled with other software -\n# under a commercial license agreement.\n#\n# Use of Altair\u2019s trademarks, including but not limited to \"PBS\u2122\",\n# \"PBS Professional\u00ae\", and \"PBS Pro\u2122\" and Altair\u2019s logos is subject to Altair's\n# trademark licensing policies.\n#\n\nAC_PREREQ([2.63])\n# Use PBS_VERSION to override the version statically defined here. For example:\n# ./configure PBS_VERSION=19.1.3 --prefix=/opt/pbs\nAC_INIT([PBS Professional],\n  [19.1.3],\n  [pbssupport@altair.com],\n  [pbspro],\n  [http://www.pbspro.org/])\nAC_CONFIG_HEADERS([src/include/pbs_config.h])\nAC_CONFIG_SRCDIR([src/cmds/qmgr.c])\nAC_CONFIG_AUX_DIR([buildutils])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CANONICAL_TARGET([])\nos_id=`grep ^ID= /etc/os-release | sed -n 's/.*\"\\(.*\\)\"/\\1/p'`\nAS_CASE([$os_id],\n  [opensuse-tumbleweed], m4_define([am_init_string], [-Wall foreign subdir-objects]),\n  [*], m4_define([am_init_string], [-Wall foreign]))\nAM_INIT_AUTOMAKE(am_init_string)\nAC_USE_SYSTEM_EXTENSIONS\n\n\n# Checks for programs.\nAC_PROG_AWK\nAC_PROG_YACC\nAC_PROG_SED\nAC_PROG_CC\nAC_PROG_LEX\nAC_PROG_INSTALL\nAC_PROG_LN_S\n\n# Automake macros\n#AM_PROG_AR macro is defined with automake version >= 1.12\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\nAM_PROG_CC_C_O\n\n# Initialize libtool\nLT_INIT([shared static])\n\n# Checks for libraries.\nAC_CHECK_LIB([c], [xdr_int],\n  [],\n  AC_CHECK_LIB(nsl, xdr_int)\n)\nAC_CHECK_LIB([c], [ruserok],\n  [],\n  AC_CHECK_LIB(socket, ruserok)\n)\nAC_CHECK_LIB([c], [crypt],\n  [],\n  AC_CHECK_LIB(crypt, crypt)\n)\nAC_CHECK_LIB([c], [posix_openpt],\n  AC_DEFINE([HAVE_POSIX_OPENPT], [], [Defined whe posix_openpt is available])\n)\nAC_CHECK_LIB(dl, dlopen)\nAC_CHECK_LIB([kvm], [kvm_open])\nAC_CHECK_LIB([socket], [socket],\n  [socket_lib=\"-lsocket -lnsl\"]\n  AC_SUBST(socket_lib),\n  [socket_lib=\"\"]\n  AC_SUBST(socket_lib),\n  [-lnsl]\n)\nAC_CHECK_LIB([c], [malloc_info],\n  AC_DEFINE([HAVE_MALLOC_INFO], [], [Defined when malloc_info is available])\n)\n\n# Check for X Window System\nAC_PATH_XTRA\n\n# Checks for optional header files.\nAC_CHECK_HEADERS([ \\\n\tcom_err.h \\\n\tgssapi.h \\\n\tkrb5.h \\\n\tlibpq-fe.h \\\n\tmach/mach.h \\\n\tnlist.h \\\n\tsys/eventfd.h \\\n\tsys/systeminfo.h \\\n])\n\n# Checks for required header files.\nAC_CHECK_HEADERS([ \\\n\tstdio.h \\\n\talloca.h \\\n\tarpa/inet.h \\\n\tasm/types.h \\\n\tassert.h \\\n\tcrypt.h \\\n\tctype.h \\\n\tdirent.h \\\n\tdlfcn.h \\\n\texecinfo.h \\\n\tfcntl.h \\\n\tfeatures.h \\\n\tfloat.h \\\n\tfstab.h \\\n\tftw.h \\\n\tgrp.h \\\n\tlibgen.h \\\n\tlimits.h \\\n\tmalloc.h \\\n\tmath.h \\\n\tmemory.h \\\n\tmntent.h \\\n\tnetdb.h \\\n\tnetinet/in.h \\\n\tnetinet/in_systm.h \\\n\tnetinet/ip.h \\\n\tnetinet/tcp.h \\\n\topenssl/aes.h \\\n\topenssl/bio.h \\\n\topenssl/err.h \\\n\topenssl/evp.h \\\n\topenssl/ssl.h \\\n\tpaths.h \\\n\tpoll.h \\\n\tpthread.h \\\n\tpwd.h \\\n\tregex.h \\\n\tsignal.h \\\n\tstddef.h \\\n\tstdint.h \\\n\tstdio.h \\\n\tstdlib.h \\\n\tstring.h \\\n\tstrings.h \\\n\tsyscall.h \\\n\tsyslog.h \\\n\tsys/epoll.h \\\n\tsys/fcntl.h \\\n\tsys/file.h \\\n\tsys/ioctl.h \\\n\tsys/mman.h \\\n\tsys/mount.h \\\n\tsys/param.h \\\n\tsys/poll.h \\\n\tsys/prctl.h \\\n\tsys/procfs.h \\\n\tsys/quota.h \\\n\tsys/resource.h \\\n\tsys/select.h \\\n\tsys/signal.h \\\n\tsys/socket.h \\\n\tsys/statfs.h \\\n\tsys/stat.h \\\n\tsys/statvfs.h \\\n\tsys/sysctl.h \\\n\tsys/sysinfo.h \\\n\tsys/sysmacros.h \\\n\tsys/time.h \\\n\tsys/timeb.h \\\n\tsys/times.h \\\n\tsys/types.h \\\n\tsys/uio.h \\\n\tsys/un.h \\\n\tsys/unistd.h \\\n\tsys/user.h \\\n\tsys/utsname.h \\\n\tsys/vfs.h \\\n\tsys/wait.h \\\n\ttermios.h \\\n\ttime.h \\\n\tunistd.h \\\n\tutime.h \\\n\tX11/Intrinsic.h \\\n\tX11/X.h \\\n\tX11/Xlib.h \\\n\tzlib.h \\\n\t],, AC_MSG_ERROR([Required header file is missing.]) \\\n)\n\n# Checks for typedefs, structures, and compiler characteristics.\n#AC_CHECK_HEADER_STDBOOL macro is defined with autoconf version >= 2.67\nm4_ifdef([AC_CHECK_HEADER_STDBOOL], [AC_CHECK_HEADER_STDBOOL])\nAC_TYPE_UID_T\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_C_RESTRICT\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_CHECK_MEMBERS([struct stat.st_blksize])\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\nAC_TYPE_UINT8_T\nAC_CHECK_TYPES([ptrdiff_t])\n\n# Checks for library functions.\nAC_FUNC_ALLOCA\nAC_FUNC_CHOWN\nAC_FUNC_ERROR_AT_LINE\nAC_FUNC_FORK\nAC_FUNC_GETGROUPS\nAC_FUNC_GETMNTENT\nAC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK\nAC_FUNC_MALLOC\nAC_FUNC_MKTIME\nAC_FUNC_MMAP\nAC_FUNC_REALLOC\nAC_FUNC_STRERROR_R\nAC_FUNC_STRTOD\nAC_CHECK_FUNCS([ \\\n\talarm \\\n\tatexit \\\n\tbzero \\\n\tdup2 \\\n\tendpwent \\\n\tfloor \\\n\tftruncate \\\n\tgetcwd \\\n\tgethostbyaddr \\\n\tgethostbyname \\\n\tgethostname \\\n\tgetmntent \\\n\tgetpagesize \\\n\tgettimeofday \\\n\thasmntopt \\\n\tinet_ntoa \\\n\tlocaltime_r \\\n\tmemchr \\\n\tmemmove \\\n\tmemset \\\n\tmkdir \\\n\tmunmap \\\n\tpathconf \\\n\tpoll \\\n\tpstat_getdynamic \\\n\tputenv \\\n\trealpath \\\n\tregcomp \\\n\trmdir \\\n\tselect \\\n\tsetresuid \\\n\tsetresgid \\\n\tseteuid \\\n\tsetegid \\\n\tstrerror_r \\\n\tsocket \\\n\tstrcasecmp \\\n\tstrchr \\\n\tstrcspn \\\n\tstrdup \\\n\tstrerror \\\n\tstrncasecmp \\\n\tstrpbrk \\\n\tstrrchr \\\n\tstrspn \\\n\tstrstr \\\n\tstrtol \\\n\tstrtoul \\\n\tstrtoull \\\n\tsysinfo \\\n\tuname \\\n\tutime \\\n])\n\nPKG_PROG_PKG_CONFIG\nm4_ifdef([PKG_INSTALLDIR],\n  [PKG_INSTALLDIR],\n  [\n    pkgconfigdir=/usr/lib64/pkgconfig\n    AC_SUBST([pkgconfigdir])\n  ])\n\n\n# PBS macros (order matters for some of these)\nPBS_AC_PBS_VERSION\nPBS_AC_MACHINE_TYPE\nPBS_AC_DECL_H_ERRNO\nPBS_AC_DECL_SOCKLEN_T\nPBS_AC_DECL_EPOLL\nPBS_AC_DECL_EPOLL_PWAIT\nPBS_AC_DECL_PPOLL\nPBS_AC_WITH_SERVER_HOME\nPBS_AC_WITH_SERVER_NAME_FILE\nPBS_AC_WITH_DATABASE_DIR\nPBS_AC_WITH_DATABASE_USER\nPBS_AC_WITH_DATABASE_PORT\nPBS_AC_WITH_PBS_CONF_FILE\nPBS_AC_WITH_TMP_DIR\nPBS_AC_WITH_UNSUPPORTED_DIR\nPBS_AC_WITH_CORE_LIMIT\nPBS_AC_WITH_PYTHON\nPBS_AC_WITH_EXPAT\nPBS_AC_WITH_EDITLINE\nPBS_AC_WITH_HWLOC\nPBS_AC_WITH_LIBICAL\nPBS_AC_WITH_SENDMAIL\nPBS_AC_WITH_SWIG\nPBS_AC_WITH_TCL\nPBS_AC_WITH_TCLATRSEP\nPBS_AC_WITH_XAUTH\nPBS_AC_WITH_MIN_STACK_LIMIT\nPBS_AC_DISABLE_RPP\nPBS_AC_DISABLE_SHELL_PIPE\nPBS_AC_DISABLE_SYSLOG\nPBS_AC_ENABLE_ALPS\nPBS_AC_ENABLE_CPUSET\nPBS_AC_WITH_LIBZ\nPBS_AC_ENABLE_PTL\nPBS_AC_SYSTEMD_UNITDIR\n\nAC_CONFIG_FILES([\n\tpbspro.spec\n\tMakefile\n\tbuildutils/Makefile\n\tbuildutils/pbs_mkdirs\n\tdoc/Makefile\n\ttest/Makefile\n\ttest/fw/Makefile\n\ttest/tests/Makefile\n\ttest/fw/setup.py\n\ttest/fw/ptl/__init__.py\n\tsrc/Makefile\n\tsrc/cmds/Makefile\n\tsrc/cmds/mpiexec\n\tsrc/cmds/nqs2pbs\n\tsrc/cmds/pbs_lamboot\n\tsrc/cmds/pbs_mpihp\n\tsrc/cmds/pbs_mpilam\n\tsrc/cmds/pbs_mpirun\n\tsrc/cmds/pbs_remsh\n\tsrc/cmds/pbsrun_unwrap\n\tsrc/cmds/pbsrun_wrap\n\tsrc/cmds/pbsrun\n\tsrc/cmds/scripts/Makefile\n\tsrc/cmds/scripts/au-nodeupdate\n\tsrc/cmds/scripts/modulefile\n\tsrc/cmds/scripts/pbs_habitat\n\tsrc/cmds/scripts/pbs_init.d\n\tsrc/cmds/scripts/pbs_poerun\n\tsrc/cmds/scripts/pbs_postinstall\n\tsrc/cmds/scripts/pbs.service\n\tsrc/cmds/scripts/pbsrun.poe\n\tsrc/hooks/Makefile\n\tsrc/iff/Makefile\n\tsrc/include/Makefile\n\tsrc/include/pbs_version.h\n\tsrc/lib/Libattr/Makefile\n\tsrc/lib/Libdb/Makefile\n\tsrc/lib/Liblog/Makefile\n\tsrc/lib/Libnet/Makefile\n\tsrc/lib/Libpbs/Makefile\n\tsrc/lib/Libpbs/pbs.pc\n\tsrc/lib/Libpython/Makefile\n\tsrc/lib/Libsec/Makefile\n\tsrc/lib/Libsite/Makefile\n\tsrc/lib/Libtpp/Makefile\n\tsrc/lib/Libutil/Makefile\n\tsrc/lib/Makefile\n\tsrc/modules/Makefile\n\tsrc/modules/python/Makefile\n\tsrc/mom_rcp/Makefile\n\tsrc/resmom/Makefile\n\tsrc/scheduler/Makefile\n\tsrc/server/Makefile\n\tsrc/tools/Makefile\n\tsrc/tools/wrap_tcl.sh\n\tsrc/unsupported/Makefile\n\tsrc/unsupported/pbs_diag\n\tsrc/unsupported/pbs_dtj\n])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/src/lib/Libutil/munge_supp.c": "/*\n * Copyright (C) 1994-2018 Altair Engineering, Inc.\n * For more information, contact Altair at www.altair.com.\n *\n * This file is part of the PBS Professional (\"PBS Pro\") software.\n *\n * Open Source License Information:\n *\n * PBS Pro is free software. You can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n *\n * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial License Information:\n *\n * For a copy of the commercial license terms and conditions,\n * go to: (http://www.pbspro.com/UserArea/agreement.html)\n * or contact the Altair Legal Department.\n *\n * Altair\u2019s dual-license business model allows companies, individuals, and\n * organizations to create proprietary derivative works of PBS Pro and\n * distribute them - whether embedded or bundled with other software -\n * under a commercial license agreement.\n *\n * Use of Altair\u2019s trademarks, including but not limited to \"PBS\u2122\",\n * \"PBS Professional\u00ae\", and \"PBS Pro\u2122\" and Altair\u2019s logos is subject to Altair's\n * trademark licensing policies.\n *\n */\n\n/**\n * @file\tmunge_supp.c\n * @brief\n *  Utility functions to support munge authentication\n */\n\n#include <pbs_config.h>   /* the master config generated by configure */\n\n#include <libutil.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <limits.h>\n#include <pbs_ifl.h>\n#include <pbs_internal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#ifndef WIN32\n#include <dlfcn.h>\n#include <grp.h>\n#endif\n#include \"pbs_error.h\"\n\n\n\n#ifndef WIN32\nconst char libmunge[] = \"libmunge.so\";  /* MUNGE library */\nvoid *munge_dlhandle; /* MUNGE dynamic loader handle */\nint (*munge_encode_ptr)(char **, void *, const void *, int); /* MUNGE munge_encode() function pointer */\nint (*munge_decode_ptr)(const char *cred, void *, void **, int *, uid_t *, gid_t *); /* MUNGE munge_decode() function pointer */\nchar * (*munge_strerror_ptr) (int); /* MUNGE munge_stderror() function pointer */\n\n/**\n * @brief\n *      Check if libmunge.so shared library is present in the system\n *      and assign specific function pointers to be used at the time\n *      of decode or encode.\n *\n * @param[in/out] ebuf\tError message is updated here\n * @param[in] ebufsz\tsize of the error message buffer\n *\n * @return int\n * @retval  0 on success\n * @retval -1 on failure\n */\nint\ninit_munge(char *ebuf, int ebufsz)\n{\n        munge_dlhandle = dlopen(libmunge, RTLD_LAZY);\n        if (munge_dlhandle == NULL) {\n            snprintf(ebuf, ebufsz, \"%s not found\", libmunge);\n            goto err;\n        }\n\n        munge_encode_ptr = dlsym(munge_dlhandle, \"munge_encode\");\n        if (munge_encode_ptr == NULL) {\n        \tsnprintf(ebuf, ebufsz, \"symbol munge_encode not found in %s\", libmunge);\n            goto err;\n        }\n\n        munge_decode_ptr = dlsym(munge_dlhandle, \"munge_decode\");\n        if (munge_decode_ptr == NULL) {\n        \tsnprintf(ebuf, ebufsz, \"symbol munge_decode not found in %s\", libmunge);\n            goto err;\n        }\n\n        munge_strerror_ptr = dlsym(munge_dlhandle, \"munge_strerror\");\n        if (munge_strerror_ptr == NULL) {\n        \tsnprintf(ebuf, ebufsz, \"symbol munge_strerror not found in %s\", libmunge);\n            goto err;\n        }\n        /*\n         * Don't close the munge handler as it will be used\n         * further for encode or decode\n         */\n        return (0);\n\nerr:\n\tif (munge_dlhandle)\n\t\tdlclose(munge_dlhandle);\n\n\tmunge_dlhandle = NULL;\n\tmunge_encode_ptr = NULL;\n\tmunge_decode_ptr = NULL;\n\tmunge_strerror_ptr = NULL;\n\treturn (-1);\n}\n\n/**\n * @brief\n *      Call Munge encode API's to get the authentication\n *      data for the current user\n *\n * @param[in] fromsvr\tconnection initiated from server?\n * @param[in/out] ebuf\tError message is updated here\n * @param[in] ebufsz\tsize of the error message buffer\n *\n * @return  The encoded munge authentication data\n * @retval   !NULL on success\n * @retval  NULL on failure\n */\nchar *\npbs_get_munge_auth_data(int fromsvr, char *ebuf, int ebufsz)\n{\n\tchar *cred = NULL;\n\tuid_t myrealuid;\n\tstruct passwd *pwent;\n\tstruct group *grp;\n\tchar payload[2 + PBS_MAXUSER + PBS_MAXGRPN + 1] = { '\\0' };\n\tint munge_err = 0;\n\n\tif (munge_dlhandle == NULL) {\n\t\tif (init_munge(ebuf, ebufsz) != 0) {\n\t\t\tpbs_errno = PBSE_SYSTEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmyrealuid = getuid();\n\tpwent = getpwuid(myrealuid);\n\tif (pwent == NULL) {\n\t\tsnprintf(ebuf, ebufsz, \"Failed to obtain user-info for uid = %d\", myrealuid);\n\t\tpbs_errno = PBSE_SYSTEM;\n\t\tgoto err;\n\t}\n\n\tgrp = getgrgid(pwent->pw_gid);\n\tif (grp == NULL) {\n\t\tsnprintf(ebuf, ebufsz, \"Failed to obtain group-info for gid=%d\", pwent->pw_gid);\n\t\tpbs_errno = PBSE_SYSTEM;\n\t\tgoto err;\n\t}\n\n\t/* if the connection is being initiated from server, encode a 1 before the user:grp */\n\tsnprintf(payload, PBS_MAXUSER + PBS_MAXGRPN + 2, \"%c:%s:%s\", (fromsvr ? '1' : '0'), pwent->pw_name, grp->gr_name);\n\n\tmunge_err = munge_encode_ptr(&cred, NULL, payload, strlen(payload));\n\tif (munge_err != 0) {\n\t\tpbs_errno = PBSE_BADCRED;\n\t\tsnprintf(ebuf, ebufsz, \"MUNGE user-authentication on encode failed with `%s`\", munge_strerror_ptr(munge_err));\n\t\tgoto err;\n\t}\n\treturn cred;\n\nerr:\n\tfree(cred);\n\treturn NULL;\n}\n\n\n/**\n * @brief\n *      Validate the munge authentication data\n *\n * @param[in]  auth_data\topaque auth data that is to be verified\n * @param[out] from_svr\t\t1 - sender is server, 0 - sender not a server\n * @param[in/out] ebuf\t\tError message is updated here\n * @param[in] ebufsz\t\tsize of the error message buffer\n *\n * @return error code\n * @retval  0 - Success\n * @retval -1 - Failure\n *\n */\nint\npbs_munge_validate(void *auth_data, int *fromsvr, char *ebuf, int ebufsz)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tint recv_len = 0;\n\tstruct passwd *pwent = NULL;\n\tstruct group *grp = NULL;\n\tvoid *recv_payload = NULL;\n\tchar user_credential[PBS_MAXUSER + PBS_MAXGRPN + 1] = { \"\\0\" };\n\tint munge_err = 0;\n\tchar *p;\n\tint rc = -1;\n\n\t*fromsvr = 0;\n\n\tif (munge_dlhandle == NULL) {\n\t\tif (init_munge(ebuf, ebufsz) != 0) {\n\t\t\tpbs_errno = PBSE_SYSTEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmunge_err = munge_decode_ptr(auth_data, NULL, &recv_payload, &recv_len, &uid, &gid);\n\tif (munge_err != 0) {\n\t\tsnprintf(ebuf, ebufsz, \"MUNGE user-authentication on decode failed with `%s`\",\n\t\t\t\t\tmunge_strerror_ptr(munge_err));\n\t\tgoto err;\n\t}\n\n\tif ((pwent = getpwuid(uid)) == NULL) {\n\t\tsnprintf(ebuf, ebufsz, \"Failed to obtain user-info for uid = %d\", uid);\n\t\tgoto err;\n\t}\n\n\tif ((grp = getgrgid(pwent->pw_gid)) == NULL) {\n\t\tsnprintf(ebuf, ebufsz, \"Failed to obtain group-info for gid=%d\", gid);\n\t\tgoto err;\n\t}\n\tsnprintf(user_credential, PBS_MAXUSER + PBS_MAXGRPN, \"%s:%s\", pwent->pw_name, grp->gr_name);\n\n\t/* parse the recv_payload past the first two characters */\n\tp = (char *) recv_payload;\n\tif (*p == '1')\n\t\t*fromsvr = 1; /* connection was from a server */\n\n\tp = recv_payload + 2;\n\n\tif (strcmp(user_credential, p) == 0)\n\t\trc = 0;\n\telse\n\t\tsnprintf(ebuf, ebufsz, \"User credentials do not match\");\n\nerr:\n\t/* Don't close the munge handler */\n\tfree(recv_payload);\n\treturn rc;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/src/resmom/linux/mom_mach.c": "/*\n * Copyright (C) 1994-2018 Altair Engineering, Inc.\n * For more information, contact Altair at www.altair.com.\n *\n * This file is part of the PBS Professional (\"PBS Pro\") software.\n *\n * Open Source License Information:\n *\n * PBS Pro is free software. You can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n *\n * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial License Information:\n *\n * For a copy of the commercial license terms and conditions,\n * go to: (http://www.pbspro.com/UserArea/agreement.html)\n * or contact the Altair Legal Department.\n *\n * Altair\u2019s dual-license business model allows companies, individuals, and\n * organizations to create proprietary derivative works of PBS Pro and\n * distribute them - whether embedded or bundled with other software -\n * under a commercial license agreement.\n *\n * Use of Altair\u2019s trademarks, including but not limited to \"PBS\u2122\",\n * \"PBS Professional\u00ae\", and \"PBS Pro\u2122\" and Altair\u2019s logos is subject to Altair's\n * trademark licensing policies.\n *\n */\n\n#ifndef\tPBSMOM_HTUNIT\n#include <pbs_config.h>   /* the master config generated by configure */\n\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <pwd.h>\n#include <time.h>\n#include <mntent.h>\n#include <ftw.h>\n#include <dlfcn.h>\n#include <asm/types.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/procfs.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <syscall.h>\n#include <signal.h>\n\n#include \"pbs_error.h\"\n#include \"portability.h\"\n#include \"list_link.h\"\n#include \"server_limits.h\"\n#include \"attribute.h\"\n#include \"resource.h\"\n#include \"job.h\"\n#include \"log.h\"\n#include \"mom_func.h\"\n#include \"resmon.h\"\n#include \"../rm_dep.h\"\n#include \"rpp.h\"\n#include \"pbs_license.h\"\n#include \"pbs_ifl.h\"\n#include \"placementsets.h\"\n#include \"mom_vnode.h\"\n#ifndef NAS /* localmod 113 */\n#include \"hwloc.h\"\n#endif /* localmod 113 */\n\n/**\n * @file\n * @brief\n *\tSystem dependent code to gather information for the resource\n *\tmonitor for a Linux i386 machine.\n *\n * @par Resources known by this code:\n *\t\tcput\t\tcpu time for a pid or session\n *\t\tmem\t\tmemory size for a pid or session in KB\n *\t\tresi\t\tresident memory size for a pid or session in KB\n *\t\tsessions\tlist of sessions in the system\n *\t\tpids\t\tlist of pids in a session\n *\t\tnsessions\tnumber of sessions in the system\n *\t\tnusers\t\tnumber of users in the system\n *\t\ttotmem\t\ttotal memory size in KB\n *\t\tavailmem\tavailable memory size in KB\n *\t\tncpus\t\tnumber of cpus\n *\t\tphysmem\t\tphysical memory size in KB\n *\t\tsize\t\tsize of a file or filesystem\n *\t\tidletime\tseconds of idle time (see mom_main.c)\n *\t\twalltime\twall clock time for a pid\n *\t\tloadave\t\tcurrent load average\n #ifdef NAS\n localmod 090\n *\t\ttimes\t\tEpoch time host booted and current time\n #endif\n */\n\n\n#ifndef\tTRUE\n#define\tFALSE\t0\n#define\tTRUE\t1\n#endif\t/* TRUE */\n\n#define\tTBL_INC 20\n#define CPUT_POSSIBLE_FACTOR 5\n\nstatic char\tprocfs[] = \"/proc\";\nstatic DIR\t*pdir = NULL;\nstatic int\tpagesize;\nstatic long\thz;\n#if\tMOM_CPUSET\nstatic char \tcpusetfs[] = PBS_CPUSETDIR;\nstatic DIR\t*cpusetdir = NULL;\n#endif\t/* MOM_CPUSET */\n\n/* convert between jiffies and seconds */\n#define\tJTOS(x)\t(((x) + (hz/2)) / hz)\n\nstatic char\t*choose_procflagsfmt(void);\n\nproc_stat_t\t*proc_info = NULL;\nint\t\tnproc = 0;\nint\t\tmax_proc = 0;\n#if\tMOM_CPUSET\nint\t\tdo_memreserved_adjustment;\n#endif\t/* MOM_CPUSET */\n\nextern\tchar\t*ret_string;\nextern\tchar\textra_parm[];\nextern\tchar\tno_parm[];\nextern\tint\texiting_tasks;\nextern\tvnl_t\t*vnlp;\n\nextern\ttime_t\ttime_now;\n\n/*\n ** external functions and data\n */\nextern  int\tnice_val;\nextern\tint\t\t\trm_errno;\nextern\tint\t\t\treqnum;\nextern\tdouble\tcputfactor;\nextern\tdouble\twallfactor;\nextern  pid_t\tmom_pid;\nextern\tint\tnum_acpus;\nextern\tint\tnum_pcpus;\nextern\tint\tnum_oscpus;\nstruct\tconfig\t\t*search(struct config *, char *);\nstruct\trm_attribute\t*momgetattr(char *);\n\nchar\t*physmem\t(struct rm_attribute *attrib);\n\n/*\n ** local functions and data\n */\nstatic char\t*resi\t\t(struct rm_attribute *attrib);\nstatic char\t*totmem\t\t(struct rm_attribute *attrib);\nstatic char\t*availmem\t(struct rm_attribute *attrib);\nstatic char\t*ncpus\t\t(struct rm_attribute *attrib);\nstatic char\t*walltime\t(struct rm_attribute *attrib);\nstatic long\tget_wm\t\t(pid_t);\n#if\tMOM_CPUSET && (CPUSET_VERSION >= 4)\nstatic uid_t\townerof\t\t(pid_t);\n#endif\t/* MOM_CPUSET && CPUSET_VERSION >= 4 */\n#ifdef NAS\n/* localmod 005 */\nstatic void proc_new\t\t(int, int);\n/* localmod 090 */\nstatic unsigned linux_time = 0;\nstatic char\t*sys_clocks\t(struct rm_attribute *attrib);\n#endif\n\n#if\tMOM_CPUSET\nstatic void\tadjust_memreserved\t(vnl_t *);\nstatic int\tmigrate_task\t\t(task *, char *);\nstatic void\tclear_cpuset_fromjob\t(job *);\nstatic void\tcpuset_free_job_CPUs\t(job *);\n#if\t(CPUSET_VERSION >= 4)\nstatic void\tclear_named_cpuset\t(char *, job *);\nstatic void\tremove_cpuset_procs\t(const char *, const char *);\n#endif\t/* CPUSET_VERSION >= 4 */\n#endif\t/* MOM_CPUSET */\n\nextern char\t*loadave\t(struct rm_attribute *attrib);\nextern char\t*nullproc\t(struct rm_attribute *attrib);\n\ntime_t\twait_time = 10;\n\ntypedef\tstruct\tproc_mem  {\n\tulong\ttotal;\n\tulong\tused;\n\tulong\tfree;\n} proc_mem_t;\n\nint\tmom_does_chkpnt = 0;\nulong\tcpuset_nodes = 1;\nulong\tmemreserved = 0;\nulong\tmempernode;\nulong\tcpupernode;\nulong\ttotalmem;\n\nstatic int\tmyproc_max = 0;\t\t/* entries in Proc_lnks  */\npbs_plinks\t*Proc_lnks = NULL;\t/* process links table head */\nstatic time_t\tsampletime_ceil;\nstatic time_t\tsampletime_floor;\n\n#if\tMOM_CPUSET\ntypedef int\t\tpidcachetype_t;\t\t/* type of allocatable unit */\nstatic pidcachetype_t\t*pidcache_arena;\t/* cache storage area */\nstatic unsigned int \tpidcache_bitsper = sizeof(pidcachetype_t) * NBBY;\nstatic int\t\tpidcache_check(pid_t, pidcachetype_t *);\nstatic pidcachetype_t\t*pidcache_create(void);\nstatic int\t\tpidcache_reset(pidcachetype_t *);\nstatic void\t\tpidcache_destroy(void);\nstatic pidcachetype_t *\tpidcache_getarena(void);\nstatic int\t\tpidcache_insert(pid_t p, pidcachetype_t *set);\nstatic int\t\tpidcache_needed(void);\nstatic pid_t\t\tpidcache_pidmax;\t/* zero value implies no limit */\nstatic int\t\tpidcache_test = 0;\t/* say PID cache always needed */\n#endif\t/* MOM_CPUSET */\n\n/*\n ** local resource array\n */\nstruct\tconfig\tdependent_config[] = {\n\t{ \"resi\",\t{ resi } },\n\t{ \"totmem\",\t{ totmem } },\n\t{ \"availmem\",\t{ availmem } },\n\t{ \"physmem\",\t{ physmem } },\n\t{ \"ncpus\",\t{ ncpus } },\n\t{ \"loadave\",\t{ loadave } },\n\t{ \"walltime\",\t{ walltime } },\n#ifdef NAS\n\t/* localmod 090 */\n\t{ \"times\",\t{ sys_clocks } },\n#endif\n\t{ NULL,\t\t{ nullproc } },\n};\n\n#if\tMOM_CPUSET\n\n#if\t(CPUSET_VERSION < 4)\n/* relevant ProPack 2, 3 flags */\n#define\tCPUSET_CREATE_FLAGS\t(CPUSET_CPU_EXCLUSIVE|\t\\\n\t\t\t\tCPUSET_MEMORY_LOCAL|\t\\\n\t\t\t\tCPUSET_MEMORY_MANDATORY|\\\n\t\t\t\tCPUSET_MEMORY_EXCLUSIVE|\\\n\t\t\t\tCPUSET_POLICY_KILL|\t\\\n\t\t\t\tCPUSET_EVENT_NOTIFY)\n#else\n/* relevant ProPack 4 flags */\n#define\tCPUSET_CREATE_FLAGS\t(CPU_EXCLUSIVE | MEM_EXCLUSIVE)\n#endif\t/* CPUSET_VERSION < 4 */\nint\tcpuset_create_flags =\tCPUSET_CREATE_FLAGS;\n\nulong\tcpuset_destroy_delay = 0;\n\n/**\n * @brief\n *\tSet cpuset_create_flags based on config file 'str' in the format:\n *\t\"flag1|flag2|...\"\n *\n * @param[in] str - string holding cpuset flags\n *\n * @return Void\n *\n */\nvoid\nset_cpuset_flags(char *str)\n{\n\tstatic char\ttok[] = \"\\040|\\t\";\n\tchar *val;\n\n\tif (str == NULL)\n\t\treturn;\n\n\tval = strtok(str, tok);\n\tcpuset_create_flags = 0;\n\n\twhile (val) {\n#if\t(CPUSET_VERSION < 4)\n\t\tif (strcasecmp(val, \"CPUSET_CPU_EXCLUSIVE\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_CPU_EXCLUSIVE;\n\t\telse if (strcasecmp(val, \"CPUSET_MEMORY_LOCAL\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_MEMORY_LOCAL;\n\t\telse if (strcasecmp(val, \"CPUSET_MEMORY_EXCLUSIVE\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_MEMORY_EXCLUSIVE;\n\t\telse if (strcasecmp(val, \"CPUSET_MEMORY_KERNEL_AVOID\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_MEMORY_KERNEL_AVOID;\n\t\telse if (strcasecmp(val, \"CPUSET_MEMORY_MANDATORY\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_MEMORY_MANDATORY;\n\t\telse if (strcasecmp(val, \"CPUSET_POLICY_PAGE\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_POLICY_PAGE;\n\t\telse if (strcasecmp(val, \"CPUSET_POLICY_KILL\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_POLICY_KILL;\n\t\telse if (strcasecmp(val, \"CPUSET_EVENT_NOTIFY\") == 0)\n\t\t\tcpuset_create_flags |= CPUSET_EVENT_NOTIFY;\n#else\n\t\tif (strcasecmp(val, \"CPUSET_CPU_EXCLUSIVE\") == 0)\n\t\t\tcpuset_create_flags |= CPU_EXCLUSIVE;\n\t\telse if (strcasecmp(val, \"CPUSET_MEMORY_SHARED\") == 0)\n\t\t\tcpuset_create_flags &= ~MEM_EXCLUSIVE;\n#endif\t/* CPUSET_VERSION < 4 */\n\t\telse {\n\t\t\tsprintf(log_buffer, \"unknown flag: %s\", val);\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_NOTICE, \"cpuset_flags\", log_buffer);\n\t\t}\n\n\t\tval = strtok(NULL, tok);\n\t}\n\treturn;\n}\n\n/**\n * @brief\n *\tclear cpu set for job\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return \tint\n * @retval \t0\tSuccess\n *\n */\nint\nsuspend_job(job *pjob)\n{\n#if\t(CPUSET_VERSION < 4)\n\tclear_cpuset(pjob);\n#else\n\t/*\n\t *\tIn ProPack 4+, we leave processes and their CPU sets in place\n\t *\trather than moving the processes and removing their sets.  This\n\t *\tpreserves memory binding information that applications may have\n\t *\tset up itself (which would otherwise be lost when a CPU set is\n\t *\tremoved, then recreated).\n\t */\n\tif (free_job_CPUs != NULL)\n\t\t(*free_job_CPUs)(pjob);\n#endif\t/* CPUSET_VERSION < 4 */\n\treturn 0;\n}\n\n/**\n * @brief\n *\tmigrates a task of job to cpuset.\n *\n * @param[in] ptask - pointer to task structure\n * @param[in] cname - cpuset name\n *\n * @return \tint\n * @retval \t0\tSuccess\n * @retval\t-1\tFailure\n *\n */\nstatic int\nmigrate_task(task *ptask, char *cname)\n{\n\tjob\t\t*pjob = ptask->ti_job;\n\tpid_t\t\tsid = ptask->ti_qs.ti_sid;\n\n#if\t(CPUSET_VERSION < 4)\n\tif (cpusetMoveMigrate(NULL, cname, CPUSET_SID, sid) == 0) {\n\t\tint\ti;\n\n\t\tif (errno != ENOSYS) {\t/* supported but didn't work */\n\t\t\tlog_joberr(errno, __func__, \"cpusetMoveMigrate\",\n\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t}\n\n\t\tfor (i=0; i<nproc; i++) {\n\t\t\tproc_stat_t\t*ps = &proc_info[i];\n\n\t\t\tif (ps->session != sid)\n\t\t\t\tcontinue;\n\t\t\tif (cpusetAttachPID(cname, ps->pid) != 0)\n\t\t\t\tcontinue;\n\t\t\tlog_joberr(errno, __func__, \"cpusetAttachPID\",\n\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"could not migrate pid %d to cpuset %s\",\n\t\t\t\tps->pid, cname);\n\t\t\treturn -1;\n\t\t}\n\t}\n#else\n\tint\ti;\n\n\tfor (i=0; i<nproc; i++) {\n\t\tproc_stat_t\t*ps = &proc_info[i];\n\n\t\tif (ps->session != sid)\n\t\t\tcontinue;\n\t\tif (cpuset_move(ps->pid, cname) != 0) {\n\t\t\tDBPRT((\"%s:  cpuset_move(%d, %s) failed, errno %d\\n\",\n\t\t\t\t__func__, ps->pid, cname, errno))\n\t\t\tlog_joberr(errno, __func__, \"cpuset_move\",\n\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"could not migrate pid %d to cpuset %s\",\n\t\t\t\tps->pid, cname);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tDBPRT((\"%s:  cpuset_move(%d, %s) succeeded\\n\", __func__,\n\t\t\t\tps->pid, cname))\n\t\t}\n\t}\n#endif\t/* CPUSET_VERSION < 4 */\n\n\tDBPRT((\"%s: %s task %8.8X added to cpuset %s\\n\", __func__,\n\t\tpjob->ji_qs.ji_jobid, ptask->ti_qs.ti_task, cname))\n\treturn 0;\n}\n\n/**\n * @brief\n *\tAttach each task of a resumed job back to a cpuset.\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return \tint\n * @retval \t0\tSuccess\n * @retval \t-1\tFailure\n *\n */\nint\nresume_job(job *pjob)\n{\n#if\tCPUSET_VERSION < 4\n\tchar\tcbuf[CPUSET_NAME_SIZE+16];\n\tchar\t*cname;\n\ttask\t*ptask;\n\n\tif ((cname = make_cpuset(pjob)) == NULL)\n\t\treturn -1;\n\n\tfor (ptask = (task *)GET_NEXT(pjob->ji_tasks);\n\t\tptask != NULL;\n\t\tptask = (task *)GET_NEXT(ptask->ti_jobtask)) {\n\t\tif (migrate_task(ptask, cname)) {\n\t\t\tclear_cpuset(pjob);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsprintf(cbuf, \"cpuset=%s\", cname);\n\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],\n\t\tATTR_altid, NULL, cbuf);\n\tDBPRT((\"%s:  adding job %s to cpu set %s\\n\", __func__,\n\t\tpjob->ji_qs.ji_jobid, cname))\n\tupdate_ajob_status(pjob);\n#else\n\tstatic struct bitmask\t*cpubits = NULL;\n\tstatic struct cpuset\t*cp = NULL;\n\tunsigned int\t\tcpunum;\n\tchar\t\t\t*jobset;\n\tchar\t\t\t*jobid = pjob->ji_qs.ji_jobid;\n\tint\t\t\tfirstbit, lastbit;\n\n\t/* reassociate CPUs in job's (still existing) CPU set with the job */\n\tif ((cpubits == NULL) &&\n\t\t((cpubits = bitmask_alloc(cpus_nbits)) == NULL)) {\n\t\tlog_joberr(errno, __func__, \"bitmask_alloc failed\", jobid);\n\t\treturn -1;\n\t}\n\tif ((cp == NULL) && ((cp = cpuset_alloc()) == NULL)) {\n\t\tlog_joberr(errno, __func__, \"cpuset_alloc failed\", jobid);\n\t\treturn -1;\n\t}\n\tif ((jobset = getsetname(pjob)) == NULL) {\n\t\tlog_joberr(errno, __func__, \"getsetname failed\", jobid);\n\t\treturn -1;\n\t}\n\tif (cpuset_query(cp, jobset) == -1) {\n\t\tlog_joberr(errno, __func__, \"cpuset_query failed\", jobid);\n\t\tfree(jobset);\n\t\treturn -1;\n\t}\n\tif (cpuset_getcpus(cp, cpubits) == -1) {\n\t\tlog_joberr(errno, __func__, \"cpuset_getcpus failed\", jobid);\n\t\tfree(jobset);\n\t\treturn -1;\n\t}\n\n\tif ((firstbit = bitmask_first(cpubits)) == bitmask_nbits(cpubits)) {\n\t\tDBPRT((\"%s:  cpubits mask is empty\\n\", __func__))\n\t\tfree(jobset);\n\t\treturn -1;\n\t}\n\tlastbit = bitmask_last(cpubits);\n\n\tfor (cpunum = firstbit; cpunum <= lastbit;\n\t\tcpunum = bitmask_next(cpubits, cpunum + 1))\n\t\t\tcpunum_inuse(cpunum, pjob);\n\n\tfree(jobset);\n#endif\t/* CPUSET_VERSION < 4 */\n\treturn 0;\n}\n\n/**\n * @brief\n *\tsets values for cpuset\n *\n * @param[in] cptr - config info\n * @param[in] suff - suffix for val\n * @param[in] val - value for cpuset\n *\n * @return Void\n *\n */\nvoid\ncpusetvalue(struct config *cptr, char *suff, ulong *val)\n{\n\tchar\t\t*left;\n\tulong\t\tul;\n\n\tul = strtoul(cptr->c_u.c_value, &left, 0);\n\tif (*left != '\\0' && strcasecmp(left, suff) != 0) {\n\t\tsprintf(log_buffer, \"%s: cannot parse %s\",\n\t\t\tcptr->c_name, cptr->c_u.c_value);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t\treturn;\n\t}\n\tsprintf(log_buffer, \"setting %s=%lu%s\", cptr->c_name, ul, suff);\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t*val = ul;\n\treturn;\n}\n\n/**\n * @brief\n *\tlogs info about the process\n *\n * @param[in] pid - process id\n * @param[in] errnum - error number\n * @param[in] jid - job id\n *\n * @return Void\n *\n */\n\nvoid\nlogprocinfo(pid_t pid, int errnum, const char *jid)\n{\n\tstatic char\t*procstatpath = NULL;\n\tint\t\tpathlen;\n\tpid_t\t\tpgrp, ppid, session;\n\tchar\t\tstate;\n\tchar\t\tcomm[PATH_MAX];\n\tFILE\t\t*fp;\n\n\tif (procstatpath == NULL) {\n\t\tif ((pathlen = pathconf(\"/proc\", _PC_PATH_MAX)) == -1) {\n\t\t\tlog_joberr(errnum, __func__, \"pathconf\", (char *)jid);\n\t\t\treturn;\n\t\t}\n\t\tif ((procstatpath = malloc(pathlen)) == NULL) {\n\t\t\tlog_joberr(errnum, __func__, \"malloc\", (char *)jid);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t(void) sprintf(procstatpath, \"/proc/%u/stat\", pid);\n\tif ((fp = fopen(procstatpath, \"r\")) == NULL) {\n\t\tsprintf(log_buffer, \"fopen %s\", procstatpath);\n\t\tlog_joberr(errnum, __func__, log_buffer, (char *)jid);\n\t\treturn;\n\t}\n\tif (fscanf(fp, \"%d %s %c %d %d %d\", &pid, comm, &state, &ppid,\n\t\t&pgrp, &session) != 6) {\n\t\tsprintf(log_buffer, \"failed to read proc info for PID %d\", pid);\n\t\tlog_joberr(errnum, __func__, log_buffer, (char *)jid);\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tsprintf(log_buffer, \"PID %d: comm %s, state %c, PPID %d, \"\n\t\t\"PGRP %d, session %d\", pid, comm, state, ppid, pgrp, session);\n\tlog_joberr(errnum, __func__, log_buffer, (char *)jid);\n\n\tfclose(fp);\n}\n\n/**\n * @brief\n *\tdeletes cpuset file for job.\n *\n * @param[in] qname - job cpuset name\n * @param[in] pjob - pointer to job structure\n *\n * @return Void\n *\n */\n\nvoid\ndel_cpusetfile(char *qname, job *pjob)\n{\n\tchar\t\t*jid = pjob->ji_qs.ji_jobid;\n#if\t(CPUSET_VERSION < 4)\n\tchar\t\tname_buf[MAXPATHLEN+1];\n\textern\tchar\t*path_jobs;\n\n\tstrcpy(name_buf, path_jobs);\n\tstrcat(name_buf, qname);\n\tstrcat(name_buf, JOB_CPUSET_SUFFIX);\n\tif (unlink(name_buf) == -1) {\n\t\tsprintf(log_buffer, \"unlink cpuset %s failed\", name_buf);\n\t\tlog_joberr(errno, __func__, log_buffer, (char *)jid);\n\t} else {\n\t\tsprintf(log_buffer, \"delete cpuset %s\", qname);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tjid, log_buffer);\n\t\t/* CPU set is gone - it's now safe to reclaim the job's CPUs */\n\t\tif (free_job_CPUs != NULL)\n\t\t\t(*free_job_CPUs)(pjob);\n\t}\n#else\n\tchar\t\tpathbuf[sizeof(DEV_CPUSET) + 1 + CPUSET_NAME_SIZE];\n\n\tassert((qname != NULL) && (qname[0] == '/'));\n\n\t/*\n\t *\tIf the named CPU set no longer exists, presumably because\n\t *\tthe ``notify_on_release flag'' caused the system to remove\n\t *\tit before we did, don't complain.\n\t */\n\tstrncpy(pathbuf, DEV_CPUSET, sizeof(pathbuf));\n\tstrncat(pathbuf, qname, sizeof(pathbuf) - strlen(pathbuf));\n\tif (access((const char *) pathbuf, F_OK) == -1)\n\t\treturn;\n\n\t/* don't try to delete one of the ``special'' PBS CPU sets */\n\tif (is_pbs_container((const char *) qname))\n\t\treturn;\n\t/* remove all sub-CPU sets of this set, then the set itself */\n\tprune_subsetsof(qname, jid);\n\tif (try_remove_set(qname, jid) != -1) {\n\t\t/* CPU set is gone - it's now safe to reclaim the job's CPUs */\n\t\tif (free_job_CPUs != NULL)\n\t\t\t(*free_job_CPUs)(pjob);\n\t} else {\n\t\tsprintf(log_buffer, \"removal of cpuset %s failed\", qname);\n\t\tlog_joberr(errno, __func__, log_buffer, (char *)jid);\n\t}\n#endif\t/* CPUSET_VERSION < 4 */\n}\n\n#if\t(CPUSET_VERSION < 4)\n/**\n * @brief\n *\tClear a job from a cpuset.\n *\tIf the cpuset is shared and other jobs are still using it,\n *\tjust detach the job and leave the cpuset alone.  Otherwise,\n *\tdelete the cpuset.\n *\tDon't bother with retries right now, see if we need them.\n *\n * @param[in] pjob - pointer to job\n *\n * @return Void\n *\n */\n\nvoid\nclear_cpuset(job *pjob)\n{\n\textern\tpbs_list_head\tsvr_alljobs;\n\tint\t\t\ti, numsets;\n\tcpuset_NameList_t\t*names;\n\tchar\t\t\t*qname;\n\tchar\t\t\t*jobset = NULL;\n\tjob\t\t\t*pj;\n\n\t/* get name for job cpuset */\n\tqname = getsetname(pjob);\n\tif (qname == NULL) {\n\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB,\n\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\"clear_cpuset: unable to get set name\");\n\t\treturn;\n\t}\n\n\tsprintf(log_buffer, \"clear_cpuset: setname=%s\", qname);\n\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB,\n\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);\n\n\n\t/* get all the cpuset names on the system */\n\tif ((names = cpusetGetNameList()) == NULL) {\n\t\tlog_err(errno, __func__, \"cpusetGetNameList\");\n\t\tfree(qname);\n\t\treturn;\n\t}\n\n\t/* make sure job cpuset exists */\n\tnumsets = names->count;\n\tfor (i=0; i<numsets; i++) {\n\t\tif (strcmp(names->list[i], qname) == 0)\n\t\t\tbreak;\n\t}\n\tcpusetFreeNameList(names);\n\tif (i == numsets) {\t\t\t/* not there */\n\t\tdel_cpusetfile(qname, pjob);\n\t\tfree(qname);\n\t\treturn;\n\t}\n\n\t/*\n\t **\tLook through all jobs to see if any others exist that use\n\t **\tthis cpuset.\n\t */\n\tfor (pj = (job *)GET_NEXT(svr_alljobs);\n\t\tpj != NULL;\n\t\tpj = (job *)GET_NEXT(pj->ji_alljobs)) {\n\t\tif (pj == pjob)\t\t\t\t/* not me */\n\t\t\tcontinue;\n\t\tif (pj->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING)\n\t\t\tcontinue;\t/* don't care if not running */\n\n\t\tjobset = getsetname(pj);\n\t\tif (jobset == NULL)\n\t\t\tcontinue;\t/* doesn't have name set */\n\n\t\tif (strcmp(qname, jobset) == 0)\t\t/* found one */\n\t\t\tbreak;\n\t\tfree(jobset);\n\t\tjobset = NULL;\n\t}\n\tif (jobset != NULL)\n\t\tfree(jobset);\n\tif (pj != NULL) {\t\t/* shared and in use */\n\t\ttask\t*ptask;\n\n\t\tfor (ptask = (task *)GET_NEXT(pjob->ji_tasks);\n\t\t\tptask != NULL;\n\t\t\tptask = (task *)GET_NEXT(ptask->ti_jobtask)) {\n\t\t\tpid_t\tsid = ptask->ti_qs.ti_sid;\n\t\t\tint\ti;\n\n\t\t\tfor (i=0; i<nproc; i++) {\n\t\t\t\tproc_stat_t\t*ps = &proc_info[i];\n\n\t\t\t\tif (ps->session != sid)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cpusetDetachPID(qname, ps->pid) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tsprintf(log_buffer, \"cpusetDetachPID %s\",\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\t}\n\t\t}\n\t\tsprintf(log_buffer, \"detach from cpuset %s\", qname);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);\n\t} else {\n\t\t/*\n\t\t **\tNo longer in use, clean up and destroy cpuset.\n\t\t */\n\t\tif (cpusetDetachAll(qname) == 0 && errno != ESRCH) {\n\t\t\tsprintf(log_buffer, \"cpusetDetachAll %s\", qname);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t}\n\t\t/*\n\t\t *\tLooping is necessary to protect against sleep being\n\t\t *\tinterrupted by delivery of a signal (e.g. SIGCHLD).\n\t\t */\n\t\tif (cpuset_destroy_delay > 0) {\n\t\t\tunsigned int unslept = (unsigned int)cpuset_destroy_delay;\n\t\t\twhile ((unslept = sleep(unslept)) > 0)\n\t\t\t\t;\n\t\t}\n\t\tif (cpusetDestroy(qname) == 0 && errno != ESRCH) {\n\t\t\tsprintf(log_buffer, \"cpusetDestroy %s\", qname);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t}\n\t\tdel_cpusetfile(qname, pjob);\n\t}\n\n\tfree(qname);\n\n\tclear_cpuset_fromjob(pjob);\n}\n\n#else\n\n/**\n * @brief\n *\tClear a job from a cpuset, then try (hard) to remove any processes\n *\tremaining in the set before deleting it.\n *\n * @param[in] pjob - pointer to job\n *\n * @return Void\n *\n */\n\nvoid\nclear_cpuset(job *pjob)\n{\n\tchar\t*qname;\n\n\t/* get name for job cpuset */\n\tDBPRT((\"%s:  job %s\\n\", __func__, pjob->ji_qs.ji_jobid))\n\tqname = getsetname(pjob);\n\tif (qname == NULL)\n\t\treturn;\n\telse\n\t\tclear_named_cpuset(qname, pjob);\t/* frees qname */\n}\n\n/**\n * @brief\n *\tClear processes from the CPU set qname and delete the set.  Unlike\n *\tclear_cpuset(), the set name is not derived from the job structure.\n *\tNote that we must be careful about attempting to kill processes in\n *\ta CPU set (or remove the set) since suspended jobs are in the \"/\"\n *\tset rather than a PBS-owned one.\n *\n * @param[in] qname - cpuset name\n * @param[in] pjob - pointer to job\n *\n * @return Void\n *\n */\n\nstatic void\nclear_named_cpuset(char *qname, job *pjob)\n{\n\tif (qname[0] != '\\0') {\n\t\tchar\t*jid = pjob->ji_qs.ji_jobid;\n\n\t\tassert(qname[0] == '/');\n\t\tif (strstr(qname, CPUSET_REL_NAME(PBS_CPUSETDIR)) == qname) {\n\t\t\tremove_cpuset_procs(qname, jid);\n\t\t\tdel_cpusetfile(qname, pjob);\n\t\t} else {\n\t\t\t/*\n\t\t\t *\tThe only time we get here is when the set name\n\t\t\t *\tdoesn't belong to PBS.  That only happens if\n\t\t\t *\tthe job has been suspended and its processes\n\t\t\t *\tare now residing in the root set.  As a result\n\t\t\t *\tof the suspension, the original set will have\n\t\t\t *\tbeen deleted (using del_cpusetfile()), so there\n\t\t\t *\tshould be no CPUs left assigned to the job and\n\t\t\t *\tnothing for us to do here.\n\t\t\t */\n\t\t}\n\t}\n\tfree(qname);\n\n\tclear_cpuset_fromjob(pjob);\n}\n\n/**\n * @brief\n *\tThis function is courtesy of pj@sgi.com.\n *\tThe cpuset_*_pidlist() routines were broken (cause memory\n *\tcorruption) on early versions of libcpuset.  Those same libcpuset\n *\tversions didn't define the [optional] routine cpuset_migrate(),\n *\twhich fact we use to determine if the cpuset_*_pidlist routines\n *\tare broken.\n *\n */\n\nint\ncpuset_pidlist_broken(void)\n{\n\treturn (cpuset_function(\"cpuset_migrate\") == 0);\n}\n\n/**\n * @brief\tKill remaining cpuset tasks.\n * \t\tTimeout after cpuset_destroy_delay seconds.\n *\n * @par\t\tIf cpuset_init_pidlist() fails, this function\n *\t\twill return without waiting the full duration\n *\t\tand there may be processes remaining in the cpuset.\n *\n * @param[in]\tsetname - Name of the cpuset\n * @param[in]\tisrecursive - Whether to descend into the cpuset\n * @param[in]\tjid - Job ID string\n *\n * @return int\n * @retval -1\t- Error\n * @retval >= 0\t- Number of PIDs remaining\n */\nstatic int\nkill_cpuset_procs(const char *setname, int isrecursive, const char *jid)\n{\n\tulong\t\t\tunslept = cpuset_destroy_delay;\n\tpid_t\t\t\tpid;\n\tpid_t\t\t\tmypid;\t\t/* to avoid signalling myself */\n\tint\t\t\tpll = 0;\t/* PID list length */\n\tint\t\t\ti;\n\tstruct cpuset_pidlist\t*pl;\n\n\tmypid = getpid();\n\tdo {\n\t\tif ((pl = cpuset_init_pidlist(setname, isrecursive)) == NULL) {\n\t\t\tlog_joberr(errno, __func__, \"NULL cpuset_init_pidlist\", (char *)jid);\n\t\t\tpll = -1;\n\t\t} else {\n\t\t\tpll = cpuset_pidlist_length(pl);\n\t\t\tsprintf(log_buffer, \"cpuset_pidlist_length (#1):  %d\", pll);\n\t\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_DEBUG, (char *)jid, log_buffer);\n#ifdef\tDEBUG\n\t\t\tDBPRT((\"%s:  pll %d\", __func__, pll));\n\t\t\tfor (i = 0; i < pll; i++) {\n\t\t\t\tDBPRT((\"%s:  cpuset_get_pidlist(pl, %d) = %d\\n\", __func__, i, cpuset_get_pidlist(pl, i)));\n\t\t\t}\n#endif\t/* DEBUG */\n\t\t\tfor (i = 0; i < pll; i++) {\n\t\t\t\tif ((pid = cpuset_get_pidlist(pl, i)) != (pid_t)-1) {\n\t\t\t\t\tif (pid < 2) {\n\t\t\t\t\t\tint\tsave_errno = errno;\n\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\"cpuset_get_pidlist index %d \"\n\t\t\t\t\t\t\t\"returned %d\", i, pid);\n\t\t\t\t\t\tlog_joberr(save_errno, __func__, log_buffer,\n\t\t\t\t\t\t\t(char *)jid);\n\t\t\t\t\t} else if (ownerof(pid) == 0) {\n\t\t\t\t\t\tsprintf(log_buffer, \"skip root-owned PID %d in set %s\",\n\t\t\t\t\t\t\tpid, setname);\n\t\t\t\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\t\t\t\t\tLOG_DEBUG, (char *)jid, log_buffer);\n\t\t\t\t\t} else if (pid == mypid) {\n\t\t\t\t\t\tsprintf(log_buffer, \"skip my PID %d in set %s\",\n\t\t\t\t\t\t\tpid, setname);\n\t\t\t\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\t\t\t\t\tLOG_DEBUG, (char *)jid, log_buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(void) kill(pid, SIGKILL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* some documentation incorrectly refers to cpuset_free_pidlist() */\n\t\t\tcpuset_freepidlist(pl);\n\t\t\t/* break from the loop if no PIDs remain */\n\t\t\tif (pll == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Do not sleep if cpuset_destroy_delay is unset */\n\t\tif (cpuset_destroy_delay > 0)\n\t\t\t/* Do not decrement unslept if sleep() fails. */\n\t\t\tif (sleep(1) != 0)\n\t\t\t\tcontinue;\n\t\t/* Now decrement. */\n\t\tunslept--;\n\t} while (unslept > 0);\n\treturn (pll);\n}\n\n/**\n * @brief\n *\tRemove cpuset processes.\n *\n * @param[in] setname - cpuset name\n * @param[in] jid - job id\n *\n * @return void\n *\n */\nstatic void\nremove_cpuset_procs(const char *setname, const char *jid)\n{\n\tint\t\t\ti;\n\tint\t\t\tisrecursive = 1;\n\tpid_t\t\t\tpid;\n\tpid_t\t\t\tmypid;\t/* to avoid signalling myself */\n\tstruct cpuset_pidlist\t*pl;\n\tint\t\t\tpll;\n\tstatic int\t\tfirsttime = 1;\n\n\t/* avoid using some broken libcpuset functions */\n\tif (cpuset_pidlist_broken()) {\n\t\tif (firsttime) {\n\t\t\t/* note the problem, but only once */\n\t\t\tfirsttime = 0;\n\t\t\tsprintf(log_buffer, \"ProPack < 5:  can't remove_cpuset_procs\");\n\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, __func__, log_buffer);\n\t\t}\n\t\t(void)kill_cpuset_procs(setname, isrecursive, jid);\n\t\treturn;\n\t}\n\n\tmypid = getpid();\n\n\t/*\n\t *\tStep 1:  find the list of processes that remain in setname\n\t *\tand send them SIGKILL.  We treat a NULL return value from\n\t *\tcpuset_init_pidlist() as meaning no processes were found.\n\t *\tAccording to pj@sgi.com, even in this case cpuset_init_pidlist()\n\t *\tought to have returned non-NULL, but cpuset_pidlist_length()\n\t *\tshould return 0.\n\t */\n\tpll = kill_cpuset_procs(setname, isrecursive, jid);\n\tif (pll == 0)\n\t\treturn;\n\n\t/*\n\t *\tStep 2:  there are processes that didn't respond to the\n\t *\tSIGKILL.  Attempt to sweep them under the rug (i.e. into\n\t *\tthe place suspended processes go) so the CPU set may\n\t *\tthen be deleted.\n\t */\n\tif ((pl = cpuset_init_pidlist(setname, isrecursive)) == NULL) {\n\t\tlog_joberr(errno, __func__, \"NULL cpuset_init_pidlist\", (char *)jid);\n\t\treturn;\n\t}\n\n\t/* are we done or do we need to deal with undead processes? */\n\tpll = cpuset_pidlist_length(pl);\n\tsprintf(log_buffer, \"cpuset_pidlist_length (#2a):  %d\", pll);\n\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_DEBUG, (char *)jid,\n\t\tlog_buffer);\n\tif (pll == 0) {\n\t\tcpuset_freepidlist(pl);\n\n\t\t/*\n\t\t *\tDid any processes sneak in while we were making the\n\t\t *\tprevious list?\n\t\t */\n\t\tif ((pl = cpuset_init_pidlist(setname, isrecursive)) == NULL) {\n\t\t\tlog_joberr(errno, __func__, \"NULL cpuset_init_pidlist\",\n\t\t\t\t(char *)jid);\n\t\t\treturn;\n\t\t}\n\t\tpll = cpuset_pidlist_length(pl);\n\t\tsprintf(log_buffer, \"cpuset_pidlist_length (#2b):  %d\", pll);\n\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\t(char *)jid, log_buffer);\n\n\t\tif (pll == 0) {\n\t\t\tcpuset_freepidlist(pl);\n\t\t\treturn;\n\t\t} else {\n\t\t\tfor (i = 0; i < pll; i++) {\n\t\t\t\tpid = cpuset_get_pidlist(pl, i);\n\t\t\t\tif (pid == -1) {\n\t\t\t\t\tint\tsave_errno = errno;\n\n\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\"cpuset_get_pidlist index %d \"\n\t\t\t\t\t\t\"returned -1\", i);\n\t\t\t\t\tlog_joberr(save_errno, __func__, log_buffer,\n\t\t\t\t\t\t(char *)jid);\n\t\t\t\t} else\n\t\t\t\t\tlogprocinfo(pid, errno, jid);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < pll; i++) {\n\t\tif ((pid = cpuset_get_pidlist(pl, i)) != (pid_t) -1) {\n\t\t\tif (ownerof(pid) != 0) {\n\t\t\t\tsprintf(log_buffer, \"failed to kill pid %d in set %s\",\n\t\t\t\t\tpid, setname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer, (char *)jid);\n\t\t\t}\n\t\t\tif (pid == mypid) {\n\t\t\t\tsprintf(log_buffer, \"my PID (%d) in pidlist of set %s\",\n\t\t\t\t\tpid, setname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer, (char *)jid);\n\t\t\t}\n\t\t\tif (cpuset_move(pid, DEV_CPUSET_ROOT) != 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"cpuset_move PID %d (from set %s) failed\",\n\t\t\t\t\tpid, setname);\n\t\t\t\tlog_joberr(errno, __func__, log_buffer, (char *)jid);\n\t\t\t} else {\n\t\t\t\tif (pid != mypid)\n\t\t\t\t\t(void) kill(pid, SIGSTOP);\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"PID %d moved to set %s\",\n\t\t\t\t\tpid, DEV_CPUSET_ROOT);\n\t\t\t\tlog_joberr(0, __func__, log_buffer, (char *)jid);\n\t\t\t}\n\t\t} else {\n\t\t\tint\tsave_errno = errno;\n\n\t\t\tsprintf(log_buffer, \"cpuset_get_pidlist index %d returned -1\",\n\t\t\t\ti);\n\t\t\tlog_joberr(save_errno, __func__, log_buffer, (char *)jid);\n\t\t}\n\t}\n\n\tcpuset_freepidlist(pl);\n}\n\n/**\n * @brief\n *\treturns the owner of process\n *\n * @param[in] pid - process id\n *\n * @return \tuid_t\n * @retval \tuser id\n *\n */\n\nstatic uid_t\nownerof(pid_t pid)\n{\n\tstruct stat\tsb;\n\tchar\t\tbuf[MAXPATHLEN];\n\n\t(void) sprintf(buf, \"/proc/%d\", pid);\n\tif ((stat(buf, &sb) == -1) || !S_ISDIR(sb.st_mode))\n\t\treturn (-1);\n\telse\n\t\treturn (sb.st_uid);\n}\n#endif\t/* CPUSET_VERSION < 4 */\n\n/**\n * @brief\n * \tclears cpuset from job.\n *\n * @param[in] pjob - pointer to job\n *\n * @return Void\n *\n */\n\nstatic void\nclear_cpuset_fromjob(job *pjob)\n{\n\t/* get rid of ATTR_altid containing cpuset name */\n\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],\n\t\tATTR_altid, NULL, NULL);\n\tDBPRT((\"%s:  removing cpuset attribute from job %s\\n\", __func__,\n\t\tpjob->ji_qs.ji_jobid))\n\tupdate_ajob_status(pjob);\n}\n#endif\t/* MOM_CPUSET */\n\n#ifdef NAS\n/* localmod 090 */\n/**\n * @brief\n *\treturns present time\n *\n * @return \tchar *\n * @retval \ttime\n *\n */\n\nstatic char *\nsys_clocks(struct rm_attribute *attrib)\n{\n\tsprintf(ret_string, \"%lu/%lu\", (unsigned long) linux_time,\n\t\t(unsigned long) time_now);\n\treturn ret_string;\n}\n\n#endif /* NAS */\n\n#if\tMOM_BGL\n/*********************************************************************/\n/*     Global variables\t\t\t\t\t\t     */\n/*********************************************************************/\nextern int\tinternal_state_update;\nchar\t\tmom_host[PBS_MAXHOSTNAME+1];\nextern char\tmom_short_name[PBS_MAXHOSTNAME+1];\nextern int\talarm_time;\nextern int\trestrict_user;\nextern int\trestrict_user_exempt_uids[NUM_RESTRICT_USER_EXEMPT_UIDS];\n\nchar\t*reserve_bglpartitions = NULL;\t  /* comma-separated list of reserved */\nstruct bgl_partition *bglpartitions = NULL;\t/* unreserved partitions */\nstruct bgl_partition *bglpartitions_down = NULL;    /* partitions marked down */\nstruct bgl_vnode *bglvnodes = NULL;\t\t/* vnodes in the system */\nchar\t*downed_bglvnodes = NULL;     /* comma-seprated list of downed vnodes */\nstruct bgl_job *stuck_bgljobs = NULL;\t\t/* \"hanging\" BGL jobs */\n\n/*************************************************************************/\n/* in_str: return 1 if 'str' is found in comma-separated 'string_list'; 0 */\n/* otherwise.\t\t\t\t\t\t\t\t  */\n/*************************************************************************/\n/**\n * @brief\n *\tfinds str in string list\n *\n * @param[in] str - string to search\n * @param[in] string_list - comma seperated list of string\n *\n * @return \tint\n * @retval\t1\tSuccess\n * @retval \t0\tFail\n *\n */\nstatic int\nin_string_list(char *str, char *string_list)\n{\n\tchar\t*p = NULL;\n\tchar\t*p2 = NULL;\n\tchar\t*ptoken = NULL;\n\tint\tfound_match = 0;\n\tint\tlen;\n\n\tif ((str == NULL) || (str[0] == '\\0') || (string_list == NULL)) {\n\t\treturn (0);\n\t}\n\n\tp2 = strdup(string_list);\n\tif (p2 == NULL) {\n\t\treturn (0);\n\t}\n\n\tp = p2;\n\tlen = strlen(string_list);\n\n\twhile (p < (p+len)) {\n\n\t\t/* skip past [, ] characters */\n\t\twhile ((*p != '\\0') &&  ((*p == ',') || (*p == ' '))) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\n\t\tptoken = p;\t/* start of token */\n\n\t\t/* skip past not in [, ] characters  */\n\t\twhile ((*p != '\\0') &&  ((*p != ',') && (*p != ' '))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\t*p = '\\0';\t/* delimeter value is nulled */\n\t\tif (strcmp(str, ptoken)  == 0) {\n\t\t\tfound_match = 1;\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\n\tif (p2) {\n\t\t(void)free(p2);\n\t}\n\treturn (found_match);\n}\n\n/**\n * @brief\n *\tcompares 2 string lists, strl1 and strl2\n *\n * @param[in] strl1 - string list 1\n * @param[in] strl2 - string list 2\n *\n * @return \tint\n * @retval \t1 \tSuccess matched\n * @retval \t0 \tFailed\tunmatch\n *\n */\nstatic int\nequal_string_list(char *strl1, char *strl2)\n{\n\tchar *strl1_dup = NULL;\n\tchar *strl2_dup = NULL;\n\tchar *slp1, *slp2;\n\tint\tret;\n\n\tif ((strl1 == NULL)  || (strl2 == NULL))\n\t\treturn (0);\n\n\tstrl1_dup = strdup(strl1);\n\tstrl2_dup = strdup(strl2);\n\n\tif ((strl1_dup == NULL)  || (strl2_dup == NULL)) {\n\t\tlog_err(errno, \"equal_string_list\", \"malloc failed!\");\n\t\treturn (0);\n\t}\n\n\t/* check to make sure all elements of strl1 appear on strl2 */\n\tslp1=strtok(strl1_dup, \", \");\n\twhile (slp1) {\n\t\tif (!in_string_list(slp1, strl2)) {\n\t\t\tret = 0;\t/* no match */\n\t\t\tgoto equal_string_list_end;\n\t\t}\n\t\tslp1=strtok(NULL, \", \");\n\t}\n\n\t/* check to make sure all elements of strl2 appear on strl1 */\n\tslp2=strtok(strl2_dup, \", \");\n\twhile (slp2) {\n\t\tif (! in_string_list(slp2, strl1)) {\n\t\t\tret = 0;\t/* no match */\n\t\t\tgoto equal_string_list_end;\n\t\t}\n\t\tslp2=strtok(NULL, \", \");\n\t}\n\tret = 1;\n\nequal_string_list_end:\n\tif (strl1_dup)\n\t\t(void)free(strl1_dup);\n\n\tif (strl2_dup)\n\t\t(void)free(strl2_dup);\n\n\treturn (ret);\n}\n\n/**\n * @brief\n *\tcompares 2 string lists, strl1 and strl2\n *\n * @param[in] strl1 - string list 1\n * @param[in] strl2 - string list 2\n *\n * @return      int\n * @retval      1       Success\tif at least one element from each list match\n * @retval      0       Failed  they don't overlap.\n *\n * NOTE:A string_list passed as a NULL value is considered an error.\n */\n\nstatic int\noverlap_string_list(char *strl1, char *strl2)\n{\n\tchar *strl1_dup = NULL;\n\tchar *slp1;\n\tint\tret;\n\n\tif ((strl1 == NULL)  || (strl2 == NULL))\n\t\treturn (0);\n\n\tstrl1_dup = strdup(strl1);\n\n\tif (strl1_dup == NULL) {\n\t\tlog_err(errno, \"overlap_string_list\", \"malloc failed!\");\n\t\treturn (0);\n\t}\n\n\t/* check to make sure all elements of strl1 appear on strl2 */\n\tslp1=strtok(strl1_dup, \", \");\n\twhile (slp1) {\n\t\tif (in_string_list(slp1, strl2)) {\n\t\t\tret = 1;\t/* a match */\n\t\t\tgoto overlap_string_list_end;\n\t\t}\n\t\tslp1=strtok(NULL, \", \");\n\t}\n\n\tret = 0;\n\noverlap_string_list_end:\n\tif (strl1_dup) {\n\t\t(void)free(strl1_dup);\n\t}\n\n\treturn (ret);\n}\n\n/**\n * @brief\n *\tlike strdup() except this one appends 'str_val' to existing\n *\tstr_src' string, doing a reallocs on 'str_src' as needed.\n * \tstr_src' is a comma-separated list with a leading space introducing\n *\ta list value.\n *\n * @param[in] str_src - source string\n * @param[in] str_val - string with value\n *\n * @return \tint\n * @retval\t0\tSuccess\n * @retval\t-1\tFailure\n *\n */\n\nstatic int\nstrdup_cat(char **str_src, char *str_val)\n{\n\tchar\t*str_bef = NULL;\n\tchar *temp_str_src = NULL;\n\n\tif ((str_val == NULL) || (str_val[0] == '\\0') || (str_src == NULL)) {\n\t\treturn (0);\n\t}\n\n\tif (*str_src == NULL) {\n\t\t*str_src = (char *)malloc((size_t)strlen(str_val)+1);\n\t\tif (*str_src == NULL) {\n\t\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\t\treturn (-1);\n\t\t}\n\t\tstrcpy(*str_src, str_val);\n\t} else {\n\t\tstr_bef = *str_src;\n\n\t\ttemp_str_src = (char *)realloc((char *)*str_src,\n\t\t\t(size_t)(strlen(*str_src)+strlen(str_val)+3));\n\n\t\tif (temp_str_src == NULL) {\n\t\t\tlog_err(errno, __func__, \"realloc failed!\");\n\t\t\t*str_src = str_bef;\n\t\t\treturn (-1);\n\t\t} else {\n\t\t\t*str_src = temp_str_src;\n\t\t}\n\t\tstrcat(*str_src, \", \");\n\t\tstrcat(*str_src, str_val);\n\t}\n\treturn (0);\n}\n\n/********************************************************************/\n/********  bgl_vnode functions **************************************/\n/********************************************************************/\n\n/**\n * @brief\n *\tcreates bgl vnodes\n *\n * @param[in] vnode_name - vnode name\n *\n * @return \tstructure handle\n * @retval\tstructure handle to bgl_vnode\n *\n */\n\nstruct bgl_vnode *\nbgl_vnode_create(char *vnode_name)\n{\n\tstruct bgl_vnode\t*iptr = NULL;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL\");\n\t\treturn NULL;\n\t}\n\n\tiptr = (struct bgl_vnode *)malloc(sizeof(struct bgl_vnode));\n\tif (iptr == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tiptr->state = BGLVN_UNKNOWN;\n\tiptr->num_cnodes = -1;\n\tiptr->amt_mem = 0;\n\tiptr->part_list = NULL;\n\tiptr->nextptr = NULL;\n\n\tiptr->vnode_name = (char *)malloc((size_t)strlen(vnode_name)+1);\n\tif (iptr->vnode_name == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->vnode_name, vnode_name);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tgets bgl vnode state.\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n *\n * @return \tenum\n * @retval\tBGLVN_UNKNOWN(0)\tFailure\n * @retval \t!BGLVN_UNKNOWN(!0)\tSuccess\n *\n */\nbgl_vnstate\nbgl_vnode_get_state(struct bgl_vnode *head, char *vnode_name)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (BGLVN_UNKNOWN);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->vnode_name &&\n\t\t\tstrcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\treturn (iptr->state);\n\t\t}\n\t}\n\treturn (BGLVN_UNKNOWN);\n}\n\n/**\n * @brief\n *\tReturns the number of cpu available on node\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n *\n * @return \tint\n * @retval\tnumber of cpus\t\tSuccess\n * @retval\t-1\t\t\tError\n *\n */\n\nint\nbgl_vnode_get_num_cnodes(struct bgl_vnode *head, char *vnode_name)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (-1);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->vnode_name &&\n\t\t\tstrcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\treturn (iptr->num_cnodes);\n\t\t}\n\t}\n\treturn (-1);\n}\n\n/**\n * @brief\n *      Returns the amount of memory available on node\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n *\n * @return      ulong\n * @retval      amount of memory(kb)\tSuccess\n * @retval      0                      \tError\n *\n */\n\nulong\nbgl_vnode_get_amt_mem(struct bgl_vnode *head, char *vnode_name)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (0);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->vnode_name &&\n\t\t\tstrcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\treturn (iptr->amt_mem);\n\t\t}\n\t}\n\treturn (0);\n}\n\n/**\n * @brief\n *      Returns the partition list available on node\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n *\n * @return      string\n * @retval      partition list        \tSuccess\n * @retval      NULL            \tError\n *\n */\n\nchar *\nbgl_vnode_get_part_list(struct bgl_vnode *head, char *vnode_name)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->vnode_name &&\n\t\t\tstrcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\treturn (iptr->part_list);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief\n *\tbgl_vnode_get_part_list_spanning_vnode: returns a list of partitions that\n * \tcontains the given vnode (vnode_name=bpid#qcard#ncard), or the base\n * \tpartition (bpid) that the vnode  belongs to. 'bpid' can be NULL if vnode\n * \tis a base partition.\n * NOTE:  This returns a malloced array that needs to be  freed.\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n * @param[in] bpid - base partition id\n *\n * @return\tstring\n * @retval\tplist_ret\tpartition list\n * @retval\tNULL\t\tError\n *\n */\n\nchar *\nbgl_vnode_get_part_list_spanning_vnode(struct bgl_vnode *head, char *vnode_name,\n\tchar *bpid)\n{\n\tstruct bgl_vnode\t*iptr;\n\tchar\t\t\t*plist_ret = NULL;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (iptr->vnode_name) {\t\t/* okay */\n\t\t\t/* match itself or bpid */\n\t\t\tif( (strcmp(iptr->vnode_name, vnode_name) == 0) || \\\n\t\t\t    (bpid && (strcmp(bpid, iptr->vnode_name) == 0)) ) {\n\t\t\t\t(void)strdup_cat(&plist_ret, iptr->part_list);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn (plist_ret);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_vnode_create() is not called first,\n * \tbe sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n * @param[in] state - state of vnode\n *\n * @return \tstructure handle\n * @retval\tstructure handle to bgl_vnode\tSuccess\n *\n */\n\nstruct bgl_vnode *\nbgl_vnode_put_state(struct bgl_vnode *head, char *vnode_name, bgl_vnstate state)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\tiptr->state = state;\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_vnode_create(vnode_name);\n\n\tif (iptr == NULL)\n\t\treturn (head);\n\n\tiptr->nextptr = head;\n\n\tiptr->state = state;\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_vnode_create() is not called first,\n * \tbe sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n * @param[in] num_cnodes - number of cpus on node\n *\n * @return\tstructure handle\n * @retval\tstructure handle to bgl_vnode\t\tif exists\n * @retval\tcreates one entry for bgl_vnode\t\tif doesn exist\n *\n */\n\nstruct bgl_vnode *\nbgl_vnode_put_num_cnodes(struct bgl_vnode *head, char *vnode_name,\n\tint num_cnodes)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\tiptr->num_cnodes = num_cnodes;\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_vnode_create(vnode_name);\n\n\tif (iptr == NULL)\n\t\treturn (head);\n\n\tiptr->nextptr = head;\n\n\tiptr->num_cnodes = num_cnodes;\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_vnode_create() is not called first,\n * \tbe sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n * @param[in] amt_mem - amount of memory on node\n *\n * @return      structure handle\n * @retval      structure handle to bgl_vnode           \tif exists\n * @retval      creates & return one entry for bgl_vnode\tif doesn exist\n *\n */\n\nstruct bgl_vnode *\nbgl_vnode_put_amt_mem(struct bgl_vnode *head, char *vnode_name, ulong amt_mem)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif (vnode_name == NULL) {\n\t\tlog_err(-1, __func__, \"vnode_name is NULL!\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\tiptr->amt_mem = amt_mem;\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_vnode_create(vnode_name);\n\n\tif (iptr == NULL)\n\t\treturn (head);\n\n\tiptr->nextptr = head;\n\n\tiptr->amt_mem = amt_mem;\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_vnode_create() is not called first,\n * \tbe sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_vnode structure\n * @param[in] vnode_name - vnode name\n * @param[in] part - partition list\n *\n * @return      structure handle\n * @retval      structure handle to bgl_vnode                   if exists\n * @retval      creates & return one entry for bgl_vnode        if doesn exist\n *\n */\n\nstruct bgl_vnode *\nbgl_vnode_put_part_list(struct bgl_vnode *head, char *vnode_name, char *part)\n{\n\tstruct bgl_vnode\t*iptr;\n\n\tif ((vnode_name == NULL) || (part == NULL)) {\n\t\tlog_err(-1, __func__, \"either vnode_name is NULL or part is NULL!\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->vnode_name, vnode_name) == 0) {\n\t\t\t(void)strdup_cat(&iptr->part_list, part);\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_vnode_create(vnode_name);\n\n\tif (iptr == NULL)\n\t\treturn (head);\n\n\tiptr->nextptr = head;\n\n\tiptr->part_list = (char *)malloc((size_t)strlen(part)+1);\n\tif (iptr->part_list == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->part_list, part);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tfrees the vnode from list\n *\n * @param[in] head - pointer to bgl_vnode structure\n *\n * @return\tVoid\n *\n */\n\nvoid\nbgl_vnode_free(struct bgl_vnode *head)\n{\n\tstruct bgl_vnode\t*iptr, *tptr;\n\n\ttptr = NULL;\n\tfor (iptr=head; iptr; iptr=tptr) {\n\t\ttptr = iptr->nextptr;\n\t\tif (iptr->vnode_name) {\n\t\t\t(void)free(iptr->vnode_name);\n\t\t}\n\n\t\tif (iptr->part_list) {\n\t\t\t(void)free(iptr->part_list);\n\t\t}\n\t\t(void)free(iptr);\n\t}\n}\n\n/**\n * @brief\n *\tprints the vnode list\n *\n * @param[in] head - pointer to bgl_vnode structure\n *\n * @return      Void\n *\n */\n\nvoid\nbgl_vnode_print(struct bgl_vnode *head)\n{\n\tstruct bgl_vnode\t*iptr;\n\tint\t\t\ti;\n\n\ti=0;\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tsprintf(log_buffer,\n\t\t\t\"[%d]vnode_name=%s state=%d num_cnodes=%d amt_mem=%lu part_list=%s\",\n\t\t\ti, (iptr->vnode_name?iptr->vnode_name:\"null\"),\n\t\t\tiptr->state, iptr->num_cnodes, iptr->amt_mem,\n\t\t\t(iptr->part_list?iptr->part_list:\"null\"));\n\t\tlog_err(0, __func__, log_buffer);\n\t\ti++;\n\t}\n}\n\n/************ end of bgl_vnode functions ********************************/\n\n\n/*********************************************************************/\n/************* bgl_job functions *************************************/\n/*********************************************************************/\n\n/**\n * @brief\n *\tcreates job id for bgl job\n *\n * @param[in] bgl_jobid - job id\n *\n * @return\tstructure handle\n * @retval\tstructure handle to bgl_job\tSuccess\n * @retval\tNULL\t\t\t\tError\n *\n */\n\nstruct bgl_job *\nbgl_job_create_given_bgl_jobid(db_job_id_t bgl_jobid)\n{\n\tstruct bgl_job\t*iptr = NULL;\n\n\tif (bgl_jobid == -1) {\n\t\tlog_err(-1, __func__, \"bgl_jobid is -1\");\n\t\treturn NULL;\n\t}\n\n\tiptr = (struct bgl_job *)malloc(sizeof(struct bgl_job));\n\tif (iptr == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tiptr->partition = NULL;\n\tiptr->pbs_jobid = NULL;\n\tiptr->nextptr = NULL;\n\n\tiptr->bgl_jobid = bgl_jobid;\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *      creates pbs job id for bgl job\n *\n * @param[in] pbs_jobid - job id\n *\n * @return      structure handle\n * @retval      structure handle to bgl_job     Success\n * @retval      NULL                            Error\n *\n */\n\nstruct bgl_job *\nbgl_job_create_given_pbs_jobid(char *pbs_jobid)\n{\n\tstruct bgl_job\t*iptr = NULL;\n\n\tif (pbs_jobid == NULL) {\n\t\tlog_err(-1, __func__, \"pbs_jobid is NULL!\");\n\t\treturn NULL;\n\t}\n\n\tiptr = (struct bgl_job *)malloc(sizeof(struct bgl_job));\n\tif (iptr == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tiptr->partition = NULL;\n\tiptr->bgl_jobid = -1;\n\tiptr->nextptr = NULL;\n\n\tiptr->pbs_jobid = (char *)malloc((size_t)strlen(pbs_jobid)+1);\n\tif (iptr->pbs_jobid == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->pbs_jobid, pbs_jobid);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\treturns the partition for bgl job(bgl_jobid)\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] bgl_jobid - job id\n *\n * @return\tstring\n * @retval\tpartition\tSuccess\n * @retval\tNULL\t\tError\n *\n */\nchar *\nbgl_job_get_partition_given_bgl_jobid(struct bgl_job *head,\n\tdb_job_id_t bgl_jobid)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif (bgl_jobid == -1) {\n\t\tlog_err(-1, __func__, \"bgl_jobid is -1\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->bgl_jobid == bgl_jobid) {\n\t\t\treturn (iptr->partition);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief\n *      returns the partition for pbs job (pbs_jobid)\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] pbs_jobid - job id\n *\n * @return      string\n * @retval      partition       Success\n * @retval      NULL            Error\n *\n */\n\nchar *\nbgl_job_get_partition_given_pbs_jobid(struct bgl_job *head, char *pbs_jobid)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif (pbs_jobid == NULL) {\n\t\tlog_err(-1, __func__, \"pbs_jobid is NULL\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->pbs_jobid &&\n\t\t\t(strcmp(iptr->pbs_jobid, pbs_jobid) == 0)) {\n\t\t\treturn (iptr->partition);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief\n *\treturns the gbl jobid in partition\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] part - partition\n *\n * @return\tdb_job_id_t\n * @retval\tbgl jobid\tSuccess\n * @retval\t-1\t\tError\n *\n */\n\ndb_job_id_t\nbgl_job_get_bgl_jobid(struct bgl_job *head, char *part)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif (part == NULL) {\n\t\tlog_err(-1, __func__, \"part is NULL\");\n\t\treturn (-1);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->partition &&\n\t\t\tstrcmp(iptr->partition, part) == 0) {\n\t\t\treturn (iptr->bgl_jobid);\n\t\t}\n\t}\n\treturn (-1);\n}\n\n/**\n * @brief\n *      returns the pbs jobid in partition\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] part - partition\n *\n * @return      db_job_id_t\n * @retval      pbs jobid       Success\n * @retval      -1              Error\n *\n */\n\nchar *\nbgl_job_get_pbs_jobid(struct bgl_job *head, char *part)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif (part == NULL) {\n\t\tlog_err(-1, __func__, \"part is NULL\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->partition &&\n\t\t\tstrcmp(iptr->partition, part) == 0) {\n\t\t\treturn (iptr->pbs_jobid);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_job_create_given_jobid() is not called\n * \tfirst. Be sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] bgl_jobid - bgl jobid\n * @param[in]  part - partition\n *\n * @return\tstructure handle\n * @retval\tstructure handle to bgl_job\t\t\t\tif exists\n * @retval\tcreate and return structure handle to bgl_job\t\tif not exists\n *\n */\nstruct bgl_job *\nbgl_job_put_partition_given_bgl_jobid(struct bgl_job *head,\n\tdb_job_id_t bgl_jobid, char *part)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif ((bgl_jobid == -1) || (part == NULL)) {\n\t\tlog_err(-1, __func__, \"either bgl_jobid is -1 or part is NULL\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (iptr->bgl_jobid == bgl_jobid) {\n\t\t\t(void)strdup_cat(&iptr->partition, part);\n\t\t\treturn (head);\n\t\t}\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_job_create_given_bgl_jobid(bgl_jobid);\n\n\tif (iptr == NULL) {\n\t\treturn (head);\n\t}\n\tiptr->nextptr = head;\n\n\tiptr->partition = (char *)malloc((size_t)strlen(part)+1);\n\tif (iptr->partition == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->partition, part);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_job_create_given_jobid() is not called\n * \tfirst. Be sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] pbs_jobid - pbs jobid\n * @param[in]  part - partition\n *\n * @return      structure handle\n * @retval      structure handle to bgl_job                             if exists\n * @retval      create and return structure handle to bgl_job           if not exists\n *\n */\n\nstruct bgl_job *\nbgl_job_put_partition_given_pbs_jobid(struct bgl_job *head, char *pbs_jobid,\n\tchar *part)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif ((pbs_jobid == NULL) || (part == NULL)) {\n\t\tlog_err(-1, __func__, \"either pbs_jobid is NULL or part is NULL\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (iptr->pbs_jobid &&\n\t\t\t(strcmp(iptr->pbs_jobid, pbs_jobid) == 0)) {\n\t\t\t(void)strdup_cat(&iptr->partition, part);\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_job_create_given_pbs_jobid(pbs_jobid);\n\n\tif (iptr == NULL) {\n\t\treturn (head);\n\t}\n\tiptr->nextptr = head;\n\n\tiptr->partition = (char *)malloc((size_t)strlen(part)+1);\n\tif (iptr->partition == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->partition, part);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_job_create_given_jobid() is not called\n * \tfirst. Be sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_job structure\n * @param[in] pbs_jobid - pbs jobid\n * @param[in]  part - partition\n *\n * @return      structure handle\n * @retval      structure handle to bgl_job                             if exists\n * @retval      create and return structure handle to bgl_job           if not exists\n *\n */\n\nstruct bgl_job *\nbgl_job_put_pbs_jobid(struct bgl_job *head, char *part, char *pbs_jobid)\n{\n\tstruct bgl_job\t*iptr;\n\n\tif ((part == NULL) || (pbs_jobid == NULL)) {\n\t\tlog_err(-1, __func__, \"either part is NULL or pbs_jobid is NULL\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (iptr->partition && (strcmp(iptr->partition, part) == 0)) {\n\n\t\t\tif (iptr->pbs_jobid != NULL) {\n\t\t\t\t(void)free(iptr->pbs_jobid);\n\t\t\t}\n\t\t\tiptr->pbs_jobid = \\\n\t\t\t\t(char *)malloc((size_t)strlen(pbs_jobid)+1);\n\t\t\tif (iptr->pbs_jobid == NULL) {\n\t\t\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\t\t\treturn (head);\n\t\t\t}\n\t\t\tstrcpy(iptr->pbs_jobid, pbs_jobid);\n\t\t\treturn (head);\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_job_create_given_pbs_jobid(pbs_jobid);\n\n\tif (iptr == NULL) {\n\t\treturn (head);\n\t}\n\tiptr->nextptr = head;\n\n\tiptr->partition = (char *)malloc((size_t)strlen(part)+1);\n\tif (iptr->partition == NULL) {\n\t\tlog_err(errno, __func__, \"2nd malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->partition, part);\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tfrees the job from list\n *\n * @param[in] head - pointer to bgl_job structure\n *\n * @return\tVoid\n *\n */\n\nvoid\nbgl_job_free(struct bgl_job *head)\n{\n\tstruct bgl_job\t*iptr, *tptr;\n\n\ttptr = NULL;\n\tfor (iptr=head; iptr; iptr=tptr) {\n\t\ttptr = iptr->nextptr;\n\t\tif (iptr->pbs_jobid) {\n\t\t\t(void)free(iptr->pbs_jobid);\n\t\t}\n\t\tif (iptr->partition) {\n\t\t\t(void)free(iptr->partition);\n\t\t}\n\t\t(void)free(iptr);\n\t}\n}\n\n/**\n * @brief\n *      prints the job list\n *\n * @param[in] head - pointer to bgl_job structure\n *\n * @return      Void\n *\n */\n\nvoid\nbgl_job_print(struct bgl_job *head)\n{\n\tstruct bgl_job\t*iptr;\n\tint\t\ti;\n\n\ti=0;\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tsprintf(log_buffer,\n\t\t\t\"[%d](bgl=%d,pbs=%s): partition=%s\", i,\n\t\t\tiptr->bgl_jobid,\n\t\t\t(iptr->pbs_jobid?iptr->pbs_jobid:\"null\"),\n\t\t\t(iptr->partition?iptr->partition:\"null\"));\n\t\tlog_err(0, __func__, log_buffer);\n\t\ti++;\n\t}\n}\n/************ end of bgl_job functions ********************************/\n\n/********************************************************************/\n/********  bgl_partition functions **************************************/\n/********************************************************************/\n\n/**\n * @brief\n *\tcreates bgl partition\n *\n * @param[in] part_name - partition name\n *\n * @return\tstructure handle\n * @retval\tstructure handle to bgl_partition\tSuccess\n * @retval\tNULL\t\t\t\t\tError\n *\n */\n\nstruct bgl_partition *\nbgl_partition_create(char *part_name)\n{\n\tstruct bgl_partition\t*iptr = NULL;\n\n\tif (part_name == NULL) {\n\t\tlog_err(-1, __func__, \"part_name is NULL\");\n\t\treturn NULL;\n\t}\n\n\tiptr = (struct bgl_partition *)malloc(sizeof(struct bgl_partition));\n\tif (iptr == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tiptr->nextptr = NULL;\n\n\tiptr->part_name = (char *)malloc((size_t)strlen(part_name)+1);\n\tif (iptr->part_name == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\treturn (iptr);\n\t}\n\tstrcpy(iptr->part_name, part_name);\n\tiptr->num_cnodes = 0;\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\tReturns the head of list - if bgl_partition_create() is not called first,\n * \tbe sure to call this with a NULL head\n *\n * @param[in] head - pointer to bgl_partition structure\n * @param[in] part_name - partition name\n *\n * @return\tstructure handle\n * @retval\tstructure handle to bgl_partition\t\t\tif partition list exists\n * @retval\tcreate and return structure handle to bgl_partition\tif partition list doesn exist\n *\n */\n\nstruct bgl_partition *\nbgl_partition_put_part_name(struct bgl_partition *head, char *part_name)\n{\n\tstruct bgl_partition\t*iptr;\n\n\tif (part_name == NULL) {\n\t\tlog_err(-1, __func__, \"part_name is NULL\");\n\t\treturn (head);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->part_name, part_name) == 0) {\n\t\t\treturn (head);\t/* already in list */\n\t\t}\n\n\t}\n\t/* no entry found, so create one */\n\tiptr = bgl_partition_create(part_name);\n\n\tif (iptr == NULL) {\n\t\treturn (head);\n\t}\n\tiptr->nextptr = head;\n\n\treturn (iptr);\n}\n\n/**\n * @brief\n *\treturns the number of cpus for partition\n *\n * @param[in] head - pointer to bgl_partition structure\n * @param[in] part_name - partition name\n *\n * @return\tint\n * @retval\tnumber of cpus\t\tSuccess\n * @retval\t0\t\t\tError\n *\n */\nint\nbgl_partition_get_num_cnodes(struct bgl_partition *head, char *part_name)\n{\n\tstruct bgl_partition *iptr;\n\n\tif (part_name == NULL) {\n\t\tlog_err(-1, __func__, \"part_name is NULL\");\n\t\treturn (0);\n\t}\n\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\n\t\tif (strcmp(iptr->part_name, part_name) == 0) {\n\t\t\treturn (iptr->num_cnodes);\n\t\t}\n\n\t}\n\treturn (0);\n}\n\n/**\n * @brief\n *\tfrees the partitions from list\n *\n * @param[in] head - pointer to bgl_partition structure\n *\n * @return\tVoid\n *\n */\n\nvoid\nbgl_partition_free(struct bgl_partition *head)\n{\n\tstruct bgl_partition\t*iptr, *tptr;\n\n\tfor (iptr=head; iptr; iptr=tptr) {\n\t\ttptr = iptr->nextptr;\n\t\tif (iptr->part_name) {\n\t\t\t(void)free(iptr->part_name);\n\t\t}\n\t\t(void)free(iptr);\n\t}\n}\n\n/**\n * @brief\n *\tprints the partitions in list\n *\n * @param[in] head - pointer to bgl_partition structure\n *\n * @return\tVoid\n *\n */\n\nvoid\nbgl_partition_print(struct bgl_partition *head)\n{\n\tstruct bgl_partition\t*iptr;\n\tint\t\t\ti;\n\n\ti=0;\n\tfor (iptr=head; iptr; iptr=iptr->nextptr) {\n\t\tsprintf(log_buffer, \"[%d](part=%s num_cnodes=%d)\", i,\n\t\t\t(iptr->part_name?iptr->part_name:\"null\"), iptr->num_cnodes);\n\t\tlog_err(0, __func__, log_buffer);\n\t\ti++;\n\t}\n}\n\n/**\n * @brief\n *\tcopies and returns appropriate error message depending on stat\n *\n * @param[in] stat - status\n *\n * @return \tstring\n * @retval\terror string\tSuccess\n *\n */\nstatic char *\nbglerror_to_txt(status_t stat)\n{\n\tstatic char\terror_str[80];\n\n\tswitch (stat) {\n\t\tcase PARTITION_NOT_FOUND:\n\t\t\tstrcpy(error_str, \"error PARTITION_NOT_FOUND\");\n\t\t\tbreak;\n\t\tcase JOB_NOT_FOUND:\n\t\t\tstrcpy(error_str, \"error JOB_NOT_FOUND\");\n\t\t\tbreak;\n\t\tcase BP_NOT_FOUND:\n\t\t\tstrcpy(error_str, \"error BP_NOT_FOUND\");\n\t\t\tbreak;\n\t\tcase SWITCH_NOT_FOUND:\n\t\t\tstrcpy(error_str, \"error SWITCH_NOT_FOUND\");\n\t\t\tbreak;\n\t\tcase JOB_ALREADY_DEFINED:\n\t\t\tstrcpy(error_str, \"error JOB_ALREADY_DEFINED\");\n\t\t\tbreak;\n\t\tcase CONNECTION_ERROR:\n\t\t\tstrcpy(error_str, \"error CONNECTION_ERROR\");\n\t\t\tbreak;\n\t\tcase INTERNAL_ERROR:\n\t\t\tstrcpy(error_str, \"error INTERNAL_ERROR\");\n\t\t\tbreak;\n\t\tcase INVALID_INPUT:\n\t\t\tstrcpy(error_str, \"error INVALID_INPUT\");\n\t\t\tbreak;\n\t\tcase INCOMPATIBLE_STATE:\n\t\t\tstrcpy(error_str, \"error INCOMPATIBLE_STATE\");\n\t\t\tbreak;\n\t\tcase INCONSISTENT_DATA:\n\t\t\tstrcpy(error_str, \"error INCONSISTENT_STATE\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(error_str, \"error %d\", stat);\n\t}\n\n\treturn (error_str);\n}\n\n/**\n * @brief\n *\tcopies and returns the state of partition\n *\n * @param[in] state - state of partition\n *\n * @return\tstring\n * @retval\tstate of partition\tSuccess\n *\n */\nstatic\nchar *\npstate_to_txt(rm_partition_state_t state)\n{\n\tstatic char state_str[80];\n\n\tswitch (state) {\n\t\tcase RM_PARTITION_FREE:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_FREE\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_CONFIGURING:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_CONFIGURING\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_READY:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_READY\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_BUSY:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_BUSY\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_DEALLOCATING:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_DEALLOCATING\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_ERROR:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_ERROR\");\n\t\t\tbreak;\n\t\tcase RM_PARTITION_NAV:\n\t\t\tstrcpy(state_str, \"RM_PARTITION_NAV (no state)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(state_str, \"unkown pstate %d\", state);\n\t}\n\n\treturn (state_str);\n}\n\n/**\n * @brief\n *      copies and returns the state of base partition\n *\n * @param[in] state - state of base partition\n *\n * @return      string\n * @retval      state of base partition      Success\n *\n */\n\nstatic\nchar *\nbpstate_to_txt(rm_BP_state_t state)\n{\n\tstatic char state_str[80];\n\n\tswitch (state) {\n\t\tcase RM_BP_UP:\n\t\t\tstrcpy(state_str, \"RM_BP_UP\");\n\t\t\tbreak;\n\t\tcase RM_BP_DOWN:\n\t\t\tstrcpy(state_str, \"RM_BP_DOWN\");\n\t\t\tbreak;\n\t\tcase RM_BP_MISSING:\n\t\t\tstrcpy(state_str, \"RM_BP_MISSING\");\n\t\t\tbreak;\n\t\tcase RM_BP_ERROR:\n\t\t\tstrcpy(state_str, \"RM_BP_ERROR\");\n\t\t\tbreak;\n\t\tcase RM_BP_NAV:\n\t\t\tstrcpy(state_str, \"RM_BP_NAV\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(state_str, \"unknown bpstate %d\", state);\n\t}\n\n\treturn (state_str);\n}\n\n/**\n * @brief\n *      copies and returns the state of node card\n *\n * @param[in] state - state of node card\n *\n * @return      string\n * @retval      state of node card     Success\n *\n */\n\nstatic\nchar *\nncstate_to_txt(rm_nodecard_state_t state)\n{\n\tstatic char state_str[80];\n\n\tswitch (state) {\n\t\tcase RM_NODECARD_UP:\n\t\t\tstrcpy(state_str, \"RM_NODECARD_UP\");\n\t\t\tbreak;\n\t\tcase RM_NODECARD_DOWN:\n\t\t\tstrcpy(state_str, \"RM_NODECARD_DOWN\");\n\t\t\tbreak;\n\t\tcase RM_NODECARD_MISSING:\n\t\t\tstrcpy(state_str, \"RM_NODECARD_MISSING\");\n\t\t\tbreak;\n\t\tcase RM_NODECARD_ERROR:\n\t\t\tstrcpy(state_str, \"RM_NODECARD_ERROR\");\n\t\t\tbreak;\n\t\tcase RM_NODECARD_NAV:\n\t\t\tstrcpy(state_str, \"RM_NODECARD_NAV\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(state_str, \"unknown ncstate %d\", state);\n\t}\n\n\treturn (state_str);\n}\n/************ end of bgl_partition functions **********************************/\n\n/**\n * @brief\n *\tgenerate_bglvnodes_from_partitions: returns the list of vnodes found\n *\twhen canvassing the partitions existing on the system.\n *\n * @retrun \tstructure handle\n * @retval\ta pointer to the bgl_vnode structure which must later be freed\t\tSuccess\n *\t\twith \"bgl_vnode_free()\"\n * @retval\tNULL\t\t\t\t\t\t\t\t\tError\n *\n */\nstruct bgl_vnode *\ngenerate_bglvnodes_from_partitions(void)\n{\n\tint st;\n\tstruct bgl_vnode\t*vparts = NULL;\n\trm_partition_list_t\t*part_list = NULL;\n\tint\t\t\ti, j, num_parts;\n\trm_element_t\t\t*part = NULL;\n\tpm_partition_id_t\tpart_id;\n\trm_element_t\t\t*bp;\n\trm_bp_id_t\t\tbp_id;\n\trm_BP_state_t\t\tbp_state;\n\trm_partition_state_t\tpart_state;\n\tint\t\t\tpart_num_bps;\n\tint\t\t\tpart_is_small = 0;\t/* must init to 0 */\n\t/* only updates to */\n\t/* non-zero if small */\n\tint\t\t\tpart_num_nodecards;\n\trm_nodecard_t\t\t*ncard;\n\trm_quarter_t\t\tncard_q;\n\trm_nodecard_state_t\tncard_state;\n\trm_nodecard_id_t\tncard_id;\n\tchar\t\t\tvnode_name[PBS_MAXNODENAME+1];\n\tchar\t\t\t*part_user;\n\tchar\t\t\t*part_descr;\n\n\tif ((st=rm_get_partitions(PARTITION_ALL_FLAG,\n\t\t&part_list)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_partitions: %s\",\n\t\t\tbglerror_to_txt(st));\n\t\tlog_err(errno, __func__, log_buffer);\n\n\t\treturn NULL;\n\t}\n\n\trm_get_data(part_list, RM_PartListSize, &num_parts);\n\n\tfor (i=0; i < num_parts; i++) {\n\t\tif (i == 0) {\n\t\t\trm_get_data(part_list, RM_PartListFirstPart, &part);\n\t\t} else {\n\t\t\trm_get_data(part_list, RM_PartListNextPart, &part);\n\t\t}\n\n\t\trm_get_data(part, RM_PartitionID, &part_id);\n\t\trm_get_data(part, RM_PartitionState, &part_state);\n\t\trm_get_data(part, RM_PartitionUserName, &part_user);\n\t\trm_get_data(part, RM_PartitionDescription, &part_descr);\n\n\n\t\tif (part_state == RM_PARTITION_ERROR)\n\t\t\tcontinue;\n\n\t\trm_get_data(part, RM_PartitionBPNum, &part_num_bps);\n\t\trm_get_data(part, RM_PartitionSmall, &part_is_small);\n\t\tif (part_is_small) {\t/* made up of nodecards */\n\n\t\t\trm_get_data(part, RM_PartitionFirstBP, &bp);\n\n\t\t\trm_get_data(bp, RM_BPID, &bp_id);\n\t\t\trm_get_data(bp, RM_BPState, &bp_state);\n\n\t\t\tif (bp_state != RM_BP_UP)\n\t\t\t\tcontinue;\n\n\t\t\trm_get_data(part, RM_PartitionNodeCardNum,\n\t\t\t\t&part_num_nodecards);\n\t\t\tfor (j=0; j < part_num_nodecards; j++) {\n\t\t\t\tif (j == 0)\n\t\t\t\t\trm_get_data(part,\n\t\t\t\t\t\tRM_PartitionFirstNodeCard, &ncard);\n\t\t\t\telse\n\t\t\t\t\trm_get_data(part,\n\t\t\t\t\t\tRM_PartitionNextNodeCard, &ncard);\n\n\t\t\t\trm_get_data(ncard, RM_NodeCardID, &ncard_id);\n\t\t\t\trm_get_data(ncard, RM_NodeCardState,\n\t\t\t\t\t&ncard_state);\n\t\t\t\trm_get_data(ncard, RM_NodeCardQuarter, &ncard_q);\n\n\t\t\t\tif (ncard_state != RM_NODECARD_UP)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsprintf(vnode_name, \"%s[%s%s%d%s%s]\",\n\t\t\t\t\tmom_short_name, bp_id,\n\t\t\t\t\tCARD_DELIM, ncard_q, CARD_DELIM, ncard_id);\n\t\t\t\tvparts=bgl_vnode_put_part_list(vparts,\n\t\t\t\t\tvnode_name, part_id);\n\n\t\t\t}\n\t\t} else {\t/* made up of BPs */\n\t\t\tfor (j=0; j < part_num_bps; j++) {\n\t\t\t\tif (j == 0)\n\t\t\t\t\trm_get_data(part,\n\t\t\t\t\t\tRM_PartitionFirstBP, &bp);\n\t\t\t\telse\n\t\t\t\t\trm_get_data(part,\n\t\t\t\t\t\tRM_PartitionNextBP, &bp);\n\n\t\t\t\trm_get_data(bp, RM_BPState, &bp_state);\n\t\t\t\tif (bp_state != RM_BP_UP)\n\t\t\t\t\tcontinue;\n\t\t\t\trm_get_data(bp, RM_BPID, &bp_id);\n\t\t\t\tsprintf(vnode_name, \"%s[%s]\", mom_short_name,\n\t\t\t\t\tbp_id);\n\t\t\t\tvparts=bgl_vnode_put_part_list(vparts,\n\t\t\t\t\tvnode_name, part_id);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\trm_free_partition_list(part_list);\n\treturn (vparts);\n}\n\n/**\n * @brief\n *\tgenerate_bglvnodes_from_system: generates the list of vnodes and their\n *\tproperties (# of cnodes, mem, list of partitions spanning the vnode)\n *\tfound in the   system (what the real hardware provides).\n *\n * @return\tstructure handle\n * @retval\tpointer to struct bgl_vnode\n *\n */\n\nstruct bgl_vnode *\ngenerate_bglvnodes_from_system(void)\n{\n\n\tstatus_t\t\tst;\n\trm_BGL_t\t\t*bgl = NULL;\n\trm_size3D_t\t\tbp_size;\n\tint\t\t\tnum_bps;\n\trm_element_t\t\t*bp;\n\trm_bp_id_t\t\tbp_id;\n\trm_BP_state_t\t\tbp_state;\n\tint\t\t\tbp_used_by_busy_smallp = 0;\n\tint\t\t\tbp_used_by_free_smallp = 0;\n\trm_nodecard_list_t\t*nc_list;\n\tint\t\t\tcnodes_per_bp;\n\tint                    cnodes_per_ncard;\n\tulong\t\t\tmem_per_bp;\n\tint\t\t\tcpus_per_bp;\n\tint\t\t\tnum_ncards;\n\tint\t\t\tnum_cnodes;\n\tint\t\t\tnum_cpus;\n\tulong\t\t\tamt_mem;\n\trm_nodecard_t\t\t*ncard;\n\trm_quarter_t\t\tncard_q;\n\trm_nodecard_state_t\tncard_state;\n\trm_nodecard_id_t\tncard_id;\n\tchar\t\t\tvnode_name[PBS_MAXNODENAME+1];\n\tchar\t\t\tbpid_vnode_name[PBS_MAXNODENAME+1];\n\tint\t\t\ti, j;\n\tchar\t\t\t*plist;\n\tstruct bgl_vnode\t*bglvnodes_p = NULL;/* vnodes with partitions*/\n\tstruct bgl_vnode\t*bglvns = NULL;\n\tint\t\t\tfound_reserve = 0;\n\tstruct bgl_partition    *bjparts = NULL;\n\n\n\tif (bglpartitions != NULL) {\n\t\tbgl_partition_free(bglpartitions);\n\t\tbglpartitions = NULL;\n\t}\n\n\tbglvnodes_p = generate_bglvnodes_from_partitions();\n\tif (bglvnodes_p == NULL) {\n\t\tlog_err(-1, __func__,\n\t\t\t\"FATAL: No working BGL partitions exist! No jobs will run. Please create partitions using genfullblock/gensmallblock\");\n\t\treturn NULL;\n\t}\n\n\tif ((st=rm_get_BGL(&bgl)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_BGL: %s\", bglerror_to_txt(st));\n\t\tlog_err(errno, __func__, log_buffer);\n\n\t\tbgl_partition_free(bglpartitions);\n\t\tbglpartitions = NULL;\n\n\t\treturn NULL;\n\t}\n\n\trm_get_data(bgl, RM_BPsize, &bp_size);\n\n\tcnodes_per_bp = bp_size.X * bp_size.Y * bp_size.Z;\n\tcpus_per_bp = cnodes_per_bp*CPUS_PER_CNODE;\n\tmem_per_bp = cnodes_per_bp*MEM_PER_CNODE;\n\n\trm_get_data(bgl, RM_BPNum, &num_bps);\n\n\tfor (i=0; i < num_bps; i++) {\n\t\tif (i == 0)\n\t\t\trm_get_data(bgl, RM_FirstBP, &bp);\n\t\telse\n\t\t\trm_get_data(bgl, RM_NextBP, &bp);\n\n\t\trm_get_data(bp, RM_BPID, &bp_id);\n\t\trm_get_data(bp, RM_BPState, &bp_state);\n\t\trm_get_data(bp, RM_BPSDB, &bp_used_by_busy_smallp);\n\t\trm_get_data(bp, RM_BPSD, &bp_used_by_free_smallp);\n\n\t\tif (bp_used_by_free_smallp || bp_used_by_busy_smallp) {\n\n\t\t\tif (rm_get_nodecards(bp_id, &nc_list) == STATUS_OK) {\n\t\t\t\trm_get_data(nc_list, RM_NodeCardListSize, &num_ncards);\n\n\t\t\t\tnum_cnodes = cnodes_per_bp/num_ncards;\n\t\t\t\tcnodes_per_ncard  = num_cnodes;\n\t\t\t\tnum_cpus = num_cnodes*CPUS_PER_CNODE;\n\t\t\t\tamt_mem = num_cnodes*MEM_PER_CNODE;\n\n\t\t\t\tfor (j=0; j < num_ncards; j++) {\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\trm_get_data(nc_list,\n\t\t\t\t\t\t\tRM_NodeCardListFirst, &ncard);\n\t\t\t\t\telse\n\t\t\t\t\t\trm_get_data(nc_list,\n\t\t\t\t\t\t\tRM_NodeCardListNext, &ncard);\n\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardID, &ncard_id);\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardState,\n\t\t\t\t\t\t&ncard_state);\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardQuarter, &ncard_q);\n\n\t\t\t\t\tsprintf(vnode_name, \"%s[%s%s%d%s%s]\",\n\t\t\t\t\t\tmom_short_name, bp_id,\n\t\t\t\t\t\tCARD_DELIM, ncard_q, CARD_DELIM, ncard_id);\n\n\t\t\t\t\tbglvns = bgl_vnode_put_num_cnodes(bglvns,\n\t\t\t\t\t\tvnode_name, num_cnodes);\n\n\t\t\t\t\tbglvns = bgl_vnode_put_amt_mem(bglvns,\n\t\t\t\t\t\tvnode_name, amt_mem);\n\n\t\t\t\t\tsprintf(bpid_vnode_name, \"%s[%s]\",\n\t\t\t\t\t\tmom_short_name, bp_id);\n\t\t\t\t\tplist = bgl_vnode_get_part_list_spanning_vnode(\\\n\t\t\t\t\tbglvnodes_p, vnode_name,\n\t\t\t\t\t\tbpid_vnode_name);\n\n\t\t\t\t\tfound_reserve = 0;\n\t\t\t\t\tif (plist != NULL) {\n\t\t\t\t\t\tchar *p2;\n\n\t\t\t\t\t\tbglvns = bgl_vnode_put_part_list(bglvns,\n\t\t\t\t\t\t\tvnode_name, plist);\n\n\t\t\t\t\t\t/* safe to modify plist here */\n\t\t\t\t\t\t/* since we've save it in bglvns */\n\t\t\t\t\t\tp2 = strtok(plist, \", \");\n\n\t\t\t\t\t\twhile (p2 != NULL) { /* each part */\n\t\t\t\t\t\t\tif (in_string_list(p2,\n\t\t\t\t\t\t\t\treserve_bglpartitions)) {\n\t\t\t\t\t\t\t\tsprintf(log_buffer, \"Marked vnode %s as RESERVED since it is part of reserve partition %s\", vnode_name, p2);\n\t\t\t\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0,\n\t\t\t\t\t\t\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\t\t\t\t\t\t\tfound_reserve = 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbglpartitions = \\\n\t\t\t\t\t\tbgl_partition_put_part_name(\\\n\t\t\t\t\t\t\tbglpartitions,\n\t\t\t\t\t\t\t\t\tp2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp2 = strtok(NULL, \", \");\n\t\t\t\t\t\t} /* while */\n\n\n\t\t\t\t\t\t(void)free(plist);\n\n\t\t\t\t\t}\n\t\t\t\t\tif (found_reserve) {\n\t\t\t\t\t\tbgl_vnode_put_state(bglvns, vnode_name,\n\t\t\t\t\t\t\tBGLVN_RESERVE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbgl_vnode_put_state(bglvns, vnode_name,\n\t\t\t\t\t\t\tBGLVN_FREE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(vnode_name, \"%s[%s]\", mom_short_name, bp_id);\n\n\t\t\tbglvns = bgl_vnode_put_num_cnodes(bglvns,\n\t\t\t\tvnode_name, cnodes_per_bp);\n\n\t\t\tbglvns = bgl_vnode_put_amt_mem(bglvns,\n\t\t\t\tvnode_name, mem_per_bp);\n\n\t\t\tplist = bgl_vnode_get_part_list_spanning_vnode(\\\n\t\t\t\t\t\tbglvnodes_p, vnode_name, NULL);\n\n\t\t\tbgl_vnode_put_state(bglvns, vnode_name, BGLVN_FREE);\n\n\t\t\tfound_reserve = 0;\n\t\t\tif (plist != NULL) {\n\t\t\t\tchar *p2;\n\n\t\t\t\tbglvns = bgl_vnode_put_part_list(bglvns,\n\t\t\t\t\tvnode_name, plist);\n\n\t\t\t\t/* safe to modify plist here since we've */\n\t\t\t\t/* already saved it in bglvns */\n\t\t\t\tp2 = strtok(plist, \", \");\n\n\t\t\t\twhile (p2 != NULL) {\n\n\t\t\t\t\tif (in_string_list(p2,\n\t\t\t\t\t\treserve_bglpartitions)) {\n\t\t\t\t\t\tsprintf(log_buffer, \"Will mark vnode %s as RESERVED since it is part of reserve partition %s\", vnode_name, p2);\n\t\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0,\n\t\t\t\t\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\t\t\t\t\tfound_reserve = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbglpartitions = \\\n\t\t\t\t\t\tbgl_partition_put_part_name(\\\n\t\t\t\t\t\t\tbglpartitions,\n\t\t\t\t\t\t\tp2);\n\t\t\t\t\t}\n\n\t\t\t\t\tp2 = strtok(NULL, \", \");\n\t\t\t\t} /* while */\n\t\t\t\t(void)free(plist);\n\t\t\t}\n\t\t\tif (found_reserve) {\n\t\t\t\tbgl_vnode_put_state(bglvns, vnode_name,\n\t\t\t\t\tBGLVN_RESERVE);\n\t\t\t} else {\n\t\t\t\tbgl_vnode_put_state(bglvns, vnode_name,\n\t\t\t\t\tBGLVN_FREE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* got here means everything's okay */\n\trm_free_BGL(bgl);\n\tbgl_vnode_free(bglvnodes_p);\n\n\t/* cache the sizes of the partitions to be used later */\n\t/* FUTURE: may not need to do this, if we can just evaluate */\n\t/* the exec_vnode string assigned to the job for a list of  */\n\t/* vnodes and determine their total sizes */\n\tfor (bjparts=bglpartitions; bjparts; bjparts=bjparts->nextptr) {\n\t\tif (bjparts->part_name) {\n\t\t\tbjparts->num_cnodes = get_bgl_partition_size(\\\n\t\t\t\tbjparts->part_name, cnodes_per_bp, cnodes_per_ncard);\n\t\t}\n\t}\n\n\treturn (bglvns);\n\n}\n\n/**\n * @brief\n *\tuniquify_part_list: given a list of real partition names,\"part1, part2, ..., partN\",\n *\n * @param[in] part_list - partition list\n *\n * @return\tstring\n * @retval\tnew malloced list that \"uniquifies\" each partition name as follows:\n *\t\t\"<mom_short_name>-part1,<mom_short_name>-part2,...,<mom_short_name>-partN\"\n * @retval\tNULL\tError\n *\n */\nstatic char *\nuniquify_part_list(char *part_list)\n{\n\tchar *plist;\n\tchar *pl;\n\tchar *plist2;\n\tint i, num_parts;\n\tint\t\tmom_host_len = strlen(mom_short_name);\n\tint\t\tpart_list_len = 0;\n\n\tif ((part_list == NULL) || (part_list[0] == '\\0'))\n\t\treturn NULL;\n\n\tpart_list_len = strlen(part_list);\n\t/* Get # of partitions */\n\tnum_parts = 0;\n\tfor (i=0; i < part_list_len; i++) {\n\t\tif (part_list[i] == ',')\n\t\t\tnum_parts++;\n\t}\n\tnum_parts++;\t/* # of commas + 1 */\n\n\n\tplist = strdup(part_list);\n\n\tif (plist == NULL) {\n\t\tlog_err(errno, __func__, \"strdup failed!\");\n\t\treturn NULL;\n\t}\n\n\t/* size accounts for '-', extra ',', ' ', and '\\0' */\n\tplist2=malloc(part_list_len+((mom_host_len+3)*num_parts)+1);\n\n\tif (plist2 == NULL) {\n\t\tlog_err(errno, __func__, \"malloc failed!\");\n\t\t(void)free(plist);\n\t\treturn NULL;\n\t}\n\n\tpl = strtok(plist, \", \");\n\ti = 0;\n\tplist2[0] = '\\0';\n\twhile (pl) {\n\n\t\tif (i != 0)\n\t\t\tstrcat(plist2, \", \");\n\n\t\tstrcat(plist2, mom_short_name);\n\t\tstrcat(plist2, \"-\");\n\t\tstrcat(plist2, pl);\n\n\t\ti++;\n\n\t\tpl = strtok(NULL, \", \");\n\t}\n\n\t(void)free(plist);\n\treturn (plist2);\n\n}\n\n/**\n * @brief\n *\treturns the real partition name\n *\tgiven a \"uniquified\" partition name of the form:\n *\t<mom_short_name>-partN\n *\n * @param[in] part_name - partition name\n *\n * @return\tstring\n * @retval\tpartirion name\t\tSuccess\n * @retval\tNULL\t\t\tError\n *\n */\nstatic char *\nget_real_part_name(char *part_name)\n{\n\tchar matchstr[PBS_MAXHOSTNAME+2];\t/* '\\0' and '-' */\n\n\tif (part_name == NULL)\n\t\treturn NULL;\n\n\tsprintf(matchstr, \"%s-\", mom_short_name);\n\tif (strncmp(part_name, matchstr, strlen(matchstr)) == 0)\n\t\treturn (part_name+strlen(matchstr));\n\n\treturn (part_name);\n}\n\n/**\n * @brief\n *\tvn_create_bglvnodes: generates the list of vnodes and attributes\n * \tin *p_vnlp, taking values from 'bglvns',  to be sent over to the server\n *\ton the next state_to_server() call.\n *\n * @param[in] p_vnlp - pointer to pointer to vnl_t structure\n * @param[in] bglvns - pointer to bgl_vnode structure\n * @param[in] callback - call back function\n *\n * NOTE: *p_vnlp is always re-generated and set to NULL if any error occurs\n *\n * @return\tint\n * @retval\t0\tSuccess\n * @retval\t-1\tError\n *\n */\nint\nvn_create_bglvnodes(vnl_t **p_vnlp, struct bgl_vnode *bglvns,\n\tcallfunc_t callback)\n{\n\tstruct bgl_vnode\t*iptr;\n\tchar\t\t\tpname_attrib[80];\n\tint\t\t\ti;\n\tint\t\t\trcode = -1;\t/* initially set as error */\n\tchar\t\t\t*u_part_list = NULL;\n\n\tif (*p_vnlp != NULL) {\n\t\tvnl_free(*p_vnlp);\n\t\t*p_vnlp = NULL;\n\n\t}\n\tif (vnl_alloc(p_vnlp) == NULL) {\n\t\tlog_err(errno, __func__, \"vnl_alloc failed!\");\n\t\treturn (-1);\n\t}\n\n\tif (vn_addvnr(*p_vnlp, mom_short_name, VNATTR_PNAMES,\n\t\tPNAME, 0, 0, callback) == -1)\n\t\tgoto bgl_vn_create_exit;\n\n\tif (vn_addvnr(*p_vnlp, mom_short_name, \"resources_available.ncpus\",\n\t\t\"0\", 0, 0, callback) == -1)\n\t\tgoto bgl_vn_create_exit;\n\n\tif (vn_addvnr(*p_vnlp, mom_short_name, \"resources_available.mem\",\n\t\t\"0\", 0, 0 callback) == -1)\n\t\tgoto bgl_vn_create_exit;\n\n\tif (vn_addvnr(*p_vnlp, mom_short_name, \"resources_available.vmem\",\n\t\t\"0\", 0, 0, callback) == -1)\n\t\tgoto bgl_vn_create_exit;\n\n\tsprintf(pname_attrib, \"resources_available.%s\", PNAME);\n\n\ti = 0;\n\tfor (iptr=bglvns; iptr; iptr=iptr->nextptr) {\n\t\tchar\tnum_cpus_s[40];\n\t\tchar\tnum_cnodes_s[40];\n\t\tchar\tamt_mem_s[40];\n\n\t\tif ((iptr->vnode_name == NULL) || (iptr->state != BGLVN_FREE)) {\n\t\t\tcontinue;\n\t\t} else if ((iptr->part_list == NULL) ||\n\t\t\t(iptr->part_list[0] == '\\0')) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Not reporting vnode %s since it is not part of any partition\", iptr->vnode_name);\n\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer)\n\t\t\t;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* only FREE vnodes are sent */\n\t\tsprintf(num_cnodes_s, \"%d\", iptr->num_cnodes);\n\t\tsprintf(num_cpus_s, \"%d\", iptr->num_cnodes*CPUS_PER_CNODE);\n\t\tsprintf(amt_mem_s, \"%lukb\", iptr->amt_mem);\n\n\t\tif (vn_addvnr(*p_vnlp, iptr->vnode_name,\n\t\t\t\"resources_available.arch\",\n\t\t\tBLUEGENE, 0, 0, callback) == -1)\n\t\t\tgoto bgl_vn_create_exit;\n\n\t\tif (vn_addvnr(*p_vnlp, iptr->vnode_name, \"sharing\",\n\t\t\t\"force_excl\", 0, 0, callback) == -1)\n\t\t\tgoto bgl_vn_create_exit;\n\n\t\tif (vn_addvnr(*p_vnlp, iptr->vnode_name,\n\t\t\t\"resources_available.ncpus\",\n\t\t\tnum_cpus_s, 0, 0, callback) ==-1)\n\t\t\tgoto bgl_vn_create_exit;\n\n\t\tif (vn_addvnr(*p_vnlp, iptr->vnode_name,\n\t\t\t\"resources_available.mem\",\n\t\t\tamt_mem_s, 0, 0, callback) == -1)\n\t\t\tgoto bgl_vn_create_exit;\n\n\t\tif (u_part_list) {\n\t\t\t(void)free(u_part_list);\n\t\t\tu_part_list = NULL;\n\t\t}\n\n\t\tu_part_list = uniquify_part_list(iptr->part_list);\n\n\t\tif (vn_addvnr(*p_vnlp, iptr->vnode_name, pname_attrib,\n\t\t\t(u_part_list?u_part_list:\"\"), 0, 0, callback) == -1)\n\t\t\tgoto bgl_vn_create_exit;\n\t\ti++;\n\t}\n\n\n\t(*p_vnlp)->vnl_modtime = time(0);\n\n\trcode = 0;\t/* got this far, means all okay! */\n\nbgl_vn_create_exit:\n\n\tif (rcode != 0) {\t/* we have an error */\n\t\tvnl_free(*p_vnlp);\n\t\t*p_vnlp = NULL;\n\t}\n\n\tif (u_part_list)\n\t\t(void)free(u_part_list);\n\n\treturn (rcode);\n}\n\n\n/**\n * @brief\n *\tbgl_read_machine_serial: finds out the serial number  of the BGL machine\n * \tby consulting the BRIDGE_CONFIG_FILE.\n *\n * @return \tstring\n * @retval\tserial number\tif found\n * @retval\tNULL \t\tif not found or error.\n *\n */\nchar *\nbgl_read_machine_serial(void)\n{\n\tFILE\t\t*conf;\n\tchar\t\tname[32], value[256];\n\tint\t\tn;\n\tchar\t\t*machine_ser = NULL;\n\n\tchar *config_file = getenv(\"BRIDGE_CONFIG_FILE\");\n\n\tif (config_file == NULL) {\n\t\tlog_err(-1, __func__, \"The environment parameter \\\"BRIDGE_CONFIG_FILE\\\" not set, set it to point to the configuration file\");\n\t\treturn NULL;\n\t}\n\tconf = fopen(config_file, \"r\");\n\n\tif (conf == NULL) {\n\t\tlog_err(errno, __func__,\n\t\t\t\"Bridge config file could not be found or accessed\");\n\t\treturn NULL;\n\t}\n\n\twhile (((n=fscanf(conf, \"%s %s\", name, value)) != EOF) && (n > 0)) {\n\t\tif (strcmp(name, \"BGL_MACHINE_SN\") == 0) {\n\t\t\tmachine_ser = strdup(value);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(conf);\n\treturn (machine_ser);\n}\n\n/**\n * @brief\n *\tget_vnode_list_spanned_bypartition: returns a comma-separated\n *\tstring containing the list of vnodes in\n *\t\"vns\" who are spanned by the given 'partition'.\n *\n * @param[in] vns - pointer to bgl_vnode structure\n * @param[in] partition - partition name\n *\n * @return\tstring\n * @retval\tmalloced string to be freed\tSuccess\n * @retval\tNULL\t\t\t\tError\n *\n */\nchar *\nget_vnode_list_spanned_bypartition(struct bgl_vnode *vns, char *partition)\n{\n\tstruct bgl_vnode\t*iptr;\n\tchar\t\t\t*vnlist_ret = NULL;\n\n\tif (partition == NULL) {\n\t\tlog_err(-1, __func__, \"part_name is NULL!\");\n\t\treturn NULL;\n\t}\n\n\tfor (iptr=vns; iptr; iptr=iptr->nextptr) {\n\t\tif (iptr->vnode_name && iptr->part_list) {\n\t\t\tif (in_string_list(partition, iptr->part_list)) {\n\t\t\t\t(void)strdup_cat(&vnlist_ret, iptr->vnode_name);\n\t\t\t}\n\t\t}\n\t}\n\treturn (vnlist_ret);\n}\n\n/**\n * @brief\n *\tset_bgl_vnodes_state: set state to 'state' in *p_bglvns structure of all\n *\tvnodes in 'vn_list' string (a comma-separated list)\n *\n * @param[in] p_bglvns - pointer to pointer to bgl_vnode  structure\n * @param[in] vn_list - vnode list\n * @param[in] state - vnode state\n *\n * @return\tVoid\n *\n */\nvoid\nset_bgl_vnodes_state(struct bgl_vnode **p_bglvns, char *vn_list,\n\tbgl_vnstate state)\n{\n\tchar\t*p, *p2;\n\n\tif ((vn_list == NULL) || (vn_list[0] == '\\0'))\n\t\treturn;\n\n\tp = strdup(vn_list);\n\tif (p != NULL) {\n\t\tp2 = strtok(p, \", \");\n\t\twhile (p2 != NULL) {\n\t\t\t*p_bglvns=bgl_vnode_put_state(*p_bglvns, p2, state);\n\t\t\tp2 = strtok(NULL, \", \");\n\t\t}\n\t\t(void)free(p);\n\t}\n}\n\n/**\n * @brief\n *\tcancel_bgl_job: return 0 if job has been cancelled; non-zero otherwise.\n *\tIf a job could not be cancelled, then this function automatically\n *\tadds the job to the list of \"stuck\" jobs in the global variable\n *\t\"stuck_bgljobs\".\n *\n * @param[in] bjid - bgl jobid\n * @param[in] part - partition name\n *\n * @return\tint\n * @retval\t0\tSuccess\n * @retval\t-1\tError\n *\n */\nint\ncancel_bgl_job(db_job_id_t bjid, char *part)\n{\n\trm_job_t\t*bgl_job;\n\trm_job_state_t\tbjstate = RM_JOB_IDLE;\n\tdb_job_id_t\tstuck_bjid;\n\n\tif (bjid == -1)\n\t\treturn (-1);\n\n\n\t(void)jm_signal_job(bjid, SIGINT);\n\t(void)jm_cancel_job(bjid);\n\n\tif (rm_get_job(bjid, &bgl_job) == STATUS_OK) {\n\t\trm_get_data(bgl_job, RM_JobState, &bjstate);\n\t\tif( (bjstate == RM_JOB_TERMINATED) || \\\n\t\t\t\t(bjstate == RM_JOB_KILLED) || \\\n\t\t\t\t\t(bjstate == JOB_NOT_FOUND) ) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (((stuck_bjid=bgl_job_get_bgl_jobid(stuck_bgljobs, part)) == -1) ||\n\t\t(stuck_bjid != bjid)) {\n\t\tchar\t*vn_list = NULL;\n\n\t\tstuck_bgljobs = \\\n\t\t\tbgl_job_put_partition_given_bgl_jobid(stuck_bgljobs,\n\t\t\tbjid, part);\n\n\t\tsprintf(log_buffer, \"Marked BGL job %d on part %s as stuck\",\n\t\t\tbjid, part);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\t\tvn_list = get_vnode_list_spanned_bypartition(bglvnodes, part);\n\t\tif (vn_list) {\n\t\t\tset_bgl_vnodes_state(&bglvnodes, vn_list, BGLVN_BUSY);\n\t\t\tsprintf(log_buffer, \"vnodes marked BUSY: %s\", vn_list);\n\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\tlog_buffer);\n\t\t\tif (vn_create_bglvnodes(&vnlp, bglvnodes, NULL) == -1) {\n\t\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\t\tLOG_NOTICE, __func__,\n\t\t\t\t\t\"Failed to create new VN list to send to server!\");\n\t\t\t}\n\t\t\tinternal_state_update = UPDATE_MOM_STATE;\n\n\t\t\t(void)free(vn_list);\n\t\t}\n\t}\n\n\treturn (-1);\n}\n\n\n/**\n * @brief\n *\tjob_bgl_partitions: returns the name of the BGL partition that has been\n * \t\"pre-assigned\" to the job 'pjob'.\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return\tstring\n * @retval\tpartition name\tSuccess\n * @retval\tNULL\t\tError\n *\n */\n\nchar *\njob_bgl_partition(job *pjob)\n{\n\tchar *p, *p2;\n\tchar *part_name = NULL;\n\tchar *cur_jid = NULL;\n\n\tif (pjob == NULL) {\n\t\tlog_err(-1, __func__, \"pjob is NULL!\");\n\t\treturn NULL;\n\t}\n\tcur_jid = pjob->ji_qs.ji_jobid;\n\n\tif (!(pjob->ji_wattr[(int)JOB_ATR_pset].at_flags & ATR_VFLAG_SET)) {\n\t\tlog_joberr(-1, __func__, \"job has no pset\", cur_jid);\n\t\treturn NULL;\n\t}\n\n\tp = strstr(pjob->ji_wattr[(int)JOB_ATR_pset].at_val.at_str,\n\t\tPSET_SUFFIX);\n\n\n\tif (p == NULL) {\n\t\tsprintf(log_buffer, \"pjob has no %s in pset\",\n\t\t\tPSET_SUFFIX);\n\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\t\treturn NULL;\n\t}\n\tif ((p2=strstr(p, \"=\"))) {\n\t\tp2++;\n\t\tpart_name = p2;\n\n\t\t/* look for the ending ',' or ' ' */\n\t\twhile (p2 && *p2 != ',' && *p2 != '\\0' && *p2 != ' ')\n\t\t\tp2++;\n\n\t\tif ((*p2 == ',') || (*p2 == ' '))\n\t\t\t*p2 = '\\0';\n\t}\n\n\t/* we're only looking at the first PSET_SUFFIX since currently    */\n\t/* we don't support multi-host  BGL partitions; that is, can only */\n\t/* assign a single partition from the single BGL host. We can't   */\n\t/* have the following:   pset=\"partition=X, partition=Y, ...\"     */\n\t/* If PBS mom receives such a pset, then it will automatically    */\n\t/* truncate as \"pset=partition=X\"                                 */\n\n\treturn (get_real_part_name(part_name));\n}\n\n/**\n * @brief\n *\tjob_bgl_delete: free up of any job the BGL partition that pjob belongs to\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return\tint\n * @retval\t0\tSuccess\n * @retval\t!0\tError\n *\n */\n\nint\njob_bgl_delete(job *pjob)\n{\n\tchar\t\t*part = NULL;\n\tstruct\tbgl_job\t*bjobs = NULL;\n\tdb_job_id_t\tbgl_jid;\n\tint\t\tret;\n\tchar\t\t*pbs_jobid = NULL;  /* PBS job owner of BGL job */\n\tchar\t\t*cur_jid = NULL;    /* PBS job being examined */\n\n\n\tif (pjob == NULL)\n\t\treturn (-1);\n\n\tcur_jid = pjob->ji_qs.ji_jobid;\n\n\tpart = job_bgl_partition(pjob);\n\tif (part == NULL) {\n\t\tlog_joberr(-1, __func__, \"no assigned partition\", cur_jid);\n\t\treturn (-1);\n\t}\n\n\n\tbjobs = get_bgl_jobs();\n\n\n\tif (bjobs == NULL) {\n\t\treturn (0);\n\t}\n\n\t/* TODO: free up the job attribute that holds the partition info */\n\tret = 0;\n\tbgl_jid = bgl_job_get_bgl_jobid(bjobs, part);\n\tpbs_jobid = bgl_job_get_pbs_jobid(bjobs, part);\n\n\n\tif (bgl_jid != -1) { /* there's a BGL job found */\n\n\t\t/* cancel only if BGL job belongs to this PBS job, */\n\t\t/* or if it was created outside of PBS and restrict_user is ON */\n\n\t\tif ((pbs_jobid && cur_jid && (strcmp(pbs_jobid, cur_jid) == 0)) ||\n\t\t\t((pbs_jobid == NULL) && restrict_user)) {\n\n\t\t\tif (cancel_bgl_job(bgl_jid, part) != 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Failed to delete bgl_jobid=%d from partition=%s\",\n\t\t\t\t\tbgl_jid, part);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\t\t\t\tret = -2;\n\t\t\t} else {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Cancelled BGL job %d For job %s\",\n\t\t\t\t\tbgl_jid, pjob->ji_qs.ji_jobid);\n\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t\t\t}\n\t\t}\n\t}\n\tbgl_job_free(bjobs);\n\treturn (ret);\n}\n\n/**\n * @brief\n *\tGiven a partition name 'part_name', returns its current status.\n *\tIf error getting partitions listing from the system, or partition\n *\tnot found, return RM_PARTITION_NAV; otherwise, return the current\n *\tpartition state.\n * WARNING: Somehow, calling this in the child process causes failure\n * in API! Don't know why.\n *\n * @param[in] part_name - parition name\n *\n * @return\trm_partition_state_t\n * @retval\tstate of partition\tSuccess\n * @retval\terror code\t\tError\n *\n */\n\nrm_partition_state_t\nget_bgl_partition_state(char *part_name)\n{\n\tint\t\t\tst = 0;\n\trm_partition_state_t\t part_state = RM_PARTITION_NAV;\n\trm_partition_t\t\t*part = NULL;\n\n\tif ((st=rm_get_partition(part_name, &part)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_partition(%s): %s\", part_name,\n\t\t\tbglerror_to_txt(st));\n\t\tlog_err(errno, __func__, log_buffer);\n\n\t\treturn (RM_PARTITION_NAV);\n\t}\n\n\trm_get_data(part, RM_PartitionState, &part_state);\n\n\trm_free_partition(part);\n\n\treturn (part_state);\n}\n\n/**\n * @brief\n *\tGiven a partition name 'part_name', returns number of compute nodes\n *\tmaking up the partition.\n * WARNING: Somehow, calling this in the child process causes failure\n * in API! Don't know why.\n *\n * @param[in] part_name - partition name\n * @param[in] cnodes_per_bp - number of cpu per base partition\n * @param[in] cnodes_per_ncard - number of cpu per node card\n *\n * @return\tint\n * @retval\tnumber of cpu\t\tSuccess\n * @retval\t0\t\t\tError\n *\n */\nint\nget_bgl_partition_size(char *part_name, int cnodes_per_bp, int cnodes_per_ncard)\n{\n\tint\t\t\tst = 0;\n\tint\t\t\tnum_cnodes = 0;\n\tint\t\t\tnum_bps = 0;\n\tint\t\t\tnum_ncards;\n\tint\t\t\tpart_is_small = 0;\n\trm_partition_t\t\t*part = NULL;\n\n\tif ((st=rm_get_partition(part_name, &part)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_partition(%s): %s\", part_name,\n\t\t\tbglerror_to_txt(st));\n\t\tlog_err(errno, __func__, log_buffer);\n\n\t\treturn (0);\n\t}\n\n\trm_get_data(part, RM_PartitionSmall, &part_is_small);\n\tif (part_is_small) {\n\t\trm_get_data(part, RM_PartitionNodeCardNum, &num_ncards);\n\t\tnum_cnodes = num_ncards*cnodes_per_ncard;\n\t} else {\n\t\trm_get_data(part, RM_PartitionBPNum, &num_bps);\n\t\tnum_cnodes = num_bps*cnodes_per_bp;\n\t}\n\n\trm_free_partition(part);\n\n\treturn (num_cnodes);\n}\n\n/**\n * @brief\n *\treturns the list of BGL jobs that are currently running\n *\ton the system. If it finds a BGL job belonging to a partition that is\n *\tassigned to a PBS job, that PBS jobid is also added to the\n *\tbgl_job entry.\n *\n * NOTE: It is possible that a partition has been assigned a PBS job,\n * but no BGL job has been instantiated yet. Instantiation takes place\n * when PBS job calls \"mpirun\". If so, only a pbs_jobid entry in bgl_job\n * would be returned without a BGL job.\n *\n * @return\tstructure handle\n * @retval\tthe bgl_job structure that must be later freed. \tSuccess\n * @retval\tNULL\t\t\t\t\t\t\tError\n *\n */\nstruct bgl_job *\nget_bgl_jobs(void)\n{\n\tstatus_t\t\tst;\n\trm_job_list_t\t\t*bjobs;\n\trm_element_t\t\t*bj;\n\tint\t\t\ti, num_jobs;\n\tdb_job_id_t\t\tbjid;\n\tpm_partition_id_t\tbjpartid;\n\trm_job_state_t\t\tbjstate;\n\tstruct bgl_job\t\t*bjparts = NULL;\n\textern pbs_list_head\tsvr_alljobs;\n\tjob\t\t\t*pj;\n\n\tif ((st=rm_get_jobs(JOB_ALL_FLAG, &bjobs)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_jobs: %s\",\n\t\t\tbglerror_to_txt(st));\n\t\tlog_err(-1, __func__, log_buffer);\n\t\treturn NULL;\n\t}\n\trm_get_data(bjobs, RM_JobListSize, &num_jobs);\n\n\tfor (i=0; i < num_jobs; i++) {\n\t\tif (i == 0)\n\t\t\trm_get_data(bjobs, RM_JobListFirstJob, &bj);\n\t\telse\n\t\t\trm_get_data(bjobs, RM_JobListNextJob, &bj);\n\n\t\trm_get_data(bj, RM_JobDBJobID, &bjid);\n\t\trm_get_data(bj, RM_JobPartitionID, &bjpartid);\n\t\trm_get_data(bj, RM_JobState, &bjstate);\n\n\t\tif( (bjstate != RM_JOB_TERMINATED) && \\\n\t\t\t\t(bjstate != RM_JOB_KILLED) && \\\n\t\t\t\t(bjstate != RM_JOB_ERROR) ) {\n\t\t\tbjparts=bgl_job_put_partition_given_bgl_jobid(bjparts,\n\t\t\t\tbjid, bjpartid);\n\t\t}\n\t}\n\n\trm_free_job_list(bjobs);\n\n\t/* Now let's check for PBS-owned partitions */\n\tfor (pj = (job *)GET_NEXT(svr_alljobs);\n\t\tpj != NULL;\n\t\tpj = (job *)GET_NEXT(pj->ji_alljobs)) {\n\t\tchar\t*part;\n\t\tif ((part=job_bgl_partition(pj)) != NULL) {\n\n\t\t\t/* mark partition as actively used by PBS if:         */\n\t\t\t/* 1. PBS job is truly in a RUNNING state when the    */\n\t\t\t/*    job script is being executed, which is when the */\n\t\t\t/*    the partition is needed.                        */\n\t\t\t/* 2. PBS job is being killed by a signal (qrerun)    */\n\t\t\t/* 3. PBS job was running and sent an obit            */\n\t\t\t/*                                                    */\n\t\t\tif (((pj->ji_qs.ji_state == JOB_STATE_RUNNING) &&\n\t\t\t\t(pj->ji_qs.ji_substate == JOB_SUBSTATE_RUNNING)) ||\n\t\t\t\t((pj->ji_qs.ji_state == JOB_STATE_EXITING) &&\n\t\t\t\t(pj->ji_qs.ji_substate == JOB_SUBSTATE_KILLSIS)) ||\n\t\t\t\t((pj->ji_qs.ji_state == JOB_STATE_RUNNING) &&\n\t\t\t\t(pj->ji_qs.ji_substate == JOB_SUBSTATE_OBIT)))\n\t\t\t\tbjparts=bgl_job_put_pbs_jobid(bjparts, part,\n\t\t\t\t\t(char *)pj->ji_qs.ji_jobid);\n\t\t}\n\t}\n\treturn (bjparts);\n}\n\n/**\n * @brief\n *\tevaluate_vnodes_phys_state: any non-RESERVE vnodes in the comma-separated\n *\t'vn_list' found to not have a physical state of \"UP\" in the system\n *\twill get marked as having a BGLVN_DOWN state in '*p_bglvns'; any vnodes\n *\tin 'vn_list' found to have a physical state of \"UP\" and yet shows as\n *\tBGLVN_DOWN in '*p_bglvns' will get marked as BGLVN_FREE in '*p_bglvns'\n *\n * @param[in] p_bglvns - pointer to pointer to bgl_vnode structure\n * @param[in] vn_list - vnode list\n * @param[in] num_vns_down - number of vnodes down\n * @param[in] num_vns_up - number of vnodes up\n * @param[in] down_vn_list - pointer to list of vnodes which are down\n *\n * @return\tVoid\n *\n */\nvoid\nevaluate_vnodes_phys_state(struct bgl_vnode **p_bglvns, char *vn_list,\n\tint *num_vns_down, int *num_vns_up, char **down_vn_list)\n{\n\n\tstatus_t\t\tst;\n\trm_BGL_t\t\t*bgl = NULL;\n\tint\t\t\tnum_bps;\n\tint\t\t\ti, j;\n\trm_element_t\t\t*bp;\n\trm_bp_id_t\t\tbp_id;\n\trm_BP_state_t\t\tbp_state;\n\tint\t\t\tbp_used_by_busy_smallp = 0;\n\tint\t\t\tbp_used_by_free_smallp = 0;\n\trm_nodecard_list_t\t*nc_list;\n\tint\t\t\tnum_ncards;\n\trm_nodecard_t\t\t*ncard;\n\trm_quarter_t\t\tncard_q;\n\trm_nodecard_state_t\tncard_state;\n\trm_nodecard_id_t\tncard_id;\n\tchar\t\t\tvnode_name[PBS_MAXNODENAME+1];\n\n\tif (vn_list == NULL)\n\t\treturn;\n\n\tif ((st=rm_get_BGL(&bgl)) != STATUS_OK) {\n\t\tsprintf(log_buffer, \"rm_get_BGL: %s\", bglerror_to_txt(st));\n\t\tlog_err(errno, __func__, log_buffer);\n\t\treturn;\n\t}\n\n\trm_get_data(bgl, RM_BPNum, &num_bps);\n\n\t/* prepare the returned items */\n\tif (down_vn_list && (*down_vn_list != NULL)) {\n\t\t(void)free(*down_vn_list);\n\t\t*down_vn_list = NULL;\n\t}\n\n\tfor (i=0; i < num_bps; i++) {\n\t\tif (i == 0)\n\t\t\trm_get_data(bgl, RM_FirstBP, &bp);\n\t\telse\n\t\t\trm_get_data(bgl, RM_NextBP, &bp);\n\n\t\trm_get_data(bp, RM_BPID, &bp_id);\n\t\trm_get_data(bp, RM_BPState, &bp_state);\n\t\trm_get_data(bp, RM_BPSDB, &bp_used_by_busy_smallp);\n\t\trm_get_data(bp, RM_BPSD, &bp_used_by_free_smallp);\n\n\t\tif (bp_used_by_free_smallp || bp_used_by_busy_smallp) {\n\n\t\t\tif (rm_get_nodecards(bp_id, &nc_list) == STATUS_OK) {\n\t\t\t\trm_get_data(nc_list, RM_NodeCardListSize, &num_ncards);\n\n\t\t\t\tfor (j=0; j < num_ncards; j++) {\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\trm_get_data(nc_list,\n\t\t\t\t\t\t\tRM_NodeCardListFirst, &ncard);\n\t\t\t\t\telse\n\t\t\t\t\t\trm_get_data(nc_list,\n\t\t\t\t\t\t\tRM_NodeCardListNext, &ncard);\n\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardID, &ncard_id);\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardState,\n\t\t\t\t\t\t&ncard_state);\n\t\t\t\t\trm_get_data(ncard, RM_NodeCardQuarter, &ncard_q);\n\n\t\t\t\t\tsprintf(vnode_name, \"%s[%s%s%d%s%s]\",\n\t\t\t\t\t\tmom_short_name, bp_id,\n\t\t\t\t\t\tCARD_DELIM, ncard_q, CARD_DELIM, ncard_id);\n\n\t\t\t\t\tif (bgl_vnode_get_state(*p_bglvns,\n\t\t\t\t\t\tvnode_name) == BGLVN_RESERVE)\n\t\t\t\t\t\tcontinue;   /* skip reserve vnodes */\n\n\t\t\t\t\tif (in_string_list(vnode_name, vn_list)) {\n\t\t\t\t\t\t/* if current state is down and */\n\t\t\t\t\t\t/* previous state is up */\n\t\t\t\t\t\tif( (ncard_state != RM_NODECARD_UP) && \\\n\t\t\t\t\t (bgl_vnode_get_state(*p_bglvns,\n\t\t\t\t\t\t\tvnode_name) != BGLVN_DOWN)) {\n\t\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\t\"Vnode %s has a bad nodecard state %s\",\n\t\t\t\t\t\t\t\tvnode_name, ncstate_to_txt(ncard_state));\n\t\t\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG,\n\t\t\t\t\t\t\t\t__func__, log_buffer);\n\n\t\t\t\t\t\t\t*p_bglvns = bgl_vnode_put_state(\\\n\t\t\t\t\t\t\t*p_bglvns, vnode_name,\n\t\t\t\t\t\t\t\tBGLVN_DOWN);\n\t\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\t\"vnode marked DOWN: %s\", vnode_name);\n\t\t\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0,\n\t\t\t\t\t\t\t\tLOG_DEBUG, __func__, log_buffer);\n\n\t\t\t\t\t\t\tif (down_vn_list)\n\t\t\t\t\t\t\t\t(void)strdup_cat(down_vn_list,\n\t\t\t\t\t\t\t\t\tvnode_name);\n\n\t\t\t\t\t\t\tif (num_vns_down)\n\t\t\t\t\t\t\t\t(*num_vns_down)++;\n\t\t\t\t\t\t} else if ((ncard_state == RM_NODECARD_UP) &&\n\t\t\t\t\t\t\t(bgl_vnode_get_state(*p_bglvns,\n\t\t\t\t\t\t\tvnode_name) == BGLVN_DOWN)) {\n\t\t\t\t\t\t\t/* nodecard up, but vnode currently down*/\n\t\t\t\t\t\t\t*p_bglvns = bgl_vnode_put_state(\\\n\t\t\t\t\t\t\t*p_bglvns, vnode_name,\n\t\t\t\t\t\t\t\tBGLVN_FREE);\n\t\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\t\"vnode marked FREE: %s\", vnode_name);\n\t\t\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0,\n\t\t\t\t\t\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\t\t\t\t\t\tif (num_vns_up)\n\t\t\t\t\t\t\t\t(*num_vns_up)++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(vnode_name, \"%s[%s]\", mom_short_name, bp_id);\n\n\t\t\tif (bgl_vnode_get_state(*p_bglvns,\n\t\t\t\tvnode_name) == BGLVN_RESERVE)\n\t\t\t\tcontinue;   /* skip reserve vnodes */\n\n\t\t\tif (in_string_list(vnode_name, vn_list)) {\n\n\t\t\t\t/* if current state is down but previous state */\n\t\t\t\t/* is up */\n\t\t\t\tif( (bp_state != RM_BP_UP) && \\\n\t\t\t      (bgl_vnode_get_state(*p_bglvns, vnode_name) \\\n\t\t\t\t\t\t!= BGLVN_DOWN) ) {\n\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\"Vnode %s has a bad midplane state %s\",\n\t\t\t\t\t\tvnode_name, bpstate_to_txt(bp_state));\n\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\t\t\tlog_buffer);\n\n\t\t\t\t\t*p_bglvns = bgl_vnode_put_state(*p_bglvns,\n\t\t\t\t\t\tvnode_name, BGLVN_DOWN);\n\t\t\t\t\tsprintf(log_buffer, \"vnode marked DOWN: %s\",\n\t\t\t\t\t\tvnode_name);\n\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\t\t\tlog_buffer);\n\n\t\t\t\t\tif (down_vn_list)\n\t\t\t\t\t\t(void)strdup_cat(down_vn_list, vnode_name);\n\t\t\t\t\tif (num_vns_down)\n\t\t\t\t\t\t(*num_vns_down)++;\n\t\t\t\t} else if ((bp_state == RM_BP_UP) &&\n\t\t\t\t\t(bgl_vnode_get_state(*p_bglvns,\n\t\t\t\t\tvnode_name) == BGLVN_DOWN)) {\n\t\t\t\t\t/* nodecard up, but vnode currently down*/\n\t\t\t\t\t*p_bglvns = bgl_vnode_put_state(\\\n\t\t\t\t\t\t\t*p_bglvns, vnode_name,\n\t\t\t\t\t\tBGLVN_FREE);\n\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\"vnode marked FREE: %s\", vnode_name);\n\t\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0,\n\t\t\t\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\t\t\t\tif (num_vns_up)\n\t\t\t\t\t\t(*num_vns_up)++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\trm_free_BGL(bgl);\n\n}\n\n/**\n * @brief\n *\tverify_job_bgl_partition: verifies that the pre-assigned partition\n *\tto 'pjob' is ok and returns 0 for success.\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] job_error_code - error code\n *\n * @return \tint\n * @retval\t0\tSuccess\n * @retval\t-1  \tbad pjob\n * @retval\t-2  \tjob was not pre-assigned any partition by the scheduler\n * @retval\t-3  \tjob's pre-assigned partition is not empty (not cleared due to\n *\t\t\trestrict_user is OFF\n * @retval\t-4  \tjob's pre-assigned partition owned by another PBS job\n * @retval\t-5  \tjob's pre-assigned partition (not owned by PBS) could not be\n *\t\t\tcleared\n * @retval\t-6  \tjob's pre-assigned partition had an unexpected state!\n * @retval\t-7   \tjob's pre-assigned partition has vnodes that are not\n *\t\t\tphysically up.\n * @retval\t-8  \tpartition is READY but PBS failed to reset state to FREE\n * @retval\t-9  \tvnodes in chosen partition not match job's assigned vnodes\n * @retval \t-10 \tjob's pre-assigned partition has vnodes overlapping with\n * \t\t\t  an active partition not assigned by PBS.\n *\n */\nint\nverify_job_bgl_partition(job *pjob, int *job_error_code)\n{\n\n\tstruct bgl_job\t*bgl_jobs = NULL;\n\tstruct bgl_job  *jptr = NULL;\n\tdb_job_id_t\tbjid;\n\tchar\t\t*pjid, *cur_jid;\n\tint\t\trcode;\n\tchar\t\t*part;\n\tchar\t\t*vnode_list = NULL;\n\trm_partition_state_t part_state;\n\tint\t\tnum_vns_down = 0;\n\tint\t\tnum_vns_up = 0;\n\tchar\t\t*downed_vns = NULL;\n\tchar\t\t*assn_vnode_list = NULL;\n\t/* variables used in parsing the \"exec_vnode\" string */\n\tchar\t\t*chunk = NULL;\n\tchar\t\t*execvnode = NULL;\n\tint\t\trc;\n\tchar\t\t*noden;\n\tint\t\tnelem;\n\tstruct key_value_pair *pkvp;\n\n\tcur_jid = pjob->ji_qs.ji_jobid;\n\n\tif ((pjob == NULL) || (cur_jid == NULL)) {\n\t\tlog_joberr(-1, __func__, \"pjob or jobid is NULL!\", cur_jid);\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_FAIL2;\n\t\treturn (-1);\n\t}\n\n\tif ((part=job_bgl_partition(pjob)) == NULL) {\n\t\tlog_joberr(-1, __func__, \"Scheduler did not assign a partition\", cur_jid);\n\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\treturn (-2);\n\t}\n\tvnode_list = get_vnode_list_spanned_bypartition(bglvnodes, part);\n\n\tif (!(pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_flags & ATR_VFLAG_SET)) {\n\t\tlog_joberr(-1, __func__, \"pjob's exec_vnode is not set!\", cur_jid);\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_FAIL2;\n\t\trcode = -1;\n\t\tgoto verifyexit;\n\t}\n\n\texecvnode = pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_val.at_str;\n\tchunk = parse_plus_spec(execvnode, &rc);\n\tif (rc != 0) {\n\t\tlog_joberr(-1, __func__, \"error initially  parsing exec_vnode!\",\n\t\t\tcur_jid);\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_FAIL2;\n\n\t\trcode = -1;\n\t\tgoto verifyexit;\n\t}\n\n\twhile (chunk) {\n\t\tif (parse_node_resc(chunk, &noden, &nelem, &pkvp) != 0) {\n\t\t\tlog_joberr(-1, __func__, \"error parsing exec_vnode chunk!\",\n\t\t\t\tcur_jid);\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_FAIL2;\n\n\t\t\trcode = -1;\n\t\t\tgoto verifyexit;\n\t\t}\n\n\t\tif (!in_string_list(noden, assn_vnode_list))\n\t\t\tstrdup_cat(&assn_vnode_list, noden);\n\n\t\tchunk = parse_plus_spec(NULL, &rc);\n\n\t\tif (rc != 0) {\n\t\t\tlog_joberr(-1, __func__, \"error parsing exec_vnode!\",\n\t\t\t\tcur_jid);\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_FAIL2;\n\n\t\t\trcode = -1;\n\t\t\tgoto verifyexit;\n\t\t}\n\t}\n\n\tif (!equal_string_list(vnode_list, assn_vnode_list)) {\n\t\tsprintf(log_buffer,\n\t\t\t\"part=%s has vnode_list=%s not matching assn_vnodes=%s (possible qrun -H problem)\",\n\t\t\tpart, vnode_list, (assn_vnode_list?assn_vnode_list:\"null\"));\n\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\n\t\trcode = -9;\n\t\tgoto verifyexit;\n\t}\n\n\n\tevaluate_vnodes_phys_state(&bglvnodes, vnode_list, &num_vns_down,\n\t\t&num_vns_up, &downed_vns);\n\n\tif ((num_vns_down > 0) || (num_vns_up > 0)) {\n\n\t\t/* send server an updated list */\n\t\tif (vn_create_bglvnodes(&vnlp, bglvnodes, NULL) == -1) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_NOTICE, __func__,\n\t\t\t\t\"Failed to create new VN list to send to server!\");\n\t\t}\n\t\tinternal_state_update = UPDATE_MOM_STATE;\n\t}\n\n\tif (num_vns_down > 0) {\n\t\t/* ok to have duplicates in downed_bglvnodes; they'll be */\n\t\t/* cleaned up in end_proc */\n\t\t(void)strdup_cat(&downed_bglvnodes, downed_vns);\n\t\tsprintf(log_buffer,\n\t\t\t\"partition %s has the following vnodes physically down: %s!\",\n\t\t\tpart, downed_vns);\n\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t(void)free(downed_vns);\n\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\n\t\trcode = -7;\n\t\tgoto verifyexit;\n\t}\n\n\tpart_state = get_bgl_partition_state(part);\n\n\tif ((part_state != RM_PARTITION_FREE) &&\n\t\t(part_state != RM_PARTITION_READY) &&\n\t\t(part_state != RM_PARTITION_CONFIGURING)) {\n\n\t\tsprintf(log_buffer, \"partition %s has unexpected state %s!\",\n\t\t\tpart, pstate_to_txt(part_state));\n\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\t\tif (job_error_code != NULL)\n\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\n\t\tif (vnode_list) {\n\n\n\t\t\tbglpartitions_down = \\\n\t\t\t    bgl_partition_put_part_name(bglpartitions_down,\n\t\t\t\tpart);\n\t\t\tset_bgl_vnodes_state(&bglvnodes, vnode_list,\n\t\t\t\tBGLVN_DOWN);\n\t\t\tsprintf(log_buffer, \"vnodes marked DOWN: %s\",\n\t\t\t\tvnode_list);\n\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\tlog_buffer);\n\t\t\tif (vn_create_bglvnodes(&vnlp, bglvnodes,\n\t\t\t\tNULL) == -1) {\n\t\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\t\tLOG_NOTICE, __func__,\n\t\t\t\t\t\"Failed to create new VN list to send to server!\");\n\t\t\t}\n\t\t\tinternal_state_update = UPDATE_MOM_STATE;\n\t\t}\n\n\t\trcode = -6;\n\t\tgoto verifyexit;\n\t} else if (part_state == RM_PARTITION_READY) { /* booted state */\n\t\tstatus_t\t\tst;\n\n\t\t/* need to to set to FREE state as mpirun would fail */\n\t\t/* if a partition is booted and owned by another user */\n\t\tif (((st=pm_destroy_partition(part)) != STATUS_OK) ||\n\t\t\t((part_state=get_bgl_partition_state(part)) !=\n\t\t\tRM_PARTITION_FREE)) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Failed to set partition %s to FREE state error %s (current state %s)\",\n\t\t\t\tpart, bglerror_to_txt(st), pstate_to_txt(part_state));\n\t\t\tlog_joberr(errno, __func__, log_buffer, cur_jid);\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\trcode = -8;\n\t\t\tgoto verifyexit;\n\t\t}\n\t\tsprintf(log_buffer, \"Set partition %s to FREE state\",\n\t\t\tpart);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t}\n\n\tbgl_jobs = get_bgl_jobs();\n\n\tif (bgl_jobs == NULL) {\n\t\trcode = 0;\n\t\tgoto verifyexit;\n\t}\n\n\tbjid = -1;\n\tpjid = NULL;\n\trcode = 0;\n\n\t/* Need to catch also Blue Gene jobs spawned outside of PBS */\n\t/* whose partition overlaps with a partition to be assigned by PBS */\n\n\tfor (jptr=bgl_jobs; jptr; jptr=jptr->nextptr) {\n\n\t\tif (jptr->partition) {\n\n\t\t\tif (strcmp(jptr->partition, part) == 0) {\n\t\t\t\tpjid = jptr->pbs_jobid;\n\t\t\t\tbjid = jptr->bgl_jobid;\n\t\t\t} else if ((jptr->bgl_jobid != -1) &&\n\t\t\t\t(jptr->pbs_jobid  == NULL)) { /* BGL job not by PBS */\n\t\t\t\tchar *jvnode_list = NULL;\n\t\t\t\tint  found_overlap = 0;\n\n\t\t\t\tjvnode_list = get_vnode_list_spanned_bypartition(\\\n                                        \tbglvnodes, jptr->partition);\n\n\t\t\t\t/* active non-PBS Blue Gene job has vnodes that */\n\t\t\t\t/* overlap with the partition to be assigned */\n\t\t\t\tif (overlap_string_list(jvnode_list, vnode_list)) {\n\n\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\"Pre-assigned partition %s has vnodes %s overlapping with Blue Gene job %d's vnodes %s\",\n\t\t\t\t\t\tpart,\n\t\t\t\t\t\t(vnode_list?vnode_list:\"null\"),\n\t\t\t\t\t\tjptr->bgl_jobid,\n\t\t\t\t\t\t(jvnode_list?jvnode_list:\"null\"));\n\t\t\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t\t\t\tif (job_error_code != NULL)\n\t\t\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\t\t\trcode = -10;\n\t\t\t\t\tfound_overlap = 1;\n\t\t\t\t}\n\n\t\t\t\tif (jvnode_list) {\n\t\t\t\t\t(void)free(jvnode_list);\n\t\t\t\t}\n\n\t\t\t\tif (found_overlap)\n\t\t\t\t\tgoto  verifyexit;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bjid == -1) { /* No BGL job on partition */\n\t\tif ((pjid != NULL) && (strcmp(pjid, cur_jid) != 0)) {\n\t\t\t/* actively used by another PBS job */\n\t\t\t/* but it has not instantiated a */\n\t\t\t/* BGL jobid via mpirun */\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Pre-assigned partition %s is actively used by another PBS job (affected vnodes: %s)\",\n\t\t\t\tpart,\n\t\t\t\t(vnode_list?vnode_list:\"null\"));\n\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\trcode = -4;\n\t\t}\n\t\tgoto verifyexit;\n\t}\n\n\t/* BGL job on partition */\n\tif (pjid == NULL) { /* partition not owned by PBS */\n\t\tif (!restrict_user) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Busy pre-assigned partition %s not cleared due to restrict_user is OFF (affected vnodes: %s)\",\n\t\t\t\tpart, (vnode_list?vnode_list:\"null\"));\n\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\trcode = -3;\n\t\t} else if (cancel_bgl_job(bjid, part) != 0) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Busy pre-assigned partition %s could not be cleared (affected vnodes: %s)\",\n\t\t\t\tpart,\n\t\t\t\t(vnode_list?vnode_list:\"null\"));\n\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\trcode = -5;\n\t\t}\n\t} else { \t/* partition owned by PBS */\n\t\tif (strcmp(pjid, cur_jid) != 0) { /* owned by another PBS job*/\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Busy pre-assigned partition %s is actively used by another PBS job (affected vnodes: %s)\",\n\t\t\t\tpart,\n\t\t\t\t(vnode_list?vnode_list:\"null\"));\n\t\t\tlog_joberr(-1, __func__, log_buffer, cur_jid);\n\n\t\t\tif (job_error_code != NULL)\n\t\t\t\t*job_error_code = JOB_EXEC_RETRY;\n\t\t\trcode = -4;\n\t\t}\n\t}\n\nverifyexit:\n\tif (vnode_list)\n\t\t(void)free(vnode_list);\n\n\tbgl_job_free(bgl_jobs);\n\n\tif (assn_vnode_list)\n\t\t(void)free(assn_vnode_list);\n\n\treturn (rcode);\n}\n\n/**\n * @brief\n *\tif mode is 0, then calls \"setenv(env_var, env_val, 1)\" if env_var\n *\tis not defined in the current environment.\n *\tif mode is 1, then calls \"setenv(env_var, env_val, 1)\" if env_var\n *\tis not defined in the current environment, and env_val is an existent\n *\tfile path.\n *\tif mode is 2, then if env_var is not defined in the current environment,\n *\tthen execute 'cmd_get_val' to get the value for env_val, and call\n *\tsetenv(env_var, env_val, 1). Any passed env_val in this case will be ignored\n *\tand should just be set to NULL.\n *\n * @param[in] env_var - environment variable\n * @param[in] env_val - value for environment variable\n * @param[in] mode - mode of exec\n *\n * @return\tint\n * @retval\t0\tfound proper val for env_var\n * @retval\t-1\tnot found\n *\n */\nstatic int\nsetenv_if_not_exists(char *env_var, char *env_val, int mode, char *cmd_get_val)\n{\n\tchar\t*str = NULL;\n\tchar\t*env_str = NULL;\n\tstruct\tstat sbuf;\n\n\tif (env_var == NULL)\n\t\treturn (-1);\n\n\tif ((mode != 0) && (mode != 1) && (mode != 2))\n\t\treturn (-1);\n\n\t/* if defined in current environment */\n\tif (((str=getenv(env_var)) != NULL) && (strcmp(str, \"\") != 0)) {\n\t\tif ((mode == 0) || (mode == 2))\n\t\t\treturn (0);\n\n\t\t/* mode == 1 (file path) */\n\t\tif (stat(str, &sbuf) == -1) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Bad value for %s - path %s is bad!\",\n\t\t\t\tenv_var, str);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (mode == 1) {\n\n\t\tif (stat(env_val, &sbuf) == -1) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Did not find a value for %s - path %s is bad!\",\n\t\t\t\tenv_var, env_val);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\treturn (-1);\n\t\t}\n\t} else if (mode == 2) {\n\t\tFILE\t*fp;\n\t\tchar\tbuf[256];\n\n\t\talarm(alarm_time);\n\t\tif (cmd_get_val == NULL) {\n\t\t\tsprintf(log_buffer, \"No cmd_get_val to %s\", env_var);\n\t\t\tlog_err(-1, __func__, log_buffer);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif ((fp=pbs_popen(cmd_get_val, \"r\")) == NULL) {\n\t\t\tsprintf(log_buffer, \"pbs_open(%s) failed\", cmd_get_val);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\talarm(0);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tbuf[0] = '\\0';\n\t\tif ((fgets(buf, sizeof(buf), fp) == NULL) &&\n\t\t\t(errno == EINTR)) {\n\t\t\tsprintf(log_buffer, \"pbs_open(%s) interrupted\",\n\t\t\t\tcmd_get_val);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\tpbs_pclose(fp);\n\t\t\talarm(0);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tbuf[strlen(buf)-1] = '\\0';\n\t\tenv_val = (char *)buf;\n\t\tpbs_pclose(fp);\n\t\talarm(0);\n\t}\n\n\tif ((env_val == NULL) || *env_val ==  '\\0') {\n\t\tsprintf(log_buffer, \"Unable to obtain value for %s\",\n\t\t\tenv_var);\n\t\tlog_err(errno, __func__, log_buffer);\n\t\treturn (-1);\n\t}\n\n\tenv_str = (char *)malloc((size_t)(strlen(env_var) + strlen(env_val) + 2));\n\tif (env_str == NULL) {\n\t\tlog_err(-1, __func__, \"malloc failed\");\n\t\treturn (-1);\n\t}\n\tsetenv(env_var, env_val, 1);\n\n\treturn (0);\n}\n\n/**\n * @brief\n *\tadds restricted users uids to deny access to mom\n *\n * @param[in] user - user id\n *\n * @return\tVoid\n *\n */\nstatic void\nadd_restrict_user_exceptions(char *user)\n{\n\tstruct passwd \t*pwent;\n\tint\t\ti;\n\tint\t\tempty_slot;\n\tint\t\tfound_dbuser;\n\n\tif ((user == NULL) || (user[0] == '\\0'))\n\t\treturn;\n\n\tpwent = getpwnam(user);\n\tif (pwent == NULL) {\n\t\tsprintf(log_buffer, \"User %s not found\", user);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t\treturn;\n\t}\n\n\tfound_dbuser = 0;\n\tempty_slot = -1;\n\tfor (i=0; i < NUM_RESTRICT_USER_EXEMPT_UIDS; i++) {\n\t\tif (restrict_user_exempt_uids[i] == 0) {\n\t\t\tempty_slot = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (restrict_user_exempt_uids[i] == pwent->pw_uid) {\n\t\t\tfound_dbuser = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_dbuser && (empty_slot >= 0)) {\n\t\trestrict_user_exempt_uids[empty_slot] = pwent->pw_uid;\n\t\tsprintf(log_buffer,\n\t\t\t\"added restrict_user_exempt_uids[%d]=%d (user %s)\",\n\t\t\tempty_slot, restrict_user_exempt_uids[empty_slot], user);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\t\t/* terminate next slot */\n\t\tif ((empty_slot+1) < NUM_RESTRICT_USER_EXEMPT_UIDS) {\n\t\t\trestrict_user_exempt_uids[empty_slot+1] = 0;\n\t\t}\n\t}\n\n\tif (empty_slot == -1) {\n\t\tsprintf(log_buffer, \"can't add user %s, restrict_user_exempt_uids array is full (%d users allowed)! \", user, NUM_RESTRICT_USER_EXEMPT_UIDS);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t}\n}\n\n/**\n * @brief\n *\tset_bgl_environment:\n *\n * @return\tint\n * @retval\t0\tSuccess\n * @retval\t-1\tError\n *\n */\nstatic int\nset_bgl_environment()\n{\n\tif (setenv_if_not_exists(\"BRIDGE_CONFIG_FILE\",\n\t\tBRIDGE_CONFIG_FILE, 1, NULL) == -1) {\n\t\treturn (-1);\n\t}\n\tsprintf(log_buffer, \"BRIDGE_CONFIG_FILE=%s\",\n\t\tgetenv(\"BRIDGE_CONFIG_FILE\"));\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\tif (setenv_if_not_exists(\"DB_PROPERTY\", DB_PROPERTY, 1, NULL) == -1) {\n\t\treturn (-1);\n\t}\n\tsprintf(log_buffer, \"DB_PROPERTY=%s\", getenv(\"DB_PROPERTY\"));\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\tif (setenv_if_not_exists(\"MMCS_SERVER_IP\", mom_host, 0, NULL) == -1) {\n\t\treturn (-1);\n\t}\n\tsprintf(log_buffer, \"MMCS_SERVER_IP=%s\", getenv(\"MMCS_SERVER_IP\"));\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\tif (setenv_if_not_exists(\"DB2DIR\", NULL, 2, DB2DIR_GET_CMD) == -1) {\n\t\treturn (-1);\n\t}\n\tsprintf(log_buffer, \"DB2DIR=%s\", getenv(\"DB2DIR\"));\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\tif (setenv_if_not_exists(\"DB2INSTANCE\", NULL, 2,\n\t\tDB2INSTANCE_GET_CMD) == -1) {\n\t\treturn (-1);\n\t}\n\tsprintf(log_buffer, \"DB2INSTANCE=%s\", getenv(\"DB2INSTANCE\"));\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\n\tadd_restrict_user_exceptions(BGLADMIN);\n\tadd_restrict_user_exceptions(BGLCLIENT);\n\treturn (0);\n}\n#endif\t/* MOM_BGL */\n\n#ifndef NAS /* localmod 090 */\nunsigned linux_time = 0;\n#endif /* localmod 090 */\n/**\n * @brief\n * \tsupport routine for getting system time -- sets linux_time\n *\n * @return\tVoid\n *\n */\nvoid\nproc_get_btime(void)\n{\n\tFILE\t*fp;\n\tchar\tlabel[256];\n\n\n\tif ((fp = fopen(\"/proc/stat\", \"r\")) == NULL)\n\t\treturn;\n\n\twhile (!feof(fp)) {\n\t\tfscanf(fp, \"%s\", label);\n\t\tif (strcmp(label, \"btime\")) {\n\t\t\tfscanf(fp, \"%*[^\\n]%*c\");\n\t\t} else {\n\t\t\tfscanf(fp, \"%u\", &linux_time);\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn;\n}\n\nstatic char\tstat_str_pre[] =\n\"%%d \"\t\t/* 1  pid %d The process id */\n\"(%%[^)]) \"\t/* 2  comm %s The filename of the executable */\n\"%%c \"\t\t/* 3  state %c \"RSDZTW\" */\n\"%%d \"\t\t/* 4  ppid %d The PID of the parent */\n\"%%d \"\t\t/* 5  pgrp %d The process group ID */\n\"%%d \"\t\t/* 6  session %d The session ID */\n\"%%*d \"\t\t/* 7  ignored:  tty_nr */\n\"%%*d \"\t\t/* 8  ignored:  tpgid */\n\"%s \"\t\t/* 9  flags - %u or %lu */\n\"%%*lu \"\t/* 10 ignored:  minflt */\n\"%%*lu \"\t/* 11 ignored:  cminflt */\n\"%%*lu \"\t/* 12 ignored:  majflt */\n\"%%*lu \"\t/* 13 ignored:  cmajflt */\n\"%%lu \"\t\t/* 14 utime %lu */\n\"%%lu \"\t\t/* 15 stime %lu */\n\"%%ld \"\t\t/* 16 cutime %ld */\n\"%%ld \"\t\t/* 17 cstime %ld */\n\"%%*ld \"\t/* 18 ignored:  priority %ld */\n\"%%*ld \"\t/* 19 ignored:  nice %ld */\n\"%%*ld \"\t/* 20 ignored:  num_threads %ld */\n\"%%*ld \"\t/* 21 ignored:  itrealvalue %ld - no longer maintained */\n\"%%llu \"\t/* 22 starttime (was %lu before Linux 2.6 - see proc(5) for conversion details */\n\"%%lu \"\t\t/* 23 vsize (bytes) */\n\"%%ld \"\t\t/* 24 rss (number of pages) */\n  ;\n\n/**\n * @brief\n *\treturns the process memory (used,free,total).\n *\n * @return\tstructure handle\n * @retval\tpointer to proc_mem_t structure \tSuccess\n * @retval\tNULL\t\t\t\t\tError\n *\n */\nproc_mem_t *\nget_proc_mem(void)\n{\n\tstatic proc_mem_t\tmm;\n\tFILE\t\t\t*fp;\n\tulong\t\t\tm_tot, m_use, m_free;\n\tulong\t\t\ts_tot, s_use, s_free;\n\tchar\t\t\tstrbuf[BUFSIZ];\n\n\tif ((fp = fopen(\"/proc/meminfo\", \"r\")) == NULL)\n\t\treturn NULL;\n\n\n\tm_tot = m_free = s_tot = s_free = (ulong) 0;\n\twhile (fgets(strbuf, sizeof(strbuf), fp) != NULL) {\n\t\tsscanf(strbuf, \"MemTotal: %ld k\", &m_tot);\n\t\tsscanf(strbuf, \"MemFree: %ld k\", &m_free);\n\t\tsscanf(strbuf, \"SwapTotal: %ld k\", &s_tot);\n\t\tsscanf(strbuf, \"SwapFree: %ld k\", &s_free);\n\t}\n\n\t/* convert from kB to B */\n\tm_tot <<= 10;\n\tm_free <<= 10;\n\ts_tot <<= 10;\n\ts_free <<= 10;\n\tm_use = m_tot - m_free;\n\ts_use = s_tot - s_free;\n\n\tmm.total = m_tot + s_tot;\n\tmm.used = m_use + s_use;\n\tmm.free = m_free + s_free;\n\n\tfclose(fp);\n\treturn (&mm);\n}\n\n/**\n * @brief\n *\tCheck if attribute ATTR_NODE_TopologyInfo is in the global 'vnlp' structure.\n *\n * @return int\n * @retval 1\t- if ATTR_NODE_TopologyInfo is found as one of the entries in 'vnlp'.\n * @retval 0\t- otherwise, if not found or 'vnlp' is NULL.\n *\n */\nstatic int\nvnlp_has_topology_info(void) {\n\tint\ti, j;\n\n\tif (vnlp == NULL) {\n\t\treturn (0);\n\t}\n\n\tfor (i = 0; i < vnlp->vnl_used; i++) {\n\t\tvnal_t\t*vnalp;\n\n\t\tvnalp = VNL_NODENUM(vnlp, i);\n\n\t\tfor (j = 0; j < vnalp->vnal_used; j++) {\n\t\t\tvna_t\t*vnap;\n\n\t\t\tvnap = VNAL_NODENUM(vnalp, j);\n\t\t\tif (strcmp(vnap->vna_name, ATTR_NODE_TopologyInfo) == 0) {\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n\n/**\n * @brief\n * \tdep_topology - compute and export platform-dependent topology information\n *\n * @return\tvoid\n *\n * @par MT-Safe:\tno\n * @par Side Effects:\n *\tNone\n *\n * @par Note:\tnominally, we use the Open-MPI hardware locality (a.k.a. hwloc)\n *\t\tfunctions to export the topology information that it generates,\n *\t\tbut on Cray systems we instead export information via the\n *\t\talps_inventory() function.\n * @brief A synopsis of the function call sequence (for vnode creation).\n *\t  1. Process the System (BASIL 1.7) Query in alps_system_KNL(). This\n *\t  \tdoes not include KNL vnode creation.\n *\t  2. Process the Inventory (BASIL 1.4) Query in alps_inventory() and\n *\t\tcreate non-KNL vnodes.\n *\t  \tKNL vnodes returned by the earlier System Query (step 1) are\n *\t\tfiltered from the Inventory (1.4) response.\n *\t  3. Create KNL vnodes in system_to_vnodes_KNL(), using information\n *\t\tretrieved earlier in alps_system_KNL() (step 1).\n *\n * @see\talps_inventory\n * @see\tmom_topology\n * @see alps_system_KNL\n * @see system_to_vnodes_KNL\n */\nvoid\ndep_topology(void)\n{\n#if\tMOM_ALPS\n\t/* This function is the entry point for System Query processing. */\n\t/* Activities include making a System XML Request & handling the XML Response. */\n\talps_system_KNL();\n\t/*\n\t * The call to physmem needs to take place before the ALPS inventory\n\t * because a vnode for the \"login node\" will be created which\n\t * must have the memory set.\n\t */\n\t/* Inventory (BASIL 1.4) Query processing. */\n\t/* Create non-KNL vnodes. */\n\tif (alps_inventory() != -1 )\n\t{\n\t\t/* Create KNL VNodes. */\n\t\tsystem_to_vnodes_KNL();\n\t}\n#endif\n\tif (!vnlp_has_topology_info()) {\n\t\t/* Populate \"topology_info\", only if the attribute */\n\t\t/* has not been set inside alps_inventory(). */\n\t\tmom_topology();\n\t}\n}\n\n/**\n * @brief\n *\tinitialize the platform-dependent topology information\n *\n * @return\tVoid\n *\n */\nvoid\ndep_initialize(void)\n{\n#if\tMOM_BGL\n\tstatus_t\tst;\n\trm_serial_t\tmach_serial = NULL;\t/* BGL machine serial name */\n#endif\t/* MOM_BGL */\n#ifdef\tMOM_CPUSET\n\textern vnl_t\t\t*vnlp;\n\textern char\t\t*pbs_mach;\n\tstruct\tconfig\t\t*cptr;\n\textern\tstruct\tconfig\t*config_array;\n\n\t/*\n\t ** Set special name for \"arch\".\n\t */\n\tif (pbs_mach == NULL)\n\t\tpbs_mach = \"linux_cpuset\";\n\n\t/*\n\t **\tReset everything to default value\n\t */\n\tcpuset_create_flags =\tCPUSET_CREATE_FLAGS;\n\n\tmemreserved = 0;\n\tcpuset_destroy_delay = 0;\n\n\tfor (cptr = config_array; cptr != NULL; cptr ++) {\n\t\tif (cptr->c_name == NULL || *cptr->c_name == 0)\n\t\t\tbreak;\n\t\tif (strcasecmp(cptr->c_name, \"cpuset_create_flags\") == 0)\n\t\t\tset_cpuset_flags(cptr->c_u.c_value);\n\t\telse if (strcasecmp(cptr->c_name, \"cpuset_destroy_delay\") == 0) {\n\t\t\tcpusetvalue(cptr, \"s\", &cpuset_destroy_delay);\n\t\t}\n\t\telse if (strcasecmp(cptr->c_name, \"memreserved\") == 0) {\n\t\t\tcpusetvalue(cptr, \"mb\", &memreserved);\n\t\t\tif (memreserved > 0)\n\t\t\t\tadjust_memreserved(vnlp);\n\t\t}\n\t}\n#endif\t/* MOM_CPUSET */\n\n#if\tMOM_BGL\n\t/* Check Blue Gene environment */\n\tif (set_bgl_environment() == -1) {\n\t\tsprintf(log_buffer, \"Blue Gene Mom did not start, please provide values for the env variables %s in file %s\", BGL_ENVIRONMENT_VARS, pbs_conf.pbs_environment);\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__, log_buffer);\n\t\texit(1);\n\t}\n\n\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\"Starting as a Blue Gene MOM\");\n\n\tif ((st=rm_get_serial(&mach_serial)) != STATUS_OK) {\n\t\trm_serial_t serial = NULL;\n\n\t\tserial = bgl_read_machine_serial();\n\t\tif (serial == NULL) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"can't obtain BGL machine serial name! rm_get_serial: %s\", bglerror_to_txt(st));\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_NOTICE, \"dep_initialize\", log_buffer);\n\t\t\texit(1);\n\t\t}\n\n\t\tif ((st=rm_set_serial(serial)) != STATUS_OK) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"rm_set_serial: %s\", bglerror_to_txt(st));\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_NOTICE, \"dep_initialize\", log_buffer);\n\t\t\t(void)free(serial);\n\t\t\texit(1);\n\t\t}\n\t\t(void)free(serial);\n\t} else {\n\t\tif (mach_serial)\n\t\t\t(void)free(mach_serial);\n\t}\n\n\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\"Generating vnodes information...\");\n\n\tif ((bglvnodes=generate_bglvnodes_from_system()) == NULL) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_NOTICE, \"dep_initialize\",\n\t\t\t\"Failed to generate BGL vnodes list!\");\n\t\texit(1);\n\t}\n\n\tif (vn_create_bglvnodes(&vnlp, bglvnodes, NULL) == -1) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_NOTICE, \"dep_initialize\",\n\t\t\t\"Failed to create VN list to send to server!\");\n\t\texit(1);\n\t}\n\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\"finished vnodes generation\");\n#endif\t/* MOM_BGL */\n\n\tpagesize = getpagesize();\n\n\tif ((pdir = opendir(procfs)) == NULL) {\n\t\tlog_err(errno, __func__, \"opendir\");\n\t\treturn;\n\t}\n\n\tproc_get_btime();\n\n\t/*\n\t ** The global cpu counts are now set in ncpus()\n\t */\n\t(void)ncpus(NULL);\n\n#if\tMOM_CPUSET\n\tcpuset_nodes = numnodes();\n\tfree_job_CPUs = cpuset_free_job_CPUs;\n#endif\t/* MOM_CPUSET */\n\t(void)physmem(0);\t/* get memory info */\n\n\tdep_topology();\n}\n\n/**\n * @brief\n *\tclean up platform-dependent topology information\n *\n * @return\tVoid\n *\n */\nvoid\ndep_cleanup(void)\n{\n\tif (pdir) {\n\t\tclosedir(pdir);\n\t\tpdir = NULL;\n\t}\n\n#if\tMOM_BGL\n\tbgl_partition_free(bglpartitions);\n\tbglpartitions = NULL;\n\n\tbgl_partition_free(bglpartitions_down);\n\tbglpartitions_down = NULL;\n\n\tbgl_job_free(stuck_bgljobs);\n\tstuck_bgljobs = NULL;\n\n\tbgl_vnode_free(bglvnodes);\n\tbglvnodes = NULL;\n\n\tif (downed_bglvnodes) {\n\t\t(void)free(downed_bglvnodes);\n\t\tdowned_bglvnodes = NULL;\n\t}\n\n\tif (reserve_bglpartitions) {\n\t\t(void)free(reserve_bglpartitions);\n\t\treserve_bglpartitions = NULL;\n\t}\n#endif\n}\n\n/**\n * @brief\n *\tDon't need any periodic procsessing except in some special cases.\n *\n * @return\tVoid\n *\n */\nvoid\nend_proc(void)\n{\n#if\tMOM_BGL\n\tdb_job_id_t     bjid;\n\tchar\t\t*pbs_jobid;\n\tstruct bgl_job  *bgl_jobs = NULL;\n\tstruct bgl_partition *bgl_parts = NULL;\n\tstruct bgl_partition *bgl_parts_next = NULL;\n\tstruct bgl_partition *bgl_parts_bef = NULL;\n\tstruct bgl_job *stuckj = NULL;\n\tstruct bgl_job *stuckj_next = NULL;\n\tstruct bgl_job *stuckj_bef = NULL;\n\tint\t\tnum_unstuck = 0;\n\tint\t       num_part_up = 0;\n\tint \t       num_vns_down = 0;\n\tint\t       num_vns_up = 0;\n\trm_partition_state_t part_state;\n\tchar\t\t*vn_list;\n\tchar\t\t*down_vns = NULL;\n\n\t/* looked for \"downed\" partitions that now shows UP by */\n\t/* the system */\n\n\tnum_part_up = 0;\n\tbgl_parts_bef = NULL;\n\tfor (bgl_parts=bglpartitions_down; bgl_parts;\n\t\tbgl_parts=bgl_parts_next) {\n\n\t\tbgl_parts_next = bgl_parts->nextptr;\n\n\t\tpart_state = get_bgl_partition_state(bgl_parts->part_name);\n\t\tif ((part_state == RM_PARTITION_FREE) ||\n\t\t\t(part_state == RM_PARTITION_READY) ||\n\t\t\t(part_state == RM_PARTITION_CONFIGURING)) {\n\n\t\t\tvn_list = get_vnode_list_spanned_bypartition(\\\n\t\t\t\t \tbglvnodes, bgl_parts->part_name);\n\t\t\tif (vn_list) {\n\t\t\t\tset_bgl_vnodes_state(&bglvnodes, vn_list,\n\t\t\t\t\tBGLVN_FREE);\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"previously down vnodes marked FREE: %s\",\n\t\t\t\t\tvn_list);\n\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\t\tlog_buffer);\n\t\t\t\t(void)free(vn_list);\n\n\t\t\t\tif (bgl_parts->part_name) {\n\t\t\t\t\t(void)free(bgl_parts->part_name);\n\t\t\t\t}\n\n\t\t\t\tif (bgl_parts_bef == NULL) {\n\t\t\t\t\tbglpartitions_down = bgl_parts_next;\n\t\t\t\t} else {\n\t\t\t\t\tbgl_parts_bef->nextptr = bgl_parts_next;\n\t\t\t\t}\n\t\t\t\t(void)free(bgl_parts);\n\t\t\t\tnum_part_up++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbgl_parts_bef = bgl_parts;\n\t}\n\n\t/* check physical states of vnodes in the list of downed vnodes */\n\tif (downed_bglvnodes) {\n\t\tif ((down_vns=strdup(downed_bglvnodes))) {\n\t\t\tevaluate_vnodes_phys_state(&bglvnodes, down_vns,\n\t\t\t\t&num_vns_down, &num_vns_up, &downed_bglvnodes);\n\t\t\t(void)free(down_vns);\n\t\t}\n\t}\n\n\t/* Clear BGL jobs that were instantiated outside of PBS */\n\tif (restrict_user) {\n\t\tbgl_jobs = get_bgl_jobs();\n\n\t\tfor (bgl_parts=bglpartitions; bgl_parts;\n\t\t\tbgl_parts=bgl_parts->nextptr) {\n\n\n\n\t\t\tbjid = bgl_job_get_bgl_jobid(bgl_jobs,\n\t\t\t\tbgl_parts->part_name);\n\t\t\tpbs_jobid = bgl_job_get_pbs_jobid(bgl_jobs,\n\t\t\t\tbgl_parts->part_name);\n\n\t\t\t/* ignore free partitions (no BGL jobs running), or */\n\t\t\t/* partitions actively used by PBS, or */\n\t\t\t/* bjid matches one of the stuck jobs */\n\t\t\tif ((bjid == -1) || (pbs_jobid != NULL) ||\n\t\t\t\t(bgl_job_get_bgl_jobid(stuck_bgljobs,\n\t\t\t\tbgl_parts->part_name) == bjid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cancel_bgl_job(bjid, bgl_parts->part_name) == 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Cancelled BGL jobid=%d in partition %s\",\n\t\t\t\t\tbjid,\n\t\t\t\t\t(bgl_parts->part_name?bgl_parts->part_name:\"null\"));\n\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\t\tlog_buffer);\n\t\t\t}\n\t\t}\n\t\tbgl_job_free(bgl_jobs);\n\t}\n\n\t/* Attempt to cancel any stuck BGL jobs */\n\tnum_unstuck=0;\n\tstuckj_bef = NULL;\n\tfor (stuckj=stuck_bgljobs; stuckj; stuckj=stuckj_next) {\n\n\t\tstuckj_next = stuckj->nextptr;\n\n\t\tif (stuckj->bgl_jobid == -1)\n\t\t\tcontinue;\n\n\t\tif (cancel_bgl_job(stuckj->bgl_jobid,\n\t\t\tstuckj->partition) != -1) {\n\t\t\tchar\t*vn_list = NULL;\n\t\t\t/* can remove job from stuck list */\n\t\t\tsprintf(log_buffer, \"Cleared BGL job %d on part %s\",\n\t\t\t\tstuckj->bgl_jobid, stuckj->partition);\n\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\tlog_buffer);\n\t\t\tnum_unstuck++;\n\n\t\t\tvn_list = get_vnode_list_spanned_bypartition( \\\n\t\t\t\t\tbglvnodes, stuckj->partition);\n\t\t\tif (vn_list) {\n\t\t\t\tset_bgl_vnodes_state(&bglvnodes, vn_list,\n\t\t\t\t\tBGLVN_FREE);\n\t\t\t\tsprintf(log_buffer, \"vnodes marked FREE: %s\",\n\t\t\t\t\tvn_list);\n\t\t\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_DEBUG, __func__,\n\t\t\t\t\tlog_buffer);\n\t\t\t\t(void)free(vn_list);\n\n\t\t\t\t/* clear entry in stuck_bgljobs */\n\t\t\t\tif (stuckj->pbs_jobid) {\n\t\t\t\t\t(void)free(stuckj->pbs_jobid);\n\t\t\t\t}\n\t\t\t\tif (stuckj->partition) {\n\t\t\t\t\t(void)free(stuckj->partition);\n\t\t\t\t}\n\t\t\t\tif (stuckj_bef == NULL) {\n\t\t\t\t\tstuck_bgljobs = stuckj_next;\n\t\t\t\t} else {\n\t\t\t\t\tstuckj_bef->nextptr = stuckj_next;\n\t\t\t\t}\n\t\t\t\t(void)free(stuckj);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t}\n\n\t\tstuckj_bef = stuckj;\n\t}\n\n\tif ((num_part_up > 0) || (num_vns_down > 0) || (num_vns_up > 0) ||\n\t\tnum_unstuck > 0) {\n\t\t/* at least one partition that was previously */\n\t\t/* down is now up, or at least one BGL job was */\n\t\t/* unstuck */\n\t\tif (vn_create_bglvnodes(&vnlp, bglvnodes, NULL) == -1) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_NOTICE, __func__,\n\t\t\t\t\"Failed to create new VN list to send to server!\");\n\t\t}\n\t\tinternal_state_update = UPDATE_MOM_STATE;\n\t}\n\n#endif\t/* MOM_BGL */\n}\n\n/**\n * @brief\n *\t Scan a list of tasks and return true if one of them matches sid\n *\n * @param[in] pjob - job pointer\n * @param[in] sid - session id\n *\n * @return\tBool\n * @retval\tTRUE\n * @retval\tFALSE\tError\n *\n */\nstatic int\ninjob(job *pjob, pid_t sid)\n{\n\ttask\t*ptask;\n\n\tfor (ptask = (task *)GET_NEXT(pjob->ji_tasks);\n\t\tptask;\n\t\tptask = (task *)GET_NEXT(ptask->ti_jobtask)) {\n\t\tif (ptask->ti_qs.ti_sid <= 1)\n\t\t\tcontinue;\n\t\tif (ptask->ti_qs.ti_sid == sid)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/**\n * @brief\n * \tInternal session cpu time decoding routine.\n *\n * @param[in] job - a job pointer.\n *\n * @return\tulong\n * @retval\tsum of all cpu time consumed for all tasks executed by the job, in seconds,\n *\t\tadjusted by cputfactor.\n *\n */\nstatic ulong\ncput_sum(job *pjob)\n{\n\tint\t\ti;\n\tulong\t\tcputime = 0;\n\tint\t\tnps = 0;\n\tint\t\tactive_tasks = 0;\n\tint\t\ttaskprocs;\n\tproc_stat_t\t*ps;\n\ttask\t\t*ptask;\n\tulong\t\tpcput,tcput;\n\n\tfor (ptask = (task *)GET_NEXT(pjob->ji_tasks);\n\t\tptask != NULL;\n\t\tptask = (task *)GET_NEXT(ptask->ti_jobtask)) {\n\n\t\t/* DEAD task */\n\t\tif (ptask->ti_qs.ti_sid <= 1) {\n\t\t\tcputime += ptask->ti_cput;\n\t\t\tcontinue;\n\t\t}\n\n\t\tactive_tasks++;\n\t\ttcput = 0;\n\t\ttaskprocs = 0;\n\t\tfor (i=0; i<nproc; i++) {\n\t\t\tps = &proc_info[i];\n\n\t\t\t/* is this process part of the task? */\n\t\t\tif (ptask->ti_qs.ti_sid != ps->session)\n\t\t\t\tcontinue;\n\n\t\t\tnps++;\n\t\t\ttaskprocs++;\n\n\t\t\t/* don't include zombie unless it is the top proc */\n\t\t\tif ((ps->state == 'Z') && (ps->pid != ps->session) &&\n\t\t\t\t(ps->ppid != mom_pid))\n\t\t\t\tcontinue;\n\n\t\t\tpcput = (ps->utime + ps->stime +\n\t\t\t\tps->cutime + ps->cstime);\n\n\t\t\tif (pcput > num_oscpus * (sampletime_ceil + 1 - pjob->ji_qs.ji_stime) * CPUT_POSSIBLE_FACTOR ) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"cput for process %d impossible (%lds > %lds * %d), ignoring\",\n\t\t\t\t\tps->pid,\n\t\t\t\t\tpcput,\n\t\t\t\t\t(sampletime_ceil + 1 - pjob->ji_qs.ji_stime),\n\t\t\t\t\tnum_oscpus);\n\t\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\t\tlog_buffer);\n\t\t\t\tsampletime_floor = pjob->ji_qs.ji_stime;\n\t\t\t\tsampletime_ceil = pjob->ji_qs.ji_stime;\n\t\t\t\treturn 0;\n\n\t\t\t} else {\n\t\t\t\ttcput += pcput;\n\t\t\t}\n\n\t\t\tDBPRT((\"%s: task %8.8X ses %d pid %d cputime %lu\\n\",\n\t\t\t\t__func__, ptask->ti_qs.ti_task,\n\t\t\t\tps->session, ps->pid, tcput))\n\t\t}\n\t\tif (tcput > ptask->ti_cput)\n\t\t\tptask->ti_cput = tcput;\n\t\tcputime += ptask->ti_cput;\n\t\tDBPRT((\"%s: task %8.8X cput %lu total %lu\\n\", __func__,\n\t\t\tptask->ti_qs.ti_task, ptask->ti_cput, cputime))\n\n\t\tif (taskprocs == 0) {\n\t\t\t/*\n\t\t\t * Linux seems to be able to forget about a\n\t\t\t * process on rare occations.  See if the\n\t\t\t * kill system call can see it.\n\t\t\t */\n\t\t\tif (kill(ptask->ti_qs.ti_sid, 0) == 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"active processes for task %8.8X \"\n\t\t\t\t\t\"session %d exist but are not \"\n\t\t\t\t\t\"reported in /proc\",\n\t\t\t\t\tptask->ti_qs.ti_task,\n\t\t\t\t\t(int)ptask->ti_qs.ti_sid);\n\t\t\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB,\n\t\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\t\tlog_buffer);\n\t\t\t\t/*\n\t\t\t\t * Fake a non-zero nps so the job is not killed.\n\t\t\t\t */\n\t\t\t\tnps++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Don't declare a running task exited without a small\n\t\t\t * grace time.\n\t\t\t */\n\t\t\tif ((ptask->ti_qs.ti_status == TI_STATE_RUNNING) &&\n\t\t\t\t((time_now - pjob->ji_qs.ji_stime) < 10)) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"no active processes for task %8.8X \"\n\t\t\t\t\t\"session %d exist but the job is\"\n\t\t\t\t\t\"only %ld secs old\",\n\t\t\t\t\tptask->ti_qs.ti_task,\n\t\t\t\t\t(int)ptask->ti_qs.ti_sid,\n\t\t\t\t\ttime_now - pjob->ji_qs.ji_stime);\n\t\t\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB,\n\t\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\t\tlog_buffer);\n\t\t\t\t/*\n\t\t\t\t * Fake a non-zero nps so the job is not killed.\n\t\t\t\t */\n\t\t\t\tnps++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"no active process for task %8.8X\",\n\t\t\t\tptask->ti_qs.ti_task);\n\t\t\tlog_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,\n\t\t\t\tLOG_INFO, pjob->ji_qs.ji_jobid,\n\t\t\t\tlog_buffer);\n\t\t\tptask->ti_qs.ti_status = TI_STATE_EXITED;\n\t\t\ttask_save(ptask);\n\t\t\texiting_tasks = 1;\n\t\t}\n\t}\n\n\tif (active_tasks == 0) {\n\t\tsprintf(log_buffer, \"no active tasks\");\n\t\tlog_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,\n\t\t\tLOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);\n\t}\n\tif (nps == 0)\n\t\tpjob->ji_flags |= MOM_NO_PROC;\n\n\tif (cputime > num_oscpus * (sampletime_ceil + 1 - pjob->ji_qs.ji_stime) * CPUT_POSSIBLE_FACTOR ) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"cput for job impossible (%lds > %lds * %d), ignoring\",\n\t\t\t\t\tcputime,\n\t\t\t\t\t(sampletime_ceil + 1 - pjob->ji_qs.ji_stime),\n\t\t\t\t\tnum_oscpus);\n\n\t\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\t\tlog_buffer);\n\t\t\t\tsampletime_floor = pjob->ji_qs.ji_stime;\n\t\t\t\tsampletime_ceil = pjob->ji_qs.ji_stime;\n\t\t\t\treturn 0;\n\t}\n\n\treturn ((ulong)((double)cputime * cputfactor));\n}\n\n/**\n * @brief\n * \tInternal session memory usage function.\n *\n * @param[in] job - job pointer\n *\n * @return\tulong\n * @retval\tthe total number of bytes of address\n *\t\tspace consumed by all current processes within the job.\n *\n */\nstatic ulong\nmem_sum(job *pjob)\n{\n\tint\t\ti;\n\tulong\t\tsegadd;\n\tproc_stat_t\t*ps;\n\n\tsegadd = 0;\n\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\n\t\tif (!injob(pjob, ps->session))\n\t\t\tcontinue;\n\t\tsegadd += ps->vsize;\n\t\tDBPRT((\"%s: pid: %d  pr_size: %lu  total: %lu\\n\",\n\t\t\t__func__, ps->pid, (ulong)ps->vsize, segadd))\n\t}\n\n\treturn (segadd);\n}\n\n/**\n * @brief\n * \tInternal session workingset size function.\n *\n * @param[in] pjob - job pointer\n *\n * @return\tulong\n * @retval\tnew resident set size \tSuccess\n * @retval\told resident set size\tError\n *\n */\nstatic ulong\nresi_sum(job *pjob)\n{\n\tint\t\ti;\n\tulong\t\tresisize;\n\tlong\t\twm;\t\t/* Altix weighted RSS replacement */\n\tproc_stat_t\t*ps;\n\n\tresisize = 0;\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\n\t\tif (!injob(pjob, ps->session))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t *\tCertain Altix ProPack releases (or patches) add an\n\t\t *\tinterface to replace the value reported by /proc via\n\t\t *\tthe RSS field in the process's stat file.  If the\n\t\t *\tvalue is available, we use it;  if get_wm() returns\n\t\t *\t-1 indicating an error, we proceed using the old rss\n\t\t *\tvalue that we read from /proc/<pid>/stat.\n\t\t */\n\t\tif ((wm = get_wm(ps->pid)) != -1)\n\t\t\tps->rss = wm;\n\t\tresisize += ps->rss * pagesize;\n\t}\n\n\treturn (resisize);\n}\n\n/**\n * @brief\n * \tEstablish system-enforced limits for the job.\n *\n *\tRun through the resource list, checking the values for all items\n *\twe recognize.\n *\n * @param[in] pjob - job pointer\n * @param[in]  set_mode\t- setting mode\n *\n *\tIf set_mode is SET_LIMIT_SET, then also set hard limits for the\n *\t\t\t  system enforced limits (not-polled).\n *\tIf anything goes wrong with the process, return a PBS error code\n *\tand print a message on standard error.  A zero-length resource list\n *\tis not an error.\n *\n *\tIf set_mode is SET_LIMIT_SET the entry conditions are:\n *\t    1.\tMOM has already forked, and we are called from the child.\n *\t    2.\tThe child is still running as root.\n *\t    3.  Standard error is open to the user's file.\n *\n *\tIf set_mode is SET_LIMIT_ALTER, we are beening called to modify\n *\texisting limits.  Cannot alter those set by setrlimit (kernel)\n *\tbecause we are the wrong process.\n *\n * @return\tint\n * @retval\tPBSE_NONE\tSuccess\n * @retval\tPBSE_*\t\tError\n *\n */\nint\nmom_set_limits(job *pjob, int set_mode)\n{\n\tchar\t\t*pname;\n\tint\t\tretval;\n\tulong\t\tvalue;\t/* place in which to build resource value */\n\tresource\t*pres;\n\tstruct rlimit\treslim;\n\tulong\t\tmem_limit = 0;\n\tulong\t\tvmem_limit = 0;\n\tulong\t\tcput_limit = 0;\n\n\tDBPRT((\"%s: entered\\n\", __func__))\n\tassert(pjob != NULL);\n\tassert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);\n\tpres = (resource *)\n\t\tGET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);\n\n\t/*\n\t * Cycle through all the resource specifications,\n\t * setting limits appropriately.\n\t */\n\n\t/* mem and vmem limits come from the local node limits, not the job */\n\tmem_limit = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_mem << 10;\n\tvmem_limit = pjob->ji_hosts[pjob->ji_nodeid].hn_nrlimit.rl_vmem << 10;\n\n\twhile (pres != NULL) {\n\t\tassert(pres->rs_defin != NULL);\n\t\tpname = pres->rs_defin->rs_name;\n\t\tassert(pname != NULL);\n\t\tassert(*pname != '\\0');\n\n\t\tif (strcmp(pname, \"cput\") == 0 ||\n\t\t\tstrcmp(pname, \"pcput\") == 0) {\n\t\t\tretval = local_gettime(pres, &value);\n\t\t\tif (retval != PBSE_NONE)\n\t\t\t\treturn (error(pname, retval));\n\t\t\tif ((cput_limit == 0) || (value < cput_limit))\n\t\t\t\tcput_limit = value;\n\t\t} else if (strcmp(pname, \"pvmem\") == 0) {\n\t\t\tretval = local_getsize(pres, &value);\n\t\t\tif (retval != PBSE_NONE)\n\t\t\t\treturn (error(pname, retval));\n\t\t\tif ((vmem_limit == 0) || (value < vmem_limit))\n\t\t\t\tvmem_limit = value;\n\t\t} else if (strcmp(pname, \"pmem\") == 0) {\t/* set */\n\t\t\tretval = local_getsize(pres, &value);\n\t\t\tif (retval != PBSE_NONE)\n\t\t\t\treturn (error(pname, retval));\n\t\t\tif ((mem_limit == 0) || (value < mem_limit))\n\t\t\t\tmem_limit = value;\n\t\t} else if (strcmp(pname, \"walltime\") == 0) {\t/* Check */\n\t\t\tretval = local_gettime(pres, &value);\n\t\t\tif (retval != PBSE_NONE)\n\t\t\t\treturn (error(pname, retval));\n\t\t} else if (strcmp(pname, \"nice\") == 0) {\t/* set nice */\n\t\t\tif (set_mode == SET_LIMIT_SET) {\n\t\t\t\terrno = 0;\n\t\t\t\tif ((nice((int)pres->rs_value.at_val.at_long) == -1)\n\t\t\t\t\t&& (errno != 0))\n\t\t\t\t\treturn (error(pname, PBSE_BADATVAL));\n\t\t\t}\n\t\t} else if (strcmp(pname, \"file\") == 0) {\t/* set */\n\t\t\tif (set_mode == SET_LIMIT_SET) {\n\t\t\t\tretval = local_getsize(pres, &value);\n\t\t\t\tif (retval != PBSE_NONE)\n\t\t\t\t\treturn (error(pname, retval));\n\t\t\t\treslim.rlim_cur = reslim.rlim_max = value;\n\t\t\t\tif (setrlimit(RLIMIT_FSIZE, &reslim) < 0)\n\t\t\t\t\treturn (error(pname, PBSE_SYSTEM));\n\t\t\t}\n\t\t}\n\t\tpres = (resource *)GET_NEXT(pres->rs_link);\n\t}\n\n\tif (set_mode == SET_LIMIT_SET) {\n\t\t/* if either vmem or pvmem was given, set sys limit to lesser */\n\t\tif (vmem_limit != 0) {\n\t\t\treslim.rlim_cur = reslim.rlim_max = vmem_limit;\n\t\t\tif (setrlimit(RLIMIT_AS, &reslim) < 0)\n\t\t\t\treturn (error(\"RLIMIT_AS\", PBSE_SYSTEM));\n\t\t}\n\n\t\t/* if either mem or pmem was given, set sys limit to lesser */\n\t\tif (mem_limit != 0) {\n\t\t\treslim.rlim_cur = reslim.rlim_max = mem_limit;\n\t\t\tif (setrlimit(RLIMIT_RSS, &reslim) < 0)\n\t\t\t\treturn (error(\"RLIMIT_RSS\", PBSE_SYSTEM));\n\t\t}\n\n\t\t/* if either cput or pcput was given, set sys limit to lesser */\n\t\tif (cput_limit != 0) {\n\t\t\treslim.rlim_cur = reslim.rlim_max =\n\t\t\t\t(ulong)((double)cput_limit / cputfactor);\n\t\t\tif (setrlimit(RLIMIT_CPU, &reslim) < 0)\n\t\t\t\treturn (error(\"RLIMIT_CPU\", PBSE_SYSTEM));\n\t\t}\n\t}\n\treturn (PBSE_NONE);\n}\n\n/**\n * @brief\n * \tState whether MOM main loop has to poll this job to determine if some\n * \tlimits are being exceeded.\n *\n * @param[in] pjob - job pointer\n *\n * @return\tint\n * @retval\tTRUE\tif polling is necessary\n * @retval\tFALSE \totherwise.\n *\n * NOTE: Actual polling is done using the mom_over_limit machine-dependent function.\n *\n */\nint\nmom_do_poll(job *pjob)\n{\n\tchar\t\t*pname;\n\tresource\t*pres;\n\n\tDBPRT((\"%s: entered\\n\", __func__))\n\tassert(pjob != NULL);\n\tassert(pjob->ji_wattr[(int)JOB_ATR_resource].at_type == ATR_TYPE_RESC);\n\tpres = (resource *)\n\t\tGET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);\n\n\twhile (pres != NULL) {\n\t\tassert(pres->rs_defin != NULL);\n\t\tpname = pres->rs_defin->rs_name;\n\t\tassert(pname != NULL);\n\t\tassert(*pname != '\\0');\n\n\t\tif (strcmp(pname, \"walltime\") == 0 ||\n\t\t\tstrcmp(pname, \"cput\") == 0 ||\n\t\t\tstrcmp(pname, \"mem\") == 0 ||\n\t\t\tstrcmp(pname, \"vmem\") == 0 ||\n\t\t\tstrcmp(pname, \"ncpus\") == 0)\n\t\t\treturn (TRUE);\n\t\tpres = (resource *)GET_NEXT(pres->rs_link);\n\t}\n\n\treturn (FALSE);\n}\n\n/**\n * @brief\n * \tSetup for polling.\n *\tOpen kernel device and get namelist info.\n *\n * @return\tint\n * @retval\tPBSE_NONE\t\tSuccess\n * @retval\tPBSE_SYSTEM\t\tError\n *\n */\nint\nmom_open_poll(void)\n{\n\tDBPRT((\"%s: entered\\n\", __func__))\n\tpagesize = getpagesize();\n\tproc_info = (proc_stat_t *)malloc(sizeof(proc_stat_t) * TBL_INC);\n\tif (proc_info == NULL) {\n\t\tlog_err(errno, __func__, \"malloc\");\n\t\treturn (PBSE_SYSTEM);\n\t}\n\tmax_proc = TBL_INC;\n\n\treturn (PBSE_NONE);\n}\n\n/**\n * @brief\n * \tDeclare start of polling loop.\n *\n * @return\tint\n * @retval\tPBSE_INTERNAL\tDir pdir in NULL\n * @retval\tPBSE_NONE\tSuccess\n *\n */\nint\nmom_get_sample(void)\n{\n\tstruct dirent\t\t*dent = NULL;\n\tFILE\t\t\t*fd = NULL;\n\tstatic char\t\tpath[MAXPATHLEN + 1];\n\tchar\t\t\tprocname[384]; /* space for dent->d_name plus extra */\n\tstruct stat\t\tsb;\n\tproc_stat_t\t\t*ps = NULL;\n#if MOM_CPUSET\n\tpidcachetype_t\t\t*pidcache = NULL;\n#endif\t/* MOM_CPUSET */\n\tint\t\t\tnprocs = 0;\n\tint\t\t\tncached = 0;\n\tint\t\t\tncantstat = 0;\n\tint\t\t\tnnomem = 0;\n\tunsigned long long \tstarttime;\n\tint\t\t\tnskipped = 0;\n\textern time_t\t\ttime_last_sample;\n\tchar\t\t\t*stat_str = NULL;\n\n\tDBPRT((\"%s: entered\\n\", __func__))\n\tif (pdir == NULL)\n\t\treturn PBSE_INTERNAL;\n\n#if MOM_CPUSET\n\tif (((pidcache = pidcache_getarena()) == NULL) && pidcache_needed()) {\n\t\tif ((pidcache = pidcache_create()) == NULL)\n\t\t\tlog_err(errno, __func__, \"PID cache create\");\n\t\tif ((pidcache != NULL) && (ncached = pidcache_reset(pidcache)) == -1) {\n\t\t\tncached = 0;\n\t\t\tlog_err(errno, __func__, \"PID cache reset\");\n\t\t}\n\t}\n#endif /* MOM_CPUSET */\n\trewinddir(pdir);\n\tnproc = 0;\n\tfd = NULL;\n\tif (hz == 0)\n\t\thz = sysconf(_SC_CLK_TCK);\n\ttime_last_sample = time(0);\n\tsampletime_floor = time_last_sample;\n\twhile (errno = 0, (dent = readdir(pdir)) != NULL) {\n\t\tint\tnomem = 0;\n\n\t\tnprocs++;\n\n\t\t/*\n\t\t ** Check to see if we have /proc/pid or /proc/.pid\n\t\t */\n\t\tif (!isdigit(dent->d_name[0])) {\n\t\t\tif (dent->d_name[0] == '.' && isdigit(dent->d_name[1])) {\n\t\t\t\tnomem = 1;\n\t\t\t\tnnomem++;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n#if MOM_CPUSET\n\t\t{\n\t\t\tpid_t\tp;\n\t\t\tp = strtol(dent->d_name, NULL, 10);\n\t\t\tif ((pidcache != NULL) && pidcache_check(p, pidcache) == 0) {\n\t\t\t\tnskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\t/* MOM_CPUSET */\n\t\tsprintf(procname, \"/proc/%s/stat\", dent->d_name);\n\n\t\tif ((fd = fopen(procname, \"r\")) == NULL) {\n\t\t\tncantstat++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tps = &proc_info[nproc];\n\t\tstat_str = choose_procflagsfmt();\n\t\tif (stat_str == NULL) {\n\t\t\tlog_err(errno, __func__, \"choose_procflagsfmt allocation failed\");\n\t\t\treturn PBSE_INTERNAL;\n\t\t}\n\t\tif (fscanf(fd, stat_str,\n\t\t\t   &ps->pid,\t\t/* \"%d \"\t1  pid %d The process id */\n\t\t\t   path,\t\t/* \"(%[^)]) \"\t2  comm %s The filename of the executable */\n\t\t\t   &ps->state,\t\t/* \"%c \"\t3  state %c \"RSDZTW\" */\n\t\t\t   &ps->ppid,\t\t/* \"%d \"\t4  ppid %d The PID of the parent */\n\t\t\t   &ps->pgrp,\t\t/* \"%d \"\t5  pgrp %d The process group ID */\n\t\t\t   &ps->session,\t/* \"%d \"\t6  session %d The session ID */\n\t\t\t\t   \t\t/* \"%*d \"\t7  ignored:  tty_nr */\n\t \t\t   \t\t\t/* \"%*d \"\t8  ignored:  tpgid */\n\t\t\t   &ps->flags,\t\t/* \"%u or %lu\"\t9  flags */\n\t\t\t\t\t   \t/* \"%*lu \"\t10 ignored:  minflt */\n\t\t\t\t\t   \t/* \"%*lu \"\t11 ignored:  cminflt */\n\t\t\t\t\t   \t/* \"%*lu \"\t12 ignored:  majflt */\n\t\t\t\t\t   \t/* \"%*lu \"\t13 ignored:  cmajflt */\n\t\t\t   &ps->utime,\t\t/* \"%lu \"\t14 utime %lu */\n\t\t\t   &ps->stime,\t\t/* \"%lu \"\t15 stime %lu */\n\t\t\t   &ps->cutime,\t\t/* \"%ld \"\t16 cutime %ld */\n\t\t\t   &ps->cstime,\t\t/* \"%ld \"\t17 cstime %ld */\n\t\t\t\t   \t\t/* \"%*ld \"\t18 ignored:  priority %ld */\n\t\t\t   \t\t\t/* \"%*ld \"\t19 ignored:  nice %ld */\n\t\t\t   \t\t\t/* \"%*ld \"\t20 ignored:  num_threads %ld */\n\t\t\t   \t\t\t/* \"%*ld \"\t21 ignored:  itrealvalue %ld - no longer maintained */\n\t\t\t   &starttime,\t\t/* \"%llu \"\t22 starttime (was %lu before Linux 2.6 - see proc(5) for conversion details */\n\t\t\t   &ps->vsize,\t\t/* \"%lu \"\t23 vsize (bytes) */\n\t\t\t   &ps->rss\t\t/* \"%ld \"\t24 rss (number of pages) */\n\t\t\t) != 14) {\n\t\t\tncantstat++;\n\t\t\tfclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fstat(fileno(fd), &sb) == -1) {\n\t\t\tfclose(fd);\n\t\t\tcontinue;\n\t\t}\n\t\tps->uid = sb.st_uid;\n\t\tfclose(fd);\n\n\t\t/*\n\t\t ** A .pid thread shows the memory of the process\n\t\t ** but we only want to count it once.\n\t\t */\n\t\tif (nomem) {\n\t\t\tps->vsize = 0;\n\t\t\tps->rss = 0;\n\t\t}\n\n\t\tps->start_time = linux_time + (starttime / hz);\n\t\tsnprintf(ps->comm, sizeof(ps->comm), \"%.*s\",\n\t\t\t(int)(sizeof(ps->comm) - 1), path);\n\n\t\tps->utime = JTOS(ps->utime);\n\t\tps->stime = JTOS(ps->stime);\n\t\tps->cutime = JTOS(ps->cutime);\n\t\tps->cstime = JTOS(ps->cstime);\n\t\tif (++nproc == max_proc) {\n\t\t\tvoid\t*hold;\n\t\t\tDBPRT((\"%s: alloc more proc table space %d\\n\", __func__, nproc))\n\t\t\tmax_proc += TBL_INC;\n\t\t\thold = realloc((void *)proc_info,\n\t\t\t\tmax_proc*sizeof(proc_stat_t));\n\t\t\tassert(hold != NULL);\n\t\t\tproc_info = (proc_stat_t *)hold;\n\t\t}\n\t}\n\tif (errno != 0 && errno != ENOENT)\n\t\tlog_err(errno, __func__, \"readdir\");\n\tsampletime_ceil = time_last_sample;\n\tsprintf(log_buffer,\n\t\t\"nprocs:  %d, cantstat:  %d, nomem:  %d, skipped:  %d, \"\n\t\t\"cached:  %d\",\n\t\tnprocs - 2, ncantstat, nnomem, nskipped,\n\t\tncached);\n\tlog_event(PBSEVENT_DEBUG4, 0, LOG_DEBUG, __func__, log_buffer);\n#if MOM_CPUSET\n\tif (pidcache != NULL)\n\t\tpidcache_destroy();\n#endif\t/* MOM_CPUSET */\n\treturn (PBSE_NONE);\n}\n\n/**\n * @brief\n * \tUpdate the resources used.<attributes> of a job.\n *\n * @param[in]\tpjob - job in question.\n *\n * @note\n *\tThe first time this is called for a job, set up resource entries for\n *\teach resource that can be reported for this machine.  Fill in the\n *\tcorrect values.\n *\tIf a resource attribute has been set in a mom hook, then its value\n *\twill not be updated here. This allows a mom  hook to override\n *\tresource value.\n *\n * @return int\n * @retval PBSE_NONE\tfor success.\n */\nint\nmom_set_use(job *pjob)\n{\n\tresource\t*pres;\n\tresource\t*pres_req;\n\tattribute\t*at;\n\tattribute\t*at_req;\n\tresource_def\t*rd;\n\tu_Long \t\t*lp_sz, lnum_sz;\n\tulong\t\t*lp, lnum, oldcput;\n\tlong\t\tncpus_req;\n\n\tassert(pjob != NULL);\n\tat = &pjob->ji_wattr[(int)JOB_ATR_resc_used];\n\tassert(at->at_type == ATR_TYPE_RESC);\n\n\tif ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_Suspend) != 0)\n\t\treturn (PBSE_NONE);\t/* job suspended, don't track it */\n\n\tDBPRT((\"%s: entered %s\\n\", __func__, pjob->ji_qs.ji_jobid))\n\n\tat->at_flags |= (ATR_VFLAG_MODIFY|ATR_VFLAG_SET);\n\n\trd = find_resc_def(svr_resc_def, \"ncpus\", svr_resc_size);\n\tassert(rd != NULL);\n\tpres = find_resc_entry(at, rd);\n\tif (pres == NULL) {\n\t\tpres = add_resource_entry(at, rd);\n\t\tpres->rs_value.at_flags |= ATR_VFLAG_SET;\n\t\tpres->rs_value.at_type = ATR_TYPE_LONG;\n\n\t\t/*\n\t\t * get pointer to list of resources *requested* for the job\n\t\t * so the ncpus used can be set to ncpus requested\n\t\t */\n\t\tat_req = &pjob->ji_wattr[(int)JOB_ATR_resource];\n\t\tassert(at->at_type == ATR_TYPE_RESC);\n\n\t\tpres_req = find_resc_entry(at_req, rd);\n\t\tif ((pres_req != NULL) &&\n\t\t\t((ncpus_req=pres_req->rs_value.at_val.at_long) !=0))\n\t\t\t\tpres->rs_value.at_val.at_long = ncpus_req;\n\t\telse\n\t\t\tpres->rs_value.at_val.at_long = 0;\n\n\t}\n\n\trd = find_resc_def(svr_resc_def, \"cput\", svr_resc_size);\n\tassert(rd != NULL);\n\tpres = find_resc_entry(at, rd);\n\tif (pres == NULL) {\n\t\tpres = add_resource_entry(at, rd);\n\t\tpres->rs_value.at_flags |= ATR_VFLAG_SET;\n\t\tpres->rs_value.at_type = ATR_TYPE_LONG;\n\t\tpres->rs_value.at_val.at_long = 0;\n\t}\n\tlp = (ulong *)&pres->rs_value.at_val.at_long;\n\toldcput = *lp;\n\tlnum = cput_sum(pjob);\n\tlnum = MAX(*lp, lnum);\n\tif ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {\n\t\t/* don't conflict with hook setting a value */\n\t\t*lp = lnum;\n\t}\n\n\trd = find_resc_def(svr_resc_def, \"cpupercent\", svr_resc_size);\n\tassert(rd != NULL);\n\tpres = find_resc_entry(at, rd);\n\tif (pres == NULL) {\n\t\tpres = add_resource_entry(at, rd);\n\t\tpres->rs_value.at_flags |= ATR_VFLAG_SET;\n\t\tpres->rs_value.at_type = ATR_TYPE_LONG;\n\t\tpres->rs_value.at_val.at_long = 0;\n\t}\n\tif ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {\n\t\t/* now calculate weighted moving average cpu usage */\n\t\t/* percentage */\n\t\tcalc_cpupercent(pjob, oldcput, lnum, sampletime_ceil);\n\t}\n\tpjob->ji_sampletim = sampletime_floor;\n\n\trd = find_resc_def(svr_resc_def, \"vmem\", svr_resc_size);\n\tassert(rd != NULL);\n\tpres = find_resc_entry(at, rd);\n\tif (pres == NULL) {\n\t\tpres = add_resource_entry(at, rd);\n\t\tpres->rs_value.at_flags |= ATR_VFLAG_SET;\n\t\tpres->rs_value.at_type = ATR_TYPE_SIZE;\n\t\tpres->rs_value.at_val.at_size.atsv_shift = 10;\t/* KB */\n\t\tpres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;\n\t} else if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {\n\t\tlp_sz = &pres->rs_value.at_val.at_size.atsv_num;\n\t\tlnum_sz = (mem_sum(pjob) + 1023) >> 10;\t\t/* as KB */\n\t\t*lp_sz = MAX(*lp_sz, lnum_sz);\n\t}\n\n\t/* update walltime usage */\n\tupdate_walltime(pjob);\n\n\trd = find_resc_def(svr_resc_def, \"mem\", svr_resc_size);\n\tassert(rd != NULL);\n\tpres = find_resc_entry(at, rd);\n\tif (pres == NULL) {\n\t\tpres = add_resource_entry(at, rd);\n\t\tpres->rs_value.at_flags |= ATR_VFLAG_SET;\n\t\tpres->rs_value.at_type = ATR_TYPE_SIZE;\n\t\tpres->rs_value.at_val.at_size.atsv_shift = 10;\t/* KB */\n\t\tpres->rs_value.at_val.at_size.atsv_units = ATR_SV_BYTESZ;\n\t} else if ((pres->rs_value.at_flags & ATR_VFLAG_HOOK) == 0) {\n\t\tlp_sz = &pres->rs_value.at_val.at_size.atsv_num;\n\t\tlnum_sz = (resi_sum(pjob) + 1023) >> 10; /* as KB */\n\t\t*lp_sz = MAX(*lp_sz, lnum_sz);\n\t}\n\n\treturn (PBSE_NONE);\n}\n\n/**\n * @brief\n * \tbld_ptree - establish links (parent, child, and sibling) for processes\n * \tin a given session.\n *\n *\tThe PBS_PROC_* macros are defined in resmom/.../mom_mach.h\n *\tto refer to the correct machine dependent table.\n *\tLinkage scope changed from static to default as this gets referred\n *\tfrom scan_for_terminated(), declaration\tadded in the mom_mach.h.\n *\n * @param[in] sid - session id\n *\n * @return\tint\n * @retval\tnumber of processes in session\tSuccess\n *\n */\nint\nbld_ptree(pid_t sid)\n{\n\tint\tmyproc_ct;\t\t/* count of processes in a session */\n\tint\ti, j;\n\n\tif (Proc_lnks == NULL) {\n\t\tProc_lnks = (pbs_plinks *)malloc(TBL_INC * sizeof(pbs_plinks));\n\t\tassert(Proc_lnks != NULL);\n\t\tmyproc_max = TBL_INC;\n\t}\n\n\t/*\n\t * Build links for processes in the session in question.\n\t * First, load with the processes in the session.\n\t */\n\n\tmyproc_ct = 0;\n\tfor (i = 0; i < nproc; i++) {\n\t\tif (PBS_PROC_PID(i) <= 1)\n\t\t\tcontinue;\n\t\tif ((int)PBS_PROC_SID(i) == sid) {\n\t\t\tProc_lnks[myproc_ct].pl_pid = PBS_PROC_PID(i);\n\t\t\tProc_lnks[myproc_ct].pl_ppid = PBS_PROC_PPID(i);\n\t\t\tProc_lnks[myproc_ct].pl_parent = -1;\n\t\t\tProc_lnks[myproc_ct].pl_sib = -1;\n\t\t\tProc_lnks[myproc_ct].pl_child = -1;\n\t\t\tProc_lnks[myproc_ct].pl_done = 0;\n\t\t\tif (++myproc_ct == myproc_max) {\n\t\t\t\tvoid * hold;\n\n\t\t\t\tmyproc_max += TBL_INC;\n\t\t\t\thold = realloc((void *)Proc_lnks,\n\t\t\t\t\tmyproc_max*sizeof(pbs_plinks));\n\t\t\t\tassert(hold != NULL);\n\t\t\t\tProc_lnks = (pbs_plinks *)hold;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Now build the tree for those processes */\n\n\tfor (i = 0; i < myproc_ct; i++) {\n\t\t/*\n\t\t * Find all the children for this process, establish links.\n\t\t */\n\t\tfor (j = 0; j < myproc_ct; j++) {\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\t\t\tif (Proc_lnks[j].pl_ppid == Proc_lnks[i].pl_pid) {\n\t\t\t\tProc_lnks[j].pl_parent = i;\n\t\t\t\tProc_lnks[j].pl_sib = Proc_lnks[i].pl_child;\n\t\t\t\tProc_lnks[i].pl_child = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn (myproc_ct);\t/* number of processes in session */\n}\n\n/**\n * @brief\n * \tkill_ptree - traverse the process tree, killing the processes as we go\n *\n * @param[in]\tidx:\tcurrent pid index\n * @param[in]\tflag:\ttraverse order, top down (1) or bottom up (0)\n * @param[in]\tsig:\tthe signal to send\n *\n * @return\tVoid\n *\n */\nstatic void\nkill_ptree(int idx, int flag, int sig)\n{\n\tpid_t\tchild;\n\n\tif (flag && !Proc_lnks[idx].pl_done) {\t\t/* top down */\n\t\tDBPRT((\"%s: top down %d\\n\", __func__, Proc_lnks[idx].pl_pid));\n\t\t(void)kill(Proc_lnks[idx].pl_pid, sig);\n\t\tProc_lnks[idx].pl_done = 1;\n\t}\n\tchild = Proc_lnks[idx].pl_child;\n\twhile (child != -1) {\n\t\tkill_ptree(child, flag, sig);\n\t\tchild = Proc_lnks[child].pl_sib;\n\t}\n\tif (!flag && !Proc_lnks[idx].pl_done) {\t\t/* bottom up */\n\t\tDBPRT((\"%s: bottom up %d\\n\", __func__, Proc_lnks[idx].pl_pid));\n\t\t(void)kill(Proc_lnks[idx].pl_pid, sig);\n\t\tProc_lnks[idx].pl_done = 1;\n\t}\n}\n/**\n * @brief\n *\tkill task session\n *\n * @param[in] ptask - pointer to pbs_task structure\n * @param[in] sig - signal number\n * @param[in] dir - indication how to kill\n *\t\t    0 - kill child first\n *\t\t    1 - kill parent first\n *\n * @return\tint\n * @retval\tnumber of tasks\n *\n */\nint\nkill_task(pbs_task *ptask, int sig, int dir)\n{\n\treturn kill_session(ptask->ti_qs.ti_sid, sig, dir);\n}\n\n/**\n * @brief\n *\tKill a task session.\n *\tCall with the task pointer and a signal number.\n *\n * @param[in] sesid - session id\n * @param[in] sig - signal number\n * @param[in] dir - indication how to kill\n *                  0 - kill child first\n *\t            1 - kill parent first\n *\n * @return\tint\n * @retval      number of tasks\n *\n */\nint\nkill_session(pid_t sesid, int sig, int dir)\n{\n\tint\tct = 0;\n\tint\ti;\n\n\tDBPRT((\"%s: entered sid %d\\n\", __func__, sesid))\n\tif (sesid <= 1)\n\t\treturn 0;\n\n\t(void)mom_get_sample();\n\tct = bld_ptree(sesid);\n\tDBPRT((\"%s: bld_ptree %d\\n\", __func__, ct))\n\n\t/*\n\t ** Find index into the Proc_lnks table for the session lead.\n\t */\n\tfor (i = 0; i < ct; i++) {\n\t\tif (Proc_lnks[i].pl_pid == sesid) {\n\t\t\tkill_ptree(i, dir, sig);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t ** Do a linear pass.\n\t */\n\tfor (i = 0; i < ct; i++) {\n\t\tif (Proc_lnks[i].pl_done)\n\t\t\tcontinue;\n\t\tDBPRT((\"%s: cleanup %d\\n\", __func__, Proc_lnks[i].pl_pid))\n\t\tkill(Proc_lnks[i].pl_pid, sig);\n\t}\n\n\t/*\n\t ** Kill the process group in case anything was missed reading /proc\n\t */\n\tif ((sig == SIGKILL) || (ct == 0))\n\t\tkillpg(sesid, sig);\n\n\treturn ct;\n}\n\n/**\n * @brief\n *\tClean up everything related to polling.\n *\n * @return\tint\n * @retval\tPBSE_NONE\tSuccess\n * @retval\tPBSE_SYSTEM\tError\n *\n */\nint\nmom_close_poll(void)\n{\n\tDBPRT((\"%s: entered\\n\", __func__))\n\tif (pdir) {\n\t\tif (closedir(pdir) != 0) {\n\t\t\tlog_err(errno, __func__, \"closedir\");\n\t\t\treturn (PBSE_SYSTEM);\n\t\t}\n\t\tpdir = NULL;\n\t}\n\tif (proc_info) {\n\t\t(void)free(proc_info);\n\t\tproc_info = NULL;\n\t\tmax_proc = 0;\n\t}\n\n\treturn (PBSE_NONE);\n}\n\n/**\n * @brief\n * \tCheckpoint the job.\n *\n * @param[in] ptask - pointer to task\n * @param[in] file - filename\n * @param[in] abort - value indicating abort\n *\n * If abort is true, kill it too.\n *\n * @return\tint\n * @retval\t-1\n */\nint\nmach_checkpoint(task *ptask, char *file, int abort)\n{\n\treturn (-1);\n}\n\n/**\n * @brief\n * \tRestart the job from the checkpoint file.\n *\n * @param[in] ptask - pointer to task\n * @param[in] file - filename\n *\n * @return      long\n * @retval      session id\tSuccess\n * @retval\t-1\t\tError\n */\nlong\nmach_restart(task *ptask, char *file)\n{\n\treturn (-1);\n}\n\n/**\n * @brief\n *\tReturn 1 if proc table can be read, 0 otherwise.\n */\nint\ngetprocs(void)\n{\n\tstatic unsigned int\tlastproc = 0;\n\n\tif (lastproc == reqnum)\t\t/* don't need new proc table */\n\t\treturn 1;\n\n\tif (mom_get_sample() != PBSE_NONE)\n\t\treturn 0;\n\n\tlastproc = reqnum;\n\treturn 1;\n}\n\n#define\tdsecs(val) ((double)(val) )\n\n/**\n * @brief\n *\tcomputes and returns the cpu time process with  pid jobid\n *\n * @param[in] jobid - process id for job\n *\n * @return\tstring\n * @retval\tcputime\t\tSuccess\n * @retval\tNULL\t\tError\n *\n */\nchar *\ncput_job(pid_t jobid)\n{\n\tint\t\ti;\n\tint\t\tfound = 0;\n\tdouble\t\tcputime, addtime;\n\tproc_stat_t\t*ps;\n\n\tcputime = 0.0;\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\t\tif (jobid != ps->session)\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\taddtime = dsecs(ps->cutime) + dsecs(ps->cstime);\n\n\t\tcputime += addtime;\n\t\tDBPRT((\"%s: total %.2f pid %d %.2f\\n\", __func__, cputime,\n\t\t\tps->pid, addtime))\n\n\t}\n\tif (found) {\n\t\tsprintf(ret_string, \"%.2f\", cputime * cputfactor);\n\t\treturn ret_string;\n\t}\n\n\trm_errno = RM_ERR_EXIST;\n\treturn NULL;\n}\n\n/**\n * @brief\n *      computes and returns the cpu time process with  pid pid.\n *\n * @param[in] pid - process id\n *\n * @return      string\n * @retval      cputime         Success\n * @retval      NULL            Error\n *\n */\nchar *\ncput_proc(pid_t pid)\n{\n\tint\t\ti;\n\tdouble\t\tcputime;\n\tproc_stat_t\t*ps = NULL;\n\n\tcputime = 0.0;\n\n\tmom_get_sample();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\t\tif (ps->pid == pid)\n\t\t\tbreak;\n\t}\n\tif (i == nproc) {\n\t\trm_errno = RM_ERR_EXIST;\n\t\treturn NULL;\n\t}\n\tcputime = dsecs(ps->utime) + dsecs(ps->stime);\n\n\tsprintf(ret_string, \"%.2f\", cputime * cputfactor);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\twrapper function for cput_proc and cput_job.\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return\tstring\n * @retval\tcputime\t\tSuccess\n * @retval\tNULL\t\tERRor\n *\n */\nchar *\ncput(struct rm_attribute *attrib)\n{\n\tint\t\tvalue;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif ((value = atoi(attrib->a_value)) == 0) {\n\t\tsprintf(log_buffer, \"bad param: %s\", attrib->a_value);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(attrib->a_qualifier, \"session\") == 0)\n\t\treturn (cput_job((pid_t)value));\n\telse if (strcmp(attrib->a_qualifier, \"proc\") == 0)\n\t\treturn (cput_proc((pid_t)value));\n\telse {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief\n *      computes and returns the memory for session with  pid sid..\n *\n * @param[in] sid - process id\n *\n * @return      string\n * @retval      memsize         Success\n * @retval      NULL            Error\n *\n */\nchar *\nmem_job(pid_t sid)\n{\n\tulong\t\tmemsize;\n\tint\t\ti;\n\tproc_stat_t\t*ps;\n\n\tmemsize = 0;\n\n\tmom_get_sample();\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\n\t\tif (sid != ps->session)\n\t\t\tcontinue;\n\t\tmemsize += ps->vsize;\n\t}\n\n\tif (memsize == 0) {\n\t\trm_errno = RM_ERR_EXIST;\n\t\treturn NULL;\n\t}\n\telse {\n\t\tsprintf(ret_string, \"%lukb\", memsize >> 10); /* KB */\n\t\treturn ret_string;\n\t}\n}\n\n/**\n * @brief\n *      computes and returns the memory for process with  pid sid..\n *\n * @param[in] pid - process id\n *\n * @return      string\n * @retval      memsize         Success\n * @retval      NULL            Error\n *\n */\nchar *\nmem_proc(pid_t pid)\n{\n\tint\t\ti;\n\tproc_stat_t\t*ps = NULL;\n\n\tmom_get_sample();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\t\tif (ps->pid == pid)\n\t\t\tbreak;\n\t}\n\tif (i == nproc) {\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\n\tsprintf(ret_string, \"%lukb\", (ulong)ps->vsize >> 10); /* KB */\n\treturn ret_string;\n}\n\n/**\n * @brief\n *      wrapper function for mem_job and mem_proc..\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      memsize         Success\n * @retval      NULL            ERRor\n *\n */\nchar *\nmem(struct rm_attribute *attrib)\n{\n\tint\t\tvalue;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif ((value = atoi(attrib->a_value)) == 0) {\n\t\tsprintf(log_buffer, \"bad param: %s\", attrib->a_value);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(attrib->a_qualifier, \"session\") == 0)\n\t\treturn (mem_job((pid_t)value));\n\telse if (strcmp(attrib->a_qualifier, \"proc\") == 0)\n\t\treturn (mem_proc((pid_t)value));\n\telse {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief\n *\tcomputes and returns resident set size for job\n *\n * @param[in] jobid - pid for job\n *\n * @return\tstring\n * @retval\tresident set size\tSuccess\n * @retval\tNULL\t\t\tError\n *\n */\nstatic char *\nresi_job(pid_t jobid)\n{\n\tint\t\ti;\n\tulong\t\tresisize;\n\tlong\t\twm;\t\t/* Altix weighted RSS replacement */\n\tint\t\tfound = 0;\n\tproc_stat_t\t*ps;\n\n\tresisize = 0;\n\tmom_get_sample();\n\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\n\t\tif (jobid != ps->session)\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\t/*\n\t\t *\tCertain Altix ProPack releases (or patches) add an\n\t\t *\tinterface to replace the value reported by /proc via\n\t\t *\tthe RSS field in the process's stat file.  If the\n\t\t *\tvalue is available, we use it;  if get_wm() returns\n\t\t *\t-1 indicating an error, we proceed using the old rss\n\t\t *\tvalue that we read from /proc/<pid>/stat.\n\t\t */\n\t\tif ((wm = get_wm(ps->pid)) != -1)\n\t\t\tps->rss = wm;\n\t\tresisize += ps->rss;\n\t}\n\tif (found) {\n\t\t/* in KB */\n\t\tsprintf(ret_string, \"%lukb\", (resisize * (ulong)pagesize) >> 10);\n\t\treturn ret_string;\n\t}\n\n\trm_errno = RM_ERR_EXIST;\n\treturn NULL;\n}\n\n/**\n * @brief\n *      computes and returns resident set size for process\n *\n * @param[in] pid - process id\n *\n * @return      string\n * @retval      resident set size       Success\n * @retval      NULL                    Error\n *\n */\nstatic char *\nresi_proc(pid_t pid)\n{\n\tint\t\ti;\n\tlong\t\twm;\t\t/* Altix weighted RSS replacement */\n\tproc_stat_t\t*ps = NULL;\n\n\n\tmom_get_sample();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\t\tif (ps->pid == pid)\n\t\t\tbreak;\n\t}\n\tif (i == nproc) {\n\t\trm_errno = RM_ERR_EXIST;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tCertain Altix ProPack releases (or patches) add an\n\t *\tinterface to replace the value reported by /proc via\n\t *\tthe RSS field in the process's stat file.  If the\n\t *\tvalue is available, we use it;  if get_wm() returns\n\t *\t-1 indicating an error, we proceed using the old rss\n\t *\tvalue that we read from /proc/<pid>/stat.\n\t */\n\tif ((wm = get_wm(pid)) != -1)\n\t\tps->rss = wm;\n\t/* in KB */\n\tsprintf(ret_string, \"%lukb\", ((ulong)ps->rss * (ulong)pagesize) >> 10);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *      wrapper function for mem_job and mem_proc..\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      resident set size     \tSuccess\n * @retval      NULL            \tERRor\n *\n */\nstatic char *\nresi(struct rm_attribute *attrib)\n{\n\tint\t\tvalue;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif ((value = atoi(attrib->a_value)) == 0) {\n\t\tsprintf(log_buffer, \"bad param: %s\", attrib->a_value);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(attrib->a_qualifier, \"session\") == 0)\n\t\treturn (resi_job((pid_t)value));\n\telse if (strcmp(attrib->a_qualifier, \"proc\") == 0)\n\t\treturn (resi_proc((pid_t)value));\n\telse {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief\n *\treturns the number of sessions\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return\tstring\n * @retval\tsessions\tSuccess\n * @retval\tNULL\t\terror\n *\n */\nchar *\nsessions(struct rm_attribute *attrib)\n{\n\tchar\t\t*fmt;\n\tint\t\ti, j;\n\tproc_stat_t\t*ps;\n\tint\t\tnjids = 0;\n\tpid_t\t\t*jids, *hold;\n\tstatic int\tmaxjid = 200;\n\tregister\tpid_t\tjobid;\n\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif ((jids = (pid_t *)calloc(maxjid, sizeof(pid_t))) == NULL) {\n\t\tlog_err(errno, __func__, \"no memory\");\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\n\tmom_get_sample();\n\n\t/*\n\t ** Search for members of session\n\t */\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\n\t\tif (ps->uid == 0)\n\t\t\tcontinue;\n\t\tif ((jobid = ps->session) == 0)\n\t\t\tcontinue;\n\t\tDBPRT((\"%s[%d]: pid %d sid %d\\n\",\n\t\t\t__func__, njids, ps->pid, jobid))\n\n\t\tfor (j=0; j<njids; j++) {\n\t\t\tif (jids[j] == jobid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == njids) {\t\t/* not found */\n\t\t\tif (njids == maxjid) {\t/* need more space */\n\t\t\t\tmaxjid += 100;\n\t\t\t\thold = (pid_t *)realloc(jids, maxjid);\n\t\t\t\tif (hold == NULL) {\n\t\t\t\t\tlog_err(errno, __func__, \"realloc\");\n\t\t\t\t\trm_errno = RM_ERR_SYSTEM;\n\t\t\t\t\tfree(jids);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tjids = hold;\n\t\t\t}\n\t\t\tjids[njids++] = jobid;\t/* add jobid to list */\n\t\t}\n\t}\n\n\tfmt = ret_string;\n\tfor (j=0; j<njids; j++) {\n\t\tcheckret(&fmt, 100);\n\t\tsprintf(fmt, \" %d\", (int)jids[j]);\n\t\tfmt += strlen(fmt);\n\t}\n\tfree(jids);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\twrapper function for sessions().\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      sessions        Success\n * @retval      0           \terror\n *\n */\nchar *\nnsessions(struct rm_attribute *attrib)\n{\n\tchar\t*result, *ch;\n\tint\tnum = 0;\n\n\tif ((result = sessions(attrib)) == NULL)\n\t\treturn result;\n\n\tfor (ch=result; *ch; ch++) {\n\t\tif (*ch == ' ')\t\t/* count blanks */\n\t\t\tnum++;\n\t}\n\tsprintf(ret_string, \"%d\", num);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *      returns the number of processes in session\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      process        Success\n * @retval      NULL            error\n *\n */\nchar *\npids(struct rm_attribute *attrib)\n{\n\tchar\t\t*fmt;\n\tint\t\ti;\n\tpid_t\t\tjobid;\n\tproc_stat_t\t*ps;\n\tint\t\tnum_pids;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif ((jobid = (pid_t)atoi(attrib->a_value)) == 0) {\n\t\tsprintf(log_buffer, \"bad param: %s\", attrib->a_value);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(attrib->a_qualifier, \"session\") != 0) {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tmom_get_sample();\n\n\t/*\n\t ** Search for members of session\n\t */\n\tfmt = ret_string;\n\tnum_pids = 0;\n\n\tfor (i=0; i<nproc; i++) {\n\n\t\tps = &proc_info[i];\n\t\tDBPRT((\"%s[%d]: pid: %d sid %d\\n\",\n\t\t\t__func__, num_pids, ps->pid, ps->session))\n\t\tif (jobid != ps->session)\n\t\t\tcontinue;\n\n\t\tsprintf(fmt, \"%d \", ps->pid);\n\t\tfmt += strlen(fmt);\n\t\tnum_pids++;\n\t}\n\tif (num_pids == 0) {\n\t\trm_errno = RM_ERR_EXIST;\n\t\treturn NULL;\n\t}\n\treturn ret_string;\n}\n\n/**\n * @brief\n *      returns the number of users\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      users        Success\n * @retval      NULL            error\n *\n */\nchar *\nnusers(struct rm_attribute *attrib)\n{\n\tint\t\ti;\n\tint\t\tj;\n\tproc_stat_t\t*ps;\n\tint\t\tnuids = 0;\n\tuid_t\t\t*uids, *hold;\n\tstatic int\tmaxuid = 200;\n\tregister uid_t\tuid;\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif ((uids = (uid_t *)calloc(maxuid, sizeof(uid_t))) == NULL) {\n\t\tlog_err(errno, __func__, \"no memory\");\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\n\tmom_get_sample();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\n\t\tif ((uid = ps->uid) == 0)\n\t\t\tcontinue;\n\n\t\tDBPRT((\"%s[%d]: pid %d uid %d\\n\",\n\t\t\t__func__, nuids, ps->pid, uid))\n\n\t\tfor (j=0; j<nuids; j++) {\n\t\t\tif (uids[j] == uid)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == nuids) {\t\t/* not found */\n\t\t\tif (nuids == maxuid) {\t/* need more space */\n\t\t\t\tmaxuid += 100;\n\t\t\t\thold = (uid_t *)realloc(uids, maxuid);\n\t\t\t\tif (hold == NULL) {\n\t\t\t\t\tlog_err(errno, __func__, \"realloc\");\n\t\t\t\t\trm_errno = RM_ERR_SYSTEM;\n\t\t\t\t\tfree(uids);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tuids = hold;\n\t\t\t}\n\t\t\tuids[nuids++] = uid;\t/* add uid to list */\n\t\t}\n\t}\n\n\tsprintf(ret_string, \"%d\", nuids);\n\tfree(uids);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\treturns all the process ids\n *\n * @return\tpid_t\n * @retval\tpids\tSuccess\n * @retval\tNULl\tError\n *\n */\npid_t *\nallpids(void)\n{\n\tint\t\ti;\n\tproc_stat_t\t*ps;\n\tstatic pid_t\t*pids = NULL;\n\n\tgetprocs();\n\n\tif (pids != NULL)\n\t\tfree(pids);\n\tif ((pids = (pid_t *)calloc(nproc+1, sizeof(pid_t))) == NULL) {\n\t\tlog_err(errno, __func__, \"no memory\");\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\n\t\tpids[i] = ps->pid;\t/* add pid to list */\n\t}\n\tpids[nproc] = -1;\n\treturn pids;\n}\n\n/**\n * @brief\n *\t return amount of total memory on system in KB as numeric string\n *\n * @return      string\n * @retval      total memory    \tSuccess\n * @retval      NULl    \t\tError\n *\n */\nstatic char *\ntotmem(struct rm_attribute *attrib)\n{\n\tproc_mem_t\t*mm;\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif ((mm = get_proc_mem()) == NULL) {\n\t\tlog_err(errno, __func__, \"get_proc_mem\");\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\tDBPRT((\"%s: total mem=%lu\\n\", __func__, mm->total))\n\tsprintf(ret_string, \"%lukb\", (ulong)mm->total >> 10); /* KB */\n\treturn ret_string;\n}\n\n/**\n * @brief\n *      returns available free process memory\n *\n * @return      string\n * @retval      avbl free process memory\t\tSuccess\n * @retval      NULl \t\t\t\t\tError\n *\n */\nstatic char *\navailmem(struct rm_attribute *attrib)\n{\n\tproc_mem_t\t*mm;\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif ((mm = get_proc_mem()) == NULL) {\n\t\tlog_err(errno, __func__, \"get_proc_mem\");\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\tDBPRT((\"%s: free mem=%lu\\n\", __func__, mm->free))\n\tsprintf(ret_string, \"%lukb\", (ulong)mm->free >> 10); /* KB */\n\treturn ret_string;\n}\n\n/**\n * @brief\tfind and remember the current Linux release number\n * @param[in]\tstruct utsname *\n *\n * @return\tvalue returned by uname(2)'s utsname release[] member\n */\nstatic char *\nuname2release(struct utsname *u)\n{\n\tstatic char\t*u_release = NULL;\n\n\tif (u_release != NULL)\n\t\treturn (u_release);\n\telse if ((u_release = malloc(strlen(u->release) + 1)) != NULL) {\n\t\tmemcpy(u_release, u->release, strlen(u->release) + 1);\n\t\tsprintf(log_buffer, \"uname release:  %s\", u_release);\n\t\tlog_event(PBSEVENT_DEBUG4, 0, LOG_DEBUG, __func__, log_buffer);\n\t\treturn (u_release);\n\t} else\n\t\treturn NULL;\n}\n\n/**\n * @brief\tchoose the format for the /proc \"flags\" field\n * @param[in]\trelease\n * @param[out]\tstdio format string\n *\n * @return\t\"%lu\" for /proc before Linux version 2.6.22\n * @return\t\"%u\" for  /proc Linux version 2.6.22 and later\n * *\n * @note\tTo derive release information, we're at the mercy of whoever\n *\t\tconfigures the kernel's UTS_RELEASE value when it's built.\n *\t\tWe hope that the version information is in the format\n *\t\t<major>.<minor>.<micro>, or - if not - that at least we can\n *\t\tdepend on sscanf() to throw away extraneous characters and\n *\t\tderive a number for the \"micro\" version that can be used to\n *\t\tleverage proc(5)'s \"%u (%lu before Linux 2.6.22)\" flags\n *\t\tfield format specification.\n *\n *\t\tThis code is not designed to work for Linux versions < 2.\n *\n * @par MT-Safe:\tyes\n */\nstatic char *\nprocflagsfmt(char *release)\n{\n\tchar\t*p;\n\tchar\t*ver_begin = release;\n\tchar\trfseparator_dot = '.';\n\tchar\trfseparator_dash = '-';\n\tint\tnseparators_seen = 0;\n\tint\tmajor, minor, micro, ver;\n\tstatic char\tbefore[] = \"%lu\";\n\tstatic char\tafter[] = \"%u\";\n\n\tfor (p = release; *p != '\\0'; p++) {\n\t\tif ((*p == rfseparator_dot) || (*p == rfseparator_dash)) {\n\t\t\tp++;\n\t\t\tif (sscanf(ver_begin, \"%d\", &ver) == 1) {\n\t\t\t\tif (nseparators_seen == 0) {\n\t\t\t\t\tmajor = ver;\n\t\t\t\t\tif (major > 2)\n\t\t\t\t\t\treturn (after);\n\t\t\t\t} else if (nseparators_seen == 1) {\n\t\t\t\t\tminor = ver;\n\t\t\t\t\tif (minor > 6)\n\t\t\t\t\t\treturn (after);\n\t\t\t\t} else {\n\t\t\t\t\tmicro = ver;\n\t\t\t\t\t /* \"flags %u (%lu before Linux 2.6.22)\" */\n\t\t\t\t\tif ((minor == 6) && (micro >= 22))\n\t\t\t\t\t\treturn (after);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (before);\n\t\t\t\t}\n\t\t\t}\n\t\t\tver_begin = p;\n\t\t\tnseparators_seen++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/**\n * @brief\treturn the stdio format directive for the /proc flags field\n *\n * @param[out]\tformat string for the /proc flags field\n *\n * @return\tstatic char *\n *\n * @see\tprocflagsfmt\n * @see\tuname2release\n */\nstatic char *\nchoose_procflagsfmt(void)\n{\n\tchar\t\tbuf[1024];\n\tstatic char\t*fmtstr = NULL;\n\tstatic int\tinitialized = 0;\n\tstruct utsname\tu;\n\n\tif (initialized)\n\t\treturn (fmtstr);\n\n\tif (uname(&u) == -1) {\n\t\tlog_err(errno, __func__, \"uname\");\n\t\treturn NULL;\n\t} else {\n\t\tchar\t*release;\n\t\tchar\t*fffs;\t\t/* the flags field format string */\n\n\t\tif ((release = uname2release(&u)) == NULL) {\n\t\t\tlog_err(-1, __func__, \"uname2release returned NULL\");\n\t\t\treturn NULL;\n\t\t}\n\t\telse if ((fffs = procflagsfmt(release)) == NULL) {\n\t\t\tlog_err(-1, __func__, \"procflagsfmt returned NULL\");\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tsprintf(buf, stat_str_pre, fffs);\n\t\t\tif ((fmtstr = strdup(buf)) == NULL) {\n\t\t\t\tlog_err(-1, __func__, \"strdup returned NULL\");\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tinitialized = 1;\n\t\t\t\treturn (fmtstr);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#else\t/* PBSMOM_HTUNIT */\n\n/*\n **\tThis is code to compile the ncpus function for unit testing.\n **\tWhat follows is a bit of cruft needed to make a correct program.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/utsname.h>\n\nchar\tlog_buffer[4096];\nchar\tret_string[4096];\n\n/**\n * @brief\n *\toutputs logevent on stdout\n *\n * @param[in] a - event  number\n * @param[in] b - event number\n * @param[in] c - type of log\n * @param[in] id - id to indicate log from which object\n * @param[in] mess - message to be logged\n *\n * @return\tVoid\n *\n */\nvoid\nlog_event(int a, int b, int c, char *id, char *mess)\n{\n\tprintf(\"%s: %s\\n\", id, mess);\n}\n/**\n * @brief\n *      outputs logevent on stdout\n *\n * @param[in] a - error number\n * @param[in] id - id to indicate log from which object\n * @param[in] mess - message to be logged\n *\n * @return      Void\n *\n */\nvoid\nlog_err(int a, char *id, char *mess)\n{\n\tprintf(\"error %d %s: %s\\n\", a, id, mess);\n}\n\nstruct rm_attribute;\n\nstatic\tchar\t*ncpus(struct rm_attribute *);\n\n#define\tPBSEVENT_SYSTEM\t0\n#define\tLOG_NOTICE\t0\n#define\tRM_ERR_BADPARAM\t0\n#define\tpbs_strsep\tstrsep\n\nint\tnum_pcpus, num_acpus, num_oscpus, rm_errno;\nchar\textra_parm[] = \"extra_parm\";\n\n\nint\nmain()\n{\n\tif (ncpus(NULL) != NULL)\n\t\tprintf(\"ncpus = %s\\n\", ret_string);\n\tprintf(\"physical %d  logical %d\\n\", num_pcpus, num_oscpus);\n\treturn 0;\n}\n#endif\t/* PBSMOM_HTUNIT */\n\n/**\n * @brief\n *\treturns the processed string (skip).\n *\tprocessed string format \"string\t:\"\n *\n * @param[in] str - label\n * @param[in] skip - string to be processed\n *\n * @return\tstring\n * @retval\tNULL\t\t\tError\n * @retval\tprocessed string\tSuccess\n *\n */\n\nchar *\nskipstr(char *str, char *skip)\n{\n\tint\tlen = strlen(skip);\n\n\tif (strncmp(str, skip, len) != 0)\n\t\treturn NULL;\n\n\tskip = str + len;\n\treturn skip + strspn(skip, \"\\t :\");\n}\n\nint\tlinenum;\nint\terrflag = 0;\n\nchar\tbadformat[] = \"warning: /proc/cpuinfo format not recognized\";\n\n/**\n * @brief\n *\tprints log events about ncpus\n *\n * @return\tVoid\n *\n */\nvoid\nwarning(void)\n{\n\tif (!errflag) {\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, \"ncpus\", badformat);\n\t\terrflag = 1;\n\t}\n\tlog_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, \"ncpus\", log_buffer);\n\treturn;\n}\n\n/**\n * @brief\n *\tconverts and return the string value\n *\n * @param[in] str - string to be processed\n *\n * @return\tint\n * @retval\tconverted val(strtol)\tSuccess\n * @retval\t0\t\t\tError\n *\n */\nint\ngetnum(char *str)\n{\n\tlong\tval;\n\tchar\t*extra;\n\n\tif (str == NULL || *str == '\\0') {\n\t\tsprintf(log_buffer, \"line %d: number needed\", linenum);\n\t\twarning();\n\t\treturn 0;\n\t}\n\n\tval = strtol(str, &extra, 10);\n\tif (*extra != '\\0') {\n\t\tsprintf(log_buffer, \"line %d: bad number %s\", linenum, str);\n\t\twarning();\n\t}\n\treturn (int)val;\n}\n\n#define\tLABLELEN\t1024\n\nstruct {\n\tint\tphysid;\n\tint\tcoreid;\n} *proc_array = NULL;\nint\tproc_num = 0;\n\n/**\n * @brief\n *\tAdd an entry to the proc_array[] with the physid/coreid\n *\tcombination of a cpu.  We do this to count the number of\n *\tunique tuples since HyperThread(tm) \"cpus\" will have duplicate\n *\tphysid/coreid values.\n *\n * @param[in] physid - physical id\n * @param[in] coreid - core id\n *\n * @return\tVoid\n *\n */\nstatic void\nproc_new(int physid, int coreid)\n{\n\tint\ti;\n\n\tif (physid < 0 || coreid < 0)\n\t\treturn;\n\n\tfor (i=0; i<proc_num; i++) {\n\t\tif (proc_array[i].physid == physid &&\n\t\t\tproc_array[i].coreid == coreid)\n\t\t\tbreak;\n\t}\n\tif (i == proc_num) {\t/* need new proc entry */\n\t\tproc_num++;\n\t\tproc_array = realloc(proc_array, sizeof(*proc_array)*proc_num);\n\t\tassert(proc_array != NULL);\n\t\tproc_array[i].physid = physid;\n\t\tproc_array[i].coreid = coreid;\n\t}\n}\n\n/**\n * @brief\n *\treturn the number of cpus\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return\tstring\n * @retval\tnumber of cpus\tSuccess\n * @retval\tNULL\t\tError\n *\n */\nstatic char *\nncpus(struct rm_attribute *attrib)\n{\n\tchar\t\t*file = \"/proc/cpuinfo\";\n\tchar\t\tlabel[LABLELEN];\n\tchar\t\t*cp;\n\tFILE\t\t*fp;\n\tint\t\tprocs, logical;\n\tint\t\tskip = 0;\n\tint\t\tsiblings = 0;\n\tint\t\tcoreid = -1;\n\tint\t\tphysid = -1;\n\tint\t\tmaxsib = 0;\n\tint\t\tmaxsibcpu = 0;\n\tint\t\tprocnum = -1;\n\tint\t\thtseen, htany;\n\tint\t\tintelany;\n\tstatic int\toldlinux = -1;\n\tint\t\tlen;\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (num_pcpus > 0) {\n\t\tsprintf(ret_string, \"%d\", num_pcpus);\n\t\treturn ret_string;\n\t}\n\n\tif ((fp = fopen(file, \"r\")) == NULL)\n\t\treturn NULL;\n\n\tif (oldlinux == -1) {\n\t\tstruct\tutsname\tubuf;\n\n\t\toldlinux = 0;\n\t\tif (uname(&ubuf) == 0) {\n\t\t\tif (strncmp(ubuf.release, \"2.4.\", 4) == 0 &&\n\t\t\t\tstrcmp(ubuf.machine, \"x86_64\") == 0)\n\t\t\t\toldlinux = 1;\n\t\t}\n\t}\n\n\terrflag = 0;\n\tlogical = procs = 0;\n\tlinenum = 0;\n\thtany = intelany = 0;\n\n\twhile (!feof(fp)) {\n\t\tif (fgets(label, LABLELEN, fp) == NULL)\n\t\t\tbreak;\n\n\t\tlinenum++;\n\t\tlen = strlen(label);\n\t\tif (label[len - 1] == '\\n')\n\t\t\tlabel[len - 1] = '\\0';\n\t\telse {\n\t\t\tsprintf(log_buffer, \"line %d too long\", linenum);\n\t\t\twarning();\n\t\t}\n\n\t\t/* x86 linux /proc/cpuinfo format is\n\t\t ** processor 0\n\t\t ** info about processor 0\n\t\t ** processor 1\n\t\t ** info about processor 1\n\t\t ** etc.... Alpha linux just prints \"cpus detected: X\"\n\t\t */\n\t\tif ((cp = skipstr(label, \"processor\")) != NULL) {\n\t\t\tproc_new(physid, coreid);\n\t\t\tphysid = coreid = -1;\n\t\t\thtseen = 0;\n\t\t\tsiblings = 0;\n\t\t\tprocnum = getnum(cp);\n\t\t\tlogical++;\n\t\t\tif (skip == 0)\n\t\t\t\tprocs++;\n\t\t}\n\t\telse if ((cp = skipstr(label, \"cpus detected\")) != NULL) {\n\t\t\tlogical = procs = getnum(cp);\n\t\t\tbreak;\n\t\t}\n\t\telse if ((cp = skipstr(label, \"siblings\")) != NULL ||\n\t\t\t(cp = skipstr(label, \"threads\")) != NULL ||\n\t\t\t(cp = skipstr(label, \"Number of siblings\")) != NULL) {\n\t\t\tsiblings = getnum(cp);\n\t\t\tif (siblings > maxsib) {\n\t\t\t\tmaxsib = siblings;\n\t\t\t\tmaxsibcpu = procnum;\n\t\t\t}\n\t\t\tif (skip == 0)\n\t\t\t\tskip = siblings - 1;\n\t\t\telse\n\t\t\t\tskip--;\n\t\t}\n\t\telse if ((cp = skipstr(label, \"physical id\")) != NULL) {\n\t\t\tphysid = getnum(cp);\n\t\t}\n\t\telse if ((cp = skipstr(label, \"core id\")) != NULL) {\n\t\t\tcoreid = getnum(cp);\n\t\t}\n\t\telse if ((cp = skipstr(label, \"vendor_id\")) != NULL) {\n\t\t\tif (strcmp(cp, \"GenuineIntel\") == 0)\n\t\t\t\tintelany = 1;\n\t\t}\n\t\telse if ((cp = skipstr(label, \"flags\")) != NULL) {\n\t\t\twhile (cp != NULL) {\n\t\t\t\tchar *flag = pbs_strsep(&cp, \" \");\n\n\t\t\t\tif (flag == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(flag, \"ht\") == 0) {\n\t\t\t\t\thtany = htseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fp);\n\tproc_new(physid, coreid);\n\n\tif (maxsib > logical) {\n\t\tsprintf(log_buffer, \"cpu %d: siblings=%d but OS only \"\n\t\t\t\"reports %d cpus\", maxsibcpu, maxsib, logical);\n\t\twarning();\n\t}\n\tif (errflag)\n\t\tprocs = logical;\n\telse if (htany || (oldlinux && intelany)) {\n\t\t/*\n\t\t ** If the version of linux is new enough to have\n\t\t ** physid and coreid, we can use the proc_num\n\t\t ** count as the value of physical processors.\n\t\t */\n\t\tif (proc_num > 0)\n\t\t\tprocs = proc_num;\n\t\tsprintf(log_buffer, \"hyperthreading %s\",\n\t\t\t(procs < logical) ? \"enabled\" : \"disabled\");\n\t\tlog_event(PBSEVENT_SYSTEM, 0, LOG_NOTICE, \"ncpus\", log_buffer);\n\t}\n\n\tnum_pcpus = num_acpus = num_oscpus = logical;\n\tif (proc_array != NULL) {\n\t\tfree(proc_array);\n\t\tproc_array = NULL;\n\t\tproc_num = 0;\n\t}\n\n\tsprintf(ret_string, \"%d\", num_oscpus);\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\treturns the total physical memory\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return      string\n * @retval      tot physical memory  \tSuccess\n * @retval      NULL            \tError\n *\n */\n\n#ifndef\tPBSMOM_HTUNIT\nchar *\nphysmem(struct rm_attribute *attrib)\n{\n\tchar\t\tstrbuf[256];\n\tFILE\t\t*fp;\n\n\tif (attrib) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif ((fp = fopen(\"/proc/meminfo\", \"r\")) == NULL) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\t/* the physmem of the machine is in MemTotal */\n\twhile (fgets(strbuf, 256, fp) != NULL) {\n\t\tif (sscanf(strbuf, \"MemTotal: %s k\", ret_string) == 1) {\n\t\t\tfclose(fp);\n\t\t\ttotalmem = (ulong)atol(ret_string);\n\n\t\t\tmempernode = (totalmem / cpuset_nodes) -\n\t\t\t\t(memreserved * 1024);\n\t\t\tcpupernode = num_pcpus / cpuset_nodes;\n\n\t\t\tsprintf(ret_string, \"%lukb\",\n\t\t\t\tmempernode * (num_acpus/cpupernode));\n\t\t\treturn ret_string;\n\t\t}\n\t}\n\tfclose(fp);\n\trm_errno = RM_ERR_SYSTEM;\n\treturn NULL;\n\n}\n\n/**\n * @brief\n *\treturns the size of file system present in machine\n *\n * @param[in] param - attribute value(file system)\n *\n * @return \tstring\n * @retval\tsize of file system\tSuccess\n * @retval\tNULL\t\t\tError\n *\n */\nchar *\nsize_fs(char *param)\n{\n\tstruct\tstatfs\tfsbuf;\n\n\tif (param[0] != '/') {\n\t\tsprintf(log_buffer, \"%s: not full path filesystem name: %s\",\n\t\t\t__func__, param);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (statfs(param, &fsbuf) == -1) {\n\t\tlog_err(errno, __func__, \"statfs\");\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tsprintf(ret_string, \"%lukb\",\n\t\t(ulong)(((double)fsbuf.f_bsize *\n\t\t(double)fsbuf.f_bfree) / 1024.0)); /* KB */\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\tget file attribute(size) from param and put them in buffer.\n *\n * @param[in] param - file attributes\n *\n * @return\tstring\n * @retval\tsize of file\tSuccess\n * @retval\tNULL\t\tError\n *\n */\nchar *\nsize_file(char *param)\n{\n\tstruct\tstat\tsbuf;\n\n\tif (param[0] != '/') {\n\t\tsprintf(log_buffer, \"%s: not full path filesystem name: %s\",\n\t\t\t__func__, param);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (stat(param, &sbuf) == -1) {\n\t\tlog_err(errno, __func__, \"stat\");\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tsprintf(ret_string, \"%lukb\", (ulong)(sbuf.st_size >> 10)); /* KB */\n\treturn ret_string;\n}\n\n/**\n * @brief\n *\twrapper function for size_file which returns the size of file system\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return\tstring\n * @retval      size of file system     Success\n * @retval      NULL                    Error\n *\n */\nchar *\nsize(struct rm_attribute *attrib)\n{\n\tchar\t\t*param;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tparam = attrib->a_value;\n\tif (strcmp(attrib->a_qualifier, \"file\") == 0)\n\t\treturn (size_file(param));\n\telse if (strcmp(attrib->a_qualifier, \"fs\") == 0)\n\t\treturn (size_fs(param));\n\telse {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief\n *\tcomputes and returns walltime for process or session.\n *\n * @param[in] attrib - pointer to rm_attribute structure\n *\n * @return\tstring\n * @retval\twalltime\tSuccess\n * @retval\tNULL\t\tError\n *\n */\nstatic char *\nwalltime(struct rm_attribute *attrib)\n{\n\tint\t\ti;\n\tint\t\tvalue, job, found = 0;\n\ttime_t\t\tnow, start;\n\tproc_stat_t\t*ps;\n\n\tif (attrib == NULL) {\n\t\tlog_err(-1, __func__, no_parm);\n\t\trm_errno = RM_ERR_NOPARAM;\n\t\treturn NULL;\n\t}\n\tif ((value = atoi(attrib->a_value)) == 0) {\n\t\tsprintf(log_buffer, \"bad param: %s\", attrib->a_value);\n\t\tlog_err(-1, __func__, log_buffer);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\tif (momgetattr(NULL)) {\n\t\tlog_err(-1, __func__, extra_parm);\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(attrib->a_qualifier, \"proc\") == 0)\n\t\tjob = 0;\n\telse if (strcmp(attrib->a_qualifier, \"session\") == 0)\n\t\tjob = 1;\n\telse {\n\t\trm_errno = RM_ERR_BADPARAM;\n\t\treturn NULL;\n\t}\n\n\tif ((now = time(NULL)) <= 0) {\n\t\tlog_err(errno, __func__, \"time\");\n\t\trm_errno = RM_ERR_SYSTEM;\n\t\treturn NULL;\n\t}\n\tmom_get_sample();\n\n\tstart = now;\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\n\t\tif (job) {\n\t\t\tif (value != ps->session)\n\t\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (value != ps->pid)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tstart = MIN(start, ps->start_time);\n\t}\n\n\tif (found) {\n\t\tsprintf(ret_string, \"%ld\",\n\t\t\t(long)((double)(now - start) * wallfactor));\n\t\treturn ret_string;\n\t}\n\n\trm_errno = RM_ERR_EXIST;\n\treturn NULL;\n}\n\n/**\n * @brief\n *\treads load avg from file and returns\n *\n * @param[out] rv - var to hold load avg\n *\n * @return\tint\n * @retval\t0\t\t\tSuccess\n * @retval\tRM_ERR_SYSTEM(15205)\terror\n *\n */\nint\nget_la(double *rv)\n{\n\tFILE\t\t*fp;\n\tfloat\t\tload;\n\n\tif ((fp = fopen(\"/proc/loadavg\", \"r\")) == NULL)\n\t\treturn (rm_errno = RM_ERR_SYSTEM);\n\n\tif (fscanf(fp, \"%f\", &load) != 1) {\n\t\tlog_err(errno, __func__, \"fscanf of load in /proc/loadavg\");\n\t\t(void) fclose(fp);\n\t\treturn (rm_errno = RM_ERR_SYSTEM);\n\t}\n\n\t*rv = (double)load;\n\t(void) fclose(fp);\n\treturn 0;\n}\n\nu_long\ngracetime(u_long secs)\n{\n\ttime_t\tnow = time(NULL);\n\n\tif (secs > now)\t\t/* time is in the future */\n\t\treturn (secs - now);\n\telse\n\t\treturn 0;\n}\n\n/**\n * @brief\n *\tset priority of processes.\n *\n * @return\tVoid\n *\n */\nvoid\nmom_nice(void)\n{\n\tif ((nice_val != 0) && (setpriority(PRIO_PROCESS, 0, nice_val) == -1)) {\n\t\t(void)sprintf(log_buffer, \"failed to nice(%d) mom\", nice_val);\n\t\tlog_err(errno, __func__, log_buffer);\n\t}\n}\n\n/**\n * @brief\n *      Unset priority of processes.\n *\n * @return      Void\n *\n */\nvoid\nmom_unnice(void)\n{\n\tif ((nice_val != 0) && (setpriority(PRIO_PROCESS, 0, 0) == -1)) {\n\t\t(void)sprintf(log_buffer, \"failed to nice(%d) mom\", nice_val);\n\t\tlog_err(errno, __func__, log_buffer);\n\t}\n}\n\n/**\n * @brief\n *\tGet the info required for tm_attach.\n *\n * @param[in] pid - process id\n * @param[in] sid - session id\n * @param[in] uid - user id\n * @param[in] comm - command name\n * @param[in] len - size of command\n *\n * @return\tint\n * @retval\tTM_OKAY\t\t\tSuccess\n * @retval\tTM_ENOPROC(17011)\tError\n *\n */\nint\ndep_procinfo(pid_t pid, pid_t *sid, uid_t *uid, char *comm, size_t len)\n{\n\tint\t\ti;\n\tproc_stat_t\t*ps;\n\n\tgetprocs();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\t\tif (ps->pid == pid) {\n\t\t\t*sid = ps->session;\n\t\t\t*uid = ps->uid;\n\t\t\tmemset(comm, '\\0', len);\n\t\t\tmemcpy(comm, ps->comm,\n\t\t\t\tMIN(len-1, sizeof(ps->comm)));\n\t\t\treturn TM_OKAY;\n\t\t}\n\t}\n\treturn TM_ENOPROC;\n}\n\n#ifdef NAS_UNKILL /* localmod 011 */\n/**\n * @brief\n *\tGet the info required for tracking killed processes.\n *\n * @param[in] pid - process id\n * @param[in] ppid - parent process id\n * @param[in] start_time - start time of process\n *\n * @return      int\n * @retval      TM_OKAY                 Success\n * @retval      TM_ENOPROC(17011)       Error\n *\n */\nint\nkill_procinfo(pid_t pid, pid_t *ppid, u_Long *start_time)\n{\n\tint\t\ti;\n\tproc_stat_t\t*ps;\n\n\tgetprocs();\n\tfor (i=0; i<nproc; i++) {\n\t\tps = &proc_info[i];\n\t\tif (ps->pid == pid) {\n\t\t\t*ppid = ps->ppid;\n\t\t\t*start_time = ps->start_time;\n\t\t\treturn TM_OKAY;\n\t\t}\n\t}\n\treturn TM_ENOPROC;\n}\n#endif /* localmod 011 */\n\n/**\n * @brief\n *\tFor cpuset machine, migrate new task to a cpuset.\n *\n * @param[in] ptask - pointer to task structure\n *\n * @return\tint\n * @retval\tTM_OKAY\t\t\tSuccess\n * @retval\tTM_ESYSTEM(17000)\tError\n *\n */\nint\ndep_attach(task *ptask)\n{\n#if\tMOM_CPUSET\n\tchar\tcbuf[CPUSET_NAME_SIZE+16];\n\tchar\t*cname;\n\tjob\t*pjob = ptask->ti_job;\n\n\tif ((cname = make_cpuset(pjob)) == NULL)\n\t\treturn TM_ESYSTEM;\n\n\tif (migrate_task(ptask, cname))\n\t\treturn TM_ESYSTEM;\n\n\tsprintf(cbuf, \"cpuset=%s\", cname);\n\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],\n\t\tATTR_altid, NULL, cbuf);\n\tDBPRT((\"%s:  job %s's cpu set is %s\\n\", __func__, pjob->ji_qs.ji_jobid,\n\t\tcname))\n#endif\t/* MOM_CPUSET */\n\treturn TM_OKAY;\n}\n\n/**\n * @brief\n *\tadjusts the reserved mem attribute to make it hold in space\n *\n * @param[in] vp - pointer to vnl_t structure( vnode list)\n *\n * @return\tVoid\n *\n */\n#if\tMOM_CPUSET\nstatic void\nadjust_memreserved(vnl_t *vp)\n{\n\tint\ti, j;\n\tchar\tmemres[] = \"resources_available.mem\";\n\tulong\tmemval;\n\n\t/* no work to do */\n\tif ((vp == NULL) || (do_memreserved_adjustment == 0))\n\t\treturn;\n\n\tfor (i = 0; i < vp->vnl_used; i++) {\n\t\tvnal_t\t*vnalp;\n\n\t\tvnalp = VNL_NODENUM(vp, i);\n\t\tfor (j = 0; j < vnalp->vnal_used; j++) {\n\t\t\tvna_t\t*vnap;\n\t\t\tchar\tmembuf[BUFSIZ];\n\n\t\t\tvnap = VNAL_NODENUM(vnalp, j);\n\t\t\tif (strcmp(vnap->vna_name, memres) == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tFound resource named \"mem\";  its value\n\t\t\t\t *\twill be in KB while \"memreserved\" is in\n\t\t\t\t *\tMB.\n\t\t\t\t */\n\t\t\t\tmemval = strtoul(vnap->vna_val, NULL, 0);\n\t\t\t\tmemval -= (memreserved << 10);\n\n\t\t\t\t/*\n\t\t\t\t *\tSince the \"mem\" resource value is now\n\t\t\t\t *\tsmaller than before, it ought to fit\n\t\t\t\t *\tin the space that holds the current\n\t\t\t\t *\tvalue.\n\t\t\t\t */\n\t\t\t\tif (snprintf(membuf, sizeof(membuf), \"%lukb\",\n\t\t\t\t\tmemval) > strlen(vnap->vna_val))\n\t\t\t\t\tcontinue;\n\t\t\t\tstrcpy(vnap->vna_val, membuf);\n\t\t\t}\n\t\t}\n\t}\n\n\tdo_memreserved_adjustment = 0;\n}\n\n/**\n * @brief\n *\tFree any CPUs marked as being in use by the given job.\n *\n * @param[in] pjob - job pointer\n *\n * @return\tVoid\n *\n */\nstatic void\ncpuset_free_job_CPUs(job *pjob)\n{\n\tint\t\ti, j;\n\thnodent\t\t*hn;\n\tmominfo_t\t*mip;\n\tmom_vninfo_t\t*mvp;\n\thost_vlist_t\t*hv;\n\tint\t\tcpus_freed;\n\n\tfor (i = 0, hn = &pjob->ji_hosts[pjob->ji_nodeid];\n\t\ti < hn->hn_vlnum; i++) {\n\t\thv = &hn->hn_vlist[i];\n\t\tmip = find_mominfo(hv->hv_vname);\n\t\tif (mip == NULL) {\n\t\t\t/*\n\t\t\t *\tThere's a vnode that has been allocated to us\n\t\t\t *\tin the exec_vnode list, but of which we have no\n\t\t\t *\trecord.  That's possible, because we only keep\n\t\t\t *\ta record of vnodes for which we have to allocate\n\t\t\t *\teither CPUs or memory.  We note the fact for\n\t\t\t *\tdebugging purposes, but don't consider it an\n\t\t\t *\terror.\n\t\t\t */\n\t\t\tsprintf(log_buffer, \"%s: find_mominfo %s failed\",\n\t\t\t\t__func__, hv->hv_vname);\n\t\t\tlog_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB,\n\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);\n\t\t\tcontinue;\t/* on to next vnode in hn_vlist[] */\n\t\t}\n\t\tmvp = (mom_vninfo_t *) mip->mi_data;\n\t\tif (mvp == NULL) {\n\t\t\tsprintf(log_buffer, \"mip->mi_data NULL\");\n\t\t\tlog_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t\tcontinue;\t/* on to next vnode in hn_vlist[] */\n\t\t}\n\t\tfor (j = 0, cpus_freed = 0; j < mvp->mvi_ncpus; j++) {\n\t\t\tif (mvp->mvi_cpulist[j].mvic_job == pjob) {\n\t\t\t\tcpuindex_free(mvp, j);\n\t\t\t\tcpus_freed++;\n\t\t\t}\n\t\t}\n\n#ifdef\tDEBUG\n\t\tif (cpus_freed != hv->hv_ncpus) {\n\t\t\tsprintf(log_buffer, \"cpus_freed (%d) != hv_ncpus(%d)\",\n\t\t\t\tcpus_freed, hv->hv_ncpus);\n\t\t\tlog_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t}\n#endif\t/* DEBUG */\n\t}\n}\n#endif\t/* MOM_CPUSET */\n\n/**\n *\tThere is a problem with RSS reporting on (at least) Altix systems:\n *\tshared memory (such as dynamic shared object libraries) is charged\n *\tfully to each process participating in the sharing rather than\n *\tcharging only 1/N times as much (where N is the number of processes\n *\tsharing a given object).\n *\n *\tTo address this, SGI has provided a new memacct(3) interface (see\n *\tbelow) to do the proper sharing computation.  It is available on an\n *\tAltix with ProPack 5 and patch 10386 installed (or via a subsequent -\n *\tname or date not yet known - update to ProPack 5).\n *\n *\tThis function will return the value of the get_weighted_memory_size\n *\tfunction contained in the libmemacct shared object, scaled to units\n *\texpected for RSS (pages).\n *\tThe synopsis of get_weighted_memory_size is\n *\n *\n *\tSYNOPSIS\n *\t       cc ... -lmemacct\n *\n *\t       #include <sys/types.h>\n *\n *\t       extern int get_weighted_memory_size(pid_t pid);\n *\n *\tSYNOPSIS\n *\t   int *get_weighted_memory_size(pid_t pid);\n *\t       Return  the  weighted  memory  size for a pid, in bytes.\n *\t       This weights the size of shared regions by the number of processes\n *\t       accessing it.  Return -1 when an error occurs.\n *\n *\n *\tYes, there are two synopses and yes, they disagree about the return\n *\tvalue.  Apparently both are wrong:  an update from the SGI developer\n *\tof this interface tells us that the correct prototype is\n *\n *\t       extern long get_weighted_memory_size(pid_t pid);\n *\n *\tso that is how the function return value and``ptr'' variable below have\n *\tbeen defined.\n *\n *\tOn platforms without the shared object or the named API symbol, this\n *\tfunction will return -1.\n *\n *\tBecause the Altix version of PBS may be built on older (or unpatched)\n *\tversions of ProPack, we cannot simply link against the shared object\n *\twe need to use.  Instead, we use dlopen() and dlsym() to map it in\n *\tand call the memacct(3) API.\n *\n *\tNote:  the log event type, object class, and severity are chosen to\n *\tmatch that of the CSA function ck_acct_facility_present(), q.v.\n */\nstatic long\nget_wm(pid_t pid)\n{\n#ifdef NAS_NO_WM /* localmod 089 */\n\tstatic int\thardfailure = 1;\n#else\n\tstatic int\thardfailure = 0;\n#endif /* localmod 089 */\n\tstatic void\t*handle = NULL;\n\tlong\t\twm;\n\tlong\t\t(*ptr)(pid_t);\n\tchar\t\tmemsym[] = \"get_weighted_memory_size\";\n\tchar\t\tmemacctsoname[] = \"libmemacct.so.1\";\n\n\tif (hardfailure == 1) {\n\t\tif (handle != NULL) {\n\t\t\t(void) dlclose(handle);\n\t\t\thandle = NULL;\n\t\t}\n\t\treturn (-1);\n\t}\n\n\t/*\n\t *\tThere are three ways this function can fail:\n\t *\n\t *\t\tthe shared object may not be present\n\t *\t\tthe needed symbol may not be found in the shared object\n\t *\t\tthe get_weighted_memory_size interface returns an error\n\t *\n\t *\tIt might seem reasonable to consider the first of these a soft,\n\t *\trecoverable error.  After all, someone might have forgotten to\n\t *\tinstall the appropriate package.  However, at the time of this\n\t *\twriting, the memacct package depends on the sgi-numatools-kmp\n\t *\tpackage, which requires an OS reboot.  Thus simply installing\n\t *\tthe missing package is unlikely to solve the problem, so we\n\t *\tconsider it unrecoverable.\n\t *\n\t *\tThe second error is clearly not recoverable:  the shared object\n\t *\twas present but didn't contain the symbol we need, so something\n\t *\tis quite wrong.\n\t *\n\t *\tThe third error is problematic:  the interface description\n\t *\tcontains no information about errors, so we can't tell the\n\t *\tdifference between one that we might well anticipate (e.g. a\n\t *\tprocess has exited) and one that occurs because the package\n\t *\tdependency above hasn't been satisfied.  So, we silently\n\t *\tignore this error.\n\t */\n\tif ((handle == NULL) &&\n\t\t(handle = dlopen(memacctsoname, RTLD_LAZY)) == NULL) {\n\t\tsprintf(log_buffer, \"%s not found\", memacctsoname);\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT,\n\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\thardfailure = 1;\n\t\treturn (-1);\n\t}\n\n#ifdef NAS /* localmod 005 */\n\tif ((ptr = (long(*)(pid_t))dlsym(handle, memsym)) == NULL) {\n#else\n\tif ((ptr = dlsym(handle, memsym)) == NULL) {\n#endif /* localmod 005 */\n\t\tsprintf(log_buffer, \"symbol %s not found in %s\",\n\t\t\tmemsym, memacctsoname);\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT,\n\t\t\tLOG_DEBUG, __func__, log_buffer);\n\t\thardfailure = 1;\n\t\treturn (-1);\n\t}\n\n\tif ((wm = (*ptr)(pid)) == -1)\n\t\treturn (-1);\n\telse\n\t\treturn (wm / pagesize);\t\t/* convert bytes to pages */\n}\n\n#if\tMOM_CPUSET\n/** @fn pidcache_create\n * @brief\tcreate space to hold a set of PIDs\n *\n * @return\tpidcachetype_t *\n * @retval\tpointer to an array of pidcachetype_t elements long enough to\n *\t\thold a range of values, each of which is sizeof(pidcachetype_t)\n *\t\tbytes in size.  Value N is in the set if the Nth bit of the\n *\t\tarray is nonzero.\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n * @par Note\tTo represent all possible PIDs using pidcachetype_t:  each\n *\t\tpidcachetype_t can hold sizeof(pidcachetype_t) * NBBY bits of\n *\t\tinformation.  A pid_t can take on 1 << (sizeof(pid_t) * NBBY)\n *\t\tpossible values, so the pidcachetype_t array's size must be\n *\t\t(1 << (sizeof(pid_t) * NBBY)) / (sizeof(pidcachetype_t) * NBBY)\n *\t\tbytes.\n */\nstatic pidcachetype_t *\npidcache_create(void)\n{\n\tunsigned long long\tnumerator, denominator;\n\tunsigned long\t\tsetsize;\n\n\tnumerator = ((unsigned long long) 1 << (sizeof(pid_t) * NBBY));\n\tdenominator = (unsigned long long)(sizeof(pidcachetype_t) * NBBY);\n\tsetsize = (unsigned long)((unsigned long long) numerator/denominator);\n\tassert(setsize <=\n\t\t((unsigned long long) 1 << (sizeof(pidcachetype_t) * NBBY)));\n\tassert(pidcache_arena == NULL);\n\tpidcache_arena = calloc(1, (size_t) setsize);\n\treturn (pidcache_arena);\n}\n\n/** @fn pidcache_reset\n * @brief\treset pidcache with new set of PIDs from /dev/cpuset/PBSPro\n *\n * @return\tint\n * @retval\tnprocs\t- number of processes cached\n *\t\t-1\t- when stat fails to open a cpuset tasks file\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n */\nstatic int\npidcache_reset(pidcachetype_t *pidcache)\n{\n\tstruct dirent\t\t*dent = NULL;\n\tpid_t\t\t\tpid = 0;\n\tint\t\t\tncantstat = 0;\n\tFILE\t\t\t*fd = NULL;\n\tchar\t\t\tline[25] = {0};\n\tchar\t\t\t*p = NULL;\n\tint\t\t\ti = 0;\n\tint\t\t\tnprocs = 0;\n\n\tif (cpusetdir == NULL) {\n\t\tif ((cpusetdir = opendir(cpusetfs)) == NULL) {\n\t\t\tlog_err(errno, __func__, \"opendir\");\n\t\t\treturn -1;\n\t\t}\n\t} else\n\t\trewinddir(cpusetdir);\n\n\twhile (errno = 0, (dent = readdir(cpusetdir)) != NULL) {\n\t\tchar *taskname = NULL;\n\t\tif (!isdigit(dent->d_name[0]))\n\t\t\tcontinue;\n\t\tpbs_asprintf(&taskname, \"%s/%s/tasks\", cpusetfs, dent->d_name);\n\n\t\tif ((fd = fopen(taskname, \"r\")) == NULL) {\n\t\t\tncantstat++;\n\t\t\tfree(taskname);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i=0; (p = fgets(line, sizeof(line), fd)) != NULL; i++) {\n\t\t\tpid = strtol(p, NULL, 10);\n\t\t\tif (pidcache_insert(pid, pidcache))\n\t\t\t\tnprocs++;\n\t\t}\n\t\tfree(taskname);\n\t\tfclose(fd);\n\t}\n\n\tif (!nprocs && ncantstat)\n\t\treturn -1;\n\telse\n\t\treturn nprocs;\n}\n\n/** @fn pidcache_destroy\n * @brief\tfree space allocated by pidcache_create()\n *\n * @return\tvoid\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n *\n * @par See:\tpidcache_create\n *\n */\nstatic void\npidcache_destroy(void)\n{\n\tif (pidcache_arena != NULL) {\n\t\tfree(pidcache_arena);\n\t\tpidcache_pidmax = 0;\n\t\tpidcache_arena = NULL;\n\t}\n}\n\n/** @fn pidcache_getarena()\n * @brief\treturn a pointer to the arena allocated by pidcache_create()\n *\n * @return\tpointer to the current storage arena\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n */\nstatic pidcachetype_t *\npidcache_getarena(void)\n{\n\treturn (pidcache_arena);\n}\n\n/**\n * @brief\tadd value to PID set\n *\n * @param[in]\tp\tPID to add\n * @param[in]\tset\tcache arena\n *\n * @return\tint\n * @retval\t0\tp was not inserted into cache\n * @retval\t1\tp was inserted into cache\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n *\n * @par Note:\tas an example, for an integer allocation type and value 12345\n *\t\ton an ILP32 or LP64 machine, the value is stored in the 25th\n *\t\tbit of the 385th integer.\n */\nstatic int\npidcache_insert(pid_t p, pidcachetype_t *set)\n{\n\tunsigned int\tword;\n\tunsigned int\tbitinword;\n\n\tif ((pidcache_pidmax != 0) && (p > pidcache_pidmax))\n\t\treturn (0);\n\telse {\n\t\tword = p / pidcache_bitsper;\n\t\tbitinword = p - (word * pidcache_bitsper);\n\t\tset[word] |= 1 << bitinword;\n\t\treturn (1);\n\t}\n}\n\n/** @fn pidcache_check\n * @brief\tcheck for PID in set\n *\n * @param[in]\tp\tPID to look for\n * @param[in]\tset\tcache arena\n *\n * @return\tint\n * @retval\t0\tPID not found in set\n * @retval\t1\tPID found in set\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n */\nstatic int\npidcache_check(pid_t p, pidcachetype_t *set)\n{\n\tunsigned int\tword;\n\tunsigned int\tbitinword;\n\n\tif ((pidcache_pidmax > 0) && (p > pidcache_pidmax))\n\t\treturn (0);\n\telse {\n\t\tword  = p / pidcache_bitsper;\n\t\tbitinword = p - (word * pidcache_bitsper);\n\t\tif (set[word] & (1 << bitinword))\n\t\t\treturn (1);\n\t\telse\n\t\t\treturn (0);\n\t}\n}\n\n/** @fn pidcache_needed\n * @brief\tis a PID cache needed on this platform?\n *\n * @return\tint\n * @retval\t0\tno\n * @retval\t1\tyes\n *\n * @par MT-Safe:\tyes\n * @par Side Effects:\n *\tNone\n *\n * @par Note:\tthe PID cache implemented here is O(1) in both insertion and\n *\t\tlookup, but is expensive in the amount of memory allocated to\n *\t\thold its data.  Since some platforms where the MoMs run have\n *\t\tno allocated swap space, we may not want to pay the memory\n *\t\tcost on such a platform.  On the other hand, a Linux system\n *\t\twith lots of kernel threads (because there are lots of CPUs)\n *\t\twill benefit substantially.  SGI's Ultraviolet is one such\n *\t\tclass of systems.  SGI suggested the \"/proc/sgi_uv\" test below\n *\t\tas the way to tell we're running on a UV.\n */\nstatic int\npidcache_needed(void)\n{\n\tstruct stat\tsb;\n\n\tif ((stat(\"/proc/sgi_uv\", &sb) == 0) || (pidcache_test == 1))\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n#endif\t/* MOM_CPUSET */\n#endif\t/* PBSMOM_HTUNIT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/src/resmom/linux/mom_start.c": "/*\n * Copyright (C) 1994-2018 Altair Engineering, Inc.\n * For more information, contact Altair at www.altair.com.\n *\n * This file is part of the PBS Professional (\"PBS Pro\") software.\n *\n * Open Source License Information:\n *\n * PBS Pro is free software. You can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n *\n * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial License Information:\n *\n * For a copy of the commercial license terms and conditions,\n * go to: (http://www.pbspro.com/UserArea/agreement.html)\n * or contact the Altair Legal Department.\n *\n * Altair\u2019s dual-license business model allows companies, individuals, and\n * organizations to create proprietary derivative works of PBS Pro and\n * distribute them - whether embedded or bundled with other software -\n * under a commercial license agreement.\n *\n * Use of Altair\u2019s trademarks, including but not limited to \"PBS\u2122\",\n * \"PBS Professional\u00ae\", and \"PBS Pro\u2122\" and Altair\u2019s logos is subject to Altair's\n * trademark licensing policies.\n *\n */\n#include <pbs_config.h>   /* the master config generated by configure */\n/**\n * @file\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <errno.h>\n#include <assert.h>\n#include <ftw.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include \"libpbs.h\"\n#include \"list_link.h\"\n#include \"log.h\"\n#include \"server_limits.h\"\n#include \"attribute.h\"\n#include \"resource.h\"\n#include \"job.h\"\n#include \"pbs_nodes.h\"\n#include \"mom_mach.h\"\n#include \"mom_func.h\"\n#include \"resmon.h\"\n#include \"mom_vnode.h\"\n#include \"libutil.h\"\n#include \"work_task.h\"\n\n/**\n * @struct\n *\tstruct release_info is used to parse the release information\n *\tof ProPack and linux distributions (i.e RHEL/SLES).\n *\n *\tKeep the sgi-release file information at index 0\n *\tTo load the ProPack information, index 0 is used.\n *\tTo load the os information, index 1 thru end is used\n *\tto search which file is available.\n */\n\nstatic struct release_info {\n\tchar *file;\n\tchar *pfx;\n\tchar *srch;\n\tchar *sep;\n} release_info[] = {\n\t{\"/etc/sgi-release\",\t\"PP\",\t\"ProPack\",\t\" \"},\n\t{\"/etc/redhat-release\",\t\"RHEL\",\t\"release\",\t\" \"},\n\t{\"/etc/SuSE-release\",\t\"SLES\",\t\"VERSION\",\t\"=\"},\n\t{\"/etc/os-release\",\t\"SLES\",\t\"VERSION\",\t\"=\"}\n};\n\n/**\n * @struct\n *\tstruct libcsa_support is used to hold verified and tested list of\n *\t<PP ver>, <OS ver>, <Architecture>, <libcsa Ver>, <libjob ver>.\n *\t<PP ver> set to \"---\" for non-SGI systems.\n *\n *\tNOTE: We don't support CSA for RHEL5, since RH declined the backport\n *\tof the upstream kernel changes that would be needed.\n */\n\nstatic struct libcsa_support {\n\tchar *propackver;\n\tchar *osver;\n\tchar *arch;\n\tchar *libcsaver;\n\tchar *libjobver;\n} libcsa_support[] = {\n\t{ \"PP4\", \"SLES9\", \"ia64\", \"libcsa.so.1\", \"libjob.so\"},\n\t{ \"PP5\", \"SLES10\", \"ia64\", \"libcsa.so.1\", \"libjob.so\"},\n\t{ \"PP5\", \"SLES10\", \"x86_64\", \"libcsa.so.2\", \"libjob.so.2\"},\n#ifdef NAS /* localmod 092 */\n\t{ \"PP6\", \"SLES10\", \"ia64\", \"libcsa.so.4\", \"libjob.so.2\"},\n#else\n\t{ \"PP6\", \"SLES10\", \"ia64\", \"libcsa.so.3\", \"libjob.so.2\"},\n#endif /* localmod 092 */\n\t{ \"PP6\", \"SLES10\", \"x86_64\", \"libcsa.so.3\", \"libjob.so.2\"},\n\t{ \"PP6\", \"SLES11\", \"ia64\", \"libcsa.so.4\", \"libjob.so.2\"},\n\t{ \"PP6\", \"SLES11\", \"x86_64\", \"libcsa.so.4\", \"libjob.so.2\"},\n\t{ \"PP7\", \"SLES11\", \"ia64\", \"libcsa.so.4\", \"libjob.so.2\"},\n\t{ \"---\", \"SLES10\", \"x86_64\", \"libcsa.so.1\", \"libjob.so\"},\n\t{ \"---\", \"SLES11\", \"x86_64\", \"libcsa.so.1\", \"libjob.so\"},\n\t{ \"---\", \"SLES12\", \"x86_64\", \"libcsa.so.1\", \"libjob.so.0\"},\n\t{ \"---\", \"SLES12\", \"aarch64\", \"libcsa.so.1\", \"libjob.so.0\"},\n\t{ \"---\", \"SLES15\", \"aarch64\", \"libcsa.so.1\", \"libjob.so.0\"},\n\t{ \"---\", \"SLES15\", \"x86_64\", \"libcsa.so.1\", \"libjob.so.0\"}\n};\n\n/**\n * @enum\n *\tTypes of shared objects for dlopen.\n *\n */\n\nenum sotype {sotype_job, sotype_csa};\n\n/* Global Variables */\n\nextern\tint\t\texiting_tasks;\nextern\tchar\t\tmom_host[];\nextern\tpbs_list_head\tsvr_alljobs;\nextern\tint\t\ttermin_child;\nextern\tint\t\tnum_acpus;\nextern\tint\t\tnum_pcpus;\nextern\tint\t\tsvr_delay_entry;\n\nextern\tpbs_list_head\ttask_list_event;\n\n#if\tMOM_CPUSET || MOM_ALPS\nextern\tchar\t\t*path_jobs;\nchar *get_versioned_libname(int sotype);\nint find_in_lib(void *handle, char * plnam, char *psnam, void ** psp);\n\n/**\n *\tThis is a temporary kludge - this work should really be done by\n *\tpbs_sched:  if the job is getting exclusive use of a vnode, we\n *\twill assign all the CPU (and, if the CPUSET_VERSION >= 4, memory)\n *\tresources of the vnode to the created CPU set.  Exclusive use of\n *\ta vnode is defined by a table in (currently) section E16.4 of the\n *\tGRUNT 2 document, q.v..  It is reproduced here\n *\n *\t\t\t\t\tResource_List.place value\n *\tvnode \"sharing\"\n *\t   value\t\tunset\t   contains \"share\"   contains \"excl\"\n *\t\t\t   ---------------------------------------------------|\n * \tunset  \t       \t   |   \tshare  \t  |    \tshare  \t  |    \texcl   \t      |\n *     \t       \t       \t   |--------------|---------------|-------------------|\n *\t\"default_shared\"   |\tshare\t  |\tshare\t  |\texcl\t      |\n *\t\t    \t   |--------------|---------------|-------------------|\n *\t\"default_excl\"\t   |\texcl\t  |\tshare\t  |\texcl\t      |\n *\t       \t    \t   |--------------|---------------|-------------------|\n *\t\"ignore_excl\"\t   |\tshare\t  |\tshare\t  |\tshare\t      |\n *\t\t    \t   |--------------|---------------|-------------------|\n *\t\"force_excl\"\t   |\texcl\t  |\texcl\t  |\texcl \t      |\n *\t\t\t   |---------------------------------------------------\n *\n *\tand reflected in the vnss[][] array below.\n *\n *\tThis applies to ALPS because the Cray reservation has an EXCLUSIVE\n *\tor SHARED mode that is set from this table.\n */\nenum vnode_sharing_state vnss[][rlplace_excl - rlplace_unset + 1] = {\n\t{ isshared,\tisshared,\tisexcl },\t/* VNS_UNSET */\n\t{ isshared,\tisshared,\tisexcl },\t/* VNS_DFLT_SHARED */\n\t{ isexcl,\tisshared,\tisexcl },\t/* VNS_DFLT_EXCL */\n\t{ isshared,\tisshared,\tisshared },\t/* VNS_IGNORE_EXCL */\n\t{ isexcl,\tisexcl,\t\tisexcl },\t/* VNS_FORCE_EXCL */\n\t{ isexcl,\tisshared,\tisexcl },\t/* VNS_DFLT_EXCLHOST */\n\t{ isexcl,\tisexcl,\t\tisexcl }\t/* VNS_FORCE_EXCLHOST */\n};\n\n#if\t(CPUSET_VERSION >= 4)\nstatic struct bitmask\t*acpus_bits;\nstatic struct bitmask\t*amem_bits;\nint\t\t\tcpus_nbits;\t/* max size of a CPU bitmask */\nint\t\t\tmems_nbits;\t/* max size of a memory bitmask */\n#endif\t/* CPUSET_VERSION >= 4 */\n\n#ifndef MAX\n#define MAX(a, b) (((a)>(b))?(a):(b))\n#endif\n\n/**\n * @brief\n *   \tgetplacesharing\tsharing value for job place\n *\n *   \tCompare the \"place\" string for a job with \"excl\" and \"share\" and\n *   \treturn the corresponding rlplace_value.\n *\n * @param[in] \tpjob\tthe job of interest\n *\n * @return\tenum rlplace_value\n *\n * @par Side-effects\n *   \tA log message is printed at DEBUG level.\n *\n * @par\n *   \tThis code was taken from make_cpuset and put in an externally\n *   \tavailable function for use by the Cray project.\n *\n */\nenum rlplace_value\ngetplacesharing(job *pjob)\n{\n\tstatic\tresource_def\t*prsdef = NULL;\n\tenum rlplace_value\trpv = rlplace_unset;\n\tattribute\t\t*patresc;/* ptr to job/resv resource_list */\n\tresource\t\t*pplace;\n\n\t/*\n\t *\tCompute the \"Resource_List.place\" index for vnss[][]:\n\t */\n\tif (prsdef == NULL) {\n\t\tprsdef = find_resc_def(svr_resc_def, \"place\",\n\t\t\tsvr_resc_size);\n\t}\n\tif (prsdef != NULL) {\n\t\tchar\t*placeval = NULL;\n\n\t\tpatresc = &pjob->ji_wattr[(int)JOB_ATR_resource];\n\t\tpplace = find_resc_entry(patresc, prsdef);\n\t\tif (pplace)\n\t\t\tplaceval = pplace->rs_value.at_val.at_str;\n\t\tif (placeval != NULL) {\n\t\t\tif (place_sharing_check(placeval, PLACE_Excl))\n\t\t\t\trpv = rlplace_excl;\n\t\t\telse if (place_sharing_check(placeval, PLACE_ExclHost))\n\t\t\t\trpv = rlplace_excl;\n\t\t\telse if (place_sharing_check(placeval, PLACE_Shared))\n\t\t\t\trpv = rlplace_share;\n\n\t\t\tsprintf(log_buffer, \"Resource_List.place = %s\",\n\t\t\t\tplaceval);\n\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,\n\t\t\t\tLOG_DEBUG, pjob->ji_qs.ji_jobid,\n\t\t\t\tlog_buffer);\n\t\t}\n\t}\n\treturn rpv;\n}\n#endif\t/* MOM_CPUSET || MOM_ALPS */\n\n#if\tMOM_CPUSET\n/**\n * @brief\n *\tgets info about whether vnode sharing\n *\n * @param[in] mip - pointer to mominfo_t structure which holds vnode info\n *\n * @return \tenum\n * @retval \tvnode_sharing\n *\n */\n\nstatic enum vnode_sharing\ngetvnodesharing(mominfo_t *mip)\n{\n\tmom_vninfo_t\t*mvp;\n\n\tif ((mvp = (mom_vninfo_t *) mip->mi_data) == NULL)\n\t\treturn (VNS_UNSET);\n\telse\n\t\treturn (mvp->mvi_sharing);\n}\n\n/**\n * @brief\n *\tsets name for cpu set\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] prefix - prefix for name\n * @param[in] prelen - length of prefix\n *\n * @return string\n * @retval setname(name)\n *\n */\nchar *\nnewsetname(job *pjob, char *prefix, size_t prelen)\n{\n\tchar\t*setname;\n\tchar\t*jobid = pjob->ji_qs.ji_jobid;\n\tint\tdigits, len, room;\n\n\tsetname = calloc(CPUSET_NAME_SIZE+1, sizeof(char));\n\tassert(setname != NULL);\n\n\t/* find the first '.' in the jobid */\n\tfor (digits=0; jobid[digits]; digits++) {\n\t\tif (jobid[digits] == '.')\n\t\t\tbreak;\n\t}\n\n#if\t(CPUSET_VERSION >= 4)\n\t/* \"/PBSPro\" */\n\tstrncpy(setname, CPUSET_REL_NAME(PBS_CPUSETDIR), CPUSET_NAME_SIZE);\n\tif (prefix != NULL) {\n\t\tif (prefix[0] != '/')\n\t\t\t/* \"/PBSPro/\" */\n\t\t\tstrncat(setname, \"/\",\n\t\t\t\tCPUSET_NAME_SIZE - strlen(setname));\n\t\t/* \"/PBSPro/<prefix>\" */\n\t\tstrncat(setname, prefix, CPUSET_NAME_SIZE - strlen(setname));\n\t} else\n\t\t/* \"/PBSPro/\" */\n\t\tstrncat(setname, \"/\",\n\t\t\tCPUSET_NAME_SIZE - strlen(setname));\n\n#else\n\t/* \"<prefix>\" */\n\tstrncpy(setname, prefix, prelen);\n#endif\t/* CPUSET_VERSION >= 4 */\n\tlen = strlen(setname);\n\troom = CPUSET_NAME_SIZE - len;\t\t/* room left */\n\n\t/* append digits from jobid */\n\tif (digits >= room) {\n\t\tdigits -= room;\t\t\t/* least significant */\n\t\tstrncpy(&setname[len], &jobid[digits], room);\n\t}\n\telse {\n\t\tstrncpy(&setname[len], jobid, room);\n\t}\n\tDBPRT((\"%s:  job %s's cpu set is %s\\n\", __func__, pjob->ji_qs.ji_jobid,\n\t\tsetname))\n\treturn setname;\n}\n\n/**\n * @brief\n *\tGet existing cpuset name for a job.\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return \tstring\n * @retval \tcpuset name\tSUCCESS\n * @retval \tNULL\t\tFAILURE\n *\n */\nchar *\ngetsetname(job *pjob)\n{\n\n\t/* see if altid has it */\n\tif (pjob->ji_wattr[(int)JOB_ATR_altid].at_flags & ATR_VFLAG_SET) {\n\t\tchar\t*setname;\n\t\tchar\t*altid;\n\t\tchar\ttrim[] = \"cpuset=\";\n\t\tint\tlen = strlen(trim);\n\n\t\tsetname = calloc(CPUSET_NAME_SIZE+1, sizeof(char));\n\t\tassert(setname != NULL);\n\t\taltid = pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str;\n\t\tif (strncmp(altid, trim, len) == 0) {\n\t\t\tstrncpy(setname, &altid[len], CPUSET_NAME_SIZE);\n\t\t\t/*\n\t\t\t *\tGet rid of ATTR_altid containing cpuset name.\n\t\t\t */\n\t\t\tif (strlen(setname) == 0) {\n\t\t\t\tDBPRT((\"%s:  \\\"cpuset=\\\" NULL\\n\", __func__))\n\t\t\t\tDBPRT((\"\\tjob id %s\\n\", pjob->ji_qs.ji_jobid))\n\t\t\t\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],\n\t\t\t\t\tATTR_altid, NULL, NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn setname;\n\t\t}\n\t\tfree(setname);\n\t}\n\treturn NULL;\n}\n\nint\t\t\t*cpuignore = NULL;\n\n/**\n * @brief\n *\tSet up to use cpusets.\n *\tLook for any cpuset that does not \"belong\" to PBS and deduct\n *\tthe cpus that are unavailable from our cpu count.\n *\n * @param[in] recover - indiaction flag for recovery\n *\n * @return Void\n *\n */\nvoid\n#if\t(CPUSET_VERSION < 4)\ncpusets_initialize(void)\n#else\ncpusets_initialize(int recover)\n#endif\t/* CPUSET_VERSION < 4 */\n{\n\tint\t\t\ti;\n#if\t(CPUSET_VERSION >= 4)\n\tint\t\t\tcpuset_create_fail;\n\tchar\t\t\thelpme[] = \" - manual intervention is needed\";\n\tstatic struct cpuset\t*newcp = NULL;\t/* for created CPU sets */\n\tstatic struct cpuset\t*rootcp = NULL;\t/* for /dev/cpuset */\n\n\t/*\n\t *\tThe ProPack 4 CPU set directory structure within the cpuset\n\t *\tfile system looks like this:\n\t *\n\t *\t/dev/cpuset/\t\t\troot CPU set;  also the place\n\t *\t\t\t\t\tsuspended jobs go\n\t *\n\t *\t\tPBSPro/\t\t\troot directory for all PBS\n\t *\t\t\t\t\tCPU sets\n\t *\n\t *\t\t\t<qname>/\tindividual CPU sets are here\n\t *\n\t */\n\n\tif (cpus_nbits == 0)\n\t\tcpus_nbits = cpuset_cpus_nbits();\n\tif (mems_nbits == 0)\n\t\tmems_nbits = cpuset_mems_nbits();\n\n\t/*\n\t *\tIn case we've been restarted after the available number of CPUs\n\t *\tor amount of memory has changed, first forget the old values.\n\t */\n\tif (acpus_bits != NULL)\n\t\tbitmask_free(acpus_bits);\n\tif ((acpus_bits = bitmask_alloc(cpus_nbits)) == NULL) {\n\t\tlog_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_ERR, __func__, \"acpus_bits bitmask_alloc failed\");\n\t\texit(1);\n\t}\n\tif (amem_bits != NULL)\n\t\tbitmask_free(amem_bits);\n\tif ((amem_bits = bitmask_alloc(mems_nbits)) == NULL) {\n\t\tlog_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_ERR, __func__, \"amem_bits bitmask_alloc failed\");\n\t\texit(1);\n\t}\n\tif (cpuignore != NULL)\n\t\tfree(cpuignore);\n\tif ((cpuignore = calloc(num_pcpus, sizeof(int))) == NULL) {\n\t\tlog_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_ERR, __func__, \"cpuignore[] calloc failed\");\n\t\texit(1);\n\t}\n\n\t/*\n\t *\tAfter ftw() returns, cpuignore_return() will be able to\n\t *\tinitialize the cpuignore[] array as well as the bitmask\n\t *\tof available CPUs, acpus_bits.\n\t */\n\tcpuignore_setup(cpuignore, num_pcpus, acpus_bits);\n\tif (ftw(DEV_CPUSET, inuse_cpus, 3) == -1) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_ERR, __func__, \"ftw failed\");\n\t\texit(1);\n\t}\n\tcpuignore_return();\n\n\t/*\n\t *\tCheck to see if we are going to be doing cpu exclusive\n\t *\tcpusets.  If so, we can't use cpu0.\n\t */\n\tif ((cpuset_create_flags & CPU_EXCLUSIVE) && !cpuignore[0]) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_WARNING, __func__,\n\t\t\t\"CPUSET_CPU_EXCLUSIVE is on so cpu0 must not be used\");\n\t\tcpuignore[0] = 1;\n\t\tbitmask_clearbit(acpus_bits, 0);\n\t}\n\n\tif (rootcp == NULL) {\n\t\tnewcp = cpuset_alloc();\n\t\trootcp = cpuset_alloc();\n\t\tassert((newcp != NULL) && (rootcp != NULL));\n\t}\n\n\t/* sanity check only:  is the root CPU set there? */\n\tif (cpuset_query(rootcp, DEV_CPUSET_ROOT) == -1) {\n\t\tsprintf(log_buffer, \"cpuset_query for / failed%s\", helpme);\n\t\tlog_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t__func__, log_buffer);\n\t\texit(1);\n\t}\n\n\t/*\n\t *\tCatch the case where we were started with the '-p' flag, but\n\t *\tno PBSPro CPU set hierarchy currently exists.\n\t */\n\tif (cpuset_query(newcp, CPUSET_REL_NAME(PBS_CPUSETDIR)) == -1)\n\t\trecover = 0;\n\n\tif (recover == 2) {\n\t\t/*\n\t\t *\tOn warm start, read the CPU and memory information\n\t\t *\tfrom the preexisting /PBSPro CPU set.\n\t\t */\n\t\tif (cpuset_query(newcp, CPUSET_REL_NAME(PBS_CPUSETDIR)) == -1) {\n\t\t\tsprintf(log_buffer, \"/PBSPro query failed%s\", helpme);\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, log_buffer);\n\t\t\texit(1);\n\t\t}\n\t\tif (cpuset_getcpus(newcp, acpus_bits) == -1) {\n\t\t\tsprintf(log_buffer, \"/PBSPro cpuset_getcpus failed%s\",\n\t\t\t\thelpme);\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, log_buffer);\n\t\t\texit(1);\n\t\t}\n\t\tif (cpuset_getmems(newcp, amem_bits) == -1) {\n\t\t\tsprintf(log_buffer, \"/PBSPro cpuset_getmems failed%s\",\n\t\t\t\thelpme);\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, log_buffer);\n\t\t\texit(1);\n\t\t}\n\n\t\treassociate_job_cpus_setup(cpus_nbits);\n\t\tif (ftw(PBS_CPUSETDIR, reassociate_job_cpus, 3) == -1) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\tLOG_ERR, __func__, \"job<->CPU reassociation failed\");\n\t\t\texit(1);\n\t\t}\n\t\t(void) reassociate_job_cpus_return();\n\n\t\tgoto cullCPUs;\n\t} else {\n\t\t/*\n\t\t *\tEither init_abort_jobs() will have killed off leftover\n\t\t *\trunning jobs or we are assumed to be starting at boot\n\t\t *\ttime.  In either of these cases, we believe we may\n\t\t *\tconsider it an error if jobs are still running (which\n\t\t *\twould cause us to be unable to build the PBS subtree in\n\t\t *\t/dev/cpuset.\n\t\t */\n\t\tint cleanup_errorflag;\n\t\tchar err[] = \"/PBSPro hierarchy cleanup failed in %s - \"\n\t\t\t\"restart pbs_mom with '-p'\\n\";\n\n\t\trestart_setup();\n\t\tif (access(PBS_CPUSETDIR, R_OK|W_OK|X_OK) == 0) {\n\t\t\tif (ftw(PBS_CPUSETDIR, restart_cleanupprep, 3) == -1) {\n\t\t\t\tsprintf(log_buffer, err, PBS_CPUSETDIR);\n\t\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\t\tLOG_ERR, __func__, log_buffer);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trestart_return(&cleanup_errorflag);\n\t\t\tif (cleanup_errorflag) {\n\t\t\t\tsprintf(log_buffer, err, PBS_CPUSETDIR);\n\t\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\t\t\tLOG_ERR, __func__, log_buffer);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\n\t\tif (cpuset_setcpus(newcp, acpus_bits) == -1) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, \"/PBSPro cpuset_setcpus failed\");\n\t\t\texit(1);\n\t\t}\n\t\tget_membits(amem_bits);\n\t\tif (bitmask_weight(amem_bits) == 0) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, \"no memory boards found\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cpuset_setmems(newcp, amem_bits) == -1) {\n\t\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR,\n\t\t\t\t__func__, \"/PBSPro cpuset_setmems failed\");\n\t\t\texit(1);\n\t\t}\n\t\tcpuset_set_iopt(newcp, \"notify_on_release\", 0);\n\t}\n\n\tcpuset_set_iopt(newcp, \"cpu_exclusive\", 1);\n\n\tif ((cpuset_create_flags & MEM_EXCLUSIVE) == 0)\n\t\tcpuset_set_iopt(newcp, \"mem_exclusive\", 0);\n\telse {\n\t\t/*\n\t\t * if there is more than one memory pool on the node, allow mem\n\t\t * exclusive; else if there we need to share with some existing cpuset,\n\t\t * clear exclusive\n\t\t */\n\t\tcpuset_set_iopt(newcp, \"mem_exclusive\", 1);\n\t\tif (numnodes() == 1) {\t/* returns the number of \"mems\" */\n\t\t\tfor (i=0; i<num_pcpus; i++) {\n\t\t\t\tif (cpuignore[i]) {\n\t\t\t\t\tcpuset_set_iopt(newcp, \"mem_exclusive\", 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcpuset_create_fail = 0;\n\tif ((cpuset_modify(CPUSET_REL_NAME(PBS_CPUSETDIR), newcp) == -1) &&\n\t\t(cpuset_create(CPUSET_REL_NAME(PBS_CPUSETDIR), newcp) == -1)) {\n\n\t\tcpuset_create_fail = 1;\n\n\t\tif (errno == ENXIO) {\n\t\t\t/*\n\t\t\t * retry with cpu_exclusive off. This rejection is due to\n\t\t\t * a ProPack bug which causes a Kernel crash if not all of\n\t\t\t * the cpus in a package are included in a exclusive cpuset\n\t\t\t */\n\n\t\t\tcpuset_set_iopt(newcp, \"cpu_exclusive\", 0);\n\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_NODE, LOG_NOTICE,\n\t\t\t\t__func__, \"Setting cpu_exclusive to 0\");\n\n\t\t\tif ((cpuset_modify(CPUSET_REL_NAME(PBS_CPUSETDIR), newcp)!=-1) ||\n\t\t\t\t(cpuset_create(CPUSET_REL_NAME(PBS_CPUSETDIR), newcp)!=-1)) {\n\n\t\t\t\tcpuset_create_fail = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cpuset_create_fail) {\n\t\tchar\tcpuset_errbuf[BUFSIZ];\n\t\tchar\tcpubitbuf[BUFSIZ];\n\t\tchar\tmembitbuf[BUFSIZ];\n\n\t\tbitmask_displayhex(cpubitbuf, sizeof(cpubitbuf), acpus_bits);\n\t\tbitmask_displayhex(membitbuf, sizeof(membitbuf), amem_bits);\n\t\tsprintf(cpuset_errbuf,\n\t\t\t\"/PBSPro (re)creation failed, CPU bits:  %s, mem bits:  %s\",\n\t\t\tcpubitbuf, membitbuf);\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_ERR, __func__,\n\t\t\tcpuset_errbuf);\n\t\t/*\n\t\t *\tDue to a bug in the current version of ProPack 4, it's\n\t\t *\tnecessary to clean up after unsuccessful creation\n\t\t *\tattempts.\n\t\t */\n\t\t(void) cpuset_delete(CPUSET_REL_NAME(PBS_CPUSETDIR));\n\t\texit(1);\n\t}\n\ncullCPUs:\n#else\n\tcpuset_NameList_t\t*names;\n\tchar\t\t\t*jobset = NULL;\n\tint\t\t\tnumsets;\n\tjob\t\t\t*pjob;\n\n\tif ((names = cpusetGetNameList()) == NULL)\n\t\treturn;\n\n\tif (cpuignore == NULL) {\n\t\tcpuignore = calloc(num_pcpus, sizeof(int));\n\t\tassert(cpuignore != NULL);\n\t}\n\n\tnumsets = names->count;\n\tfor (i=0; i<numsets; i++) {\n\t\tcpuset_CPUList_t\t*cpulst;\n\t\tint\t\t\tj;\n\t\tchar\t\t\t*qname = names->list[i];\n\n\t\t/* not a very good way to search but it isn't done often */\n\t\tfor (pjob = (job *)GET_NEXT(svr_alljobs);\n\t\t\tpjob != NULL;\n\t\t\tpjob = (job *)GET_NEXT(pjob->ji_alljobs)) {\n\t\t\tjobset = getsetname(pjob);\n\t\t\tif (jobset == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(jobset, qname) == 0)\t\t/* ours */\n\t\t\t\tbreak;\n\t\t\tfree(jobset);\n\t\t\tjobset = NULL;\t/* to prevent second free */\n\t\t}\n\t\tif (jobset != NULL)\n\t\t\tfree(jobset);\n\t\tif (pjob != NULL)\t/* matched a job */\n\t\t\tcontinue;\n\n\t\tcpulst = cpusetGetCPUList(qname);\n\t\tif (cpulst == NULL) {\n\t\t\tsprintf(log_buffer, \"cpusetGetCPUList %s\", qname);\n\t\t\tlog_err(errno, __func__, log_buffer);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsprintf(log_buffer,\n\t\t\t\"ignoring %d cpus in initial cpuset \\\"%s\\\"\",\n\t\t\tcpulst->count, qname);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_NODE, LOG_NOTICE,\n\t\t\t__func__, log_buffer);\n\t\tfor (j=0; j<cpulst->count; j++) {\n\t\t\tint\tcpu = cpulst->list[j];\n\n\t\t\tcpuignore[cpu] = 1;\n\t\t}\n\t\tcpusetFreeCPUList(cpulst);\n\t}\n\tcpusetFreeNameList(names);\n\n\t/*\n\t **\tCheck to see if we are going to be doing cpu exclusive\n\t **\tcpusets.  If so, we can't use cpu0.\n\t */\n\tif ((cpuset_create_flags & CPUSET_CPU_EXCLUSIVE) && !cpuignore[0]) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE, LOG_WARNING, __func__,\n\t\t\t\"CPUSET_CPU_EXCLUSIVE is on so cpu0 must not be used\");\n\t\tcpuignore[0] = 1;\n\t}\n\n#endif\t/* CPUSET_VERSION >= 4 */\n\n\tfor (i=0; i<num_pcpus; i++) {\n\t\tif (cpuignore[i]) {\n\t\t\tnum_acpus--;\n\t\t\tcpunum_outofservice(i);\n\t\t\tDBPRT((\"%s:  ignore CPU %d\\n\", __func__, i))\n\t\t}\n\t}\n\tif (num_acpus <= 0) {\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_NODE,\n\t\t\tLOG_NOTICE, __func__, \"FATAL: No cpus are available to PBS\");\n\t\texit(2);\n\t}\n}\n\n/**\n * @brief\n *\tmakes cpu set for job\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] modify - if set to 1, don't create job's cpuset from scratch but\n *\t\t\trather, update it using the current resource values assigned\n *\t\t\tto the job, which may have recently changed.\n *\n * @return \tstring\n * @retval      cpuset name     SUCCESS\n * @retval      NULL            FAILURE\n *\n */\n\nstatic char *\nmake_cpuset_inner(job *pjob, int modify)\n{\n\tchar\t\t\t*qname = NULL;\n\tchar\t\t\t*ret = NULL;\n\tint\t\t\ti, j;\n\tint\t\t\tdo_meminit;\n\tint\t\t\t*cpulist = NULL, *temp_cpulist = NULL;\n\tlong\t\t\tncpus;\t/* size of cpulist[] array */\n\tint\t\t\ttotal_cpus_assigned = 0;\n\tchar\t\t\tname_buf[MAXPATHLEN+1];\n\thnodent\t\t\t*hn;\n\tenum rlplace_value\trpv;\t/* computed index into vnss[][] above */\n\tenum vnode_sharing\tvnsv;\t/* computed index into vnss[][] above */\n\tint\t\t\tdoexcl;\t/* is this vnode \"exclusive\"? */\n#if\t(CPUSET_VERSION < 4)\n\tchar\t\t\t*fname = NULL;\n\tint\t\t\tnumsets;\n\tint\t\t\tfd = -1;\n\tcpuset_NameList_t\t*names;\n\tcpuset_QueueDef_t\t*qdef;\n#else\n\tstruct cpuset\t\t*cp = NULL;\n\tstatic struct bitmask\t*cpubits = NULL;\n\tstatic struct bitmask\t*membits = NULL;\n\tint\t\t\tcpuset_exists;\n\tint\t(*cpuset_action)(const char *, const struct cpuset *cp);\n\n\t/* room for the full path of a PBS CPU set in the file system */\n\tchar\t\t\tpathbuf[sizeof(DEV_CPUSET) + 1 +\n\tCPUSET_NAME_SIZE];\n#endif\t/* CPUSET_VERSION < 4 */\n\n\trpv = getplacesharing(pjob);\n\n\t/*\n\t ** Check to see if job already has a cpuset.\n\t */\n\tDBPRT((\"%s:  job %s\\n\", __func__, pjob->ji_qs.ji_jobid))\n\tqname = getsetname(pjob);\t/* get name for job cpuset */\n\n\tif (qname != NULL) {\n#if\t(CPUSET_VERSION < 4)\n\t\t/* get all the cpuset names on the system */\n\t\tif ((names = cpusetGetNameList()) == NULL) {\n\t\t\tfree(qname);\n\t\t\tlog_joberr(errno, __func__, \"cpusetGetNameList\",\n\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* see if job cpuset exists */\n\t\tnumsets = names->count;\n\t\tfor (i=0; i<numsets; i++) {\n\t\t\tif (strcmp(names->list[i], qname) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tcpusetFreeNameList(names);\n\t\tif (i < numsets)\t\t\t/* found it */\n\t\t\treturn qname;\n#else\n\t\tif (!modify) {\n\t\t\tif ((cp = cpuset_alloc()) == NULL) {\n\t\t\t\tlog_joberr(errno, __func__, \"cpuset_alloc\",\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tfree(qname);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (cpuset_query(cp, qname) == -1)\n\t\t\t\tcpuset_exists = 0;\n\t\t\telse\n\t\t\t\tcpuset_exists = 1;\n\t\t\tcpuset_free(cp);\n\t\t\tif (cpuset_exists)\n\t\t\t\treturn qname;\n\t\t\telse {\n\t\t\t\tfree(qname);\n\t\t\t\tqname = newsetname(pjob, NULL, 0);\n\t\t\t}\n\t\t}\n#endif\t/* CPUSET_VERSION < 4 */\n\t} else {\n\t\tqname = newsetname(pjob, NULL, 0);\n\t\tif (qname == NULL)\n\t\t\treturn (NULL);\n\t\tmodify = 0; /* new cpuset name, so create mode */\n\t\t\t\n\t}\n\t/*\n\t *\tThe hnodent with index pjob->ji_nodeid contains a list of\n\t *\thn_vlnum vnodes in hn_vlist[], each of which belongs to this\n\t *\thost, and contains information on the number of CPUs and\n\t *\tamount of memory to assign from the vnode.  From this, and\n\t *\tmom's list of CPUs per vnode, we choose CPUs to be assigned\n\t *\tto this job.  The list of CPUs to assign goes into the cpulist[]\n\t *\tarray, used below to construct the job's CPU set.\n\t #if\t(CPUSET_VERSION >= 4)\n\t *\n\t *\tIn contrast, the Linux NUMA model presents a single memory\n\t *\tnode - never more than one - per ``cbrick'', so rather than\n\t *\tmaking a list and using it later, we directly manipulate the\n\t *\tset's membits mask.\n\t #else\n\t *\tFor ProPack [23], we do not separately initialize memory\n\t *\tinformation for the CPU set.\n\t #endif\n\t */\n\tfor (i = 0, ncpus = 0, total_cpus_assigned = 0, do_meminit = 1,\n\t\thn = &pjob->ji_hosts[pjob->ji_nodeid];\n\t\ti < hn->hn_vlnum; i++) {\n\t\tmominfo_t\t*mip;\n\t\tmom_vninfo_t\t*mvp;\n\t\thost_vlist_t\t*hv;\n\t\tint\t\tcpus_this_vnode;\n\n\t\thv = &hn->hn_vlist[i];\n\t\tdoexcl = 0;\n\n\t\t/* to avoid multiple expensive find_mominfo() calls */\n\t\tmip = NULL;\n\n#if\t(CPUSET_VERSION >= 4)\n\t\tif (hv->hv_mem > 0) {\n\t\t\t/*\n\t\t\t *\tWith properly functioning scheduler and server,\n\t\t\t *\tneither of the following two tests should ever\n\t\t\t *\tsucceed.\n\t\t\t */\n\t\t\tif ((mip == NULL) &&\n\t\t\t\t(mip = find_mominfo(hv->hv_vname)) == NULL) {\n\t\t\t\tsprintf(log_buffer, \"find_mominfo %s failed\",\n\t\t\t\t\thv->hv_vname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tvnsv = getvnodesharing(mip);\n\t\t\t\tif (vnss[vnsv][rpv] == isexcl)\n\t\t\t\t\tdoexcl = 1;\n\t\t\t}\n\t\t\tif ((mvp = (mom_vninfo_t *) mip->mi_data) == NULL) {\n\t\t\t\tsprintf(log_buffer, \"vnode %s:  NULL mi_data\",\n\t\t\t\t\thv->hv_vname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (doexcl != 0) {\n\t\t\t\t/*\n\t\t\t\t *\tWe're already assigning all the memory\n\t\t\t\t *\tfor this vnode;  if exclusive, snag all\n\t\t\t\t *\t(which may be zero) the CPUs as well.\n\t\t\t\t */\n\t\t\t\thv->hv_ncpus = mvp->mvi_acpus;\n\t\t\t}\n\n\t\t\tif (mvp->mvi_memnum == (unsigned int) -1) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"vnode %s:  uninitialized mvi_memnum\",\n\t\t\t\t\thv->hv_vname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (membits == NULL) {\n\t\t\t\tif ((membits = bitmask_alloc(mems_nbits)) ==\n\t\t\t\t\tNULL) {\n\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\"bitmask_alloc membits\");\n\t\t\t\t\tlog_joberr(errno, __func__, log_buffer,\n\t\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (do_meminit == 1) {\n\t\t\t\tdo_meminit = 0;\n\t\t\t\t(void) bitmask_clearall(membits);\n\t\t\t}\n\t\t\t(void) bitmask_setbit(membits, mvp->mvi_memnum);\n\t\t}\n#endif\t/* CPUSET_VERSION >= 4 */\n\n\t\tif (hv->hv_ncpus > 0) {\n\t\t\t/*\n\t\t\t *\tWith properly functioning scheduler and server,\n\t\t\t *\tnone of the following three tests should ever\n\t\t\t *\tsucceed.\n\t\t\t */\n\t\t\tif ((mip == NULL) &&\n\t\t\t\t(mip = find_mominfo(hv->hv_vname)) == NULL) {\n\t\t\t\tsprintf(log_buffer, \"find_mominfo %s failed\",\n\t\t\t\t\thv->hv_vname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tvnsv = getvnodesharing(mip);\n\t\t\t\tif (vnss[vnsv][rpv] == isexcl)\n\t\t\t\t\tdoexcl = 1;\n\t\t\t}\n\n\t\t\tif ((mvp = (mom_vninfo_t *) mip->mi_data) == NULL) {\n\t\t\t\tsprintf(log_buffer, \"vnode %s:  NULL mi_data\",\n\t\t\t\t\thv->hv_vname);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (doexcl != 0) {\n\t\t\t\t/*\n\t\t\t\t *\tIf exclusive, snag all the CPUs and\n\t\t\t\t *\tmemory for this vnode.\n\t\t\t\t */\n\t\t\t\thv->hv_ncpus = mvp->mvi_acpus;\n#if\t(CPUSET_VERSION >= 4)\n\t\t\t\tif (hv->hv_mem == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t *\tWe assigned no memory above, so\n\t\t\t\t\t *\tthere's more work to do here.\n\t\t\t\t\t */\n\t\t\t\t\tif (mvp->mvi_memnum == (unsigned int) -1) {\n\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\"vnode %s:  uninitialized mvi_memnum\",\n\t\t\t\t\t\t\thv->hv_vname);\n\t\t\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (membits == NULL) {\n\t\t\t\t\t\tif ((membits = bitmask_alloc(mems_nbits)) ==\n\t\t\t\t\t\t\tNULL) {\n\t\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\t\"bitmask_alloc membits\");\n\t\t\t\t\t\t\tlog_joberr(errno, __func__, log_buffer,\n\t\t\t\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (do_meminit == 1) {\n\t\t\t\t\t\tdo_meminit = 0;\n\t\t\t\t\t\t(void) bitmask_clearall(membits);\n\t\t\t\t\t}\n\t\t\t\t\t(void) bitmask_setbit(membits,\n\t\t\t\t\t\tmvp->mvi_memnum);\n\t\t\t\t}\n#endif\t/* CPUSET_VERSION >= 4 */\n\t\t\t}\n\t\t\tif (hv->hv_ncpus > mvp->mvi_acpus) {\n\t\t\t\t/*\n\t\t\t\t *\tThis consistency check should never have\n\t\t\t\t *\tfailed.  If it did, something in the\n\t\t\t\t *\tMOM's configuration, a synchronization\n\t\t\t\t *\terror between us and pbs_server, or a\n\t\t\t\t *\tsilly operator error (e.g. manually\n\t\t\t\t *\tplacing a job that won't fit) has caused\n\t\t\t\t *\tus to be given an exec specification we\n\t\t\t\t *\tcan't meet.\n\t\t\t\t *\n\t\t\t\t *\tThis message is designed to tell a\n\t\t\t\t *\tdeveloper what's wrong, not a customer.\n\t\t\t\t *\tThe customer error message will occur\n\t\t\t\t *\tas a result of returning (via \"done\")\n\t\t\t\t *\twithout creating a CPU set for the job.\n\t\t\t\t *\n\t\t\t\t *\tSome people feel that all log entries\n\t\t\t\t *\tshould be interpretable by customers,\n\t\t\t\t *\twho would be confused by seeing this\n\t\t\t\t *\tone.  We therefore append the time-\n\t\t\t\t *\thonored UNIX phrase from the Lions' book\n\t\t\t\t *\tto make it clear that customers need not\n\t\t\t\t *\tworry their pretty little heads about\n\t\t\t\t *\tthis message.\n\t\t\t\t */\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"vnode %s:  hv_ncpus (%d) > mvi_acpus (%d) \"\n\t\t\t\t\t\"(you are not expected to understand this)\",\n\t\t\t\t\thv->hv_vname, hv->hv_ncpus, mvp->mvi_acpus);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tcpus_this_vnode is used as a consistency check:\n\t\t\t *\twhen we're done assigning CPUs for this vnode,\n\t\t\t *\tit should equal hv_ncpus, the number of CPUs we\n\t\t\t *\tought to have assigned.\n\t\t\t */\n\t\t\tfor (j = cpus_this_vnode = 0; j < mvp->mvi_ncpus; j++) {\n\t\t\t\tif (MVIC_CPUISFREE(mvp, j)) {\n\t\t\t\t\ttemp_cpulist = realloc(cpulist,\n\t\t\t\t\t\t(ncpus + 1) * sizeof(int));\n\t\t\t\t\tif (temp_cpulist == NULL) {\n\t\t\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\t\t\"cpulist realloc failed\");\n\t\t\t\t\t\tlog_joberr(errno, __func__,\n\t\t\t\t\t\t\tlog_buffer,\n\t\t\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcpulist = temp_cpulist;\n\t\t\t\t\t\tncpus++;\n\t\t\t\t\t}\n\t\t\t\t\tcpuindex_inuse(mvp, j, pjob);\n\t\t\t\t\tcpulist[total_cpus_assigned] =\n\t\t\t\t\t\tmvp->mvi_cpulist[j].mvic_cpunum;\n\t\t\t\t\ttotal_cpus_assigned++;\n\t\t\t\t\tcpus_this_vnode++;\n\t\t\t\t\tif (cpus_this_vnode == hv->hv_ncpus)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if ((doexcl == 1) &&\n\t\t\t\t\t(mvp->mvi_cpulist[j].mvic_job == pjob)) {\n\t\t\t\t\t/*\n\t\t\t\t\t *\tBecause the same vnode may be\n\t\t\t\t\t *\tpresent multiple times in the\n\t\t\t\t\t *\texec_vnode list, we look to see\n\t\t\t\t\t *\twhether any of this vnode's CPUs\n\t\t\t\t\t *\thas already been assigned to our\n\t\t\t\t\t *\tjob;  if so, we arrange for the\n\t\t\t\t\t *\tCPUs assigned to look as we\n\t\t\t\t\t *\texpect in the consistency check\n\t\t\t\t\t *\tbelow.\n\t\t\t\t\t */\n\t\t\t\t\tcpus_this_vnode = hv->hv_ncpus;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cpus_this_vnode != hv->hv_ncpus) {\n\t\t\t\tsprintf(log_buffer, \"vnode %s:  \"\n\t\t\t\t\t\"cpus_this_vnode (%d) != hv_ncpus (%d)\",\n\t\t\t\t\thv->hv_vname, cpus_this_vnode,\n\t\t\t\t\thv->hv_ncpus);\n\t\t\t\tlog_joberr(-1, __func__, log_buffer,\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n#if\t(CPUSET_VERSION < 4)\n\tmodify = 0;\t/* this mode not supported under older cpusets. */\n\t/*\n\t **\tCreate file then the cpuset.\n\t */\n\tstrcpy(name_buf, path_jobs);\n\tstrcat(name_buf, qname);\n\tstrcat(name_buf, JOB_CPUSET_SUFFIX);\n\n\tif ((fd = creat(name_buf, 0744)) == -1) {\n\t\tsprintf(log_buffer, \"create %s\", name_buf);\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n\t(void)fchmod(fd, 0744);\n\tfname = name_buf;\n\tif ((qdef = cpusetAllocQueueDef(ncpus)) == NULL) {\n\t\tsprintf(log_buffer, \"cpusetAllocQueueDef\");\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n\tqdef->flags = cpuset_create_flags;\n\tqdef->permfile = name_buf;\n\tqdef->cpu->count = ncpus;\n\tfor (i=0; i<ncpus; i++)\n\t\tqdef->cpu->list[i] = cpulist[i];\n\ti = cpusetCreate(qname, qdef);\n\tcpusetFreeQueueDef(qdef);\n\tif (i == 0) {\n\t\tsprintf(log_buffer, \"cpusetCreate %s\", qname);\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n#else\n\t/*\n\t *\tCreate a new CPU set for this job\n\t */\n\tassert((qname != NULL) && (qname[0] == '/'));\n\tstrncpy(name_buf, qname, sizeof(name_buf) - 1);\n\n\tif ((cp = cpuset_alloc()) == NULL) {\n\t\tsprintf(log_buffer, \"cpuset_alloc\");\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n\tif (cpubits == NULL) {\n\t\tif ((cpubits = bitmask_alloc(cpus_nbits)) == NULL) {\n\t\t\tsprintf(log_buffer, \"bitmask_alloc cpubits\");\n\t\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (membits == NULL) {\n\t\tif ((membits = bitmask_alloc(mems_nbits)) == NULL) {\n\t\t\tsprintf(log_buffer, \"bitmask_alloc membits\");\n\t\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t\tgoto done;\n\t\t} else\n\t\t\t(void) bitmask_clearall(membits);\n\t}\n\n\t(void) bitmask_clearall(cpubits);\n\tfor (i = 0; i < ncpus; i++)\n\t\t(void) bitmask_setbit(cpubits, cpulist[i]);\n\n\t/*\n\t *\tIf do_meminit is nonzero at this point, no memory allocation\n\t *\twas present in the vnodes assigned from this host.  If we try\n\t *\tto create a CPU set with no memory boards in it, cpuset_create()\n\t *\twill return EINVAL.  We avoid this by defaulting to ``local''\n\t *\tmemory (as defined by cpuset_localmems(3)) in this case, but\n\t *\talso take into account amem_bits, the previously initialized\n\t *\tmask of memory available to us.\n\t *\n\t *\tNote that this initialization must occur after initializing\n\t *\tcpubits from cpulist[].\n\t */\n\tif (do_meminit != 0) {\n\t\tif (cpuset_localmems((const struct bitmask *) cpubits,\n\t\t\tmembits) == -1) {\n\t\t\tsprintf(log_buffer, \"cpuset_localmems %s\", qname);\n\t\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t\tgoto done;\n\t\t}\n\t\t(void) bitmask_and(membits, membits, amem_bits);\n\t\tif (bitmask_weight(membits) == 0) {\n\t\t\tlog_joberr(-1, __func__, \"cannot assign memory for set\",\n\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (cpuset_setcpus(cp, cpubits) == -1) {\n\t\tsprintf(log_buffer, \"cpuset_setcpus %s\", qname);\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n\tif (cpuset_setmems(cp, membits) == -1) {\n\t\tsprintf(log_buffer, \"cpuset_setmems %s\", qname);\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\tgoto done;\n\t}\n\n\t/*\n\t *\tWe can't set the ``notify_on_release'' flag to 1 because the\n\t *\tCPU set created on a sister mom might disappear as a side-\n\t *\teffect of a set of multinode processes having been attached\n\t *\tto the set, then exited.  Trust del_cpusetfile() to clean up.\n\t */\n\tcpuset_set_iopt(cp, \"notify_on_release\", 0);\n\tcpuset_set_iopt(cp, \"cpu_exclusive\", 0);\n\tcpuset_set_iopt(cp, \"mem_exclusive\", 0);\n\n\tif (modify)\n\t\tcpuset_action = cpuset_modify;\n\telse\n\t\tcpuset_action = cpuset_create;\n\n\tif (cpuset_action(name_buf, cp) == -1) {\n\t\textern char\t*cpuset_error_action;\n\n\t\tsprintf(log_buffer, \"cpuset_%s %s\", modify ? \"modify\" : \"create\", qname);\n\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t(void) cpuset_delete(name_buf);\n\t\tif (!strcmp(cpuset_error_action, \"offline\")) {\n\t\t\toffline_job_vnodes(pjob);\n\t\t\trequeue_job(pjob);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (!modify) {\n\t\tstrncpy(pathbuf, DEV_CPUSET, sizeof(pathbuf));\n\t\tstrncat(pathbuf, name_buf, sizeof(pathbuf) - strlen(pathbuf));\n\n\t\tif (chmod(pathbuf, 0755) == -1) {\n\t\t\tsprintf(log_buffer, \"chmod(%s, 0755)\", pathbuf);\n\t\t\tlog_joberr(errno, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\t\t}\n\t}\n\n#endif\t/* CPUSET_VERSION < 4 */\n\tsprintf(log_buffer, \"%s cpuset %s\", modify ? \"modified\" : \"created\", qname);\n\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\tpjob->ji_qs.ji_jobid, log_buffer);\n#ifdef NAS /* localmod 093 */\n\tstrcpy(log_buffer, \"cpus = \");\n\t{\n\t\tsize_t tlen;\n\t\ttlen = strlen(log_buffer);\n\t\tbitmask_displaylist(log_buffer+tlen, sizeof(log_buffer) - tlen,\n\t\t\tcpubits);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tpjob->ji_qs.ji_jobid, log_buffer);\n\t}\n#endif /* localmod 093 */\n\tret = qname;\n\ndone:\n\n\tif (cpulist != NULL) {\n\t\t/*\n\t\t *\tIf we get here with ret still NULL, an error has\n\t\t *\toccurred and we will need to clean up any CPUs\n\t\t *\ttentatively assigned above.\n\t\t */\n\t\tif (ret == NULL)\n\t\t\tfor (i = 0; i < total_cpus_assigned; i++)\n\t\t\t\tcpunum_free(cpulist[i]);\n\t\tfree(cpulist);\n\t}\n\n#if\t(CPUSET_VERSION < 4)\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (ret == NULL) {\n\t\tif (fname != NULL)\n\t\t\tunlink(fname);\n\t\tif (qname != NULL)\n\t\t\tfree(qname);\n\t}\n#else\n\tif (cp != NULL)\n\t\tcpuset_free(cp);\n\tif (ret == NULL) {\n\t\tif (qname != NULL)\n\t\t\tfree(qname);\n\t}\n#endif\t/* CPUSET_VERSION < 4 */\n\n\treturn ret;\n}\n\n/**\n * @brief\n * \twrapper function that calls make_cpuset_inner() passing a 0 to the\n *\tmodify parameter.\n *\n * @param[in] pjob - job pointer\n *\n * @return \tstring\n * @retval      cpuset name     SUCCESS\n * @retval      NULL            FAILURE\n */\nchar *\nmake_cpuset(job *pjob)\n{\n\treturn (make_cpuset_inner(pjob, 0));\n}\n\n/**\n * @brief\n * \twrapper function that calls make_cpuset_inner() passing a 1 to the\n *\tmodify parameter.\n *\n * @param[in] pjob - job pointer\n *\n * @return \tstring\n * @retval      cpuset name     SUCCESS\n * @retval      NULL            FAILURE\n */\nchar *\nmodify_cpuset(job *pjob)\n{\n\treturn (make_cpuset_inner(pjob, 1));\n}\n#endif\t/* MOM_CPUSET */\n\n\n#if\tMOM_CSA || MOM_ALPS /* MOM_ALPS requires libjob support */\n\n/* These globals are initialized in ck_acct_facility_present.\n *\n * At a later time it may be better to relocate them to the machine\n * independent portion of the mom code if they find use by more\n * than a single machine/OS type (i.e. CSA on irix too)\n */\n\nint job_facility_present;\nint job_facility_enabled;\nint acct_facility_present;\nint acct_facility_active;\nint acct_facility_wkmgt_recs;\nint acct_facility_wkmgt_active;\nint acct_facility_csa_active;\nint acct_dmd_wkmg;\t\t/* valued in abi_correction() */\njid_t\t(*jc_create)();\njid_t\t(*jc_getjid)();\n#endif\n\n#if MOM_CSA\nint\t(*p_csa_check)(struct csa_check_req *);\nint\t(*p_csa_wracct)(struct csa_wra_req *);\n\n/**\n * @brief\n *\tabi_correction - This function adjusts the value of acct_dmd_wkmg.\n * \tSince CSA's ABI has redefined the enumeration constant ACCT_DMD_WKMG\n * \tin PP5 it causes the value used at compile time to not be a correct\n * \tvalue to use during runtime - if PBS built on a PP4 machine is installed\n * \ton PP5  machine.  This function adjusts for that situation.\n *\n * @return Void\n *\n */\nstatic\tvoid\nabi_correction(void)\n{\n\tint  ver;\n\tchar *ssp;\n\tchar buffer [ 128 ];\n\tFILE *fp = fopen(\"/etc/sgi-release\", \"r\");\n\n\tacct_dmd_wkmg =  ACCT_DMD_WKMG;\n\tif (fp != NULL) {\n\t\tfgets(buffer, sizeof(buffer), fp);\n\t\tif ((ssp = strstr(buffer, \"ProPack \")) != NULL  ) {\n\t\t\tif (sscanf(ssp, \"ProPack %d\", &ver) == 1) {\n\n\t\t\t\t/*see if PBS built on ProPack < 5 machine\n\t\t\t\t *but installed on a machine with ProPack >=5\n\t\t\t\t */\n\t\t\t\tif (ver > 4)\n\t\t\t\t\tif (acct_dmd_wkmg > 2)\n\t\t\t\t\t\t/* running on ProPack >=5 and compile-time\n\t\t\t\t\t\t * ACCT_DMD_WKMG not right for this ProPack\n\t\t\t\t\t\t */\n\t\t\t\t\t\tacct_dmd_wkmg = 2;\n\t\t\t}\n\t\t}\n\t\tpclose(fp);\n\t}\n}\n\n/**\n * @brief\n * \tTests if the accounting facility is present\n * \ton this host.\n * \tGlobal variable \"acct_facility_present\" will\n * \trecord this fact.\n *\n * \tThis function to be be called during pbs_mom's startup\n * \tinitialization sequence and whenever pbs_mom receives a\n * \tSIGHUP signal.\n *\n * @par Side Effects:\n * \tMay exit if a bad flag combination is found.\n *\n * @return Void\n *\n */\n#endif /* MOM_CSA */\n\n#if MOM_CSA || MOM_ALPS /* MOM_ALPS requires libjob support */\nvoid\nck_acct_facility_present(void)\n{\n\tint\tret1;\n\tint\tret2;\n\tchar\t*libjob;\n\n\tstatic void *handle1 = NULL, *handle2 = NULL;\n\n\tstruct\tconfig\t\t*cptr;\n\textern\tstruct\tconfig\t*config_array;\n#if MOM_CSA\n\tint\treq_status;\n\tchar\t*libcsa;\n\tstruct csa_check_req   check_req;\n\tchar\t*status_csa;\n\tchar\t*status_wkmg;\n\t/* \"write workload management records\" defaults to \"on\" */\n\tacct_facility_wkmgt_recs = 1;\n#else\n\tacct_facility_wkmgt_recs = 0;\n#endif\n\n\t/* use of job_create defaults to True */\n\tjob_facility_enabled = 1;\n\n\tfor (cptr = config_array; cptr != NULL; cptr++) {\n\t\tif (cptr->c_name == NULL || *cptr->c_name == 0)\n\t\t\tbreak;\n\n\t\tif (strcasecmp(cptr->c_name, \"pbs_accounting_workload_mgmt\") == 0) {\n\t\t\t(void)set_boolean(__func__, cptr->c_u.c_value,\n\t\t\t\t&acct_facility_wkmgt_recs);\n\t\t}\n\t\telse if (strcasecmp(cptr->c_name, \"pbs_jobcreate_workload_mgmt\") == 0) {\n\t\t\t(void)set_boolean(__func__, cptr->c_u.c_value,\n\t\t\t\t&job_facility_enabled);\n\t\t}\n\t}\n\n\tif (acct_facility_wkmgt_recs && !job_facility_enabled) {\n\t\tlog_event(PBSEVENT_ERROR, 0, LOG_CRIT, __func__,\n\t\t\t\"the combination of libjob disabled/libcsa enabled cannot be set because libcsa depends on libjob\");\n\t\texit(1);\n\t}\n\n\t/* multiple calls to dlopen with the same arguments do not cause multiple\n\t * copies of the library to get loaded into the proesses memory, they just\n\t * bump a reference count and return the same handle value.\n\t * If dlclose is issued when the reference count is 1, the library will be\n\t * unloaded from memory and any previous pointers obtained through calls to\n\t * dlsym will not be valid.\n\t */\n\n\tjob_facility_present = 0;\n\tacct_facility_present = 0;\n\tacct_facility_active = 0;\n\tacct_facility_csa_active = 0;\n\tacct_facility_wkmgt_active = 0;\n\n\t/*\n\t * If job facility is turned off, don't call dlopen for job_create.\n\t */\n\tif (job_facility_enabled == 0)\n\t\tgoto done;\n\n\tlibjob = get_versioned_libname(sotype_job);\n\tif (libjob == NULL) {\n\t\tsprintf(log_buffer, \"Could not find a supported job shared object\");\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\t\tlog_buffer);\n\t\tgoto err;\n\t}\n\n\tsprintf(log_buffer, \"using %s for job shared object\", libjob);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__, log_buffer);\n\thandle1 = dlopen(libjob, RTLD_LAZY);\n\tif (handle1 == NULL) {\n\t\t/* facility is not available */\n\n\t\tsprintf(log_buffer, \"%s. failed to dlopen %s\", dlerror(), libjob);\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, log_buffer);\n\t\tgoto err;\n\t}\n\n\tsprintf(log_buffer, \"dlopen of %s successful\", libjob);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, log_buffer);\n\n\t/* find_in_lib sets message in log_buffer */\n\tret1 = find_in_lib(handle1, libjob, \"job_create\", (void **)&jc_create);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\tlog_buffer);\n\n\tret2 = find_in_lib(handle1, libjob, \"job_getjid\", (void **)&jc_getjid);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\tlog_buffer);\n\n\tif ((ret1 == 1) && (ret2 == 1))\n\t\tjob_facility_present = 1;\n\n\t/*\n\t * If job facility is not available or accounting is turned off,\n\t * don't call dlopen for CSA.\n\t */\n\tif (job_facility_present == 0 || acct_facility_wkmgt_recs == 0)\n\t\tgoto done;\n\n#if MOM_CSA\n\tstatus_wkmg = \"off\";\n\tstatus_csa = \"off\";\n\tlibcsa = get_versioned_libname(sotype_csa);\n\tif (libcsa == NULL) {\n\t\tsprintf(log_buffer, \"Could not find a supported CSA shared object\");\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\t\tlog_buffer);\n\t\tgoto err;\n\t}\n\n\tsprintf(log_buffer, \"using %s for CSA shared object\", libcsa);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__, log_buffer);\n\n\thandle2 = dlopen(libcsa, RTLD_LAZY);\n\tif (handle2 == NULL) {\n\t\t/* facility is not available */\n\n\t\tsprintf(log_buffer, \"%s. failed to dlopen %s\", dlerror(), libcsa);\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, log_buffer);\n\t\tgoto err;\n\t}\n\n\tsprintf(log_buffer, \"dlopen of %s successful\", libcsa);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, log_buffer);\n\n\tret1 = find_in_lib(handle2, libcsa, \"csa_wracct\",\n\t\t\t(void **)&p_csa_wracct);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\tlog_buffer);\n\n\tret2 = find_in_lib(handle2, libcsa, \"csa_check\",\n\t\t\t(void **)&p_csa_check);\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\tlog_buffer);\n\n\tif ((ret1 == 1) && (ret2 == 1) &&\n\t\t\t(p_csa_wracct != NULL) && (p_csa_check != NULL))\n\t\tacct_facility_present = 1;\n\n\t/* Check status of workload management and csa portions of CSA facility */\n\n\tif (acct_facility_present) {\n\n\t\t/* next function call copes with unexpected ABI change */\n\t\tabi_correction();\n\n\t\tcheck_req.ck_stat.am_id = acct_dmd_wkmg;\n\t\treq_status = (*p_csa_check)(&check_req);\n\t\tif (req_status == 0) {\n\n\t\t\t/* Is CSA's \"wkmg\" component \"on/off\" */\n\t\t\tif (check_req.ck_stat.am_status == ACS_ON) {\n\t\t\t\tacct_facility_wkmgt_active = 1;\n\t\t\t\tstatus_wkmg = \"on\";\n\t\t\t}\n\n\t\t\t/* got workload mgmt status, now try and get status on \"csa\" part */\n\t\t\tcheck_req.ck_stat.am_id = ACCT_KERN_CSA;\n\t\t\treq_status = (*p_csa_check)(&check_req);\n\t\t}\n\n\t\tif (req_status == -1) {\n\t\t\t/* couldn't get status on either \"wkmg\" or \"csa\" parts - turn off */\n\t\t\tacct_facility_present = 0;\n\t\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG, __func__,\n\t\t\t\t\"Unable to get CSA Kernel and Daemon accounting status\");\n\t\t} else {\n\t\t\t/* Is CSA's \"csa\" component \"on/off\" */\n\t\t\tif (check_req.ck_stat.am_status == ACS_ON) {\n\t\t\t\tacct_facility_csa_active = 1;\n\t\t\t\tstatus_csa = \"on\";\n\t\t\t}\n\t\t}\n\n\t\t/* prepare for first use  in set_job */\n\n\t\tacct_facility_active = 1;\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, \"CSA facility present\");\n\n\t\tsprintf(log_buffer, \"Status for CSA shows csa=%s and wkmg=%s\",\n\t\t\tstatus_csa, status_wkmg);\n\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, log_buffer);\n\t\tgoto done;\n\t}\n#endif\n\nerr:\n\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t__func__, \"CSA/job facility not present or improperly setup\");\n\ndone:\n\t/*\n\t * When we get here, the flags are set to indicate what libs should\n\t * be kept open.\n\t */\n\tif (job_facility_present == 0) {\n\t\tif (handle1) {\n\t\t\tdlclose(handle1);\n\t\t\thandle1 = NULL;\n\t\t}\n\t}\n\tif (acct_facility_present == 0) {\n\t\t/*\n\t\t * CSA accounting not possible if either of the libraries can't be\n\t\t * opened, one or more symbols can't be resolved, or query of either\n\t\t * of the CSA components \"csa\" or \"wkmg\" returns with error.\n\t\t */\n\t\tif (handle2) {\n\t\t\tdlclose(handle2);\n\t\t\thandle2 = NULL;\n\t\t}\n\t}\n}\n\n/**\n * @brief\n *\tfind_in_lib -  Call this function when you want to find the address of symbol\n * \tin a shared library that has been opened by a call to dlopen.\n *\n * \tAn appropriate message will be written into PBS' global \"log_buffer\"\n * \tin each of the three possible cases (found, not found, bogus arguments).\n * \tThe caller chooses to log or ignore the content of log_buffer.\n *\n *\n * @param[in]\thandle\tvalid handle from call to dlopen\n * @param[in]\tplnam\tpointer to the name of the library (NULL acceptable)\n * @param[in]\tpsnam\tpointer to the name of the symbol\n * @param[out]\tpsp\twhere to return the symbol pointer if found\n *\n * @return\tint\n * @retval\t1      success, with symbol pointer stored to *psp\n * @retval \t0      failure, and *psp unmodified\n * @retval\t-1      bad input to this function\n *\n */\nint\nfind_in_lib(void *handle, char * plnam, char *psnam, void ** psp)\n{\n\tvoid\t\t*psym;\n\tconst char\t*error;\n\tint\t\tretcode;\n\n\t/* check arguments */\n\tif (handle == NULL || psnam == NULL || *psnam == '\\0') {\n\t\tsprintf(log_buffer, \"%s: bad arguments %p %p %p %p\", __func__,\n\t\t\thandle, plnam, psnam, psp);\n\t\treturn -1;\n\t}\n\n\tpsym = dlsym(handle, psnam);\n\terror = dlerror();\n\n\tif (error != NULL) {\n\n\t\tretcode = 0;\n\t\tif (plnam)\n\t\t\tsprintf(log_buffer, \"%s. symbol %s not found in %s\", error, psnam, plnam);\n\t\telse\n\t\t\tsprintf(log_buffer, \"%s. symbol %s not found\", error, psnam);\n\t} else {\n\n\t\tretcode = 1;\n\t\t*psp = psym;\n\n\t\tif (plnam)\n\t\t\tsprintf(log_buffer, \"symbol %s found in %s\", psnam, plnam);\n\t\telse\n\t\t\tsprintf(log_buffer, \"symbol %s found\", psnam);\n\t}\n\treturn (retcode);\n}\n\n#endif /* MOM_CSA or MOM_ALPS */\n\n#if MOM_CSA /* this section only when CSA is enabled */\n\n/**\n * @brief\n *\twrite_wkmg_record - Call this function at appropriate places in the code to request\n *\ta workload management accounting record of some ilk get written\n *\tby the \"system\" to an accounting file.  Such record will be of\n *\ta certain type/subtype, which somehow maps to the over all job\n * \tstate - or possibly the status of the workload management\n * \taccounting facility itself.\n *\n * Sgi's CSA has the following type/subtype combinations:\n * WM_INFO: WM_RECV: WM_INIT: WM_SPOOL: WM_TERM:\n *   WM_INFO:\n *      - WM_INFO_ACCTON  1       Accounting started\n *      - WM_INFO_ACCTOFF 2       Accounting stopped\n *\n *   WM_RECV:\n *      - WM_RECV_NEW      1       New request\n *\n * WM_INIT_START || WM_INIT_RESTART || WM_INIT_RERUN\n *   WM_INIT:\n *      - WM_INIT_START    1       Request started for first time\n *      - WM_INIT_RESTART  2       Request restarted\n *      - WM_INIT_RERUN    3       Request rerun\n *\n *   WM_SPOOL:\n *      - WM_SPOOL_INIT    4       Output return started\n *      - WM_SPOOL_TERM    6       Output return stopped\n *\n *   case WM_TERM_EXIT: case WM_TERM_REQUEUE: case WM_TERM_HOLD: case WM_TERM_RERUN: case WM_TERM_MIGRATE\n *   WM_TERM:\n *      - WM_TERM_EXIT     1       Request exited\n *      - WM_TERM_REQUEUE  2       Request requeued\n *      - WM_TERM_HOLD     3       Request checkpointed and held\n *      - WM_TERM_RERUN    4       Request will be rerun\n *      - WM_TERM_MIGRATE  5       Request will be migrated\n * where \"request\" can be interpreted a PBS job\n *\n *\n * @return Void\n *\n * Log: write an appropriate log message to mom's logfile if the\n *      record write request returns failure.\n *\n */\nvoid\nwrite_wkmg_record(int rec_type, int sub_type, job *pjob)\n{\n\textern\ttime_t\ttime_now;\n\tchar\t*id_name;\n\tint\tbad_args = 0;\n\tint\tunsupported = 0;\n\n\tstruct wkmgmtbs\t\t\twkmgmtbs;\t/* wkmgt record */\n\tstatic struct csa_wra_req\tcsa_wra_req;\t/* header info */\n\tstruct csa_check_req   check_req, *pchk = &check_req;\n\n\tchar\t\ttext[PBS_MAXSVRJOBID+1];\n\tint\t\treq_status;\n\n\tstatic int\tl_mnam = sizeof(wkmgmtbs.machname);\n\tstatic int\tl_qnam = sizeof(wkmgmtbs.quename);\n\tstatic int\tl_rnam = sizeof(wkmgmtbs.reqname);\n\tstatic int\tl_snam = sizeof(wkmgmtbs.serv_provider);\n\n\n\t/* mom config switch set to off || facility not active */\n\n\tif (acct_facility_present == 0 || acct_facility_wkmgt_recs == 0 ||\n\t\tacct_facility_active == 0 || p_csa_check == NULL)\n\t\treturn;\n\n\t/* check current status for CSA workload management */\n\n\tpchk->ck_stat.am_id = acct_dmd_wkmg;\n\tif ((req_status = (*p_csa_check)(pchk)) == -1) {\n\t\tif (acct_facility_wkmgt_active == 1) {\n\t\t\tif (pjob)\n\t\t\t\tlog_joberr(-1, __func__,\n\t\t\t\t\t\"Unable to get CSA Kernel and Daemon accounting status\",\n\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\telse\n\t\t\t\tlog_joberr(errno, __func__,\n\t\t\t\t\t\"Unable to get CSA Kernel and Daemon accounting status\",\n\t\t\t\t\t\"\");\n\t\t}\n\t\tacct_facility_wkmgt_active = 0;\n\t\treturn;\n\t}\n\n\tif (pchk->ck_stat.am_status != ACS_ON) {\n\t\tif (acct_facility_wkmgt_active == 1) {\n\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t\t__func__, \"Status for CSA shows wkmg \\\"off\\\"\");\n\t\t\tacct_facility_wkmgt_active = 0;\n\t\t}\n\t\treturn;\n\n\t} else {\n\t\tif (acct_facility_wkmgt_active == 0) {\n\t\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t\t__func__, \"Status for CSA shows wkmg \\\"on\\\"\");\n\t\t\tacct_facility_wkmgt_active = 1;\n\t\t}\n\t}\n\n\tif (pjob == NULL) {\n\t\tif (rec_type != WM_INFO)\n\t\t\t++bad_args;\n\t\telse\n\t\t\t++unsupported;\n\t} else {\n\n\t\t/* check for valid record type and subtype */\n\t\tswitch (rec_type) {\n\n\t\t\tcase WM_INFO:\n\t\t\t\tswitch (sub_type) {\n\t\t\t\t\tcase WM_INFO_ACCTON:\n\t\t\t\t\tcase WM_INFO_ACCTOFF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t++bad_args;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WM_RECV:\n\t\t\t\tif (sub_type != WM_RECV_NEW)\n\t\t\t\t\t++bad_args;\n\t\t\t\tbreak;\n\n\t\t\tcase WM_INIT:\n\t\t\t\tif (pjob->ji_wattr [JOB_ATR_runcount].at_val.at_long > 1) {\n\t\t\t\t\tsub_type = WM_INIT_RERUN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (sub_type) {\n\t\t\t\t\tcase WM_INIT_START:\n\t\t\t\t\tcase WM_INIT_RERUN:\n\t\t\t\t\tcase WM_INIT_RESTART:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t++bad_args;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WM_SPOOL:\n\t\t\t\tswitch (sub_type) {\n\t\t\t\t\tcase WM_SPOOL_INIT:\n\t\t\t\t\tcase WM_SPOOL_TERM:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t++bad_args;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WM_TERM:\n\t\t\t\tswitch (sub_type) {\n\t\t\t\t\tcase WM_TERM_EXIT:\n\t\t\t\t\tcase WM_TERM_REQUEUE:\n\t\t\t\t\tcase WM_TERM_RERUN:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WM_TERM_HOLD:\n\t\t\t\t\tcase WM_TERM_MIGRATE:\n\t\t\t\t\t\t++unsupported;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t++bad_args;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t++bad_args;\n\t\t}\n\t}\n\n\t/* anything bad or unsupported, log message only */\n\tif (bad_args || unsupported) {\n\t\tif (bad_args) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"badargs rec_type=%d sub_type=%d no csa workload record write\",\n\t\t\t\trec_type, sub_type);\n\n\t\t} else {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"unsupported CSA record rec_type=%d sub_type=%d\",\n\t\t\t\trec_type, sub_type);\n\t\t}\n\n\t\tif (pjob)\n\t\t\tid_name = pjob->ji_qs.ji_jobid;\n\t\telse\n\t\t\tid_name = __func__\n\n\t\tlog_event(PBSEVENT_ERROR, PBS_EVENTCLASS_ACCT, LOG_WARNING,\n\t\t\tid_name, log_buffer);\n\t\treturn;\n\t}\n\n\t/* OK to issue workload management record request to kernel */\n\n\tmemset((char *)&wkmgmtbs, 0, sizeof(wkmgmtbs));\n\tmemset((char *)&csa_wra_req, 0, sizeof(csa_wra_req));\n\n\twkmgmtbs.hdr.ah_magic = ACCT_MAGIC;\n\twkmgmtbs.hdr.ah_revision = REV_WKMG;\n\twkmgmtbs.hdr.ah_type = ACCT_DAEMON_WKMG;\n\twkmgmtbs.hdr.ah_flag = 0;\n\twkmgmtbs.hdr.ah_size = sizeof(wkmgmtbs);\n\n\twkmgmtbs.type = rec_type;\n\twkmgmtbs.subtype = sub_type;\n\twkmgmtbs.time = time_now;\n\n\t/*remark: memset 0 initialization guarantees '\\0' termination */\n\n\tstrncpy(wkmgmtbs.serv_provider, \"PBS_Pro\", l_snam -1);\n\n\twkmgmtbs.uid = pjob->ji_qs.ji_un.ji_momt.ji_exuid;\n\n\t/* from email exchanges with David Wright at SGI */\n\tif (rec_type == WM_INIT &&\n\t\tpjob->ji_wattr[(int)JOB_ATR_etime].at_flags & ATR_VFLAG_SET) {\n\n\t\twkmgmtbs.enter_time = (time_t)pjob->ji_wattr[(int)JOB_ATR_etime].at_val.at_long;\n\t}\n\telse {\n\n\t\twkmgmtbs.enter_time = (time_t)0;\n\t}\n\n\twkmgmtbs.jid = *(jid_t *)&pjob->ji_extended.ji_ext.ji_4jid[0];\n\twkmgmtbs.arrayid = pjob->ji_nodeid;\n\n\t/* linux: qwtime computed (csabuild) quantity - David Wright email */\n\twkmgmtbs.qwtime = 0;\n\n\t/* linux: Batch extensions to CSA (csaacct.h) */\n\twkmgmtbs.qtype = 0;\n\twkmgmtbs.code = 0;\n\twkmgmtbs.utime = 0;\n\twkmgmtbs.stime = 0;\n\twkmgmtbs.ctime = 0;\n\twkmgmtbs.mem_reserved = 0;\n\twkmgmtbs.ncpus = 0;\n\n\t/* linux: sub_type not relevant (except RECV) - David Wright email */\n\twkmgmtbs.term_subtype = 0;\n\n\n\t/* create \"reqid\" from job identifier's sequence number */\n\n\tstrcpy(text, pjob->ji_qs.ji_jobid);\n\twkmgmtbs.reqid = strtoll(&text[0], NULL, 0);\n\n\t/*remark: memset 0 initialization guarantees '\\0' termination */\n\n\tstrncpy(wkmgmtbs.quename,\n\t\tpjob->ji_wattr[(int)JOB_ATR_in_queue].at_val.at_str, l_qnam -1);\n\tstrncpy(wkmgmtbs.machname, &mom_host[0], l_mnam -1);\n\tstrncpy(wkmgmtbs.reqname,\n\t\tpjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str, l_rnam -1);\n\n\t/* fillout header information needed by CSA kernel */\n\n\tcsa_wra_req.wra_did   = acct_dmd_wkmg;\n\tcsa_wra_req.wra_len   = sizeof(wkmgmtbs);\n\tcsa_wra_req.wra_buf   = (char *)&wkmgmtbs;\n\n\tif (rec_type == WM_TERM)\n\t\t/* job's JID no longer valid so use (jid_t)0 */\n\t\t/* (*jc_getjid) ( getpid () ); not sure would be more appropriate */\n\n\t\tcsa_wra_req.wra_jid = (jid_t)0;\n\telse\n\t\tcsa_wra_req.wra_jid   = wkmgmtbs.jid;\n\n\n\t/* issue workload management write request to CSA kernel */\n\n\tif ((req_status = (p_csa_wracct == NULL) ? -1 :\n\t\t(*p_csa_wracct)(&csa_wra_req)) == -1 &&\n\t\trec_type != WM_TERM) {\n\t\tsprintf(log_buffer, \"failed to write CSA workload record (%d/%d)\",\n\t\t\trec_type, sub_type);\n\t\tlog_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);\n\n\t} else {\n\n\t\tsprintf(log_buffer, \"CSA workload management record %d/%d written\",\n\t\t\trec_type, sub_type);\n\t\tlog_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tpjob->ji_qs.ji_jobid, log_buffer);\n\t}\n}\n#endif\t/* MOM_CSA */\n\n/* Private variables */\n\n/**\n * @brief\n * \tSet session id and whatever else is required on this machine\n *\tto create a new job.\n * \tOn a Cray, an ALPS reservation will be created and confirmed.\n *\n * @param[in]\tpjob\t-\tpointer to job structure\n * @param[in]\tsjr\t-\tpointer to startjob_rtn structure\n *\n * @return session/job id\n * @retval -1 error from setsid(), no message in log_buffer\n * @retval -2 temporary error, retry job, message in log_buffer\n * @retval -3 permanent error, abort job, message in log_buffer\n *\n */\nint\nset_job(job *pjob, struct startjob_rtn *sjr)\n{\n#ifdef\tMOM_CPUSET\n\tif (attach_to_cpuset(pjob, sjr) < 0)\n\t\treturn -2;\n#endif\t/* MOM_CPUSET */\n\n#if\tMOM_CSA || MOM_ALPS\n\tif (job_facility_present && pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) {\n\n\t\t/* host system has necessary JOB container facility present\n\t\t * and this host is Mother Superior for this job\n\t\t */\n\n\t\tjid_t *pjid = (jid_t *) &pjob->ji_extended.ji_ext.ji_4jid[0];\n\n\t\tif (*pjid != (jid_t)0 && *pjid != (jid_t)-1) {\n\t\t\tsjr->sj_jid = *pjid;\n\t\t} else {\n\n\t\t\terrno = -1;\n\t\t\tsjr->sj_jid = (jc_create == NULL) ? -1 :\n\t\t\t\t(*jc_create)(0, pjob->ji_qs.ji_un.ji_momt.ji_exuid, 0);\n\n\t\t\tif (sjr->sj_jid == (jid_t)-1) {\n\n\t\t\t\t/* Failed: categorize errno into two cases and handle */\n\t\t\t\t/* Remark: sit_job call occurs before log_close()     */\n\n\t\t\t\tif (errno == ENOSYS) {\n\t\t\t\t\tif (job_facility_present == 1) {\n\t\t\t\t\t\tlog_joberr(errno, __func__,\n\t\t\t\t\t\t\t\"Job container facility unavailable\",\n\t\t\t\t\t\t\tpjob->ji_qs.ji_jobid);\n\t\t\t\t\t\tjob_facility_present = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\t/* log any other job_create failure type */\n\n\t\t\t\t\tlog_joberr(errno, __func__,\n\t\t\t\t\t\t\"Job container job_create call failed\", pjob->ji_qs.ji_jobid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*pjid = sjr->sj_jid;\n\t}\n#endif\t/* MOM_CSA or MOM_ALPS */\n\n\tsjr->sj_session = setsid();\n\n#if\tMOM_ALPS\n\t/*\n\t * Now that we have our SID/JID we can request/confirm our\n\t * placement scheduler reservation.\n\t *\n\t * Do this only if we are mother superior for the job.\n\t */\n\n\tif (pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) {\n\t\tbasil_request_reserve_t *basil_req;\n\t\tint rc;\n\n\t\t/* initialized to -1 so this catches the unset case. */\n\t\tsjr->sj_reservation = -1;\n\n\t\trc = alps_create_reserve_request(pjob, &basil_req);\n\t\tif (rc == 1) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Fatal MPP reservation error\"\n\t\t\t\t\" preparing request.\");\n\t\t\treturn -3;\n\t\t} else if (rc == 2) {\n\t\t\tsprintf(log_buffer,\n\t\t\t\t\"Transient MPP reservation error\"\n\t\t\t\t\" preparing request.\");\n\t\t\treturn -2;\n\t\t}\n\t\tif (basil_req) {\n\t\t\trc = alps_create_reservation(basil_req,\n\t\t\t\t&sjr->sj_reservation,\n\t\t\t\t&sjr->sj_pagg);\n\t\t\talps_free_reserve_request(basil_req);\n\t\t\tif (rc < 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Fatal MPP reservation error\"\n\t\t\t\t\t\" on create.\");\n\t\t\t\treturn -3;\n\t\t\t}\n\t\t\tif (rc > 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Transient MPP reservation error\"\n\t\t\t\t\t\" on create.\");\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we are interacting with ALPS, the cookie has\n\t\t\t * not been set. Fill in the session ID we just\n\t\t\t * acquired. Otherwise, we are interacting with\n\t\t\t * CPA and use the cookie that was acquired when\n\t\t\t * the reservation was created.\n\t\t\t *\n\t\t\t * When CSA support comes along in UNICOS/lc 2.1 we\n\t\t\t * will use the job ID rather than the session ID.\n\t\t\t */\n\t\t\tif (sjr->sj_pagg == 0) {\n#if MOM_CSA || MOM_ALPS /* MOM_ALPS requires libjob support */\n\t\t\t\tif ((job_facility_present == 1))\n\t\t\t\t\tsjr->sj_pagg = sjr->sj_jid;\n\t\t\t\telse\n#endif /* MOM_CSA or MOM_ALPS */\n\t\t\t\t\tsjr->sj_pagg = sjr->sj_session;\n\t\t\t}\n\t\t\tpjob->ji_extended.ji_ext.ji_reservation =\n\t\t\t\tsjr->sj_reservation;\n\t\t\tpjob->ji_extended.ji_ext.ji_pagg =\n\t\t\t\tsjr->sj_pagg;\n\n\t\t\trc = alps_confirm_reservation(pjob);\n\t\t\tif (rc < 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Fatal MPP reservation error\"\n\t\t\t\t\t\" on confirm.\");\n\t\t\t\treturn -3;\n\t\t\t}\n\t\t\tif (rc > 0) {\n\t\t\t\tsprintf(log_buffer,\n\t\t\t\t\t\"Transient MPP reservation error\"\n\t\t\t\t\t\" on confirm.\");\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else {\t/* No error but no reservation made, reset so\n\t\t\t\t\t * the inventory will not be reread.\n\t\t\t\t\t */\n\t\t\tsjr->sj_reservation = 0;\n\t\t}\n\t}\n#endif\t/* MOM_ALPS */\n\n\treturn (sjr->sj_session);\n}\n\n#ifdef\tMOM_CPUSET\n/**\n * @brief\n *\tset new cpu set for job\n *\n * @param[in] pjob - pointer to job structure\n *\n * @return \tint\n * @retval \t0\tSuccess\n * @retval     -1\tFailure\n *\n */\nint\nnew_cpuset(job *pjob)\n{\n\tchar\t\t*setname;\n\tchar\t\tcbuf[CPUSET_NAME_SIZE + 16];\n\n\tif ((setname = make_cpuset(pjob)) == NULL)\n\t\treturn -2;\n\n\tsprintf(cbuf, \"cpuset=%s\", setname);\n\tif (decode_str(&pjob->ji_wattr[JOB_ATR_altid], ATTR_altid, NULL,\n\t\tcbuf) == -1) {\n\t\tdel_cpusetfile(setname, pjob);\n\t\tfree(setname);\n\t\treturn -2;\n\t} else {\n\t\tsprintf(log_buffer, \"%s:  setting altid to CPU set named %s\",\n\t\t\t__func__, cbuf + 7);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tpjob->ji_qs.ji_jobid, log_buffer);\n\t}\n\tfree(setname);\n\tupdate_ajob_status(pjob);\n\n\treturn 0;\n}\n\n/**\n * @brief\n * \tattaches cpu set\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] sjr  - pointer to startjob_rtn structure\n *\n * @return Void\n *\n */\nint\nattach_to_cpuset(job *pjob, struct startjob_rtn *sjr)\n{\n\tchar\t*setname;\n\n\t/*\n\t *\tAttach the current pid to a cpuset.\n\t */\n\tif ((setname = getsetname(pjob)) == NULL) {\n\t\tsprintf(log_buffer, \"%s:  getsetname failed\", __func__);\n\t\treturn -2;\n\t}\n\n#if\t(CPUSET_VERSION < 4)\n\tif (cpusetAttach(setname) == 0) {\n\t\tsprintf(log_buffer, \"errno %d, cpusetAttach %s\",\n\t\t\terrno, setname);\n\t\tfree(setname);\n\t\treturn -2;\n\t}\n#else\n\tstruct cpuset\t*cp;\n\n\t/*\n\t *\tAssure that the name returned by make_cpuset() begins with\n\t *\tour base CPU set name.\n\t */\n\tassert(strncmp(setname, CPUSET_REL_NAME(PBS_CPUSETDIR),\n\t\tstrlen(CPUSET_REL_NAME(PBS_CPUSETDIR))) == 0);\n\n\tif ((cp = cpuset_alloc()) == NULL) {\n\t\tsprintf(log_buffer, \"errno %d, cpuset_alloc %s\",\n\t\t\terrno, setname);\n\t\tfree(setname);\n\t\treturn -2;\n\t}\n\tif (cpuset_query(cp, setname) == -1) {\n\t\tsprintf(log_buffer, \"errno %d, cpuset_query %s\",\n\t\t\terrno, setname);\n\t\tcpuset_free(cp);\n\t\tfree(setname);\n\t\treturn -2;\n\t}\n\tif (cpuset_move((pid_t) 0, setname) == -1) {\n\t\tsprintf(log_buffer, \"errno %d, cpuset_move %s\",\n\t\t\terrno, setname);\n\t\tcpuset_free(cp);\n\t\tfree(setname);\n\t\treturn -2;\n\t}\n\tcpuset_free(cp);\n#endif\t/* CPUSET_VERSION < 4 */\n\n\tassert(sjr != NULL);\n\t(void)strncpy(sjr->sj_cpuset_name, setname, CPUSET_NAME_SIZE);\n\tfree(setname);\n\treturn 0;\n}\n#endif\t/* MOM_CPUSET */\n\n/**\n * @brief\n *\tset_globid - set the global id for a machine type.\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] sjr  - pointer to startjob_rtn structure\n *\n * @return Void\n *\n */\n\nvoid\nset_globid(job *pjob, struct startjob_rtn *sjr)\n{\n#if\tMOM_CPUSET\n\tchar\tcbuf[CPUSET_NAME_SIZE+16];\n#endif\t/* MOM_CPUSET */\n#if\tMOM_CSA || MOM_ALPS\n\tchar\t\tbuf[19];  /* 0x,16 hex digits,'\\0' */\n\n\tif (sjr->sj_jid == (jid_t)-1) {\n\t\tjob_facility_present = 0;\n\t}\n\telse if (sjr->sj_jid) {\n\n\t\tsprintf(buf, \"%#0lx\", (unsigned long)sjr->sj_jid);\n\t\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_acct_id],\n\t\t\tATTR_acct_id, NULL, buf);\n\n\t\t(void)memcpy(&pjob->ji_extended.ji_ext.ji_4jid,\n\t\t\t\t&sjr->sj_jid,\n\t\t\t\tsizeof(pjob->ji_extended.ji_ext.ji_4jid));\n\n#if MOM_CSA\n\t\tif (acct_facility_active == 0) {\n\n\t\t\t/* first success on job_create() after failure */\n\t\t\tacct_facility_active = 1;\n\t\t\tsprintf(log_buffer, \"Job container facility available\");\n\t\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t\t__func__, log_buffer);\n\t\t}\n#endif /*MOM_CSA */\n\t\tif (job_facility_present == 0) {\n\t\t\t/* first success on job_create() after failure */\n\t\t\tjob_facility_present = 1;\n\t\t\tsprintf(log_buffer, \"Job container facility available\");\n\t\t\tlog_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_ACCT, LOG_DEBUG,\n\t\t\t\t__func__, log_buffer);\n\n\t\t}\n\t}\n#endif\t/* MOM_CSA or MOM_ALPS */\n\n#if\tMOM_CPUSET\n\t/*\n\t *\tNote that this code which deals with initializing the CPU set\n\t *\tname in JOB_ATR_altid must occur last:  if we detect that we're\n\t *\tbeing asked to write a NULL or zero-length string into altid,\n\t *\twe refuse to do so and instead return.\n\t */\n\tsprintf(cbuf, \"cpuset=%s\", sjr->sj_cpuset_name);\n\tif (strlen(sjr->sj_cpuset_name) == 0) {\n\t\tDBPRT((\"%s:  job %s's sj_cpuset_name is 0 length\\n\", __func__,\n\t\t\tpjob->ji_qs.ji_jobid))\n\t\treturn;\n\t}\n\n\t/* see if altid has it */\n\tif (pjob->ji_wattr[(int)JOB_ATR_altid].at_flags & ATR_VFLAG_SET) {\n\t\tchar *altid = pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str;\n\n\t\tif (strcmp(altid, cbuf) == 0)\n\t\t\treturn;\t\t/* already there */\n\n\t\tsprintf(log_buffer, \"%s: replace %s with %s\", __func__, altid, cbuf);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tpjob->ji_qs.ji_jobid, log_buffer);\n\t}\n\t(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],\n\t\tATTR_altid, NULL, cbuf);\n#endif\t/* MOM_CPUSET */\n\n#if\tMOM_ALPS\n\t{\n\t\tchar altid_buf[23];\n\t\tpjob->ji_extended.ji_ext.ji_pagg = sjr->sj_pagg;\n\t\tpjob->ji_extended.ji_ext.ji_reservation = sjr->sj_reservation;\n\t\tsprintf(altid_buf, \"%ld\", sjr->sj_reservation);\n\t\tjob_attr_def[(int)JOB_ATR_altid].at_decode(\n\t\t\t&pjob->ji_wattr[(int)JOB_ATR_altid],\n\t\t\tjob_attr_def[(int)JOB_ATR_altid].at_name,\n\t\t\tNULL, altid_buf);\n\t}\n#endif\t/* MOM_ALPS */\n}\n\n/**\n * @brief\n * \tset_mach_vars - setup machine dependent environment variables\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] vtab - pointer to var_table structure\n *\n * @return \tint\n * @retval \t0\tSuccess\n *\n */\n\nint\nset_mach_vars(job *pjob, struct var_table *vtab)\n{\n#if\tMOM_BGL\n\tchar *job_partition = NULL;\n\n\tjob_partition = job_bgl_partition(pjob);\n\tif (job_partition) {\n\t\tchar\tnum_cnodes_s[40];\n\t\tbld_env_variables(vtab, \"MPIRUN_PARTITION\", job_partition);\n\n\t\tsprintf(num_cnodes_s, \"%d\", bgl_partition_get_num_cnodes(bglpartitions,\n\t\t\tjob_partition));\n\t\tbld_env_variables(vtab, \"MPIRUN_PARTITION_SIZE\", num_cnodes_s);\n\t}\n#endif\t/* MOM_BGL */\n\n\treturn 0;\n}\n\n/**\n * @brief\n *\tsets the shell to be used\n *\n * @param[in] pjob - pointer to job structure\n * @param[in] pwdp - pointer to passwd structure\n *\n * @return \tstring\n * @retval \tshellname\tSuccess\n *\n */\nchar *\nset_shell(job *pjob, struct passwd *pwdp)\n{\n\tchar *cp;\n\tint   i;\n\tchar *shell;\n\tstruct array_strings *vstrs;\n\t/*\n\t * find which shell to use, one specified or the login shell\n\t */\n\n\tshell = pwdp->pw_shell;\n\tif ((pjob->ji_wattr[(int)JOB_ATR_shell].at_flags & ATR_VFLAG_SET) &&\n\t\t(vstrs = pjob->ji_wattr[(int)JOB_ATR_shell].at_val.at_arst)) {\n\t\tfor (i = 0; i < vstrs->as_usedptr; ++i) {\n\t\t\tcp = strchr(vstrs->as_string[i], '@');\n\t\t\tif (cp) {\n\t\t\t\tif (!strncmp(mom_host, cp+1, strlen(cp+1))) {\n\t\t\t\t\t*cp = '\\0';\t/* host name matches */\n\t\t\t\t\tshell = vstrs->as_string[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshell = vstrs->as_string[i];\t/* wildcard */\n\t\t\t}\n\t\t}\n\t}\n\treturn (shell);\n}\n\n/**\n *\n * @brief\n * \tChecks if a child of the current (mom) process has terminated, and\n *\tmatches it with the pid of one of the tasks in the task_list_event,\n *\tor matches the pid of a process being monitored for a PBS job.\n *\tif matching a task in the task_list_event, then that task is\n *\tmarked as WORK_Deferred_Cmp along with the exit value of the child\n *\tprocess. Otherwise if it's for a job, and that job's\n *\tJOB_SVFLAG_TERMJOB is set, then mark the job as exiting.\n *\n * @return\tVoid\n *\n */\n\nvoid\nscan_for_terminated(void)\n{\n\tint\t\texiteval;\n\tpid_t\t\tpid;\n\tjob\t\t*pjob;\n\ttask\t\t*ptask = NULL;\n\tstruct work_task *wtask = NULL;\n\tint\t\tstatloc;\n\n\t/* update the latest intelligence about the running jobs;         */\n\t/* must be done before we reap the zombies, else we lose the info */\n\n\ttermin_child = 0;\n\n\tif (mom_get_sample() == PBSE_NONE) {\n\t\tpjob = (job *)GET_NEXT(svr_alljobs);\n\t\twhile (pjob) {\n\t\t\tmom_set_use(pjob);\n\t\t\tpjob = (job *)GET_NEXT(pjob->ji_alljobs);\n\t\t}\n\t}\n\n\t/* Now figure out which task(s) have terminated (are zombies) */\n\n\twhile ((pid = waitpid(-1, &statloc, WNOHANG)) > 0) {\n\t\tif (WIFEXITED(statloc))\n\t\t\texiteval = WEXITSTATUS(statloc);\n\t\telse if (WIFSIGNALED(statloc))\n\t\t\texiteval = WTERMSIG(statloc) + 0x100;\n\t\telse\n\t\t\texiteval = 1;\n\n\n\t\t/* Check for other task lists */\n\t\twtask = (struct work_task *)GET_NEXT(task_list_event);\n\t\twhile (wtask) {\n\t\t\tif ((wtask->wt_type == WORK_Deferred_Child) &&\n\t\t\t\t(wtask->wt_event == pid)) {\n\t\t\t\twtask->wt_type = WORK_Deferred_Cmp;\n\t\t\t\twtask->wt_aux = (int)exiteval; /* exit status */\n\t\t\t\tsvr_delay_entry++;\t/* see next_task() */\n\t\t\t}\n\t\t\twtask = (struct work_task *)GET_NEXT(wtask->wt_linkall);\n\t\t}\n\n\t\tpjob = (job *)GET_NEXT(svr_alljobs);\n\t\twhile (pjob) {\n\t\t\t/*\n\t\t\t ** see if process was a child doing a special\n\t\t\t ** function for MOM\n\t\t\t */\n\t\t\tif (pid == pjob->ji_momsubt)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t ** look for task\n\t\t\t */\n\t\t\tptask = (task *)GET_NEXT(pjob->ji_tasks);\n\t\t\twhile (ptask) {\n\t\t\t\tif (ptask->ti_qs.ti_sid == pid)\n\t\t\t\t\tbreak;\n\t\t\t\tptask = (task *)GET_NEXT(ptask->ti_jobtask);\n\t\t\t}\n\t\t\tif (ptask != NULL)\n\t\t\t\tbreak;\n\t\t\tpjob = (job *)GET_NEXT(pjob->ji_alljobs);\n\t\t}\n\n\t\tif (pjob == NULL) {\n\t\t\tDBPRT((\"%s: pid %d not tracked, exit %d\\n\",\n\t\t\t\t__func__, pid, exiteval))\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pid == pjob->ji_momsubt) {\n\t\t\tpjob->ji_momsubt = 0;\n\t\t\tif (pjob->ji_mompost) {\n\t\t\t\tpjob->ji_mompost(pjob, exiteval);\n\t\t\t}\n\t\t\t(void)job_save(pjob, SAVEJOB_QUICK);\n\t\t\tcontinue;\n\t\t}\n\t\tDBPRT((\"%s: task %8.8X pid %d exit value %d\\n\", __func__,\n\t\t\tptask->ti_qs.ti_task, pid, exiteval))\n\t\tptask->ti_qs.ti_exitstat = exiteval;\n\t\tsprintf(log_buffer, \"task %8.8X terminated\",\n\t\t\tptask->ti_qs.ti_task);\n\t\tlog_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG,\n\t\t\tpjob->ji_qs.ji_jobid, log_buffer);\n\n\t\t/*\n\t\t ** After the top process(shell) of the TASK exits, check if the\n\t\t ** JOB_SVFLG_TERMJOB job flag set. If yes, then check for any\n\t\t ** live process(s) in the session. If found, make the task\n\t\t ** ORPHAN by setting the flag and delay by kill_delay time. This\n\t\t ** will be exited in kill_job or by cput_sum() as can not be\n\t\t ** seen again by scan_for_terminated().\n\t\t */\n\t\tif (pjob->ji_qs.ji_svrflags & JOB_SVFLG_TERMJOB) {\n\t\t\tint\tn;\n\n\t\t\t(void)mom_get_sample();\n\t\t\tn = bld_ptree(ptask->ti_qs.ti_sid);\n\t\t\tif (n > 0) {\n\t\t\t\tptask->ti_flags |= TI_FLAGS_ORPHAN;\n\t\t\t\tDBPRT((\"%s: task %8.8X still has %d active procs\\n\", __func__,\n\t\t\t\t\tptask->ti_qs.ti_task, n))\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tkill_session(ptask->ti_qs.ti_sid, SIGKILL, 0);\n\t\tptask->ti_qs.ti_status = TI_STATE_EXITED;\n\t\t(void)task_save(ptask);\n\t\texiting_tasks = 1;\n\t}\n}\n\n\n#ifdef\tHAVE_POSIX_OPENPT\n\n/**\n * @brief\n *\tThis is code adapted from an example for posix_openpt in\n *\tThe Open Group Base Specifications Issue 6.\n *\n *\tOn success, this function returns an open descriptor for the\n *\tmaster pseudotty and places a pointer to the (static) name of\n *\tthe slave pseudotty in *rtn_name;  on failure, -1 is returned.\n *\n * @param[out] rtn_name - holds info of tty\n *\n * @return \tint\n * @retval \tfd \tSuccess\n * @retval \t-1\tFailure\n *\n */\nint\nopen_master(char **rtn_name)\n{\n\tint\t\tmasterfd;\n\tchar\t\t*newslavename;\n\tstatic char\tslavename[_POSIX_PATH_MAX];\n#ifndef\t_XOPEN_SOURCE\n\textern char\t*ptsname(int);\n\textern int\tgrantpt(int);\n\textern int\tunlockpt(int);\n\textern int\tposix_openpt(int);\n#endif\n\n\tmasterfd = posix_openpt(O_RDWR | O_NOCTTY);\n\tif (masterfd == -1)\n\t\treturn (-1);\n\n\tif ((grantpt(masterfd) == -1) ||\n\t\t(unlockpt(masterfd) == -1) ||\n\t\t((newslavename = ptsname(masterfd)) == NULL)) {\n\t\t(void) close(masterfd);\n\t\treturn (-1);\n\t}\n\n\t(void)strncpy(slavename, newslavename, sizeof(slavename) - 1);\n\tassert(rtn_name != NULL);\n\t*rtn_name = slavename;\n\treturn (masterfd);\n}\n\n#else\t/* HAVE_POSIX_OPENPT */\n\n/**\n * @brief\n * \tcreat the master pty, this particular\n * \tpiece of code depends on multiplexor /dev/ptc\n *\n * @param[in] rtn_name - holds info about tty\n * @return      int\n * @retval      fd      Success\n * @retval      -1      Failure\n *\n */\n\n#define PTY_SIZE 12\n\nint\nopen_master(char **rtn_name)\n{\n\tchar \t       *pc1;\n\tchar \t       *pc2;\n\tint\t\tptc;\t/* master file descriptor */\n\tstatic char\tptcchar1[] = \"pqrs\";\n\tstatic char\tptcchar2[] = \"0123456789abcdef\";\n\tstatic char\tpty_name[PTY_SIZE+1];\t/* \"/dev/[pt]tyXY\" */\n\n\t(void)strncpy(pty_name, \"/dev/ptyXY\", PTY_SIZE);\n\tfor (pc1 = ptcchar1; *pc1 != '\\0'; ++pc1) {\n\t\tpty_name[8] = *pc1;\n\t\tfor (pc2 = ptcchar2; *pc2 != '\\0'; ++pc2) {\n\t\t\tpty_name[9] = *pc2;\n\t\t\tif ((ptc = open(pty_name, O_RDWR | O_NOCTTY, 0)) >= 0) {\n\t\t\t\t/* Got a master, fix name to matching slave */\n\t\t\t\tpty_name[5] = 't';\n\t\t\t\t*rtn_name = pty_name;\n\t\t\t\treturn (ptc);\n\n\t\t\t} else if (errno == ENOENT)\n\t\t\t\treturn (-1);\t/* tried all entries, give up */\n\t\t}\n\t}\n\treturn (-1);\t/* tried all entries, give up */\n}\n#endif\t/* HAVE_POSIX_OPENPT */\n\n\n/*\n * struct sig_tbl = map of signal names to numbers,\n * see req_signal() in ../requests.c\n */\nstruct sig_tbl sig_tbl[] = {\n\t{ \"NULL\", 0 },\n\t{ \"HUP\", SIGHUP },\n\t{ \"INT\", SIGINT },\n\t{ \"QUIT\", SIGQUIT },\n\t{ \"ILL\",  SIGILL },\n\t{ \"TRAP\", SIGTRAP },\n\t{ \"IOT\", SIGIOT },\n\t{ \"ABRT\", SIGABRT },\n\t{ \"FPE\", SIGFPE },\n\t{ \"KILL\", SIGKILL },\n\t{ \"BUS\", SIGBUS },\n\t{ \"SEGV\", SIGSEGV },\n\t{ \"PIPE\", SIGPIPE },\n\t{ \"ALRM\", SIGALRM },\n\t{ \"TERM\", SIGTERM },\n\t{ \"URG\", SIGURG },\n\t{ \"STOP\", SIGSTOP },\n\t{ \"TSTP\", SIGTSTP },\n\t{ \"CONT\", SIGCONT },\n\t{ \"CHLD\", SIGCHLD },\n\t{ \"CLD\",  SIGCHLD },\n\t{ \"TTIN\", SIGTTIN },\n\t{ \"TTOU\", SIGTTOU },\n\t{ \"IO\", SIGIO },\n\t{ \"POLL\", SIGPOLL },\n\t{ \"XCPU\", SIGXCPU },\n\t{ \"XFSZ\", SIGXFSZ },\n\t{ \"VTALRM\", SIGVTALRM },\n\t{ \"PROF\", SIGPROF },\n\t{ \"WINCH\", SIGWINCH },\n\t{ \"USR1\", SIGUSR1 },\n\t{ \"USR2\", SIGUSR2 },\n\t{NULL, -1 }\n};\n\n/**\n * @brief\n *      Get the release information\n *\n * @par Functionality:\n *      This function extracts the release information of ProPack and Linux distributions\n *      from system files listed in struct release_info.\n *\n * @see\n *      get_versioned_lib\n *\n * @param[in]   file    -       pointer to file\n * @param[in]   pfx     -       pointer to prefix\n * @param[in]   srch    -       pointer to search string\n * @param[in]   sep     -       pointer to separator\n *\n * @return\tchar *\n * @retval\tdistro: <PP ver> or <OS ver>\n * @retval\tNULL: Not able to get the requested information from distro\n *\n * @par Side Effects: The value returned needs to be freed by the caller.\n *\n * @par MT-safe: Yes\n *\n */\n\nstatic char *\nparse_sysfile_info(const char *file,\n\tconst char *pfx,\n\tconst char *srch,\n\tconst char *sep)\n{\n\tFILE *fptr;\n\tchar rbuf[1024];\n\tchar *tok;\n\tchar *svptr = NULL;\n\tchar *distro;\n\tint found = 0;\n\n\tfptr = fopen(file, \"r\");\n\tif (fptr == NULL)\n\t\treturn NULL;\n\n\twhile (fgets(rbuf, sizeof(rbuf), fptr) != NULL) {\n\t\tif (strstr(rbuf, srch)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fptr);\n\n\tif (found == 0) {\n\t\tsprintf(log_buffer, \"release info not found in %s\", file);\n\t\tlog_err(errno, __func__, log_buffer);\n\t\treturn NULL;\n\t}\n\n\ttok = string_token(rbuf, sep, &svptr);\n\twhile (tok) {\n\t\tif (strstr(tok, srch)) {\n\t\t\ttok = string_token(NULL, sep, &svptr);\n\t\t\tbreak;\n\t\t}\n\t\ttok = string_token(NULL, sep, &svptr);\n\t}\n\tif (tok == NULL)\n\t\treturn NULL;\n\n\twhile (!isdigit((int)(*tok)))\n\t\ttok++;\n\tdistro = malloc(MAXNAMLEN);\n\tif (distro == NULL) {\n\t\tsprintf(log_buffer, \"memory allocation failed\");\n\t\tlog_err(errno, __func__, log_buffer);\n\t\treturn NULL;\n\t}\n\t(void)snprintf(distro, MAXNAMLEN, \"%s%d\", pfx, atoi(tok));\n\tdistro[MAXNAMLEN - 1] = '\\0';\n\treturn distro;\n}\n\n/**\n *@brief\n *\tEnsure that the shared object exists and\n *\tget the shared object name from the table\n *\n * @par Functionality:\n *\tThis function checks verified and tested list of\n *\t<PP ver>, <OS ver>, <Architecture>  and\n *\tif the above entries matches with  libcsa_support table,\n *\tthen returns shared object to the caller for dlopen.\n *\tOtherwise it returns NULL.\n *\n * @see\n *\tck_acct_facility_present\n *\n * @param[in]\tsotype\t\t-\tvariable of type integer\n *\n * @return\tchar *\n * @retval\tlibcsa_support[idx].libjobver:\tfor sotype_job\n * @retval\tlibcsa_support[idx].libcsaver:\tfor sotype_csa\n * @retval\tNULL:\t\t\t\tFailed to get the supported library\n *\n * @par Side Effects: None\n *\n * @par MT-safe: Yes\n *\n */\n\nchar *\nget_versioned_libname(int sotype)\n{\n\tint idx, table_size;\n\tstruct utsname buf;\n\tstruct libcsa_support csaobj;\n\n\tmemset(&csaobj, 0, sizeof(csaobj));\n\n\t/* load ProPack information - use the 0th index */\n\tassert(strcmp(release_info[0].pfx, \"PP\") == 0);\n\t/* if parse_sysfile_info fails, csaobj.propackver remains NULL,\n\t * and is handled later */\n\tcsaobj.propackver = parse_sysfile_info(release_info[0].file,\n\t\trelease_info[0].pfx,\n\t\trelease_info[0].srch,\n\t\trelease_info[0].sep);\n\n\t/* find OS information - loop to find out which file available */\n\ttable_size = sizeof(release_info)/sizeof(release_info[0]);\n\tfor (idx = 1; idx < table_size; idx++) {\n\t\tif (access(release_info[idx].file, R_OK) != -1)\n\t\t\tbreak;\n\t}\n\n\t/* if we found a readable os release file, parse it.\n\t * if we dont find a file or if parse_sysfile_info fails,\n\t * csaobj.osver remains NULL, and is handled later\n\t */\n\tif (idx < table_size)\n\t\tcsaobj.osver = parse_sysfile_info(release_info[idx].file,\n\t\t\trelease_info[idx].pfx,\n\t\t\trelease_info[idx].srch,\n\t\t\trelease_info[idx].sep);\n\t/* Get the information on architecture */\n\tif (uname(&buf) == -1) {\n\t\tsprintf(log_buffer, \"uname() call failed\");\n\t\tlog_err(errno, __func__, log_buffer);\n\t\tgoto SYSFAIL;\n\t}\n\n\tcsaobj.arch = strdup(buf.machine);\n\n\t/* check that all the required members of csaobj are NON-NULL */\n\tif ((csaobj.arch == NULL) || (csaobj.osver == NULL)) {\n\t\tsprintf(log_buffer, \"Failed to get system information\");\n\t\tlog_err(errno, __func__, log_buffer);\n\t\tgoto SYSFAIL;\n\t} else if (csaobj.propackver == NULL) {\n\t\tcsaobj.propackver = strdup(\"---\");\n\t}\n\n\t/* Compare system information with verified list of platforms */\n\n\ttable_size = sizeof(libcsa_support)/sizeof(libcsa_support[0]);\n\tfor (idx = 0; idx < table_size; idx++) {\n\t\tif ((strcmp(csaobj.osver, libcsa_support[idx].osver) == 0) &&\n\t\t\t(strcmp(csaobj.propackver, libcsa_support[idx].propackver) == 0) &&\n\t\t\t(strcmp(csaobj.arch, libcsa_support[idx].arch) == 0)) {\n\t\t\tfree(csaobj.arch);\n\t\t\tfree(csaobj.osver);\n\t\t\tfree(csaobj.propackver);\n\t\t\tswitch (sotype) {\n\t\t\t\tcase sotype_job:\n\t\t\t\t\treturn libcsa_support[idx].libjobver;\n\t\t\t\tcase sotype_csa:\n\t\t\t\t\treturn libcsa_support[idx].libcsaver;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\nSYSFAIL:\n\tif (csaobj.arch)\n\t\tfree(csaobj.arch);\n\tif (csaobj.osver)\n\t\tfree(csaobj.osver);\n\tif (csaobj.propackver)\n\t\tfree(csaobj.propackver);\n\treturn NULL;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/doc/man1/pbs_release_nodes.1B",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/msi/wix/resources/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/msi/wix/resources/pbs_hq.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/msi/wix/resources/setup.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/resources/pbs_wish.aps",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/resources/pbs_tclsh.aps",
        "/tmp/vanessa/spack-stage/spack-stage-openpbs-19.1.3-ssld66ds7yy2i6f3j22oezabunjm7wt6/spack-src/win_configure/resources/Pbspro_logo.ico"
    ],
    "total_files": 1254
}