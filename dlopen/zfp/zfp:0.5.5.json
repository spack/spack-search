{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-zfp-0.5.5-nzwwxmxjsz3vsh47qywy4nkshm4o7f6m/spack-src/python/scikit-build-cmake/targetLinkLibrariesWithDynamicLookup.cmake": "#.rst:\n#\n# Public Functions\n# ^^^^^^^^^^^^^^^^\n#\n# The following functions are defined:\n#\n# .. cmake:command:: target_link_libraries_with_dynamic_lookup\n#\n# ::\n#\n#     target_link_libraries_with_dynamic_lookup(<Target> [<Libraries>])\n#\n#\n# Useful to \"weakly\" link a loadable module. For example, it should be used\n# when compiling a loadable module when the symbols should be resolve from\n# the run-time environment where the module is loaded, and not a specific\n# system library.\n#\n# Like proper linking, except that the given ``<Libraries>`` are not necessarily\n# linked. Instead, the ``<Target>`` is produced in a manner that allows for\n# symbols unresolved within it to be resolved at runtime, presumably by the\n# given ``<Libraries>``.  If such a target can be produced, the provided\n# ``<Libraries>`` are not actually linked.\n#\n# It links a library to a target such that the symbols are resolved at\n# run-time not link-time.\n#\n# The linker is checked to see if it supports undefined\n# symbols when linking a shared library. If it does then the library\n# is not linked when specified with this function.\n#\n# On platforms that do not support weak-linking, this function works just\n# like ``target_link_libraries``.\n#\n# .. note::\n#\n#     For OSX it uses ``undefined dynamic_lookup``. This is similar to using\n#     ``-shared`` on Linux where undefined symbols are ignored.\n#\n#     For more details, see `blog <http://blog.tim-smith.us/2015/09/python-extension-modules-os-x/>`_\n#     from Tim D. Smith.\n#\n#\n# .. cmake:command:: check_dynamic_lookup\n#\n# Check if the linker requires a command line flag to allow leaving symbols\n# unresolved when producing a target of type ``<TargetType>`` that is\n# weakly-linked against a dependency of type ``<LibType>``.\n#\n# ``<TargetType>``\n#   can be one of \"STATIC\", \"SHARED\", \"MODULE\", or \"EXE\".\n#\n# ``<LibType>``\n#   can be one of \"STATIC\", \"SHARED\", or \"MODULE\".\n#\n# Long signature:\n#\n# ::\n#\n#     check_dynamic_lookup(<TargetType>\n#                          <LibType>\n#                          <ResultVar>\n#                          [<LinkFlagsVar>])\n#\n#\n# Short signature:\n#\n# ::\n#\n#     check_dynamic_lookup(<ResultVar>) # <TargetType> set to \"MODULE\"\n#                                       # <LibType> set to \"SHARED\"\n#\n#\n# The result is cached between invocations and recomputed only when the value\n# of CMake's linker flag list changes; ``CMAKE_STATIC_LINKER_FLAGS`` if\n# ``<TargetType>`` is \"STATIC\", and ``CMAKE_SHARED_LINKER_FLAGS`` otherwise.\n#\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   Whether the current C toolchain supports weak-linking for target binaries of\n#   type ``<TargetType>`` that are weakly-linked against a dependency target of\n#   type ``<LibType>``.\n#\n# ``<LinkFlagsVar>``\n#   List of flags to add to the linker command to produce a working target\n#   binary of type ``<TargetType>`` that is weakly-linked against a dependency\n#   target of type ``<LibType>``.\n#\n# ``HAS_DYNAMIC_LOOKUP_<TargetType>_<LibType>``\n#   Cached, global alias for ``<ResultVar>``\n#\n# ``DYNAMIC_LOOKUP_FLAGS_<TargetType>_<LibType>``\n#   Cached, global alias for ``<LinkFlagsVar>``\n#\n#\n# Private Functions\n# ^^^^^^^^^^^^^^^^^\n#\n# The following private functions are defined:\n#\n# .. warning:: These functions are not part of the scikit-build API. They\n#     exist purely as an implementation detail and may change from version\n#     to version without notice, or even be removed.\n#\n#     We mean it.\n#\n#\n# .. cmake:command:: _get_target_type\n#\n# ::\n#\n#     _get_target_type(<ResultVar> <Target>)\n#\n#\n# Shorthand for querying an abbreviated version of the target type\n# of the given ``<Target>``.\n#\n# ``<ResultVar>`` is set to:\n#\n# - \"STATIC\" for a STATIC_LIBRARY,\n# - \"SHARED\" for a SHARED_LIBRARY,\n# - \"MODULE\" for a MODULE_LIBRARY,\n# - and \"EXE\" for an EXECUTABLE.\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   The abbreviated version of the ``<Target>``'s type.\n#\n#\n# .. cmake:command:: _test_weak_link_project\n#\n# ::\n#\n#     _test_weak_link_project(<TargetType>\n#                             <LibType>\n#                             <ResultVar>\n#                             <LinkFlagsVar>)\n#\n#\n# Attempt to compile and run a test project where a target of type\n# ``<TargetType>`` is weakly-linked against a dependency of type ``<LibType>``:\n#\n# - ``<TargetType>`` can be one of \"STATIC\", \"SHARED\", \"MODULE\", or \"EXE\".\n# - ``<LibType>`` can be one of \"STATIC\", \"SHARED\", or \"MODULE\".\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   Whether the current C toolchain can produce a working target binary of type\n#   ``<TargetType>`` that is weakly-linked against a dependency target of type\n#   ``<LibType>``.\n#\n# ``<LinkFlagsVar>``\n#   List of flags to add to the linker command to produce a working target\n#   binary of type ``<TargetType>`` that is weakly-linked against a dependency\n#   target of type ``<LibType>``.\n#\n\nfunction(_get_target_type result_var target)\n  set(target_type \"SHARED_LIBRARY\")\n  if(TARGET ${target})\n    get_property(target_type TARGET ${target} PROPERTY TYPE)\n  endif()\n\n  set(result \"STATIC\")\n\n  if(target_type STREQUAL \"STATIC_LIBRARY\")\n    set(result \"STATIC\")\n  endif()\n\n  if(target_type STREQUAL \"SHARED_LIBRARY\")\n    set(result \"SHARED\")\n  endif()\n\n  if(target_type STREQUAL \"MODULE_LIBRARY\")\n    set(result \"MODULE\")\n  endif()\n\n  if(target_type STREQUAL \"EXECUTABLE\")\n    set(result \"EXE\")\n  endif()\n\n  set(${result_var} ${result} PARENT_SCOPE)\nendfunction()\n\n\nfunction(_test_weak_link_project\n         target_type\n         lib_type\n         can_weak_link_var\n         project_name)\n\n  set(gnu_ld_ignore      \"-Wl,--unresolved-symbols=ignore-all\")\n  set(osx_dynamic_lookup           \"-undefined dynamic_lookup\")\n  set(no_flag                                               \"\")\n\n  foreach(link_flag_spec gnu_ld_ignore osx_dynamic_lookup no_flag)\n    set(link_flag \"${${link_flag_spec}}\")\n\n    set(test_project_dir \"${PROJECT_BINARY_DIR}/CMakeTmp\")\n    set(test_project_dir \"${test_project_dir}/${project_name}\")\n    set(test_project_dir \"${test_project_dir}/${link_flag_spec}\")\n    set(test_project_dir \"${test_project_dir}/${target_type}\")\n    set(test_project_dir \"${test_project_dir}/${lib_type}\")\n\n    set(test_project_src_dir \"${test_project_dir}/src\")\n    set(test_project_bin_dir \"${test_project_dir}/build\")\n\n    file(MAKE_DIRECTORY ${test_project_src_dir})\n    file(MAKE_DIRECTORY ${test_project_bin_dir})\n\n    set(mod_type \"STATIC\")\n    set(link_mod_lib TRUE)\n    set(link_exe_lib TRUE)\n    set(link_exe_mod FALSE)\n\n    if(\"${target_type}\" STREQUAL \"EXE\")\n      set(link_exe_lib FALSE)\n      set(link_exe_mod TRUE)\n    else()\n      set(mod_type \"${target_type}\")\n    endif()\n\n    if(\"${mod_type}\" STREQUAL \"MODULE\")\n      set(link_mod_lib FALSE)\n    endif()\n\n\n    file(WRITE \"${test_project_src_dir}/CMakeLists.txt\" \"\n      cmake_minimum_required(VERSION ${CMAKE_VERSION})\n      project(${project_name} C)\n\n      include_directories(${test_project_src_dir})\n\n      add_library(number ${lib_type} number.c)\n      add_library(counter ${mod_type} counter.c)\n    \")\n\n    if(\"${mod_type}\" STREQUAL \"MODULE\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        set_target_properties(counter PROPERTIES PREFIX \\\"\\\")\n      \")\n    endif()\n\n    if(link_mod_lib)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(counter number)\n      \")\n    elseif(NOT link_flag STREQUAL \"\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        set_target_properties(counter PROPERTIES LINK_FLAGS \\\"${link_flag}\\\")\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n      add_executable(main main.c)\n    \")\n\n    if(link_exe_lib)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main number)\n      \")\n    elseif(NOT link_flag STREQUAL \"\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main \\\"${link_flag}\\\")\n      \")\n    endif()\n\n    if(link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main counter)\n      \")\n    else()\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main \\\"${CMAKE_DL_LIBS}\\\")\n      \")\n    endif()\n\n    file(WRITE \"${test_project_src_dir}/number.c\" \"\n      #include <number.h>\n\n      static int _number;\n      void set_number(int number) { _number = number; }\n      int get_number() { return _number; }\n    \")\n\n    file(WRITE \"${test_project_src_dir}/number.h\" \"\n      #ifndef _NUMBER_H\n      #define _NUMBER_H\n      extern void set_number(int);\n      extern int get_number(void);\n      #endif\n    \")\n\n    file(WRITE \"${test_project_src_dir}/counter.c\" \"\n      #include <number.h>\n      int count() {\n        int result = get_number();\n        set_number(result + 1);\n        return result;\n      }\n    \")\n\n    file(WRITE \"${test_project_src_dir}/counter.h\" \"\n      #ifndef _COUNTER_H\n      #define _COUNTER_H\n      extern int count(void);\n      #endif\n    \")\n\n    file(WRITE \"${test_project_src_dir}/main.c\" \"\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <number.h>\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        #include <dlfcn.h>\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n      int my_count() {\n        int result = get_number();\n        set_number(result + 1);\n        return result;\n      }\n\n      int main(int argc, char **argv) {\n        int result;\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        void *counter_module;\n        int (*count)(void);\n\n        counter_module = dlopen(\\\"./counter.so\\\", RTLD_LAZY | RTLD_GLOBAL);\n        if(!counter_module) goto error;\n\n        count = dlsym(counter_module, \\\"count\\\");\n        if(!count) goto error;\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n        result = count()    != 0 ? EXIT_FAILURE :\n                 my_count() != 1 ? EXIT_FAILURE :\n                 my_count() != 2 ? EXIT_FAILURE :\n                 count()    != 3 ? EXIT_FAILURE :\n                 count()    != 4 ? EXIT_FAILURE :\n                 count()    != 5 ? EXIT_FAILURE :\n                 my_count() != 6 ? EXIT_FAILURE : EXIT_SUCCESS;\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        goto done;\n        error:\n          fprintf(stderr, \\\"Error occured:\\\\n    %s\\\\n\\\", dlerror());\n          result = 1;\n\n        done:\n          if(counter_module) dlclose(counter_module);\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n          return result;\n      }\n    \")\n\n    set(_rpath_arg)\n    if(APPLE AND ${CMAKE_VERSION} VERSION_GREATER 2.8.11)\n      set(_rpath_arg \"-DCMAKE_MACOSX_RPATH='${CMAKE_MACOSX_RPATH}'\")\n    endif()\n\n    try_compile(project_compiles\n                \"${test_project_bin_dir}\"\n                \"${test_project_src_dir}\"\n                \"${project_name}\"\n                CMAKE_FLAGS\n                  \"-DCMAKE_SHARED_LINKER_FLAGS='${CMAKE_SHARED_LINKER_FLAGS}'\"\n                  \"-DCMAKE_ENABLE_EXPORTS=ON\"\n                  ${_rpath_arg}\n                OUTPUT_VARIABLE compile_output)\n\n    set(project_works 1)\n    set(run_output)\n\n    if(project_compiles)\n      execute_process(COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR}\n                              \"${test_project_bin_dir}/main\"\n                      WORKING_DIRECTORY \"${test_project_bin_dir}\"\n                      RESULT_VARIABLE project_works\n                      OUTPUT_VARIABLE run_output\n                      ERROR_VARIABLE run_output)\n    endif()\n\n    set(test_description\n        \"Weak Link ${target_type} -> ${lib_type} (${link_flag_spec})\")\n\n    if(project_works EQUAL 0)\n      set(project_works TRUE)\n      message(STATUS \"Performing Test ${test_description} - Success\")\n    else()\n      set(project_works FALSE)\n      message(STATUS \"Performing Test ${test_description} - Failed\")\n      file(APPEND ${CMAKE_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/CMakeError.log\n           \"Performing Test ${test_description} failed with the \"\n           \"following output:\\n\"\n           \"BUILD\\n-----\\n${compile_output}\\nRUN\\n---\\n${run_output}\\n\")\n    endif()\n\n    set(${can_weak_link_var} ${project_works} PARENT_SCOPE)\n    if(project_works)\n      set(${project_name} ${link_flag} PARENT_SCOPE)\n      break()\n    endif()\n  endforeach()\nendfunction()\n\nfunction(check_dynamic_lookup)\n  # Two signatures are supported:\n\n  if(ARGC EQUAL \"1\")\n    #\n    # check_dynamic_lookup(<ResultVar>)\n    #\n    set(target_type \"MODULE\")\n    set(lib_type \"SHARED\")\n    set(has_dynamic_lookup_var \"${ARGV0}\")\n    set(link_flags_var \"unused\")\n\n  elseif(ARGC GREATER \"2\")\n    #\n    # check_dynamic_lookup(<TargetType>\n    #                      <LibType>\n    #                      <ResultVar>\n    #                      [<LinkFlagsVar>])\n    #\n    set(target_type \"${ARGV0}\")\n    set(lib_type \"${ARGV1}\")\n    set(has_dynamic_lookup_var \"${ARGV2}\")\n    if(ARGC EQUAL \"3\")\n      set(link_flags_var \"unused\")\n    else()\n      set(link_flags_var \"${ARGV3}\")\n    endif()\n  else()\n    message(FATAL_ERROR \"missing arguments\")\n  endif()\n\n  _check_dynamic_lookup(\n    ${target_type}\n    ${lib_type}\n    ${has_dynamic_lookup_var}\n    ${link_flags_var}\n    )\n  set(${has_dynamic_lookup_var} ${${has_dynamic_lookup_var}} PARENT_SCOPE)\n  if(NOT \"x${link_flags_var}x\" STREQUAL \"xunusedx\")\n    set(${link_flags_var} ${${link_flags_var}} PARENT_SCOPE)\n  endif()\nendfunction()\n\nfunction(_check_dynamic_lookup\n         target_type\n         lib_type\n         has_dynamic_lookup_var\n         link_flags_var\n         )\n\n  # hash the CMAKE_FLAGS passed and check cache to know if we need to rerun\n  if(\"${target_type}\" STREQUAL \"STATIC\")\n    string(MD5 cmake_flags_hash \"${CMAKE_STATIC_LINKER_FLAGS}\")\n  else()\n    string(MD5 cmake_flags_hash \"${CMAKE_SHARED_LINKER_FLAGS}\")\n  endif()\n\n  set(cache_var \"HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}\")\n  set(cache_hash_var \"HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}_hash\")\n  set(result_var \"DYNAMIC_LOOKUP_FLAGS_${target_type}_${lib_type}\")\n\n  if(     NOT DEFINED ${cache_hash_var}\n       OR NOT \"${${cache_hash_var}}\" STREQUAL \"${cmake_flags_hash}\")\n    unset(${cache_var} CACHE)\n  endif()\n\n  if(NOT DEFINED ${cache_var})\n    set(skip_test FALSE)\n\n   if(CMAKE_CROSSCOMPILING AND NOT CMAKE_CROSSCOMPILING_EMULATOR)\n      set(skip_test TRUE)\n    endif()\n\n    if(skip_test)\n      set(has_dynamic_lookup FALSE)\n      set(link_flags)\n    else()\n      _test_weak_link_project(${target_type}\n                              ${lib_type}\n                              has_dynamic_lookup\n                              link_flags)\n    endif()\n\n    set(caveat \" (when linking ${target_type} against ${lib_type})\")\n\n    set(${cache_var} \"${has_dynamic_lookup}\"\n        CACHE BOOL\n        \"linker supports dynamic lookup for undefined symbols${caveat}\")\n    mark_as_advanced(${cache_var})\n\n    set(${result_var} \"${link_flags}\"\n        CACHE STRING\n        \"linker flags for dynamic lookup${caveat}\")\n    mark_as_advanced(${result_var})\n\n    set(${cache_hash_var} \"${cmake_flags_hash}\"\n        CACHE INTERNAL \"hashed flags for ${cache_var} check\")\n  endif()\n\n  set(${has_dynamic_lookup_var} \"${${cache_var}}\" PARENT_SCOPE)\n  set(${link_flags_var} \"${${result_var}}\" PARENT_SCOPE)\nendfunction()\n\nfunction(target_link_libraries_with_dynamic_lookup target)\n  _get_target_type(target_type ${target})\n\n  set(link_props)\n  set(link_items)\n  set(link_libs)\n\n  foreach(lib ${ARGN})\n    _get_target_type(lib_type ${lib})\n    check_dynamic_lookup(${target_type}\n                         ${lib_type}\n                         has_dynamic_lookup\n                         dynamic_lookup_flags)\n\n    if(has_dynamic_lookup)\n      if(dynamic_lookup_flags)\n        if(\"${target_type}\" STREQUAL \"EXE\")\n          list(APPEND link_items \"${dynamic_lookup_flags}\")\n        else()\n          list(APPEND link_props \"${dynamic_lookup_flags}\")\n        endif()\n      endif()\n    elseif(${lib} MATCHES \"(debug|optimized|general)\")\n      # See gh-255\n    else()\n      list(APPEND link_libs \"${lib}\")\n    endif()\n  endforeach()\n\n  if(link_props)\n    list(REMOVE_DUPLICATES link_props)\n  endif()\n\n  if(link_items)\n    list(REMOVE_DUPLICATES link_items)\n  endif()\n\n  if(link_libs)\n    list(REMOVE_DUPLICATES link_libs)\n  endif()\n\n  if(link_props)\n    set_target_properties(${target}\n                          PROPERTIES LINK_FLAGS \"${link_props}\")\n  endif()\n\n  set(links \"${link_items}\" \"${link_libs}\")\n  if(links)\n    target_link_libraries(${target} \"${links}\")\n  endif()\nendfunction()\n"
    },
    "skipped": [],
    "total_files": 185
}