{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/g2o/core/optimization_algorithm_factory.h": "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#ifndef G2O_OPTMIZATION_ALGORITHM_PROPERTY_H\n#define G2O_OPTMIZATION_ALGORITHM_PROPERTY_H\n\n#include <iostream>\n#include <list>\n#include <memory>\n\n#include \"g2o/config.h\"\n#include \"g2o/stuff/misc.h\"  // ForceLinker for the macros\n#include \"g2o_core_api.h\"\n#include \"optimization_algorithm_property.h\"\n\n// define to get some verbose output\n//#define G2O_DEBUG_OPTIMIZATION_ALGORITHM_FACTORY\n\nnamespace g2o {\n\n// forward decl\nclass G2O_CORE_API OptimizationAlgorithm;\n\n/**\n * \\brief base for allocating an optimization algorithm\n *\n * Allocating a solver for a given optimizer. The method construct() has to be\n * implemented in your derived class to allocate the desired solver.\n */\nclass G2O_CORE_API AbstractOptimizationAlgorithmCreator {\n public:\n  AbstractOptimizationAlgorithmCreator(const OptimizationAlgorithmProperty& p);\n  virtual ~AbstractOptimizationAlgorithmCreator() {}\n  //! allocate a solver operating on optimizer, re-implement for your creator\n  virtual OptimizationAlgorithm* construct() = 0;\n  //! return the properties of the solver\n  const OptimizationAlgorithmProperty& property() const { return _property; }\n\n protected:\n  OptimizationAlgorithmProperty _property;\n};\n\n/**\n * \\brief create solvers based on their short name\n *\n * Factory to allocate solvers based on their short name.\n * The Factory is implemented as a sigleton and the single\n * instance can be accessed via the instance() function.\n */\nclass G2O_CORE_API OptimizationAlgorithmFactory {\n public:\n  typedef std::list<std::shared_ptr<AbstractOptimizationAlgorithmCreator>> CreatorList;\n\n  //! return the instance\n  static OptimizationAlgorithmFactory* instance();\n\n  //! free the instance\n  static void destroy();\n\n  OptimizationAlgorithmFactory(OptimizationAlgorithmFactory const&) = delete;\n  OptimizationAlgorithmFactory& operator=(OptimizationAlgorithmFactory const&) = delete;\n\n  /**\n   * register a specific creator for allocating a solver\n   */\n  void registerSolver(const std::shared_ptr<AbstractOptimizationAlgorithmCreator>& c);\n\n  /**\n   * unregister a specific creator for allocating a solver\n   */\n  void unregisterSolver(const std::shared_ptr<AbstractOptimizationAlgorithmCreator>& c);\n\n  /**\n   * construct a solver based on its name, e.g., var, fix3_2_cholmod\n   */\n  OptimizationAlgorithm* construct(const std::string& tag,\n                                   OptimizationAlgorithmProperty& solverProperty) const;\n\n  //! list the known solvers into a stream\n  void listSolvers(std::ostream& os) const;\n\n  //! return the underlying list of creators\n  const CreatorList& creatorList() const { return _creator; }\n\n protected:\n  OptimizationAlgorithmFactory() = default;\n\n  CreatorList _creator;\n\n  CreatorList::const_iterator findSolver(const std::string& name) const;\n  CreatorList::iterator findSolver(const std::string& name);\n\n private:\n  static std::unique_ptr<OptimizationAlgorithmFactory> factoryInstance;\n};\n\nclass RegisterOptimizationAlgorithmProxy {\n public:\n  RegisterOptimizationAlgorithmProxy(AbstractOptimizationAlgorithmCreator* c) {\n    _creator.reset(c);\n#ifdef G2O_DEBUG_OPTIMIZATION_ALGORITHM_FACTORY\n    std::cout << __FUNCTION__ << \": Registering \" << _creator->property().name << \" of type \"\n              << typeid(*_creator).name() << std::endl;\n#endif\n    OptimizationAlgorithmFactory::instance()->registerSolver(_creator);\n  }\n\n private:\n  std::shared_ptr<AbstractOptimizationAlgorithmCreator> _creator;\n};\n\n}  // namespace g2o\n\n#if defined _MSC_VER && defined G2O_SHARED_LIBS\n#define G2O_OAF_EXPORT __declspec(dllexport)\n#define G2O_OAF_IMPORT __declspec(dllimport)\n#else\n#define G2O_OAF_EXPORT\n#define G2O_OAF_IMPORT\n#endif\n\n/**\n * Use the following macro to register a whole library of\n * algorithms to the factory, e.g.,\n * G2O_REGISTER_OPTIMIZATION_LIBRARY(csparse)\n * In another programm that links to your library or loads\n * it via dlopen() (or similar functions) you should indicate\n * the desired usage of the solver by using the\n * G2O_REGISTER_OPTIMIZATION_LIBRARY() macro. Here, you\n * should then provide the same name as to the macro before.\n */\n#define G2O_REGISTER_OPTIMIZATION_LIBRARY(libraryname) \\\n  extern \"C\" void G2O_OAF_EXPORT g2o_optimization_library_##libraryname(void) {}\n\n/**\n * see the documentation to G2O_OAF_EXPORT() above.\n * You should but this into your code, if you expect the factory\n * to be able to allocate a solver but it fails. It enforces linking\n * to the library containing the solver. Hence, the usage of the macro\n * should enforce that the library is actually linked with the binary.\n */\n#define G2O_USE_OPTIMIZATION_LIBRARY(libraryname)                                 \\\n  extern \"C\" void G2O_OAF_IMPORT g2o_optimization_library_##libraryname(void);    \\\n  static g2o::ForceLinker g2o_force_optimization_algorithm_library_##libraryname( \\\n      g2o_optimization_library_##libraryname);\n\n/**\n * Similarly to G2O_OAF_IMPORT this macro allows to register a singla\n * more specific algorithm to the library, i.e., gn_var, where gn_var\n * corresponds to a specific instance of csparse based solver for example\n */\n#define G2O_REGISTER_OPTIMIZATION_ALGORITHM(optimizername, instance)                             \\\n  extern \"C\" void G2O_OAF_EXPORT g2o_optimization_algorithm_##optimizername(void) {}             \\\n  static g2o::RegisterOptimizationAlgorithmProxy g_optimization_algorithm_proxy_##optimizername( \\\n      instance);\n\n/**\n * see the documentation of the macros above.\n * It allows to enforce linking to library that contains a specific\n * solver instance and guarantees its usage with the factory\n */\n#define G2O_USE_OPTIMIZATION_ALGORITHM(optimizername)                              \\\n  extern \"C\" void G2O_OAF_IMPORT g2o_optimization_algorithm_##optimizername(void); \\\n  static g2o::ForceLinker g2o_force_optimization_algorithm_link_##optimizername(   \\\n      g2o_optimization_algorithm_##optimizername);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/g2o/apps/g2o_cli/dl_wrapper.cpp": "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include <sys/types.h>\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\n#include \"dl_wrapper.h\"\n#include \"g2o/stuff/macros.h\"\n#include \"g2o/stuff/filesys_tools.h\"\n\n#if defined (UNIX) || defined(CYGWIN)\n#include <dlfcn.h>\n#endif\n\n#ifdef __APPLE__\n#define SO_EXT \"dylib\"\n#define SO_EXT_LEN 5\n#elif defined (WINDOWS) || defined (CYGWIN)\n#define SO_EXT \"dll\"\n#define SO_EXT_LEN 3\n#else // Linux\n#define SO_EXT \"so\"\n#define SO_EXT_LEN 2\n#endif\n\nusing namespace std;\n\nnamespace g2o {\n\nDlWrapper::DlWrapper()\n{\n}\n\nDlWrapper::~DlWrapper()\n{\n  //clear();\n}\n\nint DlWrapper::openLibraries(const std::string& directory, const std::string& pattern)\n{\n  //cerr << \"# loading libraries from \" << directory << \"\\t pattern: \" << pattern << endl;\n  string searchPattern = directory + \"/\" + pattern;\n  if (pattern == \"\")\n    searchPattern = directory + \"/*\";\n  vector<string> matchingFiles = getFilesByPattern(searchPattern.c_str());\n\n  int numLibs = 0;\n  for (size_t i = 0; i < matchingFiles.size(); ++i) {\n    const string& filename = matchingFiles[i];\n    if (find(_filenames.begin(), _filenames.end(), filename) != _filenames.end())\n      continue;\n\n    // If we are doing a release build, the wildcards will pick up the\n    // suffixes; unfortunately the \"_rd\" extension means that we\n    // don't seem to be able to filter out the incompatible files using a\n    // wildcard expansion to wordexp.\n\n#ifndef G2O_LIBRARY_POSTFIX\n    if ((filename.rfind(string(\"_d.\") + SO_EXT) == filename.length() - 3 - SO_EXT_LEN)\n        || (filename.rfind(string(\"_rd.\") + SO_EXT) == filename.length() - 4 - SO_EXT_LEN)\n        || (filename.rfind(string(\"_s.\") + SO_EXT) == filename.length() - 3 - SO_EXT_LEN))\n        continue;\n#endif\n\n    // open the lib\n    //cerr << \"loading \" << filename << endl;\n    if (openLibrary(filename))\n      numLibs++;\n  }\n\n  return numLibs;\n}\n\nvoid DlWrapper::clear()\n{\n# if defined (UNIX) || defined(CYGWIN)\n  for (size_t i = 0; i < _handles.size(); ++i) {\n    dlclose(_handles[i]);\n  }\n#elif defined(WINDOWS)\n  for (size_t i = 0; i < _handles.size(); ++i) {\n    FreeLibrary(_handles[i]);\n  }\n#endif\n  _filenames.clear();\n  _handles.clear();\n}\n\nbool DlWrapper::openLibrary(const std::string& filename)\n{\n# if defined (UNIX) || defined(CYGWIN)\n  void* handle = dlopen(filename.c_str(), RTLD_LAZY);\n  if (! handle) {\n    cerr << __PRETTY_FUNCTION__ << \" Cannot open library: \" << dlerror() << '\\n';\n    return false;\n  }\n# elif defined (WINDOWS)\n  HMODULE handle = LoadLibrary(filename.c_str());\n  if (! handle) {\n    cerr << __PRETTY_FUNCTION__ << \" Cannot open library.\" << endl;\n    return false;\n  }\n# endif\n\n  //cerr << \"loaded \" << filename << endl;\n\n  _filenames.push_back(filename);\n  _handles.push_back(handle);\n  return true;\n}\n\n} // end namespace g2o\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/.git/objects/pack/pack-7ff49fe040fa0c43c273d6e6db193ba00d265390.pack",
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/.git/objects/pack/pack-7ff49fe040fa0c43c273d6e6db193ba00d265390.idx",
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/doc/g2o.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/doc/pics/viewer.png",
        "/tmp/vanessa/spack-stage/spack-stage-g2o-master-5ecwwdasfyf5md4tfaqrxyk5p6nognnc/spack-src/doc/pics/viewer.eps"
    ],
    "total_files": 706
}