{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-sysbench-1.0.19-gikkqs7jdja4opskyaz2kgg5fvxf5cus/spack-src/third_party/luajit/luajit/src/lib_package.c": "/*\n** Package library.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n**\n** Major portions taken verbatim or adapted from the Lua interpreter.\n** Copyright (C) 1994-2012 Lua.org, PUC-Rio. See Copyright Notice in lua.h\n*/\n\n#define lib_package_c\n#define LUA_LIB\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n#include \"lj_obj.h\"\n#include \"lj_err.h\"\n#include \"lj_lib.h\"\n\n/* ------------------------------------------------------------------------ */\n\n/* Error codes for ll_loadfunc. */\n#define PACKAGE_ERR_LIB\t\t1\n#define PACKAGE_ERR_FUNC\t2\n#define PACKAGE_ERR_LOAD\t3\n\n/* Redefined in platform specific part. */\n#define PACKAGE_LIB_FAIL\t\"open\"\n#define setprogdir(L)\t\t((void)0)\n\n/* Symbol name prefixes. */\n#define SYMPREFIX_CF\t\t\"luaopen_%s\"\n#define SYMPREFIX_BC\t\t\"luaJIT_BC_%s\"\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib(void *lib)\n{\n  dlclose(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  void *lib = dlopen(path, RTLD_NOW | (gl ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n#if defined(RTLD_DEFAULT)\n  if (lib == NULL) lib = RTLD_DEFAULT;\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n  if (lib == NULL) lib = (void *)(intptr_t)-2;\n#endif\n  return (const char *)dlsym(lib, sym);\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS  4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT  2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#undef setprogdir\n\nstatic void setprogdir(lua_State *L)\n{\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL) {\n    luaL_error(L, \"unable to get ModuleFileName\");\n  } else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\nstatic void pusherror(lua_State *L)\n{\n  DWORD error = GetLastError();\n#if LJ_TARGET_XBOXONE\n  wchar_t wbuffer[128];\n  char buffer[128*2];\n  if (FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, wbuffer, sizeof(wbuffer)/sizeof(wchar_t), NULL) &&\n      WideCharToMultiByte(CP_ACP, 0, wbuffer, 128, buffer, 128*2, NULL, NULL))\n#else\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n#endif\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib(void *lib)\n{\n  FreeLibrary((HINSTANCE)lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  HINSTANCE lib = LoadLibraryExA(path, NULL, 0);\n  if (lib == NULL) pusherror(L);\n  UNUSED(gl);\n  return lib;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  if (lib) {\n    return (const char *)GetProcAddress((HINSTANCE)lib, sym);\n  } else {\n    HINSTANCE h = GetModuleHandleA(NULL);\n    const char *p = (const char *)GetProcAddress(h, sym);\n    if (p == NULL && GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t\t\t(const char *)ll_bcsym, &h))\n      p = (const char *)GetProcAddress(h, sym);\n    return p;\n  }\n}\n\n#else\n\n#undef PACKAGE_LIB_FAIL\n#define PACKAGE_LIB_FAIL\t\"absent\"\n\n#define DLMSG\t\"dynamic libraries not enabled; no support for target OS\"\n\nstatic void ll_unloadlib(void *lib)\n{\n  UNUSED(lib);\n}\n\nstatic void *ll_load(lua_State *L, const char *path, int gl)\n{\n  UNUSED(path); UNUSED(gl);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\nstatic const char *ll_bcsym(void *lib, const char *sym)\n{\n  UNUSED(lib); UNUSED(sym);\n  return NULL;\n}\n\n#endif\n\n/* ------------------------------------------------------------------------ */\n\nstatic void **ll_register(lua_State *L, const char *path)\n{\n  void **plib;\n  lua_pushfstring(L, \"LOADLIB: %s\", path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1)) {  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  } else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(void *));\n    *plib = NULL;\n    luaL_getmetatable(L, \"_LOADLIB\");\n    lua_setmetatable(L, -2);\n    lua_pushfstring(L, \"LOADLIB: %s\", path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\nstatic const char *mksymname(lua_State *L, const char *modname,\n\t\t\t     const char *prefix)\n{\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", \"_\");\n  funcname = lua_pushfstring(L, prefix, funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\nstatic int ll_loadfunc(lua_State *L, const char *path, const char *name, int r)\n{\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path, (*name == '*'));\n  if (*reg == NULL) {\n    return PACKAGE_ERR_LIB;  /* Unable to load library. */\n  } else if (*name == '*') {  /* Only load library into global namespace. */\n    lua_pushboolean(L, 1);\n    return 0;\n  } else {\n    const char *sym = r ? name : mksymname(L, name, SYMPREFIX_CF);\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f) {\n      lua_pushcfunction(L, f);\n      return 0;\n    }\n    if (!r) {\n      const char *bcdata = ll_bcsym(*reg, mksymname(L, name, SYMPREFIX_BC));\n      lua_pop(L, 1);\n      if (bcdata) {\n\tif (luaL_loadbuffer(L, bcdata, LJ_MAX_BUF, name) != 0)\n\t  return PACKAGE_ERR_LOAD;\n\treturn 0;\n      }\n    }\n    return PACKAGE_ERR_FUNC;  /* Unable to find function. */\n  }\n}\n\nstatic int lj_cf_package_loadlib(lua_State *L)\n{\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int st = ll_loadfunc(L, path, init, 1);\n  if (st == 0) {  /* no errors? */\n    return 1;  /* return the loaded function */\n  } else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (st == PACKAGE_ERR_LIB) ?  PACKAGE_LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\nstatic int lj_cf_package_unloadlib(lua_State *L)\n{\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic int readable(const char *filename)\n{\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\nstatic const char *pushnexttemplate(lua_State *L, const char *path)\n{\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, (size_t)(l - path));  /* template */\n  return l;\n}\n\nstatic const char *searchpath (lua_State *L, const char *name,\n\t\t\t       const char *path, const char *sep,\n\t\t\t       const char *dirsep)\n{\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n\t\t\t\t     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    goto check_readable; /* suppress \"unused label\" warning */\ncheck_readable:\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n#if LJ_TARGET_OSX || LJ_TARGET_IOS\n    /* if *.dylib is missing, try *.so */\n    size_t len = strlen(filename);\n    if (len > 6 && strcmp(filename + len - 6, \".dylib\") == 0) {\n      luaL_addvalue(&msg);  /* concatenate error msg. entry */\n      lua_pushlstring(L, filename, len - 6);\n      filename = lua_pushfstring(L, \"%s.so\", lua_tostring(L, -1));\n      lua_insert(L, -3); /* sink new filename below old one */\n      lua_pop(L, 2);\n      goto check_readable;\n    }\n#endif\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\nstatic int lj_cf_package_searchpath(lua_State *L)\n{\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n\t\t\t\tluaL_checkstring(L, 2),\n\t\t\t\tluaL_optstring(L, 3, \".\"),\n\t\t\t\tluaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) {\n    return 1;\n  } else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\nstatic const char *findfile(lua_State *L, const char *name,\n\t\t\t    const char *pname)\n{\n  const char *path;\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  return searchpath(L, name, path, \".\", LUA_DIRSEP);\n}\n\nstatic void loaderror(lua_State *L, const char *filename)\n{\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n\t     lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\nstatic int lj_cf_package_loader_lua(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_c(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (ll_loadfunc(L, filename, name, 0) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\nstatic int lj_cf_package_loader_croot(lua_State *L)\n{\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int st;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, (size_t)(p - name));\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  if ((st = ll_loadfunc(L, filename, name, 0)) != 0) {\n    if (st != PACKAGE_ERR_FUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n\t\t    name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\nstatic int lj_cf_package_loader_preload(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1)) {  /* Not found? */\n    const char *bcname = mksymname(L, name, SYMPREFIX_BC);\n    const char *bcdata = ll_bcsym(NULL, bcname);\n    if (bcdata == NULL || luaL_loadbuffer(L, bcdata, LJ_MAX_BUF, name) != 0)\n      lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  }\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define sentinel\t((void *)0x4004)\n\nstatic int lj_cf_package_require(lua_State *L)\n{\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i = 1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n\t\t name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  lj_lib_checkfpu(L);\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\nstatic void setfenv(lua_State *L)\n{\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\nstatic void dooptions(lua_State *L, int n)\n{\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\nstatic void modinit(lua_State *L, const char *modname)\n{\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname; else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, (size_t)(dot - modname));\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\nstatic int lj_cf_package_module(lua_State *L)\n{\n  const char *modname = luaL_checkstring(L, 1);\n  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)\n      lj_err_callerv(L, LJ_ERR_BADMODN, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */\n  }\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1)) {  /* is table an initialized module? */\n    lua_pop(L, 1);\n  } else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, loaded - 1);\n  return 0;\n}\n\nstatic int lj_cf_package_seeall(lua_State *L)\n{\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\n\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath(lua_State *L, const char *fieldname, const char *envname,\n\t\t    const char *def, int noenv)\n{\n#if LJ_TARGET_CONSOLE\n  const char *path = NULL;\n  UNUSED(envname);\n#else\n  const char *path = getenv(envname);\n#endif\n  if (path == NULL || noenv) {\n    lua_pushstring(L, def);\n  } else {\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n\t\t\t      LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\nstatic const luaL_Reg package_lib[] = {\n  { \"loadlib\",\tlj_cf_package_loadlib },\n  { \"searchpath\",  lj_cf_package_searchpath },\n  { \"seeall\",\tlj_cf_package_seeall },\n  { NULL, NULL }\n};\n\nstatic const luaL_Reg package_global[] = {\n  { \"module\",\tlj_cf_package_module },\n  { \"require\",\tlj_cf_package_require },\n  { NULL, NULL }\n};\n\nstatic const lua_CFunction package_loaders[] =\n{\n  lj_cf_package_loader_preload,\n  lj_cf_package_loader_lua,\n  lj_cf_package_loader_c,\n  lj_cf_package_loader_croot,\n  NULL\n};\n\nLUALIB_API int luaopen_package(lua_State *L)\n{\n  int i;\n  int noenv;\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lj_lib_pushcf(L, lj_cf_package_unloadlib, 1);\n  lua_setfield(L, -2, \"__gc\");\n  luaL_register(L, LUA_LOADLIBNAME, package_lib);\n  lua_pushvalue(L, -1);\n  lua_replace(L, LUA_ENVIRONINDEX);\n  lua_createtable(L, sizeof(package_loaders)/sizeof(package_loaders[0])-1, 0);\n  for (i = 0; package_loaders[i] != NULL; i++) {\n    lj_lib_pushcf(L, package_loaders[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if LJ_52\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, \"searchers\");\n#endif\n  lua_setfield(L, -2, \"loaders\");\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  noenv = lua_toboolean(L, -1);\n  lua_pop(L, 1);\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT, noenv);\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT, noenv);\n  lua_pushliteral(L, LUA_PATH_CONFIG);\n  lua_setfield(L, -2, \"config\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 16);\n  lua_setfield(L, -2, \"loaded\");\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\", 4);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, package_global);\n  lua_pop(L, 1);\n  return 1;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-sysbench-1.0.19-gikkqs7jdja4opskyaz2kgg5fvxf5cus/spack-src/third_party/luajit/luajit/src/lj_clib.c": "/*\n** FFI C library loader.\n** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h\n*/\n\n#include \"lj_obj.h\"\n\n#if LJ_HASFFI\n\n#include \"lj_gc.h\"\n#include \"lj_err.h\"\n#include \"lj_tab.h\"\n#include \"lj_str.h\"\n#include \"lj_udata.h\"\n#include \"lj_ctype.h\"\n#include \"lj_cconv.h\"\n#include \"lj_cdata.h\"\n#include \"lj_clib.h\"\n#include \"lj_strfmt.h\"\n\n/* -- OS-specific functions ----------------------------------------------- */\n\n#if LJ_TARGET_DLOPEN\n\n#include <dlfcn.h>\n#include <stdio.h>\n\n#if defined(RTLD_DEFAULT)\n#define CLIB_DEFHANDLE\tRTLD_DEFAULT\n#elif LJ_TARGET_OSX || LJ_TARGET_BSD\n#define CLIB_DEFHANDLE\t((void *)(intptr_t)-2)\n#else\n#define CLIB_DEFHANDLE\tNULL\n#endif\n\nLJ_NORET LJ_NOINLINE static void clib_error_(lua_State *L)\n{\n  lj_err_callermsg(L, dlerror());\n}\n\n#define clib_error(L, fmt, name)\tclib_error_(L)\n\n#if LJ_TARGET_CYGWIN\n#define CLIB_SOPREFIX\t\"cyg\"\n#else\n#define CLIB_SOPREFIX\t\"lib\"\n#endif\n\n#if LJ_TARGET_OSX\n#define CLIB_SOEXT\t\"%s.dylib\"\n#elif LJ_TARGET_CYGWIN\n#define CLIB_SOEXT\t\"%s.dll\"\n#else\n#define CLIB_SOEXT\t\"%s.so\"\n#endif\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (!strchr(name, '/')\n#if LJ_TARGET_CYGWIN\n      && !strchr(name, '\\\\')\n#endif\n     ) {\n    if (!strchr(name, '.')) {\n      name = lj_strfmt_pushf(L, CLIB_SOEXT, name);\n      L->top--;\n#if LJ_TARGET_CYGWIN\n    } else {\n      return name;\n#endif\n    }\n    if (!(name[0] == CLIB_SOPREFIX[0] && name[1] == CLIB_SOPREFIX[1] &&\n\t  name[2] == CLIB_SOPREFIX[2])) {\n      name = lj_strfmt_pushf(L, CLIB_SOPREFIX \"%s\", name);\n      L->top--;\n    }\n  }\n  return name;\n}\n\n/* Check for a recognized ld script line. */\nstatic const char *clib_check_lds(lua_State *L, const char *buf)\n{\n  char *p, *e;\n  if ((!strncmp(buf, \"GROUP\", 5) || !strncmp(buf, \"INPUT\", 5)) &&\n      (p = strchr(buf, '('))) {\n    while (*++p == ' ') ;\n    for (e = p; *e && *e != ' ' && *e != ')'; e++) ;\n    return strdata(lj_str_new(L, p, e-p));\n  }\n  return NULL;\n}\n\n/* Quick and dirty solution to resolve shared library name from ld script. */\nstatic const char *clib_resolve_lds(lua_State *L, const char *name)\n{\n  FILE *fp = fopen(name, \"r\");\n  const char *p = NULL;\n  if (fp) {\n    char buf[256];\n    if (fgets(buf, sizeof(buf), fp)) {\n      if (!strncmp(buf, \"/* GNU ld script\", 16)) {  /* ld script magic? */\n\twhile (fgets(buf, sizeof(buf), fp)) {  /* Check all lines. */\n\t  p = clib_check_lds(L, buf);\n\t  if (p) break;\n\t}\n      } else {  /* Otherwise check only the first line. */\n\tp = clib_check_lds(L, buf);\n      }\n    }\n    fclose(fp);\n  }\n  return p;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  void *h = dlopen(clib_extname(L, name),\n\t\t   RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n  if (!h) {\n    const char *e, *err = dlerror();\n    if (*err == '/' && (e = strchr(err, ':')) &&\n\t(name = clib_resolve_lds(L, strdata(lj_str_new(L, err, e-err))))) {\n      h = dlopen(name, RTLD_LAZY | (global?RTLD_GLOBAL:RTLD_LOCAL));\n      if (h) return h;\n      err = dlerror();\n    }\n    lj_err_callermsg(L, err);\n  }\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle && cl->handle != CLIB_DEFHANDLE)\n    dlclose(cl->handle);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = dlsym(cl->handle, name);\n  return p;\n}\n\n#elif LJ_TARGET_WINDOWS\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\t4\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT\t2\nBOOL WINAPI GetModuleHandleExA(DWORD, LPCSTR, HMODULE*);\n#endif\n\n#define CLIB_DEFHANDLE\t((void *)-1)\n\n/* Default libraries. */\nenum {\n  CLIB_HANDLE_EXE,\n  CLIB_HANDLE_DLL,\n  CLIB_HANDLE_CRT,\n  CLIB_HANDLE_KERNEL32,\n  CLIB_HANDLE_USER32,\n  CLIB_HANDLE_GDI32,\n  CLIB_HANDLE_MAX\n};\n\nstatic void *clib_def_handle[CLIB_HANDLE_MAX];\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  DWORD err = GetLastError();\n#if LJ_TARGET_XBOXONE\n  wchar_t wbuf[128];\n  char buf[128*2];\n  if (!FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, err, 0, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL) ||\n      !WideCharToMultiByte(CP_ACP, 0, wbuf, 128, buf, 128*2, NULL, NULL))\n#else\n  char buf[128];\n  if (!FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t      NULL, err, 0, buf, sizeof(buf), NULL))\n#endif\n    buf[0] = '\\0';\n  lj_err_callermsg(L, lj_strfmt_pushf(L, fmt, name, buf));\n}\n\nstatic int clib_needext(const char *s)\n{\n  while (*s) {\n    if (*s == '/' || *s == '\\\\' || *s == '.') return 0;\n    s++;\n  }\n  return 1;\n}\n\nstatic const char *clib_extname(lua_State *L, const char *name)\n{\n  if (clib_needext(name)) {\n    name = lj_strfmt_pushf(L, \"%s.dll\", name);\n    L->top--;\n  }\n  return name;\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  DWORD oldwerr = GetLastError();\n  void *h = (void *)LoadLibraryExA(clib_extname(L, name), NULL, 0);\n  if (!h) clib_error(L, \"cannot load module \" LUA_QS \": %s\", name);\n  SetLastError(oldwerr);\n  UNUSED(global);\n  return h;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  if (cl->handle == CLIB_DEFHANDLE) {\n    MSize i;\n    for (i = CLIB_HANDLE_KERNEL32; i < CLIB_HANDLE_MAX; i++) {\n      void *h = clib_def_handle[i];\n      if (h) {\n\tclib_def_handle[i] = NULL;\n\tFreeLibrary((HINSTANCE)h);\n      }\n    }\n  } else if (cl->handle) {\n    FreeLibrary((HINSTANCE)cl->handle);\n  }\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  void *p = NULL;\n  if (cl->handle == CLIB_DEFHANDLE) {  /* Search default libraries. */\n    MSize i;\n    for (i = 0; i < CLIB_HANDLE_MAX; i++) {\n      HINSTANCE h = (HINSTANCE)clib_def_handle[i];\n      if (!(void *)h) {  /* Resolve default library handles (once). */\n\tswitch (i) {\n\tcase CLIB_HANDLE_EXE: GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, NULL, &h); break;\n\tcase CLIB_HANDLE_DLL:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)clib_def_handle, &h);\n\t  break;\n\tcase CLIB_HANDLE_CRT:\n\t  GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS|GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\t\t\t     (const char *)&_fmode, &h);\n\t  break;\n\tcase CLIB_HANDLE_KERNEL32: h = LoadLibraryExA(\"kernel32.dll\", NULL, 0); break;\n\tcase CLIB_HANDLE_USER32: h = LoadLibraryExA(\"user32.dll\", NULL, 0); break;\n\tcase CLIB_HANDLE_GDI32: h = LoadLibraryExA(\"gdi32.dll\", NULL, 0); break;\n\t}\n\tif (!h) continue;\n\tclib_def_handle[i] = (void *)h;\n      }\n      p = (void *)GetProcAddress(h, name);\n      if (p) break;\n    }\n  } else {\n    p = (void *)GetProcAddress((HINSTANCE)cl->handle, name);\n  }\n  return p;\n}\n\n#else\n\n#define CLIB_DEFHANDLE\tNULL\n\nLJ_NORET LJ_NOINLINE static void clib_error(lua_State *L, const char *fmt,\n\t\t\t\t\t    const char *name)\n{\n  lj_err_callermsg(L, lj_strfmt_pushf(L, fmt, name, \"no support for this OS\"));\n}\n\nstatic void *clib_loadlib(lua_State *L, const char *name, int global)\n{\n  lj_err_callermsg(L, \"no support for loading dynamic libraries for this OS\");\n  UNUSED(name); UNUSED(global);\n  return NULL;\n}\n\nstatic void clib_unloadlib(CLibrary *cl)\n{\n  UNUSED(cl);\n}\n\nstatic void *clib_getsym(CLibrary *cl, const char *name)\n{\n  UNUSED(cl); UNUSED(name);\n  return NULL;\n}\n\n#endif\n\n/* -- C library indexing -------------------------------------------------- */\n\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n/* Compute argument size for fastcall/stdcall functions. */\nstatic CTSize clib_func_argsize(CTState *cts, CType *ct)\n{\n  CTSize n = 0;\n  while (ct->sib) {\n    CType *d;\n    ct = ctype_get(cts, ct->sib);\n    if (ctype_isfield(ct->info)) {\n      d = ctype_rawchild(cts, ct);\n      n += ((d->size + 3) & ~3);\n    }\n  }\n  return n;\n}\n#endif\n\n/* Get redirected or mangled external symbol. */\nstatic const char *clib_extsym(CTState *cts, CType *ct, GCstr *name)\n{\n  if (ct->sib) {\n    CType *ctf = ctype_get(cts, ct->sib);\n    if (ctype_isxattrib(ctf->info, CTA_REDIR))\n      return strdata(gco2str(gcref(ctf->name)));\n  }\n  return strdata(name);\n}\n\n/* Index a C library by name. */\nTValue *lj_clib_index(lua_State *L, CLibrary *cl, GCstr *name)\n{\n  TValue *tv = lj_tab_setstr(L, cl->cache, name);\n  if (LJ_UNLIKELY(tvisnil(tv))) {\n    CTState *cts = ctype_cts(L);\n    CType *ct;\n    CTypeID id = lj_ctype_getname(cts, &ct, name, CLNS_INDEX);\n    if (!id)\n      lj_err_callerv(L, LJ_ERR_FFI_NODECL, strdata(name));\n    if (ctype_isconstval(ct->info)) {\n      CType *ctt = ctype_child(cts, ct);\n      lua_assert(ctype_isinteger(ctt->info) && ctt->size <= 4);\n      if ((ctt->info & CTF_UNSIGNED) && (int32_t)ct->size < 0)\n\tsetnumV(tv, (lua_Number)(uint32_t)ct->size);\n      else\n\tsetintV(tv, (int32_t)ct->size);\n    } else {\n      const char *sym = clib_extsym(cts, ct, name);\n#if LJ_TARGET_WINDOWS\n      DWORD oldwerr = GetLastError();\n#endif\n      void *p = clib_getsym(cl, sym);\n      GCcdata *cd;\n      lua_assert(ctype_isfunc(ct->info) || ctype_isextern(ct->info));\n#if LJ_TARGET_X86 && LJ_ABI_WIN\n      /* Retry with decorated name for fastcall/stdcall functions. */\n      if (!p && ctype_isfunc(ct->info)) {\n\tCTInfo cconv = ctype_cconv(ct->info);\n\tif (cconv == CTCC_FASTCALL || cconv == CTCC_STDCALL) {\n\t  CTSize sz = clib_func_argsize(cts, ct);\n\t  const char *symd = lj_strfmt_pushf(L,\n\t\t\t       cconv == CTCC_FASTCALL ? \"@%s@%d\" : \"_%s@%d\",\n\t\t\t       sym, sz);\n\t  L->top--;\n\t  p = clib_getsym(cl, symd);\n\t}\n      }\n#endif\n      if (!p)\n\tclib_error(L, \"cannot resolve symbol \" LUA_QS \": %s\", sym);\n#if LJ_TARGET_WINDOWS\n      SetLastError(oldwerr);\n#endif\n      cd = lj_cdata_new(cts, id, CTSIZE_PTR);\n      *(void **)cdataptr(cd) = p;\n      setcdataV(L, tv, cd);\n    }\n  }\n  return tv;\n}\n\n/* -- C library management ------------------------------------------------ */\n\n/* Create a new CLibrary object and push it on the stack. */\nstatic CLibrary *clib_new(lua_State *L, GCtab *mt)\n{\n  GCtab *t = lj_tab_new(L, 0, 0);\n  GCudata *ud = lj_udata_new(L, sizeof(CLibrary), t);\n  CLibrary *cl = (CLibrary *)uddata(ud);\n  cl->cache = t;\n  ud->udtype = UDTYPE_FFI_CLIB;\n  /* NOBARRIER: The GCudata is new (marked white). */\n  setgcref(ud->metatable, obj2gco(mt));\n  setudataV(L, L->top++, ud);\n  return cl;\n}\n\n/* Load a C library. */\nvoid lj_clib_load(lua_State *L, GCtab *mt, GCstr *name, int global)\n{\n  void *handle = clib_loadlib(L, strdata(name), global);\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = handle;\n}\n\n/* Unload a C library. */\nvoid lj_clib_unload(CLibrary *cl)\n{\n  clib_unloadlib(cl);\n  cl->handle = NULL;\n}\n\n/* Create the default C library object. */\nvoid lj_clib_default(lua_State *L, GCtab *mt)\n{\n  CLibrary *cl = clib_new(L, mt);\n  cl->handle = CLIB_DEFHANDLE;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-sysbench-1.0.19-gikkqs7jdja4opskyaz2kgg5fvxf5cus/spack-src/m4/lib-link.m4": "# lib-link.m4 serial 13 (gettext-0.17)\ndnl Copyright (C) 2001-2007 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ(2.54)\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n    ac_cv_lib[]Name[]_prefix=\"$LIB[]NAME[]_PREFIX\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  LIB[]NAME[]_PREFIX=\"$ac_cv_lib[]Name[]_prefix\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. If found, it\ndnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and\ndnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $LIB[]NAME\"\n    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n    LIB[]NAME[]_PREFIX=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl   acl_libext,\ndnl   acl_shlibext,\ndnl   acl_hardcode_libdir_flag_spec,\ndnl   acl_hardcode_libdir_separator,\ndnl   acl_hardcode_direct,\ndnl   acl_hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  acl_libext=\"$acl_cv_libext\"\n  acl_shlibext=\"$acl_cv_shlibext\"\n  acl_libname_spec=\"$acl_cv_libname_spec\"\n  acl_library_names_spec=\"$acl_cv_library_names_spec\"\n  acl_hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  acl_hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  acl_hardcode_direct=\"$acl_cv_hardcode_direct\"\n  acl_hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE(rpath,\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\ndnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found\ndnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  dnl Autoconf >= 2.61 supports dots in --with options.\n  define([N_A_M_E],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit([$1],[.],[_])],[$1])])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib]N_A_M_E[-prefix],\n[  --with-lib]N_A_M_E[-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib\n  --without-lib]N_A_M_E[-prefix     don't search for lib$1 in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  LIB[]NAME[]_PREFIX=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          eval libname=\\\"$acl_libname_spec\\\"    # typically: libname=lib$name\n          if test -n \"$acl_shlibext\"; then\n            shrext=\".$acl_shlibext\"             # typically: shrext=.so\n          else\n            shrext=\n          fi\n          if test $use_additional = yes; then\n            dir=\"$additional_libdir\"\n            dnl The same code as in the loop below:\n            dnl First look for a shared library.\n            if test -n \"$acl_shlibext\"; then\n              if test -f \"$dir/$libname$shrext\"; then\n                found_dir=\"$dir\"\n                found_so=\"$dir/$libname$shrext\"\n              else\n                if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                  ver=`(cd \"$dir\" && \\\n                        for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                        | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                        | sed 1q ) 2>/dev/null`\n                  if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/$libname$shrext.$ver\"\n                  fi\n                else\n                  eval library_names=\\\"$acl_library_names_spec\\\"\n                  for f in $library_names; do\n                    if test -f \"$dir/$f\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$f\"\n                      break\n                    fi\n                  done\n                fi\n              fi\n            fi\n            dnl Then look for a static library.\n            if test \"X$found_dir\" = \"X\"; then\n              if test -f \"$dir/$libname.$acl_libext\"; then\n                found_dir=\"$dir\"\n                found_a=\"$dir/$libname.$acl_libext\"\n              fi\n            fi\n            if test \"X$found_dir\" != \"X\"; then\n              if test -f \"$dir/$libname.la\"; then\n                found_la=\"$dir/$libname.la\"\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  dnl First look for a shared library.\n                  if test -n \"$acl_shlibext\"; then\n                    if test -f \"$dir/$libname$shrext\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$libname$shrext\"\n                    else\n                      if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                        ver=`(cd \"$dir\" && \\\n                              for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                              | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                              | sed 1q ) 2>/dev/null`\n                        if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                          found_dir=\"$dir\"\n                          found_so=\"$dir/$libname$shrext.$ver\"\n                        fi\n                      else\n                        eval library_names=\\\"$acl_library_names_spec\\\"\n                        for f in $library_names; do\n                          if test -f \"$dir/$f\"; then\n                            found_dir=\"$dir\"\n                            found_so=\"$dir/$f\"\n                            break\n                          fi\n                        done\n                      fi\n                    fi\n                  fi\n                  dnl Then look for a static library.\n                  if test \"X$found_dir\" = \"X\"; then\n                    if test -f \"$dir/$libname.$acl_libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/$libname.$acl_libext\"\n                    fi\n                  fi\n                  if test \"X$found_dir\" != \"X\"; then\n                    if test -f \"$dir/$libname.la\"; then\n                      found_la=\"$dir/$libname.la\"\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$acl_hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$acl_hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                LIB[]NAME[]_PREFIX=\"$basedir\"\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$acl_hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$acl_hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-sysbench-1.0.19-gikkqs7jdja4opskyaz2kgg5fvxf5cus/spack-src/third_party/luajit/luajit/doc/img/contact.png"
    ],
    "total_files": 714
}