{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/libibverbs/dynamic_driver.c": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2018 Mellanox Technologies, Ltd.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#ifndef _STATIC_LIBRARY_BUILD_\n#define _GNU_SOURCE\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <ccan/list.h>\n\n#include \"ibverbs.h\"\n\nstruct ibv_driver_name {\n\tstruct list_node entry;\n\tchar *name;\n};\n\nstatic LIST_HEAD(driver_name_list);\n\nstatic void read_config_file(const char *path)\n{\n\tFILE *conf;\n\tchar *line = NULL;\n\tchar *config;\n\tchar *field;\n\tsize_t buflen = 0;\n\tssize_t len;\n\n\tconf = fopen(path, \"r\" STREAM_CLOEXEC);\n\tif (!conf) {\n\t\tfprintf(stderr, PFX \"Warning: couldn't read config file %s.\\n\",\n\t\t\tpath);\n\t\treturn;\n\t}\n\n\twhile ((len = getline(&line, &buflen, conf)) != -1) {\n\t\tconfig = line + strspn(line, \"\\t \");\n\t\tif (config[0] == '\\n' || config[0] == '#')\n\t\t\tcontinue;\n\n\t\tfield = strsep(&config, \"\\n\\t \");\n\n\t\tif (strcmp(field, \"driver\") == 0 && config != NULL) {\n\t\t\tstruct ibv_driver_name *driver_name;\n\n\t\t\tconfig += strspn(config, \"\\t \");\n\t\t\tfield = strsep(&config, \"\\n\\t \");\n\n\t\t\tdriver_name = malloc(sizeof(*driver_name));\n\t\t\tif (!driver_name) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\tPFX\n\t\t\t\t\t\"Warning: couldn't allocate driver name '%s'.\\n\",\n\t\t\t\t\tfield);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdriver_name->name = strdup(field);\n\t\t\tif (!driver_name->name) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\tPFX\n\t\t\t\t\t\"Warning: couldn't allocate driver name '%s'.\\n\",\n\t\t\t\t\tfield);\n\t\t\t\tfree(driver_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist_add(&driver_name_list, &driver_name->entry);\n\t\t} else\n\t\t\tfprintf(stderr,\n\t\t\t\tPFX\n\t\t\t\t\"Warning: ignoring bad config directive '%s' in file '%s'.\\n\",\n\t\t\t\tfield, path);\n\t}\n\n\tif (line)\n\t\tfree(line);\n\tfclose(conf);\n}\n\nstatic void read_config(void)\n{\n\tDIR *conf_dir;\n\tstruct dirent *dent;\n\tchar *path;\n\n\tconf_dir = opendir(IBV_CONFIG_DIR);\n\tif (!conf_dir) {\n\t\tfprintf(stderr,\n\t\t\tPFX \"Warning: couldn't open config directory '%s'.\\n\",\n\t\t\tIBV_CONFIG_DIR);\n\t\treturn;\n\t}\n\n\twhile ((dent = readdir(conf_dir))) {\n\t\tstruct stat buf;\n\n\t\tif (asprintf(&path, \"%s/%s\", IBV_CONFIG_DIR, dent->d_name) <\n\t\t    0) {\n\t\t\tfprintf(stderr,\n\t\t\t\tPFX\n\t\t\t\t\"Warning: couldn't read config file %s/%s.\\n\",\n\t\t\t\tIBV_CONFIG_DIR, dent->d_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stat(path, &buf)) {\n\t\t\tfprintf(stderr,\n\t\t\t\tPFX\n\t\t\t\t\"Warning: couldn't stat config file '%s'.\\n\",\n\t\t\t\tpath);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISREG(buf.st_mode))\n\t\t\tgoto next;\n\n\t\tread_config_file(path);\nnext:\n\t\tfree(path);\n\t}\n\nout:\n\tclosedir(conf_dir);\n}\n\nstatic void load_driver(const char *name)\n{\n\tchar *so_name;\n\tvoid *dlhandle;\n\n\t/* If the name is an absolute path then open that path after appending\n\t * the trailer suffix\n\t */\n\tif (name[0] == '/') {\n\t\tif (asprintf(&so_name, \"%s\" VERBS_PROVIDER_SUFFIX, name) < 0)\n\t\t\tgoto out_asprintf;\n\t\tdlhandle = dlopen(so_name, RTLD_NOW);\n\t\tif (!dlhandle)\n\t\t\tgoto out_dlopen;\n\t\tfree(so_name);\n\t\treturn;\n\t}\n\n\t/* If configured with a provider plugin path then try that next */\n\tif (sizeof(VERBS_PROVIDER_DIR) > 1) {\n\t\tif (asprintf(&so_name,\n\t\t\t     VERBS_PROVIDER_DIR \"/lib%s\" VERBS_PROVIDER_SUFFIX,\n\t\t\t     name) < 0)\n\t\t\tgoto out_asprintf;\n\t\tdlhandle = dlopen(so_name, RTLD_NOW);\n\t\tfree(so_name);\n\t\tif (dlhandle)\n\t\t\treturn;\n\t}\n\n\t/* Otherwise use the system library search path. This is the historical\n\t * behavior of libibverbs\n\t */\n\tif (asprintf(&so_name, \"lib%s\" VERBS_PROVIDER_SUFFIX, name) < 0)\n\t\tgoto out_asprintf;\n\tdlhandle = dlopen(so_name, RTLD_NOW);\n\tif (!dlhandle)\n\t\tgoto out_dlopen;\n\tfree(so_name);\n\treturn;\n\nout_asprintf:\n\tfprintf(stderr, PFX \"Warning: couldn't load driver '%s'.\\n\", name);\n\treturn;\nout_dlopen:\n\tfprintf(stderr, PFX \"Warning: couldn't load driver '%s': %s\\n\", so_name,\n\t\tdlerror());\n\tfree(so_name);\n}\n\nvoid load_drivers(void)\n{\n\tstruct ibv_driver_name *name, *next_name;\n\tconst char *env;\n\tchar *list, *env_name;\n\n\tread_config();\n\n\t/* Only use drivers passed in through the calling user's environment\n\t * if we're not running setuid.\n\t */\n\tif (getuid() == geteuid()) {\n\t\tif ((env = getenv(\"RDMAV_DRIVERS\"))) {\n\t\t\tlist = strdupa(env);\n\t\t\twhile ((env_name = strsep(&list, \":;\")))\n\t\t\t\tload_driver(env_name);\n\t\t} else if ((env = getenv(\"IBV_DRIVERS\"))) {\n\t\t\tlist = strdupa(env);\n\t\t\twhile ((env_name = strsep(&list, \":;\")))\n\t\t\t\tload_driver(env_name);\n\t\t}\n\t}\n\n\tlist_for_each_safe (&driver_name_list, name, next_name, entry) {\n\t\tload_driver(name->name);\n\t\tfree(name->name);\n\t\tfree(name);\n\t}\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/libibverbs/driver.h": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2005, 2006 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2005 PathScale, Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifndef INFINIBAND_DRIVER_H\n#define INFINIBAND_DRIVER_H\n\n#include <stdatomic.h>\n#include <infiniband/verbs.h>\n#include <infiniband/kern-abi.h>\n#include <infiniband/cmd_ioctl.h>\n#include <ccan/list.h>\n#include <config.h>\n#include <stdbool.h>\n#include <rdma/rdma_user_ioctl_cmds.h>\n#include <infiniband/cmd_ioctl.h>\n#include <sys/types.h>\n\nstruct verbs_device;\n\nenum verbs_xrcd_mask {\n\tVERBS_XRCD_HANDLE\t= 1 << 0,\n\tVERBS_XRCD_RESERVED\t= 1 << 1\n};\n\nstruct verbs_xrcd {\n\tstruct ibv_xrcd\t\txrcd;\n\tuint32_t\t\tcomp_mask;\n\tuint32_t\t\thandle;\n};\n\nstruct verbs_srq {\n\tstruct ibv_srq\t\tsrq;\n\tenum ibv_srq_type\tsrq_type;\n\tstruct verbs_xrcd      *xrcd;\n\tstruct ibv_cq\t       *cq;\n\tuint32_t\t\tsrq_num;\n};\n\nenum verbs_qp_mask {\n\tVERBS_QP_XRCD\t\t= 1 << 0,\n\tVERBS_QP_EX\t\t= 1 << 1,\n};\n\nenum ibv_gid_type_sysfs {\n\tIBV_GID_TYPE_SYSFS_IB_ROCE_V1,\n\tIBV_GID_TYPE_SYSFS_ROCE_V2,\n};\n\nenum verbs_query_gid_attr_mask {\n\tVERBS_QUERY_GID_ATTR_GID\t\t= 1 << 0,\n\tVERBS_QUERY_GID_ATTR_TYPE\t\t= 1 << 1,\n\tVERBS_QUERY_GID_ATTR_NDEV_IFINDEX\t= 1 << 2,\n};\n\nenum ibv_mr_type {\n\tIBV_MR_TYPE_MR,\n\tIBV_MR_TYPE_NULL_MR,\n\tIBV_MR_TYPE_IMPORTED_MR,\n};\n\nstruct verbs_mr {\n\tstruct ibv_mr\t\tibv_mr;\n\tenum ibv_mr_type        mr_type;\n\tint access;\n};\n\nstatic inline struct verbs_mr *verbs_get_mr(struct ibv_mr *mr)\n{\n\treturn container_of(mr, struct verbs_mr, ibv_mr);\n}\n\nstruct verbs_qp {\n\tunion {\n\t\tstruct ibv_qp qp;\n\t\tstruct ibv_qp_ex qp_ex;\n\t};\n\tuint32_t\t\tcomp_mask;\n\tstruct verbs_xrcd       *xrcd;\n};\nstatic_assert(offsetof(struct ibv_qp_ex, qp_base) == 0, \"Invalid qp layout\");\n\nstruct verbs_cq {\n\tunion {\n\t\tstruct ibv_cq cq;\n\t\tstruct ibv_cq_ex cq_ex;\n\t};\n};\n\nenum ibv_flow_action_type {\n\tIBV_FLOW_ACTION_UNSPECIFIED,\n\tIBV_FLOW_ACTION_ESP = 1,\n};\n\nstruct verbs_flow_action {\n\tstruct ibv_flow_action\t\taction;\n\tuint32_t\t\t\thandle;\n\tenum ibv_flow_action_type\ttype;\n};\n\nstruct verbs_dm {\n\tstruct ibv_dm\t\tdm;\n\tuint32_t\t\thandle;\n};\n\nenum {\n\tVERBS_MATCH_SENTINEL = 0,\n\tVERBS_MATCH_PCI = 1,\n\tVERBS_MATCH_MODALIAS = 2,\n\tVERBS_MATCH_DRIVER_ID = 3,\n};\n\nstruct verbs_match_ent {\n\tvoid *driver_data;\n\tunion {\n\t\tconst char *modalias;\n\t\tuint64_t driver_id;\n\t} u;\n\tuint16_t vendor;\n\tuint16_t device;\n\tuint8_t kind;\n};\n#define VERBS_DRIVER_ID(_id)                                                   \\\n\t{                                                                      \\\n\t\t.u.driver_id = (_id), .kind = VERBS_MATCH_DRIVER_ID,           \\\n\t}\n/* Note: New drivers should only use VERBS_DRIVER_ID, the below are for legacy\n * drivers\n */\n#define VERBS_PCI_MATCH(_vendor, _device, _data)\t\t\t\\\n\t{                                                                      \\\n\t    .driver_data = (void *)(_data),\t\t\t\t       \\\n\t    .vendor = (_vendor),                                               \\\n\t    .device = (_device),                                               \\\n\t    .kind = VERBS_MATCH_PCI,                                           \\\n\t}\n\n#define VERBS_MODALIAS_MATCH(_mod_str, _data)                                  \\\n\t{                                                                      \\\n\t    .driver_data = (void *)(_data),\t\t\t               \\\n\t    .u.modalias = (_mod_str),                                          \\\n\t    .kind = VERBS_MATCH_MODALIAS,                                      \\\n\t}\n\n/* Matching on the IB device name is STRONGLY discouraged. This will only\n * match if there is no device/modalias file available, and it will eventually\n * be disabled entirely if the kernel supports renaming. Use is strongly\n * discouraged.\n */\n#define VERBS_NAME_MATCH(_name_prefix, _data)                                  \\\n\t{                                                                      \\\n\t    .driver_data = (_data),                                            \\\n\t    .u.modalias = \"rdma_device:*N\" _name_prefix \"*\",                   \\\n\t    .kind = VERBS_MATCH_MODALIAS,                                      \\\n\t}\n\nenum {\n\tVSYSFS_READ_MODALIAS = 1 << 0,\n\tVSYSFS_READ_NODE_GUID = 1 << 1,\n\tVSYSFS_READ_FW_VER = 1 << 2,\n};\n\n/* A rdma device detected in sysfs */\nstruct verbs_sysfs_dev {\n\tstruct list_node entry;\n\tvoid *provider_data;\n\tconst struct verbs_match_ent *match;\n\tunsigned int flags;\n\tchar sysfs_name[IBV_SYSFS_NAME_MAX];\n\tdev_t sysfs_cdev;\n\tchar ibdev_name[IBV_SYSFS_NAME_MAX];\n\tchar ibdev_path[IBV_SYSFS_PATH_MAX];\n\tchar modalias[512];\n\tchar fw_ver[64];\n\tuint64_t node_guid;\n\tuint32_t driver_id;\n\tenum ibv_node_type node_type;\n\tint ibdev_idx;\n\tuint32_t abi_ver;\n\tstruct timespec time_created;\n};\n\n/* Must change the PRIVATE IBVERBS_PRIVATE_ symbol if this is changed */\nstruct verbs_device_ops {\n\tconst char *name;\n\n\tuint32_t match_min_abi_version;\n\tuint32_t match_max_abi_version;\n\tconst struct verbs_match_ent *match_table;\n\tconst struct verbs_device_ops **static_providers;\n\n\tbool (*match_device)(struct verbs_sysfs_dev *sysfs_dev);\n\n\tstruct verbs_context *(*alloc_context)(struct ibv_device *device,\n\t\t\t\t\t       int cmd_fd,\n\t\t\t\t\t       void *private_data);\n\tstruct verbs_context *(*import_context)(struct ibv_device *device,\n\t\t\t\t\t\tint cmd_fd);\n\n\tstruct verbs_device *(*alloc_device)(struct verbs_sysfs_dev *sysfs_dev);\n\tvoid (*uninit_device)(struct verbs_device *device);\n};\n\n/* Must change the PRIVATE IBVERBS_PRIVATE_ symbol if this is changed */\nstruct verbs_device {\n\tstruct ibv_device device; /* Must be first */\n\tconst struct verbs_device_ops *ops;\n\tatomic_int refcount;\n\tstruct list_node entry;\n\tstruct verbs_sysfs_dev *sysfs;\n\tuint64_t core_support;\n};\n\nstruct verbs_counters {\n\tstruct ibv_counters counters;\n\tuint32_t handle;\n};\n\n/*\n * Must change the PRIVATE IBVERBS_PRIVATE_ symbol if this is changed. This is\n * the union of every op the driver can support. If new elements are added to\n * this structure then verbs_dummy_ops must also be updated.\n *\n * Keep sorted.\n */\nstruct verbs_context_ops {\n\tint (*advise_mr)(struct ibv_pd *pd,\n\t\t\t enum ibv_advise_mr_advice advice,\n\t\t\t uint32_t flags,\n\t\t\t struct ibv_sge *sg_list,\n\t\t\t uint32_t num_sges);\n\tstruct ibv_dm *(*alloc_dm)(struct ibv_context *context,\n\t\t\t\t   struct ibv_alloc_dm_attr *attr);\n\tstruct ibv_mw *(*alloc_mw)(struct ibv_pd *pd, enum ibv_mw_type type);\n\tstruct ibv_mr *(*alloc_null_mr)(struct ibv_pd *pd);\n\tstruct ibv_pd *(*alloc_parent_domain)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_parent_domain_init_attr *attr);\n\tstruct ibv_pd *(*alloc_pd)(struct ibv_context *context);\n\tstruct ibv_td *(*alloc_td)(struct ibv_context *context,\n\t\t\t\t   struct ibv_td_init_attr *init_attr);\n\tvoid (*async_event)(struct ibv_context *context, struct ibv_async_event *event);\n\tint (*attach_counters_point_flow)(struct ibv_counters *counters,\n\t\t\t\t\t  struct ibv_counter_attach_attr *attr,\n\t\t\t\t\t  struct ibv_flow *flow);\n\tint (*attach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,\n\t\t\t    uint16_t lid);\n\tint (*bind_mw)(struct ibv_qp *qp, struct ibv_mw *mw,\n\t\t       struct ibv_mw_bind *mw_bind);\n\tint (*close_xrcd)(struct ibv_xrcd *xrcd);\n\tvoid (*cq_event)(struct ibv_cq *cq);\n\tstruct ibv_ah *(*create_ah)(struct ibv_pd *pd,\n\t\t\t\t    struct ibv_ah_attr *attr);\n\tstruct ibv_counters *(*create_counters)(struct ibv_context *context,\n\t\t\t\t\t\tstruct ibv_counters_init_attr *init_attr);\n\tstruct ibv_cq *(*create_cq)(struct ibv_context *context, int cqe,\n\t\t\t\t    struct ibv_comp_channel *channel,\n\t\t\t\t    int comp_vector);\n\tstruct ibv_cq_ex *(*create_cq_ex)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_cq_init_attr_ex *init_attr);\n\tstruct ibv_flow *(*create_flow)(struct ibv_qp *qp,\n\t\t\t\t\tstruct ibv_flow_attr *flow_attr);\n\tstruct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *context,\n\t\t\t\t\t\t\t  struct ibv_flow_action_esp_attr *attr);\n\tstruct ibv_qp *(*create_qp)(struct ibv_pd *pd,\n\t\t\t\t    struct ibv_qp_init_attr *attr);\n\tstruct ibv_qp *(*create_qp_ex)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_qp_init_attr_ex *qp_init_attr_ex);\n\tstruct ibv_rwq_ind_table *(*create_rwq_ind_table)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_rwq_ind_table_init_attr *init_attr);\n\tstruct ibv_srq *(*create_srq)(struct ibv_pd *pd,\n\t\t\t\t      struct ibv_srq_init_attr *srq_init_attr);\n\tstruct ibv_srq *(*create_srq_ex)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_srq_init_attr_ex *srq_init_attr_ex);\n\tstruct ibv_wq *(*create_wq)(struct ibv_context *context,\n\t\t\t\t    struct ibv_wq_init_attr *wq_init_attr);\n\tint (*dealloc_mw)(struct ibv_mw *mw);\n\tint (*dealloc_pd)(struct ibv_pd *pd);\n\tint (*dealloc_td)(struct ibv_td *td);\n\tint (*dereg_mr)(struct verbs_mr *vmr);\n\tint (*destroy_ah)(struct ibv_ah *ah);\n\tint (*destroy_counters)(struct ibv_counters *counters);\n\tint (*destroy_cq)(struct ibv_cq *cq);\n\tint (*destroy_flow)(struct ibv_flow *flow);\n\tint (*destroy_flow_action)(struct ibv_flow_action *action);\n\tint (*destroy_qp)(struct ibv_qp *qp);\n\tint (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *rwq_ind_table);\n\tint (*destroy_srq)(struct ibv_srq *srq);\n\tint (*destroy_wq)(struct ibv_wq *wq);\n\tint (*detach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,\n\t\t\t    uint16_t lid);\n\tvoid (*free_context)(struct ibv_context *context);\n\tint (*free_dm)(struct ibv_dm *dm);\n\tint (*get_srq_num)(struct ibv_srq *srq, uint32_t *srq_num);\n\tstruct ibv_mr *(*import_mr)(struct ibv_pd *pd,\n\t\t\t\t    uint32_t mr_handle);\n\tstruct ibv_pd *(*import_pd)(struct ibv_context *context,\n\t\t\t\t    uint32_t pd_handle);\n\tint (*modify_cq)(struct ibv_cq *cq, struct ibv_modify_cq_attr *attr);\n\tint (*modify_flow_action_esp)(struct ibv_flow_action *action,\n\t\t\t\t      struct ibv_flow_action_esp_attr *attr);\n\tint (*modify_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n\t\t\t int attr_mask);\n\tint (*modify_qp_rate_limit)(struct ibv_qp *qp,\n\t\t\t\t    struct ibv_qp_rate_limit_attr *attr);\n\tint (*modify_srq)(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr,\n\t\t\t  int srq_attr_mask);\n\tint (*modify_wq)(struct ibv_wq *wq, struct ibv_wq_attr *wq_attr);\n\tstruct ibv_qp *(*open_qp)(struct ibv_context *context,\n\t\t\t\t  struct ibv_qp_open_attr *attr);\n\tstruct ibv_xrcd *(*open_xrcd)(\n\t\tstruct ibv_context *context,\n\t\tstruct ibv_xrcd_init_attr *xrcd_init_attr);\n\tint (*poll_cq)(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc);\n\tint (*post_recv)(struct ibv_qp *qp, struct ibv_recv_wr *wr,\n\t\t\t struct ibv_recv_wr **bad_wr);\n\tint (*post_send)(struct ibv_qp *qp, struct ibv_send_wr *wr,\n\t\t\t struct ibv_send_wr **bad_wr);\n\tint (*post_srq_ops)(struct ibv_srq *srq, struct ibv_ops_wr *op,\n\t\t\t    struct ibv_ops_wr **bad_op);\n\tint (*post_srq_recv)(struct ibv_srq *srq, struct ibv_recv_wr *recv_wr,\n\t\t\t     struct ibv_recv_wr **bad_recv_wr);\n\tint (*query_device)(struct ibv_context *context,\n\t\t\t    struct ibv_device_attr *device_attr);\n\tint (*query_device_ex)(struct ibv_context *context,\n\t\t\t       const struct ibv_query_device_ex_input *input,\n\t\t\t       struct ibv_device_attr_ex *attr,\n\t\t\t       size_t attr_size);\n\tint (*query_ece)(struct ibv_qp *qp, struct ibv_ece *ece);\n\tint (*query_port)(struct ibv_context *context, uint8_t port_num,\n\t\t\t  struct ibv_port_attr *port_attr);\n\tint (*query_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n\t\t\tint attr_mask, struct ibv_qp_init_attr *init_attr);\n\tint (*query_rt_values)(struct ibv_context *context,\n\t\t\t       struct ibv_values_ex *values);\n\tint (*query_srq)(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr);\n\tint (*read_counters)(struct ibv_counters *counters,\n\t\t\t     uint64_t *counters_value,\n\t\t\t     uint32_t ncounters,\n\t\t\t     uint32_t flags);\n\tstruct ibv_mr *(*reg_dm_mr)(struct ibv_pd *pd, struct ibv_dm *dm,\n\t\t\t\t    uint64_t dm_offset, size_t length,\n\t\t\t\t    unsigned int access);\n\tstruct ibv_mr *(*reg_mr)(struct ibv_pd *pd, void *addr, size_t length,\n\t\t\t\t uint64_t hca_va, int access);\n\tint (*req_notify_cq)(struct ibv_cq *cq, int solicited_only);\n\tint (*rereg_mr)(struct verbs_mr *vmr, int flags, struct ibv_pd *pd,\n\t\t\tvoid *addr, size_t length, int access);\n\tint (*resize_cq)(struct ibv_cq *cq, int cqe);\n\tint (*set_ece)(struct ibv_qp *qp, struct ibv_ece *ece);\n\tvoid (*unimport_mr)(struct ibv_mr *mr);\n\tvoid (*unimport_pd)(struct ibv_pd *pd);\n};\n\nstatic inline struct verbs_device *\nverbs_get_device(const struct ibv_device *dev)\n{\n\treturn container_of(dev, struct verbs_device, device);\n}\n\ntypedef struct verbs_device *(*verbs_driver_init_func)(const char *uverbs_sys_path,\n\t\t\t\t\t\t       int abi_version);\n\n/* Wire the IBVERBS_PRIVATE version number into the verbs_register_driver\n * symbol name.  This guarentees we link to the correct set of symbols even if\n * statically linking or using a dynmic linker with symbol versioning turned\n * off.\n */\n#define ___make_verbs_register_driver(x) verbs_register_driver_ ## x\n#define __make_verbs_register_driver(x)  ___make_verbs_register_driver(x)\n#define verbs_register_driver __make_verbs_register_driver(IBVERBS_PABI_VERSION)\n\nvoid verbs_register_driver(const struct verbs_device_ops *ops);\n\n/*\n * Macro for providers to use to supply verbs_device_ops to the core code.\n * This creates a global symbol for the provider structure to be used by the\n * ibv_static_providers() machinery, and a global constructor for the dlopen\n * machinery.\n */\n#define PROVIDER_DRIVER(provider_name, drv_struct)                             \\\n\textern const struct verbs_device_ops verbs_provider_##provider_name    \\\n\t\t__attribute__((alias(stringify(drv_struct))));                 \\\n\tstatic __attribute__((constructor)) void drv##__register_driver(void)  \\\n\t{                                                                      \\\n\t\tverbs_register_driver(&drv_struct);                            \\\n\t}\n\nvoid *_verbs_init_and_alloc_context(struct ibv_device *device, int cmd_fd,\n\t\t\t\t    size_t alloc_size,\n\t\t\t\t    struct verbs_context *context_offset,\n\t\t\t\t    uint32_t driver_id);\n\n#define verbs_init_and_alloc_context(ibdev, cmd_fd, drv_ctx_ptr, ctx_memb,     \\\n\t\t\t\t     driver_id)\t\t\t\t       \\\n\t((typeof(drv_ctx_ptr))_verbs_init_and_alloc_context(                   \\\n\t\tibdev, cmd_fd, sizeof(*drv_ctx_ptr),                           \\\n\t\t&((typeof(drv_ctx_ptr))NULL)->ctx_memb, (driver_id)))\n\nint verbs_init_context(struct verbs_context *context_ex,\n\t\t       struct ibv_device *device, int cmd_fd,\n\t\t       uint32_t driver_id);\nvoid verbs_uninit_context(struct verbs_context *context);\nvoid verbs_set_ops(struct verbs_context *vctx,\n\t\t   const struct verbs_context_ops *ops);\n\nvoid verbs_init_cq(struct ibv_cq *cq, struct ibv_context *context,\n\t\t       struct ibv_comp_channel *channel,\n\t\t       void *cq_context);\n\nstruct ibv_context *verbs_open_device(struct ibv_device *device,\n\t\t\t\t      void *private_data);\nint ibv_cmd_get_context(struct verbs_context *context,\n\t\t\tstruct ibv_get_context *cmd, size_t cmd_size,\n\t\t\tstruct ib_uverbs_get_context_resp *resp, size_t resp_size);\nint ibv_cmd_query_context(struct ibv_context *ctx,\n\t\t\t  struct ibv_command_buffer *driver);\nint ibv_cmd_query_device(struct ibv_context *context,\n\t\t\t struct ibv_device_attr *device_attr,\n\t\t\t uint64_t *raw_fw_ver,\n\t\t\t struct ibv_query_device *cmd, size_t cmd_size);\nint ibv_cmd_create_flow_action_esp(struct ibv_context *ctx,\n\t\t\t\t   struct ibv_flow_action_esp_attr *attr,\n\t\t\t\t   struct verbs_flow_action *flow_action,\n\t\t\t\t   struct ibv_command_buffer *driver);\nint ibv_cmd_modify_flow_action_esp(struct verbs_flow_action *flow_action,\n\t\t\t\t   struct ibv_flow_action_esp_attr *attr,\n\t\t\t\t   struct ibv_command_buffer *driver);\nint ibv_cmd_query_device_ex(struct ibv_context *context,\n\t\t\t    const struct ibv_query_device_ex_input *input,\n\t\t\t    struct ibv_device_attr_ex *attr, size_t attr_size,\n\t\t\t    uint64_t *raw_fw_ver,\n\t\t\t    struct ibv_query_device_ex *cmd,\n\t\t\t    size_t cmd_size,\n\t\t\t    struct ib_uverbs_ex_query_device_resp *resp,\n\t\t\t    size_t resp_size);\nint ibv_cmd_query_port(struct ibv_context *context, uint8_t port_num,\n\t\t       struct ibv_port_attr *port_attr,\n\t\t       struct ibv_query_port *cmd, size_t cmd_size);\nint ibv_cmd_alloc_async_fd(struct ibv_context *context);\nint ibv_cmd_alloc_pd(struct ibv_context *context, struct ibv_pd *pd,\n\t\t     struct ibv_alloc_pd *cmd, size_t cmd_size,\n\t\t     struct ib_uverbs_alloc_pd_resp *resp, size_t resp_size);\nint ibv_cmd_dealloc_pd(struct ibv_pd *pd);\nint ibv_cmd_open_xrcd(struct ibv_context *context, struct verbs_xrcd *xrcd,\n\t\t      int vxrcd_size,\n\t\t      struct ibv_xrcd_init_attr *attr,\n\t\t      struct ibv_open_xrcd *cmd, size_t cmd_size,\n\t\t      struct ib_uverbs_open_xrcd_resp *resp, size_t resp_size);\nint ibv_cmd_close_xrcd(struct verbs_xrcd *xrcd);\nint ibv_cmd_reg_mr(struct ibv_pd *pd, void *addr, size_t length,\n\t\t   uint64_t hca_va, int access,\n\t\t   struct verbs_mr *vmr, struct ibv_reg_mr *cmd,\n\t\t   size_t cmd_size,\n\t\t   struct ib_uverbs_reg_mr_resp *resp, size_t resp_size);\nint ibv_cmd_rereg_mr(struct verbs_mr *vmr, uint32_t flags, void *addr,\n\t\t     size_t length, uint64_t hca_va, int access,\n\t\t     struct ibv_pd *pd, struct ibv_rereg_mr *cmd,\n\t\t     size_t cmd_sz, struct ib_uverbs_rereg_mr_resp *resp,\n\t\t     size_t resp_sz);\nint ibv_cmd_dereg_mr(struct verbs_mr *vmr);\nint ibv_cmd_query_mr(struct ibv_pd *pd, struct verbs_mr *vmr,\n\t\t     uint32_t mr_handle);\nint ibv_cmd_advise_mr(struct ibv_pd *pd,\n\t\t      enum ibv_advise_mr_advice advice,\n\t\t      uint32_t flags,\n\t\t      struct ibv_sge *sg_list,\n\t\t      uint32_t num_sge);\nint ibv_cmd_alloc_mw(struct ibv_pd *pd, enum ibv_mw_type type,\n\t\t     struct ibv_mw *mw, struct ibv_alloc_mw *cmd,\n\t\t     size_t cmd_size,\n\t\t     struct ib_uverbs_alloc_mw_resp *resp, size_t resp_size);\nint ibv_cmd_dealloc_mw(struct ibv_mw *mw);\nint ibv_cmd_create_cq(struct ibv_context *context, int cqe,\n\t\t      struct ibv_comp_channel *channel,\n\t\t      int comp_vector, struct ibv_cq *cq,\n\t\t      struct ibv_create_cq *cmd, size_t cmd_size,\n\t\t      struct ib_uverbs_create_cq_resp *resp, size_t resp_size);\nint ibv_cmd_create_cq_ex(struct ibv_context *context,\n\t\t\t struct ibv_cq_init_attr_ex *cq_attr,\n\t\t\t struct verbs_cq *cq,\n\t\t\t struct ibv_create_cq_ex *cmd,\n\t\t\t size_t cmd_size,\n\t\t\t struct ib_uverbs_ex_create_cq_resp *resp,\n\t\t\t size_t resp_size);\nint ibv_cmd_poll_cq(struct ibv_cq *cq, int ne, struct ibv_wc *wc);\nint ibv_cmd_req_notify_cq(struct ibv_cq *cq, int solicited_only);\nint ibv_cmd_resize_cq(struct ibv_cq *cq, int cqe,\n\t\t      struct ibv_resize_cq *cmd, size_t cmd_size,\n\t\t      struct ib_uverbs_resize_cq_resp *resp, size_t resp_size);\nint ibv_cmd_destroy_cq(struct ibv_cq *cq);\nint ibv_cmd_modify_cq(struct ibv_cq *cq,\n\t\t      struct ibv_modify_cq_attr *attr,\n\t\t      struct ibv_modify_cq *cmd,\n\t\t      size_t cmd_size);\n\nint ibv_cmd_create_srq(struct ibv_pd *pd,\n\t\t       struct ibv_srq *srq, struct ibv_srq_init_attr *attr,\n\t\t       struct ibv_create_srq *cmd, size_t cmd_size,\n\t\t       struct ib_uverbs_create_srq_resp *resp, size_t resp_size);\nint ibv_cmd_create_srq_ex(struct ibv_context *context,\n\t\t\t  struct verbs_srq *srq,\n\t\t\t  struct ibv_srq_init_attr_ex *attr_ex,\n\t\t\t  struct ibv_create_xsrq *cmd, size_t cmd_size,\n\t\t\t  struct ib_uverbs_create_srq_resp *resp, size_t resp_size);\nint ibv_cmd_modify_srq(struct ibv_srq *srq,\n\t\t       struct ibv_srq_attr *srq_attr,\n\t\t       int srq_attr_mask,\n\t\t       struct ibv_modify_srq *cmd, size_t cmd_size);\nint ibv_cmd_query_srq(struct ibv_srq *srq,\n\t\t      struct ibv_srq_attr *srq_attr,\n\t\t      struct ibv_query_srq *cmd, size_t cmd_size);\nint ibv_cmd_destroy_srq(struct ibv_srq *srq);\n\nint ibv_cmd_create_qp(struct ibv_pd *pd,\n\t\t      struct ibv_qp *qp, struct ibv_qp_init_attr *attr,\n\t\t      struct ibv_create_qp *cmd, size_t cmd_size,\n\t\t      struct ib_uverbs_create_qp_resp *resp, size_t resp_size);\nint ibv_cmd_create_qp_ex(struct ibv_context *context,\n\t\t\t struct verbs_qp *qp,\n\t\t\t struct ibv_qp_init_attr_ex *attr_ex,\n\t\t\t struct ibv_create_qp *cmd, size_t cmd_size,\n\t\t\t struct ib_uverbs_create_qp_resp *resp, size_t resp_size);\nint ibv_cmd_create_qp_ex2(struct ibv_context *context,\n\t\t\t  struct verbs_qp *qp,\n\t\t\t  struct ibv_qp_init_attr_ex *qp_attr,\n\t\t\t  struct ibv_create_qp_ex *cmd,\n\t\t\t  size_t cmd_size,\n\t\t\t  struct ib_uverbs_ex_create_qp_resp *resp,\n\t\t\t  size_t resp_size);\nint ibv_cmd_open_qp(struct ibv_context *context,\n\t\t    struct verbs_qp *qp,  int vqp_sz,\n\t\t    struct ibv_qp_open_attr *attr,\n\t\t    struct ibv_open_qp *cmd, size_t cmd_size,\n\t\t    struct ib_uverbs_create_qp_resp *resp, size_t resp_size);\nint ibv_cmd_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *qp_attr,\n\t\t     int attr_mask,\n\t\t     struct ibv_qp_init_attr *qp_init_attr,\n\t\t     struct ibv_query_qp *cmd, size_t cmd_size);\nint ibv_cmd_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n\t\t      int attr_mask,\n\t\t      struct ibv_modify_qp *cmd, size_t cmd_size);\nint ibv_cmd_modify_qp_ex(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n\t\t\t int attr_mask, struct ibv_modify_qp_ex *cmd,\n\t\t\t size_t cmd_size,\n\t\t\t struct ib_uverbs_ex_modify_qp_resp *resp,\n\t\t\t size_t resp_size);\nint ibv_cmd_destroy_qp(struct ibv_qp *qp);\nint ibv_cmd_post_send(struct ibv_qp *ibqp, struct ibv_send_wr *wr,\n\t\t      struct ibv_send_wr **bad_wr);\nint ibv_cmd_post_recv(struct ibv_qp *ibqp, struct ibv_recv_wr *wr,\n\t\t      struct ibv_recv_wr **bad_wr);\nint ibv_cmd_post_srq_recv(struct ibv_srq *srq, struct ibv_recv_wr *wr,\n\t\t\t  struct ibv_recv_wr **bad_wr);\nint ibv_cmd_create_ah(struct ibv_pd *pd, struct ibv_ah *ah,\n\t\t      struct ibv_ah_attr *attr,\n\t\t      struct ib_uverbs_create_ah_resp *resp,\n\t\t      size_t resp_size);\nint ibv_cmd_destroy_ah(struct ibv_ah *ah);\nint ibv_cmd_attach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);\nint ibv_cmd_detach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);\n\nint ibv_cmd_create_flow(struct ibv_qp *qp,\n\t\t\t\t     struct ibv_flow *flow_id,\n\t\t\t\t     struct ibv_flow_attr *flow_attr,\n\t\t\t\t     void *ucmd,\n\t\t\t\t     size_t ucmd_size);\nint ibv_cmd_destroy_flow(struct ibv_flow *flow_id);\nint ibv_cmd_create_wq(struct ibv_context *context,\n\t\t      struct ibv_wq_init_attr *wq_init_attr,\n\t\t      struct ibv_wq *wq,\n\t\t      struct ibv_create_wq *cmd,\n\t\t      size_t cmd_size,\n\t\t      struct ib_uverbs_ex_create_wq_resp *resp,\n\t\t      size_t resp_size);\n\nint ibv_cmd_destroy_flow_action(struct verbs_flow_action *action);\nint ibv_cmd_modify_wq(struct ibv_wq *wq, struct ibv_wq_attr *attr,\n\t\t      struct ibv_modify_wq *cmd, size_t cmd_size);\nint ibv_cmd_destroy_wq(struct ibv_wq *wq);\nint ibv_cmd_create_rwq_ind_table(struct ibv_context *context,\n\t\t\t\t struct ibv_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t struct ibv_rwq_ind_table *rwq_ind_table,\n\t\t\t\t struct ib_uverbs_ex_create_rwq_ind_table_resp *resp,\n\t\t\t\t size_t resp_size);\nint ibv_cmd_destroy_rwq_ind_table(struct ibv_rwq_ind_table *rwq_ind_table);\nint ibv_cmd_create_counters(struct ibv_context *context,\n\t\t\t    struct ibv_counters_init_attr *init_attr,\n\t\t\t    struct verbs_counters *vcounters,\n\t\t\t    struct ibv_command_buffer *link);\nint ibv_cmd_destroy_counters(struct verbs_counters *vcounters);\nint ibv_cmd_read_counters(struct verbs_counters *vcounters,\n\t\t\t  uint64_t *counters_value,\n\t\t\t  uint32_t ncounters,\n\t\t\t  uint32_t flags,\n\t\t\t  struct ibv_command_buffer *link);\nint ibv_dontfork_range(void *base, size_t size);\nint ibv_dofork_range(void *base, size_t size);\nint ibv_cmd_alloc_dm(struct ibv_context *ctx,\n\t\t     const struct ibv_alloc_dm_attr *dm_attr,\n\t\t     struct verbs_dm *dm,\n\t\t     struct ibv_command_buffer *link);\nint ibv_cmd_free_dm(struct verbs_dm *dm);\nint ibv_cmd_reg_dm_mr(struct ibv_pd *pd, struct verbs_dm *dm,\n\t\t      uint64_t offset, size_t length,\n\t\t      unsigned int access, struct verbs_mr *vmr,\n\t\t      struct ibv_command_buffer *link);\n\nint __ibv_query_gid_ex(struct ibv_context *context, uint32_t port_num,\n\t\t\t    uint32_t gid_index, struct ibv_gid_entry *entry,\n\t\t\t    uint32_t flags, size_t entry_size,\n\t\t\t    uint32_t fallback_attr_mask);\n\n/*\n * sysfs helper functions\n */\nconst char *ibv_get_sysfs_path(void);\n\nint ibv_read_sysfs_file(const char *dir, const char *file,\n\t\t\tchar *buf, size_t size);\nint ibv_read_sysfs_file_at(int dirfd, const char *file, char *buf, size_t size);\nint ibv_read_ibdev_sysfs_file(char *buf, size_t size,\n\t\t\t      struct verbs_sysfs_dev *sysfs_dev,\n\t\t\t      const char *fnfmt, ...)\n\t__attribute__((format(printf, 4, 5)));\nint ibv_get_fw_ver(char *value, size_t len, struct verbs_sysfs_dev *sysfs_dev);\n\nstatic inline bool check_comp_mask(uint64_t input, uint64_t supported)\n{\n\treturn (input & ~supported) == 0;\n}\n\nint ibv_query_gid_type(struct ibv_context *context, uint8_t port_num,\n\t\t       unsigned int index, enum ibv_gid_type_sysfs *type);\n\nstatic inline int\nibv_check_alloc_parent_domain(struct ibv_parent_domain_init_attr *attr)\n{\n\t/* A valid protection domain must be set */\n\tif (!attr->pd) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Initialize the ibv_pd which is being used as a parent_domain. From the\n * perspective of the core code the new ibv_pd is completely interchangeable\n * with the passed contained_pd.\n */\nstatic inline void ibv_initialize_parent_domain(struct ibv_pd *parent_domain,\n\t\t\t\t\t\tstruct ibv_pd *contained_pd)\n{\n\tparent_domain->context = contained_pd->context;\n\tparent_domain->handle = contained_pd->handle;\n}\n\n#endif /* INFINIBAND_DRIVER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/ibacm/src/acm.c": "/*\n * Copyright (c) 2009-2014 Intel Corporation. All rights reserved.\n * Copyright (c) 2013 Mellanox Technologies LTD. All rights reserved.\n *\n * This software is available to you under the OpenIB.org BSD license\n * below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AWV\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#define _GNU_SOURCE\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <osd.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <infiniband/acm.h>\n#include <infiniband/acm_prov.h>\n#include <infiniband/umad.h>\n#include <infiniband/verbs.h>\n#include <infiniband/umad_types.h>\n#include <infiniband/umad_sa.h>\n#include <dlfcn.h>\n#include <search.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <net/if_arp.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <rdma/rdma_netlink.h>\n#include <rdma/ib_user_sa.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <getopt.h>\n#include <systemd/sd-daemon.h>\n#include <ccan/list.h>\n#include <util/util.h>\n#include \"acm_mad.h\"\n#include \"acm_util.h\"\n\n#define NL_MSG_BUF_SIZE 4096\n#define ACM_PROV_NAME_SIZE 64\n#define NL_CLIENT_INDEX 0\n\nstruct acmc_subnet {\n\tstruct list_node       entry;\n\t__be64                 subnet_prefix;\n};\n\nstruct acmc_prov {\n\tstruct acm_provider    *prov;\n\tvoid                   *handle;\n\tstruct list_node       entry;\n\tstruct list_head       subnet_list;\n};\n\nstruct acmc_prov_context {\n\tstruct list_node        entry;\n\tatomic_t                refcnt;\n\tstruct acm_provider     *prov;\n\tvoid                    *context;\n};\n\nstruct acmc_device;\n\nstruct acmc_port {\n\tstruct acmc_device  *dev;\n\tstruct acm_port     port;\n\tstruct acm_provider *prov; /* limit to 1 provider per port for now */\n\tvoid                *prov_port_context;\n\tint\t\t    mad_portid;\n\tint\t\t    mad_agentid;\n\tstruct ib_mad_addr  sa_addr;\n\tstruct list_head    sa_pending;\n\tstruct list_head    sa_wait;\n\tint\t\t    sa_credits;\n\tpthread_mutex_t     lock;\n\tstruct list_head    ep_list;\n\tenum ibv_port_state state;\n\tint                 gid_cnt;\n\tunion ibv_gid       *gid_tbl;\n\tuint16_t            lid;\n\tuint16_t            lid_mask;\n\tint                 sa_pkey_index;\n\tbool\t\t    pending_rereg;\n\tuint16_t            def_acm_pkey;\n};\n\nstruct acmc_device {\n\tstruct acm_device       device;\n\tstruct list_node        entry;\n\tstruct list_head        prov_dev_context_list;\n\tint                     port_cnt;\n\tstruct acmc_port        port[0];\n};\n\nstruct acmc_addr {\n\tstruct acm_address    addr;\n\tvoid                  *prov_addr_context;\n\tchar\t\t      string_buf[ACM_MAX_ADDRESS];\n};\n\nstruct acmc_ep {\n\tstruct acmc_port      *port;\n\tstruct acm_endpoint   endpoint;\n\tvoid                  *prov_ep_context;\n\t/* Although the below two entries are used for dynamic allocations,\n\t * they are accessed by a single thread, so no locking is required.\n\t */\n\tint                   nmbr_ep_addrs;\n\tstruct acmc_addr      *addr_info;\n\tstruct list_node      entry;\n};\n\nstruct acmc_client {\n\tpthread_mutex_t lock;   /* acquire ep lock first */\n\tint      sock;\n\tint      index;\n\tatomic_t refcnt;\n};\n\nunion socket_addr {\n\tstruct sockaddr     sa;\n\tstruct sockaddr_in  sin;\n\tstruct sockaddr_in6 sin6;\n};\n\nstruct acmc_sa_req {\n\tstruct list_node\tentry;\n\tstruct acmc_ep\t\t*ep;\n\tvoid\t\t\t(*resp_handler)(struct acm_sa_mad *);\n\tstruct acm_sa_mad\tmad;\n};\n\nstruct acm_nl_path {\n\tstruct nlattr\t\t\tattr_hdr;\n\tstruct ib_path_rec_data\t\trec;\n};\n\nstruct acm_nl_msg {\n\tstruct nlmsghdr\t\t\t\tnlmsg_header;\n\tunion {\n\t\tuint8_t\t\t\t\tdata[ACM_MSG_DATA_LENGTH];\n\t\tstruct rdma_ls_resolve_header\tresolve_header;\n\t\tstruct nlattr\t\t\tattr[0];\n\t\tstruct acm_nl_path\t\tpath[0];\n\t};\n};\n\nstatic char def_prov_name[ACM_PROV_NAME_SIZE] = \"ibacmp\";\nstatic LIST_HEAD(provider_list);\nstatic struct acmc_prov *def_provider = NULL;\n\nstatic LIST_HEAD(dev_list);\n\nstatic int listen_socket;\nstatic int ip_mon_socket;\nstatic struct acmc_client client_array[FD_SETSIZE - 1];\n\nstatic FILE *flog;\nstatic pthread_mutex_t log_lock;\nstatic __thread char log_data[ACM_MAX_ADDRESS];\nstatic atomic_t counter[ACM_MAX_COUNTER];\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port);\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey);\nstatic int acm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t\t      uint8_t addr_type);\nstatic void acm_event_handler(struct acmc_device *dev);\nstatic int acm_nl_send(int sock, struct acm_msg *msg);\n\nstatic struct sa_data {\n\tint\t\ttimeout;\n\tint\t\tretries;\n\tint\t\tdepth;\n\tpthread_t\tthread_id;\n\tstruct pollfd\t*fds;\n\tstruct acmc_port **ports;\n\tint\t\tnfds;\n} sa = { 2000, 2, 1, 0, NULL, NULL, 0};\n\n/*\n * Service options - may be set through ibacm_opts.cfg file.\n */\nstatic const char *acme = IBACM_BIN_PATH \"/ib_acme -A\";\nstatic const char *opts_file = ACM_CONF_DIR \"/\" ACM_OPTS_FILE;\nstatic const char *addr_file = ACM_CONF_DIR \"/\" ACM_ADDR_FILE;\nstatic char log_file[128] = IBACM_LOG_FILE;\nstatic int log_level = 0;\nstatic char lock_file[128] = IBACM_PID_FILE;\nstatic short server_port = 6125;\nstatic int server_mode = IBACM_SERVER_MODE_DEFAULT;\nstatic int acme_plus_kernel_only = IBACM_ACME_PLUS_KERNEL_ONLY_DEFAULT;\nstatic int support_ips_in_addr_cfg = 0;\nstatic char prov_lib_path[256] = IBACM_LIB_PATH;\n\nvoid acm_write(int level, const char *format, ...)\n{\n\tva_list args;\n\tstruct timeval tv;\n\tstruct tm tmtime;\n\tchar buffer[20];\n\n\tif (level > log_level)\n\t\treturn;\n\n\tgettimeofday(&tv, NULL);\n\tlocaltime_r(&tv.tv_sec, &tmtime);\n\tstrftime(buffer, 20, \"%Y-%m-%dT%H:%M:%S\", &tmtime);\n\tva_start(args, format);\n\tpthread_mutex_lock(&log_lock);\n\tfprintf(flog, \"%s.%03u: \", buffer, (unsigned) (tv.tv_usec / 1000));\n\tvfprintf(flog, format, args);\n\tfflush(flog);\n\tpthread_mutex_unlock(&log_lock);\n\tva_end(args);\n}\n\nvoid acm_format_name(int level, char *name, size_t name_size,\n\t\t     uint8_t addr_type, const uint8_t *addr, size_t addr_size)\n{\n\tstruct ibv_path_record *path;\n\n\tif (level > log_level)\n\t\treturn;\n\n\tswitch (addr_type) {\n\tcase ACM_EP_INFO_NAME:\n\t\tmemcpy(name, addr, addr_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\tinet_ntop(AF_INET, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\tcase ACM_ADDRESS_GID:\n\t\tinet_ntop(AF_INET6, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_PATH:\n\t\tpath = (struct ibv_path_record *) addr;\n\t\tif (path->dlid) {\n\t\t\tsnprintf(name, name_size, \"SLID(%u) DLID(%u)\",\n\t\t\t\tbe16toh(path->slid), be16toh(path->dlid));\n\t\t} else {\n\t\t\tacm_format_name(level, name, name_size, ACM_ADDRESS_GID,\n\t\t\t\t\tpath->dgid.raw, sizeof path->dgid);\n\t\t}\n\t\tbreak;\n\tcase ACM_ADDRESS_LID:\n\t\tsnprintf(name, name_size, \"LID(%u)\", be16toh(*((__be16 *) addr)));\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(name, \"Unknown\");\n\t\tbreak;\n\t}\n}\n\nint ib_any_gid(union ibv_gid *gid)\n{\n\treturn ((gid->global.subnet_prefix | gid->global.interface_id) == 0);\n}\n\nconst char *acm_get_opts_file(void)\n{\n\treturn opts_file;\n}\n\nvoid acm_increment_counter(int type)\n{\n\tif (type >= 0 && type < ACM_MAX_COUNTER)\n\t\tatomic_inc(&counter[type]);\n}\n\nstatic struct acmc_prov_context *\nacm_alloc_prov_context(struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = calloc(1, sizeof(*ctx));\n\tif (!ctx) {\n\t\tacm_log(0, \"Error: failed to allocate prov context\\n\");\n\t\treturn NULL;\n\t}\n\tatomic_set(&ctx->refcnt, 1);\n\tctx->prov = prov;\n\treturn ctx;\n}\n\nstatic struct acmc_prov_context *\nacm_get_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tlist_for_each(list, ctx, entry) {\n\t\tif (ctx->prov == prov) {\n\t\t\treturn ctx;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_prov_context *\nacm_acquire_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = acm_get_prov_context(list, prov);\n\tif (!ctx) {\n\t\tctx = acm_alloc_prov_context(prov);\n\t\tif (!ctx) {\n\t\t\tacm_log(0, \"Error -- failed to allocate provider context\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlist_add_tail(list, &ctx->entry);\n\t} else {\n\t\tatomic_inc(&ctx->refcnt);\n\t}\n\n\treturn ctx;\n}\n\nstatic void\nacm_release_prov_context(struct acmc_prov_context *ctx)\n{\n\tif (atomic_dec(&ctx->refcnt) <= 0) {\n\t\tlist_del(&ctx->entry);\n\t\tfree(ctx);\n\t}\n}\n\nuint8_t acm_gid_index(struct acm_port *port, union ibv_gid *gid)\n{\n\tuint8_t i;\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tfor (i = 0; i < cport->gid_cnt; i++) {\n\t\tif (!memcmp(&cport->gid_tbl[i], gid, sizeof (*gid)))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint acm_get_gid(struct acm_port *port, int index, union ibv_gid *gid)\n{\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tif (index >= 0 && index < cport->gid_cnt) {\n\t\t*gid = cport->gid_tbl[index];\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic size_t acm_addr_len(uint8_t addr_type)\n{\n\tswitch (addr_type) {\n\tcase ACM_ADDRESS_NAME:\n\t\treturn ACM_MAX_ADDRESS;\n\tcase ACM_ADDRESS_IP:\n\t\treturn sizeof(struct in_addr);\n\tcase ACM_ADDRESS_IP6:\n\t\treturn sizeof(struct in6_addr);\n\tcase ACM_ADDRESS_GID:\n\t\treturn sizeof(union ibv_gid);\n\tcase ACM_ADDRESS_LID:\n\t\treturn sizeof(uint16_t);\n\tdefault:\n\t\tacm_log(2, \"illegal address type %d\\n\", addr_type);\n\t}\n\treturn 0;\n}\n\nstatic int acm_addr_cmp(struct acm_address *acm_addr, uint8_t *addr, uint8_t addr_type)\n{\n\tif (acm_addr->type != addr_type)\n\t\treturn -2;\n\n\tif (acm_addr->type == ACM_ADDRESS_NAME)\n\t\treturn strncasecmp((char *) acm_addr->info.name,\n\t\t\t\t   (char *) addr, acm_addr_len(acm_addr->type));\n\treturn memcmp(acm_addr->info.addr, addr, acm_addr_len(acm_addr->type));\n}\n\nstatic void acm_mark_addr_invalid(struct acmc_ep *ep,\n\t\t\t\t  struct acm_ep_addr_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\tif (!acm_addr_cmp(&ep->addr_info[i].addr, data->info.addr, data->type)) {\n\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\tep->port->prov->remove_address(ep->addr_info[i].prov_addr_context);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct acm_address *\nacm_addr_lookup(const struct acm_endpoint *endpoint, uint8_t *addr, uint8_t addr_type)\n{\n\tstruct acmc_ep *ep;\n\tint i;\n\n\tep = container_of(endpoint, struct acmc_ep, endpoint);\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++)\n\t\tif (!acm_addr_cmp(&ep->addr_info[i].addr, addr, addr_type))\n\t\t\treturn &ep->addr_info[i].addr;\n\n\treturn NULL;\n}\n\n__be64 acm_path_comp_mask(struct ibv_path_record *path)\n{\n\tuint32_t fl_hop;\n\tuint16_t qos_sl;\n\t__be64 comp_mask = 0;\n\n\tacm_log(2, \"\\n\");\n\tif (path->service_id)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SERVICE_ID;\n\tif (!ib_any_gid(&path->dgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_DGID;\n\tif (!ib_any_gid(&path->sgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_SGID;\n\tif (path->dlid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_DLID;\n\tif (path->slid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SLID;\n\n\tfl_hop = be32toh(path->flowlabel_hoplimit);\n\tif (fl_hop >> 8)\n\t\tcomp_mask |= IB_COMP_MASK_PR_FLOW_LABEL;\n\tif (fl_hop & 0xFF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_HOP_LIMIT;\n\n\tif (path->tclass)\n\t\tcomp_mask |= IB_COMP_MASK_PR_TCLASS;\n\tif (path->reversible_numpath & 0x80)\n\t\tcomp_mask |= IB_COMP_MASK_PR_REVERSIBLE;\n\tif (path->pkey)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PKEY;\n\n\tqos_sl = be16toh(path->qosclass_sl);\n\tif (qos_sl >> 4)\n\t\tcomp_mask |= IB_COMP_MASK_PR_QOS_CLASS;\n\tif (qos_sl & 0xF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SL;\n\n\tif (path->mtu & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU_SELECTOR;\n\tif (path->mtu & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU;\n\tif (path->rate & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE_SELECTOR;\n\tif (path->rate & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE;\n\tif (path->packetlifetime & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME_SELECTOR;\n\tif (path->packetlifetime & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME;\n\n\treturn comp_mask;\n}\n\nint acm_resolve_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"client %d, status 0x%x\\n\", client->index, msg->hdr.status);\n\n\tif (msg->hdr.status == ACM_STATUS_ENODATA)\n\t\tatomic_inc(&counter[ACM_CNTR_NODATA]);\n\telse if (msg->hdr.status)\n\t\tatomic_inc(&counter[ACM_CNTR_ERROR]);\n\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tif (id == NL_CLIENT_INDEX)\n\t\tret = acm_nl_send(client->sock, msg);\n\telse\n\t\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int\nacmc_resolve_response(uint64_t id, struct acm_msg *req_msg, uint8_t status)\n{\n\treq_msg->hdr.opcode |= ACM_OP_ACK;\n\treq_msg->hdr.status = status;\n\tif (status != ACM_STATUS_SUCCESS)\n\t\treq_msg->hdr.length = ACM_MSG_HDR_LENGTH;\n\tmemset(req_msg->hdr.data, 0, sizeof(req_msg->hdr.data));\n\n\treturn acm_resolve_response(id, req_msg);\n}\n\nint acm_query_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"status 0x%x\\n\", msg->hdr.status);\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int acmc_query_response(uint64_t id, struct acm_msg *msg, uint8_t status)\n{\n\tacm_log(2, \"status 0x%x\\n\", status);\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = status;\n\treturn acm_query_response(id, msg);\n}\n\nstatic void acm_init_server(void)\n{\n\tFILE *f;\n\tint i;\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tpthread_mutex_init(&client_array[i].lock, NULL);\n\t\tclient_array[i].index = i;\n\t\tclient_array[i].sock = -1;\n\t\tatomic_init(&client_array[i].refcnt);\n\t}\n\n\tif (server_mode != IBACM_SERVER_MODE_UNIX) {\n\t\tf = fopen(IBACM_IBACME_PORT_FILE, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"%hu\\n\", server_port);\n\t\t\tfclose(f);\n\t\t} else\n\t\t\tacm_log(0,\n\t\t\t\t\"notice - cannot publish ibacm port number\\n\");\n\n\t\tunlink(IBACM_PORT_FILE);\n\t\tif (!acme_plus_kernel_only) {\n\t\t\tif (symlink(IBACM_PORT_BASE, IBACM_PORT_FILE) != 0)\n\t\t\t\tacm_log(0,\n\t\t\t\t\t\"notice - can't create port symlink\\n\");\n\t\t}\n\t} else {\n\t\tunlink(IBACM_IBACME_PORT_FILE);\n\t\tunlink(IBACM_PORT_FILE);\n\t}\n}\n\nstatic int acm_listen(void)\n{\n\tunion {\n\t\tstruct sockaddr any;\n\t\tstruct sockaddr_in inet;\n\t\tstruct sockaddr_un unx;\n\t} addr;\n\tmode_t saved_mask;\n\tint ret, saved_errno;\n\n\tacm_log(2, \"\\n\");\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (server_mode == IBACM_SERVER_MODE_UNIX) {\n\t\taddr.any.sa_family = AF_UNIX;\n\t\tBUILD_ASSERT(sizeof(IBACM_IBACME_SERVER_PATH) <=\n\t\t\t     sizeof(addr.unx.sun_path));\n\t\tstrcpy(addr.unx.sun_path, IBACM_IBACME_SERVER_PATH);\n\n\t\tlisten_socket = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\tif (listen_socket < 0) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to allocate unix socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\n\t\tunlink(addr.unx.sun_path);\n\t\tsaved_mask = umask(0);\n\t\tret = bind(listen_socket, &addr.any, sizeof(addr.unx));\n\t\tsaved_errno = errno;\n\t\tumask(saved_mask);\n\n\t\tif (ret) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to bind listen socket '%s'\\n\",\n\t\t\t\taddr.unx.sun_path);\n\t\t\treturn saved_errno;\n\t\t}\n\n\t\tunlink(IBACM_SERVER_PATH);\n\t\tif (!acme_plus_kernel_only) {\n\t\t\tif (symlink(IBACM_SERVER_BASE,\n\t\t\t\t    IBACM_SERVER_PATH) != 0) {\n\t\t\t\tsaved_errno = errno;\n\t\t\t\tacm_log(0,\n\t\t\t\t\t\"notice - can't create symlink\\n\");\n\t\t\t\treturn saved_errno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tunlink(IBACM_IBACME_SERVER_PATH);\n\t\tunlink(IBACM_SERVER_PATH);\n\n\t\tlisten_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\t\tif (listen_socket == -1) {\n\t\t\tacm_log(0,\n\t\t\t\t\"ERROR - unable to allocate TCP socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\n\t\taddr.any.sa_family = AF_INET;\n\t\taddr.inet.sin_port = htobe16(server_port);\n\t\tif (server_mode == IBACM_SERVER_MODE_LOOP)\n\t\t\taddr.inet.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tret = bind(listen_socket, &addr.any, sizeof(addr.inet));\n\t\tif (ret == -1) {\n\t\t\tacm_log(0, \"ERROR - unable to bind listen socket\\n\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\tret = listen(listen_socket, 0);\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to start listen\\n\");\n\t\treturn errno;\n\t}\n\n\tacm_log(2, \"listen active\\n\");\n\treturn 0;\n}\n\n/* Retrieve the listening socket from systemd. */\nstatic int acm_listen_systemd(void)\n{\n\tint fd;\n\n\tint rc = sd_listen_fds(1);\n\tif (rc == -1) {\n\t\tfprintf(stderr, \"sd_listen_fds failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (rc > 2) {\n\t\tfprintf(stderr,\n\t\t\t\"sd_listen_fds returned %d fds, expected <= 2\\n\", rc);\n\t\treturn -1;\n\t}\n\n\tfor (fd = SD_LISTEN_FDS_START; fd != SD_LISTEN_FDS_START + rc; fd++) {\n\t\tif (sd_is_socket(fd, AF_NETLINK, SOCK_RAW, 0)) {\n\t\t\t/* ListenNetlink for RDMA_NL_GROUP_LS multicast\n\t\t\t * messages from the kernel\n\t\t\t */\n\t\t\tif (client_array[NL_CLIENT_INDEX].sock != -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"sd_listen_fds returned more than one netlink socket\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclient_array[NL_CLIENT_INDEX].sock = fd;\n\n\t\t\t/* systemd sets NONBLOCK on the netlink socket, while\n\t\t\t * we want blocking send to the kernel.\n\t\t\t */\n\t\t\tif (set_fd_nonblock(fd, false)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Unable to drop O_NOBLOCK on netlink socket\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (sd_is_socket(SD_LISTEN_FDS_START, AF_UNSPEC,\n\t\t\t\t\tSOCK_STREAM, 1)) {\n\t\t\t/* Socket for user space client communication */\n\t\t\tif (listen_socket != -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"sd_listen_fds returned more than one listening socket\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlisten_socket = fd;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"sd_listen_fds socket is not a SOCK_STREAM/SOCK_NETLINK listening socket\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_disconnect_client(struct acmc_client *client)\n{\n\tpthread_mutex_lock(&client->lock);\n\tshutdown(client->sock, SHUT_RDWR);\n\tclose(client->sock);\n\tclient->sock = -1;\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n}\n\nstatic void acm_svr_accept(void)\n{\n\tint s;\n\tint i;\n\n\tacm_log(2, \"\\n\");\n\ts = accept(listen_socket, NULL, NULL);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - failed to accept connection\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tif (i == NL_CLIENT_INDEX)\n\t\t\tcontinue;\n\t\tif (!atomic_get(&client_array[i].refcnt))\n\t\t\tbreak;\n\t}\n\n\tif (i == FD_SETSIZE - 1) {\n\t\tacm_log(0, \"ERROR - all connections busy - rejecting\\n\");\n\t\tclose(s);\n\t\treturn;\n\t}\n\n\tclient_array[i].sock = s;\n\tatomic_set(&client_array[i].refcnt, 1);\n\tacm_log(2, \"assigned client %d\\n\", i);\n}\n\nstatic int\nacm_is_path_from_port(struct acmc_port *port, struct ibv_path_record *path)\n{\n\tuint8_t i;\n\n\tif (!ib_any_gid(&path->sgid)) {\n\t\treturn (acm_gid_index(&port->port, &path->sgid) <\n\t\t\tport->gid_cnt);\n\t}\n\n\tif (path->slid) {\n\t\treturn (port->lid == (be16toh(path->slid) & port->lid_mask));\n\t}\n\n\tif (ib_any_gid(&path->dgid)) {\n\t\treturn 1;\n\t}\n\n\tif (acm_gid_index(&port->port, &path->dgid) < port->gid_cnt) {\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < port->gid_cnt; i++) {\n\t\tif (port->gid_tbl[i].global.subnet_prefix ==\n\t\t    path->dgid.global.subnet_prefix) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool acm_same_partition(uint16_t pkey_a, uint16_t pkey_b)\n{\n\n\tacm_log(2, \"pkey_a: 0x%04x pkey_b: 0x%04x\\n\", pkey_a, pkey_b);\n\n\treturn ((pkey_a | IB_PKEY_FULL_MEMBER) == (pkey_b | IB_PKEY_FULL_MEMBER));\n}\n\nstatic struct acmc_addr *\nacm_get_port_ep_address(struct acmc_port *port, struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acm_address *addr;\n\tint i;\n\n\tif (port->state != IBV_PORT_ACTIVE)\n\t\treturn NULL;\n\n\tif (data->type == ACM_EP_INFO_PATH &&\n\t    !acm_is_path_from_port(port, &data->info.path))\n\t\treturn NULL;\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif ((data->type == ACM_EP_INFO_PATH) &&\n\t\t    (!data->info.path.pkey ||\n\t\t     acm_same_partition(be16toh(data->info.path.pkey), ep->endpoint.pkey))) {\n\t\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\t\tif (ep->addr_info[i].addr.type)\n\t\t\t\t\treturn &ep->addr_info[i];\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((addr = acm_addr_lookup(&ep->endpoint, data->info.addr,\n\t\t\t\t\t    (uint8_t) data->type)))\n\t\t\treturn container_of(addr, struct acmc_addr, addr);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_addr *acm_get_ep_address(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_addr *addr;\n\tint i;\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(2, \"%s\\n\", log_data);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\taddr = acm_get_port_ep_address(&dev->port[i], data);\n\t\t\tif (addr)\n\t\t\t\treturn addr;\n\t\t}\n\t}\n\n\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(1, \"notice - could not find %s\\n\", log_data);\n\treturn NULL;\n}\n\n/* If port_num is zero, iterate through all ports, otherwise consider\n * only the specific port_num */\nstatic struct acmc_ep *acm_get_ep(int index, uint8_t port_num)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tint i, inx = 0;\n\n\tacm_log(2, \"ep index %d\\n\", index);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tif (port_num && port_num != (i + 1))\n\t\t\t\tcontinue;\n\t\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each(&dev->port[i].ep_list, ep, entry) {\n\t\t\t\tif (index == inx)\n\t\t\t\t\treturn ep;\n\t\t\t\t++inx;\n\t\t\t}\n\t\t}\n\t}\n\n\tacm_log(1, \"notice - could not find ep %d\\n\", index);\n\treturn NULL;\n}\n\nstatic int\nacm_svr_query_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length != ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid length: 0x%x\\n\", msg->hdr.length);\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(1, \"notice - could not find local end point address\\n\");\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->query(addr->prov_addr_context, msg, client->index);\n}\n\nstatic int acm_svr_select_src(struct acm_ep_addr_data *src, struct acm_ep_addr_data *dst)\n{\n\tunion socket_addr addr;\n\tsocklen_t len;\n\tint ret;\n\tint s;\n\n\tacm_log(2, \"selecting source address\\n\");\n\tmemset(&addr, 0, sizeof addr);\n\tswitch (dst->type) {\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\taddr.sin.sin_family = AF_INET;\n\t\tmemcpy(&addr.sin.sin_addr, dst->info.addr, 4);\n\t\tlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\t\taddr.sin6.sin6_family = AF_INET6;\n\t\tmemcpy(&addr.sin6.sin6_addr, dst->info.addr, 16);\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(1, \"notice - bad destination type, cannot lookup source\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\ts = socket(addr.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate socket\\n\");\n\t\treturn errno;\n\t}\n\n\tret = connect(s, &addr.sa, len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to connect socket\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tret = getsockname(s, &addr.sa, &len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to get socket address\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tsrc->type = dst->type;\n\tsrc->flags = ACM_EP_FLAG_SOURCE;\n\tif (dst->type == ACM_EP_INFO_ADDRESS_IP) {\n\t\tmemcpy(&src->info.addr, &addr.sin.sin_addr, 4);\n\t} else {\n\t\tmemcpy(&src->info.addr, &addr.sin6.sin6_addr, 16);\n\t}\nout:\n\tclose(s);\n\treturn ret;\n}\n\n/*\n * Verify the resolve message from the client and return\n * references to the source and destination addresses.\n * The message buffer contains extra address data buffers.  If a\n * source address is not given, reference an empty address buffer,\n * and we'll resolve a source address later.  Record the location of\n * the source and destination addresses in the message header data\n * to avoid further searches.\n */\nstatic uint8_t acm_svr_verify_resolve(struct acm_msg *msg)\n{\n\tint i, cnt, have_dst = 0;\n\n\tif (msg->hdr.length < ACM_MSG_HDR_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn ACM_STATUS_EINVAL;\n\t}\n\n\tmsg->hdr.src_out = 1;\n\tcnt = (msg->hdr.length - ACM_MSG_HDR_LENGTH) / ACM_MSG_EP_LENGTH;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_SOURCE) {\n\t\t\tif (!msg->hdr.src_out) {\n\t\t\t\tacm_log(0, \"ERROR - multiple sources specified\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported source address type\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCTYPE;\n\t\t\t}\n\t\t\tmsg->hdr.src_out = 0;\n\t\t\tmsg->hdr.src_index = i;\n\t\t}\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_DEST) {\n\t\t\tif (have_dst) {\n\t\t\t\tacm_log(0, \"ERROR - multiple destinations specified\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported destination address type\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTTYPE;\n\t\t\t}\n\t\t\thave_dst = 1;\n\t\t\tmsg->hdr.dst_index = i;\n\t\t}\n\t}\n\n\tif (!have_dst) {\n\t\tacm_log(0, \"ERROR - destination address required\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\tif (msg->hdr.src_out) {\n\t\tmsg->hdr.src_index = i;\n\t\tmemset(&msg->resolve_data[i], 0, sizeof(struct acm_ep_addr_data));\n\t}\n\treturn ACM_STATUS_SUCCESS;\n}\n\nstatic int\nacm_svr_resolve_dest(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct acm_ep_addr_data *saddr, *daddr;\n\tuint8_t status;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tstatus = acm_svr_verify_resolve(msg);\n\tif (status) {\n\t\tacm_log(0, \"notice - misformatted or unsupported request\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, status);\n\t}\n\n\tsaddr = &msg->resolve_data[msg->hdr.src_index];\n\tdaddr = &msg->resolve_data[msg->hdr.dst_index];\n\tif (msg->hdr.src_out) {\n\t\tstatus = acm_svr_select_src(saddr, daddr);\n\t\tif (status) {\n\t\t\tacm_log(0, \"notice - unable to select suitable source address\\n\");\n\t\t\treturn acmc_resolve_response(client->index, msg, status);\n\t\t}\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tsaddr->type, saddr->info.addr, sizeof saddr->info.addr);\n\tacm_log(2, \"src  %s\\n\", log_data);\n\taddr = acm_get_ep_address(saddr);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg, client->index);\n}\n\n/*\n * The message buffer contains extra address data buffers.  We extract the\n * destination address from the path record into an extra buffer, so we can\n * lookup the destination by either LID or GID.\n */\nstatic int\nacm_svr_resolve_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct ibv_path_record *path;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)) {\n\t\tacm_log(0, \"notice - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\tpath = &msg->resolve_data[0].info.path;\n\tif (!path->dlid && ib_any_gid(&path->dgid)) {\n\t\tacm_log(0, \"notice - no destination specified\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_EDESTADDR);\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data, ACM_EP_INFO_PATH,\n\t\tmsg->resolve_data[0].info.addr, sizeof *path);\n\tacm_log(2, \"path %s\\n\", log_data);\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg,\n\t\t\t\t       client->index);\n}\n\nstatic int acm_svr_resolve(struct acmc_client *client, struct acm_msg *msg)\n{\n\t(void) atomic_inc(&client->refcnt);\n\n\tif (msg->resolve_data[0].type == ACM_EP_INFO_PATH) {\n\t\tif (msg->resolve_data[0].flags & ACM_FLAGS_QUERY_SA) {\n\t\t\treturn acm_svr_query_path(client, msg);\n\t\t} else {\n\t\t\treturn acm_svr_resolve_path(client, msg);\n\t\t}\n\t} else {\n\t\treturn acm_svr_resolve_dest(client, msg);\n\t}\n}\n\nstatic int acm_svr_perf_query(struct acmc_client *client, struct acm_msg *msg)\n{\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep = NULL;\n\tint index;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.src_index;\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\tmsg->hdr.dst_index = 0;\n\n\tif ((be16toh(msg->hdr.length) < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && index < 1) ||\n\t    ((be16toh(msg->hdr.length) >= (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && !(msg->resolve_data[0].flags & ACM_EP_FLAG_SOURCE)))) {\n\t\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\t\tmsg->perf_data[i] = htobe64((uint64_t) atomic_get(&counter[i]));\n\n\t\tmsg->hdr.src_out = ACM_MAX_COUNTER;\n\t\tlen = ACM_MSG_HDR_LENGTH + (ACM_MAX_COUNTER * sizeof(uint64_t));\n\t} else {\n\t\tif (index >= 1) {\n\t\t\tep = acm_get_ep(index - 1, msg->hdr.src_index);\n\t\t} else {\n\t\t\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\t\t\tif (addr)\n\t\t\t\tep = container_of(addr->addr.endpoint,\n\t\t\t\t\t\t  struct acmc_ep, endpoint);\n\t\t}\n\n\t\tif (ep) {\n\t\t\tep->port->prov->query_perf(ep->prov_ep_context,\n\t\t\t\t\t\t   msg->perf_data, &msg->hdr.src_out);\n\t\t\tlen = ACM_MSG_HDR_LENGTH + (msg->hdr.src_out * sizeof(uint64_t));\n\t\t} else {\n\t\t\tmsg->hdr.status = ACM_STATUS_ESRCADDR;\n\t\t\tlen = ACM_MSG_HDR_LENGTH;\n\t\t}\n\t}\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int may_be_realloc(struct acm_msg **msg_ptr,\n\t\t\t  int len,\n\t\t\t  int cnt,\n\t\t\t  int *cur_msg_siz_ptr,\n\t\t\t  int max_msg_siz)\n{\n\n\t/* Check if a new address exceeds the protocol constrained max size */\n\tif (len + (cnt + 1) * ACM_MAX_ADDRESS > max_msg_siz) {\n\t\tacm_log(0, \"ERROR - unable to amend more addresses to acm_msg due to protocol constraints\\n\");\n\t\t\treturn ENOMEM;\n\t}\n\n\t/* Check if a new address exceeds current size of msg */\n\tif (len + (cnt + 1) * ACM_MAX_ADDRESS > *cur_msg_siz_ptr) {\n\t\tconst size_t chunk_size = 16 * ACM_MAX_ADDRESS;\n\t\tstruct acm_msg *new_msg = realloc(*msg_ptr, *cur_msg_siz_ptr + chunk_size);\n\n\t\tif (!new_msg) {\n\t\t\tacm_log(0, \"ERROR - failed to allocate longer acm_msg\\n\");\n\t\t\treturn ENOMEM;\n\t\t}\n\n\t\t*msg_ptr = new_msg;\n\t\t*cur_msg_siz_ptr += chunk_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int acm_svr_ep_query(struct acmc_client *client, struct acm_msg **_msg)\n{\n\tint sts;\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_ep *ep;\n\tint index, cnt = 0;\n\tstruct acm_msg *msg = *_msg;\n\tint cur_msg_siz = sizeof(*msg);\n\tint max_msg_siz = USHRT_MAX;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.src_out;\n\tep = acm_get_ep(index - 1, msg->hdr.src_index);\n\tif (ep) {\n\t\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\t\tmsg->ep_data[0].dev_guid = ep->port->dev->device.dev_guid;\n\t\tmsg->ep_data[0].port_num = ep->port->port.port_num;\n\t\tmsg->ep_data[0].phys_port_cnt = ep->port->dev->port_cnt;\n\t\tmsg->ep_data[0].pkey = htobe16(ep->endpoint.pkey);\n\t\tstrncpy((char *)msg->ep_data[0].prov_name, ep->port->prov->name,\n\t\t\tACM_MAX_PROV_NAME - 1);\n\t\tmsg->ep_data[0].prov_name[ACM_MAX_PROV_NAME - 1] = '\\0';\n\t\tlen = ACM_MSG_HDR_LENGTH + sizeof(struct acm_ep_config_data);\n\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\tif (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID) {\n\t\t\t\tsts = may_be_realloc(_msg, len, cnt, &cur_msg_siz, max_msg_siz);\n\t\t\t\tmsg = *_msg;\n\t\t\t\tif (sts)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(msg->ep_data[0].addrs[cnt++].name,\n\t\t\t\t       ep->addr_info[i].string_buf,\n\t\t\t\t       ACM_MAX_ADDRESS);\n\t\t\t}\n\t\t}\n\t\tmsg->ep_data[0].addr_cnt = htobe16(cnt);\n\t\tlen += cnt * ACM_MAX_ADDRESS;\n\t} else {\n\t\tmsg->hdr.status = ACM_STATUS_EINVAL;\n\t\tlen = ACM_MSG_HDR_LENGTH;\n\t}\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.src_index = 0;\n\tmsg->hdr.dst_index = 0;\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int acm_msg_length(struct acm_msg *msg)\n{\n\treturn (msg->hdr.opcode == ACM_OP_RESOLVE) ?\n\t\tmsg->hdr.length : be16toh(msg->hdr.length);\n}\n\nstatic void acm_svr_receive(struct acmc_client *client)\n{\n\tstruct acm_msg *msg = malloc(sizeof(*msg));\n\tint ret;\n\n\tif (!msg) {\n\t\tacm_log(0, \"ERROR - Unable to alloc acm_msg\\n\");\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tret = recv(client->sock, (char *)msg, sizeof(*msg), 0);\n\tif (ret <= 0 || ret != acm_msg_length(msg)) {\n\t\tacm_log(2, \"client disconnected\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (msg->hdr.version != ACM_VERSION) {\n\t\tacm_log(0, \"ERROR - unsupported version %d\\n\", msg->hdr.version);\n\t\tgoto out;\n\t}\n\n\tswitch (msg->hdr.opcode & ACM_OP_MASK) {\n\tcase ACM_OP_RESOLVE:\n\t\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\t\tret = acm_svr_resolve(client, msg);\n\t\tbreak;\n\tcase ACM_OP_PERF_QUERY:\n\t\tret = acm_svr_perf_query(client, msg);\n\t\tbreak;\n\tcase ACM_OP_EP_QUERY:\n\t\tret = acm_svr_ep_query(client, &msg);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown opcode 0x%x\\n\", msg->hdr.opcode);\n\t\tbreak;\n\t}\n\nout:\n\tfree(msg);\n\tif (ret)\n\t\tacm_disconnect_client(client);\n}\n\nstatic int acm_nl_to_addr_data(struct acm_ep_addr_data *ad,\n\t\t\t\t  int af_family, uint8_t *addr, size_t addr_len)\n{\n\tif (addr_len > ACM_MAX_ADDRESS)\n\t\treturn EINVAL;\n\n\t/* find the ep associated with this address \"if any\" */\n\tswitch (af_family) {\n\tcase AF_INET:\n\t\tad->type = ACM_ADDRESS_IP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tad->type = ACM_ADDRESS_IP6;\n\t\tbreak;\n\tdefault:\n\t\treturn EINVAL;\n\t}\n\tmemcpy(&ad->info.addr, addr, addr_len);\n\treturn 0;\n}\n\nstatic void acm_add_ep_ip(char *ifname, struct acm_ep_addr_data *data, char *ip_str)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_device *dev;\n\tuint8_t port_num;\n\tuint16_t pkey;\n\tunion ibv_gid sgid;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tacm_log(1, \"Address '%s' already available\\n\", ip_str);\n\t\treturn;\n\t}\n\n\tif (acm_if_get_sgid(ifname, &sgid))\n\t\treturn;\n\n\tdev = acm_get_device_from_gid(&sgid, &port_num);\n\tif (!dev)\n\t\treturn;\n\n\tif (acm_if_get_pkey(ifname, &pkey))\n\t\treturn;\n\n\tacm_log(0, \" %s\\n\", ip_str);\n\n\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\tif (ep) {\n\t\tif (acm_ep_insert_addr(ep, ip_str, data->info.addr,\n\t\t\t\t       data->type))\n\t\t\tacm_log(0, \"Failed to add '%s' to EP\\n\", ip_str);\n\t} else {\n\t\tacm_log(0, \"Failed to add '%s' no EP for pkey\\n\", ip_str);\n\t}\n}\n\nstatic void acm_rm_ep_ip(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\t\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\t\tacm_log(0, \" %s\\n\", log_data);\n\t\tacm_mark_addr_invalid(ep, data);\n\t}\n}\n\nstatic int acm_ipnl_create(void)\n{\n\tstruct sockaddr_nl addr;\n\n\tif ((ip_mon_socket = socket(PF_NETLINK, SOCK_RAW | SOCK_NONBLOCK, NETLINK_ROUTE)) == -1) {\n\t\tacm_log(0, \"Failed to open NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;\n\n\tif (bind(ip_mon_socket, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tacm_log(0, \"Failed to bind NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr,\n\t\tchar *ip_str, void *ctx)\n{\n\tint ret = EINVAL;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tuint8_t port_num;\n\tchar gid_str[INET6_ADDRSTRLEN];\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev) {\n\t\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\t\tif (ep)\n\t\t\tret = acm_ep_insert_addr(ep, ip_str, addr, addr_type);\n\t}\n\n\tif (ret) {\n\t\tinet_ntop(AF_INET6, gid->raw, gid_str, sizeof(gid_str));\n\t\tacm_log(0, \"Failed to add '%s' (gid %s; pkey 0x%x)\\n\",\n\t\t\tip_str, gid_str, pkey);\n\t}\n}\n\n/* Netlink updates have indicated a failure which means we are no longer in\n * sync.  This should be a rare condition so we handle this with a \"big\n * hammer\" by clearing and re-reading all the system IP's.\n */\nstatic int resync_system_ips(void)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_port *port;\n\tstruct acmc_ep *ep;\n\tint i, cnt;\n\n\tacm_log(0, \"Resyncing all IP's\\n\");\n\n\t/* mark all IP's invalid */\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (cnt = 0; cnt < dev->port_cnt; cnt++) {\n\t\t\tport = &dev->port[cnt];\n\n\t\t\tlist_for_each(&port->ep_list, ep, entry) {\n\t\t\t\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\t\t\t\tif (ep->addr_info[i].addr.type == ACM_ADDRESS_IP ||\n\t\t\t\t\t    ep->addr_info[i].addr.type == ACM_ADDRESS_IP6)\n\t\t\t\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn acm_if_iter_sys(acm_ip_iter_cb, NULL);\n}\n\nstatic void acm_ipnl_handler(void)\n{\n\tint len;\n\tchar buffer[NL_MSG_BUF_SIZE];\n\tstruct nlmsghdr *nlh;\n\tchar ifname[IFNAMSIZ];\n\tchar ip_str[INET6_ADDRSTRLEN];\n\tstruct acm_ep_addr_data ad;\n\n\twhile ((len = recv(ip_mon_socket, buffer, NL_MSG_BUF_SIZE, 0)) > 0) {\n\t\tnlh = (struct nlmsghdr *)buffer;\n\t\twhile ((NLMSG_OK(nlh, len)) && (nlh->nlmsg_type != NLMSG_DONE)) {\n\t\t\tstruct ifaddrmsg *ifa = (struct ifaddrmsg *) NLMSG_DATA(nlh);\n\t\t\tstruct ifinfomsg *ifi = (struct ifinfomsg *) NLMSG_DATA(nlh);\n\t\t\tstruct rtattr *rth = IFA_RTA(ifa);\n\t\t\tint rtl = IFA_PAYLOAD(nlh);\n\n\t\t\tswitch (nlh->nlmsg_type) {\n\t\t\tcase RTM_NEWADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"New system address available %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_add_ep_ip(ifname, &ad, ip_str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"System address removed %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_rm_ep_ip(&ad);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_NEWLINK:\n\t\t\t\tacm_log(2, \"Link added : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELLINK:\n\t\t\t\tacm_log(2, \"Link removed : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tacm_log(2, \"unknown netlink message\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnlh = NLMSG_NEXT(nlh, len);\n\t\t}\n\t}\n\n\tif (len < 0 && errno == ENOBUFS) {\n\t\tacm_log(0, \"ENOBUFS returned from netlink...\\n\");\n\t\tresync_system_ips();\n\t}\n}\n\nstatic int acm_nl_send(int sock, struct acm_msg *msg)\n{\n\tstruct sockaddr_nl dst_addr;\n\tstruct acm_nl_msg acmnlmsg;\n\tstruct acm_nl_msg *orig;\n\tint ret;\n\tint datalen;\n\n\torig = (struct acm_nl_msg *)(uintptr_t)msg->hdr.tid;\n\n\tmemset(&dst_addr, 0, sizeof(dst_addr));\n\tdst_addr.nl_family = AF_NETLINK;\n\tdst_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tmemset(&acmnlmsg, 0, sizeof(acmnlmsg));\n\tacmnlmsg.nlmsg_header.nlmsg_len = NLMSG_HDRLEN;\n\tacmnlmsg.nlmsg_header.nlmsg_pid = getpid();\n\tacmnlmsg.nlmsg_header.nlmsg_type = orig->nlmsg_header.nlmsg_type;\n\tacmnlmsg.nlmsg_header.nlmsg_seq = orig->nlmsg_header.nlmsg_seq;\n\n\tif (msg->hdr.status != ACM_STATUS_SUCCESS) {\n\t\tacm_log(2, \"acm status no success = %d\\n\", msg->hdr.status);\n\t\tacmnlmsg.nlmsg_header.nlmsg_flags |= RDMA_NL_LS_F_ERR;\n\t} else {\n\t\tacm_log(2, \"acm status success\\n\");\n\t\tacmnlmsg.nlmsg_header.nlmsg_len +=\n\t\t\tNLA_ALIGN(sizeof(struct acm_nl_path));\n\t\tacmnlmsg.path[0].attr_hdr.nla_type = LS_NLA_TYPE_PATH_RECORD;\n\t\tacmnlmsg.path[0].attr_hdr.nla_len = sizeof(struct acm_nl_path);\n\t\tif (orig->resolve_header.path_use ==\n\t\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_OUTBOUND;\n\t\telse\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_GMP | IB_PATH_BIDIRECTIONAL;\n\t\tmemcpy(acmnlmsg.path[0].rec.path_rec,\n\t\t       &msg->resolve_data[0].info.path,\n\t\t       sizeof(struct ibv_path_record));\n\t}\n\n\tdatalen = NLMSG_ALIGN(acmnlmsg.nlmsg_header.nlmsg_len);\n\tret = sendto(sock, &acmnlmsg, datalen, 0,\n\t\t     (const struct sockaddr *)&dst_addr,\n\t\t     (socklen_t)sizeof(dst_addr));\n\tif (ret != datalen) {\n\t\tacm_log(0, \"ERROR - sendto = %d errno = %d\\n\", ret, errno);\n\t\tret = -1;\n\t} else {\n\t\tret = msg->hdr.length;\n\t}\n\n\tfree(orig);\n\n\treturn ret;\n}\n\n#define NLA_LEN(nla)\t((nla)->nla_len - NLA_HDRLEN)\n#define NLA_DATA(nla)\t((char *)(nla) + NLA_HDRLEN)\n\nstatic int acm_nl_parse_path_attr(struct nlattr *attr,\n\t\t\t\t   struct acm_ep_addr_data *data)\n{\n\tstruct ibv_path_record *path;\n\tuint64_t  *sid;\n\tstruct rdma_nla_ls_gid *gid;\n\tuint8_t *tcl;\n\tuint16_t *pkey;\n\tuint16_t *qos;\n\tuint16_t val;\n\tint ret = 0;\n\n#define IBV_PATH_RECORD_QOS_MASK 0xfff0\n\n\tpath = &data->info.path;\n\tswitch (attr->nla_type & RDMA_NLA_TYPE_MASK) {\n\tcase LS_NLA_TYPE_SERVICE_ID:\n\t\tsid = (uint64_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*sid)) {\n\t\t\tacm_log(2, \"service_id 0x%\" PRIx64 \"\\n\", *sid);\n\t\t\tpath->service_id = htobe64(*sid);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_DGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path dgid %s\\n\", log_data);\n\t\t\tmemcpy(path->dgid.raw, gid->gid, sizeof(path->dgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_DEST;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_SGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path sgid %s\\n\", log_data);\n\t\t\tmemcpy(path->sgid.raw, gid->gid, sizeof(path->sgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_SOURCE;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_TCLASS:\n\t\ttcl = (uint8_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*tcl)) {\n\t\t\tacm_log(2, \"tclass 0x%x\\n\", *tcl);\n\t\t\tpath->tclass = *tcl;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_PKEY:\n\t\tpkey = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*pkey)) {\n\t\t\tacm_log(2, \"pkey 0x%x\\n\", *pkey);\n\t\t\tpath->pkey = htobe16(*pkey);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_QOS_CLASS:\n\t\tqos = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*qos)) {\n\t\t\tacm_log(2, \"qos_class 0x%x\\n\", *qos);\n\t\t\tval = be16toh(path->qosclass_sl);\n\t\t\tval &= ~IBV_PATH_RECORD_QOS_MASK;\n\t\t\tval |= (*qos & IBV_PATH_RECORD_QOS_MASK);\n\t\t\tpath->qosclass_sl = htobe16(val);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tacm_log(1, \"WARN: unknown attr %x\\n\", attr->nla_type);\n\t\t/* We can not ignore a mandatory attribute */\n\t\tif (attr->nla_type & RDMA_NLA_F_MANDATORY)\n\t\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void acm_nl_process_invalid_request(struct acmc_client *client,\n\t\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_EINVAL;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\n\tacm_nl_send(client->sock, &msg);\n}\n\nstatic void acm_nl_process_resolve(struct acmc_client *client,\n\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\tstruct nlattr *attr;\n\tint payload_len;\n\tint resolve_hdr_len;\n\tint rem;\n\tint total_attr_len;\n\tint status;\n\tunsigned char *data;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_SUCCESS;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\tmsg.resolve_data[0].type = ACM_EP_INFO_PATH;\n\n\t/* We support only one pathrecord */\n\tacm_log(2, \"path use 0x%x\\n\", acmnlmsg->resolve_header.path_use);\n\tif (acmnlmsg->resolve_header.path_use ==\n\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\tmsg.resolve_data[0].info.path.reversible_numpath = 1;\n\telse\n\t\tmsg.resolve_data[0].info.path.reversible_numpath =\n\t\t\tIBV_PATH_RECORD_REVERSIBLE | 1;\n\n\tdata = (unsigned char *) &acmnlmsg->nlmsg_header + NLMSG_HDRLEN;\n\tresolve_hdr_len = NLMSG_ALIGN(sizeof(struct rdma_ls_resolve_header));\n\tattr = (struct nlattr *) (data + resolve_hdr_len);\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN -\n\t\tresolve_hdr_len;\n\trem = payload_len;\n\twhile (1) {\n\t\tif (rem < (int) sizeof(*attr) ||\n\t\t    attr->nla_len < sizeof(*attr) ||\n\t\t    attr->nla_len > rem)\n\t\t\tbreak;\n\n\t\tstatus = acm_nl_parse_path_attr(attr, &msg.resolve_data[0]);\n\t\tif (status) {\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Next attribute */\n\t\ttotal_attr_len = NLA_ALIGN(attr->nla_len);\n\t\trem -= total_attr_len;\n\t\tattr = (struct nlattr *) ((char *) attr + total_attr_len);\n\t}\n\n\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\tacm_svr_resolve(client, &msg);\n}\n\nstatic int acm_nl_is_valid_resolve_request(struct acm_nl_msg *acmnlmsg)\n{\n\tint payload_len;\n\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN;\n\tif (payload_len < (sizeof(struct rdma_ls_resolve_header) +\n\t\t\t   sizeof(struct nlattr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void acm_nl_receive(struct acmc_client *client)\n{\n\tstruct acm_nl_msg *acmnlmsg;\n\tint datalen = sizeof(*acmnlmsg);\n\tint ret;\n\tuint16_t client_inx, op;\n\n\tacmnlmsg = calloc(1, sizeof(*acmnlmsg));\n\tif (!acmnlmsg) {\n\t\tacm_log(0, \"Out of memory for recving nl msg.\\n\");\n\t\treturn;\n\t}\n\tret = recv(client->sock, acmnlmsg, datalen, 0);\n\tif (!NLMSG_OK(&acmnlmsg->nlmsg_header, ret)) {\n\t\tacm_log(0, \"Netlink receive error: %d.\\n\", ret);\n\t\tgoto rcv_cleanup;\n\t}\n\n\tacm_log(2, \"nlmsg: len %d type 0x%x flags 0x%x seq %d pid %d\\n\",\n\t\tacmnlmsg->nlmsg_header.nlmsg_len,\n\t\tacmnlmsg->nlmsg_header.nlmsg_type,\n\t\tacmnlmsg->nlmsg_header.nlmsg_flags,\n\t\tacmnlmsg->nlmsg_header.nlmsg_seq,\n\t\tacmnlmsg->nlmsg_header.nlmsg_pid);\n\n\t/* Currently we handle only request from the local service client */\n\tclient_inx = RDMA_NL_GET_CLIENT(acmnlmsg->nlmsg_header.nlmsg_type);\n\top = RDMA_NL_GET_OP(acmnlmsg->nlmsg_header.nlmsg_type);\n\tif (client_inx != RDMA_NL_LS) {\n\t\tacm_log_once(0, \"ERROR - Unknown NL client ID (%d)\\n\", client_inx);\n\t\tgoto rcv_cleanup;\n\t}\n\n\tswitch (op) {\n\tcase RDMA_NL_LS_OP_RESOLVE:\n\t\tif (acm_nl_is_valid_resolve_request(acmnlmsg))\n\t\t\tacm_nl_process_resolve(client, acmnlmsg);\n\t\telse\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\tdefault:\n\t\t/* Not supported*/\n\t\tacm_log_once(0, \"WARN - invalid opcode %x\\n\", op);\n\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\t}\n\n\treturn;\nrcv_cleanup:\n\tfree(acmnlmsg);\n}\n\nstatic int acm_init_nl(void)\n{\n\tstruct sockaddr_nl src_addr;\n\tint ret;\n\tint nl_rcv_socket;\n\n\tnl_rcv_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_RDMA);\n\tif (nl_rcv_socket == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate netlink recv socket\\n\");\n\t\treturn errno;\n\t}\n\n\tmemset(&src_addr, 0, sizeof(src_addr));\n\tsrc_addr.nl_family = AF_NETLINK;\n\tsrc_addr.nl_pid = getpid();\n\tsrc_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tret = bind(nl_rcv_socket, (struct sockaddr *)&src_addr,\n\t\t   sizeof(src_addr));\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to bind netlink socket\\n\");\n\t\tclose(nl_rcv_socket);\n\t\treturn errno;\n\t}\n\n\t/* init nl client structure */\n\tclient_array[NL_CLIENT_INDEX].sock = nl_rcv_socket;\n\treturn 0;\n}\n\nstatic void acm_server(bool systemd)\n{\n\tfd_set readfds;\n\tint i, n, ret;\n\tstruct acmc_device *dev;\n\n\tacm_log(0, \"started\\n\");\n\tacm_init_server();\n\n\tclient_array[NL_CLIENT_INDEX].sock = -1;\n\tlisten_socket = -1;\n\tif (systemd) {\n\t\tret = acm_listen_systemd();\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - systemd server listen failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (listen_socket == -1) {\n\t\tret = acm_listen();\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - server listen failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (client_array[NL_CLIENT_INDEX].sock == -1) {\n\t\tret = acm_init_nl();\n\t\tif (ret)\n\t\t\tacm_log(1, \"Warn - Netlink init failed\\n\");\n\t}\n\n\tif (systemd)\n\t\tsd_notify(0, \"READY=1\");\n\n\twhile (1) {\n\t\tn = (int) listen_socket;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(listen_socket, &readfds);\n\t\tn = max(n, (int) ip_mon_socket);\n\t\tFD_SET(ip_mon_socket, &readfds);\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1) {\n\t\t\t\tFD_SET(client_array[i].sock, &readfds);\n\t\t\t\tn = max(n, (int) client_array[i].sock);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tFD_SET(dev->device.verbs->async_fd, &readfds);\n\t\t\tn = max(n, (int) dev->device.verbs->async_fd);\n\t\t}\n\n\t\tret = select(n + 1, &readfds, NULL, NULL, NULL);\n\t\tif (ret == -1) {\n\t\t\tacm_log(0, \"ERROR - server select error\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(listen_socket, &readfds))\n\t\t\tacm_svr_accept();\n\n\t\tif (FD_ISSET(ip_mon_socket, &readfds))\n\t\t\tacm_ipnl_handler();\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1 &&\n\t\t\t\tFD_ISSET(client_array[i].sock, &readfds)) {\n\t\t\t\tacm_log(2, \"receiving from client %d\\n\", i);\n\t\t\t\tif (i == NL_CLIENT_INDEX)\n\t\t\t\t\tacm_nl_receive(&client_array[i]);\n\t\t\t\telse\n\t\t\t\t\tacm_svr_receive(&client_array[i]);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tif (FD_ISSET(dev->device.verbs->async_fd, &readfds)) {\n\t\t\t\tacm_log(2, \"handling event from %s\\n\",\n\t\t\t\t\tdev->device.verbs->device->name);\n\t\t\t\tacm_event_handler(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum ibv_rate acm_get_rate(uint8_t width, uint8_t speed)\n{\n\tswitch (width) {\n\tcase 1: /* 1x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_2_5_GBPS;\n\t\tcase 2: return IBV_RATE_5_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_10_GBPS;\n\t\tcase 16: return IBV_RATE_14_GBPS;\n\t\tcase 32: return IBV_RATE_25_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 2: /* 4x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_10_GBPS;\n\t\tcase 2: return IBV_RATE_20_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_40_GBPS;\n\t\tcase 16: return IBV_RATE_56_GBPS;\n\t\tcase 32: return IBV_RATE_100_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 4: /* 8x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_20_GBPS;\n\t\tcase 2: return IBV_RATE_40_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_80_GBPS;\n\t\tcase 16: return IBV_RATE_112_GBPS;\n\t\tcase 32: return IBV_RATE_200_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 8: /* 12x */\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_30_GBPS;\n\t\tcase 2: return IBV_RATE_60_GBPS;\n\t\tcase 4: /* fall through */\n\t\tcase 8: return IBV_RATE_120_GBPS;\n\t\tcase 16: return IBV_RATE_168_GBPS;\n\t\tcase 32: return IBV_RATE_300_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown link width 0x%x\\n\", width);\n\t\treturn IBV_RATE_MAX;\n\t}\n}\n\nenum ibv_mtu acm_convert_mtu(int mtu)\n{\n\tswitch (mtu) {\n\tcase 256:  return IBV_MTU_256;\n\tcase 512:  return IBV_MTU_512;\n\tcase 1024: return IBV_MTU_1024;\n\tcase 2048: return IBV_MTU_2048;\n\tcase 4096: return IBV_MTU_4096;\n\tdefault:   return IBV_MTU_2048;\n\t}\n}\n\nenum ibv_rate acm_convert_rate(int rate)\n{\n\tswitch (rate) {\n\tcase 2:   return IBV_RATE_2_5_GBPS;\n\tcase 5:   return IBV_RATE_5_GBPS;\n\tcase 10:  return IBV_RATE_10_GBPS;\n\tcase 20:  return IBV_RATE_20_GBPS;\n\tcase 30:  return IBV_RATE_30_GBPS;\n\tcase 40:  return IBV_RATE_40_GBPS;\n\tcase 60:  return IBV_RATE_60_GBPS;\n\tcase 80:  return IBV_RATE_80_GBPS;\n\tcase 120: return IBV_RATE_120_GBPS;\n\tcase 14:  return IBV_RATE_14_GBPS;\n\tcase 56:  return IBV_RATE_56_GBPS;\n\tcase 112: return IBV_RATE_112_GBPS;\n\tcase 168: return IBV_RATE_168_GBPS;\n\tcase 25:  return IBV_RATE_25_GBPS;\n\tcase 100: return IBV_RATE_100_GBPS;\n\tcase 200: return IBV_RATE_200_GBPS;\n\tcase 300: return IBV_RATE_300_GBPS;\n\tdefault:  return IBV_RATE_10_GBPS;\n\t}\n}\n\nstatic FILE *acm_open_addr_file(void)\n{\n\tFILE *f;\n\n\tif ((f = fopen(addr_file, \"r\")))\n\t\treturn f;\n\n\tacm_log(0, \"notice - generating %s file\\n\", addr_file);\n\tif (!(f = popen(acme, \"r\"))) {\n\t\tacm_log(0, \"ERROR - cannot generate %s\\n\", addr_file);\n\t\treturn NULL;\n\t}\n\tpclose(f);\n\treturn fopen(addr_file, \"r\");\n}\n\nstatic int\n__acm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t   uint8_t addr_type)\n{\n\tint i;\n\tint ret;\n\tuint8_t tmp[ACM_MAX_ADDRESS] = {};\n\n\tmemcpy(tmp, addr, acm_addr_len(addr_type));\n\n\tfor (i = 0; (i < ep->nmbr_ep_addrs) &&\n\t\t     (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID); i++)\n\t\t;\n\tif (i == ep->nmbr_ep_addrs) {\n\t\tstruct acmc_addr *new_info;\n\t\tint j;\n\n\t\tnew_info = realloc(ep->addr_info, (i + 1) * sizeof(*ep->addr_info));\n\t\tif (!new_info) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* id_string needs to point to the reallocated string_buf */\n\t\tfor (j = 0; (j < ep->nmbr_ep_addrs); j++) {\n\t\t\tnew_info[j].addr.id_string = new_info[j].string_buf;\n\t\t}\n\n\t\tep->addr_info = new_info;\n\n\t\t/* Added memory is not initialized */\n\t\tmemset(ep->addr_info + i, 0, sizeof(*ep->addr_info));\n\t\tep->addr_info[i].addr.endpoint = &ep->endpoint;\n\t\tep->addr_info[i].addr.id_string = ep->addr_info[i].string_buf;\n\t\t++ep->nmbr_ep_addrs;\n\t}\n\n\t/* Open the provider endpoint only if at least a name or\n\t   address is found */\n\tif (!ep->prov_ep_context) {\n\t\tret = ep->port->prov->open_endpoint(&ep->endpoint,\n\t\t\t\t\t\t    ep->port->prov_port_context,\n\t\t\t\t\t\t    &ep->prov_ep_context);\n\t\tif (ret) {\n\t\t\tacm_log(0, \"Error: failed to open prov ep\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tep->addr_info[i].addr.type = addr_type;\n\tif (!check_snprintf(ep->addr_info[i].string_buf,\n\t\t\t    sizeof(ep->addr_info[i].string_buf), \"%s\", name))\n\t\treturn EINVAL;\n\tmemcpy(ep->addr_info[i].addr.info.addr, tmp, ACM_MAX_ADDRESS);\n\tret = ep->port->prov->add_address(&ep->addr_info[i].addr,\n\t\t\t\t\t  ep->prov_ep_context,\n\t\t\t\t\t  &ep->addr_info[i].prov_addr_context);\n\tif (ret) {\n\t\tacm_log(0, \"Error: failed to add addr to provider\\n\");\n\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int\nacm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t   uint8_t addr_type)\n{\n\tint ret = -1;\n\n\tif (!acm_addr_lookup(&ep->endpoint, addr, addr_type)) {\n\t\tret = __acm_ep_insert_addr(ep, name, addr, addr_type);\n\t}\n\n\treturn ret;\n}\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (*port = 1; *port <= dev->port_cnt; (*port)++) {\n\n\t\t\tfor (i = 0; i < dev->port[*port - 1].gid_cnt; i++) {\n\n\t\t\t\tif (!memcmp(sgid->raw,\n\t\t\t\t\t    dev->port[*port - 1].gid_tbl[i].raw,\n\t\t\t\t\t    sizeof(*sgid)))\n\t\t\t\t\treturn dev;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_ep_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr,\n\t\tchar *ip_str, void *ctx)\n{\n\tuint8_t port_num;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep = ctx;\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev && ep->port->dev == dev\n\t    && ep->port->port.port_num == port_num &&\n\t\t/* pkey retrieved from ipoib has always full mmbr bit set */\n\t\t(ep->endpoint.pkey | IB_PKEY_FULL_MEMBER) == pkey) {\n\t\tif (!acm_ep_insert_addr(ep, ip_str, addr, addr_type)) {\n\t\t\tacm_log(0, \"Added %s %s %d 0x%x from %s\\n\", ip_str,\n\t\t\t\tdev->device.verbs->device->name, port_num, ep->endpoint.pkey,\n\t\t\t\tifname);\n\t\t}\n\t}\n}\n\nstatic int acm_get_system_ips(struct acmc_ep *ep)\n{\n\treturn acm_if_iter_sys(acm_ep_ip_iter_cb, ep);\n}\n\nstatic int acm_assign_ep_names(struct acmc_ep *ep)\n{\n\tFILE *faddr;\n\tchar *dev_name;\n\tchar s[120];\n\tchar dev[32], name[ACM_MAX_ADDRESS], pkey_str[8];\n\tuint16_t pkey;\n\tuint8_t addr[ACM_MAX_ADDRESS], type;\n\tint port;\n\n\tdev_name = ep->port->dev->device.verbs->device->name;\n\tacm_log(1, \"device %s, port %d, pkey 0x%x\\n\",\n\t\tdev_name, ep->port->port.port_num, ep->endpoint.pkey);\n\n\tacm_get_system_ips(ep);\n\n\tif (!(faddr = acm_open_addr_file())) {\n\t\tacm_log(0, \"ERROR - address file not found\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (fgets(s, sizeof s, faddr)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%46s%31s%d%7s\", name, dev, &port, pkey_str) != 4)\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"%s\", s);\n\t\tif (inet_pton(AF_INET, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP;\n\t\t} else if (inet_pton(AF_INET6, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP6;\n\t\t} else {\n\t\t\ttype = ACM_ADDRESS_NAME;\n\t\t\tstrncpy((char *)addr, name, sizeof(addr));\n\t\t}\n\n\t\tif (strcasecmp(pkey_str, \"default\")) {\n\t\t\tif (sscanf(pkey_str, \"%hx\", &pkey) != 1) {\n\t\t\t\tacm_log(0, \"ERROR - bad pkey format %s\\n\", pkey_str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tpkey = ep->port->def_acm_pkey;\n\t\t}\n\n\t\tif (!strcasecmp(dev_name, dev) &&\n\t\t    (ep->port->port.port_num == (uint8_t) port) &&\n\t\t    acm_same_partition(ep->endpoint.pkey, pkey)) {\n\t\t\tacm_log(1, \"assigning %s\\n\", name);\n\t\t\tif (acm_ep_insert_addr(ep, name, addr, type)) {\n\t\t\t\tacm_log(1, \"maximum number of names assigned to EP\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(faddr);\n\nout:\n\treturn (!ep->nmbr_ep_addrs || ep->addr_info[0].addr.type == ACM_ADDRESS_INVALID);\n}\n\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep, *res = NULL;\n\n\tacm_log(2, \"pkey 0x%x\\n\", pkey);\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif (acm_same_partition(ep->endpoint.pkey, pkey)) {\n\t\t\tres = ep;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void acm_ep_down(struct acmc_ep *ep)\n{\n\tint i;\n\n\tacm_log(1, \"%s %d pkey 0x%04x\\n\",\n\t\tep->port->dev->device.verbs->device->name,\n\t\tep->port->port.port_num, ep->endpoint.pkey);\n\n\tfor (i = 0; i < ep->nmbr_ep_addrs; i++) {\n\t\tif (ep->addr_info[i].addr.type &&\n\t\t    ep->addr_info[i].prov_addr_context)\n\t\t\tep->port->prov->remove_address(ep->addr_info[i].\n\t\t\t\t\t\t       prov_addr_context);\n\t}\n\n\tif (ep->prov_ep_context)\n\t\tep->port->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic struct acmc_ep *\nacm_alloc_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\n\tacm_log(1, \"\\n\");\n\tep = calloc(1, sizeof *ep);\n\tif (!ep)\n\t\treturn NULL;\n\n\tep->port = port;\n\tep->endpoint.port = &port->port;\n\tep->endpoint.pkey = pkey;\n\tep->addr_info = NULL;\n\tep->nmbr_ep_addrs = 0;\n\n\treturn ep;\n}\n\nstatic void acm_ep_up(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\tint ret;\n\n\tacm_log(1, \"\\n\");\n\tif (acm_find_ep(port, pkey)) {\n\t\tacm_log(2, \"endpoint for pkey 0x%x already exists\\n\", pkey);\n\t\treturn;\n\t}\n\n\tacm_log(2, \"creating endpoint for pkey 0x%x\\n\", pkey);\n\tep = acm_alloc_ep(port, pkey);\n\tif (!ep)\n\t\treturn;\n\n\tret = acm_assign_ep_names(ep);\n\tif (ret) {\n\t\tacm_log(1, \"unable to assign EP name for pkey 0x%x\\n\", pkey);\n\t\tgoto ep_close;\n\t}\n\n\tlist_add(&port->ep_list, &ep->entry);\n\treturn;\n\nep_close:\n\tif (ep->prov_ep_context)\n\t\tport->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic void acm_assign_provider(struct acmc_port *port)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(2, \"port %s/%d\\n\", port->port.dev->verbs->device->name,\n\t\tport->port.port_num);\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tlist_for_each(&prov->subnet_list, subnet, entry) {\n\t\t\tif (subnet->subnet_prefix ==\n\t\t\t    port->gid_tbl[0].global.subnet_prefix) {\n\t\t\t\tacm_log(2, \"Found provider %s for port %s/%d\\n\",\n\t\t\t\t\tprov->prov->name,\n\t\t\t\t\tport->port.dev->verbs->device->name,\n\t\t\t\t\tport->port.port_num);\n\t\t\t\tport->prov = prov->prov;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If no provider is found, assign the default provider*/\n\tif (!port->prov) {\n\t\tacm_log(2, \"No prov found, assign default prov %s to %s/%d\\n\",\n\t\t\tdef_provider ? def_provider->prov->name: \"NULL\",\n\t\t\tport->port.dev->verbs->device->name,\n\t\t\tport->port.port_num);\n\t\tport->prov = def_provider ? def_provider->prov : NULL;\n\t}\n}\n\nstatic void acm_port_get_gid_tbl(struct acmc_port *port)\n{\n\tunion ibv_gid gid;\n\tint i, j, ret;\n\n\tfor (i = 0;; i++) {\n\t\tret = ibv_query_gid(port->port.dev->verbs, port->port.port_num,\n\t\t\t\t    i, &gid);\n\t\tif (ret || !gid.global.interface_id)\n\t\t\tbreak;\n\t}\n\n\tif (i > 0) {\n\t\tport->gid_tbl = calloc(i, sizeof(union ibv_gid));\n\t\tif (!port->gid_tbl) {\n\t\t\tacm_log(0, \"Error: failed to allocate gid table\\n\");\n\t\t\tport->gid_cnt = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tret = ibv_query_gid(port->port.dev->verbs,\n\t\t\t\t\t    port->port.port_num, j,\n\t\t\t\t\t    &port->gid_tbl[j]);\n\t\t\tif (ret || !port->gid_tbl[j].global.interface_id)\n\t\t\t\tbreak;\n\t\t\tacm_log(2, \"guid %d: 0x%\" PRIx64 \" %\" PRIx64 \"\\n\", j,\n\t\t\t\tbe64toh(port->gid_tbl[j].global.subnet_prefix),\n\t\t\t\tbe64toh(port->gid_tbl[j].global.interface_id));\n\t\t}\n\t\tport->gid_cnt = j;\n\t}\n\tacm_log(2, \"port %d gid_cnt %d\\n\", port->port.port_num,\n\t\tport->gid_cnt);\n}\n\nstatic void acm_port_up(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tuint16_t pkey;\n\t__be16 pkey_be;\n\tint i, ret;\n\tstruct acmc_prov_context *dev_ctx;\n\tint index = -1;\n\tuint16_t first_pkey = 0;\n\n\tacm_log(1, \"%s %d\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n\tret = ibv_query_port(port->dev->device.verbs, port->port.port_num,\n\t\t\t     &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to get port state\\n\");\n\t\treturn;\n\t}\n\tif (attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active\\n\");\n\t\treturn;\n\t}\n\n\tacm_port_get_gid_tbl(port);\n\tport->lid = attr.lid;\n\tport->lid_mask = 0xffff - ((1 << attr.lmc) - 1);\n\tport->sa_addr.lid = htobe16(attr.sm_lid);\n\tport->sa_addr.sl = attr.sm_sl;\n\tport->state = IBV_PORT_ACTIVE;\n\tacm_assign_provider(port);\n\tif (!port->prov) {\n\t\tacm_log(1, \"no provider assigned to port\\n\");\n\t\treturn;\n\t}\n\tdev_ctx = acm_acquire_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t   port->prov);\n\tif (!dev_ctx) {\n\t\tacm_log(0, \"Error -- failed to acquire dev context\\n\");\n\t\treturn;\n\t}\n\n\tif (atomic_get(&dev_ctx->refcnt) == 1) {\n\t\tif (port->prov->open_device(&port->dev->device, &dev_ctx->context)) {\n\t\t\tacm_log(0, \"Error -- failed to open the prov device\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tif (port->prov->open_port(&port->port, dev_ctx->context,\n\t\t\t\t  &port->prov_port_context)) {\n\t\tacm_log(0, \"Error -- failed to open the prov port\\n\");\n\t\tgoto err1;\n\t}\n\n\t/* Determine the default pkey for SA access first.\n\t *     Order of preference: 0xffff, 0x7fff\n\t * Use the first pkey as the default pkey for parsing address file.\n\t */\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey_be);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey_be);\n\t\tif (i == 0)\n\t\t\tfirst_pkey = pkey;\n\t\tif (pkey == 0xffff) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\telse if (pkey == 0x7fff) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tport->sa_pkey_index = index < 0 ? 0 : index;\n\tport->def_acm_pkey = first_pkey;\n\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey_be);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey_be);\n\t\tif (!(pkey & 0x7fff))\n\t\t\tcontinue;\n\n\t\tacm_ep_up(port, pkey);\n\t}\n\treturn;\nerr1:\n\tacm_release_prov_context(dev_ctx);\n}\n\nstatic void acm_shutdown_port(struct acmc_port *port)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_prov_context *dev_ctx;\n\n\twhile ((ep = list_pop(&port->ep_list, struct acmc_ep, entry)))\n\t\tacm_ep_down(ep);\n\n\tif (port->prov_port_context) {\n\t\tport->prov->close_port(port->prov_port_context);\n\t\tport->prov_port_context = NULL;\n\t\tdev_ctx = acm_get_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t       port->prov);\n\t\tif (dev_ctx) {\n\t\t\tif (atomic_get(&dev_ctx->refcnt) == 1)\n\t\t\t\tport->prov->close_device(dev_ctx->context);\n\t\t\tacm_release_prov_context(dev_ctx);\n\t\t}\n\t}\n\tport->prov = NULL;\n\tif (port->gid_tbl) {\n\t\tfree(port->gid_tbl);\n\t\tport->gid_tbl = NULL;\n\t}\n\tport->gid_cnt = 0;\n}\n\nstatic void acm_port_down(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (!ret && attr.state == IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port active\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\n\tacm_log(1, \"%s %d is down\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n}\n\nstatic void acm_port_change(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (ret || attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active: don't care\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\tacm_port_up(port);\n}\n\nstatic void acm_event_handler(struct acmc_device *dev)\n{\n\tstruct ibv_async_event event;\n\tint i, ret;\n\n\tret = ibv_get_async_event(dev->device.verbs, &event);\n\tif (ret)\n\t\treturn;\n\n\tacm_log(2, \"processing async event %s for %s\\n\",\n\t\tibv_event_type_str(event.event_type),\n\t\tdev->device.verbs->device->name);\n\ti = event.element.port_num - 1;\n\n\tswitch (event.event_type) {\n\tcase IBV_EVENT_PORT_ACTIVE:\n\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\tacm_port_up(&dev->port[i]);\n\t\tif (dev->port[i].pending_rereg && dev->port[i].prov_port_context) {\n\t\t\tdev->port[i].prov->handle_event(dev->port[i].prov_port_context,\n\t\t\t\t\t\t\tIBV_EVENT_CLIENT_REREGISTER);\n\t\t\tdev->port[i].pending_rereg = false;\n\t\t\tacm_log(1, \"%s %d delayed reregistration\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t}\n\n\t\tbreak;\n\tcase IBV_EVENT_PORT_ERR:\n\t\tif (dev->port[i].state == IBV_PORT_ACTIVE)\n\t\t\tacm_port_down(&dev->port[i]);\n\t\tbreak;\n\tcase IBV_EVENT_CLIENT_REREGISTER:\n\t\tif ((dev->port[i].state == IBV_PORT_ACTIVE) &&\n\t\t    dev->port[i].prov_port_context) {\n\t\t\tdev->port[i].prov->handle_event(dev->port[i].prov_port_context,\n\t\t\t\t\t\t\tevent.event_type);\n\t\t\tacm_log(1, \"%s %d has reregistered\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t} else {\n\t\t\tacm_log(2, \"%s %d rereg on inactive port, postpone handling\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t\tdev->port[i].pending_rereg = true;\n\t\t}\n\n\t\tbreak;\n\tcase IBV_EVENT_LID_CHANGE:\n\tcase IBV_EVENT_GID_CHANGE:\n\tcase IBV_EVENT_PKEY_CHANGE:\n\t\tacm_port_change(&dev->port[i]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tibv_ack_async_event(&event);\n}\n\nstatic void acm_activate_devices(void)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tacm_port_up(&dev->port[i]);\n\t\t}\n\t}\n}\n\nstatic void\nacm_open_port(struct acmc_port *port, struct acmc_device *dev, uint8_t port_num)\n{\n\tacm_log(1, \"%s %d\\n\", dev->device.verbs->device->name, port_num);\n\tport->dev = dev;\n\tport->port.dev = &dev->device;\n\tport->port.port_num = port_num;\n\tpthread_mutex_init(&port->lock, NULL);\n\tlist_head_init(&port->ep_list);\n\tlist_head_init(&port->sa_pending);\n\tlist_head_init(&port->sa_wait);\n\tport->sa_credits = sa.depth;\n\tport->sa_addr.qpn = htobe32(1);\n\tport->sa_addr.qkey = htobe32(ACM_QKEY);\n\n\tport->mad_portid = umad_open_port(dev->device.verbs->device->name, port_num);\n\tif (port->mad_portid < 0)\n\t\tacm_log(0, \"ERROR - unable to open MAD port\\n\");\n\n\tport->mad_agentid = umad_register(port->mad_portid,\n\t\t\t\t\t  IB_MGMT_CLASS_SA, 1, 1, NULL);\n\tif (port->mad_agentid < 0) {\n\t\tumad_close_port(port->mad_portid);\n\t\tacm_log(0, \"ERROR - unable to register MAD client\\n\");\n\t}\n\n\tport->prov = NULL;\n\tport->state = IBV_PORT_DOWN;\n}\n\nstatic void acm_open_dev(struct ibv_device *ibdev)\n{\n\tstruct acmc_device *dev;\n\tstruct ibv_device_attr attr;\n\tstruct ibv_port_attr port_attr;\n\tstruct ibv_context *verbs;\n\tsize_t size;\n\tint i, ret;\n\tbool has_ib_port = false;\n\n\tacm_log(1, \"%s\\n\", ibdev->name);\n\tverbs = ibv_open_device(ibdev);\n\tif (verbs == NULL) {\n\t\tacm_log(0, \"ERROR - opening device %s\\n\", ibdev->name);\n\t\treturn;\n\t}\n\n\tret = ibv_query_device(verbs, &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - ibv_query_device (%d) %s\\n\", ret, ibdev->name);\n\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < attr.phys_port_cnt; i++) {\n\t\tret = ibv_query_port(verbs, i + 1, &port_attr);\n\t\tif (ret) {\n\t\t\tacm_log(0, \"ERROR - ibv_query_port (%s, %d) return (%d)\\n\",\n\t\t\t\tibdev->name, i + 1, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port_attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {\n\t\t\tacm_log(1, \"%s port %d is an InfiniBand port\\n\", ibdev->name, i + 1);\n\t\t\thas_ib_port = true;\n\t\t} else {\n\t\t\tacm_log(1, \"%s port %d is not an InfiniBand port\\n\", ibdev->name, i + 1);\n\t\t}\n\t}\n\n\tif (!has_ib_port) {\n\t\tacm_log(1, \"%s does not support InfiniBand.\\n\", ibdev->name);\n\t\tgoto err1;\n\t}\n\n\tsize = sizeof(*dev) + sizeof(struct acmc_port) * attr.phys_port_cnt;\n\tdev = (struct acmc_device *) calloc(1, size);\n\tif (!dev)\n\t\tgoto err1;\n\n\tdev->device.verbs = verbs;\n\tdev->device.dev_guid = ibv_get_device_guid(ibdev);\n\tdev->port_cnt = attr.phys_port_cnt;\n\tlist_head_init(&dev->prov_dev_context_list);\n\n\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\tacm_open_port(&dev->port[i], dev, i + 1);\n\t}\n\n\tlist_add(&dev_list, &dev->entry);\n\n\tacm_log(1, \"%s opened\\n\", ibdev->name);\n\treturn;\n\nerr1:\n\tibv_close_device(verbs);\n}\n\nstatic int acm_open_devices(void)\n{\n\tstruct ibv_device **ibdev;\n\tint dev_cnt;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tibdev = ibv_get_device_list(&dev_cnt);\n\tif (!ibdev) {\n\t\tacm_log(0, \"ERROR - unable to get device list\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < dev_cnt; i++)\n\t\tacm_open_dev(ibdev[i]);\n\n\tibv_free_device_list(ibdev);\n\tif (list_empty(&dev_list)) {\n\t\tacm_log(0, \"ERROR - no devices\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_load_prov_config(void)\n{\n\tFILE *fd;\n\tchar s[128];\n\tchar *p, *ptr;\n\tchar prov_name[ACM_PROV_NAME_SIZE];\n\tuint64_t prefix;\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tif (!(fd = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, fd)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* Ignore blank lines */\n\t\tif (!(p = strtok_r(s, \" \\n\", &ptr)))\n\t\t\tcontinue;\n\n\t\tif (strncasecmp(p, \"provider\", sizeof(\"provider\") - 1))\n\t\t\tcontinue;\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tstrncpy(prov_name, p, sizeof(prov_name));\n\t\tprov_name[sizeof(prov_name) -1] = '\\0';\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(p, \"default\", sizeof(\"default\") - 1)) {\n\t\t\tstrncpy(def_prov_name, prov_name, sizeof(def_prov_name));\n\t\t\tdef_prov_name[sizeof(def_prov_name) -1] = '\\0';\n\t\t\tacm_log(2, \"default provider: %s\\n\", def_prov_name);\n\t\t\tcontinue;\n\t\t}\n\t\tprefix = strtoull(p, NULL, 0);\n\t\tacm_log(2, \"provider %s subnet_prefix 0x%\" PRIx64 \"\\n\",\n\t\t\tprov_name, prefix);\n\n\t\tlist_for_each(&provider_list, prov, entry) {\n\t\t\tif (!strcasecmp(prov->prov->name, prov_name)) {\n\t\t\t\tsubnet = calloc(1, sizeof (*subnet));\n\t\t\t\tif (!subnet) {\n\t\t\t\t\tacm_log(0, \"Error: out of memory\\n\");\n\t\t\t\t\tfclose(fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsubnet->subnet_prefix = htobe64(prefix);\n\t\t\t\tlist_add_tail(&prov->subnet_list,\n\t\t\t\t\t      &subnet->entry);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fd);\n\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tif (!strcasecmp(prov->prov->name, def_prov_name)) {\n\t\t\tdef_provider = prov;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int acm_string_end_compare(const char *s1, const char *s2)\n{\n\tsize_t s1_len = strlen(s1);\n\tsize_t s2_len = strlen(s2);\n\n\tif (s1_len < s2_len)\n\t\treturn -1;\n\n\treturn strcmp(s1 + s1_len - s2_len, s2);\n}\n\nstatic int acm_open_providers(void)\n{\n\tDIR *shlib_dir;\n\tstruct dirent *dent;\n\tchar file_name[256];\n\tstruct stat buf;\n\tvoid *handle;\n\tstruct acmc_prov *prov;\n\tstruct acm_provider *provider;\n\tuint32_t version;\n\tchar *err_str;\n\tint (*query)(struct acm_provider **, uint32_t *);\n\n\tacm_log(1, \"\\n\");\n\tshlib_dir = opendir(prov_lib_path);\n\tif (!shlib_dir) {\n\t\tacm_log(0, \"ERROR - could not open provider lib dir: %s\\n\",\n\t\t\tprov_lib_path);\n\t\treturn -1;\n\t}\n\n\twhile ((dent = readdir(shlib_dir))) {\n\t\tif (acm_string_end_compare(dent->d_name, \".so\"))\n\t\t\tcontinue;\n\n\t\tif (!check_snprintf(file_name, sizeof(file_name), \"%s/%s\",\n\t\t\t\t    prov_lib_path, dent->d_name))\n\t\t\tcontinue;\n\n\t\tif (lstat(file_name, &buf)) {\n\t\t\tacm_log(0, \"Error - could not stat: %s\\n\", file_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(buf.st_mode))\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"Loading provider %s...\\n\", file_name);\n\t\tif (!(handle = dlopen(file_name, RTLD_LAZY))) {\n\t\t\tacm_log(0, \"Error - could not load provider %s (%s)\\n\",\n\t\t\t\tfile_name, dlerror());\n\t\t\tcontinue;\n\t\t}\n\n\t\tquery = dlsym(handle, \"provider_query\");\n\t\tif ((err_str = dlerror()) != NULL) {\n\t\t\tacm_log(0, \"Error - provider_query not found in %s (%s)\\n\",\n\t\t\t\tfile_name, err_str);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (query(&provider, &version)) {\n\t\t\tacm_log(0, \"Error - provider_query failed to %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (version != ACM_PROV_VERSION ||\n\t\t    provider->size != sizeof(struct acm_provider)) {\n\t\t\tacm_log(0, \"Error -unmatched provider version 0x%08x (size %zd)\"\n\t\t\t\t\" core 0x%08x (size %zd)\\n\", version, provider->size,\n\t\t\t\tACM_PROV_VERSION, sizeof(struct acm_provider));\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacm_log(1, \"Provider %s (%s) loaded\\n\", provider->name, file_name);\n\n\t\tprov = calloc(1, sizeof(*prov));\n\t\tif (!prov) {\n\t\t\tacm_log(0, \"Error -failed to allocate provider %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprov->prov = provider;\n\t\tprov->handle = handle;\n\t\tlist_head_init(&prov->subnet_list);\n\t\tlist_add_tail(&provider_list, &prov->entry);\n\t\tif (!strcasecmp(provider->name, def_prov_name))\n\t\t\tdef_provider = prov;\n\t}\n\n\tclosedir(shlib_dir);\n\tacm_load_prov_config();\n\treturn 0;\n}\n\nstatic void acm_close_providers(void)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(1, \"\\n\");\n\tdef_provider = NULL;\n\n\twhile ((prov = list_pop(&provider_list, struct acmc_prov, entry))) {\n\t\twhile ((subnet = list_pop(&prov->subnet_list,\n\t\t\t\tstruct acmc_subnet, entry)))\n\t\t\tfree(subnet);\n\t\tdlclose(prov->handle);\n\t\tfree(prov);\n\t}\n}\n\nstatic int acmc_init_sa_fds(void)\n{\n\tstruct acmc_device *dev;\n\tint ret, p, i = 0;\n\n\tlist_for_each(&dev_list, dev, entry)\n\t\tsa.nfds += dev->port_cnt;\n\n\tsa.fds = calloc(sa.nfds, sizeof(*sa.fds));\n\tsa.ports = calloc(sa.nfds, sizeof(*sa.ports));\n\tif (!sa.fds || !sa.ports)\n\t\treturn -ENOMEM;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (p = 0; p < dev->port_cnt; p++) {\n\t\t\tsa.fds[i].fd = umad_get_fd(dev->port[p].mad_portid);\n\t\t\tsa.fds[i].events = POLLIN;\n\t\t\tret = set_fd_nonblock(sa.fds[i].fd, true);\n\t\t\tif (ret)\n\t\t\t\tacm_log(0, \"WARNING - umad fd is blocking\\n\");\n\n\t\t\tsa.ports[i++] = &dev->port[p];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct acm_sa_mad *\nacm_alloc_sa_mad(const struct acm_endpoint *endpoint, void *context,\n\t\t void (*handler)(struct acm_sa_mad *))\n{\n\tstruct acmc_sa_req *req;\n\n\tif (!endpoint) {\n\t\tacm_log(0, \"Error: NULL endpoint\\n\");\n\t\treturn NULL;\n\t}\n\treq = calloc(1, sizeof (*req));\n\tif (!req) {\n\t\tacm_log(0, \"Error: failed to allocate sa request\\n\");\n\t\treturn NULL;\n\t}\n\n\treq->ep = container_of(endpoint, struct acmc_ep, endpoint);\n\treq->mad.context = context;\n\treq->resp_handler = handler;\n\n\tacm_log(2, \"%p\\n\", req);\n\treturn &req->mad;\n}\n\nvoid acm_free_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_sa_req *req;\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p\\n\", req);\n\tfree(req);\n}\n\nint acm_send_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_port *port;\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p from %s\\n\", req, req->ep->addr_info[0].addr.id_string);\n\n\tport = req->ep->port;\n\tmad->umad.addr.qpn = port->sa_addr.qpn;\n\tmad->umad.addr.qkey = port->sa_addr.qkey;\n\tmad->umad.addr.lid = port->sa_addr.lid;\n\tmad->umad.addr.sl = port->sa_addr.sl;\n\tmad->umad.addr.pkey_index = req->ep->port->sa_pkey_index;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (port->sa_credits && list_empty(&port->sa_wait)) {\n\t\tret = umad_send(port->mad_portid, port->mad_agentid, &mad->umad,\n\t\t\t\tsizeof mad->sa_mad, sa.timeout, sa.retries);\n\t\tif (!ret) {\n\t\t\tport->sa_credits--;\n\t\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t\t}\n\t} else {\n\t\tret = 0;\n\t\tlist_add_tail(&port->sa_wait, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\treturn ret;\n}\n\nstatic void acmc_send_queued_req(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (list_empty(&port->sa_wait) || !port->sa_credits) {\n\t\tpthread_mutex_unlock(&port->lock);\n\t\treturn;\n\t}\n\n\treq = list_pop(&port->sa_wait, struct acmc_sa_req, entry);\n\n\tret = umad_send(port->mad_portid, port->mad_agentid, &req->mad.umad,\n\t\t\tsizeof req->mad.sa_mad, sa.timeout, sa.retries);\n\tif (!ret) {\n\t\tport->sa_credits--;\n\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (ret) {\n\t\treq->mad.umad.status = -ret;\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void acmc_recv_mad(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tstruct acm_sa_mad resp;\n\tint ret, len, found;\n\tstruct umad_hdr *hdr;\n\n\tif (!port->prov) {\n\t\tacm_log(1, \"no provider assigned to port\\n\");\n\t\treturn;\n\t}\n\n\tacm_log(2, \"\\n\");\n\tlen = sizeof(resp.sa_mad);\n\tret = umad_recv(port->mad_portid, &resp.umad, &len, 0);\n\tif (ret < 0) {\n\t\tacm_log(1, \"umad_recv error %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thdr = &resp.sa_mad.mad_hdr;\n\tacm_log(2, \"bv %x cls %x cv %x mtd %x st %d tid %\" PRIx64 \"x at %x atm %x\\n\",\n\t\thdr->base_version, hdr->mgmt_class, hdr->class_version,\n\t\thdr->method, hdr->status, be64toh(hdr->tid), hdr->attr_id, hdr->attr_mod);\n\tfound = 0;\n\tpthread_mutex_lock(&port->lock);\n\tlist_for_each(&port->sa_pending, req, entry) {\n\t\t/* The upper 32-bit of the tid is used for agentid in umad */\n\t\tif (req->mad.sa_mad.mad_hdr.tid == (hdr->tid & htobe64(0xFFFFFFFF))) {\n\t\t\tfound = 1;\n\t\t\tlist_del(&req->entry);\n\t\t\tport->sa_credits++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (found) {\n\t\tmemcpy(&req->mad.umad, &resp.umad, sizeof(resp.umad) + len);\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void *acm_sa_handler(void *context)\n{\n\tint i, ret;\n\n\tacm_log(0, \"started\\n\");\n\tret = acmc_init_sa_fds();\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to init fds\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel type \\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel state\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tpthread_testcancel();\n\t\tret = poll(sa.fds, sa.nfds, -1);\n\t\tif (ret < 0) {\n\t\t\tacm_log(0, \"ERROR - sa poll error: %d\\n\", errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < sa.nfds; i++) {\n\t\t\tif (!sa.fds[i].revents)\n\t\t\t\tcontinue;\n\n\t\t\tif (sa.fds[i].revents & POLLIN) {\n\t\t\t\tacmc_recv_mad(sa.ports[i]);\n\t\t\t\tacmc_send_queued_req(sa.ports[i]);\n\t\t\t}\n\t\t\tsa.fds[i].revents = 0;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_stop_sa_handler(void)\n{\n\tif (pthread_cancel(sa.thread_id)) {\n\t\tacm_log(0, \"Error: failed to cancel sa resp thread \\n\");\n\t\treturn;\n\t}\n\n\tif (pthread_join(sa.thread_id, NULL)) {\n\t\tacm_log(0, \"Error: failed to join sa resp thread\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void acm_set_options(void)\n{\n\tFILE *f;\n\tchar s[120];\n\tchar opt[32], value[256];\n\n\tif (!(f = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, f)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%31s%255s\", opt, value) != 2)\n\t\t\tcontinue;\n\n\t\tif (!strcasecmp(\"log_file\", opt))\n\t\t\tstrcpy(log_file, value);\n\t\telse if (!strcasecmp(\"log_level\", opt))\n\t\t\tlog_level = atoi(value);\n\t\telse if (!strcasecmp(\"lock_file\", opt))\n\t\t\tstrcpy(lock_file, value);\n\t\telse if (!strcasecmp(\"server_port\", opt))\n\t\t\tserver_port = (short) atoi(value);\n\t\telse if (!strcasecmp(\"server_mode\", opt)) {\n\t\t\tif (!strcasecmp(value, \"open\"))\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_OPEN;\n\t\t\telse if (!strcasecmp(value, \"loop\"))\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_LOOP;\n\t\t\telse\n\t\t\t\tserver_mode = IBACM_SERVER_MODE_UNIX;\n\t\t} else if (!strcasecmp(\"acme_plus_kernel_only\", opt))\n\t\t\tacme_plus_kernel_only =\n\t\t\t\t!strcasecmp(value, \"true\") ||\n\t\t\t\t!strcasecmp(value, \"yes\") ||\n\t\t\t\tstrtol(value, NULL, 0);\n\t\telse if (!strcasecmp(\"provider_lib_path\", opt))\n\t\t\tstrcpy(prov_lib_path, value);\n\t\telse if (!strcasecmp(\"support_ips_in_addr_cfg\", opt))\n\t\t\tsupport_ips_in_addr_cfg = atoi(value);\n\t\telse if (!strcasecmp(\"timeout\", opt))\n\t\t\tsa.timeout = atoi(value);\n\t\telse if (!strcasecmp(\"retries\", opt))\n\t\t\tsa.retries = atoi(value);\n\t\telse if (!strcasecmp(\"sa_depth\", opt))\n\t\t\tsa.depth = atoi(value);\n\t}\n\n\tfclose(f);\n}\n\nstatic void acm_log_options(void)\n{\n\tstatic const char * const server_mode_names[] = {\n\t\t[IBACM_SERVER_MODE_UNIX] = \"unix\",\n\t\t[IBACM_SERVER_MODE_LOOP] = \"loop\",\n\t\t[IBACM_SERVER_MODE_OPEN] = \"open\",\n\t};\n\n\tacm_log(0, \"log file %s\\n\", log_file);\n\tacm_log(0, \"log level %d\\n\", log_level);\n\tacm_log(0, \"lock file %s\\n\", lock_file);\n\tacm_log(0, \"server_port %d\\n\", server_port);\n\tacm_log(0, \"server_mode %s\\n\", server_mode_names[server_mode]);\n\tacm_log(0, \"acme_plus_kernel_only %s\\n\",\n\t\tacme_plus_kernel_only ? \"yes\" : \"no\");\n\tacm_log(0, \"timeout %d ms\\n\", sa.timeout);\n\tacm_log(0, \"retries %d\\n\", sa.retries);\n\tacm_log(0, \"sa depth %d\\n\", sa.depth);\n\tacm_log(0, \"options file %s\\n\", opts_file);\n\tacm_log(0, \"addr file %s\\n\", addr_file);\n\tacm_log(0, \"provider lib path %s\\n\", prov_lib_path);\n\tacm_log(0, \"support IP's in ibacm_addr.cfg %d\\n\", support_ips_in_addr_cfg);\n}\n\nstatic FILE *acm_open_log(void)\n{\n\tFILE *f;\n\n\tif (!strcasecmp(log_file, \"stdout\"))\n\t\treturn stdout;\n\n\tif (!strcasecmp(log_file, \"stderr\"))\n\t\treturn stderr;\n\n\tif (!(f = fopen(log_file, \"w\")))\n\t\tf = stdout;\n\n\treturn f;\n}\n\nstatic int acm_open_lock_file(void)\n{\n\tint lock_fd;\n\tchar pid[16];\n\n\tlock_fd = open(lock_file, O_RDWR | O_CREAT, 0640);\n\tif (lock_fd < 0)\n\t\treturn lock_fd;\n\n\tif (lockf(lock_fd, F_TLOCK, 0)) {\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\n\tsnprintf(pid, sizeof pid, \"%d\\n\", getpid());\n\tif (write(lock_fd, pid, strlen(pid)) != strlen(pid)){\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void show_usage(char *program)\n{\n\tprintf(\"usage: %s\\n\", program);\n\tprintf(\"   [-D]             - run as a daemon (default)\\n\");\n\tprintf(\"   [-P]             - run as a standard process\\n\");\n\tprintf(\"   [-A addr_file]   - address configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_ADDR_FILE);\n\tprintf(\"   [-O option_file] - option configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_OPTS_FILE);\n}\n\nint main(int argc, char **argv)\n{\n\tint i, op, as_daemon = 1;\n\tbool systemd = false;\n\n\tstatic const struct option long_opts[] = {\n\t\t{\"systemd\", 0, NULL, 's'},\n\t\t{}\n\t};\n\n\twhile ((op = getopt_long(argc, argv, \"DPA:O:\", long_opts, NULL)) !=\n\t       -1) {\n\t\tswitch (op) {\n\t\tcase 'D':\n\t\t\t/* option no longer required */\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tas_daemon = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\taddr_file = optarg;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\topts_file = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsystemd = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshow_usage(argv[0]);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (as_daemon && !systemd) {\n\t\tif (daemon(0, 0))\n\t\t\treturn EXIT_FAILURE;\n\t}\n\n\tacm_set_options();\n\n\t/* usage of systemd implies unix-domain communication */\n\tif (systemd)\n\t\tserver_mode = IBACM_SERVER_MODE_UNIX;\n\n\tif (acm_open_lock_file())\n\t\treturn -1;\n\n\tpthread_mutex_init(&log_lock, NULL);\n\tflog = acm_open_log();\n\n\tacm_log(0, \"Assistant to the InfiniBand Communication Manager\\n\");\n\tacm_log_options();\n\n\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\tatomic_init(&counter[i]);\n\n\tif (umad_init() != 0) {\n\t\tacm_log(0, \"ERROR - fail to initialize umad\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_providers()) {\n\t\tacm_log(0, \"ERROR - unable to open any providers\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_devices()) {\n\t\tacm_log(0, \"ERROR - unable to open any devices\\n\");\n\t\treturn -1;\n\t}\n\n\tacm_log(1, \"creating IP Netlink socket\\n\");\n\tacm_ipnl_create();\n\n\tacm_log(1, \"starting sa response receiving thread\\n\");\n\tif (pthread_create(&sa.thread_id, NULL, acm_sa_handler, NULL)) {\n\t\tacm_log(0, \"Error: failed to create sa resp rcving thread\");\n\t\treturn -1;\n\t}\n\n\tif (acm_init_if_iter_sys()) {\n\t\tacm_log(0, \"Error: unable to initialize acm_if_iter_sys\");\n\t\treturn -1;\n\t}\n\n\tacm_activate_devices();\n\tacm_log(1, \"starting server\\n\");\n\tacm_server(systemd);\n\n\tacm_log(0, \"shutting down\\n\");\n\tif (client_array[NL_CLIENT_INDEX].sock != -1)\n\t\tclose(client_array[NL_CLIENT_INDEX].sock);\n\tacm_close_providers();\n\tacm_stop_sa_handler();\n\tumad_done();\n\tacm_fini_if_iter_sys();\n\tfclose(flog);\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/buildlib/rdma_functions.cmake": "# COPYRIGHT (c) 2016 Obsidian Research Corporation.\n# Licensed under BSD (MIT variant) or GPLv2. See COPYING.\n\n# Helper functions for use in the sub CMakeLists files to make them simpler\n# and more uniform.\n\n# Global list of tuples of (SHARED STATIC MAP) library target names\nset(RDMA_STATIC_LIBS \"\" CACHE INTERNAL \"Doc\" FORCE)\n\n# Global list of tuples of (PROVIDER_NAME LIB_NAME)\nset(RDMA_PROVIDER_LIST \"\" CACHE INTERNAL \"Doc\" FORCE)\n\nset(COMMON_LIBS_PIC ccan_pic rdma_util_pic)\nset(COMMON_LIBS ccan rdma_util)\n\nfunction(rdma_public_static_lib SHLIB STATICLIB VERSION_SCRIPT)\n  if (NOT IS_ABSOLUTE ${VERSION_SCRIPT})\n    set(VERSION_SCRIPT \"${CMAKE_CURRENT_SOURCE_DIR}/${VERSION_SCRIPT}\")\n  endif()\n\n  set_target_properties(${STATICLIB} PROPERTIES\n    OUTPUT_NAME ${SHLIB}\n    ARCHIVE_OUTPUT_DIRECTORY \"${BUILD_STATIC_LIB}\")\n  target_compile_definitions(${STATICLIB} PRIVATE _STATIC_LIBRARY_BUILD_=1)\n\n  list(APPEND RDMA_STATIC_LIBS ${SHLIB} ${STATICLIB} ${VERSION_SCRIPT})\n  set(RDMA_STATIC_LIBS \"${RDMA_STATIC_LIBS}\" CACHE INTERNAL \"\")\nendfunction()\n\nfunction(rdma_make_dir DDIR)\n  if(NOT EXISTS \"${DDIR}/\")\n    execute_process(COMMAND \"${CMAKE_COMMAND}\" \"-E\" \"make_directory\"\n      \"${DDIR}\" RESULT_VARIABLE retcode)\n    if(NOT \"${retcode}\" STREQUAL \"0\")\n      message(FATAL_ERROR \"Failed to create directory ${DDIR}\")\n    endif()\n  endif()\nendfunction()\n\n# Create a symlink at filename DEST\n# If the directory containing DEST does not exist then it is created\n# automatically.\nfunction(rdma_create_symlink LINK_CONTENT DEST)\n  if(NOT LINK_CONTENT)\n    message(FATAL_ERROR \"Failed to provide LINK_CONTENT\")\n  endif()\n\n  # Make sure the directory exists, cmake doesn't create target DESTINATION\n  # directories until everything is finished, do it manually here if necessary\n  if(CMAKE_VERSION VERSION_LESS \"2.8.12\")\n    get_filename_component(DDIR \"${DEST}\" PATH)\n  else()\n    get_filename_component(DDIR \"${DEST}\" DIRECTORY)\n  endif()\n\n  rdma_make_dir(\"${DDIR}\")\n\n  # Newer versions of cmake can use \"${CMAKE_COMMAND}\" \"-E\" \"create_symlink\"\n  # however it is broken weirdly on older versions.\n  execute_process(COMMAND \"ln\" \"-Tsf\"\n    \"${LINK_CONTENT}\" \"${DEST}\" RESULT_VARIABLE retcode)\n  if(NOT \"${retcode}\" STREQUAL \"0\")\n    message(FATAL_ERROR \"Failed to create symlink in ${DEST}\")\n  endif()\nendfunction()\n\n# Install a symlink during 'make install'\nfunction(rdma_install_symlink LINK_CONTENT DEST)\n  # Create a link in the build tree with the right content\n  get_filename_component(FN \"${DEST}\" NAME)\n  rdma_create_symlink(\"${LINK_CONTENT}\" \"${CMAKE_CURRENT_BINARY_DIR}/${FN}\")\n\n  # Have cmake install it. Doing it this way lets cpack work if we ever wish\n  # to use that.\n  get_filename_component(DIR \"${DEST}\" PATH)\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${FN}\"\n    DESTINATION \"${DIR}\")\nendfunction()\n\n# Wrapper for install() that runs the single file through configure_file first.\n# This only works with the basic single file install(FILE file ARGS..) pattern\nfunction(rdma_subst_install ARG1 file)\n  if (NOT \"${ARG1}\" STREQUAL \"FILES\")\n    message(FATAL_ERROR \"Bad use of rdma_subst_install\")\n  endif()\n  configure_file(\"${file}\" \"${CMAKE_CURRENT_BINARY_DIR}/${file}\" @ONLY)\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${file}\" ${ARGN})\nendfunction()\n\n# Modify shared library target DEST to use VERSION_SCRIPT as the linker map file\nfunction(rdma_set_library_map DEST VERSION_SCRIPT)\n  if (NOT IS_ABSOLUTE ${VERSION_SCRIPT})\n    set(VERSION_SCRIPT \"${CMAKE_CURRENT_SOURCE_DIR}/${VERSION_SCRIPT}\")\n  endif()\n  set_property(TARGET ${DEST} APPEND_STRING PROPERTY\n    LINK_FLAGS \" -Wl,--version-script,${VERSION_SCRIPT}\")\n\n  # NOTE: This won't work with ninja prior to cmake 3.4\n  set_property(TARGET ${DEST} APPEND_STRING PROPERTY\n    LINK_DEPENDS ${VERSION_SCRIPT})\nendfunction()\n\n# Basic function to produce a standard libary with a GNU LD version script.\nfunction(rdma_library DEST VERSION_SCRIPT SOVERSION VERSION)\n  # Create a static library\n  if (ENABLE_STATIC)\n    add_library(${DEST}-static STATIC ${ARGN})\n    target_link_libraries(${DEST}-static LINK ${COMMON_LIBS})\n    rdma_public_static_lib(${DEST} ${DEST}-static ${VERSION_SCRIPT})\n  endif()\n\n  # Create a shared library\n  add_library(${DEST} SHARED ${ARGN})\n  rdma_set_library_map(${DEST} ${VERSION_SCRIPT})\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  set_target_properties(${DEST} PROPERTIES\n    SOVERSION ${SOVERSION}\n    VERSION ${VERSION}\n    LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\nendfunction()\n\n# Create a special provider with exported symbols in it The shared provider\n# exists as a normal system library with the normal shared library SONAME and\n# other convections. The system library is symlinked into the\n# VERBS_PROVIDER_DIR so it can be dlopened as a provider as well.\nfunction(rdma_shared_provider DEST VERSION_SCRIPT SOVERSION VERSION)\n  # Installed driver file\n  file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" \"driver ${DEST}\\n\")\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" DESTINATION \"${CONFIG_DIR}\")\n\n  # Uninstalled driver file\n  file(MAKE_DIRECTORY \"${BUILD_ETC}/libibverbs.d/\")\n  file(WRITE \"${BUILD_ETC}/libibverbs.d/${DEST}.driver\" \"driver ${BUILD_LIB}/lib${DEST}\\n\")\n\n  list(APPEND RDMA_PROVIDER_LIST ${DEST} ${DEST})\n  set(RDMA_PROVIDER_LIST \"${RDMA_PROVIDER_LIST}\" CACHE INTERNAL \"\")\n\n  # Create a static provider library\n  if (ENABLE_STATIC)\n    add_library(${DEST}-static STATIC ${ARGN})\n    rdma_public_static_lib(${DEST} ${DEST}-static ${VERSION_SCRIPT})\n  endif()\n\n  # Create the plugin shared library\n  add_library(${DEST} SHARED ${ARGN})\n  rdma_set_library_map(${DEST} ${VERSION_SCRIPT})\n\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  target_link_libraries(${DEST} LINK_PRIVATE ibverbs)\n  target_link_libraries(${DEST} LINK_PRIVATE ${CMAKE_THREAD_LIBS_INIT})\n  set_target_properties(${DEST} PROPERTIES\n    SOVERSION ${SOVERSION}\n    VERSION ${VERSION}\n    LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n  # Compute a relative symlink from VERBS_PROVIDER_DIR to LIBDIR\n  execute_process(COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/buildlib/relpath\n    \"${CMAKE_INSTALL_FULL_LIBDIR}/lib${DEST}.so.${VERSION}\"\n    \"${VERBS_PROVIDER_DIR}\"\n    OUTPUT_VARIABLE DEST_LINK_PATH OUTPUT_STRIP_TRAILING_WHITESPACE\n    RESULT_VARIABLE retcode)\n  if(NOT \"${retcode}\" STREQUAL \"0\")\n    message(FATAL_ERROR \"Unable to run buildlib/relpath, do you have python?\")\n  endif()\n\n  rdma_install_symlink(\"${DEST_LINK_PATH}\" \"${VERBS_PROVIDER_DIR}/lib${DEST}${IBVERBS_PROVIDER_SUFFIX}\")\n  rdma_create_symlink(\"lib${DEST}.so.${VERSION}\" \"${BUILD_LIB}/lib${DEST}${IBVERBS_PROVIDER_SUFFIX}\")\nendfunction()\n\n# Create a provider shared library for libibverbs\nfunction(rdma_provider DEST)\n  # Installed driver file\n  file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" \"driver ${DEST}\\n\")\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" DESTINATION \"${CONFIG_DIR}\")\n\n  # Uninstalled driver file\n  file(MAKE_DIRECTORY \"${BUILD_ETC}/libibverbs.d/\")\n  file(WRITE \"${BUILD_ETC}/libibverbs.d/${DEST}.driver\" \"driver ${BUILD_LIB}/lib${DEST}\\n\")\n\n  list(APPEND RDMA_PROVIDER_LIST ${DEST} \"${DEST}-rdmav${IBVERBS_PABI_VERSION}\")\n  set(RDMA_PROVIDER_LIST \"${RDMA_PROVIDER_LIST}\" CACHE INTERNAL \"\")\n\n  # Create a static provider library\n  if (ENABLE_STATIC)\n    add_library(${DEST} STATIC ${ARGN})\n    rdma_public_static_lib(\"${DEST}-rdmav${IBVERBS_PABI_VERSION}\" ${DEST} ${BUILDLIB}/provider.map)\n  endif()\n\n  # Create the plugin shared library\n  set(DEST \"${DEST}-rdmav${IBVERBS_PABI_VERSION}\")\n  add_library(${DEST} MODULE ${ARGN})\n  # Even though these are modules we still want to use Wl,--no-undefined\n  set_target_properties(${DEST} PROPERTIES LINK_FLAGS ${CMAKE_SHARED_LINKER_FLAGS})\n  rdma_set_library_map(${DEST} ${BUILDLIB}/provider.map)\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  target_link_libraries(${DEST} LINK_PRIVATE ibverbs)\n  target_link_libraries(${DEST} LINK_PRIVATE ${CMAKE_THREAD_LIBS_INIT})\n  set_target_properties(${DEST} PROPERTIES LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  # Provider Plugins do not use SONAME versioning, there is no reason to\n  # create the usual symlinks.\n\n  if (VERBS_PROVIDER_DIR)\n    install(TARGETS ${DEST} DESTINATION \"${VERBS_PROVIDER_DIR}\")\n  else()\n    install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n    # FIXME: This symlink is provided for compat with the old build, but it\n    # never should have existed in the first place, nothing should use this\n    # name, we can probably remove it.\n    rdma_install_symlink(\"lib${DEST}${IBVERBS_PROVIDER_SUFFIX}\" \"${CMAKE_INSTALL_LIBDIR}/lib${DEST}.so\")\n  endif()\nendfunction()\n\n # Create an installed executable\nfunction(rdma_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\n  install(TARGETS ${EXEC} DESTINATION \"${CMAKE_INSTALL_BINDIR}\")\nendfunction()\n\n # Create an installed executable (under sbin)\nfunction(rdma_sbin_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\n  install(TARGETS ${EXEC} DESTINATION \"${CMAKE_INSTALL_SBINDIR}\")\nendfunction()\n\n# Create an test executable (not-installed)\nfunction(rdma_test_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\nendfunction()\n\n# Finalize the setup of the static libraries by copying the meta information\n# from the shared to static and setting up the static builder\nfunction(rdma_finalize_libs)\n  list(LENGTH RDMA_STATIC_LIBS LEN)\n  if (LEN LESS 3)\n    return()\n  endif()\n\n  math(EXPR LEN ${LEN}-1)\n  foreach(I RANGE 0 ${LEN} 3)\n    list(GET RDMA_STATIC_LIBS ${I} SHARED)\n    math(EXPR I ${I}+1)\n    list(GET RDMA_STATIC_LIBS ${I} STATIC)\n    math(EXPR I ${I}+1)\n    list(GET RDMA_STATIC_LIBS ${I} MAP)\n\n    # PUBLIC libraries\n    set(LIBS \"\")\n    get_property(TMP TARGET ${SHARED} PROPERTY INTERFACE_LINK_LIBRARIES SET)\n    if (TMP)\n      get_target_property(TMP ${SHARED} INTERFACE_LINK_LIBRARIES)\n      set_target_properties(${STATIC} PROPERTIES INTERFACE_LINK_LIBRARIES \"${TMP}\")\n      set(LIBS \"${TMP}\")\n    endif()\n\n    # PRIVATE libraries\n    get_property(TMP TARGET ${SHARED} PROPERTY LINK_LIBRARIES SET)\n    if (TMP)\n      get_target_property(TMP ${SHARED} LINK_LIBRARIES)\n      set_target_properties(${STATIC} PROPERTIES LINK_LIBRARIES \"${TMP}\")\n      list(APPEND LIBS \"${TMP}\")\n    endif()\n\n    set(ARGS ${ARGS} --map \"${MAP}\" --lib \"$<TARGET_FILE:${STATIC}>\")\n    set(DEPENDS ${DEPENDS} ${STATIC} ${MAP})\n\n    get_target_property(TMP ${STATIC} OUTPUT_NAME)\n    set(OUTPUTS ${OUTPUTS} \"${BUILD_LIB}/lib${TMP}.a\")\n    install(FILES \"${BUILD_LIB}/lib${TMP}.a\" DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n  endforeach()\n\n  foreach(STATIC ${COMMON_LIBS})\n    set(ARGS ${ARGS} --internal_lib \"$<TARGET_FILE:${STATIC}>\")\n    set(DEPENDS ${DEPENDS} ${STATIC})\n  endforeach()\n\n  add_custom_command(\n    OUTPUT ${OUTPUTS}\n    COMMAND \"${PYTHON_EXECUTABLE}\" \"${CMAKE_SOURCE_DIR}/buildlib/sanitize_static_lib.py\"\n             --version ${PACKAGE_VERSION}\n             --ar \"${CMAKE_AR}\" --nm \"${CMAKE_NM}\" --objcopy \"${CMAKE_OBJCOPY}\" ${ARGS}\n    DEPENDS ${DEPENDS} \"${CMAKE_SOURCE_DIR}/buildlib/sanitize_static_lib.py\"\n    COMMENT \"Building distributable static libraries\"\n    VERBATIM)\n  add_custom_target(\"make_static\" ALL DEPENDS ${OUTPUTS})\nendfunction()\n\n# Generate a pkg-config file\nfunction(rdma_pkg_config PC_LIB_NAME PC_REQUIRES_PRIVATE PC_LIB_PRIVATE)\n  set(PC_LIB_NAME \"${PC_LIB_NAME}\")\n  set(PC_LIB_PRIVATE \"${PC_LIB_PRIVATE}\")\n  set(PC_REQUIRES_PRIVATE \"${PC_REQUIRES_PRIVATE}\")\n  get_target_property(PC_VERSION ${PC_LIB_NAME} VERSION)\n\n  # With IN_PLACE=1 the install step is not run, so generate the file in the build dir\n  if (IN_PLACE)\n    set(PC_RPATH \"-Wl,-rpath,\\${libdir}\")\n  endif()\n\n  configure_file(${BUILDLIB}/template.pc.in ${BUILD_LIB}/pkgconfig/lib${PC_LIB_NAME}.pc @ONLY)\n  if (NOT IN_PLACE)\n    install(FILES ${BUILD_LIB}/pkgconfig/lib${PC_LIB_NAME}.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n  endif()\nendfunction()\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-32.0-lld5dj4lbomjn74h62u554lxb2v6qnhz/spack-src/buildlib/provider.map": "/* The providers do not export any symbols at all. Instead they rely on\n   attribute(constructor) to cause their init function to run at dlopen\n   time. */\n{\n\tlocal: *;\n};\n"
    },
    "skipped": [],
    "total_files": 1016
}