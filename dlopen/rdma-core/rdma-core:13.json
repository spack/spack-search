{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-13-f2bnbpzsqc4ceifuvhs2iin347h5f2uh/spack-src/libibverbs/init.c": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006 Cisco Systems, Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#define _GNU_SOURCE\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <glob.h>\n#include <stdio.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <dirent.h>\n#include <errno.h>\n#include <assert.h>\n\n#include <util/util.h>\n#include \"ibverbs.h\"\n\n#pragma GCC diagnostic ignored \"-Wmissing-prototypes\"\n\nint abi_ver;\n\nstruct ibv_sysfs_dev {\n\tchar\t\t        sysfs_name[IBV_SYSFS_NAME_MAX];\n\tchar\t\t        ibdev_name[IBV_SYSFS_NAME_MAX];\n\tchar\t\t        sysfs_path[IBV_SYSFS_PATH_MAX];\n\tchar\t\t        ibdev_path[IBV_SYSFS_PATH_MAX];\n\tstruct ibv_sysfs_dev   *next;\n\tint\t\t\tabi_ver;\n\tint\t\t\thave_driver;\n};\n\nstruct ibv_driver_name {\n\tchar\t\t       *name;\n\tstruct ibv_driver_name *next;\n};\n\nstruct ibv_driver {\n\tconst char\t       *name;\n\tverbs_driver_init_func\tverbs_init_func;\n\tstruct ibv_driver      *next;\n};\n\nstatic struct ibv_sysfs_dev *sysfs_dev_list;\nstatic struct ibv_driver_name *driver_name_list;\nstatic struct ibv_driver *head_driver, *tail_driver;\n\nstatic int find_sysfs_devs(void)\n{\n\tchar class_path[IBV_SYSFS_PATH_MAX];\n\tDIR *class_dir;\n\tstruct dirent *dent;\n\tstruct ibv_sysfs_dev *sysfs_dev = NULL;\n\tchar value[8];\n\tint ret = 0;\n\n\tif (!check_snprintf(class_path, sizeof(class_path),\n\t\t\t    \"%s/class/infiniband_verbs\", ibv_get_sysfs_path()))\n\t\treturn ENOMEM;\n\n\tclass_dir = opendir(class_path);\n\tif (!class_dir)\n\t\treturn ENOSYS;\n\n\twhile ((dent = readdir(class_dir))) {\n\t\tstruct stat buf;\n\n\t\tif (dent->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\tif (!sysfs_dev)\n\t\t\tsysfs_dev = malloc(sizeof *sysfs_dev);\n\t\tif (!sysfs_dev) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!check_snprintf(sysfs_dev->sysfs_path, sizeof sysfs_dev->sysfs_path,\n\t\t\t\t    \"%s/%s\", class_path, dent->d_name))\n\t\t\tcontinue;\n\n\t\tif (stat(sysfs_dev->sysfs_path, &buf)) {\n\t\t\tfprintf(stderr, PFX \"Warning: couldn't stat '%s'.\\n\",\n\t\t\t\tsysfs_dev->sysfs_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!S_ISDIR(buf.st_mode))\n\t\t\tcontinue;\n\n\t\tif (!check_snprintf(sysfs_dev->sysfs_name, sizeof sysfs_dev->sysfs_name,\n\t\t\t\t    \"%s\", dent->d_name))\n\t\t\tcontinue;\n\n\t\tif (ibv_read_sysfs_file(sysfs_dev->sysfs_path, \"ibdev\",\n\t\t\t\t\tsysfs_dev->ibdev_name,\n\t\t\t\t\tsizeof sysfs_dev->ibdev_name) < 0) {\n\t\t\tfprintf(stderr, PFX \"Warning: no ibdev class attr for '%s'.\\n\",\n\t\t\t\tdent->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!check_snprintf(\n\t\t\tsysfs_dev->ibdev_path, sizeof(sysfs_dev->ibdev_path),\n\t\t\t\"%s/class/infiniband/%s\", ibv_get_sysfs_path(),\n\t\t\tsysfs_dev->ibdev_name))\n\t\t\tcontinue;\n\n\t\tsysfs_dev->next        = sysfs_dev_list;\n\t\tsysfs_dev->have_driver = 0;\n\t\tif (ibv_read_sysfs_file(sysfs_dev->sysfs_path, \"abi_version\",\n\t\t\t\t\tvalue, sizeof value) > 0)\n\t\t\tsysfs_dev->abi_ver = strtol(value, NULL, 10);\n\t\telse\n\t\t\tsysfs_dev->abi_ver = 0;\n\n\t\tsysfs_dev_list = sysfs_dev;\n\t\tsysfs_dev      = NULL;\n\t}\n\n out:\n\tif (sysfs_dev)\n\t\tfree(sysfs_dev);\n\n\tclosedir(class_dir);\n\treturn ret;\n}\n\nvoid verbs_register_driver(const char *name,\n\t\t\t   verbs_driver_init_func verbs_init_func)\n{\n\tstruct ibv_driver *driver;\n\n\tdriver = malloc(sizeof *driver);\n\tif (!driver) {\n\t\tfprintf(stderr, PFX \"Warning: couldn't allocate driver for %s\\n\", name);\n\t\treturn;\n\t}\n\n\tdriver->name            = name;\n\tdriver->verbs_init_func = verbs_init_func;\n\tdriver->next            = NULL;\n\n\tif (tail_driver)\n\t\ttail_driver->next = driver;\n\telse\n\t\thead_driver = driver;\n\ttail_driver = driver;\n}\n\n#define __IBV_QUOTE(x)\t#x\n#define IBV_QUOTE(x)\t__IBV_QUOTE(x)\n#define DLOPEN_TRAILER \"-\" IBV_QUOTE(IBV_DEVICE_LIBRARY_EXTENSION) \".so\"\n\nstatic void load_driver(const char *name)\n{\n\tchar *so_name;\n\tvoid *dlhandle;\n\n\t/* If the name is an absolute path then open that path after appending\n\t   the trailer suffix */\n\tif (name[0] == '/') {\n\t\tif (asprintf(&so_name, \"%s\" DLOPEN_TRAILER, name) < 0)\n\t\t\tgoto out_asprintf;\n\t\tdlhandle = dlopen(so_name, RTLD_NOW);\n\t\tif (!dlhandle)\n\t\t\tgoto out_dlopen;\n\t\tfree(so_name);\n\t\treturn;\n\t}\n\n\t/* If configured with a provider plugin path then try that next */\n\tif (sizeof(VERBS_PROVIDER_DIR) > 1) {\n\t\tif (asprintf(&so_name, VERBS_PROVIDER_DIR \"/lib%s\" DLOPEN_TRAILER, name) <\n\t\t    0)\n\t\t\tgoto out_asprintf;\n\t\tdlhandle = dlopen(so_name, RTLD_NOW);\n\t\tfree(so_name);\n\t\tif (dlhandle)\n\t\t\treturn;\n\t}\n\n\t/* Otherwise use the system libary search path. This is the historical\n\t   behavior of libibverbs */\n\tif (asprintf(&so_name, \"lib%s\" DLOPEN_TRAILER, name) < 0)\n\t\tgoto out_asprintf;\n\tdlhandle = dlopen(so_name, RTLD_NOW);\n\tif (!dlhandle)\n\t\tgoto out_dlopen;\n\tfree(so_name);\n\treturn;\n\nout_asprintf:\n\tfprintf(stderr, PFX \"Warning: couldn't load driver '%s'.\\n\", name);\n\treturn;\nout_dlopen:\n\tfprintf(stderr, PFX \"Warning: couldn't load driver '%s': %s\\n\", so_name,\n\t\tdlerror());\n\tfree(so_name);\n\treturn;\n}\n\nstatic void load_drivers(void)\n{\n\tstruct ibv_driver_name *name, *next_name;\n\tconst char *env;\n\tchar *list, *env_name;\n\n\t/*\n\t * Only use drivers passed in through the calling user's\n\t * environment if we're not running setuid.\n\t */\n\tif (getuid() == geteuid()) {\n\t\tif ((env = getenv(\"RDMAV_DRIVERS\"))) {\n\t\t\tlist = strdupa(env);\n\t\t\twhile ((env_name = strsep(&list, \":;\")))\n\t\t\t\tload_driver(env_name);\n\t\t} else if ((env = getenv(\"IBV_DRIVERS\"))) {\n\t\t\tlist = strdupa(env);\n\t\t\twhile ((env_name = strsep(&list, \":;\")))\n\t\t\t\tload_driver(env_name);\n\t\t}\n\t}\n\n\tfor (name = driver_name_list, next_name = name ? name->next : NULL;\n\t     name;\n\t     name = next_name, next_name = name ? name->next : NULL) {\n\t\tload_driver(name->name);\n\t\tfree(name->name);\n\t\tfree(name);\n\t}\n}\n\nstatic void read_config_file(const char *path)\n{\n\tFILE *conf;\n\tchar *line = NULL;\n\tchar *config;\n\tchar *field;\n\tsize_t buflen = 0;\n\tssize_t len;\n\n\tconf = fopen(path, \"r\" STREAM_CLOEXEC);\n\tif (!conf) {\n\t\tfprintf(stderr, PFX \"Warning: couldn't read config file %s.\\n\",\n\t\t\tpath);\n\t\treturn;\n\t}\n\n\twhile ((len = getline(&line, &buflen, conf)) != -1) {\n\t\tconfig = line + strspn(line, \"\\t \");\n\t\tif (config[0] == '\\n' || config[0] == '#')\n\t\t\tcontinue;\n\n\t\tfield = strsep(&config, \"\\n\\t \");\n\n\t\tif (strcmp(field, \"driver\") == 0 && config != NULL) {\n\t\t\tstruct ibv_driver_name *driver_name;\n\n\t\t\tconfig += strspn(config, \"\\t \");\n\t\t\tfield = strsep(&config, \"\\n\\t \");\n\n\t\t\tdriver_name = malloc(sizeof *driver_name);\n\t\t\tif (!driver_name) {\n\t\t\t\tfprintf(stderr, PFX \"Warning: couldn't allocate \"\n\t\t\t\t\t\"driver name '%s'.\\n\", field);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdriver_name->name = strdup(field);\n\t\t\tif (!driver_name->name) {\n\t\t\t\tfprintf(stderr, PFX \"Warning: couldn't allocate \"\n\t\t\t\t\t\"driver name '%s'.\\n\", field);\n\t\t\t\tfree(driver_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdriver_name->next = driver_name_list;\n\t\t\tdriver_name_list  = driver_name;\n\t\t} else\n\t\t\tfprintf(stderr, PFX \"Warning: ignoring bad config directive \"\n\t\t\t\t\"'%s' in file '%s'.\\n\", field, path);\n\t}\n\n\tif (line)\n\t\tfree(line);\n\tfclose(conf);\n}\n\nstatic void read_config(void)\n{\n\tDIR *conf_dir;\n\tstruct dirent *dent;\n\tchar *path;\n\n\tconf_dir = opendir(IBV_CONFIG_DIR);\n\tif (!conf_dir) {\n\t\tfprintf(stderr, PFX \"Warning: couldn't open config directory '%s'.\\n\",\n\t\t\tIBV_CONFIG_DIR);\n\t\treturn;\n\t}\n\n\twhile ((dent = readdir(conf_dir))) {\n\t\tstruct stat buf;\n\n\t\tif (asprintf(&path, \"%s/%s\", IBV_CONFIG_DIR, dent->d_name) < 0) {\n\t\t\tfprintf(stderr, PFX \"Warning: couldn't read config file %s/%s.\\n\",\n\t\t\t\tIBV_CONFIG_DIR, dent->d_name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stat(path, &buf)) {\n\t\t\tfprintf(stderr, PFX \"Warning: couldn't stat config file '%s'.\\n\",\n\t\t\t\tpath);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISREG(buf.st_mode))\n\t\t\tgoto next;\n\n\t\tread_config_file(path);\nnext:\n\t\tfree(path);\n\t}\n\nout:\n\tclosedir(conf_dir);\n}\n\nstatic struct ibv_device *try_driver(struct ibv_driver *driver,\n\t\t\t\t     struct ibv_sysfs_dev *sysfs_dev)\n{\n\tstruct verbs_device *vdev;\n\tstruct ibv_device *dev;\n\tchar value[16];\n\n\tvdev = driver->verbs_init_func(sysfs_dev->sysfs_path, sysfs_dev->abi_ver);\n\tif (!vdev)\n\t\treturn NULL;\n\n\tdev = &vdev->device;\n\tassert(dev->_ops._dummy1 == NULL);\n\tassert(dev->_ops._dummy2 == NULL);\n\n\tif (ibv_read_sysfs_file(sysfs_dev->ibdev_path, \"node_type\", value, sizeof value) < 0) {\n\t\tfprintf(stderr, PFX \"Warning: no node_type attr under %s.\\n\",\n\t\t\tsysfs_dev->ibdev_path);\n\t\t\tdev->node_type = IBV_NODE_UNKNOWN;\n\t} else {\n\t\tdev->node_type = strtol(value, NULL, 10);\n\t\tif (dev->node_type < IBV_NODE_CA || dev->node_type > IBV_NODE_USNIC_UDP)\n\t\t\tdev->node_type = IBV_NODE_UNKNOWN;\n\t}\n\n\tswitch (dev->node_type) {\n\tcase IBV_NODE_CA:\n\tcase IBV_NODE_SWITCH:\n\tcase IBV_NODE_ROUTER:\n\t\tdev->transport_type = IBV_TRANSPORT_IB;\n\t\tbreak;\n\tcase IBV_NODE_RNIC:\n\t\tdev->transport_type = IBV_TRANSPORT_IWARP;\n\t\tbreak;\n\tcase IBV_NODE_USNIC:\n\t\tdev->transport_type = IBV_TRANSPORT_USNIC;\n\t\tbreak;\n\tcase IBV_NODE_USNIC_UDP:\n\t\tdev->transport_type = IBV_TRANSPORT_USNIC_UDP;\n\t\tbreak;\n\tdefault:\n\t\tdev->transport_type = IBV_TRANSPORT_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstrcpy(dev->dev_name,   sysfs_dev->sysfs_name);\n\tstrcpy(dev->dev_path,   sysfs_dev->sysfs_path);\n\tstrcpy(dev->name,       sysfs_dev->ibdev_name);\n\tstrcpy(dev->ibdev_path, sysfs_dev->ibdev_path);\n\n\treturn dev;\n}\n\nstatic struct ibv_device *try_drivers(struct ibv_sysfs_dev *sysfs_dev)\n{\n\tstruct ibv_driver *driver;\n\tstruct ibv_device *dev;\n\n\tfor (driver = head_driver; driver; driver = driver->next) {\n\t\tdev = try_driver(driver, sysfs_dev);\n\t\tif (dev)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic int check_abi_version(const char *path)\n{\n\tchar value[8];\n\n\tif (ibv_read_sysfs_file(path, \"class/infiniband_verbs/abi_version\",\n\t\t\t\tvalue, sizeof value) < 0) {\n\t\treturn ENOSYS;\n\t}\n\n\tabi_ver = strtol(value, NULL, 10);\n\n\tif (abi_ver < IB_USER_VERBS_MIN_ABI_VERSION ||\n\t    abi_ver > IB_USER_VERBS_MAX_ABI_VERSION) {\n\t\tfprintf(stderr, PFX \"Fatal: kernel ABI version %d \"\n\t\t\t\"doesn't match library version %d.\\n\",\n\t\t\tabi_ver, IB_USER_VERBS_MAX_ABI_VERSION);\n\t\treturn ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic void check_memlock_limit(void)\n{\n\tstruct rlimit rlim;\n\n\tif (!geteuid())\n\t\treturn;\n\n\tif (getrlimit(RLIMIT_MEMLOCK, &rlim)) {\n\t\tfprintf(stderr, PFX \"Warning: getrlimit(RLIMIT_MEMLOCK) failed.\");\n\t\treturn;\n\t}\n\n\tif (rlim.rlim_cur <= 32768)\n\t\tfprintf(stderr, PFX \"Warning: RLIMIT_MEMLOCK is %lu bytes.\\n\"\n\t\t\t\"    This will severely limit memory registrations.\\n\",\n\t\t\trlim.rlim_cur);\n}\n\nstatic void add_device(struct ibv_device *dev,\n\t\t       struct ibv_device ***dev_list,\n\t\t       int *num_devices,\n\t\t       int *list_size)\n{\n\tstruct ibv_device **new_list;\n\n\tif (*list_size <= *num_devices) {\n\t\t*list_size = *list_size ? *list_size * 2 : 1;\n\t\tnew_list = realloc(*dev_list, *list_size * sizeof (struct ibv_device *));\n\t\tif (!new_list)\n\t\t\treturn;\n\t\t*dev_list = new_list;\n\t}\n\n\t(*dev_list)[(*num_devices)++] = dev;\n}\n\nint ibverbs_init(struct ibv_device ***list)\n{\n\tconst char *sysfs_path;\n\tstruct ibv_sysfs_dev *sysfs_dev, *next_dev;\n\tstruct ibv_device *device;\n\tint num_devices = 0;\n\tint list_size = 0;\n\tint statically_linked = 0;\n\tint no_driver = 0;\n\tint ret;\n\n\t*list = NULL;\n\n\tif (getenv(\"RDMAV_FORK_SAFE\") || getenv(\"IBV_FORK_SAFE\"))\n\t\tif (ibv_fork_init())\n\t\t\tfprintf(stderr, PFX \"Warning: fork()-safety requested \"\n\t\t\t\t\"but init failed\\n\");\n\n\tsysfs_path = ibv_get_sysfs_path();\n\tif (!sysfs_path)\n\t\treturn -ENOSYS;\n\n\tret = check_abi_version(sysfs_path);\n\tif (ret)\n\t\treturn -ret;\n\n\tcheck_memlock_limit();\n\n\tread_config();\n\n\tret = find_sysfs_devs();\n\tif (ret)\n\t\treturn -ret;\n\n\tfor (sysfs_dev = sysfs_dev_list; sysfs_dev; sysfs_dev = sysfs_dev->next) {\n\t\tdevice = try_drivers(sysfs_dev);\n\t\tif (device) {\n\t\t\tadd_device(device, list, &num_devices, &list_size);\n\t\t\tsysfs_dev->have_driver = 1;\n\t\t} else\n\t\t\tno_driver = 1;\n\t}\n\n\tif (!no_driver)\n\t\tgoto out;\n\n\t/*\n\t * Check if we can dlopen() ourselves.  If this fails,\n\t * libibverbs is probably statically linked into the\n\t * executable, and we should just give up, since trying to\n\t * dlopen() a driver module will fail spectacularly (loading a\n\t * driver .so will bring in dynamic copies of libibverbs and\n\t * libdl to go along with the static copies the executable\n\t * has, which quickly leads to a crash.\n\t */\n\t{\n\t\tvoid *hand = dlopen(NULL, RTLD_NOW);\n\t\tif (!hand) {\n\t\t\tfprintf(stderr, PFX \"Warning: dlopen(NULL) failed, \"\n\t\t\t\t\"assuming static linking.\\n\");\n\t\t\tstatically_linked = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tdlclose(hand);\n\t}\n\n\tload_drivers();\n\n\tfor (sysfs_dev = sysfs_dev_list; sysfs_dev; sysfs_dev = sysfs_dev->next) {\n\t\tif (sysfs_dev->have_driver)\n\t\t\tcontinue;\n\n\t\tdevice = try_drivers(sysfs_dev);\n\t\tif (device) {\n\t\t\tadd_device(device, list, &num_devices, &list_size);\n\t\t\tsysfs_dev->have_driver = 1;\n\t\t}\n\t}\n\nout:\n\tfor (sysfs_dev = sysfs_dev_list,\n\t\t     next_dev = sysfs_dev ? sysfs_dev->next : NULL;\n\t     sysfs_dev;\n\t     sysfs_dev = next_dev, next_dev = sysfs_dev ? sysfs_dev->next : NULL) {\n\t\tif (!sysfs_dev->have_driver && getenv(\"IBV_SHOW_WARNINGS\")) {\n\t\t\tfprintf(stderr, PFX \"Warning: no userspace device-specific \"\n\t\t\t\t\"driver found for %s\\n\", sysfs_dev->sysfs_path);\n\t\t\tif (statically_linked)\n\t\t\t\tfprintf(stderr, \"\tWhen linking libibverbs statically, \"\n\t\t\t\t\t\"driver must be statically linked too.\\n\");\n\t\t}\n\t\tfree(sysfs_dev);\n\t}\n\n\treturn num_devices;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-13-f2bnbpzsqc4ceifuvhs2iin347h5f2uh/spack-src/ibacm/src/acm.c": "/*\n * Copyright (c) 2009-2014 Intel Corporation. All rights reserved.\n * Copyright (c) 2013 Mellanox Technologies LTD. All rights reserved.\n *\n * This software is available to you under the OpenIB.org BSD license\n * below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AWV\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <osd.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <infiniband/acm.h>\n#include <infiniband/acm_prov.h>\n#include <infiniband/umad.h>\n#include <infiniband/verbs.h>\n#include <infiniband/umad_types.h>\n#include <infiniband/umad_sa.h>\n#include <dlfcn.h>\n#include <search.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <net/if_arp.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <rdma/rdma_netlink.h>\n#include <rdma/ib_user_sa.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <ccan/list.h>\n#include <util/util.h>\n#include \"acm_mad.h\"\n#include \"acm_util.h\"\n\n#define src_out     data[0]\n#define src_index   data[1]\n#define dst_index   data[2]\n\n#define MAX_EP_ADDR 4\n#define NL_MSG_BUF_SIZE 4096\n#define ACM_PROV_NAME_SIZE 64\n#define NL_CLIENT_INDEX 0\n\nstruct acmc_subnet {\n\tstruct list_node       entry;\n\tuint64_t               subnet_prefix;\n};\n\nstruct acmc_prov {\n\tstruct acm_provider    *prov;\n\tvoid                   *handle;\n\tstruct list_node       entry;\n\tstruct list_head       subnet_list;\n};\n\nstruct acmc_prov_context {\n\tstruct list_node        entry;\n\tatomic_t                refcnt;\n\tstruct acm_provider     *prov;\n\tvoid                    *context;\n};\n\nstruct acmc_device;\n\nstruct acmc_port {\n\tstruct acmc_device  *dev;\n\tstruct acm_port     port;\n\tstruct acm_provider *prov; /* limit to 1 provider per port for now */\n\tvoid                *prov_port_context;\n\tint\t\t    mad_portid;\n\tint\t\t    mad_agentid;\n\tstruct ib_mad_addr  sa_addr;\n\tstruct list_head    sa_pending;\n\tstruct list_head    sa_wait;\n\tint\t\t    sa_credits;\n\tpthread_mutex_t     lock;\n\tstruct list_head    ep_list;\n\tenum ibv_port_state state;\n\tint                 gid_cnt;\n\tunion ibv_gid       *gid_tbl;\n\tuint16_t            lid;\n\tuint16_t            lid_mask;\n\tint                 sa_pkey_index;\n\tuint16_t            def_acm_pkey;\n};\n\nstruct acmc_device {\n\tstruct acm_device       device;\n\tstruct list_node        entry;\n\tstruct list_head        prov_dev_context_list;\n\tint                     port_cnt;\n\tstruct acmc_port        port[0];\n};\n\nstruct acmc_addr {\n\tstruct acm_address    addr;\n\tvoid                  *prov_addr_context;\n\tchar\t\t      string_buf[ACM_MAX_ADDRESS];\n};\n\nstruct acmc_ep {\n\tstruct acmc_port      *port;\n\tstruct acm_endpoint   endpoint;\n\tvoid                  *prov_ep_context;\n\tstruct acmc_addr      addr_info[MAX_EP_ADDR];\n\tstruct list_node      entry;\n};\n\nstruct acmc_client {\n\tpthread_mutex_t lock;   /* acquire ep lock first */\n\tint      sock;\n\tint      index;\n\tatomic_t refcnt;\n};\n\nunion socket_addr {\n\tstruct sockaddr     sa;\n\tstruct sockaddr_in  sin;\n\tstruct sockaddr_in6 sin6;\n};\n\nstruct acmc_sa_req {\n\tstruct list_node\tentry;\n\tstruct acmc_ep\t\t*ep;\n\tvoid\t\t\t(*resp_handler)(struct acm_sa_mad *);\n\tstruct acm_sa_mad\tmad;\n};\n\nstruct acm_nl_path {\n\tstruct nlattr\t\t\tattr_hdr;\n\tstruct ib_path_rec_data\t\trec;\n};\n\nstruct acm_nl_msg {\n\tstruct nlmsghdr\t\t\t\tnlmsg_header;\n\tunion {\n\t\tuint8_t\t\t\t\tdata[ACM_MSG_DATA_LENGTH];\n\t\tstruct rdma_ls_resolve_header\tresolve_header;\n\t\tstruct nlattr\t\t\tattr[0];\n\t\tstruct acm_nl_path\t\tpath[0];\n\t};\n};\n\nstatic char def_prov_name[ACM_PROV_NAME_SIZE] = \"ibacmp\";\nstatic LIST_HEAD(provider_list);\nstatic struct acmc_prov *def_provider = NULL;\n\nstatic LIST_HEAD(dev_list);\n\nstatic int listen_socket;\nstatic int ip_mon_socket;\nstatic struct acmc_client client_array[FD_SETSIZE - 1];\n\nstatic FILE *flog;\nstatic pthread_mutex_t log_lock;\nstatic __thread char log_data[ACM_MAX_ADDRESS];\nstatic atomic_t counter[ACM_MAX_COUNTER];\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port);\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey);\nstatic int acm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t\t      size_t addr_len, uint8_t addr_type);\nstatic void acm_event_handler(struct acmc_device *dev);\nstatic int acm_nl_send(int sock, struct acm_msg *msg);\n\nstatic struct sa_data {\n\tint\t\ttimeout;\n\tint\t\tretries;\n\tint\t\tdepth;\n\tpthread_t\tthread_id;\n\tstruct pollfd\t*fds;\n\tstruct acmc_port **ports;\n\tint\t\tnfds;\n} sa = { 2000, 2, 1, 0, NULL, NULL, 0};\n\n/*\n * Service options - may be set through ibacm_opts.cfg file.\n */\nstatic const char *acme = IBACM_BIN_PATH \"/ib_acme -A\";\nstatic const char *opts_file = ACM_CONF_DIR \"/\" ACM_OPTS_FILE;\nstatic const char *addr_file = ACM_CONF_DIR \"/\" ACM_ADDR_FILE;\nstatic char log_file[128] = IBACM_LOG_FILE;\nstatic int log_level = 0;\nstatic char lock_file[128] = IBACM_PID_FILE;\nstatic short server_port = 6125;\nstatic int support_ips_in_addr_cfg = 0;\nstatic char prov_lib_path[256] = IBACM_LIB_PATH;\n\nvoid acm_write(int level, const char *format, ...)\n{\n\tva_list args;\n\tstruct timeval tv;\n\n\tif (level > log_level)\n\t\treturn;\n\n\tgettimeofday(&tv, NULL);\n\tva_start(args, format);\n\tpthread_mutex_lock(&log_lock);\n\tfprintf(flog, \"%u.%03u: \", (unsigned) tv.tv_sec, (unsigned) (tv.tv_usec / 1000));\n\tvfprintf(flog, format, args);\n\tfflush(flog);\n\tpthread_mutex_unlock(&log_lock);\n\tva_end(args);\n}\n\nvoid acm_format_name(int level, char *name, size_t name_size,\n\t\t     uint8_t addr_type, const uint8_t *addr, size_t addr_size)\n{\n\tstruct ibv_path_record *path;\n\n\tif (level > log_level)\n\t\treturn;\n\n\tswitch (addr_type) {\n\tcase ACM_EP_INFO_NAME:\n\t\tmemcpy(name, addr, addr_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\tinet_ntop(AF_INET, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\tcase ACM_ADDRESS_GID:\n\t\tinet_ntop(AF_INET6, addr, name, name_size);\n\t\tbreak;\n\tcase ACM_EP_INFO_PATH:\n\t\tpath = (struct ibv_path_record *) addr;\n\t\tif (path->dlid) {\n\t\t\tsnprintf(name, name_size, \"SLID(%u) DLID(%u)\",\n\t\t\t\tbe16toh(path->slid), be16toh(path->dlid));\n\t\t} else {\n\t\t\tacm_format_name(level, name, name_size, ACM_ADDRESS_GID,\n\t\t\t\t\tpath->dgid.raw, sizeof path->dgid);\n\t\t}\n\t\tbreak;\n\tcase ACM_ADDRESS_LID:\n\t\tsnprintf(name, name_size, \"LID(%u)\", be16toh(*((uint16_t *) addr)));\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(name, \"Unknown\");\n\t\tbreak;\n\t}\n}\n\nint ib_any_gid(union ibv_gid *gid)\n{\n\treturn ((gid->global.subnet_prefix | gid->global.interface_id) == 0);\n}\n\nconst char *acm_get_opts_file(void)\n{\n\treturn opts_file;\n}\n\nvoid acm_increment_counter(int type)\n{\n\tif (type >= 0 && type < ACM_MAX_COUNTER)\n\t\tatomic_inc(&counter[type]);\n}\n\nstatic struct acmc_prov_context *\nacm_alloc_prov_context(struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = calloc(1, sizeof(*ctx));\n\tif (!ctx) {\n\t\tacm_log(0, \"Error: failed to allocate prov context\\n\");\n\t\treturn NULL;\n\t}\n\tatomic_set(&ctx->refcnt, 1);\n\tctx->prov = prov;\n\treturn ctx;\n}\n\nstatic struct acmc_prov_context *\nacm_get_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tlist_for_each(list, ctx, entry) {\n\t\tif (ctx->prov == prov) {\n\t\t\treturn ctx;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_prov_context *\nacm_acquire_prov_context(struct list_head *list, struct acm_provider *prov)\n{\n\tstruct acmc_prov_context *ctx;\n\n\tctx = acm_get_prov_context(list, prov);\n\tif (!ctx) {\n\t\tctx = acm_alloc_prov_context(prov);\n\t\tif (!ctx) {\n\t\t\tacm_log(0, \"Error -- failed to allocate provider context\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlist_add_tail(list, &ctx->entry);\n\t} else {\n\t\tatomic_inc(&ctx->refcnt);\n\t}\n\n\treturn ctx;\n}\n\nstatic void\nacm_release_prov_context(struct acmc_prov_context *ctx)\n{\n\tif (atomic_dec(&ctx->refcnt) <= 0) {\n\t\tlist_del(&ctx->entry);\n\t\tfree(ctx);\n\t}\n}\n\nuint8_t acm_gid_index(struct acm_port *port, union ibv_gid *gid)\n{\n\tuint8_t i;\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tfor (i = 0; i < cport->gid_cnt; i++) {\n\t\tif (!memcmp(&cport->gid_tbl[i], gid, sizeof (*gid)))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint acm_get_gid(struct acm_port *port, int index, union ibv_gid *gid)\n{\n\tstruct acmc_port *cport;\n\n\tcport = container_of(port, struct acmc_port, port);\n\tif (index >= 0 && index < cport->gid_cnt) {\n\t\t*gid = cport->gid_tbl[index];\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic void acm_mark_addr_invalid(struct acmc_ep *ep,\n\t\t\t\t  struct acm_ep_addr_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\tif (ep->addr_info[i].addr.type != data->type)\n\t\t\tcontinue;\n\n\t\tif ((data->type == ACM_ADDRESS_NAME &&\n\t\t    !strncasecmp((char *) ep->addr_info[i].addr.info.name,\n\t\t\t      (char *) data->info.addr, ACM_MAX_ADDRESS)) ||\n\t\t     !memcmp(ep->addr_info[i].addr.info.addr, data->info.addr,\n\t\t\t     ACM_MAX_ADDRESS)) {\n\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct acm_address *\nacm_addr_lookup(const struct acm_endpoint *endpoint, uint8_t *addr, uint8_t addr_type)\n{\n\tstruct acmc_ep *ep;\n\tint i;\n\n\tep = container_of(endpoint, struct acmc_ep, endpoint);\n\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\tif (ep->addr_info[i].addr.type != addr_type)\n\t\t\tcontinue;\n\n\t\tif ((addr_type == ACM_ADDRESS_NAME &&\n\t\t\t!strncasecmp((char *) ep->addr_info[i].addr.info.name,\n\t\t\t\t(char *) addr, ACM_MAX_ADDRESS)) ||\n\t\t\t!memcmp(ep->addr_info[i].addr.info.addr, addr, ACM_MAX_ADDRESS))\n\t\t\treturn &ep->addr_info[i].addr;\n\t}\n\treturn NULL;\n}\n\nuint64_t acm_path_comp_mask(struct ibv_path_record *path)\n{\n\tuint32_t fl_hop;\n\tuint16_t qos_sl;\n\tuint64_t comp_mask = 0;\n\n\tacm_log(2, \"\\n\");\n\tif (path->service_id)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SERVICE_ID;\n\tif (!ib_any_gid(&path->dgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_DGID;\n\tif (!ib_any_gid(&path->sgid))\n\t\tcomp_mask |= IB_COMP_MASK_PR_SGID;\n\tif (path->dlid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_DLID;\n\tif (path->slid)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SLID;\n\n\tfl_hop = be32toh(path->flowlabel_hoplimit);\n\tif (fl_hop >> 8)\n\t\tcomp_mask |= IB_COMP_MASK_PR_FLOW_LABEL;\n\tif (fl_hop & 0xFF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_HOP_LIMIT;\n\n\tif (path->tclass)\n\t\tcomp_mask |= IB_COMP_MASK_PR_TCLASS;\n\tif (path->reversible_numpath & 0x80)\n\t\tcomp_mask |= IB_COMP_MASK_PR_REVERSIBLE;\n\tif (path->pkey)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PKEY;\n\n\tqos_sl = be16toh(path->qosclass_sl);\n\tif (qos_sl >> 4)\n\t\tcomp_mask |= IB_COMP_MASK_PR_QOS_CLASS;\n\tif (qos_sl & 0xF)\n\t\tcomp_mask |= IB_COMP_MASK_PR_SL;\n\n\tif (path->mtu & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU_SELECTOR;\n\tif (path->mtu & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_MTU;\n\tif (path->rate & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE_SELECTOR;\n\tif (path->rate & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_RATE;\n\tif (path->packetlifetime & 0xC0)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME_SELECTOR;\n\tif (path->packetlifetime & 0x3F)\n\t\tcomp_mask |= IB_COMP_MASK_PR_PACKET_LIFETIME;\n\n\treturn comp_mask;\n}\n\nint acm_resolve_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"client %d, status 0x%x\\n\", client->index, msg->hdr.status);\n\n\tif (msg->hdr.status == ACM_STATUS_ENODATA)\n\t\tatomic_inc(&counter[ACM_CNTR_NODATA]);\n\telse if (msg->hdr.status)\n\t\tatomic_inc(&counter[ACM_CNTR_ERROR]);\n\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tif (id == NL_CLIENT_INDEX)\n\t\tret = acm_nl_send(client->sock, msg);\n\telse\n\t\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int\nacmc_resolve_response(uint64_t id, struct acm_msg *req_msg, uint8_t status)\n{\n\treq_msg->hdr.opcode |= ACM_OP_ACK;\n\treq_msg->hdr.status = status;\n\tif (status != ACM_STATUS_SUCCESS)\n\t\treq_msg->hdr.length = ACM_MSG_HDR_LENGTH;\n\tmemset(req_msg->hdr.data, 0, sizeof(req_msg->hdr.data));\n\n\treturn acm_resolve_response(id, req_msg);\n}\n\nint acm_query_response(uint64_t id, struct acm_msg *msg)\n{\n\tstruct acmc_client *client = &client_array[id];\n\tint ret;\n\n\tacm_log(2, \"status 0x%x\\n\", msg->hdr.status);\n\tpthread_mutex_lock(&client->lock);\n\tif (client->sock == -1) {\n\t\tacm_log(0, \"ERROR - connection lost\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto release;\n\t}\n\n\tret = send(client->sock, (char *) msg, msg->hdr.length, 0);\n\tif (ret != msg->hdr.length)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\nrelease:\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n\treturn ret;\n}\n\nstatic int acmc_query_response(uint64_t id, struct acm_msg *msg, uint8_t status)\n{\n\tacm_log(2, \"status 0x%x\\n\", status);\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = status;\n\treturn acm_query_response(id, msg);\n}\n\nstatic void acm_init_server(void)\n{\n\tFILE *f;\n\tint i;\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tpthread_mutex_init(&client_array[i].lock, NULL);\n\t\tclient_array[i].index = i;\n\t\tclient_array[i].sock = -1;\n\t\tatomic_init(&client_array[i].refcnt);\n\t}\n\n\tif (!(f = fopen(IBACM_PORT_FILE, \"w\"))) {\n\t\tacm_log(0, \"notice - cannot publish ibacm port number\\n\");\n\t\treturn;\n\t}\n\tfprintf(f, \"%hu\\n\", server_port);\n\tfclose(f);\n}\n\nstatic int acm_listen(void)\n{\n\tstruct sockaddr_in addr;\n\tint ret;\n\n\tacm_log(2, \"\\n\");\n\tlisten_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (listen_socket == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate listen socket\\n\");\n\t\treturn errno;\n\t}\n\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htobe16(server_port);\n\tret = bind(listen_socket, (struct sockaddr *) &addr, sizeof addr);\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to bind listen socket\\n\");\n\t\treturn errno;\n\t}\n\n\tret = listen(listen_socket, 0);\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to start listen\\n\");\n\t\treturn errno;\n\t}\n\n\tacm_log(2, \"listen active\\n\");\n\treturn 0;\n}\n\nstatic void acm_disconnect_client(struct acmc_client *client)\n{\n\tpthread_mutex_lock(&client->lock);\n\tshutdown(client->sock, SHUT_RDWR);\n\tclose(client->sock);\n\tclient->sock = -1;\n\tpthread_mutex_unlock(&client->lock);\n\t(void) atomic_dec(&client->refcnt);\n}\n\nstatic void acm_svr_accept(void)\n{\n\tint s;\n\tint i;\n\n\tacm_log(2, \"\\n\");\n\ts = accept(listen_socket, NULL, NULL);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - failed to accept connection\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\tif (i == NL_CLIENT_INDEX)\n\t\t\tcontinue;\n\t\tif (!atomic_get(&client_array[i].refcnt))\n\t\t\tbreak;\n\t}\n\n\tif (i == FD_SETSIZE - 1) {\n\t\tacm_log(0, \"ERROR - all connections busy - rejecting\\n\");\n\t\tclose(s);\n\t\treturn;\n\t}\n\n\tclient_array[i].sock = s;\n\tatomic_set(&client_array[i].refcnt, 1);\n\tacm_log(2, \"assigned client %d\\n\", i);\n}\n\nstatic int\nacm_is_path_from_port(struct acmc_port *port, struct ibv_path_record *path)\n{\n\tuint8_t i;\n\n\tif (!ib_any_gid(&path->sgid)) {\n\t\treturn (acm_gid_index(&port->port, &path->sgid) <\n\t\t\tport->gid_cnt);\n\t}\n\n\tif (path->slid) {\n\t\treturn (port->lid == (be16toh(path->slid) & port->lid_mask));\n\t}\n\n\tif (ib_any_gid(&path->dgid)) {\n\t\treturn 1;\n\t}\n\n\tif (acm_gid_index(&port->port, &path->dgid) < port->gid_cnt) {\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < port->gid_cnt; i++) {\n\t\tif (port->gid_tbl[i].global.subnet_prefix ==\n\t\t    path->dgid.global.subnet_prefix) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct acmc_addr *\nacm_get_port_ep_address(struct acmc_port *port, struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acm_address *addr;\n\tint i;\n\n\tif (port->state != IBV_PORT_ACTIVE)\n\t\treturn NULL;\n\n\tif (data->type == ACM_EP_INFO_PATH &&\n\t    !acm_is_path_from_port(port, &data->info.path))\n\t\treturn NULL;\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif ((data->type == ACM_EP_INFO_PATH) &&\n\t\t    (!data->info.path.pkey ||\n\t\t     (be16toh(data->info.path.pkey) == ep->endpoint.pkey))) {\n\t\t\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\t\t\tif (ep->addr_info[i].addr.type)\n\t\t\t\t\treturn &ep->addr_info[i];\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((addr = acm_addr_lookup(&ep->endpoint, data->info.addr,\n\t\t\t\t\t    (uint8_t) data->type)))\n\t\t\treturn container_of(addr, struct acmc_addr, addr);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct acmc_addr *acm_get_ep_address(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_addr *addr;\n\tint i;\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(2, \"%s\\n\", log_data);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\taddr = acm_get_port_ep_address(&dev->port[i], data);\n\t\t\tif (addr)\n\t\t\t\treturn addr;\n\t\t}\n\t}\n\n\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\tacm_log(1, \"notice - could not find %s\\n\", log_data);\n\treturn NULL;\n}\n\nstatic struct acmc_ep *acm_get_ep(int index)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tint i, inx = 0;\n\n\tacm_log(2, \"ep index %d\\n\", index);\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each(&dev->port[i].ep_list, ep, entry) {\n\t\t\t\tif (index == inx)\n\t\t\t\t\treturn ep;\n\t\t\t}\n\t\t}\n\t}\n\n\tacm_log(1, \"notice - could not find ep %d\\n\", index);\n\treturn NULL;\n}\n\nstatic int\nacm_svr_query_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length != ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid length: 0x%x\\n\", msg->hdr.length);\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(1, \"notice - could not find local end point address\\n\");\n\t\treturn acmc_query_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->query(addr->prov_addr_context, msg, client->index);\n}\n\nstatic int acm_svr_select_src(struct acm_ep_addr_data *src, struct acm_ep_addr_data *dst)\n{\n\tunion socket_addr addr;\n\tsocklen_t len;\n\tint ret;\n\tint s;\n\n\tacm_log(2, \"selecting source address\\n\");\n\tmemset(&addr, 0, sizeof addr);\n\tswitch (dst->type) {\n\tcase ACM_EP_INFO_ADDRESS_IP:\n\t\taddr.sin.sin_family = AF_INET;\n\t\tmemcpy(&addr.sin.sin_addr, dst->info.addr, 4);\n\t\tlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase ACM_EP_INFO_ADDRESS_IP6:\n\t\taddr.sin6.sin6_family = AF_INET6;\n\t\tmemcpy(&addr.sin6.sin6_addr, dst->info.addr, 16);\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(1, \"notice - bad destination type, cannot lookup source\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\ts = socket(addr.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\tif (s == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate socket\\n\");\n\t\treturn errno;\n\t}\n\n\tret = connect(s, &addr.sa, len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to connect socket\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tret = getsockname(s, &addr.sa, &len);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to get socket address\\n\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\tsrc->type = dst->type;\n\tsrc->flags = ACM_EP_FLAG_SOURCE;\n\tif (dst->type == ACM_EP_INFO_ADDRESS_IP) {\n\t\tmemcpy(&src->info.addr, &addr.sin.sin_addr, 4);\n\t} else {\n\t\tmemcpy(&src->info.addr, &addr.sin6.sin6_addr, 16);\n\t}\nout:\n\tclose(s);\n\treturn ret;\n}\n\n/*\n * Verify the resolve message from the client and return\n * references to the source and destination addresses.\n * The message buffer contains extra address data buffers.  If a\n * source address is not given, reference an empty address buffer,\n * and we'll resolve a source address later.  Record the location of\n * the source and destination addresses in the message header data\n * to avoid further searches.\n */\nstatic uint8_t acm_svr_verify_resolve(struct acm_msg *msg)\n{\n\tint i, cnt, have_dst = 0;\n\n\tif (msg->hdr.length < ACM_MSG_HDR_LENGTH) {\n\t\tacm_log(0, \"ERROR - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn ACM_STATUS_EINVAL;\n\t}\n\n\tmsg->hdr.src_out = 1;\n\tcnt = (msg->hdr.length - ACM_MSG_HDR_LENGTH) / ACM_MSG_EP_LENGTH;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_SOURCE) {\n\t\t\tif (!msg->hdr.src_out) {\n\t\t\t\tacm_log(0, \"ERROR - multiple sources specified\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported source address type\\n\");\n\t\t\t\treturn ACM_STATUS_ESRCTYPE;\n\t\t\t}\n\t\t\tmsg->hdr.src_out = 0;\n\t\t\tmsg->hdr.src_index = i;\n\t\t}\n\t\tif (msg->resolve_data[i].flags & ACM_EP_FLAG_DEST) {\n\t\t\tif (have_dst) {\n\t\t\t\tacm_log(0, \"ERROR - multiple destinations specified\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTADDR;\n\t\t\t}\n\t\t\tif (!msg->resolve_data[i].type ||\n\t\t\t    (msg->resolve_data[i].type >= ACM_ADDRESS_RESERVED)) {\n\t\t\t\tacm_log(0, \"ERROR - unsupported destination address type\\n\");\n\t\t\t\treturn ACM_STATUS_EDESTTYPE;\n\t\t\t}\n\t\t\thave_dst = 1;\n\t\t\tmsg->hdr.dst_index = i;\n\t\t}\n\t}\n\n\tif (!have_dst) {\n\t\tacm_log(0, \"ERROR - destination address required\\n\");\n\t\treturn ACM_STATUS_EDESTTYPE;\n\t}\n\n\tif (msg->hdr.src_out) {\n\t\tmsg->hdr.src_index = i;\n\t\tmemset(&msg->resolve_data[i], 0, sizeof(struct acm_ep_addr_data));\n\t}\n\treturn ACM_STATUS_SUCCESS;\n}\n\nstatic int\nacm_svr_resolve_dest(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct acm_ep_addr_data *saddr, *daddr;\n\tuint8_t status;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tstatus = acm_svr_verify_resolve(msg);\n\tif (status) {\n\t\tacm_log(0, \"notice - misformatted or unsupported request\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, status);\n\t}\n\n\tsaddr = &msg->resolve_data[msg->hdr.src_index];\n\tdaddr = &msg->resolve_data[msg->hdr.dst_index];\n\tif (msg->hdr.src_out) {\n\t\tstatus = acm_svr_select_src(saddr, daddr);\n\t\tif (status) {\n\t\t\tacm_log(0, \"notice - unable to select suitable source address\\n\");\n\t\t\treturn acmc_resolve_response(client->index, msg, status);\n\t\t}\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data,\n\t\t\tsaddr->type, saddr->info.addr, sizeof saddr->info.addr);\n\tacm_log(2, \"src  %s\\n\", log_data);\n\taddr = acm_get_ep_address(saddr);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg, client->index);\n}\n\n/*\n * The message buffer contains extra address data buffers.  We extract the\n * destination address from the path record into an extra buffer, so we can\n * lookup the destination by either LID or GID.\n */\nstatic int\nacm_svr_resolve_path(struct acmc_client *client, struct acm_msg *msg)\n{\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep;\n\tstruct ibv_path_record *path;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tif (msg->hdr.length < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)) {\n\t\tacm_log(0, \"notice - invalid msg hdr length %d\\n\", msg->hdr.length);\n\t\treturn acmc_resolve_response(client->index, msg, ACM_STATUS_EINVAL);\n\t}\n\n\tpath = &msg->resolve_data[0].info.path;\n\tif (!path->dlid && ib_any_gid(&path->dgid)) {\n\t\tacm_log(0, \"notice - no destination specified\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_EDESTADDR);\n\t}\n\n\tacm_format_name(2, log_data, sizeof log_data, ACM_EP_INFO_PATH,\n\t\tmsg->resolve_data[0].info.addr, sizeof *path);\n\tacm_log(2, \"path %s\\n\", log_data);\n\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\tif (!addr) {\n\t\tacm_log(0, \"notice - unknown local end point address\\n\");\n\t\treturn acmc_resolve_response(client->index, msg,\n\t\t\t\t\t     ACM_STATUS_ESRCADDR);\n\t}\n\n\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\treturn ep->port->prov->resolve(addr->prov_addr_context, msg,\n\t\t\t\t       client->index);\n}\n\nstatic int acm_svr_resolve(struct acmc_client *client, struct acm_msg *msg)\n{\n\t(void) atomic_inc(&client->refcnt);\n\n\tif (msg->resolve_data[0].type == ACM_EP_INFO_PATH) {\n\t\tif (msg->resolve_data[0].flags & ACM_FLAGS_QUERY_SA) {\n\t\t\treturn acm_svr_query_path(client, msg);\n\t\t} else {\n\t\t\treturn acm_svr_resolve_path(client, msg);\n\t\t}\n\t} else {\n\t\treturn acm_svr_resolve_dest(client, msg);\n\t}\n}\n\nstatic int acm_svr_perf_query(struct acmc_client *client, struct acm_msg *msg)\n{\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_addr *addr;\n\tstruct acmc_ep *ep = NULL;\n\tint index;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.data[1];\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\tmsg->hdr.data[2] = 0;\n\n\tif ((be16toh(msg->hdr.length) < (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && index < 1) ||\n\t    ((be16toh(msg->hdr.length) >= (ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH)\n\t    && !(msg->resolve_data[0].flags & ACM_EP_FLAG_SOURCE)))) {\n\t\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\t\tmsg->perf_data[i] = htobe64((uint64_t) atomic_get(&counter[i]));\n\n\t\tmsg->hdr.data[0] = ACM_MAX_COUNTER;\n\t\tlen = ACM_MSG_HDR_LENGTH + (ACM_MAX_COUNTER * sizeof(uint64_t));\n\t} else {\n\t\tif (index >= 1) {\n\t\t\tep = acm_get_ep(index - 1);\n\t\t} else {\n\t\t\taddr = acm_get_ep_address(&msg->resolve_data[0]);\n\t\t\tif (addr)\n\t\t\t\tep = container_of(addr->addr.endpoint,\n\t\t\t\t\t\t  struct acmc_ep, endpoint);\n\t\t}\n\n\t\tif (ep) {\n\t\t\tep->port->prov->query_perf(ep->prov_ep_context,\n\t\t\t\t\t\t   msg->perf_data, &msg->hdr.data[0]);\n\t\t\tlen = ACM_MSG_HDR_LENGTH + (msg->hdr.data[0] * sizeof(uint64_t));\n\t\t} else {\n\t\t\tmsg->hdr.status = ACM_STATUS_ESRCADDR;\n\t\t\tlen = ACM_MSG_HDR_LENGTH;\n\t\t}\n\t}\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int acm_svr_ep_query(struct acmc_client *client, struct acm_msg *msg)\n{\n\tint ret, i;\n\tuint16_t len;\n\tstruct acmc_ep *ep;\n\tint index, cnt = 0;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tindex = msg->hdr.data[0];\n\tep = acm_get_ep(index - 1);\n\tif (ep) {\n\t\tmsg->hdr.status = ACM_STATUS_SUCCESS;\n\t\tmsg->ep_data[0].dev_guid = ep->port->dev->device.dev_guid;\n\t\tmsg->ep_data[0].port_num = ep->port->port.port_num;\n\t\tmsg->ep_data[0].pkey = htobe16(ep->endpoint.pkey);\n\t\tstrncpy((char *)msg->ep_data[0].prov_name, ep->port->prov->name,\n\t\t\tACM_MAX_PROV_NAME - 1);\n\t\tmsg->ep_data[0].prov_name[ACM_MAX_PROV_NAME - 1] = '\\0';\n\t\tlen = ACM_MSG_HDR_LENGTH + sizeof(struct acm_ep_config_data);\n\t\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\t\tif (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID) {\n\t\t\t\tmemcpy(msg->ep_data[0].addrs[cnt++].name,\n\t\t\t\t       ep->addr_info[i].string_buf,\n\t\t\t\t       ACM_MAX_ADDRESS);\n\t\t\t}\n\t\t}\n\t\tmsg->ep_data[0].addr_cnt = htobe16(cnt);\n\t\tlen += cnt * ACM_MAX_ADDRESS;\n\t} else {\n\t\tmsg->hdr.status = ACM_STATUS_EINVAL;\n\t\tlen = ACM_MSG_HDR_LENGTH;\n\t}\n\tmsg->hdr.opcode |= ACM_OP_ACK;\n\tmsg->hdr.data[1] = 0;\n\tmsg->hdr.data[2] = 0;\n\tmsg->hdr.length = htobe16(len);\n\n\tret = send(client->sock, (char *) msg, len, 0);\n\tif (ret != len)\n\t\tacm_log(0, \"ERROR - failed to send response\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int acm_msg_length(struct acm_msg *msg)\n{\n\treturn (msg->hdr.opcode == ACM_OP_RESOLVE) ?\n\t\tmsg->hdr.length : be16toh(msg->hdr.length);\n}\n\nstatic void acm_svr_receive(struct acmc_client *client)\n{\n\tstruct acm_msg msg;\n\tint ret;\n\n\tacm_log(2, \"client %d\\n\", client->index);\n\tret = recv(client->sock, (char *) &msg, sizeof msg, 0);\n\tif (ret <= 0 || ret != acm_msg_length(&msg)) {\n\t\tacm_log(2, \"client disconnected\\n\");\n\t\tret = ACM_STATUS_ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (msg.hdr.version != ACM_VERSION) {\n\t\tacm_log(0, \"ERROR - unsupported version %d\\n\", msg.hdr.version);\n\t\tgoto out;\n\t}\n\n\tswitch (msg.hdr.opcode & ACM_OP_MASK) {\n\tcase ACM_OP_RESOLVE:\n\t\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\t\tret = acm_svr_resolve(client, &msg);\n\t\tbreak;\n\tcase ACM_OP_PERF_QUERY:\n\t\tret = acm_svr_perf_query(client, &msg);\n\t\tbreak;\n\tcase ACM_OP_EP_QUERY:\n\t\tret = acm_svr_ep_query(client, &msg);\n\t\tbreak;\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown opcode 0x%x\\n\", msg.hdr.opcode);\n\t\tbreak;\n\t}\n\nout:\n\tif (ret)\n\t\tacm_disconnect_client(client);\n}\n\nstatic int acm_nl_to_addr_data(struct acm_ep_addr_data *ad,\n\t\t\t\t  int af_family, uint8_t *addr, size_t addr_len)\n{\n\tif (addr_len > ACM_MAX_ADDRESS)\n\t\treturn EINVAL;\n\n\t/* find the ep associated with this address \"if any\" */\n\tswitch (af_family) {\n\tcase AF_INET:\n\t\tad->type = ACM_ADDRESS_IP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tad->type = ACM_ADDRESS_IP6;\n\t\tbreak;\n\tdefault:\n\t\treturn EINVAL;\n\t}\n\tmemcpy(&ad->info.addr, addr, addr_len);\n\treturn 0;\n}\n\nstatic void acm_add_ep_ip(char *ifname, struct acm_ep_addr_data *data, char *ip_str)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_device *dev;\n\tuint8_t port_num;\n\tuint16_t pkey;\n\tunion ibv_gid sgid;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tacm_log(1, \"Address '%s' already available\\n\", ip_str);\n\t\treturn;\n\t}\n\n\tif (acm_if_get_sgid(ifname, &sgid))\n\t\treturn;\n\n\tdev = acm_get_device_from_gid(&sgid, &port_num);\n\tif (!dev)\n\t\treturn;\n\n\tif (acm_if_get_pkey(ifname, &pkey))\n\t\treturn;\n\n\tacm_log(0, \" %s\\n\", ip_str);\n\n\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\tif (ep) {\n\t\tif (acm_ep_insert_addr(ep, ip_str, data->info.addr,\n\t\t\t\t       sizeof data->info.addr, data->type))\n\t\t\tacm_log(0, \"Failed to add '%s' to EP\\n\", ip_str);\n\t} else {\n\t\tacm_log(0, \"Failed to add '%s' no EP for pkey\\n\", ip_str);\n\t}\n}\n\nstatic void acm_rm_ep_ip(struct acm_ep_addr_data *data)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_addr *addr;\n\n\taddr = acm_get_ep_address(data);\n\tif (addr) {\n\t\tep = container_of(addr->addr.endpoint, struct acmc_ep, endpoint);\n\t\tacm_format_name(0, log_data, sizeof log_data,\n\t\t\t\tdata->type, data->info.addr, sizeof data->info.addr);\n\t\tacm_log(0, \" %s\\n\", log_data);\n\t\tacm_mark_addr_invalid(ep, data);\n\t}\n}\n\nstatic int acm_ipnl_create(void)\n{\n\tstruct sockaddr_nl addr;\n\n\tif ((ip_mon_socket = socket(PF_NETLINK, SOCK_RAW | SOCK_NONBLOCK, NETLINK_ROUTE)) == -1) {\n\t\tacm_log(0, \"Failed to open NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;\n\n\tif (bind(ip_mon_socket, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tacm_log(0, \"Failed to bind NETLINK_ROUTE socket\");\n\t\treturn EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr, size_t addr_len,\n\t\tchar *ip_str, void *ctx)\n{\n\tint ret = EINVAL;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep;\n\tuint8_t port_num;\n\tchar gid_str[INET6_ADDRSTRLEN];\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev) {\n\t\tep = acm_find_ep(&dev->port[port_num - 1], pkey);\n\t\tif (ep)\n\t\t\tret = acm_ep_insert_addr(ep, ip_str, addr, addr_len, addr_type);\n\t}\n\n\tif (ret) {\n\t\tinet_ntop(AF_INET6, gid->raw, gid_str, sizeof(gid_str));\n\t\tacm_log(0, \"Failed to add '%s' (gid %s; pkey 0x%x)\\n\",\n\t\t\tip_str, gid_str, pkey);\n\t}\n}\n\n/* Netlink updates have indicated a failure which means we are no longer in\n * sync.  This should be a rare condition so we handle this with a \"big\n * hammer\" by clearing and re-reading all the system IP's.\n */\nstatic int resync_system_ips(void)\n{\n\tstruct acmc_device *dev;\n\tstruct acmc_port *port;\n\tstruct acmc_ep *ep;\n\tint i, cnt;\n\n\tacm_log(0, \"Resyncing all IP's\\n\");\n\n\t/* mark all IP's invalid */\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (cnt = 0; cnt < dev->port_cnt; cnt++) {\n\t\t\tport = &dev->port[cnt];\n\n\t\t\tlist_for_each(&port->ep_list, ep, entry) {\n\t\t\t\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\t\t\t\tif (ep->addr_info[i].addr.type == ACM_ADDRESS_IP ||\n\t\t\t\t\t    ep->addr_info[i].addr.type == ACM_ADDRESS_IP6)\n\t\t\t\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn acm_if_iter_sys(acm_ip_iter_cb, NULL);\n}\n\nstatic void acm_ipnl_handler(void)\n{\n\tint len;\n\tchar buffer[NL_MSG_BUF_SIZE];\n\tstruct nlmsghdr *nlh;\n\tchar ifname[IFNAMSIZ];\n\tchar ip_str[INET6_ADDRSTRLEN];\n\tstruct acm_ep_addr_data ad;\n\n\twhile ((len = recv(ip_mon_socket, buffer, NL_MSG_BUF_SIZE, 0)) > 0) {\n\t\tnlh = (struct nlmsghdr *)buffer;\n\t\twhile ((NLMSG_OK(nlh, len)) && (nlh->nlmsg_type != NLMSG_DONE)) {\n\t\t\tstruct ifaddrmsg *ifa = (struct ifaddrmsg *) NLMSG_DATA(nlh);\n\t\t\tstruct ifinfomsg *ifi = (struct ifinfomsg *) NLMSG_DATA(nlh);\n\t\t\tstruct rtattr *rth = IFA_RTA(ifa);\n\t\t\tint rtl = IFA_PAYLOAD(nlh);\n\n\t\t\tswitch (nlh->nlmsg_type) {\n\t\t\tcase RTM_NEWADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"New system address available %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_add_ep_ip(ifname, &ad, ip_str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELADDR:\n\t\t\t\tif_indextoname(ifa->ifa_index, ifname);\n\t\t\t\twhile (rtl && RTA_OK(rth, rtl)) {\n\t\t\t\t\tif (rth->rta_type == IFA_LOCAL) {\n\t\t\t\t\t\tacm_log(1, \"System address removed %s : %s\\n\",\n\t\t\t\t\t\t        ifname, inet_ntop(ifa->ifa_family, RTA_DATA(rth),\n\t\t\t\t\t\t\tip_str, sizeof(ip_str)));\n\t\t\t\t\t\tif (!acm_nl_to_addr_data(&ad, ifa->ifa_family,\n\t\t\t\t\t\t\t\t      RTA_DATA(rth),\n\t\t\t\t\t\t\t\t      RTA_PAYLOAD(rth))) {\n\t\t\t\t\t\t\tacm_rm_ep_ip(&ad);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trth = RTA_NEXT(rth, rtl);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RTM_NEWLINK:\n\t\t\t\tacm_log(2, \"Link added : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tcase RTM_DELLINK:\n\t\t\t\tacm_log(2, \"Link removed : %s\\n\",\n\t\t\t\t\tif_indextoname(ifi->ifi_index, ifname));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tacm_log(2, \"unknown netlink message\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnlh = NLMSG_NEXT(nlh, len);\n\t\t}\n\t}\n\n\tif (len < 0 && errno == ENOBUFS) {\n\t\tacm_log(0, \"ENOBUFS returned from netlink...\\n\");\n\t\tresync_system_ips();\n\t}\n}\n\nstatic int acm_nl_send(int sock, struct acm_msg *msg)\n{\n\tstruct sockaddr_nl dst_addr;\n\tstruct acm_nl_msg acmnlmsg;\n\tstruct acm_nl_msg *orig;\n\tint ret;\n\tint datalen;\n\n\torig = (struct acm_nl_msg *)(uintptr_t)msg->hdr.tid;\n\n\tmemset(&dst_addr, 0, sizeof(dst_addr));\n\tdst_addr.nl_family = AF_NETLINK;\n\tdst_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tmemset(&acmnlmsg, 0, sizeof(acmnlmsg));\n\tacmnlmsg.nlmsg_header.nlmsg_len = NLMSG_HDRLEN;\n\tacmnlmsg.nlmsg_header.nlmsg_pid = getpid();\n\tacmnlmsg.nlmsg_header.nlmsg_type = orig->nlmsg_header.nlmsg_type;\n\tacmnlmsg.nlmsg_header.nlmsg_seq = orig->nlmsg_header.nlmsg_seq;\n\n\tif (msg->hdr.status != ACM_STATUS_SUCCESS) {\n\t\tacm_log(2, \"acm status no success = %d\\n\", msg->hdr.status);\n\t\tacmnlmsg.nlmsg_header.nlmsg_flags |= RDMA_NL_LS_F_ERR;\n\t} else {\n\t\tacm_log(2, \"acm status success\\n\");\n\t\tacmnlmsg.nlmsg_header.nlmsg_len +=\n\t\t\tNLA_ALIGN(sizeof(struct acm_nl_path));\n\t\tacmnlmsg.path[0].attr_hdr.nla_type = LS_NLA_TYPE_PATH_RECORD;\n\t\tacmnlmsg.path[0].attr_hdr.nla_len = sizeof(struct acm_nl_path);\n\t\tif (orig->resolve_header.path_use ==\n\t\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_OUTBOUND;\n\t\telse\n\t\t\tacmnlmsg.path[0].rec.flags = IB_PATH_PRIMARY |\n\t\t\t\tIB_PATH_GMP | IB_PATH_BIDIRECTIONAL;\n\t\tmemcpy(acmnlmsg.path[0].rec.path_rec,\n\t\t       &msg->resolve_data[0].info.path,\n\t\t       sizeof(struct ibv_path_record));\n\t}\n\n\tdatalen = NLMSG_ALIGN(acmnlmsg.nlmsg_header.nlmsg_len);\n\tret = sendto(sock, &acmnlmsg, datalen, 0,\n\t\t     (const struct sockaddr *)&dst_addr,\n\t\t     (socklen_t)sizeof(dst_addr));\n\tif (ret != datalen) {\n\t\tacm_log(0, \"ERROR - sendto = %d errno = %d\\n\", ret, errno);\n\t\tret = -1;\n\t} else {\n\t\tret = msg->hdr.length;\n\t}\n\n\tfree(orig);\n\n\treturn ret;\n}\n\n#define NLA_LEN(nla)\t((nla)->nla_len - NLA_HDRLEN)\n#define NLA_DATA(nla)\t((char *)(nla) + NLA_HDRLEN)\n\nstatic int acm_nl_parse_path_attr(struct nlattr *attr,\n\t\t\t\t   struct acm_ep_addr_data *data)\n{\n\tstruct ibv_path_record *path;\n\tuint64_t  *sid;\n\tstruct rdma_nla_ls_gid *gid;\n\tuint8_t *tcl;\n\tuint16_t *pkey;\n\tuint16_t *qos;\n\tuint16_t val;\n\tint ret = 0;\n\n#define IBV_PATH_RECORD_QOS_MASK 0xfff0\n\n\tpath = &data->info.path;\n\tswitch (attr->nla_type & RDMA_NLA_TYPE_MASK) {\n\tcase LS_NLA_TYPE_SERVICE_ID:\n\t\tsid = (uint64_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*sid)) {\n\t\t\tacm_log(2, \"service_id 0x%\" PRIx64 \"\\n\", *sid);\n\t\t\tpath->service_id = htobe64(*sid);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_DGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path dgid %s\\n\", log_data);\n\t\t\tmemcpy(path->dgid.raw, gid->gid, sizeof(path->dgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_DEST;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_SGID:\n\t\tgid = (struct rdma_nla_ls_gid *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(gid->gid)) {\n\t\t\tacm_format_name(2, log_data, sizeof(log_data),\n\t\t\t\t\tACM_ADDRESS_GID, gid->gid,\n\t\t\t\t\tsizeof(union ibv_gid));\n\t\t\tacm_log(2, \"path sgid %s\\n\", log_data);\n\t\t\tmemcpy(path->sgid.raw, gid->gid, sizeof(path->sgid));\n\t\t\tdata->flags |= ACM_EP_FLAG_SOURCE;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_TCLASS:\n\t\ttcl = (uint8_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*tcl)) {\n\t\t\tacm_log(2, \"tclass 0x%x\\n\", *tcl);\n\t\t\tpath->tclass = *tcl;\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_PKEY:\n\t\tpkey = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*pkey)) {\n\t\t\tacm_log(2, \"pkey 0x%x\\n\", *pkey);\n\t\t\tpath->pkey = htobe16(*pkey);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tcase LS_NLA_TYPE_QOS_CLASS:\n\t\tqos = (uint16_t *) NLA_DATA(attr);\n\t\tif (NLA_LEN(attr) == sizeof(*qos)) {\n\t\t\tacm_log(2, \"qos_class 0x%x\\n\", *qos);\n\t\t\tval = be16toh(path->qosclass_sl);\n\t\t\tval &= ~IBV_PATH_RECORD_QOS_MASK;\n\t\t\tval |= (*qos & IBV_PATH_RECORD_QOS_MASK);\n\t\t\tpath->qosclass_sl = htobe16(val);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tacm_log(1, \"WARN: unknown attr %x\\n\", attr->nla_type);\n\t\t/* We can not ignore a mandatory attribute */\n\t\tif (attr->nla_type & RDMA_NLA_F_MANDATORY)\n\t\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void acm_nl_process_invalid_request(struct acmc_client *client,\n\t\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_EINVAL;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\n\tacm_nl_send(client->sock, &msg);\n}\n\nstatic void acm_nl_process_resolve(struct acmc_client *client,\n\t\t\t\t   struct acm_nl_msg *acmnlmsg)\n{\n\tstruct acm_msg msg;\n\tstruct nlattr *attr;\n\tint payload_len;\n\tint resolve_hdr_len;\n\tint rem;\n\tint total_attr_len;\n\tint status;\n\tunsigned char *data;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.hdr.opcode = ACM_OP_RESOLVE;\n\tmsg.hdr.version = ACM_VERSION;\n\tmsg.hdr.length = ACM_MSG_HDR_LENGTH + ACM_MSG_EP_LENGTH;\n\tmsg.hdr.status = ACM_STATUS_SUCCESS;\n\tmsg.hdr.tid = (uintptr_t) acmnlmsg;\n\tmsg.resolve_data[0].type = ACM_EP_INFO_PATH;\n\n\t/* We support only one pathrecord */\n\tacm_log(2, \"path use 0x%x\\n\", acmnlmsg->resolve_header.path_use);\n\tif (acmnlmsg->resolve_header.path_use ==\n\t    LS_RESOLVE_PATH_USE_UNIDIRECTIONAL)\n\t\tmsg.resolve_data[0].info.path.reversible_numpath = 1;\n\telse\n\t\tmsg.resolve_data[0].info.path.reversible_numpath =\n\t\t\tIBV_PATH_RECORD_REVERSIBLE | 1;\n\n\tdata = (unsigned char *) &acmnlmsg->nlmsg_header + NLMSG_HDRLEN;\n\tresolve_hdr_len = NLMSG_ALIGN(sizeof(struct rdma_ls_resolve_header));\n\tattr = (struct nlattr *) (data + resolve_hdr_len);\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN -\n\t\tresolve_hdr_len;\n\trem = payload_len;\n\twhile (1) {\n\t\tif (rem < (int) sizeof(*attr) ||\n\t\t    attr->nla_len < sizeof(*attr) ||\n\t\t    attr->nla_len > rem)\n\t\t\tbreak;\n\n\t\tstatus = acm_nl_parse_path_attr(attr, &msg.resolve_data[0]);\n\t\tif (status) {\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Next attribute */\n\t\ttotal_attr_len = NLA_ALIGN(attr->nla_len);\n\t\trem -= total_attr_len;\n\t\tattr = (struct nlattr *) ((char *) attr + total_attr_len);\n\t}\n\n\tatomic_inc(&counter[ACM_CNTR_RESOLVE]);\n\tacm_svr_resolve(client, &msg);\n}\n\nstatic int acm_nl_is_valid_resolve_request(struct acm_nl_msg *acmnlmsg)\n{\n\tint payload_len;\n\n\tpayload_len = acmnlmsg->nlmsg_header.nlmsg_len - NLMSG_HDRLEN;\n\tif (payload_len < (sizeof(struct rdma_ls_resolve_header) +\n\t\t\t   sizeof(struct nlattr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void acm_nl_receive(struct acmc_client *client)\n{\n\tstruct acm_nl_msg *acmnlmsg;\n\tint datalen = sizeof(*acmnlmsg);\n\tint ret;\n\tuint16_t client_inx, op;\n\n\tacmnlmsg = calloc(1, sizeof(*acmnlmsg));\n\tif (!acmnlmsg) {\n\t\tacm_log(0, \"Out of memory for recving nl msg.\\n\");\n\t\treturn;\n\t}\n\tret = recv(client->sock, acmnlmsg, datalen, 0);\n\tif (!NLMSG_OK(&acmnlmsg->nlmsg_header, ret)) {\n\t\tacm_log(0, \"Netlink receive error: %d.\\n\", ret);\n\t\tgoto rcv_cleanup;\n\t}\n\n\tacm_log(2, \"nlmsg: len %d type 0x%x flags 0x%x seq %d pid %d\\n\",\n\t\tacmnlmsg->nlmsg_header.nlmsg_len,\n\t\tacmnlmsg->nlmsg_header.nlmsg_type,\n\t\tacmnlmsg->nlmsg_header.nlmsg_flags,\n\t\tacmnlmsg->nlmsg_header.nlmsg_seq,\n\t\tacmnlmsg->nlmsg_header.nlmsg_pid);\n\n\t/* Currently we handle only request from the local service client */\n\tclient_inx = RDMA_NL_GET_CLIENT(acmnlmsg->nlmsg_header.nlmsg_type);\n\top = RDMA_NL_GET_OP(acmnlmsg->nlmsg_header.nlmsg_type);\n\tif (client_inx != RDMA_NL_LS)\n\t\tgoto rcv_cleanup;\n\n\tswitch (op) {\n\tcase RDMA_NL_LS_OP_RESOLVE:\n\t\tif (acm_nl_is_valid_resolve_request(acmnlmsg))\n\t\t\tacm_nl_process_resolve(client, acmnlmsg);\n\t\telse\n\t\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\tdefault:\n\t\t/* Not supported*/\n\t\tacm_log(1, \"WARN - invalid opcode %x\\n\", op);\n\t\tacm_nl_process_invalid_request(client, acmnlmsg);\n\t\tbreak;\n\t}\n\n\treturn;\nrcv_cleanup:\n\tfree(acmnlmsg);\n}\n\nstatic int acm_init_nl(void)\n{\n\tstruct sockaddr_nl src_addr;\n\tint ret;\n\tint nl_rcv_socket;\n\n\tnl_rcv_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_RDMA);\n\tif (nl_rcv_socket == -1) {\n\t\tacm_log(0, \"ERROR - unable to allocate netlink recv socket\\n\");\n\t\treturn errno;\n\t}\n\n\tmemset(&src_addr, 0, sizeof(src_addr));\n\tsrc_addr.nl_family = AF_NETLINK;\n\tsrc_addr.nl_pid = getpid();\n\tsrc_addr.nl_groups = (1 << (RDMA_NL_GROUP_LS - 1));\n\n\tret = bind(nl_rcv_socket, (struct sockaddr *)&src_addr,\n\t\t   sizeof(src_addr));\n\tif (ret == -1) {\n\t\tacm_log(0, \"ERROR - unable to bind netlink socket\\n\");\n\t\tclose(nl_rcv_socket);\n\t\treturn errno;\n\t}\n\n\t/* init nl client structure */\n\tclient_array[NL_CLIENT_INDEX].sock = nl_rcv_socket;\n\treturn 0;\n}\n\nstatic void acm_server(void)\n{\n\tfd_set readfds;\n\tint i, n, ret;\n\tstruct acmc_device *dev;\n\n\tacm_log(0, \"started\\n\");\n\tacm_init_server();\n\tret = acm_listen();\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - server listen failed\\n\");\n\t\treturn;\n\t}\n\n\tret = acm_init_nl();\n\tif (ret)\n\t\tacm_log(1, \"Warn - Netlink init failed\\n\");\n\n\twhile (1) {\n\t\tn = (int) listen_socket;\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(listen_socket, &readfds);\n\t\tn = max(n, (int) ip_mon_socket);\n\t\tFD_SET(ip_mon_socket, &readfds);\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1) {\n\t\t\t\tFD_SET(client_array[i].sock, &readfds);\n\t\t\t\tn = max(n, (int) client_array[i].sock);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tFD_SET(dev->device.verbs->async_fd, &readfds);\n\t\t\tn = max(n, (int) dev->device.verbs->async_fd);\n\t\t}\n\n\t\tret = select(n + 1, &readfds, NULL, NULL, NULL);\n\t\tif (ret == -1) {\n\t\t\tacm_log(0, \"ERROR - server select error\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(listen_socket, &readfds))\n\t\t\tacm_svr_accept();\n\n\t\tif (FD_ISSET(ip_mon_socket, &readfds))\n\t\t\tacm_ipnl_handler();\n\n\t\tfor (i = 0; i < FD_SETSIZE - 1; i++) {\n\t\t\tif (client_array[i].sock != -1 &&\n\t\t\t\tFD_ISSET(client_array[i].sock, &readfds)) {\n\t\t\t\tacm_log(2, \"receiving from client %d\\n\", i);\n\t\t\t\tif (i == NL_CLIENT_INDEX)\n\t\t\t\t\tacm_nl_receive(&client_array[i]);\n\t\t\t\telse\n\t\t\t\t\tacm_svr_receive(&client_array[i]);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each(&dev_list, dev, entry) {\n\t\t\tif (FD_ISSET(dev->device.verbs->async_fd, &readfds)) {\n\t\t\t\tacm_log(2, \"handling event from %s\\n\",\n\t\t\t\t\tdev->device.verbs->device->name);\n\t\t\t\tacm_event_handler(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum ibv_rate acm_get_rate(uint8_t width, uint8_t speed)\n{\n\tswitch (width) {\n\tcase 1:\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_2_5_GBPS;\n\t\tcase 2: return IBV_RATE_5_GBPS;\n\t\tcase 4: return IBV_RATE_10_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 2:\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_10_GBPS;\n\t\tcase 2: return IBV_RATE_20_GBPS;\n\t\tcase 4: return IBV_RATE_40_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 4:\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_20_GBPS;\n\t\tcase 2: return IBV_RATE_40_GBPS;\n\t\tcase 4: return IBV_RATE_80_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tcase 8:\n\t\tswitch (speed) {\n\t\tcase 1: return IBV_RATE_30_GBPS;\n\t\tcase 2: return IBV_RATE_60_GBPS;\n\t\tcase 4: return IBV_RATE_120_GBPS;\n\t\tdefault: return IBV_RATE_MAX;\n\t\t}\n\tdefault:\n\t\tacm_log(0, \"ERROR - unknown link width 0x%x\\n\", width);\n\t\treturn IBV_RATE_MAX;\n\t}\n}\n\nenum ibv_mtu acm_convert_mtu(int mtu)\n{\n\tswitch (mtu) {\n\tcase 256:  return IBV_MTU_256;\n\tcase 512:  return IBV_MTU_512;\n\tcase 1024: return IBV_MTU_1024;\n\tcase 2048: return IBV_MTU_2048;\n\tcase 4096: return IBV_MTU_4096;\n\tdefault:   return IBV_MTU_2048;\n\t}\n}\n\nenum ibv_rate acm_convert_rate(int rate)\n{\n\tswitch (rate) {\n\tcase 2:   return IBV_RATE_2_5_GBPS;\n\tcase 5:   return IBV_RATE_5_GBPS;\n\tcase 10:  return IBV_RATE_10_GBPS;\n\tcase 20:  return IBV_RATE_20_GBPS;\n\tcase 30:  return IBV_RATE_30_GBPS;\n\tcase 40:  return IBV_RATE_40_GBPS;\n\tcase 60:  return IBV_RATE_60_GBPS;\n\tcase 80:  return IBV_RATE_80_GBPS;\n\tcase 120: return IBV_RATE_120_GBPS;\n\tdefault:  return IBV_RATE_10_GBPS;\n\t}\n}\n\nstatic FILE *acm_open_addr_file(void)\n{\n\tFILE *f;\n\n\tif ((f = fopen(addr_file, \"r\")))\n\t\treturn f;\n\n\tacm_log(0, \"notice - generating %s file\\n\", addr_file);\n\tif (!(f = popen(acme, \"r\"))) {\n\t\tacm_log(0, \"ERROR - cannot generate %s\\n\", addr_file);\n\t\treturn NULL;\n\t}\n\tpclose(f);\n\treturn fopen(addr_file, \"r\");\n}\n\nstatic int\nacm_ep_insert_addr(struct acmc_ep *ep, const char *name, uint8_t *addr,\n\t\t   size_t addr_len, uint8_t addr_type)\n{\n\tint i, ret = -1;\n\tuint8_t tmp[ACM_MAX_ADDRESS];\n\n\tif (addr_len > ACM_MAX_ADDRESS)\n\t\treturn EINVAL;\n\n\tmemset(tmp, 0, sizeof tmp);\n\tmemcpy(tmp, addr, addr_len);\n\n\tif (!acm_addr_lookup(&ep->endpoint, addr, addr_type)) {\n\t\tfor (i = 0; (i < MAX_EP_ADDR) &&\n\t\t\t    (ep->addr_info[i].addr.type != ACM_ADDRESS_INVALID); i++)\n\t\t\t;\n\t\tif (i == MAX_EP_ADDR) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Open the provider endpoint only if at least a name or\n\t\t   address is found */\n\t\tif (!ep->prov_ep_context) {\n\t\t\tret = ep->port->prov->open_endpoint(&ep->endpoint,\n\t\t\t\tep->port->prov_port_context,\n\t\t\t\t&ep->prov_ep_context);\n\t\t\tif (ret) {\n\t\t\t\tacm_log(0, \"Error: failed to open prov ep\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tep->addr_info[i].addr.type = addr_type;\n\t\tstrncpy(ep->addr_info[i].string_buf, name, ACM_MAX_ADDRESS);\n\t\tmemcpy(ep->addr_info[i].addr.info.addr, tmp, ACM_MAX_ADDRESS);\n\t\tret = ep->port->prov->add_address(&ep->addr_info[i].addr,\n\t\t\t\t\t\t  ep->prov_ep_context,\n\t\t\t\t\t\t  &ep->addr_info[i].prov_addr_context);\n\t\tif (ret) {\n\t\t\tacm_log(0, \"Error: failed to add addr to provider\\n\");\n\t\t\tep->addr_info[i].addr.type = ACM_ADDRESS_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic struct acmc_device *\nacm_get_device_from_gid(union ibv_gid *sgid, uint8_t *port)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (*port = 1; *port <= dev->port_cnt; (*port)++) {\n\n\t\t\tfor (i = 0; i < dev->port[*port - 1].gid_cnt; i++) {\n\n\t\t\t\tif (!memcmp(sgid->raw,\n\t\t\t\t\t    dev->port[*port - 1].gid_tbl[i].raw,\n\t\t\t\t\t    sizeof(*sgid)))\n\t\t\t\t\treturn dev;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_ep_ip_iter_cb(char *ifname, union ibv_gid *gid, uint16_t pkey,\n\t\tuint8_t addr_type, uint8_t *addr, size_t addr_len,\n\t\tchar *ip_str, void *ctx)\n{\n\tuint8_t port_num;\n\tstruct acmc_device *dev;\n\tstruct acmc_ep *ep = ctx;\n\n\tdev = acm_get_device_from_gid(gid, &port_num);\n\tif (dev && ep->port->dev == dev\n\t    && ep->port->port.port_num == port_num && ep->endpoint.pkey == pkey) {\n\t\tif (!acm_ep_insert_addr(ep, ip_str, addr, addr_len, addr_type)) {\n\t\t\tacm_log(0, \"Added %s %s %d 0x%x from %s\\n\", ip_str,\n\t\t\t\tdev->device.verbs->device->name, port_num, pkey,\n\t\t\t\tifname);\n\t\t}\n\t}\n}\n\nstatic int acm_get_system_ips(struct acmc_ep *ep)\n{\n\treturn acm_if_iter_sys(acm_ep_ip_iter_cb, ep);\n}\n\nstatic int acm_assign_ep_names(struct acmc_ep *ep)\n{\n\tFILE *faddr;\n\tchar *dev_name;\n\tchar s[120];\n\tchar dev[32], name[ACM_MAX_ADDRESS], pkey_str[8];\n\tuint16_t pkey;\n\tuint8_t addr[ACM_MAX_ADDRESS], type;\n\tint port;\n\tsize_t addr_len;\n\n\tdev_name = ep->port->dev->device.verbs->device->name;\n\tacm_log(1, \"device %s, port %d, pkey 0x%x\\n\",\n\t\tdev_name, ep->port->port.port_num, ep->endpoint.pkey);\n\n\tacm_get_system_ips(ep);\n\n\tif (!(faddr = acm_open_addr_file())) {\n\t\tacm_log(0, \"ERROR - address file not found\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (fgets(s, sizeof s, faddr)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%46s%32s%d%8s\", name, dev, &port, pkey_str) != 4)\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"%s\", s);\n\t\tif (inet_pton(AF_INET, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP;\n\t\t\taddr_len = 4;\n\t\t} else if (inet_pton(AF_INET6, name, addr) > 0) {\n\t\t\tif (!support_ips_in_addr_cfg) {\n\t\t\t\tacm_log(0, \"ERROR - IP's are not configured to be read from ibacm_addr.cfg\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttype = ACM_ADDRESS_IP6;\n\t\t\taddr_len = 16;\n\t\t} else {\n\t\t\ttype = ACM_ADDRESS_NAME;\n\t\t\taddr_len = strlen(name);\n\t\t\tmemcpy(addr, name, addr_len);\n\t\t}\n\n\t\tif (strcasecmp(pkey_str, \"default\")) {\n\t\t\tif (sscanf(pkey_str, \"%hx\", &pkey) != 1) {\n\t\t\t\tacm_log(0, \"ERROR - bad pkey format %s\\n\", pkey_str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tpkey = ep->port->def_acm_pkey;\n\t\t}\n\n\t\tif (!strcasecmp(dev_name, dev) &&\n\t\t    (ep->port->port.port_num == (uint8_t) port) &&\n\t\t    (ep->endpoint.pkey == pkey)) {\n\t\t\tacm_log(1, \"assigning %s\\n\", name);\n\t\t\tif (acm_ep_insert_addr(ep, name, addr, addr_len, type)) {\n\t\t\t\tacm_log(1, \"maximum number of names assigned to EP\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(faddr);\n\nout:\n\treturn (ep->addr_info[0].addr.type == ACM_ADDRESS_INVALID);\n}\n\nstatic struct acmc_ep *acm_find_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep, *res = NULL;\n\n\tacm_log(2, \"pkey 0x%x\\n\", pkey);\n\n\tlist_for_each(&port->ep_list, ep, entry) {\n\t\tif (ep->endpoint.pkey == pkey) {\n\t\t\tres = ep;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void acm_ep_down(struct acmc_ep *ep)\n{\n\tint i;\n\n\tacm_log(1, \"%s %d pkey 0x%04x\\n\",\n\t\tep->port->dev->device.verbs->device->name,\n\t\tep->port->port.port_num, ep->endpoint.pkey);\n\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\tif (ep->addr_info[i].addr.type &&\n\t\t    ep->addr_info[i].prov_addr_context)\n\t\t\tep->port->prov->remove_address(ep->addr_info[i].\n\t\t\t\t\t\t       prov_addr_context);\n\t}\n\n\tif (ep->prov_ep_context)\n\t\tep->port->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic struct acmc_ep *\nacm_alloc_ep(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tep = calloc(1, sizeof *ep);\n\tif (!ep)\n\t\treturn NULL;\n\n\tep->port = port;\n\tep->endpoint.port = &port->port;\n\tep->endpoint.pkey = pkey;\n\n\tfor (i = 0; i < MAX_EP_ADDR; i++) {\n\t\tep->addr_info[i].addr.endpoint = &ep->endpoint;\n\t\tep->addr_info[i].addr.id_string = ep->addr_info[i].string_buf;\n\t}\n\n\treturn ep;\n}\n\nstatic void acm_ep_up(struct acmc_port *port, uint16_t pkey)\n{\n\tstruct acmc_ep *ep;\n\tint ret;\n\n\tacm_log(1, \"\\n\");\n\tif (acm_find_ep(port, pkey)) {\n\t\tacm_log(2, \"endpoint for pkey 0x%x already exists\\n\", pkey);\n\t\treturn;\n\t}\n\n\tacm_log(2, \"creating endpoint for pkey 0x%x\\n\", pkey);\n\tep = acm_alloc_ep(port, pkey);\n\tif (!ep)\n\t\treturn;\n\n\tret = acm_assign_ep_names(ep);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to assign EP name for pkey 0x%x\\n\", pkey);\n\t\tgoto ep_close;\n\t}\n\n\tlist_add(&port->ep_list, &ep->entry);\n\treturn;\n\nep_close:\n\tif (ep->prov_ep_context)\n\t\tport->prov->close_endpoint(ep->prov_ep_context);\n\n\tfree(ep);\n}\n\nstatic void acm_assign_provider(struct acmc_port *port)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(2, \"port %s/%d\\n\", port->port.dev->verbs->device->name,\n\t\tport->port.port_num);\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tlist_for_each(&prov->subnet_list, subnet, entry) {\n\t\t\tif (subnet->subnet_prefix ==\n\t\t\t    port->gid_tbl[0].global.subnet_prefix) {\n\t\t\t\tacm_log(2, \"Found provider %s for port %s/%d\\n\",\n\t\t\t\t\tprov->prov->name,\n\t\t\t\t\tport->port.dev->verbs->device->name,\n\t\t\t\t\tport->port.port_num);\n\t\t\t\tport->prov = prov->prov;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If no provider is found, assign the default provider*/\n\tif (!port->prov) {\n\t\tacm_log(2, \"No prov found, assign default prov %s to %s/%d\\n\",\n\t\t\tdef_provider ? def_provider->prov->name: \"NULL\",\n\t\t\tport->port.dev->verbs->device->name,\n\t\t\tport->port.port_num);\n\t\tport->prov = def_provider ? def_provider->prov : NULL;\n\t}\n}\n\nstatic void acm_port_get_gid_tbl(struct acmc_port *port)\n{\n\tunion ibv_gid gid;\n\tint i, j, ret;\n\n\tfor (i = 0;; i++) {\n\t\tret = ibv_query_gid(port->port.dev->verbs, port->port.port_num,\n\t\t\t\t    i, &gid);\n\t\tif (ret || !gid.global.interface_id)\n\t\t\tbreak;\n\t}\n\n\tif (i > 0) {\n\t\tport->gid_tbl = calloc(i, sizeof(union ibv_gid));\n\t\tif (!port->gid_tbl) {\n\t\t\tacm_log(0, \"Error: failed to allocate gid table\\n\");\n\t\t\tport->gid_cnt = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tret = ibv_query_gid(port->port.dev->verbs,\n\t\t\t\t\t    port->port.port_num, j,\n\t\t\t\t\t    &port->gid_tbl[j]);\n\t\t\tif (ret || !port->gid_tbl[j].global.interface_id)\n\t\t\t\tbreak;\n\t\t\tacm_log(2, \"guid %d: 0x%\" PRIx64 \" %\" PRIx64 \"\\n\", j,\n\t\t\t\tbe64toh(port->gid_tbl[j].global.subnet_prefix),\n\t\t\t\tbe64toh(port->gid_tbl[j].global.interface_id));\n\t\t}\n\t\tport->gid_cnt = j;\n\t}\n\tacm_log(2, \"port %d gid_cnt %d\\n\", port->port.port_num,\n\t\tport->gid_cnt);\n}\n\nstatic void acm_port_up(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tuint16_t pkey;\n\tint i, ret;\n\tstruct acmc_prov_context *dev_ctx;\n\tint index = -1;\n\tuint16_t first_pkey = 0;\n\n\tacm_log(1, \"%s %d\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n\tret = ibv_query_port(port->dev->device.verbs, port->port.port_num,\n\t\t\t     &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - unable to get port state\\n\");\n\t\treturn;\n\t}\n\tif (attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active\\n\");\n\t\treturn;\n\t}\n\n\tacm_port_get_gid_tbl(port);\n\tport->lid = attr.lid;\n\tport->lid_mask = 0xffff - ((1 << attr.lmc) - 1);\n\tport->sa_addr.lid = attr.sm_lid;\n\tport->sa_addr.sl = attr.sm_sl;\n\tport->state = IBV_PORT_ACTIVE;\n\tacm_assign_provider(port);\n\tif (!port->prov) {\n\t\tacm_log(1, \"no provider assigned to port\\n\");\n\t\treturn;\n\t}\n\tdev_ctx = acm_acquire_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t   port->prov);\n\tif (!dev_ctx) {\n\t\tacm_log(0, \"Error -- failed to acquire dev context\\n\");\n\t\treturn;\n\t}\n\n\tif (atomic_get(&dev_ctx->refcnt) == 1) {\n\t\tif (port->prov->open_device(&port->dev->device, &dev_ctx->context)) {\n\t\t\tacm_log(0, \"Error -- failed to open the prov device\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tif (port->prov->open_port(&port->port, dev_ctx->context,\n\t\t\t\t  &port->prov_port_context)) {\n\t\tacm_log(0, \"Error -- failed to open the prov port\\n\");\n\t\tgoto err1;\n\t}\n\n\t/* Determine the default pkey for SA access first.\n\t *     Order of preference: 0xffff, 0x7fff\n\t * Use the first pkey as the default pkey for parsing address file.\n\t */\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey);\n\t\tif (i == 0)\n\t\t\tfirst_pkey = pkey;\n\t\tif (pkey == 0xffff) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\telse if (pkey == 0x7fff) {\n\t\t\tindex = i;\n\t\t}\n\t}\n\tport->sa_pkey_index = index < 0 ? 0 : index;\n\tport->def_acm_pkey = first_pkey;\n\n\tfor (i = 0; i < attr.pkey_tbl_len; i++) {\n\t\tret = ibv_query_pkey(port->dev->device.verbs,\n\t\t\t\t     port->port.port_num, i, &pkey);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tpkey = be16toh(pkey);\n\t\tif (!(pkey & 0x7fff))\n\t\t\tcontinue;\n\n\t\tacm_ep_up(port, pkey);\n\t}\n\treturn;\nerr1:\n\tacm_release_prov_context(dev_ctx);\n}\n\nstatic void acm_shutdown_port(struct acmc_port *port)\n{\n\tstruct acmc_ep *ep;\n\tstruct acmc_prov_context *dev_ctx;\n\n\twhile ((ep = list_pop(&port->ep_list, struct acmc_ep, entry)))\n\t\tacm_ep_down(ep);\n\n\tif (port->prov_port_context) {\n\t\tport->prov->close_port(port->prov_port_context);\n\t\tport->prov_port_context = NULL;\n\t\tdev_ctx = acm_get_prov_context(&port->dev->prov_dev_context_list,\n\t\t\t\t\t       port->prov);\n\t\tif (dev_ctx) {\n\t\t\tif (atomic_get(&dev_ctx->refcnt) == 1)\n\t\t\t\tport->prov->close_device(dev_ctx->context);\n\t\t\tacm_release_prov_context(dev_ctx);\n\t\t}\n\t}\n\tport->prov = NULL;\n\tif (port->gid_tbl) {\n\t\tfree(port->gid_tbl);\n\t\tport->gid_tbl = NULL;\n\t}\n\tport->gid_cnt = 0;\n}\n\nstatic void acm_port_down(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (!ret && attr.state == IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port active\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\n\tacm_log(1, \"%s %d is down\\n\", port->dev->device.verbs->device->name,\n\t\tport->port.port_num);\n}\n\nstatic void acm_port_change(struct acmc_port *port)\n{\n\tstruct ibv_port_attr attr;\n\tint ret;\n\n\tacm_log(1, \"%s %d\\n\", port->port.dev->verbs->device->name, port->port.port_num);\n\tret = ibv_query_port(port->port.dev->verbs, port->port.port_num, &attr);\n\tif (ret || attr.state != IBV_PORT_ACTIVE) {\n\t\tacm_log(1, \"port not active: don't care\\n\");\n\t\treturn;\n\t}\n\n\tport->state = attr.state;\n\tacm_shutdown_port(port);\n\tacm_port_up(port);\n}\n\nstatic void acm_event_handler(struct acmc_device *dev)\n{\n\tstruct ibv_async_event event;\n\tint i, ret;\n\n\tret = ibv_get_async_event(dev->device.verbs, &event);\n\tif (ret)\n\t\treturn;\n\n\tacm_log(2, \"processing async event %s for %s\\n\",\n\t\tibv_event_type_str(event.event_type),\n\t\tdev->device.verbs->device->name);\n\ti = event.element.port_num - 1;\n\n\tswitch (event.event_type) {\n\tcase IBV_EVENT_PORT_ACTIVE:\n\t\tif (dev->port[i].state != IBV_PORT_ACTIVE)\n\t\t\tacm_port_up(&dev->port[i]);\n\t\tbreak;\n\tcase IBV_EVENT_PORT_ERR:\n\t\tif (dev->port[i].state == IBV_PORT_ACTIVE)\n\t\t\tacm_port_down(&dev->port[i]);\n\t\tbreak;\n\tcase IBV_EVENT_CLIENT_REREGISTER:\n\t\tif ((dev->port[i].state == IBV_PORT_ACTIVE) &&\n\t\t    dev->port[i].prov_port_context) {\n\t\t\tdev->port[i].prov->handle_event(dev->port[i].prov_port_context,\n\t\t\t\t\t\t\tevent.event_type);\n\t\t\tacm_log(1, \"%s %d has reregistered\\n\",\n\t\t\t\tdev->device.verbs->device->name, i + 1);\n\t\t}\n\t\tbreak;\n\tcase IBV_EVENT_LID_CHANGE:\n\tcase IBV_EVENT_GID_CHANGE:\n\tcase IBV_EVENT_PKEY_CHANGE:\n\t\tacm_port_change(&dev->port[i]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tibv_ack_async_event(&event);\n}\n\nstatic void acm_activate_devices(void)\n{\n\tstruct acmc_device *dev;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\t\tacm_port_up(&dev->port[i]);\n\t\t}\n\t}\n}\n\nstatic void\nacm_open_port(struct acmc_port *port, struct acmc_device *dev, uint8_t port_num)\n{\n\tacm_log(1, \"%s %d\\n\", dev->device.verbs->device->name, port_num);\n\tport->dev = dev;\n\tport->port.dev = &dev->device;\n\tport->port.port_num = port_num;\n\tpthread_mutex_init(&port->lock, NULL);\n\tlist_head_init(&port->ep_list);\n\tlist_head_init(&port->sa_pending);\n\tlist_head_init(&port->sa_wait);\n\tport->sa_credits = sa.depth;\n\tport->sa_addr.qpn = htobe32(1);\n\tport->sa_addr.qkey = htobe32(ACM_QKEY);\n\n\tport->mad_portid = umad_open_port(dev->device.verbs->device->name, port_num);\n\tif (port->mad_portid < 0)\n\t\tacm_log(0, \"ERROR - unable to open MAD port\\n\");\n\n\tport->mad_agentid = umad_register(port->mad_portid,\n\t\t\t\t\t  IB_MGMT_CLASS_SA, 1, 1, NULL);\n\tif (port->mad_agentid < 0)\n\t\tacm_log(0, \"ERROR - unable to register MAD client\\n\");\n\n\tport->prov = NULL;\n\tport->state = IBV_PORT_DOWN;\n}\n\nstatic void acm_open_dev(struct ibv_device *ibdev)\n{\n\tstruct acmc_device *dev;\n\tstruct ibv_device_attr attr;\n\tstruct ibv_context *verbs;\n\tsize_t size;\n\tint i, ret;\n\n\tacm_log(1, \"%s\\n\", ibdev->name);\n\tverbs = ibv_open_device(ibdev);\n\tif (verbs == NULL) {\n\t\tacm_log(0, \"ERROR - opening device %s\\n\", ibdev->name);\n\t\treturn;\n\t}\n\n\tret = ibv_query_device(verbs, &attr);\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - ibv_query_device (%d) %s\\n\", ret, ibdev->name);\n\t\tgoto err1;\n\t}\n\n\tsize = sizeof(*dev) + sizeof(struct acmc_port) * attr.phys_port_cnt;\n\tdev = (struct acmc_device *) calloc(1, size);\n\tif (!dev)\n\t\tgoto err1;\n\n\tdev->device.verbs = verbs;\n\tdev->device.dev_guid = ibv_get_device_guid(ibdev);\n\tdev->port_cnt = attr.phys_port_cnt;\n\tlist_head_init(&dev->prov_dev_context_list);\n\n\tfor (i = 0; i < dev->port_cnt; i++) {\n\t\tacm_open_port(&dev->port[i], dev, i + 1);\n\t}\n\n\tlist_add(&dev_list, &dev->entry);\n\n\tacm_log(1, \"%s opened\\n\", ibdev->name);\n\treturn;\n\nerr1:\n\tibv_close_device(verbs);\n}\n\nstatic int acm_open_devices(void)\n{\n\tstruct ibv_device **ibdev;\n\tint dev_cnt;\n\tint i;\n\n\tacm_log(1, \"\\n\");\n\tibdev = ibv_get_device_list(&dev_cnt);\n\tif (!ibdev) {\n\t\tacm_log(0, \"ERROR - unable to get device list\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < dev_cnt; i++)\n\t\tacm_open_dev(ibdev[i]);\n\n\tibv_free_device_list(ibdev);\n\tif (list_empty(&dev_list)) {\n\t\tacm_log(0, \"ERROR - no devices\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_load_prov_config(void)\n{\n\tFILE *fd;\n\tchar s[128];\n\tchar *p, *ptr;\n\tchar prov_name[ACM_PROV_NAME_SIZE];\n\tuint64_t prefix;\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tif (!(fd = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, fd)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* Ignore blank lines */\n\t\tif (!(p = strtok_r(s, \" \\n\", &ptr)))\n\t\t\tcontinue;\n\n\t\tif (strncasecmp(p, \"provider\", sizeof(\"provider\") - 1))\n\t\t\tcontinue;\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tstrncpy(prov_name, p, sizeof(prov_name));\n\t\tprov_name[sizeof(prov_name) -1] = '\\0';\n\n\t\tp = strtok_r(NULL, \" \", &ptr);\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(p, \"default\", sizeof(\"default\") - 1)) {\n\t\t\tstrncpy(def_prov_name, prov_name, sizeof(def_prov_name));\n\t\t\tdef_prov_name[sizeof(def_prov_name) -1] = '\\0';\n\t\t\tacm_log(2, \"default provider: %s\\n\", def_prov_name);\n\t\t\tcontinue;\n\t\t}\n\t\tprefix = strtoull(p, NULL, 0);\n\t\tacm_log(2, \"provider %s subnet_prefix 0x%\" PRIx64 \"\\n\",\n\t\t\tprov_name, prefix);\n\t\t/* Convert it into network byte order */\n\t\tprefix = htobe64(prefix);\n\n\t\tlist_for_each(&provider_list, prov, entry) {\n\t\t\tif (!strcasecmp(prov->prov->name, prov_name)) {\n\t\t\t\tsubnet = calloc(1, sizeof (*subnet));\n\t\t\t\tif (!subnet) {\n\t\t\t\t\tacm_log(0, \"Error: out of memory\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsubnet->subnet_prefix = prefix;\n\t\t\t\tlist_add_after(&provider_list, &prov->entry,\n\t\t\t\t\t\t&subnet->entry);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fd);\n\n\tlist_for_each(&provider_list, prov, entry) {\n\t\tif (!strcasecmp(prov->prov->name, def_prov_name)) {\n\t\t\tdef_provider = prov;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int acm_open_providers(void)\n{\n\tDIR *shlib_dir;\n\tstruct dirent *dent;\n\tchar file_name[256];\n\tstruct stat buf;\n\tvoid *handle;\n\tstruct acmc_prov *prov;\n\tstruct acm_provider *provider;\n\tuint32_t version;\n\tchar *err_str;\n\tint (*query)(struct acm_provider **, uint32_t *);\n\n\tacm_log(1, \"\\n\");\n\tshlib_dir = opendir(prov_lib_path);\n\tif (!shlib_dir) {\n\t\tacm_log(0, \"ERROR - could not open provider lib dir: %s\\n\",\n\t\t\tprov_lib_path);\n\t\treturn -1;\n\t}\n\n\twhile ((dent = readdir(shlib_dir))) {\n\t\tif (!strstr(dent->d_name, \".so\"))\n\t\t\tcontinue;\n\n\t\tif (!check_snprintf(file_name, sizeof(file_name), \"%s/%s\",\n\t\t\t\t    prov_lib_path, dent->d_name))\n\t\t\tcontinue;\n\n\t\tif (lstat(file_name, &buf)) {\n\t\t\tacm_log(0, \"Error - could not stat: %s\\n\", file_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(buf.st_mode))\n\t\t\tcontinue;\n\n\t\tacm_log(2, \"Loading provider %s...\\n\", file_name);\n\t\tif (!(handle = dlopen(file_name, RTLD_LAZY))) {\n\t\t\tacm_log(0, \"Error - could not load provider %s (%s)\\n\",\n\t\t\t\tfile_name, dlerror());\n\t\t\tcontinue;\n\t\t}\n\n\t\tquery = dlsym(handle, \"provider_query\");\n\t\tif ((err_str = dlerror()) != NULL) {\n\t\t\tacm_log(0, \"Error -provider_query not found in %s (%s)\\n\",\n\t\t\t\tfile_name, err_str);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (query(&provider, &version)) {\n\t\t\tacm_log(0, \"Error - provider_query failed to %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (version != ACM_PROV_VERSION ||\n\t\t    provider->size != sizeof(struct acm_provider)) {\n\t\t\tacm_log(0, \"Error -unmatched provider version 0x%08x (size %zd)\"\n\t\t\t\t\" core 0x%08x (size %zd)\\n\", version, provider->size,\n\t\t\t\tACM_PROV_VERSION, sizeof(struct acm_provider));\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacm_log(1, \"Provider %s (%s) loaded\\n\", provider->name, file_name);\n\n\t\tprov = calloc(1, sizeof(*prov));\n\t\tif (!prov) {\n\t\t\tacm_log(0, \"Error -failed to allocate provider %s\\n\", file_name);\n\t\t\tdlclose(handle);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprov->prov = provider;\n\t\tprov->handle = handle;\n\t\tlist_head_init(&prov->subnet_list);\n\t\tlist_add_tail(&provider_list, &prov->entry);\n\t\tif (!strcasecmp(provider->name, def_prov_name))\n\t\t\tdef_provider = prov;\n\t}\n\n\tclosedir(shlib_dir);\n\tacm_load_prov_config();\n\treturn 0;\n}\n\nstatic void acm_close_providers(void)\n{\n\tstruct acmc_prov *prov;\n\tstruct acmc_subnet *subnet;\n\n\tacm_log(1, \"\\n\");\n\tdef_provider = NULL;\n\n\twhile ((prov = list_pop(&provider_list, struct acmc_prov, entry))) {\n\t\twhile ((subnet = list_pop(&prov->subnet_list,\n\t\t\t\tstruct acmc_subnet, entry)))\n\t\t\tfree(subnet);\n\t\tdlclose(prov->handle);\n\t\tfree(prov);\n\t}\n}\n\nstatic int acmc_init_sa_fds(void)\n{\n\tstruct acmc_device *dev;\n\tint ret, p, i = 0;\n\n\tlist_for_each(&dev_list, dev, entry)\n\t\tsa.nfds += dev->port_cnt;\n\n\tsa.fds = calloc(sa.nfds, sizeof(*sa.fds));\n\tsa.ports = calloc(sa.nfds, sizeof(*sa.ports));\n\tif (!sa.fds || !sa.ports)\n\t\treturn -ENOMEM;\n\n\tlist_for_each(&dev_list, dev, entry) {\n\t\tfor (p = 0; p < dev->port_cnt; p++) {\n\t\t\tsa.fds[i].fd = umad_get_fd(dev->port[p].mad_portid);\n\t\t\tsa.fds[i].events = POLLIN;\n\t\t\tret = fcntl(sa.fds[i].fd, F_SETFL, O_NONBLOCK);\n\t\t\tif (ret)\n\t\t\t\tacm_log(0, \"WARNING - umad fd is blocking\\n\");\n\n\t\t\tsa.ports[i++] = &dev->port[p];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct acm_sa_mad *\nacm_alloc_sa_mad(const struct acm_endpoint *endpoint, void *context,\n\t\t void (*handler)(struct acm_sa_mad *))\n{\n\tstruct acmc_sa_req *req;\n\n\tif (!endpoint) {\n\t\tacm_log(0, \"Error: NULL endpoint\\n\");\n\t\treturn NULL;\n\t}\n\treq = calloc(1, sizeof (*req));\n\tif (!req) {\n\t\tacm_log(0, \"Error: failed to allocate sa request\\n\");\n\t\treturn NULL;\n\t}\n\n\treq->ep = container_of(endpoint, struct acmc_ep, endpoint);\n\treq->mad.context = context;\n\treq->resp_handler = handler;\n\n\tacm_log(2, \"%p\\n\", req);\n\treturn &req->mad;\n}\n\nvoid acm_free_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_sa_req *req;\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p\\n\", req);\n\tfree(req);\n}\n\nint acm_send_sa_mad(struct acm_sa_mad *mad)\n{\n\tstruct acmc_port *port;\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\treq = container_of(mad, struct acmc_sa_req, mad);\n\tacm_log(2, \"%p from %s\\n\", req, req->ep->addr_info[0].addr.id_string);\n\n\tport = req->ep->port;\n\tmad->umad.addr.qpn = port->sa_addr.qpn;\n\tmad->umad.addr.qkey = port->sa_addr.qkey;\n\tmad->umad.addr.lid = htobe16(port->sa_addr.lid);\n\tmad->umad.addr.sl = port->sa_addr.sl;\n\tmad->umad.addr.pkey_index = req->ep->port->sa_pkey_index;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (port->sa_credits && list_empty(&port->sa_wait)) {\n\t\tret = umad_send(port->mad_portid, port->mad_agentid, &mad->umad,\n\t\t\t\tsizeof mad->sa_mad, sa.timeout, sa.retries);\n\t\tif (!ret) {\n\t\t\tport->sa_credits--;\n\t\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t\t}\n\t} else {\n\t\tret = 0;\n\t\tlist_add_tail(&port->sa_wait, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\treturn ret;\n}\n\nstatic void acmc_send_queued_req(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tint ret;\n\n\tpthread_mutex_lock(&port->lock);\n\tif (list_empty(&port->sa_wait) || !port->sa_credits) {\n\t\tpthread_mutex_unlock(&port->lock);\n\t\treturn;\n\t}\n\n\treq = list_pop(&port->sa_wait, struct acmc_sa_req, entry);\n\n\tret = umad_send(port->mad_portid, port->mad_agentid, &req->mad.umad,\n\t\t\tsizeof req->mad.sa_mad, sa.timeout, sa.retries);\n\tif (!ret) {\n\t\tport->sa_credits--;\n\t\tlist_add_tail(&port->sa_pending, &req->entry);\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (ret) {\n\t\treq->mad.umad.status = -ret;\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void acmc_recv_mad(struct acmc_port *port)\n{\n\tstruct acmc_sa_req *req;\n\tstruct acm_sa_mad resp;\n\tint ret, len, found;\n\tstruct umad_hdr *hdr;\n\n\tacm_log(2, \"\\n\");\n\tlen = sizeof(resp.sa_mad);\n\tret = umad_recv(port->mad_portid, &resp.umad, &len, 0);\n\tif (ret < 0) {\n\t\tacm_log(1, \"umad_recv error %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thdr = &resp.sa_mad.mad_hdr;\n\tacm_log(2, \"bv %x cls %x cv %x mtd %x st %d tid %\" PRIx64 \"x at %x atm %x\\n\",\n\t\thdr->base_version, hdr->mgmt_class, hdr->class_version,\n\t\thdr->method, hdr->status, be64toh(hdr->tid), hdr->attr_id, hdr->attr_mod);\n\tfound = 0;\n\tpthread_mutex_lock(&port->lock);\n\tlist_for_each(&port->sa_pending, req, entry) {\n\t\t/* The upper 32-bit of the tid is used for agentid in umad */\n\t\tif (req->mad.sa_mad.mad_hdr.tid == (hdr->tid & htobe64(0xFFFFFFFF))) {\n\t\t\tfound = 1;\n\t\t\tlist_del(&req->entry);\n\t\t\tport->sa_credits++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&port->lock);\n\n\tif (found) {\n\t\tmemcpy(&req->mad.umad, &resp.umad, sizeof(resp.umad) + len);\n\t\treq->resp_handler(&req->mad);\n\t}\n}\n\nstatic void *acm_sa_handler(void *context)\n{\n\tint i, ret;\n\n\tacm_log(0, \"started\\n\");\n\tret = acmc_init_sa_fds();\n\tif (ret) {\n\t\tacm_log(0, \"ERROR - failed to init fds\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel type \\n\");\n\t\treturn NULL;\n\t}\n\n\tif (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)) {\n\t\tacm_log(0, \"Error: failed to set cancel state\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tpthread_testcancel();\n\t\tret = poll(sa.fds, sa.nfds, -1);\n\t\tif (ret < 0) {\n\t\t\tacm_log(0, \"ERROR - sa poll error: %d\\n\", errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < sa.nfds; i++) {\n\t\t\tif (!sa.fds[i].revents)\n\t\t\t\tcontinue;\n\n\t\t\tif (sa.fds[i].revents & POLLIN) {\n\t\t\t\tacmc_recv_mad(sa.ports[i]);\n\t\t\t\tacmc_send_queued_req(sa.ports[i]);\n\t\t\t}\n\t\t\tsa.fds[i].revents = 0;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void acm_stop_sa_handler(void)\n{\n\tif (pthread_cancel(sa.thread_id)) {\n\t\tacm_log(0, \"Error: failed to cancel sa resp thread \\n\");\n\t\treturn;\n\t}\n\n\tif (pthread_join(sa.thread_id, NULL)) {\n\t\tacm_log(0, \"Error: failed to join sa resp thread\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void acm_set_options(void)\n{\n\tFILE *f;\n\tchar s[120];\n\tchar opt[32], value[256];\n\n\tif (!(f = fopen(opts_file, \"r\")))\n\t\treturn;\n\n\twhile (fgets(s, sizeof s, f)) {\n\t\tif (s[0] == '#')\n\t\t\tcontinue;\n\n\t\tif (sscanf(s, \"%32s%256s\", opt, value) != 2)\n\t\t\tcontinue;\n\n\t\tif (!strcasecmp(\"log_file\", opt))\n\t\t\tstrcpy(log_file, value);\n\t\telse if (!strcasecmp(\"log_level\", opt))\n\t\t\tlog_level = atoi(value);\n\t\telse if (!strcasecmp(\"lock_file\", opt))\n\t\t\tstrcpy(lock_file, value);\n\t\telse if (!strcasecmp(\"server_port\", opt))\n\t\t\tserver_port = (short) atoi(value);\n\t\telse if (!strcasecmp(\"provider_lib_path\", opt))\n\t\t\tstrcpy(prov_lib_path, value);\n\t\telse if (!strcasecmp(\"support_ips_in_addr_cfg\", opt))\n\t\t\tsupport_ips_in_addr_cfg = atoi(value);\n\t\telse if (!strcasecmp(\"timeout\", opt))\n\t\t\tsa.timeout = atoi(value);\n\t\telse if (!strcasecmp(\"retries\", opt))\n\t\t\tsa.retries = atoi(value);\n\t\telse if (!strcasecmp(\"sa_depth\", opt))\n\t\t\tsa.depth = atoi(value);\n\t}\n\n\tfclose(f);\n}\n\nstatic void acm_log_options(void)\n{\n\tacm_log(0, \"log file %s\\n\", log_file);\n\tacm_log(0, \"log level %d\\n\", log_level);\n\tacm_log(0, \"lock file %s\\n\", lock_file);\n\tacm_log(0, \"server_port %d\\n\", server_port);\n\tacm_log(0, \"timeout %d ms\\n\", sa.timeout);\n\tacm_log(0, \"retries %d\\n\", sa.retries);\n\tacm_log(0, \"sa depth %d\\n\", sa.depth);\n\tacm_log(0, \"options file %s\\n\", opts_file);\n\tacm_log(0, \"addr file %s\\n\", addr_file);\n\tacm_log(0, \"provider lib path %s\\n\", prov_lib_path);\n\tacm_log(0, \"support IP's in ibacm_addr.cfg %d\\n\", support_ips_in_addr_cfg);\n}\n\nstatic FILE *acm_open_log(void)\n{\n\tFILE *f;\n\n\tif (!strcasecmp(log_file, \"stdout\"))\n\t\treturn stdout;\n\n\tif (!strcasecmp(log_file, \"stderr\"))\n\t\treturn stderr;\n\n\tif (!(f = fopen(log_file, \"w\")))\n\t\tf = stdout;\n\n\treturn f;\n}\n\nstatic int acm_open_lock_file(void)\n{\n\tint lock_fd;\n\tchar pid[16];\n\n\tlock_fd = open(lock_file, O_RDWR | O_CREAT, 0640);\n\tif (lock_fd < 0)\n\t\treturn lock_fd;\n\n\tif (lockf(lock_fd, F_TLOCK, 0)) {\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\n\tsnprintf(pid, sizeof pid, \"%d\\n\", getpid());\n\tif (write(lock_fd, pid, strlen(pid)) != strlen(pid)){\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void daemonize(void)\n{\n\tpid_t pid, sid;\n\n\tpid = fork();\n\tif (pid)\n\t\texit(pid < 0);\n\n\tsid = setsid();\n\tif (sid < 0)\n\t\texit(1);\n\n\tif (chdir(\"/\"))\n\t\texit(1);\n\n\tif(!freopen(\"/dev/null\", \"r\", stdin))\n\t\texit(1);\n\tif(!freopen(\"/dev/null\", \"w\", stdout))\n\t\texit(1);\n\tif(!freopen(\"/dev/null\", \"w\", stderr))\n\t\texit(1);\n}\n\nstatic void show_usage(char *program)\n{\n\tprintf(\"usage: %s\\n\", program);\n\tprintf(\"   [-D]             - run as a daemon (default)\\n\");\n\tprintf(\"   [-P]             - run as a standard process\\n\");\n\tprintf(\"   [-A addr_file]   - address configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_ADDR_FILE);\n\tprintf(\"   [-O option_file] - option configuration file\\n\");\n\tprintf(\"                      (default %s/%s)\\n\", ACM_CONF_DIR, ACM_OPTS_FILE);\n}\n\nint main(int argc, char **argv)\n{\n\tint i, op, daemon = 1;\n\n\twhile ((op = getopt(argc, argv, \"DPA:O:\")) != -1) {\n\t\tswitch (op) {\n\t\tcase 'D':\n\t\t\t/* option no longer required */\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tdaemon = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\taddr_file = optarg;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\topts_file = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshow_usage(argv[0]);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (daemon)\n\t\tdaemonize();\n\n\tacm_set_options();\n\tif (acm_open_lock_file())\n\t\treturn -1;\n\n\tpthread_mutex_init(&log_lock, NULL);\n\tflog = acm_open_log();\n\n\tacm_log(0, \"Assistant to the InfiniBand Communication Manager\\n\");\n\tacm_log_options();\n\n\tfor (i = 0; i < ACM_MAX_COUNTER; i++)\n\t\tatomic_init(&counter[i]);\n\n\tif (umad_init() != 0) {\n\t\tacm_log(0, \"ERROR - fail to initialize umad\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_providers()) {\n\t\tacm_log(0, \"ERROR - unable to open any providers\\n\");\n\t\treturn -1;\n\t}\n\n\tif (acm_open_devices()) {\n\t\tacm_log(0, \"ERROR - unable to open any devices\\n\");\n\t\treturn -1;\n\t}\n\n\tacm_log(1, \"creating IP Netlink socket\\n\");\n\tacm_ipnl_create();\n\n\tacm_log(1, \"starting sa response receiving thread\\n\");\n\tif (pthread_create(&sa.thread_id, NULL, acm_sa_handler, NULL)) {\n\t\tacm_log(0, \"Error: failed to create sa resp rcving thread\");\n\t\treturn -1;\n\t}\n\tacm_activate_devices();\n\tacm_log(1, \"starting server\\n\");\n\tacm_server();\n\n\tacm_log(0, \"shutting down\\n\");\n\tif (client_array[NL_CLIENT_INDEX].sock != -1)\n\t\tclose(client_array[NL_CLIENT_INDEX].sock);\n\tacm_close_providers();\n\tacm_stop_sa_handler();\n\tumad_done();\n\tfclose(flog);\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-13-f2bnbpzsqc4ceifuvhs2iin347h5f2uh/spack-src/buildlib/rdma_functions.cmake": "# COPYRIGHT (c) 2016 Obsidian Research Corporation. See COPYING file\n\n# Helper functions for use in the sub CMakeLists files to make them simpler\n# and more uniform.\n\n# Global list of pairs of (SHARED STATIC) libary target names\nset(RDMA_STATIC_LIBS \"\" CACHE INTERNAL \"Doc\" FORCE)\n\nset(COMMON_LIBS_PIC ccan_pic)\nset(COMMON_LIBS ccan)\n\n# Install a symlink during 'make install'\nfunction(rdma_install_symlink LINK_CONTENT DEST)\n  # Create a link in the build tree with the right content\n  get_filename_component(FN \"${DEST}\" NAME)\n  execute_process(COMMAND \"${CMAKE_COMMAND}\" -E create_symlink\n    \"${LINK_CONTENT}\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/${FN}\")\n\n  # Have cmake install it. Doing it this way lets cpack work if we ever wish\n  # to use that.\n  get_filename_component(DIR \"${DEST}\" PATH)\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${FN}\"\n    DESTINATION \"${DIR}\")\nendfunction()\n\n# Wrapper for install() that runs the single file through configure_file first.\n# This only works with the basic single file install(FILE file ARGS..) pattern\nfunction(rdma_subst_install ARG1 file)\n  if (NOT \"${ARG1}\" STREQUAL \"FILES\")\n    message(FATAL_ERROR \"Bad use of rdma_subst_install\")\n  endif()\n  configure_file(\"${file}\" \"${CMAKE_CURRENT_BINARY_DIR}/${file}\" @ONLY)\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${file}\" ${ARGN})\nendfunction()\n\n# Modify shared library target DEST to use VERSION_SCRIPT as the linker map file\nfunction(rdma_set_library_map DEST VERSION_SCRIPT)\n  if (NOT IS_ABSOLUTE ${VERSION_SCRIPT})\n    set(VERSION_SCRIPT \"${CMAKE_CURRENT_SOURCE_DIR}/${VERSION_SCRIPT}\")\n  endif()\n  set_property(TARGET ${DEST} APPEND_STRING PROPERTY\n    LINK_FLAGS \" -Wl,--version-script,${VERSION_SCRIPT}\")\n\n  # NOTE: This won't work with ninja prior to cmake 3.4\n  set_property(TARGET ${DEST} APPEND_STRING PROPERTY\n    LINK_DEPENDS ${VERSION_SCRIPT})\nendfunction()\n\n# Basic function to produce a standard libary with a GNU LD version script.\nfunction(rdma_library DEST VERSION_SCRIPT SOVERSION VERSION)\n  # Create a static library\n  if (ENABLE_STATIC)\n    add_library(${DEST}-static STATIC ${ARGN})\n    set_target_properties(${DEST}-static PROPERTIES\n      OUTPUT_NAME ${DEST}\n      LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n    install(TARGETS ${DEST}-static DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n    list(APPEND RDMA_STATIC_LIBS ${DEST} ${DEST}-static)\n    set(RDMA_STATIC_LIBS \"${RDMA_STATIC_LIBS}\" CACHE INTERNAL \"\")\n  endif()\n\n  # Create a shared library\n  add_library(${DEST} SHARED ${ARGN})\n  rdma_set_library_map(${DEST} ${VERSION_SCRIPT})\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  set_target_properties(${DEST} PROPERTIES\n    SOVERSION ${SOVERSION}\n    VERSION ${VERSION}\n    LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\nendfunction()\n\n# Create a special provider with exported symbols in it The shared provider\n# exists as a normal system library with the normal shared library SONAME and\n# other convections. The system library is symlinked into the\n# VERBS_PROVIDER_DIR so it can be dlopened as a provider as well.\nfunction(rdma_shared_provider DEST VERSION_SCRIPT SOVERSION VERSION)\n  # Installed driver file\n  file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" \"driver ${DEST}\\n\")\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" DESTINATION \"${CONFIG_DIR}\")\n\n  # Uninstalled driver file\n  file(MAKE_DIRECTORY \"${BUILD_ETC}/libibverbs.d/\")\n  file(WRITE \"${BUILD_ETC}/libibverbs.d/${DEST}.driver\" \"driver ${BUILD_LIB}/lib${DEST}\\n\")\n\n  # Create a static provider library\n  if (ENABLE_STATIC)\n    add_library(${DEST} STATIC ${ARGN})\n    set_target_properties(${DEST} PROPERTIES LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n    install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n    list(APPEND RDMA_STATIC_LIBS ${DEST}-rdmav2 ${DEST})\n    set(RDMA_STATIC_LIBS \"${RDMA_STATIC_LIBS}\" CACHE INTERNAL \"\")\n  endif()\n\n  # Create the plugin shared library\n  add_library(${DEST} SHARED ${ARGN})\n  rdma_set_library_map(${DEST} ${VERSION_SCRIPT})\n\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  target_link_libraries(${DEST} LINK_PRIVATE ibverbs)\n  target_link_libraries(${DEST} LINK_PRIVATE ${CMAKE_THREAD_LIBS_INIT})\n  set_target_properties(${DEST} PROPERTIES\n    SOVERSION ${SOVERSION}\n    VERSION ${VERSION}\n    LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n  # Compute a relative symlink from VERBS_PROVIDER_DIR to LIBDIR\n  execute_process(COMMAND python ${CMAKE_SOURCE_DIR}/buildlib/relpath\n    \"${CMAKE_INSTALL_FULL_LIBDIR}/lib${DEST}.so.${VERSION}\"\n    \"${VERBS_PROVIDER_DIR}\"\n    OUTPUT_VARIABLE DEST_LINK_PATH OUTPUT_STRIP_TRAILING_WHITESPACE)\n  rdma_install_symlink(\"${DEST_LINK_PATH}\" \"${VERBS_PROVIDER_DIR}/lib${DEST}-rdmav2.so\")\n\n  # cmake doesn't create target DESTINATION directories until everything is\n  # finished, do it manually here so we can create the in-tree symlink.\n  execute_process(COMMAND \"${CMAKE_COMMAND}\" -E make_directory \"${BUILD_LIB}\")\n  execute_process(COMMAND \"${CMAKE_COMMAND}\" -E create_symlink\n    \"lib${DEST}.so.${VERSION}\"\n    \"${BUILD_LIB}/lib${DEST}-rdmav2.so\")\nendfunction()\n\n# Create a provider shared library for libibverbs\nfunction(rdma_provider DEST)\n  # Installed driver file\n  file(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" \"driver ${DEST}\\n\")\n  install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/${DEST}.driver\" DESTINATION \"${CONFIG_DIR}\")\n\n  # Uninstalled driver file\n  file(MAKE_DIRECTORY \"${BUILD_ETC}/libibverbs.d/\")\n  file(WRITE \"${BUILD_ETC}/libibverbs.d/${DEST}.driver\" \"driver ${BUILD_LIB}/lib${DEST}\\n\")\n\n  # Create a static provider library\n  # FIXME: This is probably pointless, the provider library has no symbols so\n  # what good is it? Presumably it should be used with -Wl,--whole-archive,\n  # but we don't have any directions on how to make static linking work..\n  if (ENABLE_STATIC)\n    add_library(${DEST} STATIC ${ARGN})\n    set_target_properties(${DEST} PROPERTIES LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n    install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n    list(APPEND RDMA_STATIC_LIBS ${DEST}-rdmav2 ${DEST})\n    set(RDMA_STATIC_LIBS \"${RDMA_STATIC_LIBS}\" CACHE INTERNAL \"\")\n  endif()\n\n  # Create the plugin shared library\n  set(DEST ${DEST}-rdmav2)\n  add_library(${DEST} MODULE ${ARGN})\n  # Even though these are modules we still want to use Wl,--no-undefined\n  set_target_properties(${DEST} PROPERTIES LINK_FLAGS ${CMAKE_SHARED_LINKER_FLAGS})\n  rdma_set_library_map(${DEST} ${BUILDLIB}/provider.map)\n  target_link_libraries(${DEST} LINK_PRIVATE ${COMMON_LIBS_PIC})\n  target_link_libraries(${DEST} LINK_PRIVATE ibverbs)\n  target_link_libraries(${DEST} LINK_PRIVATE ${CMAKE_THREAD_LIBS_INIT})\n  set_target_properties(${DEST} PROPERTIES LIBRARY_OUTPUT_DIRECTORY \"${BUILD_LIB}\")\n  # Provider Plugins do not use SONAME versioning, there is no reason to\n  # create the usual symlinks.\n\n  if (VERBS_PROVIDER_DIR)\n    install(TARGETS ${DEST} DESTINATION \"${VERBS_PROVIDER_DIR}\")\n  else()\n    install(TARGETS ${DEST} DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\n\n    # FIXME: This symlink is provided for compat with the old build, but it\n    # never should have existed in the first place, nothing should use this\n    # name, we can probably remove it.\n    rdma_install_symlink(\"lib${DEST}-rdmav2.so\" \"${CMAKE_INSTALL_LIBDIR}/lib${DEST}.so\")\n  endif()\nendfunction()\n\n # Create an installed executable\nfunction(rdma_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\n  install(TARGETS ${EXEC} DESTINATION \"${CMAKE_INSTALL_BINDIR}\")\nendfunction()\n\n # Create an installed executable (under sbin)\nfunction(rdma_sbin_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\n  install(TARGETS ${EXEC} DESTINATION \"${CMAKE_INSTALL_SBINDIR}\")\nendfunction()\n\n# Create an test executable (not-installed)\nfunction(rdma_test_executable EXEC)\n  add_executable(${EXEC} ${ARGN})\n  target_link_libraries(${EXEC} LINK_PRIVATE ${COMMON_LIBS})\n  set_target_properties(${EXEC} PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${BUILD_BIN}\")\nendfunction()\n\n# Install man pages. This deduces the section from the trailing integer in the\n# filename\nfunction(rdma_man_pages)\n  foreach(I ${ARGN})\n    if (\"${I}\" MATCHES \"\\\\.in$\")\n      string(REGEX REPLACE \"^.+[.](.+)\\\\.in$\" \"\\\\1\" MAN_SECT \"${I}\")\n      string(REGEX REPLACE \"^(.+)\\\\.in$\" \"\\\\1\" BASE_NAME \"${I}\")\n      get_filename_component(BASE_NAME \"${BASE_NAME}\" NAME)\n      rdma_subst_install(FILES \"${I}\"\n\tDESTINATION \"${CMAKE_INSTALL_MANDIR}/man${MAN_SECT}/\"\n\tRENAME \"${BASE_NAME}\")\n    else()\n      string(REGEX REPLACE \"^.+[.](.+)$\" \"\\\\1\" MAN_SECT \"${I}\")\n      install(FILES \"${I}\" DESTINATION \"${CMAKE_INSTALL_MANDIR}/man${MAN_SECT}/\")\n    endif()\n  endforeach()\nendfunction()\n\n# Create an alias for a man page, using a symlink.\n# Input is a list of pairs of names (MAN_PAGE ALIAS)\n# NOTE: The section must currently be the same for both.\nfunction(rdma_alias_man_pages)\n  list(LENGTH ARGN LEN)\n  math(EXPR LEN ${LEN}-1)\n  foreach(I RANGE 0 ${LEN} 2)\n    list(GET ARGN ${I} FROM)\n    math(EXPR I ${I}+1)\n    list(GET ARGN ${I} TO)\n    string(REGEX REPLACE \"^.+[.](.+)$\" \"\\\\1\" MAN_SECT ${FROM})\n    rdma_install_symlink(\"${FROM}\" \"${CMAKE_INSTALL_MANDIR}/man${MAN_SECT}/${TO}\")\n  endforeach()\nendfunction()\n\n# Finalize the setup of the static libraries by copying the meta information\n# from the shared and setting up the libtool .la files.\nfunction(rdma_finalize_libs)\n  list(LENGTH RDMA_STATIC_LIBS LEN)\n  if (LEN LESS 2)\n    return()\n  endif()\n\n  math(EXPR LEN ${LEN}-1)\n  foreach(I RANGE 0 ${LEN} 2)\n    list(GET RDMA_STATIC_LIBS ${I} SHARED)\n    math(EXPR I ${I}+1)\n    list(GET RDMA_STATIC_LIBS ${I} STATIC)\n\n    # PUBLIC libraries\n    set(LIBS \"\")\n    get_property(TMP TARGET ${SHARED} PROPERTY INTERFACE_LINK_LIBRARIES SET)\n    if (TMP)\n      get_target_property(TMP ${SHARED} INTERFACE_LINK_LIBRARIES)\n      set_target_properties(${STATIC} PROPERTIES INTERFACE_LINK_LIBRARIES \"${TMP}\")\n      set(LIBS \"${TMP}\")\n    endif()\n\n    # PRIVATE libraries\n    get_property(TMP TARGET ${SHARED} PROPERTY LINK_LIBRARIES SET)\n    if (TMP)\n      get_target_property(TMP ${SHARED} LINK_LIBRARIES)\n      set_target_properties(${STATIC} PROPERTIES LINK_LIBRARIES \"${TMP}\")\n      list(APPEND LIBS \"${TMP}\")\n    endif()\n  endforeach()\nendfunction()\n",
        "/tmp/vanessa/spack-stage/spack-stage-rdma-core-13-f2bnbpzsqc4ceifuvhs2iin347h5f2uh/spack-src/buildlib/provider.map": "/* The providers do not export any symbols at all. Instead they rely on\n   attribute(constructor) to cause their init function to run at dlopen\n   time. */\n{\n\tlocal: *;\n};\n"
    },
    "skipped": [],
    "total_files": 524
}