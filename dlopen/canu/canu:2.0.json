{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-canu-2.0-lqlrtjwlx7fqgtmnipssdlmjbv7lvc6j/spack-src/src/utility/libbacktrace/dwarf.c": "/* dwarf.c -- Get file/line information from DWARF for backtraces.\n   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n   Written by Ian Lance Taylor, Google.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    (1) Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    (2) Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n    (3) The name of the author may not be used to\n    endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.  */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include \"backtrace.h\"\n#include \"internal.h\"\n\n/* DWARF constants.  */\n\nenum dwarf_tag {\n  DW_TAG_entry_point = 0x3,\n  DW_TAG_compile_unit = 0x11,\n  DW_TAG_inlined_subroutine = 0x1d,\n  DW_TAG_subprogram = 0x2e,\n};\n\nenum dwarf_form {\n  DW_FORM_addr = 0x1,\n  DW_FORM_block2 = 0x3,\n  DW_FORM_block4 = 0x4,\n  DW_FORM_data2 = 0x5,\n  DW_FORM_data4 = 0x6,\n  DW_FORM_data8 = 0x07,\n  DW_FORM_string = 0x08,\n  DW_FORM_block = 0x09,\n  DW_FORM_block1 = 0x0a,\n  DW_FORM_data1 = 0x0b,\n  DW_FORM_flag = 0x0c,\n  DW_FORM_sdata = 0x0d,\n  DW_FORM_strp = 0x0e,\n  DW_FORM_udata = 0x0f,\n  DW_FORM_ref_addr = 0x10,\n  DW_FORM_ref1 = 0x11,\n  DW_FORM_ref2 = 0x12,\n  DW_FORM_ref4 = 0x13,\n  DW_FORM_ref8 = 0x14,\n  DW_FORM_ref_udata = 0x15,\n  DW_FORM_indirect = 0x16,\n  DW_FORM_sec_offset = 0x17,\n  DW_FORM_exprloc = 0x18,\n  DW_FORM_flag_present = 0x19,\n  DW_FORM_ref_sig8 = 0x20,\n  DW_FORM_GNU_addr_index = 0x1f01,\n  DW_FORM_GNU_str_index = 0x1f02,\n  DW_FORM_GNU_ref_alt = 0x1f20,\n  DW_FORM_GNU_strp_alt = 0x1f21,\n};\n\nenum dwarf_attribute {\n  DW_AT_name = 0x3,\n  DW_AT_stmt_list = 0x10,\n  DW_AT_low_pc = 0x11,\n  DW_AT_high_pc = 0x12,\n  DW_AT_comp_dir = 0x1b,\n  DW_AT_abstract_origin = 0x31,\n  DW_AT_specification = 0x47,\n  DW_AT_ranges = 0x55,\n  DW_AT_call_file = 0x58,\n  DW_AT_call_line = 0x59,\n  DW_AT_linkage_name = 0x6e,\n  DW_AT_MIPS_linkage_name = 0x2007,\n};\n\nenum dwarf_line_number_op {\n  DW_LNS_extended_op = 0x0,\n  DW_LNS_copy = 0x1,\n  DW_LNS_advance_pc = 0x2,\n  DW_LNS_advance_line = 0x3,\n  DW_LNS_set_file = 0x4,\n  DW_LNS_set_column = 0x5,\n  DW_LNS_negate_stmt = 0x6,\n  DW_LNS_set_basic_block = 0x7,\n  DW_LNS_const_add_pc = 0x8,\n  DW_LNS_fixed_advance_pc = 0x9,\n  DW_LNS_set_prologue_end = 0xa,\n  DW_LNS_set_epilogue_begin = 0xb,\n  DW_LNS_set_isa = 0xc,\n};\n\nenum dwarf_extedned_line_number_op {\n  DW_LNE_end_sequence = 0x1,\n  DW_LNE_set_address = 0x2,\n  DW_LNE_define_file = 0x3,\n  DW_LNE_set_discriminator = 0x4,\n};\n\n#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)\n# define IS_DIR_SEPARATOR(c) ((c) == '/' || (c) == '\\\\')\n#define HAS_DRIVE_SPEC(f) ((f)[0] && (f)[1] == ':')\n# define IS_ABSOLUTE_PATH(f) (IS_DIR_SEPARATOR(f[0]) || HAS_DRIVE_SPEC(f))\n#else\n# define IS_DIR_SEPARATOR(c) ((c) == '/')\n# define IS_ABSOLUTE_PATH(f) IS_DIR_SEPARATOR(f[0])\n#endif\n\n#if !defined(HAVE_DECL_STRNLEN) || !HAVE_DECL_STRNLEN\n\n/* If strnlen is not declared, provide our own version.  */\n\nstatic size_t\nxstrnlen (const char *s, size_t maxlen)\n{\n  size_t i;\n\n  for (i = 0; i < maxlen; ++i)\n    if (s[i] == '\\0')\n      break;\n  return i;\n}\n\n#define strnlen xstrnlen\n\n#endif\n\n/* A buffer to read DWARF info.  */\n\nstruct dwarf_buf\n{\n  /* Buffer name for error messages.  */\n  const char *name;\n  /* Start of the buffer.  */\n  const unsigned char *start;\n  /* Next byte to read.  */\n  const unsigned char *buf;\n  /* The number of bytes remaining.  */\n  size_t left;\n  /* Whether the data is big-endian.  */\n  int is_bigendian;\n  /* Error callback routine.  */\n  backtrace_error_callback error_callback;\n  /* Data for error_callback.  */\n  void *data;\n  /* Non-zero if we've reported an underflow error.  */\n  int reported_underflow;\n};\n\n/* A single attribute in a DWARF abbreviation.  */\n\nstruct attr\n{\n  /* The attribute name.  */\n  enum dwarf_attribute name;\n  /* The attribute form.  */\n  enum dwarf_form form;\n};\n\n/* A single DWARF abbreviation.  */\n\nstruct abbrev\n{\n  /* The abbrev code--the number used to refer to the abbrev.  */\n  uint64_t code;\n  /* The entry tag.  */\n  enum dwarf_tag tag;\n  /* Non-zero if this abbrev has child entries.  */\n  int has_children;\n  /* The number of attributes.  */\n  size_t num_attrs;\n  /* The attributes.  */\n  struct attr *attrs;\n};\n\n/* The DWARF abbreviations for a compilation unit.  This structure\n   only exists while reading the compilation unit.  Most DWARF readers\n   seem to a hash table to map abbrev ID's to abbrev entries.\n   However, we primarily care about GCC, and GCC simply issues ID's in\n   numerical order starting at 1.  So we simply keep a sorted vector,\n   and try to just look up the code.  */\n\nstruct abbrevs\n{\n  /* The number of abbrevs in the vector.  */\n  size_t num_abbrevs;\n  /* The abbrevs, sorted by the code field.  */\n  struct abbrev *abbrevs;\n};\n\n/* The different kinds of attribute values.  */\n\nenum attr_val_encoding\n{\n  /* An address.  */\n  ATTR_VAL_ADDRESS,\n  /* A unsigned integer.  */\n  ATTR_VAL_UINT,\n  /* A sigd integer.  */\n  ATTR_VAL_SINT,\n  /* A string.  */\n  ATTR_VAL_STRING,\n  /* An offset to other data in the containing unit.  */\n  ATTR_VAL_REF_UNIT,\n  /* An offset to other data within the .dwarf_info section.  */\n  ATTR_VAL_REF_INFO,\n  /* An offset to data in some other section.  */\n  ATTR_VAL_REF_SECTION,\n  /* A type signature.  */\n  ATTR_VAL_REF_TYPE,\n  /* A block of data (not represented).  */\n  ATTR_VAL_BLOCK,\n  /* An expression (not represented).  */\n  ATTR_VAL_EXPR,\n};\n\n/* An attribute value.  */\n\nstruct attr_val\n{\n  /* How the value is stored in the field u.  */\n  enum attr_val_encoding encoding;\n  union\n  {\n    /* ATTR_VAL_ADDRESS, ATTR_VAL_UINT, ATTR_VAL_REF*.  */\n    uint64_t uint;\n    /* ATTR_VAL_SINT.  */\n    int64_t sint;\n    /* ATTR_VAL_STRING.  */\n    const char *string;\n    /* ATTR_VAL_BLOCK not stored.  */\n  } u;\n};\n\n/* The line number program header.  */\n\nstruct line_header\n{\n  /* The version of the line number information.  */\n  int version;\n  /* The minimum instruction length.  */\n  unsigned int min_insn_len;\n  /* The maximum number of ops per instruction.  */\n  unsigned int max_ops_per_insn;\n  /* The line base for special opcodes.  */\n  int line_base;\n  /* The line range for special opcodes.  */\n  unsigned int line_range;\n  /* The opcode base--the first special opcode.  */\n  unsigned int opcode_base;\n  /* Opcode lengths, indexed by opcode - 1.  */\n  const unsigned char *opcode_lengths;\n  /* The number of directory entries.  */\n  size_t dirs_count;\n  /* The directory entries.  */\n  const char **dirs;\n  /* The number of filenames.  */\n  size_t filenames_count;\n  /* The filenames.  */\n  const char **filenames;\n};\n\n/* Map a single PC value to a file/line.  We will keep a vector of\n   these sorted by PC value.  Each file/line will be correct from the\n   PC up to the PC of the next entry if there is one.  We allocate one\n   extra entry at the end so that we can use bsearch.  */\n\nstruct line\n{\n  /* PC.  */\n  uintptr_t pc;\n  /* File name.  Many entries in the array are expected to point to\n     the same file name.  */\n  const char *filename;\n  /* Line number.  */\n  int lineno;\n  /* Index of the object in the original array read from the DWARF\n     section, before it has been sorted.  The index makes it possible\n     to use Quicksort and maintain stability.  */\n  int idx;\n};\n\n/* A growable vector of line number information.  This is used while\n   reading the line numbers.  */\n\nstruct line_vector\n{\n  /* Memory.  This is an array of struct line.  */\n  struct backtrace_vector vec;\n  /* Number of valid mappings.  */\n  size_t count;\n};\n\n/* A function described in the debug info.  */\n\nstruct function\n{\n  /* The name of the function.  */\n  const char *name;\n  /* If this is an inlined function, the filename of the call\n     site.  */\n  const char *caller_filename;\n  /* If this is an inlined function, the line number of the call\n     site.  */\n  int caller_lineno;\n  /* Map PC ranges to inlined functions.  */\n  struct function_addrs *function_addrs;\n  size_t function_addrs_count;\n};\n\n/* An address range for a function.  This maps a PC value to a\n   specific function.  */\n\nstruct function_addrs\n{\n  /* Range is LOW <= PC < HIGH.  */\n  uint64_t low;\n  uint64_t high;\n  /* Function for this address range.  */\n  struct function *function;\n};\n\n/* A growable vector of function address ranges.  */\n\nstruct function_vector\n{\n  /* Memory.  This is an array of struct function_addrs.  */\n  struct backtrace_vector vec;\n  /* Number of address ranges present.  */\n  size_t count;\n};\n\n/* A DWARF compilation unit.  This only holds the information we need\n   to map a PC to a file and line.  */\n\nstruct unit\n{\n  /* The first entry for this compilation unit.  */\n  const unsigned char *unit_data;\n  /* The length of the data for this compilation unit.  */\n  size_t unit_data_len;\n  /* The offset of UNIT_DATA from the start of the information for\n     this compilation unit.  */\n  size_t unit_data_offset;\n  /* DWARF version.  */\n  int version;\n  /* Whether unit is DWARF64.  */\n  int is_dwarf64;\n  /* Address size.  */\n  int addrsize;\n  /* Offset into line number information.  */\n  off_t lineoff;\n  /* Primary source file.  */\n  const char *filename;\n  /* Compilation command working directory.  */\n  const char *comp_dir;\n  /* Absolute file name, only set if needed.  */\n  const char *abs_filename;\n  /* The abbreviations for this unit.  */\n  struct abbrevs abbrevs;\n\n  /* The fields above this point are read in during initialization and\n     may be accessed freely.  The fields below this point are read in\n     as needed, and therefore require care, as different threads may\n     try to initialize them simultaneously.  */\n\n  /* PC to line number mapping.  This is NULL if the values have not\n     been read.  This is (struct line *) -1 if there was an error\n     reading the values.  */\n  struct line *lines;\n  /* Number of entries in lines.  */\n  size_t lines_count;\n  /* PC ranges to function.  */\n  struct function_addrs *function_addrs;\n  size_t function_addrs_count;\n};\n\n/* An address range for a compilation unit.  This maps a PC value to a\n   specific compilation unit.  Note that we invert the representation\n   in DWARF: instead of listing the units and attaching a list of\n   ranges, we list the ranges and have each one point to the unit.\n   This lets us do a binary search to find the unit.  */\n\nstruct unit_addrs\n{\n  /* Range is LOW <= PC < HIGH.  */\n  uint64_t low;\n  uint64_t high;\n  /* Compilation unit for this address range.  */\n  struct unit *u;\n};\n\n/* A growable vector of compilation unit address ranges.  */\n\nstruct unit_addrs_vector\n{\n  /* Memory.  This is an array of struct unit_addrs.  */\n  struct backtrace_vector vec;\n  /* Number of address ranges present.  */\n  size_t count;\n};\n\n/* The information we need to map a PC to a file and line.  */\n\nstruct dwarf_data\n{\n  /* The data for the next file we know about.  */\n  struct dwarf_data *next;\n  /* The base address for this file.  */\n  uintptr_t base_address;\n  /* A sorted list of address ranges.  */\n  struct unit_addrs *addrs;\n  /* Number of address ranges in list.  */\n  size_t addrs_count;\n  /* The unparsed .debug_info section.  */\n  const unsigned char *dwarf_info;\n  size_t dwarf_info_size;\n  /* The unparsed .debug_line section.  */\n  const unsigned char *dwarf_line;\n  size_t dwarf_line_size;\n  /* The unparsed .debug_ranges section.  */\n  const unsigned char *dwarf_ranges;\n  size_t dwarf_ranges_size;\n  /* The unparsed .debug_str section.  */\n  const unsigned char *dwarf_str;\n  size_t dwarf_str_size;\n  /* Whether the data is big-endian or not.  */\n  int is_bigendian;\n  /* A vector used for function addresses.  We keep this here so that\n     we can grow the vector as we read more functions.  */\n  struct function_vector fvec;\n};\n\n/* Report an error for a DWARF buffer.  */\n\nstatic void\ndwarf_buf_error (struct dwarf_buf *buf, const char *msg)\n{\n  char b[200];\n\n  snprintf (b, sizeof b, \"%s in %s at %d\",\n\t    msg, buf->name, (int) (buf->buf - buf->start));\n  buf->error_callback (buf->data, b, 0);\n}\n\n/* Require at least COUNT bytes in BUF.  Return 1 if all is well, 0 on\n   error.  */\n\nstatic int\nrequire (struct dwarf_buf *buf, size_t count)\n{\n  if (buf->left >= count)\n    return 1;\n\n  if (!buf->reported_underflow)\n    {\n      dwarf_buf_error (buf, \"DWARF underflow\");\n      buf->reported_underflow = 1;\n    }\n\n  return 0;\n}\n\n/* Advance COUNT bytes in BUF.  Return 1 if all is well, 0 on\n   error.  */\n\nstatic int\nadvance (struct dwarf_buf *buf, size_t count)\n{\n  if (!require (buf, count))\n    return 0;\n  buf->buf += count;\n  buf->left -= count;\n  return 1;\n}\n\n/* Read one byte from BUF and advance 1 byte.  */\n\nstatic unsigned char\nread_byte (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 1))\n    return 0;\n  return p[0];\n}\n\n/* Read a signed char from BUF and advance 1 byte.  */\n\nstatic signed char\nread_sbyte (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 1))\n    return 0;\n  return (*p ^ 0x80) - 0x80;\n}\n\n/* Read a uint16 from BUF and advance 2 bytes.  */\n\nstatic uint16_t\nread_uint16 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 2))\n    return 0;\n  if (buf->is_bigendian)\n    return ((uint16_t) p[0] << 8) | (uint16_t) p[1];\n  else\n    return ((uint16_t) p[1] << 8) | (uint16_t) p[0];\n}\n\n/* Read a uint32 from BUF and advance 4 bytes.  */\n\nstatic uint32_t\nread_uint32 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 4))\n    return 0;\n  if (buf->is_bigendian)\n    return (((uint32_t) p[0] << 24) | ((uint32_t) p[1] << 16)\n\t    | ((uint32_t) p[2] << 8) | (uint32_t) p[3]);\n  else\n    return (((uint32_t) p[3] << 24) | ((uint32_t) p[2] << 16)\n\t    | ((uint32_t) p[1] << 8) | (uint32_t) p[0]);\n}\n\n/* Read a uint64 from BUF and advance 8 bytes.  */\n\nstatic uint64_t\nread_uint64 (struct dwarf_buf *buf)\n{\n  const unsigned char *p = buf->buf;\n\n  if (!advance (buf, 8))\n    return 0;\n  if (buf->is_bigendian)\n    return (((uint64_t) p[0] << 56) | ((uint64_t) p[1] << 48)\n\t    | ((uint64_t) p[2] << 40) | ((uint64_t) p[3] << 32)\n\t    | ((uint64_t) p[4] << 24) | ((uint64_t) p[5] << 16)\n\t    | ((uint64_t) p[6] << 8) | (uint64_t) p[7]);\n  else\n    return (((uint64_t) p[7] << 56) | ((uint64_t) p[6] << 48)\n\t    | ((uint64_t) p[5] << 40) | ((uint64_t) p[4] << 32)\n\t    | ((uint64_t) p[3] << 24) | ((uint64_t) p[2] << 16)\n\t    | ((uint64_t) p[1] << 8) | (uint64_t) p[0]);\n}\n\n/* Read an offset from BUF and advance the appropriate number of\n   bytes.  */\n\nstatic uint64_t\nread_offset (struct dwarf_buf *buf, int is_dwarf64)\n{\n  if (is_dwarf64)\n    return read_uint64 (buf);\n  else\n    return read_uint32 (buf);\n}\n\n/* Read an address from BUF and advance the appropriate number of\n   bytes.  */\n\nstatic uint64_t\nread_address (struct dwarf_buf *buf, int addrsize)\n{\n  switch (addrsize)\n    {\n    case 1:\n      return read_byte (buf);\n    case 2:\n      return read_uint16 (buf);\n    case 4:\n      return read_uint32 (buf);\n    case 8:\n      return read_uint64 (buf);\n    default:\n      dwarf_buf_error (buf, \"unrecognized address size\");\n      return 0;\n    }\n}\n\n/* Return whether a value is the highest possible address, given the\n   address size.  */\n\nstatic int\nis_highest_address (uint64_t address, int addrsize)\n{\n  switch (addrsize)\n    {\n    case 1:\n      return address == (unsigned char) -1;\n    case 2:\n      return address == (uint16_t) -1;\n    case 4:\n      return address == (uint32_t) -1;\n    case 8:\n      return address == (uint64_t) -1;\n    default:\n      return 0;\n    }\n}\n\n/* Read an unsigned LEB128 number.  */\n\nstatic uint64_t\nread_uleb128 (struct dwarf_buf *buf)\n{\n  uint64_t ret;\n  unsigned int shift;\n  int overflow;\n  unsigned char b;\n\n  ret = 0;\n  shift = 0;\n  overflow = 0;\n  do\n    {\n      const unsigned char *p;\n\n      p = buf->buf;\n      if (!advance (buf, 1))\n\treturn 0;\n      b = *p;\n      if (shift < 64)\n\tret |= ((uint64_t) (b & 0x7f)) << shift;\n      else if (!overflow)\n\t{\n\t  dwarf_buf_error (buf, \"LEB128 overflows uint64_t\");\n\t  overflow = 1;\n\t}\n      shift += 7;\n    }\n  while ((b & 0x80) != 0);\n\n  return ret;\n}\n\n/* Read a signed LEB128 number.  */\n\nstatic int64_t\nread_sleb128 (struct dwarf_buf *buf)\n{\n  uint64_t val;\n  unsigned int shift;\n  int overflow;\n  unsigned char b;\n\n  val = 0;\n  shift = 0;\n  overflow = 0;\n  do\n    {\n      const unsigned char *p;\n\n      p = buf->buf;\n      if (!advance (buf, 1))\n\treturn 0;\n      b = *p;\n      if (shift < 64)\n\tval |= ((uint64_t) (b & 0x7f)) << shift;\n      else if (!overflow)\n\t{\n\t  dwarf_buf_error (buf, \"signed LEB128 overflows uint64_t\");\n\t  overflow = 1;\n\t}\n      shift += 7;\n    }\n  while ((b & 0x80) != 0);\n\n  if ((b & 0x40) != 0 && shift < 64)\n    val |= ((uint64_t) -1) << shift;\n\n  return (int64_t) val;\n}\n\n/* Return the length of an LEB128 number.  */\n\nstatic size_t\nleb128_len (const unsigned char *p)\n{\n  size_t ret;\n\n  ret = 1;\n  while ((*p & 0x80) != 0)\n    {\n      ++p;\n      ++ret;\n    }\n  return ret;\n}\n\n/* Free an abbreviations structure.  */\n\nstatic void\nfree_abbrevs (struct backtrace_state *state, struct abbrevs *abbrevs,\n\t      backtrace_error_callback error_callback, void *data)\n{\n  size_t i;\n\n  for (i = 0; i < abbrevs->num_abbrevs; ++i)\n    backtrace_free (state, abbrevs->abbrevs[i].attrs,\n\t\t    abbrevs->abbrevs[i].num_attrs * sizeof (struct attr),\n\t\t    error_callback, data);\n  backtrace_free (state, abbrevs->abbrevs,\n\t\t  abbrevs->num_abbrevs * sizeof (struct abbrev),\n\t\t  error_callback, data);\n  abbrevs->num_abbrevs = 0;\n  abbrevs->abbrevs = NULL;\n}\n\n/* Read an attribute value.  Returns 1 on success, 0 on failure.  If\n   the value can be represented as a uint64_t, sets *VAL and sets\n   *IS_VALID to 1.  We don't try to store the value of other attribute\n   forms, because we don't care about them.  */\n\nstatic int\nread_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n\t\tint is_dwarf64, int version, int addrsize,\n\t\tconst unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\tstruct attr_val *val)\n{\n  /* Avoid warnings about val.u.FIELD may be used uninitialized if\n     this function is inlined.  The warnings aren't valid but can\n     occur because the different fields are set and used\n     conditionally.  */\n  memset (val, 0, sizeof *val);\n\n  switch (form)\n    {\n    case DW_FORM_addr:\n      val->encoding = ATTR_VAL_ADDRESS;\n      val->u.uint = read_address (buf, addrsize);\n      return 1;\n    case DW_FORM_block2:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uint16 (buf));\n    case DW_FORM_block4:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uint32 (buf));\n    case DW_FORM_data2:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint16 (buf);\n      return 1;\n    case DW_FORM_data4:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint32 (buf);\n      return 1;\n    case DW_FORM_data8:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_string:\n      val->encoding = ATTR_VAL_STRING;\n      val->u.string = (const char *) buf->buf;\n      return advance (buf, strnlen ((const char *) buf->buf, buf->left) + 1);\n    case DW_FORM_block:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_uleb128 (buf));\n    case DW_FORM_block1:\n      val->encoding = ATTR_VAL_BLOCK;\n      return advance (buf, read_byte (buf));\n    case DW_FORM_data1:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_flag:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_sdata:\n      val->encoding = ATTR_VAL_SINT;\n      val->u.sint = read_sleb128 (buf);\n      return 1;\n    case DW_FORM_strp:\n      {\n\tuint64_t offset;\n\n\toffset = read_offset (buf, is_dwarf64);\n\tif (offset >= dwarf_str_size)\n\t  {\n\t    dwarf_buf_error (buf, \"DW_FORM_strp out of range\");\n\t    return 0;\n\t  }\n\tval->encoding = ATTR_VAL_STRING;\n\tval->u.string = (const char *) dwarf_str + offset;\n\treturn 1;\n      }\n    case DW_FORM_udata:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_ref_addr:\n      val->encoding = ATTR_VAL_REF_INFO;\n      if (version == 2)\n\tval->u.uint = read_address (buf, addrsize);\n      else\n\tval->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_ref1:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_byte (buf);\n      return 1;\n    case DW_FORM_ref2:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint16 (buf);\n      return 1;\n    case DW_FORM_ref4:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint32 (buf);\n      return 1;\n    case DW_FORM_ref8:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_ref_udata:\n      val->encoding = ATTR_VAL_REF_UNIT;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_indirect:\n      {\n\tuint64_t form;\n\n\tform = read_uleb128 (buf);\n\treturn read_attribute ((enum dwarf_form) form, buf, is_dwarf64,\n\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n\t\t\t       val);\n      }\n    case DW_FORM_sec_offset:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_exprloc:\n      val->encoding = ATTR_VAL_EXPR;\n      return advance (buf, read_uleb128 (buf));\n    case DW_FORM_flag_present:\n      val->encoding = ATTR_VAL_UINT;\n      val->u.uint = 1;\n      return 1;\n    case DW_FORM_ref_sig8:\n      val->encoding = ATTR_VAL_REF_TYPE;\n      val->u.uint = read_uint64 (buf);\n      return 1;\n    case DW_FORM_GNU_addr_index:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_GNU_str_index:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_uleb128 (buf);\n      return 1;\n    case DW_FORM_GNU_ref_alt:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    case DW_FORM_GNU_strp_alt:\n      val->encoding = ATTR_VAL_REF_SECTION;\n      val->u.uint = read_offset (buf, is_dwarf64);\n      return 1;\n    default:\n      dwarf_buf_error (buf, \"unrecognized DWARF form\");\n      return 0;\n    }\n}\n\n/* Compare function_addrs for qsort.  When ranges are nested, make the\n   smallest one sort last.  */\n\nstatic int\nfunction_addrs_compare (const void *v1, const void *v2)\n{\n  const struct function_addrs *a1 = (const struct function_addrs *) v1;\n  const struct function_addrs *a2 = (const struct function_addrs *) v2;\n\n  if (a1->low < a2->low)\n    return -1;\n  if (a1->low > a2->low)\n    return 1;\n  if (a1->high < a2->high)\n    return 1;\n  if (a1->high > a2->high)\n    return -1;\n  return strcmp (a1->function->name, a2->function->name);\n}\n\n/* Compare a PC against a function_addrs for bsearch.  Note that if\n   there are multiple ranges containing PC, which one will be returned\n   is unpredictable.  We compensate for that in dwarf_fileline.  */\n\nstatic int\nfunction_addrs_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct function_addrs *entry = (const struct function_addrs *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->low)\n    return -1;\n  else if (pc >= entry->high)\n    return 1;\n  else\n    return 0;\n}\n\n/* Add a new compilation unit address range to a vector.  Returns 1 on\n   success, 0 on failure.  */\n\nstatic int\nadd_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n\t       struct unit_addrs addrs,\n\t       backtrace_error_callback error_callback, void *data,\n\t       struct unit_addrs_vector *vec)\n{\n  struct unit_addrs *p;\n\n  /* Add in the base address of the module here, so that we can look\n     up the PC directly.  */\n  addrs.low += base_address;\n  addrs.high += base_address;\n\n  /* Try to merge with the last entry.  */\n  if (vec->count > 0)\n    {\n      p = (struct unit_addrs *) vec->vec.base + (vec->count - 1);\n      if ((addrs.low == p->high || addrs.low == p->high + 1)\n\t  && addrs.u == p->u)\n\t{\n\t  if (addrs.high > p->high)\n\t    p->high = addrs.high;\n\t  return 1;\n\t}\n    }\n\n  p = ((struct unit_addrs *)\n       backtrace_vector_grow (state, sizeof (struct unit_addrs),\n\t\t\t      error_callback, data, &vec->vec));\n  if (p == NULL)\n    return 0;\n\n  *p = addrs;\n  ++vec->count;\n  return 1;\n}\n\n/* Free a unit address vector.  */\n\nstatic void\nfree_unit_addrs_vector (struct backtrace_state *state,\n\t\t\tstruct unit_addrs_vector *vec,\n\t\t\tbacktrace_error_callback error_callback, void *data)\n{\n  struct unit_addrs *addrs;\n  size_t i;\n\n  addrs = (struct unit_addrs *) vec->vec.base;\n  for (i = 0; i < vec->count; ++i)\n    free_abbrevs (state, &addrs[i].u->abbrevs, error_callback, data);\n}\n\n/* Compare unit_addrs for qsort.  When ranges are nested, make the\n   smallest one sort last.  */\n\nstatic int\nunit_addrs_compare (const void *v1, const void *v2)\n{\n  const struct unit_addrs *a1 = (const struct unit_addrs *) v1;\n  const struct unit_addrs *a2 = (const struct unit_addrs *) v2;\n\n  if (a1->low < a2->low)\n    return -1;\n  if (a1->low > a2->low)\n    return 1;\n  if (a1->high < a2->high)\n    return 1;\n  if (a1->high > a2->high)\n    return -1;\n  if (a1->u->lineoff < a2->u->lineoff)\n    return -1;\n  if (a1->u->lineoff > a2->u->lineoff)\n    return 1;\n  return 0;\n}\n\n/* Compare a PC against a unit_addrs for bsearch.  Note that if there\n   are multiple ranges containing PC, which one will be returned is\n   unpredictable.  We compensate for that in dwarf_fileline.  */\n\nstatic int\nunit_addrs_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct unit_addrs *entry = (const struct unit_addrs *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->low)\n    return -1;\n  else if (pc >= entry->high)\n    return 1;\n  else\n    return 0;\n}\n\n/* Sort the line vector by PC.  We want a stable sort here to maintain\n   the order of lines for the same PC values.  Since the sequence is\n   being sorted in place, their addresses cannot be relied on to\n   maintain stability.  That is the purpose of the index member.  */\n\nstatic int\nline_compare (const void *v1, const void *v2)\n{\n  const struct line *ln1 = (const struct line *) v1;\n  const struct line *ln2 = (const struct line *) v2;\n\n  if (ln1->pc < ln2->pc)\n    return -1;\n  else if (ln1->pc > ln2->pc)\n    return 1;\n  else if (ln1->idx < ln2->idx)\n    return -1;\n  else if (ln1->idx > ln2->idx)\n    return 1;\n  else\n    return 0;\n}\n\n/* Find a PC in a line vector.  We always allocate an extra entry at\n   the end of the lines vector, so that this routine can safely look\n   at the next entry.  Note that when there are multiple mappings for\n   the same PC value, this will return the last one.  */\n\nstatic int\nline_search (const void *vkey, const void *ventry)\n{\n  const uintptr_t *key = (const uintptr_t *) vkey;\n  const struct line *entry = (const struct line *) ventry;\n  uintptr_t pc;\n\n  pc = *key;\n  if (pc < entry->pc)\n    return -1;\n  else if (pc >= (entry + 1)->pc)\n    return 1;\n  else\n    return 0;\n}\n\n/* Sort the abbrevs by the abbrev code.  This function is passed to\n   both qsort and bsearch.  */\n\nstatic int\nabbrev_compare (const void *v1, const void *v2)\n{\n  const struct abbrev *a1 = (const struct abbrev *) v1;\n  const struct abbrev *a2 = (const struct abbrev *) v2;\n\n  if (a1->code < a2->code)\n    return -1;\n  else if (a1->code > a2->code)\n    return 1;\n  else\n    {\n      /* This really shouldn't happen.  It means there are two\n\t different abbrevs with the same code, and that means we don't\n\t know which one lookup_abbrev should return.  */\n      return 0;\n    }\n}\n\n/* Read the abbreviation table for a compilation unit.  Returns 1 on\n   success, 0 on failure.  */\n\nstatic int\nread_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n\t      const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n\t      int is_bigendian, backtrace_error_callback error_callback,\n\t      void *data, struct abbrevs *abbrevs)\n{\n  struct dwarf_buf abbrev_buf;\n  struct dwarf_buf count_buf;\n  size_t num_abbrevs;\n\n  abbrevs->num_abbrevs = 0;\n  abbrevs->abbrevs = NULL;\n\n  if (abbrev_offset >= dwarf_abbrev_size)\n    {\n      error_callback (data, \"abbrev offset out of range\", 0);\n      return 0;\n    }\n\n  abbrev_buf.name = \".debug_abbrev\";\n  abbrev_buf.start = dwarf_abbrev;\n  abbrev_buf.buf = dwarf_abbrev + abbrev_offset;\n  abbrev_buf.left = dwarf_abbrev_size - abbrev_offset;\n  abbrev_buf.is_bigendian = is_bigendian;\n  abbrev_buf.error_callback = error_callback;\n  abbrev_buf.data = data;\n  abbrev_buf.reported_underflow = 0;\n\n  /* Count the number of abbrevs in this list.  */\n\n  count_buf = abbrev_buf;\n  num_abbrevs = 0;\n  while (read_uleb128 (&count_buf) != 0)\n    {\n      if (count_buf.reported_underflow)\n\treturn 0;\n      ++num_abbrevs;\n      // Skip tag.\n      read_uleb128 (&count_buf);\n      // Skip has_children.\n      read_byte (&count_buf);\n      // Skip attributes.\n      while (read_uleb128 (&count_buf) != 0)\n\tread_uleb128 (&count_buf);\n      // Skip form of last attribute.\n      read_uleb128 (&count_buf);\n    }\n\n  if (count_buf.reported_underflow)\n    return 0;\n\n  if (num_abbrevs == 0)\n    return 1;\n\n  abbrevs->num_abbrevs = num_abbrevs;\n  abbrevs->abbrevs = ((struct abbrev *)\n\t\t      backtrace_alloc (state,\n\t\t\t\t       num_abbrevs * sizeof (struct abbrev),\n\t\t\t\t       error_callback, data));\n  if (abbrevs->abbrevs == NULL)\n    return 0;\n  memset (abbrevs->abbrevs, 0, num_abbrevs * sizeof (struct abbrev));\n\n  num_abbrevs = 0;\n  while (1)\n    {\n      uint64_t code;\n      struct abbrev a;\n      size_t num_attrs;\n      struct attr *attrs;\n\n      if (abbrev_buf.reported_underflow)\n\tgoto fail;\n\n      code = read_uleb128 (&abbrev_buf);\n      if (code == 0)\n\tbreak;\n\n      a.code = code;\n      a.tag = (enum dwarf_tag) read_uleb128 (&abbrev_buf);\n      a.has_children = read_byte (&abbrev_buf);\n\n      count_buf = abbrev_buf;\n      num_attrs = 0;\n      while (read_uleb128 (&count_buf) != 0)\n\t{\n\t  ++num_attrs;\n\t  read_uleb128 (&count_buf);\n\t}\n\n      if (num_attrs == 0)\n\t{\n\t  attrs = NULL;\n\t  read_uleb128 (&abbrev_buf);\n\t  read_uleb128 (&abbrev_buf);\n\t}\n      else\n\t{\n\t  attrs = ((struct attr *)\n\t\t   backtrace_alloc (state, num_attrs * sizeof *attrs,\n\t\t\t\t    error_callback, data));\n\t  if (attrs == NULL)\n\t    goto fail;\n\t  num_attrs = 0;\n\t  while (1)\n\t    {\n\t      uint64_t name;\n\t      uint64_t form;\n\n\t      name = read_uleb128 (&abbrev_buf);\n\t      form = read_uleb128 (&abbrev_buf);\n\t      if (name == 0)\n\t\tbreak;\n\t      attrs[num_attrs].name = (enum dwarf_attribute) name;\n\t      attrs[num_attrs].form = (enum dwarf_form) form;\n\t      ++num_attrs;\n\t    }\n\t}\n\n      a.num_attrs = num_attrs;\n      a.attrs = attrs;\n\n      abbrevs->abbrevs[num_abbrevs] = a;\n      ++num_abbrevs;\n    }\n\n  backtrace_qsort (abbrevs->abbrevs, abbrevs->num_abbrevs,\n\t\t   sizeof (struct abbrev), abbrev_compare);\n\n  return 1;\n\n fail:\n  free_abbrevs (state, abbrevs, error_callback, data);\n  return 0;\n}\n\n/* Return the abbrev information for an abbrev code.  */\n\nstatic const struct abbrev *\nlookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n\t       backtrace_error_callback error_callback, void *data)\n{\n  struct abbrev key;\n  void *p;\n\n  /* With GCC, where abbrevs are simply numbered in order, we should\n     be able to just look up the entry.  */\n  if (code - 1 < abbrevs->num_abbrevs\n      && abbrevs->abbrevs[code - 1].code == code)\n    return &abbrevs->abbrevs[code - 1];\n\n  /* Otherwise we have to search.  */\n  memset (&key, 0, sizeof key);\n  key.code = code;\n  p = bsearch (&key, abbrevs->abbrevs, abbrevs->num_abbrevs,\n\t       sizeof (struct abbrev), abbrev_compare);\n  if (p == NULL)\n    {\n      error_callback (data, \"invalid abbreviation code\", 0);\n      return NULL;\n    }\n  return (const struct abbrev *) p;\n}\n\n/* Add non-contiguous address ranges for a compilation unit.  Returns\n   1 on success, 0 on failure.  */\n\nstatic int\nadd_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n\t\t struct unit *u, uint64_t ranges, uint64_t base,\n\t\t int is_bigendian, const unsigned char *dwarf_ranges,\n\t\t size_t dwarf_ranges_size,\n\t\t backtrace_error_callback error_callback, void *data,\n\t\t struct unit_addrs_vector *addrs)\n{\n  struct dwarf_buf ranges_buf;\n\n  if (ranges >= dwarf_ranges_size)\n    {\n      error_callback (data, \"ranges offset out of range\", 0);\n      return 0;\n    }\n\n  ranges_buf.name = \".debug_ranges\";\n  ranges_buf.start = dwarf_ranges;\n  ranges_buf.buf = dwarf_ranges + ranges;\n  ranges_buf.left = dwarf_ranges_size - ranges;\n  ranges_buf.is_bigendian = is_bigendian;\n  ranges_buf.error_callback = error_callback;\n  ranges_buf.data = data;\n  ranges_buf.reported_underflow = 0;\n\n  while (1)\n    {\n      uint64_t low;\n      uint64_t high;\n\n      if (ranges_buf.reported_underflow)\n\treturn 0;\n\n      low = read_address (&ranges_buf, u->addrsize);\n      high = read_address (&ranges_buf, u->addrsize);\n\n      if (low == 0 && high == 0)\n\tbreak;\n\n      if (is_highest_address (low, u->addrsize))\n\tbase = high;\n      else\n\t{\n\t  struct unit_addrs a;\n\n\t  a.low = low + base;\n\t  a.high = high + base;\n\t  a.u = u;\n\t  if (!add_unit_addr (state, base_address, a, error_callback, data,\n\t\t\t      addrs))\n\t    return 0;\n\t}\n    }\n\n  if (ranges_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Find the address range covered by a compilation unit, reading from\n   UNIT_BUF and adding values to U.  Returns 1 if all data could be\n   read, 0 if there is some error.  */\n\nstatic int\nfind_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n\t\t     struct dwarf_buf *unit_buf,\n\t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\t     const unsigned char *dwarf_ranges,\n\t\t     size_t dwarf_ranges_size,\n\t\t     int is_bigendian, backtrace_error_callback error_callback,\n\t\t     void *data, struct unit *u,\n\t\t     struct unit_addrs_vector *addrs)\n{\n  while (unit_buf->left > 0)\n    {\n      uint64_t code;\n      const struct abbrev *abbrev;\n      uint64_t lowpc;\n      int have_lowpc;\n      uint64_t highpc;\n      int have_highpc;\n      int highpc_is_relative;\n      uint64_t ranges;\n      int have_ranges;\n      size_t i;\n\n      code = read_uleb128 (unit_buf);\n      if (code == 0)\n\treturn 1;\n\n      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n      if (abbrev == NULL)\n\treturn 0;\n\n      lowpc = 0;\n      have_lowpc = 0;\n      highpc = 0;\n      have_highpc = 0;\n      highpc_is_relative = 0;\n      ranges = 0;\n      have_ranges = 0;\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attr_val val;\n\n\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n\t\t\t       dwarf_str, dwarf_str_size, &val))\n\t    return 0;\n\n\t  switch (abbrev->attrs[i].name)\n\t    {\n\t    case DW_AT_low_pc:\n\t      if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t{\n\t\t  lowpc = val.u.uint;\n\t\t  have_lowpc = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_high_pc:\n\t      if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t{\n\t\t  highpc = val.u.uint;\n\t\t  have_highpc = 1;\n\t\t}\n\t      else if (val.encoding == ATTR_VAL_UINT)\n\t\t{\n\t\t  highpc = val.u.uint;\n\t\t  have_highpc = 1;\n\t\t  highpc_is_relative = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_ranges:\n\t      if (val.encoding == ATTR_VAL_UINT\n\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n\t\t{\n\t\t  ranges = val.u.uint;\n\t\t  have_ranges = 1;\n\t\t}\n\t      break;\n\n\t    case DW_AT_stmt_list:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_SECTION))\n\t\tu->lineoff = val.u.uint;\n\t      break;\n\n\t    case DW_AT_name:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && val.encoding == ATTR_VAL_STRING)\n\t\tu->filename = val.u.string;\n\t      break;\n\n\t    case DW_AT_comp_dir:\n\t      if (abbrev->tag == DW_TAG_compile_unit\n\t\t  && val.encoding == ATTR_VAL_STRING)\n\t\tu->comp_dir = val.u.string;\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      if (abbrev->tag == DW_TAG_compile_unit\n\t  || abbrev->tag == DW_TAG_subprogram)\n\t{\n\t  if (have_ranges)\n\t    {\n\t      if (!add_unit_ranges (state, base_address, u, ranges, lowpc,\n\t\t\t\t    is_bigendian, dwarf_ranges,\n\t\t\t\t    dwarf_ranges_size, error_callback,\n\t\t\t\t    data, addrs))\n\t\treturn 0;\n\t    }\n\t  else if (have_lowpc && have_highpc)\n\t    {\n\t      struct unit_addrs a;\n\n\t      if (highpc_is_relative)\n\t\thighpc += lowpc;\n\t      a.low = lowpc;\n\t      a.high = highpc;\n\t      a.u = u;\n\n\t      if (!add_unit_addr (state, base_address, a, error_callback, data,\n\t\t\t\t  addrs))\n\t\treturn 0;\n\t    }\n\n\t  /* If we found the PC range in the DW_TAG_compile_unit, we\n\t     can stop now.  */\n\t  if (abbrev->tag == DW_TAG_compile_unit\n\t      && (have_ranges || (have_lowpc && have_highpc)))\n\t    return 1;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  if (!find_address_ranges (state, base_address, unit_buf,\n\t\t\t\t    dwarf_str, dwarf_str_size,\n\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n\t\t\t\t    is_bigendian, error_callback, data,\n\t\t\t\t    u, addrs))\n\t    return 0;\n\t}\n    }\n\n  return 1;\n}\n\n/* Build a mapping from address ranges to the compilation units where\n   the line number information for that range can be found.  Returns 1\n   on success, 0 on failure.  */\n\nstatic int\nbuild_address_map (struct backtrace_state *state, uintptr_t base_address,\n\t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n\t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n\t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n\t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n\t\t   int is_bigendian, backtrace_error_callback error_callback,\n\t\t   void *data, struct unit_addrs_vector *addrs)\n{\n  struct dwarf_buf info;\n  struct abbrevs abbrevs;\n\n  memset (&addrs->vec, 0, sizeof addrs->vec);\n  addrs->count = 0;\n\n  /* Read through the .debug_info section.  FIXME: Should we use the\n     .debug_aranges section?  gdb and addr2line don't use it, but I'm\n     not sure why.  */\n\n  info.name = \".debug_info\";\n  info.start = dwarf_info;\n  info.buf = dwarf_info;\n  info.left = dwarf_info_size;\n  info.is_bigendian = is_bigendian;\n  info.error_callback = error_callback;\n  info.data = data;\n  info.reported_underflow = 0;\n\n  memset (&abbrevs, 0, sizeof abbrevs);\n  while (info.left > 0)\n    {\n      const unsigned char *unit_data_start;\n      uint64_t len;\n      int is_dwarf64;\n      struct dwarf_buf unit_buf;\n      int version;\n      uint64_t abbrev_offset;\n      int addrsize;\n      struct unit *u;\n\n      if (info.reported_underflow)\n\tgoto fail;\n\n      unit_data_start = info.buf;\n\n      is_dwarf64 = 0;\n      len = read_uint32 (&info);\n      if (len == 0xffffffff)\n\t{\n\t  len = read_uint64 (&info);\n\t  is_dwarf64 = 1;\n\t}\n\n      unit_buf = info;\n      unit_buf.left = len;\n\n      if (!advance (&info, len))\n\tgoto fail;\n\n      version = read_uint16 (&unit_buf);\n      if (version < 2 || version > 4)\n\t{\n\t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n\t  goto fail;\n\t}\n\n      abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n      if (!read_abbrevs (state, abbrev_offset, dwarf_abbrev, dwarf_abbrev_size,\n\t\t\t is_bigendian, error_callback, data, &abbrevs))\n\tgoto fail;\n\n      addrsize = read_byte (&unit_buf);\n\n      u = ((struct unit *)\n\t   backtrace_alloc (state, sizeof *u, error_callback, data));\n      if (u == NULL)\n\tgoto fail;\n      u->unit_data = unit_buf.buf;\n      u->unit_data_len = unit_buf.left;\n      u->unit_data_offset = unit_buf.buf - unit_data_start;\n      u->version = version;\n      u->is_dwarf64 = is_dwarf64;\n      u->addrsize = addrsize;\n      u->filename = NULL;\n      u->comp_dir = NULL;\n      u->abs_filename = NULL;\n      u->lineoff = 0;\n      u->abbrevs = abbrevs;\n      memset (&abbrevs, 0, sizeof abbrevs);\n\n      /* The actual line number mappings will be read as needed.  */\n      u->lines = NULL;\n      u->lines_count = 0;\n      u->function_addrs = NULL;\n      u->function_addrs_count = 0;\n\n      if (!find_address_ranges (state, base_address, &unit_buf,\n\t\t\t\tdwarf_str, dwarf_str_size,\n\t\t\t\tdwarf_ranges, dwarf_ranges_size,\n\t\t\t\tis_bigendian, error_callback, data,\n\t\t\t\tu, addrs))\n\t{\n\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n\t  goto fail;\n\t}\n\n      if (unit_buf.reported_underflow)\n\t{\n\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n\t  goto fail;\n\t}\n    }\n  if (info.reported_underflow)\n    goto fail;\n\n  return 1;\n\n fail:\n  free_abbrevs (state, &abbrevs, error_callback, data);\n  free_unit_addrs_vector (state, addrs, error_callback, data);\n  return 0;\n}\n\n/* Add a new mapping to the vector of line mappings that we are\n   building.  Returns 1 on success, 0 on failure.  */\n\nstatic int\nadd_line (struct backtrace_state *state, struct dwarf_data *ddata,\n\t  uintptr_t pc, const char *filename, int lineno,\n\t  backtrace_error_callback error_callback, void *data,\n\t  struct line_vector *vec)\n{\n  struct line *ln;\n\n  /* If we are adding the same mapping, ignore it.  This can happen\n     when using discriminators.  */\n  if (vec->count > 0)\n    {\n      ln = (struct line *) vec->vec.base + (vec->count - 1);\n      if (pc == ln->pc && filename == ln->filename && lineno == ln->lineno)\n\treturn 1;\n    }\n\n  ln = ((struct line *)\n\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n\t\t\t       data, &vec->vec));\n  if (ln == NULL)\n    return 0;\n\n  /* Add in the base address here, so that we can look up the PC\n     directly.  */\n  ln->pc = pc + ddata->base_address;\n\n  ln->filename = filename;\n  ln->lineno = lineno;\n  ln->idx = vec->count;\n\n  ++vec->count;\n\n  return 1;\n}\n\n/* Free the line header information.  If FREE_FILENAMES is true we\n   free the file names themselves, otherwise we leave them, as there\n   may be line structures pointing to them.  */\n\nstatic void\nfree_line_header (struct backtrace_state *state, struct line_header *hdr,\n\t\t  backtrace_error_callback error_callback, void *data)\n{\n  backtrace_free (state, hdr->dirs, hdr->dirs_count * sizeof (const char *),\n\t\t  error_callback, data);\n  backtrace_free (state, hdr->filenames,\n\t\t  hdr->filenames_count * sizeof (char *),\n\t\t  error_callback, data);\n}\n\n/* Read the line header.  Return 1 on success, 0 on failure.  */\n\nstatic int\nread_line_header (struct backtrace_state *state, struct unit *u,\n\t\t  int is_dwarf64, struct dwarf_buf *line_buf,\n\t\t  struct line_header *hdr)\n{\n  uint64_t hdrlen;\n  struct dwarf_buf hdr_buf;\n  const unsigned char *p;\n  const unsigned char *pend;\n  size_t i;\n\n  hdr->version = read_uint16 (line_buf);\n  if (hdr->version < 2 || hdr->version > 4)\n    {\n      dwarf_buf_error (line_buf, \"unsupported line number version\");\n      return 0;\n    }\n\n  hdrlen = read_offset (line_buf, is_dwarf64);\n\n  hdr_buf = *line_buf;\n  hdr_buf.left = hdrlen;\n\n  if (!advance (line_buf, hdrlen))\n    return 0;\n\n  hdr->min_insn_len = read_byte (&hdr_buf);\n  if (hdr->version < 4)\n    hdr->max_ops_per_insn = 1;\n  else\n    hdr->max_ops_per_insn = read_byte (&hdr_buf);\n\n  /* We don't care about default_is_stmt.  */\n  read_byte (&hdr_buf);\n\n  hdr->line_base = read_sbyte (&hdr_buf);\n  hdr->line_range = read_byte (&hdr_buf);\n\n  hdr->opcode_base = read_byte (&hdr_buf);\n  hdr->opcode_lengths = hdr_buf.buf;\n  if (!advance (&hdr_buf, hdr->opcode_base - 1))\n    return 0;\n\n  /* Count the number of directory entries.  */\n  hdr->dirs_count = 0;\n  p = hdr_buf.buf;\n  pend = p + hdr_buf.left;\n  while (p < pend && *p != '\\0')\n    {\n      p += strnlen((const char *) p, pend - p) + 1;\n      ++hdr->dirs_count;\n    }\n\n  hdr->dirs = ((const char **)\n\t       backtrace_alloc (state,\n\t\t\t\thdr->dirs_count * sizeof (const char *),\n\t\t\t\tline_buf->error_callback, line_buf->data));\n  if (hdr->dirs == NULL)\n    return 0;\n\n  i = 0;\n  while (*hdr_buf.buf != '\\0')\n    {\n      if (hdr_buf.reported_underflow)\n\treturn 0;\n\n      hdr->dirs[i] = (const char *) hdr_buf.buf;\n      ++i;\n      if (!advance (&hdr_buf,\n\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n\treturn 0;\n    }\n  if (!advance (&hdr_buf, 1))\n    return 0;\n\n  /* Count the number of file entries.  */\n  hdr->filenames_count = 0;\n  p = hdr_buf.buf;\n  pend = p + hdr_buf.left;\n  while (p < pend && *p != '\\0')\n    {\n      p += strnlen ((const char *) p, pend - p) + 1;\n      p += leb128_len (p);\n      p += leb128_len (p);\n      p += leb128_len (p);\n      ++hdr->filenames_count;\n    }\n\n  hdr->filenames = ((const char **)\n\t\t    backtrace_alloc (state,\n\t\t\t\t     hdr->filenames_count * sizeof (char *),\n\t\t\t\t     line_buf->error_callback,\n\t\t\t\t     line_buf->data));\n  if (hdr->filenames == NULL)\n    return 0;\n  i = 0;\n  while (*hdr_buf.buf != '\\0')\n    {\n      const char *filename;\n      uint64_t dir_index;\n\n      if (hdr_buf.reported_underflow)\n\treturn 0;\n\n      filename = (const char *) hdr_buf.buf;\n      if (!advance (&hdr_buf,\n\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n\treturn 0;\n      dir_index = read_uleb128 (&hdr_buf);\n      if (IS_ABSOLUTE_PATH (filename)\n\t  || (dir_index == 0 && u->comp_dir == NULL))\n\thdr->filenames[i] = filename;\n      else\n\t{\n\t  const char *dir;\n\t  size_t dir_len;\n\t  size_t filename_len;\n\t  char *s;\n\n\t  if (dir_index == 0)\n\t    dir = u->comp_dir;\n\t  else if (dir_index - 1 < hdr->dirs_count)\n\t    dir = hdr->dirs[dir_index - 1];\n\t  else\n\t    {\n\t      dwarf_buf_error (line_buf,\n\t\t\t       (\"invalid directory index in \"\n\t\t\t\t\"line number program header\"));\n\t      return 0;\n\t    }\n\t  dir_len = strlen (dir);\n\t  filename_len = strlen (filename);\n\t  s = ((char *)\n\t       backtrace_alloc (state, dir_len + filename_len + 2,\n\t\t\t\tline_buf->error_callback, line_buf->data));\n\t  if (s == NULL)\n\t    return 0;\n\t  memcpy (s, dir, dir_len);\n\t  /* FIXME: If we are on a DOS-based file system, and the\n\t     directory or the file name use backslashes, then we\n\t     should use a backslash here.  */\n\t  s[dir_len] = '/';\n\t  memcpy (s + dir_len + 1, filename, filename_len + 1);\n\t  hdr->filenames[i] = s;\n\t}\n\n      /* Ignore the modification time and size.  */\n      read_uleb128 (&hdr_buf);\n      read_uleb128 (&hdr_buf);\n\n      ++i;\n    }\n\n  if (hdr_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Read the line program, adding line mappings to VEC.  Return 1 on\n   success, 0 on failure.  */\n\nstatic int\nread_line_program (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t   struct unit *u, const struct line_header *hdr,\n\t\t   struct dwarf_buf *line_buf, struct line_vector *vec)\n{\n  uint64_t address;\n  unsigned int op_index;\n  const char *reset_filename;\n  const char *filename;\n  int lineno;\n\n  address = 0;\n  op_index = 0;\n  if (hdr->filenames_count > 0)\n    reset_filename = hdr->filenames[0];\n  else\n    reset_filename = \"\";\n  filename = reset_filename;\n  lineno = 1;\n  while (line_buf->left > 0)\n    {\n      unsigned int op;\n\n      op = read_byte (line_buf);\n      if (op >= hdr->opcode_base)\n\t{\n\t  unsigned int advance;\n\n\t  /* Special opcode.  */\n\t  op -= hdr->opcode_base;\n\t  advance = op / hdr->line_range;\n\t  address += (hdr->min_insn_len * (op_index + advance)\n\t\t      / hdr->max_ops_per_insn);\n\t  op_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t  lineno += hdr->line_base + (int) (op % hdr->line_range);\n\t  add_line (state, ddata, address, filename, lineno,\n\t\t    line_buf->error_callback, line_buf->data, vec);\n\t}\n      else if (op == DW_LNS_extended_op)\n\t{\n\t  uint64_t len;\n\n\t  len = read_uleb128 (line_buf);\n\t  op = read_byte (line_buf);\n\t  switch (op)\n\t    {\n\t    case DW_LNE_end_sequence:\n\t      /* FIXME: Should we mark the high PC here?  It seems\n\t\t that we already have that information from the\n\t\t compilation unit.  */\n\t      address = 0;\n\t      op_index = 0;\n\t      filename = reset_filename;\n\t      lineno = 1;\n\t      break;\n\t    case DW_LNE_set_address:\n\t      address = read_address (line_buf, u->addrsize);\n\t      break;\n\t    case DW_LNE_define_file:\n\t      {\n\t\tconst char *f;\n\t\tunsigned int dir_index;\n\n\t\tf = (const char *) line_buf->buf;\n\t\tif (!advance (line_buf, strnlen (f, line_buf->left) + 1))\n\t\t  return 0;\n\t\tdir_index = read_uleb128 (line_buf);\n\t\t/* Ignore that time and length.  */\n\t\tread_uleb128 (line_buf);\n\t\tread_uleb128 (line_buf);\n\t\tif (IS_ABSOLUTE_PATH (f))\n\t\t  filename = f;\n\t\telse\n\t\t  {\n\t\t    const char *dir;\n\t\t    size_t dir_len;\n\t\t    size_t f_len;\n\t\t    char *p;\n\n\t\t    if (dir_index == 0)\n\t\t      dir = u->comp_dir;\n\t\t    else if (dir_index - 1 < hdr->dirs_count)\n\t\t      dir = hdr->dirs[dir_index - 1];\n\t\t    else\n\t\t      {\n\t\t\tdwarf_buf_error (line_buf,\n\t\t\t\t\t (\"invalid directory index \"\n\t\t\t\t\t  \"in line number program\"));\n\t\t\treturn 0;\n\t\t      }\n\t\t    dir_len = strlen (dir);\n\t\t    f_len = strlen (f);\n\t\t    p = ((char *)\n\t\t\t backtrace_alloc (state, dir_len + f_len + 2,\n\t\t\t\t\t  line_buf->error_callback,\n\t\t\t\t\t  line_buf->data));\n\t\t    if (p == NULL)\n\t\t      return 0;\n\t\t    memcpy (p, dir, dir_len);\n\t\t    /* FIXME: If we are on a DOS-based file system,\n\t\t       and the directory or the file name use\n\t\t       backslashes, then we should use a backslash\n\t\t       here.  */\n\t\t    p[dir_len] = '/';\n\t\t    memcpy (p + dir_len + 1, f, f_len + 1);\n\t\t    filename = p;\n\t\t  }\n\t      }\n\t      break;\n\t    case DW_LNE_set_discriminator:\n\t      /* We don't care about discriminators.  */\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    default:\n\t      if (!advance (line_buf, len - 1))\n\t\treturn 0;\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  switch (op)\n\t    {\n\t    case DW_LNS_copy:\n\t      add_line (state, ddata, address, filename, lineno,\n\t\t\tline_buf->error_callback, line_buf->data, vec);\n\t      break;\n\t    case DW_LNS_advance_pc:\n\t      {\n\t\tuint64_t advance;\n\n\t\tadvance = read_uleb128 (line_buf);\n\t\taddress += (hdr->min_insn_len * (op_index + advance)\n\t\t\t    / hdr->max_ops_per_insn);\n\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t      }\n\t      break;\n\t    case DW_LNS_advance_line:\n\t      lineno += (int) read_sleb128 (line_buf);\n\t      break;\n\t    case DW_LNS_set_file:\n\t      {\n\t\tuint64_t fileno;\n\n\t\tfileno = read_uleb128 (line_buf);\n\t\tif (fileno == 0)\n\t\t  filename = \"\";\n\t\telse\n\t\t  {\n\t\t    if (fileno - 1 >= hdr->filenames_count)\n\t\t      {\n\t\t\tdwarf_buf_error (line_buf,\n\t\t\t\t\t (\"invalid file number in \"\n\t\t\t\t\t  \"line number program\"));\n\t\t\treturn 0;\n\t\t      }\n\t\t    filename = hdr->filenames[fileno - 1];\n\t\t  }\n\t      }\n\t      break;\n\t    case DW_LNS_set_column:\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    case DW_LNS_negate_stmt:\n\t      break;\n\t    case DW_LNS_set_basic_block:\n\t      break;\n\t    case DW_LNS_const_add_pc:\n\t      {\n\t\tunsigned int advance;\n\n\t\top = 255 - hdr->opcode_base;\n\t\tadvance = op / hdr->line_range;\n\t\taddress += (hdr->min_insn_len * (op_index + advance)\n\t\t\t    / hdr->max_ops_per_insn);\n\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n\t      }\n\t      break;\n\t    case DW_LNS_fixed_advance_pc:\n\t      address += read_uint16 (line_buf);\n\t      op_index = 0;\n\t      break;\n\t    case DW_LNS_set_prologue_end:\n\t      break;\n\t    case DW_LNS_set_epilogue_begin:\n\t      break;\n\t    case DW_LNS_set_isa:\n\t      read_uleb128 (line_buf);\n\t      break;\n\t    default:\n\t      {\n\t\tunsigned int i;\n\n\t\tfor (i = hdr->opcode_lengths[op - 1]; i > 0; --i)\n\t\t  read_uleb128 (line_buf);\n\t      }\n\t      break;\n\t    }\n\t}\n    }\n\n  return 1;\n}\n\n/* Read the line number information for a compilation unit.  Returns 1\n   on success, 0 on failure.  */\n\nstatic int\nread_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\tbacktrace_error_callback error_callback, void *data,\n\t\tstruct unit *u, struct line_header *hdr, struct line **lines,\n\t\tsize_t *lines_count)\n{\n  struct line_vector vec;\n  struct dwarf_buf line_buf;\n  uint64_t len;\n  int is_dwarf64;\n  struct line *ln;\n\n  memset (&vec.vec, 0, sizeof vec.vec);\n  vec.count = 0;\n\n  memset (hdr, 0, sizeof *hdr);\n\n  if (u->lineoff != (off_t) (size_t) u->lineoff\n      || (size_t) u->lineoff >= ddata->dwarf_line_size)\n    {\n      error_callback (data, \"unit line offset out of range\", 0);\n      goto fail;\n    }\n\n  line_buf.name = \".debug_line\";\n  line_buf.start = ddata->dwarf_line;\n  line_buf.buf = ddata->dwarf_line + u->lineoff;\n  line_buf.left = ddata->dwarf_line_size - u->lineoff;\n  line_buf.is_bigendian = ddata->is_bigendian;\n  line_buf.error_callback = error_callback;\n  line_buf.data = data;\n  line_buf.reported_underflow = 0;\n\n  is_dwarf64 = 0;\n  len = read_uint32 (&line_buf);\n  if (len == 0xffffffff)\n    {\n      len = read_uint64 (&line_buf);\n      is_dwarf64 = 1;\n    }\n  line_buf.left = len;\n\n  if (!read_line_header (state, u, is_dwarf64, &line_buf, hdr))\n    goto fail;\n\n  if (!read_line_program (state, ddata, u, hdr, &line_buf, &vec))\n    goto fail;\n\n  if (line_buf.reported_underflow)\n    goto fail;\n\n  if (vec.count == 0)\n    {\n      /* This is not a failure in the sense of a generating an error,\n\t but it is a failure in that sense that we have no useful\n\t information.  */\n      goto fail;\n    }\n\n  /* Allocate one extra entry at the end.  */\n  ln = ((struct line *)\n\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n\t\t\t       data, &vec.vec));\n  if (ln == NULL)\n    goto fail;\n  ln->pc = (uintptr_t) -1;\n  ln->filename = NULL;\n  ln->lineno = 0;\n  ln->idx = 0;\n\n  if (!backtrace_vector_release (state, &vec.vec, error_callback, data))\n    goto fail;\n\n  ln = (struct line *) vec.vec.base;\n  backtrace_qsort (ln, vec.count, sizeof (struct line), line_compare);\n\n  *lines = ln;\n  *lines_count = vec.count;\n\n  return 1;\n\n fail:\n  vec.vec.alc += vec.vec.size;\n  vec.vec.size = 0;\n  backtrace_vector_release (state, &vec.vec, error_callback, data);\n  free_line_header (state, hdr, error_callback, data);\n  *lines = (struct line *) (uintptr_t) -1;\n  *lines_count = 0;\n  return 0;\n}\n\n/* Read the name of a function from a DIE referenced by a\n   DW_AT_abstract_origin or DW_AT_specification tag.  OFFSET is within\n   the same compilation unit.  */\n\nstatic const char *\nread_referenced_name (struct dwarf_data *ddata, struct unit *u,\n\t\t      uint64_t offset, backtrace_error_callback error_callback,\n\t\t      void *data)\n{\n  struct dwarf_buf unit_buf;\n  uint64_t code;\n  const struct abbrev *abbrev;\n  const char *ret;\n  size_t i;\n\n  /* OFFSET is from the start of the data for this compilation unit.\n     U->unit_data is the data, but it starts U->unit_data_offset bytes\n     from the beginning.  */\n\n  if (offset < u->unit_data_offset\n      || offset - u->unit_data_offset >= u->unit_data_len)\n    {\n      error_callback (data,\n\t\t      \"abstract origin or specification out of range\",\n\t\t      0);\n      return NULL;\n    }\n\n  offset -= u->unit_data_offset;\n\n  unit_buf.name = \".debug_info\";\n  unit_buf.start = ddata->dwarf_info;\n  unit_buf.buf = u->unit_data + offset;\n  unit_buf.left = u->unit_data_len - offset;\n  unit_buf.is_bigendian = ddata->is_bigendian;\n  unit_buf.error_callback = error_callback;\n  unit_buf.data = data;\n  unit_buf.reported_underflow = 0;\n\n  code = read_uleb128 (&unit_buf);\n  if (code == 0)\n    {\n      dwarf_buf_error (&unit_buf, \"invalid abstract origin or specification\");\n      return NULL;\n    }\n\n  abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n  if (abbrev == NULL)\n    return NULL;\n\n  ret = NULL;\n  for (i = 0; i < abbrev->num_attrs; ++i)\n    {\n      struct attr_val val;\n\n      if (!read_attribute (abbrev->attrs[i].form, &unit_buf,\n\t\t\t   u->is_dwarf64, u->version, u->addrsize,\n\t\t\t   ddata->dwarf_str, ddata->dwarf_str_size,\n\t\t\t   &val))\n\treturn NULL;\n\n      switch (abbrev->attrs[i].name)\n\t{\n\tcase DW_AT_name:\n\t  /* We prefer the linkage name if get one.  */\n\t  if (val.encoding == ATTR_VAL_STRING)\n\t    ret = val.u.string;\n\t  break;\n\n\tcase DW_AT_linkage_name:\n\tcase DW_AT_MIPS_linkage_name:\n\t  if (val.encoding == ATTR_VAL_STRING)\n\t    return val.u.string;\n\t  break;\n\n\tcase DW_AT_specification:\n\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n\t    {\n\t      /* This refers to a specification defined in some other\n\t\t compilation unit.  We can handle this case if we\n\t\t must, but it's harder.  */\n\t      break;\n\t    }\n\t  if (val.encoding == ATTR_VAL_UINT\n\t      || val.encoding == ATTR_VAL_REF_UNIT)\n\t    {\n\t      const char *name;\n\n\t      name = read_referenced_name (ddata, u, val.u.uint,\n\t\t\t\t\t   error_callback, data);\n\t      if (name != NULL)\n\t\tret = name;\n\t    }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\n  return ret;\n}\n\n/* Add a single range to U that maps to function.  Returns 1 on\n   success, 0 on error.  */\n\nstatic int\nadd_function_range (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t    struct function *function, uint64_t lowpc, uint64_t highpc,\n\t\t    backtrace_error_callback error_callback,\n\t\t    void *data, struct function_vector *vec)\n{\n  struct function_addrs *p;\n\n  /* Add in the base address here, so that we can look up the PC\n     directly.  */\n  lowpc += ddata->base_address;\n  highpc += ddata->base_address;\n\n  if (vec->count > 0)\n    {\n      p = (struct function_addrs *) vec->vec.base + vec->count - 1;\n      if ((lowpc == p->high || lowpc == p->high + 1)\n\t  && function == p->function)\n\t{\n\t  if (highpc > p->high)\n\t    p->high = highpc;\n\t  return 1;\n\t}\n    }\n\n  p = ((struct function_addrs *)\n       backtrace_vector_grow (state, sizeof (struct function_addrs),\n\t\t\t      error_callback, data, &vec->vec));\n  if (p == NULL)\n    return 0;\n\n  p->low = lowpc;\n  p->high = highpc;\n  p->function = function;\n  ++vec->count;\n  return 1;\n}\n\n/* Add PC ranges to U that map to FUNCTION.  Returns 1 on success, 0\n   on error.  */\n\nstatic int\nadd_function_ranges (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t     struct unit *u, struct function *function,\n\t\t     uint64_t ranges, uint64_t base,\n\t\t     backtrace_error_callback error_callback, void *data,\n\t\t     struct function_vector *vec)\n{\n  struct dwarf_buf ranges_buf;\n\n  if (ranges >= ddata->dwarf_ranges_size)\n    {\n      error_callback (data, \"function ranges offset out of range\", 0);\n      return 0;\n    }\n\n  ranges_buf.name = \".debug_ranges\";\n  ranges_buf.start = ddata->dwarf_ranges;\n  ranges_buf.buf = ddata->dwarf_ranges + ranges;\n  ranges_buf.left = ddata->dwarf_ranges_size - ranges;\n  ranges_buf.is_bigendian = ddata->is_bigendian;\n  ranges_buf.error_callback = error_callback;\n  ranges_buf.data = data;\n  ranges_buf.reported_underflow = 0;\n\n  while (1)\n    {\n      uint64_t low;\n      uint64_t high;\n\n      if (ranges_buf.reported_underflow)\n\treturn 0;\n\n      low = read_address (&ranges_buf, u->addrsize);\n      high = read_address (&ranges_buf, u->addrsize);\n\n      if (low == 0 && high == 0)\n\tbreak;\n\n      if (is_highest_address (low, u->addrsize))\n\tbase = high;\n      else\n\t{\n\t  if (!add_function_range (state, ddata, function, low + base,\n\t\t\t\t   high + base, error_callback, data, vec))\n\t    return 0;\n\t}\n    }\n\n  if (ranges_buf.reported_underflow)\n    return 0;\n\n  return 1;\n}\n\n/* Read one entry plus all its children.  Add function addresses to\n   VEC.  Returns 1 on success, 0 on error.  */\n\nstatic int\nread_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t     struct unit *u, uint64_t base, struct dwarf_buf *unit_buf,\n\t\t     const struct line_header *lhdr,\n\t\t     backtrace_error_callback error_callback, void *data,\n\t\t     struct function_vector *vec_function,\n\t\t     struct function_vector *vec_inlined)\n{\n  while (unit_buf->left > 0)\n    {\n      uint64_t code;\n      const struct abbrev *abbrev;\n      int is_function;\n      struct function *function;\n      struct function_vector *vec;\n      size_t i;\n      uint64_t lowpc;\n      int have_lowpc;\n      uint64_t highpc;\n      int have_highpc;\n      int highpc_is_relative;\n      uint64_t ranges;\n      int have_ranges;\n\n      code = read_uleb128 (unit_buf);\n      if (code == 0)\n\treturn 1;\n\n      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n      if (abbrev == NULL)\n\treturn 0;\n\n      is_function = (abbrev->tag == DW_TAG_subprogram\n\t\t     || abbrev->tag == DW_TAG_entry_point\n\t\t     || abbrev->tag == DW_TAG_inlined_subroutine);\n\n      if (abbrev->tag == DW_TAG_inlined_subroutine)\n\tvec = vec_inlined;\n      else\n\tvec = vec_function;\n\n      function = NULL;\n      if (is_function)\n\t{\n\t  function = ((struct function *)\n\t\t      backtrace_alloc (state, sizeof *function,\n\t\t\t\t       error_callback, data));\n\t  if (function == NULL)\n\t    return 0;\n\t  memset (function, 0, sizeof *function);\n\t}\n\n      lowpc = 0;\n      have_lowpc = 0;\n      highpc = 0;\n      have_highpc = 0;\n      highpc_is_relative = 0;\n      ranges = 0;\n      have_ranges = 0;\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attr_val val;\n\n\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n\t\t\t       ddata->dwarf_str, ddata->dwarf_str_size,\n\t\t\t       &val))\n\t    return 0;\n\n\t  /* The compile unit sets the base address for any address\n\t     ranges in the function entries.  */\n\t  if (abbrev->tag == DW_TAG_compile_unit\n\t      && abbrev->attrs[i].name == DW_AT_low_pc\n\t      && val.encoding == ATTR_VAL_ADDRESS)\n\t    base = val.u.uint;\n\n\t  if (is_function)\n\t    {\n\t      switch (abbrev->attrs[i].name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  if (val.encoding == ATTR_VAL_UINT)\n\t\t    {\n\t\t      if (val.u.uint == 0)\n\t\t\tfunction->caller_filename = \"\";\n\t\t      else\n\t\t\t{\n\t\t\t  if (val.u.uint - 1 >= lhdr->filenames_count)\n\t\t\t    {\n\t\t\t      dwarf_buf_error (unit_buf,\n\t\t\t\t\t       (\"invalid file number in \"\n\t\t\t\t\t\t\"DW_AT_call_file attribute\"));\n\t\t\t      return 0;\n\t\t\t    }\n\t\t\t  function->caller_filename =\n\t\t\t    lhdr->filenames[val.u.uint - 1];\n\t\t\t}\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  if (val.encoding == ATTR_VAL_UINT)\n\t\t    function->caller_lineno = val.u.uint;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n\t\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n\t\t    {\n\t\t      /* This refers to an abstract origin defined in\n\t\t\t some other compilation unit.  We can handle\n\t\t\t this case if we must, but it's harder.  */\n\t\t      break;\n\t\t    }\n\t\t  if (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_UNIT)\n\t\t    {\n\t\t      const char *name;\n\n\t\t      name = read_referenced_name (ddata, u, val.u.uint,\n\t\t\t\t\t\t   error_callback, data);\n\t\t      if (name != NULL)\n\t\t\tfunction->name = name;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  if (val.encoding == ATTR_VAL_STRING)\n\t\t    {\n\t\t      /* Don't override a name we found in some other\n\t\t\t way, as it will normally be more\n\t\t\t useful--e.g., this name is normally not\n\t\t\t mangled.  */\n\t\t      if (function->name == NULL)\n\t\t\tfunction->name = val.u.string;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  if (val.encoding == ATTR_VAL_STRING)\n\t\t    function->name = val.u.string;\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t    {\n\t\t      lowpc = val.u.uint;\n\t\t      have_lowpc = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n\t\t    {\n\t\t      highpc = val.u.uint;\n\t\t      have_highpc = 1;\n\t\t    }\n\t\t  else if (val.encoding == ATTR_VAL_UINT)\n\t\t    {\n\t\t      highpc = val.u.uint;\n\t\t      have_highpc = 1;\n\t\t      highpc_is_relative = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (val.encoding == ATTR_VAL_UINT\n\t\t      || val.encoding == ATTR_VAL_REF_SECTION)\n\t\t    {\n\t\t      ranges = val.u.uint;\n\t\t      have_ranges = 1;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      /* If we couldn't find a name for the function, we have no use\n\t for it.  */\n      if (is_function && function->name == NULL)\n\t{\n\t  backtrace_free (state, function, sizeof *function,\n\t\t\t  error_callback, data);\n\t  is_function = 0;\n\t}\n\n      if (is_function)\n\t{\n\t  if (have_ranges)\n\t    {\n\t      if (!add_function_ranges (state, ddata, u, function, ranges,\n\t\t\t\t\tbase, error_callback, data, vec))\n\t\treturn 0;\n\t    }\n\t  else if (have_lowpc && have_highpc)\n\t    {\n\t      if (highpc_is_relative)\n\t\thighpc += lowpc;\n\t      if (!add_function_range (state, ddata, function, lowpc, highpc,\n\t\t\t\t       error_callback, data, vec))\n\t\treturn 0;\n\t    }\n\t  else\n\t    {\n\t      backtrace_free (state, function, sizeof *function,\n\t\t\t      error_callback, data);\n\t      is_function = 0;\n\t    }\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  if (!is_function)\n\t    {\n\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n\t\t\t\t\terror_callback, data, vec_function,\n\t\t\t\t\tvec_inlined))\n\t\treturn 0;\n\t    }\n\t  else\n\t    {\n\t      struct function_vector fvec;\n\n\t      /* Gather any information for inlined functions in\n\t\t FVEC.  */\n\n\t      memset (&fvec, 0, sizeof fvec);\n\n\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n\t\t\t\t\terror_callback, data, vec_function,\n\t\t\t\t\t&fvec))\n\t\treturn 0;\n\n\t      if (fvec.count > 0)\n\t\t{\n\t\t  struct function_addrs *faddrs;\n\n\t\t  if (!backtrace_vector_release (state, &fvec.vec,\n\t\t\t\t\t\t error_callback, data))\n\t\t    return 0;\n\n\t\t  faddrs = (struct function_addrs *) fvec.vec.base;\n\t\t  backtrace_qsort (faddrs, fvec.count,\n\t\t\t\t   sizeof (struct function_addrs),\n\t\t\t\t   function_addrs_compare);\n\n\t\t  function->function_addrs = faddrs;\n\t\t  function->function_addrs_count = fvec.count;\n\t\t}\n\t    }\n\t}\n    }\n\n  return 1;\n}\n\n/* Read function name information for a compilation unit.  We look\n   through the whole unit looking for function tags.  */\n\nstatic void\nread_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t    const struct line_header *lhdr,\n\t\t    backtrace_error_callback error_callback, void *data,\n\t\t    struct unit *u, struct function_vector *fvec,\n\t\t    struct function_addrs **ret_addrs,\n\t\t    size_t *ret_addrs_count)\n{\n  struct function_vector lvec;\n  struct function_vector *pfvec;\n  struct dwarf_buf unit_buf;\n  struct function_addrs *addrs;\n  size_t addrs_count;\n\n  /* Use FVEC if it is not NULL.  Otherwise use our own vector.  */\n  if (fvec != NULL)\n    pfvec = fvec;\n  else\n    {\n      memset (&lvec, 0, sizeof lvec);\n      pfvec = &lvec;\n    }\n\n  unit_buf.name = \".debug_info\";\n  unit_buf.start = ddata->dwarf_info;\n  unit_buf.buf = u->unit_data;\n  unit_buf.left = u->unit_data_len;\n  unit_buf.is_bigendian = ddata->is_bigendian;\n  unit_buf.error_callback = error_callback;\n  unit_buf.data = data;\n  unit_buf.reported_underflow = 0;\n\n  while (unit_buf.left > 0)\n    {\n      if (!read_function_entry (state, ddata, u, 0, &unit_buf, lhdr,\n\t\t\t\terror_callback, data, pfvec, pfvec))\n\treturn;\n    }\n\n  if (pfvec->count == 0)\n    return;\n\n  addrs_count = pfvec->count;\n\n  if (fvec == NULL)\n    {\n      if (!backtrace_vector_release (state, &lvec.vec, error_callback, data))\n\treturn;\n      addrs = (struct function_addrs *) pfvec->vec.base;\n    }\n  else\n    {\n      /* Finish this list of addresses, but leave the remaining space in\n\t the vector available for the next function unit.  */\n      addrs = ((struct function_addrs *)\n\t       backtrace_vector_finish (state, &fvec->vec,\n\t\t\t\t\terror_callback, data));\n      if (addrs == NULL)\n\treturn;\n      fvec->count = 0;\n    }\n\n  backtrace_qsort (addrs, addrs_count, sizeof (struct function_addrs),\n\t\t   function_addrs_compare);\n\n  *ret_addrs = addrs;\n  *ret_addrs_count = addrs_count;\n}\n\n/* See if PC is inlined in FUNCTION.  If it is, print out the inlined\n   information, and update FILENAME and LINENO for the caller.\n   Returns whatever CALLBACK returns, or 0 to keep going.  */\n\nstatic int\nreport_inlined_functions (uintptr_t pc, struct function *function,\n\t\t\t  backtrace_full_callback callback, void *data,\n\t\t\t  const char **filename, int *lineno)\n{\n  struct function_addrs *function_addrs;\n  struct function *inlined;\n  int ret;\n\n  if (function->function_addrs_count == 0)\n    return 0;\n\n  function_addrs = ((struct function_addrs *)\n\t\t    bsearch (&pc, function->function_addrs,\n\t\t\t     function->function_addrs_count,\n\t\t\t     sizeof (struct function_addrs),\n\t\t\t     function_addrs_search));\n  if (function_addrs == NULL)\n    return 0;\n\n  while (((size_t) (function_addrs - function->function_addrs) + 1\n\t  < function->function_addrs_count)\n\t && pc >= (function_addrs + 1)->low\n\t && pc < (function_addrs + 1)->high)\n    ++function_addrs;\n\n  /* We found an inlined call.  */\n\n  inlined = function_addrs->function;\n\n  /* Report any calls inlined into this one.  */\n  ret = report_inlined_functions (pc, inlined, callback, data,\n\t\t\t\t  filename, lineno);\n  if (ret != 0)\n    return ret;\n\n  /* Report this inlined call.  */\n  ret = callback (data, pc, *filename, *lineno, inlined->name);\n  if (ret != 0)\n    return ret;\n\n  /* Our caller will report the caller of the inlined function; tell\n     it the appropriate filename and line number.  */\n  *filename = inlined->caller_filename;\n  *lineno = inlined->caller_lineno;\n\n  return 0;\n}\n\n/* Look for a PC in the DWARF mapping for one module.  On success,\n   call CALLBACK and return whatever it returns.  On error, call\n   ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n   0 if not.  */\n\nstatic int\ndwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n\t\t uintptr_t pc, backtrace_full_callback callback,\n\t\t backtrace_error_callback error_callback, void *data,\n\t\t int *found)\n{\n  struct unit_addrs *entry;\n  struct unit *u;\n  int new_data;\n  struct line *lines;\n  struct line *ln;\n  struct function_addrs *function_addrs;\n  struct function *function;\n  const char *filename;\n  int lineno;\n  int ret;\n\n  *found = 1;\n\n  /* Find an address range that includes PC.  */\n  entry = bsearch (&pc, ddata->addrs, ddata->addrs_count,\n\t\t   sizeof (struct unit_addrs), unit_addrs_search);\n\n  if (entry == NULL)\n    {\n      *found = 0;\n      return 0;\n    }\n\n  /* If there are multiple ranges that contain PC, use the last one,\n     in order to produce predictable results.  If we assume that all\n     ranges are properly nested, then the last range will be the\n     smallest one.  */\n  while ((size_t) (entry - ddata->addrs) + 1 < ddata->addrs_count\n\t && pc >= (entry + 1)->low\n\t && pc < (entry + 1)->high)\n    ++entry;\n\n  /* We need the lines, lines_count, function_addrs,\n     function_addrs_count fields of u.  If they are not set, we need\n     to set them.  When running in threaded mode, we need to allow for\n     the possibility that some other thread is setting them\n     simultaneously.  */\n\n  u = entry->u;\n  lines = u->lines;\n\n  /* Skip units with no useful line number information by walking\n     backward.  Useless line number information is marked by setting\n     lines == -1.  */\n  while (entry > ddata->addrs\n\t && pc >= (entry - 1)->low\n\t && pc < (entry - 1)->high)\n    {\n      if (state->threaded)\n\tlines = (struct line *) backtrace_atomic_load_pointer (&u->lines);\n\n      if (lines != (struct line *) (uintptr_t) -1)\n\tbreak;\n\n      --entry;\n\n      u = entry->u;\n      lines = u->lines;\n    }\n\n  if (state->threaded)\n    lines = backtrace_atomic_load_pointer (&u->lines);\n\n  new_data = 0;\n  if (lines == NULL)\n    {\n      size_t function_addrs_count;\n      struct line_header lhdr;\n      size_t count;\n\n      /* We have never read the line information for this unit.  Read\n\t it now.  */\n\n      function_addrs = NULL;\n      function_addrs_count = 0;\n      if (read_line_info (state, ddata, error_callback, data, entry->u, &lhdr,\n\t\t\t  &lines, &count))\n\t{\n\t  struct function_vector *pfvec;\n\n\t  /* If not threaded, reuse DDATA->FVEC for better memory\n\t     consumption.  */\n\t  if (state->threaded)\n\t    pfvec = NULL;\n\t  else\n\t    pfvec = &ddata->fvec;\n\t  read_function_info (state, ddata, &lhdr, error_callback, data,\n\t\t\t      entry->u, pfvec, &function_addrs,\n\t\t\t      &function_addrs_count);\n\t  free_line_header (state, &lhdr, error_callback, data);\n\t  new_data = 1;\n\t}\n\n      /* Atomically store the information we just read into the unit.\n\t If another thread is simultaneously writing, it presumably\n\t read the same information, and we don't care which one we\n\t wind up with; we just leak the other one.  We do have to\n\t write the lines field last, so that the acquire-loads above\n\t ensure that the other fields are set.  */\n\n      if (!state->threaded)\n\t{\n\t  u->lines_count = count;\n\t  u->function_addrs = function_addrs;\n\t  u->function_addrs_count = function_addrs_count;\n\t  u->lines = lines;\n\t}\n      else\n\t{\n\t  backtrace_atomic_store_size_t (&u->lines_count, count);\n\t  backtrace_atomic_store_pointer (&u->function_addrs, function_addrs);\n\t  backtrace_atomic_store_size_t (&u->function_addrs_count,\n\t\t\t\t\t function_addrs_count);\n\t  backtrace_atomic_store_pointer (&u->lines, lines);\n\t}\n    }\n\n  /* Now all fields of U have been initialized.  */\n\n  if (lines == (struct line *) (uintptr_t) -1)\n    {\n      /* If reading the line number information failed in some way,\n\t try again to see if there is a better compilation unit for\n\t this PC.  */\n      if (new_data)\n\treturn dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\tdata, found);\n      return callback (data, pc, NULL, 0, NULL);\n    }\n\n  /* Search for PC within this unit.  */\n\n  ln = (struct line *) bsearch (&pc, lines, entry->u->lines_count,\n\t\t\t\tsizeof (struct line), line_search);\n  if (ln == NULL)\n    {\n      /* The PC is between the low_pc and high_pc attributes of the\n\t compilation unit, but no entry in the line table covers it.\n\t This implies that the start of the compilation unit has no\n\t line number information.  */\n\n      if (entry->u->abs_filename == NULL)\n\t{\n\t  const char *filename;\n\n\t  filename = entry->u->filename;\n\t  if (filename != NULL\n\t      && !IS_ABSOLUTE_PATH (filename)\n\t      && entry->u->comp_dir != NULL)\n\t    {\n\t      size_t filename_len;\n\t      const char *dir;\n\t      size_t dir_len;\n\t      char *s;\n\n\t      filename_len = strlen (filename);\n\t      dir = entry->u->comp_dir;\n\t      dir_len = strlen (dir);\n\t      s = (char *) backtrace_alloc (state, dir_len + filename_len + 2,\n\t\t\t\t\t    error_callback, data);\n\t      if (s == NULL)\n\t\t{\n\t\t  *found = 0;\n\t\t  return 0;\n\t\t}\n\t      memcpy (s, dir, dir_len);\n\t      /* FIXME: Should use backslash if DOS file system.  */\n\t      s[dir_len] = '/';\n\t      memcpy (s + dir_len + 1, filename, filename_len + 1);\n\t      filename = s;\n\t    }\n\t  entry->u->abs_filename = filename;\n\t}\n\n      return callback (data, pc, entry->u->abs_filename, 0, NULL);\n    }\n\n  /* Search for function name within this unit.  */\n\n  if (entry->u->function_addrs_count == 0)\n    return callback (data, pc, ln->filename, ln->lineno, NULL);\n\n  function_addrs = ((struct function_addrs *)\n\t\t    bsearch (&pc, entry->u->function_addrs,\n\t\t\t     entry->u->function_addrs_count,\n\t\t\t     sizeof (struct function_addrs),\n\t\t\t     function_addrs_search));\n  if (function_addrs == NULL)\n    return callback (data, pc, ln->filename, ln->lineno, NULL);\n\n  /* If there are multiple function ranges that contain PC, use the\n     last one, in order to produce predictable results.  */\n\n  while (((size_t) (function_addrs - entry->u->function_addrs + 1)\n\t  < entry->u->function_addrs_count)\n\t && pc >= (function_addrs + 1)->low\n\t && pc < (function_addrs + 1)->high)\n    ++function_addrs;\n\n  function = function_addrs->function;\n\n  filename = ln->filename;\n  lineno = ln->lineno;\n\n  ret = report_inlined_functions (pc, function, callback, data,\n\t\t\t\t  &filename, &lineno);\n  if (ret != 0)\n    return ret;\n\n  return callback (data, pc, filename, lineno, function->name);\n}\n\n\n/* Return the file/line information for a PC using the DWARF mapping\n   we built earlier.  */\n\nstatic int\ndwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n\t\tbacktrace_full_callback callback,\n\t\tbacktrace_error_callback error_callback, void *data)\n{\n  struct dwarf_data *ddata;\n  int found;\n  int ret;\n\n  if (!state->threaded)\n    {\n      for (ddata = (struct dwarf_data *) state->fileline_data;\n\t   ddata != NULL;\n\t   ddata = ddata->next)\n\t{\n\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\t data, &found);\n\t  if (ret != 0 || found)\n\t    return ret;\n\t}\n    }\n  else\n    {\n      struct dwarf_data **pp;\n\n      pp = (struct dwarf_data **) (void *) &state->fileline_data;\n      while (1)\n\t{\n\t  ddata = backtrace_atomic_load_pointer (pp);\n\t  if (ddata == NULL)\n\t    break;\n\n\t  ret = dwarf_lookup_pc (state, ddata, pc, callback, error_callback,\n\t\t\t\t data, &found);\n\t  if (ret != 0 || found)\n\t    return ret;\n\n\t  pp = &ddata->next;\n\t}\n    }\n\n  /* FIXME: See if any libraries have been dlopen'ed.  */\n\n  return callback (data, pc, NULL, 0, NULL);\n}\n\n/* Initialize our data structures from the DWARF debug info for a\n   file.  Return NULL on failure.  */\n\nstatic struct dwarf_data *\nbuild_dwarf_data (struct backtrace_state *state,\n\t\t  uintptr_t base_address,\n\t\t  const unsigned char *dwarf_info,\n\t\t  size_t dwarf_info_size,\n\t\t  const unsigned char *dwarf_line,\n\t\t  size_t dwarf_line_size,\n\t\t  const unsigned char *dwarf_abbrev,\n\t\t  size_t dwarf_abbrev_size,\n\t\t  const unsigned char *dwarf_ranges,\n\t\t  size_t dwarf_ranges_size,\n\t\t  const unsigned char *dwarf_str,\n\t\t  size_t dwarf_str_size,\n\t\t  int is_bigendian,\n\t\t  backtrace_error_callback error_callback,\n\t\t  void *data)\n{\n  struct unit_addrs_vector addrs_vec;\n  struct unit_addrs *addrs;\n  size_t addrs_count;\n  struct dwarf_data *fdata;\n\n  if (!build_address_map (state, base_address, dwarf_info, dwarf_info_size,\n\t\t\t  dwarf_abbrev, dwarf_abbrev_size, dwarf_ranges,\n\t\t\t  dwarf_ranges_size, dwarf_str, dwarf_str_size,\n\t\t\t  is_bigendian, error_callback, data, &addrs_vec))\n    return NULL;\n\n  if (!backtrace_vector_release (state, &addrs_vec.vec, error_callback, data))\n    return NULL;\n  addrs = (struct unit_addrs *) addrs_vec.vec.base;\n  addrs_count = addrs_vec.count;\n  backtrace_qsort (addrs, addrs_count, sizeof (struct unit_addrs),\n\t\t   unit_addrs_compare);\n\n  fdata = ((struct dwarf_data *)\n\t   backtrace_alloc (state, sizeof (struct dwarf_data),\n\t\t\t    error_callback, data));\n  if (fdata == NULL)\n    return NULL;\n\n  fdata->next = NULL;\n  fdata->base_address = base_address;\n  fdata->addrs = addrs;\n  fdata->addrs_count = addrs_count;\n  fdata->dwarf_info = dwarf_info;\n  fdata->dwarf_info_size = dwarf_info_size;\n  fdata->dwarf_line = dwarf_line;\n  fdata->dwarf_line_size = dwarf_line_size;\n  fdata->dwarf_ranges = dwarf_ranges;\n  fdata->dwarf_ranges_size = dwarf_ranges_size;\n  fdata->dwarf_str = dwarf_str;\n  fdata->dwarf_str_size = dwarf_str_size;\n  fdata->is_bigendian = is_bigendian;\n  memset (&fdata->fvec, 0, sizeof fdata->fvec);\n\n  return fdata;\n}\n\n/* Build our data structures from the DWARF sections for a module.\n   Set FILELINE_FN and STATE->FILELINE_DATA.  Return 1 on success, 0\n   on failure.  */\n\nint\nbacktrace_dwarf_add (struct backtrace_state *state,\n\t\t     uintptr_t base_address,\n\t\t     const unsigned char *dwarf_info,\n\t\t     size_t dwarf_info_size,\n\t\t     const unsigned char *dwarf_line,\n\t\t     size_t dwarf_line_size,\n\t\t     const unsigned char *dwarf_abbrev,\n\t\t     size_t dwarf_abbrev_size,\n\t\t     const unsigned char *dwarf_ranges,\n\t\t     size_t dwarf_ranges_size,\n\t\t     const unsigned char *dwarf_str,\n\t\t     size_t dwarf_str_size,\n\t\t     int is_bigendian,\n\t\t     backtrace_error_callback error_callback,\n\t\t     void *data, fileline *fileline_fn)\n{\n  struct dwarf_data *fdata;\n\n  fdata = build_dwarf_data (state, base_address, dwarf_info, dwarf_info_size,\n\t\t\t    dwarf_line, dwarf_line_size, dwarf_abbrev,\n\t\t\t    dwarf_abbrev_size, dwarf_ranges, dwarf_ranges_size,\n\t\t\t    dwarf_str, dwarf_str_size, is_bigendian,\n\t\t\t    error_callback, data);\n  if (fdata == NULL)\n    return 0;\n\n  if (!state->threaded)\n    {\n      struct dwarf_data **pp;\n\n      for (pp = (struct dwarf_data **) (void *) &state->fileline_data;\n\t   *pp != NULL;\n\t   pp = &(*pp)->next)\n\t;\n      *pp = fdata;\n    }\n  else\n    {\n      while (1)\n\t{\n\t  struct dwarf_data **pp;\n\n\t  pp = (struct dwarf_data **) (void *) &state->fileline_data;\n\n\t  while (1)\n\t    {\n\t      struct dwarf_data *p;\n\n\t      p = backtrace_atomic_load_pointer (pp);\n\n\t      if (p == NULL)\n\t\tbreak;\n\n\t      pp = &p->next;\n\t    }\n\n\t  if (__sync_bool_compare_and_swap (pp, NULL, fdata))\n\t    break;\n\t}\n    }\n\n  *fileline_fn = dwarf_fileline;\n\n  return 1;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-canu-2.0-lqlrtjwlx7fqgtmnipssdlmjbv7lvc6j/spack-src/src/mhap/mhap-2.1.3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-canu-2.0-lqlrtjwlx7fqgtmnipssdlmjbv7lvc6j/spack-src/src/utgcns/libboost/boost/format/alt_sstream_impl.hpp"
    ],
    "total_files": 1438
}