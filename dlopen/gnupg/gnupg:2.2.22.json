{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/configure.ac": "# configure.ac - for GnuPG 2.2\n# Copyright (C) 1998-2019 Free Software Foundation, Inc.\n# Copyright (C) 1998-2019 Werner Koch\n# Copyright (C) 2003-2020 g10 Code GmbH\n#\n# This file is part of GnuPG.\n#\n# GnuPG is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License, or\n# (at your option) any later version.\n#\n# GnuPG is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n\n# Process this file with autoconf to produce a configure script.\nAC_PREREQ(2.61)\nmin_automake_version=\"1.14\"\n\n# To build a release you need to create a tag with the version number\n# (git tag -s gnupg-2.n.m) and run \"./autogen.sh --force\".  Please\n# bump the version number immediately *after* the release and do\n# another commit and push so that the git magic is able to work.\nm4_define([mym4_package],[gnupg])\nm4_define([mym4_major], [2])\nm4_define([mym4_minor], [2])\nm4_define([mym4_micro], [22])\n\n# To start a new development series, i.e a new major or minor number\n# you need to mark an arbitrary commit before the first beta release\n# with an annotated tag.  For example the 2.1 branch starts off with\n# the tag \"gnupg-2.1-base\".  This is used as the base for counting\n# beta numbers before the first release of a series.\n\n# Below is m4 magic to extract and compute the git revision number,\n# the decimalized short revision number, a beta version string and a\n# flag indicating a development version (mym4_isbeta).  Note that the\n# m4 processing is done by autoconf and not during the configure run.\nm4_define([mym4_verslist], m4_split(m4_esyscmd([./autogen.sh --find-version] \\\n                           mym4_package mym4_major mym4_minor mym4_micro),[:]))\nm4_define([mym4_isbeta],       m4_argn(2, mym4_verslist))\nm4_define([mym4_version],      m4_argn(4, mym4_verslist))\nm4_define([mym4_revision],     m4_argn(7, mym4_verslist))\nm4_define([mym4_revision_dec], m4_argn(8, mym4_verslist))\nm4_esyscmd([echo ]mym4_version[>VERSION])\nAC_INIT([mym4_package],[mym4_version], [https://bugs.gnupg.org])\n\n# When changing the SWDB tag please also adjust the hard coded tags in\n# build-aux/speedo.mk and Makefile.am\nAC_DEFINE_UNQUOTED(GNUPG_SWDB_TAG, \"gnupg22\", [swdb tag for this branch])\n\nNEED_GPG_ERROR_VERSION=1.25\n\nNEED_LIBGCRYPT_API=1\nNEED_LIBGCRYPT_VERSION=1.7.0\n\nNEED_LIBASSUAN_API=2\nNEED_LIBASSUAN_VERSION=2.5.0\n\nNEED_KSBA_API=1\nNEED_KSBA_VERSION=1.3.4\n\nNEED_NTBTLS_API=1\nNEED_NTBTLS_VERSION=0.1.0\n\nNEED_NPTH_API=1\nNEED_NPTH_VERSION=1.2\n\n\nNEED_GNUTLS_VERSION=3.0\n\nNEED_SQLITE_VERSION=3.7\n\ndevelopment_version=mym4_isbeta\nPACKAGE=$PACKAGE_NAME\nPACKAGE_GT=${PACKAGE_NAME}2\nVERSION=$PACKAGE_VERSION\n\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_SRCDIR([sm/gpgsm.c])\nAC_CONFIG_HEADER([config.h])\nAM_INIT_AUTOMAKE([serial-tests dist-bzip2 no-dist-gzip])\nAC_CANONICAL_HOST\nAB_INIT\n\nAC_GNU_SOURCE\n\n\n# Some status variables.\nhave_gpg_error=no\nhave_libgcrypt=no\nhave_libassuan=no\nhave_ksba=no\nhave_ntbtls=no\nhave_gnutls=no\nhave_sqlite=no\nhave_npth=no\nhave_libusb=no\nhave_system_resolver=no\ngnupg_have_ldap=\"n/a\"\n\nuse_zip=yes\nuse_bzip2=yes\nuse_exec=yes\nuse_trust_models=yes\nuse_tofu=yes\nuse_libdns=yes\ncard_support=yes\nuse_ccid_driver=auto\ndirmngr_auto_start=yes\nuse_tls_library=no\nlarge_secmem=no\nshow_tor_support=no\n\nGNUPG_BUILD_PROGRAM(gpg, yes)\nGNUPG_BUILD_PROGRAM(gpgsm, yes)\n# The agent is a required part and can't be disabled anymore.\nbuild_agent=yes\nGNUPG_BUILD_PROGRAM(scdaemon, yes)\nGNUPG_BUILD_PROGRAM(g13, no)\nGNUPG_BUILD_PROGRAM(dirmngr, yes)\nGNUPG_BUILD_PROGRAM(doc, yes)\nGNUPG_BUILD_PROGRAM(symcryptrun, no)\n# We use gpgtar to unpack test data, hence we always build it.  If the\n# user opts out, we simply don't install it.\nGNUPG_BUILD_PROGRAM(gpgtar, yes)\n# We also install the gpg-wks-server tool by default but disable it\n# later for platforms where it can't be build.\nGNUPG_BUILD_PROGRAM(wks-tools, yes)\n\n\nAC_SUBST(PACKAGE)\nAC_SUBST(PACKAGE_GT)\nAC_SUBST(VERSION)\nAC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of this package])\nAC_DEFINE_UNQUOTED(PACKAGE_GT, \"$PACKAGE_GT\",\n                                [Name of this package for gettext])\nAC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version of this package])\nAC_DEFINE_UNQUOTED(PACKAGE_BUGREPORT, \"$PACKAGE_BUGREPORT\",\n                                        [Bug report address])\nAC_DEFINE_UNQUOTED(NEED_LIBGCRYPT_VERSION, \"$NEED_LIBGCRYPT_VERSION\",\n                                       [Required version of Libgcrypt])\nAC_DEFINE_UNQUOTED(NEED_KSBA_VERSION, \"$NEED_KSBA_VERSION\",\n                                       [Required version of Libksba])\nAC_DEFINE_UNQUOTED(NEED_NTBTLS_VERSION, \"$NEED_NTBTLS_VERSION\",\n                                       [Required version of NTBTLS])\n\n\n\n# The default is to use the modules from this package and the few\n# other packages in a standard place; i.e where this package gets\n# installed.  With these options it is possible to override these\n# ${prefix} depended values with fixed paths, which can't be replaced\n# at make time.  See also am/cmacros.am and the defaults in AH_BOTTOM.\nAC_ARG_WITH(agent-pgm,\n    [  --with-agent-pgm=PATH  Use PATH as the default for the agent)],\n          GNUPG_AGENT_PGM=\"$withval\", GNUPG_AGENT_PGM=\"\" )\nAC_SUBST(GNUPG_AGENT_PGM)\nAM_CONDITIONAL(GNUPG_AGENT_PGM, test -n \"$GNUPG_AGENT_PGM\")\nshow_gnupg_agent_pgm=\"(default)\"\ntest -n \"$GNUPG_AGENT_PGM\" && show_gnupg_agent_pgm=\"$GNUPG_AGENT_PGM\"\n\nAC_ARG_WITH(pinentry-pgm,\n    [  --with-pinentry-pgm=PATH  Use PATH as the default for the pinentry)],\n          GNUPG_PINENTRY_PGM=\"$withval\", GNUPG_PINENTRY_PGM=\"\" )\nAC_SUBST(GNUPG_PINENTRY_PGM)\nAM_CONDITIONAL(GNUPG_PINENTRY_PGM, test -n \"$GNUPG_PINENTRY_PGM\")\nshow_gnupg_pinentry_pgm=\"(default)\"\ntest -n \"$GNUPG_PINENTRY_PGM\" && show_gnupg_pinentry_pgm=\"$GNUPG_PINENTRY_PGM\"\n\n\nAC_ARG_WITH(scdaemon-pgm,\n    [  --with-scdaemon-pgm=PATH  Use PATH as the default for the scdaemon)],\n          GNUPG_SCDAEMON_PGM=\"$withval\", GNUPG_SCDAEMON_PGM=\"\" )\nAC_SUBST(GNUPG_SCDAEMON_PGM)\nAM_CONDITIONAL(GNUPG_SCDAEMON_PGM, test -n \"$GNUPG_SCDAEMON_PGM\")\nshow_gnupg_scdaemon_pgm=\"(default)\"\ntest -n \"$GNUPG_SCDAEMON_PGM\" && show_gnupg_scdaemon_pgm=\"$GNUPG_SCDAEMON_PGM\"\n\n\nAC_ARG_WITH(dirmngr-pgm,\n    [  --with-dirmngr-pgm=PATH  Use PATH as the default for the dirmngr)],\n          GNUPG_DIRMNGR_PGM=\"$withval\", GNUPG_DIRMNGR_PGM=\"\" )\nAC_SUBST(GNUPG_DIRMNGR_PGM)\nAM_CONDITIONAL(GNUPG_DIRMNGR_PGM, test -n \"$GNUPG_DIRMNGR_PGM\")\nshow_gnupg_dirmngr_pgm=\"(default)\"\ntest -n \"$GNUPG_DIRMNGR_PGM\" && show_gnupg_dirmngr_pgm=\"$GNUPG_DIRMNGR_PGM\"\n\nAC_ARG_WITH(protect-tool-pgm,\n    [  --with-protect-tool-pgm=PATH  Use PATH as the default for the protect-tool)],\n          GNUPG_PROTECT_TOOL_PGM=\"$withval\", GNUPG_PROTECT_TOOL_PGM=\"\" )\nAC_SUBST(GNUPG_PROTECT_TOOL_PGM)\nAM_CONDITIONAL(GNUPG_PROTECT_TOOL_PGM, test -n \"$GNUPG_PROTECT_TOOL_PGM\")\nshow_gnupg_protect_tool_pgm=\"(default)\"\ntest -n \"$GNUPG_PROTECT_TOOL_PGM\" \\\n      && show_gnupg_protect_tool_pgm=\"$GNUPG_PROTECT_TOOL_PGM\"\n\nAC_ARG_WITH(dirmngr-ldap-pgm,\n    [  --with-dirmngr-ldap-pgm=PATH  Use PATH as the default for the dirmngr ldap wrapper)],\n          GNUPG_DIRMNGR_LDAP_PGM=\"$withval\", GNUPG_DIRMNGR_LDAP_PGM=\"\" )\nAC_SUBST(GNUPG_DIRMNGR_LDAP_PGM)\nAM_CONDITIONAL(GNUPG_DIRMNGR_LDAP_PGM, test -n \"$GNUPG_DIRMNGR_LDAP_PGM\")\nshow_gnupg_dirmngr_ldap_pgm=\"(default)\"\ntest -n \"$GNUPG_DIRMNGR_LDAP_PGM\" \\\n      && show_gnupg_dirmngr_ldap_pgm=\"$GNUPG_DIRMNGR_LDAP_PGM\"\n\n\n#\n# For a long time gpg 2.x was installed as gpg2.  This changed with\n# 2.2.  This option can be used to install gpg under the name gpg2.\n#\nAC_ARG_ENABLE(gpg-is-gpg2,\n    AC_HELP_STRING([--enable-gpg-is-gpg2],[Set installed name of gpg to gpg2]),\n    gpg_is_gpg2=$enableval)\nif test \"$gpg_is_gpg2\" = \"yes\"; then\n   AC_DEFINE(USE_GPG2_HACK, 1, [Define to install gpg as gpg2])\nfi\nAM_CONDITIONAL(USE_GPG2_HACK, test \"$gpg_is_gpg2\" = \"yes\")\n\n\n# SELinux support includes tracking of sensitive files to avoid\n# leaking their contents through processing these files by gpg itself\nAC_MSG_CHECKING([whether SELinux support is requested])\nAC_ARG_ENABLE(selinux-support,\n              AC_HELP_STRING([--enable-selinux-support],\n                             [enable SELinux support]),\n              selinux_support=$enableval, selinux_support=no)\nAC_MSG_RESULT($selinux_support)\n\n\nAC_MSG_CHECKING([whether to allocate extra secure memory])\nAC_ARG_ENABLE(large-secmem,\n              AC_HELP_STRING([--enable-large-secmem],\n                             [allocate extra secure memory]),\n              large_secmem=$enableval, large_secmem=no)\nAC_MSG_RESULT($large_secmem)\nif test \"$large_secmem\" = yes ; then\n   SECMEM_BUFFER_SIZE=65536\nelse\n   SECMEM_BUFFER_SIZE=32768\nfi\nAC_DEFINE_UNQUOTED(SECMEM_BUFFER_SIZE,$SECMEM_BUFFER_SIZE,\n                   [Size of secure memory buffer])\n\nAC_MSG_CHECKING([calibrated passphrase-stretching (s2k) duration])\nAC_ARG_WITH(agent-s2k-calibration,\n              AC_HELP_STRING([--with-agent-s2k-calibration=MSEC],\n                             [calibrate passphrase stretching (s2k) to MSEC milliseconds]),\n              agent_s2k_calibration=$withval, agent_s2k_calibration=100)\nAC_MSG_RESULT($agent_s2k_calibration milliseconds)\nAC_DEFINE_UNQUOTED(AGENT_S2K_CALIBRATION, $agent_s2k_calibration,\n                   [Agent s2k calibration time (ms)])\n\nAC_MSG_CHECKING([whether to enable trust models])\nAC_ARG_ENABLE(trust-models,\n              AC_HELP_STRING([--disable-trust-models],\n                             [disable all trust models except \"always\"]),\n              use_trust_models=$enableval)\nAC_MSG_RESULT($use_trust_models)\nif test \"$use_trust_models\" = no ; then\n    AC_DEFINE(NO_TRUST_MODELS, 1,\n             [Define to include only trust-model always])\nfi\n\nAC_MSG_CHECKING([whether to enable TOFU])\nAC_ARG_ENABLE(tofu,\n                AC_HELP_STRING([--disable-tofu],\n                               [disable the TOFU trust model]),\n              use_tofu=$enableval, use_tofu=$use_trust_models)\nAC_MSG_RESULT($use_tofu)\nif test \"$use_trust_models\" = no && test \"$use_tofu\" = yes; then\n    AC_MSG_ERROR([both --disable-trust-models and --enable-tofu given])\nfi\n\nAC_MSG_CHECKING([whether to enable libdns])\nAC_ARG_ENABLE(libdns,\n                AC_HELP_STRING([--disable-libdns],\n                               [do not build with libdns support]),\n              use_libdns=$enableval, use_libdns=yes)\nAC_MSG_RESULT($use_libdns)\nif test x\"$use_libdns\" = xyes ; then\n    AC_DEFINE(USE_LIBDNS, 1, [Build with integrated libdns support])\nfi\nAM_CONDITIONAL(USE_LIBDNS, test \"$use_libdns\" = yes)\n\n\n#\n# Options to disable algorithm\n#\n\nGNUPG_GPG_DISABLE_ALGO([rsa],[RSA public key])\n# Elgamal is a MUST algorithm\n# DSA is a MUST algorithm\nGNUPG_GPG_DISABLE_ALGO([ecdh],[ECDH public key])\nGNUPG_GPG_DISABLE_ALGO([ecdsa],[ECDSA public key])\nGNUPG_GPG_DISABLE_ALGO([eddsa],[EdDSA public key])\n\nGNUPG_GPG_DISABLE_ALGO([idea],[IDEA cipher])\n# 3DES is a MUST algorithm\nGNUPG_GPG_DISABLE_ALGO([cast5],[CAST5 cipher])\nGNUPG_GPG_DISABLE_ALGO([blowfish],[BLOWFISH cipher])\nGNUPG_GPG_DISABLE_ALGO([aes128],[AES128 cipher])\nGNUPG_GPG_DISABLE_ALGO([aes192],[AES192 cipher])\nGNUPG_GPG_DISABLE_ALGO([aes256],[AES256 cipher])\nGNUPG_GPG_DISABLE_ALGO([twofish],[TWOFISH cipher])\nGNUPG_GPG_DISABLE_ALGO([camellia128],[CAMELLIA128 cipher])\nGNUPG_GPG_DISABLE_ALGO([camellia192],[CAMELLIA192 cipher])\nGNUPG_GPG_DISABLE_ALGO([camellia256],[CAMELLIA256 cipher])\n\nGNUPG_GPG_DISABLE_ALGO([md5],[MD5 hash])\n# SHA1 is a MUST algorithm\nGNUPG_GPG_DISABLE_ALGO([rmd160],[RIPE-MD160 hash])\nGNUPG_GPG_DISABLE_ALGO([sha224],[SHA-224 hash])\n# SHA256 is a MUST algorithm for GnuPG.\nGNUPG_GPG_DISABLE_ALGO([sha384],[SHA-384 hash])\nGNUPG_GPG_DISABLE_ALGO([sha512],[SHA-512 hash])\n\n\n# Allow disabling of zip support.\n# This is in general not a good idea because according to rfc4880 OpenPGP\n# implementations SHOULD support ZLIB.\nAC_MSG_CHECKING([whether to enable the ZIP and ZLIB compression algorithm])\nAC_ARG_ENABLE(zip,\n   AC_HELP_STRING([--disable-zip],\n                  [disable the ZIP and ZLIB compression algorithm]),\n   use_zip=$enableval)\nAC_MSG_RESULT($use_zip)\n\n# Allow disabling of bzib2 support.\n# It is defined only after we confirm the library is available later\nAC_MSG_CHECKING([whether to enable the BZIP2 compression algorithm])\nAC_ARG_ENABLE(bzip2,\n   AC_HELP_STRING([--disable-bzip2],[disable the BZIP2 compression algorithm]),\n   use_bzip2=$enableval)\nAC_MSG_RESULT($use_bzip2)\n\n# Configure option to allow or disallow execution of external\n# programs, like a photo viewer.\nAC_MSG_CHECKING([whether to enable external program execution])\nAC_ARG_ENABLE(exec,\n    AC_HELP_STRING([--disable-exec],[disable all external program execution]),\n    use_exec=$enableval)\nAC_MSG_RESULT($use_exec)\nif test \"$use_exec\" = no ; then\n    AC_DEFINE(NO_EXEC,1,[Define to disable all external program execution])\nfi\n\nif test \"$use_exec\" = yes ; then\n  AC_MSG_CHECKING([whether to enable photo ID viewing])\n  AC_ARG_ENABLE(photo-viewers,\n      [  --disable-photo-viewers disable photo ID viewers],\n      [if test \"$enableval\" = no ; then\n         AC_DEFINE(DISABLE_PHOTO_VIEWER,1,[define to disable photo viewing])\n      fi],enableval=yes)\n  gnupg_cv_enable_photo_viewers=$enableval\n  AC_MSG_RESULT($enableval)\n\n  if test \"$gnupg_cv_enable_photo_viewers\" = yes ; then\n    AC_MSG_CHECKING([whether to use a fixed photo ID viewer])\n    AC_ARG_WITH(photo-viewer,\n        [  --with-photo-viewer=FIXED_VIEWER  set a fixed photo ID viewer],\n        [if test \"$withval\" = yes ; then\n           withval=no\n        elif test \"$withval\" != no ; then\n           AC_DEFINE_UNQUOTED(FIXED_PHOTO_VIEWER,\"$withval\",\n  \t                    [if set, restrict photo-viewer to this])\n        fi],withval=no)\n    AC_MSG_RESULT($withval)\n  fi\nfi\n\n\n#\n# Check for the key/uid cache size.  This can't be zero, but can be\n# pretty small on embedded systems.  This is used for the gpg part.\n#\nAC_MSG_CHECKING([for the size of the key and uid cache])\nAC_ARG_ENABLE(key-cache,\n        AC_HELP_STRING([--enable-key-cache=SIZE],\n                       [Set key cache to SIZE (default 4096)]),,enableval=4096)\nif test \"$enableval\" = \"no\"; then\n   enableval=5\nelif test \"$enableval\" = \"yes\" || test \"$enableval\" = \"\"; then\n   enableval=4096\nfi\nchangequote(,)dnl\nkey_cache_size=`echo \"$enableval\" | sed 's/[A-Za-z]//g'`\nchangequote([,])dnl\nif test \"$enableval\" != \"$key_cache_size\" || test \"$key_cache_size\" -lt 5; then\n   AC_MSG_ERROR([invalid key-cache size])\nfi\nAC_MSG_RESULT($key_cache_size)\nAC_DEFINE_UNQUOTED(PK_UID_CACHE_SIZE,$key_cache_size,\n                  [Size of the key and UID caches])\n\n\n\n#\n# Check whether we want to use Linux capabilities\n#\nAC_MSG_CHECKING([whether use of capabilities is requested])\nAC_ARG_WITH(capabilities,\n    [  --with-capabilities     use linux capabilities [default=no]],\n[use_capabilities=\"$withval\"],[use_capabilities=no])\nAC_MSG_RESULT($use_capabilities)\n\n#\n# Check whether to disable the card support\nAC_MSG_CHECKING([whether smartcard support is requested])\nAC_ARG_ENABLE(card-support,\n              AC_HELP_STRING([--disable-card-support],\n                             [disable smartcard support]),\n              card_support=$enableval)\nAC_MSG_RESULT($card_support)\nif test \"$card_support\" = yes ; then\n  AC_DEFINE(ENABLE_CARD_SUPPORT,1,[Define to include smartcard support])\nelse\n  build_scdaemon=no\nfi\n\n#\n# Allow disabling of internal CCID support.\n# It is defined only after we confirm the library is available later\n#\nAC_MSG_CHECKING([whether to enable the internal CCID driver])\nAC_ARG_ENABLE(ccid-driver,\n              AC_HELP_STRING([--disable-ccid-driver],\n                             [disable the internal CCID driver]),\n              use_ccid_driver=$enableval)\nAC_MSG_RESULT($use_ccid_driver)\n\nAC_MSG_CHECKING([whether to auto start dirmngr])\nAC_ARG_ENABLE(dirmngr-auto-start,\n              AC_HELP_STRING([--disable-dirmngr-auto-start],\n                             [disable auto starting of the dirmngr]),\n              dirmngr_auto_start=$enableval)\nAC_MSG_RESULT($dirmngr_auto_start)\nif test \"$dirmngr_auto_start\" = yes ; then\n    AC_DEFINE(USE_DIRMNGR_AUTO_START,1,\n              [Define to enable auto starting of the dirmngr])\nfi\n\n\n#\n# To avoid double inclusion of config.h which might happen at some\n# places, we add the usual double inclusion protection at the top of\n# config.h.\n#\nAH_TOP([\n#ifndef GNUPG_CONFIG_H_INCLUDED\n#define GNUPG_CONFIG_H_INCLUDED\n])\n\n#\n# Stuff which goes at the bottom of config.h.\n#\nAH_BOTTOM([\n/* This is the major version number of GnuPG so that\n   source included files can test for this.  Note, that\n   we use 2 here even for GnuPG 1.9.x. */\n#define GNUPG_MAJOR_VERSION 2\n\n/* Now to separate file name parts.\n   Please note that the string version must not contain more\n   than one character because the code assumes strlen()==1 */\n#ifdef HAVE_DOSISH_SYSTEM\n#define DIRSEP_C '\\\\'\n#define DIRSEP_S \"\\\\\"\n#define EXTSEP_C '.'\n#define EXTSEP_S \".\"\n#define PATHSEP_C ';'\n#define PATHSEP_S \";\"\n#define EXEEXT_S \".exe\"\n#else\n#define DIRSEP_C '/'\n#define DIRSEP_S \"/\"\n#define EXTSEP_C '.'\n#define EXTSEP_S \".\"\n#define PATHSEP_C ':'\n#define PATHSEP_S \":\"\n#define EXEEXT_S \"\"\n#endif\n\n/* This is the same as VERSION, but should be overridden if the\n   platform cannot handle things like dots '.' in filenames. Set\n   SAFE_VERSION_DOT and SAFE_VERSION_DASH to whatever SAFE_VERSION\n   uses for dots and dashes. */\n#define SAFE_VERSION VERSION\n#define SAFE_VERSION_DOT  '.'\n#define SAFE_VERSION_DASH '-'\n\n/* Some global constants.\n * Note that the homedir must not end in a slash.  */\n#ifdef HAVE_DOSISH_SYSTEM\n# ifdef HAVE_DRIVE_LETTERS\n#  define GNUPG_DEFAULT_HOMEDIR \"c:/gnupg\"\n# else\n#  define GNUPG_DEFAULT_HOMEDIR \"/gnupg\"\n# endif\n#elif defined(__VMS)\n#define GNUPG_DEFAULT_HOMEDIR \"/SYS$LOGIN/gnupg\"\n#else\n#define GNUPG_DEFAULT_HOMEDIR \"~/.gnupg\"\n#endif\n#define GNUPG_PRIVATE_KEYS_DIR  \"private-keys-v1.d\"\n#define GNUPG_OPENPGP_REVOC_DIR \"openpgp-revocs.d\"\n\n/* For some systems (DOS currently), we hardcode the path here.  For\n   POSIX systems the values are constructed by the Makefiles, so that\n   the values may be overridden by the make invocations; this is to\n   comply with the GNU coding standards.  Note that these values are\n   only defaults.  */\n#ifdef HAVE_DOSISH_SYSTEM\n# ifdef HAVE_DRIVE_LETTERS\n#  define GNUPG_BINDIR      \"c:\\\\gnupg\"\n#  define GNUPG_LIBEXECDIR  \"c:\\\\gnupg\"\n#  define GNUPG_LIBDIR      \"c:\\\\gnupg\"\n#  define GNUPG_DATADIR     \"c:\\\\gnupg\"\n#  define GNUPG_SYSCONFDIR  \"c:\\\\gnupg\"\n# else\n#  define GNUPG_BINDIR      \"\\\\gnupg\"\n#  define GNUPG_LIBEXECDIR  \"\\\\gnupg\"\n#  define GNUPG_LIBDIR      \"\\\\gnupg\"\n#  define GNUPG_DATADIR     \"\\\\gnupg\"\n#  define GNUPG_SYSCONFDIR  \"\\\\gnupg\"\n# endif\n#endif\n\n/* Derive some other constants. */\n#if !(defined(HAVE_FORK) && defined(HAVE_PIPE) && defined(HAVE_WAITPID))\n#define EXEC_TEMPFILE_ONLY\n#endif\n\n\n/* We didn't define endianness above, so get it from OS macros.  This\n   is intended for making fat binary builds on OS X. */\n#if !defined(BIG_ENDIAN_HOST) && !defined(LITTLE_ENDIAN_HOST)\n#if defined(__BIG_ENDIAN__)\n#define BIG_ENDIAN_HOST 1\n#elif defined(__LITTLE_ENDIAN__)\n#define LITTLE_ENDIAN_HOST 1\n#else\n#error \"No endianness found\"\n#endif\n#endif\n\n\n/* Hack used for W32: ldap.m4 also tests for the ASCII version of\n   ldap_start_tls_s because that is the actual symbol used in the\n   library.  winldap.h redefines it to our commonly used value,\n   thus we define our usual macro here.  */\n#ifdef HAVE_LDAP_START_TLS_SA\n# ifndef HAVE_LDAP_START_TLS_S\n#  define HAVE_LDAP_START_TLS_S 1\n# endif\n#endif\n\n/* Provide the es_ macro for estream.  */\n#define GPGRT_ENABLE_ES_MACROS 1\n\n/* Tell libgcrypt not to use its own libgpg-error implementation. */\n#define USE_LIBGPG_ERROR 1\n\n/* Tell Libgcrypt not to include deprecated definitions.  */\n#define GCRYPT_NO_DEPRECATED 1\n\n/* Our HTTP code is used in estream mode.  */\n#define HTTP_USE_ESTREAM 1\n\n/* Under W32 we do an explicit socket initialization, thus we need to\n   avoid the on-demand initialization which would also install an atexit\n   handler.  */\n#define HTTP_NO_WSASTARTUP\n\n/* Under Windows we use the gettext code from libgpg-error.  */\n#define GPG_ERR_ENABLE_GETTEXT_MACROS\n\n/* Under WindowsCE we use the strerror replacement from libgpg-error.  */\n#define GPG_ERR_ENABLE_ERRNO_MACROS\n\n#endif /*GNUPG_CONFIG_H_INCLUDED*/\n])\n\n\nAM_MAINTAINER_MODE\nAC_ARG_VAR(SYSROOT,[locate config scripts also below that directory])\n\n# Checks for programs.\nAC_MSG_NOTICE([checking for programs])\nAC_PROG_MAKE_SET\nAM_SANITY_CHECK\nmissing_dir=`cd $ac_aux_dir && pwd`\nAM_MISSING_PROG(ACLOCAL, aclocal, $missing_dir)\nAM_MISSING_PROG(AUTOCONF, autoconf, $missing_dir)\nAM_MISSING_PROG(AUTOMAKE, automake, $missing_dir)\nAM_MISSING_PROG(AUTOHEADER, autoheader, $missing_dir)\nAM_MISSING_PROG(MAKEINFO, makeinfo, $missing_dir)\nAM_SILENT_RULES\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CPP\nAM_PROG_CC_C_O\nif test \"x$ac_cv_prog_cc_c89\" = \"xno\" ; then\n  AC_MSG_ERROR([[No C-89 compiler found]])\nfi\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_RANLIB\nAC_CHECK_TOOL(AR, ar, :)\nAC_PATH_PROG(PERL,\"perl\")\nAC_CHECK_TOOL(WINDRES, windres, :)\nAC_PATH_PROG(YAT2M, \"yat2m\")\nAC_ARG_VAR(YAT2M, [tool to convert texi to man pages])\nAM_CONDITIONAL(HAVE_YAT2M, test -n \"$ac_cv_path_YAT2M\")\nAC_ISC_POSIX\nAC_SYS_LARGEFILE\nGNUPG_CHECK_USTAR\n\n\n# GNU AWK requires -n option to interpret \"0xHH\" as a number\nif $AWK 'BEGIN { if (PROCINFO@<:@\"version\"@:>@) exit 1 }'; then\n  AWK_HEX_NUMBER_OPTION=''\n  AC_MSG_NOTICE([awk with no option for hexadecimal])\nelse\n  AWK_HEX_NUMBER_OPTION='-n'\n  AC_MSG_NOTICE([awk with an option -n for hexadecimal])\nfi\nAC_SUBST(AWK_HEX_NUMBER_OPTION)\n\n# We need to compile and run a program on the build machine.  A\n# comment in libgpg-error says that the AC_PROG_CC_FOR_BUILD macro in\n# the AC archive is broken for autoconf 2.57.  Given that there is no\n# newer version of that macro, we assume that it is also broken for\n# autoconf 2.61 and thus we use a simple but usually sufficient\n# approach.\nAC_MSG_CHECKING(for cc for build)\nif test \"$cross_compiling\" = \"yes\"; then\n  CC_FOR_BUILD=\"${CC_FOR_BUILD-cc}\"\nelse\n  CC_FOR_BUILD=\"${CC_FOR_BUILD-$CC}\"\nfi\nAC_MSG_RESULT($CC_FOR_BUILD)\nAC_ARG_VAR(CC_FOR_BUILD,[build system C compiler])\n\n# We need to call this macro because other pkg-config macros are\n# not always used.\nPKG_PROG_PKG_CONFIG\n\n\ntry_gettext=yes\nrequire_iconv=yes\nhave_dosish_system=no\nhave_w32_system=no\nhave_w32ce_system=no\nhave_android_system=no\nuse_simple_gettext=no\nuse_ldapwrapper=yes\nmmap_needed=yes\nrequire_pipe_to_unblock_pselect=yes\ncase \"${host}\" in\n    *-mingw32*)\n        # special stuff for Windoze NT\n        ac_cv_have_dev_random=no\n        AC_DEFINE(USE_ONLY_8DOT3,1,\n                  [Set this to limit filenames to the 8.3 format])\n        AC_DEFINE(USE_SIMPLE_GETTEXT,1,\n                  [Because the Unix gettext has too much overhead on\n                   MingW32 systems and these systems lack Posix functions,\n                   we use a simplified version of gettext])\n        have_dosish_system=yes\n        have_w32_system=yes\n        require_iconv=no\n        require_pipe_to_unblock_pselect=no\n        case \"${host}\" in\n          *-mingw32ce*)\n            have_w32ce_system=yes\n            ;;\n          *)\n            AC_DEFINE(HAVE_DRIVE_LETTERS,1,\n                      [Defined if the OS supports drive letters.])\n            ;;\n        esac\n        try_gettext=\"no\"\n\tuse_simple_gettext=yes\n\tmmap_needed=no\n        build_wks_tools=no\n        ;;\n    i?86-emx-os2 | i?86-*-os2*emx )\n        # OS/2 with the EMX environment\n        ac_cv_have_dev_random=no\n        AC_DEFINE(HAVE_DRIVE_LETTERS)\n        have_dosish_system=yes\n        try_gettext=\"no\"\n        build_wks_tools=no\n        ;;\n\n    i?86-*-msdosdjgpp*)\n        # DOS with the DJGPP environment\n        ac_cv_have_dev_random=no\n        AC_DEFINE(HAVE_DRIVE_LETTERS)\n        have_dosish_system=yes\n        try_gettext=\"no\"\n        build_wks_tools=no\n        ;;\n\n    *-*-hpux*)\n        if test -z \"$GCC\" ; then\n            CFLAGS=\"-Ae -D_HPUX_SOURCE $CFLAGS\"\n        fi\n        ;;\n    *-dec-osf4*)\n        if test -z \"$GCC\" ; then\n            # Suppress all warnings\n            # to get rid of the unsigned/signed char mismatch warnings.\n            CFLAGS=\"-w $CFLAGS\"\n        fi\n        ;;\n    *-dec-osf5*)\n        if test -z \"$GCC\" ; then\n            # Use the newer compiler `-msg_disable ptrmismatch1' to\n            # get rid of the unsigned/signed char mismatch warnings.\n            # Using this may hide other pointer mismatch warnings, but\n\t    # it at least lets other warning classes through\n            CFLAGS=\"-msg_disable ptrmismatch1 $CFLAGS\"\n        fi\n        ;;\n    m68k-atari-mint)\n        ;;\n    *-linux-android*)\n        have_android_system=yes\n        # Android is fully utf-8 and we do not want to use iconv to\n        # keeps things simple\n        require_iconv=no\n        build_wks_tools=no\n        ;;\n    *-apple-darwin*)\n        AC_DEFINE(_DARWIN_C_SOURCE, 900000L,\n                  Expose all libc features (__DARWIN_C_FULL).)\n        ;;\n    *-*-netbsd*)\n        require_pipe_to_unblock_pselect=yes\n        ;;\n    *)\n        ;;\nesac\n\nif test \"$require_pipe_to_unblock_pselect\" = yes; then\n   AC_DEFINE(HAVE_PSELECT_NO_EINTR, 1,\n             [Defined if we run on systems like NetBSD, where\n              pselect cannot be unblocked by signal from a thread\n              within the same process.  We use pipe in this case, instead.])\nfi\n\nif test \"$have_dosish_system\" = yes; then\n   AC_DEFINE(HAVE_DOSISH_SYSTEM,1,\n             [Defined if we run on some of the PCDOS like systems\n              (DOS, Windoze. OS/2) with special properties like\n              no file modes, case insensitive file names and preferred\n              use of backslashes as directory name separators.])\nfi\nAM_CONDITIONAL(HAVE_DOSISH_SYSTEM, test \"$have_dosish_system\" = yes)\n\nAM_CONDITIONAL(USE_SIMPLE_GETTEXT, test x\"$use_simple_gettext\" = xyes)\n\nif test \"$have_w32_system\" = yes; then\n   AC_DEFINE(HAVE_W32_SYSTEM,1, [Defined if we run on a W32 API based system])\n   if test \"$have_w32ce_system\" = yes; then\n      AC_DEFINE(HAVE_W32CE_SYSTEM,1,[Defined if we run on WindowsCE])\n   fi\nfi\nAM_CONDITIONAL(HAVE_W32_SYSTEM, test \"$have_w32_system\" = yes)\nAM_CONDITIONAL(HAVE_W32CE_SYSTEM, test \"$have_w32ce_system\" = yes)\n\nif test \"$have_android_system\" = yes; then\n   AC_DEFINE(HAVE_ANDROID_SYSTEM,1, [Defined if we build for an Android system])\nfi\nAM_CONDITIONAL(HAVE_ANDROID_SYSTEM, test \"$have_android_system\" = yes)\n\n\n# (These need to go after AC_PROG_CC so that $EXEEXT is defined)\nAC_DEFINE_UNQUOTED(EXEEXT,\"$EXEEXT\",[The executable file extension, if any])\n\n\n#\n# Checks for libraries.\n#\nAC_MSG_NOTICE([checking for libraries])\n\n\n#\n# libgpg-error is a library with error codes shared between GnuPG\n# related projects.\n#\nAM_PATH_GPG_ERROR(\"$NEED_GPG_ERROR_VERSION\",\n                  have_gpg_error=yes,have_gpg_error=no)\n\n\n#\n# Libgcrypt is our generic crypto library\n#\nAM_PATH_LIBGCRYPT(\"$NEED_LIBGCRYPT_API:$NEED_LIBGCRYPT_VERSION\",\n        have_libgcrypt=yes,have_libgcrypt=no)\n\n\n#\n# libassuan is used for IPC\n#\nAM_PATH_LIBASSUAN(\"$NEED_LIBASSUAN_API:$NEED_LIBASSUAN_VERSION\",\n                  have_libassuan=yes,have_libassuan=no)\nif test \"$have_libassuan\" = \"yes\"; then\n  AC_DEFINE_UNQUOTED(GNUPG_LIBASSUAN_VERSION, \"$libassuan_version\",\n                     [version of the libassuan library])\n  show_tor_support=\"only .onion\"\nfi\n\n\n#\n# libksba is our X.509 support library\n#\nAM_PATH_KSBA(\"$NEED_KSBA_API:$NEED_KSBA_VERSION\",have_ksba=yes,have_ksba=no)\n\n\n#\n# libusb allows us to use the integrated CCID smartcard reader driver.\n#\n# FiXME: Use GNUPG_CHECK_LIBUSB and modify to use separate AC_SUBSTs.\nif test \"$use_ccid_driver\" = auto || test \"$use_ccid_driver\" = yes; then\n   case \"${host}\" in\n     *-mingw32*)\n       LIBUSB_NAME=\n       LIBUSB_LIBS=\n       LIBUSB_CPPFLAGS=\n       ;;\n     *-*-darwin*)\n       LIBUSB_NAME=usb-1.0\n       LIBUSB_LIBS=\"-Wl,-framework,CoreFoundation -Wl,-framework,IOKit\"\n       ;;\n     *-*-freebsd*)\n       # FreeBSD has a native 1.0 compatible library by -lusb.\n       LIBUSB_NAME=usb\n       LIBUSB_LIBS=\n       ;;\n     *)\n       LIBUSB_NAME=usb-1.0\n       LIBUSB_LIBS=\n       ;;\n   esac\nfi\nif test x\"$LIBUSB_NAME\" != x ; then\n   AC_CHECK_LIB($LIBUSB_NAME, libusb_init,\n                [ LIBUSB_LIBS=\"-l$LIBUSB_NAME $LIBUSB_LIBS\"\n                  have_libusb=yes ])\n   AC_MSG_CHECKING([libusb include dir])\n   usb_incdir_found=\"no\"\n   for _incdir in \"\" \"/usr/include/libusb-1.0\" \\\n       \"/usr/local/include/libusb-1.0\" \"/usr/pkg/include/libusb-1.0\"; do\n     _libusb_save_cppflags=$CPPFLAGS\n     if test -n \"${_incdir}\"; then\n       CPPFLAGS=\"-I${_incdir} ${CPPFLAGS}\"\n     fi\n     AC_PREPROC_IFELSE([AC_LANG_SOURCE([[@%:@include <libusb.h>]])],\n     [usb_incdir=${_incdir}; usb_incdir_found=\"yes\"], [])\n     CPPFLAGS=${_libusb_save_cppflags}\n     if test \"$usb_incdir_found\" = \"yes\"; then\n       break\n     fi\n   done\n   if test \"$usb_incdir_found\" = \"yes\"; then\n     AC_MSG_RESULT([${usb_incdir}])\n   else\n     AC_MSG_RESULT([not found])\n     usb_incdir=\"\"\n     have_libusb=no\n     if test \"$use_ccid_driver\" != yes; then\n       use_ccid_driver=no\n     fi\n     LIBUSB_LIBS=\"\"\n   fi\n\n   if test \"$have_libusb\" = yes; then\n     AC_DEFINE(HAVE_LIBUSB,1, [defined if libusb is available])\n   fi\n   if test x\"$usb_incdir\" = x; then\n     LIBUSB_CPPFLAGS=\"\"\n   else\n     LIBUSB_CPPFLAGS=\"-I${usb_incdir}\"\n   fi\nfi\nAC_SUBST(LIBUSB_LIBS)\nAC_SUBST(LIBUSB_CPPFLAGS)\n\n#\n# Check whether it is necessary to link against libdl.\n# (For example to load libpcsclite)\n#\ngnupg_dlopen_save_libs=\"$LIBS\"\nLIBS=\"\"\nAC_SEARCH_LIBS(dlopen, c dl,,,)\nDL_LIBS=$LIBS\nAC_SUBST(DL_LIBS)\nLIBS=\"$gnupg_dlopen_save_libs\"\n\n\n# Checks for g10\n\nAC_ARG_ENABLE(sqlite,\n                AC_HELP_STRING([--disable-sqlite],\n                               [disable the use of SQLITE]),\n              try_sqlite=$enableval, try_sqlite=yes)\n\nif test x\"$use_tofu\" = xyes ; then\n  if test x\"$try_sqlite\" = xyes ; then\n    PKG_CHECK_MODULES([SQLITE3], [sqlite3 >= $NEED_SQLITE_VERSION],\n                                 [have_sqlite=yes],\n                                 [have_sqlite=no])\n  fi\n  if test \"$have_sqlite\" = \"yes\"; then\n    :\n    AC_SUBST([SQLITE3_CFLAGS])\n    AC_SUBST([SQLITE3_LIBS])\n  else\n    use_tofu=no\n    tmp=$(echo \"$SQLITE3_PKG_ERRORS\" | tr '\\n' '\\v' | sed 's/\\v/\\n*** /g')\n    AC_MSG_WARN([[\n***\n*** Building without SQLite support - TOFU disabled\n***\n*** $tmp]])\n  fi\nfi\n\nAM_CONDITIONAL(SQLITE3, test \"$have_sqlite\" = \"yes\")\n\nif test x\"$use_tofu\" = xyes ; then\n    AC_DEFINE(USE_TOFU, 1, [Enable to build the TOFU code])\nfi\n\n\n# Checks for g13\n\nAC_PATH_PROG(ENCFS, encfs, /usr/bin/encfs)\nAC_DEFINE_UNQUOTED(ENCFS,\n\t\"${ENCFS}\", [defines the filename of the encfs program])\n\nAC_PATH_PROG(FUSERMOUNT, fusermount, /usr/bin/fusermount)\nAC_DEFINE_UNQUOTED(FUSERMOUNT,\n\t\"${FUSERMOUNT}\", [defines the filename of the fusermount program])\n\n\n# Checks for dirmngr\n\n\n#\n# Checks for symcryptrun:\n#\n\n# libutil has openpty() and login_tty().\nAC_CHECK_LIB(util, openpty,\n              [ LIBUTIL_LIBS=\"$LIBUTIL_LIBS -lutil\"\n                AC_DEFINE(HAVE_LIBUTIL,1,\n                         [defined if libutil is available])\n             ])\nAC_SUBST(LIBUTIL_LIBS)\n\n# shred is used to clean temporary plain text files.\nAC_PATH_PROG(SHRED, shred, /usr/bin/shred)\nAC_DEFINE_UNQUOTED(SHRED,\n\t\"${SHRED}\", [defines the filename of the shred program])\n\n\n#\n# Check whether the nPth library is available\n#\nAM_PATH_NPTH(\"$NEED_NPTH_API:$NEED_NPTH_VERSION\",have_npth=yes,have_npth=no)\nif test \"$have_npth\" = \"yes\"; then\n  AC_DEFINE(HAVE_NPTH, 1,\n              [Defined if the New Portable Thread Library is available])\n  AC_DEFINE(USE_NPTH, 1,\n              [Defined if support for nPth is requested and nPth is available])\nelse\n  AC_MSG_WARN([[\n***\n*** To support concurrent access for example in gpg-agent and the SCdaemon\n*** we need the support of the New Portable Threads Library.\n***]])\nfi\n#\n# Enable debugging of nPth\n#\nAC_ARG_ENABLE(npth-debug,\n   AC_HELP_STRING([--enable-npth-debug],\n                  [build with debug version of npth]),\n                  [if test $enableval = yes ; then\n                     AC_DEFINE(NPTH_ENABLE_DEBUG,1,\n                              [Build with debug version of nPth])\n                  fi])\n\n\n\n#\n# NTBTLS is our TLS library.  If it is not available fallback to\n# GNUTLS.\n#\nAC_ARG_ENABLE(ntbtls,\n              AC_HELP_STRING([--disable-ntbtls],\n                             [disable the use of NTBTLS as TLS library]),\n              try_ntbtls=$enableval, try_ntbtls=yes)\nif test x\"$try_ntbtls\" = xyes ; then\n  AM_PATH_NTBTLS(\"$NEED_NTBTLS_API:$NEED_NTBTLS_VERSION\",\n                 [have_ntbtls=yes],[have_ntbtls=no])\nfi\nif test \"$have_ntbtls\" = yes ; then\n   use_tls_library=ntbtls\n   AC_DEFINE(HTTP_USE_NTBTLS, 1, [Enable NTBTLS support in http.c])\nelse\n  AC_ARG_ENABLE(gnutls,\n                AC_HELP_STRING([--disable-gnutls],\n                               [disable GNUTLS as fallback TLS library]),\n                try_gnutls=$enableval, try_gnutls=yes)\n  if test x\"$try_gnutls\" = xyes ; then\n    PKG_CHECK_MODULES([LIBGNUTLS], [gnutls >= $NEED_GNUTLS_VERSION],\n                                   [have_gnutls=yes],\n                                   [have_gnutls=no])\n  fi\n  if test \"$have_gnutls\" = \"yes\"; then\n    AC_SUBST([LIBGNUTLS_CFLAGS])\n    AC_SUBST([LIBGNUTLS_LIBS])\n    use_tls_library=gnutls\n    AC_DEFINE(HTTP_USE_GNUTLS, 1, [Enable GNUTLS support in http.c])\n  else\n    tmp=$(echo \"$LIBGNUTLS_PKG_ERRORS\" | tr '\\n' '\\v' | sed 's/\\v/\\n*** /g')\n    AC_MSG_WARN([[\n***\n*** Building without NTBTLS and GNUTLS - no TLS access to keyservers.\n***\n*** $tmp]])\n  fi\nfi\n\n#\n# Allow to set a fixed trust store file for system provided certificates.\n#\nAC_ARG_WITH([default-trust-store-file],\n            [AC_HELP_STRING([--with-default-trust-store-file=FILE],\n                            [Use FILE as system trust store])],\n            default_trust_store_file=\"$withval\",\n            default_trust_store_file=\"\")\nif test x\"$default_trust_store_file\" = xno;then\n  default_trust_store_file=\"\"\nfi\nif test x\"$default_trust_store_file\" != x ; then\n  AC_DEFINE_UNQUOTED([DEFAULT_TRUST_STORE_FILE],\n    [\"$default_trust_store_file\"], [Use as default system trust store file])\nfi\n\n\nAC_MSG_NOTICE([checking for networking options])\n\n#\n# Must check for network library requirements before doing link tests\n# for ldap, for example. If ldap libs are static (or dynamic and without\n# ELF runtime link paths), then link will fail and LDAP support won't\n# be detected.\n#\nAC_CHECK_FUNC(gethostbyname, , AC_CHECK_LIB(nsl, gethostbyname,\n\t[NETLIBS=\"-lnsl $NETLIBS\"]))\nAC_CHECK_FUNC(setsockopt, , AC_CHECK_LIB(socket, setsockopt,\n\t[NETLIBS=\"-lsocket $NETLIBS\"]))\n\n\n#\n# Check standard resolver functions.\n#\nif test \"$build_dirmngr\" = \"yes\"; then\n  _dns_save_libs=$LIBS\n  LIBS=\"\"\n\n  # Find the system resolver which can always be enabled with\n  # the dirmngr option --standard-resolver.\n\n  # the double underscore thing is a glibc-ism?\n  AC_SEARCH_LIBS(res_query,resolv bind,,\n                 AC_SEARCH_LIBS(__res_query,resolv bind,,have_resolver=no))\n  AC_SEARCH_LIBS(dn_expand,resolv bind,,\n                 AC_SEARCH_LIBS(__dn_expand,resolv bind,,have_resolver=no))\n\n  # macOS renames dn_skipname into res_9_dn_skipname in <resolv.h>,\n  # and for some reason fools us into believing we don't need\n  # -lresolv even if we do.  Since the test program checking for the\n  # symbol does not include <resolv.h>, we need to check for the\n  # renamed symbol explicitly.\n  AC_SEARCH_LIBS(res_9_dn_skipname,resolv bind,,\n      AC_SEARCH_LIBS(dn_skipname,resolv bind,,\n          AC_SEARCH_LIBS(__dn_skipname,resolv bind,,have_resolver=no)))\n\n  if test x\"$have_resolver\" != xno ; then\n\n      # Make sure that the BIND 4 resolver interface is workable before\n      # enabling any code that calls it.  At some point I'll rewrite the\n      # code to use the BIND 8 resolver API.\n      # We might also want to use libdns instead.\n\n    AC_MSG_CHECKING([whether the resolver is usable])\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>]],\n[[unsigned char answer[PACKETSZ];\n  res_query(\"foo.bar\",C_IN,T_A,answer,PACKETSZ);\n  dn_skipname(0,0);\n  dn_expand(0,0,0,0,0);\n]])],have_resolver=yes,have_resolver=no)\n    AC_MSG_RESULT($have_resolver)\n\n    # This is Apple-specific and somewhat bizarre as they changed the\n    # define in bind 8 for some reason.\n\n    if test x\"$have_resolver\" != xyes ; then\n      AC_MSG_CHECKING(\n           [whether I can make the resolver usable with BIND_8_COMPAT])\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([[#define BIND_8_COMPAT\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>]],\n[[unsigned char answer[PACKETSZ];\n  res_query(\"foo.bar\",C_IN,T_A,answer,PACKETSZ);\n  dn_skipname(0,0); dn_expand(0,0,0,0,0);\n]])],[have_resolver=yes ; need_compat=yes])\n      AC_MSG_RESULT($have_resolver)\n    fi\n  fi\n\n  if test x\"$have_resolver\" = xyes ; then\n    AC_DEFINE(HAVE_SYSTEM_RESOLVER,1,[The system's resolver is usable.])\n    DNSLIBS=\"$DNSLIBS $LIBS\"\n    if test x\"$need_compat\" = xyes ; then\n      AC_DEFINE(BIND_8_COMPAT,1,[an Apple OSXism])\n    fi\n    if test \"$use_libdns\" = yes; then\n     show_tor_support=yes\n    fi\n  elif test \"$use_libdns\" = yes; then\n    show_tor_support=yes\n  else\n    AC_MSG_WARN([[\n***\n*** The system's DNS resolver is not usable.\n*** Dirmngr functionality is limited.\n***]])\n    show_tor_support=\"${show_tor_support} (no system resolver)\"\n  fi\n\n  if test \"$have_w32_system\" = yes; then\n    if test \"$use_libdns\" = yes; then\n      DNSLIBS=\"$DNSLIBS -liphlpapi\"\n    fi\n  fi\n\n  LIBS=$_dns_save_libs\nfi\n\nAC_SUBST(DNSLIBS)\n\n\n#\n# Check for LDAP\n#\n# Note that running the check changes the variable\n# gnupg_have_ldap from \"n/a\" to \"no\" or \"yes\".\n\nAC_ARG_ENABLE(ldap,\n    AC_HELP_STRING([--disable-ldap],[disable LDAP support]),\n    [if test \"$enableval\" = \"no\"; then gnupg_have_ldap=no; fi])\n\nif test \"$gnupg_have_ldap\" != \"no\" ; then\n  if test \"$build_dirmngr\" = \"yes\" ; then\n     GNUPG_CHECK_LDAP($NETLIBS)\n     AC_CHECK_LIB(lber, ber_free,\n                  [ LBER_LIBS=\"$LBER_LIBS -llber\"\n                    AC_DEFINE(HAVE_LBER,1,\n                             [defined if liblber is available])\n                    have_lber=yes\n                 ])\n  fi\nfi\nAC_SUBST(LBER_LIBS)\nif test \"$gnupg_have_ldap\" = \"no\"; then\n    AC_MSG_WARN([[\n***\n*** Building without LDAP support.\n*** No CRL access or X.509 certificate search available.\n***]])\nfi\n\nAM_CONDITIONAL(USE_LDAP, [test \"$gnupg_have_ldap\" = yes])\nif test \"$gnupg_have_ldap\" = yes ; then\n  AC_DEFINE(USE_LDAP,1,[Defined if LDAP is support])\nelse\n use_ldapwrapper=no\nfi\n\nif test \"$use_ldapwrapper\" = yes; then\n   AC_DEFINE(USE_LDAPWRAPPER,1, [Build dirmngr with LDAP wrapper process])\nfi\nAM_CONDITIONAL(USE_LDAPWRAPPER, test \"$use_ldapwrapper\" = yes)\n\n\n\n\n#\n# Check for sendmail\n#\n# This isn't necessarily sendmail itself, but anything that gives a\n# sendmail-ish interface to the outside world.  That includes Exim,\n# Postfix, etc.  Basically, anything that can handle \"sendmail -t\".\nAC_ARG_WITH(mailprog,\n      AC_HELP_STRING([--with-mailprog=NAME],\n                     [use \"NAME -t\" for mail transport]),\n             ,with_mailprog=yes)\nif test x\"$with_mailprog\" = xyes ; then\n    AC_PATH_PROG(SENDMAIL,sendmail,,$PATH:/usr/sbin:/usr/libexec:/usr/lib)\nelif test x\"$with_mailprog\" != xno ; then\n    AC_MSG_CHECKING([for a mail transport program])\n    AC_SUBST(SENDMAIL,$with_mailprog)\n    AC_MSG_RESULT($with_mailprog)\nfi\nAC_DEFINE_UNQUOTED(NAME_OF_SENDMAIL,\"$SENDMAIL\",\n                   [Tool with sendmail -t interface])\n\n\n#\n# Construct a printable name of the OS\n#\ncase \"${host}\" in\n    *-mingw32ce*)\n        PRINTABLE_OS_NAME=\"W32CE\"\n        ;;\n    *-mingw32*)\n        PRINTABLE_OS_NAME=\"MingW32\"\n        ;;\n    *-*-cygwin*)\n        PRINTABLE_OS_NAME=\"Cygwin\"\n        ;;\n    i?86-emx-os2 | i?86-*-os2*emx )\n        PRINTABLE_OS_NAME=\"OS/2\"\n        ;;\n    i?86-*-msdosdjgpp*)\n        PRINTABLE_OS_NAME=\"MSDOS/DJGPP\"\n        try_dynload=no\n        ;;\n    *-linux*)\n        PRINTABLE_OS_NAME=\"GNU/Linux\"\n        ;;\n    *)\n        PRINTABLE_OS_NAME=`uname -s || echo \"Unknown\"`\n        ;;\nesac\nAC_DEFINE_UNQUOTED(PRINTABLE_OS_NAME, \"$PRINTABLE_OS_NAME\",\n                   [A human readable text with the name of the OS])\n\n\n#\n# Checking for iconv\n#\nif test \"$require_iconv\" = yes; then\n  AM_ICONV\nelse\n  LIBICONV=\n  LTLIBICONV=\n  AC_SUBST(LIBICONV)\n  AC_SUBST(LTLIBICONV)\nfi\n\n\n#\n# Check for gettext\n#\n# This is \"GNU gnupg\" - The project-id script from gettext\n#                       needs this string\n#\nAC_MSG_NOTICE([checking for gettext])\nAM_PO_SUBDIRS\nAM_GNU_GETTEXT_VERSION([0.17])\nif test \"$try_gettext\" = yes; then\n  AM_GNU_GETTEXT([external],[need-ngettext])\n\n  # gettext requires some extra checks.  These really should be part of\n  # the basic AM_GNU_GETTEXT macro.  TODO: move other gettext-specific\n  # function checks to here.\n\n  AC_CHECK_FUNCS(strchr)\nelse\n  USE_NLS=no\n  USE_INCLUDED_LIBINTL=no\n  BUILD_INCLUDED_LIBINTL=no\n  POSUB=po\n  AC_SUBST(USE_NLS)\n  AC_SUBST(USE_INCLUDED_LIBINTL)\n  AC_SUBST(BUILD_INCLUDED_LIBINTL)\n  AC_SUBST(POSUB)\nfi\n\n# We use HAVE_LANGINFO_CODESET in a couple of places.\nAM_LANGINFO_CODESET\n\n# Checks required for our use of locales\ngt_LC_MESSAGES\n\n\n#\n# SELinux support\n#\nif test \"$selinux_support\" = yes ; then\n  AC_DEFINE(ENABLE_SELINUX_HACKS,1,[Define to enable SELinux support])\nfi\n\n\n#\n# Checks for header files.\n#\nAC_MSG_NOTICE([checking for header files])\nAC_HEADER_STDC\nAC_CHECK_HEADERS([string.h unistd.h langinfo.h termio.h locale.h getopt.h \\\n                  pty.h utmp.h pwd.h inttypes.h signal.h sys/select.h     \\\n                  stdint.h signal.h util.h libutil.h termios.h \\\n                  ucred.h sys/ucred.h sys/sysmacros.h sys/mkdev.h])\n\nAC_HEADER_TIME\n\n\n#\n# Checks for typedefs, structures, and compiler characteristics.\n#\nAC_MSG_NOTICE([checking for system characteristics])\nAC_C_CONST\nAC_C_INLINE\nAC_C_VOLATILE\nAC_TYPE_SIZE_T\nAC_TYPE_MODE_T\nAC_TYPE_SIGNAL\nAC_DECL_SYS_SIGLIST\n\ngl_HEADER_SYS_SOCKET\ngl_TYPE_SOCKLEN_T\n\nAC_SEARCH_LIBS([inet_addr], [nsl])\n\nAC_ARG_ENABLE(endian-check,\n              AC_HELP_STRING([--disable-endian-check],\n\t      [disable the endian check and trust the OS provided macros]),\n\t      endiancheck=$enableval,endiancheck=yes)\n\nif test x\"$endiancheck\" = xyes ; then\n  GNUPG_CHECK_ENDIAN\nfi\n\n# fixme: we should get rid of the byte type\nGNUPG_CHECK_TYPEDEF(byte, HAVE_BYTE_TYPEDEF)\nGNUPG_CHECK_TYPEDEF(ushort, HAVE_USHORT_TYPEDEF)\nGNUPG_CHECK_TYPEDEF(ulong, HAVE_ULONG_TYPEDEF)\nGNUPG_CHECK_TYPEDEF(u16, HAVE_U16_TYPEDEF)\nGNUPG_CHECK_TYPEDEF(u32, HAVE_U32_TYPEDEF)\n\nAC_CHECK_SIZEOF(unsigned short)\nAC_CHECK_SIZEOF(unsigned int)\nAC_CHECK_SIZEOF(unsigned long)\nAC_CHECK_SIZEOF(unsigned long long)\nAC_HEADER_TIME\nAC_CHECK_SIZEOF(time_t,,[[\n#include <stdio.h>\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n]])\nGNUPG_TIME_T_UNSIGNED\n\n\nif test \"$ac_cv_sizeof_unsigned_short\" = \"0\" \\\n   || test \"$ac_cv_sizeof_unsigned_int\" = \"0\" \\\n   || test \"$ac_cv_sizeof_unsigned_long\" = \"0\"; then\n    AC_MSG_WARN([Hmmm, something is wrong with the sizes - using defaults]);\nfi\n\n\n#\n# Checks for library functions.\n#\nAC_MSG_NOTICE([checking for library functions])\nAC_CHECK_DECLS(getpagesize)\nAC_FUNC_FSEEKO\nAC_FUNC_VPRINTF\nAC_FUNC_FORK\nAC_CHECK_FUNCS([atexit canonicalize_file_name clock_gettime ctermid  \\\n                explicit_bzero fcntl flockfile fsync ftello          \\\n                ftruncate funlockfile getaddrinfo getenv getpagesize \\\n                getpwnam getpwuid getrlimit getrusage gettimeofday   \\\n                gmtime_r inet_ntop inet_pton isascii lstat memicmp   \\\n                memmove memrchr mmap nl_langinfo pipe raise rand     \\\n                setenv setlocale setrlimit sigaction sigprocmask     \\\n                stat stpcpy strcasecmp strerror strftime stricmp     \\\n                strlwr strncasecmp strpbrk strsep strtol strtoul     \\\n                strtoull tcgetattr timegm times ttyname unsetenv     \\\n                wait4 waitpid ])\n\n# On some systems (e.g. Solaris) nanosleep requires linking to librl.\n# Given that we use nanosleep only as an optimization over a select\n# based wait function we want it only if it is available in libc.\n_save_libs=\"$LIBS\"\nAC_SEARCH_LIBS([nanosleep], [],\n               [AC_DEFINE(HAVE_NANOSLEEP,1,\n                [Define to 1 if you have the `nanosleep' function in libc.])])\nLIBS=\"$_save_libs\"\n\n\n# See whether libc supports the Linux inotify interface\ncase \"${host}\" in\n    *-*-linux*)\n        AC_CHECK_FUNCS([inotify_init])\n        ;;\nesac\n\n\nif test \"$have_android_system\" = yes; then\n   # On Android ttyname is a stub but prints an error message.\n   AC_DEFINE(HAVE_BROKEN_TTYNAME,1,\n             [Defined if ttyname does not work properly])\nfi\n\nAC_CHECK_TYPES([struct sigaction, sigset_t],,,[#include <signal.h>])\n\n# Dirmngr requires mmap on Unix systems.\nif test $ac_cv_func_mmap != yes -a $mmap_needed = yes; then\n  AC_MSG_ERROR([[Sorry, the current implementation requires mmap.]])\nfi\n\n\n#\n# Check for the getsockopt SO_PEERCRED, etc.\n#\nAC_CHECK_MEMBERS([struct ucred.pid, struct ucred.cr_pid, struct sockpeercred.pid], [], [], [#include <sys/types.h>\n#include <sys/socket.h> ])\n\n# (Open)Solaris\nAC_CHECK_FUNCS([getpeerucred])\n\n\n#\n# W32 specific test\n#\nGNUPG_FUNC_MKDIR_TAKES_ONE_ARG\n\n\n#\n# Do we have zlib? Must do it here because Solaris failed\n# when compiling a conftest (due to the \"-lz\" from LIBS).\n# Note that we combine zlib and bzlib2 in ZLIBS.\n#\nif test \"$use_zip\" = yes ; then\n  _cppflags=\"${CPPFLAGS}\"\n  _ldflags=\"${LDFLAGS}\"\n  AC_ARG_WITH(zlib,\n    [  --with-zlib=DIR         use libz in DIR],[\n      if test -d \"$withval\"; then\n        CPPFLAGS=\"${CPPFLAGS} -I$withval/include\"\n        LDFLAGS=\"${LDFLAGS} -L$withval/lib\"\n      fi\n    ])\n\n  AC_CHECK_HEADER(zlib.h,\n     AC_CHECK_LIB(z, deflateInit2_,\n       [\n       ZLIBS=\"-lz\"\n       AC_DEFINE(HAVE_ZIP,1, [Defined if ZIP and ZLIB are supported])\n       ],\n       CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}),\n       CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags})\nfi\n\n\n#\n# Check whether we can support bzip2\n#\nif test \"$use_bzip2\" = yes ; then\n  _cppflags=\"${CPPFLAGS}\"\n  _ldflags=\"${LDFLAGS}\"\n  AC_ARG_WITH(bzip2,\n     AC_HELP_STRING([--with-bzip2=DIR],[look for bzip2 in DIR]),\n      [\n      if test -d \"$withval\" ; then\n        CPPFLAGS=\"${CPPFLAGS} -I$withval/include\"\n        LDFLAGS=\"${LDFLAGS} -L$withval/lib\"\n      fi\n      ],withval=\"\")\n\n  # Checking alongside stdio.h as an early version of bzip2 (1.0)\n  # required stdio.h to be included before bzlib.h, and Solaris 9 is\n  # woefully out of date.\n  if test \"$withval\" != no ; then\n     AC_CHECK_HEADER(bzlib.h,\n        AC_CHECK_LIB(bz2,BZ2_bzCompressInit,\n  \t  [\n\t  have_bz2=yes\n\t  ZLIBS=\"$ZLIBS -lbz2\"\n\t  AC_DEFINE(HAVE_BZIP2,1,\n\t\t  [Defined if the bz2 compression library is available])\n\t  ],\n\t  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}),\n\t  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags},[#include <stdio.h>])\n  fi\nfi\nAM_CONDITIONAL(ENABLE_BZIP2_SUPPORT,test x\"$have_bz2\" = \"xyes\")\nAC_SUBST(ZLIBS)\n\n\n# Check for readline support\nGNUPG_CHECK_READLINE\n\n\nif test \"$development_version\" = yes; then\n    AC_DEFINE(IS_DEVELOPMENT_VERSION,1,\n            [Defined if this is not a regular release])\nfi\n\nif test \"$USE_MAINTAINER_MODE\" = \"yes\"; then\n    AC_DEFINE(MAINTAINER_MODE,1,\n            [Defined if this build is in maintainer mode])\nfi\n\nAM_CONDITIONAL(CROSS_COMPILING, test x$cross_compiling = xyes)\n\nGNUPG_CHECK_GNUMAKE\n\n# Add some extra libs here so that previous tests don't fail for\n# mysterious reasons - the final link step should bail out.\n# W32SOCKLIBS is also defined so that if can be used for tools not\n# requiring any network stuff but linking to code in libcommon which\n# tracks in winsock stuff (e.g. init_common_subsystems).\nif test \"$have_w32_system\" = yes; then\n   if test \"$have_w32ce_system\" = yes; then\n     W32SOCKLIBS=\"-lws2\"\n   else\n     W32SOCKLIBS=\"-lws2_32\"\n   fi\n   NETLIBS=\"${NETLIBS} ${W32SOCKLIBS}\"\nfi\n\nAC_SUBST(NETLIBS)\nAC_SUBST(W32SOCKLIBS)\n\n#\n# Setup gcc specific options\n#\nUSE_C99_CFLAGS=\nAC_MSG_NOTICE([checking for cc features])\nif test \"$GCC\" = yes; then\n    mycflags=\n    mycflags_save=$CFLAGS\n\n    # Check whether gcc does not emit a diagnositc for unknown -Wno-*\n    # options.  This is the case for gcc >= 4.6\n    AC_MSG_CHECKING([if gcc ignores unknown -Wno-* options])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6 )\n#kickerror\n#endif]],[])],[_gcc_silent_wno=yes],[_gcc_silent_wno=no])\n    AC_MSG_RESULT($_gcc_silent_wno)\n\n    # Note that it is okay to use CFLAGS here because these are just\n    # warning options and the user should have a chance of overriding\n    # them.\n    if test \"$USE_MAINTAINER_MODE\" = \"yes\"; then\n        mycflags=\"$mycflags -O3 -Wall -Wcast-align -Wshadow -Wstrict-prototypes\"\n        mycflags=\"$mycflags -Wformat -Wno-format-y2k -Wformat-security\"\n        if test x\"$_gcc_silent_wno\" = xyes ; then\n          _gcc_wopt=yes\n        else\n          AC_MSG_CHECKING([if gcc supports -Wno-missing-field-initializers])\n          CFLAGS=\"-Wno-missing-field-initializers\"\n          AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],\n                            [_gcc_wopt=yes],[_gcc_wopt=no])\n          AC_MSG_RESULT($_gcc_wopt)\n        fi\n        if test x\"$_gcc_wopt\" = xyes ; then\n          mycflags=\"$mycflags -W -Wno-sign-compare -Wno-format-zero-length\"\n          mycflags=\"$mycflags -Wno-missing-field-initializers\"\n          mycflags=\"$mycflags -Wno-format-zero-length\"\n        fi\n\n        AC_MSG_CHECKING([if gcc supports -Wdeclaration-after-statement])\n        CFLAGS=\"-Wdeclaration-after-statement\"\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)\n        AC_MSG_RESULT($_gcc_wopt)\n        if test x\"$_gcc_wopt\" = xyes ; then\n          mycflags=\"$mycflags -Wdeclaration-after-statement\"\n        fi\n\n        AC_MSG_CHECKING([if gcc supports -Wlogical-op])\n        CFLAGS=\"-Wlogical-op -Werror\"\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)\n        AC_MSG_RESULT($_gcc_wopt)\n        if test x\"$_gcc_wopt\" = xyes ; then\n          mycflags=\"$mycflags -Wlogical-op\"\n        fi\n\n        AC_MSG_CHECKING([if gcc supports -Wvla])\n        CFLAGS=\"-Wvla\"\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_wopt=yes,_gcc_wopt=no)\n        AC_MSG_RESULT($_gcc_wopt)\n        if test x\"$_gcc_wopt\" = xyes ; then\n          mycflags=\"$mycflags -Wvla\"\n        fi\n\n    else\n        mycflags=\"$mycflags -Wall\"\n    fi\n\n    if test x\"$_gcc_silent_wno\" = xyes ; then\n      _gcc_psign=yes\n    else\n      AC_MSG_CHECKING([if gcc supports -Wno-pointer-sign])\n      CFLAGS=\"-Wno-pointer-sign\"\n      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],\n                        [_gcc_psign=yes],[_gcc_psign=no])\n      AC_MSG_RESULT($_gcc_psign)\n    fi\n    if test x\"$_gcc_psign\" = xyes ; then\n       mycflags=\"$mycflags -Wno-pointer-sign\"\n    fi\n\n    AC_MSG_CHECKING([if gcc supports -Wpointer-arith])\n    CFLAGS=\"-Wpointer-arith\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],_gcc_psign=yes,_gcc_psign=no)\n    AC_MSG_RESULT($_gcc_psign)\n    if test x\"$_gcc_psign\" = xyes ; then\n       mycflags=\"$mycflags -Wpointer-arith\"\n    fi\n\n    CFLAGS=\"$mycflags $mycflags_save\"\n    if test \"$use_libdns\" = yes; then\n       # dirmngr/dns.{c,h} require C99 and GNU extensions.  */\n       USE_C99_CFLAGS=\"-std=gnu99\"\n    fi\nfi\n\nAC_SUBST(USE_C99_CFLAGS)\n\n\n#\n# This is handy for debugging so the compiler doesn't rearrange\n# things and eliminate variables.\n#\nAC_ARG_ENABLE(optimization,\n   AC_HELP_STRING([--disable-optimization],\n                  [disable compiler optimization]),\n                  [if test $enableval = no ; then\n                      CFLAGS=`echo $CFLAGS | sed s/-O[[1-9]]\\ /-O0\\ /g`\n                   fi])\n\n#\n# Add -Werror to CFLAGS.  This hack can be used to avoid problems with\n# misbehaving autoconf tests in case the user supplied -Werror.\n#\nAC_ARG_ENABLE(werror,\n   AC_HELP_STRING([--enable-werror],\n                  [append -Werror to CFLAGS]),\n                  [if test $enableval = yes ; then\n                      CFLAGS=\"$CFLAGS -Werror\"\n                   fi])\n\n#\n# Configure option --enable-all-tests\n#\nAC_MSG_CHECKING([whether \"make check\" shall run all tests])\nAC_ARG_ENABLE(all-tests,\n              AC_HELP_STRING([--enable-all-tests],\n                             [let \"make check\" run all tests]),\n              run_all_tests=$enableval, run_all_tests=no)\nAC_MSG_RESULT($run_all_tests)\nif test \"$run_all_tests\" = \"yes\"; then\n    AC_DEFINE(RUN_ALL_TESTS,1,\n            [Defined if \"make check\" shall run all tests])\nfi\n\n#\n# Configure option --disable-tests\n#\nAC_MSG_CHECKING([whether tests should be run])\nAC_ARG_ENABLE(tests,\n              AC_HELP_STRING([--disable-tests],\n                             [do not run any tests]),\n              run_tests=$enableval, run_tests=yes)\nAC_MSG_RESULT($run_tests)\n\n#\n# We do not want support for the GNUPG_BUILDDIR environment variable\n# in a released version.  However, our regression tests suite requires\n# this and thus we build with support for it during \"make distcheck\".\n# This configure option implements this along with the top Makefile's\n# AM_DISTCHECK_CONFIGURE_FLAGS.\n#\ngnupg_builddir_envvar=no\nAC_ARG_ENABLE(gnupg-builddir-envvar,,\n              gnupg_builddir_envvar=$enableval)\nif test x\"$gnupg_builddir_envvar\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_GNUPG_BUILDDIR_ENVVAR, 1,\n      [This is only used with \"make distcheck\"])\nfi\n\n\n#\n# To avoid problems with systemd cleaning up the /run/user directory,\n# this option will make GnuPG try to use /run/gnupg/user as socket dir\n# before /run/user\n#\nAC_ARG_ENABLE(run-gnupg-user-socket,\n    AC_HELP_STRING([--enable-run-gnupg-user-socket],\n                   [try /run/gnupg/user for sockets prior to /run/user]),\n    use_run_gnupg_user_socket=$enableval)\nif test x\"$use_run_gnupg_user_socket\" = x\"yes\"; then\n   AC_DEFINE(USE_RUN_GNUPG_USER_SOCKET, 1,\n            [If defined try /run/gnupg/user before /run/user])\nfi\n\n\n#\n# Decide what to build\n#\n\nbuild_scdaemon_extra=\"\"\nif test \"$build_scdaemon\" = \"yes\"; then\n  if test $have_libusb = no; then\n     build_scdaemon_extra=\"without internal CCID driver\"\n  fi\n  if test -n \"$build_scdaemon_extra\"; then\n     build_scdaemon_extra=\"(${build_scdaemon_extra})\"\n  fi\nfi\n\n\n#\n# Set variables for use by automake makefiles.\n#\nAM_CONDITIONAL(BUILD_GPG,         test \"$build_gpg\" = \"yes\")\nAM_CONDITIONAL(BUILD_GPGSM,       test \"$build_gpgsm\" = \"yes\")\nAM_CONDITIONAL(BUILD_AGENT,       test \"$build_agent\" = \"yes\")\nAM_CONDITIONAL(BUILD_SCDAEMON,    test \"$build_scdaemon\" = \"yes\")\nAM_CONDITIONAL(BUILD_G13,         test \"$build_g13\" = \"yes\")\nAM_CONDITIONAL(BUILD_DIRMNGR,     test \"$build_dirmngr\" = \"yes\")\nAM_CONDITIONAL(BUILD_DOC,         test \"$build_doc\" = \"yes\")\nAM_CONDITIONAL(BUILD_SYMCRYPTRUN, test \"$build_symcryptrun\" = \"yes\")\nAM_CONDITIONAL(BUILD_GPGTAR,      test \"$build_gpgtar\" = \"yes\")\nAM_CONDITIONAL(BUILD_WKS_TOOLS,   test \"$build_wks_tools\" = \"yes\")\n\nAM_CONDITIONAL(DISABLE_TESTS,       test \"$run_tests\" != yes)\nAM_CONDITIONAL(ENABLE_CARD_SUPPORT, test \"$card_support\" = yes)\nAM_CONDITIONAL(NO_TRUST_MODELS,     test \"$use_trust_models\" = no)\nAM_CONDITIONAL(USE_TOFU,            test \"$use_tofu\" = yes)\n\n#\n# Set some defines for use gpgconf.\n#\nif test \"$build_gpg\" = yes ; then\n    AC_DEFINE(BUILD_WITH_GPG,1,[Defined if GPG is to be build])\nfi\nif test \"$build_gpgsm\" = yes ; then\n    AC_DEFINE(BUILD_WITH_GPGSM,1,[Defined if GPGSM is to be build])\nfi\nif test \"$build_agent\" = yes ; then\n    AC_DEFINE(BUILD_WITH_AGENT,1,[Defined if GPG-AGENT is to be build])\nfi\nif test \"$build_scdaemon\" = yes ; then\n    AC_DEFINE(BUILD_WITH_SCDAEMON,1,[Defined if SCDAEMON is to be build])\nfi\nif test \"$build_dirmngr\" = yes ; then\n    AC_DEFINE(BUILD_WITH_DIRMNGR,1,[Defined if DIRMNGR is to be build])\nfi\nif test \"$build_g13\" = yes ; then\n    AC_DEFINE(BUILD_WITH_G13,1,[Defined if G13 is to be build])\nfi\n\n\n#\n# Define Name strings\n#\nAC_DEFINE_UNQUOTED(GNUPG_NAME, \"GnuPG\", [The name of the project])\n\nAC_DEFINE_UNQUOTED(GPG_NAME, \"gpg\", [The name of the OpenPGP tool])\nAC_DEFINE_UNQUOTED(GPG_DISP_NAME, \"GnuPG\", [The displayed name of gpg])\n\nAC_DEFINE_UNQUOTED(GPGSM_NAME, \"gpgsm\", [The name of the S/MIME tool])\nAC_DEFINE_UNQUOTED(GPGSM_DISP_NAME, \"GPGSM\", [The displayed name of gpgsm])\n\nAC_DEFINE_UNQUOTED(GPG_AGENT_NAME, \"gpg-agent\", [The name of the agent])\nAC_DEFINE_UNQUOTED(GPG_AGENT_DISP_NAME, \"GPG Agent\",\n                                        [The displayed name of gpg-agent])\n\nAC_DEFINE_UNQUOTED(SCDAEMON_NAME, \"scdaemon\", [The name of the scdaemon])\nAC_DEFINE_UNQUOTED(SCDAEMON_DISP_NAME, \"SCDaemon\",\n                                       [The displayed name of scdaemon])\n\nAC_DEFINE_UNQUOTED(DIRMNGR_NAME, \"dirmngr\", [The name of the dirmngr])\nAC_DEFINE_UNQUOTED(DIRMNGR_DISP_NAME, \"DirMngr\",\n                                      [The displayed name of dirmngr])\n\nAC_DEFINE_UNQUOTED(G13_NAME, \"g13\", [The name of the g13 tool])\nAC_DEFINE_UNQUOTED(G13_DISP_NAME, \"G13\", [The displayed name of g13])\n\nAC_DEFINE_UNQUOTED(GPGCONF_NAME, \"gpgconf\", [The name of the gpgconf tool])\nAC_DEFINE_UNQUOTED(GPGCONF_DISP_NAME, \"GPGConf\",\n                                      [The displayed name of gpgconf])\n\nAC_DEFINE_UNQUOTED(GPGTAR_NAME, \"gpgtar\", [The name of the gpgtar tool])\n\nAC_DEFINE_UNQUOTED(GPG_AGENT_SOCK_NAME, \"S.gpg-agent\",\n                   [The name of the agent socket])\nAC_DEFINE_UNQUOTED(GPG_AGENT_EXTRA_SOCK_NAME, \"S.gpg-agent.extra\",\n                   [The name of the agent socket for remote access])\nAC_DEFINE_UNQUOTED(GPG_AGENT_BROWSER_SOCK_NAME, \"S.gpg-agent.browser\",\n                   [The name of the agent socket for browsers])\nAC_DEFINE_UNQUOTED(GPG_AGENT_SSH_SOCK_NAME, \"S.gpg-agent.ssh\",\n                   [The name of the agent socket for ssh])\nAC_DEFINE_UNQUOTED(DIRMNGR_INFO_NAME, \"DIRMNGR_INFO\",\n                   [The name of the dirmngr info envvar])\nAC_DEFINE_UNQUOTED(SCDAEMON_SOCK_NAME, \"S.scdaemon\",\n                   [The name of the SCdaemon socket])\nAC_DEFINE_UNQUOTED(DIRMNGR_SOCK_NAME, \"S.dirmngr\",\n                   [The name of the dirmngr socket])\nAC_DEFINE_UNQUOTED(DIRMNGR_DEFAULT_KEYSERVER,\n                   \"hkps://hkps.pool.sks-keyservers.net\",\n      [The default keyserver for dirmngr to use, if none is explicitly given])\n\nAC_DEFINE_UNQUOTED(GPGEXT_GPG, \"gpg\", [The standard binary file suffix])\n\nif test \"$have_w32_system\" = yes; then\n  AC_DEFINE_UNQUOTED(GNUPG_REGISTRY_DIR, \"Software\\\\\\\\GNU\\\\\\\\GnuPG\",\n                     [The directory part of the W32 registry keys])\nfi\n\n\n#\n# Provide information about the build.\n#\nBUILD_REVISION=\"mym4_revision\"\nAC_SUBST(BUILD_REVISION)\nAC_DEFINE_UNQUOTED(BUILD_REVISION, \"$BUILD_REVISION\",\n                   [GIT commit id revision used to build this package])\n\nchangequote(,)dnl\nBUILD_VERSION=`echo \"$VERSION\" | sed 's/\\([0-9.]*\\).*/\\1./'`\nchangequote([,])dnl\nBUILD_VERSION=\"${BUILD_VERSION}mym4_revision_dec\"\nBUILD_FILEVERSION=`echo \"${BUILD_VERSION}\" | tr . ,`\nAC_SUBST(BUILD_VERSION)\nAC_SUBST(BUILD_FILEVERSION)\n\nAC_ARG_ENABLE([build-timestamp],\n  AC_HELP_STRING([--enable-build-timestamp],\n                 [set an explicit build timestamp for reproducibility.\n                  (default is the current time in ISO-8601 format)]),\n     [if test \"$enableval\" = \"yes\"; then\n        BUILD_TIMESTAMP=`date -u +%Y-%m-%dT%H:%M+0000 2>/dev/null || date`\n      else\n        BUILD_TIMESTAMP=\"$enableval\"\n      fi\n      BUILD_HOSTNAME=\"$ac_hostname\"],\n     [BUILD_TIMESTAMP=\"<none>\"\n      BUILD_HOSTNAME=\"<anon>\"])\nAC_SUBST(BUILD_TIMESTAMP)\nAC_DEFINE_UNQUOTED(BUILD_TIMESTAMP, \"$BUILD_TIMESTAMP\",\n                   [The time this package was configured for a build])\nAC_SUBST(BUILD_HOSTNAME)\n\n\n#\n# Print errors here so that they are visible all\n# together and the user can acquire them all together.\n#\ndie=no\nif test \"$have_gpg_error\" = \"no\"; then\n   die=yes\n   AC_MSG_NOTICE([[\n***\n*** You need libgpg-error to build this program.\n**  This library is for example available at\n***   https://gnupg.org/ftp/gcrypt/libgpg-error\n*** (at least version $NEED_GPG_ERROR_VERSION is required.)\n***]])\nfi\nif test \"$have_libgcrypt\" = \"no\"; then\n   die=yes\n   AC_MSG_NOTICE([[\n***\n*** You need libgcrypt to build this program.\n**  This library is for example available at\n***   https://gnupg.org/ftp/gcrypt/libgcrypt/\n*** (at least version $NEED_LIBGCRYPT_VERSION (API $NEED_LIBGCRYPT_API) is required.)\n***]])\nfi\nif test \"$have_libassuan\" = \"no\"; then\n   die=yes\n   AC_MSG_NOTICE([[\n***\n*** You need libassuan to build this program.\n*** This library is for example available at\n***   https://gnupg.org/ftp/gcrypt/libassuan/\n*** (at least version $NEED_LIBASSUAN_VERSION (API $NEED_LIBASSUAN_API) is required).\n***]])\nfi\nif test \"$have_ksba\" = \"no\"; then\n    die=yes\n    AC_MSG_NOTICE([[\n***\n*** You need libksba to build this program.\n*** This library is for example available at\n***   https://gnupg.org/ftp/gcrypt/libksba/\n*** (at least version $NEED_KSBA_VERSION using API $NEED_KSBA_API is required).\n***]])\nfi\nif test \"$gnupg_have_ldap\" = yes; then\n  if test \"$have_w32ce_system\" = yes; then\n    AC_MSG_NOTICE([[\n*** Note that CeGCC might be broken, a package fixing this is:\n***    http://files.kolab.org/local/windows-ce/\n***                           source/wldap32_0.1-mingw32ce.orig.tar.gz\n***                           binary/wldap32-ce-arm-dev_0.1-1_all.deb\n***]])\n   fi\nfi\nif test \"$have_npth\" = \"no\"; then\n    die=yes\n    AC_MSG_NOTICE([[\n***\n*** It is now required to build with support for the\n*** New Portable Threads Library (nPth). Please install this\n*** library first.  The library is for example available at\n***   https://gnupg.org/ftp/gcrypt/npth/\n*** (at least version $NEED_NPTH_VERSION (API $NEED_NPTH_API) is required).\n***]])\nfi\n\nif test \"$require_iconv\" = yes; then\n  if test \"$am_func_iconv\" != yes; then\n    die=yes\n    AC_MSG_NOTICE([[\n***\n*** The system does not provide a working iconv function.  Please\n*** install a suitable library; for example GNU Libiconv which is\n*** available at:\n***   https://ftp.gnu.org/gnu/libiconv/\n***]])\n  fi\nfi\n\nif test \"$use_ccid_driver\" = yes; then\n  if test \"$have_libusb\" != yes; then\n    die=yes\n    AC_MSG_NOTICE([[\n***\n*** You need libusb to build the internal ccid driver.  Please\n*** install a libusb suitable for your system.\n***]])\n  fi\nfi\n\nif test \"$die\" = \"yes\"; then\n    AC_MSG_ERROR([[\n***\n*** Required libraries not found. Please consult the above messages\n*** and install them before running configure again.\n***]])\nfi\n\n\n\nAC_CONFIG_FILES([ m4/Makefile\nMakefile\npo/Makefile.in\ncommon/Makefile\ncommon/w32info-rc.h\nregexp/Makefile\nkbx/Makefile\ng10/Makefile\nsm/Makefile\nagent/Makefile\nscd/Makefile\ng13/Makefile\ndirmngr/Makefile\ntools/gpg-zip\ntools/Makefile\ndoc/Makefile\ntests/Makefile\ntests/gpgscm/Makefile\ntests/openpgp/Makefile\ntests/migrations/Makefile\ntests/gpgsm/Makefile\ntests/gpgme/Makefile\ntests/pkits/Makefile\ng10/gpg.w32-manifest\n])\n\n\nAC_OUTPUT\n\n\necho \"\n        GnuPG v${VERSION} has been configured as follows:\n\n        Revision:  mym4_revision  (mym4_revision_dec)\n        Platform:  $PRINTABLE_OS_NAME ($host)\n\n        OpenPGP:   $build_gpg\n        S/MIME:    $build_gpgsm\n        Agent:     $build_agent\n        Smartcard: $build_scdaemon $build_scdaemon_extra\n        G13:       $build_g13\n        Dirmngr:   $build_dirmngr\n        Gpgtar:    $build_gpgtar\n        WKS tools: $build_wks_tools\n\n        Protect tool:      $show_gnupg_protect_tool_pgm\n        LDAP wrapper:      $show_gnupg_dirmngr_ldap_pgm\n        Default agent:     $show_gnupg_agent_pgm\n        Default pinentry:  $show_gnupg_pinentry_pgm\n        Default scdaemon:  $show_gnupg_scdaemon_pgm\n        Default dirmngr:   $show_gnupg_dirmngr_pgm\n\n        Dirmngr auto start:  $dirmngr_auto_start\n        Readline support:    $gnupg_cv_have_readline\n        LDAP support:        $gnupg_have_ldap\n        TLS support:         $use_tls_library\n        TOFU support:        $use_tofu\n        Tor support:         $show_tor_support\n\"\nif test \"x${gpg_config_script_warn}\" != x; then\ncat <<G10EOF\n        Warning: Mismatches between the target platform and the\n                 to be used libraries have been detected for:\n                  ${gpg_config_script_warn}\n                 Please check above for more warning messages.\n\nG10EOF\nfi\nif test \"${build_gpg}\" != \"yes\"; then\ncat <<G10EOF\n        Warning: The component \"gpg\" is used by other components as\n                 well as for the test suite.  You have disabled\n                 this component and thus other things won't work.\n\nG10EOF\nfi\nif test \"${run_tests}\" != \"yes\"; then\ncat <<G10EOF\n        Warning: The use of the test suite has been disabled!\n                 This is in almost all cases a bad idea.  Take care.\n\nG10EOF\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/scd/apdu.c": "/* apdu.c - ISO 7816 APDU functions and low level I/O\n * Copyright (C) 2003, 2004, 2008, 2009, 2010,\n *               2011 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * GnuPG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n/* NOTE: This module is also used by other software, thus the use of\n   the macro USE_NPTH is mandatory.  For GnuPG this macro is\n   guaranteed to be defined true. */\n\n#include <config.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <signal.h>\n#ifdef USE_NPTH\n# include <unistd.h>\n# include <fcntl.h>\n# include <npth.h>\n#endif\n\n\n/* If requested include the definitions for the remote APDU protocol\n   code. */\n#ifdef USE_G10CODE_RAPDU\n#include \"rapdu.h\"\n#endif /*USE_G10CODE_RAPDU*/\n\n#if defined(GNUPG_SCD_MAIN_HEADER)\n#include GNUPG_SCD_MAIN_HEADER\n#elif GNUPG_MAJOR_VERSION == 1\n/* This is used with GnuPG version < 1.9.  The code has been source\n   copied from the current GnuPG >= 1.9  and is maintained over\n   there. */\n#include \"../common/options.h\"\n#include \"errors.h\"\n#include \"memory.h\"\n#include \"../common/util.h\"\n#include \"../common/i18n.h\"\n#include \"dynload.h\"\n#include \"cardglue.h\"\n#else /* GNUPG_MAJOR_VERSION != 1 */\n#include \"scdaemon.h\"\n#include \"../common/exechelp.h\"\n#endif /* GNUPG_MAJOR_VERSION != 1 */\n#include \"../common/host2net.h\"\n\n#include \"iso7816.h\"\n#include \"apdu.h\"\n#define CCID_DRIVER_INCLUDE_USB_IDS 1\n#include \"ccid-driver.h\"\n\nstruct dev_list {\n  struct ccid_dev_table *ccid_table;\n  const char *portstr;\n  int idx;\n  int idx_max;\n};\n\n#define MAX_READER 4 /* Number of readers we support concurrently. */\n\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#define DLSTDCALL __stdcall\n#else\n#define DLSTDCALL\n#endif\n\n#if defined(__APPLE__) || defined(_WIN32) || defined(__CYGWIN__)\ntypedef unsigned int pcsc_dword_t;\n#else\ntypedef unsigned long pcsc_dword_t;\n#endif\n\n/* A structure to collect information pertaining to one reader\n   slot. */\nstruct reader_table_s {\n  int used;            /* True if slot is used. */\n  unsigned short port; /* Port number:  0 = unused, 1 - dev/tty */\n\n  /* Function pointers initialized to the various backends.  */\n  int (*connect_card)(int);\n  int (*disconnect_card)(int);\n  int (*close_reader)(int);\n  int (*reset_reader)(int);\n  int (*get_status_reader)(int, unsigned int *, int);\n  int (*send_apdu_reader)(int,unsigned char *,size_t,\n                          unsigned char *, size_t *, pininfo_t *);\n  int (*check_pinpad)(int, int, pininfo_t *);\n  void (*dump_status_reader)(int);\n  int (*set_progress_cb)(int, gcry_handler_progress_t, void*);\n  int (*set_prompt_cb)(int, void (*) (void *, int), void*);\n  int (*pinpad_verify)(int, int, int, int, int, pininfo_t *);\n  int (*pinpad_modify)(int, int, int, int, int, pininfo_t *);\n\n  struct {\n    ccid_driver_t handle;\n  } ccid;\n  struct {\n    long context;\n    long card;\n    pcsc_dword_t protocol;\n    pcsc_dword_t verify_ioctl;\n    pcsc_dword_t modify_ioctl;\n    int pinmin;\n    int pinmax;\n    pcsc_dword_t current_state;\n  } pcsc;\n#ifdef USE_G10CODE_RAPDU\n  struct {\n    rapdu_t handle;\n  } rapdu;\n#endif /*USE_G10CODE_RAPDU*/\n  char *rdrname;     /* Name of the connected reader or NULL if unknown. */\n  unsigned int is_t0:1;     /* True if we know that we are running T=0. */\n  unsigned int is_spr532:1; /* True if we know that the reader is a SPR532.  */\n  unsigned int pinpad_varlen_supported:1;  /* True if we know that the reader\n                                              supports variable length pinpad\n                                              input.  */\n  unsigned int require_get_status:1;\n  unsigned char atr[33];\n  size_t atrlen;           /* A zero length indicates that the ATR has\n                              not yet been read; i.e. the card is not\n                              ready for use. */\n#ifdef USE_NPTH\n  npth_mutex_t lock;\n#endif\n};\ntypedef struct reader_table_s *reader_table_t;\n\n/* A global table to keep track of active readers. */\nstatic struct reader_table_s reader_table[MAX_READER];\n\n#ifdef USE_NPTH\nstatic npth_mutex_t reader_table_lock;\n#endif\n\n\n/* PC/SC constants and function pointer. */\n#define PCSC_SCOPE_USER      0\n#define PCSC_SCOPE_TERMINAL  1\n#define PCSC_SCOPE_SYSTEM    2\n#define PCSC_SCOPE_GLOBAL    3\n\n#define PCSC_PROTOCOL_T0     1\n#define PCSC_PROTOCOL_T1     2\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_PROTOCOL_RAW   0x00010000  /* The active protocol.  */\n#else\n# define PCSC_PROTOCOL_RAW   4\n#endif\n\n#define PCSC_SHARE_EXCLUSIVE 1\n#define PCSC_SHARE_SHARED    2\n#define PCSC_SHARE_DIRECT    3\n\n#define PCSC_LEAVE_CARD      0\n#define PCSC_RESET_CARD      1\n#define PCSC_UNPOWER_CARD    2\n#define PCSC_EJECT_CARD      3\n\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_UNKNOWN    0x0000  /* The driver is not aware of the status.  */\n# define PCSC_ABSENT     0x0001  /* Card is absent.  */\n# define PCSC_PRESENT    0x0002  /* Card is present.  */\n# define PCSC_SWALLOWED  0x0003  /* Card is present and electrical connected. */\n# define PCSC_POWERED    0x0004  /* Card is powered.  */\n# define PCSC_NEGOTIABLE 0x0005  /* Card is awaiting PTS.  */\n# define PCSC_SPECIFIC   0x0006  /* Card is ready for use.  */\n#else\n# define PCSC_UNKNOWN    0x0001\n# define PCSC_ABSENT     0x0002  /* Card is absent.  */\n# define PCSC_PRESENT    0x0004  /* Card is present.  */\n# define PCSC_SWALLOWED  0x0008  /* Card is present and electrical connected. */\n# define PCSC_POWERED    0x0010  /* Card is powered.  */\n# define PCSC_NEGOTIABLE 0x0020  /* Card is awaiting PTS.  */\n# define PCSC_SPECIFIC   0x0040  /* Card is ready for use.  */\n#endif\n\n#define PCSC_STATE_UNAWARE     0x0000  /* Want status.  */\n#define PCSC_STATE_IGNORE      0x0001  /* Ignore this reader.  */\n#define PCSC_STATE_CHANGED     0x0002  /* State has changed.  */\n#define PCSC_STATE_UNKNOWN     0x0004  /* Reader unknown.  */\n#define PCSC_STATE_UNAVAILABLE 0x0008  /* Status unavailable.  */\n#define PCSC_STATE_EMPTY       0x0010  /* Card removed.  */\n#define PCSC_STATE_PRESENT     0x0020  /* Card inserted.  */\n#define PCSC_STATE_ATRMATCH    0x0040  /* ATR matches card. */\n#define PCSC_STATE_EXCLUSIVE   0x0080  /* Exclusive Mode.  */\n#define PCSC_STATE_INUSE       0x0100  /* Shared mode.  */\n#define PCSC_STATE_MUTE        0x0200  /* Unresponsive card.  */\n#ifdef HAVE_W32_SYSTEM\n# define PCSC_STATE_UNPOWERED  0x0400  /* Card not powerred up.  */\n#endif\n\n/* Some PC/SC error codes.  */\n#define PCSC_E_CANCELLED               0x80100002\n#define PCSC_E_CANT_DISPOSE            0x8010000E\n#define PCSC_E_INSUFFICIENT_BUFFER     0x80100008\n#define PCSC_E_INVALID_ATR             0x80100015\n#define PCSC_E_INVALID_HANDLE          0x80100003\n#define PCSC_E_INVALID_PARAMETER       0x80100004\n#define PCSC_E_INVALID_TARGET          0x80100005\n#define PCSC_E_INVALID_VALUE           0x80100011\n#define PCSC_E_NO_MEMORY               0x80100006\n#define PCSC_E_UNKNOWN_READER          0x80100009\n#define PCSC_E_TIMEOUT                 0x8010000A\n#define PCSC_E_SHARING_VIOLATION       0x8010000B\n#define PCSC_E_NO_SMARTCARD            0x8010000C\n#define PCSC_E_UNKNOWN_CARD            0x8010000D\n#define PCSC_E_PROTO_MISMATCH          0x8010000F\n#define PCSC_E_NOT_READY               0x80100010\n#define PCSC_E_SYSTEM_CANCELLED        0x80100012\n#define PCSC_E_NOT_TRANSACTED          0x80100016\n#define PCSC_E_READER_UNAVAILABLE      0x80100017\n#define PCSC_E_NO_SERVICE              0x8010001D\n#define PCSC_E_SERVICE_STOPPED         0x8010001E\n#define PCSC_W_RESET_CARD              0x80100068\n#define PCSC_W_REMOVED_CARD            0x80100069\n\n/* Fix pcsc-lite ABI incompatibility.  */\n#ifndef SCARD_CTL_CODE\n#ifdef _WIN32\n#include <winioctl.h>\n#define SCARD_CTL_CODE(code) CTL_CODE(FILE_DEVICE_SMARTCARD, (code), \\\n                                      METHOD_BUFFERED, FILE_ANY_ACCESS)\n#else\n#define SCARD_CTL_CODE(code) (0x42000000 + (code))\n#endif\n#endif\n\n#define CM_IOCTL_GET_FEATURE_REQUEST     SCARD_CTL_CODE(3400)\n#define CM_IOCTL_VENDOR_IFD_EXCHANGE     SCARD_CTL_CODE(1)\n#define FEATURE_VERIFY_PIN_DIRECT        0x06\n#define FEATURE_MODIFY_PIN_DIRECT        0x07\n#define FEATURE_GET_TLV_PROPERTIES       0x12\n\n#define PCSCv2_PART10_PROPERTY_bEntryValidationCondition 2\n#define PCSCv2_PART10_PROPERTY_bTimeOut2                 3\n#define PCSCv2_PART10_PROPERTY_bMinPINSize               6\n#define PCSCv2_PART10_PROPERTY_bMaxPINSize               7\n#define PCSCv2_PART10_PROPERTY_wIdVendor                11\n#define PCSCv2_PART10_PROPERTY_wIdProduct               12\n\n\n/* The PC/SC error is defined as a long as per specs.  Due to left\n   shifts bit 31 will get sign extended.  We use this mask to fix\n   it. */\n#define PCSC_ERR_MASK(a)  ((a) & 0xffffffff)\n\n\nstruct pcsc_io_request_s\n{\n  unsigned long protocol;\n  unsigned long pci_len;\n};\n\ntypedef struct pcsc_io_request_s *pcsc_io_request_t;\n\n#ifdef __APPLE__\n#pragma pack(1)\n#endif\n\nstruct pcsc_readerstate_s\n{\n  const char *reader;\n  void *user_data;\n  pcsc_dword_t current_state;\n  pcsc_dword_t event_state;\n  pcsc_dword_t atrlen;\n  unsigned char atr[33];\n};\n\n#ifdef __APPLE__\n#pragma pack()\n#endif\n\ntypedef struct pcsc_readerstate_s *pcsc_readerstate_t;\n\nlong (* DLSTDCALL pcsc_establish_context) (pcsc_dword_t scope,\n                                           const void *reserved1,\n                                           const void *reserved2,\n                                           long *r_context);\nlong (* DLSTDCALL pcsc_release_context) (long context);\nlong (* DLSTDCALL pcsc_list_readers) (long context,\n                                      const char *groups,\n                                      char *readers, pcsc_dword_t*readerslen);\nlong (* DLSTDCALL pcsc_get_status_change) (long context,\n                                           pcsc_dword_t timeout,\n                                           pcsc_readerstate_t readerstates,\n                                           pcsc_dword_t nreaderstates);\nlong (* DLSTDCALL pcsc_connect) (long context,\n                                 const char *reader,\n                                 pcsc_dword_t share_mode,\n                                 pcsc_dword_t preferred_protocols,\n                                 long *r_card,\n                                 pcsc_dword_t *r_active_protocol);\nlong (* DLSTDCALL pcsc_reconnect) (long card,\n                                   pcsc_dword_t share_mode,\n                                   pcsc_dword_t preferred_protocols,\n                                   pcsc_dword_t initialization,\n                                   pcsc_dword_t *r_active_protocol);\nlong (* DLSTDCALL pcsc_disconnect) (long card,\n                                    pcsc_dword_t disposition);\nlong (* DLSTDCALL pcsc_status) (long card,\n                                char *reader, pcsc_dword_t *readerlen,\n                                pcsc_dword_t *r_state,\n                                pcsc_dword_t *r_protocol,\n                                unsigned char *atr, pcsc_dword_t *atrlen);\nlong (* DLSTDCALL pcsc_begin_transaction) (long card);\nlong (* DLSTDCALL pcsc_end_transaction) (long card,\n                                         pcsc_dword_t disposition);\nlong (* DLSTDCALL pcsc_transmit) (long card,\n                                  const pcsc_io_request_t send_pci,\n                                  const unsigned char *send_buffer,\n                                  pcsc_dword_t send_len,\n                                  pcsc_io_request_t recv_pci,\n                                  unsigned char *recv_buffer,\n                                  pcsc_dword_t *recv_len);\nlong (* DLSTDCALL pcsc_set_timeout) (long context,\n                                     pcsc_dword_t timeout);\nlong (* DLSTDCALL pcsc_control) (long card,\n                                 pcsc_dword_t control_code,\n                                 const void *send_buffer,\n                                 pcsc_dword_t send_len,\n                                 void *recv_buffer,\n                                 pcsc_dword_t recv_len,\n                                 pcsc_dword_t *bytes_returned);\n\n\n/*  Prototypes.  */\nstatic int pcsc_vendor_specific_init (int slot);\nstatic int pcsc_get_status (int slot, unsigned int *status, int on_wire);\nstatic int reset_pcsc_reader (int slot);\nstatic int apdu_get_status_internal (int slot, int hang, unsigned int *status,\n                                     int on_wire);\nstatic int check_pcsc_pinpad (int slot, int command, pininfo_t *pininfo);\nstatic int pcsc_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                               pininfo_t *pininfo);\nstatic int pcsc_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                               pininfo_t *pininfo);\n\n\n\f\n/*\n      Helper\n */\n\nstatic int\nlock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_lock (&reader_table[slot].lock);\n  if (err)\n    {\n      log_error (\"failed to acquire apdu lock: %s\\n\", strerror (err));\n      return SW_HOST_LOCKING_FAILED;\n    }\n#endif /*USE_NPTH*/\n  return 0;\n}\n\nstatic int\ntrylock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_trylock (&reader_table[slot].lock);\n  if (err == EBUSY)\n    return SW_HOST_BUSY;\n  else if (err)\n    {\n      log_error (\"failed to acquire apdu lock: %s\\n\", strerror (err));\n      return SW_HOST_LOCKING_FAILED;\n    }\n#endif /*USE_NPTH*/\n  return 0;\n}\n\nstatic void\nunlock_slot (int slot)\n{\n#ifdef USE_NPTH\n  int err;\n\n  err = npth_mutex_unlock (&reader_table[slot].lock);\n  if (err)\n    log_error (\"failed to release apdu lock: %s\\n\", strerror (errno));\n#endif /*USE_NPTH*/\n}\n\n\n/* Find an unused reader slot for PORTSTR and put it into the reader\n   table.  Return -1 on error or the index into the reader table.\n   Acquire slot's lock on successful return.  Caller needs to unlock it.  */\nstatic int\nnew_reader_slot (void)\n{\n  int i, reader = -1;\n\n  for (i=0; i < MAX_READER; i++)\n    if (!reader_table[i].used)\n      {\n        reader = i;\n        reader_table[reader].used = 1;\n        break;\n      }\n\n  if (reader == -1)\n    {\n      log_error (\"new_reader_slot: out of slots\\n\");\n      return -1;\n    }\n\n  if (lock_slot (reader))\n    {\n      reader_table[reader].used = 0;\n      return -1;\n    }\n\n  reader_table[reader].connect_card = NULL;\n  reader_table[reader].disconnect_card = NULL;\n  reader_table[reader].close_reader = NULL;\n  reader_table[reader].reset_reader = NULL;\n  reader_table[reader].get_status_reader = NULL;\n  reader_table[reader].send_apdu_reader = NULL;\n  reader_table[reader].check_pinpad = check_pcsc_pinpad;\n  reader_table[reader].dump_status_reader = NULL;\n  reader_table[reader].set_progress_cb = NULL;\n  reader_table[reader].set_prompt_cb = NULL;\n  reader_table[reader].pinpad_verify = pcsc_pinpad_verify;\n  reader_table[reader].pinpad_modify = pcsc_pinpad_modify;\n\n  reader_table[reader].is_t0 = 1;\n  reader_table[reader].is_spr532 = 0;\n  reader_table[reader].pinpad_varlen_supported = 0;\n  reader_table[reader].require_get_status = 1;\n  reader_table[reader].pcsc.verify_ioctl = 0;\n  reader_table[reader].pcsc.modify_ioctl = 0;\n  reader_table[reader].pcsc.pinmin = -1;\n  reader_table[reader].pcsc.pinmax = -1;\n  reader_table[reader].pcsc.current_state = PCSC_STATE_UNAWARE;\n\n  return reader;\n}\n\n\nstatic void\ndump_reader_status (int slot)\n{\n  if (!opt.verbose)\n    return;\n\n  if (reader_table[slot].dump_status_reader)\n    reader_table[slot].dump_status_reader (slot);\n\n  if (reader_table[slot].atrlen)\n    {\n      log_info (\"slot %d: ATR=\", slot);\n      log_printhex (reader_table[slot].atr, reader_table[slot].atrlen, \"\");\n    }\n}\n\n\n\nstatic const char *\nhost_sw_string (long err)\n{\n  switch (err)\n    {\n    case 0: return \"okay\";\n    case SW_HOST_OUT_OF_CORE: return \"out of core\";\n    case SW_HOST_INV_VALUE: return \"invalid value\";\n    case SW_HOST_NO_DRIVER: return \"no driver\";\n    case SW_HOST_NOT_SUPPORTED: return \"not supported\";\n    case SW_HOST_LOCKING_FAILED: return \"locking failed\";\n    case SW_HOST_BUSY: return \"busy\";\n    case SW_HOST_NO_CARD: return \"no card\";\n    case SW_HOST_CARD_INACTIVE: return \"card inactive\";\n    case SW_HOST_CARD_IO_ERROR: return \"card I/O error\";\n    case SW_HOST_GENERAL_ERROR: return \"general error\";\n    case SW_HOST_NO_READER: return \"no reader\";\n    case SW_HOST_ABORTED: return \"aborted\";\n    case SW_HOST_NO_PINPAD: return \"no pinpad\";\n    case SW_HOST_ALREADY_CONNECTED: return \"already connected\";\n    case SW_HOST_CANCELLED: return \"cancelled\";\n    default: return \"unknown host status error\";\n    }\n}\n\n\nconst char *\napdu_strerror (int rc)\n{\n  switch (rc)\n    {\n    case SW_EOF_REACHED    : return \"eof reached\";\n    case SW_EEPROM_FAILURE : return \"eeprom failure\";\n    case SW_WRONG_LENGTH   : return \"wrong length\";\n    case SW_CHV_WRONG      : return \"CHV wrong\";\n    case SW_CHV_BLOCKED    : return \"CHV blocked\";\n    case SW_REF_DATA_INV   : return \"referenced data invalidated\";\n    case SW_USE_CONDITIONS : return \"use conditions not satisfied\";\n    case SW_BAD_PARAMETER  : return \"bad parameter\";\n    case SW_NOT_SUPPORTED  : return \"not supported\";\n    case SW_FILE_NOT_FOUND : return \"file not found\";\n    case SW_RECORD_NOT_FOUND:return \"record not found\";\n    case SW_REF_NOT_FOUND  : return \"reference not found\";\n    case SW_NOT_ENOUGH_MEMORY: return \"not enough memory space in the file\";\n    case SW_INCONSISTENT_LC: return \"Lc inconsistent with TLV structure.\";\n    case SW_INCORRECT_P0_P1: return \"incorrect parameters P0,P1\";\n    case SW_BAD_LC         : return \"Lc inconsistent with P0,P1\";\n    case SW_BAD_P0_P1      : return \"bad P0,P1\";\n    case SW_INS_NOT_SUP    : return \"instruction not supported\";\n    case SW_CLA_NOT_SUP    : return \"class not supported\";\n    case SW_SUCCESS        : return \"success\";\n    default:\n      if ((rc & ~0x00ff) == SW_MORE_DATA)\n        return \"more data available\";\n      if ( (rc & 0x10000) )\n        return host_sw_string (rc);\n      return \"unknown status error\";\n    }\n}\n\f\n/*\n       PC/SC Interface\n */\n\nstatic const char *\npcsc_error_string (long err)\n{\n  const char *s;\n\n  if (!err)\n    return \"okay\";\n  if ((err & 0x80100000) != 0x80100000)\n    return \"invalid PC/SC error code\";\n  err &= 0xffff;\n  switch (err)\n    {\n    case 0x0002: s = \"cancelled\"; break;\n    case 0x000e: s = \"can't dispose\"; break;\n    case 0x0008: s = \"insufficient buffer\"; break;\n    case 0x0015: s = \"invalid ATR\"; break;\n    case 0x0003: s = \"invalid handle\"; break;\n    case 0x0004: s = \"invalid parameter\"; break;\n    case 0x0005: s = \"invalid target\"; break;\n    case 0x0011: s = \"invalid value\"; break;\n    case 0x0006: s = \"no memory\"; break;\n    case 0x0013: s = \"comm error\"; break;\n    case 0x0001: s = \"internal error\"; break;\n    case 0x0014: s = \"unknown error\"; break;\n    case 0x0007: s = \"waited too long\"; break;\n    case 0x0009: s = \"unknown reader\"; break;\n    case 0x000a: s = \"timeout\"; break;\n    case 0x000b: s = \"sharing violation\"; break;\n    case 0x000c: s = \"no smartcard\"; break;\n    case 0x000d: s = \"unknown card\"; break;\n    case 0x000f: s = \"proto mismatch\"; break;\n    case 0x0010: s = \"not ready\"; break;\n    case 0x0012: s = \"system cancelled\"; break;\n    case 0x0016: s = \"not transacted\"; break;\n    case 0x0017: s = \"reader unavailable\"; break;\n    case 0x0065: s = \"unsupported card\"; break;\n    case 0x0066: s = \"unresponsive card\"; break;\n    case 0x0067: s = \"unpowered card\"; break;\n    case 0x0068: s = \"reset card\"; break;\n    case 0x0069: s = \"removed card\"; break;\n    case 0x006a: s = \"inserted card\"; break;\n    case 0x001f: s = \"unsupported feature\"; break;\n    case 0x0019: s = \"PCI too small\"; break;\n    case 0x001a: s = \"reader unsupported\"; break;\n    case 0x001b: s = \"duplicate reader\"; break;\n    case 0x001c: s = \"card unsupported\"; break;\n    case 0x001d: s = \"no service\"; break;\n    case 0x001e: s = \"service stopped\"; break;\n    default:     s = \"unknown PC/SC error code\"; break;\n    }\n  return s;\n}\n\n/* Map PC/SC error codes to our special host status words.  */\nstatic int\npcsc_error_to_sw (long ec)\n{\n  int rc;\n\n  switch ( PCSC_ERR_MASK (ec) )\n    {\n    case 0:  rc = 0; break;\n\n    case PCSC_E_CANCELLED:           rc = SW_HOST_CANCELLED; break;\n    case PCSC_E_NO_MEMORY:           rc = SW_HOST_OUT_OF_CORE; break;\n    case PCSC_E_TIMEOUT:             rc = SW_HOST_CARD_IO_ERROR; break;\n    case PCSC_E_NO_SERVICE:\n    case PCSC_E_SERVICE_STOPPED:\n    case PCSC_E_UNKNOWN_READER:      rc = SW_HOST_NO_READER; break;\n    case PCSC_E_SHARING_VIOLATION:   rc = SW_HOST_LOCKING_FAILED; break;\n    case PCSC_E_NO_SMARTCARD:        rc = SW_HOST_NO_CARD; break;\n    case PCSC_W_REMOVED_CARD:        rc = SW_HOST_NO_CARD; break;\n\n    case PCSC_E_INVALID_TARGET:\n    case PCSC_E_INVALID_VALUE:\n    case PCSC_E_INVALID_HANDLE:\n    case PCSC_E_INVALID_PARAMETER:\n    case PCSC_E_INSUFFICIENT_BUFFER: rc = SW_HOST_INV_VALUE; break;\n\n    default:  rc = SW_HOST_GENERAL_ERROR; break;\n    }\n\n  return rc;\n}\n\nstatic void\ndump_pcsc_reader_status (int slot)\n{\n  if (reader_table[slot].pcsc.card)\n    {\n      log_info (\"reader slot %d: active protocol:\", slot);\n      if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T0))\n        log_printf (\" T0\");\n      else if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T1))\n        log_printf (\" T1\");\n      else if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_RAW))\n        log_printf (\" raw\");\n      log_printf (\"\\n\");\n    }\n  else\n    log_info (\"reader slot %d: not connected\\n\", slot);\n}\n\n\nstatic int\npcsc_get_status (int slot, unsigned int *status, int on_wire)\n{\n  long err;\n  struct pcsc_readerstate_s rdrstates[1];\n\n  (void)on_wire;\n  memset (rdrstates, 0, sizeof *rdrstates);\n  rdrstates[0].reader = reader_table[slot].rdrname;\n  rdrstates[0].current_state = reader_table[slot].pcsc.current_state;\n  err = pcsc_get_status_change (reader_table[slot].pcsc.context,\n                                0,\n                                rdrstates, 1);\n  if (err == PCSC_E_TIMEOUT)\n    err = 0; /* Timeout is no error here.  */\n  if (err)\n    {\n      log_error (\"pcsc_get_status_change failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return pcsc_error_to_sw (err);\n    }\n\n  if ((rdrstates[0].event_state & PCSC_STATE_CHANGED))\n    reader_table[slot].pcsc.current_state =\n      (rdrstates[0].event_state & ~PCSC_STATE_CHANGED);\n\n  if (DBG_CARD_IO)\n    log_debug\n      (\"pcsc_get_status_change: %s%s%s%s%s%s%s%s%s%s\\n\",\n       (rdrstates[0].event_state & PCSC_STATE_IGNORE)? \" ignore\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_CHANGED)? \" changed\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_UNKNOWN)? \" unknown\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_UNAVAILABLE)?\" unavail\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_EMPTY)? \" empty\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_PRESENT)? \" present\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_ATRMATCH)? \" atr\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_EXCLUSIVE)? \" excl\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_INUSE)? \" inuse\":\"\",\n       (rdrstates[0].event_state & PCSC_STATE_MUTE)? \" mute\":\"\" );\n\n  *status = 0;\n  if ( (reader_table[slot].pcsc.current_state & PCSC_STATE_PRESENT) )\n    {\n      *status |= APDU_CARD_PRESENT;\n      if ( !(reader_table[slot].pcsc.current_state & PCSC_STATE_MUTE) )\n        *status |= APDU_CARD_ACTIVE;\n    }\n#ifndef HAVE_W32_SYSTEM\n  /* We indicate a useful card if it is not in use by another\n     application.  This is because we only use exclusive access\n     mode.  */\n  if ( (*status & (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n       == (APDU_CARD_PRESENT|APDU_CARD_ACTIVE)\n       && !(reader_table[slot].pcsc.current_state & PCSC_STATE_INUSE) )\n    *status |= APDU_CARD_USABLE;\n#else\n  /* Some winscard drivers may set EXCLUSIVE and INUSE at the same\n     time when we are the only user (SCM SCR335) under Windows.  */\n  if ((*status & (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n      == (APDU_CARD_PRESENT|APDU_CARD_ACTIVE))\n    *status |= APDU_CARD_USABLE;\n#endif\n\n  if (!on_wire && (rdrstates[0].event_state & PCSC_STATE_CHANGED))\n    /* Event like sleep/resume occurs, which requires RESET.  */\n    return SW_HOST_NO_READER;\n  else\n    return 0;\n}\n\n\n/* Send the APDU of length APDULEN to SLOT and return a maximum of\n   *BUFLEN data in BUFFER, the actual returned size will be stored at\n   BUFLEN.  Returns: A status word. */\nstatic int\npcsc_send_apdu (int slot, unsigned char *apdu, size_t apdulen,\n                unsigned char *buffer, size_t *buflen,\n                pininfo_t *pininfo)\n{\n  long err;\n  struct pcsc_io_request_s send_pci;\n  pcsc_dword_t recv_len;\n\n  (void)pininfo;\n\n  if (!reader_table[slot].atrlen\n      && (err = reset_pcsc_reader (slot)))\n    return err;\n\n  if (DBG_CARD_IO)\n    log_printhex (apdu, apdulen, \"  PCSC_data:\");\n\n  if ((reader_table[slot].pcsc.protocol & PCSC_PROTOCOL_T1))\n      send_pci.protocol = PCSC_PROTOCOL_T1;\n  else\n      send_pci.protocol = PCSC_PROTOCOL_T0;\n  send_pci.pci_len = sizeof send_pci;\n  recv_len = *buflen;\n  err = pcsc_transmit (reader_table[slot].pcsc.card,\n                       &send_pci, apdu, apdulen,\n                       NULL, buffer, &recv_len);\n  *buflen = recv_len;\n  if (err)\n    log_error (\"pcsc_transmit failed: %s (0x%lx)\\n\",\n               pcsc_error_string (err), err);\n\n  /* Handle fatal errors which require shutdown of reader.  */\n  if (err == PCSC_E_NOT_TRANSACTED || err == PCSC_W_RESET_CARD\n      || err == PCSC_W_REMOVED_CARD)\n    {\n      reader_table[slot].pcsc.current_state = PCSC_STATE_UNAWARE;\n      scd_kick_the_loop ();\n    }\n\n  return pcsc_error_to_sw (err);\n}\n\n\n/* Do some control with the value of IOCTL_CODE to the card inserted\n   to SLOT.  Input buffer is specified by CNTLBUF of length LEN.\n   Output buffer is specified by BUFFER of length *BUFLEN, and the\n   actual output size will be stored at BUFLEN.  Returns: A status word.\n   This routine is used for PIN pad input support.  */\nstatic int\ncontrol_pcsc (int slot, pcsc_dword_t ioctl_code,\n              const unsigned char *cntlbuf, size_t len,\n              unsigned char *buffer, pcsc_dword_t *buflen)\n{\n  long err;\n\n  err = pcsc_control (reader_table[slot].pcsc.card, ioctl_code,\n                      cntlbuf, len, buffer, buflen? *buflen:0, buflen);\n  if (err)\n    {\n      log_error (\"pcsc_control failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return pcsc_error_to_sw (err);\n    }\n\n  return 0;\n}\n\n\nstatic int\nclose_pcsc_reader (int slot)\n{\n  pcsc_release_context (reader_table[slot].pcsc.context);\n  return 0;\n}\n\n\n/* Connect a PC/SC card.  */\nstatic int\nconnect_pcsc_card (int slot)\n{\n  long err;\n\n  assert (slot >= 0 && slot < MAX_READER);\n\n  if (reader_table[slot].pcsc.card)\n    return SW_HOST_ALREADY_CONNECTED;\n\n  reader_table[slot].atrlen = 0;\n  reader_table[slot].is_t0 = 0;\n\n  err = pcsc_connect (reader_table[slot].pcsc.context,\n                      reader_table[slot].rdrname,\n                      PCSC_SHARE_EXCLUSIVE,\n                      PCSC_PROTOCOL_T0|PCSC_PROTOCOL_T1,\n                      &reader_table[slot].pcsc.card,\n                      &reader_table[slot].pcsc.protocol);\n  if (err)\n    {\n      reader_table[slot].pcsc.card = 0;\n      if (err != PCSC_E_NO_SMARTCARD)\n        log_error (\"pcsc_connect failed: %s (0x%lx)\\n\",\n                   pcsc_error_string (err), err);\n    }\n  else\n    {\n      char reader[250];\n      pcsc_dword_t readerlen, atrlen;\n      pcsc_dword_t card_state, card_protocol;\n\n      pcsc_vendor_specific_init (slot);\n\n      atrlen = DIM (reader_table[0].atr);\n      readerlen = sizeof reader -1 ;\n      err = pcsc_status (reader_table[slot].pcsc.card,\n                         reader, &readerlen,\n                         &card_state, &card_protocol,\n                         reader_table[slot].atr, &atrlen);\n      if (err)\n        log_error (\"pcsc_status failed: %s (0x%lx) %lu\\n\",\n                   pcsc_error_string (err), err, (long unsigned int)readerlen);\n      else\n        {\n          if (atrlen > DIM (reader_table[0].atr))\n            log_bug (\"ATR returned by pcsc_status is too large\\n\");\n          reader_table[slot].atrlen = atrlen;\n          reader_table[slot].is_t0 = !!(card_protocol & PCSC_PROTOCOL_T0);\n        }\n    }\n\n  dump_reader_status (slot);\n  return pcsc_error_to_sw (err);\n}\n\n\nstatic int\ndisconnect_pcsc_card (int slot)\n{\n  long err;\n\n  assert (slot >= 0 && slot < MAX_READER);\n\n  if (!reader_table[slot].pcsc.card)\n    return 0;\n\n  err = pcsc_disconnect (reader_table[slot].pcsc.card, PCSC_LEAVE_CARD);\n  if (err)\n    {\n      log_error (\"pcsc_disconnect failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      return SW_HOST_CARD_IO_ERROR;\n    }\n  reader_table[slot].pcsc.card = 0;\n  return 0;\n}\n\n\n/* Send an PC/SC reset command and return a status word on error or 0\n   on success. */\nstatic int\nreset_pcsc_reader (int slot)\n{\n  int sw;\n\n  sw = disconnect_pcsc_card (slot);\n  if (!sw)\n    sw = connect_pcsc_card (slot);\n\n  return sw;\n}\n\n\n/* Examine reader specific parameters and initialize.  This is mostly\n   for pinpad input.  Called at opening the connection to the reader.  */\nstatic int\npcsc_vendor_specific_init (int slot)\n{\n  unsigned char buf[256];\n  pcsc_dword_t len;\n  int sw;\n  int vendor = 0;\n  int product = 0;\n  pcsc_dword_t get_tlv_ioctl = (pcsc_dword_t)-1;\n  unsigned char *p;\n\n  len = sizeof (buf);\n  sw = control_pcsc (slot, CM_IOCTL_GET_FEATURE_REQUEST, NULL, 0, buf, &len);\n  if (sw)\n    {\n      log_error (\"pcsc_vendor_specific_init: GET_FEATURE_REQUEST failed: %d\\n\",\n                 sw);\n      return SW_NOT_SUPPORTED;\n    }\n  else\n    {\n      p = buf;\n      while (p < buf + len)\n        {\n          unsigned char code = *p++;\n          int l = *p++;\n          unsigned int v = 0;\n\n          if (l == 1)\n            v = p[0];\n          else if (l == 2)\n            v = buf16_to_uint (p);\n          else if (l == 4)\n            v = buf32_to_uint (p);\n\n          if (code == FEATURE_VERIFY_PIN_DIRECT)\n            reader_table[slot].pcsc.verify_ioctl = v;\n          else if (code == FEATURE_MODIFY_PIN_DIRECT)\n            reader_table[slot].pcsc.modify_ioctl = v;\n          else if (code == FEATURE_GET_TLV_PROPERTIES)\n            get_tlv_ioctl = v;\n\n          if (DBG_CARD_IO)\n            log_debug (\"feature: code=%02X, len=%d, v=%02X\\n\", code, l, v);\n\n          p += l;\n        }\n    }\n\n  if (get_tlv_ioctl == (pcsc_dword_t)-1)\n    {\n      /*\n       * For system which doesn't support GET_TLV_PROPERTIES,\n       * we put some heuristics here.\n       */\n      if (reader_table[slot].rdrname)\n        {\n          if (strstr (reader_table[slot].rdrname, \"SPRx32\"))\n            {\n              reader_table[slot].is_spr532 = 1;\n              reader_table[slot].pinpad_varlen_supported = 1;\n            }\n          else if (strstr (reader_table[slot].rdrname, \"ST-2xxx\"))\n            {\n              reader_table[slot].pcsc.pinmax = 15;\n              reader_table[slot].pinpad_varlen_supported = 1;\n            }\n          else if (strstr (reader_table[slot].rdrname, \"cyberJack\")\n                   || strstr (reader_table[slot].rdrname, \"DIGIPASS\")\n                   || strstr (reader_table[slot].rdrname, \"Gnuk\")\n                   || strstr (reader_table[slot].rdrname, \"KAAN\")\n                   || strstr (reader_table[slot].rdrname, \"Trustica\"))\n            reader_table[slot].pinpad_varlen_supported = 1;\n        }\n\n      return 0;\n    }\n\n  len = sizeof (buf);\n  sw = control_pcsc (slot, get_tlv_ioctl, NULL, 0, buf, &len);\n  if (sw)\n    {\n      log_error (\"pcsc_vendor_specific_init: GET_TLV_IOCTL failed: %d\\n\", sw);\n      return SW_NOT_SUPPORTED;\n    }\n\n  p = buf;\n  while (p < buf + len)\n    {\n      unsigned char tag = *p++;\n      int l = *p++;\n      unsigned int v = 0;\n\n      /* Umm... here is little endian, while the encoding above is big.  */\n      if (l == 1)\n        v = p[0];\n      else if (l == 2)\n        v = (((unsigned int)p[1] << 8) | p[0]);\n      else if (l == 4)\n        v = (((unsigned int)p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0]);\n\n      if (tag == PCSCv2_PART10_PROPERTY_bMinPINSize)\n        reader_table[slot].pcsc.pinmin = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_bMaxPINSize)\n        reader_table[slot].pcsc.pinmax = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_wIdVendor)\n        vendor = v;\n      else if (tag == PCSCv2_PART10_PROPERTY_wIdProduct)\n        product = v;\n\n      if (DBG_CARD_IO)\n        log_debug (\"TLV properties: tag=%02X, len=%d, v=%08X\\n\", tag, l, v);\n\n      p += l;\n    }\n\n  if (vendor == VENDOR_VEGA && product == VEGA_ALPHA)\n    {\n      /*\n       * Please read the comment of ccid_vendor_specific_init in\n       * ccid-driver.c.\n       */\n      const unsigned char cmd[] = { '\\xb5', '\\x01', '\\x00', '\\x03', '\\x00' };\n      sw = control_pcsc (slot, CM_IOCTL_VENDOR_IFD_EXCHANGE,\n                         cmd, sizeof (cmd), NULL, 0);\n      if (sw)\n        return SW_NOT_SUPPORTED;\n    }\n  else if (vendor == VENDOR_SCM && product == SCM_SPR532) /* SCM SPR532 */\n    {\n      reader_table[slot].is_spr532 = 1;\n      reader_table[slot].pinpad_varlen_supported = 1;\n    }\n  else if (vendor == 0x046a)\n    {\n      /* Cherry ST-2xxx (product == 0x003e) supports TPDU level\n       * exchange.  Other products which only support short APDU level\n       * exchange only work with shorter keys like RSA 1024.\n       */\n      reader_table[slot].pcsc.pinmax = 15;\n      reader_table[slot].pinpad_varlen_supported = 1;\n    }\n  else if (vendor == 0x0c4b /* Tested with Reiner cyberJack GO */\n           || vendor == 0x1a44 /* Tested with Vasco DIGIPASS 920 */\n           || vendor == 0x234b /* Tested with FSIJ Gnuk Token */\n           || vendor == 0x0d46 /* Tested with KAAN Advanced??? */\n           || (vendor == 0x1fc9 && product == 0x81e6) /* Tested with Trustica Cryptoucan */)\n    reader_table[slot].pinpad_varlen_supported = 1;\n\n  return 0;\n}\n\n\n/* Open the PC/SC reader without using the wrapper.  Returns -1 on\n   error or a slot number for the reader.  */\nstatic int\nopen_pcsc_reader (const char *portstr)\n{\n  long err;\n  int slot;\n  char *list = NULL;\n  char *rdrname = NULL;\n  pcsc_dword_t nreader;\n  char *p;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n\n  /* Fixme: Allocating a context for each slot is not required.  One\n     global context should be sufficient.  */\n  err = pcsc_establish_context (PCSC_SCOPE_SYSTEM, NULL, NULL,\n                                &reader_table[slot].pcsc.context);\n  if (err)\n    {\n      log_error (\"pcsc_establish_context failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      reader_table[slot].used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  err = pcsc_list_readers (reader_table[slot].pcsc.context,\n                           NULL, NULL, &nreader);\n  if (!err)\n    {\n      list = xtrymalloc (nreader+1); /* Better add 1 for safety reasons. */\n      if (!list)\n        {\n          log_error (\"error allocating memory for reader list\\n\");\n          pcsc_release_context (reader_table[slot].pcsc.context);\n          reader_table[slot].used = 0;\n          unlock_slot (slot);\n          return -1 /*SW_HOST_OUT_OF_CORE*/;\n        }\n      err = pcsc_list_readers (reader_table[slot].pcsc.context,\n                               NULL, list, &nreader);\n    }\n  if (err)\n    {\n      log_error (\"pcsc_list_readers failed: %s (0x%lx)\\n\",\n                 pcsc_error_string (err), err);\n      pcsc_release_context (reader_table[slot].pcsc.context);\n      reader_table[slot].used = 0;\n      xfree (list);\n      unlock_slot (slot);\n      return -1;\n    }\n\n  p = list;\n  while (nreader)\n    {\n      if (!*p && !p[1])\n        break;\n      log_info (\"detected reader '%s'\\n\", p);\n      if (nreader < (strlen (p)+1))\n        {\n          log_error (\"invalid response from pcsc_list_readers\\n\");\n          break;\n        }\n      if (!rdrname && portstr && !strncmp (p, portstr, strlen (portstr)))\n        rdrname = p;\n      nreader -= strlen (p)+1;\n      p += strlen (p) + 1;\n    }\n\n  if (!rdrname)\n    rdrname = list;\n\n  reader_table[slot].rdrname = xtrystrdup (rdrname);\n  if (!reader_table[slot].rdrname)\n    {\n      log_error (\"error allocating memory for reader name\\n\");\n      pcsc_release_context (reader_table[slot].pcsc.context);\n      reader_table[slot].used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n  xfree (list);\n  list = NULL;\n\n  reader_table[slot].pcsc.card = 0;\n  reader_table[slot].atrlen = 0;\n\n  reader_table[slot].connect_card = connect_pcsc_card;\n  reader_table[slot].disconnect_card = disconnect_pcsc_card;\n  reader_table[slot].close_reader = close_pcsc_reader;\n  reader_table[slot].reset_reader = reset_pcsc_reader;\n  reader_table[slot].get_status_reader = pcsc_get_status;\n  reader_table[slot].send_apdu_reader = pcsc_send_apdu;\n  reader_table[slot].dump_status_reader = dump_pcsc_reader_status;\n\n  dump_reader_status (slot);\n  unlock_slot (slot);\n  return slot;\n}\n\n\n/* Check whether the reader supports the ISO command code COMMAND\n   on the pinpad.  Return 0 on success.  */\nstatic int\ncheck_pcsc_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  int r;\n\n  if (reader_table[slot].pcsc.pinmin >= 0)\n    pininfo->minlen = reader_table[slot].pcsc.pinmin;\n\n  if (reader_table[slot].pcsc.pinmax >= 0)\n    pininfo->maxlen = reader_table[slot].pcsc.pinmax;\n\n  if (!pininfo->minlen)\n    pininfo->minlen = 1;\n  if (!pininfo->maxlen)\n    pininfo->maxlen = 15;\n\n  if ((command == ISO7816_VERIFY && reader_table[slot].pcsc.verify_ioctl != 0)\n      || (command == ISO7816_CHANGE_REFERENCE_DATA\n          && reader_table[slot].pcsc.modify_ioctl != 0))\n    r = 0;                       /* Success */\n  else\n    r = SW_NOT_SUPPORTED;\n\n  if (DBG_CARD_IO)\n    log_debug (\"check_pcsc_pinpad: command=%02X, r=%d\\n\",\n               (unsigned int)command, r);\n\n  if (reader_table[slot].pinpad_varlen_supported)\n    pininfo->fixedlen = 0;\n\n  return r;\n}\n\n#define PIN_VERIFY_STRUCTURE_SIZE 24\nstatic int\npcsc_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  int sw;\n  unsigned char *pin_verify;\n  int len = PIN_VERIFY_STRUCTURE_SIZE + pininfo->fixedlen;\n  /*\n   * The result buffer is only expected to have two-byte result on\n   * return.  However, some implementation uses this buffer for lower\n   * layer too and it assumes that there is enough space for lower\n   * layer communication.  Such an implementation fails for TPDU\n   * readers with \"insufficient buffer\", as it needs header and\n   * trailer.  Six is the number for header + result + trailer (TPDU).\n   */\n  unsigned char result[6];\n  pcsc_dword_t resultlen = 6;\n  int no_lc;\n\n  if (!reader_table[slot].atrlen\n      && (sw = reset_pcsc_reader (slot)))\n    return sw;\n\n  if (pininfo->fixedlen < 0 || pininfo->fixedlen >= 16)\n    return SW_NOT_SUPPORTED;\n\n  pin_verify = xtrymalloc (len);\n  if (!pin_verify)\n    return SW_HOST_OUT_OF_CORE;\n\n  no_lc = (!pininfo->fixedlen && reader_table[slot].is_spr532);\n\n  pin_verify[0] = 0x00; /* bTimeOut */\n  pin_verify[1] = 0x00; /* bTimeOut2 */\n  pin_verify[2] = 0x82; /* bmFormatString: Byte, pos=0, left, ASCII. */\n  pin_verify[3] = pininfo->fixedlen; /* bmPINBlockString */\n  pin_verify[4] = 0x00; /* bmPINLengthFormat */\n  pin_verify[5] = pininfo->maxlen; /* wPINMaxExtraDigit */\n  pin_verify[6] = pininfo->minlen; /* wPINMaxExtraDigit */\n  pin_verify[7] = 0x02; /* bEntryValidationCondition: Validation key pressed */\n  if (pininfo->minlen && pininfo->maxlen && pininfo->minlen == pininfo->maxlen)\n    pin_verify[7] |= 0x01; /* Max size reached.  */\n  pin_verify[8] = 0x01; /* bNumberMessage: One message */\n  pin_verify[9] =  0x09; /* wLangId: 0x0409: US English */\n  pin_verify[10] = 0x04; /* wLangId: 0x0409: US English */\n  pin_verify[11] = 0x00; /* bMsgIndex */\n  pin_verify[12] = 0x00; /* bTeoPrologue[0] */\n  pin_verify[13] = 0x00; /* bTeoPrologue[1] */\n  pin_verify[14] = pininfo->fixedlen + 0x05 - no_lc; /* bTeoPrologue[2] */\n  pin_verify[15] = pininfo->fixedlen + 0x05 - no_lc; /* ulDataLength */\n  pin_verify[16] = 0x00; /* ulDataLength */\n  pin_verify[17] = 0x00; /* ulDataLength */\n  pin_verify[18] = 0x00; /* ulDataLength */\n  pin_verify[19] = class; /* abData[0] */\n  pin_verify[20] = ins; /* abData[1] */\n  pin_verify[21] = p0; /* abData[2] */\n  pin_verify[22] = p1; /* abData[3] */\n  pin_verify[23] = pininfo->fixedlen; /* abData[4] */\n  if (pininfo->fixedlen)\n    memset (&pin_verify[24], 0xff, pininfo->fixedlen);\n  else if (no_lc)\n    len--;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send secure: c=%02X i=%02X p1=%02X p2=%02X len=%d pinmax=%d\\n\",\n               class, ins, p0, p1, len, pininfo->maxlen);\n\n  sw = control_pcsc (slot, reader_table[slot].pcsc.verify_ioctl,\n                     pin_verify, len, result, &resultlen);\n  xfree (pin_verify);\n  if (sw || resultlen < 2)\n    {\n      log_error (\"control_pcsc failed: %d\\n\", sw);\n      return sw? sw: SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  if (DBG_CARD_IO)\n    log_debug (\" response: sw=%04X  datalen=%d\\n\", sw, (unsigned int)resultlen);\n  return sw;\n}\n\n\n#define PIN_MODIFY_STRUCTURE_SIZE 29\nstatic int\npcsc_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  int sw;\n  unsigned char *pin_modify;\n  int len = PIN_MODIFY_STRUCTURE_SIZE + 2 * pininfo->fixedlen;\n  unsigned char result[6];      /* See the comment at pinpad_verify.  */\n  pcsc_dword_t resultlen = 6;\n  int no_lc;\n\n  if (!reader_table[slot].atrlen\n      && (sw = reset_pcsc_reader (slot)))\n    return sw;\n\n  if (pininfo->fixedlen < 0 || pininfo->fixedlen >= 16)\n    return SW_NOT_SUPPORTED;\n\n  pin_modify = xtrymalloc (len);\n  if (!pin_modify)\n    return SW_HOST_OUT_OF_CORE;\n\n  no_lc = (!pininfo->fixedlen && reader_table[slot].is_spr532);\n\n  pin_modify[0] = 0x00; /* bTimeOut */\n  pin_modify[1] = 0x00; /* bTimeOut2 */\n  pin_modify[2] = 0x82; /* bmFormatString: Byte, pos=0, left, ASCII. */\n  pin_modify[3] = pininfo->fixedlen; /* bmPINBlockString */\n  pin_modify[4] = 0x00; /* bmPINLengthFormat */\n  pin_modify[5] = 0x00; /* bInsertionOffsetOld */\n  pin_modify[6] = pininfo->fixedlen; /* bInsertionOffsetNew */\n  pin_modify[7] = pininfo->maxlen; /* wPINMaxExtraDigit */\n  pin_modify[8] = pininfo->minlen; /* wPINMaxExtraDigit */\n  pin_modify[9] = (p0 == 0 ? 0x03 : 0x01);\n                  /* bConfirmPIN\n                   *    0x00: new PIN once\n                   *    0x01: new PIN twice (confirmation)\n                   *    0x02: old PIN and new PIN once\n                   *    0x03: old PIN and new PIN twice (confirmation)\n                   */\n  pin_modify[10] = 0x02; /* bEntryValidationCondition: Validation key pressed */\n  if (pininfo->minlen && pininfo->maxlen && pininfo->minlen == pininfo->maxlen)\n    pin_modify[10] |= 0x01; /* Max size reached.  */\n  pin_modify[11] = 0x03; /* bNumberMessage: Three messages */\n  pin_modify[12] = 0x09; /* wLangId: 0x0409: US English */\n  pin_modify[13] = 0x04; /* wLangId: 0x0409: US English */\n  pin_modify[14] = 0x00; /* bMsgIndex1 */\n  pin_modify[15] = 0x01; /* bMsgIndex2 */\n  pin_modify[16] = 0x02; /* bMsgIndex3 */\n  pin_modify[17] = 0x00; /* bTeoPrologue[0] */\n  pin_modify[18] = 0x00; /* bTeoPrologue[1] */\n  pin_modify[19] = 2 * pininfo->fixedlen + 0x05 - no_lc; /* bTeoPrologue[2] */\n  pin_modify[20] = 2 * pininfo->fixedlen + 0x05 - no_lc; /* ulDataLength */\n  pin_modify[21] = 0x00; /* ulDataLength */\n  pin_modify[22] = 0x00; /* ulDataLength */\n  pin_modify[23] = 0x00; /* ulDataLength */\n  pin_modify[24] = class; /* abData[0] */\n  pin_modify[25] = ins; /* abData[1] */\n  pin_modify[26] = p0; /* abData[2] */\n  pin_modify[27] = p1; /* abData[3] */\n  pin_modify[28] = 2 * pininfo->fixedlen; /* abData[4] */\n  if (pininfo->fixedlen)\n    memset (&pin_modify[29], 0xff, 2 * pininfo->fixedlen);\n  else if (no_lc)\n    len--;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send secure: c=%02X i=%02X p1=%02X p2=%02X len=%d pinmax=%d\\n\",\n               class, ins, p0, p1, len, (int)pininfo->maxlen);\n\n  sw = control_pcsc (slot, reader_table[slot].pcsc.modify_ioctl,\n                     pin_modify, len, result, &resultlen);\n  xfree (pin_modify);\n  if (sw || resultlen < 2)\n    {\n      log_error (\"control_pcsc failed: %d\\n\", sw);\n      return sw? sw : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  if (DBG_CARD_IO)\n    log_debug (\" response: sw=%04X  datalen=%d\\n\", sw, (unsigned int)resultlen);\n  return sw;\n}\n\f\n#ifdef HAVE_LIBUSB\n/*\n     Internal CCID driver interface.\n */\n\n\nstatic void\ndump_ccid_reader_status (int slot)\n{\n  log_info (\"reader slot %d: using ccid driver\\n\", slot);\n}\n\nstatic int\nclose_ccid_reader (int slot)\n{\n  ccid_close_reader (reader_table[slot].ccid.handle);\n  return 0;\n}\n\n\nstatic int\nreset_ccid_reader (int slot)\n{\n  int err;\n  reader_table_t slotp = reader_table + slot;\n  unsigned char atr[33];\n  size_t atrlen;\n\n  err = ccid_get_atr (slotp->ccid.handle, atr, sizeof atr, &atrlen);\n  if (err)\n    return err;\n  /* If the reset was successful, update the ATR. */\n  assert (sizeof slotp->atr >= sizeof atr);\n  slotp->atrlen = atrlen;\n  memcpy (slotp->atr, atr, atrlen);\n  dump_reader_status (slot);\n  return 0;\n}\n\n\nstatic int\nset_progress_cb_ccid_reader (int slot, gcry_handler_progress_t cb, void *cb_arg)\n{\n  reader_table_t slotp = reader_table + slot;\n\n  return ccid_set_progress_cb (slotp->ccid.handle, cb, cb_arg);\n}\n\nstatic int\nset_prompt_cb_ccid_reader (int slot, void (*cb) (void *, int ), void *cb_arg)\n{\n  reader_table_t slotp = reader_table + slot;\n\n  return ccid_set_prompt_cb (slotp->ccid.handle, cb, cb_arg);\n}\n\n\nstatic int\nget_status_ccid (int slot, unsigned int *status, int on_wire)\n{\n  int rc;\n  int bits;\n\n  rc = ccid_slot_status (reader_table[slot].ccid.handle, &bits, on_wire);\n  if (rc)\n    return rc;\n\n  if (bits == 0)\n    *status = (APDU_CARD_USABLE|APDU_CARD_PRESENT|APDU_CARD_ACTIVE);\n  else if (bits == 1)\n    *status = APDU_CARD_PRESENT;\n  else\n    *status = 0;\n\n  return 0;\n}\n\n\n/* Actually send the APDU of length APDULEN to SLOT and return a\n   maximum of *BUFLEN data in BUFFER, the actual returned size will be\n   set to BUFLEN.  Returns: Internal CCID driver error code. */\nstatic int\nsend_apdu_ccid (int slot, unsigned char *apdu, size_t apdulen,\n                unsigned char *buffer, size_t *buflen,\n                pininfo_t *pininfo)\n{\n  long err;\n  size_t maxbuflen;\n\n  /* If we don't have an ATR, we need to reset the reader first. */\n  if (!reader_table[slot].atrlen\n      && (err = reset_ccid_reader (slot)))\n    return err;\n\n  if (DBG_CARD_IO)\n    log_printhex (apdu, apdulen, \" raw apdu:\");\n\n  maxbuflen = *buflen;\n  if (pininfo)\n    err = ccid_transceive_secure (reader_table[slot].ccid.handle,\n                                  apdu, apdulen, pininfo,\n                                  buffer, maxbuflen, buflen);\n  else\n    err = ccid_transceive (reader_table[slot].ccid.handle,\n                           apdu, apdulen,\n                           buffer, maxbuflen, buflen);\n  if (err)\n    log_error (\"ccid_transceive failed: (0x%lx)\\n\",\n               err);\n\n  return err;\n}\n\n\n/* Check whether the CCID reader supports the ISO command code COMMAND\n   on the pinpad.  Return 0 on success.  For a description of the pin\n   parameters, see ccid-driver.c */\nstatic int\ncheck_ccid_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  unsigned char apdu[] = { 0, 0, 0, 0x81 };\n\n  apdu[1] = command;\n  return ccid_transceive_secure (reader_table[slot].ccid.handle, apdu,\n                                 sizeof apdu, pininfo, NULL, 0, NULL);\n}\n\n\nstatic int\nccid_pinpad_operation (int slot, int class, int ins, int p0, int p1,\n                       pininfo_t *pininfo)\n{\n  unsigned char apdu[4];\n  int err, sw;\n  unsigned char result[2];\n  size_t resultlen = 2;\n\n  apdu[0] = class;\n  apdu[1] = ins;\n  apdu[2] = p0;\n  apdu[3] = p1;\n  err = ccid_transceive_secure (reader_table[slot].ccid.handle,\n                                apdu, sizeof apdu, pininfo,\n                                result, 2, &resultlen);\n  if (err)\n    return err;\n\n  if (resultlen < 2)\n    return SW_HOST_INCOMPLETE_CARD_RESPONSE;\n\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  return sw;\n}\n\n\n/* Open the reader and try to read an ATR.  */\nstatic int\nopen_ccid_reader (struct dev_list *dl)\n{\n  int err;\n  int slot;\n  int require_get_status;\n  reader_table_t slotp;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n  slotp = reader_table + slot;\n\n  err = ccid_open_reader (dl->portstr, dl->idx, dl->ccid_table,\n                          &slotp->ccid.handle, &slotp->rdrname);\n  if (!err)\n    {\n      err = ccid_get_atr (slotp->ccid.handle,\n                          slotp->atr, sizeof slotp->atr, &slotp->atrlen);\n      if (err)\n        ccid_close_reader (slotp->ccid.handle);\n    }\n\n  if (err)\n    {\n      slotp->used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  require_get_status = ccid_require_get_status (slotp->ccid.handle);\n\n  reader_table[slot].close_reader = close_ccid_reader;\n  reader_table[slot].reset_reader = reset_ccid_reader;\n  reader_table[slot].get_status_reader = get_status_ccid;\n  reader_table[slot].send_apdu_reader = send_apdu_ccid;\n  reader_table[slot].check_pinpad = check_ccid_pinpad;\n  reader_table[slot].dump_status_reader = dump_ccid_reader_status;\n  reader_table[slot].set_progress_cb = set_progress_cb_ccid_reader;\n  reader_table[slot].set_prompt_cb = set_prompt_cb_ccid_reader;\n  reader_table[slot].pinpad_verify = ccid_pinpad_operation;\n  reader_table[slot].pinpad_modify = ccid_pinpad_operation;\n  /* Our CCID reader code does not support T=0 at all, thus reset the\n     flag.  */\n  reader_table[slot].is_t0 = 0;\n  reader_table[slot].require_get_status = require_get_status;\n\n  dump_reader_status (slot);\n  unlock_slot (slot);\n  return slot;\n}\n#endif /* HAVE_LIBUSB */\n\f\n#ifdef USE_G10CODE_RAPDU\n/*\n     The Remote APDU Interface.\n\n     This uses the Remote APDU protocol to contact a reader.\n\n     The port number is actually an index into the list of ports as\n     returned via the protocol.\n */\n\n\nstatic int\nrapdu_status_to_sw (int status)\n{\n  int rc;\n\n  switch (status)\n    {\n    case RAPDU_STATUS_SUCCESS:  rc = 0; break;\n\n    case RAPDU_STATUS_INVCMD:\n    case RAPDU_STATUS_INVPROT:\n    case RAPDU_STATUS_INVSEQ:\n    case RAPDU_STATUS_INVCOOKIE:\n    case RAPDU_STATUS_INVREADER:  rc = SW_HOST_INV_VALUE;  break;\n\n    case RAPDU_STATUS_TIMEOUT:  rc = SW_HOST_CARD_IO_ERROR; break;\n    case RAPDU_STATUS_CARDIO:   rc = SW_HOST_CARD_IO_ERROR; break;\n    case RAPDU_STATUS_NOCARD:   rc = SW_HOST_NO_CARD; break;\n    case RAPDU_STATUS_CARDCHG:  rc = SW_HOST_NO_CARD; break;\n    case RAPDU_STATUS_BUSY:     rc = SW_HOST_BUSY; break;\n    case RAPDU_STATUS_NEEDRESET: rc = SW_HOST_CARD_INACTIVE; break;\n\n    default: rc = SW_HOST_GENERAL_ERROR; break;\n    }\n\n  return rc;\n}\n\n\n\nstatic int\nclose_rapdu_reader (int slot)\n{\n  rapdu_release (reader_table[slot].rapdu.handle);\n  return 0;\n}\n\n\nstatic int\nreset_rapdu_reader (int slot)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n\n  slotp = reader_table + slot;\n\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_RESET);\n  if (err)\n    {\n      log_error (\"sending rapdu command RESET failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command RESET failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n  if (msg->datalen > DIM (slotp->atr))\n    {\n      log_error (\"ATR returned by the RAPDU layer is too large\\n\");\n      rapdu_msg_release (msg);\n      return SW_HOST_INV_VALUE;\n    }\n  slotp->atrlen = msg->datalen;\n  memcpy (slotp->atr, msg->data, msg->datalen);\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\n\nstatic int\nmy_rapdu_get_status (int slot, unsigned int *status, int on_wire)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n  int oldslot;\n\n  (void)on_wire;\n  slotp = reader_table + slot;\n\n  oldslot = rapdu_set_reader (slotp->rapdu.handle, slot);\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_GET_STATUS);\n  rapdu_set_reader (slotp->rapdu.handle, oldslot);\n  if (err)\n    {\n      log_error (\"sending rapdu command GET_STATUS failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command GET_STATUS failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n  *status = msg->data[0];\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\n\n/* Actually send the APDU of length APDULEN to SLOT and return a\n   maximum of *BUFLEN data in BUFFER, the actual returned size will be\n   set to BUFLEN.  Returns: APDU error code. */\nstatic int\nmy_rapdu_send_apdu (int slot, unsigned char *apdu, size_t apdulen,\n                    unsigned char *buffer, size_t *buflen,\n                    pininfo_t *pininfo)\n{\n  int err;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n  size_t maxlen = *buflen;\n\n  slotp = reader_table + slot;\n\n  *buflen = 0;\n  if (DBG_CARD_IO)\n    log_printhex (apdu, apdulen, \"  APDU_data:\");\n\n  if (apdulen < 4)\n    {\n      log_error (\"rapdu_send_apdu: APDU is too short\\n\");\n      return SW_HOST_INV_VALUE;\n    }\n\n  err = rapdu_send_apdu (slotp->rapdu.handle, apdu, apdulen);\n  if (err)\n    {\n      log_error (\"sending rapdu command APDU failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_error (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      rapdu_msg_release (msg);\n      return rapdu_status_to_sw (err);\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      int sw = rapdu_status_to_sw (msg->cmd);\n      log_error (\"rapdu command APDU failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      rapdu_msg_release (msg);\n      return sw;\n    }\n\n  if (msg->datalen > maxlen)\n    {\n      log_error (\"rapdu response apdu too large\\n\");\n      rapdu_msg_release (msg);\n      return SW_HOST_INV_VALUE;\n    }\n\n  *buflen = msg->datalen;\n  memcpy (buffer, msg->data, msg->datalen);\n\n  rapdu_msg_release (msg);\n  return 0;\n}\n\nstatic int\nopen_rapdu_reader (int portno,\n                   const unsigned char *cookie, size_t length,\n                   int (*readfnc) (void *opaque,\n                                   void *buffer, size_t size),\n                   void *readfnc_value,\n                   int (*writefnc) (void *opaque,\n                                    const void *buffer, size_t size),\n                   void *writefnc_value,\n                   void (*closefnc) (void *opaque),\n                   void *closefnc_value)\n{\n  int err;\n  int slot;\n  reader_table_t slotp;\n  rapdu_msg_t msg = NULL;\n\n  slot = new_reader_slot ();\n  if (slot == -1)\n    return -1;\n  slotp = reader_table + slot;\n\n  slotp->rapdu.handle = rapdu_new ();\n  if (!slotp->rapdu.handle)\n    {\n      slotp->used = 0;\n      unlock_slot (slot);\n      return -1;\n    }\n\n  rapdu_set_reader (slotp->rapdu.handle, portno);\n\n  rapdu_set_iofunc (slotp->rapdu.handle,\n                    readfnc, readfnc_value,\n                    writefnc, writefnc_value,\n                    closefnc, closefnc_value);\n  rapdu_set_cookie (slotp->rapdu.handle, cookie, length);\n\n  /* First try to get the current ATR, but if the card is inactive\n     issue a reset instead.  */\n  err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_GET_ATR);\n  if (err == RAPDU_STATUS_NEEDRESET)\n    err = rapdu_send_cmd (slotp->rapdu.handle, RAPDU_CMD_RESET);\n  if (err)\n    {\n      log_info (\"sending rapdu command GET_ATR/RESET failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      goto failure;\n    }\n  err = rapdu_read_msg (slotp->rapdu.handle, &msg);\n  if (err)\n    {\n      log_info (\"receiving rapdu message failed: %s\\n\",\n                err < 0 ? strerror (errno): rapdu_strerror (err));\n      goto failure;\n    }\n  if (msg->cmd != RAPDU_STATUS_SUCCESS || !msg->datalen)\n    {\n      log_info (\"rapdu command GET ATR failed: %s\\n\",\n                 rapdu_strerror (msg->cmd));\n      goto failure;\n    }\n  if (msg->datalen > DIM (slotp->atr))\n    {\n      log_error (\"ATR returned by the RAPDU layer is too large\\n\");\n      goto failure;\n    }\n  slotp->atrlen = msg->datalen;\n  memcpy (slotp->atr, msg->data, msg->datalen);\n\n  reader_table[slot].close_reader = close_rapdu_reader;\n  reader_table[slot].reset_reader = reset_rapdu_reader;\n  reader_table[slot].get_status_reader = my_rapdu_get_status;\n  reader_table[slot].send_apdu_reader = my_rapdu_send_apdu;\n  reader_table[slot].check_pinpad = NULL;\n  reader_table[slot].dump_status_reader = NULL;\n  reader_table[slot].pinpad_verify = NULL;\n  reader_table[slot].pinpad_modify = NULL;\n\n  dump_reader_status (slot);\n  rapdu_msg_release (msg);\n  unlock_slot (slot);\n  return slot;\n\n failure:\n  rapdu_msg_release (msg);\n  rapdu_release (slotp->rapdu.handle);\n  slotp->used = 0;\n  unlock_slot (slot);\n  return -1;\n}\n\n#endif /*USE_G10CODE_RAPDU*/\n\n\n\f\n/*\n       Driver Access\n */\ngpg_error_t\napdu_dev_list_start (const char *portstr, struct dev_list **l_p)\n{\n  struct dev_list *dl = xtrymalloc (sizeof (struct dev_list));\n\n  *l_p = NULL;\n  if (!dl)\n    return gpg_error_from_syserror ();\n\n  dl->portstr = portstr;\n  dl->idx = 0;\n\n  npth_mutex_lock (&reader_table_lock);\n\n#ifdef HAVE_LIBUSB\n  if (opt.disable_ccid)\n    {\n      dl->ccid_table = NULL;\n      dl->idx_max = 1;\n    }\n  else\n    {\n      gpg_error_t err;\n\n      err = ccid_dev_scan (&dl->idx_max, &dl->ccid_table);\n      if (err)\n        return err;\n\n      if (dl->idx_max == 0)\n        {\n          /* If a CCID reader specification has been given, the user does\n             not want a fallback to other drivers. */\n          if (portstr && strlen (portstr) > 5 && portstr[4] == ':')\n            {\n              if (DBG_READER)\n                log_debug (\"leave: apdu_open_reader => slot=-1 (no ccid)\\n\");\n\n              xfree (dl);\n              npth_mutex_unlock (&reader_table_lock);\n              return gpg_error (GPG_ERR_ENODEV);\n            }\n          else\n            dl->idx_max = 1;\n        }\n    }\n#else\n  dl->ccid_table = NULL;\n  dl->idx_max = 1;\n#endif /* HAVE_LIBUSB */\n\n  *l_p = dl;\n  return 0;\n}\n\nvoid\napdu_dev_list_finish (struct dev_list *dl)\n{\n#ifdef HAVE_LIBUSB\n  if (dl->ccid_table)\n    ccid_dev_scan_finish (dl->ccid_table, dl->idx_max);\n#endif\n  xfree (dl);\n  npth_mutex_unlock (&reader_table_lock);\n}\n\n\n/* Open the reader and return an internal slot number or -1 on\n   error. If PORTSTR is NULL we default to a suitable port (for ctAPI:\n   the first USB reader.  For PC/SC the first listed reader). */\nstatic int\napdu_open_one_reader (const char *portstr)\n{\n  static int pcsc_api_loaded;\n  int slot;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_open_reader: portstr=%s\\n\", portstr);\n\n  /* Lets try the PC/SC API */\n  if (!pcsc_api_loaded)\n    {\n      void *handle;\n\n      handle = dlopen (opt.pcsc_driver, RTLD_LAZY);\n      if (!handle)\n        {\n          log_error (\"apdu_open_reader: failed to open driver '%s': %s\\n\",\n                     opt.pcsc_driver, dlerror ());\n          return -1;\n        }\n\n      pcsc_establish_context = dlsym (handle, \"SCardEstablishContext\");\n      pcsc_release_context   = dlsym (handle, \"SCardReleaseContext\");\n      pcsc_list_readers      = dlsym (handle, \"SCardListReaders\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_list_readers)\n        pcsc_list_readers    = dlsym (handle, \"SCardListReadersA\");\n#endif\n      pcsc_get_status_change = dlsym (handle, \"SCardGetStatusChange\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_get_status_change)\n        pcsc_get_status_change = dlsym (handle, \"SCardGetStatusChangeA\");\n#endif\n      pcsc_connect           = dlsym (handle, \"SCardConnect\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_connect)\n        pcsc_connect         = dlsym (handle, \"SCardConnectA\");\n#endif\n      pcsc_reconnect         = dlsym (handle, \"SCardReconnect\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_reconnect)\n        pcsc_reconnect       = dlsym (handle, \"SCardReconnectA\");\n#endif\n      pcsc_disconnect        = dlsym (handle, \"SCardDisconnect\");\n      pcsc_status            = dlsym (handle, \"SCardStatus\");\n#if defined(_WIN32) || defined(__CYGWIN__)\n      if (!pcsc_status)\n        pcsc_status          = dlsym (handle, \"SCardStatusA\");\n#endif\n      pcsc_begin_transaction = dlsym (handle, \"SCardBeginTransaction\");\n      pcsc_end_transaction   = dlsym (handle, \"SCardEndTransaction\");\n      pcsc_transmit          = dlsym (handle, \"SCardTransmit\");\n      pcsc_set_timeout       = dlsym (handle, \"SCardSetTimeout\");\n      pcsc_control           = dlsym (handle, \"SCardControl\");\n\n      if (!pcsc_establish_context\n          || !pcsc_release_context\n          || !pcsc_list_readers\n          || !pcsc_get_status_change\n          || !pcsc_connect\n          || !pcsc_reconnect\n          || !pcsc_disconnect\n          || !pcsc_status\n          || !pcsc_begin_transaction\n          || !pcsc_end_transaction\n          || !pcsc_transmit\n          || !pcsc_control\n          /* || !pcsc_set_timeout */)\n        {\n          /* Note that set_timeout is currently not used and also not\n             available under Windows. */\n          log_error (\"apdu_open_reader: invalid PC/SC driver \"\n                     \"(%d%d%d%d%d%d%d%d%d%d%d%d%d)\\n\",\n                     !!pcsc_establish_context,\n                     !!pcsc_release_context,\n                     !!pcsc_list_readers,\n                     !!pcsc_get_status_change,\n                     !!pcsc_connect,\n                     !!pcsc_reconnect,\n                     !!pcsc_disconnect,\n                     !!pcsc_status,\n                     !!pcsc_begin_transaction,\n                     !!pcsc_end_transaction,\n                     !!pcsc_transmit,\n                     !!pcsc_set_timeout,\n                     !!pcsc_control );\n          dlclose (handle);\n          return -1;\n        }\n      pcsc_api_loaded = 1;\n    }\n\n  slot = open_pcsc_reader (portstr);\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_open_reader => slot=%d [pc/sc]\\n\", slot);\n  return slot;\n}\n\nint\napdu_open_reader (struct dev_list *dl, int app_empty)\n{\n  int slot;\n\n#ifdef HAVE_LIBUSB\n  if (dl->ccid_table)\n    { /* CCID readers.  */\n      int readerno;\n\n      /* See whether we want to use the reader ID string or a reader\n         number. A readerno of -1 indicates that the reader ID string is\n         to be used. */\n      if (dl->portstr && strchr (dl->portstr, ':'))\n        readerno = -1; /* We want to use the readerid.  */\n      else if (dl->portstr)\n        {\n          readerno = atoi (dl->portstr);\n          if (readerno < 0)\n            {\n              return -1;\n            }\n        }\n      else\n        readerno = 0;  /* Default. */\n\n      if (readerno > 0)\n        { /* Use single, the specific reader.  */\n          if (readerno >= dl->idx_max)\n            return -1;\n\n          dl->idx = readerno;\n          dl->portstr = NULL;\n          slot = open_ccid_reader (dl);\n          dl->idx = dl->idx_max;\n          if (slot >= 0)\n            return slot;\n          else\n            return -1;\n        }\n\n      while (dl->idx < dl->idx_max)\n        {\n          unsigned int bai = ccid_get_BAI (dl->idx, dl->ccid_table);\n\n          if (DBG_READER)\n            log_debug (\"apdu_open_reader: BAI=%x\\n\", bai);\n\n          /* Check identity by BAI against already opened HANDLEs.  */\n          for (slot = 0; slot < MAX_READER; slot++)\n            if (reader_table[slot].used\n                && reader_table[slot].ccid.handle\n                && ccid_compare_BAI (reader_table[slot].ccid.handle, bai))\n              break;\n\n          if (slot == MAX_READER)\n            { /* Found a new device.  */\n              if (DBG_READER)\n                log_debug (\"apdu_open_reader: new device=%x\\n\", bai);\n\n              slot = open_ccid_reader (dl);\n\n              dl->idx++;\n              if (slot >= 0)\n                return slot;\n              else\n                {\n                  /* Skip this reader.  */\n                  log_error (\"ccid open error: skip\\n\");\n                  continue;\n                }\n            }\n          else\n            dl->idx++;\n        }\n\n      /* Not found.  Try one for PC/SC, only when it's the initial scan.  */\n      if (app_empty && dl->idx == dl->idx_max)\n        {\n          dl->idx++;\n          slot = apdu_open_one_reader (dl->portstr);\n        }\n      else\n        slot = -1;\n    }\n  else\n#endif\n    { /* PC/SC readers.  */\n      if (app_empty && dl->idx == 0)\n        {\n          dl->idx++;\n          slot = apdu_open_one_reader (dl->portstr);\n        }\n      else\n        slot = -1;\n    }\n\n  return slot;\n}\n\n\n/* Open an remote reader and return an internal slot number or -1 on\n   error. This function is an alternative to apdu_open_reader and used\n   with remote readers only.  Note that the supplied CLOSEFNC will\n   only be called once and the slot will not be valid afther this.\n\n   If PORTSTR is NULL we default to the first available port.\n*/\nint\napdu_open_remote_reader (const char *portstr,\n                         const unsigned char *cookie, size_t length,\n                         int (*readfnc) (void *opaque,\n                                         void *buffer, size_t size),\n                         void *readfnc_value,\n                         int (*writefnc) (void *opaque,\n                                          const void *buffer, size_t size),\n                         void *writefnc_value,\n                         void (*closefnc) (void *opaque),\n                         void *closefnc_value)\n{\n#ifdef USE_G10CODE_RAPDU\n  return open_rapdu_reader (portstr? atoi (portstr) : 0,\n                            cookie, length,\n                            readfnc, readfnc_value,\n                            writefnc, writefnc_value,\n                            closefnc, closefnc_value);\n#else\n  (void)portstr;\n  (void)cookie;\n  (void)length;\n  (void)readfnc;\n  (void)readfnc_value;\n  (void)writefnc;\n  (void)writefnc_value;\n  (void)closefnc;\n  (void)closefnc_value;\n#ifdef _WIN32\n  errno = ENOENT;\n#else\n  errno = ENOSYS;\n#endif\n  return -1;\n#endif\n}\n\n\nint\napdu_close_reader (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_close_reader: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_close_reader => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n  sw = apdu_disconnect (slot);\n  if (sw)\n    {\n      /*\n       * When the reader/token was removed it might come here.\n       * It should go through to call CLOSE_READER even if we got an error.\n       */\n      if (DBG_READER)\n        log_debug (\"apdu_close_reader => 0x%x (apdu_disconnect)\\n\", sw);\n    }\n  if (reader_table[slot].close_reader)\n    {\n      sw = reader_table[slot].close_reader (slot);\n      reader_table[slot].used = 0;\n      if (DBG_READER)\n        log_debug (\"leave: apdu_close_reader => 0x%x (close_reader)\\n\", sw);\n      return sw;\n    }\n  xfree (reader_table[slot].rdrname);\n  reader_table[slot].rdrname = NULL;\n  reader_table[slot].used = 0;\n  if (DBG_READER)\n    log_debug (\"leave: apdu_close_reader => SW_HOST_NOT_SUPPORTED\\n\");\n  return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Function suitable for a cleanup function to close all reader.  It\n   should not be used if the reader will be opened again.  The reason\n   for implementing this to properly close USB devices so that they\n   will startup the next time without error. */\nvoid\napdu_prepare_exit (void)\n{\n  static int sentinel;\n  int slot;\n\n  if (!sentinel)\n    {\n      sentinel = 1;\n      npth_mutex_lock (&reader_table_lock);\n      for (slot = 0; slot < MAX_READER; slot++)\n        if (reader_table[slot].used)\n          {\n            apdu_disconnect (slot);\n            if (reader_table[slot].close_reader)\n              reader_table[slot].close_reader (slot);\n            xfree (reader_table[slot].rdrname);\n            reader_table[slot].rdrname = NULL;\n            reader_table[slot].used = 0;\n          }\n      npth_mutex_unlock (&reader_table_lock);\n      sentinel = 0;\n    }\n}\n\n\n/* Enumerate all readers and return information on whether this reader\n   is in use.  The caller should start with SLOT set to 0 and\n   increment it with each call until an error is returned. */\nint\napdu_enum_reader (int slot, int *used)\n{\n  if (slot < 0 || slot >= MAX_READER)\n    return SW_HOST_NO_DRIVER;\n  *used = reader_table[slot].used;\n  return 0;\n}\n\n\n/* Connect a card.  This is used to power up the card and make sure\n   that an ATR is available.  Depending on the reader backend it may\n   return an error for an inactive card or if no card is available.\n   Return -1 on error.  Return 1 if reader requires get_status to\n   watch card removal.  Return 0 if it's a token (always with a card),\n   or it supports INTERRUPT endpoint to watch card removal.\n  */\nint\napdu_connect (int slot)\n{\n  int sw = 0;\n  unsigned int status = 0;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_connect: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_connect => SW_HOST_NO_DRIVER\\n\");\n      return -1;\n    }\n\n  /* Only if the access method provides a connect function we use it.\n     If not, we expect that the card has been implicitly connected by\n     apdu_open_reader.  */\n  if (reader_table[slot].connect_card)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].connect_card (slot);\n          unlock_slot (slot);\n        }\n    }\n\n  /* We need to call apdu_get_status_internal, so that the last-status\n     machinery gets setup properly even if a card is inserted while\n     scdaemon is fired up and apdu_get_status has not yet been called.\n     Without that we would force a reset of the card with the next\n     call to apdu_get_status.  */\n  if (!sw)\n    sw = apdu_get_status_internal (slot, 1, &status, 1);\n\n  if (sw)\n    ;\n  else if (!(status & APDU_CARD_PRESENT))\n    sw = SW_HOST_NO_CARD;\n  else if ((status & APDU_CARD_PRESENT) && !(status & APDU_CARD_ACTIVE))\n    sw = SW_HOST_CARD_INACTIVE;\n\n  if (sw == SW_HOST_CARD_INACTIVE)\n    {\n      /* Try power it up again.  */\n      sw = apdu_reset (slot);\n    }\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_connect => sw=0x%x\\n\", sw);\n\n  if (sw)\n    return -1;\n\n  return reader_table[slot].require_get_status;\n}\n\n\nint\napdu_disconnect (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_disconnect: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_disconnect => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n\n  if (reader_table[slot].disconnect_card)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].disconnect_card (slot);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n\n  if (DBG_READER)\n    log_debug (\"leave: apdu_disconnect => sw=0x%x\\n\", sw);\n  return sw;\n}\n\n\n/* Set the progress callback of SLOT to CB and its args to CB_ARG.  If\n   CB is NULL the progress callback is removed.  */\nint\napdu_set_progress_cb (int slot, gcry_handler_progress_t cb, void *cb_arg)\n{\n  int sw;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].set_progress_cb)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].set_progress_cb (slot, cb, cb_arg);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n  return sw;\n}\n\n\nint\napdu_set_prompt_cb (int slot, void (*cb) (void *, int), void *cb_arg)\n{\n  int sw;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].set_prompt_cb)\n    {\n      sw = lock_slot (slot);\n      if (!sw)\n        {\n          sw = reader_table[slot].set_prompt_cb (slot, cb, cb_arg);\n          unlock_slot (slot);\n        }\n    }\n  else\n    sw = 0;\n  return sw;\n}\n\n\n/* Do a reset for the card in reader at SLOT. */\nint\napdu_reset (int slot)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_reset: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_reset => SW_HOST_NO_DRIVER\\n\");\n      return SW_HOST_NO_DRIVER;\n    }\n\n  if ((sw = lock_slot (slot)))\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_reset => sw=0x%x (lock_slot)\\n\", sw);\n      return sw;\n    }\n\n  if (reader_table[slot].reset_reader)\n    sw = reader_table[slot].reset_reader (slot);\n\n  unlock_slot (slot);\n  if (DBG_READER)\n    log_debug (\"leave: apdu_reset => sw=0x%x\\n\", sw);\n  return sw;\n}\n\n\n/* Return the ATR or NULL if none is available.  On success the length\n   of the ATR is stored at ATRLEN.  The caller must free the returned\n   value.  */\nunsigned char *\napdu_get_atr (int slot, size_t *atrlen)\n{\n  unsigned char *buf;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_get_atr: slot=%d\\n\", slot);\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (bad slot)\\n\");\n      return NULL;\n    }\n  if (!reader_table[slot].atrlen)\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (no ATR)\\n\");\n      return NULL;\n    }\n\n  buf = xtrymalloc (reader_table[slot].atrlen);\n  if (!buf)\n    {\n      if (DBG_READER)\n        log_debug (\"leave: apdu_get_atr => NULL (out of core)\\n\");\n      return NULL;\n    }\n  memcpy (buf, reader_table[slot].atr, reader_table[slot].atrlen);\n  *atrlen = reader_table[slot].atrlen;\n  if (DBG_READER)\n    log_debug (\"leave: apdu_get_atr => atrlen=%zu\\n\", *atrlen);\n  return buf;\n}\n\n\n\n/* Retrieve the status for SLOT. The function does only wait for the\n   card to become available if HANG is set to true. On success the\n   bits in STATUS will be set to\n\n     APDU_CARD_USABLE  (bit 0) = card present and usable\n     APDU_CARD_PRESENT (bit 1) = card present\n     APDU_CARD_ACTIVE  (bit 2) = card active\n                       (bit 3) = card access locked [not yet implemented]\n\n   For most applications, testing bit 0 is sufficient.\n*/\nstatic int\napdu_get_status_internal (int slot, int hang, unsigned int *status, int on_wire)\n{\n  int sw;\n  unsigned int s = 0;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if ((sw = hang? lock_slot (slot) : trylock_slot (slot)))\n    return sw;\n\n  if (reader_table[slot].get_status_reader)\n    sw = reader_table[slot].get_status_reader (slot, &s, on_wire);\n\n  unlock_slot (slot);\n\n  if (sw)\n    {\n      if (on_wire)\n        reader_table[slot].atrlen = 0;\n      s = 0;\n    }\n\n  if (status)\n    *status = s;\n  return sw;\n}\n\n\n/* See above for a description.  */\nint\napdu_get_status (int slot, int hang, unsigned int *status)\n{\n  int sw;\n\n  if (DBG_READER)\n    log_debug (\"enter: apdu_get_status: slot=%d hang=%d\\n\", slot, hang);\n  sw = apdu_get_status_internal (slot, hang, status, 0);\n  if (DBG_READER)\n    {\n      if (status)\n        log_debug (\"leave: apdu_get_status => sw=0x%x status=%u\\n\",\n                   sw, *status);\n      else\n        log_debug (\"leave: apdu_get_status => sw=0x%x\\n\", sw);\n    }\n  return sw;\n}\n\n\n/* Check whether the reader supports the ISO command code COMMAND on\n   the pinpad.  Return 0 on success.  For a description of the pin\n   parameters, see ccid-driver.c */\nint\napdu_check_pinpad (int slot, int command, pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (opt.enable_pinpad_varlen)\n    pininfo->fixedlen = 0;\n\n  if (reader_table[slot].check_pinpad)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].check_pinpad (slot, command, pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\nint\napdu_pinpad_verify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].pinpad_verify)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].pinpad_verify (slot, class, ins, p0, p1,\n                                             pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\nint\napdu_pinpad_modify (int slot, int class, int ins, int p0, int p1,\n                    pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].pinpad_modify)\n    {\n      int sw;\n\n      if ((sw = lock_slot (slot)))\n        return sw;\n\n      sw = reader_table[slot].pinpad_modify (slot, class, ins, p0, p1,\n                                             pininfo);\n      unlock_slot (slot);\n      return sw;\n    }\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Dispatcher for the actual send_apdu function. Note, that this\n   function should be called in locked state. */\nstatic int\nsend_apdu (int slot, unsigned char *apdu, size_t apdulen,\n           unsigned char *buffer, size_t *buflen, pininfo_t *pininfo)\n{\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (reader_table[slot].send_apdu_reader)\n    return reader_table[slot].send_apdu_reader (slot,\n                                                apdu, apdulen,\n                                                buffer, buflen,\n                                                pininfo);\n  else\n    return SW_HOST_NOT_SUPPORTED;\n}\n\n\n/* Core APDU tranceiver function. Parameters are described at\n   apdu_send_le with the exception of PININFO which indicates pinpad\n   related operations if not NULL.  If EXTENDED_MODE is not 0\n   command chaining or extended length will be used according to these\n   values:\n       n < 0 := Use command chaining with the data part limited to -n\n                in each chunk.  If -1 is used a default value is used.\n      n == 0 := No extended mode or command chaining.\n      n == 1 := Use extended length for input and output without a\n                length limit.\n       n > 1 := Use extended length with up to N bytes.\n\n*/\nstatic int\nsend_le (int slot, int class, int ins, int p0, int p1,\n         int lc, const char *data, int le,\n         unsigned char **retbuf, size_t *retbuflen,\n         pininfo_t *pininfo, int extended_mode)\n{\n#define SHORT_RESULT_BUFFER_SIZE 258\n  /* We allocate 8 extra bytes as a safety margin towards a driver bug.  */\n  unsigned char short_result_buffer[SHORT_RESULT_BUFFER_SIZE+10];\n  unsigned char *result_buffer = NULL;\n  size_t result_buffer_size;\n  unsigned char *result;\n  size_t resultlen;\n  unsigned char short_apdu_buffer[5+256+1];\n  unsigned char *apdu_buffer = NULL;\n  size_t apdu_buffer_size;\n  unsigned char *apdu;\n  size_t apdulen;\n  int sw;\n  long rc; /* We need a long here due to PC/SC. */\n  int did_exact_length_hack = 0;\n  int use_chaining = 0;\n  int use_extended_length = 0;\n  int lc_chunk;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (DBG_CARD_IO)\n    log_debug (\"send apdu: c=%02X i=%02X p1=%02X p2=%02X lc=%d le=%d em=%d\\n\",\n               class, ins, p0, p1, lc, le, extended_mode);\n\n  if (lc != -1 && (lc > 255 || lc < 0))\n    {\n      /* Data does not fit into an APDU.  What we do now depends on\n         the EXTENDED_MODE parameter.  */\n      if (!extended_mode)\n        return SW_WRONG_LENGTH; /* No way to send such an APDU.  */\n      else if (extended_mode > 0)\n        use_extended_length = 1;\n      else if (extended_mode < 0)\n        {\n          /* Send APDU using chaining mode.  */\n          if (lc > 16384)\n            return SW_WRONG_LENGTH;   /* Sanity check.  */\n          if ((class&0xf0) != 0)\n            return SW_HOST_INV_VALUE; /* Upper 4 bits need to be 0.  */\n          use_chaining = extended_mode == -1? 255 : -extended_mode;\n          use_chaining &= 0xff;\n        }\n      else\n        return SW_HOST_INV_VALUE;\n    }\n  else if (lc == -1 && extended_mode > 0)\n    use_extended_length = 1;\n\n  if (le != -1 && (le > (extended_mode > 0? 255:256) || le < 0))\n    {\n      /* Expected Data does not fit into an APDU.  What we do now\n         depends on the EXTENDED_MODE parameter.  Note that a check\n         for command chaining does not make sense because we are\n         looking at Le.  */\n      if (!extended_mode)\n        return SW_WRONG_LENGTH; /* No way to send such an APDU.  */\n      else if (use_extended_length)\n        ; /* We are already using extended length.  */\n      else if (extended_mode > 0)\n        use_extended_length = 1;\n      else\n        return SW_HOST_INV_VALUE;\n    }\n\n  if ((!data && lc != -1) || (data && lc == -1))\n    return SW_HOST_INV_VALUE;\n\n  if (use_extended_length)\n    {\n      if (reader_table[slot].is_t0)\n        return SW_HOST_NOT_SUPPORTED;\n\n      /* Space for: cls/ins/p1/p2+Z+2_byte_Lc+Lc+2_byte_Le.  */\n      apdu_buffer_size = 4 + 1 + (lc >= 0? (2+lc):0) + 2;\n      apdu_buffer = xtrymalloc (apdu_buffer_size + 10);\n      if (!apdu_buffer)\n        return SW_HOST_OUT_OF_CORE;\n      apdu = apdu_buffer;\n    }\n  else\n    {\n      apdu_buffer_size = sizeof short_apdu_buffer;\n      apdu = short_apdu_buffer;\n    }\n\n  if (use_extended_length && (le > 256 || le < 0))\n    {\n      /* Two more bytes are needed for status bytes.  */\n      result_buffer_size = le < 0? 4096 : (le + 2);\n      result_buffer = xtrymalloc (result_buffer_size);\n      if (!result_buffer)\n        {\n          xfree (apdu_buffer);\n          return SW_HOST_OUT_OF_CORE;\n        }\n      result = result_buffer;\n    }\n  else\n    {\n      result_buffer_size = SHORT_RESULT_BUFFER_SIZE;\n      result = short_result_buffer;\n    }\n#undef SHORT_RESULT_BUFFER_SIZE\n\n  if ((sw = lock_slot (slot)))\n    {\n      xfree (apdu_buffer);\n      xfree (result_buffer);\n      return sw;\n    }\n\n  do\n    {\n      if (use_extended_length)\n        {\n          use_chaining = 0;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = ins;\n          apdu[apdulen++] = p0;\n          apdu[apdulen++] = p1;\n          if (lc > 0)\n            {\n              apdu[apdulen++] = 0;  /* Z byte: Extended length marker.  */\n              apdu[apdulen++] = ((lc >> 8) & 0xff);\n              apdu[apdulen++] = (lc & 0xff);\n              memcpy (apdu+apdulen, data, lc);\n              data += lc;\n              apdulen += lc;\n            }\n          if (le != -1)\n            {\n              if (lc <= 0)\n                apdu[apdulen++] = 0;  /* Z byte: Extended length marker.  */\n              apdu[apdulen++] = ((le >> 8) & 0xff);\n              apdu[apdulen++] = (le & 0xff);\n            }\n        }\n      else\n        {\n          apdulen = 0;\n          apdu[apdulen] = class;\n          if (use_chaining && lc > 255)\n            {\n              apdu[apdulen] |= 0x10;\n              assert (use_chaining < 256);\n              lc_chunk = use_chaining;\n              lc -= use_chaining;\n            }\n          else\n            {\n              use_chaining = 0;\n              lc_chunk = lc;\n            }\n          apdulen++;\n          apdu[apdulen++] = ins;\n          apdu[apdulen++] = p0;\n          apdu[apdulen++] = p1;\n          if (lc_chunk != -1)\n            {\n              apdu[apdulen++] = lc_chunk;\n              memcpy (apdu+apdulen, data, lc_chunk);\n              data += lc_chunk;\n              apdulen += lc_chunk;\n              /* T=0 does not allow the use of Lc together with Le;\n                 thus disable Le in this case.  */\n              if (reader_table[slot].is_t0)\n                le = -1;\n            }\n          if (le != -1 && !use_chaining)\n            apdu[apdulen++] = le; /* Truncation is okay (0 means 256). */\n        }\n\n    exact_length_hack:\n      /* As a safeguard don't pass any garbage to the driver.  */\n      assert (apdulen <= apdu_buffer_size);\n      memset (apdu+apdulen, 0, apdu_buffer_size - apdulen);\n      resultlen = result_buffer_size;\n      rc = send_apdu (slot, apdu, apdulen, result, &resultlen, pininfo);\n      if (rc || resultlen < 2)\n        {\n          log_info (\"apdu_send_simple(%d) failed: %s\\n\",\n                    slot, apdu_strerror (rc));\n          unlock_slot (slot);\n          xfree (apdu_buffer);\n          xfree (result_buffer);\n          return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n        }\n      sw = (result[resultlen-2] << 8) | result[resultlen-1];\n      if (!use_extended_length\n          && !did_exact_length_hack && SW_EXACT_LENGTH_P (sw))\n        {\n          apdu[apdulen-1] = (sw & 0x00ff);\n          did_exact_length_hack = 1;\n          goto exact_length_hack;\n        }\n    }\n  while (use_chaining && sw == SW_SUCCESS);\n\n  if (apdu_buffer)\n    {\n      xfree (apdu_buffer);\n      apdu_buffer = NULL;\n    }\n\n  /* Store away the returned data but strip the statusword. */\n  resultlen -= 2;\n  if (DBG_CARD_IO)\n    {\n      log_debug (\" response: sw=%04X  datalen=%d\\n\",\n                 sw, (unsigned int)resultlen);\n      if ( !retbuf && (sw == SW_SUCCESS || (sw & 0xff00) == SW_MORE_DATA))\n        log_printhex (result, resultlen, \"    dump: \");\n    }\n\n  if (sw == SW_SUCCESS || sw == SW_EOF_REACHED)\n    {\n      if (retbuf)\n        {\n          *retbuf = xtrymalloc (resultlen? resultlen : 1);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          *retbuflen = resultlen;\n          memcpy (*retbuf, result, resultlen);\n        }\n    }\n  else if ((sw & 0xff00) == SW_MORE_DATA)\n    {\n      unsigned char *p = NULL, *tmp;\n      size_t bufsize = 4096;\n\n      /* It is likely that we need to return much more data, so we\n         start off with a large buffer. */\n      if (retbuf)\n        {\n          *retbuf = p = xtrymalloc (bufsize);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          assert (resultlen < bufsize);\n          memcpy (p, result, resultlen);\n          p += resultlen;\n        }\n\n      do\n        {\n          int len = (sw & 0x00ff);\n\n          if (DBG_CARD_IO)\n            log_debug (\"apdu_send_simple(%d): %d more bytes available\\n\",\n                       slot, len);\n          apdu_buffer_size = sizeof short_apdu_buffer;\n          apdu = short_apdu_buffer;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = 0xC0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = len;\n          assert (apdulen <= apdu_buffer_size);\n          memset (apdu+apdulen, 0, apdu_buffer_size - apdulen);\n          resultlen = result_buffer_size;\n          rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n          if (rc || resultlen < 2)\n            {\n              log_error (\"apdu_send_simple(%d) for get response failed: %s\\n\",\n                         slot, apdu_strerror (rc));\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n            }\n          sw = (result[resultlen-2] << 8) | result[resultlen-1];\n          resultlen -= 2;\n          if (DBG_CARD_IO)\n            {\n              log_debug (\"     more: sw=%04X  datalen=%d\\n\",\n                         sw, (unsigned int)resultlen);\n              if (!retbuf && (sw==SW_SUCCESS || (sw&0xff00)==SW_MORE_DATA))\n                log_printhex (result, resultlen, \"     dump: \");\n            }\n\n          if ((sw & 0xff00) == SW_MORE_DATA\n              || sw == SW_SUCCESS\n              || sw == SW_EOF_REACHED )\n            {\n              if (retbuf && resultlen)\n                {\n                  if (p - *retbuf + resultlen > bufsize)\n                    {\n                      bufsize += resultlen > 4096? resultlen: 4096;\n                      tmp = xtryrealloc (*retbuf, bufsize);\n                      if (!tmp)\n                        {\n                          unlock_slot (slot);\n                          xfree (result_buffer);\n                          return SW_HOST_OUT_OF_CORE;\n                        }\n                      p = tmp + (p - *retbuf);\n                      *retbuf = tmp;\n                    }\n                  memcpy (p, result, resultlen);\n                  p += resultlen;\n                }\n            }\n          else\n            log_info (\"apdu_send_simple(%d) \"\n                      \"got unexpected status %04X from get response\\n\",\n                      slot, sw);\n        }\n      while ((sw & 0xff00) == SW_MORE_DATA);\n\n      if (retbuf)\n        {\n          *retbuflen = p - *retbuf;\n          tmp = xtryrealloc (*retbuf, *retbuflen);\n          if (tmp)\n            *retbuf = tmp;\n        }\n    }\n\n  unlock_slot (slot);\n  xfree (result_buffer);\n\n  if (DBG_CARD_IO && retbuf && sw == SW_SUCCESS)\n    log_printhex (*retbuf, *retbuflen, \"      dump: \");\n\n  return sw;\n}\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA, LE.  A value of -1\n   for LC won't sent this field and the data field; in this case DATA\n   must also be passed as NULL.  If EXTENDED_MODE is not 0 command\n   chaining or extended length will be used; see send_le for details.\n   The return value is the status word or -1 for an invalid SLOT or\n   other non card related error.  If RETBUF is not NULL, it will\n   receive an allocated buffer with the returned data.  The length of\n   that data will be put into *RETBUFLEN.  The caller is responsible\n   for releasing the buffer even in case of errors.  */\nint\napdu_send_le(int slot, int extended_mode,\n             int class, int ins, int p0, int p1,\n             int lc, const char *data, int le,\n             unsigned char **retbuf, size_t *retbuflen)\n{\n  return send_le (slot, class, ins, p0, p1,\n                  lc, data, le,\n                  retbuf, retbuflen,\n                  NULL, extended_mode);\n}\n\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA.  A value of -1 for\n   LC won't sent this field and the data field; in this case DATA must\n   also be passed as NULL.  If EXTENDED_MODE is not 0 command chaining\n   or extended length will be used; see send_le for details.  The\n   return value is the status word or -1 for an invalid SLOT or other\n   non card related error.  If RETBUF is not NULL, it will receive an\n   allocated buffer with the returned data.  The length of that data\n   will be put into *RETBUFLEN.  The caller is responsible for\n   releasing the buffer even in case of errors.  */\nint\napdu_send (int slot, int extended_mode,\n           int class, int ins, int p0, int p1,\n           int lc, const char *data, unsigned char **retbuf, size_t *retbuflen)\n{\n  return send_le (slot, class, ins, p0, p1, lc, data, 256,\n                  retbuf, retbuflen, NULL, extended_mode);\n}\n\n/* Send an APDU to the card in SLOT.  The APDU is created from all\n   given parameters: CLASS, INS, P0, P1, LC, DATA.  A value of -1 for\n   LC won't sent this field and the data field; in this case DATA must\n   also be passed as NULL.  If EXTENDED_MODE is not 0 command chaining\n   or extended length will be used; see send_le for details.  The\n   return value is the status word or -1 for an invalid SLOT or other\n   non card related error.  No data will be returned.  */\nint\napdu_send_simple (int slot, int extended_mode,\n                  int class, int ins, int p0, int p1,\n                  int lc, const char *data)\n{\n  return send_le (slot, class, ins, p0, p1, lc, data, -1, NULL, NULL, NULL,\n                  extended_mode);\n}\n\n\n/* This is a more generic version of the apdu sending routine.  It\n * takes an already formatted APDU in APDUDATA or length APDUDATALEN\n * and returns with an APDU including the status word.  With\n * HANDLE_MORE set to true this function will handle the MORE DATA\n * status and return all APDUs concatenated with one status word at\n * the end.  If EXTENDED_LENGTH is != 0 extended lengths are allowed\n * with a max. result data length of EXTENDED_LENGTH bytes.  The\n * function does not return a regular status word but 0 on success.\n * If the slot is locked, the function returns immediately with an\n * error.\n *\n * Out of historical reasons the function returns 0 on success and\n * outs the status word at the end of the result to be able to get the\n * status word in the case of a not provided RETBUF, R_SW can be used\n * to store the SW.  But note that R_SW qill only be set if the\n * function returns 0. */\nint\napdu_send_direct (int slot, size_t extended_length,\n                  const unsigned char *apdudata, size_t apdudatalen,\n                  int handle_more, unsigned int *r_sw,\n                  unsigned char **retbuf, size_t *retbuflen)\n{\n#define SHORT_RESULT_BUFFER_SIZE 258\n  unsigned char short_result_buffer[SHORT_RESULT_BUFFER_SIZE+10];\n  unsigned char *result_buffer = NULL;\n  size_t result_buffer_size;\n  unsigned char *result;\n  size_t resultlen;\n  unsigned char short_apdu_buffer[5+256+10];\n  unsigned char *apdu_buffer = NULL;\n  unsigned char *apdu;\n  size_t apdulen;\n  int sw;\n  long rc; /* we need a long here due to PC/SC. */\n  int class;\n\n  if (slot < 0 || slot >= MAX_READER || !reader_table[slot].used )\n    return SW_HOST_NO_DRIVER;\n\n  if (apdudatalen > 65535)\n    return SW_HOST_INV_VALUE;\n\n  if (apdudatalen > sizeof short_apdu_buffer - 5)\n    {\n      apdu_buffer = xtrymalloc (apdudatalen + 5);\n      if (!apdu_buffer)\n        return SW_HOST_OUT_OF_CORE;\n      apdu = apdu_buffer;\n    }\n  else\n    {\n      apdu = short_apdu_buffer;\n    }\n  apdulen = apdudatalen;\n  memcpy (apdu, apdudata, apdudatalen);\n  class = apdulen? *apdu : 0;\n\n  if (extended_length >= 256 && extended_length <= 65536)\n    {\n      result_buffer_size = extended_length;\n      result_buffer = xtrymalloc (result_buffer_size + 10);\n      if (!result_buffer)\n        {\n          xfree (apdu_buffer);\n          return SW_HOST_OUT_OF_CORE;\n        }\n      result = result_buffer;\n    }\n  else\n    {\n      result_buffer_size = SHORT_RESULT_BUFFER_SIZE;\n      result = short_result_buffer;\n    }\n#undef SHORT_RESULT_BUFFER_SIZE\n\n  if ((sw = trylock_slot (slot)))\n    {\n      xfree (apdu_buffer);\n      xfree (result_buffer);\n      return sw;\n    }\n\n  resultlen = result_buffer_size;\n  rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n  xfree (apdu_buffer);\n  apdu_buffer = NULL;\n  if (rc || resultlen < 2)\n    {\n      log_error (\"apdu_send_direct(%d) failed: %s\\n\",\n                 slot, apdu_strerror (rc));\n      unlock_slot (slot);\n      xfree (result_buffer);\n      return rc? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n    }\n  sw = (result[resultlen-2] << 8) | result[resultlen-1];\n  /* Store away the returned data but strip the statusword. */\n  resultlen -= 2;\n  if (DBG_CARD_IO)\n    {\n      log_debug (\" response: sw=%04X  datalen=%d\\n\",\n                 sw, (unsigned int)resultlen);\n      if ( !retbuf && (sw == SW_SUCCESS || (sw & 0xff00) == SW_MORE_DATA))\n        log_printhex (result, resultlen, \"     dump: \");\n    }\n\n  if (handle_more && (sw & 0xff00) == SW_MORE_DATA)\n    {\n      unsigned char *p = NULL, *tmp;\n      size_t bufsize = 4096;\n\n      /* It is likely that we need to return much more data, so we\n         start off with a large buffer. */\n      if (retbuf)\n        {\n          *retbuf = p = xtrymalloc (bufsize + 2);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          assert (resultlen < bufsize);\n          memcpy (p, result, resultlen);\n          p += resultlen;\n        }\n\n      do\n        {\n          int len = (sw & 0x00ff);\n\n          if (DBG_CARD_IO)\n            log_debug (\"apdu_send_direct(%d): %d more bytes available\\n\",\n                       slot, len);\n          apdu = short_apdu_buffer;\n          apdulen = 0;\n          apdu[apdulen++] = class;\n          apdu[apdulen++] = 0xC0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = 0;\n          apdu[apdulen++] = len;\n          memset (apdu+apdulen, 0, sizeof (short_apdu_buffer) - apdulen);\n          resultlen = result_buffer_size;\n          rc = send_apdu (slot, apdu, apdulen, result, &resultlen, NULL);\n          if (rc || resultlen < 2)\n            {\n              log_error (\"apdu_send_direct(%d) for get response failed: %s\\n\",\n                         slot, apdu_strerror (rc));\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return rc ? rc : SW_HOST_INCOMPLETE_CARD_RESPONSE;\n            }\n          sw = (result[resultlen-2] << 8) | result[resultlen-1];\n          resultlen -= 2;\n          if (DBG_CARD_IO)\n            {\n              log_debug (\"     more: sw=%04X  datalen=%d\\n\",\n                         sw, (unsigned int)resultlen);\n              if (!retbuf && (sw==SW_SUCCESS || (sw&0xff00)==SW_MORE_DATA))\n                log_printhex (result, resultlen, \"     dump: \");\n            }\n\n          if ((sw & 0xff00) == SW_MORE_DATA\n              || sw == SW_SUCCESS\n              || sw == SW_EOF_REACHED )\n            {\n              if (retbuf && resultlen)\n                {\n                  if (p - *retbuf + resultlen > bufsize)\n                    {\n                      bufsize += resultlen > 4096? resultlen: 4096;\n                      tmp = xtryrealloc (*retbuf, bufsize + 2);\n                      if (!tmp)\n                        {\n                          unlock_slot (slot);\n                          xfree (result_buffer);\n                          return SW_HOST_OUT_OF_CORE;\n                        }\n                      p = tmp + (p - *retbuf);\n                      *retbuf = tmp;\n                    }\n                  memcpy (p, result, resultlen);\n                  p += resultlen;\n                }\n            }\n          else\n            log_info (\"apdu_send_direct(%d) \"\n                      \"got unexpected status %04X from get response\\n\",\n                      slot, sw);\n        }\n      while ((sw & 0xff00) == SW_MORE_DATA);\n\n      if (retbuf)\n        {\n          *retbuflen = p - *retbuf;\n          tmp = xtryrealloc (*retbuf, *retbuflen + 2);\n          if (tmp)\n            *retbuf = tmp;\n        }\n    }\n  else\n    {\n      if (retbuf)\n        {\n          *retbuf = xtrymalloc ((resultlen? resultlen : 1)+2);\n          if (!*retbuf)\n            {\n              unlock_slot (slot);\n              xfree (result_buffer);\n              return SW_HOST_OUT_OF_CORE;\n            }\n          *retbuflen = resultlen;\n          memcpy (*retbuf, result, resultlen);\n        }\n    }\n\n  unlock_slot (slot);\n  xfree (result_buffer);\n\n  /* Append the status word.  Note that we reserved the two extra\n     bytes while allocating the buffer.  */\n  if (retbuf)\n    {\n      (*retbuf)[(*retbuflen)++] = (sw >> 8);\n      (*retbuf)[(*retbuflen)++] = sw;\n    }\n\n  if (r_sw)\n    *r_sw = sw;\n\n  if (DBG_CARD_IO && retbuf)\n    log_printhex (*retbuf, *retbuflen, \"      dump: \");\n\n\n  return 0;\n}\n\n\nconst char *\napdu_get_reader_name (int slot)\n{\n  return reader_table[slot].rdrname;\n}\n\ngpg_error_t\napdu_init (void)\n{\n#ifdef USE_NPTH\n  gpg_error_t err;\n  int i;\n\n  if (npth_mutex_init (&reader_table_lock, NULL))\n    goto leave;\n\n  for (i = 0; i < MAX_READER; i++)\n    if (npth_mutex_init (&reader_table[i].lock, NULL))\n      goto leave;\n\n  /* All done well.  */\n  return 0;\n\n leave:\n  err = gpg_error_from_syserror ();\n  log_error (\"apdu: error initializing mutex: %s\\n\", gpg_strerror (err));\n  return err;\n#endif /*USE_NPTH*/\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/iobuf.c": "/* iobuf.c  -  File Handling for OpenPGP.\n * Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2006, 2007, 2008,\n *               2009, 2010, 2011  Free Software Foundation, Inc.\n * Copyright (C) 2015  g10 Code GmbH\n *\n * This file is part of GnuPG.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#ifdef HAVE_W32_SYSTEM\n# ifdef HAVE_WINSOCK2_H\n#  include <winsock2.h>\n# endif\n# include <windows.h>\n#endif\n#ifdef __riscos__\n# include <kernel.h>\n# include <swis.h>\n#endif /* __riscos__ */\n\n#include <assuan.h>\n\n#include \"util.h\"\n#include \"sysutils.h\"\n#include \"iobuf.h\"\n\n/*-- Begin configurable part.  --*/\n\n/* The size of the internal buffers.\n   NOTE: If you change this value you MUST also adjust the regression\n   test \"armored_key_8192\" in armor.test! */\n#define IOBUF_BUFFER_SIZE  8192\n\n/* To avoid a potential DoS with compression packets we better limit\n   the number of filters in a chain.  */\n#define MAX_NESTING_FILTER 64\n\n/*-- End configurable part.  --*/\n\n\n#ifdef HAVE_W32_SYSTEM\n# ifdef HAVE_W32CE_SYSTEM\n#  define FD_FOR_STDIN  (es_fileno (es_stdin))\n#  define FD_FOR_STDOUT (es_fileno (es_stdout))\n# else\n#  define FD_FOR_STDIN  (GetStdHandle (STD_INPUT_HANDLE))\n#  define FD_FOR_STDOUT (GetStdHandle (STD_OUTPUT_HANDLE))\n# endif\n#else /*!HAVE_W32_SYSTEM*/\n# define FD_FOR_STDIN  (0)\n# define FD_FOR_STDOUT (1)\n#endif /*!HAVE_W32_SYSTEM*/\n\n\n/* The context used by the file filter.  */\ntypedef struct\n{\n  gnupg_fd_t fp;       /* Open file pointer or handle.  */\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name; /* Flags indicating that fname is not a real file.  */\n  char fname[1];       /* Name of the file.  */\n} file_filter_ctx_t;\n\n/* The context used by the estream filter.  */\ntypedef struct\n{\n  estream_t fp;        /* Open estream handle.  */\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name; /* Flags indicating that fname is not a real file.  */\n  char fname[1];       /* Name of the file.  */\n} file_es_filter_ctx_t;\n\n\n/* Object to control the \"close cache\".  */\nstruct close_cache_s\n{\n  struct close_cache_s *next;\n  gnupg_fd_t fp;\n  char fname[1];\n};\ntypedef struct close_cache_s *close_cache_t;\nstatic close_cache_t close_cache;\n\nint iobuf_debug_mode;\n\n\n#ifdef HAVE_W32_SYSTEM\ntypedef struct\n{\n  int sock;\n  int keep_open;\n  int no_cache;\n  int eof_seen;\n  int print_only_name;\t/* Flag indicating that fname is not a real file.  */\n  char fname[1];\t/* Name of the file */\n\n} sock_filter_ctx_t;\n#endif /*HAVE_W32_SYSTEM*/\n\n/* The first partial length header block must be of size 512 to make\n * it easier (and more efficient) we use a min. block size of 512 for\n * all chunks (but the last one) */\n#define OP_MIN_PARTIAL_CHUNK\t  512\n#define OP_MIN_PARTIAL_CHUNK_2POW 9\n\n/* The context we use for the block filter (used to handle OpenPGP\n   length information header).  */\ntypedef struct\n{\n  int use;\n  size_t size;\n  size_t count;\n  int partial;\t   /* 1 = partial header, 2 in last partial packet.  */\n  char *buffer;\t   /* Used for partial header.  */\n  size_t buflen;   /* Used size of buffer.  */\n  int first_c;\t   /* First character of a partial header (which is > 0).  */\n  int eof;\n}\nblock_filter_ctx_t;\n\n\n/* Local prototypes.  */\nstatic int underflow (iobuf_t a, int clear_pending_eof);\nstatic int underflow_target (iobuf_t a, int clear_pending_eof, size_t target);\nstatic int translate_file_handle (int fd, int for_write);\n\n/* Sends any pending data to the filter's FILTER function.  Note: this\n   works on the filter and not on the whole pipeline.  That is,\n   iobuf_flush doesn't necessarily cause data to be written to any\n   underlying file; it just causes any data buffered at the filter A\n   to be sent to A's filter function.\n\n   If A is a IOBUF_OUTPUT_TEMP filter, then this also enlarges the\n   buffer by IOBUF_BUFFER_SIZE.\n\n   May only be called on an IOBUF_OUTPUT or IOBUF_OUTPUT_TEMP filters.  */\nstatic int filter_flush (iobuf_t a);\n\n\n\f\n/* This is a replacement for strcmp.  Under W32 it does not\n   distinguish between backslash and slash.  */\nstatic int\nfd_cache_strcmp (const char *a, const char *b)\n{\n#ifdef HAVE_DOSISH_SYSTEM\n  for (; *a && *b; a++, b++)\n    {\n      if (*a != *b && !((*a == '/' && *b == '\\\\')\n                        || (*a == '\\\\' && *b == '/')) )\n        break;\n    }\n  return *(const unsigned char *)a - *(const unsigned char *)b;\n#else\n  return strcmp (a, b);\n#endif\n}\n\n/*\n * Invalidate (i.e. close) a cached iobuf\n */\nstatic int\nfd_cache_invalidate (const char *fname)\n{\n  close_cache_t cc;\n  int rc = 0;\n\n  assert (fname);\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_invalidate (%s)\\n\", fname);\n\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"                did (%s)\\n\", cc->fname);\n#ifdef HAVE_W32_SYSTEM\n\t  if (!CloseHandle (cc->fp))\n            rc = -1;\n#else\n\t  rc = close (cc->fp);\n#endif\n\t  cc->fp = GNUPG_INVALID_FD;\n\t}\n    }\n  return rc;\n}\n\n\n/* Try to sync changes to the disk.  This is to avoid data loss during\n   a system crash in write/close/rename cycle on some file\n   systems.  */\nstatic int\nfd_cache_synchronize (const char *fname)\n{\n  int err = 0;\n\n#ifdef HAVE_FSYNC\n  close_cache_t cc;\n\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_synchronize (%s)\\n\", fname);\n\n  for (cc=close_cache; cc; cc = cc->next )\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"                 did (%s)\\n\", cc->fname);\n\n\t  err = fsync (cc->fp);\n\t}\n    }\n#else\n  (void)fname;\n#endif /*HAVE_FSYNC*/\n\n  return err;\n}\n\n\nstatic gnupg_fd_t\ndirect_open (const char *fname, const char *mode, int mode700)\n{\n#ifdef HAVE_W32_SYSTEM\n  unsigned long da, cd, sm;\n  HANDLE hfile;\n\n  (void)mode700;\n  /* Note, that we do not handle all mode combinations */\n\n  /* According to the ReactOS source it seems that open() of the\n   * standard MSW32 crt does open the file in shared mode which is\n   * something new for MS applications ;-)\n   */\n  if (strchr (mode, '+'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      da = GENERIC_READ | GENERIC_WRITE;\n      cd = OPEN_EXISTING;\n      sm = FILE_SHARE_READ | FILE_SHARE_WRITE;\n    }\n  else if (strchr (mode, 'w'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      da = GENERIC_WRITE;\n      cd = CREATE_ALWAYS;\n      sm = FILE_SHARE_WRITE;\n    }\n  else\n    {\n      da = GENERIC_READ;\n      cd = OPEN_EXISTING;\n      sm = FILE_SHARE_READ;\n    }\n\n#ifdef HAVE_W32CE_SYSTEM\n  {\n    wchar_t *wfname = utf8_to_wchar (fname);\n    if (wfname)\n      {\n        hfile = CreateFile (wfname, da, sm, NULL, cd,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n        xfree (wfname);\n      }\n    else\n      hfile = INVALID_HANDLE_VALUE;\n  }\n#else\n  hfile = CreateFile (fname, da, sm, NULL, cd, FILE_ATTRIBUTE_NORMAL, NULL);\n#endif\n  return hfile;\n\n#else /*!HAVE_W32_SYSTEM*/\n\n  int oflag;\n  int cflag = S_IRUSR | S_IWUSR;\n\n  if (!mode700)\n    cflag |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n\n  /* Note, that we do not handle all mode combinations */\n  if (strchr (mode, '+'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      oflag = O_RDWR;\n    }\n  else if (strchr (mode, 'w'))\n    {\n      if (fd_cache_invalidate (fname))\n        return GNUPG_INVALID_FD;\n      oflag = O_WRONLY | O_CREAT | O_TRUNC;\n    }\n  else\n    {\n      oflag = O_RDONLY;\n    }\n#ifdef O_BINARY\n  if (strchr (mode, 'b'))\n    oflag |= O_BINARY;\n#endif\n\n#ifdef __riscos__\n  {\n    struct stat buf;\n\n    /* Don't allow iobufs on directories */\n    if (!stat (fname, &buf) && S_ISDIR (buf.st_mode) && !S_ISREG (buf.st_mode))\n      return __set_errno (EISDIR);\n  }\n#endif\n  return open (fname, oflag, cflag);\n\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/*\n * Instead of closing an FD we keep it open and cache it for later reuse\n * Note that this caching strategy only works if the process does not chdir.\n */\nstatic void\nfd_cache_close (const char *fname, gnupg_fd_t fp)\n{\n  close_cache_t cc;\n\n  assert (fp);\n  if (!fname || !*fname)\n    {\n#ifdef HAVE_W32_SYSTEM\n      CloseHandle (fp);\n#else\n      close (fp);\n#endif\n      if (DBG_IOBUF)\n\tlog_debug (\"fd_cache_close (%d) real\\n\", (int)fp);\n      return;\n    }\n  /* try to reuse a slot */\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp == GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  cc->fp = fp;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"fd_cache_close (%s) used existing slot\\n\", fname);\n\t  return;\n\t}\n    }\n  /* add a new one */\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_close (%s) new slot created\\n\", fname);\n  cc = xcalloc (1, sizeof *cc + strlen (fname));\n  strcpy (cc->fname, fname);\n  cc->fp = fp;\n  cc->next = close_cache;\n  close_cache = cc;\n}\n\n/*\n * Do a direct_open on FNAME but first try to reuse one from the fd_cache\n */\nstatic gnupg_fd_t\nfd_cache_open (const char *fname, const char *mode)\n{\n  close_cache_t cc;\n\n  assert (fname);\n  for (cc = close_cache; cc; cc = cc->next)\n    {\n      if (cc->fp != GNUPG_INVALID_FD && !fd_cache_strcmp (cc->fname, fname))\n\t{\n\t  gnupg_fd_t fp = cc->fp;\n\t  cc->fp = GNUPG_INVALID_FD;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"fd_cache_open (%s) using cached fp\\n\", fname);\n#ifdef HAVE_W32_SYSTEM\n\t  if (SetFilePointer (fp, 0, NULL, FILE_BEGIN) == 0xffffffff)\n\t    {\n\t      log_error (\"rewind file failed on handle %p: ec=%d\\n\",\n\t\t\t fp, (int) GetLastError ());\n\t      fp = GNUPG_INVALID_FD;\n\t    }\n#else\n\t  if (lseek (fp, 0, SEEK_SET) == (off_t) - 1)\n\t    {\n\t      log_error (\"can't rewind fd %d: %s\\n\", fp, strerror (errno));\n\t      fp = GNUPG_INVALID_FD;\n\t    }\n#endif\n\t  return fp;\n\t}\n    }\n  if (DBG_IOBUF)\n    log_debug (\"fd_cache_open (%s) not cached\\n\", fname);\n  return direct_open (fname, mode, 0);\n}\n\n\nstatic int\nfile_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n\t     size_t * ret_len)\n{\n  file_filter_ctx_t *a = opaque;\n  gnupg_fd_t f = a->fp;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain; /* Not used.  */\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size); /* We need a buffer.  */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n#ifdef HAVE_W32_SYSTEM\n\t  unsigned long nread;\n\n\t  nbytes = 0;\n\t  if (!ReadFile (f, buf, size, &nread, NULL))\n\t    {\n\t      int ec = (int) GetLastError ();\n\t      if (ec != ERROR_BROKEN_PIPE)\n\t\t{\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"%s: read error: ec=%d\\n\", a->fname, ec);\n\t\t}\n\t    }\n\t  else if (!nread)\n\t    {\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = nread;\n\t    }\n\n#else\n\n\t  int n;\n\n\t  nbytes = 0;\n\t  do\n\t    {\n\t      n = read (f, buf, size);\n\t    }\n\t  while (n == -1 && errno == EINTR);\n\t  if (n == -1)\n\t    {\t\t\t/* error */\n\t      if (errno != EPIPE)\n\t\t{\n\t\t  rc = gpg_error_from_syserror ();\n\t\t  log_error (\"%s: read error: %s\\n\",\n\t\t\t     a->fname, strerror (errno));\n\t\t}\n\t    }\n\t  else if (!n)\n\t    {\t\t\t/* eof */\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = n;\n\t    }\n#endif\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n#ifdef HAVE_W32_SYSTEM\n\t  byte *p = buf;\n\t  unsigned long n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      if (size && !WriteFile (f, p, nbytes, &n, NULL))\n\t\t{\n\t\t  int ec = (int) GetLastError ();\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"%s: write error: ec=%d\\n\", a->fname, ec);\n\t\t  break;\n\t\t}\n\t      p += n;\n\t      nbytes -= n;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n#else\n\t  byte *p = buf;\n\t  int n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      do\n\t\t{\n\t\t  n = write (f, p, nbytes);\n\t\t}\n\t      while (n == -1 && errno == EINTR);\n\t      if (n > 0)\n\t\t{\n\t\t  p += n;\n\t\t  nbytes -= n;\n\t\t}\n\t    }\n\t  while (n != -1 && nbytes);\n\t  if (n == -1)\n\t    {\n\t      rc = gpg_error_from_syserror ();\n\t      log_error (\"%s: write error: %s\\n\", a->fname, strerror (errno));\n\t    }\n\t  nbytes = p - buf;\n#endif\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->keep_open = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"file_filter(fd)\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (f != FD_FOR_STDIN && f != FD_FOR_STDOUT)\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"%s: close fd/handle %d\\n\", a->fname, FD2INT (f));\n\t  if (!a->keep_open)\n\t    fd_cache_close (a->no_cache ? NULL : a->fname, f);\n\t}\n      xfree (a); /* We can free our context now. */\n    }\n\n  return rc;\n}\n\n\n/* Similar to file_filter but using the estream system.  */\nstatic int\nfile_es_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n                size_t * ret_len)\n{\n  file_es_filter_ctx_t *a = opaque;\n  estream_t f = a->fp;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain; /* Not used.  */\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size); /* We need a buffer.  */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n          nbytes = 0;\n          rc = es_read (f, buf, size, &nbytes);\n\t  if (rc == -1)\n\t    {\t\t\t/* error */\n              rc = gpg_error_from_syserror ();\n              log_error (\"%s: read error: %s\\n\", a->fname, strerror (errno));\n\t    }\n\t  else if (!nbytes)\n\t    {\t\t\t/* eof */\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n\t  byte *p = buf;\n\t  size_t nwritten;\n\n\t  nbytes = size;\n\t  do\n\t    {\n              nwritten = 0;\n              if (es_write (f, p, nbytes, &nwritten))\n                {\n                  rc = gpg_error_from_syserror ();\n                  log_error (\"%s: write error: %s\\n\",\n                             a->fname, strerror (errno));\n                  break;\n                }\n              p += nwritten;\n              nbytes -= nwritten;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"estream_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (f != es_stdin && f != es_stdout)\n\t{\n\t  if (DBG_IOBUF)\n\t    log_debug (\"%s: es_fclose %p\\n\", a->fname, f);\n\t  if (!a->keep_open)\n\t    es_fclose (f);\n\t}\n      f = NULL;\n      xfree (a); /* We can free our context now. */\n    }\n\n  return rc;\n}\n\n\n#ifdef HAVE_W32_SYSTEM\n/* Because network sockets are special objects under Lose32 we have to\n   use a dedicated filter for them. */\nstatic int\nsock_filter (void *opaque, int control, iobuf_t chain, byte * buf,\n\t     size_t * ret_len)\n{\n  sock_filter_ctx_t *a = opaque;\n  size_t size = *ret_len;\n  size_t nbytes = 0;\n  int rc = 0;\n\n  (void)chain;\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      assert (size);\t\t/* need a buffer */\n      if (a->eof_seen)\n\t{\n\t  rc = -1;\n\t  *ret_len = 0;\n\t}\n      else\n\t{\n\t  int nread;\n\n\t  nread = recv (a->sock, buf, size, 0);\n\t  if (nread == SOCKET_ERROR)\n\t    {\n\t      int ec = (int) WSAGetLastError ();\n\t      rc = gpg_error_from_errno (ec);\n\t      log_error (\"socket read error: ec=%d\\n\", ec);\n\t    }\n\t  else if (!nread)\n\t    {\n\t      a->eof_seen = 1;\n\t      rc = -1;\n\t    }\n\t  else\n\t    {\n\t      nbytes = nread;\n\t    }\n\t  *ret_len = nbytes;\n\t}\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (size)\n\t{\n\t  byte *p = buf;\n\t  int n;\n\n\t  nbytes = size;\n\t  do\n\t    {\n\t      n = send (a->sock, p, nbytes, 0);\n\t      if (n == SOCKET_ERROR)\n\t\t{\n\t\t  int ec = (int) WSAGetLastError ();\n\t\t  rc = gpg_error_from_errno (ec);\n\t\t  log_error (\"socket write error: ec=%d\\n\", ec);\n\t\t  break;\n\t\t}\n\t      p += n;\n\t      nbytes -= n;\n\t    }\n\t  while (nbytes);\n\t  nbytes = p - buf;\n\t}\n      *ret_len = nbytes;\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      a->eof_seen = 0;\n      a->keep_open = 0;\n      a->no_cache = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"sock_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (!a->keep_open)\n\tclosesocket (a->sock);\n      xfree (a);\t\t/* we can free our context now */\n    }\n  return rc;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n/****************\n * This is used to implement the block write mode.\n * Block reading is done on a byte by byte basis in readbyte(),\n * without a filter\n */\nstatic int\nblock_filter (void *opaque, int control, iobuf_t chain, byte * buffer,\n\t      size_t * ret_len)\n{\n  block_filter_ctx_t *a = opaque;\n  char *buf = (char *)buffer;\n  size_t size = *ret_len;\n  int c, needed, rc = 0;\n  char *p;\n\n  if (control == IOBUFCTRL_UNDERFLOW)\n    {\n      size_t n = 0;\n\n      p = buf;\n      assert (size);\t\t/* need a buffer */\n      if (a->eof)\t\t/* don't read any further */\n\trc = -1;\n      while (!rc && size)\n\t{\n\t  if (!a->size)\n\t    {\t\t\t/* get the length bytes */\n\t      if (a->partial == 2)\n\t\t{\n\t\t  a->eof = 1;\n\t\t  if (!n)\n\t\t    rc = -1;\n\t\t  break;\n\t\t}\n\t      else if (a->partial)\n\t\t{\n\t\t  /* These OpenPGP introduced huffman like encoded length\n\t\t   * bytes are really a mess :-( */\n\t\t  if (a->first_c)\n\t\t    {\n\t\t      c = a->first_c;\n\t\t      a->first_c = 0;\n\t\t    }\n\t\t  else if ((c = iobuf_get (chain)) == -1)\n\t\t    {\n\t\t      log_error (\"block_filter: 1st length byte missing\\n\");\n\t\t      rc = GPG_ERR_BAD_DATA;\n\t\t      break;\n\t\t    }\n\t\t  if (c < 192)\n\t\t    {\n\t\t      a->size = c;\n\t\t      a->partial = 2;\n\t\t      if (!a->size)\n\t\t\t{\n\t\t\t  a->eof = 1;\n\t\t\t  if (!n)\n\t\t\t    rc = -1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (c < 224)\n\t\t    {\n\t\t      a->size = (c - 192) * 256;\n\t\t      if ((c = iobuf_get (chain)) == -1)\n\t\t\t{\n\t\t\t  log_error\n\t\t\t    (\"block_filter: 2nd length byte missing\\n\");\n\t\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t\t  break;\n\t\t\t}\n\t\t      a->size += c + 192;\n\t\t      a->partial = 2;\n\t\t      if (!a->size)\n\t\t\t{\n\t\t\t  a->eof = 1;\n\t\t\t  if (!n)\n\t\t\t    rc = -1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (c == 255)\n\t\t    {\n\t\t      a->size = iobuf_get_noeof (chain) << 24;\n\t\t      a->size |= iobuf_get_noeof (chain) << 16;\n\t\t      a->size |= iobuf_get_noeof (chain) << 8;\n\t\t      if ((c = iobuf_get (chain)) == -1)\n\t\t\t{\n\t\t\t  log_error (\"block_filter: invalid 4 byte length\\n\");\n\t\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t\t  break;\n\t\t\t}\n\t\t      a->size |= c;\n                      a->partial = 2;\n                      if (!a->size)\n                        {\n                          a->eof = 1;\n                          if (!n)\n                            rc = -1;\n                          break;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    { /* Next partial body length. */\n\t\t      a->size = 1 << (c & 0x1f);\n\t\t    }\n\t\t  /*  log_debug(\"partial: ctx=%p c=%02x size=%u\\n\", a, c, a->size); */\n\t\t}\n\t      else\n\t\tBUG ();\n\t    }\n\n\t  while (!rc && size && a->size)\n\t    {\n\t      needed = size < a->size ? size : a->size;\n\t      c = iobuf_read (chain, p, needed);\n\t      if (c < needed)\n\t\t{\n\t\t  if (c == -1)\n\t\t    c = 0;\n\t\t  log_error\n\t\t    (\"block_filter %p: read error (size=%lu,a->size=%lu)\\n\",\n\t\t     a, (ulong) size + c, (ulong) a->size + c);\n\t\t  rc = GPG_ERR_BAD_DATA;\n\t\t}\n\t      else\n\t\t{\n\t\t  size -= c;\n\t\t  a->size -= c;\n\t\t  p += c;\n\t\t  n += c;\n\t\t}\n\t    }\n\t}\n      *ret_len = n;\n    }\n  else if (control == IOBUFCTRL_FLUSH)\n    {\n      if (a->partial)\n\t{\t\t\t/* the complicated openpgp scheme */\n\t  size_t blen, n, nbytes = size + a->buflen;\n\n\t  assert (a->buflen <= OP_MIN_PARTIAL_CHUNK);\n\t  if (nbytes < OP_MIN_PARTIAL_CHUNK)\n\t    {\n\t      /* not enough to write a partial block out; so we store it */\n\t      if (!a->buffer)\n\t\ta->buffer = xmalloc (OP_MIN_PARTIAL_CHUNK);\n\t      memcpy (a->buffer + a->buflen, buf, size);\n\t      a->buflen += size;\n\t    }\n\t  else\n\t    {\t\t\t/* okay, we can write out something */\n\t      /* do this in a loop to use the most efficient block lengths */\n\t      p = buf;\n\t      do\n\t\t{\n\t\t  /* find the best matching block length - this is limited\n\t\t   * by the size of the internal buffering */\n\t\t  for (blen = OP_MIN_PARTIAL_CHUNK * 2,\n\t\t       c = OP_MIN_PARTIAL_CHUNK_2POW + 1; blen <= nbytes;\n\t\t       blen *= 2, c++)\n\t\t    ;\n\t\t  blen /= 2;\n\t\t  c--;\n\t\t  /* write the partial length header */\n\t\t  assert (c <= 0x1f);\t/*;-) */\n\t\t  c |= 0xe0;\n\t\t  iobuf_put (chain, c);\n\t\t  if ((n = a->buflen))\n\t\t    {\t\t/* write stuff from the buffer */\n\t\t      assert (n == OP_MIN_PARTIAL_CHUNK);\n\t\t      if (iobuf_write (chain, a->buffer, n))\n\t\t\trc = gpg_error_from_syserror ();\n\t\t      a->buflen = 0;\n\t\t      nbytes -= n;\n\t\t    }\n\t\t  if ((n = nbytes) > blen)\n\t\t    n = blen;\n\t\t  if (n && iobuf_write (chain, p, n))\n\t\t    rc = gpg_error_from_syserror ();\n\t\t  p += n;\n\t\t  nbytes -= n;\n\t\t}\n\t      while (!rc && nbytes >= OP_MIN_PARTIAL_CHUNK);\n\t      /* store the rest in the buffer */\n\t      if (!rc && nbytes)\n\t\t{\n\t\t  assert (!a->buflen);\n\t\t  assert (nbytes < OP_MIN_PARTIAL_CHUNK);\n\t\t  if (!a->buffer)\n\t\t    a->buffer = xmalloc (OP_MIN_PARTIAL_CHUNK);\n\t\t  memcpy (a->buffer, p, nbytes);\n\t\t  a->buflen = nbytes;\n\t\t}\n\t    }\n\t}\n      else\n\tBUG ();\n    }\n  else if (control == IOBUFCTRL_INIT)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"init block_filter %p\\n\", a);\n      if (a->partial)\n\ta->count = 0;\n      else if (a->use == IOBUF_INPUT)\n\ta->count = a->size = 0;\n      else\n\ta->count = a->size;\t/* force first length bytes */\n      a->eof = 0;\n      a->buffer = NULL;\n      a->buflen = 0;\n    }\n  else if (control == IOBUFCTRL_DESC)\n    {\n      mem2str (buf, \"block_filter\", *ret_len);\n    }\n  else if (control == IOBUFCTRL_FREE)\n    {\n      if (a->use == IOBUF_OUTPUT)\n\t{\t\t\t/* write the end markers */\n\t  if (a->partial)\n\t    {\n\t      u32 len;\n\t      /* write out the remaining bytes without a partial header\n\t       * the length of this header may be 0 - but if it is\n\t       * the first block we are not allowed to use a partial header\n\t       * and frankly we can't do so, because this length must be\n\t       * a power of 2. This is _really_ complicated because we\n\t       * have to check the possible length of a packet prior\n\t       * to it's creation: a chain of filters becomes complicated\n\t       * and we need a lot of code to handle compressed packets etc.\n\t       *   :-(((((((\n\t       */\n\t      /* construct header */\n\t      len = a->buflen;\n\t      /*log_debug(\"partial: remaining length=%u\\n\", len ); */\n\t      if (len < 192)\n\t\trc = iobuf_put (chain, len);\n\t      else if (len < 8384)\n\t\t{\n\t\t  if (!(rc = iobuf_put (chain, ((len - 192) / 256) + 192)))\n\t\t    rc = iobuf_put (chain, ((len - 192) % 256));\n\t\t}\n\t      else\n\t\t{\t\t/* use a 4 byte header */\n\t\t  if (!(rc = iobuf_put (chain, 0xff)))\n\t\t    if (!(rc = iobuf_put (chain, (len >> 24) & 0xff)))\n\t\t      if (!(rc = iobuf_put (chain, (len >> 16) & 0xff)))\n\t\t\tif (!(rc = iobuf_put (chain, (len >> 8) & 0xff)))\n\t\t\t  rc = iobuf_put (chain, len & 0xff);\n\t\t}\n\t      if (!rc && len)\n\t\trc = iobuf_write (chain, a->buffer, len);\n\t      if (rc)\n\t\t{\n\t\t  log_error (\"block_filter: write error: %s\\n\",\n\t\t\t     strerror (errno));\n\t\t  rc = gpg_error_from_syserror ();\n\t\t}\n\t      xfree (a->buffer);\n\t      a->buffer = NULL;\n\t      a->buflen = 0;\n\t    }\n\t  else\n\t    BUG ();\n\t}\n      else if (a->size)\n\t{\n\t  log_error (\"block_filter: pending bytes!\\n\");\n\t}\n      if (DBG_IOBUF)\n\tlog_debug (\"free block_filter %p\\n\", a);\n      xfree (a);\t\t/* we can free our context now */\n    }\n\n  return rc;\n}\n\n#define MAX_IOBUF_DESC 32\n/*\n * Fill the buffer by the description of iobuf A.\n * The buffer size should be MAX_IOBUF_DESC (or larger).\n * Returns BUF as (const char *).\n */\nstatic const char *\niobuf_desc (iobuf_t a, byte *buf)\n{\n  size_t len = MAX_IOBUF_DESC;\n\n  if (! a || ! a->filter)\n    memcpy (buf, \"?\", 2);\n  else\n    a->filter (a->filter_ov, IOBUFCTRL_DESC, NULL, buf, &len);\n\n  return buf;\n}\n\nstatic void\nprint_chain (iobuf_t a)\n{\n  if (!DBG_IOBUF)\n    return;\n  for (; a; a = a->chain)\n    {\n      byte desc[MAX_IOBUF_DESC];\n\n      log_debug (\"iobuf chain: %d.%d '%s' filter_eof=%d start=%d len=%d\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc), a->filter_eof,\n\t\t (int) a->d.start, (int) a->d.len);\n    }\n}\n\nint\niobuf_print_chain (iobuf_t a)\n{\n  print_chain (a);\n  return 0;\n}\n\niobuf_t\niobuf_alloc (int use, size_t bufsize)\n{\n  iobuf_t a;\n  static int number = 0;\n\n  assert (use == IOBUF_INPUT || use == IOBUF_INPUT_TEMP\n\t  || use == IOBUF_OUTPUT || use == IOBUF_OUTPUT_TEMP);\n  if (bufsize == 0)\n    {\n      log_bug (\"iobuf_alloc() passed a bufsize of 0!\\n\");\n      bufsize = IOBUF_BUFFER_SIZE;\n    }\n\n  a = xcalloc (1, sizeof *a);\n  a->use = use;\n  a->d.buf = xmalloc (bufsize);\n  a->d.size = bufsize;\n  a->no = ++number;\n  a->subno = 0;\n  a->real_fname = NULL;\n  return a;\n}\n\nint\niobuf_close (iobuf_t a)\n{\n  iobuf_t a_chain;\n  size_t dummy_len = 0;\n  int rc = 0;\n\n  for (; a; a = a_chain)\n    {\n      byte desc[MAX_IOBUF_DESC];\n      int rc2 = 0;\n\n      a_chain = a->chain;\n\n      if (a->use == IOBUF_OUTPUT && (rc = filter_flush (a)))\n\tlog_error (\"filter_flush failed on close: %s\\n\", gpg_strerror (rc));\n\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: close '%s'\\n\",\n\t\t   a->no, a->subno, iobuf_desc (a, desc));\n\n      if (a->filter && (rc2 = a->filter (a->filter_ov, IOBUFCTRL_FREE,\n\t\t\t\t\t a->chain, NULL, &dummy_len)))\n\tlog_error (\"IOBUFCTRL_FREE failed on close: %s\\n\", gpg_strerror (rc));\n      if (! rc && rc2)\n\t/* Whoops!  An error occurred.  Save it in RC if we haven't\n\t   already recorded an error.  */\n\trc = rc2;\n\n      xfree (a->real_fname);\n      if (a->d.buf)\n\t{\n\t  memset (a->d.buf, 0, a->d.size);\t/* erase the buffer */\n\t  xfree (a->d.buf);\n\t}\n      xfree (a);\n    }\n  return rc;\n}\n\nint\niobuf_cancel (iobuf_t a)\n{\n  const char *s;\n  iobuf_t a2;\n  int rc;\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n  char *remove_name = NULL;\n#endif\n\n  if (a && a->use == IOBUF_OUTPUT)\n    {\n      s = iobuf_get_real_fname (a);\n      if (s && *s)\n\t{\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n\t  remove_name = xstrdup (s);\n#else\n\t  remove (s);\n#endif\n\t}\n    }\n\n  /* send a cancel message to all filters */\n  for (a2 = a; a2; a2 = a2->chain)\n    {\n      size_t dummy;\n      if (a2->filter)\n\ta2->filter (a2->filter_ov, IOBUFCTRL_CANCEL, a2->chain, NULL, &dummy);\n    }\n\n  rc = iobuf_close (a);\n#if defined(HAVE_W32_SYSTEM) || defined(__riscos__)\n  if (remove_name)\n    {\n      /* Argg, MSDOS does not allow removing open files.  So\n       * we have to do it here */\n#ifdef HAVE_W32CE_SYSTEM\n      wchar_t *wtmp = utf8_to_wchar (remove_name);\n      if (wtmp)\n        DeleteFile (wtmp);\n      xfree (wtmp);\n#else\n      remove (remove_name);\n#endif\n      xfree (remove_name);\n    }\n#endif\n  return rc;\n}\n\n\niobuf_t\niobuf_temp (void)\n{\n  return iobuf_alloc (IOBUF_OUTPUT_TEMP, IOBUF_BUFFER_SIZE);\n}\n\niobuf_t\niobuf_temp_with_content (const char *buffer, size_t length)\n{\n  iobuf_t a;\n  int i;\n\n  a = iobuf_alloc (IOBUF_INPUT_TEMP, length);\n  assert (length == a->d.size);\n  /* memcpy (a->d.buf, buffer, length); */\n  for (i=0; i < length; i++)\n    a->d.buf[i] = buffer[i];\n  a->d.len = length;\n\n  return a;\n}\n\n\nint\niobuf_is_pipe_filename (const char *fname)\n{\n  if (!fname || (*fname=='-' && !fname[1]) )\n    return 1;\n  return check_special_filename (fname, 0, 1) != -1;\n}\n\n\nstatic iobuf_t\ndo_open (const char *fname, int special_filenames,\n\t int use, const char *opentype, int mode700)\n{\n  iobuf_t a;\n  gnupg_fd_t fp;\n  file_filter_ctx_t *fcx;\n  size_t len = 0;\n  int print_only = 0;\n  int fd;\n  byte desc[MAX_IOBUF_DESC];\n\n  assert (use == IOBUF_INPUT || use == IOBUF_OUTPUT);\n\n  if (special_filenames\n      /* NULL or '-'.  */\n      && (!fname || (*fname == '-' && !fname[1])))\n    {\n      if (use == IOBUF_INPUT)\n\t{\n\t  fp = FD_FOR_STDIN;\n\t  fname = \"[stdin]\";\n\t}\n      else\n\t{\n\t  fp = FD_FOR_STDOUT;\n\t  fname = \"[stdout]\";\n\t}\n      print_only = 1;\n    }\n  else if (!fname)\n    return NULL;\n  else if (special_filenames\n           && (fd = check_special_filename (fname, 0, 1)) != -1)\n    return iobuf_fdopen (translate_file_handle (fd, use == IOBUF_INPUT ? 0 : 1),\n\t\t\t opentype);\n  else\n    {\n      if (use == IOBUF_INPUT)\n\tfp = fd_cache_open (fname, opentype);\n      else\n\tfp = direct_open (fname, opentype, mode700);\n      if (fp == GNUPG_INVALID_FD)\n\treturn NULL;\n    }\n\n  a = iobuf_alloc (use, IOBUF_BUFFER_SIZE);\n  fcx = xmalloc (sizeof *fcx + strlen (fname));\n  fcx->fp = fp;\n  fcx->print_only_name = print_only;\n  strcpy (fcx->fname, fname);\n  if (!print_only)\n    a->real_fname = xstrdup (fname);\n  a->filter = file_filter;\n  a->filter_ov = fcx;\n  file_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: open '%s' desc=%s fd=%d\\n\",\n\t       a->no, a->subno, fname, iobuf_desc (a, desc), FD2INT (fcx->fp));\n\n  return a;\n}\n\niobuf_t\niobuf_open (const char *fname)\n{\n  return do_open (fname, 1, IOBUF_INPUT, \"rb\", 0);\n}\n\niobuf_t\niobuf_create (const char *fname, int mode700)\n{\n  return do_open (fname, 1, IOBUF_OUTPUT, \"wb\", mode700);\n}\n\niobuf_t\niobuf_openrw (const char *fname)\n{\n  return do_open (fname, 0, IOBUF_OUTPUT, \"r+b\", 0);\n}\n\n\nstatic iobuf_t\ndo_iobuf_fdopen (int fd, const char *mode, int keep_open)\n{\n  iobuf_t a;\n  gnupg_fd_t fp;\n  file_filter_ctx_t *fcx;\n  size_t len;\n\n  fp = INT2FD (fd);\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  fcx = xmalloc (sizeof *fcx + 20);\n  fcx->fp = fp;\n  fcx->print_only_name = 1;\n  fcx->keep_open = keep_open;\n  sprintf (fcx->fname, \"[fd %d]\", fd);\n  a->filter = file_filter;\n  a->filter_ov = fcx;\n  file_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: fdopen%s '%s'\\n\",\n               a->no, a->subno, keep_open? \"_nc\":\"\", fcx->fname);\n  iobuf_ioctl (a, IOBUF_IOCTL_NO_CACHE, 1, NULL);\n  return a;\n}\n\n\niobuf_t\niobuf_fdopen (int fd, const char *mode)\n{\n  return do_iobuf_fdopen (fd, mode, 0);\n}\n\niobuf_t\niobuf_fdopen_nc (int fd, const char *mode)\n{\n  return do_iobuf_fdopen (fd, mode, 1);\n}\n\n\niobuf_t\niobuf_esopen (estream_t estream, const char *mode, int keep_open)\n{\n  iobuf_t a;\n  file_es_filter_ctx_t *fcx;\n  size_t len = 0;\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  fcx = xtrymalloc (sizeof *fcx + 30);\n  fcx->fp = estream;\n  fcx->print_only_name = 1;\n  fcx->keep_open = keep_open;\n  sprintf (fcx->fname, \"[fd %p]\", estream);\n  a->filter = file_es_filter;\n  a->filter_ov = fcx;\n  file_es_filter (fcx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: esopen%s '%s'\\n\",\n               a->no, a->subno, keep_open? \"_nc\":\"\", fcx->fname);\n  return a;\n}\n\n\niobuf_t\niobuf_sockopen (int fd, const char *mode)\n{\n  iobuf_t a;\n#ifdef HAVE_W32_SYSTEM\n  sock_filter_ctx_t *scx;\n  size_t len;\n\n  a = iobuf_alloc (strchr (mode, 'w') ? IOBUF_OUTPUT : IOBUF_INPUT,\n\t\t   IOBUF_BUFFER_SIZE);\n  scx = xmalloc (sizeof *scx + 25);\n  scx->sock = fd;\n  scx->print_only_name = 1;\n  sprintf (scx->fname, \"[sock %d]\", fd);\n  a->filter = sock_filter;\n  a->filter_ov = scx;\n  sock_filter (scx, IOBUFCTRL_INIT, NULL, NULL, &len);\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: sockopen '%s'\\n\", a->no, a->subno, scx->fname);\n  iobuf_ioctl (a, IOBUF_IOCTL_NO_CACHE, 1, NULL);\n#else\n  a = iobuf_fdopen (fd, mode);\n#endif\n  return a;\n}\n\nint\niobuf_ioctl (iobuf_t a, iobuf_ioctl_t cmd, int intval, void *ptrval)\n{\n  byte desc[MAX_IOBUF_DESC];\n\n  if (cmd == IOBUF_IOCTL_KEEP_OPEN)\n    {\n      /* Keep system filepointer/descriptor open.  This was used in\n         the past by http.c; this ioctl is not directly used\n         anymore.  */\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: ioctl '%s' keep_open=%d\\n\",\n\t\t   a ? a->no : -1, a ? a->subno : -1, iobuf_desc (a, desc),\n\t\t   intval);\n      for (; a; a = a->chain)\n\tif (!a->chain && a->filter == file_filter)\n\t  {\n\t    file_filter_ctx_t *b = a->filter_ov;\n\t    b->keep_open = intval;\n\t    return 0;\n\t  }\n#ifdef HAVE_W32_SYSTEM\n\telse if (!a->chain && a->filter == sock_filter)\n\t  {\n\t    sock_filter_ctx_t *b = a->filter_ov;\n\t    b->keep_open = intval;\n\t    return 0;\n\t  }\n#endif\n    }\n  else if (cmd == IOBUF_IOCTL_INVALIDATE_CACHE)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-*.*: ioctl '%s' invalidate\\n\",\n\t\t   ptrval ? (char *) ptrval : \"?\");\n      if (!a && !intval && ptrval)\n\t{\n\t  if (fd_cache_invalidate (ptrval))\n            return -1;\n\t  return 0;\n\t}\n    }\n  else if (cmd == IOBUF_IOCTL_NO_CACHE)\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: ioctl '%s' no_cache=%d\\n\",\n\t\t   a ? a->no : -1, a ? a->subno : -1, iobuf_desc (a, desc),\n\t\t   intval);\n      for (; a; a = a->chain)\n\tif (!a->chain && a->filter == file_filter)\n\t  {\n\t    file_filter_ctx_t *b = a->filter_ov;\n\t    b->no_cache = intval;\n\t    return 0;\n\t  }\n#ifdef HAVE_W32_SYSTEM\n\telse if (!a->chain && a->filter == sock_filter)\n\t  {\n\t    sock_filter_ctx_t *b = a->filter_ov;\n\t    b->no_cache = intval;\n\t    return 0;\n\t  }\n#endif\n    }\n  else if (cmd == IOBUF_IOCTL_FSYNC)\n    {\n      /* Do a fsync on the open fd and return any errors to the caller\n         of iobuf_ioctl.  Note that we work on a file name here. */\n      if (DBG_IOBUF)\n        log_debug (\"iobuf-*.*: ioctl '%s' fsync\\n\",\n                   ptrval? (const char*)ptrval:\"<null>\");\n\n      if (!a && !intval && ptrval)\n        {\n          return fd_cache_synchronize (ptrval);\n        }\n    }\n\n\n  return -1;\n}\n\n\n/****************\n * Register an i/o filter.\n */\nint\niobuf_push_filter (iobuf_t a,\n\t\t   int (*f) (void *opaque, int control,\n\t\t\t     iobuf_t chain, byte * buf, size_t * len),\n                   void *ov)\n{\n  return iobuf_push_filter2 (a, f, ov, 0);\n}\n\nint\niobuf_push_filter2 (iobuf_t a,\n\t\t    int (*f) (void *opaque, int control,\n\t\t\t      iobuf_t chain, byte * buf, size_t * len),\n\t\t    void *ov, int rel_ov)\n{\n  iobuf_t b;\n  size_t dummy_len = 0;\n  int rc = 0;\n\n  if (a->use == IOBUF_OUTPUT && (rc = filter_flush (a)))\n    return rc;\n\n  if (a->subno >= MAX_NESTING_FILTER)\n    {\n      log_error (\"i/o filter too deeply nested - corrupted data?\\n\");\n      return GPG_ERR_BAD_DATA;\n    }\n\n  /* We want to create a new filter and put it in front of A.  A\n     simple implementation would do:\n\n       b = iobuf_alloc (...);\n       b->chain = a;\n       return a;\n\n     This is a bit problematic: A is the head of the pipeline and\n     there are potentially many pointers to it.  Requiring the caller\n     to update all of these pointers is a burden.\n\n     An alternative implementation would add a level of indirection.\n     For instance, we could use a pipeline object, which contains a\n     pointer to the first filter in the pipeline.  This is not what we\n     do either.\n\n     Instead, we allocate a new buffer (B) and copy the first filter's\n     state into that and use the initial buffer (A) for the new\n     filter.  One limitation of this approach is that it is not\n     practical to maintain a pointer to a specific filter's state.\n\n     Before:\n\n           A\n           |\n           v 0x100               0x200\n           +----------+          +----------+\n           | filter x |--------->| filter y |---->....\n           +----------+          +----------+\n\n     After:           B\n                      |\n                      v 0x300\n                      +----------+\n           A          | filter x |\n           |          +----------+\n           v 0x100    ^          v 0x200\n           +----------+          +----------+\n           | filter w |          | filter y |---->....\n           +----------+          +----------+\n\n     Note: filter x's address changed from 0x100 to 0x300, but A still\n     points to the head of the pipeline.\n  */\n\n  b = xmalloc (sizeof *b);\n  memcpy (b, a, sizeof *b);\n  /* fixme: it is stupid to keep a copy of the name at every level\n   * but we need the name somewhere because the name known by file_filter\n   * may have been released when we need the name of the file */\n  b->real_fname = a->real_fname ? xstrdup (a->real_fname) : NULL;\n  /* remove the filter stuff from the new stream */\n  a->filter = NULL;\n  a->filter_ov = NULL;\n  a->filter_ov_owner = 0;\n  a->filter_eof = 0;\n  if (a->use == IOBUF_OUTPUT_TEMP)\n    /* A TEMP filter buffers any data sent to it; it does not forward\n       any data down the pipeline.  If we add a new filter to the\n       pipeline, it shouldn't also buffer data.  It should send it\n       downstream to be buffered.  Thus, the correct type for a filter\n       added in front of an IOBUF_OUTPUT_TEMP filter is IOBUF_OUPUT, not\n       IOBUF_OUTPUT_TEMP.  */\n    {\n      a->use = IOBUF_OUTPUT;\n\n      /* When pipeline is written to, the temp buffer's size is\n\t increased accordingly.  We don't need to allocate a 10 MB\n\t buffer for a non-terminal filter.  Just use the default\n\t size.  */\n      a->d.size = IOBUF_BUFFER_SIZE;\n    }\n  else if (a->use == IOBUF_INPUT_TEMP)\n    /* Same idea as above.  */\n    {\n      a->use = IOBUF_INPUT;\n      a->d.size = IOBUF_BUFFER_SIZE;\n    }\n\n  /* The new filter (A) gets a new buffer.\n\n     If the pipeline is an output or temp pipeline, then giving the\n     buffer to the new filter means that data that was written before\n     the filter was pushed gets sent to the filter.  That's clearly\n     wrong.\n\n     If the pipeline is an input pipeline, then giving the buffer to\n     the new filter (A) means that data that has read from (B), but\n     not yet read from the pipeline won't be processed by the new\n     filter (A)!  That's certainly not what we want.  */\n  a->d.buf = xmalloc (a->d.size);\n  a->d.len = 0;\n  a->d.start = 0;\n\n  /* disable nlimit for the new stream */\n  a->ntotal = b->ntotal + b->nbytes;\n  a->nlimit = a->nbytes = 0;\n  a->nofast = 0;\n  /* make a link from the new stream to the original stream */\n  a->chain = b;\n\n  /* setup the function on the new stream */\n  a->filter = f;\n  a->filter_ov = ov;\n  a->filter_ov_owner = rel_ov;\n\n  a->subno = b->subno + 1;\n\n  if (DBG_IOBUF)\n    {\n      byte desc[MAX_IOBUF_DESC];\n      log_debug (\"iobuf-%d.%d: push '%s'\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc));\n      print_chain (a);\n    }\n\n  /* now we can initialize the new function if we have one */\n  if (a->filter && (rc = a->filter (a->filter_ov, IOBUFCTRL_INIT, a->chain,\n\t\t\t\t    NULL, &dummy_len)))\n    log_error (\"IOBUFCTRL_INIT failed: %s\\n\", gpg_strerror (rc));\n  return rc;\n}\n\n/****************\n * Remove an i/o filter.\n */\nint\niobuf_pop_filter (iobuf_t a, int (*f) (void *opaque, int control,\n                                       iobuf_t chain, byte * buf, size_t * len),\n                  void *ov)\n{\n  iobuf_t b;\n  size_t dummy_len = 0;\n  int rc = 0;\n  byte desc[MAX_IOBUF_DESC];\n\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: pop '%s'\\n\",\n\t       a->no, a->subno, iobuf_desc (a, desc));\n  if (a->use == IOBUF_INPUT_TEMP || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      /* This should be the last filter in the pipeline.  */\n      assert (! a->chain);\n      return 0;\n    }\n  if (!a->filter)\n    {\t\t\t\t/* this is simple */\n      b = a->chain;\n      assert (b);\n      xfree (a->d.buf);\n      xfree (a->real_fname);\n      memcpy (a, b, sizeof *a);\n      xfree (b);\n      return 0;\n    }\n  for (b = a; b; b = b->chain)\n    if (b->filter == f && (!ov || b->filter_ov == ov))\n      break;\n  if (!b)\n    log_bug (\"iobuf_pop_filter(): filter function not found\\n\");\n\n  /* flush this stream if it is an output stream */\n  if (a->use == IOBUF_OUTPUT && (rc = filter_flush (b)))\n    {\n      log_error (\"filter_flush failed in iobuf_pop_filter: %s\\n\",\n                 gpg_strerror (rc));\n      return rc;\n    }\n  /* and tell the filter to free it self */\n  if (b->filter && (rc = b->filter (b->filter_ov, IOBUFCTRL_FREE, b->chain,\n\t\t\t\t    NULL, &dummy_len)))\n    {\n      log_error (\"IOBUFCTRL_FREE failed: %s\\n\", gpg_strerror (rc));\n      return rc;\n    }\n  if (b->filter_ov && b->filter_ov_owner)\n    {\n      xfree (b->filter_ov);\n      b->filter_ov = NULL;\n    }\n\n\n  /* and see how to remove it */\n  if (a == b && !b->chain)\n    log_bug (\"can't remove the last filter from the chain\\n\");\n  else if (a == b)\n    {\t\t\t\t/* remove the first iobuf from the chain */\n      /* everything from b is copied to a. This is save because\n       * a flush has been done on the to be removed entry\n       */\n      b = a->chain;\n      xfree (a->d.buf);\n      xfree (a->real_fname);\n      memcpy (a, b, sizeof *a);\n      xfree (b);\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: popped filter\\n\", a->no, a->subno);\n    }\n  else if (!b->chain)\n    {\t\t\t\t/* remove the last iobuf from the chain */\n      log_bug (\"Ohh jeee, trying to remove a head filter\\n\");\n    }\n  else\n    {\t\t\t\t/* remove an intermediate iobuf from the chain */\n      log_bug (\"Ohh jeee, trying to remove an intermediate filter\\n\");\n    }\n\n  return rc;\n}\n\n\n/****************\n * read underflow: read at least one byte into the buffer and return\n * the first byte or -1 on EOF.\n */\nstatic int\nunderflow (iobuf_t a, int clear_pending_eof)\n{\n  return underflow_target (a, clear_pending_eof, 1);\n}\n\n\n/****************\n * read underflow: read TARGET bytes into the buffer and return\n * the first byte or -1 on EOF.\n */\nstatic int\nunderflow_target (iobuf_t a, int clear_pending_eof, size_t target)\n{\n  size_t len;\n  int rc;\n\n  if (DBG_IOBUF)\n    log_debug (\"iobuf-%d.%d: underflow: buffer size: %d; still buffered: %d => space for %d bytes\\n\",\n\t       a->no, a->subno,\n\t       (int) a->d.size, (int) (a->d.len - a->d.start),\n\t       (int) (a->d.size - (a->d.len - a->d.start)));\n\n  if (a->use == IOBUF_INPUT_TEMP)\n    /* By definition, there isn't more data to read into the\n       buffer.  */\n    return -1;\n\n  assert (a->use == IOBUF_INPUT);\n\n  /* If there is still some buffered data, then move it to the start\n     of the buffer and try to fill the end of the buffer.  (This is\n     useful if we are called from iobuf_peek().)  */\n  assert (a->d.start <= a->d.len);\n  a->d.len -= a->d.start;\n  memmove (a->d.buf, &a->d.buf[a->d.start], a->d.len);\n  a->d.start = 0;\n\n  if (a->d.len < target && a->filter_eof)\n    /* The last time we tried to read from this filter, we got an EOF.\n       We couldn't return the EOF, because there was buffered data.\n       Since there is no longer any buffered data, return the\n       error.  */\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: underflow: eof (pending eof)\\n\",\n\t\t   a->no, a->subno);\n      if (! clear_pending_eof)\n\treturn -1;\n\n      if (a->chain)\n\t/* A filter follows this one.  Free this filter.  */\n\t{\n\t  iobuf_t b = a->chain;\n\t  if (DBG_IOBUF)\n\t    log_debug (\"iobuf-%d.%d: filter popped (pending EOF returned)\\n\",\n\t\t       a->no, a->subno);\n\t  xfree (a->d.buf);\n\t  xfree (a->real_fname);\n\t  memcpy (a, b, sizeof *a);\n\t  xfree (b);\n\t  print_chain (a);\n\t}\n      else\n\ta->filter_eof = 0;\t/* for the top level filter */\n      return -1;\t\t/* return one(!) EOF */\n    }\n\n  if (a->d.len == 0 && a->error)\n    /* The last time we tried to read from this filter, we got an\n       error.  We couldn't return the error, because there was\n       buffered data.  Since there is no longer any buffered data,\n       return the error.  */\n    {\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: pending error (%s) returned\\n\",\n\t\t   a->no, a->subno, gpg_strerror (a->error));\n      return -1;\n    }\n\n  if (a->filter && ! a->filter_eof && ! a->error)\n    /* We have a filter function and the last time we tried to read we\n       didn't get an EOF or an error.  Try to fill the buffer.  */\n    {\n      /* Be careful to account for any buffered data.  */\n      len = a->d.size - a->d.len;\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: underflow: A->FILTER (%lu bytes)\\n\",\n\t\t   a->no, a->subno, (ulong) len);\n      if (len == 0)\n\t/* There is no space for more data.  Don't bother calling\n\t   A->FILTER.  */\n\trc = 0;\n      else\n\trc = a->filter (a->filter_ov, IOBUFCTRL_UNDERFLOW, a->chain,\n\t\t\t&a->d.buf[a->d.len], &len);\n      a->d.len += len;\n\n      if (DBG_IOBUF)\n\tlog_debug (\"iobuf-%d.%d: A->FILTER() returned rc=%d (%s), read %lu bytes\\n\",\n\t\t   a->no, a->subno,\n\t\t   rc, rc == 0 ? \"ok\" : rc == -1 ? \"EOF\" : gpg_strerror (rc),\n\t\t   (ulong) len);\n/*  \t    if( a->no == 1 ) */\n/*                   log_hexdump (\"     data:\", a->d.buf, len); */\n\n      if (rc == -1)\n\t/* EOF.  */\n\t{\n\t  size_t dummy_len = 0;\n\n\t  /* Tell the filter to free itself */\n\t  if ((rc = a->filter (a->filter_ov, IOBUFCTRL_FREE, a->chain,\n\t\t\t       NULL, &dummy_len)))\n\t    log_error (\"IOBUFCTRL_FREE failed: %s\\n\", gpg_strerror (rc));\n\n\t  /* Free everything except for the internal buffer.  */\n\t  if (a->filter_ov && a->filter_ov_owner)\n\t    xfree (a->filter_ov);\n\t  a->filter_ov = NULL;\n\t  a->filter = NULL;\n\t  a->filter_eof = 1;\n\n\t  if (clear_pending_eof && a->d.len == 0 && a->chain)\n\t    /* We don't need to keep this filter around at all:\n\n\t         - we got an EOF\n\t\t - we have no buffered data\n\t\t - a filter follows this one.\n\n\t      Unlink this filter.  */\n\t    {\n\t      iobuf_t b = a->chain;\n\t      if (DBG_IOBUF)\n\t\tlog_debug (\"iobuf-%d.%d: pop in underflow (nothing buffered, got EOF)\\n\",\n\t\t\t   a->no, a->subno);\n\t      xfree (a->d.buf);\n\t      xfree (a->real_fname);\n\t      memcpy (a, b, sizeof *a);\n\t      xfree (b);\n\n\t      print_chain (a);\n\n\t      return -1;\n\t    }\n\t  else if (a->d.len == 0)\n\t    /* We can't unlink this filter (it is the only one in the\n\t       pipeline), but we can immediately return EOF.  */\n\t    return -1;\n\t}\n      else if (rc)\n\t/* Record the error.  */\n\t{\n\t  a->error = rc;\n\n\t  if (a->d.len == 0)\n\t    /* There is no buffered data.  Immediately return EOF.  */\n\t    return -1;\n\t}\n    }\n\n  assert (a->d.start <= a->d.len);\n  if (a->d.start < a->d.len)\n    return a->d.buf[a->d.start++];\n\n  /* EOF.  */\n  return -1;\n}\n\n\nstatic int\nfilter_flush (iobuf_t a)\n{\n  size_t len;\n  int rc;\n\n  if (a->use == IOBUF_OUTPUT_TEMP)\n    {\t\t\t\t/* increase the temp buffer */\n      size_t newsize = a->d.size + IOBUF_BUFFER_SIZE;\n\n      if (DBG_IOBUF)\n\tlog_debug (\"increasing temp iobuf from %lu to %lu\\n\",\n\t\t   (ulong) a->d.size, (ulong) newsize);\n\n      a->d.buf = xrealloc (a->d.buf, newsize);\n      a->d.size = newsize;\n      return 0;\n    }\n  else if (a->use != IOBUF_OUTPUT)\n    log_bug (\"flush on non-output iobuf\\n\");\n  else if (!a->filter)\n    log_bug (\"filter_flush: no filter\\n\");\n  len = a->d.len;\n  rc = a->filter (a->filter_ov, IOBUFCTRL_FLUSH, a->chain, a->d.buf, &len);\n  if (!rc && len != a->d.len)\n    {\n      log_info (\"filter_flush did not write all!\\n\");\n      rc = GPG_ERR_INTERNAL;\n    }\n  else if (rc)\n    a->error = rc;\n  a->d.len = 0;\n\n  return rc;\n}\n\n\nint\niobuf_readbyte (iobuf_t a)\n{\n  int c;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      log_bug (\"iobuf_readbyte called on a non-INPUT pipeline!\\n\");\n      return -1;\n    }\n\n  assert (a->d.start <= a->d.len);\n\n  if (a->nlimit && a->nbytes >= a->nlimit)\n    return -1;\t\t\t/* forced EOF */\n\n  if (a->d.start < a->d.len)\n    {\n      c = a->d.buf[a->d.start++];\n    }\n  else if ((c = underflow (a, 1)) == -1)\n    return -1;\t\t\t/* EOF */\n\n  assert (a->d.start <= a->d.len);\n\n  /* Note: if underflow doesn't return EOF, then it returns the first\n     byte that was read and advances a->d.start appropriately.  */\n\n  a->nbytes++;\n  return c;\n}\n\n\nint\niobuf_read (iobuf_t a, void *buffer, unsigned int buflen)\n{\n  unsigned char *buf = (unsigned char *)buffer;\n  int c, n;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_OUTPUT_TEMP)\n    {\n      log_bug (\"iobuf_read called on a non-INPUT pipeline!\\n\");\n      return -1;\n    }\n\n  if (a->nlimit)\n    {\n      /* Handle special cases. */\n      for (n = 0; n < buflen; n++)\n\t{\n\t  if ((c = iobuf_readbyte (a)) == -1)\n\t    {\n\t      if (!n)\n\t\treturn -1;\t/* eof */\n\t      break;\n\t    }\n\n\t  if (buf)\n\t    {\n\t      *buf = c;\n\t      buf++;\n\t    }\n\t}\n      return n;\n    }\n\n  n = 0;\n  do\n    {\n      if (n < buflen && a->d.start < a->d.len)\n\t/* Drain the buffer.  */\n\t{\n\t  unsigned size = a->d.len - a->d.start;\n\t  if (size > buflen - n)\n\t    size = buflen - n;\n\t  if (buf)\n\t    memcpy (buf, a->d.buf + a->d.start, size);\n\t  n += size;\n\t  a->d.start += size;\n\t  if (buf)\n\t    buf += size;\n\t}\n      if (n < buflen)\n\t/* Draining the internal buffer didn't fill BUFFER.  Call\n\t   underflow to read more data into the filter's internal\n\t   buffer.  */\n\t{\n\t  if ((c = underflow (a, 1)) == -1)\n\t    /* EOF.  If we managed to read something, don't return EOF\n\t       now.  */\n\t    {\n\t      a->nbytes += n;\n\t      return n ? n : -1 /*EOF*/;\n\t    }\n\t  if (buf)\n\t    *buf++ = c;\n\t  n++;\n\t}\n    }\n  while (n < buflen);\n  a->nbytes += n;\n  return n;\n}\n\n\n\nint\niobuf_peek (iobuf_t a, byte * buf, unsigned buflen)\n{\n  int n = 0;\n\n  assert (buflen > 0);\n  assert (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP);\n\n  if (buflen > a->d.size)\n    /* We can't peek more than we can buffer.  */\n    buflen = a->d.size;\n\n  /* Try to fill the internal buffer with enough data to satisfy the\n     request.  */\n  while (buflen > a->d.len - a->d.start)\n    {\n      if (underflow_target (a, 0, buflen) == -1)\n\t/* EOF.  We can't read any more.  */\n\tbreak;\n\n      /* Underflow consumes the first character (it's the return\n\t value).  unget() it by resetting the \"file position\".  */\n      assert (a->d.start == 1);\n      a->d.start = 0;\n    }\n\n  n = a->d.len - a->d.start;\n  if (n > buflen)\n    n = buflen;\n\n  if (n == 0)\n    /* EOF.  */\n    return -1;\n\n  memcpy (buf, &a->d.buf[a->d.start], n);\n\n  return n;\n}\n\n\n\n\nint\niobuf_writebyte (iobuf_t a, unsigned int c)\n{\n  int rc;\n\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_writebyte called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  if (a->d.len == a->d.size)\n    if ((rc=filter_flush (a)))\n      return rc;\n\n  assert (a->d.len < a->d.size);\n  a->d.buf[a->d.len++] = c;\n  return 0;\n}\n\n\nint\niobuf_write (iobuf_t a, const void *buffer, unsigned int buflen)\n{\n  const unsigned char *buf = (const unsigned char *)buffer;\n  int rc;\n\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_write called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  do\n    {\n      if (buflen && a->d.len < a->d.size)\n\t{\n\t  unsigned size = a->d.size - a->d.len;\n\t  if (size > buflen)\n\t    size = buflen;\n\t  memcpy (a->d.buf + a->d.len, buf, size);\n\t  buflen -= size;\n\t  buf += size;\n\t  a->d.len += size;\n\t}\n      if (buflen)\n\t{\n\t  rc = filter_flush (a);\n          if (rc)\n\t    return rc;\n\t}\n    }\n  while (buflen);\n  return 0;\n}\n\n\nint\niobuf_writestr (iobuf_t a, const char *buf)\n{\n  if (a->use == IOBUF_INPUT || a->use == IOBUF_INPUT_TEMP)\n    {\n      log_bug (\"iobuf_writestr called on an input pipeline!\\n\");\n      return -1;\n    }\n\n  return iobuf_write (a, buf, strlen (buf));\n}\n\n\n\nint\niobuf_write_temp (iobuf_t dest, iobuf_t source)\n{\n  assert (source->use == IOBUF_OUTPUT || source->use == IOBUF_OUTPUT_TEMP);\n  assert (dest->use == IOBUF_OUTPUT || dest->use == IOBUF_OUTPUT_TEMP);\n\n  iobuf_flush_temp (source);\n  return iobuf_write (dest, source->d.buf, source->d.len);\n}\n\nsize_t\niobuf_temp_to_buffer (iobuf_t a, byte * buffer, size_t buflen)\n{\n  byte desc[MAX_IOBUF_DESC];\n  size_t n;\n\n  while (1)\n    {\n      int rc = filter_flush (a);\n      if (rc)\n\tlog_bug (\"Flushing iobuf %d.%d (%s) from iobuf_temp_to_buffer failed.  Ignoring.\\n\",\n\t\t a->no, a->subno, iobuf_desc (a, desc));\n      if (! a->chain)\n\tbreak;\n      a = a->chain;\n    }\n\n  n = a->d.len;\n  if (n > buflen)\n    n = buflen;\n  memcpy (buffer, a->d.buf, n);\n  return n;\n}\n\n/* Copies the data from the input iobuf SOURCE to the output iobuf\n   DEST until either an error is encountered or EOF is reached.\n   Returns the number of bytes copies.  */\nsize_t\niobuf_copy (iobuf_t dest, iobuf_t source)\n{\n  char *temp;\n  /* Use a 32 KB buffer.  */\n  const size_t temp_size = 32 * 1024;\n\n  size_t nread;\n  size_t nwrote = 0;\n  size_t max_read = 0;\n  int err;\n\n  assert (source->use == IOBUF_INPUT || source->use == IOBUF_INPUT_TEMP);\n  assert (dest->use == IOBUF_OUTPUT || source->use == IOBUF_OUTPUT_TEMP);\n\n  if (iobuf_error (dest))\n    return -1;\n\n  temp = xmalloc (temp_size);\n  while (1)\n    {\n      nread = iobuf_read (source, temp, temp_size);\n      if (nread == -1)\n        /* EOF.  */\n        break;\n\n      if (nread > max_read)\n        max_read = nread;\n\n      err = iobuf_write (dest, temp, nread);\n      if (err)\n        break;\n      nwrote += nread;\n    }\n\n  /* Burn the buffer.  */\n  if (max_read)\n    wipememory (temp, max_read);\n  xfree (temp);\n\n  return nwrote;\n}\n\n\nvoid\niobuf_flush_temp (iobuf_t temp)\n{\n  if (temp->use == IOBUF_INPUT || temp->use == IOBUF_INPUT_TEMP)\n    log_bug (\"iobuf_flush_temp called on an input pipeline!\\n\");\n  while (temp->chain)\n    iobuf_pop_filter (temp, temp->filter, NULL);\n}\n\n\nvoid\niobuf_set_limit (iobuf_t a, off_t nlimit)\n{\n  if (nlimit)\n    a->nofast = 1;\n  else\n    a->nofast = 0;\n  a->nlimit = nlimit;\n  a->ntotal += a->nbytes;\n  a->nbytes = 0;\n}\n\n\n\noff_t\niobuf_get_filelength (iobuf_t a, int *overflow)\n{\n  if (overflow)\n    *overflow = 0;\n\n  /* Hmmm: file_filter may have already been removed */\n  for ( ; a->chain; a = a->chain )\n    ;\n\n  if (a->filter != file_filter)\n    return 0;\n\n  {\n    file_filter_ctx_t *b = a->filter_ov;\n    gnupg_fd_t fp = b->fp;\n\n#if defined(HAVE_W32_SYSTEM)\n    ulong size;\n    static int (* __stdcall get_file_size_ex) (void *handle,\n\t\t\t\t\t       LARGE_INTEGER *r_size);\n    static int get_file_size_ex_initialized;\n\n    if (!get_file_size_ex_initialized)\n      {\n\tvoid *handle;\n\n\thandle = dlopen (\"kernel32.dll\", RTLD_LAZY);\n\tif (handle)\n\t  {\n\t    get_file_size_ex = dlsym (handle, \"GetFileSizeEx\");\n\t    if (!get_file_size_ex)\n\t      dlclose (handle);\n\t  }\n\tget_file_size_ex_initialized = 1;\n      }\n\n    if (get_file_size_ex)\n      {\n\t/* This is a newer system with GetFileSizeEx; we use this\n\t   then because it seem that GetFileSize won't return a\n\t   proper error in case a file is larger than 4GB. */\n\tLARGE_INTEGER exsize;\n\n\tif (get_file_size_ex (fp, &exsize))\n\t  {\n\t    if (!exsize.u.HighPart)\n\t      return exsize.u.LowPart;\n\t    if (overflow)\n\t      *overflow = 1;\n\t    return 0;\n\t  }\n      }\n    else\n      {\n\tif ((size=GetFileSize (fp, NULL)) != 0xffffffff)\n\t  return size;\n      }\n    log_error (\"GetFileSize for handle %p failed: %s\\n\",\n\t       fp, w32_strerror (-1));\n#else /*!HAVE_W32_SYSTEM*/\n    {\n      struct stat st;\n\n      if ( !fstat (FD2INT (fp), &st) )\n        return st.st_size;\n      log_error(\"fstat() failed: %s\\n\", strerror(errno) );\n    }\n#endif /*!HAVE_W32_SYSTEM*/\n  }\n\n  return 0;\n}\n\n\nint\niobuf_get_fd (iobuf_t a)\n{\n  for (; a->chain; a = a->chain)\n    ;\n\n  if (a->filter != file_filter)\n    return -1;\n\n  {\n    file_filter_ctx_t *b = a->filter_ov;\n    gnupg_fd_t fp = b->fp;\n\n    return FD2INT (fp);\n  }\n}\n\n\noff_t\niobuf_tell (iobuf_t a)\n{\n  return a->ntotal + a->nbytes;\n}\n\n\n#if !defined(HAVE_FSEEKO) && !defined(fseeko)\n\n#ifdef HAVE_LIMITS_H\n# include <limits.h>\n#endif\n#ifndef LONG_MAX\n# define LONG_MAX ((long) ((unsigned long) -1 >> 1))\n#endif\n#ifndef LONG_MIN\n# define LONG_MIN (-1 - LONG_MAX)\n#endif\n\n/****************\n * A substitute for fseeko, for hosts that don't have it.\n */\nstatic int\nfseeko (FILE * stream, off_t newpos, int whence)\n{\n  while (newpos != (long) newpos)\n    {\n      long pos = newpos < 0 ? LONG_MIN : LONG_MAX;\n      if (fseek (stream, pos, whence) != 0)\n\treturn -1;\n      newpos -= pos;\n      whence = SEEK_CUR;\n    }\n  return fseek (stream, (long) newpos, whence);\n}\n#endif\n\nint\niobuf_seek (iobuf_t a, off_t newpos)\n{\n  file_filter_ctx_t *b = NULL;\n\n  if (a->use == IOBUF_OUTPUT || a->use == IOBUF_INPUT)\n    {\n      /* Find the last filter in the pipeline.  */\n      for (; a->chain; a = a->chain)\n\t;\n\n      if (a->filter != file_filter)\n\treturn -1;\n\n      b = a->filter_ov;\n\n#ifdef HAVE_W32_SYSTEM\n      if (SetFilePointer (b->fp, newpos, NULL, FILE_BEGIN) == 0xffffffff)\n\t{\n\t  log_error (\"SetFilePointer failed on handle %p: ec=%d\\n\",\n\t\t     b->fp, (int) GetLastError ());\n\t  return -1;\n\t}\n#else\n      if (lseek (b->fp, newpos, SEEK_SET) == (off_t) - 1)\n\t{\n\t  log_error (\"can't lseek: %s\\n\", strerror (errno));\n\t  return -1;\n\t}\n#endif\n      /* Discard the buffer it is not a temp stream.  */\n      a->d.len = 0;\n    }\n  a->d.start = 0;\n  a->nbytes = 0;\n  a->nlimit = 0;\n  a->nofast = 0;\n  a->ntotal = newpos;\n  a->error = 0;\n\n  /* It is impossible for A->CHAIN to be non-NULL.  If A is an INPUT\n     or OUTPUT buffer, then we find the last filter, which is defined\n     as A->CHAIN being NULL.  If A is a TEMP filter, then A must be\n     the only filter in the pipe: when iobuf_push_filter adds a filter\n     to the front of a pipeline, it sets the new filter to be an\n     OUTPUT filter if the pipeline is an OUTPUT or TEMP pipeline and\n     to be an INPUT filter if the pipeline is an INPUT pipeline.\n     Thus, only the last filter in a TEMP pipeline can be a */\n\n  /* remove filters, but the last */\n  if (a->chain)\n    log_debug (\"iobuf_pop_filter called in iobuf_seek - please report\\n\");\n  while (a->chain)\n    iobuf_pop_filter (a, a->filter, NULL);\n\n  return 0;\n}\n\n\nconst char *\niobuf_get_real_fname (iobuf_t a)\n{\n  if (a->real_fname)\n    return a->real_fname;\n\n  /* the old solution */\n  for (; a; a = a->chain)\n    if (!a->chain && a->filter == file_filter)\n      {\n\tfile_filter_ctx_t *b = a->filter_ov;\n\treturn b->print_only_name ? NULL : b->fname;\n      }\n\n  return NULL;\n}\n\nconst char *\niobuf_get_fname (iobuf_t a)\n{\n  for (; a; a = a->chain)\n    if (!a->chain && a->filter == file_filter)\n      {\n\tfile_filter_ctx_t *b = a->filter_ov;\n\treturn b->fname;\n      }\n  return NULL;\n}\n\nconst char *\niobuf_get_fname_nonnull (iobuf_t a)\n{\n  const char *fname;\n\n  fname = iobuf_get_fname (a);\n  return fname? fname : \"[?]\";\n}\n\n\n/****************\n * Enable or disable partial body length mode (RFC 4880 4.2.2.4).\n *\n * If LEN is 0, this disables partial block mode by popping the\n * partial body length filter, which must be the most recently\n * added filter.\n *\n * If LEN is non-zero, it pushes a partial body length filter.  If\n * this is a read filter, LEN must be the length byte from the first\n * chunk and A should be position just after this first partial body\n * length header.\n */\nvoid\niobuf_set_partial_body_length_mode (iobuf_t a, size_t len)\n{\n  if (!len)\n    /* Disable partial body length mode.  */\n    {\n      if (a->use == IOBUF_INPUT)\n\tlog_debug (\"iobuf_pop_filter called in set_partial_block_mode\"\n\t\t   \" - please report\\n\");\n\n      log_assert (a->filter == block_filter);\n      iobuf_pop_filter (a, block_filter, NULL);\n    }\n  else\n    /* Enabled partial body length mode.  */\n    {\n      block_filter_ctx_t *ctx = xcalloc (1, sizeof *ctx);\n      ctx->use = a->use;\n      ctx->partial = 1;\n      ctx->size = 0;\n      ctx->first_c = len;\n      iobuf_push_filter (a, block_filter, ctx);\n    }\n}\n\n\n\nunsigned int\niobuf_read_line (iobuf_t a, byte ** addr_of_buffer,\n\t\t unsigned *length_of_buffer, unsigned *max_length)\n{\n  int c;\n  char *buffer = (char *)*addr_of_buffer;\n  unsigned length = *length_of_buffer;\n  unsigned nbytes = 0;\n  unsigned maxlen = *max_length;\n  char *p;\n\n  /* The code assumes that we have space for at least a newline and a\n     NUL character in the buffer.  This requires at least 2 bytes.  We\n     don't complicate the code by handling the stupid corner case, but\n     simply assert that it can't happen.  */\n  assert (!buffer || length >= 2 || maxlen >= 2);\n\n  if (!buffer || length <= 1)\n    /* must allocate a new buffer */\n    {\n      length = 256 <= maxlen ? 256 : maxlen;\n      buffer = xrealloc (buffer, length);\n      *addr_of_buffer = (unsigned char *)buffer;\n      *length_of_buffer = length;\n    }\n\n  p = buffer;\n  while ((c = iobuf_get (a)) != -1)\n    {\n      *p++ = c;\n      nbytes++;\n      if (c == '\\n')\n\tbreak;\n\n      if (nbytes == length - 1)\n\t/* We don't have enough space to add a \\n and a \\0.  Increase\n\t   the buffer size.  */\n\t{\n\t  if (length == maxlen)\n\t    /* We reached the buffer's size limit!  */\n\t    {\n\t      /* Skip the rest of the line.  */\n\t      while (c != '\\n' && (c = iobuf_get (a)) != -1)\n\t\t;\n\n\t      /* p is pointing at the last byte in the buffer.  We\n\t\t always terminate the line with \"\\n\\0\" so overwrite\n\t\t the previous byte with a \\n.  */\n\t      assert (p > buffer);\n\t      p[-1] = '\\n';\n\n\t      /* Indicate truncation.  */\n\t      *max_length = 0;\n\t      break;\n\t    }\n\n\t  length += length < 1024 ? 256 : 1024;\n\t  if (length > maxlen)\n\t    length = maxlen;\n\n\t  buffer = xrealloc (buffer, length);\n\t  *addr_of_buffer = (unsigned char *)buffer;\n\t  *length_of_buffer = length;\n\t  p = buffer + nbytes;\n\t}\n    }\n  /* Add the terminating NUL.  */\n  *p = 0;\n\n  /* Return the number of characters written to the buffer including\n     the newline, but not including the terminating NUL.  */\n  return nbytes;\n}\n\nstatic int\ntranslate_file_handle (int fd, int for_write)\n{\n#if defined(HAVE_W32CE_SYSTEM)\n  /* This is called only with one of the special filenames.  Under\n     W32CE the FD here is not a file descriptor but a rendezvous id,\n     thus we need to finish the pipe first.  */\n  fd = _assuan_w32ce_finish_pipe (fd, for_write);\n#elif defined(HAVE_W32_SYSTEM)\n  {\n    int x;\n\n    (void)for_write;\n\n    if (fd == 0)\n      x = (int) GetStdHandle (STD_INPUT_HANDLE);\n    else if (fd == 1)\n      x = (int) GetStdHandle (STD_OUTPUT_HANDLE);\n    else if (fd == 2)\n      x = (int) GetStdHandle (STD_ERROR_HANDLE);\n    else\n      x = fd;\n\n    if (x == -1)\n      log_debug (\"GetStdHandle(%d) failed: ec=%d\\n\",\n\t\t fd, (int) GetLastError ());\n\n    fd = x;\n  }\n#else\n  (void)for_write;\n#endif\n  return fd;\n}\n\n\nvoid\niobuf_skip_rest (iobuf_t a, unsigned long n, int partial)\n{\n  if ( partial )\n    {\n      for (;;)\n        {\n          if (a->nofast || a->d.start >= a->d.len)\n            {\n              if (iobuf_readbyte (a) == -1)\n                {\n                  break;\n                }\n\t    }\n          else\n            {\n              unsigned long count = a->d.len - a->d.start;\n              a->nbytes += count;\n              a->d.start = a->d.len;\n\t    }\n\t}\n    }\n  else\n    {\n      unsigned long remaining = n;\n      while (remaining > 0)\n        {\n          if (a->nofast || a->d.start >= a->d.len)\n            {\n              if (iobuf_readbyte (a) == -1)\n                {\n                  break;\n\t\t}\n              --remaining;\n\t    }\n          else\n            {\n              unsigned long count = a->d.len - a->d.start;\n              if (count > remaining)\n                {\n                  count = remaining;\n\t\t}\n              a->nbytes += count;\n              a->d.start += count;\n              remaining -= count;\n\t    }\n\t}\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/ChangeLog.jnlib": "2011-12-01  Werner Koch  <wk@g10code.com>\n\n\tNB: ChangeLog files are no longer manually maintained.  Starting\n\ton December 1st, 2011 we put change information only in the GIT\n\tcommit log, and generate a top-level ChangeLog file from logs at\n\t\"make dist\".  See doc/HACKING for details.\n\n\t[Update 2015-04-24: README.jnlib has been removed and all\n\t references to JNLIB, except for this file, have been removed.]\n\n2010-03-10  Werner Koch  <wk@g10code.com>\n\n\tSee gnupg/common/ChangeLog for newer changes.\n\n\tJNLIB has been merged into GnuPG's common directory.  README.jnlib\n\tlist the files making up JNLIB.\n\n\t* README: Rename to README.jnlib\n\t* ChangeLog: Rename to ChangeLog.jnlib.\n\t* Makefile.am: Remove.\n\n2010-03-01  Werner Koch  <wk@g10code.com>\n\n\t* t-w32-reg.c: New.\n\n\t* w32-reg.c (read_w32_registry_string)\n\t(write_w32_registry_string): Support W32CE.\n\n2010-02-26  Werner Koch  <wk@g10code.com>\n\n\t* t-timestuff.c: New.\n\n\t* dynload.h (dlopen, dlsym) [W32CE]: Map to wchar_t.\n\n\t* mischelp.c (_jnlib_free): New.\n\t(same_file_p) [W32CE]: Map to wchar_t.\n\n\t* utf8conv.c (set_native_charset) [W32CE]: Do not use\n\tGetConsoleOutputCP.\n\t(wchar_to_utf8, utf8_to_wchar) [W32]: New.\n\n\t* Makefile.am (t_jnlib_ldadd) [W32CE]: Add gpg-error.\n\n\t* t-support.h (getenv) [HAVE_GETENV]: Add getenv stub.\n\t[W32CE]: Include gpg-error.h\n\t* t-support.c (gpg_err_code_from_errno)\n\t(gpg_err_code_from_syserror) [GPG_ERROR_H]: Do not build.\n\n\t* t-stringhelp.c (gethome) [!HAVE_GETPWUID]: Keep result of getenv.\n\n\t* dotlock.c [!HAVE_SIGNAL_H]: Don't include signal.h.\n\t(create_dotlock) [W32CE]: Map filename top wchar_t.\n\n\t* libjnlib-config.h [USE_SIMPLE_GETTEXT]: Include gpg-error.h and\n\tremove w32help.h.\n\t(jnlib_set_errno): New.  Use it everywhere to set ERRNO.\n\t(getenv) [!HAVE_GETENV]: New.\n\t(getpid) [W32E]: New.\n\n\t* stringhelp.c (get_pwdir) [!HAVE_PWD_H]: Mark unused args.\n\t(w32_strerror) [W32CE]: Use a simple implementation.\n\n\t* w32help.h [USE_SIMPLE_GETTEXT]: Remove all definitions; we are\n\tnow using the gpg-error included implementation.\n\t* w32-gettext.c: Remove.\n\n\t* mischelp.c (same_file_p): Fix bug in case the second file can't\n\tbe opened.\n\n2009-10-19  Werner Koch  <wk@g10code.com>\n\n\t* strlist.c (add_to_strlist_try): New.\n\n2009-09-22  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.h (DOTLOCK): Rename to dotlock_t.  Change all users.\n\n2009-08-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (do_make_filename): Factor some code out to ..\n\t(get_pwdir): .. new.\n\n2009-08-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c [HAVE_PWD_H]: Include pwd.h.\n\t(do_make_filename): New.\n\t(make_filename, make_filename_try): Implement using the new\n\tfunction.\n\t* t-stringhelp.c (test_make_filename_try): New.\n\t* t-support.c (gcry_strdup): Fix.\n\n\t* stringhelp.h (make_filename, make_filename_try): Add sentinel\n\tattribute.\n\n2009-08-25  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c: Include errno.h.\n\t(do_strconcat): New.\n\t(strconcat, xstrconcat): New.\n\t* types.h (GNUPG_GCC_A_SENTINEL): New.\n\t* t-stringhelp.c (test_strconcat, test_xstrconcat): New.\n\t(main): Run them.\n\n2009-07-07  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_filename_try): Use jnlib_malloc.\n\n\t* dotlock.c (read_lockfile): Replace jnlib_xmalloc by jnlib_malloc.\n\n2009-06-04  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.h: Include SUN_LEN etc also for W32.\n\n2009-05-19  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.h: Define PF_LOCAL, AF_LOCAL and SUN_LEN if requested.\n\t* logging.c (fun_writer): Use SUN_LEN to fix a Mac OS X freeze.\n\n2009-03-25  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (fun_closer): Never close fd 2.\n\t(set_file_fd): Close logstream early.\n\n2009-02-25  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (get_tid_callback): New.\n\t(do_logv): Use it.\n\t(log_set_get_tid_callback): New.\n\n2009-01-22  Werner Koch  <wk@g10code.com>\n\n\t* t-support.c (gpg_err_code_from_errno)\n\t(gpg_err_code_from_syserror): New.\n\n2008-11-20  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (arg_parse): Fix last change.\n\n2008-11-11  Werner Koch  <wk@g10code.com>\n\n\t* argparse.h: Add a bunch of macros and constants.\n\t* argparse.c: Use the new macros.  Re-indent the code.  Change\n\tlicense back to LGPL 2.1.\n\n2008-11-04  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c: Merged with code from libgpg-error and rewrote\n\tmost parts.\n\n\t* Makefile.am (AM_CFLAGS): Add -DJNLIB_IN_JNLIB.\n\n2008-10-29  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_filename): Implement using macros. Factor some\n\tcode out to ..\n\t(change_slashes): New.\n\t(make_filename_try): New.\n\n\t* w32-gettext.c (gettext): Return if no domain is loaded.\n\tReported by Tom Pegios.\n\n2008-10-28  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (gettext): Try the binary search if the string was\n\tnot found in the hash table.\n\n2008-10-20  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c (_w32_sock_connect): Mark ADDRLEN as unused.\n\n\t* dotlock.c (release_dotlock): Do not mix declaration and code.\n\n\t* stringhelp.c (make_basename): Silent gcc warning about unused arg.\n\t* argparse.c (store_alias): Ditto.\n\t(find_long_option):\n\n2008-10-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv) [W32]: Flush the log stream.\n\n2008-09-29  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (ARGERR_): Use constants for error values.\n\t(optfile_parse): Prettify.  Replace xmalloc and xrealloc by malloc\n\tand realloc.\n\t* libjnlib-config.h (jnlib_strdup, jnlib_realloc): New.\n\n2008-06-26  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (print_sanitized_buffer2): Loose check for control\n\tcharacters to better cope with utf-8.  The range 0x80..0x9f is\n\tnowadays not anymore accidently used for control charaters.\n\n2008-06-13  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.c: Reformat code and implement locking for W32.\n\t(create_dotlock): Use snprintf.\n\n2008-06-11  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c: Remove useless variable ACTIVE_CHARSET.  Suggested\n\tby Petr Uzel.\n\n2008-05-26  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (usage): Make sure to print a trailing LF for usage(1).\n\n2008-04-08  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (gettext_select_utf8): New.\n\t(get_string): Support switching encodings.\n\t(load_domain): Allocate space for DATA_NATIVE.\n\n2008-03-25  Werner Koch  <wk@g10code.com>\n\n\t* w32-gettext.c (_nl_locale_name): New.  Taken from\n\t../common/localename and GNU gettext's localename.c.\n\t(set_gettext_file): Rewritten.\n\t(gettext_localename): New.\n\n2008-03-17  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (my_funopen_hook_size_t): New.\n\t(fun_writer): Use it to cope with fopencookie/funopen differences.\n\t* dotlock.c (read_lockfile): Initialize PID.  Reported by St\u00e9phane\n\tCorth\u00e9sy.\n\n2008-02-22  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Set copyright year to 2008.\n\n2007-11-19  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (percent_escape): Factor code out to\n\t(do_percent_escape): .. new.\n\t(try_percent_escape): New.\n\n2007-10-01  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c: Only keep the client related code.\n\t(read_port_and_nonce): New.  Taken from Assuan.\n\t(_w32_sock_connect): Rewritten.\n\n2007-08-29  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (initialize): Make strings translatable and remove\n\textra LF.\n\n2007-08-24  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.c (same_file_p): New.\n\t(libjnlib_dummy_mischelp_func): Remove as we now always have one\n\tfunction.\n\n2007-08-09  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (show_help): Expand the @EMAIL@ macro in the package\n\tbug reporting address.\n\n2007-08-02  Werner Koch  <wk@g10code.com>\n\n\t* t-stringhelp.c (test_compare_filenames): New.\n\n\t* stringhelp.c (compare_filenames) [HAVE_DRIVE_LETTERS]: Fixed\n\tcomparison to take slash and backslash in account.\n\t(make_filename): Avoid mixing / and \\.\n\n2007-07-04  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (load_libiconv): Remove URL from translatble string.\n\n\tSwitched JNLIB from LGPLv2.1 to LGPLv3.\n\n2007-07-01  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Use id 10 for the license string;\n\tdefault to GPL3+.  Change long note to version 3 or later.\n\t(show_version): Print the license info.\n\n2007-06-19  Werner Koch  <wk@g10code.com>\n\n\t* Makefile.am: Add support for regression tests.\n\t* t-support.h, t-support.c: New.\n\t* t-stringhelp.c: New.\n\n\t* stringhelp.c (percent_escape): Add arg EXTRA to make it a more\n\tgeneral function.  Changed all callers.\n\n2007-06-18  Werner Koch  <wk@g10code.com>\n\n\t* w32-afunix.c (_w32_sock_bind): Changed to properly detect an\n\talready used socket.\n\n2007-06-18  Marcus Brinkmann  <marcus@g10code.de>\n\n\t* stringhelp.h (percent_escape): New prototype.\n\t* stringhelp.c (percent_escape): New function.\n\n2007-06-11  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (jnlib_iconv_open, jnlib_iconv, jnlib_iconv_close): New.\n\n2007-06-06  Werner Koch  <wk@g10code.com>\n\n\t* w32help.h: New.\n\t* w32-gettext.c: New.  Taken from gnupg 1.4, added ngettext,\n\tchanged to use jnlib malloc functions and put under the LGPL.\n\t* w32-reg.c: New.  Taken from../common/w32reg.c and changed to\n\tLGPL.  Changed API to use the jnlib malloc functions.\n\t* Makefile.am (libjnlib_a_SOURCES) [!W32]: Do not build the w32\n\tspecific modules.\n\n\t* dotlock.c: Include stringhelp.h for stpcpy prototype.\n\n2007-06-04  Werner Koch  <wk@g10code.com>\n\n\t* dynload.h: New.  Taken from ../common and changed to LGPL.\n\n\t* utf8conv.c (load_libiconv): New.  Taken from GnuPG 1.4\n\n2007-05-30  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.h, w32-pth.c: Remove.\n\n2007-04-25  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (long_opt_strlen): Fixed for utf-8.\n\n2007-03-07  Werner Koch  <wk@g10code.com>\n\n\t* argparse.c (strusage): Set copyright year to 2007.\n\n2007-01-25  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (utf8_charcount): New.\n\n2006-11-29  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c (set_native_charset) [HAVE_W32_SYSTEM]: Fixed typo in\n\tmacro name.\n\n2006-11-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (my_funopen_hook_ret_t): New.\n\t(fun_writer): Use it.\n\n2006-10-19  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (memrchr) [!HAVE_MEMRCHR]: Provide a replacement.\n\n2006-09-27  Werner Koch  <wk@g10code.com>\n\n\t* mischelp.c: New.\n\t(timegm): Copied from gnupg 1.4, changed from GPL to LGPL.  Fixed\n\ta memory leak.\n\n\t* stringhelp.h (isascii): New.\n\n\t* stringhelp.c (strsep): New. Copied from gnupg 1.4.5\n\tutil/strgutil.c.\n\n\t* strlist.h (STRLIST): Removed deprecated typedef.\n\n\t* types.h: Made cpp commands work with old compilers.  Also shows\n\tup nicer with Emacs' font locking.\n\n\t* w32-afunix.c (_w32_sock_connect): Set ERRNO for an invalid port.\n\n        Changed license from GPL to LGPL.  Note that all code has either\n\tbeen written by me, David, employees of g10 Code or taken from\n\tglibc.\n\n\t* libjnlib-config.h, stringhelp.c, stringhelp.h:\n\t* strlist.c, strlist.h,\tutf8conv.c, utf8conv.h:\n\t* argparse.c, argparse.h, logging.c, logging.h:\n\t* dotlock.c, dotlock.h, types.h, mischelp.h:\n        * xmalloc.c, xmalloc.h, w32-pth.c, w32-pth.h:\n\t* w32-afunix.c, w32-afunix.h: Tagged them to be long to jnlib\n\twhich is a part of GnuPG but also used by other projetcs.\n\n2006-09-22  Werner Koch  <wk@g10code.com>\n\n\t* utf8conv.c: Reworked to match the gnupg 1.4.5 code.  This now\n\trequires iconv support but this is reasonable for all modern\n\tsystems.\n\n2006-08-29  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv): Emit a missing LF for fatal errors.\n\n2006-06-28  Werner Koch  <wk@g10code.com>\n\n\t* dotlock.c (make_dotlock, release_dotlock, read_lockfile)\n\t(maybe_deadlock, destroy_dotlock, create_dotlock): Re-indented.\n\t(create_dotlock): Repalces some log_fatal by log_error as it was\n\tnot intended that they should terminate.  Write the nodename to\n\tthe locking file. Code cleanups.\n\t(read_lockfile): Reworked to read the node name.\n\t(make_dotlock): Test for identical node name and delete lock stale\n\tfile.\n\t(release_dotlock): Likewise.\n\n2006-05-23  Werner Koch  <wk@g10code.com>\n\n\t* libjnlib-config.h (JNLIB_NEED_UTF8CONV): Fixed typo in name.\n\n\t* dotlock.c (release_dotlock): Don't act if we don't have any\n\tlocks at all.\n\t(destroy_dotlock): New.  From 1.4.3.\n\t(dotlock_remove_lockfiles): Make use of destroy function.\n\n2006-05-19  Werner Koch  <wk@g10code.com>\n\n\t* strlist.c (append_to_strlist2): Enabled.\n\n\t* stringhelp.c (print_sanitized_buffer2): New.  Changed the rules\n\tto match the behaviour of print_string2 from gnupg 1.4.3.\n\t(print_sanitized_buffer): Use the new function.\n\t(print_sanitized_string2): New.\n\t(hextobyte): New.  Taken from gpg 1.4.3.\n\n2006-04-28  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (print_sanitized_buffer): Fix bug where the count\n\tgot wrong for the \\xNN representation.\n\t(sanitize_buffer): Fix bug where some control characters lose part\n\tof their \\xNN representation.\n\n2006-04-20  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (make_basename): New arg INPUTPATH for future\n\triscos compatibility.\n\n2006-04-18  Werner Koch  <wk@g10code.com>\n\n\t* libjnlib-config.h (JNLIB_NEED_UTF8CONF): Defined.\n\t* strlist.c (add_to_strlist2) [JNLIB_NEED_UTF8CONV]: Enabled.\n\n2005-06-15  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (sanitize_buffer): Make P a void*.\n\t(ascii_memistr, memistr): Ditto.\n\t(ascii_memcasecmp): Ditto.\n\t* logging.c (writen): Use void * for arg BUFFER.\n\t* stringhelp.c (memistr): Fixed unsigned/signed pointer conflict.\n\t(ascii_memistr): Ditto.\n\t(ascii_memcasemem): Ditto.\n\t* utf8conv.c (utf8_to_native): Ditto.\n\t(utf8_to_native): Ditto.\n\t* argparse.c (show_version): Removed non-required cast.\n\n2005-01-19  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (fun_writer): Don't fallback to stderr. Print to\n\tstderr only if connected to a tty.\n\n2004-12-20  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (do_pth_event_free): The events are hold in a ring\n\tbuffer.  Adjust for that.\n\t(do_pth_event_body): Ditto.\n\t(pth_event_isolate): Ditto.\n\t(do_pth_wait): Ditto.\n\t(_pth_event_count): Renamed to ..\n\t(event_count): .. and adjusted as above.\n\t(pth_init): Define 3 debug levels and change all debug calls to\n\tmake use of them.  This makes the moule now silent.\n\n2004-12-19  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (pth_init): Enable debugging depending on env var.\n\t(pth_self): New.\n\t(pth_mutex_release, pth_mutex_acquire): Implemented directly using\n\tthe W32 API.\n\n2004-12-18  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (pth_init): Reverse return values.  Use TRUE and FALSE\n\tconstants.\n\t(pth_kill, pth_mutex_acquire, pth_attr_set, pth_join, pth_cancel):\n\tDitto.\n\n2004-12-15  Werner Koch  <wk@g10code.com>\n\n\t* logging.c [W32]: Don't include unavailable headers.\n\n2004-12-14  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c (_pth_strerror): Renamed to ...\n\t(w32_strerror): .. this. And let callers provide a buffer.\n\t(spawn_helper_thread): Removed HD arg and hardwire the stack size\n\tto 32k.\n\t(do_pth_wait): Removed use of ATTR; not needed for the helper\n\tthreads.\n\t(helper_thread): Renamed to ..\n\t(launch_thread): .. this.  Release handle if not joinable.\n\t(struct pth_priv_hd_s): Renamed to ...\n\t(struct thread_info_s): .. this.  Add member JOINABLE and TH.\n\n2004-12-14  Timo Schulz  <twoaday@g10code.com>\n\n\t* w32-pth.c (pth_kill): Just release the crit section if\n\tpth_init was really called. And set all handles to NULL.\n\t(_pth_strerror): New.\n\t(do_pth_wait): Before we enter the loop we check if there\n\tare too much events in the ring.\n\n2004-12-14  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.h (pth_event_occured): Removed macro.\n\t* w32-pth.c: Fixed license statement; its under the LGPL.\n\t(enter_pth, leave_pth): Use them to bracket almost all public\n\tfunctions.\n\n2004-12-13  Timo Schulz  <twoaday@g10code.com>\n\n\t* w32-pth.c (enter_pth, leave_pth): New.\n\t(pth_init): Initialize global mutex section.\n\t(pth_kill): Release global mutex section.\n\t(helper_thread): New.\n\t(pth_spawn): Make sure only one thread is running.\n\n2004-12-13  Werner Koch  <wk@g10code.com>\n\n\t* stringhelp.c (w32_strerror) [W32]: New.\n\n\t* w32-pth.c, w32-pth.h: Added real code written by Timo\tSchulz.\n\tNot finished, though.\n\n2004-12-07  Werner Koch  <wk@g10code.com>\n\n\t* w32-pth.c, w32-pth.h: New.\n\n2004-11-26  Werner Koch  <wk@g10code.com>\n\n\t* logging.c [_WIN32]: Don't include socket headers.\n\n2004-11-30  Timo Schulz  <ts@g10code.com>\n\n\t* w32-afunix.c: New. AF_UNIX emulation for W32.\n\t* w32-afunix.h: Likewise.\n\n2004-11-22  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (log_test_fd): Add test on LOGSTREAM.  Reported by\n\tBarry Schwartz.\n\n2004-11-18  Werner Koch  <wk@g10code.com>\n\n\t* logging.c: Explicitly include sys/stat.h for the S_I* constants.\n\n2004-10-21  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (do_logv): Use set_log_stream to setup a default.\n\t(log_set_file): Factored code out to ..\n\t(set_file_fd): .. New function to allow using a file descriptor.\n\t(log_set_fd): Make use of new fucntion.\n\t(fun_writer): Reworked.\n\n2004-08-18  Werner Koch  <wk@g10code.de>\n\n\t* stringhelp.c (print_sanitized_utf8_string): Actually implement\n\tit.\n\n2004-06-21  Werner Koch  <wk@g10code.com>\n\n\t* logging.c (log_set_file): Do not close an old logstream if it\n\tused to be stderr or stdout.\n\n2004-05-05  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_file): Oops, don't close if LOGSTREAM is NULL.\n\n2004-04-30  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_file): Make sure the log stream will be\n\tclosed even if the stderr fileno will be assigned to a new socket.\n\n2004-04-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.h (JNLIB_LOG_WITH_PREFIX): Add constants for the flag\n\tvalues.\n\t* logging.c (log_set_prefix): New flag DETACHED.\n\t(fun_writer): Take care of this flag.\n\t(log_test_fd): New.\n\n2004-02-18  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (print_sanitized_buffer): Don't care about\n\tnon-ASCII characaters.\n\t(sanitize_buffer): Ditto.\n\n2004-02-12  Werner Koch  <wk@gnupg.org>\n\n\t* Makefile.am: Replaced INCLUDES by AM_CPPFLAGS.\n\n2004-01-05  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (strusage): Changed default copyright year to 2004.\n\n2003-12-17  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (initialize): Replaced use of non-literal format\n\targs.  Suggested by Florian Weimer.\n\n2003-12-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (writen, fun_writer, fun_closer): New.\n\t(log_set_file): Add feature to log to a socket.\n\t(log_set_file, do_logv): Force printing with prefix and pid.\n\n2003-11-13  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c (strlist_copy): New.\n\n\t* dotlock.c: Define DIRSEP_C et al. if not defined.\n\n2003-11-06  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.h (strlist_t): New. STRLIST is now deprecated.\n\n2003-06-18  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c (strlist_pop): New.\n\n\t* dotlock.c (dotlock_remove_lockfiles): Prefixed with dotlock_ and\n\tmade global.\n\n2003-06-17  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (length_sans_trailing_chars)\n\t(length_sans_trailing_ws): New.\n\n\t* logging.c (log_inc_errorcount): New.\n\n\t* stringhelp.c (print_sanitized_utf8_buffer): Implement utf8\n\tconversion.\n\t(sanitize_buffer): New. Based on gnupg 1.3.2 make_printable_string.\n\n\t* dotlock.c: Updated to match the version from 1.3.2\n\t* utf8conv.c: New.  Code taken from strgutil.c of gnupg 1.3.2.\n\t* utf8conv.h: New.\n\n2003-06-16  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (do_logv): Hack to optionally suppress a leading space.\n\n\t* stringhelp.c (ascii_strncasecmp): New.  Taken from gnupg 1.3.\n\t(ascii_memistr): New. Taken from gnupg 1.3\n\n2003-06-13  Werner Koch  <wk@gnupg.org>\n\n\t* mischelp.h (wipememory2,wipememory): New. Taken from GnuPG 1.3.2.\n\n2002-06-04  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (print_sanitized_utf8_string): New.  No real\n\timplementation for now.\n\t(print_sanitized_utf8_buffer): Ditto.\n\n2002-04-04  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_get_prefix): New.\n\n2002-03-15  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (optfile_parse): Fixed missing argument handling.\n\n2002-02-25  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (ascii_memcasemem): New.\n\n2002-02-14  Werner Koch  <wk@gnupg.org>\n\n\t* Makefile.am (INCLUDES): Add cflags for libgcrypt.\n\n2002-02-07  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_fd): New.\n\n\t* stringhelp.c (print_sanitized_buffer): New.\n\t(print_sanitized_string): New.\n\n2002-01-24  Werner Koch  <wk@gnupg.org>\n\n\t* argparse.c (strusage): Set default copyright notice year to 2002.\n\n\tFixed the copyright notice of this file, as it has always been\n\tpart of GnuPG and therefore belongs to the FSF.\n\n2001-11-01  Marcus Brinkmann  <marcus@g10code.de>\n\n\t* logging.c (log_printf): Do not initialize ARG_PTR with 0, we\n\tdon't know the correct type.  Instead, run va_start and va_end\n\tunconditionally.\n\tReported by Jose Carlos Garcia Sogo <jsogo@debian.org>.\n\n2002-01-19  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_get_stream): New.\n\n2001-12-05  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_set_prefix): New.\n\t(do_logv): Include prefix and pid only if enabled. Print time only\n\twhen explicitly enabled.\n\t(log_logv): New.\n\t* logging.h: Include log_logv() only when requested.\n\n2001-11-06  Werner Koch  <wk@gnupg.org>\n\n\t* strlist.c, strlist.h: New. Taken from pgnupg/util/strgutil.c\n\n2001-08-30  Werner Koch  <wk@gnupg.org>\n\n\t* logging.c (log_printf): Don't pass NULL instead of arg_ptr.\n\n2001-07-19  Werner Koch  <wk@gnupg.org>\n\n\t* stringhelp.c (ascii_memistr,ascii_isupper,ascii_islower,\n\tascii_toupper,ascii_tolower, ascii_strcasecmp, ascii_memcasecmp): New.\n\n2000-07-26 10:02:51  Werner Koch  (wk@habibti.openit.de)\n\n\t* stringhelp.c.: Add stdarg.h\n\t* argparse.h: s/ulong/unsigned long/ although this should be defined\n        by types.h.\n\n2000-06-28 19:40:23  Werner Koch  (wk@habibti.openit.de)\n\n\t* Makefile.am: Replaced second logging.c by .h\n\n2000-05-24 08:58:15  Werner Koch  (wk@habibti.openit.de)\n\n\t* logging.c (log_get_errorcount): New.\n\n2000-05-24 08:44:47  Werner Koch  (wk@habibti.openit.de)\n\n\t* stringhelp.c: Added a few filename related helper functions.\n\n2000-05-11 18:04:43  Werner Koch  (wk@habibti.openit.de)\n\n\t* xmalloc.c (xstrcat2): Replaced stpcpy to quickly address W32\n\tproblems.\n\n2000-05-02 19:43:38  Werner Koch  (wk@habibti.openit.de)\n\n\t* xmalloc.c (xstrcat2): New.\n\nMon Jan 24 13:04:28 CET 2000  Werner Koch  <wk@gnupg.de>\n\n\t* README: New.\n\t* Makefile.am: new.\n\t* argparse.c, argparse.h, logging.c, logging.h:\n\t* mischelp.h, stringhelp.c, stringhelp.h, xmalloc.c:\n\t* xmalloc.h, dotlock.c: Moved from ../util to here.\n\t* dotlock.h: New.\n\t* libjnlib-config.h: New.\n\n\t* logging.c (log_set_file): New.\n\t(log_printf): New.\n\t(do_logv): Add kludge to insert LFs.\n\n\n     ***********************************************************\n     * Please note that JNLIB is maintained as part of GnuPG.  *\n     * You may find it source-copied in other packages.        *\n     ***********************************************************\n\n Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n\t   2010 Free Software Foundation, Inc.\n\n This file is free software; as a special exception the author gives\n unlimited permission to copy and/or distribute it, with or without\n modifications, as long as this notice is preserved.\n\n This file is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY, to the extent permitted by law; without even the\n implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nLocal Variables:\nbuffer-read-only: t\nEnd:\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/homedir.c": "/* homedir.c - Setup the home directory.\n * Copyright (C) 2004, 2006, 2007, 2010 Free Software Foundation, Inc.\n * Copyright (C) 2013, 2016 Werner Koch\n *\n * This file is part of GnuPG.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * This file is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#ifdef HAVE_W32_SYSTEM\n#include <winsock2.h>   /* Due to the stupid mingw64 requirement to\n                           include this header before windows.h which\n                           is often implicitly included.  */\n#include <shlobj.h>\n#ifndef CSIDL_APPDATA\n#define CSIDL_APPDATA 0x001a\n#endif\n#ifndef CSIDL_LOCAL_APPDATA\n#define CSIDL_LOCAL_APPDATA 0x001c\n#endif\n#ifndef CSIDL_COMMON_APPDATA\n#define CSIDL_COMMON_APPDATA 0x0023\n#endif\n#ifndef CSIDL_FLAG_CREATE\n#define CSIDL_FLAG_CREATE 0x8000\n#endif\n#endif /*HAVE_W32_SYSTEM*/\n\n#ifdef HAVE_STAT\n#include <sys/stat.h> /* for stat() */\n#endif\n\n\n\n#include \"util.h\"\n#include \"sysutils.h\"\n#include \"zb32.h\"\n\n/* The GnuPG homedir.  This is only accessed by the functions\n * gnupg_homedir and gnupg_set_homedir.  Malloced.  */\nstatic char *the_gnupg_homedir;\n\n/* Flag indicating that home directory is not the default one.  */\nstatic byte non_default_homedir;\n\n\n#ifdef HAVE_W32_SYSTEM\n/* A flag used to indicate that a control file for gpgconf has been\n   detected.  Under Windows the presence of this file indicates a\n   portable installations and triggers several changes:\n\n   - The GNUGHOME directory is fixed relative to installation\n     directory.  All other means to set the home directory are ignore.\n\n   - All registry variables will be ignored.\n\n   This flag is not used on Unix systems.\n */\nstatic byte w32_portable_app;\n#endif /*HAVE_W32_SYSTEM*/\n\n#ifdef HAVE_W32_SYSTEM\n/* This flag is true if this process' binary has been installed under\n   bin and not in the root directory as often used before GnuPG 2.1. */\nstatic byte w32_bin_is_bin;\n#endif /*HAVE_W32_SYSTEM*/\n\n\n#ifdef HAVE_W32_SYSTEM\nstatic const char *w32_rootdir (void);\n#endif\n\n\n\n#ifdef HAVE_W32_SYSTEM\nstatic void\nw32_try_mkdir (const char *dir)\n{\n#ifdef HAVE_W32CE_SYSTEM\n  wchar_t *wdir = utf8_to_wchar (dir);\n  if (wdir)\n    {\n      CreateDirectory (wdir, NULL);\n      xfree (wdir);\n    }\n#else\n  CreateDirectory (dir, NULL);\n#endif\n}\n#endif\n\n\n/* This is a helper function to load a Windows function from either of\n   one DLLs. */\n#ifdef HAVE_W32_SYSTEM\nstatic HRESULT\nw32_shgetfolderpath (HWND a, int b, HANDLE c, DWORD d, LPSTR e)\n{\n  static int initialized;\n  static HRESULT (WINAPI * func)(HWND,int,HANDLE,DWORD,LPSTR);\n\n  if (!initialized)\n    {\n      static char *dllnames[] = { \"shell32.dll\", \"shfolder.dll\", NULL };\n      void *handle;\n      int i;\n\n      initialized = 1;\n\n      for (i=0, handle = NULL; !handle && dllnames[i]; i++)\n        {\n          handle = dlopen (dllnames[i], RTLD_LAZY);\n          if (handle)\n            {\n              func = dlsym (handle, \"SHGetFolderPathA\");\n              if (!func)\n                {\n                  dlclose (handle);\n                  handle = NULL;\n                }\n            }\n        }\n    }\n\n  if (func)\n    return func (a,b,c,d,e);\n  else\n    return -1;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n\n/* Check whether DIR is the default homedir.  */\nstatic int\nis_gnupg_default_homedir (const char *dir)\n{\n  int result;\n  char *a = make_absfilename (dir, NULL);\n  char *b = make_absfilename (GNUPG_DEFAULT_HOMEDIR, NULL);\n  result = !compare_filenames (a, b);\n  xfree (b);\n  xfree (a);\n  return result;\n}\n\n\n/* Helper to remove trailing slashes from NEWDIR.  Return a new\n * allocated string if that has been done or NULL if there are no\n * slashes to remove.  Also inserts a missing slash after a Windows\n * drive letter.  */\nstatic char *\ncopy_dir_with_fixup (const char *newdir)\n{\n  char *result = NULL;\n  char *p;\n\n  if (!*newdir)\n    return NULL;\n\n#ifdef HAVE_W32_SYSTEM\n  if (newdir[0] && newdir[1] == ':'\n      && !(newdir[2] == '/' || newdir[2] == '\\\\'))\n    {\n      /* Drive letter with missing leading slash.  */\n      p = result = xmalloc (strlen (newdir) + 1 + 1);\n      *p++ = newdir[0];\n      *p++ = newdir[1];\n      *p++ = '\\\\';\n      strcpy (p, newdir+2);\n\n      /* Remove trailing slashes.  */\n      p = result + strlen (result) - 1;\n      while (p > result+2 && (*p == '/' || *p == '\\\\'))\n        *p-- = 0;\n    }\n  else if (newdir[strlen (newdir)-1] == '/'\n           || newdir[strlen (newdir)-1] == '\\\\' )\n    {\n      result = xstrdup (newdir);\n      p = result + strlen (result) - 1;\n      while (p > result\n             && (*p == '/' || *p == '\\\\')\n             && (p-1 > result && p[-1] != ':')) /* We keep \"c:/\". */\n        *p-- = 0;\n    }\n\n#else /*!HAVE_W32_SYSTEM*/\n\n  if (newdir[strlen (newdir)-1] == '/')\n    {\n      result = xstrdup (newdir);\n      p = result + strlen (result) - 1;\n      while (p > result && *p == '/')\n        *p-- = 0;\n    }\n\n#endif /*!HAVE_W32_SYSTEM*/\n\n  return result;\n}\n\n\n/* Get the standard home directory.  In general this function should\n   not be used as it does not consider a registry value (under W32) or\n   the GNUPGHOME environment variable.  It is better to use\n   default_homedir(). */\nconst char *\nstandard_homedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static const char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        {\n          dir = xstrconcat (rdir, DIRSEP_S \"home\", NULL);\n        }\n      else\n        {\n          char path[MAX_PATH];\n\n          /* It might be better to use LOCAL_APPDATA because this is\n             defined as \"non roaming\" and thus more likely to be kept\n             locally.  For private keys this is desired.  However,\n             given that many users copy private keys anyway forth and\n             back, using a system roaming services might be better\n             than to let them do it manually.  A security conscious\n             user will anyway use the registry entry to have better\n             control.  */\n          if (w32_shgetfolderpath (NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE,\n                                   NULL, 0, path) >= 0)\n            {\n              char *tmp = xmalloc (strlen (path) + 6 +1);\n              strcpy (stpcpy (tmp, path), \"\\\\gnupg\");\n              dir = tmp;\n\n              /* Try to create the directory if it does not yet exists.  */\n              if (access (dir, F_OK))\n                w32_try_mkdir (dir);\n            }\n          else\n            dir = GNUPG_DEFAULT_HOMEDIR;\n        }\n    }\n  return dir;\n#else/*!HAVE_W32_SYSTEM*/\n  return GNUPG_DEFAULT_HOMEDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n/* Set up the default home directory.  The usual --homedir option\n   should be parsed later. */\nconst char *\ndefault_homedir (void)\n{\n  const char *dir;\n\n#ifdef HAVE_W32_SYSTEM\n  /* For a portable application we only use the standard homedir.  */\n  w32_rootdir ();\n  if (w32_portable_app)\n    return standard_homedir ();\n#endif /*HAVE_W32_SYSTEM*/\n\n  dir = getenv (\"GNUPGHOME\");\n#ifdef HAVE_W32_SYSTEM\n  if (!dir || !*dir)\n    {\n      static const char *saved_dir;\n\n      if (!saved_dir)\n        {\n          if (!dir || !*dir)\n            {\n              char *tmp, *p;\n\n              /* This is deprecated; gpgconf --list-dirs prints a\n               * warning if the homedir has been taken from the\n               * registry.  */\n              tmp = read_w32_registry_string (NULL,\n                                              GNUPG_REGISTRY_DIR,\n                                              \"HomeDir\");\n              if (tmp && !*tmp)\n                {\n                  xfree (tmp);\n                  tmp = NULL;\n                }\n              if (tmp)\n                {\n                  /* Strip trailing backslashes.  */\n                  p = tmp + strlen (tmp) - 1;\n                  while (p > tmp && *p == '\\\\')\n                    *p-- = 0;\n                  saved_dir = tmp;\n                }\n            }\n\n          if (!saved_dir)\n            saved_dir = standard_homedir ();\n        }\n      dir = saved_dir;\n    }\n#endif /*HAVE_W32_SYSTEM*/\n\n  if (!dir || !*dir)\n    dir = GNUPG_DEFAULT_HOMEDIR;\n  else\n    {\n      char *p;\n\n      p = copy_dir_with_fixup (dir);\n      if (p)\n        dir = p;\n\n      if (!is_gnupg_default_homedir (dir))\n        non_default_homedir = 1;\n    }\n\n  return dir;\n}\n\n\n#ifdef HAVE_W32_SYSTEM\n/* Check whether gpgconf is installed and if so read the gpgconf.ctl\n   file. */\nstatic void\ncheck_portable_app (const char *dir)\n{\n  char *fname;\n\n  fname = xstrconcat (dir, DIRSEP_S \"gpgconf.exe\", NULL);\n  if (!access (fname, F_OK))\n    {\n      strcpy (fname + strlen (fname) - 3, \"ctl\");\n      if (!access (fname, F_OK))\n        {\n          /* gpgconf.ctl file found.  Record this fact.  */\n          w32_portable_app = 1;\n          {\n            unsigned int flags;\n            log_get_prefix (&flags);\n            log_set_prefix (NULL, (flags | GPGRT_LOG_NO_REGISTRY));\n          }\n          /* FIXME: We should read the file to detect special flags\n             and print a warning if we don't understand them  */\n        }\n    }\n  xfree (fname);\n}\n\n\n/* Determine the root directory of the gnupg installation on Windows.  */\nstatic const char *\nw32_rootdir (void)\n{\n  static int got_dir;\n  static char dir[MAX_PATH+5];\n\n  if (!got_dir)\n    {\n      char *p;\n      int rc;\n      wchar_t wdir [MAX_PATH+5];\n\n      rc = GetModuleFileNameW (NULL, wdir, MAX_PATH);\n      if (rc && WideCharToMultiByte (CP_UTF8, 0, wdir, -1, dir, MAX_PATH-4,\n                                     NULL, NULL) < 0)\n        rc = 0;\n      if (!rc)\n        {\n          log_debug (\"GetModuleFileName failed: %s\\n\", w32_strerror (-1));\n          *dir = 0;\n        }\n      got_dir = 1;\n      p = strrchr (dir, DIRSEP_C);\n      if (p)\n        {\n          *p = 0;\n\n          check_portable_app (dir);\n\n          /* If we are installed below \"bin\" we strip that and use\n             the top directory instead.  */\n          p = strrchr (dir, DIRSEP_C);\n          if (p && !strcmp (p+1, \"bin\"))\n            {\n              *p = 0;\n              w32_bin_is_bin = 1;\n            }\n        }\n      if (!p)\n        {\n          log_debug (\"bad filename '%s' returned for this process\\n\", dir);\n          *dir = 0;\n        }\n    }\n\n  if (*dir)\n    return dir;\n  /* Fallback to the hardwired value. */\n  return GNUPG_LIBEXECDIR;\n}\n\nstatic const char *\nw32_commondir (void)\n{\n  static char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n      char path[MAX_PATH];\n\n      /* Make sure that w32_rootdir has been called so that we are\n         able to check the portable application flag.  The common dir\n         is the identical to the rootdir.  In that case there is also\n         no need to strdup its value.  */\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        return rdir;\n\n      if (w32_shgetfolderpath (NULL, CSIDL_COMMON_APPDATA,\n                               NULL, 0, path) >= 0)\n        {\n          char *tmp = xmalloc (strlen (path) + 4 +1);\n          strcpy (stpcpy (tmp, path), \"\\\\GNU\");\n          dir = tmp;\n          /* No auto create of the directory.  Either the installer or\n             the admin has to create these directories.  */\n        }\n      else\n        {\n          /* Ooops: Not defined - probably an old Windows version.\n             Use the installation directory instead.  */\n          dir = xstrdup (rdir);\n        }\n    }\n\n  return dir;\n}\n#endif /*HAVE_W32_SYSTEM*/\n\n\n/* Change the homedir.  Some care must be taken to set this early\n * enough because previous calls to gnupg_homedir may else return a\n * different string.  */\nvoid\ngnupg_set_homedir (const char *newdir)\n{\n  char *tmp = NULL;\n\n  if (!newdir || !*newdir)\n    newdir = default_homedir ();\n  else\n    {\n      tmp = copy_dir_with_fixup (newdir);\n      if (tmp)\n        newdir = tmp;\n\n      if (!is_gnupg_default_homedir (newdir))\n        non_default_homedir = 1;\n    }\n  xfree (the_gnupg_homedir);\n  the_gnupg_homedir = make_absfilename (newdir, NULL);;\n  xfree (tmp);\n}\n\n\n/* Return the homedir.  The returned string is valid until another\n * gnupg-set-homedir call.  This is always an absolute directory name.\n * The function replaces the former global var opt.homedir.  */\nconst char *\ngnupg_homedir (void)\n{\n  /* If a homedir has not been set, set it to the default.  */\n  if (!the_gnupg_homedir)\n    the_gnupg_homedir = make_absfilename (default_homedir (), NULL);\n  return the_gnupg_homedir;\n}\n\n\n/* Return whether the home dir is the default one.  */\nint\ngnupg_default_homedir_p (void)\n{\n  return !non_default_homedir;\n}\n\n\n/* Return the directory name used by daemons for their current working\n * directory.  */\nconst char *\ngnupg_daemon_rootdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    {\n      char path[MAX_PATH];\n      size_t n;\n\n      n = GetSystemDirectoryA (path, sizeof path);\n      if (!n || n >= sizeof path)\n        name = xstrdup (\"/\"); /* Error - use the curret top dir instead.  */\n      else\n        name = xstrdup (path);\n    }\n\n  return name;\n\n#else /*!HAVE_W32_SYSTEM*/\n  return \"/\";\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Helper for gnupg-socketdir.  This is a global function, so that\n * gpgconf can use it for its --create-socketdir command.  If\n * SKIP_CHECKS is set permission checks etc. are not done.  The\n * function always returns a malloced directory name and stores these\n * bit flags at R_INFO:\n *\n *   1 := Internal error, stat failed, out of core, etc.\n *   2 := No /run/user directory.\n *   4 := Directory not owned by the user, not a directory\n *        or wrong permissions.\n *   8 := Same as 4 but for the subdir.\n *  16 := mkdir failed\n *  32 := Non default homedir; checking subdir.\n *  64 := Subdir does not exist.\n * 128 := Using homedir as fallback.\n */\nchar *\n_gnupg_socketdir_internal (int skip_checks, unsigned *r_info)\n{\n#if defined(HAVE_W32_SYSTEM) || !defined(HAVE_STAT)\n\n  char *name;\n\n  (void)skip_checks;\n  *r_info = 0;\n  name = xstrdup (gnupg_homedir ());\n\n#else /* Unix and stat(2) available. */\n\n  static const char * const bases[] = {\n#ifdef USE_RUN_GNUPG_USER_SOCKET\n    \"/run/gnupg\",\n#endif\n    \"/run\",\n#ifdef USE_RUN_GNUPG_USER_SOCKET\n    \"/var/run/gnupg\",\n#endif\n    \"/var/run\",\n    NULL\n  };\n  int i;\n  struct stat sb;\n  char prefix[19 + 1 + 20 + 6 + 1];\n  const char *s;\n  char *name = NULL;\n\n  *r_info = 0;\n\n  /* First make sure that non_default_homedir can be set.  */\n  gnupg_homedir ();\n\n  /* It has been suggested to first check XDG_RUNTIME_DIR envvar.\n   * However, the specs state that the lifetime of the directory MUST\n   * be bound to the user being logged in.  Now GnuPG may also be run\n   * as a background process with no (desktop) user logged in.  Thus\n   * we better don't do that.  */\n\n  /* Check whether we have a /run/[gnupg/]user dir.  */\n  for (i=0; bases[i]; i++)\n    {\n      snprintf (prefix, sizeof prefix, \"%s/user/%u\",\n                bases[i], (unsigned int)getuid ());\n      if (!stat (prefix, &sb) && S_ISDIR(sb.st_mode))\n        break;\n    }\n  if (!bases[i])\n    {\n      *r_info |= 2; /* No /run/user directory.  */\n      goto leave;\n    }\n\n  if (sb.st_uid != getuid ())\n    {\n      *r_info |= 4; /* Not owned by the user.  */\n      if (!skip_checks)\n        goto leave;\n    }\n\n  if (strlen (prefix) + 7 >= sizeof prefix)\n    {\n      *r_info |= 1; /* Ooops: Buffer too short to append \"/gnupg\".  */\n      goto leave;\n    }\n  strcat (prefix, \"/gnupg\");\n\n  /* Check whether the gnupg sub directory has proper permissions.  */\n  if (stat (prefix, &sb))\n    {\n      if (errno != ENOENT)\n        {\n          *r_info |= 1; /* stat failed.  */\n          goto leave;\n        }\n\n      /* Try to create the directory and check again.  */\n      if (gnupg_mkdir (prefix, \"-rwx\"))\n        {\n          *r_info |= 16; /* mkdir failed.  */\n          goto leave;\n        }\n      if (stat (prefix, &sb))\n        {\n          *r_info |= 1; /* stat failed.  */\n          goto leave;\n        }\n    }\n  /* Check that it is a directory, owned by the user, and only the\n   * user has permissions to use it.  */\n  if (!S_ISDIR(sb.st_mode)\n      || sb.st_uid != getuid ()\n      || (sb.st_mode & (S_IRWXG|S_IRWXO)))\n    {\n      *r_info |= 4; /* Bad permissions or not a directory. */\n      if (!skip_checks)\n        goto leave;\n    }\n\n  /* If a non default homedir is used, we check whether an\n   * corresponding sub directory below the socket dir is available\n   * and use that.  We hash the non default homedir to keep the new\n   * subdir short enough.  */\n  if (non_default_homedir)\n    {\n      char sha1buf[20];\n      char *suffix;\n\n      *r_info |= 32; /* Testing subdir.  */\n      s = gnupg_homedir ();\n      gcry_md_hash_buffer (GCRY_MD_SHA1, sha1buf, s, strlen (s));\n      suffix = zb32_encode (sha1buf, 8*15);\n      if (!suffix)\n        {\n          *r_info |= 1; /* Out of core etc. */\n          goto leave;\n        }\n      name = strconcat (prefix, \"/d.\", suffix, NULL);\n      xfree (suffix);\n      if (!name)\n        {\n          *r_info |= 1; /* Out of core etc. */\n          goto leave;\n        }\n\n      /* Stat that directory and check constraints.\n       * The command\n       *    gpgconf --remove-socketdir\n       * can be used to remove that directory.  */\n      if (stat (name, &sb))\n        {\n          if (errno != ENOENT)\n            *r_info |= 1; /* stat failed. */\n          else if (!skip_checks)\n            {\n              /* Try to create the directory and check again.  */\n              if (gnupg_mkdir (name, \"-rwx\"))\n                *r_info |= 16; /* mkdir failed.  */\n              else if (stat (prefix, &sb))\n                {\n                  if (errno != ENOENT)\n                    *r_info |= 1; /* stat failed. */\n                  else\n                    *r_info |= 64; /* Subdir does not exist.  */\n                }\n              else\n                goto leave; /* Success!  */\n            }\n          else\n            *r_info |= 64; /* Subdir does not exist.  */\n          if (!skip_checks)\n            {\n              xfree (name);\n              name = NULL;\n              goto leave;\n            }\n        }\n      else if (!S_ISDIR(sb.st_mode)\n               || sb.st_uid != getuid ()\n               || (sb.st_mode & (S_IRWXG|S_IRWXO)))\n        {\n          *r_info |= 8; /* Bad permissions or subdir is not a directory.  */\n          if (!skip_checks)\n            {\n              xfree (name);\n              name = NULL;\n              goto leave;\n            }\n        }\n    }\n  else\n    name = xstrdup (prefix);\n\n leave:\n  /* If nothing works fall back to the homedir.  */\n  if (!name)\n    {\n      *r_info |= 128; /* Fallback.  */\n      name = xstrdup (gnupg_homedir ());\n    }\n\n#endif /* Unix */\n\n  return name;\n}\n\n\n/*\n * Return the name of the socket dir.  That is the directory used for\n * the IPC local sockets.  This is an absolute directory name.\n */\nconst char *\ngnupg_socketdir (void)\n{\n  static char *name;\n\n  if (!name)\n    {\n      unsigned int dummy;\n      name = _gnupg_socketdir_internal (0, &dummy);\n    }\n\n  return name;\n}\n\n\n/* Return the name of the sysconfdir.  This is a static string.  This\n   function is required because under Windows we can't simply compile\n   it in.  */\nconst char *\ngnupg_sysconfdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    {\n      const char *s1, *s2;\n      s1 = w32_commondir ();\n      s2 = DIRSEP_S \"etc\" DIRSEP_S \"gnupg\";\n      name = xmalloc (strlen (s1) + strlen (s2) + 1);\n      strcpy (stpcpy (name, s1), s2);\n    }\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_SYSCONFDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\nconst char *\ngnupg_bindir (void)\n{\n#if defined (HAVE_W32CE_SYSTEM)\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"bin\", NULL);\n  return name;\n#elif defined(HAVE_W32_SYSTEM)\n  const char *rdir;\n\n  rdir = w32_rootdir ();\n  if (w32_bin_is_bin)\n    {\n      static char *name;\n\n      if (!name)\n        name = xstrconcat (rdir, DIRSEP_S \"bin\", NULL);\n      return name;\n    }\n  else\n    return rdir;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_BINDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the name of the libexec directory.  The name is allocated in\n   a static area on the first use.  This function won't fail. */\nconst char *\ngnupg_libexecdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  return gnupg_bindir ();\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LIBEXECDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\nconst char *\ngnupg_libdir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"lib\" DIRSEP_S \"gnupg\", NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LIBDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\nconst char *\ngnupg_datadir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"share\" DIRSEP_S \"gnupg\", NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_DATADIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\nconst char *\ngnupg_localedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static char *name;\n\n  if (!name)\n    name = xstrconcat (w32_rootdir (), DIRSEP_S \"share\" DIRSEP_S \"locale\",\n                       NULL);\n  return name;\n#else /*!HAVE_W32_SYSTEM*/\n  return LOCALEDIR;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the name of the cache directory.  The name is allocated in a\n   static area on the first use.  Windows only: If the directory does\n   not exist it is created.  */\nconst char *\ngnupg_cachedir (void)\n{\n#ifdef HAVE_W32_SYSTEM\n  static const char *dir;\n\n  if (!dir)\n    {\n      const char *rdir;\n\n      rdir = w32_rootdir ();\n      if (w32_portable_app)\n        {\n          dir = xstrconcat (rdir,\n                            DIRSEP_S, \"var\",\n                            DIRSEP_S, \"cache\",\n                            DIRSEP_S, \"gnupg\", NULL);\n        }\n      else\n        {\n          char path[MAX_PATH];\n          const char *s1[] = { \"GNU\", \"cache\", \"gnupg\", NULL };\n          int s1_len;\n          const char **comp;\n\n          s1_len = 0;\n          for (comp = s1; *comp; comp++)\n            s1_len += 1 + strlen (*comp);\n\n          if (w32_shgetfolderpath (NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE,\n                                   NULL, 0, path) >= 0)\n            {\n              char *tmp = xmalloc (strlen (path) + s1_len + 1);\n              char *p;\n\n              p = stpcpy (tmp, path);\n              for (comp = s1; *comp; comp++)\n                {\n                  p = stpcpy (p, \"\\\\\");\n                  p = stpcpy (p, *comp);\n\n                  if (access (tmp, F_OK))\n                    w32_try_mkdir (tmp);\n                }\n\n              dir = tmp;\n            }\n          else\n            {\n              dir = \"c:\\\\temp\\\\cache\\\\gnupg\";\n#ifdef HAVE_W32CE_SYSTEM\n              dir += 2;\n              w32_try_mkdir (\"\\\\temp\\\\cache\");\n              w32_try_mkdir (\"\\\\temp\\\\cache\\\\gnupg\");\n#endif\n            }\n        }\n    }\n  return dir;\n#else /*!HAVE_W32_SYSTEM*/\n  return GNUPG_LOCALSTATEDIR \"/cache/\" PACKAGE_NAME;\n#endif /*!HAVE_W32_SYSTEM*/\n}\n\n\n/* Return the user socket name used by DirMngr.  */\nconst char *\ndirmngr_socket_name (void)\n{\n  static char *name;\n\n  if (!name)\n    name = make_filename (gnupg_socketdir (), DIRMNGR_SOCK_NAME, NULL);\n  return name;\n}\n\n\n/* Return the default pinentry name.  If RESET is true the internal\n   cache is first flushed.  */\nstatic const char *\nget_default_pinentry_name (int reset)\n{\n  static struct {\n    const char *(*rfnc)(void);\n    const char *name;\n  } names[] = {\n    /* The first entry is what we return in case we found no\n       other pinentry.  */\n    { gnupg_bindir, DIRSEP_S \"pinentry\" EXEEXT_S },\n#ifdef HAVE_W32_SYSTEM\n    /* Try Gpg4win directory (with bin and without.) */\n    { w32_rootdir, \"\\\\..\\\\Gpg4win\\\\bin\\\\pinentry.exe\" },\n    { w32_rootdir, \"\\\\..\\\\Gpg4win\\\\pinentry.exe\" },\n    /* Try old Gpgwin directory.  */\n    { w32_rootdir, \"\\\\..\\\\GNU\\\\GnuPG\\\\pinentry.exe\" },\n    /* Try a Pinentry from the common GNU dir.  */\n    { w32_rootdir, \"\\\\..\\\\GNU\\\\bin\\\\pinentry.exe\" },\n#endif\n    /* Last chance is a pinentry-basic (which comes with the\n       GnuPG 2.1 Windows installer).  */\n    { gnupg_bindir, DIRSEP_S \"pinentry-basic\" EXEEXT_S }\n  };\n  static char *name;\n\n  if (reset)\n    {\n      xfree (name);\n      name = NULL;\n    }\n\n  if (!name)\n    {\n      int i;\n\n      for (i=0; i < DIM(names); i++)\n        {\n          char *name2;\n\n          name2 = xstrconcat (names[i].rfnc (), names[i].name, NULL);\n          if (!access (name2, F_OK))\n            {\n              /* Use that pinentry.  */\n              xfree (name);\n              name = name2;\n              break;\n            }\n          if (!i) /* Store the first as fallback return.  */\n            name = name2;\n          else\n            xfree (name2);\n        }\n    }\n\n  return name;\n}\n\n\n/* If set, 'gnupg_module_name' returns modules from that build\n * directory.  */\nstatic char *gnupg_build_directory;\n\n/* For sanity checks.  */\nstatic int gnupg_module_name_called;\n\n\n/* Set NEWDIR as the new build directory.  This will make\n * 'gnupg_module_name' return modules from that build directory.  Must\n * be called before any invocation of 'gnupg_module_name', and must\n * not be called twice.  It can be used by test suites to make sure\n * the components from the build directory are used instead of\n * potentially outdated installed ones.  */\nvoid\ngnupg_set_builddir (const char *newdir)\n{\n  log_assert (! gnupg_module_name_called);\n  log_assert (! gnupg_build_directory);\n  gnupg_build_directory = xtrystrdup (newdir);\n}\n\n\n/* If no build directory has been configured, try to set it from the\n * environment.  We only do this in development builds to avoid\n * increasing the set of influential environment variables and hence\n * the attack surface of production builds.  */\nstatic void\ngnupg_set_builddir_from_env (void)\n{\n#if defined(IS_DEVELOPMENT_VERSION) || defined(ENABLE_GNUPG_BUILDDIR_ENVVAR)\n  if (gnupg_build_directory)\n    return;\n\n  gnupg_build_directory = getenv (\"GNUPG_BUILDDIR\");\n#endif\n}\n\n\n/* Return the file name of a helper tool.  WHICH is one of the\n   GNUPG_MODULE_NAME_foo constants.  */\nconst char *\ngnupg_module_name (int which)\n{\n  gnupg_set_builddir_from_env ();\n  gnupg_module_name_called = 1;\n\n#define X(a,b,c) do {                                                   \\\n    static char *name;                                                  \\\n    if (!name)                                                          \\\n      name = gnupg_build_directory                                      \\\n        ? xstrconcat (gnupg_build_directory,                            \\\n                      DIRSEP_S b DIRSEP_S c EXEEXT_S, NULL)             \\\n        : xstrconcat (gnupg_ ## a (), DIRSEP_S c EXEEXT_S, NULL);       \\\n    return name;                                                        \\\n  } while (0)\n\n  switch (which)\n    {\n    case GNUPG_MODULE_NAME_AGENT:\n#ifdef GNUPG_DEFAULT_AGENT\n      return GNUPG_DEFAULT_AGENT;\n#else\n      X(bindir, \"agent\", \"gpg-agent\");\n#endif\n\n    case GNUPG_MODULE_NAME_PINENTRY:\n#ifdef GNUPG_DEFAULT_PINENTRY\n      return GNUPG_DEFAULT_PINENTRY;  /* (Set by a configure option) */\n#else\n      return get_default_pinentry_name (0);\n#endif\n\n    case GNUPG_MODULE_NAME_SCDAEMON:\n#ifdef GNUPG_DEFAULT_SCDAEMON\n      return GNUPG_DEFAULT_SCDAEMON;\n#else\n      X(libexecdir, \"scd\", \"scdaemon\");\n#endif\n\n    case GNUPG_MODULE_NAME_DIRMNGR:\n#ifdef GNUPG_DEFAULT_DIRMNGR\n      return GNUPG_DEFAULT_DIRMNGR;\n#else\n      X(bindir, \"dirmngr\", DIRMNGR_NAME);\n#endif\n\n    case GNUPG_MODULE_NAME_PROTECT_TOOL:\n#ifdef GNUPG_DEFAULT_PROTECT_TOOL\n      return GNUPG_DEFAULT_PROTECT_TOOL;\n#else\n      X(libexecdir, \"agent\", \"gpg-protect-tool\");\n#endif\n\n    case GNUPG_MODULE_NAME_DIRMNGR_LDAP:\n#ifdef GNUPG_DEFAULT_DIRMNGR_LDAP\n      return GNUPG_DEFAULT_DIRMNGR_LDAP;\n#else\n      X(libexecdir, \"dirmngr\", \"dirmngr_ldap\");\n#endif\n\n    case GNUPG_MODULE_NAME_CHECK_PATTERN:\n      X(libexecdir, \"tools\", \"gpg-check-pattern\");\n\n    case GNUPG_MODULE_NAME_GPGSM:\n      X(bindir, \"sm\", \"gpgsm\");\n\n    case GNUPG_MODULE_NAME_GPG:\n#if USE_GPG2_HACK\n      if (! gnupg_build_directory)\n        X(bindir, \"g10\", GPG_NAME \"2\");\n      else\n#endif\n        X(bindir, \"g10\", GPG_NAME);\n\n    case GNUPG_MODULE_NAME_GPGV:\n#if USE_GPG2_HACK\n      if (! gnupg_build_directory)\n        X(bindir, \"g10\", GPG_NAME \"v2\");\n      else\n#endif\n        X(bindir, \"g10\", GPG_NAME \"v\");\n\n    case GNUPG_MODULE_NAME_CONNECT_AGENT:\n      X(bindir, \"tools\", \"gpg-connect-agent\");\n\n    case GNUPG_MODULE_NAME_GPGCONF:\n      X(bindir, \"tools\", \"gpgconf\");\n\n    default:\n      BUG ();\n    }\n#undef X\n}\n\n\n/* Flush some of the cached module names.  This is for example used by\n   gpg-agent to allow configuring a different pinentry.  */\nvoid\ngnupg_module_name_flush_some (void)\n{\n  (void)get_default_pinentry_name (1);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/utf8conv.c": "/* utf8conf.c -  UTF8 character set conversion\n * Copyright (C) 1994, 1998, 1999, 2000, 2001, 2003, 2006,\n *               2008, 2010  Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute and/or modify this\n * part of GnuPG under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * GnuPG is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copies of the GNU General Public License\n * and the GNU Lesser General Public License along with this program;\n * if not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <ctype.h>\n#ifdef HAVE_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n#include <errno.h>\n\n#if HAVE_W32_SYSTEM\n# /* Tell libgpg-error to provide the iconv macros.  */\n# define GPGRT_ENABLE_W32_ICONV_MACROS 1\n#elif HAVE_ANDROID_SYSTEM\n# /* No iconv support.  */\n#else\n# include <iconv.h>\n#endif\n\n\n#include \"util.h\"\n#include \"common-defs.h\"\n#include \"i18n.h\"\n#include \"stringhelp.h\"\n#include \"utf8conv.h\"\n\n#ifndef MB_LEN_MAX\n#define MB_LEN_MAX 16\n#endif\n\nstatic const char *active_charset_name = \"iso-8859-1\";\nstatic int no_translation;     /* Set to true if we let simply pass through. */\nstatic int use_iconv;          /* iconv conversion functions required. */\n\n\n#ifdef HAVE_ANDROID_SYSTEM\n/* Fake stuff to get things building.  */\ntypedef void *iconv_t;\n#define ICONV_CONST\n\nstatic iconv_t\niconv_open (const char *tocode, const char *fromcode)\n{\n  (void)tocode;\n  (void)fromcode;\n  return (iconv_t)(-1);\n}\n\nstatic size_t\niconv (iconv_t cd, char **inbuf, size_t *inbytesleft,\n       char **outbuf, size_t *outbytesleft)\n{\n  (void)cd;\n  (void)inbuf;\n  (void)inbytesleft;\n  (void)outbuf;\n  (void)outbytesleft;\n  return (size_t)(0);\n}\n\nstatic int\niconv_close (iconv_t cd)\n{\n  (void)cd;\n  return 0;\n}\n#endif /*HAVE_ANDROID_SYSTEM*/\n\n\n/* Error handler for iconv failures. This is needed to not clutter the\n   output with repeated diagnostics about a missing conversion. */\nstatic void\nhandle_iconv_error (const char *to, const char *from, int use_fallback)\n{\n  if (errno == EINVAL)\n    {\n      static int shown1, shown2;\n      int x;\n\n      if (to && !strcmp (to, \"utf-8\"))\n        {\n          x = shown1;\n          shown1 = 1;\n        }\n      else\n        {\n          x = shown2;\n          shown2 = 1;\n        }\n\n      if (!x)\n        log_info (_(\"conversion from '%s' to '%s' not available\\n\"),\n                  from, to);\n    }\n  else\n    {\n      static int shown;\n\n      if (!shown)\n        log_info (_(\"iconv_open failed: %s\\n\"), strerror (errno));\n      shown = 1;\n    }\n\n  if (use_fallback)\n    {\n      /* To avoid further error messages we fallback to UTF-8 for the\n         native encoding.  Nowadays this seems to be the best bet in\n         case of errors from iconv or nl_langinfo.  */\n      active_charset_name = \"utf-8\";\n      no_translation = 0;\n      use_iconv = 0;\n    }\n}\n\n\n\nint\nset_native_charset (const char *newset)\n{\n  const char *full_newset;\n\n  if (!newset)\n    {\n#ifdef HAVE_ANDROID_SYSTEM\n      newset = \"utf-8\";\n#elif defined HAVE_W32_SYSTEM\n      static char codepage[30];\n      unsigned int cpno;\n      const char *aliases;\n\n      /* We are a console program thus we need to use the\n         GetConsoleOutputCP function and not the GetACP which\n         would give the codepage for a GUI program.  Note this is not\n         a bulletproof detection because GetConsoleCP might return a\n         different one for console input.  Not sure how to cope with\n         that.  If the console Code page is not known we fall back to\n         the system code page.  */\n#ifndef HAVE_W32CE_SYSTEM\n      cpno = GetConsoleOutputCP ();\n      if (!cpno)\n#endif\n        cpno = GetACP ();\n      sprintf (codepage, \"CP%u\", cpno );\n      /* Resolve alias.  We use a long string string and not the usual\n         array to optimize if the code is taken to a DSO.  Taken from\n         libiconv 1.9.2. */\n      newset = codepage;\n      for (aliases = (\"CP936\"   \"\\0\" \"GBK\" \"\\0\"\n                      \"CP1361\"  \"\\0\" \"JOHAB\" \"\\0\"\n                      \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n                      \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n                      \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n                      \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n                      \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n                      \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n                      \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n                      \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n                      \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n                      \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n                      \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n                      \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n                      \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n                      \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\");\n           *aliases;\n           aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n        {\n          if (!strcmp (codepage, aliases) ||(*aliases == '*' && !aliases[1]))\n            {\n              newset = aliases + strlen (aliases) + 1;\n              break;\n            }\n        }\n\n#else /*!HAVE_W32_SYSTEM && !HAVE_ANDROID_SYSTEM*/\n\n#ifdef HAVE_LANGINFO_CODESET\n      newset = nl_langinfo (CODESET);\n#else /*!HAVE_LANGINFO_CODESET*/\n      /* Try to get the used charset from environment variables.  */\n      static char codepage[30];\n      const char *lc, *dot, *mod;\n\n      strcpy (codepage, \"iso-8859-1\");\n      lc = getenv (\"LC_ALL\");\n      if (!lc || !*lc)\n        {\n          lc = getenv (\"LC_CTYPE\");\n          if (!lc || !*lc)\n            lc = getenv (\"LANG\");\n        }\n      if (lc && *lc)\n        {\n          dot = strchr (lc, '.');\n          if (dot)\n            {\n              mod = strchr (++dot, '@');\n              if (!mod)\n                mod = dot + strlen (dot);\n              if (mod - dot < sizeof codepage && dot != mod)\n                {\n                  memcpy (codepage, dot, mod - dot);\n                  codepage [mod - dot] = 0;\n                }\n            }\n        }\n      newset = codepage;\n#endif /*!HAVE_LANGINFO_CODESET*/\n#endif /*!HAVE_W32_SYSTEM && !HAVE_ANDROID_SYSTEM*/\n    }\n\n  full_newset = newset;\n  if (strlen (newset) > 3 && !ascii_memcasecmp (newset, \"iso\", 3))\n    {\n      newset += 3;\n      if (*newset == '-' || *newset == '_')\n        newset++;\n    }\n\n  /* Note that we silently assume that plain ASCII is actually meant\n     as Latin-1.  This makes sense because many Unix system don't have\n     their locale set up properly and thus would get annoying error\n     messages and we have to handle all the \"bug\" reports. Latin-1 has\n     traditionally been the character set used for 8 bit characters on\n     Unix systems. */\n  if ( !*newset\n       || !ascii_strcasecmp (newset, \"8859-1\" )\n       || !ascii_strcasecmp (newset, \"646\" )\n       || !ascii_strcasecmp (newset, \"ASCII\" )\n       || !ascii_strcasecmp (newset, \"ANSI_X3.4-1968\" )\n       )\n    {\n      active_charset_name = \"iso-8859-1\";\n      no_translation = 0;\n      use_iconv = 0;\n    }\n  else if ( !ascii_strcasecmp (newset, \"utf8\" )\n            || !ascii_strcasecmp(newset, \"utf-8\") )\n    {\n      active_charset_name = \"utf-8\";\n      no_translation = 1;\n      use_iconv = 0;\n    }\n  else\n    {\n      iconv_t cd;\n\n      cd = iconv_open (full_newset, \"utf-8\");\n      if (cd == (iconv_t)-1)\n        {\n          handle_iconv_error (full_newset, \"utf-8\", 0);\n          return -1;\n        }\n      iconv_close (cd);\n      cd = iconv_open (\"utf-8\", full_newset);\n      if (cd == (iconv_t)-1)\n        {\n          handle_iconv_error (\"utf-8\", full_newset, 0);\n          return -1;\n        }\n      iconv_close (cd);\n      active_charset_name = full_newset;\n      no_translation = 0;\n      use_iconv = 1;\n    }\n  return 0;\n}\n\nconst char *\nget_native_charset ()\n{\n  return active_charset_name;\n}\n\n/* Return true if the native charset is utf-8.  */\nint\nis_native_utf8 (void)\n{\n  return no_translation;\n}\n\n\n/* Convert string, which is in native encoding to UTF8 and return a\n   new allocated UTF-8 string.  This function terminates the process\n   on memory shortage.  */\nchar *\nnative_to_utf8 (const char *orig_string)\n{\n  const unsigned char *string = (const unsigned char *)orig_string;\n  const unsigned char *s;\n  char *buffer;\n  unsigned char *p;\n  size_t length = 0;\n\n  if (no_translation)\n    {\n      /* Already utf-8 encoded. */\n      buffer = xstrdup (orig_string);\n    }\n  else if (!use_iconv)\n    {\n      /* For Latin-1 we can avoid the iconv overhead. */\n      for (s = string; *s; s++)\n\t{\n\t  length++;\n\t  if (*s & 0x80)\n\t    length++;\n\t}\n      buffer = xmalloc (length + 1);\n      for (p = (unsigned char *)buffer, s = string; *s; s++)\n\t{\n\t  if ( (*s & 0x80 ))\n\t    {\n\t      *p++ = 0xc0 | ((*s >> 6) & 3);\n\t      *p++ = 0x80 | (*s & 0x3f);\n\t    }\n\t  else\n\t    *p++ = *s;\n\t}\n      *p = 0;\n    }\n  else\n    {\n      /* Need to use iconv.  */\n      iconv_t cd;\n      const char *inptr;\n      char *outptr;\n      size_t inbytes, outbytes;\n\n      cd = iconv_open (\"utf-8\", active_charset_name);\n      if (cd == (iconv_t)-1)\n        {\n          handle_iconv_error (\"utf-8\", active_charset_name, 1);\n          return native_to_utf8 (string);\n        }\n\n      for (s=string; *s; s++ )\n        {\n          length++;\n          if ((*s & 0x80))\n            length += 5; /* We may need up to 6 bytes for the utf8 output. */\n        }\n      buffer = xmalloc (length + 1);\n\n      inptr = string;\n      inbytes = strlen (string);\n      outptr = buffer;\n      outbytes = length;\n      if ( iconv (cd, (ICONV_CONST char **)&inptr, &inbytes,\n                  &outptr, &outbytes) == (size_t)-1)\n        {\n          static int shown;\n\n          if (!shown)\n            log_info (_(\"conversion from '%s' to '%s' failed: %s\\n\"),\n                      active_charset_name, \"utf-8\", strerror (errno));\n          shown = 1;\n          /* We don't do any conversion at all but use the strings as is. */\n          strcpy (buffer, string);\n        }\n      else /* Success.  */\n        {\n          *outptr = 0;\n          /* We could realloc the buffer now but I doubt that it makes\n             much sense given that it will get freed anyway soon\n             after.  */\n        }\n      iconv_close (cd);\n    }\n  return buffer;\n}\n\n\n\nstatic char *\ndo_utf8_to_native (const char *string, size_t length, int delim,\n                   int with_iconv)\n{\n  int nleft;\n  int i;\n  unsigned char encbuf[8];\n  int encidx;\n  const unsigned char *s;\n  size_t n;\n  char *buffer = NULL;\n  char *p = NULL;\n  unsigned long val = 0;\n  size_t slen;\n  int resync = 0;\n\n  /* First pass (p==NULL): count the extended utf-8 characters.  */\n  /* Second pass (p!=NULL): create string.  */\n  for (;;)\n    {\n      for (slen = length, nleft = encidx = 0, n = 0,\n             s = (const unsigned char *)string;\n           slen;\n\t   s++, slen--)\n\t{\n\t  if (resync)\n\t    {\n\t      if (!(*s < 128 || (*s >= 0xc0 && *s <= 0xfd)))\n\t\t{\n\t\t  /* Still invalid. */\n\t\t  if (p)\n\t\t    {\n\t\t      sprintf (p, \"\\\\x%02x\", *s);\n\t\t      p += 4;\n\t\t    }\n\t\t  n += 4;\n\t\t  continue;\n\t\t}\n\t      resync = 0;\n\t    }\n\t  if (!nleft)\n\t    {\n\t      if (!(*s & 0x80))\n\t\t{\n                  /* Plain ascii. */\n\t\t  if ( delim != -1\n                       && (*s < 0x20 || *s == 0x7f || *s == delim\n                           || (delim && *s == '\\\\')))\n\t\t    {\n\t\t      n++;\n\t\t      if (p)\n\t\t\t*p++ = '\\\\';\n\t\t      switch (*s)\n\t\t\t{\n                        case '\\n': n++; if ( p ) *p++ = 'n'; break;\n                        case '\\r': n++; if ( p ) *p++ = 'r'; break;\n                        case '\\f': n++; if ( p ) *p++ = 'f'; break;\n                        case '\\v': n++; if ( p ) *p++ = 'v'; break;\n                        case '\\b': n++; if ( p ) *p++ = 'b'; break;\n                        case    0: n++; if ( p ) *p++ = '0'; break;\n\t\t\tdefault:\n\t\t\t  n += 3;\n\t\t\t  if (p)\n\t\t\t    {\n\t\t\t      sprintf (p, \"x%02x\", *s);\n\t\t\t      p += 3;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (p)\n\t\t\t*p++ = *s;\n\t\t      n++;\n\t\t    }\n\t\t}\n\t      else if ((*s & 0xe0) == 0xc0) /* 110x xxxx */\n\t\t{\n\t\t  val = *s & 0x1f;\n\t\t  nleft = 1;\n\t\t  encidx = 0;\n\t\t  encbuf[encidx++] = *s;\n\t\t}\n\t      else if ((*s & 0xf0) == 0xe0) /* 1110 xxxx */\n\t\t{\n\t\t  val = *s & 0x0f;\n\t\t  nleft = 2;\n\t\t  encidx = 0;\n\t\t  encbuf[encidx++] = *s;\n\t\t}\n\t      else if ((*s & 0xf8) == 0xf0) /* 1111 0xxx */\n\t\t{\n\t\t  val = *s & 0x07;\n\t\t  nleft = 3;\n\t\t  encidx = 0;\n\t\t  encbuf[encidx++] = *s;\n\t\t}\n\t      else if ((*s & 0xfc) == 0xf8) /* 1111 10xx */\n\t\t{\n\t\t  val = *s & 0x03;\n\t\t  nleft = 4;\n\t\t  encidx = 0;\n\t\t  encbuf[encidx++] = *s;\n\t\t}\n\t      else if ((*s & 0xfe) == 0xfc) /* 1111 110x */\n\t\t{\n\t\t  val = *s & 0x01;\n\t\t  nleft = 5;\n\t\t  encidx = 0;\n\t\t  encbuf[encidx++] = *s;\n\t\t}\n\t      else /* Invalid encoding: print as \\xNN. */\n\t\t{\n\t\t  if (p)\n\t\t    {\n\t\t      sprintf (p, \"\\\\x%02x\", *s);\n\t\t      p += 4;\n\t\t    }\n\t\t  n += 4;\n\t\t  resync = 1;\n\t\t}\n\t    }\n\t  else if (*s < 0x80 || *s >= 0xc0) /* Invalid utf-8 */\n\t    {\n\t      if (p)\n\t\t{\n\t\t  for (i = 0; i < encidx; i++)\n\t\t    {\n\t\t      sprintf (p, \"\\\\x%02x\", encbuf[i]);\n\t\t      p += 4;\n\t\t    }\n\t\t  sprintf (p, \"\\\\x%02x\", *s);\n\t\t  p += 4;\n\t\t}\n\t      n += 4 + 4 * encidx;\n\t      nleft = 0;\n\t      encidx = 0;\n\t      resync = 1;\n\t    }\n\t  else\n\t    {\n\t      encbuf[encidx++] = *s;\n\t      val <<= 6;\n\t      val |= *s & 0x3f;\n\t      if (!--nleft)  /* Ready. */\n\t\t{\n\t\t  if (no_translation)\n\t\t    {\n\t\t      if (p)\n\t\t\t{\n\t\t\t  for (i = 0; i < encidx; i++)\n\t\t\t    *p++ = encbuf[i];\n\t\t\t}\n\t\t      n += encidx;\n\t\t      encidx = 0;\n\t\t    }\n                  else if (with_iconv)\n                    {\n                      /* Our strategy for using iconv is a bit strange\n                         but it better keeps compatibility with\n                         previous versions in regard to how invalid\n                         encodings are displayed.  What we do is to\n                         keep the utf-8 as is and have the real\n                         translation step then at the end.  Yes, I\n                         know that this is ugly.  However we are short\n                         of the 1.4 release and for this branch we\n                         should not mess too much around with iconv\n                         things.  One reason for this is that we don't\n                         know enough about non-GNU iconv\n                         implementation and want to minimize the risk\n                         of breaking the code on too many platforms.  */\n                        if ( p )\n                          {\n                            for (i=0; i < encidx; i++ )\n                              *p++ = encbuf[i];\n                          }\n                        n += encidx;\n                        encidx = 0;\n                    }\n\t\t  else \t/* Latin-1 case. */\n                    {\n\t\t      if (val >= 0x80 && val < 256)\n\t\t\t{\n                          /* We can simply print this character */\n\t\t\t  n++;\n\t\t\t  if (p)\n\t\t\t    *p++ = val;\n\t\t\t}\n\t\t      else\n\t\t\t{\n                          /* We do not have a translation: print utf8. */\n\t\t\t  if (p)\n\t\t\t    {\n\t\t\t      for (i = 0; i < encidx; i++)\n\t\t\t\t{\n\t\t\t\t  sprintf (p, \"\\\\x%02x\", encbuf[i]);\n\t\t\t\t  p += 4;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  n += encidx * 4;\n\t\t\t  encidx = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t    }\n\t}\n      if (!buffer)\n\t{\n          /* Allocate the buffer after the first pass. */\n\t  buffer = p = xmalloc (n + 1);\n\t}\n      else if (with_iconv)\n        {\n          /* Note: See above for comments.  */\n          iconv_t cd;\n          const char *inptr;\n          char *outbuf, *outptr;\n          size_t inbytes, outbytes;\n\n          *p = 0;  /* Terminate the buffer. */\n\n          cd = iconv_open (active_charset_name, \"utf-8\");\n          if (cd == (iconv_t)-1)\n            {\n              handle_iconv_error (active_charset_name, \"utf-8\", 1);\n              xfree (buffer);\n              return utf8_to_native (string, length, delim);\n            }\n\n          /* Allocate a new buffer large enough to hold all possible\n             encodings. */\n          n = p - buffer + 1;\n          inbytes = n - 1;;\n          inptr = buffer;\n          outbytes = n * MB_LEN_MAX;\n          if (outbytes / MB_LEN_MAX != n)\n            BUG (); /* Actually an overflow. */\n          outbuf = outptr = xmalloc (outbytes);\n          if ( iconv (cd, (ICONV_CONST char **)&inptr, &inbytes,\n                      &outptr, &outbytes) == (size_t)-1)\n            {\n              static int shown;\n\n              if (!shown)\n                log_info (_(\"conversion from '%s' to '%s' failed: %s\\n\"),\n                          \"utf-8\", active_charset_name, strerror (errno));\n              shown = 1;\n              /* Didn't worked out.  Try again but without iconv.  */\n              xfree (buffer);\n              buffer = NULL;\n              xfree (outbuf);\n              outbuf = do_utf8_to_native (string, length, delim, 0);\n            }\n            else /* Success.  */\n              {\n                *outptr = 0; /* Make sure it is a string. */\n                /* We could realloc the buffer now but I doubt that it\n                   makes much sense given that it will get freed\n                   anyway soon after.  */\n                xfree (buffer);\n              }\n          iconv_close (cd);\n          return outbuf;\n        }\n      else /* Not using iconv. */\n\t{\n\t  *p = 0; /* Make sure it is a string. */\n\t  return buffer;\n\t}\n    }\n}\n\n/* Convert string, which is in UTF-8 to native encoding.  Replace\n   illegal encodings by some \"\\xnn\" and quote all control\n   characters. A character with value DELIM will always be quoted, it\n   must be a vanilla ASCII character.  A DELIM value of -1 is special:\n   it disables all quoting of control characters.  This function\n   terminates the process on memory shortage.  */\nchar *\nutf8_to_native (const char *string, size_t length, int delim)\n{\n  return do_utf8_to_native (string, length, delim, use_iconv);\n}\n\n\n\n\n/* Wrapper function for iconv_open, required for W32 as we dlopen that\n   library on that system.  */\njnlib_iconv_t\njnlib_iconv_open (const char *tocode, const char *fromcode)\n{\n  return (jnlib_iconv_t)iconv_open (tocode, fromcode);\n}\n\n\n/* Wrapper function for iconv, required for W32 as we dlopen that\n   library on that system.  */\nsize_t\njnlib_iconv (jnlib_iconv_t cd,\n             const char **inbuf, size_t *inbytesleft,\n             char **outbuf, size_t *outbytesleft)\n{\n  return iconv ((iconv_t)cd, (ICONV_CONST char**)inbuf, inbytesleft,\n                outbuf, outbytesleft);\n}\n\n/* Wrapper function for iconv_close, required for W32 as we dlopen that\n   library on that system.  */\nint\njnlib_iconv_close (jnlib_iconv_t cd)\n{\n  return iconv_close ((iconv_t)cd);\n}\n\n\n#ifdef HAVE_W32_SYSTEM\n/* Return a malloced string encoded for CODEPAGE from the wide char input\n   string STRING.  Caller must free this value.  Returns NULL and sets\n   ERRNO on failure.  Calling this function with STRING set to NULL is\n   not defined.  */\nstatic char *\nwchar_to_cp (const wchar_t *string, unsigned int codepage)\n{\n  int n;\n  char *result;\n\n  n = WideCharToMultiByte (codepage, 0, string, -1, NULL, 0, NULL, NULL);\n  if (n < 0)\n    {\n      gpg_err_set_errno (EINVAL);\n      return NULL;\n    }\n\n  result = xtrymalloc (n+1);\n  if (!result)\n    return NULL;\n\n  n = WideCharToMultiByte (codepage, 0, string, -1, result, n, NULL, NULL);\n  if (n < 0)\n    {\n      xfree (result);\n      gpg_err_set_errno (EINVAL);\n      result = NULL;\n    }\n  return result;\n}\n\n\n/* Return a malloced wide char string from a CODEPAGE encoded input\n   string STRING.  Caller must free this value.  Returns NULL and sets\n   ERRNO on failure.  Calling this function with STRING set to NULL is\n   not defined.  */\nstatic wchar_t *\ncp_to_wchar (const char *string, unsigned int codepage)\n{\n  int n;\n  size_t nbytes;\n  wchar_t *result;\n\n  n = MultiByteToWideChar (codepage, 0, string, -1, NULL, 0);\n  if (n < 0)\n    {\n      gpg_err_set_errno (EINVAL);\n      return NULL;\n    }\n\n  nbytes = (size_t)(n+1) * sizeof(*result);\n  if (nbytes / sizeof(*result) != (n+1))\n    {\n      gpg_err_set_errno (ENOMEM);\n      return NULL;\n    }\n  result = xtrymalloc (nbytes);\n  if (!result)\n    return NULL;\n\n  n = MultiByteToWideChar (codepage, 0, string, -1, result, n);\n  if (n < 0)\n    {\n      xfree (result);\n      gpg_err_set_errno (EINVAL);\n      result = NULL;\n    }\n  return result;\n}\n\n\n/* Get the current codepage as used by wchar_to_native and\n * native_to_char.  Note that these functions intentionally do not use\n * iconv based conversion machinery.  */\nstatic unsigned int\nget_w32_codepage (void)\n{\n  static unsigned int cp;\n\n  if (!cp)\n    {\n#ifndef HAVE_W32CE_SYSTEM\n      cp = GetConsoleOutputCP ();\n      if (!cp)\n#endif\n        cp = GetACP ();\n    }\n  return cp;\n}\n\n/* Return a malloced string encoded in the active code page from the\n * wide char input string STRING.  Caller must free this value.\n * Returns NULL and sets ERRNO on failure.  Calling this function with\n * STRING set to NULL is not defined.  */\nchar *\nwchar_to_native (const wchar_t *string)\n{\n  return wchar_to_cp (string, get_w32_codepage ());\n}\n\n\n/* Return a malloced wide char string from native encoded input\n * string STRING.  Caller must free this value.  Returns NULL and sets\n * ERRNO on failure.  Calling this function with STRING set to NULL is\n * not defined.  */\nwchar_t *\nnative_to_wchar (const char *string)\n{\n  return cp_to_wchar (string, get_w32_codepage ());\n}\n\n\n/* Return a malloced string encoded in UTF-8 from the wide char input\n * string STRING.  Caller must free this value.  Returns NULL and sets\n * ERRNO on failure.  Calling this function with STRING set to NULL is\n * not defined.  */\nchar *\nwchar_to_utf8 (const wchar_t *string)\n{\n  return wchar_to_cp (string, CP_UTF8);\n}\n\n\n/* Return a malloced wide char string from an UTF-8 encoded input\n * string STRING.  Caller must free this value.  Returns NULL and sets\n * ERRNO on failure.  Calling this function with STRING set to NULL is\n * not defined.  */\nwchar_t *\nutf8_to_wchar (const char *string)\n{\n  return cp_to_wchar (string, CP_UTF8);\n}\n\n#endif /*HAVE_W32_SYSTEM*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/dynload.h": "/* dynload.h - Wrapper functions for run-time dynamic loading\n *      Copyright (C) 2003, 2010 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute and/or modify this\n * part of GnuPG under the terms of either\n *\n *   - the GNU Lesser General Public License as published by the Free\n *     Software Foundation; either version 3 of the License, or (at\n *     your option) any later version.\n *\n * or\n *\n *   - the GNU General Public License as published by the Free\n *     Software Foundation; either version 2 of the License, or (at\n *     your option) any later version.\n *\n * or both in parallel, as here.\n *\n * GnuPG is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copies of the GNU General Public License\n * and the GNU Lesser General Public License along with this program;\n * if not, see <https://www.gnu.org/licenses/>.\n */\n\n#ifndef GNUPG_COMMON_DYNLOAD_H\n#define GNUPG_COMMON_DYNLOAD_H\n\n#ifndef __MINGW32__\n# include <dlfcn.h>\n#else\n# include <windows.h>\n# include \"utf8conv.h\"\n# include \"mischelp.h\"\n# define RTLD_LAZY 0\n\nstatic inline void *\ndlopen (const char *name, int flag)\n{\n  void *hd;\n#ifdef HAVE_W32CE_SYSTEM\n  wchar_t *wname = utf8_to_wchar (name);\n  hd = wname? LoadLibrary (wname) : NULL;\n  xfree (wname);\n#else\n  hd = LoadLibrary (name);\n#endif\n  (void)flag;\n  return hd;\n}\n\nstatic inline void *\ndlsym (void *hd, const char *sym)\n{\n  if (hd && sym)\n    {\n#ifdef HAVE_W32CE_SYSTEM\n      wchar_t *wsym = utf8_to_wchar (sym);\n      void *fnc = wsym? GetProcAddress (hd, wsym) : NULL;\n      xfree (wsym);\n#else\n      void *fnc = GetProcAddress (hd, sym);\n#endif\n      if (!fnc)\n        return NULL;\n      return fnc;\n    }\n  return NULL;\n}\n\n\nstatic inline const char *\ndlerror (void)\n{\n  static char buf[32];\n  snprintf (buf, sizeof buf, \"ec=%lu\", GetLastError ());\n  return buf;\n}\n\n\nstatic inline int\ndlclose (void * hd)\n{\n  if (hd)\n    {\n      CloseHandle (hd);\n      return 0;\n    }\n  return -1;\n}\n# endif /*__MINGW32__*/\n#endif /*GNUPG_COMMON_DYNLOAD_H*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/m4/lib-link.m4": "# lib-link.m4 serial 13 (gettext-0.17)\ndnl Copyright (C) 2001-2007 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ(2.54)\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n    ac_cv_lib[]Name[]_prefix=\"$LIB[]NAME[]_PREFIX\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  LIB[]NAME[]_PREFIX=\"$ac_cv_lib[]Name[]_prefix\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. If found, it\ndnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and\ndnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $LIB[]NAME\"\n    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n    LIB[]NAME[]_PREFIX=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl   acl_libext,\ndnl   acl_shlibext,\ndnl   acl_hardcode_libdir_flag_spec,\ndnl   acl_hardcode_libdir_separator,\ndnl   acl_hardcode_direct,\ndnl   acl_hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  acl_libext=\"$acl_cv_libext\"\n  acl_shlibext=\"$acl_cv_shlibext\"\n  acl_libname_spec=\"$acl_cv_libname_spec\"\n  acl_library_names_spec=\"$acl_cv_library_names_spec\"\n  acl_hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  acl_hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  acl_hardcode_direct=\"$acl_cv_hardcode_direct\"\n  acl_hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE(rpath,\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\ndnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found\ndnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  dnl Autoconf >= 2.61 supports dots in --with options.\n  define([N_A_M_E],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit([$1],[.],[_])],[$1])])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib]N_A_M_E[-prefix],\n[  --with-lib]N_A_M_E[-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib\n  --without-lib]N_A_M_E[-prefix     don't search for lib$1 in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-search.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  LIB[]NAME[]_PREFIX=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          eval libname=\\\"$acl_libname_spec\\\"    # typically: libname=lib$name\n          if test -n \"$acl_shlibext\"; then\n            shrext=\".$acl_shlibext\"             # typically: shrext=.so\n          else\n            shrext=\n          fi\n          if test $use_additional = yes; then\n            dir=\"$additional_libdir\"\n            dnl The same code as in the loop below:\n            dnl First look for a shared library.\n            if test -n \"$acl_shlibext\"; then\n              if test -f \"$dir/$libname$shrext\"; then\n                found_dir=\"$dir\"\n                found_so=\"$dir/$libname$shrext\"\n              else\n                if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                  ver=`(cd \"$dir\" && \\\n                        for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                        | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                        | sed 1q ) 2>/dev/null`\n                  if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/$libname$shrext.$ver\"\n                  fi\n                else\n                  eval library_names=\\\"$acl_library_names_spec\\\"\n                  for f in $library_names; do\n                    if test -f \"$dir/$f\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$f\"\n                      break\n                    fi\n                  done\n                fi\n              fi\n            fi\n            dnl Then look for a static library.\n            if test \"X$found_dir\" = \"X\"; then\n              if test -f \"$dir/$libname.$acl_libext\"; then\n                found_dir=\"$dir\"\n                found_a=\"$dir/$libname.$acl_libext\"\n              fi\n            fi\n            if test \"X$found_dir\" != \"X\"; then\n              if test -f \"$dir/$libname.la\"; then\n                found_la=\"$dir/$libname.la\"\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  dnl First look for a shared library.\n                  if test -n \"$acl_shlibext\"; then\n                    if test -f \"$dir/$libname$shrext\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$libname$shrext\"\n                    else\n                      if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                        ver=`(cd \"$dir\" && \\\n                              for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                              | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                              | sed 1q ) 2>/dev/null`\n                        if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                          found_dir=\"$dir\"\n                          found_so=\"$dir/$libname$shrext.$ver\"\n                        fi\n                      else\n                        eval library_names=\\\"$acl_library_names_spec\\\"\n                        for f in $library_names; do\n                          if test -f \"$dir/$f\"; then\n                            found_dir=\"$dir\"\n                            found_so=\"$dir/$f\"\n                            break\n                          fi\n                        done\n                      fi\n                    fi\n                  fi\n                  dnl Then look for a static library.\n                  if test \"X$found_dir\" = \"X\"; then\n                    if test -f \"$dir/$libname.$acl_libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/$libname.$acl_libext\"\n                    fi\n                  fi\n                  if test \"X$found_dir\" != \"X\"; then\n                    if test -f \"$dir/$libname.la\"; then\n                      found_la=\"$dir/$libname.la\"\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$acl_hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$acl_hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                LIB[]NAME[]_PREFIX=\"$basedir\"\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$acl_hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$acl_hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/build-aux/speedo.mk": "# speedo.mk - Speedo rebuilds speedily.\n# Copyright (C) 2008, 2014, 2019 g10 Code GmbH\n#\n# speedo is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License, or\n# (at your option) any later version.\n#\n# speedo is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <http://www.gnu.org/licenses/>.\n\n# speedo builds gnupg-related packages from GIT and installs them in a\n# user directory, thereby providing a non-obstrusive test environment.\n# speedo does only work with GNU make.  The build system is similar to\n# that of gpg4win.  The following commands are supported:\n#\n#   make -f speedo.mk all  pkg2rep=/dir/with/tarballs\n# or\n#   make -f speedo.mk\n#\n# Builds all packages and installs them under PLAY/inst.  At the end,\n# speedo prints commands that can be executed in the local shell to\n# make use of the installed packages.\n#\n#   make -f speedo.mk clean\n# or\n#   make -f speedo.mk clean-PACKAGE\n#\n# Removes all packages or the package PACKAGE from the installation\n# and build tree.  A subsequent make will rebuild these (and only\n# these) packages.\n#\n#   make -f speedo.mk report\n# or\n#   make -f speedo.mk report-PACKAGE\n#\n# Lists packages and versions.\n#\n# The information reyured to sign the tarballs and binaries\n# are expected in the developer specific file ~/.gnupg-autogen.rc\".\n# Here is an example:\n#--8<---------------cut here---------------start------------->8---\n# # Location of the released tarball archives.  Note that this is an\n# # internal archive and before uploading this to the public server,\n# # manual tests should be run and the git release tagged and pushed.\n# # This is greped by the Makefile.\n# RELEASE_ARCHIVE=foo@somehost:tarball-archive\n#\n# # The key used to sign the released sources.\n# # This is greped by the Makefile.\n# RELEASE_SIGNKEY=6DAA6E64A76D2840571B4902528897B826403ADA\n#\n# # For signing Windows binaries we need to employ a Windows machine.\n# # We connect to this machine via ssh and take the connection\n# # parameters via .ssh/config. For example a VM could be specified\n# # like this:\n# #\n# #   Host authenticode-signhost\n# #        HostName localhost\n# #        Port 27042\n# #        User gpgsign\n# #\n# # Depending on the used token it might be necessary to allow single\n# # signon and unlock the token before running the make.  The following\n# # variable references this entry.  This is greped by the Makefile.\n# AUTHENTICODE_SIGNHOST=authenticode-signhost\n#\n# # The name of the signtool as used on Windows.\n# # This is greped by the Makefile.\n# AUTHENTICODE_TOOL=\"C:\\Program Files (x86)\\Windows Kits\\10\\bin\\signtool.exe\"\n#\n# # To use osslsigncode the follwing entries are required and\n# # an empty string must be given for AUTHENTICODE_SIGNHOST.\n# # They are greped by the Makefile.\n# AUTHENTICODE_KEY=/home/foo/.gnupg/my-authenticode-key.p12\n# AUTHENTICODE_CERTS=/home/foo/.gnupg/my-authenticode-certs.pem\n#\n#--8<---------------cut here---------------end--------------->8---\n\n\n# We need to know our own name.\nSPEEDO_MK := $(realpath $(lastword $(MAKEFILE_LIST)))\n\n.PHONY : help native native-gui w32-installer w32-source w32-wixlib\n.PHONY :      git-native git-native-gui git-w32-installer git-w32-source\n.PHONY :      this-native this-native-gui this-w32-installer this-w32-source\n\nhelp:\n\t@echo 'usage: make -f speedo.mk TARGET'\n\t@echo '       with TARGET being one of:'\n\t@echo '  help               This help'\n\t@echo '  native             Native build of the GnuPG core'\n\t@echo '  native-gui         Ditto but with pinentry and GPA'\n\t@echo '  w32-installer      Build a Windows installer'\n\t@echo '  w32-source         Pack a source archive'\n\t@echo '  w32-release        Build a Windows release'\n\t@echo '  w32-wixlib         Build a wixlib for MSI packages'\n\t@echo '  w32-sign-installer Sign the installer'\n\t@echo\n\t@echo 'You may append INSTALL_PREFIX=<dir> for native builds.'\n\t@echo 'Prepend TARGET with \"git-\" to build from GIT repos.'\n\t@echo 'Prepend TARGET with \"this-\" to build from the source tarball.'\n\t@echo 'Use STATIC=1 to build with statically linked libraries.'\n\t@echo 'Use SELFCHECK=0 for a non-released version.'\n\t@echo 'Use CUSTOM_SWDB=1 for an already downloaded swdb.lst.'\n\t@echo 'Use WIXPREFIX to provide the WIX binaries for the MSI package.'\n\t@echo '    Using WIX also requires wine with installed wine mono.'\n\t@echo '    Seee help-wixlib for more information'\n\nhelp-wixlib:\n\t@echo 'The buildsystem can create a wixlib to build MSI packages.'\n\t@echo ''\n\t@echo 'On debian install the packages \"wine\"'\n\t@echo '  apt-get install wine'\n\t@echo ''\n\t@echo 'Download the wine-mono msi:'\n\t@echo '  https://dl.winehq.org/wine/wine-mono/'\n\t@echo ''\n\t@echo 'Install it:'\n\t@echo '  wine msiexec /i ~/Downloads/wine-mono-4.9.4.msi'\n\t@echo ''\n\t@echo 'Download the wix toolset binary zip from:'\n\t@echo '  https://github.com/wixtoolset/wix3/releases'\n\t@echo 'The default folder searches for ~/w32root/wixtools'\n\t@echo 'Alternative locations can be passed by WIXPREFIX variable'\n\t@echo '  unzip -d ~/w32root/wixtools ~/Downloads/wix311-binaries.zip'\n\t@echo ''\n\t@echo 'Afterwards w32-release will build also a wixlib.'\n\n\nSPEEDOMAKE := $(MAKE) -f $(SPEEDO_MK) UPD_SWDB=1\n\nnative: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=release WITH_GUI=0 all\n\ngit-native: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=git     WITH_GUI=0 all\n\nthis-native: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=this    WITH_GUI=0 all\n\nnative-gui: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=release WITH_GUI=1 all\n\ngit-native-gui: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=git     WITH_GUI=1 all\n\nthis-native-gui: check-tools\n\t$(SPEEDOMAKE) TARGETOS=native WHAT=this    WITH_GUI=1 all\n\nw32-installer: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=release WITH_GUI=0 installer\n\ngit-w32-installer: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=git     WITH_GUI=0 installer\n\nthis-w32-installer: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=this    WITH_GUI=0 \\\n\t                                           CUSTOM_SWDB=1 installer\nw32-wixlib: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=release WITH_GUI=0 wixlib\n\ngit-w32-wixlib: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=git     WITH_GUI=0 wixlib\n\nthis-w32-wixlib: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=this    WITH_GUI=0 \\\n\t                                           CUSTOM_SWDB=1 wixlib\n\nw32-source: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=release WITH_GUI=0 dist-source\n\ngit-w32-source: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=git     WITH_GUI=0 dist-source\n\nthis-w32-source: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32    WHAT=this    WITH_GUI=0 \\\n\t                                           CUSTOM_SWDB=1 dist-source\n\nw32-release: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32 WHAT=release    WITH_GUI=0 SELFCHECK=0 \\\n                                                   installer-from-source\n\nw32-sign-installer: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32 WHAT=release    WITH_GUI=0 SELFCHECK=0 \\\n                                                   sign-installer\n\nw32-release-offline: check-tools\n\t$(SPEEDOMAKE) TARGETOS=w32 WHAT=release    WITH_GUI=0 SELFCHECK=0 \\\n\t  CUSTOM_SWDB=1 pkgrep=${HOME}/b pkg10rep=${HOME}/b  \\\n\t  installer-from-source\n\n\n# Set this to \"git\" to build from git,\n#          to \"release\" from tarballs,\n#          to \"this\" from the unpacked sources.\nWHAT=git\n\n# Set target to \"native\" or \"w32\"\nTARGETOS=\n\n# Set to 1 to build the GUI tools\nWITH_GUI=0\n\n# Set to 1 to use a pre-installed swdb.lst instead of the online version.\nCUSTOM_SWDB=0\n\n# Set to 1 to really download the swdb.\nUPD_SWDB=0\n\n# Set to 0 to skip the GnuPG version self-check\nSELFCHECK=1\n\n# Set to 1 to build with statically linked libraries.\nSTATIC=0\n\n# Set to the location of the directory with tarballs of\n# external packages.\nTARBALLS=$(shell pwd)/../tarballs\n\n#  Number of parallel make jobs\nMAKE_J=3\n\n# Name to use for the w32 installer and sources\nINST_NAME=gnupg-w32\n\n# Use this to override the installaion directory for native builds.\nINSTALL_PREFIX=none\n\n# Set this to the location of wixtools\nWIXPREFIX=$(shell readlink -f ~/w32root/wixtools)\n\n# Read signing information from ~/.gnupg-autogen.rc\ndefine READ_AUTOGEN_template\n$(1) = $$(shell grep '^$(1)=' $$$$HOME/.gnupg-autogen.rc|cut -d= -f2)\nendef\n$(eval $(call READ_AUTOGEN_template,AUTHENTICODE_SIGNHOST))\n$(eval $(call READ_AUTOGEN_template,AUTHENTICODE_TOOL))\n$(eval $(call READ_AUTOGEN_template,AUTHENTICODE_KEY))\n$(eval $(call READ_AUTOGEN_template,AUTHENTICODE_CERTS))\n\n# All files given in AUTHENTICODE_FILES are signed before\n# they are put into the installer.\nAUTHENTICODE_FILES= \\\n                    dirmngr.exe               \\\n                    dirmngr_ldap.exe          \\\n                    gpg-agent.exe             \\\n                    gpg-connect-agent.exe     \\\n                    gpg-preset-passphrase.exe \\\n                    gpg-wks-client.exe        \\\n                    gpg.exe                   \\\n                    gpgconf.exe               \\\n                    gpgme-w32spawn.exe        \\\n                    gpgsm.exe                 \\\n                    gpgtar.exe                \\\n                    gpgv.exe                  \\\n                    libassuan-0.dll           \\\n                    libgcrypt-20.dll          \\\n                    libgpg-error-0.dll        \\\n                    libgpgme-11.dll           \\\n                    libksba-8.dll             \\\n                    libnpth-0.dll             \\\n                    libsqlite3-0.dll          \\\n                    pinentry-w32.exe          \\\n                    scdaemon.exe\t      \\\n                    zlib1.dll\n\n\n\n# Directory names.\n# They must be absolute, as we switch directories pretty often.\nroot := $(shell pwd)/PLAY\nsdir := $(root)/src\nbdir := $(root)/build\nbdir6:= $(root)/build-w64\nifeq ($(INSTALL_PREFIX),none)\nidir := $(root)/inst\nelse\nidir := $(abspath $(INSTALL_PREFIX))\nendif\nidir6:= $(root)/inst-w64\nstampdir := $(root)/stamps\ntopsrc := $(shell cd $(dir $(SPEEDO_MK)).. && pwd)\nauxsrc := $(topsrc)/build-aux/speedo\npatdir := $(topsrc)/build-aux/speedo/patches\nw32src := $(topsrc)/build-aux/speedo/w32\n\n# =====BEGIN LIST OF PACKAGES=====\n# The packages that should be built.  The order is also the build order.\n# Fixme: Do we need to build pkg-config for cross-building?\n\nspeedo_spkgs  = \\\n\tlibgpg-error npth libgcrypt\n\nifeq ($(TARGETOS),w32)\nspeedo_spkgs += \\\n\tzlib bzip2 sqlite\nifeq ($(WITH_GUI),1)\nspeedo_spkgs += gettext libiconv\nendif\nendif\n\nspeedo_spkgs += \\\n\tlibassuan libksba\n\nifeq ($(TARGETOS),w32)\nspeedo_spkgs += \\\n\tntbtls\nendif\n\nspeedo_spkgs += \\\n\tgnupg\n\nifeq ($(TARGETOS),w32)\nifeq ($(WITH_GUI),1)\nspeedo_spkgs += \\\n\tlibffi glib pkg-config\nendif\nendif\n\nifeq ($(STATIC),0)\nspeedo_spkgs += \\\n\tgpgme\nendif\n\nifeq ($(TARGETOS),w32)\nifeq ($(WITH_GUI),1)\nspeedo_spkgs += \\\n\tlibpng \\\n\tgdk-pixbuf atk pixman cairo pango gtk+\nendif\nendif\n\nifeq ($(TARGETOS),w32)\n\nspeedo_spkgs += pinentry\nifeq ($(WITH_GUI),1)\nspeedo_spkgs += gpa gpgex\nendif\n\nelse\n\nifeq ($(WITH_GUI),1)\nspeedo_spkgs += pinentry gpa\nendif\n\nendif\n\n\n# =====END LIST OF PACKAGES=====\n\n\n# Packages which are additionally build for 64 bit Windows.  They are\n# only used for gpgex and thus we need to build them only if we want\n# a full installer.\nspeedo_w64_spkgs  =\nifeq ($(WITH_GUI),1)\nspeedo_w64_spkgs += libgpg-error libiconv gettext libassuan gpgex\nendif\n\n# Packages which use the gnupg autogen.sh build style\nspeedo_gnupg_style = \\\n\tlibgpg-error npth libgcrypt  \\\n\tlibassuan libksba ntbtls gnupg gpgme \\\n\tpinentry gpa gpgex\n\n# Packages which use only make and no build directory\nspeedo_make_only_style = \\\n\tzlib bzip2\n\n# Get the content of the software DB.\nifeq ($(CUSTOM_SWDB),1)\ngetswdb_options = --skip-download --skip-verify\nelse\ngetswdb_options =\nendif\nifeq ($(SELFCHECK),0)\ngetswdb_options += --skip-selfcheck\nendif\nifeq ($(UPD_SWDB),1)\nSWDB := $(shell $(topsrc)/build-aux/getswdb.sh $(getswdb_options) && echo okay)\nifeq ($(strip $(SWDB)),)\nifneq ($(WHAT),git)\n$(error Error getting GnuPG software version database)\nendif\nendif\n\n# Version numbers of the released packages\ngnupg_ver_this = $(shell cat $(topsrc)/VERSION)\n\ngnupg_ver        := $(shell awk '$$1==\"gnupg22_ver\" {print $$2}' swdb.lst)\n\nlibgpg_error_ver := $(shell awk '$$1==\"libgpg_error_ver\" {print $$2}' swdb.lst)\nlibgpg_error_sha1:= $(shell awk '$$1==\"libgpg_error_sha1\" {print $$2}' swdb.lst)\nlibgpg_error_sha2:= $(shell awk '$$1==\"libgpg_error_sha2\" {print $$2}' swdb.lst)\n\nnpth_ver  := $(shell awk '$$1==\"npth_ver\" {print $$2}' swdb.lst)\nnpth_sha1 := $(shell awk '$$1==\"npth_sha1\" {print $$2}' swdb.lst)\nnpth_sha2 := $(shell awk '$$1==\"npth_sha2\" {print $$2}' swdb.lst)\n\nlibgcrypt_ver  := $(shell awk '$$1==\"libgcrypt18_ver\" {print $$2}' swdb.lst)\nlibgcrypt_sha1 := $(shell awk '$$1==\"libgcrypt18_sha1\" {print $$2}' swdb.lst)\nlibgcrypt_sha2 := $(shell awk '$$1==\"libgcrypt18_sha2\" {print $$2}' swdb.lst)\n\nlibassuan_ver  := $(shell awk '$$1==\"libassuan_ver\" {print $$2}' swdb.lst)\nlibassuan_sha1 := $(shell awk '$$1==\"libassuan_sha1\" {print $$2}' swdb.lst)\nlibassuan_sha2 := $(shell awk '$$1==\"libassuan_sha2\" {print $$2}' swdb.lst)\n\nlibksba_ver  := $(shell awk '$$1==\"libksba_ver\" {print $$2}' swdb.lst)\nlibksba_sha1 := $(shell awk '$$1==\"libksba_sha1\" {print $$2}' swdb.lst)\nlibksba_sha2 := $(shell awk '$$1==\"libksba_sha2\" {print $$2}' swdb.lst)\n\nntbtls_ver  := $(shell awk '$$1==\"ntbtls_ver\" {print $$2}' swdb.lst)\nntbtls_sha1 := $(shell awk '$$1==\"ntbtls_sha1\" {print $$2}' swdb.lst)\nntbtls_sha2 := $(shell awk '$$1==\"ntbtls_sha2\" {print $$2}' swdb.lst)\n\ngpgme_ver  := $(shell awk '$$1==\"gpgme_ver\" {print $$2}' swdb.lst)\ngpgme_sha1 := $(shell awk '$$1==\"gpgme_sha1\" {print $$2}' swdb.lst)\ngpgme_sha2 := $(shell awk '$$1==\"gpgme_sha2\" {print $$2}' swdb.lst)\n\npinentry_ver  := $(shell awk '$$1==\"pinentry_ver\" {print $$2}' swdb.lst)\npinentry_sha1 := $(shell awk '$$1==\"pinentry_sha1\" {print $$2}' swdb.lst)\npinentry_sha2 := $(shell awk '$$1==\"pinentry_sha2\" {print $$2}' swdb.lst)\n\ngpa_ver  := $(shell awk '$$1==\"gpa_ver\" {print $$2}' swdb.lst)\ngpa_sha1 := $(shell awk '$$1==\"gpa_sha1\" {print $$2}' swdb.lst)\ngpa_sha2 := $(shell awk '$$1==\"gpa_sha2\" {print $$2}' swdb.lst)\n\ngpgex_ver  := $(shell awk '$$1==\"gpgex_ver\" {print $$2}' swdb.lst)\ngpgex_sha1 := $(shell awk '$$1==\"gpgex_sha1\" {print $$2}' swdb.lst)\ngpgex_sha2 := $(shell awk '$$1==\"gpgex_sha2\" {print $$2}' swdb.lst)\n\nzlib_ver  := $(shell awk '$$1==\"zlib_ver\" {print $$2}' swdb.lst)\nzlib_sha1 := $(shell awk '$$1==\"zlib_sha1_gz\" {print $$2}' swdb.lst)\nzlib_sha2 := $(shell awk '$$1==\"zlib_sha2_gz\" {print $$2}' swdb.lst)\n\nbzip2_ver  := $(shell awk '$$1==\"bzip2_ver\" {print $$2}' swdb.lst)\nbzip2_sha1 := $(shell awk '$$1==\"bzip2_sha1_gz\" {print $$2}' swdb.lst)\nbzip2_sha2 := $(shell awk '$$1==\"bzip2_sha2_gz\" {print $$2}' swdb.lst)\n\nsqlite_ver  := $(shell awk '$$1==\"sqlite_ver\" {print $$2}' swdb.lst)\nsqlite_sha1 := $(shell awk '$$1==\"sqlite_sha1_gz\" {print $$2}' swdb.lst)\nsqlite_sha2 := $(shell awk '$$1==\"sqlite_sha2_gz\" {print $$2}' swdb.lst)\n\n\n$(info Information from the version database)\n$(info GnuPG ..........: $(gnupg_ver) (building $(gnupg_ver_this)))\n$(info Libgpg-error ...: $(libgpg_error_ver))\n$(info Npth ...........: $(npth_ver))\n$(info Libgcrypt ......: $(libgcrypt_ver))\n$(info Libassuan ......: $(libassuan_ver))\n$(info Libksba ........: $(libksba_ver))\n$(info Zlib ...........: $(zlib_ver))\n$(info Bzip2 ..........: $(bzip2_ver))\n$(info SQLite .........: $(sqlite_ver))\n$(info NtbTLS .. ......: $(ntbtls_ver))\n$(info GPGME ..........: $(gpgme_ver))\n$(info Pinentry .......: $(pinentry_ver))\n$(info GPA ............: $(gpa_ver))\n$(info GpgEX.... ......: $(gpgex_ver))\nendif\n\n# Version number for external packages\npkg_config_ver = 0.23\nlibiconv_ver = 1.14\ngettext_ver = 0.18.2.1\nlibffi_ver = 3.0.13\nglib_ver = 2.34.3\nlibpng_ver = 1.4.12\ngdk_pixbuf_ver = 2.26.5\natk_ver = 1.32.0\npango_ver = 1.29.4\npixman_ver = 0.32.4\ncairo_ver = 1.12.16\ngtk__ver = 2.24.17\n\n# The GIT repository.  Using a local repo is much faster.\n#gitrep = git://git.gnupg.org\ngitrep = ${HOME}/s\n\n# The tarball directories\npkgrep = ftp://ftp.gnupg.org/gcrypt\npkg10rep = ftp://ftp.g10code.com/g10code\npkg2rep = $(TARBALLS)\n\n# For each package, the following variables can be defined:\n#\n# speedo_pkg_PACKAGE_git: The GIT repository that should be built.\n# speedo_pkg_PACKAGE_gitref: The GIT revision to checkout\n#\n# speedo_pkg_PACKAGE_tar: URL to the tar file that should be built.\n#\n# Exactly one of the above variables is required.  Note that this\n# version of speedo does not cache repositories or tar files, and does\n# not test the integrity of the downloaded software.  If you care\n# about this, you can also specify filenames to locally verified files.\n# Filenames are differentiated from URLs by starting with a slash '/'.\n#\n# speedo_pkg_PACKAGE_configure: Extra arguments to configure.\n#\n# speedo_pkg_PACKAGE_make_args: Extra arguments to make.\n#\n# speedo_pkg_PACKAGE_make_args_inst: Extra arguments to make install.\n#\n# Note that you can override the defaults in this file in a local file\n# \"config.mk\"\n\nifeq ($(WHAT),this)\nelse ifeq ($(WHAT),git)\n  speedo_pkg_libgpg_error_git = $(gitrep)/libgpg-error\n  speedo_pkg_libgpg_error_gitref = master\n  speedo_pkg_npth_git = $(gitrep)/npth\n  speedo_pkg_npth_gitref = master\n  speedo_pkg_libassuan_git = $(gitrep)/libassuan\n  speedo_pkg_libassuan_gitref = master\n  speedo_pkg_libgcrypt_git = $(gitrep)/libgcrypt\n  speedo_pkg_libgcrypt_gitref = master\n  speedo_pkg_libksba_git = $(gitrep)/libksba\n  speedo_pkg_libksba_gitref = master\n  speedo_pkg_ntbtls_git = $(gitrep)/ntbtls\n  speedo_pkg_ntbtls_gitref = master\n  speedo_pkg_gpgme_git = $(gitrep)/gpgme\n  speedo_pkg_gpgme_gitref = master\n  speedo_pkg_pinentry_git = $(gitrep)/pinentry\n  speedo_pkg_pinentry_gitref = master\n  speedo_pkg_gpa_git = $(gitrep)/gpa\n  speedo_pkg_gpa_gitref = master\n  speedo_pkg_gpgex_git = $(gitrep)/gpgex\n  speedo_pkg_gpgex_gitref = master\nelse ifeq ($(WHAT),release)\n  speedo_pkg_libgpg_error_tar = \\\n\t$(pkgrep)/libgpg-error/libgpg-error-$(libgpg_error_ver).tar.bz2\n  speedo_pkg_npth_tar = \\\n\t$(pkgrep)/npth/npth-$(npth_ver).tar.bz2\n  speedo_pkg_libassuan_tar = \\\n\t$(pkgrep)/libassuan/libassuan-$(libassuan_ver).tar.bz2\n  speedo_pkg_libgcrypt_tar = \\\n\t$(pkgrep)/libgcrypt/libgcrypt-$(libgcrypt_ver).tar.bz2\n  speedo_pkg_libksba_tar = \\\n\t$(pkgrep)/libksba/libksba-$(libksba_ver).tar.bz2\n  speedo_pkg_ntbtls_tar = \\\n\t$(pkgrep)/ntbtls/ntbtls-$(ntbtls_ver).tar.bz2\n  speedo_pkg_gpgme_tar = \\\n\t$(pkgrep)/gpgme/gpgme-$(gpgme_ver).tar.bz2\n  speedo_pkg_pinentry_tar = \\\n\t$(pkgrep)/pinentry/pinentry-$(pinentry_ver).tar.bz2\n  speedo_pkg_gpa_tar = \\\n\t$(pkgrep)/gpa/gpa-$(gpa_ver).tar.bz2\n  speedo_pkg_gpgex_tar = \\\n\t$(pkg10rep)/gpgex/gpgex-$(gpgex_ver).tar.bz2\nelse\n  $(error invalid value for WHAT (use on of: git release this))\nendif\n\nspeedo_pkg_pkg_config_tar = $(pkg2rep)/pkg-config-$(pkg_config_ver).tar.gz\nspeedo_pkg_zlib_tar       = $(pkgrep)/zlib/zlib-$(zlib_ver).tar.gz\nspeedo_pkg_bzip2_tar      = $(pkgrep)/bzip2/bzip2-$(bzip2_ver).tar.gz\nspeedo_pkg_sqlite_tar     = $(pkgrep)/sqlite/sqlite-autoconf-$(sqlite_ver).tar.gz\nspeedo_pkg_libiconv_tar   = $(pkg2rep)/libiconv-$(libiconv_ver).tar.gz\nspeedo_pkg_gettext_tar    = $(pkg2rep)/gettext-$(gettext_ver).tar.gz\nspeedo_pkg_libffi_tar     = $(pkg2rep)/libffi-$(libffi_ver).tar.gz\nspeedo_pkg_glib_tar       = $(pkg2rep)/glib-$(glib_ver).tar.xz\nspeedo_pkg_libpng_tar     = $(pkg2rep)/libpng-$(libpng_ver).tar.bz2\nspeedo_pkg_gdk_pixbuf_tar = $(pkg2rep)/gdk-pixbuf-$(gdk_pixbuf_ver).tar.xz\nspeedo_pkg_atk_tar        = $(pkg2rep)/atk-$(atk_ver).tar.bz2\nspeedo_pkg_pango_tar      = $(pkg2rep)/pango-$(pango_ver).tar.bz2\nspeedo_pkg_pixman_tar     = $(pkg2rep)/pixman-$(pixman_ver).tar.gz\nspeedo_pkg_cairo_tar      = $(pkg2rep)/cairo-$(cairo_ver).tar.xz\nspeedo_pkg_gtk__tar       = $(pkg2rep)/gtk+-$(gtk__ver).tar.xz\n\n\n#\n# Package build options\n#\n\nspeedo_pkg_npth_configure = --enable-static\n\nspeedo_pkg_libgpg_error_configure = --enable-static\nspeedo_pkg_w64_libgpg_error_configure = --enable-static\n\nspeedo_pkg_libassuan_configure = --enable-static\nspeedo_pkg_w64_libassuan_configure = --enable-static\n\nspeedo_pkg_libgcrypt_configure = --disable-static\n\nspeedo_pkg_libksba_configure = --disable-static\n\nspeedo_pkg_ntbtls_configure = --enable-static\n\n\nifeq ($(STATIC),1)\nspeedo_pkg_npth_configure += --disable-shared\n\nspeedo_pkg_libgpg_error_configure += --disable-shared\n\nspeedo_pkg_libassuan_configure += --disable-shared\n\nspeedo_pkg_libgcrypt_configure += --disable-shared\n\nspeedo_pkg_libksba_configure += --disable-shared\nendif\n\n# For now we build ntbtls only static\nspeedo_pkg_ntbtls_configure = --disable-shared\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_gnupg_configure = \\\n        --disable-g13 --enable-ntbtls \\\n        --enable-build-timestamp\nelse\nspeedo_pkg_gnupg_configure = --disable-g13 --enable-wks-tools\nendif\nspeedo_pkg_gnupg_extracflags = -g\n\n# Create the version info files only for W32 so that they won't get\n# installed if for example INSTALL_PREFIX=/usr/local is used.\nifeq ($(TARGETOS),w32)\ndefine speedo_pkg_gnupg_post_install\n(set -e; \\\n sed -n  's/.*PACKAGE_VERSION \"\\(.*\\)\"/\\1/p' config.h >$(idir)/INST_VERSION; \\\n sed -n  's/.*W32INFO_VI_PRODUCTVERSION \\(.*\\)/\\1/p' common/w32info-rc.h \\\n    |sed 's/,/./g' >$(idir)/INST_PROD_VERSION )\nendef\nendif\n\n# The LDFLAGS is needed for -lintl for glib.\nifeq ($(WITH_GUI),1)\nspeedo_pkg_gpgme_configure = \\\n\t--enable-static --enable-w32-glib  \\\n\t--with-gpg-error-prefix=$(idir) \\\n\tLDFLAGS=-L$(idir)/lib\nelse\nspeedo_pkg_gpgme_configure = \\\n\t--disable-static --disable-w32-glib \\\n\t--with-gpg-error-prefix=$(idir) \\\n\tLDFLAGS=-L$(idir)/lib\nendif\n\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_pinentry_configure = --disable-pinentry-gtk2\nelse\nspeedo_pkg_pinentry_configure = --enable-pinentry-gtk2\nendif\nspeedo_pkg_pinentry_configure += \\\n        --disable-pinentry-qt5   \\\n        --disable-pinentry-qt    \\\n\t--disable-pinentry-fltk  \\\n\t--disable-pinentry-tty   \\\n\tCPPFLAGS=-I$(idir)/include   \\\n\tLDFLAGS=-L$(idir)/lib        \\\n\tCXXFLAGS=-static-libstdc++\n\n\nspeedo_pkg_gpa_configure = \\\n        --with-libiconv-prefix=$(idir) --with-libintl-prefix=$(idir) \\\n        --with-gpgme-prefix=$(idir) --with-zlib=$(idir) \\\n        --with-libassuan-prefix=$(idir) --with-gpg-error-prefix=$(idir)\n\nspeedo_pkg_gpgex_configure = \\\n\t--with-gpg-error-prefix=$(idir) \\\n\t--with-libassuan-prefix=$(idir) \\\n\t--enable-gpa-only\n\nspeedo_pkg_w64_gpgex_configure = \\\n\t--with-gpg-error-prefix=$(idir6) \\\n\t--with-libassuan-prefix=$(idir6) \\\n\t--enable-gpa-only\n\n\n#\n# External packages\n#\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_zlib_make_args = \\\n        -fwin32/Makefile.gcc PREFIX=$(host)- IMPLIB=libz.dll.a\n\nspeedo_pkg_zlib_make_args_inst = \\\n        -fwin32/Makefile.gcc \\\n        BINARY_PATH=$(idir)/bin INCLUDE_PATH=$(idir)/include \\\n\tLIBRARY_PATH=$(idir)/lib SHARED_MODE=1 IMPLIB=libz.dll.a\n\n# Zlib needs some special magic to generate a libtool file.\n# We also install the pc file here.\ndefine speedo_pkg_zlib_post_install\n(set -e; mkdir $(idir)/lib/pkgconfig || true;\t        \\\ncp $(auxsrc)/zlib.pc $(idir)/lib/pkgconfig/; \t        \\\ncd $(idir);\t\t\t\t\t\t\\\necho \"# Generated by libtool\" > lib/libz.la\t\t\\\necho \"dlname='../bin/zlib1.dll'\" >> lib/libz.la;\t\\\necho \"library_names='libz.dll.a'\" >> lib/libz.la;\t\\\necho \"old_library='libz.a'\" >> lib/libz.la;\t\t\\\necho \"dependency_libs=''\" >> lib/libz.la;\t\t\\\necho \"current=1\" >> lib/libz.la;\t\t\t\\\necho \"age=2\" >> lib/libz.la;\t\t\t\t\\\necho \"revision=5\" >> lib/libz.la;\t\t\t\\\necho \"installed=yes\" >> lib/libz.la;\t\t\t\\\necho \"shouldnotlink=no\" >> lib/libz.la;\t\t\t\\\necho \"dlopen=''\" >> lib/libz.la;\t\t\t\\\necho \"dlpreopen=''\" >> lib/libz.la;\t\t\t\\\necho \"libdir=\\\"$(idir)/lib\\\"\" >> lib/libz.la)\nendef\n\nendif\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_bzip2_make_args = \\\n\tCC=\"$(host)-gcc\" AR=\"$(host)-ar\" RANLIB=\"$(host)-ranlib\"\n\nspeedo_pkg_bzip2_make_args_inst = \\\n\tPREFIX=$(idir) CC=\"$(host)-gcc\" AR=\"$(host)-ar\" RANLIB=\"$(host)-ranlib\"\nendif\n\nspeedo_pkg_w64_libiconv_configure = \\\n\t--enable-shared=no --enable-static=yes\n\nspeedo_pkg_gettext_configure = \\\n\t--with-lib-prefix=$(idir) --with-libiconv-prefix=$(idir) \\\n        CPPFLAGS=-I$(idir)/include LDFLAGS=-L$(idir)/lib\nspeedo_pkg_w64_gettext_configure = \\\n\t--with-lib-prefix=$(idir) --with-libiconv-prefix=$(idir) \\\n        CPPFLAGS=-I$(idir6)/include LDFLAGS=-L$(idir6)/lib\nspeedo_pkg_gettext_extracflags = -O2\n# We only need gettext-runtime and there is sadly no top level\n# configure option for this\nspeedo_pkg_gettext_make_dir = gettext-runtime\n\n\nspeedo_pkg_glib_configure = \\\n\t--disable-modular-tests \\\n\t--with-libiconv=gnu \\\n\tCPPFLAGS=-I$(idir)/include \\\n\tLDFLAGS=-L$(idir)/lib \\\n\tCCC=$(host)-g++ \\\n        LIBFFI_CFLAGS=-I$(idir)/lib/libffi-$(libffi_ver)/include \\\n\tLIBFFI_LIBS=\\\"-L$(idir)/lib -lffi\\\"\nifeq ($(TARGETOS),w32)\nspeedo_pkg_glib_extracflags = -march=i486\nendif\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_libpng_configure = \\\n\tCPPFLAGS=\\\"-I$(idir)/include -DPNG_BUILD_DLL\\\" \\\n\tLDFLAGS=\\\"-L$(idir)/lib\\\" LIBPNG_DEFINES=\\\"-DPNG_BUILD_DLL\\\"\nelse\nspeedo_pkg_libpng_configure = \\\n        CPPFLAGS=\\\"-I$(idir)/include\\\" \\\n        LDFLAGS=\\\"-L$(idir)/lib\\\"\nendif\n\nifneq ($(TARGETOS),w32)\nspeedo_pkg_gdk_pixbuf_configure = --without-libtiff --without-libjpeg\nendif\n\nspeedo_pkg_pixman_configure = \\\n\tCPPFLAGS=-I$(idir)/include \\\n\tLDFLAGS=-L$(idir)/lib\n\nifeq ($(TARGETOS),w32)\nspeedo_pkg_cairo_configure = \\\n\t--disable-qt --disable-ft --disable-fc \\\n\t--enable-win32 --enable-win32-font \\\n\tCPPFLAGS=-I$(idir)/include \\\n\tLDFLAGS=-L$(idir)/lib\nelse\nspeedo_pkg_cairo_configure = \\\n\t--disable-qt \\\n        CPPFLAGS=-I$(idir)/include \\\n        LDFLAGS=-L$(idir)/lib\nendif\n\nspeedo_pkg_pango_configure = \\\n\t--disable-gtk-doc  \\\n\tCPPFLAGS=-I$(idir)/include \\\n\tLDFLAGS=-L$(idir)/lib\n\nspeedo_pkg_gtk__configure = \\\n\t--disable-cups \\\n\tCPPFLAGS=-I$(idir)/include \\\n\tLDFLAGS=-L$(idir)/lib\n\n\n# ---------\n\nall: all-speedo\n\nreport: report-speedo\n\nclean: clean-speedo\n\nifeq ($(TARGETOS),w32)\nSTRIP = i686-w64-mingw32-strip\nelse\nSTRIP = strip\nendif\nW32CC = i686-w64-mingw32-gcc\n\n-include config.mk\n\n#\n#  The generic speedo code\n#\n\nMKDIR=mkdir\nMAKENSIS=makensis\nWINE=wine\n\nSHA1SUM := $(shell $(topsrc)/build-aux/getswdb.sh --find-sha1sum)\nifeq ($(SHA1SUM),false)\n$(error The sha1sum tool is missing)\nendif\nSHA2SUM := $(shell $(topsrc)/build-aux/getswdb.sh --find-sha256sum)\nifeq ($(SHA2SUM),false)\n$(error The sha256sum tool is missing)\nendif\n\n\nBUILD_ISODATE=$(shell date -u +%Y-%m-%d)\nBUILD_DATESTR=$(subst -,,$(BUILD_ISODATE))\n\n# The next two macros will work only after gnupg has been build.\nifeq ($(TARGETOS),w32)\nINST_VERSION=$(shell head -1 $(idir)/INST_VERSION)\nINST_PROD_VERSION=$(shell head -1 $(idir)/INST_PROD_VERSION)\nendif\n\n# List with packages\nspeedo_build_list = $(speedo_spkgs)\nspeedo_w64_build_list = $(speedo_w64_spkgs)\n\n# To avoid running external commands during the read phase (\":=\" style\n# assignments), we check that the targetos has been given\nifneq ($(TARGETOS),)\n\n# Determine build and host system\nbuild := $(shell $(topsrc)/autogen.sh --silent --print-build)\nifeq ($(TARGETOS),w32)\n  speedo_autogen_buildopt := --build-w32\n  speedo_autogen_buildopt6 := --build-w64\n  host := $(shell $(topsrc)/autogen.sh --silent --print-host --build-w32)\n  host6:= $(shell $(topsrc)/autogen.sh --silent --print-host --build-w64)\n  speedo_host_build_option := --host=$(host) --build=$(build)\n  speedo_host_build_option6 := --host=$(host6) --build=$(build)\n  speedo_w32_cflags := -mms-bitfields\nelse\n  speedo_autogen_buildopt :=\n  host :=\n  speedo_host_build_option :=\n  speedo_w32_cflags :=\nendif\n\nifeq ($(MAKE_J),)\n  speedo_makeopt=\nelse\n  speedo_makeopt=-j$(MAKE_J)\nendif\n\n# End non-empty TARGETOS\nendif\n\n\n\n# The playground area is our scratch area, where we unpack, build and\n# install the packages.\n$(stampdir)/stamp-directories:\n\t$(MKDIR) $(root) || true\n\t$(MKDIR) $(stampdir) || true\n\t$(MKDIR) $(sdir)  || true\n\t$(MKDIR) $(bdir)  || true\n\t$(MKDIR) $(idir)   || true\nifeq ($(TARGETOS),w32)\n\t$(MKDIR) $(bdir6)  || true\n\t$(MKDIR) $(idir6)   || true\nendif\n\ttouch $(stampdir)/stamp-directories\n\n# Frob the name $1 by converting all '-' and '+' characters to '_'.\ndefine FROB_macro\n$(subst +,_,$(subst -,_,$(1)))\nendef\n\n# Get the variable $(1) (which may contain '-' and '+' characters).\ndefine GETVAR\n$($(call FROB_macro,$(1)))\nendef\n\n# Set a couple of common variables.\ndefine SETVARS\n        pkg=\"$(1)\";                                                     \\\n        git=\"$(call GETVAR,speedo_pkg_$(1)_git)\";                       \\\n        gitref=\"$(call GETVAR,speedo_pkg_$(1)_gitref)\";                 \\\n        tar=\"$(call GETVAR,speedo_pkg_$(1)_tar)\";                       \\\n        ver=\"$(call GETVAR,$(1)_ver)\";                                  \\\n        sha2=\"$(call GETVAR,$(1)_sha2)\";                                \\\n        sha1=\"$(call GETVAR,$(1)_sha1)\";                                \\\n        pkgsdir=\"$(sdir)/$(1)\";                                         \\\n        if [ \"$(1)\" = \"gnupg\" ]; then                                   \\\n          git='';                                                       \\\n          gitref='';                                                    \\\n          tar='';                                                       \\\n          pkgsdir=\"$(topsrc)\";                                          \\\n        fi;                                                             \\\n        pkgbdir=\"$(bdir)/$(1)\";                                         \\\n        pkgcfg=\"$(call GETVAR,speedo_pkg_$(1)_configure)\";              \\\n        tmp=\"$(speedo_w32_cflags)                                       \\\n             $(call GETVAR,speedo_pkg_$(1)_extracflags)\";               \\\n        if [ x$$$$(echo \"$$$$tmp\" | tr -d '[:space:]')x != xx ]; then   \\\n          pkgextracflags=\"CFLAGS=\\\"$$$$tmp\\\"\";                          \\\n        else                                                            \\\n          pkgextracflags=;                                              \\\n        fi;                                                             \\\n        pkgmkdir=\"$(call GETVAR,speedo_pkg_$(1)_make_dir)\";             \\\n        pkgmkargs=\"$(call GETVAR,speedo_pkg_$(1)_make_args)\";           \\\n        pkgmkargs_inst=\"$(call GETVAR,speedo_pkg_$(1)_make_args_inst)\"; \\\n        pkgmkargs_uninst=\"$(call GETVAR,speedo_pkg_$(1)_make_args_uninst)\"; \\\n        export PKG_CONFIG=\"/usr/bin/pkg-config\";                        \\\n        export PKG_CONFIG_PATH=\"$(idir)/lib/pkgconfig\";                 \\\n        [ \"$(TARGETOS)\" != native ] && export PKG_CONFIG_LIBDIR=\"\";     \\\n        export SYSROOT=\"$(idir)\";                                       \\\n        export PATH=\"$(idir)/bin:$${PATH}\";                             \\\n        export LD_LIBRARY_PATH=\"$(idir)/lib:$${LD_LIBRARY_PATH}\"\nendef\n\ndefine SETVARS_W64\n        pkg=\"$(1)\";                                                     \\\n        git=\"$(call GETVAR,speedo_pkg_$(1)_git)\";                       \\\n        gitref=\"$(call GETVAR,speedo_pkg_$(1)_gitref)\";                 \\\n        tar=\"$(call GETVAR,speedo_pkg_$(1)_tar)\";                       \\\n        ver=\"$(call GETVAR,$(1)_ver)\";                                  \\\n        sha2=\"$(call GETVAR,$(1)_sha2)\";                                \\\n        sha1=\"$(call GETVAR,$(1)_sha1)\";                                \\\n        pkgsdir=\"$(sdir)/$(1)\";                                         \\\n        if [ \"$(1)\" = \"gnupg\" ]; then                                   \\\n          git='';                                                       \\\n          gitref='';                                                    \\\n          tar='';                                                       \\\n          pkgsdir=\"$(topsrc)\";                                          \\\n        fi;                                                             \\\n        pkgbdir=\"$(bdir6)/$(1)\";                                        \\\n        pkgcfg=\"$(call GETVAR,speedo_pkg_w64_$(1)_configure)\";          \\\n        tmp=\"$(speedo_w32_cflags)                                       \\\n             $(call GETVAR,speedo_pkg_$(1)_extracflags)\";               \\\n        if [ x$$$$(echo \"$$$$tmp\" | tr -d '[:space:]')x != xx ]; then   \\\n          pkgextracflags=\"CFLAGS=\\\"$$$$tmp\\\"\";                          \\\n        else                                                            \\\n          pkgextracflags=;                                              \\\n        fi;                                                             \\\n        pkgmkdir=\"$(call GETVAR,speedo_pkg_$(1)_make_dir)\";             \\\n        pkgmkargs=\"$(call GETVAR,speedo_pkg_$(1)_make_args)\";           \\\n        pkgmkargs_inst=\"$(call GETVAR,speedo_pkg_$(1)_make_args_inst)\"; \\\n        pkgmkargs_uninst=\"$(call GETVAR,speedo_pkg_$(1)_make_args_uninst)\"; \\\n        export PKG_CONFIG=\"/usr/bin/pkg-config\";                        \\\n        export PKG_CONFIG_PATH=\"$(idir6)/lib/pkgconfig\";                \\\n        [ \"$(TARGETOS)\" != native ] && export PKG_CONFIG_LIBDIR=\"\";     \\\n        export SYSROOT=\"$(idir6)\";                                      \\\n        export PATH=\"$(idir6)/bin:$${PATH}\";                            \\\n        export LD_LIBRARY_PATH=\"$(idir6)/lib:$${LD_LIBRARY_PATH}\"\nendef\n\n\n# Template for source packages.\n\n# Note that the gnupg package is special: The package source dir is\n# the same as the topsrc dir and thus we need to detect the gnupg\n# package and cd to that directory.  We also test that no in-source build\n# has been done.  autogen.sh is not run for gnupg.\n#\ndefine SPKG_template\n\n$(stampdir)/stamp-$(1)-00-unpack: $(stampdir)/stamp-directories\n\t@echo \"speedo: /*\"\n\t@echo \"speedo:  *   $(1)\"\n\t@echo \"speedo:  */\"\n\t@(set -e; cd $(sdir);\t\t\t\t\\\n\t $(call SETVARS,$(1)); \t\t\t\t\\\n\t if [ \"$(WHAT)\" = \"this\" ]; then                \\\n           echo \"speedo: using included source\";        \\\n\t elif [ \"$(1)\" = \"gnupg\" ]; then                \\\n\t   cd $$$${pkgsdir};                            \\\n           if [ -f config.log ]; then                   \\\n             echo \"GnuPG has already been build in-source\" >&2  ;\\\n\t     echo \"Please run \\\"make distclean\\\" and retry\" >&2 ;\\\n\t     exit 1 ;\t                         \t\\\n           fi;                                          \\\n\t   echo \"speedo: unpacking gnupg not needed\";   \\\n\t elif [ -n \"$$$${git}\" ]; then\t\t\t\\\n\t   echo \"speedo: unpacking $(1) from $$$${git}:$$$${gitref}\"; \\\n           git clone -b \"$$$${gitref}\" \"$$$${git}\" \"$$$${pkg}\"; \\\n\t   cd \"$$$${pkg}\"; \t\t\t\t\\\n\t   AUTOGEN_SH_SILENT=1 ./autogen.sh;            \\\n         elif [ -n \"$$$${tar}\" ]; then\t\t\t\\\n\t   echo \"speedo: unpacking $(1) from $$$${tar}\"; \\\n           case \"$$$${tar}\" in\t\t\t\t\\\n             *.gz) pretar=zcat ;;\t   \t\t\\\n             *.bz2) pretar=bzcat ;;\t\t\t\\\n\t     *.xz) pretar=xzcat ;;                     \t\\\n             *) pretar=cat ;;\t\t\t\t\\\n           esac;\t\t\t\t\t\\\n           [ -f tmp.tgz ] && rm tmp.tgz;                \\\n           case \"$$$${tar}\" in\t\t\t\t\\\n\t     /*) $$$${pretar} < $$$${tar} | tar xf - ;;\t\\\n\t     *)  wget -q -O - $$$${tar} | tee tmp.tgz   \\\n                  | $$$${pretar} | tar x$$$${opt}f - ;; \\\n\t   esac;\t\t\t\t\t\\\n\t   if [ -f tmp.tgz ]; then                      \\\n\t     if [ -n \"$$$${sha2}\" ]; then               \\\n               tmp=$$$$($(SHA2SUM) <tmp.tgz|cut -d' ' -f1);\\\n               if [ \"$$$${tmp}\" != \"$$$${sha2}\" ]; then \\\n\t         echo \"speedo:\";                        \\\n                 echo \"speedo: ERROR: SHA-256 checksum mismatch for $(1)\";\\\n\t         echo \"speedo:\";                        \\\n                 exit 1;                                \\\n               fi;                                      \\\n\t     elif [ -n \"$$$${sha1}\" ]; then            \\\n               tmp=$$$$($(SHA1SUM) <tmp.tgz|cut -d' ' -f1);\\\n               if [ \"$$$${tmp}\" != \"$$$${sha1}\" ]; then \\\n\t         echo \"speedo:\";                        \\\n                 echo \"speedo: ERROR: SHA-1 checksum mismatch for $(1)\";\\\n\t         echo \"speedo:\";                        \\\n                 exit 1;                                \\\n               fi;                                      \\\n\t     else                                       \\\n               echo \"speedo:\";                          \\\n               echo \"speedo: Warning: No checksum known for $(1)\";\\\n               echo \"speedo:\";                          \\\n             fi;                                        \\\n\t     rm tmp.tgz;                                \\\n           fi;                                          \\\n\t   base=`echo \"$$$${tar}\" | sed -e 's,^.*/,,'   \\\n                 | sed -e 's,\\.tar.*$$$$,,'`;\t\t\\\n\t   mv $$$${base} $(1);\t\t\t\t\\\n\t   patch=\"$(patdir)/$(1)-$$$${base#$(1)-}.patch\";\\\n\t   patchx=\"$(patdir)/$(1).patch\";               \\\n\t   if [ -x \"$$$${patch}\" ]; then  \t\t\\\n             echo \"speedo: applying patch $$$${patch}\"; \\\n             cd $(1); \"$$$${patch}\"; \t \t\t\\\n\t   elif [ -x \"$$$${patchx}\" ]; then  \t\t\\\n             echo \"speedo: applying patch $$$${patchx}\";\\\n             cd $(1); \"$$$${patchx}\"; \t \t\t\\\n\t   elif [ -f \"$$$${patch}\" ]; then  \t\t\\\n             echo \"speedo: warning: $$$${patch} is not executable\"; \\\n\t   fi;\t\t\t\t\t\t\\\n\t else                                           \\\n\t   echo \"speedo: unpacking $(1) from UNKNOWN\";  \\\n\t fi)\n\t@touch $(stampdir)/stamp-$(1)-00-unpack\n\n$(stampdir)/stamp-$(1)-01-configure: $(stampdir)/stamp-$(1)-00-unpack\n\t@echo \"speedo: configuring $(1)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@echo \"speedo: configure run not required\"\nelse ifneq ($(findstring $(1),$(speedo_gnupg_style)),)\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n\t mkdir \"$$$${pkgbdir}\";\t\t\t\t\\\n\t cd \"$$$${pkgbdir}\";\t\t        \t\\\n         if [ -n \"$(speedo_autogen_buildopt)\" ]; then   \\\n            eval AUTOGEN_SH_SILENT=1 w32root=\"$(idir)\"  \\\n               \"$$$${pkgsdir}/autogen.sh\"               \\\n               $(speedo_autogen_buildopt)            \t\\\n               $$$${pkgcfg} $$$${pkgextracflags}; \t\\\n         else                                        \t\\\n            eval \"$$$${pkgsdir}/configure\" \t\t\\\n\t       --silent                 \t\t\\\n\t       --enable-maintainer-mode\t\t\t\\\n               --prefix=\"$(idir)\"\t\t        \\\n               $$$${pkgcfg} $$$${pkgextracflags};     \t\\\n\t fi)\nelse\n\t@($(call SETVARS,$(1)); \t\t\t\\\n\t mkdir \"$$$${pkgbdir}\";\t\t\t\t\\\n\t cd \"$$$${pkgbdir}\";\t\t        \t\\\n\t eval \"$$$${pkgsdir}/configure\" \t\t\\\n\t     --silent $(speedo_host_build_option)\t\\\n             --prefix=\"$(idir)\"\t\t        \t\\\n\t     $$$${pkgcfg}  $$$${pkgextracflags};\t\\\n\t )\nendif\n\t@touch $(stampdir)/stamp-$(1)-01-configure\n\n# Note that unpack has no 64 bit version becuase it is just the source.\n# Fixme: We should use templates to create the standard and w64\n# version of these rules.\n$(stampdir)/stamp-w64-$(1)-01-configure: $(stampdir)/stamp-$(1)-00-unpack\n\t@echo \"speedo: configuring $(1) (64 bit)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@echo \"speedo: configure run not required\"\nelse ifneq ($(findstring $(1),$(speedo_gnupg_style)),)\n\t@($(call SETVARS_W64,$(1));\t\t\t\\\n\t mkdir \"$$$${pkgbdir}\";\t\t\t\t\\\n\t cd \"$$$${pkgbdir}\";\t\t        \t\\\n         if [ -n \"$(speedo_autogen_buildopt)\" ]; then   \\\n            eval AUTOGEN_SH_SILENT=1 w64root=\"$(idir6)\" \\\n               \"$$$${pkgsdir}/autogen.sh\"               \\\n               $(speedo_autogen_buildopt6)            \t\\\n               $$$${pkgcfg} $$$${pkgextracflags};       \\\n         else                                        \t\\\n            eval \"$$$${pkgsdir}/configure\" \t\t\\\n\t       --silent                 \t\t\\\n\t       --enable-maintainer-mode\t\t\t\\\n               --prefix=\"$(idir6)\"\t\t        \\\n               $$$${pkgcfg} $$$${pkgextracflags};       \\\n\t fi)\nelse\n\t@($(call SETVARS_W64,$(1)); \t\t\t\\\n\t mkdir \"$$$${pkgbdir}\";\t\t\t\t\\\n\t cd \"$$$${pkgbdir}\";\t\t        \t\\\n\t eval \"$$$${pkgsdir}/configure\" \t\t\\\n\t     --silent $(speedo_host_build_option6)\t\\\n             --prefix=\"$(idir6)\"\t        \t\\\n\t     $$$${pkgcfg} $$$${pkgextracflags};       \t\\\n\t )\nendif\n\t@touch $(stampdir)/stamp-w64-$(1)-01-configure\n\n\n$(stampdir)/stamp-$(1)-02-make: $(stampdir)/stamp-$(1)-01-configure\n\t@echo \"speedo: making $(1)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n          cd \"$$$${pkgsdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n          if test \"$$$${pkg}\" = zlib -a \"$(TARGETOS)\" != w32 ; then \\\n            ./configure --prefix=\"$(idir)\" ; \\\n          fi ;\\\n\t  $(MAKE) --no-print-directory $(speedo_makeopt) $$$${pkgmkargs} V=0)\nelse\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n          cd \"$$$${pkgbdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $(speedo_makeopt) $$$${pkgmkargs} V=0)\nendif\n\t@touch $(stampdir)/stamp-$(1)-02-make\n\n$(stampdir)/stamp-w64-$(1)-02-make: $(stampdir)/stamp-w64-$(1)-01-configure\n\t@echo \"speedo: making $(1) (64 bit)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@($(call SETVARS_W64,$(1));\t\t\t\t\\\n          cd \"$$$${pkgsdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $(speedo_makeopt) $$$${pkgmkargs} V=0)\nelse\n\t@($(call SETVARS_W64,$(1));\t\t\t\t\\\n          cd \"$$$${pkgbdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $(speedo_makeopt) $$$${pkgmkargs} V=0)\nendif\n\t@touch $(stampdir)/stamp-w64-$(1)-02-make\n\n# Note that post_install must come last because it may be empty and\n# \"; ;\" is a syntax error.\n$(stampdir)/stamp-$(1)-03-install: $(stampdir)/stamp-$(1)-02-make\n\t@echo \"speedo: installing $(1)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n          cd \"$$$${pkgsdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $$$${pkgmkargs_inst} install V=0;\\\n\t  $(call speedo_pkg_$(call FROB_macro,$(1))_post_install))\nelse\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n          cd \"$$$${pkgbdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $$$${pkgmkargs_inst} install-strip V=0;\\\n\t  $(call speedo_pkg_$(call FROB_macro,$(1))_post_install))\nendif\n\ttouch $(stampdir)/stamp-$(1)-03-install\n\n$(stampdir)/stamp-w64-$(1)-03-install: $(stampdir)/stamp-w64-$(1)-02-make\n\t@echo \"speedo: installing $(1) (64 bit)\"\nifneq ($(findstring $(1),$(speedo_make_only_style)),)\n\t@($(call SETVARS_W64,$(1));\t\t\t\t\\\n          cd \"$$$${pkgsdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $$$${pkgmkargs_inst} install V=0;\\\n\t  $(call speedo_pkg_$(call FROB_macro,$(1))_post_install))\nelse\n\t@($(call SETVARS_W64,$(1));\t\t\t\t\\\n          cd \"$$$${pkgbdir}\";\t\t\t\t\\\n\t  test -n \"$$$${pkgmkdir}\" && cd \"$$$${pkgmkdir}\"; \\\n\t  $(MAKE) --no-print-directory $$$${pkgmkargs_inst} install-strip V=0;\\\n\t  $(call speedo_pkg_$(call FROB_macro,$(1))_post_install))\nendif\n\ttouch $(stampdir)/stamp-w64-$(1)-03-install\n\n$(stampdir)/stamp-final-$(1): $(stampdir)/stamp-$(1)-03-install\n\t@($(call SETVARS,$(1));                                  \\\n\t  printf \"%-14s %-12s %s\\n\" $(1) \"$$$${ver}\" \"$$$${sha1}\" \\\n\t      >> $(bdir)/pkg-versions.txt)\n\t@echo \"speedo: $(1) done\"\n\t@touch $(stampdir)/stamp-final-$(1)\n\n$(stampdir)/stamp-w64-final-$(1): $(stampdir)/stamp-w64-$(1)-03-install\n\t@echo \"speedo: $(1) (64 bit) done\"\n\t@touch $(stampdir)/stamp-w64-final-$(1)\n\n.PHONY : clean-$(1)\nclean-$(1):\n\t@echo \"speedo: uninstalling $(1)\"\n\t@($(call SETVARS,$(1));\t\t\t          \\\n\t (cd \"$$$${pkgbdir}\" 2>/dev/null &&\t\t  \\\n\t  $(MAKE) --no-print-directory                    \\\n           $$$${pkgmkargs_uninst} uninstall V=0 ) || true;\\\n         if [ \"$(1)\" = \"gnupg\" ]; then                    \\\n\t   rm -fR \"$$$${pkgbdir}\" || true                ;\\\n\t else                                             \\\n\t   rm -fR \"$$$${pkgsdir}\" \"$$$${pkgbdir}\" || true;\\\n\t fi)\n\t-rm -f $(stampdir)/stamp-final-$(1) $(stampdir)/stamp-$(1)-*\n\n\n.PHONY : build-$(1)\nbuild-$(1): $(stampdir)/stamp-final-$(1)\n\n\n.PHONY : report-$(1)\nreport-$(1):\n\t@($(call SETVARS,$(1));\t\t\t\t\\\n\t echo -n $(1):\\  ;\t\t\t\t\\\n\t if [ -n \"$$$${git}\" ]; then\t\t\t\\\n           if [ -e \"$$$${pkgsdir}/.git\" ]; then\t\t\\\n\t     cd \"$$$${pkgsdir}\" &&\t\t\t\\\n             git describe ;\t\t                \\\n\t   else\t\t\t\t\t\t\\\n             echo missing;\t\t\t\t\\\n\t   fi\t\t\t\t\t\t\\\n         elif [ -n \"$$$${tar}\" ]; then\t\t\t\\\n\t   base=`echo \"$$$${tar}\" | sed -e 's,^.*/,,'   \\\n                 | sed -e 's,\\.tar.*$$$$,,'`;\t\t\\\n\t   echo $$$${base} ;\t\t\t\t\\\n         fi)\n\nendef\n\n\n# Insert the template for each source package.\n$(foreach spkg, $(speedo_spkgs), $(eval $(call SPKG_template,$(spkg))))\n\n$(stampdir)/stamp-final: $(stampdir)/stamp-directories clean-pkg-versions\nifeq ($(TARGETOS),w32)\n$(stampdir)/stamp-final: $(addprefix $(stampdir)/stamp-w64-final-,$(speedo_w64_build_list))\nendif\n$(stampdir)/stamp-final: $(addprefix $(stampdir)/stamp-final-,$(speedo_build_list))\n\ttouch $(stampdir)/stamp-final\n\nclean-pkg-versions:\n        @: >$(bdir)/pkg-versions.txt\n\nall-speedo: $(stampdir)/stamp-final\n\nreport-speedo: $(addprefix report-,$(speedo_build_list))\n\n# Just to check if we catched all stamps.\nclean-stamps:\n\t$(RM) -fR $(stampdir)\n\nclean-speedo:\n\t$(RM) -fR PLAY\n\n\n#\n# Windows installer\n#\n# {{{\nifeq ($(TARGETOS),w32)\n\ndist-source: installer\n\tfor i in 00 01 02 03; do sleep 1;touch PLAY/stamps/stamp-*-${i}-*;done\n\t(set -e;\\\n\t tarname=\"$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).tar\" ;\\\n\t [ -f \"$$tarname\" ] && rm \"$$tarname\" ;\\\n         tar -C $(topsrc) -cf \"$$tarname\" --exclude-backups --exclude-vcs \\\n             --transform='s,^\\./,$(INST_NAME)-$(INST_VERSION)/,' \\\n             --anchored --exclude './PLAY' . ;\\\n\t tar --totals -rf \"$$tarname\" --exclude-backups --exclude-vcs \\\n              --transform='s,^,$(INST_NAME)-$(INST_VERSION)/,' \\\n\t     PLAY/stamps/stamp-*-00-unpack PLAY/src swdb.lst swdb.lst.sig ;\\\n\t [ -f \"$$tarname\".xz ] && rm \"$$tarname\".xz;\\\n         xz -T0 \"$$tarname\" ;\\\n\t)\n\n\n# Extract the two latest news entries.  */\n$(bdir)/NEWS.tmp: $(topsrc)/NEWS\n\tawk '/^Notewo/ {if(okay>1){exit}; okay++};okay {print $0}' \\\n\t    <$(topsrc)/NEWS  >$(bdir)/NEWS.tmp\n\n# Sort the file with the package versions.\n$(bdir)/pkg-versions.sorted: $(bdir)/pkg-versions.txt\n\tgrep -v '^gnupg ' <$(bdir)/pkg-versions.txt \\\n\t    | sort | uniq >$(bdir)/pkg-versions.sorted\n\n$(bdir)/README.txt: $(bdir)/NEWS.tmp $(topsrc)/README $(w32src)/README.txt \\\n                    $(w32src)/pkg-copyright.txt $(bdir)/pkg-versions.sorted\n\tsed -e '/^;.*/d;' \\\n\t-e '/!NEWSFILE!/{r $(bdir)/NEWS.tmp' -e 'd;}' \\\n\t-e '/!GNUPGREADME!/{r $(topsrc)/README' -e 'd;}' \\\n        -e '/!PKG-COPYRIGHT!/{r $(w32src)/pkg-copyright.txt' -e 'd;}' \\\n        -e '/!PKG-VERSIONS!/{r $(bdir)/pkg-versions.sorted' -e 'd;}' \\\n        -e 's,!VERSION!,$(INST_VERSION),g' \\\n\t   < $(w32src)/README.txt \\\n           | sed -e '/^#/d' \\\n           | awk '{printf \"%s\\r\\n\", $$0}' >$(bdir)/README.txt\n\n$(bdir)/g4wihelp.dll: $(w32src)/g4wihelp.c $(w32src)/exdll.h\n\t(set -e; cd $(bdir); \\\n\t $(W32CC) -I. -shared -O2 -o g4wihelp.dll $(w32src)/g4wihelp.c \\\n\t          -lwinmm -lgdi32; \\\n\t $(STRIP) g4wihelp.dll)\n\nw32_insthelpers: $(bdir)/g4wihelp.dll\n\n$(bdir)/inst-options.ini: $(w32src)/inst-options.ini\n\tcat $(w32src)/inst-options.ini >$(bdir)/inst-options.ini\n\nextra_installer_options =\nifeq ($(WITH_GUI),1)\nextra_installer_options += -DWITH_GUI=1\nendif\n\n# Note that we sign only when doing the final installer.\ninstaller: all w32_insthelpers $(w32src)/inst-options.ini $(bdir)/README.txt\n\t(set -e;\\\n\t cd \"$(idir)\"; \\\n\t if echo \"$(idir)\" | grep -q '/PLAY-release/' ; then \\\n\t   for f in $(AUTHENTICODE_FILES); do \\\n             if [ -f \"bin/$$f\" ]; then \\\n\t       $(call AUTHENTICODE_sign,\"bin/$$f\",\"bin/$$f\");\\\n\t     elif [ -f \"libexec/$$f\" ]; then \\\n\t       $(call AUTHENTICODE_sign,\"libexec/$$f\",\"libexec/$$f\");\\\n\t     else \\\n\t       echo \"speedo: WARNING: file '$$f' not available for signing\";\\\n             fi;\\\n           done; \\\n         fi \\\n        )\n\t$(MAKENSIS) -V2 $$($(MAKENSIS) -version \\\n                           | grep -q ^v3 && echo \"-INPUTCHARSET CP1252 \") \\\n                    -DINST_DIR=$(idir) \\\n                    -DINST6_DIR=$(idir6) \\\n                    -DBUILD_DIR=$(bdir) \\\n                    -DTOP_SRCDIR=$(topsrc) \\\n                    -DW32_SRCDIR=$(w32src) \\\n                    -DBUILD_ISODATE=$(BUILD_ISODATE) \\\n                    -DBUILD_DATESTR=$(BUILD_DATESTR) \\\n\t\t    -DNAME=$(INST_NAME) \\\n\t            -DVERSION=$(INST_VERSION) \\\n\t\t    -DPROD_VERSION=$(INST_PROD_VERSION) \\\n\t\t    $(extra_installer_options) $(w32src)/inst.nsi\n\t@echo \"Ready: $(idir)/$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).exe\"\n\n# We use the installer target to ensure everything is done and signed\nwixlib: installer $(bdir)/README.txt $(w32src)/wixlib.wxs\n\tif [ -z \"$$(which $(WINE))\" ]; then \\\n\t\techo \"ERROR: For the w32-wixlib wine needs to be installed.\"; \\\n\t\techo \"ERROR: see 'help-w32-wixlib'\"; \\\n\t\texit 1; \\\n\tfi;\n\tif [ ! -d \"$(WIXPREFIX)\" ]; then \\\n\t\techo \"ERROR: You must set WIXPREFIX to an installation of wixtools.\"; \\\n\t\techo \"ERROR: see 'help-w32-wixlib'\"; \\\n\t\texit 1; \\\n\tfi;\n\t(if [ -z \"$$WINEPREFIX\" ]; then \\\n\t\tWINEPREFIX=\"$$HOME/.wine\"; \\\n\t\tif [ ! -e \"$$WINEPREFIX/dosdevices\" ]; then \\\n\t\t\techo \"ERROR: No wine prefix found under $$WINEPREFIX\"; \\\n\t\t\texit 1; \\\n\t\tfi; \\\n\tfi; \\\n\tWINEINST=$$WINEPREFIX/dosdevices/k:; \\\n\tWINESRC=$$WINEPREFIX/dosdevices/i:; \\\n\tWINEBUILD=$$WINEPREFIX/dosdevices/j:; \\\n\tif [ -e \"$$WINEINST\" ]; then \\\n\t\techo \"ERROR: $$WINEINST already exists. Please remove.\"; \\\n\t\texit 1; \\\n\tfi; \\\n\tif [ -e \"$$WINESRC\" ]; then \\\n\t\techo \"ERROR: $$WINESRC already exists. Please remove.\"; \\\n\t\texit 1; \\\n\tfi; \\\n\tif [ -e \"$$WINEBUILD\" ]; then \\\n\t\techo \"ERROR: $$WINEBUILD already exists. Please remove.\"; \\\n\t\texit 1; \\\n\tfi; \\\n\techo \"$(INST_NAME)\" > $(bdir)/VERSION; \\\n\techo \"$(INST_VERSION)\" >> $(bdir)/VERSION; \\\n\tMSI_VERSION=$$(echo $(INST_VERSION) | tr -s \\\\-beta .); \\\n\t(ln -s $(idir) $$WINEINST; \\\n\t ln -s $(w32src) $$WINESRC; \\\n\t ln -s $(bdir)  $$WINEBUILD; \\\n\t\t$(WINE) $(WIXPREFIX)/candle.exe \\\n\t\t-dSourceDir=k: \\\n\t\t-dBuildDir=j: \\\n\t\t-dVersion=$$MSI_VERSION \\\n\t\t-out k:\\\\$(INST_NAME).wixobj \\\n\t\t-pedantic -wx i:\\\\wixlib.wxs ;\\\n\t\t$(WINE) $(WIXPREFIX)/lit.exe \\\n\t\t-out k:\\\\$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).wixlib \\\n\t\t-bf \\\n\t\t-wx \\\n\t\t-pedantic \\\n\t\tk:\\\\$(INST_NAME).wixobj \\\n\t); \\\n\t\t(rm $$WINEINST; rm $$WINESRC; rm $$WINEBUILD;) \\\n\t)\n\ndefine MKSWDB_commands\n ( pref=\"#+macro: gnupg22_w32_$(3)\" ;\\\n   echo \"$${pref}ver  $(INST_VERSION)_$(BUILD_DATESTR)\"  ;\\\n   echo \"$${pref}date $(2)\" ;\\\n   echo \"$${pref}size $$(wc -c <$(1)|awk '{print int($$1/1024)}')k\";\\\n   echo \"$${pref}sha1 $$(sha1sum <$(1)|cut -d' ' -f1)\" ;\\\n   echo \"$${pref}sha2 $$(sha256sum <$(1)|cut -d' ' -f1)\" ;\\\n ) | tee $(1).swdb\nendef\n\n# Sign the file $1 and save the result as $2\ndefine AUTHENTICODE_sign\n   set -e;\\\n   if [ -n \"$(AUTHENTICODE_SIGNHOST)\" ]; then \\\n     echo \"speedo: Signing via host $(AUTHENTICODE_SIGNHOST)\";\\\n     scp $(1) \"$(AUTHENTICODE_SIGNHOST):a.exe\" ;\\\n     ssh \"$(AUTHENTICODE_SIGNHOST)\" '$(AUTHENTICODE_TOOL)' sign \\\n        /n '\"g10 Code GmbH\"' \\\n        /tr 'http://rfc3161timestamp.globalsign.com/advanced' /td sha256 \\\n        /fd sha256 /du https://gnupg.org a.exe ;\\\n     scp \"$(AUTHENTICODE_SIGNHOST):a.exe\" $(2);\\\n     echo \"speedo: signed file is '$(2)'\" ;\\\n   elif [ -e \"$(AUTHENTICODE_KEY)\" ]; then \\\n     echo \"speedo: Signing using key $(AUTHENTICODE_KEY)\";\\\n     osslsigncode sign -certs $(AUTHENTICODE_CERTS) \\\n       -pkcs12 $(AUTHENTICODE_KEY) -askpass \\\n       -ts \"http://timestamp.globalsign.com/scripts/timstamp.dll\" \\\n       -h sha256 -n GnuPG -i https://gnupg.org \\\n       -in $(1) -out $(2) ;\\\n   else \\\n     echo \"speedo: WARNING: Binaries are not signed\"; \\\n   fi\nendef\n\n\n# Build the installer from the source tarball.\ninstaller-from-source: dist-source\n\t(set -e;\\\n\t [ -d PLAY-release ] && rm -rf PLAY-release; \\\n\t mkdir PLAY-release;\\\n\t cd PLAY-release; \\\n\t tar xJf \"../$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).tar.xz\";\\\n\t cd $(INST_NAME)-$(INST_VERSION); \\\n\t $(MAKE) -f build-aux/speedo.mk this-w32-installer SELFCHECK=0;\\\n\t if [ -d \"$(WIXPREFIX)\" ]; then \\\n\t\t $(MAKE) -f build-aux/speedo.mk this-w32-wixlib SELFCHECK=0;\\\n\t fi; \\\n\t reldate=\"$$(date -u +%Y-%m-%d)\" ;\\\n\t exefile=\"$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).exe\" ;\\\n\t cp \"PLAY/inst/$$exefile\" ../.. ;\\\n\t exefile=\"../../$$exefile\" ;\\\n\t $(call MKSWDB_commands,$${exefile},$${reldate}); \\\n\t msifile=\"$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).wixlib\"; \\\n\t if [ -e \"PLAY/inst/$${msifile}\" ]; then \\\n\t\t cp \"PLAY/inst/$$msifile\" ../..; \\\n\t\t msifile=\"../../$$msifile\" ; \\\n\t\t $(call MKSWDB_commands,$${msifile},$${reldate},\"wixlib_\"); \\\n\t fi \\\n\t)\n\n# This target repeats some of the installer-from-source steps but it\n# is intended to be called interactively, so that the passphrase can be\n# entered.\nsign-installer:\n\t@(set -e; \\\n\t cd PLAY-release; \\\n\t cd $(INST_NAME)-$(INST_VERSION); \\\n\t reldate=\"$$(date -u +%Y-%m-%d)\" ;\\\n\t exefile=\"$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).exe\" ;\\\n\t msifile=\"$(INST_NAME)-$(INST_VERSION)_$(BUILD_DATESTR).wixlib\" ;\\\n\t echo \"speedo: /*\" ;\\\n\t echo \"speedo:  * Signing installer\" ;\\\n\t echo \"speedo:  */\" ;\\\n\t $(call AUTHENTICODE_sign,\"PLAY/inst/$$exefile\",\"../../$$exefile\");\\\n\t exefile=\"../../$$exefile\" ;\\\n\t msifile=\"../../$$msifile\" ;\\\n\t $(call MKSWDB_commands,$${exefile},$${reldate}); \\\n\t if [ -e \"$${msifile}\" ]; then \\\n\t   $(call MKSWDB_commands,$${msifile},$${reldate},\"wixlib_\"); \\\n\t fi; \\\n\t echo \"speedo: /*\" ;\\\n\t echo \"speedo:  * Verification result\" ;\\\n\t echo \"speedo:  */\" ;\\\n         osslsigncode verify $${exefile} \\\n\t)\n\n\n\nendif\n# }}} W32\n\n\n#\n# Check availibility of standard tools\n#\ncheck-tools:\n\n\n#\n# Mark phony targets\n#\n.PHONY: all all-speedo report-speedo clean-stamps clean-speedo installer \\\n\tw32_insthelpers check-tools clean-pkg-versions\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/common/gnupg.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/samplekeys/68A638998DFABAC510EA645CE34F9686B2EDF7EA.key",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/4gb-packet.asc",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/B662E42F-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/BE04EB2B.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/conflicting/1C005AF3-4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-3.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-2.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-4.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-2.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-1.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-secret.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/871C2247-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/openpgp/tofu/cross-sigs/EC38277E-1.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/gpgsm/cert_dfn_pca01.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/gpgsm/cert_dfn_pca15.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/tests/gpgsm/cert_g10code_test1.der",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/fi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/et.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/ro.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/uk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/pt.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/id.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/eo.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/hu.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/sk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/nb.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/cs.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/en@boldquot.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/pl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/gl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/en@quot.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/it.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/ca.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/ru.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/po/tr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/build-aux/speedo/w32/inst.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/build-aux/speedo/w32/gnupg-logo-164x314.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/build-aux/speedo/w32/gnupg-logo-150x57.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-card-architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-module-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-card-architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-module-overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/doc/gnupg-logo-tr.png",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/g10/t-keydb-get-keyblock.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/g10/distsigkey.gpg",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/g10/t-stutter-data.asc",
        "/tmp/vanessa/spack-stage/spack-stage-gnupg-2.2.22-42leu7csxsjfu3hthtzijz67iwoxnluo/spack-src/g10/t-keydb-keyring.kbx"
    ],
    "total_files": 1030
}