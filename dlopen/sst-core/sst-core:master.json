{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/configure.ac": "\n\nAC_INIT([SSTCore], [-dev], [sst@sandia.gov])\n\nAC_PREREQ([2.59])\n\nAC_CONFIG_AUX_DIR([config])\nAC_CONFIG_MACRO_DIR([config])\nAC_PREFIX_DEFAULT([/usr/local])\nAM_INIT_AUTOMAKE([1.9.6 foreign dist-bzip2 subdir-objects no-define tar-pax])\n\n# If Automake supports silent rules, enable them.\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nm4_pattern_allow([LT_LIBEXT])\n\nAC_CONFIG_HEADER([src/sst/core/sst_config.h])\n\n# Lets check for the standard compilers and basic options\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_CC_C99\nAC_C_INLINE\nAC_PROG_MAKE_SET\n\nAC_PROG_CXX\nAC_CACHE_SAVE\n\nAC_PROG_CPP\nAC_CANONICAL_HOST\n\nAC_CACHE_SAVE\nAC_HEADER_TIME\n\nLT_CONFIG_LTDL_DIR([src/sst/core/libltdl])\nLT_INIT([shared disable-static dlopen])\nLTDL_INIT([recursive])\n\nif test \"x$with_included_ltdl\" != \"xyes\"; then\n   save_CFLAGS=\"$CFLAGS\"\n   save_LDFLAGS=\"$LDFLAGS\"\n   save_LIBS=\"$LIBS\"\n   CFLAGS=\"$CFLAGS $LTDLINCL\"\n   LDFLAGS=\"$LDFLAGS $LIBLTDL\"\n   AC_CHECK_LIB([ltdl], [lt_dladvise_init],\n                 [],\n                 [AC_MSG_ERROR([installed libltdl is too old])])\n   LIBS=\"$save_LIBS\"\n   LDFLAGS=\"$save_LDFLAGS\"\n   CFLAGS=\"$save_CFLAGS\"\nfi\n\nAC_SUBST([LTDLINCL])\nAC_SUBST([LIBLTDL])\n\ndnl Work out the C++ standard which we are going to use\nAX_CXX_COMPILE_STDCXX_1Y\nAX_CXX_COMPILE_STDCXX_0X\n\nAS_IF([test \"x$found_cxx1y\" = \"xyes\"],\n        [CXXFLAGS=\"$CXXFLAGS $SST_CXX1Y_FLAGS\"],\n        [CXXFLAGS=\"$CXXFLAGS $SST_CXX0X_FLAGS\"])\n\nSST_CHECK_PICKY\nAS_IF([test \"x$use_picky\" = \"xyes\"],\n      [WARNFLAGS=\"-Wall -Wextra\"],\n      [WARNFLAGS=\"\"])\nCFLAGS=\"$CFLAGS $WARNFLAGS\"\nCXXFLAGS=\"$CXXFLAGS $WARNFLAGS\"\n\ndnl Fix flags - seems to be only way to make libltdl play nice\nCPPFLAGS='-I$(top_builddir) -I$(top_srcdir)/src -I$(top_builddir)/src'\" $CPPFLAGS\"\n\nAC_HEADER_TIME\nAC_CHECK_HEADERS([c_asm.h dlfcn.h intrinsics.h mach/mach_time.h sys/time.h sys/stat.h sys/types.h unistd.h])\n\nAC_CACHE_SAVE\n\nAC_CHECK_PROG([DOXYGEN], [doxygen], [doxygen])\nAM_CONDITIONAL([HAVE_DOXYGEN], [test \"$DOXYGEN\" = \"doxygen\"])\n\nSST_CHECK_PREVIEW_BUILD()\nSST_ENABLE_TESTFRAMEWORK_DEV()\n\nSST_CHECK_OSX()\nSST_CHECK_MPI([], [AC_MSG_ERROR([Could not find MPI package])])\n\nSST_CHECK_PYTHON([], [AC_MSG_ERROR([Could not find Python, this is required for SST to build])])\nSST_CHECK_LIBZ([have_zlib=\"yes\"],[have_zlib=\"no\"],[AC_MSG_ERROR([zlib was requested but could not be found.])])\nSST_CHECK_HDF5()\nSST_CHECK_MEM_POOL()\n\nSST_ENABLE_DEBUG_OUTPUT()\nSST_ENABLE_DEBUG_EVENT_TRACKING()\n\nAS_IF([test \"$use_mempool\" = \"no\" -a \"$enable_debug_event_tracking\" = \"yes\"],\n[AC_MSG_ERROR([Event Tracking cannot be enabled with mem-pools disabled.])])\n\nSST_ENABLE_CORE_PROFILE()\n\nSST_CHECK_FPIC()\n\nSST_CHECK_ZOLTAN([have_zoltan=1],[have_zoltan=0],[AC_MSG_ERROR([Zoltan requested but not found])])\nAS_IF([test \"x$have_zoltan\" = \"x1\"], [AC_DEFINE_UNQUOTED([HAVE_ZOLTAN], [1],\n\t[Define if you have the Zoltan library.])])\nAM_CONDITIONAL([HAVE_ZOLTAN], [test \"$have_zoltan\" = 1])\n\nAC_DEFINE_UNQUOTED([SST_CPPFLAGS], [\"$CPPFLAGS\"], [Defines the CPPFLAGS used to build SST])\nAC_DEFINE_UNQUOTED([SST_CFLAGS], [\"$CFLAGS\"], [Defines the CFLAGS used to build SST])\nAC_DEFINE_UNQUOTED([SST_CXXFLAGS], [\"$CXXFLAGS\"], [Defines the CXXFLAGS used to build SST])\nAC_DEFINE_UNQUOTED([SST_LDFLAGS], [\"$LDFLAGS\"], [Defines the LDFLAGS used to build SST])\n\nAC_DEFINE_UNQUOTED([SST_CC], [\"$CC\"], [Defines the C compiler used to build SST])\nAC_DEFINE_UNQUOTED([SST_CXX], [\"$CXX\"], [Defines the C++ compiler used to build SST])\nAC_DEFINE_UNQUOTED([SST_LD], [\"$LD\"], [Defines the linker used to build SST])\nAC_DEFINE_UNQUOTED([SST_MPICC], [\"$MPICC\"], [Defines the MPI C compiler used to build SST])\nAC_DEFINE_UNQUOTED([SST_MPICXX], [\"$MPICXX\"], [Defines the MPI C++ compilers used to build SST])\n\nAC_DEFINE_UNQUOTED([SST_CPP], [\"$CPP\"], [Defines the C preprocessor used to build SST])\nAC_DEFINE_UNQUOTED([SST_CXXCPP], [\"$CXXCPP\"], [Defines the C++ preprocessor used to build SST])\n\nAC_DEFINE_UNQUOTED([SST_PYTHON_CPPFLAGS], [\"$PYTHON_CPPFLAGS\"],\n\t[Defines the CPPFLAGS needed to compile Python into SST])\nAC_DEFINE_UNQUOTED([SST_PYTHON_LDFLAGS], [\"$PYTHON_LDFLAGS\"],\n\t[Defines the LDFLAGS needed to compile Python into SST])\n\nAC_DEFINE([__STDC_FORMAT_MACROS], [1], [Defines that standard PRI macros should be enabled])\n\nAC_MSG_CHECKING([for SST-Core Git Branch, Head SHA and Commit Count])\nif test -d \".git\" ; then\n    SSTCORE_GIT_BRANCH=`git rev-parse --abbrev-ref HEAD`\n    AC_MSG_RESULT([${SSTCORE_GIT_BRANCH}])\n    SSTCORE_GIT_HEADSHA=`git rev-parse HEAD`\n    AC_MSG_RESULT([${SSTCORE_GIT_HEADSHA}])\n\tSSTCORE_GIT_COMMITCOUNT=`git rev-list HEAD | wc -l | sed -e 's/^ *//g'`\n\tAC_MSG_RESULT([${SSTCORE_GIT_COMMITCOUNT}])\nelse\n    SSTCORE_GIT_BRANCH=\"N/A\"\n    AC_MSG_RESULT([${SSTCORE_GIT_BRANCH}])\n    SSTCORE_GIT_HEADSHA=\"${PACKAGE_VERSION}\"\n    AC_MSG_RESULT([${SSTCORE_GIT_HEADSHA}])\n\tSSTCORE_GIT_COMMITCOUNT=\"0\"\n\tAC_MSG_RESULT([${SSTCORE_GIT_COMMITCOUNT}])\nfi\n\nAC_SUBST(SSTCORE_GIT_BRANCH)\nAC_DEFINE_UNQUOTED([SSTCORE_GIT_BRANCH], [\"$SSTCORE_GIT_BRANCH\"], [SST-Core Git Branch])\n\nAC_SUBST(SSTCORE_GIT_HEADSHA)\nAC_DEFINE_UNQUOTED([SSTCORE_GIT_HEADSHA], [\"$SSTCORE_GIT_HEADSHA\"], [SST-Core Git Head SHA])\n\nAC_SUBST(SSTCORE_GIT_COMMITCOUNT)\nAC_DEFINE_UNQUOTED([SSTCORE_GIT_COMMITCOUNT], [\"$SSTCORE_GIT_COMMITCOUNT\"], [SST-Core Git Commit Count])\n\nCC_VERSION=`$CC --version | sed -e ':a' -e 'N' -e '$!ba' -e 's/\\n/%/g' | awk -F'%' '{print $1}'`\nAC_SUBST(CC_VERSION)\n\nMPICC_VERSION=`$MPICC --version | sed -e ':a' -e 'N' -e '$!ba' -e 's/\\n/%/g' | awk -F'%' '{print $1}'`\nAC_SUBST(MPICC_VERSION)\n\nAC_CACHE_SAVE\n\nAC_DEFINE_UNQUOTED([SST_INSTALL_PREFIX], [\"$prefix\"], [Defines the location SST will be installed in])\n\nAC_CACHE_SAVE\n\ndnl Remove flags like -g, -O, and -W, that are not needed by other elements\nSST_EXPORT_CXXFLAGS=`echo \"$CXXFLAGS\" | sed -E -e 's/ *-(g|O.|W@<:@^@<:@:space:@:>@@:>@+)//g'`\nSST_EXPORT_CFLAGS=`echo \"$CFLAGS\" | sed -E -e 's/ *-(g|O.|W@<:@^@<:@:space:@:>@@:>@+)//g'`\nAC_SUBST(SST_EXPORT_CXXFLAGS)\nAC_SUBST(SST_EXPORT_CFLAGS)\n\nAC_CONFIG_FILES([\n  Makefile\n  doc/Makefile\n  doc/Doxyfile\n  share/Makefile\n  share/SSTConfig.cmake\n  src/sst/sstsimulator.conf:src/sst/sst.conf\n  src/Makefile\n  src/sst/Makefile\n  src/sst/SST-${PACKAGE_VERSION}.pc:src/sst/sst.pc.in\n  src/sst/core/Makefile\n  src/sst/core/libltdl/Makefile\n  src/sst/core/build_info.h:src/sst/core/build_info.h.in\n])\nAC_OUTPUT\n\necho \"\"\necho \"-------------------------------------------------------\"\necho \"SST Core Configuration completed.\"\necho \"-------------------------------------------------------\"\necho \"Build Environment:\"\necho \"\"\nprintf \"%38s : %s\\n\" \"SST-Core Version\" \"$PACKAGE_VERSION\"\nif test \"x$SSTCORE_GIT_HEADSHA\" != \"x$PACKAGE_VERSION\"; then\nprintf \"%38s : %s\\n\" \"Git Branch\" \"$SSTCORE_GIT_BRANCH\"\nprintf \"%38s : %s\\n\" \"Git HEAD SHA\" \"$SSTCORE_GIT_HEADSHA\"\nprintf \"%38s : %s\\n\" \"Branch Commit Count\" \"$SSTCORE_GIT_COMMITCOUNT\"\nelse\nprintf \"%38s : %s\\n\" \"Version\" \"SST-Core $PACKAGE_VERSION\"\nfi\nprintf \"%38s : %s\\n\" \"Prefix\" \"$prefix\"\nprintf \"%38s : %s\\n\" \"Preprocessor\" \"$CPP\"\nprintf \"%38s : %s\\n\" \"C++ Compiler\" \"$CXX\"\nprintf \"%38s : %s\\n\" \"C Compiler\" \"$CC\"\nprintf \"%38s : %s\\n\" \"Compiler Version\" \"$CC_VERSION\"\nprintf \"%38s : %s\\n\" \"MPI C Compiler\" \"$MPICC\"\nprintf \"%38s : %s\\n\" \"MPI C++ Compiler\" \"$MPICXX\"\nprintf \"%38s : %s\\n\" \"MPI Compiler Version\" \"$MPICC_VERSION\"\nprintf \"%38s : %s\\n\" \"Linker\" \"$LD\"\nprintf \"%38s : %s\\n\" \"Preprocessor Options\" \"$CPPFLAGS\"\nprintf \"%38s : %s\\n\" \"C Compiler Options\" \"$CFLAGS\"\nprintf \"%38s : %s\\n\" \"C++ Compiler Options\" \"$CXXFLAGS\"\n\nif test \"x$found_cxx1y\" = \"xyes\"; then\nprintf \"%38s : %s\\n\" \"C++ Standard Compliance\" \"C++1Y/14\"\nelse\nprintf \"%38s : %s\\n\" \"C++ Standard Compliance\" \"C++11\"\nfi\n\nprintf \"%38s : %s\\n\" \"Linker Options\" \"$LDFLAGS\"\necho \"-------------------------------------------------------\"\necho \"Configuration Information (Dependencies):\"\necho \"\"\n\nprintf \"%38s : %s (%s)\\n\" \"Found Python\" \"$PYTHON_EXE\" \"$PYTHON_VERSION\"\nprintf \"%38s : %s\\n\" \"Python3\" \"$PYTHON_VERSION3\"\nif test \"x$sst_check_zoltan_happy\" = \"xyes\" ; then\n    printf \"%38s : YES\\n\" \"Zoltan Partitioner\"\nelse\n    printf \"%38s : No\\n\" \"Zoltan Partitioner\"\nfi\nif test \"x$sst_check_hdf5_happy\" = \"xyes\" ; then\n    printf \"%38s : YES\\n\" \"HDF5 Support\"\nelse\n    printf \"%38s : No\\n\" \"HDF5 Support\"\nfi\nif test \"x$sst_check_libz_happy\" = \"xyes\" ; then\n    printf \"%38s : YES\\n\" \"libz compression library\"\nelse\n    printf \"%38s : No\\n\" \"libz compression library\"\nfi\n\nif test \"x$PYTHON_VERSION3\" = \"xno\"; then\n    printf \"DEPRECATION NOTICE: Use of Python 2 is deprecated in favor of Python 3.5 or greater. Support for Python 2 may be removed in SST 12 or later.\\n\"\nfi\n\necho \"-------------------------------------------------------\"\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/elemLoader.cc": "// Copyright 2009-2020 NTESS. Under the terms\n// of Contract DE-NA0003525 with NTESS, the U.S.\n// Government retains certain rights in this software.\n//\n// Copyright (c) 2009-2020, NTESS\n// All rights reserved.\n//\n// This file is part of the SST software package. For license\n// information, see the LICENSE file in the top level directory of the\n// distribution.\n\n\n#include \"sst_config.h\"\n\n#include \"elemLoader.h\"\n\n#include \"sst/core/eli/elementinfo.h\"\n#include \"sst/core/component.h\"\n#include \"sst/core/subcomponent.h\"\n#include \"sst/core/part/sstpart.h\"\n#include \"sst/core/sstpart.h\"\n\n#include <ltdl.h>\n#include <vector>\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <cstring>\n\n#include <stdio.h>\n\n/* This needs to happen before lt_dlinit() and sets up the preload\n   libraries properly.  The macro declares an extern symbol, so if we\n   do this in the sst namespace, the symbol is namespaced and then not\n   found in linking.  So have this short function here.\n\n   Only do this when building with element libraries.\n   */\nstatic void preload_symbols(void) {\n// README: This is only set if we are not building any elements\n// in the split up build this is now default so must always be called.\n//#ifndef __SST_BUILD_CORE_ONLY__\n//    LTDL_SET_PRELOADED_SYMBOLS();\n//#endif\n}\n\nnamespace SST {\n\n/** This structure exists so that we don't need to have any\n   libtool-specific code (and therefore need the libtool headers) in\n   factory.h */\nstruct LoaderData {\n    /** Handle from Libtool */\n    lt_dladvise advise_handle;\n};\n\n\nElemLoader::ElemLoader(const std::string& searchPaths) :\n    searchPaths(searchPaths)\n{\n    loaderData = new LoaderData;\n    int ret = 0;\n\n    preload_symbols();\n\n\n    ret = lt_dlinit();\n    if (ret != 0) {\n        fprintf(stderr, \"lt_dlinit returned %d, %s\\n\", ret, lt_dlerror());\n        delete loaderData;\n        abort();\n    }\n\n    ret = lt_dladvise_init(&loaderData->advise_handle);\n    if (ret != 0) {\n        fprintf(stderr, \"lt_dladvise_init returned %d, %s\\n\", ret, lt_dlerror());\n        delete loaderData;\n        abort();\n    }\n\n    ret = lt_dladvise_ext(&loaderData->advise_handle);\n    if (ret != 0) {\n        fprintf(stderr, \"lt_dladvise_ext returned %d, %s\\n\", ret, lt_dlerror());\n        delete loaderData;\n        abort();\n    }\n\n    ret = lt_dladvise_global(&loaderData->advise_handle);\n    if (ret != 0) {\n        fprintf(stderr, \"lt_dladvise_global returned %d, %s\\n\", ret, lt_dlerror());\n        delete loaderData;\n        abort();\n    }\n\n    ret = lt_dlsetsearchpath(searchPaths.c_str());\n    if (ret != 0) {\n        fprintf(stderr, \"lt_dlsetsearchpath returned %d, %s\\n\", ret, lt_dlerror());\n        delete loaderData;\n        abort();\n    }\n\n}\n\n\nElemLoader::~ElemLoader()\n{\n    if ( loaderData ) {\n        lt_dladvise_destroy(&loaderData->advise_handle);\n        lt_dlexit();\n\n        delete loaderData;\n    }\n}\n\n\nstatic std::vector<std::string> splitPath(const std::string& searchPaths)\n{\n    std::vector<std::string> paths;\n    char * pathCopy = new char [searchPaths.length() + 1];\n    std::strcpy(pathCopy, searchPaths.c_str());\n    char *brkb = nullptr;\n    char *p = nullptr;\n    for ( p = strtok_r(pathCopy, \":\", &brkb); p ; p = strtok_r(nullptr, \":\", &brkb) ) {\n        paths.push_back(p);\n    }\n\n    delete [] pathCopy;\n    return paths;\n}\n\n\nstatic void followError(const std::string& libname, const std::string& elemlib, const std::string& searchPaths,\n                        std::ostream& err_os)\n{\n    std::string so_path = libname + \".so\";\n    std::string fullpath;\n    void *handle;\n\n    std::vector<std::string> paths = splitPath(searchPaths);\n\n    for ( std::string path : paths ) {\n        struct stat sbuf;\n        int ret;\n\n        fullpath = path + \"/\" + so_path;\n        ret = stat(fullpath.c_str(), &sbuf);\n        if (ret == 0) break;\n    }\n\n    // This is a little weird, but always try the last path - if we\n    // didn't succeed in the stat, we'll get a file not found error\n    // from dlopen, which is a useful error message for the user.\n    handle = dlopen(fullpath.c_str(), RTLD_NOW|RTLD_GLOBAL);\n    if (nullptr == handle) {\n        std::vector<char> err_str(1e6); //make darn sure we fit the str\n        sprintf(err_str.data(),\n          \"Opening and resolving references for element library %s failed:\\n\" \"\\t%s\\n\",\n        elemlib.c_str(), dlerror());\n        err_os << (const char*) err_str.data();\n    }\n}\n\nvoid\nElemLoader::loadLibrary(const std::string& elemlib, std::ostream& err_os)\n{\n    std::string libname = \"lib\" + elemlib;\n    lt_dlhandle lt_handle;\n    lt_handle = lt_dlopenadvise(libname.c_str(), loaderData->advise_handle);\n    if (nullptr == lt_handle) {\n      // The preopen module runs last and if the\n        // component was found earlier, but has a missing symbol or\n        // the like, we just get an amorphous \"file not found\" error,\n        // which is totally useless...\n        //Make darn sure we have enough space to hold the error message\n        std::vector<char> err_str(1e6);\n        sprintf(err_str.data(), \"Opening element library %s failed: %s\\n\",\n                elemlib.c_str(), lt_dlerror());\n        err_os << (const char*) err_str.data();\n        followError(libname, elemlib, searchPaths, err_os);\n    }\n\n    //loading a library can \"wipe\" previously loaded libraries depending\n    //on how weak symbol resolution works in dlopen\n    //rerun the loaders to make sure everything is still registered\n    for (auto& libpair : ELI::LoadedLibraries::getLoaders()){\n      //loop all the elements in the element lib\n      for (auto& elempair : libpair.second){\n        //loop all the loaders in the element\n        for (auto* loader : elempair.second){\n          loader->load();\n        }\n      }\n    }\n    return;\n}\n\nextern \"C\" {\nstatic int elemCB(const char *fname, void *vd)\n{\n    std::vector<std::string>* arr = (std::vector<std::string>*)vd;\n    const char *base = strrchr(fname, '/') + 1; /* +1 to go past the / */\n    if ( !strncmp(\"lib\", base, 3) ) { /* Filter out directories and the like */\n        arr->push_back(base + 3); /* skip past \"lib\" */\n    }\n    return 0;\n}\n}\n\nstd::vector<std::string>\nElemLoader::getPotentialElements()\n{\n    std::vector<std::string> res;\n    lt_dlforeachfile(searchPaths.c_str(), elemCB, &res);\n    return res;\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/eli/elementinfo.h": "// Copyright 2009-2020 NTESS. Under the terms\n// of Contract DE-NA0003525 with NTESS, the U.S.\n// Government retains certain rights in this software.\n//\n// Copyright (c) 2009-2020, NTESS\n// All rights reserved.\n//\n// This file is part of the SST software package. For license\n// information, see the LICENSE file in the top level directory of the\n// distribution.\n\n#ifndef SST_CORE_ELEMENTINFO_H\n#define SST_CORE_ELEMENTINFO_H\n\n#include \"sst/core/sst_types.h\"\n#include \"sst/core/warnmacros.h\"\n#include \"sst/core/params.h\"\n\n#include \"sst/core/eli/paramsInfo.h\"\n#include \"sst/core/eli/statsInfo.h\"\n#include \"sst/core/eli/defaultInfo.h\"\n#include \"sst/core/eli/portsInfo.h\"\n#include \"sst/core/eli/subcompSlotInfo.h\"\n#include \"sst/core/eli/interfaceInfo.h\"\n#include \"sst/core/eli/categoryInfo.h\"\n#include \"sst/core/eli/elementbuilder.h\"\n\n#include <string>\n#include <vector>\n\n#include \"sst/core/eli/elibase.h\"\n\nnamespace SST {\nclass Component;\nclass Module;\nclass SubComponent;\nclass BaseComponent;\nnamespace Partition {\nclass SSTPartitioner;\n}\nnamespace Statistics {\ntemplate <class T> class Statistic;\nclass StatisticBase;\n}\nclass RankInfo;\nclass SSTElementPythonModule;\n\n/****************************************************\n   Base classes for templated documentation classes\n*****************************************************/\n\nnamespace ELI {\n\ntemplate <class T>\nclass DataBase {\npublic:\n    static T* get(const std::string& elemlib, const std::string& elem){\n        if (!infos_) return nullptr;\n\n        auto libiter = infos_->find(elemlib);\n        if (libiter != infos_->end()){\n            auto& submap = libiter->second;\n            auto elemiter = submap.find(elem);\n            if (elemiter != submap.end()){\n                return elemiter->second;\n            }\n        }\n        return nullptr;\n    }\n\n    static void add(const std::string& elemlib, const std::string& elem, T* info){\n        if (!infos_){\n            infos_ = std::unique_ptr<std::map<std::string, std::map<std::string, T*>>>(\n                new std::map<std::string, std::map<std::string, T*>>);\n        }\n\n        (*infos_)[elemlib][elem] = info;\n    }\n\nprivate:\n    static std::unique_ptr<std::map<std::string, std::map<std::string, T*>>> infos_;\n};\ntemplate <class T> std::unique_ptr<std::map<std::string,std::map<std::string,T*>>> DataBase<T>::infos_;\n\n\ntemplate <class Policy, class... Policies>\nclass BuilderInfoImpl : public Policy, public BuilderInfoImpl<Policies...>\n{\n    using Parent=BuilderInfoImpl<Policies...>;\npublic:\n    template <class... Args> BuilderInfoImpl(const std::string& elemlib,\n                                             const std::string& elem,\n                                             Args&&... args)\n        : Policy(args...), Parent(elemlib, elem, args...) //forward as l-values\n        {\n            DataBase<Policy>::add(elemlib,elem,this);\n        }\n\n    template <class XMLNode> void outputXML(XMLNode* node){\n        Policy::outputXML(node);\n        Parent::outputXML(node);\n    }\n\n    void toString(std::ostream& os) const {\n        Parent::toString(os);\n        Policy::toString(os);\n    }\n};\n\ntemplate <> class BuilderInfoImpl<void> {\nprotected:\n    template <class... Args> BuilderInfoImpl(Args&&... UNUSED(args))\n        {\n        }\n\n    template <class XMLNode> void outputXML(XMLNode* UNUSED(node)){}\n\n    void toString(std::ostream& UNUSED(os)) const {}\n\n};\n\ntemplate <class Base, class T>\nstruct InstantiateBuilderInfo {\n    static bool isLoaded() {\n        return loaded;\n    }\n\n    static const bool loaded;\n};\n\ntemplate <class Base> class InfoLibrary\n{\npublic:\n    using BaseInfo = typename Base::BuilderInfo;\n\n    InfoLibrary(const std::string& name) :\n        name_(name)\n        {\n        }\n\n    BaseInfo* getInfo(const std::string& name) {\n        auto iter = infos_.find(name);\n        if (iter == infos_.end()){\n            return nullptr;\n        } else {\n            return iter->second;\n        }\n    }\n\n    bool hasInfo(const std::string& name) const {\n        return infos_.find(name) != infos_.end();\n    }\n\n    int numEntries() const {\n        return infos_.size();\n    }\n\n    const std::map<std::string, BaseInfo*>& getMap() const {\n        return infos_;\n    }\n\n    void readdInfo(const std::string& name, BaseInfo* info){\n        infos_[name] = info;\n    }\n\n    bool addInfo(const std::string& elem, BaseInfo* info){\n        readdInfo(elem, info);\n        //dlopen might thrash this later - add a loader to put it back in case\n        addLoader(name_, elem, info);\n        return true;\n    }\n\nprivate:\n    void addLoader(const std::string& lib, const std::string& name, BaseInfo* info);\n\n    std::map<std::string, BaseInfo*> infos_;\n\n    std::string name_;\n};\n\ntemplate <class Base>\nclass InfoLibraryDatabase {\npublic:\n    using Library=InfoLibrary<Base>;\n    using BaseInfo=typename Library::BaseInfo;\n    using Map=std::map<std::string,Library*>;\n\n    static Library* getLibrary(const std::string& name){\n        if (!libraries){\n            libraries = new Map;\n        }\n        auto iter = libraries->find(name);\n        if (iter == libraries->end()){\n            auto* info = new Library(name);\n            (*libraries)[name] = info;\n            return info;\n        } else {\n            return iter->second;\n        }\n    }\n\nprivate:\n    // Database - needs to be a pointer for static init order\n    static Map* libraries;\n};\n\ntemplate <class Base> typename InfoLibraryDatabase<Base>::Map*\nInfoLibraryDatabase<Base>::libraries = nullptr;\n\ntemplate <class Base, class Info>\nstruct InfoLoader : public LibraryLoader {\n  InfoLoader(const std::string& elemlib,\n                        const std::string& elem,\n                        Info* info) :\n    elemlib_(elemlib), elem_(elem), info_(info)\n  {\n  }\n\n  void load() override {\n    auto* lib = InfoLibraryDatabase<Base>::getLibrary(elemlib_);\n    if (!lib->hasInfo(elem_)){\n        lib->readdInfo(elem_, info_);\n    }\n  }\n private:\n  std::string elemlib_;\n  std::string elem_;\n  Info* info_;\n};\n\ntemplate <class Base> void InfoLibrary<Base>::addLoader(const std::string& elemlib, const std::string& elem,\n                                                        BaseInfo* info){\n   auto loader = new InfoLoader<Base,BaseInfo>(elemlib, elem, info);\n   LoadedLibraries::addLoader(elemlib, elem, loader);\n}\n\n\ntemplate <class Base> struct ElementsInfo\n{\n    static InfoLibrary<Base>* getLibrary(const std::string& name){\n        return InfoLibraryDatabase<Base>::getLibrary(name);\n    }\n\n    template <class T> static bool add(){\n        return Base::template addDerivedInfo<T>(T::ELI_getLibrary(), T::ELI_getName());\n    }\n};\ntemplate <class Base, class T> const bool InstantiateBuilderInfo<Base,T>::loaded\n= ElementsInfo<Base>::template add<T>();\n\n\nstruct InfoDatabase {\n    template <class T>\n    static InfoLibrary<T>* getLibrary(const std::string& name){\n        return InfoLibraryDatabase<T>::getLibrary(name);\n    }\n};\n\nvoid force_instantiate_bool(bool b, const char* name);\n\ntemplate <class T> struct ForceExport {\n  static bool ELI_isLoaded() {\n    return T::ELI_isLoaded();\n  }\n};\n\n} //namespace ELI\n\n\n/**************************************************************************\n  Class and constexpr functions to extract integers from version number.\n**************************************************************************/\n\nstruct SST_ELI_element_version_extraction {\n    const unsigned major;\n    const unsigned minor;\n    const unsigned tertiary;\n\n    constexpr unsigned getMajor() const { return major; }\n    constexpr unsigned getMinor() const { return minor; }\n    constexpr unsigned getTertiary() const { return tertiary; }\n};\n\nconstexpr unsigned SST_ELI_getMajorNumberFromVersion(SST_ELI_element_version_extraction ver) {\n    return ver.getMajor();\n}\n\nconstexpr unsigned SST_ELI_getMinorNumberFromVersion(SST_ELI_element_version_extraction ver) {\n    return ver.getMinor();\n}\n\nconstexpr unsigned SST_ELI_getTertiaryNumberFromVersion(SST_ELI_element_version_extraction ver) {\n    return ver.getTertiary();\n}\n\n\n/**************************************************************************\n  Macros used by elements to add element documentation\n**************************************************************************/\n\n#define SST_ELI_DECLARE_INFO(...) \\\n  using BuilderInfo = ::SST::ELI::BuilderInfoImpl<__VA_ARGS__,SST::ELI::ProvidesDefaultInfo,void>; \\\n  template <class BuilderImpl> static bool addInfo(const std::string& elemlib, const std::string& elem, \\\n                                            BuilderImpl* info){ \\\n    return ::SST::ELI::InfoDatabase::getLibrary<__LocalEliBase>(elemlib)->addInfo(elem,info); \\\n  } \\\n  SST_ELI_DECLARE_INFO_COMMON()\n\n\n#define SST_ELI_DECLARE_DEFAULT_INFO() \\\n  using BuilderInfo = ::SST::ELI::BuilderInfoImpl<SST::ELI::ProvidesDefaultInfo,void>; \\\n  template <class BuilderImpl> static bool addInfo(const std::string& elemlib, const std::string& elem, \\\n                                                   BuilderImpl* info){ \\\n    return ::SST::ELI::InfoDatabase::getLibrary<__LocalEliBase>(elemlib)->addInfo(elem,info); \\\n  } \\\n  SST_ELI_DECLARE_INFO_COMMON()\n\n\n#define SST_ELI_DECLARE_INFO_EXTERN(...) \\\n  using BuilderInfo = ::SST::ELI::BuilderInfoImpl<SST::ELI::ProvidesDefaultInfo,__VA_ARGS__,void>; \\\n  static bool addInfo(const std::string& elemlib, const std::string& elem, BuilderInfo* info); \\\n  SST_ELI_DECLARE_INFO_COMMON()\n\n#define SST_ELI_DECLARE_DEFAULT_INFO_EXTERN() \\\n  using BuilderInfo = ::SST::ELI::BuilderInfoImpl<SST::ELI::ProvidesDefaultInfo,void>; \\\n  static bool addInfo(const std::string& elemlib, const std::string& elem, BuilderInfo* info); \\\n  SST_ELI_DECLARE_INFO_COMMON()\n\n#define SST_ELI_DEFINE_INFO_EXTERN(base) \\\n  bool base::addInfo(const std::string& elemlib, const std::string& elem, BuilderInfo* info){ \\\n    return ::SST::ELI::InfoDatabase::getLibrary<__LocalEliBase>(elemlib)->addInfo(elem,info); \\\n  }\n\n#define SST_ELI_EXTERN_DERIVED(base,cls,lib,name,version,desc) \\\n  bool ELI_isLoaded(); \\\n  SST_ELI_DEFAULT_INFO(lib,name,ELI_FORWARD_AS_ONE(version),desc)\n\n// The Intel compilers do not correctly instantiate symbols\n// even though they are required. We have to force the instantiation\n// in source files, header files are not good enough\n// we do this by creating a static bool that produces an undefined ref\n// if the instantiate macro is missing in a source file\n#ifdef __INTEL_COMPILER\n#define SST_ELI_FORCE_INSTANTIATION(base,cls) \\\n  template <class T> \\\n  struct ELI_ForceRegister { \\\n    ELI_ForceRegister(){  \\\n      bool b = SST::ELI::InstantiateBuilder<base,cls>::isLoaded() \\\n        && SST::ELI::InstantiateBuilderInfo<base,cls>::isLoaded(); \\\n      SST::ELI::force_instantiate_bool(b, #cls); \\\n    } \\\n  }; \\\n  ELI_ForceRegister<cls> force_instantiate;\n// if the implementation is entirely in a C++ file\n// the Intel compiler will not generate any code because\n// it none of the symbols can be observed by other files\n// this forces the Intel compiler to export symbols self-contained in a C++ file\n#define SST_ELI_EXPORT(cls) \\\n  template class SST::ELI::ForceExport<cls>;\n#else\n#define SST_ELI_FORCE_INSTANTIATION(base,cls)\n#define SST_ELI_EXPORT(cls)\n#endif\n\n\n#define SST_ELI_REGISTER_DERIVED(base,cls,lib,name,version,desc) \\\n  static bool ELI_isLoaded() { \\\n    return SST::ELI::InstantiateBuilder<base,cls>::isLoaded() \\\n      && SST::ELI::InstantiateBuilderInfo<base,cls>::isLoaded(); \\\n  } \\\n  SST_ELI_FORCE_INSTANTIATION(base,cls) \\\n  SST_ELI_DEFAULT_INFO(lib,name,ELI_FORWARD_AS_ONE(version),desc)\n\n#define SST_ELI_REGISTER_EXTERN(base,cls) \\\n  bool cls::ELI_isLoaded(){ \\\n    return SST::ELI::InstantiateBuilder<base,cls>::isLoaded() \\\n      && SST::ELI::InstantiateBuilderInfo<base,cls>::isLoaded(); \\\n  }\n\n\n} //namespace SST\n\n#endif // SST_CORE_ELEMENTINFO_H\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/testingframework/pdoc_template/SSTLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/xmltest.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/utf8test.gif",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlAttribute.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlDeclaration.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlDocument.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlNode.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlVisitor.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlComment.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlPrinter.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlText.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlUnknown.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlElement.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/classTiXmlBase.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/src/sst/core/tinyxml/docs/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/.git/objects/pack/pack-556ce22dd34587aba233bd546de05ebb1e2c3555.pack",
        "/tmp/vanessa/spack-stage/spack-stage-sst-core-master-c35dluixmkk53hwk3tgpzjlnplai2ssm/spack-src/.git/objects/pack/pack-556ce22dd34587aba233bd546de05ebb1e2c3555.idx"
    ],
    "total_files": 525
}