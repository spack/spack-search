{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/configure.ac": "###############################################################################\n## Copyright (C) 2000-2004 Sistina Software, Inc. All rights reserved.\n## Copyright (C) 2004-2016 Red Hat, Inc. All rights reserved.\n##\n## This copyrighted material is made available to anyone wishing to use,\n## modify, copy, or redistribute it subject to the terms and conditions\n## of the GNU General Public License v.2.\n##\n## You should have received a copy of the GNU General Public License\n## along with this program; if not, write to the Free Software Foundation,\n## Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n################################################################################\n\nAC_PREREQ(2.69)\n################################################################################\ndnl -- Process this file with autoconf to produce a configure script.\nAC_INIT\nCONFIGURE_LINE=\"$0 $@\"\nAC_CONFIG_SRCDIR([lib/device/dev-cache.h])\nAC_CONFIG_HEADERS([include/configure.h])\n\n################################################################################\ndnl -- Setup the directory where autoconf has auxilary files\nAC_CONFIG_AUX_DIR(autoconf)\n\n################################################################################\ndnl -- Get system type\nAC_CANONICAL_TARGET([])\n\nAS_IF([test -z \"$CFLAGS\"], [COPTIMISE_FLAG=\"-O2\"])\ncase \"$host_os\" in\n\tlinux*)\n\t\tCLDFLAGS=\"${CLDFLAGS:\"$LDFLAGS\"} -Wl,--version-script,.export.sym\"\n\t\t# equivalent to -rdynamic\n\t\tELDFLAGS=\"-Wl,--export-dynamic\"\n\t\t# FIXME Generate list and use --dynamic-list=.dlopen.sym\n\t\tCLDWHOLEARCHIVE=\"-Wl,-whole-archive\"\n\t\tCLDNOWHOLEARCHIVE=\"-Wl,-no-whole-archive\"\n\t\tLDDEPS=\"$LDDEPS .export.sym\"\n\t\tLIB_SUFFIX=so\n\t\tDEVMAPPER=yes\n\t\tBUILD_LVMPOLLD=no\n\t\tLOCKDSANLOCK=no\n\t\tLOCKDDLM=no\n\t\tODIRECT=yes\n\t\tDM_IOCTLS=yes\n\t\tSELINUX=yes\n\t\tFSADM=yes\n\t\tBLKDEACTIVATE=yes\n\t\t;;\n\tdarwin*)\n\t\tCFLAGS=\"$CFLAGS -no-cpp-precomp -fno-common\"\n\t\tCLDFLAGS=\"${CLDFLAGS:\"$LDFLAGS\"}\"\n\t\tELDFLAGS=\n\t\tCLDWHOLEARCHIVE=\"-all_load\"\n\t\tCLDNOWHOLEARCHIVE=\n\t\tLIB_SUFFIX=dylib\n\t\tDEVMAPPER=yes\n\t\tODIRECT=no\n\t\tDM_IOCTLS=no\n\t\tSELINUX=no\n\t\tFSADM=no\n\t\tBLKDEACTIVATE=no\n\t\t;;\n\t*)\n\t\tCLDFLAGS=\"${CLDFLAGS:\"$LDFLAGS\"}\"\n\t\t;;\nesac\n\n################################################################################\ndnl -- Checks for programs.\nAC_PROG_SED\nAC_PROG_AWK\nsave_CFLAGS=$CFLAGS\nsave_CXXFLAGS=$CXXFLAGS\nAC_PROG_CC\nAC_PROG_CXX\nCFLAGS=$save_CFLAGS\nCXXFLAGS=$save_CXXFLAGS\nPATH_SBIN=\"$PATH:/usr/sbin:/sbin\"\n\ndnl probably no longer needed in 2008, but...\nAC_PROG_GCC_TRADITIONAL\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_MKDIR_P\nAC_PROG_RANLIB\nAC_CHECK_TOOL(AR, ar)\nAC_PATH_TOOL(CFLOW_CMD, cflow)\nAC_PATH_TOOL(CSCOPE_CMD, cscope)\nAC_PATH_TOOL(CHMOD, chmod)\nAC_PATH_TOOL(WC, wc)\nAC_PATH_TOOL(SORT, sort)\n\n################################################################################\ndnl -- Check for header files.\nAC_HEADER_DIRENT\nAC_HEADER_MAJOR\nAC_HEADER_STDBOOL\nAC_HEADER_STDC\nAC_HEADER_SYS_WAIT\nAC_HEADER_TIME\n\nAC_CHECK_HEADERS([assert.h ctype.h dirent.h errno.h fcntl.h float.h \\\n  getopt.h inttypes.h langinfo.h libaio.h libgen.h limits.h locale.h paths.h \\\n  signal.h stdarg.h stddef.h stdio.h stdlib.h string.h sys/file.h \\\n  sys/ioctl.h syslog.h sys/mman.h sys/param.h sys/resource.h sys/stat.h \\\n  sys/time.h sys/types.h sys/utsname.h sys/wait.h time.h \\\n  unistd.h], , [AC_MSG_ERROR(bailing out)])\n\nAC_CHECK_HEADERS(termios.h sys/statvfs.h sys/timerfd.h sys/vfs.h linux/magic.h linux/fiemap.h)\n\ncase \"$host_os\" in\n\tlinux*)\n\t\tAC_CHECK_HEADERS(asm/byteorder.h linux/fs.h malloc.h,,AC_MSG_ERROR(bailing out)) ;;\n\tdarwin*)\n\t\tAC_CHECK_HEADERS(machine/endian.h sys/disk.h,,AC_MSG_ERROR(bailing out)) ;;\nesac\n\n################################################################################\ndnl -- Check for typedefs, structures, and compiler characteristics.\nAC_C_CONST\nAC_C_INLINE\nAC_CHECK_MEMBERS([struct stat.st_rdev])\nAC_CHECK_TYPES([ptrdiff_t])\nAC_STRUCT_ST_BLOCKS\nAC_STRUCT_TM\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIGNAL\nAC_TYPE_SIZE_T\nAC_TYPE_MODE_T\nAC_TYPE_INT8_T\nAC_TYPE_INT16_T\nAC_TYPE_INT32_T\nAC_TYPE_INT64_T\nAC_TYPE_SSIZE_T\nAC_TYPE_UID_T\nAC_TYPE_UINT8_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\nAX_GCC_BUILTIN([__builtin_clz])\nAX_GCC_BUILTIN([__builtin_clzll])\n\n################################################################################\ndnl -- Check for functions\nAC_CHECK_FUNCS([ftruncate gethostname getpagesize gettimeofday localtime_r \\\n  memchr memset mkdir mkfifo munmap nl_langinfo realpath rmdir setenv \\\n  setlocale strcasecmp strchr strcspn strdup strerror strncasecmp strndup \\\n  strrchr strspn strstr strtol strtoul uname], , [AC_MSG_ERROR(bailing out)])\nAC_FUNC_ALLOCA\nAC_FUNC_CLOSEDIR_VOID\nAC_FUNC_CHOWN\nAC_FUNC_FORK\nAC_FUNC_LSTAT\nAC_FUNC_MALLOC\nAC_FUNC_MEMCMP\nAC_FUNC_MKTIME\nAC_FUNC_MMAP\nAC_FUNC_REALLOC\nAC_FUNC_STAT\nAC_FUNC_STRTOD\nAC_FUNC_VPRINTF\n\n################################################################################\ndnl -- Disable dependency tracking\nAC_MSG_CHECKING(whether to enable dependency tracking)\nAC_ARG_ENABLE(dependency-tracking,\n\t      AC_HELP_STRING([--disable-dependency-tracking],\n\t\t\t     [speeds up one-time build.]),\n\t      USE_TRACKING=$enableval, USE_TRACKING=yes)\nAC_MSG_RESULT($USE_TRACKING)\n\n################################################################################\ndnl -- Disable silence rules\nAC_MSG_CHECKING(whether to build silently)\nAC_ARG_ENABLE(silent-rules,\n\t      AC_HELP_STRING([--disable-silent-rules], [disable silent building]),\n\t      SILENT_RULES=$enableval, SILENT_RULES=yes)\nAC_MSG_RESULT($SILENT_RULES)\n\n\n################################################################################\ndnl -- Enables statically-linked tools\nAC_MSG_CHECKING(whether to use static linking)\nAC_ARG_ENABLE(static_link,\n\t      AC_HELP_STRING([--enable-static_link],\n\t\t\t     [use this to link the tools to their libraries\n\t\t\t      statically (default is dynamic linking]),\n\t      STATIC_LINK=$enableval, STATIC_LINK=no)\nAC_MSG_RESULT($STATIC_LINK)\n\n################################################################################\ndnl -- Check if compiler/linker supports PIE and RELRO\nAC_TRY_CCFLAG([-pie], [HAVE_PIE], [], [])\nAC_SUBST(HAVE_PIE)\nAC_TRY_LDFLAGS([-Wl,-z,relro,-z,now], [HAVE_FULL_RELRO], [], [])\nAC_SUBST(HAVE_FULL_RELRO)\n\n################################################################################\ndnl -- Prefix is /usr by default, the exec_prefix default is setup later\nAC_PREFIX_DEFAULT(/usr)\n\n################################################################################\ndnl -- Clear default exec_prefix - install into /sbin rather than /usr/sbin\ntest \"$exec_prefix\" = NONE -a \"$prefix\" = NONE && exec_prefix=\"\"\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\n\n################################################################################\ndnl -- Setup the ownership of the files\nAC_MSG_CHECKING(file owner)\nAC_ARG_WITH(user,\n\t    AC_HELP_STRING([--with-user=USER],\n\t\t\t   [set the owner of installed files [USER=]]),\n\t    OWNER=$withval)\nAC_MSG_RESULT($OWNER)\ntest -n \"$OWNER\" && INSTALL=\"$INSTALL -o $OWNER\"\n\n################################################################################\ndnl -- Setup the group ownership of the files\nAC_MSG_CHECKING(group owner)\nAC_ARG_WITH(group,\n\t    AC_HELP_STRING([--with-group=GROUP],\n\t\t\t   [set the group owner of installed files [GROUP=]]),\n\t    GROUP=$withval)\nAC_MSG_RESULT($GROUP)\ntest -n \"$GROUP\" && INSTALL=\"$INSTALL -g $GROUP\"\n\n################################################################################\ndnl -- Setup device node ownership\nAC_MSG_CHECKING(device node uid)\n\nAC_ARG_WITH(device-uid,\n\t    AC_HELP_STRING([--with-device-uid=UID],\n\t\t\t   [set the owner used for new device nodes [UID=0]]),\n\t    DM_DEVICE_UID=$withval, DM_DEVICE_UID=0)\nAC_MSG_RESULT($DM_DEVICE_UID)\nAC_DEFINE_UNQUOTED([DM_DEVICE_UID], [$DM_DEVICE_UID], [Define default owner for device node])\n\n################################################################################\ndnl -- Setup device group ownership\nAC_MSG_CHECKING(device node gid)\n\nAC_ARG_WITH(device-gid,\n\t    AC_HELP_STRING([--with-device-gid=GID],\n\t\t\t   [set the group used for new device nodes [GID=0]]),\n\t    DM_DEVICE_GID=$withval, DM_DEVICE_GID=0)\nAC_MSG_RESULT($DM_DEVICE_GID)\nAC_DEFINE_UNQUOTED([DM_DEVICE_GID], [$DM_DEVICE_GID], [Define default group for device node])\n\n################################################################################\ndnl -- Setup device mode\nAC_MSG_CHECKING(device node mode)\n\nAC_ARG_WITH(device-mode,\n\t    AC_HELP_STRING([--with-device-mode=MODE],\n\t\t\t   [set the mode used for new device nodes [MODE=0600]]),\n\t    DM_DEVICE_MODE=$withval, DM_DEVICE_MODE=0600)\nAC_MSG_RESULT($DM_DEVICE_MODE)\nAC_DEFINE_UNQUOTED([DM_DEVICE_MODE], [$DM_DEVICE_MODE], [Define default mode for device node])\n\nAC_MSG_CHECKING(when to create device nodes)\nAC_ARG_WITH(device-nodes-on,\n\t    AC_HELP_STRING([--with-device-nodes-on=ON],\n\t\t\t   [create nodes on resume or create [ON=resume]]),\n\t    ADD_NODE=$withval, ADD_NODE=resume)\ncase \"$ADD_NODE\" in\n resume) add_on=DM_ADD_NODE_ON_RESUME;;\n create) add_on=DM_ADD_NODE_ON_CREATE;;\n *) AC_MSG_ERROR([--with-device-nodes-on parameter invalid]);;\nesac\nAC_MSG_RESULT(on $ADD_NODE)\nAC_DEFINE_UNQUOTED([DEFAULT_DM_ADD_NODE], $add_on, [Define default node creation behavior with dmsetup create])\n\nAC_MSG_CHECKING(default name mangling)\nAC_ARG_WITH(default-name-mangling,\n\t    AC_HELP_STRING([--with-default-name-mangling=MANGLING],\n\t\t\t   [default name mangling: auto/none/hex [auto]]),\n\t    MANGLING=$withval, MANGLING=auto)\ncase \"$MANGLING\" in\n auto) mangling=DM_STRING_MANGLING_AUTO;;\n none|disabled) mangling=DM_STRING_MANGLING_NONE;;\n hex) mangling=DM_STRING_MANGLING_HEX;;\n *) AC_MSG_ERROR([--with-default-name-mangling parameter invalid]);;\nesac\nAC_MSG_RESULT($MANGLING)\nAC_DEFINE_UNQUOTED([DEFAULT_DM_NAME_MANGLING], $mangling, [Define default name mangling behaviour])\n\n################################################################################\ndnl -- snapshots inclusion type\nAC_MSG_CHECKING(whether to include snapshots)\nAC_ARG_WITH(snapshots,\n\t    AC_HELP_STRING([--with-snapshots=TYPE],\n\t\t\t   [snapshot support: internal/shared/none [internal]]),\n\t    SNAPSHOTS=$withval, SNAPSHOTS=internal)\nAC_MSG_RESULT($SNAPSHOTS)\n\ncase \"$SNAPSHOTS\" in\n  none|shared) ;;\n  internal) AC_DEFINE([SNAPSHOT_INTERNAL], 1,\n\t\t      [Define to 1 to include built-in support for snapshots.]) ;;\n  *) AC_MSG_ERROR([--with-snapshots parameter invalid]) ;;\nesac\n\n################################################################################\ndnl -- mirrors inclusion type\nAC_MSG_CHECKING(whether to include mirrors)\nAC_ARG_WITH(mirrors,\n\t    AC_HELP_STRING([--with-mirrors=TYPE],\n\t\t\t   [mirror support: internal/shared/none [internal]]),\n\t    MIRRORS=$withval, MIRRORS=internal)\nAC_MSG_RESULT($MIRRORS)\n\ncase \"$MIRRORS\" in\n  none|shared) ;;\n  internal) AC_DEFINE([MIRRORED_INTERNAL], 1,\n\t\t      [Define to 1 to include built-in support for mirrors.]) ;;\n  *) AC_MSG_ERROR([--with-mirrors parameter invalid]) ;;\nesac\n\n################################################################################\ndnl -- raid inclusion type\nAC_ARG_WITH(default-mirror-segtype,\n\t    AC_HELP_STRING([--with-default-mirror-segtype=TYPE],\n\t\t\t   [default mirror segtype: raid1/mirror [raid1]]),\n\t\t\t   DEFAULT_MIRROR_SEGTYPE=$withval, DEFAULT_MIRROR_SEGTYPE=\"raid1\")\nAC_ARG_WITH(default-raid10-segtype,\n\t    AC_HELP_STRING([--with-default-raid10-segtype=TYPE],\n\t\t\t   [default mirror segtype: raid10/mirror [raid10]]),\n\t\t\t   DEFAULT_RAID10_SEGTYPE=$withval, DEFAULT_RAID10_SEGTYPE=\"raid10\")\n\nAC_DEFINE([RAID_INTERNAL], 1,\n\t  [Define to 1 to include built-in support for raid.])\n\nAC_DEFINE_UNQUOTED([DEFAULT_MIRROR_SEGTYPE], [\"$DEFAULT_MIRROR_SEGTYPE\"],\n\t\t   [Default segtype used for mirror volumes.])\n\nAC_DEFINE_UNQUOTED([DEFAULT_RAID10_SEGTYPE], [\"$DEFAULT_RAID10_SEGTYPE\"],\n\t\t   [Default segtype used for raid10 volumes.])\n\n################################################################################\nAC_ARG_WITH(default-sparse-segtype,\n\t    AC_HELP_STRING([--with-default-sparse-segtype=TYPE],\n\t\t\t   [default sparse segtype: thin/snapshot [thin]]),\n\t\t\t   DEFAULT_SPARSE_SEGTYPE=$withval, DEFAULT_SPARSE_SEGTYPE=\"thin\")\n\n################################################################################\ndnl -- thin provisioning\nAC_MSG_CHECKING(whether to include thin provisioning)\nAC_ARG_WITH(thin,\n\t    AC_HELP_STRING([--with-thin=TYPE],\n\t\t\t   [thin provisioning support: internal/shared/none [internal]]),\n\t    THIN=$withval, THIN=internal)\nAC_ARG_WITH(thin-check,\n\t    AC_HELP_STRING([--with-thin-check=PATH],\n\t\t\t   [thin_check tool: [autodetect]]),\n\t\t\t   THIN_CHECK_CMD=$withval, THIN_CHECK_CMD=\"autodetect\")\nAC_ARG_WITH(thin-dump,\n\t    AC_HELP_STRING([--with-thin-dump=PATH],\n\t\t\t   [thin_dump tool: [autodetect]]),\n\t\t\t   THIN_DUMP_CMD=$withval, THIN_DUMP_CMD=\"autodetect\")\nAC_ARG_WITH(thin-repair,\n\t    AC_HELP_STRING([--with-thin-repair=PATH],\n\t\t\t   [thin_repair tool: [autodetect]]),\n\t\t\t   THIN_REPAIR_CMD=$withval, THIN_REPAIR_CMD=\"autodetect\")\nAC_ARG_WITH(thin-restore,\n\t    AC_HELP_STRING([--with-thin-restore=PATH],\n\t\t\t   [thin_restore tool: [autodetect]]),\n\t\t\t   THIN_RESTORE_CMD=$withval, THIN_RESTORE_CMD=\"autodetect\")\n\nAC_MSG_RESULT($THIN)\n\ncase \"$THIN\" in\n  none)  test \"$DEFAULT_SPARSE_SEGTYPE\" = \"thin\" && DEFAULT_SPARSE_SEGTYPE=\"snapshot\" ;;\n  shared) ;;\n  internal) AC_DEFINE([THIN_INTERNAL], 1,\n\t\t      [Define to 1 to include built-in support for thin provisioning.]) ;;\n  *) AC_MSG_ERROR([--with-thin parameter invalid ($THIN)]) ;;\nesac\n\nAC_DEFINE_UNQUOTED([DEFAULT_SPARSE_SEGTYPE], [\"$DEFAULT_SPARSE_SEGTYPE\"],\n\t\t   [Default segtype used for sparse volumes.])\n\ndnl -- thin_check needs-check flag\nAC_ARG_ENABLE(thin_check_needs_check,\n\t      AC_HELP_STRING([--disable-thin_check_needs_check],\n\t\t\t     [required if thin_check version is < 0.3.0]),\n\t      THIN_CHECK_NEEDS_CHECK=$enableval, THIN_CHECK_NEEDS_CHECK=yes)\n\n# Test if necessary thin tools are available\n# if not - use plain defaults and warn user\ncase \"$THIN\" in\n  internal|shared)\n\t# Empty means a config way to ignore thin checking\n\tif test \"$THIN_CHECK_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(THIN_CHECK_CMD, thin_check, [], [$PATH_SBIN])\n\t\tif test -z \"$THIN_CHECK_CMD\"; then\n\t\t\tAC_MSG_WARN([thin_check not found in path $PATH])\n\t\t\tTHIN_CHECK_CMD=/usr/sbin/thin_check\n\t\t\tTHIN_CONFIGURE_WARN=y\n\t\tfi\n\tfi\n\tif test \"$THIN_CHECK_NEEDS_CHECK\" = yes; then\n\t\tTHIN_CHECK_VSN=`\"$THIN_CHECK_CMD\" -V 2>/dev/null`\n\t\tTHIN_CHECK_VSN_MAJOR=`echo \"$THIN_CHECK_VSN\" | $AWK -F '.' '{print $1}'`\n\t\tTHIN_CHECK_VSN_MINOR=`echo \"$THIN_CHECK_VSN\" | $AWK -F '.' '{print $2}'`\n\n\t\tif test -z \"$THIN_CHECK_VSN_MAJOR\" -o -z \"$THIN_CHECK_VSN_MINOR\"; then\n\t\t\tAC_MSG_WARN([$THIN_CHECK_CMD: Bad version \"$THIN_CHECK_VSN\" found])\n\t\t\tTHIN_CHECK_VERSION_WARN=y\n\t\t\tTHIN_CHECK_NEEDS_CHECK=no\n\t\telif test \"$THIN_CHECK_VSN_MAJOR\" -eq 0 -a \"$THIN_CHECK_VSN_MINOR\" -lt 3; then\n\t\t\tAC_MSG_WARN([$THIN_CHECK_CMD: Old version \"$THIN_CHECK_VSN\" found])\n\t\t\tTHIN_CHECK_VERSION_WARN=y\n\t\t\tTHIN_CHECK_NEEDS_CHECK=no\n\t\tfi\n\tfi\n\t# Empty means a config way to ignore thin dumping\n\tif test \"$THIN_DUMP_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(THIN_DUMP_CMD, thin_dump, [], [$PATH_SBIN])\n\t\ttest -z \"$THIN_DUMP_CMD\" && {\n\t\t\tAC_MSG_WARN(thin_dump not found in path $PATH)\n\t\t\tTHIN_DUMP_CMD=/usr/sbin/thin_dump\n\t\t\tTHIN_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\t# Empty means a config way to ignore thin repairing\n\tif test \"$THIN_REPAIR_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(THIN_REPAIR_CMD, thin_repair, [], [$PATH_SBIN])\n\t\ttest -z \"$THIN_REPAIR_CMD\" && {\n\t\t\tAC_MSG_WARN(thin_repair not found in path $PATH)\n\t\t\tTHIN_REPAIR_CMD=/usr/sbin/thin_repair\n\t\t\tTHIN_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\t# Empty means a config way to ignore thin restoring\n\tif test \"$THIN_RESTORE_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(THIN_RESTORE_CMD, thin_restore, [], [$PATH_SBIN])\n\t\ttest -z \"$THIN_RESTORE_CMD\" && {\n\t\t\tAC_MSG_WARN(thin_restore not found in path $PATH)\n\t\t\tTHIN_RESTORE_CMD=/usr/sbin/thin_restore\n\t\t\tTHIN_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\n\tAC_MSG_CHECKING([whether thin_check supports the needs-check flag])\n\tAC_MSG_RESULT([$THIN_CHECK_NEEDS_CHECK])\n\tif test \"$THIN_CHECK_NEEDS_CHECK\" = yes; then\n\t\tAC_DEFINE([THIN_CHECK_NEEDS_CHECK], 1, [Define to 1 if the external 'thin_check' tool requires the --clear-needs-check-flag option])\n\tfi\n\n\t;;\nesac\n\nAC_DEFINE_UNQUOTED([THIN_CHECK_CMD], [\"$THIN_CHECK_CMD\"],\n\t\t   [The path to 'thin_check', if available.])\n\nAC_DEFINE_UNQUOTED([THIN_DUMP_CMD], [\"$THIN_DUMP_CMD\"],\n\t\t   [The path to 'thin_dump', if available.])\n\nAC_DEFINE_UNQUOTED([THIN_REPAIR_CMD], [\"$THIN_REPAIR_CMD\"],\n\t\t   [The path to 'thin_repair', if available.])\n\nAC_DEFINE_UNQUOTED([THIN_RESTORE_CMD], [\"$THIN_RESTORE_CMD\"],\n\t\t   [The path to 'thin_restore', if available.])\n\n################################################################################\ndnl -- cache inclusion type\nAC_MSG_CHECKING(whether to include cache)\nAC_ARG_WITH(cache,\n\t    AC_HELP_STRING([--with-cache=TYPE],\n\t\t\t   [cache support: internal/shared/none [internal]]),\n\t\t\t   CACHE=$withval, CACHE=\"internal\")\nAC_ARG_WITH(cache-check,\n\t    AC_HELP_STRING([--with-cache-check=PATH],\n\t\t\t   [cache_check tool: [autodetect]]),\n\t\t\t   CACHE_CHECK_CMD=$withval, CACHE_CHECK_CMD=\"autodetect\")\nAC_ARG_WITH(cache-dump,\n\t    AC_HELP_STRING([--with-cache-dump=PATH],\n\t\t\t   [cache_dump tool: [autodetect]]),\n\t\t\t   CACHE_DUMP_CMD=$withval, CACHE_DUMP_CMD=\"autodetect\")\nAC_ARG_WITH(cache-repair,\n\t    AC_HELP_STRING([--with-cache-repair=PATH],\n\t\t\t   [cache_repair tool: [autodetect]]),\n\t\t\t   CACHE_REPAIR_CMD=$withval, CACHE_REPAIR_CMD=\"autodetect\")\nAC_ARG_WITH(cache-restore,\n\t    AC_HELP_STRING([--with-cache-restore=PATH],\n\t\t\t   [cache_restore tool: [autodetect]]),\n\t\t\t   CACHE_RESTORE_CMD=$withval, CACHE_RESTORE_CMD=\"autodetect\")\nAC_MSG_RESULT($CACHE)\n\ncase \"$CACHE\" in\n none|shared) ;;\n internal) AC_DEFINE([CACHE_INTERNAL], 1, [Define to 1 to include built-in support for cache.]) ;;\n *) AC_MSG_ERROR([--with-cache parameter invalid]) ;;\nesac\n\ndnl -- cache_check needs-check flag\nAC_ARG_ENABLE(cache_check_needs_check,\n\t      AC_HELP_STRING([--disable-cache_check_needs_check],\n\t\t\t     [required if cache_check version is < 0.5]),\n\t      CACHE_CHECK_NEEDS_CHECK=$enableval, CACHE_CHECK_NEEDS_CHECK=yes)\n\n# Test if necessary cache tools are available\n# if not - use plain defaults and warn user\ncase \"$CACHE\" in\n  internal|shared)\n\t# Empty means a config way to ignore cache checking\n\tif test \"$CACHE_CHECK_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(CACHE_CHECK_CMD, cache_check, [], [$PATH_SBIN])\n\t\tif test -z \"$CACHE_CHECK_CMD\"; then\n\t\t\tAC_MSG_WARN([cache_check not found in path $PATH])\n\t\t\tCACHE_CHECK_CMD=/usr/sbin/cache_check\n\t\t\tCACHE_CONFIGURE_WARN=y\n\t\tfi\n\tfi\n\tif test \"$CACHE_CHECK_NEEDS_CHECK\" = yes; then\n\t\t$CACHE_CHECK_CMD -V 2>/dev/null >conftest.tmp\n\t\tread -r CACHE_CHECK_VSN < conftest.tmp\n\t\tIFS=.- read -r CACHE_CHECK_VSN_MAJOR CACHE_CHECK_VSN_MINOR CACHE_CHECK_VSN_PATCH LEFTOVER < conftest.tmp\n\t\trm -f conftest.tmp\n\n\t\t# Require version >= 0.5.4 for --clear-needs-check-flag\n\t\tif test -z \"$CACHE_CHECK_VSN_MAJOR\" \\\n\t\t\t|| test -z \"$CACHE_CHECK_VSN_MINOR\" \\\n\t\t\t|| test -z \"$CACHE_CHECK_VSN_PATCH\"; then\n\t\t\tAC_MSG_WARN([$CACHE_CHECK_CMD: Bad version \"$CACHE_CHECK_VSN\" found])\n\t\t\tCACHE_CHECK_VERSION_WARN=y\n\t\t\tCACHE_CHECK_NEEDS_CHECK=no\n\t\telif test \"$CACHE_CHECK_VSN_MAJOR\" -eq 0 ; then\n\t\t\tif test \"$CACHE_CHECK_VSN_MINOR\" -lt 5 \\\n\t\t\t\t|| test \"$CACHE_CHECK_VSN_MINOR\" -eq 5 -a \"$CACHE_CHECK_VSN_PATCH\" -lt 4; then\n\t\t\t\tAC_MSG_WARN([$CACHE_CHECK_CMD: Old version \"$CACHE_CHECK_VSN\" found])\n\t\t\t\tCACHE_CHECK_VERSION_WARN=y\n\t\t\t\tCACHE_CHECK_NEEDS_CHECK=no\n\t\t\tfi\n\t\t\tif test \"$CACHE_CHECK_VSN_MINOR\" -lt 7 ; then\n\t\t\t\tAC_MSG_WARN([$CACHE_CHECK_CMD: Old version \"$CACHE_CHECK_VSN\" does not support new cache format V2])\n\t\t\t\tCACHE_CHECK_VERSION_WARN=y\n\t\t\tfi\n\t\tfi\n\tfi\n\t# Empty means a config way to ignore cache dumping\n\tif test \"$CACHE_DUMP_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(CACHE_DUMP_CMD, cache_dump, [], [$PATH_SBIN])\n\t\ttest -z \"$CACHE_DUMP_CMD\" && {\n\t\t\tAC_MSG_WARN(cache_dump not found in path $PATH)\n\t\t\tCACHE_DUMP_CMD=/usr/sbin/cache_dump\n\t\t\tCACHE_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\t# Empty means a config way to ignore cache repairing\n\tif test \"$CACHE_REPAIR_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(CACHE_REPAIR_CMD, cache_repair, [], [$PATH_SBIN])\n\t\ttest -z \"$CACHE_REPAIR_CMD\" && {\n\t\t\tAC_MSG_WARN(cache_repair not found in path $PATH)\n\t\t\tCACHE_REPAIR_CMD=/usr/sbin/cache_repair\n\t\t\tCACHE_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\t# Empty means a config way to ignore cache restoring\n\tif test \"$CACHE_RESTORE_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(CACHE_RESTORE_CMD, cache_restore, [], [$PATH_SBIN])\n\t\ttest -z \"$CACHE_RESTORE_CMD\" && {\n\t\t\tAC_MSG_WARN(cache_restore not found in path $PATH)\n\t\t\tCACHE_RESTORE_CMD=/usr/sbin/cache_restore\n\t\t\tCACHE_CONFIGURE_WARN=y\n\t\t}\n\tfi\n\n\tAC_MSG_CHECKING([whether cache_check supports the needs-check flag])\n\tAC_MSG_RESULT([$CACHE_CHECK_NEEDS_CHECK])\n\tif test \"$CACHE_CHECK_NEEDS_CHECK\" = yes; then\n\t\tAC_DEFINE([CACHE_CHECK_NEEDS_CHECK], 1, [Define to 1 if the external 'cache_check' tool requires the --clear-needs-check-flag option])\n\tfi\n\t;;\nesac\n\nAC_DEFINE_UNQUOTED([CACHE_CHECK_CMD], [\"$CACHE_CHECK_CMD\"],\n\t\t   [The path to 'cache_check', if available.])\n\nAC_DEFINE_UNQUOTED([CACHE_DUMP_CMD], [\"$CACHE_DUMP_CMD\"],\n\t\t   [The path to 'cache_dump', if available.])\n\nAC_DEFINE_UNQUOTED([CACHE_REPAIR_CMD], [\"$CACHE_REPAIR_CMD\"],\n\t\t   [The path to 'cache_repair', if available.])\n\nAC_DEFINE_UNQUOTED([CACHE_RESTORE_CMD], [\"$CACHE_RESTORE_CMD\"],\n\t\t   [The path to 'cache_restore', if available.])\n\n################################################################################\ndnl -- cache inclusion type\nAC_MSG_CHECKING(whether to include vdo)\nAC_ARG_WITH(vdo,\n\t    AC_HELP_STRING([--with-vdo=TYPE],\n\t\t\t   [vdo support: internal/none [internal]]),\n\t\t\t   VDO=$withval, VDO=\"none\")\n\nAC_MSG_RESULT($VDO)\n\nAC_ARG_WITH(vdo-format,\n\t    AC_HELP_STRING([--with-vdo-format=PATH],\n\t\t\t   [vdoformat tool: [autodetect]]),\n\t\t\t   VDO_FORMAT_CMD=$withval, VDO_FORMAT_CMD=\"autodetect\")\ncase \"$VDO\" in\n none) ;;\n internal) \n\tAC_DEFINE([VDO_INTERNAL], 1, [Define to 1 to include built-in support for vdo.])\n\tif test \"$VDO_FORMAT_CMD\" = \"autodetect\"; then\n\t\tAC_PATH_TOOL(VDO_FORMAT_CMD, vdoformat, [], [$PATH])\n\t\tif test -z \"$VDO_FORMAT_CMD\"; then\n\t\t\tAC_MSG_WARN([vdoformat not found in path $PATH])\n\t\t\tVDO_FORMAT_CMD=/usr/bin/vdoformat\n\t\t\tVDO_CONFIGURE_WARN=y\n\t\tfi\n\tfi\n\t;;\n *) AC_MSG_ERROR([--with-vdo parameter invalid]) ;;\nesac\n\nAC_DEFINE_UNQUOTED([VDO_FORMAT_CMD], [\"$VDO_FORMAT_CMD\"],\n\t\t   [The path to 'vdoformat', if available.])\n#\n# Do we need to use the API??\n# Do we want to link lvm2 with a big library for vdoformating ?\n#\n#AC_ARG_WITH(vdo-include,\n#\t    AC_HELP_STRING([--with-vdo-include=PATH],\n#\t\t\t   [vdo support: Path to utils headers: [/usr/include/vdo/utils]]),\n#\t\t\t   VDO_INCLUDE=$withval, VDO_INCLUDE=\"/usr/include/vdo/utils\")\n#AC_MSG_RESULT($VDO_INCLUDE)\n#\n#AC_ARG_WITH(vdo-lib,\n#            AC_HELP_STRING([--with-vdo-lib=PATH],\n#                           [vdo support: Path to utils lib: [/usr/lib]]),\n#                           VDO_LIB=$withval, VDO_LIB=\"/usr/lib\") \n#AC_MSG_RESULT($VDO_LIB)\n\n################################################################################\ndnl -- Disable readline\nAC_ARG_ENABLE([readline],\n\t      AC_HELP_STRING([--disable-readline], [disable readline support]),\n\t      READLINE=$enableval, READLINE=maybe)\n\n################################################################################\ndnl -- Disable realtime clock support\nAC_MSG_CHECKING(whether to enable realtime support)\nAC_ARG_ENABLE(realtime,\n\t      AC_HELP_STRING([--disable-realtime], [disable realtime clock support]),\n\t      REALTIME=$enableval, REALTIME=yes)\nAC_MSG_RESULT($REALTIME)\n\n################################################################################\ndnl -- disable OCF resource agents\nAC_MSG_CHECKING(whether to enable OCF resource agents)\nAC_ARG_ENABLE(ocf,\n\t      AC_HELP_STRING([--enable-ocf],\n\t\t\t     [enable Open Cluster Framework (OCF) compliant resource agents]),\n\t      OCF=$enableval, OCF=no)\nAC_MSG_RESULT($OCF)\nAC_ARG_WITH(ocfdir,\n\t    AC_HELP_STRING([--with-ocfdir=DIR],\n\t\t\t   [install OCF files in [PREFIX/lib/ocf/resource.d/lvm2]]),\n\t    OCFDIR=$withval, OCFDIR='${prefix}/lib/ocf/resource.d/lvm2')\n\n################################################################################\ndnl -- Init pkg-config with dummy invokation:\ndnl -- this is required because PKG_CHECK_MODULES macro is expanded\ndnl -- to initialize the pkg-config environment only at the first invokation,\ndnl -- that would be conditional in this configure.in.\npkg_config_init() {\n\tif test \"$PKGCONFIG_INIT\" != 1; then\n\t\tPKG_CHECK_MODULES(PKGCONFIGINIT, pkgconfiginit, [],\n\t\t\t\t  [AC_MSG_RESULT([pkg-config initialized])])\n\t\tPKGCONFIG_INIT=1\n\tfi\n}\n\n################################################################################\nAC_MSG_CHECKING(for default run directory)\nRUN_DIR=\"/run\"\ntest -d \"/run\" || RUN_DIR=\"/var/run\"\nAC_MSG_RESULT($RUN_DIR)\ndnl -- Set up pidfile and run directory\nAH_TEMPLATE(DEFAULT_PID_DIR)\nAC_ARG_WITH(default-pid-dir,\n\t    AC_HELP_STRING([--with-default-pid-dir=PID_DIR],\n\t\t\t   [Default directory to keep PID files in. [autodetect]]),\n\t    DEFAULT_PID_DIR=\"$withval\", DEFAULT_PID_DIR=$RUN_DIR)\nAC_DEFINE_UNQUOTED(DEFAULT_PID_DIR, [\"$DEFAULT_PID_DIR\"],\n\t\t   [Default directory to keep PID files in.])\n\nAH_TEMPLATE(DEFAULT_DM_RUN_DIR, [Name of default DM run directory.])\nAC_ARG_WITH(default-dm-run-dir,\n\t    AC_HELP_STRING([--with-default-dm-run-dir=DM_RUN_DIR],\n\t\t\t   [ Default DM run directory. [autodetect]]),\n\t    DEFAULT_DM_RUN_DIR=\"$withval\", DEFAULT_DM_RUN_DIR=$RUN_DIR)\nAC_DEFINE_UNQUOTED(DEFAULT_DM_RUN_DIR, [\"$DEFAULT_DM_RUN_DIR\"],\n\t\t   [Default DM run directory.])\n\nAH_TEMPLATE(DEFAULT_RUN_DIR, [Name of default LVM run directory.])\nAC_ARG_WITH(default-run-dir,\n\t    AC_HELP_STRING([--with-default-run-dir=RUN_DIR],\n\t\t\t   [Default LVM run directory. [autodetect_run_dir/lvm]]),\n\t    DEFAULT_RUN_DIR=\"$withval\", DEFAULT_RUN_DIR=\"$RUN_DIR/lvm\")\nAC_DEFINE_UNQUOTED(DEFAULT_RUN_DIR, [\"$DEFAULT_RUN_DIR\"],\n\t\t   [Default LVM run directory.])\n\n################################################################################\ndnl -- Build cluster mirror log daemon\nAC_MSG_CHECKING(whether to build cluster mirror log daemon)\nAC_ARG_ENABLE(cmirrord,\n\t      AC_HELP_STRING([--enable-cmirrord],\n\t\t\t     [enable the cluster mirror log daemon]),\n\t      CMIRRORD=$enableval, CMIRRORD=no)\nAC_MSG_RESULT($CMIRRORD)\n\nBUILD_CMIRRORD=$CMIRRORD\n\n################################################################################\ndnl -- cmirrord pidfile\nif test \"$BUILD_CMIRRORD\" = yes; then\n\tAC_ARG_WITH(cmirrord-pidfile,\n\t\t    AC_HELP_STRING([--with-cmirrord-pidfile=PATH],\n\t\t\t\t   [cmirrord pidfile [PID_DIR/cmirrord.pid]]),\n\t\t    CMIRRORD_PIDFILE=$withval,\n\t\t    CMIRRORD_PIDFILE=\"$DEFAULT_PID_DIR/cmirrord.pid\")\n\tAC_DEFINE_UNQUOTED(CMIRRORD_PIDFILE, [\"$CMIRRORD_PIDFILE\"],\n\t\t\t   [Path to cmirrord pidfile.])\nfi\n\n################################################################################\ndnl -- Look for corosync libraries if required.\nif [[ \"$BUILD_CMIRRORD\" = yes ]]; then\n\tpkg_config_init\n\n\tif test \"$HAVE_CPG\" != yes; then\n\t\tPKG_CHECK_MODULES(CPG, libcpg)\n\tfi\nfi\n\n################################################################################\ndnl -- Enable debugging\nAC_MSG_CHECKING(whether to enable debugging)\nAC_ARG_ENABLE(debug, AC_HELP_STRING([--enable-debug], [enable debugging]),\n\t      DEBUG=$enableval, DEBUG=no)\nAC_MSG_RESULT($DEBUG)\n\ndnl -- Normally turn off optimisation for debug builds\nif test \"$DEBUG\" = yes; then\n\tCOPTIMISE_FLAG=\nelse\n\tCSCOPE_CMD=\nfi\n\ndnl -- Check if compiler supports -Wjump-misses-init\nAC_TRY_CCFLAG([-Wjump-misses-init], [HAVE_WJUMP], [], [])\nAC_SUBST(HAVE_WJUMP)\nAC_TRY_CCFLAG([-Wclobbered], [HAVE_WCLOBBERED], [], [])\nAC_SUBST(HAVE_WCLOBBERED)\nAC_TRY_CCFLAG([-Wsync-nand], [HAVE_WSYNCNAND], [], [])\nAC_SUBST(HAVE_WSYNCNAND)\n\n################################################################################\ndnl -- Override optimisation\nAC_MSG_CHECKING(for C optimisation flag)\nAC_ARG_WITH(optimisation,\n\t    AC_HELP_STRING([--with-optimisation=OPT],\n\t\t\t   [C optimisation flag [OPT=-O2]]),\n\t    COPTIMISE_FLAG=$withval)\nAC_MSG_RESULT($COPTIMISE_FLAG)\n\n################################################################################\ndnl -- Enable profiling\nAC_MSG_CHECKING(whether to gather gcov profiling data)\nAC_ARG_ENABLE(profiling,\n\t      AC_HELP_STRING([--enable-profiling],\n\t\t\t     [gather gcov profiling data]),\n\t      PROFILING=$enableval, PROFILING=no)\nAC_MSG_RESULT($PROFILING)\n\nif test \"$PROFILING\" = yes; then\n  COPTIMISE_FLAG=\"$COPTIMISE_FLAG -fprofile-arcs -ftest-coverage\"\n  AC_PATH_TOOL(LCOV, lcov)\n  AC_PATH_TOOL(GENHTML, genhtml)\n  test -z \"$LCOV\" -o -z \"$GENHTML\" && AC_MSG_ERROR([lcov and genhtml are required for profiling])\n  AC_PATH_TOOL(GENPNG, genpng)\n  if test -n \"$GENPNG\"; then\n    AC_MSG_CHECKING([whether $GENPNG has all required modules])\n    if \"$GENPNG\" --help > /dev/null 2>&1 ; then\n      AC_MSG_RESULT(ok)\n      GENHTML=\"$GENHTML --frames\"\n    else\n      AC_MSG_RESULT([not supported])\n      AC_MSG_WARN([GD.pm perl module is not installed])\n      GENPNG=\n    fi\n  fi\nfi\n\n################################################################################\ndnl -- Set LVM2 testsuite data\nTESTSUITE_DATA='${datarootdir}/lvm2-testsuite'\n# double eval needed ${datarootdir} -> ${prefix}/share -> real path\nAC_DEFINE_UNQUOTED(TESTSUITE_DATA, [\"$(eval echo $(eval echo $TESTSUITE_DATA))\"], [Path to testsuite data])\n\n\n################################################################################\ndnl -- Enable valgrind awareness of memory pools\nAC_MSG_CHECKING(whether to enable valgrind awareness of pools)\nAC_ARG_ENABLE(valgrind_pool,\n\t      AC_HELP_STRING([--enable-valgrind-pool],\n\t\t\t     [enable valgrind awareness of pools]),\n\t      VALGRIND_POOL=$enableval, VALGRIND_POOL=no)\nAC_MSG_RESULT($VALGRIND_POOL)\n\npkg_config_init\nPKG_CHECK_MODULES(VALGRIND, valgrind, [HAVE_VALGRIND=yes], [if test x$VALGRIND_POOL = xyes; then AC_MSG_ERROR(bailing out); fi])\nAC_SUBST(VALGRIND_CFLAGS)\n\nif test x$HAVE_VALGRIND = xyes; then\n\tAC_DEFINE([HAVE_VALGRIND], 1, [valgrind.h found])\nfi\n\nif test x$VALGRIND_POOL = xyes; then\n\tAC_DEFINE([VALGRIND_POOL], 1, [Enable a valgrind aware build of pool])\nfi\n\n################################################################################\ndnl -- Disable devmapper\nAC_MSG_CHECKING(whether to use device-mapper)\nAC_ARG_ENABLE(devmapper,\n\t      AC_HELP_STRING([--disable-devmapper],\n\t\t\t     [disable LVM2 device-mapper interaction]),\n\t      DEVMAPPER=$enableval)\nAC_MSG_RESULT($DEVMAPPER)\n\nif test \"$DEVMAPPER\" = yes; then\n\tAC_DEFINE([DEVMAPPER_SUPPORT], 1, [Define to 1 to enable LVM2 device-mapper interaction.])\nfi\n\n################################################################################\ndnl -- Build lvmpolld\nAC_MSG_CHECKING(whether to build lvmpolld)\nAC_ARG_ENABLE(lvmpolld,\n\t      AC_HELP_STRING([--enable-lvmpolld],\n\t\t\t     [enable the LVM Polling Daemon]),\n\t      LVMPOLLD=$enableval)\ntest -n \"$LVMPOLLD\" && BUILD_LVMPOLLD=$LVMPOLLD\nAC_MSG_RESULT($BUILD_LVMPOLLD)\n\n################################################################################\nBUILD_LVMLOCKD=no\n\ndnl -- Build lvmlockdsanlock\nAC_MSG_CHECKING(whether to build lvmlockdsanlock)\nAC_ARG_ENABLE(lvmlockd-sanlock,\n\t      AC_HELP_STRING([--enable-lvmlockd-sanlock],\n\t\t\t     [enable the LVM lock daemon using sanlock]),\n\t      LOCKDSANLOCK=$enableval)\nAC_MSG_RESULT($LOCKDSANLOCK)\n\nBUILD_LOCKDSANLOCK=$LOCKDSANLOCK\n\ndnl -- Look for sanlock libraries\nif test \"$BUILD_LOCKDSANLOCK\" = yes; then\n\tPKG_CHECK_MODULES(LOCKD_SANLOCK, libsanlock_client >= 3.3.0, [HAVE_LOCKD_SANLOCK=yes], $bailout)\n\tAC_DEFINE([LOCKDSANLOCK_SUPPORT], 1, [Define to 1 to include code that uses lvmlockd sanlock option.])\n\tBUILD_LVMLOCKD=yes\nfi\n\n################################################################################\ndnl -- Build lvmlockddlm\nAC_MSG_CHECKING(whether to build lvmlockddlm)\nAC_ARG_ENABLE(lvmlockd-dlm,\n\t      AC_HELP_STRING([--enable-lvmlockd-dlm],\n\t\t\t     [enable the LVM lock daemon using dlm]),\n\t      LOCKDDLM=$enableval)\nAC_MSG_RESULT($LOCKDDLM)\n\nBUILD_LOCKDDLM=$LOCKDDLM\n\ndnl -- Look for dlm libraries\nif test \"$BUILD_LOCKDDLM\" = yes; then\n\tPKG_CHECK_MODULES(LOCKD_DLM, libdlm, [HAVE_LOCKD_DLM=yes], $bailout)\n\tAC_DEFINE([LOCKDDLM_SUPPORT], 1, [Define to 1 to include code that uses lvmlockd dlm option.])\n\tBUILD_LVMLOCKD=yes\nfi\n\n################################################################################\ndnl -- Build lvmlockd\nAC_MSG_CHECKING(whether to build lvmlockd)\nAC_MSG_RESULT($BUILD_LVMLOCKD)\n\nif test \"$BUILD_LVMLOCKD\" = yes; then\n\tAS_IF([test \"$LVMPOLLD\" = no], [AC_MSG_ERROR([cannot build lvmlockd with --disable-lvmpolld.])])\n\tAS_IF([test \"$BUILD_LVMPOLLD\" = no], [BUILD_LVMPOLLD=yes; AC_MSG_WARN([Enabling lvmpolld - required by lvmlockd.])])\n\tAC_MSG_CHECKING([defaults for use_lvmlockd])\n\tAC_ARG_ENABLE(use_lvmlockd,\n\t\t      AC_HELP_STRING([--disable-use-lvmlockd],\n\t\t\t\t     [disable usage of LVM lock daemon]),\n\t\t      [case ${enableval} in\n\t\t       yes) DEFAULT_USE_LVMLOCKD=1 ;;\n\t\t       *) DEFAULT_USE_LVMLOCKD=0 ;;\n\t\t       esac], DEFAULT_USE_LVMLOCKD=1)\n\tAC_MSG_RESULT($DEFAULT_USE_LVMLOCKD)\n\tAC_DEFINE([LVMLOCKD_SUPPORT], 1, [Define to 1 to include code that uses lvmlockd.])\n\n\tAC_ARG_WITH(lvmlockd-pidfile,\n\t\t    AC_HELP_STRING([--with-lvmlockd-pidfile=PATH],\n\t\t\t\t   [lvmlockd pidfile [PID_DIR/lvmlockd.pid]]),\n\t\t    LVMLOCKD_PIDFILE=$withval,\n\t\t    LVMLOCKD_PIDFILE=\"$DEFAULT_PID_DIR/lvmlockd.pid\")\n\tAC_DEFINE_UNQUOTED(LVMLOCKD_PIDFILE, [\"$LVMLOCKD_PIDFILE\"],\n\t\t\t   [Path to lvmlockd pidfile.])\nelse\n\tDEFAULT_USE_LVMLOCKD=0\nfi\nAC_DEFINE_UNQUOTED(DEFAULT_USE_LVMLOCKD, [$DEFAULT_USE_LVMLOCKD],\n\t\t   [Use lvmlockd by default.])\n\n################################################################################\ndnl -- Check lvmpolld\nif test \"$BUILD_LVMPOLLD\" = yes; then\n\tAC_MSG_CHECKING([defaults for use_lvmpolld])\n\tAC_ARG_ENABLE(use_lvmpolld,\n\t\t      AC_HELP_STRING([--disable-use-lvmpolld],\n\t\t\t\t     [disable usage of LVM Poll Daemon]),\n\t\t      [case ${enableval} in\n\t\t       yes) DEFAULT_USE_LVMPOLLD=1 ;;\n\t\t       *) DEFAULT_USE_LVMPOLLD=0 ;;\n\t\t       esac], DEFAULT_USE_LVMPOLLD=1)\n\tAC_MSG_RESULT($DEFAULT_USE_LVMPOLLD)\n\tAC_DEFINE([LVMPOLLD_SUPPORT], 1, [Define to 1 to include code that uses lvmpolld.])\n\n\tAC_ARG_WITH(lvmpolld-pidfile,\n\t\t    AC_HELP_STRING([--with-lvmpolld-pidfile=PATH],\n\t\t\t\t   [lvmpolld pidfile [PID_DIR/lvmpolld.pid]]),\n\t\t    LVMPOLLD_PIDFILE=$withval,\n\t\t    LVMPOLLD_PIDFILE=\"$DEFAULT_PID_DIR/lvmpolld.pid\")\n\tAC_DEFINE_UNQUOTED(LVMPOLLD_PIDFILE, [\"$LVMPOLLD_PIDFILE\"],\n\t\t\t   [Path to lvmpolld pidfile.])\nelse\n\tDEFAULT_USE_LVMPOLLD=0\nfi\nAC_DEFINE_UNQUOTED(DEFAULT_USE_LVMPOLLD, [$DEFAULT_USE_LVMPOLLD],\n\t\t   [Use lvmpolld by default.])\n\n################################################################################\ndnl -- Check dmfilemapd\nAC_MSG_CHECKING(whether to build dmfilemapd)\nAC_ARG_ENABLE(dmfilemapd, AC_HELP_STRING([--enable-dmfilemapd],\n\t\t\t\t\t [enable the dmstats filemap daemon]),\n\t      BUILD_DMFILEMAPD=$enableval, BUILD_DMFILEMAPD=no)\nAC_MSG_RESULT($BUILD_DMFILEMAPD)\nAC_DEFINE([DMFILEMAPD], $BUILD_DMFILEMAPD, [Define to 1 to enable the device-mapper filemap daemon.])\n\ndnl -- dmfilemapd requires FIEMAP\nif test \"$BUILD_DMFILEMAPD\" = yes; then\n   AC_CHECK_HEADER([linux/fiemap.h], , [AC_MSG_ERROR(--enable-dmfilemapd requires fiemap.h)])\nfi\n\n################################################################################\ndnl -- Build notifydbus\nAC_MSG_CHECKING(whether to build notifydbus)\nAC_ARG_ENABLE(notify-dbus,\n\t      AC_HELP_STRING([--enable-notify-dbus],\n\t\t\t     [enable LVM notification using dbus]),\n\t      NOTIFYDBUS_SUPPORT=$enableval, NOTIFYDBUS_SUPPORT=no)\nAC_MSG_RESULT($NOTIFYDBUS_SUPPORT)\n\nif test \"$NOTIFYDBUS_SUPPORT\" = yes; then\n\tAC_DEFINE([NOTIFYDBUS_SUPPORT], 1, [Define to 1 to include code that uses dbus notification.])\n\tSYSTEMD_LIBS=\"-lsystemd\"\nfi\n\n################################################################################\ndnl -- Look for dbus libraries\nif test \"$NOTIFYDBUS_SUPPORT\" = yes; then\n\tPKG_CHECK_MODULES(NOTIFY_DBUS, systemd >= 221, [HAVE_NOTIFY_DBUS=yes], $bailout)\nfi\n\n################################################################################\n\ndnl -- Enable blkid wiping functionality\nAC_ARG_ENABLE(blkid_wiping,\n\t      AC_HELP_STRING([--disable-blkid_wiping],\n\t\t\t     [disable libblkid detection of signatures when wiping and use native code instead]),\n\t      BLKID_WIPING=$enableval, BLKID_WIPING=maybe)\n\nDEFAULT_USE_BLKID_WIPING=0\nif test \"$BLKID_WIPING\" != no; then\n\tpkg_config_init\n\tPKG_CHECK_MODULES(BLKID, blkid >= 2.24,\n\t\t\t  [ BLKID_WIPING=yes\n\t\t\t    BLKID_PC=\"blkid\"\n\t\t\t    DEFAULT_USE_BLKID_WIPING=1\n\t\t\t    AC_DEFINE([BLKID_WIPING_SUPPORT], 1, [Define to 1 to use libblkid detection of signatures when wiping.])\n\t\t\t  ], [if test \"$BLKID_WIPING\" = maybe; then\n\t\t\t\tBLKID_WIPING=no\n\t\t\t   else\n\t\t\t        AC_MSG_ERROR([bailing out... blkid library >= 2.24 is required])\n\t\t\t   fi])\nfi\nAC_MSG_CHECKING([whether to enable libblkid detection of signatures when wiping])\nAC_MSG_RESULT($BLKID_WIPING)\nAC_DEFINE_UNQUOTED(DEFAULT_USE_BLKID_WIPING, [$DEFAULT_USE_BLKID_WIPING],\n\t\t   [Use blkid wiping by default.])\n\n################################################################################\ndnl -- Enable udev-systemd protocol to instantiate a service for background jobs\ndnl -- Requires systemd version 205 at least (including support for systemd-run)\nAC_ARG_ENABLE(udev-systemd-background-jobs,\n\t      AC_HELP_STRING([--disable-udev-systemd-background-jobs],\n\t\t\t     [disable udev-systemd protocol to instantiate a service for background job]),\n\t      UDEV_SYSTEMD_BACKGROUND_JOBS=$enableval,\n\t      UDEV_SYSTEMD_BACKGROUND_JOBS=maybe)\n\nif test \"$UDEV_SYSTEMD_BACKGROUND_JOBS\" != no; then\n\tpkg_config_init\n\tPKG_CHECK_MODULES(SYSTEMD, systemd >= 205,\n\t\t\t  [UDEV_SYSTEMD_BACKGROUND_JOBS=yes],\n\t\t\t  [if test \"$UDEV_SYSTEMD_BACKGROUND_JOBS\" = maybe; then\n\t\t\t\tUDEV_SYSTEMD_BACKGROUND_JOBS=no\n\t\t\t   else\n\t\t\t\tAC_MSG_ERROR([bailing out... systemd >= 205 is required])\n\t\t\t   fi])\nfi\n\nAC_MSG_CHECKING(whether to use udev-systemd protocol for jobs in background)\nAC_MSG_RESULT($UDEV_SYSTEMD_BACKGROUND_JOBS)\n\n################################################################################\ndnl -- Enable udev synchronisation\nAC_MSG_CHECKING(whether to enable synchronisation with udev processing)\nAC_ARG_ENABLE(udev_sync,\n\t      AC_HELP_STRING([--enable-udev_sync],\n\t\t\t     [enable synchronisation with udev processing]),\n\t      UDEV_SYNC=$enableval, UDEV_SYNC=no)\nAC_MSG_RESULT($UDEV_SYNC)\n\nif test \"$UDEV_SYNC\" = yes; then\n\tpkg_config_init\n\tPKG_CHECK_MODULES(UDEV, libudev >= 143, [UDEV_PC=\"libudev\"])\n\tAC_DEFINE([UDEV_SYNC_SUPPORT], 1, [Define to 1 to enable synchronisation with udev processing.])\n\n\tAC_CHECK_LIB(udev, udev_device_get_is_initialized, AC_DEFINE([HAVE_LIBUDEV_UDEV_DEVICE_GET_IS_INITIALIZED], 1,\n\t  [Define to 1 if udev_device_get_is_initialized is available.]))\n\tLIBS=$ac_check_lib_save_LIBS\nfi\n\ndnl -- Enable udev rules\nAC_MSG_CHECKING(whether to enable installation of udev rules required for synchronisation)\nAC_ARG_ENABLE(udev_rules,\n\t      AC_HELP_STRING([--enable-udev_rules],\n\t\t\t     [install rule files needed for udev synchronisation]),\n\t      UDEV_RULES=$enableval, UDEV_RULES=$UDEV_SYNC)\nAC_MSG_RESULT($UDEV_RULES)\n\nAC_MSG_CHECKING(whether to enable executable path detection in udev rules)\nAC_ARG_ENABLE(udev_rule_exec_detection,\n\t      AC_HELP_STRING([--enable-udev-rule-exec-detection],\n\t\t\t     [enable executable path detection in udev rules]),\n\t      UDEV_RULE_EXEC_DETECTION=$enableval, UDEV_RULE_EXEC_DETECTION=no)\nAC_MSG_RESULT($UDEV_RULE_EXEC_DETECTION)\n\ndnl -- Check support for built-in blkid against target udev version\nif test \"$UDEV_RULE\" != no ; then\n\tAC_MSG_CHECKING(whether udev supports built-in blkid)\n\tpkg_config_init\n\tif $(\"$PKG_CONFIG\" --atleast-version=176 libudev); then\n\t\tUDEV_HAS_BUILTIN_BLKID=yes\n\telse\n\t\tUDEV_HAS_BUILTIN_BLKID=no\n\tfi\n\tAC_MSG_RESULT($UDEV_HAS_BUILTIN_BLKID)\nfi\n\n################################################################################\ndnl -- Compatibility mode\nAC_ARG_ENABLE(compat,\n\t      AC_HELP_STRING([--enable-compat],\n\t\t\t     [enable support for old device-mapper versions]),\n\t      DM_COMPAT=$enableval, DM_COMPAT=no)\n\nAS_IF([test \"$DM_COMPAT\" = yes],\n      [AC_DEFINE([DM_COMPAT], 1, [Define to enable compat protocol])\n      AC_MSG_ERROR([--enable-compat is not currently supported.\nSince device-mapper version 1.02.66, only one version (4) of the device-mapper\nioctl protocol is supported.])])\n\n################################################################################\ndnl -- Compatible units suffix mode\nAC_ARG_ENABLE(units-compat,\n\t      AC_HELP_STRING([--enable-units-compat],\n\t\t\t     [enable output compatibility with old versions that\n\t\t\t      that do not use KiB-style unit suffixes]),\n\t      UNITS_COMPAT=$enableval, UNITS_COMPAT=no)\n\nif test \"$UNITS_COMPAT\" = yes; then\n\tAC_DEFINE([DEFAULT_SI_UNIT_CONSISTENCY], 0, [Define to 0 to reinstate the pre-2.02.54 handling of unit suffixes.])\nfi\n\n################################################################################\ndnl -- Disable ioctl\nAC_ARG_ENABLE(ioctl,\n\t      AC_HELP_STRING([--disable-ioctl],\n\t\t\t     [disable ioctl calls to device-mapper in the kernel]),\n\t      DM_IOCTLS=$enableval)\nAS_IF([test \"$DM_IOCTLS\" = yes],\n      [AC_DEFINE([DM_IOCTLS], 1, [Define to enable ioctls calls to kernel])])\n\n################################################################################\ndnl -- Disable O_DIRECT\nAC_MSG_CHECKING(whether to enable O_DIRECT)\nAC_ARG_ENABLE(o_direct,\n\t      AC_HELP_STRING([--disable-o_direct], [disable O_DIRECT]),\n\t      ODIRECT=$enableval)\nAC_MSG_RESULT($ODIRECT)\n\nif test \"$ODIRECT\" = yes; then\n\tAC_DEFINE([O_DIRECT_SUPPORT], 1, [Define to 1 to enable O_DIRECT support.])\nfi\n\n################################################################################\ndnl -- Enable cmdlib\nAC_MSG_CHECKING(whether to compile liblvm2cmd.so)\nAC_ARG_ENABLE(cmdlib,\n\t      AC_HELP_STRING([--enable-cmdlib], [build shared command library]),\n\t      CMDLIB=$enableval, CMDLIB=no)\nAC_MSG_RESULT($CMDLIB)\nAC_SUBST([LVM2CMD_LIB])\ntest \"$CMDLIB\" = yes \\\n  && LVM2CMD_LIB=-llvm2cmd \\\n  || LVM2CMD_LIB=\n\n################################################################################\ndnl -- Enable D-Bus service\nAC_MSG_CHECKING(whether to include Python D-Bus support)\nAC_ARG_ENABLE(dbus-service,\n\t      AC_HELP_STRING([--enable-dbus-service], [install D-Bus support]),\n\t      BUILD_LVMDBUSD=$enableval, BUILD_LVMDBUSD=no)\nAC_MSG_RESULT($BUILD_LVMDBUSD)\nAS_IF([test \"$NOTIFYDBUS_SUPPORT\" = yes && test \"BUILD_LVMDBUSD\" = yes],\n      [AC_MSG_WARN([Building D-Bus support without D-Bus notifications.])])\n\n################################################################################\ndnl -- Enable Python dbus library\n\nif test \"$BUILD_LVMDBUSD\" = yes; then\n\tunset PYTHON_CONFIG\n\tunset am_cv_pathless_PYTHON ac_cv_path_PYTHON am_cv_python_platform\n\tunset am_cv_python_pythondir am_cv_python_version am_cv_python_pyexecdir\n\tunset ac_cv_path_PYTHON_CONFIG ac_cv_path_ac_pt_PYTHON_CONFIG\n\tAM_PATH_PYTHON([3])\n\tPYTHON3=$PYTHON\n\ttest -z \"$PYTHON3\" && AC_MSG_ERROR([python3 is required for --enable-python3_bindings or --enable-dbus-service but cannot be found])\n\tAC_PATH_TOOL(PYTHON3_CONFIG, python3-config)\n\ttest -z \"$PYTHON3_CONFIG\" && AC_MSG_ERROR([python3 headers are required for --enable-python3_bindings or --enable-dbus-service but cannot be found])\n\tPYTHON3_INCDIRS=`\"$PYTHON3_CONFIG\" --includes`\n\tPYTHON3_LIBDIRS=`\"$PYTHON3_CONFIG\" --libs`\n\tPYTHON3DIR=$pythondir\n\ttest \"$PYTHON3_BINDINGS\" = yes && PYTHON_BINDINGS=yes\n\n\t# To get this macro, install autoconf-archive package then run autoreconf\n\tAC_PYTHON_MODULE([pyudev], [Required], python3)\n\tAC_PYTHON_MODULE([dbus], [Required], python3)\nfi\n\n################################################################################\ndnl -- Enable pkg-config\nAC_ARG_ENABLE(pkgconfig,\n\t      AC_HELP_STRING([--enable-pkgconfig], [install pkgconfig support]),\n\t      PKGCONFIG=$enableval, PKGCONFIG=no)\n\n################################################################################\ndnl -- Enable installation of writable files by user\nAC_ARG_ENABLE(write_install,\n\t      AC_HELP_STRING([--enable-write_install],\n\t\t\t     [install user writable files]),\n\t      WRITE_INSTALL=$enableval, WRITE_INSTALL=no)\n\n################################################################################\ndnl -- Enable fsadm\nAC_MSG_CHECKING(whether to install fsadm)\nAC_ARG_ENABLE(fsadm, AC_HELP_STRING([--disable-fsadm], [disable fsadm]),\n\t      FSADM=$enableval)\nAC_MSG_RESULT($FSADM)\n\n################################################################################\ndnl -- Enable blkdeactivate\nAC_MSG_CHECKING(whether to install blkdeactivate)\nAC_ARG_ENABLE(blkdeactivate, AC_HELP_STRING([--disable-blkdeactivate], [disable blkdeactivate]),\n\t      BLKDEACTIVATE=$enableval)\nAC_MSG_RESULT($BLKDEACTIVATE)\n\n################################################################################\ndnl -- enable dmeventd handling\nAC_MSG_CHECKING(whether to use dmeventd)\nAC_ARG_ENABLE(dmeventd, AC_HELP_STRING([--enable-dmeventd],\n\t\t\t\t       [enable the device-mapper event daemon]),\n\t      BUILD_DMEVENTD=$enableval, BUILD_DMEVENTD=no)\nAC_MSG_RESULT($BUILD_DMEVENTD)\n\ndnl -- dmeventd currently requires internal mirror support\nif test \"$BUILD_DMEVENTD\" = yes; then\n   if test \"$MIRRORS\" != internal; then\n      AC_MSG_ERROR([--enable-dmeventd currently requires --with-mirrors=internal])\n   fi\n   if test \"$CMDLIB\" = no; then\n      AC_MSG_ERROR([--enable-dmeventd requires --enable-cmdlib to be used as well])\n   fi\n\n   AC_DEFINE([DMEVENTD], 1, [Define to 1 to enable the device-mapper event daemon.])\nfi\n\n################################################################################\ndnl -- getline included in recent libc\n\nAC_CHECK_LIB(c, getline, AC_DEFINE([HAVE_GETLINE], 1,\n  [Define to 1 if getline is available.]))\n\n################################################################################\ndnl -- canonicalize_file_name included in recent libc\n\nAC_CHECK_LIB(c, canonicalize_file_name,\n  AC_DEFINE([HAVE_CANONICALIZE_FILE_NAME], 1,\n    [Define to 1 if canonicalize_file_name is available.]))\n\n################################################################################\ndnl -- Check for dlopen\nAC_CHECK_LIB(dl, dlopen,\n\t     [AC_DEFINE([HAVE_LIBDL], 1, [Define to 1 if dynamic libraries are available.])\n\t      DL_LIBS=\"-ldl\"\n\t      HAVE_LIBDL=yes],\n\t     [DL_LIBS=\n\t      HAVE_LIBDL=no ])\n\n################################################################################\ndnl -- Check for shared/static conflicts\nif [[ \\( \"$LVM1\" = shared -o \"$POOL\" = shared \\\n      \\) -a \"$STATIC_LINK\" = yes ]]; then\n\tAC_MSG_ERROR([Features cannot be 'shared' when building statically])\nfi\n\n################################################################################\nAC_CHECK_LIB(m, log10,\n\t[M_LIBS=\"-lm\"], hard_bailout)\n\n################################################################################\nAC_CHECK_LIB([pthread], [pthread_mutex_lock],\n\t[PTHREAD_LIBS=\"-lpthread\"], hard_bailout)\n\n################################################################################\ndnl -- Disable selinux\nAC_MSG_CHECKING(whether to enable selinux support)\nAC_ARG_ENABLE(selinux,\n\t      AC_HELP_STRING([--disable-selinux], [disable selinux support]),\n\t      SELINUX=$enableval)\nAC_MSG_RESULT($SELINUX)\n\n################################################################################\ndnl -- Check for selinux\nif test \"$SELINUX\" = yes; then\n\tAC_CHECK_LIB([sepol], [sepol_check_context], [\n\t\tAC_DEFINE([HAVE_SEPOL], 1, [Define to 1 if sepol_check_context is available.])\n\t\tSELINUX_LIBS=\"-lsepol\"])\n\n\tAC_CHECK_LIB([selinux], [is_selinux_enabled], [\n\t\tAC_CHECK_HEADERS([selinux/selinux.h],, hard_bailout)\n\t\tAC_CHECK_HEADERS([selinux/label.h])\n\t\tAC_DEFINE([HAVE_SELINUX], 1, [Define to 1 to include support for selinux.])\n\t\tSELINUX_LIBS=\"-lselinux $SELINUX_LIBS\"\n\t\tSELINUX_PC=\"libselinux\"\n\t\tHAVE_SELINUX=yes ], [\n\t\tAC_MSG_WARN(Disabling selinux)\n\t\tSELINUX_LIBS=\n\t\tSELINUX_PC=\n\t\tHAVE_SELINUX=no ])\nfi\n\n################################################################################\ndnl -- Check for realtime clock support\nRT_LIBS=\nHAVE_REALTIME=no\nif test \"$REALTIME\" = yes; then\n\tAC_CHECK_FUNCS([clock_gettime], HAVE_REALTIME=yes)\n\n\tAS_IF([test \"$HAVE_REALTIME\" != yes], [ # try again with -lrt\n\t      AC_CHECK_LIB([rt], [clock_gettime], RT_LIBS=\"-lrt\"; HAVE_REALTIME=yes)])\n\n\tif test \"$HAVE_REALTIME\" = yes; then\n\t\tAC_DEFINE([HAVE_REALTIME], 1, [Define to 1 to include support for realtime clock.])\n\telse\n\t\tAC_MSG_WARN(Disabling realtime clock)\n\tfi\nfi\n\ndnl Check if the system has struct stat st_ctim.\nAC_CACHE_CHECK([for struct stat has st_ctim.],\n\t[ac_cv_stat_st_ctim],\n\t[AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[#include <sys/stat.h>\nlong bar(void) { struct stat s; return (long)(s.st_ctim.tv_sec + s.st_ctim.tv_nsec);}]\n\t )], [ac_cv_stat_st_ctim=yes], [ac_cv_stat_st_ctim=no])])\n\nAC_IF_YES(ac_cv_stat_st_ctim,\n\t  AC_DEFINE(HAVE_STAT_ST_CTIM, 1,\n\t\t    [Define if struct stat has a field st_ctim with timespec for ctime]))\n\n################################################################################\ndnl -- Check for getopt\nAC_CHECK_HEADERS(getopt.h, AC_DEFINE([HAVE_GETOPTLONG], 1, [Define to 1 if getopt_long is available.]))\n\n################################################################################\ndnl -- Check for readline (Shamelessly copied from parted 1.4.17)\nif test \"$READLINE\" != no; then\n\tlvm_saved_libs=$LIBS\n\tAC_SEARCH_LIBS([tgetent], [tinfo ncurses curses termcap termlib],\n\t\tREADLINE_LIBS=$ac_cv_search_tgetent, [\n\t\tif test \"$READLINE\" = yes; then\n\t\t\tAC_MSG_ERROR(\n[termcap could not be found which is required for the\n--enable-readline option (which is enabled by default).  Either disable readline\nsupport with --disable-readline or download and install termcap from:\n\tftp.gnu.org/gnu/termcap\nNote: if you are using precompiled packages you will also need the development\n  package as well (which may be called termcap-devel or something similar).\nNote: (n)curses also seems to work as a substitute for termcap.  This was\n  not found either - but you could try installing that as well.])\n\t\tfi])\n\tdnl -- Old systems may need extra termcap dependency explicitly in LIBS\n\tAC_CHECK_LIB([readline], [readline], [\n\t\tAC_DEFINE([READLINE_SUPPORT], 1,\n\t\t\t[Define to 1 to include the LVM readline shell.])\n\t\tdnl -- Try only with -lreadline and check for different symbol\n\t\tREADLINE=yes\n\t\tLIBS=$lvm_saved_libs\n\t\tAC_CHECK_LIB([readline], [rl_line_buffer],\n\t\t\t[ READLINE_LIBS=\"-lreadline\" ], [\n\t\t\t  AC_MSG_RESULT([linking -lreadline with $READLINE_LIBS needed])\n\t\t\t  READLINE_LIBS=\"-lreadline $READLINE_LIBS\"\n\t\t\t]) ], [\n\t\tREADLINE_LIBS=\n\t\tif test \"$READLINE\" = yes; then\n\t\t\tAC_MSG_ERROR(\n[GNU Readline could not be found which is required for the\n--enable-readline option (which is enabled by default).  Either disable readline\nsupport with --disable-readline or download and install readline from:\n\tftp.gnu.org/gnu/readline\nNote: if you are using precompiled packages you will also need the development\npackage as well (which may be called readline-devel or something similar).])\n\t\tfi ])\n\tLIBS=\"$READLINE_LIBS $lvm_saved_libs\"\n\tAC_CHECK_FUNCS([rl_completion_matches])\n\tLIBS=$lvm_saved_libs\nfi\n\n################################################################################\ndnl -- Internationalisation stuff\nAC_MSG_CHECKING(whether to enable internationalisation)\nAC_ARG_ENABLE(nls,\n\t      AC_HELP_STRING([--enable-nls], [enable Native Language Support]),\n\t      INTL=$enableval, INTL=no)\nAC_MSG_RESULT($INTL)\n\nif test \"$INTL\" = yes; then\n# FIXME - Move this - can be device-mapper too\n\tINTL_PACKAGE=\"lvm2\"\n\tAC_PATH_TOOL(MSGFMT, msgfmt)\n\n\tAS_IF([test -z \"$MSGFMT\"], [AC_MSG_ERROR([msgfmt not found in path $PATH])])\n\n\tAC_ARG_WITH(localedir,\n\t\t    AC_HELP_STRING([--with-localedir=DIR],\n\t\t\t\t   [locale-dependent data [DATAROOTDIR/locale]]),\n\t\t    localedir=$withval, localedir=${localedir-'${datarootdir}/locale'})\n\tAC_DEFINE_UNQUOTED([INTL_PACKAGE], [\"$INTL_PACKAGE\"], [Internalization package])\n\t# double eval needed ${datarootdir} -> ${prefix}/share -> real path\n\tAC_DEFINE_UNQUOTED([LOCALEDIR], [\"$(eval echo $(eval echo $localedir))\"], [Locale-dependent data])\nfi\n\n################################################################################\ndnl -- FIXME: need to switch to regular option here  --sysconfdir\nAC_ARG_WITH(confdir,\n\t    AC_HELP_STRING([--with-confdir=DIR],\n\t\t\t   [configuration files in DIR [/etc]]),\n\t    CONFDIR=$withval, CONFDIR='/etc')\nAC_DEFINE_UNQUOTED(DEFAULT_ETC_DIR, [\"$CONFDIR\"],\n\t\t   [Default system configuration directory.])\n\nAC_ARG_WITH(staticdir,\n\t    AC_HELP_STRING([--with-staticdir=DIR],\n\t\t\t   [static binaries in DIR [EPREFIX/sbin]]),\n\t    STATICDIR=$withval, STATICDIR='${exec_prefix}/sbin')\n\nAC_ARG_WITH(usrlibdir,\n\t    AC_HELP_STRING([--with-usrlibdir=DIR],\n\t\t\t   [usrlib in DIR [PREFIX/lib]]),\n\t    usrlibdir=$withval, usrlibdir='${prefix}/lib')\n\nAC_ARG_WITH(usrsbindir,\n\t    AC_HELP_STRING([--with-usrsbindir=DIR],\n\t\t\t   [usrsbin executables in DIR [PREFIX/sbin]]),\n\t    usrsbindir=$withval, usrsbindir='${prefix}/sbin')\n\n################################################################################\nAC_ARG_WITH(udev_prefix,\n\t    AC_HELP_STRING([--with-udev-prefix=UPREFIX],\n\t\t\t   [install udev rule files in UPREFIX [EPREFIX]]),\n\t    udev_prefix=$withval, udev_prefix='${exec_prefix}')\n\nAC_ARG_WITH(udevdir,\n\t    AC_HELP_STRING([--with-udevdir=DIR],\n\t\t\t   [udev rules in DIR [UPREFIX/lib/udev/rules.d]]),\n\t    udevdir=$withval, udevdir='${udev_prefix}/lib/udev/rules.d')\n\n################################################################################\ndnl -- Get the systemd system unit dir value from pkg_config automatically if value not given explicitly.\ndnl -- This follows the recommendation for systemd integration best practices mentioned in daemon(7) manpage.\nAC_ARG_WITH(systemdsystemunitdir,\n\t    AC_HELP_STRING([--with-systemdsystemunitdir=DIR],\n\t\t\t   [systemd service files in DIR]),\n\t    systemdsystemunitdir=$withval,\n\t    pkg_config_init\n\t    pkg_systemdsystemunitdir=$(\"$PKG_CONFIG\" --variable=systemdsystemunitdir systemd))\n\ntest -n \"$pkg_systemdsystemunitdir\" && systemdsystemunitdir=$pkg_systemdsystemunitdir\ntest -z \"$systemdsystemunitdir\" && systemdsystemunitdir='${exec_prefix}/lib/systemd/system';\n\nsystemdutildir=$(\"$PKG_CONFIG\" --variable=systemdutildir systemd)\ntest -z \"$systemdutildir\" && systemdutildir='${exec_prefix}/lib/systemd';\n\n################################################################################\nAC_ARG_WITH(tmpfilesdir,\n\t    AC_HELP_STRING([--with-tmpfilesdir=DIR],\n\t\t\t   [install configuration files for management of volatile files and directories in DIR [PREFIX/lib/tmpfiles.d]]),\n\t\t\t   tmpfilesdir=$withval, tmpfilesdir='${prefix}/lib/tmpfiles.d')\n################################################################################\ndnl -- Ensure additional headers required\nif test \"$READLINE\" = yes; then\n\tAC_CHECK_HEADERS(readline/readline.h readline/history.h,,hard_bailout)\nfi\nAC_MSG_CHECKING(whether to enable readline)\nAC_MSG_RESULT($READLINE)\n\nif test \"$BUILD_CMIRRORD\" = yes; then\n\tAC_CHECK_FUNCS(atexit,,hard_bailout)\nfi\n\nif test \"$BUILD_LVMLOCKD\" = yes; then\n\tAS_IF([test \"$HAVE_REALTIME\" != yes], [AC_MSG_ERROR([Realtime clock support is mandatory for lvmlockd.])])\n\tAC_CHECK_FUNCS(strtoull,,hard_bailout)\nfi\n\nif test \"$BUILD_LVMPOLLD\" = yes; then\n\tAC_CHECK_FUNCS(strpbrk,,hard_bailout)\n\tAC_FUNC_STRERROR_R\nfi\n\nif test \"$BUILD_DMEVENTD\" = yes; then\n\tAC_CHECK_HEADERS(arpa/inet.h,,hard_bailout)\nfi\n\nif test \"$HAVE_LIBDL\" = yes; then\n\tAC_CHECK_HEADERS(dlfcn.h,,hard_bailout)\nfi\n\nif test \"$INTL\" = yes; then\n\tAC_CHECK_HEADERS(libintl.h,,hard_bailout)\nfi\n\nif test \"$UDEV_SYNC\" = yes; then\n\tAC_CHECK_HEADERS(sys/ipc.h sys/sem.h,,hard_bailout)\nfi\n\nif test \"$BUILD_DMFILEMAPD\" = yes; then\n\tAC_CHECK_HEADERS([sys/inotify.h],,hard_bailout)\nfi\n\n################################################################################\nAC_PATH_TOOL(MODPROBE_CMD, modprobe, [], [$PATH_SBIN])\n\nif test -n \"$MODPROBE_CMD\"; then\n\tAC_DEFINE_UNQUOTED([MODPROBE_CMD], [\"$MODPROBE_CMD\"], [The path to 'modprobe', if available.])\nfi\n\nSYSCONFDIR=\"$(eval echo $(eval echo $sysconfdir))\"\n\nSBINDIR=\"$(eval echo $(eval echo $sbindir))\"\nLVM_PATH=\"$SBINDIR/lvm\"\nAC_DEFINE_UNQUOTED(LVM_PATH, [\"$LVM_PATH\"], [Path to lvm binary.])\n\nLVMCONFIG_PATH=\"$SBINDIR/lvmconfig\"\nAC_DEFINE_UNQUOTED(LVMCONFIG_PATH, [\"$LVMCONFIG_PATH\"], [Path to lvmconfig binary.])\n\nUSRSBINDIR=\"$(eval echo $(eval echo $usrsbindir))\"\n\nFSADM_PATH=\"$SBINDIR/fsadm\"\nAC_DEFINE_UNQUOTED(FSADM_PATH, [\"$FSADM_PATH\"], [Path to fsadm binary.])\n\n################################################################################\ndnl -- dmeventd pidfile and executable path\nif test \"$BUILD_DMEVENTD\" = yes; then\n\tAC_ARG_WITH(dmeventd-pidfile,\n\t\t    AC_HELP_STRING([--with-dmeventd-pidfile=PATH],\n\t\t\t\t   [dmeventd pidfile [PID_DIR/dmeventd.pid]]),\n\t\t    DMEVENTD_PIDFILE=$withval,\n\t\t    DMEVENTD_PIDFILE=\"$DEFAULT_PID_DIR/dmeventd.pid\")\n\tAC_DEFINE_UNQUOTED(DMEVENTD_PIDFILE, [\"$DMEVENTD_PIDFILE\"],\n\t\t\t   [Path to dmeventd pidfile.])\nfi\n\nif test \"$BUILD_DMEVENTD\" = yes; then\n\tAC_ARG_WITH(dmeventd-path,\n\t\t    AC_HELP_STRING([--with-dmeventd-path=PATH],\n\t\t\t\t   [dmeventd path [EPREFIX/sbin/dmeventd]]),\n\t\t    DMEVENTD_PATH=$withval,\n\t\t    DMEVENTD_PATH=\"$SBINDIR/dmeventd\")\n\tAC_DEFINE_UNQUOTED(DMEVENTD_PATH, [\"$DMEVENTD_PATH\"],\n\t\t\t   [Path to dmeventd binary.])\nfi\n\n################################################################################\ndnl -- various defaults\ndnl -- FIXME: need to switch to regular option here  --sysconfdir\nAC_ARG_WITH(default-system-dir,\n\t    AC_HELP_STRING([--with-default-system-dir=DIR],\n\t\t\t   [default LVM system directory [/etc/lvm]]),\n\t    DEFAULT_SYS_DIR=$withval, DEFAULT_SYS_DIR=\"/etc/lvm\")\nAC_DEFINE_UNQUOTED(DEFAULT_SYS_DIR, [\"$DEFAULT_SYS_DIR\"],\n\t\t   [Path to LVM system directory.])\n\nAC_ARG_WITH(default-profile-subdir,\n\t    AC_HELP_STRING([--with-default-profile-subdir=SUBDIR],\n\t\t\t   [default configuration profile subdir [profile]]),\n\t    DEFAULT_PROFILE_SUBDIR=$withval, DEFAULT_PROFILE_SUBDIR=profile)\nAC_DEFINE_UNQUOTED(DEFAULT_PROFILE_SUBDIR, [\"$DEFAULT_PROFILE_SUBDIR\"],\n\t\t   [Name of default configuration profile subdirectory.])\n\nAC_ARG_WITH(default-archive-subdir,\n\t    AC_HELP_STRING([--with-default-archive-subdir=SUBDIR],\n\t\t\t   [default metadata archive subdir [archive]]),\n\t    DEFAULT_ARCHIVE_SUBDIR=$withval, DEFAULT_ARCHIVE_SUBDIR=archive)\nAC_DEFINE_UNQUOTED(DEFAULT_ARCHIVE_SUBDIR, [\"$DEFAULT_ARCHIVE_SUBDIR\"],\n\t\t   [Name of default metadata archive subdirectory.])\n\nAC_ARG_WITH(default-backup-subdir,\n\t    AC_HELP_STRING([--with-default-backup-subdir=SUBDIR],\n\t\t\t   [default metadata backup subdir [backup]]),\n\t    DEFAULT_BACKUP_SUBDIR=$withval, DEFAULT_BACKUP_SUBDIR=backup)\nAC_DEFINE_UNQUOTED(DEFAULT_BACKUP_SUBDIR, [\"$DEFAULT_BACKUP_SUBDIR\"],\n                   [Name of default metadata backup subdirectory.])\n\nAC_ARG_WITH(default-cache-subdir,\n\t    AC_HELP_STRING([--with-default-cache-subdir=SUBDIR],\n\t\t\t   [default metadata cache subdir [cache]]),\n\t    DEFAULT_CACHE_SUBDIR=$withval, DEFAULT_CACHE_SUBDIR=cache)\nAC_DEFINE_UNQUOTED(DEFAULT_CACHE_SUBDIR, [\"$DEFAULT_CACHE_SUBDIR\"],\n\t\t   [Name of default metadata cache subdirectory.])\n\n# Select default system locking dir, prefer /run/lock over /var/lock\nDEFAULT_SYS_LOCK_DIR=\"$RUN_DIR/lock\"\ntest -d \"$DEFAULT_SYS_LOCK_DIR\" || DEFAULT_SYS_LOCK_DIR=\"/var/lock\"\n\n# Support configurable locking subdir for lvm\nAC_ARG_WITH(default-locking-dir,\n\t    AC_HELP_STRING([--with-default-locking-dir=DIR],\n\t\t\t   [default locking directory [autodetect_lock_dir/lvm]]),\n\t    DEFAULT_LOCK_DIR=$withval,\n\t    [AC_MSG_CHECKING(for default lock directory)\n\t     DEFAULT_LOCK_DIR=\"$DEFAULT_SYS_LOCK_DIR/lvm\"\n\t     AC_MSG_RESULT($DEFAULT_LOCK_DIR)])\nAC_DEFINE_UNQUOTED(DEFAULT_LOCK_DIR, [\"$DEFAULT_LOCK_DIR\"],\n\t\t   [Name of default locking directory.])\n\n################################################################################\ndnl -- Setup default data alignment\nAC_ARG_WITH(default-data-alignment,\n\t    AC_HELP_STRING([--with-default-data-alignment=NUM],\n\t\t\t   [set the default data alignment in MiB [1]]),\n\t    DEFAULT_DATA_ALIGNMENT=$withval, DEFAULT_DATA_ALIGNMENT=1)\nAC_DEFINE_UNQUOTED(DEFAULT_DATA_ALIGNMENT, [$DEFAULT_DATA_ALIGNMENT],\n\t\t   [Default data alignment.])\n\n################################################################################\ndnl -- which kernel interface to use (ioctl only)\nAC_MSG_CHECKING(for kernel interface choice)\nAC_ARG_WITH(interface,\n\t    AC_HELP_STRING([--with-interface=IFACE],\n\t\t\t   [choose kernel interface (ioctl) [ioctl]]),\n\t    interface=$withval, interface=ioctl)\ntest \"$interface\" != ioctl && AC_MSG_ERROR([--with-interface=ioctl required. fs no longer supported.])\nAC_MSG_RESULT($interface)\n\n################################################################################\nread DM_LIB_VERSION < \"$srcdir\"/VERSION_DM 2>/dev/null || DM_LIB_VERSION=Unknown\nAC_DEFINE_UNQUOTED(DM_LIB_VERSION, \"$DM_LIB_VERSION\", [Library version])\n\nDM_LIB_PATCHLEVEL=`cat \"$srcdir\"/VERSION_DM | $AWK -F '[[-. ]]' '{printf \"%s.%s.%s\",$1,$2,$3}'`\n\nread VER < \"$srcdir\"/VERSION 2>/dev/null || VER=Unknown\n\nLVM_VERSION=\\\"$VER\\\"\nLVM_RELEASE_DATE=\"\\\"`echo $VER | $SED 's/.* (//;s/).*//'`\\\"\"\nVER=`echo \"$VER\" | $AWK '{print $1}'`\nLVM_RELEASE=\"\\\"`echo \"$VER\" | $AWK -F '-' '{print $2}'`\\\"\"\nVER=`echo \"$VER\" | $AWK -F '-' '{print $1}'`\nLVM_MAJOR=`echo \"$VER\" | $AWK -F '.' '{print $1}'`\nLVM_MINOR=`echo \"$VER\" | $AWK -F '.' '{print $2}'`\nLVM_PATCHLEVEL=`echo \"$VER\" | $AWK -F '[[(.]]' '{print $3}'`\nLVM_LIBAPI=`echo \"$VER\" | $AWK -F '[[()]]' '{print $2}'`\n\nAC_DEFINE_UNQUOTED(LVM_CONFIGURE_LINE, \"$CONFIGURE_LINE\", [configure command line used])\n\n################################################################################\nAC_SUBST(AWK)\nAC_SUBST(BLKID_PC)\nAC_SUBST(BUILD_CMIRRORD)\nAC_SUBST(BUILD_DMEVENTD)\nAC_SUBST(BUILD_LVMDBUSD)\nAC_SUBST(BUILD_LVMPOLLD)\nAC_SUBST(BUILD_LVMLOCKD)\nAC_SUBST(BUILD_LOCKDSANLOCK)\nAC_SUBST(BUILD_LOCKDDLM)\nAC_SUBST(BUILD_DMFILEMAPD)\nAC_SUBST(CACHE)\nAC_SUBST(CFLAGS)\nAC_SUBST(CFLOW_CMD)\nAC_SUBST(CHMOD)\nAC_SUBST(CLDFLAGS)\nAC_SUBST(CLDNOWHOLEARCHIVE)\nAC_SUBST(CLDWHOLEARCHIVE)\nAC_SUBST(CMDLIB)\nAC_SUBST(CONFDB_CFLAGS)\nAC_SUBST(CONFDB_LIBS)\nAC_SUBST(CONFDIR)\nAC_SUBST(COPTIMISE_FLAG)\nAC_SUBST(CPG_CFLAGS)\nAC_SUBST(CPG_LIBS)\nAC_SUBST(CSCOPE_CMD)\nAC_SUBST(DEBUG)\nAC_SUBST(DEFAULT_ARCHIVE_SUBDIR)\nAC_SUBST(DEFAULT_BACKUP_SUBDIR)\nAC_SUBST(DEFAULT_CACHE_SUBDIR)\nAC_SUBST(DEFAULT_DATA_ALIGNMENT)\nAC_SUBST(DEFAULT_DM_RUN_DIR)\nAC_SUBST(DEFAULT_LOCK_DIR)\nAC_SUBST(DEFAULT_MIRROR_SEGTYPE)\nAC_SUBST(DEFAULT_PID_DIR)\nAC_SUBST(DEFAULT_PROFILE_SUBDIR)\nAC_SUBST(DEFAULT_RAID10_SEGTYPE)\nAC_SUBST(DEFAULT_RUN_DIR)\nAC_SUBST(DEFAULT_SPARSE_SEGTYPE)\nAC_SUBST(DEFAULT_SYS_DIR)\nAC_SUBST(DEFAULT_SYS_LOCK_DIR)\nAC_SUBST(DEFAULT_USE_BLKID_WIPING)\nAC_SUBST(DEFAULT_USE_LVMPOLLD)\nAC_SUBST(DEFAULT_USE_LVMLOCKD)\nAC_SUBST(DEVMAPPER)\nAC_SUBST(DLM_CFLAGS)\nAC_SUBST(DLM_LIBS)\nAC_SUBST(DL_LIBS)\nAC_SUBST(DMEVENTD_PATH)\nAC_SUBST(DM_LIB_PATCHLEVEL)\nAC_SUBST(ELDFLAGS)\nAC_SUBST(FSADM)\nAC_SUBST(FSADM_PATH)\nAC_SUBST(BLKDEACTIVATE)\nAC_SUBST(HAVE_LIBDL)\nAC_SUBST(HAVE_REALTIME)\nAC_SUBST(HAVE_VALGRIND)\nAC_SUBST(INTL)\nAC_SUBST(JOBS)\nAC_SUBST(LDDEPS)\nAC_SUBST(LIBS)\nAC_SUBST(LIB_SUFFIX)\nAC_SUBST(LVM_VERSION)\nAC_SUBST(LVM_LIBAPI)\nAC_SUBST(LVM_MAJOR)\nAC_SUBST(LVM_MINOR)\nAC_SUBST(LVM_PATCHLEVEL)\nAC_SUBST(LVM_PATH)\nAC_SUBST(LVM_RELEASE)\nAC_SUBST(LVM_RELEASE_DATE)\nAC_SUBST(localedir)\nAC_SUBST(MANGLING)\nAC_SUBST(MIRRORS)\nAC_SUBST(MSGFMT)\nAC_SUBST(OCF)\nAC_SUBST(OCFDIR)\nAC_SUBST(ODIRECT)\nAC_SUBST(PKGCONFIG)\nAC_SUBST(M_LIBS)\nAC_SUBST(PTHREAD_LIBS)\nAC_SUBST(PYTHON2)\nAC_SUBST(PYTHON3)\nAC_SUBST(PYTHON_BINDINGS)\nAC_SUBST(PYTHON2_BINDINGS)\nAC_SUBST(PYTHON3_BINDINGS)\nAC_SUBST(PYTHON2_INCDIRS)\nAC_SUBST(PYTHON3_INCDIRS)\nAC_SUBST(PYTHON2_LIBDIRS)\nAC_SUBST(PYTHON3_LIBDIRS)\nAC_SUBST(PYTHON2DIR)\nAC_SUBST(PYTHON3DIR)\nAC_SUBST(QUORUM_CFLAGS)\nAC_SUBST(QUORUM_LIBS)\nAC_SUBST(RT_LIBS)\nAC_SUBST(READLINE_LIBS)\nAC_SUBST(REPLICATORS)\nAC_SUBST(SACKPT_CFLAGS)\nAC_SUBST(SACKPT_LIBS)\nAC_SUBST(SALCK_CFLAGS)\nAC_SUBST(SALCK_LIBS)\nAC_SUBST(SBINDIR)\nAC_SUBST(SELINUX_LIBS)\nAC_SUBST(SELINUX_PC)\nAC_SUBST(SYSCONFDIR)\nAC_SUBST(SYSTEMD_LIBS)\nAC_SUBST(SNAPSHOTS)\nAC_SUBST(STATICDIR)\nAC_SUBST(STATIC_LINK)\nAC_SUBST(TESTSUITE_DATA)\nAC_SUBST(THIN)\nAC_SUBST(THIN_CHECK_CMD)\nAC_SUBST(THIN_DUMP_CMD)\nAC_SUBST(THIN_REPAIR_CMD)\nAC_SUBST(THIN_RESTORE_CMD)\nAC_SUBST(CACHE_CHECK_CMD)\nAC_SUBST(CACHE_DUMP_CMD)\nAC_SUBST(CACHE_REPAIR_CMD)\nAC_SUBST(CACHE_RESTORE_CMD)\nAC_SUBST(UDEV_PC)\nAC_SUBST(UDEV_RULES)\nAC_SUBST(UDEV_SYNC)\nAC_SUBST(UDEV_SYSTEMD_BACKGROUND_JOBS)\nAC_SUBST(UDEV_RULE_EXEC_DETECTION)\nAC_SUBST(UDEV_HAS_BUILTIN_BLKID)\nAC_SUBST(USE_TRACKING)\nAC_SUBST(SILENT_RULES)\nAC_SUBST(USRSBINDIR)\nAC_SUBST(VALGRIND_POOL)\nAC_SUBST(VDO)\nAC_SUBST(VDO_FORMAT_CMD)\nAC_SUBST(VDO_INCLUDE)\nAC_SUBST(VDO_LIB)\nAC_SUBST(WRITE_INSTALL)\nAC_SUBST(DMEVENTD_PIDFILE)\nAC_SUBST(LVMPOLLD_PIDFILE)\nAC_SUBST(LVMLOCKD_PIDFILE)\nAC_SUBST(CMIRRORD_PIDFILE)\nAC_SUBST(interface)\nAC_SUBST(kerneldir)\nAC_SUBST(missingkernel)\nAC_SUBST(kernelvsn)\nAC_SUBST(tmpdir)\nAC_SUBST(udev_prefix)\nAC_SUBST(udevdir)\nAC_SUBST(systemdsystemunitdir)\nAC_SUBST(systemdutildir)\nAC_SUBST(tmpfilesdir)\nAC_SUBST(usrlibdir)\nAC_SUBST(usrsbindir)\n\n################################################################################\ndnl -- First and last lines should not contain files to generate in order to\ndnl -- keep utility scripts running properly\nAC_CONFIG_FILES([\nMakefile\nmake.tmpl\nlibdm/make.tmpl\ndaemons/Makefile\ndaemons/cmirrord/Makefile\ndaemons/dmeventd/Makefile\ndaemons/dmeventd/libdevmapper-event.pc\ndaemons/dmeventd/plugins/Makefile\ndaemons/dmeventd/plugins/lvm2/Makefile\ndaemons/dmeventd/plugins/raid/Makefile\ndaemons/dmeventd/plugins/mirror/Makefile\ndaemons/dmeventd/plugins/snapshot/Makefile\ndaemons/dmeventd/plugins/thin/Makefile\ndaemons/dmeventd/plugins/vdo/Makefile\ndaemons/lvmdbusd/Makefile\ndaemons/lvmdbusd/lvmdbusd\ndaemons/lvmdbusd/lvmdb.py\ndaemons/lvmdbusd/lvm_shell_proxy.py\ndaemons/lvmdbusd/path.py\ndaemons/lvmpolld/Makefile\ndaemons/lvmlockd/Makefile\nconf/Makefile\nconf/example.conf\nconf/lvmlocal.conf\nconf/command_profile_template.profile\nconf/metadata_profile_template.profile\ninclude/Makefile\nlib/Makefile\ninclude/lvm-version.h\nlibdaemon/Makefile\nlibdaemon/client/Makefile\nlibdaemon/server/Makefile\nlibdm/Makefile\nlibdm/dm-tools/Makefile\nlibdm/libdevmapper.pc\nman/Makefile\npo/Makefile\nscripts/blkdeactivate.sh\nscripts/blk_availability_init_red_hat\nscripts/blk_availability_systemd_red_hat.service\nscripts/cmirrord_init_red_hat\nscripts/com.redhat.lvmdbus1.service\nscripts/dm_event_systemd_red_hat.service\nscripts/dm_event_systemd_red_hat.socket\nscripts/lvm2_cmirrord_systemd_red_hat.service\nscripts/lvm2_lvmdbusd_systemd_red_hat.service\nscripts/lvm2_lvmpolld_init_red_hat\nscripts/lvm2_lvmpolld_systemd_red_hat.service\nscripts/lvm2_lvmpolld_systemd_red_hat.socket\nscripts/lvmlockd.service\nscripts/lvmlocks.service\nscripts/lvm2_monitoring_init_red_hat\nscripts/lvm2_monitoring_systemd_red_hat.service\nscripts/lvm2_tmpfiles_red_hat.conf\nscripts/lvmdump.sh\nscripts/Makefile\ntest/Makefile\ntools/Makefile\nudev/Makefile\n])\nAC_OUTPUT\n\nAS_IF([test -n \"$THIN_CONFIGURE_WARN\"],\n      [AC_MSG_WARN([Support for thin provisioning is limited since some thin provisioning tools are missing!])])\n\nAS_IF([test -n \"$THIN_CHECK_VERSION_WARN\"],\n      [AC_MSG_WARN([You should also install latest thin_check vsn 0.7.0 (or later) for lvm2 thin provisioning])])\n\nAS_IF([test -n \"$CACHE_CONFIGURE_WARN\"],\n      [AC_MSG_WARN([Support for cache is limited since some cache tools are missing!])])\n\nAS_IF([test -n \"$CACHE_CHECK_VERSION_WARN\"],\n      [AC_MSG_WARN([You should install latest cache_check vsn 0.7.0 to use lvm2 cache metadata format 2])])\n\nAS_IF([test -n \"$VDO_CONFIGURE_WARN\"],\n      [AC_MSG_WARN([unrecognized 'vdoformat' tool is REQUIRED for VDO logical volume creation!])])\n\n\nAS_IF([test \"$ODIRECT\" != yes],\n      [AC_MSG_WARN([O_DIRECT disabled: low-memory pvmove may lock up])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/lib/mm/memlock.c": "/*\n * Copyright (C) 2003-2004 Sistina Software, Inc. All rights reserved.\n * Copyright (C) 2004-2011 Red Hat, Inc. All rights reserved.\n *\n * This file is part of LVM2.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"lib/misc/lib.h\"\n#include \"lib/mm/memlock.h\"\n#include \"lib/config/defaults.h\"\n#include \"lib/config/config.h\"\n#include \"lib/commands/toolcontext.h\"\n\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <malloc.h>\n\n#ifdef HAVE_VALGRIND\n#include <valgrind.h>\n#endif\n\n#ifndef DEVMAPPER_SUPPORT\n\nvoid memlock_inc_daemon(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_dec_daemon(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid critical_section_inc(struct cmd_context *cmd, const char *reason)\n{\n\treturn;\n}\n\nvoid critical_section_dec(struct cmd_context *cmd, const char *reason)\n{\n\treturn;\n}\n\nint critical_section(void)\n{\n\treturn 0;\n}\nvoid memlock_init(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_unlock(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_reset(void)\n{\n\treturn;\n}\n\nint memlock_count_daemon(void)\n{\n\treturn 0;\n}\n\n#else\t\t\t\t/* DEVMAPPER_SUPPORT */\n\nstatic size_t _size_stack;\nstatic size_t _size_malloc_tmp;\nstatic size_t _size_malloc = 2000000;\n\nstatic void *_malloc_mem = NULL;\nstatic int _mem_locked = 0;\nstatic int _priority_raised = 0;\nstatic int _critical_section = 0;\nstatic int _prioritized_section = 0;\nstatic int _memlock_count_daemon = 0;\nstatic int _priority;\nstatic int _default_priority;\n\n/* list of maps, that are unconditionaly ignored */\nstatic const char * const _ignore_maps[] = {\n\t\"[vdso]\",\n\t\"[vsyscall]\",\n\t\"[vectors]\",\n};\n\n/* default blacklist for maps */\nstatic const char * const _blacklist_maps[] = {\n\t\"locale/locale-archive\",\n\t\"/LC_MESSAGES/\",\n\t\"gconv/gconv-modules.cache\",\n\t\"/ld-2.\",\t\t/* not using dlopen,dlsym during mlock */\n\t\"/libaio.so.\",\t\t/* not using aio during mlock */\n\t\"/libattr.so.\",\t\t/* not using during mlock (udev) */\n\t\"/libblkid.so.\",\t/* not using blkid during mlock (udev) */\n\t\"/libbz2.so.\",\t\t/* not using during mlock (udev) */\n\t\"/libcap.so.\",\t\t/* not using during mlock (systemd) */\n\t\"/libdl-\",\t\t/* not using dlopen,dlsym during mlock */\n\t\"/libdw-\",\t\t/* not using during mlock (udev) */\n\t\"/libelf-\",\t\t/* not using during mlock (udev) */\n\t\"/libgcrypt.so.\",\t/* not using during mlock (systemd) */\n\t\"/libgpg-error.so.\",\t/* not using gpg-error during mlock (systemd) */\n\t\"/liblz4.so.\",\t\t/* not using lz4 during mlock (systemd) */\n\t\"/liblzma.so.\",\t\t/* not using lzma during mlock (systemd) */\n\t\"/libmount.so.\",\t/* not using mount during mlock (udev) */\n\t\"/libncurses.so.\",\t/* not using ncurses during mlock */\n\t\"/libpcre.so.\",\t\t/* not using pcre during mlock (selinux) */\n\t\"/libpcre2-\",\t\t/* not using pcre during mlock (selinux) */\n\t\"/libreadline.so.\",\t/* not using readline during mlock */\n\t\"/libresolv-\",\t\t/* not using during mlock (udev) */\n\t\"/libselinux.so.\",\t/* not using selinux during mlock */\n\t\"/libsepol.so.\",\t/* not using sepol during mlock */\n\t\"/libsystemd.so.\",\t/* not using systemd during mlock */\n\t\"/libtinfo.so.\",\t/* not using tinfo during mlock */\n\t\"/libudev.so.\",\t\t/* not using udev during mlock */\n\t\"/libuuid.so.\",\t\t/* not using uuid during mlock (blkid) */\n\t\"/libz.so.\",\t\t/* not using during mlock (udev) */\n\t\"/etc/selinux\",\t\t/* not using selinux during mlock */\n\t/* \"/libdevmapper-event.so\" */\n};\n\ntypedef enum { LVM_MLOCK, LVM_MUNLOCK } lvmlock_t;\n\nstatic unsigned _use_mlockall;\nstatic int _maps_fd;\nstatic size_t _maps_len = 8192; /* Initial buffer size for reading /proc/self/maps */\nstatic char *_maps_buffer;\nstatic char _procselfmaps[PATH_MAX] = \"\";\n#define SELF_MAPS \"/self/maps\"\n\nstatic size_t _mstats; /* statistic for maps locking */\n\nstatic void _touch_memory(void *mem, size_t size)\n{\n\tsize_t pagesize = lvm_getpagesize();\n\tchar *pos = mem;\n\tchar *end = pos + size - sizeof(long);\n\n\twhile (pos < end) {\n\t\t*(long *) pos = 1;\n\t\tpos += pagesize;\n\t}\n}\n\nstatic void _allocate_memory(void)\n{\n#ifndef VALGRIND_POOL\n\tvoid *stack_mem;\n\tstruct rlimit limit;\n\tint i, area = 0, missing = _size_malloc_tmp, max_areas = 32, hblks;\n\tchar *areas[max_areas];\n\n\t/* Check if we could preallocate requested stack */\n\tif ((getrlimit (RLIMIT_STACK, &limit) == 0) &&\n\t    ((_size_stack * 2) < limit.rlim_cur) &&\n\t    ((stack_mem = alloca(_size_stack))))\n\t\t_touch_memory(stack_mem, _size_stack);\n\t/* FIXME else warn user setting got ignored */\n\n        /*\n         *  When a brk() fails due to fragmented address space (which sometimes\n         *  happens when we try to grab 8M or so), glibc will make a new\n         *  arena. In this arena, the rules for using \u201cdirect\u201d mmap are relaxed,\n         *  circumventing the MAX_MMAPs and MMAP_THRESHOLD settings. We can,\n         *  however, detect when this happens with mallinfo() and try to co-opt\n         *  malloc into using MMAP as a MORECORE substitute instead of returning\n         *  MMAP'd memory directly. Since MMAP-as-MORECORE does not munmap the\n         *  memory on free(), this is good enough for our purposes.\n         */\n\twhile (missing > 0) {\n\t\tstruct mallinfo inf = mallinfo();\n\t\thblks = inf.hblks;\n\n\t\tif ((areas[area] = malloc(_size_malloc_tmp)))\n\t\t\t_touch_memory(areas[area], _size_malloc_tmp);\n\n\t\tinf = mallinfo();\n\n\t\tif (hblks < inf.hblks) {\n\t\t\t/* malloc cheated and used mmap, even though we told it\n\t\t\t   not to; we try with twice as many areas, each half\n\t\t\t   the size, to circumvent the faulty logic in glibc */\n\t\t\tfree(areas[area]);\n\t\t\t_size_malloc_tmp /= 2;\n\t\t} else {\n\t\t\t++ area;\n\t\t\tmissing -= _size_malloc_tmp;\n\t\t}\n\n\t\tif (area == max_areas && missing > 0) {\n\t\t\t/* Too bad. Warn the user and proceed, as things are\n\t\t\t * most likely going to work out anyway. */\n\t\t\tlog_warn(\"WARNING: Failed to reserve memory, %d bytes missing.\", missing);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((_malloc_mem = malloc(_size_malloc)))\n\t\t_touch_memory(_malloc_mem, _size_malloc);\n\n\t/* free up the reserves so subsequent malloc's can use that memory */\n\tfor (i = 0; i < area; ++i)\n\t\tfree(areas[i]);\n#endif\n}\n\nstatic void _release_memory(void)\n{\n\tfree(_malloc_mem);\n}\n\n/*\n * mlock/munlock memory areas from /proc/self/maps\n * format described in kernel/Documentation/filesystem/proc.txt\n */\nstatic int _maps_line(const struct dm_config_node *cn, lvmlock_t lock,\n\t\t      const char *line, size_t *mstats)\n{\n\tconst struct dm_config_value *cv;\n\tlong from, to;\n\tint pos;\n\tunsigned i;\n\tchar fr, fw, fx, fp;\n\tsize_t sz;\n\tconst char *lock_str = (lock == LVM_MLOCK) ? \"mlock\" : \"munlock\";\n\n\tif (sscanf(line, \"%lx-%lx %c%c%c%c%n\",\n\t\t   &from, &to, &fr, &fw, &fx, &fp, &pos) != 6) {\n\t\tlog_error(\"Failed to parse maps line: %s\", line);\n\t\treturn 0;\n\t}\n\n\t/* Select readable maps */\n\tif (fr != 'r') {\n\t\tlog_debug_mem(\"%s area unreadable %s : Skipping.\", lock_str, line);\n\t\treturn 1;\n\t}\n\n\t/* always ignored areas */\n\tfor (i = 0; i < DM_ARRAY_SIZE(_ignore_maps); ++i)\n\t\tif (strstr(line + pos, _ignore_maps[i])) {\n\t\t\tlog_debug_mem(\"%s ignore filter '%s' matches '%s': Skipping.\",\n\t\t\t\t      lock_str, _ignore_maps[i], line);\n\t\t\treturn 1;\n\t\t}\n\n\tsz = to - from;\n\tif (!cn) {\n\t\t/* If no blacklist configured, use an internal set */\n\t\tfor (i = 0; i < DM_ARRAY_SIZE(_blacklist_maps); ++i)\n\t\t\tif (strstr(line + pos, _blacklist_maps[i])) {\n\t\t\t\tlog_debug_mem(\"%s default filter '%s' matches '%s': Skipping.\",\n\t\t\t\t\t      lock_str, _blacklist_maps[i], line);\n\t\t\t\treturn 1;\n\t\t\t}\n\t} else {\n\t\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\t\tif ((cv->type != DM_CFG_STRING) || !cv->v.str[0])\n\t\t\t\tcontinue;\n\t\t\tif (strstr(line + pos, cv->v.str)) {\n\t\t\t\tlog_debug_mem(\"%s_filter '%s' matches '%s': Skipping.\",\n\t\t\t\t\t      lock_str, cv->v.str, line);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_VALGRIND\n\t/*\n\t * Valgrind is continually eating memory while executing code\n\t * so we need to deactivate check of locked memory size\n\t */\n#ifndef VALGRIND_POOL\n\tif (RUNNING_ON_VALGRIND)\n#endif\n\t\tsz -= sz; /* = 0, but avoids getting warning about dead assigment */\n\n#endif\n\t*mstats += sz;\n\tlog_debug_mem(\"%s %10ldKiB %12lx - %12lx %c%c%c%c%s\", lock_str,\n\t\t      ((long)sz + 1023) / 1024, from, to, fr, fw, fx, fp, line + pos);\n\n\tif (lock == LVM_MLOCK) {\n\t\tif (mlock((const void*)from, sz) < 0) {\n\t\t\tlog_sys_error(\"mlock\", line);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (munlock((const void*)from, sz) < 0) {\n\t\t\tlog_sys_error(\"munlock\", line);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int _memlock_maps(struct cmd_context *cmd, lvmlock_t lock, size_t *mstats)\n{\n\tconst struct dm_config_node *cn;\n\tchar *line, *line_end;\n\tsize_t len;\n\tssize_t n;\n\tint ret = 1;\n\n\tif (_use_mlockall) {\n#ifdef MCL_CURRENT\n\t\tif (lock == LVM_MLOCK) {\n\t\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\t\tlog_sys_error(\"mlockall\", \"\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (munlockall()) {\n\t\t\t\tlog_sys_error(\"munlockall\", \"\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n#else\n\t\treturn 0;\n#endif\n\t}\n\n\t/* Reset statistic counters */\n\t*mstats = 0;\n\n\t/* read mapping into a single memory chunk without reallocation\n\t * in the middle of reading maps file */\n\tfor (len = 0;;) {\n\t\tif (!_maps_buffer || len >= _maps_len) {\n\t\t\tif (_maps_buffer)\n\t\t\t\t_maps_len *= 2;\n\t\t\tif (!(line = realloc(_maps_buffer, _maps_len))) {\n\t\t\t\tlog_error(\"Allocation of maps buffer failed.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t_maps_buffer = line;\n\t\t}\n\t\tif (lseek(_maps_fd, 0, SEEK_SET))\n\t\t\tlog_sys_error(\"lseek\", _procselfmaps);\n\t\tfor (len = 0 ; len < _maps_len; len += n) {\n\t\t\tif (!(n = read(_maps_fd, _maps_buffer + len, _maps_len - len)))\n\t\t\t\tbreak; /* EOF */\n\t\t\tif (n == -1) {\n\t\t\t\tlog_sys_error(\"read\", _procselfmaps);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (len < _maps_len) { /* fits in buffer */\n\t\t\t_maps_buffer[len] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tline = _maps_buffer;\n\tcn = find_config_tree_array(cmd, activation_mlock_filter_CFG, NULL);\n\n\twhile ((line_end = strchr(line, '\\n'))) {\n\t\t*line_end = '\\0'; /* remove \\n */\n\t\tif (!_maps_line(cn, lock, line, mstats))\n\t\t\tret = 0;\n\t\tline = line_end + 1;\n\t}\n\n\tlog_debug_mem(\"%socked %ld bytes\",\n\t\t      (lock == LVM_MLOCK) ? \"L\" : \"Unl\", (long)*mstats);\n\n\treturn ret;\n}\n\n#ifdef DEBUG_MEMLOCK\n/*\n * LVM is not supposed to use mmap while devices are suspended.\n * This code causes a core dump if gets called.\"\n */\n#  ifdef __i386__\n#    define ARCH_X86\n#  endif /* __i386__ */\n#  ifdef __x86_64__\n#    ifndef ARCH_X86\n#      define ARCH_X86\n#    endif /* ARCH_X86 */\n#  endif /* __x86_64__ */\n\n#endif /* DEBUG_MEMLOCK */\n\n#ifdef ARCH_X86\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <dlfcn.h>\nstatic const unsigned char _instruction_hlt = 0x94;\nstatic char _mmap_orig;\nstatic unsigned char *_mmap_addr;\n#ifdef __i386__\nstatic char _mmap64_orig;\nstatic unsigned char *_mmap64_addr;\n#endif /* __i386__ */\n#endif /* ARCH_X86 */\n\nstatic int _disable_mmap(void)\n{\n#ifdef ARCH_X86\n\tvolatile unsigned char *abs_addr;\n\n\tif (!_mmap_addr) {\n\t\t_mmap_addr = (unsigned char *) dlsym(RTLD_NEXT, \"mmap\");\n\t\tif (_mmap_addr[0] == 0xff && _mmap_addr[1] == 0x25) { /* plt */\n#ifdef __x86_64__\n\t\t\tabs_addr = _mmap_addr + 6 + *(int32_t *)(_mmap_addr + 2);\n#endif /* __x86_64__ */\n#ifdef __i386__\n\t\t\tabs_addr = *(void **)(_mmap_addr + 2);\n#endif /* __i386__ */\n\t\t\t_mmap_addr = *(void **)abs_addr;\n\t\t} else\n\t\t\tlog_debug_mem(\"Can't find PLT jump entry assuming -fPIE linkage.\");\n\t\tif (mprotect((void *)((unsigned long)_mmap_addr & ~4095UL), 4096, PROT_READ|PROT_WRITE|PROT_EXEC)) {\n\t\t\tlog_sys_error(\"mprotect\", \"\");\n\t\t\t_mmap_addr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t_mmap_orig = *_mmap_addr;\n\t}\n\tlog_debug_mem(\"Remapping mmap entry %02x to %02x.\", _mmap_orig, _instruction_hlt);\n\t*_mmap_addr = _instruction_hlt;\n\n#ifdef __i386__\n\tif (!_mmap64_addr) {\n\t\t_mmap64_addr = (unsigned char *) dlsym(RTLD_NEXT, \"mmap64\");\n\t\tif (_mmap64_addr[0] == 0xff && _mmap64_addr[1] == 0x25) {\n\t\t\tabs_addr = *(void **)(_mmap64_addr + 2);\n\t\t\t_mmap64_addr = *(void **)abs_addr;\n\t\t} /* Can't find PLT jump entry assuming -fPIE linkage */\n\t\tif (mprotect((void *)((unsigned long)_mmap64_addr & ~4095UL), 4096, PROT_READ|PROT_WRITE|PROT_EXEC)) {\n\t\t\tlog_sys_error(\"mprotect\", \"\");\n\t\t\t_mmap64_addr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t_mmap64_orig = *_mmap64_addr;\n\t}\n\t*_mmap64_addr = INSTRUCTION_HLT;\n#endif /* __i386__ */\n#endif /* ARCH_X86 */\n\treturn 1;\n}\n\nstatic int _restore_mmap(void)\n{\n#ifdef ARCH_X86\n\tif (_mmap_addr)\n\t\t*_mmap_addr = _mmap_orig;\n#ifdef __i386__\n\tif (_mmap64_addr)\n\t\t*_mmap64_addr = _mmap64_orig;\n#endif /* __i386__ */\n\tlog_debug_mem(\"Restored mmap entry.\");\n#endif /* ARCH_X86 */\n\treturn 1;\n}\nstatic void _raise_priority(struct cmd_context *cmd)\n{\n\tif (_priority_raised)\n\t\treturn;\n\n\t_priority_raised = 1;\n\terrno = 0;\n\tif (((_priority = getpriority(PRIO_PROCESS, 0)) == -1) && errno)\n\t\tlog_sys_debug(\"getpriority\", \"\");\n\telse if (_default_priority < _priority) {\n\t\tif (setpriority(PRIO_PROCESS, 0, _default_priority) == 0)\n\t\t\tlog_debug_activation(\"Raised task priority %d -> %d.\",\n\t\t\t\t\t     _priority, _default_priority);\n\t\telse\n\t\t\tlog_warn(\"WARNING: setpriority %d failed: %s.\",\n\t\t\t\t _default_priority, strerror(errno));\n\t}\n}\n\nstatic void _restore_priority_if_possible(struct cmd_context *cmd)\n{\n\tif (!_priority_raised || _critical_section || _memlock_count_daemon)\n\t\treturn;\n\n\tif (setpriority(PRIO_PROCESS, 0, _priority) == 0)\n\t\tlog_debug_activation(\"Restoring original task priority %d.\", _priority);\n\telse\n\t\tlog_warn(\"WARNING: setpriority %u failed: %s.\",\n\t\t\t _priority, strerror(errno));\n\n\t_priority_raised = 0;\n}\n\n/* Stop memory getting swapped out */\nstatic void _lock_mem(struct cmd_context *cmd)\n{\n\t_allocate_memory();\n\t(void)strerror(0);\t\t/* Force libc.mo load */\n\t(void)dm_udev_get_sync_support(); /* udev is initialized */\n\tlog_very_verbose(\"Locking memory\");\n\n\t/*\n\t * For daemon we need to use mlockall()\n\t * so even future adition of thread which may not even use lvm lib\n\t * will not block memory locked thread\n\t * Note: assuming _memlock_count_daemon is updated before _memlock_count\n\t */\n\t_use_mlockall = _memlock_count_daemon ? 1 :\n\t\tfind_config_tree_bool(cmd, activation_use_mlockall_CFG, NULL);\n\n\tif (!_use_mlockall) {\n\t\tif (!*_procselfmaps &&\n\t\t    dm_snprintf(_procselfmaps, sizeof(_procselfmaps),\n\t\t\t\t\"%s\" SELF_MAPS, cmd->proc_dir) < 0) {\n\t\t\tlog_error(\"proc_dir too long\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(_maps_fd = open(_procselfmaps, O_RDONLY))) {\n\t\t\tlog_sys_error(\"open\", _procselfmaps);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!_disable_mmap())\n\t\t\tstack;\n\t}\n\n\tif (!_memlock_maps(cmd, LVM_MLOCK, &_mstats))\n\t\tstack;\n}\n\nstatic void _unlock_mem(struct cmd_context *cmd)\n{\n\tsize_t unlock_mstats;\n\n\tlog_very_verbose(\"Unlocking memory\");\n\n\tif (!_memlock_maps(cmd, LVM_MUNLOCK, &unlock_mstats))\n\t\tstack;\n\n\tif (!_use_mlockall) {\n\t\t_restore_mmap();\n\t\tif (close(_maps_fd))\n\t\t\tlog_sys_error(\"close\", _procselfmaps);\n\t\tfree(_maps_buffer);\n\t\t_maps_buffer = NULL;\n\t\tif (_mstats < unlock_mstats) {\n\t\t\tif ((_mstats + lvm_getpagesize()) < unlock_mstats)\n\t\t\t\tlog_error(INTERNAL_ERROR\n\t\t\t\t\t  \"Reserved memory (%ld) not enough: used %ld. Increase activation/reserved_memory?\",\n\t\t\t\t\t  (long)_mstats, (long)unlock_mstats);\n\t\t\telse\n\t\t\t\t/* FIXME Believed due to incorrect use of yes_no_prompt while locks held */\n\t\t\t\tlog_debug_mem(\"Suppressed internal error: Maps lock %ld < unlock %ld, a one-page difference.\",\n\t\t\t\t\t      (long)_mstats, (long)unlock_mstats);\n\t\t}\n\t}\n\n\t_restore_priority_if_possible(cmd);\n\n\t_release_memory();\n}\n\nstatic void _lock_mem_if_needed(struct cmd_context *cmd)\n{\n\tlog_debug_mem(\"Lock:   Memlock counters: prioritized:%d locked:%d critical:%d daemon:%d suspended:%d\",\n\t\t      _priority_raised, _mem_locked, _critical_section, _memlock_count_daemon, dm_get_suspended_counter());\n\tif (!_mem_locked &&\n\t    ((_critical_section + _memlock_count_daemon) == 1)) {\n\t\t_mem_locked = 1;\n\t\t_lock_mem(cmd);\n\t}\n}\n\nstatic void _unlock_mem_if_possible(struct cmd_context *cmd)\n{\n\tlog_debug_mem(\"Unlock: Memlock counters: prioritized:%d locked:%d critical:%d daemon:%d suspended:%d\",\n\t\t      _priority_raised, _mem_locked, _critical_section, _memlock_count_daemon, dm_get_suspended_counter());\n\tif (_mem_locked &&\n\t    !_critical_section &&\n\t    !_memlock_count_daemon) {\n\t\t_unlock_mem(cmd);\n\t\t_mem_locked = 0;\n\t}\n}\n\n/*\n * Critical section is only triggered with suspending reason.\n * Other reasons only raise process priority so the table manipulation\n * remains fast.\n *\n * Memory stays locked until 'memlock_unlock()' is called so when possible\n * it may stay locked across multiple crictical section entrances.\n */\nvoid critical_section_inc(struct cmd_context *cmd, const char *reason)\n{\n\tif (!_critical_section &&\n\t    (strcmp(reason, \"suspending\") == 0)) {\n\t\t/*\n\t\t * Profiles are loaded on-demand so make sure that before\n\t\t * entering the critical section all needed profiles are\n\t\t * loaded to avoid the disk access later.\n\t\t */\n\t\t(void) load_pending_profiles(cmd);\n\t\t_critical_section = 1;\n\t\tlog_debug_activation(\"Entering critical section (%s).\", reason);\n\t\t_lock_mem_if_needed(cmd);\n\t} else\n\t\tlog_debug_activation(\"Entering prioritized section (%s).\", reason);\n\n\t_raise_priority(cmd);\n\t_prioritized_section++;\n}\n\nvoid critical_section_dec(struct cmd_context *cmd, const char *reason)\n{\n\tif (_critical_section && !dm_get_suspended_counter()) {\n\t\t_critical_section = 0;\n\t\tlog_debug_activation(\"Leaving critical section (%s).\", reason);\n\t} else\n\t\tlog_debug_activation(\"Leaving section (%s).\", reason);\n\n\tif (_prioritized_section > 0)\n\t\t_prioritized_section--;\n}\n\nint critical_section(void)\n{\n\treturn _critical_section;\n}\n\nint prioritized_section(void)\n{\n\treturn _prioritized_section;\n}\n\n/*\n * The memlock_*_daemon functions will force the mlockall() call that we need\n * to stay in memory, but they will have no effect on device scans (unlike\n * normal critical_section_inc/dec). Memory is kept locked as long as either\n * of critical_section or memlock_daemon is in effect.\n */\n\nvoid memlock_inc_daemon(struct cmd_context *cmd)\n{\n\t++_memlock_count_daemon;\n\tif (_memlock_count_daemon == 1 && _critical_section > 0)\n\t\tlog_error(INTERNAL_ERROR \"_memlock_inc_daemon used in critical section.\");\n\tlog_debug_mem(\"memlock_count_daemon inc to %d\", _memlock_count_daemon);\n\t_lock_mem_if_needed(cmd);\n\t_raise_priority(cmd);\n}\n\nvoid memlock_dec_daemon(struct cmd_context *cmd)\n{\n\tif (!_memlock_count_daemon)\n\t\tlog_error(INTERNAL_ERROR \"_memlock_count_daemon has dropped below 0.\");\n\t--_memlock_count_daemon;\n\tlog_debug_mem(\"memlock_count_daemon dec to %d\", _memlock_count_daemon);\n\t_unlock_mem_if_possible(cmd);\n}\n\nvoid memlock_init(struct cmd_context *cmd)\n{\n\t/* When threaded, caller already limited stack size so just use the default. */\n\t_size_stack = 1024ULL * (cmd->threaded ? DEFAULT_RESERVED_STACK :\n\t\t\t\t find_config_tree_int(cmd, activation_reserved_stack_CFG, NULL));\n\t_size_malloc_tmp = find_config_tree_int(cmd, activation_reserved_memory_CFG, NULL) * 1024ULL;\n\t_default_priority = find_config_tree_int(cmd, activation_process_priority_CFG, NULL);\n}\n\nvoid memlock_reset(void)\n{\n\tlog_debug_mem(\"memlock reset.\");\n\t_mem_locked = 0;\n\t_priority_raised = 0;\n\t_critical_section = 0;\n\t_prioritized_section = 0;\n\t_memlock_count_daemon = 0;\n}\n\nvoid memlock_unlock(struct cmd_context *cmd)\n{\n\t_unlock_mem_if_possible(cmd);\n\t_restore_priority_if_possible(cmd);\n}\n\nint memlock_count_daemon(void)\n{\n\treturn _memlock_count_daemon;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/lib/misc/sharedlib.c": "/*\n * Copyright (C) 2002-2004 Sistina Software, Inc. All rights reserved.\n * Copyright (C) 2004-2006 Red Hat, Inc. All rights reserved.\n *\n * This file is part of LVM2.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"lib/misc/lib.h\"\n#include \"lib/config/config.h\"\n#include \"lib/misc/sharedlib.h\"\n#include \"lib/commands/toolcontext.h\"\n\n#include <limits.h>\n#include <sys/stat.h>\n#include <dlfcn.h>\n\nvoid get_shared_library_path(struct cmd_context *cmd, const char *libname,\n\t\t\t     char *path, size_t path_len)\n{\n\tstruct stat info;\n\n\tif (!path_len)\n\t\treturn;\n\n\t/* If libname doesn't begin with '/' then use lib_dir/libname,\n\t * if present */\n\tif (libname[0] == '/' ||\n\t    (!cmd->lib_dir &&\n\t     !(cmd->lib_dir = find_config_tree_str(cmd, global_library_dir_CFG, NULL))) ||\n\t    (dm_snprintf(path, path_len, \"%s/%s\", cmd->lib_dir,\n\t\t\t libname) == -1) || stat(path, &info) == -1) {\n\t\t(void) dm_strncpy(path, libname, path_len);\n\t}\n}\n\nvoid *load_shared_library(struct cmd_context *cmd, const char *libname,\n\t\t\t  const char *desc, int silent)\n{\n\tchar path[PATH_MAX];\n\tvoid *library;\n\n\tif (is_static()) {\n\t\tlog_error(\"Not loading shared %s library %s in static mode.\",\n\t\t\t  desc, libname);\n\t\treturn NULL;\n\t}\n\n\tget_shared_library_path(cmd, libname, path, sizeof(path));\n\n\tlog_very_verbose(\"Opening shared %s library %s\", desc, path);\n\n\tif (!(library = dlopen(path, RTLD_LAZY | RTLD_GLOBAL))) {\n\t\tif (silent)\n\t\t\tlog_verbose(\"Unable to open external %s library %s: %s\",\n\t\t\t\t    desc, path, dlerror());\n\t\telse\n\t\t\tlog_error(\"Unable to open external %s library %s: %s\",\n\t\t\t\t  desc, path, dlerror());\n\t}\n\n\treturn library;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/daemons/dmeventd/dmeventd.c": "/*\n * Copyright (C) 2005-2015 Red Hat, Inc. All rights reserved.\n *\n * This file is part of the device-mapper userspace tools.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/*\n * dmeventd - dm event daemon to monitor active mapped devices\n */\n\n#include \"device_mapper/misc/dmlib.h\"\n#include \"base/memory/zalloc.h\"\n#include \"device_mapper/misc/dm-logging.h\"\n\n#include \"daemons/dmeventd/libdevmapper-event.h\"\n#include \"dmeventd.h\"\n\n#include \"tools/tool.h\"\n\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <signal.h>\n#include <arpa/inet.h>\t\t/* for htonl, ntohl */\n#include <fcntl.h>\t\t/* for musl libc */\n\n#ifdef __linux__\n/*\n * Kernel version 2.6.36 and higher has\n * new OOM killer adjustment interface.\n */\n#  define OOM_ADJ_FILE_OLD \"/proc/self/oom_adj\"\n#  define OOM_ADJ_FILE \"/proc/self/oom_score_adj\"\n\n/* From linux/oom.h */\n/* Old interface */\n#  define OOM_DISABLE (-17)\n#  define OOM_ADJUST_MIN (-16)\n/* New interface */\n#  define OOM_SCORE_ADJ_MIN (-1000)\n\n/* Systemd on-demand activation support */\n#  define SD_RUNTIME_UNIT_FILE_DIR DEFAULT_DM_RUN_DIR \"/systemd/system/\"\n#  define SD_ACTIVATION_ENV_VAR_NAME \"SD_ACTIVATION\"\n#  define SD_LISTEN_PID_ENV_VAR_NAME \"LISTEN_PID\"\n#  define SD_LISTEN_FDS_ENV_VAR_NAME \"LISTEN_FDS\"\n#  define SD_LISTEN_FDS_START 3\n#  define SD_FD_FIFO_SERVER SD_LISTEN_FDS_START\n#  define SD_FD_FIFO_CLIENT (SD_LISTEN_FDS_START + 1)\n\n#endif\n\n#include <syslog.h>\n\n#define DM_SIGNALED_EXIT  1\n#define DM_SCHEDULED_EXIT 2\nstatic volatile sig_atomic_t _exit_now = 0;\t/* set to '1' when signal is given to exit */\n\n/* List (un)link macros. */\n#define\tLINK(x, head)\t\tdm_list_add(head, &(x)->list)\n#define\tLINK_DSO(dso)\t\tLINK(dso, &_dso_registry)\n#define\tLINK_THREAD(thread)\tLINK(thread, &_thread_registry)\n\n#define\tUNLINK(x)\t\tdm_list_del(&(x)->list)\n#define\tUNLINK_DSO(x)\t\tUNLINK(x)\n#define\tUNLINK_THREAD(x)\tUNLINK(x)\n\n#define DAEMON_NAME \"dmeventd\"\n\n/*\n  Global mutex for thread list access. Has to be held when:\n  - iterating thread list\n  - adding or removing elements from thread list\n  - changing or reading thread_status's fields:\n    processing, status, events\n  Use _lock_mutex() and _unlock_mutex() to hold/release it\n*/\nstatic pthread_mutex_t _global_mutex;\n\nstatic const size_t THREAD_STACK_SIZE = 300 * 1024;\n\n/* Default idle exit timeout 1 hour (in seconds) */\nstatic const time_t DMEVENTD_IDLE_EXIT_TIMEOUT = 60 * 60;\n\nstatic int _debug_level = 0;\nstatic int _use_syslog = 1;\nstatic int _systemd_activation = 0;\nstatic int _foreground = 0;\nstatic int _restart = 0;\nstatic time_t _idle_since = 0;\nstatic char **_initial_registrations = 0;\n\n/* FIXME Make configurable at runtime */\n\n/* All libdm messages */\n__attribute__((format(printf, 5, 6)))\nstatic void _libdm_log(int level, const char *file, int line,\n\t\t       int dm_errno_or_class, const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tdm_event_log(\"#dm\", level, file, line, dm_errno_or_class, format, ap);\n\tva_end(ap);\n}\n\n/* All dmeventd messages */\n#undef LOG_MESG\n#define LOG_MESG(l, f, ln, e, x...) _dmeventd_log(l, f, ln, e, ## x)\n__attribute__((format(printf, 5, 6)))\nstatic void _dmeventd_log(int level, const char *file, int line,\n\t\t\t  int dm_errno_or_class, const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tdm_event_log(\"dmeventd\", level, file, line, dm_errno_or_class, format, ap);\n\tva_end(ap);\n}\n\n#ifdef DEBUG\n#  define DEBUGLOG  log_debug\nstatic const char *decode_cmd(uint32_t cmd)\n{\n\tswitch (cmd) {\n\tcase DM_EVENT_CMD_ACTIVE:\t\t\treturn \"ACTIVE\";\n\tcase DM_EVENT_CMD_REGISTER_FOR_EVENT:\t\treturn \"REGISTER_FOR_EVENT\";\n\tcase DM_EVENT_CMD_UNREGISTER_FOR_EVENT:\t\treturn \"UNREGISTER_FOR_EVENT\";\n\tcase DM_EVENT_CMD_GET_REGISTERED_DEVICE:\treturn \"GET_REGISTERED_DEVICE\";\n\tcase DM_EVENT_CMD_GET_NEXT_REGISTERED_DEVICE:\treturn \"GET_NEXT_REGISTERED_DEVICE\";\n\tcase DM_EVENT_CMD_SET_TIMEOUT:\t\t\treturn \"SET_TIMEOUT\";\n\tcase DM_EVENT_CMD_GET_TIMEOUT:\t\t\treturn \"GET_TIMEOUT\";\n\tcase DM_EVENT_CMD_HELLO:\t\t\treturn \"HELLO\";\n\tcase DM_EVENT_CMD_DIE:\t\t\t\treturn \"DIE\";\n\tcase DM_EVENT_CMD_GET_STATUS:\t\t\treturn \"GET_STATUS\";\n\tcase DM_EVENT_CMD_GET_PARAMETERS:\t\treturn \"GET_PARAMETERS\";\n\tdefault:\t\t\t\t\treturn \"unknown\";\n\t}\n}\n\n#else\n#  define DEBUGLOG(fmt, args...) do { } while (0)\n#endif\n\n/* Data kept about a DSO. */\nstruct dso_data {\n\tstruct dm_list list;\n\n\tchar *dso_name;\t\t/* DSO name (eg, \"evms\", \"dmraid\", \"lvm2\"). */\n\n\tvoid *dso_handle;\t/* Opaque handle as returned from dlopen(). */\n\tunsigned int ref_count;\t/* Library reference count. */\n\n\t/*\n\t * Event processing.\n\t *\n\t * The DSO can do whatever appropriate steps if an event\n\t * happens such as changing the mapping in case a mirror\n\t * fails, update the application metadata etc.\n\t *\n\t * This function gets a dm_task that is a result of\n\t * DM_DEVICE_WAITEVENT ioctl (results equivalent to\n\t * DM_DEVICE_STATUS). It should not destroy it.\n\t * The caller must dispose of the task.\n\t */\n\tvoid (*process_event)(struct dm_task *dmt, enum dm_event_mask event, void **user);\n\n\t/*\n\t * Device registration.\n\t *\n\t * When an application registers a device for an event, the DSO\n\t * can carry out appropriate steps so that a later call to\n\t * the process_event() function is sane (eg, read metadata\n\t * and activate a mapping).\n\t */\n\tint (*register_device)(const char *device, const char *uuid, int major,\n\t\t\t       int minor, void **user);\n\n\t/*\n\t * Device unregistration.\n\t *\n\t * In case all devices of a mapping (eg, RAID10) are unregistered\n\t * for events, the DSO can recognize this and carry out appropriate\n\t * steps (eg, deactivate mapping, metadata update).\n\t */\n\tint (*unregister_device)(const char *device, const char *uuid,\n\t\t\t\t int major, int minor, void **user);\n};\nstatic DM_LIST_INIT(_dso_registry);\n\n/* Structure to keep parsed register variables from client message. */\nstruct message_data {\n\tchar *id;\n\tchar *dso_name;\t\t/* Name of DSO. */\n\tchar *device_uuid;\t/* Mapped device path. */\n\tchar *events_str;\t/* Events string as fetched from message. */\n\tenum dm_event_mask events_field;\t/* Events bitfield. */\n\tchar *timeout_str;\n\tuint32_t timeout_secs;\n\tstruct dm_event_daemon_message *msg;\t/* Pointer to message buffer. */\n};\n\n/* There are three states a thread can attain. */\nenum {\n\tDM_THREAD_REGISTERING,\t/* Registering, transitions to RUNNING */\n\tDM_THREAD_RUNNING,\t/* Working on events, transitions to DONE */\n\tDM_THREAD_DONE\t\t/* Terminated and cleanup is pending */\n};\n\n/*\n * Housekeeping of thread+device states.\n *\n * One thread per mapped device which can block on it until an event\n * occurs and the event processing function of the DSO gets called.\n */\nstruct thread_status {\n\tstruct dm_list list;\n\n\tpthread_t thread;\n\n\tstruct dso_data *dso_data;\t/* DSO this thread accesses. */\n\n\tstruct {\n\t\tchar *uuid;\n\t\tchar *name;\n\t\tint major, minor;\n\t} device;\n\tint processing;\t\t/* Set when event is being processed */\n\n\tint status;\t\t/* See DM_THREAD_{REGISTERING,RUNNING,DONE} */\n\n\tint events;\t\t/* bitfield for event filter. */\n\tint current_events;\t/* bitfield for occured events. */\n\tstruct dm_task *wait_task;\n\tint pending;\t\t/* Set when event filter change is pending */\n\ttime_t next_time;\n\tuint32_t timeout;\n\tstruct dm_list timeout_list;\n\tvoid *dso_private; /* dso per-thread status variable */\n\t/* TODO per-thread mutex */\n};\n\nstatic DM_LIST_INIT(_thread_registry);\nstatic DM_LIST_INIT(_thread_registry_unused);\n\nstatic int _timeout_running;\nstatic DM_LIST_INIT(_timeout_registry);\nstatic pthread_mutex_t _timeout_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t _timeout_cond = PTHREAD_COND_INITIALIZER;\n\n\n/**********\n *   DSO\n **********/\n\n/* DSO data allocate/free. */\nstatic void _free_dso_data(struct dso_data *data)\n{\n\tfree(data->dso_name);\n\tfree(data);\n}\n\nstatic struct dso_data *_alloc_dso_data(struct message_data *data)\n{\n\tstruct dso_data *ret = (typeof(ret)) zalloc(sizeof(*ret));\n\n\tif (!ret)\n\t\treturn_NULL;\n\n\tif (!(ret->dso_name = strdup(data->dso_name))) {\n\t\tfree(ret);\n\t\treturn_NULL;\n\t}\n\n\treturn ret;\n}\n\n/* DSO reference counting. */\nstatic void _lib_get(struct dso_data *data)\n{\n\tdata->ref_count++;\n}\n\nstatic void _lib_put(struct dso_data *data)\n{\n\tif (!--data->ref_count) {\n\t\tdlclose(data->dso_handle);\n\t\tUNLINK_DSO(data);\n\t\t_free_dso_data(data);\n\n\t\t/* Close control device if there is no plugin in-use */\n\t\tif (dm_list_empty(&_dso_registry)) {\n\t\t\tDEBUGLOG(\"Unholding control device.\");\n\t\t\tdm_hold_control_dev(0);\n\t\t\tdm_lib_release();\n\t\t\t_idle_since = time(NULL);\n\t\t}\n\t}\n}\n\n/* Find DSO data. */\nstatic struct dso_data *_lookup_dso(struct message_data *data)\n{\n\tstruct dso_data *dso_data, *ret = NULL;\n\n\tdm_list_iterate_items(dso_data, &_dso_registry)\n\t\tif (!strcmp(data->dso_name, dso_data->dso_name)) {\n\t\t\tret = dso_data;\n\t\t\tbreak;\n\t\t}\n\n\treturn ret;\n}\n\n/* Lookup DSO symbols we need. */\nstatic int _lookup_symbol(void *dl, void **symbol, const char *name)\n{\n\tif (!(*symbol = dlsym(dl, name)))\n\t\treturn_0;\n\n\treturn 1;\n}\n\nstatic int _lookup_symbols(void *dl, struct dso_data *data)\n{\n\treturn _lookup_symbol(dl, (void *) &data->process_event,\n\t\t\t     \"process_event\") &&\n\t    _lookup_symbol(dl, (void *) &data->register_device,\n\t\t\t  \"register_device\") &&\n\t    _lookup_symbol(dl, (void *) &data->unregister_device,\n\t\t\t  \"unregister_device\");\n}\n\n/* Load an application specific DSO. */\nstatic struct dso_data *_load_dso(struct message_data *data)\n{\n\tvoid *dl;\n\tstruct dso_data *ret;\n\tconst char *dlerr;\n\n\tif (!(dl = dlopen(data->dso_name, RTLD_NOW))) {\n\t\tdlerr = dlerror();\n\t\tgoto_bad;\n\t}\n\n\tif (!(ret = _alloc_dso_data(data))) {\n\t\tdlclose(dl);\n\t\tdlerr = \"no memory\";\n\t\tgoto_bad;\n\t}\n\n\tif (!(_lookup_symbols(dl, ret))) {\n\t\t_free_dso_data(ret);\n\t\tdlclose(dl);\n\t\tdlerr = \"symbols missing\";\n\t\tgoto_bad;\n\t}\n\n\t/* Keep control device open until last user closes */\n\tif (dm_list_empty(&_dso_registry)) {\n\t\tDEBUGLOG(\"Holding control device open.\");\n\t\tdm_hold_control_dev(1);\n\t\t_idle_since = 0;\n\t}\n\n\t/*\n\t * Keep handle to close the library once\n\t * we've got no references to it any more.\n\t */\n\tret->dso_handle = dl;\n\tLINK_DSO(ret);\n\n\treturn ret;\nbad:\n\tlog_error(\"dmeventd %s dlopen failed: %s.\", data->dso_name, dlerr);\n\tdata->msg->size = dm_asprintf(&(data->msg->data), \"%s %s dlopen failed: %s\",\n\t\t\t\t      data->id, data->dso_name, dlerr);\n\treturn NULL;\n}\n\n/************\n *  THREAD\n ************/\n\n/* Allocate/free the thread status structure for a monitoring thread. */\nstatic void _free_thread_status(struct thread_status *thread)\n{\n\n\t_lib_put(thread->dso_data);\n\tif (thread->wait_task)\n\t\tdm_task_destroy(thread->wait_task);\n\tfree(thread->device.uuid);\n\tfree(thread->device.name);\n\tfree(thread);\n}\n\n/* Note: events_field must not be 0, ensured by caller */\nstatic struct thread_status *_alloc_thread_status(const struct message_data *data,\n\t\t\t\t\t\t  struct dso_data *dso_data)\n{\n\tstruct thread_status *thread;\n\n\tif (!(thread = zalloc(sizeof(*thread)))) {\n\t\tlog_error(\"Cannot create new thread, out of memory.\");\n\t\treturn NULL;\n\t}\n\n\t_lib_get(dso_data);\n\tthread->dso_data = dso_data;\n\n\tif (!(thread->wait_task = dm_task_create(DM_DEVICE_WAITEVENT)))\n\t\tgoto_out;\n\n\tif (!dm_task_set_uuid(thread->wait_task, data->device_uuid))\n\t\tgoto_out;\n\n\tif (!(thread->device.uuid = strdup(data->device_uuid)))\n\t\tgoto_out;\n\n\t/* Until real name resolved, use UUID */\n\tif (!(thread->device.name = strdup(data->device_uuid)))\n\t\tgoto_out;\n\n\t/* runs ioctl and may register lvm2 pluging */\n\tthread->processing = 1;\n\tthread->status = DM_THREAD_REGISTERING;\n\n\tthread->events = data->events_field;\n\tthread->pending = DM_EVENT_REGISTRATION_PENDING;\n\tthread->timeout = data->timeout_secs;\n\tdm_list_init(&thread->timeout_list);\n\n\treturn thread;\n\nout:\n\t_free_thread_status(thread);\n\n\treturn NULL;\n}\n\n/*\n * Create a device monitoring thread.\n * N.B.  Error codes returned are positive.\n */\nstatic int _pthread_create_smallstack(pthread_t *t, void *(*fun)(void *), void *arg)\n{\n\tint r;\n\tpthread_t tmp;\n\tpthread_attr_t attr;\n\n\t/*\n\t * From pthread_attr_init man page:\n\t * POSIX.1-2001 documents an ENOMEM error for pthread_attr_init(); on\n\t * Linux these functions always succeed (but portable and future-proof\n\t * applications should nevertheless handle a possible error return).\n\t */\n\tif ((r = pthread_attr_init(&attr)) != 0) {\n\t\tlog_sys_error(\"pthread_attr_init\", \"\");\n\t\treturn r;\n\t}\n\n\t/*\n\t * We use a smaller stack since it gets preallocated in its entirety\n\t */\n\tpthread_attr_setstacksize(&attr, THREAD_STACK_SIZE + getpagesize());\n\n\t/*\n\t * If no-one will be waiting, we need to detach.\n\t */\n\tif (!t) {\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\t\tt = &tmp;\n\t}\n\n\tif ((r = pthread_create(t, &attr, fun, arg)))\n\t\tlog_sys_error(\"pthread_create\", \"\");\n\n\tpthread_attr_destroy(&attr);\n\n\treturn r;\n}\n\n/*\n * Fetch a string off src and duplicate it into *ptr.\n * Pay attention to zero-length and 'empty' strings ('-').\n */\n/* FIXME? move to libdevmapper to share with the client lib (need to\n   make delimiter a parameter then) */\nstatic int _fetch_string(char **ptr, char **src, const int delimiter)\n{\n\tint ret = 1;\n\tchar *p;\n\tsize_t len;\n\t*ptr = NULL; /* Empty field returns NULL pointer */\n\n\tif ((*src)[0] == '-') {\n\t\t/* Could be empty field '-', handle without allocation */\n\t\tif ((*src)[1] == '\\0') {\n\t\t\t(*src)++;\n\t\t\tgoto out;\n\t\t} else if ((*src)[1] == delimiter) {\n\t\t\t(*src) += 2;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((p = strchr(*src, delimiter))) {\n\t\tif (*src < p) {\n\t\t\t*p = 0; /* Temporary exit with \\0 */\n\t\t\tif (!(*ptr = strdup(*src))) {\n\t\t\t\tlog_error(\"Failed to fetch item %s.\", *src);\n\t\t\t\tret = 0; /* Allocation fail */\n\t\t\t}\n\t\t\t*p = delimiter;\n\t\t\t*src = p;\n\t\t}\n\t\t(*src)++; /* Skip delmiter, next field */\n\t} else if ((len = strlen(*src))) {\n\t\t/* No delimiter, item ends with '\\0' */\n\t\tif (!(*ptr = strdup(*src))) {\n\t\t\tlog_error(\"Failed to fetch last item %s.\", *src);\n\t\t\tret = 0; /* Fail */\n\t\t}\n\t\t*src += len + 1;\n\t}\nout:\n\treturn ret;\n}\n\n/* Free message memory. */\nstatic void _free_message(struct message_data *message_data)\n{\n\tfree(message_data->id);\n\tfree(message_data->dso_name);\n\tfree(message_data->device_uuid);\n\tfree(message_data->events_str);\n\tfree(message_data->timeout_str);\n}\n\n/* Parse a register message from the client. */\nstatic int _parse_message(struct message_data *message_data)\n{\n\tint ret = 0;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tchar *p = msg->data;\n\n\tif (!msg->data)\n\t\treturn 0;\n\n\t/*\n\t * Retrieve application identifier, mapped device\n\t * path and events # string from message.\n\t */\n\tif (_fetch_string(&message_data->id, &p, ' ') &&\n\t    _fetch_string(&message_data->dso_name, &p, ' ') &&\n\t    _fetch_string(&message_data->device_uuid, &p, ' ') &&\n\t    _fetch_string(&message_data->events_str, &p, ' ') &&\n\t    _fetch_string(&message_data->timeout_str, &p, ' ')) {\n\t\tif (message_data->events_str)\n\t\t\tmessage_data->events_field =\n\t\t\t\tatoi(message_data->events_str);\n\t\tif (message_data->timeout_str)\n\t\t\tmessage_data->timeout_secs =\n\t\t\t\tatoi(message_data->timeout_str)\n\t\t\t\t? : DM_EVENT_DEFAULT_TIMEOUT;\n\t\tret = 1;\n\t}\n\n\tfree(msg->data);\n\tmsg->data = NULL;\n\n\treturn ret;\n}\n\n/* Global mutex to lock access to lists et al. See _global_mutex\n   above. */\nstatic int _lock_mutex(void)\n{\n\treturn pthread_mutex_lock(&_global_mutex);\n}\n\nstatic int _unlock_mutex(void)\n{\n\treturn pthread_mutex_unlock(&_global_mutex);\n}\n\n/* Check, if a device exists. */\nstatic int _fill_device_data(struct thread_status *ts)\n{\n\tstruct dm_task *dmt;\n\tstruct dm_info dmi;\n\tint ret = 0;\n\n\tif (!(dmt = dm_task_create(DM_DEVICE_INFO)))\n\t\treturn 0;\n\n\tif (!dm_task_set_uuid(dmt, ts->device.uuid))\n\t\tgoto fail;\n\n\tif (!dm_task_run(dmt))\n\t\tgoto fail;\n\n\tfree(ts->device.name);\n\tif (!(ts->device.name = strdup(dm_task_get_name(dmt))))\n\t\tgoto fail;\n\n\tif (!dm_task_get_info(dmt, &dmi))\n\t\tgoto fail;\n\n\tts->device.major = dmi.major;\n\tts->device.minor = dmi.minor;\n\tdm_task_set_event_nr(ts->wait_task, dmi.event_nr);\n\n\tret = 1;\nfail:\n\tdm_task_destroy(dmt);\n\n\treturn ret;\n}\n\nstatic struct dm_task *_get_device_status(struct thread_status *ts)\n{\n\tstruct dm_task *dmt = dm_task_create(DM_DEVICE_STATUS);\n\n\tif (!dmt)\n\t\treturn_NULL;\n\n\tif (!dm_task_set_uuid(dmt, ts->device.uuid)) {\n\t\tdm_task_destroy(dmt);\n\t\treturn_NULL;\n\t}\n\n\t/* Non-blocking status read */\n\tif (!dm_task_no_flush(dmt))\n\t\tlog_warn(\"WARNING: Can't set no_flush for dm status.\");\n\n\tif (!dm_task_run(dmt)) {\n\t\tdm_task_destroy(dmt);\n\t\treturn_NULL;\n\t}\n\n\treturn dmt;\n}\n\n/*\n * Find an existing thread for a device.\n *\n * Mutex must be held when calling this.\n */\nstatic struct thread_status *_lookup_thread_status(struct message_data *data)\n{\n\tstruct thread_status *thread;\n\n\tdm_list_iterate_items(thread, &_thread_registry)\n\t\tif (!strcmp(data->device_uuid, thread->device.uuid))\n\t\t\treturn thread;\n\n\treturn NULL;\n}\n\nstatic int _get_status(struct message_data *message_data)\n{\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tstruct thread_status *thread;\n\tint i = 0, j;\n\tint ret = -ENOMEM;\n\tint count;\n\tint size = 0, current;\n\tsize_t len;\n\tchar **buffers;\n\tchar *message;\n\n\t_lock_mutex();\n\tcount = dm_list_size(&_thread_registry);\n\tbuffers = alloca(sizeof(char*) * count);\n\tdm_list_iterate_items(thread, &_thread_registry) {\n\t\tif ((current = dm_asprintf(buffers + i, \"0:%d %s %s %u %\" PRIu32 \";\",\n\t\t\t\t\t   i, thread->dso_data->dso_name,\n\t\t\t\t\t   thread->device.uuid, thread->events,\n\t\t\t\t\t   thread->timeout)) < 0) {\n\t\t\t_unlock_mutex();\n\t\t\tgoto out;\n\t\t}\n\t\t++i;\n\t\tsize += current; /* count with trailing '\\0' */\n\t}\n\t_unlock_mutex();\n\n\tlen = strlen(message_data->id);\n\tmsg->size = size + len + 1;\n\tfree(msg->data);\n\tif (!(msg->data = malloc(msg->size)))\n\t\tgoto out;\n\n\tmemcpy(msg->data, message_data->id, len);\n\tmessage = msg->data + len;\n\t*message++ = ' ';\n\tfor (j = 0; j < i; ++j) {\n\t\tlen = strlen(buffers[j]);\n\t\tmemcpy(message, buffers[j], len);\n\t\tmessage += len;\n\t}\n\n\tret = 0;\n out:\n\tfor (j = 0; j < i; ++j)\n\t\tfree(buffers[j]);\n\n\treturn ret;\n}\n\nstatic int _get_parameters(struct message_data *message_data) {\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tint size;\n\n\tfree(msg->data);\n\tif ((size = dm_asprintf(&msg->data, \"%s pid=%d daemon=%s exec_method=%s\",\n\t\t\t\tmessage_data->id, getpid(),\n\t\t\t\t_foreground ? \"no\" : \"yes\",\n\t\t\t\t_systemd_activation ? \"systemd\" : \"direct\")) < 0) {\n\t\tstack;\n\t\treturn -ENOMEM;\n\t}\n\n\tmsg->size = (uint32_t) size;\n\n\treturn 0;\n}\n\n/* Cleanup at exit. */\nstatic void _exit_dm_lib(void)\n{\n\tdm_lib_release();\n\tdm_lib_exit();\n}\n\nstatic void _exit_timeout(void *unused __attribute__((unused)))\n{\n\t_timeout_running = 0;\n\tpthread_mutex_unlock(&_timeout_mutex);\n}\n\n/* Wake up monitor threads every so often. */\nstatic void *_timeout_thread(void *unused __attribute__((unused)))\n{\n\tstruct thread_status *thread;\n\tstruct timespec timeout;\n\ttime_t curr_time;\n\tint ret;\n\n\tDEBUGLOG(\"Timeout thread starting.\");\n\tpthread_cleanup_push(_exit_timeout, NULL);\n\tpthread_mutex_lock(&_timeout_mutex);\n\n\twhile (!dm_list_empty(&_timeout_registry)) {\n\t\ttimeout.tv_sec = 0;\n\t\ttimeout.tv_nsec = 0;\n\t\tcurr_time = time(NULL);\n\n\t\tdm_list_iterate_items_gen(thread, &_timeout_registry, timeout_list) {\n\t\t\tif (thread->next_time <= curr_time) {\n\t\t\t\tthread->next_time = curr_time + thread->timeout;\n\t\t\t\t_lock_mutex();\n\t\t\t\tif (thread->processing) {\n\t\t\t\t\t/* Cannot signal processing monitoring thread */\n\t\t\t\t\tlog_debug(\"Skipping SIGALRM to processing Thr %x for timeout.\",\n\t\t\t\t\t\t  (int) thread->thread);\n\t\t\t\t} else {\n\t\t\t\t\tDEBUGLOG(\"Sending SIGALRM to Thr %x for timeout.\",\n\t\t\t\t\t\t (int) thread->thread);\n\t\t\t\t\tret = pthread_kill(thread->thread, SIGALRM);\n\t\t\t\t\tif (ret && (ret != ESRCH))\n\t\t\t\t\t\tlog_error(\"Unable to wakeup Thr %x for timeout: %s.\",\n\t\t\t\t\t\t\t  (int) thread->thread, strerror(ret));\n\t\t\t\t}\n\t\t\t\t_unlock_mutex();\n\t\t\t}\n\n\t\t\tif (thread->next_time < timeout.tv_sec || !timeout.tv_sec)\n\t\t\t\ttimeout.tv_sec = thread->next_time;\n\t\t}\n\n\t\tpthread_cond_timedwait(&_timeout_cond, &_timeout_mutex,\n\t\t\t\t       &timeout);\n\t}\n\n\tDEBUGLOG(\"Timeout thread finished.\");\n\tpthread_cleanup_pop(1);\n\n\treturn NULL;\n}\n\nstatic int _register_for_timeout(struct thread_status *thread)\n{\n\tint ret = 0;\n\n\tpthread_mutex_lock(&_timeout_mutex);\n\n\tif (dm_list_empty(&thread->timeout_list)) {\n\t\tthread->next_time = time(NULL) + thread->timeout;\n\t\tdm_list_add(&_timeout_registry, &thread->timeout_list);\n\t\tif (_timeout_running)\n\t\t\tpthread_cond_signal(&_timeout_cond);\n\t}\n\n\tif (!_timeout_running &&\n\t    !(ret = _pthread_create_smallstack(NULL, _timeout_thread, NULL)))\n\t\t_timeout_running = 1;\n\n\tpthread_mutex_unlock(&_timeout_mutex);\n\n\treturn ret;\n}\n\nstatic void _unregister_for_timeout(struct thread_status *thread)\n{\n\tpthread_mutex_lock(&_timeout_mutex);\n\tif (!dm_list_empty(&thread->timeout_list)) {\n\t\tdm_list_del(&thread->timeout_list);\n\t\tdm_list_init(&thread->timeout_list);\n\t\tif (dm_list_empty(&_timeout_registry))\n\t\t\t/* No more work -> wakeup to finish quickly */\n\t\t\tpthread_cond_signal(&_timeout_cond);\n\t}\n\tpthread_mutex_unlock(&_timeout_mutex);\n}\n\n#ifdef DEBUG_SIGNALS\n/* Print list of signals within a signal set */\nstatic void _print_sigset(const char *prefix, const sigset_t *sigset)\n{\n\tint sig, cnt = 0;\n\n\tfor (sig = 1; sig < NSIG; sig++)\n\t\tif (!sigismember(sigset, sig)) {\n\t\t\tcnt++;\n\t\t\tlog_debug(\"%s%d (%s)\", prefix, sig, strsignal(sig));\n\t\t}\n\n\tif (!cnt)\n\t\tlog_debug(\"%s<empty signal set>\", prefix);\n}\n#endif\n\nenum {\n\tDM_WAIT_RETRY,\n\tDM_WAIT_INTR,\n\tDM_WAIT_FATAL\n};\n\n/* Wait on a device until an event occurs. */\nstatic int _event_wait(struct thread_status *thread)\n{\n\tsigset_t set, old;\n\tint ret = DM_WAIT_RETRY;\n\tstruct dm_info info;\n\n\t/* TODO: audit libdm thread usage */\n\n\t/*\n\t * This is so that you can break out of waiting on an event,\n\t * either for a timeout event, or to cancel the thread.\n\t */\n\tsigemptyset(&old);\n\tsigemptyset(&set);\n\tsigaddset(&set, SIGALRM);\n\tif (pthread_sigmask(SIG_UNBLOCK, &set, &old) != 0) {\n\t\tlog_sys_error(\"pthread_sigmask\", \"unblock alarm\");\n\t\treturn ret; /* What better */\n\t}\n\n\tif (dm_task_run(thread->wait_task)) {\n\t\tthread->current_events |= DM_EVENT_DEVICE_ERROR;\n\t\tret = DM_WAIT_INTR;\n\t\t/* Update event_nr */\n\t\tif (dm_task_get_info(thread->wait_task, &info))\n\t\t\tdm_task_set_event_nr(thread->wait_task, info.event_nr);\n\t} else {\n\t\tswitch (dm_task_get_errno(thread->wait_task)) {\n\t\tcase ENXIO:\n\t\t\tlog_error(\"%s disappeared, detaching.\",\n\t\t\t\t  thread->device.name);\n\t\t\tret = DM_WAIT_FATAL;\n\t\t\tbreak;\n\t\tcase EINTR:\n\t\t\tthread->current_events |= DM_EVENT_TIMEOUT;\n\t\t\tret = DM_WAIT_INTR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_sys_error(\"dm_task_run\", \"waitevent\");\n\t\t}\n\t}\n\n\tif (pthread_sigmask(SIG_SETMASK, &old, NULL) != 0)\n\t\tlog_sys_error(\"pthread_sigmask\", \"block alarm\");\n\n#ifdef DEBUG_SIGNALS\n\t_print_sigset(\"dmeventd blocking \", &old);\n#endif\n\tDEBUGLOG(\"Completed waitevent task for %s.\", thread->device.name);\n\n\treturn ret;\n}\n\n/* Register a device with the DSO. */\nstatic int _do_register_device(struct thread_status *thread)\n{\n\treturn thread->dso_data->register_device(thread->device.name,\n\t\t\t\t\t\t thread->device.uuid,\n\t\t\t\t\t\t thread->device.major,\n\t\t\t\t\t\t thread->device.minor,\n\t\t\t\t\t\t &(thread->dso_private));\n}\n\n/* Unregister a device with the DSO. */\nstatic int _do_unregister_device(struct thread_status *thread)\n{\n\treturn thread->dso_data->unregister_device(thread->device.name,\n\t\t\t\t\t\t   thread->device.uuid,\n\t\t\t\t\t\t   thread->device.major,\n\t\t\t\t\t\t   thread->device.minor,\n\t\t\t\t\t\t   &(thread->dso_private));\n}\n\n/* Process an event in the DSO. */\nstatic void _do_process_event(struct thread_status *thread)\n{\n\tstruct dm_task *task;\n\n\t/* NOTE: timeout event gets status */\n\ttask = (thread->current_events & DM_EVENT_TIMEOUT)\n\t\t? _get_device_status(thread) : thread->wait_task;\n\n\tif (!task)\n\t\tlog_error(\"Lost event in Thr %x.\", (int)thread->thread);\n\telse {\n\t\tthread->dso_data->process_event(task, thread->current_events, &(thread->dso_private));\n\t\tif (task != thread->wait_task)\n\t\t\tdm_task_destroy(task);\n\t}\n}\n\nstatic void _thread_unused(struct thread_status *thread)\n{\n\tUNLINK_THREAD(thread);\n\tLINK(thread, &_thread_registry_unused);\n}\n\n/* Thread cleanup handler to unregister device. */\nstatic void _monitor_unregister(void *arg)\n{\n\tstruct thread_status *thread = arg, *thread_iter;\n\n\tdm_list_iterate_items(thread_iter, &_thread_registry)\n\t\tif (thread_iter == thread) {\n\t\t\t/* Relink to _unused */\n\t\t\t_thread_unused(thread);\n\t\t\tbreak;\n\t\t}\n\n\tthread->events = 0;\t/* Filter is now empty */\n\tthread->pending = 0;\t/* Event pending resolved */\n\tthread->processing = 1;\t/* Process unregistering */\n\n\t_unlock_mutex();\n\n\tDEBUGLOG(\"Unregistering monitor for %s.\", thread->device.name);\n\t_unregister_for_timeout(thread);\n\n\tif ((thread->status != DM_THREAD_REGISTERING) &&\n\t    !_do_unregister_device(thread))\n\t\tlog_error(\"%s: %s unregister failed.\", __func__,\n\t\t\t  thread->device.name);\n\n\tDEBUGLOG(\"Marking Thr %x as DONE and unused.\", (int)thread->thread);\n\n\t_lock_mutex();\n\tthread->status = DM_THREAD_DONE; /* Last access to thread memory! */\n\t_unlock_mutex();\n}\n\n/* Device monitoring thread. */\nstatic void *_monitor_thread(void *arg)\n{\n\tstruct thread_status *thread = arg;\n\tint ret;\n\tsigset_t pendmask;\n\n\tpthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);\n\tpthread_cleanup_push(_monitor_unregister, thread);\n\n\tif (!_fill_device_data(thread)) {\n\t\tlog_error(\"Failed to fill device data for %s.\", thread->device.uuid);\n\t\t_lock_mutex();\n\t\tgoto out;\n\t}\n\n\tif (!_do_register_device(thread)) {\n\t\tlog_error(\"Failed to register device %s.\", thread->device.name);\n\t\t_lock_mutex();\n\t\tgoto out;\n\t}\n\n\t_lock_mutex();\n\tthread->status = DM_THREAD_RUNNING;\n\tthread->processing = 0;\n\n\t/* Loop awaiting/analyzing device events. */\n\twhile (thread->events) {\n\n\t\tthread->pending = 0; /* Event is no longer pending...  */\n\n\t\t/*\n\t\t * Check against bitmask filter.\n\t\t *\n\t\t * If there's current events delivered from _event_wait() AND\n\t\t * the device got registered for those events AND\n\t\t * those events haven't been processed yet, call\n\t\t * the DSO's process_event() handler.\n\t\t */\n\t\tif (thread->events & thread->current_events) {\n\t\t\tthread->processing = 1;  /* Cannot be removed/signaled */\n\t\t\t_unlock_mutex();\n\n\t\t\t_do_process_event(thread);\n\t\t\tthread->current_events = 0; /* Current events processed */\n\n\t\t\t_lock_mutex();\n\t\t\tthread->processing = 0;\n\n\t\t\t/*\n\t\t\t * Thread can terminate itself from plugin via SIGALRM\n\t\t\t * Timer thread will not send signal while processing\n\t\t\t * TODO: maybe worth API change and return value for\n\t\t\t *       _do_process_event() instead of this signal solution\n\t\t\t */\n\t\t\tif (sigpending(&pendmask) < 0)\n\t\t\t\tlog_sys_error(\"sigpending\", \"\");\n\t\t\telse if (sigismember(&pendmask, SIGALRM))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t_unlock_mutex();\n\n\t\t\tif ((ret = _event_wait(thread)) == DM_WAIT_RETRY)\n\t\t\t\tusleep(100); /* Avoid busy loop, wait without mutex */\n\n\t\t\t_lock_mutex();\n\n\t\t\tif (ret == DM_WAIT_FATAL)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\t/* ';' fixes gcc compilation problem with older pthread macros\n\t * \"label at end of compound statement\" */\n\t;\n\n\tpthread_cleanup_pop(1);\n\n\treturn NULL;\n}\n\n/* Create a device monitoring thread. */\nstatic int _create_thread(struct thread_status *thread)\n{\n\treturn _pthread_create_smallstack(&thread->thread, _monitor_thread, thread);\n}\n\n/* Update events - needs to be locked */\nstatic int _update_events(struct thread_status *thread, int events)\n{\n\tint ret = 0;\n\n\tif (thread->events == events)\n\t\treturn 0; /* Nothing has changed */\n\n\tthread->events = events;\n\tthread->pending = DM_EVENT_REGISTRATION_PENDING;\n\n\t/* Only non-processing threads can be notified */\n\tif (!thread->processing) {\n\t\tDEBUGLOG(\"Sending SIGALRM to wakeup Thr %x.\", (int)thread->thread);\n\n\t\t/* Notify thread waiting in ioctl (to speed-up) */\n\t\tif ((ret = pthread_kill(thread->thread, SIGALRM))) {\n\t\t\tif (ret == ESRCH)\n\t\t\t\tthread->events = 0;  /* thread is gone */\n\t\t\telse\n\t\t\t\tlog_error(\"Unable to wakeup thread: %s\",\n\t\t\t\t\t  strerror(ret));\n\t\t}\n\t}\n\n\t/* Threads with no events has to be moved to unused */\n\tif (!thread->events)\n\t\t_thread_unused(thread);\n\n\treturn -ret;\n}\n\n/* Return success on daemon active check. */\nstatic int _active(struct message_data *message_data)\n{\n\treturn 0;\n}\n\n/*\n * Unregister for an event.\n *\n * Only one caller at a time here as with register_for_event().\n */\nstatic int _unregister_for_event(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\tint ret;\n\n\t/*\n\t * Clear event in bitfield and deactivate\n\t * monitoring thread in case bitfield is 0.\n\t */\n\t_lock_mutex();\n\n\tif (!(thread = _lookup_thread_status(message_data))) {\n\t\t_unlock_mutex();\n\t\treturn -ENODEV;\n\t}\n\n\t/* AND mask event ~# from events bitfield. */\n\tret = _update_events(thread, (thread->events & ~message_data->events_field));\n\n\t_unlock_mutex();\n\n\t/* If there are no events, thread is later garbage\n\t * collected by _cleanup_unused_threads */\n\tif (message_data->events_field & DM_EVENT_TIMEOUT)\n\t\t_unregister_for_timeout(thread);\n\n\tDEBUGLOG(\"Unregistered event for %s.\", thread->device.name);\n\n\treturn ret;\n}\n\n/*\n * Register for an event.\n *\n * Only one caller at a time here, because we use\n * a FIFO and lock it against multiple accesses.\n */\nstatic int _register_for_event(struct message_data *message_data)\n{\n\tint ret = 0;\n\tstruct thread_status *thread;\n\tstruct dso_data *dso_data;\n\n\tif (!(dso_data = _lookup_dso(message_data)) &&\n\t    !(dso_data = _load_dso(message_data))) {\n\t\tstack;\n#ifdef ELIBACC\n\t\tret = ELIBACC;\n#else\n\t\tret = ENODEV;\n#endif\n\t\treturn ret;\n\t}\n\n\t_lock_mutex();\n\n\tif ((thread = _lookup_thread_status(message_data))) {\n\t\t/* OR event # into events bitfield. */\n\t\tret = _update_events(thread, (thread->events | message_data->events_field));\n\t} else {\n\t\t_unlock_mutex();\n\n\t\t/* Only creating thread during event processing\n\t\t * Remaining initialization happens within monitoring thread */\n\t\tif (!(thread = _alloc_thread_status(message_data, dso_data))) {\n\t\t\tstack;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif ((ret = _create_thread(thread))) {\n\t\t\tstack;\n\t\t\t_free_thread_status(thread);\n\t\t\treturn -ret;\n\t\t}\n\n\t\t_lock_mutex();\n\t\t/* Note: same uuid can't be added in parallel */\n\t\tLINK_THREAD(thread);\n\t}\n\n\t_unlock_mutex();\n\n\t/* If creation of timeout thread fails (as it may), we fail\n\t   here completely. The client is responsible for either\n\t   retrying later or trying to register without timeout\n\t   events. However, if timeout thread cannot be started, it\n\t   usually means we are so starved on resources that we are\n\t   almost as good as dead already... */\n\tif ((message_data->events_field & DM_EVENT_TIMEOUT) &&\n\t    (ret = _register_for_timeout(thread))) {\n\t\tstack;\n\t\t_unregister_for_event(message_data);\n\t}\n\n\treturn -ret;\n}\n\n/*\n * Get registered device.\n *\n * Only one caller at a time here as with register_for_event().\n */\nstatic int _registered_device(struct message_data *message_data,\n\t\t\t     struct thread_status *thread)\n{\n\tint r;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\n\tfree(msg->data);\n\n\tif ((r = dm_asprintf(&(msg->data), \"%s %s %s %u\",\n\t\t\t     message_data->id,\n\t\t\t     thread->dso_data->dso_name,\n\t\t\t     thread->device.uuid,\n\t\t\t     thread->events | thread->pending)) < 0)\n\t\treturn -ENOMEM;\n\n\tmsg->size = (uint32_t) r;\n\tDEBUGLOG(\"Registered %s.\", msg->data);\n\n\treturn 0;\n}\n\nstatic int _want_registered_device(char *dso_name, char *device_uuid,\n\t\t\t\t   struct thread_status *thread)\n{\n\t/* If DSO names and device paths are equal. */\n\tif (dso_name && device_uuid)\n\t\treturn !strcmp(dso_name, thread->dso_data->dso_name) &&\n\t\t    !strcmp(device_uuid, thread->device.uuid);\n\n\t/* If DSO names are equal. */\n\tif (dso_name)\n\t\treturn !strcmp(dso_name, thread->dso_data->dso_name);\n\n\t/* If device paths are equal. */\n\tif (device_uuid)\n\t\treturn !strcmp(device_uuid, thread->device.uuid);\n\n\treturn 1;\n}\n\nstatic int _get_registered_dev(struct message_data *message_data, int next)\n{\n\tstruct thread_status *thread, *hit = NULL;\n\tint ret = -ENOENT;\n\n\tDEBUGLOG(\"Get%s dso:%s  uuid:%s.\", next ? \"\" : \"Next\",\n\t\t message_data->dso_name,\n\t\t message_data->device_uuid);\n\t_lock_mutex();\n\n\t/* Iterate list of threads checking if we want a particular one. */\n\tdm_list_iterate_items(thread, &_thread_registry)\n\t\tif (_want_registered_device(message_data->dso_name,\n\t\t\t\t\t    message_data->device_uuid,\n\t\t\t\t\t    thread)) {\n\t\t\thit = thread;\n\t\t\tbreak;\n\t\t}\n\n\t/*\n\t * If we got a registered device and want the next one ->\n\t * fetch next conforming element off the list.\n\t */\n\tif (hit && !next)\n\t\tgoto reg;\n\n\t/*\n\t * If we didn't get a match, try the threads waiting to be deleted.\n\t * FIXME Do something similar if 'next' is set.\n\t */\n\tif (!hit && !next)\n\t\tdm_list_iterate_items(thread, &_thread_registry_unused)\n\t\t\tif (_want_registered_device(message_data->dso_name,\n\t\t\t\t\t\t    message_data->device_uuid, thread)) {\n\t\t\t\thit = thread;\n\t\t\t\tgoto reg;\n\t\t\t}\n\n\tif (!hit) {\n\t\tDEBUGLOG(\"Get%s not registered\", next ? \"\" : \"Next\");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tif (dm_list_end(&_thread_registry, &thread->list))\n\t\t\tgoto out;\n\n\t\tthread = dm_list_item(thread->list.n, struct thread_status);\n\t\tif (_want_registered_device(message_data->dso_name, NULL, thread)) {\n\t\t\thit = thread;\n\t\t\tbreak;\n\t\t}\n\t}\n\n      reg:\n\tret = _registered_device(message_data, hit);\n\n      out:\n\t_unlock_mutex();\n\n\treturn ret;\n}\n\nstatic int _get_registered_device(struct message_data *message_data)\n{\n\treturn _get_registered_dev(message_data, 0);\n}\n\nstatic int _get_next_registered_device(struct message_data *message_data)\n{\n\treturn _get_registered_dev(message_data, 1);\n}\n\nstatic int _set_timeout(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\n\t_lock_mutex();\n\tthread = _lookup_thread_status(message_data);\n\t_unlock_mutex();\n\n\tif (!thread)\n\t\treturn -ENODEV;\n\n\t/* Lets reprogram timer */\n\tpthread_mutex_lock(&_timeout_mutex);\n\tthread->timeout = message_data->timeout_secs;\n\tthread->next_time = 0;\n\tpthread_cond_signal(&_timeout_cond);\n\tpthread_mutex_unlock(&_timeout_mutex);\n\n\treturn 0;\n}\n\nstatic int _get_timeout(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\n\t_lock_mutex();\n\tthread = _lookup_thread_status(message_data);\n\t_unlock_mutex();\n\n\tif (!thread)\n\t\treturn -ENODEV;\n\n\tfree(msg->data);\n\tmsg->size = dm_asprintf(&(msg->data), \"%s %\" PRIu32,\n\t\t\t\tmessage_data->id, thread->timeout);\n\n\treturn (msg->data && msg->size) ? 0 : -ENOMEM;\n}\n\nstatic int _open_fifo(const char *path)\n{\n\tstruct stat st;\n\tint fd = -1;\n \n \t/*\n\t * FIXME Explicitly verify the code's requirement that path is secure:\n\t * - All parent directories owned by root without group/other write access unless sticky.\n\t */\n\n\t/* If path exists, only use it if it is root-owned fifo mode 0600 */\n\tif ((lstat(path, &st) < 0)) {\n\t\tif (errno != ENOENT) {\n\t\t\tlog_sys_error(\"stat\", path);\n\t\t\treturn -1;\n\t\t}\n\t} else if (!S_ISFIFO(st.st_mode) || st.st_uid ||\n\t\t   (st.st_mode & (S_IEXEC | S_IRWXG | S_IRWXO))) {\n\t\tlog_warn(\"WARNING: %s has wrong attributes: Replacing.\", path);\n\t\tif (unlink(path)) {\n\t\t\tlog_sys_error(\"unlink\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Create fifo. */\n\t(void) dm_prepare_selinux_context(path, S_IFIFO);\n\tif ((mkfifo(path, 0600) == -1) && errno != EEXIST) {\n\t\tlog_sys_error(\"mkfifo\", path);\n\t\t(void) dm_prepare_selinux_context(NULL, 0);\n\t\tgoto fail;\n\t}\n\n\t(void) dm_prepare_selinux_context(NULL, 0);\n\n\t/* Need to open read+write or we will block or fail */\n\tif ((fd = open(path, O_RDWR)) < 0) {\n\t\tlog_sys_error(\"open\", path);\n\t\tgoto fail;\n\t}\n\n\t/* Warn about wrong permissions if applicable */\n\tif (fstat(fd, &st)) {\n\t\tlog_sys_error(\"fstat\", path);\n\t\tgoto fail;\n\t}\n\n\tif (!S_ISFIFO(st.st_mode) || st.st_uid ||\n\t    (st.st_mode & (S_IEXEC | S_IRWXG | S_IRWXO))) {\n\t\tlog_error(\"%s: fifo has incorrect attributes\", path);\n\t\tgoto fail;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tlog_sys_error(\"fcntl(FD_CLOEXEC)\", path);\n\t\tgoto fail;\n\t}\n\n\treturn fd;\n\nfail:\n\tif ((fd >= 0) && close(fd))\n\t\tlog_sys_error(\"close\", path);\n\n\treturn -1;\n}\n\n/* Open fifos used for client communication. */\nstatic int _open_fifos(struct dm_event_fifos *fifos)\n{\n\t/* Create client fifo. */\n\tif ((fifos->client = _open_fifo(fifos->client_path)) < 0)\n\t\tgoto fail;\n\n\t/* Create server fifo. */\n\tif ((fifos->server = _open_fifo(fifos->server_path)) < 0)\n\t\tgoto fail;\n\n\treturn 1;\n\nfail:\n\tif (fifos->client >= 0 && close(fifos->client))\n\t\tlog_sys_error(\"close\", fifos->client_path);\n\n\treturn 0;\n}\n\n/*\n * Read message from client making sure that data is available\n * and a complete message is read.  Must not block indefinitely.\n */\nstatic int _client_read(struct dm_event_fifos *fifos,\n\t\t\tstruct dm_event_daemon_message *msg)\n{\n\tstruct timeval t;\n\tunsigned bytes = 0;\n\tint ret = 0;\n\tfd_set fds;\n\tsize_t size = 2 * sizeof(uint32_t);\t/* status + size */\n\tuint32_t *header = alloca(size);\n\tchar *buf = (char *)header;\n\n\tmsg->data = NULL;\n\n\terrno = 0;\n\twhile (bytes < size && errno != EOF) {\n\t\t/* Watch client read FIFO for input. */\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fifos->client, &fds);\n\t\tt.tv_sec = 1;\n\t\tt.tv_usec = 0;\n\t\tret = select(fifos->client + 1, &fds, NULL, NULL, &t);\n\n\t\tif (!ret && !bytes)\t/* nothing to read */\n\t\t\treturn 0;\n\n\t\tif (!ret)\t/* trying to finish read */\n\t\t\tcontinue;\n\n\t\tif (ret < 0)\t/* error */\n\t\t\treturn 0;\n\n\t\tret = read(fifos->client, buf + bytes, size - bytes);\n\t\tbytes += ret > 0 ? ret : 0;\n\t\tif (header && (bytes == 2 * sizeof(uint32_t))) {\n\t\t\tmsg->cmd = ntohl(header[0]);\n\t\t\tsize = msg->size = ntohl(header[1]);\n\t\t\tbytes = 0;\n\t\t\tif (!size)\n\t\t\t\tbreak; /* No data -> error */\n\t\t\tbuf = msg->data = malloc(msg->size);\n\t\t\tif (!buf)\n\t\t\t\tbreak; /* No mem -> error */\n\t\t\theader = 0;\n\t\t}\n\t}\n\n\tif (bytes != size) {\n\t\tfree(msg->data);\n\t\tmsg->data = NULL;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Write a message to the client making sure that it is ready to write.\n */\nstatic int _client_write(struct dm_event_fifos *fifos,\n\t\t\tstruct dm_event_daemon_message *msg)\n{\n\tuint32_t temp[2];\n\tunsigned bytes = 0;\n\tint ret = 0;\n\tfd_set fds;\n\n\tsize_t size = 2 * sizeof(uint32_t) + ((msg->data) ? msg->size : 0);\n\tuint32_t *header = malloc(size);\n\tchar *buf = (char *)header;\n\n\tif (!header) {\n\t\t/* Reply with ENOMEM message */\n\t\theader = temp;\n\t\tsize = sizeof(temp);\n\t\theader[0] = htonl(-ENOMEM);\n\t\theader[1] = 0;\n\t} else {\n\t\theader[0] = htonl(msg->cmd);\n\t\theader[1] = htonl((msg->data) ? msg->size : 0);\n\t\tif (msg->data)\n\t\t\tmemcpy(buf + 2 * sizeof(uint32_t), msg->data, msg->size);\n\t}\n\n\twhile (bytes < size) {\n\t\tdo {\n\t\t\t/* Watch client write FIFO to be ready for output. */\n\t\t\tFD_ZERO(&fds);\n\t\t\tFD_SET(fifos->server, &fds);\n\t\t} while (select(fifos->server + 1, NULL, &fds, NULL, NULL) != 1);\n\n\t\tif ((ret = write(fifos->server, buf + bytes, size - bytes)) > 0)\n\t\t\tbytes += ret;\n\t\telse if (errno == EIO)\n\t\t\tbreak;\n\t}\n\n\tif (header != temp)\n\t\tfree(header);\n\n\treturn (bytes == size);\n}\n\n/*\n * Handle a client request.\n *\n * We put the request handling functions into\n * a list because of the growing number.\n */\nstatic int _handle_request(struct dm_event_daemon_message *msg,\n\t\t\t  struct message_data *message_data)\n{\n\tswitch (msg->cmd) {\n\tcase DM_EVENT_CMD_REGISTER_FOR_EVENT:\n\t\tif (!message_data->events_field)\n\t\t\treturn -EINVAL;\n\t\treturn _register_for_event(message_data);\n\tcase DM_EVENT_CMD_UNREGISTER_FOR_EVENT:\n\t\treturn _unregister_for_event(message_data);\n\tcase DM_EVENT_CMD_GET_REGISTERED_DEVICE:\n\t\treturn _get_registered_device(message_data);\n\tcase DM_EVENT_CMD_GET_NEXT_REGISTERED_DEVICE:\n\t\treturn _get_next_registered_device(message_data);\n\tcase DM_EVENT_CMD_SET_TIMEOUT:\n\t\treturn _set_timeout(message_data);\n\tcase DM_EVENT_CMD_GET_TIMEOUT:\n\t\treturn _get_timeout(message_data);\n\tcase DM_EVENT_CMD_ACTIVE:\n\t\treturn _active(message_data);\n\tcase DM_EVENT_CMD_GET_STATUS:\n\t\treturn _get_status(message_data);\n\t/* dmeventd parameters of running dmeventd,\n\t * returns 'pid=<pid> daemon=<no/yes> exec_method=<direct/systemd>'\n\t * \tpid - pidfile of running dmeventd\n\t * \tdaemon - running as a daemon or not (foreground)?\n\t * \texec_method - \"direct\" if executed directly or\n\t * \t\t      \"systemd\" if executed via systemd\n\t */\n\tcase DM_EVENT_CMD_GET_PARAMETERS:\n\t\treturn _get_parameters(message_data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* Process a request passed from the communication thread. */\nstatic int _do_process_request(struct dm_event_daemon_message *msg)\n{\n\tint ret;\n\tchar *answer;\n\tstruct message_data message_data = { .msg =  msg };\n\n\t/* Parse the message. */\n\tif (msg->cmd == DM_EVENT_CMD_HELLO || msg->cmd == DM_EVENT_CMD_DIE)  {\n\t\tret = 0;\n\t\tanswer = msg->data;\n\t\tif (answer) {\n\t\t\tmsg->size = dm_asprintf(&(msg->data), \"%s %s %d\", answer,\n\t\t\t\t\t\t(msg->cmd == DM_EVENT_CMD_DIE) ? \"DYING\" : \"HELLO\",\n\t\t\t\t\t\tDM_EVENT_PROTOCOL_VERSION);\n\t\t\tfree(answer);\n\t\t}\n\t} else if (msg->cmd != DM_EVENT_CMD_ACTIVE && !_parse_message(&message_data)) {\n\t\tstack;\n\t\tret = -EINVAL;\n\t} else\n\t\tret = _handle_request(msg, &message_data);\n\n\tmsg->cmd = ret;\n\tif (!msg->data)\n\t\tmsg->size = dm_asprintf(&(msg->data), \"%s %s\", message_data.id, strerror(-ret));\n\n\t_free_message(&message_data);\n\n\treturn ret;\n}\n\n/* Only one caller at a time. */\nstatic void _process_request(struct dm_event_fifos *fifos)\n{\n\tstruct dm_event_daemon_message msg = { 0 };\n\tint cmd;\n\t/*\n\t * Read the request from the client (client_read, client_write\n\t * give true on success and false on failure).\n\t */\n\tif (!_client_read(fifos, &msg))\n\t\treturn;\n\n\tcmd = msg.cmd;\n\n\tDEBUGLOG(\">>> CMD:%s (0x%x) processing...\", decode_cmd(cmd), cmd);\n\n\t/* _do_process_request fills in msg (if memory allows for\n\t   data, otherwise just cmd and size = 0) */\n\t_do_process_request(&msg);\n\n\tif (!_client_write(fifos, &msg))\n\t\tstack;\n\n\tDEBUGLOG(\"<<< CMD:%s (0x%x) completed (result %d).\", decode_cmd(cmd), cmd, msg.cmd);\n\n\tfree(msg.data);\n\n\tif (cmd == DM_EVENT_CMD_DIE) {\n\t\tif (unlink(DMEVENTD_PIDFILE))\n\t\t\tlog_sys_error(\"unlink\", DMEVENTD_PIDFILE);\n\t\t_exit(0);\n\t}\n}\n\nstatic void _process_initial_registrations(void)\n{\n\tint i;\n\tchar *reg;\n\tstruct dm_event_daemon_message msg = { 0 };\n\n\tfor (i = 0; (reg = _initial_registrations[i]); ++i) {\n\t\tmsg.cmd = DM_EVENT_CMD_REGISTER_FOR_EVENT;\n\t\tif ((msg.size = strlen(reg))) {\n\t\t\tmsg.data = reg;\n\t\t\t_do_process_request(&msg);\n\t\t}\n\t}\n}\n\nstatic void _cleanup_unused_threads(void)\n{\n\tstruct dm_list *l;\n\tstruct thread_status *thread;\n\tint ret;\n\n\t_lock_mutex();\n\n\twhile ((l = dm_list_first(&_thread_registry_unused))) {\n\t\tthread = dm_list_item(l, struct thread_status);\n\t\tif (thread->status != DM_THREAD_DONE) {\n\t\t\tif (thread->processing)\n\t\t\t\tbreak; /* cleanup on the next round */\n\n\t\t\t/* Signal possibly sleeping thread */\n\t\t\tret = pthread_kill(thread->thread, SIGALRM);\n\t\t\tif (!ret || (ret != ESRCH))\n\t\t\t\tbreak; /* check again on the next round */\n\n\t\t\t/* thread is likely gone */\n\t\t}\n\n\t\tdm_list_del(l);\n\t\t_unlock_mutex();\n\n\t\tDEBUGLOG(\"Destroying Thr %x.\", (int)thread->thread);\n\n\t\tif (pthread_join(thread->thread, NULL))\n\t\t\tlog_sys_error(\"pthread_join\", \"\");\n\n\t\t_free_thread_status(thread);\n\t\t_lock_mutex();\n\t}\n\n\t_unlock_mutex();\n}\n\nstatic void _sig_alarm(int signum __attribute__((unused)))\n{\n\t/* empty SIG_IGN */;\n}\n\n/* Init thread signal handling. */\nstatic void _init_thread_signals(void)\n{\n\tsigset_t my_sigset;\n\tstruct sigaction act = { .sa_handler = _sig_alarm };\n\n\tsigaction(SIGALRM, &act, NULL);\n\tsigfillset(&my_sigset);\n\n\t/* These are used for exiting */\n\tsigdelset(&my_sigset, SIGTERM);\n\tsigdelset(&my_sigset, SIGINT);\n\tsigdelset(&my_sigset, SIGHUP);\n\tsigdelset(&my_sigset, SIGQUIT);\n\n\tpthread_sigmask(SIG_BLOCK, &my_sigset, NULL);\n}\n\n/*\n * exit_handler\n * @sig\n *\n * Set the global variable which the process should\n * be watching to determine when to exit.\n */\nstatic void _exit_handler(int sig __attribute__((unused)))\n{\n\t_exit_now = DM_SIGNALED_EXIT;\n}\n\n#ifdef __linux__\nstatic int _set_oom_adj(const char *oom_adj_path, int val)\n{\n\tFILE *fp;\n\n\tif (!(fp = fopen(oom_adj_path, \"w\"))) {\n\t\tlog_sys_error(\"open\", oom_adj_path);\n\t\treturn 0;\n\t}\n\n\tfprintf(fp, \"%i\", val);\n\n\tif (dm_fclose(fp))\n\t\tlog_sys_error(\"fclose\", oom_adj_path);\n\n\treturn 1;\n}\n\n/*\n * Protection against OOM killer if kernel supports it\n */\nstatic int _protect_against_oom_killer(void)\n{\n\tstruct stat st;\n\n\tif (stat(OOM_ADJ_FILE, &st) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tlog_sys_error(\"stat\", OOM_ADJ_FILE);\n\n\t\t/* Try old oom_adj interface as a fallback */\n\t\tif (stat(OOM_ADJ_FILE_OLD, &st) == -1) {\n\t\t\tlog_sys_error(\"stat\", OOM_ADJ_FILE_OLD);\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn _set_oom_adj(OOM_ADJ_FILE_OLD, OOM_DISABLE) ||\n\t\t       _set_oom_adj(OOM_ADJ_FILE_OLD, OOM_ADJUST_MIN);\n\t}\n\n\treturn _set_oom_adj(OOM_ADJ_FILE, OOM_SCORE_ADJ_MIN);\n}\n\nstatic int _handle_preloaded_fifo(int fd, const char *path)\n{\n\tstruct stat st_fd, st_path;\n\tint flags;\n\n\tif ((flags = fcntl(fd, F_GETFD)) < 0)\n\t\treturn 0;\n\n\tif (flags & FD_CLOEXEC)\n\t\treturn 0;\n\n\tif (fstat(fd, &st_fd) < 0 || !S_ISFIFO(st_fd.st_mode))\n\t\treturn 0;\n\n\tif (stat(path, &st_path) < 0 ||\n\t    st_path.st_dev != st_fd.st_dev ||\n\t    st_path.st_ino != st_fd.st_ino)\n\t\treturn 0;\n\n\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int _systemd_handover(struct dm_event_fifos *fifos)\n{\n\tconst char *e;\n\tchar *p;\n\tunsigned long env_pid, env_listen_fds;\n\tint r = 0;\n\n\t/* SD_ACTIVATION must be set! */\n\tif (!(e = getenv(SD_ACTIVATION_ENV_VAR_NAME)) || strcmp(e, \"1\"))\n\t\tgoto out;\n\n\t/* LISTEN_PID must be equal to our PID! */\n\tif (!(e = getenv(SD_LISTEN_PID_ENV_VAR_NAME)))\n\t\tgoto out;\n\n\terrno = 0;\n\tenv_pid = strtoul(e, &p, 10);\n\tif (errno || !p || *p || env_pid <= 0 ||\n\t    getpid() != (pid_t) env_pid)\n\t\tgoto out;\n\n\t/* LISTEN_FDS must be 2 and the fds must be FIFOSs! */\n\tif (!(e = getenv(SD_LISTEN_FDS_ENV_VAR_NAME)))\n\t\tgoto out;\n\n\terrno = 0;\n\tenv_listen_fds = strtoul(e, &p, 10);\n\tif (errno || !p || *p || env_listen_fds != 2)\n\t\tgoto out;\n\n\t/* Check and handle the FIFOs passed in */\n\tr = (_handle_preloaded_fifo(SD_FD_FIFO_SERVER, DM_EVENT_FIFO_SERVER) &&\n\t     _handle_preloaded_fifo(SD_FD_FIFO_CLIENT, DM_EVENT_FIFO_CLIENT));\n\n\tif (r) {\n\t\tfifos->server = SD_FD_FIFO_SERVER;\n\t\tfifos->server_path = DM_EVENT_FIFO_SERVER;\n\t\tfifos->client = SD_FD_FIFO_CLIENT;\n\t\tfifos->client_path = DM_EVENT_FIFO_CLIENT;\n\t}\n\nout:\n\tunsetenv(SD_ACTIVATION_ENV_VAR_NAME);\n\tunsetenv(SD_LISTEN_PID_ENV_VAR_NAME);\n\tunsetenv(SD_LISTEN_FDS_ENV_VAR_NAME);\n\treturn r;\n}\n\n#endif\n\nstatic void _remove_files_on_exit(void)\n{\n\tif (unlink(DMEVENTD_PIDFILE))\n\t\tlog_sys_error(\"unlink\", DMEVENTD_PIDFILE);\n\n\tif (!_systemd_activation) {\n\t\tif (unlink(DM_EVENT_FIFO_CLIENT))\n\t\t\tlog_sys_error(\"unlink\", DM_EVENT_FIFO_CLIENT);\n\n\t\tif (unlink(DM_EVENT_FIFO_SERVER))\n\t\t\tlog_sys_error(\"unlink\", DM_EVENT_FIFO_SERVER);\n\t}\n}\n\nstatic void _daemonize(void)\n{\n\tint child_status;\n\tint fd;\n\tpid_t pid;\n\tstruct rlimit rlim;\n\tstruct timeval tval;\n\tsigset_t my_sigset;\n\n\tsigemptyset(&my_sigset);\n\tif (sigprocmask(SIG_SETMASK, &my_sigset, NULL) < 0) {\n\t\tfprintf(stderr, \"Unable to restore signals.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tsignal(SIGTERM, &_exit_handler);\n\n\tswitch (pid = fork()) {\n\tcase -1:\n\t\tlog_sys_error(\"fork\", \"\");\n\t\texit(EXIT_FAILURE);\n\tcase 0:\t\t/* Child */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Wait for response from child */\n\t\twhile (!waitpid(pid, &child_status, WNOHANG) && !_exit_now) {\n\t\t\ttval.tv_sec = 0;\n\t\t\ttval.tv_usec = 250000;\t/* .25 sec */\n\t\t\tselect(0, NULL, NULL, NULL, &tval);\n\t\t}\n\n\t\tif (_exit_now)\t/* Child has signaled it is ok - we can exit now */\n\t\t\texit(EXIT_SUCCESS);\n\n\t\t/* Problem with child.  Determine what it is by exit code */\n\t\tswitch (WEXITSTATUS(child_status)) {\n\t\tcase EXIT_DESC_CLOSE_FAILURE:\n\t\tcase EXIT_DESC_OPEN_FAILURE:\n\t\tcase EXIT_FIFO_FAILURE:\n\t\tcase EXIT_CHDIR_FAILURE:\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Child exited with code %d\\n\", WEXITSTATUS(child_status));\n\t\t\tbreak;\n\t\t}\n\n\t\texit(WEXITSTATUS(child_status));\n\t}\n\n\tif (chdir(\"/\"))\n\t\texit(EXIT_CHDIR_FAILURE);\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n\t\tfd = 256;\t/* just have to guess */\n\telse\n\t\tfd = rlim.rlim_cur;\n\n\tfor (--fd; fd >= 0; fd--) {\n#ifdef __linux__\n\t\t/* Do not close fds preloaded by systemd! */\n\t\tif (_systemd_activation &&\n\t\t    (fd == SD_FD_FIFO_SERVER || fd == SD_FD_FIFO_CLIENT))\n\t\t\tcontinue;\n#endif\n\t\t(void) close(fd);\n\t}\n\n\tif ((open(\"/dev/null\", O_RDONLY) < 0) ||\n\t    (open(\"/dev/null\", O_WRONLY) < 0) ||\n\t    (open(\"/dev/null\", O_WRONLY) < 0))\n\t\texit(EXIT_DESC_OPEN_FAILURE);\n\n\tsetsid();\n}\n\nstatic int _reinstate_registrations(struct dm_event_fifos *fifos)\n{\n\tstatic const char _failed_parsing_msg[] = \"Failed to parse existing event registration.\\n\";\n\tstatic const char *_delim = \" \";\n\tstruct dm_event_daemon_message msg = { 0 };\n\tchar *endp, *dso_name, *dev_name, *mask, *timeout;\n\tunsigned long mask_value, timeout_value;\n\tint i, ret;\n\n\tret = daemon_talk(fifos, &msg, DM_EVENT_CMD_HELLO, NULL, NULL, 0, 0);\n\tfree(msg.data);\n\tmsg.data = NULL;\n\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to communicate with new instance of dmeventd.\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; _initial_registrations[i]; ++i) {\n\t\tif (!(strtok(_initial_registrations[i], _delim)) ||\n\t\t    !(dso_name = strtok(NULL, _delim)) ||\n\t\t    !(dev_name = strtok(NULL, _delim)) ||\n\t\t    !(mask = strtok(NULL, _delim)) ||\n\t\t    !(timeout = strtok(NULL, _delim))) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\terrno = 0;\n\t\tmask_value = strtoul(mask, &endp, 10);\n\t\tif (errno || !endp || *endp) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\terrno = 0;\n\t\ttimeout_value = strtoul(timeout, &endp, 10);\n\t\tif (errno || !endp || *endp) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (daemon_talk(fifos, &msg, DM_EVENT_CMD_REGISTER_FOR_EVENT,\n\t\t\t\tdso_name,\n\t\t\t\tdev_name,\n\t\t\t\t(enum dm_event_mask) mask_value,\n\t\t\t\ttimeout_value))\n\t\t\tfprintf(stderr, \"Failed to reinstate monitoring for device %s.\\n\", dev_name);\n\t}\n\n\treturn 1;\n}\n\nstatic void _restart_dmeventd(void)\n{\n\tstruct dm_event_fifos fifos = {\n\t\t.server = -1,\n\t\t.client = -1,\n\t\t/* FIXME Make these either configurable or depend directly on dmeventd_path */\n\t\t.client_path = DM_EVENT_FIFO_CLIENT,\n\t\t.server_path = DM_EVENT_FIFO_SERVER\n\t};\n\tstruct dm_event_daemon_message msg = { 0 };\n\tint i, count = 0;\n\tchar *message;\n\tint version;\n\tconst char *e;\n\n\t/* Get the list of registrations from the running daemon. */\n\tif (!init_fifos(&fifos)) {\n\t\tfprintf(stderr, \"WARNING: Could not initiate communication with existing dmeventd.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!dm_event_get_version(&fifos, &version)) {\n\t\tfprintf(stderr, \"WARNING: Could not communicate with existing dmeventd.\\n\");\n\t\tgoto bad;\n\t}\n\n\tif (version < 1) {\n\t\tfprintf(stderr, \"WARNING: The running dmeventd instance is too old.\\n\"\n\t\t\t\t\"Protocol version %d (required: 1). Action cancelled.\\n\",\n\t\t\t\tversion);\n\t\tgoto bad;\n\t}\n\n\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_GET_STATUS, \"-\", \"-\", 0, 0))\n\t\tgoto bad;\n\n\tmessage = strchr(msg.data, ' ') + 1;\n\tfor (i = 0; msg.data[i]; ++i)\n\t\tif (msg.data[i] == ';') {\n\t\t\tmsg.data[i] = 0;\n\t\t\t++count;\n\t\t}\n\n\tif (!(_initial_registrations = malloc(sizeof(char*) * (count + 1)))) {\n\t\tfprintf(stderr, \"Memory allocation registration failed.\\n\");\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\tif (!(_initial_registrations[i] = strdup(message))) {\n\t\t\tfprintf(stderr, \"Memory allocation for message failed.\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmessage += strlen(message) + 1;\n\t}\n\t_initial_registrations[count] = NULL;\n\n\tif (version >= 2) {\n\t\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_GET_PARAMETERS, \"-\", \"-\", 0, 0)) {\n\t\t\tfprintf(stderr, \"Failed to acquire parameters from old dmeventd.\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (strstr(msg.data, \"exec_method=systemd\"))\n\t\t\t_systemd_activation = 1;\n\t}\n#ifdef __linux__\n\t/*\n\t* If the protocol version is old, just assume that if systemd is running,\n\t* the dmeventd is also run as a systemd service via fifo activation.\n\t*/\n\tif (version < 2) {\n\t\t/* This check is copied from sd-daemon.c. */\n\t\tstruct stat st;\n\t\tif (!lstat(SD_RUNTIME_UNIT_FILE_DIR, &st) && !!S_ISDIR(st.st_mode))\n\t\t\t_systemd_activation = 1;\n\t}\n#endif\n\n\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_DIE, \"-\", \"-\", 0, 0)) {\n\t\tfprintf(stderr, \"Old dmeventd refused to die.\\n\");\n\t\tgoto bad;\n\t}\n\n\tif (!_systemd_activation &&\n\t    ((e = getenv(SD_ACTIVATION_ENV_VAR_NAME)) && strcmp(e, \"1\")))\n\t\t_systemd_activation = 1;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tif ((access(DMEVENTD_PIDFILE, F_OK) == -1) && (errno == ENOENT))\n\t\t\tbreak;\n\t\tusleep(10);\n\t}\n\n\tif (!_systemd_activation) {\n\t\tfini_fifos(&fifos);\n\t\treturn;\n\t}\n\n\t/* Reopen fifos. */\n\tfini_fifos(&fifos);\n\tif (!init_fifos(&fifos)) {\n\t\tfprintf(stderr, \"Could not initiate communication with new instance of dmeventd.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!_reinstate_registrations(&fifos)) {\n\t\tfprintf(stderr, \"Failed to reinstate monitoring with new instance of dmeventd.\\n\");\n\t\tgoto bad;\n\t}\n\n\tfini_fifos(&fifos);\n\texit(EXIT_SUCCESS);\nbad:\n\tfini_fifos(&fifos);\n\texit(EXIT_FAILURE);\n}\n\nstatic void _usage(char *prog, FILE *file)\n{\n\tfprintf(file, \"Usage:\\n\"\n\t\t\"%s [-d [-d [-d]]] [-f] [-h] [-l] [-R] [-V] [-?]\\n\\n\"\n\t\t\"   -d       Log debug messages to syslog (-d, -dd, -ddd)\\n\"\n\t\t\"   -f       Don't fork, run in the foreground\\n\"\n\t\t\"   -h       Show this help information\\n\"\n\t\t\"   -l       Log to stdout,stderr instead of syslog\\n\"\n\t\t\"   -?       Show this help information on stderr\\n\"\n\t\t\"   -R       Restart dmeventd\\n\"\n\t\t\"   -V       Show version of dmeventd\\n\\n\", prog);\n}\n\nint main(int argc, char *argv[])\n{\n\tsigned char opt;\n\tstruct dm_event_fifos fifos = {\n\t\t.client = -1,\n\t\t.server = -1,\n\t\t.client_path = DM_EVENT_FIFO_CLIENT,\n\t\t.server_path = DM_EVENT_FIFO_SERVER\n\t};\n\ttime_t now, idle_exit_timeout = DMEVENTD_IDLE_EXIT_TIMEOUT;\n\topterr = 0;\n\toptind = 0;\n\n\twhile ((opt = getopt(argc, argv, \"?fhVdlR\")) != EOF) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\t_usage(argv[0], stdout);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase '?':\n\t\t\t_usage(argv[0], stderr);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'R':\n\t\t\t_restart++;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t_foreground++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t_debug_level++;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t_use_syslog = 0;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprintf(\"dmeventd version: %s\\n\", DM_LIB_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t}\n\n\tif (!_foreground && !_use_syslog) {\n\t\tprintf(\"WARNING: Ignoring logging to stdout, needs options -f\\n\");\n\t\t_use_syslog = 1;\n\t}\n\t/*\n\t * Switch to C locale to avoid reading large locale-archive file\n\t * used by some glibc (on some distributions it takes over 100MB).\n\t * Daemon currently needs to use mlockall().\n\t */\n\tif (setenv(\"LC_ALL\", \"C\", 1))\n\t\tperror(\"Cannot set LC_ALL to C\");\n\n\tif (_restart)\n\t\t_restart_dmeventd();\n\n#ifdef __linux__\n\t_systemd_activation = _systemd_handover(&fifos);\n#endif\n\n\tif (!_foreground)\n\t\t_daemonize();\n\n\tif (_use_syslog)\n\t\topenlog(\"dmeventd\", LOG_PID, LOG_DAEMON);\n\n\tdm_event_log_set(_debug_level, _use_syslog);\n\tdm_log_with_errno_init(_libdm_log);\n\n\t(void) dm_prepare_selinux_context(DMEVENTD_PIDFILE, S_IFREG);\n\tif (dm_create_lockfile(DMEVENTD_PIDFILE) == 0)\n\t\texit(EXIT_FAILURE);\n\n\tatexit(_remove_files_on_exit);\n\t(void) dm_prepare_selinux_context(NULL, 0);\n\n\t/* Set the rest of the signals to cause '_exit_now' to be set */\n\tsignal(SIGTERM, &_exit_handler);\n\tsignal(SIGINT, &_exit_handler);\n\tsignal(SIGHUP, &_exit_handler);\n\tsignal(SIGQUIT, &_exit_handler);\n\n#ifdef __linux__\n\t/* Systemd has adjusted oom killer for us already */\n\tif (!_systemd_activation && !_protect_against_oom_killer())\n\t\tlog_warn(\"WARNING: Failed to protect against OOM killer.\");\n#endif\n\n\t_init_thread_signals();\n\n\tpthread_mutex_init(&_global_mutex, NULL);\n\n\tif (!_systemd_activation && !_open_fifos(&fifos))\n\t\texit(EXIT_FIFO_FAILURE);\n\n\t/* Signal parent, letting them know we are ready to go. */\n\tif (!_foreground)\n\t\tkill(getppid(), SIGTERM);\n\n\tlog_notice(\"dmeventd ready for processing.\");\n\n\t_idle_since = time(NULL);\n\n\tif (_initial_registrations)\n\t\t_process_initial_registrations();\n\n\tfor (;;) {\n\t\tif (_idle_since) {\n\t\t\tif (_exit_now) {\n\t\t\t\tif (_exit_now == DM_SCHEDULED_EXIT)\n\t\t\t\t\tbreak; /* Only prints shutdown message */\n\t\t\t\tlog_info(\"dmeventd detected break while being idle \"\n\t\t\t\t\t \"for %ld second(s), exiting.\",\n\t\t\t\t\t (long) (time(NULL) - _idle_since));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (idle_exit_timeout) {\n\t\t\t\tnow = time(NULL);\n\t\t\t\tif (now < _idle_since)\n\t\t\t\t\t_idle_since = now; /* clock change? */\n\t\t\t\tnow -= _idle_since;\n\t\t\t\tif (now >= idle_exit_timeout) {\n\t\t\t\t\tlog_info(\"dmeventd was idle for %ld second(s), \"\n\t\t\t\t\t\t \"exiting.\", (long) now);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_exit_now == DM_SIGNALED_EXIT) {\n\t\t\t_exit_now = DM_SCHEDULED_EXIT;\n\t\t\t/*\n\t\t\t * When '_exit_now' is set, signal has been received,\n\t\t\t * but can not simply exit unless all\n\t\t\t * threads are done processing.\n\t\t\t */\n\t\t\tlog_info(\"dmeventd received break, scheduling exit.\");\n\t\t}\n\t\t_process_request(&fifos);\n\t\t_cleanup_unused_threads();\n\t}\n\n\tpthread_mutex_destroy(&_global_mutex);\n\n\tlog_notice(\"dmeventd shutting down.\");\n\n\tif (fifos.client >= 0 && close(fifos.client))\n\t\tlog_sys_error(\"client close\", fifos.client_path);\n\tif (fifos.server >= 0 && close(fifos.server))\n\t\tlog_sys_error(\"server close\", fifos.server_path);\n\n\tif (_use_syslog)\n\t\tcloselog();\n\n\t_exit_dm_lib();\n\n\texit(EXIT_SUCCESS);\n}\n"
    },
    "skipped": [],
    "total_files": 1035
}