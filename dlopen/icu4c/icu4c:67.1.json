{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/configure.ac": "# -*-autoconf-*-\nAC_COPYRIGHT([ Copyright (C) 2016 and later: Unicode, Inc. and others. License & terms of use: http://www.unicode.org/copyright.html ])\n# AC_COPYRIGHT([ Copyright (c) 1999-2015, International Business Machines Corporation and others. All Rights Reserved. ])\n# configure.in for ICU\n# Stephen F. Booth, heavily modified by Yves and others\n\n# NOTE: please use 'autoreconf' to rebuild, otherwise 'aclocal && autoconf'.\n\n# Check for autoconf version\nAC_PREREQ(2.69)\n\n# Process this file with autoreconf to produce a configure script\nAC_INIT([ICU],\n        m4_esyscmd_s([sed -n 's/^[ \t]*#[ \t]*define[ \t]*U_ICU_VERSION[ \t]*\"\\([^\"]*\\)\".*/\\1/p' \"./common/unicode/uvernum.h]\"),\n        [http://icu-project.org/bugs],\n        [International Components for Unicode],\n        [http://icu-project.org])\n\n# Instruct Python to never write any byte code to the ICU source tree.\nPYTHONDONTWRITEBYTECODE=1\nexport PYTHONDONTWRITEBYTECODE\n\nAC_CONFIG_MACRO_DIR([config/m4])\nAC_CONFIG_SRCDIR([common/unicode/utypes.h])\n\nPACKAGE=\"icu\"\nAC_SUBST(PACKAGE)\n\n# Use custom echo test for newline option\n# Current autoconf (2.65) gives incorrect echo newline option\n# for icu-config\n# This may be removed later - mow (June 17, 2010)\nICU_ECHO_C= ICU_ECHO_N= ICU_ECHO_T=\ncase `/bin/sh -c \"echo -n x\"` in\n-n*)\n  case `/bin/sh -c \"echo 'x\\c'\"` in\n  *c*) ICU_ECHO_T=' ';;     # ECHO_T is single tab character.\n  *)   ICU_ECHO_C='\\c';;\n  esac;;\n*)\n  ICU_ECHO_N='-n';;\nesac\nAC_SUBST(ICU_ECHO_N)\nAC_SUBST(ICU_ECHO_C)\nAC_SUBST(ICU_ECHO_T)\n\nAC_MSG_CHECKING(for ICU version numbers)\n\n# Get the ICU version from uversion.h or other headers\ngeticuversion() {\n    [sed -n 's/^[ \t]*#[ \t]*define[ \t]*U_ICU_VERSION[ \t]*\"\\([^\"]*\\)\".*/\\1/p' \"$@\"]\n}\ngetuversion() {\n    [sed -n 's/^[ \t]*#[ \t]*define[ \t]*U_UNICODE_VERSION[ \t]*\"\\([^\"]*\\)\".*/\\1/p' \"$@\"]\n}\nVERSION=`geticuversion $srcdir/common/unicode/uvernum.h`\nif test x\"$VERSION\" = x; then\n   as_fn_error $? \"Cannot determine ICU version number from uvernum.h header file\" \"$LINENO\" 5\nfi\n\n#TODO: IcuBug:8502\n#if test \"$VERSION\" != \"$PACKAGE_VERSION\"; then\n#   AC_MSG_ERROR([configure was generated for $PACKAGE_VERSION but uvernum.h has $VERSION - please rerun autoconf])\n#fi\n\nUNICODE_VERSION=`getuversion $srcdir/common/unicode/uchar.h`\nif test x\"$UNICODE_VERSION\" = x; then\n    AC_MSG_ERROR([Cannot determine Unicode version number from uchar.h header file])\nfi\n# Compute a reasonable library version from the release version. This is\n# very bad, but that's wanted... We want to make sure that the LIB_VERSION\n# has at least a dot in it, so we'll add a .0 if needed.\n#[LIB_VERSION=`echo $VERSION | sed -e 's/\\.//' -e 's/^\\([^.]*\\)$/\\1.0/'`]\nLIB_VERSION=$VERSION\nLIB_VERSION_MAJOR=`echo $LIB_VERSION | sed 's/\\..*//'`\nAC_SUBST(VERSION)\nAC_SUBST(LIB_VERSION)\nAC_SUBST(LIB_VERSION_MAJOR)\nAC_MSG_RESULT([release $VERSION, library $LIB_VERSION, unicode version $UNICODE_VERSION])\n\nAC_SUBST(UNICODE_VERSION)\n\n# Determine the host system\nAC_CANONICAL_HOST\n\nAC_SUBST(CPPFLAGS)\n\n# This variable is needed on z/OS because the C++ compiler only recognizes .C\n_CXX_CXXSUFFIX=cpp\nexport _CXX_CXXSUFFIX\n\n# Accumulate #defines\n\n# CONFIG_CPPFLAGS: These are defines that are set for ICU Build time only.\n# They are only needed for building ICU itself. Example: platform stuff\nCONFIG_CPPFLAGS=\"\"\n# UCONFIG_CPPFLAGS: These are defines which are set for ICU build time,\n# and also a notice is output that they need to be set\n# for end-users of ICU also. uconfig.h.prepend is generated\n# with, for example, \"#define U_DISABLE_RENAMING 1\"\n# Example: ICU configuration stuff\nUCONFIG_CPPFLAGS=\"\"\n# UCONFIG_CFLAGS: contains a copy of anything that needs to be set by end users\n# such as -std\nUCONFIG_CFLAGS=\"\"\n\n# Check whether to install icu-config\nAC_ARG_ENABLE([icu-config],\n    AS_HELP_STRING([--enable-icu-config], [install icu-config]),\n        [case \"${enableval}\" in\n            yes) enable_icu_config=true ;;\n            no) enable_icu_config=false ;;\n            *) AC_MSG_ERROR([bad value '${enableval}' for --enable-icu-config]) ;;\n        esac], [enable_icu_config=true])\nAC_SUBST(INSTALL_ICU_CONFIG, [$enable_icu_config])\n\n# Check whether to build debug libraries\nAC_MSG_CHECKING([whether to build debug libraries])\nenabled=no\nENABLE_DEBUG=0\nAC_ARG_ENABLE(debug,\n    [  --enable-debug          build debug libraries and enable the U_DEBUG define [default=no]],\n    [ case \"${enableval}\" in\n         yes|\"\") enabled=yes; ENABLE_DEBUG=1; CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_DEBUG=1\" ;;\n         *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(ENABLE_DEBUG)\n\n# Check whether to build release libraries\nAC_MSG_CHECKING([whether to build release libraries])\nenabled=yes\nENABLE_RELEASE=1\nAC_ARG_ENABLE(release,\n    [  --enable-release        build release libraries [default=yes]],\n    [ case \"${enableval}\" in\n         no) enabled=no; ENABLE_RELEASE=0 ;;\n         *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(ENABLE_RELEASE)\n\n# Don't use the default C/CXXFLags\n: ${CFLAGS=\"\"}\n: ${CXXFLAGS=\"\"}\n\n# Checks for compilers\nAC_PROG_CC([clang gcc cc c99 c89 xlc_r xlc cl.exe icc])\n# Make sure that we try clang++ first, which provides C++11 support.\n# The g++ compiler is less likely to support C++11.\nAC_PROG_CXX([clang++ g++ c++ gpp xlC_r xlC aCC CC cxx cc++ cl.exe icc FCC KCC RCC])\n\n# pkg-config is needed for harfbuzz support\nPKG_PROG_PKG_CONFIG([0.20])\nPKG_CHECK_MODULES(ICULEHB, icu-le-hb, have_icu_le_hb=true, :)\n\n# Ensure that if CXXFLAGS/CFLAGS were not set when calling configure, set it correctly based on (enable/disable) debug or release option\n# The release mode use is the default one for autoconf\nif test \"$GCC\" = yes; then\n    if test \"$CFLAGS\" = \"\"; then\n        if test \"$ENABLE_DEBUG\" = 1; then\n            CFLAGS=-g\n        fi\n        if test \"$ENABLE_RELEASE\" = 1; then\n            CFLAGS=\"$CFLAGS -O2\"\n        fi\n    fi\n    if test \"$CXXFLAGS\" = \"\"; then\n        if test \"$ENABLE_DEBUG\" = 1; then\n            CXXFLAGS=-g\n        fi\n        if test \"$ENABLE_RELEASE\" = 1; then\n            CXXFLAGS=\"$CXXFLAGS -O2\"\n        fi\n    fi\nfi\n\nAC_PROG_CPP\n\nAC_PROG_INSTALL\n\nAC_SUBST(cross_compiling)\n\ndnl use the pld hack to get ac_fn_cxx_try_link defined globally and not local\nAC_LANG_PUSH([C++])\nAC_LINK_IFELSE([AC_LANG_PROGRAM()])\nAC_LANG_POP([C++])\n\n# make sure install is relative to srcdir - if a script\nif test \"$srcdir\" = \".\"; then\n  # If srcdir isn't just ., then (srcdir) is already prepended.\n  if test \"${ac_install_sh}\" = \"${INSTALL}\"; then\n   INSTALL=\"\\\\\\$(top_srcdir)/${ac_install_sh}\"\n  fi\nfi\n\n#AC_CHECK_PROG(AUTOCONF, autoconf, autoconf, true)\n#AC_CHECK_PROG(STRIP, strip, strip, true)\n\n# TODO(ICU-20301): Remove fallback to Python 2.\nAC_CHECK_PROGS(PYTHON, python3 \"py -3\" python \"py\")\nAC_SUBST(PYTHON)\n\n# Check for the platform make\nAC_PATH_PROGS(U_MAKE, gmake gnumake, make)\nAC_SUBST(U_MAKE)\n\n\nAC_ARG_WITH(cross-build,\n\t[  --with-cross-build=dir specify an absolute path to the build directory of an ICU built for the current platform [default=no cross dir]],\n\t[cross_buildroot=\"${withval}\"],\n        [cross_buildroot=\"\"])\n\nif test \"X$cross_buildroot\" = \"X\"; then\n    if test \"$cross_compiling\" = \"yes\"; then\n        AC_MSG_ERROR([Error! Cross compiling but no --with-cross-build option specified - please supply the path to an executable ICU's build root])\n\tdnl '\n    fi\nelse\n    if test -f \"${cross_buildroot}/config/icucross.mk\"; then\n        AC_MSG_RESULT([Using cross buildroot: $cross_buildroot])\n    else\n        if test -d \"${cross_buildroot}\"; then\n            AC_MSG_ERROR([${cross_buildroot}/config/icucross.mk not found. Please build ICU in ${cross_buildroot} first.])\n        else\n            AC_MSG_ERROR([No such directory ${cross_buildroot} supplied as the argument to --with-cross-build. Use an absolute path.])\n        fi\n    fi\nfi\nAC_SUBST(cross_buildroot)\n\n# Check for doxygen to generate documentation\nAC_PATH_PROG(DOXYGEN,doxygen,,$PATH:/usr/local/bin:/usr/bin)\n\n# Check that the linker is usable\nICU_PROG_LINK\n\n# Determine the executable suffix\n# We don't use AC_EXEEXT because some compilers output separate debugging\n# files, which confuses the AC_EXEEXT macro.\nAC_MSG_CHECKING(checking for executable suffix)\ncase \"${host}\" in\n    *-*-cygwin*|*-*-mingw*)  EXEEXT=.exe ;;\n    *)      EXEEXT=\"\" ;;\nesac\nac_exeext=$EXEEXT\nAC_MSG_RESULT($EXEEXT)\nAC_SUBST(EXEEXT)\n\n# Determine how strict we want to be when compiling\nAC_CHECK_STRICT_COMPILE\n\n# Check if we can build and use 64-bit libraries\nAC_CHECK_64BIT_LIBS\nAC_SUBST(ARFLAGS)\nAC_SUBST(COMPILE_LINK_ENVVAR)\n\n# Determine the Makefile fragment\nICU_CHECK_MH_FRAG\n\n# Checks for libraries and other host specific stuff\n# On HP/UX, don't link to -lm from a shared lib because it isn't\n#  PIC (at least on 10.2)\ncase \"${host}\" in\n\t*-*-hpux*) \tAC_CHECK_LIB(m, floor, LIB_M=\"-lm\") ;;\n\n\t*) \t\tAC_CHECK_LIB(m, floor)\n\t\t\tLIB_M=\"\" ;;\nesac\nAC_SUBST(LIB_M)\n\n# Check whether to build shared libraries\nAC_MSG_CHECKING([whether to build shared libraries])\nenabled=no\nAC_ARG_ENABLE(shared,\n    [  --enable-shared         build shared libraries [default=yes]],\n    [ case \"${enableval}\" in\n\t     yes|\"\") enabled=yes; ENABLE_SHARED=YES ;;\n\t     no);;\n\t     *) ;;\n    esac],\n    [enabled=yes; ENABLE_SHARED=YES]\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(ENABLE_SHARED)\n\n# Check whether to build static libraries\nAC_MSG_CHECKING([whether to build static libraries])\nenabled=no\nAC_ARG_ENABLE(static,\n    [  --enable-static         build static libraries [default=no]],\n    [ case \"${enableval}\" in\n\t     yes|\"\") enabled=yes; ENABLE_STATIC=YES ;;\n\t     no) ;;\n\t     *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(ENABLE_STATIC)\n\n# When building release static library, there might be some optimization flags we can use\nif test \"$ENABLE_STATIC\" = \"YES\"; then\n    if test \"$ENABLE_SHARED\" != \"YES\"; then\n        if test \"$ENABLE_RELEASE\" = 1; then\n            AC_MSG_CHECKING([whether we can use static library optimization option])\n            CHECK_STATIC_OPT_FLAG=no\n\n            OLD_CPPFLAGS=\"${CPPFLAGS}\"\n            OLD_LDFLAGS=\"${LDFLAGS}\"\n\n            case \"${host}\" in\n            *-linux*|i*86-*-*bsd*|i*86-pc-gnu)\n                if test \"$GCC\" = yes; then\n                    CPPFLAGS=\"${CPPFLAGS} -ffunction-sections -fdata-sections\"\n                    LDFLAGS=\"${LDFLAGS} -Wl,--gc-sections\"\n                fi\n                ;;\n            *)\n                ;;\n            esac\n\n            AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [CHECK_STATIC_OPT_FLAG=yes], [CHECK_STATIC_OPT_FLAG=no])\n            AC_MSG_RESULT($CHECK_STATIC_OPT_FLAG)\n            if test \"$CHECK_STATIC_OPT_FLAG\" = no; then\n                CPPFLAGS=\"${OLD_CPPFLAGS}\"\n                LDFLAGS=\"${OLD_LDFLAGS}\"\n            fi\n        fi\n    fi\nfi\n\n\n# Check whether to enable auto cleanup of libraries\nAC_MSG_CHECKING([whether to enable auto cleanup of libraries])\nenabled=no\nUCLN_NO_AUTO_CLEANUP=1\nAC_ARG_ENABLE(auto-cleanup,\n    [  --enable-auto-cleanup   enable auto cleanup of libraries [default=no]],\n    [ case \"${enableval}\" in\n         yes) enabled=yes;\n         CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DUCLN_NO_AUTO_CLEANUP=0\";\n         UCLN_NO_AUTO_CLEANUP=0\n          ;;\n         *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(UCLN_NO_AUTO_CLEANUP)\n\n# MSVC floating-point option\nMSVC_RELEASE_FLAG=\"\"\nif test $enabled = yes\nthen\n    if test $icu_cv_host_frag = mh-cygwin-msvc -o $icu_cv_host_frag = mh-msys-msvc\n    then\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n    #if defined _MSC_VER && _MSC_VER >= 1400\n    #else\n    Microsoft Visual C++ < 2005\n    #endif\n        ]], [[]])],[MSVC_RELEASE_FLAG=\"/fp:precise\"],[MSVC_RELEASE_FLAG=\"/Op\"])\n\n        CFLAGS=\"${CFLAGS} ${MSVC_RELEASE_FLAG}\"\n        CXXFLAGS=\"${CXXFLAGS} ${MSVC_RELEASE_FLAG}\"\n    fi\nfi\n\n# Check whether to enabled draft APIs\nAC_MSG_CHECKING([whether to enable draft APIs])\nenabled=yes\nU_DEFAULT_SHOW_DRAFT=1\nAC_ARG_ENABLE(draft,\n    [  --enable-draft          enable draft APIs (and internal APIs) [default=yes]],\n    [ case \"${enableval}\" in\n         no) enabled=no; U_DEFAULT_SHOW_DRAFT=0;\n         CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_DEFAULT_SHOW_DRAFT=0\"\n          ;;\n         *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\n# Make sure that we can use draft API in ICU.\nif test \"$U_DEFAULT_SHOW_DRAFT\" = 0; then\n    CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_SHOW_DRAFT_API -DU_SHOW_INTERNAL_API\"\nfi\nAC_SUBST(U_DEFAULT_SHOW_DRAFT)\n\nAC_PROG_RANLIB\n\n# need sed\nAC_PROG_SED\n\n# look for 'ar' the proper way\nAC_CHECK_TOOL(AR, ar, false)\n\nAC_MSG_CHECKING([whether to enable renaming of symbols])\nenabled=yes\nU_DISABLE_RENAMING=0\nAC_ARG_ENABLE(renaming,\n    [  --enable-renaming       add a version suffix to symbols [default=yes]],\n    [ case \"${enableval}\" in\n\t     yes|\"\") enabled=yes ;;\n\t     no) enabled=no; U_DISABLE_RENAMING=1;\n             UCONFIG_CPPFLAGS=\"${UCONFIG_CPPFLAGS} -DU_DISABLE_RENAMING=1\"\n              ;;\n\t     *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(U_DISABLE_RENAMING)\n\nAC_MSG_CHECKING([whether to enable function and data tracing])\nenabled=no\nU_ENABLE_TRACING=0\nAC_ARG_ENABLE(tracing,\n    [  --enable-tracing        enable function and data tracing [default=no]],\n    [ case \"${enableval}\" in\n\t     yes|\"\") enabled=yes;\n                     CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_ENABLE_TRACING=1\";\n                     U_ENABLE_TRACING=1 ;;\n\t     no) enabled=no; U_ENABLE_TRACING=0 ;;\n\t     *) ;;\n    esac],\n)\nAC_MSG_RESULT($enabled)\nAC_SUBST(U_ENABLE_TRACING)\n\n# check if elf.h is present.\nAC_CHECK_HEADERS([elf.h])\nif test \"x$ac_cv_header_elf_h\" = \"xyes\"; then\n    CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_HAVE_ELF_H=1\";\nfi\n\n# Enable/disable plugins\nAC_ARG_ENABLE(plugins,\n\t[  --enable-plugins        enable plugins [default=no]],\n\t[case \"${enableval}\" in\n\t\tyes) plugins=true ;;\n\t\tno)  plugins=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-plugins) ;;\n\t\tesac],\n\tplugins=false)\nICU_CONDITIONAL(PLUGINS, test \"$plugins\" = true)\n\nif test \"x$plugins\" = \"xtrue\"; then\n   UCONFIG_CPPFLAGS=\"$UCONFIG_CPPFLAGS -DUCONFIG_ENABLE_PLUGINS=1\"\nfi\n\n\nU_ENABLE_DYLOAD=1\nenable=yes\nAC_MSG_CHECKING([whether to enable dynamic loading of plugins. Ignored if plugins disabled.])\nAC_ARG_ENABLE(dyload,\n    [  --disable-dyload        disable dynamic loading [default=no]],\n    [ case \"${enableval}\" in\n\t     yes|\"\")\n\t\t     U_ENABLE_DYLOAD=1\n                     enable=yes\n                     ;;\n\t     no)\n\t     \t U_ENABLE_DYLOAD=0;\n                 enable=no;\n                 CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DU_ENABLE_DYLOAD=0\";\n                 ;;\n\t     *) ;;\n    esac],\n)\nAC_MSG_RESULT($enable)\nAC_SUBST(U_ENABLE_DYLOAD)\n\nif test \"$enable\" = \"yes\"; then\n   AC_CHECK_HEADERS([dlfcn.h])\n   #AC_MSG_RESULT($enabled)\n   AC_SEARCH_LIBS([dlopen], [dl])\n   AC_CHECK_FUNCS([dlopen])\n\n   if test \"x$ac_cv_func_dlopen\" != xyes; then\n      CONFIG_CPPFLAGS=\"$CONFIG_CPPFLAGS -DHAVE_DLOPEN=0\"\n   fi\nfi\n\n# Check for miscellanous functions.\n# So, use for putil / tools only.\n# Note that this will generate HAVE_GETTIMEOFDAY, not U_HAVE_GETTIMEOFDAY\nAC_CHECK_FUNCS([gettimeofday])\n\n\n# Check whether to use the evil rpath or not\nAC_ARG_ENABLE(rpath,\n    [  --enable-rpath          use rpath when linking [default is only if necessary]],\n    [ case \"${enableval}\" in\n\t     yes|\"\") ENABLE_RPATH=YES ;;\n\t     no) ;;\n\t     *) ;;\n    esac],\n    [ENABLE_RPATH=NO]\n)\nAC_SUBST(ENABLE_RPATH)\n\n\n\nAC_LANG_PUSH([C++])\nAC_MSG_CHECKING([[if we have a C++ compiler]])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[cxx_okay=yes],[cxx_okay=no])\nif test $cxx_okay = yes\nthen\n\tAC_MSG_RESULT([[Good]])\nelse\n\tAC_MSG_RESULT([[no]])\n\tAC_MSG_ERROR([[C++ compiler $CXX does not work or no compiler found]])\nfi\n\nif [[ \"$GXX\" = yes ]]; then\n    # if CXXFLAGS does not have a \"-std=\" setting, set it now to -std=c++11,\n    # and check that the compiler still works.\n    if ! echo \"$CXXFLAGS\" | grep '\\-std=' >/dev/null 2>&1; then\n        OLD_CXXFLAGS=\"${CXXFLAGS}\"\n        CXXFLAGS=\"$CXXFLAGS -std=c++11\"\n        AC_MSG_CHECKING([[if we have a C++11 compiler]])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[cxx11_okay=yes],[cxx11_okay=no])\n        AC_MSG_RESULT($cxx11_okay)\n        if [[ $cxx11_okay = yes ]]; then\n            AC_MSG_NOTICE([Adding CXXFLAGS option -std=c++11])\n            UCONFIG_CXXFLAGS=\"${UCONFIG_CXXFLAGS} -std=c++11\"\n        else\n            CXXFLAGS=\"$OLD_CXXFLAGS\"\n        fi\n        case \"${host}\" in\n        *-*-solaris*)\n            CXXFLAGS=\"$OLD_CXXFLAGS\"\n            ;;\n        esac\n    fi\nfi\n\nAC_LANG_POP([C++])\n\n# Always build ICU with multi-threading support.\nOLD_LIBS=${LIBS}\n\n# For Compaq Tru64 (OSF1), we must look for pthread_attr_init\n# and must do this before seaching for pthread_mutex_destroy, or\n# we will pick up libpthreads.so not libpthread.so\n# If this fails, then we must test for HPUX specials, before\n# moving on to a more generic test\n\nAC_CHECK_LIB(pthread, pthread_attr_init)\nif test $ac_cv_lib_pthread_pthread_attr_init = yes; then\n  :\nelse\n  # Locate the right library for POSIX threads. We look for the\n  # symbols in the libraries first, because on Solaris libc provides\n  # pthread_create but libpthread has the real code :(\n  # AIX uses libpthreads instead of libpthread, and HP/UX uses libpthread\n  # FreeBSD users may need libpthread if they do not have libc_r.\n\n  AC_SEARCH_LIBS_FIRST(pthread_mutex_destroy, pthread pthreads c_r )\n\n  if test \"$ac_cv_search_pthread_mutex_destroy\" != no; then\n    :\n  else\n    # For HP 11\n    AC_CHECK_LIB(pthread, pthread_mutex_init)\n    if test $ac_cv_lib_pthread_pthread_mutex_init = yes; then\n      :\n    fi\n  fi\n\n  AC_CHECK_FUNC(pthread_mutex_lock)\n\n  if test $ac_cv_func_pthread_mutex_lock = yes; then\n    :\n  fi\nfi\n# Check to see if we are using CygWin with MSVC\ncase \"${host}\" in\n*-pc-cygwin*|*-pc-mingw*)\n  # For gcc, the thread options are set by mh-mingw/mh-cygwin\n  # For msvc, the thread options are set by runConfigureICU\n  :\n  ;;\n*-*-hpux*)\n  # Add -mt because it does several nice things on newer compilers.\n  case \"${icu_cv_host_frag}\" in\n    mh-hpux-acc)\n      OLD_CXXFLAGS=\"${CXXFLAGS}\"\n      CXXFLAGS=\"${CXXFLAGS} -mt\"\n      if test x\"`${CXX} ${CXXFLAGS} 2>&1`\" != x\"\"; then\n         CXXFLAGS=\"${OLD_CXXFLAGS}\"\n      else\n         UCONFIG_CXXFLAGS=\"${UCONFIG_CXXFLAGS} -mt\"\n      fi\n    ;;\n  esac\n  ;;\n*-*-solaris*)\n  case \"${icu_cv_host_frag}\" in\n    mh-solaris)\n         LIBS=\"${LIBS} -mt\"\n    ;;\n  esac\n  ;;\nesac\n\nAC_ARG_ENABLE(weak-threads,\n\t[  --enable-weak-threads   weakly reference the threading library [default=no]],\n\t[case \"${enableval}\" in\n\t\tyes)\n            LIB_THREAD=\"${LIBS%${OLD_LIBS}}\"\n            LIBS=${OLD_LIBS}\n            ;;\n\t\tno)  ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-weak-threads) ;;\n\t\tesac])\nAC_SUBST(LIB_THREAD)\n\n# Check for mmap()\n\n# The AC_FUNC_MMAP macro doesn't work properly.  It seems to be too specific.\n# Do this check instead.\nHAVE_MMAP=0\nAC_MSG_CHECKING([for mmap])\nAC_CACHE_VAL(ac_cv_func_mmap_ok,\n    [AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>], [mmap((void *)0, 0, PROT_READ, 0, 0, 0);])],[ac_cv_func_mmap_ok=yes],[ac_cv_func_mmap_ok=no])] )\nAC_MSG_RESULT($ac_cv_func_mmap_ok)\nif test $ac_cv_func_mmap_ok = yes\nthen\n    HAVE_MMAP=1\nelse\n    CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_MMAP=0\"\nfi\nAC_SUBST(HAVE_MMAP)\n\nAC_MSG_CHECKING([for genccode assembly])\n\n# Check to see if genccode can generate simple assembly.\nGENCCODE_ASSEMBLY=\ncase \"${host}\" in\n*-linux*|*-kfreebsd*-gnu*|i*86-*-*bsd*|i*86-pc-gnu)\n    if test \"$GCC\" = yes; then\n        # We're using gcc, and the simple -a gcc command line works for genccode\n        GENCCODE_ASSEMBLY=\"-a gcc\"\n    fi ;;\ni*86-*-solaris*)\n    if test \"$GCC\" = yes; then\n        # When using gcc, look if we're also using GNU as.\n        # When using GNU as, the simple -a gcc command line works for genccode.\n        asv=`\"${CC}\" -print-prog-name=as 2>/dev/null`\n        asv=`\"${asv}\" --version 2>/dev/null`\n        case \"X${asv}\" in\n        X*GNU*) GENCCODE_ASSEMBLY=\"-a gcc\" ;;\n        X*) GENCCODE_ASSEMBLY=\"-a sun-x86\" ;;\n        esac\n        unset asv\n    else\n        GENCCODE_ASSEMBLY=\"-a sun-x86\"\n    fi ;;\nsparc-*-solaris*)\n    GENCCODE_ASSEMBLY=\"-a sun\"\n    ;;\nia64-*-hpux*)\n# There has been some issues with building ICU data on HPUX ia64 aCC\n# when using the assemble code setting below.  For now, build without\n# assemble code for this platform.  This will increase the build time.   \n#    GENCCODE_ASSEMBLY=\"-a aCC-ia64\"\n    ;;\nesac\nAC_SUBST(GENCCODE_ASSEMBLY)\n\nAC_MSG_RESULT($GENCCODE_ASSEMBLY)\n\n# Checks for header files\nAC_CHECK_HEADERS(inttypes.h)\nif test $ac_cv_header_inttypes_h = no; then\n U_HAVE_INTTYPES_H=0\n CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INTTYPES_H=0\"\nelse\n U_HAVE_INTTYPES_H=1\nfi\nif test \"$CC\" = ccc; then\n AC_MSG_RESULT(\"C compiler set to CCC ${CC}\" )\n case \"${host}\" in\n        alpha*-*-*) U_HAVE_INTTYPES_H=0;\n        CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INTTYPES_H=0\"\n esac\nfi\n\nAC_SUBST(U_HAVE_INTTYPES_H)\n\nAC_CHECK_HEADERS(dirent.h)\nif test $ac_cv_header_dirent_h = no; then\n U_HAVE_DIRENT_H=0\n CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_DIRENT_H=0\"\nelse\n U_HAVE_DIRENT_H=1\nfi\n\nAC_SUBST(U_HAVE_DIRENT_H)\n\n# Check for endianness\nAC_C_BIGENDIAN()\nif test $ac_cv_c_bigendian = no; then\nU_IS_BIG_ENDIAN=0\nU_ENDIAN_CHAR=\"l\"\nelse\nU_IS_BIG_ENDIAN=1\nU_ENDIAN_CHAR=\"b\"\nfi\nAC_SUBST(U_IS_BIG_ENDIAN)\n\n# Do various POSIX related checks\nU_HAVE_NL_LANGINFO_CODESET=0\nU_NL_LANGINFO_CODESET=-1\nAC_CHECK_FUNC(nl_langinfo,[U_HAVE_NL_LANGINFO=1],[U_HAVE_NL_LANGINFO=0])\ndnl AC_SUBST(U_HAVE_NL_LANGINFO)\nif test $U_HAVE_NL_LANGINFO -eq 1; then\n  AC_CACHE_CHECK([for nl_langinfo's argument to obtain the codeset],\n  ac_cv_nl_langinfo_codeset,\n  [ac_cv_nl_langinfo_codeset=\"unknown\"\n  for a in CODESET _NL_CTYPE_CODESET_NAME; do\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <langinfo.h>]], [[nl_langinfo($a);]])],[ac_cv_nl_langinfo_codeset=\"$a\"; break],[])]\n  done)\n  if test x$ac_cv_nl_langinfo_codeset != xunknown\n  then\n      U_HAVE_NL_LANGINFO_CODESET=1\n      U_NL_LANGINFO_CODESET=$ac_cv_nl_langinfo_codeset\n      if test \"x${ac_cv_nl_langinfo_codeset}\" != \"xCODESET\"\n      then\n        CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DNL_LANGINFO_CODESET=${ac_cv_nl_langinfo_codeset}\"\n      fi\n  else\n      CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_NL_LANGINFO_CODESET=0\"\n  fi\nfi\nAC_SUBST(U_HAVE_NL_LANGINFO_CODESET)\nAC_SUBST(U_NL_LANGINFO_CODESET)\n\n# Namespace support checks\nAC_LANG(C++)\nAC_MSG_CHECKING([for namespace support])\nAC_CACHE_VAL(ac_cv_namespace_ok,\n    [AC_LINK_IFELSE([AC_LANG_PROGRAM([namespace x_version {void f(){}}\n    namespace x = x_version;\n    using namespace x_version;\n    ], [f();])],[ac_cv_namespace_ok=yes],[ac_cv_namespace_ok=no])] )\nAC_MSG_RESULT($ac_cv_namespace_ok)\nif test $ac_cv_namespace_ok = no\nthen\n    AC_MSG_ERROR(Namespace support is required to build ICU.)\nfi\n\nAC_MSG_CHECKING([for properly overriding new and delete])\nU_OVERRIDE_CXX_ALLOCATION=0\nU_HAVE_PLACEMENT_NEW=0\nAC_CACHE_VAL(ac_cv_override_cxx_allocation_ok,\n    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n    class UMemory {\n    public:\n    void *operator new(size_t size) {return malloc(size);}\n    void *operator new[](size_t size) {return malloc(size);}\n    void operator delete(void *p) {free(p);}\n    void operator delete[](void *p) {free(p);}\n    };\n    ]], [])],[ac_cv_override_cxx_allocation_ok=yes],[ac_cv_override_cxx_allocation_ok=no])] )\nAC_MSG_RESULT($ac_cv_override_cxx_allocation_ok)\nif test $ac_cv_override_cxx_allocation_ok = yes\nthen\n    U_OVERRIDE_CXX_ALLOCATION=1\n    AC_MSG_CHECKING([for placement new and delete])\n    AC_CACHE_VAL(ac_cv_override_placement_new_ok,\n        [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n        class UMemory {\n        public:\n        void *operator new(size_t size) {return malloc(size);}\n        void *operator new[](size_t size) {return malloc(size);}\n        void operator delete(void *p) {free(p);}\n        void operator delete[](void *p) {free(p);}\n        void * operator new(size_t, void *ptr) { return ptr; }\n        void operator delete(void *, void *) {}\n        };\n        ]], [])],[ac_cv_override_placement_new_ok=yes],[ac_cv_override_placement_new_ok=no])] )\n    AC_MSG_RESULT($ac_cv_override_placement_new_ok)\n    if test $ac_cv_override_placement_new_ok = yes\n    then\n        U_HAVE_PLACEMENT_NEW=1\n    else\n        CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_PLACEMENT_NEW=0\"\n    fi\nelse\n    CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_OVERRIDE_CXX_ALLOCATION=0\"\nfi\nAC_SUBST(U_OVERRIDE_CXX_ALLOCATION)\nAC_SUBST(U_HAVE_PLACEMENT_NEW)\n\nAC_LANG(C)\nAC_CHECK_FUNC(popen)\nif test x$ac_cv_func_popen = xyes\nthen\n     U_HAVE_POPEN=1\nelse\n     CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_POPEN=0\"\n     U_HAVE_POPEN=0\nfi\nAC_SUBST(U_HAVE_POPEN)\n\nAC_CHECK_FUNC(tzset)\nU_HAVE_TZSET=0\nif test x$ac_cv_func_tzset = xyes\nthen\n    U_TZSET=tzset\n    U_HAVE_TZSET=1\nelse\n    AC_CHECK_FUNC(_tzset)\n    if test x$ac_cv_func__tzset = xyes\n    then\n        U_TZSET=_tzset\n        U_HAVE_TZSET=1\n    else\n      CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_TZSET=0\"\n    fi\nfi\nAC_SUBST(U_HAVE_TZSET)\nAC_SUBST(U_TZSET)\n\nU_HAVE_TZNAME=0\nAC_CACHE_CHECK(for tzname,ac_cv_var_tzname,\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([[#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE\n#endif\n#include <stdlib.h>\n#include <time.h>\n#ifndef tzname /* For SGI.  */\nextern char *tzname[]; /* RS6000 and others reject char **tzname.  */\n#endif]], [atoi(*tzname);])],[ac_cv_var_tzname=yes],[ac_cv_var_tzname=no])])\nif test $ac_cv_var_tzname = yes; then\n  U_TZNAME=tzname\n  U_HAVE_TZNAME=1\nelse\n  AC_CACHE_CHECK(for _tzname,ac_cv_var__tzname,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n  #include <time.h>\n  extern char *_tzname[];]], [atoi(*_tzname);])],[ac_cv_var__tzname=yes],[ac_cv_var__tzname=no])])\n    if test $ac_cv_var__tzname = yes; then\n      U_TZNAME=_tzname\n      U_HAVE_TZNAME=1\n    else\n     CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_TZNAME=0\"\n    fi\nfi\nAC_SUBST(U_HAVE_TZNAME)\nAC_SUBST(U_TZNAME)\n\nAC_CACHE_CHECK(for timezone,ac_cv_var_timezone,\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([#ifndef _XOPEN_SOURCE\n#define _XOPEN_SOURCE\n#endif\n#include <time.h>\n], [[timezone = 1;]])],[ac_cv_var_timezone=yes],[ac_cv_var_timezone=no])])\nU_HAVE_TIMEZONE=0\nif test $ac_cv_var_timezone = yes; then\n  U_TIMEZONE=timezone\n  U_HAVE_TIMEZONE=1\nelse\n  AC_CACHE_CHECK(for __timezone,ac_cv_var___timezone,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <time.h>]], [[__timezone = 1;]])],[ac_cv_var___timezone=yes],[ac_cv_var___timezone=no])])\n  if test $ac_cv_var___timezone = yes; then\n    U_TIMEZONE=__timezone\n    U_HAVE_TIMEZONE=1\n  else\n    AC_CACHE_CHECK(for _timezone,ac_cv_var__timezone,\n    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <time.h>]], [[_timezone = 1;]])],[ac_cv_var__timezone=yes],[ac_cv_var__timezone=no])])\n    if test $ac_cv_var__timezone = yes; then\n      U_TIMEZONE=_timezone\n      U_HAVE_TIMEZONE=1\n    else\n     CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_TIMEZONE=0\"\n    fi\n  fi\nfi\nAC_SUBST(U_HAVE_TIMEZONE)\nAC_SUBST(U_TIMEZONE)\n\nAC_CHECK_FUNC(strtod_l)\nif test x$ac_cv_func_strtod_l = xyes\nthen\n    U_HAVE_STRTOD_L=1\n    AC_CHECK_HEADER(xlocale.h)\n    if test \"$ac_cv_header_xlocale_h\" = yes; then\n      U_HAVE_XLOCALE_H=1\n      CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_STRTOD_L=1 -DU_HAVE_XLOCALE_H=1\"\n    else\n      U_HAVE_XLOCALE_H=0\n      CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_STRTOD_L=1 -DU_HAVE_XLOCALE_H=0\"\n    fi\nelse\n    CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_STRTOD_L=0\"\n    U_HAVE_STRTOD_L=0\nfi\nAC_SUBST(U_HAVE_STRTOD_L)\n\n# Check if C++17 std::string_view is available.\nAC_LANG_PUSH([C++])\nAC_CHECK_TYPE(std::string_view, [], [], [[#include <string_view>]])\nif test \"x$ac_cv_type_std__string_view\" = xyes; then :\n  CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_STRING_VIEW=1\"\nfi\nAC_LANG_POP([C++])\n\n# Checks for typedefs\nAC_CHECK_TYPE(int8_t,signed char)\nAC_CHECK_TYPE(uint8_t,unsigned char)\nAC_CHECK_TYPE(int16_t,signed short)\nAC_CHECK_TYPE(uint16_t,unsigned short)\nAC_CHECK_TYPE(int32_t,signed long)\nAC_CHECK_TYPE(uint32_t,unsigned long)\nAC_CHECK_TYPE(int64_t,signed long long)\nAC_CHECK_TYPE(uint64_t,unsigned long long)\n\nif test $ac_cv_type_int8_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INT8_T=0\"\nfi\n\nif test $ac_cv_type_uint8_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_UINT8_T=0\"\nfi\n\nif test $ac_cv_type_int16_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INT16_T=0\"\nfi\n\nif test $ac_cv_type_uint16_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_UINT16_T=0\"\nfi\n\nif test $ac_cv_type_int32_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INT32_T=0\"\nfi\n\nif test $ac_cv_type_uint32_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_UINT32_T=0\"\nfi\n\nif test $ac_cv_type_int64_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_INT64_T=0\"\nfi\n\nif test $ac_cv_type_uint64_t = no; then\nCONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_UINT64_T=0\"\nfi\n\n# Do various wchar_t related checks\nAC_CHECK_HEADER(wchar.h)\nif test \"$ac_cv_header_wchar_h\" = no\nthen\n    U_HAVE_WCHAR_H=0\n    U_HAVE_WCSCPY=0\n    CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_WCHAR_H=0 -DU_HAVE_WCSCPY=0\"\nelse\n    AC_DEFINE([HAVE_WCHAR_H], [1], [wchar.h was found.])\n    U_HAVE_WCHAR_H=1\n    # Some broken systems have wchar.h but not some of its functions...\n    AC_SEARCH_LIBS(wcscpy, wcs w)\n    if test \"$ac_cv_search_wcscpy\" != no; then\n      U_HAVE_WCSCPY=1\n    else\n      U_HAVE_WCSCPY=0\n      CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_HAVE_WCSCPY=0\"\n    fi\nfi\nAC_SUBST(U_HAVE_WCHAR_H)\nAC_SUBST(U_HAVE_WCSCPY)\n\nAC_CHECK_SIZEOF([wchar_t], 0, [\n#if STDC_HEADERS\n#include <stddef.h>\n#endif\n#include <stdlib.h>\n#if HAVE_WCHAR_H\n#include <string.h>\n#include <wchar.h>\n#endif])\nU_SIZEOF_WCHAR_T=$ac_cv_sizeof_wchar_t\n# We do this check to verify that everything is okay.\nif test $U_SIZEOF_WCHAR_T = 0; then\n    if test $U_HAVE_WCHAR_H=1; then\n       AC_MSG_ERROR(There is wchar.h but the size of wchar_t is 0)\n    fi\nfi\n\nAC_MSG_CHECKING([for UTF-16 string literal support])\nU_CHECK_UTF16_STRING=1\nCHECK_UTF16_STRING_RESULT=\"unknown\"\n\ncase \"${host}\" in\n*-*-aix*|powerpc64-*-linux*)\n    if test \"$GCC\" = no; then\n        OLD_CFLAGS=\"${CFLAGS}\"\n        OLD_CXXFLAGS=\"${CXXFLAGS}\"\n        CFLAGS=\"${CFLAGS} -qutf\"\n        CXXFLAGS=\"${CXXFLAGS} -qutf\"\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[const unsigned short hello[] = u\"hello\";]], [[]])],[U_CHECK_UTF16_STRING=1],[U_CHECK_UTF16_STRING=0])\n        if test \"$U_CHECK_UTF16_STRING\" = 0; then\n            CFLAGS=\"${OLD_CFLAGS}\"\n            CXXFLAGS=\"${OLD_CXXFLAGS}\"\n        else\n            UCONFIG_CXXFLAGS=\"${UCONFIG_CXXFLAGS} -qutf\"\n            CHECK_UTF16_STRING_RESULT=\"-qutf\"\n        fi\n    fi\n    ;;\n*-*-solaris*)\n    if test \"$GCC\" = no; then\n        OLD_CFLAGS=\"${CFLAGS}\"\n        OLD_CXXFLAGS=\"${CXXFLAGS}\"\n        CFLAGS=\"${CFLAGS} -xustr=ascii_utf16_ushort\"\n        CXXFLAGS=\"${CXXFLAGS} -xustr=ascii_utf16_ushort\"\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[const unsigned short hello[] = U\"hello\";]], [[]])],[U_CHECK_UTF16_STRING=1],[U_CHECK_UTF16_STRING=0])\n        if test \"$U_CHECK_UTF16_STRING\" = 0; then\n            CFLAGS=\"${OLD_CFLAGS}\"\n            CXXFLAGS=\"${OLD_CXXFLAGS}\"\n        else\n            CHECK_UTF16_STRING_RESULT=\"-xustr=ascii_utf16_ushort\"\n            UCONFIG_CXXFLAGS=\"${UCONFIG_CXXFLAGS} -xustr=ascii_utf16_ushort\"\n            UCONFIG_CFLAGS=\"${UCONFIG_CFLAGS} -xustr=ascii_utf16_ushort\"\n            # Since we can't detect the availability of this UTF-16 syntax at compile time,\n            # we depend on configure telling us that we can use it.\n            # Since we can't ensure ICU users use -xustr=ascii_utf16_ushort,\n            # we only use this macro within ICU.\n            # If an ICU user uses icu-config, this feature will be enabled.\n            CONFIG_CPPFLAGS=\"${CONFIG_CPPFLAGS} -DU_CHECK_UTF16_STRING=1\"\n            U_CHECK_UTF16_STRING=0\n        fi\n    fi\n    ;;\n*-*-hpux*)\n    if test \"$GCC\" = no; then\n        # The option will be detected at compile time without additional compiler options.\n        CHECK_UTF16_STRING_RESULT=\"available\"\n    fi\n    ;;\n*-*-cygwin)\n    # wchar_t can be used\n    CHECK_UTF16_STRING_RESULT=\"available\"\n    ;;\n*)\n    ;;\nesac\n\n# GCC >= 4.4 supports UTF16 string literals. As of ICU 62, both C and C++ files require them.\nif test \"$CHECK_UTF16_STRING_RESULT\" = \"unknown\"; then\n    if test \"$GCC\" = yes; then\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\nstatic const unsigned short test[] = u\"This is a UTF16 literal string.\";\n        ]], [[]])],[CC_UTF16_STRING=1],[CC_UTF16_STRING=0])\n        if test \"$CC_UTF16_STRING\" = 1; then\n            CHECK_UTF16_STRING_RESULT=\"C only\";\n        fi\n    fi\n    if test \"$GXX\" = yes; then\n        # -Wno-return-type-c-linkage is desired so that stable ICU API is not warned about.\n        AC_LANG_PUSH([C++])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\nstatic const char16_t test[] = u\"This is a UTF16 literal string.\";\n        ]], [[]])],[CXX_UTF16_STRING=1],[CXX_UTF16_STRING=0])\n        AC_LANG_POP([C++])\n        if test \"$CXX_UTF16_STRING\" = 1; then\n            if test \"$CC_UTF16_STRING\" = 1; then\n                CHECK_UTF16_STRING_RESULT=\"available\";\n            else\n                CHECK_UTF16_STRING_RESULT=\"C++ only\";\n            fi\n        fi\n    fi\nfi\nAC_MSG_RESULT($CHECK_UTF16_STRING_RESULT)\n\n# Enable/disable extras\nAC_ARG_ENABLE(extras,\n\t[  --enable-extras         build ICU extras [default=yes]],\n\t[case \"${enableval}\" in\n\t\tyes) extras=true ;;\n\t\tno)  extras=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-extras) ;;\n\t\tesac],\n\textras=true)\nICU_CONDITIONAL(EXTRAS, test \"$extras\" = true)\nAC_ARG_ENABLE(icuio,\n\t[  --enable-icuio          build ICU's icuio library [default=yes]],\n\t[case \"${enableval}\" in\n\t\tyes) icuio=true ;;\n\t\tno)  icuio=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-icuio) ;;\n\t\tesac],\n\ticuio=true)\nICU_CONDITIONAL(ICUIO, test \"$icuio\" = true)\n\n# Enable/disable layoutex\nAC_ARG_ENABLE(layoutex,\n\t[  --enable-layoutex         build ICU's Paragraph Layout library [default=yes].\n            icu-le-hb must be installed via pkg-config. See http://harfbuzz.org],\n\t[case \"${enableval}\" in\n\t\tyes) layoutex=$have_icu_le_hb ;;\n\t\tno)  layoutex=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-layoutex) ;;\n\t\tesac],\n\tlayoutex=$have_icu_le_hb)\nICU_CONDITIONAL(LAYOUTEX, test \"$layoutex\" = true)\n\n# Enable/disable layout\nAC_ARG_ENABLE(layout,\n\t[],\n\t[case \"${enableval}\" in\n\t\tyes) AC_MSG_ERROR(The ICU Layout Engine has been removed.) ;;\n\t\tno)   ;;\n\t\t*) ;;\n\t\tesac],\n\t)\n\n# Enable/disable tools\nAC_ARG_ENABLE(tools,\n\t[  --enable-tools         build ICU's tools [default=yes]],\n\t[case \"${enableval}\" in\n\t\tyes) tools=true ;;\n\t\tno)  tools=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-tools) ;;\n\t\tesac],\n\ttools=true)\nICU_CONDITIONAL(TOOLS, test \"$tools\" = true)\n\n# Enable/disable fuzzer target tests.\nAC_ARG_ENABLE(fuzzer,\n\t[  --enable-fuzzer        build ICU's fuzzer test targets [default=no]],\n\t[case \"${enableval}\" in\n\t\tyes) fuzzer=true ;;\n\t\tno)  fuzzer=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-fuzzer) ;;\n\t\tesac],\n\tfuzzer=false)\nICU_CONDITIONAL(FUZZER, test \"$fuzzer\" = true)\n\nICU_CONDITIONAL(DATA, test \"$tools\" = true || test \"$cross_compiling\" = \"yes\")\n\nAC_ARG_WITH(data-packaging,\n\t[  --with-data-packaging     specify how to package ICU data. Possible values:\n        files    raw files (.res, etc)\n        archive  build a single icudtXX.dat file\n        library  shared library (.dll/.so/etc.)\n        static   static library (.a/.lib/etc.)\n        auto     build shared if possible (default)\n           See http://userguide.icu-project.org/icudata for more info.],\n\t[case \"${withval}\" in\n                files|archive|library) datapackaging=$withval ;;\n\t\tauto) datapackaging=$withval ;;\n\t\tcommon) datapackaging=archive ;;\n\t\tdll) datapackaging=library ;;\n\t\tstatic) datapackaging=static ;;\n\t\t*) AC_MSG_ERROR(bad value ${withval} for --with-data-packaging) ;;\n\t\tesac],\n        [datapackaging=])\n\n# Note:  'thesysconfdir' is an evaluated version, for Man pages, so also for thedatadir, thelibdir, etc..\n# thesysconfdir=`eval echo $sysconfdir`\ndnl# AC_SUBST(thesysconfdir)\ndnl# thelibdir=`test \"x$exec_prefix\" = xNONE && exec_prefix=\"$prefix\"; eval echo $libdir`\ndnl# AC_SUBST(thelibdir)\nthedatadir=`eval echo $datadir`\ndnl# AC_SUBST(thedatadir)\n# Always put raw data files in share/icu/{version}, etc.   Never use lib/icu/{version} for data files.. Actual shared libraries will go in {libdir}.\npkgicudatadir=$datadir\nthepkgicudatadir=$thedatadir\nAC_SUBST(pkgicudatadir)\nAC_SUBST(thepkgicudatadir)\n\ndnl# Shouldn't need the AC_SUBST\n\nif test x\"$datapackaging\" = x -o x\"$datapackaging\" = xauto; then\n\t# default to library\n\tdatapackaging=library\n\tif test \"$ENABLE_STATIC\" = \"YES\"; then\n\t\tif test \"$ENABLE_SHARED\" != \"YES\"; then\n\t\t\tdatapackaging=static\n\t\tfi\n\tfi\nfi\n\ndatapackaging_dir=`eval echo $thedatadir`\"/icu/${VERSION}\"\n\ndatapackaging_msg=\"(No explaination for mode $datapackaging.)\"\n\ndatapackaging_msg_path=\"ICU will look in $datapackaging_dir which is the installation location. Call u_setDataDirectory() or use the ICU_DATA environment variable to override.\"\ndatapackaging_msg_set=\"ICU will use the linked data library. If linked with the stub library located in stubdata/, the application can use udata_setCommonData() or set a data path to override.\"\ndatapackaging_howfound=\"(unknown)\"\n\ncase \"$datapackaging\" in\n    files)\n    DATA_PACKAGING_MODE=files\n    datapackaging_msg=\"ICU data will be stored in individual files.\"\n    datapackaging_howfound=\"$datapackaging_msg_path\"\n    ;;\n    archive)\n    DATA_PACKAGING_MODE=common\n    datapackaging_msg=\"ICU data will be stored in a single .dat file.\"\n    datapackaging_howfound=\"$datapackaging_msg_path\"\n    ;;\n    library)\n    DATA_PACKAGING_MODE=dll\n    datapackaging_msg=\"ICU data will be linked with ICU.\"\n    if test \"$ENABLE_STATIC\" = \"YES\"; then\n        datapackaging_msg=\"$datapackaging_msg A static data library will be built. \"\n    fi\n    if test \"$ENABLE_SHARED\" = \"YES\"; then\n        datapackaging_msg=\"$datapackaging_msg A shared data library will be built. \"\n    fi\n    datapackaging_howfound=\"$datapackaging_msg_set\"\n    ;;\n    static)\n    DATA_PACKAGING_MODE=static\n    datapackaging_msg=\"ICU data will be stored in a static library.\"\n    datapackaging_howfound=\"$datapackaging_msg_set\"\n    ;;\nesac\nAC_SUBST(DATA_PACKAGING_MODE)\n\n# Sets a library suffix\nAC_MSG_CHECKING([for a library suffix to use])\nAC_ARG_WITH(library-suffix,\n\t[  --with-library-suffix=suffix    tag a suffix to the library names [default=]],\n\t[ICULIBSUFFIX=\"${withval}\"],\n\t[ICULIBSUFFIX=])\nmsg=$ICULIBSUFFIX\nif test \"$msg\" = \"\"; then\n    msg=none\nfi\nAC_MSG_RESULT($msg)\nAC_SUBST(ICULIBSUFFIX)\nif test \"$ICULIBSUFFIX\" != \"\"\nthen\n    U_HAVE_LIB_SUFFIX=1\n    ICULIBSUFFIXCNAME=`echo _$ICULIBSUFFIX | sed 's/[^A-Za-z0-9_]/_/g'`\n    UCONFIG_CPPFLAGS=\"${UCONFIG_CPPFLAGS} -DU_HAVE_LIB_SUFFIX=1 -DU_LIB_SUFFIX_C_NAME=${ICULIBSUFFIXCNAME} \"\nelse\n    U_HAVE_LIB_SUFFIX=0\nfi\nAC_SUBST(U_HAVE_LIB_SUFFIX)\nAC_SUBST(ICULIBSUFFIXCNAME)\n\n# Enable/disable tests\nAC_ARG_ENABLE(tests,\n\t[  --enable-tests          build ICU tests [default=yes]],\n\t[case \"${enableval}\" in\n\t\tyes) tests=true ;;\n\t\tno)  tests=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-tests) ;;\n\t\tesac],\n\ttests=true)\nICU_CONDITIONAL(TESTS, test \"$tests\" = true)\n\n# Enable/disable samples\nAC_ARG_ENABLE(samples,\n\t[  --enable-samples        build ICU samples [default=yes]\n\nAdditionally, the variable FORCE_LIBS may be set before calling configure.\nIf set, it will REPLACE any automatic list of libraries.],\n\t[case \"${enableval}\" in\n\t\tyes) samples=true ;;\n\t\tno)  samples=false ;;\n\t\t*) AC_MSG_ERROR(bad value ${enableval} for --enable-samples) ;;\n\t\tesac],\n\tsamples=true)\nICU_CONDITIONAL(SAMPLES, test \"$samples\" = true)\n\nICUDATA_CHAR=$U_ENDIAN_CHAR\n\n# Platform-specific Makefile setup\n# set ICUDATA_CHAR to 'e' for any EBCDIC (which should be big endian) platform.\ncase \"${host}\" in\n\t*-*-solaris*) \tplatform=U_SOLARIS ;;\n\t*-*-linux*|*-*-gnu|*-*-k*bsd*-gnu|*-*-kopensolaris*-gnu)        platform=U_LINUX ;;\n\t*-*-*bsd*|*-*-dragonfly*) \tplatform=U_BSD ;;\n\t*-*-aix*) \tplatform=U_AIX ;;\n\t*-*-hpux*) \tplatform=U_HPUX ;;\n\t*-apple-darwin*|*-apple-rhapsody*)\tplatform=U_DARWIN ;;\n\t*-*-cygwin*)\tplatform=U_CYGWIN ;;\n\t*-*-mingw*)\tplatform=U_MINGW ;;\n\t*-*ibm-openedition*|*-*-os390*)\tplatform=OS390\n\t\t\tif test \"${ICU_ENABLE_ASCII_STRINGS}\" != \"1\"; then\n\t\t\t\tICUDATA_CHAR=\"e\"\n\t\t\tfi ;;\n\t*-*-os400*)\tplatform=OS400\n\t\t\tif test \"${ICU_ENABLE_ASCII_STRINGS}\" != \"1\"; then\n\t\t\t\tICUDATA_CHAR=\"e\"\n\t\t\tfi ;;\n\t*-*-nto*)\tplatform=U_QNX ;;\n\t*-dec-osf*) \tplatform=U_OSF ;;\n\t*-*-beos)\t\tplatform=U_BEOS ;;\n\t*-*-irix*)\t\tplatform=U_IRIX ;;\n\t*-ncr-*)\t\tplatform=U_MPRAS ;;\n\t*) \t\tplatform=U_UNKNOWN_PLATFORM ;;\nesac\nAC_SUBST(ICUDATA_CHAR)\nAC_SUBST(platform)\nplatform_make_fragment_name=\"$icu_cv_host_frag\"\nplatform_make_fragment='$(top_srcdir)/config/'\"$platform_make_fragment_name\"\nAC_SUBST(platform_make_fragment_name)\nAC_SUBST(platform_make_fragment)\n\nif test \"${FORCE_LIBS}\" != \"\"; then\n   echo \" *** Overriding automatically chosen [LIBS=$LIBS], using instead [FORCE_LIBS=${FORCE_LIBS}]\"  1>&6\n   LIBS=${FORCE_LIBS}\nfi\n\n# Now that we're done using CPPFLAGS etc. for tests, we can change it\n# for build.\n\nif test \"${CC}\" = \"clang\"; then\n   CLANGCFLAGS=\"-Qunused-arguments -Wno-parentheses-equality\"\nelse\n   CLANGCFLAGS=\"\"\nfi\n\nif test \"${CXX}\" = \"clang++\"; then\n   CLANGCXXFLAGS=\"-Qunused-arguments -Wno-parentheses-equality\"\n   LIBCXXFLAGS=\"$LIBCXXFLAGS -Wglobal-constructors\"\nelse\n   CLANGCXXFLAGS=\"\"\nfi\n\nCPPFLAGS=\"$CPPFLAGS \\$(THREADSCPPFLAGS)\"\nCFLAGS=\"$CFLAGS \\$(THREADSCFLAGS) $CLANGCFLAGS\"\nCXXFLAGS=\"$CXXFLAGS \\$(THREADSCXXFLAGS) $CLANGCXXFLAGS\"\n\nAC_SUBST(LIBCFLAGS)\nAC_SUBST(LIBCXXFLAGS)\n\n# append all config cppflags\nCPPFLAGS=\"$CPPFLAGS $CONFIG_CPPFLAGS $UCONFIG_CPPFLAGS\"\n\necho \"CPPFLAGS=$CPPFLAGS\"\necho \"CFLAGS=$CFLAGS\"\necho \"CXXFLAGS=$CXXFLAGS\"\n\n\n# output the Makefiles\nAC_CONFIG_FILES([icudefs.mk \\\n\t\tMakefile \\\n\t\tdata/pkgdataMakefile \\\n\t\tconfig/Makefile.inc \\\n\t\tconfig/icu.pc \\\n\t\tconfig/pkgdataMakefile \\\n\t\tdata/Makefile \\\n\t\tstubdata/Makefile \\\n\t\tcommon/Makefile \\\n\t\ti18n/Makefile \\\n\t\tlayoutex/Makefile \\\n\t\tio/Makefile \\\n\t\textra/Makefile \\\n\t\textra/uconv/Makefile \\\n\t\textra/uconv/pkgdataMakefile \\\n\t\textra/scrptrun/Makefile \\\n\t\ttools/Makefile \\\n\t\ttools/ctestfw/Makefile \\\n\t\ttools/toolutil/Makefile \\\n\t\ttools/makeconv/Makefile \\\n\t\ttools/genrb/Makefile \\\n\t\ttools/genccode/Makefile \\\n\t\ttools/gencmn/Makefile \\\n\t\ttools/gencnval/Makefile \\\n\t\ttools/gendict/Makefile \\\n\t\ttools/gentest/Makefile \\\n\t\ttools/gennorm2/Makefile \\\n\t\ttools/genbrk/Makefile \\\n\t\ttools/gensprep/Makefile \\\n\t\ttools/icuinfo/Makefile \\\n\t\ttools/icupkg/Makefile \\\n\t\ttools/icuswap/Makefile \\\n\t\ttools/pkgdata/Makefile \\\n\t\ttools/tzcode/Makefile \\\n\t\ttools/gencfu/Makefile \\\n\t\ttools/escapesrc/Makefile \\\n\t\ttest/Makefile \\\n\t\ttest/compat/Makefile \\\n\t\ttest/testdata/Makefile \\\n\t\ttest/testdata/pkgdataMakefile \\\n\t\ttest/hdrtst/Makefile \\\n\t\ttest/intltest/Makefile \\\n\t\ttest/cintltst/Makefile \\\n\t\ttest/iotest/Makefile \\\n\t\ttest/letest/Makefile \\\n\t\ttest/perf/Makefile \\\n\t\ttest/perf/collationperf/Makefile \\\n\t\ttest/perf/collperf/Makefile \\\n\t\ttest/perf/collperf2/Makefile \\\n\t\ttest/perf/dicttrieperf/Makefile \\\n\t\ttest/perf/ubrkperf/Makefile \\\n\t\ttest/perf/charperf/Makefile \\\n\t\ttest/perf/convperf/Makefile \\\n\t\ttest/perf/normperf/Makefile \\\n\t\ttest/perf/DateFmtPerf/Makefile \\\n\t\ttest/perf/howExpensiveIs/Makefile \\\n\t\ttest/perf/strsrchperf/Makefile \\\n\t\ttest/perf/unisetperf/Makefile \\\n\t\ttest/perf/usetperf/Makefile \\\n\t\ttest/perf/ustrperf/Makefile \\\n\t\ttest/perf/utfperf/Makefile \\\n\t\ttest/perf/utrie2perf/Makefile \\\n\t\ttest/perf/leperf/Makefile \\\n\t\ttest/fuzzer/Makefile \\\n\t\tsamples/Makefile samples/date/Makefile \\\n\t\tsamples/cal/Makefile samples/layout/Makefile])\nAC_OUTPUT\n\nif test -z \"$PYTHON\";\nthen\n    echo \"\" > data/rules.mk\n    echo \"\" > test/testdata/rules.mk\nelse\n    if test -f \"$srcdir/data/locales/root.txt\";\n    then\n        echo \"Spawning Python to generate data/rules.mk...\"\n        PYTHONPATH=\"$srcdir/python\" \\\n            $PYTHON -m icutools.databuilder \\\n            --mode gnumake \\\n            --seqmode parallel \\\n            --src_dir \"$srcdir/data\" \\\n            --filter_file \"$ICU_DATA_FILTER_FILE\" \\\n            $ICU_DATA_BUILDTOOL_OPTS \\\n            > data/rules.mk\n        if test \"$?\" != \"0\"; then\n            AC_MSG_ERROR(Python failed to run; see above error.)\n        fi\n    else\n      echo \"Not rebuilding data/rules.mk, assuming prebuilt data in data/in\"\n      touch data/rules.mk\n    fi\n    echo \"Spawning Python to generate test/testdata/rules.mk...\"\n    PYTHONPATH=\"$srcdir/python\" \\\n        $PYTHON -m icutools.databuilder \\\n        --mode gnumake \\\n        --seqmode parallel \\\n        --src_dir \"$srcdir/test/testdata\" \\\n        > test/testdata/rules.mk\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR(Python failed to run; see above error.)\n    fi\nfi\n\necho\necho \"ICU for C/C++ $VERSION is ready to be built.\"\necho \"=== Important Notes: ===\"\n\necho \"Data Packaging: $datapackaging\"\necho \" This means: $datapackaging_msg\"\necho \" To locate data: $datapackaging_howfound\"\n\nif test -n \"`$U_MAKE -v 2>&1 | grep '^GNU Make'`\"; then\necho \"Building ICU: Use a GNU make such as $U_MAKE to build ICU.\"\nelse\necho \"** WARNING: $U_MAKE may not be GNU make.\"\necho \"This may cause ICU to fail to build. Please make sure that GNU make\"\necho \"is in your PATH so that the configure script can detect its location.\"\nfi\nif test \"x$AR\" = \"xfalse\"; then\n  echo \"*** WARNING: Archiver ar not found. Set AR= or fix PATH. Some builds (such as static) may fail.\"\nfi\n\nAC_MSG_CHECKING([the version of \"$U_MAKE\"])\nif \"$U_MAKE\" -f \"$srcdir/config/gmakever.mk\" PLATFORM=\"$platform\"; then\nAC_MSG_RESULT([ok])\nelse\nAC_MSG_RESULT([too old or test failed - try upgrading GNU Make])\nfi\n\nAC_SUBST(UCONFIG_CPPFLAGS)\nif test -n \"$UCONFIG_CPPFLAGS\"; then\n   HDRFILE=\"uconfig.h.prepend\"\n   echo \"*** WARNING: You must set the following flags before code compiled against this ICU will function properly:\"\n   echo\n   echo \"   ${UCONFIG_CPPFLAGS}\"\n   echo\n   echo 'The recommended way to do this is to prepend the following lines to source/common/unicode/uconfig.h or #include them near the top of that file.'\n   echo \"Creating the file ${HDRFILE}\"\n   echo\n   echo '---------------   ' \"${HDRFILE}\"\n   echo > \"${HDRFILE}\"\n   echo '/* ICU customizations: put these lines at the top of uconfig.h */' >> \"${HDRFILE}\"\n   echo >> \"${HDRFILE}\"\n   for flag in ${UCONFIG_CPPFLAGS};\n   do\n        echo \" /* $flag */\" >> \"${HDRFILE}\"\n        case \"${flag}\" in\n        -D*=*)\n          [ \\echo \"${flag}\" | sed -n 's%-D\\([^=]*\\)=%#define \\1 %p' >> \"${HDRFILE}\" ]\n          \\echo >> \"${HDRFILE}\"\n          ;;\n        -D*)\n          [ \\echo \"${flag}\" | sed -n 's%-D\\([^=]*\\)%#define \\1 %p' >> \"${HDRFILE}\" ]\n          \\echo >> \"${HDRFILE}\"\n          ;;\n        *)\n          \\echo \"/*  Not sure how to handle this argument: ${flag} */\" >> \"${HDRFILE}\"\n          \\echo >> \"${HDRFILE}\"\n          ;;\n        esac\n   done\n   cat \"${HDRFILE}\"\n   \\echo  \"/* End of ${HDRFILE} ------------ */\" >> \"${HDRFILE}\"\n   echo >> \"${HDRFILE}\"\n   echo '--------------- end ' \"${HDRFILE}\"\nfi\n\nAC_SUBST(UCONFIG_CFLAGS)\nif test -n \"$UCONFIG_CFLAGS\"; then\n   echo \"C   apps may want to build with CFLAGS   = ${UCONFIG_CFLAGS}\"\nfi\nAC_SUBST(UCONFIG_CXXFLAGS)\nif test -n \"$UCONFIG_CXXFLAGS\"; then\n   echo \"C++ apps may want to build with CXXFLAGS = ${UCONFIG_CXXFLAGS}\"\nfi\n\nif test \"$tools\" = false;\nthen\n        echo \"## Note: you have disabled ICU's tools. This ICU cannot build its own data or tests.\"\n        echo \"## Expect build failures in the 'data', 'test', and other directories.\"\nfi\n\nif test -z \"$PYTHON\";\nthen\n    echo \"** Note: Python not found. You will not be able to build data from source or run tests.\"\nfi\n\n$as_unset _CXX_CXXSUFFIX\n",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/common/putil.cpp": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)\n*\n*   Date        Name        Description\n*   04/14/97    aliu        Creation.\n*   04/24/97    aliu        Added getDefaultDataDirectory() and\n*                            getDefaultLocaleID().\n*   04/28/97    aliu        Rewritten to assume Unix and apply general methods\n*                            for assumed case.  Non-UNIX platforms must be\n*                            special-cased.  Rewrote numeric methods dealing\n*                            with NaN and Infinity to be platform independent\n*                             over all IEEE 754 platforms.\n*   05/13/97    aliu        Restored sign of timezone\n*                            (semantics are hours West of GMT)\n*   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,\n*                             nextDouble..\n*   07/22/98    stephen     Added remainder, max, min, trunc\n*   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity\n*   08/24/98    stephen     Added longBitsFromDouble\n*   09/08/98    stephen     Minor changes for Mac Port\n*   03/02/99    stephen     Removed openFile().  Added AS400 support.\n*                            Fixed EBCDIC tables\n*   04/15/99    stephen     Converted to C.\n*   06/28/99    stephen     Removed mutex locking in u_isBigEndian().\n*   08/04/99    jeffrey R.  Added OS/2 changes\n*   11/15/99    helena      Integrated S/390 IEEE support.\n*   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID\n*   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage\n*   01/03/08    Steven L.   Fake Time Support\n******************************************************************************\n*/\n\n// Defines _XOPEN_SOURCE for access to POSIX functions.\n// Must be before any other #includes.\n#include \"uposixdefs.h\"\n\n// First, the platform type. Need this for U_PLATFORM.\n#include \"unicode/platform.h\"\n\n#if U_PLATFORM == U_PF_MINGW && defined __STRICT_ANSI__\n/* tzset isn't defined in strict ANSI on MinGW. */\n#undef __STRICT_ANSI__\n#endif\n\n/*\n * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.\n */\n#include <time.h>\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#include <sys/time.h>\n#endif\n\n/* include the rest of the ICU headers */\n#include \"unicode/putil.h\"\n#include \"unicode/ustring.h\"\n#include \"putilimp.h\"\n#include \"uassert.h\"\n#include \"umutex.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"locmap.h\"\n#include \"ucln_cmn.h\"\n#include \"charstr.h\"\n\n/* Include standard headers. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <locale.h>\n#include <float.h>\n\n#ifndef U_COMMON_IMPLEMENTATION\n#error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu\n#endif\n\n\n/* include system headers */\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /*\n     * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.\n     * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)\n     * to use native APIs as much as possible?\n     */\n#ifndef WIN32_LEAN_AND_MEAN\n#   define WIN32_LEAN_AND_MEAN\n#endif\n#   define VC_EXTRALEAN\n#   define NOUSER\n#   define NOSERVICE\n#   define NOIME\n#   define NOMCX\n#   include <windows.h>\n#   include \"unicode/uloc.h\"\n#   include \"wintz.h\"\n#elif U_PLATFORM == U_PF_OS400\n#   include <float.h>\n#   include <qusec.h>       /* error code structure */\n#   include <qusrjobi.h>\n#   include <qliept.h>      /* EPT_CALL macro  - this include must be after all other \"QSYSINCs\" */\n#   include <mih/testptr.h> /* For uprv_maximumPtr */\n#elif U_PLATFORM == U_PF_OS390\n#   include \"unicode/ucnv.h\"   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */\n#elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS\n#   include <limits.h>\n#   include <unistd.h>\n#   if U_PLATFORM == U_PF_SOLARIS\n#       ifndef _XPG4_2\n#           define _XPG4_2\n#       endif\n#   endif\n#elif U_PLATFORM == U_PF_QNX\n#   include <sys/neutrino.h>\n#endif\n\n/*\n * Only include langinfo.h if we have a way to get the codeset. If we later\n * depend on more feature, we can test on U_HAVE_NL_LANGINFO.\n *\n */\n\n#if U_HAVE_NL_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n/**\n * Simple things (presence of functions, etc) should just go in configure.in and be added to\n * icucfg.h via autoheader.\n */\n#if U_PLATFORM_IMPLEMENTS_POSIX\n#   if U_PLATFORM == U_PF_OS400\n#    define HAVE_DLFCN_H 0\n#    define HAVE_DLOPEN 0\n#   else\n#   ifndef HAVE_DLFCN_H\n#    define HAVE_DLFCN_H 1\n#   endif\n#   ifndef HAVE_DLOPEN\n#    define HAVE_DLOPEN 1\n#   endif\n#   endif\n#   ifndef HAVE_GETTIMEOFDAY\n#    define HAVE_GETTIMEOFDAY 1\n#   endif\n#else\n#   define HAVE_DLFCN_H 0\n#   define HAVE_DLOPEN 0\n#   define HAVE_GETTIMEOFDAY 0\n#endif\n\nU_NAMESPACE_USE\n\n/* Define the extension for data files, again... */\n#define DATA_TYPE \"dat\"\n\n/* Leave this copyright notice here! */\nstatic const char copyright[] = U_COPYRIGHT_STRING;\n\n/* floating point implementations ------------------------------------------- */\n\n/* We return QNAN rather than SNAN*/\n#define SIGN 0x80000000U\n\n/* Make it easy to define certain types of constants */\ntypedef union {\n    int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */\n    double d64;\n} BitPatternConversion;\nstatic const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };\nstatic const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };\n\n/*---------------------------------------------------------------------------\n  Platform utilities\n  Our general strategy is to assume we're on a POSIX platform.  Platforms which\n  are non-POSIX must declare themselves so.  The default POSIX implementation\n  will sometimes work for non-POSIX platforms as well (e.g., the NaN-related\n  functions).\n  ---------------------------------------------------------------------------*/\n\n#if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400\n#   undef U_POSIX_LOCALE\n#else\n#   define U_POSIX_LOCALE    1\n#endif\n\n/*\n    WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble\n    can't be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).\n*/\n#if !IEEE_754\nstatic char*\nu_topNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)d;\n#else\n    return (char*)(d + 1) - n;\n#endif\n}\n\nstatic char*\nu_bottomNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)(d + 1) - n;\n#else\n    return (char*)d;\n#endif\n}\n#endif   /* !IEEE_754 */\n\n#if IEEE_754\nstatic UBool\nu_signBit(double d) {\n    uint8_t hiByte;\n#if U_IS_BIG_ENDIAN\n    hiByte = *(uint8_t *)&d;\n#else\n    hiByte = *(((uint8_t *)&d) + sizeof(double) - 1);\n#endif\n    return (hiByte & 0x80) != 0;\n}\n#endif\n\n\n\n#if defined (U_DEBUG_FAKETIME)\n/* Override the clock to test things without having to move the system clock.\n * Assumes POSIX gettimeofday() will function\n */\nUDate fakeClock_t0 = 0; /** Time to start the clock from **/\nUDate fakeClock_dt = 0; /** Offset (fake time - real time) **/\nUBool fakeClock_set = FALSE; /** True if fake clock has spun up **/\n\nstatic UDate getUTCtime_real() {\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n}\n\nstatic UDate getUTCtime_fake() {\n    static UMutex fakeClockMutex;\n    umtx_lock(&fakeClockMutex);\n    if(!fakeClock_set) {\n        UDate real = getUTCtime_real();\n        const char *fake_start = getenv(\"U_FAKETIME_START\");\n        if((fake_start!=NULL) && (fake_start[0]!=0)) {\n            sscanf(fake_start,\"%lf\",&fakeClock_t0);\n            fakeClock_dt = fakeClock_t0 - real;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\\n\"\n                    \"env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\\n\",\n                    fakeClock_t0, fake_start, fakeClock_dt, real);\n        } else {\n          fakeClock_dt = 0;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\\n\"\n                    \"Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\\n\");\n        }\n        fakeClock_set = TRUE;\n    }\n    umtx_unlock(&fakeClockMutex);\n\n    return getUTCtime_real() + fakeClock_dt;\n}\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\ntypedef union {\n    int64_t int64;\n    FILETIME fileTime;\n} FileTimeConversion;   /* This is like a ULARGE_INTEGER */\n\n/* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */\n#define EPOCH_BIAS  INT64_C(116444736000000000)\n#define HECTONANOSECOND_PER_MILLISECOND   10000\n\n#endif\n\n/*---------------------------------------------------------------------------\n  Universal Implementations\n  These are designed to work on all platforms.  Try these, and if they\n  don't work on your platform, then special case your platform with new\n  implementations.\n---------------------------------------------------------------------------*/\n\nU_CAPI UDate U_EXPORT2\nuprv_getUTCtime()\n{\n#if defined(U_DEBUG_FAKETIME)\n    return getUTCtime_fake(); /* Hook for overriding the clock */\n#else\n    return uprv_getRawUTCtime();\n#endif\n}\n\n/* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/\nU_CAPI UDate U_EXPORT2\nuprv_getRawUTCtime()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n\n    FileTimeConversion winTime;\n    GetSystemTimeAsFileTime(&winTime.fileTime);\n    return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);\n#else\n\n#if HAVE_GETTIMEOFDAY\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n#else\n    time_t epochtime;\n    time(&epochtime);\n    return (UDate)epochtime * U_MILLIS_PER_SECOND;\n#endif\n\n#endif\n}\n\n/*-----------------------------------------------------------------------------\n  IEEE 754\n  These methods detect and return NaN and infinity values for doubles\n  conforming to IEEE 754.  Platforms which support this standard include X86,\n  Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.\n  If this doesn't work on your platform, you have non-IEEE floating-point, and\n  will need to code your own versions.  A naive implementation is to return 0.0\n  for getNaN and getInfinity, and false for isNaN and isInfinite.\n  ---------------------------------------------------------------------------*/\n\nU_CAPI UBool U_EXPORT2\nuprv_isNaN(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) > gInf.i64);\n\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits & 0x7F080000L) == 0x7F080000L) &&\n      (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return number != number;\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isInfinite(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is exactly 0x7FF0000000000000U. */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) == gInf.i64);\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits  & ~SIGN) == 0x70FF0000L) && (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return number == (2.0 * number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isPositiveInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number > 0 && uprv_isInfinite(number));\n#else\n    return uprv_isInfinite(number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isNegativeInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number < 0 && uprv_isInfinite(number));\n\n#else\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    return((highBits & SIGN) && uprv_isInfinite(number));\n\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getNaN()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gNan.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getInfinity()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gInf.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_floor(double x)\n{\n    return floor(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_ceil(double x)\n{\n    return ceil(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_round(double x)\n{\n    return uprv_floor(x + 0.5);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fabs(double x)\n{\n    return fabs(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_modf(double x, double* y)\n{\n    return modf(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmod(double x, double y)\n{\n    return fmod(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow(double x, double y)\n{\n    /* This is declared as \"double pow(double x, double y)\" */\n    return pow(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow10(int32_t x)\n{\n    return pow(10.0, (double)x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmax(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(x))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? x : y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmin(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(y))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? y : x);\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_add32_overflow(int32_t a, int32_t b, int32_t* res) {\n    // NOTE: Some compilers (GCC, Clang) have primitives available, like __builtin_add_overflow.\n    // This function could be optimized by calling one of those primitives.\n    auto a64 = static_cast<int64_t>(a);\n    auto b64 = static_cast<int64_t>(b);\n    int64_t res64 = a64 + b64;\n    *res = static_cast<int32_t>(res64);\n    return res64 != *res;\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_mul32_overflow(int32_t a, int32_t b, int32_t* res) {\n    // NOTE: Some compilers (GCC, Clang) have primitives available, like __builtin_mul_overflow.\n    // This function could be optimized by calling one of those primitives.\n    auto a64 = static_cast<int64_t>(a);\n    auto b64 = static_cast<int64_t>(b);\n    int64_t res64 = a64 * b64;\n    *res = static_cast<int32_t>(res64);\n    return res64 != *res;\n}\n\n/**\n * Truncates the given double.\n * trunc(3.3) = 3.0, trunc (-3.3) = -3.0\n * This is different than calling floor() or ceil():\n * floor(3.3) = 3, floor(-3.3) = -4\n * ceil(3.3) = 4, ceil(-3.3) = -3\n */\nU_CAPI double U_EXPORT2\nuprv_trunc(double d)\n{\n#if IEEE_754\n    /* handle error cases*/\n    if(uprv_isNaN(d))\n        return uprv_getNaN();\n    if(uprv_isInfinite(d))\n        return uprv_getInfinity();\n\n    if(u_signBit(d))    /* Signbit() picks up -0.0;  d<0 does not. */\n        return ceil(d);\n    else\n        return floor(d);\n\n#else\n    return d >= 0 ? floor(d) : ceil(d);\n\n#endif\n}\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n */\nU_CAPI double U_EXPORT2\nuprv_maxMantissa(void)\n{\n    return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;\n}\n\nU_CAPI double U_EXPORT2\nuprv_log(double d)\n{\n    return log(d);\n}\n\nU_CAPI void * U_EXPORT2\nuprv_maximumPtr(void * base)\n{\n#if U_PLATFORM == U_PF_OS400\n    /*\n     * With the provided function we should never be out of range of a given segment\n     * (a traditional/typical segment that is).  Our segments have 5 bytes for the\n     * id and 3 bytes for the offset.  The key is that the casting takes care of\n     * only retrieving the offset portion minus x1000.  Hence, the smallest offset\n     * seen in a program is x001000 and when casted to an int would be 0.\n     * That's why we can only add 0xffefff.  Otherwise, we would exceed the segment.\n     *\n     * Currently, 16MB is the current addressing limitation on i5/OS if the activation is\n     * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).\n     * This function determines the activation based on the pointer that is passed in and\n     * calculates the appropriate maximum available size for\n     * each pointer type (TERASPACE and non-TERASPACE)\n     *\n     * Unlike other operating systems, the pointer model isn't determined at\n     * compile time on i5/OS.\n     */\n    if ((base != NULL) && (_TESTPTR(base, _C_TERASPACE_CHECK))) {\n        /* if it is a TERASPACE pointer the max is 2GB - 4k */\n        return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));\n    }\n    /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */\n    return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));\n\n#else\n    return U_MAX_PTR(base);\n#endif\n}\n\n/*---------------------------------------------------------------------------\n  Platform-specific Implementations\n  Try these, and if they don't work on your platform, then special case your\n  platform with new implementations.\n  ---------------------------------------------------------------------------*/\n\n/* Generic time zone layer -------------------------------------------------- */\n\n/* Time zone utilities */\nU_CAPI void U_EXPORT2\nuprv_tzset()\n{\n#if defined(U_TZSET)\n    U_TZSET();\n#else\n    /* no initialization*/\n#endif\n}\n\nU_CAPI int32_t U_EXPORT2\nuprv_timezone()\n{\n#ifdef U_TIMEZONE\n    return U_TIMEZONE;\n#else\n    time_t t, t1, t2;\n    struct tm tmrec;\n    int32_t tdiff = 0;\n\n    time(&t);\n    uprv_memcpy( &tmrec, localtime(&t), sizeof(tmrec) );\n#if U_PLATFORM != U_PF_IPHONE\n    UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/\n#endif\n    t1 = mktime(&tmrec);                 /* local time in seconds*/\n    uprv_memcpy( &tmrec, gmtime(&t), sizeof(tmrec) );\n    t2 = mktime(&tmrec);                 /* GMT (or UTC) in seconds*/\n    tdiff = t2 - t1;\n\n#if U_PLATFORM != U_PF_IPHONE\n    /* imitate NT behaviour, which returns same timezone offset to GMT for\n       winter and summer.\n       This does not work on all platforms. For instance, on glibc on Linux\n       and on Mac OS 10.5, tdiff calculated above remains the same\n       regardless of whether DST is in effect or not. iOS is another\n       platform where this does not work. Linux + glibc and Mac OS 10.5\n       have U_TIMEZONE defined so that this code is not reached.\n    */\n    if (dst_checked)\n        tdiff += 3600;\n#endif\n    return tdiff;\n#endif\n}\n\n/* Note that U_TZNAME does *not* have to be tzname, but if it is,\n   some platforms need to have it declared here. */\n\n#if defined(U_TZNAME) && (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED)\n/* RS6000 and others reject char **tzname.  */\nextern U_IMPORT char *U_TZNAME[];\n#endif\n\n#if !UCONFIG_NO_FILE_IO && ((U_PLATFORM_IS_DARWIN_BASED && (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)\n/* These platforms are likely to use Olson timezone IDs. */\n/* common targets of the symbolic link at TZDEFAULT are:\n * \"/usr/share/zoneinfo/<olsonID>\" default, older Linux distros, macOS to 10.12\n * \"../usr/share/zoneinfo/<olsonID>\" newer Linux distros: Red Hat Enterprise Linux 7, Ubuntu 16, SuSe Linux 12\n * \"/usr/share/lib/zoneinfo/<olsonID>\" Solaris\n * \"../usr/share/lib/zoneinfo/<olsonID>\" Solaris\n * \"/var/db/timezone/zoneinfo/<olsonID>\" macOS 10.13\n * To avoid checking lots of paths, just check that the target path\n * before the <olsonID> ends with \"/zoneinfo/\", and the <olsonID> is valid.\n */\n\n#define CHECK_LOCALTIME_LINK 1\n#if U_PLATFORM_IS_DARWIN_BASED\n#include <tzfile.h>\n#define TZZONEINFO      (TZDIR \"/\")\n#elif U_PLATFORM == U_PF_SOLARIS\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/lib/zoneinfo/\"\n#define TZ_ENV_CHECK    \"localtime\"\n#else\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/zoneinfo/\"\n#endif\n#define TZZONEINFOTAIL  \"/zoneinfo/\"\n#if U_HAVE_DIRENT_H\n#define TZFILE_SKIP     \"posixrules\" /* tz file to skip when searching. */\n/* Some Linux distributions have 'localtime' in /usr/share/zoneinfo\n   symlinked to /etc/localtime, which makes searchForTZFile return\n   'localtime' when it's the first match. */\n#define TZFILE_SKIP2    \"localtime\"\n#define SEARCH_TZFILE\n#include <dirent.h>  /* Needed to search through system timezone files */\n#endif\nstatic char gTimeZoneBuffer[PATH_MAX];\nstatic char *gTimeZoneBufferPtr = NULL;\n#endif\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#define isNonDigit(ch) (ch < '0' || '9' < ch)\nstatic UBool isValidOlsonID(const char *id) {\n    int32_t idx = 0;\n\n    /* Determine if this is something like Iceland (Olson ID)\n    or AST4ADT (non-Olson ID) */\n    while (id[idx] && isNonDigit(id[idx]) && id[idx] != ',') {\n        idx++;\n    }\n\n    /* If we went through the whole string, then it might be okay.\n    The timezone is sometimes set to \"CST-7CDT\", \"CST6CDT5,J129,J131/19:30\",\n    \"GRNLNDST3GRNLNDDT\" or similar, so we cannot use it.\n    The rest of the time it could be an Olson ID. George */\n    return (UBool)(id[idx] == 0\n        || uprv_strcmp(id, \"PST8PDT\") == 0\n        || uprv_strcmp(id, \"MST7MDT\") == 0\n        || uprv_strcmp(id, \"CST6CDT\") == 0\n        || uprv_strcmp(id, \"EST5EDT\") == 0);\n}\n\n/* On some Unix-like OS, 'posix' subdirectory in\n   /usr/share/zoneinfo replicates the top-level contents. 'right'\n   subdirectory has the same set of files, but individual files\n   are different from those in the top-level directory or 'posix'\n   because 'right' has files for TAI (Int'l Atomic Time) while 'posix'\n   has files for UTC.\n   When the first match for /etc/localtime is in either of them\n   (usually in posix because 'right' has different file contents),\n   or TZ environment variable points to one of them, createTimeZone\n   fails because, say, 'posix/America/New_York' is not an Olson\n   timezone id ('America/New_York' is). So, we have to skip\n   'posix/' and 'right/' at the beginning. */\nstatic void skipZoneIDPrefix(const char** id) {\n    if (uprv_strncmp(*id, \"posix/\", 6) == 0\n        || uprv_strncmp(*id, \"right/\", 6) == 0)\n    {\n        *id += 6;\n    }\n}\n#endif\n\n#if defined(U_TZNAME) && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)\ntypedef struct OffsetZoneMapping {\n    int32_t offsetSeconds;\n    int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/\n    const char *stdID;\n    const char *dstID;\n    const char *olsonID;\n} OffsetZoneMapping;\n\nenum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };\n\n/*\nThis list tries to disambiguate a set of abbreviated timezone IDs and offsets\nand maps it to an Olson ID.\nBefore adding anything to this list, take a look at\nicu/source/tools/tzcode/tz.alias\nSometimes no daylight savings (0) is important to define due to aliases.\nThis list can be tested with icu/source/test/compat/tzone.pl\nMore values could be added to daylightType to increase precision.\n*/\nstatic const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {\n    {-45900, 2, \"CHAST\", \"CHADT\", \"Pacific/Chatham\"},\n    {-43200, 1, \"PETT\", \"PETST\", \"Asia/Kamchatka\"},\n    {-43200, 2, \"NZST\", \"NZDT\", \"Pacific/Auckland\"},\n    {-43200, 1, \"ANAT\", \"ANAST\", \"Asia/Anadyr\"},\n    {-39600, 1, \"MAGT\", \"MAGST\", \"Asia/Magadan\"},\n    {-37800, 2, \"LHST\", \"LHST\", \"Australia/Lord_Howe\"},\n    {-36000, 2, \"EST\", \"EST\", \"Australia/Sydney\"},\n    {-36000, 1, \"SAKT\", \"SAKST\", \"Asia/Sakhalin\"},\n    {-36000, 1, \"VLAT\", \"VLAST\", \"Asia/Vladivostok\"},\n    {-34200, 2, \"CST\", \"CST\", \"Australia/South\"},\n    {-32400, 1, \"YAKT\", \"YAKST\", \"Asia/Yakutsk\"},\n    {-32400, 1, \"CHOT\", \"CHOST\", \"Asia/Choibalsan\"},\n    {-31500, 2, \"CWST\", \"CWST\", \"Australia/Eucla\"},\n    {-28800, 1, \"IRKT\", \"IRKST\", \"Asia/Irkutsk\"},\n    {-28800, 1, \"ULAT\", \"ULAST\", \"Asia/Ulaanbaatar\"},\n    {-28800, 2, \"WST\", \"WST\", \"Australia/West\"},\n    {-25200, 1, \"HOVT\", \"HOVST\", \"Asia/Hovd\"},\n    {-25200, 1, \"KRAT\", \"KRAST\", \"Asia/Krasnoyarsk\"},\n    {-21600, 1, \"NOVT\", \"NOVST\", \"Asia/Novosibirsk\"},\n    {-21600, 1, \"OMST\", \"OMSST\", \"Asia/Omsk\"},\n    {-18000, 1, \"YEKT\", \"YEKST\", \"Asia/Yekaterinburg\"},\n    {-14400, 1, \"SAMT\", \"SAMST\", \"Europe/Samara\"},\n    {-14400, 1, \"AMT\", \"AMST\", \"Asia/Yerevan\"},\n    {-14400, 1, \"AZT\", \"AZST\", \"Asia/Baku\"},\n    {-10800, 1, \"AST\", \"ADT\", \"Asia/Baghdad\"},\n    {-10800, 1, \"MSK\", \"MSD\", \"Europe/Moscow\"},\n    {-10800, 1, \"VOLT\", \"VOLST\", \"Europe/Volgograd\"},\n    {-7200, 0, \"EET\", \"CEST\", \"Africa/Tripoli\"},\n    {-7200, 1, \"EET\", \"EEST\", \"Europe/Athens\"}, /* Conflicts with Africa/Cairo */\n    {-7200, 1, \"IST\", \"IDT\", \"Asia/Jerusalem\"},\n    {-3600, 0, \"CET\", \"WEST\", \"Africa/Algiers\"},\n    {-3600, 2, \"WAT\", \"WAST\", \"Africa/Windhoek\"},\n    {0, 1, \"GMT\", \"IST\", \"Europe/Dublin\"},\n    {0, 1, \"GMT\", \"BST\", \"Europe/London\"},\n    {0, 0, \"WET\", \"WEST\", \"Africa/Casablanca\"},\n    {0, 0, \"WET\", \"WET\", \"Africa/El_Aaiun\"},\n    {3600, 1, \"AZOT\", \"AZOST\", \"Atlantic/Azores\"},\n    {3600, 1, \"EGT\", \"EGST\", \"America/Scoresbysund\"},\n    {10800, 1, \"PMST\", \"PMDT\", \"America/Miquelon\"},\n    {10800, 2, \"UYT\", \"UYST\", \"America/Montevideo\"},\n    {10800, 1, \"WGT\", \"WGST\", \"America/Godthab\"},\n    {10800, 2, \"BRT\", \"BRST\", \"Brazil/East\"},\n    {12600, 1, \"NST\", \"NDT\", \"America/St_Johns\"},\n    {14400, 1, \"AST\", \"ADT\", \"Canada/Atlantic\"},\n    {14400, 2, \"AMT\", \"AMST\", \"America/Cuiaba\"},\n    {14400, 2, \"CLT\", \"CLST\", \"Chile/Continental\"},\n    {14400, 2, \"FKT\", \"FKST\", \"Atlantic/Stanley\"},\n    {14400, 2, \"PYT\", \"PYST\", \"America/Asuncion\"},\n    {18000, 1, \"CST\", \"CDT\", \"America/Havana\"},\n    {18000, 1, \"EST\", \"EDT\", \"US/Eastern\"}, /* Conflicts with America/Grand_Turk */\n    {21600, 2, \"EAST\", \"EASST\", \"Chile/EasterIsland\"},\n    {21600, 0, \"CST\", \"MDT\", \"Canada/Saskatchewan\"},\n    {21600, 0, \"CST\", \"CDT\", \"America/Guatemala\"},\n    {21600, 1, \"CST\", \"CDT\", \"US/Central\"}, /* Conflicts with Mexico/General */\n    {25200, 1, \"MST\", \"MDT\", \"US/Mountain\"}, /* Conflicts with Mexico/BajaSur */\n    {28800, 0, \"PST\", \"PST\", \"Pacific/Pitcairn\"},\n    {28800, 1, \"PST\", \"PDT\", \"US/Pacific\"}, /* Conflicts with Mexico/BajaNorte */\n    {32400, 1, \"AKST\", \"AKDT\", \"US/Alaska\"},\n    {36000, 1, \"HAST\", \"HADT\", \"US/Aleutian\"}\n};\n\n/*#define DEBUG_TZNAME*/\n\nstatic const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)\n{\n    int32_t idx;\n#ifdef DEBUG_TZNAME\n    fprintf(stderr, \"TZ=%s std=%s dst=%s daylight=%d offset=%d\\n\", getenv(\"TZ\"), stdID, dstID, daylightType, offset);\n#endif\n    for (idx = 0; idx < UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)\n    {\n        if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds\n            && daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)\n        {\n            return OFFSET_ZONE_MAPPINGS[idx].olsonID;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#ifdef SEARCH_TZFILE\n#define MAX_READ_SIZE 512\n\ntypedef struct DefaultTZInfo {\n    char* defaultTZBuffer;\n    int64_t defaultTZFileSize;\n    FILE* defaultTZFilePtr;\n    UBool defaultTZstatus;\n    int32_t defaultTZPosition;\n} DefaultTZInfo;\n\n/*\n * This method compares the two files given to see if they are a match.\n * It is currently use to compare two TZ files.\n */\nstatic UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {\n    FILE* file; \n    int64_t sizeFile;\n    int64_t sizeFileLeft;\n    int32_t sizeFileRead;\n    int32_t sizeFileToRead;\n    char bufferFile[MAX_READ_SIZE];\n    UBool result = TRUE;\n\n    if (tzInfo->defaultTZFilePtr == NULL) {\n        tzInfo->defaultTZFilePtr = fopen(defaultTZFileName, \"r\");\n    }\n    file = fopen(TZFileName, \"r\");\n\n    tzInfo->defaultTZPosition = 0; /* reset position to begin search */\n\n    if (file != NULL && tzInfo->defaultTZFilePtr != NULL) {\n        /* First check that the file size are equal. */\n        if (tzInfo->defaultTZFileSize == 0) {\n            fseek(tzInfo->defaultTZFilePtr, 0, SEEK_END);\n            tzInfo->defaultTZFileSize = ftell(tzInfo->defaultTZFilePtr);\n        }\n        fseek(file, 0, SEEK_END);\n        sizeFile = ftell(file);\n        sizeFileLeft = sizeFile;\n\n        if (sizeFile != tzInfo->defaultTZFileSize) {\n            result = FALSE;\n        } else {\n            /* Store the data from the files in seperate buffers and\n             * compare each byte to determine equality.\n             */\n            if (tzInfo->defaultTZBuffer == NULL) {\n                rewind(tzInfo->defaultTZFilePtr);\n                tzInfo->defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo->defaultTZFileSize);\n                sizeFileRead = fread(tzInfo->defaultTZBuffer, 1, tzInfo->defaultTZFileSize, tzInfo->defaultTZFilePtr);\n            }\n            rewind(file);\n            while(sizeFileLeft > 0) {\n                uprv_memset(bufferFile, 0, MAX_READ_SIZE);\n                sizeFileToRead = sizeFileLeft < MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;\n\n                sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);\n                if (memcmp(tzInfo->defaultTZBuffer + tzInfo->defaultTZPosition, bufferFile, sizeFileRead) != 0) {\n                    result = FALSE;\n                    break;\n                }\n                sizeFileLeft -= sizeFileRead;\n                tzInfo->defaultTZPosition += sizeFileRead;\n            }\n        }\n    } else {\n        result = FALSE;\n    }\n\n    if (file != NULL) {\n        fclose(file);\n    }\n\n    return result;\n}\n\n\n/* dirent also lists two entries: \".\" and \"..\" that we can safely ignore. */\n#define SKIP1 \".\"\n#define SKIP2 \"..\"\nstatic UBool U_CALLCONV putil_cleanup(void);\nstatic CharString *gSearchTZFileResult = NULL;\n\n/*\n * This method recursively traverses the directory given for a matching TZ file and returns the first match.\n * This function is not thread safe - it uses a global, gSearchTZFileResult, to hold its results.\n */\nstatic char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {\n    DIR* dirp = NULL;\n    struct dirent* dirEntry = NULL;\n    char* result = NULL;\n    UErrorCode status = U_ZERO_ERROR;\n\n    /* Save the current path */\n    CharString curpath(path, -1, status);\n    if (U_FAILURE(status)) {\n        goto cleanupAndReturn;\n    }\n\n    dirp = opendir(path);\n    if (dirp == NULL) {\n        goto cleanupAndReturn;\n    }\n\n    if (gSearchTZFileResult == NULL) {\n        gSearchTZFileResult = new CharString;\n        if (gSearchTZFileResult == NULL) {\n            goto cleanupAndReturn;\n        }\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    }\n\n    /* Check each entry in the directory. */\n    while((dirEntry = readdir(dirp)) != NULL) {\n        const char* dirName = dirEntry->d_name;\n        if (uprv_strcmp(dirName, SKIP1) != 0 && uprv_strcmp(dirName, SKIP2) != 0\n            && uprv_strcmp(TZFILE_SKIP, dirName) != 0 && uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {\n            /* Create a newpath with the new entry to test each entry in the directory. */\n            CharString newpath(curpath, status);\n            newpath.append(dirName, -1, status);\n            if (U_FAILURE(status)) {\n                break;\n            }\n\n            DIR* subDirp = NULL;\n            if ((subDirp = opendir(newpath.data())) != NULL) {\n                /* If this new path is a directory, make a recursive call with the newpath. */\n                closedir(subDirp);\n                newpath.append('/', status);\n                if (U_FAILURE(status)) {\n                    break;\n                }\n                result = searchForTZFile(newpath.data(), tzInfo);\n                /*\n                 Have to get out here. Otherwise, we'd keep looking\n                 and return the first match in the top-level directory\n                 if there's a match in the top-level. If not, this function\n                 would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().\n                 It worked without this in most cases because we have a fallback of calling\n                 localtime_r to figure out the default timezone.\n                */\n                if (result != NULL)\n                    break;\n            } else {\n                if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {\n                    int32_t amountToSkip = sizeof(TZZONEINFO) - 1;\n                    if (amountToSkip > newpath.length()) {\n                        amountToSkip = newpath.length();\n                    }\n                    const char* zoneid = newpath.data() + amountToSkip;\n                    skipZoneIDPrefix(&zoneid);\n                    gSearchTZFileResult->clear();\n                    gSearchTZFileResult->append(zoneid, -1, status);\n                    if (U_FAILURE(status)) {\n                        break;\n                    }\n                    result = gSearchTZFileResult->data();\n                    /* Get out after the first one found. */\n                    break;\n                }\n            }\n        }\n    }\n\n  cleanupAndReturn:\n    if (dirp) {\n        closedir(dirp);\n    }\n    return result;\n}\n#endif\n\nU_CAPI void U_EXPORT2\nuprv_tzname_clear_cache()\n{\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    gTimeZoneBufferPtr = NULL;\n#endif\n}\n\nU_CAPI const char* U_EXPORT2\nuprv_tzname(int n)\n{\n    (void)n; // Avoid unreferenced parameter warning.\n    const char *tzid = NULL;\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    tzid = uprv_detectWindowsTimeZone();\n\n    if (tzid != NULL) {\n        return tzid;\n    }\n\n#ifndef U_TZNAME\n    // The return value is free'd in timezone.cpp on Windows because\n    // the other code path returns a pointer to a heap location.\n    // If we don't have a name already, then tzname wouldn't be any\n    // better, so just fall back.\n    return uprv_strdup(\"\");\n#endif // !U_TZNAME\n\n#else\n\n/*#if U_PLATFORM_IS_DARWIN_BASED\n    int ret;\n\n    tzid = getenv(\"TZFILE\");\n    if (tzid != NULL) {\n        return tzid;\n    }\n#endif*/\n\n/* This code can be temporarily disabled to test tzname resolution later on. */\n#ifndef DEBUG_TZNAME\n    tzid = getenv(\"TZ\");\n    if (tzid != NULL && isValidOlsonID(tzid)\n#if U_PLATFORM == U_PF_SOLARIS\n    /* When TZ equals localtime on Solaris, check the /etc/localtime file. */\n        && uprv_strcmp(tzid, TZ_ENV_CHECK) != 0\n#endif\n    ) {\n        /* The colon forces tzset() to treat the remainder as zoneinfo path */ \n        if (tzid[0] == ':') { \n            tzid++; \n        } \n        /* This might be a good Olson ID. */\n        skipZoneIDPrefix(&tzid);\n        return tzid;\n    }\n    /* else U_TZNAME will give a better result. */\n#endif\n\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    /* Caller must handle threading issues */\n    if (gTimeZoneBufferPtr == NULL) {\n        /*\n        This is a trick to look at the name of the link to get the Olson ID\n        because the tzfile contents is underspecified.\n        This isn't guaranteed to work because it may not be a symlink.\n        */\n        int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer)-1);\n        if (0 < ret) {\n            int32_t tzZoneInfoTailLen = uprv_strlen(TZZONEINFOTAIL);\n            gTimeZoneBuffer[ret] = 0;\n            char *  tzZoneInfoTailPtr = uprv_strstr(gTimeZoneBuffer, TZZONEINFOTAIL);\n            \n            if (tzZoneInfoTailPtr != NULL\n                && isValidOlsonID(tzZoneInfoTailPtr + tzZoneInfoTailLen))\n            {\n                return (gTimeZoneBufferPtr = tzZoneInfoTailPtr + tzZoneInfoTailLen);\n            }\n        } else {\n#if defined(SEARCH_TZFILE)\n            DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));\n            if (tzInfo != NULL) {\n                tzInfo->defaultTZBuffer = NULL;\n                tzInfo->defaultTZFileSize = 0;\n                tzInfo->defaultTZFilePtr = NULL;\n                tzInfo->defaultTZstatus = FALSE;\n                tzInfo->defaultTZPosition = 0;\n\n                gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);\n\n                /* Free previously allocated memory */\n                if (tzInfo->defaultTZBuffer != NULL) {\n                    uprv_free(tzInfo->defaultTZBuffer);\n                }\n                if (tzInfo->defaultTZFilePtr != NULL) {\n                    fclose(tzInfo->defaultTZFilePtr);\n                }\n                uprv_free(tzInfo);\n            }\n\n            if (gTimeZoneBufferPtr != NULL && isValidOlsonID(gTimeZoneBufferPtr)) {\n                return gTimeZoneBufferPtr;\n            }\n#endif\n        }\n    }\n    else {\n        return gTimeZoneBufferPtr;\n    }\n#endif\n#endif\n\n#ifdef U_TZNAME\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /* The return value is free'd in timezone.cpp on Windows because\n     * the other code path returns a pointer to a heap location. */\n    return uprv_strdup(U_TZNAME[n]);\n#else\n    /*\n    U_TZNAME is usually a non-unique abbreviation, which isn't normally usable.\n    So we remap the abbreviation to an olson ID.\n\n    Since Windows exposes a little more timezone information,\n    we normally don't use this code on Windows because\n    uprv_detectWindowsTimeZone should have already given the correct answer.\n    */\n    {\n        struct tm juneSol, decemberSol;\n        int daylightType;\n        static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/\n        static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/\n\n        /* This probing will tell us when daylight savings occurs.  */\n        localtime_r(&juneSolstice, &juneSol);\n        localtime_r(&decemberSolstice, &decemberSol);\n        if(decemberSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_DECEMBER;\n        } else if(juneSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_JUNE;\n        } else {\n          daylightType = U_DAYLIGHT_NONE;\n        }\n        tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());\n        if (tzid != NULL) {\n            return tzid;\n        }\n    }\n    return U_TZNAME[n];\n#endif\n#else\n    return \"\";\n#endif\n}\n\n/* Get and set the ICU data directory --------------------------------------- */\n\nstatic icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;\nstatic char *gDataDirectory = NULL;\n\nUInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;\nstatic CharString *gTimeZoneFilesDirectory = NULL;\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n static const char *gCorrectedPOSIXLocale = NULL; /* Sometimes heap allocated */\n static bool gCorrectedPOSIXLocaleHeapAllocated = false;\n#endif\n\nstatic UBool U_CALLCONV putil_cleanup(void)\n{\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = NULL;\n    gDataDirInitOnce.reset();\n\n    delete gTimeZoneFilesDirectory;\n    gTimeZoneFilesDirectory = NULL;\n    gTimeZoneFilesInitOnce.reset();\n\n#ifdef SEARCH_TZFILE\n    delete gSearchTZFileResult;\n    gSearchTZFileResult = NULL;\n#endif\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n    if (gCorrectedPOSIXLocale && gCorrectedPOSIXLocaleHeapAllocated) {\n        uprv_free(const_cast<char *>(gCorrectedPOSIXLocale));\n        gCorrectedPOSIXLocale = NULL;\n        gCorrectedPOSIXLocaleHeapAllocated = false;\n    }\n#endif\n    return TRUE;\n}\n\n/*\n * Set the data directory.\n *    Make a copy of the passed string, and set the global data dir to point to it.\n */\nU_CAPI void U_EXPORT2\nu_setDataDirectory(const char *directory) {\n    char *newDataDir;\n    int32_t length;\n\n    if(directory==NULL || *directory==0) {\n        /* A small optimization to prevent the malloc and copy when the\n        shared library is used, and this is a way to make sure that NULL\n        is never returned.\n        */\n        newDataDir = (char *)\"\";\n    }\n    else {\n        length=(int32_t)uprv_strlen(directory);\n        newDataDir = (char *)uprv_malloc(length + 2);\n        /* Exit out if newDataDir could not be created. */\n        if (newDataDir == NULL) {\n            return;\n        }\n        uprv_strcpy(newDataDir, directory);\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n        {\n            char *p;\n            while((p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) != NULL) {\n                *p = U_FILE_SEP_CHAR;\n            }\n        }\n#endif\n    }\n\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = newDataDir;\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_pathIsAbsolute(const char *path)\n{\n  if(!path || !*path) {\n    return FALSE;\n  }\n\n  if(*path == U_FILE_SEP_CHAR) {\n    return TRUE;\n  }\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n  if(*path == U_FILE_ALT_SEP_CHAR) {\n    return TRUE;\n  }\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\n  if( (((path[0] >= 'A') && (path[0] <= 'Z')) ||\n       ((path[0] >= 'a') && (path[0] <= 'z'))) &&\n      path[1] == ':' ) {\n    return TRUE;\n  }\n#endif\n\n  return FALSE;\n}\n\n/* Backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR\n   (needed for some Darwin ICU build environments) */\n#if U_PLATFORM_IS_DARWIN_BASED && TARGET_OS_SIMULATOR\n# if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n#  define ICU_DATA_DIR_PREFIX_ENV_VAR \"IPHONE_SIMULATOR_ROOT\"\n# endif\n#endif\n\n#if defined(ICU_DATA_DIR_WINDOWS)\n// Helper function to get the ICU Data Directory under the Windows directory location.\nstatic BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryBuffer, UINT bufferLength)\n{\n    wchar_t windowsPath[MAX_PATH];\n    char windowsPathUtf8[MAX_PATH];\n\n    UINT length = GetSystemWindowsDirectoryW(windowsPath, UPRV_LENGTHOF(windowsPath));\n    if ((length > 0) && (length < (UPRV_LENGTHOF(windowsPath) - 1))) {\n        // Convert UTF-16 to a UTF-8 string.\n        UErrorCode status = U_ZERO_ERROR;\n        int32_t windowsPathUtf8Len = 0;\n        u_strToUTF8(windowsPathUtf8, static_cast<int32_t>(UPRV_LENGTHOF(windowsPathUtf8)),\n            &windowsPathUtf8Len, reinterpret_cast<const UChar*>(windowsPath), -1, &status);\n\n        if (U_SUCCESS(status) && (status != U_STRING_NOT_TERMINATED_WARNING) &&\n            (windowsPathUtf8Len < (UPRV_LENGTHOF(windowsPathUtf8) - 1))) {\n            // Ensure it always has a separator, so we can append the ICU data path.\n            if (windowsPathUtf8[windowsPathUtf8Len - 1] != U_FILE_SEP_CHAR) {\n                windowsPathUtf8[windowsPathUtf8Len++] = U_FILE_SEP_CHAR;\n                windowsPathUtf8[windowsPathUtf8Len] = '\\0';\n            }\n            // Check if the concatenated string will fit.\n            if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) < bufferLength) {\n                uprv_strcpy(directoryBuffer, windowsPathUtf8);\n                uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n#endif\n\nstatic void U_CALLCONV dataDirectoryInitFn() {\n    /* If we already have the directory, then return immediately. Will happen if user called\n     * u_setDataDirectory().\n     */\n    if (gDataDirectory) {\n        return;\n    }\n\n    const char *path = NULL;\n#if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n    char datadir_path_buffer[PATH_MAX];\n#endif\n\n    /*\n    When ICU_NO_USER_DATA_OVERRIDE is defined, users aren't allowed to\n    override ICU's data with the ICU_DATA environment variable. This prevents\n    problems where multiple custom copies of ICU's specific version of data\n    are installed on a system. Either the application must define the data\n    directory with u_setDataDirectory, define ICU_DATA_DIR when compiling\n    ICU, set the data with udata_setCommonData or trust that all of the\n    required data is contained in ICU's data library that contains\n    the entry point defined by U_ICUDATA_ENTRY_POINT.\n\n    There may also be some platforms where environment variables\n    are not allowed.\n    */\n#   if !defined(ICU_NO_USER_DATA_OVERRIDE) && !UCONFIG_NO_FILE_IO\n    /* First try to get the environment variable */\n#     if U_PLATFORM_HAS_WINUWP_API == 0  // Windows UWP does not support getenv\n        path=getenv(\"ICU_DATA\");\n#     endif\n#   endif\n\n    /* ICU_DATA_DIR may be set as a compile option.\n     * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time\n     * and is used only when data is built in archive mode eliminating the need\n     * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation\n     * directory of the data dat file. Users should use ICU_DATA_DIR if they want to\n     * set their own path.\n     */\n#if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)\n    if(path==NULL || *path==0) {\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);\n# endif\n# ifdef ICU_DATA_DIR\n        path=ICU_DATA_DIR;\n# else\n        path=U_ICU_DATA_DEFAULT_DIR;\n# endif\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        if (prefix != NULL) {\n            snprintf(datadir_path_buffer, PATH_MAX, \"%s%s\", prefix, path);\n            path=datadir_path_buffer;\n        }\n# endif\n    }\n#endif\n\n#if defined(ICU_DATA_DIR_WINDOWS)\n    char datadir_path_buffer[MAX_PATH];\n    if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {\n        path = datadir_path_buffer;\n    }\n#endif\n\n    if(path==NULL) {\n        /* It looks really bad, set it to something. */\n        path = \"\";\n    }\n\n    u_setDataDirectory(path);\n    return;\n}\n\nU_CAPI const char * U_EXPORT2\nu_getDataDirectory(void) {\n    umtx_initOnce(gDataDirInitOnce, &dataDirectoryInitFn);\n    return gDataDirectory;\n}\n\nstatic void setTimeZoneFilesDir(const char *path, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    gTimeZoneFilesDirectory->clear();\n    gTimeZoneFilesDirectory->append(path, status);\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n    char *p = gTimeZoneFilesDirectory->data();\n    while ((p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) != NULL) {\n        *p = U_FILE_SEP_CHAR;\n    }\n#endif\n}\n\n#define TO_STRING(x) TO_STRING_2(x) \n#define TO_STRING_2(x) #x\n\nstatic void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &status) {\n    U_ASSERT(gTimeZoneFilesDirectory == NULL);\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    gTimeZoneFilesDirectory = new CharString();\n    if (gTimeZoneFilesDirectory == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return;\n    }\n\n    const char *dir = \"\";\n\n#if defined(ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR)\n    char timezonefilesdir_path_buffer[PATH_MAX];\n    const char *prefix = getenv(ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR);\n#endif\n\n#if U_PLATFORM_HAS_WINUWP_API == 1\n// The UWP version does not support the environment variable setting.\n\n# if defined(ICU_DATA_DIR_WINDOWS)\n    // When using the Windows system data, we can possibly pick up time zone data from the Windows directory.\n    char datadir_path_buffer[MAX_PATH];\n    if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {\n        dir = datadir_path_buffer;\n    }\n# endif\n\n#else\n    dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n#endif // U_PLATFORM_HAS_WINUWP_API\n\n#if defined(U_TIMEZONE_FILES_DIR)\n    if (dir == NULL) {\n        // Build time configuration setting.\n        dir = TO_STRING(U_TIMEZONE_FILES_DIR);\n    }\n#endif\n\n    if (dir == NULL) {\n        dir = \"\";\n    }\n\n#if defined(ICU_TIMEZONE_FILES_DIR_PREFIX_ENV_VAR)\n    if (prefix != NULL) {\n        snprintf(timezonefilesdir_path_buffer, PATH_MAX, \"%s%s\", prefix, dir);\n        dir = timezonefilesdir_path_buffer;\n    }\n#endif\n\n    setTimeZoneFilesDir(dir, status);\n}\n\n\nU_CAPI const char * U_EXPORT2\nu_getTimeZoneFilesDirectory(UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    return U_SUCCESS(*status) ? gTimeZoneFilesDirectory->data() : \"\";\n}\n\nU_CAPI void U_EXPORT2\nu_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    setTimeZoneFilesDir(path, *status);\n\n    // Note: this function does some extra churn, first setting based on the\n    //       environment, then immediately replacing with the value passed in.\n    //       The logic is simpler that way, and performance shouldn't be an issue.\n}\n\n\n#if U_POSIX_LOCALE\n/* A helper function used by uprv_getPOSIXIDForDefaultLocale and\n * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for\n * LC_CTYPE and LC_MESSAGES. It doesn't support other locale categories.\n */\nstatic const char *uprv_getPOSIXIDForCategory(int category)\n{\n    const char* posixID = NULL;\n    if (category == LC_MESSAGES || category == LC_CTYPE) {\n        /*\n        * On Solaris two different calls to setlocale can result in\n        * different values. Only get this value once.\n        *\n        * We must check this first because an application can set this.\n        *\n        * LC_ALL can't be used because it's platform dependent. The LANG\n        * environment variable seems to affect LC_CTYPE variable by default.\n        * Here is what setlocale(LC_ALL, NULL) can return.\n        * HPUX can return 'C C C C C C C'\n        * Solaris can return /en_US/C/C/C/C/C on the second try.\n        * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...\n        *\n        * The default codepage detection also needs to use LC_CTYPE.\n        *\n        * Do not call setlocale(LC_*, \"\")! Using an empty string instead\n        * of NULL, will modify the libc behavior.\n        */\n        posixID = setlocale(category, NULL);\n        if ((posixID == 0)\n            || (uprv_strcmp(\"C\", posixID) == 0)\n            || (uprv_strcmp(\"POSIX\", posixID) == 0))\n        {\n            /* Maybe we got some garbage.  Try something more reasonable */\n            posixID = getenv(\"LC_ALL\");\n            /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008 \n             * This is needed to properly handle empty env. variables\n             */\n#if U_PLATFORM == U_PF_SOLARIS\n            if ((posixID == 0) || (posixID[0] == '\\0')) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if ((posixID == 0) || (posixID[0] == '\\0')) {\n#else\n            if (posixID == 0) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if (posixID == 0) {\n#endif                    \n                    posixID = getenv(\"LANG\");\n                }\n            }\n        }\n    }\n    if ((posixID==0)\n        || (uprv_strcmp(\"C\", posixID) == 0)\n        || (uprv_strcmp(\"POSIX\", posixID) == 0))\n    {\n        /* Nothing worked.  Give it a nice POSIX default value. */\n        posixID = \"en_US_POSIX\";\n        // Note: this test will not catch 'C.UTF-8',\n        // that will be handled in uprv_getDefaultLocaleID().\n        // Leave this mapping here for the uprv_getPOSIXIDForDefaultCodepage()\n        // caller which expects to see \"en_US_POSIX\" in many branches.\n    }\n    return posixID;\n}\n\n/* Return just the POSIX id for the default locale, whatever happens to be in\n * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultLocale(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);\n    }\n    return posixID;\n}\n\n#if !U_CHARSET_IS_UTF8\n/* Return just the POSIX id for the default codepage, whatever happens to be in\n * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultCodepage(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);\n    }\n    return posixID;\n}\n#endif\n#endif\n\n/* NOTE: The caller should handle thread safety */\nU_CAPI const char* U_EXPORT2\nuprv_getDefaultLocaleID()\n{\n#if U_POSIX_LOCALE\n/*\n  Note that:  (a '!' means the ID is improper somehow)\n     LC_ALL  ---->     default_loc          codepage\n--------------------------------------------------------\n     ab.CD             ab                   CD\n     ab@CD             ab__CD               -\n     ab@CD.EF          ab__CD               EF\n\n     ab_CD.EF@GH       ab_CD_GH             EF\n\nSome 'improper' ways to do the same as above:\n  !  ab_CD@GH.EF       ab_CD_GH             EF\n  !  ab_CD.EF@GH.IJ    ab_CD_GH             EF\n  !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF\n\n     _CD@GH            _CD_GH               -\n     _CD.EF@GH         _CD_GH               EF\n\nThe variant cannot have dots in it.\nThe 'rightmost' variant (@xxx) wins.\nThe leftmost codepage (.xxx) wins.\n*/\n    const char* posixID = uprv_getPOSIXIDForDefaultLocale();\n\n    /* Format: (no spaces)\n    ll [ _CC ] [ . MM ] [ @ VV]\n\n      l = lang, C = ctry, M = charmap, V = variant\n    */\n\n    if (gCorrectedPOSIXLocale != nullptr) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    // Copy the ID into owned memory.\n    // Over-allocate in case we replace \"C\" with \"en_US_POSIX\" (+10), + null termination\n    char *correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID) + 10 + 1));\n    if (correctedPOSIXLocale == nullptr) {\n        return nullptr;\n    }\n    uprv_strcpy(correctedPOSIXLocale, posixID);\n\n    char *limit;\n    if ((limit = uprv_strchr(correctedPOSIXLocale, '.')) != nullptr) {\n        *limit = 0;\n    }\n    if ((limit = uprv_strchr(correctedPOSIXLocale, '@')) != nullptr) {\n        *limit = 0;\n    }\n\n    if ((uprv_strcmp(\"C\", correctedPOSIXLocale) == 0) // no @ variant\n        || (uprv_strcmp(\"POSIX\", correctedPOSIXLocale) == 0)) {\n      // Raw input was C.* or POSIX.*, Give it a nice POSIX default value.\n      // (The \"C\"/\"POSIX\" case is handled in uprv_getPOSIXIDForCategory())\n      uprv_strcpy(correctedPOSIXLocale, \"en_US_POSIX\");\n    }\n \n    /* Note that we scan the *uncorrected* ID. */\n    const char *p;\n    if ((p = uprv_strrchr(posixID, '@')) != nullptr) {\n        p++;\n\n        /* Take care of any special cases here.. */\n        if (!uprv_strcmp(p, \"nynorsk\")) {\n            p = \"NY\";\n            /* Don't worry about no__NY. In practice, it won't appear. */\n        }\n\n        if (uprv_strchr(correctedPOSIXLocale,'_') == nullptr) {\n            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b (note this can make the new locale 1 char longer) */\n        }\n        else {\n            uprv_strcat(correctedPOSIXLocale, \"_\"); /* aa_CC@b -> aa_CC_b */\n        }\n\n        const char *q;\n        if ((q = uprv_strchr(p, '.')) != nullptr) {\n            /* How big will the resulting string be? */\n            int32_t len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));\n            uprv_strncat(correctedPOSIXLocale, p, q-p); // do not include charset\n            correctedPOSIXLocale[len] = 0;\n        }\n        else {\n            /* Anything following the @ sign */\n            uprv_strcat(correctedPOSIXLocale, p);\n        }\n\n        /* Should there be a map from 'no@nynorsk' -> no_NO_NY here?\n         * How about 'russian' -> 'ru'?\n         * Many of the other locales using ISO codes will be handled by the\n         * canonicalization functions in uloc_getDefault.\n         */\n    }\n\n    if (gCorrectedPOSIXLocale == nullptr) {\n        gCorrectedPOSIXLocale = correctedPOSIXLocale;\n        gCorrectedPOSIXLocaleHeapAllocated = true;\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n        correctedPOSIXLocale = nullptr;\n    }\n    posixID = gCorrectedPOSIXLocale;\n\n    if (correctedPOSIXLocale != nullptr) {  /* Was already set - clean up. */\n        uprv_free(correctedPOSIXLocale);\n    }\n\n    return posixID;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#define POSIX_LOCALE_CAPACITY 64\n    UErrorCode status = U_ZERO_ERROR;\n    char *correctedPOSIXLocale = nullptr;\n\n    // If we have already figured this out just use the cached value\n    if (gCorrectedPOSIXLocale != nullptr) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    // No cached value, need to determine the current value\n    static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH] = {};\n    int length = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT, LOCALE_SNAME, windowsLocale, LOCALE_NAME_MAX_LENGTH);\n\n    // Now we should have a Windows locale name that needs converted to the POSIX style.\n    if (length > 0) // If length is 0, then the GetLocaleInfoEx failed.\n    {\n        // First we need to go from UTF-16 to char (and also convert from _ to - while we're at it.)\n        char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH] = {};\n\n        int32_t i;\n        for (i = 0; i < UPRV_LENGTHOF(modifiedWindowsLocale); i++)\n        {\n            if (windowsLocale[i] == '_')\n            {\n                modifiedWindowsLocale[i] = '-';\n            }\n            else\n            {\n                modifiedWindowsLocale[i] = static_cast<char>(windowsLocale[i]);\n            }\n\n            if (modifiedWindowsLocale[i] == '\\0')\n            {\n                break;\n            }\n        }\n\n        if (i >= UPRV_LENGTHOF(modifiedWindowsLocale))\n        {\n            // Ran out of room, can't really happen, maybe we'll be lucky about a matching\n            // locale when tags are dropped\n            modifiedWindowsLocale[UPRV_LENGTHOF(modifiedWindowsLocale) - 1] = '\\0';\n        }\n\n        // Now normalize the resulting name\n        correctedPOSIXLocale = static_cast<char *>(uprv_malloc(POSIX_LOCALE_CAPACITY + 1));\n        /* TODO: Should we just exit on memory allocation failure? */\n        if (correctedPOSIXLocale)\n        {\n            int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &status);\n            if (U_SUCCESS(status))\n            {\n                *(correctedPOSIXLocale + posixLen) = 0;\n                gCorrectedPOSIXLocale = correctedPOSIXLocale;\n                gCorrectedPOSIXLocaleHeapAllocated = true;\n                ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n            }\n            else\n            {\n                uprv_free(correctedPOSIXLocale);\n            }\n        }\n    }\n\n    // If unable to find a locale we can agree upon, use en-US by default\n    if (gCorrectedPOSIXLocale == nullptr) {\n        gCorrectedPOSIXLocale = \"en_US\";\n    }\n    return gCorrectedPOSIXLocale;\n\n#elif U_PLATFORM == U_PF_OS400\n    /* locales are process scoped and are by definition thread safe */\n    static char correctedLocale[64];\n    const  char *localeID = getenv(\"LC_ALL\");\n           char *p;\n\n    if (localeID == NULL)\n        localeID = getenv(\"LANG\");\n    if (localeID == NULL)\n        localeID = setlocale(LC_ALL, NULL);\n    /* Make sure we have something... */\n    if (localeID == NULL)\n        return \"en_US_POSIX\";\n\n    /* Extract the locale name from the path. */\n    if((p = uprv_strrchr(localeID, '/')) != NULL)\n    {\n        /* Increment p to start of locale name. */\n        p++;\n        localeID = p;\n    }\n\n    /* Copy to work location. */\n    uprv_strcpy(correctedLocale, localeID);\n\n    /* Strip off the '.locale' extension. */\n    if((p = uprv_strchr(correctedLocale, '.')) != NULL) {\n        *p = 0;\n    }\n\n    /* Upper case the locale name. */\n    T_CString_toUpperCase(correctedLocale);\n\n    /* See if we are using the POSIX locale.  Any of the\n    * following are equivalent and use the same QLGPGCMA\n    * (POSIX) locale.\n    * QLGPGCMA2 means UCS2\n    * QLGPGCMA_4 means UTF-32\n    * QLGPGCMA_8 means UTF-8\n    */\n    if ((uprv_strcmp(\"C\", correctedLocale) == 0) ||\n        (uprv_strcmp(\"POSIX\", correctedLocale) == 0) ||\n        (uprv_strncmp(\"QLGPGCMA\", correctedLocale, 8) == 0))\n    {\n        uprv_strcpy(correctedLocale, \"en_US_POSIX\");\n    }\n    else\n    {\n        int16_t LocaleLen;\n\n        /* Lower case the lang portion. */\n        for(p = correctedLocale; *p != 0 && *p != '_'; p++)\n        {\n            *p = uprv_tolower(*p);\n        }\n\n        /* Adjust for Euro.  After '_E' add 'URO'. */\n        LocaleLen = uprv_strlen(correctedLocale);\n        if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'E')\n        {\n            uprv_strcat(correctedLocale, \"URO\");\n        }\n\n        /* If using Lotus-based locale then convert to\n         * equivalent non Lotus.\n         */\n        else if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'L')\n        {\n            correctedLocale[LocaleLen - 2] = 0;\n        }\n\n        /* There are separate simplified and traditional\n         * locales called zh_HK_S and zh_HK_T.\n         */\n        else if (uprv_strncmp(correctedLocale, \"zh_HK\", 5) == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_HK\");\n        }\n\n        /* A special zh_CN_GBK locale...\n        */\n        else if (uprv_strcmp(correctedLocale, \"zh_CN_GBK\") == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_CN\");\n        }\n\n    }\n\n    return correctedLocale;\n#endif\n\n}\n\n#if !U_CHARSET_IS_UTF8\n#if U_POSIX_LOCALE\n/*\nDue to various platform differences, one platform may specify a charset,\nwhen they really mean a different charset. Remap the names so that they are\ncompatible with ICU. Only conflicting/ambiguous aliases should be resolved\nhere. Before adding anything to this function, please consider adding unique\nnames to the ICU alias table in the data directory.\n*/\nstatic const char*\nremapPlatformDependentCodepage(const char *locale, const char *name) {\n    if (locale != NULL && *locale == 0) {\n        /* Make sure that an empty locale is handled the same way. */\n        locale = NULL;\n    }\n    if (name == NULL) {\n        return NULL;\n    }\n#if U_PLATFORM == U_PF_AIX\n    if (uprv_strcmp(name, \"IBM-943\") == 0) {\n        /* Use the ASCII compatible ibm-943 */\n        name = \"Shift-JIS\";\n    }\n    else if (uprv_strcmp(name, \"IBM-1252\") == 0) {\n        /* Use the windows-1252 that contains the Euro */\n        name = \"IBM-5348\";\n    }\n#elif U_PLATFORM == U_PF_SOLARIS\n    if (locale != NULL && uprv_strcmp(name, \"EUC\") == 0) {\n        /* Solaris underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"zh_CN\") == 0) {\n            name = \"EUC-CN\";\n        }\n        else if (uprv_strcmp(locale, \"zh_TW\") == 0) {\n            name = \"EUC-TW\";\n        }\n        else if (uprv_strcmp(locale, \"ko_KR\") == 0) {\n            name = \"EUC-KR\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-954 is the best match.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (uprv_strcmp(name, \"646\") == 0) {\n        /*\n         * The default codepage given by Solaris is 646 but the C library routines treat it as if it was\n         * ISO-8859-1 instead of US-ASCII(646).\n         */\n        name = \"ISO-8859-1\";\n    }\n#elif U_PLATFORM_IS_DARWIN_BASED\n    if (locale == NULL && *name == 0) {\n        /*\n        No locale was specified, and an empty name was passed in.\n        This usually indicates that nl_langinfo didn't return valid information.\n        Mac OS X uses UTF-8 by default (especially the locale data and console).\n        */\n        name = \"UTF-8\";\n    }\n    else if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 && uprv_strcmp(name, \"US-ASCII\") == 0) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n#elif U_PLATFORM == U_PF_BSD\n    if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n#elif U_PLATFORM == U_PF_HPUX\n    if (locale != NULL && uprv_strcmp(locale, \"zh_HK\") == 0 && uprv_strcmp(name, \"big5\") == 0) {\n        /* HP decided to extend big5 as hkbig5 even though it's not compatible :-( */\n        /* zh_TW.big5 is not the same charset as zh_HK.big5! */\n        name = \"hkbig5\";\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n#elif U_PLATFORM == U_PF_LINUX\n    if (locale != NULL && uprv_strcmp(name, \"euc\") == 0) {\n        /* Linux underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"korean\") == 0) {\n            name = \"EUC-KR\";\n        }\n        else if (uprv_strcmp(locale, \"japanese\") == 0) {\n            /* See comment below about eucJP */\n            name = \"eucjis\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucjp\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 &&\n            (uprv_strcmp(name, \"ANSI_X3.4-1968\") == 0 || uprv_strcmp(name, \"US-ASCII\") == 0)) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n    /*\n     * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of\n     * it by falling back to 'US-ASCII' when NULL is returned from this\n     * function. So, we don't have to worry about it here.\n     */\n#endif\n    /* return NULL when \"\" is passed in */\n    if (*name == 0) {\n        name = NULL;\n    }\n    return name;\n}\n\nstatic const char*\ngetCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)\n{\n    char localeBuf[100];\n    const char *name = NULL;\n    char *variant = NULL;\n\n    if (localeName != NULL && (name = (uprv_strchr(localeName, '.'))) != NULL) {\n        size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);\n        uprv_strncpy(localeBuf, localeName, localeCapacity);\n        localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */\n        name = uprv_strncpy(buffer, name+1, buffCapacity);\n        buffer[buffCapacity-1] = 0; /* ensure NULL termination */\n        if ((variant = const_cast<char *>(uprv_strchr(name, '@'))) != NULL) {\n            *variant = 0;\n        }\n        name = remapPlatformDependentCodepage(localeBuf, name);\n    }\n    return name;\n}\n#endif\n\nstatic const char*\nint_getDefaultCodepage()\n{\n#if U_PLATFORM == U_PF_OS400\n    uint32_t ccsid = 37; /* Default to ibm-37 */\n    static char codepage[64];\n    Qwc_JOBI0400_t jobinfo;\n    Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */\n\n    EPT_CALL(QUSRJOBI)(&jobinfo, sizeof(jobinfo), \"JOBI0400\",\n        \"*                         \", \"                \", &error);\n\n    if (error.Bytes_Available == 0) {\n        if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;\n        }\n        else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;\n        }\n        /* else use the default */\n    }\n    sprintf(codepage,\"ibm-%d\", ccsid);\n    return codepage;\n\n#elif U_PLATFORM == U_PF_OS390\n    static char codepage[64];\n\n    strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));\n    strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);\n    codepage[63] = 0; /* NULL terminate */\n\n    return codepage;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    static char codepage[64];\n    DWORD codepageNumber = 0;\n\n#if U_PLATFORM_HAS_WINUWP_API == 1\n    // UWP doesn't have a direct API to get the default ACP as Microsoft would rather\n    // have folks use Unicode than a \"system\" code page, however this is the same\n    // codepage as the system default locale codepage.  (FWIW, the system locale is\n    // ONLY used for codepage, it should never be used for anything else)\n    GetLocaleInfoEx(LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,\n        (LPWSTR)&codepageNumber, sizeof(codepageNumber) / sizeof(WCHAR));\n#else\n    // Win32 apps can call GetACP\n    codepageNumber = GetACP();\n#endif\n    // Special case for UTF-8\n    if (codepageNumber == 65001)\n    { \n        return \"UTF-8\";\n    }\n    // Windows codepages can look like windows-1252, so format the found number\n    // the numbers are eclectic, however all valid system code pages, besides UTF-8\n    // are between 3 and 19999\n    if (codepageNumber > 0 && codepageNumber < 20000)\n    {\n        sprintf(codepage, \"windows-%ld\", codepageNumber);\n        return codepage;\n    }\n    // If the codepage number call failed then return UTF-8\n    return \"UTF-8\";\n\n#elif U_POSIX_LOCALE\n    static char codesetName[100];\n    const char *localeName = NULL;\n    const char *name = NULL;\n\n    localeName = uprv_getPOSIXIDForDefaultCodepage();\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    /* On Solaris nl_langinfo returns C locale values unless setlocale\n     * was called earlier.\n     */\n#if (U_HAVE_NL_LANGINFO_CODESET && U_PLATFORM != U_PF_SOLARIS)\n    /* When available, check nl_langinfo first because it usually gives more\n       useful names. It depends on LC_CTYPE.\n       nl_langinfo may use the same buffer as setlocale. */\n    {\n        const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);\n#if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED\n        /*\n         * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8\n         * instead of ASCII.\n         */\n        if (uprv_strcmp(localeName, \"en_US_POSIX\") != 0) {\n            codeset = remapPlatformDependentCodepage(localeName, codeset);\n        } else\n#endif\n        {\n            codeset = remapPlatformDependentCodepage(NULL, codeset);\n        }\n\n        if (codeset != NULL) {\n            uprv_strncpy(codesetName, codeset, sizeof(codesetName));\n            codesetName[sizeof(codesetName)-1] = 0;\n            return codesetName;\n        }\n    }\n#endif\n\n    /* Use setlocale in a nice way, and then check some environment variables.\n       Maybe the application used setlocale already.\n    */\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));\n    if (name) {\n        /* if we can find the codeset name from setlocale, return that. */\n        return name;\n    }\n\n    if (*codesetName == 0)\n    {\n        /* Everything failed. Return US ASCII (ISO 646). */\n        (void)uprv_strcpy(codesetName, \"US-ASCII\");\n    }\n    return codesetName;\n#else\n    return \"US-ASCII\";\n#endif\n}\n\n\nU_CAPI const char*  U_EXPORT2\nuprv_getDefaultCodepage()\n{\n    static char const  *name = NULL;\n    umtx_lock(NULL);\n    if (name == NULL) {\n        name = int_getDefaultCodepage();\n    }\n    umtx_unlock(NULL);\n    return name;\n}\n#endif  /* !U_CHARSET_IS_UTF8 */\n\n\n/* end of platform-specific implementation -------------- */\n\n/* version handling --------------------------------------------------------- */\n\nU_CAPI void U_EXPORT2\nu_versionFromString(UVersionInfo versionArray, const char *versionString) {\n    char *end;\n    uint16_t part=0;\n\n    if(versionArray==NULL) {\n        return;\n    }\n\n    if(versionString!=NULL) {\n        for(;;) {\n            versionArray[part]=(uint8_t)uprv_strtoul(versionString, &end, 10);\n            if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {\n                break;\n            }\n            versionString=end+1;\n        }\n    }\n\n    while(part<U_MAX_VERSION_LENGTH) {\n        versionArray[part++]=0;\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {\n    if(versionArray!=NULL && versionString!=NULL) {\n        char versionChars[U_MAX_VERSION_STRING_LENGTH+1];\n        int32_t len = u_strlen(versionString);\n        if(len>U_MAX_VERSION_STRING_LENGTH) {\n            len = U_MAX_VERSION_STRING_LENGTH;\n        }\n        u_UCharsToChars(versionString, versionChars, len);\n        versionChars[len]=0;\n        u_versionFromString(versionArray, versionChars);\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionToString(const UVersionInfo versionArray, char *versionString) {\n    uint16_t count, part;\n    uint8_t field;\n\n    if(versionString==NULL) {\n        return;\n    }\n\n    if(versionArray==NULL) {\n        versionString[0]=0;\n        return;\n    }\n\n    /* count how many fields need to be written */\n    for(count=4; count>0 && versionArray[count-1]==0; --count) {\n    }\n\n    if(count <= 1) {\n        count = 2;\n    }\n\n    /* write the first part */\n    /* write the decimal field value */\n    field=versionArray[0];\n    if(field>=100) {\n        *versionString++=(char)('0'+field/100);\n        field%=100;\n    }\n    if(field>=10) {\n        *versionString++=(char)('0'+field/10);\n        field%=10;\n    }\n    *versionString++=(char)('0'+field);\n\n    /* write the following parts */\n    for(part=1; part<count; ++part) {\n        /* write a dot first */\n        *versionString++=U_VERSION_DELIMITER;\n\n        /* write the decimal field value */\n        field=versionArray[part];\n        if(field>=100) {\n            *versionString++=(char)('0'+field/100);\n            field%=100;\n        }\n        if(field>=10) {\n            *versionString++=(char)('0'+field/10);\n            field%=10;\n        }\n        *versionString++=(char)('0'+field);\n    }\n\n    /* NUL-terminate */\n    *versionString=0;\n}\n\nU_CAPI void U_EXPORT2\nu_getVersion(UVersionInfo versionArray) {\n    (void)copyright;   // Suppress unused variable warning from clang.\n    u_versionFromString(versionArray, U_ICU_VERSION);\n}\n\n/**\n * icucfg.h dependent code \n */\n\n#if U_ENABLE_DYLOAD && HAVE_DLOPEN && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#if HAVE_DLFCN_H\n#ifdef __MVS__\n#ifndef __SUSV3\n#define __SUSV3 1\n#endif\n#endif\n#include <dlfcn.h>\n#endif /* HAVE_DLFCN_H */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  void *ret = NULL;\n  if(U_FAILURE(*status)) return ret;\n  ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);\n  if(ret==NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlopen(%s): %s\\n\", libName, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  dlclose(lib);\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  union {\n      UVoidFunction *fp;\n      void *vp;\n  } uret;\n  uret.fp = NULL;\n  if(U_FAILURE(*status)) return uret.fp;\n  uret.vp = dlsym(lib, sym);\n  if(uret.vp == NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlsym(%p,%s): %s\\n\", lib,sym, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return uret.fp;\n}\n\n#elif U_ENABLE_DYLOAD && U_PLATFORM_USES_ONLY_WIN32_API && !U_PLATFORM_HAS_WINUWP_API\n\n/* Windows API implementation. */\n// Note: UWP does not expose/allow these APIs, so the UWP version gets the null implementation. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  HMODULE lib = NULL;\n  \n  if(U_FAILURE(*status)) return NULL;\n  \n  lib = LoadLibraryA(libName);\n  \n  if(lib==NULL) {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  \n  return (void*)lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  if(U_FAILURE(*status)) return;\n  \n  FreeLibrary(handle);\n  \n  return;\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  UVoidFunction* addr = NULL;\n  \n  if(U_FAILURE(*status) || lib==NULL) return NULL;\n  \n  addr = (UVoidFunction*)GetProcAddress(handle, sym);\n  \n  if(addr==NULL) {\n    DWORD lastError = GetLastError();\n    if(lastError == ERROR_PROC_NOT_FOUND) {\n      *status = U_MISSING_RESOURCE_ERROR;\n    } else {\n      *status = U_UNSUPPORTED_ERROR; /* other unknown error. */\n    }\n  }\n  \n  return addr;\n}\n\n#else\n\n/* No dynamic loading, null (nonexistent) implementation. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n    (void)libName;\n    if(U_FAILURE(*status)) return NULL;\n    *status = U_UNSUPPORTED_ERROR;\n    return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n    (void)lib;\n    if(U_FAILURE(*status)) return;\n    *status = U_UNSUPPORTED_ERROR;\n    return;\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  (void)lib;\n  (void)sym;\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n#endif\n\n/*\n * Hey, Emacs, please set the following:\n *\n * Local Variables:\n * indent-tabs-mode: nil\n * End:\n *\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/depstest/dependencies.txt": "# -*- icu-dependencies -*-\n# Copyright (C) 2016 and later: Unicode, Inc. and others.\n# License & terms of use: http://www.unicode.org/copyright.html\n# Copyright (C) 2011-2016, International Business Machines\n# Corporation and others. All Rights Reserved.\n#\n# file name: dependencies.txt\n#\n# created on: 2011may26\n# created by: Markus W. Scherer\n#\n# See http://site.icu-project.org/processes/release/tasks/healthy-code#TOC-Check-library-dependencies\n\n# Standard library symbols used by ICU --------------------------------------- #\n\nsystem_symbols:\n  deps\n    # C\n    PIC system_misc system_debug malloc_functions ubsan\n    c_strings c_string_formatting\n    int_functions floating_point trigonometry\n    stdlib_qsort\n    system_locale\n    stdio_input stdio_output file_io readlink_function dir_io mmap_functions dlfcn\n    # C++\n    cplusplus iostream\n    std_mutex\n\ngroup: PIC\n    # Position-Independent Code (-fPIC) requires a Global Offset Table.\n    _GLOBAL_OFFSET_TABLE_\n\ngroup: system_misc\n    abort\n\ngroup: system_debug\n    __assert_fail __stack_chk_fail\n\ngroup: malloc_functions\n    free malloc realloc\n\ngroup: std_mutex\n    std::condition_variable::notify_one()\n    std::condition_variable::wait(std::unique_lock<std::mutex>&)\n    std::condition_variable::notify_all()\n    std::condition_variable::condition_variable()\n    std::condition_variable::~condition_variable()\n    std::condition_variable_any::condition_variable_any()\n    std::condition_variable_any::~condition_variable_any()\n\ngroup: ubsan\n    # UBSan=UndefinedBehaviorSanitizer, clang -fsanitize=bounds\n    __ubsan_handle_out_of_bounds\n\ngroup: c_strings\n    isspace isdigit\n    __ctype_b_loc  # for <ctype.h>\n    # We must not use tolower and toupper because they are system-locale-sensitive (Turkish i).\n    strlen strchr strrchr strstr strcmp strncmp strcpy strncpy strcat strncat\n    memchr memcmp memcpy memmove memset\n    # Additional symbols in an optimized build.\n    __strcpy_chk __strncpy_chk __strcat_chk __strncat_chk\n    __rawmemchr __memcpy_chk __memmove_chk __memset_chk\n\ngroup: c_string_formatting\n    atoi atol strtod strtod_l strtol strtoul\n    sprintf snprintf\n    # Additional symbols in an optimized build.\n    __sprintf_chk\n\ngroup: int_functions\n    div\n\ngroup: floating_point\n    abs fabs floor ceil modf fmod log pow round sqrt trunc\n\ngroup: trigonometry\n    acos asin atan atan2 cos sin tan\n    # Additional symbols in an optimized build.\n    sincos\n\ngroup: stdlib_qsort\n    qsort\n\ngroup: system_locale\n    getenv\n    nl_langinfo setlocale newlocale freelocale\n    gettimeofday localtime_r tzname tzset __timezone\n\ngroup: stdio_input\n    fopen fclose fgets fread fseek ftell rewind feof fileno\n    # Additional symbols in an optimized build.\n    __fgets_chk __fread_chk fread_unlocked\n\ngroup: stdio_output\n    fflush fwrite\n    stdout\n\ngroup: file_io\n    open close stat\n    # Additional symbols in an optimized build.\n    __xstat\n\ngroup: readlink_function\n    readlink  # putil.cpp uprv_tzname() calls this in a hack to get the time zone name\n\ngroup: dir_io\n    opendir closedir readdir  # for a hack to get the time zone name\n\ngroup: mmap_functions  # for memory-mapped data loading\n    mmap munmap\n\ngroup: dlfcn\n    dlopen dlclose dlsym  # called by putil.o only for icuplug.o\n\ngroup: cplusplus\n    __dynamic_cast\n    # The compiler generates references to the global operator delete\n    # even when no code actually uses it.\n    # ICU must not _use_ the global operator delete.\n    \"operator delete(void*)\"\n    # ICU also must not use the global operator new.\n    # \"operator new[](unsigned long)\"\n\n    # _Unwind_Resume is related to exceptions:\n    # \"A call to this routine is inserted as the end of a landing pad that performs cleanup,\n    # but does not resume normal execution. It causes unwinding to proceed further.\"\n    # (Linux Standard Base Specification 1.3)\n    # Even though ICU does not actually use (nor handle) exceptions.\n    _Unwind_Resume\n    # std::terminate() looks similar to _Unwind_Resume:\n    # \"Calls the current terminate handler.\"\n    std::terminate()\n\ngroup: iostream\n    \"std::basic_ios<char, std::char_traits<char> >::clear(std::_Ios_Iostate)\"\n    \"std::basic_ios<char, std::char_traits<char> >::eof() const\"\n    \"std::basic_ios<char, std::char_traits<char> >::fail() const\"\n    \"std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)\"\n    std::ios_base::Init::Init()\n    std::ios_base::Init::~Init()\n    std::istream::get()\n    std::istream::putback(char)\n    # Additional symbols in an optimized build.\n    \"std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long)\"\n\n# ICU common library --------------------------------------------------------- #\n\nlibrary: stubdata\n    stubdata.o  # Exports icudt48_dat.\n\nlibrary: common\n    # All files in the common library are listed in its dependencies.\n  deps\n    # Libraries and groups that the common library depends on.\n    pluralmap\n    date_interval\n    breakiterator\n    uts46 filterednormalizer2 normalizer2 loadednormalizer2 canonical_iterator\n    normlzr unormcmp unorm\n    idna2003 stringprep\n    stringenumeration\n    unistr_props unistr_case unistr_case_locale unistr_titlecase_brkiter unistr_cnv\n    cstr\n    uniset_core uniset_props uniset_closure usetiter uset uset_props\n    static_unicode_sets\n    uiter edits\n    ucasemap ucasemap_titlecase_brkiter script_runs\n    uprops ubidi_props ucase uscript uscript_props characterproperties\n    ubidi ushape ubiditransform\n    resourcebundle service_registration resbund_cnv ures_cnv icudataver ucat\n    currency\n    locale_display_names2\n    conversion converter_selector ucnv_set ucnvdisp\n    messagepattern simpleformatter\n    icu_utility icu_utility_with_props\n    ustr_wcs\n    unifiedcache\n    ucharstriebuilder ucharstrieiterator\n    bytestriebuilder bytestrieiterator\n    hashtable uhash uvector uvector32 uvector64 ulist\n    propsvec utrie2 utrie2_builder ucptrie umutablecptrie utrie_swap\n    sort\n    uinit utypes errorcode\n    icuplug\n    platform\n    localebuilder localematcher\n\ngroup: pluralmap\n    # TODO: Move to i18n library, ticket #11926.\n    pluralmap.o\n  deps\n    platform\n\ngroup: date_interval  # class DateInterval\n    dtintrv.o\n  deps\n    platform\n\ngroup: breakiterator\n    # We could try to split off a breakiterator_builder group,\n    # but we still need uniset_props for code like in the ThaiBreakEngine constructor\n    # which does\n    #   fThaiWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[[:Thai:]&[:LineBreak=SA:]]\"), status)\n    brkiter.o brkeng.o ubrk.o\n    rbbi.o rbbinode.o rbbiscan.o rbbisetb.o rbbistbl.o rbbitblb.o\n    rbbidata.o rbbirb.o rbbi_cache.o\n    dictionarydata.o dictbe.o\n    # BreakIterator::makeInstance() factory implementation makes for circular dependency\n    # between BreakIterator base and FilteredBreakIteratorBuilder.\n    filteredbrk.o\n  deps\n    resourcebundle service_registration\n    schriter utext uniset_core uniset_props\n    uhash ustack utrie2_builder\n    ucharstrie bytestrie\n    ucharstriebuilder  # for filteredbrk.o\n    normlzr  # for dictbe.o, should switch to Normalizer2\n    uvector32 # for dictbe.o\n\ngroup: unormcmp  # unorm_compare()\n    unormcmp.o\n  deps\n    filterednormalizer2\n    uniset_props  # for uniset_getUnicode32Instance()\n    ucase\n\ngroup: unorm  # old normalization C API\n    unorm.o\n  deps\n    filterednormalizer2\n    uniset_props  # for uniset_getUnicode32Instance()\n    uiter\n\ngroup: normlzr  # old Normalizer C++ class\n    normlzr.o\n  deps\n    filterednormalizer2\n    uniset_props  # for uniset_getUnicode32Instance()\n    schriter\n\ngroup: uts46\n    uts46.o\n  deps\n    normalizer2 loadednormalizer2 punycode\n    uchar  # for u_charType() (via U_GET_GC_MASK(c))\n    ubidi_props  # for u_charDirection() & ubidi_getJoiningType()\n    bytestream\n\ngroup: filterednormalizer2\n    filterednormalizer2.o\n  deps\n    normalizer2\n\ngroup: idna2003\n    uidna.o\n  deps\n    stringprep punycode\n\ngroup: stringprep\n    usprep.o\n  deps\n    unorm  # could change to use filterednormalizer2 directly for Unicode 3.2 normalization\n    normalizer2\n    ubidi_props utrie\n\ngroup: canonical_iterator\n    caniter.o\n  deps\n    normalizer2 usetiter\n\ngroup: loadednormalizer2\n    loadednormalizer2impl.o\n  deps\n    normalizer2\n\ngroup: normalizer2\n    normalizer2.o\n    normalizer2impl.o\n  deps\n    uniset_core\n    bytestream bytesinkutil  # for UTF-8 output\n    umutablecptrie  # for building CanonIterData & FCD\n    utrie_swap  # TODO(ICU-20170): move unorm2_swap() to a separate file\n    uvector  # for building CanonIterData\n    uhash  # for the instance cache\n    udata\n\ngroup: punycode\n    punycode.o\n  deps\n    platform\n\ngroup: static_unicode_sets\n    static_unicode_sets.o\n  deps\n    resourcebundle uniset_props\n\ngroup: uset_props\n    uset_props.o\n  deps\n    uniset_closure uniset_props uniset_core\n\ngroup: uset\n    uset.o\n  deps\n    uniset_core\n\ngroup: uniset_closure\n    uniset_closure.o\n  deps\n    uniset_core unistr_case_locale unistr_titlecase_brkiter\n\ngroup: uniset_props\n    uniset_props.o ruleiter.o\n  deps\n    uniset_core uprops unistr_case characterproperties\n    parsepos\n    resourcebundle\n    propname unames\n\ngroup: parsepos\n    parsepos.o\n  deps\n    platform\n\ngroup: usetiter  # UnicodeSetIterator\n    usetiter.o\n  deps\n    uniset_core\n\ngroup: uniset_core\n    unifilt.o unifunct.o\n    uniset.o bmpset.o unisetspan.o\n  deps\n    patternprops\n    icu_utility\n    uvector\n\ngroup: icu_utility_with_props\n    util_props.o\n  deps\n    icu_utility uchar ucase\n\ngroup: icu_utility\n    util.o\n  deps\n    patternprops platform\n\ngroup: utext\n    utext.o\n  deps\n    ucase\n\ngroup: stringenumeration\n    ustrenum.o uenum.o\n  deps\n    platform\n\ngroup: schriter\n    schriter.o\n    # The UCharCharacterIterator implements virtual void getText(UnicodeString& result)\n    # so it depends on UnicodeString, therefore it makes little sense to split\n    # schriter and uchriter into separate groups.\n    uchriter.o\n  deps\n    chariter\n\ngroup: chariter\n    chariter.o\n  deps\n    platform\n\ngroup: uiter\n    uiter.o\n  deps\n    platform\n\ngroup: unistr_cnv\n    unistr_cnv.o\n  deps\n    conversion\n\ngroup: cstr\n    cstr.o\n  deps\n    unistr_cnv\n\ngroup: uscript\n    uscript.o  # uscript_getCode() accepts a locale ID and loads its script code data\n  deps\n    propname resourcebundle\n\ngroup: uscript_props  # script metadata properties\n    uscript_props.o\n  deps\n    platform\n\ngroup: uprops\n    uprops.o\n  deps\n    normalizer2 loadednormalizer2\n    uchar\n    ubidi_props\n    unistr_case ustring_case  # only for case folding\n    ucase\n\ngroup: characterproperties\n    characterproperties.o\n  deps\n    uprops\n    uniset_core\n\ngroup: propname\n    propname.o\n  deps\n    bytestrie\n\ngroup: unames\n    unames.o\n  deps\n    uchar udata\n\ngroup: script_runs\n    usc_impl.o\n  deps\n    uchar\n\ngroup: uchar\n    uchar.o\n  deps\n    utrie2\n\ngroup: messagepattern  # for MessageFormat and tools\n    messagepattern.o\n  deps\n    patternprops platform\n\ngroup: simpleformatter\n    simpleformatter.o\n  deps\n    platform\n\ngroup: patternprops\n    patternprops.o\n  deps\n    PIC ubsan\n\ngroup: ushape\n    ushape.o\n  deps\n    ubidi_props\n\ngroup: ubidi\n    ubidi.o ubidiln.o ubidiwrt.o\n  deps\n    ubidi_props\n    uchar  # for doWriteReverse() which uses IS_COMBINING(u_charType(c))\n\ngroup: ubiditransform\n    ubiditransform.o\n  deps\n    ubidi ushape\n\ngroup: ubidi_props\n    ubidi_props.o\n  deps\n    utrie2\n\ngroup: unistr_props\n    unistr_props.o\n  deps\n    uchar platform\n\ngroup: unistr_case_locale\n    unistr_case_locale.o\n  deps\n    unistr_case ustring_case_locale\n\ngroup: unistr_case\n    unistr_case.o\n  deps\n    ustring_case\n\ngroup: unistr_titlecase_brkiter\n    unistr_titlecase_brkiter.o\n  deps\n    ustr_titlecase_brkiter\n\ngroup: ustr_titlecase_brkiter\n    ustr_titlecase_brkiter.o\n  deps\n    breakiterator\n    ustring_case_locale ucase\n\ngroup: edits\n    edits.o\n  deps\n    # Edits::Iterator::toString() calls ICU_Utility::appendNumber()\n    icu_utility\n    platform\n\ngroup: ucasemap_titlecase_brkiter\n    ucasemap_titlecase_brkiter.o\n  deps\n    ucasemap breakiterator utext\n    ustr_titlecase_brkiter  # ustrcase_getTitleBreakIterator()\n\ngroup: ucasemap\n    ucasemap.o\n  deps\n    ustring_case ustring_case_locale\n    bytestream bytesinkutil  # for UTF-8 output\n    resourcebundle  # uloc_getName() etc.\n\ngroup: ustring_case_locale\n    ustrcase_locale.o\n  deps\n    ustring_case\n    resourcebundle  # for uloc_getDefault()\n\ngroup: ustring_case\n    ustrcase.o\n  deps\n    ucase uchar edits\n\ngroup: ucase\n    ucase.o\n  deps\n    utrie2\n\ngroup: uinit\n    uinit.o\n  deps\n    ucnv_io icuplug\n\ngroup: converter_selector\n    ucnvsel.o\n  deps\n    conversion propsvec utrie2_builder utrie_swap uset ucnv_set\n\ngroup: ucnvdisp  # ucnv_getDisplayName()\n    ucnvdisp.o\n  deps\n    conversion resourcebundle\n\ngroup: ucnv_set  # ucnv_getUnicodeSet\n    ucnv_set.o\n  deps\n    uset\n\ngroup: conversion\n    ustr_cnv.o\n    ucnv.o ucnv_cnv.o ucnv_bld.o ucnv_cb.o ucnv_err.o\n    ucnv_ct.o\n    ucnvmbcs.o ucnv_ext.o\n    ucnvhz.o ucnvisci.o ucnv_lmb.o ucnv2022.o\n    ucnvlat1.o ucnv_u7.o ucnv_u8.o ucnv_u16.o ucnv_u32.o\n    ucnvbocu.o ucnvscsu.o\n  deps\n    ucnv_io\n\ngroup: ucnv_io\n    ucnv_io.o\n  deps\n    sort stringenumeration udata\n\ngroup: service_registration\n    serv.o servnotf.o servlkf.o servlk.o servls.o servrbf.o servslkf.o\n    locutil.o\n  deps\n    locale_display_names resourcebundle\n    hashtable uvector\n\ngroup: ucat  # message-catalog-like API\n    ucat.o\n  deps\n    resourcebundle\n\ngroup: locale_display_names\n    locdispnames.o  # Locale.getDisplayName()\n  deps\n    locresdata\n\ngroup: locale_display_names2\n    locdspnm.o  # class LocaleDisplayNames\n  deps\n    resourcebundle currency simpleformatter unistr_titlecase_brkiter uchar\n\ngroup: currency\n    ucurr.o\n  deps\n    resourcebundle ulist ustring_case_locale\n    stdlib_qsort  # for ucurr.o (which does not use ICU's uarrsort.o)\n    static_unicode_sets usetiter\n\ngroup: icudataver  # u_getDataVersion()\n    icudataver.o\n  deps\n    resourcebundle\n\ngroup: locresdata\n    # This was intended to collect locale functions that load resource bundle data.\n    # See the resourcebundle group about what else loads data.\n    locresdata.o\n  deps\n    resourcebundle\n\ngroup: resbund_cnv  # paths are Unicode strings\n    resbund_cnv.o\n  deps\n    conversion resourcebundle ures_cnv\n\ngroup: ures_cnv  # ures_openU, path is a Unicode string\n    ures_cnv.o\n  deps\n    conversion resourcebundle\n\ngroup: resourcebundle\n    resource.o resbund.o uresbund.o uresdata.o\n    locavailable.o\n    # uloc_tag.c and uloc_keytype.cpp convert between\n    # old ICU/LDML/CLDR locale IDs and newer BCP 47 IDs.\n    # They use data from resource bundles for some of the mappings.\n    # We might want to generate .h files for that data, to #include rather than load,\n    # to minimize dependencies from this code.\n    # Then we could separate this higher-level locale ID code from the resource bundle code.\n    uloc.o uloc_tag.o uloc_keytype.o\n    # Even basic locid.cpp via Locale constructors and Locale::getDefault()\n    # depend on canonicalization and data loading.\n    # We can probably only disentangle basic locale ID handling from resource bundle code\n    # by hardcoding all of the locale ID data.\n    locid.o locmap.o wintz.o\n    # Do we need class LocaleBased? https://unicode-org.atlassian.net/browse/ICU-8608\n    locbased.o\n    loclikely.o\n  deps\n    udata ucol_swp\n    sort stringenumeration uhash uvector\n    uscript_props propname\n    bytesinkutil\n    errorcode\n\ngroup: localebuilder\n    localebuilder.o\n  deps\n    resourcebundle\n\ngroup: localematcher\n    localematcher.o\n  deps\n    localebuilder localeprioritylist loclikelysubtags locdistance lsr\n\ngroup: localeprioritylist\n    localeprioritylist.o\n  deps\n    resourcebundle\n\ngroup: locdistance\n    locdistance.o\n  deps\n    loclikelysubtags\n\ngroup: loclikelysubtags\n    loclikelysubtags.o\n  deps\n    lsr resourcebundle\n\ngroup: lsr\n    lsr.o\n  deps\n    platform\n\ngroup: udata\n    udata.o ucmndata.o udatamem.o restrace.o\n    umapfile.o\n  deps\n    uhash platform stubdata\n    file_io mmap_functions\n    icu_utility\n\ngroup: unifiedcache\n    unifiedcache.o\n  deps\n    uhash\n    platform\n\ngroup: ucharstriebuilder\n    ucharstriebuilder.o\n  deps\n    ucharstrie stringtriebuilder sort\n\ngroup: ucharstrieiterator\n    ucharstrieiterator.o\n  deps\n    ucharstrie uvector32\n\ngroup: ucharstrie\n    ucharstrie.o\n  deps\n    platform\n\ngroup: bytestriebuilder\n    bytestriebuilder.o\n  deps\n    bytestrie stringtriebuilder sort\n\ngroup: bytestrieiterator\n    bytestrieiterator.o\n  deps\n    bytestrie uvector32\n\ngroup: bytestrie\n    bytestrie.o\n  deps\n    platform\n\ngroup: stringtriebuilder\n    stringtriebuilder.o\n  deps\n    uhash\n\ngroup: propsvec\n    propsvec.o\n  deps\n    sort utrie2_builder\n\ngroup: utrie_swap\n    utrie_swap.o\n  deps\n    udata\n\ngroup: umutablecptrie\n    umutablecptrie.o\n  deps\n    ucptrie\n\ngroup: ucptrie\n    ucptrie.o\n  deps\n    platform\n\ngroup: utrie2_builder\n    utrie2_builder.o\n  deps\n    platform\n    utrie2\n    utrie  # for utrie2_fromUTrie()\n\ngroup: utrie2  # Try to switch users to ucptrie.\n    utrie2.o\n  deps\n    platform\n\ngroup: utrie  # Callers should use ucptrie instead.\n    utrie.o\n  deps\n    platform\n\ngroup: hashtable  # Maps UnicodeString to value.\n    uhash_us.o\n  deps\n    uhash\n\ngroup: uhash\n    uhash.o\n  deps\n    platform\n\ngroup: ustack\n    ustack.o\n  deps\n    uvector\n\ngroup: uvector\n    uvector.o\n  deps\n    platform\n    sort  # for UVector::sort()\n\ngroup: uvector32\n    uvectr32.o\n  deps\n    platform\n\ngroup: uvector64\n    uvectr64.o\n  deps\n    platform\n\ngroup: ulist\n    ulist.o\n  deps\n    platform\n\ngroup: sort\n    uarrsort.o\n  deps\n    platform\n\ngroup: ustr_wcs\n    ustr_wcs.o\n  deps\n    platform\n\ngroup: bytesinkutil\n    bytesinkutil.o\n  deps\n    bytestream edits\n\ngroup: bytestream\n    bytestream.o\n  deps\n    platform\n\ngroup: icuplug\n    icuplug.o\n  deps\n    platform\n\ngroup: ucol_swp\n    ucol_swp.o\n  deps\n    utrie_swap\n\ngroup: errorcode  # ErrorCode base class\n    errorcode.o\n  deps\n    utypes\n    platform\n\ngroup: utypes  # u_errorName()\n    utypes.o\n  deps\n    ubsan\n\ngroup: platform\n    # Files in the \"platform\" group.\n    cmemory.o uobject.o\n    cstring.o cwchar.o uinvchar.o\n    charstr.o\n    unistr.o  # for CharString::appendInvariantChars(const UnicodeString &s, UErrorCode &errorCode)\n    appendable.o stringpiece.o ustrtrns.o  # for unistr.o\n    ustring.o  # Other platform files really just need u_strlen\n    ustrfmt.o  # uprv_itou\n    utf_impl.o\n    putil.o\n    ucln_cmn.o  # for putil.o which calls ucln_common_registerCleanup\n    udataswp.o  # for uinvchar.o; TODO: move uinvchar.o swapper functions to udataswp.o?\n    umath.o\n    umutex.o sharedobject.o\n    utrace.o\n  deps\n    # The \"platform\" group has no ICU dependencies.\n    PIC system_misc system_debug malloc_functions ubsan\n    c_strings c_string_formatting\n    floating_point system_locale\n    stdio_input readlink_function dir_io\n    dlfcn  # Move related code into icuplug.c?\n    cplusplus\n    std_mutex\n\n# ICU i18n library ----------------------------------------------------------- #\n\nlibrary: i18n\n  deps\n    region localedata genderinfo charset_detector spoof_detection\n    alphabetic_index collation collation_builder string_search\n    dayperiodrules\n    listformatter\n    formatting formattable_cnv regex regex_cnv translit\n    double_conversion number_representation number_output numberformatter number_skeletons numberparser\n    units_extra\n    universal_time_scale\n    uclean_i18n\n\ngroup: region\n    region.o uregion.o\n  deps\n    icu_utility\n    resourcebundle\n    uvector uclean_i18n\n\ngroup: localedata\n    ulocdata.o\n  deps\n    uniset_props resourcebundle\n    uset_props  # TODO: change to using C++ UnicodeSet, remove this dependency\n\ngroup: genderinfo\n    gender.o\n  deps\n    resourcebundle\n    uclean_i18n\n\ngroup: charset_detector\n    csdetect.o csmatch.o csr2022.o csrecog.o csrmbcs.o csrsbcs.o csrucode.o csrutf8.o inputext.o ucsdet.o\n  deps\n    conversion\n    uclean_i18n\n\ngroup: spoof_detection\n    uspoof.o uspoof_build.o uspoof_conf.o uspoof_impl.o scriptset.o\n  deps\n    uniset_props regex unorm uscript\n\ngroup: alphabetic_index\n    alphaindex.o\n  deps\n    collation localedata\n    uclean_i18n\n\ngroup: collation\n    # The collation \"runtime\" code should not depend on the collation_builder code.\n    # For example, loading from resource bundles does not fall back to\n    # building from rules.\n    collation.o collationcompare.o collationdata.o\n    collationdatareader.o collationdatawriter.o\n    collationfastlatin.o collationfcd.o collationiterator.o collationkeys.o\n    collationroot.o collationrootelements.o collationsets.o\n    collationsettings.o collationtailoring.o rulebasedcollator.o\n    uitercollationiterator.o utf16collationiterator.o utf8collationiterator.o\n    bocsu.o coleitr.o coll.o sortkey.o ucol.o\n    ucol_res.o ucol_sit.o ucoleitr.o\n  deps\n    bytestream normalizer2 resourcebundle service_registration unifiedcache\n    ucharstrieiterator uiter ulist uset usetiter uvector32 uvector64 utrie2\n    uclean_i18n propname\n\ngroup: collation_builder\n    collationbuilder.o collationdatabuilder.o collationfastlatinbuilder.o\n    collationruleparser.o collationweights.o\n  deps\n    canonical_iterator collation ucharstriebuilder uset_props\n\ngroup: string_search\n    search.o stsearch.o usearch.o\n  deps\n    breakiterator collation\n\ngroup: dayperiodrules\n    dayperiodrules.o\n  deps\n    resourcebundle uclean_i18n\n\ngroup: listformatter\n    listformatter.o ulistformatter.o\n  deps\n    uchar resourcebundle simpleformatter format uclean_i18n formatted_value_iterimpl\n\ngroup: double_conversion\n    double-conversion-bignum.o double-conversion-double-to-string.o\n    double-conversion-bignum-dtoa.o double-conversion-cached-powers.o\n    double-conversion-string-to-double.o double-conversion-fast-dtoa.o\n    double-conversion-strtod.o\n  deps\n    platform\n\ngroup: number_representation\n    number_decimalquantity.o string_segment.o number_utils.o\n    # TODO(ICU-21058) Move formatted_string_builder to its own unit.\n    formatted_string_builder.o\n  deps\n    decnumber double_conversion\n    # for trimming whitespace around fields\n    static_unicode_sets\n    # for data loading; that could be split off\n    resourcebundle\n    int_functions\n    ucase uniset_core\n    formatted_value\n\ngroup: number_output\n    # PluralRules and FormattedNumber\n    number_output.o\n    standardplural.o plurrule.o\n  deps\n    # FormattedNumber internals:\n    number_representation format formatted_value_sbimpl\n    # PluralRules internals:\n    unifiedcache\n\ngroup: numberformatter\n    # ICU 60+ NumberFormatter API\n    number_affixutils.o\n    number_compact.o number_currencysymbols.o\n    number_decimfmtprops.o\n    number_fluent.o number_formatimpl.o\n    number_grouping.o number_integerwidth.o number_longnames.o\n    number_mapper.o number_modifiers.o number_multiplier.o\n    number_notation.o number_padding.o\n    number_patternmodifier.o number_patternstring.o number_rounding.o\n    number_scientific.o\n    currpinf.o dcfmtsym.o numsys.o\n    numrange_fluent.o numrange_impl.o\n  deps\n    decnumber double_conversion formattable units\n    number_representation number_output\n    uclean_i18n common\n\ngroup: number_skeletons\n    # Number skeleton support; separated from numberformatter\n    number_skeletons.o number_capi.o number_asformat.o\n  deps\n    numberformatter\n    units_extra\n\ngroup: numberparser\n    numparse_affixes.o numparse_compositions.o numparse_currency.o\n    numparse_decimal.o numparse_impl.o numparse_parsednumber.o\n    numparse_scientific.o numparse_symbols.o\n    numparse_validators.o\n  deps\n    numberformatter\n\ngroup: formatting\n    # TODO: Try to subdivide this ball of wax.\n    # currencyformat\n    curramt.o currfmt.o\n    # pluralrules C API\n    upluralrules.o\n    # decimalformat\n    unumsys.o\n    decimfmt.o compactdecimalformat.o\n    numfmt.o unum.o\n    winnmfmt.o\n    # scientificnumberformatter - would depend on dcfmtsym, so would be circular.\n    scientificnumberformatter.o\n    # rbnf\n    nfrs.o nfrule.o nfsubs.o rbnf.o\n    # measureformat\n    measfmt.o quantityformatter.o\n    # dateformat\n    astro.o buddhcal.o calendar.o cecal.o chnsecal.o coptccal.o dangical.o ethpccal.o\n    gregocal.o gregoimp.o hebrwcal.o indiancal.o islamcal.o japancal.o persncal.o taiwncal.o\n    erarules.o  # mostly for Japanese eras\n    ucal.o\n    basictz.o olsontz.o rbtz.o simpletz.o timezone.o tzrule.o tztrans.o\n    vtzone.o vzone.o wintzimpl.o zonemeta.o zrule.o ztrans.o\n    tzfmt.o tzgnames.o tznames.o tznames_impl.o\n    datefmt.o dtfmtsym.o dtitvfmt.o dtitvinf.o dtptngen.o dtrule.o reldtfmt.o reldatefmt.o\n    smpdtfmt.o smpdtfst.o udateintervalformat.o udatpg.o windtfmt.o\n    udat.o\n    tmunit.o tmutamt.o tmutfmt.o\n    # messageformat\n    choicfmt.o msgfmt.o plurfmt.o selfmt.o umsg.o\n  deps\n    decnumber formattable format units numberformatter number_skeletons numberparser\n    formatted_value_sbimpl\n    listformatter\n    dayperiodrules\n    collation collation_builder  # for rbnf\n    common\n    floating_point  # sqrt() for astro.o\n    trigonometry  # for astro.o\n    sharedbreakiterator # for reldatefmt.o\n    uclean_i18n\n    region\n\ngroup: sharedbreakiterator\n    sharedbreakiterator.o\n  deps\n    breakiterator\n\ngroup: units_extra\n    measunit_extra.o\n  deps\n    units ucharstriebuilder ucharstrie uclean_i18n\n\ngroup: units\n    measunit.o currunit.o nounit.o\n  deps\n    stringenumeration errorcode\n\ngroup: decnumber\n    decContext.o decNumber.o\n  deps\n    double_conversion uclean_i18n\n\ngroup: formattable\n    fmtable.o\n    measure.o\n  deps\n    decnumber number_representation\n\ngroup: formattable_cnv\n    fmtable_cnv.o\n  deps\n    formattable unistr_cnv conversion\n\ngroup: formatted_value\n    formattedvalue.o\n  deps\n    platform\n\ngroup: formatted_value_iterimpl\n    formattedval_iterimpl.o\n  deps\n    formatted_value format uvector32\n\ngroup: formatted_value_sbimpl\n    formattedval_sbimpl.o\n  deps\n    number_representation\n\ngroup: format\n    format.o fphdlimp.o fpositer.o ufieldpositer.o\n  deps\n    resourcebundle parsepos uvector32\n\ngroup: regex_cnv\n    uregexc.o\n  deps\n    regex unistr_cnv\n\ngroup: regex\n    regexcmp.o regexst.o regextxt.o regeximp.o rematch.o repattrn.o uregex.o\n  deps\n    uniset_closure utext uvector32 uvector64 ustack\n    breakiterator\n    uinit  # TODO: Really needed?\n    uclean_i18n\n\ngroup: translit\n    anytrans.o brktrans.o casetrn.o cpdtrans.o name2uni.o uni2name.o nortrans.o remtrans.o titletrn.o tolowtrn.o toupptrn.o\n    esctrn.o unesctrn.o nultrans.o\n    funcrepl.o quant.o rbt.o rbt_data.o rbt_pars.o rbt_rule.o rbt_set.o strmatch.o strrepl.o translit.o transreg.o tridpars.o utrans.o\n  deps\n    common\n    formatting  # for Transliterator::getDisplayName()\n    uclean_i18n\n\ngroup: universal_time_scale\n    utmscale.o\n  deps\n    ubsan\n\ngroup: uclean_i18n\n    ucln_in.o\n  deps\n    platform\n\n# ICU io library ------------------------------------------------------------- #\n\nlibrary: io\n  deps\n    ustdio ustream uclean_io\n\ngroup: ustdio\n    locbund.o sprintf.o sscanf.o ufile.o ufmt_cmn.o uprintf.o uprntf_p.o uscanf.o uscanf_p.o ustdio.o\n  deps\n    formatting conversion translit\n    uclean_io\n    stdio_output\n\ngroup: ustream\n    ustream.o\n  deps\n    unistr_cnv\n    uchar  # for u_isWhitespace()\n    iostream\n\ngroup: uclean_io\n    ucln_io.o\n  deps\n    platform\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/ISO-8859-2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/koi8r.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/ISO-8859-3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/hangul-eucKR.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/danish-ISO-8859-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/hania-eucKR.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/eucJP.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/iso8859-1.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/extra/uconv/samples/ibm-37-test.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/nfkc.nrm",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/ulayout.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/nfc.nrm",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/ucase.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/nfkc_cf.nrm",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/uprops.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/icudt67l.dat",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/uts46.nrm",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/pnames.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/ubidi.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/unames.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/coll/ucadata-implicithan.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/data/in/coll/ucadata-unihan.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/uni-text.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/old_l_testtypes.res",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/old_e_testtypes.res",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/TestFont1.otf",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/idna_conf.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/testdata/encoded.utf16be",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/test/fuzzer/collator_rulebased_fuzzer_seed_corpus.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/samples/uresb/sr.txt",
        "/tmp/vanessa/spack-stage/spack-stage-icu4c-67.1-vf6ge6vvf7uaphhcvvcxyzcvluc2ro5m/spack-src/source/samples/ucnv/data02.bin"
    ],
    "total_files": 2302
}