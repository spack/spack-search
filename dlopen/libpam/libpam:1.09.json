{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libpam-1.09-h77h3yhuj45rxzdw47qeln5sfxliavnl/spack-src/configure.ac": "AC_PREREQ(2.61)\nAC_INIT(google-authenticator, 1.09, habets@google.com)\nAC_CONFIG_SRCDIR([src/google-authenticator.c])\nAC_CONFIG_AUX_DIR([build])\nAC_CONFIG_MACRO_DIR([build])\n\n# --enable-silent-rules\nm4_ifdef([AM_SILENT_RULES],\n  [AM_SILENT_RULES([yes])],\n  [AC_SUBST([AM_DEFAULT_VERBOSITY], [1])])\n\nAC_USE_SYSTEM_EXTENSIONS\nAM_INIT_AUTOMAKE([foreign subdir-objects])\nAM_MAINTAINER_MODE([enable])\n\nLT_INIT\nAC_PROG_CC\nAC_PROG_CC_STDC\n\nAC_CHECK_HEADERS([sys/fsuid.h])\nAC_CHECK_FUNCS([ \\\n\texplicit_bzero \\\n\tsetfsuid \\\n\tsetfsgid \\\n])\n\nAC_CHECK_HEADERS_ONCE([security/pam_appl.h])\n# On Solaris at least, <security/pam_modules.h> requires <security/pam_appl.h>\n# to be included first\nAC_CHECK_HEADER([security/pam_modules.h], [], [], \\\n\t\t[#ifdef HAVE_SECURITY_PAM_APPL_H\n\t\t# include <security/pam_appl.h>\n\t\t#endif\n\t\t])\nAC_CHECK_LIB([pam], [pam_get_user], [:])\nAS_IF([test \"x$ac_cv_header_security_pam_modules_h\" = \"xno\" \\\n       -o \"x$ac_cv_lib_pam_pam_get_user\" = \"xno\"], [\n  AC_MSG_ERROR([Unable to find the PAM library or the PAM header files])\n])\n\nAC_MSG_CHECKING([whether certain PAM functions require const arguments])\nAC_LANG_PUSH(C)\n# Force test to bail if const isn't needed\nAC_LANG_WERROR\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t#include <security/pam_appl.h>\n\t#include <security/pam_modules.h>\n]],[[\n\tconst void **item = 0;\n\tint dummy = 0;\n\t/*\n\t * since pam_handle_t is opaque on at least some platforms, give it\n\t * a non-NULL dummy value\n\t */\n\t const pam_handle_t *ph = (const pam_handle_t *)&dummy;\n\t(void) pam_get_item(ph, 0, item);\n]])],[AC_DEFINE([PAM_CONST], [const], \\\n\t[Define if certain PAM functions require const arguments])\n\t\tAC_MSG_RESULT([yes])],\n\t[AC_DEFINE([PAM_CONST], [], \\\n\t[Prevent certain PAM functions from using const arguments])\n\tAC_MSG_RESULT([no])])\n\n\n\tAC_MSG_CHECKING(whether compiler understands -Wall)\n\told_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -Wall\"\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],\n\t  AC_MSG_RESULT(yes),\n\t  AC_MSG_RESULT(no)\n\t  CFLAGS=\"$old_CFLAGS\")\n\nAC_LANG_POP(C)\n\n\n\nAC_SEARCH_LIBS([dlopen], [dl])\n\nAC_CONFIG_HEADER(config.h)\nAC_CONFIG_FILES([Makefile contrib/rpm.spec])\nAC_OUTPUT\n\necho \"\n  $PACKAGE_NAME version $PACKAGE_VERSION\n  Prefix.........: $prefix\n  Debug Build....: $debug\n  C Compiler.....: $CC $CFLAGS $CPPFLAGS\n  Linker.........: $LD $LDFLAGS $LIBS\n\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-libpam-1.09-h77h3yhuj45rxzdw47qeln5sfxliavnl/spack-src/src/google-authenticator.c": "// Helper program to generate a new secret for use in two-factor\n// authentication.\n//\n// Copyright 2010 Google Inc.\n// Author: Markus Gutschke\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"base32.h\"\n#include \"hmac.h\"\n#include \"sha1.h\"\n\n#define SECRET                    \"/.google_authenticator\"\n#define SECRET_BITS               128         // Must be divisible by eight\n#define VERIFICATION_CODE_MODULUS (1000*1000) // Six digits\n#define SCRATCHCODES              5           // Default number of initial scratchcodes\n#define MAX_SCRATCHCODES          10          // Max number of initial scratchcodes\n#define SCRATCHCODE_LENGTH        8           // Eight digits per scratchcode\n#define BYTES_PER_SCRATCHCODE     4           // 32bit of randomness is enough\n#define BITS_PER_BASE32_CHAR      5           // Base32 expands space by 8/5\n\nstatic enum { QR_UNSET=0, QR_NONE, QR_ANSI, QR_UTF8 } qr_mode = QR_UNSET;\n\nstatic int generateCode(const char *key, unsigned long tm) {\n  uint8_t challenge[8];\n  for (int i = 8; i--; tm >>= 8) {\n    challenge[i] = tm;\n  }\n\n  // Estimated number of bytes needed to represent the decoded secret. Because\n  // of white-space and separators, this is an upper bound of the real number,\n  // which we later get as a return-value from base32_decode()\n  int secretLen = (strlen(key) + 7)/8*BITS_PER_BASE32_CHAR;\n\n  // Sanity check, that our secret will fixed into a reasonably-sized static\n  // array.\n  if (secretLen <= 0 || secretLen > 100) {\n    return -1;\n  }\n\n  // Decode secret from Base32 to a binary representation, and check that we\n  // have at least one byte's worth of secret data.\n  uint8_t secret[100];\n  if ((secretLen = base32_decode((const uint8_t *)key, secret, secretLen))<1) {\n    return -1;\n  }\n\n  // Compute the HMAC_SHA1 of the secret and the challenge.\n  uint8_t hash[SHA1_DIGEST_LENGTH];\n  hmac_sha1(secret, secretLen, challenge, 8, hash, SHA1_DIGEST_LENGTH);\n\n  // Pick the offset where to sample our hash value for the actual verification\n  // code.\n  const int offset = hash[SHA1_DIGEST_LENGTH - 1] & 0xF;\n\n  // Compute the truncated hash in a byte-order independent loop.\n  unsigned int truncatedHash = 0;\n  for (int i = 0; i < 4; ++i) {\n    truncatedHash <<= 8;\n    truncatedHash  |= hash[offset + i];\n  }\n\n  // Truncate to a smaller number of digits.\n  truncatedHash &= 0x7FFFFFFF;\n  truncatedHash %= VERIFICATION_CODE_MODULUS;\n\n  return truncatedHash;\n}\n\n// return the user name in heap-allocated buffer.\n// Caller frees.\nstatic const char *getUserName(uid_t uid) {\n  struct passwd pwbuf, *pw;\n  char *buf;\n  #ifdef _SC_GETPW_R_SIZE_MAX\n  int len = sysconf(_SC_GETPW_R_SIZE_MAX);\n  if (len <= 0) {\n    len = 4096;\n  }\n  #else\n  int len = 4096;\n  #endif\n  buf = malloc(len);\n  char *user;\n  if (getpwuid_r(uid, &pwbuf, buf, len, &pw) || !pw) {\n    user = malloc(32);\n    snprintf(user, 32, \"%d\", uid);\n  } else {\n    user = strdup(pw->pw_name);\n    if (!user) {\n      perror(\"malloc()\");\n      _exit(1);\n    }\n  }\n  free(buf);\n  return user;\n}\n\nstatic const char *urlEncode(const char *s) {\n  const size_t size = 3 * strlen(s) + 1;\n  if (size > 10000) {\n    // Anything \"too big\" is too suspect to let through.\n    fprintf(stderr, \"Error: Generated URL would be unreasonably large.\\n\");\n    exit(1);\n  }\n  char *ret = malloc(size);\n  char *d = ret;\n  do {\n    switch (*s) {\n    case '%':\n    case '&':\n    case '?':\n    case '=':\n    encode:\n      snprintf(d, size-(d-ret), \"%%%02X\", (unsigned char)*s);\n      d += 3;\n      break;\n    default:\n      if ((*s && *s <= ' ') || *s >= '\\x7F') {\n        goto encode;\n      }\n      *d++ = *s;\n      break;\n    }\n  } while (*s++);\n  char* newret = realloc(ret, strlen(ret) + 1);\n  if (newret) {\n    ret = newret;\n  }\n  return ret;\n}\n\nstatic const char *getURL(const char *secret, const char *label,\n                          char **encoderURL, const int use_totp, const char *issuer) {\n  const char *encodedLabel = urlEncode(label);\n  char *url;\n  const char totp = use_totp ? 't' : 'h';\n  if (asprintf(&url, \"otpauth://%cotp/%s?secret=%s\", totp, encodedLabel, secret) < 0) {\n    fprintf(stderr, \"String allocation failed, probably running out of memory.\\n\");\n    _exit(1);\n  }\n\n  if (issuer != NULL && strlen(issuer) > 0) {\n    // Append to URL &issuer=<issuer>\n    const char *encodedIssuer = urlEncode(issuer);\n    char *newUrl;\n    if (asprintf(&newUrl, \"%s&issuer=%s\", url, encodedIssuer) < 0) {\n      fprintf(stderr, \"String allocation failed, probably running out of memory.\\n\");\n      _exit(1);\n    }\n    free((void *)encodedIssuer);\n    free(url);\n    url = newUrl;\n  }\n\n  if (encoderURL) {\n    // Show a QR code.\n    const char *encoder = \"https://www.google.com/chart?chs=200x200&\"\n                          \"chld=M|0&cht=qr&chl=\";\n    const char *encodedURL = urlEncode(url);\n\n    *encoderURL = strcat(strcpy(malloc(strlen(encoder) +\n                                       strlen(encodedURL) + 1),\n                                encoder), encodedURL);\n    free((void *)encodedURL);\n  }\n  free((void *)encodedLabel);\n  return url;\n}\n\n#define ANSI_RESET        \"\\x1B[0m\"\n#define ANSI_BLACKONGREY  \"\\x1B[30;47;27m\"\n#define ANSI_WHITE        \"\\x1B[27m\"\n#define ANSI_BLACK        \"\\x1B[7m\"\n#define UTF8_BOTH         \"\\xE2\\x96\\x88\"\n#define UTF8_TOPHALF      \"\\xE2\\x96\\x80\"\n#define UTF8_BOTTOMHALF   \"\\xE2\\x96\\x84\"\n\n// Display QR code visually. If not possible, return 0.\nstatic int displayQRCode(const char* url) {\n  void *qrencode = dlopen(\"libqrencode.so.2\", RTLD_NOW | RTLD_LOCAL);\n  if (!qrencode) {\n    qrencode = dlopen(\"libqrencode.so.3\", RTLD_NOW | RTLD_LOCAL);\n  }\n  if (!qrencode) {\n    qrencode = dlopen(\"libqrencode.so.4\", RTLD_NOW | RTLD_LOCAL);\n  }\n  if (!qrencode) {\n    qrencode = dlopen(\"libqrencode.3.dylib\", RTLD_NOW | RTLD_LOCAL);\n  }\n  if (!qrencode) {\n    qrencode = dlopen(\"libqrencode.4.dylib\", RTLD_NOW | RTLD_LOCAL);\n  }\n  if (!qrencode) {\n    return 0;\n  }\n  typedef struct {\n    int version;\n    int width;\n    unsigned char *data;\n  } QRcode;\n  QRcode *(*QRcode_encodeString8bit)(const char *, int, int) =\n      (QRcode *(*)(const char *, int, int))\n      dlsym(qrencode, \"QRcode_encodeString8bit\");\n  void (*QRcode_free)(QRcode *qrcode) =\n      (void (*)(QRcode *))dlsym(qrencode, \"QRcode_free\");\n  if (!QRcode_encodeString8bit || !QRcode_free) {\n    dlclose(qrencode);\n    return 0;\n  }\n  QRcode *qrcode = QRcode_encodeString8bit(url, 0, 1);\n  const char *ptr = (char *)qrcode->data;\n  // Output QRCode using ANSI colors. Instead of black on white, we\n  // output black on grey, as that works independently of whether the\n  // user runs their terminal in a black on white or white on black color\n  // scheme.\n  // But this requires that we print a border around the entire QR Code.\n  // Otherwise readers won't be able to recognize it.\n  if (qr_mode != QR_UTF8) {\n    for (int i = 0; i < 2; ++i) {\n      printf(ANSI_BLACKONGREY);\n      for (int x = 0; x < qrcode->width + 4; ++x) printf(\"  \");\n      puts(ANSI_RESET);\n    }\n    for (int y = 0; y < qrcode->width; ++y) {\n      printf(ANSI_BLACKONGREY\"    \");\n      int isBlack = 0;\n      for (int x = 0; x < qrcode->width; ++x) {\n        if (*ptr++ & 1) {\n          if (!isBlack) {\n            printf(ANSI_BLACK);\n          }\n          isBlack = 1;\n        } else {\n          if (isBlack) {\n            printf(ANSI_WHITE);\n          }\n          isBlack = 0;\n        }\n        printf(\"  \");\n      }\n      if (isBlack) {\n        printf(ANSI_WHITE);\n      }\n      puts(\"    \"ANSI_RESET);\n    }\n    for (int i = 0; i < 2; ++i) {\n      printf(ANSI_BLACKONGREY);\n      for (int x = 0; x < qrcode->width + 4; ++x) printf(\"  \");\n      puts(ANSI_RESET);\n    }\n  } else {\n    // Drawing the QRCode with Unicode block elements is desirable as\n    // it makes the code much smaller, which is often easier to scan.\n    // Unfortunately, many terminal emulators do not display these\n    // Unicode characters properly.\n    printf(ANSI_BLACKONGREY);\n    for (int i = 0; i < qrcode->width + 4; ++i) {\n      printf(\" \");\n    }\n    puts(ANSI_RESET);\n    for (int y = 0; y < qrcode->width; y += 2) {\n      printf(ANSI_BLACKONGREY\"  \");\n      for (int x = 0; x < qrcode->width; ++x) {\n        const int top = qrcode->data[y*qrcode->width + x] & 1;\n        int bottom = 0;\n        if (y+1 < qrcode->width) {\n          bottom = qrcode->data[(y+1)*qrcode->width + x] & 1;\n        }\n        if (top) {\n          if (bottom) {\n            printf(UTF8_BOTH);\n          } else {\n            printf(UTF8_TOPHALF);\n          }\n        } else {\n          if (bottom) {\n            printf(UTF8_BOTTOMHALF);\n          } else {\n            printf(\" \");\n          }\n        }\n      }\n      puts(\"  \"ANSI_RESET);\n    }\n    printf(ANSI_BLACKONGREY);\n    for (int i = 0; i < qrcode->width + 4; ++i) {\n      printf(\" \");\n    }\n    puts(ANSI_RESET);\n  }\n  QRcode_free(qrcode);\n  dlclose(qrencode);\n  return 1;\n}\n\n// Display to the user what they need to provision their app.\nstatic void displayEnrollInfo(const char *secret, const char *label,\n                              const int use_totp, const char *issuer) {\n  if (qr_mode == QR_NONE) {\n    return;\n  }\n  char *encoderURL;\n  const char *url = getURL(secret, label, &encoderURL, use_totp, issuer);\n  printf(\"Warning: pasting the following URL into your browser exposes the OTP secret to Google:\\n  %s\\n\", encoderURL);\n\n  // Only newer systems have support for libqrencode. So instead of requiring\n  // it at build-time we look for it at run-time. If it cannot be found, the\n  // user can still type the code in manually or copy the URL into\n  // their browser.\n  if (isatty(STDOUT_FILENO)) {\n    if (!displayQRCode(url)) {\n      printf(\n          \"Failed to use libqrencode to show QR code visually for scanning.\\n\"\n          \"Consider typing the OTP secret into your app manually.\\n\");\n    }\n  }\n\n  free((char *)url);\n  free(encoderURL);\n}\n\n// ask for a code. Return code, or some garbage if no number given. That's fine\n// because bad data also won't match code.\nstatic int ask_code(const char* msg) {\n  char line[128];\n  printf(\"%s \", msg);\n  fflush(stdout);\n\n  line[sizeof(line)-1] = 0;\n  if (NULL == fgets(line, sizeof line, stdin)) {\n    if (errno == 0) {\n      printf(\"\\n\");\n    } else {\n      perror(\"getline()\");\n    }\n    exit(1);\n  }\n\n  return strtol(line, NULL, 10);\n}\n\n// ask y/n, and return 0 for no, 1 for yes.\nstatic int maybe(const char *msg) {\n  printf(\"\\n\");\n  for (;;) {\n    char line[128];\n    printf(\"%s (y/n) \", msg);\n    fflush(stdout);\n\n    line[sizeof(line)-1] = 0;\n    if (NULL == fgets(line, sizeof(line), stdin)) {\n      if (errno == 0) {\n        printf(\"\\n\");\n      } else {\n        perror(\"getline()\");\n      }\n      exit(1);\n    }\n    switch (line[0]) {\n    case 'Y':\n    case 'y':\n      return 1;\n    case 'N':\n    case 'n':\n      return 0;\n    }\n  }\n}\n\nstatic char *addOption(char *buf, size_t nbuf, const char *option) {\n  assert(strlen(buf) + strlen(option) < nbuf);\n  char *scratchCodes = strchr(buf, '\\n');\n  assert(scratchCodes);\n  scratchCodes++;\n  memmove(scratchCodes + strlen(option), scratchCodes,\n          strlen(scratchCodes) + 1);\n  memcpy(scratchCodes, option, strlen(option));\n  return buf;\n}\n\nstatic char *maybeAddOption(const char *msg, char *buf, size_t nbuf,\n                            const char *option) {\n  if (maybe(msg)) {\n    buf = addOption(buf, nbuf, option);\n  }\n  return buf;\n}\n\nstatic void\nprint_version() {\n  puts(\"google-authenticator \"VERSION);\n}\n\nstatic void usage(void) {\n  print_version();\n  puts(\n \"google-authenticator [<options>]\\n\"\n \" -h, --help                     Print this message\\n\"\n \"     --version                  Print version\\n\"\n \" -c, --counter-based            Set up counter-based (HOTP) verification\\n\"\n \" -C, --no-confirm               Don't confirm code. For non-interactive setups\\n\"\n \" -t, --time-based               Set up time-based (TOTP) verification\\n\"\n \" -d, --disallow-reuse           Disallow reuse of previously used TOTP tokens\\n\"\n \" -D, --allow-reuse              Allow reuse of previously used TOTP tokens\\n\"\n \" -f, --force                    Write file without first confirming with user\\n\"\n \" -l, --label=<label>            Override the default label in \\\"otpauth://\\\" URL\\n\"\n \" -i, --issuer=<issuer>          Override the default issuer in \\\"otpauth://\\\" URL\\n\"\n \" -q, --quiet                    Quiet mode\\n\"\n \" -Q, --qr-mode={NONE,ANSI,UTF8} QRCode output mode\\n\"\n \" -r, --rate-limit=N             Limit logins to N per every M seconds\\n\"\n \" -R, --rate-time=M              Limit logins to N per every M seconds\\n\"\n \" -u, --no-rate-limit            Disable rate-limiting\\n\"\n \" -s, --secret=<file>            Specify a non-standard file location\\n\"\n \" -S, --step-size=S              Set interval between token refreshes\\n\"\n \" -w, --window-size=W            Set window of concurrently valid codes\\n\"\n \" -W, --minimal-window           Disable window of concurrently valid codes\\n\"\n \" -e, --emergency-codes=N        Number of emergency codes to generate\");\n}\n\nint main(int argc, char *argv[]) {\n  uint8_t buf[SECRET_BITS/8 + MAX_SCRATCHCODES*BYTES_PER_SCRATCHCODE];\n  static const char hotp[]      = \"\\\" HOTP_COUNTER 1\\n\";\n  static const char totp[]      = \"\\\" TOTP_AUTH\\n\";\n  static const char disallow[]  = \"\\\" DISALLOW_REUSE\\n\";\n  static const char step[]      = \"\\\" STEP_SIZE 30\\n\";\n  static const char window[]    = \"\\\" WINDOW_SIZE 17\\n\";\n  static const char ratelimit[] = \"\\\" RATE_LIMIT 3 30\\n\";\n  char secret[(SECRET_BITS + BITS_PER_BASE32_CHAR-1)/BITS_PER_BASE32_CHAR +\n              1 /* newline */ +\n              sizeof(hotp) +  // hotp and totp are mutually exclusive.\n              sizeof(disallow) +\n              sizeof(step) +\n              sizeof(window) +\n              sizeof(ratelimit) + 5 + // NN MMM (total of five digits)\n              SCRATCHCODE_LENGTH*(MAX_SCRATCHCODES + 1 /* newline */) +\n              1 /* NUL termination character */];\n\n  enum { ASK_MODE, HOTP_MODE, TOTP_MODE } mode = ASK_MODE;\n  enum { ASK_REUSE, DISALLOW_REUSE, ALLOW_REUSE } reuse = ASK_REUSE;\n  int force = 0, quiet = 0;\n  int r_limit = 0, r_time = 0;\n  char *secret_fn = NULL;\n  char *label = NULL;\n  char *issuer = NULL;\n  int step_size = 0;\n  int confirm = 1;\n  int window_size = 0;\n  int emergency_codes = -1;\n  int idx;\n  for (;;) {\n    static const char optstring[] = \"+hcCtdDfl:i:qQ:r:R:us:S:w:We:\";\n    static struct option options[] = {\n      { \"help\",             0, 0, 'h' },\n      { \"version\",          0, 0, 0},\n      { \"counter-based\",    0, 0, 'c' },\n      { \"no-confirm\",       0, 0, 'C' },\n      { \"time-based\",       0, 0, 't' },\n      { \"disallow-reuse\",   0, 0, 'd' },\n      { \"allow-reuse\",      0, 0, 'D' },\n      { \"force\",            0, 0, 'f' },\n      { \"label\",            1, 0, 'l' },\n      { \"issuer\",           1, 0, 'i' },\n      { \"quiet\",            0, 0, 'q' },\n      { \"qr-mode\",          1, 0, 'Q' },\n      { \"rate-limit\",       1, 0, 'r' },\n      { \"rate-time\",        1, 0, 'R' },\n      { \"no-rate-limit\",    0, 0, 'u' },\n      { \"secret\",           1, 0, 's' },\n      { \"step-size\",        1, 0, 'S' },\n      { \"window-size\",      1, 0, 'w' },\n      { \"minimal-window\",   0, 0, 'W' },\n      { \"emergency-codes\",  1, 0, 'e' },\n      { 0,                  0, 0,  0  }\n    };\n    idx = -1;\n    const int c = getopt_long(argc, argv, optstring, options, &idx);\n    if (c > 0) {\n      for (int i = 0; options[i].name; i++) {\n        if (options[i].val == c) {\n          idx = i;\n          break;\n        }\n      }\n    } else if (c < 0) {\n      break;\n    }\n    if (idx-- <= 0) {\n      // Help (or invalid argument)\n    err:\n      usage();\n      if (idx < -1) {\n        fprintf(stderr, \"Failed to parse command line\\n\");\n        _exit(1);\n      }\n      exit(0);\n    } else if (!idx--) {\n      // --version\n      print_version();\n      exit(0);\n    } else if (!idx--) {\n      // counter-based, -c\n      if (mode != ASK_MODE) {\n        fprintf(stderr, \"Duplicate -c and/or -t option detected\\n\");\n        _exit(1);\n      }\n      if (reuse != ASK_REUSE) {\n      reuse_err:\n        fprintf(stderr, \"Reuse of tokens is not a meaningful parameter \"\n                \"in counter-based mode\\n\");\n        _exit(1);\n      }\n      mode = HOTP_MODE;\n    } else if (!idx--) {\n      // don't confirm code provisioned, -C\n      confirm = 0;\n    } else if (!idx--) {\n      // time-based\n      if (mode != ASK_MODE) {\n        fprintf(stderr, \"Duplicate -c and/or -t option detected\\n\");\n        _exit(1);\n      }\n      mode = TOTP_MODE;\n    } else if (!idx--) {\n      // disallow-reuse\n      if (reuse != ASK_REUSE) {\n        fprintf(stderr, \"Duplicate -d and/or -D option detected\\n\");\n        _exit(1);\n      }\n      if (mode == HOTP_MODE) {\n        goto reuse_err;\n      }\n      reuse = DISALLOW_REUSE;\n    } else if (!idx--) {\n      // allow-reuse\n      if (reuse != ASK_REUSE) {\n        fprintf(stderr, \"Duplicate -d and/or -D option detected\\n\");\n        _exit(1);\n      }\n      if (mode == HOTP_MODE) {\n        goto reuse_err;\n      }\n      reuse = ALLOW_REUSE;\n    } else if (!idx--) {\n      // force\n      if (force) {\n        fprintf(stderr, \"Duplicate -f option detected\\n\");\n        _exit(1);\n      }\n      force = 1;\n    } else if (!idx--) {\n      // label\n      if (label) {\n        fprintf(stderr, \"Duplicate -l option detected\\n\");\n        _exit(1);\n      }\n      label = strdup(optarg);\n    } else if (!idx--) {\n      // issuer\n      if (issuer) {\n        fprintf(stderr, \"Duplicate -i option detected\\n\");\n        _exit(1);\n      }\n      issuer = strdup(optarg);\n    } else if (!idx--) {\n      // quiet\n      if (quiet) {\n        fprintf(stderr, \"Duplicate -q option detected\\n\");\n        _exit(1);\n      }\n      quiet = 1;\n    } else if (!idx--) {\n      // qr-mode\n      if (qr_mode != QR_UNSET) {\n        fprintf(stderr, \"Duplicate -Q option detected\\n\");\n        _exit(1);\n      }\n      if (!strcasecmp(optarg, \"none\")) {\n        qr_mode = QR_NONE;\n      } else if (!strcasecmp(optarg, \"ansi\")) {\n        qr_mode = QR_ANSI;\n      } else if (!strcasecmp(optarg, \"utf8\")) {\n        qr_mode = QR_UTF8;\n      } else {\n        fprintf(stderr, \"Invalid qr-mode \\\"%s\\\"\\n\", optarg);\n        _exit(1);\n      }\n    } else if (!idx--) {\n      // rate-limit\n      if (r_limit > 0) {\n        fprintf(stderr, \"Duplicate -r option detected\\n\");\n        _exit(1);\n      } else if (r_limit < 0) {\n        fprintf(stderr, \"-u is mutually exclusive with -r\\n\");\n        _exit(1);\n      }\n      char *endptr;\n      errno = 0;\n      const long l = strtol(optarg, &endptr, 10);\n      if (errno || endptr == optarg || *endptr || l < 1 || l > 10) {\n        fprintf(stderr, \"-r requires an argument in the range 1..10\\n\");\n        _exit(1);\n      }\n      r_limit = (int)l;\n    } else if (!idx--) {\n      // rate-time\n      if (r_time > 0) {\n        fprintf(stderr, \"Duplicate -R option detected\\n\");\n        _exit(1);\n      } else if (r_time < 0) {\n        fprintf(stderr, \"-u is mutually exclusive with -R\\n\");\n        _exit(1);\n      }\n      char *endptr;\n      errno = 0;\n      const long l = strtol(optarg, &endptr, 10);\n      if (errno || endptr == optarg || *endptr || l < 15 || l > 600) {\n        fprintf(stderr, \"-R requires an argument in the range 15..600\\n\");\n        _exit(1);\n      }\n      r_time = (int)l;\n    } else if (!idx--) {\n      // no-rate-limit\n      if (r_limit > 0 || r_time > 0) {\n        fprintf(stderr, \"-u is mutually exclusive with -r/-R\\n\");\n        _exit(1);\n      }\n      if (r_limit < 0) {\n        fprintf(stderr, \"Duplicate -u option detected\\n\");\n        _exit(1);\n      }\n      r_limit = r_time = -1;\n    } else if (!idx--) {\n      // secret\n      if (secret_fn) {\n        fprintf(stderr, \"Duplicate -s option detected\\n\");\n        _exit(1);\n      }\n      if (!*optarg) {\n        fprintf(stderr, \"-s must be followed by a filename\\n\");\n        _exit(1);\n      }\n      secret_fn = strdup(optarg);\n      if (!secret_fn) {\n        perror(\"malloc()\");\n        _exit(1);\n      }\n    } else if (!idx--) {\n      // step-size\n      if (step_size) {\n        fprintf(stderr, \"Duplicate -S option detected\\n\");\n        _exit(1);\n      }\n      char *endptr;\n      errno = 0;\n      const long l = strtol(optarg, &endptr, 10);\n      if (errno || endptr == optarg || *endptr || l < 1 || l > 60) {\n        fprintf(stderr, \"-S requires an argument in the range 1..60\\n\");\n        _exit(1);\n      }\n      step_size = (int)l;\n    } else if (!idx--) {\n      // window-size\n      if (window_size) {\n        fprintf(stderr, \"Duplicate -w/-W option detected\\n\");\n        _exit(1);\n      }\n      char *endptr;\n      errno = 0;\n      const long l = strtol(optarg, &endptr, 10);\n      if (errno || endptr == optarg || *endptr || l < 1 || l > 21) {\n        fprintf(stderr, \"-w requires an argument in the range 1..21\\n\");\n        _exit(1);\n      }\n      window_size = (int)l;\n    } else if (!idx--) {\n      // minimal-window\n      if (window_size) {\n        fprintf(stderr, \"Duplicate -w/-W option detected\\n\");\n        _exit(1);\n      }\n      window_size = -1;\n    } else if (!idx--) {\n      // emergency-codes\n      if (emergency_codes >= 0) {\n        fprintf(stderr, \"Duplicate -e option detected\\n\");\n        _exit(1);\n      }\n      char *endptr;\n      errno = 0;\n      long l = strtol(optarg, &endptr, 10);\n      if (errno || endptr == optarg || *endptr || l < 0 || l > MAX_SCRATCHCODES) {\n        fprintf(stderr, \"-e requires an argument in the range 0..%d\\n\", MAX_SCRATCHCODES);\n        _exit(1);\n      }\n      emergency_codes = (int)l;\n    } else {\n      fprintf(stderr, \"Error\\n\");\n      _exit(1);\n    }\n  }\n  idx = -1;\n  if (optind != argc) {\n    goto err;\n  }\n  if (reuse != ASK_REUSE && mode != TOTP_MODE) {\n    fprintf(stderr, \"Must select time-based mode, when using -d or -D\\n\");\n    _exit(1);\n  }\n  if ((r_time && !r_limit) || (!r_time && r_limit)) {\n    fprintf(stderr, \"Must set -r when setting -R, and vice versa\\n\");\n    _exit(1);\n  }\n  if (emergency_codes < 0) {\n    emergency_codes = SCRATCHCODES;\n  }\n  if (!label) {\n    const uid_t uid = getuid();\n    const char *user = getUserName(uid);\n    char hostname[128] = { 0 };\n    if (gethostname(hostname, sizeof(hostname)-1)) {\n      strcpy(hostname, \"unix\");\n    }\n    label = strcat(strcat(strcpy(malloc(strlen(user) + strlen(hostname) + 2),\n                                 user), \"@\"), hostname);\n    free((char *)user);\n  }\n  if (!issuer) {\n    char hostname[128] = { 0 };\n    if (gethostname(hostname, sizeof(hostname)-1)) {\n      strcpy(hostname, \"unix\");\n    }\n\n    issuer = strdup(hostname);\n  }\n  // Not const because 'fd' is reused. TODO.\n  int fd = open(\"/dev/urandom\", O_RDONLY);\n  if (fd < 0) {\n    perror(\"Failed to open \\\"/dev/urandom\\\"\");\n    return 1;\n  }\n  if (read(fd, buf, sizeof(buf)) != sizeof(buf)) {\n  urandom_failure:\n    perror(\"Failed to read from \\\"/dev/urandom\\\"\");\n    return 1;\n  }\n\n  base32_encode(buf, SECRET_BITS/8, (uint8_t *)secret, sizeof(secret));\n  int use_totp;\n  if (mode == ASK_MODE) {\n    use_totp = maybe(\"Do you want authentication tokens to be time-based\");\n  } else {\n    use_totp = mode == TOTP_MODE;\n  }\n  if (!quiet) {\n    displayEnrollInfo(secret, label, use_totp, issuer);\n    printf(\"Your new secret key is: %s\\n\", secret);\n\n    // Confirm code.\n    if (confirm && use_totp) {\n      for (;;) {\n        const int test_code = ask_code(\"Enter code from app (-1 to skip):\");\n        if (test_code < 0) {\n          printf(\"Code confirmation skipped\\n\");\n          break;\n        }\n        const unsigned long tm = time(NULL)/(step_size ? step_size : 30);\n        const int correct_code = generateCode(secret, tm);\n        if (test_code == correct_code) {\n          printf(\"Code confirmed\\n\");\n          break;\n        }\n        printf(\"Code incorrect (correct code %06d). Try again.\\n\",\n               correct_code);\n      }\n    } else {\n      const unsigned long tm = 1;\n      printf(\"Your verification code for code %lu is %06d\\n\",\n             tm, generateCode(secret, tm));\n    }\n    printf(\"Your emergency scratch codes are:\\n\");\n  }\n  free(label);\n  free(issuer);\n  strcat(secret, \"\\n\");\n  if (use_totp) {\n    strcat(secret, totp);\n  } else {\n    strcat(secret, hotp);\n  }\n  for (int i = 0; i < emergency_codes; ++i) {\n  new_scratch_code:;\n    int scratch = 0;\n    for (int j = 0; j < BYTES_PER_SCRATCHCODE; ++j) {\n      scratch = 256*scratch + buf[SECRET_BITS/8 + BYTES_PER_SCRATCHCODE*i + j];\n    }\n    int modulus = 1;\n    for (int j = 0; j < SCRATCHCODE_LENGTH; j++) {\n      modulus *= 10;\n    }\n    scratch = (scratch & 0x7FFFFFFF) % modulus;\n    if (scratch < modulus/10) {\n      // Make sure that scratch codes are always exactly eight digits. If they\n      // start with a sequence of zeros, just generate a new scratch code.\n      if (read(fd, buf + (SECRET_BITS/8 + BYTES_PER_SCRATCHCODE*i),\n               BYTES_PER_SCRATCHCODE) != BYTES_PER_SCRATCHCODE) {\n        goto urandom_failure;\n      }\n      goto new_scratch_code;\n    }\n    if (!quiet) {\n      printf(\"  %08d\\n\", scratch);\n    }\n    snprintf(strrchr(secret, '\\000'), sizeof(secret) - strlen(secret),\n             \"%08d\\n\", scratch);\n  }\n  close(fd);\n  if (!secret_fn) {\n    const char *home = getenv(\"HOME\");\n    if (!home || *home != '/') {\n      fprintf(stderr, \"Cannot determine home directory\\n\");\n      return 1;\n    }\n    secret_fn = malloc(strlen(home) + strlen(SECRET) + 1);\n    if (!secret_fn) {\n      perror(\"malloc()\");\n      _exit(1);\n    }\n    strcat(strcpy(secret_fn, home), SECRET);\n  }\n  if (!force) {\n    char s[1024];\n    snprintf(s, sizeof s, \"Do you want me to update your \\\"%s\\\" file?\",\n             secret_fn);\n    if (!maybe(s)) {\n      exit(0);\n    }\n  }\n\n  const int size = strlen(secret_fn) + 3;\n  char* tmp_fn = malloc(size);\n  if (!tmp_fn) {\n    perror(\"malloc()\");\n    _exit(1);\n  }\n  snprintf(tmp_fn, size, \"%s~\", secret_fn);\n\n  // Add optional flags.\n  if (use_totp) {\n    if (reuse == ASK_REUSE) {\n      maybeAddOption(\"Do you want to disallow multiple uses of the same \"\n                     \"authentication\\ntoken? This restricts you to one login \"\n                     \"about every 30s, but it increases\\nyour chances to \"\n                     \"notice or even prevent man-in-the-middle attacks\",\n                     secret, sizeof(secret), disallow);\n    } else if (reuse == DISALLOW_REUSE) {\n      addOption(secret, sizeof(secret), disallow);\n    }\n    if (step_size) {\n      char s[80];\n      snprintf(s, sizeof s, \"\\\" STEP_SIZE %d\\n\", step_size);\n      addOption(secret, sizeof(secret), s);\n    }\n    if (!window_size) {\n      maybeAddOption(\"By default, a new token is generated every 30 seconds by\"\n                     \" the mobile app.\\nIn order to compensate for possible\"\n                     \" time-skew between the client and the server,\\nwe allow\"\n                     \" an extra token before and after the current time. This\"\n                     \" allows for a\\ntime skew of up to 30 seconds between\"\n                     \" authentication server and client. If you\\nexperience\"\n                     \" problems with poor time synchronization, you can\"\n                     \" increase the window\\nfrom its default size of 3\"\n                     \" permitted codes (one previous code, the current\\ncode,\"\n                     \" the next code) to 17 permitted codes (the 8 previous\"\n                     \" codes, the current\\ncode, and the 8 next codes).\"\n                     \" This will permit for a time skew of up to 4 minutes\"\n                     \"\\nbetween client and server.\"\n                     \"\\nDo you want to do so?\",\n                     secret, sizeof(secret), window);\n    } else {\n      char s[80];\n      // TODO: Should 3 really be the minimal window size for TOTP?\n      // If so, the code should not allow -w=1 here.\n      snprintf(s, sizeof s, \"\\\" WINDOW_SIZE %d\\n\", window_size > 0 ? window_size : 3);\n      addOption(secret, sizeof(secret), s);\n    }\n  } else {\n    // Counter based.\n    if (!window_size) {\n      maybeAddOption(\"By default, three tokens are valid at any one time.  \"\n                     \"This accounts for\\ngenerated-but-not-used tokens and \"\n                     \"failed login attempts. In order to\\ndecrease the \"\n                     \"likelihood of synchronization problems, this window \"\n                     \"can be\\nincreased from its default size of 3 to 17. Do \"\n                     \"you want to do so?\",\n                     secret, sizeof(secret), window);\n    } else {\n      char s[80];\n      snprintf(s, sizeof s, \"\\\" WINDOW_SIZE %d\\n\", window_size > 0 ? window_size : 1);\n      addOption(secret, sizeof(secret), s);\n    }\n  }\n  if (!r_limit && !r_time) {\n    maybeAddOption(\"If the computer that you are logging into isn't hardened \"\n                   \"against brute-force\\nlogin attempts, you can enable \"\n                   \"rate-limiting for the authentication module.\\nBy default, \"\n                   \"this limits attackers to no more than 3 login attempts \"\n                   \"every 30s.\\nDo you want to enable rate-limiting?\",\n                   secret, sizeof(secret), ratelimit);\n  } else if (r_limit > 0 && r_time > 0) {\n    char s[80];\n    snprintf(s, sizeof s, \"\\\" RATE_LIMIT %d %d\\n\", r_limit, r_time);\n    addOption(secret, sizeof(secret), s);\n  }\n\n  fd = open(tmp_fn, O_WRONLY|O_EXCL|O_CREAT|O_NOFOLLOW|O_TRUNC, 0400);\n  if (fd < 0) {\n    fprintf(stderr, \"Failed to create \\\"%s\\\" (%s)\",\n            secret_fn, strerror(errno));\n    goto errout;\n  }\n  if (write(fd, secret, strlen(secret)) != (ssize_t)strlen(secret) ||\n      rename(tmp_fn, secret_fn)) {\n    perror(\"Failed to write new secret\");\n    unlink(secret_fn);\n    goto errout;\n  }\n\n  free(tmp_fn);\n  free(secret_fn);\n  close(fd);\n\n  return 0;\n\nerrout:\n  if (fd > 0) {\n    close(fd);\n  }\n  free(secret_fn);\n  free(tmp_fn);\n  return 1;\n}\n/* ---- Emacs Variables ----\n * Local Variables:\n * c-basic-offset: 2\n * indent-tabs-mode: nil\n * End:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libpam-1.09-h77h3yhuj45rxzdw47qeln5sfxliavnl/spack-src/tests/pam_google_authenticator_unittest.c": "// Unittest for the PAM module. This is part of the Google Authenticator\n// project.\n//\n// Copyright 2010 Google Inc.\n// Author: Markus Gutschke\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#include \"config.h\"\n\n#include <assert.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"../src/base32.h\"\n#include \"../src/hmac.h\"\n\n#if !defined(PAM_BAD_ITEM)\n// FreeBSD does not know about PAM_BAD_ITEM. And PAM_SYMBOL_ERR is an \"enum\",\n// we can't test for it at compile-time.\n#define PAM_BAD_ITEM PAM_SYMBOL_ERR\n#endif\n\nstatic PAM_CONST char pw[] = \"0123456789\";\nstatic char *response = \"\";\nstatic void *pam_module;\nstatic enum { TWO_PROMPTS, COMBINED_PASSWORD, COMBINED_PROMPT } conv_mode;\nstatic int num_prompts_shown = 0;\n\nstatic int conversation(int num_msg, PAM_CONST struct pam_message **msg,\n                        struct pam_response **resp, void *appdata_ptr) {\n  // Keep track of how often the conversation callback is executed.\n  ++num_prompts_shown;\n  if (conv_mode == COMBINED_PASSWORD) {\n    return PAM_CONV_ERR;\n  }\n  if (num_msg == 1 && msg[0]->msg_style == PAM_PROMPT_ECHO_OFF) {\n    *resp = malloc(sizeof(struct pam_response));\n    assert(*resp);\n    (*resp)->resp = conv_mode == TWO_PROMPTS\n      ? strdup(response)\n      : strcat(strcpy(malloc(sizeof(pw) + strlen(response)), pw), response);\n    (*resp)->resp_retcode = 0;\n    return PAM_SUCCESS;\n  }\n  return PAM_CONV_ERR;\n}\n\nint pam_get_user(pam_handle_t *pamh, PAM_CONST char **user,\n                 PAM_CONST char *prompt)\n  __attribute__((visibility(\"default\")));\nint pam_get_user(pam_handle_t *pamh, PAM_CONST char **user,\n                 PAM_CONST char *prompt) {\n  return pam_get_item(pamh, PAM_USER, (void *)user);\n}\n\nint pam_get_item(const pam_handle_t *pamh, int item_type,\n                 PAM_CONST void **item)\n  __attribute__((visibility(\"default\")));\nint pam_get_item(const pam_handle_t *pamh, int item_type,\n                 PAM_CONST void **item) {\n  switch (item_type) {\n    case PAM_SERVICE: {\n      static const char *service = \"google_authenticator_unittest\";\n      *item = service;\n      return PAM_SUCCESS;\n    }\n    case PAM_USER: {\n      char *user = getenv(\"USER\");\n      *item = user;\n      return PAM_SUCCESS;\n    }\n    case PAM_CONV: {\n      static struct pam_conv conv = { .conv = conversation }, *p_conv = &conv;\n      *item = p_conv;\n      return PAM_SUCCESS;\n    }\n    case PAM_RHOST: {\n        static const char *rhost = \"::1\";\n        *item = rhost;\n        return PAM_SUCCESS;\n    }\n    case PAM_AUTHTOK: {\n      static char *authtok = NULL;\n      if (conv_mode == COMBINED_PASSWORD) {\n        authtok = realloc(authtok, sizeof(pw) + strlen(response));\n        *item = strcat(strcpy(authtok, pw), response);\n      } else {\n        *item = pw;\n      }\n      return PAM_SUCCESS;\n    }\n    default:\n      return PAM_BAD_ITEM;\n  }\n}\n\nint pam_set_item(pam_handle_t *pamh, int item_type,\n                 const void *item)\n  __attribute__((visibility(\"default\")));\nint pam_set_item(pam_handle_t *pamh, int item_type,\n                 const void *item) {\n  switch (item_type) {\n    case PAM_AUTHTOK:\n      if (strcmp((char *)item, pw)) {\n        return PAM_BAD_ITEM;\n      }\n      return PAM_SUCCESS;\n    default:\n      return PAM_BAD_ITEM;\n  }\n}\n\n// Return the last line of the error message.\nstatic const char *get_error_msg(void) {\n  const char *(*get_error_msg)(void) =\n    (const char *(*)(void))dlsym(pam_module, \"get_error_msg\");\n  const char* msg = get_error_msg ? get_error_msg() : \"\";\n  const char* p = strrchr(msg, '\\n');\n  if (p) {\n    msg = p+1;\n  }\n  return msg;\n}\n\nstatic void print_diagnostics(int signo) {\n  if (*get_error_msg()) {\n    fprintf(stderr, \"%s\\n\", get_error_msg());\n  }\n  _exit(1);\n}\n\n#define verify_prompts_shown(expected_prompts_shown) do { \\\n  assert(num_prompts_shown == (expected_prompts_shown)); \\\n  num_prompts_shown = 0; /* Reset for the next count. */ \\\n} while(0)\n\nint main(int argc, char *argv[]) {\n  // Testing Base32 encoding\n  puts(\"Testing base32 encoding\");\n  static const uint8_t dat[] = \"Hello world...\";\n  uint8_t enc[((sizeof(dat) + 4)/5)*8 + 1];\n  assert(base32_encode(dat, sizeof(dat), enc, sizeof(enc)) == sizeof(enc)-1);\n  assert(!strcmp((char *)enc, \"JBSWY3DPEB3W64TMMQXC4LQA\"));\n \n  puts(\"Testing base32 decoding\");\n  uint8_t dec[sizeof(dat)];\n  assert(base32_decode(enc, dec, sizeof(dec)) == sizeof(dec));\n  assert(!memcmp(dat, dec, sizeof(dat)));\n\n  // Testing HMAC_SHA1\n  puts(\"Testing HMAC_SHA1\");\n  uint8_t hmac[20];\n  hmac_sha1((uint8_t *)\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\"\n                       \"\\x0D\\x0E\\x0F\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n                       \"\\x1A\\x1B\\x1C\\x1D\\x1E\\x1F !\\\"#$%&'()*+,-./0123456789:\"\n                       \";<=>?\", 64,\n            (uint8_t *)\"Sample #1\", 9,\n            hmac, sizeof(hmac));\n  assert(!memcmp(hmac,\n                 (uint8_t []) { 0x4F, 0x4C, 0xA3, 0xD5, 0xD6, 0x8B, 0xA7, 0xCC,\n                                0x0A, 0x12, 0x08, 0xC9, 0xC6, 0x1E, 0x9C, 0x5D,\n                                0xA0, 0x40, 0x3C, 0x0A },\n                 sizeof(hmac)));\n  hmac_sha1((uint8_t *)\"0123456789:;<=>?@ABC\", 20,\n            (uint8_t *)\"Sample #2\", 9,\n            hmac, sizeof(hmac));\n  assert(!memcmp(hmac,\n                 (uint8_t []) { 0x09, 0x22, 0xD3, 0x40, 0x5F, 0xAA, 0x3D, 0x19,\n                                0x4F, 0x82, 0xA4, 0x58, 0x30, 0x73, 0x7D, 0x5C,\n                                0xC6, 0xC7, 0x5D, 0x24 },\n                 sizeof(hmac)));\n  hmac_sha1((uint8_t *)\"PQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n                       \"\\x7F\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8A\"\n                       \"\\x8B\\x8C\\x8D\\x8E\\x8F\\x90\\x91\\x92\\x93\\x94\\x95\\x96\"\n                       \"\\x97\\x98\\x99\\x9A\\x9B\\x9C\\x9D\\x9E\\x9F\\xA0\\xA1\\xA2\"\n                       \"\\xA3\\xA4\\xA5\\xA6\\xA7\\xA8\\xA9\\xAA\\xAB\\xAC\\xAD\\xAE\"\n                       \"\\xAF\\xB0\\xB1\\xB2\\xB3\", 100,\n            (uint8_t *)\"Sample #3\", 9,\n            hmac, sizeof(hmac));\n  assert(!memcmp(hmac,\n                 (uint8_t []) { 0xBC, 0xF4, 0x1E, 0xAB, 0x8B, 0xB2, 0xD8, 0x02,\n                                0xF3, 0xD0, 0x5C, 0xAF, 0x7C, 0xB0, 0x92, 0xEC,\n                                0xF8, 0xD1, 0xA3, 0xAA },\n                 sizeof(hmac)));\n  hmac_sha1((uint8_t *)\"pqrstuvwxyz{|}~\\x7F\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\"\n                       \"\\x88\\x89\\x8A\\x8B\\x8C\\x8D\\x8E\\x8F\\x90\\x91\\x92\\x93\\x94\"\n                       \"\\x95\\x96\\x97\\x98\\x99\\x9A\\x9B\\x9C\\x9D\\x9E\\x9F\\xA0\", 49,\n            (uint8_t *)\"Sample #4\", 9,\n            hmac, sizeof(hmac));\n  assert(!memcmp(hmac,\n                 (uint8_t []) { 0x9E, 0xA8, 0x86, 0xEF, 0xE2, 0x68, 0xDB, 0xEC,\n                                0xCE, 0x42, 0x0C, 0x75, 0x24, 0xDF, 0x32, 0xE0,\n                                0x75, 0x1A, 0x2A, 0x26 },\n                 sizeof(hmac)));\n\n  // Load the PAM module\n  puts(\"Loading PAM module\");\n  pam_module = dlopen(\"./.libs/libpam_google_authenticator_testing.so\",\n                      RTLD_NOW | RTLD_GLOBAL);\n  if (pam_module == NULL) {\n    fprintf(stderr, \"dlopen(): %s\\n\", dlerror());\n    exit(1);\n  }\n  signal(SIGABRT, print_diagnostics);\n\n  // Look up public symbols\n  int (*pam_sm_authenticate)(pam_handle_t *, int, int, const char **) =\n      (int (*)(pam_handle_t *, int, int, const char **))\n      dlsym(pam_module, \"pam_sm_authenticate\");\n  assert(pam_sm_authenticate != NULL);\n\n  // Look up private test-only API\n  void (*set_time)(time_t t) =\n      (void (*)(time_t))dlsym(pam_module, \"set_time\");\n  assert(set_time);\n  int (*compute_code)(uint8_t *, int, unsigned long) =\n      (int (*)(uint8_t*, int, unsigned long))dlsym(pam_module, \"compute_code\");\n  assert(compute_code);\n\n  for (int otp_mode = 0; otp_mode < 8; ++otp_mode) {\n    // Create a secret file with a well-known test vector\n    char fn[] = \"/tmp/.google_authenticator_XXXXXX\";\n    mode_t orig_umask = umask(S_IRWXG|S_IRWXO); // Only for the current user.\n    int fd = mkstemp(fn);\n    (void)umask(orig_umask);\n    assert(fd >= 0);\n    static const uint8_t secret[] = \"2SH3V3GDW7ZNMGYE\";\n    assert(write(fd, secret, sizeof(secret)-1) == sizeof(secret)-1);\n    assert(write(fd, \"\\n\\\" TOTP_AUTH\", 12) == 12);\n    close(fd);\n    uint8_t binary_secret[sizeof(secret)];\n    size_t binary_secret_len = base32_decode(secret, binary_secret,\n                                             sizeof(binary_secret));\n\n    // Set up test argc/argv parameters to let the PAM module know where to\n    // find our secret file\n    const char *targv[] = { malloc(strlen(fn) + 8), NULL, NULL, NULL, NULL };\n    strcat(strcpy((char *)targv[0], \"secret=\"), fn);\n    int targc;\n    int expected_good_prompts_shown;\n    int expected_bad_prompts_shown;\n    int password_is_provided_from_external;\n\n    switch (otp_mode) {\n    case 0:\n      puts(\"\\nRunning tests, querying for verification code\");\n      conv_mode = TWO_PROMPTS;\n      targc = 1;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 1;\n      password_is_provided_from_external = 0;\n      break;\n    case 1:\n      puts(\"\\nRunning tests, querying for verification code, \"\n           \"forwarding system pass\");\n      conv_mode = COMBINED_PROMPT;\n      targv[1] = strdup(\"forward_pass\");\n      targc = 2;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 1;\n      password_is_provided_from_external = 0;\n      break;\n    case 2:\n      puts(\"\\nRunning tests with use_first_pass\");\n      conv_mode = COMBINED_PASSWORD;\n      targv[1] = strdup(\"use_first_pass\");\n      targc = 2;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 0;\n      password_is_provided_from_external = 1;\n      break;\n    case 3:\n      puts(\"\\nRunning tests with use_first_pass, forwarding system pass\");\n      conv_mode = COMBINED_PASSWORD;\n      targv[1] = strdup(\"use_first_pass\");\n      targv[2] = strdup(\"forward_pass\");\n      targc = 3;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 0;\n      password_is_provided_from_external = 1;\n      break;\n    case 4:\n      puts(\"\\nRunning tests with try_first_pass, combining codes\");\n      conv_mode = COMBINED_PASSWORD;\n      targv[1] = strdup(\"try_first_pass\");\n      targc = 2;\n      expected_good_prompts_shown = 0;\n      expected_bad_prompts_shown = 2;\n      password_is_provided_from_external = 1;\n      break;\n    case 5:\n      puts(\"\\nRunning tests with try_first_pass, combining codes, \"\n           \"forwarding system pass\");\n      conv_mode = COMBINED_PASSWORD;\n      targv[1] = strdup(\"try_first_pass\");\n      targv[2] = strdup(\"forward_pass\");\n      targc = 3;\n      expected_good_prompts_shown = 0;\n      expected_bad_prompts_shown = 2;\n      password_is_provided_from_external = 1;\n      break;\n    case 6:\n      puts(\"\\nRunning tests with try_first_pass, querying for codes\");\n      conv_mode = TWO_PROMPTS;\n      targv[1] = strdup(\"try_first_pass\");\n      targc = 2;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 1;\n      password_is_provided_from_external = 1;\n      break;\n    default:\n      assert(otp_mode == 7);\n      puts(\"\\nRunning tests with try_first_pass, querying for codes, \"\n           \"forwarding system pass\");\n      conv_mode = COMBINED_PROMPT;\n      targv[1] = strdup(\"try_first_pass\");\n      targv[2] = strdup(\"forward_pass\");\n      targc = 3;\n      expected_good_prompts_shown = expected_bad_prompts_shown = 1;\n      password_is_provided_from_external = 1;\n      break;\n    }\n\n    // Make sure num_prompts_shown is still 0.\n    verify_prompts_shown(0);\n\n    // Set the timestamp that this test vector needs\n    set_time(10000*30);\n\n    response = \"123456\";\n\n    // Check if we can log in when using an invalid verification code\n    puts(\"Testing failed login attempt\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_bad_prompts_shown);\n\n    // Check required number of digits\n    if (conv_mode == TWO_PROMPTS) {\n      puts(\"Testing required number of digits\");\n      response = \"50548\";\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n      verify_prompts_shown(expected_bad_prompts_shown);\n      response = \"0050548\";\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n      verify_prompts_shown(expected_bad_prompts_shown);\n      response = \"00050548\";\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n      verify_prompts_shown(expected_bad_prompts_shown);\n    }\n\n    // Test a blank response\n    puts(\"Testing a blank response\");\n    response = \"\";\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_bad_prompts_shown);\n\n    // Set the response that we should send back to the authentication module\n    response = \"050548\";\n\n    // Test handling of missing state files\n    puts(\"Test handling of missing state files\");\n    const char *old_secret = targv[0];\n    targv[0] = \"secret=/NOSUCHFILE\";\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(password_is_provided_from_external ? 0 : expected_bad_prompts_shown);\n    targv[targc++] = \"nullok\";\n    targv[targc] = NULL;\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_IGNORE);\n    verify_prompts_shown(0);\n    targv[--targc] = NULL;\n    targv[0] = old_secret;\n\n    // Check if we can log in when using a valid verification code\n    puts(\"Testing successful login\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n\n    // Test the STEP_SIZE option\n    puts(\"Testing STEP_SIZE option\");\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_APPEND | O_WRONLY)) >= 0);\n    assert(write(fd, \"\\n\\\" STEP_SIZE 60\\n\", 16) == 16);\n    close(fd);\n    for (int *tm  = (int []){ 9998, 9999, 10001, 10002, 10000, -1 },\n             *res = (int []){ PAM_AUTH_ERR, PAM_SUCCESS, PAM_SUCCESS,\n                              PAM_AUTH_ERR, PAM_SUCCESS };\n         *tm >= 0;) {\n      set_time(*tm++ * 60);\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == *res++);\n      verify_prompts_shown(expected_good_prompts_shown);\n    }\n\n    // Reset secret file after step size testing.\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_TRUNC | O_WRONLY)) >= 0);\n    assert(write(fd, secret, sizeof(secret)-1) == sizeof(secret)-1);\n    assert(write(fd, \"\\n\\\" TOTP_AUTH\", 12) == 12);\n    close(fd);\n\n    // Test the WINDOW_SIZE option\n    puts(\"Testing WINDOW_SIZE option\");\n    for (int *tm  = (int []){ 9998, 9999, 10001, 10002, 10000, -1 },\n             *res = (int []){ PAM_AUTH_ERR, PAM_SUCCESS, PAM_SUCCESS,\n                              PAM_AUTH_ERR, PAM_SUCCESS };\n         *tm >= 0;) {\n      set_time(*tm++ * 30);\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == *res++);\n      verify_prompts_shown(expected_good_prompts_shown);\n    }\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_APPEND | O_WRONLY)) >= 0);\n    assert(write(fd, \"\\n\\\" WINDOW_SIZE 6\\n\", 17) == 17);\n    close(fd);\n    for (int *tm  = (int []){ 9996, 9997, 10002, 10003, 10000, -1 },\n             *res = (int []){ PAM_AUTH_ERR, PAM_SUCCESS, PAM_SUCCESS,\n                              PAM_AUTH_ERR, PAM_SUCCESS };\n         *tm >= 0;) {\n      set_time(*tm++ * 30);\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == *res++);\n      verify_prompts_shown(expected_good_prompts_shown);\n    }\n\n    // Test the DISALLOW_REUSE option\n    puts(\"Testing DISALLOW_REUSE option\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_APPEND | O_WRONLY)) >= 0);\n    assert(write(fd, \"\\\" DISALLOW_REUSE\\n\", 17) == 17);\n    close(fd);\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_good_prompts_shown);\n\n    // Test that DISALLOW_REUSE expires old entries from the re-use list\n    char *old_response = response;\n    for (int i = 10001; i < 10008; ++i) {\n      set_time(i * 30);\n      char buf[7];\n      response = buf;\n      sprintf(response, \"%06d\", compute_code(binary_secret,\n                                             binary_secret_len, i));\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n      verify_prompts_shown(expected_good_prompts_shown);\n    }\n    set_time(10000 * 30);\n    response = old_response;\n    assert((fd = open(fn, O_RDONLY)) >= 0);\n    char state_file_buf[4096] = { 0 };\n    assert(read(fd, state_file_buf, sizeof(state_file_buf)-1) > 0);\n    close(fd);\n    const char *disallow = strstr(state_file_buf, \"\\\" DISALLOW_REUSE \");\n    assert(disallow);\n    assert(!memcmp(disallow + 17,\n                   \"10002 10003 10004 10005 10006 10007\\n\", 36));\n\n    // Test the RATE_LIMIT option\n    puts(\"Testing RATE_LIMIT option\");\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_APPEND | O_WRONLY)) >= 0);\n    assert(write(fd, \"\\\" RATE_LIMIT 4 120\\n\", 19) == 19);\n    close(fd);\n    for (int *tm  = (int []){ 20000, 20001, 20002, 20003, 20004, 20006, -1 },\n             *res = (int []){ PAM_SUCCESS, PAM_SUCCESS, PAM_SUCCESS,\n                              PAM_SUCCESS, PAM_AUTH_ERR, PAM_SUCCESS, -1 };\n         *tm >= 0;) {\n      set_time(*tm * 30);\n      char buf[7];\n      response = buf;\n      sprintf(response, \"%06d\",\n              compute_code(binary_secret, binary_secret_len, *tm++));\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) == *res);\n      verify_prompts_shown(\n          *res != PAM_SUCCESS ? 0 : expected_good_prompts_shown);\n      ++res;\n    }\n    set_time(10000 * 30);\n    response = old_response;\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_RDWR)) >= 0);\n    memset(state_file_buf, 0, sizeof(state_file_buf));\n    assert(read(fd, state_file_buf, sizeof(state_file_buf)-1) > 0);\n    const char *rate_limit = strstr(state_file_buf, \"\\\" RATE_LIMIT \");\n    assert(rate_limit);\n    assert(!memcmp(rate_limit + 13,\n                   \"4 120 600060 600090 600120 600180\\n\", 35));\n\n    // Test trailing space in RATE_LIMIT. This is considered a file format\n    // error.\n    char *eol = strchr(rate_limit, '\\n');\n    *eol = ' ';\n    assert(!lseek(fd, 0, SEEK_SET));\n    assert(write(fd, state_file_buf, strlen(state_file_buf)) ==\n           strlen(state_file_buf));\n    close(fd);\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(0);\n    assert(!strncmp(get_error_msg(),\n                    \"Invalid list of timestamps in RATE_LIMIT\", 40));\n    *eol = '\\n';\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_WRONLY)) >= 0);\n    assert(write(fd, state_file_buf, strlen(state_file_buf)) ==\n           strlen(state_file_buf));\n    close(fd);\n\n    // Test TIME_SKEW option\n    puts(\"Testing TIME_SKEW\");\n    for (int i = 0; i < 4; ++i) {\n      set_time((12000 + i)*30);\n      char buf[7];\n      response = buf;\n      sprintf(response, \"%06d\",\n              compute_code(binary_secret, binary_secret_len, 11000 + i));\n      assert(pam_sm_authenticate(NULL, 0, targc, targv) ==\n             (i >= 2 ? PAM_SUCCESS : PAM_AUTH_ERR));\n      verify_prompts_shown(expected_good_prompts_shown);\n    }\n\n    puts(\"Testing TIME_SKEW - noskewadj\");\n    set_time(12020 * 30);\n    char buf[7];\n    response = buf;\n    sprintf(response, \"%06d\", compute_code(binary_secret,\n                                           binary_secret_len, 11010));\n    targv[targc] = \"noskewadj\";\n    assert(pam_sm_authenticate(NULL, 0, targc+1, targv) == PAM_AUTH_ERR);\n    targv[targc] = NULL;\n    verify_prompts_shown(expected_bad_prompts_shown);\n    set_time(10000*30);\n\n    // Test scratch codes\n    puts(\"Testing scratch codes\");\n    response = \"12345678\";\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_bad_prompts_shown);\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_APPEND | O_WRONLY)) >= 0);\n    assert(write(fd, \"12345678\\n\", 9) == 9);\n    close(fd);\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_bad_prompts_shown);\n\n    // Set up secret file for counter-based codes.\n    assert(!chmod(fn, 0600));\n    assert((fd = open(fn, O_TRUNC | O_WRONLY)) >= 0);\n    assert(write(fd, secret, sizeof(secret)-1) == sizeof(secret)-1);\n    assert(write(fd, \"\\n\\\" HOTP_COUNTER 1\\n\", 18) == 18);\n    close(fd);\n\n    response = \"293240\";\n\n    // Check if we can log in when using a valid verification code\n    puts(\"Testing successful counter-based login\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n\n    // Verify that the hotp counter incremented\n    assert((fd = open(fn, O_RDONLY)) >= 0);\n    memset(state_file_buf, 0, sizeof(state_file_buf));\n    assert(read(fd, state_file_buf, sizeof(state_file_buf)-1) > 0);\n    close(fd);\n    const char *hotp_counter = strstr(state_file_buf, \"\\\" HOTP_COUNTER \");\n    assert(hotp_counter);\n    assert(!memcmp(hotp_counter + 15, \"2\\n\", 2));\n\n    // Check if we can log in when using an invalid verification code\n    // (including the same code a second time)\n    puts(\"Testing failed counter-based login attempt\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_AUTH_ERR);\n    verify_prompts_shown(expected_bad_prompts_shown);\n\n    // Verify that the hotp counter incremented\n    assert((fd = open(fn, O_RDONLY)) >= 0);\n    memset(state_file_buf, 0, sizeof(state_file_buf));\n    assert(read(fd, state_file_buf, sizeof(state_file_buf)-1) > 0);\n    close(fd);\n    hotp_counter = strstr(state_file_buf, \"\\\" HOTP_COUNTER \");\n    assert(hotp_counter);\n    assert(!memcmp(hotp_counter + 15, \"3\\n\", 2));\n\n    response = \"932068\";\n\n    // Check if we can log in using a future valid verification code (using\n    // default window_size of 3)\n    puts(\"Testing successful future counter-based login\");\n    assert(pam_sm_authenticate(NULL, 0, targc, targv) == PAM_SUCCESS);\n    verify_prompts_shown(expected_good_prompts_shown);\n\n    // Verify that the hotp counter incremented\n    assert((fd = open(fn, O_RDONLY)) >= 0);\n    memset(state_file_buf, 0, sizeof(state_file_buf));\n    assert(read(fd, state_file_buf, sizeof(state_file_buf)-1) > 0);\n    close(fd);\n    hotp_counter = strstr(state_file_buf, \"\\\" HOTP_COUNTER \");\n    assert(hotp_counter);\n    assert(!memcmp(hotp_counter + 15, \"6\\n\", 2));\n\n    // Remove the temporarily created secret file\n    unlink(fn);\n\n    // Release memory for the test arguments\n    for (int i = 0; i < targc; ++i) {\n      free((void *)targv[i]);\n    }\n  }\n\n  // Unload the PAM module\n  dlclose(pam_module);\n\n  puts(\"DONE\");\n  return 0;\n}\n"
    },
    "skipped": [],
    "total_files": 32
}