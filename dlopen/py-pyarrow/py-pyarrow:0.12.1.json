{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/gandiva.pyx": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\n# cython: profile=False\n# distutils: language = c++\n# cython: embedsignature = True\n\nimport os\n\nfrom libcpp cimport bool as c_bool, nullptr\nfrom libcpp.memory cimport shared_ptr, unique_ptr, make_shared\nfrom libcpp.string cimport string as c_string\nfrom libcpp.vector cimport vector as c_vector\nfrom libcpp.unordered_set cimport unordered_set as c_unordered_set\nfrom libc.stdint cimport int64_t, int32_t, uint8_t, uintptr_t\n\nfrom pyarrow.includes.libarrow cimport *\nfrom pyarrow.compat import frombytes\nfrom pyarrow.lib cimport (Array, DataType, Field, MemoryPool, RecordBatch,\n                          Schema, check_status, pyarrow_wrap_array,\n                          pyarrow_wrap_data_type, ensure_type)\n\nfrom pyarrow.includes.libgandiva cimport (\n    CCondition, CExpression,\n    CNode, CProjector, CFilter,\n    CSelectionVector,\n    TreeExprBuilder_MakeExpression,\n    TreeExprBuilder_MakeFunction,\n    TreeExprBuilder_MakeBoolLiteral,\n    TreeExprBuilder_MakeUInt8Literal,\n    TreeExprBuilder_MakeUInt16Literal,\n    TreeExprBuilder_MakeUInt32Literal,\n    TreeExprBuilder_MakeUInt64Literal,\n    TreeExprBuilder_MakeInt8Literal,\n    TreeExprBuilder_MakeInt16Literal,\n    TreeExprBuilder_MakeInt32Literal,\n    TreeExprBuilder_MakeInt64Literal,\n    TreeExprBuilder_MakeFloatLiteral,\n    TreeExprBuilder_MakeDoubleLiteral,\n    TreeExprBuilder_MakeStringLiteral,\n    TreeExprBuilder_MakeBinaryLiteral,\n    TreeExprBuilder_MakeField,\n    TreeExprBuilder_MakeIf,\n    TreeExprBuilder_MakeAnd,\n    TreeExprBuilder_MakeOr,\n    TreeExprBuilder_MakeCondition,\n    TreeExprBuilder_MakeInExpressionInt32,\n    TreeExprBuilder_MakeInExpressionInt64,\n    TreeExprBuilder_MakeInExpressionTime32,\n    TreeExprBuilder_MakeInExpressionTime64,\n    TreeExprBuilder_MakeInExpressionDate32,\n    TreeExprBuilder_MakeInExpressionDate64,\n    TreeExprBuilder_MakeInExpressionTimeStamp,\n    TreeExprBuilder_MakeInExpressionString,\n    TreeExprBuilder_MakeInExpressionBinary,\n    SelectionVector_MakeInt16,\n    SelectionVector_MakeInt32,\n    SelectionVector_MakeInt64,\n    Projector_Make,\n    Filter_Make,\n    CFunctionSignature,\n    GetRegisteredFunctionSignatures)\n\nif os.name == 'posix':\n    # Expose self with RTLD_GLOBAL so that symbols from gandiva.so and child\n    # libs (such as libstdc++) can be reached during JIT code execution.\n    # Another workaround is to use\n    #   sys.setdlopenflags(os.RTLD_GLOBAL | os.RTLD_NOW)\n    # but it would affect all C extensions loaded in the process.\n    import ctypes\n    _dll = ctypes.CDLL(__file__, ctypes.RTLD_GLOBAL)\n\ncdef class Node:\n    cdef:\n        shared_ptr[CNode] node\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly, use the \"\n                        \"TreeExprBuilder API directly\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CNode] node):\n        cdef Node self = Node.__new__(Node)\n        self.node = node\n        return self\n\ncdef class Expression:\n    cdef:\n        shared_ptr[CExpression] expression\n\n    cdef void init(self, shared_ptr[CExpression] expression):\n        self.expression = expression\n\ncdef class Condition:\n    cdef:\n        shared_ptr[CCondition] condition\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly, use the \"\n                        \"TreeExprBuilder API instead\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CCondition] condition):\n        cdef Condition self = Condition.__new__(Condition)\n        self.condition = condition\n        return self\n\ncdef class SelectionVector:\n    cdef:\n        shared_ptr[CSelectionVector] selection_vector\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly.\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CSelectionVector] selection_vector):\n        cdef SelectionVector self = SelectionVector.__new__(SelectionVector)\n        self.selection_vector = selection_vector\n        return self\n\n    def to_array(self):\n        cdef shared_ptr[CArray] result = self.selection_vector.get().ToArray()\n        return pyarrow_wrap_array(result)\n\ncdef class Projector:\n    cdef:\n        shared_ptr[CProjector] projector\n        MemoryPool pool\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly, use \"\n                        \"make_projector instead\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CProjector] projector, MemoryPool pool):\n        cdef Projector self = Projector.__new__(Projector)\n        self.projector = projector\n        self.pool = pool\n        return self\n\n    def evaluate(self, RecordBatch batch):\n        cdef vector[shared_ptr[CArray]] results\n        check_status(self.projector.get().Evaluate(\n            batch.sp_batch.get()[0], self.pool.pool, &results))\n        cdef shared_ptr[CArray] result\n        arrays = []\n        for result in results:\n            arrays.append(pyarrow_wrap_array(result))\n        return arrays\n\ncdef class Filter:\n    cdef:\n        shared_ptr[CFilter] filter\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly, use \"\n                        \"make_filter instead\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CFilter] filter):\n        cdef Filter self = Filter.__new__(Filter)\n        self.filter = filter\n        return self\n\n    def evaluate(self, RecordBatch batch, MemoryPool pool, dtype='int32'):\n        cdef:\n            DataType type = ensure_type(dtype)\n            shared_ptr[CSelectionVector] selection\n\n        if type.id == _Type_INT16:\n            check_status(SelectionVector_MakeInt16(\n                batch.num_rows, pool.pool, &selection))\n        elif type.id == _Type_INT32:\n            check_status(SelectionVector_MakeInt32(\n                batch.num_rows, pool.pool, &selection))\n        elif type.id == _Type_INT64:\n            check_status(SelectionVector_MakeInt64(\n                batch.num_rows, pool.pool, &selection))\n        else:\n            raise ValueError(\"'dtype' of the selection vector should be \"\n                             \"one of 'int16', 'int32' and 'int64'.\")\n\n        check_status(self.filter.get().Evaluate(\n            batch.sp_batch.get()[0], selection))\n        return SelectionVector.create(selection)\n\n\ncdef class TreeExprBuilder:\n\n    def make_literal(self, value, dtype):\n        cdef:\n            DataType type = ensure_type(dtype)\n            shared_ptr[CNode] r\n\n        if type.id == _Type_BOOL:\n            r = TreeExprBuilder_MakeBoolLiteral(value)\n        elif type.id == _Type_UINT8:\n            r = TreeExprBuilder_MakeUInt8Literal(value)\n        elif type.id == _Type_UINT16:\n            r = TreeExprBuilder_MakeUInt16Literal(value)\n        elif type.id == _Type_UINT32:\n            r = TreeExprBuilder_MakeUInt32Literal(value)\n        elif type.id == _Type_UINT64:\n            r = TreeExprBuilder_MakeUInt64Literal(value)\n        elif type.id == _Type_INT8:\n            r = TreeExprBuilder_MakeInt8Literal(value)\n        elif type.id == _Type_INT16:\n            r = TreeExprBuilder_MakeInt16Literal(value)\n        elif type.id == _Type_INT32:\n            r = TreeExprBuilder_MakeInt32Literal(value)\n        elif type.id == _Type_INT64:\n            r = TreeExprBuilder_MakeInt64Literal(value)\n        elif type.id == _Type_FLOAT:\n            r = TreeExprBuilder_MakeFloatLiteral(value)\n        elif type.id == _Type_DOUBLE:\n            r = TreeExprBuilder_MakeDoubleLiteral(value)\n        elif type.id == _Type_STRING:\n            r = TreeExprBuilder_MakeStringLiteral(value.encode('UTF-8'))\n        elif type.id == _Type_BINARY:\n            r = TreeExprBuilder_MakeBinaryLiteral(value)\n        else:\n            raise TypeError(\"Didn't recognize dtype \" + str(dtype))\n\n        return Node.create(r)\n\n    def make_expression(self, Node root_node, Field return_field):\n        cdef shared_ptr[CExpression] r = TreeExprBuilder_MakeExpression(\n            root_node.node, return_field.sp_field)\n        cdef Expression expression = Expression()\n        expression.init(r)\n        return expression\n\n    def make_function(self, name, children, DataType return_type):\n        cdef c_vector[shared_ptr[CNode]] c_children\n        cdef Node child\n        for child in children:\n            c_children.push_back(child.node)\n        cdef shared_ptr[CNode] r = TreeExprBuilder_MakeFunction(\n            name.encode(), c_children, return_type.sp_type)\n        return Node.create(r)\n\n    def make_field(self, Field field):\n        cdef shared_ptr[CNode] r = TreeExprBuilder_MakeField(field.sp_field)\n        return Node.create(r)\n\n    def make_if(self, Node condition, Node this_node,\n                Node else_node, DataType return_type):\n        cdef shared_ptr[CNode] r = TreeExprBuilder_MakeIf(\n            condition.node, this_node.node, else_node.node,\n            return_type.sp_type)\n        return Node.create(r)\n\n    def make_and(self, children):\n        cdef c_vector[shared_ptr[CNode]] c_children\n        cdef Node child\n        for child in children:\n            c_children.push_back(child.node)\n        cdef shared_ptr[CNode] r = TreeExprBuilder_MakeAnd(c_children)\n        return Node.create(r)\n\n    def make_or(self, children):\n        cdef c_vector[shared_ptr[CNode]] c_children\n        cdef Node child\n        for child in children:\n            c_children.push_back(child.node)\n        cdef shared_ptr[CNode] r = TreeExprBuilder_MakeOr(c_children)\n        return Node.create(r)\n\n    def _make_in_expression_int32(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int32_t] c_values\n        cdef int32_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionInt32(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_int64(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int64_t] c_values\n        cdef int64_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionInt64(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_time32(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int32_t] c_values\n        cdef int32_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionTime32(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_time64(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int64_t] c_values\n        cdef int64_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionTime64(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_date32(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int32_t] c_values\n        cdef int32_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionDate32(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_date64(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int64_t] c_values\n        cdef int64_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionDate64(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_timestamp(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[int64_t] c_values\n        cdef int64_t v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionTimeStamp(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_binary(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[c_string] c_values\n        cdef c_string v\n        for v in values:\n            c_values.insert(v)\n        r = TreeExprBuilder_MakeInExpressionString(node.node, c_values)\n        return Node.create(r)\n\n    def _make_in_expression_string(self, Node node, values):\n        cdef shared_ptr[CNode] r\n        cdef c_unordered_set[c_string] c_values\n        cdef c_string _v\n        for v in values:\n            _v = v.encode('UTF-8')\n            c_values.insert(_v)\n        r = TreeExprBuilder_MakeInExpressionString(node.node, c_values)\n        return Node.create(r)\n\n    def make_in_expression(self, Node node, values, dtype):\n        cdef DataType type = ensure_type(dtype)\n\n        if type.id == _Type_INT32:\n            return self._make_in_expression_int32(node, values)\n        elif type.id == _Type_INT64:\n            return self._make_in_expression_int64(node, values)\n        elif type.id == _Type_TIME32:\n            return self._make_in_expression_time32(node, values)\n        elif type.id == _Type_TIME64:\n            return self._make_in_expression_time64(node, values)\n        elif type.id == _Type_TIMESTAMP:\n            return self._make_in_expression_timestamp(node, values)\n        elif type.id == _Type_DATE32:\n            return self._make_in_expression_date32(node, values)\n        elif type.id == _Type_DATE64:\n            return self._make_in_expression_date64(node, values)\n        elif type.id == _Type_BINARY:\n            return self._make_in_expression_binary(node, values)\n        elif type.id == _Type_STRING:\n            return self._make_in_expression_string(node, values)\n        else:\n            raise TypeError(\"Data type \" + str(dtype) + \" not supported.\")\n\n    def make_condition(self, Node condition):\n        cdef shared_ptr[CCondition] r = TreeExprBuilder_MakeCondition(\n            condition.node)\n        return Condition.create(r)\n\ncpdef make_projector(Schema schema, children, MemoryPool pool):\n    cdef c_vector[shared_ptr[CExpression]] c_children\n    cdef Expression child\n    for child in children:\n        c_children.push_back(child.expression)\n    cdef shared_ptr[CProjector] result\n    check_status(Projector_Make(schema.sp_schema, c_children,\n                                &result))\n    return Projector.create(result, pool)\n\ncpdef make_filter(Schema schema, Condition condition):\n    cdef shared_ptr[CFilter] result\n    check_status(Filter_Make(schema.sp_schema, condition.condition, &result))\n    return Filter.create(result)\n\ncdef class FunctionSignature:\n    \"\"\"\n    Signature of a Gandiva function including name, parameter types\n    and return type.\n    \"\"\"\n\n    cdef:\n        shared_ptr[CFunctionSignature] signature\n\n    def __init__(self):\n        raise TypeError(\"Do not call {}'s constructor directly.\"\n                        .format(self.__class__.__name__))\n\n    @staticmethod\n    cdef create(shared_ptr[CFunctionSignature] signature):\n        cdef FunctionSignature self = FunctionSignature.__new__(\n            FunctionSignature)\n        self.signature = signature\n        return self\n\n    def return_type(self):\n        return pyarrow_wrap_data_type(self.signature.get().ret_type())\n\n    def param_types(self):\n        result = []\n        cdef vector[shared_ptr[CDataType]] types = \\\n            self.signature.get().param_types()\n        for t in types:\n            result.append(pyarrow_wrap_data_type(t))\n        return result\n\n    def name(self):\n        return self.signature.get().base_name().decode()\n\n    def __repr__(self):\n        signature = self.signature.get().ToString().decode()\n        return \"FunctionSignature(\" + signature + \")\"\n\n\ndef get_registered_function_signatures():\n    \"\"\"\n    Return the function in Gandiva's ExpressionRegistry.\n\n    Returns\n    -------\n    registry: a list of registered function signatures\n    \"\"\"\n    results = []\n\n    cdef vector[shared_ptr[CFunctionSignature]] signatures = \\\n        GetRegisteredFunctionSignatures()\n\n    for signature in signatures:\n        results.append(FunctionSignature.create(signature))\n\n    return results\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.testDate1900.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.emptyFile.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.testDate1900.orc",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.emptyFile.orc",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/TestOrcFile.test1.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/decimal.orc",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/orc/decimal.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/parquet/v0.7.1.some-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/parquet/v0.7.1.column-metadata-handling.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/parquet/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyarrow-0.12.1-dhlcuw5emc3komv736uqohhqmvixwlif/spack-src/pyarrow/tests/data/parquet/v0.7.1.all-named-index.parquet"
    ],
    "total_files": 298
}