{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/nestkernel/dynamicloader.cpp": "/*\n *  dynamicloader.cpp\n *\n *  This file is part of NEST.\n *\n *  Copyright (C) 2004 The NEST Initiative\n *\n *  NEST is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  NEST is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/*\n   This file is part of NEST.\n\n   dynamicloader.cpp -- Implements the class DynamicLoaderModule\n   to allow for dymanically loaded modules for extending the kernel.\n\n   Author(s):\n   Moritz Helias\n\n   First Version: November 2005\n*/\n\n#include \"dynamicloader.h\"\n\n#ifdef HAVE_LIBLTDL\n\n// External includes:\n#include <ltdl.h>\n\n// Includes from libnestutil:\n#include \"logging.h\"\n\n// Includes from nestkernel:\n#include \"kernel_manager.h\"\n#include \"model.h\"\n\n// Includes from sli:\n#include \"integerdatum.h\"\n#include \"interpret.h\"\n#include \"stringdatum.h\"\n\n\nnamespace nest\n{\n\nstruct sDynModule\n{\n  std::string name;\n  lt_dlhandle handle;\n  SLIModule* pModule;\n\n  bool operator==( const sDynModule& rhs ) const\n  {\n    return name == rhs.name;\n  }\n\n  // operator!= must be implemented explicitly, not all compilers\n  // generate it automatically from operator==\n  bool operator!=( const sDynModule& rhs ) const\n  {\n    return not( *this == rhs );\n  }\n};\n\n// static member initialization\nDictionary* DynamicLoaderModule::moduledict_ = new Dictionary();\n\nvecLinkedModules&\nDynamicLoaderModule::getLinkedModules()\n{\n  static vecLinkedModules lm; // initialized empty on first call\n  return lm;\n}\n\n\n/*! At the time when DynamicLoaderModule is constructed, the SLI Interpreter\n  and NestModule must be already constructed and initialized.\n  DynamicLoaderModule relies on the presence of\n  the following SLI datastructures: Name, Dictionary.\n*/\nDynamicLoaderModule::DynamicLoaderModule( SLIInterpreter& interpreter )\n  : loadmodule_function( dyn_modules )\n{\n  interpreter.def( \"moduledict\", new DictionaryDatum( moduledict_ ) );\n}\n\nDynamicLoaderModule::~DynamicLoaderModule()\n{\n  // unload all loaded modules\n  for ( vecDynModules::iterator it = dyn_modules.begin();\n        it != dyn_modules.end();\n        ++it )\n  {\n    if ( it->handle != NULL )\n    {\n      lt_dlclose( it->handle );\n      it->handle = NULL;\n    }\n  }\n\n  lt_dlexit();\n}\n\n// The following concerns the new module: -----------------------\n\nconst std::string\nDynamicLoaderModule::name( void ) const\n{\n  return std::string( \"NEST-Dynamic Loader\" ); // Return name of the module\n}\n\nconst std::string\nDynamicLoaderModule::commandstring( void ) const\n{\n  return std::string( \"\" ); // Run associated SLI startup script\n}\n\n\n// auxiliary function to check name of module via its pointer\n// we cannot use a & for the second argument, as std::bind2nd() then\n// becomes confused, at least with g++ 4.0.1.\nbool\nhas_name( SLIModule const* const m, const std::string n )\n{\n  return m->name() == n;\n}\n\n\n/*\n  BeginDocumentation\n  Name: Install - Load a dynamic module to extend the functionality.\n  Description:\n  Synopsis: (module_name) Install -> handle\n*/\nDynamicLoaderModule::LoadModuleFunction::LoadModuleFunction(\n  vecDynModules& dyn_modules )\n  : dyn_modules_( dyn_modules )\n{\n}\n\nvoid\nDynamicLoaderModule::LoadModuleFunction::execute( SLIInterpreter* i ) const\n{\n  i->assert_stack_load( 1 );\n\n  if ( kernel().model_manager.has_user_models()\n    or kernel().model_manager.has_user_prototypes() )\n  {\n    throw DynamicModuleManagementError(\n      \"Modules cannot be installed after CopyModel has been called\" );\n  }\n\n  sDynModule new_module;\n\n  new_module.name = getValue< std::string >( i->OStack.top() );\n  if ( new_module.name.empty() )\n  {\n    throw DynamicModuleManagementError( \"Module name must not be empty.\" );\n  }\n\n  // check if module already loaded\n  // this check can happen here, since we are comparing dynamically loaded\n  // modules based on the name given to the Install command\n  if ( std::find( dyn_modules_.begin(), dyn_modules_.end(), new_module )\n    != dyn_modules_.end() )\n  {\n    throw DynamicModuleManagementError(\n      \"Module '\" + new_module.name + \"' is loaded already.\" );\n  }\n\n  // call lt_dlerror() to reset any error messages hanging around\n  lt_dlerror();\n  // try to open the module\n  const lt_dlhandle hModule = lt_dlopenext( new_module.name.c_str() );\n\n  if ( not hModule )\n  {\n    char* errstr = ( char* ) lt_dlerror();\n    std::string msg = \"Module '\" + new_module.name + \"' could not be opened.\";\n    if ( errstr )\n    {\n      msg += \"\\nThe dynamic loader returned the following error: '\"\n        + std::string( errstr ) + \"'.\";\n    }\n    msg += \"\\n\\nPlease check LD_LIBRARY_PATH (OSX: DYLD_LIBRARY_PATH)!\";\n    throw DynamicModuleManagementError( msg );\n  }\n\n  // see if we can find the mod symbol in the module\n  SLIModule* pModule = ( SLIModule* ) lt_dlsym( hModule, \"mod\" );\n  char* errstr = ( char* ) lt_dlerror();\n  if ( errstr )\n  {\n    lt_dlclose( hModule ); // close module again\n    lt_dlerror();          // remove any error caused by lt_dlclose()\n    throw DynamicModuleManagementError(\n            \"Module '\" + new_module.name + \"' could not be loaded.\\n\"\n            \"The dynamic loader returned the following error: '\"\n            + std::string(errstr) + \"'.\");\n  }\n\n  // check if module is linked in. This test is based on the module name\n  // returned by DynModule::name(), since we have no file names for linked\n  // modules. We can only perform it after we have loaded the module.\n  if ( std::find_if( DynamicLoaderModule::getLinkedModules().begin(),\n         DynamicLoaderModule::getLinkedModules().end(),\n         std::bind2nd( std::ptr_fun( has_name ), pModule->name() ) )\n    != DynamicLoaderModule::getLinkedModules().end() )\n  {\n    lt_dlclose( hModule ); // close module again\n    lt_dlerror();          // remove any error caused by lt_dlclose()\n    throw DynamicModuleManagementError(\n            \"Module '\" + new_module.name + \"' is linked into NEST.\\n\"\n            \"You neither need nor may load it dynamically in addition.\");\n  }\n\n  // all is well an we can register the module with the interpreter\n  try\n  {\n    pModule->install( std::cerr, i );\n  }\n  catch ( std::exception& e )\n  {\n    // We should uninstall the partially installed module here, but\n    // this must wait for #152.\n    // For now, we just close the module file and rethrow the exception.\n\n    lt_dlclose( hModule );\n    lt_dlerror(); // remove any error caused by lt_dlclose()\n    throw;        // no arg re-throws entire exception, see Stroustrup 14.3.1\n  }\n\n  // add the handle to list of loaded modules\n  new_module.handle = hModule;\n  new_module.pModule = pModule;\n  dyn_modules_.push_back( new_module );\n\n  LOG( M_INFO, \"Install\", ( \"loaded module \" + pModule->name() ).c_str() );\n\n  // remove operand and operator from stack\n  i->OStack.pop();\n  i->EStack.pop();\n\n  // put handle to module onto stack\n  int moduleid = dyn_modules_.size() - 1;\n  i->OStack.push( moduleid );\n  ( *moduledict_ )[ new_module.name ] = moduleid;\n\n  // now we can run the module initializer, after we have cleared the EStack\n  if ( not pModule->commandstring().empty() )\n  {\n    Token t = new StringDatum( pModule->commandstring() );\n    i->OStack.push_move( t );\n    Token c = new NameDatum( \"initialize_module\" );\n    i->EStack.push_move( c );\n  }\n}\n\nvoid\nDynamicLoaderModule::init( SLIInterpreter* i )\n{\n\n  // bind functions to terminal names\n  i->createcommand( \"Install\", &loadmodule_function );\n\n  // initialize ltdl library for loading dynamic modules\n\n  int dl_error = lt_dlinit();\n\n  if ( not dl_error )\n  {\n    const char* path = getenv( \"NEST_MODULE_PATH\" );\n    if ( path != NULL )\n    {\n      LOG( M_DEBUG, \"DynamicLoaderModule::init\", \"Setting module path to\" );\n      LOG( M_DEBUG, \"DynamicLoaderModule::init\", path );\n\n      dl_error = lt_dlsetsearchpath( path );\n      if ( dl_error )\n      {\n        LOG( M_ERROR,\n          \"DynamicLoaderModule::init\",\n          \"Could not set dynamic module path.\" );\n      }\n    }\n  }\n  else\n  {\n    LOG( M_ERROR,\n      \"DynamicLoaderModule::init\",\n      \"Could not initialize libltdl. No dynamic modules will be avaiable.\" );\n  }\n}\n\n\nint\nDynamicLoaderModule::registerLinkedModule( SLIModule* pModule )\n{\n  assert( pModule != 0 );\n  getLinkedModules().push_back( pModule );\n  return getLinkedModules().size();\n}\n\nvoid\nDynamicLoaderModule::initLinkedModules( SLIInterpreter& interpreter )\n{\n\n  for ( vecLinkedModules::iterator it = getLinkedModules().begin();\n        it != getLinkedModules().end();\n        ++it )\n  {\n    interpreter.message( SLIInterpreter::M_STATUS,\n      \"DynamicLoaderModule::initLinkedModules\",\n      \"adding linked module\" );\n    interpreter.message( SLIInterpreter::M_STATUS,\n      \"DynamicLoaderModule::initLinkedModules\",\n      ( *it )->name().c_str() );\n    interpreter.addlinkedusermodule( *it );\n  }\n}\n\n\n} // namespace nest\n\n#endif // HAVE_LIBLTDL\n",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/pynest/nest/__init__.py": "# -*- coding: utf-8 -*-\n#\n# __init__.py\n#\n# This file is part of NEST.\n#\n# Copyright (C) 2004 The NEST Initiative\n#\n# NEST is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# NEST is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with NEST.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nInitializer of PyNEST.\n\"\"\"\n\nimport sys\nimport os\n\n# This is a workaround for readline import errors encountered with Anaconda\n# Python running on Ubuntu, when invoked from the terminal\n# \"python -c 'import nest'\"\nif 'linux' in sys.platform and 'Anaconda' in sys.version:\n    import readline\n\n# This is a workaround to avoid segmentation faults when importing\n# scipy *after* nest. See https://github.com/numpy/numpy/issues/2521\ntry:\n    import scipy\nexcept:\n    pass\n\n# Make MPI-enabled NEST import properly. The underlying problem is that the\n# shared object pynestkernel dynamically opens other libraries that open\n# yet other libraries.\ntry:\n    # Python 3.3 and later has flags in os\n    sys.setdlopenflags(os.RTLD_NOW | os.RTLD_GLOBAL)\nexcept AttributeError:\n    # Python 2.6 and 2.7 have flags in ctypes, but RTLD_NOW may only\n    # be available in dl or DLFCN and is required at least under\n    # Ubuntu 14.04. The latter two are not available under OSX,\n    # but OSX does not have and does not need RTLD_NOW. We therefore\n    # first try dl and DLFCN, then ctypes just for OSX.\n    try:\n        import dl\n        sys.setdlopenflags(dl.RTLD_GLOBAL | dl.RTLD_NOW)\n    except (ImportError, AttributeError):\n        try:\n            import DLFCN\n            sys.setdlopenflags(DLFCN.RTLD_GLOBAL | DLFCN.RTLD_NOW)\n        except (ImportError, AttributeError):\n            import ctypes\n            try:\n                sys.setdlopenflags(ctypes.RTLD_GLOBAL | ctypes.RTLD_NOW)\n            except AttributeError:\n                # We must test this last, since it is the only case without\n                # RTLD_NOW (OSX)\n                sys.setdlopenflags(ctypes.RTLD_GLOBAL)\n\nfrom . import pynestkernel as _kernel      # noqa\nfrom .lib import hl_api_helper as hl_api   # noqa\n\nengine = _kernel.NESTEngine()\n\nsli_push = hl_api.sps = engine.push\nsli_pop = hl_api.spp = engine.pop\nhl_api.pcd = engine.push_connection_datums\nhl_api.kernel = _kernel\n\ninitialized = False\n\n\ndef catching_sli_run(cmd):\n    \"\"\"Send a command string to the NEST kernel to be executed, catch\n    SLI errors and re-raise them in Python.\n\n    Parameters\n    ----------\n    cmd : str\n        The SLI command to be executed.\n    Raises\n    ------\n    NESTError\n        SLI errors are bubbled to the Python API as NESTErrors.\n    \"\"\"\n\n    if sys.version_info >= (3, ):\n        def encode(s):\n            return s\n\n        def decode(s):\n            return s\n    else:\n        def encode(s):\n            return s.encode('utf-8')\n\n        def decode(s):\n            return s.decode('utf-8')\n\n    engine.run('{%s} runprotected' % decode(cmd))\n    if not sli_pop():\n        errorname = sli_pop()\n        message = sli_pop()\n        commandname = sli_pop()\n        engine.run('clear')\n        errorstring = '%s in %s%s' % (errorname, commandname, message)\n        raise _kernel.NESTError(encode(errorstring))\n\nsli_run = hl_api.sr = catching_sli_run\n\n\ndef sli_func(s, *args, **kwargs):\n    \"\"\"Convenience function for executing an SLI command s with\n    arguments args.\n\n    This executes the SLI sequence:\n    ``sli_push(args); sli_run(s); y=sli_pop()``\n\n    Parameters\n    ----------\n    s : str\n        Function to call\n    *args\n        Arbitrary number of arguments to pass to the SLI function\n    **kwargs\n        namespace : str\n            The sli code is executed in the given SLI namespace.\n        litconv : bool\n            Convert string args beginning with / to literals.\n\n    Returns\n    -------\n    The function may have multiple return values. The number of return values\n    is determined by the SLI function that was called.\n\n    Examples\n    --------\n    r,q = sli_func('dup rollu add',2,3)\n    r   = sli_func('add',2,3)\n    r   = sli_func('add pop',2,3)\n    l   = sli_func('CreateLayer', {...}, namespace='topology')\n    \"\"\"\n\n    # check for namespace\n    slifun = 'sli_func'  # version not converting to literals\n    if 'namespace' in kwargs:\n        s = kwargs['namespace'] + ' using ' + s + ' endusing'\n    elif 'litconv' in kwargs:\n        if kwargs['litconv']:\n            slifun = 'sli_func_litconv'\n    elif len(kwargs) > 0:\n        _kernel.NESTError(\n            \"'namespace' and 'litconv' are the only valid keyword arguments.\")\n\n    sli_push(args)       # push array of arguments on SLI stack\n    sli_push(s)          # push command string\n    sli_run(slifun)      # SLI support code to execute s on args\n    r = sli_pop()        # return value is an array\n\n    if len(r) == 1:      # 1 return value is no tuple\n        return r[0]\n\n    if len(r) != 0:\n        return r\n\nhl_api.sli_func = sli_func\n\n\ndef init(argv):\n    \"\"\"Initializes NEST.\n\n    Parameters\n    ----------\n    argv : list\n        Command line arguments, passed to the NEST kernel\n\n    Raises\n    ------\n    _kernel.NESTError\n    \"\"\"\n\n    global initialized\n\n    if initialized:\n        raise _kernel.NESTError(\"NEST already initialized.\")\n        return\n\n    quiet = False\n    if argv.count(\"--quiet\"):\n        quiet = True\n        argv.remove(\"--quiet\")\n\n    initialized |= engine.init(argv, __path__[0])\n\n    if initialized:\n        if not quiet:\n            engine.run(\"pywelcome\")\n\n        # Dirty hack to get tab-completion for models in IPython.\n        try:\n            __IPYTHON__\n        except NameError:\n            pass\n        else:\n            try:\n                import keyword\n                keyword.kwlist += Models()\n            except ImportError:\n                pass\n\n    else:\n        _kernel.NESTError(\"Initiatization of NEST failed.\")\n\n\ndef test():\n    \"\"\"Runs all PyNEST unit tests.\"\"\"\n    from . import tests\n    import unittest\n\n    debug = hl_api.get_debug()\n    hl_api.set_debug(True)\n\n    runner = unittest.TextTestRunner(verbosity=2)\n    runner.run(tests.suite())\n\n    hl_api.set_debug(debug)\n\nfrom .pynestkernel import *         # noqa\nfrom .lib.hl_api_helper import *    # noqa\n\n# We search through the subdirectory \"lib\" of the \"nest\" module\n# directory and import the content of all Python files therein into\n# the global namespace. This makes the API functions of PyNEST itself\n# and those of extra modules available to the user.\nfor name in os.listdir(os.path.join(os.path.dirname(__file__), \"lib\")):\n    if name.endswith(\".py\") and not name.startswith('__'):\n        exec(\"from .lib.{0} import *\".format(name[:-3]))\n\nif 'DELAY_PYNEST_INIT' not in os.environ:\n    init(sys.argv)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-initiative.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-initiative-www.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-simulated.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-initiative-www.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-simulated-www.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-simulated.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-initiative.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/logos/nest-simulated-www.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/vm_one_neuron_noise.pdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Divergent_connect.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/vm_psp_two_neurons.pdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Receptor_types.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/sample2_rectanchor.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/spikes_one_neuron_noise.pdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/sample4_gaussweights.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/MultimeterExample.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/vm_one_neuron.pdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/vm_psp_two_neurons.pdf-w400.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/sample3_doughnutlinear.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Fixed_outdegree.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Process_vp_thread.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/time_definitions-300x61.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/precise2-300x171.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/All_to_all.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Fixed_indegree.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/precise1-300x175.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/sample1_circgauss.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Node_distribution.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/One_to_one.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/spikes_one_neuron.pdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/Convergent_connect.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/python_interface.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/free.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/userdoc/img/simulation_loop-241x300.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/extras/ConnPlotter/doc/connplotter_tutorial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/Topology_UserManual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/vislayer.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn5.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer4_3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn4.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn1.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer3a.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer2.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn6.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer3.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn_3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn2.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer1.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/conn3.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/layer4.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/topology/doc/user_manual_figures/player.png",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/doc/nest_by_example/NEST_by_Example.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-nest-2.14.0-jtnxgypuuze2ua536ojse3btzzmjtj3t/spack-src/doc/nest_by_example/figures/brunel_detailed_external_single2.jpg"
    ],
    "total_files": 1388
}