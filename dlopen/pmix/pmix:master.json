{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/.travis.yml": "sudo: false\ndist: xenial\narch:\n  - amd64\n  - ppc64le\n\n\ncache:\n  apt: true\n\nlanguage: python\npython:\n  - \"3.5\"\n\naddons:\n  apt:\n    packages:\n      - perl\n      - pandoc\n      - libevent-dev\n      - libhwloc-dev\n\nenv:\n    global:\n        - AM_MAKEFLAGS=\"-j4\"\n        - PRRTE_PREFIX=\"$HOME/bogus\"\n        - PRRTE_CONFIGURE_ARGS=\"--prefix=$PRRTE_PREFIX\"\n        - DISTCHECK_CONFIGURE_FLAGS=\"$PRRTE_CONFIGURE_ARGS --disable-dlopen\"\n\njobs:\n  fast_finish: true\n  include:\n    - compiler: gcc\n      env:\n        - CFLAGS=\"-Wall -Wextra -Wno-unused-function -Wno-unused-parameter -Wno-type-limits -Wno-missing-field-initializers -Wno-sign-compare -Wno-missing-braces\"\n          ENABLE_WERROR=\"--enable-werror\"\n    - compiler: gcc\n      env:\n        - CFLAGS=\"-fsanitize=undefined\"  # TODO: add -fsanitize=address\n    - compiler: clang\n      env:\n        - CFLAGS=\"-Wall -Wextra -Wno-unused-function -Wno-unused-parameter -Wno-type-limits -Wno-missing-field-initializers -Wno-sign-compare -Wno-missing-braces\"\n          ENABLE_WERROR=\"--enable-werror\"\n    # TODO:\n    #- compiler: clang\n    #  env:\n    #    - CFLAGS=\"-fsanitize=address\"\n    #      ASAN_OPTIONS=detect_stack_use_after_return=1:detect_leaks=1:check_initialization_order=true:strict_init_order=true:detect_stack_use_after_scope=1\n    - compiler: clang\n      env:\n        - CFLAGS=\"-fsanitize=undefined\"\n\nscript:\n        # prepare\n        # build\n        - ./autogen.pl\n        - pip install -q cython\n        - ./configure ${ENABLE_WERROR}\n        - if [ $? -ne 0 ]; then cat config.log; fi\n        - make all\n        # test\n        - make check\n        - cat test/test-suite.log\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/Makefile.am": "#\n# Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n#                         University Research and Technology\n#                         Corporation.  All rights reserved.\n# Copyright (c) 2004-2005 The University of Tennessee and The University\n#                         of Tennessee Research Foundation.  All rights\n#                         reserved.\n# Copyright (c) 2004-2009 High Performance Computing Center Stuttgart,\n#                         University of Stuttgart.  All rights reserved.\n# Copyright (c) 2004-2005 The Regents of the University of California.\n#                         All rights reserved.\n# Copyright (c) 2006-2016 Cisco Systems, Inc.  All rights reserved.\n# Copyright (c) 2012-2013 Los Alamos National Security, Inc.  All rights reserved.\n# Copyright (c) 2013-2020 Intel, Inc.  All rights reserved.\n# Copyright (c) 2019      Amazon.com, Inc. or its affiliates.  All Rights\n#                         reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\n# Note that the -I directory must *exactly* match what was specified\n# via AC_CONFIG_MACRO_DIR in configure.ac.\nACLOCAL_AMFLAGS = -I ./config\n\nSUBDIRS = config contrib include src etc bindings\n\nAM_DISTCHECK_CONFIGURE_FLAGS = --disable-dlopen\n\nheaders =\nsources =\nnodist_headers =\nEXTRA_DIST = AUTHORS README HACKING INSTALL VERSION LICENSE autogen.pl Makefile.pmix-rules\n\n# Only install the valgrind suppressions file and man pages\n# if we're building in standalone mode\ndist_pmixdata_DATA =\nif ! PMIX_EMBEDDED_MODE\ndist_pmixdata_DATA += contrib/pmix-valgrind.supp\n\nendif\n\nif PMIX_TESTS_EXAMPLES\nSUBDIRS += . test examples\nendif\n\nif WANT_INSTALL_HEADERS\npmixdir = $(pmixincludedir)/$(subdir)\nnobase_pmix_HEADERS = $(headers)\n\nelse\n\nnoinst_HEADERS = $(headers)\nendif\n\nnroff:\n\t(cd man; $(MAKE) nroff)\n\ndist-hook:\n\tenv LS_COLORS= sh \"$(top_srcdir)/config/distscript.sh\" \"$(top_srcdir)\" \"$(distdir)\" \"$(PMIX_VERSION)\" \"$(PMIX_REPO_REV)\"\n\npkgconfigdir = $(libdir)/pkgconfig\npkgconfig_DATA = maint/pmix.pc\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/config/pmix.m4": "dnl -*- shell-script -*-\ndnl\ndnl Copyright (c) 2004-2010 The Trustees of Indiana University and Indiana\ndnl                         University Research and Technology\ndnl                         Corporation.  All rights reserved.\ndnl Copyright (c) 2004-2005 The University of Tennessee and The University\ndnl                         of Tennessee Research Foundation.  All rights\ndnl                         reserved.\ndnl Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\ndnl                         University of Stuttgart.  All rights reserved.\ndnl Copyright (c) 2004-2005 The Regents of the University of California.\ndnl                         All rights reserved.\ndnl Copyright (c) 2006-2020 Cisco Systems, Inc.  All rights reserved\ndnl Copyright (c) 2007      Sun Microsystems, Inc.  All rights reserved.\ndnl Copyright (c) 2009-2021 IBM Corporation.  All rights reserved.\ndnl Copyright (c) 2009      Los Alamos National Security, LLC.  All rights\ndnl                         reserved.\ndnl Copyright (c) 2009-2011 Oak Ridge National Labs.  All rights reserved.\ndnl Copyright (c) 2011-2013 NVIDIA Corporation.  All rights reserved.\ndnl Copyright (c) 2013-2020 Intel, Inc.  All rights reserved.\ndnl Copyright (c) 2015-2019 Research Organization for Information Science\ndnl                         and Technology (RIST).  All rights reserved.\ndnl Copyright (c) 2016      Mellanox Technologies, Inc.\ndnl                         All rights reserved.\ndnl\ndnl Copyright (c) 2021      Nanook Consulting.  All rights reserved.\ndnl $COPYRIGHT$\ndnl\ndnl Additional copyrights may follow\ndnl\ndnl $HEADER$\ndnl\n\nAC_DEFUN([PMIX_SETUP_CORE],[\n\n    AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n    AC_REQUIRE([AC_CANONICAL_TARGET])\n\n    # AM_PROG_CC_C_O AC_REQUIREs AC_PROG_CC, so we have to be a little\n    # careful about ordering here, and AC_REQUIRE these things so that\n    # they get stamped out in the right order.\n    AC_REQUIRE([_PMIX_START_SETUP_CC])\n    AC_REQUIRE([_PMIX_PROG_CC])\n    AC_REQUIRE([AM_PROG_CC_C_O])\n\n\n    # initialize\n    PMIX_EMBEDDED_LDFLAGS=\n    PMIX_EMBEDDED_LIBS=\n    PMIX_EMBEDDED_CPPFLAGS=\n\n    # If no prefix was defined, set a good value\n    m4_ifval([$1],\n             [m4_define([pmix_config_prefix],[$1/])],\n             [m4_define([pmix_config_prefix], [])])\n\n    # Get pmix's absolute top builddir (which may not be the same as\n    # the real $top_builddir)\n    PMIX_startdir=`pwd`\n    if test x\"pmix_config_prefix\" != \"x\" && test ! -d \"pmix_config_prefix\"; then\n        mkdir -p \"pmix_config_prefix\"\n    fi\n    if test x\"pmix_config_prefix\" != \"x\"; then\n        cd \"pmix_config_prefix\"\n    fi\n    PMIX_top_builddir=`pwd`\n    AC_SUBST(PMIX_top_builddir)\n\n    # Get pmix's absolute top srcdir (which may not be the same as the\n    # real $top_srcdir.  First, go back to the startdir incase the\n    # $srcdir is relative.\n\n    cd \"$PMIX_startdir\"\n    cd \"$srcdir\"/pmix_config_prefix\n    PMIX_top_srcdir=\"`pwd`\"\n    AC_SUBST(PMIX_top_srcdir)\n\n    # Go back to where we started\n    cd \"$PMIX_startdir\"\n\n    AC_MSG_NOTICE([pmix builddir: $PMIX_top_builddir])\n    AC_MSG_NOTICE([pmix srcdir: $PMIX_top_srcdir])\n    if test \"$PMIX_top_builddir\" != \"$PMIX_top_srcdir\"; then\n        AC_MSG_NOTICE([Detected VPATH build])\n    fi\n\n    # Get the version of pmix that we are installing\n    AC_MSG_CHECKING([for pmix version])\n    PMIX_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_MSG_RESULT([$PMIX_VERSION])\n    AC_SUBST(PMIX_VERSION)\n    AC_DEFINE_UNQUOTED([PMIX_VERSION], [\"$PMIX_VERSION\"],\n                       [The library version is always available, contrary to VERSION])\n\n    PMIX_RELEASE_DATE=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --release-date`\"\n    AC_SUBST(PMIX_RELEASE_DATE)\n\n    # Save the breakdown the version information\n    PMIX_MAJOR_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --major`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_MAJOR_VERSION)\n    AC_DEFINE_UNQUOTED([PMIX_MAJOR_VERSION], [$PMIX_MAJOR_VERSION],\n                       [The library major version is always available, contrary to VERSION])\n\n    PMIX_MINOR_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --minor`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_MINOR_VERSION)\n    AC_DEFINE_UNQUOTED([PMIX_MINOR_VERSION], [$PMIX_MINOR_VERSION],\n                       [The library minor version is always available, contrary to VERSION])\n\n    PMIX_RELEASE_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --release`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_RELEASE_VERSION)\n    AC_DEFINE_UNQUOTED([PMIX_RELEASE_VERSION], [$PMIX_RELEASE_VERSION],\n                       [The library release version is always available, contrary to VERSION])\n\n    pmixmajor=${PMIX_MAJOR_VERSION}L\n    pmixminor=${PMIX_MINOR_VERSION}L\n    pmixrelease=${PMIX_RELEASE_VERSION}L\n    pmixnumeric=$(printf 0x%4.4x%2.2x%2.2x $PMIX_MAJOR_VERSION $PMIX_MINOR_VERSION $PMIX_RELEASE_VERSION)\n    AC_SUBST(pmixmajor)\n    AC_SUBST(pmixminor)\n    AC_SUBST(pmixrelease)\n    AC_SUBST(pmixnumeric)\n    AC_CONFIG_FILES(pmix_config_prefix[include/pmix_version.h])\n\n    PMIX_GREEK_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --greek`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_GREEK_VERSION)\n\n    AC_MSG_CHECKING([for pmix standard version])\n    PMIX_STD_VERSION=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --std-version`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_MSG_RESULT([$PMIX_STD_VERSION])\n    AC_SUBST(PMIX_STD_VERSION)\n    AC_DEFINE_UNQUOTED([PMIX_STD_VERSION], [\"$PMIX_STD_VERSION\"],\n                       [The PMIx Standard compliance level])\n\n    PMIX_REPO_REV=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --repo-rev`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_REPO_REV)\n    AC_DEFINE_UNQUOTED([PMIX_REPO_REV], [\"$PMIX_REPO_REV\"],\n                       [The OpenPMIx Git Revision])\n\n    # A hint to tell us if we are working with a build from Git or a tarball.\n    # Helpful when preparing diagnostic output.\n    if test -e $PMIX_TOP_SRCDIR/.git; then\n        AC_DEFINE_UNQUOTED([PMIX_GIT_REPO_BUILD], [\"1\"],\n            [If built from a git repo])\n    fi\n\n    PMIX_RELEASE_DATE=\"`$PMIX_top_srcdir/config/pmix_get_version.sh $PMIX_top_srcdir/VERSION --release-date`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_SUBST(PMIX_RELEASE_DATE)\n\n    # Debug mode?\n    AC_MSG_CHECKING([if want pmix maintainer support])\n    pmix_debug=\n    AS_IF([test \"$pmix_debug\" = \"\" && test \"$enable_debug\" = \"yes\"],\n          [pmix_debug=1\n           pmix_debug_msg=\"enabled\"])\n    AS_IF([test \"$pmix_debug\" = \"\"],\n          [pmix_debug=0\n           pmix_debug_msg=\"disabled\"])\n    # Grr; we use #ifndef for PMIX_DEBUG!  :-(\n    AH_TEMPLATE(PMIX_ENABLE_DEBUG, [Whether we are in debugging mode or not])\n    AS_IF([test \"$pmix_debug\" = \"1\"], [AC_DEFINE([PMIX_ENABLE_DEBUG])])\n    AC_MSG_RESULT([$pmix_debug_msg])\n\n    AC_MSG_CHECKING([for pmix directory prefix])\n    AC_MSG_RESULT(m4_ifval([$1], pmix_config_prefix, [(none)]))\n\n    # Note that private/config.h *MUST* be listed first so that it\n    # becomes the \"main\" config header file.  Any AC-CONFIG-HEADERS\n    # after that (pmix/config.h) will only have selective #defines\n    # replaced, not the entire file.\n    AC_CONFIG_HEADERS(pmix_config_prefix[src/include/pmix_config.h])\n\n\n    # Add any extra lib?\n    AC_ARG_WITH([pmix-extra-lib],\n                AC_HELP_STRING([--with-pmix-extra-lib=LIB],\n                               [Link the output PMIx library to this extra lib (used in embedded mode)]))\n    AC_MSG_CHECKING([for extra lib])\n    AS_IF([test ! -z \"$with_pmix_extra_lib\"],\n          [AS_IF([test \"$with_pmix_extra_lib\" = \"yes\" || test \"$with_pmix_extra_lib\" = \"no\"],\n                 [AC_MSG_RESULT([ERROR])\n                  AC_MSG_WARN([Invalid value for --with-extra-pmix-lib:])\n                  AC_MSG_WARN([    $with_pmix_extra_lib])\n                  AC_MSG_WARN([Must be path name of the library to add])\n                  AC_MSG_ERROR([Cannot continue])],\n                 [AC_MSG_RESULT([$with_pmix_extra_lib])\n                  PMIX_EXTRA_LIB=$with_pmix_extra_lib])],\n          [AC_MSG_RESULT([no])\n           PMIX_EXTRA_LIB=])\n    AC_SUBST(PMIX_EXTRA_LIB)\n\n    # Add any extra libtool lib?\n    AC_ARG_WITH([pmix-extra-ltlib],\n                AC_HELP_STRING([--with-pmix-extra-ltlib=LIB],\n                               [Link any embedded components/tools that require it to the provided libtool lib (used in embedded mode)]))\n    AC_MSG_CHECKING([for extra ltlib])\n    AS_IF([test ! -z \"$with_pmix_extra_ltlib\"],\n          [AS_IF([test \"$with_pmix_extra_ltlib\" = \"yes\" || test \"$with_pmix_extra_ltlib\" = \"no\"],\n                 [AC_MSG_RESULT([ERROR])\n                  AC_MSG_WARN([Invalid value for --with-pmix-extra-ltlib:])\n                  AC_MSG_WARN([    $with_pmix_extra_ltlib])\n                  AC_MSG_WARN([Must be path name of the library to add])\n                  AC_MSG_ERROR([Cannot continue])],\n                 [AC_MSG_RESULT([$with_pmix_extra_ltlib])\n                  PMIX_EXTRA_LTLIB=$with_pmix_extra_ltlib])],\n          [AC_MSG_RESULT([no])\n           PMIX_EXTRA_LTLIB=])\n    AC_SUBST(PMIX_EXTRA_LTLIB)\n\n    #\n    # Package/brand string\n    #\n    AC_MSG_CHECKING([if want package/brand string])\n    AC_ARG_WITH([pmix-package-string],\n         [AC_HELP_STRING([--with-pmix-package-string=STRING],\n                         [Use a branding string throughout PMIx])])\n    if test \"$with_pmix_package_string\" = \"\" || test \"$with_pmix_package_string\" = \"no\"; then\n        with_package_string=\"PMIx $PMIX_CONFIGURE_USER@$PMIX_CONFIGURE_HOST Distribution\"\n    fi\n    AC_DEFINE_UNQUOTED([PMIX_PACKAGE_STRING], [\"$with_package_string\"],\n         [package/branding string for PMIx])\n    AC_MSG_RESULT([$with_package_string])\n\n\n    # GCC specifics.\n    if test \"x$GCC\" = \"xyes\"; then\n        PMIX_GCC_CFLAGS=\"-Wall -Wmissing-prototypes -Wundef\"\n        PMIX_GCC_CFLAGS=\"$PMIX_GCC_CFLAGS -Wpointer-arith -Wcast-align\"\n    fi\n\n    ############################################################################\n    # Check for compilers and preprocessors\n    ############################################################################\n    pmix_show_title \"Compiler and preprocessor tests\"\n\n    PMIX_SETUP_CC\n\n    #\n    # Check for some types\n    #\n\n    AC_CHECK_TYPES(int8_t)\n    AC_CHECK_TYPES(uint8_t)\n    AC_CHECK_TYPES(int16_t)\n    AC_CHECK_TYPES(uint16_t)\n    AC_CHECK_TYPES(int32_t)\n    AC_CHECK_TYPES(uint32_t)\n    AC_CHECK_TYPES(int64_t)\n    AC_CHECK_TYPES(uint64_t)\n    AC_CHECK_TYPES(__int128)\n    AC_CHECK_TYPES(uint128_t)\n    AC_CHECK_TYPES(long long)\n\n    AC_CHECK_TYPES(intptr_t)\n    AC_CHECK_TYPES(uintptr_t)\n    AC_CHECK_TYPES(ptrdiff_t)\n\n    #\n    # Check for type sizes\n    #\n\n    AC_CHECK_SIZEOF(_Bool)\n    AC_CHECK_SIZEOF(char)\n    AC_CHECK_SIZEOF(short)\n    AC_CHECK_SIZEOF(int)\n    AC_CHECK_SIZEOF(long)\n    if test \"$ac_cv_type_long_long\" = yes; then\n        AC_CHECK_SIZEOF(long long)\n    fi\n    AC_CHECK_SIZEOF(float)\n    AC_CHECK_SIZEOF(double)\n\n    AC_CHECK_SIZEOF(void *)\n    AC_CHECK_SIZEOF(size_t)\n    if test \"$ac_cv_type_ssize_t\" = yes ; then\n        AC_CHECK_SIZEOF(ssize_t)\n    fi\n    if test \"$ac_cv_type_ptrdiff_t\" = yes; then\n        AC_CHECK_SIZEOF(ptrdiff_t)\n    fi\n    AC_CHECK_SIZEOF(wchar_t)\n\n    AC_CHECK_SIZEOF(pid_t)\n\n    #\n    # Check for type alignments\n    #\n\n    PMIX_C_GET_ALIGNMENT(bool, PMIX_ALIGNMENT_BOOL)\n    PMIX_C_GET_ALIGNMENT(int8_t, PMIX_ALIGNMENT_INT8)\n    PMIX_C_GET_ALIGNMENT(int16_t, PMIX_ALIGNMENT_INT16)\n    PMIX_C_GET_ALIGNMENT(int32_t, PMIX_ALIGNMENT_INT32)\n    PMIX_C_GET_ALIGNMENT(int64_t, PMIX_ALIGNMENT_INT64)\n    PMIX_C_GET_ALIGNMENT(char, PMIX_ALIGNMENT_CHAR)\n    PMIX_C_GET_ALIGNMENT(short, PMIX_ALIGNMENT_SHORT)\n    PMIX_C_GET_ALIGNMENT(wchar_t, PMIX_ALIGNMENT_WCHAR)\n    PMIX_C_GET_ALIGNMENT(int, PMIX_ALIGNMENT_INT)\n    PMIX_C_GET_ALIGNMENT(long, PMIX_ALIGNMENT_LONG)\n    if test \"$ac_cv_type_long_long\" = yes; then\n        PMIX_C_GET_ALIGNMENT(long long, PMIX_ALIGNMENT_LONG_LONG)\n    fi\n    PMIX_C_GET_ALIGNMENT(float, PMIX_ALIGNMENT_FLOAT)\n    PMIX_C_GET_ALIGNMENT(double, PMIX_ALIGNMENT_DOUBLE)\n    if test \"$ac_cv_type_long_double\" = yes; then\n        PMIX_C_GET_ALIGNMENT(long double, PMIX_ALIGNMENT_LONG_DOUBLE)\n    fi\n    PMIX_C_GET_ALIGNMENT(void *, PMIX_ALIGNMENT_VOID_P)\n    PMIX_C_GET_ALIGNMENT(size_t, PMIX_ALIGNMENT_SIZE_T)\n\n\n    #\n    # Does the C compiler native support \"bool\"? (i.e., without\n    # <stdbool.h> or any other help)\n    #\n\n    PMIX_VAR_SCOPE_PUSH([MSG])\n    AC_MSG_CHECKING(for C bool type)\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n                                          AC_INCLUDES_DEFAULT],\n                                       [[bool bar, foo = true; bar = foo;]])],\n                      [PMIX_NEED_C_BOOL=0 MSG=yes],[PMIX_NEED_C_BOOL=1 MSG=no])\n    AC_DEFINE_UNQUOTED(PMIX_NEED_C_BOOL, $PMIX_NEED_C_BOOL,\n                       [Whether the C compiler supports \"bool\" without any other help (such as <stdbool.h>)])\n    AC_MSG_RESULT([$MSG])\n    AC_CHECK_SIZEOF(_Bool)\n    PMIX_VAR_SCOPE_POP\n\n    #\n    # Check for other compiler characteristics\n    #\n\n    PMIX_VAR_SCOPE_PUSH([PMIX_CFLAGS_save])\n    if test \"$GCC\" = \"yes\"; then\n\n        # gcc 2.96 will emit oodles of warnings if you use \"inline\" with\n        # -pedantic (which we do in developer builds).  However,\n        # \"__inline__\" is ok.  So we have to force gcc to select the\n        # right one.  If you use -pedantic, the AC_C_INLINE test will fail\n        # (because it names a function foo() -- without the (void)).  So\n        # we turn off all the picky flags, turn on -ansi mode (which is\n        # implied by -pedantic), and set warnings to be errors.  Hence,\n        # this does the following (for 2.96):\n        #\n        # - causes the check for \"inline\" to emit a warning, which then\n        # fails\n        # - checks for __inline__, which then emits no error, and works\n        #\n        # This also works nicely for gcc 3.x because \"inline\" will work on\n        # the first check, and all is fine.  :-)\n\n        PMIX_CFLAGS_save=$CFLAGS\n        CFLAGS=\"$PMIX_CFLAGS_BEFORE_PICKY -Werror -ansi\"\n    fi\n    AC_C_INLINE\n    if test \"$GCC\" = \"yes\"; then\n        CFLAGS=$PMIX_CFLAGS_save\n    fi\n    PMIX_VAR_SCOPE_POP\n\n    if test \"x$CC\" = \"xicc\"; then\n        PMIX_CHECK_ICC_VARARGS\n    fi\n\n\n    ##################################\n    # Only after setting up\n    # C do we check compiler attributes.\n    ##################################\n\n    pmix_show_subtitle \"Compiler characteristics\"\n\n    PMIX_CHECK_ATTRIBUTES\n    PMIX_CHECK_COMPILER_VERSION_ID\n\n    ##################################\n    # Assembler Configuration\n    ##################################\n\n    pmix_show_subtitle \"Assembler\"\n\n    AM_PROG_AS\n    AC_PATH_PROG(PERL, perl, perl)\n    PMIX_CONFIG_ASM\n\n\n    ##################################\n    # Header files\n    ##################################\n\n    pmix_show_title \"Header file tests\"\n\n    AC_CHECK_HEADERS([arpa/inet.h \\\n                      fcntl.h ifaddrs.h inttypes.h libgen.h \\\n                      net/uio.h netinet/in.h \\\n                      stdint.h stddef.h \\\n                      stdlib.h string.h strings.h \\\n                      sys/ioctl.h sys/param.h \\\n                      sys/select.h sys/socket.h sys/sockio.h \\\n                      stdarg.h sys/stat.h sys/time.h \\\n                      sys/types.h sys/un.h sys/uio.h \\\n                      sys/wait.h syslog.h \\\n                      time.h unistd.h dirent.h \\\n                      crt_externs.h signal.h \\\n                      ioLib.h sockLib.h hostLib.h limits.h \\\n                      sys/fcntl.h sys/statfs.h sys/statvfs.h \\\n                      netdb.h ucred.h zlib.h sys/auxv.h \\\n                      sys/sysctl.h termio.h termios.h pty.h \\\n                      libutil.h util.h grp.h sys/cdefs.h utmp.h stropts.h \\\n                      sys/utsname.h])\n\n    AC_CHECK_HEADERS([sys/mount.h], [], [],\n                     [AC_INCLUDES_DEFAULT\n                      #if HAVE_SYS_PARAM_H\n                      #include <sys/param.h>\n                      #endif\n                      ])\n\n    AC_CHECK_HEADERS([sys/sysctl.h], [], [],\n                     [AC_INCLUDES_DEFAULT\n                      #if HAVE_SYS_PARAM_H\n                      #include <sys/param.h>\n                      #endif\n                      ])\n\n    # Needed to work around Darwin requiring sys/socket.h for\n    # net/if.h\n    AC_CHECK_HEADERS([net/if.h], [], [],\n                     [#include <stdio.h>\n                      #if STDC_HEADERS\n                      # include <stdlib.h>\n                      # include <stddef.h>\n                      #else\n                      # if HAVE_STDLIB_H\n                      #  include <stdlib.h>\n                      # endif\n                      #endif\n                      #if HAVE_SYS_SOCKET_H\n                      # include <sys/socket.h>\n                      #endif\n                      ])\n\n    # Note that sometimes we have <stdbool.h>, but it doesn't work (e.g.,\n    # have both Portland and GNU installed; using pgcc will find GNU's\n    # <stdbool.h>, which all it does -- by standard -- is define \"bool\" to\n    # \"_Bool\" [see\n    # http://pmixw.opengroup.org/onlinepubs/009695399/basedefs/stdbool.h.html],\n    # and Portland has no idea what to do with _Bool).\n\n    # So first figure out if we have <stdbool.h> (i.e., check the value of\n    # the macro HAVE_STDBOOL_H from the result of AC_CHECK_HEADERS,\n    # above).  If we do have it, then check to see if it actually works.\n    # Define PMIX_USE_STDBOOL_H as approrpaite.\n    AC_CHECK_HEADERS([stdbool.h], [have_stdbool_h=1], [have_stdbool_h=0])\n    AC_MSG_CHECKING([if <stdbool.h> works])\n    if test \"$have_stdbool_h\" = \"1\"; then\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT[\n                                                   #if HAVE_STDBOOL_H\n                                                   #include <stdbool.h>\n                                                   #endif\n                                               ]],\n                                           [[bool bar, foo = true; bar = foo;]])],\n                          [PMIX_USE_STDBOOL_H=1 MSG=yes],[PMIX_USE_STDBOOL_H=0 MSG=no])\n    else\n        PMIX_USE_STDBOOL_H=0\n        MSG=\"no (don't have <stdbool.h>)\"\n    fi\n    AC_DEFINE_UNQUOTED(PMIX_USE_STDBOOL_H, $PMIX_USE_STDBOOL_H,\n                       [Whether to use <stdbool.h> or not])\n    AC_MSG_RESULT([$MSG])\n\n    # checkpoint results\n    AC_CACHE_SAVE\n\n    ##################################\n    # Types\n    ##################################\n\n    pmix_show_title \"Type tests\"\n\n    AC_CHECK_TYPES([socklen_t, struct sockaddr_in, struct sockaddr_un,\n                    struct sockaddr_in6, struct sockaddr_storage],\n                   [], [], [AC_INCLUDES_DEFAULT\n                            #if HAVE_SYS_SOCKET_H\n                            #include <sys/socket.h>\n                            #endif\n                            #if HAVE_SYS_UN_H\n                            #include <sys/un.h>\n                            #endif\n                            #ifdef HAVE_NETINET_IN_H\n                            #include <netinet/in.h>\n                            #endif\n                           ])\n\n    AC_CHECK_DECLS([AF_UNSPEC, PF_UNSPEC, AF_INET6, PF_INET6],\n                   [], [], [AC_INCLUDES_DEFAULT\n                            #if HAVE_SYS_SOCKET_H\n                            #include <sys/socket.h>\n                            #endif\n                            #ifdef HAVE_NETINET_IN_H\n                            #include <netinet/in.h>\n                            #endif\n                           ])\n\n    # SA_RESTART in signal.h\n    PMIX_VAR_SCOPE_PUSH([MSG2])\n    AC_MSG_CHECKING([if SA_RESTART defined in signal.h])\n                        AC_EGREP_CPP(yes, [\n                                            #include <signal.h>\n                                            #ifdef SA_RESTART\n                                            yes\n                                            #endif\n                                        ], [MSG2=yes VALUE=1], [MSG2=no VALUE=0])\n    AC_DEFINE_UNQUOTED(PMIX_HAVE_SA_RESTART, $VALUE,\n                       [Whether we have SA_RESTART in <signal.h> or not])\n    AC_MSG_RESULT([$MSG2])\n    PMIX_VAR_SCOPE_POP\n\n    AC_CHECK_MEMBERS([struct sockaddr.sa_len], [], [], [\n                         #include <sys/types.h>\n                         #if HAVE_SYS_SOCKET_H\n                         #include <sys/socket.h>\n                         #endif\n                     ])\n\n    AC_CHECK_MEMBERS([struct dirent.d_type], [], [], [\n                         #include <sys/types.h>\n                         #include <dirent.h>])\n\n    AC_CHECK_MEMBERS([siginfo_t.si_fd],,,[#include <signal.h>])\n    AC_CHECK_MEMBERS([siginfo_t.si_band],,,[#include <signal.h>])\n\n    #\n    # Checks for struct member names in struct statfs\n    #\n    AC_CHECK_MEMBERS([struct statfs.f_type], [], [], [\n                         AC_INCLUDES_DEFAULT\n                         #ifdef HAVE_SYS_VFS_H\n                         #include <sys/vfs.h>\n                         #endif\n                         #ifdef HAVE_SYS_STATFS_H\n                         #include <sys/statfs.h>\n                         #endif\n                     ])\n\n    AC_CHECK_MEMBERS([struct statfs.f_fstypename], [], [], [\n                         AC_INCLUDES_DEFAULT\n                         #ifdef HAVE_SYS_PARAM_H\n                         #include <sys/param.h>\n                         #endif\n                         #ifdef HAVE_SYS_MOUNT_H\n                         #include <sys/mount.h>\n                         #endif\n                         #ifdef HAVE_SYS_VFS_H\n                         #include <sys/vfs.h>\n                         #endif\n                         #ifdef HAVE_SYS_STATFS_H\n                         #include <sys/statfs.h>\n                         #endif\n                     ])\n\n    #\n    # Checks for struct member names in struct statvfs\n    #\n    AC_CHECK_MEMBERS([struct statvfs.f_basetype], [], [], [\n                         AC_INCLUDES_DEFAULT\n                         #ifdef HAVE_SYS_STATVFS_H\n                         #include <sys/statvfs.h>\n                         #endif\n                     ])\n\n    AC_CHECK_MEMBERS([struct statvfs.f_fstypename], [], [], [\n                         AC_INCLUDES_DEFAULT\n                         #ifdef HAVE_SYS_STATVFS_H\n                         #include <sys/statvfs.h>\n                         #endif\n                     ])\n\n    AC_CHECK_MEMBERS([struct ucred.uid, struct ucred.cr_uid, struct sockpeercred.uid],\n                     [], [],\n                     [#include <sys/types.h>\n                      #include <sys/socket.h> ])\n\n    #\n    # Check for ptrdiff type.  Yes, there are platforms where\n    # sizeof(void*) != sizeof(long) (64 bit Windows, apparently).\n    #\n    AC_MSG_CHECKING([for pointer diff type])\n    if test $ac_cv_type_ptrdiff_t = yes ; then\n        pmix_ptrdiff_t=\"ptrdiff_t\"\n        pmix_ptrdiff_size=$ac_cv_sizeof_ptrdiff_t\n    elif test $ac_cv_sizeof_void_p -eq $ac_cv_sizeof_long ; then\n        pmix_ptrdiff_t=\"long\"\n        pmix_ptrdiff_size=$ac_cv_sizeof_long\n    elif test $ac_cv_type_long_long = yes && test $ac_cv_sizeof_void_p -eq $ac_cv_sizeof_long_long ; then\n        pmix_ptrdiff_t=\"long long\"\n        pmix_ptrdiff_size=$ac_cv_sizeof_long_long\n        #else\n        #    AC_MSG_ERROR([Could not find datatype to emulate ptrdiff_t.  Cannot continue])\n    fi\n    AC_DEFINE_UNQUOTED([PMIX_PTRDIFF_TYPE], [$pmix_ptrdiff_t],\n                       [type to use for ptrdiff_t])\n    AC_MSG_RESULT([$pmix_ptrdiff_t (size: $pmix_ptrdiff_size)])\n\n    ##################################\n    # Linker characteristics\n    ##################################\n\n    AC_MSG_CHECKING([the linker for support for the -fini option])\n    PMIX_VAR_SCOPE_PUSH([LDFLAGS_save])\n    LDFLAGS_save=$LDFLAGS\n    LDFLAGS=\"$LDFLAGS_save -Wl,-fini -Wl,finalize\"\n    AC_TRY_LINK([void finalize (void) {}], [], [AC_MSG_RESULT([yes])\n            pmix_ld_have_fini=1], [AC_MSG_RESULT([no])\n            pmix_ld_have_fini=0])\n    LDFLAGS=$LDFLAGS_save\n    PMIX_VAR_SCOPE_POP\n\n    pmix_destructor_use_fini=0\n    pmix_no_destructor=0\n    if test x$pmix_cv___attribute__destructor = x0 ; then\n        if test x$pmix_ld_have_fini = x1 ; then\n            pmix_destructor_use_fini=1\n        else\n            pmix_no_destructor=1;\n        fi\n    fi\n\n    AC_DEFINE_UNQUOTED(PMIX_NO_LIB_DESTRUCTOR, [$pmix_no_destructor],\n        [Whether libraries can be configured with destructor functions])\n    AM_CONDITIONAL(PMIX_DESTRUCTOR_USE_FINI, [test x$pmix_destructor_use_fini = x1])\n\n    ##################################\n    # Libraries\n    ##################################\n\n    pmix_show_title \"Library and Function tests\"\n\n    # Darwin doesn't need -lutil, as it's something other than this -lutil.\n    PMIX_SEARCH_LIBS_CORE([openpty], [util])\n\n    PMIX_SEARCH_LIBS_CORE([gethostbyname], [nsl])\n\n    PMIX_SEARCH_LIBS_CORE([socket], [socket])\n\n    # IRIX and CentOS have dirname in -lgen, usually in libc\n    PMIX_SEARCH_LIBS_CORE([dirname], [gen])\n\n    # Darwin doesn't need -lm, as it's a symlink to libSystem.dylib\n    PMIX_SEARCH_LIBS_CORE([ceil], [m])\n\n    # -lrt might be needed for clock_gettime\n    PMIX_SEARCH_LIBS_CORE([clock_gettime], [rt])\n\n    AC_CHECK_FUNCS([asprintf snprintf vasprintf vsnprintf strsignal socketpair strncpy_s usleep statfs statvfs getpeereid getpeerucred strnlen posix_fallocate tcgetpgrp setpgid ptsname openpty setenv fork execve waitpid atexit])\n\n    # On some hosts, htonl is a define, so the AC_CHECK_FUNC will get\n    # confused.  On others, it's in the standard library, but stubbed with\n    # the magic glibc foo as not implemented.  and on other systems, it's\n    # just not there.  This covers all cases.\n    AC_CACHE_CHECK([for htonl define],\n                   [pmix_cv_htonl_define],\n                   [AC_PREPROC_IFELSE([AC_LANG_PROGRAM([\n                                                          #ifdef HAVE_SYS_TYPES_H\n                                                          #include <sys/types.h>\n                                                          #endif\n                                                          #ifdef HAVE_NETINET_IN_H\n                                                          #include <netinet/in.h>\n                                                          #endif\n                                                          #ifdef HAVE_ARPA_INET_H\n                                                          #include <arpa/inet.h>\n                                                          #endif],[\n                                                          #ifndef ntohl\n                                                          #error \"ntohl not defined\"\n                                                          #endif\n                                                      ])], [pmix_cv_htonl_define=yes], [pmix_cv_htonl_define=no])])\n    AC_CHECK_FUNC([htonl], [pmix_have_htonl=yes], [pmix_have_htonl=no])\n    AS_IF([test \"$pmix_cv_htonl_define\" = \"yes\" || test \"$pmix_have_htonl\" = \"yes\"],\n          [AC_DEFINE_UNQUOTED([HAVE_UNIX_BYTESWAP], [1],\n                              [whether unix byteswap routines -- htonl, htons, nothl, ntohs -- are available])])\n\n    #\n    # Make sure we can copy va_lists (need check declared, not linkable)\n    #\n\n    AC_CHECK_DECL(va_copy, PMIX_HAVE_VA_COPY=1, PMIX_HAVE_VA_COPY=0,\n                  [#include <stdarg.h>])\n    AC_DEFINE_UNQUOTED(PMIX_HAVE_VA_COPY, $PMIX_HAVE_VA_COPY,\n                       [Whether we have va_copy or not])\n\n    AC_CHECK_DECL(__va_copy, PMIX_HAVE_UNDERSCORE_VA_COPY=1,\n                  PMIX_HAVE_UNDERSCORE_VA_COPY=0, [#include <stdarg.h>])\n    AC_DEFINE_UNQUOTED(PMIX_HAVE_UNDERSCORE_VA_COPY, $PMIX_HAVE_UNDERSCORE_VA_COPY,\n                       [Whether we have __va_copy or not])\n\n    AC_CHECK_DECLS(__func__)\n\n    # checkpoint results\n    AC_CACHE_SAVE\n\n    ##################################\n    # System-specific tests\n    ##################################\n\n    pmix_show_title \"System-specific tests\"\n\n    AC_C_BIGENDIAN\n    PMIX_CHECK_BROKEN_QSORT\n\n    #\n    # Check out what thread support we have\n    #\n    PMIX_CONFIG_THREADS\n\n    CFLAGS=\"$CFLAGS $THREAD_CFLAGS\"\n    CPPFLAGS=\"$CPPFLAGS $THREAD_CPPFLAGS\"\n    LDFLAGS=\"$LDFLAGS $THREAD_LDFLAGS\"\n    LIBS=\"$LIBS $THREAD_LIBS\"\n\n    PMIX_WRAPPER_FLAGS_ADD([CFLAGS], [$THREAD_CFLAGS])\n    PMIX_WRAPPER_FLAGS_ADD([LDFLAGS], [$THREAD_LDFLAGS])\n\n    #\n    # What is the local equivalent of \"ln -s\"\n    #\n\n    AC_PROG_LN_S\n\n    # Check for some common system programs that we need\n    AC_PROG_GREP\n    AC_PROG_EGREP\n\n    ##################################\n    # Visibility\n    ##################################\n\n    # Check the visibility declspec at the end to avoid problem with\n    # the previous tests that are not necessarily prepared for\n    # the visibility feature.\n    pmix_show_title \"Symbol visibility feature\"\n\n    PMIX_CHECK_VISIBILITY\n\n    ##################################\n    # Libevent\n    ##################################\n    pmix_show_title \"Event libraries\"\n\n    PMIX_LIBEV_CONFIG\n    PMIX_LIBEVENT_CONFIG\n\n    AS_IF([test $pmix_libevent_support -eq 1 && test $pmix_libev_support -eq 1],\n      [AC_MSG_WARN([Both libevent and libev support have been specified.])\n       AC_MSG_WARN([Only one can be configured against at a time. Please])\n       AC_MSG_WARN([remove one from the configure command line.])\n       AC_MSG_ERROR([Cannot continue])])\n\n    AS_IF([test $pmix_libevent_support -eq 0 && test $pmix_libev_support -eq 0],\n          [AC_MSG_WARN([Either libevent or libev support is required, but neither])\n           AC_MSG_WARN([was found. Please use the configure options to point us])\n           AC_MSG_WARN([to where we can find one or the other library])\n           AC_MSG_ERROR([Cannot continue])])\n\n\n    ##################################\n    # JANSSON\n    ##################################\n    pmix_show_title \"JANSSON\"\n\n    PMIX_CHECK_JANSSON\n\n\n    ##################################\n    # CURL\n    ##################################\n    pmix_show_title \"CURL\"\n\n    PMIX_CHECK_CURL\n\n    ##################################\n    # OFI\n    ##################################\n    pmix_show_title \"OFI\"\n\n    PMIX_CHECK_OFI\n\n    ##################################\n    # Dstore Locking\n    ##################################\n\n    pmix_show_title \"Dstore Locking\"\n\n    PMIX_CHECK_DSTOR_LOCK\n\n\n    ##################################\n    # MCA\n    ##################################\n\n    pmix_show_title \"Modular Component Architecture (MCA) setup\"\n\n    #\n    # Do we want to show component load error messages by default?\n    #\n\n    AC_MSG_CHECKING([for default value of mca_base_component_show_load_errors])\n    AC_ARG_ENABLE([show-load-errors-by-default],\n                  [AC_HELP_STRING([--enable-show-load-errors-by-default],\n                                  [Set the default value for the MCA parameter\n                                   mca_base_component_show_load_errors (but can be\n                                   overridden at run time by the usual\n                                   MCA-variable-setting mechansism).  This MCA variable\n                                   controls whether warnings are displayed when an MCA\n                                   component fails to load at run time due to an error.\n                                   (default: enabled in --enable-debug builds, meaning that\n                                   mca_base_component_show_load_errors is enabled\n                                   by default when configured with --enable-debug])])\n    if test \"$enable_show_load_errors_by_default\" = \"no\" ; then\n        PMIX_SHOW_LOAD_ERRORS_DEFAULT=0\n        AC_MSG_RESULT([disabled by default])\n    else\n        PMIX_SHOW_LOAD_ERRORS_DEFAULT=$WANT_DEBUG\n        if test \"$WANT_DEBUG\" = \"1\"; then\n            AC_MSG_RESULT([enabled by default])\n        else\n            AC_MSG_RESULT([disabled by default])\n        fi\n    fi\n    AC_DEFINE_UNQUOTED(PMIX_SHOW_LOAD_ERRORS_DEFAULT, $PMIX_SHOW_LOAD_ERRORS_DEFAULT,\n                       [Default value for mca_base_component_show_load_errors MCA variable])\n\n    AC_MSG_CHECKING([for subdir args])\n    PMIX_CONFIG_SUBDIR_ARGS([pmix_subdir_args])\n    AC_MSG_RESULT([$pmix_subdir_args])\n\n    PMIX_MCA\n\n\n    ############################################################################\n    # final compiler config\n    ############################################################################\n\n    pmix_show_subtitle \"Set path-related compiler flags\"\n\n    #\n    # This is needed for VPATH builds, so that it will -I the appropriate\n    # include directory.  We delayed doing it until now just so that\n    # '-I$(top_srcdir)' doesn't show up in any of the configure output --\n    # purely aesthetic.\n    #\n    # Because pmix_config.h is created by AC_CONFIG_HEADERS, we\n    # don't need to -I the builddir for pmix/include. However, if we\n    # are VPATH building, we do need to include the source directories.\n    #\n    if test \"$PMIX_top_builddir\" != \"$PMIX_top_srcdir\"; then\n        # Note the embedded m4 directives here -- we must embed them\n        # rather than have successive assignments to these shell\n        # variables, lest the $(foo) names try to get evaluated here.\n        # Yuck!\n        cpp_includes=\"$PMIX_top_builddir $PMIX_top_srcdir $PMIX_top_srcdir/src $PMIX_top_builddir/include\"\n    else\n        cpp_includes=\"$PMIX_top_srcdir $PMIX_top_srcdir/src\"\n    fi\n    CPP_INCLUDES=\"$(echo $cpp_includes | $SED 's/[[^ \\]]* */'\"$pmix_cc_iquote\"'&/g')\"\n    CPPFLAGS=\"$CPP_INCLUDES -I$PMIX_top_srcdir/include $CPPFLAGS $PMIX_FINAL_CPPFLAGS\"\n    LDFLAGS=\"$LDFLAGS $PMIX_FINAL_LDFLAGS\"\n    LIBS=\"$LIBS $PMIX_FINAL_LIBS\"\n\n    ############################################################################\n    # final wrapper compiler config\n    ############################################################################\n    pmix_show_subtitle \"Wrapper compiler final setup\"\n\n    # The PMIx wrapper script (i.e., not the C-compiled\n    # executables) need perl.\n    AC_PATH_PROG(PERL, perl, perl)\n\n    # Need the libtool executable before the rpathify stuff\n    LT_OUTPUT\n\n    PMIX_SETUP_WRAPPER_FINAL\n\n    ############################################################################\n    # pmixdatadir, pmixlibdir, and pmixinclude are essentially the same as\n    # pkg*dir, but will always be */pmix.\n    pmixdatadir='${datadir}/pmix'\n    pmixlibdir='${libdir}/pmix'\n    pmixincludedir='${includedir}/pmix'\n    AC_SUBST(pmixdatadir)\n    AC_SUBST(pmixlibdir)\n    AC_SUBST(pmixincludedir)\n\n    ############################################################################\n    # setup \"make check\"\n    ############################################################################\n    PMIX_BUILT_TEST_PREFIX=$PMIX_top_builddir\n    AC_SUBST(PMIX_BUILT_TEST_PREFIX)\n    # expose the mca component library paths in the build system\n    pathfile=$PMIX_top_srcdir/config/mca_library_paths.txt\n    PMIX_COMPONENT_LIBRARY_PATHS=`cat $pathfile`\n    AC_SUBST(PMIX_COMPONENT_LIBRARY_PATHS)\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests00.pl], [chmod +x test/run_tests00.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests01.pl], [chmod +x test/run_tests01.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests02.pl], [chmod +x test/run_tests02.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests03.pl], [chmod +x test/run_tests03.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests04.pl], [chmod +x test/run_tests04.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests05.pl], [chmod +x test/run_tests05.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests06.pl], [chmod +x test/run_tests06.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests07.pl], [chmod +x test/run_tests07.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests08.pl], [chmod +x test/run_tests08.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests09.pl], [chmod +x test/run_tests09.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests10.pl], [chmod +x test/run_tests10.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests11.pl], [chmod +x test/run_tests11.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests12.pl], [chmod +x test/run_tests12.pl])\n    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests13.pl], [chmod +x test/run_tests13.pl])\n#    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests14.pl], [chmod +x test/run_tests14.pl])\n#    AC_CONFIG_FILES(pmix_config_prefix[test/run_tests15.pl], [chmod +x test/run_tests15.pl])\n    if test \"$WANT_PYTHON_BINDINGS\" = \"1\"; then\n        AC_CONFIG_FILES(pmix_config_prefix[test/python/run_server.sh], [chmod +x test/python/run_server.sh])\n        AC_CONFIG_FILES(pmix_config_prefix[test/python/run_sched.sh], [chmod +x test/python/run_sched.sh])\n    fi\n\n\n    ############################################################################\n    # Check for building man pages\n    ############################################################################\n    pmix_show_subtitle \"Man page setup\"\n    PMIX_SETUP_MAN_PAGES\n\n    ############################################################################\n    # final output\n    ############################################################################\n\n    pmix_show_subtitle \"Final output\"\n\n    AC_CONFIG_HEADERS(pmix_config_prefix[include/pmix_common.h])\n\n    AC_CONFIG_FILES(\n        pmix_config_prefix[Makefile]\n        pmix_config_prefix[bindings/Makefile]\n        pmix_config_prefix[bindings/python/Makefile]\n        pmix_config_prefix[config/Makefile]\n        pmix_config_prefix[etc/Makefile]\n        pmix_config_prefix[include/Makefile]\n        pmix_config_prefix[src/Makefile]\n        pmix_config_prefix[src/include/Makefile]\n        pmix_config_prefix[src/util/keyval/Makefile]\n        pmix_config_prefix[src/mca/base/Makefile]\n        pmix_config_prefix[src/tools/pevent/Makefile]\n        pmix_config_prefix[src/tools/pmix_info/Makefile]\n        pmix_config_prefix[src/tools/plookup/Makefile]\n        pmix_config_prefix[src/tools/pps/Makefile]\n        pmix_config_prefix[src/tools/pattrs/Makefile]\n        pmix_config_prefix[src/tools/pquery/Makefile]\n        pmix_config_prefix[src/tools/wrapper/Makefile]\n        pmix_config_prefix[src/tools/wrapper/pmixcc-wrapper-data.txt]\n        )\n\n    # publish any embedded flags so external wrappers can use them\n    AC_SUBST(PMIX_EMBEDDED_LIBS)\n    AC_SUBST(PMIX_EMBEDDED_LDFLAGS)\n    AC_SUBST(PMIX_EMBEDDED_CPPFLAGS)\n\n    # Success\n    $2\n])dnl\n\nAC_DEFUN([PMIX_DEFINE_ARGS],[\n    # do we want dlopen support ?\n    AC_MSG_CHECKING([if want dlopen support])\n    AC_ARG_ENABLE([dlopen],\n        [AC_HELP_STRING([--enable-dlopen],\n                        [Whether build should attempt to use dlopen (or\n                         similar) to dynamically load components.\n                         (default: enabled)])])\n    AS_IF([test \"$enable_dlopen\" = \"unknown\"],\n          [AC_MSG_WARN([enable_dlopen variable has been overwritten by configure])\n           AC_MSG_WARN([This is an internal error that should be reported to PMIx developers])\n           AC_MSG_ERROR([Cannot continue])])\n    AS_IF([test \"$enable_dlopen\" = \"no\"],\n          [enable_mca_dso=\"no\"\n           enable_mca_static=\"yes\"\n           PMIX_ENABLE_DLOPEN_SUPPORT=0\n           AC_MSG_RESULT([no])],\n          [PMIX_ENABLE_DLOPEN_SUPPORT=1\n           AC_MSG_RESULT([yes])])\n    AC_DEFINE_UNQUOTED(PMIX_ENABLE_DLOPEN_SUPPORT, $PMIX_ENABLE_DLOPEN_SUPPORT,\n                      [Whether we want to enable dlopen support])\n\n    # Embedded mode, or standalone?\n    AC_MSG_CHECKING([if embedded mode is enabled])\n    AC_ARG_ENABLE([embedded-mode],\n        [AC_HELP_STRING([--enable-embedded-mode],\n                [Using --enable-embedded-mode causes PMIx to skip a few configure checks and install nothing.  It should only be used when building PMIx within the scope of a larger package.])])\n    AS_IF([test \"$enable_embedded_mode\" = \"yes\"],\n          [pmix_mode=embedded\n           pmix_install_primary_headers=no\n           AC_MSG_RESULT([yes])],\n          [pmix_mode=standalone\n           pmix_install_primary_headers=yes\n           AC_MSG_RESULT([no])])\n\n#\n# Is this a developer copy?\n#\n\nif test -e $PMIX_TOP_SRCDIR/.git; then\n    PMIX_DEVEL=1\n    # check for Flex\n    AC_PROG_LEX\n    if test \"x$LEX\" != xflex; then\n        AC_MSG_WARN([PMIx requires Flex to build from non-tarball sources,])\n        AC_MSG_WARN([but Flex was not found. Please install Flex into])\n        AC_MSG_WARN([your path and try again])\n        AC_MSG_ERROR([Cannot continue])\n    fi\nelse\n    PMIX_DEVEL=0\nfi\n\n\n#\n# Developer picky compiler options\n#\n\nAC_MSG_CHECKING([if want developer-level compiler pickyness])\nAC_ARG_ENABLE(picky,\n    AC_HELP_STRING([--enable-picky],\n                   [enable developer-level compiler pickyness when building PMIx (default: disabled)]))\nif test \"$enable_picky\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_PICKY_COMPILER=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_PICKY_COMPILER=0\nfi\n#################### Early development override ####################\nif test \"$WANT_PICKY_COMPILER\" = \"0\" && test -z \"$enable_picky\" && test \"$PMIX_DEVEL\" = \"1\"; then\n    WANT_PICKY_COMPILER=1\n    echo \"--> developer override: enable picky compiler by default\"\nfi\n#################### Early development override ####################\n\n#\n# Developer debugging\n#\n\nAC_MSG_CHECKING([if want developer-level debugging code])\nAC_ARG_ENABLE(debug,\n    AC_HELP_STRING([--enable-debug],\n                   [enable developer-level debugging code (not for general PMIx users!) (default: disabled)]))\nif test \"$enable_debug\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_DEBUG=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_DEBUG=0\nfi\n\nif test \"$WANT_DEBUG\" = \"0\"; then\n    CFLAGS=\"-DNDEBUG $CFLAGS\"\nfi\n\nAC_DEFINE_UNQUOTED(PMIX_ENABLE_DEBUG, $WANT_DEBUG,\n                   [Whether we want developer-level debugging code or not])\n\nAC_ARG_ENABLE(debug-symbols,\n              AC_HELP_STRING([--disable-debug-symbols],\n                             [Disable adding compiler flags to enable debugging symbols if --enable-debug is specified.  For non-debugging builds, this flag has no effect.]))\n\n#\n# Do we want to install the internal devel headers?\n#\nAC_MSG_CHECKING([if want to install project-internal header files])\nAC_ARG_WITH(devel-headers,\n    AC_HELP_STRING([--with-devel-headers],\n                   [normal PMIx users/applications do not need this (pmix.h and friends are ALWAYS installed).  Developer headers are only necessary for authors doing deeper integration (default: disabled).]))\nif test \"$with_devel_headers\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_INSTALL_HEADERS=1\n    pmix_install_primary_headers=yes\nelse\n    AC_MSG_RESULT([no])\n    WANT_INSTALL_HEADERS=0\nfi\n\n# Install tests and examples?\nAC_MSG_CHECKING([if tests and examples are to be installed])\nAC_ARG_WITH([tests-examples],\n    [AC_HELP_STRING([--with-tests-examples],\n            [Whether or not to install the tests and example programs.])])\nAS_IF([test \"$pmix_install_primary_headers\" = \"no\"],\n      [AS_IF([test -z \"$with_tests_examples\" || test \"$with_tests_examples\" = \"no\"],\n             [pmix_tests=no\n              AC_MSG_RESULT([no])],\n             [AC_MSG_RESULT([no])\n              AC_MSG_WARN([Cannot install tests/examples without installing primary headers.])\n              AC_MSG_WARN([This situation arises when configured in embedded mode])\n              AC_MSG_WARN([and without devel headers.])\n              AC_MSG_ERROR([Please correct the configure line and retry])])],\n      [AS_IF([test ! -z \"$with_tests_examples\" && test \"$with_tests_examples\" = \"no\"],\n             [pmix_tests=no\n              AC_MSG_RESULT([no])],\n             [pmix_tests=yes\n              AC_MSG_RESULT([yes])])])\n\n#\n# Support per-user config files?\n#\nAC_ARG_ENABLE([per-user-config-files],\n   [AC_HELP_STRING([--enable-per-user-config-files],\n      [Disable per-user configuration files, to save disk accesses during job start-up.  This is likely desirable for large jobs.  Note that this can also be acheived by environment variables at run-time.  (default: enabled)])])\nif test \"$enable_per_user_config_files\" = \"no\" ; then\n  result=0\nelse\n  result=1\nfi\nAC_DEFINE_UNQUOTED([PMIX_WANT_HOME_CONFIG_FILES], [$result],\n     [Enable per-user config files])\n\n#\n# Do we want the pretty-print stack trace feature?\n#\n\nAC_MSG_CHECKING([if want pretty-print stacktrace])\nAC_ARG_ENABLE([pretty-print-stacktrace],\n              [AC_HELP_STRING([--enable-pretty-print-stacktrace],\n                              [Pretty print stacktrace on process signal (default: enabled)])])\nif test \"$enable_pretty_print_stacktrace\" = \"no\" ; then\n    AC_MSG_RESULT([no])\n    WANT_PRETTY_PRINT_STACKTRACE=0\nelse\n    AC_MSG_RESULT([yes])\n    WANT_PRETTY_PRINT_STACKTRACE=1\nfi\nAC_DEFINE_UNQUOTED([PMIX_WANT_PRETTY_PRINT_STACKTRACE],\n                   [$WANT_PRETTY_PRINT_STACKTRACE],\n                   [if want pretty-print stack trace feature])\n\n#\n# Use pthread-based locking\n#\nDSTORE_PTHREAD_LOCK=\"1\"\nAC_MSG_CHECKING([if want dstore pthread-based locking])\nAC_ARG_ENABLE([dstore-pthlck],\n              [AC_HELP_STRING([--disable-dstore-pthlck],\n                              [Disable pthread-based locking in dstor (default: enabled)])])\nif test \"$enable_dstore_pthlck\" = \"no\" ; then\n    AC_MSG_RESULT([no])\n    DSTORE_PTHREAD_LOCK=\"0\"\nelse\n    AC_MSG_RESULT([yes])\n    DSTORE_PTHREAD_LOCK=\"1\"\nfi\n\n#\n# Ident string\n#\nAC_MSG_CHECKING([if want ident string])\nAC_ARG_WITH([ident-string],\n            [AC_HELP_STRING([--with-ident-string=STRING],\n                            [Embed an ident string into PMIx object files])])\nif test \"$with_ident_string\" = \"\" || test \"$with_ident_string\" = \"no\"; then\n    with_ident_string=\"%VERSION%\"\nfi\n# This is complicated, because $PMIX_VERSION may have spaces in it.\n# So put the whole sed expr in single quotes -- i.e., directly\n# substitute %VERSION% for (not expanded) $PMIX_VERSION.\nwith_ident_string=\"`echo $with_ident_string | sed -e 's/%VERSION%/$PMIX_VERSION/'`\"\n\n# Now eval an echo of that so that the \"$PMIX_VERSION\" token is\n# replaced with its value.  Enclose the whole thing in \"\" so that it\n# ends up as 1 token.\nwith_ident_string=\"`eval echo $with_ident_string`\"\n\nAC_DEFINE_UNQUOTED([PMIX_IDENT_STRING], [\"$with_ident_string\"],\n                   [ident string for PMIX])\nAC_MSG_RESULT([$with_ident_string])\n\n#\n# Timing support\n#\nAC_MSG_CHECKING([if want developer-level timing support])\nAC_ARG_ENABLE(pmix-timing,\n              AC_HELP_STRING([--enable-pmix-timing],\n                             [enable PMIx developer-level timing code (default: disabled)]))\nif test \"$enable_pmix_timing\" = \"yes\"; then\n    AC_MSG_RESULT([yes])\n    WANT_PMIX_TIMING=1\nelse\n    AC_MSG_RESULT([no])\n    WANT_PMIX_TIMING=0\nfi\n\nAC_DEFINE_UNQUOTED([PMIX_ENABLE_TIMING], [$WANT_PMIX_TIMING],\n                   [Whether we want developer-level timing support or not])\n\nAM_CONDITIONAL([WANT_INSTALL_HEADERS], [test $WANT_INSTALL_HEADERS -eq 1])\n\n#\n# Do we want to install binaries?\n#\nAC_MSG_CHECKING([if want to disable binaries])\nAC_ARG_ENABLE(pmix-binaries,\n              AC_HELP_STRING([--enable-pmix-binaries],\n                             [enable PMIx tools]))\nif test \"$enable_pmix_binaries\" = \"no\"; then\n    AC_MSG_RESULT([no])\n    WANT_PMIX_BINARIES=0\nelse\n    AC_MSG_RESULT([yes])\n    WANT_PMIX_BINARIES=1\nfi\n\nAM_CONDITIONAL([PMIX_INSTALL_BINARIES], [test $WANT_PMIX_BINARIES -eq 1])\n\n#\n# Install Python bindings?\n#\nAC_MSG_CHECKING([if want install Python bindings])\nAC_ARG_ENABLE(python-bindings,\n              AC_HELP_STRING([--enable-python-bindings],\n                             [enable Python bindings (default: disabled)]))\nif test \"$enable_python_bindings\" != \"yes\"; then\n    AC_MSG_RESULT([no])\n    WANT_PYTHON_BINDINGS=0\nelse\n    AC_MSG_RESULT([yes])\n    WANT_PYTHON_BINDINGS=1\nfi\n\nAM_CONDITIONAL([WANT_PYTHON_BINDINGS], [test $WANT_PYTHON_BINDINGS -eq 1])\n\nAM_PATH_PYTHON([3.4], [pmix_python_good=yes], [pmix_python_good=no])\n\nif test \"$WANT_PYTHON_BINDINGS\" = \"1\"; then\n    if test \"$pmix_python_good\" = \"no\"; then\n        AC_MSG_WARN([Python bindings were enabled, but no suitable])\n        AC_MSG_WARN([interpreter was found. PMIx requires at least])\n        AC_MSG_WARN([Python v3.4 to provide Python bindings])\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    pyvers=`python3 --version`\n    python_version=${pyvers#\"Python \"}\n\n    PMIX_SUMMARY_ADD([[Bindings]],[[Python]], [pmix_python], [yes ($python_version)])\n\n    AC_MSG_CHECKING([if Cython package installed as Python package])\n    have_cython=`$srcdir/config/pmix_check_cython.py 2> /dev/null`\n    if test \"$have_cython\" = \"0\"; then\n        AC_MSG_RESULT([yes])\n        AC_MSG_CHECKING([Cython version])\n        cython_version=`python -c \"from Cython.Compiler.Version import version; print(version)\"`\n        AC_MSG_RESULT([$cython_version])\n        PMIX_SUMMARY_ADD([[Bindings]],[[Cython]], [pmix_cython], [yes ($cython_version)])\n    else\n        AC_MSG_RESULT([no])\n        # Cython doesn't have any include or lib files - it is just a binary\n        AC_CHECK_PROG(pmix_cython_rpm, cython, [cython])\n        if test \"$pmix_cython_rpm\" != \"\"; then\n            AC_MSG_CHECKING([Cython version])\n            cyvers=`cython --version 2>&1`\n            cython_version=${cyvers#\"Cython version \"}\n            AC_MSG_RESULT([$cython_version])\n            PMIX_SUMMARY_ADD([[Bindings]],[[Cython]], [pmix_cython], [yes ($cython_version)])\n        else\n            AC_MSG_WARN([Python bindings were enabled, but the Cython])\n            AC_MSG_WARN([package was not found. PMIx Python bindings])\n            AC_MSG_WARN([require that the Cython package be installed])\n            AC_MSG_ERROR([Cannot continue])\n        fi\n    fi\n\n    pmix_pythondir=`eval echo $pythondir`\n    AC_SUBST([PMIX_PYTHON_EGG_PATH], [$pmix_pythondir], [Path to installed Python egg])\nfi\n\n# If we didn't find a good Python and we don't have dictionary.h, then\n# see if we can find an older Python (because construct_dictionary.py\n# can use an older Python).\nAS_IF([test \"$PYTHON\" = \":\" && test ! -f $srcdir/include/dictionary.h],\n      [PYTHON=\n       AM_PATH_PYTHON\n       # If we still can't find Python (and we don't have\n       # dictionary.h), then give up.\n       AS_IF([test \"$PYTHON\" = \":\"],\n             [AC_MSG_WARN([Could not find a modern enough Python])\n              AC_MSG_WARN([Developer builds (e.g., git clones) of OpenPMIx must have Python available])\n              AC_MSG_ERROR([Cannot continue])\n             ])\n       ])\n\n# see if they want to disable non-RTLD_GLOBAL dlopen\nAC_MSG_CHECKING([if want to support dlopen of non-global namespaces])\nAC_ARG_ENABLE([nonglobal-dlopen],\n              AC_HELP_STRING([--enable-nonglobal-dlopen],\n                             [enable non-global dlopen (default: enabled)]))\nif test \"$enable_nonglobal_dlopen\" = \"no\"; then\n    AC_MSG_RESULT([no])\n    pmix_need_libpmix=0\nelse\n    AC_MSG_RESULT([yes])\n    pmix_need_libpmix=1\nfi\n\n# if someone enables embedded mode but doesn't want to install the\n# devel headers, then default nonglobal-dlopen to false\nAS_IF([test -z \"$enable_nonglobal_dlopen\" && test \"x$pmix_mode\" = \"xembedded\" && test $WANT_INSTALL_HEADERS -eq 0 && test $pmix_need_libpmix -eq 1],\n      [pmix_need_libpmix=0])\n\n#\n# Do we want PTY support?\n#\n\nAC_MSG_CHECKING([if want pty support])\nAC_ARG_ENABLE(pty-support,\n    AC_HELP_STRING([--enable-pty-support],\n                   [Enable/disable PTY support for STDIO forwarding.  (default: enabled)]))\nif test \"$enable_pty_support\" = \"no\" ; then\n    AC_MSG_RESULT([no])\n    PMIX_ENABLE_PTY_SUPPORT=0\nelse\n    AC_MSG_RESULT([yes])\n    PMIX_ENABLE_PTY_SUPPORT=1\nfi\nAC_DEFINE_UNQUOTED([PMIX_ENABLE_PTY_SUPPORT], [$PMIX_ENABLE_PTY_SUPPORT],\n                   [Whether user wants PTY support or not])\n\n#\n# psec/dummy_handshake\n#\n\nAC_MSG_CHECKING([if want build psec/dummy_handshake])\nAC_ARG_ENABLE(dummy-handshake,\n              AC_HELP_STRING([--enable-dummy-handshake],\n                             [Enables psec dummy component intended to check the PTL handshake scenario (default: disabled)]))\nif test \"$enable_dummy_handshake\" != \"yes\"; then\n    AC_MSG_RESULT([no])\n    eval \"DISABLE_psec_dummy_handshake=1\"\nelse\n    AC_MSG_RESULT([yes])\n    eval \"DISABLE_psec_dummy_handshake=0\"\nfi\nAM_CONDITIONAL(MCA_BUILD_PSEC_DUMMY_HANDSHAKE, test \"$DISABLE_psec_dummy_handshake\" = \"0\")\n])dnl\n\n# This must be a standalone routine so that it can be called both by\n# PMIX_INIT and an external caller (if PMIX_INIT is not invoked).\nAC_DEFUN([PMIX_DO_AM_CONDITIONALS],[\n    AS_IF([test \"$pmix_did_am_conditionals\" != \"yes\"],[\n        AM_CONDITIONAL([PMIX_EMBEDDED_MODE], [test \"x$pmix_mode\" = \"xembedded\"])\n        AM_CONDITIONAL([PMIX_TESTS_EXAMPLES], [test \"x$pmix_tests\" = \"xyes\"])\n        AM_CONDITIONAL([PMIX_COMPILE_TIMING], [test \"$WANT_TIMING\" = \"1\"])\n        AM_CONDITIONAL([PMIX_WANT_MUNGE], [test \"$pmix_munge_support\" = \"1\"])\n        AM_CONDITIONAL([PMIX_WANT_SASL], [test \"$pmix_sasl_support\" = \"1\"])\n        AM_CONDITIONAL([WANT_DSTORE], [test \"x$enable_dstore\" != \"xno\"])\n        AM_CONDITIONAL([WANT_PRIMARY_HEADERS], [test \"x$pmix_install_primary_headers\" = \"xyes\"])\n        AM_CONDITIONAL(WANT_INSTALL_HEADERS, test \"$WANT_INSTALL_HEADERS\" = 1)\n        AM_CONDITIONAL(WANT_PMI_BACKWARD, test \"$WANT_PMI_BACKWARD\" = 1)\n        AM_CONDITIONAL(NEED_LIBPMIX, [test \"$pmix_need_libpmix\" = \"1\"])\n        AM_CONDITIONAL([PMIX_HAVE_JANSSON], [test \"x$pmix_check_jansson_happy\" = \"xyes\"])\n        AM_CONDITIONAL([PMIX_HAVE_CURL], [test \"x$pmix_check_curl_happy\" = \"xyes\"])\n    ])\n    pmix_did_am_conditionals=yes\n])dnl\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/base/base.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2008 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2007 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2009      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2013-2015 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#ifndef PMIX_MCA_BASE_H\n#define PMIX_MCA_BASE_H\n\n#include \"src/include/pmix_config.h\"\n\n#include \"src/class/pmix_object.h\"\n#include \"src/class/pmix_list.h\"\n\n/*\n * These units are large enough to warrant their own .h files\n */\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/pmix_mca_base_var.h\"\n#include \"src/mca/base/pmix_mca_base_framework.h\"\n#include \"src/util/cmd_line.h\"\n#include \"src/util/output.h\"\n\nBEGIN_C_DECLS\n\n/*\n * Structure for making plain lists of components\n */\nstruct pmix_mca_base_component_list_item_t {\n    pmix_list_item_t super;\n    const pmix_mca_base_component_t *cli_component;\n};\ntypedef struct pmix_mca_base_component_list_item_t pmix_mca_base_component_list_item_t;\nPMIX_EXPORT PMIX_CLASS_DECLARATION(pmix_mca_base_component_list_item_t);\n\n/*\n * Structure for making priority lists of components\n */\nstruct pmix_mca_base_component_priority_list_item_t {\n    pmix_mca_base_component_list_item_t super;\n    int cpli_priority;\n};\ntypedef struct pmix_mca_base_component_priority_list_item_t\n    pmix_mca_base_component_priority_list_item_t;\n\nPMIX_EXPORT PMIX_CLASS_DECLARATION(pmix_mca_base_component_priority_list_item_t);\n\n/*\n * Public variables\n */\nPMIX_EXPORT extern char *pmix_mca_base_component_path;\nPMIX_EXPORT extern bool pmix_mca_base_component_show_load_errors;\nPMIX_EXPORT extern bool pmix_mca_base_component_track_load_errors;\nPMIX_EXPORT extern bool pmix_mca_base_component_disable_dlopen;\nPMIX_EXPORT extern char *pmix_mca_base_system_default_path;\nPMIX_EXPORT extern char *pmix_mca_base_user_default_path;\n\n/*\n * Standard verbosity levels\n */\nenum {\n    /** total silence */\n    PMIX_MCA_BASE_VERBOSE_NONE  = -1,\n    /** only errors are printed */\n    PMIX_MCA_BASE_VERBOSE_ERROR = 0,\n    /** emit messages about component selection, open, and unloading */\n    PMIX_MCA_BASE_VERBOSE_COMPONENT = 10,\n    /** also emit warnings */\n    PMIX_MCA_BASE_VERBOSE_WARN  = 20,\n    /** also emit general, user-relevant information, such as rationale as to why certain choices\n     * or code paths were taken, information gleaned from probing the local system, etc. */\n    PMIX_MCA_BASE_VERBOSE_INFO  = 40,\n    /** also emit relevant tracing information (e.g., which functions were invoked /\n     * call stack entry/exit info) */\n    PMIX_MCA_BASE_VERBOSE_TRACE = 60,\n    /** also emit PMIX-developer-level (i.e,. highly detailed) information */\n    PMIX_MCA_BASE_VERBOSE_DEBUG = 80,\n    /** also output anything else that might be useful */\n    PMIX_MCA_BASE_VERBOSE_MAX   = 100,\n};\n\n/*\n * Public functions\n */\n\n/**\n * First function called in the MCA.\n *\n * @return PMIX_SUCCESS Upon success\n * @return PMIX_ERROR Upon failure\n *\n * This function starts up the entire MCA.  It initializes a bunch\n * of built-in MCA parameters, and initialized the MCA component\n * repository.\n *\n * It must be the first MCA function invoked.  It is normally\n * invoked during the initialization stage and specifically\n * invoked in the special case of the *_info command.\n */\nPMIX_EXPORT int pmix_mca_base_open(void);\n\n/**\n * Last function called in the MCA\n *\n * @return PMIX_SUCCESS Upon success\n * @return PMIX_ERROR Upon failure\n *\n * This function closes down the entire MCA.  It clears all MCA\n * parameters and closes down the MCA component respository.\n *\n * It must be the last MCA function invoked.  It is normally invoked\n * during the finalize stage.\n */\nPMIX_EXPORT int pmix_mca_base_close(void);\n\n/**\n * A generic select function\n *\n */\nPMIX_EXPORT int pmix_mca_base_select(const char *type_name, int output_id,\n                                     pmix_list_t *components_available,\n                                     pmix_mca_base_module_t **best_module,\n                                     pmix_mca_base_component_t **best_component,\n                                     int *priority_out);\n\n/**\n * A function for component query functions to discover if they have\n * been explicitly required to or requested to be selected.\n *\n * exclusive: If the specified component is the only component that is\n *            available for selection.\n *\n */\nPMIX_EXPORT int pmix_mca_base_is_component_required(pmix_list_t *components_available,\n                                                    pmix_mca_base_component_t *component,\n                                                    bool exclusive,\n                                                    bool *is_required);\n\n/* mca_base_cmd_line.c */\n\nPMIX_EXPORT int pmix_mca_base_cmd_line_setup(pmix_cmd_line_t *cmd);\nPMIX_EXPORT int pmix_mca_base_cmd_line_process_args(pmix_cmd_line_t *cmd,\n                                                 char ***app_env,\n                                                 char ***global_env);\nPMIX_EXPORT void pmix_mca_base_cmd_line_wrap_args(char **args);\n\n/* pmix_mca_base_component_compare.c */\n\nPMIX_EXPORT int pmix_mca_base_component_compare_priority(pmix_mca_base_component_priority_list_item_t *a,\n                                                         pmix_mca_base_component_priority_list_item_t *b);\nPMIX_EXPORT int pmix_mca_base_component_compare(const pmix_mca_base_component_t *a,\n                                                const pmix_mca_base_component_t *b);\nPMIX_EXPORT int pmix_mca_base_component_compatible(const pmix_mca_base_component_t *a,\n                                                   const pmix_mca_base_component_t *b);\nPMIX_EXPORT char * pmix_mca_base_component_to_string(const pmix_mca_base_component_t *a);\n\n/* pmix_mca_base_component_find.c */\n\nPMIX_EXPORT int pmix_mca_base_component_find (const char *directory, pmix_mca_base_framework_t *framework,\n                                              bool ignore_requested, bool open_dso_components);\n\n/**\n * Parse the requested component string and return an pmix_argv of the requested\n * (or not requested) components.\n */\nPMIX_EXPORT int pmix_mca_base_component_parse_requested (const char *requested, bool *include_mode,\n                                                         char ***requested_component_names);\n\n/**\n * Filter a list of components based on a comma-delimted list of names and/or\n * a set of meta-data flags.\n *\n * @param[in,out] components List of components to filter\n * @param[in] output_id Output id to write to for error/warning/debug messages\n * @param[in] filter_names Comma delimited list of components to use. Negate with ^.\n * May be NULL.\n * @param[in] filter_flags Metadata flags components are required to have set (CR ready)\n *\n * @returns PMIX_SUCCESS On success\n * @returns PMIX_ERR_NOT_FOUND If some component in {filter_names} is not found in\n * {components}. Does not apply to negated filters.\n * @returns pmix error code On other error.\n *\n * This function closes and releases any components that do not match the filter_name and\n * filter flags.\n */\nPMIX_EXPORT int pmix_mca_base_components_filter (pmix_mca_base_framework_t *framework, uint32_t filter_flags);\n\n\n\n/* Safely release some memory allocated by pmix_mca_base_component_find()\n   (i.e., is safe to call even if you never called\n   pmix_mca_base_component_find()). */\nPMIX_EXPORT int pmix_mca_base_component_find_finalize(void);\n\n/* pmix_mca_base_components_register.c */\nPMIX_EXPORT int pmix_mca_base_framework_components_register (struct pmix_mca_base_framework_t *framework,\n                                                             pmix_mca_base_register_flag_t flags);\n\n/* pmix_mca_base_components_open.c */\nPMIX_EXPORT int pmix_mca_base_framework_components_open (struct pmix_mca_base_framework_t *framework,\n                                                         pmix_mca_base_open_flag_t flags);\n\nPMIX_EXPORT int pmix_mca_base_components_open(const char *type_name, int output_id,\n                                              const pmix_mca_base_component_t **static_components,\n                                              pmix_list_t *components_available,\n                                              bool open_dso_components);\n\n/* pmix_mca_base_components_close.c */\n/**\n * Close and release a component.\n *\n * @param[in] component Component to close\n * @param[in] output_id Output id for debugging output\n *\n * After calling this function the component may no longer be used.\n */\nPMIX_EXPORT void pmix_mca_base_component_close (const pmix_mca_base_component_t *component, int output_id);\n\n/**\n * Release a component without closing it.\n * @param[in] component Component to close\n * @param[in] output_id Output id for debugging output\n *\n * After calling this function the component may no longer be used.\n */\nPMIX_EXPORT void pmix_mca_base_component_unload (const pmix_mca_base_component_t *component, int output_id);\n\nPMIX_EXPORT int pmix_mca_base_components_close(int output_id, pmix_list_t *components_available,\n                                               const pmix_mca_base_component_t *skip);\n\nPMIX_EXPORT int pmix_mca_base_framework_components_close (struct pmix_mca_base_framework_t *framework,\n                                                          const pmix_mca_base_component_t *skip);\n\nEND_C_DECLS\n\n#endif /* MCA_BASE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/base/pmix_mca_base_component_repository.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2005 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2008-2019 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2021      Nanook Consulting.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n\n#include \"src/include/pmix_config.h\"\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"src/class/pmix_list.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/pmix_mca_base_component_repository.h\"\n#include \"src/mca/pdl/base/base.h\"\n#include \"include/pmix_common.h\"\n#include \"src/class/pmix_hash_table.h\"\n#include \"src/util/basename.h\"\n#include \"src/util/show_help.h\"\n\n#if PMIX_HAVE_PDL_SUPPORT\n\n/*\n * Private types\n */\nstatic void ri_constructor(pmix_mca_base_component_repository_item_t *ri);\nstatic void ri_destructor(pmix_mca_base_component_repository_item_t *ri);\nPMIX_CLASS_INSTANCE(pmix_mca_base_component_repository_item_t, pmix_list_item_t,\n                    ri_constructor, ri_destructor);\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n\nstatic void clf_constructor(pmix_object_t *obj)\n{\n    pmix_mca_base_failed_component_t *cli = (pmix_mca_base_failed_component_t *) obj;\n    cli->comp = NULL;\n    cli->error_msg = NULL;\n}\n\nstatic void clf_destructor(pmix_object_t *obj)\n{\n    pmix_mca_base_failed_component_t *cli = (pmix_mca_base_failed_component_t *) obj;\n    cli->comp = NULL;\n    if( NULL != cli->error_msg ) {\n        free(cli->error_msg);\n        cli->error_msg = NULL;\n    }\n}\n\nPMIX_CLASS_INSTANCE(pmix_mca_base_failed_component_t, pmix_list_item_t,\n                    clf_constructor, clf_destructor);\n\n\n/*\n * Private variables\n */\nstatic bool initialized = false;\n\n\n#if PMIX_HAVE_PDL_SUPPORT\n\nstatic pmix_hash_table_t pmix_mca_base_component_repository;\n\n/* two-level macro for stringifying a number */\n#define STRINGIFYX(x) #x\n#define STRINGIFY(x) STRINGIFYX(x)\n\nstatic int process_repository_item (const char *filename, void *data)\n{\n    (void)data;\n    char name[PMIX_MCA_BASE_MAX_COMPONENT_NAME_LEN + 1];\n    char type[PMIX_MCA_BASE_MAX_TYPE_NAME_LEN + 1];\n    pmix_mca_base_component_repository_item_t *ri;\n    pmix_list_t *component_list;\n    char *base;\n    int ret;\n\n    base = pmix_basename (filename);\n    if (NULL == base) {\n        return PMIX_ERROR;\n    }\n\n    /* check if the plugin has the appropriate prefix */\n    if (0 != strncmp (base, \"mca_\", 4)) {\n        free (base);\n        return PMIX_SUCCESS;\n    }\n\n    /* read framework and component names. framework names may not include an _\n     * but component names may */\n    ret = sscanf(base, \"mca_%\" STRINGIFY(PMIX_MCA_BASE_MAX_TYPE_NAME_LEN) \"[^_]_%\"\n                 STRINGIFY(PMIX_MCA_BASE_MAX_COMPONENT_NAME_LEN) \"s\", type, name);\n    if (0 > ret) {\n        /* does not patch the expected template. skip */\n        free(base);\n        return PMIX_SUCCESS;\n    }\n\n    /* lookup the associated framework list and create if it doesn't already exist */\n    ret = pmix_hash_table_get_value_ptr(&pmix_mca_base_component_repository, type,\n                                        strlen (type), (void **) &component_list);\n    if (PMIX_SUCCESS != ret) {\n        component_list = PMIX_NEW(pmix_list_t);\n        if (NULL == component_list) {\n            free (base);\n            /* OOM. nothing to do but fail */\n            return PMIX_ERR_OUT_OF_RESOURCE;\n        }\n\n        ret = pmix_hash_table_set_value_ptr(&pmix_mca_base_component_repository, type,\n                                            strlen (type), (void *) component_list);\n        if (PMIX_SUCCESS != ret) {\n            free (base);\n            PMIX_RELEASE(component_list);\n            return ret;\n        }\n    }\n\n    /* check for duplicate components */\n    PMIX_LIST_FOREACH(ri, component_list, pmix_mca_base_component_repository_item_t) {\n        if (0 == strcmp (ri->ri_name, name)) {\n            /* already scanned this component */\n            free (base);\n            return PMIX_SUCCESS;\n        }\n    }\n\n    ri = PMIX_NEW(pmix_mca_base_component_repository_item_t);\n    if (NULL == ri) {\n        free (base);\n        return PMIX_ERR_OUT_OF_RESOURCE;\n    }\n\n    ri->ri_base = base;\n\n    ri->ri_path = strdup (filename);\n    if (NULL == ri->ri_path) {\n        PMIX_RELEASE(ri);\n        return PMIX_ERR_OUT_OF_RESOURCE;\n    }\n\n    /* pmix_strncpy does not guarantee a \\0 */\n    ri->ri_type[PMIX_MCA_BASE_MAX_TYPE_NAME_LEN] = '\\0';\n    pmix_strncpy (ri->ri_type, type, PMIX_MCA_BASE_MAX_TYPE_NAME_LEN);\n\n    ri->ri_name[PMIX_MCA_BASE_MAX_TYPE_NAME_LEN] = '\\0';\n    pmix_strncpy (ri->ri_name, name, PMIX_MCA_BASE_MAX_COMPONENT_NAME_LEN);\n\n    pmix_list_append (component_list, &ri->super);\n\n    return PMIX_SUCCESS;\n}\n\nstatic int file_exists(const char *filename, const char *ext)\n{\n    char *final;\n    int ret;\n\n    if (NULL == ext) {\n        return access (filename, F_OK) == 0;\n    }\n\n    ret = asprintf(&final, \"%s.%s\", filename, ext);\n    if (0 > ret || NULL == final) {\n        return 0;\n    }\n\n    ret = access (final, F_OK);\n    free(final);\n    return (0 == ret);\n}\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n\nint pmix_mca_base_component_repository_add (const char *path)\n{\n#if PMIX_HAVE_PDL_SUPPORT\n    char *path_to_use = NULL, *dir, *ctx;\n    const char sep[] = {PMIX_ENV_SEP, '\\0'};\n\n    if (NULL == path) {\n        /* nothing to do */\n        return PMIX_SUCCESS;\n    }\n\n    path_to_use = strdup (path);\n\n    dir = strtok_r (path_to_use, sep, &ctx);\n    do {\n        if ((0 == strcmp(dir, \"USER_DEFAULT\") || 0 == strcmp(dir, \"USR_DEFAULT\"))\n            && NULL != pmix_mca_base_user_default_path) {\n            dir = pmix_mca_base_user_default_path;\n        } else if (0 == strcmp(dir, \"SYS_DEFAULT\") ||\n                   0 == strcmp(dir, \"SYSTEM_DEFAULT\")) {\n            dir = pmix_mca_base_system_default_path;\n        }\n\n        if (0 != pmix_pdl_foreachfile(dir, process_repository_item, NULL) &&\n            !(0 == strcmp(dir, pmix_mca_base_system_default_path) || 0 == strcmp(dir, pmix_mca_base_user_default_path))) {\n            // It is not an error if a directory fails to add (e.g.,\n            // if it doesn't exist).  But we should warn about it as\n            // it is something related to \"show_load_errors\"\n            pmix_show_help(\"help-pmix-mca-base.txt\",\n                           \"failed to add component dir\", true, dir);\n        }\n    } while (NULL != (dir = strtok_r (NULL, sep, &ctx)));\n\n    free (path_to_use);\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n\n    return PMIX_SUCCESS;\n}\n\n\n/*\n * Initialize the repository\n */\nint pmix_mca_base_component_repository_init(void)\n{\n  /* Setup internal structures */\n\n  if (!initialized) {\n#if PMIX_HAVE_PDL_SUPPORT\n\n    /* Initialize the dl framework */\n    int ret = pmix_mca_base_framework_open(&pmix_pdl_base_framework, PMIX_MCA_BASE_OPEN_DEFAULT);\n    if (PMIX_SUCCESS != ret) {\n        pmix_output(0, \"%s %d:%s failed -- process will likely abort (open the dl framework returned %d instead of PMIX_SUCCESS)\\n\",\n                    __FILE__, __LINE__, __func__, ret);\n        return ret;\n    }\n    pmix_pdl_base_select();\n\n    PMIX_CONSTRUCT(&pmix_mca_base_component_repository, pmix_hash_table_t);\n    ret = pmix_hash_table_init (&pmix_mca_base_component_repository, 128);\n    if (PMIX_SUCCESS != ret) {\n        (void) pmix_mca_base_framework_close(&pmix_pdl_base_framework);\n        return ret;\n    }\n\n    ret = pmix_mca_base_component_repository_add(pmix_mca_base_component_path);\n    if (PMIX_SUCCESS != ret) {\n        PMIX_DESTRUCT(&pmix_mca_base_component_repository);\n        (void) pmix_mca_base_framework_close(&pmix_pdl_base_framework);\n        return ret;\n    }\n#endif\n\n    initialized = true;\n  }\n\n  /* All done */\n\n  return PMIX_SUCCESS;\n}\n\nint pmix_mca_base_component_repository_get_components (pmix_mca_base_framework_t *framework,\n                                                       pmix_list_t **framework_components)\n{\n    *framework_components = NULL;\n#if PMIX_HAVE_PDL_SUPPORT\n    return pmix_hash_table_get_value_ptr (&pmix_mca_base_component_repository, framework->framework_name,\n                                          strlen (framework->framework_name), (void **) framework_components);\n#else\n    return PMIX_ERR_NOT_FOUND;\n#endif\n}\n\n#if PMIX_HAVE_PDL_SUPPORT\nstatic void pmix_mca_base_component_repository_release_internal(pmix_mca_base_component_repository_item_t *ri) {\n    int group_id;\n\n    group_id = pmix_mca_base_var_group_find (NULL, ri->ri_type, ri->ri_name);\n    if (0 <= group_id) {\n        /* ensure all variables are deregistered before we dlclose the component */\n        pmix_mca_base_var_group_deregister (group_id);\n    }\n\n    /* Close the component (and potentially unload it from memory */\n    if (ri->ri_dlhandle) {\n        pmix_pdl_close(ri->ri_dlhandle);\n        ri->ri_dlhandle = NULL;\n    }\n}\n#endif\n\n#if PMIX_HAVE_PDL_SUPPORT\nstatic pmix_mca_base_component_repository_item_t *find_component(const char *type, const char *name)\n{\n    pmix_mca_base_component_repository_item_t *ri;\n    pmix_list_t *component_list;\n    int ret;\n\n    ret = pmix_hash_table_get_value_ptr (&pmix_mca_base_component_repository, type,\n                                         strlen (type), (void **) &component_list);\n    if (PMIX_SUCCESS != ret) {\n        /* component does not exist in the repository */\n        return NULL;\n    }\n\n    PMIX_LIST_FOREACH(ri, component_list, pmix_mca_base_component_repository_item_t) {\n        if (0 == strcmp (ri->ri_name, name)) {\n            return ri;\n        }\n    }\n\n    return NULL;\n}\n#endif\n\nvoid pmix_mca_base_component_repository_release(const pmix_mca_base_component_t *component)\n{\n#if PMIX_HAVE_PDL_SUPPORT\n    pmix_mca_base_component_repository_item_t *ri;\n\n    ri = find_component (component->pmix_mca_type_name, component->pmix_mca_component_name);\n    if (NULL != ri && !(--ri->ri_refcnt)) {\n        pmix_mca_base_component_repository_release_internal (ri);\n    }\n#endif\n}\n\nint pmix_mca_base_component_repository_retain_component(const char *type, const char *name)\n{\n#if PMIX_HAVE_PDL_SUPPORT\n    pmix_mca_base_component_repository_item_t *ri = find_component(type, name);\n\n    if (NULL != ri) {\n        ++ri->ri_refcnt;\n        return PMIX_SUCCESS;\n    }\n\n    return PMIX_ERR_NOT_FOUND;\n#else\n    return PMIX_ERR_NOT_SUPPORTED;\n#endif\n}\n\nint pmix_mca_base_component_repository_open(pmix_mca_base_framework_t *framework,\n                                            pmix_mca_base_component_repository_item_t *ri)\n{\n#if PMIX_HAVE_PDL_SUPPORT\n    pmix_mca_base_component_t *component_struct;\n    pmix_mca_base_component_list_item_t *mitem = NULL;\n    char *struct_name = NULL;\n    int vl, ret;\n\n    pmix_output_verbose(PMIX_MCA_BASE_VERBOSE_INFO, 0, \"pmix_mca_base_component_repository_open: examining dynamic \"\n                        \"%s MCA component \\\"%s\\\" at path %s\", ri->ri_type, ri->ri_name, ri->ri_path);\n\n    vl = pmix_mca_base_component_show_load_errors ? PMIX_MCA_BASE_VERBOSE_ERROR : PMIX_MCA_BASE_VERBOSE_INFO;\n\n    /* Ensure that this component is not already loaded (should only happen\n       if it was statically loaded).  It's an error if it's already\n       loaded because we're evaluating this file -- not this component.\n       Hence, returning PMIX_ERR_PARAM indicates that the *file* failed\n       to load, not the component. */\n\n    PMIX_LIST_FOREACH(mitem, &framework->framework_components, pmix_mca_base_component_list_item_t) {\n        if (0 == strcmp(mitem->cli_component->pmix_mca_component_name, ri->ri_name)) {\n            pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_INFO, 0, \"pmix_mca_base_component_repository_open: already loaded (ignored)\");\n            return PMIX_ERR_BAD_PARAM;\n        }\n    }\n\n    /* silence coverity issue (invalid free) */\n    mitem = NULL;\n\n    if (NULL != ri->ri_dlhandle) {\n        pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_INFO, 0, \"pmix_mca_base_component_repository_open: already loaded. returning cached component\");\n        mitem = PMIX_NEW(pmix_mca_base_component_list_item_t);\n        if (NULL == mitem) {\n            return PMIX_ERR_OUT_OF_RESOURCE;\n        }\n\n        mitem->cli_component = ri->ri_component_struct;\n        pmix_list_append (&framework->framework_components, &mitem->super);\n\n        return PMIX_SUCCESS;\n    }\n\n    if (0 != strcmp (ri->ri_type, framework->framework_name)) {\n        /* shouldn't happen. attempting to open a component belonging to\n         * another framework. if this happens it is likely a MCA base\n         * bug so assert */\n        assert (0);\n        return PMIX_ERR_NOT_SUPPORTED;\n    }\n\n    /* Now try to load the component */\n\n    char *err_msg = NULL;\n    if (PMIX_SUCCESS != pmix_pdl_open(ri->ri_path, true, false, &ri->ri_dlhandle, &err_msg)) {\n        if (NULL == err_msg) {\n            err_msg = strdup(\"pmix_dl_open() error message was NULL!\");\n        } else if (file_exists(ri->ri_path, \"lo\") ||\n                   file_exists(ri->ri_path, \"so\") ||\n                   file_exists(ri->ri_path, \"dylib\") ||\n                   file_exists(ri->ri_path, \"dll\")) {\n            /* Because libltdl erroneously says \"file not found\" for any\n             * type of error -- which is especially misleading when the file\n             * is actually there but cannot be opened for some other reason\n             * (e.g., missing symbol) -- do some simple huersitics and if\n             * the file [probably] does exist, print a slightly better error\n             * message. */\n            err_msg = strdup(\"perhaps a missing symbol, or compiled for a different version of OpenPMIx\");\n        }\n        pmix_output_verbose(vl, 0, \"pmix_mca_base_component_repository_open: unable to open %s: %s (ignored)\",\n                            ri->ri_base, err_msg);\n\n        if( pmix_mca_base_component_track_load_errors ) {\n            pmix_mca_base_failed_component_t *f_comp = PMIX_NEW(pmix_mca_base_failed_component_t);\n            f_comp->comp = ri;\n            if (0 > asprintf(&(f_comp->error_msg), \"%s\", err_msg)) {\n                PMIX_RELEASE(f_comp);\n                free(err_msg);\n                return PMIX_ERR_BAD_PARAM;\n            }\n            pmix_list_append(&framework->framework_failed_components, &f_comp->super);\n        }\n\n        free(err_msg);\n        return PMIX_ERR_BAD_PARAM;\n    }\n\n    /* Successfully opened the component; now find the public struct.\n       Malloc out enough space for it. */\n\n    do {\n        ret = asprintf (&struct_name, \"mca_%s_%s_component\", ri->ri_type, ri->ri_name);\n        if (0 > ret) {\n            ret = PMIX_ERR_OUT_OF_RESOURCE;\n            break;\n        }\n\n        mitem = PMIX_NEW(pmix_mca_base_component_list_item_t);\n        if (NULL == mitem) {\n            ret = PMIX_ERR_OUT_OF_RESOURCE;\n            break;\n        }\n\n        err_msg = NULL;\n        ret = pmix_pdl_lookup(ri->ri_dlhandle, struct_name, (void**) &component_struct, &err_msg);\n        if (PMIX_SUCCESS != ret || NULL == component_struct) {\n            if (NULL == err_msg) {\n                err_msg = \"pmix_dl_loookup() error message was NULL!\";\n            }\n            pmix_output_verbose(vl, 0, \"pmix_mca_base_component_repository_open: \\\"%s\\\" does not appear to be a valid \"\n                                \"%s MCA dynamic component (ignored): %s. ret %d\", ri->ri_base, ri->ri_type, err_msg, ret);\n\n            ret = PMIX_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* done with the structure name */\n        free (struct_name);\n        struct_name = NULL;\n\n        /* We found the public struct.  Make sure its MCA major.minor\n           version is the same as ours. TODO -- add checks for project version (from framework) */\n        if (!(PMIX_MCA_BASE_VERSION_MAJOR == component_struct->pmix_mca_major_version &&\n              PMIX_MCA_BASE_VERSION_MINOR == component_struct->pmix_mca_minor_version)) {\n            pmix_output_verbose(vl, 0, \"pmix_mca_base_component_repository_open: %s \\\"%s\\\" uses an MCA interface that is \"\n                                \"not recognized (component MCA v%d.%d.%d != supported MCA v%d.%d.%d) -- ignored\",\n                                ri->ri_type, ri->ri_path, component_struct->pmix_mca_major_version,\n                                component_struct->pmix_mca_minor_version, component_struct->pmix_mca_release_version,\n                                PMIX_MCA_BASE_VERSION_MAJOR, PMIX_MCA_BASE_VERSION_MINOR, PMIX_MCA_BASE_VERSION_RELEASE);\n            ret = PMIX_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* Also check that the component struct framework and component\n           names match the expected names from the filename */\n        if (0 != strcmp(component_struct->pmix_mca_type_name, ri->ri_type) ||\n            0 != strcmp(component_struct->pmix_mca_component_name, ri->ri_name)) {\n            pmix_output_verbose(vl, 0, \"Component file data does not match filename: %s (%s / %s) != %s %s -- ignored\",\n                                ri->ri_path, ri->ri_type, ri->ri_name,\n                                component_struct->pmix_mca_type_name,\n                                component_struct->pmix_mca_component_name);\n            ret = PMIX_ERR_BAD_PARAM;\n            break;\n        }\n\n        /* Alles gut.  Save the component struct, and register this\n           component to be closed later. */\n\n        ri->ri_component_struct = mitem->cli_component = component_struct;\n        ri->ri_refcnt = 1;\n        pmix_list_append(&framework->framework_components, &mitem->super);\n\n        pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_INFO, 0, \"pmix_mca_base_component_repository_open: opened dynamic %s MCA \"\n                             \"component \\\"%s\\\"\", ri->ri_type, ri->ri_name);\n\n        return PMIX_SUCCESS;\n    } while (0);\n\n    if (mitem) {\n        PMIX_RELEASE(mitem);\n    }\n\n    if (struct_name) {\n        free (struct_name);\n    }\n\n    pmix_pdl_close (ri->ri_dlhandle);\n    ri->ri_dlhandle = NULL;\n\n    return ret;\n#else\n\n    /* no dlopen support */\n    return PMIX_ERR_NOT_SUPPORTED;\n#endif\n}\n\n/*\n * Finalize the repository -- close everything that's still open.\n */\nvoid pmix_mca_base_component_repository_finalize(void)\n{\n    if (!initialized) {\n        return;\n    }\n\n    initialized = false;\n\n#if PMIX_HAVE_PDL_SUPPORT\n    pmix_list_t *component_list;\n    void *node, *key;\n    size_t key_size;\n    int ret;\n\n    ret = pmix_hash_table_get_first_key_ptr (&pmix_mca_base_component_repository, &key, &key_size,\n                                             (void **) &component_list, &node);\n    while (PMIX_SUCCESS == ret) {\n        PMIX_LIST_RELEASE(component_list);\n        ret = pmix_hash_table_get_next_key_ptr (&pmix_mca_base_component_repository, &key,\n                                                &key_size, (void **) &component_list,\n                                                node, &node);\n    }\n\n    (void) pmix_mca_base_framework_close(&pmix_pdl_base_framework);\n    PMIX_DESTRUCT(&pmix_mca_base_component_repository);\n#endif\n}\n\n#if PMIX_HAVE_PDL_SUPPORT\n\n/*\n * Basic sentinel values, and construct the inner list\n */\nstatic void ri_constructor (pmix_mca_base_component_repository_item_t *ri)\n{\n    memset(ri->ri_type, 0, sizeof(ri->ri_type));\n    ri->ri_dlhandle = NULL;\n    ri->ri_component_struct = NULL;\n    ri->ri_path = NULL;\n}\n\n\n/*\n * Close a component\n */\nstatic void ri_destructor (pmix_mca_base_component_repository_item_t *ri)\n{\n    /* dlclose the component if it is still open */\n    pmix_mca_base_component_repository_release_internal (ri);\n\n    /* It should be obvious, but I'll state it anyway because it bit me\n       during debugging: after the dlclose(), the pmix_mca_base_component_t\n       pointer is no longer valid because it has [potentially] been\n       unloaded from memory.  So don't try to use it.  :-) */\n\n    if (ri->ri_path) {\n        free (ri->ri_path);\n    }\n\n    if (ri->ri_base) {\n        free (ri->ri_base);\n    }\n}\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/base/pmix_mca_base_open.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2008 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2011      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2021      Nanook Consulting.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"src/include/pmix_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#ifdef HAVE_SYSLOG_H\n#include <syslog.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"src/mca/pinstalldirs/pinstalldirs.h\"\n#include \"src/util/output.h\"\n#include \"src/util/printf.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/pmix_mca_base_component_repository.h\"\n#include \"include/pmix_common.h\"\n#include \"src/util/pmix_environ.h\"\n\n/*\n * Public variables\n */\nchar *pmix_mca_base_component_path = NULL;\nint pmix_mca_base_opened = 0;\nchar *pmix_mca_base_system_default_path = NULL;\nchar *pmix_mca_base_user_default_path = NULL;\nbool pmix_mca_base_component_show_load_errors = (bool) PMIX_SHOW_LOAD_ERRORS_DEFAULT;\nbool pmix_mca_base_component_track_load_errors = false;\nbool pmix_mca_base_component_disable_dlopen = false;\n\nstatic char *pmix_mca_base_verbose = NULL;\n\n/*\n * Private functions\n */\nstatic void set_defaults(pmix_output_stream_t *lds);\nstatic void parse_verbose(char *e, pmix_output_stream_t *lds);\n\n\n/*\n * Main MCA initialization.\n */\nint pmix_mca_base_open(void)\n{\n    char *value;\n    pmix_output_stream_t lds;\n    char hostname[PMIX_MAXHOSTNAMELEN] = {0};\n    int var_id;\n    int rc;\n\n    if (pmix_mca_base_opened++) {\n        return PMIX_SUCCESS;\n    }\n\n    /* define the system and user default paths */\n    pmix_mca_base_system_default_path = strdup(pmix_pinstall_dirs.pmixlibdir);\n#if PMIX_WANT_HOME_CONFIG_FILES\n    value = (char*)pmix_home_directory(geteuid());\n    rc = asprintf(&pmix_mca_base_user_default_path, \"%s\"PMIX_PATH_SEP\".pmix\"PMIX_PATH_SEP\"components\", value);\n    if (0 > rc) {\n        return PMIX_ERR_OUT_OF_RESOURCE;\n    }\n#endif\n\n\n    /* see if the user wants to override the defaults */\n    if (NULL == pmix_mca_base_user_default_path) {\n        value = strdup(pmix_mca_base_system_default_path);\n    } else {\n        rc = asprintf(&value, \"%s%c%s\", pmix_mca_base_system_default_path,\n                      PMIX_ENV_SEP, pmix_mca_base_user_default_path);\n        if (0 > rc) {\n            return PMIX_ERR_OUT_OF_RESOURCE;\n        }\n    }\n\n    pmix_mca_base_component_path = value;\n    var_id = pmix_mca_base_var_register(\"pmix\", \"mca\", \"base\", \"component_path\",\n                                   \"Path where to look for additional components\",\n                                   PMIX_MCA_BASE_VAR_TYPE_STRING, NULL, 0, PMIX_MCA_BASE_VAR_FLAG_NONE,\n                                   PMIX_INFO_LVL_9,\n                                   PMIX_MCA_BASE_VAR_SCOPE_READONLY,\n                                   &pmix_mca_base_component_path);\n    (void) pmix_mca_base_var_register_synonym(var_id, \"pmix\", \"mca\", NULL, \"component_path\",\n                                              PMIX_MCA_BASE_VAR_SYN_FLAG_DEPRECATED);\n    free(value);\n\n    pmix_mca_base_component_show_load_errors = (bool) PMIX_SHOW_LOAD_ERRORS_DEFAULT;;\n    var_id = pmix_mca_base_var_register(\"pmix\", \"mca\", \"base\", \"component_show_load_errors\",\n                                   \"Whether to show errors for components that failed to load or not\",\n                                   PMIX_MCA_BASE_VAR_TYPE_BOOL, NULL, 0, PMIX_MCA_BASE_VAR_FLAG_NONE,\n                                   PMIX_INFO_LVL_9,\n                                   PMIX_MCA_BASE_VAR_SCOPE_READONLY,\n                                   &pmix_mca_base_component_show_load_errors);\n    (void) pmix_mca_base_var_register_synonym(var_id, \"pmix\", \"mca\", NULL, \"component_show_load_errors\",\n                                              PMIX_MCA_BASE_VAR_SYN_FLAG_DEPRECATED);\n\n    pmix_mca_base_component_track_load_errors = false;\n    var_id = pmix_mca_base_var_register(\"pmix\", \"mca\", \"base\", \"component_track_load_errors\",\n                                        \"Whether to track errors for components that failed to load or not\",\n                                        PMIX_MCA_BASE_VAR_TYPE_BOOL, NULL, 0, PMIX_MCA_BASE_VAR_FLAG_NONE,\n                                        PMIX_INFO_LVL_9,\n                                        PMIX_MCA_BASE_VAR_SCOPE_READONLY,\n                                        &pmix_mca_base_component_track_load_errors);\n\n    pmix_mca_base_component_disable_dlopen = false;\n    var_id = pmix_mca_base_var_register(\"pmix\", \"mca\", \"base\", \"component_disable_dlopen\",\n                                   \"Whether to attempt to disable opening dynamic components or not\",\n                                   PMIX_MCA_BASE_VAR_TYPE_BOOL, NULL, 0, PMIX_MCA_BASE_VAR_FLAG_NONE,\n                                   PMIX_INFO_LVL_9,\n                                   PMIX_MCA_BASE_VAR_SCOPE_READONLY,\n                                   &pmix_mca_base_component_disable_dlopen);\n    (void) pmix_mca_base_var_register_synonym(var_id, \"pmix\", \"mca\", NULL, \"component_disable_dlopen\",\n                                              PMIX_MCA_BASE_VAR_SYN_FLAG_DEPRECATED);\n\n    /* What verbosity level do we want for the default 0 stream? */\n    pmix_mca_base_verbose = \"stderr\";\n    var_id = pmix_mca_base_var_register(\"pmix\", \"mca\", \"base\", \"verbose\",\n                                   \"Specifies where the default error output stream goes (this is separate from distinct help messages).  Accepts a comma-delimited list of: stderr, stdout, syslog, syslogpri:<notice|info|debug>, syslogid:<str> (where str is the prefix string for all syslog notices), file[:filename] (if filename is not specified, a default filename is used), fileappend (if not specified, the file is opened for truncation), level[:N] (if specified, integer verbose level; otherwise, 0 is implied)\",\n                                   PMIX_MCA_BASE_VAR_TYPE_STRING, NULL, 0, PMIX_MCA_BASE_VAR_FLAG_NONE,\n                                   PMIX_INFO_LVL_9,\n                                   PMIX_MCA_BASE_VAR_SCOPE_READONLY,\n                                   &pmix_mca_base_verbose);\n    (void) pmix_mca_base_var_register_synonym(var_id, \"pmix\", \"mca\", NULL, \"verbose\",\n                                              PMIX_MCA_BASE_VAR_SYN_FLAG_DEPRECATED);\n\n    memset(&lds, 0, sizeof(lds));\n    if (NULL != pmix_mca_base_verbose) {\n        parse_verbose(pmix_mca_base_verbose, &lds);\n    } else {\n        set_defaults(&lds);\n    }\n    gethostname(hostname, PMIX_MAXHOSTNAMELEN-1);\n    rc = asprintf(&lds.lds_prefix, \"[%s:%05d] \", hostname, getpid());\n    if (0 > rc) {\n        return PMIX_ERR_OUT_OF_RESOURCE;\n    }\n    pmix_output_reopen(0, &lds);\n    pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_COMPONENT, 0,\n                         \"mca: base: opening components at %s\", pmix_mca_base_component_path);\n    free(lds.lds_prefix);\n\n    /* Open up the component repository */\n\n    return pmix_mca_base_component_repository_init();\n}\n\n\n/*\n * Set sane default values for the lds\n */\nstatic void set_defaults(pmix_output_stream_t *lds)\n{\n\n    /* Load up defaults */\n\n    PMIX_CONSTRUCT(lds, pmix_output_stream_t);\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n    lds->lds_syslog_priority = LOG_INFO;\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n    lds->lds_syslog_ident = \"ompi\";\n    lds->lds_want_stderr = true;\n}\n\n\n/*\n * Parse the value of an environment variable describing verbosity\n */\nstatic void parse_verbose(char *e, pmix_output_stream_t *lds)\n{\n    char *edup;\n    char *ptr, *next;\n    bool have_output = false;\n\n    if (NULL == e) {\n        return;\n    }\n\n    edup = strdup(e);\n    ptr = edup;\n\n    /* Now parse the environment variable */\n\n    while (NULL != ptr && strlen(ptr) > 0) {\n        next = strchr(ptr, ',');\n        if (NULL != next) {\n            *next = '\\0';\n        }\n\n        if (0 == strcasecmp(ptr, \"syslog\")) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            have_output = true;\n#else\n            pmix_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        }\n        else if (strncasecmp(ptr, \"syslogpri:\", 10) == 0) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            have_output = true;\n            if (strcasecmp(ptr + 10, \"notice\") == 0)\n                lds->lds_syslog_priority = LOG_NOTICE;\n            else if (strcasecmp(ptr + 10, \"INFO\") == 0)\n                lds->lds_syslog_priority = LOG_INFO;\n            else if (strcasecmp(ptr + 10, \"DEBUG\") == 0)\n                lds->lds_syslog_priority = LOG_DEBUG;\n#else\n            pmix_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        } else if (strncasecmp(ptr, \"syslogid:\", 9) == 0) {\n#if defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H)\n            lds->lds_want_syslog = true;\n            lds->lds_syslog_ident = ptr + 9;\n#else\n            pmix_output(0, \"syslog support requested but not available on this system\");\n#endif  /* defined(HAVE_SYSLOG) && defined(HAVE_SYSLOG_H) */\n        }\n\n        else if (strcasecmp(ptr, \"stdout\") == 0) {\n            lds->lds_want_stdout = true;\n            have_output = true;\n        } else if (strcasecmp(ptr, \"stderr\") == 0) {\n            lds->lds_want_stderr = true;\n            have_output = true;\n        }\n\n        else if (strcasecmp(ptr, \"file\") == 0 || strcasecmp(ptr, \"file:\") == 0) {\n            lds->lds_want_file = true;\n            have_output = true;\n        } else if (strncasecmp(ptr, \"file:\", 5) == 0) {\n            lds->lds_want_file = true;\n            lds->lds_file_suffix = strdup(ptr + 5);\n            have_output = true;\n        } else if (strcasecmp(ptr, \"fileappend\") == 0) {\n            lds->lds_want_file = true;\n            lds->lds_want_file_append = 1;\n            have_output = true;\n        }\n\n        else if (strncasecmp(ptr, \"level\", 5) == 0) {\n            lds->lds_verbose_level = 0;\n            if (ptr[5] == PMIX_ENV_SEP)\n                lds->lds_verbose_level = atoi(ptr + 6);\n        }\n\n        if (NULL == next) {\n            break;\n        }\n        ptr = next + 1;\n    }\n\n    /* If we didn't get an output, default to stderr */\n\n    if (!have_output) {\n        lds->lds_want_stderr = true;\n    }\n\n    /* All done */\n\n    free(edup);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/base/pmix_mca_base_component_find.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2005 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2007 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2008-2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2008      Sun Microsystems, Inc.  All rights reserved.\n * Copyright (c) 2015      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * Copyright (c) 2014-2015 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"src/include/pmix_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n\n#include \"src/mca/pinstalldirs/pinstalldirs.h\"\n#include \"src/util/pmix_environ.h\"\n#include \"src/util/output.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/show_help.h\"\n#include \"src/class/pmix_list.h\"\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n#include \"src/mca/base/pmix_mca_base_component_repository.h\"\n#include \"include/pmix_common.h\"\n#include \"src/mca/pdl/base/base.h\"\n\n#if PMIX_HAVE_PDL_SUPPORT\n/*\n * Private functions\n */\nstatic void find_dyn_components(const char *path, pmix_mca_base_framework_t *framework,\n                                const char **names, bool include_mode);\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n\nstatic int component_find_check (pmix_mca_base_framework_t *framework, char **requested_component_names);\n\n/*\n * Dummy structure for casting for open_only logic\n */\nstruct pmix_mca_base_open_only_dummy_component_t {\n    /** MCA base component */\n    pmix_mca_base_component_t version;\n    /** MCA base data */\n    pmix_mca_base_component_data_t data;\n};\ntypedef struct pmix_mca_base_open_only_dummy_component_t pmix_mca_base_open_only_dummy_component_t;\n\nstatic char negate[] = \"^\";\n\nstatic bool use_component(const bool include_mode,\n                          const char **requested_component_names,\n                          const char *component_name);\n\n\n/*\n * Function to find as many components of a given type as possible.  This\n * includes statically-linked in components as well as opening up a\n * directory and looking for shared-library MCA components of the\n * appropriate type (load them if available).\n *\n * Return one consolidated array of (pmix_mca_base_component_t*) pointing to all\n * available components.\n */\nint pmix_mca_base_component_find (const char *directory, pmix_mca_base_framework_t *framework,\n                                  bool ignore_requested, bool open_dso_components)\n{\n    const pmix_mca_base_component_t **static_components = framework->framework_static_components;\n    char **requested_component_names = NULL;\n    pmix_mca_base_component_list_item_t *cli;\n    bool include_mode = true;\n    int ret;\n\n    pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_COMPONENT, framework->framework_output,\n                         \"mca: base: component_find: searching %s for %s components\",\n                         directory, framework->framework_name);\n\n    if (!ignore_requested) {\n        ret = pmix_mca_base_component_parse_requested (framework->framework_selection, &include_mode,\n                                                       &requested_component_names);\n        if (PMIX_SUCCESS != ret) {\n            return ret;\n        }\n    }\n\n    /* Find all the components that were statically linked in */\n    if (static_components) {\n        for (int i = 0 ; NULL != static_components[i]; ++i) {\n            if ( use_component(include_mode,\n                               (const char**)requested_component_names,\n                               static_components[i]->pmix_mca_component_name) ) {\n                cli = PMIX_NEW(pmix_mca_base_component_list_item_t);\n                if (NULL == cli) {\n                    ret = PMIX_ERR_OUT_OF_RESOURCE;\n                    goto component_find_out;\n                }\n                cli->cli_component = static_components[i];\n                pmix_list_append(&framework->framework_components, (pmix_list_item_t *) cli);\n            }\n        }\n    }\n\n#if PMIX_HAVE_PDL_SUPPORT\n    /* Find any available dynamic components in the specified directory */\n    if (open_dso_components && !pmix_mca_base_component_disable_dlopen) {\n        find_dyn_components(directory, framework, (const char**)requested_component_names,\n                            include_mode);\n    } else {\n        pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_INFO, 0,\n                            \"pmix:mca: base: component_find: dso loading for %s MCA components disabled\",\n                            framework->framework_name);\n    }\n#endif\n\n    if (include_mode) {\n        ret = component_find_check (framework, requested_component_names);\n    } else {\n        ret = PMIX_SUCCESS;\n    }\n\ncomponent_find_out:\n\n    if (NULL != requested_component_names) {\n        pmix_argv_free(requested_component_names);\n    }\n\n    /* All done */\n\n    return ret;\n}\n\nint pmix_mca_base_component_find_finalize(void)\n{\n    return PMIX_SUCCESS;\n}\n\nint pmix_mca_base_components_filter (pmix_mca_base_framework_t *framework, uint32_t filter_flags)\n{\n    pmix_list_t *components = &framework->framework_components;\n    int output_id = framework->framework_output;\n    pmix_mca_base_component_list_item_t *cli, *next;\n    char **requested_component_names = NULL;\n    bool include_mode, can_use;\n    int ret;\n\n    assert (NULL != components);\n\n    if (0 == filter_flags && NULL == framework->framework_selection) {\n        return PMIX_SUCCESS;\n    }\n\n    ret = pmix_mca_base_component_parse_requested (framework->framework_selection, &include_mode,\n                                              &requested_component_names);\n    if (PMIX_SUCCESS != ret) {\n        return ret;\n    }\n\n    PMIX_LIST_FOREACH_SAFE(cli, next, components, pmix_mca_base_component_list_item_t) {\n        const pmix_mca_base_component_t *component = cli->cli_component;\n        pmix_mca_base_open_only_dummy_component_t *dummy =\n            (pmix_mca_base_open_only_dummy_component_t *) cli->cli_component;\n\n        can_use = use_component(include_mode, (const char **) requested_component_names,\n                                cli->cli_component->pmix_mca_component_name);\n\n        if (!can_use || (filter_flags & dummy->data.param_field) != filter_flags) {\n            if (can_use && (filter_flags & PMIX_MCA_BASE_METADATA_PARAM_CHECKPOINT) &&\n                !(PMIX_MCA_BASE_METADATA_PARAM_CHECKPOINT & dummy->data.param_field)) {\n                pmix_output_verbose(PMIX_MCA_BASE_VERBOSE_COMPONENT, output_id,\n                                    \"pmix:mca: base: components_filter: \"\n                                    \"(%s) Component %s is *NOT* Checkpointable - Disabled\",\n                                    component->reserved,\n                                    component->pmix_mca_component_name);\n            }\n\n            pmix_list_remove_item(components, &cli->super);\n\n            pmix_mca_base_component_unload(component, output_id);\n\n            PMIX_RELEASE(cli);\n        } else if (filter_flags & PMIX_MCA_BASE_METADATA_PARAM_CHECKPOINT) {\n            pmix_output_verbose(PMIX_MCA_BASE_VERBOSE_COMPONENT, output_id,\n                                \"pmix:mca: base: components_filter: \"\n                                \"(%s) Component %s is Checkpointable\",\n                                component->reserved,\n                                component->pmix_mca_component_name);\n        }\n    }\n\n    if (include_mode) {\n        ret = component_find_check(framework, requested_component_names);\n    } else {\n        ret = PMIX_SUCCESS;\n    }\n\n    if (NULL != requested_component_names) {\n        pmix_argv_free(requested_component_names);\n    }\n\n    return ret;\n}\n\n#if PMIX_HAVE_PDL_SUPPORT\n\n/*\n * Open up all directories in a given path and search for components of\n * the specified type (and possibly of a given name).\n *\n * Note that we use our own path iteration functionality because we\n * need to look at companion .ompi_info files in the same directory as\n * the library to generate dependencies, etc.\n */\nstatic void find_dyn_components(const char *path, pmix_mca_base_framework_t *framework,\n                                const char **names, bool include_mode)\n{\n    pmix_mca_base_component_repository_item_t *ri;\n    pmix_list_t *dy_components;\n    int ret;\n\n    pmix_output_verbose (PMIX_MCA_BASE_VERBOSE_COMPONENT, framework->framework_output,\n                         \"mca: base: find_dyn_components: checking %s for %s components\",\n                         path, framework->framework_name);\n\n    if (NULL != path) {\n        ret = pmix_mca_base_component_repository_add(path);\n        if (PMIX_SUCCESS != ret) {\n            return;\n        }\n    }\n\n    ret = pmix_mca_base_component_repository_get_components(framework, &dy_components);\n    if (PMIX_SUCCESS != ret) {\n        return;\n    }\n\n    /* Iterate through the repository and find components that can be included */\n    PMIX_LIST_FOREACH(ri, dy_components, pmix_mca_base_component_repository_item_t) {\n        if (use_component(include_mode, names, ri->ri_name)) {\n            pmix_mca_base_component_repository_open(framework, ri);\n        }\n    }\n}\n\n#endif /* PMIX_HAVE_PDL_SUPPORT */\n\nstatic bool use_component(const bool include_mode,\n                          const char **requested_component_names,\n                          const char *component_name)\n{\n    bool found = false;\n    const char **req_comp_name = requested_component_names;\n\n    /*\n     * If no selection is specified then we use all components\n     * we can find.\n     */\n    if (NULL == req_comp_name) {\n        return true;\n    }\n\n    while ( *req_comp_name != NULL ) {\n        if ( strcmp(component_name, *req_comp_name) == 0 ) {\n            found = true;\n            break;\n        }\n        req_comp_name++;\n    }\n\n    /*\n     * include_mode  found |   use\n     * --------------------+------\n     *            0      0 |  true\n     *            0      1 | false\n     *            1      0 | false\n     *            1      1 |  true\n     *\n     * -> inverted xor\n     * As xor is a binary operator let's implement it manually before\n     * a compiler screws it up.\n     */\n\n    return (include_mode && found) || !(include_mode || found);\n}\n\n/* Ensure that *all* requested components exist.  Print a warning\n   and abort if they do not. */\nstatic int component_find_check (pmix_mca_base_framework_t *framework, char **requested_component_names)\n{\n    pmix_list_t *components = &framework->framework_components;\n    pmix_mca_base_component_list_item_t *cli;\n\n    if (NULL == requested_component_names) {\n        return PMIX_SUCCESS;\n    }\n\n    for (int i = 0; NULL != requested_component_names[i]; ++i) {\n        bool found = false;\n\n        PMIX_LIST_FOREACH(cli, components, pmix_mca_base_component_list_item_t) {\n            if (0 == strcmp(requested_component_names[i],\n                            cli->cli_component->pmix_mca_component_name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found && pmix_mca_base_component_show_load_errors) {\n            char h[PMIX_MAXHOSTNAMELEN] = {0};\n            gethostname(h, sizeof(h)-1);\n            pmix_show_help(\"help-pmix-mca-base.txt\",\n                           \"find-available:not-valid\", true,\n                           h, framework->framework_name, requested_component_names[i]);\n        }\n    }\n\n    return PMIX_SUCCESS;\n}\n\nint pmix_mca_base_component_parse_requested (const char *requested, bool *include_mode,\n                                        char ***requested_component_names)\n{\n    const char *requested_orig = requested;\n\n    *requested_component_names = NULL;\n    *include_mode = true;\n\n    /* See if the user requested anything */\n    if (NULL == requested || 0 == strlen (requested)) {\n        return PMIX_SUCCESS;\n    }\n\n    /* Are we including or excluding?  We only allow the negate\n       character to be the *first* character of the value (but be nice\n       and allow any number of negate characters in the beginning). */\n    *include_mode = requested[0] != negate[0];\n\n    /* skip over all negate symbols at the beginning */\n    requested += strspn (requested, negate);\n\n    /* Double check to ensure that the user did not specify the negate\n       character anywhere else in the value. */\n    if (NULL != strstr (requested, negate)) {\n        pmix_show_help(\"help-pmix-mca-base.txt\",\n                       \"framework-param:too-many-negates\",\n                       true, requested_orig);\n        return PMIX_ERROR;\n    }\n\n    /* Split up the value into individual component names */\n    *requested_component_names = pmix_argv_split(requested, ',');\n\n    /* All done */\n    return PMIX_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/configure.m4": "dnl -*- shell-script -*-\ndnl\ndnl Copyright (c) 2010-2015 Cisco Systems, Inc.  All rights reserved.\ndnl Copyright (c) 2016-2017 Intel, Inc. All rights reserved.\ndnl Copyright (c) 2016-2019 Research Organization for Information Science\ndnl                         and Technology (RIST). All rights reserved.\ndnl $COPYRIGHT$\ndnl\ndnl Additional copyrights may follow\ndnl\ndnl $HEADER$\ndnl\n\ndnl There will only be one component used in this framework, and it will\ndnl be selected at configure time by priority.  Components must set\ndnl their priorities in their configure.m4 file.\n\ndnl We only want one winning component (vs. STOP_AT_FIRST_PRIORITY,\ndnl which will allow all components of the same priority who succeed to\ndnl win)\nm4_define(MCA_pmix_pdl_CONFIGURE_MODE, STOP_AT_FIRST)\n\nAC_DEFUN([MCA_pmix_pdl_CONFIG],[\n    PMIX_HAVE_PDL_SUPPORT=0\n\n    # If --disable-dlopen was used, then have all the components fail\n    # (we still need to configure them all so that things like \"make\n    # dist\" work\", but we just want the MCA system to (artificially)\n    # conclude that it can't build any of the components.\n    AS_IF([test $PMIX_ENABLE_DLOPEN_SUPPORT -eq 0],\n          [want_pdl=0], [want_pdl=1])\n\n    MCA_CONFIGURE_FRAMEWORK([pdl], [$want_pdl])\n\n    # If we found no suitable static pdl component and dlopen support\n    # was not specifically disabled, this is an error.\n    AS_IF([test \"$MCA_pmix_pdl_STATIC_COMPONENTS\" = \"\" && \\\n           test $PMIX_ENABLE_DLOPEN_SUPPORT -eq 1],\n          [AC_MSG_WARN([Did not find a suitable static pmix pdl component])\n           AC_MSG_WARN([You might need to install libltld (and its headers) or])\n           AC_MSG_WARN([specify --disable-dlopen to configure.])\n           AC_MSG_ERROR([Cannot continue])])\n\n    # If we have a winning component (which, per above, will only\n    # happen if --disable-dlopen was *not* specified), do some more\n    # logic.\n    AS_IF([test \"$MCA_pmix_pdl_STATIC_COMPONENTS\" != \"\"],\n       [ # We had a winner -- w00t!\n\n        PMIX_HAVE_PDL_SUPPORT=1\n        # If we added any -L flags to ADD_LDFLAGS, then we (might)\n        # need to add those directories to LD_LIBRARY_PATH.\n        # Otherwise, if we try to AC RUN_IFELSE anything here in\n        # configure, it might die because it can't find the libraries\n        # we just linked against.\n        PMIX_VAR_SCOPE_PUSH([pmix_pdl_base_found_l pmix_pdl_base_token pmix_pdl_base_tmp pmix_pdl_base_dir])\n        pmix_pdl_base_found_l=0\n        eval \"pmix_pdl_base_tmp=\\$pmix_pdl_${pmix_pdl_winner}_ADD_LIBS\"\n        for pmix_pdl_base_token in $pmix_pdl_base_tmp; do\n            case $pmix_pdl_base_token in\n            -l*) pmix_pdl_base_found_l=1 ;;\n            esac\n        done\n        AS_IF([test $pmix_pdl_base_found_l -eq 1],\n              [eval \"pmix_pdl_base_tmp=\\$pmix_pdl_${pmix_pdl_winner}_ADD_LDFLAGS\"\n               for pmix_pdl_base_token in $pmix_pdl_base_tmp; do\n                   case $pmix_pdl_base_token in\n                   -L*)\n                       pmix_pdl_base_dir=`echo $pmix_pdl_base_token | cut -c3-`\n                       export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$pmix_pdl_base_dir\n                       AC_MSG_WARN([Adding to LD_LIBRARY_PATH: $pmix_pdl_base_dir])\n                       ;;\n                   esac\n               done])\n        PMIX_VAR_SCOPE_POP\n    ])\n\n    AC_DEFINE_UNQUOTED([PMIX_HAVE_PDL_SUPPORT], [$PMIX_HAVE_PDL_SUPPORT],\n                       [Whether the PMIX PDL framework is functional or not])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdl.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2020      Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * @file\n *\n * Dynamic library framework\n *\n * General Description:\n *\n * This framework provides portable access to dlopen- and dlsym-like\n * functionality, very similar to Libtool's libltdl.  Indeed, one of\n * the components in this framework will use libltdl, if it is\n * present/available.  However, on some common types systems where\n * libltdl headers and libraries are *not* available, we can support\n * plugins via this simple framework.\n *\n * This is a compile-time framework: a single component will be\n * selected by the priority that its configure.m4 provides.  All other\n * components will be ignored (i.e., not built/not part of the\n * installation).  Meaning: the static_components of the pdl framework\n * will always contain 0 or 1 components.\n *\n * SIDENOTE: PMIX used to embed libltdl.  However, as of early\n * 2015, this became problematic, for a variety of complex and\n * uninteresting reasons (see the following if you care about the\n * details: https://github.com/open-mpi/ompi/issues/311,\n * http://debbugs.gnu.org/cgi/bugreport.cgi?bug=19370,\n * https://github.com/open-mpi/ompi/pull/366,\n * https://github.com/open-mpi/ompi/pull/390).  That being said, we,\n * as a developer community, still wanted to be able to natively use\n * DSOs by default.  A small/simple framework for PDL functionality,\n * along with a simple component that supports dlopen/dlsym on POSIX\n * platforms and another component that natively uses libltdl seemed\n * like a good solution.\n */\n\n#ifndef PMIX_MCA_PDL_PDL_H\n#define PMIX_MCA_PDL_PDL_H\n\n#include \"src/include/pmix_config.h\"\n\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n\nBEGIN_C_DECLS\n\n/**\n * Handle for an opened file\n */\nstruct pmix_pdl_handle_t;\ntypedef struct pmix_pdl_handle_t pmix_pdl_handle_t;\n\n/**\n * Dynamically open the file specified.\n *\n * Arguments:\n *   fname   = Base filename to open.  If NULL, open this process.\n *   use_ext = If true, try various filename suffixes that are\n *       relevant on this platform (e.g., .so, .dll, .dylib).  If\n *       false, just use exactly whatever was passed as fname.\n *   private = If true, open the file in a private namespace.\n *       Otherwise, open the file in a global namespace.\n *   handle = Upon successful open, a handle to the opened file will\n *       be returned.\n *   err_msg= if non-NULL and !=PMIX_SUCCESS is returned, will point to a\n *       string error message\n *\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n * Space for the handle must be allocated by the module (it can be\n * freed during the call to pmix_pdl_base_module_dlclose_fn_t).\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to pmix_pdl API calls.\n */\ntypedef int (*pmix_pdl_base_module_open_fn_t)\n    (const char *fname, bool use_ext, bool private_namespace,\n     pmix_pdl_handle_t **handle, char **err_msg);\n\n/**\n * Lookup a symbol in an opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file\n *   symbol = name of the symbol to lookup\n *   ptr    = if found, a pointer to the symbol.  Otherwise, NULL.\n *   err_msg= if non-NULL and !=PMIX_SUCCESS is returned, will point to a\n *            string error message\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to pmix_pdl API calls.\n */\ntypedef int (*pmix_pdl_base_module_lookup_fn_t)\n    (pmix_pdl_handle_t *handle, const char *symbol, void **ptr, char **err_msg);\n\n/**\n * Dynamically close a previously dynamically-opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file.\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n * This function should close the file and free and resources\n * associated with it (e.g., whatever is cached on the handle).\n */\ntypedef int (*pmix_pdl_base_module_close_fn_t)\n    (pmix_pdl_handle_t *handle);\n\n/**\n * Search through a path of directories, invoking a callback on each\n * unique regular (non-Libtool) file basename found (e.g., will only\n * be invoked once for the files \"foo.la\" and \"foo.so\", with the\n * parameter \"foo\").\n *\n * Arguments:\n *   path   = PMIX_ENV_SEP-delimited list of directories\n *   cb_func= function to invoke on each filename found\n *   data   = context for callback function\n * Returns:\n *   PMIX_SUCESS on success, PMIX_ERR* otherwise\n */\ntypedef int (*pmix_pdl_base_module_foreachfile_fn_t)\n    (const char *search_path,\n     int (*cb_func)(const char *filename, void *context),\n     void *context);\n\n/**\n * Structure for PDL components.\n */\nstruct pmix_pdl_base_component_1_0_0_t {\n    /** MCA base component */\n    pmix_mca_base_component_t base_version;\n    /** MCA base data */\n    pmix_mca_base_component_data_t base_data;\n\n    /** Default priority */\n    int priority;\n};\ntypedef struct pmix_pdl_base_component_1_0_0_t pmix_pdl_base_component_1_0_0_t;\ntypedef struct pmix_pdl_base_component_1_0_0_t pmix_pdl_base_component_t;\n\n/**\n * Structure for PDL modules\n */\nstruct pmix_pdl_base_module_1_0_0_t {\n    pmix_mca_base_module_2_0_0_t            super;\n\n    /** Open / close */\n    pmix_pdl_base_module_open_fn_t           open;\n    pmix_pdl_base_module_close_fn_t          close;\n\n    /** Lookup a symbol */\n    pmix_pdl_base_module_lookup_fn_t         lookup;\n\n    /** Iterate looking for files */\n    pmix_pdl_base_module_foreachfile_fn_t    foreachfile;\n};\ntypedef struct pmix_pdl_base_module_1_0_0_t pmix_pdl_base_module_1_0_0_t;\ntypedef struct pmix_pdl_base_module_1_0_0_t pmix_pdl_base_module_t;\n\n/**\n * Macro for use in components that are of type PDL\n */\n#define PMIX_PDL_BASE_VERSION_1_0_0              \\\n    PMIX_MCA_BASE_VERSION_1_0_0(\"pdl\", 1, 0, 0)\n\nEND_C_DECLS\n\n#endif /* PMIX_MCA_PDL_PDL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/plibltdl/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2009-2015 Cisco Systems, Inc.  All rights reserved.\n#\n# Copyright (c) 2017      Intel, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nAC_DEFUN([MCA_pmix_pdl_plibltdl_PRIORITY], [50])\n\n#\n# Force this component to compile in static-only mode\n#\nAC_DEFUN([MCA_pmix_pdl_plibltdl_COMPILE_MODE], [\n    AC_MSG_CHECKING([for MCA component $1:$2 compile mode])\n    $3=\"static\"\n    AC_MSG_RESULT([$$3])\n])\n\n# MCA_pmix_pdl_plibltdl_POST_CONFIG()\n# ---------------------------------\nAC_DEFUN([MCA_pmix_pdl_plibltdl_POST_CONFIG],[\n    # If we won, then do all the rest of the setup\n    AS_IF([test \"$1\" = \"1\"],\n          [\n           # Add some stuff to CPPFLAGS so that the rest of the source\n           # tree can be built\n           LDFLAGS=\"$LDFLAGS $pmix_pdl_plibltdl_ADD_LDFLAGS\"\n           LIBS=\"$LIBS $pmix_pdl_plibltdl_ADD_LIBS\"\n          ])\n])dnl\n\n# MCA_dl_plibltdl_CONFIG([action-if-can-compile],\n#                       [action-if-cant-compile])\n# ------------------------------------------------\nAC_DEFUN([MCA_pmix_pdl_plibltdl_CONFIG],[\n    PMIX_VAR_SCOPE_PUSH([CPPFLAGS_save LDFLAGS_save LIBS_save])\n    AC_CONFIG_FILES([src/mca/pdl/plibltdl/Makefile])\n\n    # Add --with options\n    AC_ARG_WITH([plibltdl],\n        [AC_HELP_STRING([--with-libltdl(=DIR)],\n             [Build libltdl support, optionally adding DIR/include, DIR/lib, and DIR/lib64 to the search path for headers and libraries])])\n    AC_ARG_WITH([libltdl-libdir],\n       [AC_HELP_STRING([--with-libltdl-libdir=DIR],\n             [Search for libltdl libraries in DIR])])\n\n    # Sanity check the --with values\n    PMIX_CHECK_WITHDIR([plibltdl], [$with_libltdl],\n                       [include/ltdl.h])\n    PMIX_CHECK_WITHDIR([plibltdl-libdir], [$with_libltdl_libdir],\n                       [libltdl.*])\n\n    # Defaults\n    pmix_check_plibltdl_dir_msg=\"compiler default\"\n    pmix_check_plibltdl_libdir_msg=\"linker default\"\n\n    # Save directory names if supplied\n    AS_IF([test ! -z \"$with_libltdl\" && test \"$with_libltdl\" != \"yes\"],\n          [pmix_check_plibltdl_dir=$with_libltdl\n           pmix_check_plibltdl_dir_msg=\"$pmix_check_plibltdl_dir (from --with-libltdl)\"])\n    AS_IF([test ! -z \"$with_libltdl_libdir\" && test \"$with_libltdl_libdir\" != \"yes\"],\n          [pmix_check_plibltdl_libdir=$with_libltdl_libdir\n           pmix_check_plibltdl_libdir_msg=\"$pmix_check_plibltdl_libdir (from --with-libltdl-libdir)\"])\n\n    pmix_pdl_plibltdl_happy=no\n    AS_IF([test \"$with_plibltdl\" != \"no\"],\n          [AC_MSG_CHECKING([for libltdl dir])\n           AC_MSG_RESULT([$pmix_check_plibltdl_dir_msg])\n           AC_MSG_CHECKING([for libltdl library dir])\n           AC_MSG_RESULT([$pmix_check_plibltdl_libdir_msg])\n\n           PMIX_CHECK_PACKAGE([pmix_pdl_plibltdl],\n                  [ltdl.h],\n                  [ltdl],\n                  [lt_dlopen],\n                  [],\n                  [$pmix_check_plibltdl_dir],\n                  [$pmix_check_plibltdl_libdir],\n                  [pmix_pdl_plibltdl_happy=yes],\n                  [pmix_pdl_plibltdl_happy=no])\n              ])\n\n    # If we have plibltdl, do we have lt_dladvise?\n    pmix_pdl_plibltdl_have_lt_dladvise=0\n    AS_IF([test \"$pmix_pdl_plibltdl_happy\" = \"yes\"],\n          [CPPFLAGS_save=$CPPFLAGS\n           LDFLAGS_save=$LDFLAGS\n           LIBS_save=$LIBS\n\n           CPPFLAGS=\"$pmix_pdl_plibltdl_CPPFLAGS $CPPFLAGS\"\n           LDFLAGS=\"$pmix_pdl_plibltdl_LDFLAGS $LDFLAGS\"\n           LIBS=\"$pmix_pdl_plibltdl_LIBS $LIBS\"\n           AC_CHECK_FUNC([lt_dladvise_init],\n                         [pmix_pdl_plibltdl_have_lt_dladvise=1])\n           CPPFLAGS=$CPPFLAGS_save\n           LDFLAGS=$LDFLAGS_save\n           LIBS=$LIBS_save\n          ])\n    AC_DEFINE_UNQUOTED(PMIX_PDL_PLIBLTDL_HAVE_LT_DLADVISE,\n        [$pmix_pdl_plibltdl_have_lt_dladvise],\n        [Whether we have lt_dladvise or not])\n\n    AS_IF([test \"$pmix_pdl_plibltdl_happy\" = \"yes\"],\n          [pmix_pdl_plibltdl_ADD_CPPFLAGS=$pmix_pdl_plibltdl_CPPFLAGS\n           pmix_pdl_plibltdl_ADD_LDFLAGS=$pmix_pdl_plibltdl_LDFLAGS\n           pmix_pdl_plibltdl_ADD_LIBS=$pmix_pdl_plibltdl_LIBS\n           $1],\n          [AS_IF([test ! -z \"$with_libltdl\" && \\\n                  test \"$with_libltdl\" != \"no\"],\n                 [AC_MSG_WARN([libltdl support requested (via --with-libltdl) but not found.])\n                  AC_MSG_ERROR([Cannot continue.])])\n           $2])\n\n    AC_SUBST(pmix_pdl_plibltdl_CPPFLAGS)\n    AC_SUBST(pmix_pdl_plibltdl_LDFLAGS)\n    AC_SUBST(pmix_pdl_plibltdl_LIBS)\n\n    PMIX_VAR_SCOPE_POP\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/plibltdl/pdl_libltdl_module.c": "/*\n * Copyright (c) 2015      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2017-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"pmix_config.h\"\n\n#include \"pmix/constants.h\"\n#include \"pmix/mca/pdl/pdl.h\"\n\n#include \"pdl_libltdl.h\"\n\n\nstatic int plibltpdl_open(const char *fname, bool use_ext, bool private_namespace,\n                          pmix_pdl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    lt_dlhandle local_handle;\n\n#if PMIX_DL_LIBLTDL_HAVE_LT_DLADVISE\n    pmix_pdl_plibltpdl_component_t *c = &mca_pdl_plibltpdl_component;\n\n    if (use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_ext);\n    } else if (use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_ext);\n    } else if (!use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_noext);\n    } else if (!use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_noext);\n    }\n#else\n    if (use_ext) {\n        local_handle = lt_dlopenext(fname);\n    } else {\n        local_handle = lt_dlopen(fname);\n    }\n#endif\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(pmix_pdl_handle_t));\n        (*handle)->ltpdl_handle = local_handle;\n\n#if PMIX_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int plibltpdl_lookup(pmix_pdl_handle_t *handle, const char *symbol,\n                            void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->ltpdl_handle);\n    assert(symbol);\n    assert(ptr);\n\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    *ptr = lt_dlsym(handle->ltpdl_handle, symbol);\n    if (NULL != *ptr) {\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int plibltpdl_close(pmix_pdl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = lt_dlclose(handle->ltpdl_handle);\n\n#if PMIX_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\nstatic int plibltpdl_foreachfile(const char *search_path,\n                                 int (*func)(const char *filename, void *data),\n                                 void *data)\n{\n    assert(search_path);\n    assert(func);\n\n    int ret = lt_dlforeachfile(search_path, func, data);\n    return (0 == ret) ? PMIX_SUCCESS : PMIX_ERROR;\n}\n\n\n/*\n * Module definition\n */\npmix_pdl_base_module_t pmix_pdl_plibltpdl_module = {\n    .open = plibltpdl_open,\n    .lookup = plibltpdl_lookup,\n    .close = plibltpdl_close,\n    .foreachfile = plibltpdl_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdlopen/configure.m4": "# -*- shell-script -*-\n#\n# Copyright (c) 2009-2015 Cisco Systems, Inc.  All rights reserved.\n# Copyright (c) 2016      Research Organization for Information Science\n#                         and Technology (RIST). All rights reserved.\n#\n# Copyright (c) 2017      Intel, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nAC_DEFUN([MCA_pmix_pdl_pdlopen_PRIORITY], [80])\n\n#\n# Force this component to compile in static-only mode\n#\nAC_DEFUN([MCA_pmix_pdl_pdlopen_COMPILE_MODE], [\n    AC_MSG_CHECKING([for MCA component $1:$2 compile mode])\n    $3=\"static\"\n    AC_MSG_RESULT([$$3])\n])\n\n# MCA_pmix_pdl_pdlopen_POST_CONFIG()\n# ---------------------------------\nAC_DEFUN([MCA_pmix_pdl_pdlopen_POST_CONFIG],[\n    # If we won, then do all the rest of the setup\n    AS_IF([test \"$1\" = \"1\"],\n          [\n           # Add some stuff to CPPFLAGS so that the rest of the source\n           # tree can be built\n           LDFLAGS=\"$LDFLAGS $pmix_pdl_pdlopen_ADD_LDFLAGS\"\n           LIBS=\"$LIBS $pmix_pdl_pdlopen_ADD_LIBS\"\n          ])\n])dnl\n\n# MCA_pdl_pdlopen_CONFIG([action-if-can-compile],\n#                      [action-if-cant-compile])\n# ------------------------------------------------\nAC_DEFUN([MCA_pmix_pdl_pdlopen_CONFIG],[\n    AC_CONFIG_FILES([src/mca/pdl/pdlopen/Makefile])\n\n    dnl This is effectively a back-door for PMIX developers to\n    dnl force the use of the libltdl pdl component.\n    AC_ARG_ENABLE([dl-dlopen],\n        [AS_HELP_STRING([--disable-dl-dlopen],\n                        [Disable the \"dlopen\" PDL component (and probably force the use of the \"libltdl\" PDL component).])\n        ])\n\n    pmix_pdl_pdlopen_happy=no\n    AS_IF([test \"$enable_dl_dlopen\" != \"no\"],\n          [PMIX_CHECK_PACKAGE([pmix_pdl_pdlopen],\n              [dlfcn.h],\n              [dl],\n              [dlopen],\n              [],\n              [],\n              [],\n              [pmix_pdl_pdlopen_happy=yes],\n              [pmix_pdl_pdlopen_happy=no])\n          ])\n\n    AS_IF([test \"$pmix_pdl_pdlopen_happy\" = \"yes\"],\n          [pmix_pdl_pdlopen_ADD_LIBS=$pmix_pdl_pdlopen_LIBS\n           $1],\n          [$2])\n\n    AC_SUBST(pmix_pdl_pdlopen_LIBS)\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdlopen/pdl_pdlopen_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"src/include/pmix_config.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"include/pmix_common.h\"\n#include \"src/mca/pdl/pdl.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/error.h\"\n\n#include \"pdl_pdlopen.h\"\n\n\n/*\n * Trivial helper function to avoid replicating code\n */\nstatic void do_pdlopen(const char *fname, int flags,\n                      void **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = dlopen(fname, flags);\n\n    if (NULL != err_msg) {\n        if (NULL != *handle) {\n            *err_msg = NULL;\n        } else {\n            *err_msg = dlerror();\n        }\n    }\n}\n\n\nstatic int pdlopen_open(const char *fname, bool use_ext, bool private_namespace,\n                       pmix_pdl_handle_t **handle, char **err_msg)\n{\n    int rc;\n\n    assert(handle);\n\n    *handle = NULL;\n\n    /* Setup the dlopen flags */\n    int flags = RTLD_LAZY;\n    if (private_namespace) {\n        flags |= RTLD_LOCAL;\n    } else {\n        flags |= RTLD_GLOBAL;\n    }\n\n    /* If the caller wants to use filename extensions, loop through\n       them */\n    void *local_handle = NULL;\n    if (use_ext && NULL != fname) {\n        int i;\n        char *ext;\n\n        for (i = 0, ext = mca_pdl_pdlopen_component.filename_suffixes[i];\n             NULL != ext;\n             ext = mca_pdl_pdlopen_component.filename_suffixes[++i]) {\n            char *name;\n\n            rc = asprintf(&name, \"%s%s\", fname, ext);\n            if (0 > rc) {\n                return PMIX_ERR_NOMEM;\n            }\n            if (NULL == name) {\n                return PMIX_ERR_IN_ERRNO;\n            }\n\n            /* Does the file exist? */\n            struct stat buf;\n            /* coverity[toctou] */\n            if (stat(name, &buf) < 0) {\n                if (NULL != err_msg) {\n                    rc = asprintf(err_msg, \"File %s not found\", name);\n                    if (0 > rc) {\n                        free(name);\n                        return PMIX_ERR_NOMEM;\n                    }\n                }\n                free(name);\n                continue;\n            }\n\n            /* Yes, the file exists -- try to dlopen it.  If we can't\n               dlopen it, bail. */\n            do_pdlopen(name, flags, &local_handle, err_msg);\n            free(name);\n            break;\n        }\n    }\n\n    /* Otherwise, the caller does not want to use filename extensions,\n       so just use the single filename that the caller provided */\n    else {\n        do_pdlopen(fname, flags, &local_handle, err_msg);\n    }\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(pmix_pdl_handle_t));\n        (*handle)->dlopen_handle = local_handle;\n\n#if PMIX_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n    }\n    return (NULL != local_handle) ? PMIX_SUCCESS : PMIX_ERROR;\n}\n\n\nstatic int pdlopen_lookup(pmix_pdl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->dlopen_handle);\n    assert(symbol);\n    assert(ptr);\n\n    *ptr = dlsym(handle->dlopen_handle, symbol);\n    if (NULL != *ptr) {\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = dlerror();\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int pdlopen_close(pmix_pdl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = dlclose(handle->dlopen_handle);\n\n#if PMIX_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\n/*\n * Scan all the files in a directory (or path) and invoke a callback\n * on each one.\n */\nstatic int pdlopen_foreachfile(const char *search_path,\n                              int (*func)(const char *filename, void *data),\n                              void *data)\n{\n    int ret;\n    DIR *dp = NULL;\n    char **dirs = NULL;\n    char **good_files = NULL;\n\n    dirs = pmix_argv_split(search_path, PMIX_ENV_SEP);\n    for (int i = 0; NULL != dirs && NULL != dirs[i]; ++i) {\n\n        dp = opendir(dirs[i]);\n        if (NULL == dp) {\n            ret = PMIX_ERR_IN_ERRNO;\n            goto error;\n        }\n\n        struct dirent *de;\n        while (NULL != (de = readdir(dp))) {\n\n            /* Make the absolute path name */\n            char *abs_name = NULL;\n            ret = asprintf(&abs_name, \"%s/%s\", dirs[i], de->d_name);\n            if (0 > ret) {\n                goto error;\n            }\n            if (NULL == abs_name) {\n                ret = PMIX_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Stat the file */\n            struct stat buf;\n            /* coverity[toctou] */\n            if (stat(abs_name, &buf) < 0) {\n                free(abs_name);\n                ret = PMIX_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Skip if not a file */\n            if (!S_ISREG(buf.st_mode)) {\n                free(abs_name);\n                continue;\n            }\n\n            /* Find the suffix */\n            char *ptr = strrchr(abs_name, '.');\n            if (NULL != ptr) {\n\n                /* Skip libtool files */\n                if (strcmp(ptr, \".la\") == 0 ||\n                    strcmp(ptr, \".lo\") == 0) {\n                    free (abs_name);\n                    continue;\n                }\n\n                *ptr = '\\0';\n            }\n\n            /* Have we already found this file?  Or already found a\n               file with the same basename (but different suffix)? */\n            bool found = false;\n            for (int j = 0; NULL != good_files &&\n                     NULL != good_files[j]; ++j) {\n                if (strcmp(good_files[j], abs_name) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                pmix_argv_append_nosize(&good_files, abs_name);\n            }\n            free(abs_name);\n        }\n        closedir(dp);\n    }\n    dp = NULL;\n\n    /* Invoke the callback on all the found files */\n    if (NULL != good_files) {\n        for (int i = 0; NULL != good_files[i]; ++i) {\n            ret = func(good_files[i], data);\n            if (PMIX_SUCCESS != ret) {\n                goto error;\n            }\n        }\n    }\n\n    ret = PMIX_SUCCESS;\n\n error:\n    if (NULL != dp) {\n        closedir(dp);\n    }\n    if (NULL != dirs) {\n        pmix_argv_free(dirs);\n    }\n    if (NULL != good_files) {\n        pmix_argv_free(good_files);\n    }\n\n    return ret;\n}\n\n\n/*\n * Module definition\n */\npmix_pdl_base_module_t pmix_pdl_pdlopen_module = {\n    .open = pdlopen_open,\n    .lookup = pdlopen_lookup,\n    .close = pdlopen_close,\n    .foreachfile = pdlopen_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdlopen/pdl_pdlopen.h": "/*\n * Copyright (c) 2015     Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#ifndef PMIX_PDL_PDLOPEN\n#define PMIX_PDL_PDLOPEN\n\n#include \"src/include/pmix_config.h\"\n\n#include \"src/mca/pdl/pdl.h\"\n\nextern pmix_pdl_base_module_t pmix_pdl_pdlopen_module;\n\n/*\n * Dynamic library handles generated by this component.\n *\n * If we're debugging, keep a copy of the name of the file we've opened.\n */\nstruct pmix_pdl_handle_t {\n    void *dlopen_handle;\n#if PMIX_ENABLE_DEBUG\n    void *filename;\n#endif\n};\n\ntypedef struct {\n    pmix_pdl_base_component_t base;\n\n    char *filename_suffixes_mca_storage;\n    char **filename_suffixes;\n} pmix_pdl_pdlopen_component_t;\n\nextern pmix_pdl_pdlopen_component_t mca_pdl_pdlopen_component;\n\n#endif /* PMIX_PDL_PDLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdlopen/Makefile.am": "#\n# Copyright (c) 2004-2010 The Trustees of Indiana University.\n#                         All rights reserved.\n# Copyright (c) 2014-2015 Cisco Systems, Inc.  All rights reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nsources = \\\n        pdl_pdlopen.h \\\n        pdl_pdlopen_component.c \\\n        pdl_pdlopen_module.c\n\n# This component will only ever be built statically -- never as a DSO.\n\nnoinst_LTLIBRARIES = libmca_pdl_pdlopen.la\n\nlibmca_pdl_pdlopen_la_SOURCES = $(sources)\nlibmca_pdl_pdlopen_la_LDFLAGS = -module -avoid-version\nlibmca_pdl_pdlopen_la_LIBADD = $(pmix_pdl_pdlopen_LIBS)\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/mca/pdl/pdlopen/pdl_pdlopen_component.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2020      Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"src/include/pmix_config.h\"\n\n#include \"include/pmix_common.h\"\n#include \"src/mca/pdl/pdl.h\"\n#include \"src/util/argv.h\"\n\n#include \"pdl_pdlopen.h\"\n\n\n/*\n * Public string showing the sysinfo ompi_linux component version number\n */\nconst char *pmix_pdl_pdlopen_component_version_string =\n    \"PMIX pdl pdlopen MCA component version \" PMIX_VERSION;\n\n\n/*\n * Local functions\n */\nstatic int pdlopen_component_register(void);\nstatic int pdlopen_component_open(void);\nstatic int pdlopen_component_close(void);\nstatic int pdlopen_component_query(pmix_mca_base_module_t **module, int *priority);\n\n/*\n * Instantiate the public struct with all of our public information\n * and pointers to our public functions in it\n */\n\npmix_pdl_pdlopen_component_t mca_pdl_pdlopen_component = {\n\n    /* Fill in the mca_pdl_base_component_t */\n    .base = {\n\n        /* First, the mca_component_t struct containing meta information\n           about the component itself */\n        .base_version = {\n            PMIX_PDL_BASE_VERSION_1_0_0,\n\n            /* Component name and version */\n            .pmix_mca_component_name = \"pdlopen\",\n            PMIX_MCA_BASE_MAKE_VERSION(component, PMIX_MAJOR_VERSION, PMIX_MINOR_VERSION,\n                                       PMIX_RELEASE_VERSION),\n\n            /* Component functions */\n            .pmix_mca_register_component_params = pdlopen_component_register,\n            .pmix_mca_open_component = pdlopen_component_open,\n            .pmix_mca_close_component = pdlopen_component_close,\n            .pmix_mca_query_component = pdlopen_component_query,\n        },\n\n        .base_data = {\n            /* The component is checkpoint ready */\n            PMIX_MCA_BASE_METADATA_PARAM_CHECKPOINT\n        },\n\n        /* The pdl framework members */\n        .priority = 80\n    },\n};\n\n\nstatic int pdlopen_component_register(void)\n{\n    int ret;\n\n    mca_pdl_pdlopen_component.filename_suffixes_mca_storage = \".so,.dylib,.dll,.sl\";\n    ret =\n        pmix_mca_base_component_var_register(&mca_pdl_pdlopen_component.base.base_version,\n                                             \"filename_suffixes\",\n                                             \"Comma-delimited list of filename suffixes that the pdlopen component will try\",\n                                             PMIX_MCA_BASE_VAR_TYPE_STRING,\n                                             NULL,\n                                             0,\n                                             PMIX_MCA_BASE_VAR_FLAG_SETTABLE,\n                                             PMIX_INFO_LVL_5,\n                                             PMIX_MCA_BASE_VAR_SCOPE_LOCAL,\n                                             &mca_pdl_pdlopen_component.filename_suffixes_mca_storage);\n    if (ret < 0) {\n        return ret;\n    }\n    mca_pdl_pdlopen_component.filename_suffixes =\n        pmix_argv_split(mca_pdl_pdlopen_component.filename_suffixes_mca_storage,\n                        ',');\n\n    return PMIX_SUCCESS;\n}\n\nstatic int pdlopen_component_open(void)\n{\n    return PMIX_SUCCESS;\n}\n\n\nstatic int pdlopen_component_close(void)\n{\n    if (NULL != mca_pdl_pdlopen_component.filename_suffixes) {\n        pmix_argv_free(mca_pdl_pdlopen_component.filename_suffixes);\n        mca_pdl_pdlopen_component.filename_suffixes = NULL;\n    }\n\n    return PMIX_SUCCESS;\n}\n\n\nstatic int pdlopen_component_query(pmix_mca_base_module_t **module, int *priority)\n{\n    /* The priority value is somewhat meaningless here; by\n       pmix/mca/pdl/configure.m4, there's at most one component\n       available. */\n    *priority = mca_pdl_pdlopen_component.base.priority;\n    *module = &pmix_pdl_pdlopen_module.super;\n\n    return PMIX_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/src/tools/pmix_info/support.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2004-2010 The Trustees of Indiana University and Indiana\n *                         University Research and Technology\n *                         Corporation.  All rights reserved.\n * Copyright (c) 2004-2011 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n * Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,\n *                         University of Stuttgart.  All rights reserved.\n * Copyright (c) 2004-2005 The Regents of the University of California.\n *                         All rights reserved.\n * Copyright (c) 2006-2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2010-2016 Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2011-2012 University of Houston. All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2017      IBM Corporation.  All rights reserved.\n * Copyright (c) 2017      Research Organization for Information Science\n *                         and Technology (RIST). All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"pmix_config.h\"\n\n#include <string.h>\n#include <ctype.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#include \"src/class/pmix_list.h\"\n#include \"src/class/pmix_pointer_array.h\"\n#include \"src/runtime/pmix_rte.h\"\n#include \"src/util/output.h\"\n#include \"src/util/cmd_line.h\"\n#include \"src/util/error.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/show_help.h\"\n\n#include \"src/include/frameworks.h\"\n#include \"src/include/pmix_portable_platform.h\"\n\n#include \"src/mca/pinstalldirs/pinstalldirs.h\"\n#include \"pinfo.h\"\n#include \"support.h\"\n#include \"src/mca/base/pmix_mca_base_component_repository.h\"\n\nconst char *pmix_info_path_prefix = \"prefix\";\nconst char *pmix_info_path_bindir = \"bindir\";\nconst char *pmix_info_path_libdir = \"libdir\";\nconst char *pmix_info_path_incdir = \"incdir\";\nconst char *pmix_info_path_mandir = \"mandir\";\nconst char *pmix_info_path_pkglibdir = \"pkglibdir\";\nconst char *pmix_info_path_sysconfdir = \"sysconfdir\";\nconst char *pmix_info_path_exec_prefix = \"exec_prefix\";\nconst char *pmix_info_path_sbindir = \"sbindir\";\nconst char *pmix_info_path_libexecdir = \"libexecdir\";\nconst char *pmix_info_path_datarootdir = \"datarootdir\";\nconst char *pmix_info_path_datadir = \"datadir\";\nconst char *pmix_info_path_sharedstatedir = \"sharedstatedir\";\nconst char *pmix_info_path_localstatedir = \"localstatedir\";\nconst char *pmix_info_path_infodir = \"infodir\";\nconst char *pmix_info_path_pkgdatadir = \"pkgdatadir\";\nconst char *pmix_info_path_pkgincludedir = \"pkgincludedir\";\n\nbool pmix_info_pretty = true;\npmix_mca_base_register_flag_t pmix_info_register_flags = PMIX_MCA_BASE_REGISTER_ALL;\n\nconst char *pmix_info_type_all = \"all\";\nconst char *pmix_info_type_pmix = \"pmix\";\nconst char *pmix_info_component_all = \"all\";\nconst char *pmix_info_param_all = \"all\";\n\nconst char *pmix_info_ver_full = \"full\";\nconst char *pmix_info_ver_major = \"major\";\nconst char *pmix_info_ver_minor = \"minor\";\nconst char *pmix_info_ver_release = \"release\";\nconst char *pmix_info_ver_greek = \"greek\";\nconst char *pmix_info_ver_repo = \"repo\";\n\nconst char *pmix_info_ver_all = \"all\";\nconst char *pmix_info_ver_mca = \"mca\";\nconst char *pmix_info_ver_type = \"type\";\nconst char *pmix_info_ver_component = \"component\";\n\nstatic int pmix_info_registered = 0;\n\nstatic void component_map_construct(pmix_info_component_map_t *map)\n{\n    map->type = NULL;\n}\nstatic void component_map_destruct(pmix_info_component_map_t *map)\n{\n    if (NULL != map->type) {\n        free(map->type);\n    }\n    /* the type close functions will release the\n     * list of components\n     */\n}\nPMIX_CLASS_INSTANCE(pmix_info_component_map_t,\n                    pmix_list_item_t,\n                    component_map_construct,\n                    component_map_destruct);\n\nstatic void pmix_info_show_failed_component(const pmix_mca_base_component_repository_item_t* ri,\n                                            const char *error_msg);\n\nint pmix_info_init(int argc, char **argv,\n                   pmix_cmd_line_t *pmix_info_cmd_line)\n{\n    int ret;\n    bool want_help = false;\n    bool cmd_error = false;\n    char **app_env = NULL, **global_env = NULL;\n\n    /* add the cmd line options */\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 'V', NULL, \"version\", 0,\n                            \"Show version of Open MPI\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"param\", 2,\n                            \"Show MCA parameters.  The first parameter is the framework (or the keyword \\\"all\\\"); the second parameter is the specific component name (or the keyword \\\"all\\\").\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"params\", 2,\n                            \"Synonym for --param\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"internal\", 0,\n                            \"Show internal MCA parameters (not meant to be modified by users)\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"path\", 1,\n                            \"Show paths that Open MPI was configured with.  Accepts the following parameters: prefix, bindir, libdir, incdir, mandir, pkglibdir, sysconfdir, all\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"arch\", 0,\n                            \"Show architecture Open MPI was compiled on\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 'c', NULL, \"config\", 0,\n                            \"Show configuration options\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 't', NULL, \"type\", 1,\n                            \"Show internal MCA parameters with the type specified in parameter.\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 'h', NULL, \"help\", 0,\n                            \"Show this help message\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"pretty-print\", 0,\n                            \"When used in conjunction with other parameters, the output is displayed in 'pretty-print' format (default)\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"parsable\", 0,\n                            \"When used in conjunction with other parameters, the output is displayed in a machine-parsable format\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"parseable\", 0,\n                            \"Synonym for --parsable\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"hostname\", 0,\n                            \"Show the hostname that Open MPI was configured and built on\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 'a', NULL, \"all\", 0,\n                            \"Show all configuration options and MCA parameters\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 'l', NULL, \"level\", 1,\n                            \"Show only variables with at most this level (1-9)\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, 's', NULL, \"selected-only\", 0,\n                            \"Show only variables from selected components\");\n    pmix_cmd_line_make_opt3(pmix_info_cmd_line, '\\0', NULL, \"show-failed\", 0,\n                            \"Show the components that failed to load along with the reason why they failed.\");\n\n    if( PMIX_SUCCESS != pmix_mca_base_open() ) {\n        pmix_show_help(\"help-pinfo.txt\", \"lib-call-fail\", true, \"mca_base_open\", __FILE__, __LINE__ );\n        PMIX_RELEASE(pmix_info_cmd_line);\n        exit(1);\n    }\n    pmix_mca_base_cmd_line_setup(pmix_info_cmd_line);\n\n    /* Do the parsing */\n\n    ret = pmix_cmd_line_parse(pmix_info_cmd_line, false, false, argc, argv);\n    if (PMIX_SUCCESS != ret) {\n        if (PMIX_ERR_SILENT != ret) {\n            fprintf(stderr, \"%s: command line error (%s)\\n\", argv[0],\n                    PMIx_Error_string(ret));\n        }\n        cmd_error = true;\n    }\n    if (!cmd_error &&\n        (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"help\") ||\n         pmix_cmd_line_is_taken(pmix_info_cmd_line, \"h\"))) {\n        char *str, *usage;\n\n        want_help = true;\n        usage = pmix_cmd_line_get_usage_msg(pmix_info_cmd_line);\n        str = pmix_show_help_string(\"help-pmix-info.txt\", \"usage\", true,\n                                    usage);\n        if (NULL != str) {\n            printf(\"%s\", str);\n            free(str);\n        }\n        free(usage);\n    }\n\n\n    /* If we had a cmd line parse error, or we showed the help\n       message, it's time to exit. */\n    if (cmd_error || want_help) {\n        pmix_mca_base_close();\n        PMIX_RELEASE(pmix_info_cmd_line);\n        exit(cmd_error ? 1 : 0);\n    }\n\n    pmix_mca_base_cmd_line_process_args(pmix_info_cmd_line, &app_env, &global_env);\n\n\n    /* set the flags */\n    if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"pretty-print\")) {\n        pmix_info_pretty = true;\n    } else if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"parsable\") || pmix_cmd_line_is_taken(pmix_info_cmd_line, \"parseable\")) {\n        pmix_info_pretty = false;\n    }\n\n    if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"selected-only\")) {\n        /* register only selected components */\n        pmix_info_register_flags = PMIX_MCA_BASE_REGISTER_DEFAULT;\n    }\n\n    if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"show-failed\")) {\n        pmix_mca_base_component_track_load_errors = true;\n    }\n\n    return PMIX_SUCCESS;\n}\n\nvoid pmix_info_finalize(void)\n{\n    pmix_mca_base_close();\n}\n\nstatic int info_register_framework (pmix_mca_base_framework_t *framework, pmix_pointer_array_t *component_map)\n{\n    pmix_info_component_map_t *map;\n    int rc;\n    rc = pmix_mca_base_framework_register(framework, pmix_info_register_flags);\n    if (PMIX_SUCCESS != rc && PMIX_ERR_BAD_PARAM != rc) {\n        return rc;\n    }\n\n    if (NULL != component_map) {\n        map = PMIX_NEW(pmix_info_component_map_t);\n        map->type = strdup(framework->framework_name);\n        map->components = &framework->framework_components;\n        map->failed_components = &framework->framework_failed_components;\n        pmix_pointer_array_add(component_map, map);\n    }\n\n    return rc;\n}\n\nint pmix_info_register_project_frameworks (const char *project_name, pmix_mca_base_framework_t **frameworks,\n                                           pmix_pointer_array_t *component_map)\n{\n    int i, rc=PMIX_SUCCESS;\n\n    for (i=0; NULL != frameworks[i]; i++) {\n        if (PMIX_SUCCESS != (rc = info_register_framework(frameworks[i], component_map))) {\n            if (PMIX_ERR_BAD_PARAM == rc) {\n                fprintf(stderr, \"\\nA \\\"bad parameter\\\" error was encountered when opening the %s %s framework\\n\",\n                        project_name, frameworks[i]->framework_name);\n                fprintf(stderr, \"The output received from that framework includes the following parameters:\\n\\n\");\n            } else if (PMIX_ERR_NOT_AVAILABLE != rc) {\n                fprintf(stderr, \"%s_info_register: %s failed\\n\", project_name, frameworks[i]->framework_name);\n                rc = PMIX_ERROR;\n            } else {\n                continue;\n            }\n\n            break;\n        }\n    }\n\n    return rc;\n}\n\nvoid pmix_info_register_types(pmix_pointer_array_t *mca_types)\n{\n    int i;\n\n    /* add the top-level types */\n    pmix_pointer_array_add(mca_types, \"mca\");\n    pmix_pointer_array_add(mca_types, \"pmix\");\n\n    /* push all the types found by autogen */\n    for (i=0; NULL != pmix_frameworks[i]; i++) {\n        pmix_pointer_array_add(mca_types, pmix_frameworks[i]->framework_name);\n    }\n}\n\nint pmix_info_register_framework_params(pmix_pointer_array_t *component_map)\n{\n    int rc;\n\n    if (pmix_info_registered++) {\n        return PMIX_SUCCESS;\n    }\n\n    /* Register mca/base parameters */\n    if( PMIX_SUCCESS != pmix_mca_base_open() ) {\n        pmix_show_help(\"help-pmix_info.txt\", \"lib-call-fail\", true, \"mca_base_open\", __FILE__, __LINE__ );\n        return PMIX_ERROR;\n    }\n\n    /* Register the PMIX layer's MCA parameters */\n    if (PMIX_SUCCESS != (rc = pmix_register_params())) {\n        fprintf(stderr, \"pmix_info_register: pmix_register_params failed\\n\");\n        return rc;\n    }\n\n    return pmix_info_register_project_frameworks(\"pmix\", pmix_frameworks, component_map);\n}\n\n\nvoid pmix_info_close_components(void)\n{\n    int i;\n\n    assert(pmix_info_registered);\n    if (--pmix_info_registered) {\n        return;\n    }\n\n    for (i=0; NULL != pmix_frameworks[i]; i++) {\n        (void) pmix_mca_base_framework_close(pmix_frameworks[i]);\n    }\n\n    /* release our reference to MCA */\n    pmix_mca_base_close ();\n}\n\n\nvoid pmix_info_show_path(const char *type, const char *value)\n{\n    char *pretty, *path;\n\n    pretty = strdup(type);\n    pretty[0] = toupper(pretty[0]);\n\n    if (0 > asprintf(&path, \"path:%s\", type)) {\n        free(pretty);\n        return;\n    }\n    pmix_info_out(pretty, path, value);\n    free(pretty);\n    free(path);\n}\n\nvoid pmix_info_do_path(bool want_all, pmix_cmd_line_t *cmd_line)\n{\n    int i, count;\n    char *scope;\n\n    /* Check bozo case */\n    count = pmix_cmd_line_get_ninsts(cmd_line, \"path\");\n    for (i = 0; i < count; ++i) {\n        scope = pmix_cmd_line_get_param(cmd_line, \"path\", i, 0);\n        if (0 == strcmp(\"all\", scope)) {\n            want_all = true;\n            break;\n        }\n    }\n\n    if (want_all) {\n        pmix_info_show_path(pmix_info_path_prefix, pmix_pinstall_dirs.prefix);\n        pmix_info_show_path(pmix_info_path_exec_prefix, pmix_pinstall_dirs.exec_prefix);\n        pmix_info_show_path(pmix_info_path_bindir, pmix_pinstall_dirs.bindir);\n        pmix_info_show_path(pmix_info_path_sbindir, pmix_pinstall_dirs.sbindir);\n        pmix_info_show_path(pmix_info_path_libdir, pmix_pinstall_dirs.libdir);\n        pmix_info_show_path(pmix_info_path_incdir, pmix_pinstall_dirs.includedir);\n        pmix_info_show_path(pmix_info_path_mandir, pmix_pinstall_dirs.mandir);\n        pmix_info_show_path(pmix_info_path_pkglibdir, pmix_pinstall_dirs.pmixlibdir);\n        pmix_info_show_path(pmix_info_path_libexecdir, pmix_pinstall_dirs.libexecdir);\n        pmix_info_show_path(pmix_info_path_datarootdir, pmix_pinstall_dirs.datarootdir);\n        pmix_info_show_path(pmix_info_path_datadir, pmix_pinstall_dirs.datadir);\n        pmix_info_show_path(pmix_info_path_sysconfdir, pmix_pinstall_dirs.sysconfdir);\n        pmix_info_show_path(pmix_info_path_sharedstatedir, pmix_pinstall_dirs.sharedstatedir);\n        pmix_info_show_path(pmix_info_path_localstatedir, pmix_pinstall_dirs.localstatedir);\n        pmix_info_show_path(pmix_info_path_infodir, pmix_pinstall_dirs.infodir);\n        pmix_info_show_path(pmix_info_path_pkgdatadir, pmix_pinstall_dirs.pmixdatadir);\n        pmix_info_show_path(pmix_info_path_pkglibdir, pmix_pinstall_dirs.pmixlibdir);\n        pmix_info_show_path(pmix_info_path_pkgincludedir, pmix_pinstall_dirs.pmixincludedir);\n    } else {\n        count = pmix_cmd_line_get_ninsts(cmd_line, \"path\");\n        for (i = 0; i < count; ++i) {\n            scope = pmix_cmd_line_get_param(cmd_line, \"path\", i, 0);\n\n            if (0 == strcmp(pmix_info_path_prefix, scope)) {\n                pmix_info_show_path(pmix_info_path_prefix, pmix_pinstall_dirs.prefix);\n            } else if (0 == strcmp(pmix_info_path_bindir, scope)) {\n                pmix_info_show_path(pmix_info_path_bindir, pmix_pinstall_dirs.bindir);\n            } else if (0 == strcmp(pmix_info_path_libdir, scope)) {\n                pmix_info_show_path(pmix_info_path_libdir, pmix_pinstall_dirs.libdir);\n            } else if (0 == strcmp(pmix_info_path_incdir, scope)) {\n                pmix_info_show_path(pmix_info_path_incdir, pmix_pinstall_dirs.includedir);\n            } else if (0 == strcmp(pmix_info_path_mandir, scope)) {\n                pmix_info_show_path(pmix_info_path_mandir, pmix_pinstall_dirs.mandir);\n            } else if (0 == strcmp(pmix_info_path_pkglibdir, scope)) {\n                pmix_info_show_path(pmix_info_path_pkglibdir, pmix_pinstall_dirs.pmixlibdir);\n            } else if (0 == strcmp(pmix_info_path_sysconfdir, scope)) {\n                pmix_info_show_path(pmix_info_path_sysconfdir, pmix_pinstall_dirs.sysconfdir);\n            } else if (0 == strcmp(pmix_info_path_exec_prefix, scope)) {\n                pmix_info_show_path(pmix_info_path_exec_prefix, pmix_pinstall_dirs.exec_prefix);\n            } else if (0 == strcmp(pmix_info_path_sbindir, scope)) {\n                pmix_info_show_path(pmix_info_path_sbindir, pmix_pinstall_dirs.sbindir);\n            } else if (0 == strcmp(pmix_info_path_libexecdir, scope)) {\n                pmix_info_show_path(pmix_info_path_libexecdir, pmix_pinstall_dirs.libexecdir);\n            } else if (0 == strcmp(pmix_info_path_datarootdir, scope)) {\n                pmix_info_show_path(pmix_info_path_datarootdir, pmix_pinstall_dirs.datarootdir);\n            } else if (0 == strcmp(pmix_info_path_datadir, scope)) {\n                pmix_info_show_path(pmix_info_path_datadir, pmix_pinstall_dirs.datadir);\n            } else if (0 == strcmp(pmix_info_path_sharedstatedir, scope)) {\n                pmix_info_show_path(pmix_info_path_sharedstatedir, pmix_pinstall_dirs.sharedstatedir);\n            } else if (0 == strcmp(pmix_info_path_localstatedir, scope)) {\n                pmix_info_show_path(pmix_info_path_localstatedir, pmix_pinstall_dirs.localstatedir);\n            } else if (0 == strcmp(pmix_info_path_infodir, scope)) {\n                pmix_info_show_path(pmix_info_path_infodir, pmix_pinstall_dirs.infodir);\n            } else if (0 == strcmp(pmix_info_path_pkgdatadir, scope)) {\n                pmix_info_show_path(pmix_info_path_pkgdatadir, pmix_pinstall_dirs.pmixdatadir);\n            } else if (0 == strcmp(pmix_info_path_pkgincludedir, scope)) {\n                pmix_info_show_path(pmix_info_path_pkgincludedir, pmix_pinstall_dirs.pmixincludedir);\n            } else {\n                char *usage = pmix_cmd_line_get_usage_msg(cmd_line);\n                pmix_show_help(\"help-pmix_info.txt\", \"usage\", true, usage);\n                free(usage);\n                exit(1);\n            }\n        }\n    }\n}\n\nvoid pmix_info_do_params(bool want_all_in, bool want_internal,\n                         pmix_pointer_array_t *mca_types,\n                         pmix_pointer_array_t *component_map,\n                         pmix_cmd_line_t *pmix_info_cmd_line)\n{\n    pmix_mca_base_var_info_lvl_t max_level = PMIX_INFO_LVL_1;\n    int count;\n    char *type, *component, *str;\n    bool found;\n    int i;\n    bool want_all = false;\n    char *p;\n\n    if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"param\")) {\n        p = \"param\";\n    } else if (pmix_cmd_line_is_taken(pmix_info_cmd_line, \"params\")) {\n        p = \"params\";\n    } else {\n        p = \"foo\";  /* should never happen, but protect against segfault */\n    }\n\n    if (NULL != (str = pmix_cmd_line_get_param (pmix_info_cmd_line, \"level\", 0, 0))) {\n        char *tmp;\n\n        errno = 0;\n        max_level = strtol (str, &tmp, 10) + PMIX_INFO_LVL_1 - 1;\n        if (0 != errno || '\\0' != tmp[0] || max_level < PMIX_INFO_LVL_1 || max_level > PMIX_INFO_LVL_9) {\n            char *usage = pmix_cmd_line_get_usage_msg(pmix_info_cmd_line);\n            pmix_show_help(\"help-pmix_info.txt\", \"invalid-level\", true, str);\n            free(usage);\n            exit(1);\n        }\n    } else if (want_all_in) {\n        /* if not specified default to level 9 if all components are requested */\n        max_level = PMIX_INFO_LVL_9;\n    }\n\n    if (want_all_in) {\n        want_all = true;\n    } else {\n        /* See if the special param \"all\" was given to --param; that\n         * supercedes any individual type\n         */\n        count = pmix_cmd_line_get_ninsts(pmix_info_cmd_line, p);\n        for (i = 0; i < count; ++i) {\n            type = pmix_cmd_line_get_param(pmix_info_cmd_line, p, (int)i, 0);\n            if (0 == strcmp(pmix_info_type_all, type)) {\n                want_all = true;\n                break;\n            }\n        }\n    }\n\n    /* Show the params */\n\n    if (want_all) {\n        pmix_info_show_component_version(mca_types, component_map, pmix_info_type_all,\n                                         pmix_info_component_all, pmix_info_ver_full,\n                                         pmix_info_ver_all);\n        for (i = 0; i < mca_types->size; ++i) {\n            if (NULL == (type = (char *)pmix_pointer_array_get_item(mca_types, i))) {\n                continue;\n            }\n            pmix_info_show_mca_params(type, pmix_info_component_all, max_level, want_internal);\n        }\n    } else {\n        for (i = 0; i < count; ++i) {\n            type = pmix_cmd_line_get_param(pmix_info_cmd_line, p, (int)i, 0);\n            component = pmix_cmd_line_get_param(pmix_info_cmd_line, p, (int)i, 1);\n\n            for (found = false, i = 0; i < mca_types->size; ++i) {\n                if (NULL == (str = (char *)pmix_pointer_array_get_item(mca_types, i))) {\n                    continue;\n                }\n                if (0 == strcmp(str, type)) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                char *usage = pmix_cmd_line_get_usage_msg(pmix_info_cmd_line);\n                pmix_show_help(\"help-pmix_info.txt\", \"not-found\", true, type);\n                free(usage);\n                exit(1);\n            }\n\n            pmix_info_show_component_version(mca_types, component_map, type,\n                                             component, pmix_info_ver_full,\n                                             pmix_info_ver_all);\n            pmix_info_show_mca_params(type, component, max_level, want_internal);\n        }\n    }\n}\n\nvoid pmix_info_err_params(pmix_pointer_array_t *component_map)\n{\n    pmix_info_component_map_t *map=NULL, *mptr;\n    int i;\n\n    /* all we want to do is display the LAST entry in the\n     * component_map array as this is the one that generated the error\n     */\n    for (i=0; i < component_map->size; i++) {\n        if (NULL == (mptr = (pmix_info_component_map_t*)pmix_pointer_array_get_item(component_map, i))) {\n            continue;\n        }\n        map = mptr;\n    }\n    if (NULL == map) {\n        fprintf(stderr, \"pmix_info_err_params: map not found\\n\");\n        return;\n    }\n    pmix_info_show_mca_params(map->type, pmix_info_component_all, PMIX_INFO_LVL_9, true);\n    fprintf(stderr, \"\\n\");\n    return;\n}\n\nvoid pmix_info_do_type(pmix_cmd_line_t *pmix_info_cmd_line)\n{\n    pmix_mca_base_var_info_lvl_t max_level = PMIX_INFO_LVL_1;\n    int count;\n    char *type, *str;\n    int i, j, k, len, ret;\n    char *p;\n    const pmix_mca_base_var_t *var;\n    char** strings, *message;\n    const pmix_mca_base_var_group_t *group;\n    p = \"type\";\n\n    if (NULL != (str = pmix_cmd_line_get_param (pmix_info_cmd_line, \"level\", 0, 0))) {\n        char *tmp;\n\n        errno = 0;\n        max_level = strtol (str, &tmp, 10) + PMIX_INFO_LVL_1 - 1;\n        if (0 != errno || '\\0' != tmp[0] || max_level < PMIX_INFO_LVL_1 || max_level > PMIX_INFO_LVL_9) {\n            char *usage = pmix_cmd_line_get_usage_msg(pmix_info_cmd_line);\n            pmix_show_help(\"help-pmix_info.txt\", \"invalid-level\", true, str);\n            free(usage);\n            exit(1);\n        }\n    }\n\n    count = pmix_cmd_line_get_ninsts(pmix_info_cmd_line, p);\n    len = pmix_mca_base_var_get_count ();\n\n    for (k = 0; k < count; ++k) {\n        type = pmix_cmd_line_get_param(pmix_info_cmd_line, p, k, 0);\n        for (i = 0; i < len; ++i) {\n            ret = pmix_mca_base_var_get (i, &var);\n            if (PMIX_SUCCESS != ret) {\n                continue;\n            }\n            if (0 == strcmp(type, pmix_var_type_names[var->mbv_type]) && (var->mbv_info_lvl <= max_level)) {\n                ret = pmix_mca_base_var_dump(var->mbv_index, &strings, !pmix_info_pretty ? PMIX_MCA_BASE_VAR_DUMP_PARSABLE : PMIX_MCA_BASE_VAR_DUMP_READABLE);\n                if (PMIX_SUCCESS != ret) {\n                    continue;\n                }\n                (void) pmix_mca_base_var_group_get(var->mbv_group_index, &group);\n                for (j = 0 ; strings[j] ; ++j) {\n                    if (0 == j && pmix_info_pretty) {\n                        if (0 > asprintf (&message, \"MCA %s\", group->group_framework)) {\n                            continue;\n                        }\n                        pmix_info_out(message, message, strings[j]);\n                        free(message);\n                    } else {\n                        pmix_info_out(\"\", \"\", strings[j]);\n                    }\n                    free(strings[j]);\n                }\n                free(strings);\n            }\n        }\n    }\n}\n\nstatic void pmix_info_show_mca_group_params(const pmix_mca_base_var_group_t *group, pmix_mca_base_var_info_lvl_t max_level, bool want_internal)\n{\n    const int *variables, *groups;\n    const char *group_component;\n    const pmix_mca_base_var_t *var;\n    char **strings, *message;\n    bool requested = true;\n    int ret, i, j, count;\n\n    variables = PMIX_VALUE_ARRAY_GET_BASE(&group->group_vars, const int);\n    count = pmix_value_array_get_size((pmix_value_array_t *)&group->group_vars);\n\n    /* the default component name is \"base\". depending on how the\n     * group was registered the group may or not have this set.  */\n    group_component = group->group_component ? group->group_component : \"base\";\n\n    /* check if this group may be disabled due to a selection variable */\n    if (0 != strcmp (group_component, \"base\")) {\n        int var_id;\n\n        /* read the selection parameter */\n        var_id = pmix_mca_base_var_find (group->group_project, group->group_framework, NULL, NULL);\n        if (0 <= var_id) {\n            const pmix_mca_base_var_storage_t *value=NULL;\n            char **requested_components;\n            bool include_mode;\n\n            pmix_mca_base_var_get_value (var_id, &value, NULL, NULL);\n            if (NULL != value && NULL != value->stringval && '\\0' != value->stringval[0]) {\n                pmix_mca_base_component_parse_requested (value->stringval, &include_mode, &requested_components);\n\n                for (i = 0, requested = !include_mode ; requested_components[i] ; ++i) {\n                    if (0 == strcmp (requested_components[i], group_component)) {\n                        requested = include_mode;\n                        break;\n                    }\n                }\n\n                pmix_argv_free (requested_components);\n            }\n        }\n    }\n\n    const pmix_mca_base_var_group_t *curr_group = NULL;\n    char *component_msg = NULL;\n    if (0 > asprintf(&component_msg, \" %s\", group_component)) {\n        return;\n    }\n\n    for (i = 0 ; i < count ; ++i) {\n        ret = pmix_mca_base_var_get(variables[i], &var);\n        if (PMIX_SUCCESS != ret || ((var->mbv_flags & PMIX_MCA_BASE_VAR_FLAG_INTERNAL) &&\n                                    !want_internal) ||\n            max_level < var->mbv_info_lvl) {\n            continue;\n        }\n\n        if (pmix_info_pretty && curr_group != group) {\n            if (0 > asprintf(&message, \"MCA%s %s%s\", requested ? \"\" : \" (-)\",\n                             group->group_framework,\n                             component_msg ? component_msg : \"\")) {\n                continue;\n            }\n            pmix_info_out(message, message, \"---------------------------------------------------\");\n            free(message);\n            curr_group = group;\n        }\n\n        ret = pmix_mca_base_var_dump(variables[i], &strings, !pmix_info_pretty ? PMIX_MCA_BASE_VAR_DUMP_PARSABLE : PMIX_MCA_BASE_VAR_DUMP_READABLE);\n        if (PMIX_SUCCESS != ret) {\n            continue;\n        }\n\n        for (j = 0 ; strings[j] ; ++j) {\n            if (0 == j && pmix_info_pretty) {\n                if (0 > asprintf (&message, \"MCA%s %s%s\", requested ? \"\" : \" (-)\",\n                                  group->group_framework,\n                                  component_msg ? component_msg : \"\")) {\n                    continue;\n                }\n                pmix_info_out(message, message, strings[j]);\n                free(message);\n            } else {\n                pmix_info_out(\"\", \"\", strings[j]);\n            }\n            free(strings[j]);\n        }\n        if (!pmix_info_pretty) {\n            /* generate an entry indicating whether this variable is disabled or not. if the\n             * format in mca_base_var/pvar.c changes this needs to be changed as well */\n            if (0 > asprintf (&message, \"mca:%s:%s:param:%s:disabled:%s\", group->group_framework,\n                              group_component, var->mbv_full_name, requested ? \"false\" : \"true\")) {\n                continue;\n            }\n            pmix_info_out(\"\", \"\", message);\n            free (message);\n        }\n        free(strings);\n    }\n\n    groups = PMIX_VALUE_ARRAY_GET_BASE(&group->group_subgroups, const int);\n    count = pmix_value_array_get_size((pmix_value_array_t *)&group->group_subgroups);\n\n    for (i = 0 ; i < count ; ++i) {\n        ret = pmix_mca_base_var_group_get(groups[i], &group);\n        if (PMIX_SUCCESS != ret) {\n            continue;\n        }\n        pmix_info_show_mca_group_params(group, max_level, want_internal);\n    }\n    free(component_msg);\n}\n\nvoid pmix_info_show_mca_params(const char *type, const char *component,\n                               pmix_mca_base_var_info_lvl_t max_level, bool want_internal)\n{\n    const pmix_mca_base_var_group_t *group;\n    int ret;\n\n    if (0 == strcmp (component, \"all\")) {\n        ret = pmix_mca_base_var_group_find(\"*\", type, NULL);\n        if (0 > ret) {\n            return;\n        }\n\n        (void) pmix_mca_base_var_group_get(ret, &group);\n\n        pmix_info_show_mca_group_params(group, max_level, want_internal);\n    } else {\n        ret = pmix_mca_base_var_group_find(\"*\", type, component);\n        if (0 > ret) {\n            return;\n        }\n\n        (void) pmix_mca_base_var_group_get(ret, &group);\n        pmix_info_show_mca_group_params(group, max_level, want_internal);\n    }\n}\n\n\n\nvoid pmix_info_do_arch()\n{\n    pmix_info_out(\"Configured architecture\", \"config:arch\", PMIX_ARCH);\n}\n\n\nvoid pmix_info_do_hostname()\n{\n    pmix_info_out(\"Configure host\", \"config:host\", PMIX_CONFIGURE_HOST);\n}\n\n\nstatic char *escape_quotes(const char *value)\n{\n    const char *src;\n    int num_quotes = 0;\n    for (src = value; src != NULL && *src != '\\0'; ++src) {\n        if ('\"' == *src) {\n            ++num_quotes;\n        }\n    }\n\n    // If there are no quotes in the string, there's nothing to do\n    if (0 == num_quotes) {\n        return NULL;\n    }\n\n    // If we have quotes, make a new string.  Copy over the old\n    // string, escaping the quotes along the way.  This is simple and\n    // clear to read; it's not particularly efficient (performance is\n    // definitely not important here).\n    char *quoted_value;\n    quoted_value = calloc(1, strlen(value) + num_quotes + 1);\n    if (NULL == quoted_value) {\n        return NULL;\n    }\n\n    char *dest;\n    for (src = value, dest = quoted_value; *src != '\\0'; ++src, ++dest) {\n        if ('\"' == *src) {\n            *dest++ = '\\\\';\n        }\n        *dest = *src;\n    }\n\n    return quoted_value;\n}\n\n\n/*\n * Private variables - set some reasonable screen size defaults\n */\n\nstatic int centerpoint = 24;\nstatic int screen_width = 78;\n\n/*\n * Prints the passed message in a pretty or parsable format.\n */\nvoid pmix_info_out(const char *pretty_message, const char *plain_message, const char *value)\n{\n    size_t len, max_value_width, value_offset;\n    char *spaces = NULL;\n    char *filler = NULL;\n    char *pos, *v, savev, *v_to_free;\n\n#ifdef HAVE_ISATTY\n    /* If we have isatty(), if this is not a tty, then disable\n     * wrapping for grep-friendly behavior\n     */\n    if (0 == isatty(STDOUT_FILENO)) {\n        screen_width = INT_MAX;\n    }\n#endif\n\n#ifdef TIOCGWINSZ\n    if (screen_width < INT_MAX) {\n        struct winsize size;\n        if (ioctl(STDOUT_FILENO, TIOCGWINSZ, (char*) &size) >= 0) {\n            screen_width = size.ws_col;\n        }\n    }\n#endif\n\n    /* Sanity check (allow NULL to mean \"\") */\n    if (NULL == value) {\n        value = \"\";\n    }\n\n    /* Strip leading and trailing whitespace from the string value */\n    value_offset = strspn(value, \" \");\n\n    v = v_to_free = strdup(value + value_offset);\n    len = strlen(v);\n\n    if (len > 0) {\n        while (len > 0 && isspace(v[len-1])) len--;\n        v[len] = '\\0';\n    }\n\n    if (pmix_info_pretty && NULL != pretty_message) {\n        if (centerpoint > (int)strlen(pretty_message)) {\n            if (0 > asprintf(&spaces, \"%*s\", centerpoint -\n                             (int)strlen(pretty_message), \" \")) {\n                if (NULL != v_to_free) {\n                    free(v_to_free);\n                }\n                return;\n            }\n        } else {\n            spaces = strdup(\"\");\n#if PMIX_ENABLE_DEBUG\n            if (centerpoint < (int)strlen(pretty_message)) {\n                pmix_show_help(\"help-pmix_info.txt\",\n                               \"developer warning: field too long\", false,\n                               pretty_message, centerpoint);\n            }\n#endif\n        }\n        max_value_width = screen_width - strlen(spaces) - strlen(pretty_message) - 2;\n        if (0 < strlen(pretty_message)) {\n            if (0 > asprintf(&filler, \"%s%s: \", spaces, pretty_message)) {\n                if (NULL != v_to_free) {\n                    free(v_to_free);\n                }\n                return;\n            }\n        } else {\n            if (0 > asprintf(&filler, \"%s  \", spaces)) {\n                if (NULL != v_to_free) {\n                    free(v_to_free);\n                }\n                return;\n            }\n        }\n        free(spaces);\n        spaces = NULL;\n\n        while (true) {\n            if (strlen(v) < max_value_width) {\n                printf(\"%s%s\\n\", filler, v);\n                break;\n            } else {\n                if (0 > asprintf(&spaces, \"%*s\", centerpoint + 2, \" \")) {\n                    if (NULL != v_to_free) {\n                        free(v_to_free);\n                    }\n                    return;\n                }\n\n                /* Work backwards to find the first space before\n                 * max_value_width\n                 */\n                savev = v[max_value_width];\n                v[max_value_width] = '\\0';\n                pos = (char*)strrchr(v, (int)' ');\n                v[max_value_width] = savev;\n                if (NULL == pos) {\n                    /* No space found < max_value_width.  Look for the first\n                     * space after max_value_width.\n                     */\n                    pos = strchr(&v[max_value_width], ' ');\n\n                    if (NULL == pos) {\n\n                        /* There's just no spaces.  So just print it and be done. */\n\n                        printf(\"%s%s\\n\", filler, v);\n                        break;\n                    } else {\n                        *pos = '\\0';\n                        printf(\"%s%s\\n\", filler, v);\n                        v = pos + 1;\n                    }\n                } else {\n                    *pos = '\\0';\n                    printf(\"%s%s\\n\", filler, v);\n                    v = pos + 1;\n                }\n\n                /* Reset for the next iteration */\n                free(filler);\n                filler = strdup(spaces);\n                free(spaces);\n                spaces = NULL;\n            }\n        }\n        if (NULL != filler) {\n            free(filler);\n        }\n        if (NULL != spaces) {\n            free(spaces);\n        }\n    } else {\n        if (NULL != plain_message && 0 < strlen(plain_message)) {\n            // Escape any double quotes in the value.\n            char *quoted_value;\n            quoted_value = escape_quotes(value);\n            if (NULL != quoted_value) {\n                value = quoted_value;\n            }\n\n            char *colon = strchr(value, ':');\n            if (NULL != colon) {\n                printf(\"%s:\\\"%s\\\"\\n\", plain_message, value);\n            } else {\n                printf(\"%s:%s\\n\", plain_message, value);\n            }\n\n            if (NULL != quoted_value) {\n                free(quoted_value);\n            }\n        } else {\n            printf(\"%s\\n\", value);\n        }\n    }\n    if (NULL != v_to_free) {\n        free(v_to_free);\n    }\n}\n\n/*\n * Prints the passed integer in a pretty or parsable format.\n */\nvoid pmix_info_out_int(const char *pretty_message,\n                       const char *plain_message,\n                       int value)\n{\n    char *valstr;\n\n    if (0 > asprintf(&valstr, \"%d\", (int)value)) {\n        return;\n    }\n    pmix_info_out(pretty_message, plain_message, valstr);\n    free(valstr);\n}\n\n/*\n * Show all the components of a specific type/component combo (component may be\n * a wildcard)\n */\nvoid pmix_info_show_component_version(pmix_pointer_array_t *mca_types,\n                                      pmix_pointer_array_t *component_map,\n                                      const char *type_name,\n                                      const char *component_name,\n                                      const char *scope, const char *ver_type)\n{\n    bool want_all_components = false;\n    bool want_all_types = false;\n    bool found;\n    pmix_mca_base_component_list_item_t *cli;\n    pmix_mca_base_failed_component_t *cli_failed;\n    int j;\n    char *pos;\n    pmix_info_component_map_t *map;\n\n    /* see if all components wanted */\n    if (0 == strcmp(pmix_info_component_all, component_name)) {\n        want_all_components = true;\n    }\n\n    /* see if all types wanted */\n    if (0 != strcmp(pmix_info_type_all, type_name)) {\n        /* Check to see if the type is valid */\n\n        for (found = false, j = 0; j < mca_types->size; ++j) {\n            if (NULL == (pos = (char*)pmix_pointer_array_get_item(mca_types, j))) {\n                continue;\n            }\n            if (0 == strcmp(pos, type_name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            return;\n        }\n    } else {\n        want_all_types = true;\n    }\n\n    /* Now that we have a valid type, find the right components */\n    for (j=0; j < component_map->size; j++) {\n        if (NULL == (map = (pmix_info_component_map_t*)pmix_pointer_array_get_item(component_map, j))) {\n            continue;\n        }\n        if ((want_all_types || 0 == strcmp(type_name, map->type)) && map->components) {\n            /* found it! */\n            PMIX_LIST_FOREACH(cli, map->components, pmix_mca_base_component_list_item_t) {\n                const pmix_mca_base_component_t *component = cli->cli_component;\n                if (want_all_components ||\n                    0 == strcmp(component->pmix_mca_component_name, component_name)) {\n                    pmix_info_show_mca_version(component, scope, ver_type);\n                }\n            }\n\n            /* found it! */\n            PMIX_LIST_FOREACH(cli_failed, map->failed_components, pmix_mca_base_failed_component_t) {\n                pmix_mca_base_component_repository_item_t *ri = cli_failed->comp;\n                if (want_all_components ||\n                    0 == strcmp(component_name, ri->ri_name) ) {\n                    pmix_info_show_failed_component(ri, cli_failed->error_msg);\n                }\n            }\n\n            if (!want_all_types) {\n                break;\n            }\n        }\n    }\n}\n\n\nstatic void pmix_info_show_failed_component(const pmix_mca_base_component_repository_item_t* ri,\n                                            const char *error_msg)\n{\n    char *message, *content;\n\n    if (pmix_info_pretty) {\n        if (0 > asprintf(&message, \"MCA %s\", ri->ri_type)) {\n            return;\n        }\n        if (0 > asprintf(&content, \"%s (failed to load) %s\", ri->ri_name, error_msg)) {\n            free(message);\n            return;\n        }\n\n        pmix_info_out(message, NULL, content);\n\n        free(message);\n        free(content);\n    } else {\n        if (0 > asprintf(&message, \"mca:%s:%s:failed\", ri->ri_type, ri->ri_name)) {\n            return;\n        }\n        if (0 > asprintf(&content, \"%s\", error_msg)) {\n            free(message);\n            return;\n        }\n\n        pmix_info_out(NULL, message, content);\n\n        free(message);\n        free(content);\n    }\n}\n\n/*\n * Given a component, display its relevant version(s)\n */\nvoid pmix_info_show_mca_version(const pmix_mca_base_component_t* component,\n                                const char *scope, const char *ver_type)\n{\n    bool printed;\n    bool want_mca = false;\n    bool want_type = false;\n    bool want_component = false;\n    char *message = NULL, *content = NULL;\n    char *mca_version;\n    char *api_version;\n    char *component_version;\n    char *tmp;\n\n    if (0 == strcmp(ver_type, pmix_info_ver_all) ||\n        0 == strcmp(ver_type, pmix_info_ver_mca)) {\n        want_mca = true;\n    }\n\n    if (0 == strcmp(ver_type, pmix_info_ver_all) ||\n        0 == strcmp(ver_type, pmix_info_ver_type)) {\n        want_type = true;\n    }\n\n    if (0 == strcmp(ver_type, pmix_info_ver_all) ||\n        0 == strcmp(ver_type, pmix_info_ver_component)) {\n        want_component = true;\n    }\n\n    mca_version = pmix_info_make_version_str(scope, component->pmix_mca_major_version,\n                                             component->pmix_mca_minor_version,\n                                             component->pmix_mca_release_version, \"\",\n                                             \"\");\n    api_version = pmix_info_make_version_str(scope, component->pmix_mca_type_major_version,\n                                             component->pmix_mca_type_minor_version,\n                                             component->pmix_mca_type_release_version, \"\",\n                                             \"\");\n    component_version = pmix_info_make_version_str(scope, component->pmix_mca_component_major_version,\n                                                   component->pmix_mca_component_minor_version,\n                                                   component->pmix_mca_component_release_version,\n                                                   \"\", \"\");\n    if (pmix_info_pretty) {\n        if (0 > asprintf(&message, \"MCA %s\", component->pmix_mca_type_name)) {\n            goto exit;\n        }\n        printed = false;\n        if (0 > asprintf(&content, \"%s (\", component->pmix_mca_component_name)) {\n            goto exit;\n        }\n\n        if (want_mca) {\n            if (0 > asprintf(&tmp, \"%sMCA v%s\", content, mca_version)) {\n                goto exit;\n            }\n            content = tmp;\n            printed = true;\n        }\n\n        if (want_type) {\n            if (printed) {\n                if (0 > asprintf(&tmp, \"%s, \", content)) {\n                    goto exit;\n                }\n                free(content);\n                content = tmp;\n            }\n            if (0 > asprintf(&tmp, \"%sAPI v%s\", content, api_version)) {\n                goto exit;\n            }\n            free(content);\n            content = tmp;\n            printed = true;\n        }\n\n        if (want_component) {\n            if (printed) {\n                if (0 > asprintf(&tmp, \"%s, \", content)) {\n                    goto exit;\n                }\n                free(content);\n                content = tmp;\n            }\n            if (0 > asprintf(&tmp, \"%sComponent v%s\", content, component_version)) {\n                goto exit;\n            }\n            free(content);\n            content = tmp;\n            printed = true;\n        }\n        if (NULL != content) {\n            if (0 > asprintf(&tmp, \"%s)\", content)) {\n                goto exit;\n            }\n        } else {\n            tmp = NULL;\n        }\n\n        pmix_info_out(message, NULL, tmp);\n        if (NULL != tmp) {\n            free(tmp);\n        }\n\n    } else {\n        if (0 > asprintf(&message, \"mca:%s:%s:version\", component->pmix_mca_type_name, component->pmix_mca_component_name)) {\n            goto exit;\n        }\n        if (want_mca) {\n            if (0 > asprintf(&tmp, \"mca:%s\", mca_version)) {\n                goto exit;\n            }\n            pmix_info_out(NULL, message, tmp);\n            free(tmp);\n        }\n        if (want_type) {\n            if (0 > asprintf(&tmp, \"api:%s\", api_version)) {\n                goto exit;\n            }\n            pmix_info_out(NULL, message, tmp);\n            free(tmp);\n        }\n        if (want_component) {\n            if (0 > asprintf(&tmp, \"component:%s\", component_version)) {\n                goto exit;\n            }\n            pmix_info_out(NULL, message, tmp);\n            free(tmp);\n        }\n    }\n\nexit:\n    if (NULL != mca_version) {\n        free(mca_version);\n    }\n    if (NULL != api_version) {\n        free(api_version);\n    }\n    if (NULL != component_version) {\n        free(component_version);\n    }\n    if (NULL != message) {\n        free(message);\n    }\n    if (NULL != content) {\n        free(content);\n    }\n}\n\n\nchar *pmix_info_make_version_str(const char *scope,\n                                 int major, int minor, int release,\n                                 const char *greek,\n                                 const char *repo)\n{\n    char *str = NULL, *tmp;\n    char temp[BUFSIZ];\n\n    temp[BUFSIZ - 1] = '\\0';\n    if (0 == strcmp(scope, pmix_info_ver_full) ||\n        0 == strcmp(scope, pmix_info_ver_all)) {\n        snprintf(temp, BUFSIZ - 1, \"%d.%d.%d\", major, minor, release);\n        str = strdup(temp);\n        if (NULL != greek) {\n            if (0 > asprintf(&tmp, \"%s%s\", str, greek)) {\n                free(str);\n                return NULL;\n            }\n            free(str);\n            str = tmp;\n        }\n    } else if (0 == strcmp(scope, pmix_info_ver_major)) {\n        snprintf(temp, BUFSIZ - 1, \"%d\", major);\n    } else if (0 == strcmp(scope, pmix_info_ver_minor)) {\n        snprintf(temp, BUFSIZ - 1, \"%d\", minor);\n    } else if (0 == strcmp(scope, pmix_info_ver_release)) {\n        snprintf(temp, BUFSIZ - 1, \"%d\", release);\n    } else if (0 == strcmp(scope, pmix_info_ver_greek)) {\n        str = strdup(greek);\n    } else if (0 == strcmp(scope, pmix_info_ver_repo)) {\n        str = strdup(repo);\n    }\n\n    if (NULL == str) {\n        str = strdup(temp);\n    }\n\n    return str;\n}\n\nvoid pmix_info_show_pmix_version(const char *scope)\n{\n    char *tmp, *tmp2;\n\n    if (0 > asprintf(&tmp, \"%s:version:full\", pmix_info_type_pmix)) {\n        return;\n    }\n    tmp2 = pmix_info_make_version_str(scope,\n                                      PMIX_MAJOR_VERSION, PMIX_MINOR_VERSION,\n                                      PMIX_RELEASE_VERSION,\n                                      PMIX_GREEK_VERSION,\n                                      PMIX_REPO_REV);\n    pmix_info_out(\"PMIX\", tmp, tmp2);\n    free(tmp);\n    free(tmp2);\n    if (0 > asprintf(&tmp, \"%s:version:repo\", pmix_info_type_pmix)) {\n        return;\n    }\n    pmix_info_out(\"PMIX repo revision\", tmp, PMIX_REPO_REV);\n    free(tmp);\n    if (0 > asprintf(&tmp, \"%s:version:release_date\", pmix_info_type_pmix)) {\n        return;\n    }\n    pmix_info_out(\"PMIX release date\", tmp, PMIX_RELEASE_DATE);\n    free(tmp);\n}\n\n/*\n * do_config\n * Accepts:\n *  - want_all: boolean flag; TRUE -> display all options\n *                FALSE -> display selected options\n *\n * This function displays all the options with which the current\n * installation of pmix was configured. There are many options here\n * that are carried forward from OMPI-7 and are not mca parameters\n * in OMPI-10. I have to dig through the invalid options and replace\n * them with OMPI-10 options.\n */\nvoid pmix_info_do_config(bool want_all)\n{\n    char *debug;\n    char *have_dl;\n    char *symbol_visibility;\n    char *manpages;\n\n    /* setup the strings that don't require allocations*/\n    debug = PMIX_ENABLE_DEBUG ? \"yes\" : \"no\";\n    have_dl = PMIX_HAVE_PDL_SUPPORT ? \"yes\" : \"no\";\n    symbol_visibility = PMIX_HAVE_VISIBILITY ? \"yes\" : \"no\";\n    manpages = PMIX_ENABLE_MAN_PAGES ? \"yes\" : \"no\";\n\n    /* output values */\n    pmix_info_out(\"Configured by\", \"config:user\", PMIX_CONFIGURE_USER);\n    pmix_info_out(\"Configured on\", \"config:timestamp\", PMIX_CONFIGURE_DATE);\n    pmix_info_out(\"Configure host\", \"config:host\", PMIX_CONFIGURE_HOST);\n    pmix_info_out(\"Configure command line\", \"config:cli\", PMIX_CONFIGURE_CLI);\n\n    pmix_info_out(\"Built by\", \"build:user\", PMIX_BUILD_USER);\n    pmix_info_out(\"Built on\", \"build:timestamp\", PMIX_BUILD_DATE);\n    pmix_info_out(\"Built host\", \"build:host\", PMIX_BUILD_HOST);\n\n    pmix_info_out(\"C compiler\", \"compiler:c:command\", PMIX_CC);\n    pmix_info_out(\"C compiler absolute\", \"compiler:c:absolute\", PMIX_CC_ABSOLUTE);\n    pmix_info_out(\"C compiler family name\", \"compiler:c:familyname\", _STRINGIFY(PMIX_BUILD_PLATFORM_COMPILER_FAMILYNAME));\n    pmix_info_out(\"C compiler version\", \"compiler:c:version\", _STRINGIFY(PMIX_BUILD_PLATFORM_COMPILER_VERSION_STR));\n\n    if (want_all) {\n        pmix_info_out_int(\"C char size\", \"compiler:c:sizeof:char\", sizeof(char));\n        pmix_info_out_int(\"C bool size\", \"compiler:c:sizeof:bool\", sizeof(bool));\n        pmix_info_out_int(\"C short size\", \"compiler:c:sizeof:short\", sizeof(short));\n        pmix_info_out_int(\"C int size\", \"compiler:c:sizeof:int\", sizeof(int));\n        pmix_info_out_int(\"C long size\", \"compiler:c:sizeof:long\", sizeof(long));\n        pmix_info_out_int(\"C float size\", \"compiler:c:sizeof:float\", sizeof(float));\n        pmix_info_out_int(\"C double size\", \"compiler:c:sizeof:double\", sizeof(double));\n        pmix_info_out_int(\"C pointer size\", \"compiler:c:sizeof:pointer\", sizeof(void *));\n        pmix_info_out_int(\"C char align\", \"compiler:c:align:char\", PMIX_ALIGNMENT_CHAR);\n        pmix_info_out(\"C bool align\", \"compiler:c:align:bool\", \"skipped\");\n        pmix_info_out_int(\"C int align\", \"compiler:c:align:int\", PMIX_ALIGNMENT_INT);\n        pmix_info_out_int(\"C float align\", \"compiler:c:align:float\", PMIX_ALIGNMENT_FLOAT);\n        pmix_info_out_int(\"C double align\", \"compiler:c:align:double\", PMIX_ALIGNMENT_DOUBLE);\n    }\n\n    if (want_all) {\n        pmix_info_out(\"Build CFLAGS\", \"option:build:cflags\", PMIX_BUILD_CFLAGS);\n        pmix_info_out(\"Build LDFLAGS\", \"option:build:ldflags\", PMIX_BUILD_LDFLAGS);\n        pmix_info_out(\"Build LIBS\", \"option:build:libs\", PMIX_BUILD_LIBS);\n    }\n\n    pmix_info_out(\"Internal debug support\", \"option:debug\", debug);\n    pmix_info_out(\"dl support\", \"option:dlopen\", have_dl);\n    pmix_info_out(\"Symbol vis. support\", \"options:visibility\", symbol_visibility);\n    pmix_info_out(\"Manpages built\", \"options:man-pages\", manpages);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/.git/objects/pack/pack-c2f2d88a06258db65e32228ee5888dcf20908b8d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-uyo7w7rux7iouukx2rutfqkpfjmuvb24/spack-src/.git/objects/pack/pack-c2f2d88a06258db65e32228ee5888dcf20908b8d.idx"
    ],
    "total_files": 896
}