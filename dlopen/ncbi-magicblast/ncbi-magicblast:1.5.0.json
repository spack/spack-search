{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/corelib/ncbifile.cpp": "/*  $Id: ncbifile.cpp 567947 2018-07-26 18:36:24Z lavr $\n * ===========================================================================\n *\n *                            PUBLIC DOMAIN NOTICE\n *               National Center for Biotechnology Information\n *\n *  This software/database is a \"United States Government Work\" under the\n *  terms of the United States Copyright Act.  It was written as part of\n *  the author's official duties as a United States Government employee and\n *  thus cannot be copyrighted.  This software/database is freely available\n *  to the public for use. The National Library of Medicine and the U.S.\n *  Government have not placed any restriction on its use or reproduction.\n *\n *  Although all reasonable efforts have been taken to ensure the accuracy\n *  and reliability of the software and data, the NLM and the U.S.\n *  Government do not and cannot warrant the performance or results that\n *  may be obtained by using this software or data. The NLM and the U.S.\n *  Government disclaim all warranties, express or implied, including\n *  warranties of performance, merchantability or fitness for any particular\n *  purpose.\n *\n *  Please cite the author in any work or product based on this material.\n *\n * ===========================================================================\n *\n * Author:  Vladimir Ivanov\n *\n * File Description:   Files and directories accessory functions\n *\n */\n\n#include <ncbi_pch.hpp>\n#include <corelib/ncbifile.hpp>\n#include <corelib/ncbi_limits.h>\n#include <corelib/ncbi_limits.hpp>\n#include <corelib/ncbi_safe_static.hpp>\n#include <corelib/error_codes.hpp>\n#include <corelib/ncbierror.hpp>\n#include \"ncbisys.hpp\"\n\n#include <stdio.h>\n\n#if defined(NCBI_OS_MSWIN)\n#  include \"ncbi_os_mswin_p.hpp\"\n#  include <direct.h>\n#  include <io.h>\n#  include <fcntl.h> // for _O_* flags\n#  include <sys/utime.h>\n\n#elif defined(NCBI_OS_UNIX)\n#  include \"ncbi_os_unix_p.hpp\"\n#  include <corelib/impl/ncbi_panfs.h>\n#  include <dirent.h>\n#  include <fcntl.h>\n#  include <unistd.h>\n#  include <utime.h>\n#  include <sys/mman.h>\n#  include <sys/time.h>\n#  ifdef HAVE_SYS_STATVFS_H\n#    include <sys/statvfs.h>\n#  endif\n#  include <sys/param.h>\n#  ifdef HAVE_SYS_MOUNT_H\n#    include <sys/mount.h>\n#  endif\n#  ifdef HAVE_SYS_VFS_H\n#    include <sys/vfs.h>\n#  endif\n#  if !defined(MAP_FAILED)\n#    define MAP_FAILED ((void *)(-1L))\n#  endif\n#  include <sys/ioctl.h>\n\n#else\n#  error \"File API defined for MS Windows and UNIX platforms only\"\n\n#endif  /* NCBI_OS_MSWIN, NCBI_OS_UNIX */\n\n\n// Define platforms on which we support PANFS\n#if defined(NCBI_OS_UNIX)  &&  !defined(NCBI_OS_CYGWIN)\n#  define SUPPORT_PANFS\n#  include <sys/types.h>\n#  include <sys/wait.h>\n#endif\n\n\n#define NCBI_USE_ERRCODE_X   Corelib_File\n\n\nBEGIN_NCBI_SCOPE\n\n\n// Path separators\n\n#undef  DIR_SEPARATOR\n#undef  DIR_SEPARATOR_ALT\n#undef  DIR_SEPARATORS\n#undef  DISK_SEPARATOR\n#undef  ALL_SEPARATORS\n#undef  ALL_OS_SEPARATORS\n\n#define DIR_PARENT  \"..\"\n#define DIR_CURRENT \".\"\n#define ALL_OS_SEPARATORS   \":/\\\\\"\n\n#if defined(NCBI_OS_MSWIN)\n#  define DIR_SEPARATOR     '\\\\'\n#  define DIR_SEPARATOR_ALT '/'\n#  define DISK_SEPARATOR    ':'\n#  define DIR_SEPARATORS    \"/\\\\\"\n#  define ALL_SEPARATORS    \":/\\\\\"\n#elif defined(NCBI_OS_UNIX)\n#  define DIR_SEPARATOR     '/'\n#  define DIR_SEPARATORS    \"/\"\n#  define ALL_SEPARATORS    \"/\"\n#endif\n\n// Macro to check bits\n#define F_ISSET(flags, mask) ((flags & (mask)) == (mask))\n\n// Default buffer size, used to read/write files\nconst size_t kDefaultBufferSize = 64*1024;\n\n// List of files for CFileDeleteAtExit class\nstatic CSafeStatic< CFileDeleteList > s_DeleteAtExitFileList;\n\n\n// Declare the parameter to get directory for temporary files.\n// Registry file:\n//     [NCBI]\n//     TmpDir = ...\n// Environment variable:\n//     NCBI_CONFIG__NCBI__TmpDir\n//\nNCBI_PARAM_DECL(string, NCBI, TmpDir); \nNCBI_PARAM_DEF (string, NCBI, TmpDir, \"\");\n\n\n// Define how read-only files are treated on Windows.\n// Registry file:\n//     [NCBI]\n//     DeleteReadOnlyFiles = true/false\n// Environment variable:\n//     NCBI_CONFIG__DELETEREADONLYFILES\n//\nNCBI_PARAM_DECL(bool, NCBI, DeleteReadOnlyFiles);\nNCBI_PARAM_DEF_EX(bool, NCBI, DeleteReadOnlyFiles, false,\n    eParam_NoThread, NCBI_CONFIG__DELETEREADONLYFILES);\n\n\n// Declare how umask settings on Unix affect creating files/directories \n// in the File API.\n// Registry file:\n//     [NCBI]\n//     FileAPIHonorUmask = true/false\n// Environment variable:\n//     NCBI_CONFIG__FILEAPIHONORUMASK\n//\n// On WINDOWS: umask affect only CRT function, the part of API that\n// use Windows API directly just ignore umask setting.\n#define DEFAULT_HONOR_UMASK_VALUE false\n\nNCBI_PARAM_DECL(bool, NCBI, FileAPIHonorUmask);\nNCBI_PARAM_DEF_EX(bool, NCBI, FileAPIHonorUmask, DEFAULT_HONOR_UMASK_VALUE,\n    eParam_NoThread, NCBI_CONFIG__FILEAPIHONORUMASK);\n\n\n// Declare the parameter to turn on logging from CFile,\n// CDirEntry, etc. classes.\n// Registry file:\n//     [NCBI]\n//     FileAPILogging = true/false\n// Environment variable:\n//     NCBI_CONFIG__FILEAPILOGGING\n//\n#define DEFAULT_LOGGING_VALUE false\n\nNCBI_PARAM_DECL(bool, NCBI, FileAPILogging);\nNCBI_PARAM_DEF_EX(bool, NCBI, FileAPILogging, DEFAULT_LOGGING_VALUE,\n    eParam_NoThread, NCBI_CONFIG__FILEAPILOGGING);\n\n\n#define LOG_ERROR(subcode, log_message) \\\n    { \\\n        int saved_error = errno; \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message << \": \" << _T_STDSTRING(NcbiSys_strerror(saved_error))); \\\n        } \\\n        errno = saved_error; \\\n    }\n\n#define LOG_ERROR_AND_RETURN(subcode, log_message) \\\n    { \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n        return false; \\\n    }\n\n#define LOG_ERROR_AND_RETURN_NCBI(subcode, log_message, ncbierr) \\\n    { \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n        CNcbiError::Set(ncbierr, log_message); \\\n        return false; \\\n    }\n\n#define LOG_ERROR_AND_RETURN_WIN(subcode, log_message) \\\n    { \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n        CNcbiError::SetFromWindowsError(log_message); \\\n        return false; \\\n    }\n\n#define LOG_ERROR_AND_RETURN_ERRNO(subcode, log_message) \\\n    { \\\n        int saved_error = errno; \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message << \": \" << _T_STDSTRING(NcbiSys_strerror(saved_error))); \\\n        } \\\n        CNcbiError::SetErrno(saved_error, log_message); \\\n        errno = saved_error; \\\n        return false; \\\n    }\n    \n// Macro to silence GCC's __wur (warn unused result)\n#define _no_warning(expr)  while ( expr ) break\n    \n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CDirEntry\n//\n\nCDirEntry::CDirEntry(const string& name)\n{\n    Reset(name);\n    m_DefaultMode[eUser]    = m_DefaultModeGlobal[eFile][eUser];\n    m_DefaultMode[eGroup]   = m_DefaultModeGlobal[eFile][eGroup];\n    m_DefaultMode[eOther]   = m_DefaultModeGlobal[eFile][eOther];\n    m_DefaultMode[eSpecial] = m_DefaultModeGlobal[eFile][eSpecial];\n}\n\n\nCDirEntry::CDirEntry(const CDirEntry& other)\n    : m_Path(other.m_Path)\n{\n    m_DefaultMode[eUser]    = other.m_DefaultMode[eUser];\n    m_DefaultMode[eGroup]   = other.m_DefaultMode[eGroup];\n    m_DefaultMode[eOther]   = other.m_DefaultMode[eOther];\n    m_DefaultMode[eSpecial] = other.m_DefaultMode[eSpecial];\n}\n\n\nCDirEntry::~CDirEntry(void)\n{\n    return;\n}\n\n\nCDirEntry* CDirEntry::CreateObject(EType type, const string& path)\n{\n    CDirEntry *ptr;\n    switch ( type ) {\n        case eFile:\n            ptr = new CFile(path);\n            break;\n        case eDir:\n            ptr = new CDir(path);\n            break;\n        case eLink:\n            ptr = new CSymLink(path);\n            break;\n        default:\n            ptr = new CDirEntry(path);\n            break;\n    }\n    return ptr;\n}\n\n\nvoid CDirEntry::Reset(const string& path)\n{\n    m_Path = path;\n    size_t len = path.length();\n    // Root dir\n    if ((len == 1)  &&  IsPathSeparator(path[0])) {\n        return;\n    }\n    // Disk name\n#  if defined(DISK_SEPARATOR)\n    if ( (len == 2 || len == 3) && (path[1] == DISK_SEPARATOR) ) {\n        return;\n    }\n#  endif\n    m_Path = DeleteTrailingPathSeparator(path);\n}\n\n\nCDirEntry::TMode CDirEntry::m_DefaultModeGlobal[eUnknown][4] =\n{\n    // eFile\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eDir\n    { CDirEntry::fDefaultDirUser, CDirEntry::fDefaultDirGroup, CDirEntry::fDefaultDirOther, 0 },\n    // ePipe\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eLink\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eSocket\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eDoor\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eBlockSpecial\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eCharSpecial\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 }\n};\n\n\n// Default backup suffix\nconst char* CDirEntry::m_BackupSuffix = \".bak\";\n\n// Part of the temporary name used for \"safe copy\"\nstatic const char* kTmpSafeSuffix = \".tmp.\";\n\n\n\nCDirEntry& CDirEntry::operator= (const CDirEntry& other)\n{\n    if (this != &other) {\n        m_Path                  = other.m_Path;\n        m_DefaultMode[eUser]    = other.m_DefaultMode[eUser];\n        m_DefaultMode[eGroup]   = other.m_DefaultMode[eGroup];\n        m_DefaultMode[eOther]   = other.m_DefaultMode[eOther];\n        m_DefaultMode[eSpecial] = other.m_DefaultMode[eSpecial];\n    }\n    return *this;\n}\n\n\nvoid CDirEntry::SplitPath(const string& path, string* dir,\n                          string* base, string* ext)\n{\n    // Get file name\n    size_t pos = path.find_last_of(ALL_SEPARATORS);\n    string filename = (pos == NPOS) ? path : path.substr(pos+1);\n\n    // Get dir\n    if ( dir ) {\n        *dir = (pos == NPOS) ? kEmptyStr : path.substr(0, pos+1);\n    }\n    // Split file name to base and extension\n    pos = filename.rfind('.');\n    if ( base ) {\n        *base = (pos == NPOS) ? filename : filename.substr(0, pos);\n    }\n    if ( ext ) {\n        *ext = (pos == NPOS) ? kEmptyStr : filename.substr(pos);\n    }\n}\n\n\nvoid CDirEntry::SplitPathEx(const string& path,\n                            string* disk, string* dir,\n                            string* base, string* ext)\n{\n    size_t start_pos = 0;\n\n    // Get disk\n    if ( disk ) {\n        if ( isalpha((unsigned char)path[0])  &&  path[1] == ':' ) {\n            *disk = path.substr(0, 2);\n            start_pos = 2;\n        } else {\n            *disk = kEmptyStr;\n        }\n    }\n    // Get file name\n    size_t pos = path.find_last_of(ALL_OS_SEPARATORS);\n    string filename = (pos == NPOS) ? path : path.substr(pos+1);\n    // Get dir\n    if ( dir ) {\n        *dir = (pos == NPOS) ? kEmptyStr : \n                               path.substr(start_pos, pos - start_pos + 1);\n    }\n    // Split file name to base and extension\n    pos = filename.rfind('.');\n    if ( base ) {\n        *base = (pos == NPOS) ? filename : filename.substr(0, pos);\n    }\n    if ( ext ) {\n        *ext = (pos == NPOS) ? kEmptyStr : filename.substr(pos);\n    }\n}\n\n\nstring CDirEntry::MakePath(const string& dir, const string& base, \n                           const string& ext)\n{\n    string path;\n\n    // Adding \"dir\" and file base\n    if ( dir.length() ) {\n        path = AddTrailingPathSeparator(dir);\n    }\n    path += base;\n    // Adding extension\n    if ( ext.length()  &&  ext.at(0) != '.' ) {\n        path += '.';\n    }\n    path += ext;\n    // Return result\n    return path;\n}\n\n\nchar CDirEntry::GetPathSeparator(void) \n{\n    return DIR_SEPARATOR;\n}\n\n\nbool CDirEntry::IsPathSeparator(const char c)\n{\n#if defined(DISK_SEPARATOR)\n    if ( c == DISK_SEPARATOR ) {\n        return true;\n    }\n#endif\n#if defined(DIR_SEPARATOR_ALT)\n    if ( c == DIR_SEPARATOR_ALT ) {\n        return true;\n    }\n#endif\n    return c == DIR_SEPARATOR;\n}\n\n\nstring CDirEntry::AddTrailingPathSeparator(const string& path)\n{\n    size_t len = path.length();\n    if (len  &&  string(ALL_SEPARATORS).rfind(path.at(len - 1)) == NPOS) {\n        return path + GetPathSeparator();\n    }\n    return path;\n}\n\n\nstring CDirEntry::DeleteTrailingPathSeparator(const string& path)\n{\n    size_t pos = path.find_last_not_of(DIR_SEPARATORS);\n    if (pos + 1 < path.length()) {\n        return path.substr(0, pos + 1);\n    }\n    return path;\n}\n\n\nstring CDirEntry::GetDir(EIfEmptyPath mode) const\n{\n    string dir;\n    SplitPath(GetPath(), &dir);\n    if ( dir.empty() &&  mode == eIfEmptyPath_Current  &&\n         !GetPath().empty() ) {\n        return string(DIR_CURRENT) + DIR_SEPARATOR;\n    }\n    return dir;\n}\n\n\n// Windows: \ninline bool s_Win_IsDiskPath(const string& path)\n{\n    if ((isalpha((unsigned char)path[0]) && path[1] == ':')  &&\n         (path[2] == '/' || path[2] == '\\\\')) {\n        return true;\n    }\n    return false;\n}\n\n// Windows: \ninline bool s_Win_IsNetworkPath(const string& path)\n{\n    // Any combination of slashes in 2 first symbols\n    if ((path[0] == '\\\\' || path[0] == '/')  &&\n        (path[1] == '\\\\' || path[1] == '/')) {\n        return true;\n    }\n    return false;\n}\n\n\nbool CDirEntry::IsAbsolutePath(const string& path)\n{\n    if (path.empty()) {\n        return false;\n    }\n#if defined(NCBI_OS_MSWIN)\n    if (s_Win_IsDiskPath(path) || s_Win_IsNetworkPath(path)) {\n        return true;\n    }\n#elif defined(NCBI_OS_UNIX)\n    if ( path[0] == '/' ) {\n        return true;\n    }\n#endif\n    return false;\n}\n\n\nbool CDirEntry::IsAbsolutePathEx(const string& path)\n{\n    if ( path.empty() )\n        return false;\n\n    // Windows: \n    if (s_Win_IsDiskPath(path) || s_Win_IsNetworkPath(path)) {\n        return true;\n    }\n    // Unix\n    if (path[0] == '/') {\n        // FIXME:\n        // This is an Unix absolute path or MS Windows relative.\n        // But Unix have favor here, because '/' is native dir separator.\n        return true;\n    }\n    // Else - relative\n    return false;\n}\n\n\nstring CDirEntry::GetNearestExistingParentDir(const string& path)\n{\n    CDirEntry entry(NormalizePath(path));\n\n    // Find closest existing directory\n    while (!entry.Exists()) {\n        string dir = entry.GetDir();\n        if (dir.empty()) {\n            NCBI_THROW(CFileException, eNotExists,\n                       \"Failed to find existing containing directory for: \" +\n                       entry.GetPath());\n        }\n        entry.Reset(dir);\n    }\n    return entry.GetPath();\n}\n\n\n/// Helper -- strips dir to parts:\n///     c:\\a\\b\\     will be <c:><a><b>\n///     /usr/bin/   will be </><usr><bin>\nstatic void s_StripDir(const string& dir, vector<string> * dir_parts)\n{\n    dir_parts->clear();\n    if (dir.empty()) {\n        return;\n    }\n    const char sep = CDirEntry::GetPathSeparator();\n\n    size_t sep_pos = 0;\n    size_t last_ind = dir.length() - 1;\n    size_t part_start = 0;\n    for (;;) {\n        sep_pos = dir.find(sep, sep_pos);\n        if (sep_pos == NPOS) {\n            dir_parts->push_back(string(dir, part_start, dir.length() - part_start));\n            break;\n        }\n        // If path starts from '/' - it's a root directory\n        if (sep_pos == 0) {\n            dir_parts->push_back(string(1, sep));\n        } else {\n            dir_parts->push_back(string(dir, part_start, sep_pos - part_start));\n        }\n        sep_pos++;\n        part_start = sep_pos;\n        if (sep_pos >= last_ind) {\n            break;\n        }\n    }\n}\n\n\nstring CDirEntry::CreateRelativePath( const string& path_from, \n                                      const string& path_to )\n{\n    string path; // the result    \n    \n    if ( !IsAbsolutePath(path_from) ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_from is not absolute path\");\n    }\n\n    if ( !IsAbsolutePath(path_to) ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_to is not absolute path\");\n    }\n\n    // Split and strip FROM\n    string dir_from;\n    SplitPath(AddTrailingPathSeparator(path_from), &dir_from);\n    vector<string> dir_from_parts;\n    s_StripDir(dir_from, &dir_from_parts);\n    if ( dir_from_parts.empty() ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_from is empty path\");\n    }\n\n    // Split and strip TO\n    string dir_to;\n    string base_to;\n    string ext_to;\n    SplitPath(path_to, &dir_to, &base_to, &ext_to);    \n    vector<string> dir_to_parts;\n    s_StripDir(dir_to, &dir_to_parts);\n    if ( dir_to_parts.empty() ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_to is empty path\");\n    }\n\n    // Platform-dependent compare mode\n#ifdef NCBI_OS_MSWIN\n#  define DIR_PARTS_CMP_MODE NStr::eNocase\n#else /*NCBI_OS_UNIX*/\n#  define DIR_PARTS_CMP_MODE NStr::eCase\n#endif\n    // Roots must be the same to create relative path from one to another\n\n    if (NStr::Compare(dir_from_parts.front(), \n                      dir_to_parts.front(), \n                      DIR_PARTS_CMP_MODE) != 0) {\n        NCBI_THROW(CFileException, eRelativePath, \"roots of input paths are different\");\n    }\n\n    size_t min_parts = min(dir_from_parts.size(), dir_to_parts.size());\n    size_t common_length = min_parts;\n    for (size_t i = 0; i < min_parts; i++) {\n        if (NStr::Compare(dir_from_parts[i], dir_to_parts[i], DIR_PARTS_CMP_MODE) != 0) {\n            common_length = i;\n            break;\n        }\n    }\n\n    for (size_t i = common_length; i < dir_from_parts.size(); i++) {\n        path += \"..\";\n        path += GetPathSeparator();\n    }\n    for (size_t i = common_length; i < dir_to_parts.size(); i++) {\n        path += dir_to_parts[i];\n        path += GetPathSeparator();\n    }\n    \n    return path + base_to + ext_to;\n}\n\n\nstring CDirEntry::CreateAbsolutePath(const string& path, ERelativeToWhat rtw)\n{\n    if ( IsAbsolutePath(path) ) {\n        return NormalizePath(path);\n    }\n    string result;\n\n#if defined(NCBI_OS_MSWIN)\n    if ( path.find(DISK_SEPARATOR) != NPOS ) {\n        NCBI_THROW(CFileException, eRelativePath, \n                   \"Path must not contain disk separator: \" + path);\n    }\n    // Path started with slash\n    if (!path.empty() && (path[0] == '/' || path[0] == '\\\\')) {\n        // network path ?\n        if ( s_Win_IsNetworkPath(path) ) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Cannot use network path: \" + path);\n        }\n        // relative to current drive only\n        if (rtw != eRelativeToCwd) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Path can be used as relative to current drive only: \" + path);\n        }\n        return CDir::GetCwd().substr(0,3) + path;\n    }\n#endif\n\n    switch (rtw) {\n        case eRelativeToCwd:\n            result = ConcatPath(CDir::GetCwd(), path);\n            break;\n        case eRelativeToExe:\n          {\n            string dir;\n            SplitPath(CNcbiApplication::GetAppName(CNcbiApplication::eFullName), &dir);\n            result = ConcatPath(dir, path);\n            if ( !CDirEntry(result).Exists() ) {\n                SplitPath(CNcbiApplication::GetAppName(CNcbiApplication::eRealName), &dir);\n                result = ConcatPath(dir, path);\n            }\n            break;\n          }\n    }\n    return NormalizePath(result);\n}\n\n\nstring CDirEntry::CreateAbsolutePath(const string& path, const string& rtw)\n{\n    if ( IsAbsolutePath(path) ) {\n        return NormalizePath(path);\n    }\n\n#if defined(NCBI_OS_MSWIN)\n    if ( path.find(DISK_SEPARATOR) != NPOS ) {\n        NCBI_THROW(CFileException, eRelativePath, \n                   \"Path must not contain disk separator: \" + path);\n    }\n    // Path started with slash\n    if (!path.empty() && (path[0] == '/' || path[0] == '\\\\')) {\n        // network path ?\n        if ( s_Win_IsNetworkPath(path) ) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Cannot use network path: \" + path);\n        }\n        // relative to current drive only -- error\n        NCBI_THROW(CFileException, eRelativePath,\n                    \"Path can be used as relative to current drive only: \" + path);\n    }\n#endif\n\n    if (!IsAbsolutePath(rtw)) {\n        NCBI_THROW(CFileException, eRelativePath,\n                   \"2nd parameter must represent absolute path: \" + rtw);\n    }\n    return NormalizePath(ConcatPath(rtw, path));\n}\n\n\nstring CDirEntry::ConvertToOSPath(const string& path)\n{\n    // Not process empty or absolute path\n    if ( path.empty()  ||  IsAbsolutePathEx(path)) {\n        return NormalizePath(path);\n    }\n    // Now we have relative \"path\"\n    string xpath = path;\n    // Add trailing separator if path ends with DIR_PARENT or DIR_CURRENT\n#if defined(DIR_PARENT)\n    if ( NStr::EndsWith(xpath, DIR_PARENT) )  {\n        xpath += DIR_SEPARATOR;\n    }\n#endif\n#if defined(DIR_CURRENT)\n    if ( NStr::EndsWith(xpath, DIR_CURRENT) )  {\n        xpath += DIR_SEPARATOR;\n    }\n#endif\n    // Replace each path separator with the current OS separator character\n    for (size_t i = 0; i < xpath.length(); i++) {\n        char c = xpath[i];\n        if ( c == '\\\\' || c == '/' ) {\n            xpath[i] = DIR_SEPARATOR;\n        }\n    }\n    xpath = NormalizePath(xpath);\n    return xpath;\n}\n\n\nstring CDirEntry::ConcatPath(const string& first, const string& second)\n{\n    // Prepare first part of path\n    string path = AddTrailingPathSeparator(NStr::TruncateSpaces(first));\n    // Remove leading separator in \"second\" part\n    string part = NStr::TruncateSpaces(second);\n    if ( !path.empty()  &&  part.length() > 0  &&  part[0] == DIR_SEPARATOR ) {\n        part.erase(0,1);\n    }\n    // Add second part\n    path += part;\n    return path;\n}\n\n\nstring CDirEntry::ConcatPathEx(const string& first, const string& second)\n{\n    // Prepare first part of path\n    string path = NStr::TruncateSpaces(first);\n\n    // Add trailing path separator to first part (OS independence)\n\n    size_t pos = path.length();\n    if ( pos  &&  string(ALL_OS_SEPARATORS).find(path.at(pos-1)) == NPOS ) {\n        // Find used path separator\n        char sep = GetPathSeparator();\n        size_t sep_pos = path.find_last_of(ALL_OS_SEPARATORS);\n        if ( sep_pos != NPOS ) {\n            sep = path.at(sep_pos);\n        }\n        path += sep;\n    }\n    // Remove leading separator in \"second\" part\n    string part = NStr::TruncateSpaces(second);\n    if ( part.length() > 0  &&\n         string(ALL_OS_SEPARATORS).find(part[0]) != NPOS ) {\n        part.erase(0,1);\n    }\n    // Add second part\n    path += part;\n    return path;\n}\n\n\nstring CDirEntry::NormalizePath(const string& path, EFollowLinks follow_links)\n{\n    if ( path.empty() ) {\n        return path;\n    }\n    static const char kSep[] = { DIR_SEPARATOR, '\\0' };\n\n    std::list<string> head;       // already resolved to our satisfaction\n    std::list<string> tail;       // to resolve afterwards\n    string       current;         // to resolve next\n    int          link_depth = 0;\n\n    // Delete trailing slash for all paths except similar to 'd:\\'\n#  ifdef DISK_SEPARATOR\n    if ( path.find(DISK_SEPARATOR) == NPOS ) {\n        current = DeleteTrailingPathSeparator(path);\n    } else {\n        current = path;\n    }\n#  else\n    current = DeleteTrailingPathSeparator(path);\n#  endif\n\n    if ( current.empty() ) {\n        // root dir\n        return string(1, DIR_SEPARATOR);\n    }\n\n#ifdef NCBI_OS_MSWIN\n    NStr::ReplaceInPlace(current, \"/\", \"\\\\\");\n#endif\n\n    while ( !current.empty()  ||  !tail.empty() ) {\n        std::list<string> pretail;\n        if ( !current.empty() ) {\n            NStr::Split(current, kSep, pretail);\n            current.erase();\n            if (pretail.front().empty()\n#ifdef DISK_SEPARATOR\n                ||  pretail.front().find(DISK_SEPARATOR) != NPOS\n#endif\n                ) {\n                // Absolute path\n                head.clear();\n#ifdef NCBI_OS_MSWIN\n                // Remove leading \"\\\\?\\\". Replace leading \"\\\\?\\UNC\\\" with \"\\\\\".\n                static const char* const kUNC[] = { \"\", \"\", \"?\", \"UNC\" };\n                std::list<string>::iterator it = pretail.begin();\n                unsigned int matched = 0;\n                while (matched < 4  &&  it != pretail.end()\n                       &&  !NStr::CompareNocase(*it, kUNC[matched])) {\n                    ++it;\n                    ++matched;\n                }\n                pretail.erase(pretail.begin(), it);\n                switch (matched) {\n                case 2: case 4: // got a UNC path (\\\\... or \\\\?\\UNC\\...)\n                    head.push_back(kEmptyStr);\n                    // fall through\n                case 1:         // normal volume-less absolute path\n                    head.push_back(kEmptyStr);\n                    break;\n                case 3/*?*/:    // normal path, absolute or relative\n                    break;\n                }\n#endif\n            }\n            tail.splice(tail.begin(), pretail);\n        }\n\n        string next;\n        if (!tail.empty()) {\n            next = tail.front();\n            tail.pop_front();\n        }\n        if ( !head.empty() ) { // empty heads should accept anything\n            string& last = head.back();\n            if (last == DIR_CURRENT) {\n                if (!next.empty()) {\n                    head.pop_back();\n                    _ASSERT(head.empty());\n                }\n            } else if (next == DIR_CURRENT) {\n                // Leave out, since we already have content\n                continue;\n#ifdef DISK_SEPARATOR\n            } else if (!last.empty() && last[last.size()-1] == DISK_SEPARATOR) {\n                // Allow almost anything right after a volume specification\n#endif\n            } else if (next.empty()) {\n                continue; // leave out empty components in most cases\n            } else if (next == DIR_PARENT) {\n#ifdef DISK_SEPARATOR\n                SIZE_TYPE pos;\n#endif\n                // Back up if possible, assuming existing path to be \"physical\"\n                if (last.empty()) {\n                    // Already at the root; .. is a no-op\n                    continue;\n#ifdef DISK_SEPARATOR\n                } else if ((pos = last.find(DISK_SEPARATOR) != NPOS)) {\n                    last.erase(pos + 1);\n#endif\n                } else if (last != DIR_PARENT) {\n                    head.pop_back();\n                    continue;\n                }\n            }\n        }\n#ifdef NCBI_OS_UNIX\n        // Is there a Windows equivalent for readlink?\n        if ( follow_links ) {\n            string s(head.empty() ? next\n                     : NStr::Join(head, string(1, DIR_SEPARATOR))\n                     + DIR_SEPARATOR + next);\n            char buf[PATH_MAX];\n            int  length = (int)readlink(s.c_str(), buf, sizeof(buf));\n            if (length > 0) {\n                current.assign(buf, length);\n                if (++link_depth >= 1024) {\n                    ERR_POST_X(1, Warning << \"CDirEntry::NormalizePath():\"\n                               \" Reached symlink depth limit \" <<\n                               link_depth << \" when resolving \" << path);\n                    CNcbiError::Set(CNcbiError::eTooManySymbolicLinkLevels);\n                    follow_links = eIgnoreLinks;\n                }\n                continue;\n            }\n        }\n#endif\n        // Normal case: just append the next element to head\n        head.push_back(next);\n    }\n\n    // Special cases\n    if ( (head.size() == 0)  ||\n         (head.size() == 2  &&  head.front() == DIR_CURRENT  &&  head.back().empty()) ) {\n        // current dir\n        return DIR_CURRENT;\n    }\n    if (head.size() == 1  &&  head.front().empty()) {\n        // root dir\n        return string(1, DIR_SEPARATOR);\n    }\n    // Compose path\n    return NStr::Join(head, string(1, DIR_SEPARATOR));\n}\n\n\nbool CDirEntry::GetMode(TMode* user_mode, TMode* group_mode,\n                        TMode* other_mode, TSpecialModeBits* special) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n        LOG_ERROR_AND_RETURN_ERRNO(5, \"CDirEntry::GetMode(): stat() failed for \" + GetPath());\n    }\n    ModeFromModeT(st.st_mode, user_mode, group_mode, other_mode, special);\n    return true;\n}\n\n\n// Auxiliary macro to set/clear/replace current permissions\n\n#define UPDATE_PERMS(mode, perms) \\\n    { \\\n        _ASSERT( !F_ISSET(perms, fModeNoChange | fModeAdd)    ); \\\n        _ASSERT( !F_ISSET(perms, fModeNoChange | fModeRemove) ); \\\n        _ASSERT( !F_ISSET(perms, fModeAdd      | fModeRemove) ); \\\n        \\\n        if ( perms & fModeNoChange ) { \\\n            \\\n        } else  \\\n        if ( perms & fModeAdd ) { \\\n            mode |= perms; \\\n        } else  \\\n        if ( perms & fModeRemove ) { \\\n            mode &= ~perms; \\\n        } \\\n        else { \\\n            mode = perms; \\\n        } \\\n        /* clear auxiliary bits */ \\\n        mode &= ~(fDefault | fModeAdd | fModeRemove | fModeNoChange); \\\n    }\n\n\nbool CDirEntry::SetMode(TMode user_mode, TMode group_mode,\n                        TMode other_mode, TSpecialModeBits special_mode,\n                        TSetModeFlags flags) const\n{\n    // Assumption\n    _ASSERT(eEntryOnly == fEntry);\n\n    // Is this a directory ? (and processing not entry only)\n    if ( (flags & (fDir_All | fDir_Recursive)) != eEntryOnly  &&  IsDir(eIgnoreLinks) ) {\n        return CDir(GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode, flags);\n    }\n    // Other entries\n    return SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags);\n}\n\n\nbool CDirEntry::SetModeEntry(TMode user_mode, TMode group_mode,\n                             TMode other_mode, TSpecialModeBits special_mode,\n                             TSetModeFlags flags) const\n{\n    // Check on defaults modes\n    if (user_mode & fDefault) {\n        user_mode = m_DefaultMode[eUser];\n    }\n    if (group_mode & fDefault) {\n        group_mode = m_DefaultMode[eGroup];\n    }\n    if (other_mode & fDefault) {\n        other_mode = m_DefaultMode[eOther];\n    }\n    if (special_mode == 0) {\n        special_mode = m_DefaultMode[eSpecial];\n    }\n    \n    TMode user  = 0;\n    TMode group = 0;\n    TMode other = 0;\n    TSpecialModeBits special = 0;\n    TMode relative_mask = fModeNoChange | fModeAdd | fModeRemove;\n\n    // relative permissions\n    \n    if ( (user_mode    & relative_mask) ||\n         (group_mode   & relative_mask) ||\n         (other_mode   & relative_mask) ||\n         (special_mode & relative_mask) ) {\n\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n            if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n                return true;\n            }\n            LOG_ERROR_AND_RETURN_ERRNO(6, \"CDirEntry::SetModeEntry(): stat() failed for \" + GetPath());\n        }\n        ModeFromModeT(st.st_mode, &user, &group, &other);\n    }\n    \n    UPDATE_PERMS(user,    user_mode);\n    UPDATE_PERMS(group,   group_mode);\n    UPDATE_PERMS(other,   other_mode);\n    UPDATE_PERMS(special, special_mode);\n   \n    // change permissions\n    \n    mode_t mode = MakeModeT(user, group, other, special);\n\n    if ( NcbiSys_chmod(_T_XCSTRING(GetPath()), mode) != 0 ) {\n        if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n            return true;\n        }\n        LOG_ERROR_AND_RETURN_ERRNO(7, \"CDirEntry::SetModeEntry(): chmod() failed for \" + GetPath());\n    }\n    return true;\n}\n\n\nvoid CDirEntry::SetDefaultModeGlobal(EType entry_type, TMode user_mode, \n                                     TMode group_mode, TMode other_mode,\n                                     TSpecialModeBits special)\n{\n    if ( entry_type >= eUnknown ) {\n        return;\n    }\n    if ( entry_type == eDir ) {\n        if ( user_mode == fDefault ) {\n            user_mode = fDefaultDirUser;\n        }\n        if ( group_mode == fDefault ) {\n            group_mode = fDefaultDirGroup;\n        }\n        if ( other_mode == fDefault ) {\n            other_mode = fDefaultDirOther;\n        }\n    } else {\n        if ( user_mode == fDefault ) {\n            user_mode = fDefaultUser;\n        }\n        if ( group_mode == fDefault ) {\n            group_mode = fDefaultGroup;\n        }\n        if ( other_mode == fDefault ) {\n            other_mode = fDefaultOther;\n        }\n    }\n    if ( special == 0 ) {\n        special = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n    m_DefaultModeGlobal[entry_type][eUser]    = user_mode;\n    m_DefaultModeGlobal[entry_type][eGroup]   = group_mode;\n    m_DefaultModeGlobal[entry_type][eOther]   = other_mode;\n    m_DefaultModeGlobal[entry_type][eSpecial] = special;\n}\n\n\nvoid CDirEntry::SetDefaultMode(EType entry_type, TMode user_mode, \n                               TMode group_mode, TMode other_mode,\n                               TSpecialModeBits special)\n{\n    if ( user_mode == fDefault ) {\n        user_mode  = m_DefaultModeGlobal[entry_type][eUser];\n    }\n    if ( group_mode == fDefault ) {\n        group_mode = m_DefaultModeGlobal[entry_type][eGroup];\n    }\n    if ( other_mode == fDefault ) {\n        other_mode = m_DefaultModeGlobal[entry_type][eOther];\n    }\n    if ( special == 0 ) {\n        special = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n    m_DefaultMode[eUser]    = user_mode;\n    m_DefaultMode[eGroup]   = group_mode;\n    m_DefaultMode[eOther]   = other_mode;\n    m_DefaultMode[eSpecial] = special;\n}\n\n\nvoid CDirEntry::GetDefaultModeGlobal(EType  entry_type, TMode* user_mode,\n                                     TMode* group_mode, TMode* other_mode,\n                                     TSpecialModeBits* special)\n{\n    if ( user_mode ) {\n        *user_mode  = m_DefaultModeGlobal[entry_type][eUser];\n    }\n    if ( group_mode ) {\n        *group_mode = m_DefaultModeGlobal[entry_type][eGroup];\n    }\n    if ( other_mode ) {\n        *other_mode = m_DefaultModeGlobal[entry_type][eOther];\n    }\n    if ( special ) {\n        *special  = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n}\n\n\nvoid CDirEntry::GetDefaultMode(TMode* user_mode, TMode* group_mode,\n                               TMode* other_mode,\n                               TSpecialModeBits* special) const\n{\n    if ( user_mode ) {\n        *user_mode  = m_DefaultMode[eUser];\n    }\n    if ( group_mode ) {\n        *group_mode = m_DefaultMode[eGroup];\n    }\n    if ( other_mode ) {\n        *other_mode = m_DefaultMode[eOther];\n    }\n    if ( special ) {\n        *special   = m_DefaultMode[eSpecial];\n    }\n}\n\n\nmode_t CDirEntry::MakeModeT(TMode user_mode, TMode group_mode,\n                            TMode other_mode, TSpecialModeBits special)\n{\n    mode_t mode = (\n    // special bits\n#ifdef S_ISUID\n                   (special & fSetUID     ? S_ISUID  : 0) |\n#endif\n#ifdef S_ISGID\n                   (special & fSetGID     ? S_ISGID  : 0) |\n#endif\n#ifdef S_ISVTX\n                   (special & fSticky     ? S_ISVTX  : 0) |\n#endif\n    // modes\n#if   defined(S_IRUSR)\n                   (user_mode & fRead     ? S_IRUSR  : 0) |\n#elif defined(S_IREAD) \n                   (user_mode & fRead     ? S_IREAD  : 0) |\n#endif\n#if   defined(S_IWUSR)\n                   (user_mode & fWrite    ? S_IWUSR  : 0) |\n#elif defined(S_IWRITE)\n                   (user_mode & fWrite    ? S_IWRITE : 0) |\n#endif\n#if   defined(S_IXUSR)\n                   (user_mode & fExecute  ? S_IXUSR  : 0) |\n#elif defined(S_IEXEC)\n                   (user_mode & fExecute  ? S_IEXEC  : 0) |\n#endif\n#ifdef S_IRGRP\n                   (group_mode & fRead    ? S_IRGRP  : 0) |\n#endif\n#ifdef S_IWGRP\n                   (group_mode & fWrite   ? S_IWGRP  : 0) |\n#endif\n#ifdef S_IXGRP\n                   (group_mode & fExecute ? S_IXGRP  : 0) |\n#endif\n#ifdef S_IROTH\n                   (other_mode & fRead    ? S_IROTH  : 0) |\n#endif\n#ifdef S_IWOTH\n                   (other_mode & fWrite   ? S_IWOTH  : 0) |\n#endif\n#ifdef S_IXOTH\n                   (other_mode & fExecute ? S_IXOTH  : 0) |\n#endif\n                   0);\n    return mode;\n}\n\n\nvoid CDirEntry::ModeFromModeT(mode_t mode, \n                              TMode* user_mode, TMode* group_mode, \n                              TMode* other_mode, TSpecialModeBits* special)\n{\n    // Owner\n    if (user_mode) {\n        *user_mode = (\n#if   defined(S_IRUSR)\n                     (mode & S_IRUSR  ? fRead    : 0) |\n#elif defined(S_IREAD)\n                     (mode & S_IREAD  ? fRead    : 0) |\n#endif\n#if   defined(S_IWUSR)\n                     (mode & S_IWUSR  ? fWrite   : 0) |\n#elif defined(S_IWRITE)\n                     (mode & S_IWRITE ? fWrite   : 0) |\n#endif\n#if   defined(S_IXUSR)\n                     (mode & S_IXUSR  ? fExecute : 0) |\n#elif defined(S_IEXEC)\n                     (mode & S_IEXEC  ? fExecute : 0) |\n#endif\n                     0);\n    }\n\n#ifdef NCBI_OS_MSWIN\n    if (group_mode) *group_mode = 0;\n    if (other_mode) *other_mode = 0;\n    if (special)    *special    = 0;\n\n#else\n    // Group\n    if (group_mode) {\n        *group_mode = (\n#ifdef S_IRGRP\n                     (mode & S_IRGRP  ? fRead    : 0) |\n#endif\n#ifdef S_IWGRP\n                     (mode & S_IWGRP  ? fWrite   : 0) |\n#endif\n#ifdef S_IXGRP\n                     (mode & S_IXGRP  ? fExecute : 0) |\n#endif\n                     0);\n    }\n    // Others\n    if (other_mode) {\n        *other_mode = (\n#ifdef S_IROTH\n                     (mode & S_IROTH  ? fRead    : 0) |\n#endif\n#ifdef S_IWOTH\n                     (mode & S_IWOTH  ? fWrite   : 0) |\n#endif\n#ifdef S_IXOTH\n                     (mode & S_IXOTH  ? fExecute : 0) |\n#endif\n                     0);\n    }\n    // Special bits\n    if (special) {\n        *special = (\n#ifdef S_ISUID\n                    (mode & S_ISUID   ? fSetUID  : 0) |\n#endif\n#ifdef S_ISGID\n                    (mode & S_ISGID   ? fSetGID  : 0) |\n#endif\n#ifdef S_ISVTX\n                    (mode & S_ISVTX   ? fSticky  : 0) |\n#endif\n                    0);\n    }\n#endif // NCBI_OS_MSWIN\n}\n\n\n// Convert permission mode to \"rw[xsStT]\" string.\nstring CDirEntry::x_ModeToSymbolicString(CDirEntry::EWho who, CDirEntry::TMode mode, bool special_bit, char filler)\n{\n    string out;\n    out.reserve(3);\n\n    char c;\n    c = (mode & CDirEntry::fRead  ? 'r' : filler);\n    if (c) {\n        out += c;\n    }\n    c = (mode & CDirEntry::fWrite ? 'w' : filler);\n    if (c) {\n        out += c;\n    }\n    c = filler;\n    if ( special_bit ) {\n        if (who == CDirEntry::eOther) {\n            c = (mode & CDirEntry::fExecute) ? 't' : 'T';\n        } else {\n            c = (mode & CDirEntry::fExecute) ? 's' : 'S';\n        }\n    } else if (mode & CDirEntry::fExecute) {\n        c = 'x';\n    }\n    if (c) {\n        out += c;\n    }\n    return out;\n}\n\n\nstring CDirEntry::ModeToString(TMode user_mode, TMode group_mode, \n                               TMode other_mode, TSpecialModeBits special,\n                               EModeStringFormat format)\n{\n    string out;\n    switch (format) {\n    case eModeFormat_Octal:\n        {\n            int i = 0;\n            if (special > 0) {\n                out = \"0000\";\n                out[0] = char(special + '0');\n                i++;\n            } else {\n                out = \"000\";\n            }\n            out[i++] = char(user_mode  + '0');\n            out[i++] = char(group_mode + '0');\n            out[i++] = char(other_mode + '0');\n        }\n        break;\n    case eModeFormat_Symbolic:\n        {\n            out.reserve(17);\n            out =   \"u=\" + x_ModeToSymbolicString(eUser,  user_mode,  (special & fSetUID) > 0, '\\0');\n            out += \",g=\" + x_ModeToSymbolicString(eGroup, group_mode, (special & fSetGID) > 0, '\\0');\n            out += \",o=\" + x_ModeToSymbolicString(eOther, other_mode, (special & fSticky) > 0, '\\0');\n        }\n        break;\n    case eModeFormat_List:\n        {\n            out.reserve(9);\n            out =  x_ModeToSymbolicString(eUser,  user_mode,  (special & fSetUID) > 0, '-');\n            out += x_ModeToSymbolicString(eGroup, group_mode, (special & fSetGID) > 0, '-');\n            out += x_ModeToSymbolicString(eOther, other_mode, (special & fSticky) > 0, '-');\n        }\n        break;\n    default:\n        _TROUBLE;\n    }\n\n    return out;\n}\n\n\nbool CDirEntry::StringToMode(const CTempString& mode, \n                             TMode* user_mode, TMode* group_mode, \n                             TMode* other_mode, TSpecialModeBits* special)\n{\n    if ( mode.empty() ) {\n        CNcbiError::Set(CNcbiError::eInvalidArgument);\n        return false;\n    }\n    if ( isdigit((unsigned char)(mode[0])) ) {\n    // eModeFormat_Octal\n        unsigned int oct = NStr::StringToUInt(mode, NStr::fConvErr_NoThrow, 8);\n        if ((oct > 07777) || (!oct  &&  errno != 0)) {\n            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n            return false;\n        }\n        if (other_mode) {\n            *other_mode = TMode(oct & 7);\n        }\n        oct >>= 3;\n        if (group_mode) {\n            *group_mode = TMode(oct & 7);\n        }\n        oct >>= 3;\n        if (user_mode) {\n            *user_mode = TMode(oct & 7);\n        }\n        if (special) {\n            oct >>= 3;\n            *special = TSpecialModeBits(oct);\n        }\n\n    } else {\n\n        if (user_mode) \n            *user_mode = 0;\n        if (group_mode)\n            *group_mode = 0;\n        if (other_mode)\n            *other_mode = 0;\n        if (special)\n            *special = 0;\n\n        // eModeFormat_List:\n        if (mode.find('=') == NPOS  &&  mode.length() == 9) {\n            for (int i = 0; i < 3; i++) {\n                TMode m = 0;\n                bool is_special = false;\n\n                switch (mode[i*3]) {\n                    case 'r':\n                        m |= fRead;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (mode[i*3 + 1]) {\n                    case 'w':\n                        m |= fWrite;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (mode[i*3 + 2]) {\n                    case 'S':\n                    case 'T':\n                        is_special = true;\n                        break;\n                    case 's':\n                    case 't':\n                        is_special = true;\n                        // fall through\n                    case 'x':\n                        m |= fExecute;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (i) {\n                    case 0: // user\n                        if (user_mode) \n                            *user_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetUID;\n                        break;\n                    case 1: // group\n                        if (group_mode)\n                            *group_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetGID;\n                        break;\n                    case 2: // other\n                        if (other_mode)\n                            *other_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSticky;\n                        break;\n                }\n            }\n\n        // eModeFormat_Symbolic\n        } else {\n            std::list<string> parts;\n            NStr::Split(mode, \",\", parts,\n                NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n            if ( parts.empty() ) {\n                CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                return false;\n            }\n            bool have_user  = false;\n            bool have_group = false;\n            bool have_other = false;\n\n            ITERATE(std::list<string>, it, parts) {\n                string accessor, perm;\n                if ( !NStr::SplitInTwo(*it, \"=\", accessor, perm) ) {\n                    CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                    return false;\n                }\n                TMode m = 0;\n                bool is_special = false;\n                // Permission mode(s) (rwx)\n                ITERATE(string, s, perm) {\n                    switch(char(*s)) {\n                    case 'r':\n                        m |= fRead;\n                        break;\n                    case 'w':\n                        m |= fWrite;\n                        break;\n                    case 'S':\n                    case 'T':\n                        is_special = true;\n                        break;\n                    case 's':\n                    case 't':\n                        is_special = true;\n                        // fall through\n                    case 'x':\n                        m |= fExecute;\n                        break;\n                    default:\n                       CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                       return false;\n                    }\n                }\n                // Permission group category (ugoa)\n                ITERATE(string, s, accessor) {\n                    switch(char(*s)) {\n                    case 'u':\n                        if (have_user) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (user_mode)\n                            *user_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetUID;\n                        have_user = true;\n                        break;\n                    case 'g':\n                        if (have_group) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (group_mode)\n                            *group_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetGID;\n                        have_group = true;\n                        break;\n                    case 'o':\n                        if (have_other) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (other_mode)\n                            *other_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSticky;\n                        have_other = true;\n                        break;\n                    case 'a':\n                        if (is_special || have_user || have_group || have_other) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        have_user  = true;\n                        have_group = true;\n                        have_other = true;\n                        if (user_mode)\n                            *user_mode = m;\n                        if (group_mode)\n                            *group_mode = m;\n                        if (other_mode)\n                            *other_mode = m;\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                    }\n                }\n            }\n        }\n\n    }\n    return true;\n}\n\n\nvoid CDirEntry::GetUmask(TMode* user_mode, TMode* group_mode, \n                         TMode* other_mode, TSpecialModeBits* special)\n{\n#ifdef HAVE_GETUMASK\n    mode_t mode = getumask();\n#else\n    mode_t mode = umask(0);\n    umask(mode);\n#endif //HAVE_GETUMASK\n    ModeFromModeT(mode, user_mode, group_mode, other_mode, special);\n}\n\n\nvoid CDirEntry::SetUmask(TMode user_mode, TMode group_mode, \n                         TMode other_mode, TSpecialModeBits special)\n{\n    mode_t mode = MakeModeT((user_mode  == fDefault) ? 0 : user_mode,\n                            (group_mode == fDefault) ? 0 : group_mode,\n                            (other_mode == fDefault) ? 0 : other_mode,\n                            special);\n    umask(mode);\n}\n\n\n#if defined(NCBI_OS_UNIX) && !defined(HAVE_EUIDACCESS) && !defined(EFF_ONLY_OK)\n\n// Work around a weird GCC 2.95 glitch which can result in confusing\n// calls to stat() with invocations of a (nonexistent) constructor.\n# if defined(NCBI_COMPILER_GCC)  &&  NCBI_COMPILER_VERSION < 300\n#    define CAS_ARG1 void\n#    define CAS_CAST static_cast<const struct stat*>\n#  else\n#    define CAS_ARG1 struct stat\n#    define CAS_CAST\n#endif\n\nstatic bool s_CheckAccessStat(const CAS_ARG1* p, int mode)\n{\n    const struct stat& st = *CAS_CAST(p);\n    uid_t uid = geteuid();\n\n    // Check user permissions\n    if (uid == st.st_uid) {\n        return (!(mode & R_OK)  ||  (st.st_mode & S_IRUSR))  &&\n               (!(mode & W_OK)  ||  (st.st_mode & S_IWUSR))  &&\n               (!(mode & X_OK)  ||  (st.st_mode & S_IXUSR));\n    }\n\n    // Initialize list of group IDs for effective user\n    int ngroups = 0;\n    gid_t gids[NGROUPS_MAX + 1];\n    gids[0] = getegid();\n    ngroups = getgroups((int)(sizeof(gids)/sizeof(gids[0])) - 1, gids + 1);\n    if (ngroups < 0) {\n        ngroups = 1;\n    } else {\n        ngroups++;\n    }\n    for (int i = 1;  i < ngroups;  i++) {\n        if (gids[i] == uid) {\n            if (i < --ngroups) {\n                memmove(&gids[i], &gids[i + 1], sizeof(gids[0])*(ngroups-i));\n            }\n            break;\n        }\n    }\n\n    // Check group permissions\n    for (int i = 0;  i < ngroups;  i++) {\n        if (gids[i] == st.st_gid) {\n            return  (!(mode & R_OK)  ||  (st.st_mode & S_IRGRP))  &&\n                    (!(mode & W_OK)  ||  (st.st_mode & S_IWGRP))  &&\n                    (!(mode & X_OK)  ||  (st.st_mode & S_IXGRP));\n        }\n    }\n\n    // Check other permissions\n    if ( (!(mode & R_OK)  ||  (st.st_mode & S_IROTH))  &&\n         (!(mode & W_OK)  ||  (st.st_mode & S_IWOTH))  &&\n         (!(mode & X_OK)  ||  (st.st_mode & S_IXOTH)) ) {\n        return true;\n    }\n\n    // Permissions not granted\n    return false;\n}\n\n\nstatic bool s_CheckAccessPath(const char* path, int mode)\n{\n    if (!path) {\n        errno = 0;\n        CNcbiError::Set(CNcbiError::eBadAddress);\n        return false;\n    }\n    if (!*path) {\n        CNcbiError::SetErrno(errno = ENOENT, path);\n        return false;\n    }\n    struct stat st;\n    if (stat(path, &st) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n\n    if (!s_CheckAccessStat(&st, mode)) {\n        CNcbiError::SetErrno(errno = EACCES, path);\n        return false;\n    }\n \n    // Permissions granted\n    return true;\n}\n\n#endif  // defined(NCBI_OS_UNIX)\n\n\nbool CDirEntry::CheckAccess(TMode access_mode) const\n{\n#if defined(NCBI_OS_MSWIN)\n    // Try to get effective access rights on this file object for\n    // the current process owner.\n    ACCESS_MASK mask = 0;\n    if ( CWinSecurity::GetFilePermissions(GetPath(), &mask) ) {\n        TMode perm = ( (mask & FILE_READ_DATA  ? fRead    : 0) |\n                       (mask & FILE_WRITE_DATA ? fWrite   : 0) |\n                       (mask & FILE_EXECUTE    ? fExecute : 0) );\n        return (access_mode & perm) > 0;\n     }\n     return false;\n\n#elif defined(NCBI_OS_UNIX)\n    const char* path = GetPath().c_str();\n    int         mode = F_OK;\n\n    if ( access_mode & fRead)    mode |= R_OK;\n    if ( access_mode & fWrite)   mode |= W_OK;\n    if ( access_mode & fExecute) mode |= X_OK;\n    \n    // Use euidaccess() where possible\n#  if defined(HAVE_EUIDACCESS)\n    if (euidaccess(path, mode) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n    return true;\n\n#  elif defined(EFF_ONLY_OK)\n    // Some Unix have special flag for access() to use effective user ID.\n    mode |= EFF_ONLY_OK;\n    if (access(path, mode) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n    return true;\n\n#  else\n    // We can use access() only if effective and real user/group IDs are equal.\n    // access() operate with real IDs only, but we should check access\n    // for effective IDs.\n    if (getuid() == geteuid()  &&  getgid() == getegid()) {\n        if (access(path, mode) != 0) {\n            CNcbiError::SetFromErrno(path);\n            return false;\n        }\n        return true;\n    }\n    // Otherwise, try to check permissions itself.\n    // Note, that this function is not perfect, it doesn't work with ACL,\n    // which implementation can differ for each platform.\n    // But in most cases it works.\n    return s_CheckAccessPath(path, mode);\n\n#  endif\n#endif // NCBI_OS\n}\n\n\n#ifdef NCBI_OS_MSWIN\n\nbool s_FileTimeToCTime(const FILETIME& filetime, CTime& t) \n{\n    // Clear time object\n    t.Clear();\n\n    if ( !filetime.dwLowDateTime  &&  !filetime.dwHighDateTime ) {\n        // File time is undefined, just return \"empty\" time\n        return true;\n    }\n    SYSTEMTIME system;\n    FILETIME   local;\n\n    // Convert the file time to local time\n    if ( !FileTimeToLocalFileTime(&filetime, &local) ) {\n        CNcbiError::SetFromWindowsError();\n        return false;\n    }\n    // Convert the local file time from UTC to system time.\n    if ( !FileTimeToSystemTime(&local, &system) ) {\n        CNcbiError::SetFromWindowsError();\n        return false;\n    }\n\n    // Construct new time\n    CTime newtime(system.wYear,\n                  system.wMonth,\n                  system.wDay,\n                  system.wHour,\n                  system.wMinute,\n                  system.wSecond,\n                  system.wMilliseconds *\n                         (kNanoSecondsPerSecond / kMilliSecondsPerSecond),\n                  CTime::eLocal,\n                  t.GetTimeZonePrecision());\n\n    // And assign it\n    if ( t.GetTimeZone() == CTime::eLocal ) {\n        t = newtime;\n    } else {\n        t = newtime.GetGmtTime();\n    }\n    return true;\n}\n\n\nvoid s_UnixTimeToFileTime(time_t t, long nanosec, FILETIME& filetime) \n{\n    // Note that LONGLONG is a 64-bit value\n    LONGLONG res;\n    // This algorithm was found in MSDN\n    res = Int32x32To64(t, 10000000) + 116444736000000000 + nanosec/100;\n    filetime.dwLowDateTime  = (DWORD)res;\n    filetime.dwHighDateTime = (DWORD)(res >> 32);\n}\n\n#endif // NCBI_OS_MSWIN\n\n\nbool CDirEntry::GetTime(CTime* modification,\n                        CTime* last_access,\n                        CTime* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    HANDLE handle;\n    WIN32_FIND_DATA buf;\n\n    // Get file times using FindFile\n    handle = FindFirstFile(_T_XCSTRING(GetPath()), &buf);\n    if ( handle == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_AND_RETURN_WIN(8, \"CDirEntry::GetTime(): Cannot find \" + GetPath());\n        return false;\n    }\n    FindClose(handle);\n\n    // Convert file UTC times into CTime format\n    if ( modification  &&\n        !s_FileTimeToCTime(buf.ftLastWriteTime, *modification) ) {\n        LOG_ERROR_AND_RETURN_WIN(9, \"CDirEntry::GetTime(): Cannot get modification time for \" + GetPath());\n    }\n    if ( last_access  &&\n         !s_FileTimeToCTime(buf.ftLastAccessTime, *last_access) ) {\n        LOG_ERROR_AND_RETURN_WIN(9, \"CDirEntry::GetTime(): Cannot get access time for \" + GetPath());\n    }\n    if ( creation  &&\n        !s_FileTimeToCTime(buf.ftCreationTime, *creation) ) {\n        LOG_ERROR_AND_RETURN_WIN(9, \"CDirEntry::GetTime(): Cannot get creation time for \" + GetPath());\n    }\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    struct SStat st;\n    if ( !Stat(&st) ) {\n        LOG_ERROR_AND_RETURN_ERRNO(8, \"CDirEntry::GetTime(): Cannot get time for \" + GetPath());\n        return false;\n    }\n    if ( modification ) {\n        modification->SetTimeT(st.orig.st_mtime);\n        if ( st.mtime_nsec )\n            modification->SetNanoSecond(st.mtime_nsec);\n    }\n    if ( last_access ) {\n        last_access->SetTimeT(st.orig.st_atime);\n        if ( st.atime_nsec )\n            last_access->SetNanoSecond(st.atime_nsec);\n    }\n    if ( creation ) {\n        creation->SetTimeT(st.orig.st_ctime);\n        if ( st.ctime_nsec )\n            creation->SetNanoSecond(st.ctime_nsec);\n    }\n    return true;\n#endif\n}\n\n\nbool CDirEntry::SetTime(const CTime* modification,\n                        const CTime* last_access,\n                        const CTime* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    if ( !modification  &&  !last_access  &&  !creation ) {\n        return true;\n    }\n\n    FILETIME   x_modification,        x_last_access,        x_creation;\n    LPFILETIME p_modification = NULL, p_last_access = NULL, p_creation = NULL;\n\n    // Convert times to FILETIME format\n    if ( modification ) {\n        s_UnixTimeToFileTime(modification->GetTimeT(),\n                             modification->NanoSecond(), x_modification);\n        p_modification = &x_modification;\n    }\n    if ( last_access ) {\n        s_UnixTimeToFileTime(last_access->GetTimeT(),\n                             last_access->NanoSecond(), x_last_access);\n        p_last_access = &x_last_access;\n    }\n    if ( creation ) {\n        s_UnixTimeToFileTime(creation->GetTimeT(),\n                             creation->NanoSecond(), x_creation);\n        p_creation = &x_creation;\n    }\n\n    // Change times\n    HANDLE h = CreateFile(_T_XCSTRING(GetPath()), FILE_WRITE_ATTRIBUTES,\n                          FILE_SHARE_READ, NULL, OPEN_EXISTING,\n                          FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n    if ( h == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_AND_RETURN_WIN(10, \"CDirEntry::SetTime(): Cannot open \" + GetPath());\n    }\n    if ( !SetFileTime(h, p_creation, p_last_access, p_modification) ) {\n        CloseHandle(h);\n        LOG_ERROR_AND_RETURN_WIN(11, \"CDirEntry::SetTime(): Cannot set new time for \" + GetPath());\n    }\n    CloseHandle(h);\n\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    // Creation time doesn't used on Unix\n    creation = NULL;  /* DUMMY, to avoid warnings */\n\n    if ( !modification  &&  !last_access  /*&&  !creation*/ ) {\n        return true;\n    }\n\n#  ifdef HAVE_UTIMES\n    // Get current times\n    CTime x_modification, x_last_access;\n\n    if ( !modification  ||  !last_access ) {\n        if ( !GetTime(modification ? NULL : &x_modification,\n                      last_access  ? NULL : &x_last_access,\n                      NULL /* creation */) ) {\n            return false;\n        }\n        if (!modification) {\n            modification = &x_modification;\n        } else {\n            last_access = &x_last_access;\n        }\n    }\n\n    // Change times\n    struct timeval tvp[2];\n    tvp[0].tv_sec  = last_access->GetTimeT();\n    tvp[0].tv_usec = last_access->NanoSecond()\n        / (kNanoSecondsPerSecond / kMicroSecondsPerSecond);\n    tvp[1].tv_sec  = modification->GetTimeT();\n    tvp[1].tv_usec = modification->NanoSecond()\n        / (kNanoSecondsPerSecond / kMicroSecondsPerSecond);\n\n#    ifdef HAVE_LUTIMES\n    bool ut_res = lutimes(GetPath().c_str(), tvp) == 0;\n#    else\n    bool ut_res = utimes(GetPath().c_str(), tvp) == 0;\n#    endif\n    if ( !ut_res ) {\n        LOG_ERROR_AND_RETURN_ERRNO(12, \"CDirEntry::SetTime(): Cannot change time for \" + GetPath());\n    }\n    return true;\n\n# else\n    // utimes() does not exist on current platform,\n    // so use less accurate utime().\n\n    // Get current times\n    time_t x_modification, x_last_access;\n\n    if ((!modification  ||  !last_access)\n        &&  !GetTimeT(&x_modification,\n                      &x_last_access,\n                      NULL /* creation */)) {\n        return false;\n    }\n\n    // Change times to new\n    struct utimbuf times;\n    times.modtime  = modification ? modification->GetTimeT() : x_modification;\n    times.actime   = last_access  ? last_access->GetTimeT()  : x_last_access;\n    if ( utime(GetPath().c_str(), &times) != 0 ) {\n        LOG_ERROR_AND_RETURN_ERRNO(12, \"CDirEntry::SetTime(): Cannot change time for \" + GetPath());\n    }\n    return true;\n\n#  endif // HAVE_UTIMES\n\n#endif\n}\n\n\nbool CDirEntry::GetTimeT(time_t* modification,\n                         time_t* last_access,\n                         time_t* creation) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n        LOG_ERROR_AND_RETURN_ERRNO(13, \"CDirEntry::GetTimeT(): stat() failed for \" + GetPath());\n    }\n    if ( modification ) {\n        *modification = st.st_mtime;\n    }\n    if ( last_access ) {\n        *last_access = st.st_atime;\n    }\n    if ( creation ) {\n        *creation = st.st_ctime;\n    }\n    return true;\n}\n\n\nbool CDirEntry::SetTimeT(const time_t* modification,\n                         const time_t* last_access,\n                         const time_t* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    if ( !modification  &&  !last_access  &&  !creation ) {\n        return true;\n    }\n\n    FILETIME   x_modification,        x_last_access,        x_creation;\n    LPFILETIME p_modification = NULL, p_last_access = NULL, p_creation = NULL;\n\n    // Convert times to FILETIME format\n    if ( modification ) {\n        s_UnixTimeToFileTime(*modification, 0, x_modification);\n        p_modification = &x_modification;\n    }\n    if ( last_access ) {\n        s_UnixTimeToFileTime(*last_access, 0, x_last_access);\n        p_last_access = &x_last_access;\n    }\n    if ( creation ) {\n        s_UnixTimeToFileTime(*creation, 0, x_creation);\n        p_creation = &x_creation;\n    }\n\n    // Change times\n    HANDLE h = CreateFile(_T_XCSTRING(GetPath()), FILE_WRITE_ATTRIBUTES,\n                          FILE_SHARE_READ, NULL, OPEN_EXISTING,\n                          FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n    if ( h == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_AND_RETURN_WIN(14, \"CDirEntry::SetTimeT(): Cannot open \" + GetPath());\n    }\n    if ( !SetFileTime(h, p_creation, p_last_access, p_modification) ) {\n        CloseHandle(h);\n        LOG_ERROR_AND_RETURN_WIN(15, \"CDirEntry::SetTimeT(): Cannot change time for \" + GetPath());\n    }\n    CloseHandle(h);\n\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    // Creation time doesn't used on Unix\n    creation = NULL;  /* DUMMY, to avoid warnings */\n\n    if ( !modification  &&  !last_access  /*&&  !creation*/ )\n        return true;\n\n    time_t x_modification, x_last_access;\n    if ((!modification  ||  !last_access)\n        &&  !GetTimeT(&x_modification,\n                      &x_last_access,\n                      NULL /* creation */) ) {\n        return false;\n    }\n\n    // Change times to new\n    struct utimbuf times;\n    times.modtime = modification ? *modification : x_modification;\n    times.actime  = last_access  ? *last_access  : x_last_access;\n    if ( utime(GetPath().c_str(), &times) != 0 ) {\n        LOG_ERROR_AND_RETURN_ERRNO(15, \"CDirEntry::SetTimeT(): Cannot change time for \" + GetPath());\n    }\n    return true;\n\n#endif\n}\n\n\nbool CDirEntry::Stat(struct SStat *buffer, EFollowLinks follow_links) const\n{\n    if ( !buffer ) {\n        errno = EFAULT;\n        LOG_ERROR_AND_RETURN_ERRNO(16, \"CDirEntry::Stat(): NULL stat buffer passed for \" + GetPath());\n    }\n\n    int errcode;\n#ifdef NCBI_OS_MSWIN\n    errcode = NcbiSys_stat(_T_XCSTRING(GetPath()), &buffer->orig);\n#else // NCBI_OS_UNIX\n    if (follow_links == eFollowLinks) {\n        errcode = stat(GetPath().c_str(), &buffer->orig);\n    } else {\n        errcode = lstat(GetPath().c_str(), &buffer->orig);\n    }\n#endif\n    if (errcode != 0) {\n        CNcbiError::SetFromErrno(GetPath());\n        return false;\n    }\n   \n    // Assign additional fields\n    buffer->atime_nsec = 0;\n    buffer->mtime_nsec = 0;\n    buffer->ctime_nsec = 0;\n    \n#ifdef NCBI_OS_UNIX\n    // UNIX:\n    // Some systems have additional fields in the stat structure to store\n    // nanoseconds. If you know one more platform which have nanoseconds\n    // support for file times, add it here.\n\n#  if !defined(__GLIBC_PREREQ)\n#    define __GLIBC_PREREQ(x, y) 0\n#  endif\n\n#  if defined(NCBI_OS_LINUX)  &&  __GLIBC_PREREQ(2,3)\n#    if defined(__USE_MISC)\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atimensec;\n    buffer->mtime_nsec = buffer->orig.st_mtimensec;\n    buffer->ctime_nsec = buffer->orig.st_ctimensec;\n#    endif\n#  endif\n\n\n#  if defined(NCBI_OS_SOLARIS)\n#    if !defined(_XOPEN_SOURCE) && !defined(_POSIX_C_SOURCE) || \\\n     defined(__EXTENSIONS__)\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atim.__tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.__tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.__tv_nsec;\n#    endif\n#  endif\n\n   \n#  if defined(NCBI_OS_BSD) || defined(NCBI_OS_DARWIN)\n#    if defined(_POSIX_SOURCE)\n    buffer->atime_nsec = buffer->orig.st_atimensec;\n    buffer->mtime_nsec = buffer->orig.st_mtimensec;\n    buffer->ctime_nsec = buffer->orig.st_ctimensec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atimespec.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtimespec.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctimespec.tv_nsec;\n#    endif\n#  endif\n\n\n#  if defined(NCBI_OS_IRIX)\n#    if defined(tv_sec)\n    buffer->atime_nsec = buffer->orig.st_atim.__tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.__tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.__tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    endif\n#  endif\n    \n#endif  // NCBI_OS_UNIX\n\n    return true;\n}\n\n\nCDirEntry::EType CDirEntry::GetType(EFollowLinks follow) const\n{\n    TNcbiSys_stat st;\n    int errcode;\n\n#if defined(NCBI_OS_MSWIN)\n    errcode = NcbiSys_stat(_T_XCSTRING(GetPath()), &st);\n    if (errcode != 0) {\n        // Make additional checks for UNC paths, because \n        // stat() cannot handle path that looks like \\\\Server\\Share.\n        if (s_Win_IsNetworkPath(GetPath())) {\n            DWORD attr = GetFileAttributes(_T_XCSTRING(GetPath()));\n            if (attr == INVALID_FILE_ATTRIBUTES) {\n                CNcbiError::SetFromWindowsError(GetPath());\n                return eUnknown;\n            }\n            if ( F_ISSET(attr, FILE_ATTRIBUTE_DIRECTORY) ) {\n                return eDir;\n            }\n            return eFile;\n        }\n    }\n#else // NCBI_OS_UNIX\n    if (follow == eFollowLinks) {\n        errcode = stat(GetPath().c_str(), &st);\n    } else {\n        errcode = lstat(GetPath().c_str(), &st);\n    }\n#endif\n    if (errcode != 0) {\n        CNcbiError::SetFromErrno(GetPath());\n        return eUnknown;\n    }\n    return GetType(st);\n}\n\n\n/// Test macro for file types\n#define NCBI_IS_TYPE(mode, mask)  (((mode) & S_IFMT) == (mask))\n\nCDirEntry::EType CDirEntry::GetType(const TNcbiSys_stat& st)\n{\n    unsigned int mode = (unsigned int)st.st_mode;\n\n#ifdef S_ISDIR\n    if (S_ISDIR(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFDIR))\n#endif\n        return eDir;\n\n#ifdef S_ISCHR\n    if (S_ISCHR(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFCHR))\n#endif\n        return eCharSpecial;\n\n#ifdef NCBI_OS_MSWIN\n    if (NCBI_IS_TYPE(mode, _S_IFIFO))\n        return ePipe;\n#else\n    // NCBI_OS_UNIX\n#  ifdef S_ISFIFO\n    if (S_ISFIFO(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFIFO))\n#  endif\n        return ePipe;\n\n#  ifdef S_ISLNK\n    if (S_ISLNK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFLNK))\n#  endif\n        return eLink;\n\n#  ifdef S_ISSOCK\n    if (S_ISSOCK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFSOCK))\n#  endif\n        return eSocket;\n\n#  ifdef S_ISBLK\n    if (S_ISBLK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFBLK))\n#  endif\n        return eBlockSpecial;\n\n#  ifdef S_IFDOOR \n    // only Solaris seems to have this one\n#    ifdef S_ISDOOR\n    if (S_ISDOOR(mode))\n#    else\n    if (NCBI_IS_TYPE(mode, S_IFDOOR))\n#    endif\n        return eDoor;\n#  endif\n\n#endif //NCBI_OS_MSWIN\n\n    // Check on regular file last\n#ifdef S_ISREG\n    if (S_ISREG(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFREG))\n#endif\n        return eFile;\n\n    return eUnknown;\n}\n\n\n#if defined(NCBI_OS_MSWIN)\n\n// Windows-specific implementation. See default implementation in the .hpp file\nbool CDirEntry::Exists(void) const\n{\n    HANDLE h = CreateFile(_T_XCSTRING(GetPath()),\n                          GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n                          OPEN_EXISTING,\n                          FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL);\n    if (h == INVALID_HANDLE_VALUE) {\n        return false;\n    }\n    CloseHandle(h);\n    return true;\n}\n\n#endif\n\n\nstring CDirEntry::LookupLink(void) const\n{\n#ifdef NCBI_OS_MSWIN\n    return kEmptyStr;\n\n#else  // NCBI_OS_UNIX\n    char buf[PATH_MAX];\n    string name;\n    int length = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf));\n    if (length > 0) {\n        name.assign(buf, length);\n    }\n    return name;\n#endif\n}\n\n\nvoid CDirEntry::DereferenceLink(ENormalizePath normalize)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    string prev;\n    while ( IsLink() ) {\n        string name = LookupLink();\n        if ( name.empty() ||  name == prev ) {\n            return;\n        }\n        prev = name;\n        if ( IsAbsolutePath(name) ) {\n            Reset(name);\n        } else {\n            string path = MakePath(GetDir(), name);\n            if (normalize == eNormalizePath) {\n                Reset(NormalizePath(path));\n            } else {\n                Reset(path);\n            }\n        }\n    }\n}\n\n\nvoid s_DereferencePath(CDirEntry& entry)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    // Dereference each path components starting from last one\n    entry.DereferenceLink(eNotNormalizePath);\n\n    // Get dir and file names\n    string path = entry.GetPath();\n    size_t pos = path.find_last_of(ALL_SEPARATORS);\n    if (pos == NPOS) {\n        return; \n    }\n    string filename = path.substr(pos+1);\n    string dirname  = path.substr(0, pos);\n    if ( dirname.empty() ) {\n        return;\n    }\n    // Dereference path one level up\n    entry.Reset(dirname);\n    s_DereferencePath(entry);\n    // Create new path\n    entry.Reset(CDirEntry::MakePath(entry.GetPath(), filename));\n}\n\n\nvoid CDirEntry::DereferencePath(void)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    // Use s_DereferencePath() recursively and normalize result only once\n    CDirEntry e(GetPath());\n    s_DereferencePath(e);\n    Reset(NormalizePath(e.GetPath()));\n}\n\n\nbool CDirEntry::Copy(const string& path, TCopyFlags flags, size_t buf_size)\n    const\n{\n    // Dereference link if specified\n    bool follow = F_ISSET(flags, fCF_FollowLinks);\n    EType type = GetType(follow ? eFollowLinks : eIgnoreLinks);\n    switch (type) {\n        case eFile:\n            return CFile(GetPath()).Copy(path, flags, buf_size);\n        case eDir: \n            return CDir(GetPath()).Copy(path, flags, buf_size);\n        case eLink:\n            return CSymLink(GetPath()).Copy(path, flags, buf_size);\n        case eUnknown:\n            {\n                CNcbiError::Set(CNcbiError::eNoSuchFileOrDirectory, GetPath());\n                return false;\n            }\n        default:\n            CNcbiError::Set(CNcbiError::eNotSupported, GetPath());\n            break;\n    }\n    // We \"don't know\" how to copy entry of other type, by default.\n    // Use overloaded Copy() method in derived classes.\n    return (flags & fCF_SkipUnsupported) == fCF_SkipUnsupported;\n}\n\n\nbool CDirEntry::Rename(const string& newname, TRenameFlags flags)\n{\n    CDirEntry src(*this);\n    CDirEntry dst(newname);\n\n    // Dereference links\n    if ( F_ISSET(flags, fRF_FollowLinks) ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source entry must exists\n    EType src_type = src.GetType();\n    if ( src_type == eUnknown ) {\n        LOG_ERROR_AND_RETURN_NCBI(17, \"CDirEntry::Rename():\"\n                                      \" Source path does not exist: \" + src.GetPath(),\n                                      CNcbiError::eNoSuchFileOrDirectory);\n    }\n\n    // Try to \"move\" in one atomic operation if possible to avoid race\n    // conditions between check on destination existence and renaming.\n\n#ifdef NCBI_OS_MSWIN\n    // On Windows we can try to move file or whole directory, even across volumes\n    if ( MoveFileEx(_T_XCSTRING(src.GetPath()),\n                    _T_XCSTRING(dst.GetPath()), MOVEFILE_COPY_ALLOWED) ) {\n        Reset(newname);\n        return true;\n    }\n#else\n    // On Unix we can use \"link\" technique for files.\n    \n    // link() have dirrerent behavior on some flavors of Unix\n    // regarding symbolic links handling, and can automatically\n    // dereference both source and destination as POSIX required, \n    // or not (Linux with kernel 2.0 and up behavior).\n    // We need to rename symlink itself, if not dereferenced yet\n    // (see fRF_FollowLinks), and the destination should remain\n    // a symlink. So just dont use link() in this case and,\n    // fall back to regular rename() instead.\n    \n    if ( src_type == eFile  && \n         link(_T_XCSTRING(src.GetPath()),\n              _T_XCSTRING(dst.GetPath())) == 0 ) {\n        // Hard link successfully created, so we can just remove source file\n        if ( src.RemoveEntry() ) {\n            Reset(newname);\n            return true;\n        }\n    }\n#endif\n    // On error, symlink, or destination existence --\n    // continue on regular processing below\n\n    EType dst_type = dst.GetType();\n\n    // If destination exists...\n\n    if ( dst_type != eUnknown ) {\n        // Can rename entries with different types?\n        if ( F_ISSET(flags, fRF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_AND_RETURN_NCBI(18, \"CDirEntry::Rename():\"\n                                          \" Both source and destination exist\"\n                                          \" and have different types: \"\n                                          + src.GetPath() + \" and \" + dst.GetPath(),\n                                          CNcbiError::eOperationNotPermitted);\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fRF_Overwrite) ) {\n            LOG_ERROR_AND_RETURN_NCBI(19, \"CDirEntry::Rename():\"\n                                          \" Destination path already exists: \"\n                                          + dst.GetPath(), \n                                          CNcbiError::eOperationNotPermitted);\n        }\n        // Rename only if destination is older, otherwise just remove source\n        if ( F_ISSET(flags, fRF_Update)  &&  !src.IsNewer(dst.GetPath(), 0)) {\n            return src.Remove();\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fRF_Backup) ) {\n            // Use new CDirEntry object instead of 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR_AND_RETURN(20, \"CDirEntry::Rename(): Cannot backup \" + dst.GetPath());\n            }\n        }\n        // Overwrite destination entry\n        if ( F_ISSET(flags, fRF_Overwrite) ) {\n            if ( dst.Exists() ) {\n                dst.Remove();\n            }\n        }\n    }\n\n    // On some platform rename() fails if destination entry exists, \n    // on others it can overwrite destination.\n    // For consistency return FALSE if destination already exists.\n    if ( dst.Exists() ) {\n        // this means Remove has failed, and error is set already\n        LOG_ERROR_AND_RETURN(21, \"CDirEntry::Rename(): Destination path exists: \" + GetPath());\n    }\n    \n    // Rename\n    \n    if ( NcbiSys_rename(_T_XCSTRING(src.GetPath()),\n                        _T_XCSTRING(dst.GetPath())) != 0 ) {\n#ifdef NCBI_OS_MSWIN\n        if ( errno != EACCES ) {\n#else\n        if ( errno != EXDEV ) {\n#endif\n            LOG_ERROR_AND_RETURN_ERRNO(21, \"CDirEntry::Rename(): rename() failed for \" + GetPath());\n        }\n        // Note that rename() fails in the case of cross-device renaming.\n        // So, try to make a copy and remove the original later.\n        unique_ptr<CDirEntry> e(CDirEntry::CreateObject(src_type, src.GetPath()));\n        if ( !e->Copy(dst.GetPath(), fCF_Recursive | fCF_PreserveAll ) ) {\n            unique_ptr<CDirEntry> tmp(CDirEntry::CreateObject(src_type, dst.GetPath()));\n            tmp->Remove(eRecursive);\n            return false;\n        }\n        // Remove 'src'\n        if ( !e->Remove(eRecursive) ) {\n            // Do not delete 'dst' here because in case of directories the\n            // source may be already partially removed, so we can lose data.\n            return false;\n        }\n    }\n    Reset(newname);\n    return true;\n}\n\n\nbool CDirEntry::Remove(TRemoveFlags flags) const\n{\n    // Is this a directory ? (and processing not entry only)\n    if ( (flags & (fDir_All | fDir_Recursive)) != eEntryOnly  &&  IsDir(eIgnoreLinks) ) {\n        return CDir(GetPath()).Remove(flags);\n    }\n    // Other entries\n    return RemoveEntry(flags);\n}\n\n\nbool CDirEntry::RemoveEntry(TRemoveFlags flags) const\n{\n    if ( NcbiSys_remove(_T_XCSTRING(GetPath())) != 0 ) {\n        switch (errno) {\n        case ENOENT:\n            if ( flags & fIgnoreMissing )\n                return true;\n            break;\n\n#if defined(NCBI_OS_MSWIN)\n        case EACCES:\n            if ( NCBI_PARAM_TYPE(NCBI, DeleteReadOnlyFiles)::GetDefault() ) {\n                SetModeEntry(fDefault);\n                if ( NcbiSys_remove(_T_XCSTRING(GetPath())) == 0 ) {\n                    return true;\n                }\n            }\n#endif\n        }\n        LOG_ERROR_AND_RETURN_ERRNO(22, \"CDirEntry::RemoveEntry(): remove() failed for \" + GetPath());\n    }\n    return true;\n}\n\n\nbool CDirEntry::Backup(const string& suffix, EBackupMode mode,\n                       TCopyFlags copyflags, size_t copybufsize)\n{\n    string backup_name = DeleteTrailingPathSeparator(GetPath()) +\n                         (suffix.empty() ? string(GetBackupSuffix()) : suffix);\n    switch (mode) {\n        case eBackup_Copy:\n            {\n                TCopyFlags flags = copyflags;\n                flags &= ~(fCF_Update | fCF_Backup);\n                flags |=  (fCF_Overwrite | fCF_TopDirOnly);\n                return Copy(backup_name, flags, copybufsize);\n            }\n        case eBackup_Rename:\n            return Rename(backup_name, fRF_Overwrite);\n        default:\n            _TROUBLE;\n    }\n    CNcbiError::Set(CNcbiError::eInvalidArgument);\n    return false;\n}\n\n\nbool CDirEntry::IsNewer(const string& entry_name, TIfAbsent2 if_absent) const\n{\n    CDirEntry entry(entry_name);\n    CTime this_time;\n    CTime entry_time;\n    int v = 0;\n\n    if ( !GetTime(&this_time) ) {\n        v += 1;\n    }\n    if ( !entry.GetTime(&entry_time) ) {\n        v += 2;\n    }\n    if ( v == 0 ) {\n        return this_time > entry_time;\n    }\n    if ( if_absent ) {\n        switch(v) {\n        case 1:  // NoThis - HasPath\n            if ( if_absent &\n                 (fNoThisHasPath_Newer | fNoThisHasPath_NotNewer) )\n                return (if_absent & fNoThisHasPath_Newer) > 0;\n            break;\n        case 2:  // HasThis - NoPath\n            if ( if_absent &\n                 (fHasThisNoPath_Newer | fHasThisNoPath_NotNewer) )\n                return (if_absent & fHasThisNoPath_Newer) > 0;\n            break;\n        case 3:  // NoThis - NoPath\n            if ( if_absent &\n                 (fNoThisNoPath_Newer | fNoThisNoPath_NotNewer) )\n                return (if_absent & fNoThisNoPath_Newer) > 0;\n            break;\n        }\n    }\n    // throw an exception by default\n    NCBI_THROW(CFileException, eNotExists, \n               \"Directory entry does not exist\");\n    /*NOTREACHED*/\n    return false;\n}\n\n\nbool CDirEntry::IsNewer(time_t tm, EIfAbsent if_absent) const\n{\n    time_t current;\n    if ( !GetTimeT(&current) ) {\n        switch(if_absent) {\n        case eIfAbsent_Newer:\n            return true;\n        case eIfAbsent_NotNewer:\n            return false;\n        case eIfAbsent_Throw:\n        default:\n            NCBI_THROW(CFileException, eNotExists,\n                       \"Directory entry does not exist\");\n        }\n    }\n    return current > tm;\n}\n\n\nbool CDirEntry::IsNewer(const CTime& tm, EIfAbsent if_absent) const\n{\n    CTime current;\n    if ( !GetTime(&current) ) {\n        switch(if_absent) {\n        case eIfAbsent_Newer:\n            return true;\n        case eIfAbsent_NotNewer:\n            return false;\n        case eIfAbsent_Throw:\n        default:\n            NCBI_THROW(CFileException, eNotExists, \n                       \"Directory entry does not exist\");\n        }\n    }\n    return current > tm;\n}\n\n\nbool CDirEntry::IsIdentical(const string& entry_name,\n                            EFollowLinks  follow_links) const\n{\n#if defined(NCBI_OS_UNIX)\n    struct SStat st1, st2;\n    if ( !Stat(&st1, follow_links) ) {\n        LOG_ERROR_AND_RETURN_ERRNO(23, \"CDirEntry::IsIdentical(): Cannot find \" + GetPath());\n    }\n    if ( !CDirEntry(entry_name).Stat(&st2, follow_links) ) {\n        LOG_ERROR_AND_RETURN_ERRNO(23, \"CDirEntry::IsIdentical(): Cannot find \" + entry_name);\n    }\n    return st1.orig.st_dev == st2.orig.st_dev  &&\n           st1.orig.st_ino == st2.orig.st_ino;\n#else\n    return NormalizePath(GetPath(),  follow_links) ==\n           NormalizePath(entry_name, follow_links);\n#endif\n}\n\n\nbool CDirEntry::GetOwner(string* owner, string* group,\n                         EFollowLinks follow, \n                         unsigned int* uid, unsigned int* gid) const\n{\n    if ( !owner  &&  !group ) {\n        CNcbiError::Set(CNcbiError::eInvalidArgument);\n        return false;\n    }\n\n#if defined(NCBI_OS_MSWIN)\n\n    return CWinSecurity::GetFileOwner(GetPath(), owner, group, uid, gid);\n\n#elif defined(NCBI_OS_UNIX)\n    struct stat st;\n    int errcode;\n    \n    if ( follow == eFollowLinks ) {\n        errcode = stat (GetPath().c_str(), &st);\n    } else {\n        errcode = lstat(GetPath().c_str(), &st);\n    }\n    if ( errcode != 0 ) {\n        LOG_ERROR_AND_RETURN_ERRNO(24, \"CDirEntry::GetOwner(): stat() failed for \" + GetPath());\n    }\n\n    if ( uid ) {\n        *uid = st.st_uid;\n    }\n    if ( gid ) {\n        *gid = st.st_gid;\n    }\n\n    if ( owner ) {\n        CUnixFeature::GetUserNameByUID(st.st_uid).swap(*owner);\n        if (owner->empty()) {\n            NStr::NumericToString(*owner, st.st_uid, 0 /* flags */, 10);\n        }\n    }\n    if ( group ) {\n        CUnixFeature::GetGroupNameByGID(st.st_gid).swap(*group);\n        if (group->empty()) {\n            NStr::NumericToString(*group, st.st_gid, 0 /* flags */, 10);\n        }\n    }\n\n    return true;\n\n#endif\n}\n\n\nbool CDirEntry::SetOwner(const string& owner, const string& group,\n                         EFollowLinks follow,\n                         unsigned int* uid, unsigned int* gid) const\n{\n    if ( gid ) *gid = 0;\n    if ( uid ) *uid = 0;\n\n    if ( owner.empty()  &&  group.empty() ) {\n        CNcbiError::Set(CNcbiError::eInvalidArgument);\n        return false;\n    }\n\n#if defined(NCBI_OS_MSWIN)\n\n    return CWinSecurity::SetFileOwner(GetPath(), owner, group, uid, gid);\n\n#elif defined(NCBI_OS_UNIX)\n\n    uid_t temp_uid;\n    if ( !owner.empty() ) {\n        temp_uid = CUnixFeature::GetUserUIDByName(owner);\n        if (temp_uid == (uid_t)(-1)){\n            unsigned int temp;\n            if (!NStr::StringToNumeric(owner,\n                                       &temp, NStr::fConvErr_NoThrow, 0)) {\n                LOG_ERROR_AND_RETURN_ERRNO(25, \"CDirEntry::SetOwner(): Invalid owner name \" + owner);\n            }\n            temp_uid = (uid_t) temp;\n        }\n        if ( uid ) {\n            *uid = temp_uid;\n        }\n    } else {\n        temp_uid = (uid_t)(-1);\n    }\n\n    gid_t temp_gid;\n    if ( !group.empty() ) {\n        temp_gid = CUnixFeature::GetGroupGIDByName(group);\n        if (temp_gid == (gid_t)(-1)) {\n            unsigned int temp;\n            if (!NStr::StringToNumeric(group,\n                                       &temp, NStr::fConvErr_NoThrow, 0)) {\n                LOG_ERROR_AND_RETURN_ERRNO(26, \"CDirEntry::SetOwner(): Invalid group name \" + group);\n            }\n            temp_gid = (gid_t) temp;\n        }\n        if ( gid ) {\n            *gid = temp_gid;\n        }\n    } else {\n        temp_gid = (gid_t)(-1);\n    }\n\n    if (follow == eFollowLinks  ||  GetType(eIgnoreLinks) != eLink) {\n        if ( chown(GetPath().c_str(), temp_uid, temp_gid) ) {\n            LOG_ERROR_AND_RETURN_ERRNO(27, \"CDirEntry::SetOwner(): Cannot change owner for \" + GetPath());\n        }\n    }\n#  if defined(HAVE_LCHOWN)\n    else {\n        if ( lchown(GetPath().c_str(), temp_uid, temp_gid) ) {\n            LOG_ERROR_AND_RETURN_ERRNO(28, \"CDirEntry::SetOwner(): Cannot change symlink owner for \" + GetPath());\n        }\n    }\n#  endif\n\n    return true;\n#endif\n}\n\n\nstring CDirEntry::GetTmpName(ETmpFileCreationMode mode)\n{\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    return GetTmpNameEx(kEmptyStr, kEmptyStr, mode);\n#else\n    if (mode == eTmpFileCreate) {\n        ERR_POST_X(2, Warning << \n                   \"Temporary file cannot be auto-created on this platform, \"\n                   \"return its name only\");\n    }\n    TXChar* filename = NcbiSys_tempnam(0,0);\n    if ( !filename ) {\n        return kEmptyStr;\n    }\n    string res(_T_CSTRING(filename));\n    free(filename);\n    return res;\n#endif\n}\n\n\n#if !defined(NCBI_OS_UNIX)  &&  !defined(NCBI_OS_MSWIN)\nstatic string s_StdGetTmpName(const char* dir, const char* prefix)\n{\n    char* filename = tempnam(dir, prefix);\n    if ( !filename ) {\n        return kEmptyStr;\n    }\n    string str(filename);\n    free(filename);\n    return str;\n}\n#endif\n\n\nstring CDirEntry::GetTmpNameEx(const string&        dir,\n                               const string&        prefix,\n                               ETmpFileCreationMode mode)\n{\n    CFileIO temp_file;\n\n    temp_file.CreateTemporary(dir, prefix, mode == eTmpFileCreate ?\n        CFileIO::eDoNotRemove : CFileIO::eRemoveInClose);\n    temp_file.Close();\n\n    return temp_file.GetPathname();\n}\n\n\nclass CTmpStream : public fstream\n{\npublic:\n\n    CTmpStream(const char* s, IOS_BASE::openmode mode) : fstream(s, mode)\n    {\n        m_FileName = s;\n        // Try to remove file and OS will automatically delete it after\n        // the last file descriptor to it is closed (works only on UNIXes)\n        CFile(m_FileName).Remove();\n    }\n\n#if defined(NCBI_OS_MSWIN)\n    CTmpStream(const char* s, FILE* file) : fstream(file)\n    {\n        m_FileName = s; \n    }\n#endif    \n\n    virtual ~CTmpStream(void) \n    { \n        close();\n        if ( !m_FileName.empty() ) {\n            CFile(m_FileName).Remove();\n        }\n    }\n\nprotected:\n    string m_FileName;  // Temporary file name\n};\n\n\nfstream* CDirEntry::CreateTmpFile(const string& filename, \n                                  ETextBinary   text_binary,\n                                  EAllowRead    allow_read)\n{\n    string tmpname = filename.empty() ? GetTmpName(eTmpFileCreate) : filename;\n    if ( tmpname.empty() ) {\n        string msg(\"CDirEntry::CreateTmpFile(): Cannot get temporary file name\");\n        LOG_ERROR(29, msg);\n        CNcbiError::Set(CNcbiError::eNoSuchFileOrDirectory, msg);\n        return 0;\n    }\n#if defined(NCBI_OS_MSWIN)\n    // Open file manually, because we cannot say to fstream\n    // to use some specific flags for file opening.\n    // MS Windows should delete created file automatically\n    // after closing all opened file descriptors.\n\n    // We cannot enable \"only write\" mode here,\n    // so ignore 'allow_read' flag.\n    // Specify 'TD' (_O_SHORT_LIVED | _O_TEMPORARY)\n    char mode[6] = \"w+TDb\";\n    if (text_binary != eBinary) {\n        mode[4] = '\\0';\n    }\n    FILE* file = NcbiSys_fopen(_T_XCSTRING(tmpname),\n                               _T_XCSTRING(mode));\n\n    if ( !file ) {\n        CNcbiError::SetFromErrno(tmpname);\n        return 0;\n    }\n    // Create FILE* based fstream.\n    fstream* stream = new CTmpStream(tmpname.c_str(), file);\n    // We dont need to close FILE*, it will be closed in the fstream\n\n#else\n    // Create filename based fstream\n    ios::openmode mode = ios::out | ios::trunc;\n    if ( text_binary == eBinary ) {\n        mode = mode | ios::binary;\n    }\n    if ( allow_read == eAllowRead ) {\n        mode = mode | ios::in;\n    }\n    fstream* stream = new CTmpStream(tmpname.c_str(), mode);\n#endif\n\n    if ( !stream->good() ) {\n        delete stream;\n        CNcbiError::Set(CNcbiError::eNoSuchFileOrDirectory, tmpname);\n        return 0;\n    }\n    return stream;\n}\n\n\nfstream* CDirEntry::CreateTmpFileEx(const string& dir, const string& prefix,\n                                    ETextBinary text_binary, \n                                    EAllowRead allow_read)\n{\n    return CreateTmpFile(GetTmpNameEx(dir, prefix, eTmpFileCreate),\n                         text_binary, allow_read);\n}\n\n\n// Helper: Copy attributes (owner/date/time) from one entry to another.\n// Both entries should have equal type.\n//\n// UNIX:\n//     In mostly cases only super-user can change owner for\n//     destination entry.  The owner of a file may change the group of\n//     the file to any group of which that owner is a member.\n// WINDOWS:\n//     This function doesn't support ownership change yet.\n//\nstatic bool s_CopyAttrs(const char* from, const char* to,\n                        CDirEntry::EType type, CDirEntry::TCopyFlags flags)\n{\n#if defined(NCBI_OS_UNIX)\n\n    CDirEntry::SStat st;\n    if ( !CDirEntry(from).Stat(&st) ) {\n        LOG_ERROR_AND_RETURN_ERRNO(30, string(\"CDirEntry::s_CopyAttrs():\") + \" stat() failed for \" + from);\n    }\n\n    // Date/time.\n    // Set time before chmod() call, because on some platforms\n    // setting time can affect file mode also.\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveTime) ) {\n#  if defined(HAVE_UTIMES)\n        struct timeval tvp[2];\n        tvp[0].tv_sec  = st.orig.st_atime;\n        tvp[0].tv_usec = st.atime_nsec / 1000;\n        tvp[1].tv_sec  = st.orig.st_mtime;\n        tvp[1].tv_usec = st.mtime_nsec / 1000;\n#    if defined(HAVE_LUTIMES)\n        if (lutimes(to, tvp)) {\n            LOG_ERROR_AND_RETURN_ERRNO(31, string(\"CDirEntry::s_CopyAttrs():\") + \" lutimes() failed for \" + to);\n        }\n#    else\n        if (utimes(to, tvp)) {\n            LOG_ERROR_AND_RETURN_ERRNO(32, string(\"CDirEntry::s_CopyAttrs():\") + \" utimes() failed for \" + to);\n        }\n#    endif\n# else  // !HAVE_UTIMES\n        // utimes() does not exists on current platform,\n        // so use less accurate utime().\n        struct utimbuf times;\n        times.actime  = st.orig.st_atime;\n        times.modtime = st.orig.st_mtime;\n        if (utime(to, &times)) {\n            LOG_ERROR_AND_RETURN_ERRNO(33, string(\"CDirEntry::s_CopyAttrs():\") + \" utime() failed for \" + to);\n        }\n#  endif // HAVE_UTIMES\n    }\n\n    // Owner. \n    // To improve performance change it right here,\n    // do not use GetOwner/SetOwner.\n\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveOwner) ) {\n        if ( type == CDirEntry::eLink ) {\n#  if defined(HAVE_LCHOWN)\n            if ( lchown(to, st.orig.st_uid, st.orig.st_gid) ) {\n                if (errno != EPERM) {\n                    LOG_ERROR_AND_RETURN_ERRNO(34, string(\"CDirEntry::s_CopyAttrs():\") + \" lchown() failed for \" + to);\n                }\n            }\n#  endif\n            // We cannot change permissions for sym.links (below),\n            // so just exit from the function.\n            return true;\n        } else {\n            // Changing the ownership will probably fail, unless we're root.\n            // The setuid/gid bits can be cleared by OS.  If chown() fails,\n            // strip the setuid/gid bits.\n            if ( chown(to, st.orig.st_uid, st.orig.st_gid) ) {\n                if ( errno != EPERM ) {\n                    LOG_ERROR_AND_RETURN_ERRNO(35, string(\"CDirEntry::s_CopyAttrs():\") + \" chown() failed for \" + to);\n                }\n                st.orig.st_mode &= ~(S_ISUID | S_ISGID);\n            }\n        }\n    }\n\n    // Permissions\n    if ( F_ISSET(flags, CDirEntry::fCF_PreservePerm)  &&\n        type != CDirEntry::eLink ) {\n        if ( chmod(to, st.orig.st_mode) ) {\n            LOG_ERROR_AND_RETURN_ERRNO(36, string(\"CDirEntry::s_CopyAttrs():\") + \" chmod() failed for \" + to);\n        }\n    }\n    return true;\n\n\n#elif defined(NCBI_OS_MSWIN)\n\n    CDirEntry efrom(from), eto(to);\n\n    WIN32_FILE_ATTRIBUTE_DATA attr;\n    if ( !::GetFileAttributesEx(_T_XCSTRING(from), GetFileExInfoStandard, &attr) ) {\n        CNcbiError::SetFromWindowsError();\n        return false;\n    }\n\n    // Date/time\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveTime) ) {\n        HANDLE h = CreateFile(_T_XCSTRING(to),\n                              FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL,\n                              OPEN_EXISTING,\n                              FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n        if ( h == INVALID_HANDLE_VALUE ) {\n            LOG_ERROR_AND_RETURN_WIN(37, string(\"CDirEntry::s_CopyAttrs():\")  + \" Cannot open \" + to);\n        }\n        if ( !SetFileTime(h, &attr.ftCreationTime, &attr.ftLastAccessTime, &attr.ftLastWriteTime) ) {\n            CloseHandle(h);\n            LOG_ERROR_AND_RETURN_WIN(38, string(\"CDirEntry::s_CopyAttrs():\") + \" Cannot change time for \" + to);\n        }\n        CloseHandle(h);\n    }\n\n    // Permissions\n    if ( F_ISSET(flags, CDirEntry::fCF_PreservePerm) ) {\n        if ( !::SetFileAttributes(_T_XCSTRING(to), attr.dwFileAttributes) ) {\n            LOG_ERROR_AND_RETURN_WIN(39, string(\"CDirEntry::s_CopyAttrs():\") + \" Cannot change pemissions for \" + to);\n        }\n    }\n\n    // Owner\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveOwner) ) {\n        string owner, group;\n        // We don't check the result here, because often is impossible\n        // to set the original owner name without administrator's rights.\n        if ( efrom.GetOwner(&owner, &group) ) {\n            eto.SetOwner(owner, group);\n        }\n    }\n\n    return true;\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFile\n//\n\n\nCFile::~CFile(void)\n{ \n    return;\n}\n\n\nInt8 CFile::GetLength(void) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0  ||\n        GetType(st) != eFile ) {\n        //LOG_ERROR(40, \"CFile:GetLength(): stat() failed for \" << GetPath());\n        CNcbiError::SetFromErrno(GetPath());\n        return -1L;\n    }\n    return st.st_size;\n}\n\n\n#if !defined(NCBI_OS_MSWIN)\n\n// Close file handle\n//\nstatic int s_CloseFile(int fd)\n{\n    while (close(fd) != 0) {\n        if (errno != EINTR)\n            return errno;\n    }\n    // Success\n    return 0; \n}\n\n\n// Copy file \"src\" to \"dst\"\n//\nstatic bool s_CopyFile(const char* src, const char* dst, size_t buf_size)\n{\n    int fs;  // source file descriptor\n    int fd;  // destination file descriptor\n    \n    if ((fs = open(src, O_RDONLY)) == -1) {\n        CNcbiError::SetFromErrno(src);\n        return false;\n    }\n\n    struct stat st;\n    if (fstat(fs, &st) != 0  ||\n        (fd = open(dst, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777)) == -1) {\n        int x_errno = errno;\n        s_CloseFile(fs);\n        CNcbiError::SetErrno(errno = x_errno, src);\n        return false;\n    }\n\n    // To prevent unnecessary memory (re-)allocations,\n    // use the on-stack buffer if either the specified\n    // \"buf_size\" or the size of the copied file is small.\n    char  x_buf[4096];\n    char* buf;\n\n    if (3 * sizeof(x_buf) >= (Uint8) st.st_size) {\n        // Use on-stack buffer for any files smaller than 3x of buffer size.\n        buf_size = sizeof(x_buf);\n        buf = x_buf;\n    } else {\n        if (buf_size == 0) {\n            buf_size = kDefaultBufferSize;\n        }\n        // Use allocated buffer no bigger than the size of the file to copy.\n        if (buf_size > (Uint8) st.st_size) {\n            buf_size = st.st_size;\n        }\n        buf = buf_size > sizeof(x_buf) ? new char[buf_size] : x_buf;\n    }\n\n    // Copy files\n    int x_errno = 0;\n    do {\n        ssize_t n_read = read(fs, buf, buf_size);\n        if (n_read == 0) {\n            break;\n        }\n        if (n_read < 0) {\n            if (errno == EINTR) {\n                continue;\n            }\n            x_errno = errno;\n            break;\n        }\n        // Write to the output file\n        const char* ptr = buf;\n        do {\n            ssize_t n_written = write(fd, ptr, n_read);\n            if (n_written == 0) {\n                x_errno = EINVAL;\n                break;\n            }\n            if ( n_written < 0 ) {\n                if (errno == EINTR) {\n                    continue;\n                }\n                x_errno = errno;\n                break;\n            }\n            n_read -= n_written;\n            ptr    += n_written;\n        } while (n_read > 0);\n        \n        if (n_read != 0) {\n            if (x_errno == 0) {\n                x_errno = EIO;\n            }\n        }\n    } while (!x_errno);\n\n    s_CloseFile(fs);\n    int xx_err = s_CloseFile(fd);\n    if (x_errno == 0) {\n        x_errno = xx_err;\n    }\n    if (buf != x_buf) {\n        delete [] buf;\n    }\n    if (x_errno != 0) {\n        CNcbiError::SetErrno(errno = x_errno, src);\n        return false;\n    }\n    return true;\n}\n\n#endif\n\n\nbool CFile::Copy(const string& newname, TCopyFlags flags, size_t buf_size) const\n{\n    CFile src(*this);\n    CFile dst(newname);\n\n    // Dereference links\n    if ( F_ISSET(flags, fCF_FollowLinks) ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source file must exists\n    EType src_type = src.GetType();\n    if ( src_type != eFile )  {\n        LOG_ERROR_AND_RETURN_NCBI(41, \"CFile::Copy():\"\n                                      \" Source is not a file: \" + GetPath(),\n                                      CNcbiError::eNoSuchFileOrDirectory);\n    }\n\n    EType  dst_type   = dst.GetType();\n    bool   dst_exists = (dst_type != eUnknown);\n    string dst_safe_path;  // saved path for fCF_Safe\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // UNIX: check on copying file into yourself.\n        // MS Window's ::CopyFile() can recognize such case.\n#if defined(NCBI_OS_UNIX)\n        if ( src.IsIdentical(dst.GetPath()) ) {\n            CNcbiError::Set(CNcbiError::eInvalidArgument, newname + \": cannot copy into itself\");\n            return false;\n        }\n#endif\n        // Can copy entries with different types?\n        // Destination must be a file too.\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_AND_RETURN_NCBI(41, \"CFile::Copy(): Destination is not a file: \" + dst.GetPath(),\n                                      CNcbiError::eOperationNotPermitted);\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fCF_Overwrite) ) {\n            LOG_ERROR_AND_RETURN_NCBI(42, \"CFile::Copy(): Destination file exists: \" + dst.GetPath(), \n                                      CNcbiError::eOperationNotPermitted);\n        }\n        // Copy only if destination is older\n        if ( F_ISSET(flags, fCF_Update)  &&  !src.IsNewer(dst.GetPath(),0) ) {\n            return true;\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fCF_Backup) ) {\n            // Use new CDirEntry object for 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR_AND_RETURN(43, \"CFile::Copy(): Cannot backup \" + dst.GetPath());\n            }\n        }\n    }\n    // Safe copy -- copy to temporary file and rename later\n    if (F_ISSET(flags, fCF_Safe)) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n    }\n\n    // Copy\n#if defined(NCBI_OS_MSWIN)\n    if ( !::CopyFile(_T_XCSTRING(src.GetPath()),\n                     _T_XCSTRING(dst.GetPath()), FALSE) ) {\n        dst.RemoveEntry();\n        LOG_ERROR_AND_RETURN_WIN(44, \"CFile::Copy(): Cannot copy \" + src.GetPath() + \" to \" + dst.GetPath());\n    }\n#else\n    if ( !s_CopyFile(src.GetPath().c_str(), dst.GetPath().c_str(), buf_size) ){\n        dst.Remove();\n        LOG_ERROR_AND_RETURN(44, \"CFile::Copy(): Cannot copy \" << src.GetPath() << \" to \" + dst.GetPath());\n    }\n#endif\n\n    // Safe copy -- renaming\n    if (F_ISSET(flags, fCF_Safe)) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.RemoveEntry();\n            LOG_ERROR_AND_RETURN_NCBI(45, \"CFile:Copy():\"\n                                          \" Cannot rename temporary file \" + dst.GetPath() +\n                                          \" to \" + dst_safe_path, CNcbiError::eIoError);\n        }\n    }\n    // Verify copied data\n    if ( F_ISSET(flags, fCF_Verify)  &&  !src.Compare(dst.GetPath()) ) {\n        LOG_ERROR_AND_RETURN_NCBI(46, \"CFile::Copy(): Copy verification for \" + src.GetPath() + \n                                      \" and \" + dst.GetPath() + \" failed\", CNcbiError::eIoError);\n    }\n\n    // Preserve attributes\n    // s_CopyFile() preserve permissions on Unix, MS-Windows don't need it at all.\n\n#if defined(NCBI_OS_MSWIN)\n    // On MS Windows ::CopyFile() already preserved file attributes\n    // and all date/times.\n    flags &= ~(fCF_PreservePerm | fCF_PreserveTime);\n#endif\n    if ( flags & fCF_PreserveAll ) {\n        if ( !s_CopyAttrs(src.GetPath().c_str(),\n                          dst.GetPath().c_str(), eFile, flags) ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nbool CFile::Compare(const string& filename, size_t buf_size) const\n{\n    // To prevent unnecessary memory (re-)allocations,\n    // use the on-stack buffer if either the specified\n    // \"buf_size\" or the size of the compared files is small.\n    char   x_buf[4096*2];\n    size_t x_size = sizeof(x_buf)/2;\n    char*  buf1   = 0;\n    char*  buf2   = 0;\n    bool   equal  = false;\n    \n    try {\n        CFileIO f1;\n        CFileIO f2;\n        f1.Open(GetPath(), CFileIO::eOpen, CFileIO::eRead);\n        f2.Open(filename,  CFileIO::eOpen, CFileIO::eRead);\n \n        Uint8 s1 = f1.GetFileSize();\n        Uint8 s2 = f2.GetFileSize();\n        \n        // Files should have equal sizes\n        if (s1 != s2)\n            return false;\n        if (s1 == 0)\n            return true;\n\n        // Use on-stack buffer for any files smaller than 3x of buffer size.\n        if (s1 <= 3 * x_size) {\n            buf_size = x_size;\n            buf1 = x_buf;\n            buf2 = x_buf + x_size;\n        } else {\n            if (buf_size == 0) {\n                buf_size = kDefaultBufferSize;\n            }\n            // Use allocated buffer no bigger than the size of the file to compare.\n            // Align buffer in memory to 8 byte boundary.\n            if (buf_size > s1) {\n                buf_size = (size_t)s1 + (8 - s1 % 8);\n            }\n            if (buf_size > x_size) {\n                buf1 = new char[buf_size*2];\n                buf2 = buf1 + buf_size;\n            } else {\n                buf1 = x_buf;\n                buf2 = x_buf + x_size;\n            }\n        }\n\n        size_t n1 = 0;\n        size_t n2 = 0;\n        size_t s  = 0;\n\n        // Compare files\n        for (;;) {\n            size_t n;\n            if (n1 < buf_size) {\n                n = f1.Read(buf1 + n1, buf_size - n1);\n                if (n == 0) {\n                    break;\n                }\n                n1 += n;\n            }\n            if (n2 < buf_size) {\n                n = f2.Read(buf2 + n2, buf_size - n2);\n                if (n == 0) {\n                    break;\n                }\n                n2 += n;\n            }\n            size_t m = min(n1, n2);\n            if ( memcmp(buf1, buf2, m) != 0 ) {\n                break;\n            }\n            if (n1 > m) {\n                memmove(buf1, buf1 + m, n1 - m);\n                n1 -= m;\n            } else {\n                n1 = 0;\n            }\n            if (n2 > m) {\n                memmove(buf2, buf2 + m, n2 - m);\n                n2 -= m;\n            } else {\n                n2 = 0;\n            }\n            s += m;\n        }\n        equal = (s1 == s);\n    }\n    catch (const CFileErrnoException& ex) {\n        string msg = string(\"Error comparing file \") + GetPath() + \" and \" + filename + \" : \" + ex.what();\n        LOG_ERROR(47, msg);\n        CNcbiError::SetErrno(ex.GetErrno(), msg);\n    }\n    if (buf1 != x_buf) {\n        delete [] buf1;\n    }\n    return equal;\n}\n\n\nbool CFile::CompareTextContents(const string& file, ECompareText mode,\n                                size_t buf_size) const\n{\n    CNcbiIfstream f1(GetPath().c_str(), IOS_BASE::in);\n    CNcbiIfstream f2(file.c_str(),      IOS_BASE::in);\n\n    if ( !buf_size ) {\n        buf_size = kDefaultBufferSize;\n    }\n    return NcbiStreamCompareText(f1, f2, (ECompareTextMode)mode, (streamsize)buf_size);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CDir\n//\n\n#if defined(NCBI_OS_UNIX)\n\nstatic bool s_GetHomeByUID(string& home)\n{\n    // Get the info using user ID\n    struct passwd* pwd;\n\n    if ((pwd = getpwuid(getuid())) == 0) {\n        LOG_ERROR_AND_RETURN_ERRNO(48, \"s_GetHomeByUID(): getpwuid() failed\");\n    }\n    home = pwd->pw_dir;\n    return true;\n}\n\nstatic bool s_GetHomeByLOGIN(string& home)\n{\n    const TXChar* ptr = 0;\n    // Get user name\n    if ( !(ptr = NcbiSys_getenv(_TX(\"USER\"))) ) {\n        if ( !(ptr = NcbiSys_getenv(_TX(\"LOGNAME\"))) ) {\n            if ( !(ptr = getlogin()) ) {\n                LOG_ERROR_AND_RETURN_ERRNO(49, \"s_GetHomeByLOGIN(): Unable to get user name\");\n            }\n        }\n    }\n    // Get home dir for this user\n    struct passwd* pwd = getpwnam(ptr);\n    if ( !pwd ||  pwd->pw_dir[0] == '\\0') {\n        LOG_ERROR_AND_RETURN_ERRNO(50, \"s_GetHomeByLOGIN(): getpwnam() failed\");\n    }\n    home = pwd->pw_dir;\n    return true;\n}\n\n#endif // NCBI_OS_UNIX\n\n\nstring CDir::GetHome(void)\n{\n    string home;\n\n#if defined(NCBI_OS_MSWIN)\n    // Get home dir from environment variables\n    // like - C:\\Documents and Settings\\user\\Application Data\n    const TXChar* str = NcbiSys_getenv(_TX(\"APPDATA\"));\n    if ( str ) {\n        home = _T_CSTRING(str);\n    } else {\n        // like - C:\\Documents and Settings\\user\n        str = NcbiSys_getenv(_TX(\"USERPROFILE\"));\n        if ( str ) {\n            home = _T_CSTRING(str);\n        }\n    }\n#elif defined(NCBI_OS_UNIX)\n    // Try get home dir from environment variable\n    char* str = NcbiSys_getenv(_TX(\"HOME\"));\n    if ( str ) {\n        home = str;\n    } else {\n        // Try to retrieve the home dir -- first use user's ID,\n        // and if failed, then use user's login name.\n        if ( !s_GetHomeByUID(home) ) { \n            s_GetHomeByLOGIN(home);\n        }\n    }\n#endif \n\n    // Add trailing separator if needed\n    return AddTrailingPathSeparator(home);\n}\n\n\nstring CDir::GetTmpDir(void)\n{\n    string tmp;\n\n#if defined(NCBI_OS_UNIX)\n\n    char* tmpdir = getenv(\"TMPDIR\");\n    if ( tmpdir ) {\n        tmp = tmpdir;\n    } else  {\n#  if defined(P_tmpdir)\n        tmp = P_tmpdir;\n#  else\n        tmp = \"/tmp\";\n#  endif\n    }\n\n#elif defined(NCBI_OS_MSWIN)\n\n    const TXChar* tmpdir = NcbiSys_getenv(_TX(\"TEMP\"));\n    if ( tmpdir ) {\n        tmp = _T_CSTRING(tmpdir);\n    } else  {\n#  if defined(P_tmpdir)\n        tmp = P_tmpdir;\n#  else\n        tmp = CDir::GetHome();\n#  endif\n    }\n\n#endif\n\n    return tmp;\n}\n\n\nstring CDir::GetAppTmpDir(void)\n{\n    // Get application specific temporary directory name\n    string tmp = NCBI_PARAM_TYPE(NCBI, TmpDir)::GetThreadDefault();\n    if ( !tmp.empty() ) {\n        return tmp;\n    }\n    // Use default TMP directory specified by OS\n    return CDir::GetTmpDir();\n}\n\n\nstring CDir::GetCwd(void)\n{\n    TXChar buf[4096];\n    if ( NcbiSys_getcwd(buf, sizeof(buf)/sizeof(TXChar) - 1) ) {\n        return _T_CSTRING(buf);\n    }\n    CNcbiError::SetFromErrno();\n    return kEmptyCStr;\n}\n\n\nbool CDir::SetCwd(const string& dir)\n{\n#if defined(NCBI_OS_UNIX)  ||  defined(NCBI_OS_MSWIN)\n    if ( NcbiSys_chdir(_T_XCSTRING(dir)) != 0 ) {\n        LOG_ERROR_AND_RETURN_ERRNO(51, \"CDir::SetCwd(): Cannot change directory to \" + dir);\n    }\n    return true;\n#else    \n    return false;\n#endif\n}\n\n\nCDir::~CDir(void)\n{\n    return;\n}\n\n\nbool CDirEntry::MatchesMask(const string& name,\n                            const vector<string>& masks,\n                            NStr::ECase use_case)\n{\n    if ( masks.empty() ) {\n        return true;\n    }\n    ITERATE(vector<string>, itm, masks) {\n        const string& mask = *itm;\n        if ( MatchesMask(name, mask, use_case) ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// Helpers functions and macro for GetEntries().\n\n#if defined(NCBI_OS_MSWIN)\n\n// Set errno for failed FindFirstFile/FindNextFile\nstatic void s_SetFindFileError(void)\n{\n    DWORD err = GetLastError();\n    CNcbiError::SetWindowsError(err);\n    SetLastError(err); // set Windows error back\n    switch (err) {\n        case ERROR_NO_MORE_FILES:\n        case ERROR_FILE_NOT_FOUND:\n        case ERROR_PATH_NOT_FOUND:\n            errno = ENOENT;\n            break;\n        case ERROR_NOT_ENOUGH_MEMORY:\n            errno = ENOMEM;\n            break;\n        case ERROR_ACCESS_DENIED:\n            errno = EACCES;\n            break;\n        default:\n            errno = EINVAL;\n            break;\n    }\n}\n\n#  define IS_RECURSIVE_ENTRY                     \\\n    ( (flags & CDir::fIgnoreRecursive)  &&       \\\n      ((NcbiSys_strcmp(entry.cFileName, _TX(\".\"))  == 0) ||  \\\n       (NcbiSys_strcmp(entry.cFileName, _TX(\"..\")) == 0)) )\n\nstatic void s_AddEntry(CDir::TEntries*        contents,\n                       const string&          base_path,\n                       const WIN32_FIND_DATA& entry,\n                       CDir::TGetEntriesFlags flags)\n{\n    const string name = (flags & CDir::fIgnorePath) ?\n                         _T_CSTRING(entry.cFileName) :\n                         base_path + _T_CSTRING(entry.cFileName);\n        \n    if (flags & CDir::fCreateObjects) {\n        CDirEntry::EType type = (entry.dwFileAttributes &\n                                 FILE_ATTRIBUTE_DIRECTORY) \n                                 ? CDirEntry::eDir : CDirEntry::eFile;\n        contents->push_back(CDirEntry::CreateObject(type, name));\n    } else {\n        contents->push_back(new CDirEntry(name));\n    }\n}\n\n#else // NCBI_OS_UNIX\n\n#  define IS_RECURSIVE_ENTRY                   \\\n    ( (flags & CDir::fIgnoreRecursive)  &&     \\\n      ((::strcmp(entry->d_name, \".\")  == 0) || \\\n       (::strcmp(entry->d_name, \"..\") == 0)) )\n\nstatic void s_AddEntry(CDir::TEntries*        contents,\n                       const string&          base_path,\n                       const struct dirent*   entry,\n                       CDir::TGetEntriesFlags flags)\n{\n    const string name = (flags & CDir::fIgnorePath) ?\n                         entry->d_name :\n                         base_path + entry->d_name;\n\n    if (flags & CDir::fCreateObjects) {\n        CDirEntry::EType type = CDir::eUnknown;\n#  if defined(_DIRENT_HAVE_D_TYPE)\n        struct stat st;\n        if (entry->d_type) {\n            st.st_mode = DTTOIF(entry->d_type);\n            type = CDirEntry::GetType(st);\n        }\n#  endif\n        if (type == CDir::eUnknown) {\n            if (flags & CDir::fIgnorePath) {\n                const string path = base_path + entry->d_name;\n                type = CDirEntry(path).GetType();\n            } else {\n                type = CDirEntry(name).GetType();\n            }\n        }\n        contents->push_back(CDirEntry::CreateObject(type, name));\n    } else {\n        contents->push_back(new CDirEntry(name));\n    }\n}\n\n#endif\n\n\nCDir::TEntries CDir::GetEntries(const string& mask,\n                                TGetEntriesFlags flags) const\n{\n    CMaskFileName masks;\n    if ( !mask.empty() ) {\n        masks.Add(mask);\n    }\n    return GetEntries(masks, flags);\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const string& mask,\n                                    TGetEntriesFlags flags) const\n{\n    CMaskFileName masks;\n    if ( !mask.empty() ) {\n        masks.Add(mask);\n    }\n    return GetEntriesPtr(masks, flags);\n}\n\n\nCDir::TEntries CDir::GetEntries(const vector<string>& masks,\n                                TGetEntriesFlags flags) const\n{\n    unique_ptr<TEntries> contents(GetEntriesPtr(masks, flags));\n    return contents.get() ? *contents.get() : TEntries();\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const vector<string>& masks,\n                                    TGetEntriesFlags flags) const\n{\n    if ( masks.empty() ) {\n        return GetEntriesPtr(kEmptyStr, flags);\n    }\n    TEntries* contents = new TEntries;\n    string base_path =\n        AddTrailingPathSeparator(GetPath().empty() ? DIR_CURRENT : GetPath());\n    NStr::ECase use_case = (flags & fNoCase) ? NStr::eNocase : NStr::eCase;\n\n#if defined(NCBI_OS_MSWIN)\n\n    // Append to the \"path\" mask for all files in directory\n    string pattern = base_path + string(\"*\");\n\n    WIN32_FIND_DATA entry;\n    HANDLE          handle;\n\n    handle = FindFirstFile(_T_XCSTRING(pattern), &entry);\n    if (handle != INVALID_HANDLE_VALUE) {\n        // Check all masks\n        do {\n            if (!IS_RECURSIVE_ENTRY) {\n                ITERATE(vector<string>, it, masks) {\n                    const string& mask = *it;\n                    if ( mask.empty()  ||\n                         MatchesMask(_T_CSTRING(entry.cFileName), mask,\n                                     use_case) ) {\n                        s_AddEntry(contents, base_path, entry, flags);\n                        break;\n                    }                \n                }\n            }\n        } while (FindNextFile(handle, &entry));\n        FindClose(handle);\n    } else {\n        s_SetFindFileError();\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    DIR* dir = opendir(base_path.c_str());\n    if ( !dir ) {\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n    while (struct dirent* entry = readdir(dir)) {\n        if (IS_RECURSIVE_ENTRY) {\n            continue;\n        }\n        ITERATE(vector<string>, it, masks) {\n            const string& mask = *it;\n            if ( mask.empty()  ||\n                MatchesMask(entry->d_name, mask, use_case) ) {\n                s_AddEntry(contents, base_path, entry, flags);\n                break;\n            }\n        } // ITERATE\n    } // while\n    closedir(dir);\n\n#endif\n\n    return contents;\n}\n\n\nCDir::TEntries CDir::GetEntries(const CMask& masks,\n                                TGetEntriesFlags flags) const\n{\n    unique_ptr<TEntries> contents(GetEntriesPtr(masks, flags));\n    return contents.get() ? *contents.get() : TEntries();\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const CMask& masks,\n                                    TGetEntriesFlags flags) const\n{\n    TEntries* contents = new TEntries;\n    string base_path =\n        AddTrailingPathSeparator(GetPath().empty() ? DIR_CURRENT : GetPath());\n    NStr::ECase use_case = (flags & fNoCase) ? NStr::eNocase : NStr::eCase;\n\n#if defined(NCBI_OS_MSWIN)\n\n    // Append to the \"path\" mask for all files in directory\n    string pattern = base_path + \"*\";\n\n    WIN32_FIND_DATA entry;\n    HANDLE          handle;\n\n    handle = FindFirstFile(_T_XCSTRING(pattern), &entry);\n    if (handle != INVALID_HANDLE_VALUE) {\n        do {\n            if ( !IS_RECURSIVE_ENTRY  &&\n                 masks.Match(_T_CSTRING(entry.cFileName), use_case) ) {\n                s_AddEntry(contents, base_path, entry, flags);\n            }\n        } while ( FindNextFile(handle, &entry) );\n        FindClose(handle);\n    } else {\n        s_SetFindFileError();\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    DIR* dir = opendir(base_path.c_str());\n    if ( !dir ) {\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n    while (struct dirent* entry = readdir(dir)) {\n        if ( !IS_RECURSIVE_ENTRY  &&\n                masks.Match(entry->d_name, use_case) ) {\n            s_AddEntry(contents, base_path, entry, flags);\n        }\n    }\n    closedir(dir);\n\n#endif\n\n    return contents;\n}\n\n\n// Helper function for CDir::Create[Path]()\ninline bool s_DirCreate(const string&path, CDir::TCreateFlags flags, mode_t mode)\n{\n    errno = 0;\n#if defined(NCBI_OS_MSWIN)\n    int res = NcbiSys_mkdir(_T_XCSTRING(path));\n#elif defined(NCBI_OS_UNIX)\n    int res = NcbiSys_mkdir(_T_XCSTRING(path), mode);\n#endif\n    if (res != 0) {\n        if (errno != EEXIST) {\n            LOG_ERROR_AND_RETURN_ERRNO(52, \"CDir::Create(): Cannot create directory \" + path);\n        }\n        // Entry with such name already exists, check its type\n        CDirEntry::EType type = CDirEntry(path).GetType();\n        if (type == CDirEntry::eUnknown) {\n            LOG_ERROR_AND_RETURN(52, \"CDir::Create(): Cannot create directory \" + path);\n        }\n        if (type != CDirEntry::eDir) {\n            LOG_ERROR_AND_RETURN_NCBI(53, \"CDir::Create(): Path already exist and is not a directory \" + path, CNcbiError::eNotADirectory);\n        }\n        if (F_ISSET(flags, CDir::fCreate_ErrorIfExists)) {\n            LOG_ERROR_AND_RETURN_NCBI(54, \"CDir::Create(): Directory already exist \" + path, CNcbiError::eFileExists);\n        }\n        if (!F_ISSET(flags, CDir::fCreate_UpdateIfExists)) {\n            return true;\n        }\n    }\n    // The permissions for the created directory is controlled by umask and is (mode & ~umask & 0777).\n    // We need to call chmod() directly if we need other behavior.\n\n    _ASSERT(CDir::fCreate_Default      == 0  &&\n            CDir::fCreate_PermByUmask  != 0  &&\n            CDir::fCreate_PermAsParent != 0);\n    _ASSERT(!F_ISSET(flags, CDir::fCreate_PermByUmask | CDir::fCreate_PermAsParent));\n\n    if ( F_ISSET(flags, CDir::fCreate_PermByUmask)  ||  \n          (!F_ISSET(flags, CDir::fCreate_PermByUmask)  &&  !F_ISSET(flags, CDir::fCreate_PermAsParent)  &&\n           NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::GetDefault()) ) {\n        // nothing to do if (umask) or (default mode with \"honor umask\" global flag)\n        return true;\n    }\n    // Change directory permissions\n    if (NcbiSys_chmod(_T_XCSTRING(path), mode) != 0) {\n        LOG_ERROR_AND_RETURN_ERRNO(55, \"CDir::Create(): Cannot set mode for directory \" + path);\n    }\n    return true;\n}\n\n\nbool CDir::Create(TCreateFlags flags) const\n{\n    if (GetPath().empty()) {\n        LOG_ERROR_AND_RETURN(56, \"CDir::Create(): Path is empty\");\n    }\n    mode_t mode = GetDefaultModeT();\n\n    // Get parent permissions\n    if (F_ISSET(flags, fCreate_PermAsParent)) {\n        CDir d(CreateAbsolutePath(GetPath()));\n        string path_up(d.GetDir());\n        if ( path_up.empty()  ||  path_up == d.GetPath() ) {\n            LOG_ERROR_AND_RETURN_ERRNO(57, \"CDir::Create(): Cannot get parent directory for \" + GetPath());\n        }\n#if defined(NCBI_OS_MSWIN)\n        // Special case -- stat() dont works if directory have trailing path\n        // separator, except it is a root directory with a disk name, like \"C:\\\".\n        if (path_up.length() > 3) {\n            path_up = DeleteTrailingPathSeparator(path_up);\n        }\n#endif\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(path_up), &st) != 0) {\n            LOG_ERROR_AND_RETURN_ERRNO(58, \"CDir::Create(): Cannot get permissions for parent directory of \" + GetPath());\n        }\n        mode = st.st_mode;\n    }\n    return s_DirCreate(GetPath(), flags, mode);\n}\n\n\nbool CDir::CreatePath(TCreateFlags flags) const\n{\n    if (GetPath().empty()) {\n        LOG_ERROR_AND_RETURN(59, \"CDir::CreatePath(): Path is empty\");\n    }\n    string path(CreateAbsolutePath(GetPath()));\n    if (path.empty()) {\n        LOG_ERROR_AND_RETURN(60, \"CDir::CreatePath(): Cannot create absolute path from \" + path);\n    }\n    if (path[path.length()-1] == GetPathSeparator()) {\n        path.erase(path.length() - 1);\n    }\n\n    // Find all missed parts of the path\n\n    CTempString tmp(path); // existent part of a path\n    std::list<CTempString> missed_parts;\n\n    while (!tmp.empty()  &&  !CDirEntry(tmp).Exists()) {\n        size_t pos = tmp.find_last_of(DIR_SEPARATORS);\n        if (pos == NPOS) {\n            break;\n        }\n        CTempString part(tmp.substr(pos+1));\n        missed_parts.push_front(part);\n        tmp.erase(pos);\n    }\n\n    mode_t mode = GetDefaultModeT();\n\n    // Get parent permissions\n    if (F_ISSET(flags, fCreate_PermAsParent)) {\n        string parent;\n        if (missed_parts.empty()) {\n            parent.assign(CDir(tmp).GetDir());\n        } else {\n            parent.assign(tmp);\n        }\n#if defined(NCBI_OS_MSWIN)\n        // Special case -- for paths like \"C:\" add slash to represent a root directory\n        if (parent.length() == 2) {\n            parent += GetPathSeparator();\n        }\n#endif\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(parent), &st) != 0) {\n            LOG_ERROR_AND_RETURN_ERRNO(61, \"CDir::CreatePath(): Cannot get permissions for \" + parent);\n        }\n        mode = st.st_mode;\n    }\n\n    // Path exists?\n    if (missed_parts.empty()) {\n        // check existence and behave depends on flags\n        return s_DirCreate(path, flags, mode);\n    }\n\n    // Create missed subdirectories\n    string p = tmp;\n    for (auto i : missed_parts) {\n        p += GetPathSeparator();\n        p += i;\n        if (!s_DirCreate(p, flags, mode)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nbool CDir::Copy(const string& newname, TCopyFlags flags, size_t buf_size) const\n{\n    CDir src(*this);\n    CDir dst(newname);\n\n    // Dereference links\n    bool follow = F_ISSET(flags, fCF_FollowLinks);\n    if ( follow ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source dir must exists\n    EType src_type = src.GetType();\n    if ( src_type != eDir )  {\n        LOG_ERROR_AND_RETURN_NCBI(62, \"CDir::Copy(): Source is not a directory: \" + src.GetPath(),\n                                  CNcbiError::eNoSuchFileOrDirectory);\n    }\n    EType  dst_type        = dst.GetType();\n    bool   dst_exists      = (dst_type != eUnknown);\n    bool   need_create_dst = !dst_exists;\n    string dst_safe_path;  // saved path for fCF_Safe\n\n    // Safe copy? \n    // Don't use it if fCF_TopDirOnly is not specified. If target directory\n    // exists it will be just \"updated\" and safe copying will be applied\n    // on a file level for every copied entry.\n    bool need_safe_copy = F_ISSET(flags, fCF_Safe | fCF_TopDirOnly);\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // Check on copying dir into yourself\n        if ( src.IsIdentical(dst.GetPath()) ) {\n            LOG_ERROR_AND_RETURN_NCBI(63, \"CDir::Copy(): Source and destination are the same: \"\n                                      + src.GetPath(), CNcbiError::eOperationNotPermitted);\n        }\n        // Can rename entries with different types?\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_AND_RETURN_NCBI(64, \"CDir::Copy(): Destination is not a directory: \"\n                                      + dst.GetPath(), CNcbiError::eOperationNotPermitted);\n        }\n\n        // Some operation can be made for top directory only\n\n        if ( F_ISSET(flags, fCF_TopDirOnly) ) {\n            // Can overwrite entry?\n            if ( !F_ISSET(flags, fCF_Overwrite) ) {\n                LOG_ERROR_AND_RETURN_NCBI(65, \"CDir::Copy(): Destination directory already exists: \"\n                                          + dst.GetPath(), CNcbiError::eOperationNotPermitted);\n            }\n            // Copy only if destination is older\n            if ( F_ISSET(flags, fCF_Update)  &&  !src.IsNewer(dst.GetPath(), 0) ) {\n                return true;\n            }\n            // Backup destination directory\n            if (F_ISSET(flags, fCF_Backup)) {\n                // Use new CDirEntry object instead of 'dst', because its path\n                // will be changed after backup\n                CDirEntry dst_tmp(dst);\n                if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                    LOG_ERROR_AND_RETURN(66, \"CDir::Copy(): Cannot backup destination directory: \" + dst.GetPath());\n                }\n                need_create_dst = true;\n            }\n            // Clear flags not needed anymore.\n            // Keep fCF_Overwrite if it is set (fCF_Backup is a compound flag).\n            flags &= ~(fCF_TopDirOnly | (fCF_Backup - fCF_Overwrite));\n        }\n    }\n\n    // Safe copy for top directory -- copy to temporary directory in the same\n    // parent directory and rename later.\n\n    if ( need_safe_copy ) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n        need_create_dst = true;\n        // Clear safe flag, we already have a temporary top directory\n        flags &= ~fCF_Safe;\n    }\n\n    // Create target directory if needed\n    if ( need_create_dst ) {\n        if ( !dst.CreatePath() ) {\n            LOG_ERROR_AND_RETURN(67, \"CDir::Copy(): Cannot create \" << \n                                 (dst_safe_path.empty() ? \"target\" : \"temporary\") <<\n                                 \" directory: \" << dst.GetPath());\n        }\n    }\n\n    // Read all entries in source directory\n    unique_ptr<TEntries> contents(src.GetEntriesPtr(kEmptyStr, fIgnoreRecursive));\n    if ( !contents.get() ) {\n        LOG_ERROR_AND_RETURN(68, \"CDir::Copy(): Cannot get content of \" + src.GetPath());\n    }\n\n    // And copy each of them to target directory\n    ITERATE(TEntries, e, *contents.get()) {\n        CDirEntry& entry = **e;\n        if (!F_ISSET(flags, fCF_Recursive) &&\n            entry.IsDir(follow ? eFollowLinks : eIgnoreLinks)) {\n            continue;\n        }\n        // Copy entry\n        if (!entry.CopyToDir(dst.GetPath(), flags, buf_size)) {\n            LOG_ERROR_AND_RETURN(69, \"CDir::Copy():\"\n                                     \" Cannot copy \"  + entry.GetPath() +\n                                     \" to directory \" + dst.GetPath());\n        }\n    }\n\n    // Safe copy for top directory -- renaming temporary to target\n    if (!dst_safe_path.empty()) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.Remove();\n            LOG_ERROR_AND_RETURN(70, \"CDir:Copy():\"\n                                     \" Cannot rename temporary directory \" + dst.GetPath() +\n                                     \" to \" + dst_safe_path);\n        }\n    }\n    // Preserve attributes\n    if ( flags & fCF_PreserveAll ) {\n        if ( !s_CopyAttrs(src.GetPath().c_str(),\n                          dst.GetPath().c_str(), eDir, flags) ) {\n            return false;\n        }\n    } else {\n        // Set default permissions for directory, if we should not\n        // honor umask settings.\n        if ( !NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::GetDefault()) {\n            if ( !dst.SetMode(fDefault, fDefault, fDefault) ) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nbool CDir::Remove(TRemoveFlags flags) const\n{\n    // Assumption\n    _ASSERT(fDir_Self  == fEntry);\n    _ASSERT(eOnlyEmpty == fEntry);\n    \n    // Remove directory as empty\n    if ( (flags & (fDir_All | fDir_Recursive)) == eOnlyEmpty ) {\n        if ( NcbiSys_rmdir(_T_XCSTRING(GetPath())) != 0 ) {\n            if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n                return true;\n            }\n            LOG_ERROR_AND_RETURN_ERRNO(71, \"CDir::Remove():\"\n                                           \" Cannot remove (by implication empty)\"\n                                           \" directory \" + GetPath());\n        }\n        return true;\n    }\n\n#if !defined(NCBI_OS_MSWIN)\n    // Make directory writable for user to remove any entry inside\n    SetMode(CDirEntry::fWrite | CDirEntry::fModeAdd, \n            CDirEntry::fModeNoChange,\n            CDirEntry::fModeNoChange);\n#endif\n\n    // Read all entries in directory\n    unique_ptr<TEntries> contents(GetEntriesPtr());\n    if (!contents.get()) {\n        LOG_ERROR_AND_RETURN_ERRNO(72, \"CDir::Remove(): Cannot get content of \" + GetPath());\n    }\n    \n    // Remove each entry\n    ITERATE(TEntries, entry, *contents.get()) {\n        string name = (*entry)->GetName();\n        if ( name == \".\"  ||  name == \"..\"  ||  \n             name == string(1, GetPathSeparator()) ) {\n            continue;\n        }\n        // Get entry item with full pathname\n        CDirEntry item(GetPath() + GetPathSeparator() + name);\n\n        if (flags & fDir_Recursive) {\n            // Update flags to process subdirectories itself,\n            // because the top directory entry may not have\n            // such flag.\n            int f = (flags & fDir_Subdirs) ? (flags | fDir_Self) : flags;\n            if (item.IsDir(eIgnoreLinks)) {\n                if (!CDir(item.GetPath()).Remove(f)) {\n                    return false;\n                }\n            } else if (flags & fDir_Files) {\n                if (!item.Remove(f)) {\n                    return false;\n                }\n            }\n        }\n        else if (item.IsDir(eIgnoreLinks)) {\n            // Non-recursive directory removal\n            if (flags & fDir_Subdirs) {\n                // Clear all flags to go inside directory,\n                // and try to remove it as \"empty\".\n                if (!item.Remove((flags & ~fDir_All) | fDir_Self)) {\n                    return false;\n                }\n            }\n            continue;\n            \n        } else {\n            if (flags & fDir_Files) {\n                if (!item.Remove(flags)) {\n                    // Regular file entry removal has failed\n                    return false;\n                }\n            }\n        }\n    }\n    \n    // Remove top directory\n    if ( (flags & fDir_Self)  &&  NcbiSys_rmdir(_T_XCSTRING(GetPath())) != 0 ) {\n        if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n            return true;\n        }\n        LOG_ERROR_AND_RETURN_ERRNO(73, \"CDir::Remove(): Cannot remove directory \" + GetPath());\n    }\n    return true;\n}\n\n\nbool CDir::SetMode(TMode user_mode,  TMode group_mode,\n                   TMode other_mode, TSpecialModeBits special_mode,\n                   TSetModeFlags flags) const\n{\n    // Assumption\n    _ASSERT(fDir_Self == fEntry);\n    _ASSERT(eEntryOnly == fEntry);\n\n    // Default mode (backward compatibility) -- top entry only\n    if ( (flags & (fDir_All | fDir_Recursive)) == eEntryOnly ) {\n        return SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags);\n    }\n    \n    // Read all entries in directory\n    unique_ptr<TEntries> contents(GetEntriesPtr());\n    if (!contents.get()) {\n        LOG_ERROR_AND_RETURN_ERRNO(74, \"CDir::SetMode(): Cannot get content of \" + GetPath());\n    }\n    // Process each entry\n    ITERATE(TEntries, entry, *contents.get()) {\n        string name = (*entry)->GetName();\n        if ( name == \".\"  ||  name == \"..\"  ||  \n             name == string(1, GetPathSeparator()) ) {\n            continue;\n        }\n        // Get entry item with full pathname.\n        CDirEntry item(GetPath() + GetPathSeparator() + name);\n        if (flags & fDir_Recursive) {\n            // Update flags to process subdirectories itself,\n            // because the top directory entry may not have such flag.\n            int f = (flags & fDir_Subdirs) ? (flags | fDir_Self) : flags;\n            if (item.IsDir(eIgnoreLinks)) {\n                if (!CDir(item.GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode, f)) {\n                    return false;\n                }\n            } else if (flags & fDir_Files) {\n                if (!item.SetModeEntry(user_mode, group_mode, other_mode, special_mode, f)) {\n                    return false;\n                }\n            }\n        } \n        else if (item.IsDir(eIgnoreLinks)) {\n            // Non-recursive directory processing\n            if (flags & fDir_Subdirs) {\n                // Clear all flags to go inside directory,\n                // and try to change modes for entry only.\n                if (!CDir(item.GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode,\n                                                 (flags & ~fDir_All) | fDir_Self)) {\n                    return false;\n                }\n            }\n            continue;\n            \n        }\n        else {\n            if (flags & fDir_Files) {\n                if (!item.SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags)) {\n                    // Changing mode for a regular file entry failed\n                    return false;\n                }\n            }\n        }\n    }\n    // Process directory entry\n    if (flags & fDir_Self) {\n        // Change mode for entry/directory itself\n        return SetModeEntry(user_mode, group_mode, other_mode, special_mode, fEntry);\n    }\n    return true;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CSymLink\n//\n\nCSymLink::~CSymLink(void)\n{ \n    return;\n}\n\n\nbool CSymLink::Create(const string& path) const\n{\n#if defined(NCBI_OS_UNIX)\n    char buf[PATH_MAX + 1];\n    int len = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf) - 1);\n    if (len >= 0) {\n        buf[len] = '\\0';\n        if (strcmp(buf, path.c_str()) == 0) {\n            return true;\n        }\n    }\n    // Leave it to the kernel to decide whether the symlink can be recreated\n    if ( symlink(_T_XCSTRING(path), _T_XCSTRING(GetPath())) == 0 ) {\n        return true;\n    }\n    LOG_ERROR_AND_RETURN_ERRNO(75, \"CSymLink::Create(): failed: \" + path);\n#else\n    LOG_ERROR_AND_RETURN_NCBI(76, \"CSymLink::Create():\"\n                                  \" Symbolic links not supported on this platform: \"\n                                  + path, CNcbiError::eNotSupported);\n#endif\n}\n\n\nbool CSymLink::Copy(const string& new_path, TCopyFlags flags, size_t buf_size) const\n{\n#if defined(NCBI_OS_UNIX)\n\n    // Dereference link if specified\n    if ( F_ISSET(flags, fCF_FollowLinks) ) {\n        switch ( GetType(eFollowLinks) ) {\n            case eFile:\n                return CFile(*this).Copy(new_path, flags, buf_size);\n            case eDir:\n                return CDir(*this).Copy(new_path, flags, buf_size);\n            case eLink:\n                return CSymLink(*this).Copy(new_path, flags, buf_size);\n            default:\n                return CDirEntry(*this).Copy(new_path, flags, buf_size);\n        }\n        // not reached\n    }\n\n    // The source link must exists\n    EType src_type = GetType(eIgnoreLinks);\n    if ( src_type == eUnknown )  {\n        LOG_ERROR_AND_RETURN_NCBI(77, \"CSymLink::Copy(): Unknown entry type \" + GetPath(),\n                                  CNcbiError::eNoSuchFileOrDirectory);\n    }\n    CSymLink dst(new_path);\n    EType    dst_type = dst.GetType(eIgnoreLinks);\n    bool     dst_exists = (dst_type != eUnknown);\n    string   dst_safe_path;  // saved path for fCF_Safe\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // Check on copying link into yourself.\n        if ( IsIdentical(dst.GetPath()) ) {\n            LOG_ERROR_AND_RETURN_NCBI(78, \"CSymLink::Copy():\"\n                                          \" Source and destination are the same: \" + GetPath(),\n                                          CNcbiError::eInvalidArgument);\n        }\n        // Can copy entries with different types?\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_AND_RETURN_NCBI(79, \"CSymLink::Copy():\"\n                                          \" Cannot copy entries with different types: \" + GetPath(),\n                                          CNcbiError::eOperationNotPermitted);\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fCF_Overwrite) ) {\n            LOG_ERROR_AND_RETURN_NCBI(80, \"CSymLink::Copy():\"\n                                          \" Destination already exists: \" + dst.GetPath(),\n                                          CNcbiError::eOperationNotPermitted);\n        }\n        // Copy only if destination is older\n        if ( F_ISSET(flags, fCF_Update)  &&  !IsNewer(dst.GetPath(), 0)) {\n            return true;\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fCF_Backup) ) {\n            // Use a new CDirEntry object for 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR_AND_RETURN(81, \"CSymLink::Copy(): Cannot backup destination: \" + dst.GetPath());\n            }\n        }\n        // Overwrite destination entry\n        if ( F_ISSET(flags, fCF_Overwrite) ) {\n            dst.Remove();\n        } \n    }\n    // Safe copy -- create temporary symlink and rename later\n    if (F_ISSET(flags, fCF_Safe)) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n    }\n    else {\n        // Overwrite destination entry\n        if (dst_exists  &&  F_ISSET(flags, fCF_Overwrite)) {\n            dst.Remove();\n        }\n    }\n    // Copy symbolic link (create new one)\n    char buf[PATH_MAX + 1];\n    int  len = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf)-1);\n    if (len < 1) {\n        LOG_ERROR_AND_RETURN_ERRNO(82, \"CSymLink::Copy(): Cannot read symbolic link \" + GetPath());\n    }\n    buf[len] = '\\0';\n    if (symlink(buf, _T_XCSTRING(dst.GetPath()))) {\n        LOG_ERROR_AND_RETURN_ERRNO(83, \"CSymLink::Copy():\"\n                                       \" Cannot create symbolic link to \" + dst.GetPath() + \n                                       \" to \" + string(buf));\n    }\n\n    // Safe copy -- renaming\n    if (F_ISSET(flags, fCF_Safe)) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.Remove();\n            LOG_ERROR_AND_RETURN_NCBI(84, \"CSymLink:Copy():\"\n                                          \" Cannot rename temporary symlink \" + dst.GetPath() +\n                                          \" to \" + dst_safe_path, CNcbiError::eIoError);\n        }\n    }\n    // Preserve attributes\n    if (flags & fCF_PreserveAll) {\n        if (!s_CopyAttrs(GetPath().c_str(), new_path.c_str(), eLink, flags)) {\n            return false;\n        }\n    }\n    return true;\n#else\n    return CParent::Copy(new_path, flags, buf_size);\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileUtil\n//\n\n/// Flags to get information about file system.\n/// Each flag corresponds to one or some fields in\n/// the CFileUtil::SFileSystemInfo structure.\nenum EFileSystemInfo {\n    fFSI_Type        = (1<<1),    ///< fs_type\n    fFSI_DiskSpace   = (1<<2),    ///< total_space, free_space\n    fFSI_BlockSize   = (1<<3),    ///< block_size\n    fFSI_FileNameMax = (1<<4),    ///< filename_max\n    fFSI_All         = 0xFF       ///< get all possible information\n};\ntypedef int TFileSystemInfo;      ///< Binary OR of \"EFileSystemInfo\"\n\n// File system identification strings\nstruct SFileSystem {\n    const char*                name;\n    CFileUtil::EFileSystemType type;\n};\n\n// File system identification table\nstatic const SFileSystem s_FileSystem[] = {\n    { \"ADFS\",    CFileUtil::eADFS    },\n    { \"ADVFS\",   CFileUtil::eAdvFS   },\n    { \"AFFS\",    CFileUtil::eAFFS    },\n    { \"AUTOFS\",  CFileUtil::eAUTOFS  },\n    { \"CACHEFS\", CFileUtil::eCacheFS },\n    { \"CD9669\",  CFileUtil::eCDFS    },\n    { \"CDFS\",    CFileUtil::eCDFS    },\n    { \"DEVFS\",   CFileUtil::eDEVFS   },\n    { \"DFS\",     CFileUtil::eDFS     },\n    { \"DOS\",     CFileUtil::eFAT     },\n    { \"EXT\",     CFileUtil::eExt     },\n    { \"EXT2\",    CFileUtil::eExt2    },\n    { \"EXT3\",    CFileUtil::eExt3    },\n    { \"FAT\",     CFileUtil::eFAT     },\n    { \"FAT32\",   CFileUtil::eFAT32   },\n    { \"FDFS\",    CFileUtil::eFDFS    },\n    { \"FFM\",     CFileUtil::eFFM     },\n    { \"FFS\",     CFileUtil::eFFS     },\n    { \"HFS\",     CFileUtil::eHFS     },\n    { \"HSFS\",    CFileUtil::eHSFS    },\n    { \"HPFS\",    CFileUtil::eHPFS    },\n    { \"JFS\",     CFileUtil::eJFS     },\n    { \"LOFS\",    CFileUtil::eLOFS    },\n    { \"MFS\",     CFileUtil::eMFS     },\n    { \"MSFS\",    CFileUtil::eMSFS    },\n    { \"NFS\",     CFileUtil::eNFS     },\n    { \"NFS2\",    CFileUtil::eNFS     },\n    { \"NFSV2\",   CFileUtil::eNFS     },\n    { \"NFS3\",    CFileUtil::eNFS     },\n    { \"NFSV3\",   CFileUtil::eNFS     },\n    { \"NFS4\",    CFileUtil::eNFS     },\n    { \"NFSV4\",   CFileUtil::eNFS     },\n    { \"NTFS\",    CFileUtil::eNTFS    },\n    { \"PCFS\",    CFileUtil::eFAT     },\n    { \"PROC\",    CFileUtil::ePROC    },\n    { \"PROCFS\",  CFileUtil::ePROC    },\n    { \"RFS\",     CFileUtil::eRFS     },\n    { \"SMBFS\",   CFileUtil::eSMBFS   },\n    { \"SPECFS\",  CFileUtil::eSPECFS  },\n    { \"TMP\",     CFileUtil::eTMPFS   },\n    { \"UFS\",     CFileUtil::eUFS     },\n    { \"VXFS\",    CFileUtil::eVxFS    },\n    { \"XFS\",     CFileUtil::eXFS     }\n};\n\n\n// Macros to get filesystem status information\n\n#define GET_STATVFS_INFO                                       \\\n    struct statvfs st;                                         \\\n    memset(&st, 0, sizeof(st));                                \\\n    if (statvfs(path.c_str(), &st) != 0) {                     \\\n        NCBI_THROW(CFileErrnoException, eFileSystemInfo, msg); \\\n    }                                                          \\\n    info->total_space  = (Uint8)st.f_bsize * st.f_blocks;      \\\n    if (st.f_frsize) {                                         \\\n        info->free_space = (Uint8)st.f_frsize * st.f_bavail;   \\\n        info->block_size = (unsigned long)st.f_frsize;         \\\n    } else {                                                   \\\n        info->free_space = (Uint8)st.f_bsize * st.f_bavail;    \\\n        info->block_size = (unsigned long)st.f_bsize;          \\\n    }                                                          \\\n    info->used_space   = info->total_space - info->free_space\n\n\n#define GET_STATFS_INFO                                        \\\n    struct statfs st;                                          \\\n    memset(&st, 0, sizeof(st));                                \\\n    if (statfs(path.c_str(), &st) != 0) {                      \\\n        NCBI_THROW(CFileErrnoException, eFileSystemInfo, msg); \\\n    }                                                          \\\n    info->total_space  = (Uint8)st.f_bsize * st.f_blocks;      \\\n    info->free_space   = (Uint8)st.f_bsize * st.f_bavail;      \\\n    info->used_space   = info->total_space - info->free_space; \\\n    info->block_size   = (unsigned long)st.f_bsize\n\n\n\n#if defined(SUPPORT_PANFS)\n\n// Auxiliary function to exit from forked process with reporting errno\n// on errors to specified file descriptor \nstatic void s_PipeExit(int status, int fd)\n{\n    int errcode = errno;\n    _no_warning(::write(fd, &errcode, sizeof(errcode)));\n    ::close(fd);\n    ::_exit(status);\n}\n\n// Close pipe handle\n#define CLOSE_PIPE_END(fd) \\\n    if (fd != -1) {        \\\n        ::close(fd);       \\\n        fd = -1;           \\\n    }\n\n// Standard kernel calls cannot get correct information \n// about PANFS mounts, so we use workaround for that.\n//\n// Use external method fist, if 'ncbi_panfs.so' exists and can be loaded.\n// Fall back to 'pan_df' utuility (if present).\n// Fall back to use standard OS info if none of above works.\n//\nvoid s_GetDiskSpace_PANFS(const string&               path,\n                          CFileUtil::SFileSystemInfo* info)\n{\n    DEFINE_STATIC_FAST_MUTEX(s_Mutex);\n    CFastMutexGuard guard_mutex(s_Mutex);\n\n    // TRUE if initialization has done for EXE method\n    static bool s_InitEXE  = false;\n    static bool s_ExistEXE = false;\n    \n#if defined(ALLOW_USE_NCBI_PANFS_DLL)\n\n    // TRUE if initialization has done for DLL method\n    static bool s_InitDLL = false;\n    static FGetDiskSpace_PANFS f_GetDiskSpace = NULL;\n   \n    if ( !s_InitDLL ) {\n        s_InitDLL = true;\n\n        #define STRINGIFY(x) #x\n        #define TOSTRING(x) STRINGIFY(x)\n        const char* kNcbiPanfsDLL = \n            \"/opt/ncbi/\" TOSTRING(NCBI_PLATFORM_BITS) \"/lib/ncbi_panfs.so\";\n        \n        // Check if 'ncbi_panfs.so' exists and can be loaded\n        if ( CFile(kNcbiPanfsDLL).Exists() ) {\n            void* handle = dlopen(kNcbiPanfsDLL, RTLD_NOW | RTLD_GLOBAL);\n            const char* err = NULL;\n            if ( handle ) {\n                f_GetDiskSpace = (FGetDiskSpace_PANFS)\n                    dlsym(handle, \"ncbi_GetDiskSpace_PANFS\");\n                if ( !f_GetDiskSpace ) {\n                    err = \"Undefined symbol\";\n                }\n            } else {\n                err = \"Cannot open shared object file\";\n            }\n\n            if ( err ) {\n                char* dlerr = dlerror();\n                string msg = \"Trying to get ncbi_GetDiskSpace_PANFS() function from '\" +\n                             string(kNcbiPanfsDLL) + \"': \" + err;\n                if ( dlerr ) {\n                    msg = msg + \" (\" + dlerr + \")\";\n                }\n                LOG_ERROR(85, msg);\n                CNcbiError::Set(CNcbiError::eUnknown, msg);\n                if ( handle) {\n                    dlclose(handle);\n                }\n            }\n        }\n    }\n   \n    if ( f_GetDiskSpace ) {\n        const char* err_msg = NULL;\n        bool do_throw = false;\n        \n        int res = f_GetDiskSpace(path.c_str(),\n                                 &info->total_space,\n                                 &info->free_space,\n                                 &err_msg);\n        switch ( res ) {\n\n        case NCBI_PANFS_OK:\n            info->used_space = info->total_space - info->free_space;\n            // All done, return\n            return;\n\n        case NCBI_PANFS_THROW:\n             do_throw = true;\n             /*FALLTHRU*/\n             \n        // Same processing for all errors codes, but could be detailed\n        case NCBI_PANFS_ERR:\n        case NCBI_PANFS_ERR_OPEN:\n        case NCBI_PANFS_ERR_QUERY:\n        case NCBI_PANFS_ERR_VERSION:\n        default:\n            {\n                string msg = \"Cannot get information for PANFS mount '\"+ path + \"'\";\n                if ( err_msg ) {\n                    msg += string(\": \") + err_msg;\n                }\n\n                if ( do_throw ) {\n                    NCBI_THROW(CFileException, eFileSystemInfo, msg);\n                }\n\n                LOG_ERROR(86, msg);\n            }\n        }\n    }\n#endif // defined(ALLOW_USE_NCBI_PANFS_DLL)\n\n\n    // Cannot use DLL, so -- fall through to use pan_df.\n\n    // -----------------------------------------\n    // Call 'pan_df' utility and parse results\n    // -----------------------------------------\n\n    const char* kPanDF = \"/opt/panfs/bin/pan_df\";\n\n    if ( !s_InitEXE ) {\n        s_InitEXE = true;\n        // Check if 'pan_df' exists\n        if ( CFile(kPanDF).Exists() ) {\n            s_ExistEXE = true;\n        }\n    }\n    \n    if ( s_ExistEXE ) {\n        // Child process I/O handles\n        int status_pipe[2] = {-1,-1};\n        int pipe_fd[2]     = {-1,-1};\n        \n        try {\n            ::fflush(NULL);\n            // Create pipe for child's stdout\n            if (::pipe(pipe_fd) < 0) {\n                throw \"failed to create pipe for stdout\";\n            }\n            // Create temporary pipe to get status of execution\n            // of the child process\n            if (::pipe(status_pipe) < 0) {\n                throw \"failed to create status pipe\";\n            }\n            if (::fcntl(status_pipe[1], F_SETFD, \n                ::fcntl(status_pipe[1], F_GETFD, 0) | FD_CLOEXEC) < 0) {\n                throw \"failed to set close-on-exec mode for status pipe\";\n            }\n\n            // Fork child process\n            pid_t pid = ::fork();\n            if (pid == -1) {\n                throw \"fork() failed\";\n            }\n            if (pid == 0) {\n                // -- Now we are in the child process\n\n                // Close unused pipe handle\n                ::close(status_pipe[0]);\n                // stdin/stderr -- don't use\n                _no_warning(::freopen(\"/dev/null\", \"r\", stdin));\n                _no_warning(::freopen(\"/dev/null\", \"a\", stderr));\n                // stdout\n                if (pipe_fd[1] != STDOUT_FILENO) {\n                    if (::dup2(pipe_fd[1], STDOUT_FILENO) < 0) {\n                        s_PipeExit(-1, status_pipe[1]);\n                    }\n                    ::close(pipe_fd[1]);\n                }\n                ::close(pipe_fd[0]);\n                int status = ::execl(kPanDF, kPanDF, \"--block-size=1\",\n                                     path.c_str(), NULL);\n                s_PipeExit(status, status_pipe[1]);\n\n                // -- End of child process\n            }\n        \n            // Close unused pipes' ends\n            CLOSE_PIPE_END(pipe_fd[1]);\n            CLOSE_PIPE_END(status_pipe[1]);\n\n            // Check status pipe.\n            // If it have some data, this is an errno from the child process.\n            // If EOF in status pipe, that child executed successful.\n            // Retry if either blocked or interrupted\n\n            // Try to read errno from forked process\n            ssize_t n;\n            int errcode;\n            while ((n = read(status_pipe[0], &errcode, sizeof(errcode))) < 0) {\n                if (errno != EINTR)\n                    break;\n            }\n            CLOSE_PIPE_END(status_pipe[0]);\n            if (n > 0) {\n                // Child could not run -- reap it and exit with error\n                ::waitpid(pid, 0, 0);\n                errno = (size_t) n >= sizeof(errcode) ? errcode : 0;\n                throw \"failed to run pan_df\";\n            }\n\n            // Read data from pipe\n            char buf[1024];\n            while ((n = read(pipe_fd[0], &buf, sizeof(buf)-1)) < 0) {\n                if (errno != EINTR)\n                    break;\n            }\n            CLOSE_PIPE_END(pipe_fd[0]);\n            if ( !n ) {\n                throw \"error reading from pipe\";\n            }\n            buf[n] = '\\0';\n            \n            // Parse resilt\n            const char* kParseError = \"results parse error\";\n            const char* data = strchr(buf, '\\n');\n            if ( !data ) {\n                throw kParseError;\n            }\n            vector<string> tokens;\n            NStr::Split(data + 1, \" \", tokens,\n                NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n            if ( tokens.size() != 6 ) {\n                throw kParseError;\n            }\n            Uint8 x_total = 1, x_free = 2, x_used = 3; // dummy values\n            try {\n                x_total = NStr::StringToUInt8(tokens[1]);\n                x_free  = NStr::StringToUInt8(tokens[2]);\n                x_used  = NStr::StringToUInt8(tokens[3]);\n            }\n            catch (const CException& e) {\n                throw kParseError;\n            }\n            // Check\n            if ( x_free + x_used != x_total ) {\n                throw kParseError;\n            }\n            info->total_space = x_total;\n            info->free_space  = x_free;\n            info->used_space  = x_used;\n            return;\n        }\n        catch (const char* what) {\n            CLOSE_PIPE_END(pipe_fd[0]);\n            CLOSE_PIPE_END(pipe_fd[1]);\n            CLOSE_PIPE_END(status_pipe[0]);\n            CLOSE_PIPE_END(status_pipe[1]);\n            ERR_POST_X_ONCE(3, Warning << \n                           \"Failed to use 'pan_df' : \" << what);\n        }           \n    } // if ( s_ExistEXE ) \n    \n    // Failed\n    ERR_POST_X_ONCE(3, Warning << \n                    \"Cannot use any external method to get information about \"\n                    \"PANFS mount, fall back to use standard OS info \"\n                    \"(NOTE: it can be incorrect)\");\n    return;\n}\n\n#endif // defined(SUPPORT_PANFS)\n\n\n\nvoid s_GetFileSystemInfo(const string&               path,\n                         CFileUtil::SFileSystemInfo* info,\n                         TFileSystemInfo             flags)\n{\n    if ( !info ) {\n        NCBI_THROW(CCoreException, eInvalidArg,\n                   \"s_GetFileSystemInfo(path, NULL) is not allowed\");\n    }\n    memset(info, 0, sizeof(*info));\n    string msg = string(\"Cannot get system information for \") + path;\n    const char* fs_name_ptr = 0;\n\n#if defined(NCBI_OS_MSWIN)\n    // Try to get a root disk directory from given path\n    string xpath = path;\n    // Not UNC path\n    if (!s_Win_IsNetworkPath(path)) {\n        if ( !isalpha((unsigned char)path[0]) || path[1] != DISK_SEPARATOR ) {\n            // absolute or relative path without disk name -- current disk,\n            // dir entry should exists\n            if ( CDirEntry(path).Exists() ) {\n                xpath = CDir::GetCwd();\n            }\n        }\n        // Get disk root directory name from the path\n        xpath[2] = '\\\\';\n        xpath.resize(3);\n    }\n\n    // Get volume information\n    TXChar fs_name[MAX_PATH+1];\n    string ufs_name;\n    if (flags & (fFSI_Type | fFSI_FileNameMax))  {\n        DWORD filename_max;\n        DWORD fs_flags;\n\n        if ( !::GetVolumeInformation(_T_XCSTRING(xpath),\n                                     NULL, 0, // Name of the volume\n                                     NULL,    // and its serial number\n                                     &filename_max,\n                                     &fs_flags,\n                                     fs_name,\n                                     sizeof(fs_name)/sizeof(fs_name[0])) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, msg);\n        }\n        info->filename_max = filename_max;\n        ufs_name = _T_CSTRING(fs_name);\n        fs_name_ptr = ufs_name.c_str();\n    }\n        \n    // Get disk spaces\n    if (flags & fFSI_DiskSpace) {\n        if ( !::GetDiskFreeSpaceEx(_T_XCSTRING(xpath),\n                                   (PULARGE_INTEGER)&info->free_space,\n                                   (PULARGE_INTEGER)&info->total_space, 0) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, msg);\n        }\n    }\n\n    // Get volume cluster size\n    if (flags & fFSI_BlockSize) {\n        DWORD dwSectPerClust; \n        DWORD dwBytesPerSect;\n        if ( !::GetDiskFreeSpace(_T_XCSTRING(xpath),\n                                 &dwSectPerClust, &dwBytesPerSect,\n                                 NULL, NULL) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, msg);\n        }\n        info->block_size = dwBytesPerSect * dwSectPerClust;\n    }\n\n#else // defined(NCBI_OS_MSWIN)\n\n    bool need_name_max = true;\n#  ifdef _PC_NAME_MAX\n    long r_name_max = pathconf(path.c_str(), _PC_NAME_MAX);\n    if (r_name_max != -1) {\n        info->filename_max = (unsigned long)r_name_max;\n        need_name_max = false;\n    }\n#  endif\n\n#  if (defined(NCBI_OS_LINUX) || defined(NCBI_OS_CYGWIN))  &&  defined(HAVE_STATFS)\n    \n    GET_STATFS_INFO;\n    if (flags & (fFSI_Type | fFSI_DiskSpace)) {\n        switch (st.f_type) {\n            case 0xADF5:      info->fs_type = CFileUtil::eADFS;     break;\n            case 0xADFF:      info->fs_type = CFileUtil::eAFFS;     break;\n            case 0x5346414F:  info->fs_type = CFileUtil::eAFS;      break;\n            case 0x0187:      info->fs_type = CFileUtil::eAUTOFS;   break;\n            case 0x1BADFACE:  info->fs_type = CFileUtil::eBFS;      break;\n            case 0x4004:\n            case 0x4000:\n            case 0x9660:      info->fs_type = CFileUtil::eCDFS;     break;\n            case 0xF15F:      info->fs_type = CFileUtil::eCryptFS;  break;\n            case 0xFF534D42:  info->fs_type = CFileUtil::eCIFS;     break;\n            case 0x73757245:  info->fs_type = CFileUtil::eCODA;     break;\n            case 0x012FF7B7:  info->fs_type = CFileUtil::eCOH;      break;\n            case 0x28CD3D45:  info->fs_type = CFileUtil::eCRAMFS;   break;\n            case 0x1373:      info->fs_type = CFileUtil::eDEVFS;    break;\n            case 0x414A53:    info->fs_type = CFileUtil::eEFS;      break;\n            case 0x5DF5:      info->fs_type = CFileUtil::eEXOFS;    break;\n            case 0x137D:      info->fs_type = CFileUtil::eExt;      break;\n            case 0xEF51:\n            case 0xEF53:      info->fs_type = CFileUtil::eExt2;     break;\n            case 0x4d44:      info->fs_type = CFileUtil::eFAT;      break;\n            case 0x65735546:  info->fs_type = CFileUtil::eFUSE;     break;\n            case 0x65735543:  info->fs_type = CFileUtil::eFUSE_CTL; break;\n            case 0x01161970:  info->fs_type = CFileUtil::eGFS2;     break;\n            case 0x4244:      info->fs_type = CFileUtil::eHFS;      break;\n            case 0x482B:      info->fs_type = CFileUtil::eHFSPLUS;  break;\n            case 0xF995E849:  info->fs_type = CFileUtil::eHPFS;     break;\n            case 0x3153464A:  info->fs_type = CFileUtil::eJFS;      break;\n            case 0x07C0:      info->fs_type = CFileUtil::eJFFS;     break;\n            case 0x72B6:      info->fs_type = CFileUtil::eJFFS2;    break;\n            case 0x47504653:  info->fs_type = CFileUtil::eGPFS;     break;\n            case 0x137F:\n            case 0x138F:      info->fs_type = CFileUtil::eMinix;    break;\n            case 0x2468:\n            case 0x2478:      info->fs_type = CFileUtil::eMinix2;   break;\n            case 0x4D5A:      info->fs_type = CFileUtil::eMinix3;   break;\n            case 0x564C:      info->fs_type = CFileUtil::eNCPFS;    break;\n            case 0x6969:      info->fs_type = CFileUtil::eNFS;      break;\n            case 0x5346544E:  info->fs_type = CFileUtil::eNTFS;     break;\n            case 0x7461636F:  info->fs_type = CFileUtil::eOCFS2;    break;\n            case 0x9fA1:      info->fs_type = CFileUtil::eOPENPROM; break;\n            case 0xAAD7AAEA:  info->fs_type = CFileUtil::ePANFS;    break;\n            case 0x9fA0:      info->fs_type = CFileUtil::ePROC;     break;\n            case 0x20030528:  info->fs_type = CFileUtil::ePVFS2;    break;\n            case 0x002F:      info->fs_type = CFileUtil::eQNX4;     break;\n            case 0x52654973:  info->fs_type = CFileUtil::eReiserFS; break;\n            case 0x7275:      info->fs_type = CFileUtil::eROMFS;    break;\n            case 0xF97CFF8C:  info->fs_type = CFileUtil::eSELINUX;  break;\n            case 0x517B:      info->fs_type = CFileUtil::eSMBFS;    break;\n            case 0x73717368:  info->fs_type = CFileUtil::eSquashFS; break;\n            case 0x62656572:  info->fs_type = CFileUtil::eSYSFS;    break;\n            case 0x012FF7B6:  info->fs_type = CFileUtil::eSYSV2;    break;\n            case 0x012FF7B5:  info->fs_type = CFileUtil::eSYSV4;    break;\n            case 0x01021994:  info->fs_type = CFileUtil::eTMPFS;    break;\n            case 0x24051905:  info->fs_type = CFileUtil::eUBIFS;    break;\n            case 0x15013346:  info->fs_type = CFileUtil::eUDF;      break;\n            case 0x00011954:  info->fs_type = CFileUtil::eUFS;      break;\n            case 0x19540119:  info->fs_type = CFileUtil::eUFS2;     break;\n            case 0x9fA2:      info->fs_type = CFileUtil::eUSBDEVICE;break;\n            case 0x012FF7B8:  info->fs_type = CFileUtil::eV7;       break;\n            case 0xa501FCF5:  info->fs_type = CFileUtil::eVxFS;     break;\n            case 0x565a4653:  info->fs_type = CFileUtil::eVZFS;     break;\n            case 0x012FF7B4:  info->fs_type = CFileUtil::eXENIX;    break;\n            case 0x58465342:  info->fs_type = CFileUtil::eXFS;      break;\n            case 0x012FD16D:  info->fs_type = CFileUtil::eXIAFS;    break;\n            default:          info->fs_type = CFileUtil::eUnknown;  break;\n        }\n    }\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namelen;\n    }\n\n#  elif (defined(NCBI_OS_SOLARIS) || defined(NCBI_OS_IRIX) || defined(NCBI_OS_OSF1)) \\\n         &&  defined(HAVE_STATVFS)\n\n    GET_STATVFS_INFO;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namemax;\n    }\n    fs_name_ptr = st.f_basetype;\n\n#  elif defined(NCBI_OS_DARWIN)  &&  defined(HAVE_STATFS)\n\n    GET_STATFS_INFO;\n    // Seems statfs structure on Darwin dont have any information \n    // about name length, so rely on pathconf() only.\n    //if (need_name_max) {\n    //    info->filename_max = (unsigned long)st.f_namelen;\n    //}\n    fs_name_ptr = st.f_fstypename;\n\n#  elif defined(NCBI_OS_BSD)  &&  defined(HAVE_STATFS)\n\n    GET_STATFS_INFO;\n    fs_name_ptr = st.f_fstypename;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namemax;\n    }\n\n#  elif defined(NCBI_OS_OSF1)  &&  defined(HAVE_STATVFS)\n\n    GET_STATVFS_INFO;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namelen;\n    }\n    fs_name_ptr = st.f_fstypename;\n\n#  else\n\n     // Unknown UNIX OS\n    #if defined(HAVE_STATVFS)\n        GET_STATVFS_INFO;\n    #elif defined(HAVE_STATFS)\n        GET_STATFS_INFO;\n    #endif\n\n#  endif\n#endif\n\n    // Try to define file system type by name\n    if ((flags & fFSI_Type)  &&  fs_name_ptr) {\n        for (size_t i=0; \n             i < sizeof(s_FileSystem)/sizeof(s_FileSystem[0]); i++) {\n            if ( NStr::EqualNocase(fs_name_ptr, s_FileSystem[i].name) ) {\n                info->fs_type = s_FileSystem[i].type;\n                break;\n            }\n        }\n    }\n\n#if defined(SUPPORT_PANFS)\n    // Standard kernel calls cannot get correct information \n    // about PANFS mounts, so we use workaround for that.\n    if ((info->fs_type == CFileUtil::ePANFS) && (flags & fFSI_DiskSpace)) {\n        s_GetDiskSpace_PANFS(path, info);\n    }\n#endif\n}\n\n\nvoid CFileUtil::GetFileSystemInfo(const string& path,\n                                  CFileUtil::SFileSystemInfo* info)\n{\n    s_GetFileSystemInfo(path, info, fFSI_All);\n}\n\n\nUint8 CFileUtil::GetFreeDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.free_space;\n}\n\n\nUint8 CFileUtil::GetUsedDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.used_space;\n}\n\n\nUint8 CFileUtil::GetTotalDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.total_space;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileDeleteList / CFileDeleteAtExit\n//\n\nCFileDeleteList::~CFileDeleteList()\n{\n    ITERATE (TList, path, m_Paths) {\n        if (!CDirEntry(*path).Remove(CDirEntry::eRecursiveIgnoreMissing)) {\n            ERR_POST_X(5, Warning << \"CFileDeleteList: failed to remove path: \" << *path);\n        }\n    }\n}\n\nvoid CFileDeleteAtExit::Add(const string& path)\n{\n    s_DeleteAtExitFileList->Add(path);\n}\n\nconst CFileDeleteList& CFileDeleteAtExit::GetDeleteList(void)\n{\n    return *s_DeleteAtExitFileList;\n}\n\nvoid CFileDeleteAtExit::SetDeleteList(CFileDeleteList& list)\n{\n    *s_DeleteAtExitFileList = list;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTmpFile\n//\n\n\nCTmpFile::CTmpFile(ERemoveMode remove_file)\n{\n    m_FileName = CFile::GetTmpName();\n    if ( m_FileName.empty() ) {\n        NCBI_THROW(CFileException, eTmpFile, \n                   \"Cannot generate temporary file name\");\n    }\n    m_RemoveOnDestruction = remove_file;\n}\n\nCTmpFile::CTmpFile(const string& file_name, ERemoveMode remove_file)\n    : m_FileName(file_name), \n      m_RemoveOnDestruction(remove_file)\n{\n    return;\n}\n\nCTmpFile::~CTmpFile()\n{\n    // First, close and delete created streams.\n    m_InFile.reset();\n    m_OutFile.reset();\n\n    // Remove file if specified\n    if (m_RemoveOnDestruction == eRemove) {\n        NcbiSys_unlink(_T_XCSTRING(m_FileName));\n    }\n}\n\n    enum EIfExists {\n        /// You can make call of AsInputFile/AsOutputFile only once,\n        /// on each following call throws CFileException exception.\n        eIfExists_Throw,\n        /// Delete previous stream and return reference to new object.\n        eIfExists_Reset,\n        /// Return reference to current stream, or new if this is first call.\n        eIfExists_ReturnCurrent\n    };\n\n    // CTmpFile\n\nconst string& CTmpFile::GetFileName(void) const\n{\n    return m_FileName;\n}\n\n\nCNcbiIstream& CTmpFile::AsInputFile(EIfExists if_exists, IOS_BASE::openmode mode)\n{\n    if ( m_InFile.get() ) {\n        switch (if_exists) {\n        case eIfExists_Throw:\n            NCBI_THROW(CFileException, eTmpFile, \"AsInputFile() is already called\");\n            /*NOTREACHED*/\n            break;\n        case eIfExists_Reset:\n            // see below\n            break;\n        case eIfExists_ReturnCurrent:\n            return *m_InFile;\n        }\n    }\n    m_InFile.reset(new CNcbiIfstream(m_FileName.c_str(), IOS_BASE::in | mode));\n    return *m_InFile;\n}\n\n\nCNcbiOstream& CTmpFile::AsOutputFile(EIfExists if_exists, IOS_BASE::openmode mode)\n{\n    if ( m_OutFile.get() ) {\n        switch (if_exists) {\n        case eIfExists_Throw:\n            NCBI_THROW(CFileException, eTmpFile, \"AsOutputFile() is already called\");\n            /*NOTREACHED*/\n            break;\n        case eIfExists_Reset:\n            // see below\n            break;\n        case eIfExists_ReturnCurrent:\n            return *m_OutFile;\n        }\n    }\n    m_OutFile.reset(new CNcbiOfstream(m_FileName.c_str(), IOS_BASE::out | mode));\n    return *m_OutFile;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CMemoryFile\n//\n\n// Cached system's memory allocation granularity\nstatic unsigned long s_VirtualMemoryAllocationGranularity = 0;  \n\n\n// Platform-dependent memory file handle definition\nstruct SMemoryFileHandle {\n#if defined(NCBI_OS_MSWIN)\n    HANDLE  hMap;   // File-mapping handle (see ::[Open/Create]FileMapping())\n#else /* UNIX */\n    int     hMap;   // File handle\n#endif\n    string  sFileName;\n};\n\n// Platform-dependent memory file attributes\nstruct SMemoryFileAttrs {\n#if defined(NCBI_OS_MSWIN)\n    DWORD map_protect;\n    DWORD map_access;\n    DWORD file_share;\n    DWORD file_access;\n#else\n    int   map_protect;\n    int   map_access;\n    int   file_access;\n#endif\n};\n\n\n// Translate memory mapping attributes into OS specific flags.\nstatic SMemoryFileAttrs*\ns_TranslateAttrs(CMemoryFile_Base::EMemMapProtect protect_attr, \n                 CMemoryFile_Base::EMemMapShare   share_attr)\n{\n    SMemoryFileAttrs* attrs = new SMemoryFileAttrs();\n    memset(attrs, 0, sizeof(SMemoryFileAttrs));\n\n#if defined(NCBI_OS_MSWIN)\n\n    switch (protect_attr) {\n        case CMemoryFile_Base::eMMP_Read:\n            attrs->map_access  = FILE_MAP_READ;\n            attrs->map_protect = PAGE_READONLY;\n            attrs->file_access = GENERIC_READ;\n            break;\n        case CMemoryFile_Base::eMMP_Write:\n        case CMemoryFile_Base::eMMP_ReadWrite:\n            // On MS Windows platform Write & ReadWrite access\n            // to the mapped memory is equivalent\n            if  (share_attr == CMemoryFile_Base::eMMS_Shared ) {\n                attrs->map_access = FILE_MAP_ALL_ACCESS;\n            } else {\n                attrs->map_access = FILE_MAP_COPY;\n            }\n            attrs->map_protect = PAGE_READWRITE;\n            // So the file also must be open for reading and writing\n            attrs->file_access = GENERIC_READ | GENERIC_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    }\n    if ( share_attr == CMemoryFile_Base::eMMS_Shared ) {\n        attrs->file_share = FILE_SHARE_READ | FILE_SHARE_WRITE;\n    } else {\n        attrs->file_share = FILE_SHARE_READ;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    switch (share_attr) {\n        case CMemoryFile_Base::eMMS_Shared:\n            attrs->map_access  = MAP_SHARED;\n            // Read + write except, eMMP_Read mode\n            attrs->file_access = O_RDWR;\n            break;\n        case CMemoryFile_Base::eMMS_Private:\n            attrs->map_access  = MAP_PRIVATE;\n            // In the private mode writing to the mapped region\n            // do not affect the original file, so we can open it\n            // in the read-only mode.\n            attrs->file_access = O_RDONLY;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (protect_attr) {\n        case CMemoryFile_Base::eMMP_Read:\n            attrs->map_protect = PROT_READ;\n            attrs->file_access = O_RDONLY;\n            break;\n        case CMemoryFile_Base::eMMP_Write:\n            attrs->map_protect = PROT_WRITE;\n            break;\n        case CMemoryFile_Base::eMMP_ReadWrite:\n            attrs->map_protect = PROT_READ | PROT_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    }\n\n#endif\n    return attrs;\n}\n\n\nCMemoryFile_Base::CMemoryFile_Base(void)\n{\n    // Check if memory-mapping is supported on this platform\n    if ( !IsSupported() ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Memory-mapping is not supported by the C++ Toolkit\"\n                   \" on this platform\");\n    }\n    if ( !s_VirtualMemoryAllocationGranularity ) {\n        s_VirtualMemoryAllocationGranularity\n            = GetVirtualMemoryAllocationGranularity();\n    }\n}\n\n\nbool CMemoryFile_Base::IsSupported(void)\n{\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    return true;\n#else\n    return false;\n#endif\n}\n\n\n#if defined(NCBI_OS_MSWIN)\nstring s_LastErrorMessage(void)\n{\n    TXChar* ptr = NULL;\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n                  FORMAT_MESSAGE_FROM_SYSTEM     |\n                  FORMAT_MESSAGE_MAX_WIDTH_MASK  |\n                  FORMAT_MESSAGE_IGNORE_INSERTS,\n                  \"%0\", GetLastError(), \n                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  (TXChar*)(&ptr), 0, NULL);\n    string errmsg = ptr ? _T_CSTRING(ptr) : \"Unknown reason\";\n    LocalFree(ptr);\n    return errmsg;\n}\n#endif \n\nCMemoryFileSegment::CMemoryFileSegment(SMemoryFileHandle& handle,\n                                       SMemoryFileAttrs&  attrs,\n                                       TOffsetType        offset,\n                                       size_t             length)\n    : m_DataPtr(0), m_Offset(offset), m_Length(length),\n      m_DataPtrReal(0), m_OffsetReal(offset), m_LengthReal(length)\n{\n    if ( m_Offset < 0 ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"File offset may not be negative\");\n    }\n    if ( !m_Length ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"File mapping region size must be greater than 0\");\n    }\n    // Get system's memory allocation granularity.\n    if ( !s_VirtualMemoryAllocationGranularity ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot determine virtual memory allocation granularity\");\n    }\n    // Adjust mapped length and offset.\n    if ( m_Offset % s_VirtualMemoryAllocationGranularity ) {\n        m_OffsetReal -= m_Offset % s_VirtualMemoryAllocationGranularity;\n        m_LengthReal += m_Offset % s_VirtualMemoryAllocationGranularity;\n    }\n    // Map file view to memory\n    string errmsg;\n#if defined(NCBI_OS_MSWIN)\n    DWORD offset_hi  = DWORD(Int8(m_OffsetReal) >> 32);\n    DWORD offset_low = DWORD(Int8(m_OffsetReal) & 0xFFFFFFFF);\n    m_DataPtrReal = MapViewOfFile(handle.hMap, attrs.map_access,\n                                  offset_hi, offset_low, m_LengthReal);\n    if ( !m_DataPtrReal ) {\n        errmsg = s_LastErrorMessage();\n    }\n\n#elif defined(NCBI_OS_UNIX)\n    errno = 0;\n    m_DataPtrReal = mmap(0, m_LengthReal, attrs.map_protect,\n                         attrs.map_access, handle.hMap, m_OffsetReal);\n    if ( m_DataPtrReal == MAP_FAILED ) {\n        m_DataPtrReal = 0;\n        errmsg = strerror(errno);\n    }\n#endif\n    if ( !m_DataPtrReal ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot map file '\" + \n                   handle.sFileName + \"' to memory (offset=\" +\n                   NStr::Int8ToString(m_Offset) + \", length=\" +\n                   NStr::Int8ToString(m_Length) + \"): \" + errmsg);\n    }\n    // Calculate user's pointer to data\n    m_DataPtr = (char*)m_DataPtrReal + (m_Offset - m_OffsetReal);\n}\n\n\nCMemoryFileSegment::~CMemoryFileSegment(void)\n{\n    Unmap();\n}\n\n\nbool CMemoryFileSegment::Flush(void) const\n{\n    if ( !m_DataPtr ) {\n        CNcbiError::Set(CNcbiError::eBadAddress);\n        return false;\n    }\n    bool status;\n#if defined(NCBI_OS_MSWIN)\n    status = (FlushViewOfFile(m_DataPtrReal, m_LengthReal) != 0);\n    if ( !status ) {\n        LOG_ERROR_AND_RETURN_WIN(87, \"CMemoryFileSegment::Flush(): Cannot flush memory segment\");\n    }\n#elif defined(NCBI_OS_UNIX)\n    status = (msync((char*)m_DataPtrReal, m_LengthReal, MS_SYNC) == 0);\n    if ( !status ) {\n        LOG_ERROR_AND_RETURN_ERRNO(87, \"CMemoryFileSegment::Flush(): Cannot flush memory segment\");\n    }\n#endif\n    return status;\n}\n\n\nbool CMemoryFileSegment::Unmap(void)\n{\n    // If file view is not mapped do nothing\n    if ( !m_DataPtr ) {\n        return true;\n    }\n    bool status;\n#if defined(NCBI_OS_MSWIN)\n    status = (UnmapViewOfFile(m_DataPtrReal) != 0);\n    if (!status) {\n        LOG_ERROR_AND_RETURN_WIN(88, \"CMemoryFileSegment::Unmap(): Cannot unmap memory segment\");\n    }\n#elif defined(NCBI_OS_UNIX)\n    status = (munmap((char*)m_DataPtrReal, (size_t) m_LengthReal) == 0);\n    if (!status) {\n        LOG_ERROR_AND_RETURN_ERRNO(88, \"CMemoryFileSegment::Unmap(): Cannot unmap memory segment\");\n    }\n#endif\n    if ( status ) {\n        m_DataPtr = 0;\n    }\n    return status;\n}\n\n\nvoid CMemoryFileSegment::x_Verify(void) const\n{\n    if ( m_DataPtr ) {\n        return;\n    }\n    NCBI_THROW(CFileException, eMemoryMap, \"File not mapped\");\n}\n\n\nCMemoryFileMap::CMemoryFileMap(const string&  file_name,\n                               EMemMapProtect protect,\n                               EMemMapShare   share,\n                               EOpenMode      mode,\n                               Uint8          max_file_len)\n    : m_FileName(file_name), m_Handle(0), m_Attrs(0)\n{\n#if defined(NCBI_OS_MSWIN)\n    // Name of a file-mapping object cannot contain '\\'\n    NStr::ReplaceInPlace(m_FileName, \"\\\\\", \"/\");\n#endif\n\n    // Translate attributes \n    m_Attrs = s_TranslateAttrs(protect, share);\n\n    // Create file if necessary\n    if ( mode == eCreate ) {\n        x_Create(max_file_len);\n    }\n    // Check file size\n    Int8 file_size = GetFileSize();\n    if ( file_size < 0 ) {\n        if ( m_Attrs ) {\n            delete m_Attrs;\n            m_Attrs = 0;\n        }\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"To be memory mapped the file must exist: \" + m_FileName);\n    }\n    // Extend file size if necessary\n    if ( mode == eExtend  &&  max_file_len > (Uint8)file_size) {\n        x_Extend(file_size, max_file_len);\n        file_size = (Int8)max_file_len;\n    }\n\n    // Open file\n    if ( file_size == 0 ) {\n        // Special case -- file is empty\n        m_Handle = new SMemoryFileHandle();\n        m_Handle->hMap = kInvalidHandle;\n        m_Handle->sFileName = m_FileName;\n        return;\n    }\n    x_Open();\n}\n\n\nCMemoryFileMap::~CMemoryFileMap(void)\n{\n    // Unmap used memory and close file\n    x_Close();\n    // Clean up allocated memory\n    if ( m_Attrs ) {\n        delete m_Attrs;\n    }\n}\n\n\nvoid* CMemoryFileMap::Map(TOffsetType offset, size_t length)\n{\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        // Special case.\n        // Always return 0 if a file is unmapped or have zero length.\n        return 0;\n    }\n    // Map file wholly if the length of the mapped region is not specified\n    if ( !length ) {\n        Int8 file_size = GetFileSize() - offset;\n        if ( (Uint8)file_size > get_limits(length).max() ) {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"File too big for memory mapping \"   \\\n                       \"(file \\\"\" + m_FileName +\"\\\", \"\n                       \"offset=\" + NStr::Int8ToString(offset) + \", \"    \\\n                       \"length=\" + NStr::Int8ToString(length) + \")\");\n        } else if ( file_size > 0 ) {\n            length = (size_t)file_size;\n        } else {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"Mapping region offset specified beyond file size\");\n        }\n    }\n    // Map file segment\n    CMemoryFileSegment* segment =  \n        new CMemoryFileSegment(*m_Handle, *m_Attrs, offset, length);\n    void* ptr = segment->GetPtr();\n    if ( !ptr ) {\n        delete segment;\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot map (file \\\"\" + m_FileName +\"\\\", \"\n                   \"offset=\" + NStr::Int8ToString(offset) + \", \"    \\\n                   \"length=\" + NStr::Int8ToString(length) + \")\");\n    }\n    m_Segments[ptr] = segment;\n    return ptr;\n}\n\n\nbool CMemoryFileMap::Unmap(void* ptr)\n{\n    // Unmap mapped view of a file\n    bool status = false;\n    TSegments::iterator segment = m_Segments.find(ptr);\n    if ( segment != m_Segments.end() ) {\n        status = segment->second->Unmap();\n        if ( status ) {\n            delete segment->second;\n            m_Segments.erase(segment);\n        }\n    }\n    if ( !status ) {\n        LOG_ERROR_AND_RETURN_ERRNO(89, \"CMemoryFileMap::Unmap(): Memory segment not found\");\n    }\n    return status;\n}\n\n\nbool CMemoryFileMap::UnmapAll(void)\n{\n    bool status = true;\n    void* key_to_delete = 0;\n    ITERATE(TSegments, it, m_Segments) {\n        if ( key_to_delete ) {\n            m_Segments.erase(key_to_delete);\n        }\n        bool unmapped = it->second->Unmap();\n        if ( status ) {\n            status = unmapped;\n        }\n        if ( unmapped ) {\n            key_to_delete = it->first;\n            delete it->second;\n        } else {\n            key_to_delete = 0;\n        }\n    }\n    if ( key_to_delete ) {\n        m_Segments.erase(key_to_delete);\n    }\n    return status;\n}\n\n\nInt8 CMemoryFileMap::GetFileSize(void) const\n{\n    // On Unix -- mapping handle is the same as file handle,\n    // use it to get file size if file is already opened.\n    // On Windows -- file handle is already closed, use file name. \n    #if defined(NCBI_OS_UNIX)\n        if ( m_Handle  &&  (m_Handle->hMap != kInvalidHandle) ) {\n            struct stat st;\n            if ( fstat(m_Handle->hMap, &st) != 0 ) {\n                CNcbiError::SetFromErrno();\n                return -1L;\n            }\n            return st.st_size;\n        }\n    #endif\n    return CFile(m_FileName).GetLength();\n}\n\n\nvoid CMemoryFileMap::x_Open(void)\n{\n    m_Handle = new SMemoryFileHandle();\n    m_Handle->hMap = kInvalidHandle;\n    m_Handle->sFileName = m_FileName;\n\n    string errmsg;\n\n    for (;;) { // quasi-TRY block\n\n#if defined(NCBI_OS_MSWIN)\n        errmsg = \": \";\n        TXString filename(_T_XSTRING(m_FileName));\n\n        // If failed to attach to an existing file-mapping object then\n        // create a new one (based on the specified file)\n        HANDLE hMap = OpenFileMapping(m_Attrs->map_access, false,\n                                      filename.c_str());\n        if ( !hMap ) {\n            // Open file\n            HANDLE hFile;\n            hFile = CreateFile(filename.c_str(), m_Attrs->file_access, \n                                m_Attrs->file_share, NULL,\n                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n            if ( hFile == INVALID_HANDLE_VALUE ) {\n                errmsg += s_LastErrorMessage();\n                break;\n            }\n            // Create mapping\n            hMap = CreateFileMapping(hFile, NULL, m_Attrs->map_protect,\n                                     0, 0, filename.c_str());\n            if ( !hMap ) {\n                errmsg += s_LastErrorMessage();\n                CloseHandle(hFile);\n                break;\n            }\n            CloseHandle(hFile);\n        }\n        m_Handle->hMap = hMap;\n\n#elif defined(NCBI_OS_UNIX)\n        // Open file\n        m_Handle->hMap = open(m_FileName.c_str(), m_Attrs->file_access);\n        if ( m_Handle->hMap < 0 ) {\n            break;\n        }\n#endif\n        // Success\n        return;\n    }\n    // Error: close and cleanup\n    x_Close();\n    NCBI_THROW(CFileException, eMemoryMap,\n               \"CMemoryFile: Cannot memory map file \\\"\" + m_FileName + '\"');\n}\n\n\nvoid CMemoryFileMap::x_Close()\n{\n    // Unmap all mapped segments with error ignoring\n    ITERATE(TSegments, it, m_Segments) {\n        delete it->second;\n    }\n    m_Segments.clear();\n\n    // Close handle and cleanup\n    if ( m_Handle ) {\n        if ( m_Handle->hMap != kInvalidHandle ) { \n#if defined(NCBI_OS_MSWIN)\n            CloseHandle(m_Handle->hMap);\n#elif defined(NCBI_OS_UNIX)\n            close(m_Handle->hMap);\n#endif\n        }\n        delete m_Handle;\n        m_Handle  = 0;\n    }\n}\n\n\n// Extend/truncate file size to 'new_size' bytes.\n// Do not change position in the file.\n// Return 0 on success, or errno value.\n// NOTE: Unix only.\n#if defined(NCBI_OS_UNIX)\nint s_FTruncate(int fd, Uint8 new_size)\n{\n    int errcode = 0;\n    // ftruncate() add zeros\n    while (ftruncate(fd, (off_t)new_size) < 0) {\n        if (errno != EINTR) {\n            errcode = errno;\n            break;\n        }\n    }\n    return errcode;\n}\n#endif\n\n// Extend file size to 'new_size' bytes,\n// 'new_size' should be > current file size.\n// Do not change position in the file.\n// Return 0 on success, or errno value.\n// Similar to s_FTruncate() but can extend file size only. \n// NOTE: \n//   Works on both Windows and Unix, but file should not be\n//   opened in append mode, or write() will ignore current\n//   position in the file and start with EOF.\nint s_FExtend(int fd, Uint8 new_size)\n{\n    if (!new_size) {\n        return 0;\n    }\n    // Save current position\n    off_t current_pos = lseek(fd, 0, SEEK_CUR);\n    if (current_pos < 0) {\n        return errno;\n    }\n    // Set position beyond EOF, one byte less than necessary,\n    // and write single zero byte.\n    off_t pos = lseek(fd, (off_t)new_size - 1, SEEK_SET);\n    if (pos < 0) {\n        return errno;\n    }\n    while (write(fd, \"\\0\", 1) < 0) {\n        if (errno != EINTR) {\n            return errno;\n        }\n    }\n    // Restore current position\n    pos = lseek(fd, current_pos, SEEK_SET);\n    if (pos < 0) {\n        return errno;\n    }\n    return 0;\n}\n\n\nvoid CMemoryFileMap::x_Create(Uint8 size)\n{\n    int pmode = S_IREAD;\n#if defined(NCBI_OS_MSWIN)\n    if (m_Attrs->file_access & (GENERIC_READ | GENERIC_WRITE)) \n#elif defined(NCBI_OS_UNIX)\n    if (m_Attrs->file_access & O_RDWR) \n#endif\n        pmode |= S_IWRITE;\n\n    // Create new file\n    int fd = NcbiSys_creat(_T_XCSTRING(m_FileName), pmode);\n    if ( fd < 0 ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot create file \\\"\" + m_FileName + '\"');\n    }\n    // and fill it with zeros\n    int errcode = s_FExtend(fd, size);\n    close(fd);\n    if (errcode) {\n        string errmsg = _T_STDSTRING(NcbiSys_strerror(errcode));\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot create file with specified size: \" + errmsg);\n    }\n}\n\n\nvoid CMemoryFileMap::x_Extend(Uint8 size, Uint8 new_size)\n{\n    if (size >= new_size) {\n        return;\n    }\n    // Open file for writing.\n    // Note: do not use append mode, or s_FExtend() will work incorrectly.\n    int fd = NcbiSys_open(_T_XCSTRING(m_FileName), O_WRONLY, 0);\n    if ( fd < 0 ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot open file \\\"\" + m_FileName +\n                   \"\\\" to change its size\");\n    }\n    // and extend it with zeros\n    int errcode = s_FExtend(fd, new_size);\n    close(fd);\n    if (errcode) {\n       string errmsg = _T_STDSTRING(NcbiSys_strerror(errcode));\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot extend file size: \" + errmsg);\n    }\n}\n\n\nCMemoryFileSegment* \nCMemoryFileMap::x_GetMemoryFileSegment(void* ptr) const\n{\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" File is not mapped\");\n    }\n    TSegments::const_iterator segment = m_Segments.find(ptr);\n    if ( segment == m_Segments.end() ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot find mapped file segment\"\n                   \" with specified address\");\n    }\n    return segment->second;\n}\n\n   \nCMemoryFile::CMemoryFile(const string&  file_name,\n                         EMemMapProtect protect,\n                         EMemMapShare   share,\n                         TOffsetType    offset,\n                         size_t         length,\n                         EOpenMode      mode,\n                         Uint8          max_file_len)\n\n    : CMemoryFileMap(file_name, protect, share, mode, max_file_len), m_Ptr(0)\n{\n    // Check that file is ready for mapping to memory\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        return;\n    }\n    Map(offset, length);\n}\n\n\nvoid* CMemoryFile::Map(TOffsetType offset, size_t length)\n{\n    // Unmap if already mapped\n    if ( m_Ptr ) {\n        Unmap();\n    }\n    m_Ptr = CMemoryFileMap::Map(offset, length);\n    return m_Ptr;\n}\n\n\nbool CMemoryFile::Unmap()\n{\n    if ( !m_Ptr ) {\n        return true;\n    }\n    bool status = CMemoryFileMap::Unmap(m_Ptr);\n    m_Ptr = 0;\n    return status;\n}\n\n\nvoid* CMemoryFile::Extend(size_t length)\n{\n    x_Verify();\n\n    // Get current mapped segment\n    CMemoryFileSegment* segment = x_GetMemoryFileSegment(m_Ptr);\n    TOffsetType offset = segment->GetOffset();\n\n    // Get file size\n    Int8 file_size = GetFileSize();\n\n    // Map file wholly if the length of the mapped region is not specified\n    if ( !length ) {\n        Int8 fs = file_size - offset;\n        if ( (Uint8)fs > get_limits(length).max() ) {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"Specified length of the mapping region\"\n                       \" is too big\"\n                       \" (length=\" + NStr::Int8ToString(length) + ')');\n        } else if ( fs > 0 ) {\n            length = (size_t)fs;\n        } else {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"Specified offset of the mapping region\"\n                       \" exceeds the file size\");\n        }\n    }\n\n    // Changing file size is necessary\n    if (Int8(offset + length) > file_size) {\n        x_Close();\n        m_Ptr = 0;\n        x_Extend(file_size, offset + length);\n        x_Open();\n    }\n    // Remap current region\n    Map(offset, length);\n    return GetPtr();\n}\n\n\nvoid CMemoryFile::x_Verify(void) const\n{\n    if ( m_Ptr ) {\n        return;\n    }\n    NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFile: File is not mapped\");\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileException\n//\n\nconst char* CFileException::GetErrCodeString(void) const\n{\n    switch (GetErrCode()) {\n    case eMemoryMap:    return \"eMemoryMap\";\n    case eRelativePath: return \"eRelativePath\";\n    case eNotExists:    return \"eNotExists\";\n    case eFileIO:       return \"eFileIO\";\n    case eTmpFile:      return \"eTmpFile\";\n    default:            return CException::GetErrCodeString();\n    }\n}\n\nconst char* CFileErrnoException::GetErrCodeString(void) const\n{\n    switch (GetErrCode()) {\n    case eFile:            return \"eFile\";\n    case eFileSystemInfo:  return \"eFileSystemInfo\";\n    case eFileLock:        return \"eFileLock\";\n    case eFileIO:          return \"eFileIO\";\n    default:               return CException::GetErrCodeString();\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Find files\n//\n\nvoid x_Glob(const string& path,\n            const std::list<string>& parts,\n            std::list<string>::const_iterator next,\n            std::list<string>& result,\n            TFindFiles flags)\n{\n    vector<string> paths;\n    paths.push_back(path);\n    vector<string> masks;\n    masks.push_back(*next);\n    bool last = ++next == parts.end();\n    TFindFiles ff = flags;\n    if ( !last ) {\n        ff &= ~(fFF_File | fFF_Recursive);\n        ff |= fFF_Dir;\n    }\n    std::list<string> found;\n    FindFiles(found, paths.begin(), paths.end(), masks, ff);\n    if ( last ) {\n        result.insert(result.end(), found.begin(), found.end());\n    }\n    else {\n        if ( !found.empty() ) {\n            ITERATE(std::list<string>, it, found) {\n                x_Glob(CDirEntry::AddTrailingPathSeparator(*it), parts, next, result, flags);\n            }\n        }\n        else {\n            x_Glob(CDirEntry::AddTrailingPathSeparator(path + masks.front()), parts, next, result, flags);\n        }\n    }\n}\n\n\nvoid FindFiles(const string& pattern,  std::list<string>& result, TFindFiles flags)\n{\n    TFindFiles find_type = flags & fFF_All;\n    if ( find_type == 0 ) {\n        flags |= fFF_All;\n    }\n\n    string kDirSep(1, CDirEntry::GetPathSeparator());\n    string abs_path = CDirEntry::CreateAbsolutePath(pattern);\n    string search_path = kDirSep;\n\n    std::list<string> parts;\n    NStr::Split(abs_path, kDirSep, parts, NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n    if ( parts.empty() ) {\n        return;\n    }\n\n#if defined(DISK_SEPARATOR)\n    // Network paths on Windows start with double back-slash and\n    // need special processing.\n    // Note: abs_path has normalized in CreateAbsolutePath().\n\n    string kNetSep(2, CDirEntry::GetPathSeparator());\n    bool is_network = abs_path.find(kNetSep) == 0;\n    if ( is_network ) {\n        search_path = kNetSep + parts.front() + kDirSep;\n        parts.erase(parts.begin());\n    }\n    else {\n        string disk;\n        CDirEntry::SplitPathEx(abs_path, &disk);\n        if ( disk.empty() ) {\n            // Disk is missing in the absolute path, add it.\n            CDirEntry::SplitPathEx(CDir::GetCwd(), &disk);\n            if ( !disk.empty() ) {\n                search_path = disk + kDirSep;\n            }\n        }\n        else {\n            search_path = disk;\n            // Disk is present but may be missing dir separator\n            if (abs_path[disk.size()] == DIR_SEPARATOR) {\n                parts.erase(parts.begin()); // Remove disk from parts\n                search_path += kDirSep;\n            }\n            else {\n                // Disk is included in the first part, remove it.\n                string temp = parts.front().substr(disk.size());\n                parts.erase(parts.begin());\n                parts.insert(parts.begin(), temp);\n            }\n        }\n    }\n#endif\n\n    x_Glob(search_path, parts, parts.begin(), result, flags);\n}\n\n\n#define UNDEFINED_SORT_MODE kMax_Int\n\nSCompareDirEntries::SCompareDirEntries(ESort s1)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = UNDEFINED_SORT_MODE;\n    m_Sort[2] = UNDEFINED_SORT_MODE;\n}\nSCompareDirEntries::SCompareDirEntries(ESort s1, ESort s2)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = s2;\n    m_Sort[2] = UNDEFINED_SORT_MODE;\n}\nSCompareDirEntries::SCompareDirEntries(ESort s1, ESort s2, ESort s3)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = s2;\n    m_Sort[2] = s3;\n}\n\nbool SCompareDirEntries::operator()(const string& p1, const string& p2)\n{\n    // Default case\n    if (m_Sort[0] == ePath) {\n        return (p1 < p2);\n    }\n    string d1, n1, e1;\n    string d2, n2, e2;\n    CDirEntry::SplitPath(p1, &d1, &n1, &e1);\n    CDirEntry::SplitPath(p2, &d2, &n2, &e2);\n\n    int nc = 0;\n\n    for (int i = 0; i < 3; i++) {\n        if (m_Sort[i] == UNDEFINED_SORT_MODE) {\n            break;\n        }\n        switch (m_Sort[i]) {\n        case ePath:\n            // usually we shouldn't get here, so just compare and exit\n            return (p1 < p2);\n        case eDir:\n            nc = NStr::CompareCase(d1, d2);\n            break;\n        case eName:\n            nc = NStr::CompareCase(n1 + e1, n2 + e2);\n            break;\n        case eBase:\n            nc = NStr::CompareCase(n1, n2);\n            break;\n        case eExt:\n            nc = NStr::CompareCase(e1, e2);\n            break;\n        default:\n            NCBI_THROW(CCoreException, eInvalidArg, \"Unknown sorting mode\");\n        }\n        if (nc != 0)\n            break;\n    }\n    return nc < 0;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileIO\n//\n\nCFileIO::CFileIO(void) :\n    m_Handle(kInvalidHandle),\n    m_AutoClose(false),\n    m_AutoRemove(CFileIO::eDoNotRemove)\n{\n}\n\n\nCFileIO::~CFileIO()\n{\n    if (m_Handle != kInvalidHandle && m_AutoClose) {\n        try {\n            Close();\n        }\n        NCBI_CATCH_ALL(\"Error while closing file [IGNORED]\");\n    }\n}\n\n\nvoid CFileIO::Open(const string& filename,\n                   EOpenMode     open_mode,\n                   EAccessMode   access_mode,\n                   EShareMode    share_mode)\n{\n#if defined(NCBI_OS_MSWIN)\n\n    // Translate parameters\n    DWORD dwAccessMode, dwShareMode, dwOpenMode;\n\n    switch (open_mode) {\n        case eCreate:\n            dwOpenMode = CREATE_ALWAYS;\n            break;\n        case eCreateNew:\n            dwOpenMode = CREATE_NEW;\n            break;\n        case eOpen:\n            dwOpenMode = OPEN_EXISTING;\n            break;\n        case eOpenAlways:\n            dwOpenMode = OPEN_ALWAYS;\n            break;\n        case eTruncate:\n            dwOpenMode = TRUNCATE_EXISTING;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (access_mode) {\n        case eRead:\n            dwAccessMode = GENERIC_READ;\n            break;\n        case eWrite:\n            dwAccessMode = GENERIC_WRITE;\n            break;\n        case eReadWrite:\n            dwAccessMode = GENERIC_READ | GENERIC_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    };\n    switch (share_mode) {\n        case eShareRead:\n            dwShareMode = FILE_SHARE_READ;\n            break;\n        case eShareWrite:\n            dwShareMode = FILE_SHARE_WRITE;\n            break;\n        case eShare:\n            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n            break;\n        case eExclusive:\n            dwShareMode = 0;\n            break;\n        default:\n            _TROUBLE;\n    }\n\n    m_Handle = CreateFile(_T_XCSTRING(filename),\n                          dwAccessMode, dwShareMode, NULL, dwOpenMode,\n                          FILE_ATTRIBUTE_NORMAL, NULL);\n\n#elif defined(NCBI_OS_UNIX)\n\n    // Translate parameters\n# if defined(O_BINARY)\n    int flags = O_BINARY;\n# else\n    int flags = 0; \n# endif\n    mode_t mode = 0;\n\n    switch (open_mode) {\n        case eCreate:\n            flags |= (O_CREAT | O_TRUNC);\n            break;\n        case eCreateNew:\n            if ( CFile(filename).Exists() ) {\n                NCBI_THROW(CFileException, eFileIO,\n                           \"Open mode is eCreateNew but file already exists: \"\n                           + filename );\n            }\n            flags |= O_CREAT;\n            break;\n        case eOpen:\n            // by default\n            break;\n        case eOpenAlways:\n            if ( !CFile(filename).Exists() ) {\n                flags |= O_CREAT;\n            }\n            break;\n        case eTruncate:\n            flags |= O_TRUNC;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (access_mode) {\n        case eRead:\n            flags |= O_RDONLY;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fRead,\n                                          CDirEntry::fRead,\n                                          CDirEntry::fRead, 0);\n            break;\n        case eWrite:\n            flags |= O_WRONLY;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fWrite,\n                                          CDirEntry::fWrite,\n                                          CDirEntry::fWrite, 0);\n            break;\n        case eReadWrite:\n            flags |= O_RDWR;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fRead | CDirEntry::fWrite,\n                                          CDirEntry::fRead | CDirEntry::fWrite,\n                                          CDirEntry::fRead | CDirEntry::fWrite, 0);\n            break;\n        default:\n            _TROUBLE;\n    };\n    // Dummy, ignore 'share_mode' on UNIX\n    share_mode = eShare;\n\n    // Try to open/create file\n    m_Handle = open(filename.c_str(), flags, mode);\n\n#endif\n\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot open file \" + filename);\n    }\n    m_Pathname = filename;\n    m_AutoClose = true;\n}\n\n\nvoid CFileIO::CreateTemporary(const string& dir,\n                              const string& prefix,\n                              EAutoRemove auto_remove)\n{\n    if (m_Handle != kInvalidHandle) {\n       NCBI_THROW(CFileException, eFileIO,\n                  \"Cannot create temporary: Handle already open\");\n    }\n    static volatile int s_Count = 0;\n    string x_dir = dir;\n    if (x_dir.empty()) {\n        // Get application specific temporary directory name\n        x_dir = CDir::GetAppTmpDir();\n    }\n    if (!x_dir.empty()) {\n        x_dir = CDirEntry::AddTrailingPathSeparator(x_dir);\n    }\n    Uint8 x_tid = (Uint8) GetCurrentThreadSystemID();\n    unsigned int tid = (unsigned int) x_tid;\n    string x_prefix = prefix\n        + NStr::NumericToString(CProcess::GetCurrentPid())\n        + NStr::NumericToString(s_Count++)\n        + NStr::NumericToString(tid);\n\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    string pattern = x_dir + x_prefix;\n\n#  if defined(NCBI_OS_UNIX)\n    pattern += \"XXXXXX\";\n    if (pattern.size() > PATH_MAX) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Pattern too long '\" + pattern + \"'\");\n    }\n    char pathname[PATH_MAX+1];\n    memcpy(pathname, pattern.c_str(), pattern.size()+1);\n    if ((m_Handle = mkstemp(pathname)) == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"mkstemp() failed for '\" + pattern + \"'\");\n    }\n    m_Pathname = pathname;\n    if (auto_remove == eRemoveASAP) {\n        NcbiSys_remove(_T_XCSTRING(m_Pathname));\n    }\n\n#  elif defined(NCBI_OS_MSWIN)\n    unsigned long ofs = (unsigned long) int(rand());\n    while (ofs < numeric_limits<unsigned long>::max()) {\n        char buffer[40];\n        _ultoa(ofs, buffer, 36);\n        string pathname = pattern + buffer;\n        m_Handle = CreateFile(_T_XCSTRING(pathname), GENERIC_ALL, 0, NULL,\n                              CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY, NULL);\n        if (m_Handle != kInvalidHandle) {\n            m_Pathname.swap(pathname);\n            break;\n        }\n        if (::GetLastError() != ERROR_FILE_EXISTS) {\n            break;\n        }\n        ++ofs;\n    }\n\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Unable to create temporary file '\" + pattern + \"'\");\n    }\n\n#  endif\n\n#else // defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    x_prefix += NStr::NumericToString((unsigned int) rand());\n    Open(s_StdGetTmpName(x_dir.c_str(), x_prefix.c_str()),\n         eCreateNew, eReadWrite);\n#endif\n\n    m_AutoClose = true;\n    m_AutoRemove = auto_remove;\n}\n\n\nvoid CFileIO::Close(void)\n{\n    if (m_Handle != kInvalidHandle) {\n#if defined(NCBI_OS_MSWIN)\n        if (!::CloseHandle(m_Handle)) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"CloseHandle() failed\");\n        }\n#elif defined(NCBI_OS_UNIX)\n        while (close(m_Handle) < 0) {\n            if (errno != EINTR) {\n                NCBI_THROW(CFileErrnoException, eFileIO, \"close() failed\");\n            }\n        }\n#endif\n        m_Handle = kInvalidHandle;\n\n        if (m_AutoRemove != eDoNotRemove)\n            NcbiSys_remove(_T_XCSTRING(m_Pathname));\n    }\n}\n\n\nsize_t CFileIO::Read(void* buf, size_t count) const\n{\n    if (count == 0) {\n        return 0;\n    }\n    char* ptr = (char*) buf;\n    \n#if defined(NCBI_OS_MSWIN)\n    const DWORD   kMax = numeric_limits<DWORD>::max();\n#elif defined(NCBI_OS_UNIX)\n    const ssize_t kMax = numeric_limits<ssize_t>::max();\n#endif   \n    \n    while (count) {\n#if defined(NCBI_OS_MSWIN)\n        DWORD nmax = count > kMax ? kMax : (DWORD) count;\n        DWORD n = 0;\n        if ( ::ReadFile(m_Handle, ptr, nmax, &n, NULL) == 0 ) {\n            if (GetLastError() == ERROR_HANDLE_EOF) {\n                break;\n            }\n            NCBI_THROW(CFileErrnoException, eFileIO, \"ReadFile() failed\");\n        }\n        if ( n == 0 ) {\n            break;\n        }\n#elif defined(NCBI_OS_UNIX)\n        ssize_t nmax = count > kMax ? kMax : (ssize_t) count;\n        ssize_t n = ::read(int(m_Handle), ptr, nmax);\n        if (n == 0) {\n            break;\n        }\n        if ( n < 0 ) {\n            if (errno == EINTR) {\n                continue;\n            }\n            NCBI_THROW(CFileErrnoException, eFileIO, \"read() failed\");\n        }\n#endif\n        count -= n;\n        ptr += n;\n    }\n    return ptr - (char*)buf;\n}\n\n\nsize_t CFileIO::Write(const void* buf, size_t count) const\n{\n    if (count == 0) {\n        return 0;\n    }\n    const char* ptr = (const char*) buf;\n    \n#if defined(NCBI_OS_MSWIN)\n    const DWORD   kMax = numeric_limits<DWORD>::max();\n#elif defined(NCBI_OS_UNIX)\n    const ssize_t kMax = numeric_limits<ssize_t>::max();\n#endif   \n    \n    while (count) {\n#if defined(NCBI_OS_MSWIN)\n        DWORD nmax = count > kMax ? kMax : (DWORD) count;\n        DWORD n = 0;\n        if ( ::WriteFile(m_Handle, ptr, nmax, &n, NULL) == 0 ) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"WriteFile() failed\");\n        }\n#elif defined(NCBI_OS_UNIX)\n        ssize_t nmax = count > kMax ? kMax : (ssize_t) count;\n        ssize_t n = ::write(int(m_Handle), ptr, nmax);\n        if ( n < 0  &&  errno == EINTR ) {\n            continue;\n        }\n        if ( n <= 0 ) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"write() failed\");\n        }\n#endif\n        count -= n;\n        ptr += n;\n    }\n    return ptr - (char*)buf;\n}\n\n\nvoid CFileIO::Flush(void) const\n{\n    bool res;\n#if defined(NCBI_OS_MSWIN)\n    res = (FlushFileBuffers(m_Handle) == TRUE);\n#elif defined(NCBI_OS_UNIX)\n    res = (fsync(m_Handle) == 0);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot flush\");\n    }\n}\n\n\nvoid CFileIO::SetFileHandle(TFileHandle handle)\n{\n    // Close previous handle if needed\n    if (m_AutoClose) {\n        Close();\n        m_AutoClose = false;\n    }\n    // Use given handle for all I/O\n    m_Handle = handle;\n}\n\n\nUint8 CFileIO::GetFilePos(void) const\n{\n#if defined(NCBI_OS_MSWIN)\n    LARGE_INTEGER ofs;\n    LARGE_INTEGER pos;\n    ofs.QuadPart = 0;\n    pos.QuadPart = 0;\n    BOOL res = SetFilePointerEx(m_Handle, ofs, &pos, FILE_CURRENT);\n    if (res) {\n        return (Uint8)pos.QuadPart;\n    }\n#elif defined(NCBI_OS_UNIX)\n    off_t pos = lseek(m_Handle, 0, SEEK_CUR);\n    if (pos != -1L) {\n        return (Uint8)pos;\n    }\n#endif\n    NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot get file position\");\n    // Unreachable\n    return 0;\n}\n\n\nvoid CFileIO::SetFilePos(Uint8 position) const\n{\n#if defined(NCBI_OS_MSWIN)\n    LARGE_INTEGER ofs;\n    ofs.QuadPart = position;\n    bool res = (SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN) == TRUE);\n#elif defined(NCBI_OS_UNIX)\n    bool res = (lseek(m_Handle, (off_t)position, SEEK_SET) != -1);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file positon\"\n                   \" (position=\" + NStr::UInt8ToString(position) + ')');\n    }\n}\n\n\nvoid CFileIO::SetFilePos(Int8 offset, EPositionMoveMethod move_method) const\n{\n#if defined(NCBI_OS_MSWIN)\n    DWORD from = 0;\n    switch (move_method) {\n        case eBegin:\n            from = FILE_BEGIN;\n            break;\n        case eCurrent:\n            from = FILE_CURRENT;\n            break;\n        case eEnd:\n            from = FILE_END;\n            break;\n        default:\n            _TROUBLE;\n    }\n    LARGE_INTEGER ofs;\n    ofs.QuadPart = offset;\n    bool res = (SetFilePointerEx(m_Handle, ofs, NULL, from) == TRUE);\n\n#elif defined(NCBI_OS_UNIX)\n    int from = 0;\n    switch (move_method) {\n        case eBegin:\n            from = SEEK_SET;\n            break;\n        case eCurrent:\n            from = SEEK_CUR;\n            break;\n        case eEnd:\n            from = SEEK_END;\n            break;\n        default:\n            _TROUBLE;\n    }\n    bool res = (lseek(m_Handle, (off_t)offset, from) != -1);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file positon\"\n                   \" (offset=\" + NStr::Int8ToString(offset) +\n                   \", method=\" + NStr::IntToString(move_method) + ')');\n    }\n}\n\n\nUint8 CFileIO::GetFileSize(void) const\n{\n#if defined(NCBI_OS_MSWIN)\n    DWORD size_hi = 0;\n    DWORD size_lo = ::GetFileSize(m_Handle, &size_hi);\n    if (size_lo != INVALID_FILE_SIZE) {\n        return ((unsigned __int64)size_hi << 32) | size_lo;\n    }\n#elif defined(NCBI_OS_UNIX)\n    struct stat st;\n    if (fstat(m_Handle, &st) != -1) {\n        return st.st_size;\n    }\n#endif\n    NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot get file size\");\n    // Unreachable\n    return 0;\n}\n\n\nvoid CFileIO::SetFileSize(Uint8 length, EPositionMoveMethod pos) const\n{\n#if defined(NCBI_OS_MSWIN)\n    BOOL res = true;\n    // Get current position if needed\n    LARGE_INTEGER ofs;\n    LARGE_INTEGER saved;\n    ofs.QuadPart = 0;\n    saved.QuadPart = 0;\n    // Save current file position if needed\n    if (pos == eCurrent) {\n        res = SetFilePointerEx(m_Handle, ofs, &saved, FILE_CURRENT);\n    }\n    if (res) {\n        // Set file position to specified length (new EOF)\n        ofs.QuadPart = length;\n        res = SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN);\n        // And change file size\n        if (res) {\n            res = SetEndOfFile(m_Handle);\n        }\n        // Set file pointer if other than eEnd\n        if (res) {\n            if (pos == eBegin) {\n                // eBegin\n                ofs.QuadPart = 0;\n                res = SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN);\n            }\n            else if (pos == eCurrent) {\n                res = SetFilePointerEx(m_Handle, saved, NULL, FILE_BEGIN);\n            }\n            // Nothing todo if eEnd, because we already at the EOF position\n        }\n    }\n#elif defined(NCBI_OS_UNIX)\n    bool res = true;\n    int errcode = s_FTruncate(m_Handle, length);\n    if (!errcode  &&  pos != eCurrent) {\n        // Move file offset to the start/end of the file.\n        SetFilePos(0, pos);\n    }\n    if (errcode) {\n       // Restore errno for CFileErrnoException exception\n       errno = errcode;\n       res = false;\n    }\n   \n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file size\"\n                   \" (length=\" + NStr::NumericToString(length) + ')');\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileReader\n//\n\nCFileReader::CFileReader(const string& filename, EShareMode share_mode)\n{\n    m_File.Open(filename, eOpen, eRead, share_mode);\n}\n\n\nCFileReader::CFileReader(const char* filename, EShareMode share_mode)\n{\n    m_File.Open(filename, eOpen, eRead, share_mode);\n}\n\n\nCFileReader::CFileReader(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n}\n\n\nIReader* CFileReader::New(const string& filename, EShareMode share_mode)\n{\n    if ( filename == \"-\" ) {\n#if defined(NCBI_OS_MSWIN)\n        TFileHandle handle = GetStdHandle(STD_INPUT_HANDLE);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef STDIN_FILENO\n        TFileHandle handle = STDIN_FILENO;\n#  else\n        TFileHandle handle = 0;\n#  endif //STDIN_FILENO\n#endif\n        return new CFileReader(handle);\n    }\n    return new CFileReader(filename, share_mode);\n}\n\n\nERW_Result CFileReader::Read(void* buf, size_t count, size_t* bytes_read)\n{\n    if ( bytes_read ) {\n        *bytes_read = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Read(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_read ) {\n        *bytes_read = n;\n    }\n    return n? eRW_Success : eRW_Eof;\n}\n\n\nERW_Result CFileReader::PendingCount(size_t* /*count*/)\n{\n    return eRW_NotImplemented;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileWriter\n//\n\nCFileWriter::CFileWriter(const string& filename,\n                         EOpenMode  open_mode,\n                         EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eWrite, share_mode);\n}\n\n\nCFileWriter::CFileWriter(const char* filename,\n                         EOpenMode  open_mode,\n                         EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eWrite, share_mode);\n}\n\n\nCFileWriter::CFileWriter(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n    return;\n}\n\n\nIWriter* CFileWriter::New(const string& filename,\n                          EOpenMode  open_mode,\n                          EShareMode share_mode)\n{\n    if ( filename == \"-\" ) {\n#if defined(NCBI_OS_MSWIN)\n        TFileHandle handle = GetStdHandle(STD_OUTPUT_HANDLE);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef STDOUT_FILENO\n        TFileHandle handle = STDOUT_FILENO;\n#  else\n        TFileHandle handle = 1;\n#  endif //STDOUT_FILENO\n#endif\n        return new CFileWriter(handle);\n    }\n    return new CFileWriter(filename, open_mode, share_mode);\n}\n\n\nERW_Result CFileWriter::Write(const void* buf,\n                              size_t count, size_t* bytes_written)\n{\n    if ( bytes_written ) {\n        *bytes_written = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Write(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_written ) {\n        *bytes_written = n;\n    }\n    return n? eRW_Success : eRW_Error;\n}\n\n\nERW_Result CFileWriter::Flush(void)\n{\n    try {\n        m_File.Flush();\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    return eRW_Success;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileReaderWriter\n//\n\nCFileReaderWriter::CFileReaderWriter(const string& filename,\n                                     EOpenMode  open_mode,\n                                     EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eReadWrite, share_mode);\n}\n\n\nCFileReaderWriter::CFileReaderWriter(const char* filename,\n                                     EOpenMode  open_mode,\n                                     EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eReadWrite, share_mode);\n}\n\n\nCFileReaderWriter::CFileReaderWriter(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n    return;\n}\n\n\nIReaderWriter* CFileReaderWriter::New(const string& filename,\n                                      EOpenMode  open_mode,\n                                      EShareMode share_mode)\n{\n    return new CFileReaderWriter(filename, open_mode, share_mode);\n}\n\n\nERW_Result CFileReaderWriter::Read(void* buf,\n                                   size_t count, size_t* bytes_read)\n{\n    if ( bytes_read ) {\n        *bytes_read = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Read(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_read ) {\n        *bytes_read = n;\n    }\n    return n? eRW_Success : eRW_Eof;\n}\n\n\nERW_Result CFileReaderWriter::PendingCount(size_t* /*count*/)\n{\n    return eRW_NotImplemented;\n}\n\n\nERW_Result CFileReaderWriter::Write(const void* buf,\n                                    size_t count, size_t* bytes_written)\n{\n    if ( bytes_written ) {\n        *bytes_written = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Write(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_written ) {\n        *bytes_written = n;\n    }\n    return n? eRW_Success : eRW_Error;\n}\n\n\nERW_Result CFileReaderWriter::Flush(void)\n{\n    try {\n        m_File.Flush();\n    }\n    catch (const CFileException&) { \n       return eRW_Error;\n    }\n    return eRW_Success;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileLock\n//\n\n// Clean up an all non-default bits in group if all bits are set\n#define F_CLEAN_REDUNDANT(group) \\\n    if (F_ISSET(m_Flags, (group))) \\\n        m_Flags &= ~unsigned((group) & ~unsigned(fDefault))\n\n// Platform-dependent structure to store file locking information\nstruct SLock {\n    SLock(void) {};\n    SLock(CFileLock::TOffsetType off, size_t len) {\n        Reset(off, len);\n    }\n#if defined(NCBI_OS_MSWIN)\n    void Reset(CFileLock::TOffsetType off, size_t len) \n    {\n        offset_lo = (DWORD)(off & 0xFFFFFFFF);\n        offset_hi = (DWORD)((Int8(off) >> 32) & 0xFFFFFFFF);\n        // Locking a region that goes beyond the current EOF position\n        // is not an error.\n        if (len) {\n            length_lo = (DWORD)(len & 0xFFFFFFFF);\n            length_hi = (DWORD)((Int8(len) >> 32) & 0xFFFFFFFF);\n        } else {\n            // Lock a whole file\n            length_lo = 0;\n            length_hi = 0xFFFFFFFF;\n        }\n    };\n    DWORD offset_lo;\n    DWORD offset_hi;\n    DWORD length_lo;\n    DWORD length_hi;\n#elif defined(NCBI_OS_UNIX)\n    void Reset(CFileLock::TOffsetType off, size_t len) {\n        offset = off;\n        length = len;\n    }\n    off_t  offset;\n    size_t length;\n#endif\n};\n\n\nCFileLock::CFileLock(const string& filename, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(kInvalidHandle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(filename.c_str(), type, offset, length);\n}\n\n\nCFileLock::CFileLock(const char* filename, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(kInvalidHandle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(filename, type, offset, length);\n}\n\n\nCFileLock::CFileLock(TFileHandle handle, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(handle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(0, type, offset, length);\n}\n\n\nvoid CFileLock::x_Init(const char* filename, EType type,\n                       TOffsetType offset, size_t length)\n{\n    // Reset redundant flags\n    F_CLEAN_REDUNDANT(fLockNow | fLockLater);\n    F_CLEAN_REDUNDANT(fAutoUnlock | fNoAutoUnlock);\n\n    // Open file\n    if (filename) {\n#if defined(NCBI_OS_MSWIN)\n        m_Handle = CreateFile(_T_XCSTRING(filename), GENERIC_READ,\n                              FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n#elif defined(NCBI_OS_UNIX)\n        m_Handle = open(filename, O_RDWR);\n#endif\n    }\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileLock,\n                   \"Cannot open file \" + string(filename));\n    }\n    if (filename) {\n        m_CloseHandle = true;\n    }\n    m_Lock = new SLock;\n\n    // Lock file if necessary\n    if (F_ISSET(m_Flags, fLockNow)) {\n         Lock(type, offset, length);\n    }\n}\n\n\nCFileLock::~CFileLock()\n{\n    if (m_Handle == kInvalidHandle) {\n        return;\n    }\n    try {\n        // Remove lock automaticaly\n        if (F_ISSET(m_Flags, fAutoUnlock)) {\n            Unlock();\n        }\n    }\n    catch (const CException& e) {\n        NCBI_REPORT_EXCEPTION_X(4,\n                                \"CFileLock::~CFileLock():\"\n                                \" Cannot unlock\", e);\n    }\n\n    if (m_CloseHandle) {\n#if defined(NCBI_OS_MSWIN)\n        CloseHandle(m_Handle);\n#elif defined(NCBI_OS_UNIX)\n        close(m_Handle);\n#endif\n    }\n    return;\n}\n\n\nvoid CFileLock::Lock(EType type, TOffsetType offset, size_t length)\n{\n    // Remove previous lock\n    if (m_IsLocked) {\n        Unlock();\n    }\n    // Set new one\n    m_Lock->Reset(offset, length);\n    \n#if defined(NCBI_OS_MSWIN)\n    DWORD flags = LOCKFILE_FAIL_IMMEDIATELY;\n    if (type == eExclusive) {\n        flags |= LOCKFILE_EXCLUSIVE_LOCK;\n    }\n    OVERLAPPED overlapped;\n    overlapped.hEvent     = 0;\n    overlapped.Offset     = m_Lock->offset_lo;\n    overlapped.OffsetHigh = m_Lock->offset_hi;\n    bool res = LockFileEx(m_Handle, flags, 0, \n                            m_Lock->length_lo, m_Lock->length_hi,\n                            &overlapped) == TRUE;\n#elif defined(NCBI_OS_UNIX)\n    struct flock fl;\n    fl.l_type   = (type == eShared) ? F_RDLCK : F_WRLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = m_Lock->offset;\n    fl.l_len    = m_Lock->length;   // 0 - lock to EOF \n    fl.l_pid    = getpid();\n    \n    int err;\n    do {\n        err = fcntl(m_Handle, F_SETLK, &fl);\n    } while (err && (errno == EINTR));\n    bool res = (err == 0);\n\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileLock, \"Cannot lock file\");\n    }\n    m_IsLocked = true;\n    return;\n}\n\n\nvoid CFileLock::Unlock(void)\n{\n    if (!m_IsLocked) {\n        return;\n    }\n#if defined(NCBI_OS_MSWIN)\n    OVERLAPPED overlapped;\n    overlapped.hEvent     = 0;\n    overlapped.Offset     = m_Lock->offset_lo;\n    overlapped.OffsetHigh = m_Lock->offset_hi;\n    bool res = UnlockFileEx(m_Handle, 0,\n                            m_Lock->length_lo, m_Lock->length_hi,\n                            &overlapped) == TRUE;\n\n#elif defined(NCBI_OS_UNIX)\n    struct flock fl;\n    fl.l_type   = F_UNLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = m_Lock->offset;\n    fl.l_len    = m_Lock->length;\n    fl.l_pid    = getpid();\n    \n    int err;\n    do {\n        err = fcntl(m_Handle, F_SETLK, &fl);\n    } while (err && (errno == EINTR));\n    bool res = (err == 0);\n\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileLock, \"Cannot unlock\");\n    }\n    m_IsLocked = false;\n    return;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Misc\n//\n\nvoid CFileAPI::SetLogging(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, FileAPILogging)::SetDefault(\n        on_off_default != eDefault ?\n        on_off_default != eOff : DEFAULT_LOGGING_VALUE);\n}\n\nvoid CFileAPI::SetHonorUmask(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::SetDefault(\n        on_off_default != eDefault ?\n        on_off_default != eOff : DEFAULT_HONOR_UMASK_VALUE);\n}\n\nvoid CFileAPI::SetDeleteReadOnlyFiles(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, DeleteReadOnlyFiles)::SetDefault(\n        on_off_default == eOn);\n}\n\n\nEND_NCBI_SCOPE\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/corelib/ncbidll.cpp": "/*  $Id: ncbidll.cpp 572204 2018-10-10 14:43:17Z ivanov $\n * ===========================================================================\n *\n *                            PUBLIC DOMAIN NOTICE\n *               National Center for Biotechnology Information\n *\n *  This software/database is a \"United States Government Work\" under the\n *  terms of the United States Copyright Act.  It was written as part of\n *  the author's official duties as a United States Government employee and\n *  thus cannot be copyrighted.  This software/database is freely available\n *  to the public for use. The National Library of Medicine and the U.S.\n *  Government have not placed any restriction on its use or reproduction.\n *\n *  Although all reasonable efforts have been taken to ensure the accuracy\n *  and reliability of the software and data, the NLM and the U.S.\n *  Government do not and cannot warrant the performance or results that\n *  may be obtained by using this software or data. The NLM and the U.S.\n *  Government disclaim all warranties, express or implied, including\n *  warranties of performance, merchantability or fitness for any particular\n *  purpose.\n *\n *  Please cite the author in any work or product based on this material.\n *\n * ===========================================================================\n *\n * Author: Vladimir Ivanov, Denis Vakatov\n *\n * File Description:\n *   Portable DLL handling\n *\n */\n\n#include <ncbi_pch.hpp>\n#include <corelib/ncbidll.hpp>\n#include <corelib/ncbifile.hpp>\n#include <corelib/ncbiapp.hpp>\n#include <corelib/error_codes.hpp>\n#include \"ncbisys.hpp\"\n\n\n#if defined(NCBI_OS_MSWIN)\n#  include <corelib/ncbi_os_mswin.hpp>\n#elif defined(NCBI_OS_UNIX)\n#  ifdef NCBI_OS_DARWIN\n#    include <mach-o/dyld.h>\n#  endif\n#  ifdef HAVE_DLFCN_H\n#    include <dlfcn.h>\n#    ifndef RTLD_LOCAL /* missing on Cygwin? */\n#      define RTLD_LOCAL 0\n#    endif\n#  endif\n#else\n#  error \"Class CDll defined only for MS Windows and UNIX platforms\"\n#endif\n\n#if defined(NCBI_OS_MSWIN)\n#  pragma warning (disable : 4191)\n#endif\n\n\n#define NCBI_USE_ERRCODE_X   Corelib_Dll\n\n\nBEGIN_NCBI_SCOPE\n\n\n// Platform-dependent DLL handle type definition\nstruct SDllHandle {\n#if defined(NCBI_OS_MSWIN)\n    HMODULE handle;\n#elif defined(NCBI_OS_UNIX)\n    void*   handle;\n#endif\n};\n\n// Check flag bits\n#define F_ISSET(mask) ((m_Flags & (mask)) == (mask))\n// Clean up an all non-default bits in group if all bits are set\n#define F_CLEAN_REDUNDANT(group) \\\n    if (F_ISSET(group)) m_Flags &= ~unsigned((group) & ~unsigned(fDefault))\n\n\nCDll::CDll(const string& name, TFlags flags)\n{\n    x_Init(kEmptyStr, name, flags);\n}\n\nCDll::CDll(const string& path, const string& name, TFlags flags)\n{\n    x_Init(path, name, flags);\n}\n\nCDll::CDll(const string& name, ELoad when_to_load, EAutoUnload auto_unload,\n           EBasename treate_as)\n{\n    x_Init(kEmptyStr, name,\n           TFlags(when_to_load) | TFlags(auto_unload) | TFlags(treate_as));\n}\n\nCDll::CDll(const string& path, const string& name, ELoad when_to_load,\n           EAutoUnload auto_unload, EBasename treate_as)\n{\n    x_Init(path, name,\n           TFlags(when_to_load) | TFlags(auto_unload) | TFlags(treate_as));\n}\n\n\nCDll::~CDll()\n{\n    // Unload DLL automatically\n    if ( F_ISSET(fAutoUnload) ) {\n        try {\n            Unload();\n        } catch(CException& e) {\n            NCBI_REPORT_EXCEPTION_X(1, \"CDll destructor\", e);\n        }\n    }\n    delete m_Handle;\n}\n\n\nvoid CDll::x_Init(const string& path, const string& name, TFlags flags)\n{\n    // Save flags\n    m_Flags = flags;\n\n    // Reset redundant flags\n    F_CLEAN_REDUNDANT(fLoadNow    | fLoadLater);\n    F_CLEAN_REDUNDANT(fAutoUnload | fNoAutoUnload);\n    F_CLEAN_REDUNDANT(fBaseName   | fExactName);\n    F_CLEAN_REDUNDANT(fGlobal     | fLocal);\n\n    // Init members\n    m_Handle = 0;\n    string x_name = name;\n#if defined(NCBI_OS_MSWIN)\n    NStr::ToLower(x_name);\n#endif\n    // Process DLL name\n    if (F_ISSET(fBaseName)  &&\n        name.find_first_of(\":/\\\\\") == NPOS  &&\n        !CDirEntry::MatchesMask(name.c_str(),\n                                NCBI_PLUGIN_PREFIX \"*\" NCBI_PLUGIN_MIN_SUFFIX \"*\")\n        ) {\n        // \"name\" is basename\n        x_name = NCBI_PLUGIN_PREFIX + x_name + NCBI_PLUGIN_SUFFIX;\n    }\n    m_Name = CDirEntry::ConcatPath(path, x_name);\n    // Load DLL now if indicated\n    if (F_ISSET(fLoadNow)) {\n        Load();\n    }\n}\n\n\nvoid CDll::Load(void)\n{\n    // DLL is already loaded\n    if ( m_Handle ) {\n        return;\n    }\n    // Load DLL\n    _TRACE(\"Loading dll: \"<<m_Name);\n#if defined(NCBI_OS_MSWIN)\n    UINT errMode = SetErrorMode(SEM_FAILCRITICALERRORS);\n    HMODULE handle = LoadLibrary(_T_XCSTRING(m_Name));\n    SetErrorMode(errMode);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    int flags = RTLD_LAZY | (F_ISSET(fLocal) ? RTLD_LOCAL : RTLD_GLOBAL);\n    void* handle = dlopen(m_Name.c_str(), flags);\n#  else\n    void* handle = 0;\n#  endif\n#endif\n    if ( !handle ) {\n        x_ThrowException(\"CDll::Load\");\n    }\n    m_Handle = new SDllHandle;\n    m_Handle->handle = handle;\n}\n\n\nvoid CDll::Unload(void)\n{\n    // DLL is not loaded\n    if ( !m_Handle ) {\n        return;\n    }\n    _TRACE(\"Unloading dll: \"<<m_Name);\n    // Unload DLL\n#if defined(NCBI_OS_MSWIN)\n    BOOL unloaded = FreeLibrary(m_Handle->handle);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    bool unloaded = dlclose(m_Handle->handle) == 0;\n#  else\n    bool unloaded = false;\n#  endif\n#endif\n    if ( !unloaded ) {\n        x_ThrowException(\"CDll::Unload\");\n    }\n\n    delete m_Handle;\n    m_Handle = 0;\n}\n\n\nCDll::TEntryPoint CDll::GetEntryPoint(const string& name)\n{\n    // If DLL is not yet loaded\n    if ( !m_Handle ) {\n        Load();\n    }\n    _TRACE(\"Getting entry point: \"<<name);\n    TEntryPoint entry;\n\n    // Return address of entry (function or data)\n#if defined(NCBI_OS_MSWIN)\n    FARPROC ptr = GetProcAddress(m_Handle->handle, name.c_str());\n#elif defined(NCBI_OS_DARWIN)\n    NSModule module = (NSModule)m_Handle->handle;\n    NSSymbol nssymbol = NSLookupSymbolInModule(module, name.c_str());\n    void* ptr = 0;\n    ptr = NSAddressOfSymbol(nssymbol);\n    if (ptr == NULL) {\n        ptr = dlsym (m_Handle->handle, name.c_str());\n    }\n#elif defined(NCBI_OS_UNIX)  &&  defined(HAVE_DLFCN_H)\n    void* ptr = 0;\n    ptr = dlsym(m_Handle->handle, name.c_str());\n#else\n    void* ptr = 0;\n#endif\n    entry.func = (FEntryPoint)ptr;\n    entry.data = ptr;\n    return entry;\n}\n\n\nvoid CDll::x_ThrowException(const string& what)\n{\n#if defined(NCBI_OS_MSWIN)\n    TXChar* ptr = NULL;\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                  FORMAT_MESSAGE_FROM_SYSTEM |\n                  FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL, GetLastError(),\n                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  (TXChar*) &ptr, 0, NULL);\n    string errmsg = ptr ? _T_CSTRING(ptr) : \"unknown reason\";\n    LocalFree(ptr);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    const char* errmsg = dlerror();\n    if ( !errmsg ) {\n        errmsg = \"unknown reason\";\n    }\n#  else\n    const char* errmsg = \"No DLL support on this platform.\";\n#  endif\n#endif\n\n    NCBI_THROW(CCoreException, eDll, what + \" [\" + m_Name +\"]: \" + errmsg);\n}\n\n\nCDllResolver::CDllResolver(const string& entry_point_name,\n                           CDll::EAutoUnload unload)\n    : m_AutoUnloadDll(unload)\n{\n    m_EntryPoinNames.push_back(entry_point_name);\n}\n\nCDllResolver::CDllResolver(const vector<string>& entry_point_names,\n                           CDll::EAutoUnload unload)\n    : m_AutoUnloadDll(unload)\n{\n    m_EntryPoinNames = entry_point_names;\n}\n\nCDllResolver::~CDllResolver()\n{\n    Unload();\n}\n\nbool CDllResolver::TryCandidate(const string& file_name,\n                                const string& driver_name)\n{\n    try {\n        CDll* dll = new CDll(file_name, CDll::fLoadNow | CDll::fNoAutoUnload);\n        CDll::TEntryPoint p;\n\n        SResolvedEntry entry_point(dll);\n\n        ITERATE(vector<string>, it, m_EntryPoinNames) {\n            string entry_point_name;\n\n            const string& dll_name = dll->GetName();\n\n            if ( !dll_name.empty() ) {\n                string base_name;\n                CDirEntry::SplitPath(dll_name, 0, &base_name, 0);\n                NStr::Replace(*it, \"${basename}\", base_name, entry_point_name);\n                if (!driver_name.empty()) {\n                    NStr::Replace(*it, \"${driver}\", driver_name, entry_point_name);\n                }\n            }\n\n            // Check for the BASE library name macro\n\n            if ( entry_point_name.empty() )\n                continue;\n            p = dll->GetEntryPoint(entry_point_name);\n            if ( p.data ) {\n                entry_point.entry_points.push_back(SNamedEntryPoint(entry_point_name, p));\n            }\n        } // ITERATE\n\n        if ( entry_point.entry_points.empty() ) {\n            dll->Unload();\n            delete dll;\n            return false;\n        }\n        m_ResolvedEntries.push_back(entry_point);\n    }\n    catch (CCoreException& ex)\n    {\n        if (ex.GetErrCode() != CCoreException::eDll) {\n            throw;\n        }\n        NCBI_REPORT_EXCEPTION_X(2, \"CDllResolver::TryCandidate() failed\", ex);\n        return false;\n    }\n\n    return true;\n}\n\nstatic inline\nstring s_GetProgramPath(void)\n{\n    string dir;\n    CDirEntry::SplitPath\n        (CNcbiApplication::GetAppName(CNcbiApplication::eFullName), &dir);\n    return dir;\n}\n\nvoid CDllResolver::x_AddExtraDllPath(vector<string>& paths, TExtraDllPath which)\n{\n    if (which == fNoExtraDllPath) {\n        // Nothing to do\n        return;\n    }\n\n    // Add program executable path\n\n    if ((which & fProgramPath) != 0) {\n        string dir = s_GetProgramPath();\n        if ( !dir.empty() ) {\n            paths.push_back(dir);\n        }\n    }\n\n    // Add systems directories\n\n    if ((which & fSystemDllPath) != 0) {\n#if defined(NCBI_OS_MSWIN)\n        // Get Windows system directories\n        TXChar buf[MAX_PATH+1];\n        UINT len = GetSystemDirectory(buf, MAX_PATH+1);\n        if (len>0  &&  len<=MAX_PATH) {\n            paths.push_back(_T_STDSTRING(buf));\n        }\n        len = GetWindowsDirectory(buf, MAX_PATH+1);\n        if (len>0  &&  len<=MAX_PATH) {\n            paths.push_back(_T_STDSTRING(buf));\n        }\n        // Parse PATH environment variable\n        const TXChar* env = NcbiSys_getenv(_TX(\"PATH\"));\n        if (env  &&  *env) {\n            NStr::Split(_T_STDSTRING(env), \";\", paths);\n        }\n\n#elif defined(NCBI_OS_UNIX)\n        // From LD_LIBRARY_PATH environment variable\n        const char* env = getenv(\"LD_LIBRARY_PATH\");\n        if (env  &&  *env) {\n            NStr::Split(env, \":\", paths);\n        }\n#endif\n    }\n\n    // Add hard coded runpath\n\n    if ((which & fToolkitDllPath) != 0) {\n        const char* runpath = NCBI_GetRunpath();\n        if (runpath  &&  *runpath) {\n#  if defined(NCBI_OS_MSWIN)\n            NStr::Split(runpath, \";\", paths);\n#  elif defined(NCBI_OS_UNIX)\n            vector<string> tokenized;\n            NStr::Split(runpath, \":\", tokenized);\n            ITERATE(vector<string>, i, tokenized) {\n                if (i->find(\"$ORIGIN\") == NPOS) {\n                    paths.push_back(*i);\n                } else {\n                    string dir = s_GetProgramPath();\n                    if ( !dir.empty() ) {\n                        // Need to know the $ORIGIN else discard path.\n                        paths.push_back(NStr::Replace(*i, \"$ORIGIN\", dir));\n                    }\n                }\n            }\n#  else\n            paths.push_back(runpath);\n#  endif\n        }\n    }\n\n    return;\n}\n\nvoid CDllResolver::Unload()\n{\n    NON_CONST_ITERATE(TEntries, it, m_ResolvedEntries) {\n        if ( m_AutoUnloadDll == CDll::eAutoUnload ) {\n            it->dll->Unload();\n        }\n        delete it->dll;\n    }\n    m_ResolvedEntries.resize(0);\n}\n\n\nEND_NCBI_SCOPE\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/configure.ac": "#############################################################################\n#  $Id: configure.ac 589187 2019-07-08 17:25:11Z ivanov $\n#  Derived from configure.in version 1.173.\n# ==========================================================================\n#\n#                            PUBLIC DOMAIN NOTICE\n#               National Center for Biotechnology Information\n#\n#  This software/database is a \"United States Government Work\" under the\n#  terms of the United States Copyright Act.  It was written as part of\n#  the author's official duties as a United States Government employee and\n#  thus cannot be copyrighted.  This software/database is freely available\n#  to the public for use. The National Library of Medicine and the U.S.\n#  Government have not placed any restriction on its use or reproduction.\n#\n#  Although all reasonable efforts have been taken to ensure the accuracy\n#  and reliability of the software and data, the NLM and the U.S.\n#  Government do not and cannot warrant the performance or results that\n#  may be obtained by using this software or data. The NLM and the U.S.\n#  Government disclaim all warranties, express or implied, including\n#  warranties of performance, merchantability or fitness for any particular\n#  purpose.\n#\n#  Please cite the author in any work or product based on this material.\n#\n# ==========================================================================\n#\n# Authors:  Denis Vakatov, Aaron Ucko\n#\n# File Description:\n#   Setup NCBI C++ Toolkit build tree - tuned for your platform, compiler, etc.\n#   USAGE:\n#    1) Process this file with \"autoconf\" to produce a \"configure\" script.\n#    2) Run the resultant \"configure\" script to produce:\n#      a) \"<builddir>/inc/ncbiconf_unix.h\"\n#      b) \"<builddir>/build/Makefile.mk\"\n#      c) other Makefile's and scripts in \"<builddir>/build\" and below\n#\n#############################################################################\n\nAC_PREREQ(2.60)\n\ndnl Early setup, most crucially for locking.  The diversion magic lets\ndnl this occur before AC_INIT, which already interferes with other\ndnl configure processes.\n\nAC_DIVERT_PUSH(INIT_PREPARE)\n\n# Check --with-3psw=.../--without-3psw early because a lot hinges on it\norig_NCBI=$NCBI\ncase \"$with_3psw\" in\n   '' | yes | [[\\$/][Nn]*:[SsLl]*] | [[Nn]*:[SsLl]*] )\n      ncbi_favor_std_packages=no\n      ;;\n   [[SsLl]]*:* )\n      ncbi_favor_std_packages=yes\n      ;;\n   [[SsLl]]* )\n      AS_UNSET(NCBI)\n      ;;\n   no )\n      if test \"${with_ncbi_c-no}\" != \"no\"; then\n         AC_MSG_ERROR([incompatible options: --with-ncbi-c but --without-3psw])\n      else\n         with_ncbi_c=no\n      fi\n      m4_foreach(X, [sss, sssutils, sssdb, vdb, libunwind,\n                     z, bz2, lzo, pcre, mbedtls,\n                     gmp, gcrypt, nettle, gnutls, openssl, krb5, boost, lmdb,\n                     sybase, ftds, mysql, opengl, mesa, glut, glew, gl2ps,\n                     wxwidgets, freetype, ftgl, fastcgi, bdb, orbacus, odbc,\n                     python, perl, jni, sqlite3, mimetic, sge, icu, sp, expat,\n                     sablot, libxml, libxslt, libexslt, xerces, xalan, zorba,\n                     oechem, muparser, hdf5, gif, jpeg, png, tiff, xpm, magic,\n                     curl, gsoap, avro, cereal, sasl2,\n                     mongodb, mongodb3, gmock, lapack,\n                     libuv, libssh2, cassandra, nghttp2, h2o,\n                     libxlsxwriter, protobuf, grpc, msgsl, aws-sdk],\n        [if test \"${[with_]X-no}\" != \"no\"; then\n            AC_MSG_ERROR([incompatible options: --with-]X[ but --without-3psw])\n         else\n            [with_]X=no\n         fi\n        ])\n      AS_UNSET(NCBI)\n      ;;\n   * )\n      AC_MSG_ERROR([Unsupported option --with-3psw=$with_3psw])\n      ;;\nesac\n\nif $srcdir/scripts/common/impl/get_lock.sh configure $$; then\n    ac_clean_files=configure.lock\nelse\n    exit 1\nfi\n# reconfigure.sh expects config.cache to exist; unconditionally clobber\n# any command-line setting.\ncache_file=config.cache\nif test -z \"$CONFIG_SITE\" -a -r $srcdir/src/build-system/config.site; then\n    CONFIG_SITE=$srcdir/src/build-system/config.site\nfi\nAC_DIVERT_POP\n\nAC_INIT([ncbi-tools++],[0.0],[cpp-core@ncbi.nlm.nih.gov])\nAC_CONFIG_SRCDIR(src/build-system/Makefile.mk.in)\n\n\n\n#############################################################################\n\n\n#### Describe all \"--with-*\" arguments -- for the usage printout on \"--help\"\n\n## Title\nAC_ARG_WITH(_,\n   [===============================================================================])\nAC_ARG_WITH(_,\n   [=============== NCBI C++ Toolkit specific configuration flags =================])\nAC_ARG_WITH(_,\n   [===============================================================================])\n\n## Code generation\nAC_ARG_WITH(debug,\n   [ --without-debug         build non-debug versions of libs and apps])\nAC_ARG_WITH(max-debug,\n   [ --with-max-debug        enable extra runtime checks (esp. of STL usage)])\nAC_ARG_WITH(symbols,\n   [ --with-symbols          retain debugging symbols in non-debug mode])\nAC_ARG_WITH(optimization,\n   [ --without-optimization  turn off optimization flags in non-debug mode])\nAC_ARG_WITH(sse42,\n   [ --without-sse42         don't enable SSE 4.2 when optimizing])\nAC_ARG_WITH(profiling,\n   [ --with-profiling        build profiled versions of libs and apps])\nAC_ARG_WITH(code-coverage,\n   [ --with-code-coverage    track which code blocks have been exercised])\nAC_ARG_WITH(tcheck,\n   [ --with-tcheck(=DIR)     build for Intel Thread Checker (in DIR)])\nAC_ARG_WITH(dll,\n   [ --with-dll              build all libraries as DLLs])\nAC_ARG_WITH(static,\n   [ --with-static           build all libraries statically even if --with-dll])\nAC_ARG_WITH(static-exe,\n   [ --with-static-exe       build all executables as statically as possible])\nAC_ARG_WITH(plugin-auto-load,\n   [ --with-plugin-auto-load always enable the plugin manager by default])\nAC_ARG_WITH(bundles,\n   [ --with-bundles          build bundles in addition to dylibs on Mac OS X])\nAC_ARG_WITH(bin-release,\n   [ --with-bin-release      build executables suitable for public release])\nAC_ARG_WITH(mt,\n   [ --without-mt            support only single-threaded operation])\nAC_ARG_WITH(openmp,\n   [ --with-openmp           enable OpenMP extensions for all projects])\nAC_ARG_WITH(64,\n   [ --with-64               compile to 64-bit code])\nAC_ARG_WITH(exe,\n   [ --without-exe           do not build executables])\nAC_ARG_WITH(runpath,\n   [ --with-runpath=PATH     specify the usual runtime path to DLLs])\nAC_ARG_WITH(relative-runpath,\n   [ --with-relative-runpath=P specify an executable-relative DLL search path])\nAC_ARG_WITH(hard-runpath,\n   [ --with-hard-runpath     hard-code runtime path, ignoring LD_LIBRARY_PATH])\nAC_ARG_WITH(lfs,\n   [ --with-lfs              enable large file support to the extent possible])\nAC_ARG_WITH(limited-linker,\n   [ --with-limited-linker   don't attempt to build especially large projects])\nAC_ARG_WITH(experimental,\n   [ --with-experimental=... enable named experimental feature(s)])\nAC_ARG_WITH(skew-guard,\n   [ --with-skew-guard       catch incomplete rebuilds])\n\n## Scripts, make features, and directory naming\nAC_ARG_WITH(extra-action,\n   [ --with-extra-action=    script to call after the configuration is complete])\nAC_ARG_WITH(autodep,\n   [ --with-autodep          automatic generation of dependencies (GNU make)])\nAC_ARG_WITH(build-root,\n   [ --with-build-root=DIR   specify a non-default build directory name])\nAC_ARG_WITH(fake-root,\n   [ --with-fake-root=DIR    appear to have been built under DIR])\nAC_ARG_WITH(suffix,\n   [ --without-suffix        no Release/Debug, MT or DLL sfx in the build dir name])\nAC_ARG_WITH(hostspec,\n   [ --with-hostspec         add full host specs to the build dir name])\nAC_ARG_WITH(version,\n   [ --without-version       don't always include the cplr ver in the bd name])\nAC_ARG_WITH(build-root-sfx,\n   [ --with-build-root-sfx=X add a user-specified suffix to the build dir name])\nAC_ARG_WITH(execopy,\n   [ --without-execopy       do not copy built executables to the BIN area])\nAC_ARG_WITH(bincopy,\n   [ --with-bincopy          populate lib and bin with copies, not hard links])\nAC_ARG_WITH(lib-rebuilds,\n   [ --with-lib-rebuilds     ensure that apps use up-to-date libraries])\nAC_ARG_WITH(lib-rebuilds,\n   [ --with-lib-rebuilds=ask ask whether to update each app's libraries])dnl'\nAC_ARG_WITH(deactivation,\n   [ --without-deactivation  keep old copies of libraries that no longer build])\nAC_ARG_WITH(makefile-auto-update,\n   [ --without-makefile-auto-update  do not auto-update generated makefiles])\nAC_ARG_WITH(projects,\n   [ --with-projects=FILE    build projects listed in FILE by default])\nAC_ARG_WITH(flat-makefile,\n   [ --without-flat-makefile do not generate an all-encompassing flat makefile])\nAC_ARG_WITH(configure-dialog,\n   [ --with-configure-dialog allow interactive flat makefile project selection])\nAC_ARG_WITH(saved-settings,\n   [ --with-saved-settings=F load configuration settings from the file F])\nAC_ARG_WITH(check,\n   [ --with-check            run test suite after the build])\nAC_ARG_WITH(check-tools,\n   [ --with-check-tools=...  use the specified tools for testing])\nAC_ARG_WITH(ncbi-public,\n   [ --with-ncbi-public      ensure compatibility for all in-house platforms])\nAC_ARG_WITH(strip,\n   [ --with-strip            strip binaries at build time])\nAC_ARG_WITH(pch,\n   [ --with-pch              use precompiled headers if possible])\nAC_ARG_WITH(caution,\n   [ --with-caution          cancel configuration unconditionally when in doubt])\nAC_ARG_WITH(caution,\n   [ --without-caution       proceed without asking when in doubt])\nAC_ARG_WITH(ccache,\n   [ --without-ccache        do not automatically use ccache if available])\nAC_ARG_WITH(distcc,\n   [ --without-distcc        do not automatically use distcc if available])\n\n## NCBI packages\nAC_ARG_WITH(ncbi-c,\n   [ --with-ncbi-c=DIR       use NCBI C Toolkit installation in DIR])\nAC_ARG_WITH(ncbi-c,\n   [ --without-ncbi-c        do not use NCBI C Toolkit])\nAC_ARG_WITH(sss,\n   [ --with-sss=DIR          use NCBI SSS installation in DIR])\nAC_ARG_WITH(sss,\n   [ --without-sss           do not use NCBI SSS libraries])\nAC_ARG_WITH(sssutils,\n   [ --without-utils         do not use NCBI SSS UTIL library])\nAC_ARG_WITH(sssdb,\n   [ --without-sssdb         do not use NCBI SSS DB library])\nAC_ARG_WITH(included-sss,\n   [ --with-included-sss     use the in-tree copy of SSS])\nAC_ARG_WITH(vdb,\n   [ --with-vdb=DIR          use NCBI SRA/VDB Toolkit installation in DIR])\nAC_ARG_WITH(vdb,\n   [ --without-vdb           do not use the NCBI SRA/VDB Toolkit])\nAC_ARG_WITH(downloaded-vdb,\n   [ --with-downloaded-vdb   download and build SRA/VDB from GitHub])\nAC_ARG_WITH(static-vdb,\n   [ --with-static-vdb       always link statically against SRA/VDB])\n\n## Third-party and system packages\nAC_ARG_WITH(libunwind,\n   [ --with-libunwind(=DIR)  use libunwind (in DIR)])\nAC_ARG_WITH(libdw,\n   [ --with-libdw=DIR        use elfutils libdw installation in DIR])\nAC_ARG_WITH(libdw,\n   [ --without-libdw         do not use elfutils libdw])\nAC_ARG_WITH(backward-cpp,\n   [ --with-backward-cpp=DIR use backward-cpp installation in DIR])\nAC_ARG_WITH(backward-cpp,\n   [ --without-backward-cpp  do not use backward-cpp])\nAC_ARG_WITH(backward-cpp-sig,\n   [ --with-backward-cpp-sig  allow backward-cpp to also handle signals])\nAC_ARG_WITH(z,\n   [ --with-z=DIR            use zlib installation in DIR])\nAC_ARG_WITH(z,\n   [ --without-z             use internal copy of zlib])\nAC_ARG_WITH(bz2,\n   [ --with-bz2=DIR          use bzlib installation in DIR])\nAC_ARG_WITH(bz2,\n   [ --without-bz2           use internal copy of bzlib])\nAC_ARG_WITH(lzo,\n   [ --with-lzo=DIR          use LZO installation in DIR (requires 2.x or up)])\nAC_ARG_WITH(lzo,\n   [ --without-lzo           do not use LZO])\nAC_ARG_WITH(pcre,\n   [ --with-pcre=DIR         use PCRE installation in DIR])\nAC_ARG_WITH(pcre,\n   [ --without-pcre          use internal copy of PCRE])\nAC_ARG_WITH(mbedtls,\n   [ --with-mbedtls(=DIR)    use external mbedTLS installation (in DIR)])\nAC_ARG_WITH(gmp,\n   [ --with-gmp=DIR          use GMP installation in DIR])\nAC_ARG_WITH(gmp,\n   [ --without-gmp           do not use GMP])\nAC_ARG_WITH(gcrypt,\n   [ --with-gcrypt=DIR       use gcrypt installation in DIR])\nAC_ARG_WITH(gcrypt,\n   [ --without-gcrypt        do not use gcrypt])\nAC_ARG_WITH(nettle,\n   [ --with-nettle=DIR       use Nettle installation in DIR])\nAC_ARG_WITH(nettle,\n   [ --without-nettle        do not use Nettle])\nAC_ARG_WITH(gnutls,\n   [ --with-gnutls=DIR       use GNUTLS installation in DIR])\nAC_ARG_WITH(static-gnutls,\n   [ --with-static-gnutls    link GNUTLS statically if possible])\nAC_ARG_WITH(openssl,\n   [ --with-openssl=DIR      use OpenSSL installation in DIR])\nAC_ARG_WITH(openssl,\n   [ --without-openssl       do not use OpenSSL])\nAC_ARG_WITH(krb5,\n   [ --with-krb5=DIR         use Kerberos 5 installation in DIR])\nAC_ARG_WITH(krb5,\n   [ --without-krb5          do not use Kerberos 5])\nAC_ARG_WITH(sybase,\n   [ --without-sybase        do not use SYBASE libraries])\nAC_ARG_WITH(sybase-local,\n   [ --with-sybase-local=DIR use local SYBASE install (DIR is optional)])\nAC_ARG_WITH(sybase-new,\n   [ --with-sybase-new       use newer SYBASE install (12.5 rather than 12.0)])\nAC_ARG_WITH(ftds,\n   [ --without-ftds          do not use FreeTDS libraries])\nAC_ARG_WITH(ftds,\n   [ --with-ftds=DIR         use FreeTDS installation in DIR])\nAC_ARG_WITH(ftds-renamed,\n   [ --without-ftds-renamed  do not rename Sybase DBLIB symbols in built-in FTDS])\nAC_ARG_WITH(mysql,\n   [ --without-mysql         do not use MySQL])\nAC_ARG_WITH(mysql,\n   [ --with-mysql=DIR        use MySQL installation in DIR])\nAC_ARG_WITH(opengl,\n   [ --without-opengl        do not use OpenGL])\nAC_ARG_WITH(opengl,\n   [ --with-opengl=DIR       use OpenGL installation in DIR])\nAC_ARG_WITH(mesa,\n   [ --without-mesa          do not use MESA off-screen OpenGL])\nAC_ARG_WITH(mesa,\n   [ --with-mesa=DIR         use MESA installation in DIR])\nAC_ARG_WITH(glut,\n   [ --without-glut          do not use GLUT])\nAC_ARG_WITH(glut,\n   [ --with-glut=DIR         use GLUT installation in DIR])\nAC_ARG_WITH(glew,\n   [ --without-glew          do not use GLEW])\nAC_ARG_WITH(glew,\n   [ --with-glew=DIR         use GLEW installation in DIR])\nAC_ARG_WITH(glew-mx,\n   [ --with-glew-mx          insist on a multi-context-ready GLEW installation])\nAC_ARG_WITH(gl2ps,\n   [ --without-gl2ps         do not use GL2PS])\nAC_ARG_WITH(gl2ps,\n   [ --with-gl2ps=DIR        use GL2PS installation in DIR])\nAC_ARG_WITH(wxwidgets,\n   [ --without-wxwidgets     do not use wxWidgets (2.6+)])\nAC_ARG_WITH(wxwidgets,\n   [ --with-wxwidgets=DIR    use wxWidgets installation in DIR])\nAC_ARG_WITH(wxwidgets-ucs,\n   [ --with-wxwidgets-ucs    use Unicode builds of wxWidgets])\nAC_ARG_WITH(wxwidgets-ucs,\n   [ --without-wxwidgets-ucs do not use Unicode builds of wxWidgets])\nAC_ARG_WITH(freetype,\n   [ --without-freetype      do not use FreeType])\nAC_ARG_WITH(freetype,\n   [ --with-freetype=DIR     use FreeType installation in DIR])\nAC_ARG_WITH(ftgl,\n   [ --without-ftgl          do not use FTGL])\nAC_ARG_WITH(ftgl,\n   [ --with-ftgl=DIR         use FTGL installation in DIR])\nAC_ARG_WITH(fastcgi,\n   [ --without-fastcgi       do not use Fast-CGI library])\nAC_ARG_WITH(fastcgi,\n   [ --with-fastcgi=VERSION  use Fast-CGI installation in \\$NCBI/fcgi-VERSION])\nAC_ARG_WITH(fastcgi,\n   [ --with-fastcgi=DIR      use Fast-CGI installation in DIR])\nAC_ARG_WITH(bdb,\n   [ --without-bdb           do not use Berkeley DB library])\nAC_ARG_WITH(bdb,\n   [ --with-bdb=VERSION      use DB installation in \\$NCBI/BerkeleyDB-VERSION])\nAC_ARG_WITH(bdb,\n   [ --with-bdb=DIR          use Berkeley DB installation in DIR])\nAC_ARG_WITH(sp,\n   [ --without-sp            do not use SP libraries])\nAC_ARG_WITH(orbacus,\n   [ --without-orbacus       do not use ORBacus CORBA libraries])\nAC_ARG_WITH(orbacus,\n   [ --with-orbacus=DIR      use ORBacus installation in DIR])\nAC_ARG_WITH(odbc,\n   [ --with-odbc=DIR         use ODBC installation in DIR])\nAC_ARG_WITH(python,\n   [ --with-python=DIR       use Python installation in DIR])\nAC_ARG_WITH(python,\n   [ --without-python        do not use Python])\nAC_ARG_WITH(perl,\n   [ --with-perl=DIR         use Perl installation in DIR])\nAC_ARG_WITH(perl,\n   [ --without-perl          do not use Perl])\nAC_ARG_WITH(jni,\n   [ --with-jni(=JDK-DIR)    build Java bindings (against the JDK in JDK-DIR)])\nAC_ARG_WITH(boost,\n   [ --with-boost=DIR        use Boost installation in DIR])\nAC_ARG_WITH(boost,\n   [ --without-boost         do not use Boost])\nAC_ARG_WITH(boost-tag,\n   [ --with-boost-tag=TAG    use TAG as the tag appended to Boost library names])\nAC_ARG_WITH(boost-tag,\n   [ --without-boost-tag     use untagged Boost library names])\nAC_ARG_WITH(sqlite3,\n   [ --with-sqlite3=DIR      use SQLite 3.x installation in DIR])\nAC_ARG_WITH(sqlite3,\n   [ --without-sqlite3       do not use SQLite 3.x])\nAC_ARG_WITH(icu,\n   [ --with-icu=DIR          use ICU installation in DIR])\nAC_ARG_WITH(icu,\n   [ --without-icu           do not use ICU])\nAC_ARG_WITH(expat,\n   [ --with-expat=DIR        use Expat installation in DIR])\nAC_ARG_WITH(expat,\n   [ --without-expat         do not use Expat])\nAC_ARG_WITH(sablot,\n   [ --with-sablot=DIR       use Sablotron installation in DIR])\nAC_ARG_WITH(sablot,\n   [ --without-sablot        do not use Sablotron])\nAC_ARG_WITH(libxml,\n   [ --with-libxml=DIR       use libxml2 installation in DIR])\nAC_ARG_WITH(libxml,\n   [ --without-libxml        do not use libxml2])\nAC_ARG_WITH(libxslt,\n   [ --with-libxslt=DIR      use libxslt installation in DIR])\nAC_ARG_WITH(libxslt,\n   [ --without-libxslt       do not use libxslt])\nAC_ARG_WITH(libexslt,\n   [ --with-libexslt=DIR     use libexslt installation in DIR])\nAC_ARG_WITH(libexslt,\n   [ --without-libexslt      do not use libexslt])\nAC_ARG_WITH(xerces,\n   [ --with-xerces=DIR       use Xerces-C++ installation in DIR])\nAC_ARG_WITH(xerces,\n   [ --without-xerces        do not use Xerces-C++])\nAC_ARG_WITH(xalan,\n   [ --with-xalan=DIR        use Xalan-C++ installation in DIR])\nAC_ARG_WITH(xalan,\n   [ --without-xalan         do not use Xalan-C++])\nAC_ARG_WITH(zorba,\n   [ --with-zorba=DIR        use Zorba installation in DIR])\nAC_ARG_WITH(zorba,\n   [ --without-zorba         do not use Zorba])\nAC_ARG_WITH(oechem,\n   [ --with-oechem=DIR       use OpenEye OEChem installation in DIR])\nAC_ARG_WITH(oechem,\n   [ --without-oechem        do not use OEChem])\nAC_ARG_WITH(sge,\n   [ --with-sge=DIR          use Sun/Univa Grid Engine installation in DIR])\nAC_ARG_WITH(sge,\n   [ --without-sge           do not use Sun/Univa Grid Engine])\nAC_ARG_WITH(muparser,\n   [ --with-muparser=DIR     use muParser installation in DIR])\nAC_ARG_WITH(muparser,\n   [ --without-muparser      do not use muParser])\nAC_ARG_WITH(hdf5,\n   [ --with-hdf5=DIR         use HDF5 installation in DIR])\nAC_ARG_WITH(hdf5,\n   [ --without-hdf5          do not use HDF5])\nAC_ARG_WITH(gif,\n   [ --with-gif=DIR          use lib(un)gif installation in DIR])\nAC_ARG_WITH(gif,\n   [ --without-gif           do not use lib(un)gif])\nAC_ARG_WITH(jpeg,\n   [ --with-jpeg=DIR         use libjpeg installation in DIR])\nAC_ARG_WITH(jpeg,\n   [ --without-jpeg          do not use libjpeg])\nAC_ARG_WITH(png,\n   [ --with-png=DIR          use libpng installation in DIR])\nAC_ARG_WITH(png,\n   [ --without-png           do not use libpng])\nAC_ARG_WITH(tiff,\n   [ --with-tiff=DIR         use libtiff installation in DIR])\nAC_ARG_WITH(tiff,\n   [ --without-tiff          do not use libtiff])\nAC_ARG_WITH(xpm,\n   [ --with-xpm=DIR          use libXpm installation in DIR])\nAC_ARG_WITH(xpm,\n   [ --without-xpm           do not use libXpm])\nAC_ARG_WITH(magic,\n   [ --with-magic=DIR        use libmagic installation in DIR])\nAC_ARG_WITH(magic,\n   [ --without-magic         do not use libmagic])\nAC_ARG_WITH(curl,\n   [ --with-curl=DIR         use libcurl installation in DIR])\nAC_ARG_WITH(curl,\n   [ --without-curl          do not use libcurl])\nAC_ARG_WITH(mimetic,\n   [ --with-mimetic=DIR      use libmimetic installation in DIR])\nAC_ARG_WITH(mimetic,\n   [ --without-mimetic       do not use libmimetic])\nAC_ARG_WITH(gsoap,\n   [ --with-gsoap=DIR        use gSOAP++ installation in DIR])\nAC_ARG_WITH(gsoap,\n   [ --without-gsoap         do not use gSOAP++])\nAC_ARG_WITH(avro,\n   [ --with-avro=DIR         use Apache Avro installation in DIR])\nAC_ARG_WITH(avro,\n   [ --without-avro          do not use Apache Avro])\nAC_ARG_WITH(cereal,\n   [ --with-cereal=DIR       use USC Cereal installation in DIR])\nAC_ARG_WITH(cereal,\n   [ --without-cereal        do not use USC Cereal])\nAC_ARG_WITH(sasl2,\n   [ --with-sasl2=DIR        use SASL 2 installation in DIR])\nAC_ARG_WITH(sasl2,\n   [ --without-sasl2         do not use SASL 2])\nAC_ARG_WITH(mongodb,\n   [ --with-mongodb=DIR      use legacy MongoDB installation in DIR])\nAC_ARG_WITH(mongodb,\n   [ --without-mongodb       do not use legacy MongoDB])\nAC_ARG_WITH(mongodb3,\n   [ --with-mongodb3=DIR     use MongoDB 3 installation in DIR])\nAC_ARG_WITH(mongodb3,\n   [ --without-mongodb3      do not use MongoDB 3])\nAC_ARG_WITH(gmock,\n   [ --with-gmock=DIR        use Google Mock installation in DIR])\nAC_ARG_WITH(gmock,\n   [ --without-gmock         do not use Google Mock])\nAC_ARG_WITH(lapack,\n   [ --with-lapack=DIR       use LAPACK installation in DIR])\nAC_ARG_WITH(lapack,\n   [ --without-lapack        do not use LAPACK])\nAC_ARG_WITH(lmdb,\n   [ --with-lmdb=DIR         use LMDB installation in DIR])\nAC_ARG_WITH(lmdb,\n   [ --without-lmdb          use internal copy of LMDB])\nAC_ARG_WITH(libuv,\n   [ --with-libuv=DIR        use libuv installation in DIR])\nAC_ARG_WITH(libuv,\n   [ --without-libuv         do not use libuv])\nAC_ARG_WITH(libssh2,\n   [ --with-libssh2=DIR      use libssh2 installation in DIR])\nAC_ARG_WITH(libssh2,\n   [ --without-libssh2       do not use libssh2])\nAC_ARG_WITH(cassandra,\n   [ --with-cassandra=DIR    use Datastax Cassandra driver installation in DIR])\nAC_ARG_WITH(cassandra,\n   [ --without-cassandra     do not use Datastax Cassandra driver])\nAC_ARG_WITH(nghttp2,\n   [ --with-nghttp2=DIR      use nghttp2 installation in DIR])\nAC_ARG_WITH(nghttp2,\n   [ --without-nghttp2       do not use nghttp2])\nAC_ARG_WITH(h2o,\n   [ --with-h2o=DIR          use h2o installation in DIR])\nAC_ARG_WITH(h2o,\n   [ --without-h2o           do not use h2o])\nAC_ARG_WITH(libxlsxwriter,\n   [ --with-libxlsxwriter=DIR use libxlsxwriter installation in DIR])\nAC_ARG_WITH(libxlsxwriter,\n   [ --without-libxlsxwriter do not use libxlsxwriter])\nAC_ARG_WITH(protobuf,\n   [ --with-protobuf=DIR     use protocol buffers installation in DIR])\nAC_ARG_WITH(protobuf,\n   [ --without-protobuf      do not use protocol buffers])\nAC_ARG_WITH(grpc,\n   [ --with-grpc=DIR         use GRPC (and protobuf) installation in DIR])\nAC_ARG_WITH(grpc,\n   [ --without-grpc          do not use GRPC])\nAC_ARG_WITH(msgsl,\n   [ --with-msgsl=DIR        use Guideline Support Library installation in DIR])\nAC_ARG_WITH(msgsl,\n   [ --without-msgsl         do not use the Guideline Support Library])\nAC_ARG_WITH(aws-sdk,\n   [ --with-aws-sdk=DIR      use Amazon Web Services SDK installation in DIR])\nAC_ARG_WITH(aws-sdk,\n   [ --without-aws-sdk       do not use the Amazon Web Services SDK])\nAC_ARG_WITH(3psw,\n   [ --with-3psw=std:netopt  favor standard (system) builds of the above pkgs.])\nAC_ARG_WITH(3psw,\n   [ --without-3psw          do not use any of the above packages])\n\n## Optional projects\nAC_ARG_WITH(local-lbsm,\n   [ --without-local-lbsm    turn off support for IPC with locally running LBSMD])\nAC_ARG_WITH(ncbi-crypt,\n   [ --without-ncbi-crypt    use a dummy stubbed-out version of ncbi_crypt])\nAC_ARG_WITH(connext,\n   [ --without-connext       do not build non-public CONNECT library extensions])\ndnl AC_ARG_WITH(serial,\ndnl    [ --without-serial        do not build the serialization library and tools])\ndnl AC_ARG_WITH(objects,\ndnl    [ --without-objects       do not generate/build serializeable objects from ASNs])\ndnl AC_ARG_WITH(dbapi,\ndnl    [ --without-dbapi         do not build database connectivity libraries])\nAC_ARG_WITH(app,\n   [ --without-app           do not build standalone applications like ID1_FETCH])\nAC_ARG_WITH(ctools,\n   [ --without-ctools        do not build NCBI C Toolkit based projects])\nAC_ARG_WITH(gui,\n   [ --without-gui           do not build most graphical projects])\ndnl AC_ARG_WITH(algo,\ndnl    [ --without-algo          do not build CPU-intensive algorithms])\nAC_ARG_WITH(internal,\n   [ --with-internal         always try to build internal projects])\nAC_ARG_WITH(internal,\n   [ --without-internal      never build internal projects])\nAC_ARG_WITH(gbench,\n   [ --with-gbench           ensure that Genome Workbench can be built])\nAC_ARG_WITH(gbench,\n   [ --without-gbench        do not build Genome Workbench])\n\n## Manuals\nAC_ARG_WITH(manuals,\n   [***** See also HTML documentation in ./doc/index.html *****])\n\n\nAC_DIVERT_PUSH(PARSE_ARGS)\ndnl As of Autoconf 2.60, this needs to run too early for config.log,\ndnl to which AC_MSG_ERROR normally copies its output, to be available.\nm4_rename([AS_MESSAGE_LOG_FD], [NCBI_ORIG_ASMLFD])\n#### Check the passed arguments against the list of available ones\nx_with_list=\"\\\ndebug max-debug symbols optimization sse42 profiling code-coverage \\\ntcheck dll static static-exe \\\nplugin-auto-load bundles bin-release mt 64 exe runpath hard-runpath \\\nlfs limited-linker skew-guard openmp \\\nautodep suffix hostspec version execopy bincopy lib-rebuilds lib-rebuilds=ask \\\ndeactivation makefile-auto-update projects flat-makefile configure-dialog \\\ncheck ncbi-public strip pch caution ccache distcc \\\nncbi-c wxwidgets wxwidgets-ucs fastcgi sss sssdb sssutils included-sss \\\ngeo included-geo vdb downloaded-vdb static-vdb libunwind libdw backward-cpp \\\nbackward-cpp-sig \\\nz bz2 lzo pcre mbedtls gmp gcrypt nettle gnutls static-gnutls openssl krb5 \\\nsybase sybase-local sybase-new ftds mysql \\\norbacus freetype ftgl opengl mesa glut glew glew-mx gl2ps \\\nbdb python perl jni sqlite3 icu boost boost-tag \\\nsp expat sablot libxml libxslt libexslt xerces xalan zorba \\\noechem sge muparser hdf5 \\\ngif jpeg tiff png xpm \\\nmagic curl mimetic gsoap avro cereal sasl2 mongodb mongodb3 gmock lapack lmdb \\\nlibuv libssh2 cassandra nghttp2 h2o libxlsxwriter protobuf grpc msgsl aws-sdk \\\n3psw local-lbsm ncbi-crypt connext \\\nserial objects dbapi app ctools gui algo internal gbench\"\n\nchangequote(, )dnl\nx_with_list=`echo \"$x_with_list\" | sed 's/\\([^ ][^ ]*\\)/--with-\\1 --without-\\1/g'`\nchangequote([, ])dnl\n\n\nfor x_arg in \"$@\" ; do\n   if test -z \"$x_arg\" ; then\n      continue\n   fi\n\n   x_okay=\n   for x_desc in $x_with_list ; do\n      if test \"$x_arg\" = \"$x_desc\" ; then\n         x_okay=\"okay\"\n         break\n      fi\n   done\n   if test \"$x_okay\" = \"okay\" ; then\n      continue\n   fi\n\n   case \"$x_arg\" in\n      --with-extra-action= | --exec-prefix= | --with-projects= | --srcdir= \\\n      | --cache-file= | --build= | --host= | --target= | --with-runpath= \\\n      | --with-relative-runpath= | --x-includes= | --x-libraries= )\n      AC_MSG_ERROR([$x_arg:  requires value;  use --help to show usage])\n      ;;\n\n      --with-projects=* | --with-saved-settings=* )\n      # Confirm that the specified file exists and is readable.\n      file=`echo $x_arg | sed -e 's/^[[^=]]*=//'`\n      case \"$file\" in\n         /* ) ;;\n         *  ) file=$srcdir/$file ;;\n      esac\n      if test -f \"$file\"; then\n         if test -r \"$file\"; then\n            :\n         else\n            AC_MSG_ERROR([$x_arg:  requires a readable file; use --help to show usage])\n         fi\n      else\n         AC_MSG_ERROR([$x_arg:  requires a (readable) file; use --help to show usage])\n      fi\n      ;;\n\n      --with-vdb=rc ) ;;\n\n      --srcdir=* | --x-includes=* | --x-libraries=* | --with-tcheck=* \\\n      | --with-ncbi-c=* | --with-sss=* | --with-vdb=* | --with-libunwind=* \\\n      | --with-libdw=* | --with-backward-cpp=* \\\n      | --with-z=* | --with-bz2=* | --with-lzo=* \\\n      | --with-pcre=* | --with-mbedtls=* \\\n      | --with-gmp=* | --with-gcrypt=* | --with-nettle=* \\\n      | --with-gnutls=* | --with-openssl=* | --with-krb5=* \\\n      | --with-sybase-local=* | --with-ftds=*/* | --with-mysql=* \\\n      | --with-opengl=* | --with-mesa=* | --with-glut=* | --with-glew=* \\\n      | --with-gl2ps=* \\\n      | --with-wxwidgets=* | --with-freetype=* | --with-ftgl=* \\\n      | --with-fastcgi=*/* | --with-bdb=*/* | --with-orbacus=* \\\n      | --with-odbc=* | --with-python=* | --with-perl=* | --with-jni=* \\\n      | --with-boost=* | --with-sqlite3=* | --with-icu=* | --with-expat=* \\\n      | --with-sablot=* | --with-libxml=* | --with-libxslt=* | --with-exslt=* \\\n      | --with-xerces=* | --with-xalan=* | --with-zorba=* | --with-oechem=* \\\n      | --with-sge=* | --with-muparser=* | --with-hdf5=* | --with-gif=* \\\n      | --with-jpeg=* | --with-png=* | --with-tiff=* | --with-xpm=* \\\n      | --with-magic=* | --with-curl=* | --with-mimetic=* | --with-gsoap=* \\\n      | --with-avro=* | --with-cereal=* | --with-sasl2=* \\\n      | --with-mongodb=* | --with-mongodb3=* \\\n      | --with-gmock=* | --with-lapack=* | --with-lmdb=* | --with-libuv=* \\\n      | --with-libssh2=* | --with-cassandra=* | --with-nghttp2=* \\\n      | --with-h2o=* | --with-libxlsxwriter=* \\\n      | --with-protobuf=* | --with-grpc=* | --with-msgsl=* | --with-aws-sdk=* )\n      # Confirm that the specified directory exists and is readable.\n      dir=`echo $x_arg | sed -e 's/^[[^=]]*=//'`\n      case \"$x_arg\" in\n         --srcdir=* | --*=/* ) ;;\n         *  ) dir=$srcdir/$dir ;;\n      esac\n      if test -d \"$dir\"; then\n         if test -r \"$dir\"; then\n            :\n         else\n            AC_MSG_ERROR([$x_arg:  requires a readable directory; use --help to show usage])\n         fi\n      else\n         AC_MSG_ERROR([$x_arg:  requires a (readable) directory; use --help to show usage])\n      fi\n      ;;\n\n      [[A-Z]*=*] | -h | --help | --help=* | -V | --version | -q | --quiet \\\n      | --silent | --cache-file=* | -C | --config-cache | -n | --no-create \\\n      | --no-recursion | --prefix=* | --exec-prefix=* | --bindir=* \\\n      | --libdir=* | --includedir=* | --build=* | --host=* | --target=* \\\n      | --mandir=* | --infodir=* | --docdir=* | --htmldir=* \\\n      | --datadir=* | --sysconfdir=* | --localstatedir=* \\\n      | --with-runpath=* | --with-relative-runpath=* \\\n      | --with-experimental=* | --with-extra-action=* | --with-build-root=* \\\n      | --with-fake-root=* | --with-build-root-sfx=* | --with-check=* \\\n      | --with-check-tools=* | --with-ftds=[[0-9]]* | --with-fastcgi=[[0-9]]* \\\n      | --with-bdb=[[1-9]]* | --with-boost-tag=* | --with-3psw=* )\n      ;;\n\n      * )\n      AC_MSG_ERROR([$x_arg:  unknown option;  use --help to show usage])\n      ;;\n   esac\ndone\nm4_rename([NCBI_ORIG_ASMLFD], [AS_MESSAGE_LOG_FD])\nAC_DIVERT_POP\n\n\nif test \"$with_gbench\" = \"yes\" ; then\n   m4_foreach(OPT, [dll,mt,gui,exe,serial,objects,algo,glew,wxwidgets,ftgl,sqlite3,bdb,boost,xslt],\n     [if test \"$[with_]OPT\" = \"no\"; then\n         AC_MSG_ERROR([incompatible options: --without-]OPT[ but --with-gbench])\n      else\n         : ${[with_]OPT:=yes}\n      fi\n     ])\n   : ${with_projects=scripts/projects/ncbi_gbench.lst}\nelif test \"$with_jni\" = \"yes\" ; then\n   m4_foreach(OPT, [dll,mt],\n     [if test \"$[with_]OPT\" = \"no\"; then\n         AC_MSG_ERROR([incompatible options: --without-]OPT[ but --with-jni])\n      else\n         [with_]OPT=yes\n      fi\n     ])\n   : ${with_exe=no}\nfi\n\nif test \"$with_bin_release\" = \"yes\" ; then\n   # Default some other options accordingly\n   : ${with_ncbi_public=yes}\n   : ${with_dll=no}\n   : ${with_local_lbsm=no}\n   : ${with_ncbi_crypt=no}\n   : ${with_connext=no}\n   : ${with_libdw=no}\n   : ${with_pcre=no} # Too much variation across distributions.\n   : ${with_sse42=no}\n   AC_DEFINE(NCBI_BIN_RELEASE, 1,\n             [Define to 1 when building binaries for public release.])\nfi\n\nif test \"$with_debug\" = no; then\n    : ${with_symbols=no}\n    : ${with_optimization=yes}\n    if test \"$with_max_debug\" = yes; then\n       AC_MSG_ERROR([incompatible options: --without-debug but --with-max-debug])\n    fi\nelse\n    : ${with_symbols=yes}\n    : ${with_optimization=no}\nfi\n\nif test \"$with_openmp\" = yes; then\n   if test \"$with_mt\" = no; then\n      AC_MSG_ERROR([incompatible options: --without-mt but --with-openmp])\n   fi\n   : ${with_mt=yes} \nfi\n\ncase \"$with_downloaded_vdb:$with_vdb\" in\n   yes:no )\n      AC_MSG_ERROR([incompatible options: --without-vdb but\n                    --with-downloaded-vdb])\n      ;;\n   yes: )\n      with_vdb=yes\n      ;;\nesac\n\ncase \"$with_static_vdb:$with_vdb\" in\n   yes:no )\n      AC_MSG_ERROR([incompatible options: --without-vdb but --with-static-vdb])\n      ;;\n   yes: )\n      with_vdb=yes\n      ;;\n   :* )\n      with_static_vdb=$with_bin_release\n      ;;\nesac\n\ncase \"$with_static_gnutls:$with_gnutls\" in\n   yes:no )\n      AC_MSG_ERROR([incompatible options: --without-gnutls but --with-static-gnutls])\n      ;;\n   yes: )\n      with_gnutls=yes\n      ;;\n   :yes )\n      with_static_gnutls=$with_bin_release\n      ;;\nesac\n\nm4_foreach(OPT, [serial,objects,dbapi,algo],\n   [if test -n \"[$with_]OPT\"; then\n       AC_MSG_WARN([--with(out)-]OPT[ is deprecated])\n       AC_MSG_WARN([please simply pass an appropriate project list])\n    fi\n   ])\n\n#### Check for special options\nif test \"$with_extra_action\" = \"yes\" ; then\n   AC_MSG_ERROR([--with-extra-action must have a value after =])\nfi\nif test \"$with_extra_action\" = \"no\" ; then\n   AC_MSG_ERROR([--without-extra-action is not allowed])\nfi\n\ncase \"$with_projects\" in\n \"\"|yes)\n     if test -r projects; then\n        AC_MSG_NOTICE([using default projects file \"projects\".])\n        with_projects=projects\n        AC_SUBST(PROJECTS, \"\\$(top_srcdir)/projects\")\n     else\n        AC_SUBST(PROJECTS, \"\")\n        if test -f projects; then\n           AC_MSG_WARN([default projects file \"projects\" is unreadable.])\n        elif test -h projects; then\n           AC_MSG_WARN([default projects file \"projects\" is a dangling link.])\n        fi\n     fi\n     ;;\n no) with_projects=\"\" ;  AC_SUBST(PROJECTS, \"\") ;;\n /*) AC_SUBST(PROJECTS, $with_projects) ;;\n * ) AC_SUBST(PROJECTS, \"\\$(top_srcdir)/$with_projects\") ;;\nesac\n\nif test -n \"$with_projects\"; then\n   case \"$with_projects\" in\n      /* ) abs_projects=$with_projects         ;;\n      yes) abs_projects=$srcdir/projects       ;;\n      *  ) abs_projects=$srcdir/$with_projects ;;\n   esac\n   test -r \"$abs_projects\"  ||  \\\n      AC_MSG_ERROR([unable to read requested projects file \"$abs_projects\".])\nfi\n\n# Check for custom optimization flags before potentially going with defaults.\nskip_fast_flags=no\nif test -z \"${DEF_FAST_FLAGS}${FAST_CXXFLAGS}\"; then\n   case \" $CFLAGS $CXXFLAGS\" in\n      *\\ -O* | *\\ -xO* ) skip_fast_flags=yes ;;\n   esac\nfi\n# Generally save any originally specified flags.\nUSER_CFLAGS=$CFLAGS\nUSER_CXXFLAGS=$CXXFLAGS\nUSER_LDFLAGS=$LDFLAGS\n\nif test -n \"$with_experimental\"; then\n   for x in `echo $with_experimental | tr , ' '`; do\n      case \"$x\" in\n         ChaosMonkey )\n            CPPFLAGS=\"$CPPFLAGS -DNCBI_MONKEY\"\n            NCBI_FEATURE(ChaosMonkey)\n            ;;\n         Int8GI )\n            CPPFLAGS=\"$CPPFLAGS -DNCBI_INT8_GI\"\n            NCBI_C_PATH_TAGS=\"/ncbi.gi64 .gi64\"\n            NCBI_FEATURE(Int8GI)\n            ;;\n         StrictGI )\n            CPPFLAGS=\"$CPPFLAGS -DNCBI_STRICT_GI\"\n            NCBI_C_PATH_TAGS=\"/ncbi.gi64 .gi64\"\n            NCBI_FEATURE(Int8GI)\n            NCBI_FEATURE(StrictGI)\n            ;;\n         * )\n            AC_MSG_ERROR([unrecognized experimental feature \"$x\".])\n            ;;\n      esac\n   done\nfi\n\n#### Always define this\nAC_DEFINE(NCBI_CXX_TOOLKIT, 1, [This is the NCBI C++ Toolkit.])\n\nAC_MSG_CHECKING([TeamCity build number])\nif test -n \"$TEAMCITY_VERSION\" -a -n \"$BUILD_NUMBER\"; then\n   AC_MSG_RESULT($BUILD_NUMBER)\n   NCBI_TEAMCITY_BUILD_NUMBER=$BUILD_NUMBER\n   NCBI_TEAMCITY_PROJECT_NAME=$TEAMCITY_PROJECT_NAME\n   NCBI_TEAMCITY_BUILDCONF_NAME=$TEAMCITY_BUILDCONF_NAME\n   NCBI_TEAMCITY_BUILD_ID=`sed -ne 's/^teamcity\\.build\\.id=//p' \\\n                           $TEAMCITY_BUILD_PROPERTIES_FILE`\nelse\n   AC_MSG_RESULT(none)\n   NCBI_TEAMCITY_BUILD_NUMBER=0\nfi\n\nAC_MSG_CHECKING([Subversion revision])\nsvnrev=`svn info \"$srcdir\" 2>/dev/null | sed -ne 's/^Revision: //p'`\nif test -n \"$svnrev\"; then\n   AC_MSG_RESULT($svnrev)\n   NCBI_SUBVERSION_REVISION=$svnrev\nelif test -n \"$NCBI_SUBVERSION_REVISION\"; then\n   AC_MSG_RESULT($NCBI_SUBVERSION_REVISION)\nelse\n   AC_MSG_RESULT(unknown)\n   NCBI_SUBVERSION_REVISION=0\nfi\n\nAC_MSG_CHECKING([NCBI stable components' version])\nscver=`svn info \"$srcdir/src/build-system\" 2>/dev/null |\n sed -ne ['s,^URL: .*/production/components/[^/]*/\\([1-9][0-9]*\\)\\..*,\\1,p']`\nif test -n \"$scver\"; then\n   AC_MSG_RESULT($scver)\n   NCBI_SC_VERSION=$scver\nelif test -n \"$NCBI_SC_VERSION\"; then\n   AC_MSG_RESULT($NCBI_SC_VERSION)\nelse\n   AC_MSG_RESULT(unknown)\n   NCBI_SC_VERSION=0\nfi\n\nAC_DEFINE(HAVE_COMMON_NCBI_BUILD_VER_H, 1,\n   [Define to 1 if you have the <common/ncbi_build_ver.h> header file.])\n\n#### Get the running host's properties\nAC_CONFIG_AUX_DIR(src/build-system)\nAC_CANONICAL_HOST\nAC_DEFINE_UNQUOTED(HOST,        \"$host\",        [Full GNU-style system type])\nAC_DEFINE_UNQUOTED(HOST_CPU,    \"$host_cpu\",    [CPU type only])\nAC_DEFINE_UNQUOTED(HOST_VENDOR, \"$host_vendor\", [System vendor only])\nAC_DEFINE_UNQUOTED(HOST_OS,     \"$host_os\",     [System OS only])\n\n\n#### Make some provisions for traditional operation\nAC_PROG_INSTALL\n\n#### Point ICC at a suitable GCC version ASAP.\ncase \"/$CXX\" in\n   */icpc )\n      if test -d /opt/ncbi/gcc -o -d /usr/local/gcc; then\n         case \"`$CXX -dumpversion`:$host_cpu\" in\n            *:i?86)           v=4.4.5 ;;\n            ?.* | 1[[01]].* ) v=4.0.1 ;;\n            1[[23]].*)        v=4.4.2 ;;\n            *)                v=4.9.3 ;;\n         esac\n         for gcc in /opt/ncbi/gcc/$v/bin/gcc /usr/local/gcc/$v/bin/gcc; do\n            if test -x $gcc; then\n               CC=\"$CC -gcc-name=$gcc\"\n               CXX=\"$CXX -gcc-name=$gcc\"\n               case $gcc in\n                  /opt/* )\n                     LDFLAGS=\"-Wl,-rpath,/opt/ncbi/gcc/$v/lib64 $LDFLAGS\"\n                     ;;\n                  /usr/* )\n                     LDFLAGS=\"-Wl,-rpath,/usr/lib64/gcc-$v $LDFLAGS\"\n                     ;;\n               esac\n               break\n            fi\n         done\n      fi\n      ;;\nesac\n\n#### C and C++ compilers\nAC_LANG(C++)\nAX_PROG_CC_FOR_BUILD\nAC_PROG_CXX\n\n\n#### Detect Insure++, and attempt to find the real compiler.\ncase \"$CXX\" in\n   insure* | */insure*)\n      psrcdump=`echo \"$CXX\" | sed -e 's/insure.*/psrcdump/'`\n      real_CXX=`$psrcdump -t insure++ | sed -ne 's/^Compiler \\(.*\\)/\\1/p'`\n      real_dir=`$psrcdump -t insure++ | sed -ne 's/^Compilerinstalldir \\(.*\\)/\\1/p'`\n      test -n \"$real_dir\" && test -x \"$real_dir/$real_CXX\" && \\\n        real_CXX=\"$real_dir/$real_CXX\"\n      case \"$real_CXX\" in\n          *gcc* ) LIBS=\"$LIBS -lstdc++\"\n      esac\n      ;;\n   *)\n      real_CXX=$CXX\n      ;;\nesac\n\n\n#### Detect KCC compiler\nif test \"$GCC\" != \"yes\" ; then\n   touch kcc_test.cpp\n   kcc_ver=\"`$real_CXX -V -c kcc_test.cpp 2>&1 | grep '^KAI '`\"\n   kcc_license=\"`$real_CXX -V -c kcc_test.cpp 2>&1 | grep -v '^KAI '`\"\n   rm -f kcc_test.cpp kcc_test.o\n   case \"$kcc_ver\" in\n      KAI* )  KCC=\"yes\" ;;\n   esac\nfi\n\n\n#### Detect ICC compiler (newer versions of which configure can mis-ID as GCC)\nif test \"$KCC\" != \"yes\"; then\n   icc_ver=\"`$real_CXX -V 2>&1 | grep '^Intel(R) C'`\"\n   icc_license=\"`$real_CXX -c 2>&1 | grep '^icc: NOTE: The evaluation period for this product ends on '`\"\n   case \"$icc_ver\" in\n      Intel*C*Compiler* )  ICC=\"yes\"; GCC=\"no\" ;;\n   esac\nfi\n\n\n#### Detect IBM VisualAge compiler\nif test \"$GCC\" != \"yes\"  -a  \"$KCC\" != \"yes\"  -a  \"$ICC\" != \"yes\"; then\n   vac_ver=\"`$real_CXX -qversion 2>&1`\"\n   case \"$vac_ver\" in\n      *AIX* ) VAC=\"yes\" ;;\n   esac\nfi\n\n\n#### Detect Compaq compiler\nif test \"$GCC\" != \"yes\"  -a  \"$KCC\" != \"yes\"  -a  \"$ICC\" != \"yes\" \\\n  -a  \"$VAC\" != \"yes\"; then\n   ccc_ver=\"`$real_CXX -V 2>&1 | grep '^Compaq C++ V'`\"\n   case \"$ccc_ver\" in\n      *Compaq* ) CCC=\"yes\" ;;\n   esac\nfi\n\n\n#### Detect Cray compiler\nif test \"$GCC\" != \"yes\"  -a  \"$KCC\" != \"yes\"  -a  \"$ICC\" != \"yes\" \\\n  -a  \"$VAC\" != \"yes\" -a  \"$CCC\" != \"yes\"; then\n   cce_ver=\"`$real_CXX -V 2>&1 | grep '^Cray'`\"\n   case \"$cce_ver\" in\n      *Cray* ) CCE=\"yes\" ;;\n   esac\nfi\n\n\n#### Detect supported compilers\ncompiler=\ncompiler_ver=\nncbi_compiler=\"UNKNOWN\"\nncbi_compiler_ver=\"0\"\n\nif test \"$GCC\" = \"yes\" ; then\n   compiler_ver=\"`$real_CXX -dumpversion 2>&1`\"\n   compiler=\"GCC\"\n   ncbi_compiler=\"GCC\"\n   ncbi_compiler_ver=\"$compiler_ver\"\n   NCBI_FEATURE(GCC)\nelif test \"$KCC\" = \"yes\" ; then\n   compiler_ver=\"$kcc_ver\"\n   compiler=\"KCC\"\n   ncbi_compiler=\"KCC\"\n   ncbi_compiler_ver=\"`echo $kcc_ver | sed 's%^KAI .*C[[+]][[+]] \\([[0-9.]]*\\).*%\\1%'`\"\n   NCBI_FEATURE(KCC)\nelif test \"$ICC\" = \"yes\" ; then\n   compiler_ver=\"$icc_ver\"\n   compiler=\"ICC\"\n   ncbi_compiler=\"ICC\"\n   ncbi_compiler_ver=\"`echo $icc_ver | sed 's%.*Version \\([[0-9.]]*\\).*%\\1%'`\"\n   NCBI_FEATURE(ICC)\nelif test \"$VAC\" = \"yes\" ; then\n   compiler_ver=\"$vac_ver\"\n   compiler=\"VisualAge\"\n   ncbi_compiler=\"VISUALAGE\"\n   ncbi_compiler_ver=\"`echo $vac_ver | sed 's%.*[[Vv]]ersion:* 0*\\([[0-9.]]*\\).*%\\1%'`\"\n   NCBI_FEATURE(VisualAge)\nelif test \"$CCC\" = \"yes\" ; then\n   compiler_ver=\"$ccc_ver\"\n   compiler=Compaq\n   ncbi_compiler=\"COMPAQ\"\n   ncbi_compiler_ver=\"`echo $ccc_ver | sed 's%.*C[[+]][[+]] V\\([[0-9.]]*\\).*%\\1%'`\"\n   NCBI_FEATURE(CompaqCompiler)\nelif test \"$CCE\" = \"yes\" ; then\n   compiler_ver=\"$cce_ver\"\n   compiler=\"Cray\"\n   ncbi_compiler=\"CRAY\"\n   ncbi_compiler_ver=\"`echo $cce_ver | sed 's%.*Version \\([[0-9.]]*\\).*%\\1%'`\"\n   NCBI_FEATURE(Cray)\nelse\n   case \"$host_os\" in\n    solaris* )\n      compiler_ver=\"`$real_CXX -V 2>&1`\"\n      case \"$compiler_ver\" in\n        *WorkShop*Compilers*5\\.0 )\n          compiler=\"WorkShop5\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.0\" ;;\n        *Sun*WorkShop*6*5\\.1* )\n          compiler=\"WorkShop51\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.1\" ;;\n        *Sun*WorkShop*6*5\\.2* )\n          compiler=\"WorkShop52\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.2\" ;;\n        *Sun*WorkShop*6*5\\.3* )\n          compiler=\"WorkShop53\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.3\" ;;\n        *Forte*7*5\\.4* )\n          compiler=\"WorkShop54\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.4\" ;;\n        *Sun*C*5\\.5* )\n          compiler=\"WorkShop55\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.5\" ;;\n        *Sun*C*5\\.8* )\n          compiler=\"WorkShop58\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.8\" ;;\n        *Sun*C*5\\.9* )\n          compiler=\"WorkShop59\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.9\" ;;\n        *Sun*C*5\\.10* )\n          compiler=\"WorkShop510\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.10\" ;;\n        *Sun*C*5\\.11* )\n          compiler=\"WorkShop511\"\n          ncbi_compiler=\"WORKSHOP\"\n          ncbi_compiler_ver=\"5.11\" ;;\n      esac\n      NCBI_FEATURE(WorkShop)\n      ;;\n\n    irix* )\n      compiler_ver=\"`$real_CXX -version 2>&1`\"\n      case \"$compiler_ver\" in\n        MIPSpro*Compilers:*Version*7\\.3* )\n          compiler=\"MIPSpro73\"\n          ncbi_compiler=\"MIPSPRO\"\n          ncbi_compiler_ver=\"7.3\"\n          NCBI_FEATURE(MIPSpro)\n          ;;\n      esac\n      ;;\n\n    cygwin* )\n      case \"$real_CXX\" in\n        *cl\\.exe* | cl)\n          compiler=\"MSVC\"\n          ncbi_compiler=\"MSVC\"\n          ncbi_compiler_ver=\"6.0\"\n          NCBI_FEATURE(MSVC)\n          ;;\n      esac\n      ;;\n   esac\nfi\n\nchangequote(, )dnl\n#ncbi_compiler_ver=\"`echo $ncbi_compiler_ver | sed 's%\\([0-9]\\)\\.\\([0-9]\\)\\.\\([0-9]\\).*%\\1\\2\\3%; s%\\([0-9]\\)\\.\\([0-9][0-9]*\\).*%\\1\\2%; s%^\\([0-9][0-9]\\)$%\\10%; s%^\\([0-9]\\)$%\\100%'`\"\ncase \"$compiler:$ncbi_compiler_ver\" in\n    WorkShop*:?.?? )   ncbi_compiler_sed='s/\\([0-9]\\)\\.\\([0-9][0-9]\\)/\\1\\20/' ;;\n    WorkShop*:[6-9].?) ncbi_compiler_sed='s/\\([0-9]\\)\\.\\([0-9\\)/\\10\\20/' ;;\n    ICC:??.? )  ncbi_compiler_sed='s/\\([0-9][0-9]\\)\\.\\([0-9]\\)/\\1\\20/' ;;\n    ICC:??.?.? | \\\n    ICC:??.?.?.* ) ncbi_compiler_sed='s/\\([0-9][0-9]\\)\\.\\([0-9]\\)\\.\\([0-9]\\).*/\\1\\2\\3/' ;;\n    *:?.?.?)    ncbi_compiler_sed='s/\\([0-9]\\)\\.\\([0-9]\\)\\.\\([0-9]\\)/\\1\\2\\3/' ;;\n    *:?.??*)    ncbi_compiler_sed='s/\\([0-9]\\)\\.\\([0-9][0-9]\\).*/\\1\\2/' ;;\n    *:?.?)      ncbi_compiler_sed='s/\\([0-9]\\).\\([0-9]\\)/\\1\\20/' ;;\n    *:?)        ncbi_compiler_sed='s/\\([0-9]\\)/\\100/' ;;\nchangequote([, ])dnl\n    *)    AC_MSG_ERROR([Do not know how to parse $compiler version number $ncbi_compiler_ver]) ;;\nesac\nncbi_compiler_ver=`echo $ncbi_compiler_ver | sed \"$ncbi_compiler_sed\"`\ncompiler_version=$ncbi_compiler_ver\n\n# Possible values of NCBI_COMPILER_$ncbi_compiler, since acconfig.h is obsolete\nif false; then\n   AC_DEFINE(NCBI_COMPILER_GCC,       1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_KCC,       1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_ICC,       1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_WORKSHOP,  1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_MIPSPRO,   1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_VISUALAGE, 1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_COMPAQ,    1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_CRAY,      1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_MSVC,      1, [Compiler name])\n   AC_DEFINE(NCBI_COMPILER_UNKNOWN,   1, [Compiler name])\nfi\n\nAC_DEFINE_UNQUOTED(NCBI_COMPILER, \"$ncbi_compiler\", [Compiler name])\nAC_DEFINE_UNQUOTED(NCBI_COMPILER_$ncbi_compiler, 1, [Compiler name])\nAC_DEFINE_UNQUOTED(NCBI_COMPILER_VERSION, $ncbi_compiler_ver,\n                   [Compiler version as three-digit integer])\n\n\n#### Additional check for pre-defined compilers\ncase \"$compiler:$compiler_version\" in\n  MSVC:* )\n    if test -z \"$NCBI_COMPILER\" ; then\n       echo\n       echo \"Compiler \\\"${compiler}\\\" requires a special tuning, so you\"\n       echo \"better use a special shell script located in \\\"compilers/*.sh\\\"!\"\n       NCBI_CAUTION([Do you still want to proceed (at your own risk)?])\n       echo\n    fi ;;\nesac\n\n\n#### Use full path to the compiler, if possible\nchangequote(, )dnl\n\nset $CC\nx_CC=\"`type $1 | sed 's/.* \\([^ ]*\\)$/\\1/'`\"\nif test ! -x \"$x_CC\" ; then\n  x_CC=\"`which $1  2>/dev/null`\"\nfi\n\nif test -x \"$x_CC\" ; then\n  shift\n  CC=\"$x_CC $*\"\n  echo \"adjusted C   compiler: $CC\"\nfi\nCC_PATH=\"`dirname $x_CC`\"\nx_CC=\n\nset $CXX\nx_CXX=\"`type $1 | sed 's/.* \\([^ ]*\\)$/\\1/'`\"\nif test ! -x \"$x_CXX\" ; then\n  x_CXX=\"`which $1  2>/dev/null`\"\nfi\n\nif test -x \"$x_CXX\" ; then\n  shift\n  CXX=\"$x_CXX $*\"\n  echo \"adjusted C++ compiler: $CXX\"\nfi\nCXX_PATH=\"`dirname $x_CXX`\"\n\nif test \"$with_static_exe\" = \"yes\"; then\n   C_LINK='$(top_srcdir)/scripts/common/impl/favor-static $(CC)'\n   LINK='$(top_srcdir)/scripts/common/impl/favor-static $(CXX)'\nelse\n   C_LINK='$(CC)'\n   LINK='$(CXX)'\nfi\n\n### Which of these is better?\n#compiler_root=`dirname CXX_PATH`\ncompiler_root=`echo $x_CXX | sed -ne 's:\\(.*\\)[/\\\\]bin[/\\\\].*:\\1:p'`\nx_CXX=\n\nchangequote([, ])dnl\n\n\n#### Multi-Thread safety\n# Historically off by default; respect that when reconfiguring old builds.\nif test -z \"$with_mt\" -a -f \"$NCBI_OLD_STATUS_DIR/-MT.enabled\"; then\n    with_mt=no\nfi\n\nif test \"$with_mt\" != \"no\" ; then\n   with_mt=yes\n   case \"$host_os:$compiler\" in\n    darwin* | irix* | cygwin* | *:Cray ) ;;\n    solaris*:WorkShop*       )  : ${MT_FLAG:=\"-mt\"} ;;\n    solaris*:GCC             )  : ${MT_FLAG:=\"-pthreads\"} ;;\n    *:KCC                    )  : ${MT_FLAG:=\"--thread_safe\"} ;;\n    *:Compaq | *:GCC | *:ICC )  : ${MT_FLAG:=\"-pthread\"} ;;\n    *:VisualAge              )  : ${MT_FLAG:=\"-qthreaded\"} ;;\n    * )\n       msg=\"Do not know how to build MT-safe with compiler $CXX $compiler_ver\"\n       case \"$with_mt\" in\n          yes ) AC_MSG_ERROR([$msg]) ;;\n          ''  ) AC_MSG_WARN([$msg]); with_mt=no ;;\n       esac\n       ;;\n   esac\nfi\n\ncase \"$host_os:$compiler\" in\n  solaris2.10:GCC ) : ${THREAD_LIBS:=\"-lposix4\"} ;;\n  solaris*        ) : ${THREAD_LIBS:=\"-lpthread -lposix4\"} ;;\n  freebsd*        ) : ${THREAD_LIBS:=\"-pthread\"} ;; # for LMDB in ST builds\n  *               ) : ${THREAD_LIBS:=\"-lpthread\"} ;;\nesac\n\nif test \"$with_mt\" != \"no\" ; then\n   CPPFLAGS=\"$CPPFLAGS -D_MT -D_REENTRANT -D_THREAD_SAFE\"\n   LIBS=\"$LIBS $THREAD_LIBS\"\n   case \"$host_os:$compiler\" in\n     solaris2.??:* | solaris*:GCC | *:Compaq | irix* | aix* | darwin* | cygwin*)\n        NCBIATOMIC_LIB=\n        ;;\n     *:GCC | *:ICC | linux*:KCC )\n        case \"$host_cpu\" in\n           i?86 | powerpc* | ppc* | x86_64 | sparc* ) NCBIATOMIC_LIB= ;;\n           * ) NCBIATOMIC_LIB=xncbi ;;\n        esac\n        ;;\n     *:WorkShop* | solaris*:KCC )\n        NCBIATOMIC_LIB=xncbi\n        ncbicntr=\"ncbicntr_workshop ncbiatomic_workshop\"\n        ;;\n     * ) NCBIATOMIC_LIB=xncbi ;;\n   esac\n   case \"$compiler\" in\n      GCC )\n         if $CC -v 2>&1 | grep clang >/dev/null; then\n            :\n            # Will allegedly support -openmp at some point, but as of 3.4,\n            # just parses it as specifying an output filename: -o penmp.\n         else\n            case \"$compiler_version\" in\n               [[123]]?? | 4[[01]]? ) ;;\n               * ) : ${OPENMP_FLAGS=-fopenmp} ;;\n            esac\n         fi\n         ;;\n      ICC )\n         : ${OPENMP_FLAGS=-openmp}\n         ;;\n      WorkShop* )\n         : ${OPENMP_FLAGS=-xopenmp=parallel}\n         ;;\n   esac\n   if test \"$with_openmp\" = yes; then\n      MT_FLAG=\"$MT_FLAG $OPENMP_FLAGS\"\n      OPENMP_FLAGS=\n   fi\n   mt_sfx=\"MT\"\n   NCBI_FEATURE(MT)\nelse\n   CPPFLAGS=\"$CPPFLAGS -DNCBI_WITHOUT_MT\"\n   MT_FLAG=\n   NCBIATOMIC_LIB=\n   OPENMP_FLAGS=\n   mt_sfx=\"\"\nfi\nMT_SFX=\"${mt_sfx}\"\nAC_SUBST(MT_SFX)\n\nCFLAGS=\"$MT_FLAG $CFLAGS\"\nCXXFLAGS=\"$MT_FLAG $CXXFLAGS\"\nLDFLAGS=\"$MT_FLAG $LDFLAGS\"\n\nAPP_LDFLAGS=\nDLL_LDFLAGS=\n\n#### Provide default environment setup for known platforms/compilers\nDEPFLAGS=\"-M\"\nDEPFLAGS_POST=\"\" # Needed for VisualAge\nOBJCXX_CXXFLAGS=\nOBJCXX_LIBS=\ncase \"$host_os:$compiler\" in\n solaris2\\.6:GCC )\n   echo \"GCC compiler is not supported for:  $host\"\n   compiler=\n   ;;\n\n solaris*:GCC )\n   STRIP=\"@:\"\n   ;;\n\n linux*:ICC )\n   # \"incomplete type is not allowed\" should be an error, not a warning!\n   CFLAGS=\"-we70 $CFLAGS\"\n   CXXFLAGS=\"-we70 $CXXFLAGS\"\n   case \"$compiler_version\" in\n      1[[1-9]]?? ) MATH_LIBS=-Wl,-lm ;; # avoid static libimf in shared libs\n   esac\n   ;;\n\n linux*:GCC )\n    if test -r $srcdir/src/build-system/config.site.ncbi && test -d \"$NCBI\"\n    then\n       case \"$compiler_version\" in\n          5* ) CPPFLAGS=\"-D_GLIBCXX_USE_CXX11_ABI=0 $CPPFLAGS\" ;;\n       esac\n    fi\n    ;;\n\n irix*:GCC )\n   if test \"$with_debug\" != \"no\" ; then\n      LDFLAGS=\"-LD_LAYOUT:lgot_buffer=32 $LDFLAGS\"\n   fi\n   ;;\n\n solaris*:WorkShop* )\n   CPPFLAGS=\"-D__EXTENSIONS__ $CPPFLAGS\"\n   CXXFLAGS=\"+w +w2 $CXXFLAGS\"\n   DEPFLAGS=\"-xM1\"\n   LDFLAGS=\"-xildoff $LDFLAGS\"\n   AR=${AR:=\"$CXX $MT_FLAG -xar -o\"}\n   STRIP=\"@:\"\n   if test \"$with_symbols\" = \"no\" -a \"$with_profiling\" != \"yes\" \\\n      -a \"$with_strip\" = \"yes\" ; then\n      LDFLAGS=\"-s $LDFLAGS\"\n   fi\n   # Recent versions default to DWARF, yielding much larger executables in\n   # debug configurations; insist on STABS when the choice exists, even for\n   # versions that already default to it.\n   case \"$with_symbols:$compiler\" in\n      no:* | *:WorkShop5[[0-4]] ) ;;\n      * )\n         CFLAGS=\"-xdebugformat=stabs $CFLAGS\"\n         CXXFLAGS=\"-xdebugformat=stabs $CXXFLAGS\"\n         ;;\n   esac\n   CXX_FILTER=\"2>&1 | \\$(top_srcdir)/compilers/unix/cxx_filter.WorkShop.sh\"\n   LINK_FILTER=\"$CXX_FILTER\"\n   AR_FILTER=\"$CXX_FILTER\"\n   serial_ws50_rtti_kludge=\"rtti\"\n   ;;\n\n irix*:MIPSpro73 )\n   COMMON_FLAGS=\"-fullwarn -brief_diagnostics -use_readonly_const -G0 -rdata_shared\"\n   # Warnings we disable (messages courtesy of \"gettxt cc.cat.m:N\")\n   # 1107: A signed bit field has a length of 1 bit.\n   # 1169: External/internal linkage conflicts with a previous declaration.\n   # 1209: The controlling expression is constant. [while (0) et al.]\n   # 1424: The %n1 is not used in declaring the argument types of %n2.\n   # 1429: The type \"long long\" is nonstandard.\n   # 1460: Function %n is redeclared \"inline\" after being called.\n   # 1521: A nonstandard preprocessing directive is used.\n   CFLAGS=\"$COMMON_FLAGS -woff 1209 $CFLAGS\"\n   CXXFLAGS=\"$COMMON_FLAGS -ansiW -ptused -FE:eliminate_duplicate_inline_copies -FE:template_in_elf_section -no_auto_include -LANG:std -LANG:ansi-for-init-scope -woff 1460,1521,1429,1169,1209,1107,1424 $CXXFLAGS\"\n   : ${CXXCPP:=\"$CXX -E -LANG:std\"}\n   LDFLAGS=\"-LANG:std -G0 -FE:eliminate_duplicate_inline_copies -FE:template_in_elf_section $LDFLAGS\"\n   CPPFLAGS=\"-D__LONGLONG $CPPFLAGS\"\n   CXX_FILTER=\"2>&1 | \\$(top_srcdir)/compilers/unix/cxx_filter.$compiler.sh\"\n   ;;\n\n cygwin*:GCC )\n   CPPFLAGS=\"-D_GLIBCXX_USE_C99 $CPPFLAGS\"\n   with_dll=\"no\"\n   # : ${NETWORK_LIBS:=\"-lws2_32\"}\n   CONF_exe_ext=\".exe\"\n   ;;\n\n cygwin*:MSVC )\n   with_dll=\"no\"\n   CFLAGS=\"/W4 /Od /Zi /DEBUG /D_DEBUG\"\n   CXXFLAGS=\"/W4 /Od /Zi /DEBUG /D_DEBUG\"\n   CPPFLAGS=\"/nologo $CPPFLAGS\"\n   LDFLAGS=\"/DEBUG\"\n   AR=\"lib.exe\"\n   RANLIB=\":\"\n   STRIP=\"@:\"\n   CONF_obj_ext=\".obj\"\n   CONF_lib_ext=\".lib\"\n   CONF_dll_ext=\".dll\"\n   CONF_lib_l_ext=\".lib\"\n   CONF_lib_pre=\" \"\n   CONF_lib_l_pre=\" \"\n   CONF_exe_ext=\".exe\"\n   CONF_f_compile=\"/c \"\n   CONF_f_outobj=\"/Fo\"\n   CONF_f_outlib=\"/OUT:\"\n   CONF_f_libpath=\"/LIBPATH:\"\n   CONF_f_outexe=\"/OUT:\"\n   script_shell=\"\"\n   make_shell=\"\"\n   ;;\n\n *:VisualAge)\n   # 1506-1108 (I) The use of keyword '__attribute__' is non-portable.\n   CFLAGS=\"-qlanglvl=extc99 -qsuppress=1506-1108 $CFLAGS\"\n   # 1540-1663 (W) Incorrect assignment of a restrict qualified pointer.\n   CXXFLAGS=\"-qrtti=all -qsuppress=1540-1663 $CXXFLAGS\"\n   DEPFLAGS=\"-E -M\"\n   DEPFLAGS_POST='>/dev/null 2>&1; (cat $*.u; rm -f $*.u)'\n   ;;\n\n *:Compaq)\n   CPPFLAGS=\"-D__USE_STD_IOSTREAM $CPPFLAGS\"\n   CXXFLAGS=\"-tweak -nocompress -distinguish_nested_enums $CXXFLAGS\"\n   DEPFLAGS=\"$DEPFLAGS -distinguish_nested_enums\"\n   case \"$host_os\" in\n      osf*)\n        # Suppress link warnings; otherwise, we get \"weak symbol multiply\n        # defined\" all over the place.\n        LDFLAGS=\"-Wl,-S $LDFLAGS\"\n        # The linker sometimes needs a LOT of memory.\n        LINK=\"ulimit -d \\`ulimit -H -d\\` && $LINK\"\n        ;;\n   esac\n   ;;\n\n darwin*:GCC)\n   case `uname -m` in\n      *64 ) : ${with_64=yes} ;;\n      *   ) : ${with_64=no}  ;;\n   esac\n   # Per <http://fink.sourceforge.net/doc/porting/shared.php>, it was\n   # historically necessary to build plugins as Mach-O bundles rather than\n   # dynamic libraries.  That's not such a big deal on modern Mac OS X\n   # versions, so the Toolkit now defaults to building only the latter.\n   CONF_dll_ext=\".dylib\"\n   if test \"$with_bundles\" = yes; then\n      CONF_loadable_ext=\".so\"\n   else\n      CONF_loadable_ext=\".dylib\"\n   fi\n   if $CXX -v 2>&1 | grep -q Apple; then\n      CFLAGS=\"-fpascal-strings $CFLAGS\"\n      CXXFLAGS=\"-fpascal-strings $CXXFLAGS\"\n      if $CXX -v 2>&1 | grep -q clang; then\n         try_old_sdks=no\n      else\n         try_old_sdks=$with_ncbi_public\n         CXXFLAGS=\"-fno-permissive $CXXFLAGS\"\n      fi\n      # -flat_namespace is necessary for proper handling of shared libraries\n      # that don't themselves link against all their dependencies.\n      LDFLAGS=\"-flat_namespace -headerpad_max_install_names $LDFLAGS\"\n\n      if test \"$try_old_sdks\" = yes; then\n         sdks='/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.7.sdk'\n         case \"$host_os\" in\n            darwin?.* | darwin10.* ) # Mac OS X 10.6.x or older\n               TARGET='-mmacosx-version-min=10.5'\n               sdks=\"/Developer/SDKs/MacOSX10.6.sdk\"\n               ;;\n            * )\n               TARGET='-mmacosx-version-min=10.7'\n               ;;\n         esac\n         for sdk in $sdks; do\n            if test -d \"$sdk\"; then \n               TARGET=\"-isysroot $sdk $TARGET\"\n               break\n            fi\n         done\n         CC=\"$CC $TARGET\"\n         CXX=\"$CXX $TARGET\"\n      fi\n   else\n      LDFLAGS=\"-Wl,-flat_namespace -Wl,-headerpad_max_install_names $LDFLAGS\"\n   fi\n   if test -f /usr/include/dlfcn.h; then\n      # may be able to do without /sw, so ignore it by default\n      :\n   elif test -f /sw/include/dlfcn.h; then\n      CPPFLAGS=\"-I/sw/include $CPPFLAGS\"\n      LDFLAGS=\"-L/sw/lib $LDFLAGS\"\n   else\n      AC_MSG_WARN([No dlfcn.h in /usr/include or /sw/include.])\n   fi\n   case \"$CPPFLAGS $LIBS\" in\n      *sw/*) ;;\n      *)\n         if test -d \"$orig_NCBI/safe-sw\"; then\n             CPPFLAGS=\"-I$orig_NCBI/safe-sw/include $CPPFLAGS\"\n             LDFLAGS=\"-L$orig_NCBI/safe-sw/lib $LDFLAGS\"\n         fi\n         ;;\n   esac\n   : ${with_x=${with_xpm-no}}\n\n   # CPPFLAGS=\"-F/System/Library/Frameworks/CoreServices.framework/Frameworks $CPPFLAGS\"\n   LIBS=\"-Wl,-framework,ApplicationServices $LIBS\"\n\n   OBJCXX_CXXFLAGS='-x objective-c++'\n   OBJCXX_LIBS='-lobjc'\n\n   # New in macOS 10.12; don't attempt to use on older versions\n   ac_cv_func_clock_gettime=no\n   ac_cv_search_clock_gettime=no\n   ;;\nesac\n\n\n#### Set makefile variables for platform-specific includes\nchangequote(, )dnl\nCOMPILER=`echo $ncbi_compiler | tr '[A-Z]' '[a-z]'`\nOSTYPE=`echo $host_os | sed -e 's/[0-9.]*$//; s/-gnu[^-]*$//; y/A-Z/a-z/'`\nchangequote([, ])dnl\n\n\n#### Check if the compiler matches one of supported compilers on this platform\nif test -z \"$compiler\" ; then\n   cat <<EOF\n\n  Compiler $CXX $compiler_ver is not fully supported.\n  Consult doc/config.html\\#ref_Compilers for the list of\n  fully supported platforms/compilers.\nEOF\n   NCBI_CAUTION([Do you still want to proceed (at your own risk)?])\n   echo\n   compiler=\"UNKNOWN\"\nfi\n\n\nC_LIBS=$LIBS\n\n\nARCH_CPPFLAGS=\n#### architecture settings, and extra C++ LIBS\nif test \"$with_64\" = \"yes\" ; then\n   bit64_sfx=\"64\"\n   case \"$host:$compiler\" in\n    sparc-sun-solaris*:WorkShop5 | sparc-sun-solaris*:KCC )\n      ARCH_CFLAGS=\"-xtarget=ultra -xarch=v9\"\n      ;;\n    sparc-sun-solaris*:WorkShop51 )\n      ARCH_CFLAGS=\"-xtarget=ultra -xarch=v9\"\n      LIBS=\"-Bstatic -L$CXX_PATH/../lib -lCstd -lCrun -Bdynamic $LIBS -lc\"\n      ;;\n    *solaris*:WorkShop59 | *solaris*:WorkShop51? )\n      ARCH_CFLAGS=\"-m64\"\n      LIBS=\"-lCstd -lCrun $LIBS -lc\"\n      ;;\nchangequote(, )dnl\n    *solaris*:WorkShop5* )\n      ARCH_CFLAGS=\"-xtarget=generic64\"\n      # Redundant for programs, but necessary for dlopen-able shared libs,\n      # at least in the x86 ReleaseMT configuration.\n      LIBS=\"-lCstd -lCrun $LIBS -lc\"\n      ;;\nchangequote([, ])dnl\n    mips*:GCC )\n      ARCH_CFLAGS=\"-mips64\"\n      ;;\n    *:GCC )\n      # May not work prior to GCC 3.1.\n      ARCH_CFLAGS=\"-m64\"\n      case $host_os in darwin*) ARCH_CPPFLAGS=\"-m64\" ;; esac\n      ;;\n\n    mips-sgi-irix*:MIPSpro73 )\n      ARCH_CFLAGS=\"-64\"\n      CPPFLAGS=\"$ARCH_CFLAGS $CPPFLAGS\"\n      AR=${AR:=\"$CXX $ARCH_CFLAGS -ar -WR,-v -o\"}\n      ;;\n    mips-sgi-irix*:KCC )\n      ARCH_CFLAGS=\"-64\"\n      ;;\n    * )\n      AC_MSG_ERROR([Do not know how to compile 64-bit with compiler $CXX $compiler_ver $host:$compiler])\n      ;;\n   esac\nelse\n   bit64_sfx=\n   ARCH_CFLAGS=\n   if test \"$with_64\" = \"no\" ; then\n      case \"$host:$compiler\" in\n       *solaris*:WorkShop* | *solaris*:KCC )\n         ARCH_CFLAGS=\"-xtarget=generic\"\n         ;;\n       mips*:GCC )\n         ARCH_CFLAGS=\"-mipsn32\"\n         ;;\n       *:GCC )\n         # May not work prior to GCC 3.1.\n         ARCH_CFLAGS=\"-m32\"\n         case $host_os in darwin*) ARCH_CPPFLAGS=\"-m32\" ;; esac\n         ;;\n\n       mips-sgi-irix*:MIPSpro73 )\n         ARCH_CFLAGS=\"-n32\"\n         CPPFLAGS=\"$ARCH_CFLAGS $CPPFLAGS\"\n         AR=${AR:=\"$CXX $ARCH_CFLAGS -ar -WR,-v -o\"}\n         ;;\n       mips-sgi-irix*:KCC )\n         ARCH_CFLAGS=\"-n32\"\n         ;;\n       * )\n         # Just a warning, since 32-bit mode is typically the default anyway...\n         AC_MSG_WARN([Do not know how to compile 32-bit with compiler $CXX $compiler_ver $host:$compiler])\n         ;;\n      esac\n   fi\n   case \"$host:$compiler\" in\n    *solaris*:WorkShop5 )\n      LIBS=\"-Bstatic -L$CXX_PATH/../SC5.0/lib -lm -Bdynamic $LIBS\"\n      MATH_LIBS=\" \"\n      ;;\n    *solaris*:WorkShop51 )\n      LIBS=\"-Bstatic -L$CXX_PATH/../lib -lCstd -lCrun -lm -Bdynamic $LIBS -lc\"\n      MATH_LIBS=\" \"\n      ;;\n    sparc-sun-solaris*:WorkShop54 )\n      # Using this (still very conservative) non-generic XARCH flavor allows\n      # compiler to use the extended instruction set which reportedly speeds\n      # up the locking of at least some STL classes by allowing them to use\n      # atomic increment instead of mutex;  also seems to fix something that\n      # caused misterios basic_string<> related crashes in the\n      # WorkShop54 -xarch=v8 -mt configuration).\n      ARCH_CFLAGS=\"-xarch=v8plus\"\n      LIBS=\"-lCstd $LIBS -lCrun -lc\"\n      ;;\nchangequote(, )dnl\n    *solaris*:WorkShop5* )\n      # MATH_LIBS=\" \"\n      # Redundant for programs, but necessary for dlopen-able shared libs,\n      # at least in the x86 ReleaseMT configuration.\n      LIBS=\"-lCstd $LIBS -lCrun -lc\"\n      ;;\nchangequote([, ])dnl\n    *irix*:MIPSpro73 | *irix*:KCC )\n      ARCH_CFLAGS=\"-n32\"\n      ;;\n   esac\nfi\n\ncase \"$host_os:$host_cpu\" in\n   linux*:alpha*)\n      ARCH_CFLAGS=\"-mieee $ARCH_CFLAGS\"\n      ;;\nesac\n\nCPPFLAGS=\"$ARCH_CPPFLAGS $CPPFLAGS\"\nCFLAGS=\"$ARCH_CFLAGS $CFLAGS\"\nCXXFLAGS=\"$ARCH_CFLAGS $CXXFLAGS\"\nLDFLAGS=\"$ARCH_CFLAGS $LDFLAGS\"\n\n: ${MATH_LIBS:=\"-lm\"}\n\n### Math lib to be always linked in\nLIBS=\"$MATH_LIBS $LIBS\"\nC_LIBS=\"$MATH_LIBS $C_LIBS\"\n\n### Should go before any test compiler runs\nAC_GNU_SOURCE\n\nif test -n \"$with_64\"; then\n   AC_CACHE_CHECK([whether this system supports --with(out)-64],\n      ncbi_cv_sys_with64_ok,\n      [AC_LINK_IFELSE([\n          AC_LANG_PROGRAM([#include <string>],\n                          [std::string* sp = new std::string(\"foo\");])],\n          ncbi_cv_sys_with64_ok=yes, ncbi_cv_sys_with64_ok=no)])\n   if test \"$ncbi_cv_sys_with64_ok\" = no; then\n      AC_MSG_ERROR([cannot continue; please try different options])\n   fi\nfi\n\n#### Don't let Clang pick up old (pre-C++11) system standard\n#### library installations on Linux.\ncase \"$host_os:/$CXX\" in\n   linux*:*/clang* )\n      gccver=4.9.3\n      gccdir=/opt/ncbi/gcc/$gccver\n      if test -d $gccdir; then\n         for d in `$gccdir/bin/g++ -v -E -x c++ $ARCH_CFLAGS $ARCH_CPPFLAGS - \\\n                   </dev/null 2>&1 | fgrep 'include/c++' | tac`; do\n            NCBI_FIX_DIR(d)\n            # We don't use a dedicated CXXCPPFLAGS variable, but sticking\n            # with -isystem rather than -cxx-isystem avoids spurious\n            # warnings when also using ccache or distcc, and should still\n            # be safe in practice.  (The three libstdc++ headers that have\n            # the same names as system headers all arrange to include\n            # those headers via #include_next, and to conditionalize any\n            # C++ declarations on compiling as actual C++.)\n            CPPFLAGS=\"-isystem $d $CPPFLAGS\"\n         done\n         CPPFLAGS=\"-nostdinc++ $CPPFLAGS\"\n         libstdcxx=`$gccdir/bin/g++ --print-file-name=libstdc++.a`\n         d=`dirname $libstdcxx`\n         NCBI_FIX_DIR(d)         \n         LDFLAGS=\"-L$d -Wl,-rpath,$d $LDFLAGS\"\n      fi\n      ;;\nesac\n\ncase \"$host_os:$compiler\" in\n   darwin*:GCC )\n      AC_CACHE_CHECK([whether $CC supports -Wl,-rpath],\n         ncbi_cv_prog_cc_wl_rpath,\n         [orig_LDFLAGS=$LDFLAGS\n          LDFLAGS=\"-Wl,-rpath,. $LDFLAGS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n             [ncbi_cv_prog_cc_wl_rpath=yes], [ncbi_cv_prog_cc_wl_rpath=no])\n          LDFLAGS=$orig_LDFLAGS])\n      ;;\n   cygwin* )\n      ;;\n   *:GCC | *:ICC )\n      AC_CACHE_CHECK([whether $CC has an option to export all symbols],\n         ncbi_cv_prog_cc_export_all,\n         [orig_LDFLAGS=$LDFLAGS\n          ncbi_cv_prog_cc_export_all=no\n          for x in -Wl,--export-all-symbols -Wl,-export-dynamic -rdynamic \\\n                   -Wl,-E; do\n             LDFLAGS=\"$x $orig_LDFLAGS\"\n             AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n                [ncbi_cv_prog_cc_export_all=$x])\n             test \"x$ncbi_cv_prog_cc_export_all\" = \"xno\"  ||  break\n          done\n          LDFLAGS=$orig_LDFLAGS])\n      test \"$ncbi_cv_prog_cc_export_all\" = no  || \\\n         LDFLAGS=\"$ncbi_cv_prog_cc_export_all $LDFLAGS\"\n      AC_CACHE_CHECK([whether $CC supports -Wl,--{en,dis}able-new-dtags],\n         ncbi_cv_prog_cc_new_dtags,\n         [orig_LDFLAGS=$LDFLAGS\n          LDFLAGS=\"-Wl,--enable-new-dtags $LDFLAGS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n             [ncbi_cv_prog_cc_new_dtags=yes], [ncbi_cv_prog_cc_new_dtags=no])\n          LDFLAGS=$orig_LDFLAGS])\n      if test \"$ncbi_cv_prog_cc_new_dtags\" = yes; then\n          if test \"$with_hard_runpath\" = yes; then\n             LDFLAGS=\"-Wl,--disable-new-dtags $LDFLAGS\"\n          else\n             LDFLAGS=\"-Wl,--enable-new-dtags $LDFLAGS\"\n          fi\n      fi\n      ;;\nesac\n\nAC_CACHE_CHECK([whether $CC has an option to discard unneeded shared libraries],\n   ncbi_cv_prog_cc_as_needed,\n   [orig_LDFLAGS=$LDFLAGS\n    ncbi_cv_prog_cc_as_needed=no\n    for x in -Wl,--as-needed; do\n       LDFLAGS=\"$orig_LDFLAGS $x\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n          [ncbi_cv_prog_cc_as_needed=$x])\n       test \"x$ncbi_cv_prog_cc_as_needed\" = \"xno\"  ||  break\n    done\n    LDFLAGS=$orig_LDFLAGS])\ncase \"$ncbi_cv_prog_cc_as_needed\" in\n   -Wl,--as-needed )\n      AS_NEEDED=-Wl,--as-needed\n      NO_AS_NEEDED=-Wl,--no-as-needed\n      ;;\n   no )\n      AS_NEEDED=\n      NO_AS_NEEDED=\n      ;;\nesac\n       \nAC_CACHE_CHECK([whether $CC has an option to link in whole static archives],\n   ncbi_cv_prog_cc_whole_archive,\n   [orig_LDFLAGS=$LDFLAGS\n    ncbi_cv_prog_cc_whole_archive=no\n    for x in -Wl,--whole-archive; do\n       LDFLAGS=\"$orig_LDFLAGS $x `echo $x | sed -e 's/--/--no-/'`\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n          [ncbi_cv_prog_cc_whole_archive=$x])\n       test \"x$ncbi_cv_prog_cc_whole_archive\" = \"xno\"  ||  break\n    done\n    LDFLAGS=$orig_LDFLAGS])\ncase \"$ncbi_cv_prog_cc_whole_archive\" in\n   -Wl,--whole-archive )\n      WHOLE_ARCHIVE=-Wl,--whole-archive\n      NO_WHOLE_ARCHIVE=-Wl,--no-whole-archive\n      ;;\n   no )\n      WHOLE_ARCHIVE=\n      NO_WHOLE_ARCHIVE=\n      ;;\nesac\n       \nif $CXX -v 2>&1 | grep -q clang; then\n   CFLAGS=\"$CFLAGS -Wno-deprecated-register\"\n   CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"\n\n   case \"$host_os:$CXX\" in\n      darwin[[0-9]].*:/usr/bin/* | darwin1[[0-2]].*:/usr/bin/* )\n         ncbi_cv_prog_cxx_stdlib_libcxx=no\n         ;;\n   esac\n\n   AC_CACHE_CHECK([whether $CXX supports -stdlib=libc++],\n      ncbi_cv_prog_cxx_stdlib_libcxx,\n      [orig_CXX=$CXX\n       CXX=\"$orig_CXX -stdlib=libc++\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <stdexcept>],\n             [std::logic_error le(\"Inconceivable!\");])],\n          [ncbi_cv_prog_cxx_stdlib_libcxx=yes],\n          [ncbi_cv_prog_cxx_stdlib_libcxx=no])\n       CXX=$orig_CXX])\n   test \"$ncbi_cv_prog_cxx_stdlib_libcxx\" = no  ||  CXX=\"$CXX -stdlib=libc++\"\nelse\n   ncbi_cv_prog_cxx_stdlib_libcxx=no\nfi\n\nAC_CHECK_DECL([_LIBCPP_VERSION], [], [], [#include <iosfwd>])\n\nAC_CACHE_CHECK([how to enable C++ '11 features in $CXX],\n   ncbi_cv_prog_cxx_11,\n   [orig_CXX=$CXX\n    ncbi_cv_prog_cxx_11=no\n    for x in -std=gnu++11 -std=gnu++0x ''; do\n       CXX=\"$orig_CXX $x\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <memory>],\n          [std::unique_ptr<int> x;])],\n          [ncbi_cv_prog_cxx_11=$x])\n          test \"x$ncbi_cv_prog_cxx_11\" = \"xno\"  ||  break\n       done\n       CXX=$orig_CXX])\nif test \"$ncbi_cv_prog_cxx_11\" = no; then\n   AC_MSG_ERROR([Please upgrade to a compiler supporting C++ '11, such as GCC 4.8 or newer.])\nelse\n   CXX=\"$CXX $ncbi_cv_prog_cxx_11\"\nfi\n\nAC_LANG_PUSH(C)\nAC_CACHE_CHECK([how to enable C '11 or at least '99 features in $CC],\n   ncbi_cv_prog_c_99,\n   [orig_CC=$CC\n    ncbi_cv_prog_c_99=no\n    for x in -xc99=all \"-std=gnu11 -fgnu89-inline\" \\\n             \"-std=gnu1x -fgnu89-inline\" \\\n             \"-std=gnu99 -fgnu89-inline\" \\\n             \"-std=gnu9x -fgnu89-inline\"; do\n       CC=\"$orig_CC $x\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],\n          [ncbi_cv_prog_c_99=$x])\n          test \"x$ncbi_cv_prog_c_99\" = \"xno\"  ||  break\n       done\n       CC=$orig_CC])\n\nif test \"$host_cpu\" != x86_64; then\n   : ${with_sse42=no}\nfi\n\nif test \"${with_sse42-$with_optimization}\" = yes; then\n   orig_CC=$CC\n   AC_CACHE_CHECK([whether $CC supports -msse4.2],\n      ncbi_cv_prog_c_sse42,\n      [orig_CC=$CC\n       CC=\"$CC -msse4.2\"\n       AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM(\n              [#include <smmintrin.h>],\n              [__m128i v;  _mm_cmpgt_epi64(v, v);])],\n          [ncbi_cv_prog_c_sse42=yes],\n          [ncbi_cv_prog_c_sse42=no])])\n   if test $ncbi_cv_prog_c_sse42 = yes; then\n      CC=\"$orig_CC -msse4.2\"\n      orig_CC=$CC\n   elif test \"$with_sse42\" = yes; then\n      AC_MSG_ERROR([SSE 4.2 support explicitly requested but unavailable.])\n   else\n      CC=$orig_CC\n   fi\nfi\nAC_LANG_POP(C)\ntest \"$ncbi_cv_prog_c_99\" = no  ||  CC=\"$CC $ncbi_cv_prog_c_99\"\n\nif test \"${with_sse42-$with_optimization}\" = yes; then\n   orig_CXX=$CXX\n   AC_CACHE_CHECK([whether $CXX supports -msse4.2],\n      ncbi_cv_prog_cxx_sse42,\n      [CXX=\"$CXX -msse4.2\"\n       AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM(\n              [#include <smmintrin.h>],\n              [__m128i v;  _mm_cmpgt_epi64(v, v);])],\n          [ncbi_cv_prog_cxx_sse42=yes],\n          [ncbi_cv_prog_cxx_sse42=no])])\n   if test $ncbi_cv_prog_cxx_sse42 = yes; then\n      CXX=\"$orig_CXX -msse4.2\"\n      orig_CXX=$CXX\n   elif test \"$with_sse42\" = yes; then\n      AC_MSG_ERROR([SSE 4.2 support explicitly requested but unavailable.])\n   else\n      CXX=$orig_CXX\n   fi\nfi\n\ncase \"$host_os:$compiler\" in\n solaris*:GCC )\n   # On Solaris, GCC defaults to setting _XOPEN_SOURCE (to 500) only\n   # in C++ mode.  Set it for C code as well to ensure consistent\n   # header behavior, taking care to match the C standard version\n   # (as enforced by <sys/feature_tests.h>).\n   case \"$ncbi_cv_prog_c_99\" in\n      no) CC=\"$CC -D_XOPEN_SOURCE=500\" ;;\n      *)  CC=\"$CC -D_XOPEN_SOURCE=600\" ;;\n   esac\n   ;;\nesac\n\n\n### large file support (switch to AC_SYS_LARGEFILE?)\ncase \"$host_os:$compiler:$compiler_version\" in\n    cygwin* ) with_lfs=no ;;\n    *:GCC:3[[4-9]]* | *:GCC:[[4-9]]* | *:ICC:[[91]]* ) : ${with_lfs=yes} ;;\nesac\n\nif test \"$with_lfs\" = \"yes\" ; then\n   LFSFLAGS=\"-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\"\n   # Modern BSD-based systems (including Mac OS X) already use a 64-bit\n   # off_t, but don't necessarily provide explicit ...64 variants of all\n   # relevant functions.\n   case \"$host_os\" in\n      *bsd* | darwin* ) ;;\n      * ) LFSFLAGS=\"$LFSFLAGS -D_LARGEFILE64_SOURCE\" ;;\n   esac\n   CPPFLAGS=\"$LFSFLAGS $CPPFLAGS\"\nfi\n\ntabchar='\t'\nwschars=\" $tabchar\"\nwsrx=\"[[$wschars]]\"\n\n#### Flags to enable (potentially unsafe) extra optimization.\nif test \"$skip_fast_flags\" = no -a -z \"$DEF_FAST_FLAGS\" ; then\n   case \"$compiler:$compiler_version\" in\n      GCC:2* | GCC:344 )\n        # GCC 2.9x sometimes experiences internal errors at high optimization;\n        # GCC 3.4.4 (at least on FreeBSD) meanwhile generates crashprone code.\n        DEF_FAST_FLAGS=\"-O2\"\n        ;;\n      GCC:* )\n        DEF_FAST_FLAGS=\"-O3 -finline-functions -fstrict-aliasing\"\n        case \"$host_os:$host_cpu:$compiler_version\" in\n           freebsd* | solaris*:*86*:* | *:4[[5-9]]? | *:[[5-9]]?? ) ;;\n           * ) DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS -ffast-math\" ;;\n        esac\n        if test \"$with_profiling\" != \"yes\"; then\n           # incompatible with -pg\n           DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS -fomit-frame-pointer\"\n        fi\n        ;;\n      WorkShop5[[89]]* | WorkShop510 )\n        # Limit optimization to -xO2 (-O now maps to -xO3) due to compiler bugs.\n        subst=\"s/[$wsrx]-x*O[[1-9]]*//g\"\n        CFLAGS=\"`  echo \\\" $CFLAGS\\\"   | sed -e \\\"$subst\\\"` -xO2\"\n        CXXFLAGS=\"`echo \\\" $CXXFLAGS\\\" | sed -e \\\"$subst\\\"` -xO2\"\n        LDFLAGS=\"` echo \\\" $LDFLAGS\\\"  | sed -e \\\"$subst\\\"` -xO2\"\n        DEF_FAST_FLAGS=\"-xO2\"\n        ;;\n      WorkShop* )\n        DEF_FAST_FLAGS=\"-fast\"\n        case \"$with_ncbi_public:$host_cpu\" in\n           yes:sparc* )\n              DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS -xtarget=ultra\"\n              ;;\n           *:i?86)\n              case \"$compiler_ver\" in\n                *5.[[0-4]]*)\n                  # Work around a WorkShop standard library bug.\n                  DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS -D_RWSTD_NO_TEST_AND_SET\"\n                  ;;\n              esac\n              ;;\n        esac\n        # (Re)include ARCH_CFLAGS here because -fast implies -xtarget=native.\n        DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS $ARCH_CFLAGS\"\n        ;;\n      KCC:* )\n        DEF_FAST_FLAGS=\"+K3\"\n        case \"$host_os\" in\n           solaris* )  DEF_FAST_FLAGS=\"$DEF_FAST_FLAGS -fast $ARCH_CFLAGS\" ;;\n        esac\n        ;;\n      ICC:[[1-8]]?? )\n        DEF_FAST_FLAGS=\"-O2\"\n        ;;\n      ICC:9?? )\n        DEF_FAST_FLAGS=\"-O3 -axP -ip\" # optimized for Core or P4 w/SSE3 (max)\n        ;;\n      ICC:10?? )\n        DEF_FAST_FLAGS=\"-O3 -axT -ip\" # Core 2 w/SSSE3; axS would cover SSE 4.1\n        ;;\n      ICC:* )\n        # Core 2; ICC 11 goes up to SSE4.2 (i7), ICC 12 up to CORE-AVX-I\n        DEF_FAST_FLAGS=\"-O3 -axSSSE3 -ip\"\n        ;;\n      MIPSpro* )\n        # -Ofast would be preferable, but runs into resource limits when\n        # building libxblast.so. :-/\n        DEF_FAST_FLAGS=\"-O2\"\n        ;;\n      Compaq:* )\n        DEF_FAST_FLAGS=\"-fast\"\n        ;;\n      * )\n        DEF_FAST_FLAGS=\"-O\"\n        ;;\n   esac\nfi\n\n: ${FAST_CFLAGS=\"$DEF_FAST_FLAGS\"}\n: ${FAST_CXXFLAGS=\"$DEF_FAST_FLAGS\"}\n: ${FAST_LDFLAGS=\"$DEF_FAST_FLAGS\"}\n\n\n#### DLLs\n\n# Generate position-independent code (PIC)\nif test -z \"$CFLAGS_DLL\"  -a  -z \"$CXXFLAGS_DLL\" ; then\n   case \"$host_os:$compiler\" in\n    darwin*:GCC )\n      CFLAGS_DLL=\"-fno-common\"\n      CXXFLAGS_DLL=\"-fno-common\"\n      ;;\n    *:GCC | linux* )\n      CFLAGS_DLL=\"-fPIC\"\n      CXXFLAGS_DLL=\"-fPIC\"\n      ;;\n    solaris*:WorkShop* | irix*:MIPSpro73 | \\\n    solaris*:KCC | irix*:KCC )\n      CFLAGS_DLL=\"-KPIC\"\n      CXXFLAGS_DLL=\"-KPIC\"\n      ;;\n   esac\nfi\n\n# Flag for setting the runtime library search path\nif test -z \"$CONF_f_runpath\" ; then\n   case \"$host_os:$compiler\" in\n    solaris* )\n      CONF_f_runpath=\"-R\"\n      ;;\n    linux*:[[GI]]CC | *bsd*:GCC | cygwin*:GCC | osf*:GCC )\n      CONF_f_runpath=\"-Wl,-rpath,\"\n      ;;\n    irix*:* | linux*:KCC | *:Compaq )\n      CONF_f_runpath=\"-rpath \"\n      ;;\n    darwin* )\n      test \"$ncbi_cv_prog_cc_wl_rpath\" = no  ||  CONF_f_runpath=\"-Wl,-rpath,\"\n      ;;\n   esac\nfi\ncase \"$host_os:$ncbi_cv_prog_cc_wl_rpath\" in\n    linux*|solaris* )\n        origin=\"'\\$\\$ORIGIN'\"\n        RUNPATH_ORIGIN=\"$CONF_f_runpath$origin\"\n        ;;\n    darwin*:yes )\n        origin='@executable_path'\n        RUNPATH_ORIGIN=\"$CONF_f_runpath$origin\"\n        ;;\n    * )\n        origin=\n        RUNPATH_ORIGIN=\"-DNCBI_RPO_SUFFIX_EATER=\"\n        ;;\nesac\n\nAC_PATH_PROG(DPKG_ARCHITECTURE, dpkg-architecture)\nif test -x \"$DPKG_ARCHITECTURE\" \\\n    &&  $DPKG_ARCHITECTURE -qDEB_HOST_MULTIARCH >/dev/null 2>&1; then\n   multiarch=`$DPKG_ARCHITECTURE -qDEB_HOST_MULTIARCH`\nelse\n   multiarch=`echo $host | sed -e 's/-unknown-/-/; [s/^i[3-9]86-/^i\\[3-9\\]86/]'`\nfi\n\ncase \"$compiler:$compiler_version:$with_bin_release:$ncbi_cv_prog_cxx_stdlib_libcxx\" in\n  GCC:*:yes:no )\n    libstdcxx=`$CXX $LDFLAGS -print-file-name=libstdc++.a`\n    case \"$libstdcxx\" in\n       /*)\n          LIBS=\"$libstdcxx $LIBS\"\n          LINK=$C_LINK\n          ;;\n       *)\n          AC_MSG_ERROR([Unable to find static libstdc++ requested by --with-bin-release.])\n          ;;\n    esac\n    ;;\n  GCC:* )\n    # Need to specify runpath for compiler-provided libraries\n    case $compiler_version in\n        30*     ) major=3 ;;\n        31*     ) major=4 ;;\n        3[[23]]*) major=5 ;;\n        *       ) major=6 ;;\n    esac\n    found=false\n    for f in libstdc++.so.$major libgcc_s.so.1 libstdc++.a; do\n        path=`$CXX $LDFLAGS -print-file-name=$f`\n        dir=`dirname \"$path\"`\n        abs_dir=`cd \"$dir\" && pwd`\n        case \"$dir:$abs_dir\" in\n            *:/lib | *:/usr/lib | *:/usr/lib32 | *:/usr/lib64 \\\n            | *:/usr/lib/$multiarch )\n               # no rpath needed\n               break\n               ;;\n            /* )\n               found=true\n               break\n               ;;\n        esac\n    done\n    if test \"$found\" = \"true\" -a -n \"$CONF_f_runpath\"; then\n        LDFLAGS=\"$CONF_f_runpath$dir $LDFLAGS\"\n        case \"$host_os\" in\n           osf*)\n              # the linker doesn't merge -rpath flags...\n              CONF_f_runpath=\"$CONF_f_runpath$dir:\"\n              ;;\n           solaris*)\n              # avoid interference from possible older versions in /usr/sfw.\n              LDFLAGS=\"-L$dir $LDFLAGS\"\n              ;;\n        esac\n    fi\n    ;;\n  ICC:6* )\n    # Seems to use libcxa.so.1 even without -i_dynamic...\n    LDFLAGS=\"$CONF_f_runpath$compiler_root/lib $LDFLAGS\"\n    ;;\n  ICC:7* )\n    # Favor the static version, as libcxa.so.3 isn't exactly common....\n    # (Undocumented, and unavailable at all in older versions. :-/)\n    LDFLAGS=\"-static-libcxa $LDFLAGS\"\n    ;;\n  ICC:8* )\n    # In principle, these settings should work, and avoid the need to\n    # depend on Intel's libraries at runtime.\n    #  APP_LDFLAGS=\"-static-libcxa $APP_LDFLAGS\"\n    #  DLL_LDFLAGS=\"-nodefaultlibs $DLL_LDFLAGS\"\n    # In practice, they can break applications that use plugins. :-/\n    LDFLAGS=\"$CONF_f_runpath$compiler_root/lib $LDFLAGS\"\n    ;;\n  ICC:9* )\n    # -i-static moved from common LDFLAGS to accommodate those few\n    # DLLs (plugins for external programs such as Python) that need to\n    # link ICC's libraries dynamically.\n    APP_LDFLAGS=\"-i-static $APP_LDFLAGS\"\n    DLL_LDFLAGS=\"-i-static -nodefaultlibs $DLL_LDFLAGS\"\n    # Running icpc on a bunch of object files doesn't always ensure that\n    # the C++ standard library is actually linked in, and we shouldn't\n    # rely on help from wrapper scripts.\n    LINK=\"$LINK -Kc++\"\n    ;;\n  ICC:1???:* )\n    case \"$host_cpu\" in\n       i?86   ) intel_cpu_name=ia32      ;;\n       x86_64 ) intel_cpu_name=intel64   ;;\n       *      ) intel_cpu_name=$host_cpu ;;\n    esac\n    LDFLAGS=\"$CONF_f_runpath$compiler_root/lib/$intel_cpu_name $LDFLAGS\"\n    # Suppress \"warning #10237: -lcilkrts linked in dynamically, static\n    # library not available\" which is not a problem in practice due to\n    # as-needed linkage.\n    APP_LDFLAGS=\"-static-intel -diag-disable 10237 $APP_LDFLAGS\"\n    DLL_LDFLAGS=\"-static-intel -diag-disable 10237 -nodefaultlibs $DLL_LDFLAGS\"\n    # Redundant for apps, but necessary for plugins to be adequately\n    # self-contained, at least on 32-bit Linux.\n    if test \"$with_bin_release\" = \"yes\"; then\n       LDFLAGS=\"$LDFLAGS -static-libstdc++\"\n    elif test \"$with_dll\" != \"no\"; then\n       LIBS=\"$LIBS -lstdc++ -lgcc_s\"\n    fi\n    LINK=\"$LINK -Kc++\"\n    # Defining _GCC_NEXT_LIMITS_H ensures that <limits.h> chaining doesn't\n    # stop short, as can otherwise happen. :-/\n    CPPFLAGS=\"$CPPFLAGS -D_GCC_NEXT_LIMITS_H\"\n    ;;\nesac\n\n# DLLs and profiling don't mix on all platforms\nif test \"$with_profiling\" = \"yes\" ; then\n   case \"$host_os\" in\n      linux*) # any others?\n         case \"$with_dll\" in\n            yes) AC_MSG_ERROR([This platform does not support DLL profiling.])\n                 ;;\n            no) ;;\n            *) with_dll=no ;;\n         esac\n      ;;\n   esac\nfi\n\n# Whether to build DLLs or static (and whether by default, or forcibly)\nLIB_OR_DLL=\"lib\"\nif test \"$with_dll\" = \"yes\" ; then\n   case \"$host_os:$compiler\" in\n    linux*:GCC | irix*:* | solaris*:WorkShop* | *:KCC | linux*:ICC \\\n    | solaris*:GCC | osf*:* | darwin*:GCC | freebsd*:GCC )\n      ;;\n    * )\n      echo\n      echo \"DLLs may not be buildable by $CXX $compiler_ver on $host!\"\n      NCBI_CAUTION([Do you still want to try build DLLs (at your own risk)?])\n      echo\n      ;;\n   esac\nfi\n\ncase \"$with_dll:$with_static\" in\n   yes:yes) LIB_OR_DLL=\"both\"; dll_sfx=\"DLL+static\" ;;\n   yes:*)   LIB_OR_DLL=\"dll\";  dll_sfx=\"DLL\" ;;\n   *:no)    AC_MSG_ERROR([--without-static requires --with-dll]) ;;\n   *)       LIB_OR_DLL=\"lib\";  dll_sfx=\"\"  ;;\nesac\n\nDLL=\nDLL_LIB_SETTING='$(DLL_DLIB)'\nIF_WITH_DLL=\nUNLESS_WITH_DLL='# '\nSTATIC=\"-static\"\nUSUAL_AND_DLL=both\nUSUAL_AND_LIB=both\n\ncase \"$LIB_OR_DLL\" in\n   dll)\n       STATIC=\n       USUAL_AND_DLL=dll\n       ;;\n   lib)\n       DLL=-dll\n       DLL_LIB_SETTING='$(DLL_LIB)'\n       IF_WITH_DLL='# '\n       UNLESS_WITH_DLL=\n       USUAL_AND_LIB=lib\n       ;;\nesac\n\nAC_SUBST(DLL)\nAC_SUBST(DLL_LIB_SETTING)\nAC_SUBST(IF_WITH_DLL)\nAC_SUBST(UNLESS_WITH_DLL)\nAC_SUBST(STATIC)\nAC_SUBST(USUAL_AND_DLL)\nAC_SUBST(USUAL_AND_LIB)\n\n\n#### GNU compiler::  common flags and definitions\nif test \"$compiler\" = \"GCC\" ; then\n   CFLAGS=\"-Wall -Wno-format-y2k $CFLAGS\"\n   CXXFLAGS=\"-Wall -Wno-format-y2k $CXXFLAGS\"\n   case \"$compiler_version\" in\n      2* ) CXXFLAGS=\"-ftemplate-depth-32 $CXXFLAGS\" ;;\n   esac\n   case \"$host_os\" in\n      solaris* )  CPPFLAGS=\"-D__EXTENSIONS__ $CPPFLAGS\" ;;\n      irix*    )  CXXFLAGS=\"$CXXFLAGS -D_LANGUAGE_C_PLUS_PLUS\" ;;\n   esac\n   # orig_CFLAGS=$CFLAGS\n   # orig_CXXFLAGS=$CXXFLAGS\n   # flag=-fno-merge-debug-strs\n   # CFLAGS=\"$flag $CFLAGS\"\n   # CXXFLAGS=\"$flag $CXXFLAGS\"\n   # AC_CACHE_CHECK([whether GCC supports $flag], ncbi_cv_prog_gcc_nomerge,\n   #    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[return 0;]])],\n   #                       ncbi_cv_prog_gcc_nomerge=yes,\n   #                       ncbi_cv_prog_gcc_nomerge=no)])\n   # if test \"$ncbi_cv_prog_gcc_nomerge\" = no; then\n   #    CFLAGS=$orig_CFLAGS\n   #    CXXFLAGS=$orig_CXXFLAGS\n   # fi\nfi\n\n\n#### KAI compiler::  common flags and definitions\nif test \"$compiler\" = \"KCC\" ; then\n   AR=${AR:=\"$CXX $MT_FLAG -o\"}\n   CFLAGS=\"--display_error_number --c $CFLAGS\"\n   CXXFLAGS=\"--display_error_number --one_instantiation_per_object $CXXFLAGS\"\n   case \"$host_os\" in\n      solaris* )  CPPFLAGS=\"-D__EXTENSIONS__ -D__STDC__=0 $CPPFLAGS\" ;;\n   esac\nfi\n\n\n#### Intel compiler::  common flags and definitions\nif test \"$compiler\" = \"ICC\" ; then\n   if test -n \"$icc_license\" ; then\n      icc_CC=\"$CC\"\n      icc_CXX=\"$CXX\"\n      CC=\"./compilers/unix/cxx_filter.ICC.sh $CC\"\n      CXX=\"./compilers/unix/cxx_filter.ICC.sh $CXX\"\n   fi\nfi\n\n\n#### How to ensure that the compiler will account for potential aliasing\ncase \"$compiler\" in\n   GCC ) NO_STRICT_ALIASING=-fno-strict-aliasing ;;\n   ICC ) NO_STRICT_ALIASING='-falias -ffnalias' ;;\n   WorkShop* ) NO_STRICT_ALIASING='-xalias_level=any' ;;\n   * ) NO_STRICT_ALIASING=\nesac\n\ndnl Autoconf 2.62+ has an AC_PATH_PROGS_FEATURE_CHECK macro that could\ndnl also be useful, but we're still on 2.60.\nAX_CHECK_GNU_MAKE\nAC_PATH_PROG(MAKE, ${ax_cv_gnu_make_command-make})\nexport MAKE\n\n#### Automatic generation of dependencies for/by the \"make\" utility\ncase \"$host_os\" in\n   solaris* )  KeepStateTarget=\".KEEP_STATE:\" ;;\nesac\n\nif test \"$with_autodep\" = \"yes\" ; then\n   Rules=\"rules_with_autodep\"\nelif test \"$with_autodep\" = \"no\" ; then\n   Rules=\"rules\"\nelif $MAKE --version 2>/dev/null | grep 'GNU Make' >/dev/null ; then\n   Rules=\"rules_with_autodep\"\nelse\n   Rules=\"rules\"\nfi\n\n\n### Support for precompiled headers\nGCCPCH=\"#\"\nif test \"$compiler\" = GCC -a \"$with_pch\" = \"yes\"; then\n   AC_CACHE_CHECK([whether $CXX supports precompiled headers], ncbi_cv_cxx_pch,\n      [echo '#include <iostream>' > conftest.hpp\n       echo $CXX $CPPFLAGS $CXXFLAGS -xc++-header -c conftest.hpp >&AS_MESSAGE_LOG_FD\n       if $CXX $CPPFLAGS $CXXFLAGS -xc++-header -c conftest.hpp >&AS_MESSAGE_LOG_FD 2>&1 \\\n         &&  test -f conftest.hpp.gch; then\n          ncbi_cv_cxx_pch=yes\n       else\n          ncbi_cv_cxx_pch=no\n       fi])\n   if test \"$ncbi_cv_cxx_pch\" = \"yes\"; then\n      if test \"$Rules\" = \"rules\"; then\n         AC_MSG_WARN([Your version of make does not fully support PCH-related dependencies.])\n      fi\n      CXXFLAGS=\"-DNCBI_USE_PCH $CXXFLAGS\"\n      GCCPCH=\"\"\n   fi\nfi\n\n\n#### Tools\nAC_PROG_LN_S\ncase \"$LN_S\" in\n    /*) ;;\n    * ) LN_S=/bin/$LN_S ;;\nesac\n\nAC_PROG_RANLIB\nAC_CHECK_PROG(AR, ar, ar cr, ErrorCannotFind_AR)\nif test \"x$RANLIB\" != \"x:\"; then\n   AC_CACHE_CHECK([ranlib's effectiveness], ncbi_cv_prog_ranlib_effect,\n      [AC_LANG_CONFTEST([AC_LANG_SOURCE([[int libfunc(void) { return 0; }]])])\n       echo $CXX $CPPFLAGS $CXXFLAGS -c conftest.$ac_ext >&AS_MESSAGE_LOG_FD\n       $CXX $CPPFLAGS $CXXFLAGS -c conftest.$ac_ext >&AS_MESSAGE_LOG_FD 2>&1\n       echo $AR conftest.a conftest.o >&AS_MESSAGE_LOG_FD\n       $AR conftest.a conftest.o >&AS_MESSAGE_LOG_FD 2>&1\n       save_LIBS=$LIBS\n       LIBS=\"conftest.a $LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([[extern int libfunc(void);]],\n                                       [[return libfunc();]])],\n                      [ok_without=true], [ok_without=false])\n       echo $RANLIB conftest.a >&AS_MESSAGE_LOG_FD\n       $RANLIB conftest.a >&AS_MESSAGE_LOG_FD\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([[extern int libfunc(void);]],\n                                       [[return libfunc();]])],\n                      [ok_with=true], [ok_with=false])\n       LIBS=$save_LIBS\n       case $ok_with:$ok_without in\n          true:false)  ncbi_cv_prog_ranlib_effect=positive ;;\n          false:true)  ncbi_cv_prog_ranlib_effect=negative ;;\n          true:true)   ncbi_cv_prog_ranlib_effect=neutral  ;;\n          false:false) ncbi_cv_prog_ranlib_effect=unknown  ;;\n       esac\n      ])\n   case \"$ncbi_cv_prog_ranlib_effect\" in\n      negative) RANLIB=: ;;\n      unknown)\n        AC_MSG_WARN([Failed to make a working library with or without ranlib.])\n        ;;\n   esac\nfi\nif test \"$with_strip\" = yes; then\n   AC_CHECK_PROG(STRIP, strip, strip, @:)\n   AC_CACHE_CHECK([whether strip loses runtime type information],\n      ncbi_cv_strip_loses_rtti,\n      [if test \"$cross_compiling\" = yes; then\n          case \"$host_os\" in\n             darwin* ) ncbi_cv_strip_loses_rtti=yes ;;\n             # No problems observed elsewhere so far.\n             *       ) ncbi_cv_strip_loses_rtti=no  ;;\n          esac\n       else\n          AC_LANG_CONFTEST([AC_LANG_PROGRAM(\n                               [[#include <iostream>\n                                 #include <typeinfo>\n                                 struct SomeStruct { };]],\n                               [[std::cout << typeid(SomeStruct).name();]])])\n          echo $CXX $CPPFLAGS $CXXFLAGS $LDFLAGS -o conftest$ac_exeext \\\n             conftest.$ac_ext >&AS_MESSAGE_LOG_FD\n          $CXX $CPPFLAGS $CXXFLAGS $LDFLAGS -o conftest$ac_exeext \\\n             conftest.$ac_ext >&AS_MESSAGE_LOG_FD 2>&1\n          $STRIP conftest$ac_exeext\n          if (ulimit -c 0; ./conftest$ac_exeext) >/dev/null 2>&1; then\n             ncbi_cv_strip_loses_rtti=no\n          else\n             ncbi_cv_strip_loses_rtti=yes\n          fi\n          rm -rf conftest*\n       fi])\n   if test \"$ncbi_cv_strip_loses_rtti\" = \"yes\"; then\n      NCBI_CAUTION([Do you still want to proceed (at your own risk)?])\n   fi\nelse\n   STRIP=@:\nfi\n\n\n# When using ccache and distcc together, ccache needs to be primary,\n# so look for distcc(.sh) first.\n\nif test -x $orig_NCBI/bin/distcc.sh ; then\n   : ${DISTCC=$orig_NCBI/bin/distcc.sh}\n   : ${with_distcc=yes}\nfi\n\nif test \"$with_distcc\" = \"yes\" ; then\n   AC_PATH_PROG(DISTCC, distcc, distcc, [])\n   if test -n \"$DISTCC\" ; then\n      # Test distcc reasonably thoroughly to avoid possible gotchas.\n      cat > distcctest.c << EOF\n#include <stddef.h>\n#if !defined(__GNUC__)  &&  !defined(offsetof)\n#  define offsetof(T, F) ((size_t)((char*) &(((T*) 0)->F) - (char*) 0))\n#endif\nstruct S { int x; };\nint f() { return offsetof(struct S, x); }\nEOF\n      DISTCC_FALLBACK=0\n      export DISTCC_FALLBACK\n      AC_CACHE_CHECK([whether any distcc servers are available],\n         ncbi_cv_prog_distcc_servers,\n         [$DISTCC $CC -c distcctest.c 2>&AS_MESSAGE_LOG_FD\n          case $? in\n            # 102: bind failed\n            # 103: connect failed\n            # 106: bad hostspec\n            # 107: I/O error\n            # 109: protocol error\n            # 113: access denied\n            # 116: no hosts defined\n            102 | 103 | 106 | 107 | 109 | 113 | 116 )\n             ncbi_cv_prog_distcc_servers=no ;;\n            * )\n             ncbi_cv_prog_distcc_servers=yes ;;\n          esac])\n      if test \"$ncbi_cv_prog_distcc_servers\" = no; then\n         AS_UNSET(DISTCC)\n      fi\n      if test -n \"$DISTCC\" ; then\n         AC_CACHE_CHECK([whether $DISTCC is compatible with $CC],\n            ncbi_cv_prog_distcc_vs_cc,\n            [if $DISTCC $CC -c distcctest.c 2>&AS_MESSAGE_LOG_FD ; then\n                ncbi_cv_prog_distcc_vs_cc=yes\n             else\n                ncbi_cv_prog_distcc_vs_cc=no\n             fi])\n         if test \"$ncbi_cv_prog_distcc_vs_cc\" = yes; then\n            CC_WRAPPER=\"$DISTCC $CC_WRAPPER\"\n         else\n            AS_UNSET(DISTCC)\n         fi\n      fi\n      if test -n \"$DISTCC\" ; then\n         AC_CACHE_CHECK([whether $DISTCC is compatible with $CXX],\n            ncbi_cv_prog_distcc_vs_cxx,\n            [mv distcctest.c distcctest.cpp\n             if $DISTCC $CXX -c distcctest.cpp 2>&AS_MESSAGE_LOG_FD ; then\n                ncbi_cv_prog_distcc_vs_cxx=yes\n             else\n                ncbi_cv_prog_distcc_vs_cxx=no\n             fi])\n         if test \"$ncbi_cv_prog_distcc_vs_cxx\" = yes; then\n            CXX_WRAPPER=\"$DISTCC $CXX_WRAPPER\"\n         else\n            AS_UNSET(DISTCC)\n         fi\n      fi\n      rm -f distcctest.*\n   elif test \"$with_distcc\" = \"yes\" ; then\n      AC_MSG_WARN([distcc explicitly requested, but not found in PATH.])\n   fi\n   AS_UNSET(DISTCC_FALLBACK)\nfi\n\nif test -z \"$with_ccache\"  -a  -n \"$DISTCC\"  -a  -z \"$CCACHE_DIR\" ; then\n   # Using CCACHE together with DISTCC causes problems when the involved DISTCC\n   # servers share the same home dir, as in that case the caches from\n   # different servers can mix up rather badly, corrupting each other.\n   # On the other hand, most NCBI accounts have $CCACHE_DIR automatically set\n   # to a non-shared, per-machine location (such as \"/tmp/.ccache-username\").\n   with_ccache=\"no\"\nfi\n\nif test \"$with_ccache\" != \"no\"; then\n   AC_PATH_PROG(CCACHE, ccache)\n   if test -n \"$CCACHE\" ; then\n      if test -n \"$CC_WRAPPER\"; then\n         CC_WRAPPER=\"CCACHE_PREFIX=$CC_WRAPPER $CCACHE\"\n      else\n         CC_WRAPPER=$CCACHE\n      fi\n      if test -n \"$CXX_WRAPPER\"; then\n         CXX_WRAPPER=\"CCACHE_PREFIX=$CXX_WRAPPER $CCACHE\"\n      else\n         CXX_WRAPPER=$CCACHE\n      fi\n   elif test \"$with_ccache\" = \"yes\"; then\n      AC_MSG_WARN([ccache explicitly requested, but not found in PATH.])\n   fi\nfi\n\n# Note the path, since syntax is version-specific....\nAC_PATH_PROG(TAIL, tail)\nAC_MSG_CHECKING([whether $TAIL accepts modern syntax (-n N)])\nif $TAIL -n 1 config.log >/dev/null 2>&1; then\n   TAIL_N=\"$TAIL -n \"\n   AC_MSG_RESULT(yes)\nelse\n   TAIL_N=\"$TAIL -\"\n   AC_MSG_RESULT(no)\nfi\n\nAC_PATH_PROG(BASENAME, basename)\nAC_PATH_PROG(SED, sed)\nAC_PATH_PROG(TOUCH, touch, [], /bin:/usr/bin:$PATH)\ndnl AC_PATH_PROG(GREP, grep)\nAC_PROG_EGREP\nAC_MSG_CHECKING([how to run $EGREP quietly])\nif test -z \"`echo foo | $EGREP -q fo+ 2>>config.log || echo $?`\"; then\n   EGREP_Q=\"$EGREP -q\"\nelif test -z \"`echo foo | $EGREP -s fo+ 2>>config.log || echo $?`\"; then\n   EGREP_Q=\"$EGREP -s\"\nelse\n   EGREP_Q=\">/dev/null $EGREP\"\nfi\nAC_MSG_RESULT($EGREP_Q)\n\nAC_CHECK_PROG(VALGRIND_PATH, valgrind, valgrind)\n\nAC_PATH_PROG(LDD, ldd, [], /bin:/usr/bin:$PATH)\nif test -n \"$LDD\"; then\n   AC_MSG_CHECKING([whether $LDD accepts -r])\n   if $LDD -r /bin/ls >/dev/null 2>&1; then\n      AC_MSG_RESULT(yes)\n      LDD_R=\"$LDD -r\"\n   else\n      AC_MSG_RESULT(no)\n   fi\nfi\n\nAC_PATH_PROG(UUIDGEN, uuidgen)\nAC_PATH_PROG(CD_REPORTER, cd_reporter, [], [/am/ncbiapdata/bin:$PATH])\n\n#### Check if \"${build_root}\" is defined;  provide a default one\nif test -n \"${with_build_root}\" ; then\n   build_root=${with_build_root}\nfi\n\nsignature_compiler=$compiler\nsignature_compiler_version=$compiler_version\nif test \"$compiler\" = \"GCC\"; then\n   llvm_version=`$CXX -v 2>&1 | $EGREP 'clang|LLVM'`\n   case \"$llvm_version\" in\n      *clang* )\n         # Take the LLVM version from both \"clang version X.Y (...) ...\" and\n         # \"$Vendor (LLVM|clang) version ... (...) (based on LLVM X.Y)\"\n         sed='s/.*[[Mn]] \\([[1-9]][[0-9.]]*\\).*/\\1/; s/\\.//g; s/^..$/&0/'\n         signature_compiler=Clang\n         signature_compiler_version=`echo $llvm_version | sed -e \"$sed\"`\n         ;;\n      *LLVM* )\n         signature_compiler=LLVMGCC\n         ;;\n   esac\nfi\n\n### Possibly add the version to the build directory name, but preseve\n### the original default when reconfiguring.\nif test -z \"${with_version}\" -a -n \"${ac_cv_header_stdc}\"; then\n   with_version=${ncbi_cv_with_version:-no}\nfi\nif test -z \"${build_root}\" ; then\n   build_root=\"${srcdir}/${signature_compiler}\"\n   case \"$signature_compiler:$with_version\" in\n      *[[0-9]]:* | *:no) ;;\n      *) build_root=${build_root}${signature_compiler_version} ;;\n   esac\n   ncbi_cv_with_version=${with_version:-yes}\nelse\n   : ${with_suffix:=\"no\"}\nfi\n\n\n#### Release/Debug\ncase \"${with_debug}:${with_optimization}\" in\n   no:*)\n      release_debug=Release\n      DEBUG_SFX=Release\n      D_SFX=\n      ;;\n   yes:yes | :yes)\n      release_debug=DebugOpt\n      DEBUG_SFX=Debug\n      D_SFX=d\n      ;;\n   *)\n      release_debug=Debug\n      DEBUG_SFX=Debug\n      D_SFX=d\n      ;;\nesac\n\n\n#### Profiling; try to turn on both function weight and basic-block counting\nif test \"$with_profiling\" = \"yes\" ; then\n   prof_sfx=\"Prof\"\n   case \"$compiler\" in\n      Compaq)    PFFLAGS=\"-pg\" ;;\n      GCC)       PFFLAGS=\"-pg\" ;;\n      ICC)       PFFLAGS=\"-p\" ;;\n      KCC)       PFFLAGS=\"-pg\" ;;\n      MIPSpro73) PFFLAGS=\"\" ;; # pixie(1) adds info at runtime\n      MSVC)      PFFLAGS=\"/PROFILE\" ;;\n      VisualAge) PFFLAGS=\"-pg\" ;;\n      WorkShop*) PFFLAGS=\"-pg -xprofile=tcov\" ;;\n      *)         PFFLAGS=\"-p\" ;; # Fairly standard; shouldn't rely on -pg\n   esac\n   CFLAGS=\"$CFLAGS $PFFLAGS\"\n   CXXFLAGS=\"$CXXFLAGS $PFFLAGS\"\n   LDFLAGS=\"$LDFLAGS $PFFLAGS\"\n   STRIP=\"@:\" # Stripping may lose profiling info\nelse\n   prof_sfx=\nfi\n\n\n#### Code coverage\nif test \"$with_code_coverage\" = \"yes\"; then\n   case \"$compiler\" in\n      GCC ) # including Clang\n         COVFLAGS=\"--coverage\"\n         ;;\n      * )\n         AC_MSG_ERROR([--with-code-coverage not implemented for $compiler])\n         ;;\n   esac\n   CFLAGS=\"$CFLAGS $COVFLAGS\"\n   CXXFLAGS=\"$CXXFLAGS $COVFLAGS\"\n   LDFLAGS=\"$LDFLAGS $COVFLAGS\"\nfi\n\n\n#### Determine whether this is implicitly a 64-bit platform\nAC_TYPE_SIZE_T\nAC_CHECK_SIZEOF(size_t)\nac_cv_sizeof_size_t=`echo \"$ac_cv_sizeof_size_t\" | tr -d '\\r'`\nNCBI_PLATFORM_BITS=`expr 8 \\* $ac_cv_sizeof_size_t`\nAC_DEFINE_UNQUOTED(NCBI_PLATFORM_BITS, $NCBI_PLATFORM_BITS,\n                   [Define to the architecture size.])\nif test $NCBI_PLATFORM_BITS -eq 64; then\n   bit64_sfx=64\nfi\n\nif test \"$bit64_sfx\" = 64 -o \"$with_lfs\" = \"yes\"; then\n   NCBI_FEATURE(LFS)\nfi\n\n\n### Intel Thread Checker\nif test \"${with_tcheck=no}\" != \"no\" ; then\n   if test \"${release_debug}${mt_sfx}\" != \"DebugMT\" ; then\n      AC_MSG_WARN([--with-tcheck is most likely to be effective in DebugMT builds.])\n   fi\n   if test \"$compiler\" = \"ICC\"; then\n      case \"$bit64_sfx\" in\n        64) tcbin=bin/32e ;;\n        * ) tcbin=bin/32  ;;\n      esac\n      if test \"$with_tcheck\" != yes; then\n         TCHECK_BIN=$with_tcheck/$tcbin\n      fi\n      AC_PATH_PROG(TCHECK_CL, tcheck_cl, [], $TCHECK_BIN:$PATH:$TCHECK_FALLBACK)\n      if test -n \"$TCHECK_CL\"; then\n         CFLAGS=\"$CFLAGS -tcheck -O0\"\n         CXXFLAGS=\"$CXXFLAGS -tcheck -O0\"\n         LDFLAGS=\"$LDFLAGS -tcheck -O0 -L`dirname $TCHECK_CL`\"\n      fi\n   fi\n   CPPFLAGS=\"$CPPFLAGS -DNCBI_TCHECK\"\nfi\n\n\n#### Add \"Release\"/\"Debug\", \"MT\", \"DLL\", \"64\", \"_p\" suffixes to \"${build_root}\"\nif test \"$with_suffix\" != \"no\" ; then\n   build_root=\"${build_root}-${release_debug}${mt_sfx}${dll_sfx}${bit64_sfx}${prof_sfx}\"\nfi\n\n\n#### Add full host specs to \"${build_root}\"\nif test \"$with_hostspec\" = \"yes\" ; then\n   build_root=\"${build_root}--${host}\"\nfi\n\nif test -n \"$with_build_root_sfx\" ; then\n   build_root=$build_root$with_build_root_sfx\nfi\n\ncase \"$host_os\" in\n   linux*)\n      kver=`uname -r | sed -e 's/-.*//'`\n      libcver=`ldd --version | awk 'NR == 1 { print $NF }'`\n      verbose_host=$host_cpu-$host_vendor-linux$kver-gnu$libcver\n      ;;\n   *) verbose_host=$host ;;\nesac\n\n#### Overall configuration mode summary\nsignature_hostname=`(hostname || uname -n) 2>/dev/null \\\n    | sed 's/\\..*//; s/-/_/g; 1q'`\nsignature=\"${signature_compiler}_${signature_compiler_version}-${release_debug}${mt_sfx}${dll_sfx}${bit64_sfx}${prof_sfx}--${verbose_host}-${signature_hostname}\"\nAC_DEFINE_UNQUOTED(NCBI_SIGNATURE, \"$signature\",\n   [Build signature: compiler-name '_' compiler-version '-' configuration\n   '--' platform-name '-' hostname])\n\n\n#### Check if there is \"${build_root}\" dir\ntest -d \"${build_root}\"  ||  mkdir -p \"${build_root}\"\ntest -d \"${build_root}\"  ||  AC_MSG_ERROR([Couldn't create ${build_root}])\n\n#### Try to find a version of pwd that yields /net paths.\nAC_PATH_PROG(AMQ, amq, [], $PATH:/usr/sbin:/sbin)\ncase \"$AMQ\" in\n   */amq)\n      AC_CACHE_CHECK([whether $AMQ -w works], ncbi_cv_prog_amq_w,\n      [if $AMQ -w >/dev/null 2>&1; then\n          ncbi_cv_prog_amq_w=yes\n       else\n          ncbi_cv_prog_amq_w=no\n       fi])\n      if test \"$ncbi_cv_prog_amq_w\" = yes; then\n         smart_pwd=\"$AMQ -w\"\n      else\n         smart_pwd=pwd\n      fi\n      ;;\n   *)\n      smart_pwd=pwd\n      ;;\nesac\n\n#### Make \"build_root\" absolute\ncase \"${build_root}\" in\n   /* ) ;;\n   . )\n      CDPATH=\n      if test \"${PWD}\" != \"\" && test \"`(cd ${PWD} ; sh -c pwd)`\" = \"`pwd`\"  ;\n      then\n         build_root=\"$PWD\"\n      else\n         NCBI_FIX_DIR(build_root)\n      fi\n   ;;\n   *  ) NCBI_FIX_DIR(build_root) ;;\nesac\nif test -n \"$with_fake_root\"; then\n   build_root=$with_fake_root/`basename $build_root`\nfi\n\n\n#### Set runpath (may depend on build root)\nif test -n \"$with_relative_runpath\"; then\n   if test \"$with_runpath\" = \"no\"; then\n      AC_MSG_ERROR([incompatible options: --without-runpath and --with-relative-runpath=$with_relative_runpath])\n   elif test -z \"$origin\"; then\n      AC_MSG_ERROR([Do not know how to specify relative runpaths on $host])\n   else\n      rp=`echo \"$origin/$with_relative_runpath\" | \\\n          sed \"s,:,:$origin/,g; s,/.:,:,g; s,/.\\$,,\"`\n      with_runpath=\"$rp${with_runpath+:$with_runpath}\"\n   fi\nfi\n\nif test -z \"$with_runpath\"; then\n   # Don't allow libdir values containing variable expansions,\n   # including in particular the default \"${exec_prefix}/lib\"\n   if test -n \"$libdir\"  &&  expr \"$libdir\" : '[[^$]]*$' >/dev/null; then\n      with_runpath=$libdir\n   elif test -n \"$exec_prefix\"  -a  \"$exec_prefix\" != \"NONE\" ; then\n      with_runpath=$exec_prefix/lib\n   elif test -n \"$prefix\"  -a  \"$prefix\" != \"NONE\" ; then\n      with_runpath=$prefix/lib\n   fi\nfi\n\nif   test \"$with_runpath\" = \"no\" ; then\n   runpath=\n   pure_runpath=\nelif test -n \"$with_runpath\"  -a  \"$with_runpath\" != \"yes\" ; then\n   root_base=`basename $build_root`\n   pure_runpath=`echo \"${with_runpath}\" | sed -e \"s/{}/$root_base/g\"`\n   runpath=\"${CONF_f_runpath}${pure_runpath}\"\n   case \"$host_os:$compiler\" in\n    darwin* )\n      # Needed for a few gui projects, including gbench_plugin_scan;\n      # harmless elsewhere, since it only affects projects that indirectly\n      # need one of these libraries.  (There seems to be no general\n      # equivalent of -rpath-link.)\n      for l in dbapi_driver gui_utils ncbi_xloader_genbank ncbi_xreader \\\n               ncbi_xreader_id1 ncbi_xreader_pubseqos; do\n         ll=lib$l.dylib\n         LDFLAGS=\"$LDFLAGS -dylib_file ${pure_runpath}/$ll:\\$(libdir)/$ll\"\n      done\n      ;;\n    *:GCC )\n      if `$CXX -print-prog-name=ld` --version 2>&1 | grep GNU >/dev/null; then\n         runpath=\"$runpath -Wl,-rpath-link,\\$(libdir)\"\n      fi\n      ;;\n    *:ICC )\n      runpath=\"$runpath -Wl,-rpath-link,\\$(libdir)\"\n      ;;\n   esac\nelif test \"$with_runpath\" = \"yes\"  -o  \"$with_dll\" != \"no\" ; then\n   runpath=\"${CONF_f_runpath}\\$(libdir)\"\n   pure_runpath='${build_root}/lib'\nelse\n   runpath=\n   pure_runpath=\nfi\nif test -z \"$CONF_f_runpath\" ; then\n   # Drop the linker flag (since passing directory names doesn't work\n   # so well), but keep pure_runpath for other uses.\n   runpath=\nfi\n\n\n#### Linker command-line to build DLL (may depend on runpath)\nhas_dll_loadable=\"@# \"\nALLOW_UNDEF=\nFORBID_UNDEF=\ncase \"$compiler\" in\n GCC | ICC )\n   LINK_DLL=\"$LINK $ARCH_CFLAGS -shared -o\" # possibly overridden below\n   case \"$host_os\" in\n      solaris* )\n        # See http://realm.progsoc.uts.edu.au/~subtle/solaris28_link.html\n        LINK_DLL=\"$LINK $ARCH_CFLAGS -shared -mimpure-text -o\"\n        FORBID_UNDEF=\"-Wl,-z,defs\"\n        ;;\n      darwin* )\n        # Per <http://fink.sourceforge.net/doc/porting/shared.php>, it was\n        # historically necessary to build plugins as Mach-O bundles rather than\n        # dynamic libraries.  That's not such a big deal on modern Mac OS X\n        # versions, so the Toolkit now defaults to building only the latter.\n        if test \"$with_bundles\" = yes; then\n           has_dll_loadable=\"\"\n           AC_DEFINE(NCBI_USE_BUNDLES, 1,\n              [Define to 1 if building plugins as bundles, as Mac OS X\n               traditionally required.])\n        fi\n        if $CXX -v 2>&1 | egrep -q 'Apple|clang'; then\n           LINK_DLL=\"$LINK $ARCH_CFLAGS -dynamiclib -install_name ${pure_runpath%%:*}/\\$(XDLL) -o\"\n           LINK_LOADABLE=\"$LINK $ARCH_CFLAGS -bundle -o\"\n           ALLOW_UNDEF='-undefined suppress'\n           FORBID_UNDEF='-undefined error'\n        else\n           LINK_DLL=\"$LINK $ARCH_CFLAGS -nostartfiles -Wl,-dynamic -Wl,-dylib -Wl,-install_name,${pure_runpath%%:*}/\\$(XDLL) -o\"\n           LINK_LOADABLE=\"$LINK $ARCH_CFLAGS -nostartfiles -Wl,-dynamic -Wl,-bundle -Wl,-read_only_relocs,warning -lbundle1.o -o\"\n           ALLOW_UNDEF='-Wl,-undefined,suppress'\n           FORBID_UNDEF='-Wl,-undefined,error'\n        fi\n        ;;\n      linux* | *gnu* ) # | *bsd*\n        case \"$compiler:$compiler_version\" in\n           ICC:9* | ICC:1??? )\n             ncbi_cv_prog_cc_wl_no_asu=no\n             LIBS=\"$LIBS -lc\"\n             C_LIBS=\"$C_LIBS -lc\"\n             ;;\n           ICC:* )\n             ;;\n           * )\n             FORBID_UNDEF='-Wl,--no-undefined'\n             ;;\n        esac\n        ;;\n      irix* )\n        FORBID_UNDEF='-Wl,-no_unresolved'\n        ;;\n      osf* )\n        ALLOW_UNDEF='-Wl,-expect_unresolved,\\*'\n        FORBID_UNDEF='-Wl,-error_unresolved'\n        ;;\n   esac\n   AC_CACHE_CHECK([whether $CC supports -Wl,--no-allow-shlib-undefined],\n      ncbi_cv_prog_cc_wl_no_asu,\n      [orig_LDFLAGS=$LDFLAGS\n       LDFLAGS=\"$CXXFLAGS_DLL -shared -Wl,--no-allow-shlib-undefined $LDFLAGS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n          [ncbi_cv_prog_cc_wl_no_asu=yes], [ncbi_cv_prog_cc_wl_no_asu=no])\n       LDFLAGS=$orig_LDFLAGS])\n   if test \"$ncbi_cv_prog_cc_wl_no_asu\" = yes; then\n      FORBID_UNDEF=\"$FORBID_UNDEF -Wl,--no-allow-shlib-undefined\"\n   fi\n  ;;\n MIPSpro73 )\n   LINK_DLL=\"$LINK $ARCH_CFLAGS -shared -o\"\n   FORBID_UNDEF=\"-no_unresolved\"\n   ;;\n Compaq )\n   LINK_DLL=\"$LINK $ARCH_CFLAGS -shared -o\"\n   ALLOW_UNDEF='-expect_unresolved \\*'\n   FORBID_UNDEF='-error_unresolved'\n   ;;\n WorkShop* )\n   LINK_DLL=\"$LINK $ARCH_CFLAGS $MT_FLAG -G -h \\$(XDLL) -o\"\n   FORBID_UNDEF=\"-z defs\"\n   ;;\n KCC )\n   LINK_DLL=\"$LINK $ARCH_CFLAGS $MT_FLAG --soname \\$(XDLL) -o\"\n   FORBID_UNDEF=\"-z defs\"\n   ;;\n VisualAge )\n   # NOTE: --without-dll still recommended, as the linker doesn't seem\n   # to support building shared libraries with undefined symbols.\n   LINK_DLL=\"$LINK $ARCH_CFLAGS $MT_FLAG -qmkshrobj -o\"\n   # ALLOW_UNDEF=\"???\"\n   ;;\n * )\n   if test \"$with_dll\" = \"yes\"  &&  test -z \"$LINK_DLL\" ; then\n      AC_MSG_ERROR([Do not know how to build DLLs with compiler $CXX $compiler_ver])\n   elif test -z \"$LINK_DLL\"; then\n      with_dll=no\n   fi\n   ;;\nesac\n\nif test \"$with_dll\" = \"no\"; then # no DLLs whatsoever!\n   DLL=\n   FORCE_STATIC_LIB=\"LIB_OR_DLL = lib\"\n   APP_LIB_SETTING='$(STATIC_LIB)'\n   APP_LIBS_SETTING='$(STATIC_LIBS)'\nelse\n   FORCE_STATIC_LIB=\n   APP_LIB_SETTING='$(LIB)'\n   APP_LIBS_SETTING='$(LIBS)'\n   NCBI_FEATURE(DLL)\n   # Some shared libraries end up containing static libraries, so make\n   # sure to use DLL flags for both, as such inclusion can otherwise\n   # result in linker errors.\n   DLL_LDFLAGS=\"$DLL_LDFLAGS $CXXFLAGS_DLL\"\n   CFLAGS=\"$CFLAGS $CFLAGS_DLL\"\n   CFLAGS_DLL=\n   CXXFLAGS=\"$CXXFLAGS $CXXFLAGS_DLL\"\n   CXXFLAGS_DLL=\n   AC_DEFINE(NCBI_DLL_SUPPORT, 1,\n     [Define to 1 if building dynamic libraries at all\n      (albeit not necessarily by default).])\n   if test \"$with_dll\" = \"yes\"; then\n      NCBI_FEATURE(DLL_BUILD)\n      AC_DEFINE(NCBI_DLL_BUILD, 1,\n                [Define to 1 if building dynamic libraries by default.])\n      : ${with_plugin_auto_load=yes}\n   fi\nfi\n\nif test \"$with_plugin_auto_load\" = yes; then\n   AC_DEFINE(NCBI_PLUGIN_AUTO_LOAD, 1,\n             [Define to 1 if the plugin manager should load DLLs by default.])\nfi\n\n# Make sure we have commands for both C and C++ preprocessors\nAC_PROG_CPP\ndnl AC_PROG_CXXCPP\n\n\n#### Make \"srcdir\" absolute\ncase \"${srcdir}\" in\n   /* ) ;;\n   . )\n      CDPATH=\n      if test \"${PWD}\" != \"\" && test \"`(cd ${PWD} ; sh -c pwd)`\" = \"`pwd`\"  ;\n      then\n        srcdir=\"$PWD\"\n      else\n        NCBI_FIX_DIR(srcdir)\n      fi\n   ;;\n   * ) NCBI_FIX_DIR(srcdir) ;;\nesac\nreal_srcdir=$srcdir\nif test -n \"$with_fake_root\"; then\n   srcdir=$build_root/..\nfi\n\n\n#### Ensure that all explicitly requested subtrees actually exist\nNCBI_CHECK_SUBTREE(algo)\ndnl NCBI_CHECK_SUBTREE(app)\nif test \"$with_app\" = \"no\" ; then\n   NoConfProjects=\"$NoConfProjects app\"\nfi\n\nif test ! -f ${real_srcdir}/src/app/Makefile.in ; then\n   if test \"${with_app-no}\" != \"no\" ; then\n      AC_MSG_ERROR([--with-app:  APP sources are missing])\n   fi\n   with_app=\"no\"\nfi\n\ndnl NCBI_CHECK_SUBTREE(bdb) # deferred until end, as --with-bdb does double duty\ndnl NCBI_CHECK_SUBTREE(cgi) # --without-cgi deliberately unavailable for now\nif test -f ${real_srcdir}/src/cgi/Makefile.in  -a \\\n        -d ${real_srcdir}/include/cgi; then\n   NCBI_PROJECT(cgi)\nelse\n   AC_MSG_WARN([CGI tree missing; some projects may fail to build.])\nfi\n\nNCBI_CHECK_SUBTREE(ctools)\nNCBI_CHECK_SUBTREE(dbapi)\nNCBI_CHECK_SUBTREE(gui)\nNCBI_CHECK_SUBTREE(objects)\nNCBI_CHECK_SUBTREE(serial)\n\n\n#### Source, include, and build directories\nncbiconf=\"$build_root/inc/ncbiconf_unix.h\"\nncbiconf_old=\"$build_root/inc/ncbiconf.h\"\nif test -f \"$ncbiconf_old\" -a ! -f \"$ncbiconf\"; then\n   mv \"$ncbiconf_old\" \"$ncbiconf\"\nfi\nif test \"$build_root\" = \"$srcdir\" ; then\n   builddir=\"$srcdir/src\"\nelse\n   builddir=\"$build_root/build\"\nfi\nstatus_dir=\"$build_root/status\"\n\n\n#### Create build directories\nmkdir -p \"$builddir\" \"$build_root/lib\" \"$build_root/bin\"\n\n\n#### Check if the target directory already has a configured system in it\nif test \"$no_create\" != \"yes\"  -a  -f \"${ncbiconf}\" ; then\n   echo\n   echo \"There is already a built \\\"${ncbiconf}\\\"!\"\n   NCBI_CAUTION([Do you want to re-configure in \\\"${builddir}\\\"?])\n   echo\nfi\n\n\n#### Use right command shell in scripts and makefiles\nscript_shell=\"#! ${CONFIG_SHELL:=/bin/sh}\"\nmake_shell=\"SHELL=${CONFIG_SHELL:=/bin/sh}\"\n\n\n#### Turn on compilation warnings and adjust\n#### some compiler-specific flags and features\n\nif test \"$CONF_obj_ext\"   = \" \" ;  then obj_ext=\"\" ; else obj_ext=\"${CONF_obj_ext:=.o}\" ; fi\nif test \"$CONF_lib_pre\"   = \" \" ;  then lib_pre=\"\" ; else lib_pre=\"${CONF_lib_pre:=lib}\" ; fi\nif test \"$CONF_lib_l_pre\" = \" \" ;  then lib_l_pre=\"\" ; else lib_l_pre=\"${CONF_lib_l_pre:=-l}\" ; fi\nif test \"$CONF_lib_ext\"   = \" \" ;  then lib_ext=\"\" ; else lib_ext=\"${CONF_lib_ext:=.a}\" ; fi\nif test \"$CONF_dll_ext\"   = \" \" ;  then dll_ext=\"\" ; else dll_ext=\"${CONF_dll_ext:=.so}\" ; fi\nif test \"$CONF_loadable_ext\"  = \" \" ;  then loadable_ext=\"\" ; else loadable_ext=\"${CONF_loadable_ext:=.so}\" ; fi\nif test \"$CONF_lib_l_ext\" = \" \" ;  then lib_l_ext=\"\" ; else lib_l_ext=\"${CONF_lib_l_ext}\" ; fi\nif test \"$CONF_exe_ext\"   = \" \" ;  then exe_ext=\"\" ; else exe_ext=\"${CONF_exe_ext}\" ; fi\nif test \"$CONF_f_compile\" = \" \" ;  then f_compile=\"\" ; else f_compile=\"${CONF_f_compile:=-c }\" ; fi\nif test \"$CONF_f_outobj\"  = \" \" ;  then f_outobj=\"\" ; else f_outobj=\"${CONF_f_outobj:=-o }\" ; fi\nif test \"$CONF_f_outlib\"  = \" \" ;  then f_outlib=\"\" ; else f_outlib=\"${CONF_f_outlib}\" ; fi\nif test \"$CONF_f_libpath\" = \" \" ;  then f_libpath=\"\" ; else f_libpath=\"${CONF_f_libpath:=-L}\" ; fi\nif test \"$CONF_f_runpath\" = \" \" ;  then f_runpath=\"\" ; else f_runpath=\"${CONF_f_runpath:=$CONF_f_libpath}\" ; fi\nif test \"$CONF_f_outexe\"  = \" \" ;  then f_outexe=\"\" ; else f_outexe=\"${CONF_f_outexe:=-o }\" ; fi\n\n\nBINCOPY=\"/bin/cp -p\"\nMAC_BINCOPY=\"/Developer/Tools/CpMac -p\"\nif test \"$with_bincopy\" != \"yes\"; then\n   AC_CACHE_CHECK([whether cross-directory hard links work],\n      ncbi_cv_sys_xdir_ln,\n      [mkdir conftestdir\n       touch conftestdir/conftestfile\n       if ln -f conftestdir/conftestfile .; then\n          ncbi_cv_sys_xdir_ln=yes\n       else\n          ncbi_cv_sys_xdir_ln=no\n       fi\n       rm -rf conftestdir conftestfile])\n   if test \"$ncbi_cv_sys_xdir_ln\" = \"yes\"; then\n      BINCOPY=\"/bin/ln -f\"\n      MAC_BINCOPY=\"\\$(top_srcdir)/scripts/common/impl/ln_mac.sh\"\n   fi\nfi\nifdiff=\"${CONFIG_SHELL} \\$(top_srcdir)/scripts/common/impl/if_diff.sh\"\nif test \"$OSTYPE\" = \"darwin\" -a -x /Developer/Tools/CpMac; then\n   BINCOPY=\"$ifdiff \\\"$MAC_BINCOPY\\\"\"\nelse\n   BINCOPY=\"$ifdiff \\\"$BINCOPY\\\"\"\nfi\n\n\n#### Manage the debug-vs.-optimization flags (\"--with(out)-(max-)debug\",\n#### \"--with(out)-symbols\", \"--with(out)-optimization\")\nif test \"$compiler\" != \"MSVC\" ; then\n   if test \"$with_debug\" = \"no\" -o \"$with_tcheck\" != \"no\"; then\n      CPPFLAGS=\"-DNDEBUG $CPPFLAGS\"\n   else\n      CPPFLAGS=\"-D_DEBUG $CPPFLAGS\"\n   fi\n\n   if test \"$with_max_debug\" = \"yes\"; then\n      case \"$compiler\" in\n         GCC )\n            CPPFLAGS=\"-D_GLIBCXX_DEBUG $CPPFLAGS\"\n            CFLAGS=\"-fstack-check -fsanitize=address $CFLAGS\"\n            CXXFLAGS=\"-fstack-check -fsanitize=address $CXXFLAGS\"\n            LDFLAGS=\"-fsanitize=address $LDFLAGS\"\n            ;;\n         ICC ) \n            CPPFLAGS=\"-D_GLIBCXX_DEBUG $CPPFLAGS\"\n            CFLAGS=\"-debug all -fstack-security-check -ftrapuv $CFLAGS\"\n            CXXFLAGS=\"-debug all -fstack-security-check -ftrapuv $CXXFLAGS\"\n            ;;\n         WorkShop* )\n            CFLAGS=\"-xcheck=%all $CFLAGS\"\n            CXXFLAGS=\"-xcheck=%all $CXXFLAGS\"\n            ;;\n      esac\n      NCBI_FEATURE(MaxDebug)\n   fi\nchangequote(, )dnl\n   dbgrx1=\"$wsrx-g[^cx$wschars]*$wsrx\"\n   dbgrx2=\"$wsrx-gx*coff[0-9+]*$wsrx\"\n   optrx=\"$wsrx-x*O[0-9s]*$wsrx\"\n   NDEB_CFLAGS=`  echo \" $CFLAGS \"   | sed \"s/$dbgrx1/ /g; s/$dbgrx2/ /g\"`\n   NDEB_CXXFLAGS=`echo \" $CXXFLAGS \" | sed \"s/$dbgrx1/ /g; s/$dbgrx2/ /g\"`\n   NDEB_LDFLAGS=` echo \" $LDFLAGS \"  | sed \"s/$dbgrx1/ /g; s/$dbgrx2/ /g\"`\n   if test \"$with_symbols\" = \"no\" ; then\n      CFLAGS=$NDEB_CFLAGS\n      CXXFLAGS=$NDEB_CXXFLAGS\n      LDFLAGS=$NDEB_LDFLAGS\n   else\n      echo \" $CFLAGS \"  | $EGREP_Q \"$dbgrx1|$dbgrx2\" || CFLAGS=\"$CFLAGS -g\"\n      echo \" $CXXFLAGS \"| $EGREP_Q \"$dbgrx1|$dbgrx2\" || CXXFLAGS=\"$CXXFLAGS -g\" \n      echo \" $LDFLAGS \" | $EGREP_Q \"$dbgrx1|$dbgrx2\" || LDFLAGS=\"$LDFLAGS -g\"\n      STRIP=\"@:\"\n      case \"$compiler:$compiler_version\" in\n         GCC:4[89]? | GCC:[5-9]? | GCC:???? )\n            # GCC 4.8 defaults to DWARF 4, which Totalview for one\n            # can't handle; roll back to version 3 by default.\n            echo \" $USER_CFLAGS \" | $EGREP_Q \"$dbgrx1|$dbgrx2\" || \\\n               CFLAGS=\"$NDEB_CFLAGS -gdwarf-3\"\n            echo \" $USER_CXXFLAGS \" | $EGREP_Q \"$dbgrx1|$dbgrx2\" || \\\n               CXXFLAGS=\"$NDEB_CXXFLAGS -gdwarf-3\"\n            echo \" $USER_LDFLAGS \" | $EGREP_Q \"$dbgrx1|$dbgrx2\" || \\\n               LDFLAGS=\"$NDEB_LDFLAGS -gdwarf-3\"\n            ;;\n      esac\n   fi\n\n   NOPT_CFLAGS=`  echo \" $CFLAGS \"    | sed \"s/$optrx/ /g\"`\n   NOPT_CXXFLAGS=`echo \" $CXXFLAGS \"  | sed \"s/$optrx/ /g\"`\n   NOPT_LDFLAGS=` echo \" $LDFLAGS \"   | sed \"s/$optrx/ /g\"`\n   if test \"${with_tcheck-no}\" != \"no\"; then\n      # Suppress warnings when building with ICC.\n      NOPT_CFLAGS=\"$NOPT_CFLAGS -O0\"\n      NOPT_CXXFLAGS=\"$NOPT_CXXFLAGS -O0\"\n      NOPT_LDFLAGS=\"$NOPT_LDFLAGS -O0\"\n   fi\n   if test \"$with_optimization\" = \"no\" ; then\n      CFLAGS=\"$NOPT_CFLAGS\"\n      CXXFLAGS=\"$NOPT_CXXFLAGS\"\n      LDFLAGS=\"$NOPT_LDFLAGS\"\n      FAST_CFLAGS=\"$CFLAGS\"\n      FAST_CXXFLAGS=\"$CXXFLAGS\"\n      FAST_LDFLAGS=\"$LDFLAGS\"\n   else\n      if echo \" $CFLAGS \"   | grep -v \"$optrx\" >/dev/null ; then\n         CFLAGS=\"$CFLAGS -O\" ; fi\n      if echo \" $CXXFLAGS \" | grep -v \"$optrx\" >/dev/null ; then\n         CXXFLAGS=\"$CXXFLAGS -O\" ; fi\n      if echo \" $LDFLAGS \"  | grep -v \"$optrx\" >/dev/null ; then\n         LDFLAGS=\"$LDFLAGS -O\" ; fi\n      if test \"$skip_fast_flags\" = yes ; then\n         FAST_CFLAGS=\"$CFLAGS\"\n         FAST_CXXFLAGS=\"$CXXFLAGS\"\n         FAST_LDFLAGS=\"$LDFLAGS\"\n      else\n         FAST_CFLAGS=\"$NOPT_CFLAGS $FAST_CFLAGS\"\n         FAST_CXXFLAGS=\"$NOPT_CXXFLAGS $FAST_CXXFLAGS\"\n         FAST_LDFLAGS=\"$NOPT_LDFLAGS $FAST_LDFLAGS\"\n      fi\n   fi\nchangequote([, ])dnl\nfi\n\n\n\n### ------------------------------------------------------------------\n### ------------------------------------------------------------------\n\n### Check for header files.\nAC_CHECK_HEADERS(iostream  iostream.h)\nAC_CHECK_HEADERS(fstream   fstream.h)\nAC_CHECK_HEADERS(strstream strstream.h strstrea.h)\n\nAC_CHECK_HEADERS(inttypes.h limits limits.h)\n\n### Check for the platform (very roughly)\nAC_CHECK_HEADERS(unistd.h,  x_have_unistd=\"yes\")\nAC_CHECK_HEADERS(windows.h, x_have_windows=\"yes\")\n\nif test \"$x_have_windows\" = \"yes\" -a \"x$host_os\" != \"xcygwin32\" -a \"x$host_os\" != \"xcygwin\"; then\n   AC_DEFINE(NCBI_OS_MSWIN, 1, [Define to 1 on Windows.])\n   AC_DEFINE(NCBI_OS, \"MSWIN\", [Operating system name])\n   NCBI_FEATURE(MSWin)\nelif test \"$x_have_unistd\" = \"yes\" ; then\n   AC_DEFINE(NCBI_OS_UNIX, 1,  [Define to 1 on Unix.])\n   AC_DEFINE(NCBI_OS, \"UNIX\",  [Operating system name])\n\n   UNIX_SRC='$(UNIX_SRC)'\n   UNIX_USR_PROJ='$(UNIX_USR_PROJ)'\n   NCBI_FEATURE(unix)\n   NCBI_FEATURE(WinMain) # to accommodate a PTB-specific (ab)use of REQUIRES\n\n   # Extra defines for variants we care about\n   case \"$OSTYPE\" in\n     aix)\n        AC_DEFINE(NCBI_OS_AIX,     1, [Define to 1 on AIX.])\n        NCBI_FEATURE(AIX)\n        ;;\n     *bsd)\n        AC_DEFINE(NCBI_OS_BSD,     1, [Define to 1 on *BSD.])\n        NCBI_FEATURE(BSD)\n        ;;\n     cygwin)\n        AC_DEFINE(NCBI_OS_CYGWIN,  1, [Define to 1 on Cygwin.])\n        NCBI_FEATURE(Cygwin)\n        if test \"$with_mt\" = yes; then NCBI_FEATURE(CygwinMT); fi\n        ;;\n     darwin)\n        AC_DEFINE(NCBI_OS_DARWIN,  1, [Define to 1 on Mac OS X.])\n        NCBI_FEATURE(Darwin)\n        if false; then NCBI_FEATURE(XCODE); fi\n        ;;\n     irix)\n        AC_DEFINE(NCBI_OS_IRIX,    1, [Define to 1 on IRIX.])\n        NCBI_FEATURE(IRIX)\n        ;;\n     linux)\n        AC_DEFINE(NCBI_OS_LINUX,   1, [Define to 1 on Linux.])\n        NCBI_FEATURE(Linux)\n        ;;\n     osf)\n        AC_DEFINE(NCBI_OS_OSF1,    1, [Define to 1 on Tru64 Unix.])\n        NCBI_FEATURE(OSF)\n        ;;\n     solaris)\n        AC_DEFINE(NCBI_OS_SOLARIS, 1, [Define to 1 on Solaris.])\n        NCBI_FEATURE(Solaris)\n        ;;\n   esac\nelse\ndnl Classic Mac OS, no longer supported; the following line is\ndnl commented out to avoid cluttering config.h.in.\ndnl AC_DEFINE(NCBI_OS_MAC, 1, [Define to 1 on MacOS.])\n   AC_DEFINE(NCBI_OS, \"MAC\", [Operating system name])\n   NCBI_FEATURE(MacOS)\nfi\n\ncase \"$host_os\" in\n   cygwin* | osf* )\n      AC_DEFINE(NETDB_REENTRANT, 1,\n                [Define to 1 if the BSD-style netdb interface is reentrant.])\n      ;;\nesac\n\n# AC_CHECK_TYPES is insufficient, as linking may still fail :-/\nAC_CACHE_CHECK([for wstring], ac_cv_type_wstring_linkable,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n       [[#include <string>\n         using std::wstring;]],\n       [[wstring ws, ws2; ws.find_first_of(ws2);]])],\n       [ac_cv_type_wstring_linkable=yes], [ac_cv_type_wstring_linkable=no])])\nif test \"$ac_cv_type_wstring_linkable\" = \"yes\"; then\n   AC_DEFINE(HAVE_WSTRING, 1,\n      [Define to 1 if the system has the type `wstring'.])\nfi\n\nAC_CHECK_TYPES(socklen_t,,,[#include <sys/types.h>\n#include <sys/socket.h>])\nAC_CHECK_HEADERS(atomic.h cpuid.h dlfcn.h ieeefp.h poll.h sys/epoll.h \\\n                 sys/mount.h sys/sockio.h sys/statvfs.h sys/sysinfo.h \\\n                 sys/vfs.h x86intrin.h)\ncase \"$host_os\" in\n   cygwin*) AC_CHECK_HEADERS(winternl.h) ;;\nesac\n# for FreeTDS\nAC_CHECK_HEADERS(alloca.h arpa/inet.h dirent.h errno.h fcntl.h getopt.h \\\n                 langinfo.h libgen.h locale.h malloc.h net/inet/in.h netdb.h \\\n                 netinet/in.h netinet/tcp.h paths.h select.h signal.h \\\n                 stdbool.h stddef.h sys/eventfd.h sys/file.h sys/ioctl.h \\\n                 sys/param.h sys/resource.h sys/select.h sys/socket.h \\\n                 sys/time.h sys/wait.h valgrind/memcheck.h wchar.h)\nAC_HEADER_TIME\n\nAC_CHECK_HEADERS(cxxabi.h)\nif test \"$ac_cv_header_cxxabi_h\" = \"yes\"; then\n   AC_CHECK_DECL(abi::__cxa_demangle,\n      [AC_DEFINE(HAVE_CXA_DEMANGLE, 1,\n        [Define to 1 if `abi::__cxa_demangle' is available from <cxxabi.h>.])],\n      [], [[#include <cxxabi.h>]])\nfi\n\n## gethostbyname_r() -- 2 different variants: 5-arg (Solaris), 6-arg (Linux).\n\nAC_CACHE_CHECK([for gethostbyname_r], ncbi_cv_func_gethostbyname_r,\n   [ncbi_cv_func_gethostbyname_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>]],\n       [[\n         void*           dummy = (void*) &gethostbyname_r;\n         char            buf[1024];\n         int             err;\n         struct hostent* hp = 0;\n         hp = gethostbyname_r(\"\", hp, buf, sizeof(buf), &err);\n       ]])],\n       [\n         ncbi_cv_func_gethostbyname_r=\"5\"\n       ]\n    )\n    if test \"$ncbi_cv_func_gethostbyname_r\" = \"no\" ; then\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>]],\n       [[\n         void*           dummy = (void*) &gethostbyname_r;\n         char            buf[1024];\n         int             err;\n         struct hostent* hp = 0;\n         err = gethostbyname_r(\"\", hp, buf, sizeof(buf), &hp, &err);\n       ]])],\n       [\n         ncbi_cv_func_gethostbyname_r=\"6\"\n       ]\n    )\n    fi])\n\nif test \"$ncbi_cv_func_gethostbyname_r\" != \"no\" ; then\n   AC_DEFINE_UNQUOTED(HAVE_GETHOSTBYNAME_R, $ncbi_cv_func_gethostbyname_r,\n    [If you have the `gethostbyname_r' function, define to the number of\n     arguments it takes (normally 5 or 6).])\nfi\n\n\n## gethostbyaddr_r() -- 2 different variants: 7-arg (Solaris), 8-arg (Linux).\n\nAC_CACHE_CHECK([for gethostbyaddr_r], ncbi_cv_func_gethostbyaddr_r,\n   [ncbi_cv_func_gethostbyaddr_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[\n         #include <netdb.h>\n         #include <sys/types.h>\n         #include <sys/socket.h>\n       ]],\n       [[\n         void* dummy = (void*) &gethostbyaddr_r;\n         char            buf[1024];\n         int             err;\n         unsigned int    host;\n         struct hostent* hp = 0;\n         hp = gethostbyaddr_r((char *) &host, sizeof(host), AF_INET,\n                              hp, buf, sizeof(buf), &err);\n       ]])],\n       [\n         ncbi_cv_func_gethostbyaddr_r=\"7\"\n       ]\n    )\n    if test \"$ncbi_cv_func_gethostbyaddr_r\" = \"no\" ; then\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[\n         #include <netdb.h>\n         #include <sys/types.h>\n         #include <sys/socket.h>\n       ]],\n       [[\n         void* dummy = (void*) &gethostbyaddr_r;\n         char            buf[1024];\n         int             err;\n         unsigned int    host;\n         struct hostent* hp = 0;\n         int res = gethostbyaddr_r((char *) &host, sizeof(host), AF_INET,\n                                   hp, buf, sizeof(buf), &hp, &err);\n       ]])],\n       [\n         ncbi_cv_func_gethostbyaddr_r=\"8\"\n       ]\n    )\n    fi])\n\nif test \"$ncbi_cv_func_gethostbyaddr_r\" != \"no\" ; then\n   AC_DEFINE_UNQUOTED(HAVE_GETHOSTBYADDR_R, $ncbi_cv_func_gethostbyaddr_r,\n    [If you have the `gethostbyaddr_r' function, define to the number of\n     arguments it takes (normally 7 or 8).])\nfi\n\n\n## getservbyname_r() -- 2 different variants: 5-arg (Solaris), 6-arg (Linux).\n\nAC_CACHE_CHECK([for getservbyname_r], ncbi_cv_func_getservbyname_r,\n   [ncbi_cv_func_getservbyname_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>]],\n       [[\n         void*           dummy = (void*) &getservbyname_r;\n         char            buf[1024];\n         int             err;\n         struct servent* sp = 0;\n         sp = getservbyname_r(\"\", \"\", sp, buf, sizeof(buf));\n       ]])],\n       [\n         ncbi_cv_func_getservbyname_r=\"5\"\n       ]\n    )\n    if test \"$ncbi_cv_func_getservbyname_r\" = \"no\" ; then\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>]],\n       [[\n         void*           dummy = (void*) &getservbyname_r;\n         char            buf[1024];\n         int             err;\n         struct servent* sp = 0;\n         err = getservbyname_r(\"\", \"\", sp, buf, sizeof(buf), &sp);\n       ]])],\n       [\n         ncbi_cv_func_getservbyname_r=\"6\"\n       ]\n    )\n    fi])\n\nif test \"$ncbi_cv_func_getservbyname_r\" != \"no\" ; then\n   AC_DEFINE_UNQUOTED(HAVE_GETSERVBYNAME_R, $ncbi_cv_func_getservbyname_r,\n    [If you have the `getservbyname_r' function, define to the number of\n     arguments it takes (normally 5 or 6).])\nfi\n\n## getpwuid_r() -- 2 major variants: 4-arg, 5-arg (POSIX).\n## (Alternate 4-arg interface ignored due to rarity.)\n\nAC_CACHE_CHECK([for getpwuid_r], ncbi_cv_func_getpwuid_r,\n   [ncbi_cv_func_getpwuid_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <unistd.h>\n         #include <pwd.h>]],\n       [[struct passwd bpw;\n         char buf[1024];\n         char *dir = getpwuid_r(getuid(), &bpw, buf, sizeof(buf))->pw_dir;\n       ]])],\n       [ncbi_cv_func_getpwuid_r=4])\n    if test \"$ncbi_cv_func_getpwuid_r\" = \"no\" ; then\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <unistd.h>\n         #include <pwd.h>]],\n       [[struct passwd *pw, bpw;\n         char buf[1024];\n         getpwuid_r(getuid(), &bpw, buf, sizeof(buf), &pw);\n       ]])],\n       [ncbi_cv_func_getpwuid_r=5])\n    fi])\n\nif test \"$ncbi_cv_func_getpwuid_r\" != \"no\" ; then\n   AC_DEFINE_UNQUOTED(NCBI_HAVE_GETPWUID_R, $ncbi_cv_func_getpwuid_r,\n    [If you have the `getpwuid_r' function, define to the number of\n     arguments it takes (normally 4 or 5).])\nfi\n\n# Perform a full-fledged check in C++ to be sure of an actual declaration.\n# Accommodate the old Solaris interface that returns char* rather than int. :-/\nAC_CACHE_CHECK([for getlogin_r], ncbi_cv_func_getlogin_r,\n   [ncbi_cv_func_getlogin_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <unistd.h>]],\n       [[char buf[64]; /* return */ getlogin_r(buf, 64);]])],\n       [ncbi_cv_func_getlogin_r=yes], [ncbi_cv_func_getlogin_r=no])])\nif test $ncbi_cv_func_getlogin_r = yes; then\n   AC_DEFINE(HAVE_GETLOGIN_R, 1,\n      [Define to 1 if you have the `getlogin_r' function])\nfi\n\nAC_LANG_PUSH(C)\n# some of these can lose in C++ due to the way autoconf works\nAC_CHECK_FUNCS(localtime_r pthread_setconcurrency pthread_atfork)\nif test \"$ac_cv_func_localtime_r\" = \"yes\" ; then\n   AC_CACHE_CHECK(return type of localtime_r, ac_cv_func_which_localtime_r,\n      [AC_COMPILE_IFELSE(\n          [AC_LANG_PROGRAM(\n             [[#include <unistd.h>\n               #include <time.h>]],\n             [[struct tm mytm;\n               time_t t;\n               int y = localtime_r(&t, &mytm)->tm_year;]])],\n          ac_cv_func_which_localtime_r=struct,\n          ac_cv_func_which_localtime_r=int)])\n   if test $ac_cv_func_which_localtime_r = struct; then\n      AC_DEFINE(HAVE_FUNC_LOCALTIME_R_TM, 1,\n         [Define to 1 if your localtime_r returns a struct tm*.])\n   else\n     AC_DEFINE(HAVE_FUNC_LOCALTIME_R_INT, 1,\n        [Define to 1 if your localtime_r returns a int.])\n   fi\nfi\n\nAC_CACHE_CHECK([whether pthread mutexes are available],\n   ncbi_cv_func_pthread_mutex,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n       [[#include <pthread.h>\n         pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;]],\n       [[pthread_mutex_lock(&mutex); pthread_mutex_unlock(&mutex);]])],\n      [ncbi_cv_func_pthread_mutex=yes], [ncbi_cv_func_pthread_mutex=no])])\nif test $ncbi_cv_func_pthread_mutex=yes; then\n   AC_DEFINE(HAVE_PTHREAD_MUTEX, 1,\n      [Define to 1 if pthread mutexes are available.])\nfi\n\n\n### Check for other standard library functions\n\nAC_FUNC_VPRINTF\nAC_CHECK_FUNCS(alarm asprintf atoll basename dbopen daemon euidaccess eventfd \\\n               fseeko fstat getgrouplist gethrtime getopt getpagesize getpass \\\n               getpassphrase getpwuid getrusage gettimeofday getuid lchown \\\n               lutimes malloc_options memrchr nl_langinfo poll putenv \\\n               readpassphrase readv select setenv setitimer setrlimit \\\n               snprintf statfs statvfs strcasecmp strdup strlcat strlcpy \\\n               strndup strnlen strsep strtok_r sysmp timegm usleep utimes \\\n               vasprintf vsnprintf writev)\nAC_LANG_POP(C)\n\nAC_TYPE_SIGNAL\ntest \"$ac_cv_func_select\" = yes  ||  ncbi_cv_func_select_updates_timeout=no\nAC_CACHE_CHECK([whether select updates the timeout when interrupted],\n               ncbi_cv_func_select_updates_timeout,\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM(\n       [[#include <signal.h>\n         #include <sys/types.h>\n         #ifdef HAVE_SYS_SELECT_H\n         #  include <sys/select.h>\n         #endif\n         #ifdef HAVE_SYS_TIME_H\n         #  include <sys/time.h>\n         #endif\n         #ifdef HAVE_UNISTD_H\n         #  include <unistd.h>\n         #endif\n         RETSIGTYPE handler(int sig) { alarm(0); }]],\n       [[struct timeval timeout = { 5, 0 };\n         signal(SIGALRM, &handler);\n         alarm(1);\n         select(0, NULL, NULL, NULL, &timeout);\n         return timeout.tv_sec == 5;]])],\n       [ncbi_cv_func_select_updates_timeout=yes],\n       [ncbi_cv_func_select_updates_timeout=no],\n       [case \"$host_os\" in\n          linux) ncbi_cv_func_select_updates_timeout=yes ;;\n          *) ncbi_cv_func_select_updates_timeout=no ;;\n        esac])])\nif test \"$ncbi_cv_func_select_updates_timeout\" = yes; then\n   AC_DEFINE(SELECT_UPDATES_TIMEOUT, 1,\n      [Define to 1 if the `select' function updates its timeout when\n       interrupted by a signal.])\nfi\n\n# We want the program to return 0, which is *false* in C.  Also, since\n# use of lowercase seems to be customary if not universal, the default\n# is yes when cross-compiling; anyone cross-compiling for exceptional\n# platforms can set ncbi_cv_func_strcasecmp_lc=no in config.site.\nif test \"$ac_cv_func_strcasecmp\" = yes; then\n   AC_CACHE_CHECK([whether strcasecmp treats letters as lowercase],\n                  ncbi_cv_func_strcasecmp_lc,\n      [AC_RUN_IFELSE([AC_LANG_PROGRAM(\n          [[#include <string.h>]],\n          [[return strcasecmp(\"A\", \"_\") <= 0;]])],\n          [ncbi_cv_func_strcasecmp_lc=yes], [ncbi_cv_func_strcasecmp_lc=no],\n          [ncbi_cv_func_strcasecmp_lc=yes])])\n   if test \"$ncbi_cv_func_strcasecmp_lc\" = yes; then\n      AC_DEFINE(HAVE_STRCASECMP_LC, 1,\n                [Define to 1 if strcasecmp treats letters as lowercase.])\n   fi\nfi\n\nAC_CACHE_CHECK([for Linux-like sysinfo with 1 arg], ncbi_cv_func_sysinfo_1,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <sys/sysinfo.h>]],\n       [[\n         void* dummy = (void*) &sysinfo;\n         struct sysinfo* info = 0;\n         int retval = sysinfo(info);\n       ]])], [ncbi_cv_func_sysinfo_1=yes], [ncbi_cv_func_sysinfo_1=no])])\n\nif test \"$ncbi_cv_func_sysinfo_1\" = yes; then\n   AC_DEFINE(HAVE_SYSINFO_1, 1,\n             [Define to 1 if Linux-like 1-arg sysinfo exists.])\nfi\n\ndnl Too much overkill, and now wants getloadavg.c to exist.\ndnl AC_FUNC_GETLOADAVG\nAC_CHECK_FUNCS(getloadavg)\n\n## readdir_r() -- 2 different variants: 2-arg (trad. Solaris), 3-arg (POSIX).\n\nAC_CACHE_CHECK([for readdir_r], ncbi_cv_func_readdir_r,\n   [ncbi_cv_func_readdir_r=\"no\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <dirent.h>]],\n       [[DIR* dir; struct dirent* entry; readdir_r(dir, entry, &entry);]])],\n       [ncbi_cv_func_readdir_r=3])\n    if test \"$ncbi_cv_func_readdir_r\" = \"no\" ; then\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <dirent.h>]],\n       [[DIR* dir; struct dirent* entry; readdir_r(dir, entry);]])],\n       [ncbi_cv_func_readdir_r=2])\n    fi])\n\nif test \"$ncbi_cv_func_readdir_r\" != \"no\" ; then\n   AC_DEFINE_UNQUOTED(NCBI_HAVE_READDIR_R, $ncbi_cv_func_readdir_r,\n    [If you have the `readdir_r' function, define to the number of\n     arguments it takes (normally 2 or 3).])\nfi\n\nAC_CACHE_CHECK([whether stdio supports locking], ncbi_cv_c_stdio_locked,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n      [[#include <stdio.h>]],\n      [[int c;\n        flockfile(stdin);\n        c = getc_unlocked(stdin);\n        funlockfile(stdin);]])],\n      [ncbi_cv_c_stdio_locked=yes], [ncbi_cv_c_stdio_locked=no])])\nif test \"$ncbi_cv_c_stdio_locked\" = yes; then\n   AC_DEFINE(NCBI_HAVE_STDIO_LOCKED, 1,\n      [Define to 1 if stdio supports locking.])\nfi\n\n### Check for typedefs, structures, and compiler features.\nAC_C_CONST\n\n### Check for C standard types and sizes\nAC_C_BIGENDIAN\nAC_C_CHAR_UNSIGNED\nAC_CHECK_SIZEOF(char)\nAC_CHECK_SIZEOF(double)\nAC_CHECK_SIZEOF(float)\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long)\nAC_CHECK_SIZEOF(long double)\nAC_CHECK_SIZEOF(long long)\nAC_CHECK_SIZEOF(short)\nAC_CHECK_SIZEOF(void*)\nAC_CHECK_SIZEOF(wchar_t, [], [#include <wchar.h>])\nAC_CHECK_SIZEOF(__int64)\nAC_CHECK_TYPES([intptr_t, uintptr_t])\n\nAC_CHECK_MEMBER(struct sockaddr_in.sin_len,\n   [AC_DEFINE(HAVE_SIN_LEN, 1,\n      [Define to 1 if `sin_len' is a member of `struct sockaddr_in'.])],\n   [], [#include <sys/types.h>\n        #include <netinet/in.h>])\n\nAC_CHECK_MEMBERS([struct tm.tm_zone, struct tm.__tm_zone], [], [],\n   [#include <time.h>])\n\n\nAC_CACHE_CHECK([whether function prototypes can use throw(...)],\n   ncbi_cv_cxx_throw_spec,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[template <class T> inline int test_throw_spec(const T&) throw() {\n          return 0;\n       }]],\n       [[return test_throw_spec(123);]])],\n       [ncbi_cv_cxx_throw_spec=yes], [ncbi_cv_cxx_throw_spec=no])])\nif test \"$ncbi_cv_cxx_throw_spec\" = yes; then\n   AC_DEFINE(NCBI_USE_THROW_SPEC, 1,\n             [Define to 1 if prototypes can use exception specifications.])\nfi\n\n\nAC_CACHE_CHECK([for ios(_base)::register_callback],\n   ncbi_cv_func_ios_register_callback,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#include <iostream>]],\n       [[std::cout.register_callback(0, std::ios::erase_event);]])],\n       [ncbi_cv_func_ios_register_callback=yes],\n       [ncbi_cv_func_ios_register_callback=no])])\nif test \"$ncbi_cv_func_ios_register_callback\" = yes; then\n   AC_DEFINE(HAVE_IOS_REGISTER_CALLBACK, 1,\n             [Define to 1 if you have `ios(_base)::register_callback'.])\nfi\n\n\nAC_CACHE_CHECK([for SysV semaphores], ncbi_cv_sys_semaphores,\n   AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>\n#include <sys/sem.h>],\n      [struct sembuf buf; int id = semget(0x1234, 0, IPC_CREAT);\n       buf.sem_op = SEM_UNDO;])],\n      [ncbi_cv_sys_semaphores=yes], [ncbi_cv_sys_semaphores=no]))\nif test \"$ncbi_cv_sys_semaphores\" = yes; then\n   AC_DEFINE(HAVE_SYSV_SEMAPHORES, 1,\n             [Define to 1 if you have SysV semaphores.])\nfi\n\nAC_CHECK_TYPE([union semun],\n   AC_DEFINE(HAVE_SEMUN, 1, [Define to 1 if you have `union semun'.]),\n   [], [#include <sys/types.h>\n#include <sys/sem.h>])\n\n\nAC_CACHE_CHECK([which way the stack grows], ncbi_cv_sys_stack_dir,\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM(\n        [[ int f(int* p) { int i; return (&i < p) ? 1 : 0; } ]],\n        [[ int p; return f(&p); ]])],\n        [ncbi_cv_sys_stack_dir=up], [ncbi_cv_sys_stack_dir=down],\n        [ncbi_cv_sys_stack_dir=\"unknown (cross-compiling)\"])])\ncase \"$ncbi_cv_sys_stack_dir\" in\n up)   AC_DEFINE(STACK_GROWS_UP,   1, [Define to 1 if the stack grows up.])  ;;\n down) AC_DEFINE(STACK_GROWS_DOWN, 1, [Define to 1 if the stack grows down.]);;\nesac\n\nAC_LANG_PUSH(C)\n\nAC_CACHE_CHECK([whether the preprocessor supports C99-style variadic macros],\n   ncbi_cv_cpp_std_varargs,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#define foo(...) 1\n         #if foo(x,y,z) != 1\n         #error failed\n         #endif]], [])],\n       [ncbi_cv_cpp_std_varargs=yes], [ncbi_cv_cpp_std_varargs=no])])\nif test \"$ncbi_cv_cpp_std_varargs\" = yes; then\n   AC_DEFINE(HAVE_CPP_STD_VARARGS, 1,\n      [Define to 1 if the preprocessor supports C99-style variadic macros.])\nfi\n\nAC_CACHE_CHECK([whether the preprocessor supports GNU-style variadic macros],\n   ncbi_cv_cpp_gnu_varargs,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[#define foo(args...) 1\n         #if foo(x,y,z) != 1\n         #error failed\n         #endif]], [])],\n       [ncbi_cv_cpp_gnu_varargs=yes], [ncbi_cv_cpp_gnu_varargs=no])])\nif test \"$ncbi_cv_cpp_gnu_varargs\" = yes; then\n   AC_DEFINE(HAVE_CPP_GNU_VARARGS, 1,\n      [Define to 1 if the preprocessor supports GNU-style variadic macros.])\nfi\n\nAC_LANG_POP(C)\n\n# Avoid using unsupported (and noisily ignored) attributes.\ncase \"$compiler:$compiler_version\" in\n   GCC:2* | GCC:3[[01]]* )\n      ncbi_cv_c_deprecation_syntax=none\n      ncbi_cv_c_forceinline=inline\n      ;;\n   VisualAge:* )\n      ncbi_cv_c_forceinline=inline\n      ;;\n   WorkShop* )\n      ncbi_cv_c_deprecation_syntax=none\n      ncbi_cv_c_forceinline=inline\n      ncbi_cv_c_noreturn=none\n      ;;\nesac\n\nAC_CACHE_CHECK([syntax for marking deprecated functions],\n   ncbi_cv_c_deprecation_syntax,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[void f(void) __attribute__((__deprecated__)); void f(void) { }]],\n       [[f();]])],\n      [ncbi_cv_c_deprecation_syntax='__attribute__((__deprecated__))'],\n      [ncbi_cv_c_deprecation_syntax=none])])\ndepr=$ncbi_cv_c_deprecation_syntax\ntest \"$depr\" = \"none\"  &&  depr=\"\"\nAC_DEFINE_UNQUOTED(NCBI_DEPRECATED, $depr,\n   [Define to whatever syntax, if any, your compiler supports for marking\n    functions as deprecated.])\n\nAC_LANG_PUSH(C)\nAC_CACHE_CHECK([how to force inlining],\n   ncbi_cv_c_forceinline,\n   [ncbi_cv_c_forceinline=no\n    for fi in __always_inline \"inline __attribute__((always_inline))\" \\\n       forceinline __forceinline__ __forceinline inline __inline__; do\n       test \"$ncbi_cv_c_forceinline\" = \"no\" || break\n       AC_COMPILE_IFELSE([AC_LANG_SOURCE([$fi int f(void) { return 0; }])],\n          [ncbi_cv_c_forceinline=$fi], [])\n    done])\nforceinline=$ncbi_cv_c_forceinline\ntest \"$forceinline\" = \"no\"  &&  forceinline=\"\"\nAC_DEFINE_UNQUOTED(NCBI_FORCEINLINE, $forceinline,\n   [Define to whatever syntax your compiler supports for marking functions\n    as to be inlined even if they might not otherwise be.])\n\nAC_CACHE_CHECK([whether the C compiler supports __attribute__((destructor))],\n   ncbi_cv_c_attribute_destructor,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[void f(void) __attribute__((destructor)); void f(void) { }]],\n       [[f();]])],\n      [ncbi_cv_c_attribute_destructor=yes],\n      [ncbi_cv_c_attribute_destructor=no])])\nif test $ncbi_cv_c_attribute_destructor = yes; then\n   AC_DEFINE(HAVE_ATTRIBUTE_DESTRUCTOR, 1,\n      [Define to 1 if your C compiler supports __attribute__((destructor))])\nfi\n\ncase \"$compiler:$compiler_version $CFLAGS $CXXFLAGS\" in\n   GCC:[[4-9]]??\\ *\\ -fvisibility*|ICC:*\\ -fvisibility* ) ;;\n   * ) ncbi_cv_c_attribute_visibility_default=unnecessary ;;\nesac\n\nAC_CACHE_CHECK([whether $CC supports __attribute__((visibility(\"default\")))],\n   ncbi_cv_c_attribute_visibility_default,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[__attribute__((visibility(\"default\"))) void f(void); void f(void) {}]],\n       [[f();]])],\n      [ncbi_cv_c_attribute_visibility_default=yes],\n      [ncbi_cv_c_attribute_visibility_default=no])])\nif test $ncbi_cv_c_attribute_visibility_default = yes; then\n   AC_DEFINE(HAVE_ATTRIBUTE_VISIBILITY_DEFAULT, 1,\n      [Define to 1 if your compiler supports __attribute__((visibility(\"default\")))])\nfi\n\nAC_CACHE_CHECK([whether the C compiler supports C99 restrict],\n   ncbi_cv_c_restrict,\n   [ncbi_cv_c_restrict=no\n    for restrict in __restrict__ __restrict restrict; do\n       test \"$ncbi_cv_c_restrict\" = \"no\" || break\n       AC_COMPILE_IFELSE([AC_LANG_SOURCE([void f(int * $restrict p);])],\n          [ncbi_cv_c_restrict=$restrict], [])\n    done])\nrestrict=$ncbi_cv_c_restrict\ntest \"$restrict\" = \"no\"  &&  restrict=\"\"\nAC_DEFINE_UNQUOTED(NCBI_RESTRICT_C, $restrict,\n   [Define to whatever syntax, if any, your C compiler supports for marking\n    pointers as restricted in the C99 sense.])\nif test -n \"$restrict\"; then\n   AC_DEFINE(HAVE_RESTRICT_C, 1,\n      [Define to 1 if your C compiler supports some variant of the C99\n       `restrict' keyword.])\nfi\nAC_LANG_POP(C)\n\nAC_CACHE_CHECK([whether the C++ compiler supports C99 restrict],\n   ncbi_cv_cxx_restrict,\n   [ncbi_cv_cxx_restrict=no\n    for restrict in __restrict__ __restrict restrict; do\n       test \"$ncbi_cv_cxx_restrict\" = \"no\" || break\n       AC_COMPILE_IFELSE([AC_LANG_SOURCE([void f(int * $restrict p);])],\n          [ncbi_cv_cxx_restrict=$restrict], [])\n    done])\nrestrict=$ncbi_cv_cxx_restrict\ntest \"$restrict\" = \"no\"  &&  restrict=\"\"\nAC_DEFINE_UNQUOTED(NCBI_RESTRICT_CXX, $restrict,\n   [Define to whatever syntax, if any, your C++ compiler supports for marking\n    pointers as restricted in the C99 sense.])\nif test -n \"$restrict\"; then\n   AC_DEFINE(HAVE_RESTRICT_CXX, 1,\n      [Define to 1 if your C++ compiler supports some variant of the C99\n       `restrict' keyword.])\nfi\n\nAC_CACHE_CHECK([syntax for marking functions that never return],\n   ncbi_cv_c_noreturn,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[void f(void) __attribute__((__noreturn__)); void f(void) { }]],\n       [[f();]])],\n      [ncbi_cv_c_noreturn='__attribute__((__noreturn__))'],\n      [ncbi_cv_c_noreturn=none])])\nnoret=$ncbi_cv_c_noreturn\ntest \"$noret\" = \"none\"  &&  noret=\"\"\nAC_DEFINE_UNQUOTED(NCBI_NORETURN, $noret,\n   [Define to whatever syntax, if any, your compiler supports for marking\n    functions that never return.])\n\nAC_CACHE_CHECK([syntax for marking functions whose result should be checked],\n   ncbi_cv_c_warn_unused_result,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[int f(void) __attribute__((warn_unused_result));]],\n       [[int status = f();]])],\n      [ncbi_cv_c_warn_unused_result='__attribute__((warn_unused_result))'],\n      [ncbi_cv_c_warn_unused_result=none])])\nwur=$ncbi_cv_c_warn_unused_result\ntest \"$wur\" = \"none\"  &&  wur=\"\"\nAC_DEFINE_UNQUOTED(NCBI_WARN_UNUSED_RESULT, $wur,\n   [Define to whatever syntax, if any, your compiler supports for marking\n    functions whose (status) result is important to check.])\n\nAC_CACHE_CHECK([syntax for declaring thread-local variables],\n   ncbi_cv_c_tls_var,\n   [ncbi_cv_c_tls_var=none\n    for tls_var in __thread '__declspec(thread)' _Thread_local; do\n       test \"$ncbi_cv_c_tls_var\" = \"none\" || break\n       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([$tls_var int i;],\n          [static $tls_var int j;])],\n          [ncbi_cv_c_tls_var=$tls_var], [])\n    done])\ntls_var=$ncbi_cv_c_tls_var\nif test \"$tls_var\" != \"none\"; then\n   AC_DEFINE_UNQUOTED(NCBI_TLS_VAR, $tls_var,\n      [Define to whatever syntax your compiler supports for declaring\n       thread-local variables, or leave undefined if it doesn't.])\nfi\n\nAC_CACHE_CHECK([syntax for marking types as packed to save memory],\n   ncbi_cv_c_packed,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n       [[enum E { foo, bar } __attribute__((packed));]])],\n      [ncbi_cv_c_packed='__attribute__((__packed__))'],\n      [ncbi_cv_c_packed=none])])\npacked=$ncbi_cv_c_packed\ntest \"$packed\" = \"none\"  &&  packed=\"\"\nAC_DEFINE_UNQUOTED(NCBI_PACKED, $packed,\n   [Define to whatever syntax, if any, your compiler supports for marking\n    types as packed to save memory.])\n\n# for FreeTDS\nAC_CACHE_CHECK([whether FIONBIO requires BSD_COMP to be defined],\n   ncbi_cv_decl_fionbio_needs_bsd_comp,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[ #include <sys/types.h>\n          #include <sys/ioctl.h> ]],\n       [[ int request = FIONBIO; ]])],\n       [ncbi_cv_decl_fionbio_needs_bsd_comp=no],\n       [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n           [[ #define BSD_COMP 1\n              #include <sys/types.h>\n              #include <sys/ioctl.h> ]],\n           [[ int request = FIONBIO; ]])],\n           [ncbi_cv_decl_fionbio_needs_bsd_comp=yes],\n           [ncbi_cv_decl_fionbio_needs_bsd_comp=\"never defined at all\"])])])\nif test \"$ncbi_cv_decl_fionbio_needs_bsd_comp\" = yes; then\n   AC_DEFINE(BSD_COMP, 1,\n             [Define to 1 if necessary to get FIONBIO (e.g., on Solaris)])\nfi\n\nAC_CACHE_CHECK([whether INADDR_NONE is defined], ncbi_cv_decl_inaddr_none,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n       [[\n         #ifdef HAVE_SYS_TYPES_H\n         #include <sys/types.h>\n         #endif\n         #ifdef HAVE_SYS_SOCKET_H\n         #include <sys/socket.h>\n         #endif\n         #ifdef HAVE_NETINET_IN_H\n         #include <netinet/in.h>\n         #endif\n         #ifdef HAVE_ARPA_INET_H\n         #include <arpa/inet.h>\n         #endif\n       ]],\n       [[ unsigned long addr = INADDR_NONE; ]])],\n       [ncbi_cv_decl_inaddr_none=yes], [ncbi_cv_decl_inaddr_none=no])])\nif test \"$ncbi_cv_decl_inaddr_none\" != yes; then\n   AC_DEFINE(INADDR_NONE, 0xffffffff,\n             [Define to 0xffffffff if your operating system doesn't.])\nfi\n\nAC_CACHE_CHECK([whether unaligned reads are permissible],\n               ncbi_cv_sys_unaligned_reads,\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n       [[ unsigned int a[2] = { 0x01234567, 0x89abcdef };\n          fprintf(stderr, \"%x\\n\", *(unsigned int*)((char*)a + 1)); ]])],\n       [ncbi_cv_sys_unaligned_reads=yes],\n       [ncbi_cv_sys_unaligned_reads=no],\n       [case \"$host_cpu\" in\n          i?86|x86_64|powerpc*|ppc*) ncbi_cv_sys_unaligned_reads=yes ;;\n          *)                         ncbi_cv_sys_unaligned_reads=no  ;;\n        esac])])\nif test \"$ncbi_cv_sys_unaligned_reads\" = yes; then\n   AC_DEFINE(HAVE_UNALIGNED_READS, 1,\n             [Define to 1 if your system permits reading integers from\n              unaligned addresses.])\nfi\n\nAC_LANG_PUSH(C)\norig_CFLAGS=$CFLAGS\n\nAC_CACHE_CHECK([whether $CC supports SIMD vector arithmetic],\n               ncbi_cv_cc_vector_math,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n         [typedef int TVector __attribute__((vector_size(16)));\n          TVector f(TVector v1, TVector v2) { return v1 ^ v2; }],\n         [TVector v1, v2, v3;  v3 = f(v1, v2);])],\n      [ncbi_cv_cc_vector_math=yes], [ncbi_cv_cc_vector_math=no])])\nif test \"$ncbi_cv_cc_vector_math\" = yes; then\n   AC_DEFINE(HAVE_VECTOR_MATH, 1,\n      [Define to 1 if your C compiler supports SIMD vector calculations.])\nfi\n\nAC_CACHE_CHECK([whether $CC supports -funsafe-math-optimizations],\n               ncbi_cv_cc_unsafe_math,\n   [CFLAGS=\"$orig_CFLAGS -funsafe-math-optimizations\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],[])],\n       [ncbi_cv_cc_unsafe_math=yes], [ncbi_cv_cc_unsafe_math=no])])\n\nAC_CACHE_CHECK([whether $CC supports -msse4.1], ncbi_cv_cc_sse4_1,\n   [CFLAGS=\"$orig_CFLAGS -msse4.1\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <emmintrin.h>],\n          [double v __attribute__((__vector_size__(16)));\n           __builtin_ia32_shufpd(v, v, 1);])],\n       [ncbi_cv_cc_sse4_1=yes], [ncbi_cv_cc_sse4_1=no])])\n\nAC_CACHE_CHECK([whether $CC supports -maes], ncbi_cv_cc_aes,\n   [CFLAGS=\"$orig_CFLAGS -maes\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n          [#include <wmmintrin.h>\n           typedef long long TAESVec __attribute__((__vector_size__(16)));\n           TAESVec f(TAESVec v, TAESVec w) {\n              return __builtin_ia32_aesdec128(v, w);\n           }], [])],\n       [ncbi_cv_cc_aes=yes], [ncbi_cv_cc_aes=no])])\n\nif test \"$compiler\" = ICC; then\n   # ICC noisily ignores this flag, so explicitly blacklist it.\n   ncbi_cv_cc_fdiagnostics_color_always=no\nfi\nAC_CACHE_CHECK([whether $CC supports -fdiagnostics-color=always],\n   ncbi_cv_cc_fdiagnostics_color_always,\n   [CFLAGS=\"$orig_CFLAGS -fdiagnostics-color=always\"\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [])],\n       [ncbi_cv_cc_fdiagnostics_color_always=yes],\n       [ncbi_cv_cc_fdiagnostics_color_always=no])])\nif test $ncbi_cv_cc_fdiagnostics_color_always = yes; then\n   COLOR_DIAGNOSTICS=-fdiagnostics-color=always\nelse\n   COLOR_DIAGNOSTICS=\nfi\n\nCFLAGS=$orig_CFLAGS\nAC_LANG_POP(C)\n\nif test $ncbi_cv_cc_unsafe_math = yes; then\n   UNSAFE_MATH_FLAG=-funsafe-math-optimizations\nelse\n   UNSAFE_MATH_FLAG=\nfi\n\nif test $ncbi_cv_cc_sse4_1 = yes; then\n   SSE4_1_FLAG=-msse4.1\nelse\n   SSE4_1_FLAG=\nfi\n\nif test $ncbi_cv_cc_sse4_1 = yes -a $ncbi_cv_cc_aes = yes; then\n   AES_FLAG=-maes\nelse\n   AES_FLAG=\nfi\n\nAC_CACHE_CHECK([whether $CXX supports __builtin_bswap32],\n   ncbi_cv_cxx_builtin_bswap32,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM([],\n                       [[int i = 0x01234567; return __builtin_bswap32(i);]])],\n       [ncbi_cv_cxx_builtin_bswap32=yes], [ncbi_cv_cxx_builtin_bswap32=no])])\nif test $ncbi_cv_cxx_builtin_bswap32 = yes; then\n   AC_DEFINE(HAVE_BUILTIN_BSWAP, 1,\n      [Define to 1 if the C++ compiler supports __builtin_bswap32.])\nfi\n\nAC_CACHE_CHECK([whether $CXX supports __builtin_expect],\n   ncbi_cv_cxx_builtin_expect,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM([],\n                       [[int i = 0;  return __builtin_expect(i, 0);]])],\n       [ncbi_cv_cxx_builtin_expect=yes], [ncbi_cv_cxx_builtin_expect=no])])\nif test $ncbi_cv_cxx_builtin_expect = yes; then\n   AC_DEFINE(HAVE_BUILTIN_EXPECT, 1,\n      [Define to 1 if the C++ compiler supports __builtin_expect.])\nfi\n\n### Check for the availability of other packages\n### --------------------------------------------\n\n\nAC_MSG_CHECKING([whether in-house NCBI resources are available])\nif test -n \"$orig_NCBI\" -a -f \"$orig_NCBI/.ncbirc\" \\\n    -a -d /am/ncbiapdata/test_data; \\\nthen\n   NCBI_FEATURE(in-house-resources)\n   AC_MSG_RESULT(yes)\nelse\n   AC_MSG_RESULT(no)\nfi\n\n### Common-use system and miscellaneous libs\nif test -z \"${NETWORK_LIBS+set}\"; then\n   AC_CHECK_LIB(nsl, gethostbyname, [libnsl=-lnsl], [libnsl=])\n   AC_CHECK_LIB(socket, connect, [NETWORK_LIBS=\"-lsocket $libnsl\"],\n      [NETWORK_LIBS=$libnsl])\nfi\nAC_CACHE_CHECK([for res_search in -lresolv], ac_cv_lib_resolv_res_search,\n   [orig_LIBS=$LIBS\n    LIBS=\"-lresolv $NETWORK_LIBS $orig_LIBS\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM(\n       [[#include <resolv.h>]],\n       [[unsigned char ans[256];\n         int st = res_search(\"foo.bar\", 1, 1, ans, sizeof(ans));]])],\n       [ac_cv_lib_resolv_res_search=yes], [ac_cv_lib_resolv_res_search=no])\n    LIBS=$orig_LIBS])\nif test \"$ac_cv_lib_resolv_res_search\" = \"yes\"; then\n   RESOLVER_LIBS=-lresolv\nelse\n   RESOLVER_LIBS=\nfi\n\norig_LIBS=$LIBS\nLIBS=\"$NETWORK_LIBS $orig_LIBS\"\nAC_CHECK_FUNCS(inet_ntoa_r)\nAC_CACHE_CHECK([for getaddrinfo], ac_cv_func_getaddrinfo,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>]],\n       [[struct addrinfo *p; getaddrinfo(\"foo\", \"bar\", p, &p);]])],\n       [ac_cv_func_getaddrinfo=yes], [ac_cv_func_getaddrinfo=no])])\ntest \"$ac_cv_func_getaddrinfo\" = \"yes\" && \\\n  AC_DEFINE(HAVE_GETADDRINFO, 1,\n            [Define to 1 if you have the `getaddrinfo' function.])\nAC_CACHE_CHECK([for getnameinfo], ac_cv_func_getnameinfo,\n   [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n       [[#include <netdb.h>\n         #include <sys/types.h>\n         #include <sys/socket.h>]],\n       [[struct sockaddr p; char buf[256], buf2[256];\n         getnameinfo(&p, sizeof(p), buf, 256, buf2, 256, 0);]])],\n       [ac_cv_func_getnameinfo=yes], [ac_cv_func_getnameinfo=no])])\ntest \"$ac_cv_func_getnameinfo\" = \"yes\" && \\\n  AC_DEFINE(HAVE_GETNAMEINFO, 1,\n            [Define to 1 if you have the `getnameinfo' function.])\nAC_CHECK_FUNCS(freehostent gethostent_r getipnodebyaddr getipnodebyname \\\n               inet_ntop socketpair)\nLIBS=$orig_LIBS\n\n\n### Save original compiler/linker flags\norig_CPPFLAGS=\"$CPPFLAGS\"\norig_LDFLAGS=\"$LDFLAGS\"\norig_LIBS=\"$LIBS\"\n\n\n### Check for math functions that aren't always available\nAC_CHECK_FUNCS(erf)\n\nNCBI_CHECK_LIBS(KSTAT, kstat, kstat_open)\nNCBI_CHECK_LIBS(RPCSVC, rpcsvc, rstat)\nAC_LANG_PUSH(C)\n# Force C for this test because Sun WorkShop otherwise complains about\n# multiple extern \"C\" declarations of setkey.\nNCBI_CHECK_LIBS(CRYPT, crypt crypt_i, setkey)\nAC_LANG_POP(C)\ncase \"$host_os:$compiler\" in\n     linux*:ICC   ) ac_cv_search_dlopen=\"-ldl\" ;;\n     solaris*:GCC ) ac_cv_search_dlopen=\"-ldl\" ;;\n     darwin*      ) ac_cv_search_iconv=\"-liconv\" ;;\nesac\n# Temporarily drop -fsanitize= flags for this test, as some toolchains count\n# the support library's indirect use of libdt when building applications\n# but not when building shared libraries with --no-undefined.\norig_CXXFLAGS=$CXXFLAGS\norig_LDFLAGS=$LDFLAGS\nCXXFLAGS=`echo $CXXFLAGS | sed -e 's/[[^ ]]*fsanitize=[[^ ]]*//g'`\nLDFLAGS=`echo $LDFLAGS | sed -e 's/[[^ ]]*fsanitize=[[^ ]]*//g'`\nNCBI_CHECK_LIBS(DL, dl, dlopen)\nCXXFLAGS=$orig_CXXFLAGS\nLDFLAGS=$orig_LDFLAGS\norig_LIBS=\"$DL_LIBS $orig_LIBS\"\n# Left alone for the sake of anything using $(C_LIBS) in lieu of $(ORIG_LIBS).\n# DL_LIBS=\ndnl NCBI_CHECK_LIBS(UUID, uuid, uuid_generate)\nAC_SEARCH_LIBS(uuid_generate, uuid,\n   [NCBI_PACKAGE(UUID)\n    test \"x$ac_cv_search_uuid_generate\" = \"xnone required\" || \\\n       UUID_LIBS=$ac_cv_search_uuid_generate])\nLIBS=$orig_LIBS\ndnl NCBI_CHECK_LIBS(FUSE, fuse, fuse_loop)\nAC_SEARCH_LIBS(fuse_loop, fuse, [NCBI_PACKAGE(FUSE)])\nLIBS=$orig_LIBS\n# Temporarily drop OpenMP flags for this test, as some toolchains count\n# its support library's indirect use of librt when building applications\n# but not when building shared libraries with --no-undefined.\norig_CXXFLAGS=$CXXFLAGS\norig_LDFLAGS=$LDFLAGS\nCXXFLAGS=`echo $CXXFLAGS | sed -e 's/[[^ ]]*openmp[[^ ]]*//g'`\nLDFLAGS=`echo $LDFLAGS | sed -e 's/[[^ ]]*openmp[[^ ]]*//g'`\nNCBI_CHECK_LIBS(RT, rt posix4, clock_gettime)\nCXXFLAGS=$orig_CXXFLAGS\nLDFLAGS=$orig_LDFLAGS\nNCBI_CHECK_LIBS(DEMANGLE, demangle, cplus_demangle)\n# Add to (orig_)LIBS if present for the sake of corelib and the\n# following call to AC_CHECK_FUNCS.\nif test -n \"$DEMANGLE_LIBS$RT_LIBS\"; then\n    LIBS=\"$DEMANGLE_LIBS $RT_LIBS $LIBS\"\n    orig_LIBS=\"$DEMANGLE_LIBS $RT_LIBS $orig_LIBS\"\nfi\nAC_CHECK_FUNCS([clock_gettime nanosleep pthread_cond_timedwait_relative_np \\\n                pthread_condattr_setclock sched_yield])\nAC_CHECK_DECLS([CLOCK_MONOTONIC, CLOCK_SGI_CYCLE, CLOCK_REALTIME], [], [],\n   [[#include <time.h>\n     #ifdef HAVE_SYS_TIME_H\n     #  include <sys/time.h>\n     #endif]])\n\ndnl NCBI_CHECK_LIBS(ICONV, iconv, iconv)\n# We need to include <iconv.h>, since some implementations rename the symbols.\n# This logic adapted from Bruno Haible's iconv.m4.\nAC_CACHE_CHECK(for library containing iconv, ac_cv_search_iconv, [\n   ac_cv_search_iconv=no\n   AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM(\n         [[#include <stdlib.h>\n           #include <iconv.h>]],\n         [[iconv_t cd = iconv_open(\"\",\"\");\n           iconv(cd,NULL,NULL,NULL,NULL);\n           iconv_close(cd);]])],\n      [ac_cv_search_iconv=\"none required\"])\n   if test \"$ac_cv_search_iconv\" != \"none required\"; then\n      for l in iconv; do\n         LIBS=\"-l$l $orig_LIBS\"\n         AC_LINK_IFELSE(\n            [AC_LANG_PROGRAM(\n                [[#include <stdlib.h>\n                  #include <iconv.h>]],\n                [[iconv_t cd = iconv_open(\"\",\"\");\n                  iconv(cd,NULL,NULL,NULL,NULL);\n                  iconv_close(cd);]])],\n            [ac_cv_search_iconv=-l$l])\n         LIBS=\"$orig_LIBS\"\n      done\n   fi])\nif test \"x$ac_cv_search_iconv\" != xno; then\n   NCBI_PACKAGE(Iconv)\n   AC_DEFINE(HAVE_LIBICONV, 1,\n   [Define to 1 if ICONV is available, either in its own library or as part\n    of the standard libraries.])\n   AC_MSG_CHECKING([for iconv declaration])\n   AC_CACHE_VAL(am_cv_proto_iconv, [\n      AC_COMPILE_IFELSE([[\n#include <stdlib.h>\n#include <iconv.h>\nextern\n#ifdef __cplusplus\n\"C\"\n#endif\n#if defined(__STDC__) || defined(__cplusplus)\nsize_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n#else\nsize_t iconv();\n#endif\n]], am_cv_proto_iconv_arg1=\"\", am_cv_proto_iconv_arg1=\"const\")\n      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"])\n   am_cv_proto_iconv=`echo \"[$]am_cv_proto_iconv\" | tr -s ' ' | sed -e 's/( /(/'`\n   AC_MSG_RESULT([$]{ac_t:-\n       }[$]am_cv_proto_iconv)\n   AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,\n     [Define as const if the declaration of iconv() needs const.])\n   if test \"x$ac_cv_search_iconv\" != \"xnone required\"; then\n      ICONV_LIBS=$ac_cv_search_iconv\n   fi\nfi\n\n\n### Third-party libraries\n\n#### Set compiler prefix (empty for vendor compilers)\ncase \"$signature_compiler:$ac_cv_have_decl__LIBCPP_VERSION\" in\n   Clang:yes | LLVMGCC:yes )\n      compiler_pfx=\"${signature_compiler}-\"\n      compiler_vpfx=\"${signature_compiler}${signature_compiler_version}-\"\n      ;;\n   Clang:* | *[[GIK]]CC:* )\n      compiler_pfx=\"${compiler}-\"\n      compiler_vpfx=\"${compiler}${compiler_version}-\"\n      ;;\nesac\n\nusr_lib=['[/usr]*/lib/*[amdsprcv]*[23469]*']\nno_usr_lib=\"s,-L$usr_lib ,,g; s,-L/usr/lib/$multiarch ,,g\"\n\n: ${with_libunwind:=no}\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libunwind, LIBUNWIND, unwind,\n [[AC_LANG_PROGRAM([#include <unwind.h>\n                    #include <stdlib.h>],\n      [[_Unwind_Trace_Fn f; _Unwind_Backtrace(f, NULL);]])]])\nLIBS=\"$LIBUNWIND_LIBS $LIBS\"\norig_LIBS=\"$LIBUNWIND_LIBS $orig_LIBS\"\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libdw, LIBDW, dw,\n [[AC_LANG_PROGRAM([#include <elfutils/libdw.h>],\n      [[Dwarf* d = dwarf_begin(17, DWARF_C_READ);]])]])\nLIBS=\"$LIBDW_LIBS $LIBS\"\norig_LIBS=\"$LIBDW_LIBS $orig_LIBS\"\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(backward_cpp, BACKWARD_CPP, backward,\n [[AC_LANG_PROGRAM([#ifdef HAVE_LIBUNWIND\n                    #  define BACKWARD_HAS_UNWIND 1\n                    #else\n                    #  define BACKWARD_HAS_BACKTRACE 1\n                    #endif\n                    #ifdef HAVE_LIBDW\n                    #  define BACKWARD_HAS_DW 1\n                    #endif\n                    #include <backward.hpp>],\n      [[backward::StackTrace st; st.load_here(32);]])]],\n [], [], [$LIBUNWIND_INCLUDE $LIBDW_INCLUDE])\n\n\nif test \"$with_backward_cpp_sig\" = yes; then\n   AC_DEFINE(USE_LIBBACKWARD_SIG_HANDLING, 1,\n             [Define to allow backward-cpp to also handle signals.])\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB(z,\n [[AC_LANG_PROGRAM([#include <zlib.h>],\n      [[gzFile fp; char buf[1024]; int n = gzread(fp, buf, sizeof(buf))]])]])\nif test -z \"$Z_LIBS\"; then\n   zlocal=util/compress/zlib\n   AC_MSG_NOTICE([using local zlib copy in $zlocal])\n   Z_PATH=\"<$zlocal>\"\n   Z_INCLUDE=\"-I\\$(includedir)/$zlocal -I\\$(includedir0)/$zlocal\"\n   # Z_LIBS=\"-lz\"\n   Z_LIB=\"z\"\n   # AC_DEFINE(USE_LOCAL_ZLIB, 1, [Define to 1 if using a local copy of zlib.])\n   NCBI_PACKAGE(Z)\n   NCBI_PACKAGE(LocalZ)\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB(bz2,\n [[AC_LANG_PROGRAM([#include <bzlib.h>],\n      [[BZFILE* fp; char buf[1024]; int err;\n        int n = BZ2_bzRead(&err, fp, buf, sizeof(buf))]])]])\nif test -z \"$BZ2_LIBS\"; then\n   bzlocal=util/compress/bzip2\n   AC_MSG_NOTICE([using local bzlib copy in $bzlocal])\n   BZ2_PATH=\"<$bzlocal>\"\n   BZ2_INCLUDE=\"-I\\$(includedir)/$bzlocal -I\\$(includedir0)/$bzlocal\"\n   # BZ2_LIBS=\"-lbz2\"\n   BZ2_LIB=\"bz2\"\n   AC_DEFINE(USE_LOCAL_BZLIB, 1, [Define to 1 if using a local copy of bzlib.])\n   NCBI_PACKAGE(BZ2)\n   NCBI_PACKAGE(LocalBZ2)\nfi\n\nif test -d \"$LZO_PATH\"; then\n   NCBI_FIX_DIR(LZO_PATH)\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(lzo, LZO, lzo2,\n [[AC_LANG_PROGRAM([#include <lzo/lzo1x.h>],\n      [[lzo_uint32 c = lzo_crc32(0, (const unsigned char*)\"foo\", 3);]])]])\nif test -n \"$LZO_LIBS\" -a \"x$with_bin_release\" = xyes \\\n        -a \\( -f \"$LZO_PATH/lib$bit64_sfx/liblzo2-static.a\" \\\n              -o -f \"$LZO_PATH/lib/liblzo2-static.a\" \\); then\n   LZO_LIBS=\"$LZO_LIBPATH -llzo2-static\"\nfi\n\nif test -z \"$PCRE_PATH\"  &&  pcre-config --version >/dev/null 2>&1; then\n    p=`pcre-config --prefix`\n    test \"x$p\" = \"x/usr\"  ||  PCRE_PATH=$p\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(pcre,\n [[AC_LANG_PROGRAM([#include <pcre.h>],\n   [[const char*s[]={\"x\"}; pcre* p; pcre_extra* x = pcre_study(p, 1, s);]])]])\nif test -z \"$PCRE_LIBS\"; then\n   pcrelocal=util/regexp\n   AC_MSG_NOTICE([using local PCRE copy in $pcrelocal])\n   PCRE_PATH=\"<$pcrelocal>\"\n   PCRE_INCLUDE=\"-I\\$(includedir)/$pcrelocal -I\\$(includedir0)/$pcrelocal\"\n   # PCRE_LIBS=\"-lregexp\"\n   # PCREPOSIX_LIBS=\"-lregexp\"\n   PCRE_LIB=\"regexp\"\n   AC_DEFINE(USE_LOCAL_PCRE, 1, [Define to 1 if using a local copy of PCRE.])\n   NCBI_PACKAGE(PCRE)\n   NCBI_PACKAGE(LocalPCRE)\nelse\n   PCREPOSIX_LIBS=`echo \"$PCRE_LIBS\" | sed -e 's/-lpcre/-lpcreposix -lpcre/'`\nfi\n\n## SSL/TLS libraries (and supporting libraries)\nif test \"x${with_mbedtls-no}\" != xno; then\n   case \"$with_mbedtls\" in\n      yes ) ;;\n      *   ) MBEDTLS_PATH=$with_mbedtls ;;\n   esac\n   d=\"$MBEDTLS_PATH/${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n   if test -d \"$d\"; then\n      MBEDTLS_PATH=$d\n   fi\n   if test -d \"$MBEDTLS_PATH\"; then\n      NCBI_FIX_DIR(MBEDTLS_PATH)\n   fi\n   NCBI_CHECK_THIRD_PARTY_LIB(mbedtls,\n      [[AC_LANG_PROGRAM([#include <mbedtls/ssl.h>],\n           [[mbedtls_ssl_context ssl; mbedtls_ssl_init(&ssl);]])]],\n      [[-lmbedx509 -lmbedcrypto $Z_LIBS]])\n   if test -n \"$MBEDTLS_LIBS\" -a -f \"$MBEDTLS_PATH/lib/libmbedtls-static.a\" \\\n      -a \"x$with_static_mbedtls\" = xyes; then\n      MBEDTLS_LIBS=\"-L$MBEDTLS_PATH/lib -lmbedtls-static -lmbedx509-static -lmbedcrypto-static $Z_LIBS\"\n   fi\nfi\nif test -z \"$MBEDTLS_LIBS\"; then\n   mbedtls_local=connect/mbedtls\n   AC_MSG_NOTICE([using local mbedTLS copy in $mbedtls_local])\n   MBEDTLS_INCLUDE=\"\"\n   MBEDTLS_LIBS=\"$Z_LIBS\"\n   NCBI_PACKAGE(MBEDTLS)\nfi\n\nif test \"x$with_gmp\" != xno; then\n   case \"$with_gmp\" in\n      yes | '' ) ;;\n      *        ) GMP_PATH=$with_gmp ;;\n   esac\n   for pfx in \"$compiler_vpfx\" \"$compiler_pfx\" \"\" ; do\n      vpath=$GMP_PATH/$pfx${DEBUG_SFX}${mt_sfx}${bit64_sfx}\n      if test -d \"$vpath\" ; then\n         GMP_PATH=$vpath\n         break\n      fi\n   done\n   if test -d \"$GMP_PATH\"; then\n      NCBI_FIX_DIR(GMP_PATH)\n   fi\n   NCBI_CHECK_THIRD_PARTY_LIB(gmp,\n      [[AC_LANG_PROGRAM([#include <gmp.h>],\n           [[mpz_t x; mpz_init(x);]])]])\nfi\nif test \"$with_gmp\" = no; then\n   AS_UNSET(GMP_INCLUDE)\n   AS_UNSET(GMP_LIBS)\nelse\n   NCBI_PACKAGE(GMP)\nfi\n\ncase \"$with_gcrypt\" in\n   no )       ac_cv_path_LIBGCRYPT_CONFIG=no ;;\n   yes | '' )                                ;;\n   * )        GCRYPT_PATH=$with_gcrypt       ;;\nesac\nif test -d \"$GCRYPT_PATH\"; then\n   NCBI_FIX_DIR(GCRYPT_PATH)\nfi\nAC_PATH_PROG(LIBGCRYPT_CONFIG, libgcrypt-config, [], [${GCRYPT_BIN-$GCRYPT_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/bin}:$GCRYPT_PATH/bin${bit64_sfx}:$GCRYPT_PATH/bin:$PATH])\n\nif test \"x$with_gcrypt\" != xno; then\n   if test -x \"$LIBGCRYPT_CONFIG\"; then\n      if test -z \"$GCRYPT_PATH\"; then\n         p=`libgcrypt-config --prefix`\n         test \"x$p\" = \"x/usr\"  ||  GCRYPT_PATH=$p\n      fi\n      NCBI_RPATHIFY_OUTPUT(GCRYPT_LIBPATH,\n        [$LIBGCRYPT_CONFIG --exec-prefix], [s,^,-L,; s,$,/lib,;])\n      GCRYPT_INCLUDE=`$LIBGCRYPT_CONFIG --cflags`\n      GCRYPT_CONFIG_LIBS=\"`$LIBGCRYPT_CONFIG --libs` $Z_LIBS\"\n   fi\nelse\n   AS_UNSET(GCRYPT_CONFIG_LIBS)\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(gcrypt,\n [[AC_LANG_PROGRAM([[#include <gcrypt.h>\n                     #include <pthread.h>\n                     #include <errno.h>\n                     GCRY_THREAD_OPTION_PTHREAD_IMPL;]],\n   [[gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);]])]],\n $GCRYPT_CONFIG_LIBS)\nif test \"x$with_gcrypt\" != xno -a -n \"$GCRYPT_CONFIG_LIBS\"; then\n   NCBI_RPATHIFY_OUTPUT(GCRYPT_LIBS, [echo $GCRYPT_CONFIG_LIBS], [$no_usr_lib])\nfi\n\nif test \"x$with_nettle\" != xno; then\n   case \"$with_nettle\" in\n      yes | '' ) ;;\n      *        ) NETTLE_PATH=$with_nettle ;;\n   esac\n   if test -d \"$NETTLE_PATH\"; then\n      NCBI_FIX_DIR(NETTLE_PATH)\n   fi\n   if test -d \"$NETTLE_PATH/lib$bit64_sfx\"; then\n      NETTLE_LIBDIR=$NETTLE_PATH/lib$bit64_sfx\n   else\n      NETTLE_LIBDIR=$NETTLE_PATH/lib\n   fi\n   for pfx in \"$compiler_vpfx\" \"$compiler_pfx\" \"\" ; do\n      vpath=$NETTLE_PATH/$pfx${DEBUG_SFX}${mt_sfx}${bit64_sfx}\n      if test -d \"$vpath\" ; then\n         NETTLE_LIBDIR=$vpath/lib\n         break\n      fi\n   done\n   if test -d \"$NETTLE_LIBDIR\"; then\n      NCBI_FIX_DIR(NETTLE_LIBDIR)\n      NCBI_RPATHIFY(NETTLE_LIBPATH, $NETTLE_LIBDIR)\n   fi\n   NCBI_CHECK_THIRD_PARTY_LIB_EX(nettle, NETTLE, hogweed,\n      [[AC_LANG_PROGRAM([#include <nettle/sexp.h>],\n           [[struct sexp_iterator it;\n             sexp_iterator_first(&it, 0, (const uint8_t*) NULL);]])]],\n      [-lnettle], [$GMP_LIBS])\nfi\nif test \"$with_nettle\" = no; then\n   AS_UNSET(NETTLE_INCLUDE)\n   AS_UNSET(NETTLE_LIBS)\nelse\n   NCBI_PACKAGE(NETTLE)\nfi\n\ncase \"${with_gnutls=no}\" in\n   no  ) ac_cv_path_LIBGNUTLS_CONFIG=no ;;\n   yes )                                ;;\n   *   ) GNUTLS_PATH=$with_gnutls       ;;\nesac\nif test -d \"$GNUTLS_PATH\"; then\n   NCBI_FIX_DIR(GNUTLS_PATH)\n   gnutls_config_path=${GNUTLS_BIN-$GNUTLS_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/bin}:$GNUTLS_PATH/bin${bit64_sfx}:$GNUTLS_PATH/bin\nelse\n   gnutls_config_path=$PATH\nfi\nAC_PATH_PROG(LIBGNUTLS_CONFIG, libgnutls-config, [], [$gnutls_config_path])\n\nif test \"x$with_gnutls\" != xno; then\n   if test -x \"$LIBGNUTLS_CONFIG\"; then\n      if test -z \"$GNUTLS_PATH\"; then\n         p=`$LIBGNUTLS_CONFIG --prefix`\n         test \"x$p\" = \"x/usr\"  ||  GNUTLS_PATH=$p\n      fi\n   else\n      LIBGNUTLS_CONFIG=\"eval PKG_CONFIG_PATH=\\\"$GNUTLS_PATH/lib$bit64_sfx/pkgconfig:$GNUTLS_PATH/lib/pkgconfig\\\" pkg-config gnutls --static\"\n      $LIBGNUTLS_CONFIG --exists >/dev/null 2>&1 ||  LIBGNUTLS_CONFIG=no\n   fi\n   case \"$LIBGNUTLS_CONFIG\" in\n       eval\\ *)\n           NCBI_RPATHIFY_OUTPUT(GNUTLS_LIBPATH,\n             [$LIBGNUTLS_CONFIG --libs-only-L])\n           GNUTLS_CONFIG_LIBS=`$LIBGNUTLS_CONFIG --libs-only-l`\n           GNUTLS_CONFIG_LIBS=\"$GNUTLS_LIBPATH $GNUTLS_CONFIG_LIBS $Z_LIBS\"\n           ;;\n       no)\n           ;;\n       *)\n           NCBI_RPATHIFY_OUTPUT(GNUTLS_LIBPATH,\n             [$LIBGNUTLS_CONFIG --exec-prefix], [s,^,-L,; s,$,/lib,;])\n           GNUTLS_CONFIG_LIBS=\"`$LIBGNUTLS_CONFIG --libs` $Z_LIBS\"\n           ;;\n   esac\n\n   if test \"x$LIBGNUTLS_CONFIG\" != xno; then\n      GNUTLS_INCLUDE=`$LIBGNUTLS_CONFIG --cflags`\n   fi\nelse\n   AS_UNSET(GNUTLS_CONFIG_LIBS)\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(gnutls,\n [[AC_LANG_PROGRAM([[#include <gnutls/gnutls.h>]],\n   [[gnutls_session_t s; gnutls_init(&s, GNUTLS_CLIENT);]])]],\n [$GNUTLS_CONFIG_LIBS], [$GCRYPT_LIBS $NETTLE_LIBS $GMP_LIBS])\nif test \"x$with_gnutls\" != xno; then\n   AC_CHECK_FUNCS([gnutls_certificate_set_verify_function \\\n                   gnutls_record_disable_padding gnutls_rnd])\n   AC_CHECK_HEADERS([gnutls/abstract.h])\n   if test -n \"$GNUTLS_CONFIG_LIBS\"; then\n      NCBI_RPATHIFY_OUTPUT(GNUTLS_LIBS, [echo $GNUTLS_CONFIG_LIBS],\n         [$no_usr_lib])\n   else\n      GNUTLS_LIBS=\"$GNUTLS_LIBS $NETTLE_LIBS $GMP_LIBS\"\n   fi\n   # Conservatively build against gcrypt if available even when gnutls\n   # uses nettle instead, because gcrypt needs explicit initialization\n   # to be thread-safe, but gnutls's headers don't indicate which\n   # underlying crypto library it's actually using.\n   case \"$GNUTLS_INCLUDE\" in\n       *$GCRYPT_INCLUDE* ) ;;\n       *                 ) GNUTLS_INCLUDE=\"$GNUTLS_INCLUDE $GCRYPT_INCLUDE\" ;;\n   esac\n   case \"$GNUTLS_LIBS\" in\n       *\\ -lgcrypt* ) ;;\n       *            ) GNUTLS_LIBS=\"$GNUTLS_LIBS $GCRYPT_LIBS\" ;;\n   esac\n   if test \"$with_static_gnutls\" = yes; then\n      dirs=''\n      sep=''\n      static_libs=''\n      for x in $GNUTLS_LIBS; do\n         case $x in\n            -L* ) dirs=\"$dirs `echo _$x | cut -c4-`\" ;;\n            -l* )\n                want=lib`echo _$x | cut -c4-`-static.a\n                for d in $dirs; do\n                   if test -f $d/$want; then\n                      x=$x-static\n                      break\n                   fi\n                done\n                ;;\n         esac\n         static_libs=$static_libs$sep$x\n         sep=' '\n      done\n      GNUTLS_LIBS=\"$static_libs $ICONV_LIBS\"\n   fi\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(openssl, OPENSSL, ssl,\n [[AC_LANG_PROGRAM([[#include <openssl/ssl.h>]],\n   [[SSL_library_init();]])]],\n -lcrypto)\n\nOPENSSL_STATIC_LIBS=$OPENSSL_LIBS\nfor d in `echo \" $OPENSSL_LIBS\" | fmt -w 1 | sed -ne 's/^ *-L//p'` \\\n   /usr/local/lib${bit64_sfx} /usr/local/lib /usr/lib${bit64_sfx} /usr/lib; do\n   if test -f $d/libssl.a -a -f $d/libcrypto.a; then\n      OPENSSL_STATIC_LIBS=\"$d/libssl.a $d/libcrypto.a\"\n      break\n   elif test -f $d/libssl.so -o -f $d/libssl.dylib; then\n      break\n   fi\ndone\n\nNETWORK_LIBS=\"$GNUTLS_LIBS $MBEDTLS_LIBS $NETWORK_LIBS\"\n\ncase \"$with_krb5\" in\n   no )       ac_cv_path_KRB5_CONFIG=no    ;;\n   yes | '' ) : ${KRB5_PATH=/usr/kerberos} ;;\n   * )        KRB5_PATH=$with_krb5         ;;\nesac\nAC_PATH_PROG(KRB5_CONFIG, krb5-config, [], [${KRB5_BIN-$KRB5_PATH/bin}:$PATH])\n\nif test \"x$with_krb5\" != xno; then\n   if test -x \"$KRB5_CONFIG\"; then\n      KRB5_PATH=`$KRB5_CONFIG --prefix`\n      KRB5_INCLUDE=`$KRB5_CONFIG --cflags | \\\n         sed -e 's/$/ /; s,-I/usr/include ,,'`\n      KRB5_CONFIG_LIBS=`$KRB5_CONFIG --libs gssapi | \\\n         sed -e 's/^/ /; s/ -[[^Ll]][[^ ]]*//g'`\n   fi\nelse\n   dnl AS_UNSET(KRB5_CONFIG_LIBS)\n   KRB5_CONFIG_LIBS=$KRB5_LIBS\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(krb5, KRB5, gssapi_krb5,\n [[AC_LANG_PROGRAM([[#include <time.h>\n#ifdef HAVE_INTTYPES_H\n#  include <inttypes.h>\n#endif\nextern \"C\" {\n#include <gssapi/gssapi_krb5.h>\n}]],\n   [[OM_uint32 min_stat;\n     gss_buffer_desc buf;\n     gss_release_buffer(&min_stat, &buf);]])]],\n $KRB5_CONFIG_LIBS)\nif test \"x$with_krb5\" != xno; then\n   AC_CHECK_FUNCS([error_message])\n   AC_CHECK_HEADERS([com_err.h roken.h])\n   NCBI_RPATHIFY_OUTPUT(KRB5_LIBS, [echo $KRB5_CONFIG_LIBS], [$no_usr_lib])\nfi\n\n\nNCBI_CHECK_THIRD_PARTY_LIB(curl,\n   [AC_LANG_PROGRAM([#include <curl/curl.h>],\n       [char* v = curl_version();])])\n\n\n## SYBASE libraries\n\nNETWORK_PURE_LIBS=\"$NETWORK_LIBS\"\nif test \"$with_sybase\" != \"no\" ; then\n   resolve_sybase=true\n   default_pointer=default-${NCBI_PLATFORM_BITS}bit\n   : ${with_sybase_new:=\"no\"}\n   case \"$host_os\" in\n      linux* )\n         : ${with_sybase_local:=yes}\n         ;;\n      * )\n         if test -d \"$net_sybase_root\" ; then\n            : ${with_sybase_local:=no}\n         else\n            : ${with_sybase_local:=yes}\n         fi\n         ;;\n   esac\n\n   if test \"$with_sybase_local\" != \"no\" ; then\n      if test \"$with_sybase_local\" = \"yes\" ; then\n         if test -n \"$SYBASE_PATH\" ; then\n            with_sybase_local=$SYBASE_PATH\n         else\n            if test \"$with_sybase_new\" = \"yes\" ; then\n               with_sybase_local=$local_sybase_root/new\n            elif test -f \"$local_sybase_root/$default_pointer\" ; then\n               with_sybase_local=`cat $local_sybase_root/$default_pointer`\n               resolve_sybase=false\n            else\n               with_sybase_local=$local_sybase_root/current\n            fi\n            if test -d \"$with_sybase_local$NCBI_PLATFORM_BITS\" ; then\n               with_sybase_local=$with_sybase_local$NCBI_PLATFORM_BITS\n            fi\n         fi # default paths\n      fi # no command-line path\n      if test -d \"$with_sybase_local\" ; then\n         SYBASE_PATH=$with_sybase_local\n         SYBASE_LCL_PATH=\n      else\n         with_sybase_local=no\n      fi\n   fi\n\n   if test \"$with_sybase_local\" = \"no\" ; then\n      if test \"$with_sybase_new\" = \"yes\" ; then\n         if test -d \"$net_sybase_root/new$NCBI_PLATFORM_BITS\" ; then\n            SYBASE_LCL_PATH=$local_sybase_root/new$NCBI_PLATFORM_BITS\n            SYBASE_PATH=$net_sybase_root/new$NCBI_PLATFORM_BITS\n         elif test -d \"$net_sybase_root/new\" ; then\n            SYBASE_LCL_PATH=$local_sybase_root/new\n            SYBASE_PATH=$net_sybase_root/new\n         else\n            with_sybase_new=no\n         fi\n      fi\n\n      if test -z \"$SYBASE_PATH\" ; then\n         if test -f \"$net_sybase_root/$default_pointer\" ; then\n            SYBASE_LCL_PATH=\n            SYBASE_PATH=`cat $local_sybase_root/$default_pointer`\n            resolve_sybase=false\n         elif test -d \"$net_sybase_root/current$NCBI_PLATFORM_BITS\" ; then\n            SYBASE_LCL_PATH=$local_sybase_root/current$NCBI_PLATFORM_BITS\n            SYBASE_PATH=$net_sybase_root/current$NCBI_PLATFORM_BITS\n         elif test -d \"$net_sybase_root/current\" ; then\n            SYBASE_LCL_PATH=$local_sybase_root/current\n            SYBASE_PATH=$net_sybase_root/current\n         else\n            SYBASE_LCL_PATH=\n            SYBASE_PATH=$SYBASE\n         fi\n      fi\n   fi\n\n   # Lock in the version we found, ignoring symlinks further up\n   case \"$SYBASE_PATH\" in\n      */[[1-9]]* ) resolve_sybase=false ;;\n   esac\n   if test -d \"$SYBASE_PATH\"  &&  $resolve_sybase; then\n      # SYBASE_PATH_=`cd $SYBASE_PATH && /bin/pwd`\n      SYBASE_PATH_=`ls -ld $SYBASE_PATH | sed -ne 's/.* -> //p'`\n      case \"$SYBASE_PATH_\" in\n         '' ) ;;\n         /* )\n            SYBASE_VERSION=`basename $SYBASE_PATH_`\n            SYBASE_PATH=`dirname $SYBASE_PATH`/$SYBASE_VERSION\n            test -d \"$SYBASE_PATH\"  ||  SYBASE_PATH=$SYBASE_PATH_\n            ;;\n         * )\n            orig_parent=`dirname $SYBASE_PATH`\n            SYBASE_VERSION=`basename $SYBASE_PATH_`\n            SYBASE_PATH=$orig_parent/$SYBASE_VERSION\n            test -d \"$SYBASE_PATH\"  ||  SYBASE_PATH=$orig_parent/$SYBASE_PATH_\n            ;;\n      esac\n   fi\n\n   if test -d \"$SYBASE_LCL_PATH\"  &&  $resolve_sybase ; then\n      # SYBASE_LCL_PATH_=`cd $SYBASE_LCL_PATH && /bin/pwd`\n      SYBASE_LCL_PATH_=`ls -ld $SYBASE_LCL_PATH | sed -ne 's/.* -> //p'`\n      case \"$SYBASE_LCL_PATH_\" in\n         '' ) ;;\n         /* )\n            SYBASE_LCL_VERSION=`basename $SYBASE_LCL_PATH_`\n            SYBASE_LCL_PATH=`dirname $SYBASE_LCL_PATH`/$SYBASE_LCL_VERSION\n            test -d \"$SYBASE_LCL_PATH\"  ||  SYBASE_LCL_PATH=$SYBASE_LCL_PATH_\n            ;;\n         * )\n            orig_parent=`dirname $SYBASE_LCL_PATH`\n            SYBASE_LCL_VERSION=`basename $SYBASE_LCL_PATH_`\n            SYBASE_LCL_PATH=$orig_parent/$SYBASE_LCL_VERSION\n            test -d \"$SYBASE_LCL_PATH\"  || \\\n               SYBASE_LCL_PATH=$orig_parent/$SYBASE_LCL_PATH_\n            ;;\n      esac\n   elif test -n \"$SYBASE_LCL_PATH\" ; then\n      SYBASE_LCL_PATH=`dirname $SYBASE_LCL_PATH`/$SYBASE_VERSION\n   fi\n\n   if test -n \"$SYBASE_VERSION\" -a -n \"$SYBASE_LCL_VERSION\" \\\n        -a \"$SYBASE_VERSION\" != \"$SYBASE_LCL_VERSION\" ; then\n      AC_MSG_WARN([ignoring inconsistent local Sybase symlink: $SYBASE_LCL_VERSION vs. $SYBASE_VERSION])\n      SYBASE_LCL_PATH=`dirname $SYBASE_LCL_PATH`/$SYBASE_VERSION\n   fi\n\n   if test -n \"$SYBASE\" ; then\n      if test -d \"$net_sybase_root\" -o -d \"$local_sybase_root\" ; then\n         case $SYBASE in\n            $net_sybase_root/* | $local_sybase_root/* ) ;;\n            * ) AC_MSG_WARN([ignoring non-standard SYBASE setting: $SYBASE]) ;;\n            # Ignored regardless, but standard values are not so concerning.\n         esac\n      fi\n   fi\n\n   if test -f \"$SYBASE_PATH/SYBASE.env\"; then\n      ocs=`sed -ne 's:^SYBASE_OCS=:/:p' \"$SYBASE_PATH/SYBASE.env\"`\n   else\n      ocs=\n   fi\n   if test -d \"$SYBASE_PATH$ocslib$bit64_sfx\"; then\n      SYBASE_LIBPATH=\"$SYBASE_PATH$ocs/lib$bit64_sfx\"\n   else\n      SYBASE_LIBPATH=\"$SYBASE_PATH$ocs/lib\"\n   fi\n   syb_sfx=$bit64_sfx\n   if test -f \"$SYBASE_LIBPATH/libsybct$syb_sfx.a\"; then\n      syb_pfx=syb\n   else\n      syb_pfx=\n   fi\n\n   if test \"$with_mt\" = \"yes\" ; then\n      AC_CACHE_CHECK([for reentrant Sybase libraries], ncbi_cv_lib_sybase_r,\n         [if test -f \"$SYBASE_LIBPATH/lib${syb_pfx}ct_r$bit64_sfx.so\"; then\n             ncbi_cv_lib_sybase_r=yes\n          else\n             ncbi_cv_lib_sybase_r=no\n          fi])\n      if test $ncbi_cv_lib_sybase_r = yes; then\n         syb_sfx=_r$bit64_sfx\n      fi\n   fi\n   case \"$host_os\" in\n      linux*) sybtcl=-lsybtcl$syb_sfx; sybtli=\"\" ;;\n      *)      sybtcl=-l${syb_pfx}tcl$syb_sfx; sybtli=-ltli$syb_sfx ;;\n   esac\n   test -f \"$SYBASE_LIBPATH/libtli.so\" || sybtli=\n\n   # quick-patch for the bad \"tli\" lib (Solaris8/Intel specific)\n   case \"$host_os:$host_vendor\" in\n      solaris*:pc )  : ${sybase_sol8pc_patch:=\"yes\"} ;;\n   esac\n   if test \"$sybase_sol8pc_patch\" = \"yes\" ; then\n      sybtli=\"-ltli_orig$syb_sfx -ltli$syb_sfx\"\n      SYBASE_NETWORK_LIBS=\"-ltli$syb_sfx $NETWORK_LIBS\"\n   else\n      SYBASE_NETWORK_LIBS=\"$NETWORK_LIBS\"\n   fi\n\n   if test -f \"$SYBASE_LIBPATH/libsybunic${bit64_sfx}.a\"; then\n      sybunic=-lsybunic${bit64_sfx}\n   fi\n\n   test -n \"$bit64_sfx\"  &&  SYBASE_INCLUDE=\"-DSYB_LP64\"\n   SYBASE_LIBLIST=\"-l${syb_pfx}blk$syb_sfx -l${syb_pfx}ct$syb_sfx\"\n   SYBASE_LIBLIST=\"$SYBASE_LIBLIST -l${syb_pfx}cs$syb_sfx $sybtcl\"\n   SYBASE_LIBLIST=\"$SYBASE_LIBLIST -l${syb_pfx}comn$syb_sfx\"\n   SYBASE_LIBLIST=\"$SYBASE_LIBLIST -l${syb_pfx}intl$syb_sfx $sybunic\"\n   SYBASE_DLLLIST=\"$sybtli\"\n\n   # deduce conf.macro: SYBASE_INCLUDE, SYBASE_LIBS, SYBASE_DLLS, SYBASE_DBLIBS\n   SYBASE_INCLUDE=\"-I$SYBASE_PATH$ocs/include $SYBASE_INCLUDE\"\n   if test -z \"$SYBASE_LCL_PATH\" ; then\n      NCBI_RPATHIFY(SYBASE_LPATH, $SYBASE_LIBPATH)\n   else\n      SYBASE_LCL_LIBPATH=\"$SYBASE_LCL_PATH$ocs/${sybase_lib}\"\n      NCBI_RPATHIFY(SYBASE_LPATH, $SYBASE_LCL_LIBPATH $SYBASE_LIBPATH)\n      SYBASE_INCLUDE=\"-I$SYBASE_LCL_PATH$ocs/include $SYBASE_INCLUDE\"\n   fi\n   SYBASE_LIBS=\"$SYBASE_LPATH $SYBASE_LIBLIST\"\n   SYBASE_DBLIBS=\"$SYBASE_LPATH $SYBASE_DBLIBS\"\n   SYBASE_DLLS=\"$SYBASE_DLLLIST\"\n\n   AC_CACHE_CHECK([for Sybase${SYBASE_PATH:+ in $SYBASE_PATH}],\n      ncbi_cv_lib_sybase,\n      [CPPFLAGS=\"$SYBASE_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$SYBASE_LIBS $SYBASE_DLLS $SYBASE_NETWORK_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <ctpublic.h>]],\n          [[CS_RETCODE i = ct_init(0,0);  i = cs_ctx_global(0,0); ]])],\n          [ncbi_cv_lib_sybase=yes], [ncbi_cv_lib_sybase=no])])\n\n   if test \"$ncbi_cv_lib_sybase\" = yes; then\n      NCBI_PACKAGE(Sybase)\n      AC_DEFINE(HAVE_LIBSYBASE, 1,\n                [Define to 1 if SYBASE libraries are available.])\n      if test \"$with_mt\" = \"yes\" -a \"$ncbi_cv_lib_sybase_r\" = \"yes\"; then\n         AC_DEFINE(HAVE_SYBASE_REENTRANT, 1,\n                   [Define to 1 if SYBASE has reentrant libraries.])\n      fi\n\n      SYBASE_DBLIBS=\"$SYBASE_LPATH -lsybdb${bit64_sfx} $sybunic\"\n      AC_CACHE_CHECK([for Sybase DBLib], ncbi_cv_lib_sybdb,\n         [CPPFLAGS=\"$SYBASE_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$SYBASE_DBLIBS $SYBASE_LIBS $SYBASE_DLLS $SYBASE_NETWORK_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n             [[\n              #include <sybfront.h>\n              #include <sybdb.h>\n             ]],\n             [[\n              LOGINREC*  x_login     = 0;\n              DBPROCESS* x_dbproc    = dbopen(x_login, (char*) \"SRV_NAME\");\n             ]])],\n             [ncbi_cv_lib_sybdb=yes], [ncbi_cv_lib_sybdb=no])])\n      if test \"$ncbi_cv_lib_sybdb\" = yes; then\n         NCBI_PACKAGE(DBLib)\n         AC_DEFINE(HAVE_LIBSYBDB, 1,\n                   [Define to 1 if SYBASE DBLib is available.])\n      else\n         SYBASE_DBLIBS=\n      fi\n      # apply the Sybase patch to $NETWORK_LIBS\n      if test \"$sybase_sol8pc_patch\" = \"yes\" ; then\n         NETWORK_LIBS=\"$SYBASE_LPATH $SYBASE_NETWORK_LIBS\"\n      fi\n   else\n      NCBI_MISSING_PACKAGE(sybase)\n   fi\nfi # with_sybase != no?\n\nif test \"$with_sybase\" = no; then\n   SYBASE_PATH=\"No_Sybase\"\n   SYBASE_INCLUDE=\n   SYBASE_LIBS=\n   SYBASE_DLLS=\n   SYBASE_DBLIBS=\nfi\n\nSYBASE_LPATH=\nSYBASE_LCL_LIBPATH=\nSYBASE_LIBLIST=\nSYBASE_DLLLIST=\nSYBASE_LIBPATH=\n\n\n## FreeTDS libraries\nfreetds=\nif test \"$with_ftds\" != \"no\" ; then\n   ftds_ver=95\n   try_local=yes\n   case \"$with_ftds\" in\n      64 | 0.64 )\n         ftds_ver=64\n         ;;\n      95 | 0.95 | yes | '' )\n         ;;\n      100 | 1.00 )\n         ftds_ver=100\n         ;;\n      * )\n         FTDS_PATH=$with_ftds\n         try_local=no\n         ;;\n   esac\n   : ${FTDS_CTLIBS:=\"-lct -ltds $NETWORK_LIBS\"}\n   NCBI_RPATHIFY(FTDS_CTLIBS,   $FTDS_PATH/lib,      [ ]$FTDS_CTLIBS)\n   FTDS_INCLUDE=\"-I$FTDS_PATH/include\"\n   NCBI_LOCAL_FTDS(64)\n   NCBI_LOCAL_FTDS(95)\n   NCBI_LOCAL_FTDS(100)\n   if test -n \"$freetds\" ; then\n      FTDS_LIB=\"\\$(FTDS${ftds_ver}_LIB)\"\n      FTDS_LIBS=\"\\$(FTDS${ftds_ver}_LIBS)\"\n      FTDS_INCLUDE=\"\\$(FTDS${ftds_ver}_INCLUDE)\"\n      if test \"$with_ftds_renamed\" != \"no\" ; then\n          AC_DEFINE(NCBI_FTDS_RENAME_SYBDB, 1,\n                    [Rename DBLIB symbols in FTDS to avoid name clash with Sybase DBLIB.])\n      fi\n      AC_MSG_NOTICE([Using bundled FreeTDS (version $ftds_ver) from $FTDS_PATH])\n   else\n      FTDS_LIBS=\"$FTDS_CTLIBS\"\n      AC_CACHE_CHECK([for FreeTDS${FTDS_PATH:+ in $FTDS_PATH}],\n         ncbi_cv_lib_freetds,\n         [CPPFLAGS=\"$FTDS_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$FTDS_LIBS $NETWORK_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n            [[\n             #include <sybdb.h>\n             #include <tds.h>\n            ]],\n            [[\n             LOGINREC*  x_login     = 0;\n             DBPROCESS* x_dbproc    = dbopen(x_login, (char*) \"SRV_NAME\");\n             TDSLOGIN*  x_tds_login = 0;\n             /* TDSSOCKET* x_sock      = tds_connect(x_tds_login); */\n             tds_set_timeouts(x_tds_login, 0, 0, 0);\n            ]])],\n            [ncbi_cv_lib_freetds=yes], [ncbi_cv_lib_freetds=no])])\n      if test \"$ncbi_cv_lib_freetds\" = \"no\"; then\n         # Don't panic when using partial trees lacking dbapi/driver/ftdsN.\n         NCBI_MISSING_PACKAGE(ftds)\n      fi\n   fi\nfi\nif test \"$with_ftds\" = \"no\" ; then\n   FTDS_PATH=\n   FTDS_INCLUDE=\n   FTDS_LIBS=\n   FTDS_LIB=\n   FTDS64_INCLUDE=\n   FTDS64_LIBS=\n   FTDS64_LIB=\n   FTDS64_CTLIB_INCLUDE=\n   FTDS64_CTLIB_LIBS=\n   FTDS64_CTLIB_LIB=\n   FTDS95_INCLUDE=\n   FTDS95_LIBS=\n   FTDS95_LIB=\n   FTDS95_CTLIB_INCLUDE=\n   FTDS95_CTLIB_LIBS=\n   FTDS95_CTLIB_LIB=\n   FTDS100_INCLUDE=\n   FTDS100_LIBS=\n   FTDS100_LIB=\n   FTDS100_CTLIB_INCLUDE=\n   FTDS100_CTLIB_LIBS=\n   FTDS100_CTLIB_LIB=\n   freetds=\nelse\n   AC_DEFINE(HAVE_LIBFTDS, 1,\n             [Define to 1 if FreeTDS libraries are available.])\n   NCBI_PACKAGE(FreeTDS)\nfi\nAC_SUBST(FTDS64_INCLUDE)\nAC_SUBST(FTDS64_LIBS)\nAC_SUBST(FTDS64_LIB)\nAC_SUBST(FTDS64_CTLIB_INCLUDE)\nAC_SUBST(FTDS64_CTLIB_LIBS)\nAC_SUBST(FTDS64_CTLIB_LIB)\nAC_SUBST(FTDS95_INCLUDE)\nAC_SUBST(FTDS95_LIBS)\nAC_SUBST(FTDS95_LIB)\nAC_SUBST(FTDS95_CTLIB_INCLUDE)\nAC_SUBST(FTDS95_CTLIB_LIBS)\nAC_SUBST(FTDS95_CTLIB_LIB)\nAC_SUBST(FTDS100_INCLUDE)\nAC_SUBST(FTDS100_LIBS)\nAC_SUBST(FTDS100_LIB)\nAC_SUBST(FTDS100_CTLIB_INCLUDE)\nAC_SUBST(FTDS100_CTLIB_LIBS)\nAC_SUBST(FTDS100_CTLIB_LIB)\nAC_SUBST(FTDS_INCLUDE)\nAC_SUBST(FTDS_LIBS)\nAC_SUBST(FTDS_LIB)\nAC_SUBST(freetds)\n\n\n## MySQL\nif test \"$with_mysql\" != \"no\" ; then\n   case \"$with_mysql\" in\n      yes | \"\" ) ;;\n      *        ) MYSQL_PATH=$with_mysql ;;\n   esac\n   : ${MYSQL_BINPATH=$MYSQL_PATH/bin}\n   AC_PATH_PROG(mysql_config, mysql_config, [], [$MYSQL_BINPATH:$PATH])\n   if test -n \"$mysql_config\" ; then\n      : ${MYSQL_BINPATH=`dirname $mysql_config`}\n      # Kill off single quotes, due to later requoting\n      : ${MYSQL_INCLUDE=`$mysql_config --include | tr -d \\'`}\n      NCBI_RPATHIFY_OUTPUT_COND(MYSQL_LIBS, $mysql_config --libs${mt_sfx:+_r},\n         [s/'//g; $no_usr_lib])\n      AC_CACHE_CHECK([whether MySQL works], ncbi_cv_lib_mysql,\n         [CPPFLAGS=\"$MYSQL_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$MYSQL_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <mysql.h>]],\n          [[MYSQL *p;  p = mysql_init(p);]])],\n          [ncbi_cv_lib_mysql=yes], [ncbi_cv_lib_mysql=no])])\n      if test \"$ncbi_cv_lib_mysql\" = no; then\n         NCBI_MISSING_PACKAGE(mysql)\n      fi\n   else\n      NCBI_MISSING_PACKAGE(mysql)\n   fi\nfi\nif test \"$with_mysql\" = \"no\" ; then\n   MYSQL_PATH=\"No_MYSQL\"\n   MYSQL_INCLUDE=\n   MYSQL_LIBS=\nelse\n   NCBI_PACKAGE(MySQL)\n   AC_DEFINE(HAVE_MYSQL, 1, [Define to 1 if MySQL is available.])\nfi\n\n\n## Berkeley DB library\nif test \"$with_bdb\" != \"no\" ; then\n   case \"$with_bdb\" in\n      yes | \"\" )\n         ;;\n      */*)\n          BERKELEYDB_PATH=$with_bdb\n          AS_UNSET(BERKELEYDB_INCLUDE)\n          AS_UNSET(BERKELEYDB_LIBPATH)\n          AS_UNSET(BERKELEYDB_LIBS)\n          ;;\n      *)\n          BERKELEYDB_PATH=$NCBI/BerkeleyDB-${with_bdb}\n          AS_UNSET(BERKELEYDB_INCLUDE)\n          AS_UNSET(BERKELEYDB_LIBPATH)\n          AS_UNSET(BERKELEYDB_LIBS)\n          ;;\n   esac\n   if test -d \"$BERKELEYDB_PATH\"; then\n      NCBI_FIX_DIR(BERKELEYDB_PATH)\n      : ${BERKELEYDB_INCLUDE:=\"-I$BERKELEYDB_PATH/include\"}\n   fi\n   if test -z \"${BERKELEYDB_LIBPATH}\"; then\n      for d in \"${compiler_vpfx}${DEBUG_SFX}\" \"${compiler_pfx}${DEBUG_SFX}\" \\\n               \"${DEBUG_SFX}\" lib; do\n         for sfx in \"$mt_sfx$bit64_sfx\" \"$bit64_sfx$mt_sfx\" \"$bit64_sfx\" \\\n                    \"$mt_sfx\" \"\"; do\n            BERKELEYDB_LIBPATH=${BERKELEYDB_PATH}/$d$sfx\n            test -d \"${BERKELEYDB_LIBPATH}\"  &&  break\n         done\n         test -d \"${BERKELEYDB_LIBPATH}\"  &&  break\n      done\n   fi\n   if test -d \"$BERKELEYDB_LIBPATH\"; then\n      NCBI_FIX_DIR(BERKELEYDB_LIBPATH)\n      NCBI_RPATHIFY_COND(BERKELEYDB_LIBS:, ${BERKELEYDB_LIBPATH}, [ -ldb])\n   else\n      : ${BERKELEYDB_LIBS:=\"-ldb\"}\n   fi\n   if test -f \"${BERKELEYDB_LIBPATH}/libdb-static.a\"; then\n      BERKELEYDB_STATIC_LIBS=\"-L${BERKELEYDB_LIBPATH} -ldb-static\"\n      if test \"x$with_bin_release\" = \"xyes\"; then\n         BERKELEYDB_LIBS=$BERKELEYDB_STATIC_LIBS\n      fi\n   else\n      BERKELEYDB_STATIC_LIBS=${BERKELEYDB_LIBS}\n   fi\n   AC_CACHE_CHECK(\n      [for Berkeley DB libraries${BERKELEYDB_PATH:+ in $BERKELEYDB_PATH}],\n      ncbi_cv_lib_berkeley_db,\n      [CPPFLAGS=\"$BERKELEYDB_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$BERKELEYDB_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <db.h>\n            #include <stdlib.h>]],\n          [[ DB* dbp;  db_create(&dbp, NULL, 0);  dbp->app_private = 0; ]])],\n          [ncbi_cv_lib_berkeley_db=yes], [ncbi_cv_lib_berkeley_db=no])])\n   if test \"$ncbi_cv_lib_berkeley_db\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(bdb)\n   else\n      AC_CACHE_CHECK([Berkeley DB version (4.3 or newer required)],\n         ncbi_cv_lib_berkeley_db_version,\n         [AC_LANG_CONFTEST([AC_LANG_SOURCE([[\ncat >/dev/null <<_NCBI_EOF\n#include <db.h>\n_NCBI_EOF\nget_DB_VERSION() {\n    grep '^[^#]' <<_NCBI_EOF\nDB_VERSION_MAJOR.DB_VERSION_MINOR.DB_VERSION_PATCH\n_NCBI_EOF\n}\nncbi_cv_lib_berkeley_db_version=\\`get_DB_VERSION | tr -cd 0123456789.\\`\n          ]])])\n          eval \"$ac_cpp $BERKELEYDB_INCLUDE conftest.$ac_ext\" > conftest.sh \\\n             2>&AS_MESSAGE_LOG_FD\n          . ./conftest.sh\n          rm -f conftest*\n         ])\n      case \"$ncbi_cv_lib_berkeley_db_version\" in\n         1.* | 2.* | 3.* | 4.[[0-2]].* )\n            AC_MSG_WARN(\n               [Your Berkeley DB version is too old to use.  (Needed >= 4.3.)])\n            if test -n \"$with_bdb\"; then\n               AC_MSG_ERROR([--with-bdb:  Berkeley DB library is too old])\n            fi\n            with_bdb=no\n            ;;\n         4.[[3-6]].* ) ;;\n         * )\n            AC_MSG_WARN(\n               [Untested Berkeley DB version; may prove incompatible.])\n            AC_MSG_WARN(\n               [If so, please re-run this script with the flag --without-bdb.])\n            ;;\n      esac\n   fi\nfi\nif test \"$with_bdb\" = \"no\" ; then\n   BERKELEYDB_PATH=\"No_BerkeleyDB\"\n   BERKELEYDB_INCLUDE=\n   BERKELEYDB_LIBS=\n   BERKELEYDB_STATIC_LIBS=\n   BERKELEYDB_CXX_LIBS=\n   BERKELEYDB_CXX_STATIC_LIBS=\nelse\n   NCBI_PACKAGE(BerkeleyDB)\n   AC_DEFINE(HAVE_BERKELEY_DB, 1,\n             [Define to 1 if Berkeley DB libraries are available.])\n   if test -d \"$BERKELEYDB_LIBPATH\"; then\n      NCBI_RPATHIFY_COND(BERKELEYDB_CXX_LIBS:, ${BERKELEYDB_LIBPATH},\n          [ -ldb_cxx -ldb])\n   else\n      : ${BERKELEYDB_CXX_LIBS:=\"-ldb_cxx -ldb\"}\n   fi\n   if test -f \"${BERKELEYDB_LIBPATH}/libdb_cxx-static.a\"; then\n      BERKELEYDB_CXX_STATIC_LIBS=\"-L${BERKELEYDB_LIBPATH} -ldb_cxx-static -ldb-static\"\n   else\n      BERKELEYDB_CXX_STATIC_LIBS=${BERKELEYDB_CXX_LIBS}\n   fi\n   AC_CACHE_CHECK([for native Berkeley DB C++ wrappers (optional)],\n      ncbi_cv_lib_berkeley_db_cxx,\n      [CPPFLAGS=\"$BERKELEYDB_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$BERKELEYDB_CXX_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <db_cxx.h>]],\n          [[DbEnv env(0);  Db db(&env, 0);  db.set_app_private(NULL);]])],\n          [ncbi_cv_lib_berkeley_db_cxx=yes],\n          [ncbi_cv_lib_berkeley_db_cxx=no])])\n   if test \"$ncbi_cv_lib_berkeley_db_cxx\" = \"yes\"; then\n      NCBI_PACKAGE(BerkeleyDB++)\n      AC_DEFINE(HAVE_BERKELEY_DB_CXX, 1,\n                [Define to 1 if the Berkeley `db_cxx' library is available.])\n   else\n      BERKELEYDB_CXX_LIBS=\n      BERKELEYDB_CXX_STATIC_LIBS=\n   fi\nfi\n\n\n## ODBC\ncase \"$with_odbc\" in\n   yes | \"\"   ) : ${ODBC_PATH:=dbapi/driver/odbc/unix_odbc} ;;\n   internal | no ) ODBC_PATH=dbapi/driver/odbc/unix_odbc       ;;\n   *          ) ODBC_PATH=$with_odbc                        ;;\nesac\n\ncase \"$ODBC_PATH\" in\n dbapi/* ) ;;\n *)\n   ODBC_INCLUDE=\"-I$ODBC_PATH/include\"\n   ODBC_LIBPATH=\"${ODBC_PATH}/lib\"\n   NCBI_RPATHIFY(ODBC_LIBS, ${ODBC_LIBPATH}, [ -lodbc -lodbcinst])\n   CPPFLAGS=\"$ODBC_INCLUDE $orig_CPPFLAGS\"\n   LIBS=\"$ODBC_LIBS $orig_LIBS\"\n   AC_CACHE_CHECK([for ODBC libraries${ODBC_PATH:+ in $ODBC_PATH}],\n      ncbi_cv_lib_odbc,\n      [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <sql.h>]],\n          [[SQLHDBC hdbc;  SQLCHAR* cp = (SQLCHAR*) \"x\";\n            SQLRETURN x = SQLConnect(hdbc, cp, 1, cp, 2, cp, 3);]])],\n          [ncbi_cv_lib_odbc=yes], [ncbi_cv_lib_odbc=no])])\n   if test \"$ncbi_cv_lib_odbc\" = \"no\"; then\n      dnl ODBC_PATH=dbapi/driver/odbc/unix_odbc\n      dnl AC_MSG_WARN([Falling back to internal FreeTDS-specific ODBC implementation.])\n      NCBI_MISSING_PACKAGE(odbc)\n   else\n      # odbcss.h isn't self-contained :-/\n      AC_CHECK_HEADERS(odbcss.h, [], [], [#include <sql.h>])\n\n      AC_CHECK_FUNCS(SQLGetPrivateProfileString)\n      AC_CHECK_TYPES([SQLLEN, SQLROWOFFSET, SQLROWSETSIZE, SQLSETPOSIROW],,,\n         [#include <sqltypes.h>])\n      AC_CHECK_SIZEOF(SQLWCHAR, [], [#include <sqltypes.h>])\n\n      AC_CACHE_CHECK([whether SQLColAttribute's last argument is an SQLLEN *],\n         ncbi_cv_func_sqlcolattribute_sqllen,\n         [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n            [[#include <sql.h>\n              SQLRETURN SQL_API SQLColAttribute\n                (SQLHSTMT sh, SQLUSMALLINT cn, SQLUSMALLINT fi, SQLPOINTER ca,\n                 SQLSMALLINT bl, SQLSMALLINT *sl, SQLLEN *na);]],\n            [[]])],\n            ncbi_cv_func_sqlcolattribute_sqllen=yes,\n            ncbi_cv_func_sqlcolattribute_sqllen=no)])\n      if test $ncbi_cv_func_sqlcolattribute_sqllen = yes; then\n         AC_DEFINE(NCBI_SQLCOLATTRIBUTE_SQLLEN, 1,\n            [Define to 1 if SQLColAttribute's last argument is an SQLLEN *])\n      fi\n   fi\n   ;;\nesac\n\ncase \"$ODBC_PATH\" in\n dbapi/*)\n   # ODBC_PATH=\"No_ODBC\"\n   # Point to a local copy of unixODBC's headers, required by FreeTDS 0.64+.\n   ODBC_INCLUDE=\"-I\\$(includedir)/$ODBC_PATH -I\\$(includedir0)/$ODBC_PATH\"\n   ODBC_LIBS=\n   dnl AC_DEFINE(HAVE_SQLGETPRIVATEPROFILESTRING, 1)\n   AC_DEFINE(HAVE_SQLLEN, 1)\n   if test $NCBI_PLATFORM_BITS -eq 32; then\n      AC_DEFINE(HAVE_SQLROWOFFSET, 1)\n      AC_DEFINE(HAVE_SQLROWSETSIZE, 1)\n   fi\n   AC_DEFINE(HAVE_SQLSETPOSIROW, 1)\n   AC_DEFINE(NCBI_SQLCOLATTRIBUTE_SQLLEN, 1)\n   dnl AC_DEFINE(SIZEOF_SQLWCHAR, 2) # depends on SQL_WCHART_CONVERT\n   ;;\n *)\n   NCBI_PACKAGE(ODBC)\n   AC_DEFINE(HAVE_ODBC, 1, [Define to 1 if ODBC libraries are available.])\n   ;;\nesac\n\n## Python\nif test \"$with_python\" != \"no\" ; then\n   case \"$with_python\" in\n      yes | \"\" ) ;;\n      */*      ) PYTHON_PATH=$with_python ;;\n   esac\n   NCBI_CHECK_PYTHON()\n   NCBI_CHECK_PYTHON(2.5)\n   NCBI_CHECK_PYTHON(2.6)\n   NCBI_CHECK_PYTHON(2.7)\n   NCBI_CHECK_PYTHON(3)\n   if test \"$ncbi_cv_lib_python\" = \"no\"; then\n      if test \"$ncbi_cv_lib_python27\" = \"yes\"; then\n         PYTHON_INCLUDE=$PYTHON27_INCLUDE\n         PYTHON_LIBS=$PYTHON27_LIBS\n      elif test \"$ncbi_cv_lib_python26\" = \"yes\"; then\n         PYTHON_INCLUDE=$PYTHON26_INCLUDE\n         PYTHON_LIBS=$PYTHON26_LIBS\n      elif test \"$ncbi_cv_lib_python25\" = \"yes\"; then\n         PYTHON_INCLUDE=$PYTHON25_INCLUDE\n         PYTHON_LIBS=$PYTHON25_LIBS\n      fi\n      if test -n \"$PYTHON_LIBS\"; then\n         NCBI_PACKAGE(PYTHON)\n         AC_DEFINE(HAVE_PYTHON, 1)\n      else\n         NCBI_MISSING_PACKAGE(python)\n      fi\n   fi\nfi\n\n## Perl\nif test \"$with_perl\" != \"no\" ; then\n   case \"$with_perl\" in\n      yes | \"\" ) ;;\n      */*      ) PERL_PATH=$with_perl ;;\n   esac\n   AC_PATH_PROG(PERL, perl, [], [$PERL_PATH/bin:$PATH])\n   if test -x \"$PERL\"; then\n      PERL_ARCHLIB=`$PERL -MConfig -e 'print \\$Config{archlibexp};'`\n      PERL_FLAGS=`$PERL -MConfig -e 'print join \" \", grep /^-[[DI]]/, split /\\\\s+/, \\$Config{cppflags};'`\n      PERL_INCLUDE=\"-I$PERL_ARCHLIB/CORE $PERL_FLAGS\"\n      PERL_DEPS=`$PERL -MConfig -e 'print \\$Config{libs};'`\n      NCBI_RPATHIFY(PERL_LIBS, $PERL_ARCHLIB/CORE, [ -lperl $PERL_DEPS])\n      CPPFLAGS=\"$PERL_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$PERL_LIBS $orig_LIBS\"\n      AC_CACHE_CHECK([for usable Perl libraries], [ncbi_cv_lib_perl],\n         [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n                [[\n#include <EXTERN.h>\n#include <perl.h>]],\n                [[PerlInterpreter* p = perl_alloc();]])],\n             [ncbi_cv_lib_perl=yes], [ncbi_cv_lib_perl=no])])\n   fi\n   if test \"$ncbi_cv_lib_perl\" = yes; then\n      NCBI_PACKAGE(PERL)\n      dnl AC_DEFINE(HAVE_PERL, 1)\n   else\n      NCBI_MISSING_PACKAGE(perl)\n      PERL_INCLUDE=\n      PERL_LIBS=\n   fi\nfi\n\n## Java\nif test \"${with_jni-no}\" != \"no\"; then\n   case \"$with_jni:${JAVAC+set}\" in\n      yes: | : )\n         if test -d \"$JAVA_HOME\"; then\n            JAVAC=$JAVA_HOME/bin/javac\n         else\n            JAVAC=javac\n         fi\n         ;;\n      * )\n         JAVAC=$with_jni/bin/javac\n         ;;\n   esac\n   AX_JNI_INCLUDE_DIR\n   JDK_INCLUDE=''\n   sep=''\n   for x in $JNI_INCLUDE_DIRS; do\n      JDK_INCLUDE=$JDK_INCLUDE$sep-I$x\n      sep=' '\n   done\n   AC_MSG_NOTICE([setting JDK_INCLUDE = $JDK_INCLUDE])\n   CPPFLAGS=\"$JDK_INCLUDE $orig_CPPFLAGS\"\n   AC_CHECK_HEADER(jni.h,\n      [AC_DEFINE(NCBI_JNI, 1,\n          [Define to 1 if building Java Native Interface bindings.])\n       NCBI_FEATURE([JDK Ncbi-JNI])\n       JDK_PATH=$_JTOPDIR\n       ncbi_java=ncbi_java],\n      [JDK_INCLUDE=''\n       JDK_PATH=''\n       ncbi_java=''])\nfi\n\n\n## Boost\nif test \"$with_boost\" != \"no\"; then\n   if test \"${with_boost-yes}\" != yes; then\n      BOOST_PATH=$with_boost\n   fi\n   if test -d \"$BOOST_PATH\"; then\n      NCBI_FIX_DIR(BOOST_PATH)\n      : ${BOOST_INCLUDE=-I$BOOST_PATH/include}\n   fi\n   BOOST_LIBPATH_=$BOOST_PATH/lib\n   NCBI_RPATHIFY_COND(BOOST_LIBPATH, $BOOST_LIBPATH_)\n   if test -d \"$BOOST_PATH\"; then  \n      boost_path_digits=`basename $BOOST_PATH | sed -e 's/-ncbi[[0-9]]*$//; s/.0$//' | tr -cd 0123456789`\n   else\n      boost_path_digits=\n      BOOST_LIBPATH_=/usr/lib\n   fi\n   if test -n \"$boost_path_digits\"; then\n      boost_version_digits=`echo $ncbi_cv_lib_boost_version | sed -e 's/.0$//' | tr -cd 0123456789`\n      if test $boost_path_digits != \"$boost_version_digits\"; then\n         # presumably stale, particularly if boost_version WASN'T cached;\n         # uncache all relevant settings\n         AS_UNSET(ncbi_cv_lib_boost_version)\n         AS_UNSET(ncbi_cv_lib_boost_version_num)\n         AS_UNSET(ncbi_cv_lib_boost_regex)\n         AS_UNSET(ncbi_cv_lib_boost_spirit)\n         AS_UNSET(ncbi_cv_lib_boost_system)\n         AS_UNSET(ncbi_cv_lib_boost_filesystem)\n         AS_UNSET(ncbi_cv_lib_boost_iostreams)\n         AS_UNSET(ncbi_cv_lib_boost_program_options)\n         AS_UNSET(ncbi_cv_lib_boost_test)\n         AS_UNSET(ncbi_cv_lib_boost_thread)\n      elif test -z \"$ncbi_cv_lib_boost_version_num\"; then\n         AS_UNSET(ncbi_cv_lib_boost_version)\n      fi\n   fi\n      AC_CACHE_CHECK([Boost version],\n         ncbi_cv_lib_boost_version,\n         [AC_LANG_CONFTEST([AC_LANG_SOURCE([[\ncat >/dev/null <<_NCBI_EOF\n#include <boost/version.hpp>\n_NCBI_EOF\nget_BOOST_VERSION() {\n    grep '^[^#]' <<_NCBI_EOF\nBOOST_VERSION\n_NCBI_EOF\n}\nget_BOOST_LIB_VERSION() {\n    grep '^[^#]' <<_NCBI_EOF\nBOOST_LIB_VERSION\n_NCBI_EOF\n}\nncbi_cv_lib_boost_version_num=\\`get_BOOST_VERSION\\`\nncbi_cv_lib_boost_version=\\`get_BOOST_LIB_VERSION | tr -d '\"'\\`\n          ]])])\n          eval \"$ac_cpp $BOOST_INCLUDE conftest.$ac_ext\" > conftest.sh \\\n             2>&AS_MESSAGE_LOG_FD\n          . ./conftest.sh 2>&AS_MESSAGE_LOG_FD\n          rm -f conftest*\n         ])\n      AC_DEFINE_UNQUOTED(NCBI_EXPECTED_BOOST_VERSION,\n         $ncbi_cv_lib_boost_version_num,\n         [Define to the expected Boost version, to help catch skew.])\n   if test -d `echo $BOOST_INCLUDE | sed -e 's/^-I//'`/boost-${ncbi_cv_lib_boost_version}/boost; then\n      BOOST_INCLUDE=$BOOST_INCLUDE/boost-${ncbi_cv_lib_boost_version}\n   fi\n   case \"$compiler:$ncbi_compiler_ver\" in\n      MIPSpro*)\n         BOOST_INCLUDE=\"$BOOST_INCLUDE $BOOST_INCLUDE/boost/compatibility/cpp_c_headers\"\n         ;;\n      WorkShop*)\n         # Boost.Test's macros yield a *lot* of spurious \"should not initialize\n         # a non-const reference with a temporary\" warnings, to the point of\n         # overwhelming the compiler in some cases; turn them off altogether\n         # when using Boost at all.\n         BOOST_INCLUDE=\"$BOOST_INCLUDE -erroff=reftotemp\"\n         ;;\n      GCC*:4[[7-9]]* | GCC*:5*)\n         # Some portions of Boost also have a lot of \"unused\" typedefs\n         # from concept checking.\n         BOOST_INCLUDE=\"$BOOST_INCLUDE -Wno-unused-local-typedefs\"\n         ;;\n   esac\n   case \"$ncbi_cv_lib_boost_version\" in\n      0_* | 1_[[0-9]] | 1_[[0-9]]_* | 1_[[0-2]][[0-9]] | 1_[[0-2]][[0-9]]_* ) ;;\n      1_3[[0-4]] | 1_3[[0-4]]_* )\n         AC_MSG_WARN(\n            [Your Boost version is too old to use.  (Needed >= 1.35.)])\n         if test -n \"$with_boost\"; then\n            AC_MSG_ERROR([--with-boost:  Boost library is too old])\n         fi\n         with_boost=no\n         ;;\n      1_3[[5-9]] | 1_3[[5-9]]_* | 1_[[4-6]]* | 1_70 | 1_70_* ) ;;\n      '' ) with_boost=no ;;\n      * )\n         AC_MSG_WARN(\n            [Untested Boost version; may prove incompatible.])\n         AC_MSG_WARN(\n            [If so, please re-run this script with the flag --without-boost.])\n         ;;\n   esac\n   AC_MSG_CHECKING([for Boost library name tag])\n   case \"$with_boost_tag\" in\n      yes | \"\" )\n         case \"$host_os:$ncbi_compiler\" in\n            darwin*:GCC) BOOST_TAG=\"-xgcc\" ;;\n            *:GCC)       BOOST_TAG=\"-gcc\" ;;\n            *:KCC)       BOOST_TAG=\"-kcc\" ;;\n            linux*:ICC)  BOOST_TAG=\"-il\"  ;;\n            *:WORKSHOP)  BOOST_TAG=\"-sw\"  ;;\n            *:MIPSPRO)   BOOST_TAG=\"-mp\"  ;;\n            *:VISUALAGE) BOOST_TAG=\"-xlc\" ;;\n            *:COMPAQ)    BOOST_TAG=\"-tru\" ;;\n            *:MSVC)      BOOST_TAG=\"-vc\"  ;;\n         esac\n         case \"$BOOST_TAG\" in\n            -*gcc|-il ) boost_comp_vers=`echo $compiler_version | cut -c1-2` ;;\n            *         ) boost_comp_vers='' ;;\n         esac\n         case \"$llvm_version:$ac_cv_have_decl__LIBCPP_VERSION\" in\n            *clang*:yes )\n                case \"$host_os\" in\n                   darwin*) BOOST_TAG=\"-clang-darwin\" ;;\n                   *)       BOOST_TAG=\"-clang\" ;;\n                esac\n                boost_comp_vers=`echo $signature_compiler_version | cut -c1-2`\n            ;;\n         esac\n         test \"$with_mt\"    = \"yes\"  &&  BOOST_MT=-mt\n         test \"$with_debug\" = \"no\"   ||  BOOST_D=-d\n         test \"$bit64_sfx\"  = \"64\"   &&  BOOST_64=-64\n         found=no\n         for base in \"$BOOST_TAG$boost_comp_vers\" \"$BOOST_TAG\" ''; do\n           for bvers in \"-$ncbi_cv_lib_boost_version\" ''; do\n             for b64 in $BOOST_64 ''; do\n               for bmt in \"$BOOST_MT\" '-mt' ''; do\n                 for bd in \"$BOOST_D\" '' '-d'; do\n                   bsfx=$cvers$bmt$bd$bvers$b64\n                   if ls $BOOST_LIBPATH_/libboost*$base$bsfx.* >/dev/null 2>&1;\n                   then\n                     found=yes\n                     break\n                   else\n                     for ext in .a .so; do\n                       name=libboost_system$base$bsfx$ext\n                       path=`$CXX -L$BOOST_LIBPATH_ -print-file-name=$name \\\n                             2>/dev/null`\n                       case \"$path\" in\n                         $BOOST_PATH/*/$name ) found=yes; break ;;\n                       esac\n                     done\n                   fi\n                   test \"$found\" = yes  &&  break\n                 done\n                 test \"$found\" = yes  &&  break\n               done\n               test \"$found\" = yes  &&  break\n             done\n             test \"$found\" = yes  &&  break\n           done\n           test \"$found\" = yes  &&  break\n         done\n\n         if test \"$found\" = no; then\n            base=$BOOST_TAG\n            cvers=$boost_comp_vers\n            bvers=-$ncbi_cv_lib_boost_version\n            b64=$BOOST_64\n            bmt=$BOOST_MT\n            bd=$BOOST_D\n            bsfx=$cvers$bmt$bd$bvers$b64\n         fi\n\n         BOOST_TAG=$base$bsfx\n         AC_MSG_RESULT([$BOOST_TAG (autodetected)])\n         ;;\n      no )\n         BOOST_TAG=\"\"\n         AC_MSG_RESULT([none (by explicit request)])\n         ;;\n      *)\n         BOOST_TAG=$with_boost_tag\n         AC_MSG_RESULT([$BOOST_TAG (by explicit request)])\n         ;;\n   esac\n\n   test \"$with_mt\" = yes  || \\\n      BOOST_INCLUDE=\"$BOOST_INCLUDE -DBOOST_DISABLE_THREADS\"\n\n   BOOST_REGEX_LIBS=-lboost_regex${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_regex${BOOST_TAG}-static.a\"; then\n       BOOST_REGEX_STATIC_LIBS=-lboost_regex${BOOST_TAG}-static\n   else\n       BOOST_REGEX_STATIC_LIBS=$BOOST_REGEX_LIBS\n   fi\n\n   in_path=${BOOST_PATH:+ in $BOOST_PATH}\n\n   AC_CACHE_CHECK([for Boost.Regex$in_path], ncbi_cv_lib_boost_regex,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_REGEX_LIBS $RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/regex.hpp>]],\n              [[throw boost::regex_error(boost::regex_constants::error_stack);]])],\n          [ncbi_cv_lib_boost_regex=yes], [ncbi_cv_lib_boost_regex=no])])\n\n   AC_CACHE_CHECK([for Boost.Spirit$in_path], ncbi_cv_lib_boost_spirit,\n      CPPFLAGS=\"$BOOST_INCLUDE -DBOOST_ERROR_CODE_HEADER_ONLY $orig_CPPFLAGS\"\n      LIBS=\"$RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/spirit.hpp>\n                             using namespace boost::spirit;\n                             struct MyGrammar : public grammar<MyGrammar>\n                             {\n                                 template <typename TScanner>\n                                 struct definition {\n                                     definition(const MyGrammar&) { }\n                                     typedef rule<TScanner, parser_context<>,\n                                                  parser_tag<0> >\n                                             TRule;\n                                     TRule my_rule;\n                                     TRule const & start() const\n                                         { return my_rule; }\n                                 };\n                             };]],\n              [[MyGrammar g;  parse(\"123\", g);]])],\n          [ncbi_cv_lib_boost_spirit=yes], [ncbi_cv_lib_boost_spirit=no])])\n\n   BOOST_SYSTEM_LIBS=-lboost_system${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_system${BOOST_TAG}-static.a\"; then\n       BOOST_SYSTEM_STATIC_LIBS=-lboost_system${BOOST_TAG}-static\n   else\n       BOOST_SYSTEM_STATIC_LIBS=$BOOST_SYSTEM_LIBS\n   fi\n\n   AC_CACHE_CHECK([for Boost.System$in_path], ncbi_cv_lib_boost_system,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_SYSTEM_LIBS $RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/system/error_code.hpp>]],\n              [[const char * s = boost::system::system_category().name();]])],\n          [ncbi_cv_lib_boost_system=yes],\n          [ncbi_cv_lib_boost_system=no\n           BOOST_SYSTEM_LIBS=\n           BOOST_SYSTEM_STATIC_LIBS=])])\n\n   boost_chrono_lib=-lboost_chrono${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_chrono${BOOST_TAG}-static.a\"; then\n       boost_chrono_static_lib=-lboost_chrono${BOOST_TAG}-static\n   else\n       boost_chrono_static_lib=$boost_chrono_lib\n   fi\n   BOOST_CHRONO_LIBS=\"$boost_chrono_lib $BOOST_CHRONO_LIBS\"\n   BOOST_CHRONO_STATIC_LIBS=\"$boost_chrono_static_lib $BOOST_SYSTEM_STATIC_LIBS\"\n\n   AC_CACHE_CHECK([for Boost.Chrono$in_path], ncbi_cv_lib_boost_chrono,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_CHRONO_LIBS $RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/chrono.hpp>]],\n              [[boost::chrono::system_clock::now();]])],\n          [ncbi_cv_lib_boost_chrono=yes],\n          [ncbi_cv_lib_boost_chrono=no])])\n\n   boost_fs_lib=-lboost_filesystem${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_filesystem${BOOST_TAG}-static.a\"; then\n       boost_fs_static_lib=-lboost_filesystem${BOOST_TAG}-static\n   else\n       boost_fs_static_lib=$boost_fs_lib\n   fi\n   BOOST_FILESYSTEM_LIBS=\"$boost_fs_lib $BOOST_SYSTEM_LIBS\"\n   BOOST_FILESYSTEM_STATIC_LIBS=\"$boost_fs_static_lib $BOOST_SYSTEM_STATIC_LIBS\"\n\n   AC_CACHE_CHECK([for Boost.Filesystem$in_path], ncbi_cv_lib_boost_filesystem,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_FILESYSTEM_LIBS $RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/filesystem.hpp>]],\n              [[return boost::filesystem::portable_name(\"foo\");]])],\n          [ncbi_cv_lib_boost_filesystem=yes],\n          [ncbi_cv_lib_boost_filesystem=no])])\n\n   BOOST_IOSTREAMS_LIBS=-lboost_iostreams${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_iostreams${BOOST_TAG}-static.a\"; then\n       BOOST_IOSTREAMS_STATIC_LIBS=-lboost_iostreams${BOOST_TAG}-static\n   else\n       BOOST_IOSTREAMS_STATIC_LIBS=$BOOST_IOSTREAMS_LIBS\n   fi\n\n   AC_CACHE_CHECK([for Boost.Iostreams$in_path], ncbi_cv_lib_boost_iostreams,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_IOSTREAMS_LIBS $Z_LIBS $BZ2_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/iostreams/device/file_descriptor.hpp>]],\n              [[boost::iostreams::file_descriptor fd;]])],\n          [ncbi_cv_lib_boost_iostreams=yes],\n          [ncbi_cv_lib_boost_iostreams=no])])\n\n   BOOST_PROGRAM_OPTIONS_LIBS=-lboost_program_options${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_program_options${BOOST_TAG}-static.a\"; then\n       BOOST_PROGRAM_OPTIONS_STATIC_LIBS=-lboost_program_options${BOOST_TAG}-static\n   else\n       BOOST_PROGRAM_OPTIONS_STATIC_LIBS=$BOOST_PROGRAM_OPTIONS_LIBS\n   fi\n\n   AC_CACHE_CHECK([for Boost.Program-Options$in_path],\n      ncbi_cv_lib_boost_program_options,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_PROGRAM_OPTIONS_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/program_options.hpp>]],\n              [[boost::program_options::option_description od;]])],\n          [ncbi_cv_lib_boost_program_options=yes],\n          [ncbi_cv_lib_boost_program_options=no])])\n\n   BOOST_TEST_PEM_LIBS=-lboost_prg_exec_monitor${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_prg_exec_monitor${BOOST_TAG}-static.a\"; then\n       BOOST_TEST_PEM_STATIC_LIBS=-lboost_prg_exec_monitor${BOOST_TAG}-static\n   else\n       BOOST_TEST_PEM_STATIC_LIBS=$BOOST_TEST_PEM_LIBS\n   fi\n\n   BOOST_TEST_TEM_LIBS=-lboost_test_exec_monitor${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_test_exec_monitor${BOOST_TAG}-static.a\"; then\n       BOOST_TEST_TEM_STATIC_LIBS=-lboost_test_exec_monitor${BOOST_TAG}-static\n   else\n       BOOST_TEST_TEM_STATIC_LIBS=$BOOST_TEST_TEM_LIBS\n   fi\n\n   BOOST_TEST_UTF_LIBS=-lboost_unit_test_framework${BOOST_TAG}\n   if test -f \"$BOOST_LIBPATH_/libboost_unit_test_framework${BOOST_TAG}-static.a\"; then\n       BOOST_TEST_UTF_STATIC_LIBS=-lboost_unit_test_framework${BOOST_TAG}-static\n   else\n       BOOST_TEST_UTF_STATIC_LIBS=$BOOST_TEST_UTF_LIBS\n   dnl AC_DEFINE([NCBI_BOOST_TEST_DLL], 1,\n   dnl   [Define to 1 if unable to locate an appropriate\n   dnl    libboost_unit_test_framework${BOOST_TAG}-static.a.])\n   fi\n\n   BOOST_TEST_PEM_LIBS=$BOOST_TEST_PEM_STATIC_LIBS\n   BOOST_TEST_TEM_LIBS=$BOOST_TEST_TEM_STATIC_LIBS\n   BOOST_TEST_UTF_LIBS=$BOOST_TEST_UTF_STATIC_LIBS\n\n   AC_CACHE_CHECK([for Boost.Test$in_path], ncbi_cv_lib_boost_test,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$RT_LIBS $orig_LIBS\"\n      found=\n      for mode in included external; do\n        if test \"$mode\" = external; then\n          CPPFLAGS=\"-DNCBI_BOOST_NOT_INCLUDED $CPPFLAGS\"\n          LIBS=\"$BOOST_LIBPATH $BOOST_TEST_UTF_LIBS $LIBS\"\n        fi\n        [AC_LINK_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#ifdef NCBI_BOOST_NOT_INCLUDED\n                #  include <boost/test/unit_test.hpp>\n                #else\n                #  include <boost/test/included/unit_test.hpp>\n                #endif\n                using boost::unit_test::test_suite;\n                static void s_Test1(void) { BOOST_CHECK(1 == 1); }\n                test_suite* init_unit_test_suite(int, char*[])\n                {\n                    test_suite* test = BOOST_TEST_SUITE(\"foo\");\n                    test->add(BOOST_TEST_CASE(&s_Test1), 0);\n                    return test;\n                }]])],\n           [found=\"$found:$mode\"])]\n      done\n      [case \"$found\" in\n        :included:external ) ncbi_cv_lib_boost_test=yes           ;;\n        :included          ) ncbi_cv_lib_boost_test=included-only ;;\n        :external          ) ncbi_cv_lib_boost_test=external-only ;;\n        ''                 ) ncbi_cv_lib_boost_test=no            ;;\n      esac])\n\n   BOOST_THREAD_LIBS=\"-lboost_thread${BOOST_TAG} $BOOST_SYSTEM_LIBS\"\n   if test -f \"$BOOST_LIBPATH_/libboost_thread${BOOST_TAG}-static.a\"; then\n       BOOST_THREAD_STATIC_LIBS=\"-lboost_thread${BOOST_TAG}-static $BOOST_SYSTEM_STATIC_LIBS\"\n   else\n       BOOST_THREAD_STATIC_LIBS=$BOOST_THREAD_LIBS\n   fi\n\n   AC_CACHE_CHECK([for Boost.Thread$in_path], ncbi_cv_lib_boost_thread,\n      CPPFLAGS=\"$BOOST_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$BOOST_LIBPATH $BOOST_THREAD_LIBS $RT_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <boost/thread.hpp>]],\n              [[boost::mutex m; boost::mutex::scoped_lock l(m);]])],\n          [ncbi_cv_lib_boost_thread=yes], [ncbi_cv_lib_boost_thread=no])])\nelse\n   BOOST_INCLUDE=\n   BOOST_LIBPATH=\n   BOOST_TAG=\n   ncbi_cv_lib_boost_chrono=no\n   ncbi_cv_lib_boost_filesystem=no\n   ncbi_cv_lib_boost_iostreams=no\n   ncbi_cv_lib_boost_program_options=no\n   ncbi_cv_lib_boost_regex=no\n   ncbi_cv_lib_boost_spirit=no\n   ncbi_cv_lib_boost_system=no\n   ncbi_cv_lib_boost_test=no\n   ncbi_cv_lib_boost_thread=no\nfi\n\nif test \"$ncbi_cv_lib_boost_chrono\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_CHRONO, 1,\n             [Define to 1 if the `Boost.Chrono' library is available.])\n   NCBI_PACKAGE(Boost.Chrono)\nelse\n   boost_chrono_lib=\n   boost_chrono_static_lib=\n   BOOST_CHRONO_LIBS=\n   BOOST_CHRONO_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_filesystem\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_FILESYSTEM, 1,\n             [Define to 1 if the `Boost.Filesystem' library is available.])\n   NCBI_PACKAGE(Boost.Filesystem)\nelse\n   boost_fs_lib=\n   boost_fs_static_lib=\n   BOOST_FILESYSTEM_LIBS=\n   BOOST_FILESYSTEM_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_iostreams\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_IOSTREAMS, 1,\n             [Define to 1 if the `Boost.Iostreams' library is available.])\n   NCBI_PACKAGE(Boost.Iostreams)\nelse\n   BOOST_IOSTREAMS_LIBS=\n   BOOST_IOSTREAMS_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_program_options\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_PROGRAM_OPTIONS, 1,\n             [Define to 1 if the `Boost.Program-Options' library is available.])\n   NCBI_PACKAGE(Boost.Program-Options)\nelse\n   BOOST_PROGRAM_OPTIONS_LIBS=\n   BOOST_PROGRAM_OPTIONS_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_regex\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_REGEX, 1,\n             [Define to 1 if the `Boost.Regex' library is available.])\n   NCBI_PACKAGE(Boost.Regex)\nelse\n   BOOST_REGEX_LIBS=\n   BOOST_REGEX_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_spirit\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_SPIRIT, 1,\n             [Define to 1 if the `Boost.Spirit' headers are available.])\n   NCBI_PACKAGE(Boost.Spirit)\nfi\n\nif test \"$ncbi_cv_lib_boost_system\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_SYSTEM, 1,\n             [Define to 1 if the `Boost.System' library is available.])\n   NCBI_PACKAGE(Boost.System)\n# BOOST_SYSTEM(_STATIC)_LIBS already conditionally cleared above\nfi\n\nif test \"$ncbi_cv_lib_boost_test\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_TEST, 1,\n             [Define to 1 if the `Boost.Test' libraries are available.])\n   if test \"$ncbi_cv_lib_boost_test\" != \"included-only\"; then\n      NCBI_PACKAGE(Boost.Test)\n   fi\n   if test \"$ncbi_cv_lib_boost_test\" != \"external-only\"; then\n      NCBI_PACKAGE(Boost.Test.Included)\n   fi\nelse\n   BOOST_TEST_PEM_LIBS=\n   BOOST_TEST_PEM_STATIC_LIBS=\n   BOOST_TEST_TEM_LIBS=\n   BOOST_TEST_TEM_STATIC_LIBS=\n   BOOST_TEST_UTF_LIBS=\n   BOOST_TEST_UTF_STATIC_LIBS=\nfi\n\nif test \"$ncbi_cv_lib_boost_thread\" != \"no\"; then\n   AC_DEFINE(HAVE_BOOST_THREAD, 1,\n             [Define to 1 if the `Boost.Thread' library is available.])\n   NCBI_PACKAGE(Boost.Thread)\nelse\n   BOOST_THREAD_LIBS=\n   BOOST_THREAD_STATIC_LIBS=\nfi\n\ncase \"$with_boost:$ncbi_cv_lib_boost_test\" in\n   :* | no:* | *:yes | *:included-only ) ;; # no problem\n   * ) AC_MSG_ERROR([Boost explicitly requested, but Boost.Test.Included unavailable.]) ;;\nesac\n\n\n## NCBI C Toolkit\nif test \"$with_ncbi_c\" != \"no\" ; then\n   if test \"${with_ncbi_c-yes}\" != yes; then\n      NCBI_C_PATH=$with_ncbi_c\n   fi\n   : ${NCBI_C_PATH=\"$NCBI\"}\n   if test \"$ncbi_compiler\" = ICC -a -d \"$NCBI_C_PATH/ncbi_icc\"; then\n      NCBI_C_PATH=$NCBI_C_PATH/ncbi_icc\n   fi\n   if test -n \"$NCBI_C_PATH_TAGS\"; then\n      for x in $NCBI_C_PATH_TAGS; do\n         if test -d \"$NCBI_C_PATH$x\"; then\n            NCBI_C_PATH=$NCBI_C_PATH$x\n            break\n         fi\n      done\n   fi\n\n   NCBI_C_INCLUDE=\"-I$NCBI_C_PATH/include${bit64_sfx}\"\n   if test \"$with_debug\" = \"no\" ; then\n     NCBI_C_LIBPATH=\"$NCBI_C_PATH/lib${bit64_sfx}\"\n   else\n     NCBI_C_LIBPATH=\"$NCBI_C_PATH/altlib${bit64_sfx}\"\n   fi\n   if test \"$with_mt\" = \"yes\" ; then\n     NCBI_C_LIBPATH=\"$NCBI_C_LIBPATH $NCBI_C_LIBPATH/ncbithr.o\"\n   fi\n   if test -n \"$NCBI_C_ncbi\" ; then\n     :\n   elif test \"$OSTYPE\" = \"darwin\" ; then\n     NCBI_C_ncbi=\"-lncbi -Wl,-framework,AppKit\"\n   else\n     NCBI_C_ncbi=\"-lncbi\"\n   fi\n   NCBI_C_LIBPATH=\"-L$NCBI_C_LIBPATH\"\n   AC_CACHE_CHECK([for the NCBI C toolkit${NCBI_C_PATH:+ in $NCBI_C_PATH}],\n      ncbi_cv_lib_ctools,\n      [CPPFLAGS=\"$NCBI_C_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$NCBI_C_LIBPATH $NCBI_C_ncbi $NETWORK_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <ncbi.h>]],\n          [[ Nlm_Boolean b = Nlm_GetArgs(\"fake\", -1, 0); ]])],\n          [ncbi_cv_lib_ctools=yes], [ncbi_cv_lib_ctools=no])])\n   if test \"$ncbi_cv_lib_ctools\" = no; then\n      NCBI_MISSING_PACKAGE(ncbi-c)\n   fi\nfi\nif test \"$with_ncbi_c\" = \"no\" ; then\n   if test \"$with_ctools\" = \"yes\"; then\n      AC_MSG_ERROR([--with-ctools:  NCBI C Toolkit is missing])\n   fi\n   NCBI_C_PATH=\"No_NCBI_CToolkit\"\n   NCBI_C_INCLUDE=\n   NCBI_C_LIBPATH=\n   NCBI_C_ncbi=\nelse\n   NCBI_PACKAGE(C-Toolkit)\n   AC_DEFINE(HAVE_NCBI_C, 1, [Define to 1 if the NCBI C toolkit is available.])\nfi\n\n# X11\nLIBS=\"$orig_LIBS\"\nCPPFLAGS=\"$orig_CPPFLAGS\"\n# Look in /usr/X11R6/lib64 if necessary\nxlib=`ls -d /usr/X11R6/lib$bit64_sfx/libX11.* 2>/dev/null | sed -ne 1p`\nif test -f \"$xlib\" -a \"${x_libraries-NONE}\" = NONE \\\n  -a \"${x_includes-NONE}\" = NONE; then\n   base=`basename $xlib`\n   cmp -s /usr/X11R6/lib/$base $xlib  || \\\n      cmp -s /usr/lib/$base $xlib  || \\\n      cmp -s /usr/lib$bit64_sfx/$base $xlib  || \\\n      x_libraries=/usr/X11R6/lib$bit64_sfx x_includes=/usr/X11R6/include\nfi\nAC_PATH_XTRA\nx_libraries=`echo \"$x_libraries\" | sed -e \"s,^$usr_lib\\$,,\"`\nX_LIBS=`echo \"$X_LIBS \" | sed -e \"$no_usr_lib\"`\nAC_CHECK_LIB(Xext, XextCreateExtension, Xext=\"-lXext\", Xext=,\n   [$X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\nAC_CHECK_LIB(Xt, XtMainLoop, Xt=\"-lXt\", Xt=,\n   [$Xext $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\nAC_CHECK_LIB(Xmu, XmuMakeAtom, Xmu=\"-lXmu\", Xmu=,\n   [$Xt $Xext $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])\nLDFLAGS=$orig_LDFLAGS\nX_ALL_LIBS=\"$Xmu $Xt $Xext $X_PRE_LIBS -lX11 $X_EXTRA_LIBS\"\n\n## OpenGL\nif test \"$with_opengl\" != \"no\"; then\n   if test \"${with_opengl-yes}\" != yes; then\n      OPENGL_PATH=$with_opengl\n   fi\n   if test -d \"$OPENGL_PATH\"; then\n      NCBI_FIX_DIR(OPENGL_PATH)\n   fi\n   case \"$OSTYPE\" in\n      darwin) # Use native interface\n         OPENGL_LIBS=\"-framework AGL -framework OpenGL\"\n         # ... and its proprietary successor\n         OPENGL_LIBS=\"$OPENGL_LIBS -framework Metal -framework MetalKit\"\n\t OPENGL_LIBS=\"$OPENGL_LIBS -framework QuartzCore\"\n         ;;\n      # cygwin) ... ;;\n      *) # Default -- assume X-based\n         LIBS=\"$orig_LIBS\"\n         CPPFLAGS=\"$orig_CPPFLAGS\"\n         LDFLAGS=\"$orig_LDFLAGS $X_LIBS\"\n         if test -d \"$OPENGL_PATH/include/GL\"; then\n            OPENGL_INCLUDE=\"-I$OPENGL_PATH/include $X_CFLAGS\"\n         else\n            OPENGL_INCLUDE=$X_CFLAGS\n         fi\n         if test -n \"$OPENGL_PATH\" -a -d \"$OPENGL_PATH/lib${bit64_sfx}\"; then\n            NCBI_RPATHIFY(OPENGL_LIBPATH, $OPENGL_PATH/lib${bit64_sfx},\n                          [ ]$X_LIBS)\n         elif test -f /usr/lib/mesa/libGL.so; then\n            NCBI_RPATHIFY(OPENGL_LIBPATH, /usr/lib/mesa, [ ]$X_LIBS)\n         else\n            OPENGL_LIBPATH=$X_LIBS\n         fi\n         OPENGL_LIBS=\"$OPENGL_LIBPATH -lGLU -lGL $X_ALL_LIBS\"\n         ;;\n   esac\n   case \"${OPENGL_PATH}\" in\n      */*) where=\" in $OPENGL_PATH\" ;;\n      *  ) where= ;;\n   esac\n   AC_CACHE_CHECK([for OpenGL$where], ncbi_cv_lib_opengl,\n      [CPPFLAGS=\"$orig_CPPFLAGS $OPENGL_INCLUDE\"\n       LIBS=\"$OPENGL_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[\n           #ifdef NCBI_OS_DARWIN\n           #  include <OpenGL/gl.h>\n           #else\n           #  include <GL/gl.h>\n           #endif\n          ]],\n          [[glBegin(0);]])],\n          [ncbi_cv_lib_opengl=yes], [ncbi_cv_lib_opengl=no])])\nfi\n\nif test \"$with_opengl\" = \"no\" -o \"$ncbi_cv_lib_opengl\" = \"no\"; then\n   OPENGL_INCLUDE=\n   OPENGL_LIBS=\n   OPENGL_STATIC_LIBS=\n   OSMESA_INCLUDE=\n   OSMESA_LIBS=\n   OSMESA_STATIC_LIBS=\n   GLUT_INCLUDE=\n   GLUT_LIBS=\n   GLEW_INCLUDE=\n   GLEW_LIBS=\n   GLEW_STATIC_LIBS=\n   NCBI_MISSING_PACKAGE(opengl)\n   NCBI_MISSING_PACKAGE(gl2ps)\nelse\n   NCBI_PACKAGE(OpenGL)\n   AC_DEFINE(HAVE_OPENGL, 1, [Define to 1 if you have OpenGL (-lGL).])\n   if test -f \"$OPENGL_PATH/lib${bit64_sfx}/libGLU-static.a\"; then\n      OPENGL_STATIC_LIBS=\"$OPENGL_LIBPATH -lGLU-static -lGL-static $X_ALL_LIBS\"\n   else\n      OPENGL_STATIC_LIBS=$OPENGL_LIBS\n   fi\n   : ${OSMESA_PATH=$OPENGL_PATH}\n   if test \"$with_mesa\" != \"no\"; then\n      if test \"${with_mesa-yes}\" != \"yes\"; then\n         OSMESA_PATH=$with_mesa\n      fi\n      if test -d \"$OSMESA_PATH\"; then\n         OSMESA_INCLUDE=-I$OSMESA_PATH/include\n         if test \"$OSMESA_PATH\" != \"$OPENGL_PATH\"; then\n            NCBI_RPATHIFY(OSMESA_LDFLAGS, $OSMESA_PATH/lib${bit64_sfx})\n         fi\n      fi\n      LDFLAGS=\"$orig_LDFLAGS $OSMESA_LDFLAGS $OPENGL_LIBPATH\"\n      AC_CHECK_LIB(OSMesa, OSMesaCreateContext,\n         [NCBI_PACKAGE(MESA);\n          OSMESA_LIBS=\"$OSMESA_LDFLAGS $OPENGL_LIBPATH -lOSMesa -lGLU -lGL $X_ALL_LIBS\"\n          AC_DEFINE(HAVE_LIBOSMESA, 1, [Define to 1 if you have libOSMesa.])],\n         [OSMESA_LIBS=],\n         $OPENGL_LIBS)\n   fi\n   if test -z \"$OSMESA_LIBS\"; then\n      NCBI_MISSING_PACKAGE(mesa)\n   elif test -f \"$OSMESA_PATH/lib${bit64_sfx}/libOSMesa-static.a\"; then\n      OSMESA_STATIC_LIBS=\"$OSMESA_LDFLAGS $OPENGL_LIBPATH -lOSMesa-static -lGLU-static -lGL-static $X_ALL_LIBS\"\n   else\n      OSMESA_STATIC_LIBS=$OSMESA_LIBS\n   fi\n   if test \"$with_glut\" != \"no\"; then\n      if test \"${with_glut-yes}\" != \"yes\"; then\n         GLUT_PATH=$with_glut\n      fi\n      if test -d \"GLUT_PATH\"; then\n         GLUT_INCLUDE=-I$GLUT_PATH/include\n         NCBI_RPATHIFY(GLUT_LDFLAGS, $GLUT_PATH/lib${bit64_sfx})\n      fi\n      LDFLAGS=\"$orig_LDFLAGS $GLUT_LDFLAGS $OPENGL_LIBPATH\"\n      AC_CHECK_LIB(glut, glutInit,\n         [NCBI_PACKAGE(GLUT);\n          GLUT_LIBS=\"$GLUT_LDFLAGS $OPENGL_LIBPATH -lglut -lGLU -lGL $X_ALL_LIBS\"\n          AC_DEFINE(HAVE_LIBGLUT, 1, [Define to 1 if you have libglut.])],\n         [GLUT_LIBS=],\n         $OPENGL_LIBS)\n      if test -z \"$GLUT_LIBS\"; then\n         NCBI_MISSING_PACKAGE(glut)\n      fi\n   fi\n   if test \"$with_glew\" != \"no\"; then\n      if test \"${with_glew-yes}\" != \"yes\"; then\n         GLEW_PATH=$with_glew\n      fi\n      if test -d \"$GLEW_PATH\"; then\n         if test -d \"$GLEW_PATH/$compiler_vpfx$DEBUG_SFX$bit64_sfx\"; then\n            GLEW_PATH=$GLEW_PATH/$compiler_vpfx$DEBUG_SFX$bit64_sfx\n         elif test -d \"$GLEW_PATH/$compiler_pfx$DEBUG_SFX$bit64_sfx\"; then\n            GLEW_PATH=$GLEW_PATH/$compiler_pfx$DEBUG_SFX$bit64_sfx\n         elif test -d \"$GLEW_PATH/$DEBUG_SFX$bit64_sfx\"; then\n            GLEW_PATH=$GLEW_PATH/$DEBUG_SFX$bit64_sfx\n         fi\n         NCBI_FIX_DIR(GLEW_PATH)\n         GLEW_LIBDIR=$GLEW_PATH/lib\n         if test -n \"$bit64_sfx\" -a -d $GLEW_LIBDIR$bit64_sfx; then\n            if test -d $GLEW_LIBDIR; then\n               for x in $GLEW_LIBDIR/libGLEW*; do\n                  if cmp -s \"$x\" \"$GLEW_LIBDIR$bit64_sfx/`basename \\\"$x\\\"`\"; then\n                     :\n                  else\n                     GLEW_LIBDIR=$GLEW_LIBDIR$bit64_sfx\n                     break\n                  fi\n               done\n            else\n               GLEW_LIBDIR=$GLEW_LIBDIR$bit64_sfx\n            fi\n         fi\n      fi\n      glew_config=\"eval PKG_CONFIG_PATH=\\\"$GLEW_LIBDIR/pkgconfig\\\" pkg-config\"\n      if pkg-config --version >/dev/null 2>&1; then\n         if test \"$with_glew_mx\" != no \\\n           && $glew_config glewmx --exists >/dev/null 2>&1 \\\n           && test -n \"`$glew_config glewmx --libs 2>/dev/null`\"; then\n            glew_config=\"$glew_config glewmx\"\n         elif $glew_config glew --exists >/dev/null 2>&1 \\\n           && test -n \"`$glew_config glew --libs 2>/dev/null`\"; then\n            glew_config=\"$glew_config glew\"\n         else\n            glew_config=\n         fi\n         if test -n \"$glew_config\"; then\n            GLEW_INCLUDE=`$glew_config --cflags | sed 's:/GL *$::'`\n            GLEW_LDFLAGS=`$glew_config --libs-only-L`\n            glew_libname=`$glew_config --libs-only-l | sed -e 's/-l//'`\n         fi\n      fi\n      if test -z \"$glew_libname\" -a -d \"$GLEW_PATH\"; then\n         GLEW_INCLUDE=-I$GLEW_PATH/include\n         GLEW_LDFLAGS=-L$GLEW_LIBDIR\n      fi\n      LDFLAGS=\"$orig_LDFLAGS $GLEW_LDFLAGS\"\n      LIBS=\"$OPENGL_LIBS $orig_LIBS\"\n      NCBI_CHECK_LIBS(GLEW, [$glew_libname GLEWmx GLEW], glewGetExtension)\n      if test \"$ac_cv_search_glewGetExtension\" = no; then\n         GLEW_INCLUDE=\n         GLEW_LIBS=\n         NCBI_MISSING_PACKAGE(glew)\n         NCBI_MISSING_PACKAGE(glew-mx)\n      else\n         NCBI_RPATHIFY_OUTPUT_COND(tmp_LIBS, [echo $GLEW_LDFLAGS $GLEW_LIBS])\n         GLEW_LIBS=$tmp_LIBS\n         NCBI_PACKAGE(GLEW)\n         CPPFLAGS=\"$orig_CPPFLAGS $GLEW_INCLUDE $OPENGL_INCLUDE\"\n         LIBS=\"$GLEW_LIBS $OPENGL_LIBS $orig_LIBS\"\n         AC_CACHE_CHECK([for GLEW multi-context (MX) support],\n            ncbi_cv_lib_glew_mx,\n            [AC_LINK_IFELSE([AC_LANG_PROGRAM(\n               [[#define GLEW_MX 1\n                 #include <GL/glew.h>]],\n               [[glewContextInit(NULL);]])],\n             [ncbi_cv_lib_glew_mx=yes], [ncbi_cv_lib_glew_mx=no])])\n          if test $ncbi_cv_lib_glew_mx = yes; then\n             if test \"$with_glew_mx\" = no; then\n                GLEW_INCLUDE=\n                GLEW_LIBS=\n                NCBI_MISSING_PACKAGE(glew)\n             else\n                GLEW_INCLUDE=\"$GLEW_INCLUDE -DGLEW_MX\"\n             fi\n          else\n             NCBI_MISSING_PACKAGE(glew-mx)\n          fi\n          : ${GLEW_STATIC_LIBS=$GLEW_LIBDIR/libGLEW-static.a}\n          test -f \"$GLEW_STATIC_LIBS\"  ||  GLEW_STATIC_LIBS=$GLEW_LIBS\n      fi\n   fi\nfi\n\nLDFLAGS=$orig_LDFLAGS\n\n\n## wxWidgets\n# : ${with_wxwidgets_ucs=no}\nif test \"$with_wxwidgets\" != \"no\" ; then\n   case \"$with_wxwidgets\" in\n      yes | \"\" ) ;;\n      *        ) WXWIDGETS_PATH=$with_wxwidgets ;;\n   esac\n   if test -d \"$WXWIDGETS_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/lib\" \\\n        -a -z \"$WXWIDGETS_ARCH_PATH\"; then\n      WXWIDGETS_ARCH_PATH=\"$WXWIDGETS_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n   elif test -d \"$WXWIDGETS_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/lib\" \\\n        -a -z \"$WXWIDGETS_ARCH_PATH\"; then\n      WXWIDGETS_ARCH_PATH=\"$WXWIDGETS_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n   else\n      WXWIDGETS_ARCH_PATH=\"$WXWIDGETS_PATH\"\n   fi\n   WXWIDGETS_BINPATH=${WXWIDGETS_BINPATH:=\"$WXWIDGETS_ARCH_PATH/bin\"}\n   WXWIDGETS_LIBPATH=${WXWIDGETS_LIBPATH:=\"$WXWIDGETS_ARCH_PATH/lib\"}\n   WXWIDGETS_INCLUDE=\n   AS_UNSET(wxconf)\n   AC_PATH_PROG(wxconf, wx-config, [], $WXWIDGETS_BINPATH:$PATH)\n   if test -x \"$wxconf\"; then\n      WXWIDGETS_ARCH_PATH=`$wxconf --exec-prefix`\n      if test -n \"$with_wxwidgets_ucs\"; then\n         wxcfflags=--unicode=$with_wxwidgets_ucs\n      else\n         wxcfflags=\n      fi\n      for x in `\"$wxconf\" $wxcfflags --libs --static 2>&AS_MESSAGE_LOG_FD`; do\n         case \"$x\" in\n            -L*)\n                d=`echo $x | sed -e 's/^-L//'`\n                pcd=$d/pkgconfig\n                if test -d \"$pcd\"; then\n                   PKG_CONFIG_PATH=\"${PKG_CONFIG_PATH+$PKG_CONFIG_PATH:}$pcd\"\n                fi\n                ;;\n         esac\n      done\n      export PKG_CONFIG_PATH\n   else\n      AS_UNSET(wxconf)\n   fi\n   if test -x \"$wxconf\" \\\n     &&  \"$wxconf\" $wxcfflags --list 2>/dev/null \\\n       | grep 'Default config is gtk2' >/dev/null; then\n      gtkconf=\"pkg-config gtk+-2.0\"\n   elif test -x \"$WXWIDGETS_BINPATH/gtk-config\"; then\n      gtkconf=$WXWIDGETS_BINPATH/gtk-config\n   elif gtk-config --version >/dev/null 2>&1; then\n      gtkconf=gtk-config\n   else\n      # May work without gtk-config (e.g., on Mac OS X)\n      gtkconf=:\n   fi\n   case \"$host_os\" in\n      darwin* )\n         baseflags=\"\"\n         basesed='s/-isysroot [[^ ]]*//g; s/-arch [[^ ]]*//g'\n         if test -n \"$SYSROOT\"; then\n            deps=`\"$wxconf\" $wxcfflags --libs --static 2>/dev/null \\\n                  | sed -e 's/.*\\.a//'`\n            libsed=\"$basesed; s%\\$% $deps%\"\n         else\n            libsed=$basesed\n         fi\n         ;;\n      * )\n         baseflags=`$gtkconf --cflags 2>/dev/null`\n         basesed=$no_usr_lib\n         deps=`$gtkconf --libs 2>/dev/null`\n         libsed=\"$basesed; s%\\$% $deps%\"\n         ;;\n   esac\n   test -x \"$wxconf\"  &&  case \"`\"$wxconf\" $wxcfflags --version`\" in\n      1.* | 2.[[0-7]].* ) wxlibs=std ;;\n      *                 ) wxlibs=std,richtext,aui,propgrid ;;\n   esac\n   AC_CACHE_CHECK(\n      [for wxWidgets${WXWIDGETS_ARCH_PATH:+ in $WXWIDGETS_ARCH_PATH}],\n      ncbi_cv_lib_wxwidgets,\n      [if test -x \"$wxconf\" ; then\n          WXWIDGETS_INCLUDE=\"`\"$wxconf\" $wxcfflags --cflags` $baseflags\"\n          NCBI_RPATHIFY_OUTPUT(WXWIDGETS_LIBS,\n             [\"$wxconf\" $wxcfflags --libs $wxlibs],\n             [$libsed; s/ -lm / /g;])\n\n          CPPFLAGS=\"$WXWIDGETS_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$WXWIDGETS_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n             [[#include <wx/combobox.h>\n\t       class CMyComboBox : public wxComboBox {};]],\n             [[CMyComboBox cb; cb.Clear();]])],\n             [ncbi_cv_lib_wxwidgets=yes], [ncbi_cv_lib_wxwidgets=no])\n       else\n          ncbi_cv_lib_wxwidgets=no\n       fi])\n   if test \"$ncbi_cv_lib_wxwidgets\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(wxwidgets)\n   fi\nfi\n\nif test \"$with_wxwidgets\" = \"no\" ; then\n   WXWIDGETS_LIBPATH=\"No_wxWidgets\"\n   WXWIDGETS_INCLUDE=\n   WXWIDGETS_LIBS=\n   WXWIDGETS_STATIC_LIBS=\n   WXWIDGETS_GL_LIBS=\n   WXWIDGETS_GL_STATIC_LIBS=\n   WXWIDGETS_POST_LINK=:\nelse\n   NCBI_PACKAGE(wxWidgets)\n   case \"`\"$wxconf\" $wxcfflags --version`\" in\n      1.* | 2.[[0-7]].*) ;;\n      * ) NCBI_PACKAGE(wx2.8) ;;\n   esac\n   # The \"yes\" may have been cached; get the actual settings again if needed\n   if test -z \"$WXWIDGETS_INCLUDE\"; then\n      WXWIDGETS_INCLUDE=\"`\"$wxconf\" $wxcfflags --cflags` $baseflags\"\n   fi\n   NCBI_RPATHIFY_OUTPUT(WXWIDGETS_LIBS, [$wxconf $wxcfflags --libs $wxlibs],\n      [$libsed; s/ -lm / /g;])\n   WXWIDGETS_STATIC_LIBS=`\"$wxconf\" $wxcfflags --libs $wxlibs --static \\\n      2>/dev/null | sed -e \"$basesed; s/ -lm / /g;\"`\n   if test -n \"$WXWIDGETS_STATIC_LIBS\"; then\n      # Allow direct use of underlying libraries with strict linkers\n      WXWIDGETS_LIBS=\"$WXWIDGETS_LIBS `echo $WXWIDGETS_STATIC_LIBS | sed -e 's/.*\\.a *//'`\"\n   else\n      WXWIDGETS_STATIC_LIBS=$WXWIDGETS_LIBS\n   fi\n   WXWIDGETS_GL_LIBS=`\"$wxconf\" $wxcfflags --libs gl | sed -e \"$basesed\"`\n   WXWIDGETS_GL_STATIC_LIBS=`\"$wxconf\" $wxcfflags --libs gl --static \\\n      2>/dev/null | sed -e \"$basesed; s|-lGLU* -lGLU*|$OPENGL_STATIC_LIBS|\"`\n   : ${WXWIDGETS_GL_STATIC_LIBS:=$WXWIDGETS_GL_LIBS}\n   WXWIDGETS_POST_LINK=`\"$wxconf\" $wxcfflags --rezflags 2>/dev/null`\n   test -n \"$WXWIDGETS_POST_LINK\"  ||  WXWIDGETS_POST_LINK=:\n   wxpnglib=$WXWIDGETS_ARCH_PATH/lib/libpng.so\n   defpnglib=${PNG_PATH-/usr}/lib${bit64_sfx}/libpng.so\n   if test -f $wxpnglib  &&  \\\n       (test ! -f $defpnglib  ||  ! cmp -s $wxpnglib $defpnglib); then\n      PNG_PATH=$WXWIDGETS_ARCH_PATH\n      PNG_INCLUDE=$WXWIDGETS_INCLUDE\n   fi\n   wxtifflib=$WXWIDGETS_ARCH_PATH/lib/libtiff.so\n   deftifflib=${TIFF_PATH-/usr}/lib${bit64_sfx}/libtiff.so\n   if test -f $wxtifflib  &&  \\\n       (test ! -f $deftifflib  ||  ! cmp -s $wxtifflib $deftifflib); then\n      TIFF_PATH=$WXWIDGETS_ARCH_PATH\n      TIFF_INCLUDE=$WXWIDGETS_INCLUDE\n   fi\n   AC_DEFINE(HAVE_WXWIDGETS, 1, [Define to 1 if wxWidgets is available.])\nfi\n\n\n## In-house Fast-CGI library\nif test \"$with_fastcgi\" != \"no\" ; then\n   case \"$with_fastcgi\" in\n      yes | \"\" ) ;;\n      */*      ) FASTCGI_PATH=$with_fastcgi              ;;\n      *        ) FASTCGI_PATH=$NCBI/fcgi-${with_fastcgi} ;;\n   esac\n   if test -d \"$FASTCGI_PATH\"; then\n      NCBI_FIX_DIR(FASTCGI_PATH)\n   fi\n   FASTCGI_INCLUDE=\"-I$FASTCGI_PATH/include${bit64_sfx}\"\n   if test \"$with_debug\" = \"no\" ; then\n      FASTCGI_LIBDIR=\"$FASTCGI_PATH/lib${bit64_sfx}\"\n   else\n      FASTCGI_LIBDIR=\"$FASTCGI_PATH/altlib${bit64_sfx}\"\n   fi\n   NCBI_RPATHIFY(FASTCGI_LIBS, $FASTCGI_LIBDIR, [ -lfcgi $NETWORK_LIBS])\n   FASTCGI_OBJS=\"fcgibuf\"\n   LIBS=\"$FASTCGI_LIBS $orig_LIBS\"\n   AC_CACHE_CHECK([for FastCGI libraries${FASTCGI_PATH:+ in $FASTCGI_PATH}],\n      ncbi_cv_lib_fcgi,\n      [CPPFLAGS=\"$FASTCGI_INCLUDE $orig_CPPFLAGS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <fcgiapp.h>]],\n          [[ (void) FCGX_IsCGI(); ]])],\n          [ncbi_cv_lib_fcgi=yes], [ncbi_cv_lib_fcgi=no])])\n   if test \"$ncbi_cv_lib_fcgi\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(fastcgi)\n   fi\n   AC_CHECK_FUNCS(FCGX_Accept_r)\nfi\nif test \"$with_fastcgi\" = \"no\" ; then\n   FASTCGI_PATH=\"No_FastCgi\"\n   FASTCGI_INCLUDE=\n   FASTCGI_LIBS=\n   FASTCGI_OBJS=\nelse\n   NCBI_PACKAGE(Fast-CGI)\n   AC_DEFINE(HAVE_LIBFASTCGI, 1,\n             [Define to 1 if FastCGI libraries are available.])\nfi\n\n\n## NCBI SSS libraries\nif test \"$with_sybase\" = \"no\" ; then\n   NCBI_MISSING_PACKAGE(sssdb)\nfi\n\ncase \"$host_os:$compiler:$compiler_version\" in\n   linux*:GCC:*)\n      : ${with_included_sss=yes}\n   ;;\nesac\n\nif test \"$with_sss\" != \"no\" ; then\n   local_sss=${real_srcdir}/src/internal/sss\n   if test \"${with_included_sss-no}\" = \"yes\" \\\n       -a -f \"$local_sss/utils/sssdebug.hpp\" \\\n       -a -f \"${local_sss}srv/cli/sssconnection.cpp\"; then\n      with_included_sss=yes\n      NCBI_SSS_PATH=$local_sss\n      NCBI_SSS_INCLUDE=\"\\$(incdir)/sss\"\n      NCBI_SSS_LIBPATH=\"\\$(libdir)\"\n      NCBI_PACKAGE(LocalSSS)\n      if test -f \"$local_sss/../msgmail2/asn/msgmail.asn\"; then\n         NCBI_PACKAGE(LocalMSGMAIL2)\n      fi\n   else\n      with_included_sss=no\n   fi\n   if test \"${with_sss-yes}\" = yes; then\n      NCBI_SSS_PATH=${NCBI_SSS_PATH:=\"$NCBI/sss/BUILD\"}\n   else\n      NCBI_SSS_PATH=$with_sss\n   fi\n   NCBI_SSS_INCLUDE=${NCBI_SSS_INCLUDE:=\"$NCBI_SSS_PATH/include\"}\n   if test -z \"$NCBI_SSS_LIBPATH\" ; then\n      NCBI_SSS_LIBPATH=\"${NCBI_SSS_PATH}/lib/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}\"\n      if test \"$with_mt\" = \"yes\" ; then\n         NCBI_SSS_LIBPATH=\"${NCBI_SSS_LIBPATH}mt\"\n      fi\n   fi\n   AC_MSG_CHECKING(\n      [for NCBI SSS directories${NCBI_SSS_PATH:+ in $NCBI_SSS_PATH}])\n   if test \"$with_included_sss\" = \"yes\"; then\n      AC_MSG_RESULT([yes]) # duh\n   elif test ! -d \"${NCBI_SSS_LIBPATH}\"  -o  ! -d \"${NCBI_SSS_INCLUDE}\" ; then\n      AC_MSG_RESULT([no])\n      NCBI_MISSING_PACKAGE(sss)\n   else\n      AC_MSG_RESULT([yes])\n   fi\nfi\n\nif test \"$with_sss\" = \"no\" ; then\n   NCBI_MISSING_PACKAGE(sssutils)\n   NCBI_MISSING_PACKAGE(sssdb)\n   NCBI_SSS_INCLUDE=\n   NCBI_SSS_LIBPATH=\n   LIBSSSUTILS=\n   LIBSSSDB=\nelse\n   if test \"$with_included_sss\" = \"yes\"; then\n      NCBI_SSS_LIBPATH= # Not needed\n      ncbi_cv_lib_sssutils=yes\n      ncbi_cv_lib_sssdb=yes\n      sssutils=sssutils\n   else\n      NCBI_SSS_LIBPATH=\"-L${NCBI_SSS_LIBPATH}\"\n   fi\n   NCBI_SSS_INCLUDE=\"-I${NCBI_SSS_INCLUDE}\"\n\n   # SSS UTILS\n   if test \"$with_sssutils\" != \"no\" ; then\n      LIBSSSUTILS=\"-lsssutils\"\n      AC_CACHE_CHECK([for the NCBI SSS UTILS library], ncbi_cv_lib_sssutils,\n         [CPPFLAGS=\"$NCBI_SSS_INCLUDE $SYBASE_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$NCBI_SSS_LIBPATH $LIBSSSUTILS $SYBASE_LIBS $NETWORK_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n             [[#include <hashtab.hpp>]],\n             [[ (new C_HashTab(123))->Clear(); ]])],\n             [ncbi_cv_lib_sssutils=yes], [ncbi_cv_lib_sssutils=no])])\n      if test \"$ncbi_cv_lib_sssutils\" = yes; then\n         AC_DEFINE(HAVE_LIBSSSUTILS, 1,\n                   [Define to 1 if the NCBI SSS UTILS library is available.])\n         NCBI_PACKAGE(SSSUTILS)\n         if test -f \"$local_sss/../ncbils2/asn/login.asn\" \\\n           -a -n \"$GCRYPT_LIBS\"; then\n            if test \"$with_included_sss\" = yes  || \\\n               grep vformat $NCBI_SSS_INCLUDE/String.hpp >/dev/null 2>&1; then\n               NCBI_PACKAGE(LocalNCBILS) # temporary compatibility measure\n               NCBI_PACKAGE(NCBILS2)\n            fi\n         fi\n      else\n         NCBI_MISSING_PACKAGE(sssutils)\n         NCBI_MISSING_PACKAGE(sss)\n         LIBSSSUTILS=\"\"\n      fi\n   fi\n\n   # SSS DB\n   if test \"$with_sssdb\" != \"no\" ; then\n      if test \"$with_mt\" = \"yes\" ; then\n         LIBSSSDB=\"-lsssdb -lssssys\"\n      else\n         LIBSSSDB=\"-lsssdb\"\n      fi\n      AC_CACHE_CHECK([for the NCBI SSS DB library], ncbi_cv_lib_sssdb,\n         [CPPFLAGS=\"$NCBI_SSS_INCLUDE $SYBASE_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$NCBI_SSS_LIBPATH $LIBSSSDB $SYBASE_LIBS $NETWORK_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n             [[#include <cslink.hpp>]],\n             [[ (new CSLink)->connect2server(\"srv\", \"user\", \"pwd\", \"db\"); ]])],\n             [ncbi_cv_lib_sssdb=yes], [ncbi_cv_lib_sssdb=no])])\n      if test \"$ncbi_cv_lib_sssdb\" = \"yes\"; then\n         AC_DEFINE(HAVE_LIBSSSDB, 1,\n                   [Define to 1 if the NCBI SSS DB library is available.])\n         NCBI_PACKAGE(SSSDB)\n      else\n         NCBI_MISSING_PACKAGE(sssdb)\n         NCBI_MISSING_PACKAGE(sss)\n         LIBSSSDB=\"\"\n      fi\n   fi\nfi\n\n\n# SP\nif test \"$with_sp\" != \"no\" ; then\n   if test -n \"$SP_INCLUDE\"; then\n      SP_GENERIC=\"$SP_INCLUDE/../generic\"\n   else\n      SP_INCLUDE=\"$SP_PATH/include\"\n      SP_GENERIC=\"$SP_PATH/generic\"\n   fi\n   if test -z \"$SP_LIBPATH\" ; then\n      SP_LIBPATH=\"${SP_PATH}/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n   fi\n   AC_MSG_CHECKING([for SP directories${SP_PATH:+ in $SP_PATH}])\n   if test ! -d \"${SP_LIBPATH}\"  -o  ! -d \"${SP_INCLUDE}\" ; then\n      AC_MSG_RESULT([no])\n      NCBI_MISSING_PACKAGE(sp)\n   else\n      AC_MSG_RESULT([yes])\n   fi\nfi\n\nif test \"$with_sp\" != \"no\" ; then\n   if test -d \"$SP_GENERIC\"; then\n      SP_INCLUDE=\"-I${SP_INCLUDE} -I${SP_GENERIC}\"\n   else\n      SP_INCLUDE=\"-I${SP_INCLUDE}\"\n   fi\n   SP_LIBS=\"-L$SP_LIBPATH -lsp\"\n   AC_CACHE_CHECK([for the SP SGML library], ncbi_cv_lib_sp,\n      [CPPFLAGS=\"$SP_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$SP_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <SGMLApplication.h>]],\n          [[ SP_API::SGMLApplication app; ]])],\n          [ncbi_cv_lib_sp=yes], [ncbi_cv_lib_sp=no])])\n   if test \"$ncbi_cv_lib_sp\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(sp)\n   fi\nfi\n\nif test \"$with_sp\" = \"no\" ; then\n   SP_INCLUDE=\n   SP_LIBS=\nelse\n   NCBI_PACKAGE(SP)\n   AC_DEFINE(HAVE_LIBSP, 1, [Define to 1 if the SP SGML library is available.])\nfi\n\n\n## ORBacus CORBA\nif test \"$with_orbacus\" != no; then\n   if test \"$with_orbacus\" != yes; then\n       ORBACUS_PATH=$with_orbacus\n   fi\n   if test -d \"$ORBACUS_PATH\"; then\n      NCBI_FIX_DIR(ORBACUS_PATH)\n   fi\n   fullpath=${ORBACUS_PATH}/${DEBUG_SFX}${mt_sfx}${bit64_sfx}\n   if test -f ${fullpath}/inc/OB/Config.h ; then\n      : ${ORBACUS_INCLUDE=\"-I$ORBACUS_PATH/include -I$fullpath/inc\"}\n      NCBI_RPATHIFY_COND(ORBACUS_LIBPATH, $fullpath/lib)\n   elif test -f ${ORBACUS_PATH}/include/OB/Config.h ; then\n     : ${ORBACUS_INCLUDE=\"-I$ORBACUS_PATH/include\"}\n     NCBI_RPATHIFY_COND(ORBACUS_LIBPATH, $ORBACUS_PATH/lib)\n   fi\n   case \"$host_os:$with_mt\" in\n       linux*:no) LIBJTC=\"-lJTC -pthread\" ;;\n       *)         LIBJTC=\"-lJTC\"          ;;\n   esac\n\n   case \"$with_mt:$ORBACUS_LIBPATH\" in\n      yes:* | *:-L*MT/lib* )\n         LIBOB=\"-lOB $LIBJTC\"\n         LIBIMR=\"-lIMR\"\n         ;;\n      * )\n         LIBOB=\"-lOB\"\n         LIBIMR=\n         ;;\n   esac\n   AC_CACHE_CHECK([for ORBacus${ORBACUS_PATH:+ in $ORBACUS_PATH}],\n      ncbi_cv_lib_orbacus,\n      [CPPFLAGS=\"$ORBACUS_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$ORBACUS_LIBPATH $LIBOB $NETWORK_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE([AC_LANG_PROGRAM(\n          [[#include <OB/CORBA.h>]],\n          [[\n            int c = 0;\n            char* v[] = { NULL };\n            CORBA::ORB_var orb = CORBA::ORB_init(c, v);\n            if (!CORBA::is_nil(orb)) orb->destroy();\n          ]])],\n          [ncbi_cv_lib_orbacus=yes], [ncbi_cv_lib_orbacus=no])])\n   if test \"$ncbi_cv_lib_orbacus\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(orbacus)\n   fi\nfi\nif test \"$with_orbacus\" = no; then\n   ORBACUS_PATH=No_ORBacus\n   ORBACUS_INCLUDE=\n   ORBACUS_LIBPATH=\n   LIBOB=\n   LIBIMR=\nelse\n   NCBI_PACKAGE(ORBacus)\n   AC_DEFINE(HAVE_ORBACUS, 1,\n             [Define to 1 if the ORBacus CORBA package is available.])\nfi\n\n\n## International Components for Unicode (ICU)\nif test -z \"$ICU_PATH\"  &&  icu-config --version >/dev/null 2>&1; then\n    ICU_PATH=`icu-config --prefix`\nfi\n\nif test \"$with_icu\" != \"no\" ; then\n   case \"$with_icu\" in\n      yes | \"\" ) ;;\n      *        ) ICU_PATH=$with_icu ;;\n   esac\n   if test -d \"$ICU_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}/lib\" \\\n        -a -z \"$ICU_ARCH_PATH\"; then\n      ICU_ARCH_PATH=\"$ICU_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n   elif test -d \"$ICU_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}/lib\" \\\n        -a -z \"$ICU_ARCH_PATH\"; then\n      ICU_ARCH_PATH=\"$ICU_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n   else\n      ICU_ARCH_PATH=\"$ICU_PATH\"\n   fi\n   ICU_BINPATH=${ICU_BINPATH:=\"$ICU_ARCH_PATH/bin\"}\n   ICU_LIBPATH=${ICU_LIBPATH:=\"$ICU_ARCH_PATH/lib\"}\n   ICU_INCLUDE=\n   AC_CACHE_CHECK([for ICU${ICU_ARCH_PATH:+ in $ICU_ARCH_PATH}],\n      ncbi_cv_lib_icu,\n      [ICU_CONFIG=`$ICU_BINPATH/icu-config --bindir 2>/dev/null`/icu-config\n       if test -x \"$ICU_CONFIG\" ; then\n          ICU_INCLUDE=`$ICU_CONFIG --cppflags-searchpath`\n          NCBI_RPATHIFY_OUTPUT(ICU_LIBS, $ICU_CONFIG --ldflags-searchpath)\n          ICU_LIBS=\"$ICU_LIBS `$ICU_CONFIG --ldflags-libsonly`\"\n\n          CPPFLAGS=\"$ICU_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$ICU_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE([AC_LANG_PROGRAM(\n            [[#include <unicode/unistr.h>]],\n            [[int32_t i = UNICODE_STRING_SIMPLE(\"foo\").indexOf('f');]])],\n            [ncbi_cv_lib_icu=yes], [ncbi_cv_lib_icu=no])\n       else\n          ncbi_cv_lib_icu=no\n       fi])\n   if test \"$ncbi_cv_lib_icu\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(icu)\n   fi\nfi\n\nif test \"$with_icu\" = \"no\" ; then\n   ICU_PATH=\"No_ICU\"\n   ICU_INCLUDE=\n   ICU_LIBS=\n   ICU_STATIC_LIBS=\nelse\n   NCBI_PACKAGE(ICU)\n   ICU_CONFIG=\"`$ICU_BINPATH/icu-config --bindir`/icu-config\"\n   # The \"yes\" may have been cached; get the actual settings again if needed\n   if test -z \"$ICU_INCLUDE\"; then\n      ICU_INCLUDE=`$ICU_CONFIG --cppflags-searchpath`\n      NCBI_RPATHIFY_OUTPUT(ICU_LIBS, $ICU_CONFIG --ldflags-searchpath)\n      ICU_LIBS=\"$ICU_LIBS `$ICU_CONFIG --ldflags-libsonly`\"\n   fi\n   ICU_SEARCHPATH=`$ICU_CONFIG --ldflags-searchpath | sed -e \"$no_usr_lib\"`\n   ICU_STATIC_LIBS=`$ICU_CONFIG --ldflags-libsonly | sed -e 's/-licu/-lsicu/g'`\n   ICU_STATIC_LIBS=\"$ICU_SEARCHPATH $ICU_STATIC_LIBS\"\n   AC_DEFINE(HAVE_ICU, 1, [Define to 1 if ICU libraries are available.])\nfi\n\n\n### XML/XSL libraries\nNCBI_CHECK_THIRD_PARTY_LIB(expat,\n AC_LANG_PROGRAM([#include <expat.h>],\n    [XML_Parser parser = XML_ParserCreate(\"utf-8\");]))\nif test -f \"${EXPAT_PATH}/lib${bit64_sfx}/libexpat-static.a\"; then\n   EXPAT_STATIC_LIBS=\"-L${EXPAT_PATH}/lib${bit64_sfx} -lexpat-static\"\nelse\n   EXPAT_STATIC_LIBS=${EXPAT_LIBS}\nfi\nvpath=\"$SABLOT_PATH/${compiler_vpfx}build\"\ntest -d \"$vpath\"  &&  SABLOT_PATH=$vpath\nif test -d \"$SABLOT_PATH\"; then\n   NCBI_FIX_DIR(SABLOT_PATH)\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(sablot,\n AC_LANG_PROGRAM([#include <sablot.h>],\n    [SDOM_Document* D; int x = SablotParse(NULL, \"file:/dev/null\", D);]),\n $EXPAT_LIBS)\nif test -f \"${SABLOT_PATH}/lib${bit64_sfx}/libsablot-static.a\"; then\n   SABLOT_STATIC_LIBS=\"-L${SABLOT_PATH}/lib${bit64_sfx} -lsablot-static $EXPAT_STATIC_LIBS\"\nelse\n   SABLOT_STATIC_LIBS=${SABLOT_LIBS}\nfi\n\n# test -d \"$LIBXML_PATH\" || LIBXML_PATH=`xml2-config --prefix 2>/dev/null`\nif test \"$with_libxml\" != \"no\"; then\n   case \"$with_libxml\" in\n      yes | \"\" ) ;;\n      *        ) LIBXML_PATH=$with_libxml ;;\n   esac\n   for pfx in \"$compiler_vpfx\" \"$compiler_pfx\" \"\" ; do\n      vpath=$LIBXML_PATH/$pfx${DEBUG_SFX}${mt_sfx}${bit64_sfx}\n      if test -d \"$vpath\" ; then\n         LIBXML_PATH=$vpath\n         break\n      fi\n   done\n   if test -d \"$LIBXML_PATH\"; then\n      NCBI_FIX_DIR(LIBXML_PATH)\n      in_path=\" in $LIBXML_PATH\"\n      if test -n \"$LIBXML_INCLUDE\"; then\n         :\n      elif test -d \"$LIBXML_PATH/include/libxml2/libxml\"; then\n         LIBXML_INCLUDE=\"-I$LIBXML_PATH/include/libxml2 -I$LIBXML_PATH/include\"\n      elif test -d \"$LIBXML_PATH/include/libxml\"; then\n         LIBXML_INCLUDE=\"-I$LIBXML_PATH/include\";\n      else\n         case \"$host_os\" in\n            darwin* )\n               LIBXML_INCLUDE=\"-iwithsysroot $LIBXML_PATH/include/libxml2\"\n               ;;\n         esac\n      fi\n      if test -d \"$LIBXML_PATH/lib${bit64_sfx}\"; then\n         LIBXML_LIBPATH_=\"$LIBXML_PATH/lib${bit64_sfx}\"\n      elif test -d \"$LIBXML_PATH/lib\"; then\n         LIBXML_LIBPATH_=\"$LIBXML_PATH/lib\"\n      fi\n      NCBI_RPATHIFY_COND(LIBXML_LIBPATH, $LIBXML_LIBPATH_)\n      LIBXML_LIBS=\"$LIBXML_LIBPATH -lxml2\"\n   else\n      case \"$host_os\" in\n         darwin* ) LIBXML_INCLUDE=\"-iwithsysroot /usr/include/libxml2\" ;;\n         *       ) LIBXML_INCLUDE=\"-I/usr/include/libxml2\" ;;\n      esac\n      LIBXML_LIBS=\"-lxml2\"\n      in_path=\n   fi\n   LIBXML_LIBS=\"$LIBXML_LIBS $ICONV_LIBS\"\n   AC_CACHE_CHECK([for libxml2$in_path], ncbi_cv_lib_libxml,\n      CPPFLAGS=\"$LIBXML_INCLUDE $orig_CPPFLAGS\"\n      LIBS=\"$LIBXML_LIBS $orig_LIBS\"\n      [AC_LINK_IFELSE(\n         [AC_LANG_PROGRAM(\n             [#include <libxml/parser.h>],\n             [xmlDocPtr doc = xmlParseFile(\"foo.xml\");])],\n      [ncbi_cv_lib_libxml=yes], [ncbi_cv_lib_libxml=no])])\n   if test \"$ncbi_cv_lib_libxml\" = \"no\"; then\n      NCBI_MISSING_PACKAGE(libxml)\n   fi\nfi\nif test \"$with_libxml\" = \"no\"; then\n   LIBXML_PATH=\"No_LIBXML\"\n   LIBXML_INCLUDE=\n   LIBXML_LIBPATH_=\n   LIBXML_LIBS=\nelse\n   NCBI_PACKAGE(LIBXML)\n   LIBXML_INCLUDE=\"$LIBXML_INCLUDE\"\n   AC_DEFINE(HAVE_LIBXML, 1, [Define to 1 if libxml2 is available.])\n   export LIBXML_LIBPATH\nfi\nAC_SUBST(LIBXML_INCLUDE)\nAC_SUBST(LIBXML_LIBS)\n\nif test -f \"${LIBXML_LIBPATH_}/libxml2-static.a\"; then\n   LIBXML_STATIC_LIBS=\"-L${LIBXML_LIBPATH_} -lxml2-static $ICONV_LIBS\"\n   if test \"x$with_bin_release\" = \"xyes\"; then\n      LIBXML_LIBS=$LIBXML_STATIC_LIBS\n   fi\nelse\n   LIBXML_STATIC_LIBS=${LIBXML_LIBS}\nfi\n\n: ${LIBXSLT_PATH=$LIBXML_PATH}\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libxslt, LIBXSLT, xslt,\n [AC_LANG_PROGRAM([#include <libxslt/xslt.h>], [xsltInit()])],\n [], [$LIBXML_LIBS $Z_LIBS], [$LIBXML_INCLUDE])\n\n# XXX - they might be in different directories in some setups\nif test -f \"${LIBXML_LIBPATH_}/libxslt-static.a\"; then\n   LIBXSLT_STATIC_LIBS=\"-L${LIBXML_LIBPATH_} -lxslt-static\"\n   if test \"x$with_bin_release\" = \"xyes\"; then\n      LIBXSLT_LIBS=$LIBXSLT_STATIC_LIBS\n   fi\nelse\n   LIBXSLT_STATIC_LIBS=${LIBXSLT_LIBS}\nfi\n\nAC_PATH_PROG(XSLTPROC, xsltproc, :,\n   [$LIBXSLT_PATH/bin:`dirname $LIBXML_LIBPATH_ 2>/dev/null`/bin:$PATH])\n\n: ${LIBEXSLT_PATH=$LIBXSLT_PATH}\nif env PKG_CONFIG_PATH=$LIBEXSLT_PATH/lib/pkgconfig pkg-config libexslt --libs \\\n    2>/dev/null | $EGREP_Q gcrypt; then\n   exslt_autodep=$GCRYPT_LIBS\nelse\n   exslt_autodep=\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libexslt, LIBEXSLT, exslt,\n [AC_LANG_PROGRAM([#include <libexslt/exslt.h>], [exsltRegisterAll()])],\n [$exslt_autodep], [$LIBXSLT_LIBS $LIBXML_LIBS $Z_LIBS], [$LIBXSLT_INCLUDE])\n\n# XXX - they might be in different directories in some setups\nif test -f \"${LIBXML_LIBPATH_}/libexslt-static.a\"; then\n   LIBEXSLT_STATIC_LIBS=\"-L${LIBXML_LIBPATH_} -lexslt-static $GCRYPT_LIBS\"\n   if test \"x$with_bin_release\" = \"xyes\"; then\n      LIBEXSLT_LIBS=$LIBEXSLT_STATIC_LIBS\n   fi\nelse\n   LIBEXSLT_STATIC_LIBS=${LIBEXSLT_LIBS}\nfi\n\nif test \"$with_xerces\" != no; then\n   if test \"${with_xerces-yes}\" != yes; then\n      XERCES_PATH=$with_xerces\n   fi\n   if test -d \"$XERCES_PATH\"; then\n      NCBI_FIX_DIR(XERCES_PATH)\n   fi\n   vpath=\"$XERCES_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n   if test -d \"$vpath/lib\"; then\n      XERCES_PATH=$vpath\n      NCBI_FIX_DIR(XERCES_PATH)\n   elif test -d \"$vpath\"; then\n      : ${XERCES_LIBPATH=$vpath}\n      NCBI_FIX_DIR(XERCES_LIBPATH)\n   else\n      vpath=\"$XERCES_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n      if test -d \"$vpath/lib\"; then\n         XERCES_PATH=$vpath\n         NCBI_FIX_DIR(XERCES_PATH)\n      elif test -d \"$vpath\"; then\n         XERCES_LIBPATH=$vpath\n         NCBI_FIX_DIR(XERCES_LIBPATH)\n      fi\n   fi\n   if test -d \"$XERCES_PATH\"; then\n      in_path=\" in $XERCES_PATH\"\n      : ${XERCES_INCLUDE=-I$XERCES_PATH/include}\n      : ${XERCES_LIBPATH=$XERCES_PATH/lib}\n   else\n      in_path=''\n   fi\n   NCBI_RPATHIFY(XERCES_LIBPATH_, $XERCES_LIBPATH)\n   XERCES_LIBS=\"$XERCES_LIBPATH_ -lxerces-c\"\n   AC_CACHE_CHECK([for Xerces-C++$in_path], ncbi_cv_lib_xerces_c,\n      [CPPFLAGS=\"$XERCES_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$XERCES_LIBS $ICU_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <xercesc/dom/DOM.hpp>]],\n             [[xercesc::DOMImplementation* impl\n               = xercesc::DOMImplementationRegistry::getDOMImplementation\n                 (xercesc::XMLString::transcode(\"XML 1.0\"));]])],\n          ncbi_cv_lib_xerces_c=yes, ncbi_cv_lib_xerces_c=no)])\n   if test $ncbi_cv_lib_xerces_c = yes; then\n      if test -f \"$XERCES_LIBPATH/libxerces-c-static.a\"; then\n         XERCES_STATIC_LIBS=\"-L$XERCES_LIBPATH -lxerces-c-static $CURL_LIBS\"\n      else\n         XERCES_STATIC_LIBS=$XERCES_LIBS\n      fi\n   else\n      NCBI_MISSING_PACKAGE(xerces)\n   fi\nfi\nif test \"$with_xerces\" != no; then\n   NCBI_PACKAGE(Xerces)\n   AC_DEFINE(HAVE_XERCES, 1, [Define to 1 if Xerces-C++ is available.])\nelse\n   XERCES_INCLUDE=\n   XERCES_LIBS=\n   XERCES_STATIC_LIBS=\nfi\n\nif test \"$with_xalan\" != no; then\n   if test \"${with_xalan-yes}\" != yes; then\n      XALAN_PATH=$with_xalan\n   fi\n   if test -d \"$XALAN_PATH\"; then\n      NCBI_FIX_DIR(XALAN_PATH)\n   fi\n   vpath=\"$XALAN_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n   if test -d \"$vpath/lib\"; then\n      XALAN_PATH=$vpath\n      NCBI_FIX_DIR(XALAN_PATH)\n   elif test -d \"$vpath\"; then\n      : ${XALAN_LIBPATH=$vpath}\n      NCBI_FIX_DIR(XALAN_LIBPATH)\n   else\n      vpath=\"$XALAN_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}${mt_sfx}\"\n      if test -d \"$vpath/lib\"; then\n         XALAN_PATH=$vpath\n         NCBI_FIX_DIR(XALAN_PATH)\n      elif test -d \"$vpath\"; then\n         XALAN_LIBPATH=$vpath\n         NCBI_FIX_DIR(XALAN_LIBPATH)\n      fi\n   fi\n   if test -d \"$XALAN_PATH\"; then\n      in_path=\" in $XALAN_PATH\"\n      : ${XALAN_INCLUDE=-I$XALAN_PATH/include}\n      : ${XALAN_LIBPATH=$XALAN_PATH/lib}\n   else\n      in_path=''\n   fi\n   NCBI_RPATHIFY(XALAN_LIBPATH_, $XALAN_LIBPATH)\n   XALAN_LIBS=\"$XALAN_LIBPATH_ -lxalan-c -lxalanMsg\"\n   AC_CACHE_CHECK([for Xalan-C++$in_path], ncbi_cv_lib_xalan_c,\n      [CPPFLAGS=\"$XALAN_INCLUDE $XERCES_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$XALAN_LIBS $XERCES_LIBS $ICU_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <xalanc/XalanTransformer/XalanTransformer.hpp>]],\n             [[xalanc::XalanTransformer::initialize();]])],\n          ncbi_cv_lib_xalan_c=yes, ncbi_cv_lib_xalan_c=no)])\n   if test $ncbi_cv_lib_xalan_c = yes; then\n      if test -f \"$XALAN_LIBPATH/libxalan-c-static.a\"; then\n         XALAN_STATIC_LIBS=\"-L$XALAN_LIBPATH -lxalan-c-static -lxalanMsg-static\"\n      else\n         XALAN_STATIC_LIBS=$XALAN_LIBS\n      fi\n   else\n      NCBI_MISSING_PACKAGE(xalan)\n   fi\nfi\nif test \"$with_xalan\" != no; then\n   NCBI_PACKAGE(Xalan)\n   AC_DEFINE(HAVE_XALAN, 1, [Define to 1 if Xalan-C++ is available.])\nelse\n   XALAN_INCLUDE=\n   XALAN_LIBS=\n   XALAN_STATIC_LIBS=\nfi\n\nif test \"$with_zorba\" != no; then\n   if test \"${with_zorba-yes}\" != yes; then\n      ZORBA_PATH=$with_zorba\n   fi\n   if test -d \"$ZORBA_PATH\"; then\n      NCBI_FIX_DIR(ZORBA_PATH)\n   fi\n   vpath=\"$ZORBA_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n   if test -d \"$vpath/lib\"; then\n      ZORBA_PATH=$vpath\n      NCBI_FIX_DIR(ZORBA_PATH)\n   elif test -d \"$vpath\"; then\n      : ${ZORBA_LIBPATH=$vpath}\n      NCBI_FIX_DIR(ZORBA_LIBPATH)\n   else\n      vpath=\"$ZORBA_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\"\n      if test -d \"$vpath/lib\"; then\n         ZORBA_PATH=$vpath\n         NCBI_FIX_DIR(ZORBA_PATH)\n      elif test -d \"$vpath\"; then\n         ZORBA_LIBPATH=$vpath\n         NCBI_FIX_DIR(ZORBA_LIBPATH)\n      fi\n   fi\n   ZORBA_CONFIG=\"$ZORBA_PATH/bin/zorba-config\"\n   if test -x \"$ZORBA_CONFIG\"; then\n      ZORBA_PATH=`$ZORBA_CONFIG --prefix`\n      : ${ZORBA_INCLUDE=`$ZORBA_CONFIG --cppflags`}\n   fi\n   if test -d \"$ZORBA_PATH\"; then\n      in_path=\" in $ZORBA_PATH\"\n      : ${ZORBA_INCLUDE=-I$ZORBA_PATH/include}\n      : ${ZORBA_LIBPATH=$ZORBA_PATH/lib}\n   else\n      in_path=''\n   fi\n   if test -x \"$ZORBA_CONFIG\"; then\n      ZORBA_LIBS=`$ZORBA_CONFIG --libs`\n   else\n      NCBI_RPATHIFY(ZORBA_LIBPATH_, $ZORBA_LIBPATH)\n      ZORBA_LIBS=\"$ZORBA_LIBPATH_ -lzorba_simplestore\"\n   fi\n   AC_CACHE_CHECK([for Zorba$in_path], ncbi_cv_lib_zorba,\n      [CPPFLAGS=\"$ZORBA_INCLUDE $orig_CPPFLAGS\"\n       LIBS=\"$ZORBA_LIBS $orig_LIBS\"\n       AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM([[#include <zorba/zorba.h>]],\n             [[zorba::Version v = zorba::Zorba::version();]])],\n          ncbi_cv_lib_zorba=yes, ncbi_cv_lib_zorba=no)])\n   if test $ncbi_cv_lib_zorba = yes; then\n      if test -x \"$ZORBA_CONFIG\"; then\n         ZORBA_STATIC_LIBS=`$ZORBA_CONFIG --static-libs`\n      elif test -f \"$ZORBA_LIBPATH/libzorba_simplestore-static.a\"; then\n         ZORBA_STATIC_LIBS=\"-L$ZORBA_LIBPATH -lzorba_simplestore-static $XERCES_STATIC_LIBS $ICU_STATIC_LIBS $LIBXSLT_STATIC_LIBS $LIBXML_STATIC_LIBS\"\n      else\n         ZORBA_STATIC_LIBS=$ZORBA_LIBS\n      fi\n   else\n      NCBI_MISSING_PACKAGE(zorba)\n   fi\nfi\nif test \"$with_zorba\" != no; then\n   NCBI_PACKAGE(Zorba)\n   AC_DEFINE(HAVE_ZORBA, 1, [Define to 1 if Zorba is available.])\nelse\n   ZORBA_INCLUDE=\n   ZORBA_LIBS=\n   ZORBA_STATIC_LIBS=\nfi\n\n### SQLite\ncase \"$with_sqlite3\" in\n   yes | '' ) ;;\n   *        ) SQLITE3_PATH=$with_sqlite3 ;;\nesac\n\nif test -d \"$SQLITE3_PATH\"; then\n   NCBI_FIX_DIR(SQLITE3_PATH)\nfi\nif test -d \"$SQLITE3_PATH/${compiler_pfx}${DEBUG_SFX}${MT_SFX}${bit64_sfx}/lib\"; then\n   SQLITE3_LIBDIR=$SQLITE3_PATH/${compiler_pfx}${DEBUG_SFX}${MT_SFX}${bit64_sfx}/lib\nelif test -d $SQLITE3_PATH/lib${bit64_sfx}; then\n   SQLITE3_LIBDIR=$SQLITE3_PATH/lib${bit64_sfx}\nelse\n   SQLITE3_LIBDIR=$SQLITE3_PATH/lib\nfi\nNCBI_RPATHIFY(SQLITE3_LIBPATH, $SQLITE3_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB(sqlite3,\n AC_LANG_PROGRAM([#include <sqlite3.h>],\n    [sqlite3_pcache_methods m;\n     int status = sqlite3_config(SQLITE_CONFIG_GETPCACHE, &m);]))\nif test -n \"$SQLITE3_LIBS\"; then\n   CPPFLAGS=\"$SQLITE3_INCLUDE $orig_CPPFLAGS\"\n   AC_CHECK_HEADER(sqlite3async.h,\n      [AC_DEFINE(HAVE_SQLITE3ASYNC_H, 1,\n          [Define to 1 if you have the <sqlite3async.h> header file.])\n       NCBI_PACKAGE(SQLITE3ASYNC)])\n   LIBS=\"$SQLITE3_LIBS $orig_LIBS\"\n   AC_CHECK_FUNCS(sqlite3_unlock_notify)\n   SQLITE3_WRAPPER=sqlitewrapp\nelse\n   SQLITE3_WRAPPER=\nfi\nif test -n \"$SQLITE3_LIBS\" -a -f \"$SQLITE3_LIBDIR/libsqlite3-static.a\"; then\n   SQLITE3_STATIC_LIBS=\"-L$SQLITE3_LIBDIR -lsqlite3-static\"\n   if test \"x$with_bin_release\" = \"xyes\"; then\n      SQLITE3_LIBS=$SQLITE3_STATIC_LIBS\n   fi\nelse\n   SQLITE3_STATIC_LIBS=$SQLITE3_LIBS\nfi\n\n\n# NCBI SRA/VDB\nVDB_POST_LINK=:\nVDB_REQ=VDB\nif test \"$with_vdb\" != \"no\" ; then\n   # CURL?\n   vdb_deps=\"$NETWORK_LIBS $BZ2_LIBS $Z_LIBS $DL_LIBS\"\n   # In MT builds, ORIG_LIBS already contains THREAD_LIBS.  However,\n   # VDB is always threaded, and may need explicit THREAD_LIBS when\n   # used statically.\n   if test \"$with_mt\" = no; then\n      vdb_deps=\"$vdb_deps $THREAD_LIBS\"\n   fi\n   vdb_static_deps=\"$LIBXML_STATIC_LIBS $vdb_deps\"\n   vdb_deps=\"$LIBXML_LIBS $vdb_deps\"\n   if test \"${with_vdb:-yes}\" != \"yes\" -a -d \"$with_vdb\"; then\n      VDB_PATH=$with_vdb\n   fi\n   if test -d \"$VDB_PATH\"; then\n      : ${with_downloaded_vdb=no}\n   else\n      : ${with_downloaded_vdb=$with_vdb}\n   fi\n   if test \"$with_downloaded_vdb\" != \"no\"; then\n      AC_MSG_NOTICE([trying to build the NCBI SRA/VDB Toolkit from GitHub.])\n      VDB_PATH=`$real_srcdir/scripts/common/add_vdb.sh 2>&AS_MESSAGE_LOG_FD`\n      status=$?\n      if test $status != 0; then\n         message=\"SRA/VDB build failed with status $status\"\n      elif test ! -d \"$VDB_PATH\"; then\n         message=\"SRA/VDB build nominally succeeded, but failed to report where\"\n      else\n         message=\n      fi\n      case \"$message:$with_downloaded_vdb\" in\n         :*    ) ;;\n         *:yes ) AC_MSG_FAILURE([$message]) ;;\n         *     ) AC_MSG_WARN([$message])  ;;\n      esac\n   fi\n   # if test \"$with_included_vdb\" != \"yes\"; then\n      if test -z \"$VDB_PATH\"; then\n         in_path=\n      else\n         dnl NCBI_FIX_DIR(VDB_PATH)\n         vdb_parent=`dirname \"$VDB_PATH\"`\n         NCBI_FIX_DIR(vdb_parent)\n         VDB_PATH=$vdb_parent/`basename \"$VDB_PATH\"`\n         in_path=\" in $VDB_PATH\"\n         for x in interfaces include; do\n            if test -d \"$VDB_PATH/$x\"; then\n               vdb_inc_root=$VDB_PATH/$x\n               : ${VDB_INCLUDE=\"-I$vdb_inc_root\"}\n               break\n            fi\n         done\n         vdb_inc_subdirs=cc/gcc\n         case \"$host_cpu:$bit64_sfx\" in\n            *86*:64 ) vdb_inc_subdirs=\"cc/gcc/x86_64 $vdb_inc_subdirs\" ;;\n            *86*:*  ) vdb_inc_subdirs=\"cc/gcc/fat86 $vdb_inc_subdirs\" ;;\n         esac\n         if test \"$ncbi_compiler\" = ICC; then\n            vdb_inc_subdirs=\"cc/icc $vdb_inc_subdirs\"\n         fi\n         case \"$host_os\" in\n            darwin*  ) vdb_inc_subdirs=\"os/mac os/unix $vdb_inc_subdirs\" ;;\n            linux*   ) vdb_inc_subdirs=\"os/linux os/unix $vdb_inc_subdirs\" ;;\n            solaris* ) vdb_inc_subdirs=\"os/sun os/unix $vdb_inc_subdirs\" ;;\n         esac\n         for x in $vdb_inc_subdirs; do\n            VDB_INCLUDE=\"$VDB_INCLUDE -I$vdb_inc_root/$x\"\n         done\n         case \"$DEBUG_SFX\" in\n            Debug )\n               VDB_INCLUDE=\"$VDB_INCLUDE -D_DEBUGGING\"\n               vdb_mode=debug\n               ;;\n            Release )\n               vdb_mode=release\n               ;;\n         esac\n         case \"$host_os:$host_cpu:$bit64_sfx\" in\n            darwin*:*86*:64 ) vdb_libpath=mac/$vdb_mode/x86_64/lib   ;;\n            darwin*:*86*:* )  vdb_libpath=mac/$vdb_mode/fat86/lib    ;;\n            linux*:*86*:64 )  vdb_libpath=linux/$vdb_mode/x86_64/lib ;;\n            * )\n               if test -n \"$with_vdb\"; then\n                  AC_MSG_ERROR([--with-vdb explicitly specified,\n                                but not supported on this platform.])\n               fi\n               ;;\n         esac\n         for x in \"$vdb_libpath\" \"lib${bit64_sfx:-32}\" lib; do\n            if test -n \"$x\" -a -d \"$VDB_PATH/$x\"; then\n               : ${VDB_LIBDIR=$VDB_PATH/$x}\n               break\n            fi\n         done\n      fi\n      NCBI_RPATHIFY_COND(VDB_LIBS, $VDB_LIBDIR, [ -lncbi-vdb $vdb_deps])\n      CPPFLAGS=\"$orig_CPPFLAGS $VDB_INCLUDE\"\n      LIBS=\"$orig_LIBS $VDB_LIBS\"\n      AC_CACHE_CHECK([for ncbi-vdb$in_path], ncbi_cv_lib_ncbi_vdb,\n         AC_LINK_IFELSE([\n            AC_LANG_PROGRAM([#include <sra/sradb.h>],\n               [const SRAMgr* mgr; SRAMgrMakeRead(&mgr);])],\n            [ncbi_cv_lib_ncbi_vdb=yes], [ncbi_cv_lib_ncbi_vdb=no]))\n      if test \"$ncbi_cv_lib_ncbi_vdb\" = yes; then\n         NCBI_PACKAGE(VDB)\n         if test -f \"$VDB_LIBDIR/libncbi-vdb-static.a\"; then\n            VDB_STATIC_LIBS=\"-L$VDB_LIBDIR -lncbi-vdb-static $vdb_static_deps\"\n            if test \"$with_static_vdb\" = yes; then\n               VDB_LIBS=\"-L$VDB_LIBDIR -lncbi-vdb-static $vdb_deps\"\n            fi\n         else\n            VDB_STATIC_LIBS=$VDB_LIBS\n         fi\n         case \"$host_os\" in\n            darwin*)\n               inst_name=`otool -D $VDB_LIBDIR/libncbi-vdb.dylib 2>/dev/null \\\n                          | grep -v ':$'`\n               case \"$inst_name\" in\n                   @executable_path* )\n                      major=`echo $inst_name | sed -ne 's,.*/libncbi-vdb\\.\\([[1-9]][[0-9]]*\\).*\\.dylib$,\\1,p'`\n                      test -z \"$major\"  || \\\n                         VDB_POST_LINK=\"install_name_tool -change $inst_name @rpath/libncbi-vdb.$major.dylib\"\n                      ;;\n               esac\n               ;;\n         esac\n         AC_DEFINE(HAVE_NCBI_VDB, 1,\n            [Define to 1 if you have NCBI's SRA/VDB SDK/Toolkit.])\n         bamread=bamread\n         sraread=sraread\n         ncbi_id2proc_snp=ncbi_id2proc_snp\n         ncbi_id2proc_wgs=ncbi_id2proc_wgs\n         ncbi_xloader_bam=ncbi_xloader_bam\n         ncbi_xloader_csra=ncbi_xloader_csra\n         ncbi_xloader_snp=ncbi_xloader_snp\n         ncbi_xloader_sra=ncbi_xloader_sra\n         ncbi_xloader_vdbgraph=ncbi_xloader_vdbgraph\n         ncbi_xloader_wgs=ncbi_xloader_wgs\n      else\n         VDB_INCLUDE=\n         VDB_LIBS=\n         VDB_STATIC_LIBS=\n         bamread=\n         sraread=\n         ncbi_id2proc_snp=\n         ncbi_id2proc_wgs=\n         ncbi_xloader_bam=\n         ncbi_xloader_csra=\n         ncbi_xloader_snp=\n         ncbi_xloader_sra=\n         ncbi_xloader_vdbgraph=\n         ncbi_xloader_wgs=\n      fi\n   # else ...\n   # fi\n   if test -z \"$VDB_LIBS\"; then\n      NCBI_MISSING_PACKAGE(vdb)\n   fi\nfi\n\n\n### OEChem\n# somewhat kludgish, as we now wanto to add in oeiupac and oedepict,\n# which depend on oechem....\nNCBI_CHECK_THIRD_PARTY_LIB(oechem,\n AC_LANG_PROGRAM([#include <oechem.h>],\n    [OEChem::OEMol mol; OEChem::OEConfBase* c = mol.GetActive();]),\n  -loeiupac -loedepict -loechem -loesystem -loeplatform -lz, $NETWORK_LIBS)\nif test -n \"$OECHEM_LIBS\"; then\n   OECHEM_LIBS=`echo $OECHEM_LIBS | sed -e 's/-loechem \\(.*-loechem .*\\)/\\1/'`\nfi\n\n\n### Sun/Univa Grid Engine\ncase \"$with_sge\" in\n   yes | \"\" ) ;;\n   *        ) SGE_PATH=$with_sge ;;\nesac\nif test -d \"$SGE_PATH\" -a -z \"$SGE_LIBPATH\"; then\n   case \"$host:$NCBI_PLATFORM_BITS\" in\n      i?86-*-darwin*      ) SGE_PLATFORMS='darwin-x86'          ;;\n      i?86-*-linux*       ) SGE_PLATFORMS='lx24-x86 lx-x86'     ;;\n      i?86-*-solaris*:32  ) SGE_PLATFORMS='sol-x86'             ;;\n      i?86-*-solaris*:64  ) SGE_PLATFORMS='sol-amd64'           ;;\n      powerpc-*-darwin*   ) SGE_PLATFORMS='darwin-ppc'          ;;\n      sparc-*-solaris*:32 ) SGE_PLATFORMS='sol-sparc'           ;;\n      sparc-*-solaris*:64 ) SGE_PLATFORMS='sol-sparc64'         ;;\n      x86_64-*-linux*     ) SGE_PLATFORMS='lx24-amd64 lx-amd64' ;;\n   esac\n   for x in $SGE_PLATFORMS; do\n      if test -d \"$SGE_PATH/lib/$x\"; then\n         SGE_LIBPATH=\"$SGE_PATH/lib/$x\"\n         break\n      fi\n   done\n   BASE_SGE_LIBPATH=$SGE_LIBPATH\n   NCBI_RPATHIFY(SGE_LIBPATH, $SGE_LIBPATH)\n   # Try to use a dedicated directory without alternate versions of\n   # system libraries such as OpenSSL.\n   if test -d \"$BASE_SGE_LIBPATH\" -a -d \"$SGE_PATH/lib/drmaa\"; then\n      SGE_LIBPATH=`echo $SGE_LIBPATH \\\n          | sed -e \"s,-L$BASE_SGE_LIBPATH,-L$SGE_PATH/lib/drmaa,g\"`\n   fi\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(sge, SGE, drmaa,\n  [[AC_LANG_PROGRAM([[#include <sys/types.h>\n                      #include <drmaa.h>]],\n     [[char buf[1024]; drmaa_init(\"SGE\", buf, sizeof(buf));]])]])\n\n\n### muParser\ncase \"$with_muparser\" in\n   yes | '' ) ;;\n   *        ) MUPARSER_PATH=$with_muparser ;;\nesac\n\nif test -d \"$MUPARSER_PATH\"; then\n   NCBI_FIX_DIR(MUPARSER_PATH)\nfi\nif test -d \"$MUPARSER_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}/lib\"; then\n   MUPARSER_LIBPATH=-L$MUPARSER_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}/lib\nelif test -d \"$MUPARSER_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}/lib\"; then\n   MUPARSER_LIBPATH=-L$MUPARSER_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}/lib\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB(muparser,\n  [[AC_LANG_PROGRAM([[#include <muParser.h>]],\n     [[mu::Parser parser;]])]])\n\n\n### hdf5\ncase \"$with_hdf5\" in\n   yes | '' ) ;;\n   *        ) HDF5_PATH=$with_hdf5 ;;\nesac\n\nif test -d \"$HDF5_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}\"; then\n   HDF5_PATH=$HDF5_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}\nelif test -d \"$HDF5_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}\"; then\n   HDF5_PATH=$HDF5_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}\nfi\nif test -d \"$HDF5_PATH\"; then\n   NCBI_FIX_DIR(HDF5_PATH)\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(hdf5, HDF5, hdf5_cpp,\n  [[AC_LANG_PROGRAM([[#include <H5Cpp.h>]],\n     [[H5::H5Library::open();]])]],\n  [-lhdf5])\n\n\n### Image libraries\n# : ${JPEG_PATH=/usr/sfw}\n# Grr... jpeglib.h isn't especially well-behaved.\nNCBI_CHECK_THIRD_PARTY_LIB(jpeg,\n AC_LANG_PROGRAM([#include <sys/types.h>\n                  #include <stdio.h>\n                  extern \"C\" {\n                  #include <jpeglib.h>\n                  }],\n    [struct jpeg_decompress_struct cinfo;\n     struct jpeg_error_mgr         jerr;\n     cinfo.err = jpeg_std_error(&jerr);\n ]))\n\n# : ${PNG_PATH=/usr/sfw}\nNCBI_CHECK_THIRD_PARTY_LIB(png,\n AC_LANG_PROGRAM([#include <png.h>],\n    [png_structp png_ptr\n      = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n ]), $Z_LIBS, [], $Z_INCLUDE)\n\n# : ${TIFF_PATH=/usr/sfw}\nNCBI_CHECK_THIRD_PARTY_LIB(tiff,\n AC_LANG_PROGRAM([#include <tiffio.h>],\n    [TIFF* tiff = TIFFOpen(\"foo\", \"r\");]), $Z_LIBS, $JPEG_LIBS)\n## etc.\n\n# Paths?\nwith_ungif=$with_gif\nNCBI_CHECK_THIRD_PARTY_LIB(gif,\n AC_LANG_PROGRAM([extern \"C\" {\n                  #include <gif_lib.h>\n                  }],\n    [GifFileType* fp = DGifOpenFileName(\"foo\");]), $X_LIBS -lX11)\nif test \"$with_gif\" = \"no\"; then\n   NCBI_CHECK_THIRD_PARTY_LIB(ungif,\n    AC_LANG_PROGRAM([extern \"C\" {\n                     #include <gif_lib.h>\n                     }],\n       [GifFileType* fp = DGifOpenFileName(\"foo\");]), $X_LIBS -lX11)\nelse\n   AC_DEFINE(HAVE_LIBUNGIF, 1, [Define to 1 if libungif is available.])\n   UNGIF_INCLUDE=$GIF_INCLUDE\n   UNGIF_LIBS=$GIF_LIBS\nfi\n\ncase \"$x_libraries\" in */*) : ${XPM_PATH=`dirname \"$x_libraries\"`} ;; esac\nNCBI_CHECK_THIRD_PARTY_LIB(Xpm,\n AC_LANG_PROGRAM([#include <X11/xpm.h>],\n    [XpmImage image; XpmInfo info;\n     XpmReadFileToXpmImage(\"foo\", &image, &info);]), $X_LIBS -lX11, [],\n    $X_CFLAGS)\n# The use of X_CFLAGS is probably redundant, but shouldn't hurt.\n\nif test \"$with_gl2ps\" != \"no\"; then\n   if test \"${with_gl2ps-yes}\" != \"yes\"; then\n      GL2PS_PATH=$with_gl2ps\n   fi\n   if test -d \"$GL2PS_PATH\"; then\n      if test -d \"$GL2PS_PATH/$compiler_vpfx$DEBUG_SFX$bit64_sfx\"; then\n         GL2PS_PATH=$GL2PS_PATH/$compiler_vpfx$DEBUG_SFX$bit64_sfx\n      elif test -d \"$GL2PS_PATH/$compiler_pfx$DEBUG_SFX$bit64_sfx\"; then\n         GL2PS_PATH=$GL2PS_PATH/$compiler_pfx$DEBUG_SFX$bit64_sfx\n      elif test -d \"$GL2PS_PATH/$DEBUG_SFX$bit64_sfx\"; then\n         GL2PS_PATH=$GL2PS_PATH/$DEBUG_SFX$bit64_sfx\n      fi\n      NCBI_FIX_DIR(GL2PS_PATH)\n   fi\n   NCBI_CHECK_THIRD_PARTY_LIB(gl2ps,\n    AC_LANG_PROGRAM([#include <gl2ps.h>],\n       [gl2psSpecial(GL2PS_SVG, \"foo\")]),\n    [], [$OPENGL_LIBS $PNG_LIBS $Z_LIBS], [$OPENGL_INCLUDE])\nfi\nif test -n \"$GL2PS_LIBS\" -a -f \"$GL2PS_PATH/lib/libgl2ps-static.a\"; then\n   GL2PS_STATIC_LIBS=\"-L$GL2PS_PATH/lib -lgl2ps-static\"\nelse\n   GL2PS_STATIC_LIBS=$GL2PS_LIBS\nfi\n\n## FreeType and FTGL\nif test \"$with_freetype\" != \"no\" ; then\n   : ${FREETYPE_BINPATH=$FREETYPE_PATH/bin}\n   AC_PATH_PROG(freetype_config, freetype-config, [],\n                [$FREETYPE_BINPATH:$PATH])\n   if test -n \"$freetype_config\" ; then\n      : ${FREETYPE_BINPATH=`dirname $freetype_config`}\n      : ${FREETYPE_INCLUDE=`$freetype_config --cflags`}\n      NCBI_RPATHIFY_OUTPUT_COND(FREETYPE_LIBS, $freetype_config --libs,\n         [$no_usr_lib])\n      case \"$host_os:$bit64_sfx\" in\n         solaris*:64 )\n            ftprefix=`$freetype_config --exec-prefix`\n            if test -d \"$ftprefix/lib/64\"; then\n               FREETYPE_LIBS=`echo $FREETYPE_LIBS \\\n                   | sed -e \"s,$ftprefix/lib ,$ftprefix/lib/64 ,g\"`\n            fi\n            ;;\n      esac\n      AC_CACHE_CHECK([whether FREETYPE_INCLUDE needs doctoring],\n                     ncbi_cv_lib_freetype_fix_include,\n         [CPPFLAGS=\"$FREETYPE_INCLUDE $orig_CPPFLAGS\"\n          AC_COMPILE_IFELSE(\n             [AC_LANG_PROGRAM(\n                 [[#include <ft2build.h>]], [])],\n             [ncbi_cv_lib_freetype_fix_include=no],\n             [ncbi_cv_lib_freetype_fix_include=yes])])\n      if test \"$ncbi_cv_lib_freetype_fix_include\" = yes; then\n         FREETYPE_INCLUDE=`echo \"$FREETYPE_INCLUDE\" |\\\n             sed -e 's:\\(-I[[^ ]]*\\)\\(/freetype2\\):\\1 \\1\\2:g'`\n      fi\n      AC_CACHE_CHECK([whether FreeType works], ncbi_cv_lib_freetype,\n         [CPPFLAGS=\"$FREETYPE_INCLUDE $orig_CPPFLAGS\"\n          LIBS=\"$FREETYPE_LIBS $orig_LIBS\"\n          AC_LINK_IFELSE(\n             [AC_LANG_PROGRAM(\n                 [[#include <ft2build.h>\n                   #include FT_FREETYPE_H]],\n                 [[FT_Select_Charmap(NULL, ft_encoding_unicode);]])],\n             [ncbi_cv_lib_freetype=yes], [ncbi_cv_lib_freetype=no])])\n      if test \"$ncbi_cv_lib_freetype\" = no; then\n         NCBI_MISSING_PACKAGE(freetype)\n      fi\n   else\n      NCBI_MISSING_PACKAGE(freetype)\n   fi\nfi\nif test \"$with_freetype\" = \"no\" ; then\n   FREETYPE_PATH=\"No_FREETYPE\"\n   FREETYPE_INCLUDE=\n   FREETYPE_LIBS=\nelse\n   NCBI_PACKAGE(FreeType)\n   AC_DEFINE(HAVE_FREETYPE, 1, [Define to 1 if FreeType is available.])\nfi\n\ncase \"$with_ftgl\" in\n   yes | '' ) ;;\n   *        ) FTGL_PATH=$with_ftgl ;;\nesac\n\nif test -d \"$FTGL_PATH\"; then\n   NCBI_FIX_DIR(FTGL_PATH)\nfi\nif test -d \"$FTGL_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}/lib\"; then\n   FTGL_LIBDIR=$FTGL_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}/lib\nelif test -d \"$FTGL_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}/lib\"; then\n   FTGL_LIBDIR=$FTGL_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}/lib\nfi\nNCBI_FIX_DIR(FTGL_LIBDIR)\nNCBI_RPATHIFY(FTGL_LIBPATH, $FTGL_LIBDIR)\n\nNCBI_CHECK_THIRD_PARTY_LIB(ftgl,\n  [[AC_LANG_PROGRAM([[#include <FTGL/ftgl.h>]], [[FTSimpleLayout layout;]])]],\n  [$FREETYPE_LIBS], [], [$FREETYPE_INCLUDE])\n\n\nNCBI_CHECK_THIRD_PARTY_LIB(magic,\n   [AC_LANG_PROGRAM([#include <magic.h>],\n       [magic_t m = magic_open(17);])])\n\n\n# Mimetic\ncase \"$with_mimetic\" in\n   yes | '' ) ;;\n   *        ) MIMETIC_PATH=$with_mimetic ;;\nesac\nif test -d \"$MIMETIC_PATH\"; then\n   NCBI_FIX_DIR(MIMETIC_PATH)\nfi\nfor d in \"$MIMETIC_LIBDIR\" \\\n         \"$MIMETIC_PATH/${compiler_vpfx}${DEBUG_SFX}${bit64_sfx}/lib\" \\\n         \"$MIMETIC_PATH/${compiler_pfx}${DEBUG_SFX}${bit64_sfx}/lib\" \\\n         \"$MIMETIC_PATH/lib${bit64_sfx}\" \\\n         \"$MIMETIC_PATH/${compiler_vpfx}${DEBUG_SFX}/lib\" \\\n         \"$MIMETIC_PATH/${compiler_pfx}${DEBUG_SFX}/lib\" \\\n         \"$MIMETIC_PATH/lib\"; do\n   if test -d \"$d\"; then\n      MIMETIC_LIBDIR=$d\n      break\n   fi\ndone\nNCBI_RPATHIFY(MIMETIC_LIBPATH, $MIMETIC_LIBDIR)\n\nNCBI_CHECK_THIRD_PARTY_LIB(mimetic,\n   [AC_LANG_PROGRAM([#include <mimetic/mimetic.h>],\n       [mimetic::MimeEntity me;])])\n\n\n# gSOAP++\ncase \"$with_gsoap\" in\n   yes | '' ) ;;\n   *        ) GSOAP_PATH=$with_gsoap ;;\nesac\nif test -d \"$GSOAP_PATH\"; then\n   NCBI_FIX_DIR(GSOAP_PATH)\nfi\nfor d in \"$GSOAP_LIBDIR\" \\\n         \"$GSOAP_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/lib\" \\\n         \"$GSOAP_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}/lib\" \\\n         \"$GSOAP_PATH/lib${bit64_sfx}\" \\\n         \"$GSOAP_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}/lib\" \\\n         \"$GSOAP_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}/lib\" \\\n         \"$GSOAP_PATH/lib\"; do\n   if test -d \"$d\"; then\n      GSOAP_LIBDIR=$d\n      NCBI_FIX_DIR(GSOAP_LIBDIR)\n      break\n   fi\ndone\nNCBI_RPATHIFY(GSOAP_LIBPATH, $GSOAP_LIBDIR)\n\n: ${GSOAP_BINDIR=`dirname \"$GSOAP_LIBDIR\"`/bin}\nAC_PATH_PROG(GSOAP_SOAPCPP2, soapcpp2, [], $GSOAP_BINDIR:$PATH)\nAC_PATH_PROG(GSOAP_WSDL2H,   wsdl2h,   [], $GSOAP_BINDIR:$PATH)\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(gsoap, GSOAP, gsoapssl++,\n   [AC_LANG_PROGRAM([#include <stdsoap2.h>\n        SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultcode(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultsubcode(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultstring(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 const char** SOAP_FMAC4 soap_faultdetail(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 const char* SOAP_FMAC4 soap_check_faultsubcode(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 const char* SOAP_FMAC4 soap_check_faultdetail(struct soap*)\n        { return NULL; }\n        SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap*) { }\n        SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap*) { return 0; }\n        SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap*) { return 0; }\n        SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap*) { }\n        SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap*) { return 0; }\n        SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap*) { return 0; }],\n       [soap s;])],\n   $OPENSSL_LIBS $Z_LIBS)\n\n\n# Apache Avro\nif test \"$with_avro\" != no; then\n   case \"$with_avro\" in\n      yes | '' ) ;;\n      *        ) AVRO_PATH=$with_avro ;;\n   esac\n   for d in \"$AVRO_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\" \\\n            \"$AVRO_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\" \\\n            \"$AVRO_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}\" \\\n            \"$AVRO_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}\"; do\n      if test -d \"$d\"; then\n         AVRO_PATH=$d\n         break\n      fi\n   done\n   if test -d \"$AVRO_PATH\"; then\n      NCBI_FIX_DIR(AVRO_PATH)\n   fi\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(avro, AVRO, avrocpp,\n   [AC_LANG_PROGRAM([#include <avro/Node.hh>],\n      [avro::Name name(\"foo\");])],\n   [$BOOST_LIBPATH $BOOST_FILESYSTEM_LIBS $BOOST_SYSTEM_LIBS $BOOST_PROGRAM_OPTIONS_LIBS $BOOST_IOSTREAMS_LIBS $RT_LIBS $Z_LIBS $BZ2_LIBS],\n   [],\n   [$BOOST_INCLUDE])\nif test -n \"$AVRO_LIBS\"; then\n   if test -f \"$AVRO_PATH/lib/libavrocpp_s.a\"; then\n      AVRO_STATIC_LIBS=\"$AVRO_LIBPATH -lavrocpp_s $BOOST_LIBPATH $BOOST_FILESYSTEM_LIBS $BOOST_SYSTEM_LIBS $BOOST_PROGRAM_OPTIONS_LIBS $BOOST_IOSTREAMS_LIBS $RT_LIBS $Z_LIBS $BZ2_LIBS\"\n   else\n      AVRO_STATIC_LIBS=$AVRO_LIBS\n   fi\n   AC_PATH_PROG(AVROGENCPP, avrogencpp, [], [$AVRO_PATH/bin:$PATH])\nfi\n\n\n# USC Cereal (header-only)\ncase \"$with_cereal\" in\n   yes | no | '' ) ;;\n   *             ) CEREAL_PATH=$with_cereal ;;\nesac\nif test \"$with_cereal\" != no; then\n   in_cereal=\n   if test -d \"$CEREAL_PATH\"; then\n      NCBI_FIX_DIR(CEREAL_PATH)\n      in_cereal=\" in $CEREAL_PATH\"\n   fi\n   CEREAL_INCLUDE=-I$CEREAL_PATH/include\n   AC_CACHE_CHECK([for USC Cereal$in_cereal], ncbi_cv_lib_cereal,\n      [CPPFLAGS=\"$CEREAL_INCLUDE $orig_CPPFLAGS\"\n       AC_COMPILE_IFELSE(\n          [AC_LANG_PROGRAM([[#include <iostream>\n                             #include <cereal/archives/binary.hpp>]],\n                           [[cereal::BinaryOutputArchive\n                             archive(std::cout);]])],\n          [ncbi_cv_lib_cereal=yes], [ncbi_cv_lib_cereal=no])])\n    if test \"$ncbi_cv_lib_cereal\" = yes; then\n       NCBI_PACKAGE(Cereal)\n    else\n       NCBI_MISSING_PACKAGE(cereal)\n       CEREAL_INCLUDE=\n    fi\nfi\n\n\n# SASL 2\nNCBI_CHECK_THIRD_PARTY_LIB(sasl2,\n [[AC_LANG_PROGRAM([[#include <stdlib.h>\n                     #include <sasl/sasl.h>]],\n   [[sasl_client_init(NULL);]])]])\n\n\n# legacy MongoDB\ncase \"$with_mongodb\" in\n   yes | no | '' ) ;;\n   *             ) MONGODB_PATH=$with_mongodb ;;\nesac\nif test -d \"$MONGODB_PATH\"; then\n   NCBI_FIX_DIR(MONGODB_PATH)\nfi\nif test -d $MONGODB_PATH/lib${bit64_sfx}; then\n   MONGODB_LIBDIR=$MONGODB_PATH/lib${bit64_sfx}\nelse\n   MONGODB_LIBDIR=$MONGODB_PATH/lib\nfi\n# need Boost rpath\nNCBI_RPATHIFY(MONGODB_LIBPATH, $MONGODB_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB_EX(mongodb, MONGODB, mongoclient,\n   [AC_LANG_PROGRAM([#include <mongo/client/dbclient.h>],\n      [std::vector<mongo::HostAndPort> v;\n       mongo::DBClientReplicaSet client(\"foo\", v);\n       client.connect();])],\n   [$BOOST_LIBPATH $boost_fs_lib $BOOST_REGEX_LIBS $BOOST_THREAD_LIBS $OPENSSL_LIBS $SASL2_LIBS], [],\n   [$BOOST_INCLUDE])\n# MongoDB's own library is normally static, but its supporting Boost\n# libraries might not be by default.\nif test -n \"$MONGODB_LIBS\"; then\n   MONGODB_STATIC_LIBS=\"$MONGODB_LIBPATH -lmongoclient $BOOST_LIBPATH $boost_fs_static_lib $BOOST_REGEX_STATIC_LIBS $BOOST_THREAD_STATIC_LIBS $OPENSSL_LIBS $SASL2_LIBS\"\nelse\n   MONGODB_STATIC_LIBS=\nfi\n\n\n# MongoDB 3.x\nif test \"$with_mongodb3\" != no; then\n   case \"$with_mongodb3\" in\n      yes | '' ) ;;\n      *        ) MONGODB3_PATH=$with_mongodb3 ;;\n   esac\n   for d in \"$MONGODB3_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\" \\\n            \"$MONGODB3_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}${bit64_sfx}\" \\\n            \"$MONGODB3_PATH/${compiler_vpfx}${DEBUG_SFX}${mt_sfx}\" \\\n            \"$MONGODB3_PATH/${compiler_pfx}${DEBUG_SFX}${mt_sfx}\"; do\n      if test -d \"$d\"; then\n         MONGODB3_PATH=$d\n         break\n      fi\n   done\n   if test -d \"$MONGODB3_PATH\"; then\n      NCBI_FIX_DIR(MONGODB3_PATH)\n   fi\nfi\nif test -d $MONGODB3_PATH/lib${bit64_sfx}; then\n   MONGODB3_LIBDIR=$MONGODB3_PATH/lib${bit64_sfx}\nelse\n   MONGODB3_LIBDIR=$MONGODB3_PATH/lib\nfi\nm3pc=\"env PKG_CONFIG_PATH=$MONGODB3_LIBDIR/pkgconfig pkg-config libmongocxx\"\nif $m3pc --exists >/dev/null 2>&1; then\n   MONGODB3_FULL_INCLUDE=`$m3pc --cflags`\n   NCBI_RPATHIFY_OUTPUT(MONGODB3_FULL_LIBS, [$m3pc --libs --static],\n      [$no_usr_lib])\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(mongodb3, MONGODB3, mongocxx,\n   [AC_LANG_PROGRAM([#include <mongocxx/client.hpp>],\n      [mongocxx::client mongo_client;])],\n   [], [$MONGODB3_FULL_LIBS],\n   [$MONGODB3_FULL_INCLUDE $BOOST_INCLUDE])\nif test -n \"$MONGODB3_LIBS\"; then\n   MONGODB3_INCLUDE=$MONGODB3_FULL_INCLUDE\n   MONGODB3_LIBS=$MONGODB3_FULL_LIBS\n   if $m3pc-static --exists >/dev/null 2>&1; then\n      MONGODB3_STATIC_LIBS=`$m3pc-static --libs --static`\n   elif test -f $MONGODB3_LIBDIR/libmongocxx-static.a; then\n      MONGODB3_STATIC_LIBS=`echo \"$MONGODB3_LIBS\" | \\\n        [sed -e 's/-lmongo[^ ]*/&-static/g; s/-lbson[^ ]*/&-static/g' \\\n             -e 's/\\(-l[^ ]*-static[^ ]*\\)-static/\\1/g']`\n   else\n      MONGODB3_STATIC_LIBS=$MONGODB3_LIBS\n   fi\nfi\n\n\n# Google Mock\ncase \"$with_gmock\" in\n   yes | no | '' ) ;;\n   *             ) GMOCK_PATH=$with_gmock ;;\nesac\nif test -d \"$GMOCK_PATH\"; then\n   NCBI_FIX_DIR(GMOCK_PATH)\n   for d in \"$GMOCK_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx/lib\" \\\n            \"$GMOCK_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx/lib\" \\\n            \"$GMOCK_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx/lib\" \\\n            \"$GMOCK_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx/lib\" \\\n            \"$GMOCK_PATH/lib$bit64_sfx\" \"$GMOCK_PATH/lib\"; do\n      if test -d \"$d\"; then\n         GMOCK_LIBDIR=$d\n         NCBI_FIX_DIR(GMOCK_LIBDIR)\n         break\n      fi\n   done\nfi\nNCBI_RPATHIFY(GMOCK_LIBPATH, $GMOCK_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB(gmock,\n   [AC_LANG_PROGRAM([#include <gmock/gmock.h>],\n      [int    my_argc;\n       char** my_argv;\n       testing::InitGoogleMock(&my_argc, my_argv);])],\n   [-lgtest])\n\n\n# LAPACK\nCPPFLAGS=\"-DHAVE_LAPACK_CONFIG_H $orig_CPPFLAGS\"\ncase \"$with_lapack\" in\n   yes | no | '' ) ;;\n   *             ) LAPACK_PATH=$with_lapack ;;\nesac\nif test -d \"$LAPACK_PATH\"; then\n   NCBI_FIX_DIR(LAPACK_PATH)\n   CPPFLAGS=\"-I$LAPACK_PATH/include $CPPFLAGS\"\nfi\nAC_LANG_PUSH(C)\nAC_CHECK_HEADERS(lapacke.h lapacke/lapacke.h clapack.h Accelerate/Accelerate.h)\nAC_LANG_POP(C)\nif test \"$ac_cv_header_clapack_h:$ac_cv_header_Accelerate_Accelerate_h\" != no:no; then\n   AC_CHECK_TYPES([__CLPK_integer], [], [],\n      [[#ifdef HAVE_CLAPACK_H\n        #  include <clapack.h>\n        #else\n        #  include <Accelerate/Accelerate.h>\n        #endif]])\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB(lapack,\n   [AC_LANG_PROGRAM([[extern \"C\" int dsyev_();]],\n      [[return dsyev_();]])],\n   [-lblas])\n\n# LMDB\nNCBI_CHECK_THIRD_PARTY_LIB(lmdb,\n   [AC_LANG_PROGRAM([[#include <lmdb.h>]],\n      [[MDB_env *env; return mdb_env_create(&env);]])],\n   [$THREAD_LIBS])\nif test -z \"$LMDB_LIBS\"; then\n   lmdblocal=util/lmdb\n   AC_MSG_NOTICE([using local LMDB copy in $lmdblocal])\n   LMDB_PATH=\"<$lmdblocal>\"\n   LMDB_INCLUDE=\"-I\\$(includedir)/$lmdblocal -I\\$(includedir0)/$lmdblocal\"\n   # In MT builds, ORIG_LIBS already contains THREAD_LIBS.  However,\n   # LMDB is always threaded, and may need explicit THREAD_LIBS when\n   # used statically.\n   LMDB_LIBS=\"$THREAD_LIBS\"\n   # LMDB_LIBS=\"-llmdb $THREAD_LIBS\"\n   LMDB_LIB=\"lmdb\"\n   AC_DEFINE(USE_LOCAL_LMDB, 1, [Define to 1 if using a local copy of LMDB.])\n   NCBI_PACKAGE(LMDB)\n   NCBI_PACKAGE(LocalLMDB)\nfi\nif test \"$with_lmdb\" != no -a -f \"$LMDB_PATH/lib/liblmdb-static.a\"; then\n    LMDB_STATIC_LIBS=\"-L$LMDB_PATH/lib -llmdb-static\"\n    if test \"x$with_bin_release\" = \"xyes\"; then\n       LMDB_LIBS=$LMDB_STATIC_LIBS\n    fi\nelse\n    LMDB_STATIC_LIBS=$LMDB_LIBS\nfi\n\n# libuv\ncase \"$with_libuv\" in\n   yes | no | '' ) ;;\n   *             ) LIBUV_PATH=$with_libuv ;;\nesac\nif test -d \"$LIBUV_PATH\"; then\n   NCBI_FIX_DIR(LIBUV_PATH)\n   for d in \"$LIBUV_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx/lib\" \\\n            \"$LIBUV_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx/lib\" \\\n            \"$LIBUV_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx/lib\" \\\n            \"$LIBUV_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx/lib\" \\\n            \"$LIBUV_PATH/lib$bit64_sfx\" \"$LIBUV_PATH/lib\"; do\n      if test -d \"$d\"; then\n         LIBUV_LIBDIR=$d\n         NCBI_FIX_DIR(LIBUV_LIBDIR)\n         break\n      fi\n   done\nfi\nNCBI_RPATHIFY(LIBUV_LIBPATH, $LIBUV_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libuv, LIBUV, uv,\n   [AC_LANG_PROGRAM([[#include <uv.h>]],\n      [[uv_mutex_t m; return uv_mutex_init(&m);]])])\nif test \"$with_libuv\" != no -a -f \"$LIBUV_LIBDIR/libuv-static.a\"; then\n    LIBUV_STATIC_LIBS=\"-L$LIBUV_LIBDIR -luv-static\"\nelse\n    LIBUV_STATIC_LIBS=$LIBUV_LIBS\nfi\n\n# libssh2\ncase \"$with_libssh2\" in\n   yes | no | '' ) ;;\n   *             ) LIBSSH2_PATH=$with_libssh2 ;;\nesac\nif test -d \"$LIBSSH2_PATH\"; then\n   NCBI_FIX_DIR(LIBSSH2_PATH)\n   for d in \"$LIBSSH2_PATH/$compiler_vpfx$DEBUG_SFX$bit64_sfx/lib\" \\\n            \"$LIBSSH2_PATH/$compiler_pfx$DEBUG_SFX$bit64_sfx/lib\" \\\n            \"$LIBSSH2_PATH/$compiler_vpfx$DEBUG_SFX/lib\" \\\n            \"$LIBSSH2_PATH/$compiler_pfx$DEBUG_SFX/lib\" \\\n            \"$LIBSSH2_PATH/lib$bit64_sfx\" \"$LIBSSH2_PATH/lib\"; do\n      if test -d \"$d\"; then\n         LIBSSH2_LIBDIR=$d\n         NCBI_FIX_DIR(LIBSSH2_LIBDIR)\n         break\n      fi\n   done\nfi\nNCBI_RPATHIFY(LIBSSH2_LIBPATH, $LIBSSH2_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libssh2, LIBSSH2, ssh2,\n   [AC_LANG_PROGRAM([[#include <libssh2.h>]],\n      [[return libssh2_init(LIBSSH2_INIT_NO_CRYPTO);]])],\n   [$OPENSSL_LIBS])\nif test \"$with_libssh2\" != no -a -f \"$LIBSSH2_LIBDIR/libssh2-static.a\"; then\n    LIBSSH2_STATIC_LIBS=\"-L$LIBSSH2_LIBDIR -lssh2-static $OPENSSL_LIBS\"\nelse\n    LIBSSH2_STATIC_LIBS=$LIBSSH2_LIBS\nfi\n\n# Datastax Cassandra driver\ncase \"$with_cassandra\" in\n   yes | no | '' ) ;;\n   *             ) CASSANDRA_PATH=$with_cassandra ;;\nesac\nif test -d \"$CASSANDRA_PATH\"; then\n   NCBI_FIX_DIR(CASSANDRA_PATH)\n   for d in \"$CASSANDRA_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$CASSANDRA_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$CASSANDRA_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx\" \\\n            \"$CASSANDRA_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx\"; do\n      if test -d \"$d\"; then\n         CASSANDRA_PATH=$d\n         NCBI_FIX_DIR(CASSANDRA_PATH)\n         break\n      fi\n   done\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(cassandra,\n   [AC_LANG_PROGRAM([[#include <cassandra.h>]],\n      [[CassCluster* c = cass_cluster_new();]])],\n   [$LIBSSH2_LIBS $LIBUV_LIBS])\nif test \"$with_cassandra\" != no -a \\\n     -f \"$CASSANDRA_PATH/lib/libcassandra_static.a\"; then\n    CASSANDRA_STATIC_LIBS=\"-L$CASSANDRA_PATH/lib -lcassandra_static $LIBSSH2_STATIC_LIBS $LIBUV_STATIC_LIBS\"\nelse\n    CASSANDRA_STATIC_LIBS=$CASSANDRA_LIBS\nfi\n\n# HTTP/2 libraries\ncase \"$with_nghttp2\" in\n   yes | no | '' ) ;;\n   *             ) NGHTTP2_PATH=$with_nghttp2 ;;\nesac\nif test -d \"$NGHTTP2_PATH\"; then\n   NCBI_FIX_DIR(NGHTTP2_PATH)\n   for d in \"$NGHTTP2_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$NGHTTP2_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$NGHTTP2_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx\" \\\n            \"$NGHTTP2_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx\"; do\n      if test -d \"$d/lib\"; then\n         NGHTTP2_LIBDIR=$d/lib\n         NCBI_FIX_DIR(NGHTTP2_LIBDIR)\n         break\n      fi\n   done\nfi\nNCBI_RPATHIFY(NGHTTP2_LIBPATH, $NGHTTP2_LIBDIR)\nNCBI_CHECK_THIRD_PARTY_LIB(nghttp2,\n   [AC_LANG_PROGRAM([[#include <nghttp2/nghttp2.h>]],\n       [[nghttp2_session_client_new(NULL, NULL, NULL);]])])\nif test \"$with_nghttp2\" != no -a \\\n     -f \"$NGHTTP2_LIBDIR/libnghttp2-static.a\"; then\n   NGHTTP2_STATIC_LIBS=\"-L$NGHTTP2_LIBDIR -lnghttp2-static\"\nelse\n   NGHTTP2_STATIC_LIBS=$NGHTTP2_LIBS\nfi\n\ncase \"$with_h2o\" in\n   yes | no | '' ) ;;\n   *             ) H2O_PATH=$with_h2o ;;\nesac\nif test -d \"$H2O_PATH\"; then\n   NCBI_FIX_DIR(H2O_PATH)\n   for d in \"$H2O_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$H2O_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$H2O_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx\" \\\n            \"$H2O_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx\"; do\n      if test -d \"$d\"; then\n         H2O_PATH=$d\n         NCBI_FIX_DIR(H2O_PATH)\n         break\n      fi\n   done\nfi\nNCBI_CHECK_THIRD_PARTY_LIB(h2o,\n   [AC_LANG_PROGRAM([[#include <h2o.h>>]],\n       [[h2o_init_request(NULL, NULL, NULL);]])],\n   [$LIBUV_LIBS $OPENSSL_LIBS $Z_LIBS], [], [$LIBUV_INCLUDE])\nif test \"$with_h2o\" != no -a \\\n     -f \"$H2O_PATH/lib/libh2o-static.a\"; then\n    H2O_STATIC_LIBS=\"-L$H2O_PATH/lib -lh2o-static $LIBUV_STATIC_LIBS $OPENSSL_LIBS $Z_LIBS\"\nelse\n    H2O_STATIC_LIBS=$H2O_LIBS\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(libxlsxwriter, LIBXLSXWRITER, xlsxwriter,\n   [AC_LANG_PROGRAM([[#include <xlsxwriter.h>]],\n      [[lxw_workbook* wb = workbook_new(\"conftest.xlsx\");]])],\n   [], [$Z_LIBS])\nif test \"$with_libxlsxwriter\" != no -a \\\n     -f \"$LIBXLSXWRITER_PATH/lib/libxlsxwriter-static.a\"; then\n    LIBXLSXWRITER_STATIC_LIBS=\"-L$LIBXLSXWRITER_PATH/lib -lxlsxwriter-static\"\nelse\n    LIBXLSXWRITER_STATIC_LIBS=$LIBXLSXWRITER_LIBS\nfi\n\ncase \"$with_grpc\" in\n   yes | no | '' ) ;;\n   *             ) GRPC_PATH=$with_grpc ;;\nesac\nif test -d \"$GRPC_PATH\"; then\n   NCBI_FIX_DIR(GRPC_PATH)\n   for d in \"$GRPC_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$GRPC_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$GRPC_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx\" \\\n            \"$GRPC_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx\"; do\n      if test -d \"$d\"; then\n         GRPC_PATH=$d\n         NCBI_FIX_DIR(GRPC_PATH)\n         break\n      fi\n   done\nfi\n\n: ${PROTOBUF_PATH=$GRPC_PATH}\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(protobuf, PROTOBUF, [protobuf$D_SFX],\n   [AC_LANG_PROGRAM([[#include <google/protobuf/type.pb.h>]],\n       [[google::protobuf::Type t;]])],\n   [], [$Z_LIBS])\nif test -n \"$PROTOBUF_LIBS\"; then\n   PROTOBUF_BIN=$PROTOBUF_PATH/bin\nelse\n   NCBI_MISSING_PACKAGE(grpc)\nfi\n\nif test -f \"$GRPC_PATH/lib/libboringssl.a\"; then\n   GRPC_SSL_LIBS=\"-lboringssl -lboringcrypto\"\nelse\n   GRPC_SSL_LIBS=$OPENSSL_LIBS\nfi\n\nNCBI_CHECK_THIRD_PARTY_LIB_EX(grpc, GRPC, grpc++,\n   [AC_LANG_PROGRAM([[#include <grpc++/grpc++.h>]],\n       [[return grpc::Version().size();]])],\n   [-lgrpc -lgpr $PROTOBUF_LIBS -lcares], [$GRPC_SSL_LIBS $Z_LIBS],\n   [$PROTOBUF_INCLUDE])\nif test -n \"$GRPC_LIBS\"; then\n   LDFLAGS=\"$orig_LDFLAGS $GRPC_LIBPATH\"\n   AC_CHECK_LIB(address_sorting, address_sorting_rfc_6724_sort,\n      [GRPC_LIBS=\"$GRPC_LIBS -laddress_sorting\"], [])\n   LDFLAGS=$orig_LDFLAGS\n   GRPC_UNSECURE_LIBS=`echo $GRPC_LIBS | sed -e 's/\\(-lgrpc+*\\)/\\1_unsecure/g'`\n   GRPC_LIBS=\"$GRPC_LIBS $GRPC_SSL_LIBS\"\n   GRPC_REFLECTION_LIBS=\"$WHOLE_ARCHIVE $NO_AS_NEEDED $GRPC_LIBPATH\"\n   GRPC_REFLECTION_LIBS=\"$GRPC_REFLECTION_LIBS -lgrpc++_reflection\"\n   GRPC_REFLECTION_LIBS=\"$GRPC_REFLECTION_LIBS $NO_WHOLE_ARCHIVE $AS_NEEDED\"\n   GRPC_BIN=$GRPC_PATH/bin\nfi\n\ncase \"$with_msgsl\" in\n   yes | '' ) ;;\n   no       ) ncbi_cv_lib_msgsl=no ;;\n   *        ) MSGSL_PATH=$with_msgsl ;;\nesac\nif test -d \"$MSGSL_PATH\"; then\n   MSGSL_INCLUDE=-I$MSGSL_PATH/include\n   in_path=\" in $MSGSL_PATH\"\nelse\n   in_path=\nfi\nCPPFLAGS=\"$orig_CPPFLAGS $MSGSL_INCLUDE\"\nAC_CHECK_HEADERS([gsl/gsl], [NCBI_PACKAGE(MSGSL)],\n   [MSGSL_INCLUDE=; NCBI_MISSING_PACKAGE(msgsl)])\n\ncase \"$with_aws_sdk\" in\n   yes | no | '' ) ;;\n   *             ) AWS_SDK_PATH=$with_aws_sdk ;;\nesac\nif test -d \"$AWS_SDK_PATH\"; then\n   NCBI_FIX_DIR(AWS_SDK_PATH)\n   for d in \"$AWS_SDK_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$AWS_SDK_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx$bit64_sfx\" \\\n            \"$AWS_SDK_PATH/$compiler_vpfx$DEBUG_SFX$mt_sfx\" \\\n            \"$AWS_SDK_PATH/$compiler_pfx$DEBUG_SFX$mt_sfx\"; do\n      if test -d \"$d\"; then\n         AWS_SDK_PATH=$d\n         NCBI_FIX_DIR(AWS_SDK_PATH)\n         break\n      fi\n   done\nfi\nNCBI_CHECK_THIRD_PARTY_LIB_EX(aws_sdk, AWS_SDK, aws-cpp-sdk-s3,\n   [AC_LANG_PROGRAM([[#include <aws/s3/S3Client.h>\n                      #include <aws/ec2/EC2Client.h>]],\n       [[Aws::S3::S3Client s3cli;\n         Aws::EC2::EC2Client ec2cli;]])],\n   [-laws-cpp-sdk-ec2 -laws-cpp-sdk-core], [$CURL_LIBS $OPENSSL_LIBS $Z_LIBS])\nif test \"$with_aws_sdk\" != no -a \\\n     -f \"$AWS_SDK_PATH/lib$bit64_sfx/libaws-cpp-sdk-s3-static.a\"; then\n    AWS_SDK_STATIC_LIBS=\"-L$AWS_SDK_PATH/lib -laws-cpp-sdk-s3-static -laws-cpp-sdk-ec2-static -laws-cpp-sdk-core-static\"\nelse\n    AWS_SDK_STATIC_LIBS=$AWS_SDK_LIBS\nfi\n\n### Restore original compiler/linker flags\nLIBS=\"$orig_LIBS\"\nCPPFLAGS=\"$orig_CPPFLAGS\"\n\n\n### Optional projects\n### --------------------------------------------\n\n\n## `local_lbsm' support\n\nlocal_lbsm=\"ncbi_lbsm ncbi_lbsm_ipc ncbi_lbsmd\"\n\n## requires semaphores (lacking on older versions of Cygwin and Darwin)\nif test $ncbi_cv_sys_semaphores = no; then\n    NCBI_MISSING_PACKAGE(local-lbsm)\nfi\n## disable by default even on newer Cygwin, as its semaphores don't\n## actually work very well\ntest $OSTYPE = cygwin  &&  : ${with_local_lbsm=no}\n\nfor fff in $local_lbsm ; do\n   if test ! -f ${real_srcdir}/src/connect/${fff}.c ; then\n      if test \"$with_local_lbsm\" = \"yes\" ; then\n         AC_MSG_ERROR([--with-local-lbsm:  src/connect/${fff}.c is  missing])\n      fi\n      with_local_lbsm=\"no\"\n      break\n   fi\ndone\n\nif test \"$with_local_lbsm\" = \"no\" ; then\n   local_lbsm=\"ncbi_lbsmd_stub\"\nelse\n   NCBI_PROJECT(local_lbsm)\n   AC_DEFINE(HAVE_LOCAL_LBSM, 1,\n             [Define to 1 if local LBSM support is available.])\nfi\n\n\n## `connext' support\n\nconnext=\"ncbi_dblb ncbi_ifconf ncbi_localnet\"\n\nfor fff in $connext ; do\n   if test ! -f ${real_srcdir}/src/connect/ext/${fff}.c ; then\n      if test \"$with_connext\" = \"yes\" ; then\n         AC_MSG_ERROR([--with-connext:  src/connect/ext/${fff}.c is missing])\n      fi\n      with_connext=\"no\"\n      break\n   fi\ndone\n\nif test \"$with_connext\" = \"no\"; then\n   if test \"$with_ncbi_crypt\" = \"yes\" ; then\n      AC_MSG_ERROR([--with-ncbi-crypt specified, but CONNECT extensions are unavailable])\n   fi\n   with_ncbi_crypt=no\nfi\n\nif test \"$with_connext\" = \"no\" ; then\n   CONNEXT=\n   XCONNEXT=\nelse\n   NCBI_PROJECT(connext)\n   CONNEXT=connext\n   XCONNEXT=xconnext\n   AC_DEFINE(HAVE_LIBCONNEXT, 1,\n      [Define to 1 if non-public CONNECT extensions are available.])\nfi\n\n\n## `ncbi_crypt' support\n\nncbi_crypt=\"ncbi_crypt\"\n\nfor fff in $ncbi_crypt ; do\n   if test ! -f ${real_srcdir}/src/connect/ext/${fff}.c ; then\n      if test \"$with_ncbi_crypt\" = \"yes\" ; then\n         AC_MSG_ERROR([--with-ncbi-crypt:  src/connect/ext/${fff}.c is missing])\n      fi\n      with_ncbi_crypt=\"no\"\n      break\n   fi\ndone\n\nif test \"$with_ncbi_crypt\" = \"no\" ; then\n   ncbi_crypt=\"ncbi_crypt_stub\"\nelse\n   NCBI_PROJECT(ncbi_crypt)\n   AC_DEFINE(HAVE_NCBI_CRYPT, 1,\n      [Define to 1 if the real version of ncbi_crypt support is available.])\nfi\n\n\n## direct PubSeqOS data loaders\n\nif test \"$with_dbapi\" != no -a \\\n   -f ${real_srcdir}/src/objtools/data_loaders/genbank/pubseq/Makefile.ncbi_xreader_pubseqos.lib ; then\n   AC_DEFINE(HAVE_PUBSEQ_OS, 1,\n      [Define to 1 if the PUBSEQ service is available.])\n   NCBI_FEATURE(PubSeqOS)\n   ncbi_xreader_pubseqos=ncbi_xreader_pubseqos\n   ncbi_xreader_pubseqos2=ncbi_xreader_pubseqos2\n   UNLESS_PUBSEQOS=\\#\nelse\n   ncbi_xreader_pubseqos=\n   ncbi_xreader_pubseqos2=\n   UNLESS_PUBSEQOS=\nfi\n\n\n## `serial' projects\n\nif test \"$with_serial\" = \"no\" ; then\n   serial=\nelse\n   NCBI_PROJECT(serial)\n   serial=\"serial\"\nfi\n\n\n## `objects' projects\n\nif test \"$with_objects\" = \"no\"  -o  -z \"$serial\" ; then\n   objects=\nelse\n   NCBI_PROJECT(objects)\n   objects=\"objects\"\nfi\n\n\n## `bdb' projects\n\ndnl NCBI_CHECK_SUBTREE(bdb)\nif test \"$with_bdb\" = \"no\" ; then\n   NoConfProjects=\"$NoConfProjects bdb\"\nfi\n\nif test ! -f ${real_srcdir}/src/db/bdb/Makefile.in  -o  \\\n        ! -d ${real_srcdir}/include/db/bdb ; then\n   if test \"${with_bdb-no}\" != \"no\" ; then\n      AC_MSG_ERROR([--with-]bdb[:  ]BDB[ sources are missing])\n   fi\n   with_bdb=\"no\"\nfi\n\n\nif test \"$with_bdb\" = \"no\" ; then\n   bdb=\n   BDB_LIB=\n   BDB_CACHE_LIB=\nelse\n   NCBI_PROJECT(bdb)\n   bdb=\"bdb\"\n   BDB_LIB=\"bdb\"\n   AC_DEFINE(HAVE_BDB, 1,\n             [Define to 1 if NCBI C++ API for BerkeleyDB is available.])\n   bdb_cache=\"ncbi_xcache_bdb\"\n   BDB_CACHE_LIB=\"ncbi_xcache_bdb\"\n   AC_DEFINE(HAVE_BDB_CACHE, 1,\n             [Define to 1 if NCBI C++ API for BerkeleyDB based data cache is available.])\nfi\n\n\n## `dbapi' projects\n\nDBAPI_DRIVER=\nDBAPI_CTLIB=\nDBAPI_FTDS=\nDBAPI_FTDS64=\nDBAPI_FTDS95=\nDBAPI_FTDS100=\nDBAPI_MYSQL=\nDBAPI_ODBC=\nif test \"$with_dbapi\" = \"no\" ; then\n   dbapi=\nelse\n   NCBI_PROJECT(dbapi)\n   dbapi=\"dbapi\"\n   DBAPI_DRIVER=dbapi_driver\n   DBAPI_FTDS=ncbi_xdbapi_ftds\n   DBAPI_FTDS64=ncbi_xdbapi_ftds64\n   DBAPI_FTDS95=ncbi_xdbapi_ftds95\n   DBAPI_FTDS100=ncbi_xdbapi_ftds100\n   test -n \"$SYBASE_LIBS\"    &&  DBAPI_CTLIB=ncbi_xdbapi_ctlib\n   test -n \"$MYSQL_LIBS\"     &&  DBAPI_MYSQL=ncbi_xdbapi_mysql\n   test -n \"$ODBC_LIBS\"      &&  DBAPI_ODBC=ncbi_xdbapi_odbc\nfi\n\n\n## `app' projects\n\nif test \"$with_app\" = \"no\" ; then\n   app=\nelse\n   NCBI_PROJECT(app)\n   app=\"app\"\nfi\n\n\n## `ctools' project cluster\n\nif test \"$with_ctools\" != \"no\" ; then\n   NCBI_PROJECT(ctools)\nfi\n\n\n## `gui' projects\n\nif test \"$with_gui\" = \"no\" ; then\n   gui=\nelse\n   NCBI_PROJECT(gui)\n   gui=\"gui\"\nfi\n\n\n## `algo' projects\n\nif test \"$with_algo\" = \"no\" -o -z \"$objects\" ; then\n   algo=\nelse\n   NCBI_PROJECT(algo)\n   algo=\"algo\"\nfi\n\n\n## `internal' project cluster\n\nif test \"$with_internal\" = \"no\"  \\\n    -o  ! -f \"${real_srcdir}/src/internal/Makefile.in\"; then\n   NoConfProjects=\"$NoConfProjects internal\"\n   internal=\nelse\n   reason=\"\"\n   sep=\n   if test ! -d \"${real_srcdir}/include/internal\"; then\n     reason=\"$reason${sep}headers\"\n     sep=\", \"\n   fi\n   if test \"$with_sybase\" = \"no\"; then\n     reason=\"$reason${sep}Sybase\"\n     sep=\", \"\n   fi\n   if test \"$with_ncbi_c\" = \"no\"; then\n     reason=\"$reason${sep}C-Toolkit\"\n     sep=\", \"\n   fi\n   if test \"$with_sss\" = \"no\"; then\n     reason=\"$reason${sep}SSS\"\n     sep=\", \"\n   fi\n   if test -n \"$reason\" -a \"$with_internal\" = \"yes\"; then\n      if test -z \"$with_projects\"; then\n         AC_MSG_ERROR([--with-internal:  Cannot build INTERNAL projects: missing $reason])\n      else\n         AC_MSG_WARN([--with-internal:  Cannot build some INTERNAL projects: missing $reason])\n         OPT_GROUPS=\"$OPT_GROUPS internal\"\n         internal=\"internal\"\n      fi\n   elif test -n \"$reason\" -a -z \"$with_projects\"; then\n      NoConfProjects=\"$NoConfProjects internal\"\n      internal=\n   else\n      OPT_GROUPS=\"$OPT_GROUPS internal\"\n      internal=\"internal\"\n   fi\nfi\n\n## Genome Workbench\n\nif test \"$with_gbench\" != \"no\"  -a  -d \"$real_srcdir/src/app/gbench\"; then\n   reason=\"\"\n   sep=\n   if test \"$with_wxwidgets\" = \"no\"; then\n     reason=\"$reason${sep}wxWidgets\"\n     sep=\", \"\n   fi\n   if test ! -d \"$real_srcdir/src/gui/packages\"; then\n     reason=\"$reason${sep}internal packages\"\n     sep=\", \"\n   fi\n   if test \"$with_opengl\" = \"no\"; then\n     reason=\"$reason${sep}OpenGL\"\n     sep=\", \"\n   fi\n   if test \"$with_glew\" = \"no\"; then\n     reason=\"$reason${sep}GLEW\"\n     sep=\", \"\n   fi\n   if test \"$with_ftgl\" = \"no\"; then\n     reason=\"$reason${sep}FTGL\"\n     sep=\", \"\n   fi\n   if test \"$with_sqlite3\" = \"no\"; then\n     reason=\"$reason${sep}SQLite 3.x\"\n     sep=\", \"\n   fi\n   if test \"$with_bdb\" = \"no\"; then\n     reason=\"$reason${sep}Berkeley DB\"\n     sep=\", \"\n   fi\n   if test \"$ncbi_cv_lib_boost_spirit\" != \"yes\"; then\n     reason=Boost.Spirit\n     sep=\", \"\n   fi\n   if test \"$with_libxslt\" = \"no\"; then\n     reason=\"$reason${sep}libxslt\"\n     sep=\", \"\n   fi\n   if test \"$with_mt\" = \"no\"; then\n     reason=\"$reason${sep}multithreading\"\n     sep=\", \"\n   fi\n   if test \"$with_dll\" != \"yes\"; then\n     reason=\"$reason${sep}full-DLL setup\"\n     sep=\", \"\n   fi\n   if test \"$with_algo\" = \"no\"; then\n     reason=\"$reason${sep}other required subtrees\"\n     sep=\",\"\n   fi\n   # Anything else?\n   if test -n \"$reason\" -a \"$with_gbench\" = \"yes\"; then\n      AC_MSG_ERROR([--with-gbench:  Cannot build Genome Workbench: missing $reason])\n   elif test -z \"$reason\"; then\n      NCBI_PROJECT(gbench)\n   fi\nfi\n\n\n\n### Miscellanea\n### --------------------------------------------\n\nif test \"$with_execopy\" = \"no\" ; then\n   APP_NOCOPY=\"BINCOPY=@:\"\nelse\n   APP_NOCOPY=\nfi\n\nif test \"$with_exe\" = \"no\" ; then\n   APP_OR_NULL=null\nelse\n   APP_OR_NULL=app\nfi\n\nIF_REBUILDING_LIBS=\"#\"\nIF_REBUILDING_CONDITIONALLY=\"#\"\ncase \"$with_lib_rebuilds\" in\n  yes) IF_REBUILDING_LIBS=\"\" ;;\n  ask) IF_REBUILDING_CONDITIONALLY=\"\" ;;\nesac\n\ncase \"$with_deactivation\" in\n  no) IF_DEACTIVATING=\"#\" ;;\n  * ) IF_DEACTIVATING=\"\"  ;;\nesac\n\ncase \"$with_makefile_auto_update\" in\n  no) configurables_mfname=configurables.null ;;\n  * ) configurables_mfname=configurables      ;;\nesac\n\n# Run the test suite after the build?\n\nif test -n \"$with_check\"  -a  \"$with_check\" != \"no\" ; then\n   check=\"check\"\n   if test \"$with_check\" != \"yes\" ; then\n      CHECK_ARG=`echo \"$with_check\" | sed 's/%/ /g'`\n   fi\n   NCBI_FEATURE(check)\nfi\nCHECK_TOOLS=$with_check_tools\ncase \"$CHECK_TOOLS\" in\n   [*[Vv][Aa][Ll][Gg][Rr][Ii][Nn][Dd]*] ) NCBI_FEATURE(Valgrind) ;;\n   [*[Hh][Ee][Ll][Gg][Rr][Ii][Nn][Dd]*] ) NCBI_FEATURE(Valgrind) ;;\nesac\nCHECK_OS_NAME=\n: ${CHECK_TIMEOUT_MULT=1}\ncase \"$host_os\" in\n   linux* )\n      if test -x /usr/bin/lsb_release; then\n         CHECK_OS_NAME=`lsb_release -is | tr A-Z a-z`\n      elif test -r /etc/SuSE-release; then\n         CHECK_OS_NAME=suse\n      elif test -r /etc/redhat-release; then\n         CHECK_OS_NAME=`cut -d' ' -f1 /etc/redhat-release | tr A-Z a-z`\n      elif test -d /usr/share/doc/ubuntu-keyring; then\n         CHECK_OS_NAME=ubuntu\n      fi\n      ;;\nesac\n\nif test \"${with_limited_linker}\" = \"yes\"; then\n   NCBI_FEATURE(LimitedLinker)\nfi\n\nif test \"${with_skew_guard-$with_ncbi_public}\" = \"yes\"; then\n    AC_DEFINE(HAVE_NCBI_SKEW_GUARD, 1,\n       [Define to 1 to catch incomplete rebuilds.])\nfi\n\nFEATURES=\"$WithFeatures $WithPackages $WithProjects\"\n\n### Compute Without{Features,Packages,Projects}.  Takes quadratic time,\n### but that's life.\nm4_foreach(CATEGORY, [Features,Packages,Projects],\n  [for x in m4_indir([NCBI_ALL_]CATEGORY); do\n      case \" [$With]CATEGORY \" in\n         *\" $x \"*) ;;\n         *) [Without]CATEGORY=\"[$Without]CATEGORY[$Without]CATEGORY[Sep$x]\"\n            [Without]CATEGORY[Sep]=\" \"\n            FEATURES=\"$FEATURES -$x\"\n          ;;\n      esac\n   done\n  ])\n\n\n### Get rid of the KCC \"anti-license-warning\" filter\nif test \"$KCC\" = \"yes\"  -a  -n \"$kcc_license\" ; then\n   CC=\"$kcc_CC\"\n   CXXCPP=\"$kcc_CXX -E\"\n   CXX=\"$kcc_CXX\"\nfi\n\n### Get rid of the ICC \"anti-license-warning\" filter\nif test \"$ICC\" = \"yes\"  -a  -n \"$icc_license\" ; then\n   CC=\"$icc_CC\"\n   CXXCPP=\"$icc_CXX -E\"\n   CXX=\"$icc_CXX\"\nfi\n\n### Adjust paths to wrapper.*.sh\ncase \"$CC\"     in compilers/*)     CC=\"\\$(top_srcdir)/$CC\"     ;; esac\ncase \"$CXX\"    in compilers/*)    CXX=\"\\$(top_srcdir)/$CXX\"    ;; esac\ncase \"$CXXCPP\" in compilers/*) CXXCPP=\"\\$(top_srcdir)/$CXXCPP\" ;; esac\ncase \"$AR\"     in compilers/*)     AR=\"\\$(top_srcdir)/$AR\"     ;; esac\n\n### Get Insure++ to honor the Toolkit's psrc file\ncase \"$CC\" in\n   */insure*)\n      CC=\"$CC -Zop \\$(top_srcdir)/compilers/unix/psrc -D__INSURE__\"\n      CXX=\"$CXX -Zop \\$(top_srcdir)/compilers/unix/psrc -D__INSURE__\"\n      CXXCPP=\"$CXXCPP -Zop \\$(top_srcdir)/compilers/unix/psrc -D__INSURE__\"\n      LINK_DLL=`echo \"$LINK_DLL\" | sed -e 's:insure:& -Zop \\$(top_srcdir)/compilers/unix/psrc:'`\n   ;;\nesac\n\n\n#############################################################################\n### Compose a list of configurables(\"*.in\" -- makefiles, shell scripts, etc.)\n### in subdirs to configure\n### Compose their target counterparts\n### Configure\n\nAC_MSG_NOTICE([looking for configurables below $real_srcdir...])\ntmp_sed=\"`pwd`/config.tmp.$$\"\nfor x in $NoConfProjects dll; do\n   echo \"/^\\\\.\\\\/$x/d\"\ndone > $tmp_sed\ncat >>$tmp_sed <<EOF\ns%^.\\\\(/build-system.*/Makefile*\\\\)\\\\.in\\$%$builddir\\\\1:./src\\\\1\\\\.in%\ns%^.\\\\(/build-system\\\\)\\\\(/.*\\\\)\\\\.in\\$%$builddir\\\\2:./src\\\\1\\\\2\\\\.in%\ns%^.\\\\(/[[^:]]*\\\\)\\\\.in\\$%$builddir\\\\1:./src\\\\1\\\\.in%\nEOF\ncat $tmp_sed >&AS_MESSAGE_LOG_FD\nconfigurables=`cd \"${real_srcdir}/src\"  &&  find . -name '.svn' -prune -o -name '*.in' -print | sed -f $tmp_sed`\nrm $tmp_sed\n\nif test -z \"$configurables\" ; then\n  AC_MSG_ERROR([cannot find any configurables below \"${real_srcdir}\"!])\nelse\n  AC_MSG_NOTICE([...done])\nfi\n\nncbi_runpath=`eval echo \"$pure_runpath\"`\ndnl AC_DEFINE_UNQUOTED(NCBI_RUNPATH, \"$ncbi_runpath\", [NCBI runpath])\nc_ncbi_runpath=`echo \"$ncbi_runpath\" | sed -e 's:\\\\$\\\\$:\\\\$:g'`\n\n### Template substitutions\nAC_SUBST(signature)\n\nAC_SUBST(build_root)\n\nAC_SUBST(top_srcdir)\nAC_SUBST(srcdir)\n#AC_SUBST(real_srcdir)\nAC_SUBST(includedir)\nAC_SUBST(status_dir)\nAC_SUBST(builddir)\nAC_SUBST(runpath)\nAC_SUBST(ncbi_runpath)\nAC_SUBST(c_ncbi_runpath)\n\nAC_SUBST(CC)\nAC_SUBST(CPP)\nAC_SUBST(CXX)\nAC_SUBST(AR)\nAC_SUBST(RANLIB)\nAC_SUBST(STRIP)\nAC_SUBST(LINK)\nAC_SUBST(C_LINK)\nAC_SUBST(TAIL_N)\nAC_SUBST(EGREP_Q)\nAC_SUBST(LDD_R)\n\nAC_SUBST(CFLAGS)\nAC_SUBST(FAST_CFLAGS)\nAC_SUBST(CXXFLAGS)\nAC_SUBST(FAST_CXXFLAGS)\nAC_SUBST(OBJCXX_CXXFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(DEPFLAGS)\nAC_SUBST(DEPFLAGS_POST)\nAC_SUBST(LDFLAGS)\nAC_SUBST(FAST_LDFLAGS)\nAC_SUBST(APP_LDFLAGS)\nAC_SUBST(DLL_LDFLAGS)\nAC_SUBST(LIBS)\nAC_SUBST(C_LIBS)\nAC_SUBST(OBJCXX_LIBS)\nAC_SUBST(GCCPCH)\nAC_SUBST(RUNPATH_ORIGIN)\nAC_SUBST(NO_STRICT_ALIASING)\n\nAC_SUBST(D_SFX)\nAC_SUBST(DEBUG_SFX)\n\nAC_SUBST(LIB_OR_DLL)\nAC_SUBST(FORCE_STATIC_LIB)\nAC_SUBST(APP_LIB_SETTING)\nAC_SUBST(APP_LIBS_SETTING)\nAC_SUBST(LINK_DLL)\nAC_SUBST(has_dll_loadable)\nAC_SUBST(LINK_LOADABLE)\nAC_SUBST(CFLAGS_DLL)\nAC_SUBST(CXXFLAGS_DLL)\nAC_SUBST(ALLOW_UNDEF)\nAC_SUBST(FORBID_UNDEF)\nAC_SUBST(AS_NEEDED)\nAC_SUBST(NO_AS_NEEDED)\nAC_SUBST(WHOLE_ARCHIVE)\nAC_SUBST(NO_WHOLE_ARCHIVE)\n\nAC_SUBST(OPT_GROUPS)\nAC_SUBST(local_lbsm)\nAC_SUBST(ncbi_crypt)\nAC_SUBST(CONNEXT)\nAC_SUBST(XCONNEXT)\nAC_SUBST(serial)\nAC_SUBST(bdb)\nAC_SUBST(dbapi)\nAC_SUBST(objects)\nAC_SUBST(gui)\nAC_SUBST(algo)\nAC_SUBST(app)\nAC_SUBST(internal)\n\nAC_SUBST(check)\nAC_SUBST(CHECK_ARG)\nAC_SUBST(CHECK_TOOLS)\nAC_SUBST(CHECK_TIMEOUT_MULT)\nAC_SUBST(CHECK_OS_NAME)\nAC_SUBST(FEATURES)\n\nAC_SUBST(script_shell)\nAC_SUBST(make_shell)\nAC_SUBST(obj_ext)\nAC_SUBST(lib_pre)\nAC_SUBST(lib_l_pre)\nAC_SUBST(lib_ext)\nAC_SUBST(dll_ext)\nAC_SUBST(loadable_ext)\nAC_SUBST(lib_l_ext)\nAC_SUBST(exe_ext)\nAC_SUBST(f_compile)\nAC_SUBST(f_outobj)\nAC_SUBST(f_outlib)\nAC_SUBST(f_libpath)\nAC_SUBST(f_runpath)\nAC_SUBST(f_outexe)\n\nAC_SUBST(BDB_LIB)\nAC_SUBST(BDB_CACHE_LIB)\nAC_SUBST(SQLITE3_WRAPPER)\nAC_SUBST(DBAPI_DRIVER)\nAC_SUBST(DBAPI_CTLIB)\nAC_SUBST(DBAPI_FTDS)\nAC_SUBST(DBAPI_FTDS64)\nAC_SUBST(DBAPI_FTDS95)\nAC_SUBST(DBAPI_FTDS100)\nAC_SUBST(DBAPI_MYSQL)\nAC_SUBST(DBAPI_ODBC)\n\nAC_SUBST(THREAD_LIBS)\nAC_SUBST(NCBIATOMIC_LIB)\nAC_SUBST(OPENMP_FLAGS)\nAC_SUBST(UNSAFE_MATH_FLAG)\nAC_SUBST(SSE4_1_FLAG)\nAC_SUBST(AES_FLAG)\nAC_SUBST(COLOR_DIAGNOSTICS)\nAC_SUBST(NETWORK_LIBS)\nAC_SUBST(NETWORK_PURE_LIBS)\nAC_SUBST(RESOLVER_LIBS)\nAC_SUBST(MATH_LIBS)\nAC_SUBST(KSTAT_LIBS)\nAC_SUBST(RPCSVC_LIBS)\nAC_SUBST(CRYPT_LIBS)\nAC_SUBST(DL_LIBS)\nAC_SUBST(RT_LIBS)\nAC_SUBST(UUID_LIBS)\nAC_SUBST(DEMANGLE_LIBS)\nAC_SUBST(ICONV_LIBS)\nAC_SUBST(Z_LIB)\nAC_SUBST(BZ2_LIB)\nAC_SUBST(PCREPOSIX_LIBS)\nAC_SUBST(PCRE_LIB)\nAC_SUBST(OPENSSL_STATIC_LIBS)\nAC_SUBST(SYBASE_PATH)\nAC_SUBST(SYBASE_LCL_PATH)\nAC_SUBST(SYBASE_INCLUDE)\nAC_SUBST(SYBASE_LIBS)\nAC_SUBST(SYBASE_DLLS)\nAC_SUBST(SYBASE_DBLIBS)\nAC_SUBST(MYSQL_INCLUDE)\nAC_SUBST(MYSQL_LIBS)\nAC_SUBST(BERKELEYDB_INCLUDE)\nAC_SUBST(BERKELEYDB_LIBS)\nAC_SUBST(BERKELEYDB_STATIC_LIBS)\nAC_SUBST(BERKELEYDB_CXX_LIBS)\nAC_SUBST(BERKELEYDB_CXX_STATIC_LIBS)\nAC_SUBST(ODBC_INCLUDE)\nAC_SUBST(ODBC_LIBS)\nAC_SUBST(BOOST_INCLUDE)\nAC_SUBST(BOOST_LIBPATH)\nAC_SUBST(BOOST_TAG)\nAC_SUBST(BOOST_CHRONO_LIBS)\nAC_SUBST(BOOST_CHRONO_STATIC_LIBS)\nAC_SUBST(BOOST_FILESYSTEM_LIBS)\nAC_SUBST(BOOST_FILESYSTEM_STATIC_LIBS)\nAC_SUBST(BOOST_IOSTREAMS_LIBS)\nAC_SUBST(BOOST_IOSTREAMS_STATIC_LIBS)\nAC_SUBST(BOOST_PROGRAM_OPTIONS_LIBS)\nAC_SUBST(BOOST_PROGRAM_OPTIONS_STATIC_LIBS)\nAC_SUBST(BOOST_REGEX_LIBS)\nAC_SUBST(BOOST_REGEX_STATIC_LIBS)\nAC_SUBST(BOOST_SYSTEM_LIBS)\nAC_SUBST(BOOST_SYSTEM_STATIC_LIBS)\nAC_SUBST(BOOST_TEST_PEM_LIBS)\nAC_SUBST(BOOST_TEST_PEM_STATIC_LIBS)\nAC_SUBST(BOOST_TEST_TEM_LIBS)\nAC_SUBST(BOOST_TEST_TEM_STATIC_LIBS)\nAC_SUBST(BOOST_TEST_UTF_LIBS)\nAC_SUBST(BOOST_TEST_UTF_STATIC_LIBS)\nAC_SUBST(BOOST_THREAD_LIBS)\nAC_SUBST(BOOST_THREAD_STATIC_LIBS)\nAC_SUBST(NCBI_C_INCLUDE)\nAC_SUBST(NCBI_C_LIBPATH)\nAC_SUBST(OPENGL_INCLUDE)\nAC_SUBST(OPENGL_LIBS)\nAC_SUBST(OPENGL_STATIC_LIBS)\nAC_SUBST(OSMESA_INCLUDE)\nAC_SUBST(OSMESA_LIBS)\nAC_SUBST(OSMESA_STATIC_LIBS)\nAC_SUBST(GLUT_INCLUDE)\nAC_SUBST(GLUT_LIBS)\nAC_SUBST(GLEW_INCLUDE)\nAC_SUBST(GLEW_LIBS)\nAC_SUBST(GLEW_STATIC_LIBS)\nAC_SUBST(GL2PS_INCLUDE)\nAC_SUBST(GL2PS_LIBS)\nAC_SUBST(GL2PS_STATIC_LIBS)\nAC_SUBST(WXWIDGETS_INCLUDE)\nAC_SUBST(WXWIDGETS_LIBS)\nAC_SUBST(WXWIDGETS_STATIC_LIBS)\nAC_SUBST(WXWIDGETS_GL_LIBS)\nAC_SUBST(WXWIDGETS_GL_STATIC_LIBS)\nAC_SUBST(WXWIDGETS_POST_LINK)\nAC_SUBST(FASTCGI_INCLUDE)\nAC_SUBST(FASTCGI_LIBS)\nAC_SUBST(FASTCGI_OBJS)\nAC_SUBST(NCBI_SSS_INCLUDE)\nAC_SUBST(NCBI_SSS_LIBPATH)\nAC_SUBST(LIBSSSUTILS)\nAC_SUBST(LIBSSSDB)\nAC_SUBST(sssutils)\nAC_SUBST(VDB_INCLUDE)\nAC_SUBST(VDB_LIBS)\nAC_SUBST(VDB_STATIC_LIBS)\nAC_SUBST(bamread)\nAC_SUBST(sraread)\nAC_SUBST(ncbi_id2proc_snp)\nAC_SUBST(ncbi_id2proc_wgs)\nAC_SUBST(ncbi_xloader_bam)\nAC_SUBST(ncbi_xloader_csra)\nAC_SUBST(ncbi_xloader_snp)\nAC_SUBST(ncbi_xloader_sra)\nAC_SUBST(ncbi_xloader_vdbgraph)\nAC_SUBST(ncbi_xloader_wgs)\nAC_SUBST(VDB_REQ)\nAC_SUBST(VDB_POST_LINK)\nAC_SUBST(SP_INCLUDE)\nAC_SUBST(SP_LIBS)\nAC_SUBST(ORBACUS_INCLUDE)\nAC_SUBST(ORBACUS_LIBPATH)\nAC_SUBST(LIBOB)\nAC_SUBST(LIBIMR)\nAC_SUBST(ICU_CONFIG)\nAC_SUBST(ICU_INCLUDE)\nAC_SUBST(ICU_LIBS)\nAC_SUBST(ICU_STATIC_LIBS)\nAC_SUBST(EXPAT_STATIC_LIBS)\nAC_SUBST(SABLOT_STATIC_LIBS)\nAC_SUBST(LIBXML_STATIC_LIBS)\nAC_SUBST(LIBXSLT_STATIC_LIBS)\nAC_SUBST(LIBEXSLT_STATIC_LIBS)\nAC_SUBST(XERCES_INCLUDE)\nAC_SUBST(XERCES_LIBS)\nAC_SUBST(XERCES_STATIC_LIBS)\nAC_SUBST(XALAN_INCLUDE)\nAC_SUBST(XALAN_LIBS)\nAC_SUBST(XALAN_STATIC_LIBS)\nAC_SUBST(ZORBA_INCLUDE)\nAC_SUBST(ZORBA_LIBS)\nAC_SUBST(ZORBA_STATIC_LIBS)\nAC_SUBST(SQLITE3_STATIC_LIBS)\nAC_SUBST(FREETYPE_INCLUDE)\nAC_SUBST(FREETYPE_LIBS)\nAC_SUBST(GSOAP_PATH)\nAC_SUBST(AVRO_STATIC_LIBS)\nAC_SUBST(CEREAL_INCLUDE)\nAC_SUBST(MONGODB_STATIC_LIBS)\nAC_SUBST(MONGODB3_STATIC_LIBS)\nAC_SUBST(LMDB_LIB)\nAC_SUBST(LMDB_STATIC_LIBS)\nAC_SUBST(LIBUV_STATIC_LIBS)\nAC_SUBST(LIBSSH2_STATIC_LIBS)\nAC_SUBST(CASSANDRA_STATIC_LIBS)\nAC_SUBST(NGHTTP2_STATIC_LIBS)\nAC_SUBST(H2O_STATIC_LIBS)\nAC_SUBST(LIBXLSXWRITER_STATIC_LIBS)\nAC_SUBST(PROTOBUF_BIN)\nAC_SUBST(GRPC_UNSECURE_LIBS)\nAC_SUBST(GRPC_REFLECTION_LIBS)\nAC_SUBST(GRPC_BIN)\nAC_SUBST(MSGSL_INCLUDE)\nAC_SUBST(AWS_SDK_STATIC_LIBS)\nAC_SUBST(ncbi_xreader_pubseqos)\nAC_SUBST(ncbi_xreader_pubseqos2)\nAC_SUBST(UNLESS_PUBSEQOS)\nAC_SUBST(PERL)\nAC_SUBST(PERL_INCLUDE)\nAC_SUBST(PERL_LIBS)\nAC_SUBST(JDK_PATH)\nAC_SUBST(JDK_INCLUDE)\nAC_SUBST(ncbi_java)\n\nAC_SUBST(NCBI_C_ncbi)\n\nAC_SUBST(BINCOPY)\nAC_SUBST(APP_NOCOPY)\nAC_SUBST(APP_OR_NULL)\nAC_SUBST(IF_REBUILDING_LIBS)\nAC_SUBST(IF_REBUILDING_CONDITIONALLY)\nAC_SUBST(IF_DEACTIVATING)\nAC_SUBST(configurables_mfname)\nAC_SUBST(CC_FILTER)\nAC_SUBST(CXX_FILTER)\nAC_SUBST(AR_FILTER)\nAC_SUBST(LINK_FILTER)\nAC_SUBST(CC_WRAPPER)\nAC_SUBST(CXX_WRAPPER)\nAC_SUBST(AR_WRAPPER)\nAC_SUBST(LINK_WRAPPER)\n\nAC_SUBST(KeepStateTarget)\nAC_SUBST(Rules)\nAC_SUBST(serial_ws50_rtti_kludge)\nAC_SUBST(ncbicntr)\n\nAC_SUBST(UNIX_SRC)\nAC_SUBST(UNIX_USR_PROJ)\n\nAC_SUBST(compiler)\nAC_SUBST(compiler_root)\nAC_SUBST(compiler_version)\n\nAC_SUBST(COMPILER)\nAC_SUBST(OSTYPE)\nAC_SUBST(NCBI_PLATFORM_BITS)\n\nAC_SUBST(NCBI_TEAMCITY_BUILD_NUMBER)\nAC_SUBST(NCBI_TEAMCITY_PROJECT_NAME)\nAC_SUBST(NCBI_TEAMCITY_BUILDCONF_NAME)\nAC_SUBST(NCBI_TEAMCITY_BUILD_ID)\nAC_SUBST(NCBI_SUBVERSION_REVISION)\nAC_SUBST(NCBI_SC_VERSION)\n\n#############################################################################\n### Create output files and do some post-configuration\n\n## Compose a list of target files\nchangequote(<<, >>)dnl\nx_configurables=`echo \"$configurables\" | sed 's/:[^:][^:]*\\.in//g'`\nchangequote([, ])dnl\n\n## Deploy the target directory tree\necho \"$x_configurables\" | while read x_file ; do\n   x_dir=`dirname $x_file`\n   test -d \"$x_dir\"  ||  mkdir -p \"$x_dir\"\ndone\n\n## Create ncbicfg.c.last if necessary\nncbicfg=\"$builddir/corelib/ncbicfg.c\"\ntest -f \"$ncbicfg\" -a ! -f \"$ncbicfg.last\" && cp -p \"$ncbicfg\" \"$ncbicfg.last\"\n\ntest -d \"$status_dir\"  ||  mkdir -p \"$status_dir\"\nCONFIG_STATUS=$status_dir/config.status\n\n## Configure the compiler/flag-dependent header\nAC_CONFIG_HEADER(${ncbiconf}:src/build-system/config.h.in)\n\n##\n## Configure makefiles, shell scripts, etc.\n##\nAC_CONFIG_FILES($configurables \\\n   $srcdir/./Makefile:src/build-system/Makefile.in.top \\\n   $build_root/inc/common/ncbi_build_ver.h:include/common/ncbi_build_ver.h.in)\n\nAC_CONFIG_COMMANDS([default], [\ndnl make all shell scripts *.sh be executable\nfind \"$build_root/.\" -name '*.sh' -print | while read x_file ; do\n   chmod a+x \"$x_file\"\ndone\nchmod a+x \"$build_root/build/run_with_cd_reporter.py\"\n\ndnl save cache and log files to the build tree dir \"status/\"\ndnl (alongside config.status, which is now directly created there to\ndnl avoid possible trouble; for that matter, it can be at least as\ndnl important to avoid having config.log still open for writing during\ndnl the move).\nif test -f config.cache -a -f config.log ; then\n   test -d  \"$status_dir\"  ||  mkdir -p \"$status_dir\"\n   exec AS_MESSAGE_LOG_FD>/dev/null\n   mv config.cache config.log \"$status_dir\"/\n   exec AS_MESSAGE_LOG_FD>>\"$status_dir/config.log\"\nfi\n\ndnl Update list of enabled packages\nrm -f \"$status_dir\"/*.enabled\nfor p in $WithPackages $WithProjects $WithFeatures ; do\n   touch \"$status_dir\"/$p.enabled\ndone\nfor p in $WithoutPackages $WithoutProjects $WithoutFeatures ; do\n   touch \"$status_dir\"/-$p.enabled\ndone\n\ndnl Create dummy .dep files for system installations of (b)zlib.\ndnl This is a stopgap measure, and fails for installations in non-system dirs.\n# test -f \"$status_dir\"/LocalZ.enabled  ||  \\\n#    touch -t 197001010000 $status_dir/.z.dep\n# test -f \"$status_dir\"/LocalBZ2.enabled  ||  \\\n#    touch -t 197001010000 $status_dir/.bz2.dep\n\ndnl Incorporate any Makefile.*.mk and ncbiconf.*.h files found in the tree.\nfind \"$srcdir\"/src/* -name .svn -prune -o -name build-system -prune \\\n   -o -name 'Makefile.*.mk' -print \\\n   | while read x; do\n      echo\n      echo \"### Extra macro definitions from $x\"\n      echo\n      echo \"#line 1 \\\"$x\\\"\"\n      cat \"$x\"\n   done >> \"$builddir/Makefile.mk\"\n$srcdir/scripts/common/impl/report_duplicates.awk \\\n   src=\"$srcdir/src/build-system/Makefile.mk.in\" \"$builddir/Makefile.mk\"\nfind \"$srcdir\"/src/* -name .svn -prune -o -name 'ncbiconf.*.h' -print \\\n   | while read x; do\n      echo\n      echo \"/*** Extra macro definitions from $x ***/\"\n      echo\n      echo \"#line 1 \\\"$x\\\"\"\n      cat \"$x\"\n   done > \"$build_root/inc/ncbiconf_extra.h\"\nif test -s \"$build_root/inc/ncbiconf_extra.h\"; then\n   ncbiconf=$build_root/inc/ncbiconf_unix.h\n   newconf=$ncbiconf.extra.new\n   savedconf=$ncbiconf.extra.prev\n   cat \"$ncbiconf\" \"$build_root/inc/ncbiconf_extra.h\" > \"$newconf\"\n   $srcdir/scripts/common/impl/report_duplicates.awk \\\n      src=\"$srcdir/src/build-system/config.h.in\" \"$newconf\"\n   if test -f \"$savedconf\"  &&  cmp \"$newconf\" \"$savedconf\" >/dev/null; then\n      echo \"$ncbiconf is unchanged\"\n   else\n      cp -pf \"$newconf\" \"$savedconf\"\n   fi\n   cp -pf \"$savedconf\" \"$ncbiconf\"\nelse\n   rm -f \"$build_root/inc/ncbiconf_extra.h\"\nfi\n\ndnl Avoid gratuitous rebuilding\nfor f in \"$builddir/corelib/ncbicfg.c\" \\\n         \"$build_root/inc/common/ncbi_build_ver.h\"; do\n   if test -f \"$f.last\" && cmp -s \"$f.last\" \"$f\"; then\n      echo \"$f\" is unchanged\n      touch -r \"$f.last\" \"$f\"\n   elif test -f \"$f\"; then\n      echo \"$f\" is updated\n      rm -f \"$f.last\"\n      cp -p \"$f\" \"$f.last\"\n   else\n      echo \"$f\" is not present\n   fi\ndone\n\ndnl Try to build simple helpers\n(cd $builddir/build-system/helpers && $MAKE -k)\n\ndnl Generated header containing random compile-time values, produced by\ndnl either project_tree_builder (alongside Makefile.flat) or fallback logic.\nrandom_macro=\"$build_root/inc/ncbi_random_macro.h\"\nrm -f $random_macro\n\ndnl Create Makefile.flat if requested\nif test \"$with_configure_dialog\" = yes; then\n   if test \"$with_flat_makefile\" = no; then\n      AC_MSG_ERROR([incompatible options: --without-flat-makefile but --with-configure-dialog.])\n   fi\n   with_flat_makefile=yes\nelif test \"${with_saved_settings:-no}\" != no; then\n   if test \"$with_flat_makefile\" = no; then\n      AC_MSG_ERROR([incompatible options: --without-flat-makefile but --with-saved-settings.])\n   fi\n   with_flat_makefile=yes\nfi\nif test \"$with_flat_makefile\" != \"no\"; then\n   if test \"$with_flat_makefile\" = yes; then\n      cfm_flags=''\n   else\n      cfm_flags='-remoteptb'\n   fi\n   if test -n \"$with_projects\"; then\n      cfm_flags=\"$cfm_flags -p $with_projects\"\n   fi\n   if test \"$with_configure_dialog\" = yes; then\n      cfm_flags=\"$cfm_flags -cfg\"\n   fi\n   if test \"${with_saved_settings-no}\" != no; then\n      cfm_flags=\"$cfm_flags -saved $with_saved_settings\"\n   fi\n   if $real_srcdir/scripts/common/impl/create_flat_makefile.sh \"$build_root\" \\\n       -s \"$real_srcdir\" $cfm_flags  &&  test -f \"$builddir/Makefile.flat\"; then\n      build_flat=\"Alternatively, cd $builddir && $MAKE -f Makefile.flat\"\n   elif test -f \"$builddir/Flat.configuration_log\" \\\n      -o \"$with_flat_makefile\" = yes; then\n      $EGREP_Q 'Error:|already defined' \"$builddir/Flat.configuration_log\"\n      AC_MSG_ERROR([flat makefile generation failed.])\n   fi\nfi\n\nif test ! -f \"$random_macro\"; then\n   $real_srcdir/scripts/common/impl/define_random_macros.sh >$random_macro\nfi\n\ndnl execute extra-action\nif test -n \"$with_extra_action\" ; then\n   with_extra_action=`echo \"$with_extra_action\" | sed \"s%{}%$build_root%g\"`\n   echo\n   echo \"executing:  $with_extra_action...\"\n   eval $with_extra_action\n   exit_code=\"$?\"\n   if test $exit_code -ne 0 ; then\n      AC_MSG_WARN([non-zero exit code ($exit_code):  $with_extra_action])\n   fi\n   echo\nfi\n\ndnl print out additional configuration options\ncase \"$LIB_OR_DLL\" in\nboth) DLL_USAGE=\"LIBRARIES:  build both static and dynamic by default\" ;;\ndll)  DLL_USAGE=\"LIBRARIES:  build as dynamic by default\" ;;\nlib)\n   if test \"$with_dll\" = \"no\" ; then\n      DLL_USAGE=\"LIBRARIES:  build as static only\"\n   else\n      DLL_USAGE=\"LIBRARIES:  build as static by default\"\n   fi\n   ;;\nesac\n\nif test -n \"$with_projects\"; then\n    build_proj=\"To build selected projects (as listed in \\\"$with_projects\\\"):\n  cd $builddir && $MAKE all_p\"\nfi\n\ncat << EOCONF\n===============================================================================\nNCBI C++ Toolkit documentation:\n  Online:   http://www.ncbi.nlm.nih.gov/toolkit/doc/book/\n  Local:    ./doc/public/index.html\nFor the available configuration flags run:  ./configure --help\n\nCFLAGS   = $CFLAGS\nCXXFLAGS = $CXXFLAGS\nCPPFLAGS = $CPPFLAGS\nLDFLAGS  = $LDFLAGS\n\n$DLL_USAGE\nFEATURES:   $WithFeatures\nPACKAGES:\n  enabled:  $WithPackages\n  disabled: $WithoutPackages\nPROJECTS:\n  enabled:  $WithProjects\n  disabled: $WithoutProjects\n\nTools / flags / paths:  $builddir/Makefile.mk\nConfiguration  header:  $ncbiconf\n\nTo build everything:  cd $builddir && $MAKE all_r\nor simply run $MAKE in the current directory\n$build_proj\n$build_flat\n******* CONFIGURATION SUCCESSFUL *******\nEOCONF\n], [\nPATH=\"$HOME/bin:/bin:/usr/bin:\\$PATH\"\nstatus_dir='$status_dir'\nbuilddir='$builddir'\nbuild_root='$build_root'\nx_configurables='$x_configurables'\nncbiconf='$ncbiconf'\nCFLAGS='$CFLAGS'\nCXXFLAGS='$CXXFLAGS'\nCPPFLAGS='$CPPFLAGS'\nLDFLAGS='$LDFLAGS'\nLIB_OR_DLL='$LIB_OR_DLL'\nMAKE='$MAKE'\nwith_dll='$with_dll'\nWithFeatures='$WithFeatures'\nWithoutFeatures='$WithoutFeatures'\nWithPackages='$WithPackages'\nWithoutPackages='$WithoutPackages'\nWithProjects='$WithProjects $OPT_GROUPS'\nWithoutProjects='$WithoutProjects'\nwith_extra_action='$with_extra_action'\nwith_projects='$with_projects'\nwith_flat_makefile='$with_flat_makefile'\nwith_configure_dialog='$with_configure_dialog'\nwith_saved_settings='$with_saved_settings'\nsmart_pwd='$smart_pwd'\nreal_srcdir='$real_srcdir'\nEGREP_Q='$EGREP_Q'\nexport MAKE PATH\n])\n\nAC_WARNING([*** Please don't forget to update .../src/build-system/NEWS if appropriate! ***])dnl\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/cmake/CMake.NCBIComponentsUNIX.cmake": "#############################################################################\n# $Id: CMake.NCBIComponentsUNIX.cmake 585870 2019-05-06 16:06:54Z dicuccio $\n#############################################################################\n\n##\n## NCBI CMake components description - UNIX/Linux\n##\n##\n## As a result, the following variables should be defined for component XXX\n##  NCBI_COMPONENT_XXX_FOUND\n##  NCBI_COMPONENT_XXX_INCLUDE\n##  NCBI_COMPONENT_XXX_DEFINES\n##  NCBI_COMPONENT_XXX_LIBS\n##  HAVE_LIBXXX\n##  HAVE_XXX\n\n\n# NOTE:\n#  for the time being, macros are defined at the end of the file\n# ---------------------------------------------------------------------------\n\nset(NCBI_ALL_COMPONENTS \"\")\n#############################################################################\n\n\ninclude(CheckLibraryExists)\n\ncheck_library_exists(dl dlopen \"\" HAVE_LIBDL)\nif(HAVE_LIBDL)\n    set(DL_LIBS -ldl)\nelse(HAVE_LIBDL)\n    if (UNIX)\n        message(FATAL_ERROR \"dl library not found\")\n    endif(UNIX)\nendif(HAVE_LIBDL)\n\ncheck_library_exists(jpeg jpeg_start_decompress \"\" HAVE_LIBJPEG)\ncheck_library_exists(gif EGifCloseFile \"\" HAVE_LIBGIF)\ncheck_library_exists(tiff TIFFClientOpen \"\" HAVE_LIBTIFF)\ncheck_library_exists(png png_create_read_struct \"\" HAVE_LIBPNG)\n\noption(USE_LOCAL_BZLIB \"Use a local copy of libbz2\")\noption(USE_LOCAL_PCRE \"Use a local copy of libpcre\")\n\n\n\n############################################################################\n# NOTE:\n# We conditionally set a package config path\n# The existence of files in this directory switches find_package()\n# to automatically switch between module mode vs. config mode\n#\nset(NCBI_TOOLS_ROOT $ENV{NCBI})\nif (EXISTS ${NCBI_TOOLS_ROOT})\n    set(_NCBI_DEFAULT_PACKAGE_SEARCH_PATH \"${NCBI_TREE_CMAKECFG}/ncbi-defaults\")\n    set(CMAKE_PREFIX_PATH\n        ${CMAKE_PREFIX_PATH}\n        ${_NCBI_DEFAULT_PACKAGE_SEARCH_PATH}\n        )\n    message(STATUS \"NCBI Root: ${NCBI_TOOLS_ROOT}\")\n    message(STATUS \"CMake Prefix Path: ${CMAKE_PREFIX_PATH}\")\nelse()\n    message(STATUS \"NCBI Root: <not found>\")\nendif()\n\nif(WIN32)\n    # Specific location overrides for Windows packages\n    # Note: this variable must be set in the CMake GUI!!\n    #set(WIN32_PACKAGE_ROOT \"C:/Users/dicuccio/dev/packages\")\n    set(GIF_ROOT \"${WIN32_PACKAGE_ROOT}/giflib-4.1.4-1-lib\")\n    set (ENV{GIF_DIR} \"${GIF_ROOT}\")\n\n    set(PCRE_PKG_ROOT \"${WIN32_PACKAGE_ROOT}/pcre-7.9-lib\")\n    set(PCRE_PKG_INCLUDE_DIRS \"${PCRE_PKG_ROOT}/include\")\n    set(PCRE_PKG_LIBRARY_DIRS \"${PCRE_PKG_ROOT}/lib\")\n\n    set(GNUTLS_ROOT \"${WIN32_PACKAGE_ROOT}/gnutls-3.4.9\")\n    set(PC_GNUTLS_INCLUDEDIR \"${GNUTLS_ROOT}/include\")\n    set(PC_GNUTLS_LIBDIR \"${GNUTLS_ROOT}/lib\")\n\n    set(FREETYPE_ROOT \"${WIN32_PACKAGE_ROOT}/freetype-2.3.5-1-lib\")\n    set(ENV{FREETYPE_DIR} \"${FREETYPE_ROOT}\")\n\n    set(FTGL_ROOT \"${WIN32_PACKAGE_ROOT}/ftgl-2.1.3_rc5\")\n    set(LZO_ROOT \"${WIN32_PACKAGE_ROOT}/lzo-2.05-lib\")\n\n    set(CMAKE_PREFIX_PATH\n        ${CMAKE_PREFIX_PATH}\n        \"${PCRE_PKG_ROOT}\"\n        \"${GNUTLS_ROOT}\"\n        \"${LZO_ROOT}\"\n        \"${GIF_ROOT}\"\n        \"${WIN32_PACKAGE_ROOT}/libxml2-2.7.8.win32\"\n        \"${WIN32_PACKAGE_ROOT}/libxslt-1.1.26.win32\"\n        \"${WIN32_PACKAGE_ROOT}/iconv-1.9.2.win32\"\n        \"${FREETYPE_ROOT}\"\n        \"${WIN32_PACKAGE_ROOT}/glew-1.5.8\"\n        \"${FTGL_ROOT}\"\n        \"${WIN32_PACKAGE_ROOT}/sqlite3-3.8.10.1\"\n        \"${WIN32_PACKAGE_ROOT}/db-4.6.21\"\n\t\t\"${WIN32_PACKAGE_ROOT}/lmdb-0.9.18\"\n        )\nendif()\n\n#\n# Framework for dealing with external libraries\n#\ninclude(${NCBI_TREE_CMAKECFG}/FindExternalLibrary.cmake)\n\n############################################################################\n#\n# PCRE additions\n#\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.pcre.cmake)\n\n############################################################################\n#\n# Compression libraries\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.compress.cmake)\n\n#################################\n# Some platform-specific system libs that can be linked eventually\nset(THREAD_LIBS   ${CMAKE_THREAD_LIBS_INIT})\nif (WIN32)\n    set(KSTAT_LIBS    \"\")\n    set(RPCSVC_LIBS   \"\")\n    set(DEMANGLE_LIBS \"\")\n    set(UUID_LIBS      \"\")\n    set(NETWORK_LIBS  \"ws2_32.lib\")\n    set(RT_LIBS          \"\")\n    set(MATH_LIBS      \"\")\n    set(CURL_LIBS      \"\")\n    set(MYSQL_INCLUDE_DIR      \"\")\nendif()\n\nfind_library(UUID_LIBS NAMES uuid)\nfind_library(CRYPT_LIBS NAMES crypt)\nfind_library(MATH_LIBS NAMES m)\n\nif (APPLE)\n  find_library(NETWORK_LIBS c)\n  find_library(RT_LIBS c)\nelse (APPLE)\n  find_library(NETWORK_LIBS nsl)\n  find_library(RT_LIBS        rt)\nendif (APPLE)\n\n#\n# Basic Library Definitions\n# FIXME: get rid of these\n#\n\nset(ORIG_LIBS   ${RT_LIBS} ${MATH_LIBS} ${CMAKE_THREAD_LIBS_INIT})\nset(ORIG_C_LIBS            ${MATH_LIBS} ${CMAKE_THREAD_LIBS_INIT})\nset(C_LIBS      ${ORIG_C_LIBS})\n\n\n# ############################################################\n# Specialized libs settings\n# Mostly, from Makefile.mk\n# ############################################################\n#\n\nset(LIBS ${LIBS} ${DL_LIBS} ${CMAKE_THREAD_LIBS_INIT})\n\n\n#\n# NCBI-specific library subsets\n# NOTE:\n# these should be eliminated or simplified; they're not needed\n#\nset(LOCAL_LBSM ncbi_lbsm ncbi_lbsm_ipc ncbi_lbsmd)\n\n############################################################################\n#\n# OS-specific settings\nif (UNIX)\n    find_library(GMP_LIB LIBS gmp HINTS \"$ENV{NCBI}/gmp-6.0.0a/lib64/\")\n    find_library(IDN_LIB LIBS idn HINTS \"/lib64\")\n    find_library(NETTLE_LIB LIBS nettle HINTS \"$ENV{NCBI}/nettle-3.1.1/lib64\")\n    find_library(HOGWEED_LIB LIBS hogweed HINTS \"$ENV{NCBI}/nettle-3.1.1/lib64\")\nelseif (WIN32)\n    set(GMP_LIB \"\")\n    set(IDN_LIB \"\")\n    set(NETTLE_LIB \"\")\n    set(HOGWEED_LIB \"\")\nendif()\n\nfind_package(GnuTLS)\nif (GnuTLS_FOUND)\n    set(GNUTLS_LIBRARIES ${GNUTLS_LIBRARIES} ${ZLIB_LIBRARIES} ${IDN_LIB} ${RT_LIBS} ${HOGWEED_LIB} ${NETTLE_LIB} ${GMP_LIB})\n    set(GNUTLS_LIBS ${GNUTLS_LIBRARIES})\nendif()\n\n############################################################################\n#\n# Kerberos 5 (via GSSAPI)\n# FIXME: replace with native CMake check\n#\nfind_external_library(KRB5 INCLUDES gssapi/gssapi_krb5.h LIBS gssapi_krb5 krb5 k5crypto com_err)\n\n\n############################################################################\n#\n# Sybase stuff\n#find_package(Sybase)\n\nif (WIN32)\n\tfind_external_library(Sybase\n    DYNAMIC_ONLY\n    INCLUDES sybdb.h\n    #LIBS libsybblk\n\tLIBS libsybblk libsybdb64 libsybct libsybcs\n    INCLUDE_HINTS \"${WIN32_PACKAGE_ROOT}\\\\sybase-15.5\\\\include\"\n\tLIBS_HINTS \"${WIN32_PACKAGE_ROOT}\\\\sybase-15.5\\\\lib\")\nelse (WIN32)\n\tfind_external_library(Sybase\n#    DYNAMIC_ONLY\n    INCLUDES sybdb.h\n#    LIBS sybblk_r64 sybdb64 sybct_r64 sybcs_r64 sybtcl_r64 sybcomn_r64 sybintl_r64 sybunic64\n    LIBS  sybblk_r64         sybct_r64 sybcs_r64 sybtcl_r64 sybcomn_r64 sybintl_r64 sybunic64\n    HINTS \"/opt/sybase/clients/15.7-64bit/OCS-15_0/\")\nendif (WIN32)\n\nif (NOT SYBASE_FOUND)\n\tmessage(FATAL \"no sybase found.\" )\nendif (NOT SYBASE_FOUND)\n\nset(SYBASE_DBLIBS \"${SYBASE_LIBS}\")\n\n############################################################################\n#\n# FreeTDS\n# FIXME: do we need these anymore?\n#\nset(ftds64   ftds64)\nset(FTDS64_CTLIB_INCLUDE ${includedir}/dbapi/driver/ftds64/freetds)\nset(FTDS64_INCLUDE    ${FTDS64_CTLIB_INCLUDE})\n\nset(ftds95   ftds95)\nset(FTDS95_CTLIB_LIBS  ${ICONV_LIBS} ${KRB5_LIBS})\nset(FTDS95_CTLIB_LIB   ct_ftds95 tds_ftds95)\nset(FTDS95_CTLIB_INCLUDE ${includedir}/dbapi/driver/ftds95/freetds)\nset(FTDS95_LIBS        ${FTDS95_CTLIB_LIBS})\nset(FTDS95_LIB        ${FTDS95_CTLIB_LIB})\nset(FTDS95_INCLUDE    ${FTDS95_CTLIB_INCLUDE})\n\nset(ftds100   ftds100)\nset(FTDS100_CTLIB_LIBS  ${ICONV_LIBS} ${KRB5_LIBS})\nset(FTDS100_CTLIB_LIB   ct_ftds100 tds_ftds100)\nset(FTDS100_CTLIB_INCLUDE ${includedir}/dbapi/driver/ftds100/freetds)\nset(FTDS100_LIBS        ${FTDS100_CTLIB_LIBS})\nset(FTDS100_LIB        ${FTDS100_CTLIB_LIB})\nset(FTDS100_INCLUDE    ${FTDS100_CTLIB_INCLUDE})\n\nset(ftds          ftds95)\nset(FTDS_LIBS     ${FTDS95_LIBS})\nset(FTDS_LIB      ${FTDS95_LIB})\nset(FTDS_INCLUDE  ${FTDS95_INCLUDE})\n\n#OpenSSL\nfind_package(OpenSSL)\nif (OpenSSL_FOUND)\n    set(OpenSSL_LIBRARIES ${OPENSSL_LIBRARIES} ${Z_LIBS} ${DL_LIBS})\n    set(OPENSSL_LIBS ${OPENSSL_LIBRARIES})\n    set(HAVE_LIBOPENSSL 1)\n    message(STATUS \"OpenSSL_LIBRARIES = ${OpenSSL_LIBRARIES}\")\nendif()\n\n#EXTRALIBS were taken from mysql_config --libs\nfind_external_library(Mysql INCLUDES mysql/mysql.h LIBS mysqlclient EXTRALIBS ${Z_LIBS} ${CRYPT_LIBS} ${NETWORK_LIBS} ${MATH_LIBS} ${OPENSSL_LIBS})\n\n############################################################################\n#\n# BerkeleyDB\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.BerkeleyDB.cmake)\n\n# ODBC\n# FIXME: replace with native CMake check\n#\nset(ODBC_INCLUDE  ${includedir}/dbapi/driver/odbc/unix_odbc \n                  ${includedir0}/dbapi/driver/odbc/unix_odbc)\nset(ODBC_LIBS)\n\n# Python\nfind_external_library(Python\n    INCLUDES Python.h\n    LIBS python2.7\n    INCLUDE_HINTS \"/opt/python-2.7env/include/python2.7/\"\n    LIBS_HINTS \"/opt/python-2.7env/lib/\")\n\n############################################################################\n#\n# Boost settings\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.boost.cmake)\n\n############################################################################\n#\n# NCBI C Toolkit:  headers and libs\n# Path overridden in stable components to avoid version skew.\nset(NCBI_C_ROOT \"${NCBI_TOOLS_ROOT}/c++.by-date/production/20190103/C_TOOLKIT\")\nstring(REGEX MATCH \"DNCBI_INT8_GI|NCBI_STRICT_GI\" INT8GI_FOUND \"${CMAKE_CXX_FLAGS}\")\nif (NOT \"${INT8GI_FOUND}\" STREQUAL \"\")\n    if (EXISTS \"${NCBI_C_ROOT}/ncbi.gi64/\")\n        set(NCBI_CTOOLKIT_PATH \"${NCBI_C_ROOT}/ncbi.gi64/\")\n    elseif (EXISTS \"${NCBI_C_ROOT}.gi64\")\n        set(NCBI_CTOOLKIT_PATH \"${NCBI_C_ROOT}.gi64/\")\n    else ()\n        set(NCBI_CTOOLKIT_PATH \"${NCBI_C_ROOT}/\")\n    endif ()\nelse ()\n    set(NCBI_CTOOLKIT_PATH \"${NCBI_C_ROOT}/\")\nendif ()\n\nif (EXISTS \"${NCBI_CTOOLKIT_PATH}/include64\" AND EXISTS \"${NCBI_CTOOLKIT_PATH}/lib64\")\n    set(NCBI_C_INCLUDE  \"${NCBI_CTOOLKIT_PATH}/include64\")\n    if (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Debug\")\n        set(NCBI_C_LIBPATH  \"${NCBI_CTOOLKIT_PATH}/altlib64\")\n    else()\n        set(NCBI_C_LIBPATH  \"${NCBI_CTOOLKIT_PATH}/lib64\")\n    endif()\n    set(NCBI_C_ncbi     \"ncbi\")\n    if (APPLE)\n        set(NCBI_C_ncbi ${NCBI_C_ncbi} -Wl,-framework,ApplicationServices)\n    endif ()\n    set(HAVE_NCBI_C true)\nelseif (WIN32)\n    set(NCBI_CTOOLKIT_WIN32 \"//snowman/win-coremake/Lib/Ncbi/C_Toolkit/vs2015.64/c.current\")\n    if (EXISTS \"${NCBI_CTOOLKIT_WIN32}\")\n        set(NCBI_C_INCLUDE \"${NCBI_CTOOLKIT_WIN32}/include\")\n        set(NCBI_C_LIBPATH \"${NCBI_CTOOLKIT_WIN32}/lib\")\n        set(NCBI_C_ncbi    \"ncbi.lib\")\n        set(HAVE_NCBI_C true)\n    else()\n        set(HAVE_NCBI_C false)\n    endif()\nelse ()\n    set(HAVE_NCBI_C false)\nendif ()\n\nmessage(STATUS \"HAVE_NCBI_C = ${HAVE_NCBI_C}\")\nmessage(STATUS \"NCBI_C_INCLUDE = ${NCBI_C_INCLUDE}\")\nmessage(STATUS \"NCBI_C_LIBPATH = ${NCBI_C_LIBPATH}\")\n\n############################################################################\n#\n# OpenGL: headers and libs (including core X dependencies) for code\n# not using other toolkits.  (The wxWidgets variables already include\n# these as appropriate.)\n\nfind_package(OpenGL)\nif (WIN32)\n    set(GLEW_INCLUDE ${WIN32_PACKAGE_ROOT}/glew-1.5.8/include)\n    set(GLEW_LIBRARIES ${WIN32_PACKAGE_ROOT}/glew-1.5.8/lib/glew32mx.lib)\nelse()\n    find_package(GLEW)\nendif()\nfind_package(OSMesa)\nif (${OPENGL_FOUND})\n    set(OPENGL_INCLUDE \"${OPENGL_INCLUDE_DIR}\")\n    set(OPENGL_LIBS \"${OPENGL_LIBRARIES}\")\n\n    set(OPENGL_INCLUDE ${OPENGL_INCLUDE_DIRS})\n    set(OPENGL_LIBS ${OPENGL_LIBRARIES})\n    set(GLEW_INCLUDE ${GLEW_INCLUDE_DIRS})\n    set(GLEW_LIBS ${GLEW_LIBRARIES})\n    set(OSMESA_INCLUDE ${OSMesa_INCLUDE_DIRS} ${OPENGL_INCLUDE_DIRS})\n    set(OSMESA_LIBS ${OSMesa_LIBRARIES} ${OPENGL_LIBRARIES})\n\nendif()\n\n############################################################################\n#\n# wxWidgets\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.wxwidgets.cmake)\n\n# Fast-CGI\nset(_fcgi_version \"fcgi-2.4.0\")\nif (APPLE)\n  find_external_library(FastCGI\n      INCLUDES fastcgi.h\n      LIBS fcgi\n      HINTS \"${NCBI_TOOLS_ROOT}/${_fcgi_version}\")\nelse ()\n    set(_fcgi_root \"${NCBI_TOOLS_ROOT}/${_fcgi_version}\")\n    if (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\"\n            AND BUILD_SHARED_LIBS \n            AND EXISTS /opt/ncbi/64/${_fcgi_version} )\n        set(_fcgi_root \"/opt/ncbi/64/${_fcgi_version}\")\n    endif()\n\n    if (BUILD_SHARED_LIBS)\n        set(_fcgi_root \"${_fcgi_root}/shlib\")\n    else()\n        set(_fcgi_root \"${_fcgi_root}/lib\")\n    endif()\n\n    find_library(FASTCGI_LIBS\n        NAMES fcgi\n        HINTS \"${_fcgi_root}\")\n    find_path(FASTCGI_INCLUDE\n        NAME fastcgi.h\n        HINTS \"${NCBI_TOOLS_ROOT}/${_fcgi_version}/include\")\n\n    if (FASTCGI_LIBS)\n        set(FASTCGI_FOUND True)\n    endif()\n\n    message(STATUS \"FastCGI found at: ${FASTCGI_LIBS}\")\nendif()\n\n# Fast-CGI lib:  (module to add to the \"xcgi\" library)\nset(FASTCGI_OBJS    fcgibuf)\n\n# NCBI SSS:  headers, library path, libraries\nset(NCBI_SSS_INCLUDE ${incdir}/sss)\nset(NCBI_SSS_LIBPATH )\nset(LIBSSSUTILS      -lsssutils)\nset(LIBSSSDB         -lsssdb -lssssys)\nset(sssutils         sssutils)\nset(NCBILS2_LIB      ncbils2_cli ncbils2_asn ncbils2_cmn)\nset(NCBILS_LIB       ${NCBILS2_LIB})\n\n\n# SP:  headers, libraries\nset(SP_INCLUDE )\nset(SP_LIBS    )\n\n# ORBacus CORBA headers, library path, libraries\nset(ORBACUS_INCLUDE )\nset(ORBACUS_LIBPATH )\nset(LIBOB           )\n# LIBIMR should be empty for single-threaded builds\nset(LIBIMR          )\n\n# IBM's International Components for Unicode\nfind_external_library(ICU\n    INCLUDES unicode/ucnv.h\n    LIBS icui18n icuuc icudata\n    HINTS \"${NCBI_TOOLS_ROOT}/icu-49.1.1\")\n\n\n##############################################################################\n## LibXml2 / LibXsl\n##\nfind_library(GCRYPT_LIBS NAMES gcrypt HINTS \"$ENV{NCBI}/libgcrypt/${CMAKE_BUILD_TYPE}/lib\")\nfind_library(GPG_ERROR_LIBS NAMES gpg-error HINTS \"$ENV{NCBI}/libgpg-error/${CMAKE_BUILD_TYPE}/lib\")\nif (NOT GCRYPT_LIBS STREQUAL \"GCRYPT_LIBS-NOTFOUND\")\n    set(GCRYPT_FOUND True)\n    set(GCRYPT_LIBS ${GCRYPT_LIBS} ${GPG_ERROR_LIBS})\nelse()\n    set(GCRYPT_FOUND False)\nendif()\n\n# ICONV\n# Windows requires special handling for this\nif (WIN32)\n    find_external_library(iconv\n        INCLUDES iconv.h\n        LIBS iconv)\nendif()\n\nfind_package(LibXml2)\nif (LIBXML2_FOUND)\n    set(LIBXML_INCLUDE ${LIBXML2_INCLUDE_DIR})\n    set(LIBXML_LIBS    ${LIBXML2_LIBRARIES})\n    if (WIN32)\n        set(LIBXML_INCLUDE ${LIBXML_INCLUDE} ${ICONV_INCLUDE})\n        set(LIBXML_LIBS ${LIBXML_LIBS} ${ICONV_LIBS})\n    endif()\nendif()\n\nfind_package(LibXslt)\nif (LIBXSLT_FOUND)\n    set(LIBXSLT_INCLUDE  ${LIBXSLT_INCLUDE_DIR})\n    set(LIBXSLT_LIBS     ${LIBXSLT_EXSLT_LIBRARIES} ${LIBXSLT_LIBRARIES} ${LIBXML_LIBS})\n    set(LIBEXSLT_INCLUDE ${LIBXSLT_INCLUDE_DIR})\n    set(LIBEXSLT_LIBS    ${LIBXSLT_EXSLT_LIBRARIES})\n    if (GCRYPT_FOUND)\n        set(LIBXSLT_LIBS     ${LIBXSLT_LIBS} ${GCRYPT_LIBS})\n        set(LIBEXSLT_LIBS    ${LIBEXSLT_LIBS} ${GCRYPT_LIBS})\n    endif()\nendif()\n\n\nfind_external_library(xerces\n    INCLUDES xercesc/dom/DOM.hpp\n    LIBS xerces-c\n    HINTS \"${NCBI_TOOLS_ROOT}/xerces-3.1.2/${CMAKE_BUILD_TYPE}\")\n\nfind_external_library(xalan\n    INCLUDES xalanc/XalanTransformer/XalanTransformer.hpp\n    LIBS xalan-c xalanMsg\n    HINTS \"${NCBI_TOOLS_ROOT}/xalan-1.11/${CMAKE_BUILD_TYPE}\")\n\n# Sun Grid Engine (libdrmaa):\n# libpath - /netmnt/uge/lib/lx-amd64/\nfind_external_library(SGE\n    INCLUDES drmaa.h\n    LIBS drmaa\n    INCLUDE_HINTS \"/netmnt/gridengine/current/include\"\n    LIBS_HINTS \"/netmnt/gridengine/current/lib/lx-amd64/\")\n\n# muParser\nfind_external_library(muparser\n    INCLUDES muParser.h\n    LIBS muparser\n    INCLUDE_HINTS \"${NCBI_TOOLS_ROOT}/muParser-1.30/include\"\n    LIBS_HINTS \"${NCBI_TOOLS_ROOT}/muParser-1.30/${CMAKE_BUILD_TYPE}/lib/\")\n\n# HDF5\nfind_external_library(hdf5\n    INCLUDES hdf5.h\n    LIBS hdf5\n    HINTS \"${NCBI_TOOLS_ROOT}/hdf5-1.8.3/${CMAKE_BUILD_TYPE}\")\n\n############################################################################\n#\n# SQLite3\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.sqlite3.cmake)\n\n############################################################################\n#\n# Various image-format libraries\ninclude(${NCBI_TREE_CMAKECFG}/CMakeChecks.image.cmake)\n\n#############################################################################\n## MongoDB\n\nfind_library(SASL2_LIBS sasl2)\n\nif (NOT WIN32)\n    find_package(MongoCXX)\nendif()\nif (MONGOCXX_FOUND)\n    set(MONGOCXX_INCLUDE ${MONGOCXX_INCLUDE_DIRS} ${BSONCXX_INCLUDE_DIRS})\n    set(MONGOCXX_LIB ${MONGOCXX_LIBPATH} ${MONGOCXX_LIBRARIES} ${BSONCXX_LIBRARIES} ${OPENSSL_LIBS} ${SASL2_LIBS})\nendif()\nmessage(STATUS \"MongoCXX Includes: ${MONGOCXX_INCLUDE}\")\n\n##############################################################################\n##\n## LevelDB\n\nfind_package(LEVELDB\n             PATHS\n             /panfs/pan1/gpipe/ThirdParty/leveldb-1.20\n             /usr/local\n             /usr\n             NO_DEFAULT_PATH\n)\n############################################################################\n##\n## wgMLST\n\nif (NOT WIN32)\n    find_package(SKESA)\nendif()\nif (WGMLST_FOUND)\n    set(WGMLST_INCLUDE ${WGMLST_INCLUDE_DIRS})\n    set(WGMLST_LIB ${WGMLST_LIBPATH} ${WGMLST_LIBRARIES})\nendif()\nmessage(STATUS \"wgMLST Includes: ${WGMLST_INCLUDE}\")\n\n# libmagic (file-format identification)\nfind_library(MAGIC_LIBS magic)\n\n# libcurl (URL retrieval)\nfind_library(CURL_LIBS curl)\n\n# libmimetic (MIME handling)\nfind_external_library(mimetic\n    INCLUDES mimetic/mimetic.h\n    LIBS mimetic\n    HINTS \"${NCBI_TOOLS_ROOT}/mimetic-0.9.7-ncbi1/\")\n\n# libgSOAP++\nfind_external_library(gsoap\n    INCLUDES stdsoap2.h\n    LIBS gsoapssl++\n    INCLUDE_HINTS \"${NCBI_TOOLS_ROOT}/gsoap-2.8.15/include\"\n    LIBS_HINTS \"${NCBI_TOOLS_ROOT}/gsoap-2.8.15/${CMAKE_BUILD_TYPE}/lib/\"\n    EXTRALIBS ${Z_LIBS})\n\nset(GSOAP_SOAPCPP2 ${NCBI_TOOLS_ROOT}/gsoap-2.8.15/${CMAKE_BUILD_TYPE}/bin/soapcpp2)\nset(GSOAP_WSDL2H   ${NCBI_TOOLS_ROOT}/gsoap-2.8.15/${CMAKE_BUILD_TYPE}/bin/wsdl2h)\n\n# Compress\nset(COMPRESS_LDEP ${CMPRS_LIB})\nset(COMPRESS_LIBS xcompress ${COMPRESS_LDEP})\n\n\n#################################\n# Useful sets of object libraries\n#################################\n\n\nset(SOBJMGR_LIBS xobjmgr)\nset(ncbi_xreader_pubseqos ncbi_xreader_pubseqos)\nset(ncbi_xreader_pubseqos2 ncbi_xreader_pubseqos2)\nset(OBJMGR_LIBS ncbi_xloader_genbank)\n\n\n# Overlapping with qall is poor, so we have a second macro to make it\n# easier to stay out of trouble.\nset(QOBJMGR_ONLY_LIBS xobjmgr id2 seqsplit id1 genome_collection seqset\n    ${SEQ_LIBS} pub medline biblio general-lib xcompress ${CMPRS_LIB})\nset(QOBJMGR_LIBS ${QOBJMGR_ONLY_LIBS} qall)\nset(QOBJMGR_STATIC_LIBS ${QOBJMGR_ONLY_LIBS} qall)\n\n# EUtils\nset(EUTILS_LIBS eutils egquery elink epost esearch espell esummary linkout\n              einfo uilist ehistory)\n\n\n#\n# SRA/VDB stuff\nif (WIN32)\n\tfind_external_library(VDB\n\t\tINCLUDES sra/sradb.h\n\t\tLIBS ncbi-vdb\n\t\tINCLUDE_HINTS \"\\\\\\\\snowman\\\\trace_software\\\\vdb\\\\vdb-versions\\\\2.9.4-1\\\\interfaces\"\n\t\tLIBS_HINTS \"\\\\\\\\snowman\\\\trace_software\\\\vdb\\\\vdb-versions\\\\2.9.4-1\\\\win\\\\release\\\\x86_64\\\\lib\")\nelse (WIN32)\n\tfind_external_library(VDB\n\t\tINCLUDES sra/sradb.h\n\t\tLIBS ncbi-vdb\n \t    INCLUDE_HINTS \"/opt/ncbi/64/trace_software/vdb/vdb-versions/cxx_toolkit/2/interfaces\"\n \t    LIBS_HINTS \"/opt/ncbi/64/trace_software/vdb/vdb-versions/cxx_toolkit/2/linux/release/x86_64/lib/\")\nendif (WIN32)\n\nif (VDB_FOUND)\n\tif (WIN32)\n\t\tset(VDB_INCLUDE \"${VDB_INCLUDE}\" \"${VDB_INCLUDE}\\\\os\\\\win\" \"${VDB_INCLUDE}\\\\cc\\\\vc++\\\\x86_64\" \"${VDB_INCLUDE}\\\\cc\\\\vc++\")\n\telse (WIN32)\n\t\tset(VDB_INCLUDE \"${VDB_INCLUDE}\" \"${VDB_INCLUDE}/os/linux\" \"${VDB_INCLUDE}/os/unix\" \"${VDB_INCLUDE}/cc/gcc/x86_64\" \"${VDB_INCLUDE}/cc/gcc\")\n\tendif(WIN32)\n    set(SRA_INCLUDE ${VDB_INCLUDE})\n    set(SRA_SDK_SYSLIBS ${VDB_LIBS})\n    set(SRA_SDK_LIBS ${VDB_LIBS})\n    set(SRAXF_LIBS ${SRA_SDK_LIBS})\n    set(SRA_LIBS ${SRA_SDK_LIBS})\n    set(BAM_LIBS ${SRA_SDK_LIBS})\n    set(SRAREAD_LDEP ${SRA_SDK_LIBS})\n    set(SRAREAD_LIBS sraread ${SRA_SDK_LIBS})\n    set(HAVE_NCBI_VDB 1)\nendif ()\n\n# Makefile.blast_macros.mk\nset(BLAST_DB_DATA_LOADER_LIBS ncbi_xloader_blastdb ncbi_xloader_blastdb_rmt)\nset(BLAST_FORMATTER_MINIMAL_LIBS xblastformat align_format taxon1 blastdb_format\n    gene_info xalnmgr blastxml xcgi xhtml)\nset(BLAST_INPUT_LIBS blastinput\n    ${BLAST_DB_DATA_LOADER_LIBS} ${BLAST_FORMATTER_MINIMAL_LIBS})\n\nset(BLAST_FORMATTER_LIBS ${BLAST_INPUT_LIBS})\n\n# Libraries required to link against the internal BLAST SRA library\nset(BLAST_SRA_LIBS blast_sra ${SRAXF_LIBS} vxf ${SRA_LIBS})\n\n# BLAST_FORMATTER_LIBS and BLAST_INPUT_LIBS need $BLAST_LIBS\nset(BLAST_LIBS xblast xalgoblastdbindex composition_adjustment\nxalgodustmask xalgowinmask seqmasks_io seqdb blast_services xobjutil\n${OBJREAD_LIBS} xnetblastcli xnetblast blastdb scoremat tables xalnmgr)\n\n\n\n# SDBAPI stuff\nset(SDBAPI_LIB sdbapi) # ncbi_xdbapi_ftds ${FTDS_LIB} dbapi dbapi_driver ${XCONNEXT})\n\n\nset(VARSVC_LIBS varsvcutil varsvccli varsvcobj)\n\n\n# Entrez Libs\nset(ENTREZ_LIBS entrez2cli entrez2)\nset(EUTILS_LIBS eutils egquery elink epost esearch espell esummary linkout einfo uilist ehistory)\n\n#GLPK\nfind_external_library(glpk\n    INCLUDES glpk.h\n    LIBS glpk\n    HINTS \"/usr/local/glpk/4.45\")\n\nfind_external_library(samtools\n    INCLUDES bam.h\n    LIBS bam\n    HINTS \"${NCBI_TOOLS_ROOT}/samtools\")\n\n# libbackward\nfind_path(LIBBACKWARD_INCLUDE_DIR\n    backward.hpp\n    HINTS $ENV{NCBI}/backward-cpp-1.3/include)\nif (LIBBACKWARD_INCLUDE_DIR)\n    message(STATUS \"Found libbackward: ${LIBBACKWARD_INCLUDE_DIR}\")\n    set(HAVE_LIBBACKWARD_CPP 1)\nendif()\n\n# libdw\nfind_library(LIBDW_LIBRARIES NAMES libdw.so HINTS /usr/lib64)\nif (LIBDW_LIBRARIES)\n    set(HAVE_LIBDW 1)\n    message(STATUS \"Found libdw: ${LIBDW_LIBRARIES}\")\nendif()\n\n\n#LAPACK\ncheck_include_file(lapacke.h HAVE_LAPACKE_H)\ncheck_include_file(lapacke/lapacke.h HAVE_LAPACKE_LAPACKE_H)\ncheck_include_file(Accelerate/Accelerate.h HAVE_ACCELERATE_ACCELERATE_H)\n#find_external_library(LAPACK LIBS lapack blas)\nfind_package(LAPACK)\nif (LAPACK_FOUND)\n    set(LAPACK_INCLUDE ${LAPACK_INCLUDE_DIRS})\n    set(LAPACK_LIBS ${LAPACK_LIBRARIES})\nelse ()\n    find_library(LAPACK_LIBS lapack blas)\nendif ()\n\n#LMDB\nif (WIN32)\n\tfind_external_library(LMDB\n\t\tSTATIC_ONLY\n\t\tINCLUDES lmdb.h \n\t\tLIBS liblmdb \n\t\tINCLUDE_HINTS \"${WIN32_PACKAGE_ROOT}\\\\lmdb-0.9.18\\\\include\" \n\t\tLIB_HINTS \"${WIN32_PACKAGE_ROOT}\\\\lmdb-0.9.18\\\\lib\")\nelse (WIN32)\n\tfind_external_library(LMDB INCLUDES lmdb.h LIBS lmdb HINTS \"${NCBI_TOOLS_ROOT}/lmdb-0.9.18\" EXTRALIBS pthread)\nendif (WIN32)\n\nif (LMDB_INCLUDE)\n    set(HAVE_LIBLMDB 1)\nendif()\n\n############################################################################\n##\n## libxlsxwriter\n\nset(_xlsxwriter_version \"libxlsxwriter-0.6.9\")\nif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\"\n        AND BUILD_SHARED_LIBS \n        AND EXISTS /opt/ncbi/64/${_xlsxwriter_version}/lib/)\n    set(_xlsxwriter_hints \"/opt/ncbi/64/${_xlsxwriter_version}\")\nelse()\n    set(_xlsxwriter_hints \"${NCBI_TOOLS_ROOT}/${_xlsxwriter_version}\")\nendif()\n\nfind_library(LIBXLSXWRITER_LIBS\n    NAMES xlsxwriter\n    HINTS \"${_xlsxwriter_hints}/lib\")\nif (LIBXLSXWRITER_LIBS)\n    find_path(LIBXLSXWRITER_INCLUDE\n        NAMES xlsxwriter.h\n        HINTS \"${NCBI_TOOLS_ROOT}/${_xlsxwriter_version}/include\")\n    if (LIBXLSXWRITER_INCLUDE)\n        set(LIBXLSXWRITER_FOUND True)\n    endif()\nendif()\nif (LIBXLSXWRITER_FOUND)\n    message(STATUS \"Found libxlsxwriter: ${LIBXLSXWRITER_LIBS}\")\nelse()\n    message(STATUS \"Could not find libxlsxwriter\")\nendif()\n\n############################################################################\n##\n## libunwind\n\nset(_unwind_version \"libunwind-1.1\")\nif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\"\n        AND BUILD_SHARED_LIBS \n        AND EXISTS /opt/ncbi/64/${_unwind_version}/lib/)\n    set(_unwind_hints \"/opt/ncbi/64/${_unwind_version}\")\nelse()\n    set(_unwind_hints \"${NCBI_TOOLS_ROOT}/${_unwind_version}\")\nendif()\n\nfind_library(LIBUNWIND_LIBS\n    NAMES unwind\n    HINTS \"${_unwind_hints}/lib\"\n    )\nif (LIBUNWIND_LIBS)\n    find_path(LIBUNWIND_INCLUDE\n        NAME libunwind.h\n        HINTS \"${NCBI_TOOLS_ROOT}/${_unwind_version}/include\")\n    if (LIBUNWIND_INCLUDE)\n        set(HAVE_LIBUNWIND True)\n    endif()\nendif()\n\nif (HAVE_LIBUNWIND)\n    message(STATUS \"Found libunwind: ${LIBUNWIND_LIBS}\")\n    message(STATUS \"Found libunwind.h: ${LIBUNWIND_INCLUDE}\")\nelse()\n    message(STATUS \"Cannot find libunwind\")\nendif()\n\nif (EXISTS \"${NCBI_TOOLS_ROOT}/msgsl-0.0.20171114-1c95f94/include/gsl/gsl\")\n    set(MSGSL_INCLUDE \"${NCBI_TOOLS_ROOT}/msgsl-0.0.20171114-1c95f94/include/\")\nelse()\n    find_path(MSGSL_INCLUDE NAMES gsl/gsl)\nendif()\n\nif (NOT \"${MSGSL_INCLUDE}\" STREQUAL \"\")\n    set(HAVE_MSGSL true)\n    message(STATUS \"Found MSGSL: ${MSGSL_INCLUDE}\")\nelse()\n    message(STATUS \"Could NOT find MSGSL\")\nendif()\n\n# temporarily include the standard python path when searching for Python3\nset(CMAKE_PREFIX_PATH_ORIG ${CMAKE_PREFIX_PATH})\nset(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} /opt/python-all/)\n\nfind_package(PythonInterp 3)\nif (PYTHONINTERP_FOUND)\n    if (NOT \"$ENV{TEAMCITY_VERSION}\" STREQUAL \"\")\n        message(STATUS \"Generating ${build_root}/run_with_cd_reporter.py...\")\n        message(STATUS \"Python3 path: ${PYTHON_EXECUTABLE}\")\n\n        set(PYTHON3 ${PYTHON_EXECUTABLE})\n        set(CD_REPORTER \"/am/ncbiapdata/bin/cd_reporter\")\n        if (DEFINED NCBI_EXTERNAL_TREE_ROOT)\n            set(abs_top_srcdir ${NCBI_EXTERNAL_TREE_ROOT})\n        else()\n            set(abs_top_srcdir ${abs_top_src_dir})\n        endif()\n        configure_file(${NCBI_TREE_BUILDCFG}/run_with_cd_reporter.py.in ${build_root}/build-system/run_with_cd_reporter.py)\n\n        # copy to build_root and set executable permissions (workaround because configure_file doesn't set permissions)\n        file(COPY ${build_root}/build-system/run_with_cd_reporter.py DESTINATION ${build_root}\n            FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${build_root}/run_with_cd_reporter.py)\n    else()\n        message(STATUS \"Detected development build, cd_reporter disabled\")\n    endif()\nelse(PYTHONINTERP_FOUND)\n    message(STATUS \"Could not find Python3. Disabling cd_reporter.\")\nendif(PYTHONINTERP_FOUND)\nset(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH_ORIG})\n\n\nif (WIN32)\n\tset(win_include_directories \n\t\t\"${PCRE_PKG_INCLUDE_DIRS}\" \n\t\t\"${PC_GNUTLS_INCLUDEDIR}\"\n        \"${WIN32_PACKAGE_ROOT}/sqlite3-3.8.10.1/include\"\n\t\t\"${WIN32_PACKAGE_ROOT}/db-4.6.21/include\"\n        \"${WIN32_PACKAGE_ROOT}/libxml2-2.7.8.win32/include\"\n        \"${WIN32_PACKAGE_ROOT}/libxslt-1.1.26.win32/include\"\n        \"${WIN32_PACKAGE_ROOT}/iconv-1.9.2.win32/include\"\n\t\t\"${WIN32_PACKAGE_ROOT}/lmdb-0.9.18/include\" )\n\tinclude_directories(${win_include_directories})\nendif (WIN32)\n\n#############################################################################\n#############################################################################\n#############################################################################\n##\n##          NCBI CMake wrapper adapter\n##\n#############################################################################\n#############################################################################\n\nset(NCBI_COMPONENT_unix_FOUND YES)\nset(NCBI_COMPONENT_Linux_FOUND YES)\n\n#############################################################################\n# NCBI_C\nif(HAVE_NCBI_C)\n  message(\"NCBI_C found at ${NCBI_C_INCLUDE}\")\n  set(NCBI_COMPONENT_NCBI_C_FOUND YES)\n  set(NCBI_COMPONENT_NCBI_C_INCLUDE ${NCBI_C_INCLUDE})\n\n  set(_c_libs  ncbiobj ncbi)\n  foreach( _lib IN LISTS _c_libs)\n    set(NCBI_COMPONENT_NCBI_C_LIBS ${NCBI_COMPONENT_NCBI_C_LIBS} \"${NCBI_C_LIBPATH}/lib${_lib}.a\")\n  endforeach()\n  set(NCBI_COMPONENT_NCBI_C_DEFINES HAVE_NCBI_C=1)\nelse()\n  set(NCBI_COMPONENT_NCBI_C_FOUND NO)\nendif()\n\n#############################################################################\n# STACKTRACE\nset(NCBI_COMPONENT_STACKTRACE_FOUND YES)\nset(NCBI_COMPONENT_STACKTRACE_INCLUDE ${LIBBACKWARD_INCLUDE_DIR} ${LIBUNWIND_INCLUDE})\nset(NCBI_COMPONENT_STACKTRACE_LIBS ${LIBUNWIND_LIBS} ${LIBDW_LIBRARIES})\n\n##############################################################################\n# UUID\nif (NOT UUID_LIBS-NOTFOUND)\nset(NCBI_COMPONENT_UUID_FOUND YES)\nset(NCBI_COMPONENT_UUID_LIBS ${UUID_LIBS})\nendif()\n\n##############################################################################\n# CURL\nif (NOT CURL_LIBS-NOTFOUND)\nset(NCBI_COMPONENT_CURL_FOUND YES)\nset(NCBI_COMPONENT_CURL_LIBS ${CURL_LIBS})\nendif()\n\n#############################################################################\n# TLS\nif(GnuTLS_FOUND)\n  message(\"TLS found at ${GNUTLS_INCLUDE}\")\n  set(NCBI_COMPONENT_TLS_FOUND YES)\n  set(NCBI_COMPONENT_TLS_INCLUDE ${GNUTLS_INCLUDE})\n  set(NCBI_COMPONENT_TLS_LIBS ${GNUTLS_LIBS})\n  set(HAVE_LIBGNUTLS 1)\nelse()\n  set(NCBI_COMPONENT_TLS_FOUND NO)\nendif()\n\n#############################################################################\n# FASTCGI\nif(FASTCGI_FOUND)\n  message(STATUS \"FASTCGI found at ${FASTCGI_INCLUDE}\")\n  set(NCBI_COMPONENT_FASTCGI_FOUND YES)\n  set(NCBI_COMPONENT_FASTCGI_INCLUDE ${FASTCGI_INCLUDE})\n  set(NCBI_COMPONENT_FASTCGI_LIBS ${FASTCGI_LIBS})\nelse()\n    message(STATUS \"FASTCGI not found\")\n  set(NCBI_COMPONENT_FASTCGI_FOUND NO)\nendif()\n\n#############################################################################\n# Boost.Test.Included\nif(Boost_FOUND)\n  set(NCBI_COMPONENT_Boost.Test.Included_FOUND YES)\n  set(NCBI_COMPONENT_Boost.Test.Included_INCLUDE ${Boost_INCLUDE_DIRS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} Boost.Test.Included\")\nelse()\n  set(NCBI_COMPONENT_Boost.Test.Included_FOUND NO)\nendif()\n\n#############################################################################\n# Boost.Test\nif(Boost_FOUND)\n  set(NCBI_COMPONENT_Boost.Test_FOUND YES)\n  set(NCBI_COMPONENT_Boost.Test_INCLUDE ${Boost_INCLUDE_DIRS})\n  set(NCBI_COMPONENT_Boost.Test_LIBS    ${Boost_LIBRARIES})\nelse()\n  set(NCBI_COMPONENT_Boost.Test_FOUND NO)\nendif()\n\n#############################################################################\n# Boost.Spirit\nif(Boost_FOUND)\n  set(NCBI_COMPONENT_Boost.Spirit_FOUND YES)\n  set(NCBI_COMPONENT_Boost.Spirit_INCLUDE ${Boost_INCLUDE_DIRS})\n  set(NCBI_COMPONENT_Boost.Spirit_LIBS    ${Boost_LIBRARIES})\nelse()\n  set(NCBI_COMPONENT_Boost.Spirit_FOUND NO)\nendif()\n\n#############################################################################\n# Boost\nif(Boost_FOUND)\n  set(NCBI_COMPONENT_Boost_FOUND YES)\n  set(NCBI_COMPONENT_Boost_INCLUDE ${Boost_INCLUDE_DIRS})\n  set(NCBI_COMPONENT_Boost_LIBS    ${Boost_LIBRARIES})\nelse()\n  set(NCBI_COMPONENT_Boost_FOUND NO)\nendif()\n\n#############################################################################\n# PCRE\nif(PCRE_FOUND AND NOT USE_LOCAL_PCRE)\n  set(NCBI_COMPONENT_PCRE_FOUND YES)\n  set(NCBI_COMPONENT_PCRE_INCLUDE ${PCRE_INCLUDE_DIR})\n  set(NCBI_COMPONENT_PCRE_LIBS ${PCRE_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} PCRE\")\nelse()\n  set(NCBI_COMPONENT_PCRE_FOUND ${NCBI_COMPONENT_LocalPCRE_FOUND})\n  set(NCBI_COMPONENT_PCRE_INCLUDE ${NCBI_COMPONENT_LocalPCRE_INCLUDE})\n  set(NCBI_COMPONENT_PCRE_NCBILIB ${NCBI_COMPONENT_LocalPCRE_NCBILIB})\nendif()\n\n#############################################################################\n# Z\nif(ZLIB_FOUND)\n  set(NCBI_COMPONENT_Z_FOUND YES)\n  set(NCBI_COMPONENT_Z_INCLUDE ${ZLIB_INCLUDE_DIR})\n  set(NCBI_COMPONENT_Z_LIBS ${ZLIB_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} Z\")\nelse()\n  set(NCBI_COMPONENT_Z_FOUND ${NCBI_COMPONENT_LocalZ_FOUND})\n  set(NCBI_COMPONENT_Z_INCLUDE ${NCBI_COMPONENT_LocalZ_INCLUDE})\n  set(NCBI_COMPONENT_Z_NCBILIB ${NCBI_COMPONENT_LocalZ_NCBILIB})\nendif()\n\n#############################################################################\n# BZ2\nif(BZIP2_FOUND AND NOT USE_LOCAL_BZLIB)\n  set(NCBI_COMPONENT_BZ2_FOUND YES)\n  set(NCBI_COMPONENT_BZ2_INCLUDE ${BZIP2_INCLUDE_DIR})\n  set(NCBI_COMPONENT_BZ2_LIBS ${BZIP2_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} BZ2\")\nelse()\n  set(NCBI_COMPONENT_BZ2_FOUND ${NCBI_COMPONENT_LocalBZ2_FOUND})\n  set(NCBI_COMPONENT_BZ2_INCLUDE ${NCBI_COMPONENT_LocalBZ2_INCLUDE})\n  set(NCBI_COMPONENT_BZ2_NCBILIB ${NCBI_COMPONENT_LocalBZ2_NCBILIB})\nendif()\n\n#############################################################################\n#LZO\nif (LZO_FOUND)\n  set(NCBI_COMPONENT_LZO_FOUND YES)\n  set(NCBI_COMPONENT_LZO_INCLUDE ${LZO_INCLUDE_DIR})\n  set(NCBI_COMPONENT_LZO_LIBS ${LZO_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} LZO\")\nelse()\n  set(NCBI_COMPONENT_LZO_FOUND YES)\nendif()\n\n#############################################################################\n#BerkeleyDB\nif(BERKELEYDB_FOUND)\n  set(NCBI_COMPONENT_BerkeleyDB_FOUND YES)\n  set(NCBI_COMPONENT_BerkeleyDB_INCLUDE ${BerkeleyDB_INCLUDE_DIR})\n  set(NCBI_COMPONENT_BerkeleyDB_LIBS ${BerkeleyDB_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} BerkeleyDB\")\nelse()\n  set(NCBI_COMPONENT_BerkeleyDB_FOUND NO)\nendif()\n\n#############################################################################\n#LMDB\nif(LMDB_FOUND)\n  set(NCBI_COMPONENT_LMDB_FOUND YES)\n  set(NCBI_COMPONENT_LMDB_INCLUDE ${LMDB_INCLUDE})\n  set(NCBI_COMPONENT_LMDB_LIBS ${LMDB_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} LMDB\")\nelse()\n  set(NCBI_COMPONENT_LMDB_FOUND ${NCBI_COMPONENT_LocalLMDB_FOUND})\n  set(NCBI_COMPONENT_LMDB_INCLUDE ${NCBI_COMPONENT_LocalLMDB_INCLUDE})\n  set(NCBI_COMPONENT_LMDB_NCBILIB ${NCBI_COMPONENT_LocalLMDB_NCBILIB})\nendif()\n\n#############################################################################\n# JPEG\nif(HAVE_LIBJPEG)\n  set(NCBI_COMPONENT_JPEG_FOUND YES)\n  set(NCBI_COMPONENT_JPEG_LIBS -ljpeg)\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} JPEG\")\nelse()\n  set(NCBI_COMPONENT_JPEG_FOUND NO)\nendif()\n\n#############################################################################\n# PNG\nif(HAVE_LIBPNG)\n  set(NCBI_COMPONENT_PNG_FOUND YES)\n  set(NCBI_COMPONENT_PNG_LIBS -lpng)\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} PNG\")\nelse()\n  set(NCBI_COMPONENT_PNG_FOUND NO)\nendif()\n\n#############################################################################\n# GIF\nset(NCBI_COMPONENT_GIF_FOUND YES)\n  set(NCBI_COMPONENT_GIF_LIBS -lgif)\nset(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} GIF\")\n\n#############################################################################\n# TIFF\nif(HAVE_LIBTIFF)\n  set(NCBI_COMPONENT_TIFF_FOUND YES)\n  set(NCBI_COMPONENT_TIFF_LIBS -ltiff)\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} TIFF\")\nelse()\n  set(NCBI_COMPONENT_TIFF_FOUND NO)\nendif()\n\n#############################################################################\n# XML\nif(LIBXML2_FOUND)\n  set(NCBI_COMPONENT_XML_FOUND YES)\n  set(NCBI_COMPONENT_XML_INCLUDE ${LIBXML_INCLUDE})\n  set(NCBI_COMPONENT_XML_LIBS ${LIBXML_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} XML\")\nelse()\n  set(NCBI_COMPONENT_XML_FOUND NO)\nendif()\n\n#############################################################################\n# XSLT\n# EXSLT\nif(LIBXSLT_FOUND)\n  set(NCBI_COMPONENT_XSLT_FOUND YES)\n  set(NCBI_COMPONENT_XSLT_INCLUDE ${LIBXSLT_INCLUDE})\n  set(NCBI_COMPONENT_XSLT_LIBS ${LIBXSLT_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} XSLT\")\n\n  set(NCBI_COMPONENT_EXSLT_FOUND YES)\n  set(NCBI_COMPONENT_EXSLT_INCLUDE ${LIBEXSLT_INCLUDE})\n  set(NCBI_COMPONENT_EXSLT_LIBS ${LIBEXSLT_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} EXSLT\")\nelse()\n  set(NCBI_COMPONENT_XSLT_FOUND NO)\n  set(NCBI_COMPONENT_EXSLT_FOUND NO)\nendif()\n\n#############################################################################\n# XLSXWRITER\nif (LIBXLSXWRITER_FOUND)\n  set(NCBI_COMPONENT_XLSXWRITER_FOUND YES)\n  set(NCBI_COMPONENT_XLSXWRITER_INCLUDE ${LIBXLSXWRITER_INCLUDE})\n  set(NCBI_COMPONENT_XLSXWRITER_LIBS ${LIBXLSXWRITER_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} XLSXWRITER\")\nendif()\n\n#############################################################################\n#SQLITE3\nif(SQLITE3_FOUND)\n  set(NCBI_COMPONENT_SQLITE3_FOUND YES)\n  set(NCBI_COMPONENT_SQLITE3_INCLUDE ${SQLITE3_INCLUDE})\n  set(NCBI_COMPONENT_SQLITE3_LIBS ${SQLITE3_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} SQLITE3\")\nelse()\n  set(NCBI_COMPONENT_SQLITE3_FOUND NO)\nendif()\n\n#############################################################################\n#LAPACK\nif(LAPACK_FOUND)\n  set(NCBI_COMPONENT_LAPACK_FOUND YES)\n  set(NCBI_COMPONENT_LAPACK_INCLUDE ${LAPACK_INCLUDE})\n  set(NCBI_COMPONENT_LAPACK_LIBS ${LAPACK_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} LAPACK\")\nelse()\n  set(NCBI_COMPONENT_LAPACK_FOUND NO)\nendif()\n\n#############################################################################\n# Sybase\nif(SYBASE_FOUND)\n  set(NCBI_COMPONENT_Sybase_FOUND YES)\n  set(NCBI_COMPONENT_Sybase_INCLUDE ${SYBASE_INCLUDE})\n  set(NCBI_COMPONENT_Sybase_LIBS    ${SYBASE_LIBS})\n  set(NCBI_COMPONENT_Sybase_DEFINES SYB_LP64)\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} Sybase\")\nelse()\n  set(NCBI_COMPONENT_Sybase_FOUND NO)\nendif()\n\n#############################################################################\n# MySQL\nif(MYSQL_FOUND)\n  set(NCBI_COMPONENT_MySQL_FOUND YES)\n  set(NCBI_COMPONENT_MySQL_INCLUDE ${MYSQL_INCLUDE})\n  set(NCBI_COMPONENT_MySQL_LIBS    ${MYSQL_LIBS})\nelse()\n  set(NCBI_COMPONENT_MySQL_FOUND NO)\nendif()\n\n#############################################################################\n# ODBC\nif(ODBC_FOUND)\n  set(NCBI_COMPONENT_ODBC_FOUND YES)\n  set(NCBI_COMPONENT_ODBC_INCLUDE ${ODBC_INCLUDE})\n  set(NCBI_COMPONENT_ODBC_LIBS    ${ODBC_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} ODBC\")\nelse()\n  set(NCBI_COMPONENT_ODBC_FOUND NO)\nendif()\n\n#############################################################################\n# VDB\nif(VDB_FOUND)\n  set(NCBI_COMPONENT_VDB_FOUND YES)\n  set(NCBI_COMPONENT_VDB_INCLUDE ${VDB_INCLUDE})\n  set(NCBI_COMPONENT_VDB_LIBS    ${VDB_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} VDB\")\nelse()\n  set(NCBI_COMPONENT_VDB_FOUND NO)\nendif()\n\n#############################################################################\n# SAMTOOLS\nif(SAMTOOLS_FOUND)\n  set(NCBI_COMPONENT_SAMTOOLS_FOUND YES)\n  set(NCBI_COMPONENT_SAMTOOLS_INCLUDE ${SAMTOOLS_INCLUDE})\n  set(NCBI_COMPONENT_SAMTOOLS_LIBS    ${SAMTOOLS_LIBS})\n#  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} SAMTOOLS\")\nelse()\n  set(NCBI_COMPONENT_SAMTOOLS_FOUND NO)\nendif()\n\n#############################################################################\n# PYTHON\nset(NCBI_COMPONENT_PYTHON_FOUND NO)\n\n#############################################################################\n# OpenSSL\nif (OpenSSL_FOUND)\n  set(NCBI_COMPONENT_OpenSSL_FOUND YES)\n  set(NCBI_COMPONENT_OpenSSL_INCLUDE ${OpenSSL_INCLUDE})\n  set(NCBI_COMPONENT_OpenSSL_LIBS    ${OPENSSL_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} OpenSSL\")\nelse()\n  set(NCBI_COMPONENT_OpenSSL_FOUND NO)\nendif()\n\n#############################################################################\n# MSGSL\nif(HAVE_MSGSL)\n  set(NCBI_COMPONENT_MSGSL_FOUND YES)\n  set(NCBI_COMPONENT_MSGSL_INCLUDE ${MSGSL_INCLUDE})\nendif()\n\n#############################################################################\n# SGE\nif (SGE_FOUND)\n  set(NCBI_COMPONENT_SGE_FOUND YES)\n  set(NCBI_COMPONENT_SGE_INCLUDE ${SGE_INCLUDE})\n  set(NCBI_COMPONENT_SGE_LIBS    ${SGE_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} SGE\")\nendif()\n\n#############################################################################\n# MONGOCXX\nif (MONGOCXX_FOUND)\n  set(NCBI_COMPONENT_MONGOCXX_FOUND YES)\n  set(NCBI_COMPONENT_MONGOCXX_INCLUDE ${MONGOCXX_INCLUDE})\n  set(NCBI_COMPONENT_MONGOCXX_LIBS    ${MONGOCXX_LIB})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} MONGOCXX\")\nendif()\n\n#############################################################################\n# LEVELDB\nif (LEVELDB_FOUND)\n  set(NCBI_COMPONENT_LEVELDB_FOUND YES)\n#  set(NCBI_COMPONENT_LEVELDB_INCLUDE ${LEVELDB_INCLUDE})\n  set(NCBI_COMPONENT_LEVELDB_LIBS    ${LEVELDB_LIBRARIES})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} LEVELDB\")\nendif()\n\n#############################################################################\n# WGMLST\nif (WGMLST_FOUND)\n  set(NCBI_COMPONENT_WGMLST_FOUND YES)\n  set(NCBI_COMPONENT_WGMLST_INCLUDE ${WGMLST_INCLUDE})\n  set(NCBI_COMPONENT_WGMLST_LIBS    ${WGMLST_LIB})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} WGMLST\")\nendif()\n\n#############################################################################\n# GLPK\nif(GLPK_FOUND)\n  set(NCBI_COMPONENT_GLPK_FOUND YES)\n  set(NCBI_COMPONENT_GLPK_INCLUDE ${GLPK_INCLUDE})\n  set(NCBI_COMPONENT_GLPK_LIBS    ${GLPK_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} GLPK\")\nendif()\n\n#############################################################################\n# XALAN\nif (XALAN_FOUND)\n  set(NCBI_COMPONENT_XALAN_FOUND YES)\n  set(NCBI_COMPONENT_XALAN_INCLUDE ${XALAN_INCLUDE})\n  set(NCBI_COMPONENT_XALAN_LIBS    ${XALAN_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} XALAN\")\nendif()\n\n#############################################################################\n# XERCES\nif (XERCES_FOUND)\n  set(NCBI_COMPONENT_XERCES_FOUND YES)\n  set(NCBI_COMPONENT_XERCES_INCLUDE ${XERCES_INCLUDE})\n  set(NCBI_COMPONENT_XERCES_LIBS    ${XERCES_LIBS})\n  set(NCBI_ALL_COMPONENTS \"${NCBI_ALL_COMPONENTS} XERCES\")\nendif()\n\n##############################################################################\n# FTGL\nif (FTGL_FOUND)\n  set(NCBI_COMPONENT_FTGL_FOUND   YES)\n  set(NCBI_COMPONENT_FTGL_INCLUDE ${FTGL_INCLUDE_DIR})\n  set(NCBI_COMPONENT_FTGL_LIBS    ${FTGL_LIBRARIES})\nendif()\n\n##############################################################################\n# FreeType\nif (FREETYPE_FOUND)\n  set(NCBI_COMPONENT_FreeType_FOUND   YES)\n  set(NCBI_COMPONENT_FreeType_INCLUDE ${FREETYPE_INCLUDE_DIRS})\n  set(NCBI_COMPONENT_FreeType_LIBS    ${FREETYPE_LIBRARIES})\nendif()\n\n#############################################################################\n# GLEW\nset(NCBI_COMPONENT_GLEW_FOUND   YES)\nset(NCBI_COMPONENT_GLEW_INCLUDE ${GLEW_INCLUDE_DIRS})\nset(NCBI_COMPONENT_GLEW_LIBS    ${GLEW_LIBRARIES})\n\n##############################################################################\n# OpenGL\nset(NCBI_COMPONENT_OpenGL_FOUND   YES)\nset(NCBI_COMPONENT_OpenGL_INCLUDE ${OPENGL_INCLUDE_DIRS})\nset(NCBI_COMPONENT_OpenGL_LIBS    ${OPENGL_LIBRARIES})\n\n##############################################################################\n# OSMesa\nset(NCBI_COMPONENT_OSMesa_FOUND   YES)\nset(NCBI_COMPONENT_OSMesa_INCLUDE ${OSMesa_INCLUDE_DIRS})\nset(NCBI_COMPONENT_OSMesa_LIBS    ${OSMesa_LIBRARIES})\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/include/corelib/ncbidll.hpp": "#ifndef CORELIB___NCBIDLL__HPP\n#define CORELIB___NCBIDLL__HPP\n\n/*  $Id: ncbidll.hpp 572204 2018-10-10 14:43:17Z ivanov $\n * ===========================================================================\n *\n *                            PUBLIC DOMAIN NOTICE\n *               National Center for Biotechnology Information\n *\n *  This software/database is a \"United States Government Work\" under the\n *  terms of the United States Copyright Act.  It was written as part of\n *  the author's official duties as a United States Government employee and\n *  thus cannot be copyrighted.  This software/database is freely available\n *  to the public for use. The National Library of Medicine and the U.S.\n *  Government have not placed any restriction on its use or reproduction.\n *\n *  Although all reasonable efforts have been taken to ensure the accuracy\n *  and reliability of the software and data, the NLM and the U.S.\n *  Government do not and cannot warrant the performance or results that\n *  may be obtained by using this software or data. The NLM and the U.S.\n *  Government disclaim all warranties, express or implied, including\n *  warranties of performance, merchantability or fitness for any particular\n *  purpose.\n *\n *  Please cite the author in any work or product based on this material.\n *\n * ===========================================================================\n *\n * Author:  Denis Vakatov, Vladimir Ivanov, Anatoliy Kuznetsov\n *\n *\n */\n\n/// @file ncbidll.hpp\n/// Define class Dll and for Portable DLL handling.\n\n\n#include <corelib/ncbistd.hpp>\n#include <corelib/ncbicfg.h>\n#include <corelib/ncbifile.hpp>\n\n\nBEGIN_NCBI_SCOPE\n\n/** @addtogroup Dll\n *\n * @{\n */\n\n\n// Forward declaration of struct containing OS-specific DLL handle.\nstruct SDllHandle;\n\n\n#ifndef NCBI_PLUGIN_SUFFIX\n#  ifdef NCBI_OS_MSWIN\n#    define NCBI_PLUGIN_PREFIX \"\"\n#    define NCBI_PLUGIN_MIN_SUFFIX \".dll\"\n#  elif defined(NCBI_OS_DARWIN)  &&  !defined(NCBI_USE_BUNDLES)\n#    define NCBI_PLUGIN_PREFIX \"lib\"\n#    define NCBI_PLUGIN_MIN_SUFFIX \".dylib\"\n#  else\n#    define NCBI_PLUGIN_PREFIX \"lib\"\n#    define NCBI_PLUGIN_MIN_SUFFIX \".so\"\n#  endif\n#  if defined(NCBI_DLL_BUILD)  ||  defined(NCBI_OS_MSWIN)\n#    define NCBI_PLUGIN_SUFFIX NCBI_PLUGIN_MIN_SUFFIX\n#  else\n#    define NCBI_PLUGIN_SUFFIX \"-dll\" NCBI_PLUGIN_MIN_SUFFIX\n#  endif\n#endif\n\n\n/////////////////////////////////////////////////////////////////////////////\n///\n/// CDll --\n///\n/// Define class for portable Dll handling.\n///\n/// The DLL name is considered the basename if it does not contain embedded\n/// '/', '\\', or ':' symbols. Also, in this case, if the DLL name does not\n/// start with NCBI_PLUGIN_PREFIX and contain NCBI_PLUGIN_MIN_SUFFIX (and if\n/// eExactName flag not passed to the constructor), then it will be\n/// automatically transformed according to the following rule:\n///   <name>  --->  NCBI_PLUGIN_PREFIX + <name> + NCBI_PLUGIN_SUFFIX\n///\n///  If the DLL is specified by its basename, then it will be searched\n///  (after the transformation described above) in the following locations:\n///\n///    UNIX:\n///      1) the directories that are listed in the LD_LIBRARY_PATH environment\n///         variable (analyzed once at the process startup);\n///      2) the directory from which the application loaded;\n///      3) hard-coded (e.g. with `ldconfig' on Linux) paths.\n///\n///    MS Windows:\n///      1) the directory from which the application is loaded;\n///      2) the current directory; \n///      3) the Windows system directory;\n///      4) the Windows directory;\n///      5) the directories that are listed in the PATH environment variable.\n///\n/// NOTE: All methods of this class except the destructor throw exception\n/// CCoreException::eDll on error.\n\nclass CDll\n{\npublic:\n    /// General flags.\n    ///\n    /// Default flag in each group have priority above non-default,\n    /// if they are used together.\n    enum EFlags {\n        /// When to load DLL\n        fLoadNow      = (1<<1),  ///< Load DLL immediately in the constructor\n        fLoadLater    = (1<<2),  ///< Load DLL later, using method Load()\n        /// Whether to unload DLL in the destructor\n        fAutoUnload   = (1<<3),  ///< Unload DLL in the destructor\n        fNoAutoUnload = (1<<4),  ///< Unload DLL later, using method Unload()\n        /// Whether to transform the DLL basename\n        fBaseName     = (1<<5),  ///< Treat the name as DLL basename\n        fExactName    = (1<<6),  ///< Use the name \"as is\"\n        /// Specify how to load symbols from DLL.\n        /// UNIX specific (see 'man dlopen'), ignored on all other platforms.\n        fGlobal       = (1<<7),  ///< Load as RTLD_GLOBAL\n        fLocal        = (1<<8),  ///< Load as RTLD_LOCAL\n        /// Default flags\n        fDefault      = fLoadNow | fNoAutoUnload | fBaseName | fGlobal\n    };\n    typedef unsigned int TFlags;  ///< Binary OR of \"EFlags\"\n\n    //\n    // Enums, retained for backward compatibility\n    //\n\n    /// When to load DLL.\n    enum ELoad {\n        eLoadNow      = fLoadNow,\n        eLoadLater    = fLoadLater\n    };\n\n    /// Whether to unload DLL in the destructor.\n    enum EAutoUnload {\n        eAutoUnload   = fAutoUnload,\n        eNoAutoUnload = fNoAutoUnload\n    };\n\n    /// Whether to transform the DLL basename.\n    ///\n    /// Transformation is done according to the following:\n    ///   <name>  --->  NCBI_PLUGIN_PREFIX + <name> + NCBI_PLUGIN_SUFFIX\n    enum EBasename {\n        eBasename     = fBaseName,\n        eExactName    = fExactName\n    };\n\n    /// Constructor.\n    ///\n    /// @param name\n    ///   Can be either DLL basename or an absolute file path.\n    /// @param flags\n    ///   Define how to load/unload DLL and interpret passed name.\n    /// @sa\n    ///   Basename discussion in CDll header, EFlags\n    NCBI_XNCBI_EXPORT\n    CDll(const string& name, TFlags flags);\n\n    /// Constructor (for backward compatibility).\n    ///\n    /// @param name\n    ///   Can be either DLL basename or an absolute file path.\n    /// @param when_to_load\n    ///   Choice to load now or later using Load().\n    /// @param auto_unload\n    ///   Choice to unload DLL in destructor.\n    /// @param treat_as\n    ///   Choice to transform the DLL base name.\n    /// @sa\n    ///   Basename discussion in CDll header,\n    ///   ELoad, EAutoUnload, EBasename definition.\n    NCBI_XNCBI_EXPORT\n    CDll(const string& name,\n         ELoad         when_to_load = eLoadNow,\n         EAutoUnload   auto_unload  = eNoAutoUnload,\n         EBasename     treate_as    = eBasename);\n\n    /// Constructor.\n    ///\n    /// The absolute file path to the DLL will be formed using the \"path\"\n    /// and \"name\" parameters in the following way:\n    /// - UNIX:   <path>/PFX<name>SFX ; <path>/<name> if \"name\" is not basename\n    /// - MS-Win: <path>\\PFX<name>SFX ; <path>\\<name> if \"name\" is not basename\n    /// where PFX is NCBI_PLUGIN_PREFIX and SFX is NCBI_PLUGIN_SUFFIX.\n    ///\n    /// @param path\n    ///   Path to DLL.\n    /// @param name\n    ///   Name of DLL.\n    /// @param flags\n    ///   Define how to load/unload DLL and interpret passed name.\n    /// @sa\n    ///   Basename discussion in CDll header, EFlags\n    NCBI_XNCBI_EXPORT\n    CDll(const string& path, const string& name, TFlags flags);\n\n    /// Constructor (for backward compatibility).\n    ///\n    /// The absolute file path to the DLL will be formed using the \"path\"\n    /// and \"name\" parameters in the following way:\n    /// - UNIX:   <path>/PFX<name>SFX ; <path>/<name> if \"name\" is not basename\n    /// - MS-Win: <path>\\PFX<name>SFX ; <path>\\<name> if \"name\" is not basename\n    /// where PFX is NCBI_PLUGIN_PREFIX and SFX is NCBI_PLUGIN_SUFFIX.\n    ///\n    /// @param path\n    ///   Path to DLL.\n    /// @param name\n    ///   Name of DLL.\n    /// @param when_to_load\n    ///   Choice to load now or later using Load().\n    /// @param auto_load\n    ///   Choice to unload DLL in destructor.\n    /// @param treat_as\n    ///   Choice to transform the DLL base name.\n    /// @sa\n    ///   Basename discussion in CDll header,\n    ///   ELoad, EAutoUnload, EBasename definition.\n    NCBI_XNCBI_EXPORT\n    CDll(const string& path, const string& name,\n         ELoad         when_to_load = eLoadNow,\n         EAutoUnload   auto_unload  = eNoAutoUnload,\n         EBasename     treate_as    = eBasename);\n\n    /// Destructor.\n    ///\n    /// Unload DLL if constructor was passed \"eAutoUnload\".\n    /// Destructor does not throw any exceptions.\n    NCBI_XNCBI_EXPORT ~CDll(void);\n\n    /// Load DLL.\n    ///\n    /// Load the DLL using the name specified in the constructor's DLL \"name\".\n    /// If Load() is called more than once without calling Unload() in between,\n    /// then it will do nothing.\n    ///\n    /// @note If the DLL links against the core \"xncbi\" library, loading it may\n    /// result in reinvoking static initializers, with potential consequences\n    /// ranging from having to retune diagnostic settings to crashing at exit.\n    /// This problem could theoretically also affect other libraries linked\n    /// from both sides, but they haven't been an issue in practice.  It can\n    /// help for both the program and the DLL to link \"xncbi\" dynamically, but\n    /// in some configurations that change still isn't entirely sufficient.  As\n    /// such, on affected platforms, the C++ Toolkit's build system arranges to\n    /// filter \"xncbi\" out of the relevant makefile settings unless\n    /// specifically directed otherwise via KEEP_CORELIB = yes (which can be\n    /// useful when building plugins for third-party applications such as\n    /// scripting languages).\n    NCBI_XNCBI_EXPORT void Load(void);\n\n    /// Unload DLL.\n    ///\n    /// Do nothing and do not generate errors if the DLL is not loaded.\n    NCBI_XNCBI_EXPORT void Unload(void);\n\n    /// Get DLLs entry point (function).\n    ///\n    /// Get the entry point (a function) with name \"name\" in the DLL and\n    /// return the entry point's address on success, or return NULL on error.\n    /// If the DLL is not loaded yet, then this method will call Load(),\n    /// which can result in throwing an exception if Load() fails.\n    /// @sa\n    ///   GetEntryPoint_Data\n    template <class TFunc>\n    TFunc GetEntryPoint_Func(const string& name, TFunc* func)\n    {\n        TEntryPoint ptr = GetEntryPoint(name);\n        if ( func ) {\n            *func = (TFunc)(void*)ptr.func; \n        }\n        return (TFunc)(void*)ptr.func;\n    }\n\n    /// Get DLLs entry point (data).\n    ///\n    /// Get the entry point (a data) with name \"name\" in the DLL and\n    /// return the entry point's address on success, or return NULL on error.\n    /// If the DLL is not loaded yet, then this method will call Load(),\n    /// which can result in throwing an exception if Load() fails.\n    /// @sa\n    ///   GetEntryPoint_Func\n    template <class TData>\n    TData GetEntryPoint_Data(const string& name, TData* data)\n    {\n        TEntryPoint ptr = GetEntryPoint(name);\n        if ( data ) {\n            *data = static_cast<TData> (ptr.data); \n        }\n        return static_cast<TData> (ptr.data);\n    }\n\n    /// Fake, uncallable function pointer\n    typedef void (*FEntryPoint)(char**** Do_Not_Call_This);\n\n    /// Entry point -- pointer to either a function or a data\n    union TEntryPoint {\n        FEntryPoint func;  ///< Do not call this func without type cast!\n        void*       data;\n    };\n\n    /// Helper find method for getting a DLLs entry point.\n    ///\n    /// Get the entry point (e.g. a function) with name \"name\" in the DLL.\n    /// @param name\n    ///   Name of DLL.\n    /// @param pointer_size\n    ///   Size of pointer.\n    /// @return\n    ///   The entry point's address on success, or return NULL on error.\n    /// @sa\n    ///   GetEntryPoint_Func, GetEntryPoint_Data\n    NCBI_XNCBI_EXPORT\n    TEntryPoint GetEntryPoint(const string& name);\n\n    /// Get the name of the DLL file \n    NCBI_XNCBI_EXPORT\n    const string& GetName() const { return m_Name; }\n\nprivate:\n    /// Helper method to throw exception with system-specific error message.\n    NCBI_NORETURN\n    void  x_ThrowException(const string& what);\n\n    /// Helper method to initialize object.\n    ///\n    /// Called from constructor.\n    /// @param path\n    ///   Path to DLL.\n    /// @param name\n    ///   Name of DLL.\n    /// @param when_to_load\n    ///   Choice to load now or later using Load().\n    /// @param auto_load\n    ///   Choice to unload DLL in destructor.\n    /// @param treat_as\n    ///   Choice to transform the DLL base name.\n    /// @sa\n    ///   EFlags \n    void  x_Init(const string& path, const string& name, TFlags flags);\n\nprotected:\n    /// Private copy constructor to prohibit copy.\n    CDll(const CDll&);\n\n    /// Private assignment operator to prohibit assignment.\n    CDll& operator= (const CDll&);\n\nprivate:\n    string      m_Name;     ///< DLL name\n    SDllHandle* m_Handle;   ///< DLL handle\n    TFlags      m_Flags;    ///< Flags\n};\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n///\n/// Class for entry point resolution when there are several DLL candidates.\n///\n/// If Dll resolver finds DLL with the specified entry point it is\n/// stored in the internal list (provided by GetResolvedEntries method).\n/// All DLL libraries are unloaded upon resolver's destruction.\n///\nclass CDllResolver\n{\npublic:\n\n    /// DLL entry point name -> function pair\n    struct SNamedEntryPoint\n    {\n        string             name;          ///< Entry point name\n        CDll::TEntryPoint  entry_point;   ///< DLL entry point\n\n        SNamedEntryPoint(const string& x_name, CDll::TEntryPoint x_entry_point)\n            : name(x_name)\n        {\n            entry_point.data = x_entry_point.data;\n        }\n    };\n\n    /// DLL resolution descriptor.\n    /// Storage only. DLLs will be unloaded in the ~CDLLRelolver(), and memory freed.\n    struct SResolvedEntry\n    {\n        CDll*                     dll;           ///< Loaded DLL instance\n        vector<SNamedEntryPoint>  entry_points;  ///< list of DLL entry points\n\n        SResolvedEntry(CDll* dll_ptr = 0)\n            : dll(dll_ptr)\n        {}\n    };\n\n    /// Container, keeps list of all resolved entry points.\n    typedef vector<SResolvedEntry>  TEntries;\n\n\n    /// Constructor.\n    ///\n    /// @param entry_point_name\n    ///   Name of the DLL entry point.\n    /// @param unload\n    ///   Whether to unload loaded DLLs in the destructor\n    NCBI_XNCBI_EXPORT CDllResolver(const string& entry_point_name, \n                                   CDll::EAutoUnload unload = CDll::eAutoUnload);\n\n    /// Constructor.\n    ///\n    /// @param entry_point_names\n    ///   List of alternative DLL entry points.\n    /// @param unload\n    ///   Whether to unload loaded DLLs in the destructor\n    NCBI_XNCBI_EXPORT CDllResolver(const vector<string>& entry_point_names,\n                                   CDll::EAutoUnload unload = CDll::eAutoUnload); \n\n    /// Destructor.\n    NCBI_XNCBI_EXPORT ~CDllResolver();\n\n    /// Try to load DLL from the specified file and resolve the entry point.\n    ///\n    /// If DLL resolution successfully loaded entry point is registered in the\n    /// internal list of resolved entries.\n    ///\n    /// @param file_name\n    ///   Name of the DLL file. Can be full name with path of the base name.\n    /// @param driver_name\n    ///   Name of the driver (substitute for ${driver} macro)\n    /// @return\n    ///   TRUE if DLL is successfully loaded and entry point resolved.\n    /// @sa\n    ///   GetResolvedEntries\n    NCBI_XNCBI_EXPORT \n    bool TryCandidate(const string& file_name,\n                      const string& driver_name = kEmptyStr);\n\n    /// Try to resolve file candidates.\n    ///\n    /// @param candidates\n    ///    Container with file names to try.\n    /// @param driver_name\n    ///    Driver name\n    /// @sa\n    ///   GetResolvedEntries\n    template<class TClass>\n    void Try(const TClass& candidates, const string& driver_name = kEmptyStr)\n    {\n        typename TClass::const_iterator it = candidates.begin();\n        typename TClass::const_iterator it_end = candidates.end();\n        for (; it != it_end; ++it) {\n            TryCandidate(*it, driver_name);\n        }\n    }\n\n    /// Various (usually system-dependent) standard paths to look for DLLs in.\n    /// The fProgramPath flag works only inside CNcbiApplication framework.\n    /// @sa\n    ///   x_AddExtraDllPath, FindCandidates\n    enum EExtraDllPath {\n        fNoExtraDllPath = 0,        //< Do not add\n        fProgramPath    = 1 << 0,   //< Path to executable file\n        fToolkitDllPath = 1 << 1,   //< Toolkit paths\n        fSystemDllPath  = 1 << 2,   //< System paths\n        fDefaultDllPath = fProgramPath | fToolkitDllPath | fSystemDllPath\n    };\n\n    typedef int TExtraDllPath;      //<  bitwise OR of \"EExtraDllPath\"\n\n    /// Try to resolve all files matching the specified masks in the\n    /// specified directories.\n    ///\n    /// @param paths\n    ///   Container with directory names.\n    /// @param masks\n    ///   Container with file candidate masks.\n    /// @param extra_path\n    ///   Extra \"standard\" paths to search the DLLs in\n    /// @sa\n    ///   GetResolvedEntries, x_AddExtraDllPath\n    template<class TClass1, class TClass2>\n    void FindCandidates(const TClass1& paths, const TClass2& masks,\n                        TExtraDllPath extra_path = fDefaultDllPath,\n                        const string& driver_name = kEmptyStr)\n    {\n        // search in the explicitly specified paths\n        vector<string> x_path(paths);\n        // search in \"standard\" paths, if any specified by 'extra_path' flag\n        x_AddExtraDllPath(x_path, extra_path);\n        // remove duplicate dirs\n        vector<string> x_path_unique;\n        x_path_unique.reserve(x_path.size());\n#if defined(NCBI_OS_MSWIN)\n        NStr::ECase use_case = NStr::eNocase;\n#else\n        NStr::ECase use_case = NStr::eCase;\n#endif\n        ITERATE(vector<string>, it, x_path) {\n            bool found = false;\n            ITERATE(vector<string>, i, x_path_unique) {\n                if ( NStr::Compare(*i, *it, use_case) == 0 ) {\n                    found = true;\n                    break;\n                }\n            }\n            if ( !found ) {\n                x_path_unique.push_back(CDir::DeleteTrailingPathSeparator(*it));\n            }\n        }\n\n        // find files\n        vector<string> candidates;\n        FindFiles(candidates,\n                  x_path_unique.begin(), x_path_unique.end(),\n                  masks.begin(), masks.end(),\n                  fFF_File);\n        // try to resolve entry points in the found DLLs\n        Try(candidates, driver_name);\n    }\n\n    /// Get all resolved entry points.\n    NCBI_XNCBI_EXPORT \n    const TEntries& GetResolvedEntries() const \n    { \n        return m_ResolvedEntries; \n    }\n\n    /// Get all resolved entry points.\n    NCBI_XNCBI_EXPORT\n    TEntries& GetResolvedEntries() \n    { \n        return m_ResolvedEntries; \n    }\n\n    /// Unload all resolved DLLs.\n    NCBI_XNCBI_EXPORT void Unload();\n\nprivate:\n    CDllResolver(const CDllResolver&);\n    CDllResolver& operator=(const CDllResolver&);\n\n    /// Get the DLL search paths related to the given standard path group\n    ///\n    /// @param paths\n    ///   Container to add the requested DLL search paths to.\n    /// @param which\n    ///   Which \"standard\" paths to add.\n    /// @sa\n    ///   FindCandidates\n    NCBI_XNCBI_EXPORT\n    void x_AddExtraDllPath(vector<string>& paths, TExtraDllPath which);\n\nprotected:\n    vector<string>     m_EntryPoinNames;   ///< Candidate entry points\n    TEntries           m_ResolvedEntries;\n    CDll::EAutoUnload  m_AutoUnloadDll;\n};\n\n/* @} */\n\n\nEND_NCBI_SCOPE\n\n#endif  /* CORELIB___NCBIDLL__HPP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/common/check/valgrind.supp": "# $Id: valgrind.supp 539779 2017-06-27 16:03:53Z mcelhany $\n#\n# Valgrind suppression file (version 3.5.0 -> 3.11.0).\n#\n################################################################################\n#\n# Format of this file is:\n# {\n#     name_of_suppression\n#     tool_name:supp_kind\n#     (optional extra info for some suppression types)\n#     caller0 name, or /name/of/so/file.so\n#     caller1 name, or ditto\n#     (optionally: caller2 name)\n#     (optionally: caller3 name)\n#  }\n#\n# For Memcheck, the supp_kinds are:\n#\n#     Param Value1 Value2 Value4 Value8 Value16\n#     Free Addr1 Addr2 Addr4 Addr8 Addr16\n#     Cond (previously known as Value0)\n#\n# and the optional extra info is:\n#     if Param: name of system call param\n#     if Free: name of free-ing fn)\n#\n################################################################################\n#\n# NOTE: C++ function names must be mangled.\n#       Use --gen-suppressions=all option to generate rules.\n#\n################################################################################\n\n\n#{\n#   NCBI VDB ver 2.5.0 -- uninit value created on stack, passed around\n#   Memcheck:Param\n#   fun:__open_nocancel\n#   fun:KSysDirOpenFileRead_v1 (sysdir.c:1838)\n#}\n\n\n{\n   GnuTLS/Nettle -- apparent optimization shortcut\n   Memcheck:Addr8\n   fun:__gmpn_copyi_core2\n   fun:__gmpn_powm\n   fun:__gmpz_powm\n   fun:nettle_rsa_compute_root\n   fun:nettle_rsa_pkcs1_sign_tr\n   fun:_wrap_nettle_pk_sign\n   fun:gnutls_privkey_sign_data\n   fun:_gnutls_check_key_cert_match\n   fun:gnutls_certificate_set_x509_key\n   fun:gnutls_certificate_set_x509_simple_pkcs12_mem\n   fun:gnutls_certificate_set_x509_simple_pkcs12_file\n}\n\n{\n   NCBI VDB ver 2.5.0 -- uninit value created on stack in string_vprintf (printf.c:3374)\n   Memcheck:Cond\n   ...\n   fun:add_aws_nodes\n}\n\n\n{\n    corelib/CFileUtil::GetTotalDiskSpace, PANFS, CXX-5713 because DLL is not supposed to be closed\n    Memcheck:Leak\n    fun:malloc\n    ...\n    fun:_dl_open\n    ...\n    fun:*s_GetDiskSpace_PANFS*\n    fun:*s_GetFileSystemInfo*\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_fill\n   fun:__log_putr\n   ...\n   fun:__log_put\n   fun:__txn_regop_log\n   fun:__txn_commit\n   fun:__txn_commit_pp\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_ovput() in bt_put.c:886\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_fill\n   fun:__log_putr\n   ...\n   fun:__log_put\n   fun:__db_big_log\n   fun:__db_poff\n   ...\n   fun:__bam_iitem\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 3)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__memp_pgwrite\n   fun:__memp_bhwrite\n   fun:__memp_sync_int\n   ...\n   fun:__db_sync\n   fun:__db_refresh\n   fun:__db_close\n   fun:__db_close_pp\n   fun:_ZN4ncbi12CBDB_RawFile7x_CloseENS0_12EIgnoreErrorE\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 2b)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__memp_pgwrite\n   fun:__memp_bhwrite\n   fun:__memp_sync_int\n   ...\n   fun:__memp_trickle_pp\n   fun:_ZN4ncbi8CBDB_Env11MempTrickleEiPi\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 2a)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_flush_int\n   fun:__log_flush\n   ...\n   fun:__memp_sync_int\n   ...\n   fun:__memp_trickle_pp\n   fun:_ZN4ncbi8CBDB_Env11MempTrickleEiPi\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 1e)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_fill\n   fun:__log_putr\n   ...\n   fun:__log_put\n   fun:__db_addrem_log\n   fun:__db_pitem\n   fun:__bam_iitem\n   fun:__bamc_put\n   fun:__dbc_put\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 1d)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_fill\n   fun:__log_putr\n   ...\n   fun:__log_put\n   fun:__bam_repl_log\n   fun:__bam_ritem\n   fun:__bam_iitem\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__dbc_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile9x_DB_CPutEP5__dbcP8__db_dbtS4_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 1c)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_flush_int\n   ...\n   fun:__log_put\n   ...\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack (Variant 1b5)\n   Memcheck:Param\n   pwrite64(buf)\n   ...\n   fun:__os_io\n   fun:__log_write\n   fun:__log_fill\n   fun:__log_putr\n   ...\n   fun:__log_put\n   ...\n   fun:__bam_split\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack (Variant 1b4)\n   Memcheck:Cond\n   fun:__log_putr\n   ...\n   fun:__log_put\n   fun:__bam_split_log\n   ...\n   fun:__bam_split\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack (Variant 1b3)\n   Memcheck:Cond\n\n   fun:__log_putr\n   fun:__log_put\n   fun:__db_addrem_log\n   ...\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack (Variant 1b2)\n   Memcheck:Cond\n   fun:__log_putr\n   fun:__log_put\n   fun:__db_addrem_log\n   fun:__db_pitem\n   fun:__bam_iitem\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack (Variant 1b1)\n   Memcheck:Cond\n   fun:__log_putr\n   fun:__log_put_next\n   fun:__log_put\n   fun:__db_addrem_log\n   fun:__db_pitem\n   fun:__bam_ovput\n   fun:__bam_iitem\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- uninit value created on stack in __bam_broot() in bt_split.c:519 (Variant 1a)\n   Memcheck:Cond\n   fun:__log_putr\n   fun:__log_put_next\n   fun:__log_put\n   fun:__db_addrem_log\n   fun:__db_pitem\n   fun:__bam_broot\n   fun:__bam_root\n   fun:__bam_split\n   fun:__bamc_put\n   fun:__dbc_put\n   fun:__db_put\n   fun:__db_put_pp\n   fun:_ZN4ncbi12CBDB_RawFile8x_DB_PutEP8__db_dbtS2_j\n}\n\n{\n   Known LIBC bug (https://bugs.kde.org/show_bug.cgi?id=167483)\n   Memcheck:Free\n   fun:free\n   fun:free_mem\n   fun:__libc_freeres\n   fun:_vgnU_freeres\n   fun:exit\n   fun:(below main)\n}\n\n{\n   MemCpy to itself in swap() in CObject  (ICC 10.1)\n   Memcheck:Overlap\n   fun:memcpy\n   fun:_ZSt4swapISt4pairIPvjEEvRT_S4_\n   fun:_ZN4ncbi24sx_PopLastNewPtrMultipleEPv\n   fun:_ZN4ncbi16sx_PopLastNewPtrEPv\n   fun:_ZN4ncbi7CObject11InitCounterEv\n}\n\n{\n   Sybase CTLIB 15.7-SP122-64bit (Case 1)\n   Memcheck:Addr1\n   fun:com_secure_memset\n   fun:ct__tds_loginover\n   fun:ct_async_exec_stack\n   fun:ct_connect\n}\n\n{\n   Sybase DBLIB 15.7-SP122-64bit (Case 2)\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:sybsoc_write\n   fun:sybnet_write\n   fun:write_buffer\n   fun:sendflush\n   fun:sendeom\n   fun:bcp__endbatch\n   fun:bcp_done\n}\n\n{\n   Sybase DBLIB 12.5.1.10-ESD26-64bit (case 1)\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   fun:syb_tcp_write\n   fun:sendflush\n   fun:sendeom\n   fun:bcp__endbatch\n   fun:bcp_done\n}\n\n{\n   Sybase DBLIB 12.5.1.10-ESD26-64bit (case 2)\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   fun:syb_tcp_write\n   fun:sendflush\n   fun:sendserver\n   fun:bcp__send_text\n   fun:bcp_moretext\n}\n\n\n{\n   Sybase DBLIB 12.5.1.10-ESD26-64bit (case 3)\n   Memcheck:Param\n   write(buf)\n   fun:__write_nocancel\n   fun:syb_tcp_write\n   fun:sendflush\n   fun:sendserver\n   fun:bcp__buildrow\n   fun:bcp_sendrow\n}\n\n{\n   BerkeleyDB 4.6.21.1 glitch -- both alloc and use happen inside the same call\n   Memcheck:Param\n   pwrite64(buf)\n   fun:__pwrite_nocancel\n   fun:__os_io\n   fun:__memp_pgwrite\n   fun:__memp_bhwrite\n   fun:__memp_sync_int\n   ...\n   fun:__db_sync\n   fun:__db_refresh\n   fun:__db_close\n   fun:__fop_subdb_setup\n   fun:__db_open\n   fun:__db_open_pp\n}\n\n{\n   Googles as an apparent LZO2' intentional overread for performance\n   Memcheck:Value8\n   ...\n   fun:find_match\n   fun:lzo1x_999_compress_internal\n   fun:lzo1x_999_compress_level\n   fun:lzo1x_999_compress\n}\n\n{\n    http://permalink.gmane.org/gmane.comp.encryption.nettle.bugs/886\n    Memcheck:Addr8\n    fun:memxor3\n    fun:gcm_crypt\n    fun:nettle_gcm_encrypt\n}\n\n{\n    I think this is glibc's ultra optimised getenv doing 2 byte reads\n    Memcheck:Addr2\n    fun:getenv\n}\n\n{\n    I think this is glibc's ultra optimised getenv doing 2 byte reads\n    Memcheck:Cond\n    fun:getenv\n}\n\n{\n    corelib/CObject/InitCounter\n    Memcheck:Cond\n    fun:_ZN4ncbi7CObject11InitCounterEv\n    fun:*\n}\n{\n    corelib/Diag/s_CreateDefaultHandler\n    Memcheck:Leak\n    ...\n    fun:_ZN4ncbiL26s_CreateDefaultDiagHandlerEv\n}\n{\n    corelib/Diag/CreateDefaultHandler\n    Memcheck:Leak\n    ...\n    fun:_ZN4ncbi24CreateDefaultDiagHandlerEv\n}\n{\n    corelib/SSystemMutex/InitializeDynamic\n    Memcheck:Cond\n    fun:_ZN4ncbi12SSystemMutex17InitializeDynamicEv\n    fun:*\n}\n{\n    corelib/SSystemFastMutex/InitializeDynamic\n    Memcheck:Cond\n    fun:_ZN4ncbi16SSystemFastMutex17InitializeDynamicEv\n    fun:*\n}\n{\n    corelib/CTimeout/operator ==, <\n    Memcheck:Cond\n    fun:_ZNK4ncbi8CTimeout??ERKS0_\n    fun:*\n}\n{\n    corelib/NCBI_THROW\n    Memcheck:Leak\n    fun:malloc\n    fun:__cxa_get_globals\n    fun:__cxa_allocate_exception\n}\n{\n    corelib/SetDiagStream\n    Memcheck:Leak\n    fun:_Znwm\n    fun:_ZN4ncbi13SetDiagStreamEPSobPFvPvES1_RKSs\n}\n{\n   corelib/CNcbiEnvironment::Set\n   Memcheck:Leak\n   fun:malloc\n   fun:strdup\n   fun:_ZN4ncbi16CNcbiEnvironment3SetERKSsS2_\n}\n{\n    CToolkit/COldAsnTypeInfo\n    Memcheck:Leak\n    fun:?alloc\n    fun:s_MemAllocator\n    ...\n    fun:_ZN4ncbi15COldAsnTypeInfo*\n}\n{\n    serial/TypeInfo\n    Memcheck:Leak\n    fun:_Znwm\n    ...\n    fun:*TypeInfo*\n}\n{\n    serial/CEnumDataType::CreateDefault\n    Memcheck:Leak\n    fun:_Znwm\n    fun:_ZNK4ncbi13CEnumDataType13CreateDefaultERKNS_10CDataValueE\n    fun:_ZN4ncbi18CDataContainerType15CreateClassInfo*\n}\n{\n    serial/CIntDataType::CreateDefault\n    Memcheck:Leak\n    fun:_Znwm\n    fun:_ZNK4ncbi12CIntDataType13CreateDefaultERKNS_10CDataValueE\n    fun:_ZN4ncbi18CDataContainerType15CreateClassInfo*\n}\n{\n    serial/CPointerTypeInfo::ReadPointer\n    Memcheck:Leak\n    fun:_Znwm\n    fun:*\n    fun:*\n    fun:_ZN4ncbi16CPointerTypeInfo11ReadPointer*\n}\n{\n    serial/member\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi18CClassTypeInfoBase9AddMemberEPKcPKvRKNS_8CTypeRefE\n}\n{\n    serial/member\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi18CClassTypeInfoBase9AddMemberEPKcPKvRKNS_8CTypeRefE\n}\n{\n    serial/classinfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN9__gnu_cxx13new_allocatorISt13_Rb_tree_nodeIPN4ncbi18CClassTypeInfoBaseEEE8allocateEjPKv\n    fun:_ZNSt8_Rb_treeIPN4ncbi18CClassTypeInfoBaseES2_St9_IdentityIS2_ESt4lessIS2_ESaIS2_EE11_M_get_nodeEv\n}\n{\n    serial/iteminfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN9__gnu_cxx13new_allocatorIN4ncbi7AutoPtrINS1_9CItemInfoENS1_7DeleterIS3_EEEEE8allocateEjPKv\n    fun:_ZNSt12_Vector_baseIN4ncbi7AutoPtrINS0_9CItemInfoENS0_7DeleterIS2_EEEESaIS5_EE11_M_allocateEj\n}\n{\n    serial/iteminfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN9__gnu_cxx13new_allocatorIN4ncbi7AutoPtrINS1_9CItemInfoENS1_7DeleterIS3_EEEEE8allocateEjPKv\n}\n{\n    serial/iteminfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZNSt6vectorIN4ncbi7AutoPtrINS0_9CItemInfoENS0_7DeleterIS2_EEEESaIS5_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS5_S7_EERKS5_\n}\n{\n    serial/stltype\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:*\n    fun:_ZN4ncbi16CTypeInfoMapData11GetTypeInfoEPKNS_9CTypeInfoEPFPS1_S3_E\n}\n{\n    serial/stltype\n    Memcheck:Leak\n    fun:_Znwj\n    fun:*\n    fun:_ZN4ncbi16CTypeInfoMapData11GetTypeInfoEPKNS_9CTypeInfoEPFPS1_S3_E\n}\n{\n    serial/enumvalue\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZNK4ncbi21CEnumeratedTypeValues11ValueToNameEv\n}\n{\n    serial/enumvalue\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZNSt8_Rb_treeIiSt4pairIKiPKSsESt10_Select1stIS4_ESt4lessIiESaIS4_EE9_M_insertEPSt18_Rb_tree_node_baseSC_RKS4_\n    fun:_ZNSt8_Rb_treeIiSt4pairIKiPKSsESt10_Select1stIS4_ESt4lessIiESaIS4_EE13insert_uniqueESt17_Rb_tree_iteratorIS4_ERKS4_\n    fun:_ZNK4ncbi21CEnumeratedTypeValues11ValueToNameEv\n}\n{\n    serial/classinfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi20CClassInfoHelperBase15CreateClassInfoEPKcjPKNS_7CObjectEPFPvPKNS_9CTypeInfoEERKSt9type_infoPFPSD_PKvE\n}\n{\n    serial/classinfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi20CClassInfoHelperBase15CreateClassInfoEPKcjPKNS_7CObjectEPFPvPKNS_9CTypeInfoEPNS_17CObjectMemoryPoolEERKSt9type_infoPFPSF_PKvE\n}\n{\n    serial/choiceinfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi20CClassInfoHelperBase16CreateChoiceInfoEPKcjPKNS_7CObjectEPFPvPKNS_9CTypeInfoEERKSt9type_infoPFjPKNS_15CChoiceTypeInfoEPKvEPFvSH_S6_jEPFvSH_S6_E\n}\n{\n    serial/choiceinfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi20CClassInfoHelperBase16CreateChoiceInfoEPKcjPKNS_7CObjectEPFPvPKNS_9CTypeInfoEPNS_17CObjectMemoryPoolEERKSt9type_infoPFjPKNS_15CChoiceTypeInfoEPKvEPFvSJ_S6_jSB_EPFvSJ_S6_E\n}\n{\n    serial/typeinfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi7objects*11GetTypeInfoEv\n}\n{\n    serial/typeinfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi7objects*11GetTypeInfoEv\n}\n{\n    serial/typeinfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi30CPrimitiveTypeInfoIntFunctionsI?E14CreateTypeInfoEv\n}\n{\n    serial/typeinfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi30CPrimitiveTypeInfoIntFunctionsI?E14CreateTypeInfoEv\n}\n{\n    serial/enuminfo\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi24CreateEnumeratedTypeInfoI*21CEnumeratedTypeValuesE\n}\n{\n    serial/enuminfo\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi24CreateEnumeratedTypeInfoI*21CEnumeratedTypeValuesE\n}\n{\n    serial/choice\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi15CChoiceTypeInfo10AddVariantEPKcPKvRKNS_8CTypeRefE\n}\n{\n    serial/choice\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi15CChoiceTypeInfo10AddVariantEPKcPKvRKNS_8CTypeRefE\n}\n{\n    serial/std\n    Memcheck:Leak\n    fun:__builtin_new\n    fun:_Znwj\n    fun:_ZN4ncbi12CStdTypeInfo*CreateTypeInfo*\n}\n{\n    serial/std\n    Memcheck:Leak\n    fun:_Znwj\n    fun:_ZN4ncbi12CStdTypeInfo*CreateTypeInfo*\n}\n{\n    GProf/profil_counter\n    Memcheck:Cond\n    fun:profil_counter\n    fun:*\n}\n{\n    CSeqVector/tables\n    Memcheck:Leak\n    fun:__builtin_vec_new\n    fun:_Znaj\n    fun:_ZGVZN4ncbi7objects10CSeqVector18sx_GetConvertTableENS0_14CSeq_data_Base8E_ChoiceES3_bE6tables\n}\n{\n    CSeqVector/tables\n    Memcheck:Leak\n    fun:_Znaj\n    fun:_ZGVZN4ncbi7objects10CSeqVector18sx_GetConvertTableENS0_14CSeq_data_Base8E_ChoiceES3_bE6tables\n}\n{\n    boost/sigaltstack\n    Memcheck:Param\n    sigaltstack(ss)\n    fun:sigaltstack\n    fun:_ZN5boost6detail14signal_handlerD1Ev\n}\n{\n   boost/test_framework_impl::clear\n   Memcheck:Addr4\n   fun:_ZN5boost9unit_test14framework_impl5clearEv\n   fun:_ZN5boost9unit_test14framework_implD1Ev\n   fun:__tcf_3\n}\n{\n    LZO/do_compress\n    Memcheck:Cond\n    fun:do_compress\n    fun:lzo1x_1_compress\n}\n{\n    LZO/do_compress V8\n    Memcheck:Value8\n    fun:do_compress\n    fun:lzo1x_1_compress\n}\n{\n    STL/locale\n    Memcheck:Leak\n    fun:__builtin_vec_new\n    fun:_Znwj\n    fun:_ZNSt6locale7classicEv\n}\n{\n    STL/uncaught_exception\n    Memcheck:Leak\n    fun:malloc\n    fun:__cxa_get_globals\n    fun:_ZSt18uncaught_exceptionv\n}\n{\n    libc/dlrelocate\n    Memcheck:Cond\n    fun:_dl_relocate_object\n    fun:*\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:malloc\n    fun:add_to_global\n    fun:dl_open_worker\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:calloc\n    fun:_dlerror_run\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:malloc\n    fun:decompose_rpath\n    fun:_dl_map_object\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:malloc\n    fun:_dl_map_object_deps\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:malloc\n    fun:_dl_new_object\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:calloc\n    fun:_dl_new_object\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:malloc\n    fun:open_rpath\n    fun:_dl_map_object\n}\n{\n    libc/dlopen\n    Memcheck:Leak\n    fun:calloc\n    fun:_dl_check_map_versions\n}\n{\n    iostream/buffer\n    Memcheck:Leak\n    fun:__builtin_vec_new\n    fun:_Znaj\n    fun:_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv\n}\n{\n    iostream/buffer\n    Memcheck:Leak\n    fun:_Znaj\n    fun:_ZNSt13basic_filebufIwSt11char_traitsIwEE27_M_allocate_internal_bufferEv\n}\n{\n    iostream/buffer\n    Memcheck:Leak\n    fun:__builtin_vec_new\n    fun:_Znaj\n    fun:_ZNSt13basic_filebufIcSt11char_traitsIcEE27_M_allocate_internal_bufferEv\n}\n{\n    iostream/buffer\n    Memcheck:Leak\n    fun:_Znaj\n    fun:_ZNSt13basic_filebufIcSt11char_traitsIcEE27_M_allocate_internal_bufferEv\n}\n{\n    iostream/sync_with_stdio\n    Memcheck:Leak\n    fun:_Znam\n    fun:_ZNSt13basic_filebufI?St11char_traitsI?EE27_M_allocate_internal_bufferEv*\n    fun:_ZN9__gnu_cxx13stdio_filebuf*char_traitsI?EEC1EP8_IO_FILESt13_Ios_Openmodem\n    fun:_ZNSt8ios_base15sync_with_stdioEb\n}\n{\n    _dl_open\n    Memcheck:Addr4\n    fun:*\n    fun:*\n    fun:_dl_catch_error\n    fun:_dl_open\n}\n{\n    _dl_map_object\n    Memcheck:Addr4\n    fun:*\n    fun:*\n    fun:_dl_map_object\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/serial/datatool/testdata/data/set.bin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/serial/datatool/testdata/res/set.bin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/util/compress/bzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/util/compress/bzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ntf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ndb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/seqdb_reader/SeqDB-design-1.sxi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.paa",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pac",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/gene_info_reader/unit_test/data/geneinfo.g2o",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objtools/blast/gene_info_reader/unit_test/data/geneinfo.i2o",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/objects/general/Dbtag.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/project_tree_builder_gui/bin/ptbgui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/project_tree_builder_gui/bin/lib/swing-layout-1.0.4.jar",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/project_tree_builder_gui/bin/lib/swing-layout-1.0.3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/cmake/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/build-system/project_tree_builder/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/big_gi.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/alias.seqidlist.bsl",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pot",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.paa",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wgs.ABDC.gil",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test.entries.bsl",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/prot345b.gil",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs.gil",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pot",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pac",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/big_gi.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.not",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/testfile1.sqlite",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f556.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f556.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wgs.AADN.gil",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nti",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.not",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nti",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.ntd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.ntd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ranges/evenp.msk",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nab",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.rps",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.loo",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.freq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.rps",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.rps",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.naa",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.loo",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.freq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.obsr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.rps",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.loo",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.obsr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nac",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.wcounts",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.loo",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.wcounts",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.psi",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pkd",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/manyXs.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pki",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/manyXs.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pni",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/dbindex/README.usage",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pot",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pos",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pto",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/include/corelib/mswin_no_popup.h",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/include/objtools/cleanup/cleanup.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/compilers/vs2015/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/compilers/vs2017/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/blast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/blast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/blast/post_build/macosx/uninstall_ncbi_blast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/quickblastp/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/quickblastp/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/quickblastp/post_build/macosx/uninstall_ncbi_magicblast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/cobalt/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/cobalt/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/cobalt/post_build/macosx/uninstall_ncbi_cobalt.zip",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/magicblast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/magicblast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/magicblast/post_build/macosx/uninstall_ncbi_magicblast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/igblast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/igblast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-ncbi-magicblast-1.5.0-2xwnjxx2p62fgwpvtqeycwf7a4lga7n6/spack-src/c++/scripts/projects/igblast/post_build/macosx/uninstall_ncbi_igblast.zip"
    ],
    "total_files": 5879
}