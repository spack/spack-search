{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-soci-3.2.2-hi7ehyxolqkftbupqsbwvskbsyu5djoy/spack-src/src/core/backend-loader.cpp": "//\n// Copyright (C) 2008 Maciej Sobczak with contributions from Artyom Tonkikh\n// Distributed under the Boost Software License, Version 1.0.\n// (See accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#define SOCI_SOURCE\n#include \"backend-loader.h\"\n#include \"error.h\"\n#include <cassert>\n#include <cstdlib>\n#include <map>\n#include <string>\n#include <vector>\n#ifndef _MSC_VER\n#include <stdint.h>\n#endif\n\n#include \"soci_backends_config.h\"\n\nusing namespace soci;\nusing namespace soci::dynamic_backends;\n\n#ifdef _WIN32\n\n#include <windows.h>\n\ntypedef CRITICAL_SECTION soci_mutex_t;\ntypedef HMODULE soci_handler_t;\n\n#define LOCK(x) EnterCriticalSection(x)\n#define UNLOCK(x) LeaveCriticalSection(x)\n#define MUTEX_INIT(x) InitializeCriticalSection(x)\n#define MUTEX_DEST(x) DeleteCriticalSection(x)\n#ifdef _UNICODE\n#define DLOPEN(x) LoadLibraryA(x)\n#else\n#define DLOPEN(x) LoadLibrary(x)\n#endif\n#define DLCLOSE(x) FreeLibrary(x)\n#define DLSYM(x, y) GetProcAddress(x, y)\n\n#ifdef SOCI_ABI_VERSION\n#define LIBNAME(x) (SOCI_LIB_PREFIX + x + \"_\" SOCI_ABI_VERSION SOCI_LIB_SUFFIX)\n#else\n#define LIBNAME(x) (SOCI_LIB_PREFIX + x + SOCI_LIB_SUFFIX)\n#endif // SOCI_ABI_VERSION\n\n#else\n\n#include <pthread.h>\n#include <dlfcn.h>\n\ntypedef pthread_mutex_t soci_mutex_t;\ntypedef void * soci_handler_t;\n\n#define LOCK(x) pthread_mutex_lock(x)\n#define UNLOCK(x) pthread_mutex_unlock(x)\n#define MUTEX_INIT(x) pthread_mutex_init(x, NULL)\n#define MUTEX_DEST(x) pthread_mutex_destroy(x)\n#define DLOPEN(x) dlopen(x, RTLD_LAZY)\n#define DLCLOSE(x) dlclose(x)\n#define DLSYM(x, y) dlsym(x, y)\n\n#ifdef SOCI_ABI_VERSION\n\n#ifdef __APPLE__\n#define LIBNAME(x) (SOCI_LIB_PREFIX + x + \".\" SOCI_ABI_VERSION SOCI_LIB_SUFFIX)\n#else\n#define LIBNAME(x) (SOCI_LIB_PREFIX + x + SOCI_LIB_SUFFIX \".\" SOCI_ABI_VERSION)\n#endif\n\n#else\n#define LIBNAME(x) (SOCI_LIB_PREFIX + x + SOCI_LIB_SUFFIX)\n#endif // SOCI_ABI_VERSION\n\n#endif // _WIN32\n\n\nnamespace // unnamed\n{\n\nstruct info\n{\n    soci_handler_t handler_;\n    backend_factory const * factory_;\n    info() : handler_(0), factory_(0) {}\n};\n\ntypedef std::map<std::string, info> factory_map;\nfactory_map factories_;\n\nstd::vector<std::string> search_paths_;\n\nsoci_mutex_t mutex_;\n\nstd::vector<std::string> get_default_paths()\n{\n    std::vector<std::string> paths;\n\n    // TODO: may be problem with finding getenv in std namespace in Visual C++ --mloskot\n    char const* const penv = std::getenv(\"SOCI_BACKENDS_PATH\");\n    if (0 == penv)\n    {\n        paths.push_back(\".\");\n        paths.push_back(DEFAULT_BACKENDS_PATH);\n        return paths;\n    }\n\n    std::string const env = penv;\n    if (env.empty())\n    {\n        paths.push_back(\".\");\n        paths.push_back(DEFAULT_BACKENDS_PATH);\n        return paths;\n    }\n\n    std::string::size_type searchFrom = 0;\n    while (searchFrom != env.size())\n    {\n        std::string::size_type const found = env.find(\":\", searchFrom);\n        if (found == searchFrom)\n        {\n            ++searchFrom;\n        }\n        else if (std::string::npos != found)\n        {\n            std::string const path(env.substr(searchFrom, found - searchFrom));\n            paths.push_back(path);\n\n            searchFrom = found + 1;\n        }\n        else // found == npos\n        {\n            std::string const path = env.substr(searchFrom);\n            paths.push_back(path);\n\n            searchFrom = env.size();\n        }\n    }\n\n    return paths;\n}\n\n// used to automatically initialize the global state\nstruct static_state_mgr\n{\n    static_state_mgr()\n    {\n        MUTEX_INIT(&mutex_);\n\n        search_paths_ = get_default_paths();\n    }\n\n    ~static_state_mgr()\n    {\n        unload_all();\n\n        MUTEX_DEST(&mutex_);\n    }\n} static_state_mgr_;\n\nclass scoped_lock\n{\npublic:\n    scoped_lock(soci_mutex_t * m) : mptr(m) { LOCK(m); };\n    ~scoped_lock() { UNLOCK(mptr); };\nprivate:\n    soci_mutex_t * mptr;\n};\n\n// non-synchronized helper for the other functions\nvoid do_unload(std::string const & name)\n{\n    factory_map::iterator i = factories_.find(name);\n\n    if (i != factories_.end())\n    {\n        soci_handler_t h = i->second.handler_;\n        if (h != NULL)\n        {\n            DLCLOSE(h);\n        }\n\n        factories_.erase(i);\n    }\n}\n\n// non-synchronized helper\nvoid do_register_backend(std::string const & name, std::string const & shared_object)\n{\n    // The rules for backend search are as follows:\n    // - if the shared_object is given,\n    //   it names the library file and the search paths are not used\n    // - otherwise (shared_object not provided or empty):\n    //   - file named libsoci_NAME.so.SOVERSION is searched in the list of search paths\n\n    soci_handler_t h = 0;\n    if (shared_object.empty() == false)\n    {\n        h = DLOPEN(shared_object.c_str());\n    }\n    else\n    {\n        // try system paths\n        h = DLOPEN(LIBNAME(name).c_str());\n        if (0 == h)\n        {\n            // try all search paths\n            for (std::size_t i = 0; i != search_paths_.size(); ++i)\n            {\n                std::string const fullFileName(search_paths_[i] + \"/\" + LIBNAME(name));\n                h = DLOPEN(fullFileName.c_str());\n                if (0 != h)\n                {\n                    // already found\n                    break;\n                }\n             }\n         }\n    }\n\n    if (0 == h)\n    {\n        throw soci_error(\"Failed to find shared library for backend \" + name);\n    }\n\n    std::string symbol = \"factory_\" + name;\n\n    typedef backend_factory const * bfc_ptr;\n    typedef bfc_ptr (*get_t)(void);\n    get_t entry;\n    entry = reinterpret_cast<get_t>(\n            reinterpret_cast<uintptr_t>(DLSYM(h, symbol.c_str())));\n\n    if (0 == entry)\n    {\n        DLCLOSE(h);\n        throw soci_error(\"Failed to resolve dynamic symbol: \" + symbol);\n    }\n\n    // unload the existing handler if it's already loaded\n\n    do_unload(name);\n    \n    backend_factory const* f = entry();\n\n    info new_entry;\n    new_entry.factory_ = f;\n    new_entry.handler_ = h;\n\n    factories_[name] = new_entry;\n}\n\n} // unnamed namespace\n\nbackend_factory const& dynamic_backends::get(std::string const& name)\n{\n    scoped_lock lock(&mutex_);\n\n    factory_map::iterator i = factories_.find(name);\n\n    if (i != factories_.end())\n    {\n        return *(i->second.factory_);\n    }\n\n    // no backend found with this name, try to register it first\n\n    do_register_backend(name, std::string());\n\n    // second attempt, must succeed (the backend is already loaded)\n\n    i = factories_.find(name);\n\n    assert(i != factories_.end());\n\n    return *(i->second.factory_);\n}\n\nSOCI_DECL std::vector<std::string>& search_paths()\n{\n    return search_paths_;\n}\n\nSOCI_DECL void dynamic_backends::register_backend(\n    std::string const& name, std::string const& shared_object)\n{\n    scoped_lock lock(&mutex_);\n\n    do_register_backend(name, shared_object);\n}\n\nSOCI_DECL void dynamic_backends::register_backend(\n    std::string const& name, backend_factory const& factory)\n{\n    scoped_lock lock(&mutex_);\n\n    // unload the existing handler if it's already loaded\n\n    do_unload(name);\n    \n    info new_entry;\n    new_entry.factory_ = &factory;\n\n    factories_[name] = new_entry;\n}\n\nSOCI_DECL std::vector<std::string> dynamic_backends::list_all()\n{\n    scoped_lock lock(&mutex_);\n\n    std::vector<std::string> ret;\n    ret.reserve(factories_.size());\n\n    for (factory_map::iterator i = factories_.begin(); i != factories_.end(); ++i)\n    {\n        std::string const& name = i->first;\n        ret.push_back(name);\n    }\n\n    return ret;\n}\n\nSOCI_DECL void dynamic_backends::unload(std::string const& name)\n{\n    scoped_lock lock(&mutex_);\n\n    do_unload(name);\n}\n\nSOCI_DECL void dynamic_backends::unload_all()\n{\n    scoped_lock lock(&mutex_);\n\n    for (factory_map::iterator i = factories_.begin(); i != factories_.end(); ++i)\n    {\n        soci_handler_t h = i->second.handler_;\n        if (0 != h)\n        {\n            DLCLOSE(h);\n        }\n    }\n\n    factories_.clear();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-soci-3.2.2-hi7ehyxolqkftbupqsbwvskbsyu5djoy/spack-src/src/cmake/modules/FindDL.cmake": "if(DL_INCLUDE_DIR)\n  set(DL_FIND_QUIETLY TRUE)\nendif()\n\nfind_path(DL_INCLUDE_DIR dlfcn.h)\nfind_library(DL_LIBRARY NAMES dl)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(DL DEFAULT_MSG DL_LIBRARY DL_INCLUDE_DIR)\n\nif(NOT DL_FOUND)\n    # if dlopen can be found without linking in dl then,\n    # dlopen is part of libc, so don't need to link extra libs.\n    include(CheckFunctionExists)\n    check_function_exists(dlopen DL_FOUND)\n    set(DL_LIBRARY \"\")\nendif()\n\nset(DL_LIBRARIES ${DL_LIBRARY})\n\nmark_as_advanced(DL_LIBRARY DL_INCLUDE_DIR)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-soci-3.2.2-hi7ehyxolqkftbupqsbwvskbsyu5djoy/spack-src/www/forkus_github.png",
        "/tmp/vanessa/spack-stage/spack-stage-soci-3.2.2-hi7ehyxolqkftbupqsbwvskbsyu5djoy/spack-src/doc/structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-soci-3.2.2-hi7ehyxolqkftbupqsbwvskbsyu5djoy/spack-src/doc/structure.odg"
    ],
    "total_files": 336
}