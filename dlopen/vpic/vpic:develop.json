{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-vpic-develop-efpel2rteewooji6ekhhyjk5eyq7hwui/spack-src/src/util/checkpt/checkpt.cc": "/*#define VERBOSE_CHECKPOINTING*/\n#ifndef NO_REVERSE_SYMBOL_TABLE_LOOKUP_SUPPORT\n#define _GNU_SOURCE\n\n#if defined(__APPLE__)\n#define _DARWIN_C_SOURCE\n#endif\n\n#include \"dlfcn.h\"\n#endif\n\n#define IN_checkpt\n#include \"checkpt_private.h\"\n\n/* Boolean flag indicating whether or not checkpoint is booted. */\n\nstatic int booted = 0;\n\n/* If NULL, indicates that we are not in the middle of a checkpt or a\n   restore.  Otherwise, it gives the handle of the stream used for I/O\n   operations. */\n\nstatic checkpt_t * checkpt = NULL;\nstatic checkpt_t * restore = NULL;\n\n/* The registry is a list of objects that need to checkpointed (in the\n   order they should be checkpointed).  The registry gives each object\n   a unique identifier that is invariant across a checkpt/restore and\n   includes the details how to checkpt and restore each object. */\n\ntypedef struct registry {\n  void * obj;\n  checkpt_func_t checkpt_func;\n  restore_func_t restore_func;\n  reanimate_func_t reanimate_func;\n  size_t id;\n  struct registry * next;\n} registry_t;\n\nstatic registry_t * registry = NULL;\n\n/* Counter used to dole out unique ids.  Zero ids are used to indicate\n   an error condition. */\n\nstatic size_t next_id = 1;\n\n#ifdef VERBOSE_CHECKPOINTING\n\nstatic void\ndump_node( registry_t * node ) {\n  Dl_info dli[1];\n  if( node->checkpt_func ) dladdr( (void *)(size_t)node->checkpt_func, dli );\n  else                     dli->dli_sname = NULL, dli->dli_fname = NULL;\n  log_printf( \"Object %lu:\\n\"\n              \"\\taddr=%lx\\n\"\n              \"\\tcheckpt_func=%lx (%s from %s)\\n\",\n              (unsigned long)node->id,\n              (unsigned long)node->obj,\n              (unsigned long)node->checkpt_func,\n              !dli->dli_sname ? \"(null)\" : dli->dli_sname,\n              !dli->dli_fname ? \"(null)\" : dli->dli_fname );\n  if( node->restore_func ) dladdr( (void *)(size_t)node->restore_func, dli );\n  else                     dli->dli_sname = NULL, dli->dli_fname = NULL;\n  log_printf( \"\\trestore_func=%lx (%s from %s)\\n\",\n              (unsigned long)node->restore_func,\n              !dli->dli_sname ? \"(null)\" : dli->dli_sname,\n              !dli->dli_fname ? \"(null)\" : dli->dli_fname );\n  if( node->reanimate_func ) dladdr( (void *)(size_t)node->reanimate_func,dli);\n  else                       dli->dli_sname = NULL, dli->dli_fname = NULL;\n  log_printf( \"\\treanimate_func=%lx (%s from %s)\\n\",\n              (unsigned long)node->reanimate_func,\n              !dli->dli_sname ? \"(null)\" : dli->dli_sname,\n              !dli->dli_fname ? \"(null)\" : dli->dli_fname );\n}\n\nstatic void\ndump_registry( void ) {\n  registry_t * node;\n  for( node=registry; node; node=node->next ) dump_node( node );\n}\n\n#else\n\nstatic void\ndump_node( registry_t * node ) {\n}\n\nstatic void\ndump_registry( void ) {\n}\n\n#endif\n\nvoid\nboot_checkpt( int * pargc,\n              char *** pargv ) {\n\n  /* Check input args */\n\n  if( booted ) ERROR(( \"checkpt service already booted.\" ));\n\n  /* Initialize the checkpt service state */\n\n  registry = NULL;\n  checkpt  = NULL;\n  restore  = NULL;\n  next_id  = 1;\n\n  /* Mark the service as booted */\n\n  booted = 1;\n}\n\nvoid\nhalt_checkpt( void ) {\n\n  /* Check input args */\n\n  if( !booted  ) ERROR(( \"checkpt service not booted.\" ));\n  if( registry ) {\n    dump_registry();\n    ERROR(( \"halt called with some objects still registered\" ));\n  }\n  if( checkpt  ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore  ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Mark the service as halted */\n\n  booted = 0;\n}\n\nsize_t\nobject_id( const void * obj ) {\n  registry_t * node;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt service not booted\" ));\n\n  /* Search the registry for the object */\n\n  for( node=registry; node; node=node->next )\n    if( node->obj==obj ) break;\n\n  /* If found, return the id, otherwise, return 0 */\n\n  return node ? node->id : 0;\n}\n\nvoid *\nobject_ptr( size_t id ) {\n  registry_t * node;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt service not booted\" ));\n\n  /* Search the registry for the id */\n\n  for( node=registry; node; node=node->next )\n    if( node->id==id ) break;\n\n  /* If found, return the id, otherwise, return NULL */\n\n  return node ? node->obj : NULL;\n}\n\n// TODO: It's common to pass a ** in here, can we change the interface to just\n// be a regular pointer? I think we should avoid void casts where possible..\n// (but I accept checkpoint could possibly be re-written)\nvoid register_object(\n        void* obj,\n        checkpt_func_t checkpt_func,\n        restore_func_t restore_func,\n        reanimate_func_t reanimate_func\n)\n{\n\n  registry_t * node, * prev;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt service not booted\" ));\n  if( checkpt ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Check that obj is valid and that obj isn't already registered.\n     At the same time, find the last entry in the registry. */\n\n  if( !obj ) ERROR(( \"NULL obj\" ));\n  for( prev=NULL, node=registry; node; prev=node, node=node->next )\n    if( node->obj==obj ) break;\n  if( node ) ERROR(( \"object already registered\" ));\n  \n  /* Create the registry entry for this object */\n\n  MALLOC( node, 1 );\n  node->id             = next_id++;\n  node->obj            = obj;\n  node->checkpt_func   = checkpt_func;\n  node->restore_func   = restore_func;\n  node->reanimate_func = reanimate_func;\n  node->next           = NULL;\n\n  /* And append it to the end of the registry */\n\n  if( prev ) prev->next = node;\n  if( !registry ) registry = node;\n}\n\nvoid\nunregister_object( void * obj ) {\n  registry_t * node, * prev;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt service not booted\" ));\n  if( checkpt ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Find the entry for this object in the register and the previous\n     entry.  If the object is not registered, return an error */\n\n  for( prev=NULL, node=registry; node; prev=node, node=node->next )\n    if( node->obj==obj ) break;\n  if( !node ) ERROR(( \"object was not registered\" ));\n\n  /* Remove the node from the registry */\n\n  if( node==registry ) registry = node->next;\n  if( prev ) prev->next = node->next;\n  node->next = NULL;\n\n  /* And delete it */\n\n  FREE( node );\n}\n\nvoid\ncheckpt_objects( const char * name ) {\n  registry_t * node;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt not booted\" ));\n  if( checkpt ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Open the checkpt serialization stream */\n\n  checkpt = checkpt_open_wronly( name );\n  CHECKPT_VAL( size_t, next_id );\n\n  /* Checkpoint the objects */\n\n  for( node=registry; node; node=node->next ) {\n    dump_node( node );\n    CHECKPT_VAL( size_t, 0x600DF00D );\n    checkpt_raw( node, sizeof(*node) );\n    checkpt_sym( (void *)(size_t)node->checkpt_func   );\n    checkpt_sym( (void *)(size_t)node->restore_func   );\n    checkpt_sym( (void *)(size_t)node->reanimate_func );\n    if( node->checkpt_func ) node->checkpt_func( node->obj );\n  }\n\n  /* Mark that there are no more objects in the stream, close the\n     serialization stream and indicate that we are no longer writing a\n     checkpt */\n  \n  CHECKPT_VAL( size_t, 0xBADF00D );\n  checkpt_close( checkpt );\n  checkpt = NULL;\n}\n\nvoid\nrestore_objects( const char * name ) {\n  registry_t * node, * prev;\n  size_t prefix;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt not booted\" ));\n  if( checkpt ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Delete all objects in the in favor of the checkpointed objects */\n\n  node = registry;\n  while( node ) {\n    prev = node;\n    node = node->next;\n    FREE( prev );\n  }\n  registry = NULL;\n  next_id = 0;\n\n  /* Open the checkpt deserialization stream */\n\n  restore = checkpt_open_rdonly( name );\n  RESTORE_VAL( size_t, next_id );\n\n  /* Restore the objects */\n\n  prev = NULL;\n  for(;;) {\n    RESTORE_VAL( size_t, prefix );\n    if( prefix== 0xBADF00D ) break;\n    if( prefix!=0x600DF00D )\n      ERROR(( \"Malformed checkpt (expected an object header)\" ));\n    MALLOC( node, 1 );\n    restore_raw( node, sizeof(*node) );\n    node->checkpt_func   = (checkpt_func_t)  (size_t)restore_sym();\n    node->restore_func   = (restore_func_t)  (size_t)restore_sym();\n    node->reanimate_func = (reanimate_func_t)(size_t)restore_sym();\n    node->next = NULL;\n    if( !registry ) registry = node;\n    if( prev ) prev->next = node;\n    prev = node;\n    dump_node( node );\n    if( node->restore_func ) node->obj = node->restore_func();\n  }\n\n  /* Close the checkpt deserialization stream and indicate that we are\n     no longer reading a checkpt */\n\n  checkpt_close( restore );\n  restore = NULL;\n}\n\nvoid\nreanimate_objects( void ) {\n  registry_t * node;\n\n  /* Check input args */\n\n  if( !booted ) ERROR(( \"checkpt not booted\" ));\n  if( checkpt ) ERROR(( \"currently writing a checkpt\" ));\n  if( restore ) ERROR(( \"currently reading a checkpt\" ));\n\n  /* Call each objects reanimate function */\n\n  for( node=registry; node; node=node->next ) {\n    dump_node( node );\n    if( node->reanimate_func ) node->reanimate_func( node->obj );\n  }\n}\n\n/* Primitive checkpt helpers */\n\nvoid\ncheckpt_raw( const void * data,\n             size_t n_byte ) {\n\n  /* Check input args */\n\n  if( !checkpt ) ERROR(( \"not writing a checkpt\" ));\n  if( !data && n_byte ) ERROR(( \"NULL data\" ));\n\n  /* Write data to the serialization stream */\n\n  if( n_byte ) checkpt_write( checkpt, data, n_byte );\n}\n\nvoid\nrestore_raw( void * data,\n             size_t n_byte ) {\n\n  /* Check input args */\n\n  if( !restore ) ERROR(( \"not reading a checkpt\" ));\n  if( !data && n_byte ) ERROR(( \"NULL data\" ));\n\n  /* Read data from the deserialization stream */\n\n  if( n_byte ) checkpt_read( restore, data, n_byte );\n}\n\n/* Composiite checkpt helpers */\n\nvoid\ncheckpt_data( const void * _data,\n              size_t sz_ele,\n              size_t str_ele,\n              size_t n_ele,\n              size_t max_ele,\n              size_t align ) {\n  const char * data = (const char *)_data;\n  size_t n;\n\n  /* Check input args */\n\n  if( !data && n_ele*sz_ele>0 ) ERROR(( \"NULL data\" ));\n  if( n_ele>max_ele || sz_ele>str_ele ) ERROR(( \"bad data layout\" ));\n\n  /* Write the data header */\n\n  CHECKPT_VAL( size_t, 0xDA7A );\n  CHECKPT_VAL( size_t, sz_ele ); CHECKPT_VAL( size_t, str_ele );\n  CHECKPT_VAL( size_t, n_ele  ); CHECKPT_VAL( size_t, max_ele );\n  CHECKPT_VAL( size_t, align  );\n\n  /* Write out the individual elements */\n\n  for( n=0; n<n_ele; n++ ) checkpt_raw( data+n*str_ele, sz_ele );\n}\n\nvoid *\nrestore_data( void ) {\n  char * data;\n  size_t n, sz_ele, str_ele, n_ele, max_ele, align;\n\n  /* Read the data header */\n\n  RESTORE_VAL( size_t, n );\n  if( n!=0xDA7A ) ERROR(( \"malformed checkpt (expected a data header)\" ));\n  RESTORE_VAL( size_t, sz_ele ); RESTORE_VAL( size_t, str_ele );\n  RESTORE_VAL( size_t, n_ele  ); RESTORE_VAL( size_t, max_ele );\n  RESTORE_VAL( size_t, align  );\n  if( n_ele>max_ele || sz_ele>str_ele )\n    ERROR(( \"malformed checkpt (invalid data layout)\" ));\n\n  /* Allocate the data according to the header */\n\n  if( align==0 ) MALLOC(         data, max_ele*str_ele        );\n  else           MALLOC_ALIGNED( data, max_ele*str_ele, align );\n\n  /* And read in the checkpointed elements */\n\n  for( n=0; n<n_ele; n++ ) restore_raw( data+n*str_ele, sz_ele );\n  return data;\n}\n\nvoid\ncheckpt_str( const char * str ) {\n  \n  /* If str is NULL, write a NULL string header to the stream.\n     Otherwise, write a non-NULL string header and the string itself\n     (not including the terminating '\\0'). */\n\n  if( !str ) CHECKPT_VAL( size_t, 0x2c11577 );\n  else {\n    size_t len = strlen(str);\n    CHECKPT_VAL( size_t, 0x577 );\n    CHECKPT_VAL( size_t, len   );\n    checkpt_raw( str, len );\n  }\n}\n\nchar *\nrestore_str( void ) {\n  char * str;\n  size_t len;\n\n  /* Read the string header and decide what kind of string we\n     received */\n\n  RESTORE_VAL( size_t, len );\n  if( len==0x2c11577 ) return NULL; /* NULL string received */\n  if( len!=0x577 )\n    ERROR(( \"malformed checkpt (expected a non-NULL string header)\" ));\n\n  /* We received a non-NULL string.  Get its length, allocate it,\n     read it (appending the terminating '\\0') and check that it\n     restored okay. */\n\n  RESTORE_VAL( size_t, len );\n  MALLOC( str, len+1 );\n  restore_raw( str, len );\n  str[len] = '\\0';\n  if( strlen(str)!=len )\n    ERROR(( \"malformed checkpt (malformed string data)\" ));\n\n  return str;\n}\n\nvoid\ncheckpt_fptr( const void * ptr ) {\n\n  /* If ptr is NULL, write a NULL pointer header to the stream.\n     Otherwise, write a non-NULL pointer header and the unique\n     identifier for the ptr itself. */\n\n  if( !ptr ) CHECKPT_VAL( size_t, 0x2c11977 );\n  else {\n    size_t id = object_id( ptr );\n    if( !id )\n      ERROR(( \"cannot checkpoint a pointer to an unregistered object\" ));\n    CHECKPT_VAL( size_t, 0x977 );\n    CHECKPT_VAL( size_t, id    );\n  }\n}\n\nvoid *\nrestore_fptr( void ) {\n  size_t id;\n\n  /* Read the pointer header and decide what kind of pointer we\n     received */\n\n  RESTORE_VAL( size_t, id );\n  if( id==0x2c11977 ) return NULL; /* NULL pointer received */\n  if( id!=0x977 )\n    ERROR(( \"malformed checkpt (expected a non-NULL pointer header)\" ));\n\n  /* We received a non-NULL pointer.  Get its unique identifier and\n     determine what it points to locally. */\n\n  RESTORE_VAL( size_t, id );\n  if( !id ) ERROR(( \"malformed checkpt (expected an object identifier)\" ));\n\n  return (void *)id;\n}\n\nvoid *\nreanimate_fptr( void * ptr ) {\n  if( !ptr ) return NULL;\n  ptr = object_ptr( (size_t)ptr );\n  if( !ptr )\n    ERROR(( \"Unable to reanimate a pointer.  Mostly likely, either the \"\n            \"checkpt is malformed or a restore function is trying to restore \"\n            \"a pointer to an object that hasn't been restored yet (the second \"\n            \"case shouldn't happen if, as is typically the case, the \"\n            \"checkpointed object dependency network is a DAG ... use \"\n            \"restore_fptr in the restore and reanimate_fptr functions in the \"\n            \"reanimate functions to restore pointers in a non-DAG dependency \"\n            \"network if not doing so currently).\" ));\n  return ptr;\n}\n\nvoid\ncheckpt_ptr( const void * ptr ) {\n  checkpt_fptr( ptr );\n}\n\nvoid *\nrestore_ptr( void ) {\n  return reanimate_fptr( restore_fptr() );\n}\n\n#ifdef NO_REVERSE_SYMBOL_TABLE_LOOKUP_SUPPORT\n\nvoid\ncheckpt_sym( const void * saddr ) {\n\n  /* If symbol address is NULL, checkpoint a NULL symbol header.\n     Otherwise, write a address symbol header and the symbol\n     address. */\n  \n  if( !saddr ) CHECKPT_VAL( size_t, 0x2C11513B );\n  else {\n    static int first_time = 1;\n    if( first_time ) {\n      if( !world_rank ) \n        WARNING(( \"Checkpointing was compiled without reverse symbol table \"\n                  \"lookup support and has been asked to checkpoint at least \"\n                  \"one symbol.  Checkpointing will likely only work correctly \"\n                  \"if checkpointed symbols are statically linked in the \"\n                  \"application and the exact same application binary is used \"\n                  \"for both the checkpoint and restore process.\" ));\n      first_time = 0;\n    }\n\n    CHECKPT_VAL( size_t, 0xADD7513B  );\n    CHECKPT_VAL( const void *, saddr );    \n  }\n}\n\nvoid *\nrestore_sym( void ) {\n  static int first_time = 1;\n  size_t type;\n  void * saddr;\n\n  /* Read the symbol header and determine the symbol type. */\n\n  RESTORE_VAL( size_t, type );\n  if( type==0x2C11513B ) return NULL; /* NULL symbol header */\n  if( type!=0xADD7513B ) \n    ERROR(( \"Malformed checkpt (expected symbol header)\" ));\n\n  /* Read the symbol address */\n\n  if( first_time ) {\n    if( !world_rank ) \n      WARNING(( \"Checkpointing was compiled without reverse symbol table \"\n                \"lookup support and has been asked to restore at least one \"\n                \"symbol.  Checkpointing will likely only work correctly if \"\n                \"checkpointed symbols are statically linked in the \"\n                \"application and the exact same application binary is used \"\n                \"for both the checkpoint and restore process.\" ));\n    first_time = 0;\n  }\n\n  RESTORE_VAL( void *, saddr );\n  return saddr;\n}\n\n#else\n\n/* Note that this function is only used to look for non-NULL symbols */\n\nstatic void *\nfind_saddr( const char * sname,\n            const char * fname ) {\n  void * saddr, * fbase;\n  const char * err;\n\n  /* If we aren't given a symbol name, return not found */\n\n  if( !sname ) return NULL;\n  \n  /* Note that the default library search path (RTLD_DEFAULT) includes\n     the application itself.  The application should be linked with\n     with the global symbol table exported (e.g. \"-rdynamic\" under\n     gcc) for this to work. */\n\n  dlerror();\n  saddr = dlsym( RTLD_DEFAULT, sname );\n  err = dlerror();\n  if( !err ) return saddr;\n\n  /* If we didn't find it in the library search path, try opening the\n     library given by the explicit fname parameter (if provided).\n\n     Note: Currently, this code path is disabled as fname returned by\n     dladdr seems not be to useful (it typically is the application's\n     name, which dlopen cannot actually open) and there are open\n     issues of how to call dlopen (RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL)\n     and what and how to call dlclose. */\n\n  if( 0 && fname ) {\n    dlerror();\n    fbase = dlopen( fname, RTLD_LAZY );\n    err = dlerror();\n    if( err ) WARNING(( \"dlopen(%s,RTLD_LAZY): %s\", fname, err ));\n    else {\n      dlerror();\n      saddr = dlsym( fbase, sname );\n      err = dlerror();\n      if( !err ) return saddr;\n    }\n  }\n\n  return NULL;\n}\n\nvoid\ncheckpt_sym( const void * saddr ) {\n  Dl_info dli[1];\n  const char * err;\n\n  /* If the symbol is NULL, checkpoint a NULL symbol header */\n  \n  if( !saddr ) {\n    CHECKPT_VAL( size_t, 0x2C11513B );\n    return;\n  }\n\n  /* Do a reverse symbol lookup */\n\n  dlerror();\n  dladdr( saddr, dli );\n  err = dlerror();\n  if( err ) ERROR(( \"dladdr: %s\", err ));\n\n  if( saddr==find_saddr( dli->dli_sname, dli->dli_fname ) ) {\n\n    /* If we can resolve the symbol using the strings given to us by\n       the reverse lookup, checkpoint the symbol strings (presumably,\n       these strings are invariant across a checkpt/restore and thus\n       we should be able to do this resolution again on the\n       restore). */\n\n    CHECKPT_VAL( size_t, 0x577513B );\n    checkpt_str( dli->dli_sname );\n    checkpt_str( dli->dli_fname );\n\n  } else {\n\n    /* Otherwise, just checkpoint the raw symbol address (if we can't\n       resolve the address with the strings now, there is virtually no\n       chance we will be able to resolve it with the strings).  The\n       raw symbol address is only invariant under very limited\n       circumstances (e.g. symbol is in a statically linked section of\n       the code and the exact same binary used for writing the\n       checkpoint is used to read the checkpoint).  So, we give a\n       stern warning to the user that bad things are possible when\n       restoring this symbol. */\n\n    WARNING(( \"Unable to find a safely writable symbol that corresponds to \"\n              \"address %lx (the closest match was \\\"%s\\\" from \\\"%s\\\").  \"\n              \"Writing out the raw address instead and keeping my fingers \"\n              \"crossed.\\n\", (unsigned long)saddr,\n              !dli->dli_sname ? \"(null)\" : dli->dli_sname,\n              !dli->dli_fname ? \"(null)\" : dli->dli_fname ));\n\n    CHECKPT_VAL( size_t, 0xADD7513B  );\n    CHECKPT_VAL( const void *, saddr );\n    \n  }\n}\n\nvoid *\nrestore_sym( void ) {\n  size_t type;\n  void * saddr;\n  char * sname, * fname;\n  Dl_info dli[1];\n  const char * err;\n\n  /* Read the symbol header */\n\n  RESTORE_VAL( size_t, type );\n\n  switch( type ) {\n\n  default:         /* Invalid header */\n    ERROR(( \"Malformed checkpt (expected symbol header)\" ));\n    saddr = NULL;\n    break;\n\n  case 0x2C11513B: /* NULL symbol */\n    saddr = NULL;\n    break;\n\n  case  0x577513B: /* string symbol */\n\n    /* Restore the symbol strings */\n\n    sname = restore_str();\n    fname = restore_str();\n\n    /* Find the symbol's address */\n\n    saddr = find_saddr( sname, fname );   \n    if( !saddr )\n      ERROR(( \"Unable to resolve the symbol \\\"%s\\\" (from \\\"%s\\\") in the \"\n              \"current symbol table.  When this symbol was written, it was \"\n              \"resolvable in old symbol table.  Thus, make sure you have \"\n              \"not changed the application to eliminate this symbol or give \"\n              \"it a slightly different name, that your paths to various \"\n              \"libraries are set correctly, that the same library versions \"\n              \"are being used and so forth to allow this symbol to be \"\n              \"resolved correctly.\", sname, fname ));\n\n    /* Free the strings */\n\n    FREE( sname );\n    FREE( fname );\n    break;\n\n  case 0xADD7513B: /* address symbol */\n\n    /* Read the old symbol's address. */\n\n    RESTORE_VAL( void *, saddr );\n\n    /* Check to see if the symbol address makes any sense currently. */\n    \n    dlerror();\n    dladdr( saddr, dli );\n    err = dlerror();\n    if( err ) ERROR(( \"dladdr: %s\", err ));\n    if( saddr==find_saddr( dli->dli_sname, dli->dli_fname ) )\n      WARNING(( \"Read a symbol that was saved unsafely as the symbol's \"\n                \"address (%lx) in the old symbol table.  This address \"\n                \"resolves to symbol \\\"%s\\\" (from \\\"%s\\\") in the current \"\n                \"symbol table.  Keeping my fingers crossed that this \"\n                \"corresponds to the saved symbol.\", (unsigned long)saddr,\n                dli->dli_sname, dli->dli_fname ));\n    else\n      WARNING(( \"Read a symbol that was saved unsafely as the symbol's \"\n                \"address (%lx) in the old symbol table.  This address was not \"\n                \"found in the current symbol table; the closest match is \"\n                \"symbol \\\"%s\\\" (from \\\"%s\\\") at address %lx.  Keeping my \"\n                \"fingers crossed that the old address still means \"\n                \"something.\\n\", (unsigned long)saddr, dli->dli_sname,\n                dli->dli_fname, (unsigned long)dli->dli_saddr ));\n    break;\n\n  }\n\n  return saddr;\n}\n\n#endif\n\nvoid\n_cxx_illegal_ptr_copy( void * lv_ref,\n                       const void * rv ) {\n  if( lv_ref ) (*((const void **)lv_ref)) = rv;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-vpic-develop-efpel2rteewooji6ekhhyjk5eyq7hwui/spack-src/.git/objects/pack/pack-27c50c12df93405fb740f95ebccb503a6aa73422.idx",
        "/tmp/vanessa/spack-stage/spack-stage-vpic-develop-efpel2rteewooji6ekhhyjk5eyq7hwui/spack-src/.git/objects/pack/pack-27c50c12df93405fb740f95ebccb503a6aa73422.pack",
        "/tmp/vanessa/spack-stage/spack-stage-vpic-develop-efpel2rteewooji6ekhhyjk5eyq7hwui/spack-src/doc/vpicUnits.pdf"
    ],
    "total_files": 349
}