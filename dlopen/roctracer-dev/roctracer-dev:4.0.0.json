{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-roctracer-dev-4.0.0-vwr5jy66t4editezfva7sumfoyaqloki/spack-src/src/util/hsa_rsrc_factory.cpp": "/**********************************************************************\nCopyright \u00a92013 Advanced Micro Devices, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n<95>    Redistributions of source code must retain the above copyright notice, this list of\nconditions and the following disclaimer.\n<95>    Redistributions in binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\n other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n********************************************************************/\n\n#include \"util/hsa_rsrc_factory.h\"\n\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <hsa.h>\n#include <hsa_ext_amd.h>\n#include <hsa_ext_finalize.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <atomic>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nnamespace util {\n\n// Callback function to get available in the system agents\nhsa_status_t HsaRsrcFactory::GetHsaAgentsCallback(hsa_agent_t agent, void* data) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  HsaRsrcFactory* hsa_rsrc = reinterpret_cast<HsaRsrcFactory*>(data);\n  const AgentInfo* agent_info = hsa_rsrc->AddAgentInfo(agent);\n  if (agent_info != NULL) status = HSA_STATUS_SUCCESS;\n  return status;\n}\n\n// This function checks to see if the provided\n// pool has the HSA_AMD_SEGMENT_GLOBAL property. If the kern_arg flag is true,\n// the function adds an additional requirement that the pool have the\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT property. If kern_arg is false,\n// pools must NOT have this property.\n// Upon finding a pool that meets these conditions, HSA_STATUS_INFO_BREAK is\n// returned. HSA_STATUS_SUCCESS is returned if no errors were encountered, but\n// no pool was found meeting the requirements. If an error is encountered, we\n// return that error.\nstatic hsa_status_t FindGlobalPool(hsa_amd_memory_pool_t pool, void* data, bool kern_arg) {\n  hsa_status_t err;\n  hsa_amd_segment_t segment;\n  uint32_t flag;\n\n  if (nullptr == data) {\n    return HSA_STATUS_ERROR_INVALID_ARGUMENT;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_SEGMENT, &segment);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n  if (HSA_AMD_SEGMENT_GLOBAL != segment) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS, &flag);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n\n  uint32_t karg_st = flag & HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT;\n\n  if ((karg_st == 0 && kern_arg) || (karg_st != 0 && !kern_arg)) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  *(reinterpret_cast<hsa_amd_memory_pool_t*>(data)) = pool;\n  return HSA_STATUS_INFO_BREAK;\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that is NOT\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindStandardPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, false);\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that IS\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindKernArgPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, true);\n}\n\n// Constructor of the class\nHsaRsrcFactory::HsaRsrcFactory(bool initialize_hsa) : initialize_hsa_(initialize_hsa) {\n  hsa_status_t status;\n\n  cpu_pool_ = NULL;\n  kern_arg_pool_ = NULL;\n\n  InitHsaApiTable(NULL);\n\n  // Initialize the Hsa Runtime\n  if (initialize_hsa_) {\n    status = hsa_api_.hsa_init();\n    CHECK_STATUS(\"Error in hsa_init\", status);\n  }\n\n  // Discover the set of Gpu devices available on the platform\n  status = hsa_api_.hsa_iterate_agents(GetHsaAgentsCallback, this);\n  CHECK_STATUS(\"Error Calling hsa_iterate_agents\", status);\n  if (cpu_pool_ == NULL) CHECK_STATUS(\"CPU memory pool is not found\", HSA_STATUS_ERROR);\n  if (kern_arg_pool_ == NULL) CHECK_STATUS(\"Kern-arg memory pool is not found\", HSA_STATUS_ERROR);\n\n  // Get AqlProfile API table\n  aqlprofile_api_ = {0};\n#ifdef ROCP_LD_AQLPROFILE\n  status = LoadAqlProfileLib(&aqlprofile_api_);\n#else\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_AQLPROFILE, hsa_ven_amd_aqlprofile_VERSION_MAJOR, sizeof(aqlprofile_api_), &aqlprofile_api_);\n#endif\n  CHECK_STATUS(\"aqlprofile API table load failed\", status);\n\n  // Get Loader API table\n  loader_api_ = {0};\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_LOADER, 1, sizeof(loader_api_), &loader_api_);\n  CHECK_STATUS(\"loader API table query failed\", status);\n\n  // Instantiate HSA timer\n  timer_ = new HsaTimer(&hsa_api_);\n  CHECK_STATUS(\"HSA timer allocation failed\",\n    (timer_ == NULL) ? HSA_STATUS_ERROR : HSA_STATUS_SUCCESS);\n\n  // Time correlation\n  const uint32_t corr_iters = 1000;\n  CorrelateTime(HsaTimer::TIME_ID_CLOCK_REALTIME, corr_iters);\n  CorrelateTime(HsaTimer::TIME_ID_CLOCK_MONOTONIC, corr_iters);\n\n  // System timeout\n  timeout_ = (timeout_ns_ == HsaTimer::TIMESTAMP_MAX) ? timeout_ns_ : timer_->ns_to_sysclock(timeout_ns_);\n}\n\n// Destructor of the class\nHsaRsrcFactory::~HsaRsrcFactory() {\n  delete timer_;\n  for (auto p : cpu_list_) delete p;\n  for (auto p : gpu_list_) delete p;\n  if (initialize_hsa_) {\n    hsa_status_t status = hsa_api_.hsa_shut_down();\n    CHECK_STATUS(\"Error in hsa_shut_down\", status);\n  }\n}\n\nvoid HsaRsrcFactory::InitHsaApiTable(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n\n  if (hsa_api_.hsa_init == NULL) {\n    if (table != NULL) {\n      hsa_api_.hsa_init = table->core_->hsa_init_fn;\n      hsa_api_.hsa_shut_down = table->core_->hsa_shut_down_fn;\n      hsa_api_.hsa_agent_get_info = table->core_->hsa_agent_get_info_fn;\n      hsa_api_.hsa_iterate_agents = table->core_->hsa_iterate_agents_fn;\n\n      hsa_api_.hsa_queue_create = table->core_->hsa_queue_create_fn;\n      hsa_api_.hsa_queue_destroy = table->core_->hsa_queue_destroy_fn;\n      hsa_api_.hsa_queue_load_write_index_relaxed = table->core_->hsa_queue_load_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_store_write_index_relaxed = table->core_->hsa_queue_store_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_load_read_index_relaxed = table->core_->hsa_queue_load_read_index_relaxed_fn;\n\n      hsa_api_.hsa_signal_create = table->core_->hsa_signal_create_fn;\n      hsa_api_.hsa_signal_destroy = table->core_->hsa_signal_destroy_fn;\n      hsa_api_.hsa_signal_load_relaxed = table->core_->hsa_signal_load_relaxed_fn;\n      hsa_api_.hsa_signal_store_relaxed = table->core_->hsa_signal_store_relaxed_fn;\n      hsa_api_.hsa_signal_wait_scacquire = table->core_->hsa_signal_wait_scacquire_fn;\n      hsa_api_.hsa_signal_store_screlease = table->core_->hsa_signal_store_screlease_fn;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = table->core_->hsa_code_object_reader_create_from_file_fn;\n      hsa_api_.hsa_executable_create_alt = table->core_->hsa_executable_create_alt_fn;\n      hsa_api_.hsa_executable_load_agent_code_object = table->core_->hsa_executable_load_agent_code_object_fn;\n      hsa_api_.hsa_executable_freeze = table->core_->hsa_executable_freeze_fn;\n      hsa_api_.hsa_executable_get_symbol = table->core_->hsa_executable_get_symbol_fn;\n      hsa_api_.hsa_executable_symbol_get_info = table->core_->hsa_executable_symbol_get_info_fn;\n      hsa_api_.hsa_executable_iterate_symbols = table->core_->hsa_executable_iterate_symbols_fn;\n\n      hsa_api_.hsa_system_get_info = table->core_->hsa_system_get_info_fn;\n      hsa_api_.hsa_system_get_major_extension_table = table->core_->hsa_system_get_major_extension_table_fn;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = table->amd_ext_->hsa_amd_agent_iterate_memory_pools_fn;\n      hsa_api_.hsa_amd_memory_pool_get_info = table->amd_ext_->hsa_amd_memory_pool_get_info_fn;\n      hsa_api_.hsa_amd_memory_pool_allocate = table->amd_ext_->hsa_amd_memory_pool_allocate_fn;\n      hsa_api_.hsa_amd_agents_allow_access = table->amd_ext_->hsa_amd_agents_allow_access_fn;\n      hsa_api_.hsa_amd_memory_async_copy = table->amd_ext_->hsa_amd_memory_async_copy_fn;\n\n      hsa_api_.hsa_amd_signal_async_handler = table->amd_ext_->hsa_amd_signal_async_handler_fn;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = table->amd_ext_->hsa_amd_profiling_set_profiler_enabled_fn;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = table->amd_ext_->hsa_amd_profiling_get_async_copy_time_fn;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = table->amd_ext_->hsa_amd_profiling_get_dispatch_time_fn;\n    } else {\n      hsa_api_.hsa_init = hsa_init;\n      hsa_api_.hsa_shut_down = hsa_shut_down;\n      hsa_api_.hsa_agent_get_info = hsa_agent_get_info;\n      hsa_api_.hsa_iterate_agents = hsa_iterate_agents;\n\n      hsa_api_.hsa_queue_create = hsa_queue_create;\n      hsa_api_.hsa_queue_destroy = hsa_queue_destroy;\n      hsa_api_.hsa_queue_load_write_index_relaxed = hsa_queue_load_write_index_relaxed;\n      hsa_api_.hsa_queue_store_write_index_relaxed = hsa_queue_store_write_index_relaxed;\n      hsa_api_.hsa_queue_load_read_index_relaxed = hsa_queue_load_read_index_relaxed;\n\n      hsa_api_.hsa_signal_create = hsa_signal_create;\n      hsa_api_.hsa_signal_destroy = hsa_signal_destroy;\n      hsa_api_.hsa_signal_load_relaxed = hsa_signal_load_relaxed;\n      hsa_api_.hsa_signal_store_relaxed = hsa_signal_store_relaxed;\n      hsa_api_.hsa_signal_wait_scacquire = hsa_signal_wait_scacquire;\n      hsa_api_.hsa_signal_store_screlease = hsa_signal_store_screlease;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = hsa_code_object_reader_create_from_file;\n      hsa_api_.hsa_executable_create_alt = hsa_executable_create_alt;\n      hsa_api_.hsa_executable_load_agent_code_object = hsa_executable_load_agent_code_object;\n      hsa_api_.hsa_executable_freeze = hsa_executable_freeze;\n      hsa_api_.hsa_executable_get_symbol = hsa_executable_get_symbol;\n      hsa_api_.hsa_executable_symbol_get_info = hsa_executable_symbol_get_info;\n      hsa_api_.hsa_executable_iterate_symbols = hsa_executable_iterate_symbols;\n\n      hsa_api_.hsa_system_get_info = hsa_system_get_info;\n      hsa_api_.hsa_system_get_major_extension_table = hsa_system_get_major_extension_table;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = hsa_amd_agent_iterate_memory_pools;\n      hsa_api_.hsa_amd_memory_pool_get_info = hsa_amd_memory_pool_get_info;\n      hsa_api_.hsa_amd_memory_pool_allocate = hsa_amd_memory_pool_allocate;\n      hsa_api_.hsa_amd_agents_allow_access = hsa_amd_agents_allow_access;\n      hsa_api_.hsa_amd_memory_async_copy = hsa_amd_memory_async_copy;\n\n      hsa_api_.hsa_amd_signal_async_handler = hsa_amd_signal_async_handler;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = hsa_amd_profiling_set_profiler_enabled;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = hsa_amd_profiling_get_async_copy_time;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = hsa_amd_profiling_get_dispatch_time;\n    }\n  }\n}\n\nhsa_status_t HsaRsrcFactory::LoadAqlProfileLib(aqlprofile_pfn_t* api) {\n  void* handle = dlopen(kAqlProfileLib, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"Loading '%s' failed, %s\\n\", kAqlProfileLib, dlerror());\n    return HSA_STATUS_ERROR;\n  }\n  dlerror(); /* Clear any existing error */\n\n  api->hsa_ven_amd_aqlprofile_error_string =\n      (decltype(::hsa_ven_amd_aqlprofile_error_string)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_error_string\");\n  api->hsa_ven_amd_aqlprofile_validate_event =\n      (decltype(::hsa_ven_amd_aqlprofile_validate_event)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_validate_event\");\n  api->hsa_ven_amd_aqlprofile_start =\n      (decltype(::hsa_ven_amd_aqlprofile_start)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_start\");\n  api->hsa_ven_amd_aqlprofile_stop =\n      (decltype(::hsa_ven_amd_aqlprofile_stop)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_stop\");\n#ifdef AQLPROF_NEW_API\n  api->hsa_ven_amd_aqlprofile_read =\n      (decltype(::hsa_ven_amd_aqlprofile_read)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_read\");\n#endif\n  api->hsa_ven_amd_aqlprofile_legacy_get_pm4 =\n      (decltype(::hsa_ven_amd_aqlprofile_legacy_get_pm4)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_legacy_get_pm4\");\n  api->hsa_ven_amd_aqlprofile_get_info = (decltype(::hsa_ven_amd_aqlprofile_get_info)*)dlsym(\n      handle, \"hsa_ven_amd_aqlprofile_get_info\");\n  api->hsa_ven_amd_aqlprofile_iterate_data =\n      (decltype(::hsa_ven_amd_aqlprofile_iterate_data)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_iterate_data\");\n\n  return HSA_STATUS_SUCCESS;\n}\n\n// Add system agent info\nconst AgentInfo* HsaRsrcFactory::AddAgentInfo(const hsa_agent_t agent) {\n  // Determine if device is a Gpu agent\n  hsa_status_t status;\n  AgentInfo* agent_info = NULL;\n\n  hsa_device_type_t type;\n  status = hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_DEVICE, &type);\n  CHECK_STATUS(\"Error Calling hsa_agent_get_info\", status);\n\n  if (type == HSA_DEVICE_TYPE_CPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_CPU;\n    agent_info->dev_index = cpu_list_.size();\n\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->cpu_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (cpu_pool_ == NULL)) cpu_pool_ = &agent_info->cpu_pool;\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindKernArgPool, &agent_info->kern_arg_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (kern_arg_pool_ == NULL)) kern_arg_pool_ = &agent_info->kern_arg_pool;\n    agent_info->gpu_pool = {};\n\n    cpu_list_.push_back(agent_info);\n    cpu_agents_.push_back(agent);\n  }\n\n  if (type == HSA_DEVICE_TYPE_GPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_GPU;\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_NAME, agent_info->name);\n    strncpy(agent_info->gfxip, agent_info->name, 4);\n    agent_info->gfxip[4] = '\\0';\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_WAVEFRONT_SIZE, &agent_info->max_wave_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_QUEUE_MAX_SIZE, &agent_info->max_queue_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_PROFILE, &agent_info->profile);\n    agent_info->is_apu = (agent_info->profile == HSA_PROFILE_FULL) ? true : false;\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT),\n                       &agent_info->cu_num);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU),\n                       &agent_info->waves_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU),\n                       &agent_info->simds_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES),\n                       &agent_info->se_num);\n    hsa_api_.hsa_agent_get_info(agent,\n                       static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE),\n                       &agent_info->shader_arrays_per_se);\n\n    agent_info->cpu_pool = {};\n    agent_info->kern_arg_pool = {};\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->gpu_pool);\n    CHECK_ITER_STATUS(\"hsa_amd_agent_iterate_memory_pools(gpu pool)\", status);\n\n    // GFX8 and GFX9 SGPR/VGPR block sizes\n    agent_info->sgpr_block_dflt = (strcmp(agent_info->gfxip, \"gfx8\") == 0) ? 1 : 2;\n    agent_info->sgpr_block_size = 8;\n    agent_info->vgpr_block_size = 4;\n\n    // Set GPU index\n    agent_info->dev_index = gpu_list_.size();\n    gpu_list_.push_back(agent_info);\n    gpu_agents_.push_back(agent);\n  }\n\n  if (agent_info) agent_map_[agent.handle] = agent_info;\n\n  return agent_info;\n}\n\n// Return systen agent info\nconst AgentInfo* HsaRsrcFactory::GetAgentInfo(const hsa_agent_t agent) {\n  const AgentInfo* agent_info = NULL;\n  auto it = agent_map_.find(agent.handle);\n  if (it != agent_map_.end()) {\n    agent_info = it->second;\n  }\n  return agent_info;\n}\n\n// Get the count of Hsa Gpu Agents available on the platform\n//\n// @return uint32_t Number of Gpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfGpuAgents() { return uint32_t(gpu_list_.size()); }\n\n// Get the count of Hsa Cpu Agents available on the platform\n//\n// @return uint32_t Number of Cpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfCpuAgents() { return uint32_t(cpu_list_.size()); }\n\n// Get the AgentInfo handle of a Gpu device\n//\n// @param idx Gpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetGpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(gpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = gpu_list_[idx];\n\n  return true;\n}\n\n// Get the AgentInfo handle of a Cpu device\n//\n// @param idx Cpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetCpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(cpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = cpu_list_[idx];\n  return true;\n}\n\n// Create a Queue object and return its handle. The queue object is expected\n// to support user requested number of Aql dispatch packets.\n//\n// @param agent_info Gpu Agent on which to create a queue object\n//\n// @param num_Pkts Number of packets to be held by queue\n//\n// @param queue Output parameter updated with handle of queue object\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::CreateQueue(const AgentInfo* agent_info, uint32_t num_pkts,\n                                 hsa_queue_t** queue) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_queue_create(agent_info->dev_id, num_pkts, HSA_QUEUE_TYPE_MULTI, NULL, NULL,\n                            UINT32_MAX, UINT32_MAX, queue);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Create a Signal object and return its handle.\n// @param value Initial value of signal object\n// @param signal Output parameter updated with handle of signal object\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::CreateSignal(uint32_t value, hsa_signal_t* signal) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_signal_create(value, 0, NULL, signal);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Allocate memory for use by a kernel of specified size in specified\n// agent's memory region.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateLocalMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  status = hsa_api_.hsa_amd_memory_pool_allocate(agent_info->gpu_pool, size, 0, reinterpret_cast<void**>(&buffer));\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory to pass kernel parameters.\n// Memory is alocated accessible for all CPU agents and for GPU given by AgentInfo parameter.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateKernArgMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  if (!cpu_agents_.empty()) {\n    size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*kern_arg_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the kernel arguments\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate system memory accessible by both CPU and GPU\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateSysMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  if (!cpu_agents_.empty()) {\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*cpu_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the memory\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory for command buffer.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateCmdMemory(const AgentInfo* agent_info, size_t size) {\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  uint8_t* ptr = (agent_info->is_apu && CMD_MEMORY_MMAP)\n      ? reinterpret_cast<uint8_t*>(\n            mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, 0, 0))\n      : AllocateSysMemory(agent_info, size);\n  return ptr;\n}\n\n// Wait signal\nhsa_signal_value_t HsaRsrcFactory::SignalWait(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  const hsa_signal_value_t exp_value = signal_value - 1;\n  hsa_signal_value_t ret_value = signal_value;\n  while (1) {\n    ret_value =\n      hsa_api_.hsa_signal_wait_scacquire(signal, HSA_SIGNAL_CONDITION_LT, signal_value, timeout_, HSA_WAIT_STATE_BLOCKED);\n    if (ret_value == exp_value) break;\n    if (ret_value != signal_value) {\n      std::cerr << \"Error: HsaRsrcFactory::SignalWait: signal_value(\" << signal_value\n                << \"), ret_value(\" << ret_value << \")\" << std::endl << std::flush;\n      abort();\n    }\n  }\n  return ret_value;\n}\n\n// Wait signal with signal value restore\nvoid HsaRsrcFactory::SignalWaitRestore(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  SignalWait(signal, signal_value);\n  hsa_api_.hsa_signal_store_relaxed(const_cast<hsa_signal_t&>(signal), signal_value);\n}\n\n// Copy data from GPU to host memory\nbool HsaRsrcFactory::Memcpy(const hsa_agent_t& agent, void* dst, const void* src, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  if (!cpu_agents_.empty()) {\n    hsa_signal_t s = {};\n    status = hsa_api_.hsa_signal_create(1, 0, NULL, &s);\n    CHECK_STATUS(\"hsa_signal_create()\", status);\n    status = hsa_api_.hsa_amd_memory_async_copy(dst, cpu_agents_[0], src, agent, size, 0, NULL, s);\n    CHECK_STATUS(\"hsa_amd_memory_async_copy()\", status);\n    SignalWait(s, 1);\n    status = hsa_api_.hsa_signal_destroy(s);\n    CHECK_STATUS(\"hsa_signal_destroy()\", status);\n  }\n  return (status == HSA_STATUS_SUCCESS);\n}\nbool HsaRsrcFactory::Memcpy(const AgentInfo* agent_info, void* dst, const void* src, size_t size) {\n  return Memcpy(agent_info->dev_id, dst, src, size);\n}\n\n// Memory free method\nbool HsaRsrcFactory::FreeMemory(void* ptr) {\n  const hsa_status_t status = hsa_memory_free(ptr);\n  CHECK_STATUS(\"hsa_memory_free\", status);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Loads an Assembled Brig file and Finalizes it into Device Isa\n// @param agent_info Gpu device for which to finalize\n// @param brig_path File path of the Assembled Brig file\n// @param kernel_name Name of the kernel to finalize\n// @param code_desc Handle of finalized Code Descriptor that could\n// be used to submit for execution\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::LoadAndFinalize(const AgentInfo* agent_info, const char* brig_path,\n                                     const char* kernel_name, hsa_executable_t* executable,\n                                     hsa_executable_symbol_t* code_desc) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n\n  // Build the code object filename\n  std::string filename(brig_path);\n  std::clog << \"Code object filename: \" << filename << std::endl;\n\n  // Open the file containing code object\n  hsa_file_t file_handle = open(filename.c_str(), O_RDONLY);\n  if (file_handle == -1) {\n    std::cerr << \"Error: failed to load '\" << filename << \"'\" << std::endl;\n    assert(false);\n    return false;\n  }\n\n  // Create code object reader\n  hsa_code_object_reader_t code_obj_rdr = {0};\n  status = hsa_api_.hsa_code_object_reader_create_from_file(file_handle, &code_obj_rdr);\n  if (status != HSA_STATUS_SUCCESS) {\n    std::cerr << \"Failed to create code object reader '\" << filename << \"'\" << std::endl;\n    return false;\n  }\n\n  // Create executable.\n  status = hsa_api_.hsa_executable_create_alt(HSA_PROFILE_FULL, HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n                                     NULL, executable);\n  CHECK_STATUS(\"Error in creating executable object\", status);\n\n  // Load code object.\n  status = hsa_api_.hsa_executable_load_agent_code_object(*executable, agent_info->dev_id, code_obj_rdr,\n                                                 NULL, NULL);\n  CHECK_STATUS(\"Error in loading executable object\", status);\n\n  // Freeze executable.\n  status = hsa_api_.hsa_executable_freeze(*executable, \"\");\n  CHECK_STATUS(\"Error in freezing executable object\", status);\n\n  // Get symbol handle.\n  hsa_executable_symbol_t kernelSymbol;\n  status = hsa_api_.hsa_executable_get_symbol(*executable, NULL, kernel_name, agent_info->dev_id, 0,\n                                     &kernelSymbol);\n  CHECK_STATUS(\"Error in looking up kernel symbol\", status);\n\n  // Update output parameter\n  *code_desc = kernelSymbol;\n  return true;\n}\n\n// Print the various fields of Hsa Gpu Agents\nbool HsaRsrcFactory::PrintGpuAgents(const std::string& header) {\n  std::cout << std::flush;\n  std::clog << header << \" :\" << std::endl;\n\n  const AgentInfo* agent_info;\n  int size = uint32_t(gpu_list_.size());\n  for (int idx = 0; idx < size; idx++) {\n    agent_info = gpu_list_[idx];\n\n    std::clog << \"> agent[\" << idx << \"] :\" << std::endl;\n    std::clog << \">> Name : \" << agent_info->name << std::endl;\n    std::clog << \">> APU : \" << agent_info->is_apu << std::endl;\n    std::clog << \">> HSAIL profile : \" << agent_info->profile << std::endl;\n    std::clog << \">> Max Wave Size : \" << agent_info->max_wave_size << std::endl;\n    std::clog << \">> Max Queue Size : \" << agent_info->max_queue_size << std::endl;\n    std::clog << \">> CU number : \" << agent_info->cu_num << std::endl;\n    std::clog << \">> Waves per CU : \" << agent_info->waves_per_cu << std::endl;\n    std::clog << \">> SIMDs per CU : \" << agent_info->simds_per_cu << std::endl;\n    std::clog << \">> SE number : \" << agent_info->se_num << std::endl;\n    std::clog << \">> Shader Arrays per SE : \" << agent_info->shader_arrays_per_se << std::endl;\n  }\n  return true;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n\n  // adevance command queue\n  const uint64_t write_idx = hsa_api_.hsa_queue_load_write_index_relaxed(queue);\n  hsa_api_.hsa_queue_store_write_index_relaxed(queue, write_idx + 1);\n  while ((write_idx - hsa_api_.hsa_queue_load_read_index_relaxed(queue)) >= queue->size) {\n    sched_yield();\n  }\n\n  uint32_t slot_idx = (uint32_t)(write_idx % queue->size);\n  uint32_t* queue_slot = reinterpret_cast<uint32_t*>((uintptr_t)(queue->base_address) + (slot_idx * slot_size_b));\n  const uint32_t* slot_data = reinterpret_cast<const uint32_t*>(packet);\n\n  // Copy buffered commands into the queue slot.\n  // Overwrite the AQL invalid header (first dword) last.\n  // This prevents the slot from being read until it's fully written.\n  memcpy(&queue_slot[1], &slot_data[1], slot_size_b - sizeof(uint32_t));\n  std::atomic<uint32_t>* header_atomic_ptr =\n      reinterpret_cast<std::atomic<uint32_t>*>(&queue_slot[0]);\n  header_atomic_ptr->store(slot_data[0], std::memory_order_release);\n\n  // ringdoor bell\n  hsa_api_.hsa_signal_store_relaxed(queue->doorbell_signal, write_idx);\n\n  return write_idx;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet, size_t size_bytes) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n  if ((size_bytes & (slot_size_b - 1)) != 0) {\n    fprintf(stderr, \"HsaRsrcFactory::Submit: Bad packet size %zx\\n\", size_bytes);\n    abort();\n  }\n\n  const char* begin = reinterpret_cast<const char*>(packet);\n  const char* end = begin + size_bytes;\n  uint64_t write_idx = 0;\n  for (const char* ptr = begin; ptr < end; ptr += slot_size_b) {\n    write_idx = Submit(queue, ptr);\n  }\n\n  return write_idx;\n}\n\nconst char* HsaRsrcFactory::GetKernelName(uint64_t addr) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  const auto it = symbols_map_->find(addr);\n  if (it == symbols_map_->end()) {\n    fprintf(stderr, \"HsaRsrcFactory::kernel addr (0x%lx) is not found\\n\", addr);\n    abort();\n  }\n  return strdup(it->second);\n}\n\nvoid HsaRsrcFactory::EnableExecutableTracking(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  executable_tracking_on_ = true;\n  table->core_->hsa_executable_freeze_fn = hsa_executable_freeze_interceptor;\n}\n\nhsa_status_t HsaRsrcFactory::executable_symbols_cb(hsa_executable_t exec, hsa_executable_symbol_t symbol, void *data) {\n  hsa_symbol_kind_t value = (hsa_symbol_kind_t)0;\n  hsa_status_t status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_TYPE, &value);\n  CHECK_STATUS(\"Error in getting symbol info\", status);\n  if (value == HSA_SYMBOL_KIND_KERNEL) {\n    uint64_t addr = 0;\n    uint32_t len = 0;\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &addr);\n    CHECK_STATUS(\"Error in getting kernel object\", status);\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH, &len);\n    CHECK_STATUS(\"Error in getting name len\", status);\n    char *name = new char[len + 1];\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME, name);\n    CHECK_STATUS(\"Error in getting kernel name\", status);\n    name[len] = 0;\n    auto ret = symbols_map_->insert({addr, name});\n    if (ret.second == false) {\n      delete[] ret.first->second;\n      ret.first->second = name;\n    }\n  }\n  return HSA_STATUS_SUCCESS;\n}\n\nhsa_status_t HsaRsrcFactory::hsa_executable_freeze_interceptor(hsa_executable_t executable, const char *options) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  if (symbols_map_ == NULL) symbols_map_ = new symbols_map_t;\n  hsa_status_t status = hsa_api_.hsa_executable_iterate_symbols(executable, executable_symbols_cb, NULL);\n  CHECK_STATUS(\"Error in iterating executable symbols\", status);\n  return hsa_api_.hsa_executable_freeze(executable, options);;\n}\n\nstd::atomic<HsaRsrcFactory*> HsaRsrcFactory::instance_{};\nHsaRsrcFactory::mutex_t HsaRsrcFactory::mutex_;\nHsaRsrcFactory::timestamp_t HsaRsrcFactory::timeout_ns_ = HsaTimer::TIMESTAMP_MAX;\nhsa_pfn_t HsaRsrcFactory::hsa_api_{};\nbool HsaRsrcFactory::executable_tracking_on_ = false;\nHsaRsrcFactory::symbols_map_t* HsaRsrcFactory::symbols_map_ = NULL;\n\n}  // namespace util\n",
        "/tmp/vanessa/spack-stage/spack-stage-roctracer-dev-4.0.0-vwr5jy66t4editezfva7sumfoyaqloki/spack-src/src/core/loader.h": "#ifndef SRC_CORE_LOADER_H_\n#define SRC_CORE_LOADER_H_\n\n#include <atomic>\n#include <mutex>\n#include <dlfcn.h>\n\n#define ONLD_TRACE(str) \\\n  if (getenv(\"ROCP_ONLOAD_TRACE\")) do { \\\n    std::cout << \"PID(\" << GetPid() << \"): TRACER_LOADER::\" << __FUNCTION__ << \" \" << str << std::endl << std::flush; \\\n  } while(0);\n\nnamespace roctracer {\n\n// Base runtime loader class\ntemplate <class T>\nclass BaseLoader : public T {\n  static uint32_t GetPid() { return syscall(__NR_getpid); }\n\n  public:\n  typedef std::mutex mutex_t;\n  typedef BaseLoader<T> loader_t;\n\n  bool Enabled() const { return (handle_ != NULL); }\n\n  template <class fun_t>\n  fun_t* GetFun(const char* fun_name) {\n    if (handle_ == NULL) return NULL;\n\n    fun_t *f = (fun_t*) dlsym(handle_, fun_name);\n    if ((to_check_symb_ == true) && (f == NULL)) {\n      fprintf(stderr, \"roctracer: symbol lookup '%s' failed: \\\"%s\\\"\\n\", fun_name, dlerror());\n      abort();\n    }\n    return f;\n  }\n\n  static inline loader_t& Instance() {\n    loader_t* obj = instance_.load(std::memory_order_acquire);\n    if (obj == NULL) {\n      std::lock_guard<mutex_t> lck(mutex_);\n      if (instance_.load(std::memory_order_relaxed) == NULL) {\n        obj = new loader_t();\n        instance_.store(obj, std::memory_order_release);\n      }\n    }\n    return *instance_;\n  }\n\n  static loader_t* GetRef() { return instance_; }\n  static void SetLibName(const char *name) { lib_name_ = name; }\n\n  private:\n  BaseLoader() {\n    const int flags = (to_load_ == true) ? RTLD_LAZY : RTLD_LAZY|RTLD_NOLOAD;\n    handle_ = dlopen(lib_name_, flags);\n    ONLD_TRACE(\"(\" << lib_name_ << \" = \" << handle_ << \")\");\n    if ((to_check_open_ == true) && (handle_ == NULL)) {\n      fprintf(stderr, \"roctracer: Loading '%s' failed, %s\\n\", lib_name_, dlerror());\n      abort();\n    }\n\n    T::init(this);\n  }\n\n  ~BaseLoader() {\n    if (handle_ != NULL) dlclose(handle_);\n  }\n\n  static bool to_load_;\n  static bool to_check_open_;\n  static bool to_check_symb_;\n\n  static mutex_t mutex_;\n  static const char* lib_name_;\n  static std::atomic<loader_t*> instance_;\n  void* handle_;\n};\n\n// 'rocprofiler' library loader class\nclass RocpApi {\n  public:\n  typedef BaseLoader<RocpApi> Loader;\n\n  typedef bool (RegisterCallback_t)(uint32_t op, void* callback, void* arg);\n  typedef bool (OperateCallback_t)(uint32_t op);\n  typedef bool (InitCallback_t)(void* callback, void* arg);\n  typedef bool (EnableCallback_t)(uint32_t op, bool enable);\n  typedef const char* (NameCallback_t)(uint32_t op);\n\n  RegisterCallback_t* RegisterApiCallback;\n  OperateCallback_t* RemoveApiCallback;\n  InitCallback_t* InitActivityCallback;\n  EnableCallback_t* EnableActivityCallback;\n  NameCallback_t* GetOpName;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<OperateCallback_t>(\"RemoveApiCallback\");\n    InitActivityCallback = loader->GetFun<InitCallback_t>(\"InitActivityCallback\");\n    EnableActivityCallback = loader->GetFun<EnableCallback_t>(\"EnableActivityCallback\");\n    GetOpName = loader->GetFun<NameCallback_t>(\"GetOpName\");\n  }\n};\n\n// HIP runtime library loader class\n#if STATIC_BUILD\n__attribute__((weak)) hipError_t hipRegisterApiCallback(uint32_t id, void* fun, void* arg) { return hipErrorUnknown; }\n__attribute__((weak)) hipError_t hipRemoveApiCallback(uint32_t id) { return hipErrorUnknown; }\n__attribute__((weak)) hipError_t hipRegisterActivityCallback(uint32_t id, void* fun, void* arg) { return hipErrorUnknown; }\n__attribute__((weak)) hipError_t hipRemoveActivityCallback(uint32_t id) { return hipErrorUnknown; }\n__attribute__((weak)) const char* hipKernelNameRef(const hipFunction_t f) { return NULL; }\n__attribute__((weak)) const char* hipKernelNameRefByPtr(const void* hostFunction, hipStream_t stream) { return NULL; }\n__attribute__((weak)) int hipGetStreamDeviceId(hipStream_t stream) { return 0; }\n__attribute__((weak)) const char* hipApiName(uint32_t id) { return NULL; }\n\nclass HipLoaderStatic {\n  public:\n  typedef std::mutex mutex_t;\n  typedef HipLoaderStatic loader_t;\n  typedef std::atomic<loader_t*> instance_t;\n\n  typedef hipError_t (RegisterApiCallback_t)(uint32_t id, void* fun, void* arg);\n  typedef hipError_t (RemoveApiCallback_t)(uint32_t id);\n  typedef hipError_t (RegisterActivityCallback_t)(uint32_t id, void* fun, void* arg);\n  typedef hipError_t (RemoveActivityCallback_t)(uint32_t id);\n  typedef const char* (KernelNameRef_t)(const hipFunction_t f);\n  typedef const char* (KernelNameRefByPtr_t)(const void* hostFunction, hipStream_t stream);\n  typedef int (GetStreamDeviceId_t)(hipStream_t stream);\n  typedef const char* (ApiName_t)(uint32_t id);\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n  RegisterActivityCallback_t* RegisterActivityCallback;\n  RemoveActivityCallback_t* RemoveActivityCallback;\n  KernelNameRef_t* KernelNameRef;\n  KernelNameRefByPtr_t* KernelNameRefByPtr;\n  GetStreamDeviceId_t* GetStreamDeviceId;\n  ApiName_t* ApiName;\n\n  static inline loader_t& Instance() {\n    loader_t* obj = instance_.load(std::memory_order_acquire);\n    if (obj == NULL) {\n      std::lock_guard<mutex_t> lck(mutex_);\n      if (instance_.load(std::memory_order_relaxed) == NULL) {\n        obj = new loader_t();\n        instance_.store(obj, std::memory_order_release);\n      }\n    }\n    return *instance_;\n  }\n\n  bool Enabled() const { return true; }\n\n  private:\n  HipLoaderStatic() {\n    RegisterApiCallback = hipRegisterApiCallback;\n    RemoveApiCallback = hipRemoveApiCallback;\n    RegisterActivityCallback = hipRegisterActivityCallback;\n    RemoveActivityCallback = hipRemoveActivityCallback;\n    KernelNameRef = hipKernelNameRef;\n    KernelNameRefByPtr = hipKernelNameRefByPtr;\n    GetStreamDeviceId =  hipGetStreamDeviceId;\n    ApiName = hipApiName;\n  }\n\n  static mutex_t mutex_;\n  static instance_t instance_;\n};\n#else\nclass HipApi {\n  public:\n  typedef BaseLoader<HipApi> Loader;\n\n  typedef decltype(hipRegisterApiCallback) RegisterApiCallback_t;\n  typedef decltype(hipRemoveApiCallback) RemoveApiCallback_t;\n  typedef decltype(hipRegisterActivityCallback) RegisterActivityCallback_t;\n  typedef decltype(hipRemoveActivityCallback) RemoveActivityCallback_t;\n  typedef decltype(hipKernelNameRef) KernelNameRef_t;\n  typedef decltype(hipKernelNameRefByPtr) KernelNameRefByPtr_t;\n  typedef decltype(hipGetStreamDeviceId) GetStreamDeviceId_t;\n  typedef decltype(hipApiName) ApiName_t;\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n  RegisterActivityCallback_t* RegisterActivityCallback;\n  RemoveActivityCallback_t* RemoveActivityCallback;\n  KernelNameRef_t* KernelNameRef;\n  KernelNameRefByPtr_t* KernelNameRefByPtr;\n  GetStreamDeviceId_t* GetStreamDeviceId;\n  ApiName_t* ApiName;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"hipRegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"hipRemoveApiCallback\");\n    RegisterActivityCallback = loader->GetFun<RegisterActivityCallback_t>(\"hipRegisterActivityCallback\");\n    RemoveActivityCallback = loader->GetFun<RemoveActivityCallback_t>(\"hipRemoveActivityCallback\");\n    KernelNameRef = loader->GetFun<KernelNameRef_t>(\"hipKernelNameRef\");\n    KernelNameRefByPtr = loader->GetFun<KernelNameRefByPtr_t>(\"hipKernelNameRefByPtr\");\n    GetStreamDeviceId =  loader->GetFun<GetStreamDeviceId_t>(\"hipGetStreamDeviceId\");\n    ApiName = loader->GetFun<ApiName_t>(\"hipApiName\");\n  }\n};\n#endif\n\n// HCC runtime library loader class\n#include \"inc/roctracer_hcc.h\"\nclass HccApi {\n  public:\n  typedef BaseLoader<HccApi> Loader;\n\n  hipInitAsyncActivityCallback_t* InitActivityCallback;\n  hipEnableAsyncActivityCallback_t* EnableActivityCallback;\n  hipGetOpName_t* GetOpName;\n\n  protected:\n  void init(Loader* loader) {\n#if HIP_VDI\n    InitActivityCallback = loader->GetFun<hipInitAsyncActivityCallback_t>(\"hipInitActivityCallback\");\n    EnableActivityCallback = loader->GetFun<hipEnableAsyncActivityCallback_t>(\"hipEnableActivityCallback\");\n    GetOpName = loader->GetFun<hipGetOpName_t>(\"hipGetCmdName\");\n#else\n    InitActivityCallback = loader->GetFun<hipInitAsyncActivityCallback_t>(\"InitActivityCallbackImpl\");\n    EnableActivityCallback = loader->GetFun<hipEnableAsyncActivityCallback_t>(\"EnableActivityCallbackImpl\");\n    GetOpName = loader->GetFun<hipGetOpName_t>(\"GetCmdNameImpl\");\n#endif\n  }\n};\n\n// KFD runtime library loader class\nclass KfdApi {\n  public:\n  typedef BaseLoader<KfdApi> Loader;\n\n  typedef bool (RegisterApiCallback_t)(uint32_t op, void* callback, void* arg);\n  typedef bool (RemoveApiCallback_t)(uint32_t op);\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"RemoveApiCallback\");\n  }\n};\n\n// rocTX runtime library loader class\n#include \"inc/roctracer_roctx.h\"\nclass RocTxApi {\n  public:\n  typedef BaseLoader<RocTxApi> Loader;\n\n  typedef decltype(RegisterApiCallback) RegisterApiCallback_t;\n  typedef decltype(RemoveApiCallback) RemoveApiCallback_t;\n  typedef decltype(RangeStackIterate) RangeStackIterate_t;\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n  RangeStackIterate_t* RangeStackIterate;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"RemoveApiCallback\");\n    RangeStackIterate = loader->GetFun<RangeStackIterate_t>(\"RangeStackIterate\");\n  }\n};\n\ntypedef BaseLoader<RocpApi> RocpLoader;\ntypedef BaseLoader<HccApi> HccLoader;\ntypedef BaseLoader<KfdApi> KfdLoader;\ntypedef BaseLoader<RocTxApi> RocTxLoader;\n\n#if STATIC_BUILD\ntypedef HipLoaderStatic HipLoader;\n#else\ntypedef BaseLoader<HipApi> HipLoaderShared;\ntypedef HipLoaderShared HipLoader;\n#endif\n\n} // namespace roctracer\n\n#define LOADER_INSTANTIATE_2() \\\n  template<class T> typename roctracer::BaseLoader<T>::mutex_t roctracer::BaseLoader<T>::mutex_; \\\n  template<class T> std::atomic<roctracer::BaseLoader<T>*> roctracer::BaseLoader<T>::instance_{}; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_load_ = false; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_check_open_ = true; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_check_symb_ = true; \\\n  template<> const char* roctracer::RocpLoader::lib_name_ = \"librocprofiler64.so\"; \\\n  template<> const char* roctracer::HccLoader::lib_name_ = \"libamdhip64.so\"; \\\n  template<> bool roctracer::HccLoader::to_check_open_ = false; \\\n  template<> const char* roctracer::KfdLoader::lib_name_ = \"libkfdwrapper64.so\"; \\\n  template<> const char* roctracer::RocTxLoader::lib_name_ = \"libroctx64.so\"; \\\n  template<> bool roctracer::RocTxLoader::to_load_ = true;\n\n#if STATIC_BUILD\n#define LOADER_INSTANTIATE_HIP() \\\n  roctracer::HipLoaderStatic::mutex_t roctracer::HipLoaderStatic::mutex_; \\\n  roctracer::HipLoaderStatic::instance_t roctracer::HipLoaderStatic::instance_{};\n#else\n#define LOADER_INSTANTIATE_HIP() \\\n  template<> const char* roctracer::HipLoaderShared::lib_name_ = \"libamdhip64.so\"; \\\n  template<> bool roctracer::HipLoaderShared::to_check_open_ = false;\n#endif\n\n#if HIP_VDI\n#define LOADER_INSTANTIATE() \\\n  LOADER_INSTANTIATE_2(); \\\n  LOADER_INSTANTIATE_HIP();\n#else\n#error HCC support dropped\n#endif\n\n#endif // SRC_CORE_LOADER_H_\n"
    },
    "skipped": [],
    "total_files": 71
}