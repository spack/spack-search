{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-hip-3.7.0-dey3i2gzevyztggljq7swpt36fzfmvc4/spack-src/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-hip-3.7.0-dey3i2gzevyztggljq7swpt36fzfmvc4/spack-src/tests/src/dynamicLoading/complex_loading_behavior.cpp": "/*\nCopyright (c) 2019 Advanced Micro Devices, Inc. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* HIT_START\n * BUILD_CMD: libfoo_amd %hc %S/%s -o libfoo.so -Xcompiler -fPIC -lpthread -shared -DTEST_SHARED_LIBRARY EXCLUDE_HIP_PLATFORM nvcc\n * BUILD_CMD: libfoo_nvidia %hc %S/%s -o libfoo.so -Xcompiler -fPIC -lpthread -shared -DTEST_SHARED_LIBRARY EXCLUDE_HIP_PLATFORM hcc rocclr\n * BUILD_CMD: %t %hc %S/%s -o %T/%t -ldl\n * TEST: %t\n * HIT_END\n */\n\n#if !defined(TEST_SHARED_LIBRARY)\n\n#include <dlfcn.h>\n#include <iostream>\n#include <hip/hip_runtime.h>\n\n#define CHECK(cmd)                                                                                 \\\n    {                                                                                              \\\n        hipError_t error = cmd;                                                                    \\\n        if (error != hipSuccess) {                                                                 \\\n            fprintf(stderr, \"error: '%s'(%d) at %s:%d\\n\", hipGetErrorString(error), error,         \\\n                    __FILE__, __LINE__);                                                           \\\n            return (EXIT_FAILURE);                                                                    \\\n        }                                                                                          \\\n    }\n\n__global__ void vector_add(float* C, float* A, float* B, size_t N) {\n  size_t offset = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;\n  size_t stride = hipBlockDim_x * hipGridDim_x;\n  for (size_t i = offset; i < N; i += stride) {\n    C[i] = A[i] + B[i];\n  }\n}\n\nint launch_local_kernel() {\n    float *A_d, *B_d, *C_d;\n    float *A_h, *B_h, *C_h;\n    size_t N = 1000000;\n    size_t Nbytes = N * sizeof(float);\n    static int device = 0;\n    CHECK(hipSetDevice(device));\n    hipDeviceProp_t props;\n    CHECK(hipGetDeviceProperties(&props, device /*deviceID*/));\n    A_h = (float*)malloc(Nbytes);\n    CHECK(A_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    B_h = (float*)malloc(Nbytes);\n    CHECK(B_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    C_h = (float*)malloc(Nbytes);\n    CHECK(C_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    // Fill with Phi + i\n    for (size_t i = 0; i < N; i++) {\n        A_h[i] = 1.618f + i;\n        B_h[i] = 1.618f + i;\n    }\n\n    CHECK(hipMalloc(&A_d, Nbytes));\n    CHECK(hipMalloc(&B_d, Nbytes));\n    CHECK(hipMalloc(&C_d, Nbytes));\n    CHECK(hipMemcpy(A_d, A_h, Nbytes, hipMemcpyHostToDevice));\n    CHECK(hipMemcpy(B_d, B_h, Nbytes, hipMemcpyHostToDevice));\n\n    const unsigned blocks = 512;\n    const unsigned threadsPerBlock = 256;\n    hipLaunchKernelGGL(vector_add, dim3(blocks), dim3(threadsPerBlock), 0, 0, C_d, A_d, B_d, N);\n    CHECK(hipMemcpy(C_h, C_d, Nbytes, hipMemcpyDeviceToHost));\n\n    CHECK(hipFree(A_d));\n    CHECK(hipFree(B_d));\n    CHECK(hipFree(C_d));\n\n    free(A_h);\n    free(B_h);\n    free(C_h);\n\n    std::cout << \"PASSED!\\n\";\n    return 0;\n}\n\nint launch_dynamically_loaded_kernel() {\n  void* handle = dlopen(\"./libfoo.so\", RTLD_LAZY);\n  if (!handle) {\n    std::cout << dlerror() << \"\\n\";\n    return -1;\n  }\n  std::cout << \"loaded libfoo.so\\n\";\n\n  void* sym = dlsym(handle, \"foo\");\n  if (!sym) {\n    std::cout << \"unable to locate foo within libfoo.so\\n\";\n    std::cout << dlerror() << \"\\n\";\n    dlclose(handle);\n    return -1;\n  }\n\n  int(*fp)() = reinterpret_cast<int(*)()>(sym);\n\n  int ret = fp();\n  if (ret) {\n    std::cout << \"dynamic launch failed\\n\";\n  } else {\n    std::cout << \"dynamic launch succeeded\\n\";\n  }\n\n  dlclose(handle);\n  return ret;\n}\n\nint main() {\n  int ret = 0;\n  ret = launch_local_kernel();\n  if (ret) {\n    return ret;\n  }\n\n  ret = launch_dynamically_loaded_kernel();\n  if (ret) {\n    return ret;\n  }\n\n  return 0;\n}\n\n#else // !defined(TEST_SHARED_LIBRARY)\n\n#include <dlfcn.h>\n#include <iostream>\n#include <hip/hip_runtime.h>\n\n#define CHECK(cmd)                                                                                 \\\n    {                                                                                              \\\n        hipError_t error = cmd;                                                                    \\\n        if (error != hipSuccess) {                                                                 \\\n            fprintf(stderr, \"error: '%s'(%d) at %s:%d\\n\", hipGetErrorString(error), error,         \\\n                    __FILE__, __LINE__);                                                           \\\n            return (EXIT_FAILURE);                                                                 \\\n        }                                                                                          \\\n    }\n\n__global__ void vadd(float* C, float* A, float* B, size_t N) {\n  size_t offset = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;\n  size_t stride = hipBlockDim_x * hipGridDim_x;\n  for (size_t i = offset; i < N; i += stride) {\n    C[i] = A[i] + B[i];\n  }\n}\n\nextern \"C\" int foo() {\n    float *A_d, *B_d, *C_d;\n    float *A_h, *B_h, *C_h;\n    size_t N = 1000000;\n    size_t Nbytes = N * sizeof(float);\n    static int device = 0;\n    CHECK(hipSetDevice(device));\n    hipDeviceProp_t props;\n    CHECK(hipGetDeviceProperties(&props, device /*deviceID*/));\n    A_h = (float*)malloc(Nbytes);\n    CHECK(A_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    B_h = (float*)malloc(Nbytes);\n    CHECK(B_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    C_h = (float*)malloc(Nbytes);\n    CHECK(C_h == 0 ? hipErrorOutOfMemory : hipSuccess);\n    // Fill with Phi + i\n    for (size_t i = 0; i < N; i++) {\n        A_h[i] = 1.618f + i;\n        B_h[i] = 1.618f + i;\n    }\n\n    CHECK(hipMalloc(&A_d, Nbytes));\n    CHECK(hipMalloc(&B_d, Nbytes));\n    CHECK(hipMalloc(&C_d, Nbytes));\n    CHECK(hipMemcpy(A_d, A_h, Nbytes, hipMemcpyHostToDevice));\n    CHECK(hipMemcpy(B_d, B_h, Nbytes, hipMemcpyHostToDevice));\n\n    const unsigned blocks = 512;\n    const unsigned threadsPerBlock = 256;\n    std::cout << \"Launch vadd\\n\";\n    hipLaunchKernelGGL(vadd, dim3(blocks), dim3(threadsPerBlock), 0, 0, C_d, A_d, B_d, N);\n    CHECK(hipMemcpy(C_h, C_d, Nbytes, hipMemcpyDeviceToHost));\n\n    CHECK(hipFree(A_d));\n    CHECK(hipFree(B_d));\n    CHECK(hipFree(C_d));\n\n    free(A_h);\n    free(B_h);\n    free(C_h);\n\n    return 0;\n}\n\n#endif // !defined(TEST_SHARED_LIBRARY)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-hip-3.7.0-dey3i2gzevyztggljq7swpt36fzfmvc4/spack-src/tests/src/runtimeApi/module/vcpy_kernel.code",
        "/tmp/vanessa/spack-stage/spack-stage-hip-3.7.0-dey3i2gzevyztggljq7swpt36fzfmvc4/spack-src/tests/hipify-clang/unit_tests/libraries/cuSPARSE/cuSPARSE_12.cu",
        "/tmp/vanessa/spack-stage/spack-stage-hip-3.7.0-dey3i2gzevyztggljq7swpt36fzfmvc4/spack-src/samples/1_Utils/hipCommander/nullkernel.hsaco"
    ],
    "total_files": 689
}