{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/tools/simgrid.supp": "# Valgrind suppressions for stuff that we cannot control\n\n# Memory leaks in standard tools (e.g. dash, tail, or sort)\n{\n   Memory leak in /bin tools\n   Memcheck:Leak\n   ...\n   obj:/bin/*\n}\n\n{\n   Memory leak in /usr/bin tools\n   Memcheck:Leak\n   ...\n   obj:/usr/bin/*\n}\n\n# There's a constant leak of 56 bytes in the depths of libc which\n# manifests, for example, when using backtrace()\n{\n   Memory leak in libc/dlopen with -pthread\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:do_dlopen\n   fun:_dl_catch_error\n   fun:dlerror_run\n   fun:__libc_dlopen_mode\n}\n\n# Another problem in glibc, where makecontext does not reset the EBP register,\n# and backtrace goes too far when walking up the stack frames\n{\n   Invalid read in backtrace, called after makecontext\n   Memcheck:Addr4\n   fun:backtrace\n   ...\n   fun:makecontext\n}\n\n# Memory leaks appearing to be in libcgraph.  They can be seen with the\n# following simple program:\n# ,----\n# | #include <stdio.h>\n# | #include <graphviz/cgraph.h>\n# | int main(int argc, char *argv[])\n# | {\n# |     if (argc == 1) {\n# |         printf(\"Usage: %s <dotfile>\\n\", argv[0]);\n# |         return 1;\n# |     }\n# |     Agraph_t *g;\n# |     FILE *inf = fopen(argv[1], \"r\");\n# |     g = agread(inf, 0);\n# |     fclose(inf);\n# |     agclose(g);\n# |     return 0;\n# | }\n# `----\n{\n   Memory leak in libcgraph (1/2)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   obj:/usr/lib/libcgraph.so*\n   fun:aaglex\n   fun:aagparse\n   fun:agconcat\n}\n{\n   Memory leak in libcgraph (2/2)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:agnode\n   obj:/usr/lib/libcgraph.so*\n   fun:aagparse\n   fun:agconcat\n}\n\n# We're not interested by memory leaks in the Lua interpreter\n{\n   Memory leak in lua\n   Memcheck:Leak\n   ...\n   fun:luaD_precall\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/tools/cmake/CompleteInFiles.cmake": "set(CMAKE_MODULE_PATH\n  ${CMAKE_MODULE_PATH}\n  ${CMAKE_HOME_DIRECTORY}/tools/cmake/Modules\n  )\n\n# x86_64\n# x86\n# i.86\n\n### Determine the assembly flavor that we need today\ninclude(CMakeDetermineSystem)\nIF(CMAKE_SYSTEM_PROCESSOR MATCHES \".86|AMD64|amd64\")\n  IF(${ARCH_32_BITS})\n    message(STATUS \"System processor: i686 (${CMAKE_SYSTEM_PROCESSOR}, 32 bits)\")\n    set(PROCESSOR_i686 1)\n  ELSE()\n    message(STATUS \"System processor: x86_64 (${CMAKE_SYSTEM_PROCESSOR}, 64 bits)\")\n    set(PROCESSOR_x86_64 1)\n  ENDIF()\n  if (MSVC)\n    message(STATUS \"Disable fast raw contextes on Microsoft Visual.\")\n  else()\n    set(HAVE_RAWCTX 1)\n  endif()\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^alpha\")\n  message(STATUS \"System processor: alpha\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^arm\")\n  # Subdir is \"arm\" for both big-endian (arm) and little-endian (armel).\n  message(STATUS \"System processor: arm\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^mips\")\n  # mips* machines are bi-endian mostly so processor does not tell\n  # endianess of the underlying system.\n  message(STATUS \"System processor: ${CMAKE_SYSTEM_PROCESSOR}\" \"mips\" \"mipsel\" \"mipseb\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(powerpc|ppc)64\")\n  message(STATUS \"System processor: ppc64\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(powerpc|ppc)\")\n  message(STATUS \"System processor: ppc\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^sparc\")\n  # Both flavours can run on the same processor\n  message(STATUS \"System processor: ${CMAKE_SYSTEM_PROCESSOR}\" \"sparc\" \"sparcv9\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(parisc|hppa)\")\n  message(STATUS \"System processor: parisc\" \"parisc64\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^s390\")\n  # s390 binaries can run on s390x machines\n  message(STATUS \"System processor: ${CMAKE_SYSTEM_PROCESSOR}\" \"s390\" \"s390x\")\n\nELSEIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"^sh\")\n  message(STATUS \"System processor: sh\")\n\nELSE() #PROCESSOR NOT FOUND\n  message(STATUS \"PROCESSOR NOT FOUND: ${CMAKE_SYSTEM_PROCESSOR}\")\n\nENDIF()\n\nif(ARCH_32_BITS)\n  set(MPI_ADDRESS_SIZE 4)\nelse()\n  set(MPI_ADDRESS_SIZE 8)\nendif()\n\ninclude(CheckFunctionExists)\ninclude(CheckTypeSize)\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\ninclude(TestBigEndian)\nTEST_BIG_ENDIAN(BIGENDIAN)\n\ninclude(FindGraphviz)\ninclude(FindLibSigc++)\n\nif(enable_java)\n  find_package(Java REQUIRED COMPONENTS Runtime Development)\n  find_package(JNI REQUIRED)\n  message(\"-- [Java] JNI found: ${JNI_FOUND}\")\n  message(\"-- [Java] JNI include dirs: ${JNI_INCLUDE_DIRS}\")\n  if(enable_maintainer_mode)\n    find_package(SWIG REQUIRED)\n    include(UseSWIG)\n    message(\"-- [Java] Swig found: ${SWIG_FOUND} (version ${SWIG_VERSION})\")\n  endif()\n  set(HAVE_Java 1)\nendif()\nif(enable_scala)\n  find_package(Scala REQUIRED)\n  message(\"-- [Scala] scalac found: ${SCALA_COMPILE}\")\n  set(HAVE_Scala 1)\nendif()\nif(enable_lua)\n  include(FindLua51Simgrid)\nendif()\n\nset(HAVE_NS3 0)\nif(enable_ns3)\n  include(FindNS3)\n  if (NOT HAVE_NS3)\n    message(FATAL_ERROR \"Cannot find NS3. Please install it (apt-get install ns3 libns3-dev) or disable that cmake option\")\n  endif()\nendif()\n\nfind_package(Boost 1.48)\nif(Boost_FOUND)\n  include_directories(${Boost_INCLUDE_DIRS})\nelse()\n  if(APPLE)\n    message(FATAL_ERROR \"Failed to find Boost libraries (Try to install them with 'sudo fink install boost1.53.nopython')\")\n  else()\n    message(FATAL_ERROR \"Failed to find Boost libraries.\"\n                        \"Did you install libboost-dev and libboost-context-dev?\"\n                        \"(libboost-context-dev is optional)\")\n  endif()\nendif()\n\n# Try again to see if we have libboost-context\nfind_package(Boost 1.42 COMPONENTS context)\nset(Boost_FOUND 1) # We don't care of whether this component is missing\n\nif(Boost_FOUND AND Boost_CONTEXT_FOUND)\n  # We should use feature detection for this instead:\n  if (Boost_VERSION LESS 105600)\n    message(\"Found Boost.Context API v1\")\n    set(HAVE_BOOST_CONTEXT 1)\n  else()\n    message(\"Found Boost.Context API v2\")\n    set(HAVE_BOOST_CONTEXT 2)\n  endif()\nelse()\n  message (\"   boost        : found.\")\n  message (\"   boost-context: missing. Install libboost-context-dev for this optional feature.\")\n  set(HAVE_BOOST_CONTEXT 0)\nendif()\n\n# Checks for header libraries functions.\nCHECK_LIBRARY_EXISTS(dl      dlopen                  \"\" HAVE_DLOPEN_IN_LIBDL)\nCHECK_LIBRARY_EXISTS(execinfo backtrace              \"\" HAVE_BACKTRACE_IN_LIBEXECINFO)\nCHECK_LIBRARY_EXISTS(pthread pthread_create          \"\" HAVE_PTHREAD)\nCHECK_LIBRARY_EXISTS(pthread sem_init                \"\" HAVE_SEM_INIT_LIB)\nCHECK_LIBRARY_EXISTS(pthread sem_open                \"\" HAVE_SEM_OPEN_LIB)\nCHECK_LIBRARY_EXISTS(pthread sem_timedwait           \"\" HAVE_SEM_TIMEDWAIT_LIB)\nCHECK_LIBRARY_EXISTS(pthread pthread_mutex_timedlock \"\" HAVE_MUTEX_TIMEDLOCK_LIB)\nCHECK_LIBRARY_EXISTS(rt      clock_gettime           \"\" HAVE_POSIX_GETTIME)\n\nif(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_XOPEN_SOURCE=700 -D_DARWIN_C_SOURCE\")\nelseif(MINGW)\n  add_definitions(-D__USE_MINGW_ANSI_STDIO=1)\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D__USE_MINGW_ANSI_STDIO=1\")\nelse()\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_GNU_SOURCE\")\nendif()\n\nCHECK_INCLUDE_FILES(\"stdlib.h;stdarg.h;string.h;float.h\" STDC_HEADERS)\nCHECK_INCLUDE_FILE(\"valgrind/valgrind.h\" HAVE_VALGRIND_VALGRIND_H)\nCHECK_INCLUDE_FILE(\"socket.h\" HAVE_SOCKET_H)\nCHECK_INCLUDE_FILE(\"stat.h\" HAVE_STAT_H)\nCHECK_INCLUDE_FILE(\"sys/stat.h\" HAVE_SYS_STAT_H)\nCHECK_INCLUDE_FILE(\"windows.h\" HAVE_WINDOWS_H)\nCHECK_INCLUDE_FILE(\"errno.h\" HAVE_ERRNO_H)\nCHECK_INCLUDE_FILE(\"unistd.h\" HAVE_UNISTD_H)\nCHECK_INCLUDE_FILE(\"execinfo.h\" HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILE(\"signal.h\" HAVE_SIGNAL_H)\nCHECK_INCLUDE_FILE(\"sys/time.h\" HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILE(\"sys/param.h\" HAVE_SYS_PARAM_H)\nCHECK_INCLUDE_FILE(\"sys/sysctl.h\" HAVE_SYS_SYSCTL_H)\nCHECK_INCLUDE_FILE(\"time.h\" HAVE_TIME_H)\nCHECK_INCLUDE_FILE(\"string.h\" HAVE_STRING_H)\nCHECK_INCLUDE_FILE(\"ucontext.h\" HAVE_UCONTEXT_H)\nCHECK_INCLUDE_FILE(\"stdio.h\" HAVE_STDIO_H)\nCHECK_INCLUDE_FILE(\"linux/futex.h\" HAVE_FUTEX_H)\n\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\nCHECK_FUNCTION_EXISTS(nanosleep HAVE_NANOSLEEP)\nCHECK_FUNCTION_EXISTS(getdtablesize HAVE_GETDTABLESIZE)\nCHECK_FUNCTION_EXISTS(sysconf HAVE_SYSCONF)\nCHECK_FUNCTION_EXISTS(readv HAVE_READV)\nCHECK_FUNCTION_EXISTS(popen HAVE_POPEN)\nCHECK_FUNCTION_EXISTS(signal HAVE_SIGNAL)\n\nCHECK_SYMBOL_EXISTS(snprintf stdio.h HAVE_SNPRINTF)\nCHECK_SYMBOL_EXISTS(vsnprintf stdio.h HAVE_VSNPRINTF)\nCHECK_SYMBOL_EXISTS(asprintf stdio.h HAVE_ASPRINTF)\nCHECK_SYMBOL_EXISTS(vasprintf stdio.h HAVE_VASPRINTF)\n\nif(MINGW) \n  # The detection of asprintf fails on MinGW, assumingly because it's\n  # defined as an inline function in stdio.h instead of a regular\n  # function. So force the result to be 1 despite of the test.\n  set(HAVE_ASPRINTF 1)\n  set(HAVE_VASPRINTF 1)\nendif()\n\nCHECK_FUNCTION_EXISTS(makecontext HAVE_MAKECONTEXT)\nCHECK_FUNCTION_EXISTS(process_vm_readv HAVE_PROCESS_VM_READV)\n\nCHECK_FUNCTION_EXISTS(mmap HAVE_MMAP)\n\n#Check if __thread is defined\nexecute_process(\n  COMMAND \"${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_thread_storage.c\"\n  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n  RESULT_VARIABLE HAVE_thread_storage_run\n  )\n\nif(HAVE_thread_storage_run)\n  set(HAVE_THREAD_LOCAL_STORAGE 1)\nelse()\n  set(HAVE_THREAD_LOCAL_STORAGE 0)\nendif()\n\n# Our usage of mmap is Linux-specific (flag MAP_ANONYMOUS), but kFreeBSD uses a GNU libc\nIF(HAVE_MMAP AND\n   NOT \"${CMAKE_SYSTEM}\" MATCHES \"Linux\" AND \n   NOT \"${CMAKE_SYSTEM}\" MATCHES \"kFreeBSD\" AND \n   NOT \"${CMAKE_SYSTEM}\" MATCHES \"GNU\" AND \n   NOT  \"${CMAKE_SYSTEM}\" MATCHES \"Darwin\")\n  SET(HAVE_MMAP 0)\n  message(STATUS \"Warning: MMAP is thought as non functional on this architecture (${CMAKE_SYSTEM})\")\nENDIF()\n\nif(HAVE_MMAP AND HAVE_THREAD_LOCAL_STORAGE)\n  SET(HAVE_MMALLOC 1)\nelse()\n  SET(HAVE_MMALLOC 0)\nendif()\n\n\nif(WIN32) # Those files are not detected despite being present\n  set(HAVE_UCONTEXT_H 1)\n  set(HAVE_MAKECONTEXT 1)\n  set(HAVE_SNPRINTF 1)\n  set(HAVE_VSNPRINTF 1)\nendif()\n\nset(CONTEXT_UCONTEXT 0)\nSET(CONTEXT_THREADS 0)\n\nif(enable_jedule)\n  SET(HAVE_JEDULE 1)\nendif()\n\nif(enable_latency_bound_tracking)\n  SET(HAVE_LATENCY_BOUND_TRACKING 1)\nelse()\n  SET(HAVE_LATENCY_BOUND_TRACKING 0)\nendif()\n\nif(enable_mallocators)\n  SET(MALLOCATOR_IS_WANTED 1)\nelse()\n  SET(MALLOCATOR_IS_WANTED 0)\nendif()\n\nif(enable_model-checking AND HAVE_MMALLOC)\n  SET(HAVE_MC 1)\n  SET(MMALLOC_WANT_OVERRIDE_LEGACY 1)\n  include(FindLibunwind)\n  include(FindLibdw)\nelse()\n  if(enable_model-checking)\n    message(STATUS \"Warning: support for model-checking has been disabled because HAVE_MMALLOC is false\")\n  endif()\n  SET(HAVE_MC 0)\n  SET(HAVE_MMALLOC 0)\n  SET(MMALLOC_WANT_OVERRIDE_LEGACY 0)\nendif()\n\nif(enable_smpi)\n  include(FindGFortran)\n  #really checks for objdump for privatization\n  find_package(BinUtils QUIET)\n  SET(HAVE_SMPI 1)\n\n  if( NOT \"${CMAKE_OBJDUMP}\" MATCHES \"CMAKE_OBJDUMP-NOTFOUND\" AND HAVE_MMAP)\n    SET(HAVE_PRIVATIZATION 1)\n  else()\n    SET(HAVE_PRIVATIZATION 0)\n  endif()\nendif()\n\n#--------------------------------------------------------------------------------------------------\n### Check for GNU dynamic linker\nCHECK_INCLUDE_FILE(\"dlfcn.h\" HAVE_DLFCN_H)\nif (HAVE_DLFCN_H)\n    if(HAVE_DLOPEN_IN_LIBDL)\n      set(DL_LIBRARY \"-ldl\")\n    endif(HAVE_DLOPEN_IN_LIBDL)\n    execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_gnu_dynlinker.c ${DL_LIBRARY} -o test_gnu_ld\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      OUTPUT_VARIABLE HAVE_GNU_LD_compil\n    )\n    if(HAVE_GNU_LD_compil)\n      set(HAVE_GNU_LD 0)\n      message(STATUS \"Warning: test program toward GNU ld failed to compile:\")\n      message(STATUS \"${HAVE_GNU_LD_comp_output}\")\n    else()\n\n      execute_process(COMMAND ./test_gnu_ld\n          WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n          RESULT_VARIABLE HAVE_GNU_LD_run\n          OUTPUT_VARIABLE var_exec\n      )\n\n      if(NOT HAVE_GNU_LD_run)\n        set(HAVE_GNU_LD 1)\n        message(STATUS \"We are using GNU dynamic linker\")\n      else()\n        set(HAVE_GNU_LD 0)\n        message(STATUS \"Warning: error while checking for GNU ld:\")\n        message(STATUS \"Test output: '${var_exec}'\")\n        message(STATUS \"Exit status: ${HAVE_GNU_LD_run}\")\n      endif()\n      file(REMOVE test_gnu_ld)\n    endif()\nendif()\n\n\n#--------------------------------------------------------------------------------------------------\n### Initialize of CONTEXT THREADS\n\nif(HAVE_PTHREAD)\n  ### Test that we have a way to create semaphores\n\n  if(HAVE_SEM_OPEN_LIB)\n    execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_sem_open.c -lpthread -o sem_open\n    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n    OUTPUT_VARIABLE HAVE_SEM_OPEN_compil\n    )\n\n    # Test sem_open by compiling:\n    if(HAVE_SEM_OPEN_compil)\n      set(HAVE_SEM_OPEN 0)\n      message(STATUS \"Warning: sem_open not compilable\")\n      message(STATUS \"HAVE_SEM_OPEN_comp_output: ${HAVE_SEM_OPEN_comp_output}\")\n    else()\n      set(HAVE_SEM_OPEN 1)\n      message(STATUS \"sem_open is compilable\")\n    endif()\n\n    # If we're not crosscompiling, we check by executing the program:\n    if (HAVE_SEM_OPEN AND NOT CMAKE_CROSSCOMPILING)\n      execute_process(COMMAND ./sem_open\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      RESULT_VARIABLE HAVE_SEM_OPEN_run\n      OUTPUT_VARIABLE var_compil\n      )\n      if (NOT HAVE_SEM_OPEN_run)\n        set(HAVE_SEM_OPEN 1)\n        message(STATUS \"sem_open is executable\")\n      else()\n        set(HAVE_SEM_OPEN 0)\n        if(EXISTS \"${CMAKE_BINARY_DIR}/sem_open\")\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_open exists!\")\n        else()\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_open not exists!\")\n        endif()\n        message(STATUS \"Warning: sem_open not executable\")\n        message(STATUS \"Compilation output: '${var_compil}'\")\n        message(STATUS \"Exit result of sem_open: ${HAVE_SEM_OPEN_run}\")\n      endif()\n    endif()\n    file(REMOVE sem_open)\n\n  else()\n    set(HAVE_SEM_OPEN 0)\n  endif()\n\n  if(HAVE_SEM_INIT_LIB)\n    execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_sem_init.c -lpthread -o sem_init\n    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n    RESULT_VARIABLE HAVE_SEM_INIT_run OUTPUT_VARIABLE HAVE_SEM_INIT_compil)\n\n    # Test sem_init by compiling:\n    if(HAVE_SEM_INIT_compil)\n      set(HAVE_SEM_INIT 0)\n      message(STATUS \"Warning: sem_init not compilable\")\n      message(STATUS \"HAVE_SEM_INIT_comp_output: ${HAVE_SEM_OPEN_comp_output}\")\n    else()\n      set(HAVE_SEM_INIT 1)\n      message(STATUS \"sem_init is compilable\")\n    endif()\n\n    # If we're not crosscompiling, we check by executing the program:\n    if (HAVE_SEM_INIT AND NOT CMAKE_CROSSCOMPILING)\n      execute_process(COMMAND ./sem_init\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      RESULT_VARIABLE HAVE_SEM_INIT_run\n      OUTPUT_VARIABLE var_compil\n      )\n      if (NOT HAVE_SEM_INIT_run)\n        set(HAVE_SEM_INIT 1)\n        message(STATUS \"sem_init is executable\")\n      else()\n        set(HAVE_SEM_INIT 0)\n        if(EXISTS \"${CMAKE_BINARY_DIR}/sem_init\")\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_init exists!\")\n        else()\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_init not exists!\")\n        endif()\n        message(STATUS \"Warning: sem_init not executable\")\n        message(STATUS \"Compilation output: '${var_compil}'\")\n        message(STATUS \"Exit result of sem_init: ${HAVE_SEM_INIT_run}\")\n      endif()\n    endif()\n    file(REMOVE sem_init)\n  endif()\n\n  if(NOT HAVE_SEM_OPEN AND NOT HAVE_SEM_INIT)\n    message(FATAL_ERROR \"Semaphores are not usable (neither sem_open nor sem_init is both compilable and executable), but they are mandatory to threads (you may need to mount /dev).\")\n  endif()\n\n  ### Test that we have a way to timewait for semaphores\n\n  if(HAVE_SEM_TIMEDWAIT_LIB)\n\n    execute_process(\n      COMMAND \"${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_sem_timedwait.c -lpthread\"\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      OUTPUT_VARIABLE HAVE_SEM_TIMEDWAIT_run\n      )\n\n    if(HAVE_SEM_TIMEDWAIT_run)\n      set(HAVE_SEM_TIMEDWAIT 0)\n      message(STATUS \"timedwait not compilable\")\n    else()\n      set(HAVE_SEM_TIMEDWAIT 1)\n      message(STATUS \"timedwait is compilable\")\n    endif()\n  endif()\n\n  ### HAVE_MUTEX_TIMEDLOCK\n\n  if(HAVE_MUTEX_TIMEDLOCK_LIB)\n\n    execute_process(\n      COMMAND \"${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_mutex_timedlock.c -lpthread\"\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      OUTPUT_VARIABLE HAVE_MUTEX_TIMEDLOCK_run\n      )\n\n    if(HAVE_MUTEX_TIMEDLOCK_run)\n      set(HAVE_MUTEX_TIMEDLOCK 0)\n      message(STATUS \"timedlock not compilable\")\n    else()\n      message(STATUS \"timedlock is compilable\")\n      set(HAVE_MUTEX_TIMEDLOCK 1)\n    endif()\n  endif()\nendif()\n\n# This is needed for ucontext on MacOS X:\nif(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n  add_definitions(-D_XOPEN_SOURCE=700 -D_DARWIN_C_SOURCE)\nendif()\n\nif(WIN32)\n  # We always provide our own implementation of ucontext on Windows.\n  try_compile(HAVE_UCONTEXT\n    ${CMAKE_BINARY_DIR}\n    ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_AC_CHECK_MCSC.c\n    COMPILE_DEFINITIONS _XBT_WIN32\n    INCLUDE_DIRECTORIES\n      ${CMAKE_HOME_DIRECTORY}/src/include\n      ${CMAKE_HOME_DIRECTORY}/src/xbt\n  )\nelse()\n  # We always provide our own implementation of ucontext on Windows.\n  try_compile(HAVE_UCONTEXT\n    ${CMAKE_BINARY_DIR}\n    ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_AC_CHECK_MCSC.c)\nendif()\n\n#If can have both context\n\nif(HAVE_UCONTEXT)\n  set(CONTEXT_UCONTEXT 1)\n  message(\"-- Support for ucontext factory\")\nendif()\n\nif(HAVE_PTHREAD)\n  set(CONTEXT_THREADS 1)\n  message(\"-- Support for thread context factory\")\nendif()\n\n###############\n## GIT version check\n##\nif(EXISTS ${CMAKE_HOME_DIRECTORY}/.git/)\n  execute_process(COMMAND git remote\n  COMMAND head -n 1\n  WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n  OUTPUT_VARIABLE remote\n  RESULT_VARIABLE ret\n  )\n  string(REPLACE \"\\n\" \"\" remote \"${remote}\")\n  #message(STATUS \"Git remote: ${remote}\")\n  execute_process(COMMAND git config --get remote.${remote}.url\n  WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n  OUTPUT_VARIABLE url\n  RESULT_VARIABLE ret\n  )\n  string(REPLACE \"\\n\" \"\" url \"${url}\")\n  #message(STATUS \"Git url: ${url}\")\n  if(url)\n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log --pretty=oneline --abbrev-commit -1\n    WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n    OUTPUT_VARIABLE GIT_VERSION\n    RESULT_VARIABLE ret\n    )\n    string(REPLACE \"\\n\" \"\" GIT_VERSION \"${GIT_VERSION}\")\n    message(STATUS \"Git version: ${GIT_VERSION}\")\n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log -n 1 --pretty=format:%ai .\n    WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n    OUTPUT_VARIABLE GIT_DATE\n    RESULT_VARIABLE ret\n    )\n    string(REPLACE \"\\n\" \"\" GIT_DATE \"${GIT_DATE}\")\n    message(STATUS \"Git date: ${GIT_DATE}\")\n    string(REGEX REPLACE \" .*\" \"\" GIT_VERSION \"${GIT_VERSION}\")\n    \n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log --pretty=format:%H -1\n                    WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n\t\t    OUTPUT_VARIABLE SIMGRID_GITHASH\n\t\t    RESULT_VARIABLE ret\n\t\t    )\n    string(REPLACE \"\\n\" \"\" SIMGRID_GITHASH \"${SIMGRID_GITHASH}\")\n\t\t    \n  endif()\nelseif(EXISTS ${CMAKE_HOME_DIRECTORY}/.gitversion)\n  FILE(STRINGS ${CMAKE_HOME_DIRECTORY}/.gitversion GIT_VERSION)\nendif()\n\nif(release)\n  set(SIMGRID_VERSION_BANNER \"${SIMGRID_VERSION_BANNER}\\\\nRelease build\")\nelse()\n  set(SIMGRID_VERSION_BANNER \"${SIMGRID_VERSION_BANNER}\\\\nDevelopment build\")\nendif()\nif(GIT_VERSION)\n  set(SIMGRID_VERSION_BANNER \"${SIMGRID_VERSION_BANNER} at commit ${GIT_VERSION}\")\nendif()\nif(GIT_DATE)\n  set(SIMGRID_VERSION_BANNER \"${SIMGRID_VERSION_BANNER} (${GIT_DATE})\")\nendif()\n#--------------------------------------------------------------------------------------------------\n\nset(makecontext_CPPFLAGS_2 \"\")\nif(HAVE_MAKECONTEXT OR WIN32)\n  set(makecontext_CPPFLAGS \"-DTEST_makecontext\")\n  if(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n    set(makecontext_CPPFLAGS_2 \"-D_XOPEN_SOURCE=700\")\n  endif()\n\n  if(WIN32)\n    if(ARCH_32_BITS)\n      set(makecontext_CPPFLAGS \"-DTEST_makecontext -D_I_X86_\")\n    else()\n      set(makecontext_CPPFLAGS \"-DTEST_makecontext -D_AMD64_\")\n    endif()\n    set(makecontext_CPPFLAGS_2 \"-D_XBT_WIN32 -I${CMAKE_HOME_DIRECTORY}/src/include -I${CMAKE_HOME_DIRECTORY}/src/xbt\")\n  endif()\n\n  file(REMOVE ${CMAKE_BINARY_DIR}/conftestval)\n\n  if(CMAKE_CROSSCOMPILING)\n    set(RUN_makecontext_VAR \"cross\")\n    set(COMPILE_makecontext_VAR \"cross\")\n  else()\n    try_run(RUN_makecontext_VAR COMPILE_makecontext_VAR\n      ${CMAKE_BINARY_DIR}\n      ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_stacksetup.c\n      COMPILE_DEFINITIONS \"${makecontext_CPPFLAGS} ${makecontext_CPPFLAGS_2}\"\n      )\n  endif()\n\n  if(EXISTS ${CMAKE_BINARY_DIR}/conftestval)\n    file(READ ${CMAKE_BINARY_DIR}/conftestval MAKECONTEXT_ADDR_SIZE)\n    string(REPLACE \"\\n\" \"\" MAKECONTEXT_ADDR_SIZE \"${MAKECONTEXT_ADDR_SIZE}\")\n    string(REGEX MATCH ;^.*,;MAKECONTEXT_ADDR \"${MAKECONTEXT_ADDR_SIZE}\")\n    string(REGEX MATCH ;,.*$; MAKECONTEXT_SIZE \"${MAKECONTEXT_ADDR_SIZE}\")\n    string(REPLACE \",\" \"\" makecontext_addr \"${MAKECONTEXT_ADDR}\")\n    string(REPLACE \",\" \"\" makecontext_size \"${MAKECONTEXT_SIZE}\")\n    set(pth_skaddr_makecontext \"#define pth_skaddr_makecontext(skaddr,sksize) (${makecontext_addr})\")\n    set(pth_sksize_makecontext \"#define pth_sksize_makecontext(skaddr,sksize) (${makecontext_size})\")\n    message(STATUS \"${pth_skaddr_makecontext}\")\n    message(STATUS \"${pth_sksize_makecontext}\")\n  else()\n    # message(FATAL_ERROR \"makecontext is not compilable\")\n  endif()\nendif()\n\n#--------------------------------------------------------------------------------------------------\n\n### check for stackgrowth\nif (NOT CMAKE_CROSSCOMPILING)\n  try_run(RUN_makecontext_VAR COMPILE_makecontext_VAR\n    ${CMAKE_BINARY_DIR}\n    ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_stackgrowth.c\n    RUN_OUTPUT_VARIABLE stack\n    )\nendif()\nif(\"${stack}\" STREQUAL \"down\")\n  set(PTH_STACKGROWTH \"-1\")\nelseif(\"${stack}\" STREQUAL \"up\")\n  set(PTH_STACKGROWTH \"1\")\nelse()\n  if(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"x86_64\")\n    set(PTH_STACKGROWTH \"-1\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"i686\")\n    set(PTH_STACKGROWTH \"-1\")\n  else()\n    message(ERROR \"Could not figure the stack direction.\")\n  endif()\nendif()\n\n###############\n## System checks\n##\n\n#SG_CONFIGURE_PART([System checks...])\n#AC_PROG_CC(xlC gcc cc) -auto\n#AM_SANITY_CHECK -auto\n\n#AC_PROG_MAKE_SET\n\n#AC_CHECK_VA_COPY\n\nset(diff_va \"va_copy((d),(s))\"\n  \"VA_COPY((d),(s))\"\n  \"__va_copy((d),(s))\"\n  \"__builtin_va_copy((d),(s))\"\n  \"do { (d) = (s)\\; } while (0)\"\n  \"do { *(d) = *(s)\\; } while (0)\"\n  \"memcpy((void *)&(d), (void *)&(s), sizeof(s))\"\n  \"memcpy((void *)(d), (void *)(s), sizeof(*(s)))\"\n  )\n\nforeach(fct ${diff_va})\n  write_file(\"${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_va_copy.c\" \"#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#define DO_VA_COPY(d,s) ${fct}\nvoid test(char *str, ...)\n{\n  va_list ap, ap2;\n  int i;\n  va_start(ap, str);\n  DO_VA_COPY(ap2, ap);\n  for (i = 1; i <= 9; i++) {\n    int k = (int)va_arg(ap, int);\n    if (k != i)\n      abort();\n  }\n  DO_VA_COPY(ap, ap2);\n  for (i = 1; i <= 9; i++) {\n    int k = (int)va_arg(ap, int);\n    if (k != i)\n      abort();\n  }\n  va_end(ap);\n}\nint main(void)\n{\n  test(\\\"test\\\", 1, 2, 3, 4, 5, 6, 7, 8, 9);\n  exit(0);\n}\"\n    )\n\n  execute_process(\n  COMMAND ${CMAKE_C_COMPILER} \"${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_va_copy.c\"\n  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n  RESULT_VARIABLE COMPILE_VA_NULL_VAR\n  OUTPUT_QUIET\n  ERROR_QUIET\n  )\n\n  if(NOT COMPILE_VA_NULL_VAR)\n    string(REGEX REPLACE \"\\;\" \"\" fctbis ${fct})\n    if(${fctbis} STREQUAL \"va_copy((d),(s))\")\n      set(HAVE_VA_COPY 1)\n      set(ac_cv_va_copy \"C99\")\n      set(__VA_COPY_USE_C99 \"va_copy((d),(s))\")\n    endif()\n\n    if(${fctbis} STREQUAL \"VA_COPY((d),(s))\")\n      set(ac_cv_va_copy \"GCM\")\n      set(__VA_COPY_USE_GCM \"VA_COPY((d),(s))\")\n    endif()\n\n    if(${fctbis} STREQUAL \"__va_copy((d),(s))\")\n      set(ac_cv_va_copy \"GCH\")\n      set(__VA_COPY_USE_GCH \"__va_copy((d),(s))\")\n    endif()\n\n    if(${fctbis} STREQUAL \"__builtin_va_copy((d),(s))\")\n      set(ac_cv_va_copy \"GCB\")\n      set(__VA_COPY_USE_GCB \"__builtin_va_copy((d),(s))\")\n    endif()\n\n    if(${fctbis} STREQUAL \"do { (d) = (s) } while (0)\")\n      set(ac_cv_va_copy \"ASS\")\n      set(__VA_COPY_USE_ASS \"do { (d) = (s); } while (0)\")\n    endif()\n\n    if(${fctbis} STREQUAL \"do { *(d) = *(s) } while (0)\")\n      set(ac_cv_va_copy \"ASP\")\n      set(__VA_COPY_USE_ASP \"do { *(d) = *(s); } while (0)\")\n    endif()\n\n    if(${fctbis} STREQUAL \"memcpy((void *)&(d), (void *)&(s), sizeof(s))\")\n      set(ac_cv_va_copy \"CPS\")\n      set(__VA_COPY_USE_CPS \"memcpy((void *)&(d), (void *)&(s), sizeof(s))\")\n    endif()\n\n    if(${fctbis} STREQUAL \"memcpy((void *)(d), (void *)(s), sizeof(*(s)))\")\n      set(ac_cv_va_copy \"CPP\")\n      set(__VA_COPY_USE_CPP \"memcpy((void *)(d), (void *)(s), sizeof(*(s)))\")\n    endif()\n\n    if(NOT STATUS_OK)\n      set(__VA_COPY_USE \"__VA_COPY_USE_${ac_cv_va_copy}(d, s)\")\n    endif()\n    set(STATUS_OK \"1\")\n\n  endif()\n\nendforeach(fct ${diff_va})\n\n#--------------------------------------------------------------------------------------------------\n### check for a working snprintf\nif(HAVE_SNPRINTF AND HAVE_VSNPRINTF OR WIN32)\n  if(WIN32)\n    #set(HAVE_SNPRINTF 1)\n    #set(HAVE_VSNPRINTF 1)\n  endif()\n\n  if(CMAKE_CROSSCOMPILING)\n    set(RUN_SNPRINTF_FUNC \"cross\")\n    #set(PREFER_PORTABLE_SNPRINTF 1)\n  else()\n    try_run(RUN_SNPRINTF_FUNC_VAR COMPILE_SNPRINTF_FUNC_VAR\n      ${CMAKE_BINARY_DIR}\n      ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_snprintf.c\n      )\n  endif()\n\n  if(CMAKE_CROSSCOMPILING)\n    set(RUN_VSNPRINTF_FUNC \"cross\")\n    set(PREFER_PORTABLE_VSNPRINTF 1)\n  else()\n    try_run(RUN_VSNPRINTF_FUNC_VAR COMPILE_VSNPRINTF_FUNC_VAR\n      ${CMAKE_BINARY_DIR}\n      ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_vsnprintf.c\n      )\n  endif()\n\n  set(PREFER_PORTABLE_SNPRINTF 0)\n  if(RUN_VSNPRINTF_FUNC_VAR MATCHES \"FAILED_TO_RUN\")\n    set(PREFER_PORTABLE_SNPRINTF 1)\n  endif()\n  if(RUN_SNPRINTF_FUNC_VAR MATCHES \"FAILED_TO_RUN\")\n    set(PREFER_PORTABLE_SNPRINTF 1)\n  endif()\nendif()\n\n### check for asprintf function familly\nif(HAVE_ASPRINTF)\n  SET(simgrid_need_asprintf \"\")\n  SET(NEED_ASPRINTF 0)\nelse()\n  SET(simgrid_need_asprintf \"#define SIMGRID_NEED_ASPRINTF 1\")\n  SET(NEED_ASPRINTF 1)\nendif()\n\nif(HAVE_VASPRINTF)\n  SET(simgrid_need_vasprintf \"\")\n  SET(NEED_VASPRINTF 0)\nelse()\n  SET(simgrid_need_vasprintf \"#define SIMGRID_NEED_VASPRINTF 1\")\n  SET(NEED_VASPRINTF 1)\nendif()\n\n### check for addr2line\n\nfind_path(ADDR2LINE NAMES addr2line\tPATHS NO_DEFAULT_PATHS\t)\nif(ADDR2LINE)\n  set(ADDR2LINE \"${ADDR2LINE}/addr2line\")\nendif()\n\n### File to create\n\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/src/context_sysv_config.h.in\"\n  \"${CMAKE_BINARY_DIR}/src/context_sysv_config.h\" @ONLY IMMEDIATE)\n\nSET( CMAKEDEFINE \"#cmakedefine\" )\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/tools/cmake/src/internal_config.h.in\" \"${CMAKE_BINARY_DIR}/src/internal_config.h\" @ONLY IMMEDIATE)\nconfigure_file(\"${CMAKE_BINARY_DIR}/src/internal_config.h\" \"${CMAKE_BINARY_DIR}/src/internal_config.h\" @ONLY IMMEDIATE)\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/include/simgrid_config.h.in\" \"${CMAKE_BINARY_DIR}/include/simgrid_config.h\" @ONLY IMMEDIATE)\n\nset(top_srcdir \"${CMAKE_HOME_DIRECTORY}\")\nset(srcdir \"${CMAKE_HOME_DIRECTORY}/src\")\nset(bindir \"${CMAKE_BINARY_DIR}\")\n\n### Script used when simgrid is installed\nset(exec_prefix ${CMAKE_INSTALL_PREFIX})\nset(includeflag \"-I${CMAKE_INSTALL_PREFIX}/include -I${CMAKE_INSTALL_PREFIX}/include/smpi\")\nset(includedir \"${CMAKE_INSTALL_PREFIX}/include\")\nset(libdir ${exec_prefix}/lib)\nset(CMAKE_SMPI_COMMAND \"export LD_LIBRARY_PATH=\\\"${CMAKE_INSTALL_PREFIX}/lib\")\nif(NS3_LIBRARY_PATH)\n  set(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:${NS3_LIBRARY_PATH}\")\nendif()\nset(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:\\${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\\\"\")\n\nfile(READ ${CMAKE_HOME_DIRECTORY}/src/smpi/smpitools.sh SMPITOOLS_SH)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/include/smpi/mpif.h.in ${CMAKE_BINARY_DIR}/include/smpi/mpif.h @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpicc.in ${CMAKE_BINARY_DIR}/bin/smpicc @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpicxx.in ${CMAKE_BINARY_DIR}/bin/smpicxx @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpiff.in ${CMAKE_BINARY_DIR}/bin/smpiff @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpif90.in ${CMAKE_BINARY_DIR}/bin/smpif90 @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpirun.in ${CMAKE_BINARY_DIR}/bin/smpirun @ONLY)\n\n### Script used when simgrid is compiling\nset(includeflag \"-I${CMAKE_HOME_DIRECTORY}/include -I${CMAKE_HOME_DIRECTORY}/include/smpi\")\nset(includeflag \"${includeflag} -I${CMAKE_BINARY_DIR}/include -I${CMAKE_BINARY_DIR}/include/smpi\")\nset(includedir \"${CMAKE_HOME_DIRECTORY}/include\")\nset(exec_prefix \"${CMAKE_BINARY_DIR}/smpi_script/\")\nset(CMAKE_SMPI_COMMAND \"export LD_LIBRARY_PATH=\\\"${CMAKE_BINARY_DIR}/lib\")\nif(NS3_LIBRARY_PATH)\n  set(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:${NS3_LIBRARY_PATH}\")\nendif()\nset(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:\\${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\\\"\")\nset(libdir \"${CMAKE_BINARY_DIR}/lib\")\n\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpicc.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpicc @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpicxx.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpicxx @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpiff.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpiff @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpif90.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpif90 @ONLY)\nconfigure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpirun.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun @ONLY)\n\nset(top_builddir ${CMAKE_HOME_DIRECTORY})\n\nif(NOT WIN32)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpicc)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpicxx)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpiff)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpif90)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpirun)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpicc)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpicxx)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpiff)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpif90)\n  execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun)\nendif()\n\nset(generated_headers_to_install\n  ${CMAKE_CURRENT_BINARY_DIR}/include/smpi/mpif.h\n  ${CMAKE_CURRENT_BINARY_DIR}/include/simgrid_config.h\n  )\n\nset(generated_headers\n  ${CMAKE_CURRENT_BINARY_DIR}/src/context_sysv_config.h\n  ${CMAKE_CURRENT_BINARY_DIR}/src/internal_config.h\n  )\n\nset(generated_files_to_clean\n  ${generated_headers}\n  ${generated_headers_to_install}\n  ${CMAKE_BINARY_DIR}/bin/smpicc\n  ${CMAKE_BINARY_DIR}/bin/smpicxx\n  ${CMAKE_BINARY_DIR}/bin/smpiff\n  ${CMAKE_BINARY_DIR}/bin/smpif90\n  ${CMAKE_BINARY_DIR}/bin/smpirun\n  ${CMAKE_BINARY_DIR}/bin/colorize\n  ${CMAKE_BINARY_DIR}/bin/simgrid_update_xml\n  ${CMAKE_BINARY_DIR}/examples/smpi/tracing/smpi_traced.trace\n  )\n\nif(NOT \"${CMAKE_BINARY_DIR}\" STREQUAL \"${CMAKE_HOME_DIRECTORY}\")\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions0.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions0.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions1.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions1.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_allReduce.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allReduce.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_barrier.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_barrier.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_bcast.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_bcast.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_with_isend.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_with_isend.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_alltoall.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoall.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_alltoallv.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoallv.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_waitall.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_waitall.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_reducescatter.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_reducescatter.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_gather.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_gather.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_allgatherv.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allgatherv.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/hostfile ${CMAKE_BINARY_DIR}/teshsuite/smpi/hostfile COPYONLY)\n  \n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/description_file ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/description_file COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/README ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/README COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/smpi_replay.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/smpi_replay.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt COPYONLY)\n\n  set(generated_files_to_clean\n    ${generated_files_to_clean}\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions0.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions1.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allReduce.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_barrier.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_bcast.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_with_isend.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoall.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoallv.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_waitall.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_gather.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allgatherv.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_reducescatter.txt\n    ${CMAKE_BINARY_DIR}/teshsuite/smpi/hostfile\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/description_file\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/README\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/smpi_replay.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt\n    )\nendif()\n\nSET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES\n  \"${generated_files_to_clean}\")\n\nIF(${ARCH_32_BITS})\n  set(WIN_ARCH \"32\")\nELSE()\n  set(WIN_ARCH \"64\")\nENDIF()\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/tools/cmake/src/simgrid.nsi.in\" \"${CMAKE_BINARY_DIR}/simgrid.nsi\" @ONLY IMMEDIATE)\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/doxygen/FAQ.doc": "/*! \\page FAQ Frequently Asked Questions\n\n@tableofcontents\n\n\\section faq_simgrid I'm new to SimGrid. I have some questions. Where should I start?\n\nYou are at the right  place... Having a look to these\n<a href=\"http://www.loria.fr/~quinson/blog/2010/06/28/Tutorial_at_HPCS/\">the slides of the HPCS'10 tutorial</a>\n(or to these <a href=\"http://graal.ens-lyon.fr/~alegrand/articles/slides_g5k_simul.pdf\">ancient\nslides</a>, or to these\n<a href=\"http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf\">\"obsolete\" slides</a>)\nmay give you some insights on what SimGrid can help you to do and what\nare its limitations. Then you definitely should read the \\ref\nMSG_examples. \n\nIf you are stuck at any point and if this FAQ cannot help you, please drop us a\nmail to the user mailing list: <simgrid-user@lists.gforge.inria.fr>.\n\n\\subsection faq_interfaces What is the difference between MSG and SimDag? Do they serve the same purpose?\n\nIt depend on how you define \"purpose\", I guess ;)\n\nThey all allow you to build a prototype of application which you can run\nwithin the simulator afterward. They all share the same simulation kernel,\nwhich is the core of the SimGrid project. They differ by the way you express\nyour application.\n\nWith SimDag, you express your code as a collection of interdependent\nparallel tasks. So, in this model, applications can be seen as a DAG of\ntasks. This is the interface of choice for people wanting to port old\ncode designed for SimGrid v1 or v2 to the framework current version.\n\nWith MSG, your application is seen as a set of communicating\nprocesses, exchanging data by the way of messages and performing\ncomputation on their own.\n\n\\subsection faq_visualization Visualizing and analyzing the results\n\nIt is sometime convenient to \"see\" how the agents are behaving. If you\nlike colors, you can use <tt>tools/MSG_visualization/colorize.pl </tt>\nas a filter to your MSG outputs. It works directly with INFO. Beware,\nINFO() prints on stderr. Do not forget to redirect if you want to\nfilter (e.g. with bash):\n\\verbatim\n./msg_test small_platform.xml small_deployment.xml 2>&1 | ../../tools/MSG_visualization/colorize.pl\n\\endverbatim\n\nWe also have a more graphical output. Have a look at section \\ref options_tracing.\n\n\\subsection faq_C Argh! Do I really have to code in C?\n\nCurrently bindings on top of MSG are supported for Java, Ruby and Lua. You can find a few\ndocumentation about them on the doc page. Note that bindings are released separately from the main dist\nand so have their own version numbers.\n\nMoreover If you use C++,\nyou should be able to use the SimGrid library as a standard C library\nand everything should work fine (simply <i>link</i> against this\nlibrary; recompiling SimGrid with a C++ compiler won't work and it\nwouldn't help if you could).\n\nFor now,\nwe do not feel a real demand for any other language. But if you think there is one,\n please speak up!\n\n\\section faq_howto Feature related questions\n\n\\subsection faq_MIA \"Could you please add (your favorite feature here) to SimGrid?\"\n\nHere is the deal. The whole SimGrid project (MSG, SURF, ...) is\nmeant to be kept as simple and generic as possible. We cannot add\nfunctions for everybody's needs when these functions can easily be\nbuilt from the ones already in the API. Most of the time, it is\npossible and when it was not possible we always have upgraded the API\naccordingly. When somebody asks us a question like \"How to do that?\nIs there a function in the API to simply do this?\", we're always glad\nto answer and help. However if we don't need this code for our own\nneed, there is no chance we're going to write it... it's your job! :)\nThe counterpart to our answers is that once you come up with a neat\nimplementation of this feature (task duplication, RPC, thread\nsynchronization, ...), you should send it to us and we will be glad to\nadd it to the distribution. Thus, other people will take advantage of\nit (and we don't have to answer this question again and again ;).\n\nYou'll find in this section a few \"Missing In Action\" features. Many\npeople have asked about it and we have given hints on how to simply do\nit with MSG. Feel free to contribute...\n\n\\subsection faq_MIA_MSG MSG features\n\n\\subsubsection faq_MIA_examples I want some more complex MSG examples!\n\nMany people have come to ask me a more complex example and each time,\nthey have realized afterward that the basics were in the previous three\nexamples.\n\nOf course they have often been needing more complex functions like\nMSG_process_suspend(), MSG_process_resume() and\nMSG_process_isSuspended() (to perform synchronization), or\nMSG_task_Iprobe() and MSG_process_sleep() (to avoid blocking\nreceptions), or even MSG_process_create() (to design asynchronous\ncommunications or computations). But the examples are sufficient to\nstart.\n\nWe know. We should add some more examples, but not really some more\ncomplex ones... We should add some examples that illustrate some other\nfunctionalists (like how to simply encode asynchronous\ncommunications, RPC, process migrations, thread synchronization, ...)\nand we will do it when we will have a little bit more time. We have\ntried to document the examples so that they are understandable. Tell\nus if something is not clear and once again feel free to participate!\n:)\n\n\\subsubsection faq_MIA_taskdup Missing in action: MSG Task duplication/replication\n\nThere is no task duplication in MSG. When you create a task, you can\nprocess it or send it somewhere else. As soon as a process has sent\nthis task, he doesn't have this task anymore. It's gone. The receiver\nprocess has got the task. However, you could decide upon receiving to\ncreate a \"copy\" of a task but you have to handle by yourself the\nsemantic associated to this \"duplication\".\n\nAs we already told, we prefer keeping the API as simple as\npossible. This kind of feature is rather easy to implement by users\nand the semantic you associate really depends on people. Having a\n*generic* task duplication mechanism is not that trivial (in\nparticular because of the data field). That is why I would recommend\nthat you write it by yourself even if I can give you advice on how to\ndo it.\n\nYou have the following functions to get information about a task:\nMSG_task_get_name(), MSG_task_get_compute_duration(),\nMSG_task_get_remaining_computation(), MSG_task_get_data_size(),\nand MSG_task_get_data().\n\nYou could use a dictionary (#xbt_dict_t) of dynars (#xbt_dynar_t). If\nyou still don't see how to do it, please come back to us...\n\n\\subsubsection faq_MIA_asynchronous I want to do asynchronous communications in MSG\n\nIn the past (version <= 3.4), there was no function to perform asynchronous communications.\nIt could easily be implemented by creating new process when needed though. Since version 3.5,\nwe have introduced the following functions:\n - MSG_task_isend()\n - MSG_task_irecv()\n - MSG_comm_test()\n - MSG_comm_wait()\n - MSG_comm_waitall()\n - MSG_comm_waitany()\n - MSG_comm_destroy()\n\nWe refer you to the description of these functions for more details on their usage as well\nas to the example section on \\ref MSG_ex_asynchronous_communications.\n\n\\subsubsection faq_MIA_thread_synchronization I need to synchronize my MSG processes\n\nYou obviously cannot use pthread_mutexes of pthread_conds since we handle every\nscheduling related decision within SimGrid.\n\nIn the past (version <=3.3.4) you could do it by playing with\nMSG_process_suspend() and MSG_process_resume() or with fake communications (using MSG_task_get(),\nMSG_task_put() and MSG_task_Iprobe()).\n\nSince version 3.4, you can use classical synchronization structures. See page \\ref XBT_synchro or simply check in\ninclude/xbt/synchro_core.h.\n\n\\subsubsection faq_MIA_host_load Where is the get_host_load function hidden in MSG?\n\nThere is no such thing because its semantic wouldn't be really\nclear. Of course, it is something about the amount of host throughput,\nbut there is as many definition of \"host load\" as people asking for\nthis function. First, you have to remember that resource availability\nmay vary over time, which make any load notion harder to define.\n\nIt may be instantaneous value or an average one. Moreover it may be only the\npower of the computer, or may take the background load into account, or may\neven take the currently running tasks into account. In some SURF models,\ncommunications have an influence on computational power. Should it be taken\ninto account too?\n\nFirst of all, it's near to impossible to predict the load beforehand in the\nsimulator since it depends on too much parameters (background load\nvariation, bandwidth sharing algorithmic complexity) some of them even being\nnot known beforehand (other task starting at the same time). So, getting\nthis information is really hard (just like in real life). It's not just that\nwe want MSG to be as painful as real life. But as it is in some way\nrealistic, we face some of the same problems as we would face in real life.\n\nHow would you do it for real? The most common option is to use something\nlike NWS that performs active probes. The best solution is probably to do\nthe same within MSG, as in next code snippet. It is very close from what you\nwould have to do out of the simulator, and thus gives you information that\nyou could also get in real settings to not hinder the realism of your\nsimulation.\n\n\\verbatim\ndouble get_host_load() {\n   m_task_t task = MSG_task_create(\"test\", 0.001, 0, NULL);\n   double date = MSG_get_clock();\n\n   MSG_task_execute(task);\n   date = MSG_get_clock() - date;\n   MSG_task_destroy(task);\n   return (0.001/date);\n}\n\\endverbatim\n\nOf course, it may not match your personal definition of \"host load\". In this\ncase, please detail what you mean on the mailing list, and we will extend\nthis FAQ section to fit your taste if possible.\n\n\\subsubsection faq_MIA_communication_time How can I get the *real* communication time?\n\nCommunications are synchronous and thus if you simply get the time\nbefore and after a communication, you'll only get the transmission\ntime and the time spent to really communicate (it will also take into\naccount the time spent waiting for the other party to be\nready). However, getting the *real* communication time is not really\nhard either. The following solution is a good starting point.\n\n\\verbatim\nint sender()\n{\n  m_task_t task = MSG_task_create(\"Task\", task_comp_size, task_comm_size,\n                                  calloc(1,sizeof(double)));\n  *((double*) task->data) = MSG_get_clock();\n  MSG_task_put(task, slaves[i % slaves_count], PORT_22);\n  XBT_INFO(\"Send completed\");\n  return 0;\n}\nint receiver()\n{\n  m_task_t task = NULL;\n  double time1,time2;\n\n  time1 = MSG_get_clock();\n  a = MSG_task_get(&(task), PORT_22);\n  time2 = MSG_get_clock();\n  if(time1<*((double *)task->data))\n     time1 = *((double *) task->data);\n  XBT_INFO(\"Communication time :  \\\"%f\\\" \", time2-time1);\n  free(task->data);\n  MSG_task_destroy(task);\n  return 0;\n}\n\\endverbatim\n\n\\subsection faq_MIA_SimDag SimDag related questions\n\n\\subsubsection faq_SG_comm Implementing communication delays between tasks.\n\nA classic question of SimDag newcomers is about how to express a\ncommunication delay between tasks. The thing is that in SimDag, both\ncomputation and communication are seen as tasks.  So, if you want to\nmodel a data dependency between two DAG tasks t1 and t2, you have to\ncreate 3 SD_tasks: t1, t2 and c and add dependencies in the following\nway:\n\n\\verbatim\nSD_task_dependency_add(NULL, NULL, t1, c);\nSD_task_dependency_add(NULL, NULL, c, t2);\n\\endverbatim\n\nThis way task t2 cannot start before the termination of communication c\nwhich in turn cannot start before t1 ends.\n\nWhen creating task c, you have to associate an amount of data (in bytes)\ncorresponding to what has to be sent by t1 to t2.\n\nFinally to schedule the communication task c, you have to build a list\ncomprising the workstations on which t1 and t2 are scheduled (w1 and w2\nfor example) and build a communication matrix that should look like\n[0;amount ; 0; 0].\n\n\\subsubsection faq_SG_DAG How to implement a distributed dynamic scheduler of DAGs.\n\nDistributed is somehow \"contagious\". If you start making distributed\ndecisions, there is no way to handle DAGs directly anymore (unless I\nam missing something). You have to encode your DAGs in term of\ncommunicating process to make the whole scheduling process\ndistributed. Here is an example of how you could do that. Assume T1\nhas to be done before T2.\n\n\\verbatim\n int your_agent(int argc, char *argv[] {\n   ...\n   T1 = MSG_task_create(...);\n   T2 = MSG_task_create(...);\n   ...\n   while(1) {\n     ...\n     if(cond) MSG_task_execute(T1);\n     ...\n     if((MSG_task_get_remaining_computation(T1)=0.0) && (you_re_in_a_good_mood))\n        MSG_task_execute(T2)\n     else {\n        /* do something else */\n     }\n   }\n }\n\\endverbatim\n\nIf you decide that the distributed part is not that much important and that\nDAG is really the level of abstraction you want to work with, then you should\ngive a try to \\ref SD_API.\n\n\\subsection faq_MIA_generic Generic features\n\n\\subsubsection faq_MIA_batch_scheduler Is there a native support for batch schedulers in SimGrid?\n\nNo, there is no native support for batch schedulers and none is\nplanned because this is a very specific need (and doing it in a\ngeneric way is thus very hard). However some people have implemented\ntheir own batch schedulers. Vincent Garonne wrote one during his PhD\nand put his code in the contrib directory of our SVN so that other can\nkeep working on it. You may find inspiring ideas in it.\n\n\\subsubsection faq_MIA_checkpointing I need a checkpointing thing\n\nActually, it depends on whether you want to checkpoint the simulation, or to\nsimulate checkpoints.\n\nThe first one could help if your simulation is a long standing process you\nwant to keep running even on hardware issues. It could also help to\n<i>rewind</i> the simulation by jumping sometimes on an old checkpoint to\ncancel recent calculations.\\n\nUnfortunately, such thing will probably never exist in SG. One would have to\nduplicate all data structures because doing a rewind at the simulator level\nis very very hard (not talking about the malloc free operations that might\nhave been done in between). Instead, you may be interested in the Libckpt\nlibrary (http://www.cs.utk.edu/~plank/plank/www/libckpt.html). This is the\ncheckpointing solution used in the condor project, for example. It makes it\neasy to create checkpoints (at the OS level, creating something like core\nfiles), and rerunning them on need.\n\nIf you want to simulate checkpoints instead, it means that you want the\nstate of an executing task (in particular, the progress made towards\ncompletion) to be saved somewhere.  So if a host (and the task executing on\nit) fails (cf. #MSG_HOST_FAILURE), then the task can be restarted\nfrom the last checkpoint.\\n\n\nActually, such a thing does not exist in SimGrid either, but it's just\nbecause we don't think it is fundamental and it may be done in the user code\nat relatively low cost. You could for example use a watcher that\nperiodically get the remaining amount of things to do (using\nMSG_task_get_remaining_computation()), or fragment the task in smaller\nsubtasks.\n\n\\subsection faq_platform Platform building and Dynamic resources\n\n\\subsubsection faq_platform_example Where can I find SimGrid platform files?\n\nThere are several little examples in the archive, in the examples/msg\ndirectory. From time to time, we are asked for other files, but we\ndon't have much at hand right now.\n\nYou should refer to the Platform Description Archive\n(http://pda.gforge.inria.fr) project to see the other platform file we\nhave available, as well as the Simulacrum simulator, meant to generate\nSimGrid platforms using all classical generation algorithms.\n\n\\subsubsection faq_platform_alnem How can I automatically map an existing platform?\n\nWe are working on a project called ALNeM (Application-Level Network\nMapper) which goal is to automatically discover the topology of an\nexisting network. Its output will be a platform description file\nfollowing the SimGrid syntax, so everybody will get the ability to map\ntheir own lab network (and contribute them to the catalog project).\nThis tool is not ready yet, but it move quite fast forward. Just stay\ntuned.\n\n\\subsubsection faq_platform_synthetic Generating synthetic but realistic platforms\n\nThe third possibility to get a platform file (after manual or\nautomatic mapping of real platforms) is to generate synthetic\nplatforms. Getting a realistic result is not a trivial task, and\nmoreover, nobody is really able to define what \"realistic\" means when\nspeaking of topology files. You can find some more thoughts on this\ntopic in these\n<a href=\"http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf\">slides</a>.\n\nIf you are looking for an actual tool, there we have a little tool to\nannotate Tiers-generated topologies. This perl-script is in\n<tt>tools/platform_generation/</tt> directory of the SVN. Dinda et Al.\nreleased a very comparable tool, and called it GridG.\n\n\nThe specified computing power will be available to up to 6 sequential\ntasks without sharing. If more tasks are placed on this host, the\nresource will be shared accordingly. For example, if you schedule 12\ntasks on the host, each will get half of the computing power. Please\nnote that although sound, this model were never scientifically\nassessed. Please keep this fact in mind when using it.\n\n\n\\subsubsection faq_platform_random Using random variable for the resource power or availability\n\nThe best way to model the resouce power using a random variable is to\nuse an availability trace that is directed by a probability\ndistribution. This can be done using the function\ntmgr_trace_generator_value() below. The date and value generators is\ncreated with one of tmgr_event_generator_new_uniform(),\ntmgr_event_generator_new_exponential() or\ntmgr_event_generator_new_weibull() (if you need other generators,\nadding them to src/surf/trace_mgr.c should be quite trivial and your\npatch will be welcomed). Once your trace is created, you have to\nconnect it to the resource with the function\nsg_platf_new_trace_connect().\n\nThat the process is very similar if you want to model the\nresource availability with a random variable (deciding whether it's\non/off instead of deciding its speed) using the function\ntmgr_trace_generator_state() or tmgr_trace_generator_avail_unavail()\ninstead of tmgr_trace_generator_value().\n\nUnfortunately, all this is currently lacking a proper documentation,\nand there is even no proper example of use. You'll thus have to check\nthe header file include/simgrid/platf.h and experiment a bit by\nyourself. The following code should be a good starting point, and\ncontributing a little clean example would be a good way to help the\nSimGrid project.\n\n@code\ntmgr_trace_generator_value(\"mytrace\",tmgr_event_generator_new_exponential(.5)\n                                     tmgr_event_generator_new_uniform(100000,9999999));\n\t\t\t\t     \nsg_platf_trace_connect_cbarg_t myconnect = SG_PLATF_TRACE_CONNECT_INITIALIZER;\nmyconnect.kind = SURF_TRACE_CONNECT_KIND_BANDWIDTH;\nmyconnect.trace = \"mytrace\";\nmyconnect.element = \"mylink\";\n\nsg_platf_trace_connect(myconnect);\n@endcode\n\n\\section faq_troubleshooting Troubleshooting\n\n\\subsection faq_trouble_changelog The feature X stopped to work after my last update \n\nI guess that you want to read the ChangeLog file, that always contains\nall the information that could be important to the users during the\nupgrade. Actually, you may want to read it (alongside with the NEWS\nfile that highlights the most important changes) even before you\nupgrade your copy of SimGrid, too.\n\nBackward compatibility is very important to us, as we want to provide\na scientific tool allowing to evaluate the code you write in several\nyears, too. That being said, we sometimes change the interface to make\nthem more usable to the users. When we do so, we always keep the old\ninterface as DEPRECATED. If you still want to use them, you want to\ndefine the SIMGRID_DEPRECATED preprocessor symbol before loading the\nSimGrid files:\n\n@verbatim\n#define SIMGRID_DEPRECATED\n#include <msg/msg.h>\n@endverbatim\n\n\\subsection faq_trouble_lib_compil SimGrid compilation and installation problems\n\n\\subsubsection faq_trouble_lib_config cmake fails!\n\nWe know only one reason for the configure to fail:\n\n - <b>You are using a broken build environment</b>\\n\n   If symptom is that the configury magic complains about gcc not being able to build\n   executables, you are probably missing the libc6-dev package. Damn Ubuntu.\n\nIf you experience other kind of issue, please get in touch with us. We are\nalways interested in improving our portability to new systems.\n\n\\subsubsection faq_trouble_distcheck Dude! \"ctest\" fails on my machine!\n\nDon't assume we never run this target, because we do. Check\nhttp://cdash.inria.fr/CDash/index.php?project=Simgrid (click on\nprevious if there is no result for today: results are produced only by\n11am, French time) and\nhttps://buildd.debian.org/status/logs.php?pkg=simgrid if you don't believe us.\n\nIf it's failing on your machine in a way not experienced by the\nautobuilders above, please drop us a mail on the mailing list so that\nwe can check it out. Make sure to read \\ref faq_bugrepport before you\ndo so.\n\n\\subsection faq_trouble_compil User code compilation problems\n\n\\subsubsection faq_trouble_err_logcat \"gcc: _simgrid_this_log_category_does_not_exist__??? undeclared (first use in this function)\"\n\nThis is because you are using the log mecanism, but you didn't created\nany default category in this file. You should refer to \\ref XBT_log\nfor all the details, but you simply forgot to call one of\nXBT_LOG_NEW_DEFAULT_CATEGORY() or XBT_LOG_NEW_DEFAULT_SUBCATEGORY().\n\n\\subsubsection faq_trouble_pthreadstatic \"gcc: undefined reference to pthread_key_create\"\n\nThis indicates that one of the library SimGrid depends on (libpthread\nhere) was missing on the linking command line. Dependencies of\nlibsimgrid are expressed directly in the dynamic library, so it's\nquite impossible that you see this message when doing dynamic linking.\n\nIf you compile your code statically (and if you use a pthread version\nof SimGrid), you must absolutely\nspecify <tt>-lpthread</tt> on the linker command line. As usual, this should\ncome after <tt>-lsimgrid</tt> on this command line.\n\n\\subsubsection faq_trouble_lib_msg_deprecated \"gcc: undefined reference to MSG_*\"\n\nSince version 3.7 all the m_channel_t mecanism is deprecated. So functions\nabout this mecanism may get removed in future releases.\n\nList of functions:\n\n\\li XBT_PUBLIC(int) MSG_get_host_number(void);\n\n\\li XBT_PUBLIC(m_host_t *) MSG_get_host_table(void);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_get_errno(void);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_get(m_task_t * task, m_channel_t channel);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_get_with_timeout(m_task_t * task, m_channel_t channel, double max_duration);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_get_from_host(m_task_t * task, int channel, m_host_t host);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_get_ext(m_task_t * task, int channel, double max_duration, m_host_t host);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_put(m_task_t task, m_host_t dest, m_channel_t channel);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_put_bounded(m_task_t task, m_host_t dest, m_channel_t channel, double max_rate);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_task_put_with_timeout(m_task_t task, m_host_t dest, m_channel_t channel, double max_duration);\n\n\\li XBT_PUBLIC(int) MSG_task_Iprobe(m_channel_t channel);\n\n\\li XBT_PUBLIC(int) MSG_task_probe_from(m_channel_t channel);\n\n\\li XBT_PUBLIC(int) MSG_task_probe_from_host(int channel, m_host_t host);\n\n\\li XBT_PUBLIC(MSG_error_t) MSG_set_channel_number(int number);\n\n\\li XBT_PUBLIC(int) MSG_get_channel_number(void);\n\nIf you want them you have to compile Simgrid v3.7 with option \"-Denable_msg_deprecated=ON\".\nUsing them should print warning to inform what new function you have to use.\n\n\\subsection faq_trouble_errors Runtime error messages\n\n\\subsubsection faq_flexml_limit \"surf_parse_lex: Assertion `next limit' failed.\"\n\nThis is because your platform file is too big for the parser.\n\nActually, the message comes directly from FleXML, the technology on top of\nwhich the parser is built. FleXML has the bad idea of fetching the whole\ndocument in memory before parsing it. And moreover, the memory buffer size\nmust be determined at compilation time.\n\nWe use a value which seems big enough for our need without bloating the\nsimulators footprints. But of course your mileage may vary. In this case,\njust edit src/surf/surfxml.l modify the definition of\nFLEXML_BUFFERSTACKSIZE. E.g.\n\n\\verbatim\n#define FLEXML_BUFFERSTACKSIZE 1000000000\n\\endverbatim\n\nThen recompile and everything should be fine, provided that your version of\nFlex is recent enough (>= 2.5.31). If not the compilation process should\nwarn you.\n\nA while ago, we worked on FleXML to reduce a bit its memory consumption, but\nthese issues remain. There is two things we should do:\n\n  - use a dynamic buffer instead of a static one so that the only limit\n    becomes your memory, not a stupid constant fixed at compilation time\n    (maybe not so difficult).\n  - change the parser so that it does not need to get the whole file in\n    memory before parsing\n    (seems quite difficult, but I'm a complete newbe wrt flex stuff).\n\nThese are changes to FleXML itself, not SimGrid. But since we kinda hijacked\nthe development of FleXML, I can grant you that any patches would be really\nwelcome and quickly integrated.\n\n<b>Update:</b> A new version of FleXML (1.7) was released. Most of the work\nwas done by William Dowling, who use it in his own work. The good point is\nthat it now use a dynamic buffer, and that the memory usage was greatly\nimproved. The downside is that William also changed some things internally,\nand it breaks the hack we devised to bypass the parser, as explained in\n\\ref pf_flexml_bypassing. Indeed, this is not a classical usage of the\nparser, and Will didn't imagine that we may have used (and even documented)\nsuch a crude usage of FleXML. So, we now have to repair the bypassing\nfunctionality to use the latest FleXML version and fix the memory usage in\nSimGrid.\n\n\\subsubsection faq_trouble_errors_big_fat_warning I'm told that my XML files are too old.\n\nThe format of the XML platform description files is sometimes\nimproved. For example, we decided to change the units used in SimGrid\nfrom MBytes, MFlops and seconds to Bytes, Flops and seconds to ease\npeople exchanging small messages. We also reworked the route\ndescriptions to allow more compact descriptions.\n\nThat is why the XML files are versionned using the 'version' attribute\nof the root tag. Currently, it should read:\n\\verbatim\n  <platform version=\"2\">\n\\endverbatim\n\nIf your files are too old, you can use the simgrid_update_xml.pl\nscript which can be found in the tools directory of the archive.\n\n\\subsection faq_trouble_valgrind Valgrind-related and other debugger issues\n\nIf you don't, you really should use valgrind to debug your code, it's\nalmost magic.\n\n\\subsubsection faq_trouble_vg_longjmp longjmp madness in valgrind\n\nThis is when valgrind starts complaining about longjmp things, just like:\n\n\\verbatim ==21434== Conditional jump or move depends on uninitialised value(s)\n==21434==    at 0x420DBE5: longjmp (longjmp.c:33)\n==21434==\n==21434== Use of uninitialised value of size 4\n==21434==    at 0x420DC3A: __longjmp (__longjmp.S:48)\n\\endverbatim\n\nThis is the sign that you didn't used the exception mecanism well. Most\nprobably, you have a <tt>return;</tt> somewhere within a <tt>TRY{}</tt>\nblock. This is <b>evil</b>, and you must not do this. Did you read the section\nabout \\ref XBT_ex??\n\n\\subsubsection faq_trouble_vg_libc Valgrind spits tons of errors about backtraces!\n\nIt may happen that valgrind, the memory debugger beloved by any decent C\nprogrammer, spits tons of warnings like the following :\n\\verbatim ==8414== Conditional jump or move depends on uninitialised value(s)\n==8414==    at 0x400882D: (within /lib/ld-2.3.6.so)\n==8414==    by 0x414EDE9: (within /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)\n==8414==    by 0x414F937: _dl_open (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x4150F4C: (within /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)\n==8414==    by 0x415102D: __libc_dlopen_mode (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x412D6B9: backtrace (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x8076446: xbt_dictelm_get_ext (dict_elm.c:714)\n==8414==    by 0x80764C1: xbt_dictelm_get (dict_elm.c:732)\n==8414==    by 0x8079010: xbt_cfg_register (config.c:208)\n==8414==    by 0x806821B: MSG_config (msg_config.c:42)\n\\endverbatim\n\nThis problem is somewhere in the libc when using the backtraces and there is\nvery few things we can do ourselves to fix it. Instead, here is how to tell\nvalgrind to ignore the error. Add the following to your ~/.valgrind.supp (or\ncreate this file on need). Make sure to change the obj line according to\nyour personnal mileage (change 2.3.6 to the actual version you are using,\nwhich you can retrieve with a simple \"ls /lib/ld*.so\").\n\n\\verbatim {\n   name: Backtrace madness\n   Memcheck:Cond\n   obj:/lib/ld-2.3.6.so\n   fun:dl_open_worker\n   fun:_dl_open\n   fun:do_dlopen\n   fun:dlerror_run\n   fun:__libc_dlopen_mode\n}\\endverbatim\n\nThen, you have to specify valgrind to use this suppression file by passing\nthe <tt>--suppressions=$HOME/.valgrind.supp</tt> option on the command line.\nYou can also add the following to your ~/.bashrc so that it gets passed\nautomatically. Actually, it passes a bit more options to valgrind, and this\nhappen to be my personnal settings. Check the valgrind documentation for\nmore information.\n\n\\verbatim export VALGRIND_OPTS=\"--leak-check=yes --leak-resolution=high --num-callers=40 --tool=memcheck --suppressions=$HOME/.valgrind.supp\" \\endverbatim\n\n\\subsubsection faq_trouble_backtraces Truncated backtraces\n\nWhen debugging SimGrid, it's easier to pass the\n--disable-compiler-optimization flag to the configure if valgrind or\ngdb get fooled by the optimization done by the compiler. But you\nshould remove these flag when everything works before going in\nproduction (before launching your 1252135 experiments), or everything\nwill run only one half of the true SimGrid potential.\n\n\\subsection faq_deadlock There is a deadlock in my code!!!\n\nUnfortunately, we cannot debug every code written in SimGrid.  We\nfurthermore believe that the framework provides ways enough\ninformation to debug such informations yourself. If the textual output\nis not enough, Make sure to check the \\ref faq_visualization FAQ entry to see\nhow to get a graphical one.\n\nNow, if you come up with a really simple example that deadlocks and\nyou're absolutely convinced that it should not, you can ask on the\nlist. Just be aware that you'll be severely punished if the mistake is\non your side... We have plenty of FAQ entries to redact and new\nfeatures to implement for the impenitents! ;)\n\nUsing \n\n\\subsection faq_surf_network_latency I get weird timings when I play with the latencies.\n\nOK, first of all, remember that units should be Bytes, Flops and\nSeconds. If you don't use such units, some SimGrid constants (e.g. the\nSG_TCP_CTE_GAMMA constant used in most network models) won't have the\nright unit and you'll end up with weird results.\n\nHere is what happens with a single transfer of size L on a link\n(bw,lat) when nothing else happens.\n\n\\verbatim\n0-----lat--------------------------------------------------t\n|-----|**** real_bw =min(bw,SG_TCP_CTE_GAMMA/(2*lat)) *****|\n\\endverbatim\n\nIn more complex situations, this min is the solution of a complex\nmax-min linear system.  Have a look\n<a href=\"http://lists.gforge.inria.fr/pipermail/simgrid-devel/2006-April/thread.html\">here</a>\nand read the two threads \"Bug in SURF?\" and \"Surf bug not\nfixed?\". You'll have a few other examples of such computations. You\ncan also read \"A Network Model for Simulation of Grid Application\" by\nHenri Casanova and Loris Marchal to have all the details. The fact\nthat the real_bw is smaller than bw is easy to understand. The fact\nthat real_bw is smaller than SG_TCP_CTE_GAMMA/(2*lat) is due to the\nwindow-based congestion mechanism of TCP. With TCP, you can't exploit\nyour huge network capacity if you don't have a good round-trip-time\nbecause of the acks...\n\nAnyway, what you get is t=lat + L/min(bw,SG_TCP_CTE_GAMMA/(2*lat)).\n\n  * if I you set (bw,lat)=(100 000 000, 0.00001), you get t =  1.00001 (you fully\nuse your link)\n  * if I you set (bw,lat)=(100 000 000, 0.0001),  you get t =  1.0001 (you're on the\nlimit)\n  * if I you set (bw,lat)=(100 000 000, 0.001),   you get t = 10.001  (ouch!)\n\nThis bound on the effective bandwidth of a flow is not the only thing\nthat may make your result be unexpected. For example, two flows\ncompeting on a saturated link receive an amount of bandwidth inversely\nproportional to their round trip time.\n\n\\subsection faq_bugrepport So I've found a bug in SimGrid. How to report it?\n\nWe do our best to make sure to hammer away any bugs of SimGrid, but this is\nstill an academic project so please be patient if/when you find bugs in it.\nIf you do, the best solution is to drop an email either on the simgrid-user\nor the simgrid-devel mailing list and explain us about the issue.  You can\nalso decide to open a formal bug report using the\n<a href=\"https://gforge.inria.fr/tracker/?atid=165&group_id=12&func=browse\">relevant\ninterface</a>. You need to login on the server to get the ability to submit\nbugs.\n\nWe will do our best to solve any problem repported, but you need to help us\nfinding the issue. Just telling \"it segfault\" isn't enough. Telling \"It\nsegfaults when running the attached simulator\" doesn't really help either.\nYou may find the following article interesting to see how to repport\ninformative bug repports:\nhttp://www.chiark.greenend.org.uk/~sgtatham/bugs.html (it is not SimGrid\nspecific at all, but it's full of good advices).\n\n\\author Da SimGrid team <simgrid-devel@lists.gforge.inria.fr>\n\n*/\n\n******************************************************************\n*              OLD CRUFT NOT USED ANYMORE                        *\n******************************************************************\n\n\nsubsection faq_crosscompile Cross-compiling a Windows DLL of SimGrid from linux\n\nAt the moment, we do not distribute Windows pre-compiled version of SimGrid\nbecause the support for this platform is still experimental. We know that\nsome parts of the GRAS environment do not work, and we think that the others\nenvironments (MSG and SD) have good chances to work, but we didn't test\nourselves. This section explains how we generate the SimGrid DLL so that you\ncan build it for yourself. First of all, you need to have a version more\nrecent than 3.1 (ie, a SVN version as time of writting).\n\nIn order to cross-compile the package to windows from linux, you need to\ninstall mingw32 (minimalist gnu win32). On Debian, you can do so by\ninstalling the packages mingw32 (compiler), mingw32-binutils (linker and\nso), mingw32-runtime.\n\nYou can use the VPATH support of configure to compile at the same time for\nlinux and windows without dupplicating the source nor cleaning the tree\nbetween each. Just run bootstrap (if you use the SVN) to run the autotools.\nThen, create a linux and a win directories. Then, type:\n\\verbatim  cd linux; ../configure --srcdir=.. <usual configure flags>; make; cd ..\ncd win;  ../configure --srcdir=.. --host=i586-mingw32msvc <flags>; make; cd ..\n\\endverbatim\nThe trick to VPATH builds is to call configure from another directory,\npassing it an extra --srcdir argument to tell it where all the sources are.\nIt will understand you want to use VPATH. Then, the trick to cross-compile\nis simply to add a --host argument specifying the target you want to build\nfor. The i586-mingw32msvc string is what you have to pass to use the mingw32\nenvironment as distributed in Debian.\n\nAfter that, you can run all make targets from both directories, and test\neasily that what you change for one arch does not break the other one.\n\nIt is possible that this VPATH build thing breaks from time to time in the\nSVN since it's quite fragile, but it's granted to work in any released\nversion. If you experience problems, drop us a mail.\n\nAnother possible source of issue is that at the moment, building the\nexamples request to use the gras_stub_generator tool, which is a compiled\nprogram, not a script. In cross-compilation, you need to cross-execute with\nwine for example, which is not really pleasant. We are working on this, but\nin the meanwhile, simply don't build the examples in cross-compilation\n(<tt>cd src</tt> before running make).\n\nProgram (cross-)compiled with mingw32 do request an extra DLL at run-time to be\nusable. For example, if you want to test your build with wine, you should do\nthe following to put this library where wine looks for DLLs.\n\\verbatim\ncp /usr/share/doc/mingw32-runtime/mingwm10.dll.gz ~/.wine/c/windows/system/\ngunzip ~/.wine/c/windows/system/mingwm10.dll.gz\n\\endverbatim\n\nThe DLL is built in src/.libs, and installed in the <i>prefix</i>/bin directory\nwhen you run make install.\n\nIf you want to use it in a native project on windows, you need to use\nsimgrid.dll and mingwm10.dll. For each DLL, you need to build .def file\nunder linux (listing the defined symbols), and convert it into a .lib file\nunder windows (specifying this in a way that windows compilers like). To\ngenerate the def files, run (under linux):\n\\verbatim echo \"LIBRARY libsimgrid-0.dll\" > simgrid.def\necho EXPORTS >> simgrid.def\nnm libsimgrid-0.dll | grep ' T _' | sed 's/.* T _//' >> simgrid.def\nnm libsimgrid-0.dll | grep ' D _' | sed 's/.* D _//' | sed 's/$/ DATA/' >> simgrid.def\n\necho \"LIBRARY mingwm10.dll\" > mingwm10.def\necho EXPORTS >> mingwm10.def\nnm mingwm10.dll | grep ' T _' | sed 's/.* T _//' >> mingwm10.def\nnm mingwm10.dll | grep ' D _' | sed 's/.* D _//' | sed 's/$/ DATA/' >> mingwm10.def\n\\endverbatim\n\nTo create the import .lib files, use the <tt>lib</tt> windows tool (from\nMSVC) the following way to produce simgrid.lib and mingwm10.lib\n\\verbatim lib /def:simgrid.def\nlib /def:mingwm10.def\n\\endverbatim\n\nIf you happen to use Borland C Builder, the right command line is the\nfollowing (note that you don't need any file.def to get this working).\n\\verbatim implib simgrid.lib libsimgrid-0.dll\nimplib mingwm10.lib mingwm10.dll\n\\endverbatim\n\nThen, set the following parameters in Visual C++ 2005:\nLinker -> Input -> Additional dependencies = simgrid.lib mingwm10.lib\n\nJust in case you wonder how to generate a DLL from libtool in another\nproject, we added -no-undefined to any lib*_la_LDFLAGS variables so that\nlibtool accepts to generate a dynamic library under windows. Then, to make\nit true, we pass any dependencies (such as -lws2 under windows or -lpthread\non need) on the linking line. Passing such deps is a good idea anyway so\nthat they get noted in the library itself, avoiding the users to know about\nour dependencies and put them manually on their compilation line. Then we\nadded the AC_LIBTOOL_WIN32_DLL macro just before AC_PROG_LIBTOOL in the\nconfigure.ac. It means that we exported any symbols which need to be.\nNowadays, functions get automatically exported, so we don't need to load our\nheader files with tons of __declspec(dllexport) cruft. We only need to do so\nfor data, but there is no public data in SimGrid so we are good.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/surf++.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/triva-time_interval.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/triva-graph_visualization.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/surf++.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/triva-graph_configuration.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/sc3-description.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/smpi_simgrid_alltoall_pair_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/output.goal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/smpi_simgrid_alltoall_ring_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/AS_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/SGicon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_03.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_05.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_06.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/SGicon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/SGicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/awstats_logo3.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/win_install_04.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/poster_thumbnail.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/simgrid_logo_2011_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/simgrid_logo_win.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.12-iczmexbtkkouk7xcqepv2qldrdkd4bam/spack-src/doc/webcruft/simgrid_logo_win_2011.bmp"
    ],
    "total_files": 2569
}