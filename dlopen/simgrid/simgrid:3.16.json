{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/CMakeLists.txt": "cmake_minimum_required(VERSION 2.8.8)\nmessage(STATUS \"Cmake version ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}\")\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_HOME_DIRECTORY}/tools/cmake/Modules)\n\nproject(SimGrid C CXX)\n\n#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#\n#     Check for the compiler        #\n#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#\n\n### Need to set rc ccompiler before enable language\nif(WIN32)\n  SET(CMAKE_RC_COMPILER \"windres\")\nendif()\n\n## \n## Check the C/C++ standard that we need\n##   See also tools/cmake/GCCFlags.cmake that sets our paranoid warning flags\nINCLUDE(CheckCCompilerFlag)\nCHECK_C_COMPILER_FLAG(-fstack-cleaner HAVE_C_STACK_CLEANER)\n\n## Request full debugging flags\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g3\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g3\")\nset(CMAKE_Fortran_FLAGS \"${CMAKE_Fortran_FLAGS} -g\")\n\nif (CMAKE_COMPILER_IS_GNUCC)    \n  if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS \"4.7\")\n    message(FATAL_ERROR\n            \"SimGrid needs at least g++ version 4.7 to compile but you have ${CMAKE_CXX_COMPILER_VERSION}.\"\n            \"You need a sufficient support of c++11 to compile SimGrid.\")\n  endif()\nendif()\n\n## We need a decent support of the c++11 standard\ninclude(CheckCXXCompilerFlag)\nCHECK_CXX_COMPILER_FLAG(\"-std=gnu++11\" COMPILER_SUPPORTS_CXX11)\nif(COMPILER_SUPPORTS_CXX11)\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=gnu++11\")\nelse() \n  message(FATAL_ERROR \n          \"The compiler ${CMAKE_CXX_COMPILER} (v${CMAKE_CXX_COMPILER_VERSION}) has no C++11 support. \"\n           \"Please use a decent C++ compiler.\")\nendif()\n\n### And we need C11 standard, too\ninclude(CheckCCompilerFlag)\nCHECK_C_COMPILER_FLAG(\"-std=gnu11\" COMPILER_SUPPORTS_C11)\nif(COMPILER_SUPPORTS_C11)\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=gnu11\")\nelse()\n  message(FATAL_ERROR \n          \"The compiler ${CMAKE_C_COMPILER} (v${CMAKE_C_COMPILER_VERSION}) has no C11 support. \"\n          \"Please use a decent C compiler \"\n          \"(note that c++11 support of ${CMAKE_CXX_COMPILER} seems ok).\")\nendif()\nif(APPLE AND (CMAKE_C_COMPILER_VERSION VERSION_LESS \"4.6\"))\n  ### gcc 4.[1-5] cannot compile ucontext on OSX\n  message(STATUS \"Ucontext can't be used with this version of gcc (must be greater than 4.5)\")\n  set(HAVE_UCONTEXT_H 0)\nendif()\n\n### Check threading support\nset(CMAKE_THREAD_PREFER_PTHREAD TRUE)\nfind_package(Threads)\n\n### Setup Options\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/Option.cmake)\n\n### SMPI vs. Fortran\nif ((NOT DEFINED enable_smpi) OR enable_smpi) \n  # First unset the compiler in case we're re-running cmake over a previous\n  # configuration where it was saved as smpiff\n  unset(CMAKE_Fortran_COMPILER)\n  \n  SET(SMPI_FORTRAN 0)\n  if(enable_fortran)\n    enable_language(Fortran OPTIONAL)\n  endif()\n  \n  if(CMAKE_Fortran_COMPILER)\n    # Fortran compiler detected: save it, then replace by smpiff\n    set(SMPI_Fortran_COMPILER \"${CMAKE_Fortran_COMPILER}\" CACHE FILEPATH \"The real Fortran compiler\")\n    set(CMAKE_Fortran_COMPILER smpiff)\n\n\t# Set flags/libs to be used in smpiff\n    if(CMAKE_Fortran_COMPILER_ID MATCHES \"GNU\")\n      set(SMPI_Fortran_FLAGS \"\\\"-fpic\\\" \\\"-ff2c\\\" \\\"-fno-second-underscore\\\"\")\n      set(SMPI_Fortran_LIBS \"\\\"-lgfortran\\\"\")\n    elseif(CMAKE_Fortran_COMPILER_ID MATCHES \"Intel\")\n      set(SMPI_Fortran_FLAGS \"\\\"-fPIC\\\" \\\"-nofor-main\\\"\")\n      set(SMPI_Fortran_LIBS \"\\\"-lifcore\\\"\")\n    elseif(CMAKE_Fortran_COMPILER_ID MATCHES \"PGI\") # flang\n      set(SMPI_Fortran_FLAGS \"\\\"-fPIC\\\"\")\n      set(SMPI_Fortran_LIBS \"\")\n    endif()\n\n    set(SMPI_FORTRAN 1)\n  endif(CMAKE_Fortran_COMPILER)\n\nendif()\n\n#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#\n#     Build the version number      #\n#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#\n\nset(SIMGRID_VERSION_MAJOR \"3\")\nset(SIMGRID_VERSION_MINOR \"16\")\nset(SIMGRID_VERSION_PATCH \"0\")\nset(SIMGRID_VERSION_EXTRA \"\") # -DEVEL\") # Extra words to add to version string (e.g. -rc1)\n\nset(SIMGRID_VERSION_DATE  \"2017\") # Year for copyright information\n\nif(${SIMGRID_VERSION_PATCH} EQUAL \"0\")\n  set(release_version \"${SIMGRID_VERSION_MAJOR}.${SIMGRID_VERSION_MINOR}\")\nelse()\n  set(release_version \"${SIMGRID_VERSION_MAJOR}.${SIMGRID_VERSION_MINOR}.${SIMGRID_VERSION_PATCH}\")\nendif()\n\nset(SIMGRID_VERSION_STRING \"SimGrid version ${release_version}${SIMGRID_VERSION_EXTRA}\")\n\nset(libsimgrid_version \"${release_version}\")\nset(libsimgrid-java_version \"${release_version}\")\n\n### SET THE LIBRARY EXTENSION \nif(APPLE)\n  set(LIB_EXE \"dylib\")\nelseif(WIN32)\n  set(LIB_EXE \"a\")\n  set(BIN_EXE \".exe\")\nelse()\n  set(LIB_EXE \"so\")\nendif()\n\nexecute_process(COMMAND ${CMAKE_LINKER} -version OUTPUT_VARIABLE LINKER_VERSION ERROR_VARIABLE LINKER_VERSION)\nstring(REGEX MATCH \"[0-9].[0-9]*\" LINKER_VERSION \"${LINKER_VERSION}\")\n\n### Set the library providing dlopen\nif(\"${CMAKE_SYSTEM}\" MATCHES \"Linux\")\n  find_library(DL_LIBRARY dl)\nendif(\"${CMAKE_SYSTEM}\" MATCHES \"Linux\")\n\n### Find programs and paths\nFIND_PROGRAM(GCOV_PATH gcov)\ninclude(FindPerl)\nif(NOT PERL_FOUND)\n  message(FATAL_ERROR \"Please install Perl to compile SimGrid.\")\nendif()\n\n# tesh.py needs python 3 (or the module python-subprocess32 on python2.8+)\nset(PythonInterp_FIND_VERSION 3)\nset(PythonInterp_FIND_VERSION_COUNT 1)\nset(PythonInterp_FIND_VERSION_MAJOR 3)\ninclude(FindPythonInterp)\nif(NOT PYTHONINTERP_FOUND)\n  message(FATAL_ERROR \"Please install Python (version 3 or higher).\")\nendif()\n\nSET(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/lib)\n\n### Compute the include paths\nset(INCLUDES\n  ${CMAKE_HOME_DIRECTORY}\n  ${CMAKE_HOME_DIRECTORY}/include\n  ${CMAKE_HOME_DIRECTORY}/src/include\n  ${CMAKE_BINARY_DIR}\n  ${CMAKE_BINARY_DIR}/include\n  )\n\nif(NOT CMAKE_CROSSCOMPILING AND EXISTS /usr/include/)\n  set(INCLUDES ${INCLUDES} /usr/include/)\nendif()\n\nif(WIN32)\n  set(CMAKE_INCLUDE_WIN \"${CMAKE_C_COMPILER}\")\n  set(CMAKE_LIB_WIN \"${CMAKE_C_COMPILER}\")\n  string(REGEX REPLACE \"/bin/gcc.*\" \"/include\"  CMAKE_INCLUDE_WIN \"${CMAKE_INCLUDE_WIN}\")\n  string(REGEX REPLACE \"/bin/gcc.*\" \"/lib\"  CMAKE_LIB_WIN \"${CMAKE_LIB_WIN}\")\n  set(INCLUDES ${INCLUDES} ${CMAKE_INCLUDE_WIN})\n  unset(CMAKE_INCLUDE_WIN)\nendif()\n\ninclude_directories(${INCLUDES})\n\n# library dependency cannot start with a space (CMP0004), so initialize it with something that is never desactivated.\nset(SIMGRID_DEP \"-lm\") \n\n### Determine the assembly flavor that we need today\nset(HAVE_RAW_CONTEXTS 0)\ninclude(CMakeDetermineSystem)\nIF(CMAKE_SYSTEM_PROCESSOR MATCHES \".86|AMD64|amd64\")\n  IF(CMAKE_SIZEOF_VOID_P EQUAL 4) # 32 bits\n    message(STATUS \"System processor: i686 (${CMAKE_SYSTEM_PROCESSOR}, 32 bits)\")\n    set(SIMGRID_PROCESSOR_i686 1)\n    set(SIMGRID_PROCESSOR_x86_64 0)\n  ELSE()\n    message(STATUS \"System processor: x86_64 (${CMAKE_SYSTEM_PROCESSOR}, 64 bits)\")\n    set(SIMGRID_PROCESSOR_i686 0)\n    set(SIMGRID_PROCESSOR_x86_64 1)\n  ENDIF()\n  if (WIN32)\n    message(STATUS \"Disable fast raw contexts on Windows.\")\n  else()\n    set(HAVE_RAW_CONTEXTS 1)\n  endif()\nELSE()\n  set(SIMGRID_PROCESSOR_i686 0)\n  set(SIMGRID_PROCESSOR_x86_64 0)\nENDIF()\n\ninclude(CheckFunctionExists)\ninclude(CheckTypeSize)\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\n\nset(HAVE_GRAPHVIZ 0)\ninclude(FindGraphviz)\n\nset(SIMGRID_HAVE_LUA 0)\nif(enable_lua)\n  include(FindLuaSimgrid)\nendif()\n\nset(SIMGRID_HAVE_NS3 0)\nif(enable_ns3)\n  include(FindNS3)\n  if (SIMGRID_HAVE_NS3)\n    set(SIMGRID_HAVE_NS3 1)\n  else()\n    message(FATAL_ERROR \"Cannot find NS3. Please install it (apt-get install ns3 libns3-dev) or disable that cmake option\")\n  endif()\nendif()\n\nif(WIN32)\n  set(Boost_USE_STATIC_LIBS 1)\nendif()\nset(HAVE_PAPI 0)\nif(enable_smpi_papi)\n  include(FindPAPI)\n  if (NOT HAVE_PAPI)\n    message(FATAL_ERROR \"Cannot find PAPI. Please install it (apt-get install papi-tools libpapi-dev) or disable PAPI bindings.\")\n  endif()\nendif()\n\n# Not finding this is perfectly OK\nfind_package(Boost COMPONENTS unit_test_framework)\nif (Boost_UNIT_TEST_FRAMEWORK_FOUND)\n  message(\"--   (enabling the Boost-based unit tests)\")\nelse()\n  message(\"--   (disabling the Boost-based unit tests -- please install libboost-test-dev)\")\nendif()\n\n\nfind_package(Boost 1.48)\nif(Boost_FOUND)\n  include_directories(${Boost_INCLUDE_DIRS})\nelse()\n  if(APPLE)\n    message(FATAL_ERROR \"Boost libraries not found. Try to install them with 'sudo fink install boost1.53.nopython' (check the exact name with 'fink list boost') or 'sudo brew install boost'\")\n  else()\n    message(FATAL_ERROR \"Boost libraries not found. Install libboost-dev (>= 1.48.0).\")\n  endif()\nendif()\n\nfind_package(Boost COMPONENTS context)\nset(Boost_FOUND 1) # This component is optional\nif(Boost_CONTEXT_FOUND)\n  if (Boost_VERSION LESS 105600)\n    message(\"Found Boost.Context API v1\")\n    set(HAVE_BOOST_CONTEXTS 1)\n  elseif(Boost_VERSION LESS 106100)\n    message(\"Found Boost.Context API v2\")\n    set(HAVE_BOOST_CONTEXTS 2)\n  else()\n    message(\"   WARNING : our implementation of Boost context factory is not compatible with Boost >=1.61 yet.\")\n    set(HAVE_BOOST_CONTEXTS 0)\n  endif()\nelse()\n  message (\"   boost        : found.\")\n  message (\"   boost-context: missing. Install libboost-context-dev for this optional feature.\")\n  set(HAVE_BOOST_CONTEXTS 0)\nendif()\n\n# Checks for header libraries functions.\nCHECK_LIBRARY_EXISTS(rt      clock_gettime           \"\" HAVE_POSIX_GETTIME)\n\nif(NOT APPLE) # OS X El Capitan deprecates this function\n  CHECK_LIBRARY_EXISTS(pthread sem_init                \"\" HAVE_SEM_INIT_LIB)\nendif()\nCHECK_LIBRARY_EXISTS(pthread sem_open                \"\" HAVE_SEM_OPEN_LIB)\nset(HAVE_PTHREAD_SETAFFINITY 0)\nCHECK_LIBRARY_EXISTS(pthread pthread_setaffinity_np  \"\" HAVE_PTHREAD_SETAFFINITY)\n\nif(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_XOPEN_SOURCE=700 -D_DARWIN_C_SOURCE\")\nelseif(MINGW)\n  # Use the GNU version of unusual modifiers like PRIx64\n  add_definitions(-D__USE_MINGW_ANSI_STDIO=1)\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D__USE_MINGW_ANSI_STDIO=1\")\nelse()\n  set(CMAKE_REQUIRED_DEFINITIONS \"-D_GNU_SOURCE\")\nendif()\n\nCHECK_INCLUDE_FILE(\"valgrind/valgrind.h\" HAVE_VALGRIND_H)\nCHECK_INCLUDE_FILE(\"unistd.h\" HAVE_UNISTD_H)\nCHECK_INCLUDE_FILE(\"execinfo.h\" HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILE(\"signal.h\" HAVE_SIGNAL_H)\nCHECK_INCLUDE_FILE(\"sys/param.h\" HAVE_SYS_PARAM_H)\nCHECK_INCLUDE_FILE(\"sys/sysctl.h\" HAVE_SYS_SYSCTL_H)\nCHECK_INCLUDE_FILE(\"ucontext.h\" HAVE_UCONTEXT_H)\nCHECK_INCLUDE_FILE(\"linux/futex.h\" HAVE_FUTEX_H)\n\nCHECK_FUNCTION_EXISTS(backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS(dlfunc HAVE_DLFUNC)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\nCHECK_FUNCTION_EXISTS(nanosleep HAVE_NANOSLEEP)\nCHECK_FUNCTION_EXISTS(getdtablesize HAVE_GETDTABLESIZE)\nCHECK_FUNCTION_EXISTS(sysconf HAVE_SYSCONF)\nCHECK_FUNCTION_EXISTS(popen HAVE_POPEN)\nCHECK_FUNCTION_EXISTS(process_vm_readv HAVE_PROCESS_VM_READV)\nCHECK_FUNCTION_EXISTS(mmap HAVE_MMAP)\nCHECK_FUNCTION_EXISTS(mremap HAVE_MREMAP)\n\nCHECK_SYMBOL_EXISTS(vasprintf stdio.h HAVE_VASPRINTF)\nif(MINGW)\n  # The detection of vasprintf fails on MinGW, assumingly because it's\n  # defined as an inline function in stdio.h instead of a regular\n  # function. So force the result to be 1 despite of the test.\n  set(HAVE_VASPRINTF 1)\nendif()\n\n#Check if __thread is defined\nexecute_process(\n  COMMAND \"${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_thread_storage.c -o testprog\"\n  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n  RESULT_VARIABLE HAVE_thread_storage_run)\nfile(REMOVE testprog)\nif(HAVE_thread_storage_run)\n  set(HAVE_THREAD_LOCAL_STORAGE 1)\nelse()\n  set(HAVE_THREAD_LOCAL_STORAGE 0)\nendif()\n\nCHECK_INCLUDE_FILE(\"sys/sendfile.h\" HAVE_SENDFILE_H)\nCHECK_FUNCTION_EXISTS(sendfile HAVE_SENDFILE)\nif(HAVE_SENDFILE_H AND HAVE_SENDFILE)\n  set(HAVE_SENDFILE 1)\nelse()\n  set(HAVE_SENDFILE 0)\nendif()\n\nif(enable_model-checking AND NOT \"${CMAKE_SYSTEM}\" MATCHES \"Linux|FreeBSD\")\n  message(WARNING \"Support for model-checking has not been enabled on ${CMAKE_SYSTEM}: disabling it\")\n  set(enable_model-checking FALSE)\nendif()\n\nif(HAVE_MMAP AND HAVE_THREAD_LOCAL_STORAGE)\n  SET(HAVE_MMALLOC 1)\nelse()\n  SET(HAVE_MMALLOC 0)\n  if(enable_model-checking)\n    message(STATUS \"Warning: support for model-checking has been disabled because you are missing either mmap or __thread.\")\n  endif()\n  SET(enable_model-checking 0)\nendif()\n\nif(enable_jedule)\n  set(SIMGRID_HAVE_JEDULE 1)\nelse()\n  set(SIMGRID_HAVE_JEDULE 0)\nendif()\n\nif(enable_mallocators)\n  SET(SIMGRID_HAVE_MALLOCATOR 1)\nelse()\n  SET(SIMGRID_HAVE_MALLOCATOR 0)\nendif()\n\ninclude(FindLibunwind)\nif(HAVE_LIBUNWIND)\n  if(NOT APPLE)\n    SET(SIMGRID_DEP \"${SIMGRID_DEP} -lunwind\")\n  else()\n    # Apple forbids to link directly against its libunwind implementation\n    # So let's comply and link against the System framework\n    SET(SIMGRID_DEP \"${SIMGRID_DEP} -lSystem\")\n  endif()\n  if(\"${CMAKE_SYSTEM}\" MATCHES \"Linux|FreeBSD\")\n    set(SIMGRID_DEP \"${SIMGRID_DEP} -lunwind-ptrace\")\n    # This supposes that the host machine is either an AMD or a X86.\n    # This is deeply wrong, and should be fixed by manually loading -lunwind-PLAT (FIXME)\n    if(SIMGRID_PROCESSOR_x86_64)\n      SET(SIMGRID_DEP \"${SIMGRID_DEP} -lunwind-x86_64\")\n    else()\n      SET(SIMGRID_DEP \"${SIMGRID_DEP} -lunwind-x86\")\n    endif()\n  endif()\nelse()\n  if(enable_model-checking)\n    message(FATAL_ERROR \"Please install libunwind-dev libdw-dev libevent-dev if you want to compile the SimGrid model checker.\")\n  endif()\nendif()\n\nif(enable_model-checking)\n  find_package(Libdw REQUIRED)\n  find_package(Libevent REQUIRED)\n  include_directories(${LIBDW_INCLUDE_DIR} ${LIBEVENT_INCLUDE_DIR})\n  set(SIMGRID_DEP \"${SIMGRID_DEP} ${LIBEVENT_LIBRARIES} ${LIBDW_LIBRARIES}\")\n  set(SIMGRID_HAVE_MC 1)\n  if(\"${CMAKE_SYSTEM}\" MATCHES \"FreeBSD\" AND enable_java)\n    message(WARNING \"FreeBSD + Model-Checking + Java = too much for now. Disabling java\")\n    set(enable_java FALSE)\n  endif()\nelse()\n  SET(SIMGRID_HAVE_MC 0)  \n  set(HAVE_MMALLOC 0)\nendif()\n\nif (enable_model-checking AND enable_ns3)\n  message(FATAL_ERROR \"Cannot activate both model-checking and NS3 bindings: NS3 pull too much dependencies for the MC to work\")\nendif()\n\nif(enable_smpi)\n  SET(HAVE_SMPI 1)\n  if(\"${CMAKE_SYSTEM}\" MATCHES \"Darwin|FreeBSD|Linux\")\n    SET(USE_LIBUTIL 0)\n    SET(HAVE_PRIVATIZATION 1)\n  else()\n    message (STATUS \"Warning:  no support for SMPI automatic privatization on this platform\")\n    SET(HAVE_PRIVATIZATION 0)\n  endif()\nelse()\n  SET(HAVE_SMPI 0)\nendif()\n\n#--------------------------------------------------------------------------------------------------\n### Check for GNU dynamic linker\nCHECK_INCLUDE_FILE(\"dlfcn.h\" HAVE_DLFCN_H)\nif (HAVE_DLFCN_H)\n  execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_gnu_dynlinker.c ${DL_LIBRARY} -o test_gnu_ld\n                  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n                  OUTPUT_VARIABLE HAVE_GNU_LD_compil\n  )\n  if(HAVE_GNU_LD_compil)\n    set(HAVE_GNU_LD 0)\n    message(STATUS \"Warning: test program toward GNU ld failed to compile:\")\n    message(STATUS \"${HAVE_GNU_LD_comp_output}\")\n  else()\n    execute_process(COMMAND ./test_gnu_ld\n                    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n                    RESULT_VARIABLE HAVE_GNU_LD_run\n                    OUTPUT_VARIABLE var_exec\n                   )\n\n    if(NOT HAVE_GNU_LD_run)\n      set(HAVE_GNU_LD 1)\n      message(STATUS \"We are using GNU dynamic linker\")\n    else()\n      set(HAVE_GNU_LD 0)\n      message(STATUS \"Warning: error while checking for GNU ld:\")\n      message(STATUS \"Test output: '${var_exec}'\")\n      message(STATUS \"Exit status: ${HAVE_GNU_LD_run}\")\n    endif()\n    file(REMOVE test_gnu_ld)\n  endif()\nendif()\n\n#--------------------------------------------------------------------------------------------------\n### Initialize of CONTEXT THREADS\n\nset(HAVE_THREAD_CONTEXTS 0)\nif(CMAKE_USE_PTHREADS_INIT)\n  ### Test that we have a way to create semaphores\n\n  if(HAVE_SEM_OPEN_LIB)\n    execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_sem_open.c -lpthread -o sem_open\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      OUTPUT_VARIABLE HAVE_SEM_OPEN_compil\n    )\n\n    # Test sem_open by compiling:\n    if(HAVE_SEM_OPEN_compil)\n      set(HAVE_SEM_OPEN 0)\n      message(STATUS \"Warning: sem_open not compilable\")\n      message(STATUS \"HAVE_SEM_OPEN_comp_output: ${HAVE_SEM_OPEN_comp_output}\")\n    else()\n      set(HAVE_SEM_OPEN 1)\n      message(STATUS \"sem_open is compilable\")\n    endif()\n\n    # If we're not crosscompiling, we check by executing the program:\n    if (HAVE_SEM_OPEN AND NOT CMAKE_CROSSCOMPILING)\n      execute_process(COMMAND ./sem_open\n        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n        RESULT_VARIABLE HAVE_SEM_OPEN_run\n        OUTPUT_VARIABLE var_compil\n      )\n      if (NOT HAVE_SEM_OPEN_run)\n        set(HAVE_SEM_OPEN 1)\n        message(STATUS \"sem_open is executable\")\n      else()\n        set(HAVE_SEM_OPEN 0)\n        if(EXISTS \"${CMAKE_BINARY_DIR}/sem_open\")\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_open exists!\")\n        else()\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_open not exists!\")\n        endif()\n        message(STATUS \"Warning: sem_open not executable\")\n        message(STATUS \"Compilation output: '${var_compil}'\")\n        message(STATUS \"Exit result of sem_open: ${HAVE_SEM_OPEN_run}\")\n      endif()\n    endif()\n    file(REMOVE sem_open)\n  else()\n    set(HAVE_SEM_OPEN 0)\n  endif()\n\n  if(HAVE_SEM_INIT_LIB)\n    execute_process(COMMAND ${CMAKE_C_COMPILER} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_sem_init.c -lpthread -o sem_init\n      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n      RESULT_VARIABLE HAVE_SEM_INIT_run \n      OUTPUT_VARIABLE HAVE_SEM_INIT_compil)\n\n    # Test sem_init by compiling:\n    if(HAVE_SEM_INIT_compil)\n      set(HAVE_SEM_INIT 0)\n      message(STATUS \"Warning: sem_init not compilable\")\n      message(STATUS \"HAVE_SEM_INIT_comp_output: ${HAVE_SEM_OPEN_comp_output}\")\n    else()\n      set(HAVE_SEM_INIT 1)\n      message(STATUS \"sem_init is compilable\")\n    endif()\n\n    # If we're not crosscompiling, we check by executing the program:\n    if (HAVE_SEM_INIT AND NOT CMAKE_CROSSCOMPILING)\n      execute_process(COMMAND ./sem_init\n        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n        RESULT_VARIABLE HAVE_SEM_INIT_run\n        OUTPUT_VARIABLE var_compil\n      )\n      if (NOT HAVE_SEM_INIT_run)\n        set(HAVE_SEM_INIT 1)\n        message(STATUS \"sem_init is executable\")\n      else()\n        set(HAVE_SEM_INIT 0)\n        if(EXISTS \"${CMAKE_BINARY_DIR}/sem_init\")\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_init exists!\")\n        else()\n          message(STATUS \"Bin ${CMAKE_BINARY_DIR}/sem_init not exists!\")\n        endif()\n        message(STATUS \"Warning: sem_init not executable\")\n        message(STATUS \"Compilation output: '${var_compil}'\")\n        message(STATUS \"Exit result of sem_init: ${HAVE_SEM_INIT_run}\")\n      endif()\n    endif()\n    file(REMOVE sem_init)\n  else() \n    set(HAVE_SEM_INIT 0)  \n  endif()\n\n  if(NOT HAVE_SEM_OPEN AND NOT HAVE_SEM_INIT)\n    message(FATAL_ERROR \"Semaphores are not usable (neither sem_open nor sem_init is both compilable and executable), but they are mandatory to threads (you may need to mount /dev).\")\n  endif()\n\n  set(HAVE_THREAD_CONTEXTS 1)\n  message(\"-- Support for thread context factory ok.\")\nendif()\n\nset(HAVE_UCONTEXT_CONTEXTS 0)\nif(NOT HAVE_UCONTEXT_H)\n  message(\"-- No ucontext factory: <ucontext.h> not found.\")\nelseif(APPLE)\n  message(\"-- No ucontext factory: Apple don't want us to use them.\")\n  set(HAVE_UCONTEXT_H 0)\nelse()\n  try_compile(compile_makecontext ${CMAKE_BINARY_DIR} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_makecontext.c\n    OUTPUT_VARIABLE compile_makecontext_output)\n\n  #If can have both context\n  if(compile_makecontext)\n    set(HAVE_UCONTEXT_CONTEXTS 1)\n    message(\"-- Support for ucontext factory ok.\")\n  else()\n    message(\"-- Error: <ucontext.h> exists, but makecontext is not compilable. Compilation output:\\n ${compile_makecontext_output}\")\n    message(\"-- No ucontext factory: makecontext() is not compilable.\")\n  endif()\n\n  # Stack setup (size and address)\n  try_run(RUN_makecontext_VAR COMPILE_makecontext_VAR\n    ${CMAKE_BINARY_DIR} ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_stacksetup.c\n    RUN_OUTPUT_VARIABLE stack_setup)\n\n  LIST(LENGTH stack_setup stack_setup_len)\n  if(\"${stack_setup_len}\" STREQUAL \"2\")\n    LIST(GET stack_setup 0 makecontext_addr)\n    LIST(GET stack_setup 1 makecontext_size)\n    set(sg_makecontext_stack_addr \"#define sg_makecontext_stack_addr(skaddr) (${makecontext_addr})\")\n    set(sg_makecontext_stack_size \"#define sg_makecontext_stack_size(sksize) (${makecontext_size})\")\n  else()\n    message(FATAL_ERROR \"Could not figure out the stack setup. Compil: ${RUN_makecontext_VAR}. Exec: ${COMPILE_makecontext_VAR}. Output: ${stack_setup}\")\n  endif()\nendif()\n\n# Stack growth direction (upward or downward). Used for the following contexts: SysV, raw, Boost\ntry_run(RUN_stackgrowth_VAR COMPILE_stackgrowth_VAR\n  ${CMAKE_BINARY_DIR}\n  ${CMAKE_HOME_DIRECTORY}/tools/cmake/test_prog/prog_stackgrowth.c\n  RUN_OUTPUT_VARIABLE stack\n  COPY_FILE test_stackgrowth)\n\nif(\"${stack}\" STREQUAL \"down\")\n  set(PTH_STACKGROWTH \"-1\")\nelseif(\"${stack}\" STREQUAL \"up\")\n  set(PTH_STACKGROWTH \"1\")\nelse()\n  if(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"x86_64\")\n    set(PTH_STACKGROWTH \"-1\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"i686\")\n    set(PTH_STACKGROWTH \"-1\")\n  else()\n    message(FATAL_ERROR \"Could not figure out the stack direction. Test prog returned: ${stack}; CMAKE_SYSTEM_PROCESSOR: ${CMAKE_SYSTEM_PROCESSOR}.\")\n  endif()\nendif()\n# If the test ran well, remove the test binary\nfile(REMOVE test_stackgrowth)\n#--------------------------------------------------------------------------------------------------\n\n### check for addr2line\nfind_path(ADDR2LINE NAMES addr2line\tPATHS NO_DEFAULT_PATHS)\nif(ADDR2LINE)\n  set(ADDR2LINE \"${ADDR2LINE}/addr2line\")\nendif()\n\n###############\n## GIT version check\n##\nif(EXISTS ${CMAKE_HOME_DIRECTORY}/.git/)\n  execute_process(\n     COMMAND git remote\n     COMMAND head -n 1\n     WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n     OUTPUT_VARIABLE remote\n     OUTPUT_STRIP_TRAILING_WHITESPACE)\n  #message(STATUS \"Git remote: ${remote}\")\n  execute_process(COMMAND git config --get remote.${remote}.url\n     WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n     OUTPUT_VARIABLE url\n     OUTPUT_STRIP_TRAILING_WHITESPACE)\n  #message(STATUS \"Git url: ${url}\")\n  if(url)\n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log --pretty=oneline --abbrev-commit -1\n       WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n       OUTPUT_VARIABLE GIT_VERSION\n       OUTPUT_STRIP_TRAILING_WHITESPACE)\n    message(STATUS \"Git version: ${GIT_VERSION}\")\n\n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log -n 1 --pretty=format:%ai .\n       WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n       OUTPUT_VARIABLE GIT_DATE \n       OUTPUT_STRIP_TRAILING_WHITESPACE)\n    message(STATUS \"Git date: ${GIT_DATE}\")\n    string(REGEX REPLACE \" .*\" \"\" GIT_VERSION \"${GIT_VERSION}\")\n\n    execute_process(COMMAND git --git-dir=${CMAKE_HOME_DIRECTORY}/.git log --pretty=format:%H -1\n       WORKING_DIRECTORY ${CMAKE_HOME_DIRECTORY}/.git/\n       OUTPUT_VARIABLE SIMGRID_GITHASH\n       OUTPUT_STRIP_TRAILING_WHITESPACE)\n  endif()\nelseif(EXISTS ${CMAKE_HOME_DIRECTORY}/.gitversion)\n  FILE(STRINGS ${CMAKE_HOME_DIRECTORY}/.gitversion GIT_VERSION)\nelse()\n  set(GIT_VERSION \"none, release version\")\nendif()\n\n### Generate the required headers and scripts\n#############################################\n\n# Avoid triggering a (full) rebuild by touching the files if they did not really change\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/tools/cmake/src/internal_config.h.in\" \"${CMAKE_BINARY_DIR}/src/internal_config.h.generated\"    @ONLY IMMEDIATE)\nconfigure_file(\"${CMAKE_HOME_DIRECTORY}/include/simgrid_config.h.in\"          \"${CMAKE_BINARY_DIR}/include/simgrid_config.h.generated\" @ONLY IMMEDIATE)\nexecute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_BINARY_DIR}/src/internal_config.h.generated ${CMAKE_BINARY_DIR}/src/internal_config.h)\nexecute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_BINARY_DIR}/include/simgrid_config.h.generated ${CMAKE_BINARY_DIR}/include/simgrid_config.h)\nfile(REMOVE ${CMAKE_BINARY_DIR}/src/internal_config.h.generated)\nfile(REMOVE ${CMAKE_BINARY_DIR}/include/simgrid_config.h.generated)\n\n# We need two versions of the SMPI scripts because they contain the path to the library\n# so, it depends of whether SimGrid is installed, or run from the sources (during the build)\n\nfile(READ ${CMAKE_HOME_DIRECTORY}/src/smpi/smpitools.sh SMPITOOLS_SH) # Definitions shared amongst all SMPI scripts, inlined in each of them\n\n### SMPI script used when simgrid is installed\nset(exec_prefix ${CMAKE_INSTALL_PREFIX})\nset(includeflag \"-I${CMAKE_INSTALL_PREFIX}/include -I${CMAKE_INSTALL_PREFIX}/include/smpi\")\nset(includedir \"${CMAKE_INSTALL_PREFIX}/include\")\nset(libdir ${exec_prefix}/lib)\nset(CMAKE_SMPI_COMMAND \"export LD_LIBRARY_PATH=\\\"${CMAKE_INSTALL_PREFIX}/lib\")\nif(NS3_LIBRARY_PATH)\n  set(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:${NS3_LIBRARY_PATH}\")\nendif()\nset(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:\\${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\\\"\")\nset(SMPIMAIN smpimain)\n\nconfigure_file(${CMAKE_HOME_DIRECTORY}/include/smpi/mpif.h.in ${CMAKE_BINARY_DIR}/include/smpi/mpif.h @ONLY)\nforeach(script cc cxx ff f90 run)\n  configure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpi${script}.in ${CMAKE_BINARY_DIR}/bin/smpi${script} @ONLY)\nendforeach()\n\n### SMPI scripts used when compiling simgrid \nset(exec_prefix \"${CMAKE_BINARY_DIR}/smpi_script/\")\nset(includeflag \"-I${CMAKE_HOME_DIRECTORY}/include -I${CMAKE_HOME_DIRECTORY}/include/smpi\")\nset(includeflag \"${includeflag} -I${CMAKE_BINARY_DIR}/include -I${CMAKE_BINARY_DIR}/include/smpi\")\nset(includedir \"${CMAKE_HOME_DIRECTORY}/include\")\nset(libdir \"${CMAKE_BINARY_DIR}/lib\")\nset(CMAKE_SMPI_COMMAND \"export LD_LIBRARY_PATH=\\\"${CMAKE_BINARY_DIR}/lib\")\nif(NS3_LIBRARY_PATH)\n  set(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:${NS3_LIBRARY_PATH}\")\nendif()\nset(CMAKE_SMPI_COMMAND \"${CMAKE_SMPI_COMMAND}:\\${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\\\"\")\nset(SMPIMAIN ${CMAKE_BINARY_DIR}/bin/smpimain)\n\nforeach(script cc cxx ff f90 run)\n  configure_file(${CMAKE_HOME_DIRECTORY}/src/smpi/smpi${script}.in ${CMAKE_BINARY_DIR}/smpi_script/bin/smpi${script} @ONLY)\nendforeach()\n\nif(NOT WIN32)\n  foreach(script cc cxx ff f90 run)\n    execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/bin/smpi${script})\n    execute_process(COMMAND chmod a=rwx ${CMAKE_BINARY_DIR}/smpi_script/bin/smpi${script})\n  endforeach()\nendif()\n\nset(generated_headers_to_install\n  ${CMAKE_CURRENT_BINARY_DIR}/include/smpi/mpif.h\n  ${CMAKE_CURRENT_BINARY_DIR}/include/simgrid_config.h\n  )\n\nset(generated_headers  ${CMAKE_CURRENT_BINARY_DIR}/src/internal_config.h )\n\nset(generated_files_to_clean\n  ${generated_headers}\n  ${generated_headers_to_install}\n  ${CMAKE_BINARY_DIR}/bin/smpicc\n  ${CMAKE_BINARY_DIR}/bin/smpicxx\n  ${CMAKE_BINARY_DIR}/bin/smpiff\n  ${CMAKE_BINARY_DIR}/bin/smpif90\n  ${CMAKE_BINARY_DIR}/bin/smpirun\n  ${CMAKE_BINARY_DIR}/bin/colorize\n  ${CMAKE_BINARY_DIR}/bin/simgrid_update_xml\n  ${CMAKE_BINARY_DIR}/examples/smpi/tracing/smpi_traced.trace\n  )\n\nif(NOT \"${CMAKE_BINARY_DIR}\" STREQUAL \"${CMAKE_HOME_DIRECTORY}\")\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions0.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions0.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions1.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions1.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_allReduce.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allReduce.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_barrier.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_barrier.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_bcast.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_bcast.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_with_isend.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_with_isend.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_alltoall.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoall.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_alltoallv.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoallv.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_waitall.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_waitall.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_reducescatter.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_reducescatter.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_gather.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_gather.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay/actions_allgatherv.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allgatherv.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/hostfile ${CMAKE_BINARY_DIR}/teshsuite/smpi/hostfile COPYONLY)\n\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/description_file ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/description_file COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/README ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/README COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/smpi_replay.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/smpi_replay.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt COPYONLY)\n  configure_file(${CMAKE_HOME_DIRECTORY}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt COPYONLY)\n\n  set(generated_files_to_clean\n    ${generated_files_to_clean}\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions0.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions1.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allReduce.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_barrier.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_bcast.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_with_isend.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoall.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_alltoallv.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_waitall.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_gather.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_allgatherv.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay/actions_reducescatter.txt\n    ${CMAKE_BINARY_DIR}/teshsuite/smpi/hostfile\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/description_file\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/README\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/smpi_replay.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace0.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace1.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace2.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace3.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace4.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace5.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace6.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace7.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace8.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace9.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace10.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace11.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace12.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace13.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace14.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace15.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace16.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace17.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace18.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace19.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace20.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace21.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace22.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace23.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace24.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace25.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace26.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace27.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace28.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace29.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace30.txt\n    ${CMAKE_BINARY_DIR}/examples/smpi/replay_multiple/ti_traces_32_1/ti_trace31.txt\n    )\nendif()\n\nSET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES\n  \"${generated_files_to_clean}\")\n\n### Define source packages for Libs\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/DefinePackages.cmake)\n\n### Build some Maintainer files\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/MaintainerMode.cmake)\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/UnitTesting.cmake)\n\n### Setup gcc & clang flags\nif (NOT MSVC)\n  include(${CMAKE_HOME_DIRECTORY}/tools/cmake/GCCFlags.cmake)\nendif()\n\n### Make Libs\nif(NOT WIN32)\n  include(${CMAKE_HOME_DIRECTORY}/tools/cmake/MakeLib.cmake)\nelse()\n  include(${CMAKE_HOME_DIRECTORY}/tools/cmake/MakeLibWin.cmake)\nendif()\n\nif(enable_java)\n  include(${CMAKE_HOME_DIRECTORY}/tools/cmake/Java.cmake)\nendif()\n\n### Make tests\nif(enable_memcheck_xml)\n  set(enable_memcheck true)\nendif()\n\nINCLUDE(CTest)\nENABLE_TESTING()\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/Tests.cmake)\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/CTestConfig.cmake)\n\n### Define subdirectories\nforeach(cmakefile ${CMAKEFILES_TXT})\n  string(REPLACE \"/CMakeLists.txt\" \"\" repository ${cmakefile})\n  add_subdirectory(\"${CMAKE_HOME_DIRECTORY}/${repository}\")\nendforeach()\n\n### Setup the distrib\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/Distrib.cmake)\n\n### Build the docs if asked to\ninclude(${CMAKE_HOME_DIRECTORY}/tools/cmake/Documentation.cmake)\n\n### Print the result of configuration\nmessage(\"\")\nmessage(\"##########################################\")\nmessage(\"#### Content of src/internal_config.h ####\")\nmessage(\"##########################################\")\nfile(STRINGS ${CMAKE_CURRENT_BINARY_DIR}/src/internal_config.h config_output)\nLIST(REMOVE_AT config_output 0 1 2 3 4 5 6 7 8 9 10) # Pass the file header\nforeach(line ${config_output})\n  message(\"   ${line}\")\nendforeach()\nmessage(\"##########################################\")\nmessage(\"####   Content of simgrid_config.h    ####\")\nmessage(\"##########################################\")\nfile(STRINGS ${CMAKE_CURRENT_BINARY_DIR}/include/simgrid_config.h config_output)\nLIST(REMOVE_AT config_output 0 1 2 3 4 5 6 7 8 9 -1) # Pass the file header\nforeach(line ${config_output})\n  message(\"   ${line}\")\nendforeach()\nmessage(\"##########################################\")\nmessage(\"####   End of configuration headers   ####\")\nmessage(\"##########################################\")\n\nmessage(\"\\nConfiguration of package `simgrid':\")\nmessage(\"        Home directory ..............: ${CMAKE_HOME_DIRECTORY}\")\nmessage(\"        Build Name ..................: ${BUILDNAME}\")\nmessage(\"        Cmake Generator .............: ${CMAKE_GENERATOR}\")\nmessage(\"        Site ........................: ${SITE}\")\nmessage(\"        Install prefix ..............: ${CMAKE_INSTALL_PREFIX}\")\nif(release)\n  message(\"        Release .....................: simgrid-${release_version}${SIMGRID_VERSION_EXTRA} (release build)\")\nelse()\n  message(\"        Release .....................: simgrid-${release_version}${SIMGRID_VERSION_EXTRA} (development build)\")\nendif()\nmessage(\"\")\nmessage(\"        Compiler: C .................: ${CMAKE_C_COMPILER} (id: ${CMAKE_C_COMPILER_ID})\")\nmessage(\"                version .............: ${CMAKE_C_COMPILER_VERSION}\")\nmessage(\"                is gnu ..............: ${CMAKE_COMPILER_IS_GNUCC}\")\nmessage(\"        Compiler: C++ ...............: ${CMAKE_CXX_COMPILER} (id: ${CMAKE_CXX_COMPILER_ID})\")\nmessage(\"                version .............: ${CMAKE_CXX_COMPILER_VERSION}\")\nif(${Java_FOUND})\n  message(\"        Compiler: Javac .............: ${Java_JAVAC_EXECUTABLE}\")\n  message(\"                version .............: ${Java_VERSION_STRING}\")\nif(${SWIG_FOUND})\n  message(\"                SWIG ................: Version ${SWIG_VERSION} found.\")\nelse()\n  message(\"                SWIG ................: Missing.\")\nendif()\nendif()\nif(CMAKE_Fortran_COMPILER)\n  message(\"        Compiler: Fortran ...........: ${SMPI_Fortran_COMPILER} (id: ${CMAKE_Fortran_COMPILER_ID})\")\n  message(\"                version .............: ${CMAKE_Fortran_COMPILER_VERSION}\")\nendif()\nmessage(\"        Linker: .....................: ${CMAKE_LINKER}\")\nmessage(\"                version .............: ${LINKER_VERSION}\")\nmessage(\"        Make program: ...............: ${CMAKE_MAKE_PROGRAM}\")\nmessage(\"\")\nmessage(\"        CFlags ......................: ${CMAKE_C_FLAGS}\")\nmessage(\"        CXXFlags ....................: ${CMAKE_CXX_FLAGS}\")\nmessage(\"        LDFlags .....................: ${CMAKE_C_LINK_FLAGS}\")\nmessage(\"        with LTO ....................: ${enable_lto}\")\nmessage(\"\")\n\nif (SIMGRID_HAVE_NS3)\n  message(\"        Compile NS-3 ................: yes (path: ${NS3_PATH})\")\nelse()\n  message(\"        Compile NS-3 ................: NO  (hint: ${NS3_HINT})\")\nendif()\n\nif (${Java_FOUND})\n  message(\"        Compile Java ................: yes\")\n  message(\"          Native lib in jar .........: ${enable_lib_in_jar}\")\nelse()\n  message(\"        Compile Java ................: NO\")\nendif()\nmessage(\"        Compile Lua .................: ${SIMGRID_HAVE_LUA}\")\nmessage(\"        Compile Smpi ................: ${HAVE_SMPI}\")\nmessage(\"          Smpi fortran ..............: ${SMPI_FORTRAN}\")\nmessage(\"          MPICH3 testsuite ..........: ${enable_smpi_MPICH3_testsuite}\")\nmessage(\"          Privatization .............: ${HAVE_PRIVATIZATION}\")\nmessage(\"          PAPI support...............: ${HAVE_PAPI}\")\nmessage(\"        Compile Boost.Context support: ${HAVE_BOOST_CONTEXTS}\")\nmessage(\"\")\nmessage(\"        Maintainer mode .............: ${enable_maintainer_mode}\")\nmessage(\"        Documentation................: ${enable_documentation}\")\nmessage(\"        Model checking ..............: ${SIMGRID_HAVE_MC}\")\nmessage(\"        Jedule  mode ................: ${SIMGRID_HAVE_JEDULE}\")\nmessage(\"        Graphviz mode ...............: ${HAVE_GRAPHVIZ}\")\nmessage(\"        Mallocators .................: ${enable_mallocators}\")\nmessage(\"\")\nmessage(\"        Simgrid dependencies ........: ${SIMGRID_DEP}\")\nmessage(\"\")\n\nexecute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${PROJECT_BINARY_DIR}/Testing/Notes/)\nfile(WRITE ${PROJECT_BINARY_DIR}/Testing/Notes/Build  \"GIT version : ${GIT_VERSION}\\n\")\nfile(APPEND ${PROJECT_BINARY_DIR}/Testing/Notes/Build \"Release     : simgrid-${release_version}\\n\")\n\nINCLUDE(Dart)\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/src/simgrid/sg_config.cpp": "/* Copyright (c) 2009-2010, 2012-2015. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n/* sg_config: configuration infrastructure for the simulation world       */\n\n#include \"xbt/misc.h\"\n#include \"xbt/config.h\"\n#include \"xbt/config.hpp\"\n#include \"xbt/log.h\"\n#include \"xbt/mallocator.h\"\n#include \"xbt/str.h\"\n#include \"xbt/sysdep.h\"\n#include \"surf/surf.h\"\n#include \"surf/maxmin.h\"\n#include \"instr/instr_interface.h\"\n#include \"simgrid/simix.h\"\n#include \"simgrid/sg_config.h\"\n#include \"simgrid_config.h\" /* what was compiled in? */\n#include \"mc/mc.h\"\n#include \"simgrid/instr.h\"\n#include \"src/mc/mc_replay.h\"\n#include \"src/surf/surf_interface.hpp\"\n\nXBT_LOG_NEW_DEFAULT_SUBCATEGORY(surf_config, surf, \"About the configuration of SimGrid\");\n\n\n/* 0: beginning of time (config cannot be changed yet);\n * 1: initialized: cfg_set created (config can now be changed);\n * 2: configured: command line parsed and config part of platform file was\n *    integrated also, platform construction ongoing or done.\n *    (Config cannot be changed anymore!)\n */\nint _sg_cfg_init_status = 0;\n\n/* instruct the upper layer (simix or simdag) to exit as soon as possible */\nint _sg_cfg_exit_asap = 0;\n\n#define sg_cfg_exit_early() do { _sg_cfg_exit_asap = 1; return; } while (0)\n\n/* Parse the command line, looking for options */\nstatic void sg_config_cmd_line(int *argc, char **argv)\n{\n  int shall_exit = 0;\n  int i;\n  int j;\n\n  for (j = i = 1; i < *argc; i++) {\n    if (not strncmp(argv[i], \"--cfg=\", strlen(\"--cfg=\"))) {\n      char *opt = strchr(argv[i], '=');\n      opt++;\n\n      xbt_cfg_set_parse(opt);\n      XBT_DEBUG(\"Did apply '%s' as config setting\", opt);\n    } else if (not strcmp(argv[i], \"--version\")) {\n      printf(\"%s\\n\", SIMGRID_VERSION_STRING);\n      shall_exit = 1;\n    } else if (not strcmp(argv[i], \"--cfg-help\") || not strcmp(argv[i], \"--help\")) {\n      printf(\"Description of the configuration accepted by this simulator:\\n\");\n      xbt_cfg_help();\n      printf(\n          \"\\n\"\n          \"Each of these configurations can be used by adding\\n\"\n          \"    --cfg=<option name>:<option value>\\n\"\n          \"to the command line.\\n\"\n          \"\\n\"\n          \"For more information, please refer to:\\n\"\n          \"   --help-aliases for the list of all option aliases.\\n\"\n          \"   --help-logs and --help-log-categories for the details of logging output.\\n\"\n          \"   --help-models for a list of all models known by this simulator.\\n\"\n          \"   --help-tracing for the details of all tracing options known by this simulator.\\n\"\n          \"   --version to get SimGrid version information.\\n\"\n          \"\\n\"\n        );\n      shall_exit = 1;\n    } else if (not strcmp(argv[i], \"--help-aliases\")) {\n      printf(\"Here is a list of all deprecated option names, with their replacement.\\n\");\n      xbt_cfg_aliases();\n      printf(\"Please consider using the recent names\\n\");\n      shall_exit = 1;\n    } else if (not strcmp(argv[i], \"--help-models\")) {\n      model_help(\"host\", surf_host_model_description);\n      printf(\"\\n\");\n      model_help(\"CPU\", surf_cpu_model_description);\n      printf(\"\\n\");\n      model_help(\"network\", surf_network_model_description);\n      printf(\"\\nLong description of all optimization levels accepted by the models of this simulator:\\n\");\n      for (int k = 0; surf_optimization_mode_description[k].name; k++)\n        printf(\"  %s: %s\\n\",\n               surf_optimization_mode_description[k].name,\n               surf_optimization_mode_description[k].description);\n      printf(\"Both network and CPU models have 'Lazy' as default optimization level\\n\\n\");\n      shall_exit = 1;\n    } else if (not strcmp(argv[i], \"--help-tracing\")) {\n      TRACE_help (1);\n      shall_exit = 1;\n    } else {\n      argv[j++] = argv[i];\n    }\n  }\n  if (j < *argc) {\n    argv[j] = nullptr;\n    *argc = j;\n  }\n  if (shall_exit)\n    sg_cfg_exit_early();\n}\n\n/* callback of the plugin variable */\nstatic void _sg_cfg_cb__plugin(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot load a plugin after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (val==nullptr || val[0] == '\\0')\n    return;\n\n  if (not strcmp(val, \"help\")) {\n    model_help(\"plugin\", surf_plugin_description);\n    sg_cfg_exit_early();\n  }\n\n  int plugin_id = find_model_description(surf_plugin_description, val);\n  surf_plugin_description[plugin_id].model_init_preparse();\n}\n\n/* callback of the host/model variable */\nstatic void _sg_cfg_cb__host_model(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot change the model after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (not strcmp(val, \"help\")) {\n    model_help(\"host\", surf_host_model_description);\n    sg_cfg_exit_early();\n  }\n\n  /* Make sure that the model exists */\n  find_model_description(surf_host_model_description, val);\n}\n\n/* callback of the cpu/model variable */\nstatic void _sg_cfg_cb__cpu_model(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot change the model after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (not strcmp(val, \"help\")) {\n    model_help(\"CPU\", surf_cpu_model_description);\n    sg_cfg_exit_early();\n  }\n\n  /* New Module missing */\n  find_model_description(surf_cpu_model_description, val);\n}\n\n/* callback of the cpu/model variable */\nstatic void _sg_cfg_cb__optimization_mode(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot change the model after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (not strcmp(val, \"help\")) {\n    model_help(\"optimization\", surf_optimization_mode_description);\n    sg_cfg_exit_early();\n  }\n\n  /* New Module missing */\n  find_model_description(surf_optimization_mode_description, val);\n}\n\n/* callback of the cpu/model variable */\nstatic void _sg_cfg_cb__storage_mode(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot change the model after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (not strcmp(val, \"help\")) {\n    model_help(\"storage\", surf_storage_model_description);\n    sg_cfg_exit_early();\n  }\n\n  find_model_description(surf_storage_model_description, val);\n}\n\n/* callback of the network_model variable */\nstatic void _sg_cfg_cb__network_model(const char *name)\n{\n  xbt_assert(_sg_cfg_init_status < 2, \"Cannot change the model after the initialization\");\n\n  char *val = xbt_cfg_get_string(name);\n  if (not strcmp(val, \"help\")) {\n    model_help(\"network\", surf_network_model_description);\n    sg_cfg_exit_early();\n  }\n\n  /* New Module missing */\n  find_model_description(surf_network_model_description, val);\n}\n/* callback to decide if we want to use the model-checking */\n#include \"src/xbt_modinter.h\"\n\nstatic void _sg_cfg_cb_model_check_replay(const char *name) {\n  MC_record_path = xbt_cfg_get_string(name);\n  if (MC_record_path[0] == '\\0')\n    MC_record_path = nullptr;\n}\n\n#if SIMGRID_HAVE_MC\nextern int _sg_do_model_check_record;\nstatic void _sg_cfg_cb_model_check_record(const char *name) {\n  _sg_do_model_check_record = xbt_cfg_get_boolean(name);\n}\n#endif\n\nextern int _sg_do_verbose_exit;\nstatic void _sg_cfg_cb_verbose_exit(const char *name)\n{\n  _sg_do_verbose_exit = xbt_cfg_get_boolean(name);\n}\n\nextern int _sg_do_clean_atexit;\nstatic void _sg_cfg_cb_clean_atexit(const char *name)\n{\n  _sg_do_clean_atexit = xbt_cfg_get_boolean(name);\n}\n\nstatic void _sg_cfg_cb_context_stack_size(const char *name)\n{\n  smx_context_stack_size_was_set = 1;\n  smx_context_stack_size = xbt_cfg_get_int(name) * 1024;\n}\n\nstatic void _sg_cfg_cb_context_guard_size(const char *name)\n{\n  smx_context_guard_size_was_set = 1;\n  smx_context_guard_size = xbt_cfg_get_int(name) * xbt_pagesize;\n}\n\nstatic void _sg_cfg_cb_contexts_nthreads(const char *name)\n{\n  SIMIX_context_set_nthreads(xbt_cfg_get_int(name));\n}\n\nstatic void _sg_cfg_cb_contexts_parallel_threshold(const char *name)\n{\n  SIMIX_context_set_parallel_threshold(xbt_cfg_get_int(name));\n}\n\nstatic void _sg_cfg_cb_contexts_parallel_mode(const char *name)\n{\n  const char* mode_name = xbt_cfg_get_string(name);\n  if (not strcmp(mode_name, \"posix\")) {\n    SIMIX_context_set_parallel_mode(XBT_PARMAP_POSIX);\n  } else if (not strcmp(mode_name, \"futex\")) {\n    SIMIX_context_set_parallel_mode(XBT_PARMAP_FUTEX);\n  } else if (not strcmp(mode_name, \"busy_wait\")) {\n    SIMIX_context_set_parallel_mode(XBT_PARMAP_BUSY_WAIT);\n  }\n  else {\n    xbt_die(\"Command line setting of the parallel synchronization mode should \"\n            \"be one of \\\"posix\\\", \\\"futex\\\" or \\\"busy_wait\\\"\");\n  }\n}\n\nstatic void _sg_cfg_cb__surf_network_crosstraffic(const char *name)\n{\n  sg_network_crosstraffic = xbt_cfg_get_boolean(name);\n}\n\n/* build description line with possible values */\nstatic void describe_model(char *result,int resultsize,\n                           const s_surf_model_description_t model_description[],\n                           const char *name,\n                           const char *description)\n{\n  result[0] = '\\0';\n  char *p = result;\n  p += snprintf(result,resultsize-1, \"%s. Possible values: %s\", description,\n            model_description[0].name ? model_description[0].name : \"n/a\");\n  for (int i = 1; model_description[i].name; i++)\n    p += snprintf(p,resultsize-(p-result)-1, \", %s\", model_description[i].name);\n  p += snprintf(p,resultsize-(p-result)-1, \".\\n       (use 'help' as a value to see the long description of each %s)\", name);\n\n  xbt_assert(p<result+resultsize-1,\"Buffer too small to display the model description of %s\",name);\n}\n\n/* create the config set, register what should be and parse the command line*/\nvoid sg_config_init(int *argc, char **argv)\n{\n  const int descsize = 1024;\n  char description[descsize];\n\n  /* Create the configuration support */\n  if (_sg_cfg_init_status != 0) { /* Only create stuff if not already inited */\n    XBT_WARN(\"Call to sg_config_init() after initialization ignored\");\n    return;\n  }\n\n  /* Plugins configuration */\n  describe_model(description, descsize, surf_plugin_description, \"plugin\", \"The plugins\");\n  xbt_cfg_register_string(\"plugin\", nullptr, &_sg_cfg_cb__plugin, description);\n\n  describe_model(description, descsize, surf_cpu_model_description, \"model\", \"The model to use for the CPU\");\n  xbt_cfg_register_string(\"cpu/model\", \"Cas01\", &_sg_cfg_cb__cpu_model, description);\n\n  describe_model(description, descsize, surf_optimization_mode_description, \"optimization mode\",\n                 \"The optimization modes to use for the CPU\");\n  xbt_cfg_register_string(\"cpu/optim\", \"Lazy\", &_sg_cfg_cb__optimization_mode, description);\n\n  describe_model(description, descsize, surf_storage_model_description, \"model\", \"The model to use for the storage\");\n  xbt_cfg_register_string(\"storage/model\", \"default\", &_sg_cfg_cb__storage_mode, description);\n\n  describe_model(description, descsize, surf_network_model_description, \"model\", \"The model to use for the network\");\n  xbt_cfg_register_string(\"network/model\", \"LV08\", &_sg_cfg_cb__network_model, description);\n\n  describe_model(description, descsize, surf_optimization_mode_description, \"optimization mode\",\n                 \"The optimization modes to use for the network\");\n  xbt_cfg_register_string(\"network/optim\", \"Lazy\", &_sg_cfg_cb__optimization_mode, description);\n\n  describe_model(description, descsize, surf_host_model_description, \"model\", \"The model to use for the host\");\n  xbt_cfg_register_string(\"host/model\", \"default\", &_sg_cfg_cb__host_model, description);\n\n  sg_tcp_gamma = 4194304.0;\n  simgrid::config::bindFlag(sg_tcp_gamma, {\"network/TCP-gamma\", \"network/TCP_gamma\"},\n                            \"Size of the biggest TCP window (cat /proc/sys/net/ipv4/tcp_[rw]mem for recv/send window; \"\n                            \"Use the last given value, which is the max window size)\");\n\n  simgrid::config::bindFlag(sg_surf_precision, \"surf/precision\",\n                            \"Numerical precision used when updating simulation times (in seconds)\");\n\n  simgrid::config::bindFlag(sg_maxmin_precision, \"maxmin/precision\",\n                            \"Numerical precision used when computing resource sharing (in flops/sec or bytes/sec)\");\n\n  simgrid::config::bindFlag(sg_concurrency_limit, \"maxmin/concurrency-limit\",\n                            \"Maximum number of concurrent variables in the maxmim system. Also limits the number of \"\n                            \"processes on each host, at higher level. (default: -1 means no such limitation)\");\n  xbt_cfg_register_alias(\"maxmin/concurrency-limit\", \"maxmin/concurrency_limit\");\n\n  /* The parameters of network models */\n\n  // real default for \"network/sender-gap\" is set in network_smpi.cpp:\n  sg_sender_gap = NAN;\n  simgrid::config::bindFlag(sg_sender_gap, {\"network/sender-gap\", \"network/sender_gap\"},\n                            \"Minimum gap between two overlapping sends\");\n\n  sg_latency_factor = 1.0;\n  simgrid::config::bindFlag(sg_latency_factor, {\"network/latency-factor\", \"network/latency_factor\"},\n                            \"Correction factor to apply to the provided latency (default value set by network model)\");\n\n  sg_bandwidth_factor = 1.0;\n  simgrid::config::bindFlag(\n      sg_bandwidth_factor, {\"network/bandwidth-factor\", \"network/bandwidth_factor\"},\n      \"Correction factor to apply to the provided bandwidth (default value set by network model)\");\n\n  // real default for \"network/weight-S\" is set in network_*.cpp:\n  sg_weight_S_parameter = NAN;\n  simgrid::config::bindFlag(\n      sg_weight_S_parameter, {\"network/weight-S\", \"network/weight_S\"},\n      \"Correction factor to apply to the weight of competing streams (default value set by network model)\");\n\n  /* Inclusion path */\n  simgrid::config::declareFlag<std::string>(\"path\", \"Lookup path for inclusions in platform and deployment XML files\",\n                                            \"\", [](std::string const& path) {\n                                              if (path[0] != '\\0') {\n                                                surf_path.push_back(path);\n                                              }\n                                            });\n\n  xbt_cfg_register_boolean(\"cpu/maxmin-selective-update\", \"no\", nullptr, \"Update the constraint set propagating \"\n                                                                         \"recursively to others constraints (off by \"\n                                                                         \"default when optim is set to lazy)\");\n  xbt_cfg_register_alias(\"cpu/maxmin-selective-update\", \"cpu/maxmin_selective_update\");\n  xbt_cfg_register_boolean(\"network/maxmin-selective-update\", \"no\", nullptr, \"Update the constraint set propagating \"\n                                                                             \"recursively to others constraints (off \"\n                                                                             \"by default when optim is set to lazy)\");\n  xbt_cfg_register_alias(\"network/maxmin-selective-update\", \"network/maxmin_selective_update\");\n  /* Replay (this part is enabled even if MC it disabled) */\n  xbt_cfg_register_string(\"model-check/replay\", nullptr, _sg_cfg_cb_model_check_replay,\n                          \"Model-check path to replay (as reported by SimGrid when a violation is reported)\");\n\n#if SIMGRID_HAVE_MC\n    /* do model-checking-record */\n    xbt_cfg_register_boolean(\"model-check/record\", \"no\", _sg_cfg_cb_model_check_record, \"Record the model-checking paths\");\n\n    xbt_cfg_register_int(\"model-check/checkpoint\", 0, _mc_cfg_cb_checkpoint,\n        \"Specify the amount of steps between checkpoints during stateful model-checking (default: 0 => stateless verification). \"\n        \"If value=1, one checkpoint is saved for each step => faster verification, but huge memory consumption; higher values are good compromises between speed and memory consumption.\");\n\n    xbt_cfg_register_boolean(\"model-check/sparse-checkpoint\", \"no\", _mc_cfg_cb_sparse_checkpoint, \"Use sparse per-page snapshots.\");\n    xbt_cfg_register_boolean(\"model-check/ksm\", \"no\", _mc_cfg_cb_ksm, \"Kernel same-page merging\");\n\n    xbt_cfg_register_string(\"model-check/property\",\"\", _mc_cfg_cb_property,\n        \"Name of the file containing the property, as formated by the ltl2ba program.\");\n    xbt_cfg_register_boolean(\"model-check/communications-determinism\", \"no\", _mc_cfg_cb_comms_determinism,\n        \"Whether to enable the detection of communication determinism\");\n    xbt_cfg_register_alias(\"model-check/communications-determinism\",\"model-check/communications_determinism\");\n\n    xbt_cfg_register_boolean(\"model-check/send-determinism\", \"no\", _mc_cfg_cb_send_determinism,\n        \"Enable/disable the detection of send-determinism in the communications schemes\");\n    xbt_cfg_register_alias(\"model-check/send-determinism\",\"model-check/send_determinism\");\n\n    /* Specify the kind of model-checking reduction */\n    xbt_cfg_register_string(\"model-check/reduction\", \"dpor\", _mc_cfg_cb_reduce,\n        \"Specify the kind of exploration reduction (either none or DPOR)\");\n    xbt_cfg_register_boolean(\"model-check/timeout\", \"no\",  _mc_cfg_cb_timeout,\n        \"Whether to enable timeouts for wait requests\");\n\n    xbt_cfg_register_boolean(\"model-check/hash\", \"no\", _mc_cfg_cb_hash, \"Whether to enable state hash for state comparison (experimental)\");\n    xbt_cfg_register_boolean(\"model-check/snapshot-fds\", \"no\",  _mc_cfg_cb_snapshot_fds,\n        \"Whether file descriptors must be snapshoted (currently unusable)\");\n    xbt_cfg_register_alias(\"model-check/snapshot-fds\",\"model-check/snapshot_fds\");\n    xbt_cfg_register_int(\"model-check/max-depth\", 1000, _mc_cfg_cb_max_depth, \"Maximal exploration depth (default: 1000)\");\n    xbt_cfg_register_alias(\"model-check/max-depth\",\"model-check/max_depth\");\n    xbt_cfg_register_int(\"model-check/visited\", 0, _mc_cfg_cb_visited,\n        \"Specify the number of visited state stored for state comparison reduction. If value=5, the last 5 visited states are stored. If value=0 (the default), all states are stored.\");\n\n    xbt_cfg_register_string(\"model-check/dot-output\", \"\", _mc_cfg_cb_dot_output, \"Name of dot output file corresponding to graph state\");\n    xbt_cfg_register_alias(\"model-check/dot-output\",\"model-check/dot_output\");\n    xbt_cfg_register_boolean(\"model-check/termination\", \"no\", _mc_cfg_cb_termination, \"Whether to enable non progressive cycle detection\");\n#endif\n\n    xbt_cfg_register_boolean(\"verbose-exit\", \"yes\", _sg_cfg_cb_verbose_exit, \"Activate the \\\"do nothing\\\" mode in Ctrl-C\");\n\n    xbt_cfg_register_int(\"contexts/stack-size\", 8*1024, _sg_cfg_cb_context_stack_size, \"Stack size of contexts in KiB\");\n    /* (FIXME: this is unpleasant) Reset this static variable that was altered when setting the default value. */\n    smx_context_stack_size_was_set = 0;\n    xbt_cfg_register_alias(\"contexts/stack-size\",\"contexts/stack_size\");\n\n    /* guard size for contexts stacks in memory pages */\n    xbt_cfg_register_int(\"contexts/guard-size\",\n#if defined(_WIN32) || (PTH_STACKGROWTH != -1)\n        0,\n#else\n        1,\n#endif\n    _sg_cfg_cb_context_guard_size, \"Guard size for contexts stacks in memory pages\");\n    /* No, it was not set yet (the above setdefault() changed this to 1). */\n    smx_context_guard_size_was_set = 0;\n    xbt_cfg_register_alias(\"contexts/guard-size\",\"contexts/guard_size\");\n    xbt_cfg_register_int(\"contexts/nthreads\", 1, _sg_cfg_cb_contexts_nthreads, \"Number of parallel threads used to execute user contexts\");\n\n    xbt_cfg_register_int(\"contexts/parallel-threshold\", 2, _sg_cfg_cb_contexts_parallel_threshold,\n        \"Minimal number of user contexts to be run in parallel (raw contexts only)\");\n    xbt_cfg_register_alias(\"contexts/parallel-threshold\",\"contexts/parallel_threshold\");\n\n    /* synchronization mode for parallel user contexts */\n#if HAVE_FUTEX_H\n    xbt_cfg_register_string(\"contexts/synchro\", \"futex\",     _sg_cfg_cb_contexts_parallel_mode,\n        \"Synchronization mode to use when running contexts in parallel (either futex, posix or busy_wait)\");\n#else //No futex on mac and posix is unimplememted yet\n    xbt_cfg_register_string(\"contexts/synchro\", \"busy_wait\", _sg_cfg_cb_contexts_parallel_mode,\n        \"Synchronization mode to use when running contexts in parallel (either futex, posix or busy_wait)\");\n#endif\n\n    xbt_cfg_register_boolean(\"network/crosstraffic\", \"yes\", _sg_cfg_cb__surf_network_crosstraffic,\n        \"Activate the interferences between uploads and downloads for fluid max-min models (LV08, CM02)\");\n\n    //For smpi/bw_factor and smpi/lat_factor\n    // SMPI model can be used without enable_smpi, so keep this out of the ifdef.\n    xbt_cfg_register_string(\"smpi/bw-factor\",\n        \"65472:0.940694;15424:0.697866;9376:0.58729;5776:1.08739;3484:0.77493;1426:0.608902;732:0.341987;257:0.338112;0:0.812084\", nullptr,\n        \"Bandwidth factors for smpi. Format: 'threshold0:value0;threshold1:value1;...;thresholdN:valueN', meaning if(size >=thresholdN ) return valueN.\");\n    xbt_cfg_register_alias(\"smpi/bw-factor\",\"smpi/bw_factor\");\n\n    xbt_cfg_register_string(\"smpi/lat-factor\",\n        \"65472:11.6436;15424:3.48845;9376:2.59299;5776:2.18796;3484:1.88101;1426:1.61075;732:1.9503;257:1.95341;0:2.01467\", nullptr, \"Latency factors for smpi.\");\n    xbt_cfg_register_alias(\"smpi/lat-factor\",\"smpi/lat_factor\");\n\n    xbt_cfg_register_string(\"smpi/IB-penalty-factors\", \"0.965;0.925;1.35\", nullptr,\n        \"Correction factor to communications using Infiniband model with contention (default value based on Stampede cluster profiling)\");\n    xbt_cfg_register_alias(\"smpi/IB-penalty-factors\",\"smpi/IB_penalty_factors\");\n\n#if HAVE_SMPI\n    xbt_cfg_register_double(\"smpi/host-speed\", 20000.0, nullptr, \"Speed of the host running the simulation (in flop/s). Used to bench the operations.\");\n    xbt_cfg_register_alias(\"smpi/host-speed\",\"smpi/running_power\");\n    xbt_cfg_register_alias(\"smpi/host-speed\",\"smpi/running-power\");\n\n    xbt_cfg_register_boolean(\"smpi/keep-temps\", \"no\", nullptr, \"Whether we should keep the generated temporary files.\");\n\n    xbt_cfg_register_boolean(\"smpi/display-timing\", \"no\", nullptr, \"Whether we should display the timing after simulation.\");\n    xbt_cfg_register_alias(\"smpi/display-timing\", \"smpi/display_timing\");\n\n    xbt_cfg_register_boolean(\"smpi/simulate-computation\", \"yes\", nullptr, \"Whether the computational part of the simulated application should be simulated.\");\n    xbt_cfg_register_alias(\"smpi/simulate-computation\",\"smpi/simulate_computation\");\n\n    xbt_cfg_register_string(\"smpi/shared-malloc\", \"global\", nullptr,\n                            \"Whether SMPI_SHARED_MALLOC is enabled. Disable it for debugging purposes.\");\n    xbt_cfg_register_alias(\"smpi/shared-malloc\", \"smpi/use-shared-malloc\");\n    xbt_cfg_register_alias(\"smpi/shared-malloc\", \"smpi/use_shared_malloc\");\n    xbt_cfg_register_double(\"smpi/shared-malloc-blocksize\", 1UL << 20, nullptr, \"Size of the bogus file which will be created for global shared allocations\");\n    xbt_cfg_register_string(\"smpi/shared-malloc-hugepage\", \"\", nullptr,\n                            \"Path to a mounted hugetlbfs, to use huge pages with shared malloc.\");\n\n    xbt_cfg_register_double(\"smpi/cpu-threshold\", 1e-6, nullptr, \"Minimal computation time (in seconds) not discarded, or -1 for infinity.\");\n    xbt_cfg_register_alias(\"smpi/cpu-threshold\", \"smpi/cpu_threshold\");\n\n    xbt_cfg_register_int(\"smpi/async-small-thresh\", 0, nullptr,\n        \"Maximal size of messages that are to be sent asynchronously, without waiting for the receiver\");\n    xbt_cfg_register_alias(\"smpi/async-small-thresh\",\"smpi/async_small_thresh\");\n    xbt_cfg_register_alias(\"smpi/async-small-thresh\",\"smpi/async_small_thres\");\n\n    xbt_cfg_register_boolean(\"smpi/trace-call-location\", \"no\", nullptr, \"Should filename and linenumber of MPI calls be traced?\");\n\n    xbt_cfg_register_int(\"smpi/send-is-detached-thresh\", 65536, nullptr,\n        \"Threshold of message size where MPI_Send stops behaving like MPI_Isend and becomes MPI_Ssend\");\n    xbt_cfg_register_alias(\"smpi/send-is-detached-thresh\",\"smpi/send_is_detached_thresh\");\n    xbt_cfg_register_alias(\"smpi/send-is-detached-thresh\",\"smpi/send_is_detached_thres\");\n\n    const char* default_privatization = std::getenv(\"SMPI_PRIVATIZATION\");\n    if (default_privatization == nullptr)\n      default_privatization = \"no\";\n\n    xbt_cfg_register_string(\"smpi/privatization\", default_privatization, nullptr,\n                            \"How we should privatize global variable at runtime (no, yes, mmap, dlopen).\");\n\n    xbt_cfg_register_alias(\"smpi/privatization\", \"smpi/privatize-global-variables\");\n    xbt_cfg_register_alias(\"smpi/privatization\", \"smpi/privatize_global_variables\");\n\n    xbt_cfg_register_boolean(\"smpi/grow-injected-times\", \"yes\", nullptr, \"Whether we want to make the injected time in MPI_Iprobe and MPI_Test grow, to allow faster simulation. This can make simulation less precise, though.\");\n\n#if HAVE_PAPI\n    xbt_cfg_register_string(\"smpi/papi-events\", nullptr, nullptr, \"This switch enables tracking the specified counters with PAPI\");\n#endif\n    xbt_cfg_register_string(\"smpi/comp-adjustment-file\", nullptr, nullptr, \"A file containing speedups or slowdowns for some parts of the code.\");\n    xbt_cfg_register_string(\"smpi/os\", \"0:0:0:0:0\", nullptr,  \"Small messages timings (MPI_Send minimum time for small messages)\");\n    xbt_cfg_register_string(\"smpi/ois\", \"0:0:0:0:0\", nullptr, \"Small messages timings (MPI_Isend minimum time for small messages)\");\n    xbt_cfg_register_string(\"smpi/or\", \"0:0:0:0:0\", nullptr,  \"Small messages timings (MPI_Recv minimum time for small messages)\");\n\n    xbt_cfg_register_double(\"smpi/iprobe-cpu-usage\", 1, nullptr, \"Maximum usage of CPUs by MPI_Iprobe() calls. We've observed that MPI_Iprobes consume significantly less power than the maximum of a specific application. This value is then (Iprobe_Usage/Max_Application_Usage).\");\n\n    xbt_cfg_register_string(\"smpi/coll-selector\", \"default\", nullptr, \"Which collective selector to use\");\n    xbt_cfg_register_alias(\"smpi/coll-selector\",\"smpi/coll_selector\");\n    xbt_cfg_register_string(\"smpi/gather\",        nullptr, nullptr, \"Which collective to use for gather\");\n    xbt_cfg_register_string(\"smpi/allgather\",     nullptr, nullptr, \"Which collective to use for allgather\");\n    xbt_cfg_register_string(\"smpi/barrier\",       nullptr, nullptr, \"Which collective to use for barrier\");\n    xbt_cfg_register_string(\"smpi/reduce_scatter\",nullptr, nullptr, \"Which collective to use for reduce_scatter\");\n    xbt_cfg_register_alias(\"smpi/reduce_scatter\",\"smpi/reduce-scatter\");\n    xbt_cfg_register_string(\"smpi/scatter\",       nullptr, nullptr, \"Which collective to use for scatter\");\n    xbt_cfg_register_string(\"smpi/allgatherv\",    nullptr, nullptr, \"Which collective to use for allgatherv\");\n    xbt_cfg_register_string(\"smpi/allreduce\",     nullptr, nullptr, \"Which collective to use for allreduce\");\n    xbt_cfg_register_string(\"smpi/alltoall\",      nullptr, nullptr, \"Which collective to use for alltoall\");\n    xbt_cfg_register_string(\"smpi/alltoallv\",     nullptr, nullptr,\"Which collective to use for alltoallv\");\n    xbt_cfg_register_string(\"smpi/bcast\",         nullptr, nullptr, \"Which collective to use for bcast\");\n    xbt_cfg_register_string(\"smpi/reduce\",        nullptr, nullptr, \"Which collective to use for reduce\");\n#endif // HAVE_SMPI\n\n    /* Storage */\n\n    sg_storage_max_file_descriptors = 1024;\n    simgrid::config::bindFlag(sg_storage_max_file_descriptors, \"storage/max_file_descriptors\",\n      \"Maximum number of concurrently opened files per host. Default is 1024\");\n\n    /* Others */\n\n    xbt_cfg_register_boolean(\"exception/cutpath\", \"no\", nullptr,\n        \"Whether to cut all path information from call traces, used e.g. in exceptions.\");\n\n    xbt_cfg_register_boolean(\"clean-atexit\", \"yes\", _sg_cfg_cb_clean_atexit,\n        \"Whether to cleanup SimGrid at exit. Disable it if your code segfaults after its end.\");\n    xbt_cfg_register_alias(\"clean-atexit\",\"clean_atexit\");\n\n    if (surf_path.empty()) {\n      /* retrieves the current directory of the current process */\n      const char *initial_path = __surf_get_initial_path();\n      xbt_assert((initial_path), \"__surf_get_initial_path() failed! Can't resolve current Windows directory\");\n\n      xbt_cfg_setdefault_string(\"path\", initial_path);\n    }\n\n    _sg_cfg_init_status = 1;\n\n    sg_config_cmd_line(argc, argv);\n\n    xbt_mallocator_initialization_is_done(SIMIX_context_is_parallel());\n}\n\nvoid sg_config_finalize()\n{\n  if (not _sg_cfg_init_status)\n    return;                     /* Not initialized yet. Nothing to do */\n\n  xbt_cfg_free(&simgrid_config);\n  _sg_cfg_init_status = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/src/smpi/smpi_global.cpp": "/* Copyright (c) 2007-2017. The SimGrid Team. All rights reserved.          */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#include \"mc/mc.h\"\n#include \"simgrid/s4u/Mailbox.hpp\"\n#include \"simgrid/s4u/Host.hpp\"\n#include \"src/msg/msg_private.h\"\n#include \"src/simix/smx_private.h\"\n#include \"src/surf/surf_interface.hpp\"\n#include \"src/smpi/SmpiHost.hpp\"\n#include \"xbt/config.hpp\"\n#include \"src/smpi/private.h\"\n#include \"src/smpi/smpi_coll.hpp\"\n#include \"src/smpi/smpi_comm.hpp\"\n#include \"src/smpi/smpi_group.hpp\"\n#include \"src/smpi/smpi_info.hpp\"\n#include \"src/smpi/smpi_process.hpp\"\n\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <float.h> /* DBL_MAX */\n#include <fstream>\n\n#if HAVE_SENDFILE\n#include <sys/sendfile.h>\n#endif\n\nXBT_LOG_NEW_DEFAULT_SUBCATEGORY(smpi_kernel, smpi, \"Logging specific to SMPI (kernel)\");\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string.hpp> /* trim_right / trim_left */\n\n#ifndef RTLD_DEEPBIND\n/* RTLD_DEEPBIND is a bad idea of GNU ld that obviously does not exist on other platforms\n * See https://www.akkadia.org/drepper/dsohowto.pdf\n * and https://lists.freebsd.org/pipermail/freebsd-current/2016-March/060284.html\n*/\n#define RTLD_DEEPBIND 0\n#endif\n\n#if HAVE_PAPI\n#include \"papi.h\"\nconst char* papi_default_config_name = \"default\";\n\nstruct papi_process_data {\n  papi_counter_t counter_data;\n  int event_set;\n};\n\n#endif\nstd::unordered_map<std::string, double> location2speedup;\n\nsimgrid::smpi::Process **process_data = nullptr;\nint process_count = 0;\nint smpi_universe_size = 0;\nint* index_to_process_data = nullptr;\nextern double smpi_total_benched_time;\nxbt_os_timer_t global_timer;\nMPI_Comm MPI_COMM_WORLD = MPI_COMM_UNINITIALIZED;\nMPI_Errhandler *MPI_ERRORS_RETURN = nullptr;\nMPI_Errhandler *MPI_ERRORS_ARE_FATAL = nullptr;\nMPI_Errhandler *MPI_ERRHANDLER_NULL = nullptr;\nstatic simgrid::config::Flag<double> smpi_wtime_sleep(\n  \"smpi/wtime\", \"Minimum time to inject inside a call to MPI_Wtime\", 0.0);\nstatic simgrid::config::Flag<double> smpi_init_sleep(\n  \"smpi/init\", \"Time to inject inside a call to MPI_Init\", 0.0);\n\nvoid (*smpi_comm_copy_data_callback) (smx_activity_t, void*, size_t) = &smpi_comm_copy_buffer_callback;\n\nint smpi_process_count()\n{\n  return process_count;\n}\n\nsimgrid::smpi::Process* smpi_process()\n{\n  smx_actor_t me = SIMIX_process_self();\n  if (me == nullptr) // This happens sometimes (eg, when linking against NS3 because it pulls openMPI...)\n    return nullptr;\n  simgrid::msg::ActorExt* msgExt = static_cast<simgrid::msg::ActorExt*>(me->data);\n  return static_cast<simgrid::smpi::Process*>(msgExt->data);\n}\n\nsimgrid::smpi::Process* smpi_process_remote(int index)\n{\n  return process_data[index_to_process_data[index]];\n}\n\nMPI_Comm smpi_process_comm_self(){\n  return smpi_process()->comm_self();\n}\n\nvoid smpi_process_init(int *argc, char ***argv){\n  simgrid::smpi::Process::init(argc, argv);\n}\n\nint smpi_process_index(){\n  return smpi_process()->index();\n}\n\nvoid * smpi_process_get_user_data(){\n  return smpi_process()->get_user_data();\n}\n\nvoid smpi_process_set_user_data(void *data){\n  return smpi_process()->set_user_data(data);\n}\n\n\nint smpi_global_size()\n{\n  char *value = getenv(\"SMPI_GLOBAL_SIZE\");\n  xbt_assert(value,\"Please set env var SMPI_GLOBAL_SIZE to the expected number of processes.\");\n\n  return xbt_str_parse_int(value, \"SMPI_GLOBAL_SIZE contains a non-numerical value: %s\");\n}\n\nvoid smpi_comm_set_copy_data_callback(void (*callback) (smx_activity_t, void*, size_t))\n{\n  smpi_comm_copy_data_callback = callback;\n}\n\nstatic void print(std::vector<std::pair<size_t, size_t>> vec) {\n  std::fprintf(stderr, \"{\");\n  for (auto elt : vec) {\n    std::fprintf(stderr, \"(0x%zx, 0x%zx),\", elt.first, elt.second);\n    }\n    std::fprintf(stderr, \"}\\n\");\n}\nstatic void memcpy_private(void* dest, const void* src, std::vector<std::pair<size_t, size_t>>& private_blocks)\n{\n  for(auto block : private_blocks) {\n    memcpy((uint8_t*)dest+block.first, (uint8_t*)src+block.first, block.second-block.first);\n  }\n}\n\nstatic void check_blocks(std::vector<std::pair<size_t, size_t>> &private_blocks, size_t buff_size) {\n  for(auto block : private_blocks) {\n    xbt_assert(block.first <= block.second && block.second <= buff_size, \"Oops, bug in shared malloc.\");\n  }\n}\n\nvoid smpi_comm_copy_buffer_callback(smx_activity_t synchro, void *buff, size_t buff_size)\n{\n  simgrid::kernel::activity::CommImplPtr comm =\n      boost::dynamic_pointer_cast<simgrid::kernel::activity::CommImpl>(synchro);\n  int src_shared                        = 0;\n  int dst_shared                        = 0;\n  size_t src_offset                     = 0;\n  size_t dst_offset                     = 0;\n  std::vector<std::pair<size_t, size_t>> src_private_blocks;\n  std::vector<std::pair<size_t, size_t>> dst_private_blocks;\n  XBT_DEBUG(\"Copy the data over\");\n  if((src_shared=smpi_is_shared(buff, src_private_blocks, &src_offset))) {\n    XBT_DEBUG(\"Sender %p is shared. Let's ignore it.\", buff);\n    src_private_blocks = shift_and_frame_private_blocks(src_private_blocks, src_offset, buff_size);\n  }\n  else {\n    src_private_blocks.clear();\n    src_private_blocks.push_back(std::make_pair(0, buff_size));\n  }\n  if((dst_shared=smpi_is_shared((char*)comm->dst_buff, dst_private_blocks, &dst_offset))) {\n    XBT_DEBUG(\"Receiver %p is shared. Let's ignore it.\", (char*)comm->dst_buff);\n    dst_private_blocks = shift_and_frame_private_blocks(dst_private_blocks, dst_offset, buff_size);\n  }\n  else {\n    dst_private_blocks.clear();\n    dst_private_blocks.push_back(std::make_pair(0, buff_size));\n  }\n  check_blocks(src_private_blocks, buff_size);\n  check_blocks(dst_private_blocks, buff_size);\n  auto private_blocks = merge_private_blocks(src_private_blocks, dst_private_blocks);\n  check_blocks(private_blocks, buff_size);\n  void* tmpbuff=buff;\n  if((smpi_privatize_global_variables == SMPI_PRIVATIZE_MMAP) && (static_cast<char*>(buff) >= smpi_start_data_exe)\n      && (static_cast<char*>(buff) < smpi_start_data_exe + smpi_size_data_exe )\n    ){\n       XBT_DEBUG(\"Privatization : We are copying from a zone inside global memory... Saving data to temp buffer !\");\n\n       smpi_switch_data_segment(\n           static_cast<simgrid::smpi::Process*>((static_cast<simgrid::msg::ActorExt*>(comm->src_proc->data)->data))\n               ->index());\n       tmpbuff = static_cast<void*>(xbt_malloc(buff_size));\n       memcpy_private(tmpbuff, buff, private_blocks);\n  }\n\n  if((smpi_privatize_global_variables == SMPI_PRIVATIZE_MMAP) && ((char*)comm->dst_buff >= smpi_start_data_exe)\n      && ((char*)comm->dst_buff < smpi_start_data_exe + smpi_size_data_exe )){\n       XBT_DEBUG(\"Privatization : We are copying to a zone inside global memory - Switch data segment\");\n       smpi_switch_data_segment(\n           static_cast<simgrid::smpi::Process*>((static_cast<simgrid::msg::ActorExt*>(comm->dst_proc->data)->data))\n               ->index());\n  }\n  XBT_DEBUG(\"Copying %zu bytes from %p to %p\", buff_size, tmpbuff,comm->dst_buff);\n  memcpy_private(comm->dst_buff, tmpbuff, private_blocks);\n\n  if (comm->detached) {\n    // if this is a detached send, the source buffer was duplicated by SMPI\n    // sender to make the original buffer available to the application ASAP\n    xbt_free(buff);\n    //It seems that the request is used after the call there this should be free somewhere else but where???\n    //xbt_free(comm->comm.src_data);// inside SMPI the request is kept inside the user data and should be free\n    comm->src_buff = nullptr;\n  }\n  if(tmpbuff!=buff)xbt_free(tmpbuff);\n\n}\n\nvoid smpi_comm_null_copy_buffer_callback(smx_activity_t comm, void *buff, size_t buff_size)\n{\n  /* nothing done in this version */\n}\n\nstatic void smpi_check_options(){\n  //check correctness of MPI parameters\n\n   xbt_assert(xbt_cfg_get_int(\"smpi/async-small-thresh\") <= xbt_cfg_get_int(\"smpi/send-is-detached-thresh\"));\n\n   if (xbt_cfg_is_default_value(\"smpi/host-speed\")) {\n     XBT_INFO(\"You did not set the power of the host running the simulation.  \"\n              \"The timings will certainly not be accurate.  \"\n              \"Use the option \\\"--cfg=smpi/host-speed:<flops>\\\" to set its value.\"\n              \"Check http://simgrid.org/simgrid/latest/doc/options.html#options_smpi_bench for more information.\");\n   }\n\n   xbt_assert(xbt_cfg_get_double(\"smpi/cpu-threshold\") >=0,\n       \"The 'smpi/cpu-threshold' option cannot have negative values [anymore]. If you want to discard \"\n       \"the simulation of any computation, please use 'smpi/simulate-computation:no' instead.\");\n}\n\nint smpi_enabled() {\n  return process_data != nullptr;\n}\n\nvoid smpi_global_init()\n{\n  MPI_Group group;\n\n  if (not MC_is_active()) {\n    global_timer = xbt_os_timer_new();\n    xbt_os_walltimer_start(global_timer);\n  }\n\n  if (xbt_cfg_get_string(\"smpi/comp-adjustment-file\")[0] != '\\0') {\n    std::string filename {xbt_cfg_get_string(\"smpi/comp-adjustment-file\")};\n    std::ifstream fstream(filename);\n    if (not fstream.is_open()) {\n      xbt_die(\"Could not open file %s. Does it exist?\", filename.c_str());\n    }\n\n    std::string line;\n    typedef boost::tokenizer< boost::escaped_list_separator<char>> Tokenizer;\n    std::getline(fstream, line); // Skip the header line\n    while (std::getline(fstream, line)) {\n      Tokenizer tok(line);\n      Tokenizer::iterator it  = tok.begin();\n      Tokenizer::iterator end = std::next(tok.begin());\n\n      std::string location = *it;\n      boost::trim(location);\n      location2speedup.insert(std::pair<std::string, double>(location, std::stod(*end)));\n    }\n  }\n\n#if HAVE_PAPI\n  // This map holds for each computation unit (such as \"default\" or \"process1\" etc.)\n  // the configuration as given by the user (counter data as a pair of (counter_name, counter_counter))\n  // and the (computed) event_set.\n  std::map</* computation unit name */ std::string, papi_process_data> units2papi_setup;\n\n  if (xbt_cfg_get_string(\"smpi/papi-events\")[0] != '\\0') {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT)\n      XBT_ERROR(\"Could not initialize PAPI library; is it correctly installed and linked?\"\n                \" Expected version is %i\",\n                PAPI_VER_CURRENT);\n\n    typedef boost::tokenizer<boost::char_separator<char>> Tokenizer;\n    boost::char_separator<char> separator_units(\";\");\n    std::string str = std::string(xbt_cfg_get_string(\"smpi/papi-events\"));\n    Tokenizer tokens(str, separator_units);\n\n    // Iterate over all the computational units. This could be\n    // processes, hosts, threads, ranks... You name it. I'm not exactly\n    // sure what we will support eventually, so I'll leave it at the\n    // general term \"units\".\n    for (auto& unit_it : tokens) {\n      boost::char_separator<char> separator_events(\":\");\n      Tokenizer event_tokens(unit_it, separator_events);\n\n      int event_set = PAPI_NULL;\n      if (PAPI_create_eventset(&event_set) != PAPI_OK) {\n        // TODO: Should this let the whole simulation die?\n        XBT_CRITICAL(\"Could not create PAPI event set during init.\");\n      }\n\n      // NOTE: We cannot use a map here, as we must obey the order of the counters\n      // This is important for PAPI: We need to map the values of counters back\n      // to the event_names (so, when PAPI_read() has finished)!\n      papi_counter_t counters2values;\n\n      // Iterate over all counters that were specified for this specific\n      // unit.\n      // Note that we need to remove the name of the unit\n      // (that could also be the \"default\" value), which always comes first.\n      // Hence, we start at ++(events.begin())!\n      for (Tokenizer::iterator events_it = ++(event_tokens.begin()); events_it != event_tokens.end(); events_it++) {\n\n        int event_code   = PAPI_NULL;\n        char* event_name = const_cast<char*>((*events_it).c_str());\n        if (PAPI_event_name_to_code(event_name, &event_code) == PAPI_OK) {\n          if (PAPI_add_event(event_set, event_code) != PAPI_OK) {\n            XBT_ERROR(\"Could not add PAPI event '%s'. Skipping.\", event_name);\n            continue;\n          } else {\n            XBT_DEBUG(\"Successfully added PAPI event '%s' to the event set.\", event_name);\n          }\n        } else {\n          XBT_CRITICAL(\"Could not find PAPI event '%s'. Skipping.\", event_name);\n          continue;\n        }\n\n        counters2values.push_back(\n            // We cannot just pass *events_it, as this is of type const basic_string\n            std::make_pair<std::string, long long>(std::string(*events_it), 0));\n      }\n\n      std::string unit_name    = *(event_tokens.begin());\n      papi_process_data config = {.counter_data = std::move(counters2values), .event_set = event_set};\n\n      units2papi_setup.insert(std::make_pair(unit_name, std::move(config)));\n    }\n  }\n#endif\n\n  int smpirun = 0;\n  msg_bar_t finalization_barrier = nullptr;\n  if (process_count == 0){\n    process_count = SIMIX_process_count();\n    smpirun=1;\n    finalization_barrier = MSG_barrier_init(process_count);\n  }\n  smpi_universe_size = process_count;\n  process_data       = new simgrid::smpi::Process*[process_count];\n  for (int i = 0; i < process_count; i++) {\n    process_data[i] = new simgrid::smpi::Process(i, finalization_barrier);\n  }\n  //if the process was launched through smpirun script we generate a global mpi_comm_world\n  //if not, we let MPI_COMM_NULL, and the comm world will be private to each mpi instance\n  if (smpirun) {\n    group = new  simgrid::smpi::Group(process_count);\n    MPI_COMM_WORLD = new  simgrid::smpi::Comm(group, nullptr);\n    MPI_Attr_put(MPI_COMM_WORLD, MPI_UNIVERSE_SIZE, reinterpret_cast<void *>(process_count));\n\n    for (int i = 0; i < process_count; i++)\n      group->set_mapping(i, i);\n  }\n}\n\nvoid smpi_global_destroy()\n{\n  int count = smpi_process_count();\n\n  smpi_bench_destroy();\n  smpi_shared_destroy();\n  if (MPI_COMM_WORLD != MPI_COMM_UNINITIALIZED){\n      delete MPI_COMM_WORLD->group();\n      MSG_barrier_destroy(process_data[0]->finalization_barrier());\n  }else{\n      smpi_deployment_cleanup_instances();\n  }\n  for (int i = 0; i < count; i++) {\n    if(process_data[i]->comm_self()!=MPI_COMM_NULL){\n      simgrid::smpi::Comm::destroy(process_data[i]->comm_self());\n    }\n    if(process_data[i]->comm_intra()!=MPI_COMM_NULL){\n      simgrid::smpi::Comm::destroy(process_data[i]->comm_intra());\n    }\n    xbt_os_timer_free(process_data[i]->timer());\n    xbt_mutex_destroy(process_data[i]->mailboxes_mutex());\n    delete process_data[i];\n  }\n  delete[] process_data;\n  process_data = nullptr;\n\n  if (MPI_COMM_WORLD != MPI_COMM_UNINITIALIZED){\n    MPI_COMM_WORLD->cleanup_smp();\n    MPI_COMM_WORLD->cleanup_attr<simgrid::smpi::Comm>();\n    if(simgrid::smpi::Colls::smpi_coll_cleanup_callback!=nullptr)\n      simgrid::smpi::Colls::smpi_coll_cleanup_callback();\n    delete MPI_COMM_WORLD;\n  }\n\n  MPI_COMM_WORLD = MPI_COMM_NULL;\n\n  if (not MC_is_active()) {\n    xbt_os_timer_free(global_timer);\n  }\n\n  xbt_free(index_to_process_data);\n  if(smpi_privatize_global_variables == SMPI_PRIVATIZE_MMAP)\n    smpi_destroy_global_memory_segments();\n  smpi_free_static();\n}\n\nextern \"C\" {\n\nstatic void smpi_init_logs(){\n\n  /* Connect log categories.  See xbt/log.c */\n\n  XBT_LOG_CONNECT(smpi);  /* Keep this line as soon as possible in this function: xbt_log_appender_file.c depends on it\n                             DO NOT connect this in XBT or so, or it will be useless to xbt_log_appender_file.c */\n  XBT_LOG_CONNECT(instr_smpi);\n  XBT_LOG_CONNECT(smpi_bench);\n  XBT_LOG_CONNECT(smpi_coll);\n  XBT_LOG_CONNECT(smpi_colls);\n  XBT_LOG_CONNECT(smpi_comm);\n  XBT_LOG_CONNECT(smpi_datatype);\n  XBT_LOG_CONNECT(smpi_dvfs);\n  XBT_LOG_CONNECT(smpi_group);\n  XBT_LOG_CONNECT(smpi_kernel);\n  XBT_LOG_CONNECT(smpi_mpi);\n  XBT_LOG_CONNECT(smpi_memory);\n  XBT_LOG_CONNECT(smpi_op);\n  XBT_LOG_CONNECT(smpi_pmpi);\n  XBT_LOG_CONNECT(smpi_request);\n  XBT_LOG_CONNECT(smpi_replay);\n  XBT_LOG_CONNECT(smpi_rma);\n  XBT_LOG_CONNECT(smpi_shared);\n  XBT_LOG_CONNECT(smpi_utils);\n}\n}\n\nstatic void smpi_init_options(){\n    //return if already called\n    if (smpi_cpu_threshold > -1)\n      return;\n    simgrid::smpi::Colls::set_collectives();\n    simgrid::smpi::Colls::smpi_coll_cleanup_callback=nullptr;\n    smpi_cpu_threshold = xbt_cfg_get_double(\"smpi/cpu-threshold\");\n    smpi_host_speed = xbt_cfg_get_double(\"smpi/host-speed\");\n    const char* smpi_privatize_option               = xbt_cfg_get_string(\"smpi/privatization\");\n    if (std::strcmp(smpi_privatize_option, \"no\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_NONE;\n    else if (std::strcmp(smpi_privatize_option, \"yes\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_DEFAULT;\n    else if (std::strcmp(smpi_privatize_option, \"mmap\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_MMAP;\n    else if (std::strcmp(smpi_privatize_option, \"dlopen\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_DLOPEN;\n\n    // Some compatibility stuff:\n    else if (std::strcmp(smpi_privatize_option, \"1\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_DEFAULT;\n    else if (std::strcmp(smpi_privatize_option, \"0\") == 0)\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_NONE;\n\n    else\n      xbt_die(\"Invalid value for smpi/privatization: '%s'\", smpi_privatize_option);\n\n#if defined(__FreeBSD__)\n    if (smpi_privatize_global_variables == SMPI_PRIVATIZE_MMAP) {\n      XBT_INFO(\"Mixing mmap privatization is broken on FreeBSD, switching to dlopen privatization instead.\");\n      smpi_privatize_global_variables = SMPI_PRIVATIZE_DLOPEN;\n    }\n#endif\n\n    if (smpi_cpu_threshold < 0)\n      smpi_cpu_threshold = DBL_MAX;\n\n    char* val = xbt_cfg_get_string(\"smpi/shared-malloc\");\n    if (not strcasecmp(val, \"yes\") || not strcmp(val, \"1\") || not strcasecmp(val, \"on\") ||\n        not strcasecmp(val, \"global\")) {\n      smpi_cfg_shared_malloc = shmalloc_global;\n    } else if (not strcasecmp(val, \"local\")) {\n      smpi_cfg_shared_malloc = shmalloc_local;\n    } else if (not strcasecmp(val, \"no\") || not strcmp(val, \"0\") || not strcasecmp(val, \"off\")) {\n      smpi_cfg_shared_malloc = shmalloc_none;\n    } else {\n      xbt_die(\"Invalid value '%s' for option smpi/shared-malloc. Possible values: 'on' or 'global', 'local', 'off'\",\n              val);\n    }\n}\n\ntypedef std::function<int(int argc, char *argv[])> smpi_entry_point_type;\ntypedef int (* smpi_c_entry_point_type)(int argc, char **argv);\ntypedef void (*smpi_fortran_entry_point_type)();\n\nstatic int smpi_run_entry_point(smpi_entry_point_type entry_point, std::vector<std::string> args)\n{\n  char noarg[]   = {'\\0'};\n  const int argc = args.size();\n  std::unique_ptr<char*[]> argv(new char*[argc + 1]);\n  for (int i = 0; i != argc; ++i)\n    argv[i] = args[i].empty() ? noarg : &args[i].front();\n  argv[argc] = nullptr;\n\n  int res = entry_point(argc, argv.get());\n  if (res != 0){\n    XBT_WARN(\"SMPI process did not return 0. Return value : %d\", res);\n    smpi_process()->set_return_value(res);\n  }\n  return 0;\n}\n\n// TODO, remove the number of functions involved here\nstatic smpi_entry_point_type smpi_resolve_function(void* handle)\n{\n  smpi_fortran_entry_point_type entry_point_fortran = (smpi_fortran_entry_point_type)dlsym(handle, \"user_main_\");\n  if (entry_point_fortran != nullptr) {\n    return [entry_point_fortran](int argc, char** argv) {\n      smpi_process_init(&argc, &argv);\n      entry_point_fortran();\n      return 0;\n    };\n  }\n\n  smpi_c_entry_point_type entry_point = (smpi_c_entry_point_type)dlsym(handle, \"main\");\n  if (entry_point != nullptr) {\n    return entry_point;\n  }\n\n  return smpi_entry_point_type();\n}\n\nint smpi_main(const char* executable, int argc, char *argv[])\n{\n  srand(SMPI_RAND_SEED);\n\n  if (getenv(\"SMPI_PRETEND_CC\") != nullptr) {\n    /* Hack to ensure that smpicc can pretend to be a simple compiler. Particularly handy to pass it to the\n     * configuration tools */\n    return 0;\n  }\n\n  TRACE_global_init(&argc, argv);\n\n  SIMIX_global_init(&argc, argv);\n  MSG_init(&argc,argv);\n\n  SMPI_switch_data_segment = &smpi_switch_data_segment;\n\n  simgrid::s4u::Host::onCreation.connect([](simgrid::s4u::Host& host) {\n    host.extension_set(new simgrid::smpi::SmpiHost(&host));\n  });\n\n  // parse the platform file: get the host list\n  SIMIX_create_environment(argv[1]);\n  SIMIX_comm_set_copy_data_callback(smpi_comm_copy_buffer_callback);\n\n  static std::size_t rank = 0;\n\n  smpi_init_options();\n\n  if (smpi_privatize_global_variables == SMPI_PRIVATIZE_DLOPEN) {\n\n    std::string executable_copy = executable;\n\n    // Prepare the copy of the binary (get its size)\n    struct stat fdin_stat;\n    stat(executable_copy.c_str(), &fdin_stat);\n    off_t fdin_size = fdin_stat.st_size;\n\n    simix_global->default_function = [executable_copy, fdin_size](std::vector<std::string> args) {\n      return std::function<void()>([executable_copy, fdin_size, args] {\n\n        // Copy the dynamic library:\n        std::string target_executable = executable_copy\n          + \"_\" + std::to_string(getpid())\n          + \"_\" + std::to_string(rank++) + \".so\";\n\n        int fdin = open(executable_copy.c_str(), O_RDONLY);\n        xbt_assert(fdin >= 0, \"Cannot read from %s\", executable_copy.c_str());\n        int fdout = open(target_executable.c_str(), O_CREAT | O_RDWR, S_IRWXU);\n        xbt_assert(fdout >= 0, \"Cannot write into %s\", target_executable.c_str());\n\n#if HAVE_SENDFILE\n        ssize_t sent_size = sendfile(fdout, fdin, NULL, fdin_size);\n        xbt_assert(sent_size == fdin_size,\n                   \"Error while copying %s: only %zd bytes copied instead of %ld (errno: %d -- %s)\",\n                   target_executable.c_str(), sent_size, fdin_size, errno, strerror(errno));\n#else\n        XBT_VERB(\"Copy %d bytes into %s\", static_cast<int>(fdin_size), target_executable.c_str());\n        const int bufsize = 1024 * 1024 * 4;\n        char buf[bufsize];\n        while (int got = read(fdin, buf, bufsize)) {\n          if (got == -1) {\n            xbt_assert(errno == EINTR, \"Cannot read from %s\", executable_copy.c_str());\n          } else {\n            char* p  = buf;\n            int todo = got;\n            while (int done = write(fdout, p, todo)) {\n              if (done == -1) {\n                xbt_assert(errno == EINTR, \"Cannot write into %s\", target_executable.c_str());\n              } else {\n                p += done;\n                todo -= done;\n              }\n            }\n          }\n        }\n#endif\n        close(fdin);\n        close(fdout);\n\n        // Load the copy and resolve the entry point:\n        void* handle = dlopen(target_executable.c_str(), RTLD_LAZY | RTLD_LOCAL | RTLD_DEEPBIND);\n        if (xbt_cfg_get_boolean(\"smpi/keep-temps\") == false)\n          unlink(target_executable.c_str());\n        if (handle == nullptr)\n          xbt_die(\"dlopen failed: %s (errno: %d -- %s)\", dlerror(), errno, strerror(errno));\n        smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n        if (not entry_point)\n          xbt_die(\"Could not resolve entry point\");\n\n        smpi_run_entry_point(entry_point, args);\n      });\n    };\n\n  }\n  else {\n\n    // Load the dynamic library and resolve the entry point:\n    void* handle = dlopen(executable, RTLD_LAZY | RTLD_LOCAL | RTLD_DEEPBIND);\n    if (handle == nullptr)\n      xbt_die(\"dlopen failed for %s: %s (errno: %d -- %s)\", executable, dlerror(), errno, strerror(errno));\n    smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n    if (not entry_point)\n      xbt_die(\"main not found in %s\", executable);\n    // TODO, register the executable for SMPI privatization\n\n    // Execute the same entry point for each simulated process:\n    simix_global->default_function = [entry_point](std::vector<std::string> args) {\n      return std::function<void()>([entry_point, args] {\n        smpi_run_entry_point(entry_point, args);\n      });\n    };\n\n  }\n\n  SIMIX_launch_application(argv[2]);\n\n  SMPI_init();\n\n  /* Clean IO before the run */\n  fflush(stdout);\n  fflush(stderr);\n\n  if (MC_is_active()) {\n    MC_run();\n  } else {\n\n    SIMIX_run();\n\n    xbt_os_walltimer_stop(global_timer);\n    if (xbt_cfg_get_boolean(\"smpi/display-timing\")){\n      double global_time = xbt_os_timer_elapsed(global_timer);\n      XBT_INFO(\"Simulated time: %g seconds. \\n\\n\"\n          \"The simulation took %g seconds (after parsing and platform setup)\\n\"\n          \"%g seconds were actual computation of the application\",\n          SIMIX_get_clock(), global_time , smpi_total_benched_time);\n\n      if (smpi_total_benched_time/global_time>=0.75)\n      XBT_INFO(\"More than 75%% of the time was spent inside the application code.\\n\"\n      \"You may want to use sampling functions or trace replay to reduce this.\");\n    }\n  }\n  int count = smpi_process_count();\n  int ret   = 0;\n  for (int i = 0; i < count; i++) {\n    if(process_data[i]->return_value()!=0){\n      ret=process_data[i]->return_value();//return first non 0 value\n      break;\n    }\n  }\n  smpi_global_destroy();\n\n  TRACE_end();\n\n  return ret;\n}\n\n// Called either directly from the user code, or from the code called by smpirun\nvoid SMPI_init(){\n  smpi_init_logs();\n  smpi_init_options();\n  smpi_global_init();\n  smpi_check_options();\n  TRACE_smpi_alloc();\n  simgrid::surf::surfExitCallbacks.connect(TRACE_smpi_release);\n  if(smpi_privatize_global_variables == SMPI_PRIVATIZE_MMAP)\n    smpi_initialize_global_memory_segments();\n}\n\nvoid SMPI_finalize(){\n  smpi_global_destroy();\n}\n\nvoid smpi_mpi_init() {\n  if(smpi_init_sleep > 0)\n    simcall_process_sleep(smpi_init_sleep);\n}\n\ndouble smpi_mpi_wtime(){\n  double time;\n  if (smpi_process()->initialized() != 0 && smpi_process()->finalized() == 0 && smpi_process()->sampling() == 0) {\n    smpi_bench_end();\n    time = SIMIX_get_clock();\n    // to avoid deadlocks if used as a break condition, such as\n    //     while (MPI_Wtime(...) < time_limit) {\n    //       ....\n    //     }\n    // because the time will not normally advance when only calls to MPI_Wtime\n    // are made -> deadlock (MPI_Wtime never reaches the time limit)\n    if(smpi_wtime_sleep > 0)\n      simcall_process_sleep(smpi_wtime_sleep);\n    smpi_bench_begin();\n  } else {\n    time = SIMIX_get_clock();\n  }\n  return time;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/src/simix/smx_context.cpp": "/* a fast and simple context switching library                              */\n\n/* Copyright (c) 2009-2017. The SimGrid Team. All rights reserved.          */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#include <cerrno>\n#include <cstring>\n\n#include <utility>\n#include <string>\n\n#include <xbt/config.hpp>\n#include <xbt/log.h>\n#include <xbt/range.hpp>\n#include <xbt/sysdep.h>\n\n#include \"src/internal_config.h\"\n#include \"xbt/log.h\"\n#include \"xbt/swag.h\"\n#include \"xbt/xbt_os_thread.h\"\n#include \"smx_private.h\"\n#include \"simgrid/sg_config.h\"\n#include \"src/internal_config.h\"\n#include \"simgrid/modelchecker.h\"\n\n\n#ifdef _WIN32\n#include <windows.h>\n#include <malloc.h>\n#else\n#include <sys/mman.h>\n#endif\n\n#ifdef __MINGW32__\n#define _aligned_malloc __mingw_aligned_malloc\n#define _aligned_free  __mingw_aligned_free\n#endif /*MINGW*/\n\n#if HAVE_VALGRIND_H\n# include <valgrind/valgrind.h>\n#endif\n\nXBT_LOG_NEW_DEFAULT_SUBCATEGORY(simix_context, simix, \"Context switching mechanism\");\n\nstatic std::pair<const char*, simgrid::kernel::context::ContextFactoryInitializer> context_factories[] = {\n#if HAVE_RAW_CONTEXTS\n  { \"raw\", &simgrid::kernel::context::raw_factory },\n#endif\n#if HAVE_UCONTEXT_CONTEXTS\n  { \"ucontext\", &simgrid::kernel::context::sysv_factory },\n#endif\n#if HAVE_BOOST_CONTEXTS\n  { \"boost\", &simgrid::kernel::context::boost_factory },\n#endif\n#if HAVE_THREAD_CONTEXTS\n  { \"thread\", &simgrid::kernel::context::thread_factory },\n#endif\n};\n\nstatic_assert(sizeof(context_factories) != 0, \"No context factories are enabled for this build\");\n\n// Create the list of possible contexts:\nstatic inline\nstd::string contexts_list()\n{\n  std::string res;\n  const std::size_t n = sizeof(context_factories) / sizeof(context_factories[0]);\n  for (std::size_t i = 1; i != n; ++i) {\n    res += \", \";\n    res += context_factories[i].first;\n  }\n  return res;\n}\n\nstatic simgrid::config::Flag<std::string> context_factory_name(\n  \"contexts/factory\",\n  (std::string(\"Possible values: \")+contexts_list()).c_str(),\n  context_factories[0].first);\n\nint smx_context_stack_size;\nint smx_context_stack_size_was_set = 0;\nint smx_context_guard_size;\nint smx_context_guard_size_was_set = 0;\n#if HAVE_THREAD_LOCAL_STORAGE\nstatic XBT_THREAD_LOCAL smx_context_t smx_current_context_parallel;\n#else\nstatic xbt_os_thread_key_t smx_current_context_key = 0;\n#endif\nstatic smx_context_t smx_current_context_serial;\nstatic int smx_parallel_contexts = 1;\nstatic int smx_parallel_threshold = 2;\nstatic e_xbt_parmap_mode_t smx_parallel_synchronization_mode = XBT_PARMAP_DEFAULT;\n\n/**\n * This function is called by SIMIX_global_init() to initialize the context module.\n */\nvoid SIMIX_context_mod_init()\n{\n  xbt_assert(simix_global->context_factory == nullptr);\n\n#if HAVE_THREAD_CONTEXTS && not HAVE_THREAD_LOCAL_STORAGE\n  /* the __thread storage class is not available on this platform:\n   * use getspecific/setspecific instead to store the current context in each thread */\n  xbt_os_thread_key_create(&smx_current_context_key);\n#endif\n\n#if defined(__APPLE__) || defined(__NetBSD__)\n  if (context_factory_name == std::string(\"thread\") &&\n      strcmp(xbt_cfg_get_string(\"smpi/privatization\"), \"dlopen\") == 0) {\n    XBT_WARN(\"dlopen+thread broken on Apple and BSD. Switching to raw contexts.\");\n    context_factory_name = \"raw\";\n  }\n#endif\n#if defined(__FreeBSD__)\n  if (context_factory_name == std::string(\"thread\") && strcmp(xbt_cfg_get_string(\"smpi/privatization\"), \"no\") != 0) {\n    XBT_WARN(\"mmap broken on FreeBSD, but dlopen+thread broken too. Switching to dlopen+raw contexts.\");\n    context_factory_name = \"raw\";\n  }\n#endif\n\n  /* select the context factory to use to create the contexts */\n  if (simgrid::kernel::context::factory_initializer) { // Give Java a chance to hijack the factory mechanism\n    simix_global->context_factory = simgrid::kernel::context::factory_initializer();\n    return;\n  }\n  /* use the factory specified by --cfg=contexts/factory:value */\n  for (auto const& factory : context_factories)\n    if (context_factory_name == factory.first) {\n      simix_global->context_factory = factory.second();\n      break;\n    }\n\n  if (simix_global->context_factory == nullptr) {\n    XBT_ERROR(\"Invalid context factory specified. Valid factories on this machine:\");\n#if HAVE_RAW_CONTEXTS\n    XBT_ERROR(\"  raw: high performance context factory implemented specifically for SimGrid\");\n#else\n    XBT_ERROR(\"  (raw contexts were disabled at compilation time on this machine -- check configure logs for details)\");\n#endif\n#if HAVE_UCONTEXT_CONTEXTS\n    XBT_ERROR(\"  ucontext: classical system V contexts (implemented with makecontext, swapcontext and friends)\");\n#else\n    XBT_ERROR(\"  (ucontext was disabled at compilation time on this machine -- check configure logs for details)\");\n#endif\n#if HAVE_BOOST_CONTEXTS\n    XBT_ERROR(\"  boost: this uses the boost libraries context implementation\");\n#else\n    XBT_ERROR(\"  (boost was disabled at compilation time on this machine -- check configure logs for details. Did you install the libboost-context-dev package?)\");\n#endif\n    XBT_ERROR(\"  thread: slow portability layer using pthreads as provided by gcc\");\n    xbt_die(\"Please use a valid factory.\");\n  }\n}\n\n/**\n * This function is called by SIMIX_clean() to finalize the context module.\n */\nvoid SIMIX_context_mod_exit()\n{\n  delete simix_global->context_factory;\n  simix_global->context_factory = nullptr;\n}\n\nvoid *SIMIX_context_stack_new()\n{\n  void *stack;\n\n  /* FIXME: current code for stack overflow protection assumes that stacks are\n   * growing downward (PTH_STACKGROWTH == -1).  Protected pages need to be put\n   * after the stack when PTH_STACKGROWTH == 1. */\n\n  if (smx_context_guard_size > 0 && not MC_is_active()) {\n\n#if !defined(PTH_STACKGROWTH) || (PTH_STACKGROWTH != -1)\n    static int warned_once = 0;\n    if (not warned_once) {\n      XBT_WARN(\"Stack overflow protection is known to be broken on your system.  Either stack grows upwards, or it was not even tested properly.\");\n      warned_once = 1;\n    }\n#endif\n\n    size_t size = smx_context_stack_size + smx_context_guard_size;\n#if SIMGRID_HAVE_MC\n    /* Cannot use posix_memalign when SIMGRID_HAVE_MC. Align stack by hand, and save the\n     * pointer returned by xbt_malloc0. */\n    char *alloc = (char*)xbt_malloc0(size + xbt_pagesize);\n    stack = alloc - ((uintptr_t)alloc & (xbt_pagesize - 1)) + xbt_pagesize;\n    *((void **)stack - 1) = alloc;\n#elif !defined(_WIN32)\n    if (posix_memalign(&stack, xbt_pagesize, size) != 0)\n      xbt_die(\"Failed to allocate stack.\");\n#else\n    stack = _aligned_malloc(size, xbt_pagesize);\n#endif\n\n#ifndef _WIN32\n    if (mprotect(stack, smx_context_guard_size, PROT_NONE) == -1) {\n      xbt_die(\n          \"Failed to protect stack: %s.\\n\"\n          \"If you are running a lot of actors, you may be exceeding the amount of mappings allowed per process.\\n\"\n          \"On Linux systems, change this value with sudo sysctl -w vm.max_map_count=newvalue (default value: 65536)\\n\"\n          \"Please see http://simgrid.gforge.inria.fr/simgrid/latest/doc/html/options.html#options_virt for more info.\",\n          strerror(errno));\n      /* This is fatal. We are going to fail at some point when we try reusing this. */\n    }\n#endif\n    stack = (char *)stack + smx_context_guard_size;\n  } else {\n    stack = xbt_malloc0(smx_context_stack_size);\n  }\n\n#if HAVE_VALGRIND_H\n  unsigned int valgrind_stack_id = VALGRIND_STACK_REGISTER(stack, (char *)stack + smx_context_stack_size);\n  memcpy((char *)stack + smx_context_usable_stack_size, &valgrind_stack_id, sizeof valgrind_stack_id);\n#endif\n\n  return stack;\n}\n\nvoid SIMIX_context_stack_delete(void *stack)\n{\n  if (not stack)\n    return;\n\n#if HAVE_VALGRIND_H\n  unsigned int valgrind_stack_id;\n  memcpy(&valgrind_stack_id, (char *)stack + smx_context_usable_stack_size, sizeof valgrind_stack_id);\n  VALGRIND_STACK_DEREGISTER(valgrind_stack_id);\n#endif\n\n#ifndef _WIN32\n  if (smx_context_guard_size > 0 && not MC_is_active()) {\n    stack = (char *)stack - smx_context_guard_size;\n    if (mprotect(stack, smx_context_guard_size, PROT_READ | PROT_WRITE) == -1) {\n      XBT_WARN(\"Failed to remove page protection: %s\", strerror(errno));\n      /* try to pursue anyway */\n    }\n#if SIMGRID_HAVE_MC\n    /* Retrieve the saved pointer.  See SIMIX_context_stack_new above. */\n    stack = *((void **)stack - 1);\n#endif\n  }\n#endif /* not windows */\n\n  xbt_free(stack);\n}\n\n/** @brief Returns whether some parallel threads are used for the user contexts. */\nint SIMIX_context_is_parallel() {\n  return smx_parallel_contexts > 1;\n}\n\n/**\n * @brief Returns the number of parallel threads used for the user contexts.\n * \\return the number of threads (1 means no parallelism)\n */\nint SIMIX_context_get_nthreads() {\n  return smx_parallel_contexts;\n}\n\n/**\n * \\brief Sets the number of parallel threads to use\n * for the user contexts.\n *\n * This function should be called before initializing SIMIX.\n * A value of 1 means no parallelism (1 thread only).\n * If the value is greater than 1, the thread support must be enabled.\n *\n * \\param nb_threads the number of threads to use\n */\nvoid SIMIX_context_set_nthreads(int nb_threads) {\n  if (nb_threads<=0) {\n     nb_threads = xbt_os_get_numcores();\n     XBT_INFO(\"Auto-setting contexts/nthreads to %d\",nb_threads);\n  }\n#if !HAVE_THREAD_CONTEXTS\n  xbt_assert(nb_threads == 1, \"Parallel runs are impossible when the pthreads are missing.\");\n#endif\n  smx_parallel_contexts = nb_threads;\n}\n\n/**\n * \\brief Returns the threshold above which user processes are run in parallel.\n *\n * If the number of threads is set to 1, there is no parallelism and this\n * threshold has no effect.\n *\n * \\return when the number of user processes ready to run is above\n * this threshold, they are run in parallel\n */\nint SIMIX_context_get_parallel_threshold() {\n  return smx_parallel_threshold;\n}\n\n/**\n * \\brief Sets the threshold above which user processes are run in parallel.\n *\n * If the number of threads is set to 1, there is no parallelism and this\n * threshold has no effect.\n *\n * \\param threshold when the number of user processes ready to run is above\n * this threshold, they are run in parallel\n */\nvoid SIMIX_context_set_parallel_threshold(int threshold) {\n  smx_parallel_threshold = threshold;\n}\n\n/**\n * \\brief Returns the synchronization mode used when processes are run in\n * parallel.\n * \\return how threads are synchronized if processes are run in parallel\n */\ne_xbt_parmap_mode_t SIMIX_context_get_parallel_mode() {\n  return smx_parallel_synchronization_mode;\n}\n\n/**\n * \\brief Sets the synchronization mode to use when processes are run in\n * parallel.\n * \\param mode how to synchronize threads if processes are run in parallel\n */\nvoid SIMIX_context_set_parallel_mode(e_xbt_parmap_mode_t mode) {\n  smx_parallel_synchronization_mode = mode;\n}\n\n/**\n * \\brief Returns the current context of this thread.\n * \\return the current context of this thread\n */\nsmx_context_t SIMIX_context_get_current()\n{\n  if (SIMIX_context_is_parallel()) {\n#if HAVE_THREAD_LOCAL_STORAGE\n    return smx_current_context_parallel;\n#else\n    return xbt_os_thread_get_specific(smx_current_context_key);\n#endif\n  }\n  else {\n    return smx_current_context_serial;\n  }\n}\n\n/**\n * \\brief Sets the current context of this thread.\n * \\param context the context to set\n */\nvoid SIMIX_context_set_current(smx_context_t context)\n{\n  if (SIMIX_context_is_parallel()) {\n#if HAVE_THREAD_LOCAL_STORAGE\n    smx_current_context_parallel = context;\n#else\n    xbt_os_thread_set_specific(smx_current_context_key, context);\n#endif\n  }\n  else {\n    smx_current_context_serial = context;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/teshsuite/smpi/CMakeLists.txt": "if(enable_smpi)\n  if(WIN32)\n    set(CMAKE_C_FLAGS \"-include ${CMAKE_HOME_DIRECTORY}/include/smpi/smpi_main.h\")\n  else()\n    set(CMAKE_C_COMPILER \"${CMAKE_BINARY_DIR}/smpi_script/bin/smpicc\")\n  endif()\n\n  include_directories(BEFORE \"${CMAKE_HOME_DIRECTORY}/include/smpi\")\n  foreach(x coll-allgather coll-allgatherv coll-allreduce coll-alltoall coll-alltoallv coll-barrier coll-bcast \n            coll-gather coll-reduce coll-reduce-scatter coll-scatter macro-sample pt2pt-dsend pt2pt-pingpong \n            type-hvector type-indexed type-struct type-vector bug-17132 timers privatization )\n    add_executable       (${x}  ${x}/${x}.c)\n    target_link_libraries(${x}  simgrid)\n    set_target_properties(${x}  PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${x})\n\n    set(tesh_files    ${tesh_files}    ${CMAKE_CURRENT_SOURCE_DIR}/${x}/${x}.tesh)\n    set(teshsuite_src ${teshsuite_src} ${CMAKE_CURRENT_SOURCE_DIR}/${x}/${x}.c)\n  endforeach()\n\n  if(NOT WIN32)\n    foreach(x macro-shared macro-partial-shared macro-partial-shared-communication )\n      add_executable       (${x}  ${x}/${x}.c)\n      target_link_libraries(${x}  simgrid)\n      set_target_properties(${x}  PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${x})\n\n      set(tesh_files    ${tesh_files}    ${CMAKE_CURRENT_SOURCE_DIR}/${x}/${x}.tesh)\n      set(teshsuite_src ${teshsuite_src} ${CMAKE_CURRENT_SOURCE_DIR}/${x}/${x}.c)\n    endforeach()\n  endif()\nendif()\n\nset (teshsuite_src ${teshsuite_src} PARENT_SCOPE)\nset(tesh_files    ${tesh_files}     ${CMAKE_CURRENT_SOURCE_DIR}/coll-allreduce/coll-allreduce-large.tesh\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/coll-allreduce/coll-allreduce-automatic.tesh\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/coll-alltoall/clusters.tesh\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/pt2pt-pingpong/broken_hostfiles.tesh\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/pt2pt-pingpong/TI_output.tesh              \n                                    ${CMAKE_CURRENT_SOURCE_DIR}/privatization/privatization_dlopen.tesh                             PARENT_SCOPE)\nset(bin_files       ${bin_files}    ${CMAKE_CURRENT_SOURCE_DIR}/hostfile\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/hostfile_cluster\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/hostfile_coll\n                                    ${CMAKE_CURRENT_SOURCE_DIR}/hostfile_empty                             PARENT_SCOPE)\n\nif(enable_smpi)\n  if(NOT WIN32)\n    ADD_TESH_FACTORIES(tesh-smpi-macro-shared \"thread;ucontext;raw;boost\" --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/macro-shared --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/macro-shared macro-shared.tesh)\n    ADD_TESH_FACTORIES(tesh-smpi-macro-partial-shared \"thread;ucontext;raw;boost\" --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/macro-partial-shared --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/macro-partial-shared macro-partial-shared.tesh)\n    ADD_TESH_FACTORIES(tesh-smpi-macro-partial-shared-communication \"thread;ucontext;raw;boost\" --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/macro-partial-shared-communication --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/macro-partial-shared-communication macro-partial-shared-communication.tesh)\n  endif()\n\n  foreach(x coll-allgather coll-allgatherv coll-allreduce coll-alltoall coll-alltoallv coll-barrier coll-bcast \n            coll-gather coll-reduce coll-reduce-scatter coll-scatter macro-sample pt2pt-dsend pt2pt-pingpong \n            type-hvector type-indexed type-struct type-vector bug-17132 timers)\n    ADD_TESH_FACTORIES(tesh-smpi-${x} \"thread;ucontext;raw;boost\" --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/${x} --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/${x} ${x}.tesh)\n  endforeach()\n\n  foreach (ALLGATHER 2dmesh 3dmesh bruck GB loosely_lr NTSLR_NB pair rdb  rhv ring SMP_NTS smp_simple spreading_simple \n                     ompi mpich ompi_neighborexchange mvapich2 mvapich2_smp impi)\n    ADD_TESH(tesh-smpi-coll-allgather-${ALLGATHER} --cfg smpi/allgather:${ALLGATHER} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-allgather --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-allgather coll-allgather.tesh)\n  endforeach()\n\n  foreach (ALLGATHERV GB pair ring ompi mpich ompi_neighborexchange ompi_bruck mpich_rdb mpich_ring mvapich2 impi)\n    ADD_TESH(tesh-smpi-coll-allgatherv-${ALLGATHERV} --cfg smpi/allgatherv:${ALLGATHERV} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-allgatherv --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-allgatherv coll-allgatherv.tesh)\n  endforeach()\n\n  foreach (ALLREDUCE lr rab1 rab2 rab_rdb rdb smp_binomial smp_binomial_pipeline smp_rdb smp_rsag smp_rsag_lr impi\n                     smp_rsag_rab redbcast ompi mpich ompi_ring_segmented mvapich2 mvapich2_rs mvapich2_two_level)\n    ADD_TESH(tesh-smpi-coll-allreduce-${ALLREDUCE} --cfg smpi/allreduce:${ALLREDUCE} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-allreduce --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-allreduce coll-allreduce.tesh)\n  endforeach()\n\n  foreach (ALLTOALL 2dmesh 3dmesh pair pair_rma pair_one_barrier pair_light_barrier pair_mpi_barrier rdb ring \n                    ring_light_barrier ring_mpi_barrier ring_one_barrier bruck basic_linear ompi mpich mvapich2 \n                    mvapich2_scatter_dest impi)\n    ADD_TESH(tesh-smpi-coll-alltoall-${ALLTOALL} --cfg smpi/alltoall:${ALLTOALL} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-alltoall --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-alltoall coll-alltoall.tesh)\n  endforeach()\n\n  foreach (ALLTOALLV pair pair_light_barrier pair_mpi_barrier pair_one_barrier  ring ring_light_barrier ring_mpi_barrier\n                     ring_one_barrier bruck ompi mpich mvapich2 ompi_basic_linear impi)\n    ADD_TESH(tesh-smpi-coll-alltoallv-${ALLTOALLV} --cfg smpi/alltoallv:${ALLTOALLV} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-alltoallv --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-alltoallv coll-alltoallv.tesh)\n  endforeach()\n\n  foreach (BARRIER ompi mpich ompi_basic_linear ompi_tree ompi_bruck ompi_recursivedoubling ompi_doublering mvapich2_pair mvapich2 impi)\n      ADD_TESH(tesh-smpi-coll-barrier-${BARRIER} --cfg smpi/barrier:${BARRIER} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-barrier --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-barrier coll-barrier.tesh)\n  endforeach()\n\n  foreach (BCAST arrival_pattern_aware arrival_pattern_aware_wait arrival_scatter binomial_tree flattree \n                 flattree_pipeline NTSB NTSL NTSL_Isend scatter_LR_allgather scatter_rdb_allgather SMP_binary \n                 SMP_binomial SMP_linear ompi mpich ompi_split_bintree ompi_pipeline mvapich2 mvapich2_intra_node \n                 mvapich2_knomial_intra_node impi)\n    ADD_TESH(tesh-smpi-coll-bcast-${BCAST} --cfg smpi/bcast:${BCAST} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-bcast --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-bcast coll-bcast.tesh)\n  endforeach()\n\n  foreach (GATHER ompi mpich ompi_basic_linear ompi_linear_sync ompi_binomial mvapich2 mvapich2_two_level impi)\n    ADD_TESH(tesh-smpi-coll-gather-${GATHER} --cfg smpi/gather:${GATHER} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-gather --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-gather coll-gather.tesh)\n  endforeach()\n\n  foreach (REDUCE arrival_pattern_aware binomial flat_tree NTSL scatter_gather ompi mpich ompi_chain ompi_binary impi\n                  ompi_basic_linear ompi_binomial ompi_in_order_binary mvapich2 mvapich2_knomial mvapich2_two_level rab)\n    ADD_TESH(tesh-smpi-coll-reduce-${REDUCE} --cfg smpi/reduce:${REDUCE} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-reduce --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-reduce coll-reduce.tesh)\n  endforeach()\n\n  foreach (REDUCE_SCATTER ompi mpich ompi_basic_recursivehalving ompi_ring mpich_noncomm mpich_pair mvapich2 mpich_rdb impi)\n    ADD_TESH(tesh-smpi-coll-reduce-scatter-${REDUCE_SCATTER} --cfg smpi/reduce_scatter:${REDUCE_SCATTER} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-reduce-scatter --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-reduce-scatter coll-reduce-scatter.tesh)\n  endforeach()\n\n  foreach (SCATTER ompi mpich ompi_basic_linear ompi_binomial mvapich2 mvapich2_two_level_binomial mvapich2_two_level_direct impi)\n    ADD_TESH(tesh-smpi-coll-scatter-${SCATTER} --cfg smpi/scatter:${SCATTER} --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-scatter --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-scatter coll-scatter.tesh)\n  endforeach()\n\n  # Extra allreduce test: large automatic\n  ADD_TESH(tesh-smpi-coll-allreduce-large --cfg smpi/allreduce:ompi_ring_segmented --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-allreduce --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-allreduce coll-allreduce-large.tesh)\n  ADD_TESH(tesh-smpi-coll-allreduce-automatic --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-allreduce --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-allreduce coll-allreduce-automatic.tesh)\n\n  # Extra allreduce test: cluster-types\n  ADD_TESH(tesh-smpi-cluster-types --cfg smpi/alltoall:mvapich2 --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/coll-alltoall --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/coll-alltoall clusters.tesh)\n\n  # Extra pt2pt pingpong test: broken usage ti-tracing\n  ADD_TESH_FACTORIES(tesh-smpi-broken  \"thread\"   --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/pt2pt-pingpong --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/pt2pt-pingpong broken_hostfiles.tesh)\n  ADD_TESH(tesh-smpi-replay-ti-tracing            --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/pt2pt-pingpong --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/pt2pt-pingpong TI_output.tesh)\n\n  # Simple privatization tests\n  if(HAVE_PRIVATIZATION)\n    ADD_TESH_FACTORIES(tesh-smpi-privatization-mmap  \"thread;ucontext;raw;boost\"   --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/privatization --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/privatization privatization.tesh)\n  endif()\n\n    ADD_TESH_FACTORIES(tesh-smpi-privatization-dlopen  \"thread;ucontext;raw;boost\"   --setenv bindir=${CMAKE_BINARY_DIR}/teshsuite/smpi/privatization --cd ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/privatization privatization_dlopen.tesh)\n\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/teshsuite/smpi/mpich3-test/coll/CMakeLists.txt": "if(enable_smpi AND enable_smpi_MPICH3_testsuite)\n  if(WIN32)\n    set(CMAKE_C_FLAGS \"-include ${CMAKE_HOME_DIRECTORY}/include/smpi/smpi_main.h\")\n  else()\n    set(CMAKE_C_COMPILER \"${CMAKE_BINARY_DIR}/smpi_script/bin/smpicc\")\n    set(CMAKE_Fortran_COMPILER \"${CMAKE_BINARY_DIR}/smpi_script/bin/smpiff\")\n  endif()\n\n  include_directories(BEFORE \"${CMAKE_HOME_DIRECTORY}/include/smpi\")\n  include_directories(\"${CMAKE_CURRENT_SOURCE_DIR}/../include/\")\n\n  add_executable(allgather2 allgather2.c)\n  add_executable(allgather3 allgather3.c)\n  add_executable(allgather_struct allgather_struct.c)\n  add_executable(allgatherv2 allgatherv2.c)\n  add_executable(allgatherv3 allgatherv3.c)\n  if(HAVE_PRIVATIZATION)\n    add_executable(allgatherv4 allgatherv4.c)\n  else()\n    add_executable(allgatherv4 allgatherv4_manual.c)\n  endif()\n  add_executable(allred2 allred2.c)\n  add_executable(allred3 allred3.c)\n  add_executable(allred4 allred4.c)\n  add_executable(allred5 allred5.c)\n  add_executable(allred6 allred6.c)\n  if(HAVE_PRIVATIZATION)\n  add_executable(allred allred.c)\n  else()\n    add_executable(allred allred_manual.c)\n  endif()\n  add_executable(allredmany allredmany.c)\n  add_executable(alltoall1 alltoall1.c)\n  add_executable(alltoallv0 alltoallv0.c)\n  add_executable(alltoallv alltoallv.c)\n#  add_executable(alltoallw1 alltoallw1.c)\n#  add_executable(alltoallw2 alltoallw2.c)\n#  add_executable(alltoallw_zeros alltoallw_zeros.c)\n  add_executable(bcast_full bcast.c)\n  add_executable(bcast_min_datatypes bcast.c)\n  add_executable(bcast_comm_world bcast.c)\n  add_executable(bcasttest bcasttest.c)\n  add_executable(bcastzerotype bcastzerotype.c)\n  add_executable(coll10 coll10.c)\n  add_executable(coll11 coll11.c)\n  add_executable(coll12 coll12.c)\n  add_executable(coll13 coll13.c)\n  add_executable(coll2 coll2.c)\n  add_executable(coll3 coll3.c)\n  add_executable(coll4 coll4.c)\n  add_executable(coll5 coll5.c)\n  add_executable(coll6 coll6.c)\n  add_executable(coll7 coll7.c)\n  add_executable(coll8 coll8.c)\n  add_executable(coll9 coll9.c)\n  add_executable(exscan2 exscan2.c)\n  add_executable(exscan exscan.c)\n  add_executable(gather2 gather2.c)\n  add_executable(gather_big gather_big.c)\n  add_executable(gather gather.c)\n#  add_executable(iallred iallred.c)\n#  add_executable(ibarrier ibarrier.c)\n#  add_executable(icallgather icallgather.c)\n#  add_executable(icallgatherv icallgatherv.c)\n#  add_executable(icallreduce icallreduce.c)\n#  add_executable(icalltoall icalltoall.c)\n#  add_executable(icalltoallv icalltoallv.c)\n#  add_executable(icalltoallw icalltoallw.c)\n#  add_executable(icbarrier icbarrier.c)\n#  add_executable(icbcast icbcast.c)\n#  add_executable(icgather icgather.c)\n#  add_executable(icgatherv icgatherv.c)\n#  add_executable(icreduce icreduce.c)\n#  add_executable(icscatter icscatter.c)\n#  add_executable(icscatterv icscatterv.c)\n  add_executable(longuser longuser.c)\n#  add_executable(nonblocking2 nonblocking2.c)\n#  add_executable(nonblocking3 nonblocking3.c)\n#  add_executable(nonblocking nonblocking.c)\n#  add_executable(opband opband.c)\n#  add_executable(opbor opbor.c)\n#  add_executable(opbxor opbxor.c)\n  add_executable(op_commutative op_commutative.c)\n#  add_executable(opland opland.c)\n#  add_executable(oplor oplor.c)\n#  add_executable(oplxor oplxor.c)\n#  add_executable(opmax opmax.c)\n#  add_executable(opmaxloc opmaxloc.c)\n#  add_executable(opmin opmin.c)\n#  add_executable(opminloc opminloc.c)\n#  add_executable(opprod opprod.c)\n#  add_executable(opsum opsum.c)\n  add_executable(red3 red3.c)\n  add_executable(red4 red4.c)\n  add_executable(redscat2 redscat2.c)\n  add_executable(redscat3 redscat3.c)\n  add_executable(redscatbkinter redscatbkinter.c)\n  add_executable(redscatblk3 redscatblk3.c)\n  add_executable(red_scat_block2 red_scat_block2.c)\n  add_executable(red_scat_block red_scat_block.c)\n  add_executable(redscat redscat.c)\n#  add_executable(redscatinter redscatinter.c)\n  add_executable(reduce_mpich reduce.c)\n  add_executable(reduce_local reduce_local.c)\n  add_executable(scantst scantst.c)\n  add_executable(scatter2 scatter2.c)\n  add_executable(scatter3 scatter3.c)\n  add_executable(scattern scattern.c)\n  add_executable(scatterv scatterv.c)\n#  add_executable(uoplong uoplong.c)\n\n  target_link_libraries(allgather2  simgrid mtest_c)\n  target_link_libraries(allgather3  simgrid mtest_c)\n  target_link_libraries(allgather_struct  simgrid mtest_c)\n  target_link_libraries(allgatherv2  simgrid mtest_c)\n  target_link_libraries(allgatherv3  simgrid mtest_c)\n  target_link_libraries(allgatherv4  simgrid mtest_c)\n  target_link_libraries(allred2  simgrid mtest_c)\n  target_link_libraries(allred3  simgrid mtest_c)\n  target_link_libraries(allred4  simgrid mtest_c)\n  target_link_libraries(allred5  simgrid mtest_c)\n  target_link_libraries(allred6  simgrid mtest_c)\n  target_link_libraries(allred  simgrid mtest_c)\n  target_link_libraries(allredmany  simgrid mtest_c)\n  target_link_libraries(alltoall1  simgrid mtest_c)\n  target_link_libraries(alltoallv0  simgrid mtest_c)\n  target_link_libraries(alltoallv  simgrid mtest_c)\n#  target_link_libraries(alltoallw1  simgrid mtest_c)\n#  target_link_libraries(alltoallw2  simgrid mtest_c)\n#  target_link_libraries(alltoallw_zeros  simgrid mtest_c)\n  target_link_libraries(bcast_full  simgrid mtest_c)\n  target_link_libraries(bcast_min_datatypes  simgrid mtest_c)\n  target_link_libraries(bcast_comm_world  simgrid mtest_c)\n  target_link_libraries(bcasttest  simgrid mtest_c)\n  target_link_libraries(bcastzerotype  simgrid mtest_c)\n  target_link_libraries(coll10  simgrid mtest_c)\n  target_link_libraries(coll11  simgrid mtest_c)\n  target_link_libraries(coll12  simgrid mtest_c)\n  target_link_libraries(coll13  simgrid mtest_c)\n  target_link_libraries(coll2  simgrid mtest_c)\n  target_link_libraries(coll3  simgrid mtest_c)\n  target_link_libraries(coll4  simgrid mtest_c)\n  target_link_libraries(coll5  simgrid mtest_c)\n  target_link_libraries(coll6  simgrid mtest_c)\n  target_link_libraries(coll7  simgrid mtest_c)\n  target_link_libraries(coll8  simgrid mtest_c)\n  target_link_libraries(coll9  simgrid mtest_c)\n  target_link_libraries(exscan2  simgrid mtest_c)\n  target_link_libraries(exscan  simgrid mtest_c)\n  target_link_libraries(gather2  simgrid mtest_c)\n  target_link_libraries(gather_big  simgrid mtest_c)\n  target_link_libraries(gather  simgrid mtest_c)\n#  target_link_libraries(iallred  simgrid mtest_c)\n#  target_link_libraries(ibarrier  simgrid mtest_c)\n#  target_link_libraries(icallgather  simgrid mtest_c)\n#  target_link_libraries(icallgatherv  simgrid mtest_c)\n#  target_link_libraries(icallreduce  simgrid mtest_c)\n#  target_link_libraries(icalltoall  simgrid mtest_c)\n#  target_link_libraries(icalltoallv  simgrid mtest_c)\n#  target_link_libraries(icalltoallw  simgrid mtest_c)\n#  target_link_libraries(icbarrier  simgrid mtest_c)\n#  target_link_libraries(icbcast  simgrid mtest_c)\n#  target_link_libraries(icgather  simgrid mtest_c)\n#  target_link_libraries(icgatherv  simgrid mtest_c)\n#  target_link_libraries(icreduce  simgrid mtest_c)\n#  target_link_libraries(icscatter  simgrid mtest_c)\n#  target_link_libraries(icscatterv  simgrid mtest_c)\n  target_link_libraries(longuser  simgrid mtest_c)\n#  target_link_libraries(nonblocking2  simgrid mtest_c)\n#  target_link_libraries(nonblocking3  simgrid mtest_c)\n#  target_link_libraries(nonblocking  simgrid mtest_c)\n#  target_link_libraries(opband  simgrid mtest_c)\n#  target_link_libraries(opbor  simgrid mtest_c)\n#  target_link_libraries(opbxor  simgrid mtest_c)\n  target_link_libraries(op_commutative  simgrid mtest_c)\n#  target_link_libraries(opland  simgrid mtest_c)\n#  target_link_libraries(oplor  simgrid mtest_c)\n#  target_link_libraries(oplxor  simgrid mtest_c)\n#  target_link_libraries(opmax  simgrid mtest_c)\n#  target_link_libraries(opmaxloc  simgrid mtest_c)\n#  target_link_libraries(opmin  simgrid mtest_c)\n#  target_link_libraries(opminloc  simgrid mtest_c)\n#  target_link_libraries(opprod  simgrid mtest_c)\n#  target_link_libraries(opsum  simgrid mtest_c)\n  target_link_libraries(red3  simgrid mtest_c)\n  target_link_libraries(red4  simgrid mtest_c)\n  target_link_libraries(redscat2  simgrid mtest_c)\n  target_link_libraries(redscat3  simgrid mtest_c)\n  target_link_libraries(redscatbkinter  simgrid mtest_c)\n  target_link_libraries(redscatblk3  simgrid mtest_c)\n  target_link_libraries(red_scat_block2  simgrid mtest_c)\n  target_link_libraries(red_scat_block  simgrid mtest_c)\n  target_link_libraries(redscat  simgrid mtest_c)\n#  target_link_libraries(redscatinter  simgrid mtest_c)\n  target_link_libraries(reduce_mpich  simgrid mtest_c)\n  target_link_libraries(reduce_local  simgrid mtest_c)\n  target_link_libraries(scantst  simgrid mtest_c)\n  target_link_libraries(scatter2  simgrid mtest_c)\n  target_link_libraries(scatter3  simgrid mtest_c)\n  target_link_libraries(scattern  simgrid mtest_c)\n  target_link_libraries(scatterv  simgrid mtest_c)\n#  target_link_libraries(uoplong  simgrid mtest_c)\n\n  set_target_properties(allred PROPERTIES COMPILE_FLAGS \"-O0\" LINK_FLAGS \"-O0\")\n  set_target_properties(bcast_min_datatypes PROPERTIES COMPILE_FLAGS \"-DBCAST_MIN_DATATYPES_ONLY\" LINK_FLAGS \"-DBCAST_MIN_DATATYPES_ONLY\")\n  set_target_properties(bcast_comm_world PROPERTIES COMPILE_FLAGS \"-DBCAST_COMM_WORLD_ONLY\" LINK_FLAGS \"-DBCAST_COMM_WORLD_ONLY\")\n\n  # These tests take 5 to 15 seconds to run, so we don't want to run them several times.\n  # But at the same time, we'd like to check if they work for all factories and all privatization algorithm\n  # Thus the current matrix\n\n  # Test default selector: THREAD if available; RAW if not (with mmap privatization or none)\n  if(HAVE_THREAD_CONTEXTS)\n    ADD_TEST(test-smpi-mpich3-coll-thread      ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:thread -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION})\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-thread    PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n  else()\n    if(HAVE_RAW_CONTEXTS)\n    ADD_TEST(test-smpi-mpich3-coll-raw      ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION})\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-raw PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    endif()\n  endif()\n  \n  # Test OMPI selector: CONTEXT if available; RAW if not (with mmap privatization or none)\n  if(HAVE_UCONTEXT_CONTEXTS)\n    ADD_TEST(test-smpi-mpich3-coll-ompi-ucontext ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:ucontext -execarg=--cfg=smpi/coll_selector:ompi -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION} -execarg=--cfg=smpi/bcast:binomial_tree)\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-ompi-ucontext PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n  else()\n    if(HAVE_RAW_CONTEXTS)\n      ADD_TEST(test-smpi-mpich3-coll-ompi-raw ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/coll_selector:ompi -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION} -execarg=--cfg=smpi/bcast:binomial_tree)\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-ompi-raw PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    endif()\n  endif()\n\n  # Test MPICH selector: dlopen privatization and PTHREAD if exists (without priv and with raw if not)\n  if(HAVE_PRIVATIZATION AND HAVE_THREAD_CONTEXTS)\n    ADD_TEST(test-smpi-mpich3-coll-mpich-thread-dlopen ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:thread -execarg=--cfg=smpi/coll_selector:mpich -execarg=--cfg=smpi/privatization:dlopen)\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-mpich-thread-dlopen PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n  else()\n    if(HAVE_RAW_CONTEXTS)\n      ADD_TEST(test-smpi-mpich3-coll-mpich-raw ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/coll_selector:mpich -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION})\n      SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-mpich-raw PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    endif()\n  endif()\n\n  # Test MVAPICH2 selector: dlopen privatization and UCONTEXT if exists (without priv and with raw if not)\n  if(HAVE_PRIVATIZATION AND HAVE_UCONTEXT_CONTEXTS)\n    ADD_TEST(test-smpi-mpich3-coll-mvapich2-ucontext-dlopen ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:ucontext -execarg=--cfg=smpi/coll_selector:mvapich2 -execarg=--cfg=smpi/privatization:dlopen)\n    SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-mvapich2-ucontext-dlopen PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n  else()\n    if(HAVE_RAW_CONTEXTS)\n      ADD_TEST(test-smpi-mpich3-coll-mvapich2-raw ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/coll_selector:mvapich2 -execarg=--cfg=smpi/privatization:${HAVE_PRIVATIZATION})\n      SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-mvapich2-raw PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    endif()\n  endif()\n\n  # Test IMPI selector: always raw, with dlopen if priv exists\n  if(HAVE_RAW_CONTEXTS)\n    if(HAVE_PRIVATIZATION)\n      ADD_TEST(test-smpi-mpich3-coll-impi-raw-dlopen ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/coll_selector:impi -execarg=--cfg=smpi/privatization:dlopen)\n      SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-impi-raw-dlopen  PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    else()\n      ADD_TEST(test-smpi-mpich3-coll-impi-raw-nopriv ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/teshsuite/smpi/mpich3-test/coll ${PERL_EXECUTABLE} ${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/runtests ${TESH_OPTION} -mpiexec=${CMAKE_BINARY_DIR}/smpi_script/bin/smpirun -srcdir=${CMAKE_HOME_DIRECTORY}/teshsuite/smpi/mpich3-test/coll -tests=testlist -execarg=--cfg=contexts/factory:raw -execarg=--cfg=smpi/coll_selector:impi -execarg=--cfg=smpi/privatization:no)\n      SET_TESTS_PROPERTIES(test-smpi-mpich3-coll-impi-raw-nopriv  PROPERTIES PASS_REGULAR_EXPRESSION \"tests passed!\")\n    endif()\n  endif()\nendif()\n\nset(examples_src  ${examples_src}\n ${CMAKE_CURRENT_SOURCE_DIR}/allgather2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgather_struct.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgather3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgatherv2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgatherv3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgatherv4.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allgatherv4_manual.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred4.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred5.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred6.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allred_manual.c \n ${CMAKE_CURRENT_SOURCE_DIR}/allredmany.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoall1.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoallv0.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoallv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoallw1.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoallw2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/alltoallw_zeros.c \n ${CMAKE_CURRENT_SOURCE_DIR}/bcast.c \n ${CMAKE_CURRENT_SOURCE_DIR}/bcasttest.c \n ${CMAKE_CURRENT_SOURCE_DIR}/bcastzerotype.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll10.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll11.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll12.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll13.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll4.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll5.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll6.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll7.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll8.c \n ${CMAKE_CURRENT_SOURCE_DIR}/coll9.c \n ${CMAKE_CURRENT_SOURCE_DIR}/exscan2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/exscan.c \n ${CMAKE_CURRENT_SOURCE_DIR}/gather2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/gather_big.c \n ${CMAKE_CURRENT_SOURCE_DIR}/gather.c \n ${CMAKE_CURRENT_SOURCE_DIR}/iallred.c \n ${CMAKE_CURRENT_SOURCE_DIR}/ibarrier.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icallgather.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icallgatherv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icallreduce.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icalltoall.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icalltoallv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icalltoallw.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icbarrier.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icbcast.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icgather.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icgatherv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icreduce.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icscatter.c \n ${CMAKE_CURRENT_SOURCE_DIR}/icscatterv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/longuser.c \n ${CMAKE_CURRENT_SOURCE_DIR}/nonblocking2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/nonblocking3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/nonblocking.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opband.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opbor.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opbxor.c \n ${CMAKE_CURRENT_SOURCE_DIR}/op_commutative.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opland.c \n ${CMAKE_CURRENT_SOURCE_DIR}/oplor.c \n ${CMAKE_CURRENT_SOURCE_DIR}/oplxor.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opmax.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opmaxloc.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opmin.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opminloc.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opprod.c \n ${CMAKE_CURRENT_SOURCE_DIR}/opsum.c \n ${CMAKE_CURRENT_SOURCE_DIR}/red3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/red4.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscat2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscat3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscatbkinter.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscatblk3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/red_scat_block2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/red_scat_block.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscat.c \n ${CMAKE_CURRENT_SOURCE_DIR}/redscatinter.c \n ${CMAKE_CURRENT_SOURCE_DIR}/reduce.c \n ${CMAKE_CURRENT_SOURCE_DIR}/reduce_local.c \n ${CMAKE_CURRENT_SOURCE_DIR}/scantst.c \n ${CMAKE_CURRENT_SOURCE_DIR}/scatter2.c \n ${CMAKE_CURRENT_SOURCE_DIR}/scatter3.c \n ${CMAKE_CURRENT_SOURCE_DIR}/scattern.c \n ${CMAKE_CURRENT_SOURCE_DIR}/scatterv.c \n ${CMAKE_CURRENT_SOURCE_DIR}/uoplong.c \n  PARENT_SCOPE)\nset(txt_files  ${txt_files}  ${CMAKE_CURRENT_SOURCE_DIR}/testlist  PARENT_SCOPE)\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/teshsuite/smpi/privatization/privatization_dlopen.tesh": "p Test privatization with dlopen\n! setenv LD_LIBRARY_PATH=../../lib\n! timeout 5\n$ ${bindir:=.}/../../../smpi_script/bin/smpirun -hostfile ../hostfile -platform ../../../examples/platforms/small_platform.xml -np 32 ${bindir:=.}/privatization --log=smpi_kernel.thres:warning --log=xbt_cfg.thres:warning --cfg=smpi/privatization:dlopen --log=simix_context.thres:error\n> You requested to use 32 ranks, but there is only 5 processes in your hostfile...\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/tools/simgrid.supp": "# Valgrind suppressions for stuff that we cannot control\n\n# Memory leaks in standard tools (e.g. dash, tail, or sort)\n{\n   Memory leak in /bin tools\n   Memcheck:Leak\n   ...\n   obj:/bin/*\n}\n\n{\n   Memory leak in /usr/bin tools\n   Memcheck:Leak\n   ...\n   obj:/usr/bin/*\n}\n\n# There's a constant leak of 56 bytes in the depths of libc which\n# manifests, for example, when using backtrace()\n{\n   Memory leak in libc/dlopen with -pthread\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:do_dlopen\n   fun:_dl_catch_error\n   fun:dlerror_run\n   fun:__libc_dlopen_mode\n}\n\n# Another problem in glibc, where makecontext does not reset the EBP register,\n# and backtrace goes too far when walking up the stack frames\n{\n   Invalid read in backtrace, called after makecontext\n   Memcheck:Addr4\n   fun:backtrace\n   ...\n   fun:makecontext\n}\n\n#There seems to be an issue with libc using an uninitialized value somewhere in dlopen\n{\n   Invalid read in dl_start\n   Memcheck:Cond\n   fun:index\n   fun:expand_dynamic_string_token\n   ...\n   fun:_dl_start\n}\n\n# 72704 bytes leak from GCC >5.1 https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64535\n{\n   Memory leak in dl_init\n   Memcheck:Leak\n   match-leak-kinds:reachable\n   fun:malloc\n   obj:/usr/lib/*/libstdc++.so.*\n   fun:call_init.part.0\n   ...\n   fun:_dl_init\n}\n\n#Ignore leaks in SMPI sample codes\n{\n   Leaks in SMPI sample codes\n   Memcheck:Leak\n   match-leak-kinds: all\n   fun:malloc\n   fun:smpi_simulated_main_\n}\n\n#SMPI leaks the dlopen handle used for loading the program\n{\n   dlopen handle leaks (1/2)\n   Memcheck:Leak\n   match-leak-kinds:reachable\n   fun:malloc\n   ...\n   fun:dlopen@@GLIBC_*\n   ...\n   fun:main\n}\n\n{\n   dlopen handle leaks (2/2)\n   Memcheck:Leak\n   match-leak-kinds:reachable\n   fun:calloc\n   ...\n   fun:dlopen@@GLIBC_*\n   ...\n   fun:main\n}\n\n# Memory leaks appearing to be in libcgraph.  They can be seen with the\n# following simple program:\n# ,----\n# | #include <stdio.h>\n# | #include <graphviz/cgraph.h>\n# | int main(int argc, char *argv[])\n# | {\n# |     if (argc == 1) {\n# |         printf(\"Usage: %s <dotfile>\\n\", argv[0]);\n# |         return 1;\n# |     }\n# |     Agraph_t *g;\n# |     FILE *inf = fopen(argv[1], \"r\");\n# |     g = agread(inf, 0);\n# |     fclose(inf);\n# |     agclose(g);\n# |     return 0;\n# | }\n# `----\n{\n   Memory leak in libcgraph (1/2)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   obj:/usr/lib/libcgraph.so*\n   fun:aaglex\n   fun:aagparse\n   fun:agconcat\n}\n{\n   Memory leak in libcgraph (1/2)\n   Memcheck:Leak\n   fun:calloc\n   ...\n   obj:/usr/lib/libcgraph.so*\n   fun:aagparse\n   fun:agconcat\n}\n{\n   Memory leak in libcgraph (2/2)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:agnode\n   obj:/usr/lib/libcgraph.so*\n   fun:aagparse\n   fun:agconcat\n}\n\n# We're not interested by memory leaks in the Lua interpreter\n{\n   Memory leak in lua\n   Memcheck:Leak\n   ...\n   fun:luaD_precall\n}\n\n# libunwind seems to be using msync poorly, thus triggering these\n# https://github.com/JuliaLang/julia/issues/4533\n{\n   msync unwind\n   Memcheck:Param\n   msync(start)\n   ...\n   obj:*/libpthread*.so\n   ...\n}\n\n{\n   ignore unwind cruft \n   Memcheck:Param\n   rt_sigprocmask(set)\n   ...\n   obj:/usr/lib/x86_64-linux-gnu/libunwind.so.*\n   ...\n}\n{\n   ignore unwind cruft \n   Memcheck:Param\n   msync(start)\n   ...\n   obj:/usr/lib/x86_64-linux-gnu/libunwind.so.*\n   ...\n}\n \n{\n   ignore unwind invalid reads \n   Memcheck:Addr8\n   fun:_Ux86_64_setcontext\n}\n\n# Java cruft\n{\n  JavaCruft 1\n  Memcheck:Addr4\n  ...\n  fun:_ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread\n  fun:JVM_DoPrivileged\n  ...\n}\n{\n   JavaCruft 2\n   Memcheck:Cond\n   ...\n   fun:_ZN13CompileBroker25invoke_compiler_on_methodEP11CompileTask\n   ...\n}\n\n{\n   Somewhere within the Java conditions and monitors\n   Memcheck:Cond\n   fun:MarsagliaXORV\n   ...\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/doxygen/FAQ.doc": "/*! \\page FAQ Frequently Asked Questions\n\n@tableofcontents\n\n\\section faq_simgrid I'm new to SimGrid. I have some questions. Where should I start?\n\nYou are at the right place... To understand what you can do or\ncannot do with SimGrid, you should read the\n<a href=\"http://simgrid.gforge.inria.fr/tutorials.php\">tutorial\nslides</a> from the SimGrid's website. You may find more uptodate\nmaterial on the\n<a href=\"http://people.irisa.fr/Martin.Quinson/blog/SimGrid/\">blog of\nMartin Quinson</a>. \n\nAnother great source of inspiration can be found in the \\ref msg_examples.\n\nIf you are stuck at any point and if this FAQ cannot help you, please drop us a\nmail to the user mailing list: <simgrid-user@lists.gforge.inria.fr>.\n\n\\subsection faq_interfaces What is the difference between MSG and SimDag? Do they serve the same purpose?\n\nIt depend on how you define \"purpose\", I guess ;)\n\nThey all allow you to build a prototype of application which you can run\nwithin the simulator afterward. They all share the same simulation kernel,\nwhich is the core of the SimGrid project. They differ by the way you express\nyour application.\n\nWith SimDag, you express your code as a collection of interdependent\nparallel tasks. So, in this model, applications can be seen as a DAG of\ntasks. This is the interface of choice for people wanting to port old\ncode designed for SimGrid v1 or v2 to the framework current version.\n\nWith MSG, your application is seen as a set of communicating\nprocesses, exchanging data by the way of messages and performing\ncomputation on their own.\n\n\\subsection faq_visualization Visualizing and analyzing the results\n\nIt is sometime convenient to \"see\" how the agents are behaving. If you\nlike colors, you can use <tt>tools/MSG_visualization/colorize.pl </tt>\nas a filter to your MSG outputs. It works directly with INFO. Beware,\nINFO() prints on stderr. Do not forget to redirect if you want to\nfilter (e.g. with bash):\n\\verbatim\n./msg_test small_platform.xml small_deployment.xml 2>&1 | ../../tools/MSG_visualization/colorize.pl\n\\endverbatim\n\nWe also have a more graphical output. Have a look at section \\ref options_tracing.\n\n\\subsection faq_C Argh! Do I really have to code in C?\n\nWe provide Java bindings of the MSG interface, which is the main\nSimGrid user API.\n\nMoreover If you use C++, you should be able to use the SimGrid library\nas a standard C library and everything should work fine (simply\n<i>link</i> against this library; recompiling SimGrid with a C++\ncompiler won't work and it wouldn't help if you could).\n\nFor now, we do not feel a real demand for any other language. But if\nyou think there is one, please speak up!\n\n\\section faq_howto Feature related questions\n\n\\subsection faq_MIA \"Could you please add (your favorite feature here) to SimGrid?\"\n\nHere is the deal. The whole SimGrid project (MSG, SURF, ...) is\nmeant to be kept as simple and generic as possible. We cannot add\nfunctions for everybody's needs when these functions can easily be\nbuilt from the ones already in the API. Most of the time, it is\npossible and when it was not possible we always have upgraded the API\naccordingly. When somebody asks us a question like \"How to do that?\nIs there a function in the API to simply do this?\", we're always glad\nto answer and help. However if we don't need this code for our own\nneed, there is no chance we're going to write it... it's your job! :)\nThe counterpart to our answers is that once you come up with a neat\nimplementation of this feature (task duplication, RPC, thread\nsynchronization, ...), you should send it to us and we will be glad to\nadd it to the distribution. Thus, other people will take advantage of\nit (and we don't have to answer this question again and again ;).\n\nYou'll find in this section a few \"Missing In Action\" features. Many\npeople have asked about it and we have given hints on how to simply do\nit with MSG. Feel free to contribute...\n\n\\subsection faq_MIA_MSG MSG features\n\n\\subsubsection faq_MIA_examples I want some more complex MSG examples!\n\nMany people have come to ask me a more complex example and each time,\nthey have realized afterward that the basics were in the previous three\nexamples.\n\nOf course they have often been needing more complex functions like\nMSG_process_suspend(), MSG_process_resume() and\nMSG_process_isSuspended() (to perform synchronization), or\nMSG_task_Iprobe() and MSG_process_sleep() (to avoid blocking\nreceptions), or even MSG_process_create() (to design asynchronous\ncommunications or computations). But the examples are sufficient to\nstart.\n\nWe know. We should add some more examples, but not really some more\ncomplex ones... We should add some examples that illustrate some other\nfunctionalists (like how to simply encode asynchronous\ncommunications, RPC, process migrations, thread synchronization, ...)\nand we will do it when we will have a little bit more time. We have\ntried to document the examples so that they are understandable. Tell\nus if something is not clear and once again feel free to participate!\n:)\n\n\\subsubsection faq_MIA_taskdup Missing in action: MSG Task duplication/replication\n\nThere is no task duplication in MSG. When you create a task, you can\nprocess it or send it somewhere else. As soon as a process has sent\nthis task, he doesn't have this task anymore. It's gone. The receiver\nprocess has got the task. However, you could decide upon receiving to\ncreate a \"copy\" of a task but you have to handle by yourself the\nsemantic associated to this \"duplication\".\n\nAs we already told, we prefer keeping the API as simple as\npossible. This kind of feature is rather easy to implement by users\nand the semantic you associate really depends on people. Having a\n*generic* task duplication mechanism is not that trivial (in\nparticular because of the data field). That is why I would recommend\nthat you write it by yourself even if I can give you advice on how to\ndo it.\n\nYou have the following functions to get information about a task:\nMSG_task_get_name(), MSG_task_get_compute_duration(),\nMSG_task_get_remaining_computation(), MSG_task_get_data_size(),\nand MSG_task_get_data().\n\nYou could use a dictionary (#xbt_dict_t) of dynars (#xbt_dynar_t). If\nyou still don't see how to do it, please come back to us...\n\n\\subsubsection faq_MIA_asynchronous I want to do asynchronous communications in MSG\n\nYou are probably looking for the following functions:\nMSG_task_isend() and MSG_task_irecv(); \nMSG_comm_test(), MSG_comm_wait(), MSG_comm_waitall() and MSG_comm_waitany();\nMSG_comm_destroy(). \n\nThere is even a specific example section on \\ref msg_ex_async .\n\n\\subsubsection faq_MIA_thread_synchronization How to synchronize my user processes?\n\nIt depends on why you want to synchronize them.  If you just want to\nhave a shared state between your processes, then you probably don't\nneed to do anything. User processes never get forcefully interrupted\nin SimGrid (unless you explicitly request the parallel execution of\nuser processes -- see @ref options_virt_parallel).\n\nEven if several processes are executed at the exact same time within\nthe simulation, they are linearized in reality by default: one process\nalways run in an exclusive manner, atomic, uninterrupted until it does\na simcall (until it ask a service from the simulation kernel). This is\nsurprising at first, but things are much easier this way, both for the\nuser (who don't have to protect her shared data) and for the kernel\n(that avoid many synchronization issues too). Processes are executed\nconcurrently in the simulated realm, but you don't need to bother with\nthis in the real realm.\n\nIf you really need to synchronize your processes (because it's what\nyou are studying or to create an atomic section that spans over\nseveral simcalls), you obviously cannot use regular synchronization\nmechanisms (pthread_mutexes in C or the synchronized keyword in Java).\nThis is because the SimGrid kernel locks all processes and unlock them\none after the other when they are supposed to run, until they give the\ncontrol back in their simcall. If one of them gets locked by the OS \nbefore returning the control to the kernel, that's definitively a\ndeadlock.\n\nInstead, you should use the synchronization mechanism provided by the\nsimulation kernel. This could with a SimGrid mutex, a SimGrid\ncondition variables or a SimGrid semaphore, as described in @ref\nmsg_synchro (in Java, only semaphores are available). But actually,\nmany synchronization patterns can be encoded with communication on\nmailboxes. Typically, if you need one process to notify another one,\nyou could use a condition variable or a semphore, but sending a\nmessage to a specific mailbox does the trick in most cases.\n\n\\subsubsection faq_MIA_host_load Where is the get_host_load function hidden in MSG?\n\nThere is no such thing because its semantic wouldn't be really\nclear. Of course, it is something about the amount of host throughput,\nbut there is as many definition of \"host load\" as people asking for\nthis function. First, you have to remember that resource availability\nmay vary over time, which make any load notion harder to define.\n\nIt may be instantaneous value or an average one. Moreover it may be only the\npower of the computer, or may take the background load into account, or may\neven take the currently running tasks into account. In some SURF models,\ncommunications have an influence on computational power. Should it be taken\ninto account too?\n\nFirst of all, it's near to impossible to predict the load beforehand in the\nsimulator since it depends on too much parameters (background load\nvariation, bandwidth sharing algorithmic complexity) some of them even being\nnot known beforehand (other task starting at the same time). So, getting\nthis information is really hard (just like in real life). It's not just that\nwe want MSG to be as painful as real life. But as it is in some way\nrealistic, we face some of the same problems as we would face in real life.\n\nHow would you do it for real? The most common option is to use something\nlike NWS that performs active probes. The best solution is probably to do\nthe same within MSG, as in next code snippet. It is very close from what you\nwould have to do out of the simulator, and thus gives you information that\nyou could also get in real settings to not hinder the realism of your\nsimulation.\n\n\\code\ndouble get_host_load() {\n   m_task_t task = MSG_task_create(\"test\", 0.001, 0, NULL);\n   double date = MSG_get_clock();\n\n   MSG_task_execute(task);\n   date = MSG_get_clock() - date;\n   MSG_task_destroy(task);\n   return (0.001/date);\n}\n\\endcode\n\nOf course, it may not match your personal definition of \"host load\". In this\ncase, please detail what you mean on the mailing list, and we will extend\nthis FAQ section to fit your taste if possible.\n\n\\subsubsection faq_MIA_communication_time How can I get the *real* communication time?\n\nCommunications are synchronous and thus if you simply get the time\nbefore and after a communication, you'll only get the transmission\ntime and the time spent to really communicate (it will also take into\naccount the time spent waiting for the other party to be\nready). However, getting the *real* communication time is not really\nhard either. The following solution is a good starting point.\n\n\\code\nint sender()\n{\n  m_task_t task = MSG_task_create(\"Task\", task_comp_size, task_comm_size,\n                                  calloc(1,sizeof(double)));\n  *((double*) task->data) = MSG_get_clock();\n  MSG_task_put(task, slaves[i % slaves_count], PORT_22);\n  XBT_INFO(\"Send completed\");\n  return 0;\n}\nint receiver()\n{\n  m_task_t task = NULL;\n  double time1,time2;\n\n  time1 = MSG_get_clock();\n  a = MSG_task_get(&(task), PORT_22);\n  time2 = MSG_get_clock();\n  if(time1<*((double *)task->data))\n     time1 = *((double *) task->data);\n  XBT_INFO(\"Communication time :  \\\"%f\\\" \", time2-time1);\n  free(task->data);\n  MSG_task_destroy(task);\n  return 0;\n}\n\\endcode\n\n\\subsection faq_MIA_SimDag SimDag related questions\n\n\\subsubsection faq_SG_comm Implementing communication delays between tasks.\n\nA classic question of SimDag newcomers is about how to express a\ncommunication delay between tasks. The thing is that in SimDag, both\ncomputation and communication are seen as tasks.  So, if you want to\nmodel a data dependency between two DAG tasks t1 and t2, you have to\ncreate 3 SD_tasks: t1, t2 and c and add dependencies in the following\nway:\n\n\\code\nSD_task_dependency_add(NULL, NULL, t1, c);\nSD_task_dependency_add(NULL, NULL, c, t2);\n\\endcode\n\nThis way task t2 cannot start before the termination of communication c\nwhich in turn cannot start before t1 ends.\n\nWhen creating task c, you have to associate an amount of data (in bytes)\ncorresponding to what has to be sent by t1 to t2.\n\nFinally to schedule the communication task c, you have to build a list\ncomprising the workstations on which t1 and t2 are scheduled (w1 and w2\nfor example) and build a communication matrix that should look like\n[0;amount ; 0; 0].\n\n\\subsubsection faq_SG_DAG How to implement a distributed dynamic scheduler of DAGs.\n\nDistributed is somehow \"contagious\". If you start making distributed\ndecisions, there is no way to handle DAGs directly anymore (unless I\nam missing something). You have to encode your DAGs in term of\ncommunicating process to make the whole scheduling process\ndistributed. Here is an example of how you could do that. Assume T1\nhas to be done before T2.\n\n\\code\n int your_agent(int argc, char *argv[] {\n   ...\n   T1 = MSG_task_create(...);\n   T2 = MSG_task_create(...);\n   ...\n   while(1) {\n     ...\n     if(cond) MSG_task_execute(T1);\n     ...\n     if((MSG_task_get_remaining_computation(T1)=0.0) && (you_re_in_a_good_mood))\n        MSG_task_execute(T2)\n     else {\n        /* do something else */\n     }\n   }\n }\n\\endcode\n\nIf you decide that the distributed part is not that much important and that\nDAG is really the level of abstraction you want to work with, then you should\ngive a try to \\ref SD_API.\n\n\\subsection faq_MIA_generic Generic features\n\n\\subsubsection faq_MIA_batch_scheduler Is there a native support for batch schedulers in SimGrid?\n\nNo, there is no native support for batch schedulers and none is\nplanned because this is a very specific need (and doing it in a\ngeneric way is thus very hard). However some people have implemented\ntheir own batch schedulers. Vincent Garonne wrote one during his PhD\nand put his code in the contrib directory of our SVN so that other can\nkeep working on it. You may find inspiring ideas in it.\n\n\\subsubsection faq_MIA_checkpointing I need a checkpointing thing\n\nActually, it depends on whether you want to checkpoint the simulation, or to\nsimulate checkpoints.\n\nThe first one could help if your simulation is a long standing process you\nwant to keep running even on hardware issues. It could also help to\n<i>rewind</i> the simulation by jumping sometimes on an old checkpoint to\ncancel recent calculations.\\n\nUnfortunately, such thing will probably never exist in SG. One would have to\nduplicate all data structures because doing a rewind at the simulator level\nis very very hard (not talking about the malloc free operations that might\nhave been done in between). Instead, you may be interested in the Libckpt\nlibrary (http://www.cs.utk.edu/~plank/plank/www/libckpt.html). This is the\ncheckpointing solution used in the condor project, for example. It makes it\neasy to create checkpoints (at the OS level, creating something like core\nfiles), and rerunning them on need.\n\nIf you want to simulate checkpoints instead, it means that you want the\nstate of an executing task (in particular, the progress made towards\ncompletion) to be saved somewhere.  So if a host (and the task executing on\nit) fails (cf. #MSG_HOST_FAILURE), then the task can be restarted\nfrom the last checkpoint.\\n\n\nActually, such a thing does not exist in SimGrid either, but it's just\nbecause we don't think it is fundamental and it may be done in the user code\nat relatively low cost. You could for example use a watcher that\nperiodically get the remaining amount of things to do (using\nMSG_task_get_remaining_computation()), or fragment the task in smaller\nsubtasks.\n\n\\subsection faq_platform Platform building and Dynamic resources\n\n\\subsubsection faq_platform_example Where can I find SimGrid platform files?\n\nThere are several little examples in the archive, in the examples/msg\ndirectory. From time to time, we are asked for other files, but we\ndon't have much at hand right now.\n\nYou should refer to the Platform Description Archive\n(http://pda.gforge.inria.fr) project to see the other platform file we\nhave available, as well as the Simulacrum simulator, meant to generate\nSimGrid platforms using all classical generation algorithms.\n\n\\subsubsection faq_platform_alnem How can I automatically map an existing platform?\n\nWe are working on a project called ALNeM (Application-Level Network\nMapper) which goal is to automatically discover the topology of an\nexisting network. Its output will be a platform description file\nfollowing the SimGrid syntax, so everybody will get the ability to map\ntheir own lab network (and contribute them to the catalog project).\nThis tool is not ready yet, but it move quite fast forward. Just stay\ntuned.\n\n\\subsubsection faq_platform_synthetic Generating synthetic but realistic platforms\n\nThe third possibility to get a platform file (after manual or\nautomatic mapping of real platforms) is to generate synthetic\nplatforms. Getting a realistic result is not a trivial task, and\nmoreover, nobody is really able to define what \"realistic\" means when\nspeaking of topology files. You can find some more thoughts on this\ntopic in these\n<a href=\"http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf\">slides</a>.\n\nIf you are looking for an actual tool, there we have a little tool to\nannotate Tiers-generated topologies. This perl-script is in\n<tt>tools/platform_generation/</tt> directory of the SVN. Dinda et Al.\nreleased a very comparable tool, and called it GridG.\n\n\nThe specified computing power will be available to up to 6 sequential\ntasks without sharing. If more tasks are placed on this host, the\nresource will be shared accordingly. For example, if you schedule 12\ntasks on the host, each will get half of the computing power. Please\nnote that although sound, this model were never scientifically\nassessed. Please keep this fact in mind when using it.\n\n\n\\subsubsection faq_platform_random Using random variable for the resource power or availability\n\nThe best way to model the resouce power using a random variable is to\nuse an availability trace that is directed by a probability\ndistribution. This can be done using the function\ntmgr_trace_generator_value() below. The date and value generators is\ncreated with one of tmgr_event_generator_new_uniform(),\ntmgr_event_generator_new_exponential() or\ntmgr_event_generator_new_weibull() (if you need other generators,\nadding them to src/surf/trace_mgr.c should be quite trivial and your\npatch will be welcomed). Once your trace is created, you have to\nconnect it to the resource with the function\nsg_platf_new_trace_connect().\n\nThat the process is very similar if you want to model the\nresource availability with a random variable (deciding whether it's\non/off instead of deciding its speed) using the function\ntmgr_trace_generator_state() or tmgr_trace_generator_avail_unavail()\ninstead of tmgr_trace_generator_value().\n\nUnfortunately, all this is currently lacking a proper documentation,\nand there is even no proper example of use. You'll thus have to check\nthe header file include/simgrid/platf.h and experiment a bit by\nyourself. The following code should be a good starting point, and\ncontributing a little clean example would be a good way to help the\nSimGrid project.\n\n@code\ntmgr_trace_generator_value(\"mytrace\",tmgr_event_generator_new_exponential(.5)\n                                     tmgr_event_generator_new_uniform(100000,9999999));\n\t\t\t\t     \nsg_platf_trace_connect_cbarg_t myconnect = SG_PLATF_TRACE_CONNECT_INITIALIZER;\nmyconnect.kind = SURF_TRACE_CONNECT_KIND_BANDWIDTH;\nmyconnect.trace = \"mytrace\";\nmyconnect.element = \"mylink\";\n\nsg_platf_trace_connect(myconnect);\n@endcode\n\n\\section faq_troubleshooting Troubleshooting\n\n\\subsection faq_trouble_changelog The feature X stopped to work after my last update \n\nI guess that you want to read the ChangeLog file, that always contains\nall the information that could be important to the users during the\nupgrade. Actually, you may want to read it (alongside with the NEWS\nfile that highlights the most important changes) even before you\nupgrade your copy of SimGrid, too.\n\nWe do our best to maintain the backward compatibility, but we\nsometimes have to fix the things that are too broken. If we happen to\nkill a feature that you were using, we are sorry. We think that you\nshould update to the new way of doing things, but if you can't afford\nit, that's ok. Just stick to the last version that were working for\nyou, and have a pleasant day.\n\n\\subsection faq_trouble_lib_compil SimGrid compilation and installation problems\n\n\\subsubsection faq_trouble_lib_config cmake fails!\n\nWe know only one reason for the configure to fail:\n\n - <b>You are using a broken build environment</b>\\n\n   Try updating your cmake version. If symptom is that the configury\n   magic complains about gcc not being able to build executables, you\n   are probably missing the libc6-dev package. Damn Ubuntu. \n\nIf you experience other kind of issue, please get in touch with us. We are\nalways interested in improving our portability to new systems.\n\n\\subsubsection faq_trouble_distcheck Dude! \"ctest\" fails on my machine!\n\nDon't assume we never run this target, because we do. Check\nhttp://cdash.inria.fr/CDash/index.php?project=Simgrid (click on\nprevious if there is no result for today: results are produced only by\n11am, French time) and\nhttps://buildd.debian.org/status/logs.php?pkg=simgrid if you don't believe us.\n\nIf it's failing on your machine in a way not experienced by the\nautobuilders above, please drop us a mail on the mailing list so that\nwe can check it out. Make sure to read \\ref faq_bugrepport before you\ndo so.\n\n\\subsection faq_trouble_compil User code compilation problems\n\n\\subsubsection faq_trouble_err_logcat \"gcc: _simgrid_this_log_category_does_not_exist__??? undeclared (first use in this function)\"\n\nThis is because you are using the log mechanism, but you didn't created\nany default category in this file. You should refer to \\ref XBT_log\nfor all the details, but you simply forgot to call one of\nXBT_LOG_NEW_DEFAULT_CATEGORY() or XBT_LOG_NEW_DEFAULT_SUBCATEGORY().\n\n\\subsubsection faq_trouble_pthreadstatic \"gcc: undefined reference to pthread_key_create\"\n\nThis indicates that one of the library SimGrid depends on (libpthread\nhere) was missing on the linking command line. Dependencies of\nlibsimgrid are expressed directly in the dynamic library, so it's\nquite impossible that you see this message when doing dynamic linking.\n\nIf you compile your code statically (and if you use a pthread version\nof SimGrid), you must absolutely\nspecify <tt>-lpthread</tt> on the linker command line. As usual, this should\ncome after <tt>-lsimgrid</tt> on this command line.\n\n\\subsection faq_trouble_errors Runtime error messages\n\n\\subsubsection faq_trouble_errors_big_fat_warning I'm told that my XML files are too old.\n\nThe format of the XML platform description files is sometimes\nimproved. For example, we decided to change the units used in SimGrid\nfrom MBytes, MFlops and seconds to Bytes, Flops and seconds to ease\npeople exchanging small messages. We also reworked the route\ndescriptions to allow more compact descriptions.\n\nThat is why the XML files are versionned using the 'version' attribute\nof the root tag. Currently, it should read:\n@verbatim\n  <platform version=\"4\">\n@endverbatim\n\nIf your files are too old, you can use the simgrid_update_xml.pl\nscript which can be found in the tools directory of the archive.\n\n\\subsection faq_trouble_debug Debugging SMPI applications\n\nIn order to debug SMPI programs, you can use the following options:\n\n- <b>-wrapper 'gdb --args'</b>: this option is used to use a wrapper\n  in order to call the SMPI process. Good candidates for this options\n  are \"gdb --args\", \"valgrind\", \"rr record\", \"strace\", etc;\n\n- <b>-foreground</b>: this options gives the debugger access to the terminal\n  which is needed in order to use an interactive debugger.\n\nBoth options are needed in order to run the SMPI process under GDB.\n\n\\subsection faq_trouble_valgrind Valgrind-related and other debugger issues\n\nIf you don't, you really should use valgrind to debug your code, it's\nalmost magic.\n\n\\subsubsection faq_trouble_vg_libc Valgrind spits tons of errors about backtraces!\n\nIt may happen that valgrind, the memory debugger beloved by any decent C\nprogrammer, spits tons of warnings like the following :\n\\verbatim ==8414== Conditional jump or move depends on uninitialised value(s)\n==8414==    at 0x400882D: (within /lib/ld-2.3.6.so)\n==8414==    by 0x414EDE9: (within /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)\n==8414==    by 0x414F937: _dl_open (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x4150F4C: (within /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)\n==8414==    by 0x415102D: __libc_dlopen_mode (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x412D6B9: backtrace (in /lib/tls/i686/cmov/libc-2.3.6.so)\n==8414==    by 0x8076446: xbt_dictelm_get_ext (dict_elm.c:714)\n==8414==    by 0x80764C1: xbt_dictelm_get (dict_elm.c:732)\n==8414==    by 0x8079010: xbt_cfg_register (config.c:208)\n==8414==    by 0x806821B: MSG_config (msg_config.c:42)\n\\endverbatim\n\nThis problem is somewhere in the libc when using the backtraces and there is\nvery few things we can do ourselves to fix it. Instead, here is how to tell\nvalgrind to ignore the error. Add the following to your ~/.valgrind.supp (or\ncreate this file on need). Make sure to change the obj line according to\nyour personnal mileage (change 2.3.6 to the actual version you are using,\nwhich you can retrieve with a simple \"ls /lib/ld*.so\").\n\n\\verbatim {\n   name: Backtrace madness\n   Memcheck:Cond\n   obj:/lib/ld-2.3.6.so\n   fun:dl_open_worker\n   fun:_dl_open\n   fun:do_dlopen\n   fun:dlerror_run\n   fun:__libc_dlopen_mode\n}\\endverbatim\n\nThen, you have to specify valgrind to use this suppression file by passing\nthe <tt>--suppressions=$HOME/.valgrind.supp</tt> option on the command line.\nYou can also add the following to your ~/.bashrc so that it gets passed\nautomatically. Actually, it passes a bit more options to valgrind, and this\nhappen to be my personnal settings. Check the valgrind documentation for\nmore information.\n\n\\verbatim export VALGRIND_OPTS=\"--leak-check=yes --leak-resolution=high --num-callers=40 --tool=memcheck --suppressions=$HOME/.valgrind.supp\" \\endverbatim\n\n\\subsubsection faq_trouble_backtraces Truncated backtraces\n\nWhen debugging SimGrid, it's easier to pass the\n--disable-compiler-optimization flag to the configure if valgrind or\ngdb get fooled by the optimization done by the compiler. But you\nshould remove these flag when everything works before going in\nproduction (before launching your 1252135 experiments), or everything\nwill run only one half of the true SimGrid potential.\n\n\\subsection faq_deadlock There is a deadlock in my code!!!\n\nUnfortunately, we cannot debug every code written in SimGrid.  We\nfurthermore believe that the framework provides ways enough\ninformation to debug such information yourself. If the textual output\nis not enough, Make sure to check the \\ref faq_visualization FAQ entry to see\nhow to get a graphical one.\n\nNow, if you come up with a really simple example that deadlocks and\nyou're absolutely convinced that it should not, you can ask on the\nlist. Just be aware that you'll be severely punished if the mistake is\non your side... We have plenty of FAQ entries to redact and new\nfeatures to implement for the impenitents! ;)\n\n\\subsection faq_surf_network_latency I get weird timings when I play with the latencies.\n\nOK, first of all, remember that units should be Bytes, Flops and\nSeconds. If you don't use such units, some SimGrid constants (e.g. the\nSG_TCP_CTE_GAMMA constant used in most network models) won't have the\nright unit and you'll end up with weird results.\n\nHere is what happens with a single transfer of size L on a link\n(bw,lat) when nothing else happens.\n\n\\verbatim\n0-----lat--------------------------------------------------t\n|-----|**** real_bw =min(bw,SG_TCP_CTE_GAMMA/(2*lat)) *****|\n\\endverbatim\n\nIn more complex situations, this min is the solution of a complex\nmax-min linear system.  Have a look\n<a href=\"http://lists.gforge.inria.fr/pipermail/simgrid-devel/2006-April/thread.html\">here</a>\nand read the two threads \"Bug in SURF?\" and \"Surf bug not\nfixed?\". You'll have a few other examples of such computations. You\ncan also read \"A Network Model for Simulation of Grid Application\" by\nHenri Casanova and Loris Marchal to have all the details. The fact\nthat the real_bw is smaller than bw is easy to understand. The fact\nthat real_bw is smaller than SG_TCP_CTE_GAMMA/(2*lat) is due to the\nwindow-based congestion mechanism of TCP. With TCP, you can't exploit\nyour huge network capacity if you don't have a good round-trip-time\nbecause of the acks...\n\nAnyway, what you get is t=lat + L/min(bw,SG_TCP_CTE_GAMMA/(2*lat)).\n\n  * if I you set (bw,lat)=(100 000 000, 0.00001), you get t =  1.00001 (you fully\nuse your link)\n  * if I you set (bw,lat)=(100 000 000, 0.0001),  you get t =  1.0001 (you're on the\nlimit)\n  * if I you set (bw,lat)=(100 000 000, 0.001),   you get t = 10.001  (ouch!)\n\nThis bound on the effective bandwidth of a flow is not the only thing\nthat may make your result be unexpected. For example, two flows\ncompeting on a saturated link receive an amount of bandwidth inversely\nproportional to their round trip time.\n\n\\subsection faq_bugrepport So I've found a bug in SimGrid. How to report it?\n\nWe do our best to make sure to hammer away any bugs of SimGrid, but this is\nstill an academic project so please be patient if/when you find bugs in it.\nIf you do, the best solution is to drop an email either on the simgrid-user\nor the simgrid-devel mailing list and explain us about the issue.  You can\nalso decide to open a formal bug report using the\n<a href=\"https://gforge.inria.fr/tracker/?atid=165&group_id=12&func=browse\">relevant\ninterface</a>. You need to login on the server to get the ability to submit\nbugs.\n\nWe will do our best to solve any problem repported, but you need to help us\nfinding the issue. Just telling \"it segfault\" isn't enough. Telling \"It\nsegfaults when running the attached simulator\" doesn't really help either.\nYou may find the following article interesting to see how to repport\ninformative bug repports:\nhttp://www.chiark.greenend.org.uk/~sgtatham/bugs.html (it is not SimGrid\nspecific at all, but it's full of good advices).\n\n\\author Da SimGrid team <simgrid-devel@lists.gforge.inria.fr>\n\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/doxygen/options.doc": "/*! \\page options Configure SimGrid\n\nA number of options can be given at runtime to change the default\nSimGrid behavior. For a complete list of all configuration options\naccepted by the SimGrid version used in your simulator, simply pass\nthe --help configuration flag to your program. If some of the options\nare not documented on this page, this is a bug that you should please\nreport so that we can fix it. Note that some of the options presented\nhere may not be available in your simulators, depending on the\n@ref install_src_config \"compile-time options\" that you used.\n\n\\tableofcontents\n\n\\section options_using Passing configuration options to the simulators\n\nThere is several way to pass configuration options to the simulators.\nThe most common way is to use the \\c --cfg command line argument. For\nexample, to set the item \\c Item to the value \\c Value, simply\ntype the following: \\verbatim\nmy_simulator --cfg=Item:Value (other arguments)\n\\endverbatim\n\nSeveral \\c `--cfg` command line arguments can naturally be used. If you\nneed to include spaces in the argument, don't forget to quote the\nargument. You can even escape the included quotes (write \\' for ' if\nyou have your argument between ').\n\nAnother solution is to use the \\c \\<config\\> tag in the platform file. The\nonly restriction is that this tag must occure before the first\nplatform element (be it \\c \\<AS\\>, \\c \\<cluster\\>, \\c \\<peer\\> or whatever).\nThe \\c \\<config\\> tag takes an \\c id attribute, but it is currently\nignored so you don't really need to pass it. The important par is that\nwithin that tag, you can pass one or several \\c \\<prop\\> tags to specify\nthe configuration to use. For example, setting \\c Item to \\c Value\ncan be done by adding the following to the beginning of your platform\nfile:\n\\verbatim\n<config>\n  <prop id=\"Item\" value=\"Value\"/>\n</config>\n\\endverbatim\n\nA last solution is to pass your configuration directly using the C\ninterface. If you happen to use the MSG interface, this is very easy\nwith the MSG_config() function. If you do not use MSG, that's a bit\nmore complex, as you have to mess with the internal configuration set\ndirectly as follows. Check the \\ref XBT_config \"relevant page\" for\ndetails on all the functions you can use in this context, \\c\n_sg_cfg_set being the only configuration set currently used in\nSimGrid.\n\n@code\n#include <xbt/config.h>\n\nint main(int argc, char *argv[]) {\n     SD_init(&argc, argv);\n\n     /* Prefer MSG_config() if you use MSG!! */\n     xbt_cfg_set_parse(\"Item:Value\");\n\n     // Rest of your code\n}\n@endcode\n\n\\section options_index Index of all existing configuration options\n\n\\note\n  The full list can be retrieved by passing \"--help\" and\n     \"--help-cfg\" to an executable that uses SimGrid.\n\n- \\c clean-atexit: \\ref options_generic_clean_atexit\n\n- \\c contexts/factory: \\ref options_virt_factory\n- \\c contexts/guard-size: \\ref options_virt_guard_size\n- \\c contexts/nthreads: \\ref options_virt_parallel\n- \\c contexts/parallel_threshold: \\ref options_virt_parallel\n- \\c contexts/stack-size: \\ref options_virt_stacksize\n- \\c contexts/synchro: \\ref options_virt_parallel\n\n- \\c cpu/maxmin-selective-update: \\ref options_model_optim\n- \\c cpu/model: \\ref options_model_select\n- \\c cpu/optim: \\ref options_model_optim\n\n- \\c exception/cutpath: \\ref options_exception_cutpath\n\n- \\c host/model: \\ref options_model_select\n\n- \\c maxmin/precision: \\ref options_model_precision\n- \\c maxmin/concurrency-limit: \\ref options_concurrency_limit\n\n- \\c msg/debug-multiple-use: \\ref options_msg_debug_multiple_use\n\n- \\c model-check: \\ref options_modelchecking\n- \\c model-check/checkpoint: \\ref options_modelchecking_steps\n- \\c model-check/communications-determinism: \\ref options_modelchecking_comm_determinism\n- \\c model-check/dot-output: \\ref options_modelchecking_dot_output\n- \\c model-check/hash: \\ref options_modelchecking_hash\n- \\c model-check/property: \\ref options_modelchecking_liveness\n- \\c model-check/max-depth: \\ref options_modelchecking_max_depth\n- \\c model-check/record: \\ref options_modelchecking_recordreplay\n- \\c model-check/reduction: \\ref options_modelchecking_reduction\n- \\c model-check/replay: \\ref options_modelchecking_recordreplay\n- \\c model-check/send-determinism: \\ref options_modelchecking_comm_determinism\n- \\c model-check/sparse-checkpoint: \\ref options_modelchecking_sparse_checkpoint\n- \\c model-check/termination: \\ref options_modelchecking_termination\n- \\c model-check/timeout: \\ref options_modelchecking_timeout\n- \\c model-check/visited: \\ref options_modelchecking_visited\n\n- \\c network/bandwidth-factor: \\ref options_model_network_coefs\n- \\c network/crosstraffic: \\ref options_model_network_crosstraffic\n- \\c network/latency-factor: \\ref options_model_network_coefs\n- \\c network/maxmin-selective-update: \\ref options_model_optim\n- \\c network/model: \\ref options_model_select\n- \\c network/optim: \\ref options_model_optim\n- \\c network/sender_gap: \\ref options_model_network_sendergap\n- \\c network/TCP-gamma: \\ref options_model_network_gamma\n- \\c network/weight-S: \\ref options_model_network_coefs\n\n- \\c ns3/TcpModel: \\ref options_pls\n- \\c path: \\ref options_generic_path\n- \\c plugin: \\ref options_generic_plugin\n\n- \\c storage/max_file_descriptors: \\ref option_model_storage_maxfd\n\n- \\c surf/precision: \\ref options_model_precision\n\n- \\c <b>For collective operations of SMPI, please refer to Section \\ref options_index_smpi_coll</b>\n- \\c smpi/async-small-thresh: \\ref options_model_network_asyncsend\n- \\c smpi/bw-factor: \\ref options_model_smpi_bw_factor\n- \\c smpi/coll-selector: \\ref options_model_smpi_collectives\n- \\c smpi/comp-adjustment-file: \\ref options_model_smpi_adj_file\n- \\c smpi/cpu-threshold: \\ref options_smpi_bench\n- \\c smpi/display-timing: \\ref options_smpi_timing\n- \\c smpi/grow-injected-times: \\ref options_model_smpi_test\n- \\c smpi/host-speed: \\ref options_smpi_bench\n- \\c smpi/IB-penalty-factors: \\ref options_model_network_coefs\n- \\c smpi/iprobe: \\ref options_model_smpi_iprobe\n- \\c smpi/iprobe-cpu-usage: \\ref options_model_smpi_iprobe_cpu_usage\n- \\c smpi/init: \\ref options_model_smpi_init\n- \\c smpi/keep-temps: \\ref options_smpi_temps\n- \\c smpi/lat-factor: \\ref options_model_smpi_lat_factor\n- \\c smpi/ois: \\ref options_model_smpi_ois\n- \\c smpi/or: \\ref options_model_smpi_or\n- \\c smpi/os: \\ref options_model_smpi_os\n- \\c smpi/papi-events: \\ref options_smpi_papi_events\n- \\c smpi/privatization: \\ref options_smpi_privatization\n- \\c smpi/send-is-detached-thresh: \\ref options_model_smpi_detached\n- \\c smpi/shared-malloc: \\ref options_model_smpi_shared_malloc\n- \\c smpi/shared-malloc-hugepage: \\ref options_model_smpi_shared_malloc\n- \\c smpi/simulate-computation: \\ref options_smpi_bench\n- \\c smpi/test: \\ref options_model_smpi_test\n- \\c smpi/wtime: \\ref options_model_smpi_wtime\n\n- \\c <b>Tracing configuration options can be found in Section \\ref tracing_tracing_options</b>.\n\n- \\c storage/model: \\ref options_storage_model\n- \\c verbose-exit: \\ref options_generic_exit\n\n- \\c vm/model: \\ref options_vm_model\n\n\\subsection options_index_smpi_coll Index of SMPI collective algorithms options\n\nTODO: All available collective algorithms will be made available via the ``smpirun --help-coll`` command.\n\n\\section options_model Configuring the platform models\n\n\\anchor options_storage_model\n\\anchor options_vm_model\n\\subsection options_model_select Selecting the platform models\n\nSimGrid comes with several network, CPU and storage models built in, and you\ncan change the used model at runtime by changing the passed\nconfiguration. The three main configuration items are given below.\nFor each of these items, passing the special \\c help value gives\nyou a short description of all possible values. Also, \\c --help-models\nshould provide information about all models for all existing resources.\n   - \\b network/model: specify the used network model\n   - \\b cpu/model: specify the used CPU model\n   - \\b host/model: specify the used host model\n   - \\b storage/model: specify the used storage model (there is currently only one such model - this option is hence only useful for future releases)\n   - \\b vm/model: specify the model for virtual machines (there is currently only one such model - this option is hence only useful for future releases)\n\nAs of writing, the following network models are accepted. Over\nthe time new models can be added, and some experimental models can be\nremoved; check the values on your simulators for an uptodate\ninformation. Note that the CM02 model is described in the research report\n<a href=\"ftp://ftp.ens-lyon.fr/pub/LIP/Rapports/RR/RR2002/RR2002-40.ps.gz\">A\nNetwork Model for Simulation of Grid Application</a> while LV08 is\ndescribed in\n<a href=\"http://mescal.imag.fr/membres/arnaud.legrand/articles/simutools09.pdf\">Accuracy Study and Improvement of Network Simulation in the SimGrid Framework</a>.\n\n  - \\b LV08 (default one): Realistic network analytic model\n    (slow-start modeled by multiplying latency by 10.4, bandwidth by\n    .92; bottleneck sharing uses a payload of S=8775 for evaluating RTT)\n  - \\anchor options_model_select_network_constant \\b Constant: Simplistic network model where all communication\n    take a constant time (one second). This model provides the lowest\n    realism, but is (marginally) faster.\n  - \\b SMPI: Realistic network model specifically tailored for HPC\n    settings (accurate modeling of slow start with correction factors on\n    three intervals: < 1KiB, < 64 KiB, >= 64 KiB). See also \\ref\n    options_model_network_coefs \"this section\" for more info.\n  - \\b IB: Realistic network model specifically tailored for HPC\n    settings with InfiniBand networks (accurate modeling contention\n    behavior, based on the model explained in\n    http://mescal.imag.fr/membres/jean-marc.vincent/index.html/PhD/Vienne.pdf).\n    See also \\ref options_model_network_coefs \"this section\" for more info.\n  - \\b CM02: Legacy network analytic model (Very similar to LV08, but\n    without corrective factors. The timings of small messages are thus\n    poorly modeled)\n  - \\b Reno: Model from Steven H. Low using lagrange_solve instead of\n    lmm_solve (experts only; check the code for more info).\n  - \\b Reno2: Model from Steven H. Low using lagrange_solve instead of\n    lmm_solve (experts only; check the code for more info).\n  - \\b Vegas: Model from Steven H. Low using lagrange_solve instead of\n    lmm_solve (experts only; check the code for more info).\n\nIf you compiled SimGrid accordingly, you can use packet-level network\nsimulators as network models (see \\ref pls_ns3). In that case, you have\ntwo extra models, described below, and some \n\\ref options_pls \"specific additional configuration flags\".\n  - \\b NS3: Network pseudo-model using the NS3 tcp model\n\nConcerning the CPU, we have only one model for now:\n  - \\b Cas01: Simplistic CPU model (time=size/power)\n\nThe host concept is the aggregation of a CPU with a network\ncard. Three models exists, but actually, only 2 of them are\ninteresting. The \"compound\" one is simply due to the way our internal\ncode is organized, and can easily be ignored. So at the end, you have\ntwo host models: The default one allows to aggregate an\nexisting CPU model with an existing network model, but does not allow\nparallel tasks because these beasts need some collaboration between\nthe network and CPU model. That is why, ptask_07 is used by default\nwhen using SimDag.\n  - \\b default: Default host model. Currently, CPU:Cas01 and\n    network:LV08 (with cross traffic enabled)\n  - \\b compound: Host model that is automatically chosen if\n    you change the network and CPU models\n  - \\b ptask_L07: Host model somehow similar to Cas01+CM02 but\n    allowing \"parallel tasks\", that are intended to model the moldable\n    tasks of the grid scheduling literature.\n\n\\subsection options_generic_plugin Plugins\n\nSimGrid supports the use of plugins; currently, no known plugins\ncan be activated but there are use-cases where you may want to write\nyour own plugin (for instance, for logging).\n\nPlugins can for instance define own classes that inherit from\nexisting classes (for instance, a class \"CpuEnergy\" inherits from\n\"Cpu\" to assess energy consumption).\n\nThe plugin connects to the code by registering callbacks using\n``signal.connect(callback)`` (see file ``src/surf/plugins/energy.cpp`` for\ndetails).\n\n\\verbatim\n    --cfg=plugin:Energy\n\\endverbatim\n\n\\note\n    This option is case-sensitive: Energy and energy are not the same!\n\n\\subsection options_model_optim Optimization level of the platform models\n\nThe network and CPU models that are based on lmm_solve (that\nis, all our analytical models) accept specific optimization\nconfigurations.\n  - items \\b network/optim and \\b cpu/optim (both default to 'Lazy'):\n    - \\b Lazy: Lazy action management (partial invalidation in lmm +\n      heap in action remaining).\n    - \\b TI: Trace integration. Highly optimized mode when using\n      availability traces (only available for the Cas01 CPU model for\n      now).\n    - \\b Full: Full update of remaining and variables. Slow but may be\n      useful when debugging.\n  - items \\b network/maxmin-selective-update and\n    \\b cpu/maxmin-selective-update: configure whether the underlying\n    should be lazily updated or not. It should have no impact on the\n    computed timings, but should speed up the computation.\n\nIt is still possible to disable the \\c maxmin-selective-update feature\nbecause it can reveal counter-productive in very specific scenarios\nwhere the interaction level is high. In particular, if all your\ncommunication share a given backbone link, you should disable it:\nwithout \\c maxmin-selective-update, every communications are updated\nat each step through a simple loop over them. With that feature\nenabled, every communications will still get updated in this case\n(because of the dependency induced by the backbone), but through a\ncomplicated pattern aiming at following the actual dependencies.\n\n\\subsection options_model_precision Numerical precision of the platform models\n\nThe analytical models handle a lot of floating point values. It is\npossible to change the epsilon used to update and compare them through\nthe \\b maxmin/precision item (default value: 0.00001). Changing it\nmay speedup the simulation by discarding very small actions, at the\nprice of a reduced numerical precision.\n\n\\subsection options_concurrency_limit Concurrency limit\n\nThe maximum number of variables per resource can be tuned through\nthe \\b maxmin/concurrency-limit item. The default value is -1, meaning that\nthere is no such limitation. You can have as many simultaneous actions per\nresources as you want. If your simulation presents a very high level of\nconcurrency, it may help to use e.g. 100 as a value here. It means that at\nmost 100 actions can consume a resource at a given time. The extraneous actions\nare queued and wait until the amount of concurrency of the considered resource\nlowers under the given boundary.\n\nSuch limitations help both to the simulation speed and simulation accuracy\non highly constrained scenarios, but the simulation speed suffers of this\nsetting on regular (less constrained) scenarios so it is off by default.\n\n\\subsection options_model_network Configuring the Network model\n\n\\subsubsection options_model_network_gamma Maximal TCP window size\n\nThe analytical models need to know the maximal TCP window size to take\nthe TCP congestion mechanism into account. This is set to 20000 by\ndefault, but can be changed using the \\b network/TCP-gamma item.\n\nOn linux, this value can be retrieved using the following\ncommands. Both give a set of values, and you should use the last one,\nwhich is the maximal size.\\verbatim\ncat /proc/sys/net/ipv4/tcp_rmem # gives the sender window\ncat /proc/sys/net/ipv4/tcp_wmem # gives the receiver window\n\\endverbatim\n\n\\subsubsection options_model_network_coefs Correcting important network parameters\n\nSimGrid can take network irregularities such as a slow startup or\nchanging behavior depending on the message size into account.\nYou should not change these values unless you really know what you're doing.\n\nThe corresponding values were computed through data fitting one the\ntimings of packet-level simulators.\n\nSee\n<a href=\"http://mescal.imag.fr/membres/arnaud.legrand/articles/simutools09.pdf\">Accuracy Study and Improvement of Network Simulation in the SimGrid Framework</a>\nfor more information about these parameters.\n\nIf you are using the SMPI model, these correction coefficients are\nthemselves corrected by constant values depending on the size of the\nexchange. Again, only hardcore experts should bother about this fact.\n\nInfiniBand network behavior can be modeled through 3 parameters, as explained in\n<a href=\"http://mescal.imag.fr/membres/jean-marc.vincent/index.html/PhD/Vienne.pdf\">this PhD thesis</a>.\nThese factors can be changed through the following option:\n\n\\verbatim\nsmpi/IB-penalty-factors:\"\u03b2e;\u03b2s;\u03b3s\"\n\\endverbatim\n\nBy default SMPI uses factors computed on the Stampede Supercomputer at TACC, with optimal\ndeployment of processes on nodes.\n\n\\subsubsection options_model_network_crosstraffic Simulating cross-traffic\n\nAs of SimGrid v3.7, cross-traffic effects can be taken into account in\nanalytical simulations. It means that ongoing and incoming\ncommunication flows are treated independently. In addition, the LV08\nmodel adds 0.05 of usage on the opposite direction for each new\ncreated flow. This can be useful to simulate some important TCP\nphenomena such as ack compression.\n\nFor that to work, your platform must have two links for each\npair of interconnected hosts. An example of usable platform is\navailable in <tt>examples/platforms/crosstraffic.xml</tt>.\n\nThis is activated through the \\b network/crosstraffic item, that\ncan be set to 0 (disable this feature) or 1 (enable it).\n\nNote that with the default host model this option is activated by default.\n\n\\subsubsection options_model_network_sendergap Simulating sender gap\n\n(this configuration item is experimental and may change or disapear)\n\nIt is possible to specify a timing gap between consecutive emission on\nthe same network card through the \\b network/sender-gap item. This\nis still under investigation as of writting, and the default value is\nto wait 10 microseconds (1e-5 seconds) between emissions.\n\n\\subsubsection options_model_network_asyncsend Simulating asyncronous send\n\n(this configuration item is experimental and may change or disapear)\n\nIt is possible to specify that messages below a certain size will be sent\nas soon as the call to MPI_Send is issued, without waiting for the\ncorrespondant receive. This threshold can be configured through the\n\\b smpi/async-small-thresh item. The default value is 0. This behavior can also be\nmanually set for MSG mailboxes, by setting the receiving mode of the mailbox\nwith a call to \\ref MSG_mailbox_set_async . For MSG, all messages sent to this\nmailbox will have this behavior, so consider using two mailboxes if needed.\n\nThis value needs to be smaller than or equals to the threshold set at\n\\ref options_model_smpi_detached , because asynchronous messages are\nmeant to be detached as well.\n\n\\subsubsection options_pls Configuring packet-level pseudo-models\n\nWhen using the packet-level pseudo-models, several specific\nconfiguration flags are provided to configure the associated tools.\nThere is by far not enough such SimGrid flags to cover every aspects\nof the associated tools, since we only added the items that we\nneeded ourselves. Feel free to request more items (or even better:\nprovide patches adding more items).\n\nWhen using NS3, the only existing item is \\b ns3/TcpModel,\ncorresponding to the ns3::TcpL4Protocol::SocketType configuration item\nin NS3. The only valid values (enforced on the SimGrid side) are\n'NewReno' or 'Reno' or 'Tahoe'.\n\n\\subsection options_model_storage Configuring the Storage model\n\n\\subsubsection option_model_storage_maxfd Maximum amount of file descriptors per host\n\nEach host maintains a fixed-size array of its file descriptors. You\ncan change its size (1024 by default) through the \\b\nstorage/max_file_descriptors item to either enlarge it if your\napplication requires it or to reduce it to save memory space.\n\n\\section options_modelchecking Configuring the Model-Checking\n\nTo enable the SimGrid model-checking support the program should\nbe executed using the simgrid-mc wrapper:\n\\verbatim\nsimgrid-mc ./my_program\n\\endverbatim\n\nSafety properties are expressed as assertions using the function\n\\verbatim\nvoid MC_assert(int prop);\n\\endverbatim\n\n\\subsection options_modelchecking_liveness Specifying a liveness property\n\nIf you want to specify liveness properties (beware, that's\nexperimental), you have to pass them on the command line, specifying\nthe name of the file containing the property, as formatted by the\nltl2ba program.\n\n\\verbatim\n--cfg=model-check/property:<filename>\n\\endverbatim\n\n\\subsection options_modelchecking_steps Going for stateful verification\n\nBy default, the system is backtracked to its initial state to explore\nanother path instead of backtracking to the exact step before the fork\nthat we want to explore (this is called stateless verification). This\nis done this way because saving intermediate states can rapidly\nexhaust the available memory. If you want, you can change the value of\nthe <tt>model-check/checkpoint</tt> variable. For example, the\nfollowing configuration will ask to take a checkpoint every step.\nBeware, this will certainly explode your memory. Larger values are\nprobably better, make sure to experiment a bit to find the right\nsetting for your specific system.\n\n\\verbatim\n--cfg=model-check/checkpoint:1\n\\endverbatim\n\n\\subsection options_modelchecking_reduction Specifying the kind of reduction\n\nThe main issue when using the model-checking is the state space\nexplosion. To counter that problem, several exploration reduction\ntechniques can be used. There is unfortunately no silver bullet here,\nand the most efficient reduction techniques cannot be applied to any\nproperties. In particular, the DPOR method cannot be applied on\nliveness properties since it may break some cycles in the exploration\nthat are important to the property validity.\n\n\\verbatim\n--cfg=model-check/reduction:<technique>\n\\endverbatim\n\nFor now, this configuration variable can take 2 values:\n * none: Do not apply any kind of reduction (mandatory for now for\n   liveness properties)\n * dpor: Apply Dynamic Partial Ordering Reduction. Only valid if you\n   verify local safety properties (default value for safety checks).\n\n\\subsection options_modelchecking_visited model-check/visited, Cycle detection\n\nIn order to detect cycles, the model-checker needs to check if a new explored\nstate is in fact the same state than a previous one. For that,\nthe model-checker can take a snapshot of each visited state: this snapshot is\nthen used to compare it with subsequent states in the exploration graph.\n\nThe \\b model-check/visited option is the maximum number of states which are stored in\nmemory. If the maximum number of snapshotted state is reached, some states will\nbe removed from the memory and some cycles might be missed. Small\nvalues can lead to incorrect verifications, but large value can\nexhaust your memory, so choose carefully.\n\nBy default, no state is snapshotted and cycles cannot be detected.\n\n\\subsection options_modelchecking_termination model-check/termination, Non termination detection\n\nThe \\b model-check/termination configuration item can be used to report if a\nnon-termination execution path has been found. This is a path with a cycle\nwhich means that the program might never terminate.\n\nThis only works in safety mode.\n\nThis options is disabled by default.\n\n\\subsection options_modelchecking_dot_output model-check/dot-output, Dot output\n\nIf set, the \\b model-check/dot-output configuration item is the name of a file\nin which to write a dot file of the path leading the found property (safety or\nliveness violation) as well as the cycle for liveness properties. This dot file\ncan then fed to the graphviz dot tool to generate an corresponding graphical\nrepresentation.\n\n\\subsection options_modelchecking_max_depth model-check/max_depth, Depth limit\n\nThe \\b model-checker/max-depth can set the maximum depth of the exploration\ngraph of the model-checker. If this limit is reached, a logging message is\nsent and the results might not be exact.\n\nBy default, there is not depth limit.\n\n\\subsection options_modelchecking_timeout Handling of timeout\n\nBy default, the model-checker does not handle timeout conditions: the `wait`\noperations never time out. With the \\b model-check/timeout configuration item\nset to \\b yes, the model-checker will explore timeouts of `wait` operations.\n\n\\subsection options_modelchecking_comm_determinism Communication determinism\n\nThe \\b model-check/communications-determinism and\n\\b model-check/send-determinism items can be used to select the communication\ndeterminism mode of the model-checker which checks determinism properties of\nthe communications of an application.\n\n\\subsection options_modelchecking_sparse_checkpoint Per page checkpoints\n\nWhen the model-checker is configured to take a snapshot of each explored state\n(with the \\b model-checker/visited item), the memory consumption can rapidly\nreach GiB ou Tib of memory. However, for many workloads, the memory does not\nchange much between different snapshots and taking a complete copy of each\nsnapshot is a waste of memory.\n\nThe \\b model-check/sparse-checkpoint option item can be set to \\b yes in order\nto avoid making a complete copy of each snapshot: instead, each snapshot will be\ndecomposed in blocks which will be stored separately.\nIf multiple snapshots share the same block (or if the same block\nis used in the same snapshot), the same copy of the block will be shared leading\nto a reduction of the memory footprint.\n\nFor many applications, this option considerably reduces the memory consumption.\nIn somes cases, the model-checker might be slightly slower because of the time\ntaken to manage the metadata about the blocks. In other cases however, this\nsnapshotting strategy will be much faster by reducing the cache consumption.\nWhen the memory consumption is important, by avoiding to hit the swap or\nreducing the swap usage, this option might be much faster than the basic\nsnapshotting strategy.\n\nThis option is currently disabled by default.\n\n\\subsection options_mc_perf Performance considerations for the model checker\n\nThe size of the stacks can have a huge impact on the memory\nconsumption when using model-checking. By default, each snapshot will\nsave a copy of the whole stacks and not only of the part which is\nreally meaningful: you should expect the contribution of the memory\nconsumption of the snapshots to be \\f$ \\mbox{number of processes}\n\\times \\mbox{stack size} \\times \\mbox{number of states} \\f$.\n\nThe \\b model-check/sparse-checkpoint can be used to reduce the memory\nconsumption by trying to share memory between the different snapshots.\n\nWhen compiled against the model checker, the stacks are not\nprotected with guards: if the stack size is too small for your\napplication, the stack will silently overflow on other parts of the\nmemory (see \\ref options_virt_guard_size).\n\n\\subsection options_modelchecking_hash Hashing of the state (experimental)\n\nUsually most of the time of the model-checker is spent comparing states. This\nprocess is complicated and consumes a lot of bandwidth and cache.\nIn order to speedup the state comparison, the experimental \\b model-checker/hash\nconfiguration item enables the computation of a hash summarizing as much\ninformation of the state as possible into a single value. This hash can be used\nto avoid most of the comparisons: the costly comparison is then only used when\nthe hashes are identical.\n\nCurrently most of the state is not included in the hash because the\nimplementation was found to be buggy and this options is not as useful as\nit could be. For this reason, it is currently disabled by default.\n\n\\subsection options_modelchecking_recordreplay Record/replay (experimental)\n\nAs the model-checker keeps jumping at different places in the execution graph,\nit is difficult to understand what happens when trying to debug an application\nunder the model-checker. Event the output of the program is difficult to\ninterpret. Moreover, the model-checker does not behave nicely with advanced\ndebugging tools such as valgrind. For those reason, to identify a trajectory\nin the execution graph with the model-checker and replay this trajcetory and\nwithout the model-checker black-magic but with more standard tools\n(such as a debugger, valgrind, etc.). For this reason, Simgrid implements an\nexperimental record/replay functionnality in order to record a trajectory with\nthe model-checker and replay it without the model-checker.\n\nWhen the model-checker finds an interesting path in the application execution\ngraph (where a safety or liveness property is violated), it can generate an\nidentifier for this path. In order to enable this behavious the\n\\b model-check/record must be set to \\b yes. By default, this behaviour is not\nenabled.\n\nThis is an example of output:\n\n<pre>\n[  0.000000] (0:@) Check a safety property\n[  0.000000] (0:@) **************************\n[  0.000000] (0:@) *** PROPERTY NOT VALID ***\n[  0.000000] (0:@) **************************\n[  0.000000] (0:@) Counter-example execution trace:\n[  0.000000] (0:@) Path = 1/3;1/4\n[  0.000000] (0:@) [(1)Tremblay (app)] MC_RANDOM(3)\n[  0.000000] (0:@) [(1)Tremblay (app)] MC_RANDOM(4)\n[  0.000000] (0:@) Expanded states = 27\n[  0.000000] (0:@) Visited states = 68\n[  0.000000] (0:@) Executed transitions = 46\n</pre>\n\nThis path can then be replayed outside of the model-checker (and even in\nnon-MC build of simgrid) by setting the \\b model-check/replay item to the given\npath. The other options should be the same (but the model-checker should\nbe disabled).\n\nThe format and meaning of the path may change between different releases so\nthe same release of Simgrid should be used for the record phase and the replay\nphase.\n\n\\section options_virt Configuring the User Process Virtualization\n\n\\subsection options_virt_factory Selecting the virtualization factory\n\nIn SimGrid, the user code is virtualized in a specific mechanism\nthat allows the simulation kernel to control its execution: when a user\nprocess requires a blocking action (such as sending a message), it is\ninterrupted, and only gets released when the simulated clock reaches\nthe point where the blocking operation is done. This is explained\ngraphically in the [relevant tutorial, available online](http://simgrid.gforge.inria.fr/tutorials/simgrid-simix-101.pdf).\n\nIn SimGrid, the containers in which user processes are virtualized are\ncalled contexts. Several context factory are provided, and you can\nselect the one you want to use with the \\b contexts/factory\nconfiguration item. Some of the following may not exist on your\nmachine because of portability issues. In any case, the default one\nshould be the most effcient one (please report bugs if the\nauto-detection fails for you). They are approximately sorted here from\nthe slowest to the most efficient:\n\n - \\b thread: very slow factory using full featured threads (either\n   pthreads or windows native threads). They are slow but very\n   standard. Some debuggers or profilers only work with this factory.\n - \\b java: Java applications are virtualized onto java threads (that\n   are regular pthreads registered to the JVM)\n - \\b ucontext: fast factory using System V contexts (Linux and FreeBSD only)\n - \\b boost: This uses the [context implementation](http://www.boost.org/doc/libs/1_59_0/libs/context/doc/html/index.html)\n   of the boost library for a performance that is comparable to our\n   raw implementation.\\nInstall the relevant library (e.g. with the\n   libboost-contexts-dev package on Debian/Ubuntu) and recompile\n   SimGrid. Note that our implementation is not compatible with recent\n   implementations of the library, and it will be hard to fix this since\n   the library's author decided to hide an API that we were using.\n - \\b raw: amazingly fast factory using a context switching mechanism\n   of our own, directly implemented in assembly (only available for x86\n   and amd64 platforms for now) and without any unneeded system call.\n\nThe main reason to change this setting is when the debugging tools get\nfooled by the optimized context factories. Threads are the most\ndebugging-friendly contextes, as they allow to set breakpoints\nanywhere with gdb and visualize backtraces for all processes, in order\nto debug concurrency issues. Valgrind is also more comfortable with\nthreads, but it should be usable with all factories (but the callgrind\ntool that really don't like raw and ucontext factories).\n\n\\subsection options_virt_stacksize Adapting the used stack size\n\nEach virtualized used process is executed using a specific system\nstack. The size of this stack has a huge impact on the simulation\nscalability, but its default value is rather large. This is because\nthe error messages that you get when the stack size is too small are\nrather disturbing: this leads to stack overflow (overwriting other\nstacks), leading to segfaults with corrupted stack traces.\n\nIf you want to push the scalability limits of your code, you might\nwant to reduce the \\b contexts/stack-size item. Its default value\nis 8192 (in KiB), while our Chord simulation works with stacks as small\nas 16 KiB, for example. For the thread factory, the default value\nis the one of the system but you can still change it with this parameter.\n\nThe operating system should only allocate memory for the pages of the\nstack which are actually used and you might not need to use this in\nmost cases. However, this setting is very important when using the\nmodel checker (see \\ref options_mc_perf).\n\n\\subsection options_virt_guard_size Disabling stack guard pages\n\nA stack guard page is usually used which prevents the stack of a given\nactor from overflowing on another stack. But the performance impact\nmay become prohibitive when the amount of actors increases.  The\noption \\b contexts:guard-size is the number of stack guard pages used.\nBy setting it to 0, no guard pages will be used: in this case, you\nshould avoid using small stacks (\\b stack-size) as the stack will\nsilently overflow on other parts of the memory.\n\nWhen no stack guard page is created, stacks may then silently overflow\non other parts of the memory if their size is too small for the\napplication. This happens:\n\n- on Windows systems;\n- when the model checker is enabled;\n- and of course when guard pages are explicitely disabled (with \\b contexts:guard-size=0).\n\n\\subsection options_virt_parallel Running user code in parallel\n\nParallel execution of the user code is only considered stable in\nSimGrid v3.7 and higher, and mostly for MSG simulations. SMPI\nsimulations may well fail in parallel mode. It is described in\n<a href=\"http://hal.inria.fr/inria-00602216/\">INRIA RR-7653</a>.\n\nIf you are using the \\c ucontext or \\c raw context factories, you can\nrequest to execute the user code in parallel. Several threads are\nlaunched, each of them handling as much user contexts at each run. To\nactiave this, set the \\b contexts/nthreads item to the amount of\ncores that you have in your computer (or lower than 1 to have\nthe amount of cores auto-detected).\n\nEven if you asked several worker threads using the previous option,\nyou can request to start the parallel execution (and pay the\nassociated synchronization costs) only if the potential parallelism is\nlarge enough. For that, set the \\b contexts/parallel-threshold\nitem to the minimal amount of user contexts needed to start the\nparallel execution. In any given simulation round, if that amount is\nnot reached, the contexts will be run sequentially directly by the\nmain thread (thus saving the synchronization costs). Note that this\noption is mainly useful when the grain of the user code is very fine,\nbecause our synchronization is now very efficient.\n\nWhen parallel execution is activated, you can choose the\nsynchronization schema used with the \\b contexts/synchro item,\nwhich value is either:\n - \\b futex: ultra optimized synchronisation schema, based on futexes\n   (fast user-mode mutexes), and thus only available on Linux systems.\n   This is the default mode when available.\n - \\b posix: slow but portable synchronisation using only POSIX\n   primitives.\n - \\b busy_wait: not really a synchronisation: the worker threads\n   constantly request new contexts to execute. It should be the most\n   efficient synchronisation schema, but it loads all the cores of your\n   machine for no good reason. You probably prefer the other less\n   eager schemas.\n\n\\section options_tracing Configuring the tracing subsystem\n\nThe \\ref outcomes_vizu \"tracing subsystem\" can be configured in several\ndifferent ways depending on the nature of the simulator (MSG, SimDag,\nSMPI) and the kind of traces that need to be obtained. See the \\ref\ntracing_tracing_options \"Tracing Configuration Options subsection\" to\nget a detailed description of each configuration option.\n\nWe detail here a simple way to get the traces working for you, even if\nyou never used the tracing API.\n\n\n- Any SimGrid-based simulator (MSG, SimDag, SMPI, ...) and raw traces:\n\\verbatim\n--cfg=tracing:yes --cfg=tracing/uncategorized:yes --cfg=triva/uncategorized:uncat.plist\n\\endverbatim\n    The first parameter activates the tracing subsystem, the second\n    tells it to trace host and link utilization (without any\n    categorization) and the third creates a graph configuration file\n    to configure Triva when analysing the resulting trace file.\n\n- MSG or SimDag-based simulator and categorized traces (you need to declare categories and classify your tasks according to them)\n\\verbatim\n--cfg=tracing:yes --cfg=tracing/categorized:yes --cfg=triva/categorized:cat.plist\n\\endverbatim\n    The first parameter activates the tracing subsystem, the second\n    tells it to trace host and link categorized utilization and the\n    third creates a graph configuration file to configure Triva when\n    analysing the resulting trace file.\n\n- SMPI simulator and traces for a space/time view:\n\\verbatim\nsmpirun -trace ...\n\\endverbatim\n    The <i>-trace</i> parameter for the smpirun script runs the\nsimulation with --cfg=tracing:yes and --cfg=tracing/smpi:yes. Check the\nsmpirun's <i>-help</i> parameter for additional tracing options.\n\nSometimes you might want to put additional information on the trace to\ncorrectly identify them later, or to provide data that can be used to\nreproduce an experiment. You have two ways to do that:\n\n- Add a string on top of the trace file as comment:\n\\verbatim\n--cfg=tracing/comment:my_simulation_identifier\n\\endverbatim\n\n- Add the contents of a textual file on top of the trace file as comment:\n\\verbatim\n--cfg=tracing/comment-file:my_file_with_additional_information.txt\n\\endverbatim\n\nPlease, use these two parameters (for comments) to make reproducible\nsimulations. For additional details about this and all tracing\noptions, check See the \\ref tracing_tracing_options.\n\n\\section options_msg Configuring MSG\n\n\\subsection options_msg_debug_multiple_use Debugging MSG\n\nSometimes your application may try to send a task that is still being\nexecuted somewhere else, making it impossible to send this task. However,\nfor debugging purposes, one may want to know what the other host is/was\ndoing. This option shows a backtrace of the other process.\n\nEnable this option by adding\n\n\\verbatim\n--cfg=msg/debug-multiple-use:on\n\\endverbatim\n\n\\section options_smpi Configuring SMPI\n\nThe SMPI interface provides several specific configuration items.\nThese are uneasy to see since the code is usually launched through the\n\\c smiprun script directly.\n\n\\subsection options_smpi_bench smpi/bench: Automatic benchmarking of SMPI code\n\nIn SMPI, the sequential code is automatically benchmarked, and these\ncomputations are automatically reported to the simulator. That is to\nsay that if you have a large computation between a \\c MPI_Recv() and a\n\\c MPI_Send(), SMPI will automatically benchmark the duration of this\ncode, and create an execution task within the simulator to take this\ninto account. For that, the actual duration is measured on the host\nmachine and then scaled to the power of the corresponding simulated\nmachine. The variable \\b smpi/host-speed allows to specify the\ncomputational speed of the host machine (in flop/s) to use when\nscaling the execution times. It defaults to 20000, but you really want\nto update it to get accurate simulation results.\n\nWhen the code is constituted of numerous consecutive MPI calls, the\nprevious mechanism feeds the simulation kernel with numerous tiny\ncomputations. The \\b smpi/cpu-threshold item becomes handy when this\nimpacts badly the simulation performance. It specifies a threshold (in\nseconds) below which the execution chunks are not reported to the\nsimulation kernel (default value: 1e-6).\n\n\\note\n    The option smpi/cpu-threshold ignores any computation time spent\n    below this threshold. SMPI does not consider the \\a amount of these\n    computations; there is no offset for this. Hence, by using a\n    value that is too low, you may end up with unreliable simulation\n    results.\n\nIn some cases, however, one may wish to disable simulation of\napplication computation. This is the case when SMPI is used not to\nsimulate an MPI applications, but instead an MPI code that performs\n\"live replay\" of another MPI app (e.g., ScalaTrace's replay tool,\nvarious on-line simulators that run an app at scale). In this case the\ncomputation of the replay/simulation logic should not be simulated by\nSMPI. Instead, the replay tool or on-line simulator will issue\n\"computation events\", which correspond to the actual MPI simulation\nbeing replayed/simulated. At the moment, these computation events can\nbe simulated using SMPI by calling internal smpi_execute*() functions.\n\nTo disable the benchmarking/simulation of computation in the simulated\napplication, the variable \\b smpi/simulate-computation should be set to no.\n\n\\note\n    This option just ignores the timings in your simulation; it still executes\n    the computations itself. If you want to stop SMPI from doing that,\n    you should check the SMPI_SAMPLE macros, documented in the section\n    \\ref SMPI_adapting_speed.\n\nSolution                           | Computations actually executed? | Computations simulated ?\n---------------------------------- | ------------------------------- | ------------------------\n--cfg=smpi/simulate-computation:no | Yes                             | No, never\n--cfg=smpi/cpu-threshold:42        | Yes, in all cases               | Only if it lasts more than 42 seconds\nSMPI_SAMPLE() macro                | Only once per loop nest (see @ref SMPI_adapting_speed \"documentation\") | Always\n\n\\subsection options_model_smpi_adj_file smpi/comp-adjustment-file: Slow-down or speed-up parts of your code.\n\nThis option allows you to pass a file that contains two columns: The first column\ndefines the section that will be subject to a speedup; the second column is the speedup.\n\nFor instance:\n\n\\verbatim\n\"start:stop\",\"ratio\"\n\"exchange_1.f:30:exchange_1.f:130\",1.18244559422142\n\\endverbatim\n\nThe first line is the header - you must include it.\nThe following line means that the code between two consecutive MPI calls on\nline 30 in exchange_1.f and line 130 in exchange_1.f should receive a speedup\nof 1.18244559422142. The value for the second column is therefore a speedup, if it is\nlarger than 1 and a slow-down if it is smaller than 1. Nothing will be changed if it is\nequal to 1.\n\nOf course, you can set any arbitrary filenames you want (so the start and end don't have to be\nin the same file), but be aware that this mechanism only supports @em consecutive calls!\n\n\\note\n    Please note that you must pass the \\b -trace-call-location flag to smpicc\n    or smpiff, respectively! This flag activates some macro definitions in our\n    mpi.h / mpi.f files that help with obtaining the call location.\n\n\\subsection options_model_smpi_bw_factor smpi/bw-factor: Bandwidth factors\n\nThe possible throughput of network links is often dependent on the\nmessage sizes, as protocols may adapt to different message sizes. With\nthis option, a series of message sizes and factors are given, helping\nthe simulation to be more realistic. For instance, the current\ndefault value is\n\n\\verbatim\n65472:0.940694;15424:0.697866;9376:0.58729;5776:1.08739;3484:0.77493;1426:0.608902;732:0.341987;257:0.338112;0:0.812084\n\\endverbatim\n\nSo, messages with size 65472 and more will get a total of MAX_BANDWIDTH*0.940694,\nmessages of size 15424 to 65471 will get MAX_BANDWIDTH*0.697866 and so on.\nHere, MAX_BANDWIDTH denotes the bandwidth of the link.\n\n\\note\n    The SimGrid-Team has developed a script to help you determine these\n    values. You can find more information and the download here:\n    1. http://simgrid.gforge.inria.fr/contrib/smpi-calibration-doc.html\n    2. http://simgrid.gforge.inria.fr/contrib/smpi-saturation-doc.html\n\n\\subsection options_smpi_timing smpi/display-timing: Reporting simulation time\n\n\\b Default: 0 (false)\n\nMost of the time, you run MPI code with SMPI to compute the time it\nwould take to run it on a platform. But since the\ncode is run through the \\c smpirun script, you don't have any control\non the launcher code, making it difficult to report the simulated time\nwhen the simulation ends. If you set the \\b smpi/display-timing item\nto 1, \\c smpirun will display this information when the simulation ends. \\verbatim\nSimulation time: 1e3 seconds.\n\\endverbatim\n\n\\subsection options_smpi_temps smpi/keep-temps: not cleaning up after simulation\n\n\\b Default: 0 (false)\n\nUnder some conditions, SMPI generates a lot of temporary files.  They\nusually get cleaned, but you may use this option to not erase these\nfiles. This is for example useful when debugging or profiling\nexecutions using the dlopen privatization schema, as missing binary\nfiles tend to fool the debuggers.\n\n\\subsection options_model_smpi_lat_factor smpi/lat-factor: Latency factors\n\nThe motivation and syntax for this option is identical to the motivation/syntax\nof smpi/bw-factor, see \\ref options_model_smpi_bw_factor for details.\n\nThere is an important difference, though: While smpi/bw-factor \\a reduces the\nactual bandwidth (i.e., values between 0 and 1 are valid), latency factors\nincrease the latency, i.e., values larger than or equal to 1 are valid here.\n\nThis is the default value:\n\n\\verbatim\n65472:11.6436;15424:3.48845;9376:2.59299;5776:2.18796;3484:1.88101;1426:1.61075;732:1.9503;257:1.95341;0:2.01467\n\\endverbatim\n\n\\note\n    The SimGrid-Team has developed a script to help you determine these\n    values. You can find more information and the download here:\n    1. http://simgrid.gforge.inria.fr/contrib/smpi-calibration-doc.html\n    2. http://simgrid.gforge.inria.fr/contrib/smpi-saturation-doc.html\n\n\\subsection options_smpi_papi_events smpi/papi-events: Trace hardware counters with PAPI\n\n\\warning \n    This option is experimental and will be subject to change.\n    This feature currently requires superuser privileges, as registers are queried.\n    Only use this feature with code you trust! Call smpirun for instance via\n        smpirun -wrapper \"sudo \" <your-parameters>\n    or run sudo sh -c \"echo 0 > /proc/sys/kernel/perf_event_paranoid\"\n    In the later case, sudo will not be required.\n\n\\note\n    This option is only available when SimGrid was compiled with PAPI support.\n\nThis option takes the names of PAPI counters and adds their respective values\nto the trace files. (See Section \\ref tracing_tracing_options.)\n\nIt is planned to make this feature available on a per-process (or per-thread?) basis.\nThe first draft, however, just implements a \"global\" (i.e., for all processes) set\nof counters, the \"default\" set.\n\n\\verbatim\n--cfg=smpi/papi-events:\"default:PAPI_L3_LDM:PAPI_L2_LDM\"\n\\endverbatim\n\n\\subsection options_smpi_privatization smpi/privatization: Automatic privatization of global variables\n\nMPI executables are usually meant to be executed in separated processes, but SMPI is\nexecuted in only one process. Global variables from executables will be placed\nin the same memory zone and shared between processes, causing intricate bugs.\nSeveral options are possible to avoid this, as described in the main\n<a href=\"https://hal.inria.fr/hal-01415484\">SMPI publication</a>.\nSimGrid provides two ways of automatically privatizing the globals,\nand this option allows to choose between them.\n\n  - <b>no</b> (default): Do not automatically privatize variables.\n  - <b>mmap</b> or <b>yes</b>: Runtime automatic switching of the data segments.\\n\n    SMPI stores a copy of each global data segment for each process,\n    and at each context switch replaces the actual data with its copy\n    from the right process. No copy actually occures as this mechanism\n    uses mmap for efficiency. As such, it is for now limited to\n    systems supporting this functionnality (all Linux and most BSD).\\n\n    Another limitation is that SMPI only accounts for global variables\n    defined in the executable. If the processes use external global\n    variables from dynamic libraries, they won't be switched\n    correctly. The easiest way to solve this is to statically link\n    against the library with these globals (but you should never\n    statically link against the simgrid library itself).\n  - <b>dlopen</b>: Link multiple times against the binary.\\n  \n    SMPI loads several copy of the same binary in memory, resulting in\n    the natural duplication global variables. Since the dynamic linker\n    refuses to link the same file several times, the binary is copied\n    in a temporary file before being dl-loaded (it is erased right\n    after loading).\\n\n    Note that this feature is somewhat experimental at time of writing\n    (v3.16) but seems to work.\\n\n    This approach greatly speeds up the context switching, down to\n    about 40 CPU cycles with our raw contextes, instead of requesting\n    several syscalls with the \\c mmap approach. Another advantage is\n    that it permits to run the SMPI contexts in parallel, which is\n    obviously not possible with the \\c mmap approach.\\n\n    Further work may be possible to alleviate the memory and disk\n    overconsumption. It seems that we could \n    <a href=\"https://lwn.net/Articles/415889/\">punch holes</a>\n    in the files before dl-loading them to remove the code and\n    constants, and mmap these area onto a unique copy. This require\n    to understand the ELF layout of the file, but would \n    reduce the disk- and memory- usage to the bare minimum. In\n    addition, this would reduce the pressure on the CPU caches (in\n    particular on instruction one).\n\n\\warning\n  This configuration option cannot be set in your platform file. You can only\n  pass it as an argument to smpirun.\n\n\\subsection options_model_smpi_detached Simulating MPI detached send\n\nThis threshold specifies the size in bytes under which the send will return\nimmediately. This is different from the threshold detailed in  \\ref options_model_network_asyncsend\nbecause the message is not effectively sent when the send is posted. SMPI still waits for the\ncorrespondant receive to be posted to perform the communication operation. This threshold can be set\nby changing the \\b smpi/send-is-detached-thresh item. The default value is 65536.\n\n\\subsection options_model_smpi_collectives Simulating MPI collective algorithms\n\nSMPI implements more than 100 different algorithms for MPI collective communication, to accurately\nsimulate the behavior of most of the existing MPI libraries. The \\b smpi/coll-selector item can be used\n to use the decision logic of either OpenMPI or MPICH libraries (values: ompi or mpich, by default SMPI\nuses naive version of collective operations). Each collective operation can be manually selected with a\n\\b smpi/collective_name:algo_name. Available algorithms are listed in \\ref SMPI_use_colls .\n\n\\subsection options_model_smpi_iprobe smpi/iprobe: Inject constant times for calls to MPI_Iprobe\n\n\\b Default value: 0.0001\n\nThe behavior and motivation for this configuration option is identical with \\a smpi/test, see\nSection \\ref options_model_smpi_test for details.\n\n\\subsection options_model_smpi_iprobe_cpu_usage smpi/iprobe-cpu-usage: Reduce speed for iprobe calls\n\n\\b Default value: 1 (no change from default behavior)\n\nMPI_Iprobe calls can be heavily used in applications. To account correctly for the energy\ncores spend probing, it is necessary to reduce the load that these calls cause inside\nSimGrid.\n\nFor instance, we measured a max power consumption of 220 W for a particular application but \nonly 180 W while this application was probing. Hence, the correct factor that should\nbe passed to this option would be 180/220 = 0.81.\n\n\\subsection options_model_smpi_init smpi/init: Inject constant times for calls to MPI_Init\n\n\\b Default value: 0\n\nThe behavior for this configuration option is identical with \\a smpi/test, see\nSection \\ref options_model_smpi_test for details.\n\n\\subsection options_model_smpi_ois smpi/ois: Inject constant times for asynchronous send operations\n\nThis configuration option works exactly as \\a smpi/os, see Section \\ref options_model_smpi_os.\nOf course, \\a smpi/ois is used to account for MPI_Isend instead of MPI_Send.\n\n\\subsection options_model_smpi_os smpi/os: Inject constant times for send operations\n\nIn several network models such as LogP, send (MPI_Send, MPI_Isend) and receive (MPI_Recv)\noperations incur costs (i.e., they consume CPU time). SMPI can factor these costs in as well, but the\nuser has to configure SMPI accordingly as these values may vary by machine.\nThis can be done by using smpi/os for MPI_Send operations; for MPI_Isend and\nMPI_Recv, use \\a smpi/ois and \\a smpi/or, respectively. These work exactly as\n\\a smpi/ois.\n\n\\a smpi/os can consist of multiple sections; each section takes three values, for example:\n\n\\verbatim\n    1:3:2;10:5:1\n\\endverbatim\n\nHere, the sections are divided by \";\" (that is, this example contains two sections).\nFurthermore, each section consists of three values.\n\n1. The first value denotes the minimum size for this section to take effect;\n   read it as \"if message size is greater than this value (and other section has a larger\n   first value that is also smaller than the message size), use this\".\n   In the first section above, this value is \"1\".\n\n2. The second value is the startup time; this is a constant value that will always\n   be charged, no matter what the size of the message. In the first section above,\n   this value is \"3\".\n\n3. The third value is the \\a per-byte cost. That is, it is charged for every\n   byte of the message (incurring cost messageSize*cost_per_byte)\n   and hence accounts also for larger messages. In the first\n   section of the example above, this value is \"2\".\n\nNow, SMPI always checks which section it should take for a given message; that is,\nif a message of size 11 is sent with the configuration of the example above, only\nthe second section will be used, not the first, as the first value of the second\nsection is closer to the message size. Hence, a message of size 11 incurs the\nfollowing cost inside MPI_Send:\n\n\\verbatim\n    5+11*1\n\\endverbatim\n\nAs 5 is the startup cost and 1 is the cost per byte.\n\n\\note\n    The order of sections can be arbitrary; they will be ordered internally.\n\n\\subsection options_model_smpi_or smpi/or: Inject constant times for receive operations\n\nThis configuration option works exactly as \\a smpi/os, see Section \\ref options_model_smpi_os.\nOf course, \\a smpi/or is used to account for MPI_Recv instead of MPI_Send.\n\n\\subsection options_model_smpi_test smpi/test: Inject constant times for calls to MPI_Test\n\n\\b Default value: 0.0001\n\nBy setting this option, you can control the amount of time a process sleeps\nwhen MPI_Test() is called; this is important, because SimGrid normally only\nadvances the time while communication is happening and thus,\nMPI_Test will not add to the time, resulting in a deadlock if used as a\nbreak-condition.\n\nHere is an example:\n\n\\code{.unparsed}\n    while(!flag) {\n        MPI_Test(request, flag, status);\n        ...\n    }\n\\endcode\n\n\\note\n    Internally, in order to speed up execution, we use a counter to keep track\n    on how often we already checked if the handle is now valid or not. Hence, we\n    actually use counter*SLEEP_TIME, that is, the time MPI_Test() causes the process\n    to sleep increases linearly with the number of previously failed tests. This \n    behavior can be disabled by setting smpi/grow-injected-times to no. This will\n    also disable this behavior for MPI_Iprobe.\n\n\n\\subsection options_model_smpi_shared_malloc smpi/shared-malloc: Factorize malloc()s\n\n\\b Default: global\n\nIf your simulation consumes too much memory, you may want to modify\nyour code so that the working areas are shared by all MPI ranks. For\nexample, in a bloc-cyclic matrix multiplication, you will only\nallocate one set of blocs, and every processes will share them.\nNaturally, this will lead to very wrong results, but this will save a\nlot of memory so this is still desirable for some studies. For more on\nthe motivation for that feature, please refer to the \n<a href=\"https://simgrid.github.io/SMPI_CourseWare/topic_understanding_performance/matrixmultiplication/\">relevant\nsection</a> of the SMPI CourseWare (see Activity #2.2 of the pointed\nassignment). In practice, change the call to malloc() and free() into\nSMPI_SHARED_MALLOC() and SMPI_SHARED_FREE().\n\nSMPI provides 2 algorithms for this feature. The first one, called \\c\nlocal, allocates one bloc per call to SMPI_SHARED_MALLOC() in your\ncode (each call location gets its own bloc) and this bloc is shared\namongst all MPI ranks.  This is implemented with the shm_* functions\nto create a new POSIX shared memory object (kept in RAM, in /dev/shm)\nfor each shared bloc.\n\nWith the \\c global algorithm, each call to SMPI_SHARED_MALLOC()\nreturns a new adress, but it only points to a shadow bloc: its memory\narea is mapped on a 1MiB file on disk. If the returned bloc is of size\nN MiB, then the same file is mapped N times to cover the whole bloc. \nAt the end, no matter how many SMPI_SHARED_MALLOC you do, this will\nonly consume 1 MiB in memory. \n\nYou can disable this behavior and come back to regular mallocs (for\nexample for debugging purposes) using \\c \"no\" as a value.\n\nIf you want to keep private some parts of the buffer, for instance if these\nparts are used by the application logic and should not be corrupted, you\ncan use SMPI_PARTIAL_SHARED_MALLOC(size, offsets, offsets_count).\n\nAs an example,\n\n\\code{.C}\n    mem = SMPI_PARTIAL_SHARED_MALLOC(500, {27,42 , 100,200}, 2);\n\\endcode\n\nwill allocate 500 bytes to mem, such that mem[27..41] and mem[100..199]\nare shared and other area remain private.\n\nThen, it can be deallocated by calling SMPI_SHARED_FREE(mem).\n\nWhen smpi/shared-malloc:global is used, the memory consumption problem\nis solved, but it may induce too much load on the kernel's pages table. \nIn this case, you should use huge pages so that we create only one\nentry per Mb of malloced data instead of one entry per 4k.\nTo activate this, you must mount a hugetlbfs on your system and allocate\nat least one huge page:\n\n\\code{.sh}\n    mkdir /home/huge\n    sudo mount none /home/huge -t hugetlbfs -o rw,mode=0777\n    sudo sh -c 'echo 1 > /proc/sys/vm/nr_hugepages' # echo more if you need more\n\\endcode\n\nThen, you can pass the option --cfg=smpi/shared-malloc-hugepage:/home/huge\nto smpirun to actually activate the huge page support in shared mallocs.\n\n\\subsection options_model_smpi_wtime smpi/wtime: Inject constant times for calls to MPI_Wtime\n\n\\b Default value: 0\n\nBy setting this option, you can control the amount of time a process sleeps\nwhen MPI_Wtime() is called; this is important, because SimGrid normally only\nadvances the time while communication is happening and thus,\nMPI_Wtime will not add to the time, resulting in a deadlock if used as a\nbreak-condition.\n\nHere is an example:\n\n\\code{.unparsed}\n    while(MPI_Wtime() < some_time_bound) {\n        ...\n    }\n\\endcode\n\nIf the time is never advanced, this loop will clearly never end as MPI_Wtime()\nalways returns the same value. Hence, pass a (small) value to the smpi/wtime\noption to force a call to MPI_Wtime to advance the time as well.\n\n\n\\section options_generic Configuring other aspects of SimGrid\n\n\\subsection options_generic_clean_atexit Cleanup before termination\n\nThe C / C++ standard contains a function called \\b [atexit](http://www.cplusplus.com/reference/cstdlib/atexit/).\natexit registers callbacks, which are called just before the program terminates.\n\nBy setting the configuration option clean-atexit to 1 (true), a callback\nis registered and will clean up some variables and terminate/cleanup the tracing.\n\nTODO: Add when this should be used.\n\n\\subsection options_generic_path XML file inclusion path\n\nIt is possible to specify a list of directories to search into for the\n\\<include\\> tag in XML files by using the \\b path configuration\nitem. To add several directory to the path, set the configuration\nitem several times, as in \\verbatim\n--cfg=path:toto --cfg=path:tutu\n\\endverbatim\n\n\\subsection options_generic_exit Behavior on Ctrl-C\n\nBy default, when Ctrl-C is pressed, the status of all existing\nsimulated processes is displayed before exiting the simulation. This is very useful to debug your\ncode, but it can reveal troublesome in some cases (such as when the\namount of processes becomes really big). This behavior is disabled\nwhen \\b verbose-exit is set to 0 (it is to 1 by default).\n\n\\subsection options_exception_cutpath Truncate local path from exception backtrace\n\n\\verbatim\n--cfg=exceptions/cutpath:1\n\\endverbatim\n\nThis configuration option is used to remove the path from the\nbacktrace shown when an exception is thrown. This is mainly useful for\nthe tests: the full file path makes the tests not reproducible, and\nthus failing as we are currently comparing output. Clearly, the path\nused on different machines are almost guaranteed to be different and\nhence, the output would mismatch, causing the test to fail.\n\n\\section options_log Logging Configuration\n\nIt can be done by using XBT. Go to \\ref XBT_log for more details.\n\n*/\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/surf++.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/triva-time_interval.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/triva-graph_visualization.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/surf++.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/triva-graph_configuration.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/sc3-description.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/smpi_simgrid_alltoall_pair_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/output.goal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/smpi_simgrid_alltoall_ring_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/AS_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/SGicon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/SGicon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/SGicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/awstats_logo3.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/poster_thumbnail.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/simgrid_logo_2011_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/simgrid_logo_win.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.16-67jahhefow6lzojta3hmglchapfrb5nu/spack-src/doc/webcruft/simgrid_logo_win_2011.bmp"
    ],
    "total_files": 2355
}