{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rr-4.4.0-cfxjrjkkrrq6os4jvxt3xpl2w2lunns3/spack-src/CMakeLists.txt": "# *-* Mode: cmake; *-*\n\ncmake_minimum_required(VERSION 2.8.5)\nproject(rr C CXX ASM)\n\n# On single configuration generators, make Debug the default configuration\nif(NOT CMAKE_CONFIGURATION_TYPES)\n  if(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE STRING \"Whether to build in `Debug` or `Release` mode.\" FORCE)\n  endif()\nendif()\n\nenable_testing()\nset(BUILD_SHARED_LIBS ON)\n\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)\nset(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)\n\nset(WILL_RUN_TESTS ON CACHE BOOL \"Run tests\")\n\n# CAREFUL!  \"-\" is an invalid character in RPM package names, while\n# debian is happy with it.  However, \"_\" is illegal in debs, while RPM\n# is cool with it.  Sigh.\nset(rr_VERSION_MAJOR 4)\nset(rr_VERSION_MINOR 4)\nset(rr_VERSION_PATCH 0)\n\nadd_definitions(-DRR_VERSION=\"${rr_VERSION_MAJOR}.${rr_VERSION_MINOR}.${rr_VERSION_PATCH}\")\n\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -pthread -g3 -Wall -Wextra -Wstrict-prototypes\")\nset(CMAKE_C_FLAGS_DEBUG \"-O0 -Werror -DDEBUG\")\nset(CMAKE_C_FLAGS_RELEASE \"-O2\")\n# Define __STDC_LIMIT_MACROS so |#include <stdint.h>| works as expected.\n# Define __STDC_FORMAT_MACROS so |#include <inttypes.h>| works as expected.\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -D__USE_LARGEFILE64 -D__STDC_LIMIT_MACROS -D__STDC_FORMAT_MACROS -std=c++0x -pthread -g3 -Wall -Wextra\")\nset(CMAKE_CXX_FLAGS_DEBUG \"-O0 -Werror -DDEBUG\")\nset(CMAKE_CXX_FLAGS_RELEASE \"-O2\")\nset(CMAKE_ASM_FLAGS \"${CMAKE_ASM_FLAGS} -g3\")\n\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wno-unused-command-line-argument\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-unused-command-line-argument\")\nendif()\n\noption(force32bit \"Force a 32-bit rr build, rather than both 64 and 32-bit. rr will only be able to record and replay 32-bit processes.\")\noption(disable32bit \"On a 64-bit platform, avoid requiring a 32-bit cross-compilation toolchain by not building 32-bit components. rr will be able to record 32-bit processes but not replay them.\")\n\nif(force32bit)\n  set(rr_32BIT true)\n  set(rr_64BIT false)\n  set(rr_MBITNESS_OPTION -m32)\nelse()\n  if(CMAKE_SIZEOF_VOID_P EQUAL 8)\n    if(disable32bit)\n      set(rr_32BIT false)\n    else()\n      set(rr_32BIT true)\n    endif()\n    set(rr_64BIT true)\n  else()\n    set(rr_32BIT true)\n    set(rr_64BIT false)\n  endif()\n  set(rr_MBITNESS_OPTION)\nendif()\n\n\n# Check that compiling 32-bit code on a 64-bit target works, if required.\nif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL \"x86_64\" AND rr_32BIT)\n  # try_compile won't accept LINK_FLAGS, so do this manually.\n  file(WRITE \"${CMAKE_BINARY_DIR}/test32.c\" \"int main() { return 0; }\")\n  execute_process(COMMAND ${CMAKE_C_COMPILER} -o ${CMAKE_BINARY_DIR}/test32 ${CMAKE_BINARY_DIR}/test32.c -m32\n\t\t\tRESULT_VARIABLE COMPILER_32BIT_RESULT)\n  if(NOT (COMPILER_32BIT_RESULT EQUAL 0))\n    message(FATAL_ERROR \"Your toolchain doesn't support 32-bit cross-compilation. Install the required packages or pass -Ddisable32bit=ON to cmake.\")\n  endif()\nendif()\n\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${rr_MBITNESS_OPTION}\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${rr_MBITNESS_OPTION}\")\nset(CMAKE_ASM_FLAGS \"${CMAKE_ASM_FLAGS} ${rr_MBITNESS_OPTION}\")\n\nfind_package(PkgConfig REQUIRED)\n\n# If we're cross-compiling a 32-bit rr build on a 64-bit host we need\n# to ensure we're looking for the right libraries.\n# This has been tested on Ubuntu and Fedora.\nif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL \"x86_64\" AND NOT rr_64BIT)\n  set(LIBDIR32_CANDIDATES\n    /usr/lib/i386-linux-gnu/pkgconfig/\n    /usr/lib/pkgconfig/\n  )\n  foreach(libdir ${LIBDIR32_CANDIDATES})\n    if(IS_DIRECTORY ${libdir})\n      set(ENV{PKG_CONFIG_LIBDIR} ${libdir})\n      break()\n     endif()\n   endforeach(libdir)\n   if(NOT DEFINED ENV{PKG_CONFIG_LIBDIR})\n     message(FATAL_ERROR \"Couldn't find a suitable 32-bit pkgconfig lib dir. You probably need to install a 32-bit pkgconfig package (pkgconfig.i686 for Fedora or pkg-config:i386 for Ubuntu\")\n   endif()\nendif()\n\n# Check for required libraries\nset(REQUIRED_LIBS\n  zlib\n)\nforeach(required_lib ${REQUIRED_LIBS})\n  string(TOUPPER ${required_lib} PKG)\n  pkg_check_modules(${PKG} REQUIRED ${required_lib})\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${${PKG}_CFLAGS}\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${${PKG}_CFLAGS}\")\nendforeach(required_lib)\n\n# Check for Python >=2.7 but not Python 3.\nfind_package(PythonInterp 2.7 REQUIRED)\nif(PYTHON_VERSION_MAJOR GREATER 2)\n  message(FATAL_ERROR \"Python 3 is not supported, please use Python 2.7.\")\nendif()\n\nexecute_process(COMMAND \"${PYTHON_EXECUTABLE}\" \"-c\" \"# nothing\"\n                RESULT_VARIABLE python_status)\nif(python_status)\n  message(FATAL_ERROR \"Couldn't run python interpreter ${PYTHON_EXECUTABLE}.\")\nendif()\n\n# Check for required Python modules\nif(WILL_RUN_TESTS)\n  set(REQUIRED_PYTHON_MODULES\n    pexpect\n  )\nelse()\n  set(REQUIRED_PYTHON_MODULES)\nendif()\n\nforeach(py_module ${REQUIRED_PYTHON_MODULES})\n  execute_process(COMMAND \"${PYTHON_EXECUTABLE}\" \"-c\"\n\t\t\t\"import ${py_module}\"\n\t\t\tRESULT_VARIABLE module_status)\n  if(module_status)\n    message(FATAL_ERROR \"Couldn't find required Python module ${py_module}.\")\n  endif()\nendforeach(py_module)\n\nif(WILL_RUN_TESTS)\n  # Check for gdb\n  execute_process(COMMAND \"gdb\" \"--version\" RESULT_VARIABLE module_status OUTPUT_QUIET)\n  if(module_status)\n    message(FATAL_ERROR \"Couldn't find gdb.\")\n  endif()\nendif()\n\nset(PRELOAD_COMPILE_FLAGS \"-fno-stack-protector\")\n\nif (NOT DEBUG_PRELOAD_LIB)\nset(PRELOAD_COMPILE_FLAGS \"${PRELOAD_COMPILE_FLAGS} ${CMAKE_C_FLAGS_RELEASE}\")\nendif()\n\nset_source_files_properties(src/preload/preload.c\n                            PROPERTIES COMPILE_FLAGS ${PRELOAD_COMPILE_FLAGS})\n\ninclude_directories(\"${PROJECT_SOURCE_DIR}/include\")\ninclude_directories(\"${PROJECT_SOURCE_DIR}/third-party/proc-service\")\n# We need to know where our generated files are.\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}\")\n\nadd_library(rrpreload\n  src/preload/preload.c\n  src/preload/raw_syscall.S\n  src/preload/syscall_hook.S\n  src/preload/breakpoint_table.S\n)\n\n# Ensure that CMake knows about our generated files.\n#\n# Alphabetical, please.\nset(GENERATED_FILES\n  AssemblyTemplates.generated\n  CheckSyscallNumbers.generated\n  SyscallEnumsX64.generated\n  SyscallEnumsX86.generated\n  SyscallEnumsForTestsX64.generated\n  SyscallEnumsForTestsX86.generated\n  SyscallHelperFunctions.generated\n  SyscallnameArch.generated\n  SyscallRecordCase.generated\n)\n\nforeach(generated_file ${GENERATED_FILES})\n  set_source_files_properties(${generated_file}\n                              PROPERTIES GENERATED true HEADER_FILE_ONLY true)\n  add_custom_command(OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/${generated_file}\"\n                     COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_syscalls.py\"\n\t\t               \"${CMAKE_CURRENT_BINARY_DIR}/${generated_file}\"\n\t\t     DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_syscalls.py\"\n\t\t       \"${CMAKE_CURRENT_SOURCE_DIR}/src/syscalls.py\"\n\t\t       \"${CMAKE_CURRENT_SOURCE_DIR}/src/assembly_templates.py\")\nendforeach(generated_file)\n\nadd_custom_target(Generated DEPENDS ${GENERATED_FILES})\n\nadd_custom_command(OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64\"\n                   COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64\"\n                   DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\")\nadd_custom_command(OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32\"\n                   COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32\"\n                   DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\")\nadd_custom_command(OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64_replay\"\n                   COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64_replay\"\n                   DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\")\nadd_custom_command(OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32_replay\"\n                   COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32_replay\"\n                   DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/src/generate_rr_page.py\")\n\nadd_custom_target(Pages DEPENDS\n                  \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32\"\n                  \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64\"\n                  \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32_replay\"\n                  \"${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64_replay\")\n\nset(RR_SOURCES\n  src/test/cpuid_loop.S\n  src/AddressSpace.cc\n  src/AutoRemoteSyscalls.cc\n  src/Command.cc\n  src/CompressedReader.cc\n  src/CompressedWriter.cc\n  src/CPUIDBugDetector.cc\n  src/DiversionSession.cc\n  src/DumpCommand.cc\n  src/ElfReader.cc\n  src/EmuFs.cc\n  src/Event.cc\n  src/ExtraRegisters.cc\n  src/fast_forward.cc\n  src/FdTable.cc\n  src/Flags.cc\n  src/ftrace.cc\n  src/GdbCommand.cc\n  src/GdbCommandHandler.cc\n  src/GdbConnection.cc\n  src/GdbExpression.cc\n  src/GdbInitCommand.cc\n  src/GdbServer.cc\n  src/HasTaskSet.cc\n  src/HelpCommand.cc\n  src/kernel_abi.cc\n  src/kernel_metadata.cc\n  src/log.cc\n  src/MagicSaveDataMonitor.cc\n  src/MmappedFileMonitor.cc\n  src/MonitoredSharedMemory.cc\n  src/Monkeypatcher.cc\n  src/PerfCounters.cc\n  src/ProcFdDirMonitor.cc\n  src/ProcMemMonitor.cc\n  src/PsCommand.cc\n  src/RecordCommand.cc\n  src/RecordSession.cc\n  src/record_signal.cc\n  src/record_syscall.cc\n  src/RecordTask.cc\n  src/Registers.cc\n  src/remote_code_ptr.cc\n  src/ReplayCommand.cc\n  src/ReplaySession.cc\n  src/replay_syscall.cc\n  src/ReplayTask.cc\n  src/ReplayTimeline.cc\n  src/ReturnAddressList.cc\n  src/Scheduler.cc\n  src/SeccompFilterRewriter.cc\n  src/Session.cc\n  src/StdioMonitor.cc\n  src/Task.cc\n  src/TaskGroup.cc\n  src/ThreadDb.cc\n  src/TraceFrame.cc\n  src/TraceStream.cc\n  src/VirtualPerfCounterMonitor.cc\n  src/util.cc\n  src/WaitStatus.cc)\n\nfunction(post_build_executable target)\n# grsecurity needs these. But if we add them ourselves, they may conflict\n# with other flags added in other ways, and they all have to match :-(. So\n# don't do this until a better solution presents itself\n#  add_custom_command(TARGET ${target}\n#                     POST_BUILD\n#                     COMMAND setfattr ARGS -n user.pax.flags -v m $<TARGET_FILE:${target}>)\nendfunction(post_build_executable)\n\noption(RR_BUILD_SHARED \"Build the rr shared library as well as the binary (experimental).\")\nif(RR_BUILD_SHARED)\n  add_library(rr ${RR_SOURCES})\n  add_executable(rrbin src/main.cc)\n  set(RR_BIN rrbin)\n  post_build_executable(rrbin)\n  set_target_properties(rrbin PROPERTIES OUTPUT_NAME rr)\n  target_link_libraries(rrbin rr)\nelse()\n  add_executable(rr ${RR_SOURCES} src/main.cc)\n  post_build_executable(rr)\n  set(RR_BIN)\nendif()\nadd_dependencies(rr Generated Pages)\n\ntarget_link_libraries(rr\n  ${CMAKE_DL_LIBS}\n  -lrt\n  ${ZLIB_LDFLAGS}\n)\n\ntarget_link_libraries(rrpreload\n  ${CMAKE_DL_LIBS}\n)\n\nadd_executable(rr_exec_stub src/exec_stub.c)\npost_build_executable(rr_exec_stub)\nset_target_properties(rr_exec_stub\n                      PROPERTIES LINK_FLAGS \"-nostartfiles -nodefaultlibs\")\nset_source_files_properties(src/exec_stub.c\n                            COMPILE_FLAGS \"-fno-stack-protector\")\n\nset(RR_GDB_RESOURCES\n  32bit-avx.xml\n  32bit-core.xml\n  32bit-linux.xml\n  32bit-sse.xml\n  64bit-avx.xml\n  64bit-core.xml\n  64bit-linux.xml\n  64bit-sse.xml\n  amd64-avx-linux.xml\n  amd64-linux.xml\n  i386-avx-linux.xml\n  i386-linux.xml\n)\nforeach(file ${RR_GDB_RESOURCES})\n  configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/third-party/gdb/${file}\"\n                 \"${CMAKE_CURRENT_BINARY_DIR}/share/rr/${file}\"\n                 COPYONLY)\n  install(FILES third-party/gdb/${file}\n          DESTINATION share/rr)\nendforeach(file)\n\ninstall(PROGRAMS scripts/signal-rr-recording.sh\n                  ${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64\n                  ${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_64_replay\n                  ${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32\n                  ${CMAKE_CURRENT_BINARY_DIR}/bin/rr_page_32_replay\n  DESTINATION bin)\n\ninstall(TARGETS rr ${RR_BIN} rrpreload rr_exec_stub\n  RUNTIME DESTINATION bin\n  LIBRARY DESTINATION lib\n  ARCHIVE DESTINATION lib)\n\n# Build 32-bit librrpreload on 64-bit builds.\n# We copy the source files into '32' subdirectories in the output\n# directory, so we can set different compile options on them.\n# This sucks but I can't find a better way to get CMake to build\n# the same source file in two different ways.\nif(rr_32BIT AND rr_64BIT)\n  foreach(file preload_interface.h)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/preload/${file}\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                   COPYONLY)\n  endforeach(file)\n\n  foreach(file preload.c raw_syscall.S syscall_hook.S breakpoint_table.S)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/preload/${file}\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                   COPYONLY)\n    set_source_files_properties(\"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                                PROPERTIES COMPILE_FLAGS \"-m32 ${CMAKE_C_FLAGS_RELEASE}\")\n  endforeach(file)\n\n  add_library(rrpreload_32\n    32/preload.c\n    32/raw_syscall.S\n    32/syscall_hook.S\n    32/breakpoint_table.S\n  )\n  set_target_properties(rrpreload_32 PROPERTIES LINK_FLAGS -m32)\n  target_link_libraries(rrpreload_32\n    ${CMAKE_DL_LIBS}\n  )\n\n  foreach(file exec_stub.c)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/${file}\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                   COPYONLY)\n    set_source_files_properties(\"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                                PROPERTIES COMPILE_FLAGS \"-m32 -fno-stack-protector\")\n  endforeach(file)\n\n  add_executable(rr_exec_stub_32 32/exec_stub.c)\n  post_build_executable(rr_exec_stub_32)\n  set_target_properties(rr_exec_stub_32\n                        PROPERTIES LINK_FLAGS \"-nostartfiles -nodefaultlibs -m32\")\n\n  install(TARGETS rrpreload_32 rr_exec_stub_32\n    RUNTIME DESTINATION bin\n    LIBRARY DESTINATION lib\n    ARCHIVE DESTINATION lib)\nendif()\n\n##--------------------------------------------------\n## Testing\n\n# A \"basic test\" consists of a foo.c source file. All basic tests use the\n# same basic_test.run driver script. The test name is passed as an additional\n# parameter to the driver script. This script just does\n# \"compare_test EXIT-SUCCESS\", i.e. records and replays the program and verifies\n# that the output of both runs is identical and contains EXIT-SUCCESS.\n#\n# NB: you must update this variable when adding a new test source\n# file.  The list is not generated automatically.\n#\n# Alphabetical, please.\nset(BASIC_TESTS\n  64bit_child\n  _llseek\n  accept\n  alarm\n  alarm2\n  alsa_ioctl\n  arch_prctl\n  async_segv_ignored\n  at_threadexit\n  bad_ip\n  bad_syscall\n  barrier\n  big_buffers\n  block\n  block_open\n  brk\n  brk2\n  capget\n  chew_cpu\n  chmod\n  chown\n  clock\n  clock_nanosleep\n  clone\n  clone_bad_stack\n  clone_bad_tls\n  clone_file_range\n  clone_immediate_exit\n  clone_newflags\n  clone_untraced\n  cloned_sigmask\n  constructor\n  creat_address_not_truncated\n  cwd_inaccessible\n  daemon\n  daemon_read\n  desched_blocking_poll\n  dup\n  doublesegv\n  epoll_create\n  epoll_create1\n  eventfd\n  exec_flags\n  exec_no_env\n  exec_self\n  exec_from_main_thread\n  exec_from_other_thread\n  exit_with_syscallbuf_signal\n  fadvise\n  fanotify\n  fault_in_code_page\n  fcntl_owner_ex\n  fcntl_dupfd\n  fcntl_seals\n  fcntl_sig\n  fd_tracking_across_threads\n  fds_clean\n  flock\n  flock2\n  fork_brk\n  fork_child_crash\n  fork_stress\n  futex_pi\n  futex_priorities\n  fxregs\n  getcpu\n  getgroups\n  getpwnam\n  getrandom\n  setitimer\n  getsid\n  gettimeofday\n  grandchild_threads\n  grandchild_threads_main_running\n  grandchild_threads_thread_running\n  grandchild_threads_parent_alive\n  inotify\n  int3\n  intr_futex_wait_restart\n  intr_poll\n  intr_ppoll\n  intr_pselect\n  intr_read_no_restart\n  intr_read_restart\n  intr_sleep\n  intr_sleep_no_restart\n  invalid_fcntl\n  invalid_ioctl\n  io\n  ioctl\n  ioctl_pty\n  ioctl_tty\n  kcmp\n  kill_newborn\n  legacy_ugid\n  madvise\n  madvise_free\n  map_fixed\n  membarrier\n  memfd_create\n  mincore\n  mknod\n  mlock\n  mmap_discontinuous\n  mmap_private\n  mmap_ro\n  mmap_self_maps_shared\n  mmap_shared\n  mmap_shared_multiple\n  mmap_shared_subpage\n  mmap_shared_write\n  mmap_short_file\n  mmap_tmpfs\n  mprotect\n  mprotect_heterogenous\n  mprotect_none\n  mprotect_stack\n  mq\n  mremap\n  mremap_grow\n  mremap_grow_shared\n  mremap_non_page_size\n  mremap_shrink\n  msg\n  msync\n  mtio\n  multiple_pending_signals\n  multiple_pending_signals_sequential\n  munmap_segv\n  munmap_discontinuous\n  nanosleep\n  no_mask_timeslice\n  numa\n  old_fork\n  orphan_process\n  packet_mmap_disable\n  pause\n  perf_event\n  personality\n  pthread_rwlocks\n  poll_sig_race\n  ppoll\n  prctl\n  prctl_deathsig\n  prctl_name\n  prctl_tsc\n  proc_fds\n  proc_mem\n  protect_rr_fds\n  prw\n  pthread_condvar_locking\n  ptrace\n  ptrace_attach_null_status\n  ptrace_attach_running\n  ptrace_attach_sleeping\n  ptrace_attach_stopped\n  ptrace_attach_thread_running\n  ptrace_breakpoint\n  ptrace_debug_regs\n  ptrace_exec\n  ptrace_exec32\n  ptrace_seize\n  ptrace_sigchld_blocked\n  ptrace_signals\n  ptrace_syscall\n  ptrace_syscall_clone_untraced\n  ptrace_sysemu\n  ptrace_trace_clone\n  ptrace_trace_exit\n  ptracer_death\n  ptracer_death_multithread\n  ptracer_death_multithread_peer\n  quotactl\n  rdtsc\n  read_nothing\n  readdir\n  read_large\n  read_oversize\n  readlink\n  readlinkat\n  readv\n  recvfrom\n  rename\n  rlimit\n  robust_futex\n  rusage\n  samask\n  save_data_fd\n  # sched_attr ... disabled since suitable headers are not widely available yet\n  sched_setaffinity\n  sched_setparam\n  sched_yield\n  sched_yield_to_lower_priority\n  scm_rights\n  seccomp\n  seccomp_null\n  seccomp_tsync\n  self_sigint\n  sem\n  sendfile\n  set_ptracer\n  set_tid_address\n  setgid\n  setgroups\n  setsid\n  setuid\n  shm\n  sigaction_old\n  sigaltstack\n  sigchld_interrupt_signal\n  sigcont\n  sighandler_fork\n  sigill\n  signal_deferred\n  signal_unstoppable\n  signalfd\n  sigprocmask\n  sigprocmask_in_syscallbuf_sighandler\n  sigprocmask_rr_sigs\n  sigprocmask_syscallbuf\n  sigqueueinfo\n  sigreturn\n  sigreturn_reg\n  sigreturnmask\n  sigrt\n  sigstop\n  sigstop2\n  sigsuspend\n  sigtrap\n  simple\n  sioc\n  sock_names_opts\n  spinlock_priorities\n  splice\n  stack_growth_after_syscallbuf\n  stack_growth_syscallbuf\n  stack_growth_with_guard\n  stack_overflow\n  stack_overflow_altstack\n  stack_overflow_with_guard\n  statfs\n  stdout_child\n  stdout_cloexec\n  stdout_dup\n  stdout_redirect\n  strict_priorities\n  switch_read\n  symlink\n  sync\n  syscall_bp\n  syscallbuf_signal_reset\n  syscallbuf_sigstop\n  syscallbuf_timeslice\n  syscallbuf_timeslice2\n  sysconf\n  sysctl\n  sysemu_singlestep\n  sysinfo\n  tgkill\n  thread_stress\n  thread_yield\n  timer\n  timerfd\n  times\n  truncate\n  uname\n  unjoined_thread\n  unshare\n  utimes\n  vfork_flush\n  vfork_shared\n  video_capture\n  vm_readv_writev\n  wait\n  wait_sigstop\n  write_race\n  writev\n  xattr\n  zero_length_read\n)\n\nset(BASIC_CPP_TESTS\n  std_random\n)\n\n# A \"test with program\" consists of a foo.c source file and a foo.run driver\n# script.  See src/test/util.sh to learn how the .run files work.\n#\n# NB: you must update this variable when adding a new test source\n# file.  The list is not generated automatically.\n#\n# Alphabetical, please.\nset(TESTS_WITH_PROGRAM\n  abort_nonmain\n  args\n  async_kill_with_threads\n  async_kill_with_threads_main_running\n  async_kill_with_threads_thread_running\n  async_segv\n  async_signal_syscalls\n  async_signal_syscalls2\n  async_signal_syscalls_siginfo\n  async_usr1\n  block_clone_checkpoint\n  block_clone_interrupted\n  block_clone_syscallbuf_overflow\n  block_intr_sigchld\n  blocked_bad_ip\n  blocked_sigill\n  blocked_sigsegv\n  breakpoint\n  breakpoint_conditions\n  breakpoint_overlap\n  call_function\n  # Disabled because it's very slow\n  # check_session_leaks\n  checkpoint_dying_threads\n  checkpoint_mixed_mode\n  checksum_sanity\n  clone_interruption\n  clone_vfork\n  conditional_breakpoint_calls\n  conditional_breakpoint_offload\n  condvar_stress\n  crash\n  crash_in_function\n  dconf_mock\n  dev_tty\n  dlopen\n  execve_loop\n  exit_codes\n  exit_group\n  exit_status\n  explicit_checkpoints\n  fork_syscalls\n  function_calls\n  getcwd\n  goto_event\n  hello\n  # Disabled because issue #1806 makes tests fail on Debian 8.5 at least\n  # history\n  ignored_async_usr1\n  ignored_sigsegv\n  immediate_restart\n  int3_ok\n  interrupt\n  intr_ptrace_decline\n  invalid_jump\n  link\n  madvise_dontfork\n  main_thread_exit\n  mmap_shared_prot\n  mmap_write\n  mprotect_growsdown\n  mprotect_syscallbuf_overflow\n  mutex_pi_stress\n  priority\n  ptrace_remote_unmap\n  # Not called ps, because that interferes with using real 'ps' in tests\n  rr_ps\n  read_big_struct\n  restart_abnormal_exit\n  reverse_continue_breakpoint\n  reverse_continue_multiprocess\n  reverse_continue_process_signal\n  reverse_many_breakpoints\n  reverse_step_long\n  reverse_step_threads\n  reverse_step_threads_break\n  search\n  segfault\n  shared_map\n  shared_persistent_file\n  signal_numbers\n  stack_growth\n  step_thread\n  string_instructions\n  string_instructions_async_signals\n  string_instructions_replay\n  string_instructions_watch\n  syscallbuf_fd_disabling\n  target_fork\n  target_process\n  term_nonmain\n  term_rr\n  term_trace_syscall\n  thread_exit_signal\n  threaded_syscall_spam\n  threads\n  tls\n  ttyname\n  unexpected_stack_growth\n  user_ignore_sig\n  vfork\n  wait_for_all\n  watchpoint\n  watchpoint_at_sched\n  watchpoint_before_signal\n  watchpoint_syscall\n  watchpoint_unaligned\n)\n\n# A \"test without program\" is a foo.run driver script only, which does\n# something with one of the test executables above (or has special rules\n# to build its own executable).\n#\n# NB: you must update this variable when adding a new test source\n# file.  The list is not generated automatically.\n#\n# Alphabetical, please.\nset(TESTS_WITHOUT_PROGRAM\n  async_signal_syscalls_100\n  async_signal_syscalls_1000\n  bad_breakpoint\n  break_block\n  break_clock\n  break_clone\n  break_exec\n  break_int3\n  break_mmap_private\n  break_msg\n  break_rdtsc\n  break_sigreturn\n  break_sync_signal\n  break_thread\n  break_time_slice\n  breakpoint_consistent\n  call_exit\n  check_patched_pthread\n  checkpoint_async_signal_syscalls_1000\n  checkpoint_mmap_shared\n  checkpoint_prctl_name\n  checkpoint_simple\n  cont_signal\n  cpuid\n  dead_thread_target\n  desched_ticks\n  deliver_async_signal_during_syscalls\n  env_newline\n  exec_deleted\n  exec_stop\n  execp\n  explicit_checkpoint_clone\n  final_sigkill\n  first_instruction\n  fork_exec_info_thr\n  gcrypt_rdrand\n  get_thread_list\n  hardlink_mmapped_files\n  mprotect_step\n  parent_no_break_child_bkpt\n  parent_no_stop_child_crash\n  post_exec_fpu_regs\n  read_bad_mem\n  record_replay\n  remove_watchpoint\n  restart_invalid_checkpoint\n  restart_unstable\n  restart_diversion\n  reverse_alarm\n  reverse_continue_exec_subprocess\n  reverse_continue_fork_subprocess\n  reverse_continue_start\n  reverse_finish\n  reverse_step_breakpoint\n  reverse_step_signal\n  reverse_step_threads2\n  reverse_watchpoint\n  reverse_watchpoint_syscall\n  run_end\n  run_in_function\n  sanity\n  shm_checkpoint\n  signal_stop\n  signal_checkpoint\n  simple_script\n  simple_script_debug\n  simple_winch\n  stack_overflow_debug\n  step1\n  step_rdtsc\n  step_signal\n  string_instructions_break\n  string_instructions_replay_quirk\n  subprocess_exit_ends_session\n  switch_processes\n  syscallbuf_timeslice_250\n  trace_version\n  term_trace_cpu\n  unwind_on_signal\n  vfork_exec\n  when\n)\n\nforeach(test ${BASIC_TESTS} ${TESTS_WITH_PROGRAM})\n  add_executable(${test} src/test/${test}.c)\n  post_build_executable(${test})\n  set_source_files_properties(src/test/${test}.c\n                              PROPERTIES COMPILE_FLAGS ${CMAKE_C_FLAGS_DEBUG})\n  add_dependencies(${test} Generated)\n  target_link_libraries(${test} -lrt -ldl)\nendforeach(test)\n\n# Test disabled because it requires libuvc to be built and installed, and a\n# working USB camera\n# add_executable(usb src/test/usb.c)\n# post_build_executable(usb)\n# add_dependencies(usb Generated)\n# target_link_libraries(usb -lrt -L/usr/local/lib -luvc -lusb-1.0)\n\nforeach(test ${BASIC_CPP_TESTS})\n  add_executable(${test} src/test/${test}.cc)\n  post_build_executable(${test})\n  set_source_files_properties(src/test/${test}.cc\n                              PROPERTIES COMPILE_FLAGS ${CMAKE_CXX_FLAGS_DEBUG})\n  add_dependencies(${test} Generated)\n  target_link_libraries(${test} -lrt)\nendforeach(test)\n\nadd_library(test_lib\n  src/test/test_lib.c\n)\nadd_dependencies(test_lib Generated)\ntarget_link_libraries(constructor -lrt test_lib)\n\n# cpuid test needs to link with cpuid_loop.S\nadd_executable(cpuid src/test/cpuid.c src/test/cpuid_loop.S)\npost_build_executable(cpuid)\nadd_dependencies(cpuid Generated)\ntarget_link_libraries(cpuid -lrt)\n\nfunction(configure_test test)\n  if(\"${test}\" MATCHES \"^checkpoint_\")\n    set(TIMEOUT 600)\n  elseif(\"${test}\" MATCHES \"stress\")\n    set(TIMEOUT 600)\n  else()\n    set(TIMEOUT 120)\n  endif()\n  set_tests_properties(${test}\n    PROPERTIES FAIL_REGULAR_EXPRESSION \"FAILED\" TIMEOUT ${TIMEOUT})\nendfunction(configure_test)\n\nforeach(test ${BASIC_TESTS} ${BASIC_CPP_TESTS} ${OTHER_TESTS})\n  add_test(${test}\n    bash ${CMAKE_SOURCE_DIR}/src/test/basic_test.run -b ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test})\n  configure_test(${test})\n  add_test(${test}-no-syscallbuf\n    bash ${CMAKE_SOURCE_DIR}/src/test/basic_test.run -n ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test})\n  configure_test(${test}-no-syscallbuf)\nendforeach(test)\n\nforeach(test ${TESTS_WITH_PROGRAM} ${TESTS_WITHOUT_PROGRAM})\n  add_test(${test}\n    bash ${CMAKE_SOURCE_DIR}/src/test/${test}.run -b ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test})\n  configure_test(${test})\n  add_test(${test}-no-syscallbuf\n    bash ${CMAKE_SOURCE_DIR}/src/test/${test}.run -n ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test})\n  configure_test(${test}-no-syscallbuf)\nendforeach(test)\n\n# Run 32-bit tests on 64-bit builds.\n# We copy the test files into '32' subdirectories in the output\n# directory, so we can set different compile options on them.\n# This sucks but I can't find a better way to get CMake to build\n# the same source file in two different ways.\nif(rr_32BIT AND rr_64BIT)\n  configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/test/rrutil.h\"\n                 \"${CMAKE_CURRENT_BINARY_DIR}/32/rrutil.h\"\n                 COPYONLY)\n\n  foreach(test ${BASIC_TESTS} ${TESTS_WITH_PROGRAM} cpuid test_lib)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/test/${test}.c\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.c\"\n                   COPYONLY)\n    set_source_files_properties(\"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.c\"\n                                PROPERTIES COMPILE_FLAGS \"-m32 ${CMAKE_C_FLAGS_DEBUG}\")\n  endforeach(test)\n\n  foreach(test ${BASIC_CPP_TESTS})\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/test/${test}.cc\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.cc\"\n                   COPYONLY)\n    set_source_files_properties(\"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.cc\"\n                                PROPERTIES COMPILE_FLAGS \"-m32 ${CMAKE_CXX_FLAGS_DEBUG}\")\n  endforeach(test)\n\n  foreach(file cpuid_loop.S)\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/src/test/${file}\"\n                   \"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                   COPYONLY)\n    set_source_files_properties(\"${CMAKE_CURRENT_BINARY_DIR}/32/${file}\"\n                                PROPERTIES COMPILE_FLAGS -m32)\n  endforeach(file)\n\n  foreach(test ${BASIC_TESTS} ${TESTS_WITH_PROGRAM})\n    add_executable(${test}_32 \"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.c\")\n    post_build_executable(${test}_32)\n    add_dependencies(${test}_32 Generated)\n    set_target_properties(${test}_32 PROPERTIES LINK_FLAGS \"-m32 ${CMAKE_C_FLAGS_DEBUG}\")\n    target_link_libraries(${test}_32 -lrt -ldl)\n  endforeach(test)\n\n  foreach(test ${BASIC_CPP_TESTS})\n    add_executable(${test}_32 \"${CMAKE_CURRENT_BINARY_DIR}/32/${test}.cc\")\n    post_build_executable(${test}_32)\n    add_dependencies(${test}_32 Generated)\n    set_target_properties(${test}_32 PROPERTIES LINK_FLAGS \"-m32 ${CMAKE_CXX_FLAGS_DEBUG}\")\n    target_link_libraries(${test}_32 -lrt)\n  endforeach(test)\n\n  add_library(test_lib_32\n    \"${CMAKE_CURRENT_BINARY_DIR}/32/test_lib.c\"\n  )\n  add_dependencies(test_lib_32 Generated)\n  set_target_properties(test_lib_32 PROPERTIES LINK_FLAGS -m32)\n\n  target_link_libraries(constructor_32 -lrt test_lib_32)\n\n  # cpuid test needs to link with cpuid_loop.S\n  add_executable(cpuid_32 32/cpuid.c 32/cpuid_loop.S)\n  post_build_executable(cpuid_32)\n  add_dependencies(cpuid_32 Generated)\n  set_target_properties(cpuid_32 PROPERTIES LINK_FLAGS -m32)\n  target_link_libraries(cpuid_32 -lrt)\n\n  foreach(test ${BASIC_TESTS} ${BASIC_CPP_TESTS} ${OTHER_TESTS})\n    add_test(${test}-32\n      bash ${CMAKE_SOURCE_DIR}/src/test/basic_test.run -b ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test}_32)\n    configure_test(${test}-32)\n    add_test(${test}-32-no-syscallbuf\n      bash ${CMAKE_SOURCE_DIR}/src/test/basic_test.run -n ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test}_32)\n    configure_test(${test}-32-no-syscallbuf)\n  endforeach(test)\n\n  foreach(test ${TESTS_WITH_PROGRAM} ${TESTS_WITHOUT_PROGRAM})\n    add_test(${test}-32\n      bash ${CMAKE_SOURCE_DIR}/src/test/${test}.run -b ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test}_32)\n    configure_test(${test}-32)\n    add_test(${test}-32-no-syscallbuf\n      bash ${CMAKE_SOURCE_DIR}/src/test/${test}.run -n ${CMAKE_SOURCE_DIR} ${PROJECT_BINARY_DIR} ${test}_32)\n    configure_test(${test}-32-no-syscallbuf)\n  endforeach(test)\nendif()\n\nset(CHAOS_TESTS\n  core_count\n  mmap_adjacent\n  mmap_bits\n  starvation_multithreaded\n  starvation_singlethreaded\n)\n\nforeach(test ${CHAOS_TESTS})\n  add_executable(${test} src/chaos-test/${test}.c)\n  post_build_executable(${test})\n  target_link_libraries(${test} -lrt)\nendforeach(test)\n\nadd_executable(ftrace_helper src/ftrace/ftrace_helper.c)\n\ninclude(ProcessorCount)\nProcessorCount(N)\nif(NOT N EQUAL 0)\n  set(JFLAG -j${N})\nendif()\n\nadd_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND} --verbose ${JFLAG})\n# Run only syscallbuf-enabled and native-bitness tests\nadd_custom_target(fastcheck COMMAND ${CMAKE_CTEST_COMMAND} --verbose --exclude-regex '[-]' ${JFLAG})\n\n##--------------------------------------------------\n## Package configuration\n\ninclude (InstallRequiredSystemLibraries)\n\nset(CPACK_PACKAGE_NAME \"rr\")\nset(CPACK_PACKAGE_VERSION_MAJOR \"${rr_VERSION_MAJOR}\")\nset(CPACK_PACKAGE_VERSION_MINOR \"${rr_VERSION_MINOR}\")\nset(CPACK_PACKAGE_VERSION_PATCH \"${rr_VERSION_PATCH}\")\nset(CPACK_SYSTEM_NAME \"${CMAKE_SYSTEM_NAME}-${CMAKE_SYSTEM_PROCESSOR}\")\n\nset(CPACK_OUTPUT_FILE_PREFIX dist)\nset(CPACK_GENERATOR \"TGZ;RPM;DEB\")\nset(CPACK_SOURCE_GENERATOR \"TGZ\")\nset(CPACK_BINARY_DIR \"${PROJECT_BINARY_DIR}\")\nset(CPACK_STRIP_FILES TRUE)\n\nset(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_SOURCE_DIR}/LICENSE\")\nset(CPACK_PACKAGE_DESCRIPTION_SUMMARY\n  \"Lightweight tool for recording and replaying execution of applications (trees of processes and threads)\")\nset(CPACK_PACKAGE_DESCRIPTION_FILE \"${CMAKE_SOURCE_DIR}/README.md\")\nset(CPACK_PACKAGE_VENDOR \"Mozilla Foundation\")\n\nset(CPACK_DEBIAN_PACKAGE_MAINTAINER \"Mozilla Foundation\")\nset(CPACK_DEBIAN_PACKAGE_SECTION \"devel\")\nif(${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"x86_64\")\n  set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"amd64\")\nelseif(${CMAKE_SYSTEM_PROCESSOR} MATCHES \"i.86\")\n  set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"i386\")\nelseif(${CMAKE_SYSTEM_PROCESSOR} MATCHES \"arm.*\")\n  set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"arm\")\nendif()\n\n# XXX Cmake 2.8.7 doesn't know how to avoid specifying /usr,\n# /usr/bin, etc, as files to be installed, but distros are finicky\n# about their specification.  We want to manually filter those paths\n# out of our install list but 2.8.7 also isn't capable of that.\nset(CPACK_RPM_USER_BINARY_SPECFILE \"${CMAKE_SOURCE_DIR}/rr.spec\")\nset(CPACK_RPM_PACKAGE_RELEASE 1)\nset(CPACK_RPM_PACKAGE_GROUP \"Development/Debuggers\")\nset(CPACK_RPM_PACKAGE_LICENSE \"MIT and BSD\")\n\ninclude (CPack)\n\n##--------------------------------------------------\n## Misc\n\nadd_custom_target(setup-travis COMMAND src/script/setup_travis.sh)\n",
        "/tmp/vanessa/spack-stage/spack-stage-rr-4.4.0-cfxjrjkkrrq6os4jvxt3xpl2w2lunns3/spack-src/src/ThreadDb.cc": "/* -*- Mode: C++; tab-width: 8; c-basic-offset: 2; indent-tabs-mode: nil; -*- */\n\n#include \"ThreadDb.h\"\n#include \"GdbServer.h\"\n#include \"Task.h\"\n#include \"TaskGroup.h\"\n#include \"log.h\"\n\nextern \"C\" {\n// The proc_service/thread_db library has a very weird API.  It\n// requires the user of the library to provide certain functions which\n// it links to (rather than, say, having the library user supply a\n// struct of function pointers).  We have to ensure that these\n// functions have C linkage, so that libthread_db can find them.\n#include \"proc_service.h\"\n}\n\n#include <asm/prctl.h>\n#include <dlfcn.h>\n#include <linux/elf.h>\n#include <sys/reg.h>\n\n#define LIBRARY_NAME \"libthread_db.so.1\"\n\n// Needed for the logging API.\nusing namespace rr;\n\nps_err_e ps_pglobal_lookup(struct ps_prochandle* h, const char*,\n                           const char* symbol, psaddr_t* sym_addr) {\n  rr::remote_ptr<void> addr;\n  if (!h->db->query_symbol(symbol, &addr)) {\n    LOG(debug) << \"ps_pglobal_lookup \" << symbol << \" failed\";\n    return PS_NOSYM;\n  }\n  *sym_addr = reinterpret_cast<psaddr_t>(addr.as_int());\n  LOG(debug) << \"ps_pglobal_lookup \" << symbol << \" OK\";\n  return PS_OK;\n}\n\nps_err_e ps_pdread(struct ps_prochandle* h, psaddr_t addr, void* buffer,\n                   size_t len) {\n  bool ok = true;\n  uintptr_t uaddr = reinterpret_cast<uintptr_t>(addr);\n  // We need any task associated with the task group.  Here we assume\n  // that all the tasks in the task group share VM, which is enforced\n  // by clone(2).\n  rr::Task* task = *h->task_group->task_set().begin();\n  task->read_bytes_helper(uaddr, len, buffer, &ok);\n  LOG(debug) << \"ps_pdread \" << ok;\n  return ok ? PS_OK : PS_ERR;\n}\n\nps_err_e ps_pdwrite(struct ps_prochandle*, psaddr_t, const void*, size_t) {\n  FATAL() << \"ps_pdwrite not implemented\";\n  return PS_ERR;\n}\n\nps_err_e ps_lgetregs(struct ps_prochandle* h, lwpid_t rec_tid,\n                     prgregset_t result) {\n  rr::Task* task = h->task_group->session()->find_task(rec_tid);\n  assert(task != nullptr);\n\n  struct ::user_regs_struct regs = task->regs().get_ptrace();\n  memcpy(result, static_cast<void*>(&regs), sizeof(regs));\n  LOG(debug) << \"ps_lgetregs OK\";\n  return PS_OK;\n}\n\nps_err_e ps_lsetregs(struct ps_prochandle*, lwpid_t, const prgregset_t) {\n  FATAL() << \"ps_lsetregs not implemented\";\n  return PS_ERR;\n}\n\nps_err_e ps_lgetfpregs(struct ps_prochandle*, lwpid_t, prfpregset_t*) {\n  FATAL() << \"ps_lgetfpregs not implemented\";\n  return PS_ERR;\n}\n\nps_err_e ps_lsetfpregs(struct ps_prochandle*, lwpid_t, const prfpregset_t*) {\n  FATAL() << \"ps_lsetfpregs not implemented\";\n  return PS_ERR;\n}\n\npid_t ps_getpid(struct ps_prochandle* h) {\n  LOG(debug) << \"ps_getpid \" << h->task_group->tgid;\n  return h->task_group->tgid;\n}\n\nps_err_e ps_get_thread_area(const struct ps_prochandle* h, lwpid_t rec_tid,\n                            int val, psaddr_t* base) {\n  rr::Task* task = h->task_group->session()->find_task(rec_tid);\n  assert(task != nullptr);\n\n  if (task->arch() == rr::x86) {\n    unsigned int uval = static_cast<unsigned int>(val);\n    for (auto& area : task->thread_areas()) {\n      if (area.entry_number == uval) {\n        uintptr_t result = static_cast<uintptr_t>(area.base_addr);\n        *base = reinterpret_cast<psaddr_t>(result);\n        return PS_OK;\n      }\n    }\n    LOG(debug) << \"ps_get_thread_area 32 failed\";\n    return PS_ERR;\n  }\n\n  uintptr_t result;\n  switch (val) {\n    case FS:\n      result = task->regs().fs_base();\n      break;\n    case GS:\n      result = task->regs().gs_base();\n      break;\n    default:\n      LOG(debug) << \"ps_get_thread_area PS_BADADDR\";\n      return PS_BADADDR;\n  }\n\n  *base = reinterpret_cast<psaddr_t>(result);\n  return PS_OK;\n}\n\nrr::ThreadDb::ThreadDb(TaskGroup* task_group)\n    : internal_handle(nullptr),\n      thread_db_library(nullptr),\n      td_ta_delete_fn(nullptr),\n      td_thr_tls_get_addr_fn(nullptr),\n      td_ta_map_lwp2thr_fn(nullptr) {\n  prochandle.task_group = task_group;\n  prochandle.db = this;\n}\n\nrr::ThreadDb::~ThreadDb() {\n  if (internal_handle) {\n    td_ta_delete_fn(internal_handle);\n  }\n  if (thread_db_library) {\n    dlclose(thread_db_library);\n  }\n}\n\nconst std::set<std::string> rr::ThreadDb::get_symbols_and_clear_map() {\n  // If we think the symbol locations might have changed, then we\n  // probably need to recreate the handle.\n  if (internal_handle) {\n    td_ta_delete_fn(internal_handle);\n    internal_handle = nullptr;\n  }\n\n  symbols.clear();\n  load_library();\n  return symbol_names;\n}\n\nvoid rr::ThreadDb::register_symbol(const std::string& name,\n                                   remote_ptr<void> address) {\n  LOG(debug) << \"register_symbol \" << name;\n  symbols[name] = address;\n}\n\nbool rr::ThreadDb::query_symbol(const char* name, remote_ptr<void>* address) {\n  auto it = symbols.find(name);\n  if (it == symbols.end()) {\n    return false;\n  }\n  *address = it->second;\n  return true;\n}\n\nbool rr::ThreadDb::get_tls_address(pid_t rec_tid, size_t offset,\n                                   remote_ptr<void> load_module,\n                                   remote_ptr<void>* result) {\n  if (!initialize()) {\n    return false;\n  }\n\n  td_thrhandle_t th;\n  if (td_ta_map_lwp2thr_fn(internal_handle, rec_tid, &th) != TD_OK) {\n    return false;\n  }\n\n  psaddr_t load_module_addr = reinterpret_cast<psaddr_t>(load_module.as_int());\n  psaddr_t addr;\n  if (td_thr_tls_get_addr_fn(&th, load_module_addr, offset, &addr) != TD_OK) {\n    return false;\n  }\n  *result = remote_ptr<void>(reinterpret_cast<uintptr_t>(addr));\n  return true;\n}\n\nbool rr::ThreadDb::initialize() {\n  if (internal_handle) {\n    return true;\n  }\n\n  if (!load_library()) {\n    return false;\n  }\n\n  if (!td_ta_new_fn || td_ta_new_fn(&prochandle, &internal_handle) != TD_OK) {\n    LOG(debug) << \"initialize td_ta_new_fn failed\";\n    return false;\n  }\n\n  LOG(debug) << \"initialize OK\";\n  return true;\n}\n\nbool rr::ThreadDb::load_library() {\n  if (thread_db_library) {\n    LOG(debug) << \"load_library already loaded: \" << loaded;\n    return loaded;\n  }\n\n  thread_db_library = dlopen(LIBRARY_NAME, RTLD_NOW);\n  if (!thread_db_library) {\n    LOG(debug) << \"load_library dlopen failed\";\n    return false;\n  }\n\n  decltype(td_symbol_list)* td_symbol_list_fn;\n\n#define FIND_FUNCTION(Name)                                                    \\\n  do {                                                                         \\\n    Name##_fn = (decltype(Name)*)(dlsym(thread_db_library, #Name));            \\\n    if (!Name##_fn) {                                                          \\\n      LOG(debug) << \"load_library failed to find \" << #Name;                   \\\n      return false;                                                            \\\n    }                                                                          \\\n  } while (0)\n\n  FIND_FUNCTION(td_thr_tls_get_addr);\n  FIND_FUNCTION(td_ta_delete);\n  FIND_FUNCTION(td_symbol_list);\n  FIND_FUNCTION(td_ta_new);\n  FIND_FUNCTION(td_ta_map_lwp2thr);\n\n#undef FIND_FUNCTION\n\n  for (const char** syms = td_symbol_list_fn(); *syms; ++syms) {\n    symbol_names.insert(*syms);\n  }\n\n  // Good to go.\n  loaded = true;\n  LOG(debug) << \"load_library OK\";\n  return true;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rr-4.4.0-cfxjrjkkrrq6os4jvxt3xpl2w2lunns3/spack-src/src/test/dlopen.c": "/* -*- Mode: C; tab-width: 8; c-basic-offset: 2; indent-tabs-mode: nil; -*- */\n\n#include \"rrutil.h\"\n\nint main(void) {\n  void* h = dlopen(\"libX11.so\", RTLD_LAZY);\n  if (h) {\n    dlclose(h);\n  }\n  atomic_puts(\"EXIT-SUCCESS\");\n  return 0;\n}\n"
    },
    "skipped": [],
    "total_files": 876
}