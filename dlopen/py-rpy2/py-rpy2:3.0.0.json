{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-rpy2-3.0.0-fmtdynme7muvmxgjixr33ostjaifpw22/spack-src/rpy/rinterface_lib/openrlib.py": "import platform\nimport rpy2.situation\nfrom _rinterface_cffi import ffi\n\n\n# TODO: Separate the functions in the module from the side-effect of\n# finding R_HOME and opening the shared library.\nR_HOME = rpy2.situation.get_r_home()\n\n\ndef _dlopen_rlib(r_home: str):\n    \"\"\"Open R's shared C library.\"\"\"\n    if r_home is None:\n        raise ValueError('r_home is None. '\n                         'Try python -m rpy2.situation')\n    lib_path = rpy2.situation.get_rlib_path(r_home, platform.system())\n    rlib = ffi.dlopen(lib_path)\n    return rlib\n\n\nrlib = _dlopen_rlib(R_HOME)\n\n\n# R macros and functions\ndef _get_symbol_or_fallback(symbol: str, fallback):\n    \"\"\"Get a cffi object from rlib, or the fallback if missing.\"\"\"\n    try:\n        res = getattr(rlib, symbol)\n    except ffi.error:\n        res = fallback\n    return res\n\n\ndef _get_dataptr_fallback(vec):\n    # DATAPTR seems to be the following macro in R < 3.5\n    # but I cannot get it to work (seems to be pointing\n    # to incorrect memory region).\n    # (((SEXPREC_ALIGN *)(x)) + 1)\n    raise NotImplementedError()\n\n\nDATAPTR = _get_symbol_or_fallback('DATAPTR',\n                                  _get_dataptr_fallback)\n\n\ndef _LOGICAL(x):\n    return ffi.cast('int *', DATAPTR(x))\n\n\nLOGICAL = rlib.LOGICAL\n\n\ndef _INTEGER(x):\n    return ffi.cast('int *', DATAPTR(x))\n\n\nINTEGER = rlib.INTEGER\n\n\ndef _RAW(x):\n    return ffi.cast('Rbyte *', DATAPTR(x))\n\n\nRAW = rlib.RAW\n\n\ndef _REAL(robj):\n    return ffi.cast('double *', DATAPTR(robj))\n\n\nREAL = rlib.REAL\n\n\ndef _COMPLEX(robj):\n    return ffi.cast('Rcomplex *', DATAPTR(robj))\n\n\nCOMPLEX = rlib.COMPLEX\n\n\ndef _get_raw_elt_fallback(vec, i: int):\n    return RAW(vec)[i]\n\n\nRAW_ELT = _get_symbol_or_fallback('RAW_ELT',\n                                  _get_raw_elt_fallback)\n\n\ndef _get_integer_elt_fallback(vec, i: int):\n    return INTEGER(vec)[i]\n\n\nINTEGER_ELT = _get_symbol_or_fallback('INTEGER_ELT',\n                                      _get_integer_elt_fallback)\n\n\ndef _set_integer_elt_fallback(vec, i: int, value):\n    INTEGER(vec)[i] = value\n\n\nSET_INTEGER_ELT = _get_symbol_or_fallback('SET_INTEGER_ELT',\n                                          _set_integer_elt_fallback)\n\n\ndef _get_logical_elt_fallback(vec, i: int):\n    return LOGICAL(vec)[i]\n\n\nLOGICAL_ELT = _get_symbol_or_fallback('LOGICAL_ELT',\n                                      _get_logical_elt_fallback)\n\n\ndef _set_logical_elt_fallback(vec, i: int, value):\n    LOGICAL(vec)[i] = value\n\n\nSET_LOGICAL_ELT = _get_symbol_or_fallback('SET_LOGICAL_ELT',\n                                          _set_logical_elt_fallback)\n\n\ndef _get_real_elt_fallback(vec, i: int):\n    return REAL(vec)[i]\n\n\nREAL_ELT = _get_symbol_or_fallback('REAL_ELT',\n                                   _get_real_elt_fallback)\n\n\ndef _set_real_elt_fallback(vec, i: int, value):\n    REAL(vec)[i] = value\n\n\nSET_REAL_ELT = _get_symbol_or_fallback('SET_REAL_ELT',\n                                       _set_real_elt_fallback)\n\n\ndef _get_complex_elt_fallback(vec, i: int):\n    return COMPLEX(vec)[i]\n\n\nCOMPLEX_ELT = _get_symbol_or_fallback('COMPLEX_ELT',\n                                      _get_complex_elt_fallback)\n\n\ndef SET_COMPLEX_ELT(vec, i: int, value: complex):\n    COMPLEX(vec)[i].r = value.real\n    COMPLEX(vec)[i].i = value.imag\n\n\n# TODO: still useful or is it in the C API ?\ndef _VECTOR_ELT(robj, i):\n    return ffi.cast('SEXP *', DATAPTR(robj))[i]\n\n\ndef _STRING_PTR(robj):\n    return ffi.cast('SEXP *', DATAPTR(robj))\n\n\ndef _VECTOR_PTR(robj):\n    return ffi.cast('SEXP *', DATAPTR(robj))\n\n\ndef _STRING_VALUE(robj):\n    return rlib.R_CHAR(rlib.Rf_asChar(robj))\n"
    },
    "skipped": [],
    "total_files": 55
}