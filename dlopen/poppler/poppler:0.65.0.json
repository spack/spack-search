{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/poppler/GlobalParams.cc": "//========================================================================\n//\n// GlobalParams.cc\n//\n// Copyright 2001-2003 Glyph & Cog, LLC\n//\n//========================================================================\n\n//========================================================================\n//\n// Modified under the Poppler project - http://poppler.freedesktop.org\n//\n// All changes made under the Poppler project to this file are licensed\n// under GPL version 2 or later\n//\n// Copyright (C) 2005 Martin Kretzschmar <martink@gnome.org>\n// Copyright (C) 2005, 2006 Kristian H\u00f8gsberg <krh@redhat.com>\n// Copyright (C) 2005, 2007-2010, 2012, 2015, 2017, 2018 Albert Astals Cid <aacid@kde.org>\n// Copyright (C) 2005 Jonathan Blandford <jrb@redhat.com>\n// Copyright (C) 2006, 2007 Jeff Muizelaar <jeff@infidigm.net>\n// Copyright (C) 2006 Takashi Iwai <tiwai@suse.de>\n// Copyright (C) 2006 Ed Catmur <ed@catmur.co.uk>\n// Copyright (C) 2007 Krzysztof Kowalczyk <kkowalczyk@gmail.com>\n// Copyright (C) 2007, 2009 Jonathan Kew <jonathan_kew@sil.org>\n// Copyright (C) 2009 Petr Gajdos <pgajdos@novell.com>\n// Copyright (C) 2009, 2011, 2012, 2015 William Bader <williambader@hotmail.com>\n// Copyright (C) 2009 Kovid Goyal <kovid@kovidgoyal.net>\n// Copyright (C) 2010, 2012 Hib Eris <hib@hiberis.nl>\n// Copyright (C) 2010 Patrick Spendrin <ps_ml@gmx.de>\n// Copyright (C) 2010 Jakub Wilk <jwilk@jwilk.net>\n// Copyright (C) 2011 Pino Toscano <pino@kde.org>\n// Copyright (C) 2011 Koji Otani <sho@bbr.jp>\n// Copyright (C) 2012 Yi Yang <ahyangyi@gmail.com>\n// Copyright (C) 2012, 2017 Adrian Johnson <ajohnson@redneon.com>\n// Copyright (C) 2012 Thomas Freitag <Thomas.Freitag@alfa.de>\n// Copyright (C) 2012 Peter Breitenlohner <peb@mppmu.mpg.de>\n// Copyright (C) 2013, 2014 Jason Crain <jason@aquaticape.us>\n// Copyright (C) 2017 Christoph Cullmann <cullmann@kde.org>\n// Copyright (C) 2017 Jean Ghali <jghali@libertysurf.fr>\n// Copyright (C) 2018 Klar\u00e4lvdalens Datakonsult AB, a KDAB Group company, <info@kdab.com>. Work sponsored by the LiMux project of the city of Munich\n// Copyright (C) 2018 Adam Reichold <adam.reichold@t-online.de>\n//\n// To see a description of the changes please see the Changelog file that\n// came with your tarball or type make ChangeLog if you are building from git\n//\n//========================================================================\n\n#include <config.h>\n\n#ifdef USE_GCC_PRAGMAS\n#pragma implementation\n#endif\n\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n#ifdef ENABLE_PLUGINS\n#  ifndef _WIN32\n#    include <dlfcn.h>\n#  endif\n#endif\n#ifdef _WIN32\n#  include <shlobj.h>\n#  include <mbstring.h>\n#endif\n#include \"goo/glibc.h\"\n#include \"goo/gmem.h\"\n#include \"goo/GooString.h\"\n#include \"goo/GooList.h\"\n#include \"goo/gfile.h\"\n#include \"Error.h\"\n#include \"NameToCharCode.h\"\n#include \"CharCodeToUnicode.h\"\n#include \"UnicodeMap.h\"\n#include \"CMap.h\"\n#include \"BuiltinFontTables.h\"\n#include \"FontEncodingTables.h\"\n#ifdef ENABLE_PLUGINS\n#  include \"XpdfPluginAPI.h\"\n#endif\n#include \"GlobalParams.h\"\n#include \"GfxFont.h\"\n\n#ifdef WITH_FONTCONFIGURATION_FONTCONFIG\n#include <fontconfig/fontconfig.h>\n#endif\n\n#ifdef _MSC_VER\n#  define strcasecmp stricmp\n#else\n#  include <strings.h>\n#endif\n\n#ifdef MULTITHREADED\n#  define lockGlobalParams            gLockMutex(&mutex)\n#  define lockUnicodeMapCache         gLockMutex(&unicodeMapCacheMutex)\n#  define lockCMapCache               gLockMutex(&cMapCacheMutex)\n#  define unlockGlobalParams          gUnlockMutex(&mutex)\n#  define unlockUnicodeMapCache       gUnlockMutex(&unicodeMapCacheMutex)\n#  define unlockCMapCache             gUnlockMutex(&cMapCacheMutex)\n#else\n#  define lockGlobalParams\n#  define lockUnicodeMapCache\n#  define lockCMapCache\n#  define unlockGlobalParams\n#  define unlockUnicodeMapCache\n#  define unlockCMapCache\n#endif\n\n#ifndef FC_WEIGHT_BOOK\n#define FC_WEIGHT_BOOK 75\n#endif\n\n#include \"NameToUnicodeTable.h\"\n#include \"UnicodeMapTables.h\"\n#include \"UnicodeMapFuncs.h\"\n\n#ifdef ENABLE_PLUGINS\n#  ifdef _WIN32\nextern XpdfPluginVecTable xpdfPluginVecTable;\n#  endif\n#endif\n\n//------------------------------------------------------------------------\n\n#define cidToUnicodeCacheSize     4\n#define unicodeToUnicodeCacheSize 4\n\n//------------------------------------------------------------------------\n\nGlobalParams *globalParams = nullptr;\n\n#if defined(ENABLE_RELOCATABLE) && defined(_WIN32)\n\n/* search for data relative to where we are installed */\n\nstatic HMODULE hmodule;\n\nextern \"C\" {\n  /* Provide declaration to squelch -Wmissing-declarations warning */\n  BOOL WINAPI\n  DllMain (HINSTANCE hinstDLL,\n\t   DWORD     fdwReason,\n\t   LPVOID    lpvReserved);\n\n  BOOL WINAPI\n  DllMain (HINSTANCE hinstDLL,\n\t   DWORD     fdwReason,\n\t   LPVOID    lpvReserved)\n  {\n    switch (fdwReason) {\n      case DLL_PROCESS_ATTACH:\n\thmodule = hinstDLL;\n\tbreak;\n    }\n\n    return TRUE;\n  }\n}\n\nstatic const char *\nget_poppler_datadir (void)\n{\n  static char retval[MAX_PATH];\n  static int beenhere = 0;\n\n  unsigned char *p;\n\n  if (beenhere)\n    return retval;\n\n  if (!GetModuleFileNameA (hmodule, (CHAR *) retval, sizeof(retval) - 20))\n    return POPPLER_DATADIR;\n\n  p = _mbsrchr ((unsigned char *) retval, '\\\\');\n  *p = '\\0';\n  p = _mbsrchr ((unsigned char *) retval, '\\\\');\n  if (p) {\n    if (stricmp ((const char *) (p+1), \"bin\") == 0)\n      *p = '\\0';\n  }\n  strcat (retval, \"\\\\share\\\\poppler\");\n\n  beenhere = 1;\n\n  return retval;\n}\n\n#undef POPPLER_DATADIR\n#define POPPLER_DATADIR get_poppler_datadir ()\n\n#endif\n\n//------------------------------------------------------------------------\n// SysFontInfo\n//------------------------------------------------------------------------\n\nclass SysFontInfo {\npublic:\n\n  GooString *name;\n  GBool bold;\n  GBool italic;\n  GBool oblique;\n  GBool fixedWidth;\n  GooString *path;\n  SysFontType type;\n  int fontNum;\t\t\t// for TrueType collections\n  GooString *substituteName;\n\n  SysFontInfo(GooString *nameA, GBool boldA, GBool italicA, GBool obliqueA, GBool fixedWidthA,\n\t      GooString *pathA, SysFontType typeA, int fontNumA, GooString *substituteNameA);\n  ~SysFontInfo();\n  SysFontInfo(const SysFontInfo &) = delete;\n  SysFontInfo& operator=(const SysFontInfo&) = delete;\n  GBool match(SysFontInfo *fi);\n  GBool match(GooString *nameA, GBool boldA, GBool italicA, GBool obliqueA, GBool fixedWidthA);\n  GBool match(GooString *nameA, GBool boldA, GBool italicA);\n};\n\nSysFontInfo::SysFontInfo(GooString *nameA, GBool boldA, GBool italicA, GBool obliqueA, GBool fixedWidthA,\n\t\t\t GooString *pathA, SysFontType typeA, int fontNumA, GooString *substituteNameA) {\n  name = nameA;\n  bold = boldA;\n  italic = italicA;\n  oblique = obliqueA;\n  fixedWidth = fixedWidthA;\n  path = pathA;\n  type = typeA;\n  fontNum = fontNumA;\n  substituteName = substituteNameA;\n}\n\nSysFontInfo::~SysFontInfo() {\n  delete name;\n  delete path;\n  delete substituteName;\n}\n\nGBool SysFontInfo::match(SysFontInfo *fi) {\n  return !strcasecmp(name->getCString(), fi->name->getCString()) &&\n         bold == fi->bold && italic == fi->italic && oblique == fi->oblique && fixedWidth == fi->fixedWidth;\n}\n\nGBool SysFontInfo::match(GooString *nameA, GBool boldA, GBool italicA, GBool obliqueA, GBool fixedWidthA) {\n  return !strcasecmp(name->getCString(), nameA->getCString()) &&\n         bold == boldA && italic == italicA && oblique == obliqueA && fixedWidth == fixedWidthA;\n}\n\nGBool SysFontInfo::match(GooString *nameA, GBool boldA, GBool italicA) {\n  return !strcasecmp(name->getCString(), nameA->getCString()) &&\n         bold == boldA && italic == italicA;\n}\n\n//------------------------------------------------------------------------\n// SysFontList\n//------------------------------------------------------------------------\n\nclass SysFontList {\npublic:\n\n  SysFontList();\n  ~SysFontList();\n  SysFontList(const SysFontList &) = delete;\n  SysFontList& operator=(const SysFontList &) = delete;\n  SysFontInfo *find(const GooString *name, GBool isFixedWidth, GBool exact);\n\n#ifdef _WIN32\n  void scanWindowsFonts(GooString *winFontDir);\n#endif\n#ifdef WITH_FONTCONFIGURATION_FONTCONFIG\n  void addFcFont(SysFontInfo *si) {fonts->append(si);}\n#endif\nprivate:\n\n#ifdef _WIN32\n  SysFontInfo *makeWindowsFont(char *name, int fontNum,\n\t\t\t       char *path);\n#endif\n\n  GooList *fonts;\t\t\t// [SysFontInfo]\n};\n\nSysFontList::SysFontList() {\n  fonts = new GooList();\n}\n\nSysFontList::~SysFontList() {\n  deleteGooList(fonts, SysFontInfo);\n}\n\nSysFontInfo *SysFontList::find(const GooString *name, GBool fixedWidth, GBool exact) {\n  GooString *name2;\n  GBool bold, italic, oblique;\n  SysFontInfo *fi;\n  char c;\n  int n, i;\n\n  name2 = name->copy();\n\n  // remove space, comma, dash chars\n  i = 0;\n  while (i < name2->getLength()) {\n    c = name2->getChar(i);\n    if (c == ' ' || c == ',' || c == '-') {\n      name2->del(i);\n    } else {\n      ++i;\n    }\n  }\n  n = name2->getLength();\n\n  // remove trailing \"MT\" (Foo-MT, Foo-BoldMT, etc.)\n  if (n > 2 && !strcmp(name2->getCString() + n - 2, \"MT\")) {\n    name2->del(n - 2, 2);\n    n -= 2;\n  }\n\n  // look for \"Regular\"\n  if (n > 7 && !strcmp(name2->getCString() + n - 7, \"Regular\")) {\n    name2->del(n - 7, 7);\n    n -= 7;\n  }\n\n  // look for \"Italic\"\n  if (n > 6 && !strcmp(name2->getCString() + n - 6, \"Italic\")) {\n    name2->del(n - 6, 6);\n    italic = gTrue;\n    n -= 6;\n  } else {\n    italic = gFalse;\n  }\n\n  // look for \"Oblique\"\n  if (n > 6 && !strcmp(name2->getCString() + n - 7, \"Oblique\")) {\n    name2->del(n - 7, 7);\n    oblique = gTrue;\n    n -= 6;\n  } else {\n    oblique = gFalse;\n  }\n\n  // look for \"Bold\"\n  if (n > 4 && !strcmp(name2->getCString() + n - 4, \"Bold\")) {\n    name2->del(n - 4, 4);\n    bold = gTrue;\n    n -= 4;\n  } else {\n    bold = gFalse;\n  }\n\n  // remove trailing \"MT\" (FooMT-Bold, etc.)\n  if (n > 2 && !strcmp(name2->getCString() + n - 2, \"MT\")) {\n    name2->del(n - 2, 2);\n    n -= 2;\n  }\n\n  // remove trailing \"PS\"\n  if (n > 2 && !strcmp(name2->getCString() + n - 2, \"PS\")) {\n    name2->del(n - 2, 2);\n    n -= 2;\n  }\n\n  // remove trailing \"IdentityH\"\n  if (n > 9 && !strcmp(name2->getCString() + n - 9, \"IdentityH\")) {\n    name2->del(n - 9, 9);\n    n -= 9;\n  }\n\n  // search for the font\n  fi = nullptr;\n  for (i = 0; i < fonts->getLength(); ++i) {\n    fi = (SysFontInfo *)fonts->get(i);\n    if (fi->match(name2, bold, italic, oblique, fixedWidth)) {\n      break;\n    }\n    fi = nullptr;\n  }\n  if (!fi && !exact && bold) {\n    // try ignoring the bold flag\n    for (i = 0; i < fonts->getLength(); ++i) {\n      fi = (SysFontInfo *)fonts->get(i);\n      if (fi->match(name2, gFalse, italic)) {\n\tbreak;\n      }\n      fi = nullptr;\n    }\n  }\n  if (!fi && !exact && (bold || italic)) {\n    // try ignoring the bold and italic flags\n    for (i = 0; i < fonts->getLength(); ++i) {\n      fi = (SysFontInfo *)fonts->get(i);\n      if (fi->match(name2, gFalse, gFalse)) {\n\tbreak;\n      }\n      fi = nullptr;\n    }\n  }\n\n  delete name2;\n  return fi;\n}\n\n\n#ifdef ENABLE_PLUGINS\n//------------------------------------------------------------------------\n// Plugin\n//------------------------------------------------------------------------\n\nclass Plugin {\npublic:\n\n  static Plugin *load(char *type, char *name);\n  ~Plugin();\n\nprivate:\n\n#ifdef _WIN32\n  Plugin(HMODULE libA);\n  HMODULE lib;\n#else\n  Plugin(void *dlA);\n  void *dl;\n#endif\n};\n\nPlugin *Plugin::load(char *type, char *name) {\n  GooString *path;\n  Plugin *plugin;\n  XpdfPluginVecTable *vt;\n  XpdfBool (*xpdfInitPlugin)(void);\n#ifdef _WIN32\n  HMODULE libA;\n#else\n  void *dlA;\n#endif\n\n  path = new GooString(POPPLER_DATADIR);\n  appendToPath(path, \"plugins\");\n  appendToPath(path, type);\n  appendToPath(path, name);\n\n#ifdef _WIN32\n  path->append(\".dll\");\n  if (!(libA = LoadLibrary(path->getCString()))) {\n    error(errIO, -1, \"Failed to load plugin '{0:t}'\", path);\n    goto err1;\n  }\n  if (!(vt = (XpdfPluginVecTable *)\n\t         GetProcAddress(libA, \"xpdfPluginVecTable\"))) {\n    error(errIO, -1, \"Failed to find xpdfPluginVecTable in plugin '{0:t}'\",\n\t  path);\n    goto err2;\n  }\n#else\n  //~ need to deal with other extensions here\n  path->append(\".so\");\n  if (!(dlA = dlopen(path->getCString(), RTLD_NOW))) {\n    error(errIO, -1, \"Failed to load plugin '{0:t}': {1:s}\",\n\t  path, dlerror());\n    goto err1;\n  }\n  if (!(vt = (XpdfPluginVecTable *)dlsym(dlA, \"xpdfPluginVecTable\"))) {\n    error(errIO, -1, \"Failed to find xpdfPluginVecTable in plugin '{0:t}'\",\n\t  path);\n    goto err2;\n  }\n#endif\n\n  if (vt->version != xpdfPluginVecTable.version) {\n    error(errIO, -1, \"Plugin '{0:t}' is wrong version\", path);\n    goto err2;\n  }\n  memcpy(vt, &xpdfPluginVecTable, sizeof(xpdfPluginVecTable));\n\n#ifdef _WIN32\n  if (!(xpdfInitPlugin = (XpdfBool (*)(void))\n\t                     GetProcAddress(libA, \"xpdfInitPlugin\"))) {\n    error(errIO, -1, \"Failed to find xpdfInitPlugin in plugin '{0:t}'\",\n\t  path);\n    goto err2;\n  }\n#else\n  if (!(xpdfInitPlugin = (XpdfBool (*)(void))dlsym(dlA, \"xpdfInitPlugin\"))) {\n    error(errIO, -1, \"Failed to find xpdfInitPlugin in plugin '{0:t}'\",\n\t  path);\n    goto err2;\n  }\n#endif\n\n  if (!(*xpdfInitPlugin)()) {\n    error(errIO, -1, \"Initialization of plugin '{0:t}' failed\", path);\n    goto err2;\n  }\n\n#ifdef _WIN32\n  plugin = new Plugin(libA);\n#else\n  plugin = new Plugin(dlA);\n#endif\n\n  delete path;\n  return plugin;\n\n err2:\n#ifdef _WIN32\n  FreeLibrary(libA);\n#else\n  dlclose(dlA);\n#endif\n err1:\n  delete path;\n  return NULL;\n}\n\n#ifdef _WIN32\nPlugin::Plugin(HMODULE libA) {\n  lib = libA;\n}\n#else\nPlugin::Plugin(void *dlA) {\n  dl = dlA;\n}\n#endif\n\nPlugin::~Plugin() {\n  void (*xpdfFreePlugin)(void);\n\n#ifdef _WIN32\n  if ((xpdfFreePlugin = (void (*)(void))\n                            GetProcAddress(lib, \"xpdfFreePlugin\"))) {\n    (*xpdfFreePlugin)();\n  }\n  FreeLibrary(lib);\n#else\n  if ((xpdfFreePlugin = (void (*)(void))dlsym(dl, \"xpdfFreePlugin\"))) {\n    (*xpdfFreePlugin)();\n  }\n  dlclose(dl);\n#endif\n}\n\n#endif // ENABLE_PLUGINS\n\n//------------------------------------------------------------------------\n// parsing\n//------------------------------------------------------------------------\n\nGlobalParams::GlobalParams(const char *customPopplerDataDir)\n  : popplerDataDir(customPopplerDataDir)\n{\n#ifdef MULTITHREADED\n  gInitMutex(&mutex);\n  gInitMutex(&unicodeMapCacheMutex);\n  gInitMutex(&cMapCacheMutex);\n#endif\n\n  initBuiltinFontTables();\n\n  // scan the encoding in reverse because we want the lowest-numbered\n  // index for each char name ('space' is encoded twice)\n  macRomanReverseMap = new NameToCharCode();\n  for (int i = 255; i >= 0; --i) {\n    if (macRomanEncoding[i]) {\n      macRomanReverseMap->add(macRomanEncoding[i], (CharCode)i);\n    }\n  }\n\n  nameToUnicodeZapfDingbats = new NameToCharCode();\n  nameToUnicodeText = new NameToCharCode();\n  toUnicodeDirs = new GooList();\n  sysFonts = new SysFontList();\n  psExpandSmaller = gFalse;\n  psShrinkLarger = gTrue;\n  psLevel = psLevel2;\n  textEncoding = new GooString(\"UTF-8\");\n#if defined(_WIN32)\n  textEOL = eolDOS;\n#elif defined(MACOS)\n  textEOL = eolMac;\n#else\n  textEOL = eolUnix;\n#endif\n  textPageBreaks = gTrue;\n  enableFreeType = gTrue;\n  overprintPreview = gFalse;\n  printCommands = gFalse;\n  profileCommands = gFalse;\n  errQuiet = gFalse;\n\n  cidToUnicodeCache = new CharCodeToUnicodeCache(cidToUnicodeCacheSize);\n  unicodeToUnicodeCache =\n      new CharCodeToUnicodeCache(unicodeToUnicodeCacheSize);\n  unicodeMapCache = new UnicodeMapCache();\n  cMapCache = new CMapCache();\n\n  baseFontsInitialized = gFalse;\n#ifdef ENABLE_PLUGINS\n  plugins = new GooList();\n  securityHandlers = new GooList();\n#endif\n\n  // set up the initial nameToUnicode tables\n  for (int i = 0; nameToUnicodeZapfDingbatsTab[i].name; ++i) {\n    nameToUnicodeZapfDingbats->add(nameToUnicodeZapfDingbatsTab[i].name, nameToUnicodeZapfDingbatsTab[i].u);\n  }\n\n  for (int i = 0; nameToUnicodeTextTab[i].name; ++i) {\n    nameToUnicodeText->add(nameToUnicodeTextTab[i].name, nameToUnicodeTextTab[i].u);\n  }\n\n  // set up the residentUnicodeMaps table\n  residentUnicodeMaps.reserve(6);\n  UnicodeMap map = {\"Latin1\", gFalse, latin1UnicodeMapRanges, latin1UnicodeMapLen};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n  map = {\"ASCII7\", gFalse, ascii7UnicodeMapRanges, ascii7UnicodeMapLen};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n  map = {\"Symbol\", gFalse, symbolUnicodeMapRanges, symbolUnicodeMapLen};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n  map = {\"ZapfDingbats\", gFalse, zapfDingbatsUnicodeMapRanges, zapfDingbatsUnicodeMapLen};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n  map = {\"UTF-8\", gTrue, &mapUTF8};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n  map = {\"UTF-16\", gTrue, &mapUTF16};\n  residentUnicodeMaps.emplace(map.getEncodingName()->toStr(), std::move(map));\n\n  scanEncodingDirs();\n}\n\nvoid GlobalParams::scanEncodingDirs() {\n  GDir *dir;\n  GDirEntry *entry;\n  const char *dataRoot = popplerDataDir ? popplerDataDir : POPPLER_DATADIR;\n  \n  // allocate buffer large enough to append \"/nameToUnicode\"\n  size_t bufSize = strlen(dataRoot) + strlen(\"/nameToUnicode\") + 1;\n  char *dataPathBuffer = new char[bufSize];\n  \n  snprintf(dataPathBuffer, bufSize, \"%s/nameToUnicode\", dataRoot);\n  dir = new GDir(dataPathBuffer, gTrue);\n  while (entry = dir->getNextEntry(), entry != nullptr) {\n    if (!entry->isDir()) {\n      parseNameToUnicode(entry->getFullPath());\n    }\n    delete entry;\n  }\n  delete dir;\n\n  snprintf(dataPathBuffer, bufSize, \"%s/cidToUnicode\", dataRoot);\n  dir = new GDir(dataPathBuffer, gFalse);\n  while (entry = dir->getNextEntry(), entry != nullptr) {\n    addCIDToUnicode(entry->getName(), entry->getFullPath());\n    delete entry;\n  }\n  delete dir;\n\n  snprintf(dataPathBuffer, bufSize, \"%s/unicodeMap\", dataRoot);\n  dir = new GDir(dataPathBuffer, gFalse);\n  while (entry = dir->getNextEntry(), entry != nullptr) {\n    addUnicodeMap(entry->getName(), entry->getFullPath());\n    delete entry;\n  }\n  delete dir;\n\n  snprintf(dataPathBuffer, bufSize, \"%s/cMap\", dataRoot);\n  dir = new GDir(dataPathBuffer, gFalse);\n  while (entry = dir->getNextEntry(), entry != nullptr) {\n    addCMapDir(entry->getName(), entry->getFullPath());\n    toUnicodeDirs->append(entry->getFullPath()->copy());\n    delete entry;\n  }\n  delete dir;\n  \n  delete[] dataPathBuffer;\n}\n\nvoid GlobalParams::parseNameToUnicode(GooString *name) {\n  char *tok1, *tok2;\n  FILE *f;\n  char buf[256];\n  int line;\n  Unicode u;\n  char *tokptr;\n\n  if (!(f = openFile(name->getCString(), \"r\"))) {\n    error(errIO, -1, \"Couldn't open 'nameToUnicode' file '{0:t}'\",\n\t  name);\n    return;\n  }\n  line = 1;\n  while (getLine(buf, sizeof(buf), f)) {\n    tok1 = strtok_r(buf, \" \\t\\r\\n\", &tokptr);\n    tok2 = strtok_r(nullptr, \" \\t\\r\\n\", &tokptr);\n    if (tok1 && tok2) {\n      sscanf(tok1, \"%x\", &u);\n      nameToUnicodeText->add(tok2, u);\n    } else {\n      error(errConfig, -1, \"Bad line in 'nameToUnicode' file ({0:t}:{1:d})\",\n\t    name, line);\n    }\n    ++line;\n  }\n  fclose(f);\n}\n\nvoid GlobalParams::addCIDToUnicode(GooString *collection, GooString *fileName) {\n  cidToUnicodes[collection->toStr()] = fileName->toStr();\n}\n\nvoid GlobalParams::addUnicodeMap(GooString *encodingName, GooString *fileName) {\n  unicodeMaps[encodingName->toStr()] = fileName->toStr();\n}\n\nvoid GlobalParams::addCMapDir(GooString *collection, GooString *dir) {\n  cMapDirs.emplace(collection->toStr(), dir->toStr());\n}\n\nGBool GlobalParams::parseYesNo2(const char *token, GBool *flag) {\n  if (!strcmp(token, \"yes\")) {\n    *flag = gTrue;\n  } else if (!strcmp(token, \"no\")) {\n    *flag = gFalse;\n  } else {\n    return gFalse;\n  }\n  return gTrue;\n}\n\nGlobalParams::~GlobalParams() {\n  freeBuiltinFontTables();\n\n  delete macRomanReverseMap;\n\n  delete nameToUnicodeZapfDingbats;\n  delete nameToUnicodeText;\n  deleteGooList(toUnicodeDirs, GooString);\n  delete sysFonts;\n  delete textEncoding;\n\n  delete cidToUnicodeCache;\n  delete unicodeToUnicodeCache;\n  delete unicodeMapCache;\n  delete cMapCache;\n\n#ifdef ENABLE_PLUGINS\n  delete securityHandlers;\n  deleteGooList(plugins, Plugin);\n#endif\n\n#ifdef MULTITHREADED\n  gDestroyMutex(&mutex);\n  gDestroyMutex(&unicodeMapCacheMutex);\n  gDestroyMutex(&cMapCacheMutex);\n#endif\n}\n\n//------------------------------------------------------------------------\n// accessors\n//------------------------------------------------------------------------\n\nCharCode GlobalParams::getMacRomanCharCode(char *charName) {\n  // no need to lock - macRomanReverseMap is constant\n  return macRomanReverseMap->lookup(charName);\n}\n\nUnicode GlobalParams::mapNameToUnicodeAll(const char *charName) {\n  // no need to lock - nameToUnicodeZapfDingbats and nameToUnicodeText are constant\n  Unicode u = nameToUnicodeZapfDingbats->lookup(charName);\n  if (!u)\n    u = nameToUnicodeText->lookup(charName);\n  return u;\n}\n\nUnicode GlobalParams::mapNameToUnicodeText(const char *charName) {\n  // no need to lock - nameToUnicodeText is constant\n  return nameToUnicodeText->lookup(charName);\n}\n\nUnicodeMap *GlobalParams::getResidentUnicodeMap(GooString *encodingName) {\n  UnicodeMap *map = nullptr;\n\n  lockGlobalParams;\n  const auto unicodeMap = residentUnicodeMaps.find(encodingName->toStr());\n  if (unicodeMap != residentUnicodeMaps.end()) {\n    map = &unicodeMap->second;\n    map->incRefCnt();\n  }\n  unlockGlobalParams;\n\n  return map;\n}\n\nFILE *GlobalParams::getUnicodeMapFile(GooString *encodingName) {\n  FILE *file = nullptr;\n\n  lockGlobalParams;\n  const auto unicodeMap = unicodeMaps.find(encodingName->toStr());\n  if (unicodeMap != unicodeMaps.end()) {\n    file = openFile(unicodeMap->second.c_str(), \"r\");\n  }\n  unlockGlobalParams;\n\n  return file;\n}\n\nFILE *GlobalParams::findCMapFile(GooString *collection, GooString *cMapName) {\n  FILE *file = nullptr;\n\n  lockGlobalParams;\n  const auto cMapDirs = this->cMapDirs.equal_range(collection->toStr());\n  for (auto cMapDir = cMapDirs.first; cMapDir != cMapDirs.second; ++cMapDir) {\n    auto* const path = new GooString(cMapDir->second);\n    appendToPath(path, cMapName->getCString());\n    file = openFile(path->getCString(), \"r\");\n    delete path;\n    if (file) {\n      break;\n    }\n  }\n  unlockGlobalParams;\n  return file;\n}\n\nFILE *GlobalParams::findToUnicodeFile(GooString *name) {\n  GooString *dir, *fileName;\n  FILE *f;\n  int i;\n\n  lockGlobalParams;\n  for (i = 0; i < toUnicodeDirs->getLength(); ++i) {\n    dir = (GooString *)toUnicodeDirs->get(i);\n    fileName = appendToPath(dir->copy(), name->getCString());\n    f = openFile(fileName->getCString(), \"r\");\n    delete fileName;\n    if (f) {\n      unlockGlobalParams;\n      return f;\n    }\n  }\n  unlockGlobalParams;\n  return nullptr;\n}\n\n#ifdef WITH_FONTCONFIGURATION_FONTCONFIG\nstatic GBool findModifier(const char *name, const char *modifier, const char **start)\n{\n  const char *match;\n\n  if (name == nullptr)\n    return gFalse;\n\n  match = strstr(name, modifier);\n  if (match) {\n    if (*start == nullptr || match < *start)\n      *start = match;\n    return gTrue;\n  }\n  else {\n    return gFalse;\n  }\n}\n\nstatic const char *getFontLang(GfxFont *font)\n{\n  const char *lang;\n\n  // find the language we want the font to support\n  if (font->isCIDFont())\n  {\n    GooString *collection = ((GfxCIDFont *)font)->getCollection();\n    if (collection)\n    {\n      if (strcmp(collection->getCString(), \"Adobe-GB1\") == 0)\n        lang = \"zh-cn\"; // Simplified Chinese\n      else if (strcmp(collection->getCString(), \"Adobe-CNS1\") == 0)\n        lang = \"zh-tw\"; // Traditional Chinese\n      else if (strcmp(collection->getCString(), \"Adobe-Japan1\") == 0)\n        lang = \"ja\"; // Japanese\n      else if (strcmp(collection->getCString(), \"Adobe-Japan2\") == 0)\n        lang = \"ja\"; // Japanese\n      else if (strcmp(collection->getCString(), \"Adobe-Korea1\") == 0)\n        lang = \"ko\"; // Korean\n      else if (strcmp(collection->getCString(), \"Adobe-UCS\") == 0)\n        lang = \"xx\";\n      else if (strcmp(collection->getCString(), \"Adobe-Identity\") == 0)\n        lang = \"xx\";\n      else\n      {\n        error(errUnimplemented, -1, \"Unknown CID font collection, please report to poppler bugzilla.\");\n        lang = \"xx\";\n      }\n    }\n    else lang = \"xx\";\n  }\n  else lang = \"xx\";\n  return lang;\n}\n\nstatic FcPattern *buildFcPattern(GfxFont *font, const GooString *base14Name)\n{\n  int weight = -1,\n      slant = -1,\n      width = -1,\n      spacing = -1;\n  bool deleteFamily = false;\n  char *family, *name, *modifiers;\n  const char *start;\n  FcPattern *p;\n\n  // this is all heuristics will be overwritten if font had proper info\n  GooString copiedNameGooString(((base14Name == nullptr) ? font->getName() : base14Name)->getCString());\n  name = copiedNameGooString.getCString();\n\n  modifiers = strchr (name, ',');\n  if (modifiers == nullptr)\n    modifiers = strchr (name, '-');\n\n  // remove the - from the names, for some reason, Fontconfig does not\n  // understand \"MS-Mincho\" but does with \"MS Mincho\"\n  int len = strlen(name);\n  for (int i = 0; i < len; i++)\n    name[i] = (name[i] == '-' ? ' ' : name[i]);\n\n  start = nullptr;\n  findModifier(modifiers, \"Regular\", &start);\n  findModifier(modifiers, \"Roman\", &start);\n  \n  if (findModifier(modifiers, \"Oblique\", &start))\n    slant = FC_SLANT_OBLIQUE;\n  if (findModifier(modifiers, \"Italic\", &start))\n    slant = FC_SLANT_ITALIC;\n  if (findModifier(modifiers, \"Bold\", &start))\n    weight = FC_WEIGHT_BOLD;\n  if (findModifier(modifiers, \"Light\", &start))\n    weight = FC_WEIGHT_LIGHT;\n  if (findModifier(modifiers, \"Medium\", &start))\n    weight = FC_WEIGHT_MEDIUM;\n  if (findModifier(modifiers, \"Condensed\", &start))\n    width = FC_WIDTH_CONDENSED;\n  \n  if (start) {\n    // There have been \"modifiers\" in the name, crop them to obtain\n    // the family name\n    family = new char[len+1];\n    strcpy(family, name);\n    int pos = (modifiers - name);\n    family[pos] = '\\0';\n    deleteFamily = true;\n  }\n  else {\n    family = name;\n  }\n  \n  // use font flags\n  if (font->isFixedWidth())\n    spacing = FC_MONO;\n  if (font->isBold())\n    weight = FC_WEIGHT_BOLD;\n  if (font->isItalic())\n    slant = FC_SLANT_ITALIC;\n  \n  // if the FontDescriptor specified a family name use it\n  if (font->getFamily()) {\n    if (deleteFamily) {\n      delete[] family;\n      deleteFamily = false;\n    }\n    family = font->getFamily()->getCString();\n  }\n  \n  // if the FontDescriptor specified a weight use it\n  switch (font -> getWeight())\n  {\n    case GfxFont::W100: weight = FC_WEIGHT_EXTRALIGHT; break; \n    case GfxFont::W200: weight = FC_WEIGHT_LIGHT; break; \n    case GfxFont::W300: weight = FC_WEIGHT_BOOK; break; \n    case GfxFont::W400: weight = FC_WEIGHT_NORMAL; break; \n    case GfxFont::W500: weight = FC_WEIGHT_MEDIUM; break; \n    case GfxFont::W600: weight = FC_WEIGHT_DEMIBOLD; break; \n    case GfxFont::W700: weight = FC_WEIGHT_BOLD; break; \n    case GfxFont::W800: weight = FC_WEIGHT_EXTRABOLD; break; \n    case GfxFont::W900: weight = FC_WEIGHT_BLACK; break; \n    default: break; \n  }\n  \n  // if the FontDescriptor specified a width use it\n  switch (font -> getStretch())\n  {\n    case GfxFont::UltraCondensed: width = FC_WIDTH_ULTRACONDENSED; break; \n    case GfxFont::ExtraCondensed: width = FC_WIDTH_EXTRACONDENSED; break; \n    case GfxFont::Condensed: width = FC_WIDTH_CONDENSED; break; \n    case GfxFont::SemiCondensed: width = FC_WIDTH_SEMICONDENSED; break; \n    case GfxFont::Normal: width = FC_WIDTH_NORMAL; break; \n    case GfxFont::SemiExpanded: width = FC_WIDTH_SEMIEXPANDED; break; \n    case GfxFont::Expanded: width = FC_WIDTH_EXPANDED; break; \n    case GfxFont::ExtraExpanded: width = FC_WIDTH_EXTRAEXPANDED; break; \n    case GfxFont::UltraExpanded: width = FC_WIDTH_ULTRAEXPANDED; break; \n    default: break; \n  }\n  \n  const char *lang = getFontLang(font);\n  \n  p = FcPatternBuild(nullptr,\n                    FC_FAMILY, FcTypeString, family,\n                    FC_LANG, FcTypeString, lang,\n                    NULL);\n  if (slant != -1) FcPatternAddInteger(p, FC_SLANT, slant);\n  if (weight != -1) FcPatternAddInteger(p, FC_WEIGHT, weight);\n  if (width != -1) FcPatternAddInteger(p, FC_WIDTH, width);\n  if (spacing != -1) FcPatternAddInteger(p, FC_SPACING, spacing);\n\n  if (deleteFamily)\n    delete[] family;\n  return p;\n}\n#endif\n\nGooString *GlobalParams::findFontFile(GooString *fontName) {\n  GooString *path = nullptr;\n\n  setupBaseFonts(nullptr);\n  lockGlobalParams;\n  const auto fontFile = fontFiles.find(fontName->toStr());\n  if (fontFile != fontFiles.end()) {\n    path = new GooString(fontFile->second);\n  }\n  unlockGlobalParams;\n  return path;\n}\n\n/* if you can't or don't want to use Fontconfig, you need to implement\n   this function for your platform. For Windows, it's in GlobalParamsWin.cc\n*/\n#ifdef WITH_FONTCONFIGURATION_FONTCONFIG\n// not needed for fontconfig\nvoid GlobalParams::setupBaseFonts(char *) {\n}\n\nGooString *GlobalParams::findBase14FontFile(GooString *base14Name, GfxFont *font) {\n  SysFontType type;\n  int fontNum;\n  \n  return findSystemFontFile(font, &type, &fontNum, nullptr, base14Name);\n}\n\nGooString *GlobalParams::findSystemFontFile(GfxFont *font,\n\t\t\t\t\t  SysFontType *type,\n\t\t\t\t\t  int *fontNum, GooString *substituteFontName, GooString *base14Name) {\n  SysFontInfo *fi = nullptr;\n  FcPattern *p=nullptr;\n  GooString *path = nullptr;\n  const GooString *fontName = font->getName();\n  GooString substituteName;\n  if (!fontName) return nullptr;\n  lockGlobalParams;\n\n  if ((fi = sysFonts->find(fontName, font->isFixedWidth(), gTrue))) {\n    path = fi->path->copy();\n    *type = fi->type;\n    *fontNum = fi->fontNum;\n    substituteName.Set(fi->substituteName->getCString());\n  } else {\n    FcChar8* s;\n    char * ext;\n    FcResult res;\n    FcFontSet *set;\n    int i;\n    FcLangSet *lb = nullptr;\n    p = buildFcPattern(font, base14Name);\n\n    if (!p)\n      goto fin;\n    FcConfigSubstitute(nullptr, p, FcMatchPattern);\n    FcDefaultSubstitute(p);\n    set = FcFontSort(nullptr, p, FcFalse, nullptr, &res);\n    if (!set)\n      goto fin;\n\n    // find the language we want the font to support\n    const char *lang = getFontLang(font);\n    if (strcmp(lang,\"xx\") != 0) {\n      lb = FcLangSetCreate();\n      FcLangSetAdd(lb,(FcChar8 *)lang);\n    }\n\n    /*\n      scan twice.\n      first: fonts support the language\n      second: all fonts (fall back)\n    */\n    while (fi == nullptr)\n    {\n      for (i = 0; i < set->nfont; ++i)\n      {\n\tres = FcPatternGetString(set->fonts[i], FC_FILE, 0, &s);\n\tif (res != FcResultMatch || !s)\n\t  continue;\n\tif (lb != nullptr) {\n\t  FcLangSet *l;\n\t  res = FcPatternGetLangSet(set->fonts[i], FC_LANG, 0, &l);\n\t  if (res != FcResultMatch || !FcLangSetContains(l,lb)) {\n\t    continue;\n\t  }\n\t}\n\tFcChar8* s2;\n        res = FcPatternGetString(set->fonts[i], FC_FULLNAME, 0, &s2);\n        if (res == FcResultMatch && s2) {\n          substituteName.Set((char*)s2);\n        } else {\n          // fontconfig does not extract fullname for some fonts\n          // create the fullname from family and style\n          res = FcPatternGetString(set->fonts[i], FC_FAMILY, 0, &s2);\n          if (res == FcResultMatch && s2) {\n            substituteName.Set((char*)s2);\n            res = FcPatternGetString(set->fonts[i], FC_STYLE, 0, &s2);\n            if (res == FcResultMatch && s2) {\n              GooString *style = new GooString((char*)s2);\n              if (style->cmp(\"Regular\") != 0) {\n                substituteName.append(\" \");\n                substituteName.append(style);\n              }\n              delete style;\n            }\n          }\n        }\n\text = strrchr((char*)s,'.');\n\tif (!ext)\n\t  continue;\n\tif (!strncasecmp(ext,\".ttf\",4) || !strncasecmp(ext, \".ttc\", 4) || !strncasecmp(ext, \".otf\", 4))\n\t{\n\t  int weight, slant;\n\t  GBool bold = font->isBold();\n\t  GBool italic = font->isItalic();\n\t  GBool oblique = gFalse;\n\t  FcPatternGetInteger(set->fonts[i], FC_WEIGHT, 0, &weight);\n\t  FcPatternGetInteger(set->fonts[i], FC_SLANT, 0, &slant);\n\t  if (weight == FC_WEIGHT_DEMIBOLD || weight == FC_WEIGHT_BOLD \n\t      || weight == FC_WEIGHT_EXTRABOLD || weight == FC_WEIGHT_BLACK)\n\t  {\n\t    bold = gTrue;\n\t  }\n\t  if (slant == FC_SLANT_ITALIC)\n\t    italic = gTrue;\n\t  if (slant == FC_SLANT_OBLIQUE)\n\t    oblique = gTrue;\n\t  *fontNum = 0;\n\t  *type = (!strncasecmp(ext,\".ttc\",4)) ? sysFontTTC : sysFontTTF;\n\t  FcPatternGetInteger(set->fonts[i], FC_INDEX, 0, fontNum);\n\t  fi = new SysFontInfo(fontName->copy(), bold, italic, oblique, font->isFixedWidth(),\n\t\t\t       new GooString((char*)s), *type, *fontNum, substituteName.copy());\n\t  sysFonts->addFcFont(fi);\n\t  path = new GooString((char*)s);\n\t}\n\telse if (!strncasecmp(ext,\".pfa\",4) || !strncasecmp(ext,\".pfb\",4)) \n\t{\n\t  int weight, slant;\n\t  GBool bold = font->isBold();\n\t  GBool italic = font->isItalic();\n\t  GBool oblique = gFalse;\n\t  FcPatternGetInteger(set->fonts[i], FC_WEIGHT, 0, &weight);\n\t  FcPatternGetInteger(set->fonts[i], FC_SLANT, 0, &slant);\n\t  if (weight == FC_WEIGHT_DEMIBOLD || weight == FC_WEIGHT_BOLD \n\t      || weight == FC_WEIGHT_EXTRABOLD || weight == FC_WEIGHT_BLACK)\n\t  {\n\t\tbold = gTrue;\n\t  }\n\t  if (slant == FC_SLANT_ITALIC)\n\t    italic = gTrue;\n\t  if (slant == FC_SLANT_OBLIQUE)\n\t    oblique = gTrue;\n\t  *fontNum = 0;\n\t  *type = (!strncasecmp(ext,\".pfa\",4)) ? sysFontPFA : sysFontPFB;\n\t  FcPatternGetInteger(set->fonts[i], FC_INDEX, 0, fontNum);\n\t  fi = new SysFontInfo(fontName->copy(), bold, italic, oblique, font->isFixedWidth(),\n\t\t\t       new GooString((char*)s), *type, *fontNum, substituteName.copy());\n\t  sysFonts->addFcFont(fi);\n\t  path = new GooString((char*)s);\n\t}\n\telse\n\t  continue;\n\tbreak;\n      }\n      if (lb != nullptr) {\n        FcLangSetDestroy(lb);\n        lb = nullptr;\n      } else {\n        /* scan all fonts of the list */\n        break;\n      }\n    }\n    FcFontSetDestroy(set);\n  }\n  if (path == nullptr && (fi = sysFonts->find(fontName, font->isFixedWidth(), gFalse))) {\n    path = fi->path->copy();\n    *type = fi->type;\n    *fontNum = fi->fontNum;\n  }\n  if (substituteFontName) {\n    substituteFontName->Set(substituteName.getCString());\n  }\nfin:\n  if (p)\n    FcPatternDestroy(p);\n  unlockGlobalParams;\n  return path;\n}\n\n#elif WITH_FONTCONFIGURATION_WIN32\n#include \"GlobalParamsWin.cc\"\n\nGooString *GlobalParams::findBase14FontFile(GooString *base14Name, GfxFont *font) {\n  return findFontFile(base14Name);\n}\n#else\nGooString *GlobalParams::findBase14FontFile(GooString *base14Name, GfxFont *font) {\n  return findFontFile(base14Name);\n}\n\nstatic struct {\n  const char *name;\n  const char *t1FileName;\n  const char *ttFileName;\n} displayFontTab[] = {\n  {\"Courier\",               \"n022003l.pfb\", \"cour.ttf\"},\n  {\"Courier-Bold\",          \"n022004l.pfb\", \"courbd.ttf\"},\n  {\"Courier-BoldOblique\",   \"n022024l.pfb\", \"courbi.ttf\"},\n  {\"Courier-Oblique\",       \"n022023l.pfb\", \"couri.ttf\"},\n  {\"Helvetica\",             \"n019003l.pfb\", \"arial.ttf\"},\n  {\"Helvetica-Bold\",        \"n019004l.pfb\", \"arialbd.ttf\"},\n  {\"Helvetica-BoldOblique\", \"n019024l.pfb\", \"arialbi.ttf\"},\n  {\"Helvetica-Oblique\",     \"n019023l.pfb\", \"ariali.ttf\"},\n  {\"Symbol\",                \"s050000l.pfb\", NULL},\n  {\"Times-Bold\",            \"n021004l.pfb\", \"timesbd.ttf\"},\n  {\"Times-BoldItalic\",      \"n021024l.pfb\", \"timesbi.ttf\"},\n  {\"Times-Italic\",          \"n021023l.pfb\", \"timesi.ttf\"},\n  {\"Times-Roman\",           \"n021003l.pfb\", \"times.ttf\"},\n  {\"ZapfDingbats\",          \"d050000l.pfb\", NULL},\n  {NULL}\n};\n\nstatic const char *displayFontDirs[] = {\n  \"/usr/share/ghostscript/fonts\",\n  \"/usr/local/share/ghostscript/fonts\",\n  \"/usr/share/fonts/default/Type1\",\n  \"/usr/share/fonts/default/ghostscript\",\n  \"/usr/share/fonts/type1/gsfonts\",\n  NULL\n};\n\nvoid GlobalParams::setupBaseFonts(char *dir) {\n  GooString *fontName;\n  GooString *fileName;\n  FILE *f;\n  int i, j;\n\n  for (i = 0; displayFontTab[i].name; ++i) {\n    if (fontFiles.count(displayFontTab[i].name) > 0) {\n      continue;\n    }\n    fontName = new GooString(displayFontTab[i].name);\n    fileName = NULL;\n    if (dir) {\n      fileName = appendToPath(new GooString(dir), displayFontTab[i].t1FileName);\n      if ((f = fopen(fileName->getCString(), \"rb\"))) {\n\t      fclose(f);\n      } else {\n\t      delete fileName;\n\t      fileName = NULL;\n      }\n    }\n    for (j = 0; !fileName && displayFontDirs[j]; ++j) {\n      fileName = appendToPath(new GooString(displayFontDirs[j]),\n\t\t\t      displayFontTab[i].t1FileName);\n      if ((f = fopen(fileName->getCString(), \"rb\"))) {\n\t      fclose(f);\n      } else {\n\t      delete fileName;\n\t      fileName = NULL;\n      }\n    }\n    if (!fileName) {\n      error(errConfig, -1, \"No display font for '{0:s}'\",\n\t    displayFontTab[i].name);\n      delete fontName;\n      continue;\n    }\n    addFontFile(fontName, fileName);\n  }\n\n}\n\nGooString *GlobalParams::findSystemFontFile(GfxFont *font,\n\t\t\t\t\t  SysFontType *type,\n\t\t\t\t\t  int *fontNum, GooString * /*substituteFontName*/,\n\t\t\t\t\t  GooString * /*base14Name*/) {\n  SysFontInfo *fi;\n  GooString *path;\n\n  path = NULL;\n  lockGlobalParams;\n  if ((fi = sysFonts->find(font->getName(), font->isFixedWidth(), gFalse))) {\n    path = fi->path->copy();\n    *type = fi->type;\n    *fontNum = fi->fontNum;\n  }\n  unlockGlobalParams; \n  return path;\n}\n#endif\n\nGBool GlobalParams::getPSExpandSmaller() {\n  GBool f;\n\n  lockGlobalParams;\n  f = psExpandSmaller;\n  unlockGlobalParams;\n  return f;\n}\n\nGBool GlobalParams::getPSShrinkLarger() {\n  GBool f;\n\n  lockGlobalParams;\n  f = psShrinkLarger;\n  unlockGlobalParams;\n  return f;\n}\n\nPSLevel GlobalParams::getPSLevel() {\n  PSLevel level;\n\n  lockGlobalParams;\n  level = psLevel;\n  unlockGlobalParams;\n  return level;\n}\n\nGooString *GlobalParams::getTextEncodingName() {\n  GooString *s;\n\n  lockGlobalParams;\n  s = textEncoding->copy();\n  unlockGlobalParams;\n  return s;\n}\n\nEndOfLineKind GlobalParams::getTextEOL() {\n  EndOfLineKind eol;\n\n  lockGlobalParams;\n  eol = textEOL;\n  unlockGlobalParams;\n  return eol;\n}\n\nGBool GlobalParams::getTextPageBreaks() {\n  GBool pageBreaks;\n\n  lockGlobalParams;\n  pageBreaks = textPageBreaks;\n  unlockGlobalParams;\n  return pageBreaks;\n}\n\nGBool GlobalParams::getEnableFreeType() {\n  GBool f;\n\n  lockGlobalParams;\n  f = enableFreeType;\n  unlockGlobalParams;\n  return f;\n}\n\nGBool GlobalParams::getPrintCommands() {\n  GBool p;\n\n  lockGlobalParams;\n  p = printCommands;\n  unlockGlobalParams;\n  return p;\n}\n\nGBool GlobalParams::getProfileCommands() {\n  GBool p;\n\n  lockGlobalParams;\n  p = profileCommands;\n  unlockGlobalParams;\n  return p;\n}\n\nGBool GlobalParams::getErrQuiet() {\n  // no locking -- this function may get called from inside a locked\n  // section\n  return errQuiet;\n}\n\nCharCodeToUnicode *GlobalParams::getCIDToUnicode(GooString *collection) {\n  CharCodeToUnicode *ctu;\n\n  lockGlobalParams;\n  if (!(ctu = cidToUnicodeCache->getCharCodeToUnicode(collection))) {\n    const auto cidToUnicode = cidToUnicodes.find(collection->toStr());\n    if (cidToUnicode != cidToUnicodes.end()) {\n      if((ctu = CharCodeToUnicode::parseCIDToUnicode(cidToUnicode->second.c_str(), collection))) {\n        cidToUnicodeCache->add(ctu);\n      }\n    }\n  }\n  unlockGlobalParams;\n  return ctu;\n}\n\nUnicodeMap *GlobalParams::getUnicodeMap(GooString *encodingName) {\n  return getUnicodeMap2(encodingName);\n}\n\nUnicodeMap *GlobalParams::getUnicodeMap2(GooString *encodingName) {\n  UnicodeMap *map;\n\n  if (!(map = getResidentUnicodeMap(encodingName))) {\n    lockUnicodeMapCache;\n    map = unicodeMapCache->getUnicodeMap(encodingName);\n    unlockUnicodeMapCache;\n  }\n  return map;\n}\n\nCMap *GlobalParams::getCMap(GooString *collection, GooString *cMapName, Stream *stream) {\n  CMap *cMap;\n\n  lockCMapCache;\n  cMap = cMapCache->getCMap(collection, cMapName, stream);\n  unlockCMapCache;\n  return cMap;\n}\n\nUnicodeMap *GlobalParams::getTextEncoding() {\n  return getUnicodeMap2(textEncoding);\n}\n\nGooList *GlobalParams::getEncodingNames()\n{\n  auto* const result = new GooList;\n  for (const auto& unicodeMap : residentUnicodeMaps) {\n    result->append(new GooString(unicodeMap.first));\n  }\n  for (const auto& unicodeMap : unicodeMaps) {\n    result->append(new GooString(unicodeMap.first));\n  }\n  return result;\n}\n\n//------------------------------------------------------------------------\n// functions to set parameters\n//------------------------------------------------------------------------\n\nvoid GlobalParams::addFontFile(GooString *fontName, GooString *path) {\n  lockGlobalParams;\n  fontFiles[fontName->toStr()] = path->toStr();\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setPSExpandSmaller(GBool expand) {\n  lockGlobalParams;\n  psExpandSmaller = expand;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setPSShrinkLarger(GBool shrink) {\n  lockGlobalParams;\n  psShrinkLarger = shrink;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setPSLevel(PSLevel level) {\n  lockGlobalParams;\n  psLevel = level;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setTextEncoding(char *encodingName) {\n  lockGlobalParams;\n  delete textEncoding;\n  textEncoding = new GooString(encodingName);\n  unlockGlobalParams;\n}\n\nGBool GlobalParams::setTextEOL(char *s) {\n  lockGlobalParams;\n  if (!strcmp(s, \"unix\")) {\n    textEOL = eolUnix;\n  } else if (!strcmp(s, \"dos\")) {\n    textEOL = eolDOS;\n  } else if (!strcmp(s, \"mac\")) {\n    textEOL = eolMac;\n  } else {\n    unlockGlobalParams;\n    return gFalse;\n  }\n  unlockGlobalParams;\n  return gTrue;\n}\n\nvoid GlobalParams::setTextPageBreaks(GBool pageBreaks) {\n  lockGlobalParams;\n  textPageBreaks = pageBreaks;\n  unlockGlobalParams;\n}\n\nGBool GlobalParams::setEnableFreeType(char *s) {\n  GBool ok;\n\n  lockGlobalParams;\n  ok = parseYesNo2(s, &enableFreeType);\n  unlockGlobalParams;\n  return ok;\n}\n\nvoid GlobalParams::setOverprintPreview(GBool overprintPreviewA) {\n  lockGlobalParams;\n  overprintPreview = overprintPreviewA;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setPrintCommands(GBool printCommandsA) {\n  lockGlobalParams;\n  printCommands = printCommandsA;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setProfileCommands(GBool profileCommandsA) {\n  lockGlobalParams;\n  profileCommands = profileCommandsA;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::setErrQuiet(GBool errQuietA) {\n  lockGlobalParams;\n  errQuiet = errQuietA;\n  unlockGlobalParams;\n}\n\nvoid GlobalParams::addSecurityHandler(XpdfSecurityHandler *handler) {\n#ifdef ENABLE_PLUGINS\n  lockGlobalParams;\n  securityHandlers->append(handler);\n  unlockGlobalParams;\n#endif\n}\n\nXpdfSecurityHandler *GlobalParams::getSecurityHandler(char *name) {\n#ifdef ENABLE_PLUGINS\n  XpdfSecurityHandler *hdlr;\n  int i;\n\n  lockGlobalParams;\n  for (i = 0; i < securityHandlers->getLength(); ++i) {\n    hdlr = (XpdfSecurityHandler *)securityHandlers->get(i);\n    if (!strcasecmp(hdlr->name, name)) {\n      unlockGlobalParams;\n      return hdlr;\n    }\n  }\n  unlockGlobalParams;\n\n  if (!loadPlugin(\"security\", name)) {\n    return NULL;\n  }\n\n  lockGlobalParams;\n  for (i = 0; i < securityHandlers->getLength(); ++i) {\n    hdlr = (XpdfSecurityHandler *)securityHandlers->get(i);\n    if (!strcmp(hdlr->name, name)) {\n      unlockGlobalParams;\n      return hdlr;\n    }\n  }\n  unlockGlobalParams;\n#else\n  (void)name;\n#endif\n\n  return nullptr;\n}\n\n#ifdef ENABLE_PLUGINS\n//------------------------------------------------------------------------\n// plugins\n//------------------------------------------------------------------------\n\nGBool GlobalParams::loadPlugin(char *type, char *name) {\n  Plugin *plugin;\n\n  if (!(plugin = Plugin::load(type, name))) {\n    return gFalse;\n  }\n  lockGlobalParams;\n  plugins->append(plugin);\n  unlockGlobalParams;\n  return gTrue;\n}\n\n#endif // ENABLE_PLUGINS\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/a.pbm",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/romedalen.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-cmyk-cmyk.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-rgb-rgb-adobe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-ycck-ycck-adobe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-yuv-yuv-jfif.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-yuv-yuv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-cmyk-cmyk-adobe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-rgb-yuv-jfif.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/romedalen.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-ycck-ycck.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-rgb-rgb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/test-gen/jpegs/out-rgb-yuv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/.git/objects/pack/pack-dde4845a0072961c7eda2982253b704d2b50850f.idx",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/.git/objects/pack/pack-dde4845a0072961c7eda2982253b704d2b50850f.pack",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/encoding.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/degenerate-path.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/jpeg.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/mask-seams.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/blend.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/fonts.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/mask-seams.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/mask.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/zero-width.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/image.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/jpeg.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/mask.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/text.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/type3.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-1-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/type3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/degenerate-path.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/inline-image.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-3-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/image.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-2-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/zero-width.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/inline-image.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/text.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-5-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/encoding.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/cropbox.pdf-4-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/tests/fonts.pdf-0-cairo-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/fieldWithUtf16Names.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/encrypted-256.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/Gday gar\u00e7on - open.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/vis_policy_test.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/UseOC.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/utf16le-annot.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/kroller.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/orientation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/Gday gar\u00e7on - owner.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/UseNone.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/xr02.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/WithActualText.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/deseret.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/stroke-alpha-pattern.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/A6EmbeddedFiles.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/UseAttachments.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/UseThumbs.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/russian.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/tooltip.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/gnome-64.gif",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/form_set_icon.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/Issue637.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/NestedLayers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/type3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/truetype.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/ClarityOCGs.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/FullScreen.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/searchAcrossLines.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/imageretrieve+attachment.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/doublepage.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/PasswordEncrypted.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/latex-hyperref-checkbox-issue-655.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/bug7063.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/shapes+attachments.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/checkbox_issue_159.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/WithAttachments.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/testdata/unittestcases/xr01.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/right-insensitive.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/left.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/home.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/up-insensitive.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/right.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/left-insensitive.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/glib/reference/html/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/splash/SplashBitmap.h",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/splash/SplashBitmap.cc",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/splash/Splash.h",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/poppler/Function.cc",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/poppler/OutputDev.h",
        "/tmp/vanessa/spack-stage/spack-stage-poppler-0.65.0-uqwohyvkungmkkvkawv3cmd7tgnie5vp/spack-src/poppler/SplashOutputDev.h"
    ],
    "total_files": 718
}