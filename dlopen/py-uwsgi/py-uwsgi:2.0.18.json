{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/plugins/rrdtool/rrdtool.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\nstatic struct uwsgi_rrdtool {\n\tvoid *lib;\n\tchar *lib_name;\n\n\tint (*create)(int, char **);\n\tint (*update)(int, char **);\n\n\tint freq;\n\n\tchar *update_area;\n\tstruct uwsgi_string_list *directory;\n\n\tstruct uwsgi_stats_pusher *pusher;\n} u_rrd;\n\nstatic struct uwsgi_option rrdtool_options[] = {\n\t{\"rrdtool\", required_argument, 0, \"store rrd files in the specified directory\", uwsgi_opt_add_string_list, &u_rrd.directory, UWSGI_OPT_MASTER|UWSGI_OPT_METRICS},\n\t{\"rrdtool-freq\", required_argument, 0, \"set collect frequency\", uwsgi_opt_set_int, &u_rrd.freq, 0},\n\t{\"rrdtool-lib\", required_argument, 0, \"set the name of rrd library (default: librrd.so)\", uwsgi_opt_set_str, &u_rrd.lib_name, 0},\n\t{0, 0, 0, 0, 0, 0, 0},\n\n};\n\n\nstatic int rrdtool_init() {\n\n\tif (!u_rrd.lib_name) {\n\t\tu_rrd.lib_name = \"librrd.so\";\n\t}\n\n\tu_rrd.lib = dlopen(u_rrd.lib_name, RTLD_LAZY);\n\tif (!u_rrd.lib) return -1;\n\n\tu_rrd.create = dlsym(u_rrd.lib, \"rrd_create\");\n\tif (!u_rrd.create) {\n\t\tdlclose(u_rrd.lib);\n\t\treturn -1;\n\t}\n\n\tu_rrd.update = dlsym(u_rrd.lib, \"rrd_update\");\n\tif (!u_rrd.update) {\n\t\tdlclose(u_rrd.lib);\n\t\treturn -1;\n\t}\n\n\tuwsgi_log_initial(\"*** RRDtool library available at %p ***\\n\", u_rrd.lib);\n\n\treturn 0;\n}\n\n/*\n\n\tcreate .rrd files if needed\n\n*/\nstatic void rrdtool_post_init() {\n\n\tif (!u_rrd.create) return;\n\n\t// do not waste time if no --rrdtool option is defined\n\tif (!u_rrd.directory) return;\n\n\tif (!u_rrd.freq) u_rrd.freq = 300;\n\n\tchar *argv[7];\n\targv[0] = \"create\";\n\n\n\t// create RRA\n\targv[3] = \"RRA:AVERAGE:0.5:1:288\" ;\n\targv[4] = \"RRA:AVERAGE:0.5:12:168\" ;\n\targv[5] = \"RRA:AVERAGE:0.5:288:31\" ;\n\targv[6] = \"RRA:AVERAGE:0.5:2016:52\";\n\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, u_rrd.directory) {\n\t\tchar *dir = uwsgi_expand_path(usl->value, strlen(usl->value), NULL);\n                if (!dir) {\n                        uwsgi_error(\"rrdtool_post_init()/uwsgi_expand_path()\");\n                        exit(1);\n                }\n\t\tstruct uwsgi_metric *um = uwsgi.metrics;\n\t\t// here locking is useless, but maybe in the future we could move this part\n\t\t// somewhere else\n\t\tint created = 0;\n\t\tuwsgi_rlock(uwsgi.metrics_lock);\n\t\twhile(um) {\n\t\t\tchar *filename = uwsgi_concat4(dir, \"/\", um->name, \".rrd\");\n\t\t\tif (!uwsgi_file_exists(filename)) {\n\t\t\t\targv[1] = filename;\n\t\t\t\tif (um->type == UWSGI_METRIC_GAUGE) {\n\t\t\t\t\targv[2] = \"DS:metric:GAUGE:600:0:U\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targv[2] = \"DS:metric:DERIVE:600:0:U\";\n\t\t\t\t}\n\t\t\t\tif (u_rrd.create(7, argv)) {\n\t\t\t\t\tuwsgi_log(\"unable to create rrd file for metric \\\"%s\\\"\\n\", um->name);\n\t\t\t\t\tuwsgi_error(\"rrd_create()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tcreated++;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tum = um->next;\n\t\t}\n\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\n\t\tuwsgi_log(\"created %d new rrd files in %s\\n\", created, dir);\n\n\t\tstruct uwsgi_stats_pusher_instance *uspi = uwsgi_stats_pusher_add(u_rrd.pusher, NULL);\n        \tuspi->freq = u_rrd.freq;\n\t\tuspi->data = dir;\n        \t// no need to generate the json\n        \tuspi->raw=1;\n\t}\n\n}\n\nstatic void rrdtool_push(struct uwsgi_stats_pusher_instance *uspi, time_t now, char *json, size_t json_len) {\n\n\tif (!u_rrd.update) return ;\n\n\t// standard stats pusher\n\tif (!uspi->data) {\n\t\tif (!uspi->arg) {\n\t\t\tuwsgi_log(\"invalid rrdtool stats pusher syntax\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tuspi->data = uwsgi_expand_path(uspi->arg, strlen(uspi->arg), NULL);\n\t\tif (!uspi->data) {\n\t\t\tuwsgi_error(\"rrdtool_push()/uwsgi_expand_path()\");\n                        exit(1);\n\t\t}\n\t\tif (!u_rrd.freq) u_rrd.freq = 300;\n\t\tuspi->freq = u_rrd.freq;\n\t}\n\n\t// 1k will be more than enough\n\tchar buf[1024];\n\tchar *argv[3];\n\targv[0] = \"update\";\n\n\tstruct uwsgi_metric *um = uwsgi.metrics;\n\twhile(um) {\n\t\tuwsgi_rlock(uwsgi.metrics_lock);\n\t\tint ret = snprintf(buf, 1024, \"N:%lld\", (long long) (*um->value));\n\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\tif (um->reset_after_push){\n\t\t\tuwsgi_wlock(uwsgi.metrics_lock);\n\t\t\t*um->value = um->initial_value;\n\t\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\t}\n\t\tif (ret < 3 || ret >= 1024) {\n\t\t\tuwsgi_log(\"unable to update rrdtool metric for %s\\n\", um->name);\n\t\t\tgoto next;\n\t\t}\t\t\n\t\tchar *filename = uwsgi_concat4(uspi->data, \"/\", um->name, \".rrd\");\n\t\targv[1] = filename;\n                argv[2] = buf;\n                if (u_rrd.update(3, argv)) {\n                \tuwsgi_log_verbose(\"ERROR: rrd_update(\\\"%s\\\", \\\"%s\\\")\\n\", argv[1], argv[2]);\n                }\n\t\tfree(filename);\nnext:\n\t\tum = um->next;\n\t}\n\n}\n\nstatic void rrdtool_register() {\n\tu_rrd.pusher = uwsgi_register_stats_pusher(\"rrdtool\", rrdtool_push);\n\tu_rrd.pusher->raw = 1;\n}\n\nstruct uwsgi_plugin rrdtool_plugin = {\n\n\t.name = \"rrdtool\",\n\t.options = rrdtool_options,\n\t\n\t.on_load = rrdtool_register,\n\n\t// this is the best phase to create rrd files (if needed)\n\t.preinit_apps = rrdtool_post_init,\n\t// here we get pointers to rrdtool functions\n\t.init = rrdtool_init,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/plugins/gccgo/gccgo_plugin.c": "#include <uwsgi.h>\n\n/*\n\n\tSoon before official Go 1.1, we understood supporting Go in a fork() heavy\n\tenvironment was not blessed by the Go community.\n\n\tInstead of completely dropping support for Go, we studied how the gccgo project works and we\n\tdecided it was a better approach for uWSGI.\n\n\tThis new plugin works by initializing a new \"go runtime\" after each fork().\n\n\tThe runtime calls the Go main function (developed by the user), and pass the whole\n\tuWSGI control to it.\n\t\n\tthe uwsgi.Run() go function directly calls the uwsgi_takeover() function (it automatically\n\tmanages mules, spoolers and workers)\n\n\tThe plugin implements goroutines too.\n\n\tOn startup a goroutine is created for each socket and signals file descriptors.\n\n\tFor every request a new goroutine is created too.\n\n\tThe wsgi_request * structure is attached to the \"closure\" field of the goroutine (PAY ATTENTION)\n\n\teven if the loop engine makes use of the async mode, pthreads could be spawned all over the place.\n\tFor such a reason a mutex is created avoiding the global wsgi_req structures to be clobbered\n\n\tContrary to the standard way Go apps are deployed, the plugin supports loading shared libraries.\n\tWhile this is a common approach in other environments, the Go community prefers monolithic binaries.\n\n\tAs always, choose the model that best suite for you. Eventually building a single uWSGI binary with your Go\n\tapp embedded is pretty easy:\n\n\t\n\tCFLAGS=-DUWSGI_GCCGO_MONOLITHIC UWSGI_ADDITIONAL_SOURCES=t/go/uploadtest.go UWSGI_PROFILE=gccgo make\n\n\tor you can add the following two directives in a build profile:\n\n\tcflags = -DUWSGI_GCCGO_MONOLITHIC\n\tadditional_sources = t/go/uploadtest.go\n\n\n*/\n\nextern struct uwsgi_server uwsgi;\nstruct uwsgi_plugin gccgo_plugin;\n\nstruct uwsgi_gccgo{\n\t// 1 if a main is loaded\n\tint initialized;\n\tstruct uwsgi_string_list *libs;\n\tchar *args;\n\tpthread_mutex_t wsgi_req_lock;\n} ugccgo;\n\n/*\n\tshortcut for enabling the \"goroutines\" loop engine\n*/\nstatic void uwsgi_opt_setup_goroutines(char *opt, char *value, void *foobar) {\n        // set async mode\n        uwsgi_opt_set_int(opt, value, &uwsgi.async);\n        // set loop engine\n        uwsgi.loop = \"goroutines\";\n}\n\nstruct uwsgi_option uwsgi_gccgo_options[] = {\n\t{\"go-load\", required_argument, 0, \"load a go shared library in the process address space, eventually patching main.main and __go_init_main\", uwsgi_opt_add_string_list, &ugccgo.libs, 0},\n\t{\"gccgo-load\", required_argument, 0, \"load a go shared library in the process address space, eventually patching main.main and __go_init_main\", uwsgi_opt_add_string_list, &ugccgo.libs, 0},\n\t{\"go-args\", required_argument, 0, \"set go commandline arguments\", uwsgi_opt_set_str, &ugccgo.args, 0},\n\t{\"gccgo-args\", required_argument, 0, \"set go commandline arguments\", uwsgi_opt_set_str, &ugccgo.args, 0},\n\t{\"goroutines\", required_argument, 0, \"a shortcut setting optimal options for goroutine-based apps, takes the number of max goroutines to spawn as argument\", uwsgi_opt_setup_goroutines, NULL, UWSGI_OPT_THREADS},\n        {0, 0, 0, 0, 0, 0, 0},\n\n};\n\n// no_split_stack is the key to avoid crashing !!!\nvoid* runtime_m(void) __attribute__ ((noinline, no_split_stack));\n\n// initialize runtime\nvoid runtime_check(void);\nvoid runtime_args(int, char **);\nvoid runtime_osinit(void);\nvoid runtime_schedinit(void);\nvoid runtime_main(void);\nvoid runtime_mstart(void *);\n\n// spawn a goroutine\nvoid *__go_go(void *, void *);\n\n// api functions exposed\nextern void uwsgigo_request(void *, void *) __asm__ (\"go.uwsgi.RequestHandler\");\nextern void* uwsgigo_env(void *) __asm__ (\"go.uwsgi.Env\");\nextern void* uwsgigo_env_add(void *, void *, uint16_t, void *, uint16_t) __asm__ (\"go.uwsgi.EnvAdd\");\nextern void uwsgigo_signal_handler(void *, uint8_t) __asm__ (\"go.uwsgi.SignalHandler\");\n\n// for goroutines \nvoid runtime_netpollinit(void);\nvoid runtime_starttheworld(void);\nvoid *runtime_pollOpen(int) __asm__ (\"net.runtime_pollOpen\");\nvoid runtime_pollClose(void *) __asm__ (\"net.runtime_pollClose\");\nvoid runtime_pollUnblock(void *) __asm__ (\"net.runtime_pollUnblock\");\nint runtime_pollWait(void *, int) __asm__ (\"net.runtime_pollWait\");\nvoid runtime_pollSetDeadline(void *, int64_t, int) __asm__ (\"net.runtime_pollSetDeadline\");\nvoid runtime_gosched(void);\n// the current goroutine\nvoid *runtime_g(void);\n// we use the closure field to store the wsgi_req structure\nvoid __go_set_closure(void *);\nvoid *__go_get_closure(void);\n\nstatic void mainstart(void *arg __attribute__((unused))) {\n\truntime_main();\n}\n\n#ifndef UWSGI_GCCGO_MONOLITHIC\nvoid uwsgigo_main_main(void) __asm__ (\"main.main\");\nvoid uwsgigo_main_init(void) __asm__ (\"__go_init_main\");\n#endif\n\nvoid (*uwsgigo_hook_init)(void);\nvoid (*uwsgigo_hook_main)(void);\n\nvoid uwsgigo_main_init(void) {\n\tuwsgigo_hook_init();\n}\n\nvoid uwsgigo_main_main(void) {\n\tuwsgigo_hook_main();\n}\n\nint uwsgi_gccgo_helper_request_body_read(struct wsgi_request *wsgi_req, char *p, uint64_t len) {\n\tssize_t rlen = 0;\n\tchar *buf = uwsgi_request_body_read(wsgi_req, len, &rlen);\n\tif (buf == uwsgi.empty) {\n\t\treturn 0;\n\t}\n\telse if (buf == NULL) {\n\t\treturn -1;\n\t}\n\tmemcpy(p, buf, rlen);\n\treturn (int) rlen;\n}\n\nint uwsgi_gccgo_helper_register_signal(uint8_t signum, char *receiver, void *handler) {\n\treturn uwsgi_register_signal(signum, receiver, handler, gccgo_plugin.modifier1);\n}\n\nstatic void uwsgi_gccgo_initialize() {\n\tif (uwsgi.threads > 1) {\n\t\tuwsgi_log(\"!!! the Go runtime cannot work in multithreaded modes !!!\\n\");\n\t\texit(1);\n\t}\n#ifdef UWSGI_GCCGO_MONOLITHIC\n\tuwsgigo_hook_init = dlsym(RTLD_DEFAULT, \"__go_init_main\");\n\tuwsgigo_hook_main = dlsym(RTLD_DEFAULT, \"main.main\");\n#endif\n\tstruct uwsgi_string_list *usl = ugccgo.libs;\n\twhile(usl) {\n\t\tvoid *handle = dlopen(usl->value, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!handle) {\n\t\t\tuwsgi_log(\"unable to open go shared library: %s\\n\", dlerror());\n\t\t\texit(1);\n\t\t}\n\t\tvoid *g_init = dlsym(handle, \"__go_init_main\");\n\t\tvoid *g_main = dlsym(handle, \"main.main\");\n\t\tif (g_init && g_main) {\n\t\t\tuwsgigo_hook_init = g_init;\n\t\t\tuwsgigo_hook_main = g_main;\n\t\t\tuwsgi_log(\"[uwsgi-gccgo] loaded %s as main\\n\", usl->value);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[uwsgi-gccgo] loaded %s\\n\", usl->value);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tif (!uwsgigo_hook_init || !uwsgigo_hook_main) {\n\t\treturn;\n\t}\n\n\tugccgo.initialized = 1;\n\n\t// Go runtime initialization\n\tint argc = 0;\n\tif (ugccgo.args) {\n        \tchar *argv_list = uwsgi_str(ugccgo.args);\n                char *p, *ctx = NULL;\n\t\tuwsgi_foreach_token(argv_list, \" \", p, ctx) {\n\t\t\targc++;\n                }\n\t\tfree(argv_list);\n        }\n        runtime_check();\n\tif (argc > 0) {\n\t\tchar **argv = uwsgi_calloc(sizeof(char *) * (argc + 2));\n\t\tchar *argv_list = uwsgi_str(ugccgo.args);\n\t\tchar *p, *ctx = NULL;\n\t\tint n = 0;\n\t\tuwsgi_foreach_token(argv_list, \" \", p, ctx) {\n\t\t\targv[n] = p;\n\t\t\tn++;\n                }\n        \truntime_args(argc, argv);\n\t}\n\telse {\n\t\tchar *argv[2] = {0,0};\n        \truntime_args(0, argv);\n\t}\n\n        runtime_osinit();\n        runtime_schedinit();\n        __go_go(mainstart, NULL);\n        runtime_mstart(runtime_m());\n\t// never here\n}\n\nstatic int uwsgi_gccgo_request(struct wsgi_request *wsgi_req) {\n\tif (!ugccgo.initialized) {\n\t\tuwsgi_log(\"!!! Go runtime not initialized !!!\\n\");\n\t\tgoto end;\n\t}\n\t/* Standard GO request */\n        if (!wsgi_req->uh->pktsize) {\n                uwsgi_log(\"Empty GO request. skip.\\n\");\n                return -1;\n        }\n\n        if (uwsgi_parse_vars(wsgi_req)) {\n                return -1;\n        }\n\n\twsgi_req->async_environ = uwsgigo_env(wsgi_req);\n\tint i;\n        for(i=0;i<wsgi_req->var_cnt;i+=2) {\n                uwsgigo_env_add(wsgi_req->async_environ, wsgi_req->hvec[i].iov_base,  wsgi_req->hvec[i].iov_len, wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len);\n        }\n\tuwsgigo_request(wsgi_req->async_environ, wsgi_req);\nend:\n\treturn UWSGI_OK;\n}\n\nstatic void uwsgi_gccgo_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nstatic int uwsgi_gccgo_signal_handler(uint8_t signum, void *handler) {\n\tif (!ugccgo.initialized) return -1;\n        uwsgigo_signal_handler(handler, signum);\n\treturn 0;\n}\n\n#define free_req_queue pthread_mutex_lock(&ugccgo.wsgi_req_lock);uwsgi.async_queue_unused_ptr++; uwsgi.async_queue_unused[uwsgi.async_queue_unused_ptr] = wsgi_req; pthread_mutex_unlock(&ugccgo.wsgi_req_lock)\n\nstatic void uwsgi_gccgo_request_goroutine(void *arg) {\n\n\tstruct wsgi_request *wsgi_req = (struct wsgi_request *) arg;\n\n\t// map wsgi_req to the goroutine\n\t__go_set_closure(wsgi_req);\n\n\tint ret,status;\n\n        for(;;) {\n                ret = uwsgi.wait_read_hook(wsgi_req->fd, uwsgi.socket_timeout);\n                wsgi_req->switches++;\n\n                if (ret <= 0) {\n                        goto end;\n                }\n\nretry:\n                status = wsgi_req->socket->proto(wsgi_req);\n                if (status < 0) {\n                        goto end;\n                }\n                else if (status == 0) {\n                        break;\n                }\n\t\tif (uwsgi_is_again()) continue;\n\t\tgoto retry;\n        }\n\n#ifdef UWSGI_ROUTING\n        if (uwsgi_apply_routes(wsgi_req) == UWSGI_ROUTE_BREAK) {\n                goto end;\n        }\n#endif\n\n        for(;;) {\n                if (uwsgi.p[wsgi_req->uh->modifier1]->request(wsgi_req) <= UWSGI_OK) {\n                        goto end;\n                }\n                wsgi_req->switches++;\n\t\t// yield\n\t\truntime_gosched();\n        }\n\nend:\n        uwsgi_close_request(wsgi_req);\n        free_req_queue;\n}\n\nstatic struct wsgi_request *uwsgi_gccgo_current_wsgi_req(void) {\n\treturn (struct wsgi_request *) __go_get_closure();\n}\n\nstatic int uwsgi_gccgo_wait_read_hook(int fd, int timeout) {\n        void *pdesc = runtime_pollOpen(fd);\n\tint64_t t = (uwsgi_micros() * 1000LL) + (((int64_t)timeout) * 1000LL * 1000LL * 1000LL);\n\truntime_pollSetDeadline(pdesc, t, 'r');\n        int ret = runtime_pollWait(pdesc, 'r');\n\truntime_pollUnblock(pdesc);\n        runtime_pollClose(pdesc);\n\tif (ret == 0) return 1;\n\t// timeout\n\tif (ret == 2) return 0;\n\treturn -1;\n}\n\nstatic int uwsgi_gccgo_wait_write_hook(int fd, int timeout) {\n\tvoid *pdesc = runtime_pollOpen(fd);\n\tint64_t t = (uwsgi_micros() * 1000LL) + (((int64_t)timeout) * 1000LL * 1000LL * 1000LL);\n\truntime_pollSetDeadline(pdesc, t, 'w');\n\tint ret = runtime_pollWait(pdesc, 'w');\t\n\truntime_pollUnblock(pdesc);\n\truntime_pollClose(pdesc);\n\tif (ret == 0) return 1;\n\t// timeout\n\tif (ret == 2) return 0;\n\treturn -1;\n}\n\n/*\n\tthis goroutine manages signals\n*/\nstatic void uwsgi_gccgo_signal_goroutine(void *arg) {\n\tint *fd = (int *) arg;\n\tvoid *pdesc = runtime_pollOpen(*fd);\n\tfor(;;) {\n\t\truntime_pollWait(pdesc, 'r');\nretry:\n\t\tuwsgi_receive_signal(*fd, \"worker\", uwsgi.mywid);\n\t\tif (uwsgi_is_again()) continue;\n\t\tgoto retry;\n\t}\n}\n\nstatic void uwsgi_gccgo_socket_goroutine(void *arg) {\n\tstruct uwsgi_socket *uwsgi_sock = (struct uwsgi_socket *) arg;\n\tstruct wsgi_request *wsgi_req = NULL;\n\tvoid *pdesc = runtime_pollOpen(uwsgi_sock->fd);\n\t// wait for connection\n\tfor(;;) {\n\t\truntime_pollWait(pdesc, 'r');\t\nretry:\n\t\tpthread_mutex_lock(&ugccgo.wsgi_req_lock);\n\t\twsgi_req = find_first_available_wsgi_req();\n\t\tpthread_mutex_unlock(&ugccgo.wsgi_req_lock);\n\n\t\tif (wsgi_req == NULL) {\n                \tuwsgi_async_queue_is_full(uwsgi_now());\n\t\t\t// try rescheduling...\n\t\t\t// we do not use runtime_gosched() as we want to call the netpoll loop too\n\t\t\truntime_pollUnblock(pdesc);\n\t\t\truntime_pollClose(pdesc);\n\t\t\tpdesc = runtime_pollOpen(uwsgi_sock->fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// fill wsgi_request structure\n\t\twsgi_req_setup(wsgi_req, wsgi_req->async_id, uwsgi_sock );\n\n\t\t// mark core as used\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\t\t// accept the connection (since uWSGI 1.5 all of the sockets are non-blocking)\n\t\tif (wsgi_req_simple_accept(wsgi_req, uwsgi_sock->fd)) {\n\t\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n                \tfree_req_queue;\n\t\t\tif (uwsgi_is_again()) continue;\n                        goto retry;\n                }\n\n\t\twsgi_req->start_of_request = uwsgi_micros();\n\t\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request/1000000;\n\n\t\t// enter harakiri mode\n\t\tif (uwsgi.harakiri_options.workers > 0) {\n                \tset_harakiri(uwsgi.harakiri_options.workers);\n        \t}\n\n\t\t// spawn the new goroutine\n\t\t__go_go(uwsgi_gccgo_request_goroutine, wsgi_req);\n\t\tgoto retry;\n\t}\n}\n\nstatic void uwsgi_gccgo_loop() {\n\tif (!ugccgo.initialized) {\n\t\tuwsgi_log(\"no go.main code loaded !!!\\n\");\n\t\texit(1);\n\t}\n\t// initialize the log protecting the wsgi_req structures\n\tpthread_mutex_init(&ugccgo.wsgi_req_lock, NULL);\n\n\t// hooks\n\tuwsgi.current_wsgi_req = uwsgi_gccgo_current_wsgi_req;\n\tuwsgi.wait_write_hook = uwsgi_gccgo_wait_write_hook;\n        uwsgi.wait_read_hook = uwsgi_gccgo_wait_read_hook;\n\n\t// ininitialize Go I/O loop\n\truntime_netpollinit();\n\n\tif (uwsgi.signal_socket > -1) {\n\t\t__go_go(uwsgi_gccgo_signal_goroutine, &uwsgi.signal_socket);\n\t\t__go_go(uwsgi_gccgo_signal_goroutine, &uwsgi.my_signal_socket);\n\t}\n\n\t// start a goroutine for each socket\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\twhile(uwsgi_sock) {\n\t\tif (!uwsgi_sock->next) {\n\t\t\tuwsgi_gccgo_socket_goroutine(uwsgi_sock);\n\t\t}\n\t\telse {\n\t\t\t__go_go(uwsgi_gccgo_socket_goroutine, uwsgi_sock);\n\t\t}\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\t// never here\n}\n\nstatic void uwsgi_gccgo_on_load() {\n\tuwsgi_register_loop( (char *) \"go\", uwsgi_gccgo_loop);\n\tuwsgi_register_loop( (char *) \"goroutine\", uwsgi_gccgo_loop);\n\tuwsgi_register_loop( (char *) \"goroutines\", uwsgi_gccgo_loop);\n}\n\nstruct uwsgi_plugin gccgo_plugin = {\n        .name = \"gccgo\",\n        .modifier1 = 11,\n\t.options = uwsgi_gccgo_options,\n\t.on_load = uwsgi_gccgo_on_load,\n        .request = uwsgi_gccgo_request,\n        .after_request = uwsgi_gccgo_after_request,\n        .post_fork = uwsgi_gccgo_initialize,\n\t.signal_handler = uwsgi_gccgo_signal_handler,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/plugins/pypy/pypy_setup.py": "import sys\nimport os\nsys.path.insert(0, '.')\nsys.path.extend(os.environ.get('PYTHONPATH','').split(os.pathsep))\nimport imp\nimport traceback\n\n\n__name__ = '__main__'\nmainmodule = type(sys)('__main__')\nsys.modules['__main__'] = mainmodule\n\nimport cffi\n\n# this is a list holding object we do not want to be freed (like callback and handlers)\nuwsgi_gc = []\n# the main ffi\nffi = cffi.FFI()\n\n# the hooks we need to patch\nhooks = '''\nvoid free(void *);\nssize_t read(int, void *, size_t);\nssize_t write(int, const void *, size_t);\nint close(int);\n\nvoid (*uwsgi_pypy_hook_execute_source)(char *);\nvoid (*uwsgi_pypy_hook_loader)(char *);\nvoid (*uwsgi_pypy_hook_file_loader)(char *);\nvoid (*uwsgi_pypy_hook_paste_loader)(char *);\nvoid (*uwsgi_pypy_hook_pythonpath)(char *);\nvoid (*uwsgi_pypy_hook_request)(struct wsgi_request *);\nvoid (*uwsgi_pypy_post_fork_hook)(void);\n'''\n\n# here we load CFLAGS and uwsgi.h from the binary\ndefines0 = '''\nchar *uwsgi_get_cflags();\nchar *uwsgi_get_dot_h();\n'''\nffi.cdef(defines0)\nlib0 = ffi.verify(defines0)\n\n\n# this is ugly, we should find a better approach\n# basically it build a list of #define from binary CFLAGS\nuwsgi_cdef = []\nuwsgi_defines = []\nuwsgi_cflags = ffi.string(lib0.uwsgi_get_cflags()).split()\nfor cflag in uwsgi_cflags:\n    if cflag.startswith('-D'):\n        line = cflag[2:]\n        if '=' in line:\n            (key, value) = line.split('=', 1)\n            uwsgi_cdef.append('#define %s ...' % key)\n            uwsgi_defines.append('#define %s %s' % (key, value.replace('\\\\\"','\"').replace('\"\"','\"')))            \n        else:\n            uwsgi_cdef.append('#define %s ...' % line)\n            uwsgi_defines.append('#define %s 1' % line)            \nuwsgi_dot_h = ffi.string(lib0.uwsgi_get_dot_h())\n\n# uwsgi definitions\ncdefines = '''\n%s\n\nstruct iovec {\n\tvoid *iov_base;\n\tsize_t iov_len;\n\t...;\n};\n\nstruct uwsgi_header {\n\tuint8_t modifier1;\n\t...;\n};\n\nstruct wsgi_request {\n\tint fd;\n\tint async_id;\n\tuint16_t var_cnt;\n\tstruct iovec *hvec;\n\n\tint async_ready_fd;\n\tint async_last_ready_fd;\n\n\tint suspended;\n\n\tstruct uwsgi_header *uh;\n\t...;\n};\n\nstruct uwsgi_opt {\n\tchar *key;\n\tchar *value;\n\t...;\n};\n\nstruct uwsgi_worker {\n\tint id;\n\tint pid;\n\tuint64_t requests;\n\tuint64_t delta_requests;\n\tuint64_t signals;\n\n\tint cheaped;\n\tint suspended;\n\tint sig;\n\tuint8_t signum;\n\n\tuint64_t running_time;\n\tuint64_t avg_response_time;\n\tuint64_t tx;\n\t...;\n};\n\nstruct uwsgi_plugin {\n\tuint8_t modifier1;\n\n\tvoid (*suspend) (struct wsgi_request *);\n        void (*resume) (struct wsgi_request *);\n\t...;\n};\n\nstruct uwsgi_buffer {\n\tchar *buf;\n\tsize_t pos;\n\t...;\n};\n\nstruct uwsgi_lock_item {\n\t...;\n};\n\nstruct uwsgi_cache {\n\tstruct uwsgi_lock_item *lock;\n\t...;\n};\n\nstruct uwsgi_cache_item {\n\tuint64_t keysize;\n\t...;\n};\n\nstruct uwsgi_server {\n\tchar hostname[];\n\tint mywid;\n\tint muleid;\n\tint master_process;\n\n\tstruct uwsgi_opt **exported_opts;\n\tint exported_opts_cnt;\t\n\n\tstruct uwsgi_worker *workers;\n\n\tint signal_socket;\n\tint numproc;\n\tint async;\n\n\tvoid (*schedule_to_main) (struct wsgi_request *);\n        void (*schedule_to_req) (void);\n\n\tstruct wsgi_request *(*current_wsgi_req) (void);\n\t\n\tstruct wsgi_request *wsgi_req;\n\n\tstruct uwsgi_plugin *p[];\n\t...;\n};\nstruct uwsgi_server uwsgi;\n\nstruct uwsgi_plugin pypy_plugin;\n\nconst char *uwsgi_pypy_version;\n\nchar *uwsgi_binary_path();\n\nvoid *uwsgi_malloc(size_t);\n\nint uwsgi_response_prepare_headers(struct wsgi_request *, char *, size_t);\nint uwsgi_response_add_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);\nint uwsgi_response_write_body_do(struct wsgi_request *, char *, size_t);\nint uwsgi_response_sendfile_do_can_close(struct wsgi_request *, int, size_t, size_t, int);\n\nchar *uwsgi_request_body_read(struct wsgi_request *, ssize_t , ssize_t *);\nchar *uwsgi_request_body_readline(struct wsgi_request *, ssize_t, ssize_t *);\n\nvoid uwsgi_buffer_destroy(struct uwsgi_buffer *);\nint uwsgi_is_again();\n\nint uwsgi_register_rpc(char *, struct uwsgi_plugin *, uint8_t, void *);\nint uwsgi_register_signal(uint8_t, char *, void *, uint8_t);\n\nchar *uwsgi_do_rpc(char *, char *, uint8_t, char **, uint16_t *, uint64_t *);\n\nvoid uwsgi_set_processname(char *);\nint uwsgi_signal_send(int, uint8_t);\nuint64_t uwsgi_worker_exceptions(int);\nint uwsgi_worker_is_busy(int);\n\nchar *uwsgi_cache_magic_get(char *, uint16_t, uint64_t *, uint64_t *, char *);\nint uwsgi_cache_magic_set(char *, uint16_t, char *, uint64_t, uint64_t, uint64_t, char *);\nint uwsgi_cache_magic_del(char *, uint16_t, char *);\nint uwsgi_cache_magic_exists(char *, uint16_t, char *);\nint uwsgi_cache_magic_clear(char *);\nstruct uwsgi_cache *uwsgi_cache_by_name(char *);\nvoid uwsgi_cache_rlock(struct uwsgi_cache *);\nvoid uwsgi_cache_rwunlock(struct uwsgi_cache *);\nchar *uwsgi_cache_item_key(struct uwsgi_cache_item *);\nstruct uwsgi_cache_item *uwsgi_cache_keys(struct uwsgi_cache *, uint64_t *, struct uwsgi_cache_item **);\n\nint uwsgi_add_file_monitor(uint8_t, char *);\nint uwsgi_add_timer(uint8_t, int);\nint uwsgi_signal_add_rb_timer(uint8_t, int, int);\n\nint uwsgi_user_lock(int);\nint uwsgi_user_unlock(int);\n\nint uwsgi_signal_registered(uint8_t);\n\nint uwsgi_signal_add_cron(uint8_t, int, int, int, int, int);\nvoid uwsgi_alarm_trigger(char *, char *, size_t);\n\nvoid async_schedule_to_req_green(void);\nvoid async_add_timeout(struct wsgi_request *, int);\nint async_add_fd_write(struct wsgi_request *, int, int);\nint async_add_fd_read(struct wsgi_request *, int, int);\nint uwsgi_connect(char *, int, int);\n\nint uwsgi_websocket_handshake(struct wsgi_request *, char *, uint16_t, char *, uint16_t, char *, uint16_t);\nint uwsgi_websocket_send(struct wsgi_request *, char *, size_t);\nstruct uwsgi_buffer *uwsgi_websocket_recv(struct wsgi_request *);\nstruct uwsgi_buffer *uwsgi_websocket_recv_nb(struct wsgi_request *);\n\nchar *uwsgi_chunked_read(struct wsgi_request *, size_t *, int, int);\n\nvoid uwsgi_disconnect(struct wsgi_request *);\n\nint uwsgi_ready_fd(struct wsgi_request *);\n\nvoid set_user_harakiri(int);\n\nint uwsgi_metric_set(char *, char *, int64_t);\nint uwsgi_metric_inc(char *, char *, int64_t);\nint uwsgi_metric_dec(char *, char *, int64_t);\nint uwsgi_metric_mul(char *, char *, int64_t);\nint uwsgi_metric_div(char *, char *, int64_t);\nint64_t uwsgi_metric_get(char *, char *);\n\n%s\n\n''' % ('\\n'.join(uwsgi_cdef), hooks)\n\ncverify = '''\n%s\n\nconst char *uwsgi_pypy_version = UWSGI_VERSION;\n\n%s\n\nextern struct uwsgi_server uwsgi;\nextern struct uwsgi_plugin pypy_plugin;\n%s\n''' % ('\\n'.join(uwsgi_defines), uwsgi_dot_h, hooks)\n\nffi.cdef(cdefines)\nlib = ffi.verify(cverify)\nlibc = ffi.dlopen(None)\n\n\n\n\"\"\"\nthis is a global object point the the WSGI callable\nit sucks, i will fix it in the near future...\n\"\"\"\nwsgi_application = None\n\n# fix argv if needed\nif len(sys.argv) == 0:\n    sys.argv.insert(0, ffi.string(lib.uwsgi_binary_path()))\n\n\"\"\"\nexecute source, we expose it as cffi callback to avoid deadlocks\nafter GIL initialization\n\"\"\"\n@ffi.callback(\"void(char *)\")\ndef uwsgi_pypy_execute_source(s):\n    source = ffi.string(s)\n    exec(source)\n\n\"\"\"\nload a wsgi module\n\"\"\"\n@ffi.callback(\"void(char *)\")\ndef uwsgi_pypy_loader(module):\n    global wsgi_application\n    m = ffi.string(module)\n    c = 'application'\n    if ':' in m:\n        m, c = m.split(':')\n    if '.' in m:\n        mod = __import__(m, None, None, '*')\n    else:\n        mod = __import__(m)\n    wsgi_application = getattr(mod, c)\n\n\"\"\"\nload a mod_wsgi compliant .wsgi file\n\"\"\"\n@ffi.callback(\"void(char *)\")\ndef uwsgi_pypy_file_loader(filename):\n    global wsgi_application\n    w = ffi.string(filename)\n    c = 'application'\n    mod = imp.load_source('uwsgi_file_wsgi', w)\n    wsgi_application = getattr(mod, c)\n\n\"\"\"\nload a .ini paste app\n\"\"\"\n@ffi.callback(\"void(char *)\")\ndef uwsgi_pypy_paste_loader(config):\n    global wsgi_application\n    c = ffi.string(config)\n    if c.startswith('config:'):\n        c = c[7:]\n    if c[0] != '/':\n        c = os.getcwd() + '/' + c\n    try:\n        from paste.script.util.logging_config import fileConfig\n        fileConfig(c)\n    except ImportError:\n        print \"PyPy WARNING: unable to load paste.script.util.logging_config\"\n    from paste.deploy import loadapp\n    wsgi_application = loadapp('config:%s' % c)\n\n\"\"\"\n.post_fork_hook\n\"\"\"\n@ffi.callback(\"void()\")\ndef uwsgi_pypy_post_fork_hook():\n    import uwsgi\n    if hasattr(uwsgi, 'post_fork_hook'):\n        uwsgi.post_fork_hook()\n\n\"\"\"\nadd an item to the pythonpath\n\"\"\"\n@ffi.callback(\"void(char *)\")\ndef uwsgi_pypy_pythonpath(item):\n    path = ffi.string(item)\n    sys.path.append(path)\n    print \"added %s to pythonpath\" % path\n\n\n\"\"\"\nclass implementing wsgi.file_wrapper\n\"\"\"\nclass WSGIfilewrapper(object):\n    def __init__(self, wsgi_req, f, chunksize=0):\n        self.wsgi_req = wsgi_req\n        self.f = f\n        self.chunksize = chunksize\n        if hasattr(f, 'close'):\n            self.close = f.close\n\n    def __iter__(self):\n        return self\n\n    def sendfile(self):\n        if hasattr(self.f, 'fileno'):\n            lib.uwsgi_response_sendfile_do_can_close(self.wsgi_req, self.f.fileno(), 0, 0, 0)\n        elif hasattr(self.f, 'read'):\n            if self.chunksize == 0:\n                chunk = self.f.read()\n                if len(chunk) > 0:\n                    lib.uwsgi_response_write_body_do(self.wsgi_req, ffi.new(\"char[]\", chunk), len(chunk))\n                return\n            while True:\n                chunk = self.f.read(self.chunksize)\n                if chunk is None or len(chunk) == 0:\n                    break\n                lib.uwsgi_response_write_body_do(self.wsgi_req, ffi.new(\"char[]\", chunk), len(chunk))\n\n\n\"\"\"\nclass implementing wsgi.input\n\"\"\"\nclass WSGIinput(object):\n    def __init__(self, wsgi_req):\n        self.wsgi_req = wsgi_req\n\n    def read(self, size=0):\n        rlen = ffi.new('ssize_t*')\n        chunk = lib.uwsgi_request_body_read(self.wsgi_req, size, rlen)\n        if chunk != ffi.NULL:\n            return ffi.buffer(chunk, rlen[0])[:]\n        if rlen[0] < 0:\n            raise IOError(\"error reading wsgi.input\")\n        raise IOError(\"error waiting for wsgi.input\")\n\n    def getline(self, hint=0):\n        rlen = ffi.new('ssize_t*')\n        chunk = lib.uwsgi_request_body_readline(self.wsgi_req, hint, rlen)\n        if chunk != ffi.NULL:\n            return ffi.buffer(chunk, rlen[0])[:]\n        if rlen[0] < 0:\n            raise IOError(\"error reading line from wsgi.input\")\n        raise IOError(\"error waiting for line on wsgi.input\")\n\n    def readline(self, hint=0):\n        return self.getline(hint)\n\n    def readlines(self, hint=0):\n        lines = []\n        while True:\n            chunk = self.getline(hint)\n            if len(chunk) == 0:\n                break\n            lines.append(chunk)\n        return lines\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        chunk = self.getline()\n        if len(chunk) == 0:\n            raise StopIteration\n        return chunk\n\n\n\"\"\"\nthe WSGI request handler\n\"\"\"\n@ffi.callback(\"void(struct wsgi_request *)\")\ndef uwsgi_pypy_wsgi_handler(wsgi_req):\n    import uwsgi\n    global wsgi_application\n\n    def writer(data):\n        lib.uwsgi_response_write_body_do(wsgi_req, ffi.new(\"char[]\", data), len(data))\n\n    def start_response(status, headers, exc_info=None):\n        if exc_info:\n            traceback.print_exception(*exc_info)\n        lib.uwsgi_response_prepare_headers(wsgi_req, ffi.new(\"char[]\", status), len(status))\n        for hh in headers:\n            lib.uwsgi_response_add_header(wsgi_req, ffi.new(\"char[]\", hh[0]), len(hh[0]), ffi.new(\"char[]\", hh[1]), len(hh[1]))\n        return writer\n\n    environ = {}\n    iov = wsgi_req.hvec\n    for i in range(0, wsgi_req.var_cnt, 2):\n        environ[ffi.string(ffi.cast(\"char*\", iov[i].iov_base), iov[i].iov_len)] = ffi.string(ffi.cast(\"char*\", iov[i+1].iov_base), iov[i+1].iov_len)\n\n    environ['wsgi.version'] = (1, 0)\n    scheme = 'http'\n    if 'HTTPS' in environ:\n        if environ['HTTPS'] in ('on', 'ON', 'On', '1', 'true', 'TRUE', 'True'):\n            scheme = 'https'\n    environ['wsgi.url_scheme'] = environ.get('UWSGI_SCHEME', scheme)\n    environ['wsgi.input'] = WSGIinput(wsgi_req)\n    environ['wsgi.errors'] = sys.stderr\n    environ['wsgi.run_once'] = False\n    environ['wsgi.file_wrapper'] = lambda f, chunksize=0: WSGIfilewrapper(wsgi_req, f, chunksize)\n    environ['wsgi.multithread'] = True\n    environ['wsgi.multiprocess'] = True\n\n    environ['uwsgi.core'] = wsgi_req.async_id\n    environ['uwsgi.node'] = uwsgi.hostname\n\n    response = wsgi_application(environ, start_response)\n    if type(response) is str:\n        writer(response)\n    else:\n        try:\n            if isinstance(response, WSGIfilewrapper):\n                response.sendfile()\n            else:\n                for chunk in response:\n                    if isinstance(chunk, WSGIfilewrapper):\n                        try:\n                            chunk.sendfile()\n                        finally:\n                            chunk.close()\n                    else:\n                        writer(chunk)\n        finally:\n            if hasattr(response, 'close'):\n                response.close()\n\nlib.uwsgi_pypy_hook_execute_source = uwsgi_pypy_execute_source\nlib.uwsgi_pypy_hook_loader = uwsgi_pypy_loader\nlib.uwsgi_pypy_hook_file_loader = uwsgi_pypy_file_loader\nlib.uwsgi_pypy_hook_paste_loader = uwsgi_pypy_paste_loader\nlib.uwsgi_pypy_hook_pythonpath = uwsgi_pypy_pythonpath\nlib.uwsgi_pypy_hook_request = uwsgi_pypy_wsgi_handler\nlib.uwsgi_pypy_post_fork_hook = uwsgi_pypy_post_fork_hook\n\n\"\"\"\nHere we define the \"uwsgi\" virtual module\n\"\"\"\n\nuwsgi = imp.new_module('uwsgi')\nsys.modules['uwsgi'] = uwsgi\nuwsgi.version = ffi.string(lib.uwsgi_pypy_version)\nuwsgi.hostname = ffi.string(lib.uwsgi.hostname)\n\ndef uwsgi_pypy_uwsgi_register_signal(signum, kind, handler):\n    cb = ffi.callback('void(int)', handler)\n    uwsgi_gc.append(cb)\n    if lib.uwsgi_register_signal(signum, ffi.new(\"char[]\", kind), cb, lib.pypy_plugin.modifier1) < 0:\n        raise Exception(\"unable to register signal %d\" % signum)\nuwsgi.register_signal = uwsgi_pypy_uwsgi_register_signal\n\n\nclass uwsgi_pypy_RPC(object):\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, argc, argv, argvs, buf):\n        pargs = []\n        for i in range(0, argc):\n            pargs.append(ffi.buffer(argv[i], argvs[i])[:])\n        response = self.func(*pargs)\n        if len(response) > 0:\n            buf[0] = lib.uwsgi_malloc(len(response))\n            dst = ffi.buffer(buf[0], len(response))\n            dst[:len(response)] = response\n        return len(response)\n\n\ndef uwsgi_pypy_uwsgi_register_rpc(name, func, argc=0):\n    rpc_func = uwsgi_pypy_RPC(func)\n    cb = ffi.callback(\"int(int, char*[], int[], char**)\", rpc_func)\n    uwsgi_gc.append(cb)\n    if lib.uwsgi_register_rpc(ffi.new(\"char[]\", name), ffi.addressof(lib.pypy_plugin), argc, cb) < 0:\n        raise Exception(\"unable to register rpc func %s\" % name)\nuwsgi.register_rpc = uwsgi_pypy_uwsgi_register_rpc\n\ndef uwsgi_pypy_rpc(node, func, *args):\n    argc = 0\n    argv = ffi.new('char*[256]')\n    argvs = ffi.new('uint16_t[256]')\n    rsize = ffi.new('uint64_t*')\n\n    for arg in args:\n        if argc >= 255:\n            raise Exception('invalid number of rpc arguments')\n        if len(arg) >= 65535:\n            raise Exception('invalid rpc argument size (must be < 65535)')\n        argv[argc] = ffi.new('char[]', arg)\n        argvs[argc] = len(arg)\n        argc += 1\n\n    if node:\n        c_node = ffi.new(\"char[]\", node)\n    else:\n        c_node = ffi.NULL\n\n    response = lib.uwsgi_do_rpc(c_node, ffi.new(\"char[]\",func), argc, argv, argvs, rsize)\n    if response:\n        ret = ffi.buffer(response, rsize[0])[:]\n        lib.free(response)\n        return ret\n    return None\nuwsgi.rpc = uwsgi_pypy_rpc\n\ndef uwsgi_pypy_call(func, *args):\n    node = None\n    if '@' in func:\n        (func, node) = func.split('@')\n    return uwsgi_pypy_rpc(node, func, *args)\nuwsgi.call = uwsgi_pypy_call\n    \nuwsgi.signal = lambda x: lib.uwsgi_signal_send(lib.uwsgi.signal_socket, x)\n\nuwsgi.metric_get = lambda x: lib.uwsgi_metric_get(x, ffi.NULL)\nuwsgi.metric_set = lambda x, y: lib.uwsgi_metric_set(x, ffi.NULL, y)\nuwsgi.metric_inc = lambda x, y=1: lib.uwsgi_metric_inc(x, ffi.NULL, y)\nuwsgi.metric_dec = lambda x, y=1: lib.uwsgi_metric_dec(x, ffi.NULL, y)\nuwsgi.metric_mul = lambda x, y=1: lib.uwsgi_metric_mul(x, ffi.NULL, y)\nuwsgi.metric_div = lambda x, y=1: lib.uwsgi_metric_div(x, ffi.NULL, y)\n\ndef uwsgi_pypy_uwsgi_cache_get(key, cache=ffi.NULL):\n    vallen = ffi.new('uint64_t*')\n    value = lib.uwsgi_cache_magic_get(key, len(key), vallen, ffi.NULL, cache)\n    if value == ffi.NULL:\n        return None\n    ret = ffi.buffer(value, vallen[0])[:]\n    libc.free(value)\n    return ret\nuwsgi.cache_get = uwsgi_pypy_uwsgi_cache_get\n\ndef uwsgi_pypy_uwsgi_cache_set(key, value, expires=0, cache=ffi.NULL):\n    if lib.uwsgi_cache_magic_set(key, len(key), value, len(value), expires, 0, cache) < 0:\n        raise Exception('unable to store item in the cache')\nuwsgi.cache_set = uwsgi_pypy_uwsgi_cache_set\n\ndef uwsgi_pypy_uwsgi_cache_update(key, value, expires=0, cache=ffi.NULL):\n    if lib.uwsgi_cache_magic_set(key, len(key), value, len(value), expires, 1 << 1, cache) < 0:\n        raise Exception('unable to store item in the cache')\nuwsgi.cache_update = uwsgi_pypy_uwsgi_cache_update\n\ndef uwsgi_pypy_uwsgi_cache_del(key, cache=ffi.NULL):\n    if lib.uwsgi_cache_magic_del(key, len(key), cache) < 0:\n        raise Exception('unable to delete item from the cache')\nuwsgi.cache_del = uwsgi_pypy_uwsgi_cache_del\n\ndef uwsgi_pypy_uwsgi_cache_keys(cache=ffi.NULL):\n    uc = lib.uwsgi_cache_by_name(cache)\n    if uc == ffi.NULL:\n        raise Exception('no local uWSGI cache available')\n    l = []\n    lib.uwsgi_cache_rlock(uc)\n    pos = ffi.new('uint64_t *')\n    uci = ffi.new('struct uwsgi_cache_item **')\n    while True:\n        uci[0] = lib.uwsgi_cache_keys(uc, pos, uci)\n        if uci[0] == ffi.NULL:\n            break\n        l.append(ffi.buffer(lib.uwsgi_cache_item_key(uci[0]), uci[0].keysize)[:])\n    lib.uwsgi_cache_rwunlock(uc)\n    return l\nuwsgi.cache_keys = uwsgi_pypy_uwsgi_cache_keys\n\ndef uwsgi_pypy_uwsgi_add_timer(signum, secs):\n    if lib.uwsgi_add_timer(signum, secs) < 0:\n        raise Exception(\"unable to register timer\")\nuwsgi.add_timer = uwsgi_pypy_uwsgi_add_timer\n\ndef uwsgi_pypy_uwsgi_add_rb_timer(signum, secs):\n    if lib.uwsgi_signal_add_rb_timer(signum, secs, 0) < 0:\n        raise Exception(\"unable to register redblack timer\")\nuwsgi.add_rb_timer = uwsgi_pypy_uwsgi_add_rb_timer\n\n\ndef uwsgi_pypy_uwsgi_add_file_monitor(signum, filename):\n    if lib.uwsgi_add_file_monitor(signum, ffi.new(\"char[]\", filename)) < 0:\n        raise Exception(\"unable to register file monitor\")\nuwsgi.add_file_monitor = uwsgi_pypy_uwsgi_add_file_monitor\n\ndef uwsgi_pypy_lock(num=0):\n    if lib.uwsgi_user_lock(num) < 0:\n        raise Exception(\"invalid lock\")\nuwsgi.lock = uwsgi_pypy_lock\n\ndef uwsgi_pypy_unlock(num=0):\n    if lib.uwsgi_user_unlock(num) < 0:\n        raise Exception(\"invalid lock\")\nuwsgi.unlock = uwsgi_pypy_unlock\n\ndef uwsgi_pypy_masterpid():\n    if lib.uwsgi.master_process:\n        return lib.uwsgi.workers[0].pid\n    return 0\nuwsgi.masterpid = uwsgi_pypy_masterpid\n\nuwsgi.worker_id = lambda: lib.uwsgi.mywid\n\nuwsgi.mule_id = lambda: lib.uwsgi.muleid\n\ndef uwsgi_pypy_signal_registered(signum):\n    if lib.uwsgi_signal_registered(signum) > 0:\n        return True\n    return False\nuwsgi.signal_registered = uwsgi_pypy_signal_registered\n\ndef uwsgi_pypy_alarm(alarm, msg):\n    lib.uwsgi_alarm_trigger(ffi.new('char[]', alarm), ffi.new('char[]', msg), len(msg))\nuwsgi.alarm = uwsgi_pypy_alarm\n\nuwsgi.setprocname = lambda name: lib.uwsgi_set_processname(ffi.new('char[]', name))\n\ndef uwsgi_pypy_add_cron(signum, minute, hour, day, month, week):\n    if lib.uwsgi_signal_add_cron(signum, minute, hour, day, month, week) < 0:\n        raise Exception(\"unable to register cron\")\nuwsgi.add_cron = uwsgi_pypy_add_cron\n\n\"\"\"\npopulate uwsgi.opt\n\"\"\"\nuwsgi.opt = {}\nfor i in range(0, lib.uwsgi.exported_opts_cnt):\n    uo = lib.uwsgi.exported_opts[i]\n    k = ffi.string(uo.key)\n    if uo.value == ffi.NULL:\n        v = True\n    else:\n        v = ffi.string(uo.value)\n    if k in uwsgi.opt:\n        if type(uwsgi.opt[k]) is list:\n            uwsgi.opt[k].append(v)\n        else:\n            uwsgi.opt[k] = [uwsgi.opt[k], v]\n    else:\n        uwsgi.opt[k] = v\n\ndef uwsgi_pypy_current_wsgi_req():\n    wsgi_req = lib.uwsgi.current_wsgi_req()\n    if wsgi_req == ffi.NULL:\n        raise Exception(\"unable to get current wsgi_request, check your setup !!!\")\n    return wsgi_req\n\n\"\"\"\nuwsgi.suspend()\n\"\"\"\ndef uwsgi_pypy_suspend():\n    wsgi_req = uwsgi_pypy_current_wsgi_req()\n    if lib.uwsgi.schedule_to_main:\n        lib.uwsgi.schedule_to_main(wsgi_req);\nuwsgi.suspend = uwsgi_pypy_suspend\n\n\"\"\"\nuwsgi.workers()\n\"\"\"\ndef uwsgi_pypy_workers():\n    workers = []\n    for i in range(1, lib.uwsgi.numproc+1):\n        worker = {}\n        worker['id'] = lib.uwsgi.workers[i].id\n        worker['pid'] = lib.uwsgi.workers[i].pid\n        worker['requests'] = lib.uwsgi.workers[i].requests\n        worker['delta_requests'] = lib.uwsgi.workers[i].delta_requests\n        worker['signals'] = lib.uwsgi.workers[i].signals\n        worker['exceptions'] = lib.uwsgi_worker_exceptions(i);\n        worker['apps'] = []\n        if lib.uwsgi.workers[i].cheaped:\n            worker['status'] == 'cheap'\n        elif lib.uwsgi.workers[i].suspended and not lib.uwsgi_worker_is_busy(i):\n            worker['status'] == 'pause'\n        else:\n            if lib.uwsgi.workers[i].sig:\n                worker['status'] = 'sig%d' % lib.uwsgi.workers[i].signum\n            elif lib.uwsgi_worker_is_busy(i):\n                worker['status'] = 'busy' \n            else:\n                worker['status'] = 'idle'\n        worker['running_time'] = lib.uwsgi.workers[i].running_time\n        worker['avg_rt'] = lib.uwsgi.workers[i].avg_response_time\n        worker['tx'] = lib.uwsgi.workers[i].tx\n            \n        workers.append(worker)\n    return workers\n    \nuwsgi.workers = uwsgi_pypy_workers\n\n\"\"\"\nuwsgi.async_sleep(timeout)\n\"\"\"\ndef uwsgi_pypy_async_sleep(timeout):\n    if timeout > 0:\n        wsgi_req = uwsgi_pypy_current_wsgi_req();\n        lib.async_add_timeout(wsgi_req, timeout);\nuwsgi.async_sleep = uwsgi_pypy_async_sleep\n\n\"\"\"\nuwsgi.async_connect(addr)\n\"\"\"\ndef uwsgi_pypy_async_connect(addr):\n    fd = lib.uwsgi_connect(ffi.new('char[]', addr), 0, 1)\n    if fd < 0:\n        raise Exception(\"unable to connect to %s\" % addr)\n    return fd\nuwsgi.async_connect = uwsgi_pypy_async_connect\n\nuwsgi.connection_fd = lambda: uwsgi_pypy_current_wsgi_req().fd\n\n\"\"\"\nuwsgi.wait_fd_read(fd, timeout=0)\n\"\"\"\ndef uwsgi_pypy_wait_fd_read(fd, timeout=0):\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    if lib.async_add_fd_read(wsgi_req, fd, timeout) < 0:\n        raise Exception(\"unable to add fd %d to the event queue\" % fd)\nuwsgi.wait_fd_read = uwsgi_pypy_wait_fd_read\n\n\"\"\"\nuwsgi.wait_fd_write(fd, timeout=0)\n\"\"\"\ndef uwsgi_pypy_wait_fd_write(fd, timeout=0):\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    if lib.async_add_fd_write(wsgi_req, fd, timeout) < 0:\n        raise Exception(\"unable to add fd %d to the event queue\" % fd)\nuwsgi.wait_fd_write = uwsgi_pypy_wait_fd_write\n\n\"\"\"\nuwsgi.ready_fd()\n\"\"\"\ndef uwsgi_pypy_ready_fd():\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    return lib.uwsgi_ready_fd(wsgi_req)\nuwsgi.ready_fd = uwsgi_pypy_ready_fd\n    \n\n\"\"\"\nuwsgi.send(fd=None,data)\n\"\"\"\ndef uwsgi_pypy_send(*args):\n    if len(args) == 0:\n        raise ValueError(\"uwsgi.send() takes at least 1 argument\")\n    elif len(args) == 1:\n        wsgi_req = uwsgi_pypy_current_wsgi_req();\n        fd = wsgi_req.fd\n        data = args[0]\n    else:\n        fd = args[0]\n        data = args[1]\n    rlen = libc.write(fd, data, len(data))\n    if rlen <= 0:\n        raise IOError(\"unable to send data\")\n    return rlen\nuwsgi.send = uwsgi_pypy_send\n\n\"\"\"\nuwsgi.recv(fd=None,len)\n\"\"\"\ndef uwsgi_pypy_recv(*args):\n    if len(args) == 0:\n        raise ValueError(\"uwsgi.recv() takes at least 1 argument\")\n    elif len(args) == 1:\n        wsgi_req = uwsgi_pypy_current_wsgi_req();\n        fd = wsgi_req.fd\n        l = args[0]\n    else:\n        fd = args[0]\n        l = args[1]\n    data = ffi.new('char[%d]' % l)\n    rlen = libc.read(fd, data, l)\n    if rlen <= 0:\n        raise IOError(\"unable to receive data\")\n    return ffi.string(data[0:rlen])\nuwsgi.recv = uwsgi_pypy_recv\n    \n\"\"\"\nuwsgi.close(fd)\n\"\"\"\nuwsgi.close = lambda fd: lib.close(fd)\n\n\"\"\"\nuwsgi.disconnect()\n\"\"\"\nuwsgi.disconnect = lambda: lib.uwsgi_disconnect(uwsgi_pypy_current_wsgi_req())\n\n\"\"\"\nuwsgi.websocket_recv()\n\"\"\"\ndef uwsgi_pypy_websocket_recv():\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    ub = lib.uwsgi_websocket_recv(wsgi_req);\n    if ub == ffi.NULL:\n        raise IOError(\"unable to receive websocket message\")\n    ret = ffi.buffer(ub.buf, ub.pos)[:]\n    lib.uwsgi_buffer_destroy(ub)\n    return ret\nuwsgi.websocket_recv = uwsgi_pypy_websocket_recv\n\n\"\"\"\nuwsgi.websocket_recv_nb()\n\"\"\"\ndef uwsgi_pypy_websocket_recv_nb():\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    ub = lib.uwsgi_websocket_recv_nb(wsgi_req);\n    if ub == ffi.NULL:\n        raise IOError(\"unable to receive websocket message\")\n    ret = ffi.buffer(ub.buf, ub.pos)[:]\n    lib.uwsgi_buffer_destroy(ub)\n    return ret\nuwsgi.websocket_recv_nb = uwsgi_pypy_websocket_recv_nb\n\n\"\"\"\nuwsgi.websocket_handshake(key, origin)\n\"\"\"\ndef uwsgi_pypy_websocket_handshake(key='', origin='', proto=''):\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    c_key = ffi.new('char[]', key)\n    c_origin = ffi.new('char[]', origin)\n    c_proto = ffi.new('char[]', proto)\n    if lib.uwsgi_websocket_handshake(wsgi_req, c_key, len(key), c_origin, len(origin), c_proto, len(proto)) < 0:\n        raise IOError(\"unable to complete websocket handshake\")\nuwsgi.websocket_handshake = uwsgi_pypy_websocket_handshake\n\n\"\"\"\nuwsgi.websocket_send(msg)\n\"\"\"\ndef uwsgi_pypy_websocket_send(msg):\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    if lib.uwsgi_websocket_send(wsgi_req, ffi.new('char[]', msg), len(msg)) < 0:\n        raise IOError(\"unable to send websocket message\")\nuwsgi.websocket_send = uwsgi_pypy_websocket_send\n\n\"\"\"\nuwsgi.chunked_read(timeout=0)\n\"\"\"\ndef uwsgi_pypy_chunked_read(timeout=0):\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    rlen = ffi.new(\"size_t*\")\n    chunk = lib.uwsgi_chunked_read(wsgi_req, rlen, timeout, 0)\n    if chunk == ffi.NULL:\n        raise IOError(\"unable to receive chunked part\")\n    return ffi.buffer(chunk, rlen[0])[:]\nuwsgi.chunked_read = uwsgi_pypy_chunked_read\n\n\"\"\"\nuwsgi.chunked_read_nb()\n\"\"\"\ndef uwsgi_pypy_chunked_read_nb():\n    wsgi_req = uwsgi_pypy_current_wsgi_req();\n    rlen = ffi.new(\"size_t*\")\n    chunk = lib.uwsgi_chunked_read(wsgi_req, rlen, 0, 1)\n    if chunk == ffi.NULL:\n        if lib.uwsgi_is_again() > 0:\n            return None\n        raise IOError(\"unable to receive chunked part\")\n    return ffi.buffer(chunk, rlen[0])[:]\nuwsgi.chunked_read_nb = uwsgi_pypy_chunked_read_nb\n\n\"\"\"\nuwsgi.set_user_harakiri(sec)\n\"\"\"\nuwsgi.set_user_harakiri = lambda x: lib.set_user_harakiri(x)\n\n\nprint \"Initialized PyPy with Python\", sys.version\nprint \"PyPy Home:\", sys.prefix\n\n\n\"\"\"\nContinulets support\n\"\"\"\n\n# this is the dictionary of continulets (one per-core)\nuwsgi_pypy_continulets = {}\n\n\ndef uwsgi_pypy_continulet_wrapper(cont):\n    lib.async_schedule_to_req_green()\n\n@ffi.callback(\"void()\")\ndef uwsgi_pypy_continulet_schedule():\n    id = lib.uwsgi.wsgi_req.async_id\n    modifier1 = lib.uwsgi.wsgi_req.uh.modifier1;\n\n    # generate a new continulet\n    if not lib.uwsgi.wsgi_req.suspended:\n        from _continuation import continulet\n        uwsgi_pypy_continulets[id] = continulet(uwsgi_pypy_continulet_wrapper)\n        lib.uwsgi.wsgi_req.suspended = 1\n\n    # this is called in the main stack\n    if lib.uwsgi.p[modifier1].suspend:\n        lib.uwsgi.p[modifier1].suspend(ffi.NULL)    \n\n    # let's switch\n    uwsgi_pypy_continulets[id].switch()\n\n    # back to the main stack\n    if lib.uwsgi.p[modifier1].resume:\n        lib.uwsgi.p[modifier1].resume(ffi.NULL) \n\n@ffi.callback(\"void(struct wsgi_request *)\")\ndef uwsgi_pypy_continulet_switch(wsgi_req):\n    id = wsgi_req.async_id\n    modifier1 = wsgi_req.uh.modifier1;\n\n    # this is called in the current continulet\n    if lib.uwsgi.p[modifier1].suspend:\n        lib.uwsgi.p[modifier1].suspend(wsgi_req)    \n\n    uwsgi_pypy_continulets[id].switch()\n\n    # back to the continulet\n    if lib.uwsgi.p[modifier1].resume:\n        lib.uwsgi.p[modifier1].resume(wsgi_req) \n\n    # update current running continulet\n    lib.uwsgi.wsgi_req = wsgi_req\n    \ndef uwsgi_pypy_setup_continulets():\n    if lib.uwsgi.async <= 1:\n        raise Exception(\"pypy continulets require async mode !!!\")\n    lib.uwsgi.schedule_to_main = uwsgi_pypy_continulet_switch\n    lib.uwsgi.schedule_to_req = uwsgi_pypy_continulet_schedule\n    print \"*** PyPy Continulets engine loaded ***\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/plugins/pypy/pypy_plugin.c": "/*******************************************************************\n\n This is the C part of the PyPy plugin (with the main logic being in\n Python, see pypy_setup.py).\n\n Idea and initial implementation by Maciej Fijalkowski\n\n *******************************************************************/\n\n#include <uwsgi.h>\n\nstruct uwsgi_pypy {\n\tvoid *handler;\n\tchar *lib;\n\tchar *setup;\n\tchar *home;\n\tchar *wsgi;\n\tchar *wsgi_file;\n\tchar *paste;\n\tstruct uwsgi_string_list *eval;\n\tstruct uwsgi_string_list *eval_post_fork;\n\tstruct uwsgi_string_list *exec;\n\tstruct uwsgi_string_list *exec_post_fork;\n\n\tstruct uwsgi_string_list *pp;\n\n\tpthread_mutex_t attach_thread_lock;\n} upypy;\n\n// the functions exposed by libpypy-c\nchar *(*u_rpython_startup_code)(void);\nint (*u_pypy_setup_home)(char *, int);\nint (*u_pypy_execute_source)(char *);\nvoid (*u_pypy_thread_attach)(void);\nvoid (*u_pypy_init_threads)(void);\n\n// the hooks you can override with pypy\nvoid (*uwsgi_pypy_hook_execute_source)(char *);\nvoid (*uwsgi_pypy_hook_loader)(char *);\nvoid (*uwsgi_pypy_hook_file_loader)(char *);\nvoid (*uwsgi_pypy_hook_paste_loader)(char *);\nvoid (*uwsgi_pypy_hook_pythonpath)(char *);\nvoid (*uwsgi_pypy_hook_request)(void *, int);\nvoid (*uwsgi_pypy_post_fork_hook)(void);\n\nextern struct uwsgi_server uwsgi;\nstruct uwsgi_plugin pypy_plugin;\n\nstatic int uwsgi_pypy_init() {\n\n\tsize_t rlen = 0;\n\tchar *buffer = NULL;\n\n\tvoid *is_cpython_loaded = dlsym(RTLD_DEFAULT, \"Py_Initialize\");\n\tif (is_cpython_loaded) {\n\t\tuwsgi_log(\"!!! Loading both PyPy and CPython in the same process IS PURE EVIL AND IT IS NOT SUPPORTED !!!\\n\");\n\t\texit(1);\n\t}\n\n\tif (dlsym(RTLD_DEFAULT, \"rpython_startup_code\")) {\n\t\tuwsgi_log(\"PyPy runtime detected, skipping libpypy-c loading\\n\");\n\t\tgoto ready;\n\t}\n\telse if (upypy.lib) {\n\t\tupypy.handler = dlopen(upypy.lib, RTLD_NOW | RTLD_GLOBAL);\n\t}\n\telse {\n\t\tif (upypy.home) {\n\t\t\t// first try with /bin way:\n#ifdef __CYGWIN__\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.dll\");\n#elif defined(__APPLE__)\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.dylib\");\n#else\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.so\");\n#endif\n\t\t\tif (uwsgi_file_exists(libpath)) {\n                                upypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);\n                        }\n                        free(libpath);\n\n\t\t\t// fallback to old-style way\n\t\t\tif (!upypy.handler) {\n\t\t\t\n#ifdef __CYGWIN__\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.dll\");\n#elif defined(__APPLE__)\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.dylib\");\n#else\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.so\");\n#endif\n\t\t\t\tif (uwsgi_file_exists(libpath)) {\n\t\t\t\t\tupypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);\n\t\t\t\t}\n\t\t\t\tfree(libpath);\n\t\t\t}\n\t\t}\n\t\t// fallback to standard library search path\n\t\tif (!upypy.handler) {\n#ifdef __CYGWIN__\n\t\t\tupypy.handler = dlopen(\"libpypy-c.dll\", RTLD_NOW | RTLD_GLOBAL);\n#elif defined(__APPLE__)\n\t\t\tupypy.handler = dlopen(\"libpypy-c.dylib\", RTLD_NOW | RTLD_GLOBAL);\n#else\n\t\t\tupypy.handler = dlopen(\"libpypy-c.so\", RTLD_NOW | RTLD_GLOBAL);\n#endif\n\t\t}\n\t}\n\n\tif (!upypy.handler) {\n\t\tuwsgi_log(\"unable to load pypy library: %s\\n\", dlerror());\n\t\texit(1);\n\t}\n\n\tu_rpython_startup_code = dlsym(upypy.handler, \"rpython_startup_code\");\n\tif (!u_rpython_startup_code) {\n\t\tuwsgi_log(\"unable to find rpython_startup_code() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_setup_home = dlsym(upypy.handler, \"pypy_setup_home\");\n\tif (!u_pypy_setup_home) {\n\t\tuwsgi_log(\"unable to find pypy_setup_home() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_init_threads = dlsym(upypy.handler, \"pypy_init_threads\");\n        if (!u_pypy_init_threads) {\n                uwsgi_log(\"!!! WARNING your libpypy-c does not export pypy_init_threads, multithreading will not work !!!\\n\");\n        }\n\t\n\tu_rpython_startup_code();\n\n\tif (!upypy.home) {\n\t\tupypy.home = getenv(\"PYPY_HOME\");\n\t\tif (!upypy.home) {\n\t\t\tuwsgi_log(\"you have to specify a pypy home with --pypy-home\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (u_pypy_setup_home(upypy.home, 0)) {\n\t\tchar *retry = uwsgi_concat2(upypy.home, \"/lib_pypy\");\n\t\tif (uwsgi_is_dir(retry)) {\n\t\t\t// this time we use debug\n\t\t\tif (!u_pypy_setup_home(retry, 1)) {\n\t\t\t\tfree(retry);\n\t\t\t\tgoto ready;\n\t\t\t}\n\t\t}\n                uwsgi_log(\"unable to set pypy home to \\\"%s\\\"\\n\", upypy.home);\n\t\texit(1);\n        }\n\nready:\n\tu_pypy_execute_source = dlsym(upypy.handler, \"pypy_execute_source\");\n\tif (!u_pypy_execute_source) {\n\t\tuwsgi_log(\"unable to find pypy_execute_source() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_thread_attach = dlsym(upypy.handler, \"pypy_thread_attach\");\n        if (!u_pypy_thread_attach) {\n                uwsgi_log(\"!!! WARNING your libpypy-c does not export pypy_thread_attach, multithreading will not work !!!\\n\");\n        }\n\n\tif (upypy.setup) {\n\t\tbuffer = uwsgi_open_and_read(upypy.setup, &rlen, 1, NULL);\n\t}\n\telse {\n\t\tchar *start = dlsym(RTLD_DEFAULT, \"uwsgi_pypy_setup_start\");\n\t\tif (!start) {\n\t\t\tstart = dlsym(RTLD_DEFAULT, \"_uwsgi_pypy_setup_start\");\n\t\t}\n\t\tchar *end = dlsym(RTLD_DEFAULT, \"uwsgi_pypy_setup_end\");\n\t\tif (!end) {\n\t\t\tend = dlsym(RTLD_DEFAULT, \"_uwsgi_pypy_setup_end\");\n\t\t}\n\t\tif (start && end) {\n\t\t\tbuffer = uwsgi_concat2n(start, end-start, \"\", 0);\n\t\t}\n\t}\n\n\tif (!buffer) {\n\t\tuwsgi_log(\"you have to load a pypy setup file with --pypy-setup\\n\");\n\t\texit(1);\n\t}\n\tif (u_pypy_execute_source(buffer)) {\n\t\texit(1);\n\t}\n\tfree(buffer);\n\n\t// add items to the pythonpath\n\tstruct uwsgi_string_list *usl = upypy.pp;\n\twhile(usl) {\n\t\tif (uwsgi_pypy_hook_pythonpath) {\n\t\t\tuwsgi_pypy_hook_pythonpath(usl->value);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void uwsgi_pypy_preinit_apps() {\n\n\tif (!uwsgi_pypy_hook_execute_source) {\n\t\tuwsgi_log(\"*** WARNING your pypy setup code does not expose a callback for \\\"execute_source\\\" ***\\n\");\n\t\treturn;\n\t}\n\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, upypy.eval) {\n\t\tuwsgi_pypy_hook_execute_source(usl->value);\n\t}\n\n\tuwsgi_foreach(usl, upypy.exec) {\n\t\tsize_t rlen = 0;\n\t\tchar *buffer = uwsgi_open_and_read(usl->value, &rlen, 1, NULL);\n\t\tuwsgi_pypy_hook_execute_source(buffer);\n\t\tfree(buffer);\n\t}\n}\n\nstatic int uwsgi_pypy_request(struct wsgi_request *wsgi_req) {\n\t/* Standard WSGI request */\n        if (!wsgi_req->uh->pktsize) {\n                uwsgi_log( \"Empty pypy request. skip.\\n\");\n                return -1;\n        }\n\n        if (uwsgi_parse_vars(wsgi_req)) {\n                return -1;\n        }\n\n\tif (uwsgi_pypy_hook_request) {\n\t\tuwsgi_pypy_hook_request(wsgi_req, wsgi_req->async_id);\n\t}\n\treturn UWSGI_OK;\n}\n\nstatic void uwsgi_pypy_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nstatic void uwsgi_pypy_init_apps() {\n\tif (uwsgi_pypy_hook_loader && upypy.wsgi) {\n\t\tuwsgi_pypy_hook_loader(upypy.wsgi);\n\t}\n\n\tif (uwsgi_pypy_hook_file_loader && upypy.wsgi_file) {\n\t\tuwsgi_pypy_hook_file_loader(upypy.wsgi_file);\n\t}\n\n\tif (uwsgi_pypy_hook_paste_loader && upypy.paste) {\n\t\tuwsgi_pypy_hook_paste_loader(upypy.paste);\n\t}\n}\n\n/*\nstatic void uwsgi_pypy_atexit() {\n\tif (pypy_debug_file)\n\t\tfflush(pypy_debug_file);\n}\n*/\n\nstatic void uwsgi_opt_pypy_ini_paste(char *opt, char *value, void *foobar) {\n        uwsgi_opt_load_ini(opt, value, NULL);\n        upypy.paste = value;\n}\n\n\nstatic struct uwsgi_option uwsgi_pypy_options[] = {\n\t{\"pypy-lib\", required_argument, 0, \"set the path/name of the pypy library\", uwsgi_opt_set_str, &upypy.lib, 0},\n\t{\"pypy-setup\", required_argument, 0, \"set the path of the python setup script\", uwsgi_opt_set_str, &upypy.setup, 0},\n\t{\"pypy-home\", required_argument, 0, \"set the home of pypy library\", uwsgi_opt_set_str, &upypy.home, 0},\n\t{\"pypy-wsgi\", required_argument, 0, \"load a WSGI module\", uwsgi_opt_set_str, &upypy.wsgi, 0},\n\t{\"pypy-wsgi-file\", required_argument, 0, \"load a WSGI/mod_wsgi file\", uwsgi_opt_set_str, &upypy.wsgi_file, 0},\n\t{\"pypy-ini-paste\", required_argument, 0, \"load a paste.deploy config file containing uwsgi section\", uwsgi_opt_pypy_ini_paste, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"pypy-paste\", required_argument, 0, \"load a paste.deploy config file\", uwsgi_opt_set_str, &upypy.paste, 0},\n\t{\"pypy-eval\", required_argument, 0, \"evaluate pypy code before fork()\", uwsgi_opt_add_string_list, &upypy.eval, 0},\n\t{\"pypy-eval-post-fork\", required_argument, 0, \"evaluate pypy code soon after fork()\", uwsgi_opt_add_string_list, &upypy.eval_post_fork, 0},\n\t{\"pypy-exec\", required_argument, 0, \"execute pypy code from file before fork()\", uwsgi_opt_add_string_list, &upypy.exec, 0},\n\t{\"pypy-exec-post-fork\", required_argument, 0, \"execute pypy code from file soon after fork()\", uwsgi_opt_add_string_list, &upypy.exec_post_fork, 0},\n\t{\"pypy-pp\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{\"pypy-python-path\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{\"pypy-pythonpath\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{0, 0, 0, 0, 0, 0, 0},\n};\n\nstatic void uwsgi_pypy_enable_threads() {\n\tif (u_pypy_init_threads) {\n\t\tu_pypy_init_threads();\n\t}\n}\n\nstatic void uwsgi_pypy_init_thread() {\n\tif (u_pypy_thread_attach) {\n\t\tpthread_mutex_lock(&upypy.attach_thread_lock);\n\t\tu_pypy_thread_attach();\n\t\tpthread_mutex_unlock(&upypy.attach_thread_lock);\n\t}\n}\n\nstatic int uwsgi_pypy_signal_handler(uint8_t sig, void *handler) {\n\tvoid (*pypy_func)(int) = (void(*)(int)) handler;\n\tpypy_func(sig);\n\treturn 0;\n}\n\nstatic uint64_t uwsgi_pypy_rpc(void *func, uint8_t argc, char **argv, uint16_t argvs[], char **buffer) {\n\tint iargvs[UMAX8];\n\tint i;\n\tint (*pypy_func)(int, char **, int*, char **) = (int (*)(int, char **, int*, char **)) func;\n\t// we convert 16bit to int\n\tfor(i=0;i<argc;i++) {\n\t\tiargvs[i] = (int) argvs[i]; \n\t}\n\treturn pypy_func(argc, argv, iargvs, buffer);\n}\n\nstatic void uwsgi_pypy_post_fork() {\n\tpthread_mutex_init(&upypy.attach_thread_lock, NULL);\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, upypy.eval_post_fork) {\n                uwsgi_pypy_hook_execute_source(usl->value);\n        }\n\tuwsgi_foreach(usl, upypy.exec_post_fork) {\n                size_t rlen = 0;\n                char *buffer = uwsgi_open_and_read(usl->value, &rlen, 1, NULL);\n                uwsgi_pypy_hook_execute_source(buffer);\n                free(buffer);\n        }\n\n\tif (uwsgi_pypy_post_fork_hook) {\n\t\tuwsgi_pypy_post_fork_hook();\n\t}\n}\n\nstatic void uwsgi_pypy_onload() {\n#ifdef UWSGI_PYPY_HOME\n\tupypy.home = UWSGI_PYPY_HOME;\n#endif\n\tuwsgi.has_threads = 1;\n}\n\nstatic int uwsgi_pypy_mule(char *opt) {\n\n\tif (!uwsgi_pypy_hook_execute_source) {\n\t\tuwsgi_log(\"!!! no \\\"execute_source\\\" callback in your pypy setup code !!!\\n\");\n\t\texit(1);\n\t}\n\n        if (uwsgi_endswith(opt, \".py\")) {\n                size_t rlen = 0;\n                char *buffer = uwsgi_open_and_read(opt, &rlen, 1, NULL);\n                uwsgi_pypy_hook_execute_source(buffer);\n\t\tfree(buffer);\n                return 1;\n        }\n        return 0;\n\n}\n\n\nstruct uwsgi_plugin pypy_plugin = {\n\t.name = \"pypy\",\n\t.modifier1 = 0,\n\t.on_load = uwsgi_pypy_onload,\n\t.init = uwsgi_pypy_init,\n\t.request = uwsgi_pypy_request,\n\t.after_request = uwsgi_pypy_after_request,\n\t.options = uwsgi_pypy_options,\n\t.preinit_apps = uwsgi_pypy_preinit_apps,\n\t.init_apps = uwsgi_pypy_init_apps,\n\t.init_thread = uwsgi_pypy_init_thread,\n\t.signal_handler = uwsgi_pypy_signal_handler,\n\t.enable_threads = uwsgi_pypy_enable_threads,\n\t.rpc = uwsgi_pypy_rpc,\n\t.post_fork = uwsgi_pypy_post_fork,\n\t.mule = uwsgi_pypy_mule,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/plugins/cgi/cgi_plugin.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\n#define kill_on_error if (!uc.do_not_kill_on_error) { if (kill(cgi_pid, SIGKILL)) uwsgi_error(\"kill()\");}\n\nstruct uwsgi_cgi {\n\tstruct uwsgi_dyn_dict *mountpoint;\n\tstruct uwsgi_dyn_dict *helpers;\n\tsize_t buffer_size;\n\tint timeout;\n\tstruct uwsgi_string_list *index;\n\tstruct uwsgi_string_list *allowed_ext;\n\tstruct uwsgi_string_list *unset;\n\tstruct uwsgi_string_list *loadlib;\n\tstruct uwsgi_string_list *cgi_safe;\n\tint optimize;\n\tint from_docroot;\n\tint has_mountpoints;\n\tstruct uwsgi_dyn_dict *default_cgi;\n\tint path_info;\n\tint do_not_kill_on_error;\n\tint async_max_attempts;\n\tint close_stdin_on_eof;\n} uc ;\n\nstatic void uwsgi_opt_add_cgi(char *opt, char *value, void *foobar) {\n\n\tchar *val = strchr(value, '=');\n        if (!val) {\n        \tuwsgi_dyn_dict_new(&uc.mountpoint, value, strlen(value), NULL, 0);\n        }\n        else {\n        \tuwsgi_dyn_dict_new(&uc.mountpoint, value, val-value, val+1, strlen(val+1));\n        }\n\n}\n\nstatic void uwsgi_opt_add_cgi_maphelper(char *opt, char *value, void *foobar) {\n\tchar *val = strchr(value, '=');\n        if (!val) {\n        \tuwsgi_log(\"invalid CGI helper syntax, must be ext=command\\n\");\n                exit(1);\n        }\n        uwsgi_dyn_dict_new(&uc.helpers, value, val-value, val+1, strlen(val+1));\n}\n\nstruct uwsgi_option uwsgi_cgi_options[] = {\n\n        {\"cgi\", required_argument, 0, \"add a cgi mountpoint/directory/script\", uwsgi_opt_add_cgi, NULL, 0},\n\n        {\"cgi-map-helper\", required_argument, 0, \"add a cgi map-helper\", uwsgi_opt_add_cgi_maphelper, NULL, 0},\n        {\"cgi-helper\", required_argument, 0, \"add a cgi map-helper\", uwsgi_opt_add_cgi_maphelper, NULL, 0},\n\n        {\"cgi-from-docroot\", no_argument, 0, \"blindly enable cgi in DOCUMENT_ROOT\", uwsgi_opt_true, &uc.from_docroot, 0},\n\n        {\"cgi-buffer-size\", required_argument, 0, \"set cgi buffer size\", uwsgi_opt_set_64bit, &uc.buffer_size, 0},\n        {\"cgi-timeout\", required_argument, 0, \"set cgi script timeout\", uwsgi_opt_set_int, &uc.timeout, 0},\n\n        {\"cgi-index\", required_argument, 0, \"add a cgi index file\", uwsgi_opt_add_string_list, &uc.index, 0},\n        {\"cgi-allowed-ext\", required_argument, 0, \"cgi allowed extension\", uwsgi_opt_add_string_list, &uc.allowed_ext, 0},\n\n        {\"cgi-unset\", required_argument, 0, \"unset specified environment variables\", uwsgi_opt_add_string_list, &uc.unset, 0},\n\n        {\"cgi-loadlib\", required_argument, 0, \"load a cgi shared library/optimizer\", uwsgi_opt_add_string_list, &uc.loadlib, 0},\n        {\"cgi-optimize\", no_argument, 0, \"enable cgi realpath() optimizer\", uwsgi_opt_true, &uc.optimize, 0},\n        {\"cgi-optimized\", no_argument, 0, \"enable cgi realpath() optimizer\", uwsgi_opt_true, &uc.optimize, 0},\n\n        {\"cgi-path-info\", no_argument, 0, \"disable PATH_INFO management in cgi scripts\", uwsgi_opt_true, &uc.path_info, 0},\n\n        {\"cgi-do-not-kill-on-error\", no_argument, 0, \"do not send SIGKILL to cgi script on errors\", uwsgi_opt_true, &uc.do_not_kill_on_error, 0},\n        {\"cgi-async-max-attempts\", no_argument, 0, \"max waitpid() attempts in cgi async mode (default 10)\", uwsgi_opt_set_int, &uc.async_max_attempts, 0},\n\n        {\"cgi-close-stdin-on-eof\", no_argument, 0, \"close STDIN on input EOF\", uwsgi_opt_true, &uc.close_stdin_on_eof, 0},\n\n        {\"cgi-safe\", required_argument, 0, \"skip security checks if the cgi file is under the specified path\", uwsgi_opt_add_string_list, &uc.cgi_safe, 0},\n\n        {0, 0, 0, 0, 0, 0, 0},\n\n};\n\nstatic void uwsgi_cgi_apps() {\n\n\tstruct uwsgi_dyn_dict *udd = uc.mountpoint;\n\tstruct stat st;\n\n\twhile(udd) {\n\t\tif (udd->vallen) {\n\t\t\tif (uc.optimize) {\n\t\t\t\tudd->value = realpath(udd->value, NULL);\t\n\t\t\t\tif (!udd->value) {\n\t\t\t\t\tuwsgi_log(\"unable to find CGI path %.*s\\n\", udd->vallen, udd->value);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tudd->vallen = strlen(udd->value);\n\t\t\t\tudd->status = 1;\n\t\t\t\tif (stat(udd->value, &st)) {\n\t\t\t\t\tuwsgi_error(\"stat()\");\n\t\t\t\t\tuwsgi_log(\"something horrible happened during CGI initialization\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\t\tudd->status = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tuc.has_mountpoints = 1;\n\t\t\tuwsgi_log(\"initialized CGI mountpoint: %.*s = %.*s\\n\", udd->keylen, udd->key, udd->vallen, udd->value);\n\t\t}\n\t\telse {\n\t\t\tif (uc.optimize) {\n\t\t\t\tudd->key = realpath(udd->key, NULL);\n\t\t\t\tif (!udd->key) {\n                                        uwsgi_log(\"unable to find CGI path %.*s\\n\", udd->keylen, udd->key);\n                                        exit(1);\n                                }\n                                udd->keylen = strlen(udd->key);\n\t\t\t\tudd->status = 1;\n\n\t\t\t\tif (stat(udd->key, &st)) {\n                                        uwsgi_error(\"stat()\");  \n                                        uwsgi_log(\"something horrible happened during CGI initialization\\n\");\n                                        exit(1);\n                                }\n\n                                if (!S_ISDIR(st.st_mode)) {\n                                        udd->status = 2;\n                                }\n\n\t\t\t}\n\t\t\tuwsgi_log(\"initialized CGI path: %.*s\\n\", udd->keylen, udd->key);\n\t\t\tuc.default_cgi = udd;\n\t\t}\n\t\tudd = udd->next;\n\t}\n\n}\n\nstatic int uwsgi_cgi_init(){\n\n\tvoid (*cgi_sym)(void);\n\n\tif (!uc.buffer_size) uc.buffer_size = 65536;\n\tif (!uc.timeout) uc.timeout = 60;\n\n\tstruct uwsgi_string_list *ll = uc.loadlib;\n\twhile(ll) {\n\t\tchar *colon = strchr(ll->value, ':');\n\t\tif (!colon) {\n\t\t\tuwsgi_log(\"invalid cgi-loadlib syntax, must be in the form lib:func\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*colon = 0;\n\t\tvoid *cgi_lib = dlopen(ll->value, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!cgi_lib) {\n\t\t\tuwsgi_log( \"cgi-loadlib: %s\\n\", dlerror());\n\t\t\texit(1);\n\t\t}\n\n\t\tcgi_sym = dlsym(cgi_lib, colon+1);\n\t\tif (!cgi_sym) {\n\t\t\tuwsgi_log(\"unknown symbol %s in lib %s\\n\", colon+1, ll->value);\n\t\t\texit(1);\n\t\t}\n\n\t\tcgi_sym();\n\t\tuwsgi_log(\"[cgi-loadlib] loaded symbol %s from %s\\n\", colon+1, ll->value);\n\n\t\t*colon = ':';\n\t\tll = ll->next;\n\t}\n\n\treturn 0;\t\n\n}\n\nstatic char *uwsgi_cgi_get_helper(char *filename) {\n\n\tstruct uwsgi_dyn_dict *helpers = uc.helpers;\n\tsize_t len = strlen(filename);\n\n\twhile(helpers) {\n\t\tif (len >= (size_t) helpers->keylen) {\n\t\t\tif (!uwsgi_strncmp((filename+len)-helpers->keylen, helpers->keylen, helpers->key, helpers->keylen)) {\n\t\t\t\treturn helpers->value;\n\t\t\t}\n\t\t}\n\t\thelpers = helpers->next;\n\t}\n\n\treturn NULL;\n\t\n}\n\n/*\nstart reading each line until Status or Location are found\n-1 error\n0 not found\n1 found\n*/\nstatic int uwsgi_cgi_check_status(struct wsgi_request *wsgi_req, char *buf, size_t len) {\n\tchar *key = buf, *value = NULL;\n\tsize_t header_size = 0;\n\tsize_t i;\n\n\tfor(i=0;i<len;i++) {\n       \t\t// end of a line\n                if (buf[i] == '\\n') {\n                \t// end of headers\n                        if (key == NULL) {\n                        \t// Default status\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"setting default Status header\\n\");\n#endif\n\t\t\t\tif (uwsgi_response_prepare_headers(wsgi_req, \"200 OK\", 6)) return -1;\n\t\t\t\treturn 1;\n\t\t\t}\n                        // invalid header\n                        else if (value == NULL) return -1;\n                        header_size = (buf+i) - key;\n                        // security check\n                        if (buf+i > buf) {\n\t\t\t\t// remove \\r\n                        \tif ((buf[i-1]) == '\\r') {\n                                \theader_size--;\n                                }\n                        }\n\n\t\t\t// enough space for Status ?\n                        if (header_size >= 11) {\n                        \t// \"Status: NNN\"\n                                if (!strncasecmp(\"Status: \", key, 8)) {\n#ifdef UWSGI_DEBUG\n                                \tuwsgi_log(\"found Status header: %.*s\\n\", header_size, key);\n#endif\n                                        if (uwsgi_response_prepare_headers(wsgi_req, key+8, header_size - 8)) return -1;\n\t\t\t\t\treturn 1;\n                                }\n                                // Location: X\n                                if (!strncasecmp(\"Location: \", key, 10)) {\n#ifdef UWSGI_DEBUG\n                                \tuwsgi_log(\"found Location header: %.*s\\n\", header_size, key);\n#endif\n                                        if (uwsgi_response_prepare_headers(wsgi_req, \"302 Found\", 9)) return -1;\n\t\t\t\t\treturn 1;\n                                }\n\t\t\t}\n\n                        key = NULL;\n                        value = NULL;\n\t\t}\n                else if (buf[i] == ':') {\n\t\t\tvalue = buf+i;\n                }\n                else if (buf[i] != '\\r') {\n                \tif (key == NULL) key = buf + i;\n                }\n\n\t}\n\n\t// no Status/Location found\n\treturn 0;\n\n}\n\nstatic int uwsgi_cgi_parse(struct wsgi_request *wsgi_req, int fd, char *buf, size_t blen) {\n\n\tsize_t i;\n\tsize_t header_size = 0;\n\tint status_sent = 0;\n\tsize_t remains = blen;\n\tchar *ptr = buf;\n\tsize_t len = 0;\n\n\twhile(remains > 0) {\n\t\tssize_t rlen = uwsgi_read_true_nb(fd, ptr, remains, uc.timeout);\n\t\tif (rlen < 0) {\n\t\t\tif (!errno) return 1;\n\t\t\treturn -1;\n\t\t}\n\t\t// timed out\n\t\tif (rlen == 0) return -1;\n\t\tremains -= rlen;\n\t\tlen += rlen;\n\t\tptr += rlen;\n\n\t\t// Search for Status/Location headers\n\t\tif (!status_sent) {\n\t\t\tstatus_sent = uwsgi_cgi_check_status(wsgi_req, buf, len); \n\t\t\tif (status_sent < 0) return -1;\n\t\t\t// need more data ?\n\t\t\tif (status_sent == 0) continue;\n\t\t}\n\n\t\t// send headers\n\t\tchar *key = buf;\n\t\tchar *value = NULL;\n\n\t\tfor(i=0;i<len;i++) {\n\t\t\t// end of a line\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\t// end of headers\n\t\t\t\tif (key == NULL) {\n\t\t\t\t\ti++;\n\t\t\t\t\tgoto send_body;\n\t\t\t\t}\n\t\t\t\t// invalid header\n\t\t\t\telse if (value == NULL) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\theader_size = (buf+i) - key;\n\t\t\t\t// security check\n\t\t\t\tif (buf+i > buf) {\n\t\t\t\t\tif ((buf[i-1]) == '\\r') {\n\t\t\t\t\t\theader_size--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"found CGI header: %.*s\\n\", header_size, key);\n#endif\n\n\t\t\t\t// Ignore \"Status: NNN\" header\n\t\t\t\tif (header_size >= 11) {\n\t\t\t\t\tif (!strncasecmp(\"Status: \", key, 8)) {\n\t\t\t\t\t\tkey = NULL;\n\t\t\t\t\t\tvalue = NULL;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuwsgi_response_add_header(wsgi_req, NULL, 0, key, header_size);\n\t\t\t\tkey = NULL;\n\t\t\t\tvalue = NULL;\n\t\t\t}\n\t\t\telse if (buf[i] == ':') {\n\t\t\t\tvalue = buf+i;\n\t\t\t}\n\t\t\telse if (buf[i] != '\\r') {\n\t\t\t\tif (key == NULL) {\n\t\t\t\t\tkey = buf + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\nsend_body:\n\n\tif (len-i > 0) {\n\t\tuwsgi_response_write_body_do(wsgi_req, buf+i, len-i);\n\t}\n\n\treturn 0;\t\n}\n\nstatic char *uwsgi_cgi_get_docroot(char *path_info, uint16_t path_info_len, int *need_free, int *is_a_file, int *discard_base, char **script_name) {\n\n\tstruct uwsgi_dyn_dict *udd = uc.mountpoint, *choosen_udd = NULL;\n\tint best_found = 0;\n\tstruct stat st;\n\tchar *path = NULL;\n\n\tif (uc.has_mountpoints) {\n\t\twhile(udd) {\n\t\t\tif (udd->vallen) {\n\t\t\t\tif (!uwsgi_starts_with(path_info, path_info_len, udd->key, udd->keylen) && udd->keylen > best_found) {\n\t\t\t\t\tbest_found = udd->keylen ;\n\t\t\t\t\tchoosen_udd = udd;\n\t\t\t\t\tpath = udd->value;\n\t\t\t\t\t*script_name = udd->key;\n\t\t\t\t\t*discard_base = udd->keylen;\n\t\t\t\t\tif (udd->key[udd->keylen-1] == '/') {\n\t\t\t\t\t\t*discard_base = *discard_base-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tudd = udd->next;\n\t\t}\n\t}\n\n\tif (choosen_udd == NULL) {\n\t\tchoosen_udd = uc.default_cgi;\n\t\tif (!choosen_udd) return NULL;\n\t\tpath = choosen_udd->key;\n\t}\n\n\tif (choosen_udd->status == 0) {\n\t\tchar *tmp_udd = uwsgi_malloc(PATH_MAX+1);\n\t\tif (!realpath(path, tmp_udd)) {\n\t\t\tfree(tmp_udd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (stat(tmp_udd, &st)) {\n\t\t\tuwsgi_error(\"stat()\");\n\t\t\tfree(tmp_udd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t*is_a_file = 1;\n\t\t}\n\n\t\t*need_free = 1;\n\t\treturn tmp_udd;\n\t}\n\n\tif (choosen_udd->status == 2)\n\t\t*is_a_file = 1;\n\treturn path;\n}\n\nstatic int uwsgi_cgi_walk(struct wsgi_request *wsgi_req, char *full_path, char *docroot, size_t docroot_len, int discard_base, char **path_info) {\n\n\t// and now start walking...\n        uint16_t i;\n        char *ptr = wsgi_req->path_info+discard_base;\n        char *dst = full_path+docroot_len;\n        char *part = ptr;\n        int part_size = 0;\n\tstruct stat st;\n\n\tif (wsgi_req->path_info_len == 0) return 0;\n\n        if (ptr[0] == '/') part_size++;\n\n        for(i=0;i<wsgi_req->path_info_len-discard_base;i++) {\n        \tif (ptr[i] == '/') {\n                \tmemcpy(dst, part, part_size-1);\n                        *(dst+part_size-1) = 0;\n\n                        if (stat(full_path, &st)) {\n                        \tuwsgi_404(wsgi_req);\n                                return -1;\n                        }\n\n\n\t\t\t// not a directory, stop walking\n                        if (!S_ISDIR(st.st_mode)) {\n\t\t\t\tif (i < (wsgi_req->path_info_len-discard_base)-1) {\n                        \t\t*path_info = ptr + i;\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n                        }\n\n\n\t\t\t// check for buffer overflow !!!\n                        *(dst+part_size-1) = '/';\n                        *(dst+part_size) = 0;\n\n                        dst += part_size ;\n                        part_size = 0;\n                        part = ptr + i + 1;\n         \t}\n\n                part_size++;\n\t}\n\n\tif (part < wsgi_req->path_info+wsgi_req->path_info_len) {\n\t\tmemcpy(dst, part, part_size-1);\n\t\t*(dst+part_size-1) = 0;\n\t}\n\n\treturn 0;\n\n\n}\n\nstatic int uwsgi_cgi_run(struct wsgi_request *, char *, size_t, char *, char *, char *, char *, int, int);\n\nstatic int uwsgi_cgi_request(struct wsgi_request *wsgi_req) {\n\n\tchar full_path[PATH_MAX];\n\tchar tmp_path[PATH_MAX];\n\tstruct stat cgi_stat;\n\tint need_free = 0;\n\tint is_a_file = 0;\n\tint discard_base = 0;\n\tsize_t docroot_len = 0;\n\tsize_t full_path_len = 0;\n\tchar *helper = NULL;\n\tchar *path_info = NULL;\n\tchar *script_name = NULL;\n\n\t/* Standard CGI request */\n\tif (!wsgi_req->uh->pktsize) {\n\t\tuwsgi_log(\"Empty CGI request. skip.\\n\");\n\t\treturn -1;\n\t}\n\n\n\tif (uwsgi_parse_vars(wsgi_req)) {\n\t\treturn -1;\n\t}\n\n\tchar *docroot = NULL;\n\n\t// check for file availability (and 'runnability')\n\tif (uc.from_docroot) {\n\t\tdocroot = wsgi_req->document_root;\t\n\t\tdocroot_len = wsgi_req->document_root_len;\t\n\t}\n\telse {\n\t\tdocroot = uwsgi_cgi_get_docroot(wsgi_req->path_info, wsgi_req->path_info_len, &need_free, &is_a_file, &discard_base, &script_name);\n\t\tif (docroot)\n\t\t\tdocroot_len = strlen(docroot);\n\t}\n\n\tif (docroot == NULL || docroot_len == 0) {\n\t\tuwsgi_404(wsgi_req);\n\t\treturn UWSGI_OK;\n\t}\n\n\tmemcpy(full_path, docroot, docroot_len);\n\n\tif (!is_a_file) {\n\n\t\t*(full_path+docroot_len) = '/';\n\t\t*(full_path+docroot_len+1) = 0;\n\n\t\tif (uwsgi_cgi_walk(wsgi_req, full_path, docroot, docroot_len, discard_base, &path_info)) {\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t\tif (realpath(full_path, tmp_path) == NULL) {\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t\tfull_path_len = strlen(tmp_path);\n\t\t// add +1 to copy the null byte\n\t\tmemcpy(full_path, tmp_path, full_path_len+1);\n\n\t\tstruct uwsgi_string_list *safe = uc.cgi_safe;\n\t\twhile(safe) {\n\t\t\tif (!uwsgi_starts_with(full_path, full_path_len, safe->value, safe->len))\n\t\t\t\tbreak;\n\t\t\tsafe = safe->next;\n\t\t}\n\n\t\tif (!safe) {\n\t\t\tif (uwsgi_starts_with(full_path, full_path_len, docroot, docroot_len)) {\n\t\t\t\tuwsgi_log(\"CGI security error: %s is not under %s\\n\", full_path, docroot);\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(docroot);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\telse {\n\t\t*(full_path+docroot_len) = 0;\n\t\tpath_info = wsgi_req->path_info+discard_base;\n\t}\n\n\tif (stat(full_path, &cgi_stat)) {\n\t\tuwsgi_404(wsgi_req);\n\t\tif (need_free)\n\t\t\tfree(docroot);\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (S_ISDIR(cgi_stat.st_mode)) {\n\n\t\t// add / to directories\n\t\tif (wsgi_req->path_info_len == 0 || (wsgi_req->path_info_len > 0 && wsgi_req->path_info[wsgi_req->path_info_len-1] != '/')) {\n\t\t\tuwsgi_redirect_to_slash(wsgi_req);\n\t\t\tif (need_free)\n                        \tfree(docroot);\n                \treturn UWSGI_OK;\n\t\t}\n\t\tstruct uwsgi_string_list *ci = uc.index;\n\t\tfull_path[full_path_len] = '/';\n\t\tfull_path_len++;\n\t\tint found = 0;\n\t\twhile(ci) {\n\t\t\tif (full_path_len + ci->len + 1 < PATH_MAX) {\n\t\t\t\t// add + 1 to ensure null byte\n\t\t\t\tmemcpy(full_path+full_path_len, ci->value, ci->len + 1);\n\t\t\t\tif (!access(full_path, R_OK)) {\n\t\t\t\t\t\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tci = ci->next;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t}\n\n\tfull_path_len = strlen(full_path);\n\n\tint cgi_allowed = 1;\n\tstruct uwsgi_string_list *allowed = uc.allowed_ext;\n\twhile(allowed) {\n\t\tcgi_allowed = 0;\n\t\tif (full_path_len >= allowed->len) {\n\t\t\tif (!uwsgi_strncmp(full_path+(full_path_len-allowed->len), allowed->len, allowed->value, allowed->len)) {\n\t\t\t\tcgi_allowed = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tallowed = allowed->next;\n\t}\n\n\tif (!cgi_allowed) {\n\t\tuwsgi_403(wsgi_req);\n\t\tif (need_free)\n\t\t\tfree(docroot);\n\t\treturn UWSGI_OK;\n\t}\n\n\t// get the helper\n\tif (!is_a_file) {\n\t\thelper = uwsgi_cgi_get_helper(full_path);\n\n\t\tif (helper == NULL) {\n\t\t\tif (access(full_path, X_OK)) {\n\t\t\t\tuwsgi_error(\"access()\");\n\t\t\t\tuwsgi_403(wsgi_req);\n                \t\tif (need_free)\n                        \t\tfree(docroot);\n\t\t\t\treturn UWSGI_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = uwsgi_cgi_run(wsgi_req, docroot, docroot_len, full_path, helper, path_info, script_name, is_a_file, discard_base);\n\tif (need_free) free(docroot);\n\treturn ret;\n}\n\nstatic int uwsgi_cgi_run(struct wsgi_request *wsgi_req, char *docroot, size_t docroot_len, char *full_path, char *helper, char *path_info, char *script_name, int is_a_file, int discard_base) {\n\n\tint cgi_pipe[2];\n\tint post_pipe[2];\n\tint nargs = 0;\n\tint waitpid_status;\n\tint i;\n\tchar **argv;\n\n\tchar *command = full_path;\n\tint stdin_closed = 0;\n\n\tif (is_a_file) {\n                command = docroot;\n        }\n\n\tif (pipe(cgi_pipe)) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/pipe()\");\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (pipe(post_pipe)) {\n\t\tclose(cgi_pipe[0]);\n\t\tclose(cgi_pipe[1]);\n\t\tuwsgi_error(\"uwsgi_cgi_run()/pipe()\");\n\t\treturn UWSGI_OK;\n\t}\n\n\tpid_t cgi_pid = fork();\n\n\tif (cgi_pid < 0) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/fork()\");\n\t\tclose(cgi_pipe[0]);\n\t\tclose(cgi_pipe[1]);\n\t\tclose(post_pipe[0]);\n\t\tclose(post_pipe[1]);\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (cgi_pid > 0) {\n\n\t\tclose(cgi_pipe[1]);\n\t\tclose(post_pipe[0]);\n\n\t\tuwsgi_socket_nb(cgi_pipe[0]);\n\t\tuwsgi_socket_nb(post_pipe[1]);\n\n\t\t// ok start sending post data...\n\t\tsize_t remains = wsgi_req->post_cl;\n\t\twhile(remains > 0) {\n                \tssize_t rlen = 0;\n                \tchar *buf = uwsgi_request_body_read(wsgi_req, 8192, &rlen);\n                \tif (!buf) {\n\t\t\t\tgoto clear2;\n                \t}\n                \tif (buf == uwsgi.empty) break;\n                \t// write data to the node\n                \tif (uwsgi_write_true_nb(post_pipe[1], buf, rlen, uc.timeout)) {\n\t\t\t\tgoto clear2;\n                \t}\n                \tremains -= rlen;\n        \t}\n\n\t\tif (uc.close_stdin_on_eof) {\n\t\t\tclose(post_pipe[1]);\n\t\t\tstdin_closed = 1;\n\t\t}\n\n\t\t// wait for data\n\t\tchar *buf = uwsgi_malloc(uc.buffer_size);\n\n\t\tint completed = uwsgi_cgi_parse(wsgi_req, cgi_pipe[0], buf, uc.buffer_size);\n\t\tif (completed < 0) {\n\t\t\tuwsgi_log(\"invalid CGI response !!!\\n\");\n\t\t\tkill_on_error\n\t\t\tgoto clear;\n\t\t}\n\n\t\twhile (!completed) {\n\t\t\tssize_t rlen = uwsgi_read_true_nb(cgi_pipe[0], buf, uc.buffer_size, uc.timeout);\n\t\t\tif (rlen > 0) {\n\t\t\t\tif (uwsgi_response_write_body_do(wsgi_req, buf, rlen)) {\n\t\t\t\t\tkill_on_error\n\t\t\t\t\tgoto clear;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rlen == 0) {\n\t\t\t\tuwsgi_log(\"CGI timeout !!!\\n\");\n\t\t\t\tkill_on_error\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (errno) {\n\t\t\t\t\tuwsgi_req_error(\"error reading CGI response\\n\");\n\t\t\t\t\tkill_on_error\n\t\t\t\t}\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t}\n\nclear:\n\t\tfree(buf);\nclear2:\n\t\tclose(cgi_pipe[0]);\n\t\tif (!stdin_closed)\n\t\t\tclose(post_pipe[1]);\n\n\t\t// now wait for process exit/death\n\t\t// in async mode we need a trick...\n\t\tif (uwsgi.async > 1) {\n\t\t\tpid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);\n\t\t\tif (diedpid < 0) {\n                               \tuwsgi_error(\"waitpid()\");\n                        }\n\t\t\telse if (diedpid == 0) {\n\t\t\t\t// pass the pid of the cgi to async_plagued (the after request hook will clear the process)\n\t\t\t\twsgi_req->async_plagued = (int) cgi_pid;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t}\n\n\t\treturn UWSGI_OK;\n\t}\n\n\t// now map wsgi_req->poll.fd (or async_post) to 0 & cgi_pipe[1] to 1\n\tdup2(post_pipe[0], 0);\n\tclose(post_pipe[0]);\n\n\tdup2(cgi_pipe[1],1);\n\tclose(cgi_pipe[1]);\n\n\t// close all the fd > 2\n\tfor(i=3;i<(int)uwsgi.max_fd;i++) {\n\t\tclose(i);\n\t}\n\n\t// fill cgi env\n\tfor(i=0;i<wsgi_req->var_cnt;i+=2) {\n\t\t// no need to free the putenv() memory\n\t\tif (putenv(uwsgi_concat3n(wsgi_req->hvec[i].iov_base, wsgi_req->hvec[i].iov_len, \"=\", 1, wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len))) {\n\t\t\tuwsgi_error(\"putenv()\");\n\t\t}\n\t}\n\n\n\tif (setenv(\"GATEWAY_INTERFACE\", \"CGI/1.1\", 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\tif (setenv(\"SERVER_SOFTWARE\", uwsgi_concat2(\"uWSGI/\", UWSGI_VERSION), 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\t// for newer php\n\tif (setenv(\"REDIRECT_STATUS\", \"200\", 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\n\n\tif (path_info) {\n\n\t\tsize_t pi_len = wsgi_req->path_info_len - (path_info - wsgi_req->path_info);\n\n\t\tif (setenv(\"PATH_INFO\", uwsgi_concat2n(path_info, pi_len, \"\", 0), 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (wsgi_req->document_root_len > 0) {\n\t\t\tif (setenv(\"PATH_TRANSLATED\", uwsgi_concat3n(wsgi_req->document_root, wsgi_req->document_root_len, path_info, pi_len, \"\", 0) , 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (setenv(\"PATH_TRANSLATED\", uwsgi_concat3n(docroot, docroot_len, path_info, pi_len, \"\", 0) , 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\n\t}\n\telse {\n\t\tunsetenv(\"PATH_INFO\");\n\t\tunsetenv(\"PATH_TRANSLATED\");\n\t}\n\n\tif (is_a_file) {\n\t\tif (setenv(\"DOCUMENT_ROOT\", uwsgi.cwd, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_FILENAME\", docroot, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (script_name && discard_base > 1) {\n\t\t\tif (setenv(\"SCRIPT_NAME\", uwsgi_concat2n(script_name, discard_base, \"\", 0), 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (setenv(\"DOCUMENT_ROOT\", docroot, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_FILENAME\", full_path, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_NAME\", uwsgi_concat2n(wsgi_req->path_info, discard_base, full_path+docroot_len, strlen(full_path+docroot_len)), 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tchar *base = uwsgi_get_last_char(full_path, '/');\n\t\tif (base) {\n\t\t\t// a little trick :P\n\t\t\t*base = 0;\n\t\t\tif (chdir(full_path)) {\n                                uwsgi_error(\"chdir()\");\n                        }\n\t\t\t*base = '/';\n\t\t}\n\t\telse if (docroot_len > 0) {\n\t\t\tif (chdir(docroot)) {\n\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *drop_env = uc.unset;\n\twhile(drop_env) {\n\t\tunsetenv(drop_env->value);\n\t\tdrop_env = drop_env->next;\n\t}\n\n\targv = uwsgi_malloc(sizeof(char *) * 3);\n\n\t// check if we need to parse indexed QUERY_STRING\n\tif (wsgi_req->query_string_len > 0) {\n\t\tif (!memchr(wsgi_req->query_string, '=', wsgi_req->query_string_len)) {\n\t\t\tnargs = 1;\n\t\t\tfor(i=0;i<wsgi_req->query_string_len;i++) {\n\t\t\t\tif (wsgi_req->query_string[i] == '+')\n\t\t\t\t\tnargs++;\n\t\t\t}\n\n\t\t\t\n\t\t\t// reallocate argv and qs\n\t\t\targv = uwsgi_malloc(sizeof(char *) * (3+nargs));\n\t\t\tchar *qs = uwsgi_concat2n(wsgi_req->query_string, wsgi_req->query_string_len, \"\", 0);\n\t\t\t// set the start position of args in argv\n\t\t\ti = 1;\n\t\t\tif (helper) i = 2;\n\t\t\tchar *p, *ctx = NULL;\n\t\t\tuwsgi_foreach_token(qs, \"+\", p, ctx) {\n\t\t\t\t// create a copy for the url_decoded string\n\t\t\t\tchar *arg_copy = uwsgi_str(p);\n\t\t\t\tuint16_t arg_copy_len = strlen(p);\n\t\t\t\thttp_url_decode(p, &arg_copy_len, arg_copy);\n\t\t\t\t// and a final copy for shell escaped arg\n\t\t\t\targv[i] = uwsgi_malloc( (arg_copy_len * 2) +1);\n\t\t\t\tescape_shell_arg(arg_copy, arg_copy_len, argv[i]);\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfree(qs);\n\t\t}\n\t}\n\n\tif (helper) {\n\t\tif (!uwsgi_starts_with(helper, strlen(helper), \"sym://\", 6)) {\n\t\t\tvoid (*cgi_func)(char *) = dlsym(RTLD_DEFAULT, helper+6);\n\t\t\tif (cgi_func) {\n\t\t\t\tcgi_func(command);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"unable to find symbol %s\\n\", helper+6);\n\t\t\t}\n\t\t\texit(0);\t\n\t\t}\n\t\targv[0] = helper;\n\t\targv[1] = command;\n\t\targv[nargs+2] = NULL;\n\t}\n\telse {\n\t\targv[0] = command;\n\t\targv[nargs+1] = NULL;\n\t}\n\n\tif (execvp(argv[0], argv)) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/execvp()\");\n\t}\n\n\t// never here\n\texit(1);\n}\n\n\nstatic void uwsgi_cgi_after_request(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->async_plagued > 0) {\n\t\tint waitpid_status;\n\t\tpid_t cgi_pid = (pid_t) wsgi_req->async_plagued;\n\t\tint max_attempts = uc.async_max_attempts;\n                        if (!max_attempts) max_attempts = 10;\n                        while(max_attempts) {\n                                pid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);\n                                if (diedpid < 0) {\n                                        uwsgi_error(\"waitpid()\");\n                                        break;\n                                }\n                                else if (diedpid == 0) {\n                                        int ret = uwsgi.wait_milliseconds_hook(1000);\n                                        if (ret < 0) {\n                                                kill_on_error\n\t\t\t\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n                                \t\t\tuwsgi_error(\"waitpid()\");\n                        \t\t\t}\n                                        }\n                                }\n                                else {\n                                        break;\n                                }\n                                max_attempts--;\n                        }\n                        if (max_attempts == 0) {\n                                kill_on_error\n\t\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n                                \tuwsgi_error(\"waitpid()\");\n                        \t}\n                        }\n\t}\n\n\tlog_request(wsgi_req);\n}\n\n#ifdef UWSGI_ROUTING\nstatic int uwsgi_routing_func_cgi(struct wsgi_request *wsgi_req, struct uwsgi_route *ur){\n\n        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);\n        uint16_t *subject_len = (uint16_t *) (((char *)(wsgi_req))+ur->subject_len);\n\n        struct uwsgi_buffer *ub_command = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, ur->data, ur->data_len);\n        if (!ub_command) return UWSGI_ROUTE_BREAK;\n\tstruct uwsgi_buffer *ub_helper = NULL;\n\tif (ur->data2_len) {\n\t\tub_helper = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, ur->data2, ur->data2_len);\n\t\tif (!ub_helper) {\n\t\t\tuwsgi_buffer_destroy(ub_command);\n        \t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\t}\n\telse {\n\t\tif (!uwsgi_is_file(ub_command->buf)) {\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\tuwsgi_buffer_destroy(ub_command);\n\t\t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\n\t\tif (access(ub_command->buf, X_OK)) {\n\t\t\tuwsgi_403(wsgi_req);\n\t\t\tuwsgi_buffer_destroy(ub_command);\n\t\t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\t}\n\t// we need a NULL suffix-ed copy of the docroot\n\tchar *docroot = uwsgi_concat2n(wsgi_req->document_root, wsgi_req->document_root_len, \"\", 0);\n        uwsgi_cgi_run(wsgi_req, wsgi_req->document_root, wsgi_req->document_root_len, ub_command->buf, ub_helper ? ub_helper->buf : NULL, NULL, NULL, 0, 0 );\n\tfree(docroot);\n        uwsgi_buffer_destroy(ub_command);\n\tif (ub_helper) uwsgi_buffer_destroy(ub_helper);\n        return UWSGI_ROUTE_BREAK;\n}\n\nstatic int uwsgi_router_cgi_helper(struct uwsgi_route *ur, char *args) {\n        ur->func = uwsgi_routing_func_cgi;\n\tchar *space = strchr(args, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid cgihelper syntax, must be \\\"cgihelper:helper command\\\"\\n\");\n\t\treturn -1;\n\t}\n\t*space = 0;\n        ur->data = space+1;\n        ur->data_len = strlen(space+1);\n\tur->data2 = args;\n\tur->data2_len = strlen(args);\n        return 0;\n}\nstatic int uwsgi_router_cgi(struct uwsgi_route *ur, char *args) {\n        ur->func = uwsgi_routing_func_cgi;\n\tur->data = args;\n\tur->data_len = strlen(args);\n        return 0;\n}\nstatic void uwsgi_cgi_register_router() {\n        uwsgi_register_router(\"cgi\", uwsgi_router_cgi);\n        uwsgi_register_router(\"cgihelper\", uwsgi_router_cgi_helper);\n}\n#endif\n\nstruct uwsgi_plugin cgi_plugin = {\n\n\t.name = \"cgi\",\n\t.modifier1 = 9,\n\t.init = uwsgi_cgi_init,\n\t.init_apps = uwsgi_cgi_apps,\n\t.options = uwsgi_cgi_options,\n\t.request = uwsgi_cgi_request,\n\t.after_request = uwsgi_cgi_after_request,\n#ifdef UWSGI_ROUTING\n        .on_load = uwsgi_cgi_register_router,\n#endif\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/core/uwsgi.c": "/*\n\n *** uWSGI ***\n\n Copyright (C) 2009-2017 Unbit S.a.s. <info@unbit.it>\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n*/\n\n\n#include <uwsgi.h>\n\nstruct uwsgi_server uwsgi;\npid_t masterpid;\n\n#if defined(__APPLE__) && defined(UWSGI_AS_SHARED_LIBRARY)\n#include <crt_externs.h>\n#define UWSGI_ENVIRON (*_NSGetEnviron())\n#else\nextern char **environ;\n#define UWSGI_ENVIRON environ\n#endif\n\nUWSGI_DECLARE_EMBEDDED_PLUGINS;\n\nstatic struct uwsgi_option uwsgi_base_options[] = {\n\t{\"socket\", required_argument, 's', \"bind to the specified UNIX/TCP socket using default protocol\", uwsgi_opt_add_socket, NULL, 0},\n\t{\"uwsgi-socket\", required_argument, 's', \"bind to the specified UNIX/TCP socket using uwsgi protocol\", uwsgi_opt_add_socket, \"uwsgi\", 0},\n#ifdef UWSGI_SSL\n\t{\"suwsgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using uwsgi protocol over SSL\", uwsgi_opt_add_ssl_socket, \"suwsgi\", 0},\n\t{\"ssl-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using uwsgi protocol over SSL\", uwsgi_opt_add_ssl_socket, \"suwsgi\", 0},\n#endif\n\n\t{\"http-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTP protocol\", uwsgi_opt_add_socket, \"http\", 0},\n\t{\"http-socket-modifier1\", required_argument, 0, \"force the specified modifier1 when using HTTP protocol\", uwsgi_opt_set_64bit, &uwsgi.http_modifier1, 0},\n\t{\"http-socket-modifier2\", required_argument, 0, \"force the specified modifier2 when using HTTP protocol\", uwsgi_opt_set_64bit, &uwsgi.http_modifier2, 0},\n\n\t{\"http11-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTP 1.1 (Keep-Alive) protocol\", uwsgi_opt_add_socket, \"http11\", 0},\n\n#ifdef UWSGI_SSL\n\t{\"https-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTPS protocol\", uwsgi_opt_add_ssl_socket, \"https\", 0},\n\t{\"https-socket-modifier1\", required_argument, 0, \"force the specified modifier1 when using HTTPS protocol\", uwsgi_opt_set_64bit, &uwsgi.https_modifier1, 0},\n\t{\"https-socket-modifier2\", required_argument, 0, \"force the specified modifier2 when using HTTPS protocol\", uwsgi_opt_set_64bit, &uwsgi.https_modifier2, 0},\n#endif\n\n\t{\"fastcgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using FastCGI protocol\", uwsgi_opt_add_socket, \"fastcgi\", 0},\n\t{\"fastcgi-nph-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using FastCGI protocol (nph mode)\", uwsgi_opt_add_socket, \"fastcgi-nph\", 0},\n\t{\"fastcgi-modifier1\", required_argument, 0, \"force the specified modifier1 when using FastCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.fastcgi_modifier1, 0},\n\t{\"fastcgi-modifier2\", required_argument, 0, \"force the specified modifier2 when using FastCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.fastcgi_modifier2, 0},\n\n\t{\"scgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using SCGI protocol\", uwsgi_opt_add_socket, \"scgi\", 0},\n\t{\"scgi-nph-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using SCGI protocol (nph mode)\", uwsgi_opt_add_socket, \"scgi-nph\", 0},\n\t{\"scgi-modifier1\", required_argument, 0, \"force the specified modifier1 when using SCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.scgi_modifier1, 0},\n\t{\"scgi-modifier2\", required_argument, 0, \"force the specified modifier2 when using SCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.scgi_modifier2, 0},\n\n\t{\"raw-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using RAW protocol\", uwsgi_opt_add_socket_no_defer, \"raw\", 0},\n\t{\"raw-modifier1\", required_argument, 0, \"force the specified modifier1 when using RAW protocol\", uwsgi_opt_set_64bit, &uwsgi.raw_modifier1, 0},\n\t{\"raw-modifier2\", required_argument, 0, \"force the specified modifier2 when using RAW protocol\", uwsgi_opt_set_64bit, &uwsgi.raw_modifier2, 0},\n\n\t{\"puwsgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using persistent uwsgi protocol (puwsgi)\", uwsgi_opt_add_socket, \"puwsgi\", 0},\n\n\t{\"protocol\", required_argument, 0, \"force the specified protocol for default sockets\", uwsgi_opt_set_str, &uwsgi.protocol, 0},\n\t{\"socket-protocol\", required_argument, 0, \"force the specified protocol for default sockets\", uwsgi_opt_set_str, &uwsgi.protocol, 0},\n\t{\"shared-socket\", required_argument, 0, \"create a shared socket for advanced jailing or ipc\", uwsgi_opt_add_shared_socket, NULL, 0},\n\t{\"undeferred-shared-socket\", required_argument, 0, \"create a shared socket for advanced jailing or ipc (undeferred mode)\", uwsgi_opt_add_shared_socket, NULL, 0},\n\t{\"processes\", required_argument, 'p', \"spawn the specified number of workers/processes\", uwsgi_opt_set_int, &uwsgi.numproc, 0},\n\t{\"workers\", required_argument, 'p', \"spawn the specified number of workers/processes\", uwsgi_opt_set_int, &uwsgi.numproc, 0},\n\t{\"thunder-lock\", no_argument, 0, \"serialize accept() usage (if possible)\", uwsgi_opt_true, &uwsgi.use_thunder_lock, 0},\n\t{\"harakiri\", required_argument, 't', \"set harakiri timeout\", uwsgi_opt_set_int, &uwsgi.harakiri_options.workers, 0},\n\t{\"harakiri-verbose\", no_argument, 0, \"enable verbose mode for harakiri\", uwsgi_opt_true, &uwsgi.harakiri_verbose, 0},\n\t{\"harakiri-no-arh\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"no-harakiri-arh\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"no-harakiri-after-req-hook\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"backtrace-depth\", required_argument, 0, \"set backtrace depth\", uwsgi_opt_set_int, &uwsgi.backtrace_depth, 0},\n\t{\"mule-harakiri\", required_argument, 0, \"set harakiri timeout for mule tasks\", uwsgi_opt_set_int, &uwsgi.harakiri_options.mules, 0},\n#ifdef UWSGI_XML\n\t{\"xmlconfig\", required_argument, 'x', \"load config from xml file\", uwsgi_opt_load_xml, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"xml\", required_argument, 'x', \"load config from xml file\", uwsgi_opt_load_xml, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"config\", required_argument, 0, \"load configuration using the pluggable system\", uwsgi_opt_load_config, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"fallback-config\", required_argument, 0, \"re-exec uwsgi with the specified config when exit code is 1\", uwsgi_opt_set_str, &uwsgi.fallback_config, UWSGI_OPT_IMMEDIATE},\n\t{\"strict\", no_argument, 0, \"enable strict mode (placeholder cannot be used)\", uwsgi_opt_true, &uwsgi.strict, UWSGI_OPT_IMMEDIATE},\n\n\t{\"skip-zero\", no_argument, 0, \"skip check of file descriptor 0\", uwsgi_opt_true, &uwsgi.skip_zero, 0},\n\t{\"skip-atexit\", no_argument, 0, \"skip atexit hooks (ignored by the master)\", uwsgi_opt_true, &uwsgi.skip_atexit, 0},\n\t{\"skip-atexit-teardown\", no_argument, 0, \"skip atexit teardown (ignored by the master)\", uwsgi_opt_true, &uwsgi.skip_atexit_teardown, 0},\n\n\t{\"set\", required_argument, 'S', \"set a placeholder or an option\", uwsgi_opt_set_placeholder, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"set-placeholder\", required_argument, 0, \"set a placeholder\", uwsgi_opt_set_placeholder, (void *) 1, UWSGI_OPT_IMMEDIATE},\n\t{\"set-ph\", required_argument, 0, \"set a placeholder\", uwsgi_opt_set_placeholder, (void *) 1, UWSGI_OPT_IMMEDIATE},\n\t{\"get\", required_argument, 0, \"print the specified option value and exit\", uwsgi_opt_add_string_list, &uwsgi.get_list, UWSGI_OPT_NO_INITIAL},\n\t{\"declare-option\", required_argument, 0, \"declare a new uWSGI custom option\", uwsgi_opt_add_custom_option, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"declare-option2\", required_argument, 0, \"declare a new uWSGI custom option (non-immediate)\", uwsgi_opt_add_custom_option, NULL, 0},\n\n\t{\"resolve\", required_argument, 0, \"place the result of a dns query in the specified placeholder, sytax: placeholder=name (immediate option)\", uwsgi_opt_resolve, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"for\", required_argument, 0, \"(opt logic) for cycle\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for, UWSGI_OPT_IMMEDIATE},\n\t{\"for-glob\", required_argument, 0, \"(opt logic) for cycle (expand glob)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_glob, UWSGI_OPT_IMMEDIATE},\n\t{\"for-times\", required_argument, 0, \"(opt logic) for cycle (expand the specified num to a list starting from 1)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_times, UWSGI_OPT_IMMEDIATE},\n\t{\"for-readline\", required_argument, 0, \"(opt logic) for cycle (expand the specified file to a list of lines)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_readline, UWSGI_OPT_IMMEDIATE},\n\t{\"endfor\", optional_argument, 0, \"(opt logic) end for cycle\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"end-for\", optional_argument, 0, \"(opt logic) end for cycle\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-opt\", required_argument, 0, \"(opt logic) check for option\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_opt, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-opt\", required_argument, 0, \"(opt logic) check for option\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_opt, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-env\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_env, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-env\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_env, UWSGI_OPT_IMMEDIATE},\n\t{\"ifenv\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_env, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-reload\", no_argument, 0, \"(opt logic) check for reload\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_reload, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-reload\", no_argument, 0, \"(opt logic) check for reload\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_reload, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-hostname\", required_argument, 0, \"(opt logic) check for hostname\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_hostname, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-hostname\", required_argument, 0, \"(opt logic) check for hostname\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_hostname, UWSGI_OPT_IMMEDIATE},\n\n#ifdef UWSGI_PCRE\n\t{\"if-hostname-match\", required_argument, 0, \"(opt logic) try to match hostname against a regular expression\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_hostname_match, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-hostname-match\", required_argument, 0, \"(opt logic) try to match hostname against a regular expression\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_hostname_match, UWSGI_OPT_IMMEDIATE},\n#endif\n\n\t{\"if-exists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-exists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_exists, UWSGI_OPT_IMMEDIATE},\n\t{\"ifexists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-plugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_plugin, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-plugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_plugin, UWSGI_OPT_IMMEDIATE},\n\t{\"ifplugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_plugin, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-file\", required_argument, 0, \"(opt logic) check for file existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_file, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-file\", required_argument, 0, \"(opt logic) check for file existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_file, UWSGI_OPT_IMMEDIATE},\n\t{\"if-dir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-dir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_dir, UWSGI_OPT_IMMEDIATE},\n\n\t{\"ifdir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"if-directory\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\n\t{\"endif\", optional_argument, 0, \"(opt logic) end if\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"end-if\", optional_argument, 0, \"(opt logic) end if\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"blacklist\", required_argument, 0, \"set options blacklist context\", uwsgi_opt_set_str, &uwsgi.blacklist_context, UWSGI_OPT_IMMEDIATE},\n\t{\"end-blacklist\", no_argument, 0, \"clear options blacklist context\", uwsgi_opt_set_null, &uwsgi.blacklist_context, UWSGI_OPT_IMMEDIATE},\n\n\t{\"whitelist\", required_argument, 0, \"set options whitelist context\", uwsgi_opt_set_str, &uwsgi.whitelist_context, UWSGI_OPT_IMMEDIATE},\n\t{\"end-whitelist\", no_argument, 0, \"clear options whitelist context\", uwsgi_opt_set_null, &uwsgi.whitelist_context, UWSGI_OPT_IMMEDIATE},\n\n\t{\"ignore-sigpipe\", no_argument, 0, \"do not report (annoying) SIGPIPE\", uwsgi_opt_true, &uwsgi.ignore_sigpipe, 0},\n\t{\"ignore-write-errors\", no_argument, 0, \"do not report (annoying) write()/writev() errors\", uwsgi_opt_true, &uwsgi.ignore_write_errors, 0},\n\t{\"write-errors-tolerance\", required_argument, 0, \"set the maximum number of allowed write errors (default: no tolerance)\", uwsgi_opt_set_64bit, &uwsgi.write_errors_tolerance, 0},\n\t{\"write-errors-exception-only\", no_argument, 0, \"only raise an exception on write errors giving control to the app itself\", uwsgi_opt_true, &uwsgi.write_errors_exception_only, 0},\n\t{\"disable-write-exception\", no_argument, 0, \"disable exception generation on write()/writev()\", uwsgi_opt_true, &uwsgi.disable_write_exception, 0},\n\n\t{\"inherit\", required_argument, 0, \"use the specified file as config template\", uwsgi_opt_load, NULL, 0},\n\t{\"include\", required_argument, 0, \"include the specified file as immediate configuration\", uwsgi_opt_load, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"inject-before\", required_argument, 0, \"inject a text file before the config file (advanced templating)\", uwsgi_opt_add_string_list, &uwsgi.inject_before, UWSGI_OPT_IMMEDIATE},\n\t{\"inject-after\", required_argument, 0, \"inject a text file after the config file (advanced templating)\", uwsgi_opt_add_string_list, &uwsgi.inject_after, UWSGI_OPT_IMMEDIATE},\n\t{\"daemonize\", required_argument, 'd', \"daemonize uWSGI\", uwsgi_opt_set_str, &uwsgi.daemonize, 0},\n\t{\"daemonize2\", required_argument, 0, \"daemonize uWSGI after app loading\", uwsgi_opt_set_str, &uwsgi.daemonize2, 0},\n\t{\"stop\", required_argument, 0, \"stop an instance\", uwsgi_opt_pidfile_signal, (void *) SIGINT, UWSGI_OPT_IMMEDIATE},\n\t{\"reload\", required_argument, 0, \"reload an instance\", uwsgi_opt_pidfile_signal, (void *) SIGHUP, UWSGI_OPT_IMMEDIATE},\n\t{\"pause\", required_argument, 0, \"pause an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\t{\"suspend\", required_argument, 0, \"suspend an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\t{\"resume\", required_argument, 0, \"resume an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\n\t{\"connect-and-read\", required_argument, 0, \"connect to a socket and wait for data from it\", uwsgi_opt_connect_and_read, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"extract\", required_argument, 0, \"fetch/dump any supported address to stdout\", uwsgi_opt_extract, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"listen\", required_argument, 'l', \"set the socket listen queue size\", uwsgi_opt_set_int, &uwsgi.listen_queue, UWSGI_OPT_IMMEDIATE},\n\t{\"max-vars\", required_argument, 'v', \"set the amount of internal iovec/vars structures\", uwsgi_opt_max_vars, NULL, 0},\n\t{\"max-apps\", required_argument, 0, \"set the maximum number of per-worker applications\", uwsgi_opt_set_int, &uwsgi.max_apps, 0},\n\t{\"buffer-size\", required_argument, 'b', \"set internal buffer size\", uwsgi_opt_set_16bit, &uwsgi.buffer_size, 0},\n\t{\"memory-report\", no_argument, 'm', \"enable memory report\", uwsgi_opt_true, &uwsgi.logging_options.memory_report, 0},\n\t{\"profiler\", required_argument, 0, \"enable the specified profiler\", uwsgi_opt_set_str, &uwsgi.profiler, 0},\n\t{\"cgi-mode\", no_argument, 'c', \"force CGI-mode for plugins supporting it\", uwsgi_opt_true, &uwsgi.cgi_mode, 0},\n\t{\"abstract-socket\", no_argument, 'a', \"force UNIX socket in abstract mode (Linux only)\", uwsgi_opt_true, &uwsgi.abstract_socket, 0},\n\t{\"chmod-socket\", optional_argument, 'C', \"chmod-socket\", uwsgi_opt_chmod_socket, NULL, 0},\n\t{\"chmod\", optional_argument, 'C', \"chmod-socket\", uwsgi_opt_chmod_socket, NULL, 0},\n\t{\"chown-socket\", required_argument, 0, \"chown unix sockets\", uwsgi_opt_set_str, &uwsgi.chown_socket, 0},\n\t{\"umask\", required_argument, 0, \"set umask\", uwsgi_opt_set_umask, NULL, UWSGI_OPT_IMMEDIATE},\n#ifdef __linux__\n\t{\"freebind\", no_argument, 0, \"put socket in freebind mode\", uwsgi_opt_true, &uwsgi.freebind, 0},\n#endif\n\t{\"map-socket\", required_argument, 0, \"map sockets to specific workers\", uwsgi_opt_add_string_list, &uwsgi.map_socket, 0},\n\t{\"enable-threads\", no_argument, 'T', \"enable threads\", uwsgi_opt_true, &uwsgi.has_threads, 0},\n\t{\"no-threads-wait\", no_argument, 0, \"do not wait for threads cancellation on quit/reload\", uwsgi_opt_true, &uwsgi.no_threads_wait, 0},\n\n\t{\"auto-procname\", no_argument, 0, \"automatically set processes name to something meaningful\", uwsgi_opt_true, &uwsgi.auto_procname, 0},\n\t{\"procname-prefix\", required_argument, 0, \"add a prefix to the process names\", uwsgi_opt_set_str, &uwsgi.procname_prefix, UWSGI_OPT_PROCNAME},\n\t{\"procname-prefix-spaced\", required_argument, 0, \"add a spaced prefix to the process names\", uwsgi_opt_set_str_spaced, &uwsgi.procname_prefix, UWSGI_OPT_PROCNAME},\n\t{\"procname-append\", required_argument, 0, \"append a string to process names\", uwsgi_opt_set_str, &uwsgi.procname_append, UWSGI_OPT_PROCNAME},\n\t{\"procname\", required_argument, 0, \"set process names\", uwsgi_opt_set_str, &uwsgi.procname, UWSGI_OPT_PROCNAME},\n\t{\"procname-master\", required_argument, 0, \"set master process name\", uwsgi_opt_set_str, &uwsgi.procname_master, UWSGI_OPT_PROCNAME},\n\n\t{\"single-interpreter\", no_argument, 'i', \"do not use multiple interpreters (where available)\", uwsgi_opt_true, &uwsgi.single_interpreter, 0},\n\t{\"need-app\", no_argument, 0, \"exit if no app can be loaded\", uwsgi_opt_true, &uwsgi.need_app, 0},\n\t{\"master\", no_argument, 'M', \"enable master process\", uwsgi_opt_true, &uwsgi.master_process, 0},\n\t{\"honour-stdin\", no_argument, 0, \"do not remap stdin to /dev/null\", uwsgi_opt_true, &uwsgi.honour_stdin, 0},\n\t{\"emperor\", required_argument, 0, \"run the Emperor\", uwsgi_opt_add_string_list, &uwsgi.emperor, 0},\n\t{\"emperor-proxy-socket\", required_argument, 0, \"force the vassal to became an Emperor proxy\", uwsgi_opt_set_str, &uwsgi.emperor_proxy, 0},\n\t{\"emperor-wrapper\", required_argument, 0, \"set a binary wrapper for vassals\", uwsgi_opt_set_str, &uwsgi.emperor_wrapper, 0},\n\t{\"emperor-wrapper-override\", required_argument, 0, \"set a binary wrapper for vassals to try before the default one\", uwsgi_opt_add_string_list, &uwsgi.emperor_wrapper_override, 0},\n\t{\"emperor-wrapper-fallback\", required_argument, 0, \"set a binary wrapper for vassals to try as a last resort\", uwsgi_opt_add_string_list, &uwsgi.emperor_wrapper_fallback, 0},\n\t{\"emperor-nofollow\", no_argument, 0, \"do not follow symlinks when checking for mtime\", uwsgi_opt_true, &uwsgi.emperor_nofollow, 0},\n\t{\"emperor-procname\", required_argument, 0, \"set the Emperor process name\", uwsgi_opt_set_str, &uwsgi.emperor_procname, 0},\n\t{\"emperor-freq\", required_argument, 0, \"set the Emperor scan frequency (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.emperor_freq, 0},\n\t{\"emperor-required-heartbeat\", required_argument, 0, \"set the Emperor tolerance about heartbeats\", uwsgi_opt_set_int, &uwsgi.emperor_heartbeat, 0},\n\t{\"emperor-curse-tolerance\", required_argument, 0, \"set the Emperor tolerance about cursed vassals\", uwsgi_opt_set_int, &uwsgi.emperor_curse_tolerance, 0},\n\t{\"emperor-pidfile\", required_argument, 0, \"write the Emperor pid in the specified file\", uwsgi_opt_set_str, &uwsgi.emperor_pidfile, 0},\n\t{\"emperor-tyrant\", no_argument, 0, \"put the Emperor in Tyrant mode\", uwsgi_opt_true, &uwsgi.emperor_tyrant, 0},\n\t{\"emperor-tyrant-nofollow\", no_argument, 0, \"do not follow symlinks when checking for uid/gid in Tyrant mode\", uwsgi_opt_true, &uwsgi.emperor_tyrant_nofollow, 0},\n\t{\"emperor-stats\", required_argument, 0, \"run the Emperor stats server\", uwsgi_opt_set_str, &uwsgi.emperor_stats, 0},\n\t{\"emperor-stats-server\", required_argument, 0, \"run the Emperor stats server\", uwsgi_opt_set_str, &uwsgi.emperor_stats, 0},\n\t{\"early-emperor\", no_argument, 0, \"spawn the emperor as soon as possibile\", uwsgi_opt_true, &uwsgi.early_emperor, 0},\n\t{\"emperor-broodlord\", required_argument, 0, \"run the emperor in BroodLord mode\", uwsgi_opt_set_int, &uwsgi.emperor_broodlord, 0},\n\t{\"emperor-throttle\", required_argument, 0, \"set throttling level (in milliseconds) for bad behaving vassals (default 1000)\", uwsgi_opt_set_int, &uwsgi.emperor_throttle, 0},\n\t{\"emperor-max-throttle\", required_argument, 0, \"set max throttling level (in milliseconds) for bad behaving vassals (default 3 minutes)\", uwsgi_opt_set_int, &uwsgi.emperor_max_throttle, 0},\n\t{\"emperor-magic-exec\", no_argument, 0, \"prefix vassals config files with exec:// if they have the executable bit\", uwsgi_opt_true, &uwsgi.emperor_magic_exec, 0},\n\t{\"emperor-on-demand-extension\", required_argument, 0, \"search for text file (vassal name + extension) containing the on demand socket name\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_extension, 0},\n\t{\"emperor-on-demand-ext\", required_argument, 0, \"search for text file (vassal name + extension) containing the on demand socket name\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_extension, 0},\n\t{\"emperor-on-demand-directory\", required_argument, 0, \"enable on demand mode binding to the unix socket in the specified directory named like the vassal + .socket\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_directory, 0},\n\t{\"emperor-on-demand-dir\", required_argument, 0, \"enable on demand mode binding to the unix socket in the specified directory named like the vassal + .socket\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_directory, 0},\n\t{\"emperor-on-demand-exec\", required_argument, 0, \"use the output of the specified command as on demand socket name (the vassal name is passed as the only argument)\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_exec, 0},\n\t{\"emperor-extra-extension\", required_argument, 0, \"allows the specified extension in the Emperor (vassal will be called with --config)\", uwsgi_opt_add_string_list, &uwsgi.emperor_extra_extension, 0},\n\t{\"emperor-extra-ext\", required_argument, 0, \"allows the specified extension in the Emperor (vassal will be called with --config)\", uwsgi_opt_add_string_list, &uwsgi.emperor_extra_extension, 0},\n\t{\"emperor-no-blacklist\", no_argument, 0, \"disable Emperor blacklisting subsystem\", uwsgi_opt_true, &uwsgi.emperor_no_blacklist, 0},\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\t{\"emperor-use-clone\", required_argument, 0, \"use clone() instead of fork() passing the specified unshare() flags\", uwsgi_opt_set_unshare, &uwsgi.emperor_clone, 0},\n#endif\n#ifdef UWSGI_CAP\n\t{\"emperor-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n\t{\"vassals-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n\t{\"vassal-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n#endif\n\t{\"imperial-monitor-list\", no_argument, 0, \"list enabled imperial monitors\", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},\n\t{\"imperial-monitors-list\", no_argument, 0, \"list enabled imperial monitors\", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},\n\t{\"vassals-inherit\", required_argument, 0, \"add config templates to vassals config (uses --inherit)\", uwsgi_opt_add_string_list, &uwsgi.vassals_templates, 0},\n\t{\"vassals-include\", required_argument, 0, \"include config templates to vassals config (uses --include instead of --inherit)\", uwsgi_opt_add_string_list, &uwsgi.vassals_includes, 0},\n\t{\"vassals-inherit-before\", required_argument, 0, \"add config templates to vassals config (uses --inherit, parses before the vassal file)\", uwsgi_opt_add_string_list, &uwsgi.vassals_templates_before, 0},\n\t{\"vassals-include-before\", required_argument, 0, \"include config templates to vassals config (uses --include instead of --inherit, parses before the vassal file)\", uwsgi_opt_add_string_list, &uwsgi.vassals_includes_before, 0},\n\t{\"vassals-start-hook\", required_argument, 0, \"run the specified command before each vassal starts\", uwsgi_opt_set_str, &uwsgi.vassals_start_hook, 0},\n\t{\"vassals-stop-hook\", required_argument, 0, \"run the specified command after vassal's death\", uwsgi_opt_set_str, &uwsgi.vassals_stop_hook, 0},\n\t{\"vassal-sos\", required_argument, 0, \"ask emperor for reinforcement when overloaded\", uwsgi_opt_set_int, &uwsgi.vassal_sos, 0},\n\t{\"vassal-sos-backlog\", required_argument, 0, \"ask emperor for sos if backlog queue has more items than the value specified\", uwsgi_opt_set_int, &uwsgi.vassal_sos_backlog, 0},\n\t{\"vassals-set\", required_argument, 0, \"automatically set the specified option (via --set) for every vassal\", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},\n\t{\"vassal-set\", required_argument, 0, \"automatically set the specified option (via --set) for every vassal\", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},\n\n\t{\"heartbeat\", required_argument, 0, \"announce healthiness to the emperor\", uwsgi_opt_set_int, &uwsgi.heartbeat, 0},\n\n\t{\"reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) we wait for workers and other processes to die during reload/shutdown\", uwsgi_opt_set_int, &uwsgi.reload_mercy, 0},\n\t{\"worker-reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) a worker can take to reload/shutdown (default is 60)\", uwsgi_opt_set_int, &uwsgi.worker_reload_mercy, 0},\n\t{\"mule-reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) a mule can take to reload/shutdown (default is 60)\", uwsgi_opt_set_int, &uwsgi.mule_reload_mercy, 0},\n\t{\"exit-on-reload\", no_argument, 0, \"force exit even if a reload is requested\", uwsgi_opt_true, &uwsgi.exit_on_reload, 0},\n\t{\"die-on-term\", no_argument, 0, \"exit instead of brutal reload on SIGTERM\", uwsgi_opt_true, &uwsgi.die_on_term, 0},\n\t{\"force-gateway\", no_argument, 0, \"force the spawn of the first registered gateway without a master\", uwsgi_opt_true, &uwsgi.force_gateway, 0},\n\t{\"help\", no_argument, 'h', \"show this help\", uwsgi_help, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"usage\", no_argument, 'h', \"show this help\", uwsgi_help, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"print-sym\", required_argument, 0, \"print content of the specified binary symbol\", uwsgi_print_sym, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"print-symbol\", required_argument, 0, \"print content of the specified binary symbol\", uwsgi_print_sym, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"reaper\", no_argument, 'r', \"call waitpid(-1,...) after each request to get rid of zombies\", uwsgi_opt_true, &uwsgi.reaper, 0},\n\t{\"max-requests\", required_argument, 'R', \"reload workers after the specified amount of managed requests\", uwsgi_opt_set_64bit, &uwsgi.max_requests, 0},\n\t{\"min-worker-lifetime\", required_argument, 0, \"number of seconds worker must run before being reloaded (default is 60)\", uwsgi_opt_set_64bit, &uwsgi.min_worker_lifetime, 0},\n\t{\"max-worker-lifetime\", required_argument, 0, \"reload workers after the specified amount of seconds (default is disabled)\", uwsgi_opt_set_64bit, &uwsgi.max_worker_lifetime, 0},\n\n\t{\"socket-timeout\", required_argument, 'z', \"set internal sockets timeout\", uwsgi_opt_set_int, &uwsgi.socket_timeout, 0},\n\t{\"no-fd-passing\", no_argument, 0, \"disable file descriptor passing\", uwsgi_opt_true, &uwsgi.no_fd_passing, 0},\n\t{\"locks\", required_argument, 0, \"create the specified number of shared locks\", uwsgi_opt_set_int, &uwsgi.locks, 0},\n\t{\"lock-engine\", required_argument, 0, \"set the lock engine\", uwsgi_opt_set_str, &uwsgi.lock_engine, 0},\n\t{\"ftok\", required_argument, 0, \"set the ipcsem key via ftok() for avoiding duplicates\", uwsgi_opt_set_str, &uwsgi.ftok, 0},\n\t{\"persistent-ipcsem\", no_argument, 0, \"do not remove ipcsem's on shutdown\", uwsgi_opt_true, &uwsgi.persistent_ipcsem, 0},\n\t{\"sharedarea\", required_argument, 'A', \"create a raw shared memory area of specified pages (note: it supports keyval too)\", uwsgi_opt_add_string_list, &uwsgi.sharedareas_list, 0},\n\n\t{\"safe-fd\", required_argument, 0, \"do not close the specified file descriptor\", uwsgi_opt_safe_fd, NULL, 0},\n\t{\"fd-safe\", required_argument, 0, \"do not close the specified file descriptor\", uwsgi_opt_safe_fd, NULL, 0},\n\n\t{\"cache\", required_argument, 0, \"create a shared cache containing given elements\", uwsgi_opt_set_64bit, &uwsgi.cache_max_items, 0},\n\t{\"cache-blocksize\", required_argument, 0, \"set cache blocksize\", uwsgi_opt_set_64bit, &uwsgi.cache_blocksize, 0},\n\t{\"cache-store\", required_argument, 0, \"enable persistent cache to disk\", uwsgi_opt_set_str, &uwsgi.cache_store, UWSGI_OPT_MASTER},\n\t{\"cache-store-sync\", required_argument, 0, \"set frequency of sync for persistent cache\", uwsgi_opt_set_int, &uwsgi.cache_store_sync, 0},\n\t{\"cache-no-expire\", no_argument, 0, \"disable auto sweep of expired items\", uwsgi_opt_true, &uwsgi.cache_no_expire, 0},\n\t{\"cache-expire-freq\", required_argument, 0, \"set the frequency of cache sweeper scans (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.cache_expire_freq, 0},\n\t{\"cache-report-freed-items\", no_argument, 0, \"constantly report the cache item freed by the sweeper (use only for debug)\", uwsgi_opt_true, &uwsgi.cache_report_freed_items, 0},\n\t{\"cache-udp-server\", required_argument, 0, \"bind the cache udp server (used only for set/update/delete) to the specified socket\", uwsgi_opt_add_string_list, &uwsgi.cache_udp_server, UWSGI_OPT_MASTER},\n\t{\"cache-udp-node\", required_argument, 0, \"send cache update/deletion to the specified cache udp server\", uwsgi_opt_add_string_list, &uwsgi.cache_udp_node, UWSGI_OPT_MASTER},\n\t{\"cache-sync\", required_argument, 0, \"copy the whole content of another uWSGI cache server on server startup\", uwsgi_opt_set_str, &uwsgi.cache_sync, 0},\n\t{\"cache-use-last-modified\", no_argument, 0, \"update last_modified_at timestamp on every cache item modification (default is disabled)\", uwsgi_opt_true, &uwsgi.cache_use_last_modified, 0},\n\n\t{\"add-cache-item\", required_argument, 0, \"add an item in the cache\", uwsgi_opt_add_string_list, &uwsgi.add_cache_item, 0},\n\t{\"load-file-in-cache\", required_argument, 0, \"load a static file in the cache\", uwsgi_opt_add_string_list, &uwsgi.load_file_in_cache, 0},\n#ifdef UWSGI_ZLIB\n\t{\"load-file-in-cache-gzip\", required_argument, 0, \"load a static file in the cache with gzip compression\", uwsgi_opt_add_string_list, &uwsgi.load_file_in_cache_gzip, 0},\n#endif\n\n\t{\"cache2\", required_argument, 0, \"create a new generation shared cache (keyval syntax)\", uwsgi_opt_add_string_list, &uwsgi.cache2, 0},\n\n\n\t{\"queue\", required_argument, 0, \"enable shared queue\", uwsgi_opt_set_int, &uwsgi.queue_size, 0},\n\t{\"queue-blocksize\", required_argument, 0, \"set queue blocksize\", uwsgi_opt_set_int, &uwsgi.queue_blocksize, 0},\n\t{\"queue-store\", required_argument, 0, \"enable persistent queue to disk\", uwsgi_opt_set_str, &uwsgi.queue_store, UWSGI_OPT_MASTER},\n\t{\"queue-store-sync\", required_argument, 0, \"set frequency of sync for persistent queue\", uwsgi_opt_set_int, &uwsgi.queue_store_sync, 0},\n\n\t{\"spooler\", required_argument, 'Q', \"run a spooler on the specified directory\", uwsgi_opt_add_spooler, NULL, UWSGI_OPT_MASTER},\n\t{\"spooler-external\", required_argument, 0, \"map spoolers requests to a spooler directory managed by an external instance\", uwsgi_opt_add_spooler, (void *) UWSGI_SPOOLER_EXTERNAL, UWSGI_OPT_MASTER},\n\t{\"spooler-ordered\", no_argument, 0, \"try to order the execution of spooler tasks\", uwsgi_opt_true, &uwsgi.spooler_ordered, 0},\n\t{\"spooler-chdir\", required_argument, 0, \"chdir() to specified directory before each spooler task\", uwsgi_opt_set_str, &uwsgi.spooler_chdir, 0},\n\t{\"spooler-processes\", required_argument, 0, \"set the number of processes for spoolers\", uwsgi_opt_set_int, &uwsgi.spooler_numproc, UWSGI_OPT_IMMEDIATE},\n\t{\"spooler-quiet\", no_argument, 0, \"do not be verbose with spooler tasks\", uwsgi_opt_true, &uwsgi.spooler_quiet, 0},\n\t{\"spooler-max-tasks\", required_argument, 0, \"set the maximum number of tasks to run before recycling a spooler\", uwsgi_opt_set_int, &uwsgi.spooler_max_tasks, 0},\n\t{\"spooler-harakiri\", required_argument, 0, \"set harakiri timeout for spooler tasks\", uwsgi_opt_set_int, &uwsgi.harakiri_options.spoolers, 0},\n\t{\"spooler-frequency\", required_argument, 0, \"set spooler frequency\", uwsgi_opt_set_int, &uwsgi.spooler_frequency, 0},\n\t{\"spooler-freq\", required_argument, 0, \"set spooler frequency\", uwsgi_opt_set_int, &uwsgi.spooler_frequency, 0},\n\n\t{\"mule\", optional_argument, 0, \"add a mule\", uwsgi_opt_add_mule, NULL, UWSGI_OPT_MASTER},\n\t{\"mules\", required_argument, 0, \"add the specified number of mules\", uwsgi_opt_add_mules, NULL, UWSGI_OPT_MASTER},\n\t{\"farm\", required_argument, 0, \"add a mule farm\", uwsgi_opt_add_farm, NULL, UWSGI_OPT_MASTER},\n\t{\"mule-msg-size\", optional_argument, 0, \"set mule message buffer size\", uwsgi_opt_set_int, &uwsgi.mule_msg_size, UWSGI_OPT_MASTER},\n\n\t{\"signal\", required_argument, 0, \"send a uwsgi signal to a server\", uwsgi_opt_signal, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"signal-bufsize\", required_argument, 0, \"set buffer size for signal queue\", uwsgi_opt_set_int, &uwsgi.signal_bufsize, 0},\n\t{\"signals-bufsize\", required_argument, 0, \"set buffer size for signal queue\", uwsgi_opt_set_int, &uwsgi.signal_bufsize, 0},\n\n\t{\"signal-timer\", required_argument, 0, \"add a timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.signal_timers, UWSGI_OPT_MASTER},\n\t{\"timer\", required_argument, 0, \"add a timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.signal_timers, UWSGI_OPT_MASTER},\n\n\t{\"signal-rbtimer\", required_argument, 0, \"add a redblack timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.rb_signal_timers, UWSGI_OPT_MASTER},\n\t{\"rbtimer\", required_argument, 0, \"add a redblack timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.rb_signal_timers, UWSGI_OPT_MASTER},\n\n\t{\"rpc-max\", required_argument, 0, \"maximum number of rpc slots (default: 64)\", uwsgi_opt_set_64bit, &uwsgi.rpc_max, 0},\n\n\t{\"disable-logging\", no_argument, 'L', \"disable request logging\", uwsgi_opt_false, &uwsgi.logging_options.enabled, 0},\n\n\t{\"flock\", required_argument, 0, \"lock the specified file before starting, exit if locked\", uwsgi_opt_flock, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"flock-wait\", required_argument, 0, \"lock the specified file before starting, wait if locked\", uwsgi_opt_flock_wait, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"flock2\", required_argument, 0, \"lock the specified file after logging/daemon setup, exit if locked\", uwsgi_opt_set_str, &uwsgi.flock2, UWSGI_OPT_IMMEDIATE},\n\t{\"flock-wait2\", required_argument, 0, \"lock the specified file after logging/daemon setup, wait if locked\", uwsgi_opt_set_str, &uwsgi.flock_wait2, UWSGI_OPT_IMMEDIATE},\n\n\t{\"pidfile\", required_argument, 0, \"create pidfile (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.pidfile, 0},\n\t{\"pidfile2\", required_argument, 0, \"create pidfile (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.pidfile2, 0},\n\t{\"safe-pidfile\", required_argument, 0, \"create safe pidfile (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.safe_pidfile, 0},\n\t{\"safe-pidfile2\", required_argument, 0, \"create safe pidfile (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.safe_pidfile2, 0},\n\t{\"chroot\", required_argument, 0, \"chroot() to the specified directory\", uwsgi_opt_set_str, &uwsgi.chroot, 0},\n#ifdef __linux__\n\t{\"pivot-root\", required_argument, 0, \"pivot_root() to the specified directories (new_root and put_old must be separated with a space)\", uwsgi_opt_set_str, &uwsgi.pivot_root, 0},\n\t{\"pivot_root\", required_argument, 0, \"pivot_root() to the specified directories (new_root and put_old must be separated with a space)\", uwsgi_opt_set_str, &uwsgi.pivot_root, 0},\n#endif\n\n\t{\"uid\", required_argument, 0, \"setuid to the specified user/uid\", uwsgi_opt_set_uid, NULL, 0},\n\t{\"gid\", required_argument, 0, \"setgid to the specified group/gid\", uwsgi_opt_set_gid, NULL, 0},\n\t{\"add-gid\", required_argument, 0, \"add the specified group id to the process credentials\", uwsgi_opt_add_string_list, &uwsgi.additional_gids, 0},\n\t{\"immediate-uid\", required_argument, 0, \"setuid to the specified user/uid IMMEDIATELY\", uwsgi_opt_set_immediate_uid, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"immediate-gid\", required_argument, 0, \"setgid to the specified group/gid IMMEDIATELY\", uwsgi_opt_set_immediate_gid, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"no-initgroups\", no_argument, 0, \"disable additional groups set via initgroups()\", uwsgi_opt_true, &uwsgi.no_initgroups, 0},\n#ifdef UWSGI_CAP\n\t{\"cap\", required_argument, 0, \"set process capability\", uwsgi_opt_set_cap, NULL, 0},\n#endif\n#ifdef __linux__\n\t{\"unshare\", required_argument, 0, \"unshare() part of the processes and put it in a new namespace\", uwsgi_opt_set_unshare, &uwsgi.unshare, 0},\n\t{\"unshare2\", required_argument, 0, \"unshare() part of the processes and put it in a new namespace after rootfs change\", uwsgi_opt_set_unshare, &uwsgi.unshare2, 0},\n\t{\"setns-socket\", required_argument, 0, \"expose a unix socket returning namespace fds from /proc/self/ns\", uwsgi_opt_set_str, &uwsgi.setns_socket, UWSGI_OPT_MASTER},\n\t{\"setns-socket-skip\", required_argument, 0, \"skip the specified entry when sending setns file descriptors\", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},\n\t{\"setns-skip\", required_argument, 0, \"skip the specified entry when sending setns file descriptors\", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},\n\t{\"setns\", required_argument, 0, \"join a namespace created by an external uWSGI instance\", uwsgi_opt_set_str, &uwsgi.setns, 0},\n\t{\"setns-preopen\", no_argument, 0, \"open /proc/self/ns as soon as possible and cache fds\", uwsgi_opt_true, &uwsgi.setns_preopen, 0},\n#endif\n\t{\"jailed\", no_argument, 0, \"mark the instance as jailed (force the execution of post_jail hooks)\", uwsgi_opt_true, &uwsgi.jailed, 0},\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\t{\"jail\", required_argument, 0, \"put the instance in a FreeBSD jail\", uwsgi_opt_set_str, &uwsgi.jail, 0},\n\t{\"jail-ip4\", required_argument, 0, \"add an ipv4 address to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail_ip4, 0},\n\t{\"jail-ip6\", required_argument, 0, \"add an ipv6 address to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail_ip6, 0},\n\t{\"jidfile\", required_argument, 0, \"save the jid of a FreeBSD jail in the specified file\", uwsgi_opt_set_str, &uwsgi.jidfile, 0},\n\t{\"jid-file\", required_argument, 0, \"save the jid of a FreeBSD jail in the specified file\", uwsgi_opt_set_str, &uwsgi.jidfile, 0},\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n\t{\"jail2\", required_argument, 0, \"add an option to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail2, 0},\n\t{\"libjail\", required_argument, 0, \"add an option to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail2, 0},\n\t{\"jail-attach\", required_argument, 0, \"attach to the FreeBSD jail\", uwsgi_opt_set_str, &uwsgi.jail_attach, 0},\n#endif\n#endif\n\t{\"refork\", no_argument, 0, \"fork() again after privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork, 0},\n\t{\"re-fork\", no_argument, 0, \"fork() again after privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork, 0},\n\t{\"refork-as-root\", no_argument, 0, \"fork() again before privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_as_root, 0},\n\t{\"re-fork-as-root\", no_argument, 0, \"fork() again before privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_as_root, 0},\n\t{\"refork-post-jail\", no_argument, 0, \"fork() again after jailing. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_post_jail, 0},\n\t{\"re-fork-post-jail\", no_argument, 0, \"fork() again after jailing. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_post_jail, 0},\n\n\t{\"hook-asap\", required_argument, 0, \"run the specified hook as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.hook_asap, 0},\n\t{\"hook-pre-jail\", required_argument, 0, \"run the specified hook before jailing\", uwsgi_opt_add_string_list, &uwsgi.hook_pre_jail, 0},\n        {\"hook-post-jail\", required_argument, 0, \"run the specified hook after jailing\", uwsgi_opt_add_string_list, &uwsgi.hook_post_jail, 0},\n        {\"hook-in-jail\", required_argument, 0, \"run the specified hook in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.hook_in_jail, 0},\n        {\"hook-as-root\", required_argument, 0, \"run the specified hook before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.hook_as_root, 0},\n        {\"hook-as-user\", required_argument, 0, \"run the specified hook after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.hook_as_user, 0},\n        {\"hook-as-user-atexit\", required_argument, 0, \"run the specified hook before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.hook_as_user_atexit, 0},\n        {\"hook-pre-app\", required_argument, 0, \"run the specified hook before app loading\", uwsgi_opt_add_string_list, &uwsgi.hook_pre_app, 0},\n        {\"hook-post-app\", required_argument, 0, \"run the specified hook after app loading\", uwsgi_opt_add_string_list, &uwsgi.hook_post_app, 0},\n\t{\"hook-post-fork\", required_argument, 0, \"run the specified hook after each fork\", uwsgi_opt_add_string_list, &uwsgi.hook_post_fork, 0},\n        {\"hook-accepting\", required_argument, 0, \"run the specified hook after each worker enter the accepting phase\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting, 0},\n        {\"hook-accepting1\", required_argument, 0, \"run the specified hook after the first worker enters the accepting phase\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting1, 0},\n        {\"hook-accepting-once\", required_argument, 0, \"run the specified hook after each worker enter the accepting phase (once per-instance)\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting_once, 0},\n        {\"hook-accepting1-once\", required_argument, 0, \"run the specified hook after the first worker enters the accepting phase (once per instance)\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting1_once, 0},\n\n        {\"hook-master-start\", required_argument, 0, \"run the specified hook when the Master starts\", uwsgi_opt_add_string_list, &uwsgi.hook_master_start, 0},\n\n        {\"hook-touch\", required_argument, 0, \"run the specified hook when the specified file is touched (syntax: <file> <action>)\", uwsgi_opt_add_string_list, &uwsgi.hook_touch, 0},\n\n        {\"hook-emperor-start\", required_argument, 0, \"run the specified hook when the Emperor starts\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_start, 0},\n        {\"hook-emperor-stop\", required_argument, 0, \"run the specified hook when the Emperor send a stop message\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_stop, 0},\n        {\"hook-emperor-reload\", required_argument, 0, \"run the specified hook when the Emperor send a reload message\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_reload, 0},\n        {\"hook-emperor-lost\", required_argument, 0, \"run the specified hook when the Emperor connection is lost\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_lost, 0},\n\n        {\"hook-as-vassal\", required_argument, 0, \"run the specified hook before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal, 0},\n        {\"hook-as-emperor\", required_argument, 0, \"run the specified hook in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor, 0},\n\n        {\"hook-as-mule\", required_argument, 0, \"run the specified hook in each mule\", uwsgi_opt_add_string_list, &uwsgi.hook_as_mule, 0},\n\n        {\"hook-as-gateway\", required_argument, 0, \"run the specified hook in each gateway\", uwsgi_opt_add_string_list, &uwsgi.hook_as_gateway, 0},\n\n        {\"after-request-hook\", required_argument, 0, \"run the specified function/symbol after each request\", uwsgi_opt_add_string_list, &uwsgi.after_request_hooks, 0},\n        {\"after-request-call\", required_argument, 0, \"run the specified function/symbol after each request\", uwsgi_opt_add_string_list, &uwsgi.after_request_hooks, 0},\n\n\t{\"exec-asap\", required_argument, 0, \"run the specified command as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.exec_asap, 0},\n\t{\"exec-pre-jail\", required_argument, 0, \"run the specified command before jailing\", uwsgi_opt_add_string_list, &uwsgi.exec_pre_jail, 0},\n\t{\"exec-post-jail\", required_argument, 0, \"run the specified command after jailing\", uwsgi_opt_add_string_list, &uwsgi.exec_post_jail, 0},\n\t{\"exec-in-jail\", required_argument, 0, \"run the specified command in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.exec_in_jail, 0},\n\t{\"exec-as-root\", required_argument, 0, \"run the specified command before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.exec_as_root, 0},\n\t{\"exec-as-user\", required_argument, 0, \"run the specified command after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.exec_as_user, 0},\n\t{\"exec-as-user-atexit\", required_argument, 0, \"run the specified command before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.exec_as_user_atexit, 0},\n\t{\"exec-pre-app\", required_argument, 0, \"run the specified command before app loading\", uwsgi_opt_add_string_list, &uwsgi.exec_pre_app, 0},\n\t{\"exec-post-app\", required_argument, 0, \"run the specified command after app loading\", uwsgi_opt_add_string_list, &uwsgi.exec_post_app, 0},\n\n\t{\"exec-as-vassal\", required_argument, 0, \"run the specified command before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.exec_as_vassal, 0},\n\t{\"exec-as-emperor\", required_argument, 0, \"run the specified command in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.exec_as_emperor, 0},\n\n\t{\"mount-asap\", required_argument, 0, \"mount filesystem as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.mount_asap, 0},\n\t{\"mount-pre-jail\", required_argument, 0, \"mount filesystem before jailing\", uwsgi_opt_add_string_list, &uwsgi.mount_pre_jail, 0},\n        {\"mount-post-jail\", required_argument, 0, \"mount filesystem after jailing\", uwsgi_opt_add_string_list, &uwsgi.mount_post_jail, 0},\n        {\"mount-in-jail\", required_argument, 0, \"mount filesystem in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.mount_in_jail, 0},\n        {\"mount-as-root\", required_argument, 0, \"mount filesystem before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.mount_as_root, 0},\n\n        {\"mount-as-vassal\", required_argument, 0, \"mount filesystem before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.mount_as_vassal, 0},\n        {\"mount-as-emperor\", required_argument, 0, \"mount filesystem in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.mount_as_emperor, 0},\n\n\t{\"umount-asap\", required_argument, 0, \"unmount filesystem as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.umount_asap, 0},\n\t{\"umount-pre-jail\", required_argument, 0, \"unmount filesystem before jailing\", uwsgi_opt_add_string_list, &uwsgi.umount_pre_jail, 0},\n        {\"umount-post-jail\", required_argument, 0, \"unmount filesystem after jailing\", uwsgi_opt_add_string_list, &uwsgi.umount_post_jail, 0},\n        {\"umount-in-jail\", required_argument, 0, \"unmount filesystem in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.umount_in_jail, 0},\n        {\"umount-as-root\", required_argument, 0, \"unmount filesystem before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.umount_as_root, 0},\n\n        {\"umount-as-vassal\", required_argument, 0, \"unmount filesystem before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.umount_as_vassal, 0},\n        {\"umount-as-emperor\", required_argument, 0, \"unmount filesystem in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.umount_as_emperor, 0},\n\n\t{\"wait-for-interface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-for-interface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-interface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-interface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-for-iface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-for-iface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-iface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-iface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-for-fs\", required_argument, 0, \"wait for the specified filesystem item to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-file\", required_argument, 0, \"wait for the specified file to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-dir\", required_argument, 0, \"wait for the specified directory to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-mountpoint\", required_argument, 0, \"wait for the specified mountpoint to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_mountpoint, 0},\n\t{\"wait-for-fs-timeout\", required_argument, 0, \"set the timeout for wait-for-fs/file/dir\", uwsgi_opt_set_int, &uwsgi.wait_for_fs_timeout, 0},\n\n\t{\"wait-for-socket\", required_argument, 0, \"wait for the specified socket to be ready before loading apps\", uwsgi_opt_add_string_list, &uwsgi.wait_for_socket, 0},\n\t{\"wait-for-socket-timeout\", required_argument, 0, \"set the timeout for wait-for-socket\", uwsgi_opt_set_int, &uwsgi.wait_for_socket_timeout, 0},\n\n\t{\"call-asap\", required_argument, 0, \"call the specified function as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.call_asap, 0},\n\t{\"call-pre-jail\", required_argument, 0, \"call the specified function before jailing\", uwsgi_opt_add_string_list, &uwsgi.call_pre_jail, 0},\n\t{\"call-post-jail\", required_argument, 0, \"call the specified function after jailing\", uwsgi_opt_add_string_list, &uwsgi.call_post_jail, 0},\n\t{\"call-in-jail\", required_argument, 0, \"call the specified function in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.call_in_jail, 0},\n\t{\"call-as-root\", required_argument, 0, \"call the specified function before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.call_as_root, 0},\n\t{\"call-as-user\", required_argument, 0, \"call the specified function after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.call_as_user, 0},\n\t{\"call-as-user-atexit\", required_argument, 0, \"call the specified function before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.call_as_user_atexit, 0},\n\t{\"call-pre-app\", required_argument, 0, \"call the specified function before app loading\", uwsgi_opt_add_string_list, &uwsgi.call_pre_app, 0},\n\t{\"call-post-app\", required_argument, 0, \"call the specified function after app loading\", uwsgi_opt_add_string_list, &uwsgi.call_post_app, 0},\n\n\t{\"call-as-vassal\", required_argument, 0, \"call the specified function() before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal, 0},\n\t{\"call-as-vassal1\", required_argument, 0, \"call the specified function(char *) before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal1, 0},\n\t{\"call-as-vassal3\", required_argument, 0, \"call the specified function(char *, uid_t, gid_t) before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal3, 0},\n\n\t{\"call-as-emperor\", required_argument, 0, \"call the specified function() in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor, 0},\n\t{\"call-as-emperor1\", required_argument, 0, \"call the specified function(char *) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor1, 0},\n\t{\"call-as-emperor2\", required_argument, 0, \"call the specified function(char *, pid_t) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor2, 0},\n\t{\"call-as-emperor4\", required_argument, 0, \"call the specified function(char *, pid_t, uid_t, gid_t) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor4, 0},\n\n\n\n\t{\"ini\", required_argument, 0, \"load config from ini file\", uwsgi_opt_load_ini, NULL, UWSGI_OPT_IMMEDIATE},\n#ifdef UWSGI_YAML\n\t{\"yaml\", required_argument, 'y', \"load config from yaml file\", uwsgi_opt_load_yml, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"yml\", required_argument, 'y', \"load config from yaml file\", uwsgi_opt_load_yml, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n#ifdef UWSGI_JSON\n\t{\"json\", required_argument, 'j', \"load config from json file\", uwsgi_opt_load_json, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"js\", required_argument, 'j', \"load config from json file\", uwsgi_opt_load_json, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"weight\", required_argument, 0, \"weight of the instance (used by clustering/lb/subscriptions)\", uwsgi_opt_set_64bit, &uwsgi.weight, 0},\n\t{\"auto-weight\", required_argument, 0, \"set weight of the instance (used by clustering/lb/subscriptions) automatically\", uwsgi_opt_true, &uwsgi.auto_weight, 0},\n\t{\"no-server\", no_argument, 0, \"force no-server mode\", uwsgi_opt_true, &uwsgi.no_server, 0},\n\t{\"command-mode\", no_argument, 0, \"force command mode\", uwsgi_opt_true, &uwsgi.command_mode, UWSGI_OPT_IMMEDIATE},\n\t{\"no-defer-accept\", no_argument, 0, \"disable deferred-accept on sockets\", uwsgi_opt_true, &uwsgi.no_defer_accept, 0},\n\t{\"tcp-nodelay\", no_argument, 0, \"enable TCP NODELAY on each request\", uwsgi_opt_true, &uwsgi.tcp_nodelay, 0},\n\t{\"so-keepalive\", no_argument, 0, \"enable TCP KEEPALIVEs\", uwsgi_opt_true, &uwsgi.so_keepalive, 0},\n\t{\"so-send-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-send-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"so-write-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-write-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-sndbuf\", required_argument, 0, \"set SO_SNDBUF\", uwsgi_opt_set_64bit, &uwsgi.so_sndbuf, 0},\n\t{\"socket-rcvbuf\", required_argument, 0, \"set SO_RCVBUF\", uwsgi_opt_set_64bit, &uwsgi.so_rcvbuf, 0},\n\t{\"shutdown-sockets\", no_argument, 0, \"force calling shutdown() in addition to close() when sockets are destroyed\", uwsgi_opt_true, &uwsgi.shutdown_sockets, 0},\n\t{\"limit-as\", required_argument, 0, \"limit processes address space/vsz\", uwsgi_opt_set_megabytes, &uwsgi.rl.rlim_max, 0},\n\t{\"limit-nproc\", required_argument, 0, \"limit the number of spawnable processes\", uwsgi_opt_set_int, &uwsgi.rl_nproc.rlim_max, 0},\n\t{\"reload-on-as\", required_argument, 0, \"reload if address space is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.reload_on_as, UWSGI_OPT_MEMORY},\n\t{\"reload-on-rss\", required_argument, 0, \"reload if rss memory is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.reload_on_rss, UWSGI_OPT_MEMORY},\n\t{\"evil-reload-on-as\", required_argument, 0, \"force the master to reload a worker if its address space is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.evil_reload_on_as, UWSGI_OPT_MASTER | UWSGI_OPT_MEMORY},\n\t{\"evil-reload-on-rss\", required_argument, 0, \"force the master to reload a worker if its rss memory is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.evil_reload_on_rss, UWSGI_OPT_MASTER | UWSGI_OPT_MEMORY},\n\t{\"mem-collector-freq\", required_argument, 0, \"set the memory collector frequency when evil reloads are in place\", uwsgi_opt_set_int, &uwsgi.mem_collector_freq, 0},\n\n\t{\"reload-on-fd\", required_argument, 0, \"reload if the specified file descriptor is ready\", uwsgi_opt_add_string_list, &uwsgi.reload_on_fd, UWSGI_OPT_MASTER},\n\t{\"brutal-reload-on-fd\", required_argument, 0, \"brutal reload if the specified file descriptor is ready\", uwsgi_opt_add_string_list, &uwsgi.brutal_reload_on_fd, UWSGI_OPT_MASTER},\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\t{\"ksm\", optional_argument, 0, \"enable Linux KSM\", uwsgi_opt_set_int, &uwsgi.linux_ksm, 0},\n#endif\n#endif\n#ifdef UWSGI_PCRE\n\t{\"pcre-jit\", no_argument, 0, \"enable pcre jit (if available)\", uwsgi_opt_pcre_jit, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"never-swap\", no_argument, 0, \"lock all memory pages avoiding swapping\", uwsgi_opt_true, &uwsgi.never_swap, 0},\n\t{\"touch-reload\", required_argument, 0, \"reload uWSGI if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_reload, UWSGI_OPT_MASTER},\n\t{\"touch-workers-reload\", required_argument, 0, \"trigger reload of (only) workers if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_workers_reload, UWSGI_OPT_MASTER},\n\t{\"touch-mules-reload\", required_argument, 0, \"reload mules if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_mules_reload, UWSGI_OPT_MASTER},\n\t{\"touch-spoolers-reload\", required_argument, 0, \"reload spoolers if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_spoolers_reload, UWSGI_OPT_MASTER},\n\t{\"touch-chain-reload\", required_argument, 0, \"trigger chain reload if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_chain_reload, UWSGI_OPT_MASTER},\n\t{\"touch-logrotate\", required_argument, 0, \"trigger logrotation if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_logrotate, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"touch-logreopen\", required_argument, 0, \"trigger log reopen if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_logreopen, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"touch-exec\", required_argument, 0, \"run command when the specified file is modified/touched (syntax: file command)\", uwsgi_opt_add_string_list, &uwsgi.touch_exec, UWSGI_OPT_MASTER},\n\t{\"touch-signal\", required_argument, 0, \"signal when the specified file is modified/touched (syntax: file signal)\", uwsgi_opt_add_string_list, &uwsgi.touch_signal, UWSGI_OPT_MASTER},\n\n\t{\"fs-reload\", required_argument, 0, \"graceful reload when the specified filesystem object is modified\", uwsgi_opt_add_string_list, &uwsgi.fs_reload, UWSGI_OPT_MASTER},\n\t{\"fs-brutal-reload\", required_argument, 0, \"brutal reload when the specified filesystem object is modified\", uwsgi_opt_add_string_list, &uwsgi.fs_brutal_reload, UWSGI_OPT_MASTER},\n\t{\"fs-signal\", required_argument, 0, \"raise a uwsgi signal when the specified filesystem object is modified (syntax: file signal)\", uwsgi_opt_add_string_list, &uwsgi.fs_signal, UWSGI_OPT_MASTER},\n\n\t{\"check-mountpoint\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"mountpoint-check\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"check-mount\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"mount-check\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\n\t{\"propagate-touch\", no_argument, 0, \"over-engineering option for system with flaky signal management\", uwsgi_opt_true, &uwsgi.propagate_touch, 0},\n\t{\"limit-post\", required_argument, 0, \"limit request body\", uwsgi_opt_set_64bit, &uwsgi.limit_post, 0},\n\t{\"no-orphans\", no_argument, 0, \"automatically kill workers if master dies (can be dangerous for availability)\", uwsgi_opt_true, &uwsgi.no_orphans, 0},\n\t{\"prio\", required_argument, 0, \"set processes/threads priority\", uwsgi_opt_set_rawint, &uwsgi.prio, 0},\n\t{\"cpu-affinity\", required_argument, 0, \"set cpu affinity\", uwsgi_opt_set_int, &uwsgi.cpu_affinity, 0},\n\t{\"post-buffering\", required_argument, 0, \"set size in bytes after which will buffer to disk instead of memory\", uwsgi_opt_set_64bit, &uwsgi.post_buffering, 0},\n\t{\"post-buffering-bufsize\", required_argument, 0, \"set buffer size for read() in post buffering mode\", uwsgi_opt_set_64bit, &uwsgi.post_buffering_bufsize, 0},\n\t{\"body-read-warning\", required_argument, 0, \"set the amount of allowed memory allocation (in megabytes) for request body before starting printing a warning\", uwsgi_opt_set_64bit, &uwsgi.body_read_warning, 0},\n\t{\"upload-progress\", required_argument, 0, \"enable creation of .json files in the specified directory during a file upload\", uwsgi_opt_set_str, &uwsgi.upload_progress, 0},\n\t{\"no-default-app\", no_argument, 0, \"do not fallback to default app\", uwsgi_opt_true, &uwsgi.no_default_app, 0},\n\t{\"manage-script-name\", no_argument, 0, \"automatically rewrite SCRIPT_NAME and PATH_INFO\", uwsgi_opt_true, &uwsgi.manage_script_name, 0},\n\t{\"ignore-script-name\", no_argument, 0, \"ignore SCRIPT_NAME\", uwsgi_opt_true, &uwsgi.ignore_script_name, 0},\n\n\t{\"catch-exceptions\", no_argument, 0, \"report exception as http output (discouraged, use only for testing)\", uwsgi_opt_true, &uwsgi.catch_exceptions, 0},\n\t{\"reload-on-exception\", no_argument, 0, \"reload a worker when an exception is raised\", uwsgi_opt_true, &uwsgi.reload_on_exception, 0},\n\t{\"reload-on-exception-type\", required_argument, 0, \"reload a worker when a specific exception type is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_type, 0},\n\t{\"reload-on-exception-value\", required_argument, 0, \"reload a worker when a specific exception value is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_value, 0},\n\t{\"reload-on-exception-repr\", required_argument, 0, \"reload a worker when a specific exception type+value (language-specific) is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_repr, 0},\n\t{\"exception-handler\", required_argument, 0, \"add an exception handler\", uwsgi_opt_add_string_list, &uwsgi.exception_handlers_instance, UWSGI_OPT_MASTER},\n\n\t{\"enable-metrics\", no_argument, 0, \"enable metrics subsystem\", uwsgi_opt_true, &uwsgi.has_metrics, UWSGI_OPT_MASTER},\n\t{\"metric\", required_argument, 0, \"add a custom metric\", uwsgi_opt_add_string_list, &uwsgi.additional_metrics, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-threshold\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-alarm\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"alarm-metric\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-dir\", required_argument, 0, \"export metrics as text files to the specified directory\", uwsgi_opt_set_str, &uwsgi.metrics_dir, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-dir-restore\", no_argument, 0, \"restore last value taken from the metrics dir\", uwsgi_opt_true, &uwsgi.metrics_dir_restore, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-dir\", required_argument, 0, \"export metrics as text files to the specified directory\", uwsgi_opt_set_str, &uwsgi.metrics_dir, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-dir-restore\", no_argument, 0, \"restore last value taken from the metrics dir\", uwsgi_opt_true, &uwsgi.metrics_dir_restore, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-no-cores\", no_argument, 0, \"disable generation of cores-related metrics\", uwsgi_opt_true, &uwsgi.metrics_no_cores, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\n\t{\"udp\", required_argument, 0, \"run the udp server on the specified address\", uwsgi_opt_set_str, &uwsgi.udp_socket, UWSGI_OPT_MASTER},\n\t{\"stats\", required_argument, 0, \"enable the stats server on the specified address\", uwsgi_opt_set_str, &uwsgi.stats, UWSGI_OPT_MASTER},\n\t{\"stats-server\", required_argument, 0, \"enable the stats server on the specified address\", uwsgi_opt_set_str, &uwsgi.stats, UWSGI_OPT_MASTER},\n\t{\"stats-http\", no_argument, 0, \"prefix stats server json output with http headers\", uwsgi_opt_true, &uwsgi.stats_http, UWSGI_OPT_MASTER},\n\t{\"stats-minified\", no_argument, 0, \"minify statistics json output\", uwsgi_opt_true, &uwsgi.stats_minified, UWSGI_OPT_MASTER},\n\t{\"stats-min\", no_argument, 0, \"minify statistics json output\", uwsgi_opt_true, &uwsgi.stats_minified, UWSGI_OPT_MASTER},\n\t{\"stats-push\", required_argument, 0, \"push the stats json to the specified destination\", uwsgi_opt_add_string_list, &uwsgi.requested_stats_pushers, UWSGI_OPT_MASTER|UWSGI_OPT_METRICS},\n\t{\"stats-pusher-default-freq\", required_argument, 0, \"set the default frequency of stats pushers\", uwsgi_opt_set_int, &uwsgi.stats_pusher_default_freq, UWSGI_OPT_MASTER},\n\t{\"stats-pushers-default-freq\", required_argument, 0, \"set the default frequency of stats pushers\", uwsgi_opt_set_int, &uwsgi.stats_pusher_default_freq, UWSGI_OPT_MASTER},\n\t{\"stats-no-cores\", no_argument, 0, \"disable generation of cores-related stats\", uwsgi_opt_true, &uwsgi.stats_no_cores, UWSGI_OPT_MASTER},\n\t{\"stats-no-metrics\", no_argument, 0, \"do not include metrics in stats output\", uwsgi_opt_true, &uwsgi.stats_no_metrics, UWSGI_OPT_MASTER},\n\t{\"multicast\", required_argument, 0, \"subscribe to specified multicast group\", uwsgi_opt_set_str, &uwsgi.multicast_group, UWSGI_OPT_MASTER},\n\t{\"multicast-ttl\", required_argument, 0, \"set multicast ttl\", uwsgi_opt_set_int, &uwsgi.multicast_ttl, 0},\n\t{\"multicast-loop\", required_argument, 0, \"set multicast loop (default 1)\", uwsgi_opt_set_int, &uwsgi.multicast_loop, 0},\n\n\t{\"master-fifo\", required_argument, 0, \"enable the master fifo\", uwsgi_opt_add_string_list, &uwsgi.master_fifo, UWSGI_OPT_MASTER},\n\n\t{\"notify-socket\", required_argument, 0, \"enable the notification socket\", uwsgi_opt_set_str, &uwsgi.notify_socket, UWSGI_OPT_MASTER},\n\t{\"subscription-notify-socket\", required_argument, 0, \"set the notification socket for subscriptions\", uwsgi_opt_set_str, &uwsgi.subscription_notify_socket, UWSGI_OPT_MASTER},\n\n#ifdef UWSGI_SSL\n\t{\"legion\", required_argument, 0, \"became a member of a legion\", uwsgi_opt_legion, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-mcast\", required_argument, 0, \"became a member of a legion (shortcut for multicast)\", uwsgi_opt_legion_mcast, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node\", required_argument, 0, \"add a node to a legion\", uwsgi_opt_legion_node, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-freq\", required_argument, 0, \"set the frequency of legion packets\", uwsgi_opt_set_int, &uwsgi.legion_freq, UWSGI_OPT_MASTER},\n\t{\"legion-tolerance\", required_argument, 0, \"set the tolerance of legion subsystem\", uwsgi_opt_set_int, &uwsgi.legion_tolerance, UWSGI_OPT_MASTER},\n\t{\"legion-death-on-lord-error\", required_argument, 0, \"declare itself as a dead node for the specified amount of seconds if one of the lord hooks fails\", uwsgi_opt_set_int, &uwsgi.legion_death_on_lord_error, UWSGI_OPT_MASTER},\n\t{\"legion-skew-tolerance\", required_argument, 0, \"set the clock skew tolerance of legion subsystem (default 30 seconds)\", uwsgi_opt_set_int, &uwsgi.legion_skew_tolerance, UWSGI_OPT_MASTER},\n\t{\"legion-lord\", required_argument, 0, \"action to call on Lord election\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-unlord\", required_argument, 0, \"action to call on Lord dismiss\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-setup\", required_argument, 0, \"action to call on legion setup\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-death\", required_argument, 0, \"action to call on legion death (shutdown of the instance)\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-join\", required_argument, 0, \"action to call on legion join (first time quorum is reached)\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node-joined\", required_argument, 0, \"action to call on new node joining legion\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node-left\", required_argument, 0, \"action to call node leaving legion\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-quorum\", required_argument, 0, \"set the quorum of a legion\", uwsgi_opt_legion_quorum, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-scroll\", required_argument, 0, \"set the scroll of a legion\", uwsgi_opt_legion_scroll, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-scroll-max-size\", required_argument, 0, \"set max size of legion scroll buffer\", uwsgi_opt_set_16bit, &uwsgi.legion_scroll_max_size, 0},\n\t{\"legion-scroll-list-max-size\", required_argument, 0, \"set max size of legion scroll list buffer\", uwsgi_opt_set_64bit, &uwsgi.legion_scroll_list_max_size, 0},\n\t{\"subscriptions-sign-check\", required_argument, 0, \"set digest algorithm and certificate directory for secured subscription system\", uwsgi_opt_scd, NULL, UWSGI_OPT_MASTER},\n\t{\"subscriptions-sign-check-tolerance\", required_argument, 0, \"set the maximum tolerance (in seconds) of clock skew for secured subscription system\", uwsgi_opt_set_int, &uwsgi.subscriptions_sign_check_tolerance, UWSGI_OPT_MASTER},\n\t{\"subscriptions-sign-skip-uid\", required_argument, 0, \"skip signature check for the specified uid when using unix sockets credentials\", uwsgi_opt_add_string_list, &uwsgi.subscriptions_sign_skip_uid, UWSGI_OPT_MASTER},\n#endif\n\t{\"subscriptions-credentials-check\", required_argument, 0, \"add a directory to search for subscriptions key credentials\", uwsgi_opt_add_string_list, &uwsgi.subscriptions_credentials_check_dir, UWSGI_OPT_MASTER},\n\t{\"subscriptions-use-credentials\", no_argument, 0, \"enable management of SCM_CREDENTIALS in subscriptions UNIX sockets\", uwsgi_opt_true, &uwsgi.subscriptions_use_credentials, 0},\n\t{\"subscription-algo\", required_argument, 0, \"set load balancing algorithm for the subscription system\", uwsgi_opt_ssa, NULL, 0},\n\t{\"subscription-dotsplit\", no_argument, 0, \"try to fallback to the next part (dot based) in subscription key\", uwsgi_opt_true, &uwsgi.subscription_dotsplit, 0},\n\t{\"subscribe-to\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"st\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"subscribe\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"subscribe2\", required_argument, 0, \"subscribe to the specified subscription server using advanced keyval syntax\", uwsgi_opt_add_string_list, &uwsgi.subscriptions2, UWSGI_OPT_MASTER},\n\t{\"subscribe-freq\", required_argument, 0, \"send subscription announce at the specified interval\", uwsgi_opt_set_int, &uwsgi.subscribe_freq, 0},\n\t{\"subscription-tolerance\", required_argument, 0, \"set tolerance for subscription servers\", uwsgi_opt_set_int, &uwsgi.subscription_tolerance, 0},\n\t{\"unsubscribe-on-graceful-reload\", no_argument, 0, \"force unsubscribe request even during graceful reload\", uwsgi_opt_true, &uwsgi.unsubscribe_on_graceful_reload, 0},\n\t{\"start-unsubscribed\", no_argument, 0, \"configure subscriptions but do not send them (useful with master fifo)\", uwsgi_opt_true, &uwsgi.subscriptions_blocked, 0},\n\n\t{\"subscribe-with-modifier1\", required_argument, 0, \"force the specififed modifier1 when subscribing\", uwsgi_opt_set_str, &uwsgi.subscribe_with_modifier1, UWSGI_OPT_MASTER},\n\n\t{\"snmp\", optional_argument, 0, \"enable the embedded snmp server\", uwsgi_opt_snmp, NULL, 0},\n\t{\"snmp-community\", required_argument, 0, \"set the snmp community string\", uwsgi_opt_snmp_community, NULL, 0},\n#ifdef UWSGI_SSL\n\t{\"ssl-verbose\", no_argument, 0, \"be verbose about SSL errors\", uwsgi_opt_true, &uwsgi.ssl_verbose, 0},\n\t{\"ssl-verify-depth\", optional_argument, 0, \"set maximum certificate verification depth\", uwsgi_opt_set_int, &uwsgi.ssl_verify_depth, 0},\n#ifdef UWSGI_SSL_SESSION_CACHE\n\t// force master, as ssl sessions caching initialize locking early\n\t{\"ssl-sessions-use-cache\", optional_argument, 0, \"use uWSGI cache for ssl sessions storage\", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},\n\t{\"ssl-session-use-cache\", optional_argument, 0, \"use uWSGI cache for ssl sessions storage\", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},\n\t{\"ssl-sessions-timeout\", required_argument, 0, \"set SSL sessions timeout (default: 300 seconds)\", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},\n\t{\"ssl-session-timeout\", required_argument, 0, \"set SSL sessions timeout (default: 300 seconds)\", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},\n#endif\n\t{\"sni\", required_argument, 0, \"add an SNI-governed SSL context\", uwsgi_opt_sni, NULL, 0},\n\t{\"sni-dir\", required_argument, 0, \"check for cert/key/client_ca file in the specified directory and create a sni/ssl context on demand\", uwsgi_opt_set_str, &uwsgi.sni_dir, 0},\n\t{\"sni-dir-ciphers\", required_argument, 0, \"set ssl ciphers for sni-dir option\", uwsgi_opt_set_str, &uwsgi.sni_dir_ciphers, 0},\n\t{\"ssl-enable3\", no_argument, 0, \"enable SSLv3 (insecure)\", uwsgi_opt_true, &uwsgi.sslv3, 0},\n\t{\"ssl-enable-sslv3\", no_argument, 0, \"enable SSLv3 (insecure)\", uwsgi_opt_true, &uwsgi.sslv3, 0},\n\t{\"ssl-enable-tlsv1\", no_argument, 0, \"enable TLSv1 (insecure)\", uwsgi_opt_true, &uwsgi.tlsv1, 0},\n\t{\"ssl-option\", no_argument, 0, \"set a raw ssl option (numeric value)\", uwsgi_opt_add_string_list, &uwsgi.ssl_options, 0},\n#ifdef UWSGI_PCRE\n\t{\"sni-regexp\", required_argument, 0, \"add an SNI-governed SSL context (the key is a regexp)\", uwsgi_opt_sni, NULL, 0},\n#endif\n\t{\"ssl-tmp-dir\", required_argument, 0, \"store ssl-related temp files in the specified directory\", uwsgi_opt_set_str, &uwsgi.ssl_tmp_dir, 0},\n#endif\n\t{\"check-interval\", required_argument, 0, \"set the interval (in seconds) of master checks\", uwsgi_opt_set_int, &uwsgi.master_interval, UWSGI_OPT_MASTER},\n\t{\"forkbomb-delay\", required_argument, 0, \"sleep for the specified number of seconds when a forkbomb is detected\", uwsgi_opt_set_int, &uwsgi.forkbomb_delay, UWSGI_OPT_MASTER},\n\t{\"binary-path\", required_argument, 0, \"force binary path\", uwsgi_opt_set_str, &uwsgi.binary_path, 0},\n\t{\"privileged-binary-patch\", required_argument, 0, \"patch the uwsgi binary with a new command (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch, 0},\n\t{\"unprivileged-binary-patch\", required_argument, 0, \"patch the uwsgi binary with a new command (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch, 0},\n\t{\"privileged-binary-patch-arg\", required_argument, 0, \"patch the uwsgi binary with a new command and arguments (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch_arg, 0},\n\t{\"unprivileged-binary-patch-arg\", required_argument, 0, \"patch the uwsgi binary with a new command and arguments (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch_arg, 0},\n\t{\"async\", required_argument, 0, \"enable async mode with specified cores\", uwsgi_opt_set_int, &uwsgi.async, 0},\n\t{\"max-fd\", required_argument, 0, \"set maximum number of file descriptors (requires root privileges)\", uwsgi_opt_set_int, &uwsgi.requested_max_fd, 0},\n\t{\"logto\", required_argument, 0, \"set logfile/udp address\", uwsgi_opt_set_str, &uwsgi.logfile, 0},\n\t{\"logto2\", required_argument, 0, \"log to specified file or udp address after privileges drop\", uwsgi_opt_set_str, &uwsgi.logto2, 0},\n\t{\"log-format\", required_argument, 0, \"set advanced format for request logging\", uwsgi_opt_set_str, &uwsgi.logformat, 0},\n\t{\"logformat\", required_argument, 0, \"set advanced format for request logging\", uwsgi_opt_set_str, &uwsgi.logformat, 0},\n\t{\"logformat-strftime\", no_argument, 0, \"apply strftime to logformat output\", uwsgi_opt_true, &uwsgi.logformat_strftime, 0},\n\t{\"log-format-strftime\", no_argument, 0, \"apply strftime to logformat output\", uwsgi_opt_true, &uwsgi.logformat_strftime, 0},\n\t{\"logfile-chown\", no_argument, 0, \"chown logfiles\", uwsgi_opt_true, &uwsgi.logfile_chown, 0},\n\t{\"logfile-chmod\", required_argument, 0, \"chmod logfiles\", uwsgi_opt_logfile_chmod, NULL, 0},\n\t{\"log-syslog\", optional_argument, 0, \"log to syslog\", uwsgi_opt_set_logger, \"syslog\", UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-socket\", required_argument, 0, \"send logs to the specified socket\", uwsgi_opt_set_logger, \"socket\", UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"req-logger\", required_argument, 0, \"set/append a request logger\", uwsgi_opt_set_req_logger, NULL, UWSGI_OPT_REQ_LOG_MASTER},\n\t{\"logger-req\", required_argument, 0, \"set/append a request logger\", uwsgi_opt_set_req_logger, NULL, UWSGI_OPT_REQ_LOG_MASTER},\n\t{\"logger\", required_argument, 0, \"set/append a logger\", uwsgi_opt_set_logger, NULL, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"logger-list\", no_argument, 0, \"list enabled loggers\", uwsgi_opt_true, &uwsgi.loggers_list, 0},\n\t{\"loggers-list\", no_argument, 0, \"list enabled loggers\", uwsgi_opt_true, &uwsgi.loggers_list, 0},\n\t{\"threaded-logger\", no_argument, 0, \"offload log writing to a thread\", uwsgi_opt_true, &uwsgi.threaded_logger, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\n\n\t{\"log-encoder\", required_argument, 0, \"add an item in the log encoder chain\", uwsgi_opt_add_string_list, &uwsgi.requested_log_encoders, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-req-encoder\", required_argument, 0, \"add an item in the log req encoder chain\", uwsgi_opt_add_string_list, &uwsgi.requested_log_req_encoders, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t\n\n#ifdef UWSGI_PCRE\n\t{\"log-drain\", required_argument, 0, \"drain (do not show) log lines matching the specified regexp\", uwsgi_opt_add_regexp_list, &uwsgi.log_drain_rules, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-filter\", required_argument, 0, \"show only log lines matching the specified regexp\", uwsgi_opt_add_regexp_list, &uwsgi.log_filter_rules, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-route\", required_argument, 0, \"log to the specified named logger if regexp applied on logline matches\", uwsgi_opt_add_regexp_custom_list, &uwsgi.log_route, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-req-route\", required_argument, 0, \"log requests to the specified named logger if regexp applied on logline matches\", uwsgi_opt_add_regexp_custom_list, &uwsgi.log_req_route, UWSGI_OPT_REQ_LOG_MASTER},\n#endif\n\n\t{\"use-abort\", no_argument, 0, \"call abort() on segfault/fpe, could be useful for generating a core dump\", uwsgi_opt_true, &uwsgi.use_abort, 0},\n\n\t{\"alarm\", required_argument, 0, \"create a new alarm, syntax: <alarm> <plugin:args>\", uwsgi_opt_add_string_list, &uwsgi.alarm_list, UWSGI_OPT_MASTER},\n\t{\"alarm-cheap\", required_argument, 0, \"use main alarm thread rather than create dedicated threads for curl-based alarms\", uwsgi_opt_true, &uwsgi.alarm_cheap, 0},\n\t{\"alarm-freq\", required_argument, 0, \"tune the anti-loop alarm system (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.alarm_freq, 0},\n\t{\"alarm-fd\", required_argument, 0, \"raise the specified alarm when an fd is read for read (by default it reads 1 byte, set 8 for eventfd)\", uwsgi_opt_add_string_list, &uwsgi.alarm_fd_list, UWSGI_OPT_MASTER},\n\t{\"alarm-segfault\", required_argument, 0, \"raise the specified alarm when the segmentation fault handler is executed\", uwsgi_opt_add_string_list, &uwsgi.alarm_segfault, UWSGI_OPT_MASTER},\n\t{\"segfault-alarm\", required_argument, 0, \"raise the specified alarm when the segmentation fault handler is executed\", uwsgi_opt_add_string_list, &uwsgi.alarm_segfault, UWSGI_OPT_MASTER},\n\t{\"alarm-backlog\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"backlog-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"lq-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"alarm-lq\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"alarm-listen-queue\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"listen-queue-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n#ifdef UWSGI_PCRE\n\t{\"log-alarm\", required_argument, 0, \"raise the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"alarm-log\", required_argument, 0, \"raise the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"not-log-alarm\", required_argument, 0, \"skip the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list_custom, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"not-alarm-log\", required_argument, 0, \"skip the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list_custom, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n#endif\n\t{\"alarm-list\", no_argument, 0, \"list enabled alarms\", uwsgi_opt_true, &uwsgi.alarms_list, 0},\n\t{\"alarms-list\", no_argument, 0, \"list enabled alarms\", uwsgi_opt_true, &uwsgi.alarms_list, 0},\n\t{\"alarm-msg-size\", required_argument, 0, \"set the max size of an alarm message (default 8192)\", uwsgi_opt_set_64bit, &uwsgi.alarm_msg_size, 0},\n\t{\"log-master\", no_argument, 0, \"delegate logging to master process\", uwsgi_opt_true, &uwsgi.log_master, UWSGI_OPT_MASTER|UWSGI_OPT_LOG_MASTER},\n\t{\"log-master-bufsize\", required_argument, 0, \"set the buffer size for the master logger. bigger log messages will be truncated\", uwsgi_opt_set_64bit, &uwsgi.log_master_bufsize, 0},\n\t{\"log-master-stream\", no_argument, 0, \"create the master logpipe as SOCK_STREAM\", uwsgi_opt_true, &uwsgi.log_master_stream, 0},\n\t{\"log-master-req-stream\", no_argument, 0, \"create the master requests logpipe as SOCK_STREAM\", uwsgi_opt_true, &uwsgi.log_master_req_stream, 0},\n\t{\"log-reopen\", no_argument, 0, \"reopen log after reload\", uwsgi_opt_true, &uwsgi.log_reopen, 0},\n\t{\"log-truncate\", no_argument, 0, \"truncate log on startup\", uwsgi_opt_true, &uwsgi.log_truncate, 0},\n\t{\"log-maxsize\", required_argument, 0, \"set maximum logfile size\", uwsgi_opt_set_64bit, &uwsgi.log_maxsize, UWSGI_OPT_MASTER|UWSGI_OPT_LOG_MASTER},\n\t{\"log-backupname\", required_argument, 0, \"set logfile name after rotation\", uwsgi_opt_set_str, &uwsgi.log_backupname, 0},\n\n\t{\"logdate\", optional_argument, 0, \"prefix logs with date or a strftime string\", uwsgi_opt_log_date, NULL, 0},\n\t{\"log-date\", optional_argument, 0, \"prefix logs with date or a strftime string\", uwsgi_opt_log_date, NULL, 0},\n\t{\"log-prefix\", optional_argument, 0, \"prefix logs with a string\", uwsgi_opt_log_date, NULL, 0},\n\n\t{\"log-zero\", no_argument, 0, \"log responses without body\", uwsgi_opt_true, &uwsgi.logging_options.zero, 0},\n\t{\"log-slow\", required_argument, 0, \"log requests slower than the specified number of milliseconds\", uwsgi_opt_set_int, &uwsgi.logging_options.slow, 0},\n\t{\"log-4xx\", no_argument, 0, \"log requests with a 4xx response\", uwsgi_opt_true, &uwsgi.logging_options._4xx, 0},\n\t{\"log-5xx\", no_argument, 0, \"log requests with a 5xx response\", uwsgi_opt_true, &uwsgi.logging_options._5xx, 0},\n\t{\"log-big\", required_argument, 0, \"log requestes bigger than the specified size\", uwsgi_opt_set_64bit,  &uwsgi.logging_options.big, 0},\n\t{\"log-sendfile\", required_argument, 0, \"log sendfile requests\", uwsgi_opt_true, &uwsgi.logging_options.sendfile, 0},\n\t{\"log-ioerror\", required_argument, 0, \"log requests with io errors\", uwsgi_opt_true, &uwsgi.logging_options.ioerror, 0},\n\t{\"log-micros\", no_argument, 0, \"report response time in microseconds instead of milliseconds\", uwsgi_opt_true, &uwsgi.log_micros, 0},\n\t{\"log-x-forwarded-for\", no_argument, 0, \"use the ip from X-Forwarded-For header instead of REMOTE_ADDR\", uwsgi_opt_true, &uwsgi.logging_options.log_x_forwarded_for, 0},\n\t{\"master-as-root\", no_argument, 0, \"leave master process running as root\", uwsgi_opt_true, &uwsgi.master_as_root, 0},\n\n\t{\"drop-after-init\", no_argument, 0, \"run privileges drop after plugin initialization, superseded by drop-after-apps\", uwsgi_opt_true, &uwsgi.drop_after_init, 0},\n\t{\"drop-after-apps\", no_argument, 0, \"run privileges drop after apps loading, superseded by master-as-root\", uwsgi_opt_true, &uwsgi.drop_after_apps, 0},\n\n\t{\"force-cwd\", required_argument, 0, \"force the initial working directory to the specified value\", uwsgi_opt_set_str, &uwsgi.force_cwd, 0},\n\t{\"binsh\", required_argument, 0, \"override /bin/sh (used by exec hooks, it always fallback to /bin/sh)\", uwsgi_opt_add_string_list, &uwsgi.binsh, 0},\n\t{\"chdir\", required_argument, 0, \"chdir to specified directory before apps loading\", uwsgi_opt_set_str, &uwsgi.chdir, 0},\n\t{\"chdir2\", required_argument, 0, \"chdir to specified directory after apps loading\", uwsgi_opt_set_str, &uwsgi.chdir2, 0},\n\t{\"lazy\", no_argument, 0, \"set lazy mode (load apps in workers instead of master)\", uwsgi_opt_true, &uwsgi.lazy, 0},\n\t{\"lazy-apps\", no_argument, 0, \"load apps in each worker instead of the master\", uwsgi_opt_true, &uwsgi.lazy_apps, 0},\n\t{\"cheap\", no_argument, 0, \"set cheap mode (spawn workers only after the first request)\", uwsgi_opt_true, &uwsgi.status.is_cheap, UWSGI_OPT_MASTER},\n\t{\"cheaper\", required_argument, 0, \"set cheaper mode (adaptive process spawning)\", uwsgi_opt_set_int, &uwsgi.cheaper_count, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-initial\", required_argument, 0, \"set the initial number of processes to spawn in cheaper mode\", uwsgi_opt_set_int, &uwsgi.cheaper_initial, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-algo\", required_argument, 0, \"choose to algorithm used for adaptive process spawning\", uwsgi_opt_set_str, &uwsgi.requested_cheaper_algo, UWSGI_OPT_MASTER},\n\t{\"cheaper-step\", required_argument, 0, \"number of additional processes to spawn at each overload\", uwsgi_opt_set_int, &uwsgi.cheaper_step, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-overload\", required_argument, 0, \"increase workers after specified overload\", uwsgi_opt_set_64bit, &uwsgi.cheaper_overload, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-algo-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-algos-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-rss-limit-soft\", required_argument, 0, \"don't spawn new workers if total resident memory usage of all workers is higher than this limit\", uwsgi_opt_set_64bit, &uwsgi.cheaper_rss_limit_soft, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-rss-limit-hard\", required_argument, 0, \"if total workers resident memory usage is higher try to stop workers\", uwsgi_opt_set_64bit, &uwsgi.cheaper_rss_limit_hard, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"idle\", required_argument, 0, \"set idle mode (put uWSGI in cheap mode after inactivity)\", uwsgi_opt_set_int, &uwsgi.idle, UWSGI_OPT_MASTER},\n\t{\"die-on-idle\", no_argument, 0, \"shutdown uWSGI when idle\", uwsgi_opt_true, &uwsgi.die_on_idle, 0},\n\t{\"mount\", required_argument, 0, \"load application under mountpoint\", uwsgi_opt_add_string_list, &uwsgi.mounts, 0},\n\t{\"worker-mount\", required_argument, 0, \"load application under mountpoint in the specified worker or after workers spawn\", uwsgi_opt_add_string_list, &uwsgi.mounts, 0},\n\n\t{\"threads\", required_argument, 0, \"run each worker in prethreaded mode with the specified number of threads\", uwsgi_opt_set_int, &uwsgi.threads, UWSGI_OPT_THREADS},\n\t{\"thread-stacksize\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"threads-stacksize\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"thread-stack-size\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"threads-stack-size\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\n\t{\"vhost\", no_argument, 0, \"enable virtualhosting mode (based on SERVER_NAME variable)\", uwsgi_opt_true, &uwsgi.vhost, 0},\n\t{\"vhost-host\", no_argument, 0, \"enable virtualhosting mode (based on HTTP_HOST variable)\", uwsgi_opt_true, &uwsgi.vhost_host, UWSGI_OPT_VHOST},\n#ifdef UWSGI_ROUTING\n\t{\"route\", required_argument, 0, \"add a route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"route-host\", required_argument, 0, \"add a route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n\t{\"route-uri\", required_argument, 0, \"add a route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n\t{\"route-qs\", required_argument, 0, \"add a route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n\t{\"route-remote-addr\", required_argument, 0, \"add a route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n\t{\"route-user-agent\", required_argument, 0, \"add a route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n\t{\"route-remote-user\", required_argument, 0, \"add a route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n\t{\"route-referer\", required_argument, 0, \"add a route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n\t{\"route-label\", required_argument, 0, \"add a routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n\t{\"route-if\", required_argument, 0, \"add a route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n\t{\"route-if-not\", required_argument, 0, \"add a route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n\t{\"route-run\", required_argument, 0, \"always run the specified route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\n\n\t{\"final-route\", required_argument, 0, \"add a final route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"final-route-status\", required_argument, 0, \"add a final route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"final-route-host\", required_argument, 0, \"add a final route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"final-route-uri\", required_argument, 0, \"add a final route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"final-route-qs\", required_argument, 0, \"add a final route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"final-route-remote-addr\", required_argument, 0, \"add a final route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"final-route-user-agent\", required_argument, 0, \"add a final route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"final-route-remote-user\", required_argument, 0, \"add a final route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"final-route-referer\", required_argument, 0, \"add a final route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"final-route-label\", required_argument, 0, \"add a final routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"final-route-if\", required_argument, 0, \"add a final route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"final-route-if-not\", required_argument, 0, \"add a final route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"final-route-run\", required_argument, 0, \"always run the specified final route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"error-route\", required_argument, 0, \"add an error route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"error-route-status\", required_argument, 0, \"add an error route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"error-route-host\", required_argument, 0, \"add an error route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"error-route-uri\", required_argument, 0, \"add an error route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"error-route-qs\", required_argument, 0, \"add an error route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"error-route-remote-addr\", required_argument, 0, \"add an error route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"error-route-user-agent\", required_argument, 0, \"add an error route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"error-route-remote-user\", required_argument, 0, \"add an error route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"error-route-referer\", required_argument, 0, \"add an error route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"error-route-label\", required_argument, 0, \"add an error routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"error-route-if\", required_argument, 0, \"add an error route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"error-route-if-not\", required_argument, 0, \"add an error route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"error-route-run\", required_argument, 0, \"always run the specified error route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"response-route\", required_argument, 0, \"add a response route\", uwsgi_opt_add_route, \"path_info\", 0},\n        {\"response-route-status\", required_argument, 0, \"add a response route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"response-route-host\", required_argument, 0, \"add a response route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"response-route-uri\", required_argument, 0, \"add a response route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"response-route-qs\", required_argument, 0, \"add a response route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"response-route-remote-addr\", required_argument, 0, \"add a response route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"response-route-user-agent\", required_argument, 0, \"add a response route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"response-route-remote-user\", required_argument, 0, \"add a response route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"response-route-referer\", required_argument, 0, \"add a response route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"response-route-label\", required_argument, 0, \"add a response routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"response-route-if\", required_argument, 0, \"add a response route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"response-route-if-not\", required_argument, 0, \"add a response route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"response-route-run\", required_argument, 0, \"always run the specified response route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"router-list\", no_argument, 0, \"list enabled routers\", uwsgi_opt_true, &uwsgi.router_list, 0},\n\t{\"routers-list\", no_argument, 0, \"list enabled routers\", uwsgi_opt_true, &uwsgi.router_list, 0},\n#endif\n\n\n\t{\"error-page-403\", required_argument, 0, \"add an error page (html) for managed 403 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_403, 0},\n\t{\"error-page-404\", required_argument, 0, \"add an error page (html) for managed 404 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_404, 0},\n\t{\"error-page-500\", required_argument, 0, \"add an error page (html) for managed 500 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_500, 0},\n\n\t{\"websockets-ping-freq\", required_argument, 0, \"set the frequency (in seconds) of websockets automatic ping packets\", uwsgi_opt_set_int, &uwsgi.websockets_ping_freq, 0},\n\t{\"websocket-ping-freq\", required_argument, 0, \"set the frequency (in seconds) of websockets automatic ping packets\", uwsgi_opt_set_int, &uwsgi.websockets_ping_freq, 0},\n\n\t{\"websockets-pong-tolerance\", required_argument, 0, \"set the tolerance (in seconds) of websockets ping/pong subsystem\", uwsgi_opt_set_int, &uwsgi.websockets_pong_tolerance, 0},\n\t{\"websocket-pong-tolerance\", required_argument, 0, \"set the tolerance (in seconds) of websockets ping/pong subsystem\", uwsgi_opt_set_int, &uwsgi.websockets_pong_tolerance, 0},\n\n\t{\"websockets-max-size\", required_argument, 0, \"set the max allowed size of websocket messages (in Kbytes, default 1024)\", uwsgi_opt_set_64bit, &uwsgi.websockets_max_size, 0},\n\t{\"websocket-max-size\", required_argument, 0, \"set the max allowed size of websocket messages (in Kbytes, default 1024)\", uwsgi_opt_set_64bit, &uwsgi.websockets_max_size, 0},\n\n\t{\"chunked-input-limit\", required_argument, 0, \"set the max size of a chunked input part (default 1MB, in bytes)\", uwsgi_opt_set_64bit, &uwsgi.chunked_input_limit, 0},\n\t{\"chunked-input-timeout\", required_argument, 0, \"set default timeout for chunked input\", uwsgi_opt_set_int, &uwsgi.chunked_input_timeout, 0},\n\n\t{\"clock\", required_argument, 0, \"set a clock source\", uwsgi_opt_set_str, &uwsgi.requested_clock, 0},\n\n\t{\"clock-list\", no_argument, 0, \"list enabled clocks\", uwsgi_opt_true, &uwsgi.clock_list, 0},\n\t{\"clocks-list\", no_argument, 0, \"list enabled clocks\", uwsgi_opt_true, &uwsgi.clock_list, 0},\n\n\t{\"add-header\", required_argument, 0, \"automatically add HTTP headers to response\", uwsgi_opt_add_string_list, &uwsgi.additional_headers, 0},\n\t{\"rem-header\", required_argument, 0, \"automatically remove specified HTTP header from the response\", uwsgi_opt_add_string_list, &uwsgi.remove_headers, 0},\n\t{\"del-header\", required_argument, 0, \"automatically remove specified HTTP header from the response\", uwsgi_opt_add_string_list, &uwsgi.remove_headers, 0},\n\t{\"collect-header\", required_argument, 0, \"store the specified response header in a request var (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},\n\t{\"response-header-collect\", required_argument, 0, \"store the specified response header in a request var (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},\n\n\t{\"pull-header\", required_argument, 0, \"store the specified response header in a request var and remove it from the response (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.pull_headers, 0},\n\n\t{\"check-static\", required_argument, 0, \"check for static files in the specified directory\", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},\n\t{\"check-static-docroot\", no_argument, 0, \"check for static files in the requested DOCUMENT_ROOT\", uwsgi_opt_true, &uwsgi.check_static_docroot, UWSGI_OPT_MIME},\n\t{\"static-check\", required_argument, 0, \"check for static files in the specified directory\", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},\n\t{\"static-map\", required_argument, 0, \"map mountpoint to static directory (or file)\", uwsgi_opt_static_map, &uwsgi.static_maps, UWSGI_OPT_MIME},\n\t{\"static-map2\", required_argument, 0, \"like static-map but completely appending the requested resource to the docroot\", uwsgi_opt_static_map, &uwsgi.static_maps2, UWSGI_OPT_MIME},\n\t{\"static-skip-ext\", required_argument, 0, \"skip specified extension from staticfile checks\", uwsgi_opt_add_string_list, &uwsgi.static_skip_ext, UWSGI_OPT_MIME},\n\t{\"static-index\", required_argument, 0, \"search for specified file if a directory is requested\", uwsgi_opt_add_string_list, &uwsgi.static_index, UWSGI_OPT_MIME},\n\t{\"static-safe\", required_argument, 0, \"skip security checks if the file is under the specified path\", uwsgi_opt_add_string_list, &uwsgi.static_safe, UWSGI_OPT_MIME},\n\t{\"static-cache-paths\", required_argument, 0, \"put resolved paths in the uWSGI cache for the specified amount of seconds\", uwsgi_opt_set_int, &uwsgi.use_static_cache_paths, UWSGI_OPT_MIME|UWSGI_OPT_MASTER},\n\t{\"static-cache-paths-name\", required_argument, 0, \"use the specified cache for static paths\", uwsgi_opt_set_str, &uwsgi.static_cache_paths_name, UWSGI_OPT_MIME|UWSGI_OPT_MASTER},\n#ifdef __APPLE__\n\t{\"mimefile\", required_argument, 0, \"set mime types file path (default /etc/apache2/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n\t{\"mime-file\", required_argument, 0, \"set mime types file path (default /etc/apache2/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n#else\n\t{\"mimefile\", required_argument, 0, \"set mime types file path (default /etc/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n\t{\"mime-file\", required_argument, 0, \"set mime types file path (default /etc/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n#endif\n\n\t{\"static-expires-type\", required_argument, 0, \"set the Expires header based on content type\", uwsgi_opt_add_dyn_dict, &uwsgi.static_expires_type, UWSGI_OPT_MIME},\n\t{\"static-expires-type-mtime\", required_argument, 0, \"set the Expires header based on content type and file mtime\", uwsgi_opt_add_dyn_dict, &uwsgi.static_expires_type_mtime, UWSGI_OPT_MIME},\n\n#ifdef UWSGI_PCRE\n\t{\"static-expires\", required_argument, 0, \"set the Expires header based on filename regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires, UWSGI_OPT_MIME},\n\t{\"static-expires-mtime\", required_argument, 0, \"set the Expires header based on filename regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_mtime, UWSGI_OPT_MIME},\n\n\t{\"static-expires-uri\", required_argument, 0, \"set the Expires header based on REQUEST_URI regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_uri, UWSGI_OPT_MIME},\n\t{\"static-expires-uri-mtime\", required_argument, 0, \"set the Expires header based on REQUEST_URI regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_uri_mtime, UWSGI_OPT_MIME},\n\n\t{\"static-expires-path-info\", required_argument, 0, \"set the Expires header based on PATH_INFO regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_path_info, UWSGI_OPT_MIME},\n\t{\"static-expires-path-info-mtime\", required_argument, 0, \"set the Expires header based on PATH_INFO regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_path_info_mtime, UWSGI_OPT_MIME},\n\t{\"static-gzip\", required_argument, 0, \"if the supplied regexp matches the static file translation it will search for a gzip version\", uwsgi_opt_add_regexp_list, &uwsgi.static_gzip, UWSGI_OPT_MIME},\n#endif\n\t{\"static-gzip-all\", no_argument, 0, \"check for a gzip version of all requested static files\", uwsgi_opt_true, &uwsgi.static_gzip_all, UWSGI_OPT_MIME},\n\t{\"static-gzip-dir\", required_argument, 0, \"check for a gzip version of all requested static files in the specified dir/prefix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_dir, UWSGI_OPT_MIME},\n\t{\"static-gzip-prefix\", required_argument, 0, \"check for a gzip version of all requested static files in the specified dir/prefix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_dir, UWSGI_OPT_MIME},\n\t{\"static-gzip-ext\", required_argument, 0, \"check for a gzip version of all requested static files with the specified ext/suffix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_ext, UWSGI_OPT_MIME},\n\t{\"static-gzip-suffix\", required_argument, 0, \"check for a gzip version of all requested static files with the specified ext/suffix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_ext, UWSGI_OPT_MIME},\n\n\t{\"honour-range\", no_argument, 0, \"enable support for the HTTP Range header\", uwsgi_opt_true, &uwsgi.honour_range, 0},\n\n\t{\"offload-threads\", required_argument, 0, \"set the number of offload threads to spawn (per-worker, default 0)\", uwsgi_opt_set_int, &uwsgi.offload_threads, 0},\n\t{\"offload-thread\", required_argument, 0, \"set the number of offload threads to spawn (per-worker, default 0)\", uwsgi_opt_set_int, &uwsgi.offload_threads, 0},\n\n\t{\"file-serve-mode\", required_argument, 0, \"set static file serving mode\", uwsgi_opt_fileserve_mode, NULL, UWSGI_OPT_MIME},\n\t{\"fileserve-mode\", required_argument, 0, \"set static file serving mode\", uwsgi_opt_fileserve_mode, NULL, UWSGI_OPT_MIME},\n\n\t{\"disable-sendfile\", no_argument, 0, \"disable sendfile() and rely on boring read()/write()\", uwsgi_opt_true, &uwsgi.disable_sendfile, 0},\n\n\t{\"check-cache\", optional_argument, 0, \"check for response data in the specified cache (empty for default cache)\", uwsgi_opt_set_str, &uwsgi.use_check_cache, 0},\n\t{\"close-on-exec\", no_argument, 0, \"set close-on-exec on connection sockets (could be required for spawning processes in requests)\", uwsgi_opt_true, &uwsgi.close_on_exec, 0},\n\t{\"close-on-exec2\", no_argument, 0, \"set close-on-exec on server sockets (could be required for spawning processes in requests)\", uwsgi_opt_true, &uwsgi.close_on_exec2, 0},\n\t{\"mode\", required_argument, 0, \"set uWSGI custom mode\", uwsgi_opt_set_str, &uwsgi.mode, 0},\n\t{\"env\", required_argument, 0, \"set environment variable\", uwsgi_opt_set_env, NULL, 0},\n\t{\"envdir\", required_argument, 0, \"load a daemontools compatible envdir\", uwsgi_opt_add_string_list, &uwsgi.envdirs, 0},\n\t{\"early-envdir\", required_argument, 0, \"load a daemontools compatible envdir ASAP\", uwsgi_opt_envdir, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"unenv\", required_argument, 0, \"unset environment variable\", uwsgi_opt_unset_env, NULL, 0},\n\t{\"vacuum\", no_argument, 0, \"try to remove all of the generated file/sockets\", uwsgi_opt_true, &uwsgi.vacuum, 0},\n\t{\"file-write\", required_argument, 0, \"write the specified content to the specified file (syntax: file=value) before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.file_write_list, 0},\n#ifdef __linux__\n\t{\"cgroup\", required_argument, 0, \"put the processes in the specified cgroup\", uwsgi_opt_add_string_list, &uwsgi.cgroup, 0},\n\t{\"cgroup-opt\", required_argument, 0, \"set value in specified cgroup option\", uwsgi_opt_add_string_list, &uwsgi.cgroup_opt, 0},\n\t{\"cgroup-dir-mode\", required_argument, 0, \"set permission for cgroup directory (default is 700)\", uwsgi_opt_set_str, &uwsgi.cgroup_dir_mode, 0},\n\t{\"namespace\", required_argument, 0, \"run in a new namespace under the specified rootfs\", uwsgi_opt_set_str, &uwsgi.ns, 0},\n\t{\"namespace-keep-mount\", required_argument, 0, \"keep the specified mountpoint in your namespace\", uwsgi_opt_add_string_list, &uwsgi.ns_keep_mount, 0},\n\t{\"ns\", required_argument, 0, \"run in a new namespace under the specified rootfs\", uwsgi_opt_set_str, &uwsgi.ns, 0},\n\t{\"namespace-net\", required_argument, 0, \"add network namespace\", uwsgi_opt_set_str, &uwsgi.ns_net, 0},\n\t{\"ns-net\", required_argument, 0, \"add network namespace\", uwsgi_opt_set_str, &uwsgi.ns_net, 0},\n#endif\n\t{\"enable-proxy-protocol\", no_argument, 0, \"enable PROXY1 protocol support (only for http parsers)\", uwsgi_opt_true, &uwsgi.enable_proxy_protocol, 0},\n\t{\"reuse-port\", no_argument, 0, \"enable REUSE_PORT flag on socket (BSD only)\", uwsgi_opt_true, &uwsgi.reuse_port, 0},\n\t{\"tcp-fast-open\", required_argument, 0, \"enable TCP_FASTOPEN flag on TCP sockets with the specified qlen value\", uwsgi_opt_set_int, &uwsgi.tcp_fast_open, 0},\n\t{\"tcp-fastopen\", required_argument, 0, \"enable TCP_FASTOPEN flag on TCP sockets with the specified qlen value\", uwsgi_opt_set_int, &uwsgi.tcp_fast_open, 0},\n\t{\"tcp-fast-open-client\", no_argument, 0, \"use sendto(..., MSG_FASTOPEN, ...) instead of connect() if supported\", uwsgi_opt_true, &uwsgi.tcp_fast_open_client, 0},\n\t{\"tcp-fastopen-client\", no_argument, 0, \"use sendto(..., MSG_FASTOPEN, ...) instead of connect() if supported\", uwsgi_opt_true, &uwsgi.tcp_fast_open_client, 0},\n\t{\"zerg\", required_argument, 0, \"attach to a zerg server\", uwsgi_opt_add_string_list, &uwsgi.zerg_node, 0},\n\t{\"zerg-fallback\", no_argument, 0, \"fallback to normal sockets if the zerg server is not available\", uwsgi_opt_true, &uwsgi.zerg_fallback, 0},\n\t{\"zerg-server\", required_argument, 0, \"enable the zerg server on the specified UNIX socket\", uwsgi_opt_set_str, &uwsgi.zerg_server, UWSGI_OPT_MASTER},\n\n\t{\"cron\", required_argument, 0, \"add a cron task\", uwsgi_opt_add_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron2\", required_argument, 0, \"add a cron task (key=val syntax)\", uwsgi_opt_add_cron2, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-cron\", required_argument, 0, \"add a unique cron task\", uwsgi_opt_add_unique_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron-harakiri\", required_argument, 0, \"set the maximum time (in seconds) we wait for cron command to complete\", uwsgi_opt_set_int, &uwsgi.cron_harakiri, 0},\n#ifdef UWSGI_SSL\n\t{\"legion-cron\", required_argument, 0, \"add a cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron-legion\", required_argument, 0, \"add a cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-legion-cron\", required_argument, 0, \"add a unique cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_unique_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-cron-legion\", required_argument, 0, \"add a unique cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_unique_legion_cron, NULL, UWSGI_OPT_MASTER},\n#endif\n\t{\"loop\", required_argument, 0, \"select the uWSGI loop engine\", uwsgi_opt_set_str, &uwsgi.loop, 0},\n\t{\"loop-list\", no_argument, 0, \"list enabled loop engines\", uwsgi_opt_true, &uwsgi.loop_list, 0},\n\t{\"loops-list\", no_argument, 0, \"list enabled loop engines\", uwsgi_opt_true, &uwsgi.loop_list, 0},\n\t{\"worker-exec\", required_argument, 0, \"run the specified command as worker\", uwsgi_opt_set_str, &uwsgi.worker_exec, 0},\n\t{\"worker-exec2\", required_argument, 0, \"run the specified command as worker (after post_fork hook)\", uwsgi_opt_set_str, &uwsgi.worker_exec2, 0},\n\t{\"attach-daemon\", required_argument, 0, \"attach a command/daemon to the master process (the command has to not go in background)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"attach-control-daemon\", required_argument, 0, \"attach a command/daemon to the master process (the command has to not go in background), when the daemon dies, the master dies too\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"smart-attach-daemon\", required_argument, 0, \"attach a command/daemon to the master process managed by a pidfile (the command has to daemonize)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"smart-attach-daemon2\", required_argument, 0, \"attach a command/daemon to the master process managed by a pidfile (the command has to NOT daemonize)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n#ifdef UWSGI_SSL\n\t{\"legion-attach-daemon\", required_argument, 0, \"same as --attach-daemon but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-smart-attach-daemon\", required_argument, 0, \"same as --smart-attach-daemon but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-smart-attach-daemon2\", required_argument, 0, \"same as --smart-attach-daemon2 but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n#endif\n\t{\"daemons-honour-stdin\", no_argument, 0, \"do not change the stdin of external daemons to /dev/null\", uwsgi_opt_true, &uwsgi.daemons_honour_stdin, UWSGI_OPT_MASTER},\n\t{\"attach-daemon2\", required_argument, 0, \"attach-daemon keyval variant (supports smart modes too)\", uwsgi_opt_add_daemon2, NULL, UWSGI_OPT_MASTER},\n\t{\"plugins\", required_argument, 0, \"load uWSGI plugins\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"plugin\", required_argument, 0, \"load uWSGI plugins\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"need-plugins\", required_argument, 0, \"load uWSGI plugins (exit on error)\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"need-plugin\", required_argument, 0, \"load uWSGI plugins (exit on error)\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"plugins-dir\", required_argument, 0, \"add a directory to uWSGI plugin search path\", uwsgi_opt_add_string_list, &uwsgi.plugins_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"plugin-dir\", required_argument, 0, \"add a directory to uWSGI plugin search path\", uwsgi_opt_add_string_list, &uwsgi.plugins_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"plugins-list\", no_argument, 0, \"list enabled plugins\", uwsgi_opt_true, &uwsgi.plugins_list, 0},\n\t{\"plugin-list\", no_argument, 0, \"list enabled plugins\", uwsgi_opt_true, &uwsgi.plugins_list, 0},\n\t{\"autoload\", no_argument, 0, \"try to automatically load plugins when unknown options are found\", uwsgi_opt_true, &uwsgi.autoload, UWSGI_OPT_IMMEDIATE},\n\t{\"dlopen\", required_argument, 0, \"blindly load a shared library\", uwsgi_opt_load_dl, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"allowed-modifiers\", required_argument, 0, \"comma separated list of allowed modifiers\", uwsgi_opt_set_str, &uwsgi.allowed_modifiers, 0},\n\t{\"remap-modifier\", required_argument, 0, \"remap request modifier from one id to another\", uwsgi_opt_set_str, &uwsgi.remap_modifier, 0},\n\n\t{\"dump-options\", no_argument, 0, \"dump the full list of available options\", uwsgi_opt_true, &uwsgi.dump_options, 0},\n\t{\"show-config\", no_argument, 0, \"show the current config reformatted as ini\", uwsgi_opt_true, &uwsgi.show_config, 0},\n\t{\"binary-append-data\", required_argument, 0, \"return the content of a resource to stdout for appending to a uwsgi binary (for data:// usage)\", uwsgi_opt_binary_append_data, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"print\", required_argument, 0, \"simple print\", uwsgi_opt_print, NULL, 0},\n\t{\"iprint\", required_argument, 0, \"simple print (immediate version)\", uwsgi_opt_print, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"exit\", optional_argument, 0, \"force exit() of the instance\", uwsgi_opt_exit, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"cflags\", no_argument, 0, \"report uWSGI CFLAGS (useful for building external plugins)\", uwsgi_opt_cflags, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"dot-h\", no_argument, 0, \"dump the uwsgi.h used for building the core  (useful for building external plugins)\", uwsgi_opt_dot_h, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"config-py\", no_argument, 0, \"dump the uwsgiconfig.py used for building the core  (useful for building external plugins)\", uwsgi_opt_config_py, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"build-plugin\", required_argument, 0, \"build a uWSGI plugin for the current binary\", uwsgi_opt_build_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"version\", no_argument, 0, \"print uWSGI version\", uwsgi_opt_print, UWSGI_VERSION, 0},\n\t{\"response-headers-limit\", required_argument, 0, \"set response header maximum size (default: 64k)\", uwsgi_opt_set_int, &uwsgi.response_header_limit, 0},\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\nvoid show_config(void) {\n\tint i;\n\tuwsgi_log(\"\\n;uWSGI instance configuration\\n[uwsgi]\\n\");\n\tfor (i = 0; i < uwsgi.exported_opts_cnt; i++) {\n\t\tif (uwsgi.exported_opts[i]->value) {\n\t\t\tuwsgi_log(\"%s = %s\\n\", uwsgi.exported_opts[i]->key, uwsgi.exported_opts[i]->value);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"%s = true\\n\", uwsgi.exported_opts[i]->key);\n\t\t}\n\t}\n\tuwsgi_log(\";end of configuration\\n\\n\");\n\n}\n\nvoid config_magic_table_fill(char *filename, char **magic_table) {\n\n\tchar *tmp = NULL;\n\tchar *fullname = filename;\n\n\tmagic_table['o'] = filename;\n\n\tif (uwsgi_check_scheme(filename) || !strcmp(filename, \"-\")) {\n\t\treturn;\n\t}\n\n        char *section = uwsgi_get_last_char(filename, ':');\n        if (section) {\n                *section = 0;\n\t\tif (section == filename) {\n\t\t\tgoto reuse;\n\t\t}\n\t}\n\n\n\t// we have a special case for symlinks\n\tif (uwsgi_is_link(filename)) {\n\t\tif (filename[0] != '/') {\n\t\t\tfullname = uwsgi_concat3(uwsgi.cwd, \"/\", filename);\n\t\t}\n\t}\n\telse {\n\n\t\tfullname = uwsgi_expand_path(filename, strlen(filename), NULL);\n\t\tif (!fullname) {\n\t\t\texit(1);\n\t\t}\n\t\tchar *minimal_name = uwsgi_malloc(strlen(fullname) + 1);\n\t\tmemcpy(minimal_name, fullname, strlen(fullname));\n\t\tminimal_name[strlen(fullname)] = 0;\n\t\tfree(fullname);\n\t\tfullname = minimal_name;\n\t}\n\n\tmagic_table['b'] = uwsgi.binary_path;\n\tmagic_table['p'] = fullname;\n\n\t// compute filename hash\n\tuint32_t hash = djb33x_hash(magic_table['p'], strlen(magic_table['p']));\n\tchar *hex = uwsgi_str_to_hex((char *)&hash, 4);\n\tmagic_table['j'] = uwsgi_concat2n(hex, 8, \"\", 0);\n\tfree(hex);\n\n\tstruct stat st;\n\tif (!lstat(fullname, &st)) {\n\t\tmagic_table['i'] = uwsgi_num2str(st.st_ino);\n\t}\n\n\tmagic_table['s'] = uwsgi_get_last_char(fullname, '/') + 1;\n\n\tmagic_table['d'] = uwsgi_concat2n(magic_table['p'], magic_table['s'] - magic_table['p'], \"\", 0);\n\tif (magic_table['d'][strlen(magic_table['d']) - 1] == '/') {\n\t\ttmp = magic_table['d'] + (strlen(magic_table['d']) - 1);\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"tmp = %c\\n\", *tmp);\n#endif\n\t\t*tmp = 0;\n\t}\n\n\t// clear optional vars\n\tmagic_table['c'] = \"\";\n\tmagic_table['e'] = \"\";\n\tmagic_table['n'] = magic_table['s'];\n\n\tmagic_table['0'] = \"\";\n\tmagic_table['1'] = \"\";\n\tmagic_table['2'] = \"\";\n\tmagic_table['3'] = \"\";\n\tmagic_table['4'] = \"\";\n\tmagic_table['5'] = \"\";\n\tmagic_table['6'] = \"\";\n\tmagic_table['7'] = \"\";\n\tmagic_table['8'] = \"\";\n\tmagic_table['9'] = \"\";\n\n\tif (uwsgi_get_last_char(magic_table['d'], '/')) {\n\t\tmagic_table['c'] = uwsgi_str(uwsgi_get_last_char(magic_table['d'], '/') + 1);\n\t\tif (magic_table['c'][strlen(magic_table['c']) - 1] == '/') {\n\t\t\tmagic_table['c'][strlen(magic_table['c']) - 1] = 0;\n\t\t}\n\t}\n\n\tint base = '0';\n\tchar *to_split = uwsgi_str(magic_table['d']);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(to_split, \"/\", p, ctx) {\n\t\tif (base <= '9') {\n\t\t\tmagic_table[base] = p;\n\t\t\tbase++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp)\n\t\t*tmp = '/';\n\n\tif (uwsgi_get_last_char(magic_table['s'], '.'))\n\t\tmagic_table['e'] = uwsgi_get_last_char(magic_table['s'], '.') + 1;\n\tif (uwsgi_get_last_char(magic_table['s'], '.'))\n\t\tmagic_table['n'] = uwsgi_concat2n(magic_table['s'], uwsgi_get_last_char(magic_table['s'], '.') - magic_table['s'], \"\", 0);\n\nreuse:\n\tmagic_table['x'] = \"\";\n\tif (section) {\n\t\tmagic_table['x'] = section+1;\n\t\t*section = ':';\n\t}\n\n\t// first round ?\n\tif (!uwsgi.magic_table_first_round) { \n\t\tmagic_table['O'] = magic_table['o'];\n                magic_table['D'] = magic_table['d'];\n                magic_table['S'] = magic_table['s'];\n                magic_table['P'] = magic_table['p'];\n                magic_table['C'] = magic_table['c'];\n                magic_table['E'] = magic_table['e'];\n                magic_table['N'] = magic_table['n'];\n                magic_table['X'] = magic_table['x'];\n                magic_table['I'] = magic_table['i'];\n                magic_table['J'] = magic_table['j'];\n\t\tuwsgi.magic_table_first_round = 1;\n        }\n\n}\n\nint find_worker_id(pid_t pid) {\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid == pid)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n\nvoid warn_pipe() {\n\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\n\tif (uwsgi.threads < 2 && wsgi_req->uri_len > 0) {\n\t\tuwsgi_log_verbose(\"SIGPIPE: writing to a closed pipe/socket/fd (probably the client disconnected) on request %.*s (ip %.*s) !!!\\n\", wsgi_req->uri_len, wsgi_req->uri, wsgi_req->remote_addr_len, wsgi_req->remote_addr);\n\t}\n\telse {\n\t\tuwsgi_log_verbose(\"SIGPIPE: writing to a closed pipe/socket/fd (probably the client disconnected) !!!\\n\");\n\t}\n}\n\n// in threading mode we need to use the cancel pthread subsystem\nvoid wait_for_threads() {\n\tint i, ret;\n\n\t// on some platform thread cancellation is REALLY flaky\n\tif (uwsgi.no_threads_wait) return;\n\n\tint sudden_death = 0;\n\n\tpthread_mutex_lock(&uwsgi.six_feet_under_lock);\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[i].thread_id)) {\n\t\t\t\tuwsgi_error(\"pthread_cancel()\\n\");\n\t\t\t\tsudden_death = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sudden_death)\n\t\tgoto end;\n\n\t// wait for thread termination\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, NULL);\n\t\t\tif (ret) {\n\t\t\t\tuwsgi_log(\"pthread_join() = %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t// cancel inital thread last since after pthread_cancel() and\n\t// pthread_join() is called on it, the whole process will appear to be\n\t// a zombie. although it won't eliminate process zombie time, but it\n\t// should minimize it.\n\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, pthread_self())) {\n\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[0].thread_id)) {\n\t\t\tuwsgi_error(\"pthread_cancel() on initial thread\\n\");\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, NULL);\n\t\tif (ret) {\n\t\t\tuwsgi_log(\"pthread_join() = %d on initial thread\\n\", ret);\n\t\t}\n\t}\n\nend:\n\n\tpthread_mutex_unlock(&uwsgi.six_feet_under_lock);\n}\n\n\nvoid gracefully_kill(int signum) {\n\n\tuwsgi_log(\"Gracefully killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tif (uwsgi.threads > 1) {\n\t\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\t\twait_for_threads();\n\t\tif (!uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request) {\n\t\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\t\tuwsgi_shutdown_all_sockets();\n\t\t\texit(UWSGI_RELOAD_CODE);\n\t\t}\n\t\treturn;\n\t\t// never here\n\t}\n\n\t// still not found a way to gracefully reload in async mode\n\tif (uwsgi.async > 1) {\n\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\tuwsgi_shutdown_all_sockets();\n\t\texit(UWSGI_RELOAD_CODE);\n\t}\n\n\tif (!uwsgi.workers[uwsgi.mywid].cores[0].in_request) {\n\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\tuwsgi_shutdown_all_sockets();\n\t\texit(UWSGI_RELOAD_CODE);\n\t}\n}\n\nvoid end_me(int signum) {\n\tif (getpid() != masterpid && uwsgi.skip_atexit) {\n\t\t_exit(UWSGI_END_CODE);\n\t\t// never here\n\t}\n\texit(UWSGI_END_CODE);\n}\n\nvoid simple_goodbye_cruel_world() {\n\n\tif (uwsgi.threads > 1 && !uwsgi_instance_is_dying) {\n\t\twait_for_threads();\n\t}\n\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tuwsgi_log(\"...The work of process %d is done. Seeya!\\n\", getpid());\n\texit(0);\n}\n\nvoid goodbye_cruel_world() {\n\tuwsgi_curse(uwsgi.mywid, 0);\n\n\tif (!uwsgi.gbcw_hook) {\n\t\tsimple_goodbye_cruel_world();\n\t}\n\telse {\n\t\tuwsgi.gbcw_hook();\n\t}\n}\n\n// brutally destroy\nvoid kill_them_all(int signum) {\n\n\tif (uwsgi_instance_is_dying) return;\n\tuwsgi.status.brutally_destroying = 1;\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tuwsgi_log(\"SIGINT/SIGQUIT received...killing workers...\\n\");\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n                        uwsgi_curse(i, SIGINT);\n                }\n        }\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGINT);\n\t\t}\n\t}\n\n\tuwsgi_destroy_processes();\n}\n\n// gracefully destroy\nvoid gracefully_kill_them_all(int signum) {\n\n        if (uwsgi_instance_is_dying) return;\n        uwsgi.status.gracefully_destroying = 1;\n\n        // unsubscribe if needed\n        uwsgi_unsubscribe_all();\n\n        uwsgi_log_verbose(\"graceful shutdown triggered...\\n\");\n\n        int i;\n        for (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n\t\t\tif (uwsgi.shutdown_sockets)\n\t\t\t\tuwsgi.workers[i].shutdown_sockets = 1;\n                        uwsgi_curse(i, SIGHUP);\n                }\n        }\n        for (i = 0; i < uwsgi.mules_cnt; i++) {\n                if (uwsgi.mules[i].pid > 0) {\n                        uwsgi_curse_mule(i, SIGHUP);\n                }\n        }\n\n        uwsgi_destroy_processes();\n}\n\n\n// graceful reload\nvoid grace_them_all(int signum) {\n\tif (uwsgi_instance_is_reloading || uwsgi_instance_is_dying)\n\t\treturn;\n\n\tint i;\n\n\tif (uwsgi.lazy) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t\n\n\tuwsgi.status.gracefully_reloading = 1;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...gracefully killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n\tuwsgi_legion_announce_death();\n#endif\n\n\tif (uwsgi.unsubscribe_on_graceful_reload) {\n\t\tuwsgi_unsubscribe_all();\n\t}\n\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGHUP);\n\t\t}\n\t}\n}\n\nvoid uwsgi_nuclear_blast() {\n\n\t// the Emperor (as an example) cannot nuke itself\n\tif (uwsgi.disable_nuclear_blast) return;\n\n\tif (!uwsgi.workers) {\n\t\treap_them_all(0);\n\t}\n\telse if (uwsgi.master_process) {\n\t\tif (getpid() == uwsgi.workers[0].pid) {\n\t\t\treap_them_all(0);\n\t\t}\n\t}\n\n\texit(1);\n}\n\n// brutally reload\nvoid reap_them_all(int signum) {\n\n\t// avoid reace condition in lazy mode\n\tif (uwsgi_instance_is_reloading)\n\t\treturn;\n\n\tuwsgi.status.brutally_reloading = 1;\n\n\tif (!uwsgi.workers) return;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...brutally killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n        uwsgi_legion_announce_death();\n#endif\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0)\n\t\t\tuwsgi_curse(i, SIGTERM);\n\t}\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGTERM);\n\t\t}\n\t}\n}\n\nvoid harakiri() {\n\n\tuwsgi_log(\"\\nF*CK !!! i must kill myself (pid: %d app_id: %d)...\\n\", uwsgi.mypid, uwsgi.wsgi_req->app_id);\n\n\tif (!uwsgi.master_process) {\n\t\tuwsgi_log(\"*** if you want your workers to be automatically respawned consider enabling the uWSGI master process ***\\n\");\n\t}\n\texit(0);\n}\n\nvoid stats(int signum) {\n\t//fix this for better logging(this cause races)\n\tstruct uwsgi_app *ua = NULL;\n\tint i, j;\n\n\tif (uwsgi.mywid == 0) {\n\t\tshow_config();\n\t\tuwsgi_log(\"\\tworkers total requests: %lu\\n\", uwsgi.workers[0].requests);\n\t\tuwsgi_log(\"-----------------\\n\");\n\t\tfor (j = 1; j <= uwsgi.numproc; j++) {\n\t\t\tfor (i = 0; i < uwsgi.workers[j].apps_cnt; i++) {\n\t\t\t\tua = &uwsgi.workers[j].apps[i];\n\t\t\t\tif (ua) {\n\t\t\t\t\tuwsgi_log(\"\\tworker %d app %d [%.*s] requests: %lu exceptions: %lu\\n\", j, i, ua->mountpoint_len, ua->mountpoint, ua->requests, ua->exceptions);\n\t\t\t\t}\n\t\t\t}\n\t\t\tuwsgi_log(\"-----------------\\n\");\n\t\t}\n\t}\n\telse {\n\t\tuwsgi_log(\"worker %d total requests: %lu\\n\", uwsgi.mywid, uwsgi.workers[0].requests);\n\t\tfor (i = 0; i < uwsgi.workers[uwsgi.mywid].apps_cnt; i++) {\n\t\t\tua = &uwsgi.workers[uwsgi.mywid].apps[i];\n\t\t\tif (ua) {\n\t\t\t\tuwsgi_log(\"\\tapp %d [%.*s] requests: %lu exceptions: %lu\\n\", i, ua->mountpoint_len, ua->mountpoint, ua->requests, ua->exceptions);\n\t\t\t}\n\t\t}\n\t\tuwsgi_log(\"-----------------\\n\");\n\t}\n\tuwsgi_log(\"\\n\");\n}\n\nvoid what_i_am_doing() {\n\n\tstruct wsgi_request *wsgi_req;\n\tint i;\n\tchar ctime_storage[26];\n\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.cores > 1) {\n\t\tfor (i = 0; i < uwsgi.cores; i++) {\n\t\t\twsgi_req = &uwsgi.workers[uwsgi.mywid].cores[i].req;\n\t\t\tif (wsgi_req->uri_len > 0) {\n#if defined(__sun__) && !defined(__clang__)\n\t\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage, 26);\n#else\n\t\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);\n#endif\n\t\t\t\tif (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {\n\t\t\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d core %d (pid: %d) WAS managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"SIGUSR2: --- uWSGI worker %d core %d (pid: %d) is managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\twsgi_req = &uwsgi.workers[uwsgi.mywid].cores[0].req;\n\t\tif (wsgi_req->uri_len > 0) {\n#if defined(__sun__) && !defined(__clang__)\n\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage, 26);\n#else\n\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);\n#endif\n\t\t\tif (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {\n\t\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d (pid: %d) WAS managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"SIGUSR2: --- uWSGI worker %d (pid: %d) is managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t}\n\t\t}\n\t\telse if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {\n\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d (pid: %d) WAS handling signal %d ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, uwsgi.workers[uwsgi.mywid].signum);\n\t\t}\n\t}\n}\n\n\n\nint unconfigured_hook(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->uh->modifier1 == 0 && !uwsgi.no_default_app) {\n\t\tif (uwsgi_apps_cnt > 0 && uwsgi.default_app > -1) {\n\t\t\tstruct uwsgi_app *ua = &uwsgi_apps[uwsgi.default_app];\n\t\t\tif (uwsgi.p[ua->modifier1]->request != unconfigured_hook) {\n\t\t\t\twsgi_req->uh->modifier1 = ua->modifier1;\n\t\t\t\treturn uwsgi.p[ua->modifier1]->request(wsgi_req);\n\t\t\t}\n\t\t}\n\t}\n\tuwsgi_log(\"-- unavailable modifier requested: %d --\\n\", wsgi_req->uh->modifier1);\n\treturn -1;\n}\n\nstatic void unconfigured_after_hook(struct wsgi_request *wsgi_req) {\n\treturn;\n}\n\nstruct uwsgi_plugin unconfigured_plugin = {\n\n\t.name = \"unconfigured\",\n\t.request = unconfigured_hook,\n\t.after_request = unconfigured_after_hook,\n};\n\nvoid uwsgi_exec_atexit(void) {\n\tif (getpid() == masterpid) {\n\t\n\t\tuwsgi_hooks_run(uwsgi.hook_as_user_atexit, \"atexit\", 0);\n\t\t// now run exit scripts needed by the user\n\t\tstruct uwsgi_string_list *usl;\n\n\t\tuwsgi_foreach(usl, uwsgi.exec_as_user_atexit) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (as uid: %d gid: %d) ...\\n\", usl->value, (int) getuid(), (int) getgid());\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_as_user_atexit) {\n                \tif (uwsgi_call_symbol(usl->value)) {\n                        \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                \t}\n        \t}\n\t}\n}\n\nstatic void vacuum(void) {\n\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\n\tif (uwsgi.restore_tc) {\n\t\tif (getpid() == masterpid) {\n\t\t\tif (tcsetattr(0, TCSANOW, &uwsgi.termios)) {\n\t\t\t\tuwsgi_error(\"vacuum()/tcsetattr()\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.vacuum) {\n\t\tif (getpid() == masterpid) {\n\t\t\tif (chdir(uwsgi.cwd)) {\n\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t}\n\t\t\tif (uwsgi.pidfile && !uwsgi.uid) {\n\t\t\t\tif (unlink(uwsgi.pidfile)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: pidfile removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.pidfile2) {\n\t\t\t\tif (unlink(uwsgi.pidfile2)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: pidfile2 removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.safe_pidfile && !uwsgi.uid) {\n\t\t\t\tif (unlink(uwsgi.safe_pidfile)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: safe pidfile removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.safe_pidfile2) {\n\t\t\t\tif (unlink(uwsgi.safe_pidfile2)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: safe pidfile2 removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.chdir) {\n\t\t\t\tif (chdir(uwsgi.chdir)) {\n\t\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (uwsgi_sock) {\n\t\t\t\tif (uwsgi_sock->family == AF_UNIX && uwsgi_sock->name[0] != '@') {\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\tif (!stat(uwsgi_sock->name, &st)) {\n\t\t\t\t\t\tif (st.st_ino != uwsgi_sock->inode) {\n\t\t\t\t\t\t\tuwsgi_log(\"VACUUM WARNING: unix socket %s changed inode. Skip removal\\n\", uwsgi_sock->name);\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (unlink(uwsgi_sock->name)) {\n\t\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"VACUUM: unix socket %s removed.\\n\", uwsgi_sock->name);\n\t\t\t\t\t}\n\t\t\t\t}\nnext:\n\t\t\t\tuwsgi_sock = uwsgi_sock->next;\n\t\t\t}\n\t\t\tif (uwsgi.stats) {\n\t\t\t\t// is a unix socket ?\n\t\t\t\tif (!strchr(uwsgi.stats, ':') && uwsgi.stats[0] != '@') {\n\t\t\t\t\tif (unlink(uwsgi.stats)) {\n                                                uwsgi_error(\"unlink()\");\n                                        }\n                                        else {\n                                                uwsgi_log(\"VACUUM: unix socket %s (stats) removed.\\n\", uwsgi.stats);\n                                        }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint signal_pidfile(int sig, char *filename) {\n\n\tint ret = 0;\n\tsize_t size = 0;\n\n\tchar *buffer = uwsgi_open_and_read(filename, &size, 1, NULL);\n\n\tif (size > 0) {\n\t\tif (kill((pid_t) atoi(buffer), sig)) {\n\t\t\tuwsgi_error(\"signal_pidfile()/kill()\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\telse {\n\t\tuwsgi_log(\"error: invalid pidfile\\n\");\n\t\tret = -1;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\n/*static*/ void uwsgi_command_signal(char *opt) {\n\n\tint tmp_signal;\n\tchar *colon = strchr(opt, ',');\n\tif (!colon) {\n\t\tuwsgi_log(\"invalid syntax for signal, must be addr,signal\\n\");\n\t\texit(1);\n\t}\n\n\tcolon[0] = 0;\n\ttmp_signal = atoi(colon + 1);\n\n\tif (tmp_signal < 0 || tmp_signal > 255) {\n\t\tuwsgi_log(\"invalid signal number\\n\");\n\t\texit(3);\n\t}\n\n\tuint8_t uwsgi_signal = tmp_signal;\n\tint ret = uwsgi_remote_signal_send(opt, uwsgi_signal);\n\n\tif (ret < 0) {\n\t\tuwsgi_log(\"unable to deliver signal %d to node %s\\n\", uwsgi_signal, opt);\n\t\texit(1);\n\t}\n\n\tif (ret == 0) {\n\t\tuwsgi_log(\"node %s rejected signal %d\\n\", opt, uwsgi_signal);\n\t\texit(2);\n\t}\n\n\tuwsgi_log(\"signal %d delivered to node %s\\n\", uwsgi_signal, opt);\n\texit(0);\n}\n\nstatic void fixup_argv_and_environ(int argc, char **argv, char **environ, char **envp) {\n\n\tuwsgi.orig_argv = argv;\n\tuwsgi.argv = argv;\n\tuwsgi.argc = argc;\n\tuwsgi.environ = UWSGI_ENVIRON;\n\n\t// avoid messing with fake environ\n\tif (envp && *environ != *envp) return;\n\t\n\n#if defined(__linux__) || defined(__sun__)\n\n\tint i;\n\tint env_count = 0;\n\n\tuwsgi.argv = uwsgi_malloc(sizeof(char *) * (argc + 1));\n\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 || argv[0] + uwsgi.max_procname + 1 == argv[i]) {\n\t\t\tuwsgi.max_procname += strlen(argv[i]) + 1;\n\t\t}\n\t\tuwsgi.argv[i] = strdup(argv[i]);\n\t}\n\n\t// required by execve\n\tuwsgi.argv[i] = NULL;\n\n\tuwsgi.max_procname++;\n\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t// useless\n\t\t//if ((environ[0] + uwsgi.max_procname + 1) == environ[i]) {\n\t\tuwsgi.max_procname += strlen(environ[i]) + 1;\n\t\t//}\n\t\tenv_count++;\n\t}\n\n\tuwsgi.environ = uwsgi_malloc(sizeof(char *) * (env_count+1));\n\tfor (i = 0; i < env_count; i++) {\n\t\tuwsgi.environ[i] = strdup(environ[i]);\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"ENVIRON: %s\\n\", uwsgi.environ[i]);\n#endif\n\t\tenviron[i] = uwsgi.environ[i];\n\t}\n\tuwsgi.environ[env_count] = NULL;\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"max space for custom process name = %d\\n\", uwsgi.max_procname);\n#endif\n\t//environ = uwsgi.environ;\n\n#endif\n}\n\n\nvoid uwsgi_plugins_atexit(void) {\n\n\tint j;\n\n\tif (!uwsgi.workers)\n\t\treturn;\n\n\t// the master cannot run atexit handlers...\n\tif (uwsgi.master_process && uwsgi.workers[0].pid == getpid())\n\t\treturn;\n\n\tfor (j = 0; j < uwsgi.gp_cnt; j++) {\n\t\tif (uwsgi.gp[j]->atexit) {\n\t\t\tuwsgi.gp[j]->atexit();\n\t\t}\n\t}\n\n\tfor (j = 0; j < 256; j++) {\n\t\tif (uwsgi.p[j]->atexit) {\n\t\t\tuwsgi.p[j]->atexit();\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_backtrace(int depth) {\n\n#if defined(__GLIBC__) || (defined(__APPLE__) && !defined(NO_EXECINFO)) || defined(UWSGI_HAS_EXECINFO)\n\n#include <execinfo.h>\n\n\tvoid **btrace = uwsgi_malloc(sizeof(void *) * depth);\n\tsize_t bt_size, i;\n\tchar **bt_strings;\n\n\tbt_size = backtrace(btrace, depth);\n\n\tbt_strings = backtrace_symbols(btrace, bt_size);\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\tuwsgi_buffer_append(ub, \"*** backtrace of \",17);\n\tuwsgi_buffer_num64(ub, (int64_t) getpid());\n\tuwsgi_buffer_append(ub, \" ***\\n\", 5);\n\tfor (i = 0; i < bt_size; i++) {\n\t\tuwsgi_buffer_append(ub, bt_strings[i], strlen(bt_strings[i]));\n\t\tuwsgi_buffer_append(ub, \"\\n\", 1);\n\t}\n\n\tfree(btrace);\n\n\tuwsgi_buffer_append(ub, \"*** end of backtrace ***\\n\", 25);\n\n\tuwsgi_log(\"%.*s\", ub->pos, ub->buf);\n\n\tstruct uwsgi_string_list *usl = uwsgi.alarm_segfault;\n\twhile(usl) {\n\t\tuwsgi_alarm_trigger(usl->value, ub->buf, ub->pos);\t\n\t\tusl = usl->next;\n\t}\t\n\n\tuwsgi_buffer_destroy(ub);\n#endif\n\n}\n\nvoid uwsgi_segfault(int signum) {\n\n\tuwsgi_log(\"!!! uWSGI process %d got Segmentation Fault !!!\\n\", (int) getpid());\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.use_abort) abort();\n\n\t// restore default handler to generate core\n\tsignal(signum, SIG_DFL);\n\tkill(getpid(), signum);\n\n\t// never here...\n\texit(1);\n}\n\nvoid uwsgi_fpe(int signum) {\n\n\tuwsgi_log(\"!!! uWSGI process %d got Floating Point Exception !!!\\n\", (int) getpid());\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.use_abort) abort();\n\n\t// restore default handler to generate core\n\tsignal(signum, SIG_DFL);\n\tkill(getpid(), signum);\n\n\t// never here...\n\texit(1);\n}\n\nvoid uwsgi_flush_logs() {\n\n\tstruct pollfd pfd;\n\n\tif (!uwsgi.master_process)\n\t\treturn;\n\tif (!uwsgi.log_master)\n\t\treturn;\n\n\tif (uwsgi.workers) {\n\t\tif (uwsgi.workers[0].pid == getpid()) {\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\n\tif (uwsgi.mywid == 0)\n\t\tgoto check;\n\n\treturn;\n\ncheck:\n\t// this buffer could not be initialized !!!\n\tif (uwsgi.log_master) {\n\t\tuwsgi.log_master_buf = uwsgi_malloc(uwsgi.log_master_bufsize);\n\t}\n\n\t// check for data in logpipe\n\tpfd.events = POLLIN;\n\tpfd.fd = uwsgi.shared->worker_log_pipe[0];\n\tif (pfd.fd == -1)\n\t\tpfd.fd = 2;\n\n\twhile (poll(&pfd, 1, 0) > 0) {\n\t\tif (uwsgi_master_log()) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void plugins_list(void) {\n\tint i;\n\tuwsgi_log(\"\\n*** uWSGI loaded generic plugins ***\\n\");\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tuwsgi_log(\"%s\\n\", uwsgi.gp[i]->name);\n\t}\n\n\tuwsgi_log(\"\\n*** uWSGI loaded request plugins ***\\n\");\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i] == &unconfigured_plugin)\n\t\t\tcontinue;\n\t\tuwsgi_log(\"%d: %s\\n\", i, uwsgi.p[i]->name);\n\t}\n\n\tuwsgi_log(\"--- end of plugins list ---\\n\\n\");\n}\n\nstatic void loggers_list(void) {\n\tstruct uwsgi_logger *ul = uwsgi.loggers;\n\tuwsgi_log(\"\\n*** uWSGI loaded loggers ***\\n\");\n\twhile (ul) {\n\t\tuwsgi_log(\"%s\\n\", ul->name);\n\t\tul = ul->next;\n\t}\n\tuwsgi_log(\"--- end of loggers list ---\\n\\n\");\n}\n\nstatic void cheaper_algo_list(void) {\n\tstruct uwsgi_cheaper_algo *uca = uwsgi.cheaper_algos;\n\tuwsgi_log(\"\\n*** uWSGI loaded cheaper algorithms ***\\n\");\n\twhile (uca) {\n\t\tuwsgi_log(\"%s\\n\", uca->name);\n\t\tuca = uca->next;\n\t}\n\tuwsgi_log(\"--- end of cheaper algorithms list ---\\n\\n\");\n}\n\n#ifdef UWSGI_ROUTING\nstatic void router_list(void) {\n\tstruct uwsgi_router *ur = uwsgi.routers;\n\tuwsgi_log(\"\\n*** uWSGI loaded routers ***\\n\");\n\twhile (ur) {\n\t\tuwsgi_log(\"%s\\n\", ur->name);\n\t\tur = ur->next;\n\t}\n\tuwsgi_log(\"--- end of routers list ---\\n\\n\");\n}\n#endif\n\nstatic void loop_list(void) {\n\tstruct uwsgi_loop *loop = uwsgi.loops;\n\tuwsgi_log(\"\\n*** uWSGI loaded loop engines ***\\n\");\n\twhile (loop) {\n\t\tuwsgi_log(\"%s\\n\", loop->name);\n\t\tloop = loop->next;\n\t}\n\tuwsgi_log(\"--- end of loop engines list ---\\n\\n\");\n}\n\nstatic void imperial_monitor_list(void) {\n\tstruct uwsgi_imperial_monitor *uim = uwsgi.emperor_monitors;\n\tuwsgi_log(\"\\n*** uWSGI loaded imperial monitors ***\\n\");\n\twhile (uim) {\n\t\tuwsgi_log(\"%s\\n\", uim->scheme);\n\t\tuim = uim->next;\n\t}\n\tuwsgi_log(\"--- end of imperial monitors list ---\\n\\n\");\n}\n\nstatic void clocks_list(void) {\n\tstruct uwsgi_clock *clocks = uwsgi.clocks;\n\tuwsgi_log(\"\\n*** uWSGI loaded clocks ***\\n\");\n\twhile (clocks) {\n\t\tuwsgi_log(\"%s\\n\", clocks->name);\n\t\tclocks = clocks->next;\n\t}\n\tuwsgi_log(\"--- end of clocks list ---\\n\\n\");\n}\n\nstatic void alarms_list(void) {\n\tstruct uwsgi_alarm *alarms = uwsgi.alarms;\n\tuwsgi_log(\"\\n*** uWSGI loaded alarms ***\\n\");\n\twhile (alarms) {\n\t\tuwsgi_log(\"%s\\n\", alarms->name);\n\t\talarms = alarms->next;\n\t}\n\tuwsgi_log(\"--- end of alarms list ---\\n\\n\");\n}\n\nstatic time_t uwsgi_unix_seconds() {\n\treturn time(NULL);\n}\n\nstatic uint64_t uwsgi_unix_microseconds() {\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn ((uint64_t) tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nstatic struct uwsgi_clock uwsgi_unix_clock = {\n\t.name = \"unix\",\n\t.seconds = uwsgi_unix_seconds,\n\t.microseconds = uwsgi_unix_microseconds,\n};\n\nvoid uwsgi_init_random() {\n        srand((unsigned int) (uwsgi.start_tv.tv_usec * uwsgi.start_tv.tv_sec));\n}\n\n#ifdef UWSGI_AS_SHARED_LIBRARY\nint uwsgi_init(int argc, char *argv[], char *envp[]) {\n#else\nint main(int argc, char *argv[], char *envp[]) {\n#endif\n\tuwsgi_setup(argc, argv, envp);\n\treturn uwsgi_run();\n}\n\nstatic char *uwsgi_at_file_read(char *filename) {\n\tsize_t size = 0;\n\tchar *buffer = uwsgi_open_and_read(filename, &size, 1, NULL);\n\tif (size > 1) {\n\t\tif (buffer[size-2] == '\\n' || buffer[size-2] == '\\r') {\n\t\t\tbuffer[size-2] = 0;\n\t\t}\n\t}\n\treturn buffer;\n}\n\nvoid uwsgi_setup(int argc, char *argv[], char *envp[]) {\n\tint i;\n\n\tstruct utsname uuts;\n\n\t// signal mask is inherited, and sme process manager could make a real mess...\n\tsigset_t smask;\n        sigfillset(&smask);\n        if (sigprocmask(SIG_UNBLOCK, &smask, NULL)) {\n                uwsgi_error(\"sigprocmask()\");\n        }\n\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGSEGV, uwsgi_segfault);\n\tsignal(SIGFPE, uwsgi_fpe);\n\tsignal(SIGHUP, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t//initialize masterpid with a default value\n\tmasterpid = getpid();\n\n\tmemset(&uwsgi, 0, sizeof(struct uwsgi_server));\n\tuwsgi_proto_hooks_setup();\n\tuwsgi.cwd = uwsgi_get_cwd();\n\n\tinit_magic_table(uwsgi.magic_table);\n\n\t// initialize schemes\n\tuwsgi_setup_schemes();\n\n\t// initialize the clock\n\tuwsgi_register_clock(&uwsgi_unix_clock);\n\tuwsgi_set_clock(\"unix\");\n\n\t// fallback config\n\tatexit(uwsgi_fallback_config);\n\t// manage/flush logs\n\tatexit(uwsgi_flush_logs);\n\t// clear sockets, pidfiles...\n\tatexit(vacuum);\n\t// call user scripts\n\tatexit(uwsgi_exec_atexit);\n#ifdef UWSGI_SSL\n\t// call legions death hooks\n\tatexit(uwsgi_legion_atexit);\n#endif\n\n\t// allocate main shared memory\n\tuwsgi.shared = (struct uwsgi_shared *) uwsgi_calloc_shared(sizeof(struct uwsgi_shared));\n\n\t// initialize request plugin to void\n\tfor (i = 0; i < 256; i++) {\n\t\tuwsgi.p[i] = &unconfigured_plugin;\n\t}\n\n\t// set default values\n\tuwsgi_init_default();\n\n\t// detect cpu cores\n#if defined(_SC_NPROCESSORS_ONLN)\n\tuwsgi.cpus = sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(_SC_NPROCESSORS_CONF)\n\tuwsgi.cpus = sysconf(_SC_NPROCESSORS_CONF);\n#endif\n\t// set default logit hook\n\tuwsgi.logit = uwsgi_logit_simple;\n\n#ifdef UWSGI_BLACKLIST\n\tif (!uwsgi_file_to_string_list(UWSGI_BLACKLIST, &uwsgi.blacklist)) {\n\t\tuwsgi_log(\"you cannot run this build of uWSGI without a blacklist file\\n\");\n\t\texit(1);\n\t}\n#endif\n\n#ifdef UWSGI_WHITELIST\n\tif (!uwsgi_file_to_string_list(UWSGI_WHITELIST, &uwsgi.whitelist)) {\n\t\tuwsgi_log(\"you cannot run this build of uWSGI without a whitelist file\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\t// get startup time\n\tgettimeofday(&uwsgi.start_tv, NULL);\n\n\t// initialize random engine\n\tuwsgi_init_random();\n\n\tsetlinebuf(stdout);\n\n\tuwsgi.rl.rlim_cur = 0;\n\tuwsgi.rl.rlim_max = 0;\n\n\t// are we under systemd ?\n\tchar *notify_socket = getenv(\"NOTIFY_SOCKET\");\n\tif (notify_socket) {\n\t\tuwsgi_systemd_init(notify_socket);\n\t}\n\n\tuwsgi_notify(\"initializing uWSGI\");\n\n\t// check if we are under the Emperor\n\tuwsgi_check_emperor();\n\n\tchar *screen_env = getenv(\"TERM\");\n\tif (screen_env) {\n\t\tif (!strcmp(screen_env, \"screen\")) {\n\t\t\tuwsgi.screen_session = getenv(\"STY\");\n\t\t}\n\t}\n\n\n\t// count/set the current reload status\n\tuwsgi_setup_reload();\n\n#ifdef __CYGWIN__\n\tSYSTEM_INFO si;\n\tGetSystemInfo(&si);\n\tuwsgi.page_size = si.dwPageSize;\n#else\n\tuwsgi.page_size = getpagesize();\n#endif\n\tuwsgi.binary_path = uwsgi_get_binary_path(argv[0]);\n\n\tif(uwsgi.response_header_limit == 0)\n\t\tuwsgi.response_header_limit = UMAX16;\n\n\t// ok we can now safely play with argv and environ\n\tfixup_argv_and_environ(argc, argv, UWSGI_ENVIRON, envp);\n\n\tif (gethostname(uwsgi.hostname, 255)) {\n\t\tuwsgi_error(\"gethostname()\");\n\t}\n\tuwsgi.hostname_len = strlen(uwsgi.hostname);\n\n#ifdef UWSGI_ROUTING\n\tuwsgi_register_embedded_routers();\n#endif\n\n\t// call here to allows plugin to override hooks\n\tuwsgi_register_base_hooks();\n\tuwsgi_register_logchunks();\n\tuwsgi_log_encoders_register_embedded();\n\n\t// register base metrics (so plugins can override them)\n\tuwsgi_metrics_collectors_setup();\n\n\t//initialize embedded plugins\n\tUWSGI_LOAD_EMBEDDED_PLUGINS\n\t\t// now a bit of magic, if the executable basename contains a 'uwsgi_' string,\n\t\t// try to automatically load a plugin\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"executable name: %s\\n\", uwsgi.binary_path);\n#endif\n\tuwsgi_autoload_plugins_by_name(argv[0]);\n\n\n\t// build the options structure\n\tbuild_options();\n\n\t// set a couple of 'static' magic vars\n\tuwsgi.magic_table['v'] = uwsgi.cwd;\n\tuwsgi.magic_table['h'] = uwsgi.hostname;\n\tuwsgi.magic_table['t'] = uwsgi_64bit2str(uwsgi_now());\n\tuwsgi.magic_table['T'] = uwsgi_64bit2str(uwsgi_micros());\n\tuwsgi.magic_table['V'] = UWSGI_VERSION;\n\tuwsgi.magic_table['k'] = uwsgi_num2str(uwsgi.cpus);\n\tuwsgi.magic_table['['] = \"\\033\";\n\tuwsgi.magic_table['u'] = uwsgi_num2str((int)getuid());\n\tstruct passwd *pw = getpwuid(getuid());\n\tuwsgi.magic_table['U'] = pw ? pw->pw_name : uwsgi.magic_table['u'];\n\tuwsgi.magic_table['g'] = uwsgi_num2str((int)getgid());\n\tstruct group *gr = getgrgid(getgid());\n\tuwsgi.magic_table['G'] = gr ? gr->gr_name : uwsgi.magic_table['g'];\n\n\t// you can embed a ini file in the uWSGi binary with default options\n#ifdef UWSGI_EMBED_CONFIG\n\tuwsgi_ini_config(\"\", uwsgi.magic_table);\n\t// rebuild options if a custom ini is set\n\tbuild_options();\n#endif\n\t//parse environ\n\tparse_sys_envs(UWSGI_ENVIRON);\n\n\t// parse commandline options\n\tuwsgi_commandline_config();\n\n\t// second pass: ENVs\n\tuwsgi_apply_config_pass('$', (char *(*)(char *)) getenv);\n\n\t// third pass: FILEs\n\tuwsgi_apply_config_pass('@', uwsgi_at_file_read);\n\n\t// last pass: REFERENCEs\n\tuwsgi_apply_config_pass('%', uwsgi_manage_placeholder);\n\n\t// ok, the options dictionary is available, lets manage it\n\tuwsgi_configure();\n\n\t// fixup cwd\n\tif (uwsgi.force_cwd) uwsgi.cwd = uwsgi.force_cwd;\n\n\t// run \"asap\" hooks\n\tuwsgi_hooks_run(uwsgi.hook_asap, \"asap\", 1);\n        struct uwsgi_string_list *usl = NULL;\n        uwsgi_foreach(usl, uwsgi.mount_asap) {\n        \tuwsgi_log(\"mounting \\\"%s\\\" (asap)...\\n\", usl->value);\n                if (uwsgi_mount_hook(usl->value)) exit(1);\n\t}\n        uwsgi_foreach(usl, uwsgi.umount_asap) {\n        \tuwsgi_log(\"un-mounting \\\"%s\\\" (asap)...\\n\", usl->value);\n                if (uwsgi_umount_hook(usl->value)) exit(1);\n\t}\n        uwsgi_foreach(usl, uwsgi.exec_asap) {\n        \tuwsgi_log(\"running \\\"%s\\\" (asap)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                \tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n\t}\n        uwsgi_foreach(usl, uwsgi.call_asap) {\n        \tif (uwsgi_call_symbol(usl->value)) {\n                \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                        exit(1);\n                }\n\t}\n\n\t// manage envdirs ASAP\n\tuwsgi_envdirs(uwsgi.envdirs);\n\n\t// --get management\n\tstruct uwsgi_string_list *get_list = uwsgi.get_list;\n\twhile(get_list) {\n\t\tchar *v = uwsgi_get_exported_opt(get_list->value);\n\t\tif (v) {\n\t\t\tfprintf(stdout, \"%s\\n\", v);\n\t\t}\n\t\tget_list = get_list->next;\n\t}\n\n\tif (uwsgi.get_list) {\n\t\texit(0);\n\t}\n\n\n\t// initial log setup (files and daemonization)\n\tuwsgi_setup_log();\n\n#ifndef __CYGWIN__\n\t// enable never-swap mode\n\tif (uwsgi.never_swap) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\tuwsgi_error(\"mlockall()\");\n\t\t}\n\t}\n#endif\n\n\tif (uwsgi.flock2)\n\t\tuwsgi_opt_flock(NULL, uwsgi.flock2, NULL);\n\n\tif (uwsgi.flock_wait2)\n\t\tuwsgi_opt_flock(NULL, uwsgi.flock_wait2, NULL);\n\n\t// setup master logging\n\tif (uwsgi.log_master && !uwsgi.daemonize2)\n\t\tuwsgi_setup_log_master();\n\n\t// setup offload engines\n\tuwsgi_offload_engines_register_all();\n\n\t// setup main loops\n\tuwsgi_register_loop(\"simple\", simple_loop);\n\tuwsgi_register_loop(\"async\", async_loop);\n\n\t// setup cheaper algos\n\tuwsgi_register_cheaper_algo(\"spare\", uwsgi_cheaper_algo_spare);\n\tuwsgi_register_cheaper_algo(\"backlog\", uwsgi_cheaper_algo_backlog);\n\tuwsgi_register_cheaper_algo(\"manual\", uwsgi_cheaper_algo_manual);\n\n\t// setup imperial monitors\n\tuwsgi_register_imperial_monitor(\"dir\", uwsgi_imperial_monitor_directory_init, uwsgi_imperial_monitor_directory);\n\tuwsgi_register_imperial_monitor(\"glob\", uwsgi_imperial_monitor_glob_init, uwsgi_imperial_monitor_glob);\n\n\t// setup stats pushers\n\tuwsgi_stats_pusher_setup();\n\n\t// register embedded alarms\n\tuwsgi_register_embedded_alarms();\n\n\t/* uWSGI IS CONFIGURED !!! */\n\n\tif (uwsgi.dump_options) {\n\t\tstruct option *lopt = uwsgi.long_options;\n\t\twhile (lopt && lopt->name) {\n\t\t\tfprintf(stdout, \"%s\\n\", lopt->name);\n\t\t\tlopt++;\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (uwsgi.show_config)\n\t\tshow_config();\n\n\tif (uwsgi.plugins_list)\n\t\tplugins_list();\n\n\tif (uwsgi.loggers_list)\n\t\tloggers_list();\n\n\tif (uwsgi.cheaper_algo_list)\n\t\tcheaper_algo_list();\n\n\n#ifdef UWSGI_ROUTING\n\tif (uwsgi.router_list)\n\t\trouter_list();\n#endif\n\n\n\tif (uwsgi.loop_list)\n\t\tloop_list();\n\n\tif (uwsgi.imperial_monitor_list)\n\t\timperial_monitor_list();\n\n\tif (uwsgi.clock_list)\n\t\tclocks_list();\n\n\tif (uwsgi.alarms_list)\n\t\talarms_list();\n\n\t// set the clock\n\tif (uwsgi.requested_clock)\n\t\tuwsgi_set_clock(uwsgi.requested_clock);\n\n\tif (uwsgi.binary_path == uwsgi.argv[0]) {\n\t\tuwsgi.binary_path = uwsgi_str(uwsgi.argv[0]);\n\t}\n\n\tuwsgi_log_initial(\"*** Starting uWSGI %s (%dbit) on [%.*s] ***\\n\", UWSGI_VERSION, (int) (sizeof(void *)) * 8, 24, ctime((const time_t *) &uwsgi.start_tv.tv_sec));\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"***\\n*** You are running a DEBUG version of uWSGI, please disable debug in your build profile and recompile it ***\\n***\\n\");\n#endif\n\n\tuwsgi_log_initial(\"compiled with version: %s on %s\\n\", __VERSION__, UWSGI_BUILD_DATE);\n\n#ifdef __sun__\n\tif (uname(&uuts) < 0) {\n#else\n\tif (uname(&uuts)) {\n#endif\n\t\tuwsgi_error(\"uname()\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"os: %s-%s %s\\n\", uuts.sysname, uuts.release, uuts.version);\n\t\tuwsgi_log_initial(\"nodename: %s\\n\", uuts.nodename);\n\t\tuwsgi_log_initial(\"machine: %s\\n\", uuts.machine);\n\t}\n\n\tuwsgi_log_initial(\"clock source: %s\\n\", uwsgi.clock->name);\n#ifdef UWSGI_PCRE\n\tif (uwsgi.pcre_jit) {\n\t\tuwsgi_log_initial(\"pcre jit enabled\\n\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"pcre jit disabled\\n\");\n\t}\n#endif\n\n#ifdef __BIG_ENDIAN__\n\tuwsgi_log_initial(\"*** big endian arch detected ***\\n\");\n#endif\n\n\tuwsgi_log_initial(\"detected number of CPU cores: %d\\n\", uwsgi.cpus);\n\n\n\tuwsgi_log_initial(\"current working directory: %s\\n\", uwsgi.cwd);\n\n\tif (uwsgi.screen_session) {\n\t\tuwsgi_log(\"*** running under screen session %s ***\\n\", uwsgi.screen_session);\n\t}\n\n\tif (uwsgi.pidfile && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile);\n\t}\n\n\tuwsgi_log_initial(\"detected binary path: %s\\n\", uwsgi.binary_path);\n\n\tif (uwsgi.is_a_reload) {\n\t\tstruct rlimit rl;\n\t\tif (!getrlimit(RLIMIT_NOFILE, &rl)) {\n\t\t\tuwsgi.max_fd = rl.rlim_cur;\n\t\t}\n\t}\n\n#ifdef UWSGI_ROUTING\n\tuwsgi_routing_dump();\n#else\n\tuwsgi_log(\"!!! no internal routing support, rebuild with pcre support !!!\\n\");\n#endif\n\n\t// initialize shared sockets\n\tuwsgi_setup_shared_sockets();\n\n#ifdef __linux__\n\tif (uwsgi.setns_preopen) {\n\t\tuwsgi_setns_preopen();\n\t}\n\t// eventually join a linux namespace\n\tif (uwsgi.setns) {\n\t\tuwsgi_setns(uwsgi.setns);\n\t}\n#endif\n\n\t// start the Emperor if needed\n\tif (uwsgi.early_emperor && uwsgi.emperor) {\n\t\tuwsgi_emperor_start();\n\t}\n\n\tif (!uwsgi.reloads) {\n\t\tuwsgi_hooks_run(uwsgi.hook_pre_jail, \"pre-jail\", 1);\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tuwsgi_foreach(usl, uwsgi.mount_pre_jail) {\n                                uwsgi_log(\"mounting \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n                                if (uwsgi_mount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n                        uwsgi_foreach(usl, uwsgi.umount_pre_jail) {\n                                uwsgi_log(\"un-mounting \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n                                if (uwsgi_umount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\t\t// run the pre-jail scripts\n\t\tuwsgi_foreach(usl, uwsgi.exec_pre_jail) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_pre_jail) {\n\t\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// we could now patch the binary\n\tif (uwsgi.privileged_binary_patch) {\n\t\tuwsgi.argv[0] = uwsgi.privileged_binary_patch;\n\t\texecvp(uwsgi.privileged_binary_patch, uwsgi.argv);\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.privileged_binary_patch_arg) {\n\t\tuwsgi_exec_command_with_args(uwsgi.privileged_binary_patch_arg);\n\t}\n\n\n\t// call jail systems\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->jail) {\n\t\t\tuwsgi.gp[i]->jail(uwsgi_start, uwsgi.argv);\n\t\t}\n\t}\n\n\t// TODO pluginize basic Linux namespace support\n#if defined(__linux__) && !defined(__ia64__)\n\tif (uwsgi.ns) {\n\t\tlinux_namespace_start((void *) uwsgi.argv);\n\t\t// never here\n\t}\n\telse {\n#endif\n\t\tuwsgi_start((void *) uwsgi.argv);\n#if defined(__linux__) && !defined(__ia64__)\n\t}\n#endif\n\n\tif (uwsgi.safe_pidfile && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile_explicit(uwsgi.safe_pidfile, masterpid);\n\t}\n}\n\n\nint uwsgi_start(void *v_argv) {\n\n\tint i, j;\n\n#ifdef __linux__\n\tuwsgi_set_cgroup();\n\n#if !defined(__ia64__)\n\tif (uwsgi.ns) {\n\t\tlinux_namespace_jail();\n\t}\n#endif\n#endif\n\n\tuwsgi_hooks_run(uwsgi.hook_in_jail, \"in-jail\", 1);\n\n\tstruct uwsgi_string_list *usl;\n\n\tuwsgi_foreach(usl, uwsgi.mount_in_jail) {\n                                uwsgi_log(\"mounting \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                                if (uwsgi_mount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n                        uwsgi_foreach(usl, uwsgi.umount_in_jail) {\n                                uwsgi_log(\"un-mounting \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                                if (uwsgi_umount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n\tuwsgi_foreach(usl, uwsgi.exec_in_jail) {\n                uwsgi_log(\"running \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                        uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n        }\n\n        uwsgi_foreach(usl, uwsgi.call_in_jail) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n                }\n        }\n\n\n\tuwsgi_file_write_do(uwsgi.file_write_list);\n\n\tif (!uwsgi.master_as_root && !uwsgi.chown_socket && !uwsgi.drop_after_init && !uwsgi.drop_after_apps) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// wait for socket\n\tuwsgi_foreach(usl, uwsgi.wait_for_socket) {\n\t\tif (uwsgi_wait_for_socket(usl->value)) exit(1);\n\t}\n\n\tif (uwsgi.logto2) {\n\t\tif (!uwsgi.is_a_reload || uwsgi.log_reopen) {\n\t\t\tlogto(uwsgi.logto2);\n\t\t}\n\t}\n\n\tif (uwsgi.chdir) {\n\t\tuwsgi_log(\"chdir() to %s\\n\", uwsgi.chdir);\n\t\tif (chdir(uwsgi.chdir)) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.pidfile2 && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile2);\n\t}\n\n\tif (!uwsgi.master_process && !uwsgi.command_mode) {\n\t\tuwsgi_log_initial(\"*** WARNING: you are running uWSGI without its master process manager ***\\n\");\n\t}\n\n#ifdef RLIMIT_NPROC\n\tif (uwsgi.rl_nproc.rlim_max > 0) {\n\t\tuwsgi.rl_nproc.rlim_cur = uwsgi.rl_nproc.rlim_max;\n\t\tuwsgi_log_initial(\"limiting number of processes to %d...\\n\", (int) uwsgi.rl_nproc.rlim_max);\n\t\tif (setrlimit(RLIMIT_NPROC, &uwsgi.rl_nproc)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\n\tif (!getrlimit(RLIMIT_NPROC, &uwsgi.rl_nproc)) {\n\t\tif (uwsgi.rl_nproc.rlim_cur != RLIM_INFINITY) {\n\t\t\tuwsgi_log_initial(\"your processes number limit is %d\\n\", (int) uwsgi.rl_nproc.rlim_cur);\n\t\t\tif ((int) uwsgi.rl_nproc.rlim_cur < uwsgi.numproc + uwsgi.master_process) {\n\t\t\t\tuwsgi.numproc = uwsgi.rl_nproc.rlim_cur - 1;\n\t\t\t\tuwsgi_log_initial(\"!!! number of workers adjusted to %d due to system limits !!!\\n\", uwsgi.numproc);\n\t\t\t}\n\t\t}\n\t}\n#endif\n#ifndef __OpenBSD__\n\n\tif (uwsgi.rl.rlim_max > 0) {\n\t\tuwsgi.rl.rlim_cur = uwsgi.rl.rlim_max;\n\t\tuwsgi_log_initial(\"limiting address space of processes...\\n\");\n\t\tif (setrlimit(RLIMIT_AS, &uwsgi.rl)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\tif (uwsgi.prio != 0) {\n#ifdef __HAIKU__\n\t\tif (set_thread_priority(find_thread(NULL), uwsgi.prio) == B_BAD_THREAD_ID) {\n\t\t\tuwsgi_error(\"set_thread_priority()\");\n#else\n\t\tif (setpriority(PRIO_PROCESS, 0, uwsgi.prio)) {\n\t\t\tuwsgi_error(\"setpriority()\");\n#endif\n\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log_initial(\"scheduler priority set to %d\\n\", uwsgi.prio);\n\t\t}\n\t}\n\tif (!getrlimit(RLIMIT_AS, &uwsgi.rl)) {\n\t\t//check for overflow\n\t\tif (uwsgi.rl.rlim_max != (rlim_t) RLIM_INFINITY) {\n\t\t\tuwsgi_log_initial(\"your process address space limit is %lld bytes (%lld MB)\\n\", (long long) uwsgi.rl.rlim_max, (long long) uwsgi.rl.rlim_max / 1024 / 1024);\n\t\t}\n\t}\n#endif\n\n\tuwsgi_log_initial(\"your memory page size is %d bytes\\n\", uwsgi.page_size);\n\n\t// automatically fix options\n\tsanitize_args();\n\n\n\tif (uwsgi.requested_max_fd) {\n\t\tuwsgi.rl.rlim_cur = uwsgi.requested_max_fd;\n\t\tuwsgi.rl.rlim_max = uwsgi.requested_max_fd;\n\t\tif (setrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\n\tif (!getrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\tuwsgi.max_fd = uwsgi.rl.rlim_cur;\n\t\tuwsgi_log_initial(\"detected max file descriptor number: %lu\\n\", (unsigned long) uwsgi.max_fd);\n\t}\n\n\t// start the Emperor if needed\n\tif (!uwsgi.early_emperor && uwsgi.emperor) {\n\t\tuwsgi_emperor_start();\n\t}\n\n\t// end of generic initialization\n\n\n\t// build mime.types dictionary\n\tif (uwsgi.build_mime_dict) {\n\t\tif (!uwsgi.mime_file)\n#ifdef __APPLE__\n\t\t\tuwsgi_string_new_list(&uwsgi.mime_file, \"/etc/apache2/mime.types\");\n#else\n\t\t\tuwsgi_string_new_list(&uwsgi.mime_file, \"/etc/mime.types\");\n#endif\n\t\tstruct uwsgi_string_list *umd = uwsgi.mime_file;\n\t\twhile (umd) {\n\t\t\tif (!access(umd->value, R_OK)) {\n\t\t\t\tuwsgi_build_mime_dict(umd->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"!!! no %s file found !!!\\n\", umd->value);\n\t\t\t}\n\t\t\tumd = umd->next;\n\t\t}\n\t}\n\n\tif (uwsgi.async > 1) {\n\t\tif ((unsigned long) uwsgi.max_fd < (unsigned long) uwsgi.async) {\n\t\t\tuwsgi_log_initial(\"- your current max open files limit is %lu, this is lower than requested async cores !!! -\\n\", (unsigned long) uwsgi.max_fd);\n\t\t\tuwsgi.rl.rlim_cur = uwsgi.async;\n\t\t\tuwsgi.rl.rlim_max = uwsgi.async;\n\t\t\tif (!setrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\t\t\tuwsgi_log(\"max open files limit raised to %lu\\n\", (unsigned long) uwsgi.rl.rlim_cur);\n\t\t\t\tuwsgi.async = uwsgi.rl.rlim_cur;\n\t\t\t\tuwsgi.max_fd = uwsgi.rl.rlim_cur;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi.async = (int) uwsgi.max_fd;\n\t\t\t}\n\t\t}\n\t\tuwsgi_log_initial(\"- async cores set to %d - fd table size: %d\\n\", uwsgi.async, (int) uwsgi.max_fd);\n\t}\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"cores allocated...\\n\");\n#endif\n\n\tif (uwsgi.vhost) {\n\t\tuwsgi_log_initial(\"VirtualHosting mode enabled.\\n\");\n\t}\n\n\t// setup locking\n\tuwsgi_setup_locking();\n\tif (uwsgi.use_thunder_lock) {\n\t\tuwsgi_log_initial(\"thunder lock: enabled\\n\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"thunder lock: disabled (you can enable it with --thunder-lock)\\n\");\n\t}\n\n\t// allocate rpc structures\n        uwsgi_rpc_init();\n\n\t// initialize sharedareas\n\tuwsgi_sharedareas_init();\n\n\tuwsgi.snmp_lock = uwsgi_lock_init(\"snmp\");\n\n\t// setup queue\n\tif (uwsgi.queue_size > 0) {\n\t\tuwsgi_init_queue();\n\t}\n\n\tuwsgi_cache_create_all();\n\n\tif (uwsgi.use_check_cache) {\n\t\tuwsgi.check_cache = uwsgi_cache_by_name(uwsgi.use_check_cache);\n\t\tif (!uwsgi.check_cache) {\n\t\t\tuwsgi_log(\"unable to find cache \\\"%s\\\"\\n\", uwsgi.use_check_cache);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.use_static_cache_paths) {\n\t\tif (uwsgi.static_cache_paths_name) {\n\t\t\tuwsgi.static_cache_paths = uwsgi_cache_by_name(uwsgi.static_cache_paths_name);\n\t\t\tif (!uwsgi.static_cache_paths) {\n\t\t\t\tuwsgi_log(\"unable to find cache \\\"%s\\\"\\n\", uwsgi.static_cache_paths_name);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!uwsgi.caches) {\n                \t\tuwsgi_log(\"caching of static paths requires uWSGI caching !!!\\n\");\n                \t\texit(1);\n\t\t\t}\n\t\t\tuwsgi.static_cache_paths = uwsgi.caches;\n\t\t}\n        }\n\n        // initialize the alarm subsystem\n        uwsgi_alarms_init();\n\n\t// initialize the exception handlers\n\tuwsgi_exception_setup_handlers();\n\n\t// initialize socket protocols (do it after caching !!!)\n\tuwsgi_protocols_register();\n\n\t/* plugin initialization */\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->init) {\n\t\t\tuwsgi.gp[i]->init();\n\t\t}\n\t}\n\n\tif (!uwsgi.no_server) {\n\n\t\t// systemd/upstart/zerg socket activation\n\t\tif (!uwsgi.is_a_reload) {\n\t\t\tuwsgi_setup_systemd();\n\t\t\tuwsgi_setup_upstart();\n\t\t\tuwsgi_setup_zerg();\n\t\t\tuwsgi_setup_emperor();\n\t\t}\n\n\n\t\t//check for inherited sockets\n\t\tif (uwsgi.is_a_reload) {\n\t\t\tuwsgi_setup_inherited_sockets();\n\t\t}\n\n\n\t\t//now bind all the unbound sockets\n\t\tuwsgi_bind_sockets();\n\n\t\tif (!uwsgi.master_as_root && !uwsgi.drop_after_init && !uwsgi.drop_after_apps) {\n\t\t\tuwsgi_as_root();\n\t\t}\n\n\t\t// put listening socket in non-blocking state and set the protocol\n\t\tuwsgi_set_sockets_protocols();\n\n\t}\n\n\n\t// initialize request plugin only if workers or master are available\n\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (uwsgi.p[i]->init) {\n\t\t\t\tuwsgi.p[i]->init();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!uwsgi.master_as_root && !uwsgi.drop_after_apps) {\n\t\tuwsgi_as_root();\n\t}\n\n\n\t/* gp/plugin initialization */\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->post_init) {\n\t\t\tuwsgi.gp[i]->post_init();\n\t\t}\n\t}\n\n\t// again check for workers/sockets...\n\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (uwsgi.p[i]->post_init) {\n\t\t\t\tuwsgi.p[i]->post_init();\n\t\t\t}\n\t\t}\n\t}\n\n\tuwsgi.current_wsgi_req = simple_current_wsgi_req;\n\n\n\tif (uwsgi.has_threads) {\n\t\tif (uwsgi.threads > 1)\n\t\t\tuwsgi.current_wsgi_req = threaded_current_wsgi_req;\n\t\t(void) pthread_attr_init(&uwsgi.threads_attr);\n\t\tif (uwsgi.threads_stacksize) {\n\t\t\tif (pthread_attr_setstacksize(&uwsgi.threads_attr, uwsgi.threads_stacksize * 1024) == 0) {\n\t\t\t\tuwsgi_log(\"threads stack size set to %luk\\n\", (unsigned long) uwsgi.threads_stacksize);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"!!! unable to set requested threads stacksize !!!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_init(&uwsgi.lock_static, NULL);\n\n\t\t// again check for workers/sockets...\n\t\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\tif (uwsgi.p[i]->enable_threads)\n\t\t\t\t\tuwsgi.p[i]->enable_threads();\n\t\t\t}\n\t\t}\n\t}\n\n\t// users of the --loop option should know what they are doing... really...\n#ifndef UWSGI_DEBUG\n\tif (uwsgi.loop)\n\t\tgoto unsafe;\n#endif\n\n\tif (!uwsgi.sockets &&\n\t\t!ushared->gateways_cnt &&\n\t\t!uwsgi.no_server &&\n\t\t!uwsgi.udp_socket &&\n\t\t!uwsgi.emperor &&\n\t\t!uwsgi.command_mode &&\n\t\t!uwsgi.daemons_cnt &&\n\t\t!uwsgi.crons &&\n\t\t!uwsgi.spoolers &&\n\t\t!uwsgi.emperor_proxy\n#ifdef __linux__\n\t\t&& !uwsgi.setns_socket\n#endif\n#ifdef UWSGI_SSL\n&& !uwsgi.legions\n#endif\n\t\t) {\n\t\tuwsgi_log(\"The -s/--socket option is missing and stdin is not a socket.\\n\");\n\t\texit(1);\n\t}\n\telse if (!uwsgi.sockets && ushared->gateways_cnt && !uwsgi.no_server && !uwsgi.master_process) {\n\t\t// here we will have a zombie... sorry\n\t\tuwsgi_log(\"...you should enable the master process... really...\\n\");\n\t\tif (uwsgi.force_gateway) {\n\t\t\tstruct uwsgi_gateway *ug = &ushared->gateways[0];\n\t\t\tug->loop(0, ug->data);\n\t\t\t// when we are here the gateway is dead :(\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (!uwsgi.sockets)\n\t\tuwsgi.numproc = 0;\n\n\tif (uwsgi.command_mode) {\n\t\tuwsgi.sockets = NULL;\n\t\tuwsgi.numproc = 1;\n\t\t// hack to destroy the instance after command exit\n\t\tuwsgi.status.brutally_destroying = 1;\n\t}\n\n#ifndef UWSGI_DEBUG\nunsafe:\n#endif\n\n#ifdef UWSGI_DEBUG\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint so_bufsize;\n\tsocklen_t so_bufsize_len;\n\twhile (uwsgi_sock) {\n\t\tso_bufsize_len = sizeof(int);\n\t\tif (getsockopt(uwsgi_sock->fd, SOL_SOCKET, SO_RCVBUF, &so_bufsize, &so_bufsize_len)) {\n\t\t\tuwsgi_error(\"getsockopt()\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_debug(\"uwsgi socket %d SO_RCVBUF size: %d\\n\", i, so_bufsize);\n\t\t}\n\n\t\tso_bufsize_len = sizeof(int);\n\t\tif (getsockopt(uwsgi_sock->fd, SOL_SOCKET, SO_SNDBUF, &so_bufsize, &so_bufsize_len)) {\n\t\t\tuwsgi_error(\"getsockopt()\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_debug(\"uwsgi socket %d SO_SNDBUF size: %d\\n\", i, so_bufsize);\n\t\t}\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n#endif\n\n\n#ifndef UNBIT\n\tif (uwsgi.sockets)\n\t\tuwsgi_log(\"your server socket listen backlog is limited to %d connections\\n\", uwsgi.listen_queue);\n#endif\n\n\tuwsgi_log(\"your mercy for graceful operations on workers is %d seconds\\n\", uwsgi.worker_reload_mercy);\n\n\tif (uwsgi.crons) {\n\t\tstruct uwsgi_cron *ucron = uwsgi.crons;\n\t\twhile (ucron) {\n#ifdef UWSGI_SSL\n\t\t\tif (ucron->legion) {\n\t\t\t\tuwsgi_log(\"[uwsgi-cron] command \\\"%s\\\" registered as cron task for legion \\\"%s\\\"\\n\", ucron->command, ucron->legion);\n\t\t\t\tucron = ucron->next;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tuwsgi_log(\"[uwsgi-cron] command \\\"%s\\\" registered as cron task\\n\", ucron->command);\n\t\t\tucron = ucron->next;\n\t\t}\n\t}\n\n\n\t// initialize post buffering values\n\tif (uwsgi.post_buffering > 0)\n\t\tuwsgi_setup_post_buffering();\n\n\t// initialize workers/master shared memory segments\n\tuwsgi_setup_workers();\n\n\t// create signal pipes if master is enabled\n\tif (uwsgi.master_process) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tcreate_signal_pipe(uwsgi.workers[i].signal_pipe);\n\t\t}\n\t}\n\n\t// set masterpid\n\tuwsgi.mypid = getpid();\n\tmasterpid = uwsgi.mypid;\n\tuwsgi.workers[0].pid = masterpid;\n\n\t// initialize mules and farms\n\tuwsgi_setup_mules_and_farms();\n\n\tif (uwsgi.command_mode) {\n\t\tuwsgi_log(\"*** Operational MODE: command ***\\n\");\n\t}\n\telse if (!uwsgi.numproc) {\n\t\tuwsgi_log(\"*** Operational MODE: no-workers ***\\n\");\n\t}\n\telse if (uwsgi.threads > 1) {\n\t\tif (uwsgi.numproc > 1) {\n\t\t\tuwsgi_log(\"*** Operational MODE: preforking+threaded ***\\n\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** Operational MODE: threaded ***\\n\");\n\t\t}\n\t}\n\telse if (uwsgi.async > 1) {\n\t\tif (uwsgi.numproc > 1) {\n\t\t\tuwsgi_log(\"*** Operational MODE: preforking+async ***\\n\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** Operational MODE: async ***\\n\");\n\t\t}\n\t}\n\telse if (uwsgi.numproc > 1) {\n\t\tuwsgi_log(\"*** Operational MODE: preforking ***\\n\");\n\t}\n\telse {\n\t\tuwsgi_log(\"*** Operational MODE: single process ***\\n\");\n\t}\n\n\t// set a default request structure (for loading apps...)\n\tuwsgi.wsgi_req = &uwsgi.workers[0].cores[0].req;\n\n\t// ok, let's initialize the metrics subsystem\n\tuwsgi_setup_metrics();\n\n\t// cores are allocated, lets allocate logformat (if required)\n\tif (uwsgi.logformat) {\n\t\tuwsgi_build_log_format(uwsgi.logformat);\n\t\tuwsgi.logit = uwsgi_logit_lf;\n\t\t// TODO check it\n\t\t//if (uwsgi.logformat_strftime) {\n\t\t\t//uwsgi.logit = uwsgi_logit_lf_strftime;\n\t\t//}\n\t\tuwsgi.logvectors = uwsgi_malloc(sizeof(struct iovec *) * uwsgi.cores);\n\t\tfor (j = 0; j < uwsgi.cores; j++) {\n\t\t\tuwsgi.logvectors[j] = uwsgi_malloc(sizeof(struct iovec) * uwsgi.logformat_vectors);\n\t\t\tuwsgi.logvectors[j][uwsgi.logformat_vectors - 1].iov_base = \"\\n\";\n\t\t\tuwsgi.logvectors[j][uwsgi.logformat_vectors - 1].iov_len = 1;\n\t\t}\n\t}\n\n\t// initialize locks and socket as soon as possible, as the master could enqueue tasks\n\tif (uwsgi.spoolers != NULL) {\n\t\tcreate_signal_pipe(uwsgi.shared->spooler_signal_pipe);\n\t\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\t\twhile (uspool) {\n\t\t\t// lock is required even in EXTERNAL mode\n\t\t\tuspool->lock = uwsgi_lock_init(uwsgi_concat2(\"spooler on \", uspool->dir));\n\t\t\tif (uspool->mode == UWSGI_SPOOLER_EXTERNAL)\n\t\t\t\tgoto next;\n\t\t\tcreate_signal_pipe(uspool->signal_pipe);\nnext:\n\t\t\tuspool = uspool->next;\n\t\t}\n\t}\n\n\t// preinit apps (create the language environment)\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->preinit_apps) {\n\t\t\tuwsgi.p[i]->preinit_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->preinit_apps) {\n\t\t\tuwsgi.gp[i]->preinit_apps();\n\t\t}\n\t}\n\n\t//init apps hook (if not lazy)\n\tif (!uwsgi.lazy && !uwsgi.lazy_apps) {\n\t\tuwsgi_init_all_apps();\n\t}\n\n\t// Register uwsgi atexit plugin callbacks after all applications have\n\t// been loaded. This ensures plugin atexit callbacks are called prior\n\t// to application registered atexit callbacks.\n\tatexit(uwsgi_plugins_atexit);\n\n\tif (!uwsgi.master_as_root) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// postinit apps (setup specific features after app initialization)\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->postinit_apps) {\n\t\t\tuwsgi.p[i]->postinit_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->postinit_apps) {\n\t\t\tuwsgi.gp[i]->postinit_apps();\n\t\t}\n\t}\n\n\t// initialize after_request hooks\n\tuwsgi_foreach(usl, uwsgi.after_request_hooks) {\n\t\tusl->custom_ptr =  dlsym(RTLD_DEFAULT, usl->value);\n\t\tif (!usl->custom_ptr) {\n\t\t\tuwsgi_log(\"unable to find symbol/function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi_log(\"added \\\"%s(struct wsgi_request *)\\\" to the after-request chain\\n\", usl->value);\n\t}\n\n\tif (uwsgi.daemonize2) {\n\t\tmasterpid = uwsgi_daemonize2();\n\t}\n\n\tif (uwsgi.no_server) {\n\t\tuwsgi_log(\"no-server mode requested. Goodbye.\\n\");\n\t\texit(0);\n\t}\n\n\n\tif (!uwsgi.master_process && uwsgi.numproc == 0) {\n\t\texit(0);\n\t}\n\n\tif (!uwsgi.single_interpreter && uwsgi.numproc > 0) {\n\t\tuwsgi_log(\"*** uWSGI is running in multiple interpreter mode ***\\n\");\n\t}\n\n\t// check for request plugins, and eventually print a warning\n\tint rp_available = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i] != &unconfigured_plugin) {\n\t\t\trp_available = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!rp_available && !ushared->gateways_cnt) {\n\t\tuwsgi_log(\"!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!\\n\");\n\t\tuwsgi_log(\"no request plugin is loaded, you will not be able to manage requests.\\n\");\n\t\tuwsgi_log(\"you may need to install the package for your language of choice, or simply load it with --plugin.\\n\");\n\t\tuwsgi_log(\"!!!!!!!!!!! END OF WARNING !!!!!!!!!!\\n\");\n\t}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\tif (uwsgi.linux_ksm > 0) {\n\t\tuwsgi_log(\"[uwsgi-KSM] enabled with frequency: %d\\n\", uwsgi.linux_ksm);\n\t}\n#endif\n#endif\n\n\tif (uwsgi.master_process) {\n\t\t// initialize threads with shared state\n\t\tuwsgi_alarm_thread_start();\n        \tuwsgi_exceptions_handler_thread_start();\n\t\t// initialize a mutex to avoid glibc problem with pthread+fork()\n\t\tif (uwsgi.threaded_logger) {\n\t\t\tpthread_mutex_init(&uwsgi.threaded_logger_lock, NULL);\n\t\t}\n\n\t\tif (uwsgi.is_a_reload) {\n\t\t\tuwsgi_log(\"gracefully (RE)spawned uWSGI master process (pid: %d)\\n\", uwsgi.mypid);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"spawned uWSGI master process (pid: %d)\\n\", uwsgi.mypid);\n\t\t}\n\t}\n\n\n\n\t// security in multiuser environment: allow only a subset of modifiers\n\tif (uwsgi.allowed_modifiers) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (!uwsgi_list_has_num(uwsgi.allowed_modifiers, i)) {\n\t\t\t\tuwsgi.p[i]->request = unconfigured_hook;\n\t\t\t\tuwsgi.p[i]->after_request = unconfigured_after_hook;\n\t\t\t}\n\t\t}\n\t}\n\n\t// master fixup\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->master_fixup) {\n\t\t\tuwsgi.p[i]->master_fixup(0);\n\t\t}\n\t}\n\n\n\n\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\twhile (uspool) {\n\t\tif (uspool->mode == UWSGI_SPOOLER_EXTERNAL)\n\t\t\tgoto next2;\n\t\tuspool->pid = spooler_start(uspool);\nnext2:\n\t\tuspool = uspool->next;\n\t}\n\n\tif (!uwsgi.master_process) {\n\t\tif (uwsgi.numproc == 1) {\n\t\t\tuwsgi_log(\"spawned uWSGI worker 1 (and the only) (pid: %d, cores: %d)\\n\", masterpid, uwsgi.cores);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"spawned uWSGI worker 1 (pid: %d, cores: %d)\\n\", masterpid, uwsgi.cores);\n\t\t}\n\t\tuwsgi.workers[1].pid = masterpid;\n\t\tuwsgi.workers[1].id = 1;\n\t\tuwsgi.workers[1].last_spawn = uwsgi_now();\n\t\tuwsgi.workers[1].manage_next_request = 1;\n\t\tuwsgi.mywid = 1;\n\t\tuwsgi.respawn_delta = uwsgi_now();\n\t}\n\telse {\n\t\t// setup internal signalling system\n\t\tcreate_signal_pipe(uwsgi.shared->worker_signal_pipe);\n\t\tuwsgi.signal_socket = uwsgi.shared->worker_signal_pipe[1];\n\t}\n\n\t// uWSGI is ready\n\tuwsgi_notify_ready();\n\tuwsgi.current_time = uwsgi_now();\n\n\t// here we spawn the workers...\n\tif (!uwsgi.status.is_cheap) {\n\t\tif (uwsgi.cheaper && uwsgi.cheaper_count) {\n\t\t\tint nproc = uwsgi.cheaper_initial;\n\t\t\tif (!nproc)\n\t\t\t\tnproc = uwsgi.cheaper_count;\n\t\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\t\tif (i <= nproc) {\n\t\t\t\t\tif (uwsgi_respawn_worker(i))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tuwsgi.respawn_delta = uwsgi_now();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi.workers[i].cheaped = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (i = 2 - uwsgi.master_process; i < uwsgi.numproc + 1; i++) {\n\t\t\t\tif (uwsgi_respawn_worker(i))\n\t\t\t\t\tbreak;\n\t\t\t\tuwsgi.respawn_delta = uwsgi_now();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.safe_pidfile2 && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile_explicit(uwsgi.safe_pidfile2, masterpid);\n\t}\n\n\t// END OF INITIALIZATION\n\treturn 0;\n\n}\n\n// this lives in a worker thread and periodically scans for memory usage\n// when evil reloaders are in place\nvoid *mem_collector(void *foobar) {\n\t// block all signals\n        sigset_t smask;\n        sigfillset(&smask);\n        pthread_sigmask(SIG_BLOCK, &smask, NULL);\n\tuwsgi_log_verbose(\"mem-collector thread started for worker %d\\n\", uwsgi.mywid);\n\tfor(;;) {\n\t\tsleep(uwsgi.mem_collector_freq);\n\t\tuint64_t rss, vsz;\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t}\n\treturn NULL;\n}\n\nint uwsgi_run() {\n\n\t// !!! from now on, we could be in the master or in a worker !!!\n\tint i;\n\n\tif (getpid() == masterpid && uwsgi.master_process == 1) {\n#ifdef UWSGI_AS_SHARED_LIBRARY\n\t\tint ml_ret = master_loop(uwsgi.argv, uwsgi.environ);\n\t\tif (ml_ret == -1) {\n\t\t\treturn 0;\n\t\t}\n#else\n\t\t(void) master_loop(uwsgi.argv, uwsgi.environ);\n#endif\n\t\t//from now on the process is a real worker\n\t}\n\n#if defined(__linux__) && defined(PR_SET_PDEATHSIG)\n\t// avoid workers running without master at all costs !!! (dangerous)\n\tif (uwsgi.master_process && uwsgi.no_orphans) {\n\t\tif (prctl(PR_SET_PDEATHSIG, SIGKILL)) {\n\t\t\tuwsgi_error(\"uwsgi_run()/prctl()\");\n\t\t}\n\t}\n#endif\n\n\tif (uwsgi.evil_reload_on_rss || uwsgi.evil_reload_on_as) {\n\t\tpthread_t t;\n\t\tpthread_create(&t, NULL, mem_collector, NULL);\n\t}\n\n\n\t// eventually maps (or disable) sockets for the  worker\n\tuwsgi_map_sockets();\n\n\t// eventually set cpu affinity poilicies (OS-dependent)\n\tuwsgi_set_cpu_affinity();\n\n\tif (uwsgi.worker_exec) {\n\t\tchar *w_argv[2];\n\t\tw_argv[0] = uwsgi.worker_exec;\n\t\tw_argv[1] = NULL;\n\n\t\tuwsgi.sockets->arg &= (~O_NONBLOCK);\n\t\tif (fcntl(uwsgi.sockets->fd, F_SETFL, uwsgi.sockets->arg) < 0) {\n\t\t\tuwsgi_error(\"fcntl()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (uwsgi.sockets->fd != 0 && !uwsgi.honour_stdin) {\n\t\t\tif (dup2(uwsgi.sockets->fd, 0) < 0) {\n\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t}\n\t\t}\n\t\texecvp(w_argv[0], w_argv);\n\t\t// never here\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.master_as_root) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// set default wsgi_req (for loading apps);\n\tuwsgi.wsgi_req = &uwsgi.workers[uwsgi.mywid].cores[0].req;\n\n\tif (uwsgi.offload_threads > 0) {\n\t\tuwsgi.offload_thread = uwsgi_malloc(sizeof(struct uwsgi_thread *) * uwsgi.offload_threads);\n\t\tfor(i=0;i<uwsgi.offload_threads;i++) {\n\t\t\tuwsgi.offload_thread[i] = uwsgi_offload_thread_start();\n\t\t\tif (!uwsgi.offload_thread[i]) {\n\t\t\t\tuwsgi_log(\"unable to start offload thread %d for worker %d !!!\\n\", i, uwsgi.mywid);\n\t\t\t\tuwsgi.offload_threads = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tuwsgi_log(\"spawned %d offload threads for uWSGI worker %d\\n\", uwsgi.offload_threads, uwsgi.mywid);\n\t}\n\n\t// must be run before running apps\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->post_fork) {\n\t\t\tuwsgi.p[i]->post_fork();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->post_fork) {\n                        uwsgi.gp[i]->post_fork();\n                }\n        }\n\n\tuwsgi_hooks_run(uwsgi.hook_post_fork, \"post-fork\", 1);\n\n\tif (uwsgi.worker_exec2) {\n                char *w_argv[2];\n                w_argv[0] = uwsgi.worker_exec2;\n                w_argv[1] = NULL;\n\n                uwsgi.sockets->arg &= (~O_NONBLOCK);\n                if (fcntl(uwsgi.sockets->fd, F_SETFL, uwsgi.sockets->arg) < 0) {\n                        uwsgi_error(\"fcntl()\");\n                        exit(1);\n                }\n\n                if (uwsgi.sockets->fd != 0 && !uwsgi.honour_stdin) {\n                        if (dup2(uwsgi.sockets->fd, 0) < 0) {\n                                uwsgi_error(\"dup2()\");\n                        }\n                }\n                execvp(w_argv[0], w_argv);\n                // never here\n                uwsgi_error(\"execvp()\");\n                exit(1);\n        }\n\n\t// must be run before running apps\n\n\t// check for worker override\n        for (i = 0; i < 256; i++) {\n                if (uwsgi.p[i]->worker) {\n                        if (uwsgi.p[i]->worker()) {\n\t\t\t\t_exit(0);\n\t\t\t}\n                }\n        }\n\n        for (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->worker) {\n                        if (uwsgi.gp[i]->worker()) {\n\t\t\t\t_exit(0);\n\t\t\t}\n                }\n        }\n\n\tuwsgi_worker_run();\n\t// never here\n\t_exit(0);\n\n}\n\nvoid uwsgi_worker_run() {\n\n\tint i;\n\n\tif (uwsgi.lazy || uwsgi.lazy_apps) {\n\t\tuwsgi_init_all_apps();\n\t}\n\n\t// some apps could be mounted only on specific workers\n\tuwsgi_init_worker_mount_apps();\n\n\tif (uwsgi.async > 1) {\n\t\t// a stack of unused cores\n        \tuwsgi.async_queue_unused = uwsgi_malloc(sizeof(struct wsgi_request *) * uwsgi.async);\n\n        \t// fill it with default values\n               for (i = 0; i < uwsgi.async; i++) {\n               \tuwsgi.async_queue_unused[i] = &uwsgi.workers[uwsgi.mywid].cores[i].req;\n               }\n\n                // the first available core is the last one\n                uwsgi.async_queue_unused_ptr = uwsgi.async - 1;\n\t}\n\n\t// setup UNIX signals for the worker\n\tif (uwsgi.harakiri_options.workers > 0 && !uwsgi.master_process) {\n\t\tsignal(SIGALRM, (void *) &harakiri);\n\t}\n\tuwsgi_unix_signal(SIGHUP, gracefully_kill);\n\tuwsgi_unix_signal(SIGINT, end_me);\n\tuwsgi_unix_signal(SIGTERM, end_me);\n\n\tuwsgi_unix_signal(SIGUSR1, stats);\n\tsignal(SIGUSR2, (void *) &what_i_am_doing);\n\tif (!uwsgi.ignore_sigpipe) {\n\t\tsignal(SIGPIPE, (void *) &warn_pipe);\n\t}\n\n\t// worker initialization done\n\n\t// run fixup handler\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->fixup) {\n\t\t\tuwsgi.p[i]->fixup();\n\t\t}\n\t}\n\n\tif (uwsgi.chdir2) {\n\t\tuwsgi_log(\"chdir() to %s\\n\", uwsgi.chdir2);\n\t\tif (chdir(uwsgi.chdir2)) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t//re - initialize wsgi_req(can be full of init_uwsgi_app data)\n\tfor (i = 0; i < uwsgi.cores; i++) {\n\t\tmemset(&uwsgi.workers[uwsgi.mywid].cores[i].req, 0, sizeof(struct wsgi_request));\n\t\tuwsgi.workers[uwsgi.mywid].cores[i].req.async_id = i;\n\t}\n\n\n\t// eventually remap plugins\n\tif (uwsgi.remap_modifier) {\n\t\tchar *map, *ctx = NULL;\n\t\tuwsgi_foreach_token(uwsgi.remap_modifier, \",\", map, ctx) {\n\t\t\tchar *colon = strchr(map, ':');\n\t\t\tif (colon) {\n\t\t\t\tcolon[0] = 0;\n\t\t\t\tint rm_src = atoi(map);\n\t\t\t\tint rm_dst = atoi(colon + 1);\n\t\t\t\tuwsgi.p[rm_dst]->request = uwsgi.p[rm_src]->request;\n\t\t\t\tuwsgi.p[rm_dst]->after_request = uwsgi.p[rm_src]->after_request;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (uwsgi.cores > 1) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[0].thread_id = pthread_self();\n\t\tpthread_mutex_init(&uwsgi.six_feet_under_lock, NULL);\n\t}\n\n\tuwsgi_ignition();\n\n\t// never here\n\texit(0);\n\n}\n\n\nvoid uwsgi_ignition() {\n\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->hijack_worker) {\n\t\t\tuwsgi.p[i]->hijack_worker();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->hijack_worker) {\n\t\t\tuwsgi.gp[i]->hijack_worker();\n\t\t}\n\t}\n\n\t// create a pthread key, storing per-thread wsgi_request structure\n\tif (uwsgi.threads > 1) {\n\t\tif (pthread_key_create(&uwsgi.tur_key, NULL)) {\n\t\t\tuwsgi_error(\"pthread_key_create()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// mark the worker as \"accepting\" (this is a mark used by chain reloading)\n\tuwsgi.workers[uwsgi.mywid].accepting = 1;\n\t// ready to accept request, if i am a vassal signal Emperor about it\n        if (uwsgi.has_emperor && uwsgi.mywid == 1) {\n                char byte = 5;\n                if (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n                        uwsgi_error(\"emperor-i-am-ready-to-accept/write()\");\n\t\t\tuwsgi_log_verbose(\"lost communication with the Emperor, goodbye...\\n\");\n\t\t\tgracefully_kill_them_all(0);\n\t\t\texit(1);\n                }\n        }\n\n\t// run accepting hooks\n\tuwsgi_hooks_run(uwsgi.hook_accepting, \"accepting\", 1);\n\tif (uwsgi.workers[uwsgi.mywid].respawn_count == 1) {\n\t\tuwsgi_hooks_run(uwsgi.hook_accepting_once, \"accepting-once\", 1);\n\t}\n\n\tif (uwsgi.mywid == 1) {\n\t\tuwsgi_hooks_run(uwsgi.hook_accepting1, \"accepting1\", 1);\n\t\tif (uwsgi.workers[uwsgi.mywid].respawn_count == 1) {\n\t\t\tuwsgi_hooks_run(uwsgi.hook_accepting1_once, \"accepting1-once\", 1);\n\t\t}\n\t}\n\n\tif (uwsgi.loop) {\n\t\tvoid (*u_loop) (void) = uwsgi_get_loop(uwsgi.loop);\n\t\tif (!u_loop) {\n\t\t\tuwsgi_log(\"unavailable loop engine !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.mywid == 1) {\n\t\t\tuwsgi_log(\"*** running %s loop engine [addr:%p] ***\\n\", uwsgi.loop, u_loop);\n\t\t}\n\t\tu_loop();\n\t\tuwsgi_log(\"your loop engine died. R.I.P.\\n\");\n\t}\n\telse {\n\t\tif (uwsgi.async < 2) {\n\t\t\tsimple_loop();\n\t\t}\n\t\telse {\n\t\t\tasync_loop();\n\t\t}\n\t}\n\n\t// end of the process...\n\tend_me(0);\n}\n\n/*\n\nwhat happens here ?\n\nwe transform the uwsgi_option structure to a struct option\nfor passing it to getopt_long\nA short options string is built.\n\nThis function could be called multiple times, so it will free previous areas\n\n*/\n\nvoid build_options() {\n\n\tint options_count = 0;\n\tint pos = 0;\n\tint i;\n\t// first count the base options\n\n\tstruct uwsgi_option *op = uwsgi_base_options;\n\twhile (op->name) {\n\t\toptions_count++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.p[i]->options);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t}\n\t}\n\n\t// add custom options\n\tstruct uwsgi_custom_option *uco = uwsgi.custom_options;\n\twhile (uco) {\n\t\toptions_count++;\n\t\tuco = uco->next;\n\t}\n\n\tif (uwsgi.options)\n\t\tfree(uwsgi.options);\n\n\n\t// rebuild uwsgi.options area\n\tuwsgi.options = uwsgi_calloc(sizeof(struct uwsgi_option) * (options_count + 1));\n\n\top = uwsgi_base_options;\n\twhile (op->name) {\n\t\tmemcpy(&uwsgi.options[pos], op, sizeof(struct uwsgi_option));\n\t\tpos++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.p[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.p[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.gp[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tuco = uwsgi.custom_options;\n        while (uco) {\n                uwsgi.options[pos].name = uco->name;\n                if (uco->has_args) {\n                        uwsgi.options[pos].type = required_argument;\n                }\n                else {\n                        uwsgi.options[pos].type = no_argument;\n                }\n                // custom options should be immediate\n                uwsgi.options[pos].flags = UWSGI_OPT_IMMEDIATE;\n                // help shows the option definition\n                uwsgi.options[pos].help = uco->value;\n                uwsgi.options[pos].data = uco;\n                uwsgi.options[pos].func = uwsgi_opt_custom;\n\n                pos++;\n                uco = uco->next;\n        }\n\n\n\tpos = 0;\n\n\tif (uwsgi.long_options)\n\t\tfree(uwsgi.long_options);\n\n\tuwsgi.long_options = uwsgi_calloc(sizeof(struct option) * (options_count + 1));\n\n\tif (uwsgi.short_options)\n\t\tfree(uwsgi.short_options);\n\n\tuwsgi.short_options = uwsgi_calloc((options_count * 3) + 1);\n\n\t// build long_options (this time with custom_options)\n\top = uwsgi.options;\n\twhile (op->name) {\n\t\tuwsgi.long_options[pos].name = op->name;\n\t\tuwsgi.long_options[pos].has_arg = op->type;\n\t\tuwsgi.long_options[pos].flag = 0;\n\t\t// add 1000 to avoid short_options collision\n\t\tuwsgi.long_options[pos].val = 1000 + pos;\n\t\tif (op->shortcut) {\n\t\t\tchar shortcut = (char) op->shortcut;\n\t\t\t// avoid duplicates in short_options\n\t\t\tif (!strchr(uwsgi.short_options, shortcut)) {\n\t\t\t\tstrncat(uwsgi.short_options, &shortcut, 1);\n\t\t\t\tif (op->type == optional_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \"::\");\n\t\t\t\t}\n\t\t\t\telse if (op->type == required_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \":\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top++;\n\t\tpos++;\n\t}\n}\n\n/*\n\nthis function builds the help output from the uwsgi.options structure\n\n*/\nvoid uwsgi_help(char *opt, char *val, void *none) {\n\n\tsize_t max_size = 0;\n\n\tfprintf(stdout, \"Usage: %s [options...]\\n\", uwsgi.binary_path);\n\n\tstruct uwsgi_option *op = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (strlen(op->name) > max_size) {\n\t\t\tmax_size = strlen(op->name);\n\t\t}\n\t\top++;\n\t}\n\n\tmax_size++;\n\n\top = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (op->shortcut) {\n\t\t\tfprintf(stdout, \"    -%c|--%-*s %s\\n\", op->shortcut, (int) max_size - 3, op->name, op->help);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stdout, \"    --%-*s %s\\n\", (int) max_size, op->name, op->help);\n\t\t}\n\t\top++;\n\t}\n\n\texit(0);\n}\n\n/*\n\ninitialize all apps\n\n*/\nvoid uwsgi_init_all_apps() {\n\n\tint i, j;\n\n\tuwsgi_hooks_run(uwsgi.hook_pre_app, \"pre app\", 1);\n\n\t// now run the pre-app scripts\n\tstruct uwsgi_string_list *usl = uwsgi.exec_pre_app;\n\twhile (usl) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (pre app)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_pre_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n                }\n        }\n\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->init_apps) {\n\t\t\tuwsgi.p[i]->init_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->init_apps) {\n\t\t\tuwsgi.gp[i]->init_apps();\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *app_mps = uwsgi.mounts;\n\twhile (app_mps) {\n\t\tchar *what = strchr(app_mps->value, '=');\n\t\tif (what) {\n\t\t\twhat[0] = 0;\n\t\t\twhat++;\n\t\t\tfor (j = 0; j < 256; j++) {\n\t\t\t\tif (uwsgi.p[j]->mount_app) {\n\t\t\t\t\tuwsgi_log(\"mounting %s on %s\\n\", what, app_mps->value);\n\t\t\t\t\tif (uwsgi.p[j]->mount_app(app_mps->value, what) != -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhat--;\n\t\t\twhat[0] = '=';\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"invalid mountpoint: %s\\n\", app_mps->value);\n\t\t\texit(1);\n\t\t}\n\t\tapp_mps = app_mps->next;\n\t}\n\n\t// no app initialized and virtualhosting enabled\n\tif (uwsgi_apps_cnt == 0 && uwsgi.numproc > 0 && !uwsgi.command_mode) {\n\t\tif (uwsgi.need_app) {\n\t\t\tif (!uwsgi.lazy)\n\t\t\t\tuwsgi_log(\"*** no app loaded. GAME OVER ***\\n\");\n\t\t\tif (uwsgi.lazy_apps) {\n\t\t\t\tif (uwsgi.master_process) {\n\t\t\t\t\tif (kill(uwsgi.workers[0].pid, SIGINT)) {\n\t\t\t\t\t\tuwsgi_error(\"kill()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(UWSGI_FAILED_APP_CODE);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** no app loaded. going in full dynamic mode ***\\n\");\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_post_app, \"post app\", 1);\n\n\tusl = uwsgi.exec_post_app;\n        while (usl) {\n                uwsgi_log(\"running \\\"%s\\\" (post app)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                        uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n                usl = usl->next;\n        }\n\n\tuwsgi_foreach(usl, uwsgi.call_post_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                }\n        }\n\n}\n\nvoid uwsgi_init_worker_mount_apps() {\n/*\n\tint i,j;\n\tfor (i = 0; i < uwsgi.mounts_cnt; i++) {\n                char *what = strchr(uwsgi.mounts[i], '=');\n                if (what) {\n                        what[0] = 0;\n                        what++;\n                        for (j = 0; j < 256; j++) {\n                                if (uwsgi.p[j]->mount_app) {\n                                        if (!uwsgi_startswith(uwsgi.mounts[i], \"worker://\", 9)) {\n                        \t\t\tuwsgi_log(\"mounting %s on %s\\n\", what, uwsgi.mounts[i]+9);\n                                                if (uwsgi.p[j]->mount_app(uwsgi.mounts[i] + 9, what, 1) != -1)\n                                                        break;\n                                        }\n                                }\n                        }\n                        what--;\n                        what[0] = '=';\n                }\n                else {\n                        uwsgi_log(\"invalid mountpoint: %s\\n\", uwsgi.mounts[i]);\n                        exit(1);\n                }\n        }\n*/\n\n}\n\nvoid uwsgi_opt_true(char *opt, char *value, void *key) {\n\n\tint *ptr = (int *) key;\n\t*ptr = 1;\n\tif (value) {\n\t\tif (!strcasecmp(\"false\", value) || !strcasecmp(\"off\", value) || !strcasecmp(\"no\", value) || !strcmp(\"0\", value)) {\n\t\t\t*ptr = 0;\n\t\t}\n\t}\n}\n\nvoid uwsgi_opt_false(char *opt, char *value, void *key) {\n\n        int *ptr = (int *) key;\n        *ptr = 0;\n        if (value) {\n                if (!strcasecmp(\"false\", value) || !strcasecmp(\"off\", value) || !strcasecmp(\"no\", value) || !strcmp(\"0\", value)) {\n                        *ptr = 1;\n                }\n        }\n}\n\nvoid uwsgi_opt_set_immediate_gid(char *opt, char *value, void *none) {\n        gid_t gid = 0;\n\tif (is_a_number(value)) gid = atoi(value);\n\tif (gid == 0) {\n\t\tstruct group *ugroup = getgrnam(value);\n                if (ugroup)\n                \tgid = ugroup->gr_gid;\n\t}\n        if (gid <= 0) {\n                uwsgi_log(\"uwsgi_opt_set_immediate_gid(): invalid gid %d\\n\", (int) gid);\n                exit(1);\n        }\n        if (setgid(gid)) {\n                uwsgi_error(\"uwsgi_opt_set_immediate_gid()/setgid()\");\n                exit(1);\n        }\n\n\tif (setgroups(0, NULL)) {\n        \tuwsgi_error(\"uwsgi_opt_set_immediate_gid()/setgroups()\");\n                exit(1);\n        }\n\n\tgid = getgid();\n\tif (!gid) {\n\t\texit(1);\n\t}\n\tuwsgi_log(\"immediate gid: %d\\n\", (int) gid);\n}\n\n\nvoid uwsgi_opt_set_immediate_uid(char *opt, char *value, void *none) {\n\tuid_t uid = 0;\n\tif (is_a_number(value)) uid = atoi(value);\n\tif (uid == 0) {\n\t\tstruct passwd *upasswd = getpwnam(value);\n                if (upasswd)\n                        uid = upasswd->pw_uid;\n\t}\n\tif (uid <= 0) {\n\t\tuwsgi_log(\"uwsgi_opt_set_immediate_uid(): invalid uid %d\\n\", uid);\n\t\texit(1);\n\t}\n\tif (setuid(uid)) {\n\t\tuwsgi_error(\"uwsgi_opt_set_immediate_uid()/setuid()\");\n\t\texit(1);\n\t}\n\n\tuid = getuid();\n\tif (!uid) {\n\t\texit(1);\n\t}\n\tuwsgi_log(\"immediate uid: %d\\n\", (int) uid);\n}\n\nvoid uwsgi_opt_safe_fd(char *opt, char *value, void *foobar) {\n\tint fd = atoi(value);\n\tif (fd < 0) {\n\t\tuwsgi_log(\"invalid file descriptor: %d\\n\", fd);\n\t\texit(1);\n\t}\n\tuwsgi_add_safe_fd(fd);\n}\n\nvoid uwsgi_opt_set_int(char *opt, char *value, void *key) {\n\tint *ptr = (int *) key;\n\tif (value) {\n\t\t*ptr = atoi((char *) value);\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n\n\tif (*ptr < 0) {\n\t\tuwsgi_log(\"invalid value for option \\\"%s\\\": must be > 0\\n\", opt);\n\t\texit(1);\n\t}\n}\n\nvoid uwsgi_opt_uid(char *opt, char *value, void *key) {\n\tuid_t uid = 0;\n\tif (is_a_number(value)) uid = atoi(value);\n\tif (!uid) {\n\t\tstruct passwd *p = getpwnam(value);\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\t\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unable to find user %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (key)  {\n        \tuid_t *ptr = (uid_t *) key;\n        \t*ptr = uid;\n        }\n}\n\nvoid uwsgi_opt_gid(char *opt, char *value, void *key) {\n        gid_t gid = 0;\n\tif (is_a_number(value)) gid = atoi(value);\n        if (!gid) {\n                struct group *g = getgrnam(value);\n                if (g) {\n                        gid = g->gr_gid;\n                }\n                else {\n                        uwsgi_log(\"unable to find group %s\\n\", value);\n\t\t\texit(1);\n                }\n        }       \n        if (key)  {\n                gid_t *ptr = (gid_t *) key;\n                *ptr = gid;\n        }       \n}     \n\nvoid uwsgi_opt_set_rawint(char *opt, char *value, void *key) {\n\tint *ptr = (int *) key;\n\tif (value) {\n\t\t*ptr = atoi((char *) value);\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n}\n\n\nvoid uwsgi_opt_set_64bit(char *opt, char *value, void *key) {\n\tuint64_t *ptr = (uint64_t *) key;\n\n\tif (value) {\n\t\t*ptr = (strtoul(value, NULL, 10));\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n}\n\nvoid uwsgi_opt_set_16bit(char *opt, char *value, void *key) {\n        uint16_t *ptr = (uint16_t *) key;\n\n        if (value) {\n\t\tunsigned long n = strtoul(value, NULL, 10);\n\t\tif (n > 65535) n = 65535;\n                *ptr = n;\n        }\n        else {\n                *ptr = 1;\n        }\n}\n\n\nvoid uwsgi_opt_set_megabytes(char *opt, char *value, void *key) {\n\tuint64_t *ptr = (uint64_t *) key;\n\t*ptr = (uint64_t)strtoul(value, NULL, 10) * 1024 * 1024;\n}\n\nvoid uwsgi_opt_set_str(char *opt, char *value, void *key) {\n\tchar **ptr = (char **) key;\n\tif (!value) {\n\t\t*ptr = \"\";\n\t\treturn;\t\n\t}\n\t*ptr = (char *) value;\n}\n\nvoid uwsgi_opt_set_null(char *opt, char *value, void *key) {\n        char **ptr = (char **) key;\n        *ptr = NULL;\n}\n\n\nvoid uwsgi_opt_set_logger(char *opt, char *value, void *prefix) {\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (prefix) {\n\t\tuwsgi_string_new_list(&uwsgi.requested_logger, uwsgi_concat3((char *) prefix, \":\", value));\n\t}\n\telse {\n\t\tuwsgi_string_new_list(&uwsgi.requested_logger, uwsgi_str(value));\n\t}\n}\n\nvoid uwsgi_opt_set_req_logger(char *opt, char *value, void *prefix) {\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (prefix) {\n\t\tuwsgi_string_new_list(&uwsgi.requested_req_logger, uwsgi_concat3((char *) prefix, \":\", value));\n\t}\n\telse {\n\t\tuwsgi_string_new_list(&uwsgi.requested_req_logger, uwsgi_str(value));\n\t}\n}\n\nvoid uwsgi_opt_set_str_spaced(char *opt, char *value, void *key) {\n\tchar **ptr = (char **) key;\n\t*ptr = uwsgi_concat2((char *) value, \" \");\n}\n\nvoid uwsgi_opt_add_string_list(char *opt, char *value, void *list) {\n\tstruct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tuwsgi_string_new_list(ptr, value);\n}\n\nvoid uwsgi_opt_add_addr_list(char *opt, char *value, void *list) {\n        struct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tint af = AF_INET;\n#ifdef AF_INET6\n\tvoid *ip = uwsgi_malloc(16);\n\tif (strchr(value, ':')) {\n\t\taf = AF_INET6;\n\t}\n#else\n\tvoid *ip = uwsgi_malloc(4);\n#endif\n\t\n\tif (inet_pton(af, value, ip) <= 0) {\n\t\tuwsgi_log(\"%s: invalid address\\n\", opt);\n\t\tuwsgi_error(\"uwsgi_opt_add_addr_list()\");\n\t\texit(1);\n\t}\n\n        struct uwsgi_string_list *usl = uwsgi_string_new_list(ptr, ip);\n\tusl->custom = af;\n\tusl->custom_ptr = value;\n}\n\n\nvoid uwsgi_opt_add_string_list_custom(char *opt, char *value, void *list) {\n\tstruct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tstruct uwsgi_string_list *usl = uwsgi_string_new_list(ptr, value);\n\tusl->custom = 1;\n}\n\n#ifdef UWSGI_PCRE\nvoid uwsgi_opt_add_regexp_list(char *opt, char *value, void *list) {\n\tstruct uwsgi_regexp_list **ptr = (struct uwsgi_regexp_list **) list;\n\tuwsgi_regexp_new_list(ptr, value);\n}\n\nvoid uwsgi_opt_add_regexp_custom_list(char *opt, char *value, void *list) {\n\tchar *space = strchr(value, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid custom regexp syntax: must be <custom> <regexp>\\n\");\n\t\texit(1);\n\t}\n\tchar *custom = uwsgi_concat2n(value, space - value, \"\", 0);\n\tstruct uwsgi_regexp_list **ptr = (struct uwsgi_regexp_list **) list;\n\tuwsgi_regexp_custom_new_list(ptr, space + 1, custom);\n}\n#endif\n\nvoid uwsgi_opt_add_shared_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *us = uwsgi_new_shared_socket(generate_socket_name(value));\n\tif (!strcmp(opt, \"undeferred-shared-socket\")) {\n\t\tus->no_defer = 1;\n\t}\n}\n\nvoid uwsgi_opt_add_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n\tuwsgi_sock->name_len = strlen(uwsgi_sock->name);\n\tuwsgi_sock->proto_name = protocol;\n}\n\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_add_ssl_socket(char *opt, char *value, void *protocol) {\n\tchar *client_ca = NULL;\n\n        // build socket, certificate and key file\n        char *sock = uwsgi_str(value);\n        char *crt = strchr(sock, ',');\n        if (!crt) {\n                uwsgi_log(\"invalid https-socket syntax must be socket,crt,key\\n\");\n                exit(1);\n        }\n        *crt = '\\0'; crt++;\n        char *key = strchr(crt, ',');\n        if (!key) {\n                uwsgi_log(\"invalid https-socket syntax must be socket,crt,key\\n\");\n                exit(1);\n        }\n        *key = '\\0'; key++;\n\n        char *ciphers = strchr(key, ',');\n        if (ciphers) {\n                *ciphers = '\\0'; ciphers++;\n                client_ca = strchr(ciphers, ',');\n                if (client_ca) {\n                        *client_ca = '\\0'; client_ca++;\n                }\n        }\n\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(sock));\n\tuwsgi_sock->name_len = strlen(uwsgi_sock->name);\n        uwsgi_sock->proto_name = protocol;\n\n        // ok we have the socket, initialize ssl if required\n        if (!uwsgi.ssl_initialized) {\n                uwsgi_ssl_init();\n        }\n\n        // initialize ssl context\n        uwsgi_sock->ssl_ctx = uwsgi_ssl_new_server_context(uwsgi_sock->name, crt, key, ciphers, client_ca);\n        if (!uwsgi_sock->ssl_ctx) {\n                exit(1);\n        }\n}\n#endif\n\nvoid uwsgi_opt_add_socket_no_defer(char *opt, char *value, void *protocol) {\n        struct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n        uwsgi_sock->name_len = strlen(uwsgi_sock->name);\n        uwsgi_sock->proto_name = protocol;\n\tuwsgi_sock->no_defer = 1;\n}\n\nvoid uwsgi_opt_add_lazy_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n\tuwsgi_sock->proto_name = protocol;\n\tuwsgi_sock->bound = 1;\n\tuwsgi_sock->lazy = 1;\n}\n\n\nvoid uwsgi_opt_set_placeholder(char *opt, char *value, void *ph) {\n\n\tchar *p = strchr(value, '=');\n\tif (!p) {\n\t\tuwsgi_log(\"invalid placeholder/--set value\\n\");\n\t\texit(1);\n\t}\n\n\tp[0] = 0;\n\tadd_exported_option_do(uwsgi_str(value), p + 1, 0, ph ? 1 : 0);\n\tp[0] = '=';\n\n}\n\nvoid uwsgi_opt_ssa(char *opt, char *value, void *foobar) {\n\tuwsgi_subscription_set_algo(value);\n}\n\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_scd(char *opt, char *value, void *foobar) {\n\t// openssl could not be initialized\n\tif (!uwsgi.ssl_initialized) {\n\t\tuwsgi_ssl_init();\n\t}\n\n\tchar *colon = strchr(value, ':');\n\tif (!colon) {\n\t\tuwsgi_log(\"invalid syntax for '%s', must be: <digest>:<directory>\\n\", opt);\n\t\texit(1);\n\t}\n\n\tchar *algo = uwsgi_concat2n(value, (colon - value), \"\", 0);\n\tuwsgi.subscriptions_sign_check_md = EVP_get_digestbyname(algo);\n\tif (!uwsgi.subscriptions_sign_check_md) {\n\t\tuwsgi_log(\"unable to find digest algorithm: %s\\n\", algo);\n\t\texit(1);\n\t}\n\tfree(algo);\n\n\tuwsgi.subscriptions_sign_check_dir = colon + 1;\n}\n#endif\n\nvoid uwsgi_opt_set_umask(char *opt, char *value, void *mode) {\n\tint error = 0;\n\tmode_t mask = uwsgi_mode_t(value, &error);\n\tif (error) {\n\t\tuwsgi_log(\"invalid umask: %s\\n\", value);\n\t}\n\tumask(mask);\n\n\tuwsgi.do_not_change_umask = 1;\n}\n\nvoid uwsgi_opt_exit(char *opt, char *value, void *none) {\n\tint exit_code = 1;\n\tif (value) {\n\t\texit_code = atoi(value);\n\t}\n\texit(exit_code);\n}\n\nvoid uwsgi_opt_print(char *opt, char *value, void *str) {\n\tif (str) {\n\t\tfprintf(stdout, \"%s\\n\", (char *) str);\n\t\texit(0);\n\t}\n\tfprintf(stdout, \"%s\\n\", value);\n}\n\nvoid uwsgi_opt_set_uid(char *opt, char *value, void *none) {\n\tif (is_a_number(value)) uwsgi.uid = atoi(value);\n\tif (!uwsgi.uid)\n\t\tuwsgi.uidname = value;\n}\n\nvoid uwsgi_opt_set_gid(char *opt, char *value, void *none) {\n\tif (is_a_number(value)) uwsgi.gid = atoi(value);\n\tif (!uwsgi.gid)\n\t\tuwsgi.gidname = value;\n}\n\n#ifdef UWSGI_CAP\nvoid uwsgi_opt_set_cap(char *opt, char *value, void *none) {\n\tuwsgi.cap_count = uwsgi_build_cap(value, &uwsgi.cap);\n\tif (uwsgi.cap_count == 0) {\n\t\tuwsgi_log(\"[security] empty capabilities mask !!!\\n\");\n\t\texit(1);\n\t}\n}\nvoid uwsgi_opt_set_emperor_cap(char *opt, char *value, void *none) {\n\tuwsgi.emperor_cap_count = uwsgi_build_cap(value, &uwsgi.emperor_cap);\n\tif (uwsgi.emperor_cap_count == 0) {\n\t\tuwsgi_log(\"[security] empty capabilities mask !!!\\n\");\n\t\texit(1);\n\t}\n}\n#endif\n#ifdef __linux__\nvoid uwsgi_opt_set_unshare(char *opt, char *value, void *mask) {\n\tuwsgi_build_unshare(value, (int *) mask);\n}\n#endif\n\nvoid uwsgi_opt_set_env(char *opt, char *value, void *none) {\n\tif (putenv(value)) {\n\t\tuwsgi_error(\"putenv()\");\n\t}\n}\n\nvoid uwsgi_opt_unset_env(char *opt, char *value, void *none) {\n#ifdef UNSETENV_VOID\n\tunsetenv(value);\n#else\n\tif (unsetenv(value)) {\n\t\tuwsgi_error(\"unsetenv()\");\n\t}\n#endif\n}\n\nvoid uwsgi_opt_pidfile_signal(char *opt, char *pidfile, void *sig) {\n\n\tlong *signum_fake_ptr = (long *) sig;\n\tint signum = (long) signum_fake_ptr;\n\texit(signal_pidfile(signum, pidfile));\n}\n\nvoid uwsgi_opt_load_dl(char *opt, char *value, void *none) {\n\tif (!dlopen(value, RTLD_NOW | RTLD_GLOBAL)) {\n\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t}\n}\n\nvoid uwsgi_opt_load_plugin(char *opt, char *value, void *none) {\n\n\tchar *plugins_list = uwsgi_concat2(value, \"\");\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(plugins_list, \",\", p, ctx) {\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_debug(\"loading plugin %s\\n\", p);\n#endif\n\t\tif (uwsgi_load_plugin(-1, p, NULL)) {\n\t\t\tbuild_options();\n\t\t}\n\t\telse if (!uwsgi_startswith(opt, \"need-\", 5)) {\n\t\t\tuwsgi_log(\"unable to load plugin \\\"%s\\\"\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(p);\n\tfree(plugins_list);\n}\n\nvoid uwsgi_opt_check_static(char *opt, char *value, void *foobar) {\n\n\tuwsgi_dyn_dict_new(&uwsgi.check_static, value, strlen(value), NULL, 0);\n\tuwsgi_log(\"[uwsgi-static] added check for %s\\n\", value);\n\tuwsgi.build_mime_dict = 1;\n\n}\n\nvoid uwsgi_opt_add_dyn_dict(char *opt, char *value, void *dict) {\n\n\tchar *equal = strchr(value, '=');\n\tif (!equal) {\n\t\tuwsgi_log(\"invalid dictionary syntax for %s\\n\", opt);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_dyn_dict **udd = (struct uwsgi_dyn_dict **) dict;\n\n\tuwsgi_dyn_dict_new(udd, value, equal - value, equal + 1, strlen(equal + 1));\n\n}\n\n#ifdef UWSGI_PCRE\nvoid uwsgi_opt_add_regexp_dyn_dict(char *opt, char *value, void *dict) {\n\n\tchar *space = strchr(value, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid dictionary syntax for %s\\n\", opt);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_dyn_dict **udd = (struct uwsgi_dyn_dict **) dict;\n\n\tstruct uwsgi_dyn_dict *new_udd = uwsgi_dyn_dict_new(udd, value, space - value, space + 1, strlen(space + 1));\n\n\tchar *regexp = uwsgi_concat2n(value, space - value, \"\", 0);\n\n\tif (uwsgi_regexp_build(regexp, &new_udd->pattern, &new_udd->pattern_extra)) {\n\t\texit(1);\n\t}\n\n\tfree(regexp);\n}\n#endif\n\n\nvoid uwsgi_opt_fileserve_mode(char *opt, char *value, void *foobar) {\n\n\tif (!strcasecmp(\"x-sendfile\", value)) {\n\t\tuwsgi.file_serve_mode = 2;\n\t}\n\telse if (!strcasecmp(\"xsendfile\", value)) {\n\t\tuwsgi.file_serve_mode = 2;\n\t}\n\telse if (!strcasecmp(\"x-accel-redirect\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\telse if (!strcasecmp(\"xaccelredirect\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\telse if (!strcasecmp(\"nginx\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\n}\n\nvoid uwsgi_opt_static_map(char *opt, char *value, void *static_maps) {\n\n\tstruct uwsgi_dyn_dict **maps = (struct uwsgi_dyn_dict **) static_maps;\n\tchar *mountpoint = uwsgi_str(value);\n\n\tchar *docroot = strchr(mountpoint, '=');\n\n\tif (!docroot) {\n\t\tuwsgi_log(\"invalid document root in static map, syntax mountpoint=docroot\\n\");\n\t\texit(1);\n\t}\n\tdocroot[0] = 0;\n\tdocroot++;\n\tuwsgi_dyn_dict_new(maps, mountpoint, strlen(mountpoint), docroot, strlen(docroot));\n\tuwsgi_log_initial(\"[uwsgi-static] added mapping for %s => %s\\n\", mountpoint, docroot);\n\tuwsgi.build_mime_dict = 1;\n}\n\n\nint uwsgi_zerg_attach(char *value) {\n\n\tint count = 8;\n\tint zerg_fd = uwsgi_connect(value, 30, 0);\n\tif (zerg_fd < 0) {\n\t\tuwsgi_log(\"--- unable to connect to zerg server %s ---\\n\", value);\n\t\treturn -1;\n\t}\n\n\tint last_count = count;\n\n\tint *zerg = uwsgi_attach_fd(zerg_fd, &count, \"uwsgi-zerg\", 10);\n\tif (zerg == NULL) {\n\t\tif (last_count != count) {\n\t\t\tclose(zerg_fd);\n\t\t\tzerg_fd = uwsgi_connect(value, 30, 0);\n\t\t\tif (zerg_fd < 0) {\n\t\t\t\tuwsgi_log(\"--- unable to connect to zerg server %s ---\\n\", value);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tzerg = uwsgi_attach_fd(zerg_fd, &count, \"uwsgi-zerg\", 10);\n\t\t}\n\t}\n\n\tif (zerg == NULL) {\n\t\tuwsgi_log(\"--- invalid data received from zerg-server ---\\n\");\n\t\tclose(zerg_fd);\n\t\treturn -1;\n\t}\n\n\tif (!uwsgi.zerg) {\n\t\tuwsgi.zerg = zerg;\n\t}\n\telse {\n\t\tint pos = 0;\n\t\tfor (;;) {\n\t\t\tif (uwsgi.zerg[pos] == -1) {\n\t\t\t\tuwsgi.zerg = realloc(uwsgi.zerg, (sizeof(int) * (pos)) + (sizeof(int) * count + 1));\n\t\t\t\tif (!uwsgi.zerg) {\n\t\t\t\t\tuwsgi_error(\"realloc()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tmemcpy(&uwsgi.zerg[pos], zerg, (sizeof(int) * count + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\tfree(zerg);\n\t}\n\n\tclose(zerg_fd);\n\treturn 0;\n}\n\nvoid uwsgi_opt_signal(char *opt, char *value, void *foobar) {\n\tuwsgi_command_signal(value);\n}\n\nvoid uwsgi_opt_log_date(char *opt, char *value, void *foobar) {\n\n\tuwsgi.logdate = 1;\n\tif (value) {\n\t\tif (strcasecmp(\"true\", value) && strcasecmp(\"1\", value) && strcasecmp(\"on\", value) && strcasecmp(\"yes\", value)) {\n\t\t\tuwsgi.log_strftime = value;\n\t\t}\n\t}\n}\n\nvoid uwsgi_opt_chmod_socket(char *opt, char *value, void *foobar) {\n\n\tint i;\n\n\tuwsgi.chmod_socket = 1;\n\tif (value) {\n\t\tif (strlen(value) == 1 && *value == '1') {\n\t\t\treturn;\n\t\t}\n\t\tif (strlen(value) != 3) {\n\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (value[i] < '0' || value[i] > '7') {\n\t\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[0] - '0');\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[1] - '0');\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[2] - '0');\n\t}\n\n}\n\nvoid uwsgi_opt_logfile_chmod(char *opt, char *value, void *foobar) {\n\n\tint i;\n\n\tif (strlen(value) != 3) {\n\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\texit(1);\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (value[i] < '0' || value[i] > '7') {\n\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[0] - '0');\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[1] - '0');\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[2] - '0');\n\n}\n\nvoid uwsgi_opt_max_vars(char *opt, char *value, void *foobar) {\n\n\tuwsgi.max_vars = atoi(value);\n\tuwsgi.vec_size = 4 + 1 + (4 * uwsgi.max_vars);\n}\n\nvoid uwsgi_opt_deprecated(char *opt, char *value, void *message) {\n\tuwsgi_log(\"[WARNING] option \\\"%s\\\" is deprecated: %s\\n\", opt, (char *) message);\n}\n\nvoid uwsgi_opt_load(char *opt, char *filename, void *none) {\n\n\t// here we need to avoid setting upper magic vars\n\tint orig_magic = uwsgi.magic_table_first_round;\n\tuwsgi.magic_table_first_round = 1;\n\n\tif (uwsgi_endswith(filename, \".ini\")) {\n\t\tuwsgi_opt_load_ini(opt, filename, none);\n\t\tgoto end;\n\t}\n#ifdef UWSGI_XML\n\tif (uwsgi_endswith(filename, \".xml\")) {\n\t\tuwsgi_opt_load_xml(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n#ifdef UWSGI_YAML\n\tif (uwsgi_endswith(filename, \".yaml\")) {\n\t\tuwsgi_opt_load_yml(opt, filename, none);\n\t\tgoto end;\n\t}\n\tif (uwsgi_endswith(filename, \".yml\")) {\n\t\tuwsgi_opt_load_yml(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n#ifdef UWSGI_JSON\n\tif (uwsgi_endswith(filename, \".json\")) {\n\t\tuwsgi_opt_load_json(opt, filename, none);\n\t\tgoto end;\n\t}\n\tif (uwsgi_endswith(filename, \".js\")) {\n\t\tuwsgi_opt_load_json(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n\n\t// fallback to pluggable system\n\tuwsgi_opt_load_config(opt, filename, none);\nend:\n\tuwsgi.magic_table_first_round = orig_magic;\n}\n\nvoid uwsgi_opt_logic(char *opt, char *arg, void *func) {\n\n\tif (uwsgi.logic_opt) {\n\t\tuwsgi_log(\"recursive logic in options is not supported (option = %s)\\n\", opt);\n\t\texit(1);\n\t}\n\tuwsgi.logic_opt = (int (*)(char *, char *)) func;\n\tuwsgi.logic_opt_cycles = 0;\n\tif (arg) {\n\t\tuwsgi.logic_opt_arg = uwsgi_str(arg);\n\t}\n\telse {\n\t\tuwsgi.logic_opt_arg = NULL;\n\t}\n}\n\nvoid uwsgi_opt_noop(char *opt, char *foo, void *bar) {\n}\n\nvoid uwsgi_opt_load_ini(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_ini_config(filename, uwsgi.magic_table);\n}\n\nvoid uwsgi_opt_load_config(char *opt, char *filename, void *none) {\n        struct uwsgi_configurator *uc = uwsgi.configurators;\n        while(uc) {\n                if (uwsgi_endswith(filename, uc->name)) {\n                        config_magic_table_fill(filename, uwsgi.magic_table);\n                        uc->func(filename, uwsgi.magic_table);\n                        return;\n                }\n                uc = uc->next;\n        }\n\n\tuwsgi_log(\"unable to load configuration from %s\\n\", filename);\n\texit(1);\n}\n\n#ifdef UWSGI_XML\nvoid uwsgi_opt_load_xml(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_xml_config(filename, uwsgi.wsgi_req, uwsgi.magic_table);\n}\n#endif\n\n#ifdef UWSGI_YAML\nvoid uwsgi_opt_load_yml(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_yaml_config(filename, uwsgi.magic_table);\n}\n#endif\n\n#ifdef UWSGI_JSON\nvoid uwsgi_opt_load_json(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_json_config(filename, uwsgi.magic_table);\n}\n#endif\n\nvoid uwsgi_opt_add_custom_option(char *opt, char *value, void *none) {\n\n\tstruct uwsgi_custom_option *uco = uwsgi.custom_options, *old_uco;\n\n\tif (!uco) {\n\t\tuwsgi.custom_options = uwsgi_malloc(sizeof(struct uwsgi_custom_option));\n\t\tuco = uwsgi.custom_options;\n\t}\n\telse {\n\t\twhile (uco) {\n\t\t\told_uco = uco;\n\t\t\tuco = uco->next;\n\t\t}\n\n\t\tuco = uwsgi_malloc(sizeof(struct uwsgi_custom_option));\n\t\told_uco->next = uco;\n\t}\n\n\tchar *copy = uwsgi_str(value);\n\tchar *equal = strchr(copy, '=');\n\tif (!equal) {\n\t\tuwsgi_log(\"invalid %s syntax, must be newoption=template\\n\", value);\n\t\texit(1);\n\t}\n\t*equal = 0;\n\n\tuco->name = copy;\n\tuco->value = equal + 1;\n\tuco->has_args = 0;\n\t// a little hack, we allow the user to skip the first 2 arguments (yes.. it is silly...but users tend to make silly things...)\n\tif (strstr(uco->value, \"$1\") || strstr(uco->value, \"$2\") || strstr(uco->value, \"$3\")) {\n\t\tuco->has_args = 1;\n\t}\n\tuco->next = NULL;\n\tbuild_options();\n}\n\n\nvoid uwsgi_opt_flock(char *opt, char *filename, void *none) {\n\n\tint fd = open(filename, O_RDWR);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\n\tif (uwsgi_fcntl_is_locked(fd)) {\n\t\tuwsgi_log(\"uWSGI ERROR: %s is locked by another instance\\n\", filename);\n\t\texit(1);\n\t}\n}\n\nvoid uwsgi_opt_flock_wait(char *opt, char *filename, void *none) {\n\n\tint fd = open(filename, O_RDWR);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\n\tif (uwsgi_fcntl_lock(fd)) {\n\t\texit(1);\n\t}\n}\n\n// report CFLAGS used for compiling the server\n// use that values to build external plugins\nvoid uwsgi_opt_cflags(char *opt, char *filename, void *foobar) {\n\tfprintf(stdout, \"%s\\n\", uwsgi_get_cflags());\n\texit(0);\n}\n\nchar *uwsgi_get_cflags() {\n\tsize_t len = sizeof(UWSGI_CFLAGS) -1;\n        char *src = UWSGI_CFLAGS;\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n\t*ptr ++= 0;\n\treturn base;\n}\n\n// report uwsgi.h used for compiling the server\n// use that values to build external plugins\nextern char *uwsgi_dot_h;\nchar *uwsgi_get_dot_h() {\n\tchar *src = uwsgi_dot_h;\n\tsize_t len = strlen(src);\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n#ifdef UWSGI_ZLIB\n\tstruct uwsgi_buffer *ub = uwsgi_zlib_decompress(base, ptr-base);\n\tif (!ub) {\n\t\tfree(base);\n\t\treturn \"\";\n\t}\n\t// add final null byte\n\tuwsgi_buffer_append(ub, \"\\0\", 1);\n\tfree(base);\n\t// base is the final blob\n\tbase = ub->buf;\n\tub->buf = NULL;\n\tuwsgi_buffer_destroy(ub);\n#else\n        // add final null byte\n        *ptr = '\\0';\n#endif\n\treturn base;\n}\nvoid uwsgi_opt_dot_h(char *opt, char *filename, void *foobar) {\n        fprintf(stdout, \"%s\\n\", uwsgi_get_dot_h());\n        exit(0);\n}\n\nextern char *uwsgi_config_py;\nchar *uwsgi_get_config_py() {\n        char *src = uwsgi_config_py;\n        size_t len = strlen(src);\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n#ifdef UWSGI_ZLIB\n        struct uwsgi_buffer *ub = uwsgi_zlib_decompress(base, ptr-base);\n        if (!ub) {\n                free(base);\n                return \"\";\n        }\n        // add final null byte\n        uwsgi_buffer_append(ub, \"\\0\", 1);\n        free(base);\n        // base is the final blob\n        base = ub->buf;\n        ub->buf = NULL;\n        uwsgi_buffer_destroy(ub);\n#else\n        // add final null byte\n        *ptr = '\\0';\n#endif\n        return base;\n}\n\nvoid uwsgi_opt_config_py(char *opt, char *filename, void *foobar) {\n        fprintf(stdout, \"%s\\n\", uwsgi_get_config_py());\n        exit(0);\n}\n\n\nvoid uwsgi_opt_build_plugin(char *opt, char *directory, void *foobar) {\n\tuwsgi_build_plugin(directory);\n\texit(1);\n}\n\nvoid uwsgi_opt_connect_and_read(char *opt, char *address, void *foobar) {\n\n\tchar buf[8192];\n\n\tint fd = uwsgi_connect(address, -1, 0);\n\twhile (fd >= 0) {\n\t\tint ret = uwsgi_waitfd(fd, -1);\n\t\tif (ret <= 0) {\n\t\t\texit(0);\n\t\t}\n\t\tssize_t len = read(fd, buf, 8192);\n\t\tif (len <= 0) {\n\t\t\texit(0);\n\t\t}\n\t\tuwsgi_log(\"%.*s\", (int) len, buf);\n\t}\n\tuwsgi_error(\"uwsgi_connect()\");\n\texit(1);\n}\n\nvoid uwsgi_opt_extract(char *opt, char *address, void *foobar) {\n\n\tsize_t len = 0;\n\tchar *buf;\n\n\tbuf = uwsgi_open_and_read(address, &len, 0, NULL);\n\tif (len > 0) {\n\t\tif (write(1, buf, len) != (ssize_t) len) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t\texit(1);\n\t\t};\n\t};\n\texit(0);\n}\n\nvoid uwsgi_print_sym(char *opt, char *symbol, void *foobar) {\n\tchar **sym = dlsym(RTLD_DEFAULT, symbol);\n\tif (sym) {\n\t\tuwsgi_log(\"%s\", *sym);\n\t\texit(0);\n\t}\n\t\n\tchar *symbol_start = uwsgi_concat2(symbol, \"_start\");\n\tchar *symbol_end = uwsgi_concat2(symbol, \"_end\");\n\n\tchar *sym_s = dlsym(RTLD_DEFAULT, symbol_start);\n\tchar *sym_e = dlsym(RTLD_DEFAULT, symbol_end);\n\n\tif (sym_s && sym_e) {\n\t\tuwsgi_log(\"%.*s\", sym_e - sym_s, sym_s);\n\t}\n\n\texit(0);\n}\n\nvoid uwsgi_update_pidfiles() {\n\tif (uwsgi.pidfile) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile);\n\t}\n\tif (uwsgi.pidfile2) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile2);\n\t}\n\tif (uwsgi.safe_pidfile) {\n\t\tuwsgi_write_pidfile(uwsgi.safe_pidfile);\n\t}\n\tif (uwsgi.safe_pidfile2) {\n\t\tuwsgi_write_pidfile(uwsgi.safe_pidfile2);\n\t}\n}\n\nvoid uwsgi_opt_binary_append_data(char *opt, char *value, void *none) {\n\n\tsize_t size;\n\tchar *buf = uwsgi_open_and_read(value, &size, 0, NULL);\n\n\tuint64_t file_len = size;\n\n\tif (write(1, buf, size) != (ssize_t) size) {\n\t\tuwsgi_error(\"uwsgi_opt_binary_append_data()/write()\");\n\t\texit(1);\n\t}\n\n\tif (write(1, &file_len, 8) != 8) {\n\t\tuwsgi_error(\"uwsgi_opt_binary_append_data()/write()\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/core/plugins.c": "#include \"uwsgi.h\"\n\nextern struct uwsgi_server uwsgi;\n\n#ifdef UWSGI_ELF\nstatic void uwsgi_plugin_parse_section(char *filename) {\n\tsize_t s_len = 0;\n\tchar *buf = uwsgi_elf_section(filename, \"uwsgi\", &s_len);\n\tif (buf) {\n\t\tchar *ctx = NULL;\n\t\tchar *p = strtok_r(buf, \"\\n\", &ctx);\n\t\twhile (p) {\n\t\t\tchar *equal = strchr(p, '=');\n\t\t\tif (equal) {\n\t\t\t\t*equal = 0;\n\t\t\t\tif (!strcmp(p, \"requires\")) {\n\t\t\t\t\tif (!plugin_already_loaded(equal+1)) {\t\n\t\t\t\t\t\tuwsgi_load_plugin(-1, equal + 1, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = strtok_r(NULL, \"\\n\", &ctx);\n\t\t}\n\t\tfree(buf);\n\t}\n}\n#endif\n\nstruct uwsgi_plugin *uwsgi_plugin_get(const char *plugin) {\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->name) {\n\t\t\tif (!strcmp(plugin, uwsgi.p[i]->name)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t\tif (uwsgi.p[i]->alias) {\n\t\t\tif (!strcmp(plugin, uwsgi.p[i]->alias)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\n\t\tif (uwsgi.gp[i]->name) {\n\t\t\tif (!strcmp(plugin, uwsgi.gp[i]->name)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t\tif (uwsgi.gp[i]->alias) {\n\t\t\tif (!strcmp(plugin, uwsgi.gp[i]->alias)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint plugin_already_loaded(const char *plugin) {\n\tstruct uwsgi_plugin *up = uwsgi_plugin_get(plugin);\n\tif (up) return 1;\n\treturn 0;\n}\n\n\nvoid *uwsgi_load_plugin(int modifier, char *plugin, char *has_option) {\n\n\tvoid *plugin_handle = NULL;\n\tchar *plugin_abs_path = NULL;\n\tchar *plugin_filename = NULL;\n\n\tint need_free = 0;\n\tchar *plugin_name = uwsgi_strip(uwsgi_str(plugin));\n\tchar *plugin_symbol_name_start;\n\n\tstruct uwsgi_plugin *up;\n\tchar linkpath_buf[1024], linkpath[1024];\n\tint linkpath_size;\n\n\tchar *colon = strchr(plugin_name, ':');\n\tif (colon) {\n\t\tcolon[0] = 0;\n\t\tmodifier = atoi(plugin_name);\n\t\tplugin_name = colon + 1;\n\t\tcolon[0] = ':';\n\t}\n\n\tchar *init_func = strchr(plugin_name, '|');\n\tif (init_func) {\n\t\tinit_func[0] = 0;\n\t\tinit_func++;\t\n\t}\n\n\tif (!uwsgi_endswith(plugin_name, \"_plugin.so\")) {\n\t\tplugin_name = uwsgi_concat2(plugin_name, \"_plugin.so\");\n\t\tneed_free = 1;\n\t}\n\n\tplugin_symbol_name_start = plugin_name;\n\n\t// step 1: check for absolute plugin (stop if it fails)\n\tif (strchr(plugin_name, '/')) {\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_name);\n#endif\n\t\tplugin_handle = dlopen(plugin_name, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!plugin_handle) {\n\t\t\tif (!has_option)\n\t\t\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t\t\tgoto end;\n\t\t}\n\t\tplugin_symbol_name_start = uwsgi_get_last_char(plugin_name, '/');\n\t\tplugin_symbol_name_start++;\n\t\tplugin_abs_path = plugin_name;\n\t\tgoto success;\n\t}\n\n\t// step dir, check for user-supplied plugins directory\n\tstruct uwsgi_string_list *pdir = uwsgi.plugins_dir;\n\twhile (pdir) {\n\t\tplugin_filename = uwsgi_concat3(pdir->value, \"/\", plugin_name);\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_filename);\n#endif\n\t\tplugin_handle = dlopen(plugin_filename, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (plugin_handle) {\n\t\t\tplugin_abs_path = plugin_filename;\n\t\t\t//free(plugin_filename);\n\t\t\tgoto success;\n\t\t}\n\t\tfree(plugin_filename);\n\t\tplugin_filename = NULL;\n\t\tpdir = pdir->next;\n\t}\n\n\t// last step: search in compile-time plugin_dir\n\tif (!plugin_handle) {\n\t\tplugin_filename = uwsgi_concat3(UWSGI_PLUGIN_DIR, \"/\", plugin_name);\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_filename);\n#endif\n\t\tplugin_handle = dlopen(plugin_filename, RTLD_NOW | RTLD_GLOBAL);\n\t\tplugin_abs_path = plugin_filename;\n\t\t//free(plugin_filename);\n\t}\n\nsuccess:\n\tif (!plugin_handle) {\n\t\tif (!has_option)\n\t\t\tuwsgi_log(\"!!! UNABLE to load uWSGI plugin: %s !!!\\n\", dlerror());\n\t}\n\telse {\n\t\tif (init_func) {\n\t\t\tvoid (*plugin_init_func)() = dlsym(plugin_handle, init_func);\n\t\t\tif (plugin_init_func) {\n\t\t\t\tplugin_init_func();\n\t\t\t}\n\t\t}\n\t\tchar *plugin_entry_symbol = uwsgi_concat2n(plugin_symbol_name_start, strlen(plugin_symbol_name_start) - 3, \"\", 0);\n\t\tup = dlsym(plugin_handle, plugin_entry_symbol);\n\t\tif (!up) {\n\t\t\t// is it a link ?\n\t\t\tmemset(linkpath_buf, 0, 1024);\n\t\t\tmemset(linkpath, 0, 1024);\n\t\t\tif ((linkpath_size = readlink(plugin_abs_path, linkpath_buf, 1023)) > 0) {\n\t\t\t\tdo {\n\t\t\t\t\tlinkpath_buf[linkpath_size] = '\\0';\n\t\t\t\t\tstrncpy(linkpath, linkpath_buf, linkpath_size + 1);\n\t\t\t\t} while ((linkpath_size = readlink(linkpath, linkpath_buf, 1023)) > 0);\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s\\n\", linkpath);\n#endif\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\tchar *slash = uwsgi_get_last_char(linkpath, '/');\n\t\t\t\tif (!slash) {\n\t\t\t\t\tslash = linkpath;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tslash++;\n\t\t\t\t}\n\t\t\t\tplugin_entry_symbol = uwsgi_concat2n(slash, strlen(slash) - 3, \"\", 0);\n\t\t\t\tup = dlsym(plugin_handle, plugin_entry_symbol);\n\t\t\t}\n\t\t}\n\t\tif (up) {\n\t\t\tif (!up->name) {\n\t\t\t\tuwsgi_log(\"the loaded plugin (%s) has no .name attribute\\n\", plugin_name);\n\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t}\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(plugin_name);\n\t\t\t\tif (plugin_filename)\n\t\t\t\t\tfree(plugin_filename);\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (plugin_already_loaded(up->name)) {\n\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t}\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(plugin_name);\n\t\t\t\tif (plugin_filename)\n\t\t\t\t\tfree(plugin_filename);\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (has_option) {\n\t\t\t\tstruct uwsgi_option *op = up->options;\n\t\t\t\tint found = 0;\n\t\t\t\twhile (op && op->name) {\n\t\t\t\t\tif (!strcmp(has_option, op->name)) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\top++;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t\t}\n\t\t\t\t\tif (need_free)\n\t\t\t\t\t\tfree(plugin_name);\n\t\t\t\t\tif (plugin_filename)\n\t\t\t\t\t\tfree(plugin_filename);\n\t\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (modifier != -1) {\n\t\t\t\tfill_plugin_table(modifier, up);\n\t\t\t\tup->modifier1 = modifier;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfill_plugin_table(up->modifier1, up);\n\t\t\t}\n\t\t\tif (need_free)\n\t\t\t\tfree(plugin_name);\n\t\t\tif (plugin_filename)\n\t\t\t\tfree(plugin_filename);\n\t\t\tfree(plugin_entry_symbol);\n\n\t\t\tif (up->on_load)\n\t\t\t\tup->on_load();\n\t\t\treturn plugin_handle;\n\t\t}\n\t\tif (!has_option)\n\t\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t}\n\nend:\n\tif (need_free)\n\t\tfree(plugin_name);\n\tif (plugin_filename)\n\t\tfree(plugin_filename);\n\n\treturn NULL;\n}\n\nint uwsgi_try_autoload(char *option) {\n\tDIR *d;\n\tstruct dirent *dp;\n\t// step dir, check for user-supplied plugins directory\n\tstruct uwsgi_string_list *pdir = uwsgi.plugins_dir;\n\twhile (pdir) {\n\t\td = opendir(pdir->value);\n\t\tif (d) {\n\t\t\twhile ((dp = readdir(d)) != NULL) {\n\t\t\t\tif (uwsgi_endswith(dp->d_name, \"_plugin.so\")) {\n\t\t\t\t\tchar *filename = uwsgi_concat3(pdir->value, \"/\", dp->d_name);\n\t\t\t\t\tif (uwsgi_load_plugin(-1, filename, option)) {\n\t\t\t\t\t\tuwsgi_log(\"option \\\"%s\\\" found in plugin %s\\n\", option, filename);\n\t\t\t\t\t\tfree(filename);\n\t\t\t\t\t\tclosedir(d);\n\t\t\t\t\t\t// add new options\n\t\t\t\t\t\tbuild_options();\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tfree(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\t\t}\n\t\tpdir = pdir->next;\n\t}\n\n\t// last step: search in compile-time plugin_dir\n\td = opendir(UWSGI_PLUGIN_DIR);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dp = readdir(d)) != NULL) {\n\t\tif (uwsgi_endswith(dp->d_name, \"_plugin.so\")) {\n\t\t\tchar *filename = uwsgi_concat3(UWSGI_PLUGIN_DIR, \"/\", dp->d_name);\n\t\t\tif (uwsgi_load_plugin(-1, filename, option)) {\n\t\t\t\tuwsgi_log(\"option \\\"%s\\\" found in plugin %s\\n\", option, filename);\n\t\t\t\tfree(filename);\n\t\t\t\tclosedir(d);\n\t\t\t\t// add new options\n\t\t\t\tbuild_options();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t}\n\t}\n\n\tclosedir(d);\n\n\treturn 0;\n\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-f2z6xs55nx7kocctg7e4ltegfocvo2n6/spack-src/logo_uWSGI.png"
    ],
    "total_files": 648
}