{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/PiP-Testsuite/PiP-Testsuite/compat/compat-v3.list": "timer 1 pip_blt 1 1 ./ctype\ntimer 1 pip_blt 8 8 ./ctype\ntimer 1 pip_blt 1 1 ./environ\ntimer 1 pip_blt 8 8 ./environ\ntimer 100 pip_blt 1 1 ./malloc\ntimer 400 pip_blt 8 8 ./malloc\ntimer 1 pip_blt 1 1 ./system\ntimer 1 pip_blt 8 8 ./system\ntimer 1 pip_blt 1 1 ./gettimeofday\ntimer 1 pip_blt 8 8 ./gettimeofday\ntimer 1 pip_blt 1 1 ./gethostname\ntimer 1 pip_blt 8 8 ./gethostname\ntimer 1 pip_blt 1 1 ./gethostbyname\ntimer 1 pip_blt 8 8 ./gethostbyname\ntimer 1 pip_blt 1 1 ./const_destruct\ntimer 1 pip_blt 8 8 ./const_destruct\ntimer 1 pip_blt 1 1 ./get_nprocs\ntimer 1 pip_blt 8 8 ./get_nprocs\ntimer 1 pip_blt 1 1 ./fork\ntimer 1 pip_blt 8 8 ./fork\nskip T UNSUPPORTED timer 1 pip_blt 1 1 ./pip_dlopen\nskip T UNSUPPORTED timer 1 pip_blt 8 8 ./pip_dlopen\ntimer  5 pip_blt 1 1 ./getaddrinfo\ntimer 10 pip_blt 8 8 ./getaddrinfo\ntimer 2  pip_blt 1 1 ./malloc-x\ntimer 10 pip_blt 8 8 ./malloc-x\ntimer 2  pip_blt 1 1 ./realloc-x\ntimer 10 pip_blt 8 8 ./realloc-x\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/PiP-Testsuite/PiP-Testsuite/compat/pip_dlopen.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_TESTSUITE: Version 1.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#include <libgen.h>\n#include <limits.h>\n#include <test.h>\n\n#define LIBNAME \t\"./libnull.so\"\n\nvoid *pip_dlopen( const char*, int );\nvoid *pip_dlsym( void*, const char* );\nint   pip_dlclose( void* );\n\nint main( int argc, char **argv ) {\n  void *handle;\n  int(*foo)(void);\n\n  CHECK( pip_init(NULL,NULL,NULL,0), RV, return(EXIT_FAIL) );\n  CHECK( handle = pip_dlopen( LIBNAME, RTLD_LAZY ),\n\t handle==NULL,\n\t return(EXIT_FAIL) );\n  CHECK( ( foo = pip_dlsym( handle, \"foo\" ) ), foo==0, return(EXIT_FAIL) );\n  CHECK( foo(),                                    RV, return(EXIT_FAIL) );\n  //CHECK( pip_dlclose( handle ),                    RV, return(EXIT_FAIL) );\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/PiP-Testsuite/PiP-Testsuite/compat/compat-v2.list": "timer 1 ./pagefault 1\ntimer 1 ./pagefault 8\ntimer 1 pip_task 1 ./fork\ntimer 1 pip_task 8 ./fork\nskip T UNSUPPORTED timer 1 pip_task 1 ./pip_dlopen\nskip T UNSUPPORTED timer 1 pip_task 8 ./pip_dlopen\ntimer  5 pip_task 1 ./getaddrinfo\ntimer 10 pip_task 8 ./getaddrinfo\ntimer 10 pip_task 8 ./malloc-x\ntimer 10 pip_task 8 ./realloc-x\n##timer 1 ./sigchld 1\n##timer 1 ./sigchld 8\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/lib/pip_dlfcn.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 2.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n\n/* locked dl* functions */\n\nvoid *pip_dlopen( const char *filename, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlopen( filename, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nvoid *pip_dlmopen( long lmid, const char *path, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlmopen( lmid, path, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nint pip_dlinfo( void *handle, int request, void *info ) {\n  int rv;\n  pip_glibc_lock();\n  rv = dlinfo( handle, request, info );\n  pip_glibc_unlock();\n  return rv;\n}\n\nvoid *pip_dlsym( void *handle, const char *symbol ) {\n  void *addr;\n  pip_glibc_lock();\n  addr = dlsym( handle, symbol );\n  pip_glibc_unlock();\n  return addr;\n}\n\nint pip_dladdr( void *addr, void *info ) {\n  Dl_info *dlinfo = (Dl_info*) info;\n  int rv;\n  pip_glibc_lock();\n  rv = dladdr( addr, dlinfo );\n  pip_glibc_unlock();\n  return rv;\n}\n\nint pip_dlclose( void *handle ) {\n  int rv = 0;\n  pip_glibc_lock();\n  rv = dlclose( handle );\n  pip_glibc_unlock();\n  return rv;\n}\n\nchar *pip_dlerror( void ) {\n  char *dlerr;\n  pip_glibc_lock();\n  dlerr = dlerror();\n  pip_glibc_unlock();\n  return dlerr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/lib/pip.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 2.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#include <pip/pip_internal.h>\n#include <pip/pip.h>\n\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <sched.h>\n#include <malloc.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <sys/prctl.h>\n\n//#define PIP_NO_MALLOPT\n\n//#define DEBUG\n//#define PRINT_MAPS\n//#define PRINT_FDS\n\n/* the EVAL env. is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#define PIP_INTERNAL_FUNCS\n#include <pip/pip.h>\n#include <pip/pip_util.h>\n#include <pip/pip_gdbif.h>\n\nextern char \t\t**environ;\n\n/*** note that the following static variables are   ***/\n/*** located at each PIP task and the root process. ***/\npip_root_t\t\t*pip_root = NULL;\npip_task_t\t\t*pip_task = NULL;\n\nstatic pip_clone_t*\tpip_cloneinfo = NULL;\npip_spinlock_t *pip_lock_clone PIP_PRIVATE;\n\nstatic int (*pip_clone_mostly_pthread_ptr) (\n\tpthread_t *newthread,\n\tint clone_flags,\n\tint core_no,\n\tsize_t stack_size,\n\tvoid *(*start_routine) (void *),\n\tvoid *arg,\n\tpid_t *pidp) = NULL;\n\nstruct pip_gdbif_root\t*pip_gdbif_root;\n\nint pip_root_p_( void ) {\n  return pip_root != NULL && pip_task != NULL &&\n    pip_root->task_root == pip_task;\n}\n\nint pip_is_pthread_( void ) {\n  return (pip_root->opts & PIP_MODE_PTHREAD) != 0 ? CLONE_THREAD : 0;\n}\n\nstatic void pip_set_name( char *symbol, char *progname ) {\n#ifdef PR_SET_NAME\n  /* the following code is to set the right */\n  /* name shown by the ps and top commands  */\n  char nam[16];\n\n  if( progname == NULL ) {\n    char prg[16];\n    prctl( PR_GET_NAME, prg, 0, 0, 0 );\n    snprintf( nam, 16, \"%s%s\", symbol, prg );\n  } else {\n    char *p;\n    if( ( p = strrchr( progname, '/' ) ) != NULL) {\n      progname = p + 1;\n    }\n    snprintf( nam, 16, \"%s%s\", symbol, progname );\n  }\n  if( !pip_is_pthread_() ) {\n#define FMT \"/proc/self/task/%u/comm\"\n    char fname[sizeof(FMT)+8];\n    int fd;\n\n    (void) prctl( PR_SET_NAME, nam, 0, 0, 0 );\n    sprintf( fname, FMT, (unsigned int) pip_gettid() );\n    if( ( fd = open( fname, O_RDWR ) ) >= 0 ) {\n      (void) write( fd, nam, strlen(nam) );\n      (void) close( fd );\n    }\n  } else {\n    (void) pthread_setname_np( pthread_self(), nam );\n  }\n#endif\n}\n\nstatic char pip_cmd_name_symbol( int opts ) {\n  char sym;\n\n  switch( opts & PIP_MODE_MASK ) {\n  case PIP_MODE_PROCESS_PRELOAD:\n    sym = ':';\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    sym = ';';\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    sym = '.';\n    break;\n  case PIP_MODE_PTHREAD:\n    sym = '|';\n    break;\n  default:\n    sym = '?';\n    break;\n  }\n  return sym;\n}\n\nstatic int pip_count_vec( char **vecsrc ) {\n  int n;\n  for( n=0; vecsrc[n]!= NULL; n++ );\n  return( n );\n}\n\nstatic void pip_set_magic( pip_root_t *root ) {\n  memcpy( root->magic, PIP_MAGIC_WORD, PIP_MAGIC_WLEN );\n}\n\nvoid pip_reset_task_struct( pip_task_t *taskp ) {\n  void\t*namexp = taskp->named_exptab;\n  memset( (void*) taskp, 0, sizeof(pip_task_t) );\n  taskp->pipid = PIP_PIPID_NONE;\n  taskp->type  = PIP_TYPE_NULL;\n  taskp->named_exptab = namexp;\n}\n\n#include <elf.h>\n\nint pip_check_pie( const char *path, int flag_verbose ) {\n  struct stat stbuf;\n  Elf64_Ehdr elfh;\n  int fd;\n  int err = 0;\n\n  if( strchr( path, '/' ) == NULL ) {\n    if( flag_verbose ) {\n      pip_err_mesg( \"'%s' is not a path (no slash '/')\", path );\n    }\n    err = ENOENT;\n  } else if( ( fd = open( path, O_RDONLY ) ) < 0 ) {\n    err = errno;\n    if( flag_verbose ) {\n      pip_err_mesg( \"'%s': open() fails (%s)\", path, strerror( errno ) );\n    }\n  } else {\n    if( fstat( fd, &stbuf ) < 0 ) {\n      err = errno;\n      if( flag_verbose ) {\n\tpip_err_mesg( \"'%s': stat() fails (%s)\", path, strerror( errno ) );\n      }\n    } else if( ( stbuf.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH) ) == 0 ) {\n      if( flag_verbose ) {\n\tpip_err_mesg( \"'%s' is not executable\", path );\n      }\n      err = EACCES;\n    } else if( read( fd, &elfh, sizeof( elfh ) ) != sizeof( elfh ) ) {\n      if( flag_verbose ) {\n\tpip_err_mesg( \"Unable to read '%s'\", path );\n      }\n      err = EUNATCH;\n    } else if( elfh.e_ident[EI_MAG0] != ELFMAG0 ||\n\t       elfh.e_ident[EI_MAG1] != ELFMAG1 ||\n\t       elfh.e_ident[EI_MAG2] != ELFMAG2 ||\n\t       elfh.e_ident[EI_MAG3] != ELFMAG3 ) {\n      if( flag_verbose ) {\n\tpip_err_mesg( \"'%s' is not ELF\", path );\n      }\n      err = ELIBBAD;\n    } else if( elfh.e_type != ET_DYN ) {\n      if( flag_verbose ) {\n\tpip_err_mesg( \"'%s' is not PIE\", path );\n      }\n      err = ELIBEXEC;\n    }\n    (void) close( fd );\n  }\n  return err;\n}\n\nconst char *pip_get_mode_str( void ) {\n  char *mode;\n\n  if( pip_root == NULL ) return NULL;\n  switch( pip_root->opts & PIP_MODE_MASK ) {\n  case PIP_MODE_PTHREAD:\n    mode = PIP_ENV_MODE_PTHREAD;\n    break;\n  case PIP_MODE_PROCESS:\n    mode = PIP_ENV_MODE_PROCESS;\n    break;\n  case PIP_MODE_PROCESS_PRELOAD:\n    mode = PIP_ENV_MODE_PROCESS_PRELOAD;\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    mode = PIP_ENV_MODE_PROCESS_GOT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    mode = PIP_ENV_MODE_PROCESS_PIPCLONE;\n    break;\n  default:\n    mode = \"(unknown)\";\n  }\n  return mode;\n}\n\nstatic int pip_check_opt_and_env( int *optsp ) {\n  extern pip_spinlock_t pip_lock_got_clone;\n  int opts   = *optsp;\n  int mode   = ( opts & PIP_MODE_MASK );\n  int newmod = 0;\n  char *env  = getenv( PIP_ENV_MODE );\n\n  enum PIP_MODE_BITS {\n    PIP_MODE_PTHREAD_BIT          = 1,\n    PIP_MODE_PROCESS_PRELOAD_BIT  = 2,\n    PIP_MODE_PROCESS_GOT_BIT      = 4,\n    PIP_MODE_PROCESS_PIPCLONE_BIT = 8\n  } desired = 0;\n\n  if( ( opts & ~PIP_VALID_OPTS ) != 0 ) {\n    /* unknown option(s) specified */\n    RETURN( EINVAL );\n  }\n  /* check if pip_preload.so is pre-loaded. if so, */\n  /* PIP_MODE_PROCESS_PRELOAD is the only choice   */\n  if( pip_cloneinfo == NULL ) {\n    pip_cloneinfo = (pip_clone_t*) dlsym( RTLD_DEFAULT, \"pip_clone_info\");\n  }\n  DBGF( \"cloneinfo:%p\", pip_cloneinfo );\n  if( pip_cloneinfo != NULL ) {\n    DBGF( \"mode:0x%x\", mode );\n    if( mode == 0 || \n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == mode ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( mode & ~PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload must be specified at pip_init()\" );\n      RETURN( EPERM );\n    }\n    if( env == NULL || env[0] == '\\0' ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ||\n\tstrcasecmp( env, PIP_ENV_MODE_PROCESS         ) == 0 ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    } else {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is the only valid choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  } else {\n    /* pip_preload.so is not loaded. i.e., LD_PRELOAD does not include pip_preload.so */\n    if( mode != 0 &&\n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload might be a wrong choice\" );\n      RETURN( EPERM );\n    }\n    if( env != NULL && strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is a wrong choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  }\n\n  switch( mode ) {\n  case 0:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PTHREAD_BIT     |\n\t        PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_THREAD  ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_MODE_PTHREAD ) == 0 ) {\n      desired = PIP_MODE_PTHREAD_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PTHREAD:\n    desired = PIP_MODE_PTHREAD_BIT;\n    break;\n  case PIP_MODE_PROCESS:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    desired = PIP_MODE_PROCESS_GOT_BIT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    break;\n  default:\n    RETURN( EINVAL );\n  }\n\n  if( desired & PIP_MODE_PROCESS_GOT_BIT ) {\n    int pip_wrap_clone( void );\n    if( pip_wrap_clone() == 0 ) {\n      newmod = PIP_MODE_PROCESS_GOT;\n      pip_lock_clone = &pip_lock_got_clone;\n      goto done;\n    } else if( !( desired & ( PIP_MODE_PTHREAD_BIT |\n\t\t\t      PIP_MODE_PROCESS_PIPCLONE_BIT ) ) ) {\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PROCESS_PIPCLONE_BIT ) {\n    if ( pip_clone_mostly_pthread_ptr == NULL )\n      pip_clone_mostly_pthread_ptr =\n\tdlsym( RTLD_DEFAULT, \"pip_clone_mostly_pthread\" );\n    if ( pip_clone_mostly_pthread_ptr != NULL ) {\n      newmod = PIP_MODE_PROCESS_PIPCLONE;\n      goto done;\n    } else if( !( desired & PIP_MODE_PTHREAD_BIT) ) {\n      pip_err_mesg( \"%s mode is requested but pip_clone_mostly_pthread() \"\n\t\t    \"cannot not be found in (PiP-)glibc\",\n\t\t    PIP_ENV_MODE_PROCESS_PIPCLONE );\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PTHREAD_BIT ) {\n    newmod = PIP_MODE_PTHREAD;\n  }\n\n done:\n  *optsp = ( opts & ~PIP_MODE_MASK ) | newmod;\n  RETURN( 0 );\n}\n\n/* signal handlers */\n\nvoid pip_set_signal_handler( int sig,\n\t\t\t     void(*handler)(),\n\t\t\t     struct sigaction *oldp ) {\n  struct sigaction\tsigact;\n\n  memset( &sigact, 0, sizeof( sigact ) );\n  sigact.sa_sigaction = handler;\n  ASSERT( sigemptyset( &sigact.sa_mask )    != 0 );\n  ASSERT( sigaddset( &sigact.sa_mask, sig ) != 0 );\n  ASSERT( sigaction( sig, &sigact, oldp )   != 0 );\n}\n\nvoid pip_unset_signal_handler( int sig, struct sigaction *oldp ) {\n  ASSERT( sigaction( sig, oldp, NULL ) != 0 );\n}\n\nstatic void pip_sigchld_handler( int sig, siginfo_t *info, void *extra ) {}\n\nstatic void pip_sigterm_handler( int sig, siginfo_t *info, void *extra ) {\n  ENTER;\n  ASSERT( pip_task->pipid != PIP_PIPID_ROOT );\n  (void) pip_kill_all_tasks();\n  (void) kill( getpid(), SIGKILL );\n}\n\nvoid pip_set_sigmask( int sig ) {\n  sigset_t sigmask;\n\n  ASSERT( sigemptyset( &sigmask ) );\n  ASSERT( sigaddset(   &sigmask, sig ) );\n  ASSERT( sigprocmask( SIG_BLOCK, &sigmask, &pip_root->old_sigmask ) );\n}\n\nvoid pip_unset_sigmask( void ) {\n  ASSERT( sigprocmask( SIG_SETMASK, &pip_root->old_sigmask, NULL ) );\n}\n\n/* save PiP environments */\n\nstatic void pip_save_debug_envs( pip_root_t *root ) {\n  char *env;\n\n  if( ( env = getenv( PIP_ENV_STOP_ON_START ) ) != NULL )\n    root->envs.stop_on_start = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_PATH      ) ) != NULL )\n    root->envs.gdb_path      = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_COMMAND   ) ) != NULL )\n    root->envs.gdb_command   = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_SIGNALS   ) ) != NULL )\n    root->envs.gdb_signals   = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_MAPS     ) ) != NULL )\n    root->envs.show_maps     = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_PIPS     ) ) != NULL )\n    root->envs.show_pips    = strdup( env );\n}\n\nint pip_init( int *pipidp, int *ntasksp, void **rt_expp, int opts ) {\n  void pip_named_export_init( pip_task_t* );\n  pip_task_t\t*task;\n  size_t\tsz;\n  char\t\t*envroot = NULL;\n  char\t\t*envtask = NULL;\n  int\t\tntasks;\n  int \t\tpipid;\n  int \t\ti, err = 0;\n\n  if( ( envroot = getenv( PIP_ROOT_ENV ) ) == NULL ) {\n    /* root process ? */\n    if( pip_root != NULL ) RETURN( EBUSY ); /* already initialized */\n    if( ntasksp == NULL ) {\n      ntasks = PIP_NTASKS_MAX;\n    } else if( *ntasksp <= 0 ) {\n      RETURN( EINVAL );\n    } else {\n      ntasks = *ntasksp;\n    }\n    if( ntasks > PIP_NTASKS_MAX ) RETURN( EOVERFLOW );\n\n    if( ( err = pip_check_opt_and_env( &opts ) ) != 0 ) RETURN( err );\n    sz = sizeof( pip_root_t ) + sizeof( pip_task_t ) * ( ntasks + 1 );\n    pip_page_alloc( sz, (void**) &pip_root );\n    (void) memset( pip_root, 0, sz );\n    pip_root->size_whole = sz;\n    pip_root->size_root  = sizeof( pip_root_t );\n    pip_root->size_task  = sizeof( pip_task_t );\n\n    pip_spin_init( &pip_root->lock_ldlinux     );\n    pip_spin_init( &pip_root->lock_tasks       );\n    /* beyond this point, we can call the       */\n    /* pip_dlsymc() and pip_dlclose() functions */\n    pipid = PIP_PIPID_ROOT;\n    pip_set_magic( pip_root );\n    pip_root->version      = PIP_API_VERSION;\n    pip_root->ntasks       = ntasks;\n    pip_root->ntasks_count = 1; /* root is also a PiP task */\n    pip_root->cloneinfo    = pip_cloneinfo;\n    pip_root->opts         = opts;\n    pip_root->page_size    = sysconf( _SC_PAGESIZE );\n    pip_root->task_root    = &pip_root->tasks[ntasks];\n    pip_sem_init( &pip_root->lock_glibc );\n    pip_sem_post( &pip_root->lock_glibc );\n    pip_sem_init( &pip_root->sync_spawn );\n    for( i=0; i<ntasks+1; i++ ) {\n      pip_reset_task_struct( &pip_root->tasks[i] );\n      pip_named_export_init( &pip_root->tasks[i] );\n    }\n    if( rt_expp != NULL ) {\n      pip_root->export_root = *rt_expp;\n    }\n    pip_root->task_root->pipid  = pipid;\n    pip_root->task_root->type   = PIP_TYPE_ROOT;\n    pip_root->task_root->loaded = dlopen( NULL, RTLD_NOW );\n    pip_root->task_root->thread = pthread_self();\n    pip_root->task_root->tid    = pip_gettid();\n    pip_task = pip_root->task_root;\n    unsetenv( PIP_ROOT_ENV );\n    {\n      char sym[] = \"R*\";\n      sym[1] = pip_cmd_name_symbol( pip_root->opts );\n      pip_set_name( sym, NULL );\n    }\n    DBGF( \"PiP Execution Mode: %s\", pip_get_mode_str() );\n\n    pip_set_sigmask( SIGCHLD );\n    pip_set_signal_handler( SIGCHLD,\n\t\t\t    pip_sigchld_handler,\n\t\t\t    &pip_root->old_sigchld );\n    pip_set_signal_handler( SIGTERM,\n\t\t\t    pip_sigterm_handler,\n\t\t\t    &pip_root->old_sigterm );\n\n    pip_gdbif_initialize_root( ntasks );\n    pip_gdbif_task_commit( pip_task );\n\n    pip_save_debug_envs( pip_root );\n\n  } else if( ( envtask = getenv( PIP_TASK_ENV ) ) != NULL ) {\n    /* child task */\n    pip_root_t \t*root;\n    int\t\trv;\n\n    root = (pip_root_t*) strtoll( envroot, NULL, 16 );\n    pipid = (int) strtol( envtask, NULL, 10 );\n    ASSERT( pipid < 0 || pipid > root->ntasks );\n    task = &root->tasks[pipid];\n    if( ( rv = pip_init_task_implicitly( root, task ) ) == 0 ) {\n      ntasks = pip_root->ntasks;\n      /* succeeded */\n      if( ntasksp != NULL ) *ntasksp = ntasks;\n      if( rt_expp != NULL ) {\n\t*rt_expp = task->import_root;\n      }\n      unsetenv( PIP_ROOT_ENV );\n      unsetenv( PIP_TASK_ENV );\n    } else {\n      DBGF( \"rv:%d\", rv );\n      switch( rv ) {\n      case 1:\n\tpip_err_mesg( \"Invalid PiP root\" );\n\tbreak;\n      case 2:\n\tpip_err_mesg( \"Magic number error\" );\n\tbreak;\n      case 3:\n\tpip_err_mesg( \"Version miss-match between PiP root and task\" );\n\tbreak;\n      case 4:\n\tpip_err_mesg( \"Size miss-match between PiP root and task\" );\n\tbreak;\n      default:\n\tpip_err_mesg( \"Something wrong with PiP root and task\" );\n\tbreak;\n      }\n      RETURN( EPERM );\n    }\n  } else {\n    RETURN( EPERM );\n  }\n  /* root and child */\n  if( pipidp != NULL ) *pipidp = pipid;\n  DBGF( \"pip_root=%p  pip_task=%p\", pip_root, pip_task );\n\n  RETURN( err );\n}\n\nint pip_is_pthread( int *flagp ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( flagp    == NULL ) RETURN( EINVAL );\n  *flagp = pip_is_pthread_();\n  RETURN( 0 );\n}\n\nstatic int pip_is_shared_fd_( void ) {\n  return pip_is_threaded_();\n}\n\nint pip_is_shared_fd( int *flagp ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( flagp != NULL ) *flagp = pip_is_shared_fd_();\n  RETURN( 0 );\n}\n\nint pip_isa_piptask( void ) {\n  /* this function might be called before calling pip_init() */\n  return getenv( PIP_ROOT_ENV ) != NULL;\n}\n\npip_task_t *pip_get_task_( int pipid ) {\n  pip_task_t \t*task = NULL;\n\n  switch( pipid ) {\n  case PIP_PIPID_ROOT:\n    task = pip_root->task_root;\n    break;\n  default:\n    if( pipid >= 0 && pipid < pip_root->ntasks ) {\n      task = &pip_root->tasks[pipid];\n    }\n    break;\n  }\n  return task;\n}\n\nint pip_get_dso( int pipid, void **loaded ) {\n  pip_task_t *task;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  task = pip_get_task_( pipid );\n  if( loaded != NULL ) *loaded = task->loaded;\n  RETURN( 0 );\n}\n\nint pip_get_pipid_( void ) {\n  int pipid;\n  if( pip_root == NULL ) {\n    pipid = PIP_PIPID_ANY;\n  } else if( pip_root_p_() ) {\n    pipid = PIP_PIPID_ROOT;\n  } else {\n    pipid = pip_task->pipid;\n  }\n  return pipid;\n}\n\nint pip_get_pipid( int *pipidp ) {\n  if( pipidp == NULL ) RETURN( EINVAL );\n  *pipidp = pip_get_pipid_();\n  RETURN( 0 );\n}\n\nint pip_get_ntasks( int *ntasksp ) {\n  if( ntasksp  == NULL ) RETURN( EINVAL );\n  if( pip_root == NULL ) return( EPERM  ); /* intentionally using small return */\n  *ntasksp = pip_root->ntasks;\n  RETURN( 0 );\n}\n\nstatic pip_task_t *pip_get_myself( void ) {\n  pip_task_t *task;\n  if( pip_root_p_() ) {\n    task = pip_root->task_root;\n  } else {\n    task = pip_task;\n  }\n  return task;\n}\n\nint pip_export( void *export ) {\n  if( export == NULL ) RETURN( EINVAL );\n  pip_get_myself()->export = export;\n  RETURN( 0 );\n}\n\nint pip_import( int pipid, void **exportp  ) {\n  pip_task_t *task;\n  int err;\n\n  if( exportp == NULL ) RETURN( EINVAL );\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n\n  task = pip_get_task_( pipid );\n  *exportp = (void*) task->export;\n  pip_memory_barrier();\n  RETURN( 0 );\n}\n\nint pip_get_addr( int pipid, const char *name, void **addrp ) {\n  void *handle;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  if( name == NULL || addrp == NULL            ) RETURN( EINVAL );\n  DBGF( \"pipid=%d\", pipid );\n  if( pipid == PIP_PIPID_ROOT ) {;\n    *addrp = pip_dlsym( pip_root->task_root->loaded, name );\n  } else if( pipid == PIP_PIPID_MYSELF ) {\n    *addrp = pip_dlsym( pip_task->loaded, name );\n  } else if( ( handle = pip_root->tasks[pipid].loaded ) != NULL ) {\n    *addrp = pip_dlsym( handle, name );\n    /* FIXME: pip_dlsym() has a lock but this does not prevent for user */\n    /*        programs to directly call dl*() functions without lock    */\n    DBGF( \"=%p\", *addrp );\n  } else {\n    DBG;\n    err = ESRCH;\t\t/* tentative */\n  }\n  RETURN( err );\n}\n\nstatic int pip_copy_vec( char **vecadd,\n\t\t\t char **vecsrc,\t\t   /* input */\n\t\t\t pip_char_vec_t *cvecp ) { /* output */\n  char \t\t**vecdst, *p, *strs;\n  size_t\tveccc, sz;\n  int \t\tvecln, i, j;\n\n  vecln = 0;\n  veccc = 0;\n  if( vecadd != NULL ) {\n    for( i=0; vecadd[i]!=NULL; i++ ) {\n      vecln ++;\n      veccc += strlen( vecadd[i] ) + 1;\n    }\n  }\n  for( i=0; vecsrc[i]!=NULL; i++ ) {\n    vecln ++;\n    veccc += strlen( vecsrc[i] ) + 1;\n  }\n  vecln ++;\t\t/* plus final NULL */\n\n  sz = sizeof(char*) * vecln;\n  if( ( vecdst = (char**) malloc( sz    ) ) == NULL ) {\n    return ENOMEM;\n  }\n  if( ( strs   = (char*)  malloc( veccc ) ) == NULL ) {\n    free( vecdst );\n    free( strs   );\n    return ENOMEM;\n  }\n  p = strs;\n  j = 0;\n  if( vecadd != NULL ) {\n    for( i=0; vecadd[i]!=NULL; i++ ) {\n      vecdst[j++] = p;\n      p = stpcpy( p, vecadd[i] ) + 1;\n      //ASSERT( j      > vecln );\n      //ASSERT( p-strs > veccc );\n    }\n  }\n  for( i=0; vecsrc[i]!=NULL; i++ ) {\n    vecdst[j++] = p;\n    p = stpcpy( p, vecsrc[i] ) + 1;\n    //ASSERT( j      > vecln );\n    //ASSERT( p-strs > veccc );\n  }\n  vecdst[j] = NULL;\n  cvecp->vec  = vecdst;\n  cvecp->strs = strs;\n  return 0;\n}\n\n#define ENVLEN\t(64)\nstatic int pip_copy_env( char **envsrc, int pipid, pip_char_vec_t *vecp ) {\n  char rootenv[ENVLEN], taskenv[ENVLEN];\n  char *mallopt = \"MALLOC_MMAP_THRESHOLD_=1\";\n  char *preload_env = getenv( \"LD_PRELOAD\" );\n  char *addenv[] = { rootenv, taskenv, mallopt, preload_env, NULL };\n\n  ASSERT( snprintf( rootenv, ENVLEN, \"%s=%p\", PIP_ROOT_ENV, pip_root ) <= 0 );\n  ASSERT( snprintf( taskenv, ENVLEN, \"%s=%d\", PIP_TASK_ENV, pipid    ) <= 0 );\n  return pip_copy_vec( addenv, envsrc, vecp );\n}\n\nsize_t pip_stack_size( void ) {\n  char \t\t*env, *endptr;\n  ssize_t \ts, sz, scale, smax;\n  struct rlimit rlimit;\n\n  if( ( sz = pip_root->stack_size ) == 0 ) {\n    if( ( env = getenv( PIP_ENV_STACKSZ ) ) == NULL &&\n\t( env = getenv( \"KMP_STACKSIZE\" ) ) == NULL &&\n\t( env = getenv( \"OMP_STACKSIZE\" ) ) == NULL ) {\n      sz = PIP_STACK_SIZE;\t/* default */\n    } else {\n      if( ( sz = (ssize_t) strtoll( env, &endptr, 10 ) ) <= 0 ) {\n\tpip_err_mesg( \"stacksize: '%s' is illegal and \"\n\t\t      \"default size (%lu KiB) is set\",\n\t\t      env,\n\t\t      PIP_STACK_SIZE / 1024 );\n\tsz = PIP_STACK_SIZE;\t/* default */\n      } else {\n\tif( getrlimit( RLIMIT_STACK, &rlimit ) != 0 ) {\n\t  smax = PIP_STACK_SIZE_MAX;\n\t} else {\n\t  smax = rlimit.rlim_cur;\n\t}\n\tscale = 1;\n\tswitch( *endptr ) {\n\tcase 'T': case 't':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'G': case 'g':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'M': case 'm':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'K': case 'k':\n\tcase '\\0':\t\t/* default is KiB */\n\t  scale *= 1024;\n\t  sz *= scale;\n\t  break;\n\tcase 'B': case 'b':\n\t  for( s=PIP_STACK_SIZE_MIN; s<sz && s<smax; s*=2 );\n\t  break;\n\tdefault:\n\t  sz = PIP_STACK_SIZE;\n\t  pip_err_mesg( \"stacksize: '%s' is illegal and \"\n\t\t\t\"default size (%ldB) is used instead\",\n\t\t\tenv, sz );\n\t  break;\n\t}\n\tsz = ( sz < PIP_STACK_SIZE_MIN ) ? PIP_STACK_SIZE_MIN : sz;\n\tsz = ( sz > smax               ) ? smax               : sz;\n      }\n    }\n    pip_root->stack_size = sz;\n  }\n  return sz;\n}\n\nint pip_is_coefd( int fd ) {\n  int flags = fcntl( fd, F_GETFD );\n  return( flags > 0 && ( flags & FD_CLOEXEC ) );\n}\n\nstatic void pip_close_on_exec( void ) {\n  DIR *dir;\n  struct dirent *direntp;\n  int fd;\n\n#ifdef PRINT_FDS\n  pip_print_fds();\n#endif\n\n#define PROCFD_PATH\t\t\"/proc/self/fd\"\n  if( ( dir = opendir( PROCFD_PATH ) ) != NULL ) {\n    int fd_dir = dirfd( dir );\n    while( ( direntp = readdir( dir ) ) != NULL ) {\n      if( direntp->d_name[0] != '.' &&\n\t  ( fd = strtol( direntp->d_name, NULL, 10 ) ) >= 0 &&\n\t  fd != fd_dir &&\n\t  pip_is_coefd( fd ) ) {\n\t(void) close( fd );\n\tDBGF( \"FD:%d is closed (CLOEXEC)\", fd );\n#ifdef DEBUG\n\tpip_print_fd( fd );\n#endif\n      }\n    }\n    (void) closedir( dir );\n    (void) close( fd_dir );\n  }\n#ifdef PRINT_FDS\n  pip_print_fds();\n#endif\n}\n\nstatic int pip_find_user_symbols( pip_spawn_program_t *progp,\n\t\t\t\t  void *handle,\n\t\t\t\t  pip_task_t *task ) {\n  pip_symbols_t *symp = &task->symbols;\n  int err = 0;\n\n  pip_glibc_lock();\t\t/* to protect dlsym */\n  {\n    if( progp->funcname == NULL ) {\n      symp->main           = dlsym( handle, \"main\"                  );\n    } else {\n      symp->start          = dlsym( handle, progp->funcname         );\n    }\n  }\n  pip_glibc_unlock();\n\n  DBGF( \"func(%s):%p  main:%p\", progp->funcname, symp->start, symp->main );\n\n  /* check start function */\n  if( progp->funcname == NULL ) {\n    if( symp->main == NULL ) {\n      pip_err_mesg( \"Unable to find main \"\n\t\t    \"(possibly not linked with '-rdynamic' option)\" );\n      err = ENOEXEC;\n    }\n  } else if( symp->start == NULL ) {\n    pip_err_mesg( \"Unable to find start function (%s)\",\n\t\t  progp->funcname );\n    err = ENOEXEC;\n  }\n  RETURN( err );\n}\n\nstatic int\npip_find_glibc_symbols( void *handle, pip_task_t *task ) {\n  pip_symbols_t *symp = &task->symbols;\n  int err = 0;\n\n  pip_glibc_lock();\t\t/* to protect dlsym */\n  {\n    /* the GLIBC _init() seems not callable. It seems that */\n    /* dlmopen()ed name space does not setup VDSO properly */\n    symp->ctype_init       = dlsym( handle, \"__ctype_init\"  );\n    symp->mallopt          = dlsym( handle, \"mallopt\"       );\n    symp->libc_fflush      = dlsym( handle, \"fflush\"        );\n    symp->malloc_hook      = dlsym( handle, \"__malloc_hook\" );\n    symp->exit\t           = dlsym( handle, \"exit\"          );\n    symp->pthread_exit     = dlsym( handle, \"pthread_exit\"  );\n    /* GLIBC variables */\n    symp->libc_argcp     = dlsym( handle, \"__libc_argc\"     );\n    symp->libc_argvp     = dlsym( handle, \"__libc_argv\"     );\n    symp->environ        = dlsym( handle, \"environ\"         );\n    /* GLIBC misc. variables */\n    symp->prog           = dlsym( handle, \"__progname\"      );\n    symp->prog_full      = dlsym( handle, \"__progname_full\" );\n  }\n  pip_glibc_unlock();\n  RETURN( err );\n}\n\nstatic char *pip_find_newer_libpipinit( void ) {\n  struct stat\tstb_install, stb_build;\n  char\t\t*newer = NULL;\n\n  DBGF( \"%s\", PIP_INSTALL_LIBPIPINIT );\n  DBGF( \"%s\", PIP_BUILD_LIBPIPINIT );\n  memset( &stb_install, 0, sizeof(struct stat) );\n  memset( &stb_build,   0, sizeof(struct stat) );\n  if( stat( PIP_INSTALL_LIBPIPINIT, &stb_install ) != 0 ) {\n    /* not found in install dir */\n    if( stat( PIP_BUILD_LIBPIPINIT, &stb_build   ) != 0 ) {\n      /* nowhere */\n      return NULL;\n    }\n    newer = PIP_BUILD_LIBPIPINIT;\n  } else if( stat( PIP_BUILD_LIBPIPINIT, &stb_build ) != 0 ) {\n    /* not found in build dir, but install dir */\n    newer = PIP_INSTALL_LIBPIPINIT;\n  } else {\n    /* both found, take the newer one */\n    if( stb_install.st_mtime > stb_build.st_mtime ) {\n      newer = PIP_INSTALL_LIBPIPINIT;\n    } else {\n      newer = PIP_BUILD_LIBPIPINIT;\n    }\n  }\n  return newer;\n}\n\nstatic int\npip_load_dsos( pip_spawn_program_t *progp, pip_task_t *task) {\n  const char \t*path = progp->prog;\n  Lmid_t\tlmid;\n  char\t\t*libpipinit = NULL;\n  pip_init_t\timpinit     = NULL;\n  void \t\t*loaded     = NULL;\n  void\t\t*ld_glibc   = NULL;\n  void \t\t*ld_pipinit = NULL;\n  int \t\tflags = RTLD_NOW;\n  /* RTLD_GLOBAL is NOT accepted and dlmopen() returns EINVAL */\n  int\t\terr = 0;\n\n#ifdef RTLD_DEEPBIND\n  flags |= RTLD_DEEPBIND;\n#endif\n\n  ENTERF( \"path:%s\", path );\n  lmid = LM_ID_NEWLM;\n  if( ( loaded = pip_dlmopen( lmid, path, flags ) ) == NULL ) {\n    char *dle = pip_dlerror();\n    if( ( err = pip_check_pie( path, 1 ) ) != 0 ) goto error;\n    pip_err_mesg( \"dlmopen(%s): %s\", path, dle );\n    err = ENOEXEC;\n    goto error;\n  }\n  if( ( err = pip_find_glibc_symbols( loaded, task ) ) ) {\n    goto error;\n  }\n  if( ( err = pip_find_user_symbols( progp, loaded, task ) ) ) {\n    goto error;\n  }\n  if( pip_dlinfo( loaded, RTLD_DI_LMID, &lmid ) != 0 ) {\n    pip_err_mesg( \"Unable to obtain Lmid (%s): %s\",\n\t\t  libpipinit, pip_dlerror() );\n    err = ENXIO;\n    goto error;\n  }\n  DBGF( \"lmid:%d\", (int) lmid );\n  /* call pip_init_task_implicitly */\n  /*** we cannot call pip_ini_task_implicitly() directly here  ***/\n  /*** the name space contexts of here and there are different ***/\n  impinit = (pip_init_t) pip_dlsym( loaded, \"pip_init_task_implicitly\" );\n  if( impinit == NULL ) {\n    DBGF( \"dlsym: %s\", pip_dlerror() );\n    if( ( libpipinit = pip_find_newer_libpipinit() ) != NULL ) {\n      DBGF( \"libpipinit: %s\", libpipinit );\n      if( ( ld_pipinit = pip_dlmopen( lmid, libpipinit, flags ) ) == NULL ) {\n\tpip_warn_mesg( \"Unable to load %s: %s\", libpipinit, pip_dlerror() );\n      } else {\n\timpinit = (pip_init_t)\n\t  pip_dlsym( ld_pipinit, \"pip_init_task_implicitly\" );\n\tDBGF( \"dlsym: %s\", pip_dlerror() );\n      }\n    }\n  }\n  task->symbols.pip_init = impinit;\n  task->loaded = loaded;\n  RETURN( 0 );\n\n error:\n  if( loaded     != NULL ) pip_dlclose( loaded    );\n  if( ld_glibc   != NULL ) pip_dlclose( ld_glibc  );\n  if( ld_pipinit != NULL ) pip_dlclose( ld_pipinit);\n  RETURN( err );\n}\n\nstatic int pip_load_prog( pip_spawn_program_t *progp,\n\t\t\t  pip_spawn_args_t *args,\n\t\t\t  pip_task_t *task ) {\n  int \terr;\n\n  ENTERF( \"prog=%s\", progp->prog );\n\n  PIP_ACCUM( time_load_dso,\n\t     ( err = pip_load_dsos( progp, task ) ) == 0 );\n  if( !err ) pip_gdbif_load( task );\n  RETURN( err );\n}\n\nint pip_do_corebind( pid_t tid, uint32_t coreno, cpu_set_t *oldsetp ) {\n  cpu_set_t cpuset;\n  int flags  = coreno & PIP_CPUCORE_FLAG_MASK;\n  int i, err = 0;\n\n  ENTER;\n  /* PIP_CPUCORE_* flags are exclusive */\n  if( ( flags & PIP_CPUCORE_ASIS ) != flags &&\n      ( flags & PIP_CPUCORE_ABS  ) != flags ) RETURN( EINVAL );\n  if( flags & PIP_CPUCORE_ASIS ) RETURN( 0 );\n  coreno &= PIP_CPUCORE_CORENO_MASK;\n  if( coreno >= PIP_CPUCORE_CORENO_MAX ) RETURN ( EINVAL );\n  if( tid == 0 ) tid = pip_gettid();\n\n  if( oldsetp != NULL ) {\n    if( sched_getaffinity( tid, sizeof(cpuset), oldsetp ) != 0 ) {\n      RETURN( errno );\n    }\n  }\n\n  if( flags == 0 ) {\n    int ncores, nth;\n\n    if( sched_getaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n      RETURN( errno );\n    }\n    if( ( ncores = CPU_COUNT( &cpuset ) ) ==  0 ) RETURN( 0 );\n    coreno %= ncores;\n    nth = coreno;\n    for( i=0; ; i++ ) {\n      if( !CPU_ISSET( i, &cpuset ) ) continue;\n      if( nth-- == 0 ) {\n\tCPU_ZERO( &cpuset );\n\tCPU_SET( i, &cpuset );\n\tif( sched_setaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n\t  err = errno;\n\t}\n\tbreak;\n      }\n    }\n  } else if( ( flags & PIP_CPUCORE_ABS ) == PIP_CPUCORE_ABS ) {\n    CPU_ZERO( &cpuset );\n    CPU_SET( coreno, &cpuset );\n    /* here, do not call pthread_setaffinity(). This MAY fail */\n    /* because pd->tid is NOT set yet.  I do not know why.    */\n    /* But it is OK to call sched_setaffinity() with tid.     */\n    if( sched_setaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n      RETURN( errno );\n    }\n  }\n  RETURN( err );\n}\n\nstatic int pip_undo_corebind( pid_t tid, uint32_t coreno, cpu_set_t *oldsetp ) {\n  int flags = coreno >> PIP_CPUCORE_FLAG_SHIFT;\n  int err = 0;\n\n  ENTER;\n  if( flags != PIP_CPUCORE_ASIS ) {\n    if( tid == 0 ) tid = pip_gettid();\n    /* here, do not call pthread_setaffinity().  See above comment. */\n    if( sched_setaffinity( tid, sizeof(cpu_set_t), oldsetp ) != 0 ) {\n      err = errno;\n    }\n  }\n  RETURN( err );\n}\n\nstatic void pip_glibc_init( pip_symbols_t *symbols,\n\t\t\t    pip_spawn_args_t *args ) {\n  /* setting GLIBC variables */\n  if( symbols->libc_argcp != NULL ) {\n    DBGF( \"&__libc_argc=%p\", symbols->libc_argcp );\n    *symbols->libc_argcp = args->argc;\n  }\n  if( symbols->libc_argvp != NULL ) {\n    DBGF( \"&__libc_argv=%p\", symbols->libc_argvp );\n    *symbols->libc_argvp = args->argvec.vec;\n  }\n  if( symbols->prog != NULL ) {\n    *symbols->prog = args->prog;\n  }\n  if( symbols->prog_full != NULL ) {\n    *symbols->prog_full = args->prog_full;\n  }\n  if( symbols->environ != NULL ) {\n    *symbols->environ = args->envvec.vec;\t/* setting environment vars */\n  }\n  if( symbols->ctype_init != NULL ) {\n    DBGF( \">> __ctype_init@%p\", symbols->ctype_init );\n    symbols->ctype_init();\n    DBGF( \"<< __ctype_init@%p\", symbols->ctype_init );\n  }\n\n#ifndef PIP_NO_MALLOPT\n  /* heap (using brk or sbrk) is not safe in PiP */\n  if( symbols->mallopt != NULL ) {\n#ifdef M_MMAP_THRESHOLD\n    if( symbols->mallopt( M_MMAP_THRESHOLD, 1 ) == 1 ) {\n      DBGF( \"mallopt(M_MMAP_THRESHOLD): succeeded\" );\n    } else {\n      pip_warn_mesg( \"mallopt(M_MMAP_THRESHOLD): failed !!!!!!\" );\n    }\n#endif\n  }\n#endif\n  if( symbols->malloc_hook != 0x0 ) { /* Kaiming Patch */\n    *symbols->malloc_hook = 0x0;\n  }\n}\n\nstatic void pip_glibc_fin( pip_symbols_t *symbols ) {\n  /* call fflush() in the target context to flush out messages */\n  if( symbols->libc_fflush != NULL ) {\n    DBGF( \">> fflush@%p()\", symbols->libc_fflush );\n    symbols->libc_fflush( NULL );\n    DBGF( \"<< fflush@%p()\", symbols->libc_fflush );\n  }\n}\n\nstatic void pip_return_from_start_func( pip_task_t *task,\n\t\t\t\t\tint extval ) {\n  int err = 0;\n\n  ENTER;\n  if( pip_gettid() != task->tid ) {\n    /* when a PiP task fork()s and returns */\n    /* from main this case happens         */\n    DBGF( \"return from a fork()ed process?\" );\n    /* here we have to call the exit() in the same context */\n    if( task->symbols.exit != NULL ) {\n      task->symbols.exit( extval );\n    } else {\n      exit( extval );\n    }\n    NEVER_REACH_HERE;\n  }\n  if( task->hook_after != NULL ) {\n    char **env_save = environ;\n    environ = task->args.envvec.vec;\n    err = task->hook_after( task->hook_arg );\n    environ = env_save;\n    if( err ) {\n      pip_err_mesg( \"PIPID:%d after-hook returns %d\", task->pipid, err );\n    }\n    if( extval == 0 ) extval = err;\n  }\n  pip_glibc_fin( &task->symbols );\n  if( task->symbols.named_export_fin != NULL ) {\n    task->symbols.named_export_fin( task );\n  }\n  pip_gdbif_exit( task, WEXITSTATUS(extval) );\n  pip_gdbif_hook_after( task );\n\n  DBGF( \"PIPID:%d -- FORCE EXIT:%d\", task->pipid, extval );\n  fflush( NULL );\n\n  if( pip_is_threaded_() ) {\t/* thread mode */\n    task->flag_sigchld = 1;\n    ASSERT( pip_raise_signal( pip_root->task_root, SIGCHLD ) );\n    if( task->symbols.pthread_exit != NULL ) {\n      task->symbols.pthread_exit( NULL );\n    } else {\n      pthread_exit( NULL );\n    }\n  } else {\t\t\t/* process mode */\n    if( task->symbols.exit != NULL ) {\n      task->symbols.exit( extval );\n    } else {\n      exit( extval );\n    }\n  }\n  NEVER_REACH_HERE;\n}\n\nstatic void pip_sigquit_handler( int, void(*)(), struct sigaction* )\n  __attribute__((noreturn));\nstatic void pip_sigquit_handler( int sig,\n\t\t\t\t void(*handler)(),\n\t\t\t\t struct sigaction *oldp ) {\n  ENTER;\n  pthread_exit( NULL );\n  NEVER_REACH_HERE;\n}\n\nstatic void pip_reset_signal_handler( int sig ) {\n  if( !pip_is_threaded_() ) {\n    struct sigaction\tsigact;\n    memset( &sigact, 0, sizeof( sigact ) );\n    sigact.sa_sigaction = (void(*)(int,siginfo_t*,void*)) SIG_DFL;\n    ASSERT( sigaction( sig, &sigact, NULL ) != 0 );\n  } else {\n    sigset_t sigmask;\n    (void) sigemptyset( &sigmask );\n    (void) sigaddset( &sigmask, sig );\n    ASSERT( pthread_sigmask( SIG_BLOCK, &sigmask, NULL ) != 0 );\n  }\n}\n\nstatic void *pip_do_spawn( void *thargs )  {\n  pip_spawn_args_t *args = (pip_spawn_args_t*) thargs;\n  int \tpipid      = args->pipid;\n  char **argv      = args->argvec.vec;\n  char **envv      = args->envvec.vec;\n  void *start_arg  = args->start_arg;\n  int coreno       = args->coreno;\n  pip_task_t *self = &pip_root->tasks[pipid];\n  pip_spawnhook_t before = self->hook_before;\n  void *hook_arg         = self->hook_arg;\n  int \textval = 0, err = 0;\n\n  ENTER;\n  self->thread = pthread_self();\n  self->tid    = pip_gettid();\n\n  pip_glibc_unlock();\n  pip_sem_post( &pip_root->sync_spawn );\n\n  if( ( err = pip_do_corebind( 0, coreno, NULL ) ) != 0 ) {\n    pip_warn_mesg( \"failed to bound CPU core:%d (%d)\", coreno, err );\n    err = 0;\n  }\n  {\n    char sym[] = \"0*\";\n    sym[0] += ( pipid % 10 );\n    sym[1] = pip_cmd_name_symbol( pip_root->opts );\n    pip_set_name( sym, args->prog );\n  }\n  if( !pip_is_threaded_() ) {\n    pip_reset_signal_handler( SIGCHLD );\n    pip_reset_signal_handler( SIGTERM );\n    (void) setpgid( 0, (pid_t) pip_root->task_root->tid );\n  } else {\n    pip_set_signal_handler( SIGQUIT, pip_sigquit_handler, NULL );\n  }\n#ifdef DEBUG\n  if( pip_is_pthread_() ) {\n    pthread_attr_t attr;\n    size_t sz;\n    int _err;\n    if( ( _err = pthread_getattr_np( self->thread, &attr      ) ) != 0 ) {\n      DBGF( \"pthread_getattr_np()=%d\", _err );\n    } else if( ( _err = pthread_attr_getstacksize( &attr, &sz ) ) != 0 ) {\n      DBGF( \"pthread_attr_getstacksize()=%d\", _err );\n    } else {\n      DBGF( \"stacksize = %ld [KiB]\", sz/1024 );\n    }\n  }\n#endif\n  if( !pip_is_shared_fd_() ) pip_close_on_exec();\n\n  /* let pip-gdb know */\n  pip_gdbif_task_commit( self );\n\n  /* calling before hook, if any */\n  if( before != NULL ) {\n    char **env_save = environ;\n    environ = envv;\n    err = before( hook_arg );\n    args->envvec.vec = environ;\n    environ = env_save;\n\n    if( err ) {\n      pip_warn_mesg( \"try to spawn(%s), but the before hook at %p returns %d\",\n\t\t     argv[0], before, err );\n      extval = err;\n    }\n  }\n  if( !err ) {\n    pip_glibc_init( &self->symbols, args );\n    if( self->symbols.pip_init != NULL ) {\n      err = self->symbols.pip_init( pip_root, self );\n    }\n    if( err ) {\n      extval = err;\n    } else {\n      char *env_stop;\n\n      pip_gdbif_hook_before( self );\n      if( ( env_stop = pip_root->envs.stop_on_start ) != NULL ) {\n\tint pipid_stop = strtol( env_stop, NULL, 10 );\n\tif( pipid_stop < 0 || pipid_stop == self->pipid ) {\n\t  pip_info_mesg( \"PiP task[%d] is SIGSTOPed (%s=%s)\",\n\t\t\t self->pipid, PIP_ENV_STOP_ON_START, env_stop );\n\t  pip_kill( self->pipid, SIGSTOP );\n\t}\n      }\n      if( self->symbols.start == NULL ) {\n\t/* calling hook function, if any */\n\tDBGF( \"[%d] >> main@%p(%d,%s,%s,...)\",\n\t      args->pipid, self->symbols.main, args->argc, argv[0], argv[1] );\n\textval = self->symbols.main( args->argc, argv, envv );\n\tDBGF( \"[%d] << main@%p(%d,%s,%s,...) = %d\",\n\t      args->pipid, self->symbols.main, args->argc, argv[0], argv[1],\n\t      extval );\n      } else {\n\tDBGF( \"[%d] >> %s:%p(%p)\",\n\t      args->pipid, args->funcname,\n\t      self->symbols.start, start_arg );\n\textval = self->symbols.start( start_arg );\n\tDBGF( \"[%d] << %s:%p(%p) = %d\",\n\t      args->pipid, args->funcname,\n\t      self->symbols.start, start_arg, extval );\n      }\n    }\n  }\n  pip_return_from_start_func( self, extval );\n  NEVER_REACH_HERE;\n  return NULL;\t\t\t/* dummy */\n}\n\nstatic int pip_find_a_free_task( int *pipidp ) {\n  int pipid = *pipidp;\n  int err = 0;\n\n  if( pip_root->ntasks_accum >= PIP_NTASKS_MAX ) RETURN( EOVERFLOW );\n  if( pipid < PIP_PIPID_ANY || pipid >= pip_root->ntasks ) {\n    DBGF( \"pipid=%d\", pipid );\n    RETURN( EINVAL );\n  }\n\n  pip_spin_lock( &pip_root->lock_tasks );\n  /*** begin lock region ***/\n  do {\n    if( pipid != PIP_PIPID_ANY ) {\n      if( pip_root->tasks[pipid].pipid != PIP_PIPID_NONE ) {\n\terr = EAGAIN;\n\tgoto unlock;\n      }\n    } else {\n      int i;\n\n      for( i=pip_root->pipid_curr; i<pip_root->ntasks; i++ ) {\n\tif( pip_root->tasks[i].pipid == PIP_PIPID_NONE ) {\n\t  pipid = i;\n\t  goto found;\n\t}\n      }\n      for( i=0; i<pip_root->pipid_curr; i++ ) {\n\tif( pip_root->tasks[i].pipid == PIP_PIPID_NONE ) {\n\t  pipid = i;\n\t  goto found;\n\t}\n      }\n      err = EAGAIN;\n      goto unlock;\n    }\n  found:\n    pip_root->tasks[pipid].pipid = pipid;\t/* mark it as occupied */\n    pip_root->pipid_curr = pipid + 1;\n    *pipidp = pipid;\n\n  } while( 0 );\n unlock:\n  /*** end lock region ***/\n  pip_spin_unlock( &pip_root->lock_tasks );\n\n  RETURN( err );\n}\n\nstatic int pip_do_task_spawn( pip_spawn_program_t *progp,\n\t\t\t      int pipid,\n\t\t\t      int coreno,\n\t\t\t      uint32_t opts,\n\t\t\t      pip_task_t **tskp,\n\t\t\t      pip_spawn_hook_t *hookp ) {\n  cpu_set_t \t\tcpuset;\n  pip_spawn_args_t\t*args = NULL;\n  pip_task_t\t\t*task = NULL;\n  size_t\t\tstack_size;\n  int \t\t\terr = 0;\n\n  ENTER;\n  if( pip_root == NULL ) RETURN( EPERM );\n  if( !pip_isa_root()  ) RETURN( EPERM );\n  if( progp       == NULL ) RETURN( EINVAL );\n  if( progp->prog == NULL ) RETURN( EINVAL );\n  /* starting from main */\n  if( progp->funcname == NULL &&\n      ( progp->argv == NULL || progp->argv[0] == NULL ) ) {\n    RETURN( EINVAL );\n  }\n  /* starting from an arbitrary func */\n  if( progp->funcname == NULL && progp->prog == NULL ) {\n    progp->prog = progp->argv[0];\n  }\n  if( pipid == PIP_PIPID_MYSELF ||\n      pipid == PIP_PIPID_NULL ) {\n    RETURN( EINVAL );\n  }\n  if( pipid != PIP_PIPID_ANY ) {\n    if( pipid < 0 || pipid > pip_root->ntasks ) RETURN( EINVAL );\n  }\n  if( ( err = pip_find_a_free_task( &pipid ) ) != 0 ) goto error;\n  task = &pip_root->tasks[pipid];\n  pip_reset_task_struct( task );\n  task->pipid     = pipid;\t/* mark it as occupied */\n  task->type      = PIP_TYPE_TASK;\n  task->task_root = pip_root;\n\n  args = &task->args;\n  args->pipid     = pipid;\n  args->coreno    = coreno;\n  { \t\t\t\t/* GLIBC/misc/init-misc.c */\n    char *prog = progp->prog;\n    char *p = strrchr( prog, '/' );\n    if( p == NULL ) {\n      args->prog      = prog;\n    } else {\n      args->prog      = p + 1;\n      args->prog_full = prog;\n    }\n    DBGF( \"prog:%s full:%s\", args->prog, args->prog_full );\n  }\n  err = pip_copy_env( progp->envv, pipid, &args->envvec );\n  if( err ) ERRJ_ERR( err );\n\n  if( progp->funcname == NULL ) {\n    err = pip_copy_vec( NULL, progp->argv, &args->argvec );\n    if( err ) ERRJ_ERR( err );\n    args->argc = pip_count_vec( args->argvec.vec );\n  } else {\n    if( ( args->funcname = strdup( progp->funcname ) ) == NULL ) {\n      ERRJ_ERR( ENOMEM );\n    }\n    args->start_arg = progp->arg;\n  }\n  task->aux           = progp->aux;\n  if( progp->exp != NULL ) {\n    task->import_root = progp->exp;\n  } else {\n    task->import_root = pip_root->export_root;\n  }\n  if( hookp != NULL ) {\n    task->hook_before = hookp->before;\n    task->hook_after  = hookp->after;\n    task->hook_arg    = hookp->hookarg;\n  }\n  /* must be called before calling dlmopen() */\n  pip_gdbif_task_new( task );\n\n  if( ( err = pip_do_corebind( 0, coreno, &cpuset ) ) == 0 ) {\n    /* corebinding should take place before loading solibs,     */\n    /* hoping anon maps would be mapped onto the same numa node */\n    char **envv_root = environ;\n    /* environ must be saved before loading user program and  */\n    /* set to the specified one. this is because ld-linux and */\n    /* .init functions may refer and alter it                 */\n    environ = args->envvec.vec;\n    PIP_ACCUM( time_load_prog,\n\t       ( err = pip_load_prog( progp, args, task ) ) == 0 );\n    args->envvec.vec = environ;\n    environ = envv_root;\n    /* and of course, the corebinding must be undone */\n    (void) pip_undo_corebind( 0, coreno, &cpuset );\n  }\n  if( err != 0 ) goto error;\n\n  stack_size = pip_stack_size();\n  if( ( pip_root->opts & PIP_MODE_PROCESS_PIPCLONE ) ==\n      PIP_MODE_PROCESS_PIPCLONE ) {\n    int flags = pip_clone_flags( CLONE_PARENT_SETTID |\n\t\t\t\t CLONE_CHILD_CLEARTID |\n\t\t\t\t CLONE_SYSVSEM |\n\t\t\t\t CLONE_PTRACE );\n    pid_t pid;\n\n    /* we need lock on ldlinux. supposedly glibc does someting */\n    /* before calling main function */\n    pip_glibc_lock();\n    err = pip_clone_mostly_pthread_ptr( &task->thread,\n\t\t\t\t\tflags,\n\t\t\t\t\t-1,\n\t\t\t\t\tstack_size,\n\t\t\t\t\t(void*(*)(void*)) pip_do_spawn,\n\t\t\t\t\targs,\n\t\t\t\t\t&pid );\n    DBGF( \"pip_clone_mostly_pthread_ptr()=%d\", err );\n    if( err ) pip_glibc_unlock();\n  } else {\n    pthread_attr_t \tattr;\n    pid_t \t\ttid = pip_gettid();\n\n    if( ( err = pthread_attr_init( &attr ) ) != 0 ) goto error;\n    err = pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_JOINABLE );\n    DBGF( \"pthread_attr_setdetachstate(JOINABLE)= %d\", err );\n    if( err ) goto error;\n    err = pthread_attr_setstacksize( &attr, stack_size );\n    DBGF( \"pthread_attr_setstacksize( %ld )= %d\", stack_size, err );\n    if( err ) goto error;\n\n    DBGF( \"tid=%d  cloneinfo@%p\", tid, pip_root->cloneinfo );\n    pip_glibc_lock();\n    do {\n      if( pip_lock_clone != NULL ) {\n\t/* lock is needed, because the pip_clone()\n\t     might also be called from outside of PiP lib. */\n\tpip_spin_lock_wv( pip_lock_clone, tid );\n      }\n      err = pthread_create( &task->thread,\n\t\t\t    &attr,\n\t\t\t    (void*(*)(void*)) pip_do_spawn,\n\t\t\t    (void*) args );\n      DBGF( \"pthread_create()=%d\", err );\n      if( err ) pip_glibc_unlock();\n    } while( 0 );\n    /* unlock is done in the wrapper function */\n  }\n  if( err == 0 ) {\n    pip_sem_wait( &pip_root->sync_spawn );\n    pip_root->ntasks_count ++;\n    pip_root->ntasks_accum ++;\n    pip_root->ntasks_curr  ++;\n    *tskp = task;\n\n  } else {\n  error:\t\t\t/* undo */\n    DBG;\n    if( args != NULL ) {\n      if( args->argvec.vec  != NULL ) free( args->argvec.vec  );\n      if( args->argvec.strs != NULL ) free( args->argvec.strs );\n      if( args->envvec.vec  != NULL ) free( args->envvec.vec  );\n      if( args->envvec.strs != NULL ) free( args->envvec.strs );\n    }\n    if( task != NULL ) {\n      if( task->loaded != NULL ) (void) pip_dlclose( task->loaded );\n      pip_reset_task_struct( task );\n    }\n  }\n  RETURN( err );\n}\n\nint pip_task_spawn( pip_spawn_program_t *progp,\n\t\t    uint32_t coreno,\n\t\t    uint32_t opts,\n\t\t    int *pipidp,\n\t\t    pip_spawn_hook_t *hookp ) {\n  pip_task_t\t*task = NULL;\n  int \t\tpipid;\n  int \t\terr;\n\n  ENTER;\n  if( pipidp == NULL ) {\n    pipid = PIP_PIPID_ANY;\n  } else {\n    pipid = *pipidp;\n  }\n  err = pip_do_task_spawn( progp, pipid, coreno, opts, &task, hookp );\n  if( !err ) {\n    if( pipidp != NULL ) *pipidp = task->pipid;\n  }\n  RETURN( err );\n}\n\nint pip_spawn( char *prog,\n\t       char **argv,\n\t       char **envv,\n\t       int   coreno,\n\t       int  *pipidp,\n\t       pip_spawnhook_t before,\n\t       pip_spawnhook_t after,\n\t       void *hookarg ) {\n  pip_spawn_program_t program;\n  pip_spawn_hook_t hook;\n\n  ENTER;\n  if( prog == NULL ) return EINVAL;\n  pip_spawn_from_main( &program, prog, argv, envv, NULL, NULL );\n  pip_spawn_hook( &hook, before, after, hookarg );\n  RETURN( pip_task_spawn( &program, coreno, 0, pipidp, &hook ) );\n}\n\nint pip_fin( void ) {\n  void pip_undo_patch_GOT( void );\n  int ntasks, i, err = 0;\n\n  DBG;\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  if( pip_root_p_() ) {\n    ntasks = pip_root->ntasks;\n    for( i=0; i<ntasks; i++ ) {\n      if( pip_root->tasks[i].type != PIP_TYPE_NULL ) {\n\tDBGF( \"%d/%d [%d] -- BUSY\", i, ntasks, pip_root->tasks[i].pipid );\n\terr = EBUSY;\n\tbreak;\n      }\n    }\n    if( err == 0 ) {\n      void pip_named_export_fin_all( void );\n      /* SIGCHLD */\n      pip_unset_sigmask();\n      pip_unset_signal_handler( SIGCHLD,\n\t\t\t\t&pip_root->old_sigchld );\n      /* SIGTERM */\n      pip_unset_signal_handler( SIGTERM,\n\t\t\t\t&pip_root->old_sigterm );\n\n      pip_named_export_fin_all();\n\n      PIP_REPORT( time_load_dso  );\n      PIP_REPORT( time_load_prog );\n      PIP_REPORT( time_dlmopen   );\n\n      memset( pip_root, 0, sizeof(pip_root_t) );\n      free( pip_root );\n      pip_root = NULL;\n      pip_task = NULL;\n\n      pip_undo_patch_GOT();\n    }\n  }\n  RETURN( err );\n}\n\nint pip_get_mode( int *mode ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( mode     == NULL ) RETURN( EINVAL );\n  *mode = ( pip_root->opts & PIP_MODE_MASK );\n  RETURN( 0 );\n}\n\nint pip_get_system_id( int pipid, pip_id_t *idp ) {\n  pip_task_t \t*task;\n  intptr_t\tid;\n  int \t\terr;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  if( pipid == PIP_PIPID_ROOT ) RETURN( EINVAL );\n\n  task = pip_get_task_( pipid );\n  if( pip_is_pthread_() ) {\n    /* Do not use gettid(). This is a very Linux-specific function */\n    /* The reason of supporintg the thread PiP execution mode is   */\n    /* some OSes other than Linux does not support clone()         */\n    id = (intptr_t) task->thread;\n  } else {\n    id = (intptr_t) task->tid;\n  }\n  if( idp != NULL ) *idp = id;\n  RETURN( 0 );\n}\n\nvoid pip_exit( int extval ) {\n  DBGF( \"extval:%d\", extval );\n  if( !pip_is_initialized() ) {\n    exit( extval );\n  } else if( pip_isa_root() ) {\n    exit( extval );\n  } else {\n    pip_return_from_start_func( pip_task, extval );\n  }\n  NEVER_REACH_HERE;\n}\n\npip_clone_t *pip_get_cloneinfo_( void ) {\n  return pip_root->cloneinfo;\n}\n\nint pip_get_pid_( int pipid, pid_t *pidp ) {\n  pid_t\tpid;\n  int \terr = 0;\n\n  if( pip_root->opts && PIP_MODE_PROCESS ) {\n    /* only valid with the \"process\" execution mode */\n    if( ( err = pip_check_pipid( &pipid ) ) == 0 ) {\n      if( pipid == PIP_PIPID_ROOT ) {\n\terr = EPERM;\n      } else {\n\tpid = pip_root->tasks[pipid].tid;\n      }\n    }\n  } else {\n    err = EPERM;\n  }\n  if( !err && pidp != NULL ) *pidp = pid;\n  RETURN( err );\n}\n\nint pip_barrier_init( pip_barrier_t *barrp, int n ) {\n  if( !pip_is_initialized() ) return EPERM;\n  if( n < 0 ) return EINVAL;\n  barrp->count      = n;\n  barrp->count_init = n;\n  barrp->gsense     = 0;\n  return 0;\n}\n\nint pip_barrier_wait( pip_barrier_t *barrp ) {\n  if( barrp->count_init > 1 ) {\n    int lsense = !barrp->gsense;\n    if( __sync_sub_and_fetch( &barrp->count, 1 ) == 0 ) {\n      barrp->count  = barrp->count_init;\n      pip_memory_barrier();\n      barrp->gsense = lsense;\n    } else {\n      while( barrp->gsense != lsense ) pip_pause();\n    }\n  }\n  return 0;\n}\n\nint pip_barrier_fin( pip_barrier_t *barrp ) {\n  if( !pip_is_initialized() ) return EPERM;\n  if( barrp->count != 0     ) return EBUSY;\n  return 0;\n}\n\nint pip_yield( int flag ) {\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  if( pip_root != NULL && pip_is_threaded_() ) {\n    int pthread_yield( void );\n    (void) pthread_yield();\n  } else {\n    sched_yield();\n  }\n  return 0;\n}\n\nint pip_set_aux( void *aux ) {\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  pip_task->aux = aux;\n  RETURN( 0 );\n}\n\nint pip_get_aux( void **auxp ) {\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  if( auxp != NULL ) {\n    *auxp = pip_task->aux;\n  }\n  RETURN( 0 );\n}\n\n/* energy-saving spin-lock */\nvoid pip_glibc_lock( void ) {\n  if( pip_root != NULL ) pip_sem_wait( &pip_root->lock_glibc );\n}\n\nvoid pip_glibc_unlock( void ) {\n  if( pip_root != NULL ) pip_sem_post( &pip_root->lock_glibc );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/include/pip/pip_dlfcn.h": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 2.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#ifndef _pip_dlfcn_h_\n#define _pip_dlfcn_h_\n\n#ifndef DOXYGEN_INPROGRESS\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  /* locked dl* functions */\n  void *pip_dlopen( const char *filename, int flag );\n  void *pip_dlmopen( long lmid, const char *path, int flag );\n  int   pip_dlinfo( void *handle, int request, void *info );\n  void *pip_dlsym( void *handle, const char *symbol );\n  int   pip_dladdr( void *addr, void *info );\n  int   pip_dlclose( void *handle );\n  char *pip_dlerror( void );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-afe9999ebea0b2bfd8339d6cac7dd4ef6904aaa3.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-afe9999ebea0b2bfd8339d6cac7dd4ef6904aaa3.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/.git/objects/pack/pack-bc61cbce01b5c9e80f8ca9dd1ae3f49bb5718a7b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/.git/objects/pack/pack-bc61cbce01b5c9e80f8ca9dd1ae3f49bb5718a7b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/tutorial/tex/listings.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2mo.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2cl.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/latex-inuse/libpip-manpages.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/man/index.db",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/slides/HPDC18-ROSS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/slides/HPDC18.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/slides/IPDPS-RADR-2020.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-2-xrqusnfi5vt4nblhysazh65i5p56oxlp/spack-src/doc/logo/PiP.pdf"
    ],
    "total_files": 584
}