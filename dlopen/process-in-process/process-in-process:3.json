{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/PiP-Testsuite/PiP-Testsuite/compat/compat-v3.list": "timer 1 pip_blt 1 1 ./ctype\ntimer 1 pip_blt 8 8 ./ctype\ntimer 1 pip_blt 1 1 ./environ\ntimer 1 pip_blt 8 8 ./environ\ntimer 100 pip_blt 1 1 ./malloc\ntimer 400 pip_blt 8 8 ./malloc\ntimer 1 pip_blt 1 1 ./system\ntimer 1 pip_blt 8 8 ./system\ntimer 1 pip_blt 1 1 ./gettimeofday\ntimer 1 pip_blt 8 8 ./gettimeofday\ntimer 1 pip_blt 1 1 ./gethostname\ntimer 1 pip_blt 8 8 ./gethostname\ntimer 1 pip_blt 1 1 ./gethostbyname\ntimer 1 pip_blt 8 8 ./gethostbyname\ntimer 1 pip_blt 1 1 ./const_destruct\ntimer 1 pip_blt 8 8 ./const_destruct\ntimer 1 pip_blt 1 1 ./get_nprocs\ntimer 1 pip_blt 8 8 ./get_nprocs\ntimer 1 pip_blt 1 1 ./fork\ntimer 1 pip_blt 8 8 ./fork\nskip T UNSUPPORTED timer 1 pip_blt 1 1 ./pip_dlopen\nskip T UNSUPPORTED timer 1 pip_blt 8 8 ./pip_dlopen\ntimer  5 pip_blt 1 1 ./getaddrinfo\ntimer 10 pip_blt 8 8 ./getaddrinfo\ntimer 2  pip_blt 1 1 ./malloc-x\ntimer 10 pip_blt 8 8 ./malloc-x\ntimer 2  pip_blt 1 1 ./realloc-x\ntimer 10 pip_blt 8 8 ./realloc-x\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/PiP-Testsuite/PiP-Testsuite/compat/pip_dlopen.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_TESTSUITE: Version 1.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#include <libgen.h>\n#include <limits.h>\n#include <test.h>\n\n#define LIBNAME \t\"./libnull.so\"\n\nvoid *pip_dlopen( const char*, int );\nvoid *pip_dlsym( void*, const char* );\nint   pip_dlclose( void* );\n\nint main( int argc, char **argv ) {\n  void *handle;\n  int(*foo)(void);\n\n  CHECK( pip_init(NULL,NULL,NULL,0), RV, return(EXIT_FAIL) );\n  CHECK( handle = pip_dlopen( LIBNAME, RTLD_LAZY ),\n\t handle==NULL,\n\t return(EXIT_FAIL) );\n  CHECK( ( foo = pip_dlsym( handle, \"foo\" ) ), foo==0, return(EXIT_FAIL) );\n  CHECK( foo(),                                    RV, return(EXIT_FAIL) );\n  //CHECK( pip_dlclose( handle ),                    RV, return(EXIT_FAIL) );\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/PiP-Testsuite/PiP-Testsuite/compat/compat-v2.list": "timer 1 ./pagefault 1\ntimer 1 ./pagefault 8\ntimer 1 pip_task 1 ./fork\ntimer 1 pip_task 8 ./fork\nskip T UNSUPPORTED timer 1 pip_task 1 ./pip_dlopen\nskip T UNSUPPORTED timer 1 pip_task 8 ./pip_dlopen\ntimer  5 pip_task 1 ./getaddrinfo\ntimer 10 pip_task 8 ./getaddrinfo\ntimer 10 pip_task 8 ./malloc-x\ntimer 10 pip_task 8 ./realloc-x\n##timer 1 ./sigchld 1\n##timer 1 ./sigchld 8\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/lib/pip_dlfcn.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n\n/* locked dl* functions */\n\nvoid *pip_dlopen( const char *filename, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlopen( filename, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nvoid *pip_dlmopen( long lmid, const char *path, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlmopen( lmid, path, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nint pip_dlinfo( void *handle, int request, void *info ) {\n  int rv;\n  pip_glibc_lock();\n  rv = dlinfo( handle, request, info );\n  pip_glibc_unlock();\n  return rv;\n}\n\nvoid *pip_dlsym( void *handle, const char *symbol ) {\n  void *addr;\n  pip_glibc_lock();\n  addr = dlsym( handle, symbol );\n  pip_glibc_unlock();\n  return addr;\n}\n\nint pip_dladdr( void *addr, void *info ) {\n  Dl_info *dlinfo = (Dl_info*) info;\n  int rv;\n  pip_glibc_lock();\n  rv = dladdr( addr, dlinfo );\n  pip_glibc_unlock();\n  return rv;\n}\n\nint pip_dlclose( void *handle ) {\n  int rv = 0;\n  pip_glibc_lock();\n  rv = dlclose( handle );\n  pip_glibc_unlock();\n  return rv;\n}\n\nchar *pip_dlerror( void ) {\n  char *dlerr;\n  pip_glibc_lock();\n  dlerr = dlerror();\n  pip_glibc_unlock();\n  return dlerr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/lib/pip.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n//#define DEBUG\n//#define PRINT_MAPS\n//#define PRINT_FDS\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n#include <pip/pip_gdbif_func.h>\n\n#include <limits.h>\t\t/* for PTHREAD_STACK_MIN */\n#define PIP_TRAMPOLINE_STACKSZ\t(PTHREAD_STACK_MIN)\n\nextern char \t\t**environ;\nextern pip_spinlock_t \t*pip_lock_clone;\n\n pip_clone_mostly_pthread_t pip_clone_mostly_pthread_ptr = NULL;\n\n/*** note that the following static variables are   ***/\n/*** located at each PIP task and the root process. ***/\n\nstatic pip_clone_t*\tpip_cloneinfo = NULL;\n\nstatic void pip_set_magic( pip_root_t *root ) {\n  memcpy( root->magic, PIP_MAGIC_WORD, PIP_MAGIC_WLEN );\n}\n\n#define NITERS\t\t(100)\n#define FACTOR_INIT\t(10)\nstatic uint64_t pip_measure_yieldtime( void ) {\n  double dt, xt;\n  uint64_t c;\n  int i;\n\n  for( i=0; i<NITERS/10; i++ ) pip_system_yield();\n  dt = -pip_gettime();\n  for( i=0; i<NITERS; i++ ) pip_system_yield();\n  dt += pip_gettime();\n  DBGF( \"DT:%g\", dt );\n\n  for( i=0; i<NITERS/10; i++ ) pip_pause();\n  xt = 0.0;\n  for( c=FACTOR_INIT; ; c*=2 ) {\n    xt = -pip_gettime();\n    for( i=0; i<NITERS*c; i++ ) pip_pause();\n    xt += pip_gettime();\n    DBGF( \"c:%lu  XT:%g  DT:%g\", c, xt, dt );\n    if( xt > dt ) break;\n  }\n  c *= 10;\n  DBGF( \"yield:%lu\", c );\n  return c;\n}\n\nstatic int pip_check_opt_and_env( uint32_t *optsp ) {\n  extern pip_spinlock_t pip_lock_got_clone;\n  int opts   = *optsp;\n  int mode   = ( opts & PIP_MODE_MASK );\n  int newmod = 0;\n  char *env  = getenv( PIP_ENV_MODE );\n\n  enum PIP_MODE_BITS {\n    PIP_MODE_PTHREAD_BIT          = 1,\n    PIP_MODE_PROCESS_PRELOAD_BIT  = 2,\n    PIP_MODE_PROCESS_GOT_BIT      = 4,\n    PIP_MODE_PROCESS_PIPCLONE_BIT = 8\n  } desired = 0;\n\n  if( ( opts & ~PIP_VALID_OPTS ) != 0 ) {\n    /* unknown option(s) specified */\n    RETURN( EINVAL );\n  }\n  /* check if pip_preload.so is pre-loaded. if so, */\n  /* PIP_MODE_PROCESS_PRELOAD is the only choice   */\n  if( pip_cloneinfo == NULL ) {\n    pip_cloneinfo = (pip_clone_t*) dlsym( RTLD_DEFAULT, \"pip_clone_info\");\n  }\n  DBGF( \"cloneinfo:%p\", pip_cloneinfo );\n  if( pip_cloneinfo != NULL ) {\n    DBGF( \"mode:0x%x\", mode );\n    if( mode == 0 || \n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == mode ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( mode & ~PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload must be specified at pip_init()\" );\n      RETURN( EPERM );\n    }\n    if( env == NULL || env[0] == '\\0' ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ||\n\tstrcasecmp( env, PIP_ENV_MODE_PROCESS         ) == 0 ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    } else {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is the only valid choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  } else {\n    /* pip_preload.so is not loaded. i.e., LD_PRELOAD does not include pip_preload.so */\n    if( mode != 0 &&\n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload might be a wrong choice\" );\n      RETURN( EPERM );\n    }\n    if( env != NULL && strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is a wrong choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  }\n\n  switch( mode ) {\n  case 0:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PTHREAD_BIT     |\n\t        PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_THREAD  ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_MODE_PTHREAD ) == 0 ) {\n      desired = PIP_MODE_PTHREAD_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PTHREAD:\n    desired = PIP_MODE_PTHREAD_BIT;\n    break;\n  case PIP_MODE_PROCESS:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    desired = PIP_MODE_PROCESS_GOT_BIT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    break;\n  default:\n    RETURN( EINVAL );\n  }\n\n  if( desired & PIP_MODE_PROCESS_GOT_BIT ) {\n    int pip_wrap_clone( void );\n    if( pip_wrap_clone() == 0 ) {\n      newmod = PIP_MODE_PROCESS_GOT;\n      pip_lock_clone = &pip_lock_got_clone;\n      goto done;\n    } else if( !( desired & ( PIP_MODE_PTHREAD_BIT |\n\t\t\t      PIP_MODE_PROCESS_PIPCLONE_BIT ) ) ) {\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PROCESS_PIPCLONE_BIT ) {\n    if ( pip_clone_mostly_pthread_ptr == NULL )\n      pip_clone_mostly_pthread_ptr =\n\tdlsym( RTLD_DEFAULT, \"pip_clone_mostly_pthread\" );\n    if ( pip_clone_mostly_pthread_ptr != NULL ) {\n      newmod = PIP_MODE_PROCESS_PIPCLONE;\n      goto done;\n    } else if( !( desired & PIP_MODE_PTHREAD_BIT) ) {\n      pip_err_mesg( \"%s mode is requested but pip_clone_mostly_pthread() \"\n\t\t    \"cannot not be found in (PiP-)glibc\",\n\t\t    PIP_ENV_MODE_PROCESS_PIPCLONE );\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PTHREAD_BIT ) {\n    newmod = PIP_MODE_PTHREAD;\n  }\n\n done:\n  *optsp = ( opts & ~PIP_MODE_MASK ) | newmod;\n  RETURN( 0 );\n}\n\nstatic pip_task_internal_t *pip_get_myself( void ) {\n  pip_task_internal_t *taski;\n  if( pip_isa_root() ) {\n    taski = pip_root->task_root;\n  } else {\n    taski = pip_task;\n  }\n  return taski;\n}\n\n/* internal funcs */\n\nvoid pip_reset_task_struct( pip_task_internal_t *taski ) {\n  pip_task_annex_t \t*annex = AA(taski);\n  pip_task_misc_t \t*misc = annex->misc;\n  void\t\t\t*stack_trampoline = annex->stack_trampoline;\n  void\t\t\t*namexp = annex->named_exptab;\n\n  //memset( (void*) taski, 0, offsetof( pip_task_internal_t, annex ) );\n  PIP_TASKQ_INIT( &TA(taski)->queue  );\n  PIP_TASKQ_INIT( &TA(taski)->schedq );\n  PIP_TASKQ_INIT( &TA(taski)->oodq   );\n  TA(taski)->type  = PIP_TYPE_NULL;\n  TA(taski)->pipid = PIP_PIPID_NULL;\n  pip_spin_init( &TA(taski)->lock_oodq );\n\n  //memset( (void*) annex, 0, sizeof( pip_task_annex_t ) );\n  annex->flag_exit        = 0;\n  annex->stack_trampoline = stack_trampoline;\n  annex->named_exptab     = namexp;\n  annex->tid              = -1; /* pip_gdbif_init_task_struct() refers this */\n  annex->misc             = misc;\n  pip_sem_init( &annex->sleep );\n}\n\nint pip_check_sync_flag( uint32_t *optsp ) {\n  int opts = *optsp;\n  uint32_t f = opts & PIP_SYNC_MASK;\n\n  DBGF( \"flags:0x%x\", f );\n  if( f ) {\n    if( pip_are_flags_exclusive( f, PIP_SYNC_AUTO     ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_BUSYWAIT ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_YIELD    ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_BLOCKING ) ) goto OK;\n    return -1;\n  } else {\n    char *env = getenv( PIP_ENV_SYNC );\n    if( env == NULL ) {\n      f = PIP_SYNC_AUTO;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_AUTO     ) == 0 ) {\n      f = PIP_SYNC_AUTO;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_BUSY     ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_SYNC_BUSYWAIT ) == 0 ) {\n      f = PIP_SYNC_BUSYWAIT;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_YIELD    ) == 0 ) {\n      f = PIP_SYNC_YIELD;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_BLOCK    ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_SYNC_BLOCKING ) == 0 ) {\n      f = PIP_SYNC_BLOCKING;\n    }\n  }\n OK:\n  *optsp = ( opts & ~PIP_SYNC_MASK ) | f;\n  DBGF( \"sync-flag %x | %x => %x\", f, opts, *optsp );\n  return 0;\n}\n\nvoid pip_set_signal_handler( int sig,\n\t\t\t     void(*handler)(),\n\t\t\t     struct sigaction *oldp ) {\n  struct sigaction\tsigact;\n\n  memset( &sigact, 0, sizeof( sigact ) );\n  sigact.sa_sigaction = handler;\n  ASSERTS( sigemptyset( &sigact.sa_mask )    != 0 );\n  ASSERTS( sigaddset( &sigact.sa_mask, sig ) != 0 );\n  ASSERTS( sigaction( sig, &sigact, oldp )   != 0 );\n}\n\nvoid pip_unset_signal_handler( int sig, struct sigaction *oldp ) {\n  ASSERTS( sigaction( sig, oldp, NULL ) != 0 );\n}\n\n/* save PiP environments */\n\nstatic void pip_save_debug_envs( pip_root_t *root ) {\n  char *env;\n\n  if( ( env = getenv( PIP_ENV_STOP_ON_START ) ) != NULL )\n    root->envs.stop_on_start = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_PATH      ) ) != NULL )\n    root->envs.gdb_path      = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_COMMAND   ) ) != NULL )\n    root->envs.gdb_command   = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_SIGNALS   ) ) != NULL )\n    root->envs.gdb_signals   = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_MAPS     ) ) != NULL )\n    root->envs.show_maps     = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_PIPS     ) ) != NULL )\n    root->envs.show_pips    = strdup( env );\n}\n\n/* signal handlers */\n\nstatic void pip_sigchld_handler( int sig, siginfo_t *info, void *extra ) {}\n\nstatic void pip_sigterm_handler( int sig, siginfo_t *info, void *extra ) {\n  ENTER;\n  ASSERTD( TA(pip_task)->pipid != PIP_PIPID_ROOT );\n  (void) pip_kill_all_tasks();\n  (void) kill( getpid(), SIGKILL );\n}\n\nvoid pip_set_sigmask( int sig ) {\n  sigset_t sigmask;\n\n  ASSERTS( sigemptyset( &sigmask ) );\n  ASSERTS( sigaddset(   &sigmask, sig ) );\n  ASSERTS( sigprocmask( SIG_BLOCK, &sigmask, &pip_root->old_sigmask ) );\n}\n\nvoid pip_unset_sigmask( void ) {\n  ASSERTS( sigprocmask( SIG_SETMASK, &pip_root->old_sigmask, NULL ) );\n}\n\n/* API */\n\nint pip_init( int *pipidp, int *ntasksp, void **rt_expp, uint32_t opts ) {\n  pip_root_t\t\t*root;\n  pip_task_internal_t\t*taski;\n  pip_task_misc_t\t*misc;\n  size_t\t\tsz;\n  char\t\t\t*envroot, *envtask;\n  int\t\t\tntasks, pipid;\n  int\t\t\ti, err = 0;\n\n#ifdef DO_MCHECK\n  mcheck( NULL );\n#endif\n\n  if(( envroot = getenv( PIP_ROOT_ENV ) ) == NULL ) {\n    /* root process */\n    if( pip_root != NULL ) RETURN( EBUSY ); /* already initialized */\n    if( ntasksp == NULL ) {\n      ntasks = PIP_NTASKS_MAX;\n    } else {\n      ntasks = *ntasksp;\n    }\n\n    if( ntasks <= 0             ) RETURN( EINVAL );\n    if( ntasks > PIP_NTASKS_MAX ) RETURN( EOVERFLOW );\n\n    if( ( err = pip_check_opt_and_env( &opts ) ) != 0 ) RETURN( err );\n    if( pip_check_sync_flag(   &opts )  < 0 ) RETURN( EINVAL );\n\n#ifndef PIP_CONCAT_STRUCT\n    sz = sizeof(pip_root_t) +\n      sizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n      sizeof(pip_task_annex_t   ) * ( ntasks + 1 ) +\n      sizeof(pip_task_misc_t    ) * ( ntasks + 1 );\n    pip_page_alloc( sz, (void**) &root );\n    (void) memset( root, 0, sz );\n    pip_task_annex_t *annex = (pip_task_annex_t*)\n      ( ((intptr_t)root) +\n\tsizeof(pip_root_t) +\n\tsizeof(pip_task_internal_t) * ( ntasks + 1 ) );\n    misc = (pip_task_misc_t*)\n      ( ((intptr_t)root) +\n\tsizeof(pip_root_t) +\n\tsizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n\tsizeof(pip_task_annex_t)    * ( ntasks + 1 ) );\n    for( i=0; i<ntasks+1; i++ ) {\n      root->tasks[i].annex       = &annex[i];\n      root->tasks[i].annex->misc = &misc[i];\n    }\n#else\n    sz = sizeof(pip_root_t) +\n      sizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n      sizeof(pip_task_misc_t)     * ( ntasks + 1 );\n    pip_page_alloc( sz, (void**) &root );\n    (void) memset( root, 0, sz );\n    pip_task_internal_t\t*tasks = (pip_task_internal_t*)\n      ( ((intptr_t)root) + sizeof(pip_root_t) );\n    misc = (pip_task_misc_t*)\n      ( ((intptr_t)tasks) + sizeof(pip_task_internal_t) * ( ntasks + 1 ) );\n    for( i=0; i<ntasks+1; i++ ) {\n      root->tasks[i].annex.misc = &misc[i];\n    }\n#endif\n    root->size_whole = sz;\n    root->size_root  = sizeof( pip_root_t );\n    root->size_task  = sizeof( pip_task_internal_t );\n    root->size_annex = sizeof( pip_task_annex_t );\n    root->size_misc  = sizeof( pip_task_misc_t );\n\n    DBGF( \"ROOTROOT (%p)\", root );\n\n    pip_spin_init( &root->lock_tasks );\n    pip_spin_init( &root->lock_bt    );\n\n    pip_sem_init( &root->lock_glibc );\n    pip_sem_post( &root->lock_glibc );\n    pip_sem_init( &root->sync_spawn );\n\n    pipid = PIP_PIPID_ROOT;\n    pip_set_magic( root );\n    root->version               = PIP_API_VERSION;\n    root->ntasks                = ntasks;\n    root->ntasks_count          = 1; /* root is also a PiP task */\n    root->cloneinfo             = pip_cloneinfo;\n    root->opts                  = opts;\n    root->yield_iters           = pip_measure_yieldtime();\n    root->stack_size_trampoline = PIP_TRAMPOLINE_STACKSZ;\n    root->task_root             = &root->tasks[ntasks];\n    if( rt_expp != NULL ) {\n      root->export_root = *rt_expp;\n    }\n    for( i=0; i<ntasks+1; i++ ) {\n      pip_named_export_init( &root->tasks[i] );\n      pip_reset_task_struct( &root->tasks[i] );\n    }\n\n    taski = root->task_root;\n    TA(taski)->type       = PIP_TYPE_ROOT;\n    TA(taski)->pipid      = pipid;\n    TA(taski)->task_sched = taski;\n    SETCURR( taski, taski );\n    PIP_RUN( taski );\n\n    AA(taski)->task_root = root;\n    AA(taski)->tid       = pip_gettid();\n    MA(taski)->loaded = dlopen( NULL, RTLD_NOW );\n    MA(taski)->thread = pthread_self();\n\n#ifdef PIP_SAVE_TLS\n    pip_save_tls( &TA(taski)->tls );\n#endif\n    pip_page_alloc( root->stack_size_trampoline,\n\t\t    &AA(taski)->stack_trampoline );\n    if( AA(taski)->stack_trampoline == NULL ) {\n      free( root );\n      RETURN( err );\n    }\n    pip_root = root;\n    pip_task = taski;\n\n    pip_set_name( taski );\n\n    pip_set_sigmask( SIGCHLD );\n    pip_set_signal_handler( SIGCHLD,\n\t\t\t    pip_sigchld_handler,\n\t\t\t    &root->old_sigchld );\n    pip_set_signal_handler( SIGTERM,\n\t\t\t    pip_sigterm_handler,\n\t\t\t    &root->old_sigterm );\n\n    pip_save_debug_envs( root );\n\n    pip_gdbif_initialize_root( ntasks );\n    pip_gdbif_task_commit( taski );\n    pip_debug_on_exceptions( taski );\n\n    DBGF( \"PiP Execution Mode: %s\", pip_get_mode_str() );\n\n  } else if( ( envtask = getenv( PIP_TASK_ENV ) ) != NULL ) {\n    /* child task */\n    int\trv;\n\n    root  = (pip_root_t*) strtoll( envroot, NULL, 16 );\n    pipid = (int) strtol( envtask, NULL, 10 );\n    ASSERTS( pipid < 0 || pipid > root->ntasks );\n    taski = &pip_root->tasks[pipid];\n    if( ( rv = pip_init_task_implicitly( root, taski ) ) == 0 ) {\n      ntasks = root->ntasks;\n      /* succeeded */\n      if( ntasksp != NULL ) *ntasksp = ntasks;\n      if( rt_expp != NULL ) {\n\t*rt_expp = AA(taski)->import_root;\n      }\n      unsetenv( PIP_ROOT_ENV );\n      unsetenv( PIP_TASK_ENV );\n    } else {\n      switch( rv ) {\n      case 1:\n\tpip_err_mesg( \"Invalid PiP root\" );\n\tbreak;\n      case 2:\n\tpip_err_mesg( \"Magic number error\" );\n\tbreak;\n      case 3:\n\tpip_err_mesg( \"Version miss-match between PiP root and task\" );\n\tbreak;\n      case 4:\n\tpip_err_mesg( \"Size miss-match between PiP root and task\" );\n\tbreak;\n      default:\n\tpip_err_mesg( \"Something wrong with PiP root and task\" );\n\tbreak;\n      }\n      RETURN( EINVAL );\n    }\n  } else {\n    RETURN( EPERM );\n  }\n  DBGF( \"pip_root=%p  pip_task=%p\", pip_root, pip_task );\n  /* root and child */\n  if( pipidp != NULL ) *pipidp = pipid;\n  RETURN( err );\n}\n\nint pip_fin( void ) {\n  int ntasks, i;\n\n  ENTER;\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  if( pip_isa_root() ) {\t\t/* root */\n    ntasks = pip_root->ntasks;\n    for( i=0; i<ntasks; i++ ) {\n      pip_task_internal_t *taski = &pip_root->tasks[i];\n      if( TA(taski)->type != PIP_TYPE_NULL ) {\n\tDBGF( \"%d/%d [pipid=%d (type=0x%x)] -- BUSY\",\n\t      i, ntasks, TA(taski)->pipid, TA(taski)->type );\n\tRETURN( EBUSY );\n      }\n    }\n    pip_named_export_fin_all();\n    /* report accumulated timer values, if set */\n    PIP_REPORT( time_load_dso  );\n    PIP_REPORT( time_load_prog );\n    PIP_REPORT( time_dlmopen   );\n\n    pip_sem_fin( &pip_root->lock_glibc );\n    pip_sem_fin( &pip_root->sync_spawn );\n    /* SIGCHLD */\n    pip_unset_sigmask();\n    pip_unset_signal_handler( SIGCHLD,\n\t\t\t      &pip_root->old_sigchld );\n    /* SIGTERM */\n    pip_unset_signal_handler( SIGTERM,\n\t\t\t      &pip_root->old_sigterm );\n\n    if( pip_root->envs.stop_on_start != NULL )\n      free( pip_root->envs.stop_on_start );\n    if( pip_root->envs.gdb_path      != NULL )\n      free( pip_root->envs.gdb_path      );\n    if( pip_root->envs.gdb_command   != NULL )\n      free( pip_root->envs.gdb_command   );\n    if( pip_root->envs.gdb_signals   != NULL )\n      free( pip_root->envs.gdb_signals   );\n    if( pip_root->envs.show_maps     != NULL )\n      free( pip_root->envs.show_maps     );\n    if( pip_root->envs.show_pips     != NULL )\n      free( pip_root->envs.show_pips     );\n\n    memset( pip_root, 0, pip_root->size_whole );\n    /* after this point DBG(F) macros cannot be used */\n    free( pip_root );\n    pip_root = NULL;\n    pip_task = NULL;\n\n    pip_undo_patch_GOT();\n  }\n  RETURN( 0 );\n}\n\nint pip_export( void *exp ) {\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  AA(pip_get_myself())->exp = exp;\n  RETURN( 0 );\n}\n\nint pip_import( int pipid, void **expp  ) {\n  pip_task_internal_t *taski;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  taski = pip_get_task( pipid );\n  if( expp != NULL ) *expp = (void*) AA(taski)->exp;\n  RETURN( 0 );\n}\n\nint pip_isa_task( void ) {\n  return\n    pip_is_initialized() &&\n    PIP_ISA_TASK( pip_task ) && /* root is also a task */\n    !PIP_ISA_ROOT( pip_task );\n}\n\nint pip_get_pipid( int *pipidp ) {\n  int pipid;\n  pipid = pip_get_pipid_();\n  if( pipid == PIP_PIPID_NULL ) RETURN( EPERM );\n  if( pipidp != NULL ) *pipidp = pipid;\n  RETURN( 0 );\n}\n\nint pip_get_ntasks( int *ntasksp ) {\n  if( pip_root == NULL ) return( EPERM  ); /* intentionally small return */\n  if( ntasksp != NULL ) {\n    *ntasksp = pip_root->ntasks;\n  }\n  RETURN( 0 );\n}\n\nint pip_get_mode( int *modep ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( modep != NULL ) {\n    *modep = ( pip_root->opts & PIP_MODE_MASK );\n  }\n  RETURN( 0 );\n}\n\nconst char *pip_get_mode_str( void ) {\n  char *mode;\n\n  if( pip_root == NULL ) return NULL;\n  switch( pip_root->opts & PIP_MODE_MASK ) {\n  case PIP_MODE_PTHREAD:\n    mode = PIP_ENV_MODE_PTHREAD;\n    break;\n  case PIP_MODE_PROCESS:\n    mode = PIP_ENV_MODE_PROCESS;\n    break;\n  case PIP_MODE_PROCESS_PRELOAD:\n    mode = PIP_ENV_MODE_PROCESS_PRELOAD;\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    mode = PIP_ENV_MODE_PROCESS_GOT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    mode = PIP_ENV_MODE_PROCESS_PIPCLONE;\n    break;\n  default:\n    mode = \"(unknown)\";\n  }\n  return mode;\n}\n\nint pip_is_threaded( int *flagp ) {\n  if( pip_is_threaded_() ) {\n    *flagp = 1;\n  } else {\n    *flagp = 0;\n  }\n  return 0;\n}\n\nint pip_is_shared_fd_( void ) {\n  return pip_is_threaded_();\n}\n\nint pip_is_shared_fd( int *flagp ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( pip_is_shared_fd_() ) {\n    if( flagp != NULL ) *flagp = 1;\n  } else {\n    if( flagp != NULL ) *flagp = 0;\n  }\n  return 0;\n}\n\nint pip_kill_all_tasks( void ) {\n  int pipid, i, err = 0;\n\n  if( !pip_is_initialized() ) {\n    err = EPERM;\n  } else if( !pip_isa_root() ) {\n    err = EPERM;\n  } else {\n    for( i=0; i<pip_root->ntasks; i++ ) {\n      pipid = i;\n      if( pip_check_pipid( &pipid ) == 0 ) {\n\tif( pip_is_threaded_() ) {\n\t  pip_task_internal_t *taski = &pip_root->tasks[pipid];\n\t  AA(taski)->status = PIP_W_EXITCODE( 0, SIGTERM );\n\t    (void) pip_kill( pipid, SIGQUIT );\n\t} else {\n\t  (void) pip_kill( pipid, SIGKILL );\n\t}\n      }\n    }\n  }\n  return err;\n}\n\nint pip_get_system_id( int pipid, pip_id_t *idp ) {\n  pip_task_internal_t *taski;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  if( idp != NULL ) {\n    taski = pip_get_task( pipid );\n    /* Do not call gettid() nor pthread_self() for tbis                */\n    /* if a task is a BLT then gettid() returns the scheduling task ID */\n    if( pip_is_threaded_() ) {\n      *idp = (intptr_t) AA(TA(taski)->task_sched)->misc->thread;\n    } else {\n      *idp = (intptr_t) AA(taski)->tid;\n    }\n  }\n  RETURN( 0 );\n}\n\n/* energy-saving spin-lock */\nvoid pip_glibc_lock( void ) __attribute__ ((unused));\n/* actually this is being used */\nvoid pip_glibc_lock( void ) {\n  if( pip_root != NULL ) pip_sem_wait( &pip_root->lock_glibc );\n}\n\nvoid pip_glibc_unlock( void ) __attribute__ ((unused));\n/* actually this is being used */\nvoid pip_glibc_unlock( void ) {\n  if( pip_root != NULL ) pip_sem_post( &pip_root->lock_glibc );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/include/pip/pip_dlfcn.h": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#ifndef _pip_dlfcn_h_\n#define _pip_dlfcn_h_\n\n#ifndef DOXYGEN_INPROGRESS\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  /* locked dl* functions */\n  void *pip_dlopen( const char *filename, int flag );\n  void *pip_dlmopen( long lmid, const char *path, int flag );\n  int   pip_dlinfo( void *handle, int request, void *info );\n  void *pip_dlsym( void *handle, const char *symbol );\n  int   pip_dladdr( void *addr, void *info );\n  int   pip_dlclose( void *handle );\n  char *pip_dlerror( void );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-afe9999ebea0b2bfd8339d6cac7dd4ef6904aaa3.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-afe9999ebea0b2bfd8339d6cac7dd4ef6904aaa3.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/.git/objects/pack/pack-8dec91f7778b571fc0eec22d07ba193d81eac7c8.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/.git/objects/pack/pack-8dec91f7778b571fc0eec22d07ba193d81eac7c8.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/tutorial/tex/listings.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2mo.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2cl.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/latex-inuse/libpip-manpages.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/man/index.db",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/slides/HPDC18-ROSS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/slides/HPDC18.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/slides/IPDPS-RADR-2020.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-rdqt7xi6vsfsedscoinjyfhe7c2hmuzz/spack-src/doc/logo/PiP.pdf"
    ],
    "total_files": 728
}