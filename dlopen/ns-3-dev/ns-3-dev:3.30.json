{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/model/nsc-tcp-l4-protocol.cc": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * based on earlier integration work by Tom Henderson and Sam Jansen.\n * 2008 Florian Westphal <fw@strlen.de>\n */\n\n#include \"ns3/assert.h\"\n#include \"ns3/log.h\"\n#include \"ns3/nstime.h\"\n\n#include \"ns3/packet.h\"\n#include \"ns3/node.h\"\n#include \"ns3/ipv4-route.h\"\n\n#include \"ns3/object-vector.h\"\n#include \"ns3/string.h\"\n#include \"tcp-header.h\"\n#include \"ipv4-end-point-demux.h\"\n#include \"ipv4-end-point.h\"\n#include \"ipv4-l3-protocol.h\"\n#include \"nsc-tcp-l4-protocol.h\"\n#include \"nsc-tcp-socket-impl.h\"\n#include \"nsc-sysctl.h\"\n#include \"nsc-tcp-socket-factory-impl.h\"\n#include \"sim_interface.h\"\n\n#include <vector>\n#include <sstream>\n#include <dlfcn.h>\n#include <iomanip>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"NscTcpL4Protocol\");\n\nNS_OBJECT_ENSURE_REGISTERED (NscTcpL4Protocol);\n\n/* see http://www.iana.org/assignments/protocol-numbers */\nconst uint8_t NscTcpL4Protocol::PROT_NUMBER = 6;\n\n/**\n * \\ingroup nsctcp\n * \\brief Nsc interface implementation class.\n */\nclass NscInterfaceImpl : public ISendCallback, public IInterruptCallback \n{\npublic:\n  /**\n   * Constructor\n   * \\param prot the NSC TCP protocol\n   */\n  NscInterfaceImpl (Ptr<NscTcpL4Protocol> prot);\nprivate:\n  /**\n   * \\brief Invoked by NSCs 'ethernet driver' to re-inject a packet into ns-3.\n   *\n   * A packet is an octet soup consisting of an IP Header, TCP Header\n   * and user payload, if any\n   *\n   * \\param data the data\n   * \\param datalen the data length\n   */\n  virtual void send_callback (const void *data, int datalen);\n  /**\n   * \\brief Called by the NSC stack whenever something of interest has happened\n   *\n   * Examples: when data arrives on a socket, a listen socket\n   * has a new connection pending, etc.\n   */\n  virtual void wakeup ();\n  /**\n   * \\brief Called by the Linux stack RNG initialization\n   *\n   * Its also used by the cradle code to add a timestamp to\n   * printk/printf/debug output.\n   */\n  virtual void gettime (unsigned int *, unsigned int *);\nprivate:\n  Ptr<NscTcpL4Protocol> m_prot; //!< the NSC TCP protocol\n};\n\nNscInterfaceImpl::NscInterfaceImpl (Ptr<NscTcpL4Protocol> prot)\n  : m_prot (prot)\n{\n}\n\nvoid\nNscInterfaceImpl::send_callback (const void *data, int datalen)\n{\n  m_prot->send_callback (data, datalen);\n}\nvoid\nNscInterfaceImpl::wakeup ()\n{\n  m_prot->wakeup ();\n}\nvoid\nNscInterfaceImpl::gettime (unsigned int *sec, unsigned int *usec)\n{\n  m_prot->gettime (sec,usec);\n}\n\n\n#undef NS_LOG_APPEND_CONTEXT\n#define NS_LOG_APPEND_CONTEXT                                   \\\n  if (m_node) { std::clog << Simulator::Now ().GetSeconds () << \" [node \" << m_node->GetId () << \"] \"; } \n\nTypeId \nNscTcpL4Protocol::GetTypeId (void)\n{\n  static TypeId tid = TypeId (\"ns3::NscTcpL4Protocol\")\n    .SetParent<IpL4Protocol> ()\n    .SetGroupName (\"Internet\")\n    .AddConstructor<NscTcpL4Protocol>()\n    .AddAttribute (\"SocketList\", \"The list of sockets associated to this protocol.\",\n                   ObjectVectorValue (),\n                   MakeObjectVectorAccessor (&NscTcpL4Protocol::m_sockets),\n                   MakeObjectVectorChecker<NscTcpSocketImpl> ())\n    .AddAttribute (\"Library\",\n                   \"Set the linux library to be used to create the stack\",\n                   TypeId::ATTR_GET|TypeId::ATTR_CONSTRUCT,\n                   StringValue (\"liblinux2.6.26.so\"),\n                   MakeStringAccessor (&NscTcpL4Protocol::GetNscLibrary,&NscTcpL4Protocol::SetNscLibrary),\n                   MakeStringChecker ())\n  ;\n  return tid;\n}\n\n/**\n * \\brief External Random number generator\n *\n * \\todo make it random...\n *\n * \\returns a random number\n */\nint external_rand ()\n{\n  return 1;\n}\n\nNscTcpL4Protocol::NscTcpL4Protocol ()\n  : m_endPoints (new Ipv4EndPointDemux ()),\n    m_nscStack (0),\n    m_nscInterface (new NscInterfaceImpl (this)),\n    m_softTimer (Timer::CANCEL_ON_DESTROY)\n{\n  m_dlopenHandle = NULL;\n  NS_LOG_LOGIC (\"Made a NscTcpL4Protocol \"<<this);\n}\n\nNscTcpL4Protocol::~NscTcpL4Protocol ()\n{\n  NS_LOG_FUNCTION (this);\n  dlclose (m_dlopenHandle);\n}\n\nvoid\nNscTcpL4Protocol::SetNscLibrary (const std::string &soname)\n{\n  if (soname!=\"\")\n    {\n      m_nscLibrary = soname;\n      NS_ASSERT (!m_dlopenHandle);\n      m_dlopenHandle = dlopen (soname.c_str (), RTLD_NOW);\n      if (m_dlopenHandle == NULL)\n        NS_FATAL_ERROR (dlerror ());\n    }\n}\n\nstd::string \nNscTcpL4Protocol::GetNscLibrary () const\n{\n  return m_nscLibrary;\n}\nvoid \nNscTcpL4Protocol::SetNode (Ptr<Node> node)\n{\n  m_node = node;\n\n  if (m_nscStack)\n    { // stack has already been loaded...\n      return;\n    }\n\n  NS_ASSERT (m_dlopenHandle);\n\n  FCreateStack create = (FCreateStack)dlsym (m_dlopenHandle, \"nsc_create_stack\");\n  NS_ASSERT (create);\n  m_nscStack = create (m_nscInterface, m_nscInterface, external_rand);\n  int hzval = m_nscStack->get_hz ();\n\n  NS_ASSERT (hzval > 0);\n\n  m_softTimer.SetFunction (&NscTcpL4Protocol::SoftInterrupt, this);\n  m_softTimer.SetDelay (MilliSeconds (1000/hzval));\n  m_nscStack->init (hzval);\n  // This enables stack and NSC debug messages\n  // m_nscStack->set_diagnostic(1000);\n\n  Ptr<Ns3NscStack> nscStack = Create<Ns3NscStack> ();\n  nscStack->SetStack (m_nscStack);\n  node->AggregateObject (nscStack);\n\n  m_softTimer.Schedule ();\n\n  // its likely no ns-3 interface exits at this point, so\n  // we dealy adding the nsc interface until the start of the simulation.\n  Simulator::ScheduleNow (&NscTcpL4Protocol::AddInterface, this);\n}\n\nvoid\nNscTcpL4Protocol::NotifyNewAggregate ()\n{ \n  if (m_node == 0)\n    {\n      Ptr<Node>node = this->GetObject<Node> ();\n      if (node != 0)\n        {\n          Ptr<Ipv4L3Protocol> ipv4 = this->GetObject<Ipv4L3Protocol> ();\n          if (ipv4 != 0 && m_downTarget.IsNull ())\n            {\n              this->SetNode (node);\n              ipv4->Insert (this);\n              Ptr<NscTcpSocketFactoryImpl> tcpFactory = CreateObject<NscTcpSocketFactoryImpl> ();\n              tcpFactory->SetTcp (this);\n              node->AggregateObject (tcpFactory);\n              this->SetDownTarget (MakeCallback (&Ipv4L3Protocol::Send, ipv4));\n            }\n        }\n    }\n  IpL4Protocol::NotifyNewAggregate ();\n}\n\nint \nNscTcpL4Protocol::GetProtocolNumber (void) const\n{\n  return PROT_NUMBER;\n}\nint \nNscTcpL4Protocol::GetVersion (void) const\n{\n  return 2;\n}\n\nvoid\nNscTcpL4Protocol::DoDispose (void)\n{\n  NS_LOG_FUNCTION (this);\n\n  for (std::vector<Ptr<NscTcpSocketImpl> >::iterator i = m_sockets.begin (); i != m_sockets.end (); i++)\n    {\n      *i = 0;\n    }\n  m_sockets.clear ();\n\n\n  if (m_endPoints != 0)\n    {\n      delete m_endPoints;\n      m_endPoints = 0;\n    }\n  m_node = 0;\n  delete m_nscInterface;\n  m_nscInterface = 0;\n  m_downTarget.Nullify ();\n  IpL4Protocol::DoDispose ();\n}\n\nPtr<Socket>\nNscTcpL4Protocol::CreateSocket (void)\n{\n  NS_LOG_FUNCTION (this);\n\n  Ptr<NscTcpSocketImpl> socket = CreateObject<NscTcpSocketImpl> ();\n  socket->SetNode (m_node);\n  socket->SetTcp (this);\n  m_sockets.push_back (socket);\n  return socket;\n}\n\nIpv4EndPoint *\nNscTcpL4Protocol::Allocate (void)\n{\n  NS_LOG_FUNCTION (this);\n  return m_endPoints->Allocate ();\n}\n\nIpv4EndPoint *\nNscTcpL4Protocol::Allocate (Ipv4Address address)\n{\n  NS_LOG_FUNCTION (this << address);\n  return m_endPoints->Allocate (address);\n}\n\nIpv4EndPoint *\nNscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)\n{\n  NS_LOG_FUNCTION (this << boundNetDevice << port);\n  return m_endPoints->Allocate (boundNetDevice, port);\n}\n\nIpv4EndPoint *\nNscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port)\n{\n  NS_LOG_FUNCTION (this << boundNetDevice << address << port);\n  return m_endPoints->Allocate (boundNetDevice, address, port);\n}\n\nIpv4EndPoint *\nNscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, \n                            Ipv4Address localAddress, uint16_t localPort,\n                            Ipv4Address peerAddress, uint16_t peerPort)\n{\n  NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);\n  return m_endPoints->Allocate (boundNetDevice,\n                                localAddress, localPort,\n                                peerAddress, peerPort);\n}\n\nvoid \nNscTcpL4Protocol::DeAllocate (Ipv4EndPoint *endPoint)\n{\n  NS_LOG_FUNCTION (this << endPoint);\n  // NSC m_endPoints->DeAllocate (endPoint);\n}\n\nIpL4Protocol::RxStatus\nNscTcpL4Protocol::Receive (Ptr<Packet> packet,\n                           Ipv4Header const &header,\n                           Ptr<Ipv4Interface> incomingInterface)\n{\n  NS_LOG_FUNCTION (this << packet << header << incomingInterface);\n  Ipv4Header ipHeader;\n  uint32_t packetSize = packet->GetSize ();\n\n  // The way things work at the moment, the IP header has been removed\n  // by the ns-3 IPv4 processing code. However, the NSC stack expects\n  // a complete IP packet, so we add the IP header back.\n  // Since the original header is already gone, we create a new one\n  // based on the information we have.\n  ipHeader.SetSource (header.GetSource ());\n  ipHeader.SetDestination (header.GetDestination ());\n  ipHeader.SetProtocol (PROT_NUMBER);\n  ipHeader.SetPayloadSize (packetSize);\n  ipHeader.SetTtl (1);\n  // all NSC stacks check the IP checksum\n  ipHeader.EnableChecksum ();\n\n  packet->AddHeader (ipHeader);\n  packetSize = packet->GetSize ();\n\n  uint8_t *buf = new uint8_t[packetSize];\n  packet->CopyData (buf, packetSize);\n  const uint8_t *data = const_cast<uint8_t *>(buf);\n\n  // deliver complete packet to the NSC network stack\n  m_nscStack->if_receive_packet (0, data, packetSize);\n  delete[] buf;\n\n  wakeup ();\n  return IpL4Protocol::RX_OK;\n}\n\nIpL4Protocol::RxStatus\nNscTcpL4Protocol::Receive(Ptr<Packet>, Ipv6Header const &, Ptr<Ipv6Interface>)\n{\n  return IpL4Protocol::RX_ENDPOINT_UNREACH;\n}\n\nvoid NscTcpL4Protocol::SoftInterrupt (void)\n{\n  m_nscStack->timer_interrupt ();\n  m_nscStack->increment_ticks ();\n  m_softTimer.Schedule ();\n}\n\nvoid NscTcpL4Protocol::send_callback (const void* data, int datalen)\n{\n  Ptr<Packet> p;\n  uint32_t ipv4Saddr, ipv4Daddr;\n\n  NS_ASSERT (datalen > 20);\n\n\n  // create packet, without IP header. The TCP header is not touched.\n  // Not using the IP header makes integration easier, but it destroys\n  // eg. ECN.\n  const uint8_t *rawdata = reinterpret_cast<const uint8_t *>(data);\n  rawdata += 20; // skip IP header. IP options aren't supported at this time.\n  datalen -= 20;\n  p = Create<Packet> (rawdata, datalen);\n\n  // we need the real source/destination ipv4 addresses for Send ().\n  const uint32_t *ipheader = reinterpret_cast<const uint32_t *>(data);\n  ipv4Saddr = *(ipheader+3);\n  ipv4Daddr = *(ipheader+4);\n\n  Ipv4Address saddr (ntohl (ipv4Saddr));\n  Ipv4Address daddr (ntohl (ipv4Daddr));\n\n  Ptr<Ipv4L3Protocol> ipv4 = m_node->GetObject<Ipv4L3Protocol> ();\n  NS_ASSERT_MSG (ipv4, \"nsc callback invoked, but node has no ipv4 object\");\n\n  m_downTarget (p, saddr, daddr, PROT_NUMBER, 0);\n  m_nscStack->if_send_finish (0);\n}\n\nvoid NscTcpL4Protocol::wakeup ()\n{\n  // \\todo\n  // this should schedule a timer to read from all tcp sockets now... this is\n  // an indication that data might be waiting on the socket\n\n  Ipv4EndPointDemux::EndPoints endPoints = m_endPoints->GetAllEndPoints ();\n  for (Ipv4EndPointDemux::EndPointsI endPoint = endPoints.begin ();\n       endPoint != endPoints.end (); endPoint++) {\n      // NSC HACK: (ab)use TcpSocket::ForwardUp for signalling\n      (*endPoint)->ForwardUp (NULL, Ipv4Header (), 0, 0);\n    }\n}\n\nvoid NscTcpL4Protocol::gettime (unsigned int* sec, unsigned int* usec)\n{\n  // Only used by the Linux network stack, e.g. during ISN generation\n  // and in the kernel rng initialization routine. Also used in Linux\n  // printk output.\n  Time t = Simulator::Now ();\n  int64_t us = t.GetMicroSeconds ();\n  *sec = us / (1000*1000);\n  *usec = us - *sec * (1000*1000);\n}\n\n\nvoid NscTcpL4Protocol::AddInterface (void)\n{\n  Ptr<Ipv4> ip = m_node->GetObject<Ipv4> ();\n  const uint32_t nInterfaces = ip->GetNInterfaces ();\n\n  NS_ASSERT_MSG (nInterfaces <= 2, \"nsc does not support multiple interfaces per node\");\n\n  // start from 1, ignore the loopback interface (HACK)\n  // we really don't need the loop, but its here to illustrate\n  // how things _should_ be (once nsc can deal with multiple interfaces...)\n  for (uint32_t i = 1; i < nInterfaces; i++)\n    {\n      Ipv4InterfaceAddress ifAddr = ip->GetAddress (i, 0);\n      Ipv4Address addr = ifAddr.GetLocal ();\n      Ipv4Mask mask = ifAddr.GetMask ();\n      uint16_t mtu = ip->GetMtu (i);\n\n      std::ostringstream addrOss, maskOss;\n\n      addr.Print (addrOss);\n      mask.Print (maskOss);\n\n      NS_LOG_LOGIC (\"if_attach \" << addrOss.str ().c_str () << \" \" << maskOss.str ().c_str () << \" \" << mtu);\n\n      std::string addrStr = addrOss.str ();\n      std::string maskStr = maskOss.str ();\n      const char* addrCStr = addrStr.c_str ();\n      const char* maskCStr = maskStr.c_str ();\n      m_nscStack->if_attach (addrCStr, maskCStr, mtu);\n\n      if (i == 1)\n        {\n          // The NSC stack requires a default gateway and only supports\n          // single-interface nodes.  The below is a hack, but\n          // it turns out that we can pass the interface address to nsc as\n          // a default gateway.  Bug 1398 has been opened to track this\n          // issue (NSC's limitation to single-interface nodes)\n          //\n          // Previous versions of this code tried to assign the \"next\"\n          // IP address of the subnet but this was found to fail for\n          // some use cases in /30 subnets.\n\n          // \\todo \\bugid{1398} NSC's limitation to single-interface nodes\n          m_nscStack->add_default_gateway (addrOss.str ().c_str ());\n        }\n    }\n}\n\nvoid\nNscTcpL4Protocol::SetDownTarget (IpL4Protocol::DownTargetCallback callback)\n{\n  m_downTarget = callback;\n}\n\nvoid\nNscTcpL4Protocol::SetDownTarget6 (IpL4Protocol::DownTargetCallback6 callback)\n{\n}\n\nIpL4Protocol::DownTargetCallback\nNscTcpL4Protocol::GetDownTarget (void) const\n{\n  return m_downTarget;\n}\n\nIpL4Protocol::DownTargetCallback6\nNscTcpL4Protocol::GetDownTarget6 (void) const\n{\n  return (IpL4Protocol::DownTargetCallback6)0;\n}\n\n} // namespace ns3\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/model/nsc-tcp-l4-protocol.h": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef NSC_TCP_L4_PROTOCOL_H\n#define NSC_TCP_L4_PROTOCOL_H\n\n#include <stdint.h>\n\n#include \"ns3/packet.h\"\n#include \"ns3/ipv4-address.h\"\n#include \"ns3/ptr.h\"\n#include \"ns3/object-factory.h\"\n#include \"ns3/timer.h\"\n#include \"ip-l4-protocol.h\"\n\nstruct INetStack;\n\nnamespace ns3 {\n\nclass Node;\nclass Socket;\nclass Ipv4EndPointDemux;\nclass Ipv4Interface;\nclass NscTcpSocketImpl;\nclass Ipv4EndPoint;\nclass NscInterfaceImpl;\nclass NetDevice;\n\n/**\n * \\ingroup nsctcp\n * \n * \\brief Nsc wrapper glue, to interface with the Ipv4 protocol underneath.\n */\nclass NscTcpL4Protocol : public IpL4Protocol {\npublic:\n  static const uint8_t PROT_NUMBER; //!< protocol number (0x6)\n  /**\n   * \\brief Get the type ID.\n   * \\return the object TypeId\n   */\n  static TypeId GetTypeId (void);\n\n  NscTcpL4Protocol ();\n  virtual ~NscTcpL4Protocol ();\n\n  /**\n   * Set node associated with this stack\n   * \\param node the node\n   */\n  void SetNode (Ptr<Node> node);\n\n  /**\n   * Set the NSC library to be used\n   * \\param lib the library path\n   */\n  void SetNscLibrary (const std::string &lib);\n\n  /**\n   * Get the NSC library being used\n   * \\returns the library path\n   */\n  std::string GetNscLibrary (void) const;\n  virtual int GetProtocolNumber (void) const;\n\n  /**\n   * Get the NSC version\n   * \\returns the NSC version\n   */\n  virtual int GetVersion (void) const;\n\n  /**\n   * \\return A smart Socket pointer to a NscTcpSocketImpl, allocated by this instance\n   * of the TCP protocol\n   */\n  Ptr<Socket> CreateSocket (void);\n\n  /**\n   * \\brief Allocate an IPv4 Endpoint\n   * \\return the Endpoint\n   */\n  Ipv4EndPoint *Allocate (void);\n  /**\n   * \\brief Allocate an IPv4 Endpoint\n   * \\param address address to use\n   * \\return the Endpoint\n   */\n  Ipv4EndPoint *Allocate (Ipv4Address address);\n  /**\n   * \\brief Allocate an IPv4 Endpoint\n   * \\param boundNetDevice Bound NetDevice (if any)\n   * \\param port port to use\n   * \\return the Endpoint\n   */\n  Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);\n  /**\n   * \\brief Allocate an IPv4 Endpoint\n   * \\param boundNetDevice Bound NetDevice (if any)\n   * \\param address address to use\n   * \\param port port to use\n   * \\return the Endpoint\n   */\n  Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port);\n  /**\n   * \\brief Allocate an IPv4 Endpoint\n   * \\param boundNetDevice Bound NetDevice (if any)\n   * \\param localAddress local address to use\n   * \\param localPort local port to use\n   * \\param peerAddress remote address to use\n   * \\param peerPort remote port to use\n   * \\return the Endpoint\n   */\n  Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice,\n                          Ipv4Address localAddress, uint16_t localPort,\n                          Ipv4Address peerAddress, uint16_t peerPort);\n\n\n  /**\n   * \\brief Remove an IPv4 Endpoint.\n   * \\param endPoint the end point to remove\n   */\n  void DeAllocate (Ipv4EndPoint *endPoint);\n\n  virtual IpL4Protocol::RxStatus Receive (Ptr<Packet> p,\n                                          Ipv4Header const &header,\n                                          Ptr<Ipv4Interface> incomingInterface);\n  virtual IpL4Protocol::RxStatus Receive (Ptr<Packet> p,\n                                          Ipv6Header const &header,\n                                          Ptr<Ipv6Interface> interface);\n\n  // From IpL4Protocol\n  virtual void SetDownTarget (IpL4Protocol::DownTargetCallback cb);\n  virtual void SetDownTarget6 (IpL4Protocol::DownTargetCallback6 cb);\n  // From IpL4Protocol\n  virtual IpL4Protocol::DownTargetCallback GetDownTarget (void) const;\n  virtual IpL4Protocol::DownTargetCallback6 GetDownTarget6 (void) const;\nprotected:\n  virtual void DoDispose (void);\n  virtual void NotifyNewAggregate ();\nprivate:\n  /**\n   * \\brief Copy constructor\n   *\n   * Defined and not implemented to avoid misuse\n   */\n  NscTcpL4Protocol (NscTcpL4Protocol const &);\n  /**\n   * \\brief Copy constructor\n   *\n   * Defined and not implemented to avoid misuse\n   * \\returns\n   */\n  NscTcpL4Protocol& operator= (NscTcpL4Protocol const &);\n\n  // NSC callbacks.\n  // NSC invokes these hooks to interact with the simulator.\n  // In any case, these methods are only to be called by NSC.\n\n  /**\n   * \\brief Invoked by NSCs 'ethernet driver' to re-inject a packet into ns-3.\n   *\n   * A packet is an octet soup consisting of an IP Header, TCP Header\n   * and user payload, if any\n   *\n   * \\param data the data\n   * \\param datalen the data length\n   */\n  void send_callback (const void *data, int datalen);\n  /**\n   * \\brief Called by the NSC stack whenever something of interest has happened\n   *\n   * Examples: when data arrives on a socket, a listen socket\n   * has a new connection pending, etc.\n   */\n  void wakeup ();\n  /**\n   * \\brief Called by the Linux stack RNG initialization\n   *\n   * Its also used by the cradle code to add a timestamp to\n   * printk/printf/debug output.\n   * \\param sec seconds\n   * \\param usec microseconds\n   */\n  void gettime (unsigned int *sec, unsigned int *usec);\n  /**\n   * \\brief Add an interface\n   *\n   * Actually NSC only supports one interface per node (\\bugid{1398})\n   */\n  void AddInterface (void);\n\n  /**\n   * \\brief Provide a \"soft\" interrupt to NSC\n   */\n  void SoftInterrupt (void);\n  /**\n   * \\brief NscInterfaceImpl friend class.\n   * \\relates NscInterfaceImpl\n   */\n  friend class NscInterfaceImpl;\n  /**\n   * \\brief NscTcpSocketImpl friend class.\n   * \\relates NscTcpSocketImpl\n   */\n  friend class NscTcpSocketImpl;\n\n  Ptr<Node> m_node; //!< the node this stack is associated with\n  Ipv4EndPointDemux *m_endPoints; //!< A list of IPv4 end points.\n  INetStack* m_nscStack; //!< the NSC stack.\n  NscInterfaceImpl *m_nscInterface; //!< the NSC Interface.\n  void *m_dlopenHandle; //!< dynamic library handle.\n  std::string m_nscLibrary; //!< path to the NSC library.\n  Timer m_softTimer; //!< Soft interrupt timer\n  std::vector<Ptr<NscTcpSocketImpl> > m_sockets; //!< list of sockets\n  IpL4Protocol::DownTargetCallback m_downTarget; //!< Callback to send packets over IPv4\n};\n\n} // namespace ns3\n\n#endif /* NSC_TCP_L4_PROTOCOL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/tcp.rst": ".. include:: replace.txt\n.. highlight:: cpp\n\nTCP models in ns-3\n------------------\n\nThis chapter describes the TCP models available in |ns3|.\n\nOverview of support for TCP\n***************************\n\n|ns3| was written to support multiple TCP implementations. The implementations\ninherit from a few common header classes in the ``src/network`` directory, so that\nuser code can swap out implementations with minimal changes to the scripts.\n\nThere are two important abstract base classes:\n\n* class :cpp:class:`TcpSocket`:  This is defined in\n  ``src/internet/model/tcp-socket.{cc,h}``. This class exists for hosting TcpSocket\n  attributes that can be reused across different implementations. For instance,\n  the attribute ``InitialCwnd`` can be used for any of the implementations\n  that derive from class :cpp:class:`TcpSocket`.\n* class :cpp:class:`TcpSocketFactory`:  This is used by the layer-4 protocol\n  instance to create TCP sockets of the right type.\n\nThere are presently two active and one legacy implementations of TCP available for |ns3|.\n\n* a natively implemented TCP for ns-3\n* support for kernel implementations via `Direct Code Execution (DCE) <https://www.nsnam.org/overview/projects/direct-code-execution/>`__\n* (legacy) support for kernel implementations for the `Network Simulation Cradle (NSC) <http://www.wand.net.nz/~stj2/nsc/>`__\n\nNSC is no longer actively supported; it requires use of gcc-5 or gcc-4.9, and\nonly covers up to Linux kernel version 2.6.29.\n\nIt should also be mentioned that various ways of combining virtual machines\nwith |ns3| makes available also some additional TCP implementations, but\nthose are out of scope for this chapter.\n\nns-3 TCP\n********\n\nIn brief, the native |ns3| TCP model supports a full bidirectional TCP with\nconnection setup and close logic.  Several congestion control algorithms\nare supported, with NewReno the default, and Westwood, Hybla, HighSpeed,\nVegas, Scalable, Veno, Binary Increase Congestion Control (BIC), Yet Another\nHighSpeed TCP (YeAH), Illinois, H-TCP, Low Extra Delay Background Transport\n(LEDBAT) and TCP Low Priority (TCP-LP) also supported. The model also supports\nSelective Acknowledgements (SACK), Proportional Rate Reduction (PRR) and\nExplicit Congestion Notification (ECN). Multipath-TCP is not yet supported in\nthe |ns3| releases.\n\nModel history\n+++++++++++++\n\nUntil the ns-3.10 release, |ns3| contained a port of the TCP model from `GTNetS\n<http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html>`_, \ndeveloped initially by George Riley and ported to |ns3| by Raj Bhattacharjea. \nThis implementation was substantially rewritten by Adriam Tam for ns-3.10.\nIn 2015, the TCP module was redesigned in order to create a better \nenvironment for creating and carrying out automated tests. One of the main \nchanges involves congestion control algorithms, and how they are implemented.\n\nBefore the ns-3.25 release, a congestion control was considered as a stand-alone TCP\nthrough an inheritance relation: each congestion control (e.g. TcpNewReno) was\na subclass of TcpSocketBase, reimplementing some inherited methods. The\narchitecture was redone to avoid this inheritance,\nthe fundamental principle of the GSoC proposal was avoiding this inheritance,\nby making each congestion control a separate class, and making an interface\nto exchange important data between TcpSocketBase and the congestion modules.\nFor instance, similar modularity is used in Linux.\n\nAlong with congestion control, Fast Retransmit and Fast Recovery algorithms\nhave been modified; in previous releases, these algorithms were demanded to\nTcpSocketBase subclasses. Starting from ns-3.25, they have been merged inside\nTcpSocketBase. In future releases, they can be extracted as separate modules,\nfollowing the congestion control design.\n\nAcknowledgments\n+++++++++++++++\n\nAs mentioned above, |ns3| TCP has had multiple authors and maintainers over\nthe years.  Several publications exist on aspects of |ns3| TCP, and users \nof |ns3| TCP are requested to cite one of the applicable papers when \npublishing new work.\n\nA general reference on the current architecture is found in the following paper:\n\n* Maurizio Casoni, Natale Patriciello, Next-generation TCP for ns-3 simulator, Simulation Modelling Practice and Theory, Volume 66, 2016, Pages 81-93. (http://www.sciencedirect.com/science/article/pii/S1569190X15300939) \n\nFor an academic peer-reviewed paper on the SACK implementation in ns-3,\nplease refer to:\n\n* Natale Patriciello. 2017. A SACK-based Conservative Loss Recovery Algorithm for ns-3 TCP: a Linux-inspired Proposal. In Proceedings of the Workshop on ns-3 (WNS3 '17). ACM, New York, NY, USA, 1-8. (https://dl.acm.org/citation.cfm?id=3067666)\n\nUsage\n+++++\n\nIn many cases, usage of TCP is set at the application layer by telling\nthe |ns3| application which kind of socket factory to use.\n\nUsing the helper functions defined in ``src/applications/helper`` and\n``src/network/helper``, here is how one would create a TCP receiver::\n\n  // Create a packet sink on the star \"hub\" to receive these packets\n  uint16_t port = 50000;\n  Address sinkLocalAddress(InetSocketAddress (Ipv4Address::GetAny (), port));\n  PacketSinkHelper sinkHelper (\"ns3::TcpSocketFactory\", sinkLocalAddress);\n  ApplicationContainer sinkApp = sinkHelper.Install (serverNode);\n  sinkApp.Start (Seconds (1.0));\n  sinkApp.Stop (Seconds (10.0));\n\nSimilarly, the below snippet configures OnOffApplication traffic source to use\nTCP::\n\n  // Create the OnOff applications to send TCP to the server\n  OnOffHelper clientHelper (\"ns3::TcpSocketFactory\", Address ());\n\nThe careful reader will note above that we have specified the TypeId of an\nabstract base class :cpp:class:`TcpSocketFactory`. How does the script tell\n|ns3| that it wants the native |ns3| TCP vs. some other one?  Well, when\ninternet stacks are added to the node, the default TCP implementation that is\naggregated to the node is the |ns3| TCP.  This can be overridden as we show\nbelow when using Network Simulation Cradle. So, by default, when using the |ns3|\nhelper API, the TCP that is aggregated to nodes with an Internet stack is the\nnative |ns3| TCP.\n\nTo configure behavior of TCP, a number of parameters are exported through the\n|ns3| attribute system. These are documented in the `Doxygen\n<http://www.nsnam.org/doxygen/classns3_1_1_tcp_socket.html>` for class\n:cpp:class:`TcpSocket`.  For example, the maximum segment size is a\nsettable attribute.\n\nTo set the default socket type before any internet stack-related objects are\ncreated, one may put the following statement at the top of the simulation\nprogram:: \n\n  Config::SetDefault (\"ns3::TcpL4Protocol::SocketType\", StringValue (\"ns3::TcpNewReno\")); \n\nFor users who wish to have a pointer to the actual socket (so that\nsocket operations like Bind(), setting socket options, etc. can be\ndone on a per-socket basis), Tcp sockets can be created by using the \n``Socket::CreateSocket()`` method.  The TypeId passed to CreateSocket()\nmust be of type :cpp:class:`ns3::SocketFactory`, so configuring the underlying \nsocket type must be done by twiddling the attribute associated with the\nunderlying TcpL4Protocol object.  The easiest way to get at this would be \nthrough the attribute configuration system.  In the below example,\nthe Node container \"n0n1\" is accessed to get the zeroth element, and a socket is\ncreated on this node::\n\n  // Create and bind the socket...\n  TypeId tid = TypeId::LookupByName (\"ns3::TcpNewReno\");\n  Config::Set (\"/NodeList/*/$ns3::TcpL4Protocol/SocketType\", TypeIdValue (tid));\n  Ptr<Socket> localSocket =\n    Socket::CreateSocket (n0n1.Get (0), TcpSocketFactory::GetTypeId ());\n\nAbove, the \"*\" wild card for node number is passed to the attribute\nconfiguration system, so that all future sockets on all nodes are set to \nNewReno, not just on node 'n0n1.Get (0)'.  If one wants to limit it to just \nthe specified node, one would have to do something like::\n\n  // Create and bind the socket...\n  TypeId tid = TypeId::LookupByName (\"ns3::TcpNewReno\");\n  std::stringstream nodeId;\n  nodeId << n0n1.Get (0)->GetId ();\n  std::string specificNode = \"/NodeList/\" + nodeId.str () + \"/$ns3::TcpL4Protocol/SocketType\";\n  Config::Set (specificNode, TypeIdValue (tid));\n  Ptr<Socket> localSocket =\n    Socket::CreateSocket (n0n1.Get (0), TcpSocketFactory::GetTypeId ()); \n\nOnce a TCP socket is created, one will want to follow conventional socket logic\nand either connect() and send() (for a TCP client) or bind(), listen(), and\naccept() (for a TCP server).\nPlease note that applications usually create the sockets they use automatically,\nand so is not straightforward to connect direcly to them using pointers. Please\nrefer to the source code of your preferred application to discover how and when\nit creates the socket.\n\nTCP Socket interaction and interface with Application layer\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn the following there is an analysis on the public interface of the TCP socket,\nand how it can be used to interact with the socket itself. An analysis of the\ncallback fired by the socket is also carried out. Please note that, for\nthe sake of clarity, we will use the terminology \"Sender\" and \"Receiver\" to clearly\ndivide the functionality of the socket. However, in TCP these two roles can be\napplied at the same time (i.e. a socket could be a sender and a receiver at the\nsame time): our distinction does not lose generality, since the following\ndefinition can be applied to both sockets in case of full-duplex mode.\n\n----------\n\n**TCP state machine (for commodity use)**\n\n.. _fig-tcp-state-machine:\n\n.. figure:: figures/tcp-state-machine.*\n   :align: center\n\n   TCP State machine\n\nIn ns-3 we are fully compliant with the state machine depicted in \nFigure :ref:`fig-tcp-state-machine`.\n\n----------\n\n**Public interface for receivers (e.g. servers receiving data)**\n\n*Bind()*\n  Bind the socket to an address, or to a general endpoint. A general endpoint\n  is an endpoint with an ephemeral port allocation (that is, a random port\n  allocation) on the 0.0.0.0 IP address. For instance, in current applications,\n  data senders usually binds automatically after a *Connect()* over a random\n  port. Consequently, the connection will start from this random port towards\n  the well-defined port of the receiver. The IP 0.0.0.0 is then translated by\n  lower layers into the real IP of the device.\n\n*Bind6()*\n  Same as *Bind()*, but for IPv6.\n\n*BindToNetDevice()*\n  Bind the socket to the specified NetDevice, creating a general endpoint.\n\n*Listen()*\n  Listen on the endpoint for an incoming connection. Please note that this\n  function can be called only in the TCP CLOSED state, and transit in the\n  LISTEN state. When an incoming request for connection is detected (i.e. the\n  other peer invoked *Connect()*) the application will be signaled with the\n  callback *NotifyConnectionRequest* (set in *SetAcceptCallback()* beforehand).\n  If the connection is accepted (the default behavior, when the associated\n  callback is a null one) the Socket will fork itself, i.e. a new socket is\n  created to handle the incoming data/connection, in the state SYN_RCVD. Please\n  note that this newly created socket is not connected anymore to the callbacks\n  on the \"father\" socket (e.g. DataSent, Recv); the pointer of the newly\n  created socket is provided in the Callback *NotifyNewConnectionCreated* (set\n  beforehand in *SetAcceptCallback*), and should be used to connect new\n  callbacks to interesting events (e.g. Recv callback). After receiving the ACK\n  of the SYN-ACK, the socket will set the congestion control, move into\n  ESTABLISHED state, and then notify the application with\n  *NotifyNewConnectionCreated*.\n\n*ShutdownSend()*\n  Signal a termination of send, or in other words revents data from being added\n  to the buffer. After this call, if buffer is already empty, the socket\n  will send a FIN, otherwise FIN will go when buffer empties. Please note\n  that this is useful only for modeling \"Sink\" applications. If you have\n  data to transmit, please refer to the *Send()* / *Close()* combination of\n  API.\n\n*GetRxAvailable()*\n  Get the amount of data that could be returned by the Socket in one or multiple\n  call to Recv or RecvFrom. Please use the Attribute system to configure the\n  maximum available space on the receiver buffer (property \"RcvBufSize\").\n\n*Recv()*\n  Grab data from the TCP socket. Please remember that TCP is a stream socket,\n  and it is allowed to concatenate multiple packets into bigger ones. If no data\n  is present (i.e. *GetRxAvailable* returns 0) an empty packet is returned.\n  Set the callback *RecvCallback* through *SetRecvCallback()* in order to have\n  the application automatically notified when some data is ready to be read.\n  It's important to connect that callback to the newly created socket in case\n  of forks.\n\n*RecvFrom()*\n  Same as Recv, but with the source address as parameter.\n\n-------------------\n\n**Public interface for senders (e.g. clients uploading data)**\n\n*Connect()*\n  Set the remote endpoint, and try to connect to it. The local endpoint should\n  be set before this call, or otherwise an ephemeral one will be created. The\n  TCP then will be in the SYN_SENT state. If a SYN-ACK is received, the TCP will\n  setup the congestion control, and then call the callback\n  *ConnectionSucceeded*.\n\n*GetTxAvailable()*\n  Return the amount of data that can be stored in the TCP Tx buffer. Set this\n  property through the Attribute system (\"SndBufSize\").\n\n*Send()*\n  Send the data into the TCP Tx buffer. From there, the TCP rules will decide\n  if, and when, this data will be transmitted. Please note that, if the tx\n  buffer has enough data to fill the congestion (or the receiver) window, dynamically\n  varying the rate at which data is injected in the TCP buffer does not have any\n  noticeable effect on the amount of data transmitted on the wire, that will\n  continue to be decided by the TCP rules.\n\n*SendTo()*\n  Same as *Send()*.\n\n*Close()*\n  Terminate the local side of the connection, by sending a FIN (after all data\n  in the tx buffer has been transmitted). This does not prevent the socket in\n  receiving data, and employing retransmit mechanism if losses are detected. If\n  the application calls *Close()* with unread data in its rx buffer, the socket\n  will send a reset. If the socket is in the state SYN_SENT, CLOSING, LISTEN,\n  FIN_WAIT_2, or LAST_ACK, after that call the application will be notified with\n  *NotifyNormalClose()*. In other cases, the notification is delayed\n  (see *NotifyNormalClose()*).\n\n-----------------------------------------\n\n**Public callbacks**\n\nThese callbacks are called by the TCP socket to notify the application of\ninteresting events. We will refer to these with the protected name used in\nsocket.h, but we will provide the API function to set the pointers to these\ncallback as well.\n\n*NotifyConnectionSucceeded*: *SetConnectCallback*, 1st argument\n  Called in the SYN_SENT state, before moving to ESTABLISHED. In other words, we\n  have sent the SYN, and we received the SYN-ACK: the socket prepare the\n  sequence numbers, send the ACK for the SYN-ACK, try to send out more data (in\n  another segment) and then invoke this callback. After this callback, it\n  invokes the NotifySend callback.\n\n*NotifyConnectionFailed*: *SetConnectCallback*, 2nd argument\n  Called after the SYN retransmission count goes to 0. SYN packet is lost\n  multiple time, and the socket give up.\n\n*NotifyNormalClose*: *SetCloseCallbacks*, 1st argument\n  A normal close is invoked. A rare case is when we receive an RST segment (or a\n  segment with bad flags) in normal states. All other cases are:\n  - The application tries to *Connect()* over an already connected socket\n  - Received an ACK for the FIN sent, with or without the FIN bit set (we are in LAST_ACK)\n  - The socket reaches the maximum amount of retries in retransmitting the SYN (*)\n  - We receive a timeout in the LAST_ACK state\n  - Upon entering the TIME_WAIT state, before waiting the 2*Maximum Segment Lifetime seconds to finally deallocate the socket.\n\n*NotifyErrorClose*: *SetCloseCallbacks*, 2nd argument\n  Invoked when we send an RST segment (for whatever reason) or we reached the\n  maximum amount of data retries.\n\n*NotifyConnectionRequest*: *SetAcceptCallback*, 1st argument\n  Invoked in the LISTEN state, when we receive a SYN. The return value indicates\n  if the socket should accept the connection (return true) or should ignore it\n  (return false).\n\n*NotifyNewConnectionCreated*: *SetAcceptCallback*, 2nd argument\n  Invoked when from SYN_RCVD the socket passes to ESTABLISHED, and after setting\n  up the congestion control, the sequence numbers, and processed the incoming\n  ACK. If there is some space in the buffer, *NotifySend* is called shortly\n  after this callback. The Socket pointer, passed with this callback, is the\n  newly created socket, after a Fork().\n\n*NotifyDataSent*: *SetDataSentCallback*\n  The Socket notifies the application that some bytes has been transmitted on\n  the IP level. These bytes could still be lost in the node (traffic control\n  layer) or in the network.\n\n*NotifySend*: *SetSendCallback*\n  Invoked if there is some space in the tx buffer when entering the ESTABLISHED\n  state (e.g. after the ACK for SYN-ACK is received), after the connection\n  succeeds (e.g. after the SYN-ACK is received) and after each new ack (i.e.\n  that advances SND.UNA).\n\n*NotifyDataRecv*: *SetRecvCallback*\n  Called when in the receiver buffere there are in-order bytes, and when in\n  FIN_WAIT_1 or FIN_WAIT_2 the socket receive a in-sequence FIN (that can carry\n  data).\n\n\nCongestion Control Algorithms\n+++++++++++++++++++++++++++++\nHere follows a list of supported TCP congestion control algorithms. For an\nacademic peer-reviewed paper on these congestion control algorithms, see\nhttp://dl.acm.org/citation.cfm?id=2756518 .\n\nNew Reno\n^^^^^^^^\nNew Reno algorithm introduces partial ACKs inside the well-established Reno\nalgorithm. This and other modifications are described in RFC 6582. We have two\npossible congestion window increment strategy: slow start and congestion\navoidance. Taken from RFC 5681:\n\n  During slow start, a TCP increments cwnd by at most SMSS bytes for\n  each ACK received that cumulatively acknowledges new data.  Slow\n  start ends when cwnd exceeds ssthresh (or, optionally, when it\n  reaches it, as noted above) or when congestion is observed.  While\n  traditionally TCP implementations have increased cwnd by precisely\n  SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND\n  that TCP implementations increase cwnd, per Equation :eq:`newrenocongavoid`,\n  where N is the number of previously unacknowledged bytes acknowledged\n  in the incoming ACK.\n\n.. math:: cwnd += min (N, SMSS)\n   :label: newrenocongavoid\n\nDuring congestion avoidance, cwnd is incremented by roughly 1 full-sized\nsegment per round-trip time (RTT), and for each congestion event, the slow\nstart threshold is halved.\n\nHigh Speed\n^^^^^^^^^^\nTCP HighSpeed is designed for high-capacity channels or, in general, for\nTCP connections with large congestion windows.\nConceptually, with respect to the standard TCP, HighSpeed makes the\ncWnd grow faster during the probing phases and accelerates the\ncWnd recovery from losses.\nThis behavior is executed only when the window grows beyond a\ncertain threshold, which allows TCP Highspeed to be friendly with standard\nTCP in environments with heavy congestion, without introducing new dangers\nof congestion collapse.\n\nMathematically:\n\n.. math::  cWnd = cWnd + \\frac{a(cWnd)}{cWnd}\n\nThe function a() is calculated using a fixed RTT the value 100 ms (the\nlookup table for this function is taken from RFC 3649). For each congestion\nevent, the slow start threshold is decreased by a value that depends on the\nsize of the slow start threshold itself. Then, the congestion window is set\nto such value.\n\n.. math::   cWnd = (1-b(cWnd)) \\cdot cWnd\n\nThe lookup table for the function b() is taken from the same RFC.\nMore information at: http://dl.acm.org/citation.cfm?id=2756518\n\nHybla\n^^^^^\nThe key idea behind TCP Hybla is to obtain for long RTT connections the same\ninstantaneous transmission rate of a reference TCP connection with lower RTT.\nWith analytical steps, it is shown that this goal can be achieved by\nmodifying the time scale, in order for the throughput to be independent from\nthe RTT. This independence is obtained through the use of a coefficient rho.\n\nThis coefficient is used to calculate both the slow start threshold\nand the congestion window when in slow start and in congestion avoidance,\nrespectively.\n\nMore information at: http://dl.acm.org/citation.cfm?id=2756518\n\nWestwood\n^^^^^^^^\nWestwood and Westwood+ employ the AIAD (Additive Increase/Adaptive Decrease)\u00b7\ncongestion control paradigm. When a congestion episode happens,\u00b7\ninstead of halving the cwnd, these protocols try to estimate the network's\nbandwidth and use the estimated value to adjust the cwnd.\u00b7\nWhile Westwood performs the bandwidth sampling every ACK reception,\u00b7\nWestwood+ samples the bandwidth every RTT.\n\nMore information at: http://dl.acm.org/citation.cfm?id=381704 and\nhttp://dl.acm.org/citation.cfm?id=2512757\n\nVegas\n^^^^^\nTCP Vegas is a pure delay-based congestion control algorithm implementing a\nproactive scheme that tries to prevent packet drops by maintaining a small\nbacklog at the bottleneck queue. Vegas continuously samples the RTT and computes\nthe actual throughput a connection achieves using Equation (1) and compares it\nwith the expected throughput calculated in Equation (2). The difference between\nthese 2 sending rates in Equation (3) reflects the amount of extra packets being\nqueued at the bottleneck.\n\n.. math::\n\n   actual &= \\frac{cWnd}{RTT}        \\\\\n   expected &= \\frac{cWnd}{BaseRTT}  \\\\\n   diff &= expected - actual\n\nTo avoid congestion, Vegas linearly increases/decreases its congestion window\nto ensure the diff value fall between the two predefined thresholds, alpha and\nbeta. diff and another threshold, gamma, are used to determine when Vegas\nshould change from its slow-start mode to linear increase/decrease mode.\nFollowing the implementation of Vegas in Linux, we use 2, 4, and 1 as the\ndefault values of alpha, beta, and gamma, respectively, but they can be\nmodified through the Attribute system.\n\nMore information at: http://dx.doi.org/10.1109/49.464716\n\nScalable\n^^^^^^^^\nScalable improves TCP performance to better utilize the available bandwidth of\na highspeed wide area network by altering NewReno congestion window adjustment\nalgorithm.  When congestion has not been detected, for each ACK received in an\nRTT, Scalable increases its cwnd per:\n\n.. math::  cwnd = cwnd + 0.01\n\nFollowing Linux implementation of Scalable, we use 50 instead of 100 to account\nfor delayed ACK.\n\nOn the first detection of congestion in a given RTT, cwnd is reduced based on\nthe following equation:\n\n.. math::  cwnd = cwnd - ceil(0.125 \\cdot cwnd)\n\nMore information at: http://dl.acm.org/citation.cfm?id=956989\n\nVeno\n^^^^\n\nTCP Veno enhances Reno algorithm for more effectively dealing with random\npacket loss in wireless access networks by employing Vegas's method in\nestimating the backlog at the bottleneck queue to distinguish between\ncongestive and non-congestive states.\n\nThe backlog (the number of packets accumulated at the bottleneck queue) is\ncalculated using Equation (1):\n\n.. math::\n   N &= Actual \\cdot (RTT - BaseRTT) \\\\\n     &= Diff \\cdot BaseRTT\n\nwhere:\n\n.. math::\n   Diff &= Expected - Actual \\\\\n        &= \\frac{cWnd}{BaseRTT} - \\frac{cWnd}{RTT}\n\nVeno makes decision on cwnd modification based on the calculated N and its\npredefined threshold beta.\n\nSpecifically, it refines the additive increase algorithm of Reno so that the\nconnection can stay longer in the stable state by incrementing cwnd by\n1/cwnd for every other new ACK received after the available bandwidth has\nbeen fully utilized, i.e. when N exceeds beta.  Otherwise, Veno increases\nits cwnd by 1/cwnd upon every new ACK receipt as in Reno.\n\nIn the multiplicative decrease algorithm, when Veno is in the non-congestive\nstate, i.e. when N is less than beta, Veno decrements its cwnd by only 1/5\nbecause the loss encountered is more likely a corruption-based loss than a\ncongestion-based.  Only when N is greater than beta, Veno halves its sending\nrate as in Reno.\n\nMore information at: http://dx.doi.org/10.1109/JSAC.2002.807336\n\nBic\n^^^\n\nIn TCP Bic the congestion control problem is viewed as a search\nproblem. Taking as a starting point the current window value\nand as a target point the last maximum window value\n(i.e. the cWnd value just before the loss event) a binary search\ntechnique can be used to update the cWnd value at the midpoint between\nthe two, directly or using an additive increase strategy if the distance from\nthe current window is too large.\n\nThis way, assuming a no-loss period, the congestion window logarithmically\napproaches the maximum value of cWnd until the difference between it and cWnd\nfalls below a preset threshold. After reaching such a value (or the maximum\nwindow is unknown, i.e. the binary search does not start at all) the algorithm\nswitches to probing the new maximum window with a 'slow start' strategy.\n\nIf a loss occur in either these phases, the current window (before the loss)\ncan be treated as the new maximum, and the reduced (with a multiplicative\ndecrease factor Beta) window size can be used as the new minimum.\n\nMore information at: http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672\n\nYeAH\n^^^^\n\nYeAH-TCP (Yet Another HighSpeed TCP) is a heuristic designed to balance various\nrequirements of a state-of-the-art congestion control algorithm:\n\n\n1. fully exploit the link capacity of high BDP networks while inducing a small number of congestion events\n2. compete friendly with Reno flows\n3. achieve intra and RTT fairness\n4. robust to random losses\n5. achieve high performance regardless of buffer size\n\nYeAH operates between 2 modes: Fast and Slow mode.  In the Fast mode when the queue\noccupancy is small and the network congestion level is low, YeAH increments\nits congestion window according to the aggressive STCP rule.  When the number of packets\nin the queue grows beyond a threshold and the network congestion level is high, YeAH enters\nits Slow mode, acting as Reno with a decongestion algorithm.  YeAH employs Vegas' mechanism\nfor calculating the backlog as in Equation :eq:`q_yeah`.  The estimation of the network congestion\nlevel is shown in Equation :eq:`l_yeah`.\n\n.. math::  Q = (RTT - BaseRTT) \\cdot \\frac{cWnd}{RTT}\n   :label: q_yeah\n\n.. math::  L = \\frac{RTT - BaseRTT}{BaseRTT}\n   :label: l_yeah\n\nTo ensure TCP friendliness, YeAH also implements an algorithm to detect the presence of legacy\nReno flows.  Upon the receipt of 3 duplicate ACKs, YeAH decreases its slow start threshold\naccording to Equation (3) if it's not competing with Reno flows.  Otherwise,  the ssthresh is\nhalved as in Reno:\n\n.. math::  ssthresh = min(max(\\frac{cWnd}{8}, Q), \\frac{cWnd}{2})\n\nMore information: http://www.csc.lsu.edu/~sjpark/cs7601/4-YeAH_TCP.pdf\n\nIllinois\n^^^^^^^^\n\nTCP Illinois is a hybrid congestion control algorithm designed for\nhigh-speed networks.  Illinois implements a Concave-AIMD (or C-AIMD)\nalgorithm that uses packet loss as the primary congestion signal to\ndetermine the direction of window update and queueing delay as the\nsecondary congestion signal to determine the amount of change.\n\nThe additive increase and multiplicative decrease factors (denoted as\nalpha and beta, respectively) are functions of the current average queueing\ndelay da as shown in Equations (1) and (2).  To improve the protocol\nrobustness against sudden fluctuations in its delay sampling,\nIllinois allows the increment of alpha to alphaMax\nonly if da stays below d1 for a some (theta) amount of time.\n\n.. math::\n   alpha &=\n   \\begin{cases}\n      \\quad alphaMax              & \\quad \\text{if } da <= d1 \\\\\n      \\quad k1 / (k2 + da)        & \\quad \\text{otherwise} \\\\\n   \\end{cases} \\\\\n   \\\\\n   beta &=\n   \\begin{cases}\n      \\quad betaMin               & \\quad \\text{if } da <= d2 \\\\\n      \\quad k3 + k4 \\, da         & \\quad \\text{if } d2 < da < d3 \\\\\n      \\quad betaMax               & \\quad \\text{otherwise}\n   \\end{cases}\n\t\t\t     \nwhere the calculations of k1, k2, k3, and k4 are shown in the following:\n\n.. math::\n\n   k1 &= \\frac{(dm - d1) \\cdot alphaMin \\cdot alphaMax}{alphaMax - alphaMin} \\\\\n   \\\\\n   k2 &= \\frac{(dm - d1) \\cdot alphaMin}{alphaMax - alphaMin} - d1 \\\\\n   \\\\\n   k3 &= \\frac{alphaMin \\cdot d3 - alphaMax \\cdot d2}{d3 - d2} \\\\\n   \\\\\n   k4 &= \\frac{alphaMax - alphaMin}{d3 - d2}\n\nOther parameters include da (the current average queueing delay), and\nTa (the average RTT, calculated as sumRtt / cntRtt in the implementation) and\nTmin (baseRtt in the implementation) which is the minimum RTT ever seen.\ndm is the maximum (average) queueing delay, and Tmax (maxRtt in the\nimplementation) is the maximum RTT ever seen.\n\n.. math::\n\n   da &= Ta - Tmin\n\n   dm &= Tmax - Tmin\n\n   d_i &= eta_i \\cdot dm\n\nIllinois only executes its adaptation of alpha and beta when cwnd exceeds a threshold\ncalled winThresh. Otherwise, it sets alpha and beta to the base values of 1 and 0.5,\nrespectively.\n\nFollowing the implementation of Illinois in the Linux kernel, we use the following\ndefault parameter settings:\n\n* alphaMin = 0.3      (0.1 in the Illinois paper)\n* alphaMax = 10.0\n* betaMin = 0.125\n* betaMax = 0.5\n* winThresh = 15      (10 in the Illinois paper)\n* theta = 5\n* eta1 = 0.01\n* eta2 = 0.1\n* eta3 = 0.8\n\nMore information: http://www.doi.org/10.1145/1190095.1190166\n\nH-TCP\n^^^^^\n\nH-TCP has been designed for high BDP (Bandwidth-Delay Product) paths. It is \na dual mode protocol. In normal conditions, it works like traditional TCP \nwith the same rate of increment and decrement for the congestion window. \nHowever, in high BDP networks, when it finds no congestion on the path \nafter ``deltal`` seconds, it increases the window size based on the alpha \nfunction in the following:\n\n.. math::\n\n        alpha(delta)=1+10(delta-deltal)+0.5(delta-deltal)^2 \n\nwhere ``deltal`` is a threshold in seconds for switching between the modes and \n``delta`` is the elapsed time from the last congestion. During congestion, \nit reduces the window size by multiplying by beta function provided \nin the reference paper.  The calculated throughput between the last two \nconsecutive congestion events is considered for beta calculation. \n\nThe transport ``TcpHtcp`` can be selected in the program \n``examples/tcp/tcp-variants/comparison`` to perform an experiment with H-TCP,\nalthough it is useful to increase the bandwidth in this example (e.g.\nto 20 Mb/s) to create a higher BDP link, such as\n\n::\n\n  ./waf --run \"tcp-variants-comparison --transport_prot=TcpHtcp --bandwidth=20Mbps --duration=10\"\n\nMore information (paper):  http://www.hamilton.ie/net/htcp3.pdf\n\nMore information (Internet Draft):  https://tools.ietf.org/html/draft-leith-tcp-htcp-06\n\nLEDBAT\n^^^^^^\n\nLow Extra Delay Background Transport (LEDBAT) is an experimental delay-based \ncongestion control algorithm that seeks to utilize the available bandwidth on\nan end-to-end path while limiting the consequent increase in queueing delay \non that path. LEDBAT uses changes in one-way delay measurements to limit \ncongestion that the flow itself induces in the network.\n\nAs a first approximation, the LEDBAT sender operates as shown below:\n\non receipt of an ACK:\n\n.. math::\n       currentdelay = acknowledgement.delay\n       basedelay = min (basedelay, currentdelay)\n       queuingdelay = currentdelay - basedelay\n       offtarget = (TARGET - queuingdelay) / TARGET\n       cWnd += GAIN * offtarget * bytesnewlyacked * MSS / cWnd\n\n``TARGET`` is the maximum queueing delay that LEDBAT itself may introduce in the\nnetwork, and ``GAIN`` determines the rate at which the cwnd responds to changes in \nqueueing delay;  ``offtarget`` is a normalized value representing the difference between\nthe measured current queueing delay and the predetermined TARGET delay. offtarget can \nbe positive or negative; consequently, cwnd increases or decreases in proportion to \nofftarget.\n\nFollowing the recommendation of RFC 6817, the default values of the parameters are:\n\n* TargetDelay = 100\n* baseHistoryLen = 10\n* noiseFilterLen = 4\n* Gain = 1\n\nTo enable LEDBAT on all TCP sockets, the following configuration can be used:\n\n::\n\n  Config::SetDefault (\"ns3::TcpL4Protocol::SocketType\", TypeIdValue (TcpLedbat::GetTypeId ()));\n\nTo enable LEDBAT on a chosen TCP socket, the following configuration can be used:\n\n::\n\n  Config::Set (\"$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType\", TypeIdValue (TcpLedbat::GetTypeId ()));\n\nThe following unit tests have been written to validate the implementation of LEDBAT:\n\n* LEDBAT should operate same as NewReno during slow start\n* LEDBAT should operate same as NewReno if timestamps are disabled\n* Test to validate cwnd increment in LEDBAT\n\nIn comparison to RFC 6817, the scope and limitations of the current LEDBAT\nimplementation are:\n\n* It assumes that the clocks on the sender side and receiver side are synchronised\n* In line with Linux implementation, the one-way delay is calculated at the sender side by using the timestamps option in TCP header\n* Only the MIN function is used for noise filtering \n\nMore information about LEDBAT is available in RFC 6817: https://tools.ietf.org/html/rfc6817\n\nTCP-LP\n^^^^^^\n\nTCP-Low priority is a delay based congestion control protocol in which the low\npriority data utilizes only the excess bandwidth available on an end-to-end path.\nTCP-LP uses one way delay measurements as an indicator of congestion as it does\nnot influence cross-traffic in the reverse direction.\n\nOn acknowledgement:\n\n.. math::\n\n  One way delay = Receiver timestamp - Receiver timestamp echo reply\n  Smoothed one way delay = 7/8 * Old Smoothed one way delay + 1/8 * one way delay\n  If smoothed one way delay > owdMin + 15 * (owdMax - owdMin) / 100\n    if LP_WITHIN_INF\n      cwnd = 1\n    else\n      cwnd = cwnd / 2\n    Inference timer is set\n\nwhere owdMin and owdMax are the minimum and maximum one way delays experienced\nthroughout the connection, LP_WITHIN_INF indicates if TCP-LP is in inference\nphase or not\n\nMore information (paper): http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf\n\nSupport for Explicit Congestion Notification (ECN)\n++++++++++++++++++++++++++++++++++++++++++++++++++\n\nECN provides end-to-end notification of network congestion without dropping\npackets. It uses two bits in the IP header: ECN Capable Transport (ECT bit)\nand Congestion Experienced (CE bit), and two bits in the TCP header: Congestion\nWindow Reduced (CWR) and ECN Echo (ECE).\n\nMore information is available in RFC 3168: https://tools.ietf.org/html/rfc3168\n\nThe following ECN states are declared in ``src/internet/model/tcp-socket.h``\n\n::\n\n  typedef enum\n    {\n      ECN_DISABLED = 0, //!< ECN disabled traffic\n      ECN_IDLE,         //!< ECN is enabled but currently there is no action pertaining to ECE or CWR to be taken\n      ECN_CE_RCVD,      //!< Last packet received had CE bit set in IP header\n      ECN_SENDING_ECE,  //!< Receiver sends an ACK with ECE bit set in TCP header\n      ECN_ECE_RCVD,     //!< Last ACK received had ECE bit set in TCP header\n      ECN_CWR_SENT      //!< Sender has reduced the congestion window, and sent a packet with CWR bit set in TCP header. This is used for tracing.\n    } EcnStates_t;\n\nCurrent implementation of ECN is based on RFC 3168 and is referred as Classic ECN.\n\nThe following enum represents the mode of ECN:\n\n::\n\n  typedef enum\n    {\n      NoEcn = 0,   //!< ECN is not enabled.\n      ClassicEcn   //!< ECN functionality as described in RFC 3168.\n    } EcnMode_t;\n\nThe following are some important ECN parameters\n  // ECN parameters\n  EcnMode_t                     m_ecnMode;    //!< Socket ECN capability\n  TracedValue<SequenceNumber32> m_ecnEchoSeq; //!< Sequence number of the last received ECN Echo\n\nEnabling ECN\n^^^^^^^^^^^^\n\nBy default, support for ECN is disabled in TCP sockets.  To enable, change\nthe value of the attribute ``ns3::TcpSocketBase::EcnMode`` from NoEcn to ClassicEcn.\n\n::\n\n  Config::SetDefault (\"ns3::TcpSocketBase::EcnMode\", StringValue (\"ClassicEcn\"))\n\nECN negotiation\n^^^^^^^^^^^^^^^\n\nECN capability is negotiated during the three-way TCP handshake:\n\n1. Sender sends SYN + CWR + ECE\n\n::\n\n    if (m_ecnMode == EcnMode_t::ClassicEcn)\n      {\n        SendEmptyPacket (TcpHeader::SYN | TcpHeader::ECE | TcpHeader::CWR);\n      }\n    else\n      {\n        SendEmptyPacket (TcpHeader::SYN);\n      }\n    m_ecnState = ECN_DISABLED;\n\n2. Receiver sends SYN + ACK + ECE\n\n::\n\n    if (m_ecnMode == EcnMode_t::ClassicEcn && (tcpHeader.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::CWR | TcpHeader::ECE))\n      {\n        SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK |TcpHeader::ECE);\n        m_ecnState = ECN_IDLE;\n      }\n    else\n      {\n        SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);\n        m_ecnState = ECN_DISABLED;\n      }\n\n3. Sender sends ACK\n\n::\n\n    if (m_ecnMode == EcnMode_t::ClassicEcn &&  (tcpHeader.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::ECE))\n      {\n        m_ecnState = ECN_IDLE;\n      }\n    else\n      {\n        m_ecnState = ECN_DISABLED;\n      }\n\nOnce the ECN-negotiation is successful, the sender sends data packets with ECT\nbits set in the IP header.\n\nNote: As mentioned in Section 6.1.1 of RFC 3168, ECT bits should not be set\nduring ECN negotiation. The ECN negotiation implemented in |ns3| follows\nthis guideline.\n\nECN State Transitions\n^^^^^^^^^^^^^^^^^^^^^\n\n1. Initially both sender and receiver have their m_ecnState set as ECN_DISABLED\n2. Once the ECN negotiation is successful, their states are set to ECN_IDLE\n3. The receiver's state changes to ECN_CE_RCVD when it receives a packet with\n   CE bit set. The state then moves to ECN_SENDING_ECE when the receiver sends\n   an ACK with ECE set. This state is retained until a CWR is received\n   , following which, the state changes to ECN_IDLE.\n4. When the sender receives an ACK with ECE bit set from receiver, its state\n   is set as ECN_ECE_RCVD\n5. The sender's state changes to ECN_CWR_SENT when it sends a packet with\n   CWR bit set. It remains in this state until an ACK with valid ECE is received\n   (i.e., ECE is received for a packet that belongs to a new window),\n   following which, it's state changes to ECN_ECE_RCVD.\n\nRFC 3168 compliance\n^^^^^^^^^^^^^^^^^^^\n\nBased on the suggestions provided in RFC 3168, the following behavior has\nbeen implemented:\n\n1. Pure ACK packets should not have the ECT bit set (Section 6.1.4).\n2. In the current implementation, the sender only sends ECT(0) in the IP header.\n3. The sender should should reduce the congestion window only once in each\n   window (Section 6.1.2).\n4. The receiver should ignore the CE bits set in a packet arriving out of\n   window (Section 6.1.5).\n5. The sender should ignore the ECE bits set in the packet arriving out of\n   window (Section 6.1.2).\n\nOpen issues\n^^^^^^^^^^^\n\nThe following issues are yet to be addressed:\n\n1. Retransmitted packets should not have the CWR bit set (Section 6.1.5).\n\n2. Despite the congestion window size being 1 MSS, the sender should reduce its\n   congestion window by half when it receives a packet with the ECE bit set. The\n   sender must reset the retransmit timer on receiving the ECN-Echo packet when\n   the congestion window is one.  The sending TCP will then be able to send a\n   new packet only when the retransmit timer expires (Section 6.1.2).\n\n3. Support for separately handling the enabling of ECN on the incoming and\n   outgoing TCP sessions (e.g. a TCP may perform ECN echoing but not set the\n   ECT codepoints on its outbound data segments).\n\nValidation\n++++++++++\n\nThe following tests are found in the ``src/internet/test`` directory.  In\ngeneral, TCP tests inherit from a class called :cpp:class:`TcpGeneralTest`,\nwhich provides common operations to set up test scenarios involving TCP\nobjects.  For more information on how to write new tests, see the\nsection below on :ref:`Writing-tcp-tests`.\n\n* **tcp:** Basic transmission of string of data from client to server\n* **tcp-bytes-in-flight-test:** TCP correctly estimates bytes in flight under loss conditions\n* **tcp-cong-avoid-test:** TCP congestion avoidance for different packet sizes\n* **tcp-datasentcb:** Check TCP's 'data sent' callback\n* **tcp-endpoint-bug2211-test:** A test for an issue that was causing stack overflow\n* **tcp-fast-retr-test:** Fast Retransmit testing\n* **tcp-header:** Unit tests on the TCP header\n* **tcp-highspeed-test:** Unit tests on the Highspeed congestion control\n* **tcp-htcp-test:** Unit tests on the H-TCP congestion control\n* **tcp-hybla-test:** Unit tests on the Hybla congestion control\n* **tcp-vegas-test:** Unit tests on the Vegas congestion control\n* **tcp-veno-test:** Unit tests on the Veno congestion control\n* **tcp-scalable-test:** Unit tests on the Scalable congestion control\n* **tcp-bic-test:** Unit tests on the BIC congestion control\n* **tcp-yeah-test:** Unit tests on the YeAH congestion control\n* **tcp-illinois-test:** Unit tests on the Illinois congestion control\n* **tcp-ledbat-test:** Unit tests on the LEDBAT congestion control\n* **tcp-lp-test:** Unit tests on the TCP-LP congestion control\n* **tcp-option:** Unit tests on TCP options\n* **tcp-pkts-acked-test:** Unit test the number of time that PktsAcked is called\n* **tcp-rto-test:** Unit test behavior after a RTO timeout occurs\n* **tcp-rtt-estimation-test:** Check RTT calculations, including retransmission cases\n* **tcp-slow-start-test:** Check behavior of slow start\n* **tcp-timestamp:** Unit test on the timestamp option\n* **tcp-wscaling:** Unit test on the window scaling option\n* **tcp-zero-window-test:** Unit test persist behavior for zero window conditions\n* **tcp-close-test:** Unit test on the socket closing: both receiver and sender have to close their socket when all bytes are transferred\n* **tcp-ecn-test:** Unit tests on explicit congestion notification\n\nSeveral tests have dependencies outside of the ``internet`` module, so they\nare located in a system test directory called ``src/test/ns3tcp``.  Three\nof these six tests involve use of the Network Simulation Cradle, and are\ndisabled if NSC is not enabled in the build.  \n\n* **ns3-tcp-cwnd:** Check to see that ns-3 TCP congestion control works against liblinux2.6.26.so implementation\n* **ns3-tcp-interoperability:** Check to see that ns-3 TCP interoperates with liblinux2.6.26.so implementation\n* **ns3-tcp-loss:** Check behavior of ns-3 TCP upon packet losses\n* **nsc-tcp-loss:** Check behavior of NSC TCP upon packet losses\n* **ns3-tcp-no-delay:** Check that ns-3 TCP Nagle\"s algorithm works correctly and that it can be disabled\n* **ns3-tcp-socket:** Check that ns-3 TCP successfully transfers an application data write of various sizes\n* **ns3-tcp-state:** Check the operation of the TCP state machine for several cases\n \nSeveral TCP validation test results can also be found in the\n`wiki page <http://www.nsnam.org/wiki/New_TCP_Socket_Architecture>`_ \ndescribing this implementation.\n\nTCP ECN operation is tested in the ARED and RED tests that are documented in the traffic-control\nmodule documentation.\n\nWriting a new congestion control algorithm\n++++++++++++++++++++++++++++++++++++++++++\n\nWriting (or porting) a congestion control algorithms from scratch (or from\nother systems) is a process completely separated from the internals of\nTcpSocketBase.\n\nAll operations that are delegated to a congestion control are contained in\nthe class TcpCongestionOps. It mimics the structure tcp_congestion_ops of\nLinux, and the following operations are defined:\n\n.. code-block:: c++\n\n  virtual std::string GetName () const;\n  virtual uint32_t GetSsThresh (Ptr<const TcpSocketState> tcb, uint32_t bytesInFlight);\n  virtual void IncreaseWindow (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked);\n  virtual void PktsAcked (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked,const Time& rtt);\n  virtual Ptr<TcpCongestionOps> Fork ();\n  virtual void CwndEvent (Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCaEvent_t event);\n\nThe most interesting methods to write are GetSsThresh and IncreaseWindow.\nThe latter is called when TcpSocketBase decides that it is time to increase\nthe congestion window. Much information is available in the Transmission\nControl Block, and the method should increase cWnd and/or ssThresh based\non the number of segments acked.\n\nGetSsThresh is called whenever the socket needs an updated value of the\nslow start threshold. This happens after a loss; congestion control algorithms\nare then asked to lower such value, and to return it.\n\nPktsAcked is used in case the algorithm needs timing information (such as\nRTT), and it is called each time an ACK is received.\n\nCwndEvent is used in case the algorithm needs the state of socket during different\ncongestion window event.\n\nTCP SACK and non-SACK\n+++++++++++++++++++++\nTo avoid code duplication and the effort of maintaining two different versions\nof the TCP core, namely RFC 6675 (TCP-SACK) and RFC 5681 (TCP congestion control),\nwe have merged RFC 6675 in the current code base. If the receiver supports the\noption, the sender bases its retransmissions over the received SACK information.\nHowever, in the absence of that option, the best it can do is to follow the RFC\n5681 specification (on Fast Retransmit/Recovery) and employing NewReno\nmodifications in case of partial ACKs.\n\nA similar concept is used in Linux with the function tcp_add_reno_sack.\nOur implementation resides in the TcpTxBuffer class that implements a scoreboard\nthrough two different lists of segments. TcpSocketBase actively uses the API\nprovided by TcpTxBuffer to query the scoreboard; please refer to the Doxygen\ndocumentation (and to in-code comments) if you want to learn more about this\nimplementation.\n\nFor an academic peer-reviewed paper on the SACK implementation in ns-3,\nplease refer to https://dl.acm.org/citation.cfm?id=3067666.\n\nLoss Recovery Algorithms\n++++++++++++++++++++++++\nThe following loss recovery algorithms are supported in ns-3 TCP:\n\nClassic Recovery\n^^^^^^^^^^^^^^^^\nClassic Recovery refers to the combination of NewReno algorithm described in\nRFC 6582 along with SACK based loss recovery algorithm mentioned in RFC 6675.\nSACK based loss recovery is used when sender and receiver support SACK options.\nIn the case when SACK options are disabled, the NewReno modification handles\nthe recovery.\n\nAt the start of recovery phase the congestion window is reduced diffently for\nNewReno and SACK based recovery. For NewReno the reduction is done as given below:\n\n.. math::  cWnd = ssThresh\n\nFor SACK based recovery, this is done as follows:\n\n.. math::   cWnd = ssThresh + (dupAckCount * segmentSize)\n\nWhile in the recovery phase, the congestion window is inflated by segmentSize\non arrival of every ACK when NewReno is used. The congestion window is kept\nsame when SACK based loss recovery is used.\n\nProportional Rate Reduction\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\nProportional Rate Reduction (PRR) is the fast recovery algorithm described in\nRFC 6937 and currently used in Linux. The design of PRR helps in avoiding\nexcess window adjustments and aims to keep the congestion window as close as\npossible to ssThresh.\n\nPRR updates the congestion window by comparing the values of bytesInFlight and\nssThresh. If the value of bytesInFlight is greater than ssThresh, congestion window\nis updated as shown below:\n\n.. math::  sndcnt = CEIL(prrDelivered * ssThresh / RecoverFS) - prrOut\n.. math::  cWnd = pipe + sndcnt\n\nwhere ``RecoverFS`` is the value of bytesInFlight at the start of recovery phase,\n``prrDelivered`` is the total bytes delivered during recovery phase,\n``prrOut`` is the total bytes sent during recovery phase and\n``sndcnt`` represents the number of bytes to be sent in response to each ACK.\n\nOtherwise, the congestion window is updated by either using Conservative Reduction\nBound (CRB) or Slow Start Reduction Bound (SSRB) with SSRB being the default\nReduction Bound. Each Reduction Bound calculates a maximum data sending limit.\nFor CRB, the limit is calculated as shown below:\n\n.. math::  limit = prrDelivered - prr out\n\nFor SSRB, it is calculated as:\n\n.. math::  limit = MAX(prrDelivered - prrOut, DeliveredData) + MSS\n\nwhere ``DeliveredData`` represets the total number of bytes delivered to the\nreceiver as indicated by the current ACK and ``MSS`` is the maximum segment size.\n\nAfter limit calculation, the cWnd is updated as given below:\n\n.. math::  sndcnt = MIN (ssThresh - pipe, limit)\n.. math::  cWnd = pipe + sndcnt\n\nMore information (paper):  https://dl.acm.org/citation.cfm?id=2068832\n\nMore information (RFC):  https://tools.ietf.org/html/rfc6937\n\nAdding a new loss recovery algorithm in ns-3\n++++++++++++++++++++++++++++++++++++++++++++\n\nWriting (or porting) a loss recovery algorithms from scratch (or from\nother systems) is a process completely separated from the internals of\nTcpSocketBase.\n\nAll operations that are delegated to a loss recovery are contained in\nthe class TcpRecoveryOps and are given below:\n\n.. code-block:: c++\n\n  virtual std::string GetName () const;\n  virtual void EnterRecovery (Ptr<const TcpSocketState> tcb, uint32_t unAckDataCount,\n                              bool isSackEnabled, uint32_t dupAckCount,\n                              uint32_t bytesInFlight, uint32_t lastDeliveredBytes);\n  virtual void DoRecovery (Ptr<const TcpSocketState> tcb, uint32_t unAckDataCount,\n                           bool isSackEnabled, uint32_t dupAckCount,\n                           uint32_t bytesInFlight, uint32_t lastDeliveredBytes);\n  virtual void ExitRecovery (Ptr<TcpSocketState> tcb, uint32_t bytesInFlight);\n  virtual void UpdateBytesSent (uint32_t bytesSent);\n  virtual Ptr<TcpRecoveryOps> Fork ();\n\nEnterRecovery is called when packet loss is detected and recovery is triggered.\nWhile in recovery phase, each time when an ACK arrives, DoRecovery is called which\nperforms the necessary congestion window changes as per the recovery algorithm.\nExitRecovery is called just prior to exiting recovery phase in order to perform the\nrequired congestion window ajustments. UpdateBytesSent is used to keep track of\nbytes sent and is called whenever a data packet is sent during recovery phase.\n\nCurrent limitations\n+++++++++++++++++++\n\n* TcpCongestionOps interface does not contain every possible Linux operation\n\n.. _Writing-tcp-tests:\n\nWriting TCP tests\n+++++++++++++++++\n\nThe TCP subsystem supports automated test\ncases on both socket functions and congestion control algorithms. To show\nhow to write tests for TCP, here we explain the process of creating a test\ncase that reproduces a bug (#1571 in the project bug tracker).\n\nThe bug concerns the zero window situation, which happens when the receiver can\nnot handle more data. In this case, it advertises a zero window, which causes\nthe sender to pause transmission and wait for the receiver to increase the\nwindow.\n\nThe sender has a timer to periodically check the receiver's window: however, in\nmodern TCP implementations, when the receiver has freed a \"significant\" amount\nof data, the receiver itself sends an \"active\" window update, meaning that\nthe transmission could be resumed. Nevertheless, the sender timer is still\nnecessary because window updates can be lost.\n\n.. note::\n   During the text, we will assume some knowledge about the general design\n   of the TCP test infrastructure, which is explained in detail into the\n   Doxygen documentation. As a brief summary, the strategy is to have a class\n   that sets up a TCP connection, and that calls protected members of itself.\n   In this way, subclasses can implement the necessary members, which will\n   be called by the main TcpGeneralTest class when events occur. For example,\n   after processing an ACK, the method ProcessedAck will be invoked. Subclasses\n   interested in checking some particular things which must have happened during\n   an ACK processing, should implement the ProcessedAck method and check\n   the interesting values inside the method. To get a list of available methods,\n   please check the Doxygen documentation.\n\nWe describe the writing of two test case, covering both situations: the\nsender's zero-window probing and the receiver \"active\" window update. Our focus\nwill be on dealing with the reported problems, which are:\n\n* an ns-3 receiver does not send \"active\" window update when its receive buffer\n  is being freed;\n* even if the window update is artificially crafted, the transmission does not\n  resume.\n\nHowever, other things should be checked in the test:\n\n* Persistent timer setup\n* Persistent timer teardown if rWnd increases\n\nTo construct the test case, one first derives from the TcpGeneralTest class:\n\nThe code is the following:\n\n.. code-block:: c++\n\n   TcpZeroWindowTest::TcpZeroWindowTest (const std::string &desc)\n      : TcpGeneralTest (desc)\n   {\n   }\n\nThen, one should define the general parameters for the TCP connection, which\nwill be one-sided (one node is acting as SENDER, while the other is acting as\nRECEIVER):\n\n* Application packet size set to 500, and 20 packets in total (meaning a stream\n  of 10k bytes)\n* Segment size for both SENDER and RECEIVER set to 500 bytes\n* Initial slow start threshold set to UINT32_MAX\n* Initial congestion window for the SENDER set to 10 segments (5000 bytes)\n* Congestion control: NewReno\n\nWe have also to define the link properties, because the above definition does\nnot work for every combination of propagation delay and sender application behavior.\n\n* Link one-way propagation delay: 50 ms\n* Application packet generation interval: 10 ms\n* Application starting time: 20 s after the starting point\n\nTo define the properties of the environment (e.g. properties which should be\nset before the object creation, such as propagation delay) one next implements\nehe method ConfigureEnvironment:\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::ConfigureEnvironment ()\n   {\n     TcpGeneralTest::ConfigureEnvironment ();\n     SetAppPktCount (20);\n     SetMTU (500);\n     SetTransmitStart (Seconds (2.0));\n     SetPropagationDelay (MilliSeconds (50));\n   }\n\nFor other properties, set after the object creation, one can use \nConfigureProperties ().\nThe difference is that some values, such as initial congestion window\nor initial slow start threshold, are applicable only to a single instance, not\nto every instance we have. Usually, methods that requires an id and a value\nare meant to be called inside ConfigureProperties (). Please see the doxygen\ndocumentation for an exhaustive list of the tunable properties.\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::ConfigureProperties ()\n   {\n     TcpGeneralTest::ConfigureProperties ();\n     SetInitialCwnd (SENDER, 10);\n   }\n\nTo see the default value for the experiment, please see the implementation of\nboth methods inside TcpGeneralTest class.\n\n.. note::\n   If some configuration parameters are missing, add a method called\n   \"SetSomeValue\" which takes as input the value only (if it is meant to be\n   called inside ConfigureEnvironment) or the socket and the value (if it is\n   meant to be called inside ConfigureProperties).\n\nTo define a zero-window situation, we choose (by design) to initiate the connection\nwith a 0-byte rx buffer. This implies that the RECEIVER, in its first SYN-ACK,\nadvertises a zero window. This can be accomplished by implementing the method\nCreateReceiverSocket, setting an Rx buffer value of 0 bytes (at line 6 of the\nfollowing code):\n\n.. code-block:: c++\n   :linenos:\n   :emphasize-lines: 6,7,8\n\n   Ptr<TcpSocketMsgBase>\n   TcpZeroWindowTest::CreateReceiverSocket (Ptr<Node> node)\n   {\n     Ptr<TcpSocketMsgBase> socket = TcpGeneralTest::CreateReceiverSocket (node);\n\n     socket->SetAttribute(\"RcvBufSize\", UintegerValue (0));\n     Simulator::Schedule (Seconds (10.0),\n                          &TcpZeroWindowTest::IncreaseBufSize, this);\n\n     return socket;\n   }\n\nEven so, to check the active window update, we should schedule an increase\nof the buffer size. We do this at line 7 and 8, scheduling the function\nIncreaseBufSize.\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::IncreaseBufSize ()\n   {\n     SetRcvBufSize (RECEIVER, 2500);\n   }\n\nWhich utilizes the SetRcvBufSize method to edit the RxBuffer object of the\nRECEIVER. As said before, check the Doxygen documentation for class TcpGeneralTest\nto be aware of the various possibilities that it offers.\n\n.. note::\n   By design, we choose to maintain a close relationship between TcpSocketBase\n   and TcpGeneralTest: they are connected by a friendship relation. Since\n   friendship is not passed through inheritance, if one discovers that one\n   needs to access or to modify a private (or protected) member of TcpSocketBase,\n   one can do so by adding a method in the class TcpGeneralSocket. An example\n   of such method is SetRcvBufSize, which allows TcpGeneralSocket subclasses\n   to forcefully set the RxBuffer size.\n\n   .. code-block:: c++\n\n      void\n      TcpGeneralTest::SetRcvBufSize (SocketWho who, uint32_t size)\n      {\n        if (who == SENDER)\n          {\n            m_senderSocket->SetRcvBufSize (size);\n          }\n        else if (who == RECEIVER)\n          {\n            m_receiverSocket->SetRcvBufSize (size);\n          }\n        else\n          {\n            NS_FATAL_ERROR (\"Not defined\");\n          }\n      }\n\nNext, we can start to follow the TCP connection:\n\n#. At time 0.0 s the connection is opened sender side, with a SYN packet sent from\n   SENDER to RECEIVER\n#. At time 0.05 s the RECEIVER gets the SYN and replies with a SYN-ACK\n#. At time 0.10 s the SENDER gets the SYN-ACK and replies with a SYN.\n\nWhile the general structure is defined, and the connection is started,\nwe need to define a way to check the rWnd field on the segments. To this aim,\nwe can implement the methods Rx and Tx in the TcpGeneralTest subclass,\nchecking each time the actions of the RECEIVER and the SENDER. These methods are\ndefined in TcpGeneralTest, and they are attached to the Rx and Tx traces in the\nTcpSocketBase. One should write small tests for every detail that one wants to ensure during the\nconnection (it will prevent the test from changing over the time, and it ensures\nthat the behavior will stay consistent through releases). We start by ensuring that\nthe first SYN-ACK has 0 as advertised window size:\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::Tx(const Ptr<const Packet> p, const TcpHeader &h, SocketWho who)\n   {\n     ...\n     else if (who == RECEIVER)\n       {\n         NS_LOG_INFO (\"\\tRECEIVER TX \" << h << \" size \" << p->GetSize());\n\n         if (h.GetFlags () & TcpHeader::SYN)\n           {\n             NS_TEST_ASSERT_MSG_EQ (h.GetWindowSize(), 0,\n                                    \"RECEIVER window size is not 0 in the SYN-ACK\");\n           }\n       }\n       ....\n    }\n\nPratically, we are checking that every SYN packet sent by the RECEIVER has the\nadvertised window set to 0. The same thing is done also by checking, in the Rx\nmethod, that each SYN received by SENDER has the advertised window set to 0.\nThanks to the log subsystem, we can print what is happening through messages.\nIf we run the experiment, enabling the logging, we can see the following:\n\n.. code-block:: bash\n\n   ./waf shell\n   gdb --args ./build/utils/ns3-dev-test-runner-debug --test-name=tcp-zero-window-test --stop-on-failure --fullness=QUICK --assert-on-failure --verbose\n   (gdb) run\n\n   0.00s TcpZeroWindowTestSuite:Tx(): 0.00\tSENDER TX 49153 > 4477 [SYN] Seq=0 Ack=0 Win=32768 ns3::TcpOptionWinScale(2) ns3::TcpOptionTS(0;0) size 36\n   0.05s TcpZeroWindowTestSuite:Rx(): 0.05\tRECEIVER RX 49153 > 4477 [SYN] Seq=0 Ack=0 Win=32768 ns3::TcpOptionWinScale(2) ns3::TcpOptionTS(0;0) ns3::TcpOptionEnd(EOL) size 0\n   0.05s TcpZeroWindowTestSuite:Tx(): 0.05\tRECEIVER TX 4477 > 49153 [SYN|ACK] Seq=0 Ack=1 Win=0 ns3::TcpOptionWinScale(0) ns3::TcpOptionTS(50;0) size 36\n   0.10s TcpZeroWindowTestSuite:Rx(): 0.10\tSENDER RX 4477 > 49153 [SYN|ACK] Seq=0 Ack=1 Win=0 ns3::TcpOptionWinScale(0) ns3::TcpOptionTS(50;0) ns3::TcpOptionEnd(EOL) size 0\n   0.10s TcpZeroWindowTestSuite:Tx(): 0.10\tSENDER TX 49153 > 4477 [ACK] Seq=1 Ack=1 Win=32768 ns3::TcpOptionTS(100;50) size 32\n   0.15s TcpZeroWindowTestSuite:Rx(): 0.15\tRECEIVER RX 49153 > 4477 [ACK] Seq=1 Ack=1 Win=32768 ns3::TcpOptionTS(100;50) ns3::TcpOptionEnd(EOL) size 0\n   (...)\n\nThe output is cut to show the threeway handshake. As we can see from the headers,\nthe rWnd of RECEIVER is set to 0, and thankfully our tests are not failing.\nNow we need to test for the persistent timer, which should be started by\nthe SENDER after it receives the SYN-ACK. Since the Rx method is called before\nany computation on the received packet, we should utilize another method, namely\nProcessedAck, which is the method called after each processed ACK. In the\nfollowing, we show how to check if the persistent event is running after the\nprocessing of the SYN-ACK:\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::ProcessedAck (const Ptr<const TcpSocketState> tcb,\n                                    const TcpHeader& h, SocketWho who)\n   {\n     if (who == SENDER)\n       {\n         if (h.GetFlags () & TcpHeader::SYN)\n           {\n             EventId persistentEvent = GetPersistentEvent (SENDER);\n             NS_TEST_ASSERT_MSG_EQ (persistentEvent.IsRunning (), true,\n                                    \"Persistent event not started\");\n           }\n       }\n    }\n\nSince we programmed the increase of the buffer size after 10 simulated seconds,\nwe expect the persistent timer to fire before any rWnd changes. When it fires,\nthe SENDER should send a window probe, and the receiver should reply reporting\nagain a zero window situation. At first, we investigates on what the sender sends:\n\n..  code-block:: c++\n    :linenos:\n    :emphasize-lines: 1,6,7,11\n\n      if (Simulator::Now ().GetSeconds () <= 6.0)\n        {\n          NS_TEST_ASSERT_MSG_EQ (p->GetSize () - h.GetSerializedSize(), 0,\n                                 \"Data packet sent anyway\");\n        }\n      else if (Simulator::Now ().GetSeconds () > 6.0 &&\n               Simulator::Now ().GetSeconds () <= 7.0)\n        {\n          NS_TEST_ASSERT_MSG_EQ (m_zeroWindowProbe, false, \"Sent another probe\");\n\n          if (! m_zeroWindowProbe)\n            {\n              NS_TEST_ASSERT_MSG_EQ (p->GetSize () - h.GetSerializedSize(), 1,\n                                     \"Data packet sent instead of window probe\");\n              NS_TEST_ASSERT_MSG_EQ (h.GetSequenceNumber(), SequenceNumber32 (1),\n                                     \"Data packet sent instead of window probe\");\n              m_zeroWindowProbe = true;\n            }\n        }\n\nWe divide the events by simulated time. At line 1, we check everything that\nhappens before the 6.0 seconds mark; for instance, that no data packets are sent,\nand that the state remains OPEN for both sender and receiver.\n\nSince the persist timeout is initialized at 6 seconds (exercise left for the\nreader: edit the test, getting this value from the Attribute system), we need\nto check (line 6) between 6.0 and 7.0 simulated seconds that the probe is sent.\nOnly one probe is allowed, and this is the reason for the check at line 11.\n\n.. code-block:: c++\n   :linenos:\n   :emphasize-lines: 6,7\n\n   if (Simulator::Now ().GetSeconds () > 6.0 &&\n       Simulator::Now ().GetSeconds () <= 7.0)\n     {\n       NS_TEST_ASSERT_MSG_EQ (h.GetSequenceNumber(), SequenceNumber32 (1),\n                              \"Data packet sent instead of window probe\");\n       NS_TEST_ASSERT_MSG_EQ (h.GetWindowSize(), 0,\n                              \"No zero window advertised by RECEIVER\");\n     }\n\nFor the RECEIVER, the interval between 6 and 7 seconds is when the zero-window\nsegment is sent.\n\nOther checks are redundant; the safest approach is to deny any other packet\nexchange between the 7 and 10 seconds mark.\n\n.. code-block:: c++\n\n   else if (Simulator::Now ().GetSeconds () > 7.0 &&\n            Simulator::Now ().GetSeconds () < 10.0)\n     {\n       NS_FATAL_ERROR (\"No packets should be sent before the window update\");\n     }\n\nThe state checks are performed at the end of the methods, since they are valid\nin every condition:\n\n.. code-block:: c++\n\n   NS_TEST_ASSERT_MSG_EQ (GetCongStateFrom (GetTcb(SENDER)), TcpSocketState::CA_OPEN,\n                          \"Sender State is not OPEN\");\n   NS_TEST_ASSERT_MSG_EQ (GetCongStateFrom (GetTcb(RECEIVER)), TcpSocketState::CA_OPEN,\n                          \"Receiver State is not OPEN\");\n\nNow, the interesting part in the Tx method is to check that after the 10.0\nseconds mark (when the RECEIVER sends the active window update) the value of\nthe window should be greater than zero (and precisely, set to 2500):\n\n.. code-block:: c++\n\n   else if (Simulator::Now().GetSeconds() >= 10.0)\n     {\n       NS_TEST_ASSERT_MSG_EQ (h.GetWindowSize(), 2500,\n                              \"Receiver window not updated\");\n     }\n\nTo be sure that the sender receives the window update, we can use the Rx\nmethod:\n\n.. code-block:: c++\n   :linenos:\n   :emphasize-lines: 5\n\n   if (Simulator::Now().GetSeconds() >= 10.0)\n     {\n       NS_TEST_ASSERT_MSG_EQ (h.GetWindowSize(), 2500,\n                              \"Receiver window not updated\");\n       m_windowUpdated = true;\n     }\n\nWe check every packet after the 10 seconds mark to see if it has the\nwindow updated. At line 5, we also set to true a boolean variable, to check\nthat we effectively reach this test.\n\nLast but not least, we implement also the NormalClose() method, to check that\nthe connection ends with a success:\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::NormalClose (SocketWho who)\n   {\n     if (who == SENDER)\n       {\n         m_senderFinished = true;\n       }\n     else if (who == RECEIVER)\n       {\n         m_receiverFinished = true;\n       }\n   }\n\nThe method is called only if all bytes are transmitted successfully. Then, in\nthe method FinalChecks(), we check all variables, which should be true (which\nindicates that we have perfectly closed the connection).\n\n.. code-block:: c++\n\n   void\n   TcpZeroWindowTest::FinalChecks ()\n   {\n     NS_TEST_ASSERT_MSG_EQ (m_zeroWindowProbe, true,\n                            \"Zero window probe not sent\");\n     NS_TEST_ASSERT_MSG_EQ (m_windowUpdated, true,\n                            \"Window has not updated during the connection\");\n     NS_TEST_ASSERT_MSG_EQ (m_senderFinished, true,\n                            \"Connection not closed successfully (SENDER)\");\n     NS_TEST_ASSERT_MSG_EQ (m_receiverFinished, true,\n                            \"Connection not closed successfully (RECEIVER)\");\n   }\n\nTo run the test, the usual way is\n\n.. code-block:: bash\n\n   ./test.py -s tcp-zero-window-test\n\n   PASS: TestSuite tcp-zero-window-test\n   1 of 1 tests passed (1 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)\n\nTo see INFO messages, use a combination of ./waf shell and gdb (really useful):\n\n.. code-block:: bash\n\n\n    ./waf shell && gdb --args ./build/utils/ns3-dev-test-runner-debug --test-name=tcp-zero-window-test --stop-on-failure --fullness=QUICK --assert-on-failure --verbose\n\nand then, hit \"Run\".\n\n.. note::\n   This code magically runs without any reported errors; however, in real cases,\n   when you discover a bug you should expect the existing test to fail (this\n   could indicate a well-written test and a bad-writted model, or a bad-written\n   test; hopefully the first situation). Correcting bugs is an iterative\n   process. For instance, commits created to make this test case running without\n   errors are 11633:6b74df04cf44, (others to be merged).\n\nNetwork Simulation Cradle\n*************************\n\nThe `Network Simulation Cradle (NSC) <http://www.wand.net.nz/~stj2/nsc/>`_ is a\nframework for wrapping real-world network code into simulators, allowing\nsimulation of real-world behavior at little extra cost. This work has been\nvalidated by comparing situations using a test network with the same situations\nin the simulator. To date, it has been shown that the NSC is able to produce\nextremely accurate results.  NSC supports four real world stacks: FreeBSD,\nOpenBSD, lwIP and Linux. Emphasis has been placed on not changing any of the\nnetwork stacks by hand. Not a single line of code has been changed in the\nnetwork protocol implementations of any of the above four stacks. However, a\ncustom C parser was built to programmatically change source code.\n\nNSC has previously been ported to |ns2| and OMNeT++, and was \nwas added to |ns3| in September 2008 (ns-3.2 release).  This section \ndescribes the |ns3| port of NSC and how to use it.\n\nNSC has been obsoleted by the Linux kernel support within \n`Direct Code Execution (DCE) <http://www.nsnam.org/docs/dce/manual/singlehtml/index.html>`__.  However, NSC is still available through the bake build\nsystem.  NSC supports Linux kernels 2.6.18 and 2.6.26, and an experimental\nversion of 2.6.29 exists on ns-3's code server\n(http://code.nsnam.org/fw/nsc-linux-2.6.29/), but newer\nversions of the kernel have not been ported.  \n\nPrerequisites\n+++++++++++++\n\nPresently, NSC has been tested and shown to work on these platforms:\nLinux i386 and Linux x86-64.  NSC does not support powerpc.  Use on\nFreeBSD or OS X is unsupported (although it may be able to work).\n\nBuilding NSC requires the packages flex and bison.  \n\nNSC requires use of gcc-4.9 or gcc-5 series, and will not build on \nnewer systems lacking the older compilers.\n\nConfiguring and Downloading\n+++++++++++++++++++++++++++\n\nNSC must either be downloaded separately from\nits own repository, or downloading when using the \n`bake build system <http://www.nsnam.org/docs/tutorial/html/getting-started.html#downloading-ns3-using-bake>`_ of \n|ns3|.  \n\nFor ns-3.17 through ns-3.28 releases, when using bake, one obtains NSC implicitly as part of an \"allinone\" configuration, such as:\n\n.. sourcecode:: bash\n\n  $ cd bake\n  $ python bake.py configure -e ns-allinone-3.27\n  $ python bake.py download\n  $ python bake.py build\n\nFor ns-3.29 and later versions, including the 'ns-3-allinone' development\nversion, one must explicitly add NSC ('nsc-0.5.3') to the bake configuration, \nsuch as:\n\n.. sourcecode:: bash\n\n  $ cd bake\n  $ python bake.py configure -e ns-allinone-3.29 -e nsc-0.5.3\n  $ python bake.py download\n  $ python bake.py build\n\nInstead of a released version, one may use the ns-3 development version\nby specifying \"ns-3-allinone\" to the configure step above.\n\nNSC may also be downloaded from \n`its download site <http://research.wand.net.nz/software/nsc.php>`_ \nusing Mercurial:\n\n.. sourcecode:: bash\n\n  $ hg clone https://secure.wand.net.nz/mercurial/nsc\n\nPrior to the ns-3.17 release, NSC was included in the allinone tarball and\nthe released version did not need to be separately downloaded.\n\nBuilding and validating\n+++++++++++++++++++++++\n\nNSC may be built as part of the bake build process; alternatively, one\nmay build NSC by itself using its build system; e.g.:\n\n.. sourcecode:: bash\n\n  $ cd nsc-dev\n  $ python scons.py\n\nOnce NSC has been built either manually or through the bake system, change\ninto the |ns3| source directory and try running the following configuration:\n\n.. sourcecode:: bash\n\n  $ ./waf configure\n\nIf NSC has been previously built and found by waf, then you will see:\n\n.. sourcecode:: bash\n\n  Network Simulation Cradle     : enabled\n\nIf NSC has not been found, you will see:\n\n.. sourcecode:: bash\n\n  Network Simulation Cradle     : not enabled (NSC not found (see option --with-nsc))\n\nIn this case, you must pass the relative or absolute path to the NSC libraries\nwith the \"--with-nsc\" configure option; e.g.\n\n.. sourcecode:: bash\n\n  $ ./waf configure --with-nsc=/path/to/my/nsc/directory\n\nFor |ns3| releases prior to the ns-3.17 release, using the ``build.py`` \nscript in ns-3-allinone directory, NSC will be built by default unless the \nplatform does not support it. To explicitly disable it when building |ns3|, \ntype:\n\n.. sourcecode:: bash\n\n  $ ./waf configure --enable-examples --enable-tests --disable-nsc\n\nIf waf detects NSC, then building |ns3| with NSC is performed the same way\nwith waf as without it.  Once |ns3| is built, try running the following \ntest suite:\n\n.. sourcecode:: bash\n\n    $ ./test.py -s ns3-tcp-interoperability\n\nIf NSC has been successfully built, the following test should show up \nin the results:\n\n.. sourcecode:: text\n\n    PASS TestSuite ns3-tcp-interoperability\n\nThis confirms that NSC is ready to use.\n\nUsage\n+++++\n\nThere are a few example files.  Try:\n\n.. sourcecode:: bash\n\n    $ ./waf --run tcp-nsc-zoo\n    $ ./waf --run tcp-nsc-lfn\n\nThese examples will deposit some ``.pcap`` files in your directory,\nwhich can be examined by tcpdump or wireshark.\n\nLet's look at the ``examples/tcp/tcp-nsc-zoo.cc`` file for some typical\nusage. How does it differ from using native |ns3| TCP? There is one main\nconfiguration line, when using NSC and the |ns3| helper API, that needs to be\nset::\n\n  InternetStackHelper internetStack;\n\n  internetStack.SetNscStack (\"liblinux2.6.26.so\");\n  // this switches nodes 0 and 1 to NSCs Linux 2.6.26 stack.\n  internetStack.Install (n.Get(0));\n  internetStack.Install (n.Get(1));\n\n\nThe key line is the ``SetNscStack``.  This tells the InternetStack\nhelper to aggregate instances of NSC TCP instead of native |ns3| TCP\nto the remaining nodes.  It is important that this function be called\n**before** calling the ``Install()`` function, as shown above.\n\nWhich stacks are available to use? Presently, the focus has been on\nLinux 2.6.18 and Linux 2.6.26 stacks for |ns3|. To see which stacks\nwere built, one can execute the following find command at the |ns3| top level\ndirectory:\n\n.. sourcecode:: bash\n\n    $ find nsc -name \"*.so\" -type f \n    nsc/linux-2.6.18/liblinux2.6.18.so\n    nsc/linux-2.6.26/liblinux2.6.26.so\n\nThis tells us that we may either pass the library name liblinux2.6.18.so or\nliblinux2.6.26.so to the above configuration step.\n\nStack configuration\n+++++++++++++++++++\n\nNSC TCP shares the same configuration attributes that are common across TCP\nsockets, as described above and documented in `Doxygen\n<http://www.nsnam.org/doxygen/classns3_1_1_tcp_socket.html>`_\n\nAdditionally, NSC TCP exports a lot of configuration variables into the \n|ns3| attributes system, via a `sysctl <http://en.wikipedia.org/wiki/Sysctl>`_-like interface. In the ``examples/tcp/tcp-nsc-zoo`` example, you\ncan see the following configuration::\n\n\n  // this disables TCP SACK, wscale and timestamps on node 1 (the attributes \n    represent sysctl-values).\n  Config::Set (\"/NodeList/1/$ns3::Ns3NscStack<linux2.6.26>/net.ipv4.tcp_sack\", \n    StringValue (\"0\"));\n  Config::Set (\"/NodeList/1/$ns3::Ns3NscStack<linux2.6.26>/net.ipv4.tcp_timestamps\", \n  StringValue (\"0\"));\n  Config::Set (\"/NodeList/1/$ns3::Ns3NscStack<linux2.6.26>/net.ipv4.tcp_window_scaling\", \n  StringValue (\"0\"));\n\nThese additional configuration variables are not available to native |ns3| TCP.\n\nAlso note that default values for TCP attributes in |ns3| TCP may differ from the nsc TCP implementation.  Specifically in |ns3|:\n\n  1) TCP default MSS is 536\n  2) TCP Delayed Ack count is 2 \n\t\t\nTherefore when making comparisons between results obtained using nsc and |ns3| TCP, care must be taken to ensure these values are set appropriately.  See /examples/tcp/tcp-nsc-comparision.cc for an example.\n\nNSC API\n+++++++\n\nThis subsection describes the API that NSC presents to |ns3| or any other\nsimulator. NSC provides its API in the form of a number of classes that are\ndefined in ``sim/sim_interface.h`` in the nsc directory.\n\n* **INetStack** INetStack contains the 'low level' operations for the operating\n  system network stack, e.g. in and output functions from and to the network\n  stack (think of this as the 'network driver interface'. There are also\n  functions to create new TCP or UDP sockets.\n* **ISendCallback** This is called by NSC when a packet should be sent out to\n  the network. This simulator should use this callback to re-inject the packet\n  into the simulator so the actual data can be delivered/routed to its\n  destination, where it will eventually be handed into Receive() (and eventually\n  back to the receivers NSC instance via INetStack->if_receive() ).\n* **INetStreamSocket** This is the structure defining a particular connection\n  endpoint (file descriptor). It contains methods to operate on this endpoint,\n  e.g. connect, disconnect, accept, listen, send_data/read_data, ...\n* **IInterruptCallback** This contains the wakeup callback, which is called by\n  NSC whenever something of interest happens. Think of wakeup() as a replacement\n  of the operating systems wakeup function: Whenever the operating system would\n  wake up a process that has been waiting for an operation to complete (for\n  example the TCP handshake during connect()), NSC invokes the wakeup() callback\n  to allow the simulator to check for state changes in its connection endpoints. \n\nns-3 implementation\n+++++++++++++++++++\n\nThe |ns3| implementation makes use of the above NSC API, and is implemented as\nfollows.\n\nThe three main parts are:\n\n* :cpp:class:`ns3::NscTcpL4Protocol`:  a subclass of Ipv4L4Protocol (and two nsc\n  classes: ISendCallback and IInterruptCallback)\n* :cpp:class:`ns3::NscTcpSocketImpl`: a subclass of TcpSocket \n* :cpp:class:`ns3::NscTcpSocketFactoryImpl`:  a factory to create new NSC\n  sockets\n\n``src/internet/model/nsc-tcp-l4-protocol`` is the main class. Upon\nInitialization, it loads an nsc network stack to use (via dlopen()). Each\ninstance of this class may use a different stack. The stack (=shared library) to\nuse is set using the SetNscLibrary() method (at this time its called indirectly\nvia the internet stack helper). The nsc stack is then set up accordingly (timers\netc). The NscTcpL4Protocol::Receive() function hands the packet it receives\n(must be a complete tcp/ip packet) to the nsc stack for further processing.  To\nbe able to send packets, this class implements the nsc send_callback method.\nThis method is called by nsc whenever the nsc stack wishes to send a packet out\nto the network. Its arguments are a raw buffer, containing a complete TCP/IP\npacket, and a length value. This method therefore has to convert the raw data to\na Ptr<Packet> usable by |ns3|. In order to avoid various ipv4 header issues,\nthe nsc ip header is not included. Instead, the tcp header and the actual\npayload are put into the Ptr<Packet>, after this the Packet is passed down to\nlayer 3 for sending the packet out (no further special treatment is needed in\nthe send code path).\n\nThis class calls ``ns3::NscTcpSocketImpl`` both from the nsc wakeup() callback\nand from the Receive path (to ensure that possibly queued data is scheduled for\nsending).\n\n``src/internet/model/nsc-tcp-socket-impl`` implements the nsc socket interface.\nEach instance has its own nscTcpSocket. Data that is Send() will be handed to\nthe nsc stack via m_nscTcpSocket->send_data(). (and not to nsc-tcp-l4, this is\nthe major difference compared to |ns3| TCP). The class also queues up data that\nis Send() before the underlying descriptor has entered an ESTABLISHED state.\nThis class is called from the nsc-tcp-l4 class, when the nsc-tcp-l4 wakeup()\ncallback is invoked by nsc. nsc-tcp-socket-impl then checks the current\nconnection state (SYN_SENT, ESTABLISHED, LISTEN...) and schedules appropriate\ncallbacks as needed, e.g. a LISTEN socket will schedule Accept to see if a new\nconnection must be accepted, an ESTABLISHED socket schedules any pending data\nfor writing, schedule a read callback, etc.\n\nNote that ``ns3::NscTcpSocketImpl`` does not interact with nsc-tcp directly:\ninstead, data is redirected to nsc. nsc-tcp calls the nsc-tcp-sockets of a node\nwhen its wakeup callback is invoked by nsc. \n\nLimitations\n+++++++++++\n\n* NSC only works on single-interface nodes; attempting to run it on a\n  multi-interface node will cause a program error.  \n* Cygwin and OS X PPC are not supported; OS X Intel is not supported but may work\n* The non-Linux stacks of NSC are not supported in |ns3|\n* Not all socket API callbacks are supported\n\nFor more information, see `this wiki page <http://www.nsnam.org/wiki/Network_Simulation_Cradle_Integration>`_.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/applications/doc/http-parsing-time.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/applications/doc/http-embedded-object-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/applications/doc/http-main-object-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/applications/doc/http-reading-time.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/applications/doc/http-num-of-embedded-objects.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/animation-dumbbell.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NodeCountersTable.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/PacketStatistics.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NodeCountersChart.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NetAnim_3_105.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/Precision.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/Trajectory.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/PacketStatistics.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NetAnim_3_105.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/Trajectory.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/PacketTimeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NodeCountersChart.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/RoutingTables.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/Precision.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/PacketTimeline.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/RoutingTables.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/netanim/doc/figures/NodeCountersTable.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/test/reference/lte-mcs-index.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/test/reference/lte-mcs-index.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-soft-frequency-reuse-scheme-v1.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-legacy-handover-algorithm.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-ue-data-plane.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-test-example-ul.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-reconfiguration-handover.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-dl-power-control.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-full-frequency-reuse-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-harq-architecture.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_29_29.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ff-mac-saps.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-test-example-dl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-cell-selection-timeline.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/mac-random-access-noncontention.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-1-rem.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-procedures-after-rlf.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-impact.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-rlc-data-txon-ul.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_vehicular.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-enhanced-fractional-frequency-reuse-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-downlink-bsr.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-rlc-data-txon-dl.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-arch-enb-data.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-enb-ctrl-plane.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_1_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-legacy-handover-algorithm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-arch-enb-ctrl-rrc-phy.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-handover-campaign-rem.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ffr-scheduling.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-enb-rrc-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_urban_3kmph.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-uplink-bsr.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-context-removal-from-enb-stack.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_25_28.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_25_28.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ffr-soft-2-spectrum-trace.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-mac-impact.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-2-rem.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-handover-target-scenario.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-enb-cphy-sap.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-epc-x2-interface.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_5_8.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-test-example-dl.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-context-removal-from-enb-stack.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-rrc-states.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-handover-algorithm.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_1_4.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-reconfiguration-handover.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-2-rem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-soft-1-rem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-uplink-bsr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lena-radio-link-failure-two-enb.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lena-radio-link-failure-two-enb-thrput.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/miesm_scheme.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_16_test.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-enb-phy.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-arch-enb-ctrl.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-reconfiguration.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-handover-algorithm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ccs-arch.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_12_test.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-data-flow-ul.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-context-removal-from-epc.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-3-rem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-3-rem.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-strict-frequency-reuse-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ffr-distributed-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_5_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ue-meas-consumer.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-ctrl-arch.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-topology.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_9_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-procedures-after-rlf.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-mac-impact.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_21_24.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-profiling-scenario.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-ue-ctrl-plane.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/helpers.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-phy.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_pedestrian.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-soft-fractional-frequency-reuse-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ffr-soft-2-spectrum-trace.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-rlc-data-retx-dl.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-test-rlf-one-enb.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-arch-ue-ctrl.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/CarrierAggregationUlTxOpportunity.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_vehicular.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ue-meas-piecewise-motion.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-hard-1-rem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-epc-x2-entity-saps.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/nas-attach.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_29_29.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_9_12.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_13_16.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-impact.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-enb-rrc-states.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-cell-selection-scenario.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-handover-campaign-rem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_17_20.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/setupRadioBearerCarrierAggregation.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_21_24.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-harq-processes-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/CarrierAggregationDownlinkDataPlane.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-rrc-messages.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-establishment.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-epc-e2e-data-protocol-stack.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/miesm_scheme.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-setup-radio-bearer.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-class-net-phy-relation.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/mac-random-access-contention.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-establishment.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_pedestrian.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lena-radio-link-failure-one-enb-thrput.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/rrc-connection-reconfiguration.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lena-radio-link-failure-one-enb.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-data-flow-dl.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ff-example.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-rrc-reconf.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_2_test.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-context-removal-from-epc.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/nas-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-epc-x2-handover-seq-diagram.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_16_test.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/eutran-profiling-scenario.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-lte-ue-net-device-changes.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-fr-soft-1-rem.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-phy-interference.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-lte-enb-net-device-changes.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fading_urban_3kmph.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-interference-test-scenario.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/mac-random-access-noncontention.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-setup-radio-bearer.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-rlc-data-retx-ul.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/mac-random-access-contention.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_13_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-test-rlf-two-enb.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/helpers.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-downlink-bsr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_17_20.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-ue-rrc-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-impact.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-soft-frequency-reuse-scheme-v2.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/epc-topology-x2-enhanced.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ue-meas-piecewise-a1-hys.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-net-phy-relation.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/carrier-aggregation-mac-impact.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-arch-ue-data.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-test-example-ul.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ca-enb-data-plane.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/fr-hard-frequency-reuse-scheme.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-rlc-implementation-model.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/lte-phy-interference.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_12_test.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/ue-meas-piecewise-a1.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lte/doc/source/figures/MCS_2_test.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/network/test/known.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/network/doc/packet.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/network/doc/sockets-overview.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/network/doc/node.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/internet-node-recv.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/routing.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/internet-node-send.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/routing-specialization.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/internet/doc/figures/tcp-state-machine.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/spectrum/doc/spectrum-tv-8vsb.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/spectrum/doc/spectrum-tv-cofdm.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/spectrum/doc/spectrum-channel-phy-interface.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/spectrum/doc/spectrum-channel-phy-interface.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/wifi/doc/source/figures/snir.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/wifi/doc/source/figures/WifiArchitecture.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/uan/doc/auvmobility-classes.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/aodv-chain-regression-test-3-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/bug-606-test-0-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/aodv-chain-regression-test-4-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/aodv-chain-regression-test-0-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/aodv-chain-regression-test-1-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/bug-606-test-1-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/bug-606-test-2-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/aodv/test/aodv-chain-regression-test-2-0.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-Westwood4-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state6-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state0-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-WestwoodPlus4-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state7-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state2-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-Westwood1-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-Westwood3-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-WestwoodPlus0-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-interop-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-NewReno4-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state3-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-NewReno0-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state8-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-WestwoodPlus2-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-NewReno2-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state1-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state4-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-Westwood2-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-Westwood0-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-state5-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-NewReno3-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-WestwoodPlus1-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-NewReno1-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/test/ns3tcp/response-vectors/ns3tcp-loss-WestwoodPlus3-response-vectors.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lr-wpan/doc/lr-wpan-arch.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lr-wpan/doc/lr-wpan-data-example.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/lr-wpan/doc/lr-wpan-primitives.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/antenna/doc/source/figures/antenna-coordinate-system.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/pmp-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-4-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/pmp-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-proactive-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-target-flags-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-target-flags-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-target-flags-regression-test-2-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-3-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-proactive-regression-test-2-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-proactive-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-target-flags-regression-test-3-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-proactive-regression-test-3-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-simplest-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-proactive-regression-test-4-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-simplest-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-5-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/dot11s/hwmp-reactive-regression-test-2-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/flame/flame-regression-test-1-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/flame/flame-regression-test-2-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/test/flame/flame-regression-test-0-1.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/mesh/doc/MeshArchitecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/Wifi-default.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/gnuplot-helper-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/dcf-overview.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/gnuplot-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/file-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/gnuplot-aggregator.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/seventh-packet-byte-count.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/Stat-framework-arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/stats/doc/dcf-overview-with-aggregation.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/wimax/doc/WimaxArchitecture.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/traffic-control/doc/classful-queue-disc.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/src/traffic-control/doc/multi-queue-aware-queue-disc.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/namespace-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/bar-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/ns-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/ver.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/menu-bgr-400.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/ns3_html_theme/static/ns-3-inverted-notext-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/star.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/helpers.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/cwnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/pp.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/oneobj.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/dumbbell.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial/figures/threeobj.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/models/figures/emulated-channel.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/models/figures/testbed.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/manual/figures/software-organization.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/manual/figures/plot-2d.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/manual/figures/plot-2d-with-error-bars.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/manual/figures/plot-3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/star.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/helpers.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/cwnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/pp.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/oneobj.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/dumbbell.dia",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/figures/threeobj.png",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/getting-started.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/tracing.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/tweaking.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/resources.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/conceptual-overview.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/building-topologies.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/conclusion.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/index.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/source/introduction.rst",
        "/tmp/vanessa/spack-stage/spack-stage-ns-3-dev-3.30-l5moelo4qpjtcjen5f6enebaw7mnsnqx/spack-src/doc/tutorial-pt-br/locale/language/LC_MESSAGES/sphinx.mo"
    ],
    "total_files": 3339
}