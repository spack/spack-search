{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Help/variable/CMAKE_DL_LIBS.rst": "CMAKE_DL_LIBS\n-------------\n\nName of library containing dlopen and dlcose.\n\nThe name of the library that has dlopen and dlclose in it, usually\n-ldl on most UNIX machines.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Help/command/add_library.rst": "add_library\n-----------\n\n.. only:: html\n\n   .. contents::\n\nAdd a library to the project using the specified source files.\n\nNormal Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> [STATIC | SHARED | MODULE]\n              [EXCLUDE_FROM_ALL]\n              source1 [source2 ...])\n\nAdds a library target called ``<name>`` to be built from the source files\nlisted in the command invocation.  The ``<name>`` corresponds to the\nlogical target name and must be globally unique within a project.  The\nactual file name of the library built is constructed based on\nconventions of the native platform (such as ``lib<name>.a`` or\n``<name>.lib``).\n\n``STATIC``, ``SHARED``, or ``MODULE`` may be given to specify the type of\nlibrary to be created.  ``STATIC`` libraries are archives of object files\nfor use when linking other targets.  ``SHARED`` libraries are linked\ndynamically and loaded at runtime.  ``MODULE`` libraries are plugins that\nare not linked into other targets but may be loaded dynamically at runtime\nusing dlopen-like functionality.  If no type is given explicitly the\ntype is ``STATIC`` or ``SHARED`` based on whether the current value of the\nvariable :variable:`BUILD_SHARED_LIBS` is ``ON``.  For ``SHARED`` and\n``MODULE`` libraries the :prop_tgt:`POSITION_INDEPENDENT_CODE` target\nproperty is set to ``ON`` automatically.\n\nBy default the library file will be created in the build tree directory\ncorresponding to the source tree directory in which the command was\ninvoked.  See documentation of the :prop_tgt:`ARCHIVE_OUTPUT_DIRECTORY`,\n:prop_tgt:`LIBRARY_OUTPUT_DIRECTORY`, and\n:prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` target properties to change this\nlocation.  See documentation of the :prop_tgt:`OUTPUT_NAME` target\nproperty to change the ``<name>`` part of the final file name.\n\nIf ``EXCLUDE_FROM_ALL`` is given the corresponding property will be set on\nthe created target.  See documentation of the :prop_tgt:`EXCLUDE_FROM_ALL`\ntarget property for details.\n\nSource arguments to ``add_library`` may use \"generator expressions\" with\nthe syntax ``$<...>``.  See the :manual:`cmake-generator-expressions(7)`\nmanual for available expressions.  See the :manual:`cmake-buildsystem(7)`\nmanual for more on defining buildsystem properties.\n\nImported Libraries\n^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> <SHARED|STATIC|MODULE|UNKNOWN> IMPORTED\n              [GLOBAL])\n\nAn :ref:`IMPORTED library target <Imported Targets>` references a library\nfile located outside the project.  No rules are generated to build it, and\nthe :prop_tgt:`IMPORTED` target property is ``True``.  The target name has\nscope in the directory in which it is created and below, but the ``GLOBAL``\noption extends visibility.  It may be referenced like any target built\nwithin the project.  ``IMPORTED`` libraries are useful for convenient\nreference from commands like :command:`target_link_libraries`.  Details\nabout the imported library are specified by setting properties whose names\nbegin in ``IMPORTED_`` and ``INTERFACE_``.  The most important such\nproperty is :prop_tgt:`IMPORTED_LOCATION` (and its per-configuration\nvariant :prop_tgt:`IMPORTED_LOCATION_<CONFIG>`) which specifies the\nlocation of the main library file on disk.  See documentation of the\n``IMPORTED_*`` and ``INTERFACE_*`` properties for more information.\n\nObject Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> OBJECT <src>...)\n\nCreates an :ref:`Object Library <Object Libraries>`.  An object library\ncompiles source files but does not archive or link their object files into a\nlibrary.  Instead other targets created by :command:`add_library` or\n:command:`add_executable` may reference the objects using an expression of the\nform ``$<TARGET_OBJECTS:objlib>`` as a source, where ``objlib`` is the\nobject library name.  For example:\n\n.. code-block:: cmake\n\n  add_library(... $<TARGET_OBJECTS:objlib> ...)\n  add_executable(... $<TARGET_OBJECTS:objlib> ...)\n\nwill include objlib's object files in a library and an executable\nalong with those compiled from their own sources.  Object libraries\nmay contain only sources that compile, header files, and other files\nthat would not affect linking of a normal library (e.g. ``.txt``).\nThey may contain custom commands generating such sources, but not\n``PRE_BUILD``, ``PRE_LINK``, or ``POST_BUILD`` commands.  Object libraries\ncannot be imported, exported, installed, or linked.  Some native build\nsystems may not like targets that have only object files, so consider\nadding at least one real source file to any target that references\n``$<TARGET_OBJECTS:objlib>``.\n\nAlias Libraries\n^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> ALIAS <target>)\n\nCreates an :ref:`Alias Target <Alias Targets>`, such that ``<name>`` can be\nused to refer to ``<target>`` in subsequent commands.  The ``<name>`` does\nnot appear in the generatedbuildsystem as a make target.  The ``<target>``\nmay not be an :ref:`Imported Target <Imported Targets>` or an ``ALIAS``.\n``ALIAS`` targets can be used as linkable targets and as targets to\nread properties from.  They can also be tested for existance with the\nregular :command:`if(TARGET)` subcommand.  The ``<name>`` may not be used\nto modify properties of ``<target>``, that is, it may not be used as the\noperand of :command:`set_property`, :command:`set_target_properties`,\n:command:`target_link_libraries` etc.  An ``ALIAS`` target may not be\ninstalled or exported.\n\nInterface Libraries\n^^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n\nCreates an :ref:`Interface Library <Interface Libraries>`.  An ``INTERFACE``\nlibrary target does not directly create build output, though it may\nhave properties set on it and it may be installed, exported and\nimported. Typically the ``INTERFACE_*`` properties are populated on\nthe interface target using the commands:\n\n* :command:`set_property`,\n* :command:`target_link_libraries(INTERFACE)`,\n* :command:`target_include_directories(INTERFACE)`,\n* :command:`target_compile_options(INTERFACE)`,\n* :command:`target_compile_definitions(INTERFACE)`, and\n* :command:`target_sources(INTERFACE)`,\n\nand then it is used as an argument to :command:`target_link_libraries`\nlike any other target.\n\nAn ``INTERFACE`` :ref:`Imported Target <Imported Targets>` may also be\ncreated with this signature.  An ``IMPORTED`` library target references a\nlibrary defined outside the project.  The target name has scope in the\ndirectory in which it is created and below, but the ``GLOBAL`` option\nextends visibility.  It may be referenced like any target built within\nthe project.  ``IMPORTED`` libraries are useful for convenient reference\nfrom commands like :command:`target_link_libraries`.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/BundleUtilities/testbundleutils1.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module1.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module1\\n\");\n  }\n#else\n  void* lib = dlopen(\"module1.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module1\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/BundleUtilities/testbundleutils2.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module2.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module2\\n\");\n  }\n#else\n  void* lib = dlopen(\"module2.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module2\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/BundleUtilities/testbundleutils3.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module3.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module3\\n\");\n  }\n#else\n  void* lib = dlopen(\"module3.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module3\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/config.h.in": "/* lib/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* when building libcurl itself */\n#cmakedefine BUILDING_LIBCURL ${BUILDING_LIBCURL}\n\n/* to disable cookies support */\n#cmakedefine CURL_DISABLE_COOKIES ${CURL_DISABLE_COOKIES}\n\n/* to disable cryptographic authentication */\n#cmakedefine CURL_DISABLE_CRYPTO_AUTH ${CURL_DISABLE_CRYPTO_AUTH}\n\n/* to disable DICT */\n#cmakedefine CURL_DISABLE_DICT ${CURL_DISABLE_DICT}\n\n/* to disable FILE */\n#cmakedefine CURL_DISABLE_FILE ${CURL_DISABLE_FILE}\n\n/* to disable FTP */\n#cmakedefine CURL_DISABLE_FTP ${CURL_DISABLE_FTP}\n\n/* to disable HTTP */\n#cmakedefine CURL_DISABLE_HTTP ${CURL_DISABLE_HTTP}\n\n/* to disable LDAP */\n#cmakedefine CURL_DISABLE_LDAP ${CURL_DISABLE_LDAP}\n\n/* to disable TELNET */\n#cmakedefine CURL_DISABLE_TELNET ${CURL_DISABLE_TELNET}\n\n/* to disable TFTP */\n#cmakedefine CURL_DISABLE_TFTP ${CURL_DISABLE_TFTP}\n\n/* to disable verbose strings */\n#cmakedefine CURL_DISABLE_VERBOSE_STRINGS ${CURL_DISABLE_VERBOSE_STRINGS}\n\n/* to make a symbol visible */\n#cmakedefine CURL_EXTERN_SYMBOL ${CURL_EXTERN_SYMBOL}\n\n/* to enable hidden symbols */\n#cmakedefine CURL_HIDDEN_SYMBOLS ${CURL_HIDDEN_SYMBOLS}\n\n/* when not building a shared library */\n#cmakedefine CURL_STATICLIB ${CURL_STATICLIB}\n\n/* Set to explicitly specify we don't want to use thread-safe functions */\n#cmakedefine DISABLED_THREADSAFE ${DISABLED_THREADSAFE}\n\n/* lber dynamic library file */\n#cmakedefine DL_LBER_FILE ${DL_LBER_FILE}\n\n/* ldap dynamic library file */\n#cmakedefine DL_LDAP_FILE ${DL_LDAP_FILE}\n\n/* your Entropy Gathering Daemon socket pathname */\n#cmakedefine EGD_SOCKET ${EGD_SOCKET}\n\n/* Define if you want to enable IPv6 support */\n#cmakedefine ENABLE_IPV6 ${ENABLE_IPV6}\n\n/* Define to the type qualifier of arg 1 for getnameinfo. */\n#cmakedefine GETNAMEINFO_QUAL_ARG1 ${GETNAMEINFO_QUAL_ARG1}\n\n/* Define to the type of arg 1 for getnameinfo. */\n#cmakedefine GETNAMEINFO_TYPE_ARG1 ${GETNAMEINFO_TYPE_ARG1}\n\n/* Define to the type of arg 2 for getnameinfo. */\n#cmakedefine GETNAMEINFO_TYPE_ARG2 ${GETNAMEINFO_TYPE_ARG2}\n\n/* Define to the type of args 4 and 6 for getnameinfo. */\n#cmakedefine GETNAMEINFO_TYPE_ARG46 ${GETNAMEINFO_TYPE_ARG46}\n\n/* Define to the type of arg 7 for getnameinfo. */\n#cmakedefine GETNAMEINFO_TYPE_ARG7 ${GETNAMEINFO_TYPE_ARG7}\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#cmakedefine HAVE_ALLOCA_H ${HAVE_ALLOCA_H}\n\n/* Define to 1 if you have the <arpa/inet.h> header file. */\n#cmakedefine HAVE_ARPA_INET_H ${HAVE_ARPA_INET_H}\n\n/* Define to 1 if you have the <arpa/tftp.h> header file. */\n#cmakedefine HAVE_ARPA_TFTP_H ${HAVE_ARPA_TFTP_H}\n\n/* Define to 1 if you have the <assert.h> header file. */\n#cmakedefine HAVE_ASSERT_H ${HAVE_ASSERT_H}\n\n/* Define to 1 if you have the `basename' function. */\n#cmakedefine HAVE_BASENAME ${HAVE_BASENAME}\n\n/* Define to 1 if you have the `closesocket' function. */\n#cmakedefine HAVE_CLOSESOCKET ${HAVE_CLOSESOCKET}\n\n/* Define to 1 if you have the `CRYPTO_cleanup_all_ex_data' function. */\n#cmakedefine HAVE_CRYPTO_CLEANUP_ALL_EX_DATA ${HAVE_CRYPTO_CLEANUP_ALL_EX_DATA}\n\n/* Define to 1 if you have the <crypto.h> header file. */\n#cmakedefine HAVE_CRYPTO_H ${HAVE_CRYPTO_H}\n\n/* Define to 1 if you have the <des.h> header file. */\n#cmakedefine HAVE_DES_H ${HAVE_DES_H}\n\n/* disabled non-blocking sockets */\n#cmakedefine HAVE_DISABLED_NONBLOCKING ${HAVE_DISABLED_NONBLOCKING}\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#cmakedefine HAVE_DLFCN_H ${HAVE_DLFCN_H}\n\n/* Define to 1 if you have the `dlopen' function. */\n#cmakedefine HAVE_DLOPEN ${HAVE_DLOPEN}\n\n/* Define to 1 if you have the `ENGINE_load_builtin_engines' function. */\n#cmakedefine HAVE_ENGINE_LOAD_BUILTIN_ENGINES ${HAVE_ENGINE_LOAD_BUILTIN_ENGINES}\n\n/* Define to 1 if you have the <errno.h> header file. */\n#cmakedefine HAVE_ERRNO_H ${HAVE_ERRNO_H}\n\n/* Define to 1 if you have the <err.h> header file. */\n#cmakedefine HAVE_ERR_H ${HAVE_ERR_H}\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#cmakedefine HAVE_FCNTL_H ${HAVE_FCNTL_H}\n\n/* use FIONBIO for non-blocking sockets */\n#cmakedefine HAVE_FIONBIO ${HAVE_FIONBIO}\n\n/* Define to 1 if you have the `fork' function. */\n#cmakedefine HAVE_FORK ${HAVE_FORK}\n\n/* Define to 1 if you have the `ftruncate' function. */\n#cmakedefine HAVE_FTRUNCATE ${HAVE_FTRUNCATE}\n\n/* Define if getaddrinfo exists and works */\n#cmakedefine HAVE_GETADDRINFO ${HAVE_GETADDRINFO}\n\n/* Define to 1 if you have the `geteuid' function. */\n#cmakedefine HAVE_GETEUID ${HAVE_GETEUID}\n\n/* Define to 1 if you have the `gethostbyaddr' function. */\n#cmakedefine HAVE_GETHOSTBYADDR ${HAVE_GETHOSTBYADDR}\n\n/* If you have gethostbyname */\n#cmakedefine HAVE_GETHOSTBYNAME ${HAVE_GETHOSTBYNAME}\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n#cmakedefine HAVE_GETHOSTBYNAME_R ${HAVE_GETHOSTBYNAME_R}\n\n/* gethostbyname_r() takes 3 args */\n#cmakedefine HAVE_GETHOSTBYNAME_R_3 ${HAVE_GETHOSTBYNAME_R_3}\n\n/* gethostbyname_r() takes 5 args */\n#cmakedefine HAVE_GETHOSTBYNAME_R_5 ${HAVE_GETHOSTBYNAME_R_5}\n\n/* gethostbyname_r() takes 6 args */\n#cmakedefine HAVE_GETHOSTBYNAME_R_6 ${HAVE_GETHOSTBYNAME_R_6}\n\n/* Define to 1 if you have the getnameinfo function. */\n#cmakedefine HAVE_GETNAMEINFO ${HAVE_GETNAMEINFO}\n\n/* Define to 1 if you have the `getpass_r' function. */\n#cmakedefine HAVE_GETPASS_R ${HAVE_GETPASS_R}\n\n/* Define to 1 if you have the `getprotobyname' function. */\n#cmakedefine HAVE_GETPROTOBYNAME ${HAVE_GETPROTOBYNAME}\n\n/* Define to 1 if you have the `getpwuid' function. */\n#cmakedefine HAVE_GETPWUID ${HAVE_GETPWUID}\n\n/* Define to 1 if you have the `getrlimit' function. */\n#cmakedefine HAVE_GETRLIMIT ${HAVE_GETRLIMIT}\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#cmakedefine HAVE_GETTIMEOFDAY ${HAVE_GETTIMEOFDAY}\n\n/* Define to 1 if you have the `gmtime_r' function. */\n#cmakedefine HAVE_GMTIME_R ${HAVE_GMTIME_R}\n\n/* if you have the gssapi libraries */\n#cmakedefine HAVE_GSSAPI ${HAVE_GSSAPI}\n\n/* if you have the GNU gssapi libraries */\n#cmakedefine HAVE_GSSGNU ${HAVE_GSSGNU}\n\n/* if you have the Heimdal gssapi libraries */\n#cmakedefine HAVE_GSSHEIMDAL ${HAVE_GSSHEIMDAL}\n\n/* if you have the MIT gssapi libraries */\n#cmakedefine HAVE_GSSMIT ${HAVE_GSSMIT}\n\n/* Define to 1 if you have the `idna_strerror' function. */\n#cmakedefine HAVE_IDNA_STRERROR ${HAVE_IDNA_STRERROR}\n\n/* Define to 1 if you have the `idn_free' function. */\n#cmakedefine HAVE_IDN_FREE ${HAVE_IDN_FREE}\n\n/* Define to 1 if you have the <idn-free.h> header file. */\n#cmakedefine HAVE_IDN_FREE_H ${HAVE_IDN_FREE_H}\n\n/* Define to 1 if you have the `inet_addr' function. */\n#cmakedefine HAVE_INET_ADDR ${HAVE_INET_ADDR}\n\n/* Define to 1 if you have the `inet_ntoa' function. */\n#cmakedefine HAVE_INET_NTOA ${HAVE_INET_NTOA}\n\n/* Define to 1 if you have the `inet_ntoa_r' function. */\n#cmakedefine HAVE_INET_NTOA_R ${HAVE_INET_NTOA_R}\n\n/* inet_ntoa_r() is declared */\n#cmakedefine HAVE_INET_NTOA_R_DECL ${HAVE_INET_NTOA_R_DECL}\n\n/* Define to 1 if you have the `inet_pton' function. */\n#cmakedefine HAVE_INET_PTON ${HAVE_INET_PTON}\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#cmakedefine HAVE_INTTYPES_H ${HAVE_INTTYPES_H}\n\n/* use ioctlsocket() for non-blocking sockets */\n#cmakedefine HAVE_IOCTLSOCKET ${HAVE_IOCTLSOCKET}\n\n/* use Ioctlsocket() for non-blocking sockets */\n#cmakedefine HAVE_IOCTLSOCKET_CASE ${HAVE_IOCTLSOCKET_CASE}\n\n/* Define to 1 if you have the <io.h> header file. */\n#cmakedefine HAVE_IO_H ${HAVE_IO_H}\n\n/* if you have the Kerberos4 libraries (including -ldes) */\n#cmakedefine HAVE_KRB4 ${HAVE_KRB4}\n\n/* Define to 1 if you have the `krb_get_our_ip_for_realm' function. */\n#cmakedefine HAVE_KRB_GET_OUR_IP_FOR_REALM ${HAVE_KRB_GET_OUR_IP_FOR_REALM}\n\n/* Define to 1 if you have the <krb.h> header file. */\n#cmakedefine HAVE_KRB_H ${HAVE_KRB_H}\n\n/* Define to 1 if you have the `dl' library (-ldl). */\n#cmakedefine HAVE_LIBDL ${HAVE_LIBDL}\n\n/* Define to 1 if you have the <libgen.h> header file. */\n#cmakedefine HAVE_LIBGEN_H ${HAVE_LIBGEN_H}\n\n/* Define to 1 if you have the `idn' library (-lidn). */\n#cmakedefine HAVE_LIBIDN ${HAVE_LIBIDN}\n\n/* Define to 1 if you have the `resolv' library (-lresolv). */\n#cmakedefine HAVE_LIBRESOLV ${HAVE_LIBRESOLV}\n\n/* Define to 1 if you have the `resolve' library (-lresolve). */\n#cmakedefine HAVE_LIBRESOLVE ${HAVE_LIBRESOLVE}\n\n/* Define to 1 if you have the `socket' library (-lsocket). */\n#cmakedefine HAVE_LIBSOCKET ${HAVE_LIBSOCKET}\n\n/* Define to 1 if you have the `ssh2' library (-lssh2). */\n#cmakedefine HAVE_LIBSSH2 ${HAVE_LIBSSH2}\n\n/* Define to 1 if you have the <libssh2.h> header file. */\n#cmakedefine HAVE_LIBSSH2_H ${HAVE_LIBSSH2_H}\n\n/* if zlib is available */\n#cmakedefine HAVE_LIBZ ${HAVE_LIBZ}\n\n/* Define to 1 if you have the <limits.h> header file. */\n#cmakedefine HAVE_LIMITS_H ${HAVE_LIMITS_H}\n\n/* if your compiler supports LL */\n#cmakedefine HAVE_LL ${HAVE_LL}\n\n/* Define to 1 if you have the <locale.h> header file. */\n#cmakedefine HAVE_LOCALE_H ${HAVE_LOCALE_H}\n\n/* Define to 1 if you have the `localtime_r' function. */\n#cmakedefine HAVE_LOCALTIME_R ${HAVE_LOCALTIME_R}\n\n/* if your compiler supports long long */\n#cmakedefine HAVE_LONGLONG ${HAVE_LONGLONG}\n\n/* Define to 1 if you have the malloc.h header file. */\n#cmakedefine HAVE_MALLOC_H ${HAVE_MALLOC_H}\n\n/* Define to 1 if you have the <memory.h> header file. */\n#cmakedefine HAVE_MEMORY_H ${HAVE_MEMORY_H}\n\n/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n#cmakedefine HAVE_MSG_NOSIGNAL ${HAVE_MSG_NOSIGNAL}\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#cmakedefine HAVE_NETDB_H ${HAVE_NETDB_H}\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#cmakedefine HAVE_NETINET_IN_H ${HAVE_NETINET_IN_H}\n\n/* Define to 1 if you have the <netinet/tcp.h> header file. */\n#cmakedefine HAVE_NETINET_TCP_H ${HAVE_NETINET_TCP_H}\n\n/* Define to 1 if you have the <net/if.h> header file. */\n#cmakedefine HAVE_NET_IF_H ${HAVE_NET_IF_H}\n\n/* Define to 1 if NI_WITHSCOPEID exists and works. */\n#cmakedefine HAVE_NI_WITHSCOPEID ${HAVE_NI_WITHSCOPEID}\n\n/* Defined if no inet_pton() prototype available */\n#cmakedefine HAVE_NO_INET_PTON_PROTO ${HAVE_NO_INET_PTON_PROTO}\n\n/* we have no strerror_r() proto */\n#cmakedefine HAVE_NO_STRERROR_R_DECL ${HAVE_NO_STRERROR_R_DECL}\n\n/* Define to 1 if you have the <openssl/crypto.h> header file. */\n#cmakedefine HAVE_OPENSSL_CRYPTO_H ${HAVE_OPENSSL_CRYPTO_H}\n\n/* Define to 1 if you have the <openssl/engine.h> header file. */\n#cmakedefine HAVE_OPENSSL_ENGINE_H ${HAVE_OPENSSL_ENGINE_H}\n\n/* Define to 1 if you have the <openssl/err.h> header file. */\n#cmakedefine HAVE_OPENSSL_ERR_H ${HAVE_OPENSSL_ERR_H}\n\n/* Define to 1 if you have the <openssl/pem.h> header file. */\n#cmakedefine HAVE_OPENSSL_PEM_H ${HAVE_OPENSSL_PEM_H}\n\n/* Define to 1 if you have the <openssl/pkcs12.h> header file. */\n#cmakedefine HAVE_OPENSSL_PKCS12_H ${HAVE_OPENSSL_PKCS12_H}\n\n/* Define to 1 if you have the <openssl/rsa.h> header file. */\n#cmakedefine HAVE_OPENSSL_RSA_H ${HAVE_OPENSSL_RSA_H}\n\n/* Define to 1 if you have the <openssl/ssl.h> header file. */\n#cmakedefine HAVE_OPENSSL_SSL_H ${HAVE_OPENSSL_SSL_H}\n\n/* Define to 1 if you have the <openssl/x509.h> header file. */\n#cmakedefine HAVE_OPENSSL_X509_H ${HAVE_OPENSSL_X509_H}\n\n/* use O_NONBLOCK for non-blocking sockets */\n#cmakedefine HAVE_O_NONBLOCK ${HAVE_O_NONBLOCK}\n\n/* Define to 1 if you have the <pem.h> header file. */\n#cmakedefine HAVE_PEM_H ${HAVE_PEM_H}\n\n/* Define to 1 if you have the `perror' function. */\n#cmakedefine HAVE_PERROR ${HAVE_PERROR}\n\n/* Define to 1 if you have the `pipe' function. */\n#cmakedefine HAVE_PIPE ${HAVE_PIPE}\n\n/* Define to 1 if you have the `poll' function. */\n#cmakedefine HAVE_POLL ${HAVE_POLL}\n\n/* Define to 1 if you have the <process.h> header file. */\n#cmakedefine HAVE_PROCESS_H ${HAVE_PROCESS_H}\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#cmakedefine HAVE_PWD_H ${HAVE_PWD_H}\n\n/* Define to 1 if you have the `RAND_egd' function. */\n#cmakedefine HAVE_RAND_EGD ${HAVE_RAND_EGD}\n\n/* Define to 1 if you have the `RAND_screen' function. */\n#cmakedefine HAVE_RAND_SCREEN ${HAVE_RAND_SCREEN}\n\n/* Define to 1 if you have the `RAND_status' function. */\n#cmakedefine HAVE_RAND_STATUS ${HAVE_RAND_STATUS}\n\n/* Define to 1 if you have the recv function. */\n#cmakedefine HAVE_RECV ${HAVE_RECV}\n\n/* Define to 1 if you have the <rsa.h> header file. */\n#cmakedefine HAVE_RSA_H ${HAVE_RSA_H}\n\n/* Define to 1 if you have the select function. */\n#cmakedefine HAVE_SELECT ${HAVE_SELECT}\n\n/* Define to 1 if you have the send function. */\n#cmakedefine HAVE_SEND ${HAVE_SEND}\n\n/* Define to 1 if you have the <setjmp.h> header file. */\n#cmakedefine HAVE_SETJMP_H ${HAVE_SETJMP_H}\n\n/* Define to 1 if you have the `setlocale' function. */\n#cmakedefine HAVE_SETLOCALE ${HAVE_SETLOCALE}\n\n/* Define to 1 if you have the `setrlimit' function. */\n#cmakedefine HAVE_SETRLIMIT ${HAVE_SETRLIMIT}\n\n/* Define to 1 if you have the <sgtty.h> header file. */\n#cmakedefine HAVE_SGTTY_H ${HAVE_SGTTY_H}\n\n/* Define to 1 if you have the `sigaction' function. */\n#cmakedefine HAVE_SIGACTION ${HAVE_SIGACTION}\n\n/* Define to 1 if you have the `siginterrupt' function. */\n#cmakedefine HAVE_SIGINTERRUPT ${HAVE_SIGINTERRUPT}\n\n/* Define to 1 if you have the `signal' function. */\n#cmakedefine HAVE_SIGNAL ${HAVE_SIGNAL}\n\n/* Define to 1 if you have the <signal.h> header file. */\n#cmakedefine HAVE_SIGNAL_H ${HAVE_SIGNAL_H}\n\n/* If you have sigsetjmp */\n#cmakedefine HAVE_SIGSETJMP ${HAVE_SIGSETJMP}\n\n/* Define to 1 if sig_atomic_t is an available typedef. */\n#cmakedefine HAVE_SIG_ATOMIC_T ${HAVE_SIG_ATOMIC_T}\n\n/* Define to 1 if sig_atomic_t is already defined as volatile. */\n#cmakedefine HAVE_SIG_ATOMIC_T_VOLATILE ${HAVE_SIG_ATOMIC_T_VOLATILE}\n\n/* Define to 1 if you have the `socket' function. */\n#cmakedefine HAVE_SOCKET ${HAVE_SOCKET}\n\n/* use SO_NONBLOCK for non-blocking sockets */\n#cmakedefine HAVE_SO_NONBLOCK ${HAVE_SO_NONBLOCK}\n\n/* Define this if you have the SPNEGO library fbopenssl */\n#cmakedefine HAVE_SPNEGO ${HAVE_SPNEGO}\n\n/* Define to 1 if you have the <ssl.h> header file. */\n#cmakedefine HAVE_SSL_H ${HAVE_SSL_H}\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#cmakedefine HAVE_STDINT_H ${HAVE_STDINT_H}\n\n/* Define to 1 if you have the <stdio.h> header file. */\n#cmakedefine HAVE_STDIO_H ${HAVE_STDIO_H}\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#cmakedefine HAVE_STDLIB_H ${HAVE_STDLIB_H}\n\n/* Define to 1 if you have the `strcasecmp' function. */\n#cmakedefine HAVE_STRCASECMP ${HAVE_STRCASECMP}\n\n/* Define to 1 if you have the `strcmpi' function. */\n#cmakedefine HAVE_STRCMPI ${HAVE_STRCMPI}\n\n/* Define to 1 if you have the `strdup' function. */\n#cmakedefine HAVE_STRDUP ${HAVE_STRDUP}\n\n/* Define to 1 if you have the `stricmp' function. */\n#cmakedefine HAVE_STRICMP ${HAVE_STRICMP}\n\n/* Define to 1 if you have the <strings.h> header file. */\n#cmakedefine HAVE_STRINGS_H ${HAVE_STRINGS_H}\n\n/* Define to 1 if you have the <string.h> header file. */\n#cmakedefine HAVE_STRING_H ${HAVE_STRING_H}\n\n/* Define to 1 if you have the `strlcpy' function. */\n#cmakedefine HAVE_STRLCPY ${HAVE_STRLCPY}\n\n/* Define to 1 if you have the `strstr' function. */\n#cmakedefine HAVE_STRSTR ${HAVE_STRSTR}\n\n/* Define to 1 if you have the `strtok_r' function. */\n#cmakedefine HAVE_STRTOK_R ${HAVE_STRTOK_R}\n\n/* Define to 1 if you have the `strtoll' function. */\n#cmakedefine HAVE_STRTOLL ${HAVE_STRTOLL}\n\n/* if struct sockaddr_storage is defined */\n#cmakedefine HAVE_STRUCT_SOCKADDR_STORAGE ${HAVE_STRUCT_SOCKADDR_STORAGE}\n\n/* Define to 1 if you have the timeval struct. */\n#cmakedefine HAVE_STRUCT_TIMEVAL ${HAVE_STRUCT_TIMEVAL}\n\n/* Define to 1 if you have the <sys/filio.h> header file. */\n#cmakedefine HAVE_SYS_FILIO_H ${HAVE_SYS_FILIO_H}\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#cmakedefine HAVE_SYS_IOCTL_H ${HAVE_SYS_IOCTL_H}\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#cmakedefine HAVE_SYS_PARAM_H ${HAVE_SYS_PARAM_H}\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#cmakedefine HAVE_SYS_POLL_H ${HAVE_SYS_POLL_H}\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#cmakedefine HAVE_SYS_RESOURCE_H ${HAVE_SYS_RESOURCE_H}\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#cmakedefine HAVE_SYS_SELECT_H ${HAVE_SYS_SELECT_H}\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#cmakedefine HAVE_SYS_SOCKET_H ${HAVE_SYS_SOCKET_H}\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#cmakedefine HAVE_SYS_SOCKIO_H ${HAVE_SYS_SOCKIO_H}\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#cmakedefine HAVE_SYS_STAT_H ${HAVE_SYS_STAT_H}\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#cmakedefine HAVE_SYS_TIME_H ${HAVE_SYS_TIME_H}\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#cmakedefine HAVE_SYS_TYPES_H ${HAVE_SYS_TYPES_H}\n\n/* Define to 1 if you have the <sys/utime.h> header file. */\n#cmakedefine HAVE_SYS_UTIME_H ${HAVE_SYS_UTIME_H}\n\n/* Define to 1 if you have the <termios.h> header file. */\n#cmakedefine HAVE_TERMIOS_H ${HAVE_TERMIOS_H}\n\n/* Define to 1 if you have the <termio.h> header file. */\n#cmakedefine HAVE_TERMIO_H ${HAVE_TERMIO_H}\n\n/* Define to 1 if you have the <time.h> header file. */\n#cmakedefine HAVE_TIME_H ${HAVE_TIME_H}\n\n/* Define to 1 if you have the <tld.h> header file. */\n#cmakedefine HAVE_TLD_H ${HAVE_TLD_H}\n\n/* Define to 1 if you have the `tld_strerror' function. */\n#cmakedefine HAVE_TLD_STRERROR ${HAVE_TLD_STRERROR}\n\n/* Define to 1 if you have the `uname' function. */\n#cmakedefine HAVE_UNAME ${HAVE_UNAME}\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#cmakedefine HAVE_UNISTD_H ${HAVE_UNISTD_H}\n\n/* Define to 1 if you have the `utime' function. */\n#cmakedefine HAVE_UTIME ${HAVE_UTIME}\n\n/* Define to 1 if you have the <utime.h> header file. */\n#cmakedefine HAVE_UTIME_H ${HAVE_UTIME_H}\n\n/* Define to 1 if you have the windows.h header file. */\n#cmakedefine HAVE_WINDOWS_H ${HAVE_WINDOWS_H}\n\n/* Define to 1 if you have the winsock2.h header file. */\n#cmakedefine HAVE_WINSOCK2_H ${HAVE_WINSOCK2_H}\n\n/* Define to 1 if you have the winsock.h header file. */\n#cmakedefine HAVE_WINSOCK_H ${HAVE_WINSOCK_H}\n\n/* Define this symbol if your OS supports changing the contents of argv */\n#cmakedefine HAVE_WRITABLE_ARGV ${HAVE_WRITABLE_ARGV}\n\n/* Define to 1 if you have the ws2tcpip.h header file. */\n#cmakedefine HAVE_WS2TCPIP_H ${HAVE_WS2TCPIP_H}\n\n/* Define to 1 if you have the <x509.h> header file. */\n#cmakedefine HAVE_X509_H ${HAVE_X509_H}\n\n/* if you have the zlib.h header file */\n#cmakedefine HAVE_ZLIB_H ${HAVE_ZLIB_H}\n\n/* If you lack a fine basename() prototype */\n#cmakedefine NEED_BASENAME_PROTO ${NEED_BASENAME_PROTO}\n\n/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n#cmakedefine NEED_MALLOC_H ${NEED_MALLOC_H}\n\n/* need REENTRANT defined */\n#cmakedefine NEED_REENTRANT ${NEED_REENTRANT}\n\n/* cpu-machine-OS */\n#define OS \"${OPERATING_SYSTEM}\"\n\n/* Name of package */\n#cmakedefine PACKAGE \"${PACKAGE}\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#cmakedefine PACKAGE_BUGREPORT \"${PACKAGE_BUGREPORT}\"\n\n/* Define to the full name of this package. */\n#cmakedefine PACKAGE_NAME \"${PACKAGE_NAME}\"\n\n/* Define to the full name and version of this package. */\n#cmakedefine PACKAGE_STRING \"${PACKAGE_STRING}\"\n\n/* Define to the one symbol short name of this package. */\n#cmakedefine PACKAGE_TARNAME \"${PACKAGE_TARNAME}\"\n\n/* Define to the version of this package. */\n#cmakedefine PACKAGE_VERSION \"${PACKAGE_VERSION}\"\n\n/* a suitable file to read random data from */\n#cmakedefine RANDOM_FILE \"${RANDOM_FILE}\"\n\n/* Define to the type of arg 1 for recv. */\n#cmakedefine RECV_TYPE_ARG1 ${RECV_TYPE_ARG1}\n\n/* Define to the type of arg 2 for recv. */\n#cmakedefine RECV_TYPE_ARG2 ${RECV_TYPE_ARG2}\n\n/* Define to the type of arg 3 for recv. */\n#cmakedefine RECV_TYPE_ARG3 ${RECV_TYPE_ARG3}\n\n/* Define to the type of arg 4 for recv. */\n#cmakedefine RECV_TYPE_ARG4 ${RECV_TYPE_ARG4}\n\n/* Define to the function return type for recv. */\n#cmakedefine RECV_TYPE_RETV ${RECV_TYPE_RETV}\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#cmakedefine RETSIGTYPE ${RETSIGTYPE}\n\n/* Define to the type of arg 1 for `select'. */\n#cmakedefine SELECT_TYPE_ARG1 ${SELECT_TYPE_ARG1}\n\n/* Define to the type of args 2, 3 and 4 for `select'. */\n#cmakedefine SELECT_TYPE_ARG234 ${SELECT_TYPE_ARG234}\n\n/* Define to the type of arg 5 for `select'. */\n#cmakedefine SELECT_TYPE_ARG5 ${SELECT_TYPE_ARG5}\n\n/* Define to the type qualifier of arg 2 for send. */\n#cmakedefine SEND_QUAL_ARG2 ${SEND_QUAL_ARG2}\n\n/* Define to the type of arg 1 for send. */\n#cmakedefine SEND_TYPE_ARG1 ${SEND_TYPE_ARG1}\n\n/* Define to the type of arg 2 for send. */\n#cmakedefine SEND_TYPE_ARG2 ${SEND_TYPE_ARG2}\n\n/* Define to the type of arg 3 for send. */\n#cmakedefine SEND_TYPE_ARG3 ${SEND_TYPE_ARG3}\n\n/* Define to the type of arg 4 for send. */\n#cmakedefine SEND_TYPE_ARG4 ${SEND_TYPE_ARG4}\n\n/* Define to the function return type for send. */\n#cmakedefine SEND_TYPE_RETV ${SEND_TYPE_RETV}\n\n/* The size of `curl_off_t', as computed by sizeof. */\n@SIZEOF_CURL_OFF_T_CODE@\n\n/* The size of `long', as computed by sizeof. */\n@SIZEOF_LONG_CODE@\n\n/* The size of `long long', as computed by sizeof. */\n@SIZEOF_LONG_LONG_CODE@\n\n/* The size of `__int64', as computed by sizeof. */\n@SIZEOF___INT64_CODE@\n\n/* The size of `size_t', as computed by sizeof. */\n@SIZEOF_SIZE_T_CODE@\n\n/* The size of `ssize_t', as computed by sizeof. */\n@SIZEOF_SSIZE_T_CODE@\n\n/* The size of `time_t', as computed by sizeof. */\n@SIZEOF_TIME_T_CODE@\n\n/* Define to 1 if you have the ANSI C header files. */\n#cmakedefine STDC_HEADERS ${STDC_HEADERS}\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#cmakedefine TIME_WITH_SYS_TIME ${TIME_WITH_SYS_TIME}\n\n/* Define if you want to enable ares support */\n#cmakedefine USE_ARES ${USE_ARES}\n\n/* if GnuTLS is enabled */\n#cmakedefine USE_GNUTLS ${USE_GNUTLS}\n\n/* if libSSH2 is in use */\n#cmakedefine USE_LIBSSH2 ${USE_LIBSSH2}\n\n/* If you want to build curl with the built-in manual */\n#cmakedefine USE_MANUAL ${USE_MANUAL}\n\n/* if OpenSSL is in use */\n#cmakedefine USE_OPENSSL ${USE_OPENSSL}\n\n/* if SSL is enabled */\n#cmakedefine USE_SSLEAY ${USE_SSLEAY}\n\n/* to enable SSPI support */\n#cmakedefine USE_WINDOWS_SSPI ${USE_WINDOWS_SSPI}\n\n/* Version number of package */\n#cmakedefine VERSION \"${VERSION}\"\n\n/* Define to avoid automatic inclusion of winsock.h */\n#cmakedefine WIN32_LEAN_AND_MEAN ${WIN32_LEAN_AND_MEAN}\n\n/* Define to 1 if on AIX 3.\n   System headers sometimes define this.\n   We just want to avoid a redefinition error message.  */\n#ifndef _ALL_SOURCE\n#cmakedefine _ALL_SOURCE ${_ALL_SOURCE}\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#cmakedefine _FILE_OFFSET_BITS ${_FILE_OFFSET_BITS}\n\n/* Define for large files, on AIX-style hosts. */\n#cmakedefine _LARGE_FILES ${_LARGE_FILES}\n\n/* define this if you need it to compile thread-safe code */\n#cmakedefine _THREAD_SAFE ${_THREAD_SAFE}\n\n/* Define to empty if `const' does not conform to ANSI C. */\n#cmakedefine const ${const}\n\n/* type to use in place of in_addr_t if not defined */\n#cmakedefine in_addr_t ${in_addr_t}\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n#cmakedefine size_t ${size_t}\n\n/* type to use in place of socklen_t if not defined */\n#cmakedefine socklen_t ${socklen_t}\n\n/* the signed version of size_t */\n#ifndef SIZEOF_SSIZE_T\n# if SIZEOF_LONG == SIZEOF_SIZE_T\n   typedef long ssize_t;\n# elif SIZEOF_LONG_LONG == SIZEOF_SIZE_T\n   typedef long long ssize_t;\n# elif SIZEOF___INT64 == SIZEOF_SIZE_T\n   typedef __int64 ssize_t;\n# else\n   typedef int ssize_t;\n# endif\n#endif\n\n/* Special handling of zlib library */\n#cmakedefine CURL_SPECIAL_ZLIB_H \"${CURL_SPECIAL_ZLIB_H}\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/strerror.c": "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2004 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at http://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * $Id$\n ***************************************************************************/\n\n#include \"setup.h\"\n\n#ifdef HAVE_STRERROR_R\n#if !defined(HAVE_POSIX_STRERROR_R) && !defined(HAVE_GLIBC_STRERROR_R)\n#error \"you MUST have either POSIX or glibc strerror_r if strerror_r is found\"\n#endif /* !POSIX && !glibc */\n#endif /* HAVE_STRERROR_R */\n\n#include <curl/curl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef USE_LIBIDN\n#include <idna.h>\n#endif\n\n#include \"strerror.h\"\n\n#define _MPRINTF_REPLACE /* use our functions only */\n#include <curl/mprintf.h>\n\n#if defined(HAVE_STRERROR_R) && defined(HAVE_NO_STRERROR_R_DECL)\n#ifdef HAVE_POSIX_STRERROR_R\n/* seen on AIX 5100-02 gcc 2.9 */\nextern int strerror_r(int errnum, char *strerrbuf, size_t buflen);\n#else\nextern char *strerror_r(int errnum, char *buf, size_t buflen);\n#endif\n#endif\n\nconst char *\ncurl_easy_strerror(CURLcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLE_OK:\n    return \"no error\";\n\n  case CURLE_UNSUPPORTED_PROTOCOL:\n    return \"unsupported protocol\";\n\n  case CURLE_FAILED_INIT:\n    return \"failed init\";\n\n  case CURLE_URL_MALFORMAT:\n    return \"URL using bad/illegal format or missing URL\";\n\n  case CURLE_NOT_BUILT_IN:\n    return \"A requested feature, protocol or option was not found built-in in\"\n      \" this libcurl due to a build-time decision.\";\n\n  case CURLE_COULDNT_RESOLVE_PROXY:\n    return \"couldn't resolve proxy name\";\n\n  case CURLE_COULDNT_RESOLVE_HOST:\n    return \"couldn't resolve host name\";\n\n  case CURLE_COULDNT_CONNECT:\n    return \"couldn't connect to server\";\n\n  case CURLE_FTP_WEIRD_SERVER_REPLY:\n    return \"FTP: weird server reply\";\n\n  case CURLE_FTP_ACCESS_DENIED:\n    return \"FTP: access denied\";\n\n  case CURLE_FTP_WEIRD_PASS_REPLY:\n    return \"FTP: unknown PASS reply\";\n\n  case CURLE_FTP_WEIRD_USER_REPLY:\n    return \"FTP: unknown USER reply\";\n\n  case CURLE_FTP_WEIRD_PASV_REPLY:\n    return \"FTP: unknown PASV reply\";\n\n  case CURLE_FTP_WEIRD_227_FORMAT:\n    return \"FTP: unknown 227 response format\";\n\n  case CURLE_FTP_CANT_GET_HOST:\n    return \"FTP: can't figure out the host in the PASV response\";\n\n  case CURLE_FTP_CANT_RECONNECT:\n    return \"FTP: can't connect to server the response code is unknown\";\n\n  case CURLE_FTP_COULDNT_SET_BINARY:\n    return \"FTP: couldn't set binary mode\";\n\n  case CURLE_PARTIAL_FILE:\n    return \"Transferred a partial file\";\n\n  case CURLE_FTP_COULDNT_RETR_FILE:\n    return \"FTP: couldn't retrieve (RETR failed) the specified file\";\n\n  case CURLE_FTP_WRITE_ERROR:\n    return \"FTP: the post-transfer acknowledge response was not OK\";\n\n  case CURLE_FTP_QUOTE_ERROR:\n    return \"FTP: a quote command returned error\";\n\n  case CURLE_HTTP_RETURNED_ERROR:\n    return \"HTTP response code said error\";\n\n  case CURLE_WRITE_ERROR:\n    return \"failed writing received data to disk/application\";\n\n  case CURLE_FTP_COULDNT_STOR_FILE:\n    return \"failed FTP upload (the STOR command)\";\n\n  case CURLE_READ_ERROR:\n    return \"failed to open/read local data from file/application\";\n\n  case CURLE_OUT_OF_MEMORY:\n#ifdef CURL_DOES_CONVERSIONS\n    return \"conversion failed -or- out of memory\";\n#else\n    return \"out of memory\";\n#endif /* CURL_DOES_CONVERSIONS */\n\n  case CURLE_OPERATION_TIMEOUTED:\n    return \"a timeout was reached\";\n\n  case CURLE_FTP_COULDNT_SET_ASCII:\n    return \"FTP could not set ASCII mode (TYPE A)\";\n\n  case CURLE_FTP_PORT_FAILED:\n    return \"FTP command PORT failed\";\n\n  case CURLE_FTP_COULDNT_USE_REST:\n    return \"FTP command REST failed\";\n\n  case CURLE_FTP_COULDNT_GET_SIZE:\n    return \"FTP command SIZE failed\";\n\n  case CURLE_HTTP_RANGE_ERROR:\n    return \"a range was requested but the server did not deliver it\";\n\n  case CURLE_HTTP_POST_ERROR:\n    return \"internal problem setting up the POST\";\n\n  case CURLE_SSL_CONNECT_ERROR:\n    return \"SSL connect error\";\n\n  case CURLE_BAD_DOWNLOAD_RESUME:\n    return \"couldn't resume download\";\n\n  case CURLE_FILE_COULDNT_READ_FILE:\n    return \"couldn't read a file:// file\";\n\n  case CURLE_LDAP_CANNOT_BIND:\n    return \"LDAP: cannot bind\";\n\n  case CURLE_LDAP_SEARCH_FAILED:\n    return \"LDAP: search failed\";\n\n  case CURLE_LIBRARY_NOT_FOUND:\n    return \"a required shared library was not found\";\n\n  case CURLE_FUNCTION_NOT_FOUND:\n    return \"a required function in the shared library was not found\";\n\n  case CURLE_ABORTED_BY_CALLBACK:\n    return \"the operation was aborted by an application callback\";\n\n  case CURLE_BAD_FUNCTION_ARGUMENT:\n    return \"a libcurl function was given a bad argument\";\n\n  case CURLE_INTERFACE_FAILED:\n    return \"failed binding local connection end\";\n\n  case CURLE_TOO_MANY_REDIRECTS :\n    return \"number of redirects hit maximum amount\";\n\n  case CURLE_UNKNOWN_TELNET_OPTION:\n    return \"User specified an unknown option\";\n\n  case CURLE_TELNET_OPTION_SYNTAX :\n    return \"Malformed telnet option\";\n\n  case CURLE_SSL_PEER_CERTIFICATE:\n    return \"SSL peer certificate was not ok\";\n\n  case CURLE_GOT_NOTHING:\n    return \"server returned nothing (no headers, no data)\";\n\n  case CURLE_SSL_ENGINE_NOTFOUND:\n    return \"SSL crypto engine not found\";\n\n  case CURLE_SSL_ENGINE_SETFAILED:\n    return \"can not set SSL crypto engine as default\";\n\n  case CURLE_SSL_ENGINE_INITFAILED:\n    return \"failed to initialise SSL crypto engine\";\n\n  case CURLE_SEND_ERROR:\n    return \"failed sending data to the peer\";\n\n  case CURLE_RECV_ERROR:\n    return \"failure when receiving data from the peer\";\n\n  case CURLE_SHARE_IN_USE:\n    return \"share is already in use\";\n\n  case CURLE_SSL_CERTPROBLEM:\n    return \"problem with the local SSL certificate\";\n\n  case CURLE_SSL_CIPHER:\n    return \"couldn't use specified SSL cipher\";\n\n  case CURLE_SSL_CACERT:\n    return \"peer certificate cannot be authenticated with known CA certificates\";\n\n  case CURLE_SSL_CACERT_BADFILE:\n    return \"problem with the SSL CA cert (path? access rights?)\";\n\n  case CURLE_BAD_CONTENT_ENCODING:\n    return \"Unrecognized HTTP Content-Encoding\";\n\n  case CURLE_LDAP_INVALID_URL:\n    return \"Invalid LDAP URL\";\n\n  case CURLE_FILESIZE_EXCEEDED:\n    return \"Maximum file size exceeded\";\n\n  case CURLE_FTP_SSL_FAILED:\n    return \"Requested FTP SSL level failed\";\n\n  case CURLE_SSL_SHUTDOWN_FAILED:\n    return \"Failed to shut down the SSL connection\";\n\n  case CURLE_SEND_FAIL_REWIND:\n    return \"Send failed since rewinding of the data stream failed\";\n\n  case CURLE_LOGIN_DENIED:\n    return \"FTP: login denied\";\n\n  case CURLE_TFTP_NOTFOUND:\n    return \"TFTP: File Not Found\";\n\n  case CURLE_TFTP_PERM:\n    return \"TFTP: Access Violation\";\n\n  case CURLE_TFTP_DISKFULL:\n    return \"TFTP: Disk full or allocation exceeded\";\n\n  case CURLE_TFTP_ILLEGAL:\n    return \"TFTP: Illegal operation\";\n\n  case CURLE_TFTP_UNKNOWNID:\n    return \"TFTP: Unknown transfer ID\";\n\n  case CURLE_TFTP_EXISTS:\n    return \"TFTP: File already exists\";\n\n  case CURLE_TFTP_NOSUCHUSER:\n    return \"TFTP: No such user\";\n\n  case CURLE_CONV_FAILED:\n    return \"conversion failed\";\n\n  case CURLE_CONV_REQD:\n    return \"caller must register CURLOPT_CONV_ callback options\";\n\n  case CURLE_REMOTE_FILE_NOT_FOUND:\n    return \"Remote file not found\";\n\n  case CURLE_SSH:\n    return \"Error in the SSH layer\";\n\n    /* error codes not used by current libcurl */\n  case CURLE_FTP_USER_PASSWORD_INCORRECT:\n  case CURLE_MALFORMAT_USER:\n  case CURLE_BAD_CALLING_ORDER:\n  case CURLE_BAD_PASSWORD_ENTERED:\n  case CURLE_OBSOLETE:\n  case CURL_LAST:\n    break;\n  }\n  /*\n   * By using a switch, gcc -Wall will complain about enum values\n   * which do not appear, helping keep this function up-to-date.\n   * By using gcc -Wall -Werror, you can't forget.\n   *\n   * A table would not have the same benefit.  Most compilers will\n   * generate code very similar to a table in any case, so there\n   * is little performance gain from a table.  And something is broken\n   * for the user's application, anyways, so does it matter how fast\n   * it _doesn't_ work?\n   *\n   * The line number for the error will be near this comment, which\n   * is why it is here, and not at the start of the switch.\n   */\n  return \"unknown error\";\n#else\n  if (error == CURLE_OK)\n    return \"no error\";\n  else\n    return \"error\";\n#endif\n}\n\nconst char *\ncurl_multi_strerror(CURLMcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLM_CALL_MULTI_PERFORM:\n    return \"please call curl_multi_perform() soon\";\n\n  case CURLM_OK:\n    return \"no error\";\n\n  case CURLM_BAD_HANDLE:\n    return \"invalid multi handle\";\n\n  case CURLM_BAD_EASY_HANDLE:\n    return \"invalid easy handle\";\n\n  case CURLM_OUT_OF_MEMORY:\n    return \"out of memory\";\n\n  case CURLM_INTERNAL_ERROR:\n    return \"internal error\";\n\n  case CURLM_BAD_SOCKET:\n    return \"invalid socket argument\";\n\n  case CURLM_UNKNOWN_OPTION:\n    return \"unknown option\";\n\n  case CURLM_LAST:\n    break;\n  }\n\n  return \"unknown error\";\n#else\n  if (error == CURLM_OK)\n    return \"no error\";\n  else\n    return \"error\";\n#endif\n}\n\nconst char *\ncurl_share_strerror(CURLSHcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLSHE_OK:\n    return \"no error\";\n\n  case CURLSHE_BAD_OPTION:\n    return \"unknown share option\";\n\n  case CURLSHE_IN_USE:\n    return \"share currently in use\";\n\n  case CURLSHE_INVALID:\n    return \"invalid share handle\";\n\n  case CURLSHE_NOMEM:\n    return \"out of memory\";\n\n  case CURLSHE_LAST:\n    break;\n  }\n\n  return \"CURLSH unknown\";\n#else\n  if (error == CURLSHE_OK)\n    return \"no error\";\n  else\n    return \"error\";\n#endif\n}\n\n#ifdef USE_WINSOCK\n\n/* This function handles most / all (?) Winsock errors cURL is able to produce.\n */\nstatic const char *\nget_winsock_error (int err, char *buf, size_t len)\n{\n  const char *p;\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (err) {\n  case WSAEINTR:\n    p = \"Call interrupted.\";\n    break;\n  case WSAEBADF:\n    p = \"Bad file\";\n    break;\n  case WSAEACCES:\n    p = \"Bad access\";\n    break;\n  case WSAEFAULT:\n    p = \"Bad argument\";\n    break;\n  case WSAEINVAL:\n    p = \"Invalid arguments\";\n    break;\n  case WSAEMFILE:\n    p = \"Out of file descriptors\";\n    break;\n  case WSAEWOULDBLOCK:\n    p = \"Call would block\";\n    break;\n  case WSAEINPROGRESS:\n  case WSAEALREADY:\n    p = \"Blocking call in progress\";\n    break;\n  case WSAENOTSOCK:\n    p = \"Descriptor is not a socket.\";\n    break;\n  case WSAEDESTADDRREQ:\n    p = \"Need destination address\";\n    break;\n  case WSAEMSGSIZE:\n    p = \"Bad message size\";\n    break;\n  case WSAEPROTOTYPE:\n    p = \"Bad protocol\";\n    break;\n  case WSAENOPROTOOPT:\n    p = \"Protocol option is unsupported\";\n    break;\n  case WSAEPROTONOSUPPORT:\n    p = \"Protocol is unsupported\";\n    break;\n  case WSAESOCKTNOSUPPORT:\n    p = \"Socket is unsupported\";\n    break;\n  case WSAEOPNOTSUPP:\n    p = \"Operation not supported\";\n    break;\n  case WSAEAFNOSUPPORT:\n    p = \"Address family not supported\";\n    break;\n  case WSAEPFNOSUPPORT:\n    p = \"Protocol family not supported\";\n    break;\n  case WSAEADDRINUSE:\n    p = \"Address already in use\";\n    break;\n  case WSAEADDRNOTAVAIL:\n    p = \"Address not available\";\n    break;\n  case WSAENETDOWN:\n    p = \"Network down\";\n    break;\n  case WSAENETUNREACH:\n    p = \"Network unreachable\";\n    break;\n  case WSAENETRESET:\n    p = \"Network has been reset\";\n    break;\n  case WSAECONNABORTED:\n    p = \"Connection was aborted\";\n    break;\n  case WSAECONNRESET:\n    p = \"Connection was reset\";\n    break;\n  case WSAENOBUFS:\n    p = \"No buffer space\";\n    break;\n  case WSAEISCONN:\n    p = \"Socket is already connected\";\n    break;\n  case WSAENOTCONN:\n    p = \"Socket is not connected\";\n    break;\n  case WSAESHUTDOWN:\n    p = \"Socket has been shut down\";\n    break;\n  case WSAETOOMANYREFS:\n    p = \"Too many references\";\n    break;\n  case WSAETIMEDOUT:\n    p = \"Timed out\";\n    break;\n  case WSAECONNREFUSED:\n    p = \"Connection refused\";\n    break;\n  case WSAELOOP:\n    p = \"Loop??\";\n    break;\n  case WSAENAMETOOLONG:\n    p = \"Name too long\";\n    break;\n  case WSAEHOSTDOWN:\n    p = \"Host down\";\n    break;\n  case WSAEHOSTUNREACH:\n    p = \"Host unreachable\";\n    break;\n  case WSAENOTEMPTY:\n    p = \"Not empty\";\n    break;\n  case WSAEPROCLIM:\n    p = \"Process limit reached\";\n    break;\n  case WSAEUSERS:\n    p = \"Too many users\";\n    break;\n  case WSAEDQUOT:\n    p = \"Bad quota\";\n    break;\n  case WSAESTALE:\n    p = \"Something is stale\";\n    break;\n  case WSAEREMOTE:\n    p = \"Remote error\";\n    break;\n#ifdef WSAEDISCON  /* missing in SalfordC! */\n  case WSAEDISCON:\n    p = \"Disconnected\";\n    break;\n#endif\n    /* Extended Winsock errors */\n  case WSASYSNOTREADY:\n    p = \"Winsock library is not ready\";\n    break;\n  case WSANOTINITIALISED:\n    p = \"Winsock library not initialised\";\n    break;\n  case WSAVERNOTSUPPORTED:\n    p = \"Winsock version not supported.\";\n    break;\n\n    /* getXbyY() errors (already handled in herrmsg):\n     * Authoritative Answer: Host not found */\n  case WSAHOST_NOT_FOUND:\n    p = \"Host not found\";\n    break;\n\n    /* Non-Authoritative: Host not found, or SERVERFAIL */\n  case WSATRY_AGAIN:\n    p = \"Host not found, try again\";\n    break;\n\n    /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */\n  case WSANO_RECOVERY:\n    p = \"Unrecoverable error in call to nameserver\";\n    break;\n\n    /* Valid name, no data record of requested type */\n  case WSANO_DATA:\n    p = \"No data record of requested type\";\n    break;\n\n  default:\n    return NULL;\n  }\n#else\n  if (error == CURLE_OK)\n    return NULL;\n  else\n    p = \"error\";\n#endif\n  strncpy (buf, p, len);\n  buf [len-1] = '\\0';\n  return buf;\n}\n#endif   /* USE_WINSOCK */\n\n/*\n * Our thread-safe and smart strerror() replacement.\n *\n * The 'err' argument passed in to this function MUST be a true errno number\n * as reported on this system. We do no range checking on the number before\n * we pass it to the \"number-to-message\" convertion function and there might\n * be systems that don't do proper range checking in there themselves.\n *\n * We don't do range checking (on systems other than Windows) since there is\n * no good reliable and portable way to do it.\n */\nconst char *Curl_strerror(struct connectdata *conn, int err)\n{\n  char *buf, *p;\n  size_t max;\n\n  curlassert(conn);\n  curlassert(err >= 0);\n\n  buf = conn->syserr_buf;\n  max = sizeof(conn->syserr_buf)-1;\n  *buf = '\\0';\n\n#ifdef USE_WINSOCK\n\n#ifdef _WIN32_WCE\n  buf[0]=0;\n  {\n    wchar_t wbuf[256];\n\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,\n                  LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL);\n    wcstombs(buf,wbuf,max);\n  }\n\n#else\n\n  /* 'sys_nerr' is the maximum errno number, it is not widely portable */\n  if (err >= 0 && err < sys_nerr)\n    strncpy(buf, strerror(err), max);\n  else {\n    if (!get_winsock_error(err, buf, max) &&\n        !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,\n                       LANG_NEUTRAL, buf, (DWORD)max, NULL))\n      snprintf(buf, max, \"Unknown error %d (%#x)\", err, err);\n  }\n#endif\n#else /* not USE_WINSOCK coming up */\n\n  /* These should be atomic and hopefully thread-safe */\n#ifdef HAVE_STRERROR_R\n  /* There are two different APIs for strerror_r(). The POSIX and the GLIBC\n     versions. */\n#ifdef HAVE_POSIX_STRERROR_R\n  strerror_r(err, buf, max);\n  /* this may set errno to ERANGE if insufficient storage was supplied via\n     'strerrbuf' and 'buflen' to contain the generated message string, or\n     EINVAL if the value of 'errnum' is not a valid error number.*/\n#else\n  {\n    /* HAVE_GLIBC_STRERROR_R */\n    char buffer[256];\n    char *msg = strerror_r(err, buffer, sizeof(buffer));\n    /* this version of strerror_r() only *might* use the buffer we pass to\n       the function, but it always returns the error message as a pointer,\n       so we must copy that string unconditionally (if non-NULL) */\n    if(msg)\n      strncpy(buf, msg, max);\n    else\n      snprintf(buf, max, \"Unknown error %d\", err);\n  }\n#endif /* end of HAVE_GLIBC_STRERROR_R */\n#else /* HAVE_STRERROR_R */\n  strncpy(buf, strerror(err), max);\n#endif /* end of HAVE_STRERROR_R */\n#endif /* end of ! USE_WINSOCK */\n\n  buf[max] = '\\0'; /* make sure the string is zero terminated */\n\n  /* strip trailing '\\r\\n' or '\\n'. */\n  if ((p = strrchr(buf,'\\n')) != NULL && (p - buf) >= 2)\n     *p = '\\0';\n  if ((p = strrchr(buf,'\\r')) != NULL && (p - buf) >= 1)\n     *p = '\\0';\n  return buf;\n}\n\n#ifdef USE_LIBIDN\n/*\n * Return error-string for libidn status as returned from idna_to_ascii_lz().\n */\nconst char *Curl_idn_strerror (struct connectdata *conn, int err)\n{\n#ifdef HAVE_IDNA_STRERROR\n  (void)conn;\n  return idna_strerror((Idna_rc) err);\n#else\n  const char *str;\n  char *buf;\n  size_t max;\n\n  curlassert(conn);\n\n  buf = conn->syserr_buf;\n  max = sizeof(conn->syserr_buf)-1;\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch ((Idna_rc)err) {\n    case IDNA_SUCCESS:\n      str = \"No error\";\n      break;\n    case IDNA_STRINGPREP_ERROR:\n      str = \"Error in string preparation\";\n      break;\n    case IDNA_PUNYCODE_ERROR:\n      str = \"Error in Punycode operation\";\n      break;\n    case IDNA_CONTAINS_NON_LDH:\n      str = \"Illegal ASCII characters\";\n      break;\n    case IDNA_CONTAINS_MINUS:\n      str = \"Contains minus\";\n      break;\n    case IDNA_INVALID_LENGTH:\n      str = \"Invalid output length\";\n      break;\n    case IDNA_NO_ACE_PREFIX:\n      str = \"No ACE prefix (\\\"xn--\\\")\";\n      break;\n    case IDNA_ROUNDTRIP_VERIFY_ERROR:\n      str = \"Roundtrip verify error\";\n      break;\n    case IDNA_CONTAINS_ACE_PREFIX:\n      str = \"Already have ACE prefix (\\\"xn--\\\")\";\n      break;\n    case IDNA_ICONV_ERROR:\n      str = \"Locale conversion failed\";\n      break;\n    case IDNA_MALLOC_ERROR:\n      str = \"Allocation failed\";\n      break;\n    case IDNA_DLOPEN_ERROR:\n      str = \"dlopen() error\";\n      break;\n    default:\n      snprintf(buf, max, \"error %d\", (int)err);\n      str = NULL;\n      break;\n  }\n#else\n  if ((Idna_rc)err == IDNA_SUCCESS)\n    str = \"No error\";\n  else\n    str = \"error\";\n#endif\n  if (str)\n    strncpy(buf, str, max);\n  buf[max] = '\\0';\n  return (buf);\n#endif\n}\n#endif  /* USE_LIBIDN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/ldap.c": "/***************************************************************************\n *                      _   _ ____  _\n *  Project         ___| | | |  _ \\| |\n *                 / __| | | | |_) | |\n *                | (__| |_| |  _ <| |___\n *                 \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at http://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * $Id$\n ***************************************************************************/\n\n#include \"setup.h\"\n\n#ifndef CURL_DISABLE_LDAP\n/* -- WIN32 approved -- */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <ctype.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef NEED_MALLOC_H\n#include <malloc.h>\n#endif\n#include <errno.h>\n\n#if defined(WIN32)\n# include <winldap.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_DLFCN_H\n# include <dlfcn.h>\n#endif\n\n#include \"urldata.h\"\n#include <curl/curl.h>\n#include \"sendf.h\"\n#include \"escape.h\"\n#include \"transfer.h\"\n#include \"strequal.h\"\n#include \"strtok.h\"\n#include \"ldap.h\"\n#include \"memory.h\"\n#include \"base64.h\"\n\n#define _MPRINTF_REPLACE /* use our functions only */\n#include <curl/mprintf.h>\n\n#include \"memdebug.h\"\n\n/* WLdap32.dll functions are *not* stdcall. Must call these via __cdecl\n * pointers in case libcurl was compiled as fastcall (cl -Gr). Watcom\n * uses fastcall by default.\n */\n#if !defined(WIN32) && !defined(__cdecl)\n#define __cdecl\n#endif\n\n#ifndef LDAP_SIZELIMIT_EXCEEDED\n#define LDAP_SIZELIMIT_EXCEEDED 4\n#endif\n#ifndef LDAP_VERSION2\n#define LDAP_VERSION2 2\n#endif\n#ifndef LDAP_VERSION3\n#define LDAP_VERSION3 3\n#endif\n#ifndef LDAP_OPT_PROTOCOL_VERSION\n#define LDAP_OPT_PROTOCOL_VERSION 0x0011\n#endif\n\n#define DLOPEN_MODE   RTLD_LAZY  /*! assume all dlopen() implementations have\n                                   this */\n\n#if defined(RTLD_LAZY_GLOBAL)    /* It turns out some systems use this: */\n# undef  DLOPEN_MODE\n# define DLOPEN_MODE  RTLD_LAZY_GLOBAL\n#elif defined(RTLD_GLOBAL)\n# undef  DLOPEN_MODE\n# define DLOPEN_MODE  (RTLD_LAZY | RTLD_GLOBAL)\n#endif\n\n#define DYNA_GET_FUNCTION(type, fnc) do { \\\n          (fnc) = (type)DynaGetFunction(#fnc); \\\n          if ((fnc) == NULL) \\\n             return CURLE_FUNCTION_NOT_FOUND; \\\n        } while (0)\n\n/*! CygWin etc. configure could set these, but we don't want it.\n * Must use WLdap32.dll code.\n */\n#if defined(WIN32)\n#undef HAVE_DLOPEN\n#undef HAVE_LIBDL\n#endif\n\n/* \n * We use this ZERO_NULL to avoid picky compiler warnings,\n * when assigning a NULL pointer to a function pointer var.\n */\n\n#define ZERO_NULL 0\n\ntypedef void * (*dynafunc)(void *input);\n\n/***********************************************************************\n */\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL) || defined(WIN32)\nstatic void *libldap = NULL;\n#if defined(DL_LBER_FILE)\nstatic void *liblber = NULL;\n#endif\n#endif\n\nstruct bv {\n  unsigned long bv_len;\n  char  *bv_val;\n};\n\nstatic int DynaOpen(const char **mod_name)\n{\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap == NULL) {\n    /*\n     * libldap.so can normally resolve its dependency on liblber.so\n     * automatically, but in broken installation it does not so\n     * handle it here by opening liblber.so as global.\n     */\n#ifdef DL_LBER_FILE\n    *mod_name = DL_LBER_FILE;\n    liblber = dlopen(*mod_name, DLOPEN_MODE);\n    if (!liblber)\n      return 0;\n#endif\n\n    /* Assume loading libldap.so will fail if loading of liblber.so failed\n     */\n    *mod_name = DL_LDAP_FILE;\n    libldap = dlopen(*mod_name, RTLD_LAZY);\n  }\n  return (libldap != NULL);\n\n#elif defined(WIN32)\n  *mod_name = DL_LDAP_FILE;\n  if (!libldap)\n    libldap = (void*)LoadLibrary(*mod_name);\n  return (libldap != NULL);\n\n#else\n  *mod_name = \"\";\n  return (0);\n#endif\n}\n\nstatic void DynaClose(void)\n{\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap) {\n    dlclose(libldap);\n    libldap=NULL;\n  }\n#ifdef DL_LBER_FILE\n  if (liblber) {\n    dlclose(liblber);\n    liblber=NULL;\n  }\n#endif\n#elif defined(WIN32)\n  if (libldap) {\n    FreeLibrary ((HMODULE)libldap);\n    libldap = NULL;\n  }\n#endif\n}\n\nstatic dynafunc DynaGetFunction(const char *name)\n{\n  dynafunc func = (dynafunc)ZERO_NULL;\n\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap) {\n    /* This typecast magic below was brought by Joe Halpin. In ISO C, you\n     * cannot typecast a data pointer to a function pointer, but that's\n     * exactly what we need to do here to avoid compiler warnings on picky\n     * compilers! */\n    *(void**) (&func) = dlsym(libldap, name);\n  }\n#elif defined(WIN32)\n  if (libldap) {\n    func = (dynafunc)GetProcAddress((HINSTANCE)libldap, name);\n  }\n#else\n  (void) name;\n#endif\n  return func;\n}\n\n/***********************************************************************\n */\ntypedef struct ldap_url_desc {\n    struct ldap_url_desc *lud_next;\n    char   *lud_scheme;\n    char   *lud_host;\n    int     lud_port;\n    char   *lud_dn;\n    char  **lud_attrs;\n    int     lud_scope;\n    char   *lud_filter;\n    char  **lud_exts;\n    int     lud_crit_exts;\n} LDAPURLDesc;\n\n#ifdef WIN32\nstatic int  _ldap_url_parse (const struct connectdata *conn,\n                             LDAPURLDesc **ludp);\nstatic void _ldap_free_urldesc (LDAPURLDesc *ludp);\n\nstatic void (*ldap_free_urldesc)(LDAPURLDesc *) = _ldap_free_urldesc;\n#endif\n\n#ifdef DEBUG_LDAP\n  #define LDAP_TRACE(x)   do { \\\n                            _ldap_trace (\"%u: \", __LINE__); \\\n                            _ldap_trace x; \\\n                          } while (0)\n\n  static void _ldap_trace (const char *fmt, ...);\n#else\n  #define LDAP_TRACE(x)   ((void)0)\n#endif\n\n\nCURLcode Curl_ldap(struct connectdata *conn, bool *done)\n{\n  CURLcode status = CURLE_OK;\n  int rc = 0;\n#ifndef WIN32\n  int    (*ldap_url_parse)(char *, LDAPURLDesc **);\n  void   (*ldap_free_urldesc)(void *);\n#endif\n  void  *(__cdecl *ldap_init)(char *, int);\n  int    (__cdecl *ldap_simple_bind_s)(void *, char *, char *);\n  int    (__cdecl *ldap_unbind_s)(void *);\n  int    (__cdecl *ldap_search_s)(void *, char *, int, char *, char **,\n                                  int, void **);\n  void  *(__cdecl *ldap_first_entry)(void *, void *);\n  void  *(__cdecl *ldap_next_entry)(void *, void *);\n  char  *(__cdecl *ldap_err2string)(int);\n  char  *(__cdecl *ldap_get_dn)(void *, void *);\n  char  *(__cdecl *ldap_first_attribute)(void *, void *, void **);\n  char  *(__cdecl *ldap_next_attribute)(void *, void *, void *);\n  void **(__cdecl *ldap_get_values_len)(void *, void *, const char *);\n  void   (__cdecl *ldap_value_free_len)(void **);\n  void   (__cdecl *ldap_memfree)(void *);\n  void   (__cdecl *ber_free)(void *, int);\n  int    (__cdecl *ldap_set_option)(void *, int, void *);\n\n  void *server;\n  LDAPURLDesc *ludp = NULL;\n  const char *mod_name;\n  void *result;\n  void *entryIterator;     /*! type should be 'LDAPMessage *' */\n  int num = 0;\n  struct SessionHandle *data=conn->data;\n  int ldap_proto;\n  char *val_b64;\n  size_t val_b64_sz;\n\n  *done = TRUE; /* unconditionally */\n  infof(data, \"LDAP local: %s\\n\", data->change.url);\n\n  if (!DynaOpen(&mod_name)) {\n    failf(data, \"The %s LDAP library/libraries couldn't be opened\", mod_name);\n    return CURLE_LIBRARY_NOT_FOUND;\n  }\n\n  /* The types are needed because ANSI C distinguishes between\n   * pointer-to-object (data) and pointer-to-function.\n   */\n  DYNA_GET_FUNCTION(void *(__cdecl *)(char *, int), ldap_init);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, char *, char *),\n                    ldap_simple_bind_s);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *), ldap_unbind_s);\n#ifndef WIN32\n  DYNA_GET_FUNCTION(int (*)(char *, LDAPURLDesc **), ldap_url_parse);\n  DYNA_GET_FUNCTION(void (*)(void *), ldap_free_urldesc);\n#endif\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, char *, int, char *, char **, int,\n                                    void **), ldap_search_s);\n  DYNA_GET_FUNCTION(void *(__cdecl *)(void *, void *), ldap_first_entry);\n  DYNA_GET_FUNCTION(void *(__cdecl *)(void *, void *), ldap_next_entry);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(int), ldap_err2string);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *), ldap_get_dn);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *, void **),\n                    ldap_first_attribute);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *, void *),\n                    ldap_next_attribute);\n  DYNA_GET_FUNCTION(void **(__cdecl *)(void *, void *, const char *),\n                    ldap_get_values_len);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void **), ldap_value_free_len);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void *), ldap_memfree);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void *, int), ber_free);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, int, void *), ldap_set_option);\n\n  server = (*ldap_init)(conn->host.name, (int)conn->port);\n  if (server == NULL) {\n    failf(data, \"LDAP local: Cannot connect to %s:%d\",\n          conn->host.name, conn->port);\n    status = CURLE_COULDNT_CONNECT;\n    goto quit;\n  }\n\n  ldap_proto = LDAP_VERSION3;\n  (*ldap_set_option)(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);\n  rc = (*ldap_simple_bind_s)(server,\n                             conn->bits.user_passwd ? conn->user : NULL,\n                             conn->bits.user_passwd ? conn->passwd : NULL);\n  if (rc != 0) {\n    ldap_proto = LDAP_VERSION2;\n    (*ldap_set_option)(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);\n    rc = (*ldap_simple_bind_s)(server,\n                               conn->bits.user_passwd ? conn->user : NULL,\n                               conn->bits.user_passwd ? conn->passwd : NULL);\n  }\n  if (rc != 0) {\n     failf(data, \"LDAP local: %s\", (*ldap_err2string)(rc));\n     status = CURLE_LDAP_CANNOT_BIND;\n     goto quit;\n  }\n\n#ifdef WIN32\n  rc = _ldap_url_parse(conn, &ludp);\n#else\n  rc = (*ldap_url_parse)(data->change.url, &ludp);\n#endif\n\n  if (rc != 0) {\n     failf(data, \"LDAP local: %s\", (*ldap_err2string)(rc));\n     status = CURLE_LDAP_INVALID_URL;\n     goto quit;\n  }\n\n  rc = (*ldap_search_s)(server, ludp->lud_dn, ludp->lud_scope,\n                        ludp->lud_filter, ludp->lud_attrs, 0, &result);\n\n  if (rc != 0 && rc != LDAP_SIZELIMIT_EXCEEDED) {\n    failf(data, \"LDAP remote: %s\", (*ldap_err2string)(rc));\n    status = CURLE_LDAP_SEARCH_FAILED;\n    goto quit;\n  }\n\n  for(num = 0, entryIterator = (*ldap_first_entry)(server, result);\n      entryIterator;\n      entryIterator = (*ldap_next_entry)(server, entryIterator), num++)\n  {\n    void  *ber = NULL;      /*! is really 'BerElement **' */\n    void  *attribute;       /*! suspicious that this isn't 'const' */\n    char  *dn = (*ldap_get_dn)(server, entryIterator);\n    int i;\n\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"DN: \", 4);\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)dn, 0);\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 1);\n\n    for (attribute = (*ldap_first_attribute)(server, entryIterator, &ber);\n         attribute;\n         attribute = (*ldap_next_attribute)(server, entryIterator, ber))\n    {\n      struct bv **vals = (struct bv **)\n        (*ldap_get_values_len)(server, entryIterator, attribute);\n\n      if (vals != NULL)\n      {\n        for (i = 0; (vals[i] != NULL); i++)\n        {\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\t\", 1);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *) attribute, 0);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\": \", 2);\n          if ((strlen(attribute) > 7) &&\n              (strcmp(\";binary\",\n                      (char *)attribute +\n                      (strlen((char *)attribute) - 7)) == 0)) {\n            /* Binary attribute, encode to base64. */\n            val_b64_sz = Curl_base64_encode(conn->data,\n                                            vals[i]->bv_val,\n                                            vals[i]->bv_len,\n                                            &val_b64);\n            if (val_b64_sz > 0) {\n              Curl_client_write(conn, CLIENTWRITE_BODY, val_b64, val_b64_sz);\n              free(val_b64);\n            }\n          } else\n            Curl_client_write(conn, CLIENTWRITE_BODY, vals[i]->bv_val,\n                              vals[i]->bv_len);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 0);\n        }\n\n        /* Free memory used to store values */\n        (*ldap_value_free_len)((void **)vals);\n      }\n      Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 1);\n\n      (*ldap_memfree)(attribute);\n    }\n    (*ldap_memfree)(dn);\n    if (ber)\n       (*ber_free)(ber, 0);\n  }\n\nquit:\n  LDAP_TRACE ((\"Received %d entries\\n\", num));\n  if (rc == LDAP_SIZELIMIT_EXCEEDED)\n     infof(data, \"There are more than %d entries\\n\", num);\n  if (ludp)\n     (*ldap_free_urldesc)(ludp);\n  if (server)\n     (*ldap_unbind_s)(server);\n\n  DynaClose();\n\n  /* no data to transfer */\n  Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n  conn->bits.close = TRUE;\n\n  return status;\n}\n\n#ifdef DEBUG_LDAP\nstatic void _ldap_trace (const char *fmt, ...)\n{\n  static int do_trace = -1;\n  va_list args;\n\n  if (do_trace == -1) {\n    const char *env = getenv(\"CURL_TRACE\");\n    do_trace = (env && atoi(env) > 0);\n  }\n  if (!do_trace)\n    return;\n\n  va_start (args, fmt);\n  vfprintf (stderr, fmt, args);\n  va_end (args);\n}\n#endif\n\n#ifdef WIN32\n/*\n * Return scope-value for a scope-string.\n */\nstatic int str2scope (const char *p)\n{\n  if (!stricmp(p, \"one\"))\n     return LDAP_SCOPE_ONELEVEL;\n  if (!stricmp(p, \"onetree\"))\n     return LDAP_SCOPE_ONELEVEL;\n  if (!stricmp(p, \"base\"))\n     return LDAP_SCOPE_BASE;\n  if (!stricmp(p, \"sub\"))\n     return LDAP_SCOPE_SUBTREE;\n  if (!stricmp( p, \"subtree\"))\n     return LDAP_SCOPE_SUBTREE;\n  return (-1);\n}\n\n/*\n * Split 'str' into strings separated by commas.\n * Note: res[] points into 'str'.\n */\nstatic char **split_str (char *str)\n{\n  char **res, *lasts, *s;\n  int  i;\n\n  for (i = 2, s = strchr(str,','); s; i++)\n     s = strchr(++s,',');\n\n  res = calloc(i, sizeof(char*));\n  if (!res)\n    return NULL;\n\n  for (i = 0, s = strtok_r(str, \",\", &lasts); s;\n       s = strtok_r(NULL, \",\", &lasts), i++)\n    res[i] = s;\n  return res;\n}\n\n/*\n * Unescape the LDAP-URL components\n */\nstatic bool unescape_elements (void *data, LDAPURLDesc *ludp)\n{\n  int i;\n\n  if (ludp->lud_filter) {\n    ludp->lud_filter = curl_easy_unescape(data, ludp->lud_filter, 0, NULL);\n    if (!ludp->lud_filter)\n       return (FALSE);\n  }\n\n  for (i = 0; ludp->lud_attrs && ludp->lud_attrs[i]; i++) {\n    ludp->lud_attrs[i] = curl_easy_unescape(data, ludp->lud_attrs[i], 0, NULL);\n    if (!ludp->lud_attrs[i])\n       return (FALSE);\n  }\n\n  for (i = 0; ludp->lud_exts && ludp->lud_exts[i]; i++) {\n    ludp->lud_exts[i] = curl_easy_unescape(data, ludp->lud_exts[i], 0, NULL);\n    if (!ludp->lud_exts[i])\n       return (FALSE);\n  }\n\n  if (ludp->lud_dn) {\n    char *dn = ludp->lud_dn;\n    char *new_dn = curl_easy_unescape(data, dn, 0, NULL);\n\n    free(dn);\n    ludp->lud_dn = new_dn;\n    if (!new_dn)\n       return (FALSE);\n  }\n  return (TRUE);\n}\n\n/*\n * Break apart the pieces of an LDAP URL.\n * Syntax:\n *   ldap://<hostname>:<port>/<base_dn>?<attributes>?<scope>?<filter>?<ext>\n *\n * <hostname> already known from 'conn->host.name'.\n * <port>     already known from 'conn->remote_port'.\n * extract the rest from 'conn->data->reqdata.path+1'. All fields are optional.\n * e.g.\n *   ldap://<hostname>:<port>/?<attributes>?<scope>?<filter>\n * yields ludp->lud_dn = \"\".\n *\n * Ref. http://developer.netscape.com/docs/manuals/dirsdk/csdk30/url.htm#2831915\n */\nstatic int _ldap_url_parse2 (const struct connectdata *conn, LDAPURLDesc *ludp)\n{\n  char *p, *q;\n  int i;\n\n  if (!conn->data ||\n      !conn->data->reqdata.path ||\n       conn->data->reqdata.path[0] != '/' ||\n      !checkprefix(conn->protostr, conn->data->change.url))\n     return LDAP_INVALID_SYNTAX;\n\n  ludp->lud_scope = LDAP_SCOPE_BASE;\n  ludp->lud_port  = conn->remote_port;\n  ludp->lud_host  = conn->host.name;\n\n  /* parse DN (Distinguished Name).\n   */\n  ludp->lud_dn = strdup(conn->data->reqdata.path+1);\n  if (!ludp->lud_dn)\n     return LDAP_NO_MEMORY;\n\n  p = strchr(ludp->lud_dn, '?');\n  LDAP_TRACE ((\"DN '%.*s'\\n\", p ? (size_t)(p-ludp->lud_dn) :\n               strlen(ludp->lud_dn), ludp->lud_dn));\n\n  if (!p)\n     goto success;\n\n  *p++ = '\\0';\n\n  /* parse attributes. skip \"??\".\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n\n  if (*p && *p != '?') {\n    ludp->lud_attrs = split_str(p);\n    if (!ludp->lud_attrs)\n       return LDAP_NO_MEMORY;\n\n    for (i = 0; ludp->lud_attrs[i]; i++)\n        LDAP_TRACE ((\"attr[%d] '%s'\\n\", i, ludp->lud_attrs[i]));\n  }\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse scope. skip \"??\"\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n\n  if (*p && *p != '?') {\n    ludp->lud_scope = str2scope(p);\n    if (ludp->lud_scope == -1)\n       return LDAP_INVALID_SYNTAX;\n    LDAP_TRACE ((\"scope %d\\n\", ludp->lud_scope));\n  }\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse filter\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n  if (!*p)\n     return LDAP_INVALID_SYNTAX;\n\n  ludp->lud_filter = p;\n  LDAP_TRACE ((\"filter '%s'\\n\", ludp->lud_filter));\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse extensions\n   */\n  ludp->lud_exts = split_str(p);\n  if (!ludp->lud_exts)\n     return LDAP_NO_MEMORY;\n\n  for (i = 0; ludp->lud_exts[i]; i++)\n      LDAP_TRACE ((\"exts[%d] '%s'\\n\", i, ludp->lud_exts[i]));\n\nsuccess:\n  if (!unescape_elements(conn->data, ludp))\n     return LDAP_NO_MEMORY;\n  return LDAP_SUCCESS;\n}\n\nstatic int _ldap_url_parse (const struct connectdata *conn,\n                            LDAPURLDesc **ludpp)\n{\n  LDAPURLDesc *ludp = calloc(sizeof(*ludp), 1);\n  int rc;\n\n  *ludpp = NULL;\n  if (!ludp)\n     return LDAP_NO_MEMORY;\n\n  rc = _ldap_url_parse2 (conn, ludp);\n  if (rc != LDAP_SUCCESS) {\n    _ldap_free_urldesc(ludp);\n    ludp = NULL;\n  }\n  *ludpp = ludp;\n  return (rc);\n}\n\nstatic void _ldap_free_urldesc (LDAPURLDesc *ludp)\n{\n  int i;\n\n  if (!ludp)\n     return;\n\n  if (ludp->lud_dn)\n     free(ludp->lud_dn);\n\n  if (ludp->lud_filter)\n     free(ludp->lud_filter);\n\n  if (ludp->lud_attrs) {\n    for (i = 0; ludp->lud_attrs[i]; i++)\n       free(ludp->lud_attrs[i]);\n    free(ludp->lud_attrs);\n  }\n\n  if (ludp->lud_exts) {\n    for (i = 0; ludp->lud_exts[i]; i++)\n       free(ludp->lud_exts[i]);\n    free(ludp->lud_exts);\n  }\n  free (ludp);\n}\n#endif  /* WIN32 */\n#endif  /* CURL_DISABLE_LDAP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/CMakeLists.txt": "CMAKE_MINIMUM_REQUIRED(VERSION 2.6.3 FATAL_ERROR)\nIF(POLICY CMP0025)\n  CMAKE_POLICY(SET CMP0025 NEW)\nENDIF()\nPROJECT(LIBCURL C)\n\n# Setup package meta-data\nSET(PACKAGE \"curl\")\nSET(VERSION \"7.16.1\")\nSET(PACKAGE_TARNAME \"curl\")\nSET(PACKAGE_BUGREPORT \" \")\nSET(PACKAGE_NAME \"curl\")\nSET(PACKAGE_VERSION \"-\")\nSET(PACKAGE_STRING \"curl-\")\nSET(PACKAGE_BUGREPORT \"a suitable curl mailing list => http://curl.haxx.se/mail/\")\nSET(OPERATING_SYSTEM \"${CMAKE_SYSTEM_NAME}\")\n\n# We need ansi c-flags, especially on HP\nSET(CMAKE_C_FLAGS \"${CMAKE_ANSI_CFLAGS} ${CMAKE_C_FLAGS}\")\nSET(CMAKE_REQUIRED_FLAGS ${CMAKE_ANSI_CFLAGS})\n\n# Disable warnings on Borland to avoid changing 3rd party code.\nIF(BORLAND)\n  SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -w-\")\nENDIF(BORLAND)\n\n# If we are on AIX, do the _ALL_SOURCE magic\nIF(${CMAKE_SYSTEM_NAME} MATCHES AIX)\n  SET(_ALL_SOURCE 1)\nENDIF(${CMAKE_SYSTEM_NAME} MATCHES AIX)\n\n# Include all the necessary files for macros\nSET(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/CMake\")\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckIncludeFile)\nINCLUDE (CheckIncludeFiles)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckSymbolExists)\nINCLUDE (CheckTypeSize)\n\nSET(libCurl_SRCS\n  #  amigaos.c - does not build on AmigaOS\n  base64.c\n  connect.c\n  content_encoding.c\n  cookie.c\n  dict.c\n  easy.c\n  escape.c\n  file.c\n  formdata.c\n  ftp.c\n  getenv.c\n  getinfo.c\n  gtls.c\n  hash.c\n  hostares.c\n  hostasyn.c\n  hostip4.c\n  hostip6.c\n  hostip.c\n  hostsyn.c\n  hostthre.c\n  http.c\n  http_chunks.c\n  http_digest.c\n  http_negotiate.c\n  http_ntlm.c\n  if2ip.c\n  inet_ntop.c\n  inet_pton.c\n  krb4.c\n  ldap.c\n  llist.c\n  md5.c\n#  memdebug.c -not used\n  mprintf.c\n  multi.c\n  netrc.c\n  # nwlib.c - Not used\n  parsedate.c\n  progress.c\n  security.c\n  select.c\n  sendf.c\n  share.c\n  socks.c\n  speedcheck.c\n  splay.c\n  ssh.c\n  sslgen.c\n  ssluse.c\n  strdup.c\n  strequal.c\n  strerror.c\n  # strtok.c - specify later\n  # strtoofft.c - specify later\n  telnet.c\n  tftp.c\n  timeval.c\n  transfer.c\n  url.c\n  version.c\n  )\n\nSET(CURL_DISABLE_LDAP 1)\nIF(NOT CURL_DISABLE_LDAP)\n  SET(libCurl_SRCS\n    ${libCurl_SRCS}\n    ldap.c\n    )\nENDIF(NOT CURL_DISABLE_LDAP)\n\n# if we have Kerberos 4, right now this is never on\n#OPTION(CURL_KRB4 \"Use Kerberos 4\" OFF)\nIF(CURL_KRB4)\n  SET(libCurl_SRCS ${libCurl_SRCS}\n    krb4.c\n    security.c\n    )\nENDIF(CURL_KRB4)\n\n#OPTION(CURL_MALLOC_DEBUG \"Debug mallocs in Curl\" OFF)\nMARK_AS_ADVANCED(CURL_MALLOC_DEBUG)\nIF(CURL_MALLOC_DEBUG)\n  SET(libCurl_SRCS ${libCurl_SRCS}\n    memdebug.c\n    )\nENDIF(CURL_MALLOC_DEBUG)\n\n# On windows preload settings\nIF(WIN32 AND NOT MINGW)\n  INCLUDE(${LIBCURL_SOURCE_DIR}/Platforms/WindowsCache.cmake)\nENDIF()\n\n# This macro checks if the symbol exists in the library and if it\n# does, it appends library to the list.\nSET(CURL_LIBS \"\")\nMACRO(CHECK_LIBRARY_EXISTS_CONCAT LIBRARY SYMBOL VARIABLE)\n  CHECK_LIBRARY_EXISTS(\"${LIBRARY};${CURL_LIBS}\" ${SYMBOL} \"\"\n    ${VARIABLE})\n  IF(${VARIABLE})\n    SET(CURL_LIBS ${CURL_LIBS} ${LIBRARY})\n  ENDIF(${VARIABLE})\nENDMACRO(CHECK_LIBRARY_EXISTS_CONCAT)\n\n# Check for all needed libraries\n# use the cmake defined dl libs as dl is should not be used\n# on HPUX, but rather dld this avoids a warning\nSET(CURL_LIBS ${CURL_LIBS} ${CMAKE_DL_LIBS})\n#CHECK_LIBRARY_EXISTS_CONCAT(\"dl\"     dlopen       HAVE_LIBDL)\n#CHECK_LIBRARY_EXISTS_CONCAT(\"ucb\"    gethostname  HAVE_LIBUCB)\nCHECK_LIBRARY_EXISTS_CONCAT(\"socket\" connect      HAVE_LIBSOCKET)\nCHECK_LIBRARY_EXISTS(\"c\" gethostbyname \"\" NOT_NEED_LIBNSL)\n\n# Yellowtab Zeta needs different libraries than BeOS 5.\nIF(BEOS)\n  SET(NOT_NEED_LIBNSL 1)\n  CHECK_LIBRARY_EXISTS_CONCAT(\"bind\" gethostbyname HAVE_LIBBIND)\n  CHECK_LIBRARY_EXISTS_CONCAT(\"bnetapi\" closesocket HAVE_LIBBNETAPI)\nENDIF(BEOS)\n\nCHECK_LIBRARY_EXISTS_CONCAT(\"network\" recv HAVE_LIBNETWORK)\n\nIF(NOT NOT_NEED_LIBNSL)\n  CHECK_LIBRARY_EXISTS_CONCAT(\"nsl\"    gethostbyname  HAVE_LIBNSL)\nENDIF(NOT NOT_NEED_LIBNSL)\n\nCHECK_LIBRARY_EXISTS_CONCAT(\"ws2_32\" getch        HAVE_LIBWS2_32)\nCHECK_LIBRARY_EXISTS_CONCAT(\"winmm\"  getch        HAVE_LIBWINMM)\nIF(NOT CURL_SPECIAL_LIBZ)\n  CHECK_LIBRARY_EXISTS_CONCAT(\"z\"      inflateEnd   HAVE_LIBZ)\nENDIF(NOT CURL_SPECIAL_LIBZ)\n\n# Include the local directories before any others so that we do not end up\n# including system curl's include directory first by mistake.\nINCLUDE_DIRECTORIES(${LIBCURL_SOURCE_DIR})\nINCLUDE_DIRECTORIES(${LIBCURL_BINARY_DIR})\n\nOPTION(CMAKE_USE_OPENSSL \"Use OpenSSL code with curl.\" OFF)\nMARK_AS_ADVANCED(CMAKE_USE_OPENSSL)\nIF(CMAKE_USE_OPENSSL)\n  SET(USE_SSLEAY TRUE)\n  SET(USE_OPENSSL TRUE)\n  FIND_PACKAGE(OpenSSL REQUIRED)\n  INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})\n  SET(CURL_LIBS  ${CURL_LIBS} ${OPENSSL_LIBRARIES})\n  SET(CURL_CA_BUNDLE \"\" CACHE FILEPATH \"Path to SSL CA Certificate Bundle\")\n  MARK_AS_ADVANCED(CURL_CA_BUNDLE)\n  IF(CURL_CA_BUNDLE)\n    ADD_DEFINITIONS(-DCURL_CA_BUNDLE=\"${CURL_CA_BUNDLE}\")\n  ENDIF(CURL_CA_BUNDLE)\n  # for windows we want to install OPENSSL_LIBRARIES dlls\n  # and also copy them into the build tree so that testing\n  # can find them.\n  IF(WIN32)\n    FIND_FILE(CMAKE_EAY_DLL NAME libeay32.dll HINTS ${OPENSSL_INCLUDE_DIR}/..)\n    FIND_FILE(CMAKE_SSL_DLL NAME ssleay32.dll HINTS ${OPENSSL_INCLUDE_DIR}/..)\n    MARK_AS_ADVANCED(CMAKE_EAY_DLL CMAKE_SSL_DLL)\n    IF(CMAKE_SSL_DLL AND CMAKE_EAY_DLL)\n      SET(CMAKE_CURL_SSL_DLLS ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll\n        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll)\n      ADD_CUSTOM_COMMAND(OUTPUT\n        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll\n        DEPENDS ${CMAKE_EAY_DLL}\n        COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_EAY_DLL}\n        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/libeay32.dll)\n      ADD_CUSTOM_COMMAND(OUTPUT\n        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll\n        DEPENDS ${CMAKE_SSL_DLL}\n        COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_SSL_DLL}\n        ${CMake_BIN_DIR}/${CMAKE_CFG_INTDIR}/ssleay32.dll)\n      INSTALL(PROGRAMS ${CMAKE_EAY_DLL} ${CMAKE_SSL_DLL} DESTINATION bin)\n    ENDIF()\n  ENDIF()\nENDIF(CMAKE_USE_OPENSSL)\n\n# Check for idn\nCHECK_LIBRARY_EXISTS_CONCAT(\"idn\" idna_to_ascii_lz HAVE_LIBIDN)\n\n# Check for symbol dlopen (same as HAVE_LIBDL)\nCHECK_LIBRARY_EXISTS(\"${CURL_LIBS}\" dlopen \"\" HAVE_DLOPEN)\n\n# For other tests to use the same libraries\nSET(CMAKE_REQUIRED_LIBRARIES ${CURL_LIBS})\n\nIF(CURL_SPECIAL_LIBZ)\n  SET(CURL_LIBS ${CURL_LIBS} \"${CURL_SPECIAL_LIBZ}\")\n  INCLUDE_DIRECTORIES(${CURL_SPECIAL_LIBZ_INCLUDES})\n  SET(HAVE_LIBZ 0)\n  SET(HAVE_ZLIB_H 0)\nENDIF(CURL_SPECIAL_LIBZ)\n\n# do we have process.h\nCHECK_INCLUDE_FILE(\"process.h\" HAVE_PROCESS_H)\n\n# If we have features.h, then do the _BSD_SOURCE magic\nCHECK_INCLUDE_FILE(\"features.h\"       HAVE_FEATURES_H)\nIF(HAVE_FEATURES_H)\n  SET_SOURCE_FILES_PROPERTIES(\n    cookie.c\n    easy.c\n    formdata.c\n    getenv.c\n    hash.c\n    http.c\n    if2ip.c\n    mprintf.c\n    multi.c\n    sendf.c\n    telnet.c\n    transfer.c\n    url.c\n    COMPILE_FLAGS -D_BSD_SOURCE)\nENDIF(HAVE_FEATURES_H)\n\n# Check if header file exists and add it to the list.\nMACRO(CHECK_INCLUDE_FILE_CONCAT FILE VARIABLE)\n  CHECK_INCLUDE_FILES(\"${CURL_INCLUDES};${FILE}\" ${VARIABLE})\n  IF(${VARIABLE})\n    SET(CURL_INCLUDES ${CURL_INCLUDES} ${FILE})\n  ENDIF(${VARIABLE})\nENDMACRO(CHECK_INCLUDE_FILE_CONCAT)\n\n# Check for header files\nIF(UNIX)\n  SET(HAVE_WINDOWS_H 0)\n  SET(HAVE_WINSOCK_H 0)\n  SET(HAVE_WS2TCPIP_H 0)\n  SET(HAVE_WINSOCK2_H 0)\nENDIF(UNIX)\nIF(NOT UNIX)\n  CHECK_INCLUDE_FILE_CONCAT(\"ws2tcpip.h\"     HAVE_WS2TCPIP_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"winsock2.h\"     HAVE_WINSOCK2_H)\nENDIF(NOT UNIX)\nCHECK_INCLUDE_FILE_CONCAT(\"stdio.h\"          HAVE_STDIO_H)\nIF(NOT UNIX)\n  CHECK_INCLUDE_FILE_CONCAT(\"windows.h\"      HAVE_WINDOWS_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"winsock.h\"      HAVE_WINSOCK_H)\nENDIF(NOT UNIX)\nCHECK_INCLUDE_FILE_CONCAT(\"stddef.h\"         HAVE_STDDEF_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/types.h\"      HAVE_SYS_TYPES_H)\nCHECK_INCLUDE_FILE_CONCAT(\"inttypes.h\"       HAVE_INTTYPES_H)\nCHECK_INCLUDE_FILE_CONCAT(\"alloca.h\"         HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILE_CONCAT(\"arpa/inet.h\"      HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILE_CONCAT(\"dlfcn.h\"          HAVE_DLFCN_H)\nCHECK_INCLUDE_FILE_CONCAT(\"fcntl.h\"          HAVE_FCNTL_H)\nCHECK_INCLUDE_FILE_CONCAT(\"malloc.h\"         HAVE_MALLOC_H)\nCHECK_INCLUDE_FILE_CONCAT(\"memory.h\"         HAVE_MEMORY_H)\nCHECK_INCLUDE_FILE_CONCAT(\"netdb.h\"          HAVE_NETDB_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/poll.h\"       HAVE_SYS_POLL_H)\nCHECK_INCLUDE_FILE_CONCAT(\"assert.h\"         HAVE_ASSERT_H)\nCHECK_INCLUDE_FILE_CONCAT(\"limits.h\"         HAVE_LIMITS_H)\n\nIF(CMAKE_USE_OPENSSL)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/x509.h\"   HAVE_OPENSSL_X509_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/engine.h\" HAVE_OPENSSL_ENGINE_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/rsa.h\"    HAVE_OPENSSL_RSA_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/crypto.h\" HAVE_OPENSSL_CRYPTO_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/pem.h\"    HAVE_OPENSSL_PEM_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/ssl.h\"    HAVE_OPENSSL_SSL_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/err.h\"    HAVE_OPENSSL_ERR_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/rand.h\"   HAVE_OPENSSL_RAND_H)\n  CHECK_INCLUDE_FILE_CONCAT(\"openssl/pkcs12.h\" HAVE_OPENSSL_PKCS12_H)\nENDIF(CMAKE_USE_OPENSSL)\n\nIF(NOT CURL_SPECIAL_LIBZ)\n  CHECK_INCLUDE_FILE_CONCAT(\"zlib.h\"           HAVE_ZLIB_H)\nENDIF(NOT CURL_SPECIAL_LIBZ)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/socket.h\"     HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILE_CONCAT(\"netinet/in.h\"     HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILE_CONCAT(\"net/if.h\"         HAVE_NET_IF_H)\nCHECK_INCLUDE_FILE_CONCAT(\"netinet/if_ether.h\"\n  HAVE_NETINET_IF_ETHER_H)\nCHECK_INCLUDE_FILE_CONCAT(\"netinet/tcp.h\"\n  HAVE_NETINET_TCP_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/select.h\"    HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILE_CONCAT(\"utime.h\"         HAVE_UTIME_H)\nCHECK_INCLUDE_FILE_CONCAT(\"netinet/in.h\"    HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILE_CONCAT(\"pwd.h\"           HAVE_PWD_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sgtty.h\"         HAVE_SGTTY_H)\nCHECK_INCLUDE_FILE_CONCAT(\"stdint.h\"        HAVE_STDINT_H)\nCHECK_INCLUDE_FILE_CONCAT(\"stdlib.h\"        HAVE_STDLIB_H)\nCHECK_INCLUDE_FILE_CONCAT(\"string.h\"        HAVE_STRING_H)\nCHECK_INCLUDE_FILE_CONCAT(\"strings.h\"       HAVE_STRINGS_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/param.h\"     HAVE_SYS_PARAM_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/stat.h\"      HAVE_SYS_STAT_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/time.h\"      HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/resource.h\"  HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILE_CONCAT(\"termios.h\"       HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILE_CONCAT(\"termio.h\"        HAVE_TERMIO_H)\nCHECK_INCLUDE_FILE_CONCAT(\"io.h\"            HAVE_IO_H)\nCHECK_INCLUDE_FILE_CONCAT(\"time.h\"          HAVE_TIME_H)\nCHECK_INCLUDE_FILE_CONCAT(\"unistd.h\"        HAVE_UNISTD_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/utime.h\"     HAVE_SYS_UTIME_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sockio.h\"        HAVE_SOCKIO_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/sockio.h\"    HAVE_SYS_SOCKIO_H)\nCHECK_INCLUDE_FILE_CONCAT(\"x509.h\"          HAVE_X509_H)\nCHECK_INCLUDE_FILE_CONCAT(\"locale.h\"        HAVE_LOCALE_H)\nCHECK_INCLUDE_FILE_CONCAT(\"setjmp.h\"        HAVE_SETJMP_H)\nCHECK_INCLUDE_FILE_CONCAT(\"signal.h\"        HAVE_SIGNAL_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/ioctl.h\"     HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/utsname.h\"   HAVE_SYS_UTSNAME_H)\nCHECK_INCLUDE_FILE_CONCAT(\"idn-free.h\"      HAVE_IDN_FREE_H)\nCHECK_INCLUDE_FILE_CONCAT(\"idna.h\"          HAVE_IDNA_H)\nCHECK_INCLUDE_FILE_CONCAT(\"tld.h\"           HAVE_TLD_H)\nCHECK_INCLUDE_FILE_CONCAT(\"arpa/tftp.h\"     HAVE_ARPA_TFTP_H)\nCHECK_INCLUDE_FILE_CONCAT(\"errno.h\"         HAVE_ERRNO_H)\nCHECK_INCLUDE_FILE_CONCAT(\"libgen.h\"        HAVE_LIBGEN_H)\nCHECK_INCLUDE_FILE_CONCAT(\"sys/filio.h\"     HAVE_SYS_FILIO_H)\nCHECK_TYPE_SIZE(size_t  SIZEOF_SIZE_T)\nCHECK_TYPE_SIZE(ssize_t  SIZEOF_SSIZE_T)\nCHECK_TYPE_SIZE(\"long long\"  SIZEOF_LONG_LONG)\nCHECK_TYPE_SIZE(\"long\"  SIZEOF_LONG)\nCHECK_TYPE_SIZE(\"__int64\"  SIZEOF___INT64)\nCHECK_TYPE_SIZE(\"time_t\"  SIZEOF_TIME_T)\n\nIF(HAVE_SIZEOF_LONG_LONG)\n  SET(HAVE_LONGLONG 1)\n  SET(HAVE_LL 1)\nENDIF(HAVE_SIZEOF_LONG_LONG)\n\nFIND_FILE(RANDOM_FILE urandom /dev)\nMARK_AS_ADVANCED(RANDOM_FILE)\n\n#strtoll \\\n#socket \\\n#select \\\n#strdup \\\n#strstr \\\n#strtok_r \\\n#uname \\\n#strcasecmp \\\n#stricmp \\\n#strcmpi \\\n#gethostbyaddr \\\n#gettimeofday \\\n#inet_addr \\\n#inet_ntoa \\\n#inet_pton \\\n#perror \\\n#closesocket \\\n#siginterrupt \\\n#sigaction \\\n#signal \\\n#getpass_r \\\n#getpwuid \\\n#geteuid \\\n#dlopen \\\n#utime \\\n#sigsetjmp \\\n#basename \\\n#setlocale \\\n#ftruncate \\\n#pipe \\\n#poll \\\n#getprotobyname \\\n#getrlimit \\\n#setrlimit \\\n#fork\n\n# Check for some functions that are used\nCHECK_SYMBOL_EXISTS(basename      \"${CURL_INCLUDES}\" HAVE_BASENAME)\nCHECK_SYMBOL_EXISTS(socket        \"${CURL_INCLUDES}\" HAVE_SOCKET)\nCHECK_SYMBOL_EXISTS(poll          \"${CURL_INCLUDES}\" HAVE_POLL)\nCHECK_SYMBOL_EXISTS(select        \"${CURL_INCLUDES}\" HAVE_SELECT)\nCHECK_SYMBOL_EXISTS(strdup        \"${CURL_INCLUDES}\" HAVE_STRDUP)\nCHECK_SYMBOL_EXISTS(strstr        \"${CURL_INCLUDES}\" HAVE_STRSTR)\nCHECK_SYMBOL_EXISTS(strtok_r      \"${CURL_INCLUDES}\" HAVE_STRTOK_R)\nCHECK_SYMBOL_EXISTS(strftime      \"${CURL_INCLUDES}\" HAVE_STRFTIME)\nCHECK_SYMBOL_EXISTS(uname         \"${CURL_INCLUDES}\" HAVE_UNAME)\nCHECK_SYMBOL_EXISTS(strcasecmp    \"${CURL_INCLUDES}\" HAVE_STRCASECMP)\nCHECK_SYMBOL_EXISTS(stricmp       \"${CURL_INCLUDES}\" HAVE_STRICMP)\nCHECK_SYMBOL_EXISTS(strcmpi       \"${CURL_INCLUDES}\" HAVE_STRCMPI)\nCHECK_SYMBOL_EXISTS(strncmpi      \"${CURL_INCLUDES}\" HAVE_STRNCMPI)\nCHECK_SYMBOL_EXISTS(basename      \"${CURL_INCLUDES}\" HAVE_BASENAME)\nIF(NOT HAVE_STRNCMPI)\n  SET(HAVE_STRCMPI)\nENDIF(NOT HAVE_STRNCMPI)\nCHECK_SYMBOL_EXISTS(gethostbyaddr \"${CURL_INCLUDES}\" HAVE_GETHOSTBYADDR)\nCHECK_SYMBOL_EXISTS(gettimeofday  \"${CURL_INCLUDES}\" HAVE_GETTIMEOFDAY)\nCHECK_SYMBOL_EXISTS(inet_addr     \"${CURL_INCLUDES}\" HAVE_INET_ADDR)\n# windows only has this for vista, but will link with it and say\n# that it has it at link time!  So, force it off\nIF(WIN32)\n  SET(HAVE_INET_PTON 0 CACHE \"\" INTERNAL )\nENDIF(WIN32)\nCHECK_SYMBOL_EXISTS(inet_pton     \"${CURL_INCLUDES}\" HAVE_INET_PTON)\nCHECK_SYMBOL_EXISTS(inet_ntoa     \"${CURL_INCLUDES}\" HAVE_INET_NTOA)\nCHECK_SYMBOL_EXISTS(inet_ntoa_r   \"${CURL_INCLUDES}\" HAVE_INET_NTOA_R)\nCHECK_SYMBOL_EXISTS(tcsetattr     \"${CURL_INCLUDES}\" HAVE_TCSETATTR)\nCHECK_SYMBOL_EXISTS(tcgetattr     \"${CURL_INCLUDES}\" HAVE_TCGETATTR)\nCHECK_SYMBOL_EXISTS(perror        \"${CURL_INCLUDES}\" HAVE_PERROR)\nCHECK_SYMBOL_EXISTS(closesocket   \"${CURL_INCLUDES}\" HAVE_CLOSESOCKET)\nCHECK_SYMBOL_EXISTS(setvbuf       \"${CURL_INCLUDES}\" HAVE_SETVBUF)\nCHECK_SYMBOL_EXISTS(sigsetjmp     \"${CURL_INCLUDES}\" HAVE_SIGSETJMP)\nCHECK_SYMBOL_EXISTS(getpass_r     \"${CURL_INCLUDES}\" HAVE_GETPASS_R)\nCHECK_SYMBOL_EXISTS(getpwuid      \"${CURL_INCLUDES}\" HAVE_GETPWUID)\nCHECK_SYMBOL_EXISTS(geteuid       \"${CURL_INCLUDES}\" HAVE_GETEUID)\nCHECK_SYMBOL_EXISTS(utime         \"${CURL_INCLUDES}\" HAVE_UTIME)\nIF(CMAKE_USE_OPENSSL)\n  CHECK_SYMBOL_EXISTS(RAND_status   \"${CURL_INCLUDES}\" HAVE_RAND_STATUS)\n  CHECK_SYMBOL_EXISTS(RAND_screen   \"${CURL_INCLUDES}\" HAVE_RAND_SCREEN)\n  CHECK_SYMBOL_EXISTS(RAND_egd      \"${CURL_INCLUDES}\" HAVE_RAND_EGD)\n  CHECK_SYMBOL_EXISTS(CRYPTO_cleanup_all_ex_data \"${CURL_INCLUDES}\"\n    HAVE_CRYPTO_CLEANUP_ALL_EX_DATA)\nENDIF(CMAKE_USE_OPENSSL)\nCHECK_SYMBOL_EXISTS(gmtime_r      \"${CURL_INCLUDES}\" HAVE_GMTIME_R)\nCHECK_SYMBOL_EXISTS(localtime_r   \"${CURL_INCLUDES}\" HAVE_LOCALTIME_R)\n\nCHECK_SYMBOL_EXISTS(gethostbyname   \"${CURL_INCLUDES}\" HAVE_GETHOSTBYNAME)\nCHECK_SYMBOL_EXISTS(gethostbyname_r \"${CURL_INCLUDES}\" HAVE_GETHOSTBYNAME_R)\nCHECK_SYMBOL_EXISTS(gethostbyaddr_r \"${CURL_INCLUDES}\" HAVE_GETHOSTBYADDR_R)\n\nCHECK_SYMBOL_EXISTS(signal        \"${CURL_INCLUDES}\" HAVE_SIGNAL_FUNC)\nCHECK_SYMBOL_EXISTS(SIGALRM       \"${CURL_INCLUDES}\" HAVE_SIGNAL_MACRO)\nIF(HAVE_SIGNAL_FUNC AND HAVE_SIGNAL_MACRO)\n  SET(HAVE_SIGNAL 1)\nENDIF(HAVE_SIGNAL_FUNC AND HAVE_SIGNAL_MACRO)\nCHECK_SYMBOL_EXISTS(uname          \"${CURL_INCLUDES}\" HAVE_UNAME)\nCHECK_SYMBOL_EXISTS(strtoll        \"${CURL_INCLUDES}\" HAVE_STRTOLL)\nCHECK_SYMBOL_EXISTS(_strtoi64      \"${CURL_INCLUDES}\" HAVE__STRTOI64)\nCHECK_SYMBOL_EXISTS(strerror_r     \"${CURL_INCLUDES}\" HAVE_STRERROR_R)\nCHECK_SYMBOL_EXISTS(siginterrupt   \"${CURL_INCLUDES}\" HAVE_SIGINTERRUPT)\nCHECK_SYMBOL_EXISTS(perror         \"${CURL_INCLUDES}\" HAVE_PERROR)\nCHECK_SYMBOL_EXISTS(fork           \"${CURL_INCLUDES}\" HAVE_FORK)\nCHECK_SYMBOL_EXISTS(pipe           \"${CURL_INCLUDES}\" HAVE_PIPE)\nCHECK_SYMBOL_EXISTS(ftruncate      \"${CURL_INCLUDES}\" HAVE_FTRUNCATE)\nCHECK_SYMBOL_EXISTS(getprotobyname \"${CURL_INCLUDES}\" HAVE_GETPROTOBYNAME)\nCHECK_SYMBOL_EXISTS(getrlimit      \"${CURL_INCLUDES}\" HAVE_GETRLIMIT)\nCHECK_SYMBOL_EXISTS(idn_free       \"${CURL_INCLUDES}\" HAVE_IDN_FREE)\nCHECK_SYMBOL_EXISTS(idna_strerror  \"${CURL_INCLUDES}\" HAVE_IDNA_STRERROR)\nCHECK_SYMBOL_EXISTS(tld_strerror   \"${CURL_INCLUDES}\" HAVE_TLD_STRERROR)\nCHECK_SYMBOL_EXISTS(setlocale      \"${CURL_INCLUDES}\" HAVE_SETLOCALE)\nCHECK_SYMBOL_EXISTS(setrlimit      \"${CURL_INCLUDES}\" HAVE_SETRLIMIT)\n\n# only build compat strtok if we need to\nIF (NOT HAVE_STRTOK_R)\n  SET(libCurl_SRCS ${libCurl_SRCS}\n    strtok.c\n    )\nENDIF (NOT HAVE_STRTOK_R)\n\n# only build compat strtoofft if we need to\nIF(NOT HAVE_STRTOLL AND NOT HAVE__STRTOI64)\n  SET(libCurl_SRCS ${libCurl_SRCS}\n    strtoofft.c\n    )\nENDIF(NOT HAVE_STRTOLL AND NOT HAVE__STRTOI64)\n\n# sigaction and sigsetjmp are special. Use special mechanism for\n# detecting those, but only if previous attempt failed.\nIF(HAVE_SIGNAL_H)\n  CHECK_SYMBOL_EXISTS(sigaction \"signal.h\" HAVE_SIGACTION)\nENDIF(HAVE_SIGNAL_H)\n\nIF(NOT HAVE_SIGSETJMP)\n  IF(HAVE_SETJMP_H)\n    CHECK_SYMBOL_EXISTS(sigsetjmp \"setjmp.h\" HAVE_MACRO_SIGSETJMP)\n    IF(HAVE_MACRO_SIGSETJMP)\n      SET(HAVE_SIGSETJMP 1)\n    ENDIF(HAVE_MACRO_SIGSETJMP)\n  ENDIF(HAVE_SETJMP_H)\nENDIF(NOT HAVE_SIGSETJMP)\n\n# For other curl specific tests, use this macro.\nMACRO(CURL_INTERNAL_TEST CURL_TEST)\n  IF(NOT DEFINED ${CURL_TEST})\n    SET(MACRO_CHECK_FUNCTION_DEFINITIONS\n      \"-D${CURL_TEST} ${CMAKE_REQUIRED_FLAGS}\")\n    IF(CMAKE_REQUIRED_LIBRARIES)\n      SET(CURL_TEST_ADD_LIBRARIES\n        \"-DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES}\")\n    ENDIF(CMAKE_REQUIRED_LIBRARIES)\n\n    MESSAGE(STATUS \"Performing Curl Test ${CURL_TEST}\")\n    TRY_COMPILE(${CURL_TEST}\n      ${CMAKE_BINARY_DIR}\n      ${LIBCURL_SOURCE_DIR}/CMake/CurlTests.c\n      CMAKE_FLAGS -DCOMPILE_DEFINITIONS:STRING=${MACRO_CHECK_FUNCTION_DEFINITIONS}\n      \"${CURL_TEST_ADD_LIBRARIES}\"\n      OUTPUT_VARIABLE OUTPUT)\n    IF(${CURL_TEST})\n      SET(${CURL_TEST} 1 CACHE INTERNAL \"Curl test ${FUNCTION}\")\n      MESSAGE(STATUS \"Performing Curl Test ${CURL_TEST} - Success\")\n      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log\n        \"Performing Curl Test ${CURL_TEST} passed with the following output:\\n\"\n        \"${OUTPUT}\\n\")\n    ELSE(${CURL_TEST})\n      MESSAGE(STATUS \"Performing Curl Test ${CURL_TEST} - Failed\")\n      SET(${CURL_TEST} \"\" CACHE INTERNAL \"Curl test ${FUNCTION}\")\n      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log\n        \"Performing Curl Test ${CURL_TEST} failed with the following output:\\n\"\n        \"${OUTPUT}\\n\")\n    ENDIF(${CURL_TEST})\n  ENDIF()\nENDMACRO(CURL_INTERNAL_TEST)\n\n# Do curl specific tests\n#OPTION(CURL_HAVE_DISABLED_NONBLOCKING \"Disable non-blocking socket detection\" OFF)\nSET(CURL_NONBLOCKING_TESTS)\nIF(NOT CURL_HAVE_DISABLED_NONBLOCKING)\n  SET(CURL_NONBLOCKING_TESTS\n    HAVE_FIONBIO\n    HAVE_IOCTLSOCKET\n    HAVE_IOCTLSOCKET_CASE\n    HAVE_O_NONBLOCK\n    HAVE_SO_NONBLOCK\n    )\nENDIF(NOT CURL_HAVE_DISABLED_NONBLOCKING)\nFOREACH(CURL_TEST\n    ${CURL_NONBLOCKING_TESTS}\n    TIME_WITH_SYS_TIME\n    HAVE_O_NONBLOCKHAVE_GETHOSTBYADDR_R_5\n    HAVE_GETHOSTBYADDR_R_7\n    HAVE_GETHOSTBYADDR_R_8\n    HAVE_GETHOSTBYADDR_R_5_REENTRANT\n    HAVE_GETHOSTBYADDR_R_7_REENTRANT\n    HAVE_GETHOSTBYADDR_R_8_REENTRANT\n    HAVE_GETHOSTBYNAME_R_3\n    HAVE_GETHOSTBYNAME_R_5\n    HAVE_GETHOSTBYNAME_R_6\n    HAVE_GETHOSTBYNAME_R_3_REENTRANT\n    HAVE_GETHOSTBYNAME_R_5_REENTRANT\n    HAVE_GETHOSTBYNAME_R_6_REENTRANT\n    HAVE_SOCKLEN_T\n    HAVE_IN_ADDR_T\n    STDC_HEADERS\n    RETSIGTYPE_TEST\n    HAVE_INET_NTOA_R_DECL\n    HAVE_INET_NTOA_R_DECL_REENTRANT\n    HAVE_GETADDRINFO\n    HAVE_FILE_OFFSET_BITS\n    )\n  CURL_INTERNAL_TEST(${CURL_TEST})\nENDFOREACH(CURL_TEST)\nIF(HAVE_FILE_OFFSET_BITS)\n  SET(_FILE_OFFSET_BITS 64)\nENDIF(HAVE_FILE_OFFSET_BITS)\n\n# Check for reentrant\nFOREACH(CURL_TEST\n    HAVE_GETHOSTBYADDR_R_5\n    HAVE_GETHOSTBYADDR_R_7\n    HAVE_GETHOSTBYADDR_R_8\n    HAVE_GETHOSTBYNAME_R_3\n    HAVE_GETHOSTBYNAME_R_5\n    HAVE_GETHOSTBYNAME_R_6\n    HAVE_INET_NTOA_R_DECL_REENTRANT)\n  IF(NOT ${CURL_TEST})\n    IF(${CURL_TEST}_REENTRANT)\n      SET(NEED_REENTRANT 1)\n    ENDIF(${CURL_TEST}_REENTRANT)\n  ENDIF(NOT ${CURL_TEST})\nENDFOREACH(CURL_TEST)\n\nIF(NEED_REENTRANT)\n  FOREACH(CURL_TEST\n      HAVE_GETHOSTBYADDR_R_5\n      HAVE_GETHOSTBYADDR_R_7\n      HAVE_GETHOSTBYADDR_R_8\n      HAVE_GETHOSTBYNAME_R_3\n      HAVE_GETHOSTBYNAME_R_5\n      HAVE_GETHOSTBYNAME_R_6)\n    SET(${CURL_TEST} 0)\n    IF(${CURL_TEST}_REENTRANT)\n      SET(${CURL_TEST} 1)\n    ENDIF(${CURL_TEST}_REENTRANT)\n  ENDFOREACH(CURL_TEST)\nENDIF(NEED_REENTRANT)\n\nIF(HAVE_INET_NTOA_R_DECL_REENTRANT)\n  SET(HAVE_INET_NTOA_R_DECL 1)\n  SET(NEED_REENTRANT 1)\nENDIF(HAVE_INET_NTOA_R_DECL_REENTRANT)\n\n# Some other minor tests\n\nIF(NOT HAVE_SOCKLEN_T)\n  SET(socklen_t \"int\")\nENDIF(NOT HAVE_SOCKLEN_T)\n\nIF(NOT HAVE_IN_ADDR_T)\n  SET(in_addr_t \"unsigned long\")\nENDIF(NOT HAVE_IN_ADDR_T)\n\n# Fix libz / zlib.h\n\nIF(NOT CURL_SPECIAL_LIBZ)\n  IF(NOT HAVE_LIBZ)\n    SET(HAVE_ZLIB_H 0)\n  ENDIF(NOT HAVE_LIBZ)\n\n  IF(NOT HAVE_ZLIB_H)\n    SET(HAVE_LIBZ 0)\n  ENDIF(NOT HAVE_ZLIB_H)\nENDIF(NOT CURL_SPECIAL_LIBZ)\n\nIF(_FILE_OFFSET_BITS)\n  SET(_FILE_OFFSET_BITS 64)\nENDIF(_FILE_OFFSET_BITS)\nSET(CMAKE_REQUIRED_FLAGS \"-D_FILE_OFFSET_BITS=64\")\nSET(CMAKE_EXTRA_INCLUDE_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/curl/curl.h\")\nCHECK_TYPE_SIZE(\"curl_off_t\" SIZEOF_CURL_OFF_T)\nSET(CMAKE_EXTRA_INCLUDE_FILES)\nSET(CMAKE_REQUIRED_FLAGS)\n\n\n# Check for nonblocking\nSET(HAVE_DISABLED_NONBLOCKING 1)\nIF(HAVE_FIONBIO OR\n    HAVE_IOCTLSOCKET OR\n    HAVE_IOCTLSOCKET_CASE OR\n    HAVE_O_NONBLOCK)\n  SET(HAVE_DISABLED_NONBLOCKING)\nENDIF(HAVE_FIONBIO OR\n  HAVE_IOCTLSOCKET OR\n  HAVE_IOCTLSOCKET_CASE OR\n  HAVE_O_NONBLOCK)\n\nIF(RETSIGTYPE_TEST)\n  SET(RETSIGTYPE void)\nELSE(RETSIGTYPE_TEST)\n  SET(RETSIGTYPE int)\nENDIF(RETSIGTYPE_TEST)\n\nIF(CMAKE_COMPILER_IS_GNUCC AND APPLE)\n  INCLUDE(CheckCCompilerFlag)\n  CHECK_C_COMPILER_FLAG(-Wno-long-double HAVE_C_FLAG_Wno_long_double)\n  IF(HAVE_C_FLAG_Wno_long_double)\n    # The Mac version of GCC warns about use of long double.  Disable it.\n    GET_SOURCE_FILE_PROPERTY(MPRINTF_COMPILE_FLAGS mprintf.c COMPILE_FLAGS)\n    IF(MPRINTF_COMPILE_FLAGS)\n      SET(MPRINTF_COMPILE_FLAGS \"${MPRINTF_COMPILE_FLAGS} -Wno-long-double\")\n    ELSE(MPRINTF_COMPILE_FLAGS)\n      SET(MPRINTF_COMPILE_FLAGS \"-Wno-long-double\")\n    ENDIF(MPRINTF_COMPILE_FLAGS)\n    SET_SOURCE_FILES_PROPERTIES(mprintf.c PROPERTIES\n      COMPILE_FLAGS ${MPRINTF_COMPILE_FLAGS})\n  ENDIF(HAVE_C_FLAG_Wno_long_double)\nENDIF(CMAKE_COMPILER_IS_GNUCC AND APPLE)\n\nINCLUDE(CMake/OtherTests.cmake)\n\n# The rest of the build\n\nOPTION(CMAKE_BUILD_CURL_SHARED \"Should curl be built shared\" TRUE)\nIF(CMAKE_BUILD_CURL_SHARED)\n  SET(LIBRARY_TYPE SHARED)\n  ADD_DEFINITIONS(-DHAVE_CONFIG_H)\nELSE(CMAKE_BUILD_CURL_SHARED)\n   ADD_DEFINITIONS(-DHAVE_CONFIG_H\n    -DCURL_STATICLIB)\nENDIF(CMAKE_BUILD_CURL_SHARED)\nSET(CURL_STATICLIB)\n\n# Support CheckTypeSize module from CMake 2.8.0 and lower.\nFOREACH(var\n    SIZEOF_CURL_OFF_T\n    SIZEOF_LONG\n    SIZEOF_LONG_LONG\n    SIZEOF___INT64\n    SIZEOF_SIZE_T\n    SIZEOF_SSIZE_T\n    SIZEOF_TIME_T\n    )\n  IF(NOT ${var}_CODE)\n    MESSAGE(\"creating ${var}_CODE\")\n    IF(${var})\n      SET(${var}_CODE \"#define ${var} ${${var}}\")\n    ELSE()\n      SET(${var}_CODE \"/* #undef ${var} */\")\n    ENDIF()\n  ENDIF()\nENDFOREACH()\n\nCONFIGURE_FILE(${LIBCURL_SOURCE_DIR}/config.h.in\n  ${LIBCURL_BINARY_DIR}/config.h)\n\nADD_LIBRARY(cmcurl ${LIBRARY_TYPE} ${libCurl_SRCS} ${CMAKE_CURL_SSL_DLLS})\nTARGET_LINK_LIBRARIES(cmcurl ${CURL_LIBS})\nIF(CMAKE_BUILD_CURL_SHARED)\n  SET_TARGET_PROPERTIES(cmcurl PROPERTIES DEFINE_SYMBOL BUILDING_LIBCURL\n    RUNTIME_OUTPUT_DIRECTORY ${CMake_BIN_DIR})\n  INSTALL(TARGETS cmcurl RUNTIME DESTINATION bin)\nENDIF(CMAKE_BUILD_CURL_SHARED)\n\nOPTION(CURL_TESTING \"Do libCurl testing\" OFF)\nIF(CURL_TESTING)\n  SUBDIRS(Testing)\nENDIF(CURL_TESTING)\n\nADD_EXECUTABLE(LIBCURL Testing/curltest.c)\nTARGET_LINK_LIBRARIES(LIBCURL cmcurl ${CMAKE_DL_LIBS})\n\nIF(CMAKE_CURL_TEST_URL)\n  ADD_TEST(curl LIBCURL ${CMAKE_CURL_TEST_URL})\nENDIF(CMAKE_CURL_TEST_URL)\n\nINSTALL(FILES COPYING DESTINATION ${CMAKE_DOC_DIR}/cmcurl)\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/Platforms/config-aix.h": "/* lib/config.h.  Generated by configure.  */\n/* lib/config.h.in.  Generated from configure.in by autoheader.  */\n/* Name of this package! */\n#define PACKAGE \"curl\"\n\n/* Version number of this archive. */\n#define VERSION \"7.10.2\"\n\n/* Define if you have the getpass function.  */\n/* #undef HAVE_GETPASS */\n\n/* Define cpu-machine-OS */\n#define OS \"powerpc-ibm-aix5.1.0.0\"\n\n/* Define if you have the gethostbyaddr_r() function with 5 arguments */\n#define HAVE_GETHOSTBYADDR_R_5 1\n\n/* Define if you have the gethostbyaddr_r() function with 7 arguments */\n/* #undef HAVE_GETHOSTBYADDR_R_7 */\n\n/* Define if you have the gethostbyaddr_r() function with 8 arguments */\n/* #undef HAVE_GETHOSTBYADDR_R_8 */\n\n/* Define if you have the gethostbyname_r() function with 3 arguments */\n#define HAVE_GETHOSTBYNAME_R_3 1\n\n/* Define if you have the gethostbyname_r() function with 5 arguments */\n/* #undef HAVE_GETHOSTBYNAME_R_5 */\n\n/* Define if you have the gethostbyname_r() function with 6 arguments */\n/* #undef HAVE_GETHOSTBYNAME_R_6 */\n\n/* Define if you have the inet_ntoa_r function declared. */\n/* #undef HAVE_INET_NTOA_R_DECL */\n\n/* Define if you need the _REENTRANT define for some functions */\n/* #undef NEED_REENTRANT */\n\n/* Define if you have the Kerberos4 libraries (including -ldes) */\n/* #undef KRB4 */\n\n/* Define if you want to enable IPv6 support */\n#define ENABLE_IPV6 1\n\n/* Define this to 'int' if ssize_t is not an available typedefed type */\n/* #undef ssize_t */\n\n/* Define this to 'int' if socklen_t is not an available typedefed type */\n/* #undef socklen_t */\n\n/* Define this as a suitable file to read random data from */\n/* #undef RANDOM_FILE */\n\n/* Define this to your Entropy Gathering Daemon socket pathname */\n/* #undef EGD_SOCKET */\n\n/* Define if you have a working OpenSSL installation */\n/* #undef OPENSSL_ENABLED */\n\n/* Define the one correct non-blocking socket method below */\n/* #undef HAVE_FIONBIO */\n/* #undef HAVE_IOCTLSOCKET */\n/* #undef HAVE_IOCTLSOCKET_CASE */\n/* #undef HAVE_O_NONBLOCK */\n#define HAVE_DISABLED_NONBLOCKING 1\n\n/* Define this to 'int' if in_addr_t is not an available typedefed type */\n/* #undef in_addr_t */\n\n/* Define to disable DICT */\n/* #undef CURL_DISABLE_DICT */\n\n/* Define to disable FILE */\n/* #undef CURL_DISABLE_FILE */\n\n/* Define to disable FTP */\n/* #undef CURL_DISABLE_FTP */\n\n/* Define to disable GOPHER */\n/* #undef CURL_DISABLE_GOPHER */\n\n/* Define to disable HTTP */\n/* #undef CURL_DISABLE_HTTP */\n\n/* Define to disable LDAP */\n/* #undef CURL_DISABLE_LDAP */\n\n/* Define to disable TELNET */\n/* #undef CURL_DISABLE_TELNET */\n\n/* Define if you have zlib present */\n#define HAVE_LIBZ 1\n\n/* CA bundle full path name */\n#define CURL_CA_BUNDLE \"/usr/local/share/curl/curl-ca-bundle.crt\"\n\n/* to disable FILE */\n/* #undef CURL_DISABLE_FILE */\n\n/* to disable FTP */\n/* #undef CURL_DISABLE_FTP */\n\n/* to disable GOPHER */\n/* #undef CURL_DISABLE_GOPHER */\n\n/* to disable HTTP */\n/* #undef CURL_DISABLE_HTTP */\n\n/* to disable LDAP */\n/* #undef CURL_DISABLE_LDAP */\n\n/* to disable TELNET */\n/* #undef CURL_DISABLE_TELNET */\n\n/* Set to explicitly specify we don't want to use thread-safe functions */\n/* #undef DISABLED_THREADSAFE */\n\n/* your Entropy Gathering Daemon socket pathname */\n/* #undef EGD_SOCKET */\n\n/* Define if you want to enable IPv6 support */\n#define ENABLE_IPV6 1\n\n/* Define to 1 if you have the <alloca.h> header file. */\n#define HAVE_ALLOCA_H 1\n\n/* Define to 1 if you have the <arpa/inet.h> header file. */\n#define HAVE_ARPA_INET_H 1\n\n/* Define to 1 if you have the `closesocket' function. */\n/* #undef HAVE_CLOSESOCKET */\n\n/* Define to 1 if you have the <crypto.h> header file. */\n/* #undef HAVE_CRYPTO_H */\n\n/* Define to 1 if you have the <des.h> header file. */\n/* #undef HAVE_DES_H */\n\n/* to disable NON-BLOCKING connections */\n#define HAVE_DISABLED_NONBLOCKING 1\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#define HAVE_DLFCN_H 1\n\n/* Define to 1 if you have the `dlopen' function. */\n#define HAVE_DLOPEN 1\n\n/* Define to 1 if you have the <err.h> header file. */\n/* #undef HAVE_ERR_H */\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#define HAVE_FCNTL_H 1\n\n/* Define if getaddrinfo exists and works */\n#define HAVE_GETADDRINFO 1\n\n/* Define to 1 if you have the `geteuid' function. */\n#define HAVE_GETEUID 1\n\n/* Define to 1 if you have the `gethostbyaddr' function. */\n#define HAVE_GETHOSTBYADDR 1\n\n/* Define to 1 if you have the `gethostbyaddr_r' function. */\n#define HAVE_GETHOSTBYADDR_R 1\n\n/* Define to 1 if you have the `gethostbyname_r' function. */\n#define HAVE_GETHOSTBYNAME_R 1\n\n/* Define to 1 if you have the `getpass_r' function. */\n/* #undef HAVE_GETPASS_R */\n\n/* Define to 1 if you have the `getpwuid' function. */\n#define HAVE_GETPWUID 1\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#define HAVE_GETTIMEOFDAY 1\n\n/* Define to 1 if you have the `gmtime_r' function. */\n#define HAVE_GMTIME_R 1\n\n/* Define to 1 if you have the `inet_addr' function. */\n#define HAVE_INET_ADDR 1\n\n/* Define to 1 if you have the `inet_ntoa' function. */\n#define HAVE_INET_NTOA 1\n\n/* Define to 1 if you have the `inet_ntoa_r' function. */\n#define HAVE_INET_NTOA_R 1\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the <io.h> header file. */\n/* #undef HAVE_IO_H */\n\n/* Define to 1 if you have the `krb_get_our_ip_for_realm' function. */\n/* #undef HAVE_KRB_GET_OUR_IP_FOR_REALM */\n\n/* Define to 1 if you have the <krb.h> header file. */\n/* #undef HAVE_KRB_H */\n\n/* Define to 1 if you have the `crypto' library (-lcrypto). */\n/* #undef HAVE_LIBCRYPTO */\n\n/* Define to 1 if you have the `dl' library (-ldl). */\n/* #undef HAVE_LIBDL */\n\n/* Define to 1 if you have the `nsl' library (-lnsl). */\n/* #undef HAVE_LIBNSL */\n\n/* Define to 1 if you have the `resolv' library (-lresolv). */\n/* #undef HAVE_LIBRESOLV */\n\n/* Define to 1 if you have the `resolve' library (-lresolve). */\n/* #undef HAVE_LIBRESOLVE */\n\n/* Define to 1 if you have the `socket' library (-lsocket). */\n/* #undef HAVE_LIBSOCKET */\n\n/* Define to 1 if you have the `ssl' library (-lssl). */\n/* #undef HAVE_LIBSSL */\n\n/* If zlib is available */\n#define HAVE_LIBZ 1\n\n/* Define to 1 if you have the `localtime_r' function. */\n#define HAVE_LOCALTIME_R 1\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#define HAVE_MALLOC_H 1\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#define HAVE_NETDB_H 1\n\n/* Define to 1 if you have the <netinet/if_ether.h> header file. */\n#define HAVE_NETINET_IF_ETHER_H 1\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#define HAVE_NETINET_IN_H 1\n\n/* Define to 1 if you have the <net/if.h> header file. */\n#define HAVE_NET_IF_H 1\n\n/* Define to 1 if you have the <openssl/crypto.h> header file. */\n/* #undef HAVE_OPENSSL_CRYPTO_H */\n\n/* Define to 1 if you have the <openssl/engine.h> header file. */\n/* #undef HAVE_OPENSSL_ENGINE_H */\n\n/* Define to 1 if you have the <openssl/err.h> header file. */\n/* #undef HAVE_OPENSSL_ERR_H */\n\n/* Define to 1 if you have the <openssl/pem.h> header file. */\n/* #undef HAVE_OPENSSL_PEM_H */\n\n/* Define to 1 if you have the <openssl/rsa.h> header file. */\n/* #undef HAVE_OPENSSL_RSA_H */\n\n/* Define to 1 if you have the <openssl/ssl.h> header file. */\n/* #undef HAVE_OPENSSL_SSL_H */\n\n/* Define to 1 if you have the <openssl/x509.h> header file. */\n/* #undef HAVE_OPENSSL_X509_H */\n\n/* Define to 1 if you have the <pem.h> header file. */\n/* #undef HAVE_PEM_H */\n\n/* Define to 1 if you have the `perror' function. */\n#define HAVE_PERROR 1\n\n/* Define to 1 if you have the `poll' function. */\n#define HAVE_POLL 1\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#define HAVE_PWD_H 1\n\n/* Define to 1 if you have the `RAND_egd' function. */\n/* #undef HAVE_RAND_EGD */\n\n/* Define to 1 if you have the `RAND_screen' function. */\n/* #undef HAVE_RAND_SCREEN */\n\n/* Define to 1 if you have the `RAND_status' function. */\n/* #undef HAVE_RAND_STATUS */\n\n/* Define to 1 if you have the <rsa.h> header file. */\n/* #undef HAVE_RSA_H */\n\n/* Define to 1 if you have the `select' function. */\n#define HAVE_SELECT 1\n\n/* Define to 1 if you have the <setjmp.h> header file. */\n#define HAVE_SETJMP_H 1\n\n/* Define to 1 if you have the `setvbuf' function. */\n#define HAVE_SETVBUF 1\n\n/* Define to 1 if you have the <sgtty.h> header file. */\n#define HAVE_SGTTY_H 1\n\n/* Define to 1 if you have the `sigaction' function. */\n#define HAVE_SIGACTION 1\n\n/* Define to 1 if you have the `signal' function. */\n#define HAVE_SIGNAL 1\n\n/* If you have sigsetjmp */\n#define HAVE_SIGSETJMP 1\n\n/* Define to 1 if you have the `socket' function. */\n#define HAVE_SOCKET 1\n\n/* Define to 1 if you have the <ssl.h> header file. */\n/* #undef HAVE_SSL_H */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n/* #undef HAVE_STDINT_H */\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the `strcasecmp' function. */\n#define HAVE_STRCASECMP 1\n\n/* Define to 1 if you have the `strcmpi' function. */\n/* #undef HAVE_STRCMPI */\n\n/* Define to 1 if you have the `strdup' function. */\n#define HAVE_STRDUP 1\n\n/* Define to 1 if you have the `strftime' function. */\n#define HAVE_STRFTIME 1\n\n/* Define to 1 if you have the `stricmp' function. */\n/* #undef HAVE_STRICMP */\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the `strlcpy' function. */\n/* #undef HAVE_STRLCPY */\n\n/* Define to 1 if you have the `strstr' function. */\n#define HAVE_STRSTR 1\n\n/* Define to 1 if you have the `strtok_r' function. */\n#define HAVE_STRTOK_R 1\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#define HAVE_SYS_PARAM_H 1\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#define HAVE_SYS_POLL_H 1\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#define HAVE_SYS_SELECT_H 1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#define HAVE_SYS_SOCKET_H 1\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n/* #undef HAVE_SYS_SOCKIO_H */\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/utime.h> header file. */\n/* #undef HAVE_SYS_UTIME_H */\n\n/* Define to 1 if you have the `tcgetattr' function. */\n#define HAVE_TCGETATTR 1\n\n/* Define to 1 if you have the `tcsetattr' function. */\n#define HAVE_TCSETATTR 1\n\n/* Define to 1 if you have the <termios.h> header file. */\n#define HAVE_TERMIOS_H 1\n\n/* Define to 1 if you have the <termio.h> header file. */\n#define HAVE_TERMIO_H 1\n\n/* Define to 1 if you have the <time.h> header file. */\n#define HAVE_TIME_H 1\n\n/* Define to 1 if you have the `uname' function. */\n#define HAVE_UNAME 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to 1 if you have the `utime' function. */\n#define HAVE_UTIME 1\n\n/* Define to 1 if you have the <utime.h> header file. */\n#define HAVE_UTIME_H 1\n\n/* Define to 1 if you have the <winsock.h> header file. */\n/* #undef HAVE_WINSOCK_H */\n\n/* Define to 1 if you have the <x509.h> header file. */\n/* #undef HAVE_X509_H */\n\n/* if you have the zlib.h header file */\n/* #undef HAVE_ZLIB_H */\n\n/* if you have the Kerberos4 libraries (including -ldes) */\n/* #undef KRB4 */\n\n/* cpu-machine-OS */\n#define OS \"powerpc-ibm-aix5.1.0.0\"\n\n/* Name of package */\n#define PACKAGE \"curl\"\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"\"\n\n/* a suitable file to read random data from */\n/* #undef RANDOM_FILE */\n\n/* Define as the return type of signal handlers (`int' or `void'). */\n#define RETSIGTYPE void\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#define TIME_WITH_SYS_TIME 1\n\n/* Version number of package */\n#define VERSION \"7.10.2\"\n\n/* Define to 1 if on AIX 3.\n   System headers sometimes define this.\n   We just want to avoid a redefinition error message.  */\n#ifndef _ALL_SOURCE\n# define _ALL_SOURCE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n/* #undef _FILE_OFFSET_BITS */\n\n/* Define for large files, on AIX-style hosts. */\n#define _LARGE_FILES 1\n\n/* Define to empty if `const' does not conform to ANSI C. */\n/* #undef const */\n\n/* type to use in place of in_addr_t if not defined */\n/* #undef in_addr_t */\n\n/* Define to `unsigned' if <sys/types.h> does not define. */\n/* #undef size_t */\n\n/* type to use in place of socklen_t if not defined */\n/* #undef socklen_t */\n\n/* Define to `int' if <sys/types.h> does not define. */\n/* #undef ssize_t */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/kwsys/DynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"Configure.hxx.in\"\n#endif\n\n// This file is actually 3 different implementations.\n// 1. HP machines which uses shl_load\n// 2. Mac OS X 10.2.x and earlier which uses NSLinkModule\n// 3. Windows which uses LoadLibrary\n// 4. Most unix systems (including Mac OS X 10.3 and later) which use dlopen\n// (default) Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n// ---------------------------------------------------------------\n// 1. Implementation for HPUX  machines\n#ifdef __hpux\n#include <errno.h>\n#include <dl.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return shl_load(libname, BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return !shl_unload(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer\nDynamicLoader::GetSymbolAddress(DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example, variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym (&lib, sym, TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if(  errno == ENOEXEC\n    || errno == ENOSYM\n    || errno == EINVAL )\n    {\n    return strerror(errno);\n    }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //__hpux\n\n\n// ---------------------------------------------------------------\n// 2. Implementation for Mac OS X 10.2.x and earlier\n#ifdef __APPLE__\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#include <string.h> // for strlen\n#include <mach-o/dyld.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname, &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if( rc != NSObjectFileImageSuccess )\n    {\n    return 0;\n    }\n  NSModule handle = NSLinkModule(image, libname,\n    NSLINKMODULE_OPTION_BINDNOW|NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary( DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void *result=0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym+1, sym);\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym);\n  if(symbol)\n    {\n    result = NSAddressOfSymbol(symbol);\n    }\n\n  delete[] rsym;\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#endif // __APPLE__\n\n// ---------------------------------------------------------------\n// 3. Implementation for Windows win32 code but not cygwin\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname, -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length+1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname, -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete [] wchars;\n  return lh;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void *result;\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym, sym);\n#else\n  const char *rsym = sym;\n#endif\n  result = (void*)GetProcAddress(lib, rsym);\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  delete[] rsym;\n#endif\n  // Hack to cast pointer-to-data to pointer-to-function.\n#ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#endif\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf=NULL;\n\n  FormatMessage(\n    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n    NULL,\n    GetLastError(),\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    (LPTSTR) &lpMsgBuf,\n    0,\n    NULL\n    );\n\n  if(!lpMsgBuf)\n    {\n    return NULL;\n    }\n\n  static char* str = 0;\n  delete [] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf)+1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree( lpMsgBuf );\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //_WIN32\n\n// ---------------------------------------------------------------\n// 4. Implementation for BeOS\n#if defined __BEOS__\n\n#include <string.h> // for strerror()\n\n#include <be/kernel/image.h>\n#include <be/support/Errors.h>\n\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\nstatic image_id last_dynamic_err = B_OK;\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname);\n  if (rc < 0)\n    {\n    last_dynamic_err = rc;\n    return 0;\n    }\n\n  return rc+1;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n      return 0;\n    }\n  else\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib-1);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      return 0;\n      }\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n    }\n  else\n    {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc = get_image_symbol(lib-1,sym,B_SYMBOL_TYPE_ANY,&result.pvoid);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n      }\n    }\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  const char *retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 5. Implementation for systems without dynamic libs\n// __gnu_blrts__ is IBM BlueGene/L\n// __LIBCATAMOUNT__ is defined on Catamount on Cray compute nodes\n#if defined(__gnu_blrts__) || defined(__LIBCATAMOUNT__) || defined(__CRAYXT_COMPUTE_LINUX_TARGET)\n#include <string.h> // for strerror()\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n    return 0;\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n    DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n  {\n  return \"General error\";\n  }\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n#ifdef __MINT__\n#define DYNAMICLOADER_DEFINED 1\n#define _GNU_SOURCE /* for program_invocation_name */\n#include <string.h>\n#include <malloc.h>\n#include <errno.h>\n#include <dld.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  char *name = (char *)calloc(1, strlen(libname) + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname, strlen(libname));\n  dld_link(libname);\n  return (void *)name;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char *)lib, 0);\n  free(lib);\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym);\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 6. Implementation for default UNIX machines.\n// if nothing has been defined then use this\n#ifndef DYNAMICLOADER_DEFINED\n#define DYNAMICLOADER_DEFINED 1\n// Setup for most unix machines\n#include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return dlopen(libname, RTLD_LAZY);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib)\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n    }\n  // else\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym);\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/kwsys/DynamicLoader.hxx.in": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#ifndef @KWSYS_NAMESPACE@_DynamicLoader_hxx\n#define @KWSYS_NAMESPACE@_DynamicLoader_hxx\n\n#include <@KWSYS_NAMESPACE@/Configure.h>\n\n#if defined(__hpux)\n  #include <dl.h>\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  #include <windows.h>\n#elif defined(__APPLE__)\n  #include <AvailabilityMacros.h>\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    #include <mach-o/dyld.h>\n  #endif\n#elif defined(__BEOS__)\n  #include <be/kernel/image.h>\n#endif\n\nnamespace @KWSYS_NAMESPACE@\n{\n/** \\class DynamicLoader\n * \\brief Portable loading of dynamic libraries or dll's.\n *\n * DynamicLoader provides a portable interface to loading dynamic\n * libraries or dll's into a process.\n *\n * Directory currently works with Windows, Apple, HP-UX and Unix (POSIX)\n * operating systems\n *\n * \\warning dlopen on *nix system works the following way:\n * If filename contains a slash (\"/\"), then it is interpreted as a (relative\n * or absolute) pathname.  Otherwise, the dynamic linker searches for the\n * library as follows : see ld.so(8) for further details):\n * Whereas this distinction does not exist on Win32. Therefore ideally you\n * should be doing full path to garantee to have a consistent way of dealing\n * with dynamic loading of shared library.\n *\n * \\warning the Cygwin implementation do not use the Win32 HMODULE. Put extra\n * condition so that we can include the correct declaration (POSIX)\n */\n\nclass @KWSYS_NAMESPACE@_EXPORT DynamicLoader\n{\npublic:\n// Ugly stuff for library handles\n// They are different on several different OS's\n#if defined(__hpux)\n  typedef shl_t LibraryHandle;\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  typedef HMODULE LibraryHandle;\n#elif defined(__APPLE__)\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    typedef NSModule LibraryHandle;\n  #else\n    typedef void* LibraryHandle;\n  #endif\n#elif defined(__BEOS__)\n  typedef image_id LibraryHandle;\n#else  // POSIX\n  typedef void* LibraryHandle;\n#endif\n\n  // Return type from DynamicLoader::GetSymbolAddress.\n  typedef void (*SymbolPointer)();\n\n  /** Load a dynamic library into the current process.\n   * The returned LibraryHandle can be used to access the symbols in the\n   * library. */\n  static LibraryHandle OpenLibrary(const char*);\n\n  /** Attempt to detach a dynamic library from the\n   * process.  A value of true is returned if it is sucessful. */\n  static int CloseLibrary(LibraryHandle);\n\n  /** Find the address of the symbol in the given library. */\n  static SymbolPointer GetSymbolAddress(LibraryHandle, const char*);\n\n  /** Return the default module prefix for the current platform.  */\n  static const char* LibPrefix() { return \"@KWSYS_DynamicLoader_PREFIX@\"; }\n\n  /** Return the default module suffix for the current platform.  */\n  static const char* LibExtension() { return \"@KWSYS_DynamicLoader_SUFFIX@\"; }\n\n  /** Return the last error produced from a calls made on this class. */\n  static const char* LastError();\n}; // End Class: DynamicLoader\n\n} // namespace @KWSYS_NAMESPACE@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/kwsys/testDynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n\n#include KWSYS_HEADER(DynamicLoader.hxx)\n#include KWSYS_HEADER(ios/iostream)\n#include KWSYS_HEADER(stl/string)\n\n#if defined(__BEOS__) || defined(__HAIKU__)\n#include <be/kernel/OS.h>  /* disable_debugger() API. */\n#endif\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"kwsys_ios_iostream.h.in\"\n# include \"kwsys_stl_string.hxx.in\"\n#endif\n\n// Include with <> instead of \"\" to avoid getting any in-source copy\n// left on disk.\n#include <testSystemTools.h>\n\nstatic kwsys_stl::string GetLibName(const char* lname)\n{\n  // Construct proper name of lib\n  kwsys_stl::string slname;\n  slname = EXECUTABLE_OUTPUT_PATH;\n#ifdef CMAKE_INTDIR\n  slname += \"/\";\n  slname += CMAKE_INTDIR;\n#endif\n  slname += \"/\";\n  slname += kwsys::DynamicLoader::LibPrefix();\n  slname += lname;\n  slname += kwsys::DynamicLoader::LibExtension();\n\n  return slname;\n}\n\n/* libname = Library name (proper prefix, proper extension)\n * System  = symbol to lookup in libname\n * r1: should OpenLibrary succeed ?\n * r2: should GetSymbolAddress succeed ?\n * r3: should CloseLibrary succeed ?\n */\nint TestDynamicLoader(const char* libname, const char* symbol, int r1, int r2, int r3)\n{\n  kwsys_ios::cerr << \"Testing: \" << libname << kwsys_ios::endl;\n  kwsys::DynamicLoader::LibraryHandle l\n    = kwsys::DynamicLoader::OpenLibrary(libname);\n  // If result is incompatible with expectation just fails (xor):\n  if( (r1 && !l) || (!r1 && l) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n  kwsys::DynamicLoader::SymbolPointer f\n    = kwsys::DynamicLoader::GetSymbolAddress(l, symbol);\n  if( (r2 && !f) || (!r2 && f) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n#ifndef __APPLE__\n  int s = kwsys::DynamicLoader::CloseLibrary(l);\n  if( (r3 && !s) || (!r3 && s) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n#else\n  (void)r3;\n#endif\n  return 0;\n}\n\nint testDynamicLoader(int argc, char *argv[])\n{\n#if defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n#elif defined(__BEOS__) || defined(__HAIKU__)\n  disable_debugger(1);\n#endif\n  int res = 0;\n  if( argc == 3 )\n    {\n    // User specify a libname and symbol to check.\n    res = TestDynamicLoader(argv[1], argv[2],1,1,1);\n    return res;\n    }\n\n// dlopen() on Syllable before 11/22/2007 doesn't return 0 on error\n#ifndef __SYLLABLE__\n  // Make sure that inexistent lib is giving correct result\n  res += TestDynamicLoader(\"azerty_\", \"foo_bar\",0,0,0);\n  // Make sure that random binary file cannot be assimilated as dylib\n  res += TestDynamicLoader(TEST_SYSTEMTOOLS_SOURCE_DIR \"/testSystemTools.bin\", \"wp\",0,0,0);\n#endif\n\n#ifdef __linux__\n  // This one is actually fun to test, since dlopen is by default loaded...wonder why :)\n  res += TestDynamicLoader(\"foobar.lib\", \"dlopen\",0,1,0);\n  res += TestDynamicLoader(\"libdl.so\", \"dlopen\",1,1,1);\n  res += TestDynamicLoader(\"libdl.so\", \"TestDynamicLoader\",1,0,1);\n#endif\n  // Now try on the generated library\n  kwsys_stl::string libname = GetLibName(KWSYS_NAMESPACE_STRING \"TestDynload\");\n  res += TestDynamicLoader(libname.c_str(), \"dummy\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderSymbolPointer\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderSymbolPointer\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderData\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderData\",1,0,1);\n\n  return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/KDE3Macros.cmake": "#\n\n#=============================================================================\n# Copyright 2006-2009 Kitware, Inc.\n# Copyright 2006 Alexander Neundorf <neundorf@kde.org>\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# See FindKDE3.cmake for documentation.\n#\n# this file contains the following macros:\n# KDE3_ADD_DCOP_SKELS\n# KDE3_ADD_DCOP_STUBS\n# KDE3_ADD_MOC_FILES\n# KDE3_ADD_UI_FILES\n# KDE3_ADD_KCFG_FILES\n# KDE3_AUTOMOC\n# KDE3_INSTALL_LIBTOOL_FILE\n# KDE3_CREATE_FINAL_FILE\n# KDE3_ADD_KPART\n# KDE3_ADD_KDEINIT_EXECUTABLE\n# KDE3_ADD_EXECUTABLE\n\n\n#neundorf@kde.org\n\ninclude(AddFileDependencies)\n\n#create the kidl and skeletion file for dcop stuff\n#usage: KDE_ADD_COP_SKELS(foo_SRCS ${dcop_headers})\nmacro(KDE3_ADD_DCOP_SKELS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_skel ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_skel.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n         set(HAVE_${_basename}_KIDL_RULE ON)\n\n          add_custom_command(OUTPUT ${_kidl}\n          COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n          ARGS ${_tmp_FILE} > ${_kidl}\n          DEPENDS ${_tmp_FILE}\n         )\n\n       endif ()\n\n      if (NOT HAVE_${_basename}_SKEL_RULE)\n        set(HAVE_${_basename}_SKEL_RULE ON)\n\n       add_custom_command(OUTPUT ${_skel}\n          COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n          ARGS --c++-suffix cpp --no-signals --no-stub ${_kidl}\n          DEPENDS ${_kidl}\n          )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_skel})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_DCOP_STUBS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_stub_CPP ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_stub.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n        set(HAVE_${_basename}_KIDL_RULE ON)\n\n\n        add_custom_command(OUTPUT ${_kidl}\n           COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n           ARGS ${_tmp_FILE} > ${_kidl}\n           DEPENDS ${_tmp_FILE}\n           )\n\n      endif ()\n\n\n      if (NOT HAVE_${_basename}_STUB_RULE)\n        set(HAVE_${_basename}_STUB_RULE ON)\n\n        add_custom_command(OUTPUT ${_stub_CPP}\n           COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n           ARGS --c++-suffix cpp --no-signals --no-skel ${_kidl}\n           DEPENDS ${_kidl}\n         )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_stub_CPP})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_KCFG_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      file(READ ${_tmp_FILE} _contents)\n      string(REGEX REPLACE \"^(.*\\n)?File=([^\\n]+)\\n.*$\" \"\\\\2\"  _kcfg_FILE \"${_contents}\")\n\n      set(_src_FILE    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_header_FILE ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n\n      add_custom_command(OUTPUT ${_src_FILE}\n         COMMAND ${KDE3_KCFGC_EXECUTABLE}\n         ARGS ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} ${_tmp_FILE}\n         DEPENDS ${_tmp_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} )\n\n      set(${_sources} ${${_sources}} ${_src_FILE})\n\n   endforeach ()\n\nendmacro()\n\n\n#create the moc files and add them to the list of sources\n#usage: KDE_ADD_MOC_FILES(foo_SRCS ${moc_headers})\nmacro(KDE3_ADD_MOC_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_tmp_FILE} -o ${_moc}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      set(${_sources} ${${_sources}} ${_moc})\n\n   endforeach ()\nendmacro()\n\n\nget_filename_component( KDE3_MODULE_DIR  ${CMAKE_CURRENT_LIST_FILE} PATH)\n\n#create the implementation files from the ui files and add them to the list of sources\n#usage: KDE_ADD_UI_FILES(foo_SRCS ${ui_files})\nmacro(KDE3_ADD_UI_FILES _sources )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n      set(_src ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_header}\n         COMMAND ${QT_UIC_EXECUTABLE}\n         ARGS  -L ${KDE3_LIB_DIR}/kde3/plugins/designer -nounload -o ${_header} ${CMAKE_CURRENT_SOURCE_DIR}/${_current_FILE}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      add_custom_command(OUTPUT ${_src}\n         COMMAND ${CMAKE_COMMAND}\n         ARGS\n         -DKDE_UIC_PLUGIN_DIR:FILEPATH=${KDE3_LIB_DIR}/kde3/plugins/designer\n         -DKDE_UIC_EXECUTABLE:FILEPATH=${QT_UIC_EXECUTABLE}\n         -DKDE_UIC_FILE:FILEPATH=${_tmp_FILE}\n         -DKDE_UIC_CPP_FILE:FILEPATH=${_src}\n         -DKDE_UIC_H_FILE:FILEPATH=${_header}\n         -P ${KDE3_MODULE_DIR}/kde3uic.cmake\n         DEPENDS ${_header}\n      )\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_header} -o ${_moc}\n         DEPENDS ${_header}\n      )\n\n      set(${_sources} ${${_sources}} ${_src} ${_moc} )\n\n   endforeach ()\nendmacro()\n\n\nmacro(KDE3_AUTOMOC)\n   set(_matching_FILES )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_abs_FILE ${_current_FILE} ABSOLUTE)\n\n      # if \"SKIP_AUTOMOC\" is set to true, we will not handle this file here.\n      # here. this is required to make bouic work correctly:\n      # we need to add generated .cpp files to the sources (to compile them),\n      # but we cannot let automoc handle them, as the .cpp files don't exist yet when\n      # cmake is run for the very first time on them -> however the .cpp files might\n      # exist at a later run. at that time we need to skip them, so that we don't add two\n      # different rules for the same moc file\n      get_source_file_property(_skip ${_abs_FILE} SKIP_AUTOMOC)\n\n      if (EXISTS ${_abs_FILE} AND NOT _skip)\n\n         file(STRINGS ${_abs_FILE} _match REGEX \"#include +[^ ]+\\\\.moc[\\\">]\")\n\n         get_filename_component(_abs_PATH ${_abs_FILE} PATH)\n\n         foreach (_current_MOC_INC IN LISTS _match)\n            string(REGEX MATCH \"[^ <\\\"]+\\\\.moc\" _current_MOC \"${_current_MOC_INC}\")\n\n            get_filename_component(_basename ${_current_MOC} NAME_WE)\n#            set(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)\n            set(_header ${_abs_PATH}/${_basename}.h)\n            set(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})\n\n            add_custom_command(OUTPUT ${_moc}\n               COMMAND ${QT_MOC_EXECUTABLE}\n               ARGS ${_header} -o ${_moc}\n               DEPENDS ${_header}\n            )\n\n            ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})\n\n         endforeach ()\n         unset(_match)\n         unset(_header)\n         unset(_moc)\n      endif ()\n   endforeach ()\nendmacro()\n\n# only used internally by KDE3_INSTALL_ICONS\nmacro (_KDE3_ADD_ICON_INSTALL_RULE _install_SCRIPT _install_PATH _group _orig_NAME _install_NAME)\n\n   # if the string doesn't match the pattern, the result is the full string, so all three have the same content\n   if (NOT ${_group} STREQUAL ${_install_NAME} )\n      set(_icon_GROUP \"actions\")\n\n      if (${_group} STREQUAL \"mime\")\n         set(_icon_GROUP  \"mimetypes\")\n      endif ()\n\n      if (${_group} STREQUAL \"filesys\")\n         set(_icon_GROUP  \"filesystems\")\n      endif ()\n\n      if (${_group} STREQUAL \"device\")\n         set(_icon_GROUP  \"devices\")\n      endif ()\n\n      if (${_group} STREQUAL \"app\")\n         set(_icon_GROUP  \"apps\")\n      endif ()\n\n      if (${_group} STREQUAL \"action\")\n         set(_icon_GROUP  \"actions\")\n      endif ()\n\n#      message(STATUS \"icon: ${_current_ICON} size: ${_size} group: ${_group} name: ${_name}\" )\n   install(FILES ${_orig_NAME} DESTINATION ${_install_PATH}/${_icon_GROUP}/ RENAME ${_install_NAME} )\n   endif ()\n\nendmacro ()\n\n\nmacro (KDE3_INSTALL_ICONS _theme )\n   set(_defaultpath \"${CMAKE_INSTALL_PREFIX}/share/icons\")\n   # first the png icons\n   file(GLOB _icons *.png)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\1\" _size  \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\2\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\3\" _name  \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n         ${_defaultpath}/${_theme}/${_size}x${_size}\n         ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\n   # and now the svg icons\n   file(GLOB _icons *.svgz)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\1\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\2\" _name \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n                                 ${_defaultpath}/${_theme}/scalable\n                                 ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\nendmacro ()\n\nmacro(KDE3_INSTALL_LIBTOOL_FILE _target)\n   get_target_property(_target_location ${_target} LOCATION)\n\n   get_filename_component(_laname ${_target_location} NAME_WE)\n   get_filename_component(_soname ${_target_location} NAME)\n   set(_laname ${CMAKE_CURRENT_BINARY_DIR}/${_laname}.la)\n\n   file(WRITE ${_laname} \"# ${_laname} - a libtool library file, generated by cmake \\n\")\n   file(APPEND ${_laname} \"# The name that we can dlopen(3).\\n\")\n   file(APPEND ${_laname} \"dlname='${_soname}'\\n\")\n   file(APPEND ${_laname} \"# Names of this library\\n\")\n   if(CYGWIN)\n     file(APPEND ${_laname} \"library_names='${_soname}'\\n\")\n   else()\n     file(APPEND ${_laname} \"library_names='${_soname} ${_soname} ${_soname}'\\n\")\n   endif()\n   file(APPEND ${_laname} \"# The name of the static archive\\n\")\n   file(APPEND ${_laname} \"old_library=''\\n\")\n   file(APPEND ${_laname} \"# Libraries that this one depends upon.\\n\")\n   file(APPEND ${_laname} \"dependency_libs=''\\n\")\n#   file(APPEND ${_laname} \"dependency_libs='${${_target}_LIB_DEPENDS}'\\n\")\n   file(APPEND ${_laname} \"# Version information.\\ncurrent=0\\nage=0\\nrevision=0\\n\")\n   file(APPEND ${_laname} \"# Is this an already installed library?\\ninstalled=yes\\n\")\n   file(APPEND ${_laname} \"# Should we warn about portability when linking against -modules?\\nshouldnotlink=yes\\n\")\n   file(APPEND ${_laname} \"# Files to dlopen/dlpreopen\\ndlopen=''\\ndlpreopen=''\\n\")\n   file(APPEND ${_laname} \"# Directory that this library needs to be installed in:\\n\")\n   file(APPEND ${_laname} \"libdir='${CMAKE_INSTALL_PREFIX}/lib/kde3'\\n\")\n\n   install_files(${KDE3_LIBTOOL_DIR} FILES ${_laname})\nendmacro()\n\n\nmacro(KDE3_CREATE_FINAL_FILE _filename)\n   file(WRITE ${_filename} \"//autogenerated file\\n\")\n   foreach (_current_FILE ${ARGN})\n      file(APPEND ${_filename} \"#include \\\"${_current_FILE}\\\"\\n\")\n   endforeach ()\n\nendmacro()\n\n\n# option(KDE3_ENABLE_FINAL \"Enable final all-in-one compilation\")\noption(KDE3_BUILD_TESTS  \"Build the tests\")\n\n\nmacro(KDE3_ADD_KPART _target_NAME _with_PREFIX)\n#is the first argument is \"WITH_PREFIX\" then keep the standard \"lib\" prefix, otherwise SET the prefix empty\n   if (${_with_PREFIX} STREQUAL \"WITH_PREFIX\")\n      set(_first_SRC)\n   else ()\n      set(_first_SRC ${_with_PREFIX})\n   endif ()\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${_first_SRC} ${ARGN})\n#       add_library(${_target_NAME} MODULE  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(${_target_NAME} MODULE ${_first_SRC} ${ARGN})\n#    endif ()\n\n   if(_first_SRC)\n      set_target_properties(${_target_NAME} PROPERTIES PREFIX \"\")\n   endif()\n\n   KDE3_INSTALL_LIBTOOL_FILE(${_target_NAME})\n\nendmacro()\n\n\nmacro(KDE3_ADD_KDEINIT_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_library(kdeinit_${_target_NAME} SHARED  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(kdeinit_${_target_NAME} SHARED ${ARGN} )\n#    endif ()\n\n   configure_file(${KDE3_MODULE_DIR}/kde3init_dummy.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp)\n\n   add_executable( ${_target_NAME} ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp )\n   target_link_libraries( ${_target_NAME} kdeinit_${_target_NAME} )\n\nendmacro()\n\n\nmacro(KDE3_ADD_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_executable(${_target_NAME} ${_target_NAME}_final.cpp)\n#    else ()\n   add_executable(${_target_NAME} ${ARGN} )\n#    endif ()\n\nendmacro()\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/Platform/Linux-Intel.cmake": "\n#=============================================================================\n# Copyright 2002-2009 Kitware, Inc.\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_INTEL)\n  return()\nendif()\nset(__LINUX_COMPILER_INTEL 1)\n\nif(NOT XIAR)\n  set(_intel_xiar_hints)\n  foreach(lang C CXX Fortran)\n    if(IS_ABSOLUTE \"${CMAKE_${lang}_COMPILER}\")\n      get_filename_component(_hint \"${CMAKE_${lang}_COMPILER}\" PATH)\n      list(APPEND _intel_xiar_hints ${_hint})\n    endif()\n  endforeach()\n  find_program(XIAR NAMES xiar HINTS ${_intel_xiar_hints})\n  mark_as_advanced(XIAR)\nendif()\n\nmacro(__linux_compiler_intel lang)\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIC \"-fPIC\")\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIE \"-fPIE\")\n  set(CMAKE_SHARED_LIBRARY_${lang}_FLAGS \"-fPIC\")\n  set(CMAKE_SHARED_LIBRARY_CREATE_${lang}_FLAGS \"-shared\")\n\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\n\n  if(XIAR)\n    # INTERPROCEDURAL_OPTIMIZATION\n    set(CMAKE_${lang}_COMPILE_OPTIONS_IPO -ipo)\n    set(CMAKE_${lang}_CREATE_STATIC_LIBRARY_IPO\n      \"${XIAR} cr <TARGET> <LINK_FLAGS> <OBJECTS> \"\n      \"${XIAR} -s <TARGET> \")\n  endif()\n\n  if(NOT CMAKE_${lang}_COMPILER_VERSION VERSION_LESS 12.0)\n    set(CMAKE_${lang}_COMPILE_OPTIONS_VISIBILITY \"-fvisibility=\")\n  endif()\nendmacro()\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/Platform/Linux-GNU.cmake": "\n#=============================================================================\n# Copyright 2010 Kitware, Inc.\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_GNU)\n  return()\nendif()\nset(__LINUX_COMPILER_GNU 1)\n\nmacro(__linux_compiler_gnu lang)\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\nendmacro()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Templates/Windows/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectLocal/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/StringFileTest/test.utf8",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/configure_file/UTF32LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/configure_file/UTF16LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/configure_file/UTF16BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/RunCMake/configure_file/UTF32BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ExternalProjectUpdate/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimplePixelShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Direct3DApp1_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimpleVertexShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/Sphinx/static/cmake-logo-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/Sphinx/static/cmake-favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample2.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample1.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample3.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/libbz2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/libbz2.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample2.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample1.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample1.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/sample2.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmbzip2/dlltest.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/krb4.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/security.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/cmcurl/cookie.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.1.0-apje4iyotloc7yiq4a6vq3yequmthm7u/spack-src/Modules/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 7460
}