{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Help/variable/CMAKE_DL_LIBS.rst": "CMAKE_DL_LIBS\n-------------\n\nName of library containing ``dlopen`` and ``dlclose``.\n\nThe name of the library that has ``dlopen`` and ``dlclose`` in it, usually\n``-ldl`` on most UNIX machines.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Help/policy/CMP0065.rst": "CMP0065\n-------\n\nDo not add flags to export symbols from executables without\nthe :prop_tgt:`ENABLE_EXPORTS` target property.\n\nCMake 3.3 and below, for historical reasons, always linked executables\non some platforms with flags like ``-rdynamic`` to export symbols from\nthe executables for use by any plugins they may load via ``dlopen``.\nCMake 3.4 and above prefer to do this only for executables that are\nexplicitly marked with the :prop_tgt:`ENABLE_EXPORTS` target property.\n\nThe ``OLD`` behavior of this policy is to always use the additional link\nflags when linking executables regardless of the value of the\n:prop_tgt:`ENABLE_EXPORTS` target property.\n\nThe ``NEW`` behavior of this policy is to only use the additional link\nflags when linking executables if the :prop_tgt:`ENABLE_EXPORTS` target\nproperty is set to ``True``.\n\nThis policy was introduced in CMake version 3.4.  Unlike most policies,\nCMake version |release| does *not* warn by default when this policy\nis not set and simply uses OLD behavior.  See documentation of the\n:variable:`CMAKE_POLICY_WARNING_CMP0065 <CMAKE_POLICY_WARNING_CMP<NNNN>>`\nvariable to control the warning.\n\n.. include:: DEPRECATED.txt\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Help/command/add_library.rst": "add_library\n-----------\n\n.. only:: html\n\n   .. contents::\n\nAdd a library to the project using the specified source files.\n\nNormal Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> [STATIC | SHARED | MODULE]\n              [EXCLUDE_FROM_ALL]\n              [source1] [source2 ...])\n\nAdds a library target called ``<name>`` to be built from the source files\nlisted in the command invocation.  (The source files can be omitted here\nif they are added later using :command:`target_sources`.)  The ``<name>``\ncorresponds to the logical target name and must be globally unique within\na project.  The actual file name of the library built is constructed based\non conventions of the native platform (such as ``lib<name>.a`` or\n``<name>.lib``).\n\n``STATIC``, ``SHARED``, or ``MODULE`` may be given to specify the type of\nlibrary to be created.  ``STATIC`` libraries are archives of object files\nfor use when linking other targets.  ``SHARED`` libraries are linked\ndynamically and loaded at runtime.  ``MODULE`` libraries are plugins that\nare not linked into other targets but may be loaded dynamically at runtime\nusing dlopen-like functionality.  If no type is given explicitly the\ntype is ``STATIC`` or ``SHARED`` based on whether the current value of the\nvariable :variable:`BUILD_SHARED_LIBS` is ``ON``.  For ``SHARED`` and\n``MODULE`` libraries the :prop_tgt:`POSITION_INDEPENDENT_CODE` target\nproperty is set to ``ON`` automatically.\nA ``SHARED`` or ``STATIC`` library may be marked with the :prop_tgt:`FRAMEWORK`\ntarget property to create an macOS Framework.\n\nIf a library does not export any symbols, it must not be declared as a\n``SHARED`` library.  For example, a Windows resource DLL or a managed C++/CLI\nDLL that exports no unmanaged symbols would need to be a ``MODULE`` library.\nThis is because CMake expects a ``SHARED`` library to always have an\nassociated import library on Windows.\n\nBy default the library file will be created in the build tree directory\ncorresponding to the source tree directory in which the command was\ninvoked.  See documentation of the :prop_tgt:`ARCHIVE_OUTPUT_DIRECTORY`,\n:prop_tgt:`LIBRARY_OUTPUT_DIRECTORY`, and\n:prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` target properties to change this\nlocation.  See documentation of the :prop_tgt:`OUTPUT_NAME` target\nproperty to change the ``<name>`` part of the final file name.\n\nIf ``EXCLUDE_FROM_ALL`` is given the corresponding property will be set on\nthe created target.  See documentation of the :prop_tgt:`EXCLUDE_FROM_ALL`\ntarget property for details.\n\nSource arguments to ``add_library`` may use \"generator expressions\" with\nthe syntax ``$<...>``.  See the :manual:`cmake-generator-expressions(7)`\nmanual for available expressions.  See the :manual:`cmake-buildsystem(7)`\nmanual for more on defining buildsystem properties.\n\nSee also :prop_sf:`HEADER_FILE_ONLY` on what to do if some sources are\npre-processed, and you want to have the original sources reachable from\nwithin IDE.\n\nImported Libraries\n^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED\n              [GLOBAL])\n\nAn :ref:`IMPORTED library target <Imported Targets>` references a library\nfile located outside the project.  No rules are generated to build it, and\nthe :prop_tgt:`IMPORTED` target property is ``True``.  The target name has\nscope in the directory in which it is created and below, but the ``GLOBAL``\noption extends visibility.  It may be referenced like any target built\nwithin the project.  ``IMPORTED`` libraries are useful for convenient\nreference from commands like :command:`target_link_libraries`.  Details\nabout the imported library are specified by setting properties whose names\nbegin in ``IMPORTED_`` and ``INTERFACE_``.  The most important such\nproperty is :prop_tgt:`IMPORTED_LOCATION` (and its per-configuration\nvariant :prop_tgt:`IMPORTED_LOCATION_<CONFIG>`) which specifies the\nlocation of the main library file on disk.  Or, for object libraries,\n:prop_tgt:`IMPORTED_OBJECTS` (and :prop_tgt:`IMPORTED_OBJECTS_<CONFIG>`)\nspecifies the locations of object files on disk.\nSee documentation of the ``IMPORTED_*`` and ``INTERFACE_*`` properties\nfor more information.\n\nObject Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> OBJECT <src>...)\n\nCreates an :ref:`Object Library <Object Libraries>`.  An object library\ncompiles source files but does not archive or link their object files into a\nlibrary.  Instead other targets created by :command:`add_library` or\n:command:`add_executable` may reference the objects using an expression of the\nform ``$<TARGET_OBJECTS:objlib>`` as a source, where ``objlib`` is the\nobject library name.  For example:\n\n.. code-block:: cmake\n\n  add_library(... $<TARGET_OBJECTS:objlib> ...)\n  add_executable(... $<TARGET_OBJECTS:objlib> ...)\n\nwill include objlib's object files in a library and an executable\nalong with those compiled from their own sources.  Object libraries\nmay contain only sources that compile, header files, and other files\nthat would not affect linking of a normal library (e.g. ``.txt``).\nThey may contain custom commands generating such sources, but not\n``PRE_BUILD``, ``PRE_LINK``, or ``POST_BUILD`` commands.  Some native build\nsystems (such as Xcode) may not like targets that have only object files, so\nconsider adding at least one real source file to any target that references\n``$<TARGET_OBJECTS:objlib>``.\n\nAlias Libraries\n^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> ALIAS <target>)\n\nCreates an :ref:`Alias Target <Alias Targets>`, such that ``<name>`` can be\nused to refer to ``<target>`` in subsequent commands.  The ``<name>`` does\nnot appear in the generated buildsystem as a make target.  The ``<target>``\nmay not be a non-``GLOBAL`` :ref:`Imported Target <Imported Targets>` or an\n``ALIAS``.\n``ALIAS`` targets can be used as linkable targets and as targets to\nread properties from.  They can also be tested for existence with the\nregular :command:`if(TARGET)` subcommand.  The ``<name>`` may not be used\nto modify properties of ``<target>``, that is, it may not be used as the\noperand of :command:`set_property`, :command:`set_target_properties`,\n:command:`target_link_libraries` etc.  An ``ALIAS`` target may not be\ninstalled or exported.\n\nInterface Libraries\n^^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n\nCreates an :ref:`Interface Library <Interface Libraries>`.  An ``INTERFACE``\nlibrary target does not directly create build output, though it may\nhave properties set on it and it may be installed, exported and\nimported. Typically the ``INTERFACE_*`` properties are populated on\nthe interface target using the commands:\n\n* :command:`set_property`,\n* :command:`target_link_libraries(INTERFACE)`,\n* :command:`target_link_options(INTERFACE)`,\n* :command:`target_include_directories(INTERFACE)`,\n* :command:`target_compile_options(INTERFACE)`,\n* :command:`target_compile_definitions(INTERFACE)`, and\n* :command:`target_sources(INTERFACE)`,\n\nand then it is used as an argument to :command:`target_link_libraries`\nlike any other target.\n\nAn ``INTERFACE`` :ref:`Imported Target <Imported Targets>` may also be\ncreated with this signature.  An ``IMPORTED`` library target references a\nlibrary defined outside the project.  The target name has scope in the\ndirectory in which it is created and below, but the ``GLOBAL`` option\nextends visibility.  It may be referenced like any target built within\nthe project.  ``IMPORTED`` libraries are useful for convenient reference\nfrom commands like :command:`target_link_libraries`.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/BundleUtilities/testbundleutils1.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#  include <windows.h>\n#else\n#  include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module1.dll\");\n  if (!lib) {\n    printf(\"Failed to open module1\\n\");\n  }\n#else\n  void* lib = dlopen(\"module1.so\", RTLD_LAZY);\n  if (!lib) {\n    printf(\"Failed to open module1\\n%s\\n\", dlerror());\n  }\n#endif\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/BundleUtilities/testbundleutils2.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#  include <windows.h>\n#else\n#  include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module2.dll\");\n  if (!lib) {\n    printf(\"Failed to open module2\\n\");\n  }\n#else\n  void* lib = dlopen(\"module2.so\", RTLD_LAZY);\n  if (!lib) {\n    printf(\"Failed to open module2\\n%s\\n\", dlerror());\n  }\n#endif\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/BundleUtilities/testbundleutils3.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#  include <windows.h>\n#else\n#  include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module3.dll\");\n  if (!lib) {\n    printf(\"Failed to open module3\\n\");\n  }\n#else\n  void* lib = dlopen(\"module3.so\", RTLD_LAZY);\n  if (!lib) {\n    printf(\"Failed to open module3\\n%s\\n\", dlerror());\n  }\n#endif\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!MultiByteToWideChar(CP_UTF8,\n                           0,\n                           filename,\n                           -1,\n                           filename_w,\n                           ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  *ptr = (void*) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, \"\", *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic void uv__format_fallback_error(uv_lib_t* lib, int errorno){\n  DWORD_PTR args[1] = { (DWORD_PTR) errorno };\n  LPSTR fallback_error = \"error: %1!d!\";\n\n  FormatMessageA(FORMAT_MESSAGE_FROM_STRING |\n                 FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                 FORMAT_MESSAGE_ALLOCATE_BUFFER,\n                 fallback_error, 0, 0,\n                 (LPSTR) &lib->errmsg,\n                 0, (va_list*) args);\n}\n\n\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno) {\n  DWORD_PTR arg;\n  DWORD res;\n  char* msg;\n\n  if (lib->errmsg) {\n    LocalFree(lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno == 0)\n    return 0;\n\n  res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                       (LPSTR) &lib->errmsg, 0, NULL);\n\n  if (!res && GetLastError() == ERROR_MUI_FILE_NOT_FOUND) {\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                         0, (LPSTR) &lib->errmsg, 0, NULL);\n  }\n\n  if (res && errorno == ERROR_BAD_EXE_FORMAT && strstr(lib->errmsg, \"%1\")) {\n    msg = lib->errmsg;\n    lib->errmsg = NULL;\n    arg = (DWORD_PTR) filename;\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                         FORMAT_MESSAGE_FROM_STRING,\n                         msg,\n                         0, 0, (LPSTR) &lib->errmsg, 0, (va_list*) &arg);\n    LocalFree(msg);\n  }\n\n  if (!res)\n    uv__format_fallback_error(lib, errorno);\n\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/src/unix/darwin-proctitle.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <TargetConditionals.h>\n\n#if !TARGET_OS_IPHONE\n# include <CoreFoundation/CoreFoundation.h>\n# include <ApplicationServices/ApplicationServices.h>\n#endif\n\n\nstatic int uv__pthread_setname_np(const char* name) {\n  int (*dynamic_pthread_setname_np)(const char* name);\n  char namebuf[64];  /* MAXTHREADNAMESIZE */\n  int err;\n\n  /* pthread_setname_np() first appeared in OS X 10.6 and iOS 3.2. */\n  *(void **)(&dynamic_pthread_setname_np) =\n      dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n\n  if (dynamic_pthread_setname_np == NULL)\n    return UV_ENOSYS;\n\n  strncpy(namebuf, name, sizeof(namebuf) - 1);\n  namebuf[sizeof(namebuf) - 1] = '\\0';\n\n  err = dynamic_pthread_setname_np(namebuf);\n  if (err)\n    return UV__ERR(err);\n\n  return 0;\n}\n\n\nint uv__set_process_title(const char* title) {\n#if TARGET_OS_IPHONE\n  return uv__pthread_setname_np(title);\n#else\n  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                            const char*,\n                                            CFStringEncoding);\n  CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);\n  void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);\n  void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);\n  CFTypeRef (*pLSGetCurrentApplicationASN)(void);\n  OSStatus (*pLSSetApplicationInformationItem)(int,\n                                               CFTypeRef,\n                                               CFStringRef,\n                                               CFStringRef,\n                                               CFDictionaryRef*);\n  void* application_services_handle;\n  void* core_foundation_handle;\n  CFBundleRef launch_services_bundle;\n  CFStringRef* display_name_key;\n  CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);\n  CFBundleRef (*pCFBundleGetMainBundle)(void);\n  CFBundleRef hi_services_bundle;\n  OSStatus (*pSetApplicationIsDaemon)(int);\n  CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);\n  void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,\n                                                                void*);\n  CFTypeRef asn;\n  int err;\n\n  err = UV_ENOENT;\n  application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                       \"ApplicationServices.framework/\"\n                                       \"Versions/A/ApplicationServices\",\n                                       RTLD_LAZY | RTLD_LOCAL);\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n\n  if (application_services_handle == NULL || core_foundation_handle == NULL)\n    goto out;\n\n  *(void **)(&pCFStringCreateWithCString) =\n      dlsym(core_foundation_handle, \"CFStringCreateWithCString\");\n  *(void **)(&pCFBundleGetBundleWithIdentifier) =\n      dlsym(core_foundation_handle, \"CFBundleGetBundleWithIdentifier\");\n  *(void **)(&pCFBundleGetDataPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetDataPointerForName\");\n  *(void **)(&pCFBundleGetFunctionPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetFunctionPointerForName\");\n\n  if (pCFStringCreateWithCString == NULL ||\n      pCFBundleGetBundleWithIdentifier == NULL ||\n      pCFBundleGetDataPointerForName == NULL ||\n      pCFBundleGetFunctionPointerForName == NULL) {\n    goto out;\n  }\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n  launch_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.LaunchServices\"));\n\n  if (launch_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pLSGetCurrentApplicationASN) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSGetCurrentApplicationASN\"));\n\n  if (pLSGetCurrentApplicationASN == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationInformationItem) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSSetApplicationInformationItem\"));\n\n  if (pLSSetApplicationInformationItem == NULL)\n    goto out;\n\n  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,\n                                                    S(\"_kLSDisplayNameKey\"));\n\n  if (display_name_key == NULL || *display_name_key == NULL)\n    goto out;\n\n  *(void **)(&pCFBundleGetInfoDictionary) = dlsym(core_foundation_handle,\n                                     \"CFBundleGetInfoDictionary\");\n  *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,\n                                 \"CFBundleGetMainBundle\");\n  if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)\n    goto out;\n\n  /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */\n  hi_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.HIServices\"));\n  err = UV_ENOENT;\n  if (hi_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pSetApplicationIsDaemon) = pCFBundleGetFunctionPointerForName(\n      hi_services_bundle,\n      S(\"SetApplicationIsDaemon\"));\n  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(\n      launch_services_bundle,\n      S(\"_LSApplicationCheckIn\"));\n  *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =\n      pCFBundleGetFunctionPointerForName(\n          launch_services_bundle,\n          S(\"_LSSetApplicationLaunchServicesServerConnectionStatus\"));\n  if (pSetApplicationIsDaemon == NULL ||\n      pLSApplicationCheckIn == NULL ||\n      pLSSetApplicationLaunchServicesServerConnectionStatus == NULL) {\n    goto out;\n  }\n\n  if (pSetApplicationIsDaemon(1) != noErr)\n    goto out;\n\n  pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);\n\n  /* Check into process manager?! */\n  pLSApplicationCheckIn(-2,\n                        pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));\n\n  asn = pLSGetCurrentApplicationASN();\n\n  err = UV_EINVAL;\n  if (pLSSetApplicationInformationItem(-2,  /* Magic value. */\n                                       asn,\n                                       *display_name_key,\n                                       S(title),\n                                       NULL) != noErr) {\n    goto out;\n  }\n\n  uv__pthread_setname_np(title);  /* Don't care if it fails. */\n  err = 0;\n\nout:\n  if (core_foundation_handle != NULL)\n    dlclose(core_foundation_handle);\n\n  if (application_services_handle != NULL)\n    dlclose(application_services_handle);\n\n  return err;\n#endif  /* !TARGET_OS_IPHONE */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/src/unix/fsevents.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#if TARGET_OS_IPHONE\n\n/* iOS (currently) doesn't provide the FSEvents-API (nor CoreServices) */\n\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n}\n\n#else /* TARGET_OS_IPHONE */\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include <CoreFoundation/CFRunLoop.h>\n#include <CoreServices/CoreServices.h>\n\n/* These are macros to avoid \"initializer element is not constant\" errors\n * with old versions of gcc.\n */\n#define kFSEventsModified (kFSEventStreamEventFlagItemFinderInfoMod |         \\\n                           kFSEventStreamEventFlagItemModified |              \\\n                           kFSEventStreamEventFlagItemInodeMetaMod |          \\\n                           kFSEventStreamEventFlagItemChangeOwner |           \\\n                           kFSEventStreamEventFlagItemXattrMod)\n\n#define kFSEventsRenamed  (kFSEventStreamEventFlagItemCreated |               \\\n                           kFSEventStreamEventFlagItemRemoved |               \\\n                           kFSEventStreamEventFlagItemRenamed)\n\n#define kFSEventsSystem   (kFSEventStreamEventFlagUserDropped |               \\\n                           kFSEventStreamEventFlagKernelDropped |             \\\n                           kFSEventStreamEventFlagEventIdsWrapped |           \\\n                           kFSEventStreamEventFlagHistoryDone |               \\\n                           kFSEventStreamEventFlagMount |                     \\\n                           kFSEventStreamEventFlagUnmount |                   \\\n                           kFSEventStreamEventFlagRootChanged)\n\ntypedef struct uv__fsevents_event_s uv__fsevents_event_t;\ntypedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;\ntypedef struct uv__cf_loop_state_s uv__cf_loop_state_t;\n\nenum uv__cf_loop_signal_type_e {\n  kUVCFLoopSignalRegular,\n  kUVCFLoopSignalClosing\n};\ntypedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;\n\nstruct uv__cf_loop_signal_s {\n  QUEUE member;\n  uv_fs_event_t* handle;\n  uv__cf_loop_signal_type_t type;\n};\n\nstruct uv__fsevents_event_s {\n  QUEUE member;\n  int events;\n  char path[1];\n};\n\nstruct uv__cf_loop_state_s {\n  CFRunLoopRef loop;\n  CFRunLoopSourceRef signal_source;\n  int fsevent_need_reschedule;\n  FSEventStreamRef fsevent_stream;\n  uv_sem_t fsevent_sem;\n  uv_mutex_t fsevent_mutex;\n  void* fsevent_handles[2];\n  unsigned int fsevent_handle_count;\n};\n\n/* Forward declarations */\nstatic void uv__cf_loop_cb(void* arg);\nstatic void* uv__cf_loop_runner(void* arg);\nstatic int uv__cf_loop_signal(uv_loop_t* loop,\n                              uv_fs_event_t* handle,\n                              uv__cf_loop_signal_type_t type);\n\n/* Lazy-loaded by uv__fsevents_global_init(). */\nstatic CFArrayRef (*pCFArrayCreate)(CFAllocatorRef,\n                                    const void**,\n                                    CFIndex,\n                                    const CFArrayCallBacks*);\nstatic void (*pCFRelease)(CFTypeRef);\nstatic void (*pCFRunLoopAddSource)(CFRunLoopRef,\n                                   CFRunLoopSourceRef,\n                                   CFStringRef);\nstatic CFRunLoopRef (*pCFRunLoopGetCurrent)(void);\nstatic void (*pCFRunLoopRemoveSource)(CFRunLoopRef,\n                                      CFRunLoopSourceRef,\n                                      CFStringRef);\nstatic void (*pCFRunLoopRun)(void);\nstatic CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef,\n                                                    CFIndex,\n                                                    CFRunLoopSourceContext*);\nstatic void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);\nstatic void (*pCFRunLoopStop)(CFRunLoopRef);\nstatic void (*pCFRunLoopWakeUp)(CFRunLoopRef);\nstatic CFStringRef (*pCFStringCreateWithFileSystemRepresentation)(\n    CFAllocatorRef,\n    const char*);\nstatic CFStringEncoding (*pCFStringGetSystemEncoding)(void);\nstatic CFStringRef (*pkCFRunLoopDefaultMode);\nstatic FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef,\n                                                FSEventStreamCallback,\n                                                FSEventStreamContext*,\n                                                CFArrayRef,\n                                                FSEventStreamEventId,\n                                                CFTimeInterval,\n                                                FSEventStreamCreateFlags);\nstatic void (*pFSEventStreamFlushSync)(FSEventStreamRef);\nstatic void (*pFSEventStreamInvalidate)(FSEventStreamRef);\nstatic void (*pFSEventStreamRelease)(FSEventStreamRef);\nstatic void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,\n                                                 CFRunLoopRef,\n                                                 CFStringRef);\nstatic Boolean (*pFSEventStreamStart)(FSEventStreamRef);\nstatic void (*pFSEventStreamStop)(FSEventStreamRef);\n\n#define UV__FSEVENTS_PROCESS(handle, block)                                   \\\n    do {                                                                      \\\n      QUEUE events;                                                           \\\n      QUEUE* q;                                                               \\\n      uv__fsevents_event_t* event;                                            \\\n      int err;                                                                \\\n      uv_mutex_lock(&(handle)->cf_mutex);                                     \\\n      /* Split-off all events and empty original queue */                     \\\n      QUEUE_MOVE(&(handle)->cf_events, &events);                              \\\n      /* Get error (if any) and zero original one */                          \\\n      err = (handle)->cf_error;                                               \\\n      (handle)->cf_error = 0;                                                 \\\n      uv_mutex_unlock(&(handle)->cf_mutex);                                   \\\n      /* Loop through events, deallocating each after processing */           \\\n      while (!QUEUE_EMPTY(&events)) {                                         \\\n        q = QUEUE_HEAD(&events);                                              \\\n        event = QUEUE_DATA(q, uv__fsevents_event_t, member);                  \\\n        QUEUE_REMOVE(q);                                                      \\\n        /* NOTE: Checking uv__is_active() is required here, because handle    \\\n         * callback may close handle and invoking it after it will lead to    \\\n         * incorrect behaviour */                                             \\\n        if (!uv__is_closing((handle)) && uv__is_active((handle)))             \\\n          block                                                               \\\n        /* Free allocated data */                                             \\\n        uv__free(event);                                                      \\\n      }                                                                       \\\n      if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))   \\\n        (handle)->cb((handle), NULL, 0, err);                                 \\\n    } while (0)\n\n\n/* Runs in UV loop's thread, when there're events to report to handle */\nstatic void uv__fsevents_cb(uv_async_t* cb) {\n  uv_fs_event_t* handle;\n\n  handle = cb->data;\n\n  UV__FSEVENTS_PROCESS(handle, {\n    handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);\n  });\n}\n\n\n/* Runs in CF thread, pushed event into handle's event list */\nstatic void uv__fsevents_push_event(uv_fs_event_t* handle,\n                                    QUEUE* events,\n                                    int err) {\n  assert(events != NULL || err != 0);\n  uv_mutex_lock(&handle->cf_mutex);\n\n  /* Concatenate two queues */\n  if (events != NULL)\n    QUEUE_ADD(&handle->cf_events, events);\n\n  /* Propagate error */\n  if (err != 0)\n    handle->cf_error = err;\n  uv_mutex_unlock(&handle->cf_mutex);\n\n  uv_async_send(handle->cf_cb);\n}\n\n\n/* Runs in CF thread, when there're events in FSEventStream */\nstatic void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n                                  void* info,\n                                  size_t numEvents,\n                                  void* eventPaths,\n                                  const FSEventStreamEventFlags eventFlags[],\n                                  const FSEventStreamEventId eventIds[]) {\n  size_t i;\n  int len;\n  char** paths;\n  char* path;\n  char* pos;\n  uv_fs_event_t* handle;\n  QUEUE* q;\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  uv__fsevents_event_t* event;\n  FSEventStreamEventFlags flags;\n  QUEUE head;\n\n  loop = info;\n  state = loop->cf_state;\n  assert(state != NULL);\n  paths = eventPaths;\n\n  /* For each handle */\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_FOREACH(q, &state->fsevent_handles) {\n    handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n    QUEUE_INIT(&head);\n\n    /* Process and filter out events */\n    for (i = 0; i < numEvents; i++) {\n      flags = eventFlags[i];\n\n      /* Ignore system events */\n      if (flags & kFSEventsSystem)\n        continue;\n\n      path = paths[i];\n      len = strlen(path);\n\n      /* Filter out paths that are outside handle's request */\n      if (strncmp(path, handle->realpath, handle->realpath_len) != 0)\n        continue;\n\n      if (handle->realpath_len > 1 || *handle->realpath != '/') {\n        path += handle->realpath_len;\n        len -= handle->realpath_len;\n\n        /* Skip forward slash */\n        if (*path != '\\0') {\n          path++;\n          len--;\n        }\n      }\n\n#ifdef MAC_OS_X_VERSION_10_7\n      /* Ignore events with path equal to directory itself */\n      if (len == 0)\n        continue;\n#else\n      if (len == 0 && (flags & kFSEventStreamEventFlagItemIsDir))\n        continue;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      /* Do not emit events from subdirectories (without option set) */\n      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != 0) {\n        pos = strchr(path + 1, '/');\n        if (pos != NULL)\n          continue;\n      }\n\n#ifndef MAC_OS_X_VERSION_10_7\n      path = \"\";\n      len = 0;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      event = uv__malloc(sizeof(*event) + len);\n      if (event == NULL)\n        break;\n\n      memset(event, 0, sizeof(*event));\n      memcpy(event->path, path, len + 1);\n      event->events = UV_RENAME;\n\n#ifdef MAC_OS_X_VERSION_10_7\n      if (0 != (flags & kFSEventsModified) &&\n          0 == (flags & kFSEventsRenamed)) {\n        event->events = UV_CHANGE;\n      }\n#else\n      if (0 != (flags & kFSEventsModified) &&\n          0 != (flags & kFSEventStreamEventFlagItemIsDir) &&\n          0 == (flags & kFSEventStreamEventFlagItemRenamed)) {\n        event->events = UV_CHANGE;\n      }\n      if (0 == (flags & kFSEventStreamEventFlagItemIsDir) &&\n          0 == (flags & kFSEventStreamEventFlagItemRenamed)) {\n        event->events = UV_CHANGE;\n      }\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      QUEUE_INSERT_TAIL(&head, &event->member);\n    }\n\n    if (!QUEUE_EMPTY(&head))\n      uv__fsevents_push_event(handle, &head, 0);\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n}\n\n\n/* Runs in CF thread */\nstatic int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n  uv__cf_loop_state_t* state;\n  FSEventStreamContext ctx;\n  FSEventStreamRef ref;\n  CFAbsoluteTime latency;\n  FSEventStreamCreateFlags flags;\n\n  /* Initialize context */\n  ctx.version = 0;\n  ctx.info = loop;\n  ctx.retain = NULL;\n  ctx.release = NULL;\n  ctx.copyDescription = NULL;\n\n  latency = 0.05;\n\n  /* Explanation of selected flags:\n   * 1. NoDefer - without this flag, events that are happening continuously\n   *    (i.e. each event is happening after time interval less than `latency`,\n   *    counted from previous event), will be deferred and passed to callback\n   *    once they'll either fill whole OS buffer, or when this continuous stream\n   *    will stop (i.e. there'll be delay between events, bigger than\n   *    `latency`).\n   *    Specifying this flag will invoke callback after `latency` time passed\n   *    since event.\n   * 2. FileEvents - fire callback for file changes too (by default it is firing\n   *    it only for directory changes).\n   */\n  flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;\n\n  /*\n   * NOTE: It might sound like a good idea to remember last seen StreamEventId,\n   * but in reality one dir might have last StreamEventId less than, the other,\n   * that is being watched now. Which will cause FSEventStream API to report\n   * changes to files from the past.\n   */\n  ref = pFSEventStreamCreate(NULL,\n                             &uv__fsevents_event_cb,\n                             &ctx,\n                             paths,\n                             kFSEventStreamEventIdSinceNow,\n                             latency,\n                             flags);\n  assert(ref != NULL);\n\n  state = loop->cf_state;\n  pFSEventStreamScheduleWithRunLoop(ref,\n                                    state->loop,\n                                    *pkCFRunLoopDefaultMode);\n  if (!pFSEventStreamStart(ref)) {\n    pFSEventStreamInvalidate(ref);\n    pFSEventStreamRelease(ref);\n    return UV_EMFILE;\n  }\n\n  state->fsevent_stream = ref;\n  return 0;\n}\n\n\n/* Runs in CF thread */\nstatic void uv__fsevents_destroy_stream(uv_loop_t* loop) {\n  uv__cf_loop_state_t* state;\n\n  state = loop->cf_state;\n\n  if (state->fsevent_stream == NULL)\n    return;\n\n  /* Stop emitting events */\n  pFSEventStreamStop(state->fsevent_stream);\n\n  /* Release stream */\n  pFSEventStreamInvalidate(state->fsevent_stream);\n  pFSEventStreamRelease(state->fsevent_stream);\n  state->fsevent_stream = NULL;\n}\n\n\n/* Runs in CF thread, when there're new fsevent handles to add to stream */\nstatic void uv__fsevents_reschedule(uv_fs_event_t* handle,\n                                    uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n  uv_fs_event_t* curr;\n  CFArrayRef cf_paths;\n  CFStringRef* paths;\n  unsigned int i;\n  int err;\n  unsigned int path_count;\n\n  state = handle->loop->cf_state;\n  paths = NULL;\n  cf_paths = NULL;\n  err = 0;\n  /* NOTE: `i` is used in deallocation loop below */\n  i = 0;\n\n  /* Optimization to prevent O(n^2) time spent when starting to watch\n   * many files simultaneously\n   */\n  uv_mutex_lock(&state->fsevent_mutex);\n  if (state->fsevent_need_reschedule == 0) {\n    uv_mutex_unlock(&state->fsevent_mutex);\n    goto final;\n  }\n  state->fsevent_need_reschedule = 0;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Destroy previous FSEventStream */\n  uv__fsevents_destroy_stream(handle->loop);\n\n  /* Any failure below will be a memory failure */\n  err = UV_ENOMEM;\n\n  /* Create list of all watched paths */\n  uv_mutex_lock(&state->fsevent_mutex);\n  path_count = state->fsevent_handle_count;\n  if (path_count != 0) {\n    paths = uv__malloc(sizeof(*paths) * path_count);\n    if (paths == NULL) {\n      uv_mutex_unlock(&state->fsevent_mutex);\n      goto final;\n    }\n\n    q = &state->fsevent_handles;\n    for (; i < path_count; i++) {\n      q = QUEUE_NEXT(q);\n      assert(q != &state->fsevent_handles);\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n\n      assert(curr->realpath != NULL);\n      paths[i] =\n          pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath);\n      if (paths[i] == NULL) {\n        uv_mutex_unlock(&state->fsevent_mutex);\n        goto final;\n      }\n    }\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n  err = 0;\n\n  if (path_count != 0) {\n    /* Create new FSEventStream */\n    cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n    if (cf_paths == NULL) {\n      err = UV_ENOMEM;\n      goto final;\n    }\n    err = uv__fsevents_create_stream(handle->loop, cf_paths);\n  }\n\nfinal:\n  /* Deallocate all paths in case of failure */\n  if (err != 0) {\n    if (cf_paths == NULL) {\n      while (i != 0)\n        pCFRelease(paths[--i]);\n      uv__free(paths);\n    } else {\n      /* CFArray takes ownership of both strings and original C-array */\n      pCFRelease(cf_paths);\n    }\n\n    /* Broadcast error to all handles */\n    uv_mutex_lock(&state->fsevent_mutex);\n    QUEUE_FOREACH(q, &state->fsevent_handles) {\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n      uv__fsevents_push_event(curr, NULL, err);\n    }\n    uv_mutex_unlock(&state->fsevent_mutex);\n  }\n\n  /*\n   * Main thread will block until the removal of handle from the list,\n   * we must tell it when we're ready.\n   *\n   * NOTE: This is coupled with `uv_sem_wait()` in `uv__fsevents_close`\n   */\n  if (type == kUVCFLoopSignalClosing)\n    uv_sem_post(&state->fsevent_sem);\n}\n\n\nstatic int uv__fsevents_global_init(void) {\n  static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static void* core_foundation_handle;\n  static void* core_services_handle;\n  int err;\n\n  err = 0;\n  pthread_mutex_lock(&global_init_mutex);\n  if (core_foundation_handle != NULL)\n    goto out;\n\n  /* The libraries are never unloaded because we currently don't have a good\n   * mechanism for keeping a reference count. It's unlikely to be an issue\n   * but if it ever becomes one, we can turn the dynamic library handles into\n   * per-event loop properties and have the dynamic linker keep track for us.\n   */\n  err = UV_ENOSYS;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  if (core_foundation_handle == NULL)\n    goto out;\n\n  core_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                \"CoreServices.framework/\"\n                                \"Versions/A/CoreServices\",\n                                RTLD_LAZY | RTLD_LOCAL);\n  if (core_services_handle == NULL)\n    goto out;\n\n  err = UV_ENOENT;\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(core_foundation_handle, CFArrayCreate);\n  V(core_foundation_handle, CFRelease);\n  V(core_foundation_handle, CFRunLoopAddSource);\n  V(core_foundation_handle, CFRunLoopGetCurrent);\n  V(core_foundation_handle, CFRunLoopRemoveSource);\n  V(core_foundation_handle, CFRunLoopRun);\n  V(core_foundation_handle, CFRunLoopSourceCreate);\n  V(core_foundation_handle, CFRunLoopSourceSignal);\n  V(core_foundation_handle, CFRunLoopStop);\n  V(core_foundation_handle, CFRunLoopWakeUp);\n  V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, kCFRunLoopDefaultMode);\n  V(core_services_handle, FSEventStreamCreate);\n  V(core_services_handle, FSEventStreamFlushSync);\n  V(core_services_handle, FSEventStreamInvalidate);\n  V(core_services_handle, FSEventStreamRelease);\n  V(core_services_handle, FSEventStreamScheduleWithRunLoop);\n  V(core_services_handle, FSEventStreamStart);\n  V(core_services_handle, FSEventStreamStop);\n#undef V\n  err = 0;\n\nout:\n  if (err && core_services_handle != NULL) {\n    dlclose(core_services_handle);\n    core_services_handle = NULL;\n  }\n\n  if (err && core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  pthread_mutex_unlock(&global_init_mutex);\n  return err;\n}\n\n\n/* Runs in UV loop */\nstatic int uv__fsevents_loop_init(uv_loop_t* loop) {\n  CFRunLoopSourceContext ctx;\n  uv__cf_loop_state_t* state;\n  pthread_attr_t attr_storage;\n  pthread_attr_t* attr;\n  int err;\n\n  if (loop->cf_state != NULL)\n    return 0;\n\n  err = uv__fsevents_global_init();\n  if (err)\n    return err;\n\n  state = uv__calloc(1, sizeof(*state));\n  if (state == NULL)\n    return UV_ENOMEM;\n\n  err = uv_mutex_init(&loop->cf_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_sem_init(&loop->cf_sem, 0);\n  if (err)\n    goto fail_sem_init;\n\n  QUEUE_INIT(&loop->cf_signals);\n\n  err = uv_sem_init(&state->fsevent_sem, 0);\n  if (err)\n    goto fail_fsevent_sem_init;\n\n  err = uv_mutex_init(&state->fsevent_mutex);\n  if (err)\n    goto fail_fsevent_mutex_init;\n\n  QUEUE_INIT(&state->fsevent_handles);\n  state->fsevent_need_reschedule = 0;\n  state->fsevent_handle_count = 0;\n\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n  ctx.perform = uv__cf_loop_cb;\n  state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n  if (state->signal_source == NULL) {\n    err = UV_ENOMEM;\n    goto fail_signal_source_create;\n  }\n\n  /* In the unlikely event that pthread_attr_init() fails, create the thread\n   * with the default stack size. We'll use a little more address space but\n   * that in itself is not a fatal error.\n   */\n  attr = &attr_storage;\n  if (pthread_attr_init(attr))\n    attr = NULL;\n\n  if (attr != NULL)\n    if (pthread_attr_setstacksize(attr, 4 * PTHREAD_STACK_MIN))\n      abort();\n\n  loop->cf_state = state;\n\n  /* uv_thread_t is an alias for pthread_t. */\n  err = UV__ERR(pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop));\n\n  if (attr != NULL)\n    pthread_attr_destroy(attr);\n\n  if (err)\n    goto fail_thread_create;\n\n  /* Synchronize threads */\n  uv_sem_wait(&loop->cf_sem);\n  return 0;\n\nfail_thread_create:\n  loop->cf_state = NULL;\n\nfail_signal_source_create:\n  uv_mutex_destroy(&state->fsevent_mutex);\n\nfail_fsevent_mutex_init:\n  uv_sem_destroy(&state->fsevent_sem);\n\nfail_fsevent_sem_init:\n  uv_sem_destroy(&loop->cf_sem);\n\nfail_sem_init:\n  uv_mutex_destroy(&loop->cf_mutex);\n\nfail_mutex_init:\n  uv__free(state);\n  return err;\n}\n\n\n/* Runs in UV loop */\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n  uv__cf_loop_signal_t* s;\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n\n  if (loop->cf_state == NULL)\n    return;\n\n  if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0)\n    abort();\n\n  uv_thread_join(&loop->cf_thread);\n  uv_sem_destroy(&loop->cf_sem);\n  uv_mutex_destroy(&loop->cf_mutex);\n\n  /* Free any remaining data */\n  while (!QUEUE_EMPTY(&loop->cf_signals)) {\n    q = QUEUE_HEAD(&loop->cf_signals);\n    s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);\n    QUEUE_REMOVE(q);\n    uv__free(s);\n  }\n\n  /* Destroy state */\n  state = loop->cf_state;\n  uv_sem_destroy(&state->fsevent_sem);\n  uv_mutex_destroy(&state->fsevent_mutex);\n  pCFRelease(state->signal_source);\n  uv__free(state);\n  loop->cf_state = NULL;\n}\n\n\n/* Runs in CF thread. This is the CF loop's body */\nstatic void* uv__cf_loop_runner(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n\n  loop = arg;\n  state = loop->cf_state;\n  state->loop = pCFRunLoopGetCurrent();\n\n  pCFRunLoopAddSource(state->loop,\n                      state->signal_source,\n                      *pkCFRunLoopDefaultMode);\n\n  uv_sem_post(&loop->cf_sem);\n\n  pCFRunLoopRun();\n  pCFRunLoopRemoveSource(state->loop,\n                         state->signal_source,\n                         *pkCFRunLoopDefaultMode);\n\n  return NULL;\n}\n\n\n/* Runs in CF thread, executed after `uv__cf_loop_signal()` */\nstatic void uv__cf_loop_cb(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  QUEUE* item;\n  QUEUE split_head;\n  uv__cf_loop_signal_t* s;\n\n  loop = arg;\n  state = loop->cf_state;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_MOVE(&loop->cf_signals, &split_head);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  while (!QUEUE_EMPTY(&split_head)) {\n    item = QUEUE_HEAD(&split_head);\n    QUEUE_REMOVE(item);\n\n    s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);\n\n    /* This was a termination signal */\n    if (s->handle == NULL)\n      pCFRunLoopStop(state->loop);\n    else\n      uv__fsevents_reschedule(s->handle, s->type);\n\n    uv__free(s);\n  }\n}\n\n\n/* Runs in UV loop to notify CF thread */\nint uv__cf_loop_signal(uv_loop_t* loop,\n                       uv_fs_event_t* handle,\n                       uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_signal_t* item;\n  uv__cf_loop_state_t* state;\n\n  item = uv__malloc(sizeof(*item));\n  if (item == NULL)\n    return UV_ENOMEM;\n\n  item->handle = handle;\n  item->type = type;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  state = loop->cf_state;\n  assert(state != NULL);\n  pCFRunLoopSourceSignal(state->signal_source);\n  pCFRunLoopWakeUp(state->loop);\n\n  return 0;\n}\n\n\n/* Runs in UV loop to initialize handle */\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  err = uv__fsevents_loop_init(handle->loop);\n  if (err)\n    return err;\n\n  /* Get absolute path to file */\n  handle->realpath = realpath(handle->path, NULL);\n  if (handle->realpath == NULL)\n    return UV__ERR(errno);\n  handle->realpath_len = strlen(handle->realpath);\n\n  /* Initialize event queue */\n  QUEUE_INIT(&handle->cf_events);\n  handle->cf_error = 0;\n\n  /*\n   * Events will occur in other thread.\n   * Initialize callback for getting them back into event loop's thread\n   */\n  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n  if (handle->cf_cb == NULL) {\n    err = UV_ENOMEM;\n    goto fail_cf_cb_malloc;\n  }\n\n  handle->cf_cb->data = handle;\n  uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n  handle->cf_cb->flags |= UV__HANDLE_INTERNAL;\n  uv_unref((uv_handle_t*) handle->cf_cb);\n\n  err = uv_mutex_init(&handle->cf_mutex);\n  if (err)\n    goto fail_cf_mutex_init;\n\n  /* Insert handle into the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);\n  state->fsevent_handle_count++;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular);\n  if (err)\n    goto fail_loop_signal;\n\n  return 0;\n\nfail_loop_signal:\n  uv_mutex_destroy(&handle->cf_mutex);\n\nfail_cf_mutex_init:\n  uv__free(handle->cf_cb);\n  handle->cf_cb = NULL;\n\nfail_cf_cb_malloc:\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return err;\n}\n\n\n/* Runs in UV loop to de-initialize handle */\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  if (handle->cf_cb == NULL)\n    return UV_EINVAL;\n\n  /* Remove handle from  the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_REMOVE(&handle->cf_member);\n  state->fsevent_handle_count--;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n  if (err)\n    return UV__ERR(err);\n\n  /* Wait for deinitialization */\n  uv_sem_wait(&state->fsevent_sem);\n\n  uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free);\n  handle->cf_cb = NULL;\n\n  /* Free data in queue */\n  UV__FSEVENTS_PROCESS(handle, {\n    /* NOP */\n  });\n\n  uv_mutex_destroy(&handle->cf_mutex);\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return 0;\n}\n\n#endif /* TARGET_OS_IPHONE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  uv__free(lib->errmsg);\n  lib->errmsg = NULL;\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  const char* errmsg;\n\n  uv__free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = uv__strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/include/uv-win.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef _WIN32_WINNT\n# define _WIN32_WINNT   0x0600\n#endif\n\n#if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)\ntypedef intptr_t ssize_t;\n# define _SSIZE_T_\n# define _SSIZE_T_DEFINED\n#endif\n\n#include <winsock2.h>\n\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\ntypedef struct pollfd {\n  SOCKET fd;\n  short  events;\n  short  revents;\n} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;\n#endif\n\n#ifndef LOCALE_INVARIANT\n# define LOCALE_INVARIANT 0x007f\n#endif\n\n#include <mswsock.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n\n#include <process.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#include \"tree.h\"\n#include \"uv-threadpool.h\"\n\n#define MAX_PIPENAME_LEN 256\n\n#ifndef S_IFLNK\n# define S_IFLNK 0xA000\n#endif\n\n/* Additional signals supported by uv_signal and or uv_kill. The CRT defines\n * the following signals already:\n *\n *   #define SIGINT           2\n *   #define SIGILL           4\n *   #define SIGABRT_COMPAT   6\n *   #define SIGFPE           8\n *   #define SIGSEGV         11\n *   #define SIGTERM         15\n *   #define SIGBREAK        21\n *   #define SIGABRT         22\n *\n * The additional signals have values that are common on other Unix\n * variants (Linux and Darwin)\n */\n#define SIGHUP                1\n#define SIGKILL               9\n#define SIGWINCH             28\n\n/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many */\n/* unix-like platforms. However MinGW doesn't define it, so we do. */\n#ifndef SIGABRT_COMPAT\n# define SIGABRT_COMPAT       6\n#endif\n\n/*\n * Guids and typedefs for winsock extension functions\n * Mingw32 doesn't have these :-(\n */\n#ifndef WSAID_ACCEPTEX\n# define WSAID_ACCEPTEX                                                       \\\n         {0xb5367df1, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n#endif\n\n#ifndef WSAID_CONNECTEX\n# define WSAID_CONNECTEX                                                      \\\n         {0x25a207b9, 0xddf3, 0x4660,                                         \\\n         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n#endif\n\n#ifndef WSAID_GETACCEPTEXSOCKADDRS\n# define WSAID_GETACCEPTEXSOCKADDRS                                           \\\n         {0xb5367df2, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n#endif\n\n#ifndef WSAID_DISCONNECTEX\n# define WSAID_DISCONNECTEX                                                   \\\n         {0x7fda2e11, 0x8630, 0x436f,                                         \\\n         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n#endif\n\n#ifndef WSAID_TRANSMITFILE\n# define WSAID_TRANSMITFILE                                                   \\\n         {0xb5367df0, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n#endif\n\n#if (defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)) \\\n || (defined(_MSC_VER) && _MSC_VER < 1500)\n  typedef BOOL (PASCAL *LPFN_ACCEPTEX)\n                      (SOCKET sListenSocket,\n                       SOCKET sAcceptSocket,\n                       PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPDWORD lpdwBytesReceived,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef BOOL (PASCAL *LPFN_CONNECTEX)\n                      (SOCKET s,\n                       const struct sockaddr* name,\n                       int namelen,\n                       PVOID lpSendBuffer,\n                       DWORD dwSendDataLength,\n                       LPDWORD lpdwBytesSent,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef void (PASCAL *LPFN_GETACCEPTEXSOCKADDRS)\n                      (PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPSOCKADDR* LocalSockaddr,\n                       LPINT LocalSockaddrLength,\n                       LPSOCKADDR* RemoteSockaddr,\n                       LPINT RemoteSockaddrLength);\n\n  typedef BOOL (PASCAL *LPFN_DISCONNECTEX)\n                      (SOCKET hSocket,\n                       LPOVERLAPPED lpOverlapped,\n                       DWORD dwFlags,\n                       DWORD reserved);\n\n  typedef BOOL (PASCAL *LPFN_TRANSMITFILE)\n                      (SOCKET hSocket,\n                       HANDLE hFile,\n                       DWORD nNumberOfBytesToWrite,\n                       DWORD nNumberOfBytesPerSend,\n                       LPOVERLAPPED lpOverlapped,\n                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n                       DWORD dwFlags);\n\n  typedef PVOID RTL_SRWLOCK;\n  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;\n#endif\n\ntypedef int (WSAAPI* LPFN_WSARECV)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\ntypedef int (WSAAPI* LPFN_WSARECVFROM)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             struct sockaddr* addr,\n             LPINT addr_len,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\n#ifndef _NTDEF_\n  typedef LONG NTSTATUS;\n  typedef NTSTATUS *PNTSTATUS;\n#endif\n\n#ifndef RTL_CONDITION_VARIABLE_INIT\n  typedef PVOID CONDITION_VARIABLE, *PCONDITION_VARIABLE;\n#endif\n\ntypedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE Handle;\n  ULONG Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;\n\ntypedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER Timeout;\n  ULONG NumberOfHandles;\n  ULONG Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;\n\n#define UV_MSAFD_PROVIDER_COUNT 3\n\n\n/**\n * It should be possible to cast uv_buf_t[] to WSABUF[]\n * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n */\ntypedef struct uv_buf_t {\n  ULONG len;\n  char* base;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef SOCKET uv_os_sock_t;\ntypedef HANDLE uv_os_fd_t;\ntypedef int uv_pid_t;\n\ntypedef HANDLE uv_thread_t;\n\ntypedef HANDLE uv_sem_t;\n\ntypedef CRITICAL_SECTION uv_mutex_t;\n\n/* This condition variable implementation is based on the SetEvent solution\n * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n * We could not use the SignalObjectAndWait solution (section 3.4) because\n * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and\n * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.\n */\n\ntypedef union {\n  CONDITION_VARIABLE cond_var;\n  struct {\n    unsigned int waiters_count;\n    CRITICAL_SECTION waiters_count_lock;\n    HANDLE signal_event;\n    HANDLE broadcast_event;\n  } fallback;\n} uv_cond_t;\n\ntypedef union {\n  struct {\n    unsigned int num_readers_;\n    CRITICAL_SECTION num_readers_lock_;\n    HANDLE write_semaphore_;\n  } state_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    SRWLOCK unused_;\n  } unused1_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    uv_mutex_t unused1_;\n    uv_mutex_t unused2_;\n  } unused2_;\n} uv_rwlock_t;\n\ntypedef struct {\n  unsigned int n;\n  unsigned int count;\n  uv_mutex_t mutex;\n  uv_sem_t turnstile1;\n  uv_sem_t turnstile2;\n} uv_barrier_t;\n\ntypedef struct {\n  DWORD tls_index;\n} uv_key_t;\n\n#define UV_ONCE_INIT { 0, NULL }\n\ntypedef struct uv_once_s {\n  unsigned char ran;\n  HANDLE event;\n} uv_once_t;\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef unsigned char uv_uid_t;\ntypedef unsigned char uv_gid_t;\n\ntypedef struct uv__dirent_s {\n  int d_type;\n  char d_name[1];\n} uv__dirent_t;\n\n#define HAVE_DIRENT_TYPES\n#define UV__DT_DIR     UV_DIRENT_DIR\n#define UV__DT_FILE    UV_DIRENT_FILE\n#define UV__DT_LINK    UV_DIRENT_LINK\n#define UV__DT_FIFO    UV_DIRENT_FIFO\n#define UV__DT_SOCKET  UV_DIRENT_SOCKET\n#define UV__DT_CHAR    UV_DIRENT_CHAR\n#define UV__DT_BLOCK   UV_DIRENT_BLOCK\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC FAR WINAPI\ntypedef struct {\n  HMODULE handle;\n  char* errmsg;\n} uv_lib_t;\n\nRB_HEAD(uv_timer_tree_s, uv_timer_s);\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n    /* The loop's I/O completion port */                                      \\\n  HANDLE iocp;                                                                \\\n  /* The current time according to the event loop. in msecs. */               \\\n  uint64_t time;                                                              \\\n  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \\\n  /* is empty, tail_ is NULL. If there is only one item, */                   \\\n  /* tail_->next_req == tail_ */                                              \\\n  uv_req_t* pending_reqs_tail;                                                \\\n  /* Head of a single-linked list of closed handles */                        \\\n  uv_handle_t* endgame_handles;                                               \\\n  /* The head of the timers tree */                                           \\\n  struct uv_timer_tree_s timers;                                              \\\n    /* Lists of active loop (prepare / check / idle) watchers */              \\\n  uv_prepare_t* prepare_handles;                                              \\\n  uv_check_t* check_handles;                                                  \\\n  uv_idle_t* idle_handles;                                                    \\\n  /* This pointer will refer to the prepare/check/idle handle whose */        \\\n  /* callback is scheduled to be called next. This is needed to allow */      \\\n  /* safe removal from one of the lists above while that list being */        \\\n  /* iterated over. */                                                        \\\n  uv_prepare_t* next_prepare_handle;                                          \\\n  uv_check_t* next_check_handle;                                              \\\n  uv_idle_t* next_idle_handle;                                                \\\n  /* This handle holds the peer sockets for the fast variant of uv_poll_t */  \\\n  SOCKET poll_peer_sockets[UV_MSAFD_PROVIDER_COUNT];                          \\\n  /* Counter to keep track of active tcp streams */                           \\\n  unsigned int active_tcp_streams;                                            \\\n  /* Counter to keep track of active udp streams */                           \\\n  unsigned int active_udp_streams;                                            \\\n  /* Counter to started timer */                                              \\\n  uint64_t timer_counter;                                                     \\\n  /* Threadpool */                                                            \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;\n\n#define UV_REQ_TYPE_PRIVATE                                                   \\\n  /* TODO: remove the req suffix */                                           \\\n  UV_ACCEPT,                                                                  \\\n  UV_FS_EVENT_REQ,                                                            \\\n  UV_POLL_REQ,                                                                \\\n  UV_PROCESS_EXIT,                                                            \\\n  UV_READ,                                                                    \\\n  UV_UDP_RECV,                                                                \\\n  UV_WAKEUP,                                                                  \\\n  UV_SIGNAL_REQ,\n\n#define UV_REQ_PRIVATE_FIELDS                                                 \\\n  union {                                                                     \\\n    /* Used by I/O operations */                                              \\\n    struct {                                                                  \\\n      OVERLAPPED overlapped;                                                  \\\n      size_t queued_bytes;                                                    \\\n    } io;                                                                     \\\n  } u;                                                                        \\\n  struct uv_req_s* next_req;\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  int ipc_header;                                                             \\\n  uv_buf_t write_buffer;                                                      \\\n  HANDLE event_handle;                                                        \\\n  HANDLE wait_handle;\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  /* empty */\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES                                                  \\\n  typedef struct uv_pipe_accept_s {                                           \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE pipeHandle;                                                        \\\n    struct uv_pipe_accept_s* next_pending;                                    \\\n  } uv_pipe_accept_t;                                                         \\\n                                                                              \\\n  typedef struct uv_tcp_accept_s {                                            \\\n    UV_REQ_FIELDS                                                             \\\n    SOCKET accept_socket;                                                     \\\n    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n    struct uv_tcp_accept_s* next_pending;                                     \\\n  } uv_tcp_accept_t;                                                          \\\n                                                                              \\\n  typedef struct uv_read_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n  } uv_read_t;\n\n#define uv_stream_connection_fields                                           \\\n  unsigned int write_reqs_pending;                                            \\\n  uv_shutdown_t* shutdown_req;\n\n#define uv_stream_server_fields                                               \\\n  uv_connection_cb connection_cb;\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_read_t read_req;                                                         \\\n  union {                                                                     \\\n    struct { uv_stream_connection_fields } conn;                              \\\n    struct { uv_stream_server_fields     } serv;                              \\\n  } stream;\n\n#define uv_tcp_server_fields                                                  \\\n  uv_tcp_accept_t* accept_reqs;                                               \\\n  unsigned int processed_accepts;                                             \\\n  uv_tcp_accept_t* pending_accepts;                                           \\\n  LPFN_ACCEPTEX func_acceptex;\n\n#define uv_tcp_connection_fields                                              \\\n  uv_buf_t read_buffer;                                                       \\\n  LPFN_CONNECTEX func_connectex;\n\n#define UV_TCP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  int delayed_error;                                                          \\\n  union {                                                                     \\\n    struct { uv_tcp_server_fields } serv;                                     \\\n    struct { uv_tcp_connection_fields } conn;                                 \\\n  } tcp;\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_req_t recv_req;                                                          \\\n  uv_buf_t recv_buffer;                                                       \\\n  struct sockaddr_storage recv_from;                                          \\\n  int recv_from_len;                                                          \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  LPFN_WSARECV func_wsarecv;                                                  \\\n  LPFN_WSARECVFROM func_wsarecvfrom;\n\n#define uv_pipe_server_fields                                                 \\\n  int pending_instances;                                                      \\\n  uv_pipe_accept_t* accept_reqs;                                              \\\n  uv_pipe_accept_t* pending_accepts;\n\n#define uv_pipe_connection_fields                                             \\\n  uv_timer_t* eof_timer;                                                      \\\n  uv_write_t ipc_header_write_req;                                            \\\n  int ipc_pid;                                                                \\\n  uint64_t remaining_ipc_rawdata_bytes;                                       \\\n  struct {                                                                    \\\n    void* queue[2];                                                           \\\n    int queue_len;                                                            \\\n  } pending_ipc_info;                                                         \\\n  uv_write_t* non_overlapped_writes_tail;                                     \\\n  uv_mutex_t readfile_mutex;                                                  \\\n  volatile HANDLE readfile_thread;\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  HANDLE handle;                                                              \\\n  WCHAR* name;                                                                \\\n  union {                                                                     \\\n    struct { uv_pipe_server_fields } serv;                                    \\\n    struct { uv_pipe_connection_fields } conn;                                \\\n  } pipe;\n\n/* TODO: put the parser states in an union - TTY handles are always */\n/* half-duplex so read-state can safely overlap write-state. */\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  HANDLE handle;                                                              \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      /* Used for readable TTY handles */                                     \\\n      /* TODO: remove me in v2.x. */                                          \\\n      HANDLE unused_;                                                         \\\n      uv_buf_t read_line_buffer;                                              \\\n      HANDLE read_raw_wait;                                                   \\\n      /* Fields used for translating win keystrokes into vt100 characters */  \\\n      char last_key[8];                                                       \\\n      unsigned char last_key_offset;                                          \\\n      unsigned char last_key_len;                                             \\\n      WCHAR last_utf16_high_surrogate;                                        \\\n      INPUT_RECORD last_input_record;                                         \\\n    } rd;                                                                     \\\n    struct {                                                                  \\\n      /* Used for writable TTY handles */                                     \\\n      /* utf8-to-utf16 conversion state */                                    \\\n      unsigned int utf8_codepoint;                                            \\\n      unsigned char utf8_bytes_left;                                          \\\n      /* eol conversion state */                                              \\\n      unsigned char previous_eol;                                             \\\n      /* ansi parser state */                                                 \\\n      unsigned char ansi_parser_state;                                        \\\n      unsigned char ansi_csi_argc;                                            \\\n      unsigned short ansi_csi_argv[4];                                        \\\n      COORD saved_position;                                                   \\\n      WORD saved_attributes;                                                  \\\n    } wr;                                                                     \\\n  } tty;\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  SOCKET socket;                                                              \\\n  /* Used in fast mode */                                                     \\\n  SOCKET peer_socket;                                                         \\\n  AFD_POLL_INFO afd_poll_info_1;                                              \\\n  AFD_POLL_INFO afd_poll_info_2;                                              \\\n  /* Used in fast and slow mode. */                                           \\\n  uv_req_t poll_req_1;                                                        \\\n  uv_req_t poll_req_2;                                                        \\\n  unsigned char submitted_events_1;                                           \\\n  unsigned char submitted_events_2;                                           \\\n  unsigned char mask_events_1;                                                \\\n  unsigned char mask_events_2;                                                \\\n  unsigned char events;\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  RB_ENTRY(uv_timer_s) tree_entry;                                            \\\n  uint64_t due;                                                               \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;                                                          \\\n  uv_timer_cb timer_cb;\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  struct uv_req_s async_req;                                                  \\\n  uv_async_cb async_cb;                                                       \\\n  /* char to avoid alignment issues */                                        \\\n  char volatile async_sent;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_t* prepare_prev;                                                 \\\n  uv_prepare_t* prepare_next;                                                 \\\n  uv_prepare_cb prepare_cb;\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_t* check_prev;                                                     \\\n  uv_check_t* check_next;                                                     \\\n  uv_check_cb check_cb;\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_t* idle_prev;                                                       \\\n  uv_idle_t* idle_next;                                                       \\\n  uv_idle_cb idle_cb;\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* endgame_next;                                                  \\\n  unsigned int flags;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb getaddrinfo_cb;                                           \\\n  void* alloc;                                                                \\\n  WCHAR* node;                                                                \\\n  WCHAR* service;                                                             \\\n  /* The addrinfoW field is used to store a pointer to the hints, and    */   \\\n  /* later on to store the result of GetAddrInfoW. The final result will */   \\\n  /* be converted to struct addrinfo* and stored in the addrinfo field.  */   \\\n  struct addrinfoW* addrinfow;                                                \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  struct uv_process_exit_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } exit_req;                                                                 \\\n  BYTE* child_stdio_buffer;                                                   \\\n  int exit_signal;                                                            \\\n  HANDLE wait_handle;                                                         \\\n  HANDLE process_handle;                                                      \\\n  volatile char exit_cb_pending;\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  struct uv__work work_req;                                                   \\\n  int flags;                                                                  \\\n  DWORD sys_errno_;                                                           \\\n  union {                                                                     \\\n    /* TODO: remove me in 0.9. */                                             \\\n    WCHAR* pathw;                                                             \\\n    int fd;                                                                   \\\n  } file;                                                                     \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      int mode;                                                               \\\n      WCHAR* new_pathw;                                                       \\\n      int file_flags;                                                         \\\n      int fd_out;                                                             \\\n      unsigned int nbufs;                                                     \\\n      uv_buf_t* bufs;                                                         \\\n      int64_t offset;                                                         \\\n      uv_buf_t bufsml[4];                                                     \\\n    } info;                                                                   \\\n    struct {                                                                  \\\n      double atime;                                                           \\\n      double mtime;                                                           \\\n    } time;                                                                   \\\n  } fs;\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  struct uv_fs_event_req_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } req;                                                                      \\\n  HANDLE dir_handle;                                                          \\\n  int req_pending;                                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  WCHAR* filew;                                                               \\\n  WCHAR* short_filew;                                                         \\\n  WCHAR* dirw;                                                                \\\n  char* buffer;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  RB_ENTRY(uv_signal_s) tree_entry;                                           \\\n  struct uv_req_s signal_req;                                                 \\\n  unsigned long pending_signum;\n\n#ifndef F_OK\n#define F_OK 0\n#endif\n#ifndef R_OK\n#define R_OK 4\n#endif\n#ifndef W_OK\n#define W_OK 2\n#endif\n#ifndef X_OK\n#define X_OK 1\n#endif\n\n/* fs open() flags supported on this platform: */\n#define UV_FS_O_APPEND       _O_APPEND\n#define UV_FS_O_CREAT        _O_CREAT\n#define UV_FS_O_EXCL         _O_EXCL\n#define UV_FS_O_RANDOM       _O_RANDOM\n#define UV_FS_O_RDONLY       _O_RDONLY\n#define UV_FS_O_RDWR         _O_RDWR\n#define UV_FS_O_SEQUENTIAL   _O_SEQUENTIAL\n#define UV_FS_O_SHORT_LIVED  _O_SHORT_LIVED\n#define UV_FS_O_TEMPORARY    _O_TEMPORARY\n#define UV_FS_O_TRUNC        _O_TRUNC\n#define UV_FS_O_WRONLY       _O_WRONLY\n\n/* fs open() flags supported on other platforms (or mapped on this platform): */\n#define UV_FS_O_DIRECT       0x02000000 /* FILE_FLAG_NO_BUFFERING */\n#define UV_FS_O_DIRECTORY    0\n#define UV_FS_O_DSYNC        0x04000000 /* FILE_FLAG_WRITE_THROUGH */\n#define UV_FS_O_EXLOCK       0x10000000 /* EXCLUSIVE SHARING MODE */\n#define UV_FS_O_NOATIME      0\n#define UV_FS_O_NOCTTY       0\n#define UV_FS_O_NOFOLLOW     0\n#define UV_FS_O_NONBLOCK     0\n#define UV_FS_O_SYMLINK      0\n#define UV_FS_O_SYNC         0x08000000 /* FILE_FLAG_WRITE_THROUGH */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n\n/* Include KWSys Large File Support configuration. */\n#include <cmsys/Configure.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv-errno.h\"\n#include \"uv-version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv-win.h\"\n#else\n# include \"uv-unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n  XX(EREMOTEIO, \"remote I/O error\")                                           \\\n  XX(ENOTTY, \"inappropriate ioctl for device\")                                \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\nUV_EXTERN int uv_loop_fork(uv_loop_t* loop);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN int uv_translate_sys_error(int sys_errno);\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN const char* uv_err_name(int err);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* reserved[6];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN uv_handle_type uv_handle_get_type(const uv_handle_t* handle);\nUV_EXTERN const char* uv_handle_type_name(uv_handle_type type);\nUV_EXTERN void* uv_handle_get_data(const uv_handle_t* handle);\nUV_EXTERN uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);\nUV_EXTERN void uv_handle_set_data(uv_handle_t* handle, void* data);\n\nUV_EXTERN size_t uv_req_size(uv_req_type type);\nUV_EXTERN void* uv_req_get_data(const uv_req_t* req);\nUV_EXTERN void uv_req_set_data(uv_req_t* req, void* data);\nUV_EXTERN uv_req_type uv_req_get_type(const uv_req_t* req);\nUV_EXTERN const char* uv_req_type_name(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle;\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\n\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\nUV_EXTERN int uv_pipe_chmod(uv_pipe_t* handle, int flags);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4,\n  UV_PRIORITIZED = 8\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n  /*\n    Libuv can set the child process' CPU affinity mask.  This happens when\n    `cpumask` is non-NULL.  It must point to an array of char values\n    of length `cpumask_size`, whose value must be at least that returned by\n    uv_cpumask_size().  Each byte in the mask can be either zero (false)\n    or non-zero (true) to indicate whether the corresponding processor at\n    that index is included.\n\n    If enabled on an unsupported platform, uv_spawn() will fail with\n    UV_ENOTSUP.\n   */\n  char* cpumask;\n  size_t cpumask_size;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\nUV_EXTERN uv_pid_t uv_process_get_pid(const uv_process_t*);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s {\n    uint64_t user;\n    uint64_t nice;\n    uint64_t sys;\n    uint64_t idle;\n    uint64_t irq;\n  } cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\nUV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\nUV_EXTERN uv_pid_t uv_os_getpid(void);\nUV_EXTERN uv_pid_t uv_os_getppid(void);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\nUV_EXTERN int uv_cpumask_size(void);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\nUV_EXTERN int uv_os_getenv(const char* name, char* buffer, size_t* size);\nUV_EXTERN int uv_os_setenv(const char* name, const char* value);\nUV_EXTERN int uv_os_unsetenv(const char* name);\n\nUV_EXTERN int uv_os_gethostname(char* buffer, size_t* size);\n\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH,\n  UV_FS_COPYFILE\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN uv_fs_type uv_fs_get_type(const uv_fs_t*);\nUV_EXTERN ssize_t uv_fs_get_result(const uv_fs_t*);\nUV_EXTERN void* uv_fs_get_ptr(const uv_fs_t*);\nUV_EXTERN const char* uv_fs_get_path(const uv_fs_t*);\nUV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\n/*\n * This flag can be used with uv_fs_copyfile() to return an error if the\n * destination already exists.\n */\n#define UV_FS_COPYFILE_EXCL   0x0001\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, a fallback copy mechanism is used.\n */\n#define UV_FS_COPYFILE_FICLONE 0x0002\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, an error is returned.\n */\n#define UV_FS_COPYFILE_FICLONE_FORCE 0x0004\n\nUV_EXTERN int uv_fs_copyfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             const char* new_path,\n                             int flags,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_start_oneshot(uv_signal_t* handle,\n                                      uv_signal_cb signal_cb,\n                                      int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\n#if defined(IF_NAMESIZE)\n# define UV_IF_NAMESIZE (IF_NAMESIZE + 1)\n#elif defined(IFNAMSIZ)\n# define UV_IF_NAMESIZE (IFNAMSIZ + 1)\n#else\n# define UV_IF_NAMESIZE (16 + 1)\n#endif\n\nUV_EXTERN int uv_if_indextoname(unsigned int ifindex,\n                                char* buffer,\n                                size_t* size);\nUV_EXTERN int uv_if_indextoiid(unsigned int ifindex,\n                               char* buffer,\n                               size_t* size);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_init_recursive(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  union {\n    void* unused[2];\n    unsigned int count;\n  } active_reqs;\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\nUV_EXTERN void* uv_loop_get_data(const uv_loop_t*);\nUV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n#undef UV__ERR\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmlibuv/include/uv-unix.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef UV_UNIX_H\n#define UV_UNIX_H\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include <termios.h>\n#include <pwd.h>\n\n#if !defined(__MVS__)\n#include <semaphore.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n\n#include \"uv-threadpool.h\"\n\n#ifdef CMAKE_BOOTSTRAP\n# include \"uv-posix.h\"\n#elif defined(__linux__)\n# include \"uv-linux.h\"\n#elif defined (__MVS__)\n# include \"uv-os390.h\"\n#elif defined(__PASE__)\n# include \"uv-posix.h\"\n#elif defined(_AIX)\n# include \"uv-aix.h\"\n#elif defined(__sun)\n# include \"uv-sunos.h\"\n#elif defined(__APPLE__)\n# include \"uv-darwin.h\"\n#elif defined(__DragonFly__)       || \\\n      defined(__FreeBSD__)         || \\\n      defined(__FreeBSD_kernel__)  || \\\n      defined(__OpenBSD__)         || \\\n      defined(__NetBSD__)\n# include \"uv-bsd.h\"\n#elif defined(__CYGWIN__) || defined(__MSYS__)\n# include \"uv-posix.h\"\n#endif\n\n#ifndef PTHREAD_BARRIER_SERIAL_THREAD\n# include \"pthread-barrier.h\"\n#endif\n\n#ifndef NI_MAXHOST\n# define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\n#ifndef UV_IO_PRIVATE_PLATFORM_FIELDS\n# define UV_IO_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\nstruct uv__io_s;\nstruct uv_loop_s;\n\ntypedef void (*uv__io_cb)(struct uv_loop_s* loop,\n                          struct uv__io_s* w,\n                          unsigned int events);\ntypedef struct uv__io_s uv__io_t;\n\nstruct uv__io_s {\n  uv__io_cb cb;\n  void* pending_queue[2];\n  void* watcher_queue[2];\n  unsigned int pevents; /* Pending event mask i.e. mask at next tick. */\n  unsigned int events;  /* Current event mask. */\n  int fd;\n  UV_IO_PRIVATE_PLATFORM_FIELDS\n};\n\n#ifndef UV_PLATFORM_SEM_T\n# define UV_PLATFORM_SEM_T sem_t\n#endif\n\n#ifndef UV_PLATFORM_LOOP_FIELDS\n# define UV_PLATFORM_LOOP_FIELDS /* empty */\n#endif\n\n#ifndef UV_PLATFORM_FS_EVENT_FIELDS\n# define UV_PLATFORM_FS_EVENT_FIELDS /* empty */\n#endif\n\n#ifndef UV_STREAM_PRIVATE_PLATFORM_FIELDS\n# define UV_STREAM_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\n/* Note: May be cast to struct iovec. See writev(2). */\ntypedef struct uv_buf_t {\n  char* base;\n  size_t len;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef int uv_os_sock_t;\ntypedef int uv_os_fd_t;\ntypedef pid_t uv_pid_t;\n\n#ifdef CMAKE_BOOTSTRAP\n#define UV_ONCE_INIT 0\ntypedef int uv_once_t;\ntypedef int uv_thread_t;\ntypedef int uv_mutex_t;\ntypedef int uv_rwlock_t;\ntypedef int uv_sem_t;\ntypedef int uv_cond_t;\ntypedef int uv_key_t;\ntypedef int uv_barrier_t;\n#else\n#define UV_ONCE_INIT PTHREAD_ONCE_INIT\n\ntypedef pthread_once_t uv_once_t;\ntypedef pthread_t uv_thread_t;\ntypedef pthread_mutex_t uv_mutex_t;\ntypedef pthread_rwlock_t uv_rwlock_t;\ntypedef UV_PLATFORM_SEM_T uv_sem_t;\ntypedef pthread_cond_t uv_cond_t;\ntypedef pthread_key_t uv_key_t;\ntypedef pthread_barrier_t uv_barrier_t;\n#endif\n\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef gid_t uv_gid_t;\ntypedef uid_t uv_uid_t;\n\ntypedef struct dirent uv__dirent_t;\n\n#if defined(DT_UNKNOWN)\n# define HAVE_DIRENT_TYPES\n# if defined(DT_REG)\n#  define UV__DT_FILE DT_REG\n# else\n#  define UV__DT_FILE -1\n# endif\n# if defined(DT_DIR)\n#  define UV__DT_DIR DT_DIR\n# else\n#  define UV__DT_DIR -2\n# endif\n# if defined(DT_LNK)\n#  define UV__DT_LINK DT_LNK\n# else\n#  define UV__DT_LINK -3\n# endif\n# if defined(DT_FIFO)\n#  define UV__DT_FIFO DT_FIFO\n# else\n#  define UV__DT_FIFO -4\n# endif\n# if defined(DT_SOCK)\n#  define UV__DT_SOCKET DT_SOCK\n# else\n#  define UV__DT_SOCKET -5\n# endif\n# if defined(DT_CHR)\n#  define UV__DT_CHAR DT_CHR\n# else\n#  define UV__DT_CHAR -6\n# endif\n# if defined(DT_BLK)\n#  define UV__DT_BLOCK DT_BLK\n# else\n#  define UV__DT_BLOCK -7\n# endif\n#endif\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC /* empty */\n\ntypedef struct {\n  void* handle;\n  char* errmsg;\n} uv_lib_t;\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n  unsigned long flags;                                                        \\\n  int backend_fd;                                                             \\\n  void* pending_queue[2];                                                     \\\n  void* watcher_queue[2];                                                     \\\n  uv__io_t** watchers;                                                        \\\n  unsigned int nwatchers;                                                     \\\n  unsigned int nfds;                                                          \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;                                                        \\\n  uv_rwlock_t cloexec_lock;                                                   \\\n  uv_handle_t* closing_handles;                                               \\\n  void* process_handles[2];                                                   \\\n  void* prepare_handles[2];                                                   \\\n  void* check_handles[2];                                                     \\\n  void* idle_handles[2];                                                      \\\n  void* async_handles[2];                                                     \\\n  void (*async_unused)(void);  /* TODO(bnoordhuis) Remove in libuv v2. */     \\\n  uv__io_t async_io_watcher;                                                  \\\n  int async_wfd;                                                              \\\n  struct {                                                                    \\\n    void* min;                                                                \\\n    unsigned int nelts;                                                       \\\n  } timer_heap;                                                               \\\n  uint64_t timer_counter;                                                     \\\n  uint64_t time;                                                              \\\n  int signal_pipefd[2];                                                       \\\n  uv__io_t signal_io_watcher;                                                 \\\n  uv_signal_t child_watcher;                                                  \\\n  int emfile_fd;                                                              \\\n  UV_PLATFORM_LOOP_FIELDS                                                     \\\n\n#define UV_REQ_TYPE_PRIVATE /* empty */\n\n#define UV_REQ_PRIVATE_FIELDS  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES /* empty */\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  void* queue[2];                                                             \\\n  unsigned int write_index;                                                   \\\n  uv_buf_t* bufs;                                                             \\\n  unsigned int nbufs;                                                         \\\n  int error;                                                                  \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  void* queue[2];                                                             \\\n  struct sockaddr_storage addr;                                               \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  ssize_t status;                                                             \\\n  uv_udp_send_cb send_cb;                                                     \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* next_closing;                                                  \\\n  unsigned int flags;                                                         \\\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  uv_connect_t *connect_req;                                                  \\\n  uv_shutdown_t *shutdown_req;                                                \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n  uv_connection_cb connection_cb;                                             \\\n  int delayed_error;                                                          \\\n  int accepted_fd;                                                            \\\n  void* queued_fds;                                                           \\\n  UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\\n\n#define UV_TCP_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  const char* pipe_fname; /* strdup'ed */\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  uv__io_t io_watcher;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_cb prepare_cb;                                                   \\\n  void* queue[2];                                                             \\\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_cb check_cb;                                                       \\\n  void* queue[2];                                                             \\\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_cb idle_cb;                                                         \\\n  void* queue[2];                                                             \\\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  uv_async_cb async_cb;                                                       \\\n  void* queue[2];                                                             \\\n  int pending;                                                                \\\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  uv_timer_cb timer_cb;                                                       \\\n  void* heap_node[3];                                                         \\\n  uint64_t timeout;                                                           \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb cb;                                                       \\\n  struct addrinfo* hints;                                                     \\\n  char* hostname;                                                             \\\n  char* service;                                                              \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n  int status;                                                                 \\\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  const char *new_path;                                                       \\\n  uv_file file;                                                               \\\n  int flags;                                                                  \\\n  mode_t mode;                                                                \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  off_t off;                                                                  \\\n  uv_uid_t uid;                                                               \\\n  uv_gid_t gid;                                                               \\\n  double atime;                                                               \\\n  double mtime;                                                               \\\n  struct uv__work work_req;                                                   \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  struct termios orig_termios;                                                \\\n  int mode;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \\\n  struct {                                                                    \\\n    struct uv_signal_s* rbe_left;                                             \\\n    struct uv_signal_s* rbe_right;                                            \\\n    struct uv_signal_s* rbe_parent;                                           \\\n    int rbe_color;                                                            \\\n  } tree_entry;                                                               \\\n  /* Use two counters here so we don have to fiddle with atomics. */          \\\n  unsigned int caught_signals;                                                \\\n  unsigned int dispatched_signals;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  UV_PLATFORM_FS_EVENT_FIELDS                                                 \\\n\n/* fs open() flags supported on this platform: */\n#if defined(O_APPEND)\n# define UV_FS_O_APPEND       O_APPEND\n#else\n# define UV_FS_O_APPEND       0\n#endif\n#if defined(O_CREAT)\n# define UV_FS_O_CREAT        O_CREAT\n#else\n# define UV_FS_O_CREAT        0\n#endif\n#if defined(O_DIRECT)\n# define UV_FS_O_DIRECT       O_DIRECT\n#else\n# define UV_FS_O_DIRECT       0\n#endif\n#if defined(O_DIRECTORY)\n# define UV_FS_O_DIRECTORY    O_DIRECTORY\n#else\n# define UV_FS_O_DIRECTORY    0\n#endif\n#if defined(O_DSYNC)\n# define UV_FS_O_DSYNC        O_DSYNC\n#else\n# define UV_FS_O_DSYNC        0\n#endif\n#if defined(O_EXCL)\n# define UV_FS_O_EXCL         O_EXCL\n#else\n# define UV_FS_O_EXCL         0\n#endif\n#if defined(O_EXLOCK)\n# define UV_FS_O_EXLOCK       O_EXLOCK\n#else\n# define UV_FS_O_EXLOCK       0\n#endif\n#if defined(O_NOATIME)\n# define UV_FS_O_NOATIME      O_NOATIME\n#else\n# define UV_FS_O_NOATIME      0\n#endif\n#if defined(O_NOCTTY)\n# define UV_FS_O_NOCTTY       O_NOCTTY\n#else\n# define UV_FS_O_NOCTTY       0\n#endif\n#if defined(O_NOFOLLOW)\n# define UV_FS_O_NOFOLLOW     O_NOFOLLOW\n#else\n# define UV_FS_O_NOFOLLOW     0\n#endif\n#if defined(O_NONBLOCK)\n# define UV_FS_O_NONBLOCK     O_NONBLOCK\n#else\n# define UV_FS_O_NONBLOCK     0\n#endif\n#if defined(O_RDONLY)\n# define UV_FS_O_RDONLY       O_RDONLY\n#else\n# define UV_FS_O_RDONLY       0\n#endif\n#if defined(O_RDWR)\n# define UV_FS_O_RDWR         O_RDWR\n#else\n# define UV_FS_O_RDWR         0\n#endif\n#if defined(O_SYMLINK)\n# define UV_FS_O_SYMLINK      O_SYMLINK\n#else\n# define UV_FS_O_SYMLINK      0\n#endif\n#if defined(O_SYNC)\n# define UV_FS_O_SYNC         O_SYNC\n#else\n# define UV_FS_O_SYNC         0\n#endif\n#if defined(O_TRUNC)\n# define UV_FS_O_TRUNC        O_TRUNC\n#else\n# define UV_FS_O_TRUNC        0\n#endif\n#if defined(O_WRONLY)\n# define UV_FS_O_WRONLY       O_WRONLY\n#else\n# define UV_FS_O_WRONLY       0\n#endif\n\n/* fs open() flags supported on other platforms: */\n#define UV_FS_O_RANDOM        0\n#define UV_FS_O_SHORT_LIVED   0\n#define UV_FS_O_SEQUENTIAL    0\n#define UV_FS_O_TEMPORARY     0\n\n#endif /* UV_UNIX_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmcurl/CMakeLists.txt": "# Set curl options as needed for CMake build\nset(BUILD_CURL_EXE OFF CACHE INTERNAL \"No curl exe\")\nset(BUILD_DASHBOARD_REPORTS OFF CACHE INTERNAL \"No curl dashboard reports\")\nset(BUILD_RELEASE_DEBUG_DIRS OFF CACHE INTERNAL \"No curl release/debug dirs\")\nset(BUILD_SHARED_LIBS OFF CACHE INTERNAL \"Build shared libraries\")\nset(CMAKE_USE_GSSAPI OFF CACHE INTERNAL \"Disable curl gssapi\")\nset(CMAKE_USE_LIBSSH2 OFF CACHE INTERNAL \"Disable curl libssh2\")\nset(CMAKE_USE_OPENLDAP OFF CACHE INTERNAL \"No curl OpenLDAP\")\nset(CURL_DISABLE_COOKIES OFF CACHE INTERNAL \"Do not disable curl cookie support\")\nset(CURL_DISABLE_CRYPTO_AUTH OFF CACHE INTERNAL \"Do not disable curl crypto auth\")\nset(CURL_DISABLE_DICT ON CACHE INTERNAL \"Disable curl dict protocol?\")\nset(CURL_DISABLE_FILE OFF CACHE INTERNAL \"Disable curl file protocol?\")\nset(CURL_DISABLE_FTP OFF CACHE INTERNAL \"Disable curl ftp protocol?\")\nset(CURL_DISABLE_GOPHER ON CACHE INTERNAL \"Disable curl gopher protocol?\")\nset(CURL_DISABLE_HTTP OFF CACHE INTERNAL \"Disable curl http protocol?\")\nset(CURL_DISABLE_IMAP ON CACHE INTERNAL \"Disable curl imap protocol?\")\nset(CURL_DISABLE_LDAP ON CACHE INTERNAL \"Disable curl ldap protocol?\")\nset(CURL_DISABLE_LDAPS ON CACHE INTERNAL \"Disable curl ldaps protocol?\")\nset(CURL_DISABLE_POP3 ON CACHE INTERNAL \"Disable curl pop3 protocol?\")\nset(CURL_DISABLE_PROXY OFF CACHE INTERNAL \"Do not disable curl proxy\")\nset(CURL_DISABLE_RTSP ON CACHE INTERNAL \"Disable curl rtsp protocol?\")\nset(CURL_DISABLE_SMTP ON CACHE INTERNAL \"Disable curl smtp protocol?\")\nset(CURL_DISABLE_TELNET ON CACHE INTERNAL \"Disable curl telnet protocol?\")\nset(CURL_DISABLE_TFTP ON CACHE INTERNAL \"Disable curl tftp protocol?\")\nset(CURL_DISABLE_VERBOSE_STRINGS OFF CACHE INTERNAL \"Do not disable curl verbosity\")\nset(CURL_HIDDEN_SYMBOLS OFF CACHE INTERNAL \"No curl hidden symbols\")\nset(CURL_WERROR OFF CACHE INTERNAL \"Turn compiler warnings into errors\")\nset(DISABLED_THREADSAFE OFF CACHE INTERNAL \"Curl can use thread-safe functions\")\nset(ENABLE_ARES OFF CACHE INTERNAL \"No curl c-ares support\")\nset(ENABLE_CURLDEBUG OFF CACHE INTERNAL \"No curl TrackMemory features\")\nset(ENABLE_DEBUG OFF CACHE INTERNAL \"No curl debug features\")\nset(ENABLE_IPV6 OFF CACHE INTERNAL \"No curl IPv6 support\")\nset(ENABLE_MANUAL OFF CACHE INTERNAL \"No curl built-in manual\")\nset(ENABLE_THREADED_RESOLVER OFF CACHE INTERNAL \"No curl POSIX threaded DNS lookup\")\nset(ENABLE_UNIX_SOCKETS OFF CACHE INTERNAL \"No curl Unix domain sockets support\")\nset(HTTP_ONLY OFF CACHE INTERNAL \"Curl is not http-only\")\nset(PICKY_COMPILER OFF CACHE INTERNAL \"Enable picky compiler options\")\nset(USE_WIN32_LDAP OFF CACHE INTERNAL \"No curl Windows LDAP\")\nif(CMAKE_USE_OPENSSL)\nelseif(WIN32)\n  set(CMAKE_USE_WINSSL ON CACHE INTERNAL \"enable Windows native SSL/TLS\")\n  set(CURL_WINDOWS_SSPI ON CACHE INTERNAL \"Use windows libraries to allow NTLM authentication without openssl\")\nelseif(APPLE)\n  # Use OS X SSL/TLS native implementation if available on target version.\n  if(CMAKE_OSX_DEPLOYMENT_TARGET)\n    set(OSX_VERSION ${CMAKE_OSX_DEPLOYMENT_TARGET})\n  else()\n    execute_process(\n      COMMAND sw_vers -productVersion\n      OUTPUT_VARIABLE OSX_VERSION\n      OUTPUT_STRIP_TRAILING_WHITESPACE\n      )\n  endif()\n  if(NOT OSX_VERSION VERSION_LESS 10.6 AND\n      CMAKE_C_COMPILER_ID MATCHES \"GNU|Clang|AppleClang\")\n    set(CMAKE_USE_DARWINSSL ON CACHE INTERNAL \"enable Apple OS native SSL/TLS\")\n  else()\n    set(CMAKE_USE_DARWINSSL OFF CACHE INTERNAL \"enable Apple OS native SSL/TLS\")\n  endif()\nendif()\nset(CMAKE_USE_MBEDTLS OFF CACHE INTERNAL \"Enable mbedTLS for SSL/TLS\")\n\n# Windows Vista and above have inet_pton, but this will link on\n# older versions and then the executable will fail to launch at\n# runtime on older versions because no DLL provides the symbol.\nif(WIN32)\n  set(HAVE_INET_PTON 0 CACHE INTERNAL \"Do not use inet_pton\")\nendif()\n\n# Starting with OSX 10.11 there is an unrelated libnetwork library which will\n# be picked up during curl configuration. Linking against this library is\n# unnecessary and breaks backward compatibility of the resulting binaries\n# because libnetwork is unavailable on older OSX versions.\nif(APPLE)\n  set(HAVE_LIBNETWORK 0 CACHE INTERNAL \"Do not use libnetwork\")\nendif(APPLE)\n\n# Disable warnings to avoid changing 3rd party code.\nif(CMAKE_C_COMPILER_ID MATCHES\n    \"^(GNU|Clang|AppleClang|XL|VisualAge|SunPro|MIPSpro|HP|Intel)$\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -w\")\nelseif(CMAKE_C_COMPILER_ID STREQUAL \"PathScale\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -woffall\")\nendif()\n\n#***************************************************************************\n#                                  _   _ ____  _\n#  Project                     ___| | | |  _ \\| |\n#                             / __| | | | |_) | |\n#                            | (__| |_| |  _ <| |___\n#                             \\___|\\___/|_| \\_\\_____|\n#\n# Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n#\n# This software is licensed as described in the file COPYING, which\n# you should have received as part of this distribution. The terms\n# are also available at https://curl.haxx.se/docs/copyright.html.\n#\n# You may opt to use, copy, modify, merge, publish, distribute and/or sell\n# copies of the Software, and permit persons to whom the Software is\n# furnished to do so, under the terms of the COPYING file.\n#\n# This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n# KIND, either express or implied.\n#\n###########################################################################\n# curl/libcurl CMake script\n# by Tetetest and Sukender (Benoit Neil)\n\n# TODO:\n# The output .so file lacks the soname number which we currently have within the lib/Makefile.am file\n# Add full (4 or 5 libs) SSL support\n# Add INSTALL target (EXTRA_DIST variables in Makefile.am may be moved to Makefile.inc so that CMake/CPack is aware of what's to include).\n# Add CTests(?)\n# Check on all possible platforms\n# Test with as many configurations possible (With or without any option)\n# Create scripts that help keeping the CMake build system up to date (to reduce maintenance). According to Tetetest:\n#  - lists of headers that 'configure' checks for;\n#  - curl-specific tests (the ones that are in m4/curl-*.m4 files);\n#  - (most obvious thing:) curl version numbers.\n# Add documentation subproject\n#\n# To check:\n# (From Daniel Stenberg) The cmake build selected to run gcc with -fPIC on my box while the plain configure script did not.\n# (From Daniel Stenberg) The gcc command line use neither -g nor any -O options. As a developer, I also treasure our configure scripts's --enable-debug option that sets a long range of \"picky\" compiler options.\ncmake_minimum_required(VERSION 3.0 FATAL_ERROR)\nset(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/CMake;${CMAKE_MODULE_PATH}\")\ninclude(Utilities)\ninclude(Macros)\ninclude(CMakeDependentOption)\ninclude(CheckCCompilerFlag)\n\nproject(CURL C)\n\nif(0) # This code not needed for building within CMake.\nmessage(WARNING \"the curl cmake build system is poorly maintained. Be aware\")\nendif()\n\nfile(READ ${CURL_SOURCE_DIR}/include/curl/curlver.h CURL_VERSION_H_CONTENTS)\nstring(REGEX MATCH \"#define LIBCURL_VERSION \\\"[^\\\"]*\"\n  CURL_VERSION ${CURL_VERSION_H_CONTENTS})\nstring(REGEX REPLACE \"[^\\\"]+\\\"\" \"\" CURL_VERSION ${CURL_VERSION})\nstring(REGEX MATCH \"#define LIBCURL_VERSION_NUM 0x[0-9a-fA-F]+\"\n  CURL_VERSION_NUM ${CURL_VERSION_H_CONTENTS})\nstring(REGEX REPLACE \"[^0]+0x\" \"\" CURL_VERSION_NUM ${CURL_VERSION_NUM})\n\ninclude_regular_expression(\"^.*$\")    # Sukender: Is it necessary?\n\n# Setup package meta-data\n# SET(PACKAGE \"curl\")\nif(0) # This code not needed for building within CMake.\nmessage(STATUS \"curl version=[${CURL_VERSION}]\")\nendif()\n# SET(PACKAGE_TARNAME \"curl\")\n# SET(PACKAGE_NAME \"curl\")\n# SET(PACKAGE_VERSION \"-\")\n# SET(PACKAGE_STRING \"curl-\")\n# SET(PACKAGE_BUGREPORT \"a suitable curl mailing list => https://curl.haxx.se/mail/\")\nset(OPERATING_SYSTEM \"${CMAKE_SYSTEM_NAME}\")\nset(OS \"\\\"${CMAKE_SYSTEM_NAME}\\\"\")\n\ninclude_directories(${PROJECT_BINARY_DIR}/include/curl)\ninclude_directories(${CURL_SOURCE_DIR}/include)\n\noption(CURL_WERROR \"Turn compiler warnings into errors\" OFF)\noption(PICKY_COMPILER \"Enable picky compiler options\" ON)\noption(BUILD_CURL_EXE \"Set to ON to build curl executable.\" ON)\noption(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\noption(ENABLE_ARES \"Set to ON to enable c-ares support\" OFF)\nif(WIN32)\n  option(CURL_STATIC_CRT \"Set to ON to build libcurl with static CRT on Windows (/MT).\" OFF)\n  option(ENABLE_INET_PTON \"Set to OFF to prevent usage of inet_pton when building against modern SDKs while still requiring compatibility with older Windows versions, such as Windows XP, Windows Server 2003 etc.\" ON)\nendif()\n\ncmake_dependent_option(ENABLE_THREADED_RESOLVER \"Set to ON to enable threaded DNS lookup\"\n        ON \"NOT ENABLE_ARES\"\n        OFF)\n\noption(ENABLE_DEBUG \"Set to ON to enable curl debug features\" OFF)\noption(ENABLE_CURLDEBUG \"Set to ON to build with TrackMemory feature enabled\" OFF)\n\nif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_CLANG)\n  if(PICKY_COMPILER)\n    foreach(_CCOPT -pedantic -Wall -W -Wpointer-arith -Wwrite-strings -Wunused -Wshadow -Winline -Wnested-externs -Wmissing-declarations -Wmissing-prototypes -Wno-long-long -Wfloat-equal -Wno-multichar -Wsign-compare -Wundef -Wno-format-nonliteral -Wendif-labels -Wstrict-prototypes -Wdeclaration-after-statement -Wstrict-aliasing=3 -Wcast-align -Wtype-limits -Wold-style-declaration -Wmissing-parameter-type -Wempty-body -Wclobbered -Wignored-qualifiers -Wconversion -Wno-sign-conversion -Wvla -Wdouble-promotion -Wno-system-headers -Wno-pedantic-ms-format)\n      # surprisingly, CHECK_C_COMPILER_FLAG needs a new variable to store each new\n      # test result in.\n      check_c_compiler_flag(${_CCOPT} OPT${_CCOPT})\n      if(OPT${_CCOPT})\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${_CCOPT}\")\n      endif()\n    endforeach()\n  endif()\nendif()\n\nif(ENABLE_DEBUG)\n  # DEBUGBUILD will be defined only for Debug builds\n  if(NOT CMAKE_VERSION VERSION_LESS 3.0)\n    set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS $<$<CONFIG:Debug>:DEBUGBUILD>)\n  else()\n    set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS_DEBUG DEBUGBUILD)\n  endif()\n  set(ENABLE_CURLDEBUG ON)\nendif()\n\nif(ENABLE_CURLDEBUG)\n  set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS CURLDEBUG)\nendif()\n\nif(0) # This code not needed for building within CMake.\n# For debug libs and exes, add \"-d\" postfix\nif(NOT DEFINED CMAKE_DEBUG_POSTFIX)\n  set(CMAKE_DEBUG_POSTFIX \"-d\")\nendif()\nendif()\n\n# initialize CURL_LIBS\nset(CURL_LIBS \"\")\n\nif(ENABLE_ARES)\n  set(USE_ARES 1)\n  find_package(CARES REQUIRED)\n  list(APPEND CURL_LIBS ${CARES_LIBRARY})\n  set(CURL_LIBS ${CURL_LIBS} ${CARES_LIBRARY})\nendif()\n\nif(0) # This code not needed for building within CMake.\ninclude(CurlSymbolHiding)\nendif()\n\noption(HTTP_ONLY \"disables all protocols except HTTP (This overrides all CURL_DISABLE_* options)\" OFF)\nmark_as_advanced(HTTP_ONLY)\noption(CURL_DISABLE_FTP \"disables FTP\" OFF)\nmark_as_advanced(CURL_DISABLE_FTP)\noption(CURL_DISABLE_LDAP \"disables LDAP\" OFF)\nmark_as_advanced(CURL_DISABLE_LDAP)\noption(CURL_DISABLE_TELNET \"disables Telnet\" OFF)\nmark_as_advanced(CURL_DISABLE_TELNET)\noption(CURL_DISABLE_DICT \"disables DICT\" OFF)\nmark_as_advanced(CURL_DISABLE_DICT)\noption(CURL_DISABLE_FILE \"disables FILE\" OFF)\nmark_as_advanced(CURL_DISABLE_FILE)\noption(CURL_DISABLE_TFTP \"disables TFTP\" OFF)\nmark_as_advanced(CURL_DISABLE_TFTP)\noption(CURL_DISABLE_HTTP \"disables HTTP\" OFF)\nmark_as_advanced(CURL_DISABLE_HTTP)\n\noption(CURL_DISABLE_LDAPS \"to disable LDAPS\" OFF)\nmark_as_advanced(CURL_DISABLE_LDAPS)\n\noption(CURL_DISABLE_RTSP \"to disable RTSP\" OFF)\nmark_as_advanced(CURL_DISABLE_RTSP)\noption(CURL_DISABLE_PROXY \"to disable proxy\" OFF)\nmark_as_advanced(CURL_DISABLE_PROXY)\noption(CURL_DISABLE_POP3 \"to disable POP3\" OFF)\nmark_as_advanced(CURL_DISABLE_POP3)\noption(CURL_DISABLE_IMAP \"to disable IMAP\" OFF)\nmark_as_advanced(CURL_DISABLE_IMAP)\noption(CURL_DISABLE_SMTP \"to disable SMTP\" OFF)\nmark_as_advanced(CURL_DISABLE_SMTP)\noption(CURL_DISABLE_GOPHER \"to disable Gopher\" OFF)\nmark_as_advanced(CURL_DISABLE_GOPHER)\n\nif(HTTP_ONLY)\n  set(CURL_DISABLE_FTP ON)\n  set(CURL_DISABLE_LDAP ON)\n  set(CURL_DISABLE_LDAPS ON)\n  set(CURL_DISABLE_TELNET ON)\n  set(CURL_DISABLE_DICT ON)\n  set(CURL_DISABLE_FILE ON)\n  set(CURL_DISABLE_TFTP ON)\n  set(CURL_DISABLE_RTSP ON)\n  set(CURL_DISABLE_POP3 ON)\n  set(CURL_DISABLE_IMAP ON)\n  set(CURL_DISABLE_SMTP ON)\n  set(CURL_DISABLE_GOPHER ON)\nendif()\n\noption(CURL_DISABLE_COOKIES \"to disable cookies support\" OFF)\nmark_as_advanced(CURL_DISABLE_COOKIES)\n\noption(CURL_DISABLE_CRYPTO_AUTH \"to disable cryptographic authentication\" OFF)\nmark_as_advanced(CURL_DISABLE_CRYPTO_AUTH)\noption(CURL_DISABLE_VERBOSE_STRINGS \"to disable verbose strings\" OFF)\nmark_as_advanced(CURL_DISABLE_VERBOSE_STRINGS)\noption(ENABLE_IPV6 \"Define if you want to enable IPv6 support\" ON)\nmark_as_advanced(ENABLE_IPV6)\nif(ENABLE_IPV6 AND NOT WIN32)\n  include(CheckStructHasMember)\n  check_struct_has_member(\"struct sockaddr_in6\" sin6_addr \"netinet/in.h\"\n                          HAVE_SOCKADDR_IN6_SIN6_ADDR)\n  check_struct_has_member(\"struct sockaddr_in6\" sin6_scope_id \"netinet/in.h\"\n                          HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID)\n  if(NOT HAVE_SOCKADDR_IN6_SIN6_ADDR)\n    message(WARNING \"struct sockaddr_in6 not available, disabling IPv6 support\")\n    # Force the feature off as this name is used as guard macro...\n    set(ENABLE_IPV6 OFF\n        CACHE BOOL \"Define if you want to enable IPv6 support\" FORCE)\n  endif()\nendif()\n\nif(0) # This code not needed for building within CMake.\n# Required for building manual, docs, tests\ncurl_nroff_check()\nfind_package(Perl)\n\ncmake_dependent_option(ENABLE_MANUAL \"to provide the built-in manual\"\n    ON \"NROFF_USEFUL;PERL_FOUND\"\n    OFF)\n\nif(NOT PERL_FOUND)\n  message(STATUS \"Perl not found, testing disabled.\")\n  set(BUILD_TESTING OFF)\nendif()\nif(ENABLE_MANUAL)\n  set(USE_MANUAL ON)\nendif()\nendif()\n\n# We need ansi c-flags, especially on HP\nset(CMAKE_C_FLAGS \"${CMAKE_ANSI_CFLAGS} ${CMAKE_C_FLAGS}\")\nset(CMAKE_REQUIRED_FLAGS ${CMAKE_ANSI_CFLAGS})\n\nif(CURL_STATIC_CRT)\n  set(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} /MT\")\n  set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} /MTd\")\nendif()\n\n# Disable warnings on Borland to avoid changing 3rd party code.\nif(BORLAND)\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -w-\")\nendif()\n\n# If we are on AIX, do the _ALL_SOURCE magic\nif(${CMAKE_SYSTEM_NAME} MATCHES AIX)\n  set(_ALL_SOURCE 1)\nendif()\n\n# Include all the necessary files for macros\ninclude(CheckFunctionExists)\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\ninclude(CheckTypeSize)\ninclude(CheckCSourceCompiles)\n\n# On windows preload settings\nif(WIN32)\n  set(CMAKE_REQUIRED_DEFINITIONS \"${CMAKE_REQUIRED_DEFINITIONS} -D_WINSOCKAPI_=\")\n  include(${CMAKE_CURRENT_SOURCE_DIR}/CMake/Platforms/WindowsCache.cmake)\nendif()\n\nif(ENABLE_THREADED_RESOLVER)\n  find_package(Threads REQUIRED)\n  if(WIN32)\n    set(USE_THREADS_WIN32 ON)\n  else()\n    set(USE_THREADS_POSIX ${CMAKE_USE_PTHREADS_INIT})\n    set(HAVE_PTHREAD_H ${CMAKE_USE_PTHREADS_INIT})\n  endif()\n  set(CURL_LIBS ${CURL_LIBS} ${CMAKE_THREAD_LIBS_INIT})\nendif()\n\n# Check for all needed libraries\nif(0) # This code not needed for building within CMake.\ncheck_library_exists_concat(\"dl\"     dlopen       HAVE_LIBDL)\nelse()\n  # Use the cmake-defined dl libs as dl is should not be used\n  # on HPUX, but rather dld this avoids a warning\n  list(APPEND CURL_LIBS ${CMAKE_DL_LIBS})\nendif()\ncheck_library_exists_concat(\"socket\" connect      HAVE_LIBSOCKET)\ncheck_library_exists(\"c\" gethostbyname \"\" NOT_NEED_LIBNSL)\n\n# Yellowtab Zeta needs different libraries than BeOS 5.\nif(BEOS)\n  set(NOT_NEED_LIBNSL 1)\n  check_library_exists_concat(\"bind\" gethostbyname HAVE_LIBBIND)\n  check_library_exists_concat(\"bnetapi\" closesocket HAVE_LIBBNETAPI)\nendif()\n\ncheck_library_exists_concat(\"network\" recv HAVE_LIBNETWORK)\n\nif(NOT NOT_NEED_LIBNSL)\n  check_library_exists_concat(\"nsl\"    gethostbyname  HAVE_LIBNSL)\nendif()\n\ncheck_function_exists(gethostname HAVE_GETHOSTNAME)\n\nif(WIN32)\n  check_library_exists_concat(\"ws2_32\" getch        HAVE_LIBWS2_32)\n  check_library_exists_concat(\"winmm\"  getch        HAVE_LIBWINMM)\n  list(APPEND CURL_LIBS \"advapi32\")\nendif()\n\n# check SSL libraries\n# TODO support GNUTLS, NSS, POLARSSL, AXTLS, CYASSL\n\nif(APPLE)\n  option(CMAKE_USE_DARWINSSL \"enable Apple OS native SSL/TLS\" OFF)\nendif()\nif(WIN32)\n  option(CMAKE_USE_WINSSL \"enable Windows native SSL/TLS\" OFF)\n  cmake_dependent_option(CURL_WINDOWS_SSPI \"Use windows libraries to allow NTLM authentication without openssl\" ON\n    CMAKE_USE_WINSSL OFF)\nendif()\noption(CMAKE_USE_MBEDTLS \"Enable mbedTLS for SSL/TLS\" OFF)\n\nset(openssl_default ON)\nif(WIN32 OR CMAKE_USE_DARWINSSL OR CMAKE_USE_WINSSL OR CMAKE_USE_MBEDTLS)\n  set(openssl_default OFF)\nendif()\n\ncount_true(enabled_ssl_options_count\n  CMAKE_USE_WINSSL\n  CMAKE_USE_DARWINSSL\n  CMAKE_USE_OPENSSL\n  CMAKE_USE_MBEDTLS\n)\nif(enabled_ssl_options_count GREATER \"1\")\n  set(CURL_WITH_MULTI_SSL ON)\nendif()\n\nif(CMAKE_USE_WINSSL)\n  set(SSL_ENABLED ON)\n  set(USE_SCHANNEL ON) # Windows native SSL/TLS support\n  set(USE_WINDOWS_SSPI ON) # CMAKE_USE_WINSSL implies CURL_WINDOWS_SSPI\n  list(APPEND CURL_LIBS \"crypt32\")\nendif()\nif(CURL_WINDOWS_SSPI)\n  set(USE_WINDOWS_SSPI ON)\n  set(CMAKE_REQUIRED_DEFINITIONS \"${CMAKE_REQUIRED_DEFINITIONS} -DSECURITY_WIN32\")\nendif()\n\nif(CMAKE_USE_DARWINSSL)\n  find_library(COREFOUNDATION_FRAMEWORK \"CoreFoundation\")\n  if(NOT COREFOUNDATION_FRAMEWORK)\n      message(FATAL_ERROR \"CoreFoundation framework not found\")\n  endif()\n\n  find_library(SECURITY_FRAMEWORK \"Security\")\n  if(NOT SECURITY_FRAMEWORK)\n     message(FATAL_ERROR \"Security framework not found\")\n  endif()\n\n  set(SSL_ENABLED ON)\n  set(USE_DARWINSSL ON)\n  list(APPEND CURL_LIBS \"${COREFOUNDATION_FRAMEWORK}\" \"${SECURITY_FRAMEWORK}\")\nendif()\n\nif(CMAKE_USE_OPENSSL)\n  find_package(OpenSSL REQUIRED)\n  set(SSL_ENABLED ON)\n  set(USE_OPENSSL ON)\n  set(HAVE_LIBCRYPTO ON)\n  set(HAVE_LIBSSL ON)\n  list(APPEND CURL_LIBS ${OPENSSL_LIBRARIES})\n  include_directories(${OPENSSL_INCLUDE_DIR})\n\n  set(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})\n  check_include_file(\"openssl/crypto.h\" HAVE_OPENSSL_CRYPTO_H)\n  check_include_file(\"openssl/err.h\"    HAVE_OPENSSL_ERR_H)\n  check_include_file(\"openssl/pem.h\"    HAVE_OPENSSL_PEM_H)\n  check_include_file(\"openssl/rsa.h\"    HAVE_OPENSSL_RSA_H)\n  check_include_file(\"openssl/ssl.h\"    HAVE_OPENSSL_SSL_H)\n  check_include_file(\"openssl/x509.h\"   HAVE_OPENSSL_X509_H)\n  check_include_file(\"openssl/rand.h\"   HAVE_OPENSSL_RAND_H)\n  check_symbol_exists(RAND_status \"${CURL_INCLUDES}\" HAVE_RAND_STATUS)\n  check_symbol_exists(RAND_screen \"${CURL_INCLUDES}\" HAVE_RAND_SCREEN)\n  check_symbol_exists(RAND_egd    \"${CURL_INCLUDES}\" HAVE_RAND_EGD)\n\n  # Optionally build with a specific CA cert bundle.\n  if(CURL_CA_BUNDLE)\n    add_definitions(-DCURL_CA_BUNDLE=\"${CURL_CA_BUNDLE}\")\n  endif()\n  # Optionally build with a specific CA cert dir.\n  if(CURL_CA_PATH)\n    add_definitions(-DCURL_CA_PATH=\"${CURL_CA_PATH}\")\n  endif()\nendif()\n\nif(CMAKE_USE_MBEDTLS)\n  find_package(MbedTLS REQUIRED)\n  set(SSL_ENABLED ON)\n  set(USE_MBEDTLS ON)\n  list(APPEND CURL_LIBS ${MBEDTLS_LIBRARIES})\n  include_directories(${MBEDTLS_INCLUDE_DIRS})\nendif()\n\noption(USE_NGHTTP2 \"Use Nghttp2 library\" OFF)\nif(USE_NGHTTP2)\n  find_package(NGHTTP2 REQUIRED)\n  include_directories(${NGHTTP2_INCLUDE_DIRS})\n  list(APPEND CURL_LIBS ${NGHTTP2_LIBRARIES})\nendif()\n\nif(NOT CURL_DISABLE_LDAP)\n  if(WIN32)\n    option(USE_WIN32_LDAP \"Use Windows LDAP implementation\" ON)\n    if(USE_WIN32_LDAP)\n      check_library_exists_concat(\"wldap32\" cldap_open HAVE_WLDAP32)\n      if(NOT HAVE_WLDAP32)\n        set(USE_WIN32_LDAP OFF)\n      endif()\n    endif()\n  endif()\n\n  option(CMAKE_USE_OPENLDAP \"Use OpenLDAP code.\" OFF)\n  mark_as_advanced(CMAKE_USE_OPENLDAP)\n  set(CMAKE_LDAP_LIB \"ldap\" CACHE STRING \"Name or full path to ldap library\")\n  set(CMAKE_LBER_LIB \"lber\" CACHE STRING \"Name or full path to lber library\")\n\n  if(CMAKE_USE_OPENLDAP AND USE_WIN32_LDAP)\n    message(FATAL_ERROR \"Cannot use USE_WIN32_LDAP and CMAKE_USE_OPENLDAP at the same time\")\n  endif()\n\n  # Now that we know, we're not using windows LDAP...\n  if(USE_WIN32_LDAP)\n    check_include_file_concat(\"winldap.h\" HAVE_WINLDAP_H)\n    check_include_file_concat(\"winber.h\"  HAVE_WINBER_H)\n  else()\n    # Check for LDAP\n    set(CMAKE_REQUIRED_LIBRARIES ${OPENSSL_LIBRARIES})\n    check_library_exists_concat(${CMAKE_LDAP_LIB} ldap_init HAVE_LIBLDAP)\n    check_library_exists_concat(${CMAKE_LBER_LIB} ber_init HAVE_LIBLBER)\n\n    set(CMAKE_REQUIRED_INCLUDES_BAK ${CMAKE_REQUIRED_INCLUDES})\n    set(CMAKE_LDAP_INCLUDE_DIR \"\" CACHE STRING \"Path to LDAP include directory\")\n    if(CMAKE_LDAP_INCLUDE_DIR)\n      list(APPEND CMAKE_REQUIRED_INCLUDES ${CMAKE_LDAP_INCLUDE_DIR})\n    endif()\n    check_include_file_concat(\"ldap.h\"           HAVE_LDAP_H)\n    check_include_file_concat(\"lber.h\"           HAVE_LBER_H)\n\n    if(NOT HAVE_LDAP_H)\n      message(STATUS \"LDAP_H not found CURL_DISABLE_LDAP set ON\")\n      set(CURL_DISABLE_LDAP ON CACHE BOOL \"\" FORCE)\n      set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_BAK}) #LDAP includes won't be used\n    elseif(NOT HAVE_LIBLDAP)\n      message(STATUS \"LDAP library '${CMAKE_LDAP_LIB}' not found CURL_DISABLE_LDAP set ON\")\n      set(CURL_DISABLE_LDAP ON CACHE BOOL \"\" FORCE)\n      set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_BAK}) #LDAP includes won't be used\n    else()\n      if(CMAKE_USE_OPENLDAP)\n        set(USE_OPENLDAP ON)\n      endif()\n      if(CMAKE_LDAP_INCLUDE_DIR)\n        include_directories(${CMAKE_LDAP_INCLUDE_DIR})\n      endif()\n      set(NEED_LBER_H ON)\n      set(_HEADER_LIST)\n      if(HAVE_WINDOWS_H)\n        list(APPEND _HEADER_LIST \"windows.h\")\n      endif()\n      if(HAVE_SYS_TYPES_H)\n        list(APPEND _HEADER_LIST \"sys/types.h\")\n      endif()\n      list(APPEND _HEADER_LIST \"ldap.h\")\n\n      set(_SRC_STRING \"\")\n      foreach(_HEADER ${_HEADER_LIST})\n        set(_INCLUDE_STRING \"${_INCLUDE_STRING}#include <${_HEADER}>\\n\")\n      endforeach()\n\n      set(_SRC_STRING\n        \"\n        ${_INCLUDE_STRING}\n        int main(int argc, char ** argv)\n        {\n          BerValue *bvp = NULL;\n          BerElement *bep = ber_init(bvp);\n          ber_free(bep, 1);\n          return 0;\n        }\"\n      )\n      set(CMAKE_REQUIRED_DEFINITIONS \"${CMAKE_REQUIRED_DEFINITIONS} -DLDAP_DEPRECATED=1\")\n      list(APPEND CMAKE_REQUIRED_LIBRARIES ${CMAKE_LDAP_LIB})\n      if(HAVE_LIBLBER)\n        list(APPEND CMAKE_REQUIRED_LIBRARIES ${CMAKE_LBER_LIB})\n      endif()\n      check_c_source_compiles(\"${_SRC_STRING}\" NOT_NEED_LBER_H)\n\n      if(NOT_NEED_LBER_H)\n        set(NEED_LBER_H OFF)\n      else()\n        set(CURL_TEST_DEFINES \"${CURL_TEST_DEFINES} -DNEED_LBER_H\")\n      endif()\n    endif()\n  endif()\nendif()\n\n# No ldap, no ldaps.\nif(CURL_DISABLE_LDAP)\n  if(NOT CURL_DISABLE_LDAPS)\n    message(STATUS \"LDAP needs to be enabled to support LDAPS\")\n    set(CURL_DISABLE_LDAPS ON CACHE BOOL \"\" FORCE)\n  endif()\nendif()\n\nif(NOT CURL_DISABLE_LDAPS)\n  check_include_file_concat(\"ldap_ssl.h\" HAVE_LDAP_SSL_H)\n  check_include_file_concat(\"ldapssl.h\"  HAVE_LDAPSSL_H)\nendif()\n\n# Check for idn\ncheck_library_exists_concat(\"idn2\" idn2_lookup_ul HAVE_LIBIDN2)\n\n# Check for symbol dlopen (same as HAVE_LIBDL)\ncheck_library_exists(\"${CURL_LIBS}\" dlopen \"\" HAVE_DLOPEN)\n\nif(0) # This code not needed for building within CMake.\noption(CURL_ZLIB \"Set to ON to enable building curl with zlib support.\" ON)\nset(HAVE_LIBZ OFF)\nset(HAVE_ZLIB_H OFF)\nset(USE_ZLIB OFF)\nif(CURL_ZLIB)\n  find_package(ZLIB QUIET)\n  if(ZLIB_FOUND)\n    set(HAVE_ZLIB_H ON)\n    set(HAVE_LIBZ ON)\n    set(USE_ZLIB ON)\n\n    # Depend on ZLIB via imported targets if supported by the running\n    # version of CMake.  This allows our dependents to get our dependencies\n    # transitively.\n    if(NOT CMAKE_VERSION VERSION_LESS 3.4)\n      list(APPEND CURL_LIBS ZLIB::ZLIB)\n    else()\n      list(APPEND CURL_LIBS ${ZLIB_LIBRARIES})\n      include_directories(${ZLIB_INCLUDE_DIRS})\n    endif()\n    list(APPEND CMAKE_REQUIRED_INCLUDES ${ZLIB_INCLUDE_DIRS})\n  endif()\nendif()\nendif()\n\n#-----------------------------------------------------------------------------\n# CMake-specific curl code.\n\nif(CURL_SPECIAL_LIBZ)\n  set(CURL_LIBS ${CURL_LIBS} \"${CURL_SPECIAL_LIBZ}\")\n  include_directories(${CURL_SPECIAL_LIBZ_INCLUDES})\n  set(HAVE_LIBZ 0)\n  set(HAVE_ZLIB_H 0)\nendif()\n\noption(CURL_BROTLI \"Set to ON to enable building curl with brotli support.\" OFF)\nset(HAVE_BROTLI OFF)\nif(CURL_BROTLI)\n  find_package(BROTLI QUIET)\n  if(BROTLI_FOUND)\n    set(HAVE_BROTLI ON)\n    list(APPEND CURL_LIBS ${BROTLI_LIBRARIES})\n    include_directories(${BROTLI_INCLUDE_DIRS})\n    list(APPEND CMAKE_REQUIRED_INCLUDES ${BROTLI_INCLUDE_DIRS})\n  endif()\nendif()\n\n#libSSH2\noption(CMAKE_USE_LIBSSH2 \"Use libSSH2\" ON)\nmark_as_advanced(CMAKE_USE_LIBSSH2)\nset(USE_LIBSSH2 OFF)\nset(HAVE_LIBSSH2 OFF)\nset(HAVE_LIBSSH2_H OFF)\n\nif(CMAKE_USE_LIBSSH2)\n  find_package(LibSSH2)\n  if(LIBSSH2_FOUND)\n    list(APPEND CURL_LIBS ${LIBSSH2_LIBRARY})\n    set(CMAKE_REQUIRED_LIBRARIES ${LIBSSH2_LIBRARY})\n    list(APPEND CMAKE_REQUIRED_INCLUDES \"${LIBSSH2_INCLUDE_DIR}\")\n    include_directories(\"${LIBSSH2_INCLUDE_DIR}\")\n    set(HAVE_LIBSSH2 ON)\n    set(USE_LIBSSH2 ON)\n\n    # find_package has already found the headers\n    set(HAVE_LIBSSH2_H ON)\n    set(CURL_INCLUDES ${CURL_INCLUDES} \"${LIBSSH2_INCLUDE_DIR}/libssh2.h\")\n    set(CURL_TEST_DEFINES \"${CURL_TEST_DEFINES} -DHAVE_LIBSSH2_H\")\n\n    # now check for specific libssh2 symbols as they were added in different versions\n    set(CMAKE_EXTRA_INCLUDE_FILES \"libssh2.h\")\n    check_function_exists(libssh2_version           HAVE_LIBSSH2_VERSION)\n    check_function_exists(libssh2_init              HAVE_LIBSSH2_INIT)\n    check_function_exists(libssh2_exit              HAVE_LIBSSH2_EXIT)\n    check_function_exists(libssh2_scp_send64        HAVE_LIBSSH2_SCP_SEND64)\n    check_function_exists(libssh2_session_handshake HAVE_LIBSSH2_SESSION_HANDSHAKE)\n    set(CMAKE_EXTRA_INCLUDE_FILES \"\")\n  endif()\nendif()\n\noption(CMAKE_USE_GSSAPI \"Use GSSAPI implementation (right now only Heimdal is supported with CMake build)\" OFF)\nmark_as_advanced(CMAKE_USE_GSSAPI)\n\nif(CMAKE_USE_GSSAPI)\n  find_package(GSS)\n\n  set(HAVE_GSSAPI ${GSS_FOUND})\n  if(GSS_FOUND)\n\n    message(STATUS \"Found ${GSS_FLAVOUR} GSSAPI version: \\\"${GSS_VERSION}\\\"\")\n\n    list(APPEND CMAKE_REQUIRED_INCLUDES ${GSS_INCLUDE_DIRECTORIES})\n    check_include_file_concat(\"gssapi/gssapi.h\"  HAVE_GSSAPI_GSSAPI_H)\n    check_include_file_concat(\"gssapi/gssapi_generic.h\" HAVE_GSSAPI_GSSAPI_GENERIC_H)\n    check_include_file_concat(\"gssapi/gssapi_krb5.h\" HAVE_GSSAPI_GSSAPI_KRB5_H)\n\n    if(GSS_FLAVOUR STREQUAL \"Heimdal\")\n      set(HAVE_GSSHEIMDAL ON)\n    else() # MIT\n      set(HAVE_GSSMIT ON)\n      set(_INCLUDE_LIST \"\")\n      if(HAVE_GSSAPI_GSSAPI_H)\n        list(APPEND _INCLUDE_LIST \"gssapi/gssapi.h\")\n      endif()\n      if(HAVE_GSSAPI_GSSAPI_GENERIC_H)\n        list(APPEND _INCLUDE_LIST \"gssapi/gssapi_generic.h\")\n      endif()\n      if(HAVE_GSSAPI_GSSAPI_KRB5_H)\n        list(APPEND _INCLUDE_LIST \"gssapi/gssapi_krb5.h\")\n      endif()\n\n      string(REPLACE \";\" \" \" _COMPILER_FLAGS_STR \"${GSS_COMPILER_FLAGS}\")\n      string(REPLACE \";\" \" \" _LINKER_FLAGS_STR \"${GSS_LINKER_FLAGS}\")\n\n      foreach(_dir ${GSS_LINK_DIRECTORIES})\n        set(_LINKER_FLAGS_STR \"${_LINKER_FLAGS_STR} -L\\\"${_dir}\\\"\")\n      endforeach()\n\n      set(CMAKE_REQUIRED_FLAGS \"${_COMPILER_FLAGS_STR} ${_LINKER_FLAGS_STR}\")\n      set(CMAKE_REQUIRED_LIBRARIES ${GSS_LIBRARIES})\n      check_symbol_exists(\"GSS_C_NT_HOSTBASED_SERVICE\" ${_INCLUDE_LIST} HAVE_GSS_C_NT_HOSTBASED_SERVICE)\n      if(NOT HAVE_GSS_C_NT_HOSTBASED_SERVICE)\n        set(HAVE_OLD_GSSMIT ON)\n      endif()\n\n    endif()\n\n    include_directories(${GSS_INCLUDE_DIRECTORIES})\n    link_directories(${GSS_LINK_DIRECTORIES})\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GSS_COMPILER_FLAGS}\")\n    set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} ${GSS_LINKER_FLAGS}\")\n    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${GSS_LINKER_FLAGS}\")\n    list(APPEND CURL_LIBS ${GSS_LIBRARIES})\n\n  else()\n    message(WARNING \"GSSAPI support has been requested but no supporting libraries found. Skipping.\")\n  endif()\nendif()\n\noption(ENABLE_UNIX_SOCKETS \"Define if you want Unix domain sockets support\" ON)\nif(ENABLE_UNIX_SOCKETS)\n  include(CheckStructHasMember)\n  check_struct_has_member(\"struct sockaddr_un\" sun_path \"sys/un.h\" USE_UNIX_SOCKETS)\nelse()\n  unset(USE_UNIX_SOCKETS CACHE)\nendif()\n\n\nif(0) # This code not needed for building within CMake.\n#\n# CA handling\n#\nset(CURL_CA_BUNDLE \"auto\" CACHE STRING\n    \"Path to the CA bundle. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.\")\nset(CURL_CA_FALLBACK OFF CACHE BOOL\n    \"Set ON to use built-in CA store of TLS backend. Defaults to OFF\")\nset(CURL_CA_PATH \"auto\" CACHE STRING\n    \"Location of default CA path. Set 'none' to disable or 'auto' for auto-detection. Defaults to 'auto'.\")\n\nif(\"${CURL_CA_BUNDLE}\" STREQUAL \"\")\n  message(FATAL_ERROR \"Invalid value of CURL_CA_BUNDLE. Use 'none', 'auto' or file path.\")\nelseif(\"${CURL_CA_BUNDLE}\" STREQUAL \"none\")\n  unset(CURL_CA_BUNDLE CACHE)\nelseif(\"${CURL_CA_BUNDLE}\" STREQUAL \"auto\")\n  unset(CURL_CA_BUNDLE CACHE)\n  set(CURL_CA_BUNDLE_AUTODETECT TRUE)\nelse()\n  set(CURL_CA_BUNDLE_SET TRUE)\nendif()\n\nif(\"${CURL_CA_PATH}\" STREQUAL \"\")\n  message(FATAL_ERROR \"Invalid value of CURL_CA_PATH. Use 'none', 'auto' or directory path.\")\nelseif(\"${CURL_CA_PATH}\" STREQUAL \"none\")\n  unset(CURL_CA_PATH CACHE)\nelseif(\"${CURL_CA_PATH}\" STREQUAL \"auto\")\n  unset(CURL_CA_PATH CACHE)\n  set(CURL_CA_PATH_AUTODETECT TRUE)\nelse()\n  set(CURL_CA_PATH_SET TRUE)\nendif()\n\nif(CURL_CA_BUNDLE_SET AND CURL_CA_PATH_AUTODETECT)\n  # Skip autodetection of unset CA path because CA bundle is set explicitly\nelseif(CURL_CA_PATH_SET AND CURL_CA_BUNDLE_AUTODETECT)\n  # Skip autodetection of unset CA bundle because CA path is set explicitly\nelseif(CURL_CA_PATH_AUTODETECT OR CURL_CA_BUNDLE_AUTODETECT)\n  # first try autodetecting a CA bundle, then a CA path\n\n  if(CURL_CA_BUNDLE_AUTODETECT)\n    set(SEARCH_CA_BUNDLE_PATHS\n        /etc/ssl/certs/ca-certificates.crt\n        /etc/pki/tls/certs/ca-bundle.crt\n        /usr/share/ssl/certs/ca-bundle.crt\n        /usr/local/share/certs/ca-root-nss.crt\n        /etc/ssl/cert.pem)\n\n    foreach(SEARCH_CA_BUNDLE_PATH ${SEARCH_CA_BUNDLE_PATHS})\n      if(EXISTS \"${SEARCH_CA_BUNDLE_PATH}\")\n        message(STATUS \"Found CA bundle: ${SEARCH_CA_BUNDLE_PATH}\")\n        set(CURL_CA_BUNDLE \"${SEARCH_CA_BUNDLE_PATH}\")\n        set(CURL_CA_BUNDLE_SET TRUE CACHE BOOL \"Path to the CA bundle has been set\")\n        break()\n      endif()\n    endforeach()\n  endif()\n\n  if(CURL_CA_PATH_AUTODETECT AND (NOT CURL_CA_PATH_SET))\n    if(EXISTS \"/etc/ssl/certs\")\n      set(CURL_CA_PATH \"/etc/ssl/certs\")\n      set(CURL_CA_PATH_SET TRUE CACHE BOOL \"Path to the CA bundle has been set\")\n    endif()\n  endif()\nendif()\n\nif(CURL_CA_PATH_SET AND NOT USE_OPENSSL AND NOT USE_MBEDTLS)\n  message(FATAL_ERROR\n          \"CA path only supported by OpenSSL, GnuTLS or mbed TLS. \"\n          \"Set CURL_CA_PATH=none or enable one of those TLS backends.\")\nendif()\nendif()\n\n# Check for header files\nif(NOT UNIX)\n  check_include_file_concat(\"windows.h\"      HAVE_WINDOWS_H)\n  check_include_file_concat(\"winsock.h\"      HAVE_WINSOCK_H)\n  check_include_file_concat(\"ws2tcpip.h\"     HAVE_WS2TCPIP_H)\n  check_include_file_concat(\"winsock2.h\"     HAVE_WINSOCK2_H)\n  if(NOT CURL_WINDOWS_SSPI AND USE_OPENSSL)\n    set(CURL_LIBS ${CURL_LIBS} \"crypt32\")\n  endif()\nelse()\n  set(HAVE_WINDOWS_H 0)\n  set(HAVE_WINSOCK_H 0)\n  set(HAVE_WS2TCPIP_H 0)\n  set(HAVE_WINSOCK2_H 0)\nendif()\n\ncheck_include_file_concat(\"stdio.h\"          HAVE_STDIO_H)\ncheck_include_file_concat(\"inttypes.h\"       HAVE_INTTYPES_H)\ncheck_include_file_concat(\"sys/filio.h\"      HAVE_SYS_FILIO_H)\ncheck_include_file_concat(\"sys/ioctl.h\"      HAVE_SYS_IOCTL_H)\ncheck_include_file_concat(\"sys/param.h\"      HAVE_SYS_PARAM_H)\ncheck_include_file_concat(\"sys/poll.h\"       HAVE_SYS_POLL_H)\ncheck_include_file_concat(\"sys/resource.h\"   HAVE_SYS_RESOURCE_H)\ncheck_include_file_concat(\"sys/select.h\"     HAVE_SYS_SELECT_H)\ncheck_include_file_concat(\"sys/socket.h\"     HAVE_SYS_SOCKET_H)\ncheck_include_file_concat(\"sys/sockio.h\"     HAVE_SYS_SOCKIO_H)\ncheck_include_file_concat(\"sys/stat.h\"       HAVE_SYS_STAT_H)\ncheck_include_file_concat(\"sys/time.h\"       HAVE_SYS_TIME_H)\ncheck_include_file_concat(\"sys/types.h\"      HAVE_SYS_TYPES_H)\ncheck_include_file_concat(\"sys/uio.h\"        HAVE_SYS_UIO_H)\ncheck_include_file_concat(\"sys/un.h\"         HAVE_SYS_UN_H)\ncheck_include_file_concat(\"sys/utime.h\"      HAVE_SYS_UTIME_H)\ncheck_include_file_concat(\"sys/xattr.h\"      HAVE_SYS_XATTR_H)\ncheck_include_file_concat(\"alloca.h\"         HAVE_ALLOCA_H)\ncheck_include_file_concat(\"arpa/inet.h\"      HAVE_ARPA_INET_H)\ncheck_include_file_concat(\"arpa/tftp.h\"      HAVE_ARPA_TFTP_H)\ncheck_include_file_concat(\"assert.h\"         HAVE_ASSERT_H)\ncheck_include_file_concat(\"crypto.h\"         HAVE_CRYPTO_H)\ncheck_include_file_concat(\"des.h\"            HAVE_DES_H)\ncheck_include_file_concat(\"err.h\"            HAVE_ERR_H)\ncheck_include_file_concat(\"errno.h\"          HAVE_ERRNO_H)\ncheck_include_file_concat(\"fcntl.h\"          HAVE_FCNTL_H)\ncheck_include_file_concat(\"idn2.h\"           HAVE_IDN2_H)\ncheck_include_file_concat(\"ifaddrs.h\"        HAVE_IFADDRS_H)\ncheck_include_file_concat(\"io.h\"             HAVE_IO_H)\ncheck_include_file_concat(\"krb.h\"            HAVE_KRB_H)\ncheck_include_file_concat(\"libgen.h\"         HAVE_LIBGEN_H)\ncheck_include_file_concat(\"locale.h\"         HAVE_LOCALE_H)\ncheck_include_file_concat(\"net/if.h\"         HAVE_NET_IF_H)\ncheck_include_file_concat(\"netdb.h\"          HAVE_NETDB_H)\ncheck_include_file_concat(\"netinet/in.h\"     HAVE_NETINET_IN_H)\ncheck_include_file_concat(\"netinet/tcp.h\"    HAVE_NETINET_TCP_H)\n\ncheck_include_file_concat(\"pem.h\"            HAVE_PEM_H)\ncheck_include_file_concat(\"poll.h\"           HAVE_POLL_H)\ncheck_include_file_concat(\"pwd.h\"            HAVE_PWD_H)\ncheck_include_file_concat(\"rsa.h\"            HAVE_RSA_H)\ncheck_include_file_concat(\"setjmp.h\"         HAVE_SETJMP_H)\ncheck_include_file_concat(\"sgtty.h\"          HAVE_SGTTY_H)\ncheck_include_file_concat(\"signal.h\"         HAVE_SIGNAL_H)\ncheck_include_file_concat(\"ssl.h\"            HAVE_SSL_H)\ncheck_include_file_concat(\"stdbool.h\"        HAVE_STDBOOL_H)\ncheck_include_file_concat(\"stdint.h\"         HAVE_STDINT_H)\ncheck_include_file_concat(\"stdio.h\"          HAVE_STDIO_H)\ncheck_include_file_concat(\"stdlib.h\"         HAVE_STDLIB_H)\ncheck_include_file_concat(\"string.h\"         HAVE_STRING_H)\ncheck_include_file_concat(\"strings.h\"        HAVE_STRINGS_H)\ncheck_include_file_concat(\"stropts.h\"        HAVE_STROPTS_H)\ncheck_include_file_concat(\"termio.h\"         HAVE_TERMIO_H)\ncheck_include_file_concat(\"termios.h\"        HAVE_TERMIOS_H)\ncheck_include_file_concat(\"time.h\"           HAVE_TIME_H)\ncheck_include_file_concat(\"unistd.h\"         HAVE_UNISTD_H)\ncheck_include_file_concat(\"utime.h\"          HAVE_UTIME_H)\ncheck_include_file_concat(\"x509.h\"           HAVE_X509_H)\n\ncheck_include_file_concat(\"process.h\"        HAVE_PROCESS_H)\ncheck_include_file_concat(\"stddef.h\"         HAVE_STDDEF_H)\ncheck_include_file_concat(\"dlfcn.h\"          HAVE_DLFCN_H)\ncheck_include_file_concat(\"malloc.h\"         HAVE_MALLOC_H)\ncheck_include_file_concat(\"memory.h\"         HAVE_MEMORY_H)\ncheck_include_file_concat(\"netinet/if_ether.h\" HAVE_NETINET_IF_ETHER_H)\ncheck_include_file_concat(\"stdint.h\"        HAVE_STDINT_H)\ncheck_include_file_concat(\"sockio.h\"        HAVE_SOCKIO_H)\ncheck_include_file_concat(\"sys/utsname.h\"   HAVE_SYS_UTSNAME_H)\n\ncheck_type_size(size_t  SIZEOF_SIZE_T)\ncheck_type_size(ssize_t  SIZEOF_SSIZE_T)\ncheck_type_size(\"long long\"  SIZEOF_LONG_LONG)\ncheck_type_size(\"long\"  SIZEOF_LONG)\ncheck_type_size(\"short\"  SIZEOF_SHORT)\ncheck_type_size(\"int\"  SIZEOF_INT)\ncheck_type_size(\"__int64\"  SIZEOF___INT64)\ncheck_type_size(\"time_t\"  SIZEOF_TIME_T)\n\nif(HAVE_SIZEOF_LONG_LONG)\n  set(HAVE_LONGLONG 1)\n  set(HAVE_LL 1)\nendif()\n\nfind_file(RANDOM_FILE urandom /dev)\nmark_as_advanced(RANDOM_FILE)\n\n# Check for some functions that are used\nif(HAVE_LIBWS2_32)\n  set(CMAKE_REQUIRED_LIBRARIES ws2_32)\nelseif(HAVE_LIBSOCKET)\n  set(CMAKE_REQUIRED_LIBRARIES socket)\nelseif(HAVE_LIBNETWORK)\n  set(CMAKE_REQUIRED_LIBRARIES network)\nendif()\n\ncheck_symbol_exists(basename      \"${CURL_INCLUDES}\" HAVE_BASENAME)\ncheck_symbol_exists(socket        \"${CURL_INCLUDES}\" HAVE_SOCKET)\n# poll on macOS is unreliable, it first did not exist, then was broken until\n# fixed in 10.9 only to break again in 10.12.\nif(NOT APPLE)\n  check_symbol_exists(poll        \"${CURL_INCLUDES}\" HAVE_POLL)\nendif()\ncheck_symbol_exists(select        \"${CURL_INCLUDES}\" HAVE_SELECT)\ncheck_symbol_exists(strdup        \"${CURL_INCLUDES}\" HAVE_STRDUP)\ncheck_symbol_exists(strstr        \"${CURL_INCLUDES}\" HAVE_STRSTR)\ncheck_symbol_exists(strtok_r      \"${CURL_INCLUDES}\" HAVE_STRTOK_R)\ncheck_symbol_exists(strftime      \"${CURL_INCLUDES}\" HAVE_STRFTIME)\ncheck_symbol_exists(uname         \"${CURL_INCLUDES}\" HAVE_UNAME)\ncheck_symbol_exists(strcasecmp    \"${CURL_INCLUDES}\" HAVE_STRCASECMP)\ncheck_symbol_exists(stricmp       \"${CURL_INCLUDES}\" HAVE_STRICMP)\ncheck_symbol_exists(strcmpi       \"${CURL_INCLUDES}\" HAVE_STRCMPI)\ncheck_symbol_exists(strncmpi      \"${CURL_INCLUDES}\" HAVE_STRNCMPI)\ncheck_symbol_exists(alarm         \"${CURL_INCLUDES}\" HAVE_ALARM)\nif(NOT HAVE_STRNCMPI)\n  set(HAVE_STRCMPI)\nendif()\ncheck_symbol_exists(gethostbyaddr \"${CURL_INCLUDES}\" HAVE_GETHOSTBYADDR)\ncheck_symbol_exists(gethostbyaddr_r \"${CURL_INCLUDES}\" HAVE_GETHOSTBYADDR_R)\ncheck_symbol_exists(gettimeofday  \"${CURL_INCLUDES}\" HAVE_GETTIMEOFDAY)\ncheck_symbol_exists(inet_addr     \"${CURL_INCLUDES}\" HAVE_INET_ADDR)\ncheck_symbol_exists(inet_ntoa     \"${CURL_INCLUDES}\" HAVE_INET_NTOA)\ncheck_symbol_exists(inet_ntoa_r   \"${CURL_INCLUDES}\" HAVE_INET_NTOA_R)\ncheck_symbol_exists(tcsetattr     \"${CURL_INCLUDES}\" HAVE_TCSETATTR)\ncheck_symbol_exists(tcgetattr     \"${CURL_INCLUDES}\" HAVE_TCGETATTR)\ncheck_symbol_exists(perror        \"${CURL_INCLUDES}\" HAVE_PERROR)\ncheck_symbol_exists(closesocket   \"${CURL_INCLUDES}\" HAVE_CLOSESOCKET)\ncheck_symbol_exists(setvbuf       \"${CURL_INCLUDES}\" HAVE_SETVBUF)\ncheck_symbol_exists(sigsetjmp     \"${CURL_INCLUDES}\" HAVE_SIGSETJMP)\ncheck_symbol_exists(getpass_r     \"${CURL_INCLUDES}\" HAVE_GETPASS_R)\ncheck_symbol_exists(strlcat       \"${CURL_INCLUDES}\" HAVE_STRLCAT)\ncheck_symbol_exists(getpwuid      \"${CURL_INCLUDES}\" HAVE_GETPWUID)\ncheck_symbol_exists(getpwuid_r    \"${CURL_INCLUDES}\" HAVE_GETPWUID_R)\ncheck_symbol_exists(geteuid       \"${CURL_INCLUDES}\" HAVE_GETEUID)\ncheck_symbol_exists(utime         \"${CURL_INCLUDES}\" HAVE_UTIME)\ncheck_symbol_exists(gmtime_r      \"${CURL_INCLUDES}\" HAVE_GMTIME_R)\ncheck_symbol_exists(localtime_r   \"${CURL_INCLUDES}\" HAVE_LOCALTIME_R)\n\ncheck_symbol_exists(gethostbyname   \"${CURL_INCLUDES}\" HAVE_GETHOSTBYNAME)\ncheck_symbol_exists(gethostbyname_r \"${CURL_INCLUDES}\" HAVE_GETHOSTBYNAME_R)\n\ncheck_symbol_exists(signal        \"${CURL_INCLUDES}\" HAVE_SIGNAL_FUNC)\ncheck_symbol_exists(SIGALRM       \"${CURL_INCLUDES}\" HAVE_SIGNAL_MACRO)\nif(HAVE_SIGNAL_FUNC AND HAVE_SIGNAL_MACRO)\n  set(HAVE_SIGNAL 1)\nendif()\ncheck_symbol_exists(uname          \"${CURL_INCLUDES}\" HAVE_UNAME)\ncheck_symbol_exists(strtoll        \"${CURL_INCLUDES}\" HAVE_STRTOLL)\ncheck_symbol_exists(_strtoi64      \"${CURL_INCLUDES}\" HAVE__STRTOI64)\ncheck_symbol_exists(strerror_r     \"${CURL_INCLUDES}\" HAVE_STRERROR_R)\ncheck_symbol_exists(siginterrupt   \"${CURL_INCLUDES}\" HAVE_SIGINTERRUPT)\ncheck_symbol_exists(perror         \"${CURL_INCLUDES}\" HAVE_PERROR)\ncheck_symbol_exists(fork           \"${CURL_INCLUDES}\" HAVE_FORK)\ncheck_symbol_exists(getaddrinfo    \"${CURL_INCLUDES}\" HAVE_GETADDRINFO)\ncheck_symbol_exists(freeaddrinfo   \"${CURL_INCLUDES}\" HAVE_FREEADDRINFO)\ncheck_symbol_exists(freeifaddrs    \"${CURL_INCLUDES}\" HAVE_FREEIFADDRS)\ncheck_symbol_exists(pipe           \"${CURL_INCLUDES}\" HAVE_PIPE)\ncheck_symbol_exists(ftruncate      \"${CURL_INCLUDES}\" HAVE_FTRUNCATE)\ncheck_symbol_exists(getprotobyname \"${CURL_INCLUDES}\" HAVE_GETPROTOBYNAME)\ncheck_symbol_exists(getrlimit      \"${CURL_INCLUDES}\" HAVE_GETRLIMIT)\ncheck_symbol_exists(setlocale      \"${CURL_INCLUDES}\" HAVE_SETLOCALE)\ncheck_symbol_exists(setmode        \"${CURL_INCLUDES}\" HAVE_SETMODE)\ncheck_symbol_exists(setrlimit      \"${CURL_INCLUDES}\" HAVE_SETRLIMIT)\ncheck_symbol_exists(fcntl          \"${CURL_INCLUDES}\" HAVE_FCNTL)\ncheck_symbol_exists(ioctl          \"${CURL_INCLUDES}\" HAVE_IOCTL)\ncheck_symbol_exists(setsockopt     \"${CURL_INCLUDES}\" HAVE_SETSOCKOPT)\ncheck_function_exists(mach_absolute_time HAVE_MACH_ABSOLUTE_TIME)\n\n# symbol exists in win32, but function does not.\nif(WIN32)\n  if(ENABLE_INET_PTON)\n    check_function_exists(inet_pton HAVE_INET_PTON)\n    # _WIN32_WINNT_VISTA (0x0600)\n    add_definitions(-D_WIN32_WINNT=0x0600)\n  else()\n    # _WIN32_WINNT_WINXP (0x0501)\n    add_definitions(-D_WIN32_WINNT=0x0501)\n  endif()\nelse()\n  check_function_exists(inet_pton HAVE_INET_PTON)\nendif()\n\ncheck_symbol_exists(fsetxattr \"${CURL_INCLUDES}\" HAVE_FSETXATTR)\nif(HAVE_FSETXATTR)\n  foreach(CURL_TEST HAVE_FSETXATTR_5 HAVE_FSETXATTR_6)\n    curl_internal_test(${CURL_TEST})\n  endforeach()\nendif()\n\n# sigaction and sigsetjmp are special. Use special mechanism for\n# detecting those, but only if previous attempt failed.\nif(HAVE_SIGNAL_H)\n  check_symbol_exists(sigaction \"signal.h\" HAVE_SIGACTION)\nendif()\n\nif(NOT HAVE_SIGSETJMP)\n  if(HAVE_SETJMP_H)\n    check_symbol_exists(sigsetjmp \"setjmp.h\" HAVE_MACRO_SIGSETJMP)\n    if(HAVE_MACRO_SIGSETJMP)\n      set(HAVE_SIGSETJMP 1)\n    endif()\n  endif()\nendif()\n\n# If there is no stricmp(), do not allow LDAP to parse URLs\nif(NOT HAVE_STRICMP)\n  set(HAVE_LDAP_URL_PARSE 1)\nendif()\n\n# Do curl specific tests\nforeach(CURL_TEST\n    HAVE_FCNTL_O_NONBLOCK\n    HAVE_IOCTLSOCKET\n    HAVE_IOCTLSOCKET_CAMEL\n    HAVE_IOCTLSOCKET_CAMEL_FIONBIO\n    HAVE_IOCTLSOCKET_FIONBIO\n    HAVE_IOCTL_FIONBIO\n    HAVE_IOCTL_SIOCGIFADDR\n    HAVE_SETSOCKOPT_SO_NONBLOCK\n    HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n    TIME_WITH_SYS_TIME\n    HAVE_O_NONBLOCK\n    HAVE_GETHOSTBYADDR_R_5\n    HAVE_GETHOSTBYADDR_R_7\n    HAVE_GETHOSTBYADDR_R_8\n    HAVE_GETHOSTBYADDR_R_5_REENTRANT\n    HAVE_GETHOSTBYADDR_R_7_REENTRANT\n    HAVE_GETHOSTBYADDR_R_8_REENTRANT\n    HAVE_GETHOSTBYNAME_R_3\n    HAVE_GETHOSTBYNAME_R_5\n    HAVE_GETHOSTBYNAME_R_6\n    HAVE_GETHOSTBYNAME_R_3_REENTRANT\n    HAVE_GETHOSTBYNAME_R_5_REENTRANT\n    HAVE_GETHOSTBYNAME_R_6_REENTRANT\n    HAVE_IN_ADDR_T\n    HAVE_BOOL_T\n    STDC_HEADERS\n    RETSIGTYPE_TEST\n    HAVE_INET_NTOA_R_DECL\n    HAVE_INET_NTOA_R_DECL_REENTRANT\n    HAVE_GETADDRINFO\n    HAVE_FILE_OFFSET_BITS\n    )\n  curl_internal_test(${CURL_TEST})\nendforeach()\n\nif(HAVE_FILE_OFFSET_BITS)\n  set(_FILE_OFFSET_BITS 64)\n  set(CMAKE_REQUIRED_FLAGS \"-D_FILE_OFFSET_BITS=64\")\nendif()\ncheck_type_size(\"off_t\"  SIZEOF_OFF_T)\n\n# include this header to get the type\nset(CMAKE_REQUIRED_INCLUDES \"${CURL_SOURCE_DIR}/include\")\nset(CMAKE_EXTRA_INCLUDE_FILES \"curl/system.h\")\ncheck_type_size(\"curl_off_t\"  SIZEOF_CURL_OFF_T)\nset(CMAKE_EXTRA_INCLUDE_FILES \"\")\n\nset(CMAKE_REQUIRED_FLAGS)\n\nforeach(CURL_TEST\n    HAVE_GLIBC_STRERROR_R\n    HAVE_POSIX_STRERROR_R\n    )\n  curl_internal_test(${CURL_TEST})\nendforeach()\n\n# Check for reentrant\nforeach(CURL_TEST\n    HAVE_GETHOSTBYADDR_R_5\n    HAVE_GETHOSTBYADDR_R_7\n    HAVE_GETHOSTBYADDR_R_8\n    HAVE_GETHOSTBYNAME_R_3\n    HAVE_GETHOSTBYNAME_R_5\n    HAVE_GETHOSTBYNAME_R_6\n    HAVE_INET_NTOA_R_DECL_REENTRANT)\n  if(NOT ${CURL_TEST})\n    if(${CURL_TEST}_REENTRANT)\n      set(NEED_REENTRANT 1)\n    endif()\n  endif()\nendforeach()\n\nif(NEED_REENTRANT)\n  foreach(CURL_TEST\n      HAVE_GETHOSTBYADDR_R_5\n      HAVE_GETHOSTBYADDR_R_7\n      HAVE_GETHOSTBYADDR_R_8\n      HAVE_GETHOSTBYNAME_R_3\n      HAVE_GETHOSTBYNAME_R_5\n      HAVE_GETHOSTBYNAME_R_6)\n    set(${CURL_TEST} 0)\n    if(${CURL_TEST}_REENTRANT)\n      set(${CURL_TEST} 1)\n    endif()\n  endforeach()\nendif()\n\nif(HAVE_INET_NTOA_R_DECL_REENTRANT)\n  set(HAVE_INET_NTOA_R_DECL 1)\n  set(NEED_REENTRANT 1)\nendif()\n\n# Check clock_gettime(CLOCK_MONOTONIC, x) support\ncurl_internal_test(HAVE_CLOCK_GETTIME_MONOTONIC)\n\n# Check compiler support of __builtin_available()\ncurl_internal_test(HAVE_BUILTIN_AVAILABLE)\n\n# Some other minor tests\n\nif(NOT HAVE_IN_ADDR_T)\n  set(in_addr_t \"unsigned long\")\nendif()\n\n# Fix libz / zlib.h\n\nif(NOT CURL_SPECIAL_LIBZ)\n  if(NOT HAVE_LIBZ)\n    set(HAVE_ZLIB_H 0)\n  endif()\n\n  if(NOT HAVE_ZLIB_H)\n    set(HAVE_LIBZ 0)\n  endif()\nendif()\n\n# Check for nonblocking\nset(HAVE_DISABLED_NONBLOCKING 1)\nif(HAVE_FIONBIO OR\n    HAVE_IOCTLSOCKET OR\n    HAVE_IOCTLSOCKET_CASE OR\n    HAVE_O_NONBLOCK)\n  set(HAVE_DISABLED_NONBLOCKING)\nendif()\n\nif(RETSIGTYPE_TEST)\n  set(RETSIGTYPE void)\nelse()\n  set(RETSIGTYPE int)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCC AND APPLE)\n  include(CheckCCompilerFlag)\n  check_c_compiler_flag(-Wno-long-double HAVE_C_FLAG_Wno_long_double)\n  if(HAVE_C_FLAG_Wno_long_double)\n    # The Mac version of GCC warns about use of long double.  Disable it.\n    get_source_file_property(MPRINTF_COMPILE_FLAGS mprintf.c COMPILE_FLAGS)\n    if(MPRINTF_COMPILE_FLAGS)\n      set(MPRINTF_COMPILE_FLAGS \"${MPRINTF_COMPILE_FLAGS} -Wno-long-double\")\n    else()\n      set(MPRINTF_COMPILE_FLAGS \"-Wno-long-double\")\n    endif()\n    set_source_files_properties(mprintf.c PROPERTIES\n      COMPILE_FLAGS ${MPRINTF_COMPILE_FLAGS})\n  endif()\nendif()\n\n# TODO test which of these headers are required\nif(WIN32)\n  set(CURL_PULL_WS2TCPIP_H ${HAVE_WS2TCPIP_H})\nelse()\n  set(CURL_PULL_SYS_TYPES_H ${HAVE_SYS_TYPES_H})\n  set(CURL_PULL_SYS_SOCKET_H ${HAVE_SYS_SOCKET_H})\n  set(CURL_PULL_SYS_POLL_H ${HAVE_SYS_POLL_H})\nendif()\nset(CURL_PULL_STDINT_H ${HAVE_STDINT_H})\nset(CURL_PULL_INTTYPES_H ${HAVE_INTTYPES_H})\n\ninclude(CMake/OtherTests.cmake)\n\nadd_definitions(-DHAVE_CONFIG_H)\n\n# For Windows, all compilers used by CMake should support large files\nif(WIN32)\n  set(USE_WIN32_LARGE_FILES ON)\n\n  # Use the manifest embedded in the Windows Resource\n  set(CMAKE_RC_FLAGS \"${CMAKE_RC_FLAGS} -DCURL_EMBED_MANIFEST\")\nendif()\n\nif(MSVC)\n  # Disable default manifest added by CMake\n  set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\n\n  add_definitions(-D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE)\n  if(CMAKE_C_FLAGS MATCHES \"/W[0-4]\")\n    string(REGEX REPLACE \"/W[0-4]\" \"/W4\" CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n  else()\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /W4\")\n  endif()\nendif()\n\nif(CURL_WERROR)\n  if(MSVC_VERSION)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /WX\")\n  else()\n    # this assumes clang or gcc style options\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Werror\")\n  endif()\nendif()\n\n# Ugly (but functional) way to include \"Makefile.inc\" by transforming it (= regenerate it).\nfunction(TRANSFORM_MAKEFILE_INC INPUT_FILE OUTPUT_FILE)\n  file(READ ${INPUT_FILE} MAKEFILE_INC_TEXT)\n  string(REPLACE \"$(top_srcdir)\"   \"\\${CURL_SOURCE_DIR}\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})\n  string(REPLACE \"$(top_builddir)\" \"\\${CURL_BINARY_DIR}\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})\n\n  string(REGEX REPLACE \"\\\\\\\\\\n\" \"!\u03c0!\u03b1!\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})\n  string(REGEX REPLACE \"([a-zA-Z_][a-zA-Z0-9_]*)[\\t ]*=[\\t ]*([^\\n]*)\" \"SET(\\\\1 \\\\2)\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})\n  string(REPLACE \"!\u03c0!\u03b1!\" \"\\n\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})\n\n  string(REGEX REPLACE \"\\\\$\\\\(([a-zA-Z_][a-zA-Z0-9_]*)\\\\)\" \"\\${\\\\1}\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})    # Replace $() with ${}\n  string(REGEX REPLACE \"@([a-zA-Z_][a-zA-Z0-9_]*)@\" \"\\${\\\\1}\" MAKEFILE_INC_TEXT ${MAKEFILE_INC_TEXT})    # Replace @@ with ${}, even if that may not be read by CMake scripts.\n  file(WRITE ${OUTPUT_FILE} ${MAKEFILE_INC_TEXT})\n\nendfunction()\n\nif(0) # This code not needed for building within CMake.\ninclude(GNUInstallDirs)\n\nset(CURL_INSTALL_CMAKE_DIR ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME})\nset(TARGETS_EXPORT_NAME \"${PROJECT_NAME}Targets\")\nset(generated_dir \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\nset(project_config \"${generated_dir}/${PROJECT_NAME}Config.cmake\")\nset(version_config \"${generated_dir}/${PROJECT_NAME}ConfigVersion.cmake\")\nendif()\n\nif(USE_MANUAL)\n  add_subdirectory(docs)\nendif()\n\nadd_subdirectory(lib)\n\nif(BUILD_CURL_EXE)\n  add_subdirectory(src)\nendif()\n\n#-----------------------------------------------------------------------------\n# CMake-specific curl code.\nadd_executable(curltest curltest.c)\ntarget_link_libraries(curltest cmcurl)\n\nif(BUILD_TESTING AND CMAKE_CURL_TEST_URL)\n  add_test(curl curltest ${CMAKE_CURL_TEST_URL})\nendif()\n\ninstall(FILES COPYING DESTINATION ${CMAKE_DOC_DIR}/cmcurl)\n#-----------------------------------------------------------------------------\n\nif(0) # This code not needed for building within CMake.\ninclude(CTest)\nif(BUILD_TESTING)\n  add_subdirectory(tests)\nendif()\n\n# Helper to populate a list (_items) with a label when conditions (the remaining\n# args) are satisfied\nfunction(_add_if label)\n  # TODO need to disable policy CMP0054 (CMake 3.1) to allow this indirection\n  if(${ARGN})\n    set(_items ${_items} \"${label}\" PARENT_SCOPE)\n  endif()\nendfunction()\n\n# Clear list and try to detect available features\nset(_items)\n_add_if(\"WinSSL\"        SSL_ENABLED AND USE_WINDOWS_SSPI)\n_add_if(\"OpenSSL\"       SSL_ENABLED AND USE_OPENSSL)\n_add_if(\"DarwinSSL\"     SSL_ENABLED AND USE_DARWINSSL)\n_add_if(\"mbedTLS\"       SSL_ENABLED AND USE_MBEDTLS)\n_add_if(\"IPv6\"          ENABLE_IPV6)\n_add_if(\"unix-sockets\"  USE_UNIX_SOCKETS)\n_add_if(\"libz\"          HAVE_LIBZ)\n_add_if(\"AsynchDNS\"     USE_ARES OR USE_THREADS_POSIX OR USE_THREADS_WIN32)\n_add_if(\"IDN\"           HAVE_LIBIDN2)\n_add_if(\"Largefile\"     (CURL_SIZEOF_CURL_OFF_T GREATER 4) AND\n                        ((SIZEOF_OFF_T GREATER 4) OR USE_WIN32_LARGE_FILES))\n# TODO SSP1 (WinSSL) check is missing\n_add_if(\"SSPI\"          USE_WINDOWS_SSPI)\n_add_if(\"GSS-API\"       HAVE_GSSAPI)\n# TODO SSP1 missing for SPNEGO\n_add_if(\"SPNEGO\"        NOT CURL_DISABLE_CRYPTO_AUTH AND\n                        (HAVE_GSSAPI OR USE_WINDOWS_SSPI))\n_add_if(\"Kerberos\"      NOT CURL_DISABLE_CRYPTO_AUTH AND\n                        (HAVE_GSSAPI OR USE_WINDOWS_SSPI))\n# NTLM support requires crypto function adaptions from various SSL libs\n# TODO alternative SSL libs tests for SSP1, GNUTLS, NSS\nif(NOT CURL_DISABLE_CRYPTO_AUTH AND (USE_OPENSSL OR USE_WINDOWS_SSPI OR USE_DARWINSSL OR USE_MBEDTLS))\n  _add_if(\"NTLM\"        1)\n  # TODO missing option (autoconf: --enable-ntlm-wb)\n  _add_if(\"NTLM_WB\"     NOT CURL_DISABLE_HTTP AND NTLM_WB_ENABLED)\nendif()\n# TODO missing option (--enable-tls-srp), depends on GNUTLS_SRP/OPENSSL_SRP\n_add_if(\"TLS-SRP\"       USE_TLS_SRP)\n# TODO option --with-nghttp2 tests for nghttp2 lib and nghttp2/nghttp2.h header\n_add_if(\"HTTP2\"         USE_NGHTTP2)\nstring(REPLACE \";\" \" \" SUPPORT_FEATURES \"${_items}\")\nmessage(STATUS \"Enabled features: ${SUPPORT_FEATURES}\")\n\n# Clear list and try to detect available protocols\nset(_items)\n_add_if(\"HTTP\"          NOT CURL_DISABLE_HTTP)\n_add_if(\"HTTPS\"         NOT CURL_DISABLE_HTTP AND SSL_ENABLED)\n_add_if(\"FTP\"           NOT CURL_DISABLE_FTP)\n_add_if(\"FTPS\"          NOT CURL_DISABLE_FTP AND SSL_ENABLED)\n_add_if(\"FILE\"          NOT CURL_DISABLE_FILE)\n_add_if(\"TELNET\"        NOT CURL_DISABLE_TELNET)\n_add_if(\"LDAP\"          NOT CURL_DISABLE_LDAP)\n# CURL_DISABLE_LDAP implies CURL_DISABLE_LDAPS\n# TODO check HAVE_LDAP_SSL (in autoconf this is enabled with --enable-ldaps)\n_add_if(\"LDAPS\"         NOT CURL_DISABLE_LDAPS AND\n                        ((USE_OPENLDAP AND SSL_ENABLED) OR\n                        (NOT USE_OPENLDAP AND HAVE_LDAP_SSL)))\n_add_if(\"DICT\"          NOT CURL_DISABLE_DICT)\n_add_if(\"TFTP\"          NOT CURL_DISABLE_TFTP)\n_add_if(\"GOPHER\"        NOT CURL_DISABLE_GOPHER)\n_add_if(\"POP3\"          NOT CURL_DISABLE_POP3)\n_add_if(\"POP3S\"         NOT CURL_DISABLE_POP3 AND SSL_ENABLED)\n_add_if(\"IMAP\"          NOT CURL_DISABLE_IMAP)\n_add_if(\"IMAPS\"         NOT CURL_DISABLE_IMAP AND SSL_ENABLED)\n_add_if(\"SMTP\"          NOT CURL_DISABLE_SMTP)\n_add_if(\"SMTPS\"         NOT CURL_DISABLE_SMTP AND SSL_ENABLED)\n_add_if(\"SCP\"           USE_LIBSSH2)\n_add_if(\"SFTP\"          USE_LIBSSH2)\n_add_if(\"RTSP\"          NOT CURL_DISABLE_RTSP)\n_add_if(\"RTMP\"          USE_LIBRTMP)\nlist(SORT _items)\nstring(REPLACE \";\" \" \" SUPPORT_PROTOCOLS \"${_items}\")\nmessage(STATUS \"Enabled protocols: ${SUPPORT_PROTOCOLS}\")\n\n# curl-config needs the following options to be set.\nset(CC                      \"${CMAKE_C_COMPILER}\")\n# TODO probably put a -D... options here?\nset(CONFIGURE_OPTIONS       \"\")\n# TODO when to set \"-DCURL_STATICLIB\" for CPPFLAG_CURL_STATICLIB?\nset(CPPFLAG_CURL_STATICLIB  \"\")\nset(CURLVERSION             \"${CURL_VERSION}\")\nif(BUILD_SHARED_LIBS)\n  set(ENABLE_SHARED         \"yes\")\n  set(ENABLE_STATIC         \"no\")\nelse()\n  set(ENABLE_SHARED         \"no\")\n  set(ENABLE_STATIC         \"yes\")\nendif()\nset(exec_prefix             \"\\${prefix}\")\nset(includedir              \"\\${prefix}/include\")\nset(LDFLAGS                 \"${CMAKE_SHARED_LINKER_FLAGS}\")\nset(LIBCURL_LIBS            \"\")\nset(libdir                  \"${CMAKE_INSTALL_PREFIX}/lib\")\nforeach(_lib ${CMAKE_C_IMPLICIT_LINK_LIBRARIES} ${CURL_LIBS})\n  if(_lib MATCHES \".*/.*\" OR _lib MATCHES \"^-\")\n    set(LIBCURL_LIBS          \"${LIBCURL_LIBS} ${_lib}\")\n  else()\n    set(LIBCURL_LIBS          \"${LIBCURL_LIBS} -l${_lib}\")\n  endif()\nendforeach()\n# \"a\" (Linux) or \"lib\" (Windows)\nstring(REPLACE \".\" \"\" libext \"${CMAKE_STATIC_LIBRARY_SUFFIX}\")\nset(prefix                  \"${CMAKE_INSTALL_PREFIX}\")\n# Set this to \"yes\" to append all libraries on which -lcurl is dependent\nset(REQUIRE_LIB_DEPS        \"no\")\n# SUPPORT_FEATURES\n# SUPPORT_PROTOCOLS\nset(VERSIONNUM              \"${CURL_VERSION_NUM}\")\n\n# Finally generate a \"curl-config\" matching this config\n# Use:\n# * ENABLE_SHARED\n# * ENABLE_STATIC\nconfigure_file(\"${CURL_SOURCE_DIR}/curl-config.in\"\n               \"${CURL_BINARY_DIR}/curl-config\" @ONLY)\ninstall(FILES \"${CURL_BINARY_DIR}/curl-config\"\n        DESTINATION ${CMAKE_INSTALL_BINDIR}\n        PERMISSIONS\n          OWNER_READ OWNER_WRITE OWNER_EXECUTE\n          GROUP_READ GROUP_EXECUTE\n          WORLD_READ WORLD_EXECUTE)\n\n# Finally generate a pkg-config file matching this config\nconfigure_file(\"${CURL_SOURCE_DIR}/libcurl.pc.in\"\n               \"${CURL_BINARY_DIR}/libcurl.pc\" @ONLY)\ninstall(FILES \"${CURL_BINARY_DIR}/libcurl.pc\"\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n\n# install headers\ninstall(DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/include/curl\"\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n    FILES_MATCHING PATTERN \"*.h\")\n\ninclude(CMakePackageConfigHelpers)\nwrite_basic_package_version_file(\n    \"${version_config}\"\n    VERSION ${CURL_VERSION}\n    COMPATIBILITY SameMajorVersion\n)\n\n# Use:\n# * TARGETS_EXPORT_NAME\n# * PROJECT_NAME\nconfigure_package_config_file(CMake/curl-config.cmake.in\n        \"${project_config}\"\n        INSTALL_DESTINATION ${CURL_INSTALL_CMAKE_DIR}\n)\n\ninstall(\n        EXPORT \"${TARGETS_EXPORT_NAME}\"\n        NAMESPACE \"${PROJECT_NAME}::\"\n        DESTINATION ${CURL_INSTALL_CMAKE_DIR}\n)\n\ninstall(\n        FILES ${version_config} ${project_config}\n        DESTINATION ${CURL_INSTALL_CMAKE_DIR}\n)\n\n# Workaround for MSVS10 to avoid the Dialog Hell\n# FIXME: This could be removed with future version of CMake.\nif(MSVC_VERSION EQUAL 1600)\n  set(CURL_SLN_FILENAME \"${CMAKE_CURRENT_BINARY_DIR}/CURL.sln\")\n  if(EXISTS \"${CURL_SLN_FILENAME}\")\n    file(APPEND \"${CURL_SLN_FILENAME}\" \"\\n# This should be regenerated!\\n\")\n  endif()\nendif()\n\nif(NOT TARGET uninstall)\n  configure_file(\n      ${CMAKE_CURRENT_SOURCE_DIR}/CMake/cmake_uninstall.cmake.in\n      ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake\n      IMMEDIATE @ONLY)\n\n  add_custom_target(uninstall\n      COMMAND ${CMAKE_COMMAND} -P\n      ${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake)\nendif()\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/kwsys/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#  include \"Configure.hxx.in\"\n#  include \"DynamicLoader.hxx.in\"\n#endif\n\n// This file actually contains several different implementations:\n// * NOOP for environments without dynamic libs\n// * HP machines which uses shl_load\n// * Mac OS X 10.2.x and earlier which uses NSLinkModule\n// * Windows which uses LoadLibrary\n// * BeOS / Haiku\n// * FreeMiNT for Atari\n// * Default implementation for *NIX systems (including Mac OS X 10.3 and\n//   later) which use dlopen\n//\n// Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n#if !KWSYS_SUPPORTS_SHARED_LIBS\n// Implementation for environments without dynamic libs\n#  include <string.h> // for strerror()\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return 0;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return \"General error\";\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__hpux)\n// Implementation for HPUX machines\n#  include <dl.h>\n#  include <errno.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if (errno == ENOEXEC || errno == ENOSYM || errno == EINVAL) {\n    return strerror(errno);\n  }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n// Implementation for Mac OS X 10.2.x and earlier\n#  include <mach-o/dyld.h>\n#  include <string.h> // for strlen\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n                                 NSLINKMODULE_OPTION_BINDNOW |\n                                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n// Implementation for Windows win32 code but not cygwin\n#  include <windows.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length + 1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete[] wchars;\n  return lh;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void* result;\n#  if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  std::string ssym = '_' + sym;\n  const char* rsym = ssym.c_str();\n#  else\n  const char* rsym = sym.c_str();\n#  endif\n  result = (void*)GetProcAddress(lib, rsym);\n// Hack to cast pointer-to-data to pointer-to-function.\n#  ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#  else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#  endif\n}\n\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf = NULL;\n\n  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n                NULL, GetLastError(),\n                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n                (LPTSTR)&lpMsgBuf, 0, NULL);\n\n  if (!lpMsgBuf) {\n    return NULL;\n  }\n\n  static char* str = 0;\n  delete[] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf) + 1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree(lpMsgBuf);\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__BEOS__)\n// Implementation for BeOS / Haiku\n#  include <string.h> // for strerror()\n\n#  include <be/kernel/image.h>\n#  include <be/support/Errors.h>\n\nnamespace KWSYS_NAMESPACE {\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n    }\n  }\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  const char* retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__MINT__)\n// Implementation for FreeMiNT on Atari\n#  define _GNU_SOURCE /* for program_invocation_name */\n#  include <dld.h>\n#  include <errno.h>\n#  include <malloc.h>\n#  include <string.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#else\n// Default implementation for *NIX systems (including Mac OS X 10.3 and\n// later) which use dlopen\n#  include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/kwsys/DynamicLoader.hxx.in": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#ifndef @KWSYS_NAMESPACE@_DynamicLoader_hxx\n#define @KWSYS_NAMESPACE@_DynamicLoader_hxx\n\n#include <@KWSYS_NAMESPACE@/Configure.hxx>\n\n#include <string>\n\n#if defined(__hpux)\n#  include <dl.h>\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n#  include <windows.h>\n#elif defined(__APPLE__)\n#  include <AvailabilityMacros.h>\n#  if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#    include <mach-o/dyld.h>\n#  endif\n#elif defined(__BEOS__)\n#  include <be/kernel/image.h>\n#endif\n\nnamespace @KWSYS_NAMESPACE@ {\n/** \\class DynamicLoader\n * \\brief Portable loading of dynamic libraries or dll's.\n *\n * DynamicLoader provides a portable interface to loading dynamic\n * libraries or dll's into a process.\n *\n * Directory currently works with Windows, Apple, HP-UX and Unix (POSIX)\n * operating systems\n *\n * \\warning dlopen on *nix system works the following way:\n * If filename contains a slash (\"/\"), then it is interpreted as a (relative\n * or absolute) pathname.  Otherwise, the dynamic linker searches for the\n * library as follows : see ld.so(8) for further details):\n * Whereas this distinction does not exist on Win32. Therefore ideally you\n * should be doing full path to guarantee to have a consistent way of dealing\n * with dynamic loading of shared library.\n *\n * \\warning the Cygwin implementation do not use the Win32 HMODULE. Put extra\n * condition so that we can include the correct declaration (POSIX)\n */\n\nclass @KWSYS_NAMESPACE@_EXPORT DynamicLoader\n{\npublic:\n// Ugly stuff for library handles\n// They are different on several different OS's\n#if defined(__hpux)\n  typedef shl_t LibraryHandle;\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  typedef HMODULE LibraryHandle;\n#elif defined(__APPLE__)\n#  if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n  typedef NSModule LibraryHandle;\n#  else\n  typedef void* LibraryHandle;\n#  endif\n#elif defined(__BEOS__)\n  typedef image_id LibraryHandle;\n#else // POSIX\n  typedef void* LibraryHandle;\n#endif\n\n  // Return type from DynamicLoader::GetSymbolAddress.\n  typedef void (*SymbolPointer)();\n\n  /** Load a dynamic library into the current process.\n   * The returned LibraryHandle can be used to access the symbols in the\n   * library. */\n  static LibraryHandle OpenLibrary(const std::string&);\n\n  /** Attempt to detach a dynamic library from the\n   * process.  A value of true is returned if it is successful. */\n  static int CloseLibrary(LibraryHandle);\n\n  /** Find the address of the symbol in the given library. */\n  static SymbolPointer GetSymbolAddress(LibraryHandle, const std::string&);\n\n  /** Return the default module prefix for the current platform.  */\n  static const char* LibPrefix() { return \"@KWSYS_DynamicLoader_PREFIX@\"; }\n\n  /** Return the default module suffix for the current platform.  */\n  static const char* LibExtension() { return \"@KWSYS_DynamicLoader_SUFFIX@\"; }\n\n  /** Return the last error produced from a calls made on this class. */\n  static const char* LastError();\n}; // End Class: DynamicLoader\n\n} // namespace @KWSYS_NAMESPACE@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/kwsys/testDynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#include \"kwsysPrivate.h\"\n\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#if defined(__BEOS__) || defined(__HAIKU__)\n#  include <be/kernel/OS.h> /* disable_debugger() API. */\n#endif\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#  include \"DynamicLoader.hxx.in\"\n#endif\n\n#include <iostream>\n#include <string>\n\n// Include with <> instead of \"\" to avoid getting any in-source copy\n// left on disk.\n#include <testSystemTools.h>\n\nstatic std::string GetLibName(const char* lname)\n{\n  // Construct proper name of lib\n  std::string slname;\n  slname = EXECUTABLE_OUTPUT_PATH;\n#ifdef CMAKE_INTDIR\n  slname += \"/\";\n  slname += CMAKE_INTDIR;\n#endif\n  slname += \"/\";\n  slname += kwsys::DynamicLoader::LibPrefix();\n  slname += lname;\n  slname += kwsys::DynamicLoader::LibExtension();\n\n  return slname;\n}\n\n/* libname = Library name (proper prefix, proper extension)\n * System  = symbol to lookup in libname\n * r1: should OpenLibrary succeed ?\n * r2: should GetSymbolAddress succeed ?\n * r3: should CloseLibrary succeed ?\n */\nstatic int TestDynamicLoader(const char* libname, const char* symbol, int r1,\n                             int r2, int r3)\n{\n  std::cerr << \"Testing: \" << libname << std::endl;\n  kwsys::DynamicLoader::LibraryHandle l =\n    kwsys::DynamicLoader::OpenLibrary(libname);\n  // If result is incompatible with expectation just fails (xor):\n  if ((r1 && !l) || (!r1 && l)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n  kwsys::DynamicLoader::SymbolPointer f =\n    kwsys::DynamicLoader::GetSymbolAddress(l, symbol);\n  if ((r2 && !f) || (!r2 && f)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n#ifndef __APPLE__\n  int s = kwsys::DynamicLoader::CloseLibrary(l);\n  if ((r3 && !s) || (!r3 && s)) {\n    std::cerr << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n  }\n#else\n  (void)r3;\n#endif\n  return 0;\n}\n\nint testDynamicLoader(int argc, char* argv[])\n{\n#if defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n#elif defined(__BEOS__) || defined(__HAIKU__)\n  disable_debugger(1);\n#endif\n  int res = 0;\n  if (argc == 3) {\n    // User specify a libname and symbol to check.\n    res = TestDynamicLoader(argv[1], argv[2], 1, 1, 1);\n    return res;\n  }\n\n// dlopen() on Syllable before 11/22/2007 doesn't return 0 on error\n#ifndef __SYLLABLE__\n  // Make sure that inexistent lib is giving correct result\n  res += TestDynamicLoader(\"azerty_\", \"foo_bar\", 0, 0, 0);\n  // Make sure that random binary file cannot be assimilated as dylib\n  res += TestDynamicLoader(TEST_SYSTEMTOOLS_SOURCE_DIR \"/testSystemTools.bin\",\n                           \"wp\", 0, 0, 0);\n#endif\n\n#ifdef __linux__\n  // This one is actually fun to test, since dlopen is by default\n  // loaded...wonder why :)\n  res += TestDynamicLoader(\"foobar.lib\", \"dlopen\", 0, 1, 0);\n  res += TestDynamicLoader(\"libdl.so\", \"dlopen\", 1, 1, 1);\n  res += TestDynamicLoader(\"libdl.so\", \"TestDynamicLoader\", 1, 0, 1);\n#endif\n  // Now try on the generated library\n  std::string libname = GetLibName(KWSYS_NAMESPACE_STRING \"TestDynload\");\n  res += TestDynamicLoader(libname.c_str(), \"dummy\", 1, 0, 1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderSymbolPointer\",\n                           1, 1, 1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderSymbolPointer\",\n                           1, 0, 1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderData\", 1, 1, 1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderData\", 1, 0, 1);\n\n  return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/KDE3Macros.cmake": "# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n# file Copyright.txt or https://cmake.org/licensing for details.\n\n#\n\n# See FindKDE3.cmake for documentation.\n#\n# this file contains the following macros:\n# KDE3_ADD_DCOP_SKELS\n# KDE3_ADD_DCOP_STUBS\n# KDE3_ADD_MOC_FILES\n# KDE3_ADD_UI_FILES\n# KDE3_ADD_KCFG_FILES\n# KDE3_AUTOMOC\n# KDE3_INSTALL_LIBTOOL_FILE\n# KDE3_CREATE_FINAL_FILE\n# KDE3_ADD_KPART\n# KDE3_ADD_KDEINIT_EXECUTABLE\n# KDE3_ADD_EXECUTABLE\n\n\n#neundorf@kde.org\n\ninclude(AddFileDependencies)\n\n#create the kidl and skeletion file for dcop stuff\n#usage: KDE_ADD_COP_SKELS(foo_SRCS ${dcop_headers})\nmacro(KDE3_ADD_DCOP_SKELS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_skel ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_skel.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n         set(HAVE_${_basename}_KIDL_RULE ON)\n\n          add_custom_command(OUTPUT ${_kidl}\n          COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n          ARGS ${_tmp_FILE} > ${_kidl}\n          DEPENDS ${_tmp_FILE}\n         )\n\n       endif ()\n\n      if (NOT HAVE_${_basename}_SKEL_RULE)\n        set(HAVE_${_basename}_SKEL_RULE ON)\n\n       add_custom_command(OUTPUT ${_skel}\n          COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n          ARGS --c++-suffix cpp --no-signals --no-stub ${_kidl}\n          DEPENDS ${_kidl}\n          )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_skel})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_DCOP_STUBS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_stub_CPP ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_stub.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n        set(HAVE_${_basename}_KIDL_RULE ON)\n\n\n        add_custom_command(OUTPUT ${_kidl}\n           COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n           ARGS ${_tmp_FILE} > ${_kidl}\n           DEPENDS ${_tmp_FILE}\n           )\n\n      endif ()\n\n\n      if (NOT HAVE_${_basename}_STUB_RULE)\n        set(HAVE_${_basename}_STUB_RULE ON)\n\n        add_custom_command(OUTPUT ${_stub_CPP}\n           COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n           ARGS --c++-suffix cpp --no-signals --no-skel ${_kidl}\n           DEPENDS ${_kidl}\n         )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_stub_CPP})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_KCFG_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      file(READ ${_tmp_FILE} _contents)\n      string(REGEX REPLACE \"^(.*\\n)?File=([^\\n]+)\\n.*$\" \"\\\\2\"  _kcfg_FILE \"${_contents}\")\n\n      set(_src_FILE    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_header_FILE ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n\n      add_custom_command(OUTPUT ${_src_FILE}\n         COMMAND ${KDE3_KCFGC_EXECUTABLE}\n         ARGS ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} ${_tmp_FILE}\n         DEPENDS ${_tmp_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} )\n\n      set(${_sources} ${${_sources}} ${_src_FILE})\n\n   endforeach ()\n\nendmacro()\n\n\n#create the moc files and add them to the list of sources\n#usage: KDE_ADD_MOC_FILES(foo_SRCS ${moc_headers})\nmacro(KDE3_ADD_MOC_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_tmp_FILE} -o ${_moc}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      set(${_sources} ${${_sources}} ${_moc})\n\n   endforeach ()\nendmacro()\n\n\nget_filename_component( KDE3_MODULE_DIR  ${CMAKE_CURRENT_LIST_FILE} PATH)\n\n#create the implementation files from the ui files and add them to the list of sources\n#usage: KDE_ADD_UI_FILES(foo_SRCS ${ui_files})\nmacro(KDE3_ADD_UI_FILES _sources )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n      set(_src ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_header}\n         COMMAND ${QT_UIC_EXECUTABLE}\n         ARGS  -L ${KDE3_LIB_DIR}/kde3/plugins/designer -nounload -o ${_header} ${CMAKE_CURRENT_SOURCE_DIR}/${_current_FILE}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      add_custom_command(OUTPUT ${_src}\n         COMMAND ${CMAKE_COMMAND}\n         ARGS\n         -DKDE_UIC_PLUGIN_DIR:FILEPATH=${KDE3_LIB_DIR}/kde3/plugins/designer\n         -DKDE_UIC_EXECUTABLE:FILEPATH=${QT_UIC_EXECUTABLE}\n         -DKDE_UIC_FILE:FILEPATH=${_tmp_FILE}\n         -DKDE_UIC_CPP_FILE:FILEPATH=${_src}\n         -DKDE_UIC_H_FILE:FILEPATH=${_header}\n         -P ${KDE3_MODULE_DIR}/kde3uic.cmake\n         DEPENDS ${_header}\n      )\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_header} -o ${_moc}\n         DEPENDS ${_header}\n      )\n\n      set(${_sources} ${${_sources}} ${_src} ${_moc} )\n\n   endforeach ()\nendmacro()\n\n\nmacro(KDE3_AUTOMOC)\n   set(_matching_FILES )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_abs_FILE ${_current_FILE} ABSOLUTE)\n\n      # if \"SKIP_AUTOMOC\" is set to true, we will not handle this file here.\n      # here. this is required to make bouic work correctly:\n      # we need to add generated .cpp files to the sources (to compile them),\n      # but we cannot let automoc handle them, as the .cpp files don't exist yet when\n      # cmake is run for the very first time on them -> however the .cpp files might\n      # exist at a later run. at that time we need to skip them, so that we don't add two\n      # different rules for the same moc file\n      get_source_file_property(_skip ${_abs_FILE} SKIP_AUTOMOC)\n\n      if (EXISTS ${_abs_FILE} AND NOT _skip)\n\n         file(STRINGS ${_abs_FILE} _match REGEX \"#include +[^ ]+\\\\.moc[\\\">]\")\n\n         get_filename_component(_abs_PATH ${_abs_FILE} PATH)\n\n         foreach (_current_MOC_INC IN LISTS _match)\n            string(REGEX MATCH \"[^ <\\\"]+\\\\.moc\" _current_MOC \"${_current_MOC_INC}\")\n\n            get_filename_component(_basename ${_current_MOC} NAME_WE)\n#            set(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)\n            set(_header ${_abs_PATH}/${_basename}.h)\n            set(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})\n\n            add_custom_command(OUTPUT ${_moc}\n               COMMAND ${QT_MOC_EXECUTABLE}\n               ARGS ${_header} -o ${_moc}\n               DEPENDS ${_header}\n            )\n\n            ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})\n\n         endforeach ()\n         unset(_match)\n         unset(_header)\n         unset(_moc)\n      endif ()\n   endforeach ()\nendmacro()\n\n# only used internally by KDE3_INSTALL_ICONS\nmacro (_KDE3_ADD_ICON_INSTALL_RULE _install_SCRIPT _install_PATH _group _orig_NAME _install_NAME)\n\n   # if the string doesn't match the pattern, the result is the full string, so all three have the same content\n   if (NOT ${_group} STREQUAL ${_install_NAME} )\n      set(_icon_GROUP \"actions\")\n\n      if (${_group} STREQUAL \"mime\")\n         set(_icon_GROUP  \"mimetypes\")\n      endif ()\n\n      if (${_group} STREQUAL \"filesys\")\n         set(_icon_GROUP  \"filesystems\")\n      endif ()\n\n      if (${_group} STREQUAL \"device\")\n         set(_icon_GROUP  \"devices\")\n      endif ()\n\n      if (${_group} STREQUAL \"app\")\n         set(_icon_GROUP  \"apps\")\n      endif ()\n\n      if (${_group} STREQUAL \"action\")\n         set(_icon_GROUP  \"actions\")\n      endif ()\n\n#      message(STATUS \"icon: ${_current_ICON} size: ${_size} group: ${_group} name: ${_name}\" )\n   install(FILES ${_orig_NAME} DESTINATION ${_install_PATH}/${_icon_GROUP}/ RENAME ${_install_NAME} )\n   endif ()\n\nendmacro ()\n\n\nmacro (KDE3_INSTALL_ICONS _theme )\n   set(_defaultpath \"${CMAKE_INSTALL_PREFIX}/share/icons\")\n   # first the png icons\n   file(GLOB _icons *.png)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\1\" _size  \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\2\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\3\" _name  \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n         ${_defaultpath}/${_theme}/${_size}x${_size}\n         ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\n   # and now the svg icons\n   file(GLOB _icons *.svgz)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\1\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\2\" _name \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n                                 ${_defaultpath}/${_theme}/scalable\n                                 ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\nendmacro ()\n\nmacro(KDE3_INSTALL_LIBTOOL_FILE _target)\n   get_target_property(_target_location ${_target} LOCATION)\n\n   get_filename_component(_laname ${_target_location} NAME_WE)\n   get_filename_component(_soname ${_target_location} NAME)\n   set(_laname ${CMAKE_CURRENT_BINARY_DIR}/${_laname}.la)\n\n   file(WRITE ${_laname} \"# ${_laname} - a libtool library file, generated by cmake \\n\")\n   file(APPEND ${_laname} \"# The name that we can dlopen(3).\\n\")\n   file(APPEND ${_laname} \"dlname='${_soname}'\\n\")\n   file(APPEND ${_laname} \"# Names of this library\\n\")\n   if(CYGWIN)\n     file(APPEND ${_laname} \"library_names='${_soname}'\\n\")\n   else()\n     file(APPEND ${_laname} \"library_names='${_soname} ${_soname} ${_soname}'\\n\")\n   endif()\n   file(APPEND ${_laname} \"# The name of the static archive\\n\")\n   file(APPEND ${_laname} \"old_library=''\\n\")\n   file(APPEND ${_laname} \"# Libraries that this one depends upon.\\n\")\n   file(APPEND ${_laname} \"dependency_libs=''\\n\")\n#   file(APPEND ${_laname} \"dependency_libs='${${_target}_LIB_DEPENDS}'\\n\")\n   file(APPEND ${_laname} \"# Version information.\\ncurrent=0\\nage=0\\nrevision=0\\n\")\n   file(APPEND ${_laname} \"# Is this an already installed library?\\ninstalled=yes\\n\")\n   file(APPEND ${_laname} \"# Should we warn about portability when linking against -modules?\\nshouldnotlink=yes\\n\")\n   file(APPEND ${_laname} \"# Files to dlopen/dlpreopen\\ndlopen=''\\ndlpreopen=''\\n\")\n   file(APPEND ${_laname} \"# Directory that this library needs to be installed in:\\n\")\n   file(APPEND ${_laname} \"libdir='${CMAKE_INSTALL_PREFIX}/lib/kde3'\\n\")\n\n   install_files(${KDE3_LIBTOOL_DIR} FILES ${_laname})\nendmacro()\n\n\nmacro(KDE3_CREATE_FINAL_FILE _filename)\n   file(WRITE ${_filename} \"//autogenerated file\\n\")\n   foreach (_current_FILE ${ARGN})\n      file(APPEND ${_filename} \"#include \\\"${_current_FILE}\\\"\\n\")\n   endforeach ()\n\nendmacro()\n\n\n# option(KDE3_ENABLE_FINAL \"Enable final all-in-one compilation\")\noption(KDE3_BUILD_TESTS  \"Build the tests\")\n\n\nmacro(KDE3_ADD_KPART _target_NAME _with_PREFIX)\n#is the first argument is \"WITH_PREFIX\" then keep the standard \"lib\" prefix, otherwise SET the prefix empty\n   if (${_with_PREFIX} STREQUAL \"WITH_PREFIX\")\n      set(_first_SRC)\n   else ()\n      set(_first_SRC ${_with_PREFIX})\n   endif ()\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${_first_SRC} ${ARGN})\n#       add_library(${_target_NAME} MODULE  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(${_target_NAME} MODULE ${_first_SRC} ${ARGN})\n#    endif ()\n\n   if(_first_SRC)\n      set_target_properties(${_target_NAME} PROPERTIES PREFIX \"\")\n   endif()\n\n   KDE3_INSTALL_LIBTOOL_FILE(${_target_NAME})\n\nendmacro()\n\n\nmacro(KDE3_ADD_KDEINIT_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_library(kdeinit_${_target_NAME} SHARED  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(kdeinit_${_target_NAME} SHARED ${ARGN} )\n#    endif ()\n\n   configure_file(${KDE3_MODULE_DIR}/kde3init_dummy.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp)\n\n   add_executable( ${_target_NAME} ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp )\n   target_link_libraries( ${_target_NAME} kdeinit_${_target_NAME} )\n\nendmacro()\n\n\nmacro(KDE3_ADD_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_executable(${_target_NAME} ${_target_NAME}_final.cpp)\n#    else ()\n   add_executable(${_target_NAME} ${ARGN} )\n#    endif ()\n\nendmacro()\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/Platform/Linux-Intel.cmake": "# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n# file Copyright.txt or https://cmake.org/licensing for details.\n\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_INTEL)\n  return()\nendif()\nset(__LINUX_COMPILER_INTEL 1)\n\nif(NOT XIAR)\n  set(_intel_xiar_hints)\n  foreach(lang C CXX Fortran)\n    if(IS_ABSOLUTE \"${CMAKE_${lang}_COMPILER}\")\n      get_filename_component(_hint \"${CMAKE_${lang}_COMPILER}\" PATH)\n      list(APPEND _intel_xiar_hints ${_hint})\n    endif()\n  endforeach()\n  find_program(XIAR NAMES xiar HINTS ${_intel_xiar_hints})\n  mark_as_advanced(XIAR)\nendif()\n\nmacro(__linux_compiler_intel lang)\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIC \"-fPIC\")\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIE \"-fPIE\")\n  set(CMAKE_SHARED_LIBRARY_${lang}_FLAGS \"-fPIC\")\n  set(CMAKE_SHARED_LIBRARY_CREATE_${lang}_FLAGS \"-shared\")\n\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\n\n  set(CMAKE_${lang}_LINKER_WRAPPER_FLAG \"-Wl,\")\n  set(CMAKE_${lang}_LINKER_WRAPPER_FLAG_SEP \",\")\n\n  set(_CMAKE_${lang}_IPO_SUPPORTED_BY_CMAKE YES)\n\n  if(XIAR)\n    # INTERPROCEDURAL_OPTIMIZATION\n    set(CMAKE_${lang}_COMPILE_OPTIONS_IPO -ipo)\n    set(CMAKE_${lang}_CREATE_STATIC_LIBRARY_IPO\n      \"${XIAR} cr <TARGET> <LINK_FLAGS> <OBJECTS> \"\n      \"${XIAR} -s <TARGET> \")\n    set(_CMAKE_${lang}_IPO_MAY_BE_SUPPORTED_BY_COMPILER YES)\n    set(_CMAKE_${lang}_IPO_LEGACY_BEHAVIOR YES)\n  else()\n    set(_CMAKE_${lang}_IPO_MAY_BE_SUPPORTED_BY_COMPILER NO)\n  endif()\n\n  if(NOT CMAKE_${lang}_COMPILER_VERSION VERSION_LESS 12.0)\n    set(CMAKE_${lang}_COMPILE_OPTIONS_VISIBILITY \"-fvisibility=\")\n  endif()\nendmacro()\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/Platform/Linux-GNU.cmake": "# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n# file Copyright.txt or https://cmake.org/licensing for details.\n\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_GNU)\n  return()\nendif()\nset(__LINUX_COMPILER_GNU 1)\n\nmacro(__linux_compiler_gnu lang)\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\nendmacro()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Templates/Windows/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectLocal/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProject/gitrepo-sub.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/StringFileTest/test.utf8",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/CommandLine/cmake_depends/test_UTF-16LE.h",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/configure_file/UTF32LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/configure_file/UTF16LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/configure_file/UTF16BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/configure_file/UTF32BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/string/UTF-32BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/string/UTF-32LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/string/UTF-16BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/RunCMake/string/UTF-16LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ExternalProjectUpdate/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimplePixelShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Direct3DApp1_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimpleVertexShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSXaml/VSXaml_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSXaml/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSXaml/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSXaml/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Tests/VSXaml/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Sphinx/static/cmake-logo-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Sphinx/static/cmake-favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample2.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample1.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample3.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/libbz2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample2.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample1.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample1.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/cmbzip2/sample2.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Release/WiX/ui_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Utilities/Release/WiX/ui_banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/QtDialog/CMakeSetup64.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Packaging/CMakeDMGBackground.tif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.13.1-zgvg5ztf3z337cqajfbh5r3z6o33q7wn/spack-src/Modules/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 12644
}