{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Help/variable/CMAKE_DL_LIBS.rst": "CMAKE_DL_LIBS\n-------------\n\nName of library containing ``dlopen`` and ``dlcose``.\n\nThe name of the library that has ``dlopen`` and ``dlclose`` in it, usually\n``-ldl`` on most UNIX machines.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Help/policy/CMP0065.rst": "CMP0065\n-------\n\nDo not add flags to export symbols from executables without\nthe :prop_tgt:`ENABLE_EXPORTS` target property.\n\nCMake 3.3 and below, for historical reasons, always linked executables\non some platforms with flags like ``-rdynamic`` to export symbols from\nthe executables for use by any plugins they may load via ``dlopen``.\nCMake 3.4 and above prefer to do this only for executables that are\nexplicitly marked with the :prop_tgt:`ENABLE_EXPORTS` target property.\n\nThe ``OLD`` behavior of this policy is to always use the additional link\nflags when linking executables regardless of the value of the\n:prop_tgt:`ENABLE_EXPORTS` target property.\n\nThe ``NEW`` behavior of this policy is to only use the additional link\nflags when linking executables if the :prop_tgt:`ENABLE_EXPORTS` target\nproperty is set to ``True``.\n\nThis policy was introduced in CMake version 3.4.  Unlike most policies,\nCMake version |release| does *not* warn by default when this policy\nis not set and simply uses OLD behavior.  See documentation of the\n:variable:`CMAKE_POLICY_WARNING_CMP0065 <CMAKE_POLICY_WARNING_CMP<NNNN>>`\nvariable to control the warning.\n\n.. include:: DEPRECATED.txt\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Help/command/add_library.rst": "add_library\n-----------\n\n.. only:: html\n\n   .. contents::\n\nAdd a library to the project using the specified source files.\n\nNormal Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> [STATIC | SHARED | MODULE]\n              [EXCLUDE_FROM_ALL]\n              source1 [source2 ...])\n\nAdds a library target called ``<name>`` to be built from the source files\nlisted in the command invocation.  The ``<name>`` corresponds to the\nlogical target name and must be globally unique within a project.  The\nactual file name of the library built is constructed based on\nconventions of the native platform (such as ``lib<name>.a`` or\n``<name>.lib``).\n\n``STATIC``, ``SHARED``, or ``MODULE`` may be given to specify the type of\nlibrary to be created.  ``STATIC`` libraries are archives of object files\nfor use when linking other targets.  ``SHARED`` libraries are linked\ndynamically and loaded at runtime.  ``MODULE`` libraries are plugins that\nare not linked into other targets but may be loaded dynamically at runtime\nusing dlopen-like functionality.  If no type is given explicitly the\ntype is ``STATIC`` or ``SHARED`` based on whether the current value of the\nvariable :variable:`BUILD_SHARED_LIBS` is ``ON``.  For ``SHARED`` and\n``MODULE`` libraries the :prop_tgt:`POSITION_INDEPENDENT_CODE` target\nproperty is set to ``ON`` automatically.\nA ``SHARED`` library may be marked with the :prop_tgt:`FRAMEWORK`\ntarget property to create an OS X Framework.\n\nIf a library does not export any symbols, it must not be declared as a\n``SHARED`` library.  For example, a Windows resource DLL or a managed C++/CLI\nDLL that exports no unmanaged symbols would need to be a ``MODULE`` library.\nThis is because CMake expects a ``SHARED`` library to always have an\nassociated import library on Windows.\n\nBy default the library file will be created in the build tree directory\ncorresponding to the source tree directory in which the command was\ninvoked.  See documentation of the :prop_tgt:`ARCHIVE_OUTPUT_DIRECTORY`,\n:prop_tgt:`LIBRARY_OUTPUT_DIRECTORY`, and\n:prop_tgt:`RUNTIME_OUTPUT_DIRECTORY` target properties to change this\nlocation.  See documentation of the :prop_tgt:`OUTPUT_NAME` target\nproperty to change the ``<name>`` part of the final file name.\n\nIf ``EXCLUDE_FROM_ALL`` is given the corresponding property will be set on\nthe created target.  See documentation of the :prop_tgt:`EXCLUDE_FROM_ALL`\ntarget property for details.\n\nSource arguments to ``add_library`` may use \"generator expressions\" with\nthe syntax ``$<...>``.  See the :manual:`cmake-generator-expressions(7)`\nmanual for available expressions.  See the :manual:`cmake-buildsystem(7)`\nmanual for more on defining buildsystem properties.\n\nImported Libraries\n^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> <SHARED|STATIC|MODULE|UNKNOWN> IMPORTED\n              [GLOBAL])\n\nAn :ref:`IMPORTED library target <Imported Targets>` references a library\nfile located outside the project.  No rules are generated to build it, and\nthe :prop_tgt:`IMPORTED` target property is ``True``.  The target name has\nscope in the directory in which it is created and below, but the ``GLOBAL``\noption extends visibility.  It may be referenced like any target built\nwithin the project.  ``IMPORTED`` libraries are useful for convenient\nreference from commands like :command:`target_link_libraries`.  Details\nabout the imported library are specified by setting properties whose names\nbegin in ``IMPORTED_`` and ``INTERFACE_``.  The most important such\nproperty is :prop_tgt:`IMPORTED_LOCATION` (and its per-configuration\nvariant :prop_tgt:`IMPORTED_LOCATION_<CONFIG>`) which specifies the\nlocation of the main library file on disk.  See documentation of the\n``IMPORTED_*`` and ``INTERFACE_*`` properties for more information.\n\nObject Libraries\n^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> OBJECT <src>...)\n\nCreates an :ref:`Object Library <Object Libraries>`.  An object library\ncompiles source files but does not archive or link their object files into a\nlibrary.  Instead other targets created by :command:`add_library` or\n:command:`add_executable` may reference the objects using an expression of the\nform ``$<TARGET_OBJECTS:objlib>`` as a source, where ``objlib`` is the\nobject library name.  For example:\n\n.. code-block:: cmake\n\n  add_library(... $<TARGET_OBJECTS:objlib> ...)\n  add_executable(... $<TARGET_OBJECTS:objlib> ...)\n\nwill include objlib's object files in a library and an executable\nalong with those compiled from their own sources.  Object libraries\nmay contain only sources that compile, header files, and other files\nthat would not affect linking of a normal library (e.g. ``.txt``).\nThey may contain custom commands generating such sources, but not\n``PRE_BUILD``, ``PRE_LINK``, or ``POST_BUILD`` commands.  Object libraries\ncannot be imported, exported, installed, or linked.  Some native build\nsystems may not like targets that have only object files, so consider\nadding at least one real source file to any target that references\n``$<TARGET_OBJECTS:objlib>``.\n\nAlias Libraries\n^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> ALIAS <target>)\n\nCreates an :ref:`Alias Target <Alias Targets>`, such that ``<name>`` can be\nused to refer to ``<target>`` in subsequent commands.  The ``<name>`` does\nnot appear in the generatedbuildsystem as a make target.  The ``<target>``\nmay not be an :ref:`Imported Target <Imported Targets>` or an ``ALIAS``.\n``ALIAS`` targets can be used as linkable targets and as targets to\nread properties from.  They can also be tested for existance with the\nregular :command:`if(TARGET)` subcommand.  The ``<name>`` may not be used\nto modify properties of ``<target>``, that is, it may not be used as the\noperand of :command:`set_property`, :command:`set_target_properties`,\n:command:`target_link_libraries` etc.  An ``ALIAS`` target may not be\ninstalled or exported.\n\nInterface Libraries\n^^^^^^^^^^^^^^^^^^^\n\n::\n\n  add_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n\nCreates an :ref:`Interface Library <Interface Libraries>`.  An ``INTERFACE``\nlibrary target does not directly create build output, though it may\nhave properties set on it and it may be installed, exported and\nimported. Typically the ``INTERFACE_*`` properties are populated on\nthe interface target using the commands:\n\n* :command:`set_property`,\n* :command:`target_link_libraries(INTERFACE)`,\n* :command:`target_include_directories(INTERFACE)`,\n* :command:`target_compile_options(INTERFACE)`,\n* :command:`target_compile_definitions(INTERFACE)`, and\n* :command:`target_sources(INTERFACE)`,\n\nand then it is used as an argument to :command:`target_link_libraries`\nlike any other target.\n\nAn ``INTERFACE`` :ref:`Imported Target <Imported Targets>` may also be\ncreated with this signature.  An ``IMPORTED`` library target references a\nlibrary defined outside the project.  The target name has scope in the\ndirectory in which it is created and below, but the ``GLOBAL`` option\nextends visibility.  It may be referenced like any target built within\nthe project.  ``IMPORTED`` libraries are useful for convenient reference\nfrom commands like :command:`target_link_libraries`.\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/BundleUtilities/testbundleutils1.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module1.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module1\\n\");\n  }\n#else\n  void* lib = dlopen(\"module1.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module1\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/BundleUtilities/testbundleutils2.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module2.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module2\\n\");\n  }\n#else\n  void* lib = dlopen(\"module2.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module2\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/BundleUtilities/testbundleutils3.cpp": "\n#include \"framework.h\"\n#include \"shared.h\"\n#include \"stdio.h\"\n\n#if defined(WIN32)\n#include <windows.h>\n#else\n#include \"dlfcn.h\"\n#endif\n\nint main(int, char**)\n{\n  framework();\n  shared();\n\n#if defined(WIN32)\n  HANDLE lib = LoadLibraryA(\"module3.dll\");\n  if(!lib)\n  {\n    printf(\"Failed to open module3\\n\");\n  }\n#else\n  void* lib = dlopen(\"module3.so\", RTLD_LAZY);\n  if(!lib)\n  {\n    printf(\"Failed to open module3\\n%s\\n\", dlerror());\n  }\n#endif\n\n\n  return lib == 0 ? 1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/lib/strerror.c": "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2004 - 2015, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at http://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_STRERROR_R\n#  if (!defined(HAVE_POSIX_STRERROR_R) && \\\n       !defined(HAVE_GLIBC_STRERROR_R) && \\\n       !defined(HAVE_VXWORKS_STRERROR_R)) || \\\n      (defined(HAVE_POSIX_STRERROR_R) && defined(HAVE_VXWORKS_STRERROR_R)) || \\\n      (defined(HAVE_GLIBC_STRERROR_R) && defined(HAVE_VXWORKS_STRERROR_R)) || \\\n      (defined(HAVE_POSIX_STRERROR_R) && defined(HAVE_GLIBC_STRERROR_R))\n#    error \"strerror_r MUST be either POSIX, glibc or vxworks-style\"\n#  endif\n#endif\n\n#include <curl/curl.h>\n\n#ifdef USE_LIBIDN\n#include <idna.h>\n#endif\n\n#include \"strerror.h\"\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\nconst char *\ncurl_easy_strerror(CURLcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLE_OK:\n    return \"No error\";\n\n  case CURLE_UNSUPPORTED_PROTOCOL:\n    return \"Unsupported protocol\";\n\n  case CURLE_FAILED_INIT:\n    return \"Failed initialization\";\n\n  case CURLE_URL_MALFORMAT:\n    return \"URL using bad/illegal format or missing URL\";\n\n  case CURLE_NOT_BUILT_IN:\n    return \"A requested feature, protocol or option was not found built-in in\"\n      \" this libcurl due to a build-time decision.\";\n\n  case CURLE_COULDNT_RESOLVE_PROXY:\n    return \"Couldn't resolve proxy name\";\n\n  case CURLE_COULDNT_RESOLVE_HOST:\n    return \"Couldn't resolve host name\";\n\n  case CURLE_COULDNT_CONNECT:\n    return \"Couldn't connect to server\";\n\n  case CURLE_FTP_WEIRD_SERVER_REPLY:\n    return \"FTP: weird server reply\";\n\n  case CURLE_REMOTE_ACCESS_DENIED:\n    return \"Access denied to remote resource\";\n\n  case CURLE_FTP_ACCEPT_FAILED:\n    return \"FTP: The server failed to connect to data port\";\n\n  case CURLE_FTP_ACCEPT_TIMEOUT:\n    return \"FTP: Accepting server connect has timed out\";\n\n  case CURLE_FTP_PRET_FAILED:\n    return \"FTP: The server did not accept the PRET command.\";\n\n  case CURLE_FTP_WEIRD_PASS_REPLY:\n    return \"FTP: unknown PASS reply\";\n\n  case CURLE_FTP_WEIRD_PASV_REPLY:\n    return \"FTP: unknown PASV reply\";\n\n  case CURLE_FTP_WEIRD_227_FORMAT:\n    return \"FTP: unknown 227 response format\";\n\n  case CURLE_FTP_CANT_GET_HOST:\n    return \"FTP: can't figure out the host in the PASV response\";\n\n  case CURLE_HTTP2:\n    return \"Error in the HTTP2 framing layer\";\n\n  case CURLE_FTP_COULDNT_SET_TYPE:\n    return \"FTP: couldn't set file type\";\n\n  case CURLE_PARTIAL_FILE:\n    return \"Transferred a partial file\";\n\n  case CURLE_FTP_COULDNT_RETR_FILE:\n    return \"FTP: couldn't retrieve (RETR failed) the specified file\";\n\n  case CURLE_QUOTE_ERROR:\n    return \"Quote command returned error\";\n\n  case CURLE_HTTP_RETURNED_ERROR:\n    return \"HTTP response code said error\";\n\n  case CURLE_WRITE_ERROR:\n    return \"Failed writing received data to disk/application\";\n\n  case CURLE_UPLOAD_FAILED:\n    return \"Upload failed (at start/before it took off)\";\n\n  case CURLE_READ_ERROR:\n    return \"Failed to open/read local data from file/application\";\n\n  case CURLE_OUT_OF_MEMORY:\n    return \"Out of memory\";\n\n  case CURLE_OPERATION_TIMEDOUT:\n    return \"Timeout was reached\";\n\n  case CURLE_FTP_PORT_FAILED:\n    return \"FTP: command PORT failed\";\n\n  case CURLE_FTP_COULDNT_USE_REST:\n    return \"FTP: command REST failed\";\n\n  case CURLE_RANGE_ERROR:\n    return \"Requested range was not delivered by the server\";\n\n  case CURLE_HTTP_POST_ERROR:\n    return \"Internal problem setting up the POST\";\n\n  case CURLE_SSL_CONNECT_ERROR:\n    return \"SSL connect error\";\n\n  case CURLE_BAD_DOWNLOAD_RESUME:\n    return \"Couldn't resume download\";\n\n  case CURLE_FILE_COULDNT_READ_FILE:\n    return \"Couldn't read a file:// file\";\n\n  case CURLE_LDAP_CANNOT_BIND:\n    return \"LDAP: cannot bind\";\n\n  case CURLE_LDAP_SEARCH_FAILED:\n    return \"LDAP: search failed\";\n\n  case CURLE_FUNCTION_NOT_FOUND:\n    return \"A required function in the library was not found\";\n\n  case CURLE_ABORTED_BY_CALLBACK:\n    return \"Operation was aborted by an application callback\";\n\n  case CURLE_BAD_FUNCTION_ARGUMENT:\n    return \"A libcurl function was given a bad argument\";\n\n  case CURLE_INTERFACE_FAILED:\n    return \"Failed binding local connection end\";\n\n  case CURLE_TOO_MANY_REDIRECTS :\n    return \"Number of redirects hit maximum amount\";\n\n  case CURLE_UNKNOWN_OPTION:\n    return \"An unknown option was passed in to libcurl\";\n\n  case CURLE_TELNET_OPTION_SYNTAX :\n    return \"Malformed telnet option\";\n\n  case CURLE_PEER_FAILED_VERIFICATION:\n    return \"SSL peer certificate or SSH remote key was not OK\";\n\n  case CURLE_GOT_NOTHING:\n    return \"Server returned nothing (no headers, no data)\";\n\n  case CURLE_SSL_ENGINE_NOTFOUND:\n    return \"SSL crypto engine not found\";\n\n  case CURLE_SSL_ENGINE_SETFAILED:\n    return \"Can not set SSL crypto engine as default\";\n\n  case CURLE_SSL_ENGINE_INITFAILED:\n    return \"Failed to initialise SSL crypto engine\";\n\n  case CURLE_SEND_ERROR:\n    return \"Failed sending data to the peer\";\n\n  case CURLE_RECV_ERROR:\n    return \"Failure when receiving data from the peer\";\n\n  case CURLE_SSL_CERTPROBLEM:\n    return \"Problem with the local SSL certificate\";\n\n  case CURLE_SSL_CIPHER:\n    return \"Couldn't use specified SSL cipher\";\n\n  case CURLE_SSL_CACERT:\n    return \"Peer certificate cannot be authenticated with given CA \"\n      \"certificates\";\n\n  case CURLE_SSL_CACERT_BADFILE:\n    return \"Problem with the SSL CA cert (path? access rights?)\";\n\n  case CURLE_BAD_CONTENT_ENCODING:\n    return \"Unrecognized or bad HTTP Content or Transfer-Encoding\";\n\n  case CURLE_LDAP_INVALID_URL:\n    return \"Invalid LDAP URL\";\n\n  case CURLE_FILESIZE_EXCEEDED:\n    return \"Maximum file size exceeded\";\n\n  case CURLE_USE_SSL_FAILED:\n    return \"Requested SSL level failed\";\n\n  case CURLE_SSL_SHUTDOWN_FAILED:\n    return \"Failed to shut down the SSL connection\";\n\n  case CURLE_SSL_CRL_BADFILE:\n    return \"Failed to load CRL file (path? access rights?, format?)\";\n\n  case CURLE_SSL_ISSUER_ERROR:\n    return \"Issuer check against peer certificate failed\";\n\n  case CURLE_SEND_FAIL_REWIND:\n    return \"Send failed since rewinding of the data stream failed\";\n\n  case CURLE_LOGIN_DENIED:\n    return \"Login denied\";\n\n  case CURLE_TFTP_NOTFOUND:\n    return \"TFTP: File Not Found\";\n\n  case CURLE_TFTP_PERM:\n    return \"TFTP: Access Violation\";\n\n  case CURLE_REMOTE_DISK_FULL:\n    return \"Disk full or allocation exceeded\";\n\n  case CURLE_TFTP_ILLEGAL:\n    return \"TFTP: Illegal operation\";\n\n  case CURLE_TFTP_UNKNOWNID:\n    return \"TFTP: Unknown transfer ID\";\n\n  case CURLE_REMOTE_FILE_EXISTS:\n    return \"Remote file already exists\";\n\n  case CURLE_TFTP_NOSUCHUSER:\n    return \"TFTP: No such user\";\n\n  case CURLE_CONV_FAILED:\n    return \"Conversion failed\";\n\n  case CURLE_CONV_REQD:\n    return \"Caller must register CURLOPT_CONV_ callback options\";\n\n  case CURLE_REMOTE_FILE_NOT_FOUND:\n    return \"Remote file not found\";\n\n  case CURLE_SSH:\n    return \"Error in the SSH layer\";\n\n  case CURLE_AGAIN:\n    return \"Socket not ready for send/recv\";\n\n  case CURLE_RTSP_CSEQ_ERROR:\n    return \"RTSP CSeq mismatch or invalid CSeq\";\n\n  case CURLE_RTSP_SESSION_ERROR:\n    return \"RTSP session error\";\n\n  case CURLE_FTP_BAD_FILE_LIST:\n    return \"Unable to parse FTP file list\";\n\n  case CURLE_CHUNK_FAILED:\n    return \"Chunk callback failed\";\n\n  case CURLE_NO_CONNECTION_AVAILABLE:\n    return \"The max connection limit is reached\";\n\n  case CURLE_SSL_PINNEDPUBKEYNOTMATCH:\n    return \"SSL public key does not match pinned public key\";\n\n  case CURLE_SSL_INVALIDCERTSTATUS:\n    return \"SSL server certificate status verification FAILED\";\n\n    /* error codes not used by current libcurl */\n  case CURLE_OBSOLETE20:\n  case CURLE_OBSOLETE24:\n  case CURLE_OBSOLETE29:\n  case CURLE_OBSOLETE32:\n  case CURLE_OBSOLETE40:\n  case CURLE_OBSOLETE44:\n  case CURLE_OBSOLETE46:\n  case CURLE_OBSOLETE50:\n  case CURLE_OBSOLETE57:\n  case CURL_LAST:\n    break;\n  }\n  /*\n   * By using a switch, gcc -Wall will complain about enum values\n   * which do not appear, helping keep this function up-to-date.\n   * By using gcc -Wall -Werror, you can't forget.\n   *\n   * A table would not have the same benefit.  Most compilers will\n   * generate code very similar to a table in any case, so there\n   * is little performance gain from a table.  And something is broken\n   * for the user's application, anyways, so does it matter how fast\n   * it _doesn't_ work?\n   *\n   * The line number for the error will be near this comment, which\n   * is why it is here, and not at the start of the switch.\n   */\n  return \"Unknown error\";\n#else\n  if(!error)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\nconst char *\ncurl_multi_strerror(CURLMcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLM_CALL_MULTI_PERFORM:\n    return \"Please call curl_multi_perform() soon\";\n\n  case CURLM_OK:\n    return \"No error\";\n\n  case CURLM_BAD_HANDLE:\n    return \"Invalid multi handle\";\n\n  case CURLM_BAD_EASY_HANDLE:\n    return \"Invalid easy handle\";\n\n  case CURLM_OUT_OF_MEMORY:\n    return \"Out of memory\";\n\n  case CURLM_INTERNAL_ERROR:\n    return \"Internal error\";\n\n  case CURLM_BAD_SOCKET:\n    return \"Invalid socket argument\";\n\n  case CURLM_UNKNOWN_OPTION:\n    return \"Unknown option\";\n\n  case CURLM_ADDED_ALREADY:\n    return \"The easy handle is already added to a multi handle\";\n\n  case CURLM_LAST:\n    break;\n  }\n\n  return \"Unknown error\";\n#else\n  if(error == CURLM_OK)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\nconst char *\ncurl_share_strerror(CURLSHcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (error) {\n  case CURLSHE_OK:\n    return \"No error\";\n\n  case CURLSHE_BAD_OPTION:\n    return \"Unknown share option\";\n\n  case CURLSHE_IN_USE:\n    return \"Share currently in use\";\n\n  case CURLSHE_INVALID:\n    return \"Invalid share handle\";\n\n  case CURLSHE_NOMEM:\n    return \"Out of memory\";\n\n  case CURLSHE_NOT_BUILT_IN:\n    return \"Feature not enabled in this library\";\n\n  case CURLSHE_LAST:\n    break;\n  }\n\n  return \"CURLSHcode unknown\";\n#else\n  if(error == CURLSHE_OK)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\n#ifdef USE_WINSOCK\n\n/* This function handles most / all (?) Winsock errors cURL is able to produce.\n */\nstatic const char *\nget_winsock_error (int err, char *buf, size_t len)\n{\n  const char *p;\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch (err) {\n  case WSAEINTR:\n    p = \"Call interrupted\";\n    break;\n  case WSAEBADF:\n    p = \"Bad file\";\n    break;\n  case WSAEACCES:\n    p = \"Bad access\";\n    break;\n  case WSAEFAULT:\n    p = \"Bad argument\";\n    break;\n  case WSAEINVAL:\n    p = \"Invalid arguments\";\n    break;\n  case WSAEMFILE:\n    p = \"Out of file descriptors\";\n    break;\n  case WSAEWOULDBLOCK:\n    p = \"Call would block\";\n    break;\n  case WSAEINPROGRESS:\n  case WSAEALREADY:\n    p = \"Blocking call in progress\";\n    break;\n  case WSAENOTSOCK:\n    p = \"Descriptor is not a socket\";\n    break;\n  case WSAEDESTADDRREQ:\n    p = \"Need destination address\";\n    break;\n  case WSAEMSGSIZE:\n    p = \"Bad message size\";\n    break;\n  case WSAEPROTOTYPE:\n    p = \"Bad protocol\";\n    break;\n  case WSAENOPROTOOPT:\n    p = \"Protocol option is unsupported\";\n    break;\n  case WSAEPROTONOSUPPORT:\n    p = \"Protocol is unsupported\";\n    break;\n  case WSAESOCKTNOSUPPORT:\n    p = \"Socket is unsupported\";\n    break;\n  case WSAEOPNOTSUPP:\n    p = \"Operation not supported\";\n    break;\n  case WSAEAFNOSUPPORT:\n    p = \"Address family not supported\";\n    break;\n  case WSAEPFNOSUPPORT:\n    p = \"Protocol family not supported\";\n    break;\n  case WSAEADDRINUSE:\n    p = \"Address already in use\";\n    break;\n  case WSAEADDRNOTAVAIL:\n    p = \"Address not available\";\n    break;\n  case WSAENETDOWN:\n    p = \"Network down\";\n    break;\n  case WSAENETUNREACH:\n    p = \"Network unreachable\";\n    break;\n  case WSAENETRESET:\n    p = \"Network has been reset\";\n    break;\n  case WSAECONNABORTED:\n    p = \"Connection was aborted\";\n    break;\n  case WSAECONNRESET:\n    p = \"Connection was reset\";\n    break;\n  case WSAENOBUFS:\n    p = \"No buffer space\";\n    break;\n  case WSAEISCONN:\n    p = \"Socket is already connected\";\n    break;\n  case WSAENOTCONN:\n    p = \"Socket is not connected\";\n    break;\n  case WSAESHUTDOWN:\n    p = \"Socket has been shut down\";\n    break;\n  case WSAETOOMANYREFS:\n    p = \"Too many references\";\n    break;\n  case WSAETIMEDOUT:\n    p = \"Timed out\";\n    break;\n  case WSAECONNREFUSED:\n    p = \"Connection refused\";\n    break;\n  case WSAELOOP:\n    p = \"Loop??\";\n    break;\n  case WSAENAMETOOLONG:\n    p = \"Name too long\";\n    break;\n  case WSAEHOSTDOWN:\n    p = \"Host down\";\n    break;\n  case WSAEHOSTUNREACH:\n    p = \"Host unreachable\";\n    break;\n  case WSAENOTEMPTY:\n    p = \"Not empty\";\n    break;\n  case WSAEPROCLIM:\n    p = \"Process limit reached\";\n    break;\n  case WSAEUSERS:\n    p = \"Too many users\";\n    break;\n  case WSAEDQUOT:\n    p = \"Bad quota\";\n    break;\n  case WSAESTALE:\n    p = \"Something is stale\";\n    break;\n  case WSAEREMOTE:\n    p = \"Remote error\";\n    break;\n#ifdef WSAEDISCON  /* missing in SalfordC! */\n  case WSAEDISCON:\n    p = \"Disconnected\";\n    break;\n#endif\n    /* Extended Winsock errors */\n  case WSASYSNOTREADY:\n    p = \"Winsock library is not ready\";\n    break;\n  case WSANOTINITIALISED:\n    p = \"Winsock library not initialised\";\n    break;\n  case WSAVERNOTSUPPORTED:\n    p = \"Winsock version not supported\";\n    break;\n\n    /* getXbyY() errors (already handled in herrmsg):\n     * Authoritative Answer: Host not found */\n  case WSAHOST_NOT_FOUND:\n    p = \"Host not found\";\n    break;\n\n    /* Non-Authoritative: Host not found, or SERVERFAIL */\n  case WSATRY_AGAIN:\n    p = \"Host not found, try again\";\n    break;\n\n    /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */\n  case WSANO_RECOVERY:\n    p = \"Unrecoverable error in call to nameserver\";\n    break;\n\n    /* Valid name, no data record of requested type */\n  case WSANO_DATA:\n    p = \"No data record of requested type\";\n    break;\n\n  default:\n    return NULL;\n  }\n#else\n  if(!err)\n    return NULL;\n  else\n    p = \"error\";\n#endif\n  strncpy (buf, p, len);\n  buf [len-1] = '\\0';\n  return buf;\n}\n#endif   /* USE_WINSOCK */\n\n/*\n * Our thread-safe and smart strerror() replacement.\n *\n * The 'err' argument passed in to this function MUST be a true errno number\n * as reported on this system. We do no range checking on the number before\n * we pass it to the \"number-to-message\" conversion function and there might\n * be systems that don't do proper range checking in there themselves.\n *\n * We don't do range checking (on systems other than Windows) since there is\n * no good reliable and portable way to do it.\n */\nconst char *Curl_strerror(struct connectdata *conn, int err)\n{\n  char *buf, *p;\n  size_t max;\n  int old_errno = ERRNO;\n\n  DEBUGASSERT(conn);\n  DEBUGASSERT(err >= 0);\n\n  buf = conn->syserr_buf;\n  max = sizeof(conn->syserr_buf)-1;\n  *buf = '\\0';\n\n#ifdef USE_WINSOCK\n\n#ifdef _WIN32_WCE\n  {\n    wchar_t wbuf[256];\n    wbuf[0] = L'\\0';\n\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,\n                  LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL);\n    wcstombs(buf, wbuf, max);\n  }\n#else\n  /* 'sys_nerr' is the maximum errno number, it is not widely portable */\n  if(err >= 0 && err < sys_nerr)\n    strncpy(buf, strerror(err), max);\n  else {\n    if(!get_winsock_error(err, buf, max) &&\n       !FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,\n                       LANG_NEUTRAL, buf, (DWORD)max, NULL))\n      snprintf(buf, max, \"Unknown error %d (%#x)\", err, err);\n  }\n#endif\n\n#else /* not USE_WINSOCK coming up */\n\n#if defined(HAVE_STRERROR_R) && defined(HAVE_POSIX_STRERROR_R)\n /*\n  * The POSIX-style strerror_r() may set errno to ERANGE if insufficient\n  * storage is supplied via 'strerrbuf' and 'buflen' to hold the generated\n  * message string, or EINVAL if 'errnum' is not a valid error number.\n  */\n  if(0 != strerror_r(err, buf, max)) {\n    if('\\0' == buf[0])\n      snprintf(buf, max, \"Unknown error %d\", err);\n  }\n#elif defined(HAVE_STRERROR_R) && defined(HAVE_GLIBC_STRERROR_R)\n /*\n  * The glibc-style strerror_r() only *might* use the buffer we pass to\n  * the function, but it always returns the error message as a pointer,\n  * so we must copy that string unconditionally (if non-NULL).\n  */\n  {\n    char buffer[256];\n    char *msg = strerror_r(err, buffer, sizeof(buffer));\n    if(msg)\n      strncpy(buf, msg, max);\n    else\n      snprintf(buf, max, \"Unknown error %d\", err);\n  }\n#elif defined(HAVE_STRERROR_R) && defined(HAVE_VXWORKS_STRERROR_R)\n /*\n  * The vxworks-style strerror_r() does use the buffer we pass to the function.\n  * The buffer size should be at least NAME_MAX (256)\n  */\n  {\n    char buffer[256];\n    if(OK == strerror_r(err, buffer))\n      strncpy(buf, buffer, max);\n    else\n      snprintf(buf, max, \"Unknown error %d\", err);\n  }\n#else\n  {\n    char *msg = strerror(err);\n    if(msg)\n      strncpy(buf, msg, max);\n    else\n      snprintf(buf, max, \"Unknown error %d\", err);\n  }\n#endif\n\n#endif /* end of ! USE_WINSOCK */\n\n  buf[max] = '\\0'; /* make sure the string is zero terminated */\n\n  /* strip trailing '\\r\\n' or '\\n'. */\n  if((p = strrchr(buf, '\\n')) != NULL && (p - buf) >= 2)\n     *p = '\\0';\n  if((p = strrchr(buf, '\\r')) != NULL && (p - buf) >= 1)\n     *p = '\\0';\n\n  if(old_errno != ERRNO)\n    SET_ERRNO(old_errno);\n\n  return buf;\n}\n\n#ifdef USE_LIBIDN\n/*\n * Return error-string for libidn status as returned from idna_to_ascii_lz().\n */\nconst char *Curl_idn_strerror (struct connectdata *conn, int err)\n{\n#ifdef HAVE_IDNA_STRERROR\n  (void)conn;\n  return idna_strerror((Idna_rc) err);\n#else\n  const char *str;\n  char *buf;\n  size_t max;\n\n  DEBUGASSERT(conn);\n\n  buf = conn->syserr_buf;\n  max = sizeof(conn->syserr_buf)-1;\n  *buf = '\\0';\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch ((Idna_rc)err) {\n    case IDNA_SUCCESS:\n      str = \"No error\";\n      break;\n    case IDNA_STRINGPREP_ERROR:\n      str = \"Error in string preparation\";\n      break;\n    case IDNA_PUNYCODE_ERROR:\n      str = \"Error in Punycode operation\";\n      break;\n    case IDNA_CONTAINS_NON_LDH:\n      str = \"Illegal ASCII characters\";\n      break;\n    case IDNA_CONTAINS_MINUS:\n      str = \"Contains minus\";\n      break;\n    case IDNA_INVALID_LENGTH:\n      str = \"Invalid output length\";\n      break;\n    case IDNA_NO_ACE_PREFIX:\n      str = \"No ACE prefix (\\\"xn--\\\")\";\n      break;\n    case IDNA_ROUNDTRIP_VERIFY_ERROR:\n      str = \"Round trip verify error\";\n      break;\n    case IDNA_CONTAINS_ACE_PREFIX:\n      str = \"Already have ACE prefix (\\\"xn--\\\")\";\n      break;\n    case IDNA_ICONV_ERROR:\n      str = \"Locale conversion failed\";\n      break;\n    case IDNA_MALLOC_ERROR:\n      str = \"Allocation failed\";\n      break;\n    case IDNA_DLOPEN_ERROR:\n      str = \"dlopen() error\";\n      break;\n    default:\n      snprintf(buf, max, \"error %d\", err);\n      str = NULL;\n      break;\n  }\n#else\n  if((Idna_rc)err == IDNA_SUCCESS)\n    str = \"No error\";\n  else\n    str = \"Error\";\n#endif\n  if(str)\n    strncpy(buf, str, max);\n  buf[max] = '\\0';\n  return (buf);\n#endif\n}\n#endif  /* USE_LIBIDN */\n\n#ifdef USE_WINDOWS_SSPI\nconst char *Curl_sspi_strerror (struct connectdata *conn, int err)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  char txtbuf[80];\n  char msgbuf[sizeof(conn->syserr_buf)];\n  char *p, *str, *msg = NULL;\n  bool msg_formatted = FALSE;\n  int old_errno;\n#endif\n  const char *txt;\n  char *outbuf;\n  size_t outmax;\n\n  DEBUGASSERT(conn);\n\n  outbuf = conn->syserr_buf;\n  outmax = sizeof(conn->syserr_buf)-1;\n  *outbuf = '\\0';\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n\n  old_errno = ERRNO;\n\n  switch (err) {\n    case SEC_E_OK:\n      txt = \"No error\";\n      break;\n    case CRYPT_E_REVOKED:\n      txt = \"CRYPT_E_REVOKED\";\n      break;\n    case SEC_E_ALGORITHM_MISMATCH:\n      txt = \"SEC_E_ALGORITHM_MISMATCH\";\n      break;\n    case SEC_E_BAD_BINDINGS:\n      txt = \"SEC_E_BAD_BINDINGS\";\n      break;\n    case SEC_E_BAD_PKGID:\n      txt = \"SEC_E_BAD_PKGID\";\n      break;\n    case SEC_E_BUFFER_TOO_SMALL:\n      txt = \"SEC_E_BUFFER_TOO_SMALL\";\n      break;\n    case SEC_E_CANNOT_INSTALL:\n      txt = \"SEC_E_CANNOT_INSTALL\";\n      break;\n    case SEC_E_CANNOT_PACK:\n      txt = \"SEC_E_CANNOT_PACK\";\n      break;\n    case SEC_E_CERT_EXPIRED:\n      txt = \"SEC_E_CERT_EXPIRED\";\n      break;\n    case SEC_E_CERT_UNKNOWN:\n      txt = \"SEC_E_CERT_UNKNOWN\";\n      break;\n    case SEC_E_CERT_WRONG_USAGE:\n      txt = \"SEC_E_CERT_WRONG_USAGE\";\n      break;\n    case SEC_E_CONTEXT_EXPIRED:\n      txt = \"SEC_E_CONTEXT_EXPIRED\";\n      break;\n    case SEC_E_CROSSREALM_DELEGATION_FAILURE:\n      txt = \"SEC_E_CROSSREALM_DELEGATION_FAILURE\";\n      break;\n    case SEC_E_CRYPTO_SYSTEM_INVALID:\n      txt = \"SEC_E_CRYPTO_SYSTEM_INVALID\";\n      break;\n    case SEC_E_DECRYPT_FAILURE:\n      txt = \"SEC_E_DECRYPT_FAILURE\";\n      break;\n    case SEC_E_DELEGATION_POLICY:\n      txt = \"SEC_E_DELEGATION_POLICY\";\n      break;\n    case SEC_E_DELEGATION_REQUIRED:\n      txt = \"SEC_E_DELEGATION_REQUIRED\";\n      break;\n    case SEC_E_DOWNGRADE_DETECTED:\n      txt = \"SEC_E_DOWNGRADE_DETECTED\";\n      break;\n    case SEC_E_ENCRYPT_FAILURE:\n      txt = \"SEC_E_ENCRYPT_FAILURE\";\n      break;\n    case SEC_E_ILLEGAL_MESSAGE:\n      txt = \"SEC_E_ILLEGAL_MESSAGE\";\n      break;\n    case SEC_E_INCOMPLETE_CREDENTIALS:\n      txt = \"SEC_E_INCOMPLETE_CREDENTIALS\";\n      break;\n    case SEC_E_INCOMPLETE_MESSAGE:\n      txt = \"SEC_E_INCOMPLETE_MESSAGE\";\n      break;\n    case SEC_E_INSUFFICIENT_MEMORY:\n      txt = \"SEC_E_INSUFFICIENT_MEMORY\";\n      break;\n    case SEC_E_INTERNAL_ERROR:\n      txt = \"SEC_E_INTERNAL_ERROR\";\n      break;\n    case SEC_E_INVALID_HANDLE:\n      txt = \"SEC_E_INVALID_HANDLE\";\n      break;\n    case SEC_E_INVALID_PARAMETER:\n      txt = \"SEC_E_INVALID_PARAMETER\";\n      break;\n    case SEC_E_INVALID_TOKEN:\n      txt = \"SEC_E_INVALID_TOKEN\";\n      break;\n    case SEC_E_ISSUING_CA_UNTRUSTED:\n      txt = \"SEC_E_ISSUING_CA_UNTRUSTED\";\n      break;\n    case SEC_E_ISSUING_CA_UNTRUSTED_KDC:\n      txt = \"SEC_E_ISSUING_CA_UNTRUSTED_KDC\";\n      break;\n    case SEC_E_KDC_CERT_EXPIRED:\n      txt = \"SEC_E_KDC_CERT_EXPIRED\";\n      break;\n    case SEC_E_KDC_CERT_REVOKED:\n      txt = \"SEC_E_KDC_CERT_REVOKED\";\n      break;\n    case SEC_E_KDC_INVALID_REQUEST:\n      txt = \"SEC_E_KDC_INVALID_REQUEST\";\n      break;\n    case SEC_E_KDC_UNABLE_TO_REFER:\n      txt = \"SEC_E_KDC_UNABLE_TO_REFER\";\n      break;\n    case SEC_E_KDC_UNKNOWN_ETYPE:\n      txt = \"SEC_E_KDC_UNKNOWN_ETYPE\";\n      break;\n    case SEC_E_LOGON_DENIED:\n      txt = \"SEC_E_LOGON_DENIED\";\n      break;\n    case SEC_E_MAX_REFERRALS_EXCEEDED:\n      txt = \"SEC_E_MAX_REFERRALS_EXCEEDED\";\n      break;\n    case SEC_E_MESSAGE_ALTERED:\n      txt = \"SEC_E_MESSAGE_ALTERED\";\n      break;\n    case SEC_E_MULTIPLE_ACCOUNTS:\n      txt = \"SEC_E_MULTIPLE_ACCOUNTS\";\n      break;\n    case SEC_E_MUST_BE_KDC:\n      txt = \"SEC_E_MUST_BE_KDC\";\n      break;\n    case SEC_E_NOT_OWNER:\n      txt = \"SEC_E_NOT_OWNER\";\n      break;\n    case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n      txt = \"SEC_E_NO_AUTHENTICATING_AUTHORITY\";\n      break;\n    case SEC_E_NO_CREDENTIALS:\n      txt = \"SEC_E_NO_CREDENTIALS\";\n      break;\n    case SEC_E_NO_IMPERSONATION:\n      txt = \"SEC_E_NO_IMPERSONATION\";\n      break;\n    case SEC_E_NO_IP_ADDRESSES:\n      txt = \"SEC_E_NO_IP_ADDRESSES\";\n      break;\n    case SEC_E_NO_KERB_KEY:\n      txt = \"SEC_E_NO_KERB_KEY\";\n      break;\n    case SEC_E_NO_PA_DATA:\n      txt = \"SEC_E_NO_PA_DATA\";\n      break;\n    case SEC_E_NO_S4U_PROT_SUPPORT:\n      txt = \"SEC_E_NO_S4U_PROT_SUPPORT\";\n      break;\n    case SEC_E_NO_TGT_REPLY:\n      txt = \"SEC_E_NO_TGT_REPLY\";\n      break;\n    case SEC_E_OUT_OF_SEQUENCE:\n      txt = \"SEC_E_OUT_OF_SEQUENCE\";\n      break;\n    case SEC_E_PKINIT_CLIENT_FAILURE:\n      txt = \"SEC_E_PKINIT_CLIENT_FAILURE\";\n      break;\n    case SEC_E_PKINIT_NAME_MISMATCH:\n      txt = \"SEC_E_PKINIT_NAME_MISMATCH\";\n      break;\n    case SEC_E_POLICY_NLTM_ONLY:\n      txt = \"SEC_E_POLICY_NLTM_ONLY\";\n      break;\n    case SEC_E_QOP_NOT_SUPPORTED:\n      txt = \"SEC_E_QOP_NOT_SUPPORTED\";\n      break;\n    case SEC_E_REVOCATION_OFFLINE_C:\n      txt = \"SEC_E_REVOCATION_OFFLINE_C\";\n      break;\n    case SEC_E_REVOCATION_OFFLINE_KDC:\n      txt = \"SEC_E_REVOCATION_OFFLINE_KDC\";\n      break;\n    case SEC_E_SECPKG_NOT_FOUND:\n      txt = \"SEC_E_SECPKG_NOT_FOUND\";\n      break;\n    case SEC_E_SECURITY_QOS_FAILED:\n      txt = \"SEC_E_SECURITY_QOS_FAILED\";\n      break;\n    case SEC_E_SHUTDOWN_IN_PROGRESS:\n      txt = \"SEC_E_SHUTDOWN_IN_PROGRESS\";\n      break;\n    case SEC_E_SMARTCARD_CERT_EXPIRED:\n      txt = \"SEC_E_SMARTCARD_CERT_EXPIRED\";\n      break;\n    case SEC_E_SMARTCARD_CERT_REVOKED:\n      txt = \"SEC_E_SMARTCARD_CERT_REVOKED\";\n      break;\n    case SEC_E_SMARTCARD_LOGON_REQUIRED:\n      txt = \"SEC_E_SMARTCARD_LOGON_REQUIRED\";\n      break;\n    case SEC_E_STRONG_CRYPTO_NOT_SUPPORTED:\n      txt = \"SEC_E_STRONG_CRYPTO_NOT_SUPPORTED\";\n      break;\n    case SEC_E_TARGET_UNKNOWN:\n      txt = \"SEC_E_TARGET_UNKNOWN\";\n      break;\n    case SEC_E_TIME_SKEW:\n      txt = \"SEC_E_TIME_SKEW\";\n      break;\n    case SEC_E_TOO_MANY_PRINCIPALS:\n      txt = \"SEC_E_TOO_MANY_PRINCIPALS\";\n      break;\n    case SEC_E_UNFINISHED_CONTEXT_DELETED:\n      txt = \"SEC_E_UNFINISHED_CONTEXT_DELETED\";\n      break;\n    case SEC_E_UNKNOWN_CREDENTIALS:\n      txt = \"SEC_E_UNKNOWN_CREDENTIALS\";\n      break;\n    case SEC_E_UNSUPPORTED_FUNCTION:\n      txt = \"SEC_E_UNSUPPORTED_FUNCTION\";\n      break;\n    case SEC_E_UNSUPPORTED_PREAUTH:\n      txt = \"SEC_E_UNSUPPORTED_PREAUTH\";\n      break;\n    case SEC_E_UNTRUSTED_ROOT:\n      txt = \"SEC_E_UNTRUSTED_ROOT\";\n      break;\n    case SEC_E_WRONG_CREDENTIAL_HANDLE:\n      txt = \"SEC_E_WRONG_CREDENTIAL_HANDLE\";\n      break;\n    case SEC_E_WRONG_PRINCIPAL:\n      txt = \"SEC_E_WRONG_PRINCIPAL\";\n      break;\n    case SEC_I_COMPLETE_AND_CONTINUE:\n      txt = \"SEC_I_COMPLETE_AND_CONTINUE\";\n      break;\n    case SEC_I_COMPLETE_NEEDED:\n      txt = \"SEC_I_COMPLETE_NEEDED\";\n      break;\n    case SEC_I_CONTEXT_EXPIRED:\n      txt = \"SEC_I_CONTEXT_EXPIRED\";\n      break;\n    case SEC_I_CONTINUE_NEEDED:\n      txt = \"SEC_I_CONTINUE_NEEDED\";\n      break;\n    case SEC_I_INCOMPLETE_CREDENTIALS:\n      txt = \"SEC_I_INCOMPLETE_CREDENTIALS\";\n      break;\n    case SEC_I_LOCAL_LOGON:\n      txt = \"SEC_I_LOCAL_LOGON\";\n      break;\n    case SEC_I_NO_LSA_CONTEXT:\n      txt = \"SEC_I_NO_LSA_CONTEXT\";\n      break;\n    case SEC_I_RENEGOTIATE:\n      txt = \"SEC_I_RENEGOTIATE\";\n      break;\n    case SEC_I_SIGNATURE_NEEDED:\n      txt = \"SEC_I_SIGNATURE_NEEDED\";\n      break;\n    default:\n      txt = \"Unknown error\";\n  }\n\n  if(err == SEC_E_OK)\n    strncpy(outbuf, txt, outmax);\n  else if(err == SEC_E_ILLEGAL_MESSAGE)\n    snprintf(outbuf, outmax,\n             \"SEC_E_ILLEGAL_MESSAGE (0x%04X%04X) - This error usually occurs \"\n             \"when a fatal SSL/TLS alert is received (e.g. handshake failed). \"\n             \"More detail may be available in the Windows System event log.\",\n             (err >> 16) & 0xffff, err & 0xffff);\n  else {\n    str = txtbuf;\n    snprintf(txtbuf, sizeof(txtbuf), \"%s (0x%04X%04X)\",\n             txt, (err >> 16) & 0xffff, err & 0xffff);\n    txtbuf[sizeof(txtbuf)-1] = '\\0';\n\n#ifdef _WIN32_WCE\n    {\n      wchar_t wbuf[256];\n      wbuf[0] = L'\\0';\n\n      if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS,\n                       NULL, err, LANG_NEUTRAL,\n                       wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL)) {\n        wcstombs(msgbuf, wbuf, sizeof(msgbuf)-1);\n        msg_formatted = TRUE;\n      }\n    }\n#else\n    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, LANG_NEUTRAL,\n                      msgbuf, sizeof(msgbuf)-1, NULL)) {\n      msg_formatted = TRUE;\n    }\n#endif\n    if(msg_formatted) {\n      msgbuf[sizeof(msgbuf)-1] = '\\0';\n      /* strip trailing '\\r\\n' or '\\n' */\n      if((p = strrchr(msgbuf, '\\n')) != NULL && (p - msgbuf) >= 2)\n         *p = '\\0';\n      if((p = strrchr(msgbuf, '\\r')) != NULL && (p - msgbuf) >= 1)\n         *p = '\\0';\n      msg = msgbuf;\n    }\n    if(msg)\n      snprintf(outbuf, outmax, \"%s - %s\", str, msg);\n    else\n      strncpy(outbuf, str, outmax);\n  }\n\n  if(old_errno != ERRNO)\n    SET_ERRNO(old_errno);\n\n#else\n\n  if(err == SEC_E_OK)\n    txt = \"No error\";\n  else\n    txt = \"Error\";\n\n  strncpy(outbuf, txt, outmax);\n\n#endif\n\n  outbuf[outmax] = '\\0';\n\n  return outbuf;\n}\n#endif /* USE_WINDOWS_SSPI */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/kwsys/DynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"Configure.hxx.in\"\n#endif\n\n// This file is actually 3 different implementations.\n// 1. HP machines which uses shl_load\n// 2. Mac OS X 10.2.x and earlier which uses NSLinkModule\n// 3. Windows which uses LoadLibrary\n// 4. Most unix systems (including Mac OS X 10.3 and later) which use dlopen\n// (default) Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n// ---------------------------------------------------------------\n// 1. Implementation for HPUX  machines\n#ifdef __hpux\n#include <errno.h>\n#include <dl.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n    return 0;\n    }\n  return !shl_unload(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer\nDynamicLoader::GetSymbolAddress(DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example, variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym (&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if(  errno == ENOEXEC\n    || errno == ENOSYM\n    || errno == EINVAL )\n    {\n    return strerror(errno);\n    }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //__hpux\n\n\n// ---------------------------------------------------------------\n// 2. Implementation for Mac OS X 10.2.x and earlier\n#ifdef __APPLE__\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#include <string.h> // for strlen\n#include <mach-o/dyld.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if( rc != NSObjectFileImageSuccess )\n    {\n    return 0;\n    }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n    NSLINKMODULE_OPTION_BINDNOW|NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary( DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void *result=0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  size_t len = sym.size();\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym+1, sym.c_str());\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym);\n  if(symbol)\n    {\n    result = NSAddressOfSymbol(symbol);\n    }\n\n  delete[] rsym;\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#endif // __APPLE__\n\n// ---------------------------------------------------------------\n// 3. Implementation for Windows win32 code but not cygwin\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length+1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete [] wchars;\n  return lh;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void *result;\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  size_t len = sym.size();\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym, sym.c_str());\n#else\n  const char *rsym = sym.c_str();\n#endif\n  result = (void*)GetProcAddress(lib, rsym);\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  delete[] rsym;\n#endif\n  // Hack to cast pointer-to-data to pointer-to-function.\n#ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#endif\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf=NULL;\n\n  FormatMessage(\n    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n    NULL,\n    GetLastError(),\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    (LPTSTR) &lpMsgBuf,\n    0,\n    NULL\n    );\n\n  if(!lpMsgBuf)\n    {\n    return NULL;\n    }\n\n  static char* str = 0;\n  delete [] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf)+1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree( lpMsgBuf );\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //_WIN32\n\n// ---------------------------------------------------------------\n// 4. Implementation for BeOS\n#if defined __BEOS__\n\n#include <string.h> // for strerror()\n\n#include <be/kernel/image.h>\n#include <be/support/Errors.h>\n\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\nstatic image_id last_dynamic_err = B_OK;\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0)\n    {\n    last_dynamic_err = rc;\n    return 0;\n    }\n\n  return rc+1;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n      return 0;\n    }\n  else\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib-1);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      return 0;\n      }\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n    }\n  else\n    {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc = get_image_symbol(lib-1,sym.c_str(),B_SYMBOL_TYPE_ANY,&result.pvoid);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n      }\n    }\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  const char *retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 5. Implementation for systems without dynamic libs\n// __gnu_blrts__ is IBM BlueGene/L\n// __LIBCATAMOUNT__ is defined on Catamount on Cray compute nodes\n#if defined(__gnu_blrts__) || defined(__LIBCATAMOUNT__) || defined(__CRAYXT_COMPUTE_LINUX_TARGET)\n#include <string.h> // for strerror()\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n    return 0;\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n    DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n  {\n  return \"General error\";\n  }\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n#ifdef __MINT__\n#define DYNAMICLOADER_DEFINED 1\n#define _GNU_SOURCE /* for program_invocation_name */\n#include <string.h>\n#include <malloc.h>\n#include <errno.h>\n#include <dld.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  char *name = (char *)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void *)name;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char *)lib, 0);\n  free(lib);\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 6. Implementation for default UNIX machines.\n// if nothing has been defined then use this\n#ifndef DYNAMICLOADER_DEFINED\n#define DYNAMICLOADER_DEFINED 1\n// Setup for most unix machines\n#include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const std::string& libname )\n{\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib)\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n    }\n  // else\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/kwsys/DynamicLoader.hxx.in": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#ifndef @KWSYS_NAMESPACE@_DynamicLoader_hxx\n#define @KWSYS_NAMESPACE@_DynamicLoader_hxx\n\n#include <@KWSYS_NAMESPACE@/Configure.hxx>\n#include <string>\n\n#if defined(__hpux)\n  #include <dl.h>\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  #include <windows.h>\n#elif defined(__APPLE__)\n  #include <AvailabilityMacros.h>\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    #include <mach-o/dyld.h>\n  #endif\n#elif defined(__BEOS__)\n  #include <be/kernel/image.h>\n#endif\n\nnamespace @KWSYS_NAMESPACE@\n{\n/** \\class DynamicLoader\n * \\brief Portable loading of dynamic libraries or dll's.\n *\n * DynamicLoader provides a portable interface to loading dynamic\n * libraries or dll's into a process.\n *\n * Directory currently works with Windows, Apple, HP-UX and Unix (POSIX)\n * operating systems\n *\n * \\warning dlopen on *nix system works the following way:\n * If filename contains a slash (\"/\"), then it is interpreted as a (relative\n * or absolute) pathname.  Otherwise, the dynamic linker searches for the\n * library as follows : see ld.so(8) for further details):\n * Whereas this distinction does not exist on Win32. Therefore ideally you\n * should be doing full path to garantee to have a consistent way of dealing\n * with dynamic loading of shared library.\n *\n * \\warning the Cygwin implementation do not use the Win32 HMODULE. Put extra\n * condition so that we can include the correct declaration (POSIX)\n */\n\nclass @KWSYS_NAMESPACE@_EXPORT DynamicLoader\n{\npublic:\n// Ugly stuff for library handles\n// They are different on several different OS's\n#if defined(__hpux)\n  typedef shl_t LibraryHandle;\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  typedef HMODULE LibraryHandle;\n#elif defined(__APPLE__)\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    typedef NSModule LibraryHandle;\n  #else\n    typedef void* LibraryHandle;\n  #endif\n#elif defined(__BEOS__)\n  typedef image_id LibraryHandle;\n#else  // POSIX\n  typedef void* LibraryHandle;\n#endif\n\n  // Return type from DynamicLoader::GetSymbolAddress.\n  typedef void (*SymbolPointer)();\n\n  /** Load a dynamic library into the current process.\n   * The returned LibraryHandle can be used to access the symbols in the\n   * library. */\n  static LibraryHandle OpenLibrary(const std::string&);\n\n  /** Attempt to detach a dynamic library from the\n   * process.  A value of true is returned if it is sucessful. */\n  static int CloseLibrary(LibraryHandle);\n\n  /** Find the address of the symbol in the given library. */\n  static SymbolPointer GetSymbolAddress(LibraryHandle, const std::string&);\n\n  /** Return the default module prefix for the current platform.  */\n  static const char* LibPrefix() { return \"@KWSYS_DynamicLoader_PREFIX@\"; }\n\n  /** Return the default module suffix for the current platform.  */\n  static const char* LibExtension() { return \"@KWSYS_DynamicLoader_SUFFIX@\"; }\n\n  /** Return the last error produced from a calls made on this class. */\n  static const char* LastError();\n}; // End Class: DynamicLoader\n\n} // namespace @KWSYS_NAMESPACE@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/kwsys/testDynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#if defined(__BEOS__) || defined(__HAIKU__)\n#include <be/kernel/OS.h>  /* disable_debugger() API. */\n#endif\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n#endif\n\n#include <string>\n#include <iostream>\n\n// Include with <> instead of \"\" to avoid getting any in-source copy\n// left on disk.\n#include <testSystemTools.h>\n\nstatic std::string GetLibName(const char* lname)\n{\n  // Construct proper name of lib\n  std::string slname;\n  slname = EXECUTABLE_OUTPUT_PATH;\n#ifdef CMAKE_INTDIR\n  slname += \"/\";\n  slname += CMAKE_INTDIR;\n#endif\n  slname += \"/\";\n  slname += kwsys::DynamicLoader::LibPrefix();\n  slname += lname;\n  slname += kwsys::DynamicLoader::LibExtension();\n\n  return slname;\n}\n\n/* libname = Library name (proper prefix, proper extension)\n * System  = symbol to lookup in libname\n * r1: should OpenLibrary succeed ?\n * r2: should GetSymbolAddress succeed ?\n * r3: should CloseLibrary succeed ?\n */\nint TestDynamicLoader(const char* libname, const char* symbol, int r1, int r2, int r3)\n{\n  std::cerr << \"Testing: \" << libname << std::endl;\n  kwsys::DynamicLoader::LibraryHandle l\n    = kwsys::DynamicLoader::OpenLibrary(libname);\n  // If result is incompatible with expectation just fails (xor):\n  if( (r1 && !l) || (!r1 && l) )\n    {\n    std::cerr\n      << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n    }\n  kwsys::DynamicLoader::SymbolPointer f\n    = kwsys::DynamicLoader::GetSymbolAddress(l, symbol);\n  if( (r2 && !f) || (!r2 && f) )\n    {\n    std::cerr\n      << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n    }\n#ifndef __APPLE__\n  int s = kwsys::DynamicLoader::CloseLibrary(l);\n  if( (r3 && !s) || (!r3 && s) )\n    {\n    std::cerr\n      << kwsys::DynamicLoader::LastError() << std::endl;\n    return 1;\n    }\n#else\n  (void)r3;\n#endif\n  return 0;\n}\n\nint testDynamicLoader(int argc, char *argv[])\n{\n#if defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n#elif defined(__BEOS__) || defined(__HAIKU__)\n  disable_debugger(1);\n#endif\n  int res = 0;\n  if( argc == 3 )\n    {\n    // User specify a libname and symbol to check.\n    res = TestDynamicLoader(argv[1], argv[2],1,1,1);\n    return res;\n    }\n\n// dlopen() on Syllable before 11/22/2007 doesn't return 0 on error\n#ifndef __SYLLABLE__\n  // Make sure that inexistent lib is giving correct result\n  res += TestDynamicLoader(\"azerty_\", \"foo_bar\",0,0,0);\n  // Make sure that random binary file cannot be assimilated as dylib\n  res += TestDynamicLoader(TEST_SYSTEMTOOLS_SOURCE_DIR \"/testSystemTools.bin\", \"wp\",0,0,0);\n#endif\n\n#ifdef __linux__\n  // This one is actually fun to test, since dlopen is by default loaded...wonder why :)\n  res += TestDynamicLoader(\"foobar.lib\", \"dlopen\",0,1,0);\n  res += TestDynamicLoader(\"libdl.so\", \"dlopen\",1,1,1);\n  res += TestDynamicLoader(\"libdl.so\", \"TestDynamicLoader\",1,0,1);\n#endif\n  // Now try on the generated library\n  std::string libname = GetLibName(KWSYS_NAMESPACE_STRING \"TestDynload\");\n  res += TestDynamicLoader(libname.c_str(), \"dummy\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderSymbolPointer\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderSymbolPointer\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderData\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderData\",1,0,1);\n\n  return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/KDE3Macros.cmake": "#\n\n#=============================================================================\n# Copyright 2006-2009 Kitware, Inc.\n# Copyright 2006 Alexander Neundorf <neundorf@kde.org>\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# See FindKDE3.cmake for documentation.\n#\n# this file contains the following macros:\n# KDE3_ADD_DCOP_SKELS\n# KDE3_ADD_DCOP_STUBS\n# KDE3_ADD_MOC_FILES\n# KDE3_ADD_UI_FILES\n# KDE3_ADD_KCFG_FILES\n# KDE3_AUTOMOC\n# KDE3_INSTALL_LIBTOOL_FILE\n# KDE3_CREATE_FINAL_FILE\n# KDE3_ADD_KPART\n# KDE3_ADD_KDEINIT_EXECUTABLE\n# KDE3_ADD_EXECUTABLE\n\n\n#neundorf@kde.org\n\ninclude(AddFileDependencies)\n\n#create the kidl and skeletion file for dcop stuff\n#usage: KDE_ADD_COP_SKELS(foo_SRCS ${dcop_headers})\nmacro(KDE3_ADD_DCOP_SKELS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_skel ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_skel.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n         set(HAVE_${_basename}_KIDL_RULE ON)\n\n          add_custom_command(OUTPUT ${_kidl}\n          COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n          ARGS ${_tmp_FILE} > ${_kidl}\n          DEPENDS ${_tmp_FILE}\n         )\n\n       endif ()\n\n      if (NOT HAVE_${_basename}_SKEL_RULE)\n        set(HAVE_${_basename}_SKEL_RULE ON)\n\n       add_custom_command(OUTPUT ${_skel}\n          COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n          ARGS --c++-suffix cpp --no-signals --no-stub ${_kidl}\n          DEPENDS ${_kidl}\n          )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_skel})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_DCOP_STUBS _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      set(_stub_CPP ${CMAKE_CURRENT_BINARY_DIR}/${_basename}_stub.cpp)\n      set(_kidl ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.kidl)\n\n      if (NOT HAVE_${_basename}_KIDL_RULE)\n        set(HAVE_${_basename}_KIDL_RULE ON)\n\n\n        add_custom_command(OUTPUT ${_kidl}\n           COMMAND ${KDE3_DCOPIDL_EXECUTABLE}\n           ARGS ${_tmp_FILE} > ${_kidl}\n           DEPENDS ${_tmp_FILE}\n           )\n\n      endif ()\n\n\n      if (NOT HAVE_${_basename}_STUB_RULE)\n        set(HAVE_${_basename}_STUB_RULE ON)\n\n        add_custom_command(OUTPUT ${_stub_CPP}\n           COMMAND ${KDE3_DCOPIDL2CPP_EXECUTABLE}\n           ARGS --c++-suffix cpp --no-signals --no-skel ${_kidl}\n           DEPENDS ${_kidl}\n         )\n\n      endif ()\n\n      set(${_sources} ${${_sources}} ${_stub_CPP})\n\n   endforeach ()\n\nendmacro()\n\n\nmacro(KDE3_ADD_KCFG_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n\n      file(READ ${_tmp_FILE} _contents)\n      string(REGEX REPLACE \"^(.*\\n)?File=([^\\n]+)\\n.*$\" \"\\\\2\"  _kcfg_FILE \"${_contents}\")\n\n      set(_src_FILE    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_header_FILE ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n\n      add_custom_command(OUTPUT ${_src_FILE}\n         COMMAND ${KDE3_KCFGC_EXECUTABLE}\n         ARGS ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} ${_tmp_FILE}\n         DEPENDS ${_tmp_FILE} ${CMAKE_CURRENT_SOURCE_DIR}/${_kcfg_FILE} )\n\n      set(${_sources} ${${_sources}} ${_src_FILE})\n\n   endforeach ()\n\nendmacro()\n\n\n#create the moc files and add them to the list of sources\n#usage: KDE_ADD_MOC_FILES(foo_SRCS ${moc_headers})\nmacro(KDE3_ADD_MOC_FILES _sources)\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_tmp_FILE} -o ${_moc}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      set(${_sources} ${${_sources}} ${_moc})\n\n   endforeach ()\nendmacro()\n\n\nget_filename_component( KDE3_MODULE_DIR  ${CMAKE_CURRENT_LIST_FILE} PATH)\n\n#create the implementation files from the ui files and add them to the list of sources\n#usage: KDE_ADD_UI_FILES(foo_SRCS ${ui_files})\nmacro(KDE3_ADD_UI_FILES _sources )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_tmp_FILE ${_current_FILE} ABSOLUTE)\n\n      get_filename_component(_basename ${_tmp_FILE} NAME_WE)\n      set(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)\n      set(_src ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)\n      set(_moc ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc.cpp)\n\n      add_custom_command(OUTPUT ${_header}\n         COMMAND ${QT_UIC_EXECUTABLE}\n         ARGS  -L ${KDE3_LIB_DIR}/kde3/plugins/designer -nounload -o ${_header} ${CMAKE_CURRENT_SOURCE_DIR}/${_current_FILE}\n         DEPENDS ${_tmp_FILE}\n      )\n\n      add_custom_command(OUTPUT ${_src}\n         COMMAND ${CMAKE_COMMAND}\n         ARGS\n         -DKDE_UIC_PLUGIN_DIR:FILEPATH=${KDE3_LIB_DIR}/kde3/plugins/designer\n         -DKDE_UIC_EXECUTABLE:FILEPATH=${QT_UIC_EXECUTABLE}\n         -DKDE_UIC_FILE:FILEPATH=${_tmp_FILE}\n         -DKDE_UIC_CPP_FILE:FILEPATH=${_src}\n         -DKDE_UIC_H_FILE:FILEPATH=${_header}\n         -P ${KDE3_MODULE_DIR}/kde3uic.cmake\n         DEPENDS ${_header}\n      )\n\n      add_custom_command(OUTPUT ${_moc}\n         COMMAND ${QT_MOC_EXECUTABLE}\n         ARGS ${_header} -o ${_moc}\n         DEPENDS ${_header}\n      )\n\n      set(${_sources} ${${_sources}} ${_src} ${_moc} )\n\n   endforeach ()\nendmacro()\n\n\nmacro(KDE3_AUTOMOC)\n   set(_matching_FILES )\n   foreach (_current_FILE ${ARGN})\n\n      get_filename_component(_abs_FILE ${_current_FILE} ABSOLUTE)\n\n      # if \"SKIP_AUTOMOC\" is set to true, we will not handle this file here.\n      # here. this is required to make bouic work correctly:\n      # we need to add generated .cpp files to the sources (to compile them),\n      # but we cannot let automoc handle them, as the .cpp files don't exist yet when\n      # cmake is run for the very first time on them -> however the .cpp files might\n      # exist at a later run. at that time we need to skip them, so that we don't add two\n      # different rules for the same moc file\n      get_source_file_property(_skip ${_abs_FILE} SKIP_AUTOMOC)\n\n      if (EXISTS ${_abs_FILE} AND NOT _skip)\n\n         file(STRINGS ${_abs_FILE} _match REGEX \"#include +[^ ]+\\\\.moc[\\\">]\")\n\n         get_filename_component(_abs_PATH ${_abs_FILE} PATH)\n\n         foreach (_current_MOC_INC IN LISTS _match)\n            string(REGEX MATCH \"[^ <\\\"]+\\\\.moc\" _current_MOC \"${_current_MOC_INC}\")\n\n            get_filename_component(_basename ${_current_MOC} NAME_WE)\n#            set(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)\n            set(_header ${_abs_PATH}/${_basename}.h)\n            set(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})\n\n            add_custom_command(OUTPUT ${_moc}\n               COMMAND ${QT_MOC_EXECUTABLE}\n               ARGS ${_header} -o ${_moc}\n               DEPENDS ${_header}\n            )\n\n            ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})\n\n         endforeach ()\n         unset(_match)\n         unset(_header)\n         unset(_moc)\n      endif ()\n   endforeach ()\nendmacro()\n\n# only used internally by KDE3_INSTALL_ICONS\nmacro (_KDE3_ADD_ICON_INSTALL_RULE _install_SCRIPT _install_PATH _group _orig_NAME _install_NAME)\n\n   # if the string doesn't match the pattern, the result is the full string, so all three have the same content\n   if (NOT ${_group} STREQUAL ${_install_NAME} )\n      set(_icon_GROUP \"actions\")\n\n      if (${_group} STREQUAL \"mime\")\n         set(_icon_GROUP  \"mimetypes\")\n      endif ()\n\n      if (${_group} STREQUAL \"filesys\")\n         set(_icon_GROUP  \"filesystems\")\n      endif ()\n\n      if (${_group} STREQUAL \"device\")\n         set(_icon_GROUP  \"devices\")\n      endif ()\n\n      if (${_group} STREQUAL \"app\")\n         set(_icon_GROUP  \"apps\")\n      endif ()\n\n      if (${_group} STREQUAL \"action\")\n         set(_icon_GROUP  \"actions\")\n      endif ()\n\n#      message(STATUS \"icon: ${_current_ICON} size: ${_size} group: ${_group} name: ${_name}\" )\n   install(FILES ${_orig_NAME} DESTINATION ${_install_PATH}/${_icon_GROUP}/ RENAME ${_install_NAME} )\n   endif ()\n\nendmacro ()\n\n\nmacro (KDE3_INSTALL_ICONS _theme )\n   set(_defaultpath \"${CMAKE_INSTALL_PREFIX}/share/icons\")\n   # first the png icons\n   file(GLOB _icons *.png)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\1\" _size  \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\2\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/[a-zA-Z]+([0-9]+)\\\\-([a-z]+)\\\\-(.+\\\\.png)$\" \"\\\\3\" _name  \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n         ${_defaultpath}/${_theme}/${_size}x${_size}\n         ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\n   # and now the svg icons\n   file(GLOB _icons *.svgz)\n   foreach (_current_ICON ${_icons} )\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\1\" _group \"${_current_ICON}\")\n      string(REGEX REPLACE \"^.*/crsc\\\\-([a-z]+)\\\\-(.+\\\\.svgz)$\" \"\\\\2\" _name \"${_current_ICON}\")\n      _KDE3_ADD_ICON_INSTALL_RULE(${CMAKE_CURRENT_BINARY_DIR}/install_icons.cmake\n                                 ${_defaultpath}/${_theme}/scalable\n                                 ${_group} ${_current_ICON} ${_name})\n   endforeach ()\n\nendmacro ()\n\nmacro(KDE3_INSTALL_LIBTOOL_FILE _target)\n   get_target_property(_target_location ${_target} LOCATION)\n\n   get_filename_component(_laname ${_target_location} NAME_WE)\n   get_filename_component(_soname ${_target_location} NAME)\n   set(_laname ${CMAKE_CURRENT_BINARY_DIR}/${_laname}.la)\n\n   file(WRITE ${_laname} \"# ${_laname} - a libtool library file, generated by cmake \\n\")\n   file(APPEND ${_laname} \"# The name that we can dlopen(3).\\n\")\n   file(APPEND ${_laname} \"dlname='${_soname}'\\n\")\n   file(APPEND ${_laname} \"# Names of this library\\n\")\n   if(CYGWIN)\n     file(APPEND ${_laname} \"library_names='${_soname}'\\n\")\n   else()\n     file(APPEND ${_laname} \"library_names='${_soname} ${_soname} ${_soname}'\\n\")\n   endif()\n   file(APPEND ${_laname} \"# The name of the static archive\\n\")\n   file(APPEND ${_laname} \"old_library=''\\n\")\n   file(APPEND ${_laname} \"# Libraries that this one depends upon.\\n\")\n   file(APPEND ${_laname} \"dependency_libs=''\\n\")\n#   file(APPEND ${_laname} \"dependency_libs='${${_target}_LIB_DEPENDS}'\\n\")\n   file(APPEND ${_laname} \"# Version information.\\ncurrent=0\\nage=0\\nrevision=0\\n\")\n   file(APPEND ${_laname} \"# Is this an already installed library?\\ninstalled=yes\\n\")\n   file(APPEND ${_laname} \"# Should we warn about portability when linking against -modules?\\nshouldnotlink=yes\\n\")\n   file(APPEND ${_laname} \"# Files to dlopen/dlpreopen\\ndlopen=''\\ndlpreopen=''\\n\")\n   file(APPEND ${_laname} \"# Directory that this library needs to be installed in:\\n\")\n   file(APPEND ${_laname} \"libdir='${CMAKE_INSTALL_PREFIX}/lib/kde3'\\n\")\n\n   install_files(${KDE3_LIBTOOL_DIR} FILES ${_laname})\nendmacro()\n\n\nmacro(KDE3_CREATE_FINAL_FILE _filename)\n   file(WRITE ${_filename} \"//autogenerated file\\n\")\n   foreach (_current_FILE ${ARGN})\n      file(APPEND ${_filename} \"#include \\\"${_current_FILE}\\\"\\n\")\n   endforeach ()\n\nendmacro()\n\n\n# option(KDE3_ENABLE_FINAL \"Enable final all-in-one compilation\")\noption(KDE3_BUILD_TESTS  \"Build the tests\")\n\n\nmacro(KDE3_ADD_KPART _target_NAME _with_PREFIX)\n#is the first argument is \"WITH_PREFIX\" then keep the standard \"lib\" prefix, otherwise SET the prefix empty\n   if (${_with_PREFIX} STREQUAL \"WITH_PREFIX\")\n      set(_first_SRC)\n   else ()\n      set(_first_SRC ${_with_PREFIX})\n   endif ()\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${_first_SRC} ${ARGN})\n#       add_library(${_target_NAME} MODULE  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(${_target_NAME} MODULE ${_first_SRC} ${ARGN})\n#    endif ()\n\n   if(_first_SRC)\n      set_target_properties(${_target_NAME} PROPERTIES PREFIX \"\")\n   endif()\n\n   KDE3_INSTALL_LIBTOOL_FILE(${_target_NAME})\n\nendmacro()\n\n\nmacro(KDE3_ADD_KDEINIT_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_library(kdeinit_${_target_NAME} SHARED  ${_target_NAME}_final.cpp)\n#    else ()\n   add_library(kdeinit_${_target_NAME} SHARED ${ARGN} )\n#    endif ()\n\n   configure_file(${KDE3_MODULE_DIR}/kde3init_dummy.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp)\n\n   add_executable( ${_target_NAME} ${CMAKE_CURRENT_BINARY_DIR}/${_target_NAME}_dummy.cpp )\n   target_link_libraries( ${_target_NAME} kdeinit_${_target_NAME} )\n\nendmacro()\n\n\nmacro(KDE3_ADD_EXECUTABLE _target_NAME )\n\n#    if (KDE3_ENABLE_FINAL)\n#       KDE3_CREATE_FINAL_FILE(${_target_NAME}_final.cpp ${ARGN})\n#       add_executable(${_target_NAME} ${_target_NAME}_final.cpp)\n#    else ()\n   add_executable(${_target_NAME} ${ARGN} )\n#    endif ()\n\nendmacro()\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/Platform/Linux-Intel.cmake": "\n#=============================================================================\n# Copyright 2002-2009 Kitware, Inc.\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_INTEL)\n  return()\nendif()\nset(__LINUX_COMPILER_INTEL 1)\n\nif(NOT XIAR)\n  set(_intel_xiar_hints)\n  foreach(lang C CXX Fortran)\n    if(IS_ABSOLUTE \"${CMAKE_${lang}_COMPILER}\")\n      get_filename_component(_hint \"${CMAKE_${lang}_COMPILER}\" PATH)\n      list(APPEND _intel_xiar_hints ${_hint})\n    endif()\n  endforeach()\n  find_program(XIAR NAMES xiar HINTS ${_intel_xiar_hints})\n  mark_as_advanced(XIAR)\nendif()\n\nmacro(__linux_compiler_intel lang)\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIC \"-fPIC\")\n  set(CMAKE_${lang}_COMPILE_OPTIONS_PIE \"-fPIE\")\n  set(CMAKE_SHARED_LIBRARY_${lang}_FLAGS \"-fPIC\")\n  set(CMAKE_SHARED_LIBRARY_CREATE_${lang}_FLAGS \"-shared\")\n\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\n\n  if(XIAR)\n    # INTERPROCEDURAL_OPTIMIZATION\n    set(CMAKE_${lang}_COMPILE_OPTIONS_IPO -ipo)\n    set(CMAKE_${lang}_CREATE_STATIC_LIBRARY_IPO\n      \"${XIAR} cr <TARGET> <LINK_FLAGS> <OBJECTS> \"\n      \"${XIAR} -s <TARGET> \")\n  endif()\n\n  if(NOT CMAKE_${lang}_COMPILER_VERSION VERSION_LESS 12.0)\n    set(CMAKE_${lang}_COMPILE_OPTIONS_VISIBILITY \"-fvisibility=\")\n  endif()\nendmacro()\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/Platform/Linux-GNU.cmake": "\n#=============================================================================\n# Copyright 2010 Kitware, Inc.\n#\n# Distributed under the OSI-approved BSD License (the \"License\");\n# see accompanying file Copyright.txt for details.\n#\n# This software is distributed WITHOUT ANY WARRANTY; without even the\n# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n# See the License for more information.\n#=============================================================================\n# (To distribute this file outside of CMake, substitute the full\n#  License text for the above reference.)\n\n# This module is shared by multiple languages; use include blocker.\nif(__LINUX_COMPILER_GNU)\n  return()\nendif()\nset(__LINUX_COMPILER_GNU 1)\n\nmacro(__linux_compiler_gnu lang)\n  # We pass this for historical reasons.  Projects may have\n  # executables that use dlopen but do not set ENABLE_EXPORTS.\n  set(CMAKE_SHARED_LIBRARY_LINK_${lang}_FLAGS \"-rdynamic\")\nendmacro()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Templates/Windows/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectLocal/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProject/gitrepo-sub.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/StringFileTest/test.utf8",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/CommandLine/cmake_depends/test_UTF-16LE.h",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/configure_file/UTF32LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/configure_file/UTF16LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/configure_file/UTF16BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/configure_file/UTF32BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/string/UTF-32BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/string/UTF-32LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/string/UTF-16BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/RunCMake/string/UTF-16LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ExternalProjectUpdate/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimplePixelShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Direct3DApp1_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimpleVertexShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSXaml/VSXaml_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSXaml/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSXaml/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSXaml/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Tests/VSXaml/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Sphinx/static/cmake-logo-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Sphinx/static/cmake-favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample2.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample1.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample3.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/libbz2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/libbz2.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample2.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample1.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample1.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/sample2.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmbzip2/dlltest.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/CMakeLists.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/lib/libcurl.rc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/lib/krb5.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/lib/security.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/cmcurl/lib/cookie.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Release/cpack_wix_ui_banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Utilities/Release/cpack_wix_ui_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.4.3-5h5dmxyxt7nzf3xtpor4s6v3ok33xfkw/spack-src/Modules/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 9099
}