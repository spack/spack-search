{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Trace/src/ESMCI_Trace.C": "// $Id$\n/*\n * Writes trace events to the file system.\n *\n * Earth System Modeling Framework\n * Copyright 2002-2020, University Corporation for Atmospheric Research,\n * Massachusetts Institute of Technology, Geophysical Fluid Dynamics\n * Laboratory, University of Michigan, National Centers for Environmental\n * Prediction, Los Alamos National Laboratory, Argonne National Laboratory,\n * NASA Goddard Space Flight Center.\n * Licensed under the University of Illinois-NCSA License.\n */\n\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <map>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifndef ESMF_OS_MinGW\n#include <unistd.h>\n#else\n#include <Winsock.h>\n#endif\n\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_Util.h\"\n#include \"ESMCI_LogErr.h\"\n#include \"ESMCI_VM.h\"\n#include \"ESMCI_Trace.h\"\n#include \"ESMCI_VMKernel.h\"\n#include \"ESMCI_HashMap.h\"\n#include \"ESMCI_RegionNode.h\"\n#include \"ESMCI_RegionSummary.h\"\n#include \"ESMCI_ComponentInfo.h\"\n#include \"ESMCI_TraceUtil.h\"\n#include \"ESMCI_Comp.h\"\n#include <esmftrc.h>\n\n#ifndef ESMF_OS_MinGW\n#define TRACE_DIR_PERMISSIONS (S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)\n#else\n#define TRACE_DIR_PERMISSIONS (S_IRWXU)\n#endif\n\n#define EVENT_BUF_SIZE_DEFAULT 4096\n#define EVENT_BUF_SIZE_EAGER 1024\n#define REGION_HASHTABLE_SIZE 100\n#define VMID_MAP_SIZE 10000\n\nusing std::string;\nusing std::vector;\nusing std::stringstream;\nusing std::ofstream;\nusing std::map;\n\nnamespace ESMCI {\n\n  struct StringHashF {\n    unsigned long operator()(const string& s) const {\n      unsigned long hash = 5381;\n      int c;\n      const char *str = s.c_str();\n      while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n      //printf(\"hash for %s = %d\\n\", s.c_str(), hash % REGION_HASHTABLE_SIZE);\n      return hash % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  struct ESMFPhaseHashF {\n    unsigned long operator()(const ESMFPhaseId& phaseId) const {\n      return phaseId.hashcode() % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  struct ESMFIdHashF {\n    unsigned long operator()(const ESMFId& esmfId) const {\n      return esmfId.hashcode() % REGION_HASHTABLE_SIZE;\n    }\n  };\n\n  static bool traceInitialized = false;  // is trace ready for events?\n  static bool traceLocalPet = false;     // is tracing on for this PET?\n  static bool profileLocalPet = false;   // is profiling on for this PET?\n  static bool profileOutputToLog = false;    // output to EMSF log?\n  static bool profileOutputToFile = false;   // output to text file?\n  static bool profileOutputToBinary = false; // output to binary trace?\n  static bool profileOutputSummary = false;   // output aggregate profile on root PET?\n\n  static uint16_t next_local_id() {\n    static uint16_t next = 1;\n    if (next > REGION_MAX_COUNT) {\n      throw std::range_error(\"Out of space for trace regions\");\n    }\n    return next++;\n  }\n\n  /*\n    Timed regions are defined by either:\n     1) a component phase represented by (vmid, baseid, method, phase), or\n     2) a user-defined region name (from ESMF_TraceRegionEnter()/Exit() calls)\n\n    Both are mapped to a single integer id for the region.  In the trace\n    we output a \"definition\" event for each region, which includes the\n    region id and either the user-defined name or the (vmid, baseid, method, phase)\n    tuple.  The trace post-processor can then translate the ids back to\n    meaningful names.  Using only integer ids reduces the size of the trace files.\n\n    userRegionMap:  maps from user-defined name to region id\n    phaseRegionMap:  maps from phase (vmid,baseid,method,phase) to region id\n\n    componentInfoMap:  maps from (vmid,baseid) to an object\n                       for keeping track of component information\n\n   */\n\n  static HashMap<string, uint16_t, REGION_HASHTABLE_SIZE, StringHashF> userRegionMap;\n  static HashMap<ESMFPhaseId, uint16_t, REGION_HASHTABLE_SIZE, ESMFPhaseHashF> phaseRegionMap;\n  static HashMap<ESMFId, ComponentInfo *, REGION_HASHTABLE_SIZE, ESMFIdHashF> componentInfoMap;\n\n  static RegionNode rootRegionNode(NULL, next_local_id(), false);\n  static RegionNode *currentRegionNode = &rootRegionNode;\n\n#ifndef ESMF_NO_DLFCN\n  static int (*notify_wrappers)(int initialized) = NULL;\n#endif\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceMapVmId()\"\n  int TraceMapVmId(VMId *vmid, int *rc) {\n\n    //this data structure used to map VMIds(vmKey,localid)\n    //to an integer id\n    static VMId vmIdMap[VMID_MAP_SIZE];\n    static int nextVmId = 0;\n\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    int foundIdx;\n    //search backward - vm more likely to be at the end\n    for (foundIdx=nextVmId-1; foundIdx >= 0; foundIdx--) {\n      if (VMIdCompare(vmid, &(vmIdMap[foundIdx]))) {\n        if (rc!=NULL) *rc = ESMF_SUCCESS;\n        return foundIdx;\n      }\n    }\n    if (nextVmId >= VMID_MAP_SIZE) {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                    \"Out of VmIdMap space inside tracing\", ESMC_CONTEXT, rc);\n      return -1;\n    }\n    else {\n      localrc = (&vmIdMap[nextVmId])->create();\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n                                        ESMC_CONTEXT, rc))\n        return -1;\n      VMIdCopy(&(vmIdMap[nextVmId]), vmid);\n      foundIdx = nextVmId;\n      nextVmId++;\n\n      if (rc!=NULL) *rc=ESMF_SUCCESS;\n      return foundIdx;\n    }\n  }\n\n  bool TraceInitialized() {\n    return traceInitialized;\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::CheckPETList\"\n  static bool CheckPETList(string petList, int petToCheck, int *rc) {\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n    bool invalidFormat = false;\n    const vector<string> listItems = split(trim(petList), \" \");\n\n    for (unsigned i = 0; i < listItems.size(); i++) {\n      if (listItems.at(i).find(\"-\") != string::npos) {\n        vector<string> petRange = split(trim(listItems.at(i)), \"-\");\n        if (petRange.size() == 2) {\n          int low, high;\n          stringstream lowss(trim(petRange.at(0)));\n          stringstream highss(trim(petRange.at(1)));\n          if (!(lowss >> low).fail() && !(highss >> high).fail()) {\n            //printf(\"low=%d, high=%d\\n\", low, high);\n            if (petToCheck >= low && petToCheck <= high) {\n              return true;\n            }\n          }\n          else {\n            invalidFormat = true;\n          }\n        }\n        else {\n          invalidFormat = true;\n        }\n      }\n      else {\n        int pet = -1;\n        stringstream ss(trim(listItems.at(i)));\n        ss >> pet;\n        if(!(ss.fail())) {\n          if (petToCheck == pet) {\n            return true;\n          }\n        }\n        else {\n          invalidFormat = true;\n        }\n      }\n      if (invalidFormat) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                                      \"Invalid PET list format.\",\n                                      ESMC_CONTEXT, rc);\n        return false;\n      }\n\n    }\n\n    //pet not found in list\n    return false;\n}\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::GlobalProfileOptions()\"\n  static void GlobalProfileOptions(int *traceIsOn, int *profileIsOn, int *rc) {\n    *rc = ESMC_RC_NOT_IMPL;\n    if (traceIsOn != NULL) {\n      *traceIsOn = 0;\n      char const *envVar = VM::getenv(\"ESMF_RUNTIME_TRACE\");\n      if (envVar != NULL) {\n        std::string value(envVar);\n        size_t index;\n        index = value.find(\"on\");\n        if (index == std::string::npos)\n          index = value.find(\"ON\");\n        if (index != std::string::npos){\n          *traceIsOn=1;\n        }\n      }\n    }\n    if (profileIsOn != NULL) {\n      *profileIsOn = 0;\n      char const *envVar = VM::getenv(\"ESMF_RUNTIME_PROFILE\");\n      if (envVar != NULL) {\n        std::string value(envVar);\n        size_t index;\n        index = value.find(\"on\");\n        if (index == std::string::npos)\n          index = value.find(\"ON\");\n        if (index != std::string::npos){\n          *profileIsOn=1;\n        }\n      }\n    }\n    *rc = ESMF_SUCCESS;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::ProfileIsEnabledForPET()\"\n  static bool ProfileIsEnabledForPET(int petToCheck, int *rc) {\n    int localrc;\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n    int tracingEnabled = 0;\n    int profilingEnabled = 0;\n    GlobalProfileOptions(&tracingEnabled, &profilingEnabled, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return false;\n\n    if (profilingEnabled == 0) return false;\n\n    //always profile PET 0?\n    if (petToCheck == 0) return true;\n\n    char const *envVar = VM::getenv(\"ESMF_RUNTIME_PROFILE_PETLIST\");\n    if (envVar != NULL) {\n      string envStr(envVar);\n      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Invalid format in ESMF_RUNTIME_PROFILE_PETLIST environment variable.\", ESMC_CONTEXT, rc))\n        return false;\n      return inPetList;\n    }\n    else {\n      //default to profile all PETs\n      return true;\n    }\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceIsEnabledForPET()\"\n  static bool TraceIsEnabledForPET(int petToCheck, int *rc){\n    int localrc;\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n    //first check if tracing is enabled\n    int tracingEnabled = 0;\n    int profilingEnabled = 0;\n    GlobalProfileOptions(&tracingEnabled, &profilingEnabled, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return false;\n\n    if (tracingEnabled == 0) return false;\n\n    //always trace PET 0\n    if (petToCheck == 0) return true;\n\n    char const *envVar = VM::getenv(\"ESMF_RUNTIME_TRACE_PETLIST\");\n    if (envVar != NULL) {\n      string envStr(envVar);\n      bool inPetList = CheckPETList(envStr, petToCheck, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Invalid format in ESMF_RUNTIME_TRACE_PETLIST environment variable.\", ESMC_CONTEXT, rc))\n        return false;\n      return inPetList;\n    }\n    else {\n      //default to trace all PETs\n      return true;\n    }\n\n  }\n\n  //global context\n  static struct esmftrc_platform_filesys_ctx *traceCtx = NULL;\n\n  static struct esmftrc_default_ctx *esmftrc_platform_get_default_ctx() {\n    return &traceCtx->ctx;\n  }\n\n  static void write_packet(struct esmftrc_platform_filesys_ctx *ctx) {\n    size_t nmemb = fwrite(esmftrc_packet_buf(&ctx->ctx),\n\t\t\t  esmftrc_packet_buf_size(&ctx->ctx), 1, ctx->fh);\n    assert(nmemb == 1);\n  }\n\n  static int is_backend_full(void *data) {\n    //assume file system never full\n    return 0;\n  }\n\n  static void open_packet(void *data) {\n    struct esmftrc_platform_filesys_ctx *ctx =\n      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);\n\n    esmftrc_default_open_packet(&ctx->ctx, ctx->nodename, ctx->stream_id);\n  }\n\n  static void close_packet(void *data) {\n    struct esmftrc_platform_filesys_ctx *ctx =\n      FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, data);\n\n    // close packet now\n    esmftrc_default_close_packet(&ctx->ctx);\n\n    // write packet to file\n    write_packet(ctx);\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::write_metadata()\"\n  static void write_metadata(const char *trace_dir, int *rc) {\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n    string metadata_string = TraceGetMetadataString();\n    string filename(trace_dir);\n    filename += \"/metadata\";\n\n    std::ofstream ofs (filename.c_str(), std::ofstream::trunc);\n    if (ofs.is_open() && !ofs.fail()) {\n      ofs << metadata_string;\n      ofs.close();\n    }\n    else {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error writing trace metadata file\",\n                                    ESMC_CONTEXT, rc);\n    }\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::InitializeWrappers()\"\n  static void InitializeWrappers() {\n    int wrappersPresent = TRACE_WRAP_NONE;\n#ifndef ESMF_NO_DLFCN\n    void *preload_lib = dlopen(NULL, RTLD_LAZY);\n    if (preload_lib == NULL) {\n      ESMC_LogDefault.Write(\"ESMF Tracing/Profiling could not open shared library containing instrumentation.\", ESMC_LOGMSG_WARN);\n    }\n    else {\n      notify_wrappers = (int (*)(int)) dlsym(preload_lib, \"c_esmftrace_notify_wrappers\");\n      if (notify_wrappers != NULL) {\n        wrappersPresent = notify_wrappers(1);\n      }\n      else {\n        ESMC_LogDefault.Write(\"ESMF Tracing/Profiling could not load dynamic instrumentation functions.\", ESMC_LOGMSG_WARN);\n      }\n    }\n#else\n    wrappersPresent = c_esmftrace_notify_wrappers(1);\n#endif\n\n    if (wrappersPresent != TRACE_WRAP_NONE) {\n      stringstream logMsg;\n      logMsg << \"ESMF Tracing/Profiling enabled with \";\n      if (wrappersPresent == TRACE_WRAP_DYNAMIC) {\n        logMsg << \"DYNAMIC\";\n      }\n      else if (wrappersPresent == TRACE_WRAP_STATIC) {\n        logMsg << \"STATIC\";\n      }\n      logMsg << \" instrumentation.\";\n      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n      logMsg.str(\"  This option should only be used for profiling applications and NOT for production runs.\");\n      ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n    }\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FinalizeWrappers()\"\n  static void FinalizeWrappers() {\n#ifndef ESMF_NO_DLFCN\n    if (notify_wrappers != NULL) {\n      notify_wrappers(0);\n    }\n#else\n    c_esmftrace_notify_wrappers(0);\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceOpen()\"\n  void TraceOpen(std::string trace_dir, int *profileToLog, int *rc) {\n\n    int localrc;\n    stringstream logMsg;\n\n    if (rc != NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    //determine if tracing is turned on for this PET\n    traceLocalPet = TraceIsEnabledForPET(globalvm->getLocalPet(), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n      traceLocalPet = false;\n      return;\n    }\n\n    //determine if profiling is turned on for this PET\n    //if tracing is enabled, automatically turn on profiling\n    profileLocalPet = traceLocalPet || ProfileIsEnabledForPET(globalvm->getLocalPet(), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n         ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n      profileLocalPet = false;\n      return;\n    }\n\n    //determine output method for profiling, if enabled\n    if (profileLocalPet) {\n      //always output binary if tracing is enabled\n      if (traceLocalPet) profileOutputToBinary = true;\n      char const *envProfileOutput = VM::getenv(\"ESMF_RUNTIME_PROFILE_OUTPUT\");\n      if (envProfileOutput != NULL && strlen(envProfileOutput) > 0) {\n        string profileOutput(envProfileOutput);\n        if ( (profileOutput.find(\"TEXT\") != string::npos) ||\n             (profileOutput.find(\"text\") != string::npos) ||\n             (profileOutput.find(\"Text\") != string::npos) ) {\n          if (profileToLog != NULL && *profileToLog == 1) {\n            profileOutputToLog = true;\n          }\n          else {\n            profileOutputToFile = true;\n          }\n        }\n        if ( (profileOutput.find(\"BINARY\") != string::npos) ||\n             (profileOutput.find(\"binary\") != string::npos) ||\n             (profileOutput.find(\"Binary\") != string::npos) ) {\n          profileOutputToBinary = true;\n        }\n        if ( (profileOutput.find(\"SUMMARY\") != string::npos) ||\n             (profileOutput.find(\"summary\") != string::npos) ||\n             (profileOutput.find(\"Summary\") != string::npos) ) {\n          profileOutputSummary = true;\n        }\n      }\n      else {\n        // if not specified, default is to output text\n        if (profileToLog != NULL && *profileToLog == 1) {\n          //printf(\"set output to log\\n\");\n          profileOutputToLog = true;\n        }\n        else {\n          //printf(\"set output to file\\n\");\n          profileOutputToFile = true;\n        }\n      }\n    }\n\n    if (traceLocalPet) {\n      ESMC_LogDefault.Write(\"ESMF Tracing Enabled\", ESMC_LOGMSG_INFO);\n    }\n    if (profileLocalPet) {\n      ESMC_LogDefault.Write(\"ESMF Profiling Enabled\", ESMC_LOGMSG_INFO);\n    }\n\n    // initialize the clock\n    struct esmftrc_platform_filesys_ctx *ctx;\n    if (traceLocalPet || profileLocalPet) {\n      ctx = FROM_VOID_PTR(struct esmftrc_platform_filesys_ctx, malloc(sizeof(*ctx)));\n      if (!ctx) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, \"Cannot allocate context\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n      ctx->latch_ts = 0;\n      ctx->fh == NULL;\n\n      //store as global context\n      traceCtx = ctx;\n\n      TraceInitializeClock(&localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n        return;\n    }\n\n    // determine if we need to set up for binary output\n    if (traceLocalPet || profileOutputToBinary) {\n\n      // stream_id same as global pet id\n      int stream_id = globalvm->getLocalPet();\n      ctx->stream_id = stream_id;\n      //get node name\n      if (gethostname(ctx->nodename, NODENAME_LEN) < 0) {\n        ctx->nodename[0] = '\\0';\n      }\n\n      // set up callbacks\n      struct esmftrc_platform_callbacks cbs;\n      cbs.sys_clock_clock_get_value = TraceGetClock;\n      cbs.is_backend_full = is_backend_full;\n      cbs.open_packet = open_packet;\n      cbs.close_packet = close_packet;\n\n      //allocate event buffer\n      char const *envFlush = VM::getenv(\"ESMF_RUNTIME_TRACE_FLUSH\");\n      string strFlush = \"DEFAULT\";\n      int eventBufSize = EVENT_BUF_SIZE_DEFAULT;\n      if (envFlush != NULL) {\n        strFlush = envFlush;\n        if (trim(strFlush) == \"EAGER\" || trim(strFlush) == \"eager\" || trim(strFlush) == \"Eager\") {\n          eventBufSize = EVENT_BUF_SIZE_EAGER;\n          logMsg.str(\"ESMF Tracing set to EAGER flushing.\");\n          ESMC_LogDefault.Write(logMsg.str().c_str(), ESMC_LOGMSG_INFO);\n        }\n      }\n\n      uint8_t *buf = FROM_VOID_PTR(uint8_t, malloc(eventBufSize));\n      if (!buf) {\n        free(ctx);\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE, \"Cannot allocate trace event buffer\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n      memset(buf, 0, eventBufSize);\n\n      //make relative path absolute if needed\n      string stream_dir_root;\n      if (trace_dir[0] != '/') {\n        char cwd[ESMC_MAXPATHLEN];\n        FTN_X(c_esmc_getcwd)(cwd, &localrc, ESMC_MAXPATHLEN);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n           \"Error getting working directory\", ESMC_CONTEXT, rc))\n          return;\n        stream_dir_root = string (cwd, ESMC_F90lentrim(cwd, ESMC_MAXPATHLEN)) + \"/\" + trace_dir;\n      }\n      else {\n        stream_dir_root = trace_dir;\n      }\n\n      struct stat st;\n      if (stream_id == 0) {\n        if (stat(stream_dir_root.c_str(), &st) == -1) {\n          ESMC_Logical relaxedFlag = ESMF_TRUE;\n          int dir_perms = TRACE_DIR_PERMISSIONS;\n          FTN_X(c_esmc_makedirectory)(stream_dir_root.c_str(), &dir_perms,\n                                      &relaxedFlag, &localrc, stream_dir_root.length());\n\n          if (ESMC_LogDefault.MsgFoundError(localrc,\n                 \"Error creating trace root directory\", ESMC_CONTEXT, rc))\n            return;\n        }\n      }\n\n      // all PETs wait for directory to be created\n      globalvm->barrier();\n\n      // my specific file\n      stringstream stream_file;\n      stream_file << stream_dir_root << \"/esmf_stream_\" << std::setfill('0') << std::setw(4) << stream_id;\n\n      ctx->fh = fopen(stream_file.str().c_str(), \"wb\");\n      if (!ctx->fh) {\n        free(ctx);\n        free(buf);\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_OPEN, \"Error opening trace output file\",\n                                      ESMC_CONTEXT, rc);\n        return;\n      }\n\n      //stream zero writes the metadata file\n      if (stream_id == 0) {\n        write_metadata(stream_dir_root.c_str(), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n          return;\n        }\n      }\n\n      esmftrc_init(&ctx->ctx, buf, eventBufSize, cbs, ctx);\n      open_packet(ctx);\n\n    }\n    else {\n      // this PET either has no tracing/profiling or only profiling to log/text\n      globalvm->barrier();  //match barrier call above\n    }\n\n    if (traceLocalPet || profileLocalPet) {\n      traceInitialized = true;\n      // notify any function wrappers that trace is ready\n      InitializeWrappers();\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n  static string getPhaseNameFromPhaseId(ESMFPhaseId phaseId) {\n    ComponentInfo *ci = NULL;\n    bool present = componentInfoMap.get(phaseId.getESMFId(), ci);\n    if (present && ci != NULL) {\n      return ci->getPhaseName(phaseId);\n    }\n    return \"\";\n  }\n\n  static string getRegionNameFromId(uint16_t local_id) {\n    ESMFPhaseId phaseId;\n    bool present = phaseRegionMap.reverse(local_id, phaseId);\n    if (present) {\n      return getPhaseNameFromPhaseId(phaseId);\n    }\n    else {\n      string name;\n      present = userRegionMap.reverse(local_id, name);\n      if (present) return name;\n    }\n    return \"\";\n  }\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::populateRegionNames()\"\n  static void populateRegionNames(RegionNode *rn) {\n    if (rn == NULL) return;\n\n    string name = getRegionNameFromId(rn->getLocalId());\n    if (name.length() == 0) {\n      if (rn->isUserRegion()) {\n        name = \"UNKNOWN_USER_REGION\";\n      }\n      else {\n        name = \"UNKNOWN_ESMF_PHASE\";\n      }\n    }\n    rn->setName(name);\n\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      populateRegionNames(rn->getChildren().at(i));\n    }\n  }\n\n  static size_t regionNamePadding(RegionSummary *rs, int depth) {\n    size_t maxSize = rs->getName().length() + (2*depth);\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      size_t childSize = regionNamePadding(rs->getChildren().at(i), depth+1);\n      if (childSize > maxSize) maxSize = childSize;\n    }\n    return maxSize;\n  }\n\n  static size_t regionNamePadding(RegionNode *rn, int depth) {\n    size_t maxSize = rn->getName().length() + (2*depth);\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      size_t childSize = regionNamePadding(rn->getChildren().at(i), depth+1);\n      if (childSize > maxSize) maxSize = childSize;\n    }\n    return maxSize;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printProfile()\"\n#define STATLINE 512\n  static void printProfile(RegionNode *rn, bool printToLog, string prefix, ofstream &ofs, size_t namePadding, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    if (rn->getParent() != NULL) {\n      char strbuf[STATLINE];\n      string name = rn->getName();\n      name.insert(0, prefix);\n\n      stringstream fmt;\n      fmt << \"%-\" << namePadding << \"s %-6lu %-11.4f %-11.4f %-11.4f %-11.4f %-11.4f\";\n\n      snprintf(strbuf, STATLINE, fmt.str().c_str(),\n               name.c_str(), rn->getCount(), rn->getTotal()*NANOS_TO_SECS,\n               rn->getSelfTime()*NANOS_TO_SECS, rn->getMean()*NANOS_TO_SECS,\n               rn->getMin()*NANOS_TO_SECS, rn->getMax()*NANOS_TO_SECS);\n      if (printToLog) {\n        ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);\n      }\n      else {\n        ofs << strbuf << \"\\n\";\n      }\n    }\n    rn->sortChildren();\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      printProfile(rn->getChildren().at(i), printToLog, prefix + \"  \", ofs, namePadding, rc);\n    }\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printProfile()\"\n  static void printProfile(RegionNode *rn, bool printToLog, string filename, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    ofstream ofs;\n    int localrc;\n\n    size_t namePadding = regionNamePadding(rn, 0)+1;\n    if (namePadding > 200) namePadding = 200;\n\n    stringstream fmt;\n    fmt << \"%-\" << namePadding << \"s %-6s %-11s %-11s %-11s %-11s %-11s\";\n\n    char strbuf[STATLINE];\n    snprintf(strbuf, STATLINE, fmt.str().c_str(),\n             \"Region\", \"Count\", \"Total (s)\", \"Self (s)\", \"Mean (s)\", \"Min (s)\", \"Max (s)\");\n\n    if (printToLog) {\n      ESMC_LogDefault.Write(\"**************** Region Timings *******************\", ESMC_LOGMSG_INFO);\n      ESMC_LogDefault.Write(strbuf, ESMC_LOGMSG_INFO);\n    }\n    else {\n      ofs.open(filename.c_str(), ofstream::trunc);\n      if (ofs.is_open() && !ofs.fail()) {\n        ofs << strbuf << \"\\n\";\n      }\n      else {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error opening profile output file\",\n           ESMC_CONTEXT, rc);\n        return;\n      }\n    }\n    printProfile(rn, printToLog, \"\", ofs, namePadding, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile output file\",\n         ESMC_CONTEXT, rc))\n      return;\n    if (!printToLog) {\n      ofs.close();\n    }\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::findImbalancedConnectors()\"\n  static void findImbalancedConnectors(RegionSummary *rs, vector<string> &connList, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    rs->sortChildren();\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      //TODO: find a cleaner way of determining the type of component\n      RegionSummary *child = rs->getChildren().at(i);\n      if (child->getName().find(\"-TO-\") != string::npos &&\n\t  child->getName().find(\"Run\") != string::npos) {\n\t//only report if normalized time shows > 5% imbalance\n\tif (child->getParent()->getTotalMax() > 0) {\n\t  double ndiff = (1.0*child->getTotalMax() / child->getParent()->getTotalMax()) -\n\t    (1.0*child->getTotalMin() / child->getParent()->getTotalMax());\n\t  if (ndiff > .05) {\n\t    connList.push_back(child->getName());\n\t  }\n\t}\n      }\n    }\n\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      findImbalancedConnectors(rs->getChildren().at(i), connList, rc);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfileMessage()\"\n  static void printSummaryProfileMessage(RegionSummary *rs, ofstream &ofs, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n    int localrc;\n    vector<string> connList;\n\n    findImbalancedConnectors(rs, connList, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n\t  ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    if (connList.size() > 0) {\n      string msg = \"********\";\n      msg += \"\\nIMPORTANT: Large deviations between Connector times on different PETs\\n\";\n      msg += \"are typically indicators of load imbalance in the system. The following\\n\";\n      msg += \"Connectors in this profile may indicate a load imbalance:\\n\";\n      for (unsigned i = 0; i < connList.size(); i++) {\n\tmsg += \"\\t - \" + connList.at(i) + \"\\n\";\n      }\n      ofs << msg << \"********\\n\\n\";\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfile()\"\n  static void printSummaryProfile(RegionSummary *rs, string prefix, ofstream &ofs, size_t namePadding, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    if (rs->getParent() != NULL) {\n      char strbuf[STATLINE];\n      string name = rs->getName();\n      name.insert(0, prefix);\n\n      char countstr[12];\n      if (rs->getCountsMatch()) {\n\tsnprintf(countstr, 12, \"%-6lu\", rs->getCountEach());\n      }\n      else {\n\tsnprintf(countstr, 12, \"%-8s\", \"MULTIPLE\");\n      }\n\n      stringstream fmt;\n      fmt << \"%-\" << namePadding << \"s %-6lu %-8s %-11.4f %-11.4f %-7d %-11.4f %-7d\";\n\n      snprintf(strbuf, STATLINE, fmt.str().c_str(),\n               name.c_str(), rs->getPetCount(), countstr,\n\t       rs->getTotalMean()*NANOS_TO_SECS,\n\t       rs->getTotalMin()*NANOS_TO_SECS, rs->getTotalMinPet(),\n\t       rs->getTotalMax()*NANOS_TO_SECS, rs->getTotalMaxPet());\n      ofs << strbuf << \"\\n\";\n    }\n    rs->sortChildren();\n    for (unsigned i = 0; i < rs->getChildren().size(); i++) {\n      printSummaryProfile(rs->getChildren().at(i), prefix + \"  \", ofs, namePadding, rc);\n    }\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::printSummaryProfile()\"\n  static void printSummaryProfile(RegionSummary *rs, string filename, int *rc) {\n\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    ofstream ofs;\n    int localrc;\n\n    size_t namePadding = regionNamePadding(rs, 0)+1;\n    if (namePadding > 200) namePadding = 200;\n\n    stringstream fmt;\n    fmt << \"%-\" << namePadding << \"s %-6s %-8s %-11s %-11s %-7s %-11s %-7s\";\n\n    char strbuf[STATLINE];\n    snprintf(strbuf, STATLINE, fmt.str().c_str(),\n             \"Region\", \"PETs\", \"Count\", \"Mean (s)\", \"Min (s)\", \"Min PET\", \"Max (s)\", \"Max PET\");\n\n    ofs.open(filename.c_str(), ofstream::trunc);\n    if (ofs.is_open() && !ofs.fail()) {\n      printSummaryProfileMessage(rs, ofs, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile footer\",\n\t   ESMC_CONTEXT, rc))\n\treturn;\n      ofs << strbuf << \"\\n\";\n    }\n    else {\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_FILE_CREATE, \"Error opening profile output file\",\n\t\t\t\t    ESMC_CONTEXT, rc);\n      return;\n    }\n\n    printSummaryProfile(rs, \"\", ofs, namePadding, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, \"Error writing profile output file\",\n         ESMC_CONTEXT, rc))\n      return;\n    ofs.close();\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n  }\n\n\n\n  static void AddRegionProfilesToTrace(RegionNode *rn) {\n\n    esmftrc_default_trace_region_profile(\n        esmftrc_platform_get_default_ctx(),\n\trn->getGlobalId(),\n\trn->getParentGlobalId(),\n\trn->getTotal(),\n\trn->getSelfTime(),\n\trn->getCount(),\n\trn->getMax(),\n\trn->getMin(),\n\trn->getMean(),\n\trn->getStdDev());\n\n    for (unsigned i = 0; i < rn->getChildren().size(); i++) {\n      AddRegionProfilesToTrace(rn->getChildren().at(i));\n    }\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::GatherRegions()\"\n  static void GatherRegions(int *rc) {\n\n    int localrc;\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n          ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n      return;\n\n    char *serializedTree = NULL;\n    size_t bufferSize = 0;\n\n    if (profileLocalPet && globalvm->getLocalPet() > 0) {\n      //std::cout << \"serialize from pet: \" << globalvm->getLocalPet() << \"\\n\";\n      try {\n        serializedTree = rootRegionNode.serialize(&bufferSize);\n      }\n      catch(std::exception& e) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                      e.what(), ESMC_CONTEXT, rc);\n        return;\n      }\n      //std::cout << \"sending profile from pet: \" << globalvm->getLocalPet() << \" (\" << bufferSize << \")\" << \"\\n\";\n      //send size of buffer\n      globalvm->send((void *) &bufferSize, sizeof(bufferSize), 0);\n      //send buffer itself\n      globalvm->send((void *) serializedTree, bufferSize, 0);\n\n      free(serializedTree);\n    }\n    else if (globalvm->getLocalPet() == 0) {\n\n      //clone root\n      //ESMCI::RegionNode *aggNode = new ESMCI::RegionNode(NULL, &rootRegionNode);\n      ESMCI::RegionSummary *sumNode = new ESMCI::RegionSummary(NULL);\n\n      //first add my own timing tree to the summary\n      sumNode->merge(rootRegionNode, globalvm->getLocalPet());\n\n      //then gather from other PETs\n      for (int p=1; p<globalvm->getPetCount(); p++) {\n\n        if (ProfileIsEnabledForPET(p, &localrc) || TraceIsEnabledForPET(p, &localrc)) {\n\n          bufferSize = 0;\n          globalvm->recv((void *) &bufferSize, sizeof(bufferSize), p);\n          //std::cout << \"receive profile from pet: \" << p << \" (\" << bufferSize << \")\" << \"\\n\";\n\n          serializedTree = (char *) malloc(bufferSize);\n          if (serializedTree == NULL) {\n            ESMC_LogDefault.MsgFoundError(ESMC_RC_MEM_ALLOCATE,\n                                        \"Error allocating memory when gather profiled regions\",\n                                        ESMC_CONTEXT, rc);\n          return;\n          }\n          memset(serializedTree, 0, bufferSize);\n\n          globalvm->recv(serializedTree, bufferSize, p);\n\n\n          try {\n\t    ESMCI::RegionNode *desNode = new ESMCI::RegionNode(serializedTree, bufferSize);\n\t    //merge statistics\n\t    sumNode->merge(*desNode, p);\n\t    delete desNode;\n\t  }\n          catch(std::exception& e) {\n            ESMC_LogDefault.MsgFoundError(ESMC_RC_INTNRL_BAD,\n                                          e.what(), ESMC_CONTEXT, rc);\n            return;\n          }\n\n          free(serializedTree);\n        }\n        else if (ESMC_LogDefault.MsgFoundError(localrc,\n                   ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) {\n          return;\n        }\n\n      }\n\n      //now we have received and merged\n      //profiles from all other PETs\n      printSummaryProfile(sumNode, \"ESMF_Profile.summary\", &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n        return;\n\n      delete sumNode;\n    }\n\n  }\n\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceClose()\"\n  void TraceClose(int *rc) {\n\n    int localrc;\n    if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;\n\n    // allow calling multiple times, only closes\n    // on the first call, needed in testing\n    if (traceInitialized) {\n      traceInitialized = false;\n      FinalizeWrappers();\n\n      if (profileOutputToLog || profileOutputToFile || profileOutputSummary) {\n        populateRegionNames(&rootRegionNode);\n      }\n\n      if (profileOutputToLog) {\n        printProfile(&rootRegionNode, true, \"\", &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (profileOutputToFile) {\n        VM *globalvm = VM::getGlobal(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n\n        stringstream fname;\n        fname << (globalvm->getPetCount() - 1);\n        int width = fname.str().length();\n        fname.str(\"\");\n        fname << \"ESMF_Profile.\" << std::setfill('0') << std::setw(width) << globalvm->getLocalPet();\n\n        printProfile(&rootRegionNode, false, fname.str(), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n             ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (profileOutputToBinary) {\n        AddRegionProfilesToTrace(&rootRegionNode);\n      }\n\n      if (profileOutputSummary) {\n        GatherRegions(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc,\n           ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc))\n          return;\n      }\n\n      if (traceCtx != NULL) {\n        if (traceLocalPet || profileOutputToBinary) {\n          if (traceCtx->fh != NULL) {\n            if (esmftrc_packet_is_open(&traceCtx->ctx) &&\n                !esmftrc_packet_is_empty(&traceCtx->ctx)) {\n              close_packet(traceCtx);\n            }\n            fclose(traceCtx->fh);\n          }\n          free(esmftrc_packet_buf(&traceCtx->ctx));\n        }\n        free(traceCtx);\n        traceCtx = NULL;\n      }\n\n      vector<HashNode<ESMFId, ComponentInfo *> *> entries = componentInfoMap.getEntries();\n      vector<HashNode<ESMFId, ComponentInfo *> *>::iterator it;\n      for(it = entries.begin(); it != entries.end(); it++) {\n        delete (*it)->getValue();\n      }\n    }\n\n    if(rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n\n\n  ///////////////////// I/O Tracing //////////////////\n\n  //static std::string openFilename;\n  //static uint64_t openStartTimestamp = -1;\n\n  void TraceIOOpenStart(const char *path) {\n    /*\n      if (!traceLocalPet) return;\n      openStartTimestamp = TraceGetClock(NULL);\n      openFilename = string(path);\n    */\n  }\n\n  void TraceIOOpenEnd() {\n    /*\n    if (!traceLocalPet) return;\n    uint64_t openEndTimestamp = TraceGetClock(NULL);\n    uint64_t openTime = openEndTimestamp - openStartTimestamp;\n\n    esmftrc_default_trace_ioopen(esmftrc_platform_get_default_ctx(),\n                                 openFilename.c_str(), openTime);\n\n    openStartTimestamp = -1;\n    */\n  }\n\n  void TraceIOCloseStart() {\n  }\n\n  void TraceIOCloseEnd() {\n  }\n\n  void TraceIOWriteStart() {\n  }\n\n  void TraceIOWriteEnd(size_t nbytes) {\n  }\n\n  void TraceIOReadStart() {\n  }\n\n  void TraceIOReadEnd(size_t nbytes) {\n  }\n\n  /*\n  static void PopIOStats() {\n\n    size_t readBytes = readTotalBytes.back();\n    uint64_t readTime = readTotalTime.back();\n    readTotalBytes.pop_back();\n    readTotalTime.pop_back();\n    if (readBytes > 0) {\n      esmftrc_default_trace_ioread(esmftrc_platform_get_default_ctx(),\n                                    readBytes, readTime);\n    }\n\n    size_t writeBytes = writeTotalBytes.back();\n    uint64_t writeTime = writeTotalTime.back();\n    writeTotalBytes.pop_back();\n    writeTotalTime.pop_back();\n    if (writeBytes > 0) {\n      esmftrc_default_trace_iowrite(esmftrc_platform_get_default_ctx(),\n                                    writeBytes, writeTime);\n    }\n  }\n  */\n\n  ////////////////////////////////////////////////////\n\n  /////////////////// MPI /////////////////////\n\n  void TraceMPIWaitStart() {\n    if (profileLocalPet) {\n      currentRegionNode->enteredMPI(TraceGetClock(traceCtx));\n    }\n  }\n\n  void TraceMPIWaitEnd() {\n    if (profileLocalPet) {\n      currentRegionNode->exitedMPI(TraceGetClock(traceCtx));\n    }\n  }\n\n  /*\n   * This function used only in tests.\n   */\n  void TraceTest_GetMPIWaitStats(int *count, long long *time) {\n    if (!traceInitialized) return;\n    if (profileLocalPet) {\n      if (count != NULL)\n        *count = currentRegionNode->getCountMPI();\n      if (time != NULL)\n        *time = currentRegionNode->getTotalMPI();\n    }\n  }\n\n  void TraceTest_CheckMPIRegion(string name, int *exists) {\n    if (exists == NULL) return;\n    *exists = 0;\n    if (traceLocalPet || profileLocalPet) {\n      if (currentRegionNode == NULL) return;\n      uint16_t local_id = 0;\n      //bool present = userRegionMap.get(name, local_id);\n\n      std::transform(name.begin(), name.end(), name.begin(), ::tolower);\n      vector<HashNode<string, uint16_t> *> entries = userRegionMap.getEntries();\n      vector<HashNode<string, uint16_t> *>::iterator it;\n\n      bool present = false;\n      for(it = entries.begin(); it != entries.end(); it++) {\n        string regName = (*it)->getKey();\n\tstd::transform(regName.begin(), regName.end(), regName.begin(), ::tolower);\n\t//std::cout << \"Comparing: \" << name << \" to \" << regName << \"\\n\";\n\tif (regName == name) {\n\t  present = true;\n\t  local_id = (*it)->getValue();\n\t  break;\n\t}\n      }\n\n      if (!present) return;\n      RegionNode *child = currentRegionNode->getChild(local_id);\n      if (child != NULL) *exists = 1;\n    }\n  }\n\n\n  /////////////////////////////////////////////\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventPhaseEnter()\"\n  void TraceEventPhaseEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      uint16_t local_id = 0;\n      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);\n      bool present = phaseRegionMap.get(phaseId, local_id);\n      if (!present) {\n        local_id = next_local_id();\n        phaseRegionMap.put(phaseId, local_id);\n      }\n\n      if (currentRegionNode == NULL) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n        return;\n      }\n\n      bool added;\n      currentRegionNode = currentRegionNode->getOrAddChild(local_id, added);\n\n      //add region to trace output\n      if (added && (traceLocalPet || profileOutputToBinary)) {\n        esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId(),\n                                            TRACE_REGIONTYPE_PHASE,\n                                            *ep_vmid, *ep_baseid, *ep_method, *ep_phase,\n                                            getRegionNameFromId(local_id).c_str());\n      }\n\n      TraceClockLatch(traceCtx);  /* lock in time on clock */\n      currentRegionNode->entered(traceCtx->latch_ts);\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),\n                                             currentRegionNode->getGlobalId());\n      }\n      TraceClockUnlatch(traceCtx);\n\n      //printf(\"OrigPhaseEnter: vmid=%d, bid=%d, method=%d, phase=%d\\n\", *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n\n    }\n\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodToEnum\"\n  static inline int MethodToEnum(enum ESMCI::method method) {\n      switch(method){\n      case ESMCI::METHOD_INITIALIZE:\n        return 0;\n        break;\n      case ESMCI::METHOD_RUN:\n        return 1;\n        break;\n      case ESMCI::METHOD_FINALIZE:\n        return 2;\n        break;\n      default:\n        return -1;\n        break;\n      }\n      return -1;\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventCompPhaseEnter()\"\n  void TraceEventCompPhaseEnter(Comp *comp, enum method *method, int *phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      int localrc;\n\n      int methodid = MethodToEnum(*method);\n      if (methodid >= 0) {\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n        int baseid = base->ESMC_BaseGetID();\n\n        TraceEventPhaseEnter(&localvmid, &baseid, &methodid, phase, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        //printf(\"CompPhaseEnter: vmid=%d, bid=%d, method=%d, phase=%d\\n\", localvmid, baseid, methodid, *phase);\n      }\n    }\n\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventCompPhaseExit()\"\n  void TraceEventCompPhaseExit(Comp *comp, enum method *method, int *phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      int localrc;\n\n      if (*method == ESMCI::METHOD_SETSERVICES) {\n\n        //after SetServices, look to see if there are any\n        //phase map attributes available, and if so record\n        //these labels for displaying in the output\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int baseid = base->ESMC_BaseGetID();\n        char *compName = base->ESMC_BaseGetName();\n\n        vector<string> IPM;\n        vector<string> IIPM;\n        vector<string> RPM;\n        vector<string> FPM;\n\n        Attribute *attrRoot = base->ESMC_BaseGetRoot();\n        if (attrRoot != NULL) {\n\n          Attribute *attrPack = attrRoot->AttPackGet(\"NUOPC\", \"Instance\", \"comp\", \"\", ESMC_ATTNEST_ON);\n          if (attrPack != NULL) {\n\n            Attribute *attr;\n            attr = attrPack->AttPackGetAttribute(\"InitializePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&IPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"InternalInitializePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&IIPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"RunPhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&RPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n            attr = attrPack->AttPackGetAttribute(\"FinalizePhaseMap\", ESMC_ATTNEST_ON);\n            if (attr != NULL && Attribute::isSet(attr)) {\n              localrc = attr->get(&FPM);\n              if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n            }\n          }\n        }\n        TraceEventComponentInfo(&localvmid, &baseid, compName, IPM, IIPM, RPM, FPM);\n      }\n\n      int methodid = MethodToEnum(*method);\n      if (methodid >= 0) {\n\n        VM *vm;\n        localrc = comp->getVm(&vm);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        VMId *vmid = vm->getVMId(&localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        int localvmid = TraceMapVmId(vmid, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        ESMC_Base *base;\n        localrc = comp->getBase(&base);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n        int baseid = base->ESMC_BaseGetID();\n\n        TraceEventPhaseExit(&localvmid, &baseid, &methodid, phase, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, rc)) return;\n\n        //printf(\"CompPhaseExit: vmid=%d, bid=%d, method=%d, phase=%d\\n\", localvmid, baseid, methodid, *phase);\n      }\n    }\n\n    if (rc!=NULL) *rc=ESMF_SUCCESS;\n\n  }\n\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI:TraceEventPhaseExit()\"\n  void TraceEventPhaseExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      TraceClockLatch(traceCtx);\n\n      uint16_t local_id = 0;\n      ESMFPhaseId phaseId(ESMFId(*ep_vmid, *ep_baseid), *ep_method, *ep_phase);\n      bool present = phaseRegionMap.get(phaseId, local_id);  /* should always be present */\n      if (!present) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                    \"Trace region not properly nested\", ESMC_CONTEXT, rc);\n        TraceClockUnlatch(traceCtx);\n        return;\n      }\n\n      if (currentRegionNode == NULL) {\n\tESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n\t\t\t\t      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n      else if (currentRegionNode->getLocalId() != local_id) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested exiting from region: \";\n        errMsg << getRegionNameFromId(local_id);\n        errMsg << \" Expected exit from: \";\n        errMsg << getRegionNameFromId(currentRegionNode->getLocalId());\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId());\n      }\n\n      currentRegionNode->exited(traceCtx->latch_ts);\n      currentRegionNode = currentRegionNode->getParent();\n\n      TraceClockUnlatch(traceCtx);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n   }\n\n  void TraceEventPhasePrologueEnter(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {\n    if (!traceLocalPet) return;\n    esmftrc_default_trace_prologue_enter(esmftrc_platform_get_default_ctx(),\n                                         *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n  }\n\n  void TraceEventPhaseEpilogueExit(int *ep_vmid, int *ep_baseid, int *ep_method, int *ep_phase) {\n    if (!traceLocalPet) return;\n    esmftrc_default_trace_epilogue_exit(esmftrc_platform_get_default_ctx(),\n                                        *ep_vmid, *ep_baseid, *ep_method, *ep_phase);\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventRegionEnter()\"\n  void TraceEventRegionEnter(std::string name, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n\n      uint16_t local_id = 0;\n      bool present = userRegionMap.get(name, local_id);\n      if (!present) {\n        local_id = next_local_id();\n        userRegionMap.put(name, local_id);\n      }\n\n      if (currentRegionNode == NULL) {\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG,\n                                      \"Trace regions not properly nested\", ESMC_CONTEXT, rc);\n        return;\n      }\n\n      bool added;\n      currentRegionNode = currentRegionNode->getOrAddChild(local_id, true, added);\n\n      //add region to trace output\n      if (added && (traceLocalPet || profileOutputToBinary)) {\n        esmftrc_default_trace_define_region(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId(),\n                                            TRACE_REGIONTYPE_USER,\n                                            0, 0, 0, 0,\n                                            name.c_str());\n      }\n\n      TraceClockLatch(traceCtx);  /* lock in time on clock */\n      currentRegionNode->entered(traceCtx->latch_ts);\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_enter(esmftrc_platform_get_default_ctx(),\n                                             currentRegionNode->getGlobalId());\n      }\n      TraceClockUnlatch(traceCtx);\n\n    }\n\n    if (rc != NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventRegionExit()\"\n  void TraceEventRegionExit(std::string name, int *rc) {\n\n    if (traceLocalPet || profileLocalPet) {\n      TraceClockLatch(traceCtx);\n      uint16_t local_id = 0;\n      bool present = userRegionMap.get(name, local_id);\n      if (!present) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested. Attempt to exit region: \";\n        errMsg << name << \" that was never entered.\";\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n        TraceClockUnlatch(traceCtx);\n        return;\n      }\n\n      if (currentRegionNode == NULL) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested when attempting to exit region: \";\n        errMsg << name << \".\";\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n      else if (currentRegionNode->getLocalId() != local_id) {\n        stringstream errMsg;\n        errMsg << \"Trace regions not properly nested exiting from region: \";\n        errMsg << getRegionNameFromId(local_id);\n        errMsg << \" Expected exit from: \";\n        errMsg << getRegionNameFromId(currentRegionNode->getLocalId());\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_WRONG, errMsg.str().c_str(), ESMC_CONTEXT, rc);\n\tTraceClockUnlatch(traceCtx);\n\treturn;\n      }\n\n      if (traceLocalPet) {\n        esmftrc_default_trace_regionid_exit(esmftrc_platform_get_default_ctx(),\n                                            currentRegionNode->getGlobalId());\n      }\n\n      currentRegionNode->exited(traceCtx->latch_ts);\n      currentRegionNode = currentRegionNode->getParent();\n\n      TraceClockUnlatch(traceCtx);\n    }\n\n    if (rc!=NULL) *rc = ESMF_SUCCESS;\n\n  }\n\n  //IPDv00p1=6||IPDv00p2=7||IPDv00p3=4||IPDv00p4=5\n  static void UpdateComponentInfoMap(vector<string> phaseMap, ESMFId esmfId, int method, string compName) {\n    ComponentInfo *ci = NULL;\n    bool present = componentInfoMap.get(esmfId, ci);\n    if (!present) {\n      ci = new ComponentInfo(esmfId, compName);\n      componentInfoMap.put(esmfId, ci);\n    }\n    if (ci !=NULL) {\n      for (unsigned i = 0; i < phaseMap.size(); i++) {\n        vector<string> phase = split(trim(phaseMap.at(i)), \"=\");\n        if (phase.size() == 2) {\n          int phasenum = -1;\n          stringstream ss(trim(phase.at(1)));\n          ss >> phasenum;\n          if(!(ss.fail())) {\n            ci->setPhaseName(ESMFPhaseId(esmfId, method, phasenum), phase.at(0));\n            //std::cout << \"Added region: \" + compName + \", \" + phase.at(0) + \"\\n\";\n          }\n        }\n      }\n    }\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::join\"\n  static string join(vector<string> v) {\n    string ret(\"\");\n    for (size_t i=0; i<v.size(); i++) {\n      if(ret.size() > 0) ret.append(\"||\");\n      ret.append(v.at(i));\n    }\n    return ret;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventComponentInfo()\"\n  void TraceEventComponentInfo(int *ep_vmid, int *ep_baseid,\n                               const char *ep_name,\n                               vector<string> IPM, vector<string> IIPM,\n                               vector<string> RPM, vector<string> FPM) {\n\n    if (traceLocalPet || profileOutputToBinary) {\n      string strIPM = join(IPM);\n      string strRPM = join(RPM);\n      string strFPM = join(FPM);\n      esmftrc_default_trace_comp(esmftrc_platform_get_default_ctx(),\n                                 *ep_vmid, *ep_baseid, ep_name,\n                                 strIPM.c_str(), strRPM.c_str(), strFPM.c_str());\n    }\n\n    if (profileLocalPet) {\n      string compName(ep_name);\n      ESMFId esmfId(*ep_vmid, *ep_baseid);\n      UpdateComponentInfoMap(IPM, esmfId, 0, compName);\n      UpdateComponentInfoMap(IIPM, esmfId, 0, compName);\n      UpdateComponentInfoMap(RPM, esmfId, 1, compName);\n      UpdateComponentInfoMap(FPM, esmfId, 2, compName);\n    }\n\n  }\n\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventMemInfo()\"\n  void TraceEventMemInfo() {\n\n    if (!traceLocalPet) return;\n\n    int localrc;\n    VM *globalvm = VM::getGlobal(&localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc,\n          ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &localrc))\n      return;\n\n    int virtMem = -1;\n    int physMem = -1;\n    globalvm->getMemInfo(&virtMem, &physMem);\n\n    esmftrc_default_trace_mem(esmftrc_platform_get_default_ctx(),\n                              virtMem, physMem);\n\n  }\n\n#undef ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::TraceEventClock()\"\n  void TraceEventClock(int *ep_year, int *ep_month, int *ep_day,\n                       int *ep_hour, int *ep_minute, int *ep_second) {\n\n    if (!traceLocalPet) return;\n\n    esmftrc_default_trace_clk(esmftrc_platform_get_default_ctx(),\n                              *ep_year, *ep_month, *ep_day,\n                              *ep_hour, *ep_minute, *ep_second);\n\n  }\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/Component/src/ESMCI_MethodTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2020, University Corporation for Atmospheric Research, \n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics \n// Laboratory, University of Michigan, National Centers for Environmental \n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, \n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_MethodTable.C\"\n//==============================================================================\n//\n// ESMCI MethodTable implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt MethodTable} methods \n// declared in the companion file {\\tt ESMCI\\_MethodTable.h}.  \n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_MethodTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string>\n#include <sstream>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Macros.h\"\n#include \"ESMCI_LogErr.h\"\n\n//==============================================================================\n//==============================================================================\n// MethodTable class implementation\n//==============================================================================\n//==============================================================================\n\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtablecreate\"\n  void FTN_X(c_esmc_methodtablecreate)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::MethodTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable allocation\", ESMC_CONTEXT, \n        rc);  \n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtabledestroy\"\n  void FTN_X(c_esmc_methodtabledestroy)(ESMCI::MethodTable **ptr, int *rc){\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- MethodTable deallocation\", ESMC_CONTEXT,\n        rc);  \n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableadd\"\n  void FTN_X(c_esmc_methodtableadd)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *pointer, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->add(label, pointer);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableaddshobj\"\n  void FTN_X(c_esmc_methodtableaddshobj)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, char const *nameArg,\n    char const *sharedObjArg,\n    int *rc, ESMCI_FortranStrLenArg labelLen, ESMCI_FortranStrLenArg nameLen,\n    ESMCI_FortranStrLenArg sharedObjLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      std::string name(nameArg, nameLen);\n      name.resize(name.find_last_not_of(\" \")+1);\n      std::string sharedObj(sharedObjArg, sharedObjLen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      localrc = (*ptr)->add(label, name, sharedObj);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableremove\"\n  void FTN_X(c_esmc_methodtableremove)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, int *rc, ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->remove(label);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//     return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecute\"\n  void FTN_X(c_esmc_methodtableexecute)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_methodtableexecuteef\"\n  void FTN_X(c_esmc_methodtableexecuteef)(ESMCI::MethodTable **ptr,\n    char const *labelArg, int *index, void *object, ESMC_Logical *existflag,\n    int *userRc, int *rc,\n    ESMCI_FortranStrLenArg labelLen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (labelLen>=0){\n      bool existing;\n      std::string label(labelArg, labelLen);\n      label.resize(label.find_last_not_of(\" \")+1);\n      if (index){\n        std::stringstream indexString;\n        indexString << \"::ESMF::index::\" << *index;\n        label += indexString.str();\n      }\n      localrc = (*ptr)->execute(label, object, userRc, &existing);\n      if (existing)\n        *existflag = ESMF_TRUE;\n      else\n        *existflag = ESMF_FALSE;\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- corrupt label string\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    // debugging---------\n//    localrc = (*ptr)->print();\n//    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n//    rc)) \n//      return;\n    // debugging---------\n    \n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n\n\n\nnamespace ESMCI {\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::print()\"\n  int MethodElement::print(void)const{\n    int rc = ESMC_RC_NOT_IMPL;\n    printf(\"%s\\n\", label.c_str());\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::execute()\"\n  int MethodElement::execute(void *object, int *userRc){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (pointer){\n      typedef void (*FuncP)(void *, int *);\n      FuncP vf = (FuncP)pointer;\n      (*vf)(object, userRc);\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - invalid function pointer\", ESMC_CONTEXT, &rc);\n      return rc;\n      \n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodElement::resolve()\"\n  int MethodElement::resolve(void){\n    int rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB, \n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, &rc);\n    return rc;\n#else\n    void *lib;\n    if (shobj.length()>0)\n      lib = dlopen(shobj.c_str(), RTLD_LAZY);\n    else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"shared object not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    pointer = (void *)dlsym(lib, name.c_str());\n    if (pointer == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- named routine not found\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n#endif\n  }\n  \n// -----------------------------------------------------------------------------\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::print()\"\n  int MethodTable::print(void)const{\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    while (element){\n      localrc = element->print();\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      element = element->nextElement;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, void *pointer){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, pointer);\n    }else{\n      table = new MethodElement(labelArg, pointer);\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::add()\"\n  int MethodTable::add(std::string labelArg, std::string name,\n    std::string sharedObj){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    MethodElement *element = table; // initialize\n    if (table){\n      MethodElement *prev;\n      while (element){\n        if (element->label == labelArg){\n          ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n            \"- method with identical label already exists\", ESMC_CONTEXT, &rc);\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      prev->nextElement = new MethodElement(labelArg, name, sharedObj);\n      element = prev->nextElement;\n    }else{\n      table = new MethodElement(labelArg, name, sharedObj);\n      element = table;\n    }\n    localrc = element->resolve();\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &rc)) return rc; // bail out\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::remove()\"\n  int MethodTable::remove(std::string labelArg){\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      MethodElement *prev = table;  // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (element == table)\n            table = element->nextElement;\n          else\n            prev->nextElement = element->nextElement;\n          delete element;\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        prev = element;\n        element = element->nextElement;\n      }\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- method not found in method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }else{\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n        \"- empty method table\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n\n  \n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::MethodTable::execute()\"\n  int MethodTable::execute(std::string labelArg, void *object, int *userRc,\n    bool *existflag){\n    int localrc = ESMC_RC_NOT_IMPL;\n    int rc = ESMC_RC_NOT_IMPL;\n    if (table){\n      MethodElement *element = table; // initialize\n      while (element){\n        if (element->label == labelArg){\n          if (existflag) *existflag = true;\n          localrc = element->execute(object, userRc);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          // return successfully\n          rc = ESMF_SUCCESS;\n          return rc;\n        }\n        element = element->nextElement;\n      }\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- method not found in method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }else{\n      if (existflag){\n        *existflag = false;\n        if (userRc) *userRc = ESMF_SUCCESS;\n      }else{\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \n          \"- empty method table\", ESMC_CONTEXT, &rc);\n        return rc;\n      }\n    }\n    // return successfully\n    rc = ESMF_SUCCESS;\n    return rc;\n  }\n  \n} // namespace ESMCI\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/Component/src/ESMCI_FTable.C": "// $Id$\n//\n// Earth System Modeling Framework\n// Copyright 2002-2020, University Corporation for Atmospheric Research,\n// Massachusetts Institute of Technology, Geophysical Fluid Dynamics\n// Laboratory, University of Michigan, National Centers for Environmental\n// Prediction, Los Alamos National Laboratory, Argonne National Laboratory,\n// NASA Goddard Space Flight Center.\n// Licensed under the University of Illinois-NCSA License.\n//\n//==============================================================================\n#define ESMC_FILENAME \"ESMCI_FTable.C\"\n//==============================================================================\n//\n// ESMCI Function table implementation (body) file\n//\n//-----------------------------------------------------------------------------\n//\n// !DESCRIPTION:\n//\n// The code in this file implements the C++ {\\tt Function Table} methods\n// declared in the companion file {\\tt ESMCI\\_FTable.h}.\n//\n//-----------------------------------------------------------------------------\n// include associated header file\n#include \"ESMCI_FTable.h\"\n\n// insert higher level, 3rd party or system includes\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#ifndef ESMF_NO_DLFCN\n#include <dlfcn.h>\n#endif\n\n// include ESMF headers\n#include \"ESMCI_Base.h\"\n#include \"ESMCI_Comp.h\"\n#include \"ESMCI_CompTunnel.h\"\n#include \"ESMCI_LogErr.h\"\n#include \"ESMCI_TraceRegion.h\"\n\nusing std::string;\n\n//-----------------------------------------------------------------------------\n// leave the following line as-is; it will insert the cvs ident string\n// into the object file for tracking purposes.\nstatic const char *const version = \"$Id$\";\n//-----------------------------------------------------------------------------\n\n\n//==============================================================================\n// prototypes for Fortran interface routines called by C++ code below\n//TODO: eventually move these calls into the ESMCI::Comp class\nextern \"C\" {\n  void FTN_X(f_esmf_compsetvminfo)(ESMCI::Comp *compp, void *vm_info, int *rc);\n  void FTN_X(f_esmf_compresetvmreleased)(ESMCI::Comp *compp, int *rc);\n  void FTN_X(f_esmf_compinsertvm)(ESMCI::Comp *compp, void *vm, int *rc);\n  void FTN_X(f_esmf_compgetctype)(ESMCI::Comp *compp, ESMCI::CompType *ctype,\n    int *rc);\n  void FTN_X(f_esmf_compreplicate)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    void *vm, int *rc);\n  void FTN_X(f_esmf_comprefcopy)(ESMCI::Comp *compp, ESMCI::Comp *compp_src,\n    int *rc);\n  void FTN_X(f_esmf_compdelete)(ESMCI::Comp *compp, int *rc);\n\n  void FTN_X(f_esmf_fortranudtpointersize)(int *size);\n  void FTN_X(f_esmf_fortranudtpointercopy)(void *dst, void *src);\n\n  void FTN_X(esmf_complianceicregister)(void *comp, int *rc);\n\n#ifdef ESMF_NO_DLFCN\n  //for now, assume these are here in the case that dlopen is not available\n  void FTN_X(nuopc_model_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_driver_complianceicr)(void *comp, int *rc);\n  void FTN_X(nuopc_connector_complianceicr)(void *comp, int *rc);\n#endif\n}\n//==============================================================================\n\n\n\n//==============================================================================\n// FTable interfaces to be called from Fortran side (ESMF_Comp.F90)\n//\n// these interface subroutine names MUST be in lower case\n//\nextern \"C\" {\n\n  // call to native class constructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecreate\"\n  void FTN_X(c_esmc_ftablecreate)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    (*ptr) = new ESMCI::FTable;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable allocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // call to native class destructor\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftabledestroy\"\n  void FTN_X(c_esmc_ftabledestroy)(ESMCI::FTable **ptr, int *rc) {\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*ptr == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- Ftable deallocation\", ESMC_CONTEXT, rc);\n      return;\n    }\n    delete (*ptr);\n    *ptr = NULL;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set arguments for standard Component methods\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetstateargs\"\n  void FTN_X(c_esmc_ftablesetstateargs)(ESMCI::FTable **ptr,\n    enum ESMCI::method *method, int *phase, void *comp,\n    ESMCI::State *importState, ESMCI::State *exportState, ESMCI::Clock **clock,\n    ESMCI::CompTunnel **compTunnel, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if (*compTunnel != NULL){\n      // this is a dual component which contains a valid actual component object\n      // -> set references to the passed in arguments and return\n      (*compTunnel)->setMethod(*method);\n      (*compTunnel)->setPhase(*phase);\n      (*compTunnel)->setImportState(importState);\n      (*compTunnel)->setExportState(exportState);\n      (*compTunnel)->setClock(clock);\n\n    }else{\n      // this is not a dual component, thus do the actual ftable encoding\n\n      char const *methodString = ESMCI::FTable::methodString(*method);\n\n      int slen = strlen(methodString);\n      char *fname;\n      ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n      //printf(\"after newtrim, name = '%s'\\n\", fname);\n\n      void *alist[4];\n      alist[0] = (void *)comp;\n      alist[1] = (void *)importState;\n      alist[2] = (void *)exportState;\n      alist[3] = (void *)clock;\n\n      ESMCI::FTable *ftable = *ptr; // incoming FTable\n\n      // only if the incoming FTable contains PET-local component copies\n      for (int i=0; i<ftable->componentcount; i++){\n        ESMCI::Comp *comp = ftable->component + i;      // component copy\n        ESMCI::FTable *ft = **(ESMCI::FTable ***)comp;  // assoc. FTable\n        localrc = ft->setFuncArgs(fname, 4, alist);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, rc)) return;\n      }\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n    }\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // set the InternalState in FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablesetinternalstate\"\n  void FTN_X(c_esmc_ftablesetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->setDataPtr(name, data, *dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // get the InternalState from FTable\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablegetinternalstate\"\n  void FTN_X(c_esmc_ftablegetinternalstate)(ESMCI::FTable ***ptr,\n    char const *type, void **data, enum ESMCI::dtype *dtype, int *rc,\n      ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char *name;\n    ESMCI::FTable::newtrim(type, slen, NULL, NULL, &name);\n    //printf(\"after newtrim, name = '%s'\\n\", name);\n\n    localrc = (**ptr)->getDataPtr(name, data, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] name;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvm\"\n  void FTN_X(c_esmc_setvm)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setvmshobj\"\n  void FTN_X(c_esmc_setvmshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"routine not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservices\"\n  void FTN_X(c_esmc_setservices)(void *ptr, void (*func)(), int *userRc, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicesshobj\"\n  void FTN_X(c_esmc_setservicesshobj)(void *ptr, char const *routineArg,\n    char const *sharedObjArg, ESMC_Logical *foundRoutine, int *userRc, int *rc,\n    ESMCI_FortranStrLenArg rlen, ESMCI_FortranStrLenArg llen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n#ifdef ESMF_NO_DLFCN\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_LIB,\n      \"- System does not support dynamic loading.\", ESMC_CONTEXT, rc);\n    return;\n#else\n    *foundRoutine = ESMF_FALSE; // initialize\n    void *lib;\n    if (llen>0){\n      string sharedObj(sharedObjArg, llen);\n      sharedObj.resize(sharedObj.find_last_not_of(\" \")+1);\n      lib = dlopen(sharedObj.c_str(), RTLD_LAZY);\n    }else\n      lib = dlopen(NULL, RTLD_LAZY);  // search in executable\n    if (lib == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"shared object not found\", ESMC_CONTEXT, rc);\n      return;\n    }\n    string routine(routineArg, rlen);\n    routine.resize(routine.find_last_not_of(\" \")+1);\n    void (*func)() = (void (*)())dlsym(lib, routine.c_str());\n    if ((void *)func != NULL){\n      // Routine was found\n      *foundRoutine = ESMF_TRUE;\n      ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n        rc)) return;\n    }\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n#endif\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicescomp\"\n  void FTN_X(c_esmc_setservicescomp)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, ESMCI::Comp *localActualComp,\n    int *localActualCompRootPet, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(localActualComp,\n      *localActualCompRootPet);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setservicessock\"\n  void FTN_X(c_esmc_setservicessock)(ESMCI::Comp *dualComp,\n    ESMCI::CompTunnel **compTunnel, int *port, char const *serverArg,\n    int *timeout, int *rc, ESMCI_FortranStrLenArg len){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    if (*compTunnel != NULL){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n    }\n    if (*port<1024 || *port>65535){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"- The port argument is outside valid range [1024, 65535]\",\n        ESMC_CONTEXT, rc);\n      return;\n    }\n    // server name\n    string server(serverArg, len);\n    // The compTunnel object must be created on all the PETs that execute\n    // this routine, which are potentially all parent PETs, not just those\n    // that eventually enter the child VM. This is so that all child component\n    // objects that exist on the parent VM with a valid entry of a child VM\n    // also have a valid compTunnel member.\n    *compTunnel = new ESMCI::CompTunnel(*port, server);\n    if (*compTunnel == NULL){\n      ESMC_LogDefault.MsgAllocError(\"- CompTunnel allocation\", ESMC_CONTEXT, rc);\n      return; // bail out\n    }\n    (*compTunnel)->setTimeout(*timeout);  // set dual side timeout for setServ.\n    // call into setServices with the internal CompTunnel::SetServices wrapper\n    int userRc;\n    localrc =dualComp->setServices(ESMCI::CompTunnel::setServicesWrap, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out\n    }\n    // CompTunnel::setServicesWrap() is a framework internal method, therefore\n    // the code returned in userRc is a framework internal return code and must\n    // be treated as such.\n    // Do not filter the RC_TIMEOUT at this level, since a timeout needs to\n    // bail out until it gets to the upper ESMF level, right before returning\n    // to the user, where the filtering is done according to the presence of\n    // a timeoutFlag argument.\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)){\n      delete *compTunnel; // clean-up\n      *compTunnel = NULL; // mark clean\n      return; // bail out on userRc b/c setServicesWrap is an internal routine\n    }\n\n    // Now that everything has returned successfully, mark the tunnel as\n    // connected.\n    // This must be done up on this level, so that _all_ PETs that call into\n    // SetServices() have the tunnel set to connected.\n    (*compTunnel)->setConnected(true);\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_setentrypoint\"\n  void FTN_X(c_esmc_setentrypoint)(void *ptr, enum ESMCI::method *method,\n    void *func, int *phase, int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    int slen = strlen(methodString);\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &fname);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n    localrc = (tabptr)->setFuncPtr(fname, func, ESMCI::FT_VOIDP4INTP);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_getentrypointphasecount\"\n  void FTN_X(c_esmc_getentrypointphasecount)(void *ptr,\n    enum ESMCI::method *method, int *phaseCount, ESMC_Logical *phaseZeroFlag,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    char const *methodString = ESMCI::FTable::methodString(*method);\n\n    ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n\n    int slen = strlen(methodString);\n    int phase = 0;  // initialize\n    int i;\n\n    *phaseZeroFlag = ESMF_FALSE; // initialize\n\n    char *fname;\n    ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n    i = tabptr->getEntry(fname, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out\n    delete[] fname;  // delete memory that \"newtrim\" allocated above\n    if (i != -1)\n      *phaseZeroFlag = ESMF_TRUE;  // set the flag\n\n    do{\n      ++phase;\n      ESMCI::FTable::newtrim(methodString, slen, &phase, NULL, &fname);\n\n      i = tabptr->getEntry(fname, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, rc)) return; // bail out\n\n      delete[] fname;  // delete memory that \"newtrim\" allocated above\n\n    }while (i != -1);\n\n    *phaseCount = phase - 1;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// these functions have no leading c_ and are ESMF and not ESMC because\n// they're intended to be called directly by F90 user code.\n//\n// also note they CANNOT have prototypes in fortran because the routine\n// types and data types are private/different for each call so there\n// is no correct prototype syntax which will work.\n//\n// and finally, note that they have an extra level of indirection,\n// because the first arg is actually being called with a component\n// pointer - and after one dereference we are at the component derived\n// type.  the second dereference finds the ftable pointer which must\n// be the first entry in the comp derived type.\n//\n// these interface subroutine names MUST be in lower case\nextern \"C\" {\n\n  // ---------- GridComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompsetinternalstate\"\n  void FTN_X(esmf_gridcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_gridcompgetinternalstate\"\n  void FTN_X(esmf_gridcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- CplComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompsetinternalstate\"\n  void FTN_X(esmf_cplcompsetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_cplcompgetinternalstate\"\n  void FTN_X(esmf_cplcompgetinternalstate)(ESMCI::FTable ***ptr, void **datap,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::getDP(ptr, datap, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n  // ---------- UserComp ---------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetvm\"\n  void FTN_X(esmf_usercompsetvm)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setVM(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetservices\"\n  void FTN_X(esmf_usercompsetservices)(void *ptr, void (*func)(), int *userRc,\n    int *rc){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n    ESMCI::FTable::setServices(ptr, func, userRc, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompsetinternalstate\"\n  void FTN_X(esmf_usercompsetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype = ESMCI::DT_FORTRAN_UDT_POINTER;\n    localrc = (**ptr)->setDataPtr(tbuf, datap, dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"esmf_usercompgetinternalstate\"\n  void FTN_X(esmf_usercompgetinternalstate)(ESMCI::FTable ***ptr,\n    char const *name, void **datap, int *rc,\n    ESMCI_FortranStrLenArg slen){\n    int localrc = ESMC_RC_NOT_IMPL;\n    if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n    if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"null pointer found\", ESMC_CONTEXT,rc);\n      return;\n    }\n\n    char *tbuf;\n    ESMCI::FTable::newtrim(name, slen, NULL, NULL, &tbuf);\n    //printf(\"after newtrim, name = '%s'\\n\", tbuf);\n\n    enum ESMCI::dtype dtype;\n    localrc = (**ptr)->getDataPtr(tbuf, datap, &dtype);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n\n    delete[] tbuf;\n\n    // return successfully\n    if (rc) *rc = ESMF_SUCCESS;\n  }\n\n} // extern \"C\"\n//==============================================================================\n\n\n//==============================================================================\n// VM-enabled CallBack loop\nextern \"C\" {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI_FTableCallEntryPointVMHop\"\nvoid *ESMCI_FTableCallEntryPointVMHop(void *vm, void *cargoCast){\n  // This routine is the first level that gets instantiated in new VM\n  // The first argument must be of type (void *) and points to a derived\n  // ESMCI::VMK class object. The second argument is also of type (void *)\n  // and points to a cargotype structure.\n\n  // pull out info from cargo\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)cargoCast;\n  char *name = cargo->name;               // name of callback\n  ESMCI::FTable *ftable = cargo->ftable;  // ptr to ftable\n\n  int localrc;          // local return code\n  int esmfrc;           // ESMF return code of ESMCI::FTable::callVFuncPtr()\n  int userrc = -99999;  // user return code from the registered component method\n\n  // prepare return code members in cargo\n  int mypet = ((ESMCI::VM*)vm)->getMypet();\n  int mynthreads = ((ESMCI::VM*)vm)->getNthreads(mypet);\n  int mytid = ((ESMCI::VM*)vm)->getTid(mypet);\n  if (mytid==0){\n    // master thread -> allocate return code members in cargo for all threads\n    if (cargo->rcCount != mynthreads){\n      delete [] cargo->esmfrc;\n      delete [] cargo->userrc;\n      cargo->esmfrc = new int[mynthreads];\n      cargo->userrc = new int[mynthreads];\n      cargo->rcCount = mynthreads;\n    }\n  }\n  ((ESMCI::VM*)vm)->threadbarrier();  // synchronize all threads in local group\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &esmfrc)){\n    cargo->esmfrc[mytid] = esmfrc;\n    return NULL;\n  }\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n\n    //TODO: check whether \"name\" is found in dual components ftable. If so then\n    //TODO: consider that an override, and execute dual components method\n    //TODO: instead\n\n    localrc = compTunnel->execute(cargo);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...the user return code will not be available until wait() is called\n\n  }else{\n\n    TraceEventCompPhaseEnter(f90comp, &(cargo->currentMethod), &(cargo->currentPhase), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n                                      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n    \n    // a regular component or a dual component that needs to connect still,\n    // use the local ftable for user code or system code callback\n    localrc = ftable->callVFuncPtr(name, (ESMCI::VM*)vm, &userrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    TraceEventCompPhaseExit(f90comp, &(cargo->currentMethod), &(cargo->currentPhase), &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n                                      &esmfrc)){\n      cargo->esmfrc[mytid] = esmfrc;  // put esmf return code into cargo\n      return NULL;\n    }\n\n    // ...back from user code\n    cargo->userrc[mytid] = userrc;  // put the user return code into cargo\n  }\n\n  // return successfully\n  cargo->esmfrc[mytid] = ESMF_SUCCESS;\n  return NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// call a function through VM\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_ftablecallentrypointvm\"\nvoid FTN_X(c_esmc_ftablecallentrypointvm)(\n  ESMCI::Comp *f90comp,       // pointer to Fortran component object\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info returned by enter\n  void **vm_cargo,            // p2 to member which holds cargo\n  ESMCI::FTable **ptr,        // p2 to the ftable of this component\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *port,                  // port number\n  int *timeout,               // time out in seconds\n  int *recursionCount,        // keeping track of recursion level of component\n  int *rc                     // return code\n  ){\n\n  // local variables\n  int localrc;              // local return code\n  char *name;               // trimmed type string\n\n  // check to make sure VM has really been started up for this Component\n  if (*vm_info == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \"No VM was started for this Component - missing SetServices() call?\",\n      ESMC_CONTEXT, rc);\n    return; // bail out\n  }\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  char const *methodString = ESMCI::FTable::methodString(*method);\n\n  int slen = strlen(methodString);\n  ESMCI::FTable::newtrim(methodString, slen, phase, NULL, &name);\n\n  // dereference double pointers to pointers\n  ESMCI::VM *vm_parent  = *ptr_vm_parent;     // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;        // pointer to VMPlan\n  ESMCI::FTable *ftable = *ptr;               // pointer to function table\n\n  int i = ftable->getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n  enum ESMCI::method currentMethod = ESMCI::METHOD_NONE;  // default invalid\n  if (i > -1)\n    currentMethod = ftable->methodFromIndex(i);\n\n  // support for recursion _and_ re-entrance for non-blocking mode\n  // - recursion:   A component may call into any of its standard methods from\n  //                within the context of already executing a standard method.\n  //                There is no practical limit to the recursion depth.\n  // - re-entrance: This refers to the situation where there is an outstanding\n  //                non-blocking call, but the parent calls into the standard\n  //                child component method again. This really only happens\n  //                on the dual side of dual-actual pairs connected by a\n  //                component tunnel. The dual side then may re-enter with an\n  //                associated wait call.\n  bool newCargoFlag = true;   // initialize\n  if (recursionCount && *recursionCount==0 && *vm_cargo)\n    newCargoFlag = false; // this is not a recursion but a re-entrance\n\n#if 0\n  {\n    std::stringstream debugmsg;\n    debugmsg << \"inside c_esmc_ftablecallentrypointvm(): recursionCount=\" \n      <<  recursionCount << \" *recursionCount=\"\n      << (recursionCount ? *recursionCount : -1)\n      << \" vm_cargo=\" << vm_cargo << \" newCargoFlag=\" << newCargoFlag;\n    ESMC_LogDefault.Write(debugmsg.str(), ESMC_LOGMSG_INFO);\n  }\n#endif\n\n  if (newCargoFlag){\n    ESMCI::cargotype *cargo = new ESMCI::cargotype;\n    strcpy(cargo->name, name);    // copy trimmed type string\n    cargo->f90comp = f90comp;     // pointer to Fortran component\n    cargo->ftable = ftable;       // pointer to function table\n    cargo->rcCount = 1;           // default\n    cargo->esmfrc = new int[1];\n    cargo->userrc = new int[1];\n    cargo->esmfrc[0] = ESMF_SUCCESS;  // initialize return code to SUCCESS\n    cargo->userrc[0] = ESMF_SUCCESS;  // initialize user return code to SUCCESS\n    cargo->previousCargo = *vm_cargo; // support recursion\n    cargo->previousParentFlag = vmplan->parentVMflag;  // support threaded rec.\n    cargo->currentMethod = currentMethod;\n    if (*method == ESMCI::METHOD_SERVICELOOP){\n      // for serviceloop method the currentPhase carries the port argument\n      cargo->currentPhase = *port;\n    }else{\n      // for all other methods the currentPhase is the current phase\n      if (phase)\n        cargo->currentPhase = *phase;\n      else\n        cargo->currentPhase = 1;    // default\n    }\n\n    // store pointer to the cargo structure\n    *vm_cargo=(void*)cargo;\n\n    if (cargo->previousCargo != NULL){\n      // this is a recursive method invocation\n      // use the parentVMflag to indicate running in already existing child VM\n      vmplan->parentVMflag = 1;\n    }\n  }\n\n  delete[] name;  // delete memory that \"newtrim\" allocated above\n\n  // store the current timeout in the cargo structure\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n  if (timeout)\n    cargo->timeout = *timeout;\n  else\n    cargo->timeout = -1;          // indicate invalid timeout\n\n  // increment recursionCount before entering child VM\n  if (recursionCount) (*recursionCount)++;\n\n  // enter the child VM -> resurface in ESMCI_FTableCallEntryPointVMHop()\n#if 0\nstd::cout << \">>> calling into vm_parent->enter() with parentVMflag:\" \n  <<  vmplan->parentVMflag <<\"\\n\";\n#endif\n  localrc = vm_parent->enter(vmplan, *vm_info, *vm_cargo);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return; // bail out\n\n#if 0\nstd::cout << \"<<< parent thread returned from vm_parent->enter()\" << \"\\n\";\n#endif\n\n  // ... if the child VM uses threads (multi-threading or single-threading)\n  // then this parent PET continues running concurrently to the child PET in the\n  // same VAS! In that case the return codes in cargo are not valid here!\n  // The status returned by VM::enter() indicates that success of entering the\n  // child VM, not failure or success of the callback.\n  // The return code of the callback code will be valid in all cases (threading\n  // or no threading) _after_ VMK::exit() returns.\n\n  // get a pointer to the CompTunnel object\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // decrement recursionCount here for the dual side of a comp tunnel\n    // in general the decrement must happen during the wait, in case there\n    // are separate parent vs child threads running, but for comp tunnel must\n    // apply the decrement here\n    if (recursionCount) (*recursionCount)--;\n  }\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compwait\"\nvoid FTN_X(c_esmc_compwait)(\n  ESMCI::VM **ptr_vm_parent,  // p2 to the parent VM\n  ESMCI::VMPlan **ptr_vmplan, // p2 to the VMPlan for component's VM\n  void **vm_info,             // p2 to member which holds info\n  void **vm_cargo,            // p2 to member which holds cargo\n  int *timeout,               // time out in seconds\n  int *recursionCount,        // keeping track of recursion level of component\n  int *userrc,                // return code of the user component method\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  int localrc = ESMC_RC_NOT_IMPL;\n  if (rc) *rc = ESMC_RC_NOT_SET; // return code of ESMF callback code\n\n  // Things get a little confusing here with pointers, so I will define\n  // some temp. variables that make matters a little clearer I hope:\n  ESMCI::VM *vm_parent = *ptr_vm_parent;        // pointer to parent VM\n  ESMCI::VMPlan *vmplan = *ptr_vmplan;          // pointer to VMPlan\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;  // pointer to cargo\n\n  // return with errors if there is no cargo to obtain error codes\n  if (cargo == NULL){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n      \" - No cargo structure to obtain error codes\", ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // get a pointer to the CompTunnel object\n  ESMCI::Comp *f90comp = cargo->f90comp;\n  ESMCI::CompTunnel *compTunnel;\n  localrc = f90comp->getTunnel(&compTunnel);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // determine whether this is a dual component that is ready to execute\n  bool dualConnected = false;  // initialize\n  if (compTunnel) dualConnected = compTunnel->isConnected();\n\n  if (dualConnected){\n    // this is a dual component with a compTunnel that is connected\n    // -> execute compTunnel::wait() on dual components VM.\n\n    if (timeout == NULL){\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL,\n        \" - Must provide valid timeout argument\", ESMC_CONTEXT, rc);\n      return;\n    }\n\n    ESMCI::State *is = compTunnel->getImportState();\n    ESMCI::State *es = compTunnel->getImportState();\n    ESMCI::Clock **clock = compTunnel->getClock();\n\n    ESMCI::Clock *clockP = NULL; // default initialize\n    if (clock) clockP = *clock;\n\n    int userRc = ESMC_RC_NOT_IMPL;\n\n    localrc = f90comp->execute(ESMCI::METHOD_WAIT, is, es, clockP,\n      ESMF_NONBLOCKING,       // nonblocking or else endless recursion!!!\n      1, *timeout, &userRc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // TODO: in case of threading the userRc in not immediatly available!\n    if (ESMC_LogDefault.MsgFoundError(userRc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return; // bail out too because this is for an internal routine\n  }\n\n  // Now call the vmk_exit function which will block respective PETs\n  vm_parent->exit(static_cast<ESMCI::VMKPlan *>(vmplan), *vm_info);\n\n  // obtain return codes out of cargo\n  //TODO: deal with multiple return codes coming back for multi-threaded VMs\n  localrc = cargo->esmfrc[0];\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (userrc) *userrc = cargo->userrc[0];\n\n  // delete cargo structure and handle recursion\n  delete [] cargo->esmfrc;\n  delete [] cargo->userrc;\n  *vm_cargo = cargo->previousCargo; // bring back previous cargo structure\n  vmplan->parentVMflag = cargo->previousParentFlag;   // previous value\n  delete cargo;\n\n  if (!dualConnected){\n    // decrement recursionCount here if not dual side of a comp tunnel\n    if (recursionCount) (*recursionCount)--;\n  }\n  \n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"c_esmc_compget\"\nvoid FTN_X(c_esmc_compget)(\n  void **vm_cargo,            // p2 to member which holds cargo\n  enum ESMCI::method *method, // method type\n  int *phase,                 // phase selector\n  int *timeout,               // timeout\n  int *rc){                   // esmf internal return error code\n\n  // initialize the return codes\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n\n  ESMCI::cargotype *cargo = (ESMCI::cargotype *)*vm_cargo;\n\n  if (cargo){\n    *method = cargo->currentMethod;\n    *phase = cargo->currentPhase;\n    *timeout = cargo->timeout;\n  }else{\n    *method = ESMCI::METHOD_NONE;\n    *phase = 0;\n    *timeout = 0;\n  }\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n\n} // extern \"C\"\n//==============================================================================\n\n\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//\n// This section implements the FTable class\n//\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n\nnamespace ESMCI {\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDP()\"\nvoid FTable::getDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->getDataPtr(name, datap, &dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDP()\"\nvoid FTable::setDP(FTable ***ptr, void **datap, int *rc){\n  char const *name = \"localdata\";\n  enum dtype dtype = DT_FORTRAN_UDT_POINTER;\n  int localrc;\n\n  // Initialize return code; assume routine not implemented\n  if (rc) *rc = ESMC_RC_NOT_IMPL;\n  localrc = ESMC_RC_NOT_IMPL;\n\n  //printf(\"ptr = 0x%08x\\n\", (ESMC_POINTER)ptr);\n  //printf(\"*ptr = 0x%08x\\n\", (ESMC_POINTER)(*(int*)ptr));\n  if ((ptr == ESMC_NULL_POINTER) || (*ptr == ESMC_NULL_POINTER)) {\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  localrc = (**ptr)->setDataPtr(name, datap, dtype);\n  if (rc) *rc = localrc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getDataPtr()\"\n//BOPI\n// !IROUTINE:  getDataPtr - get data pointer from name\n//\n// !INTERFACE:\nint FTable::getDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // out, data address\n      enum dtype *dtype) {   // out, data type\n//\n// !DESCRIPTION:\n//    Returns the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  int i;\n\n  for (i=datacount-1; i>=0; i--) {    // go backwards for: \"last in first out\"\n    if (strcmp(namep, data[i].dataname)) continue;\n\n    *dtype = data[i].dtype;\n\n    if (*dtype == DT_VOIDP){\n      *datap = data[i].dataptr;\n    }else if (*dtype == DT_FORTRAN_UDT_POINTER){\n      FTN_X(f_esmf_fortranudtpointercopy)((void *)datap, data[i].dataptr);\n    }\n\n    return ESMF_SUCCESS;\n  }\n\n  return ESMF_FAILURE;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setDataPtr()\"\n//BOPI\n// !IROUTINE:  setDataPtr - set data pointer\n//\n// !INTERFACE:\nint FTable::setDataPtr(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *namep,     // in, data name\n      void **datap,          // in, data address\n      enum dtype dtype) {    // in, data type\n//\n// !DESCRIPTION:\n//    Sets the named data pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  if (datacount >= dataalloc){\n    data =\n      (datainfo *)realloc((void *)data, (datacount+4) * sizeof(datainfo));\n    dataalloc = datacount+4;\n  }\n  data[datacount].dataname = new char[strlen(namep)+1];\n  strcpy(data[datacount].dataname, namep);\n  data[datacount].dtype = dtype;\n\n  if (dtype == DT_VOIDP){\n    data[datacount].dataptr = *datap;\n  }else if (dtype == DT_FORTRAN_UDT_POINTER){\n    int datumSize;  // upper limit of (UDT, pointer) size\n    FTN_X(f_esmf_fortranudtpointersize)(&datumSize);\n    data[datacount].dataptr = (void *)new char[datumSize];\n    FTN_X(f_esmf_fortranudtpointercopy)(data[datacount].dataptr, (void *)datap);\n  }\n\n  datacount++;\n\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setServices\"\nvoid FTable::setServices(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n  localrc = (tabptr)->setFuncPtr(methodString(METHOD_SETSERVICES),\n    (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // time to startup the VM for this component (if not already started)...\n  ESMCI::VM *vm_parent;\n  localrc = f90comp->getVmParent(&vm_parent);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  ESMCI::VMPlan *vmplan_p;\n  localrc = f90comp->getVmPlan(&vmplan_p);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info==NULL){\n    // VM for this component has not been started yet\n    vm_info = vm_parent->startup(vmplan_p,\n      ESMCI_FTableCallEntryPointVMHop, NULL, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n    // keep vm_info in a safe place (in parent component) 'till it's used again\n    FTN_X(f_esmf_compsetvminfo)(f90comp, &vm_info, &localrc);\n    if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n      rc)) return;\n  }\n  // ...now the component's VM is started up and placed on hold.\n\n  // reset a flag in the component structure\n  FTN_X(f_esmf_compresetvmreleased)(f90comp, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // call into register routine using the component's VM\n  void *vm_cargo = NULL;\n  enum method reg = METHOD_SETSERVICES;\n  FTN_X(c_esmc_ftablecallentrypointvm)(f90comp, &vm_parent, &vmplan_p, &vm_info,\n    &vm_cargo, &tabptr, &reg, NULL, NULL, NULL, NULL, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // wait for the register routine to return\n  FTN_X(c_esmc_compwait)(&vm_parent, &vmplan_p, &vm_info, &vm_cargo, NULL, NULL,\n    userRc, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::Ftable::setVM\"\nvoid FTable::setVM(void *ptr, void (*func)(), int *userRc, int *rc) {\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  if (rc!=NULL) *rc = ESMC_RC_NOT_IMPL;   // final return code\n\n  // Check input\n  if ((ptr == ESMC_NULL_POINTER) || ((*(void**)ptr) == ESMC_NULL_POINTER)){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // cast into ESMCI::Comp pointer\n  ESMCI::Comp *f90comp = (ESMCI::Comp *)ptr;\n\n  // check to see if VM already exists for this Component\n  void *vm_info;\n  localrc = f90comp->getVmInfo(&vm_info);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n  if (vm_info!=NULL){\n    // VM for this component already exists\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_NOT_VALID, \"- VM already exists\",\n      ESMC_CONTEXT, rc);\n    return;\n  }\n\n  // TODO: shouldn't need to expand the table here - should be done inside\n  // FTable code on demand.\n  ESMCI::FTable *tabptr = **(ESMCI::FTable***)ptr;\n  localrc = (tabptr)->extend(32, 2); // room for 32 funcs, 2 data\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Set callback function and arguments\n  localrc = (tabptr)->setFuncPtr(\"setVM\", (void *)func, f90comp);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // Call into user code callback function\n  localrc = (tabptr)->callVFuncPtr(\"setVM\", NULL, userRc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    rc)) return;\n\n  // return successfully\n  if (rc) *rc = ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::getEntry()\"\n//BOPI\n// !IROUTINE:  getEntry - get FTable entry from name\n//\n// !INTERFACE:\nint FTable::getEntry(\n//\n// !RETURN VALUE:\n//    entry index, or -1 if not found.\n//\n// !ARGUMENTS:\n  char const *name,      // in, function name\n  int *rc) {             // out, return code\n//\n// !DESCRIPTION:\n//  Returns the index into the function table that matches \"name\". A linear\n//  search is used, which is sufficient for typically very small function\n//  table sizes.\n//  One added feature this look-up routine also provides is a secondary\n//  search for the actual method name in case that \"name\" was _not_ found,\n//  _and_ \"name\" contained the substring \"IC\" which indicates that this\n//  would have been a look-up for an interface component method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize rc and localrc ; assume functions not implemented\n  if (*rc) *rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, rc);\n    return -1;  // indicate entry not found\n  }\n\n  int i;\n  for (i=0; i<funccount; i++) {\n    if (!strcmp(name, funcs[i].funcname))\n      break;\n  }\n  if (i==funccount) i=-1; // indicate entry not found\n\n//if (i==-1)\n//printf(\"gjt: failed attempt to look up method: %s\\n\", name);\n\n  if (i == -1){\n    // name was not found in function table -> check if name contains \"IC\"\n    char const *ic = strstr(name, \"IC\");\n    if (ic){\n      // this was a failed attempt look up interface component method\n      // -> try actual component method instead\n      int len = strlen(name);\n      char *tempname = new char[len];\n      char *b = tempname;\n      char const *a = name;\n      for (int l=0; l<len+1; l++){\n        if (a!=ic && a!=ic+1){\n          *b = *a;\n          b++;\n        }\n        a++;\n      }\n//printf(\"gjt: failed attempt to look up IC method -> try actual method: %s\\n\",\n//tempname);\n\n      for (i=0; i<funccount; i++) {\n        if (!strcmp(tempname, funcs[i].funcname))\n          break;\n      }\n      if (i==funccount) i=-1; // indicate entry not found\n      delete [] tempname;\n//if (i==-1)\n//printf(\"gjt: failed 2nd attempt to look up method: %s\\n\", name);\n    }\n  }\n\n  // return successfully\n  if (rc!=NULL) *rc = ESMF_SUCCESS;\n  return i;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, no extra args\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func) {          // in, function address\n//\n// !DESCRIPTION:\n//    Sets the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_NULL;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount){\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set function pointer, type; no args yet.\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    void *func,            // in, function address\n    enum ftype ftype) {    // in, function type\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and type, but specifies no argument\n//    values.  Before this can be called successfully, the user must call\n//    FTable::setFuncArgs to fill in the argument list.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc){\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = ftype;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncPtr()\"\n//BOPI\n// !IROUTINE:  setFuncPtr - set voidp, intp specifically\n//\n// !INTERFACE:\nint FTable::setFuncPtr(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,     // in, function name\n    void *func,           // in, function address\n    void *arg){           // in, void *\n//\n// !DESCRIPTION:\n//    Sets the named function pointer and arg.  This is a common case\n//    so it has it's own interface.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // Check input\n  if (name == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (func == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n  if (arg == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // look for the name already existing in the table.  if found\n  // replace it.  otherwise add it to the end.\n  int i;\n  for (i=0; i<funccount; i++)\n    if (!strcmp(name, funcs[i].funcname)) break;\n\n  // we found the function, or we got to the end of the table.\n  // either way we are ready to add it.\n\n  int thisfunc = i;\n\n  // extend the table if needed\n  if (thisfunc >= funcalloc) {\n    funcs = (funcinfo *)realloc((void *)funcs, (thisfunc+4) * sizeof(funcinfo));\n    funcalloc = thisfunc+4;\n  }\n  funcs[thisfunc].funcptr = func;\n  funcs[thisfunc].ftype = FT_VOIDP1INTP;\n  funcs[thisfunc].funcarg[0] = arg;\n  // do these only if not replacing an existing entry.\n  if (thisfunc == funccount) {\n    funcs[thisfunc].funcname = new char[strlen(name)+1];\n    strcpy(funcs[thisfunc].funcname, name);\n    funccount++;\n  }\n\n  // return successfully\n  rc = ESMF_SUCCESS;\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::setFuncArgs()\"\n//BOPI\n// !IROUTINE:  setFuncArgs - set arglist for existing function\n//\n// !INTERFACE:\nint FTable::setFuncArgs(\n//\n// !RETURN VALUE:\n//  int error return code\n//\n// !ARGUMENTS:\n    char const *name,      // in, function name\n    int acount,            // in, count of args\n    void **arglist) {      // in, address of arg list\n//\n// !DESCRIPTION:\n//    Sets the named function args.  The function must already exist.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // Initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;\n  int rc = ESMC_RC_NOT_IMPL;\n\n  // find the \"name\" entry\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n  if (i == -1){\n    char msg[80];\n    sprintf(msg, \"unknown function name: %s\", name);\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, msg, ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // Check arglist argument\n  if (arglist == ESMC_NULL_POINTER){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD, \"null pointer found\",\n      ESMC_CONTEXT, &rc);\n    return rc;\n  }\n\n  // fill in arguments\n  for(int j=0; j<acount; j++)\n    funcs[i].funcarg[j] = arglist[j];\n\n  // return successfully\n  return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::callVFuncPtr()\"\n//BOPI\n// !IROUTINE:  callVFuncPtr - call a function w/ proper args\n//\n// !INTERFACE:\nint FTable::callVFuncPtr(\n//\n// !RETURN VALUE:\n//    integer return code\n//\n// !ARGUMENTS:\n  char const *name,     // in, function name\n  VM *vm_pointer,       // in, optional, pointer to this PET's VM instance\n  int *userrc) {        // out, function return code\n//\n// !DESCRIPTION:\n//    Calls the named function pointer\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  // initialize return code; assume routine not implemented\n  int localrc = ESMC_RC_NOT_IMPL;         // local return code\n  int rc = ESMC_RC_NOT_IMPL;              // final return code\n\n  // sanity check userrc\n  if (!userrc){\n    ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n      \"- userrc must not be NULL pointer!\", ESMC_CONTEXT, &rc);\n    return rc; // bail out\n  }\n\n  // try to find \"name\" entry in single FTable instance on parent PET\n  int i = getEntry(name, &localrc);\n  if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU, ESMC_CONTEXT,\n    &rc)) return rc; // bail out\n\n#if 0\nstd::cout << \"callVFuncPtr found i=\" << i << \"\\n\";\n#endif\n\n  Comp *comp;       // pointer to PET-local component\n  funcinfo *func;   // pointer to PET-local function entry\n\n  // optionally insert vm and replicate Component object, according to situation\n  if (vm_pointer){\n    // vm_pointer was provided -> use to set VM in Component object\n    VM *vmm = vm_pointer;\n    VM **vm = &vmm;\n    int mypet = vm_pointer->getMypet();\n    int mynthreads = vm_pointer->getNthreads(mypet);\n    int mytid = vm_pointer->getTid(mypet);\n#if 0\nstd::cout << \"vm_pointer present, mypet=\" << mypet << \" mynthreads=\" <<\n  mynthreads << \" mytid=\" << mytid <<\"\\n\";\n#endif\n    if (componentcount==0){\n      // first time Component is entering its VM -> replicate Comp\n      if (i == -1){\n        // single FTable instance on parent PET must have contained name\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = funcs + i; // determine PET-local function entry\n      vm_pointer->threadbarrier();  // wait for all the threads to have entered\n      if (mytid==0){\n        // master thread allocates component list in FTable\n        component = new Comp[mynthreads];\n        componentcount = mynthreads;\n        vm_pointer->threadbarrier();  // synchronize with slave threads\n        comp = component;   // determine PET-local component\n        // make a copy of the component reference\n        FTN_X(f_esmf_comprefcopy)(comp, (Comp *)(func->funcarg[0]), &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n        // insert child VM\n        FTN_X(f_esmf_compinsertvm)(comp, vm, &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }else{\n        // slave thread -> replicate component structure, insert child VM\n        vm_pointer->threadbarrier();  // synchronize with master thread\n        // replicate Component from the parent PET w/ private FTable, insert VM\n        comp = component + mytid; // determine PET-local component\n        FTN_X(f_esmf_compreplicate)(comp, (Comp *)(func->funcarg[0]), vm,\n          &localrc);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n    }else if (i>-1){\n      // not first time entry, but found name in FTable\n      // -> must be SetServices _again_\n      func = funcs + i; // determine PET-local function entry\n      comp = component + mytid; // determine PET-local component\n    }else if (componentcount == mynthreads){\n      // subsequent time Component is entering its VM -> obtain comp\n      comp = component + mytid; // determine PET-local component\n      FTable *ftable = **(FTable ***)comp;  // determine comp's FTable instance\n      int j = ftable->getEntry(name, &localrc);\n      if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n        ESMC_CONTEXT, &rc)) return rc; // bail out\n      if (j == -1){\n        ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function name\", ESMC_CONTEXT, &rc);\n        return rc; // bail out\n      }\n      func = ftable->funcs + j; // determine PET-local function entry\n    }else{\n      // fatal inconsistent situation\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"fatal inconsistency between Component and VM\", ESMC_CONTEXT, &rc);\n      return rc;\n    }\n  }else{\n    // vm_pointer was not provided -> simple call-back without VM insertion\n    func = funcs + i; // determine PET-local function entry\n    comp = (Comp *)(func->funcarg[0]);\n  }\n\n  // call-back into user code\n  switch (func->ftype){\n    case FT_VOIDP1INTP: {\n#if 0\nstd::cout << \"calling out of case FT_VOIDP1INTP\" << \"\\n\";\n#endif\n      VoidP1IntPFunc vf = (VoidP1IntPFunc)func->funcptr;\n      (*vf)((void *)comp, userrc);\n      // conditionally set entry point for ServiceLoop\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        localrc = comp->setEntryPoint(METHOD_SERVICELOOP, ServiceLoop);\n        if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n          ESMC_CONTEXT, &rc)) return rc; // bail out\n      }\n      // conditionally call into compliance IC for register\n      if (!strcmp(name, methodString(METHOD_SETSERVICES))){\n        char const *envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCECHECK\");\n        bool complianceCheckFlag = false;  // default internal compl. check off\n        if (envVar != NULL){\n          string value(envVar);\n          // see if compliance checker should be turned on\n          complianceCheckFlag |= value.find(\"on\")!=string::npos;  // turn on\n          complianceCheckFlag |= value.find(\"ON\")!=string::npos;  // turn on\n        }\n\n        if (complianceCheckFlag){\n          int registerIcUserRc;\n\n          // inspect the ESMF_RUNTIME_COMPLIANCEICOBJECT attribute on comp\n          ESMC_Base *base;\n          localrc = comp->getBase(&base);\n          if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n            ESMC_CONTEXT, &rc)) return rc; // bail out\n          ESMC_Logical presentFlag;\n          base->ESMC_BaseGetRoot()->AttributeIsPresent(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\",\n            &presentFlag);\n\n//#ifdef ESMF_NO_DLFCN\n          //if (presentFlag==ESMF_TRUE){\n          //  presentFlag==ESMF_FALSE;\n          //  ESMC_LogDefault.Write(\"Ignoring ESMF_RUNTIME_COMPLIANCEICREGISTER \"\n          //   \"Attribute due to no dynamic linking.\", ESMC_LOGMSG_WARN);\n          //}\n//#endif\n\n\n          if (presentFlag==ESMF_TRUE){\n\n            // access the attribute object in base\n            ESMCI::Attribute *attr=base->ESMC_BaseGetRoot()->AttributeGet(\n              \"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n\n            // retrieve the string value of the attribute\n            std::vector<string> value;\n            localrc = attr->get(&value);\n            if (ESMC_LogDefault.MsgFoundError(localrc, ESMCI_ERR_PASSTHRU,\n              ESMC_CONTEXT, &rc)) return rc; // bail out\n\n            // check the number of strings associated with the attribute\n            if (value.size()!=1){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"Attribute must contain single string\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            // convert routine name according to name mangeling mode\n            //TODO: this would be a good Util method to have\n#ifdef ESMF_LOWERCASE_DOUBLEUNDERSCORE\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"__\";\n#else\n            std::transform(value[0].begin(), value[0].end(), value[0].begin(),\n              ::tolower);\n            value[0]+=\"_\";\n#endif\n\n#if 0\nstd::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n#endif\n\n#ifndef ESMF_NO_DLFCN\n            // check and see if an alternate compliance ic object was specified\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            void *pointer = (void *)dlsym(lib, value[0].c_str());\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n#else\n            //here the compliance register routine has been specified\n            //on the attribute, but we do not have dlopen available\n            //therefore, go for a blind call assuming the NUOPC register\n            //routines have been linked in, which is typically the case\n\n            //std::cout << \"ESMF_RUNTIME_COMPLIANCEICREGISTER attribute:\" << value[0] <<\"\\n\";\n            if (value[0].find(\"nuopc_model\") != std::string::npos) {\n                FTN_X(nuopc_model_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_driver\") != std::string::npos) {\n                FTN_X(nuopc_driver_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else if (value[0].find(\"nuopc_connector\") != std::string::npos) {\n                FTN_X(nuopc_connector_complianceicr)((void *)comp, &registerIcUserRc);\n                if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n                              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n            }\n            else {\n                ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                   \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n                return rc;\n            }\n#endif\n\n          }else{\n            //TODO: In the long run the else branch could be refactored with\n            //TODO: the if branch. Both in principle should be using dlopen()\n            //TODO: for DLFCN based lookup. However, we do not currently build\n            //TODO: correct PIC on all combos for which we have DLFCN enabled,\n            //TODO: and so lookup inside the executable is not yet guaranteed.\n            //TODO: Until this is fixed, the else branch will use hardcoded\n            //TODO: Fortran function directly.\n#define ESMF_NO_DLFCNdummy\n\n#ifdef ESMF_NO_DLFCNdummy\n            FTN_X(esmf_complianceicregister)((void *)comp, &registerIcUserRc);\n\n#else\n#define QUOTEMACRO_(x) #x\n#define QUOTEMACRO(x) QUOTEMACRO_(x)\n\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICOBJECT\");\n            void *lib;\n            lib = dlopen(envVar, RTLD_LAZY);  // envVar==NULL -> look into exe\n            if (lib == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- shared object not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n            envVar = VM::getenv(\"ESMF_RUNTIME_COMPLIANCEICREGISTER\");\n            void *pointer;\n            if (envVar != NULL)\n              pointer = (void *)dlsym(lib, envVar);\n            else\n              pointer = (void *)dlsym(lib,\n                QUOTEMACRO(FTN(esmf_complianceicregister)) );\n            if (pointer == NULL){\n              ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n                \"- compliance IC register routine not found\", ESMC_CONTEXT, &rc);\n              return rc;\n            }\n\n            VoidP1IntPFunc vf = (VoidP1IntPFunc)pointer;\n            (*vf)((void *)comp, &registerIcUserRc);\n#endif\n\n            // compliance IC for register is an internal routine -> look at rc\n            if (ESMC_LogDefault.MsgFoundError(registerIcUserRc,\n              ESMCI_ERR_PASSTHRU, ESMC_CONTEXT, &rc)) return rc; // bail out\n          }\n        }\n      }\n\n      break;\n    }\n    case FT_VOIDP4INTP: {\n#if 0\nstd::cout << \"calling out of case FT_VOIDP4INTP\" << \"\\n\";\n#endif\n      VoidP4IntPFunc vf = (VoidP4IntPFunc)func->funcptr;\n      (*vf)((void *)comp, func->funcarg[1], func->funcarg[2],\n        func->funcarg[3], userrc);\n      break;\n    }\n    default:\n      ESMC_LogDefault.MsgFoundError(ESMC_RC_ARG_BAD,\n        \"unknown function type\", ESMC_CONTEXT, &rc);\n      return rc;\n  }\n\n  // return successfully\n  return ESMF_SUCCESS;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::extend()\"\n//BOPI\n// !IROUTINE:  extend - make space for additional functions/data\n//\n// !INTERFACE:\nint FTable::extend(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int nfuncp,     // in, number of functions which will be added\n      int ndatap) {   // in, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // TODO: allocate space for N items, rounded up?\n    if (nfuncp > funcalloc) {\n        funcs = (funcinfo *)realloc((void *)funcs, nfuncp * sizeof(funcinfo));\n        funcalloc = nfuncp;\n    }\n    if (ndatap > dataalloc) {\n        data = (datainfo *)realloc((void *)data, ndatap * sizeof(datainfo));\n        dataalloc = ndatap;\n    }\n\n    //printf(\"TableExtend called, sizeof(funcinfo)=%d, sizeof(datainfo)=%d\\n\",\n    //                            sizeof(funcinfo), sizeof(datainfo));\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::query()\"\n//BOPI\n// !IROUTINE:  query - return count of functions/data\n//\n// !INTERFACE:\nint FTable::query(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      int *nfuncp,     // out, number of functions which will be added\n      int *ndatap) {   // out, number of data pointers which will be added\n//\n// !DESCRIPTION:\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    // fill in values\n    *nfuncp = funccount;\n    *ndatap = datacount;\n\n    //printf(\"TableQuery method called \\n\");\n    rc = ESMF_SUCCESS;\n    return rc;\n\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::validate()\"\n//BOPI\n// !IROUTINE:  validate - internal consistency check for a Component\n//\n// !INTERFACE:\nint FTable::validate(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {    // in - validate options\n//\n// !DESCRIPTION:\n//      Validates that a Component is internally consistent.\n//      Returns error code if problems are found.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return ESMC_RC_NOT_IMPL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable::print()\"\n//BOPI\n// !IROUTINE:  print - print contents of a Component\n//\n// !INTERFACE:\nint FTable::print(\n//\n// !RETURN VALUE:\n//    int error return code\n//\n// !ARGUMENTS:\n      char const *options) const {     //  in - print options\n//\n// !DESCRIPTION:\n//      Print information about a Component.  The options control the\n//      type of information and level of detail.  Base class method.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n    // Initialize return code; assume routine not implemented\n    int rc = ESMC_RC_NOT_IMPL;\n\n    return rc;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  FTable - native C++ constructor\n//\n// !INTERFACE:\nFTable::FTable(\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n    void){\n//\n// !DESCRIPTION:\n//  Native constructor.\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  //printf(\"in ftable constructor\\n\");\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n  componentcount = 0;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n#undef  ESMC_METHOD\n#define ESMC_METHOD \"~ESMCI::FTable()\"\n//BOPI\n// !IROUTINE:  ~FTable - native C++ destructor\n//\n// !INTERFACE:\nFTable::~FTable(void) {\n//\n// !RETURN VALUE:\n//  none\n//\n// !ARGUMENTS:\n//  none\n//\n// !DESCRIPTION:\n//  Native destructor - deleting internal allocations\n//\n//EOPI\n//-----------------------------------------------------------------------------\n  for (int i=0; i<funccount; i++)\n    funcs[i].~funcinfo();\n  free(funcs);\n  funccount = 0;\n  funcalloc = 0;\n  funcs = NULL;\n\n  for (int i=0; i<datacount; i++)\n    data[i].~datainfo();\n  free(data);\n  datacount = 0;\n  dataalloc = 0;\n  data = NULL;\n\n  for (int i=1; i<componentcount; i++){\n    // skip i=0 since that is identical to the actual Component object\n    Comp *comp = component + i;\n    FTable *ftable = **(FTable ***)comp;\n    delete ftable;\n    ftable = NULL;\n    int localrc;\n    FTN_X(f_esmf_compdelete)(comp, &localrc);\n  }\n  delete [] component;\n  component = NULL;\n}\n//-----------------------------------------------------------------------------\n\n//==============================================================================\n//\n// this trim routine does several things:\n//\n// most importantly, it null terminates a counted-char string passed in\n// from fortran.  it's not guarenteed you can write into the N+1th\n// character location (if the string is full length in fortran, for example)\n// so we're forced to make a copy and copy into it.  this routine allocates,\n// so the char string created here MUST be deleted by the caller when finished.\n//\n// secondly, the phase number (init 1, init 2, etc) is passed in as an int.\n// if > 0 this routine turns it into a 2-char string filled with\n// leading 0s and tacks it onto the end of the name to make it unique.\n//\n// and finally, component routines can be called with either a single\n// state or a pair of states. we can require that the user specify the\n// interface at registration time, or we can decide at run time which\n// form was called and dispatch the corresponding entry point.\n// for now i'm going to fill both types of component entry points for each\n// registration.  i can always remove that code if we force the user\n// to specify at registration time what format the states are expected in.\n// so if nstate > 0, it gets the same treatment as phase: it's turned into\n// a single char string and tacked on the end.\n//\n// (we'd also at some point like to be able to pass back into fortran\n// a really type(State) F90 array - but the bytes on the stack are\n// compiler dependent - we'd have to create the array in fortran and\n// save a copy of it to be safe.  that code is *NOT* implemented at this\n// point, but i know it would sure seem natural from the user's viewpoint.)\n//\n\n// this is max of 2 char phase + 'P' + 1 char nstate + 'S' + trailing NULL\n#define MAXPAD 8\n\nvoid FTable::newtrim(char const *oldc, int clen, int *phase, int *nstate,\n  char **newc) {\n  char *cp, *ctmp;\n  int hasphase = 0;\n  int hasstate = 0;\n  char tspace[MAXPAD];\n  int pad=2;         // if neither phase nor nstate, still need term NULL\n\n  //printf(\"in newtrim, oldc = '%s', clen = %d\\n\", oldc, clen);\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  if ((phase != NULL) && (phase != (int *)-1) && (*phase >= 0))  {\n    pad = MAXPAD;\n    hasphase++;\n  }\n\n  // warning - on the intel compiler, optional args come in\n  // as -1, not 0.  check for both before dereferencing.\n  // if state > 0, use it to alter the EP name.\n  if ((nstate != NULL) && (nstate != (int *)-1) && (*nstate > 0))  {\n    pad = MAXPAD;\n    hasstate++;\n  }\n\n  // make new space and leave room for at least a null terminator, more\n  // if it has either phase or num states or both.\n  ctmp = new char[clen+pad];\n  strncpy(ctmp, oldc, clen);\n  ctmp[clen] = '\\0';\n  for (cp = &ctmp[clen-1]; *cp == ' '; cp--)   // trim() trailing blanks\n    *cp = '\\0';\n\n  // tack on trailing numbers if phase or nstate\n  if (hasphase && hasstate) {\n    sprintf(tspace, \"%02dP%1dS\", *phase, *nstate);\n    strcat(ctmp, tspace);\n  } else if (hasphase) {\n    sprintf(tspace, \"%02dP\", *phase);\n    strcat(ctmp, tspace);\n  } else if (hasstate) {\n    sprintf(tspace, \"%1dS\", *nstate);\n    strcat(ctmp, tspace);\n  }\n\n  // set return pointer.  caller MUST free this when finished with it.\n  *newc = ctmp;\n  //printf(\"out newtrim, newc = '%s'\\n\", *newc);\n\n  return;\n}\n//==============================================================================\n\n\n//==============================================================================\nchar const *FTable::methodString(enum ESMCI::method method){\n  switch(method){\n  case ESMCI::METHOD_NONE:\n    return \"None\";\n    break;\n  case ESMCI::METHOD_INITIALIZE:\n    return \"Initialize\";\n    break;\n  case ESMCI::METHOD_RUN:\n    return \"Run\";\n    break;\n  case ESMCI::METHOD_FINALIZE:\n    return \"Finalize\";\n    break;\n  case ESMCI::METHOD_WRITERESTART:\n    return \"WriteRestart\";\n    break;\n  case ESMCI::METHOD_READRESTART:\n    return \"ReadRestart\";\n    break;\n  case ESMCI::METHOD_SERVICELOOP:\n    return \"ServiceLoop\";\n    break;\n  case ESMCI::METHOD_INITIALIZEIC:\n    return \"InitializeIC\";\n    break;\n  case ESMCI::METHOD_RUNIC:\n    return \"RunIC\";\n    break;\n  case ESMCI::METHOD_FINALIZEIC:\n    return \"FinalizeIC\";\n    break;\n  case ESMCI::METHOD_WRITERESTARTIC:\n    return \"WriteRestartIC\";\n    break;\n  case ESMCI::METHOD_READRESTARTIC:\n    return \"ReadRestartIC\";\n    break;\n  case ESMCI::METHOD_SERVICELOOPIC:\n    return \"ServiceLoopIC\";\n    break;\n  case ESMCI::METHOD_SETSERVICES:\n    return \"Register\";\n    break;\n  case ESMCI::METHOD_WAIT:\n    return \"Wait\";\n    break;\n  default:\n    return \"Unknown\";\n    break;\n  }\n  return NULL;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromString(char const *methodString){\n  if (!strncmp(methodString, \"InitializeIC\", strlen(\"InitializeIC\")))\n    return ESMCI::METHOD_INITIALIZEIC;\n  else if (!strncmp(methodString, \"RunIC\", strlen(\"RunIC\")))\n    return ESMCI::METHOD_RUNIC;\n  else if (!strncmp(methodString, \"FinalizeIC\", strlen(\"FinalizeIC\")))\n    return ESMCI::METHOD_FINALIZEIC;\n  else if (!strncmp(methodString, \"WriteRestartIC\", strlen(\"WriteRestartIC\")))\n    return ESMCI::METHOD_WRITERESTARTIC;\n  else if (!strncmp(methodString, \"ReadRestartIC\", strlen(\"ReadRestartIC\")))\n    return ESMCI::METHOD_READRESTARTIC;\n  else if (!strncmp(methodString, \"Initialize\", strlen(\"Initialize\")))\n    return ESMCI::METHOD_INITIALIZE;\n  else if (!strncmp(methodString, \"Run\", strlen(\"Run\")))\n    return ESMCI::METHOD_RUN;\n  else if (!strncmp(methodString, \"Finalize\", strlen(\"Finalize\")))\n    return ESMCI::METHOD_FINALIZE;\n  else if (!strncmp(methodString, \"WriteRestart\", strlen(\"WriteRestart\")))\n    return ESMCI::METHOD_WRITERESTART;\n  else if (!strncmp(methodString, \"ReadRestart\", strlen(\"ReadRestart\")))\n    return ESMCI::METHOD_READRESTART;\n  else if (!strncmp(methodString, \"Register\", strlen(\"Register\")))\n    return ESMCI::METHOD_SETSERVICES;\n  return ESMCI::METHOD_NONE;\n}\n//==============================================================================\n\n//==============================================================================\nenum method FTable::methodFromIndex(int i){\n  return methodFromString(funcs[i].funcname);\n}\n//==============================================================================\n\n} // namespace ESMCI\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/C48_mosaic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/weights_generic.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile6.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Field/tests/data/horizontal_grid.tile2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/IO/tests/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/IO/tests/io_netcdf_testdata.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/IO/tests/GRIDSPEC_320x160.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Mesh/tests/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Mesh/examples/data/ne4np4-esmf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Grid/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Grid/tests/data/GRIDSPEC_1x1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Grid/tests/data/RCM3_CF_CART2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Grid/tests/data/horizontal_grid.tile6.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Infrastructure/Grid/examples/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/PreESMFMod/tests/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/PreESMFMod/tests/data/ll2.5deg_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/Superstructure/PreESMFMod/tests/data/BT42_ugrid_dual.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/prologue/tests/ESMF_F95PtrUTest.F90",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/test_harness/catalog/sample.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/MAPL5_1/src/GMAO_Shared/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/geos5_esmf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/MAPL/MAPL_Base/TeX/figs/esmf_sandwich.png",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/ESMPy/src/ESMF/util/enum/doc/enum.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/ESMPy/src/ESMF/test/data/T42_grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/ESMPy/src/ESMF/test/data/gridspec1Dcoords.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-pentagons.nc",
        "/tmp/vanessa/spack-stage/spack-stage-esmf-8.0.1-grw5ecgabwzabpmgwikj5utqmwgdaggx/spack-src/src/addon/ESMPy/src/ESMF/test/data/ne4np4-esmf.nc"
    ],
    "total_files": 3654
}