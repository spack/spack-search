{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/layer5/main.cpp": "\n/* \n   A* -------------------------------------------------------------------\n   B* This file contains source code for the PyMOL computer program\n   C* Copyright (c) Schrodinger, LLC. \n   D* -------------------------------------------------------------------\n   E* It is unlawful to modify or remove this copyright notice.\n   F* -------------------------------------------------------------------\n   G* Please see the accompanying LICENSE file for further information. \n   H* -------------------------------------------------------------------\n   I* Additional authors of this source file include:\n   -* \n   -* \n   -*\n   Z* -------------------------------------------------------------------\n*/\n#include\"os_python.h\"\n\n#include \"os_predef.h\"\n\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\n#include <signal.h>\n#include <tchar.h>\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n\n#include \"os_std.h\"\n#include \"os_gl.h\"\n\n#ifdef _DRI_WORKAROUND\n#include <dlfcn.h>\n#endif\n\n#include \"PyMOLGlobals.h\"\n#include \"PyMOL.h\"\n#include \"PyMOLOptions.h\"\n\n#include \"MemoryDebug.h\"\n#include \"Base.h\"\n#include \"main.h\"\n\n#include \"P.h\"\n#include \"PConv.h\"\n#include \"Ortho.h\"\n#include \"Scene.h\"\n#include \"Seq.h\"\n#include \"Util.h\"\n#include \"Control.h\"\n#include \"Movie.h\"\n#include \"Executive.h\"\n\nint _gScaleFactor = 1;\n\n#ifdef _PYMOL_NO_MAIN\n\nint MainSavingUnderWhileIdle(void)\n{\n  return 0;\n}\n\n#else\n\n\nvoid MainFree(void);\nstatic void MainReshape(int width, int height);\nstatic void MainDrawLocked(void);\nstatic void MainDrag(int x, int y);\n\nstatic CPyMOL *PyMOLInstance = NULL;    /* eliminate */\n\nstruct _CMain {\n  int IdleMode;\n  double IdleTime;\n  int IdleCount;\n  int Modifiers;\n  int FinalInitCounter, FinalInitTrigger, FinalInitDone;\n  int TheWindow;\n  int WindowIsVisible;\n  double ReshapeTime;\n  double DrawAfter, DrawDelay;\n  int DrawGovernorActive, DrawDeferred, DrawSignalled;\n  int DrawnFlag, DeferReshapeDeferral;\n  int MaximizeCheck;\n  CPyMOLOptions *OwnedOptions;\n  /* if Main owns a reference to a copy of the startup options that\n     needs to be freed upon shutdown to fully scrub the heap */\n};\n\n\n/* global options */\n\nstatic\nvoid MainOnExit(void);\n\nstatic void MainPushValidContext(PyMOLGlobals * G)\n{\n  PLockStatus(G);\n  PyMOL_PushValidContext(G->PyMOL);\n  PUnlockStatus(G);\n}\n\nstatic void MainPopValidContext(PyMOLGlobals * G)\n{\n  PLockStatus(G);\n  PyMOL_PopValidContext(G->PyMOL);\n  PUnlockStatus(G);\n}\n\nstatic void DrawBlueLine(PyMOLGlobals * G)\n{\n  if(G->Option->blue_line) {\n    GLint i;\n    unsigned long buffer;\n    GLint window_width, window_height;\n\n    window_width = G->Option->winX;\n    window_height = G->Option->winY;\n\n    glPushAttrib(GL_ALL_ATTRIB_BITS);\n\n    glDisable(GL_ALPHA_TEST);\n    glDisable(GL_BLEND);\n    for(i = 0; i < 6; i++)\n      glDisable(GL_CLIP_PLANE0 + i);\n    glDisable(GL_COLOR_LOGIC_OP);\n    glDisable(GL_COLOR_MATERIAL);\n    glDisable(GL_DEPTH_TEST);\n    glDisable(GL_DITHER);\n    glDisable(GL_FOG);\n    glDisable(GL_LIGHTING);\n    glDisable(GL_LINE_SMOOTH);\n    glDisable(GL_LINE_STIPPLE);\n    glDisable(GL_SCISSOR_TEST);\n    glDisable(GL_STENCIL_TEST);\n\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef _PYMOL_OSX\n    /*glDisable(GL_SHARED_TEXTURE_PALETTE_EXT); */\n    glDisable(GL_TEXTURE_1D);\n    glDisable(GL_TEXTURE_2D);\n    glDisable(GL_TEXTURE_3D);\n    glDisable(GL_TEXTURE_CUBE_MAP);\n    glDisable(GL_TEXTURE_RECTANGLE_EXT);\n    glDisable(GL_VERTEX_PROGRAM_ARB);\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n\n    for(buffer = GL_BACK_LEFT; buffer <= GL_BACK_RIGHT; buffer++) {\n      GLint matrixMode;\n      GLint vp[4];\n\n      OrthoDrawBuffer(G, buffer);\n\n      glGetIntegerv(GL_VIEWPORT, vp);\n      glViewport(0, 0, window_width, window_height);\n\n      glGetIntegerv(GL_MATRIX_MODE, &matrixMode);\n      glMatrixMode(GL_PROJECTION);\n      glPushMatrix();\n      glLoadIdentity();\n\n      glMatrixMode(GL_MODELVIEW);\n      glPushMatrix();\n      glLoadIdentity();\n      glScalef(2.0f / window_width, -2.0f / window_height, 1.0f);\n      glTranslatef(-window_width / 2.0f, -window_height / 2.0f, 0.0f);\n\n      /* draw sync lines */\n      glColor3d(0.0f, 0.0f, 0.0f);\n      glBegin(GL_LINES);        /* Draw a background line */\n      glVertex3f(0.0F, window_height - 0.5F, 0.0F);\n      glVertex3f((float) window_width, window_height - 0.5F, 0.0F);\n      glEnd();\n      glColor3d(0.0f, 0.0f, 1.0f);\n      glBegin(GL_LINES);        /* Draw a line of the correct length (the cross\n                                   over is about 40% across the screen from the left */\n      glVertex3f(0.0f, window_height - 0.5f, 0.0f);\n      if(buffer == GL_BACK_LEFT)\n        glVertex3f(window_width * 0.30f, window_height - 0.5f, 0.0f);\n      else\n        glVertex3f(window_width * 0.80f, window_height - 0.5f, 0.0f);\n      glEnd();\n\n      glPopMatrix();\n      glMatrixMode(GL_PROJECTION);\n      glPopMatrix();\n      glMatrixMode(matrixMode);\n\n      glViewport(vp[0], vp[1], vp[2], vp[3]);\n    }\n    glPopAttrib();\n  }\n}\n\n/*========================================================================*/\n\nvoid MainOnExit(void)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  /* \n     here we enter not knowing anything about the current state...\n     so, no graceful exit is possible -- in fact under Window's we'll\n     crash unless we take the drastic way out \n   */\n  if(G && !G->Terminating) {\n    G->Terminating = true;\n    printf(\" PyMOL: abrupt program termination.\\n\");\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\n    TerminateProcess(GetCurrentProcess(), 0);   /* only way to avoid a crash */\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n    exit(EXIT_SUCCESS);\n  }\n}\n\n\n/*========================================================================*/\nint MainSavingUnderWhileIdle(void)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  CMain *I = G->Main;\n  return (I && (I->IdleMode > 3));\n}\n\n\n/*========================================================================*/\nvoid MainSetWindowVisibility(int mode)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  G->Option->window_visible = mode;\n\n}\n\n\n/*========================================================================*/\nstatic void MainDrag(int x, int y)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  CMain *I = G->Main;\n\n  if(PLockAPIAsGlut(G, false)) {\n\n    y = G->Option->winY - y;\n\n    PyMOL_Drag(PyMOLInstance, x, y, I->Modifiers);\n\n    if(PyMOL_GetRedisplay(PyMOLInstance, true)) {\n      if(G->HaveGUI) {\n        p_glutPostRedisplay();\n      }\n    }\n    I->IdleMode = 0;\n\n    PUnlockAPIAsGlut(G);\n  }\n}\n\n\n/*========================================================================*/\nstatic void MainButton(int button, int state, int x, int y)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  int glMod;\n\n  CMain *I = G->Main;\n\n#ifdef WIN32\n  // fix wheel x/y on Windows (PYMOL-2173)\n  switch(button) {\n  case P_GLUT_BUTTON_SCROLL_FORWARD:\n  case P_GLUT_BUTTON_SCROLL_BACKWARD:\n    x -= p_glutGet(P_GLUT_WINDOW_X);\n    y -= p_glutGet(P_GLUT_WINDOW_Y);\n  }\n#endif\n\n  glMod = p_glutGetModifiers();\n\n  if(PLockAPIAsGlut(G, false)) {\n\n    I->IdleMode = 0;            /* restore responsiveness */\n\n    if(PyMOL_GetPassive(PyMOLInstance, (button < 3) ? true : false)) {\n      MainDrag(x, y);\n    } else {\n      /* stay blocked here because Clicks->SexFrame->PParse */\n\n      y = G->Option->winY - y;\n\n      I->Modifiers = ((glMod & P_GLUT_ACTIVE_SHIFT) ? cOrthoSHIFT : 0) |\n        ((glMod & P_GLUT_ACTIVE_CTRL) ? cOrthoCTRL : 0) |\n        ((glMod & P_GLUT_ACTIVE_ALT) ? cOrthoALT : 0);\n\n      PyMOL_Button(PyMOLInstance, button, state, x, y, I->Modifiers);\n    }\n\n    PUnlockAPIAsGlut(G);\n  }\n}\n\n\n/*========================================================================*/\nstatic void MainPassive(int x, int y)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  CMain *I = G->Main;\n\n#define PASSIVE_EDGE 20\n\n  if(PyMOL_GetPassive(G->PyMOL, false)) {       /* a harmless race condition -- we don't want\n                                                   to slow Python down buy locking on passive\n                                                   mouse motion */\n\n    if(PLockAPIAsGlut(G, false)) {\n      if((y < -PASSIVE_EDGE) || (x < -PASSIVE_EDGE) ||\n         (x > (G->Option->winX + PASSIVE_EDGE)) ||\n         (y > (G->Option->winY + PASSIVE_EDGE))) {\n\n        /* release passive drag if mouse leaves window... \n           [IF we continue to receive mouse events...] */\n\n        y = G->Option->winY - y;\n\n        PyMOL_Button(PyMOLInstance, P_GLUT_LEFT_BUTTON, P_GLUT_UP, x, y, I->Modifiers);\n\n        PyMOL_GetPassive(G->PyMOL, true);       /* reset the flag */\n\n      } else {\n\n        y = G->Option->winY - y;\n\n        PyMOL_Drag(PyMOLInstance, x, y, I->Modifiers);\n\n      }\n\n      if(PyMOL_GetRedisplay(PyMOLInstance, true)) {\n        if(G->HaveGUI) {\n          p_glutPostRedisplay();\n        }\n        I->IdleMode = 0;\n      }\n\n      PUnlockAPIAsGlut(G);\n    }\n  }\n\n}\n\n\n/*========================================================================*/\nstatic void MainDrawLocked(void)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  CMain *I = G->Main;\n  if(I->FinalInitTrigger) {\n\n    I->FinalInitTrigger = false;\n\n#ifndef _PYMOL_NOPY\n\n    /* okay, on the way in, the API is locked but the interpreter is\n       running async, so we need to block it */\n\n    PBlock(G);\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n    /* next, we need to let PyMOL know we have a valid context,\n       because some initializations, involve GL calls (such as going\n       into full-screen or stereo mode) */\n\n    if(G->HaveGUI)\n      MainPushValidContext(G);\n\n    /* restore working directory if asked to */\n    PRunStringModule(G,\n                     \"if 'PYMOL_WD' in os.environ: os.chdir(os.environ['PYMOL_WD'])\");\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef _PYMOL_OSX\n    PRunStringModule(G,\n                     \"if os.getcwd()[-23:]=='.app/Contents/Resources': os.chdir('../../..')\");\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n    PXDecRef(PYOBJECT_CALLMETHOD(G->P_inst->obj, \"launch_gui\", \"O\", G->P_inst->obj));\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n    PXDecRef(PYOBJECT_CALLMETHOD\n             (G->P_inst->obj, \"adapt_to_hardware\", \"O\", G->P_inst->obj));\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n    if(G->Option->incentive_product) {  /* perform incentive product initialization (if any) */\n      PyRun_SimpleString(\"try:\\n   import ipymol\\nexcept:\\n   pass\\n\");\n      if(PyErr_Occurred())\n        PyErr_Print();\n    }\n\n    PXDecRef(PYOBJECT_CALLMETHOD(G->P_inst->obj, \"exec_deferred\", \"O\", G->P_inst->obj));\n\n    if(PyErr_Occurred())\n      PyErr_Print();\n\n    if(G->HaveGUI)\n      MainPopValidContext(G);\n\n    PUnblock(G);\n\n#endif\n    I->FinalInitDone = true;\n  }\n\n  PyMOL_Draw(PyMOLInstance);\n\n  if(G->HaveGUI) {\n    if(Feedback(G, FB_OpenGL, FB_Debugging)) {\n      PyMOLCheckOpenGLErr(\"During Rendering\");\n    }\n  }\n\n  if(PyMOL_GetSwap(G->PyMOL, true)) {\n    if(!SettingGetGlobal_b(G, cSetting_suspend_updates))\n      if(G->HaveGUI) {\n        DrawBlueLine(G);\n        p_glutSwapBuffers();\n      }\n  }\n}\n\nstatic void MainDrawProgress(PyMOLGlobals * G)\n{\n  int progress[PYMOL_PROGRESS_SIZE];\n  int update = false;\n  PBlock(G);\n  PLockStatus(G);\n  update = PyMOL_GetProgress(G->PyMOL, progress, true);\n  PUnlockStatus(G);\n  PUnblock(G);\n\n  /*\n     printf(\"show progress %d %d %d %d %d %d\\n\",\n     progress[0],progress[1],progress[2],\n     progress[3],progress[4],progress[5]); */\n\n  if(update &&\n     (progress[PYMOL_PROGRESS_SLOW] ||\n      progress[PYMOL_PROGRESS_MED] || progress[PYMOL_PROGRESS_FAST])) {\n\n    int offset;\n    int x = 0, y;\n    float black[3] = { 0, 0, 0 };\n    float white[3] = { 1, 1, 1 };\n    GLint ViewPort[4];\n\n#define cBusyWidth 240\n#define cBusyHeight 60\n#define cBusyMargin 10\n#define cBusyBar 10\n#define cBusySpacing 15\n\n    glGetIntegerv(GL_VIEWPORT, ViewPort);\n    glMatrixMode(GL_PROJECTION);\n    glPushMatrix();\n    glLoadIdentity();\n    glOrtho(0, ViewPort[2], 0, ViewPort[3], -100, 100);\n    glMatrixMode(GL_MODELVIEW);\n    glPushMatrix();\n    glLoadIdentity();\n    glTranslatef(0.33F, 0.33F, 0.0F);   /* this generates better \n                                           rasterization on macs */\n\n    glDisable(GL_ALPHA_TEST);\n    glDisable(GL_LIGHTING);\n    glDisable(GL_FOG);\n    glDisable(GL_NORMALIZE);\n    glDisable(GL_DEPTH_TEST);\n    glDisable(GL_COLOR_MATERIAL);\n    glDisable(GL_LINE_SMOOTH);\n    glDisable(GL_DITHER);\n    glDisable(GL_BLEND);\n\n    {\n      int pass = 0;\n\n      int draw_both = SceneMustDrawBoth(G);\n\n      glClear(GL_DEPTH_BUFFER_BIT);\n      while(1) {\n        if(draw_both) {\n          if(!pass)\n            OrthoDrawBuffer(G, GL_FRONT_LEFT);\n          else\n            OrthoDrawBuffer(G, GL_FRONT_RIGHT);\n        } else {\n          OrthoDrawBuffer(G, GL_FRONT); /* draw into the front buffer */\n        }\n\n        glColor3fv(black);\n        glBegin(GL_POLYGON);\n        glVertex2i(0, ViewPort[3]);\n        glVertex2i(cBusyWidth, ViewPort[3]);\n        glVertex2i(cBusyWidth, ViewPort[3] - cBusyHeight);\n        glVertex2i(0, ViewPort[3] - cBusyHeight);\n        glVertex2i(0, ViewPort[3]);     /* needed on old buggy Mesa */\n        glEnd();\n        y = ViewPort[3] - cBusyMargin;\n\n        glColor3fv(white);\n\n        /* \n           c=I->BusyMessage;\n           if(*c) {\n           TextSetColor(G,white);\n           TextSetPos2i(G,cBusyMargin,y-(cBusySpacing/2));\n           TextDrawStr(G,c);\n           y-=cBusySpacing;\n           }\n         */\n\n        for(offset = 0; offset < PYMOL_PROGRESS_SIZE; offset += 2) {\n\n          if(progress[offset + 1]) {\n            glBegin(GL_LINE_LOOP);\n            glVertex2i(cBusyMargin, y);\n            glVertex2i(cBusyWidth - cBusyMargin, y);\n            glVertex2i(cBusyWidth - cBusyMargin, y - cBusyBar);\n            glVertex2i(cBusyMargin, y - cBusyBar);\n            glVertex2i(cBusyMargin, y); /* needed on old buggy Mesa */\n            glEnd();\n            glColor3fv(white);\n            x =\n              (progress[offset] * (cBusyWidth - 2 * cBusyMargin) / progress[offset + 1]) +\n              cBusyMargin;\n            glBegin(GL_POLYGON);\n            glVertex2i(cBusyMargin, y);\n            glVertex2i(x, y);\n            glVertex2i(x, y - cBusyBar);\n            glVertex2i(cBusyMargin, y - cBusyBar);\n            glVertex2i(cBusyMargin, y); /* needed on old buggy Mesa */\n            glEnd();\n            y -= cBusySpacing;\n          }\n        }\n        if(!draw_both)\n          break;\n        if(pass > 1)\n          break;\n        pass++;\n      }\n\n      glFlush();\n      glFinish();\n      if(draw_both)\n        OrthoDrawBuffer(G, GL_BACK_LEFT);\n      else\n        OrthoDrawBuffer(G, GL_BACK);\n    }\n\n    glPopMatrix();\n    glMatrixMode(GL_PROJECTION);\n    glPopMatrix();\n    glMatrixMode(GL_MODELVIEW);\n\n  }\n}\n\n\n/*========================================================================*/\nstatic void MainDraw(void)\n{\n  int usec_sleep_after_draw = 0;\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  PRINTFD(G, FB_Main)\n    \" MainDraw: called.\\n\" ENDFD;\n  if(PLockAPIAsGlut(G, false)) {\n    CMain *I = G->Main;\n    if(I->DrawGovernorActive &&\n       (!I->DrawSignalled) && (UtilGetSeconds(G) < I->DrawAfter) && I->FinalInitDone) {\n      I->DrawDeferred = true;\n    } else {\n      int skip = false;\n      if(I->MaximizeCheck) {\n        {\n          /* is the window manager screwing us over??? */\n\n          int height = p_glutGet(P_GLUT_SCREEN_HEIGHT);\n          int width = p_glutGet(P_GLUT_SCREEN_WIDTH);\n          int actual_x = p_glutGet(P_GLUT_WINDOW_X);\n          int actual_y = p_glutGet(P_GLUT_WINDOW_Y);\n\n          I->MaximizeCheck = false;\n\n          if(actual_x != 0) {\n            width -= 2 * actual_x;\n            height -= actual_x;\n          }\n          if(actual_y != 0) {\n            height -= actual_y;\n          }\n          p_glutPositionWindow(0, 0);\n          p_glutReshapeWindow(width, height);\n          skip = true;\n        }\n      }\n      if((!skip) && (!I->DrawnFlag) && I->FinalInitDone) {\n        if(I->DeferReshapeDeferral > 0)\n          I->DeferReshapeDeferral--;\n        else {\n          double time_since_reshape = UtilGetSeconds(G) - I->ReshapeTime;\n          if(time_since_reshape < 0.05) {\n            /* defer screen updates while it's being actively resized */\n            skip = true;\n          }\n        }\n      }\n      if(!skip) {\n        MainDrawLocked();\n        I->DrawnFlag = true;\n        if(PyMOL_GetModalDraw(PyMOLInstance)) {\n          usec_sleep_after_draw = 10000;        /* give other threads a chance to run */\n        }\n      } else {\n        PyMOL_NeedRedisplay(PyMOLInstance);\n      }\n\n      I->DrawAfter = UtilGetSeconds(G) + I->DrawDelay;\n      I->DrawSignalled = false;\n      I->DrawDeferred = false;\n    }\n    PUnlockAPIAsGlut(G);\n  } else {                      /* we're busy -- so try to display a progress indicator */\n    MainDrawProgress(G);\n  }\n  PRINTFD(G, FB_Main)\n    \" MainDraw: completed.\\n\" ENDFD;\n  if(usec_sleep_after_draw && G) {\n    PSleepUnlocked(G, usec_sleep_after_draw);\n  }\n}\n\n\n/*========================================================================*/\nstatic void MainKey(unsigned char k, int x, int y)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  CMain *I = G->Main;\n  int glMod;\n\n  glMod = p_glutGetModifiers();\n\n#if defined(_PYMOL_OSX) && !defined(_PYMOL_LIB)\n  // MacOS GLUT.framework: swap delete and backspace\n  switch (k) {\n    case 0x08: k = 0x7f; break;\n    case 0x7f: k = 0x08; break;\n  }\n#endif\n\n  PRINTFB(G, FB_Main, FB_Blather)\n    \" MainKey: code:%d modifiers:0x%02x x:%d y:%d\\n\", k, glMod, x, y ENDFB(G);\n  if(PLockAPIAsGlut(G, false)) {\n\n    I->IdleMode = 0;            /* restore responsiveness */\n\n    I->Modifiers = ((glMod & P_GLUT_ACTIVE_SHIFT) ? cOrthoSHIFT : 0) |\n      ((glMod & P_GLUT_ACTIVE_CTRL) ? cOrthoCTRL : 0) |\n      ((glMod & P_GLUT_ACTIVE_ALT) ? cOrthoALT : 0);\n\n    PyMOL_Key(PyMOLInstance, k, x, y, I->Modifiers);\n\n    PUnlockAPIAsGlut(G);\n  } else {\n    if((k == 8) || (k == 127)) {        /* interrupt busy state (if possibele) */\n      PBlock(G);\n      PLockStatus(G);\n      PyMOL_SetInterrupt(G->PyMOL, true);\n      PUnlockStatus(G);\n      PUnblock(G);\n    }\n  }\n}\n\n\n/*========================================================================*/\nstatic void MainSpecial(int k, int x, int y)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  CMain *I = G->Main;\n  int glMod;\n\n  PRINTFB(G, FB_Main, FB_Blather)\n    \" MainSpecial: %d %d %d\\n\", k, x, y ENDFB(G);\n  glMod = p_glutGetModifiers();\n  if(PLockAPIAsGlut(G, false)) {\n\n    I->Modifiers = ((glMod & P_GLUT_ACTIVE_SHIFT) ? cOrthoSHIFT : 0) |\n      ((glMod & P_GLUT_ACTIVE_CTRL) ? cOrthoCTRL : 0) |\n      ((glMod & P_GLUT_ACTIVE_ALT) ? cOrthoALT : 0);\n\n    PyMOL_Special(PyMOLInstance, k, x, y, I->Modifiers);\n\n    PUnlockAPIAsGlut(G);\n  }\n}\n\n\n/* new window size or exposure */\n\n/*========================================================================*/\nvoid MainReshape(int width, int height)\n{                               /* called by Glut */\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  if(G) {\n    CMain *I = G->Main;\n\n    I->ReshapeTime = (double) UtilGetSeconds(G);\n    I->DrawnFlag = false;\n\n    if (width==0 || height==0)\n      return;\n    if(PLockAPIAsGlut(G, true)) {\n      if(G->HaveGUI) {\n        glViewport(0, 0, (GLint) width, (GLint) height);\n        if((!PyMOLInstance) ||\n           (width != OrthoGetWidth(G)) || (height != OrthoGetHeight(G))) {\n          /* wipe the screen ASAP to prevent display of garbage... */\n\n          int draw_both = G->StereoCapable &&\n            ((SceneGetStereo(G) == 1) ||\n             SettingGetGlobal_b(G, cSetting_stereo_double_pump_mono));\n\n          SceneGLClearColor(0.0, 0.0, 0.0, 1.0);\n          if(draw_both) {\n            OrthoDrawBuffer(G, GL_FRONT_LEFT);\n            glClear(GL_COLOR_BUFFER_BIT);\n            OrthoDrawBuffer(G, GL_FRONT_RIGHT);\n            glClear(GL_COLOR_BUFFER_BIT);\n            OrthoDrawBuffer(G, GL_BACK_LEFT);\n            glClear(GL_COLOR_BUFFER_BIT);\n            OrthoDrawBuffer(G, GL_BACK_RIGHT);\n            glClear(GL_COLOR_BUFFER_BIT);\n          } else {\n            OrthoDrawBuffer(G, GL_FRONT);\n            glClear(GL_COLOR_BUFFER_BIT);\n            OrthoDrawBuffer(G, GL_BACK);\n            glClear(GL_COLOR_BUFFER_BIT);\n          }\n        }\n        PyMOL_SwapBuffers(PyMOLInstance);\n      }\n    }\n    if(PyMOLInstance)\n      PyMOL_Reshape(PyMOLInstance, width, height, false);\n    PUnlockAPIAsGlut(G);\n  }\n}\n\n\n/*========================================================================*/\nvoid MainDoReshape(int width, int height)\n{                               /* called internally */\n  int internal_feedback;\n  int force = false;\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  if(G) {\n    /* if width and height are negative and we are in full screen, don't reshape window */\n    bool keep_fullscreen = (width < 0 && height < 0 && ExecutiveIsFullScreen(G));\n\n    /* if width is negative, force a reshape based on the current width */\n\n    if(width < 0) {\n      width = SceneGetBlock(G)->getWidth();\n      if(SettingGetGlobal_b(G, cSetting_internal_gui))\n        width += SettingGetGlobal_i(G, cSetting_internal_gui_width);\n      force = true;\n    } \n\n    /* if height is negative, force a reshape based on the current height */\n\n    if(height < 0) {\n      height = SceneGetBlock(G)->getHeight();\n      internal_feedback = SettingGetGlobal_i(G, cSetting_internal_feedback);\n      if(internal_feedback)\n        height += (internal_feedback - 1) * cOrthoLineHeight + cOrthoBottomSceneMargin;\n      if(SettingGetGlobal_b(G, cSetting_seq_view)\n         && !SettingGetGlobal_b(G, cSetting_seq_view_overlay))\n        height += SeqGetHeight(G);\n      height += MovieGetPanelHeight(G);\n      force = true;\n    } \n\n    /* if we have a GUI, for a reshape event */\n\n    if(G->HaveGUI && G->ValidContext && width > 0 && height > 0) {\n      p_glutReshapeWindow(width, height);\n      glViewport(0, 0, (GLint) width, (GLint) height);\n    }\n\n    if((!width)||(!height)) {\n      int actual_width = width ? width : G->Option->winX;\n      int actual_height = height ? height : G->Option->winY;\n\n      PyMOL_Reshape(G->PyMOL, actual_width, actual_height, true);\n\n    } else {\n      PyMOL_Reshape(G->PyMOL, width, height, force);\n      if(G->Main) {\n        G->Main->DeferReshapeDeferral = 1;\n      }\n\n      /* do we need to become full-screen? */\n      if(keep_fullscreen) {\n        p_glutFullScreen();\n      }\n    }\n  }\n\n}\n\n\n/*========================================================================*/\nstatic void MainInit(PyMOLGlobals * G)\n{\n\n  CMain *I = (G->Main = pymol::calloc<CMain>(1));\n  /* Data structure is zeroed on start...no need for explicit zero inits */\n\n  I->DeferReshapeDeferral = 1;\n\n  PyMOL_Start(PyMOLInstance);\n\n  // moved to PyMOL_DrawWithoutLock\n  // PyMOL_ConfigureShadersGL(PyMOLInstance);\n\n  PyMOL_SetSwapBuffersFn(PyMOLInstance, (PyMOLSwapBuffersFn *) p_glutSwapBuffers);\n  I->ReshapeTime = (I->IdleTime = UtilGetSeconds(G));\n\n  I->DrawGovernorActive = false;\n  I->DrawSignalled = true;\n  I->DrawDelay = 0.01;          /* 100 FPS max */\n  I->DrawAfter = 0.0;\n  I->DrawDeferred = false;\n}\n\n\n/*========================================================================*/\nvoid MainFree(void)\n{\n  PyMOLGlobals *G = PyMOL_GetGlobals(PyMOLInstance);    /* temporary -- will change */\n\n  CPyMOLOptions *owned_options = G->Main->OwnedOptions;\n\n  int show_message = G->Option->show_splash && !G->Option->quiet;\n\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\n  int haveGUI = G->HaveGUI;\n  int theWindow = G->Main->TheWindow;\n#endif\n#ifdef _PYMOL_OSX\n  int game_mode = G->Option->game_mode;\n  int haveGUI = G->HaveGUI;\n  int theWindow = G->Main->TheWindow;\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n\n  FreeP(G->Main);\n\n  if(owned_options)\n    PyMOLOptions_Free(owned_options);   /* clean up launch options if we're supposed to */\n\n  if(show_message) {\n    printf(\" PyMOL: normal program termination.\\n\");\n  }\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\n  if(haveGUI)\n    p_glutDestroyWindow(theWindow);\n  TerminateProcess(GetCurrentProcess(), 0);     /* only way to avoid a crash */\n#endif\n#ifdef _PYMOL_OSX\n  if(haveGUI) {\n    if(game_mode) {\n      p_glutLeaveGameMode();\n      /* force a full-screen refresh to eliminate garbage on screen \n       * NOTE that we currently have to patch Apple's GLUT to make this work */\n      p_glutInitWindowPosition(0, 0);\n      p_glutInitWindowSize(640, 480);\n      p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE);\n      if(p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE)) {\n        theWindow = p_glutCreateWindow(\"PyMOL Viewer\");\n        p_glutFullScreen();\n        p_glutDestroyWindow(theWindow);\n      }\n    } else\n      p_glutDestroyWindow(theWindow);\n  }\n#endif\n\n/* END PROPRIETARY CODE SEGMENT */\n\n}\n\n\n/*========================================================================*/\nvoid MainRefreshNow(void)\n{                               /* should only be called by the master thread, with a locked API */\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  CMain *I = G->Main;\n  if(PyMOL_GetSwap(G->PyMOL, true)) {\n    if(G->HaveGUI) {\n      DrawBlueLine(G);\n      p_glutSwapBuffers();\n    }\n  }\n  if(PyMOL_GetRedisplay(PyMOLInstance, true)) {\n    if(G->HaveGUI)\n      p_glutPostRedisplay();\n    else\n      MainDrawLocked();\n    I->IdleMode = 0;\n  }\n}\n\n\n/*========================================================================*/\n\nstatic void MainBusyIdle(void)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n  /* This is one of the few places in the program where we can be sure \n   * that we have the \"glut\" thread...glut doesn't seem to be completely\n   * thread safe or rather thread consistent\n   */\n\n  CMain *I = G->Main;\n\n  PRINTFD(G, FB_Main)\n    \" MainBusyIdle: called.\\n\" ENDFD;\n\n  /* flush command and output queues */\n\n  /*  PRINTFD(G,FB_Main)\n     \" MainBusyIdle: entered, IdleMode %d\\n\",\n     I->IdleMode\n     ENDFD; */\n\n  if(PLockAPIAsGlut(G, false)) {\n\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: got lock.\\n\" ENDFD;\n\n    /* change window visibility & refresh, if necessary */\n\n    if(G->HaveGUI) {\n      if(I->WindowIsVisible != G->Option->window_visible) {\n        I->WindowIsVisible = G->Option->window_visible;\n        if(I->WindowIsVisible) {\n          p_glutShowWindow();\n          OrthoDirty(G);\n        } else {\n          p_glutHideWindow();\n        }\n      }\n    }\n\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: calling idle function.\\n\" ENDFD;\n\n    if(PyMOL_Idle(PyMOLInstance)) {\n      /* we did some work, so keep PyMOL responsive */\n      I->IdleMode = 1;\n    } else if(!I->IdleMode) {\n      I->IdleMode = 1;\n    } else if(I->IdleMode == 1) {\n      I->IdleMode = 2;\n      I->IdleTime = UtilGetSeconds(G);\n    }\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: swap check.\\n\" ENDFD;\n\n    if(PyMOL_GetSwap(G->PyMOL, true)) {\n      if(G->HaveGUI) {\n        DrawBlueLine(G);\n        p_glutSwapBuffers();\n      }\n    }\n\n    /* if the screen has become dirty, post a redisplay event, or if\n       we're running without a GUI, then call the draw routine (if we */\n\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: redisplay.\\n\" ENDFD;\n\n    if(PyMOL_GetRedisplay(PyMOLInstance, true)) {\n      if(G->HaveGUI)\n        p_glutPostRedisplay();\n      else\n        MainDrawLocked();\n      if(I->IdleMode > 1) {\n        I->IdleMode = 1;\n      }\n    }\n\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: redisplay.\\n\" ENDFD;\n\n    /* the following code enables PyMOL to avoid busy-idling \n     * even though we're using GLUT! */\n\n    switch (I->IdleMode) {\n    case 2:                    /* avoid racing the CPU */\n      if((UtilGetSeconds(G) - I->IdleTime) > (SettingGetGlobal_f(G, cSetting_idle_delay) / 5.0)) {\n        I->IdleMode = 3;\n        I->IdleTime = UtilGetSeconds(G);\n      }\n      break;\n    case 3:\n      if((UtilGetSeconds(G) - I->IdleTime) > (SettingGetGlobal_f(G, cSetting_idle_delay))) {\n        I->IdleMode = 4;\n        if(G->HaveGUI)\n          if(SettingGetGlobal_b(G, cSetting_cache_display)) {\n            p_glutPostRedisplay();      /* trigger caching of the current scene */\n          }\n        break;\n      }\n    }\n\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: unlocking.\\n\" ENDFD;\n\n    {\n      int control_idling = false;\n      if(I->IdleMode == 1) {\n        control_idling = ControlIdling(G);\n      }\n      PUnlockAPIAsGlut(G);\n\n      switch (I->IdleMode) {\n      case 4:\n        PSleepUnlocked(G, SettingGetGlobal_i(G, cSetting_slow_idle));   /* slow idle - save CPU cycles */\n        break;\n      case 3:\n        PSleepUnlocked(G, SettingGetGlobal_i(G, cSetting_fast_idle));   /* fast idle - more responsive */\n        break;\n      case 2:\n        PSleepUnlocked(G, SettingGetGlobal_i(G, cSetting_no_idle));     /* give Tcl/Tk a chance to run */\n        break;\n      case 1:\n        if(control_idling) {\n          PSleepUnlocked(G, SettingGetGlobal_i(G, cSetting_no_idle));   /* give Tcl/Tk a chance to run */\n        }\n        break;\n      default:\n        break;\n      }\n    }\n\n    /* run final initilization code for Python-based PyMOL implementations. */\n\n#define FINAL_INIT_AT 10\n    if(I->FinalInitCounter < FINAL_INIT_AT) {\n      I->FinalInitCounter = I->FinalInitCounter + 1;\n      if(I->FinalInitCounter == FINAL_INIT_AT) {\n        I->FinalInitTrigger = true;\n        PyMOL_NeedRedisplay(PyMOLInstance);\n      }\n    }\n\n    /* when running in command-line mode, if we're not reading from\n     * standard input and if we're not keeping the thread alive, then \n     * we can have no further input.  Therefore die. */\n\n    if(!G->HaveGUI) {\n      if(!(OrthoCommandWaiting(G) ||\n           PyMOL_GetModalDraw(G->PyMOL) ||\n           OrthoDeferredWaiting(G) || SettingGetGlobal_b(G, cSetting_keep_alive))) {\n        if((!G->Option->keep_thread_alive) &&\n           (!G->Option->read_stdin) && (I->FinalInitCounter >= FINAL_INIT_AT)) {\n          I->IdleCount++;\n          if(I->IdleCount == 10) {\n            if(PLockAPIAsGlut(G, true)) {\n              PParse(G, \"_quit\");\n              PFlush(G);\n              PUnlockAPIAsGlut(G);\n            }\n          }\n        }\n      } else {\n        I->IdleCount = 0;\n      }\n    }\n\n    {\n      int max_ups = SettingGetGlobal_i(G, cSetting_max_ups);\n      if(max_ups < 1) {\n        I->DrawGovernorActive = false;\n        if(I->DrawDeferred) {\n          p_glutPostRedisplay();\n        }\n      } else {\n        I->DrawDelay = 1.0 / max_ups;\n        I->DrawGovernorActive = true;\n        if(I->DrawDeferred) {\n          if(UtilGetSeconds(G) > I->DrawAfter) {\n            I->DrawSignalled = true;\n          }\n          if(I->DrawSignalled) {\n            I->DrawDeferred = false;\n            p_glutPostRedisplay();\n          }\n        }\n      }\n    }\n  } else {\n    PRINTFD(G, FB_Main)\n      \" MainBusyIdle: lock not obtained...\\n\" ENDFD;\n\n    PSleepWhileBusy(G, 100000); /* 10 per second */\n    if(G->HaveGUI) {\n      PBlock(G);\n      PLockStatus(G);\n      if(PyMOL_GetProgressChanged(G->PyMOL, false))\n        p_glutPostRedisplay();\n      PUnlockStatus(G);\n      PUnblock(G);\n    }\n  }\n\n  PRINTFD(G, FB_Main)\n    \" MainBusyIdle: leaving... IdleMode %d\\n\", I->IdleMode ENDFD;\n\n}\n\nvoid MainSetWindowPosition(PyMOLGlobals * G, int x, int y)\n{\n#ifdef _PYMOL_FINK\n  y -= 22;                      /* something is wrong with FinkGlut's window positioning... */\n#endif\n  p_glutPositionWindow(x, y);\n}\n\nvoid MainSetWindowSize(PyMOLGlobals * G, int w, int h)\n{\n  G->Main->DeferReshapeDeferral = 1;\n  p_glutReshapeWindow(w, h);\n}\n\nvoid MainMaximizeWindow(PyMOLGlobals * G)\n{\n  int height = p_glutGet(P_GLUT_SCREEN_HEIGHT);\n  int width = p_glutGet(P_GLUT_SCREEN_WIDTH);\n  G->Main->DeferReshapeDeferral = 1;\n  G->Main->MaximizeCheck = true;\n  p_glutPositionWindow(0, 0);\n  p_glutReshapeWindow(width, height);\n\n}\n\nvoid MainCheckWindowFit(PyMOLGlobals * G)\n{\n  CMain *I = G->Main;\n  if(G && G->Main) {\n    int height = p_glutGet(P_GLUT_SCREEN_HEIGHT);\n    int width = p_glutGet(P_GLUT_SCREEN_WIDTH);\n    int actual_x = p_glutGet(P_GLUT_WINDOW_X);\n    int actual_y = p_glutGet(P_GLUT_WINDOW_Y);\n    int actual_width = p_glutGet(P_GLUT_WINDOW_WIDTH);\n    int actual_height = p_glutGet(P_GLUT_WINDOW_HEIGHT);\n    int new_width = -1;\n    int new_height = -1;\n\n    I->DeferReshapeDeferral = 1;\n\n    if((actual_x + actual_width) > width)\n      new_width = (width - actual_x) - 5;       /* allow room for decoration */\n    if((actual_y + actual_height) > height)\n      new_height = (height - actual_y) - 5;     /* allow room for decoration */\n    if((new_width > 0) || (new_height > 0)) {\n      if(new_width < 0)\n        new_width = actual_width;\n      if(new_height < 0)\n        new_height = actual_height;\n      MainSetWindowSize(G, new_width, new_height);\n    }\n  }\n\n}\n\n\n/*========================================================================*/\n\n\n/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\nBOOL WINAPI HandlerRoutine(DWORD dwCtrlType     /*  control signal type */\n  )\n{\n  switch (dwCtrlType) {\n  case CTRL_CLOSE_EVENT:\n  case CTRL_BREAK_EVENT:\n  case CTRL_C_EVENT:\n    TerminateProcess(GetCurrentProcess(), 0);   /* only way to avoid a crash */\n\n    break;\n  }\n  return 1;\n}\n#endif\n\nstatic void launch(CPyMOLOptions * options, int own_the_options)\n{\n\n  int multisample_mask = 0;\n  int theWindow = 0;\n  PyMOLGlobals *G = NULL;\n\n  PyMOLInstance = PyMOL_NewWithOptions(options);\n  G = PyMOL_GetGlobals(PyMOLInstance);\n\n  if(G->Option->multisample)\n    multisample_mask = P_GLUT_MULTISAMPLE;\n\n  /* if were running GLUT, then we have the ability to increase the\n   * size of the window in order to accomodate the context */\n\n  if(G->Option->internal_gui && (!G->Option->game_mode))\n    G->Option->winX += cOrthoRightSceneMargin;\n\n  if(G->Option->internal_feedback && (!G->Option->game_mode))\n    G->Option->winY +=\n      (G->Option->internal_feedback - 1) * cOrthoLineHeight + cOrthoBottomSceneMargin;\n\n  if(G->HaveGUI) {\n#ifndef _PYMOL_OSX\n    atexit(MainOnExit);         /* register callback to help prevent crashes\n                                   when GLUT spontaneously kills us */\n#endif\n\n    /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in \"os_proprietary.h\") */\n#ifdef WIN32\n    SetConsoleCtrlHandler(HandlerRoutine,       // address of handler function\n                          true  // handler to add or remove\n      );\n    SetConsoleTitle(_T(\"PyMOL\"));\n#endif\n\n    int myArgc = 0;\n    char *myArgv[8] = {\"pymol\"};\n    p_glutInit(&myArgc, myArgv);\n\n    {\n      int display_mode_possible = false;\n      if(G->Option->stereo_mode > 1)\n        G->Option->force_stereo = 0;\n\n      switch (G->Option->force_stereo) {\n      case -1:                 /* force mono */\n        G->StereoCapable = 0;\n        break;\n      case 1:                  /* force quad buffer stereo (if possible) */\n        G->Option->stereo_mode = cStereo_quadbuffer;\n      case 0:                  /* default/autodetect */\n        switch (G->Option->stereo_mode) {\n        case cStereo_default:\n        case cStereo_quadbuffer:\n          p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | multisample_mask |\n                                P_GLUT_DOUBLE | P_GLUT_STEREO);\n          display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n          if(multisample_mask && (!display_mode_possible)) {\n            G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_MultisampleFailed;\n            p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE |\n                                  P_GLUT_STEREO);\n            display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n          }\n          if(display_mode_possible) {\n            G->StereoCapable = 1;\n          } else if(G->Option->stereo_mode == cStereo_quadbuffer) {\n            G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_StereoFailed;\n          }\n          break;\n        case cStereo_clone_dynamic:\n          p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE | P_GLUT_ACCUM\n                                | P_GLUT_STEREO);\n          display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n          if(!display_mode_possible) {\n            G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_StereoFailed;\n            G->Option->stereo_mode = 0;\n          } else {\n            G->StereoCapable = 1;\n          }\n          break;\n        case cStereo_dynamic:\n          p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE |\n                                P_GLUT_ACCUM);\n          display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n          if(!display_mode_possible) {\n            G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_StereoFailed;\n            G->Option->stereo_mode = 0;\n          }\n          break;\n        case cStereo_stencil_by_row:\n        case cStereo_stencil_by_column:\n        case cStereo_stencil_checkerboard:\n        case cStereo_stencil_custom:\n          p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE |\n                                P_GLUT_STENCIL);\n          display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n          if(!display_mode_possible) {\n            G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_StereoFailed;\n            G->Option->stereo_mode = 0;\n          }\n          break;\n        case cStereo_anaglyph: /* nothing special required for anaglyph */\n          G->StereoCapable = 1;\n          break;\n        default:               /* fall through */\n          break;\n        }\n        break;\n      }\n      /* fallback behavior */\n\n      if(!display_mode_possible) {\n        G->LaunchStatus &= ~cPyMOLGlobals_LaunchStatus_MultisampleFailed;\n        p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | multisample_mask |\n                              P_GLUT_DOUBLE);\n        display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n        G->StereoCapable = 0;\n      }\n\n      if(multisample_mask && (!display_mode_possible)) {\n        G->LaunchStatus |= cPyMOLGlobals_LaunchStatus_MultisampleFailed;\n        p_glutInitDisplayMode(P_GLUT_RGBA | P_GLUT_DEPTH | P_GLUT_DOUBLE);\n        display_mode_possible = p_glutGet(P_GLUT_DISPLAY_MODE_POSSIBLE);\n        G->StereoCapable = 0;\n      }\n    }\n\n    if(!G->Option->game_mode) {\n      if((G->Option->winPX > -10000) && (G->Option->winPY > -10000)) {\n#ifndef _PYMOL_FINK\n        p_glutInitWindowPosition(G->Option->winPX, G->Option->winPY);\n#else\n        p_glutInitWindowPosition(G->Option->winPX, G->Option->winPY - 22);      /* somethings wrong with FinkGlut's window positioning... */\n#endif\n      }\n\n      p_glutInitWindowSize(G->Option->winX, G->Option->winY);\n\n      theWindow = p_glutCreateWindow(\"PyMOL Viewer\");\n\n      if(G->Option->full_screen) {\n        p_glutFullScreen();\n      }\n\n      if(G->Option->window_visible) {\n        p_glutShowWindow();\n      } else {\n        p_glutHideWindow();\n      }\n\n    } else {\n      char str[255];\n      sprintf(str, \"%dx%d:32@120\", G->Option->winX, G->Option->winY);\n      p_glutGameModeString(str);\n      p_glutEnterGameMode();\n    }\n  }\n  MainInit(G);\n  if(own_the_options)\n    G->Main->OwnedOptions = options;\n  /* make sure we can clean up these options later if we've been asked to do so */\n  {\n    CMain *I = G->Main;\n\n    I->TheWindow = theWindow;\n\n    PInit(G, true);\n\n    if(G->HaveGUI) {\n      p_glutDisplayFunc(MainDraw);\n      p_glutReshapeFunc(MainReshape);\n      p_glutKeyboardFunc(MainKey);\n      p_glutMouseFunc(MainButton);\n      p_glutMotionFunc(MainDrag);\n      p_glutPassiveMotionFunc(MainPassive);\n      p_glutSpecialFunc(MainSpecial);\n      p_glutIdleFunc(MainBusyIdle);\n    }\n\n    PUnblock(G);\n\n    if(G->HaveGUI) {\n      if(!I->WindowIsVisible)\n        MainReshape(G->Option->winX, G->Option->winY);\n      I->IdleMode = 3;\n      p_glutMainLoop();         /* never returns with traditional GLUT implementation */\n      PBlock(G);                /* if we've gotten here, then we're heading back to Python... */\n    } else {\n      SceneSetCardInfo(G, \"none\", \"ray trace only\", \"none\");\n      if(G->Option->show_splash && !G->Option->quiet)\n        printf(\" Command mode. No graphics front end.\\n\");\n      MainReshape(G->Option->winX, G->Option->winY);\n      MainDraw();               /* for command line processing */\n      while(1) {\n        MainBusyIdle();\n        MainDraw();\n      }\n    }\n  }\n}\n\n\n/*========================================================================*/\n\nstatic int main_common(void);\nstatic int decoy_input_hook(void) { return 0; }\n\nint main_exec(int argc, char **argv)\n{\n  PyMOLGlobals *G = SingletonPyMOLGlobals;\n\n  fflush(stdout);\n  PSetupEmbedded(G, argc, argv);\n\n  return PyRun_SimpleString(\n      \"import pymol\\n\"\n      \"pymol.launch()\\n\");\n}\n\nint main_shared(int block_input_hook)\n{\n  if(block_input_hook)\n    PyOS_InputHook = decoy_input_hook;\n\n#ifdef _DRI_WORKAROUND\n  dlopen(\"libGL.so.1\", RTLD_LAZY | RTLD_GLOBAL);\n#endif\n\n  return main_common();\n}\n\nstatic int main_common(void)\n{\n  {                             /* no matter how PyMOL was built, we always come through here... */\n\n    CPyMOLOptions *options = PyMOLOptions_New();\n\n    if(options) {\n\n      PGetOptions(options);\n\n      launch(options, true);\n      /* this only returns when PyMOL is not running under GLUT */\n\n    }\n  }\n  return 0;\n}\n\n#endif\n\n\n/*========================================================================*/\n\nPyObject *MainAsPyList(PyMOLGlobals *G)\n{\n#ifdef _PYMOL_NOPY\n  return NULL;\n#else\n  PyObject *result = NULL;\n  int width, height;\n  result = PyList_New(2);\n  width = SceneGetBlock(G)->getWidth();\n  height = SceneGetBlock(G)->getHeight();\n  if(SettingGetGlobal_b(G, cSetting_seq_view)\n     && !SettingGetGlobal_b(G, cSetting_seq_view_overlay))\n    height += SeqGetHeight(G);\n  PyList_SetItem(result, 0, PyInt_FromLong(width));\n  PyList_SetItem(result, 1, PyInt_FromLong(height));\n  return (PConvAutoNone(result));\n#endif\n}\n\nint MainFromPyList(PyMOLGlobals *G, PyObject * list)\n{\n#ifdef _PYMOL_NOPY\n  return 0;\n#else\n\n  int ok = true;\n  int win_x, win_y;\n  int ll = 0;\n  OrthoLineType buffer;\n\n  if(ok)\n    ok = (list != NULL);\n  if(ok)\n    ok = PyList_Check(list);\n  if(ok)\n    ll = PyList_Size(list);\n  if(ok && (ll >= 2)) {\n    if(!G->Option->presentation &&\n        !G->Option->full_screen &&\n        !ExecutiveIsFullScreen(G)) {\n      if(ok)\n        ok = PConvPyIntToInt(PyList_GetItem(list, 0), &win_x);\n      if(ok)\n        ok = PConvPyIntToInt(PyList_GetItem(list, 1), &win_y);\n      /* BlockGetSize(SceneGetBlock(G),&win_x,&win_y); * so how did this get into 0.98beta29?  */\n      if(ok) {\n\n        sprintf(buffer, \"viewport %d, %d\", win_x, win_y);\n        PParse(G, buffer);\n      }\n    }\n  }\n  return (ok);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/contrib/uiuc/plugins/include/vmdplugin.h": "/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2006 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmdplugin.h,v $\n *      $Author: johns $       $Locker:  $             $State: Exp $\n *      $Revision: 1.33 $       $Date: 2015/10/29 05:10:54 $\n *\n ***************************************************************************/\n\n/** @file\n * This header must be included by every VMD plugin library.  It defines the\n * API for every plugin so that VMD can organize the plugins it finds.  \n */\n\n#ifndef VMD_PLUGIN_H\n#define VMD_PLUGIN_H\n\n\n/* \n * Preprocessor tricks to make it easier for us to redefine the names of\n * functions when building static plugins.\n */\n#if !defined(VMDPLUGIN)\n/** \n  * macro defining VMDPLUGIN if it hasn't already been set to the name of \n  * a static plugin that is being compiled.  This is the catch-all case.\n  */\n#define VMDPLUGIN vmdplugin\n#endif\n/** concatenation macro, joins args x and y together as a single string */\n#define xcat(x, y) cat(x, y)\n/** concatenation macro, joins args x and y together as a single string */\n#define cat(x, y) x ## y \n\n/*\n *  macros to correctly define plugin function names depending on whether \n *  the plugin is being compiled for static linkage or dynamic loading. \n *  When compiled for static linkage, each plugin needs to have unique\n *  function names for all of its entry points.  When compiled for dynamic\n *  loading, the plugins must name their entry points consistently so that\n *  the plugin loading mechanism can find the register, register_tcl, init,\n *  and fini routines via dlopen() or similar operating system interfaces.\n */\n/*@{*/\n/** Macro names entry points correctly for static linkage or dynamic loading */\n#define VMDPLUGIN_register     xcat(VMDPLUGIN, _register)\n#define VMDPLUGIN_register_tcl xcat(VMDPLUGIN, _register_tcl)\n#define VMDPLUGIN_init         xcat(VMDPLUGIN, _init)\n#define VMDPLUGIN_fini         xcat(VMDPLUGIN, _fini)\n/*@}*/\n\n\n/** \"WIN32\" is defined on both WIN32 and WIN64 platforms... */\n#if (defined(WIN32)) \n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#if !defined(STATIC_PLUGIN)\n#if defined(VMDPLUGIN_EXPORTS)\n/** \n *  Only define DllMain for plugins, not in VMD or in statically linked plugins\n *  VMDPLUGIN_EXPORTS is only defined when compiling dynamically loaded plugins\n */\nBOOL APIENTRY DllMain( HANDLE hModule,\n                       DWORD ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n  return TRUE;\n}\n\n#define VMDPLUGIN_API __declspec(dllexport)\n#else\n#define VMDPLUGIN_API __declspec(dllimport)\n#endif /* VMDPLUGIN_EXPORTS */\n#else  /* ! STATIC_PLUGIN */\n#define VMDPLUGIN_API\n#endif /* ! STATIC_PLUGIN */\n#else\n/** If we're not compiling on Windows, then this macro is defined empty */\n#define VMDPLUGIN_API \n#endif\n\n/** define plugin linkage correctly for both C and C++ based plugins */\n#ifdef __cplusplus\n#define VMDPLUGIN_EXTERN extern \"C\" VMDPLUGIN_API\n#else\n#define VMDPLUGIN_EXTERN extern VMDPLUGIN_API\n#endif  /* __cplusplus */\n\n/* \n * Plugin API functions start here \n */\n\n\n/** \n * Init routine: called the first time the library is loaded by the \n * application and before any other API functions are referenced.\n * Return 0 on success.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_init(void);\n\n/**\n * Macro for creating a struct header used in all plugin structures.\n * \n * This header should be placed at the top of every plugin API definition \n * so that it can be treated as a subtype of the base plugin type.\n *\n * abiversion: Defines the ABI for the base plugin type (not for other plugins)\n * type: A string descriptor of the plugin type.\n * name: A name for the plugin.\n * author: A string identifier, possibly including newlines.\n * Major and minor version.  \n * is_reentrant: Whether this library can be run concurrently with itself.\n */\n#define vmdplugin_HEAD \\\n  int abiversion; \\\n  const char *type; \\\n  const char *name; \\\n  const char *prettyname; \\\n  const char *author; \\\n  int majorv; \\\n  int minorv; \\\n  int is_reentrant; \n\n/** \n  * Typedef for generic plugin header, individual plugins can\n  * make their own structures as long as the header info remains \n  * the same as the generic plugin header, most easily done by \n  * using the vmdplugin_HEAD macro.\n  */\ntypedef struct {\n  vmdplugin_HEAD\n} vmdplugin_t;\n\n/**\n * Use this macro to initialize the abiversion member of each plugin\n */\n#define vmdplugin_ABIVERSION  17\n\n/*@{*/\n/** Use this macro to indicate a plugin's thread-safety at registration time */\n#define VMDPLUGIN_THREADUNSAFE 0\n#define VMDPLUGIN_THREADSAFE   1\n/*@}*/\n\n/*@{*/\n/** Error return code for use in the plugin registration and init functions */\n#define VMDPLUGIN_SUCCESS      0\n#define VMDPLUGIN_ERROR       -1\n/*@}*/\n\n/** \n * Function pointer typedef for register callback functions\n */\ntypedef int (*vmdplugin_register_cb)(void *, vmdplugin_t *);\n\n/**\n * Allow the library to register plugins with the application.\n * The callback should be called using the passed-in void pointer, which\n * should not be interpreted in any way by the library.  Each vmdplugin_t\n * pointer passed to the application should point to statically-allocated\n * or heap-allocated memory and should never be later modified by the plugin.\n * Applications must be permitted to retain only a copy of the the plugin\n * pointer, without making any deep copy of the items in the struct.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register(void *, vmdplugin_register_cb);\n\n/**\n * Allow the library to register Tcl extensions.  \n * This API is optional; if found by dlopen, it will be called after first\n * calling init and register.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register_tcl(void *, void *tcl_interp, \n    vmdplugin_register_cb);\n\n/**\n * The Fini method is called when the application will no longer use \n * any plugins in the library.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_fini(void);\n\n#endif   /* VMD_PLUGIN_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pymol/splash.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pymol/hsv.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pymol/cmyk.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/sidechains/sc_bb_dep.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/sidechains/sc_library.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/sidechains/sc_bb_ind.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_tyr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_hip.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/thr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/formamide.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_hid.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_gln.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/asph.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_gly.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_his.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_tyr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_glu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/methanol.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/formic.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_gluh.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/his.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_cys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_lys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_asph.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_leu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_phe.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/val.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_ile.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_ser.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/lysn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_asp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_asp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/peptide.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_ser.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/asp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/leu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_argn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_met.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_lysn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/lys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/acetylene.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyclobutane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ttp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyclopropane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/gln.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_asn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/atp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_pro.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_hie.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/indane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ala.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_cys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/hie.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_thr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_lysn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cycloheptane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_trp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nitro.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_ala.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_gluh.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/asn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_val.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/benzocycloheptane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ethylene.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_hip.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ctp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_arg.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/benzene.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/arg.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/methane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyclohexane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_phe.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/gtp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/trifluoromethane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/phosphite.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/gluh.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ser.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/glu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/sulfone.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/napthylene.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_gly.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ace.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyclopentadiene.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/argn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_asn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_gln.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nhh.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_val.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_his.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_met.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/hid.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/tyr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_pro.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/trp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/butane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/formaldehyde.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_trp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_argn.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_hie.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_lys.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_asph.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_hid.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyclopentane.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/hip.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_glu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_leu.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_ile.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/realtime.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nt_arg.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/phe.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/utp.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/cyanide.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/nme.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_thr.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/met.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/gly.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ct_ala.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/ile.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/chempy/fragments/pro.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/test/single-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/test/single.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/test/double.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/openvr/hints_vive_controller.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/openvr/menu_splash.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/cyc7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/aro67.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/aro6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/aro65.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/cyc5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/aro66.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/aro5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/cyc3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/cyc4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/data/pmg_tk/bitmaps/builder/cyc6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/contrib/uiuc/plugins/molfile_plugin/src/phiplugin.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/contrib/uiuc/plugins/molfile_plugin/src/periodic_table.h",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/content/mime1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/content/mime2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2j4z_AZ.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/map.ccp4",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2c1a.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2owb.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2jdt.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2jdo.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/1xh4.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/1xh9.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/data/2j4z_BY.pdb.gz",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/sample04/htdocs/I5S.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/sample04/htdocs/626.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-py-pymol-2.4.0-rcgu4aiibe54xfhadxq2zpb233ml7lsm/spack-src/modules/web/examples/sample04/htdocs/R69.jpg"
    ],
    "total_files": 1305
}