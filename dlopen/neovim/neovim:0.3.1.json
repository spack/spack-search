{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/mbyte.c": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/// mbyte.c: Code specifically for handling multi-byte characters.\n/// Multibyte extensions partly by Sung-Hoon Baek\n///\n/// The encoding used in nvim is always UTF-8. \"enc_utf8\" and \"has_mbyte\" is\n/// thus always true. \"enc_dbcs\" is always zero. The 'encoding' option is\n/// read-only and always reads \"utf-8\".\n///\n/// The cell width on the display needs to be determined from the character\n/// value. Recognizing UTF-8 bytes is easy: 0xxx.xxxx is a single-byte char,\n/// 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading byte of a multi-byte\n/// character. To make things complicated, up to six composing characters\n/// are allowed. These are drawn on top of the first char. For most editing\n/// the sequence of bytes with composing characters included is considered to\n/// be one character.\n///\n/// UTF-8 is used everywhere in the core. This is in registers, text\n/// manipulation, buffers, etc. Nvim core communicates with external plugins\n/// and GUIs in this encoding.\n///\n/// The encoding of a file is specified with 'fileencoding'.  Conversion\n/// is to be done when it's different from \"utf-8\".\n///\n/// Vim scripts may contain an \":scriptencoding\" command. This has an effect\n/// for some commands, like \":menutrans\".\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n#include <wchar.h>\n#include <wctype.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#ifdef HAVE_LOCALE_H\n# include <locale.h>\n#endif\n#include \"nvim/eval.h\"\n#include \"nvim/path.h\"\n#include \"nvim/iconv.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/option.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/arabic.h\"\n#include \"nvim/mark.h\"\n\ntypedef struct {\n  int rangeStart;\n  int rangeEnd;\n  int step;\n  int offset;\n} convertStruct;\n\nstruct interval {\n  long first;\n  long last;\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"mbyte.c.generated.h\"\n# include \"unicode_tables.generated.h\"\n#endif\n\nchar_u e_loadlib[] = \"E370: Could not load library %s\";\nchar_u e_loadfunc[] = \"E448: Could not load library function %s\";\n\n// To speed up BYTELEN(); keep a lookup table to quickly get the length in\n// bytes of a UTF-8 character from the first byte of a UTF-8 string.  Bytes\n// which are illegal when used as the first byte have a 1.  The NUL byte has\n// length 1.\nconst uint8_t utf8len_tab[] = {\n  // ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?A ?B ?C ?D ?E ?F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 0?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 1?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 2?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 3?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 5?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 7?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 8?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 9?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B?\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // C?\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // D?\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // E?\n  4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 1, 1,  // F?\n};\n\n// Like utf8len_tab above, but using a zero for illegal lead bytes.\nconst uint8_t utf8len_tab_zero[] = {\n  // ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?A ?B ?C ?D ?E ?F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 0?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 1?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 2?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 3?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 4?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 5?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 6?\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 7?\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8?\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9?\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A?\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B?\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // C?\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // D?\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // E?\n  4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 0, 0,  // F?\n};\n\n/*\n * Canonical encoding names and their properties.\n * \"iso-8859-n\" is handled by enc_canonize() directly.\n */\nstatic struct\n{   const char *name;   int prop;              int codepage; }\nenc_canon_table[] =\n{\n#define IDX_LATIN_1     0\n  {\"latin1\",          ENC_8BIT + ENC_LATIN1,  1252},\n#define IDX_ISO_2       1\n  {\"iso-8859-2\",      ENC_8BIT,               0},\n#define IDX_ISO_3       2\n  {\"iso-8859-3\",      ENC_8BIT,               0},\n#define IDX_ISO_4       3\n  {\"iso-8859-4\",      ENC_8BIT,               0},\n#define IDX_ISO_5       4\n  {\"iso-8859-5\",      ENC_8BIT,               0},\n#define IDX_ISO_6       5\n  {\"iso-8859-6\",      ENC_8BIT,               0},\n#define IDX_ISO_7       6\n  {\"iso-8859-7\",      ENC_8BIT,               0},\n#define IDX_ISO_8       7\n  {\"iso-8859-8\",      ENC_8BIT,               0},\n#define IDX_ISO_9       8\n  {\"iso-8859-9\",      ENC_8BIT,               0},\n#define IDX_ISO_10      9\n  {\"iso-8859-10\",     ENC_8BIT,               0},\n#define IDX_ISO_11      10\n  {\"iso-8859-11\",     ENC_8BIT,               0},\n#define IDX_ISO_13      11\n  {\"iso-8859-13\",     ENC_8BIT,               0},\n#define IDX_ISO_14      12\n  {\"iso-8859-14\",     ENC_8BIT,               0},\n#define IDX_ISO_15      13\n  {\"iso-8859-15\",     ENC_8BIT + ENC_LATIN9,  0},\n#define IDX_KOI8_R      14\n  {\"koi8-r\",          ENC_8BIT,               0},\n#define IDX_KOI8_U      15\n  {\"koi8-u\",          ENC_8BIT,               0},\n#define IDX_UTF8        16\n  {\"utf-8\",           ENC_UNICODE,            0},\n#define IDX_UCS2        17\n  {\"ucs-2\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},\n#define IDX_UCS2LE      18\n  {\"ucs-2le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},\n#define IDX_UTF16       19\n  {\"utf-16\",          ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},\n#define IDX_UTF16LE     20\n  {\"utf-16le\",        ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},\n#define IDX_UCS4        21\n  {\"ucs-4\",           ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},\n#define IDX_UCS4LE      22\n  {\"ucs-4le\",         ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},\n\n  /* For debugging DBCS encoding on Unix. */\n#define IDX_DEBUG       23\n  {\"debug\",           ENC_DBCS,               DBCS_DEBUG},\n#define IDX_EUC_JP      24\n  {\"euc-jp\",          ENC_DBCS,               DBCS_JPNU},\n#define IDX_SJIS        25\n  {\"sjis\",            ENC_DBCS,               DBCS_JPN},\n#define IDX_EUC_KR      26\n  {\"euc-kr\",          ENC_DBCS,               DBCS_KORU},\n#define IDX_EUC_CN      27\n  {\"euc-cn\",          ENC_DBCS,               DBCS_CHSU},\n#define IDX_EUC_TW      28\n  {\"euc-tw\",          ENC_DBCS,               DBCS_CHTU},\n#define IDX_BIG5        29\n  {\"big5\",            ENC_DBCS,               DBCS_CHT},\n\n  /* MS-DOS and MS-Windows codepages are included here, so that they can be\n   * used on Unix too.  Most of them are similar to ISO-8859 encodings, but\n   * not exactly the same. */\n#define IDX_CP437       30\n  {\"cp437\",           ENC_8BIT,               437},   /* like iso-8859-1 */\n#define IDX_CP737       31\n  {\"cp737\",           ENC_8BIT,               737},   /* like iso-8859-7 */\n#define IDX_CP775       32\n  {\"cp775\",           ENC_8BIT,               775},   /* Baltic */\n#define IDX_CP850       33\n  {\"cp850\",           ENC_8BIT,               850},   /* like iso-8859-4 */\n#define IDX_CP852       34\n  {\"cp852\",           ENC_8BIT,               852},   /* like iso-8859-1 */\n#define IDX_CP855       35\n  {\"cp855\",           ENC_8BIT,               855},   /* like iso-8859-2 */\n#define IDX_CP857       36\n  {\"cp857\",           ENC_8BIT,               857},   /* like iso-8859-5 */\n#define IDX_CP860       37\n  {\"cp860\",           ENC_8BIT,               860},   /* like iso-8859-9 */\n#define IDX_CP861       38\n  {\"cp861\",           ENC_8BIT,               861},   /* like iso-8859-1 */\n#define IDX_CP862       39\n  {\"cp862\",           ENC_8BIT,               862},   /* like iso-8859-1 */\n#define IDX_CP863       40\n  {\"cp863\",           ENC_8BIT,               863},   /* like iso-8859-8 */\n#define IDX_CP865       41\n  {\"cp865\",           ENC_8BIT,               865},   /* like iso-8859-1 */\n#define IDX_CP866       42\n  {\"cp866\",           ENC_8BIT,               866},   /* like iso-8859-5 */\n#define IDX_CP869       43\n  {\"cp869\",           ENC_8BIT,               869},   /* like iso-8859-7 */\n#define IDX_CP874       44\n  {\"cp874\",           ENC_8BIT,               874},   /* Thai */\n#define IDX_CP932       45\n  {\"cp932\",           ENC_DBCS,               DBCS_JPN},\n#define IDX_CP936       46\n  {\"cp936\",           ENC_DBCS,               DBCS_CHS},\n#define IDX_CP949       47\n  {\"cp949\",           ENC_DBCS,               DBCS_KOR},\n#define IDX_CP950       48\n  {\"cp950\",           ENC_DBCS,               DBCS_CHT},\n#define IDX_CP1250      49\n  {\"cp1250\",          ENC_8BIT,               1250},   /* Czech, Polish, etc. */\n#define IDX_CP1251      50\n  {\"cp1251\",          ENC_8BIT,               1251},   /* Cyrillic */\n  /* cp1252 is considered to be equal to latin1 */\n#define IDX_CP1253      51\n  {\"cp1253\",          ENC_8BIT,               1253},   /* Greek */\n#define IDX_CP1254      52\n  {\"cp1254\",          ENC_8BIT,               1254},   /* Turkish */\n#define IDX_CP1255      53\n  {\"cp1255\",          ENC_8BIT,               1255},   /* Hebrew */\n#define IDX_CP1256      54\n  {\"cp1256\",          ENC_8BIT,               1256},   /* Arabic */\n#define IDX_CP1257      55\n  {\"cp1257\",          ENC_8BIT,               1257},   /* Baltic */\n#define IDX_CP1258      56\n  {\"cp1258\",          ENC_8BIT,               1258},   /* Vietnamese */\n\n#define IDX_MACROMAN    57\n  {\"macroman\",        ENC_8BIT + ENC_MACROMAN, 0},      /* Mac OS */\n#define IDX_HPROMAN8    58\n  {\"hp-roman8\",       ENC_8BIT,               0},       /* HP Roman8 */\n#define IDX_COUNT       59\n};\n\n/*\n * Aliases for encoding names.\n */\nstatic struct\n{   const char *name; int canon; }\nenc_alias_table[] =\n{\n  {\"ansi\",            IDX_LATIN_1},\n  {\"iso-8859-1\",      IDX_LATIN_1},\n  {\"latin2\",          IDX_ISO_2},\n  {\"latin3\",          IDX_ISO_3},\n  {\"latin4\",          IDX_ISO_4},\n  {\"cyrillic\",        IDX_ISO_5},\n  {\"arabic\",          IDX_ISO_6},\n  {\"greek\",           IDX_ISO_7},\n  {\"hebrew\",          IDX_ISO_8},\n  {\"latin5\",          IDX_ISO_9},\n  {\"turkish\",         IDX_ISO_9},   /* ? */\n  {\"latin6\",          IDX_ISO_10},\n  {\"nordic\",          IDX_ISO_10},   /* ? */\n  {\"thai\",            IDX_ISO_11},   /* ? */\n  {\"latin7\",          IDX_ISO_13},\n  {\"latin8\",          IDX_ISO_14},\n  {\"latin9\",          IDX_ISO_15},\n  {\"utf8\",            IDX_UTF8},\n  {\"unicode\",         IDX_UCS2},\n  {\"ucs2\",            IDX_UCS2},\n  {\"ucs2be\",          IDX_UCS2},\n  {\"ucs-2be\",         IDX_UCS2},\n  {\"ucs2le\",          IDX_UCS2LE},\n  {\"utf16\",           IDX_UTF16},\n  {\"utf16be\",         IDX_UTF16},\n  {\"utf-16be\",        IDX_UTF16},\n  {\"utf16le\",         IDX_UTF16LE},\n  {\"ucs4\",            IDX_UCS4},\n  {\"ucs4be\",          IDX_UCS4},\n  {\"ucs-4be\",         IDX_UCS4},\n  {\"ucs4le\",          IDX_UCS4LE},\n  {\"utf32\",           IDX_UCS4},\n  {\"utf-32\",          IDX_UCS4},\n  {\"utf32be\",         IDX_UCS4},\n  {\"utf-32be\",        IDX_UCS4},\n  {\"utf32le\",         IDX_UCS4LE},\n  {\"utf-32le\",        IDX_UCS4LE},\n  {\"932\",             IDX_CP932},\n  {\"949\",             IDX_CP949},\n  {\"936\",             IDX_CP936},\n  {\"gbk\",             IDX_CP936},\n  {\"950\",             IDX_CP950},\n  {\"eucjp\",           IDX_EUC_JP},\n  {\"unix-jis\",        IDX_EUC_JP},\n  {\"ujis\",            IDX_EUC_JP},\n  {\"shift-jis\",       IDX_SJIS},\n  {\"pck\",             IDX_SJIS},        /* Sun: PCK */\n  {\"euckr\",           IDX_EUC_KR},\n  {\"5601\",            IDX_EUC_KR},      /* Sun: KS C 5601 */\n  {\"euccn\",           IDX_EUC_CN},\n  {\"gb2312\",          IDX_EUC_CN},\n  {\"euctw\",           IDX_EUC_TW},\n  {\"japan\",           IDX_EUC_JP},\n  {\"korea\",           IDX_EUC_KR},\n  {\"prc\",             IDX_EUC_CN},\n  {\"chinese\",         IDX_EUC_CN},\n  {\"taiwan\",          IDX_EUC_TW},\n  {\"cp950\",           IDX_BIG5},\n  {\"950\",             IDX_BIG5},\n  {\"mac\",             IDX_MACROMAN},\n  {\"mac-roman\",       IDX_MACROMAN},\n  {NULL,              0}\n};\n\n/*\n * Find encoding \"name\" in the list of canonical encoding names.\n * Returns -1 if not found.\n */\nstatic int enc_canon_search(const char_u *name)\n{\n  int i;\n\n  for (i = 0; i < IDX_COUNT; ++i)\n    if (STRCMP(name, enc_canon_table[i].name) == 0)\n      return i;\n  return -1;\n}\n\n\n\n/*\n * Find canonical encoding \"name\" in the list and return its properties.\n * Returns 0 if not found.\n */\nint enc_canon_props(const char_u *name)\n{\n  int i;\n\n  i = enc_canon_search(name);\n  if (i >= 0)\n    return enc_canon_table[i].prop;\n  if (STRNCMP(name, \"2byte-\", 6) == 0)\n    return ENC_DBCS;\n  if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)\n    return ENC_8BIT;\n  return 0;\n}\n\n/*\n * Return the size of the BOM for the current buffer:\n * 0 - no BOM\n * 2 - UCS-2 or UTF-16 BOM\n * 4 - UCS-4 BOM\n * 3 - UTF-8 BOM\n */\nint bomb_size(void)\n{\n  int n = 0;\n\n  if (curbuf->b_p_bomb && !curbuf->b_p_bin) {\n    if (*curbuf->b_p_fenc == NUL\n        || STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0) {\n      n = 3;\n    } else if (STRNCMP(curbuf->b_p_fenc, \"ucs-2\", 5) == 0\n               || STRNCMP(curbuf->b_p_fenc, \"utf-16\", 6) == 0) {\n      n = 2;\n    } else if (STRNCMP(curbuf->b_p_fenc, \"ucs-4\", 5) == 0) {\n      n = 4;\n    }\n  }\n  return n;\n}\n\n/*\n * Remove all BOM from \"s\" by moving remaining text.\n */\nvoid remove_bom(char_u *s)\n{\n  char *p = (char *)s;\n\n  while ((p = strchr(p, 0xef)) != NULL) {\n    if ((uint8_t)p[1] == 0xbb && (uint8_t)p[2] == 0xbf) {\n      STRMOVE(p, p + 3);\n    } else {\n      p++;\n    }\n  }\n}\n\n/*\n * Get class of pointer:\n * 0 for blank or NUL\n * 1 for punctuation\n * 2 for an (ASCII) word character\n * >2 for other word characters\n */\nint mb_get_class(const char_u *p)\n{\n  return mb_get_class_tab(p, curbuf->b_chartab);\n}\n\nint mb_get_class_tab(const char_u *p, const uint64_t *const chartab)\n{\n  if (MB_BYTE2LEN(p[0]) == 1) {\n    if (p[0] == NUL || ascii_iswhite(p[0])) {\n      return 0;\n    }\n    if (vim_iswordc_tab(p[0], chartab)) {\n      return 2;\n    }\n    return 1;\n  }\n  return utf_class_tab(utf_ptr2char(p), chartab);\n}\n\n/*\n * Return true if \"c\" is in \"table\".\n */\nstatic bool intable(const struct interval *table, size_t n_items, int c)\n{\n  int mid, bot, top;\n\n  /* first quick check for Latin1 etc. characters */\n  if (c < table[0].first)\n    return false;\n\n  /* binary search in table */\n  bot = 0;\n  top = (int)(n_items - 1);\n  while (top >= bot) {\n    mid = (bot + top) / 2;\n    if (table[mid].last < c)\n      bot = mid + 1;\n    else if (table[mid].first > c)\n      top = mid - 1;\n    else\n      return true;\n  }\n  return false;\n}\n\n/*\n * For UTF-8 character \"c\" return 2 for a double-width character, 1 for others.\n * Returns 4 or 6 for an unprintable character.\n * Is only correct for characters >= 0x80.\n * When p_ambw is \"double\", return 2 for a character with East Asian Width\n * class 'A'(mbiguous).\n */\nint utf_char2cells(int c)\n{\n  if (c >= 0x100) {\n#ifdef USE_WCHAR_FUNCTIONS\n    /*\n     * Assume the library function wcwidth() works better than our own\n     * stuff.  It should return 1 for ambiguous width chars!\n     */\n    int n = wcwidth(c);\n\n    if (n < 0)\n      return 6;                 /* unprintable, displays <xxxx> */\n    if (n > 1)\n      return n;\n#else\n    if (!utf_printable(c))\n      return 6;                 /* unprintable, displays <xxxx> */\n    if (intable(doublewidth, ARRAY_SIZE(doublewidth), c))\n      return 2;\n#endif\n    if (p_emoji && intable(emoji_width, ARRAY_SIZE(emoji_width), c)) {\n      return 2;\n    }\n  }\n  /* Characters below 0x100 are influenced by 'isprint' option */\n  else if (c >= 0x80 && !vim_isprintc(c))\n    return 4;                   /* unprintable, displays <xx> */\n\n  if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, ARRAY_SIZE(ambiguous), c))\n    return 2;\n\n  return 1;\n}\n\n/// Return the number of display cells character at \"*p\" occupies.\n/// This doesn't take care of unprintable characters, use ptr2cells() for that.\nint utf_ptr2cells(const char_u *p)\n{\n  int c;\n\n  /* Need to convert to a wide character. */\n  if (*p >= 0x80) {\n    c = utf_ptr2char(p);\n    /* An illegal byte is displayed as <xx>. */\n    if (utf_ptr2len(p) == 1 || c == NUL)\n      return 4;\n    /* If the char is ASCII it must be an overlong sequence. */\n    if (c < 0x80)\n      return char2cells(c);\n    return utf_char2cells(c);\n  }\n  return 1;\n}\n\n/// Like utf_ptr2cells(), but limit string length to \"size\".\n/// For an empty string or truncated character returns 1.\nint utf_ptr2cells_len(const char_u *p, int size)\n{\n  int c;\n\n  /* Need to convert to a wide character. */\n  if (size > 0 && *p >= 0x80) {\n    if (utf_ptr2len_len(p, size) < utf8len_tab[*p])\n      return 1;        /* truncated */\n    c = utf_ptr2char(p);\n    /* An illegal byte is displayed as <xx>. */\n    if (utf_ptr2len(p) == 1 || c == NUL)\n      return 4;\n    /* If the char is ASCII it must be an overlong sequence. */\n    if (c < 0x80)\n      return char2cells(c);\n    return utf_char2cells(c);\n  }\n  return 1;\n}\n\n/// Calculate the number of cells occupied by string `str`.\n///\n/// @param str The source string, may not be NULL, must be a NUL-terminated\n///            string.\n/// @return The number of cells occupied by string `str`\nsize_t mb_string2cells(const char_u *str)\n{\n  size_t clen = 0;\n\n  for (const char_u *p = str; *p != NUL; p += (*mb_ptr2len)(p)) {\n    clen += (*mb_ptr2cells)(p);\n  }\n\n  return clen;\n}\n\n/// Return number of display cells for char at ScreenLines[off].\n/// We make sure that the offset used is less than \"max_off\".\nint utf_off2cells(unsigned off, unsigned max_off)\n{\n  return (off + 1 < max_off && ScreenLines[off + 1][0] == 0) ? 2 : 1;\n}\n\n/// Convert a UTF-8 byte sequence to a wide character\n///\n/// If the sequence is illegal or truncated by a NUL then the first byte is\n/// returned. Does not include composing characters for obvious reasons.\n///\n/// @param[in]  p  String to convert.\n///\n/// @return Unicode codepoint or byte value.\nint utf_ptr2char(const char_u *const p)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (p[0] < 0x80) {  // Be quick for ASCII.\n    return p[0];\n  }\n\n  const uint8_t len = utf8len_tab_zero[p[0]];\n  if (len > 1 && (p[1] & 0xc0) == 0x80) {\n    if (len == 2) {\n      return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n    }\n    if ((p[2] & 0xc0) == 0x80) {\n      if (len == 3) {\n        return (((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n                + (p[2] & 0x3f));\n      }\n      if ((p[3] & 0xc0) == 0x80) {\n        if (len == 4) {\n          return (((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n                  + ((p[2] & 0x3f) << 6) + (p[3] & 0x3f));\n        }\n        if ((p[4] & 0xc0) == 0x80) {\n          if (len == 5) {\n            return (((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n                    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n                    + (p[4] & 0x3f));\n          }\n          if ((p[5] & 0xc0) == 0x80 && len == 6) {\n            return (((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n                    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n                    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f));\n          }\n        }\n      }\n    }\n  }\n  // Illegal value: just return the first byte.\n  return p[0];\n}\n\n/*\n * Convert a UTF-8 byte sequence to a wide character.\n * String is assumed to be terminated by NUL or after \"n\" bytes, whichever\n * comes first.\n * The function is safe in the sense that it never accesses memory beyond the\n * first \"n\" bytes of \"s\".\n *\n * On success, returns decoded codepoint, advances \"s\" to the beginning of\n * next character and decreases \"n\" accordingly.\n *\n * If end of string was reached, returns 0 and, if \"n\" > 0, advances \"s\" past\n * NUL byte.\n *\n * If byte sequence is illegal or incomplete, returns -1 and does not advance\n * \"s\".\n */\nstatic int utf_safe_read_char_adv(const char_u **s, size_t *n)\n{\n  int c;\n\n  if (*n == 0)   /* end of buffer */\n    return 0;\n\n  uint8_t k = utf8len_tab_zero[**s];\n\n  if (k == 1) {\n    /* ASCII character or NUL */\n    (*n)--;\n    return *(*s)++;\n  }\n\n  if (k <= *n) {\n    /* We have a multibyte sequence and it isn't truncated by buffer\n     * limits so utf_ptr2char() is safe to use. Or the first byte is\n     * illegal (k=0), and it's also safe to use utf_ptr2char(). */\n    c = utf_ptr2char(*s);\n\n    /* On failure, utf_ptr2char() returns the first byte, so here we\n     * check equality with the first byte. The only non-ASCII character\n     * which equals the first byte of its own UTF-8 representation is\n     * U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.\n     * It's safe even if n=1, else we would have k=2 > n. */\n    if (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83)) {\n      /* byte sequence was successfully decoded */\n      *s += k;\n      *n -= k;\n      return c;\n    }\n  }\n\n  /* byte sequence is incomplete or illegal */\n  return -1;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are skipped!\n */\nint mb_ptr2char_adv(const char_u **const pp)\n{\n  int c;\n\n  c = (*mb_ptr2char)(*pp);\n  *pp += (*mb_ptr2len)(*pp);\n  return c;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are returned as separate characters.\n */\nint mb_cptr2char_adv(const char_u **pp)\n{\n  int c;\n\n  c = (*mb_ptr2char)(*pp);\n  *pp += utf_ptr2len(*pp);\n  return c;\n}\n\n/*\n * Check if the character pointed to by \"p2\" is a composing character when it\n * comes after \"p1\".  For Arabic sometimes \"ab\" is replaced with \"c\", which\n * behaves like a composing character.\n */\nbool utf_composinglike(const char_u *p1, const char_u *p2)\n{\n  int c2;\n\n  c2 = utf_ptr2char(p2);\n  if (utf_iscomposing(c2))\n    return true;\n  if (!arabic_maycombine(c2))\n    return false;\n  return arabic_combine(utf_ptr2char(p1), c2);\n}\n\n/// Convert a UTF-8 string to a wide character\n///\n/// Also gets up to #MAX_MCO composing characters.\n///\n/// @param[out]  pcc  Location where to store composing characters. Must have\n///                   space at least for #MAX_MCO + 1 elements.\n///\n/// @return leading character.\nint utfc_ptr2char(const char_u *p, int *pcc)\n{\n  int len;\n  int c;\n  int cc;\n  int i = 0;\n\n  c = utf_ptr2char(p);\n  len = utf_ptr2len(p);\n\n  /* Only accept a composing char when the first char isn't illegal. */\n  if ((len > 1 || *p < 0x80)\n      && p[len] >= 0x80\n      && UTF_COMPOSINGLIKE(p, p + len)) {\n    cc = utf_ptr2char(p + len);\n    for (;; ) {\n      pcc[i++] = cc;\n      if (i == MAX_MCO)\n        break;\n      len += utf_ptr2len(p + len);\n      if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n        break;\n    }\n  }\n\n  if (i < MAX_MCO)      /* last composing char must be 0 */\n    pcc[i] = 0;\n\n  return c;\n}\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.  Use no more than p[maxlen].\n *\n * @param [out] pcc: composing chars, last one is 0\n */\nint utfc_ptr2char_len(const char_u *p, int *pcc, int maxlen)\n{\n#define IS_COMPOSING(s1, s2, s3) \\\n  (i == 0 ? UTF_COMPOSINGLIKE((s1), (s2)) : utf_iscomposing((s3)))\n\n  assert(maxlen > 0);\n\n  int i = 0;\n\n  int len = utf_ptr2len_len(p, maxlen);\n  // Is it safe to use utf_ptr2char()?\n  bool safe = len > 1 && len <= maxlen;\n  int c = safe ? utf_ptr2char(p) : *p;\n\n  // Only accept a composing char when the first char isn't illegal.\n  if ((safe || c < 0x80) && len < maxlen && p[len] >= 0x80) {\n    for (; i < MAX_MCO; i++) {\n      int len_cc = utf_ptr2len_len(p + len, maxlen - len);\n      safe = len_cc > 1 && len_cc <= maxlen - len;\n      if (!safe || (pcc[i] = utf_ptr2char(p + len)) < 0x80\n          || !IS_COMPOSING(p, p + len, pcc[i])) {\n        break;\n      }\n      len += len_cc;\n    }\n  }\n\n  if (i < MAX_MCO) {\n    // last composing char must be 0\n    pcc[i] = 0;\n  }\n\n  return c;\n#undef ISCOMPOSING\n}\n\n/// Get the length of a UTF-8 byte sequence representing a single codepoint\n///\n/// @param[in]  p  UTF-8 string.\n///\n/// @return Sequence length, 0 for empty string and 1 for non-UTF-8 byte\n///         sequence.\nint utf_ptr2len(const char_u *const p)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (*p == NUL) {\n    return 0;\n  }\n  const int len = utf8len_tab[*p];\n  for (int i = 1; i < len; i++) {\n    if ((p[i] & 0xc0) != 0x80) {\n      return 1;\n    }\n  }\n  return len;\n}\n\n/*\n * Return length of UTF-8 character, obtained from the first byte.\n * \"b\" must be between 0 and 255!\n * Returns 1 for an invalid first byte value.\n */\nint utf_byte2len(int b)\n{\n  return utf8len_tab[b];\n}\n\n/*\n * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any\n * following composing characters.\n * Returns 1 for \"\".\n * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).\n * Returns number > \"size\" for an incomplete byte sequence.\n * Never returns zero.\n */\nint utf_ptr2len_len(const char_u *p, int size)\n{\n  int len;\n  int i;\n  int m;\n\n  len = utf8len_tab[*p];\n  if (len == 1)\n    return 1;           /* NUL, ascii or illegal lead byte */\n  if (len > size)\n    m = size;           /* incomplete byte sequence. */\n  else\n    m = len;\n  for (i = 1; i < m; ++i)\n    if ((p[i] & 0xc0) != 0x80)\n      return 1;\n  return len;\n}\n\n/// Return the number of bytes occupied by a UTF-8 character in a string\n///\n/// This includes following composing characters.\nint utfc_ptr2len(const char_u *const p)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  uint8_t b0 = (uint8_t)(*p);\n\n  if (b0 == NUL) {\n    return 0;\n  }\n  if (b0 < 0x80 && p[1] < 0x80) {  // be quick for ASCII\n    return 1;\n  }\n\n  // Skip over first UTF-8 char, stopping at a NUL byte.\n  int len = utf_ptr2len(p);\n\n  // Check for illegal byte.\n  if (len == 1 && b0 >= 0x80) {\n    return 1;\n  }\n\n  // Check for composing characters.  We can handle only the first six, but\n  // skip all of them (otherwise the cursor would get stuck).\n  int prevlen = 0;\n  for (;;) {\n    if (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len)) {\n      return len;\n    }\n\n    // Skip over composing char.\n    prevlen = len;\n    len += utf_ptr2len(p + len);\n  }\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\"\n * takes.  This includes following composing characters.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\nint utfc_ptr2len_len(const char_u *p, int size)\n{\n  int len;\n  int prevlen;\n\n  if (size < 1 || *p == NUL)\n    return 0;\n  if (p[0] < 0x80 && (size == 1 || p[1] < 0x80))   /* be quick for ASCII */\n    return 1;\n\n  /* Skip over first UTF-8 char, stopping at a NUL byte. */\n  len = utf_ptr2len_len(p, size);\n\n  /* Check for illegal byte and incomplete byte sequence. */\n  if ((len == 1 && p[0] >= 0x80) || len > size)\n    return 1;\n\n  /*\n   * Check for composing characters.  We can handle only the first six, but\n   * skip all of them (otherwise the cursor would get stuck).\n   */\n  prevlen = 0;\n  while (len < size) {\n    int len_next_char;\n\n    if (p[len] < 0x80)\n      break;\n\n    /*\n     * Next character length should not go beyond size to ensure that\n     * UTF_COMPOSINGLIKE(...) does not read beyond size.\n     */\n    len_next_char = utf_ptr2len_len(p + len, size - len);\n    if (len_next_char > size - len)\n      break;\n\n    if (!UTF_COMPOSINGLIKE(p + prevlen, p + len))\n      break;\n\n    /* Skip over composing char */\n    prevlen = len;\n    len += len_next_char;\n  }\n  return len;\n}\n\n/// Determine how many bytes certain unicode codepoint will occupy\nint utf_char2len(const int c)\n{\n  if (c < 0x80) {\n    return 1;\n  } else if (c < 0x800) {\n    return 2;\n  } else if (c < 0x10000) {\n    return 3;\n  } else if (c < 0x200000) {\n    return 4;\n  } else if (c < 0x4000000) {\n    return 5;\n  } else {\n    return 6;\n  }\n}\n\n/// Convert Unicode character to UTF-8 string\n///\n/// @param c character to convert to \\p buf\n/// @param[out] buf UTF-8 string generated from \\p c, does not add \\0\n/// @return Number of bytes (1-6). Does not include composing characters.\nint utf_char2bytes(const int c, char_u *const buf)\n{\n  if (c < 0x80) {  // 7 bits\n    buf[0] = c;\n    return 1;\n  } else if (c < 0x800) {  // 11 bits\n    buf[0] = 0xc0 + ((unsigned)c >> 6);\n    buf[1] = 0x80 + (c & 0x3f);\n    return 2;\n  } else if (c < 0x10000) {  // 16 bits\n    buf[0] = 0xe0 + ((unsigned)c >> 12);\n    buf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[2] = 0x80 + (c & 0x3f);\n    return 3;\n  } else if (c < 0x200000) {  // 21 bits\n    buf[0] = 0xf0 + ((unsigned)c >> 18);\n    buf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[3] = 0x80 + (c & 0x3f);\n    return 4;\n  } else if (c < 0x4000000) {  // 26 bits\n    buf[0] = 0xf8 + ((unsigned)c >> 24);\n    buf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[4] = 0x80 + (c & 0x3f);\n    return 5;\n  } else {  // 31 bits\n    buf[0] = 0xfc + ((unsigned)c >> 30);\n    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[5] = 0x80 + (c & 0x3f);\n    return 6;\n  }\n}\n\n/*\n * Return true if \"c\" is a composing UTF-8 character.  This means it will be\n * drawn on top of the preceding character.\n * Based on code from Markus Kuhn.\n */\nbool utf_iscomposing(int c)\n{\n  return intable(combining, ARRAY_SIZE(combining), c);\n}\n\n/*\n * Return true for characters that can be displayed in a normal way.\n * Only for characters of 0x100 and above!\n */\nbool utf_printable(int c)\n{\n#ifdef USE_WCHAR_FUNCTIONS\n  /*\n   * Assume the iswprint() library function works better than our own stuff.\n   */\n  return iswprint(c);\n#else\n  /* Sorted list of non-overlapping intervals.\n   * 0xd800-0xdfff is reserved for UTF-16, actually illegal. */\n  static struct interval nonprint[] =\n  {\n    {0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},\n    {0x206a, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},\n    {0xfffe, 0xffff}\n  };\n\n  return !intable(nonprint, ARRAY_SIZE(nonprint), c);\n#endif\n}\n\n/*\n * Get class of a Unicode character.\n * 0: white space\n * 1: punctuation\n * 2 or bigger: some class of word character.\n */\nint utf_class(const int c)\n{\n  return utf_class_tab(c, curbuf->b_chartab);\n}\n\nint utf_class_tab(const int c, const uint64_t *const chartab)\n{\n  /* sorted list of non-overlapping intervals */\n  static struct clinterval {\n    unsigned int first;\n    unsigned int last;\n    unsigned int class;\n  } classes[] =\n  {\n    {0x037e, 0x037e, 1},                /* Greek question mark */\n    {0x0387, 0x0387, 1},                /* Greek ano teleia */\n    {0x055a, 0x055f, 1},                /* Armenian punctuation */\n    {0x0589, 0x0589, 1},                /* Armenian full stop */\n    {0x05be, 0x05be, 1},\n    {0x05c0, 0x05c0, 1},\n    {0x05c3, 0x05c3, 1},\n    {0x05f3, 0x05f4, 1},\n    {0x060c, 0x060c, 1},\n    {0x061b, 0x061b, 1},\n    {0x061f, 0x061f, 1},\n    {0x066a, 0x066d, 1},\n    {0x06d4, 0x06d4, 1},\n    {0x0700, 0x070d, 1},                /* Syriac punctuation */\n    {0x0964, 0x0965, 1},\n    {0x0970, 0x0970, 1},\n    {0x0df4, 0x0df4, 1},\n    {0x0e4f, 0x0e4f, 1},\n    {0x0e5a, 0x0e5b, 1},\n    {0x0f04, 0x0f12, 1},\n    {0x0f3a, 0x0f3d, 1},\n    {0x0f85, 0x0f85, 1},\n    {0x104a, 0x104f, 1},                /* Myanmar punctuation */\n    {0x10fb, 0x10fb, 1},                /* Georgian punctuation */\n    {0x1361, 0x1368, 1},                /* Ethiopic punctuation */\n    {0x166d, 0x166e, 1},                /* Canadian Syl. punctuation */\n    {0x1680, 0x1680, 0},\n    {0x169b, 0x169c, 1},\n    {0x16eb, 0x16ed, 1},\n    {0x1735, 0x1736, 1},\n    {0x17d4, 0x17dc, 1},                /* Khmer punctuation */\n    {0x1800, 0x180a, 1},                /* Mongolian punctuation */\n    {0x2000, 0x200b, 0},                /* spaces */\n    {0x200c, 0x2027, 1},                /* punctuation and symbols */\n    {0x2028, 0x2029, 0},\n    {0x202a, 0x202e, 1},                /* punctuation and symbols */\n    {0x202f, 0x202f, 0},\n    {0x2030, 0x205e, 1},                /* punctuation and symbols */\n    {0x205f, 0x205f, 0},\n    {0x2060, 0x27ff, 1},                /* punctuation and symbols */\n    {0x2070, 0x207f, 0x2070},           /* superscript */\n    {0x2080, 0x2094, 0x2080},           /* subscript */\n    {0x20a0, 0x27ff, 1},                /* all kinds of symbols */\n    {0x2800, 0x28ff, 0x2800},           /* braille */\n    {0x2900, 0x2998, 1},                /* arrows, brackets, etc. */\n    {0x29d8, 0x29db, 1},\n    {0x29fc, 0x29fd, 1},\n    {0x2e00, 0x2e7f, 1},                /* supplemental punctuation */\n    {0x3000, 0x3000, 0},                /* ideographic space */\n    {0x3001, 0x3020, 1},                /* ideographic punctuation */\n    {0x3030, 0x3030, 1},\n    {0x303d, 0x303d, 1},\n    {0x3040, 0x309f, 0x3040},           /* Hiragana */\n    {0x30a0, 0x30ff, 0x30a0},           /* Katakana */\n    {0x3300, 0x9fff, 0x4e00},           /* CJK Ideographs */\n    {0xac00, 0xd7a3, 0xac00},           /* Hangul Syllables */\n    {0xf900, 0xfaff, 0x4e00},           /* CJK Ideographs */\n    {0xfd3e, 0xfd3f, 1},\n    {0xfe30, 0xfe6b, 1},                /* punctuation forms */\n    {0xff00, 0xff0f, 1},                /* half/fullwidth ASCII */\n    {0xff1a, 0xff20, 1},                /* half/fullwidth ASCII */\n    {0xff3b, 0xff40, 1},                /* half/fullwidth ASCII */\n    {0xff5b, 0xff65, 1},                /* half/fullwidth ASCII */\n    {0x20000, 0x2a6df, 0x4e00},         /* CJK Ideographs */\n    {0x2a700, 0x2b73f, 0x4e00},         /* CJK Ideographs */\n    {0x2b740, 0x2b81f, 0x4e00},         /* CJK Ideographs */\n    {0x2f800, 0x2fa1f, 0x4e00},         /* CJK Ideographs */\n  };\n  int bot = 0;\n  int top = ARRAY_SIZE(classes) - 1;\n  int mid;\n\n  /* First quick check for Latin1 characters, use 'iskeyword'. */\n  if (c < 0x100) {\n    if (c == ' ' || c == '\\t' || c == NUL || c == 0xa0) {\n      return 0;             // blank\n    }\n    if (vim_iswordc_tab(c, chartab)) {\n      return 2;             // word character\n    }\n    return 1;               // punctuation\n  }\n\n  /* binary search in table */\n  while (top >= bot) {\n    mid = (bot + top) / 2;\n    if (classes[mid].last < (unsigned int)c)\n      bot = mid + 1;\n    else if (classes[mid].first > (unsigned int)c)\n      top = mid - 1;\n    else\n      return (int)classes[mid].class;\n  }\n\n  // emoji\n  if (intable(emoji_all, ARRAY_SIZE(emoji_all), c)) {\n    return 3;\n  }\n\n  /* most other characters are \"word\" characters */\n  return 2;\n}\n\nbool utf_ambiguous_width(int c)\n{\n  return c >= 0x80 && (intable(ambiguous, ARRAY_SIZE(ambiguous), c)\n                       || intable(emoji_all, ARRAY_SIZE(emoji_all), c));\n}\n\n/*\n * Generic conversion function for case operations.\n * Return the converted equivalent of \"a\", which is a UCS-4 character.  Use\n * the given conversion \"table\".  Uses binary search on \"table\".\n */\nstatic int utf_convert(int a, const convertStruct *const table, size_t n_items)\n{\n  size_t start, mid, end;   /* indices into table */\n\n  start = 0;\n  end = n_items;\n  while (start < end) {\n    /* need to search further */\n    mid = (end + start) / 2;\n    if (table[mid].rangeEnd < a)\n      start = mid + 1;\n    else\n      end = mid;\n  }\n  if (start < n_items\n      && table[start].rangeStart <= a\n      && a <= table[start].rangeEnd\n      && (a - table[start].rangeStart) % table[start].step == 0)\n    return a + table[start].offset;\n  else\n    return a;\n}\n\n/*\n * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses\n * simple case folding.\n */\nint utf_fold(int a)\n{\n  if (a < 0x80) {\n    // be fast for ASCII\n    return a >= 0x41 && a <= 0x5a ? a + 32 : a;\n  }\n  return utf_convert(a, foldCase, ARRAY_SIZE(foldCase));\n}\n\n// Vim's own character class functions.  These exist because many library\n// islower()/toupper() etc. do not work properly: they crash when used with\n// invalid values or can't handle latin1 when the locale is C.\n// Speed is most important here.\n\n/// Return the upper-case equivalent of \"a\", which is a UCS-4 character.  Use\n/// simple case folding.\nint mb_toupper(int a)\n{\n  /* If 'casemap' contains \"keepascii\" use ASCII style toupper(). */\n  if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n    return TOUPPER_ASC(a);\n\n#if defined(__STDC_ISO_10646__)\n  /* If towupper() is available and handles Unicode, use it. */\n  if (!(cmp_flags & CMP_INTERNAL))\n    return towupper(a);\n#endif\n\n  /* For characters below 128 use locale sensitive toupper(). */\n  if (a < 128)\n    return TOUPPER_LOC(a);\n\n  /* For any other characters use the above mapping table. */\n  return utf_convert(a, toUpper, ARRAY_SIZE(toUpper));\n}\n\nbool mb_islower(int a)\n{\n  // German sharp s is lower case but has no upper case equivalent.\n  return (mb_toupper(a) != a) || a == 0xdf;\n}\n\n/// Return the lower-case equivalent of \"a\", which is a UCS-4 character.  Use\n/// simple case folding.\nint mb_tolower(int a)\n{\n  /* If 'casemap' contains \"keepascii\" use ASCII style tolower(). */\n  if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n    return TOLOWER_ASC(a);\n\n#if defined(__STDC_ISO_10646__)\n  /* If towlower() is available and handles Unicode, use it. */\n  if (!(cmp_flags & CMP_INTERNAL))\n    return towlower(a);\n#endif\n\n  /* For characters below 128 use locale sensitive tolower(). */\n  if (a < 128)\n    return TOLOWER_LOC(a);\n\n  /* For any other characters use the above mapping table. */\n  return utf_convert(a, toLower, ARRAY_SIZE(toLower));\n}\n\nbool mb_isupper(int a)\n{\n  return mb_tolower(a) != a;\n}\n\nstatic int utf_strnicmp(const char_u *s1, const char_u *s2, size_t n1,\n                        size_t n2)\n{\n  int c1, c2, cdiff;\n  char_u buffer[6];\n\n  for (;; ) {\n    c1 = utf_safe_read_char_adv(&s1, &n1);\n    c2 = utf_safe_read_char_adv(&s2, &n2);\n\n    if (c1 <= 0 || c2 <= 0)\n      break;\n\n    if (c1 == c2)\n      continue;\n\n    cdiff = utf_fold(c1) - utf_fold(c2);\n    if (cdiff != 0)\n      return cdiff;\n  }\n\n  /* some string ended or has an incomplete/illegal character sequence */\n\n  if (c1 == 0 || c2 == 0) {\n    /* some string ended. shorter string is smaller */\n    if (c1 == 0 && c2 == 0)\n      return 0;\n    return c1 == 0 ? -1 : 1;\n  }\n\n  /* Continue with bytewise comparison to produce some result that\n   * would make comparison operations involving this function transitive.\n   *\n   * If only one string had an error, comparison should be made with\n   * folded version of the other string. In this case it is enough\n   * to fold just one character to determine the result of comparison. */\n\n  if (c1 != -1 && c2 == -1) {\n    n1 = utf_char2bytes(utf_fold(c1), buffer);\n    s1 = buffer;\n  } else if (c2 != -1 && c1 == -1) {\n    n2 = utf_char2bytes(utf_fold(c2), buffer);\n    s2 = buffer;\n  }\n\n  while (n1 > 0 && n2 > 0 && *s1 != NUL && *s2 != NUL) {\n    cdiff = (int)(*s1) - (int)(*s2);\n    if (cdiff != 0)\n      return cdiff;\n\n    s1++;\n    s2++;\n    n1--;\n    n2--;\n  }\n\n  if (n1 > 0 && *s1 == NUL)\n    n1 = 0;\n  if (n2 > 0 && *s2 == NUL)\n    n2 = 0;\n\n  if (n1 == 0 && n2 == 0)\n    return 0;\n  return n1 == 0 ? -1 : 1;\n}\n\n#ifdef WIN32\n#ifndef CP_UTF8\n# define CP_UTF8 65001  /* magic number from winnls.h */\n#endif\n\n/// Reassigns `strw` to a new, allocated pointer to a UTF16 string.\nint utf8_to_utf16(const char *str, wchar_t **strw)\n  FUNC_ATTR_NONNULL_ALL\n{\n  ssize_t wchar_len = 0;\n\n  // Compute the length needed to store the converted widechar string.\n  wchar_len = MultiByteToWideChar(CP_UTF8,\n                                  0,     // dwFlags: must be 0 for utf8\n                                  str,   // lpMultiByteStr: string to convert\n                                  -1,    // -1 => process up to NUL\n                                  NULL,  // lpWideCharStr: converted string\n                                  0);    // 0  => return length, don't convert\n  if (wchar_len == 0) {\n    return GetLastError();\n  }\n\n  ssize_t buf_sz = wchar_len * sizeof(wchar_t);\n\n  if (buf_sz == 0) {\n    *strw = NULL;\n    return 0;\n  }\n\n  char *buf = xmalloc(buf_sz);\n  char *pos = buf;\n\n  int r = MultiByteToWideChar(CP_UTF8,\n                              0,\n                              str,\n                              -1,\n                              (wchar_t *)pos,\n                              wchar_len);\n  assert(r == wchar_len);\n  if (r != wchar_len) {\n    EMSG2(\"MultiByteToWideChar failed: %d\", r);\n  }\n  *strw = (wchar_t *)pos;\n\n  return 0;\n}\n\n/// Reassigns `str` to a new, allocated pointer to a UTF8 string.\nint utf16_to_utf8(const wchar_t *strw, char **str)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Compute the space required to store the string as UTF-8.\n  DWORD utf8_len = WideCharToMultiByte(CP_UTF8,\n                                       0,\n                                       strw,\n                                       -1,\n                                       NULL,\n                                       0,\n                                       NULL,\n                                       NULL);\n  if (utf8_len == 0) {\n    return GetLastError();\n  }\n\n  *str = xmallocz(utf8_len);\n\n  // Convert to UTF-8.\n  utf8_len = WideCharToMultiByte(CP_UTF8,\n                                 0,\n                                 strw,\n                                 -1,\n                                 *str,\n                                 utf8_len,\n                                 NULL,\n                                 NULL);\n  if (utf8_len == 0) {\n    free(*str);\n    *str = NULL;\n    return GetLastError();\n  }\n  (*str)[utf8_len] = '\\0';\n\n  return 0;\n}\n\n#endif\n\n/*\n * Version of strnicmp() that handles multi-byte characters.\n * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can\n * probably use strnicmp(), because there are no ASCII characters in the\n * second byte.\n * Returns zero if s1 and s2 are equal (ignoring case), the difference between\n * two characters otherwise.\n */\nint mb_strnicmp(const char_u *s1, const char_u *s2, const size_t nn)\n{\n  return utf_strnicmp(s1, s2, nn, nn);\n}\n\n/// Compare strings case-insensitively\n///\n/// @note We need to call mb_stricmp() even when we aren't dealing with\n///       a multi-byte encoding because mb_stricmp() takes care of all ASCII and\n///       non-ascii encodings, including characters with umlauts in latin1,\n///       etc., while STRICMP() only handles the system locale version, which\n///       often does not handle non-ascii properly.\n///\n/// @param[in]  s1  First string to compare, not more then #MAXCOL characters.\n/// @param[in]  s2  Second string to compare, not more then #MAXCOL characters.\n///\n/// @return 0 if strings are equal, <0 if s1 < s2, >0 if s1 > s2.\nint mb_stricmp(const char *s1, const char *s2)\n{\n  return mb_strnicmp((const char_u *)s1, (const char_u *)s2, MAXCOL);\n}\n\n/*\n * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what\n * 'encoding' has been set to.\n */\nvoid show_utf8(void)\n{\n  int len;\n  int rlen = 0;\n  char_u      *line;\n  int clen;\n  int i;\n\n  /* Get the byte length of the char under the cursor, including composing\n   * characters. */\n  line = get_cursor_pos_ptr();\n  len = utfc_ptr2len(line);\n  if (len == 0) {\n    MSG(\"NUL\");\n    return;\n  }\n\n  clen = 0;\n  for (i = 0; i < len; ++i) {\n    if (clen == 0) {\n      /* start of (composing) character, get its length */\n      if (i > 0) {\n        STRCPY(IObuff + rlen, \"+ \");\n        rlen += 2;\n      }\n      clen = utf_ptr2len(line + i);\n    }\n    sprintf((char *)IObuff + rlen, \"%02x \",\n        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */\n    --clen;\n    rlen += (int)STRLEN(IObuff + rlen);\n    if (rlen > IOSIZE - 20)\n      break;\n  }\n\n  msg(IObuff);\n}\n\n/// Return offset from \"p\" to the first byte of the character it points into.\n/// If \"p\" points to the NUL at the end of the string return 0.\n/// Returns 0 when already at the first byte of a character.\nint utf_head_off(const char_u *base, const char_u *p)\n{\n  int c;\n  int len;\n\n  if (*p < 0x80)                /* be quick for ASCII */\n    return 0;\n\n  /* Skip backwards over trailing bytes: 10xx.xxxx\n   * Skip backwards again if on a composing char. */\n  const char_u *q;\n  for (q = p;; --q) {\n    /* Move s to the last byte of this char. */\n    const char_u *s;\n    for (s = q; (s[1] & 0xc0) == 0x80; ++s) {}\n\n    /* Move q to the first byte of this char. */\n    while (q > base && (*q & 0xc0) == 0x80)\n      --q;\n    /* Check for illegal sequence. Do allow an illegal byte after where we\n     * started. */\n    len = utf8len_tab[*q];\n    if (len != (int)(s - q + 1) && len != (int)(p - q + 1))\n      return 0;\n\n    if (q <= base)\n      break;\n\n    c = utf_ptr2char(q);\n    if (utf_iscomposing(c))\n      continue;\n\n    if (arabic_maycombine(c)) {\n      /* Advance to get a sneak-peak at the next char */\n      const char_u *j = q;\n      --j;\n      /* Move j to the first byte of this char. */\n      while (j > base && (*j & 0xc0) == 0x80)\n        --j;\n      if (arabic_combine(utf_ptr2char(j), c))\n        continue;\n    }\n    break;\n  }\n\n  return (int)(p - q);\n}\n\n/// Copy a character, advancing the pointers\n///\n/// @param[in,out]  fp  Source of the character to copy.\n/// @param[in,out]  tp  Destination to copy to.\nvoid mb_copy_char(const char_u **const fp, char_u **const tp)\n{\n  const size_t l = (size_t)utfc_ptr2len(*fp);\n\n  memmove(*tp, *fp, l);\n  *tp += l;\n  *fp += l;\n}\n\n/*\n * Return the offset from \"p\" to the first byte of a character.  When \"p\" is\n * at the start of a character 0 is returned, otherwise the offset to the next\n * character.  Can start anywhere in a stream of bytes.\n */\nint mb_off_next(char_u *base, char_u *p)\n{\n  int i;\n  int j;\n\n  if (*p < 0x80) {              // be quick for ASCII\n    return 0;\n  }\n\n  // Find the next character that isn't 10xx.xxxx\n  for (i = 0; (p[i] & 0xc0) == 0x80; i++) {}\n  if (i > 0) {\n    // Check for illegal sequence.\n    for (j = 0; p - j > base; j++) {\n      if ((p[-j] & 0xc0) != 0x80) {\n        break;\n      }\n    }\n    if (utf8len_tab[p[-j]] != i + j) {\n      return 0;\n    }\n  }\n  return i;\n}\n\n/*\n * Return the offset from \"p\" to the last byte of the character it points\n * into.  Can start anywhere in a stream of bytes.\n */\nint mb_tail_off(char_u *base, char_u *p)\n{\n  int i;\n  int j;\n\n  if (*p == NUL)\n    return 0;\n\n  // Find the last character that is 10xx.xxxx\n  for (i = 0; (p[i + 1] & 0xc0) == 0x80; i++) {}\n\n  // Check for illegal sequence.\n  for (j = 0; p - j > base; j++) {\n    if ((p[-j] & 0xc0) != 0x80) {\n      break;\n    }\n  }\n\n  if (utf8len_tab[p[-j]] != i + j + 1) {\n    return 0;\n  }\n  return i;\n}\n\n/*\n * Find the next illegal byte sequence.\n */\nvoid utf_find_illegal(void)\n{\n  pos_T pos = curwin->w_cursor;\n  char_u      *p;\n  int len;\n  vimconv_T vimconv;\n  char_u      *tofree = NULL;\n\n  vimconv.vc_type = CONV_NONE;\n  if (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT) {\n    // 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n    // possibly a utf-8 file with illegal bytes.  Setup for conversion\n    // from utf-8 to 'fileencoding'.\n    convert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n  }\n\n  curwin->w_cursor.coladd = 0;\n  for (;; ) {\n    p = get_cursor_pos_ptr();\n    if (vimconv.vc_type != CONV_NONE) {\n      xfree(tofree);\n      tofree = string_convert(&vimconv, p, NULL);\n      if (tofree == NULL)\n        break;\n      p = tofree;\n    }\n\n    while (*p != NUL) {\n      /* Illegal means that there are not enough trail bytes (checked by\n       * utf_ptr2len()) or too many of them (overlong sequence). */\n      len = utf_ptr2len(p);\n      if (*p >= 0x80 && (len == 1\n            || utf_char2len(utf_ptr2char(p)) != len)) {\n        if (vimconv.vc_type == CONV_NONE)\n          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());\n        else {\n          int l;\n\n          len = (int)(p - tofree);\n          for (p = get_cursor_pos_ptr(); *p != NUL && len-- > 0; p += l) {\n            l = utf_ptr2len(p);\n            curwin->w_cursor.col += l;\n          }\n        }\n        goto theend;\n      }\n      p += len;\n    }\n    if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n      break;\n    ++curwin->w_cursor.lnum;\n    curwin->w_cursor.col = 0;\n  }\n\n  /* didn't find it: don't move and beep */\n  curwin->w_cursor = pos;\n  beep_flush();\n\ntheend:\n  xfree(tofree);\n  convert_setup(&vimconv, NULL, NULL);\n}\n\n/*\n * If the cursor moves on an trail byte, set the cursor on the lead byte.\n * Thus it moves left if necessary.\n */\nvoid mb_adjust_cursor(void)\n{\n  mark_mb_adjustpos(curbuf, &curwin->w_cursor);\n}\n\n/// Checks and adjusts cursor column. Not mode-dependent.\n/// @see check_cursor_col_win\n///\n/// @param  win_  Places cursor on a valid column for this window.\nvoid mb_check_adjust_col(void *win_)\n{\n  win_T *win = (win_T *)win_;\n  colnr_T oldcol = win->w_cursor.col;\n\n  // Column 0 is always valid.\n  if (oldcol != 0) {\n    char_u *p = ml_get_buf(win->w_buffer, win->w_cursor.lnum, false);\n    colnr_T len = (colnr_T)STRLEN(p);\n\n    // Empty line or invalid column?\n    if (len == 0 || oldcol < 0) {\n      win->w_cursor.col = 0;\n    } else {\n      // Cursor column too big for line?\n      if (oldcol > len) {\n        win->w_cursor.col = len - 1;\n      }\n      // Move the cursor to the head byte.\n      win->w_cursor.col -= (*mb_head_off)(p, p + win->w_cursor.col);\n    }\n\n    // Reset `coladd` when the cursor would be on the right half of a\n    // double-wide character.\n    if (win->w_cursor.coladd == 1 && p[win->w_cursor.col] != TAB\n        && vim_isprintc((*mb_ptr2char)(p + win->w_cursor.col))\n        && ptr2cells(p + win->w_cursor.col) > 1) {\n      win->w_cursor.coladd = 0;\n    }\n  }\n}\n\n/*\n * Return a pointer to the character before \"*p\", if there is one.\n */\nchar_u * mb_prevptr(\n    char_u *line,           /* start of the string */\n    char_u *p\n    )\n{\n  if (p > line) {\n    MB_PTR_BACK(line, p);\n  }\n  return p;\n}\n\n/*\n * Return the character length of \"str\".  Each multi-byte character (with\n * following composing characters) counts as one.\n */\nint mb_charlen(char_u *str)\n{\n  char_u      *p = str;\n  int count;\n\n  if (p == NULL)\n    return 0;\n\n  for (count = 0; *p != NUL; count++)\n    p += (*mb_ptr2len)(p);\n\n  return count;\n}\n\n/*\n * Like mb_charlen() but for a string with specified length.\n */\nint mb_charlen_len(char_u *str, int len)\n{\n  char_u      *p = str;\n  int count;\n\n  for (count = 0; *p != NUL && p < str + len; count++)\n    p += (*mb_ptr2len)(p);\n\n  return count;\n}\n\n/// Try to unescape a multibyte character\n///\n/// Used for the rhs and lhs of the mappings.\n///\n/// @param[in,out]  pp  String to unescape. Is advanced to just after the bytes\n///                     that form a multibyte character.\n///\n/// @return Unescaped string if it is a multibyte character, NULL if no\n///         multibyte character was found. Returns a static buffer, always one\n///         and the same.\nconst char *mb_unescape(const char **const pp)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  static char buf[6];\n  size_t buf_idx = 0;\n  uint8_t *str = (uint8_t *)(*pp);\n\n  // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI\n  // KS_EXTRA KE_CSI to CSI.\n  // Maximum length of a utf-8 character is 4 bytes.\n  for (size_t str_idx = 0; str[str_idx] != NUL && buf_idx < 4; str_idx++) {\n    if (str[str_idx] == K_SPECIAL\n        && str[str_idx + 1] == KS_SPECIAL\n        && str[str_idx + 2] == KE_FILLER) {\n      buf[buf_idx++] = (char)K_SPECIAL;\n      str_idx += 2;\n    } else if ((str[str_idx] == K_SPECIAL)\n               && str[str_idx + 1] == KS_EXTRA\n               && str[str_idx + 2] == KE_CSI) {\n      buf[buf_idx++] = (char)CSI;\n      str_idx += 2;\n    } else if (str[str_idx] == K_SPECIAL) {\n      break;  // A special key can't be a multibyte char.\n    } else {\n      buf[buf_idx++] = (char)str[str_idx];\n    }\n    buf[buf_idx] = NUL;\n\n    // Return a multi-byte character if it's found.  An illegal sequence\n    // will result in a 1 here.\n    if (utf_ptr2len((const char_u *)buf) > 1) {\n      *pp = (const char *)str + str_idx + 1;\n      return buf;\n    }\n\n    // Bail out quickly for ASCII.\n    if ((uint8_t)buf[0] < 128) {\n      break;\n    }\n  }\n  return NULL;\n}\n\n/*\n * Return true if the character at \"row\"/\"col\" on the screen is the left side\n * of a double-width character.\n * Caller must make sure \"row\" and \"col\" are not invalid!\n */\nbool mb_lefthalve(int row, int col)\n{\n  return (*mb_off2cells)(LineOffset[row] + col,\n      LineOffset[row] + screen_Columns) > 1;\n}\n\n/*\n * Correct a position on the screen, if it's the right half of a double-wide\n * char move it to the left half.  Returns the corrected column.\n */\nint mb_fix_col(int col, int row)\n{\n  col = check_col(col);\n  row = check_row(row);\n  if (ScreenLines != NULL && col > 0\n      && ScreenLines[LineOffset[row] + col][0] == 0) {\n    return col - 1;\n  }\n  return col;\n}\n\n\n/*\n * Skip the Vim specific head of a 'encoding' name.\n */\nchar_u * enc_skip(char_u *p)\n{\n  if (STRNCMP(p, \"2byte-\", 6) == 0)\n    return p + 6;\n  if (STRNCMP(p, \"8bit-\", 5) == 0)\n    return p + 5;\n  return p;\n}\n\n/*\n * Find the canonical name for encoding \"enc\".\n * When the name isn't recognized, returns \"enc\" itself, but with all lower\n * case characters and '_' replaced with '-'.\n * Returns an allocated string.\n */\nchar_u *enc_canonize(char_u *enc) FUNC_ATTR_NONNULL_RET\n{\n  char_u      *p, *s;\n  int i;\n\n  if (STRCMP(enc, \"default\") == 0) {\n    // Use the default encoding as found by set_init_1().\n    return vim_strsave(fenc_default);\n  }\n\n  /* copy \"enc\" to allocated memory, with room for two '-' */\n  char_u *r = xmalloc(STRLEN(enc) + 3);\n  /* Make it all lower case and replace '_' with '-'. */\n  p = r;\n  for (s = enc; *s != NUL; ++s) {\n    if (*s == '_')\n      *p++ = '-';\n    else\n      *p++ = TOLOWER_ASC(*s);\n  }\n  *p = NUL;\n\n  /* Skip \"2byte-\" and \"8bit-\". */\n  p = enc_skip(r);\n\n  /* Change \"microsoft-cp\" to \"cp\".  Used in some spell files. */\n  if (STRNCMP(p, \"microsoft-cp\", 12) == 0)\n    STRMOVE(p, p + 10);\n\n  /* \"iso8859\" -> \"iso-8859\" */\n  if (STRNCMP(p, \"iso8859\", 7) == 0) {\n    STRMOVE(p + 4, p + 3);\n    p[3] = '-';\n  }\n\n  /* \"iso-8859n\" -> \"iso-8859-n\" */\n  if (STRNCMP(p, \"iso-8859\", 8) == 0 && p[8] != '-') {\n    STRMOVE(p + 9, p + 8);\n    p[8] = '-';\n  }\n\n  /* \"latin-N\" -> \"latinN\" */\n  if (STRNCMP(p, \"latin-\", 6) == 0)\n    STRMOVE(p + 5, p + 6);\n\n  if (enc_canon_search(p) >= 0) {\n    /* canonical name can be used unmodified */\n    if (p != r)\n      STRMOVE(r, p);\n  } else if ((i = enc_alias_search(p)) >= 0) {\n    /* alias recognized, get canonical name */\n    xfree(r);\n    r = vim_strsave((char_u *)enc_canon_table[i].name);\n  }\n  return r;\n}\n\n/*\n * Search for an encoding alias of \"name\".\n * Returns -1 when not found.\n */\nstatic int enc_alias_search(char_u *name)\n{\n  int i;\n\n  for (i = 0; enc_alias_table[i].name != NULL; ++i)\n    if (STRCMP(name, enc_alias_table[i].name) == 0)\n      return enc_alias_table[i].canon;\n  return -1;\n}\n\n\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n\n/*\n * Get the canonicalized encoding of the current locale.\n * Returns an allocated string when successful, NULL when not.\n */\nchar_u * enc_locale(void)\n{\n  int i;\n  char buf[50];\n\n  const char *s;\n# ifdef HAVE_NL_LANGINFO_CODESET\n  if (!(s = nl_langinfo(CODESET)) || *s == NUL)\n# endif\n  {\n#  if defined(HAVE_LOCALE_H)\n    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)\n#  endif\n    {\n      if ((s = os_getenv(\"LC_ALL\"))) {\n        if ((s = os_getenv(\"LC_CTYPE\"))) {\n          s = os_getenv(\"LANG\");\n        }\n      }\n    }\n  }\n\n  if (!s) {\n    return NULL;\n  }\n\n  // The most generic locale format is:\n  // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]\n  // If there is a '.' remove the part before it.\n  // if there is something after the codeset, remove it.\n  // Make the name lowercase and replace '_' with '-'.\n  // Exception: \"ja_JP.EUC\" == \"euc-jp\", \"zh_CN.EUC\" = \"euc-cn\",\n  // \"ko_KR.EUC\" == \"euc-kr\"\n  const char *p = (char *)vim_strchr((char_u *)s, '.');\n  if (p != NULL) {\n    if (p > s + 2 && !STRNICMP(p + 1, \"EUC\", 3)\n        && !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_') {\n      // Copy \"XY.EUC\" to \"euc-XY\" to buf[10].\n      memmove(buf, \"euc-\", 4);\n      buf[4] = (ASCII_ISALNUM(p[-2]) ? TOLOWER_ASC(p[-2]) : 0);\n      buf[5] = (ASCII_ISALNUM(p[-1]) ? TOLOWER_ASC(p[-1]) : 0);\n      buf[6] = NUL;\n    } else {\n      s = p + 1;\n      goto enc_locale_copy_enc;\n    }\n  } else {\nenc_locale_copy_enc:\n    for (i = 0; i < (int)sizeof(buf) - 1 && s[i] != NUL; i++) {\n      if (s[i] == '_' || s[i] == '-') {\n        buf[i] = '-';\n      } else if (ASCII_ISALNUM((uint8_t)s[i])) {\n        buf[i] = TOLOWER_ASC(s[i]);\n      } else {\n        break;\n      }\n    }\n    buf[i] = NUL;\n  }\n\n  return enc_canonize((char_u *)buf);\n}\n\n# if defined(USE_ICONV)\n\n\n/*\n * Call iconv_open() with a check if iconv() works properly (there are broken\n * versions).\n * Returns (void *)-1 if failed.\n * (should return iconv_t, but that causes problems with prototypes).\n */\nvoid * my_iconv_open(char_u *to, char_u *from)\n{\n  iconv_t fd;\n#define ICONV_TESTLEN 400\n  char_u tobuf[ICONV_TESTLEN];\n  char        *p;\n  size_t tolen;\n  static WorkingStatus iconv_working = kUnknown;\n\n  if (iconv_working == kBroken)\n    return (void *)-1;          /* detected a broken iconv() previously */\n\n#ifdef DYNAMIC_ICONV\n  // Check if the iconv.dll can be found.\n  if (!iconv_enabled(true)) {\n    return (void *)-1;\n  }\n#endif\n\n  fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));\n\n  if (fd != (iconv_t)-1 && iconv_working == kUnknown) {\n    /*\n     * Do a dummy iconv() call to check if it actually works.  There is a\n     * version of iconv() on Linux that is broken.  We can't ignore it,\n     * because it's wide-spread.  The symptoms are that after outputting\n     * the initial shift state the \"to\" pointer is NULL and conversion\n     * stops for no apparent reason after about 8160 characters.\n     */\n    p = (char *)tobuf;\n    tolen = ICONV_TESTLEN;\n    (void)iconv(fd, NULL, NULL, &p, &tolen);\n    if (p == NULL) {\n      iconv_working = kBroken;\n      iconv_close(fd);\n      fd = (iconv_t)-1;\n    } else\n      iconv_working = kWorking;\n  }\n\n  return (void *)fd;\n}\n\n/*\n * Convert the string \"str[slen]\" with iconv().\n * If \"unconvlenp\" is not NULL handle the string ending in an incomplete\n * sequence and set \"*unconvlenp\" to the length of it.\n * Returns the converted string in allocated memory.  NULL for an error.\n * If resultlenp is not NULL, sets it to the result length in bytes.\n */\nstatic char_u *iconv_string(const vimconv_T *const vcp, char_u *str,\n                            size_t slen, size_t *unconvlenp, size_t *resultlenp)\n{\n  const char  *from;\n  size_t fromlen;\n  char        *to;\n  size_t tolen;\n  size_t len = 0;\n  size_t done = 0;\n  char_u      *result = NULL;\n  char_u      *p;\n  int l;\n\n  from = (char *)str;\n  fromlen = slen;\n  for (;; ) {\n    if (len == 0 || ICONV_ERRNO == ICONV_E2BIG) {\n      /* Allocate enough room for most conversions.  When re-allocating\n       * increase the buffer size. */\n      len = len + fromlen * 2 + 40;\n      p = xmalloc(len);\n      if (done > 0)\n        memmove(p, result, done);\n      xfree(result);\n      result = p;\n    }\n\n    to = (char *)result + done;\n    tolen = len - done - 2;\n    /* Avoid a warning for systems with a wrong iconv() prototype by\n     * casting the second argument to void *. */\n    if (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen) != SIZE_MAX) {\n      /* Finished, append a NUL. */\n      *to = NUL;\n      break;\n    }\n\n    /* Check both ICONV_EINVAL and EINVAL, because the dynamically loaded\n     * iconv library may use one of them. */\n    if (!vcp->vc_fail && unconvlenp != NULL\n        && (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL)) {\n      /* Handle an incomplete sequence at the end. */\n      *to = NUL;\n      *unconvlenp = fromlen;\n      break;\n    }\n    /* Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded\n     * iconv library may use one of them. */\n    else if (!vcp->vc_fail\n        && (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ\n          || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL)) {\n      /* Can't convert: insert a '?' and skip a character.  This assumes\n       * conversion from 'encoding' to something else.  In other\n       * situations we don't know what to skip anyway. */\n      *to++ = '?';\n      if ((*mb_ptr2cells)((char_u *)from) > 1)\n        *to++ = '?';\n      l = utfc_ptr2len_len((const char_u *)from, (int)fromlen);\n      from += l;\n      fromlen -= l;\n    } else if (ICONV_ERRNO != ICONV_E2BIG) {\n      /* conversion failed */\n      xfree(result);\n      result = NULL;\n      break;\n    }\n    /* Not enough room or skipping illegal sequence. */\n    done = to - (char *)result;\n  }\n\n  if (resultlenp != NULL && result != NULL)\n    *resultlenp = (size_t)(to - (char *)result);\n  return result;\n}\n\n#  if defined(DYNAMIC_ICONV)\n/*\n * Dynamically load the \"iconv.dll\" on Win32.\n */\n\n#ifndef DYNAMIC_ICONV       /* just generating prototypes */\n# define HINSTANCE int\n#endif\nstatic HINSTANCE hIconvDLL = 0;\nstatic HINSTANCE hMsvcrtDLL = 0;\n\n#  ifndef DYNAMIC_ICONV_DLL\n#   define DYNAMIC_ICONV_DLL \"iconv.dll\"\n#   define DYNAMIC_ICONV_DLL_ALT \"libiconv-2.dll\"\n#  endif\n#  ifndef DYNAMIC_MSVCRT_DLL\n#   define DYNAMIC_MSVCRT_DLL \"msvcrt.dll\"\n#  endif\n\n/*\n * Get the address of 'funcname' which is imported by 'hInst' DLL.\n */\nstatic void * get_iconv_import_func(HINSTANCE hInst,\n    const char *funcname)\n{\n  PBYTE pImage = (PBYTE)hInst;\n  PIMAGE_DOS_HEADER pDOS = (PIMAGE_DOS_HEADER)hInst;\n  PIMAGE_NT_HEADERS pPE;\n  PIMAGE_IMPORT_DESCRIPTOR pImpDesc;\n  PIMAGE_THUNK_DATA pIAT;                   /* Import Address Table */\n  PIMAGE_THUNK_DATA pINT;                   /* Import Name Table */\n  PIMAGE_IMPORT_BY_NAME pImpName;\n\n  if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)\n    return NULL;\n  pPE = (PIMAGE_NT_HEADERS)(pImage + pDOS->e_lfanew);\n  if (pPE->Signature != IMAGE_NT_SIGNATURE)\n    return NULL;\n  pImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pImage\n      + pPE->OptionalHeader.DataDirectory[\n      IMAGE_DIRECTORY_ENTRY_IMPORT]\n      .VirtualAddress);\n  for (; pImpDesc->FirstThunk; ++pImpDesc) {\n    if (!pImpDesc->OriginalFirstThunk)\n      continue;\n    pIAT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->FirstThunk);\n    pINT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->OriginalFirstThunk);\n    for (; pIAT->u1.Function; ++pIAT, ++pINT) {\n      if (IMAGE_SNAP_BY_ORDINAL(pINT->u1.Ordinal))\n        continue;\n      pImpName = (PIMAGE_IMPORT_BY_NAME)(pImage\n          + (UINT_PTR)(pINT->u1.AddressOfData));\n      if (strcmp(pImpName->Name, funcname) == 0)\n        return (void *)pIAT->u1.Function;\n    }\n  }\n  return NULL;\n}\n\n// Load library \"name\".\nHINSTANCE vimLoadLib(char *name)\n{\n  HINSTANCE dll = NULL;\n\n  // NOTE: Do not use mch_dirname() and mch_chdir() here, they may call\n  //       vimLoadLib() recursively, which causes a stack overflow.\n  wchar_t old_dirw[MAXPATHL];\n\n  // Path to exe dir.\n  char *buf = xstrdup((char *)get_vim_var_str(VV_PROGPATH));\n  // ptrdiff_t len = ;\n  // assert(len > 0);\n  buf[path_tail_with_sep(buf) - buf] = '\\0';\n\n  if (GetCurrentDirectoryW(MAXPATHL, old_dirw) != 0) {\n    // Change directory to where the executable is, both to make\n    // sure we find a .dll there and to avoid looking for a .dll\n    // in the current directory.\n    SetCurrentDirectory((LPCSTR)buf);\n    // TODO(justinmk): use uv_dlopen instead. see os_libcall\n    dll = LoadLibrary(name);\n    SetCurrentDirectoryW(old_dirw);\n  }\n\n  return dll;\n}\n\n\n/*\n * Try opening the iconv.dll and return TRUE if iconv() can be used.\n */\nbool iconv_enabled(bool verbose)\n{\n  if (hIconvDLL != 0 && hMsvcrtDLL != 0)\n    return true;\n  hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);\n  if (hIconvDLL == 0)           /* sometimes it's called libiconv.dll */\n    hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT);\n  if (hIconvDLL != 0)\n    hMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);\n  if (hIconvDLL == 0 || hMsvcrtDLL == 0) {\n    /* Only give the message when 'verbose' is set, otherwise it might be\n     * done whenever a conversion is attempted. */\n    if (verbose && p_verbose > 0) {\n      verbose_enter();\n      EMSG2(_(e_loadlib),\n          hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL);\n      verbose_leave();\n    }\n    iconv_end();\n    return false;\n  }\n\n  iconv       = (void *)GetProcAddress(hIconvDLL, \"libiconv\");\n  iconv_open  = (void *)GetProcAddress(hIconvDLL, \"libiconv_open\");\n  iconv_close = (void *)GetProcAddress(hIconvDLL, \"libiconv_close\");\n  iconvctl    = (void *)GetProcAddress(hIconvDLL, \"libiconvctl\");\n  iconv_errno = get_iconv_import_func(hIconvDLL, \"_errno\");\n  if (iconv_errno == NULL)\n    iconv_errno = (void *)GetProcAddress(hMsvcrtDLL, \"_errno\");\n  if (iconv == NULL || iconv_open == NULL || iconv_close == NULL\n      || iconvctl == NULL || iconv_errno == NULL) {\n    iconv_end();\n    if (verbose && p_verbose > 0) {\n      verbose_enter();\n      EMSG2(_(e_loadfunc), \"for libiconv\");\n      verbose_leave();\n    }\n    return false;\n  }\n  return true;\n}\n\nvoid iconv_end(void)\n{\n  if (hIconvDLL != 0) {\n    // TODO(justinmk): use uv_dlclose instead.\n    FreeLibrary(hIconvDLL);\n  }\n  if (hMsvcrtDLL != 0) {\n    FreeLibrary(hMsvcrtDLL);\n  }\n  hIconvDLL = 0;\n  hMsvcrtDLL = 0;\n}\n\n#  endif /* DYNAMIC_ICONV */\n# endif /* USE_ICONV */\n\n\n\n\n/*\n * Setup \"vcp\" for conversion from \"from\" to \"to\".\n * The names must have been made canonical with enc_canonize().\n * vcp->vc_type must have been initialized to CONV_NONE.\n * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8\n * instead).\n * Afterwards invoke with \"from\" and \"to\" equal to NULL to cleanup.\n * Return FAIL when conversion is not supported, OK otherwise.\n */\nint convert_setup(vimconv_T *vcp, char_u *from, char_u *to)\n{\n  return convert_setup_ext(vcp, from, true, to, true);\n}\n\n/*\n * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all\n * \"from\" unicode charsets be considered utf-8.  Same for \"to\".\n */\nint convert_setup_ext(vimconv_T *vcp, char_u *from, bool from_unicode_is_utf8,\n                      char_u *to, bool to_unicode_is_utf8)\n{\n  int from_prop;\n  int to_prop;\n  int from_is_utf8;\n  int to_is_utf8;\n\n  /* Reset to no conversion. */\n# ifdef USE_ICONV\n  if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)\n    iconv_close(vcp->vc_fd);\n# endif\n  *vcp = (vimconv_T)MBYTE_NONE_CONV;\n\n  /* No conversion when one of the names is empty or they are equal. */\n  if (from == NULL || *from == NUL || to == NULL || *to == NUL\n      || STRCMP(from, to) == 0)\n    return OK;\n\n  from_prop = enc_canon_props(from);\n  to_prop = enc_canon_props(to);\n  if (from_unicode_is_utf8)\n    from_is_utf8 = from_prop & ENC_UNICODE;\n  else\n    from_is_utf8 = from_prop == ENC_UNICODE;\n  if (to_unicode_is_utf8)\n    to_is_utf8 = to_prop & ENC_UNICODE;\n  else\n    to_is_utf8 = to_prop == ENC_UNICODE;\n\n  if ((from_prop & ENC_LATIN1) && to_is_utf8) {\n    /* Internal latin1 -> utf-8 conversion. */\n    vcp->vc_type = CONV_TO_UTF8;\n    vcp->vc_factor = 2;         /* up to twice as long */\n  } else if ((from_prop & ENC_LATIN9) && to_is_utf8) {\n    /* Internal latin9 -> utf-8 conversion. */\n    vcp->vc_type = CONV_9_TO_UTF8;\n    vcp->vc_factor = 3;         /* up to three as long (euro sign) */\n  } else if (from_is_utf8 && (to_prop & ENC_LATIN1)) {\n    /* Internal utf-8 -> latin1 conversion. */\n    vcp->vc_type = CONV_TO_LATIN1;\n  } else if (from_is_utf8 && (to_prop & ENC_LATIN9)) {\n    /* Internal utf-8 -> latin9 conversion. */\n    vcp->vc_type = CONV_TO_LATIN9;\n  }\n# ifdef USE_ICONV\n  else {\n    /* Use iconv() for conversion. */\n    vcp->vc_fd = (iconv_t)my_iconv_open(\n        to_is_utf8 ? (char_u *)\"utf-8\" : to,\n        from_is_utf8 ? (char_u *)\"utf-8\" : from);\n    if (vcp->vc_fd != (iconv_t)-1) {\n      vcp->vc_type = CONV_ICONV;\n      vcp->vc_factor = 4;       /* could be longer too... */\n    }\n  }\n# endif\n  if (vcp->vc_type == CONV_NONE)\n    return FAIL;\n\n  return OK;\n}\n\n/*\n * Convert text \"ptr[*lenp]\" according to \"vcp\".\n * Returns the result in allocated memory and sets \"*lenp\".\n * When \"lenp\" is NULL, use NUL terminated strings.\n * Illegal chars are often changed to \"?\", unless vcp->vc_fail is set.\n * When something goes wrong, NULL is returned and \"*lenp\" is unchanged.\n */\nchar_u *string_convert(const vimconv_T *const vcp, char_u *ptr, size_t *lenp)\n{\n  return string_convert_ext(vcp, ptr, lenp, NULL);\n}\n\n/*\n * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is\n * an incomplete sequence at the end it is not converted and \"*unconvlenp\" is\n * set to the number of remaining bytes.\n */\nchar_u * string_convert_ext(const vimconv_T *const vcp, char_u *ptr,\n                            size_t *lenp, size_t *unconvlenp)\n{\n  char_u      *retval = NULL;\n  char_u      *d;\n  int l;\n  int c;\n\n  size_t len;\n  if (lenp == NULL)\n    len = STRLEN(ptr);\n  else\n    len = *lenp;\n  if (len == 0)\n    return vim_strsave((char_u *)\"\");\n\n  switch (vcp->vc_type) {\n    case CONV_TO_UTF8:            /* latin1 to utf-8 conversion */\n      retval = xmalloc(len * 2 + 1);\n      d = retval;\n      for (size_t i = 0; i < len; ++i) {\n        c = ptr[i];\n        if (c < 0x80)\n          *d++ = c;\n        else {\n          *d++ = 0xc0 + ((unsigned)c >> 6);\n          *d++ = 0x80 + (c & 0x3f);\n        }\n      }\n      *d = NUL;\n      if (lenp != NULL)\n        *lenp = (size_t)(d - retval);\n      break;\n\n    case CONV_9_TO_UTF8:          /* latin9 to utf-8 conversion */\n      retval = xmalloc(len * 3 + 1);\n      d = retval;\n      for (size_t i = 0; i < len; ++i) {\n        c = ptr[i];\n        switch (c) {\n          case 0xa4: c = 0x20ac; break;                 /* euro */\n          case 0xa6: c = 0x0160; break;                 /* S hat */\n          case 0xa8: c = 0x0161; break;                 /* S -hat */\n          case 0xb4: c = 0x017d; break;                 /* Z hat */\n          case 0xb8: c = 0x017e; break;                 /* Z -hat */\n          case 0xbc: c = 0x0152; break;                 /* OE */\n          case 0xbd: c = 0x0153; break;                 /* oe */\n          case 0xbe: c = 0x0178; break;                 /* Y */\n        }\n        d += utf_char2bytes(c, d);\n      }\n      *d = NUL;\n      if (lenp != NULL)\n        *lenp = (size_t)(d - retval);\n      break;\n\n    case CONV_TO_LATIN1:          /* utf-8 to latin1 conversion */\n    case CONV_TO_LATIN9:          /* utf-8 to latin9 conversion */\n      retval = xmalloc(len + 1);\n      d = retval;\n      for (size_t i = 0; i < len; ++i) {\n        l = utf_ptr2len_len(ptr + i, len - i);\n        if (l == 0)\n          *d++ = NUL;\n        else if (l == 1) {\n          uint8_t l_w = utf8len_tab_zero[ptr[i]];\n\n          if (l_w == 0) {\n            /* Illegal utf-8 byte cannot be converted */\n            xfree(retval);\n            return NULL;\n          }\n          if (unconvlenp != NULL && l_w > len - i) {\n            /* Incomplete sequence at the end. */\n            *unconvlenp = len - i;\n            break;\n          }\n          *d++ = ptr[i];\n        } else {\n          c = utf_ptr2char(ptr + i);\n          if (vcp->vc_type == CONV_TO_LATIN9)\n            switch (c) {\n              case 0x20ac: c = 0xa4; break;                     /* euro */\n              case 0x0160: c = 0xa6; break;                     /* S hat */\n              case 0x0161: c = 0xa8; break;                     /* S -hat */\n              case 0x017d: c = 0xb4; break;                     /* Z hat */\n              case 0x017e: c = 0xb8; break;                     /* Z -hat */\n              case 0x0152: c = 0xbc; break;                     /* OE */\n              case 0x0153: c = 0xbd; break;                     /* oe */\n              case 0x0178: c = 0xbe; break;                     /* Y */\n              case 0xa4:\n              case 0xa6:\n              case 0xa8:\n              case 0xb4:\n              case 0xb8:\n              case 0xbc:\n              case 0xbd:\n              case 0xbe: c = 0x100; break;                   /* not in latin9 */\n            }\n          if (!utf_iscomposing(c)) {              /* skip composing chars */\n            if (c < 0x100)\n              *d++ = c;\n            else if (vcp->vc_fail) {\n              xfree(retval);\n              return NULL;\n            } else {\n              *d++ = 0xbf;\n              if (utf_char2cells(c) > 1)\n                *d++ = '?';\n            }\n          }\n          i += l - 1;\n        }\n      }\n      *d = NUL;\n      if (lenp != NULL)\n        *lenp = (size_t)(d - retval);\n      break;\n\n# ifdef USE_ICONV\n    case CONV_ICONV:              /* conversion with vcp->vc_fd */\n      retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);\n      break;\n# endif\n  }\n\n  return retval;\n}\n\n// Check bounds for column number\nstatic int check_col(int col)\n{\n  if (col < 0)\n    return 0;\n  if (col >= screen_Columns)\n    return screen_Columns - 1;\n  return col;\n}\n\n// Check bounds for row number\nstatic int check_row(int row)\n{\n  if (row < 0)\n    return 0;\n  if (row >= screen_Rows)\n    return screen_Rows - 1;\n  return row;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/os/dl.c": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/// Functions for using external native libraries\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <uv.h>\n\n#include \"nvim/os/os.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n\n/// possible function prototypes that can be called by os_libcall()\n/// int -> int\n/// int -> string\n/// string -> string\n/// string -> int\ntypedef void (*gen_fn)(void);\ntypedef const char *(*str_str_fn)(const char *str);\ntypedef int64_t (*str_int_fn)(const char *str);\ntypedef const char *(*int_str_fn)(int64_t i);\ntypedef int64_t (*int_int_fn)(int64_t i);\n\n/// os_libcall - call a function in a dynamic loadable library\n///\n/// an example of calling a function that takes a string and returns an int:\n///\n///   int64_t int_out = 0;\n///   os_libcall(\"mylib.so\", \"somefn\", \"string-argument\", 0, NULL, &int_out);\n///\n/// @param libname the name of the library to load (e.g.: libsomething.so)\n/// @param funcname the name of the library function (e.g.: myfunc)\n/// @param argv the input string, NULL when using `argi`\n/// @param argi the input integer, not used when using `argv` != NULL\n/// @param[out] str_out an allocated output string, caller must free if\n///             not NULL. NULL when using `int_out`.\n/// @param[out] int_out the output integer param\n/// @return true on success, false on failure\nbool os_libcall(const char *libname,\n                const char *funcname,\n                const char *argv,\n                int64_t argi,\n                char **str_out,\n                int64_t *int_out)\n{\n  if (!libname || !funcname) {\n    return false;\n  }\n\n  uv_lib_t lib;\n\n  // open the dynamic loadable library\n  if (uv_dlopen(libname, &lib)) {\n      EMSG2(_(\"dlerror = \\\"%s\\\"\"), uv_dlerror(&lib));\n      return false;\n  }\n\n  // find and load the requested function in the library\n  gen_fn fn;\n  if (uv_dlsym(&lib, funcname, (void **) &fn)) {\n      EMSG2(_(\"dlerror = \\\"%s\\\"\"), uv_dlerror(&lib));\n      uv_dlclose(&lib);\n      return false;\n  }\n\n  // call the library and save the result\n  // TODO(aktau): catch signals and use jmp (if available) to handle\n  // exceptions. jmp's on Unix seem to interact trickily with signals as\n  // well. So for now we only support those libraries that are well-behaved.\n  if (str_out) {\n    str_str_fn sfn = (str_str_fn) fn;\n    int_str_fn ifn = (int_str_fn) fn;\n\n    const char *res = argv ? sfn(argv) : ifn(argi);\n\n    // assume that ptr values of NULL, 1 or -1 are illegal\n    *str_out = (res && (intptr_t) res != 1 && (intptr_t) res != -1)\n        ? xstrdup(res) : NULL;\n  } else {\n    str_int_fn sfn = (str_int_fn) fn;\n    int_int_fn ifn = (int_int_fn) fn;\n    *int_out = argv ? sfn(argv) : ifn(argi);\n  }\n\n  // free the library\n  uv_dlclose(&lib);\n\n  return true;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/cmake/FindLibUV.cmake": "# - Try to find libuv\n# Once done, this will define\n#\n#  LIBUV_FOUND - system has libuv\n#  LIBUV_INCLUDE_DIRS - the libuv include directories\n#  LIBUV_LIBRARIES - link these to use libuv\n#\n# Set the LIBUV_USE_STATIC variable to specify if static libraries should\n# be preferred to shared ones.\n\nif(NOT USE_BUNDLED_LIBUV)\n  find_package(PkgConfig)\n  if (PKG_CONFIG_FOUND)\n    pkg_check_modules(PC_LIBUV QUIET libuv)\n  endif()\nelse()\n  set(PC_LIBUV_INCLUDEDIR)\n  set(PC_LIBUV_INCLUDE_DIRS)\n  set(PC_LIBUV_LIBDIR)\n  set(PC_LIBUV_LIBRARY_DIRS)\n  set(LIMIT_SEARCH NO_DEFAULT_PATH)\nendif()\n\nfind_path(LIBUV_INCLUDE_DIR uv.h\n  HINTS ${PC_LIBUV_INCLUDEDIR} ${PC_LIBUV_INCLUDE_DIRS}\n  ${LIMIT_SEARCH})\n\n# If we're asked to use static linkage, add libuv.a as a preferred library name.\nif(LIBUV_USE_STATIC)\n  list(APPEND LIBUV_NAMES\n    \"${CMAKE_STATIC_LIBRARY_PREFIX}uv${CMAKE_STATIC_LIBRARY_SUFFIX}\")\nendif(LIBUV_USE_STATIC)\n\nlist(APPEND LIBUV_NAMES uv)\n\nfind_library(LIBUV_LIBRARY NAMES ${LIBUV_NAMES}\n  HINTS ${PC_LIBUV_LIBDIR} ${PC_LIBUV_LIBRARY_DIRS}\n  ${LIMIT_SEARCH})\n\nmark_as_advanced(LIBUV_INCLUDE_DIR LIBUV_LIBRARY)\n\nif(PC_LIBUV_LIBRARIES)\n    list(REMOVE_ITEM PC_LIBUV_LIBRARIES uv)\nendif()\n\nset(LIBUV_LIBRARIES ${LIBUV_LIBRARY} ${PC_LIBUV_LIBRARIES})\nset(LIBUV_INCLUDE_DIRS ${LIBUV_INCLUDE_DIR})\n\n# Deal with the fact that libuv.pc is missing important dependency information.\n\ninclude(CheckLibraryExists)\n\ncheck_library_exists(dl dlopen \"dlfcn.h\" HAVE_LIBDL)\nif(HAVE_LIBDL)\n  list(APPEND LIBUV_LIBRARIES dl)\nendif()\n\ncheck_library_exists(kstat kstat_lookup \"kstat.h\" HAVE_LIBKSTAT)\nif(HAVE_LIBKSTAT)\n  list(APPEND LIBUV_LIBRARIES kstat)\nendif()\n\ncheck_library_exists(kvm kvm_open \"kvm.h\" HAVE_LIBKVM)\nif(HAVE_LIBKVM AND NOT CMAKE_SYSTEM_NAME STREQUAL \"OpenBSD\")\n  list(APPEND LIBUV_LIBRARIES kvm)\nendif()\n\ncheck_library_exists(nsl gethostbyname \"nsl.h\" HAVE_LIBNSL)\nif(HAVE_LIBNSL)\n  list(APPEND LIBUV_LIBRARIES nsl)\nendif()\n\ncheck_library_exists(perfstat perfstat_cpu \"libperfstat.h\" HAVE_LIBPERFSTAT)\nif(HAVE_LIBPERFSTAT)\n  list(APPEND LIBUV_LIBRARIES perfstat)\nendif()\n\ncheck_library_exists(rt clock_gettime \"time.h\" HAVE_LIBRT)\nif(HAVE_LIBRT)\n  list(APPEND LIBUV_LIBRARIES rt)\nendif()\n\ncheck_library_exists(sendfile sendfile \"\" HAVE_LIBSENDFILE)\nif(HAVE_LIBSENDFILE)\n  list(APPEND LIBUV_LIBRARIES sendfile)\nendif()\n\nif(WIN32)\n  # check_library_exists() does not work for Win32 API calls in X86 due to name\n  # mangling calling conventions\n  list(APPEND LIBUV_LIBRARIES iphlpapi)\n  list(APPEND LIBUV_LIBRARIES psapi)\n  list(APPEND LIBUV_LIBRARIES userenv)\n  list(APPEND LIBUV_LIBRARIES ws2_32)\nendif()\n\ninclude(FindPackageHandleStandardArgs)\n\n# handle the QUIETLY and REQUIRED arguments and set LIBUV_FOUND to TRUE\n# if all listed variables are TRUE\nfind_package_handle_standard_args(LibUV DEFAULT_MSG\n                                  LIBUV_LIBRARY LIBUV_INCLUDE_DIR)\n\nmark_as_advanced(LIBUV_INCLUDE_DIR LIBUV_LIBRARY)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/digraph.c",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/cs.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/ja.euc-jp.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/sk.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/cs.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/sk.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/ga.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/sv.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/nb.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/it.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/no.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/pt_BR.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/af.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/po/de.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test_increment_dbcs.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test_spell.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test52.in",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test_regexp_latin.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test42.ok",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test_farsi.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test52.ok",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test_mksession.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/src/nvim/testdir/test42.in",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/nvim.png",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/moo.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/pascal.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/rtf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/groff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/lout.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/forth.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/nroff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/css.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/fortran.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/initng.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/iss.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/mmix.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/elf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/syntax/robots.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/ftplugin/ocaml.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/ftplugin/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/ftplugin/erlang.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/hebrewp_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/greek_cp737.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/canfr-win.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/serbian_cp1251.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/slovak_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/greek_iso-8859-7.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/hebrew_iso-8859-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/serbian_iso-8859-5.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/accents.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/serbian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/esperanto_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/croatian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/serbian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/greek_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/croatian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/greek_cp1253.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/hebrewp_cp1255.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/keymap/slovak_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/indent/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/indent/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/map.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/spell.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/mlang.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/makehtml.awk",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/usr_24.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/doc/farsi.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/runtime/spell/en.utf-8.spl",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/legacy/093_mksession_cursor_cols_latin1_spec.lua",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/legacy/044_099_regexp_multibyte_magic_spec.lua",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/api_level_2.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/api_level_0.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/shell_data.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/api_level_3.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/api_level_4.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/test/functional/fixtures/api_level_1.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-0.3.1-ljn6ktops45unbefxh6iix5pbcuznglk/spack-src/contrib/doxygen/logo-devdoc.png"
    ],
    "total_files": 2382
}