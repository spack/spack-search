{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\ndnl The macros which aren't shipped with the autotools are stored in the\ndnl Tools/config directory in .m4 files.\n\nAC_INIT([swig],[2.0.12],[http://www.swig.org])\n\ndnl NB: When this requirement is increased to 2.60 or later, AC_PROG_SED\ndnl     definition below can be removed\nAC_PREREQ(2.58)\n\nAC_CONFIG_SRCDIR([Source/Swig/swig.h])\nAC_CONFIG_AUX_DIR([Tools/config])\nAC_CONFIG_HEADERS([Source/Include/swigconfig.h])\nAC_CANONICAL_HOST\nAM_INIT_AUTOMAKE\n\ndnl Some extra defines for the config file\nAH_BOTTOM([\n/* Default language */\n#define SWIG_LANG               \"-tcl\"\n\n/* Deal with Microsofts attempt at deprecating C standard runtime functions */\n#if defined(_MSC_VER)\n# define _CRT_SECURE_NO_DEPRECATE\n#endif\n])\n\ndnl Check for programs that a user requires to build SWIG\nAC_PROG_CC\nAC_PROG_CXX\nAC_EXEEXT\nAC_OBJEXT\nAM_PROG_CC_C_O  # Needed for subdir-objects in AUTOMAKE_OPTIONS\n\nAC_COMPILE_WARNINGS # Increase warning levels\n\nAC_DEFINE_UNQUOTED(SWIG_CXX, [\"$CXX\"], [Compiler that built SWIG])\nAC_DEFINE_UNQUOTED(SWIG_PLATFORM, [\"$host\"], [Platform that SWIG is built for])\n\ndnl Checks for header files.\nAC_HEADER_STDC\n\ndnl Checks for types.\nAC_LANG_PUSH([C++])\nAC_CHECK_TYPES([bool])\nAC_LANG_POP([C++])\n\ndnl Look for popen\nAC_ARG_WITH(popen, AS_HELP_STRING([--without-popen], [Disable popen]), with_popen=\"$withval\")\nif test x\"${with_popen}\" = xno ; then\nAC_MSG_NOTICE([Disabling popen])\nelse\nAC_CHECK_FUNC(popen, AC_DEFINE(HAVE_POPEN, 1, [Define if popen is available]), AC_MSG_NOTICE([Disabling popen]))\nfi\n\ndnl PCRE\n\ndnl AX_PATH_GENERIC() relies on AC_PROG_SED() but it is defined only in\ndnl autoconf 2.60 so trivially predefine it ourselves for the older versions\nm4_ifdef([AC_PROG_SED],, [AC_DEFUN([AC_PROG_SED], [AC_PATH_PROG([SED], sed)])])\n\nAC_ARG_WITH([pcre],\n  [AS_HELP_STRING([--without-pcre],\n                  [Disable support for regular expressions using PCRE])],\n  [],\n  [with_pcre=yes])\n\nAC_MSG_CHECKING([whether to enable PCRE support])\nAC_MSG_RESULT([$with_pcre])\n\ndnl To make configuring easier, check for a locally built PCRE using the Tools/pcre-build.sh script\nif test x\"${with_pcre}\" = xyes ; then\n  AC_MSG_CHECKING([whether to use local PCRE])\n  local_pcre_config=no\n  if test -z $PCRE_CONFIG; then\n    if test -f `pwd`/pcre/pcre-swig-install/bin/pcre-config; then\n      PCRE_CONFIG=`pwd`/pcre/pcre-swig-install/bin/pcre-config\n      local_pcre_config=$PCRE_CONFIG\n    fi\n  fi\n  AC_MSG_RESULT([$local_pcre_config])\nfi\nAS_IF([test \"x$with_pcre\" != xno],\n  [AX_PATH_GENERIC([pcre],\n    [], dnl Minimal version of PCRE we need -- accept any\n    [], dnl custom sed script for version parsing is not needed\n    [AC_DEFINE([HAVE_PCRE], [1], [Define if you have PCRE library])\n     LIBS=\"$LIBS $PCRE_LIBS\"\n     CPPFLAGS=\"$CPPFLAGS $PCRE_CFLAGS\"\n    ],\n    [AC_MSG_FAILURE([\n        Cannot find pcre-config script from PCRE (Perl Compatible Regular Expressions)\n        library package. This dependency is needed for configure to complete,\n        Either:\n        - Install the PCRE developer package on your system (preferred approach).\n        - Download the PCRE source tarball, build and install on your system\n          as you would for any package built from source distribution.\n        - Use the Tools/pcre-build.sh script to build PCRE just for SWIG to statically\n          link against. Run 'Tools/pcre-build.sh --help' for instructions.\n          (quite easy and does not require privileges to install PCRE on your system)\n        - Use configure --without-pcre to disable regular expressions support in SWIG\n          (not recommended).])\n    ])\n  ])\n\n\ndnl CCache\nAC_ARG_ENABLE([ccache], AS_HELP_STRING([--disable-ccache], [disable building and installation of ccache-swig executable (default enabled)]), [enable_ccache=$enableval], [enable_ccache=yes])\nAC_MSG_CHECKING([whether to enable ccache-swig])\nAC_MSG_RESULT([$enable_ccache])\n\nif test \"$enable_ccache\" = yes; then\n  AC_CONFIG_SUBDIRS(CCache)\n  ENABLE_CCACHE=1\nfi\nAC_SUBST(ENABLE_CCACHE)\n\n\necho \"\"\necho \"Checking packages required for SWIG developers.\"\necho \"Note : None of the following packages are required for users to compile and install SWIG from the distributed tarball\"\necho \"\"\n\nAC_PROG_YACC\nAC_PROG_RANLIB\nAC_CHECK_PROGS(AR, ar aal, ar)\nAC_SUBST(AR)\nAC_CHECK_PROGS(YODL2MAN, yodl2man)\nAC_CHECK_PROGS(YODL2HTML, yodl2html)\n\nif test -n \"$YODL2MAN\"; then\n  AC_MSG_CHECKING([yodl2man version >= 2.02])\n  yodl_version=`$YODL2MAN --version 2>&1 | grep 'yodl version' | sed 's/.*\\([0-9][0-9]*\\.[0-9][0-9]*\\.*[0-9]*\\).*/\\1/g'`\n  AX_COMPARE_VERSION([$yodl_version],[ge],[2.02], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no - $yodl_version found])])\nfi\n\nif test -n \"$YODL2HTML\"; then\n  AC_MSG_CHECKING([yodl2html version >= 2.02])\n  yodl_version=`$YODL2HTML --version 2>&1 | grep 'yodl version' | sed 's/.*\\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*/\\1/g'`\n  AX_COMPARE_VERSION([$yodl_version],[ge],[2.02], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no - $yodl_version found])])\nfi\n\necho \"\"\necho \"Checking for installed target languages and other information in order to compile and run\"\necho \"the examples and test-suite invoked by 'make check'.\"\necho \"Note : None of the following packages are required for users to compile and install SWIG from the distributed tarball\"\necho \"\"\n\ndnl Some test cases require Boost\nAX_BOOST_BASE(,,,)\nAC_SUBST(BOOST_CPPFLAGS)\n\ndnl How to specify include directories that may be system directories.\n# -I should not be used on system directories (GCC)\nif test \"$GCC\" = yes; then\n    ISYSTEM=\"-isystem \"\nelse\n    ISYSTEM=\"-I\"\nfi\nAC_MSG_NOTICE(ISYSTEM: $ISYSTEM)\n\ndnl Info for building shared libraries ... in order to run the examples\n\n# SO is the extension of shared libraries (including the dot!)\nAC_MSG_CHECKING(SO)\nif test -z \"$SO\"\nthen\n\tcase $host in\n\t*-*-hp*) SO=.sl;;\n\t*-*-darwin*) SO=.bundle;;\n\t*-*-cygwin* | *-*-mingw*) SO=.dll;;\n\t*) SO=.so;;\n\tesac\nfi\nAC_MSG_RESULT($SO)\n\n# LDSHARED is the ld *command* used to create shared library\n# -- \"ld\" on SunOS 4.x.x, \"ld -G\" on SunOS 5.x, \"ld -shared\" on IRIX 5\n# (Shared libraries in this instance are shared modules to be loaded into\n# Python, as opposed to building Python itself as a shared library.)\nAC_MSG_CHECKING(LDSHARED)\nif test -z \"$LDSHARED\"\nthen\n\tcase $host in\n\t*-*-aix*) LDSHARED=\"\\$(srcdir)/ld_so_aix \\$(CC)\";;\n\t*-*-cygwin* | *-*-mingw*)\n            if test \"$GCC\" = yes; then\n                LDSHARED=\"$CC -shared\"\n            else\n                if test \"cl\" = $CC ;  then\n                    # Microsoft Visual C++ (MSVC)\n                    LDSHARED=\"$CC -nologo -LD\"\n                else\n                    # Unknown compiler try gcc approach\n                    LDSHARED=\"$CC -shared\"\n                fi\n            fi ;;\n\t*-*-irix5*) LDSHARED=\"ld -shared\";;\n\t*-*-irix6*) LDSHARED=\"ld ${SGI_ABI} -shared -all\";;\n\t*-*-sunos4*) LDSHARED=\"ld\";;\n\t*-*-solaris*) LDSHARED=\"ld -G\";;\n\t*-*-hp*) LDSHARED=\"ld -b\";;\n\t*-*-osf*) LDSHARED=\"ld -shared -expect_unresolved \\\"*\\\"\";;\n\t*-sequent-sysv4) LDSHARED=\"ld -G\";;\n\t*-*-next*)\n\t\tif test \"$ns_dyld\"\n\t\tthen LDSHARED='$(CC) $(LDFLAGS) -bundle -prebind'\n\t\telse LDSHARED='$(CC) $(CFLAGS) -nostdlib -r'\n\t\tfi\n                if test \"$with_next_framework\" ; then\n\t\t    LDSHARED=\"$LDSHARED \\$(LDLIBRARY)\"\n\t\tfi ;;\n\t*-*-linux*) LDSHARED=\"gcc -shared\";;\n\t*-*-dgux*) LDSHARED=\"ld -G\";;\n\t*-*-freebsd3*) LDSHARED=\"gcc -shared\";;\n\t*-*-freebsd* | *-*-openbsd*) LDSHARED=\"ld -Bshareable\";;\n\t*-*-netbsd*)\n\t\tif [[ \"`$CC -dM -E - </dev/null | grep __ELF__`\" != \"\" ]]\n\t\tthen\n\t\t\tLDSHARED=\"cc -shared\"\n\t\telse\n\t\t\tLDSHARED=\"ld -Bshareable\"\n\t\tfi;;\n\t*-sco-sysv*) LDSHARED=\"cc -G -KPIC -Ki486 -belf -Wl,-Bexport\";;\n\t*-*-darwin*) LDSHARED=\"cc -bundle -undefined suppress -flat_namespace\";;\n\t*)\tLDSHARED=\"ld\";;\n\tesac\nfi\nAC_MSG_RESULT($LDSHARED)\n# CXXSHARED is the ld *command* used to create C++ shared library\n# -- \"ld\" on SunOS 4.x.x, \"ld -G\" on SunOS 5.x, \"ld -shared\" on IRIX 5\n# (Shared libraries in this instance are shared modules to be loaded into\n# Python, as opposed to building Python itself as a shared library.)\nAC_MSG_CHECKING(CXXSHARED)\nif test -z \"$CXXSHARED\"\nthen\n\tCXXSHARED=\"$LDSHARED\"\nfi\nAC_MSG_RESULT($CXXSHARED)\n\n#\nAC_MSG_CHECKING(TRYLINKINGWITHCXX)\nif test -z \"$TRYLINKINGWITHCXX\"\nthen\n\tcase $host in\n\t*-*-solaris*) if test \"$GCC\" = yes\n             then TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -Wl,-G\"\n             else TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -G -L/opt/SUNWspro/lib -lCrun -lCstd\"\n             fi;;\n        *-*-hp*) TRYLINKINGWITHCXX=\"CXXSHARED= $CXX +z \";;\n        *-*-darwin*) TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -bundle -undefined suppress -flat_namespace\";;\n        *-*-cygwin* | *-*-mingw*)\n            if test \"$GCC\" = yes; then\n                TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -shared \"\n            else\n                if test \"cl\" = $CXX ;  then\n                    # Microsoft Visual C++ (MSVC)\n                    TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -nologo -LD\"\n                else\n                    TRYLINKINGWITHCXX=\"#unknown Windows compiler\"\n                fi\n            fi ;;\n        *)       TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -shared \";;\n        esac\nfi\nAC_MSG_RESULT($TRYLINKINGWITHCXX)\n# CCSHARED are the C *flags* used to create objects to go into a shared\n# library (module) -- this is only needed for a few systems\nAC_MSG_CHECKING(CCSHARED)\nif test -z \"$CCSHARED\"\nthen\n\tcase $host in\n\t*-*-hp*) if test \"$GCC\" = yes\n\t\t then CCSHARED=\"-fpic\"\n\t\t else CCSHARED=\"+z\"\n\t\t fi;;\n\t*-*-linux*) CCSHARED=\"-fpic\";;\n\t*-*-freebsd* | *-*-openbsd*) CCSHARED=\"-fpic\";;\n\t*-*-netbsd*) CCSHARED=\"-fPIC\";;\n\t*-sco-sysv*) CCSHARED=\"-KPIC -dy -Bdynamic\";;\n\t*-*-irix6*)  case $CC in\n\t\t   *gcc*) CCSHARED=\"-shared\";;\n\t\t   *) CCSHARED=\"\";;\n\t\t   esac;;\n\tesac\nfi\nAC_MSG_RESULT($CCSHARED)\n\n# RPATH is the path used to look for shared library files.\nAC_MSG_CHECKING(RPATH)\nif test -z \"$RPATH\"\nthen\n\tcase $host in\n\t*-*-solaris*) RPATH='-R. -R$(exec_prefix)/lib';;\n        *-*-irix*) RPATH='-rpath .:$(exec_prefix)/lib';;\n\t*-*-linux*) RPATH='-Xlinker -rpath $(exec_prefix)/lib -Xlinker -rpath .';;\n\t*)\tRPATH='';;\n\tesac\nfi\nAC_MSG_RESULT($RPATH)\n\n# LINKFORSHARED are the flags passed to the $(CC) command that links\n# the a few executables -- this is only needed for a few systems\n\nAC_MSG_CHECKING(LINKFORSHARED)\nif test -z \"$LINKFORSHARED\"\nthen\n\tcase $host in\n\t*-*-aix*)\tLINKFORSHARED='-Wl,-bE:$(srcdir)/python.exp -lld';;\n\t*-*-hp*)\n\t    LINKFORSHARED=\"-Wl,-E -Wl,+s -Wl,+b\\$(BINLIBDEST)/lib-dynload\";;\n\t*-*-linux*) LINKFORSHARED=\"-Xlinker -export-dynamic\";;\n\t*-*-next*) LINKFORSHARED=\"-u libsys_s\";;\n\t*-sco-sysv*) LINKFORSHARED=\"-Bdynamic -dy -Wl,-Bexport\";;\n\t*-*-irix6*) LINKFORSHARED=\"-all\";;\n\tesac\nfi\nAC_MSG_RESULT($LINKFORSHARED)\n\n# Optional CFLAGS used to silence/enhance compiler warnings on some platforms.\nAC_MSG_CHECKING(PLATFLAGS)\ncase $host in\n  *-*-solaris*) if test \"$GCC\" = yes\n    then PLATFLAGS=\n    else PLATFLAGS=\n      #    else PLATFLAGS=\"-errtags=yes\" # Need more work as C examples use ld for linking\n    fi;;\n  *) PLATFLAGS=\nesac\nAC_MSG_RESULT($PLATFLAGS)\n\n# Set info about shared libraries.\nAC_SUBST(SO)\nAC_SUBST(LDSHARED)\nAC_SUBST(CCSHARED)\nAC_SUBST(CXXSHARED)\nAC_SUBST(TRYLINKINGWITHCXX)\nAC_SUBST(RPATH)\nAC_SUBST(PLATFLAGS)\nAC_SUBST(LINKFORSHARED)\n\n# This variation is needed on OS-X because there is no (apparent) consistency in shared library naming.\n# Sometimes .bundle works, but sometimes .so is needed.  It depends on the target language\n\nAC_SUBST(PYTHON_SO)\ncase $host in\n   *-*-mingw*) PYTHON_SO=.pyd;;\n   *-*-darwin*) PYTHON_SO=.so;;\n   *) PYTHON_SO=$SO;;\nesac\n\nAC_SUBST(TCL_SO)\ncase $host in\n   *-*-darwin*) TCL_SO=.dylib;;\n   *) TCL_SO=$SO;;\nesac\n\nAC_SUBST(GUILE_SO)\ncase $host in\n   *-*-darwin*) GUILE_SO=.so;;\n   *) GUILE_SO=$SO;;\nesac\n\nAC_SUBST(PHP_SO)\ncase $host in\n   *-*-darwin*) PHP_SO=.so;;\n   *) PHP_SO=$SO;;\nesac\n\nAC_SUBST(MZSCHEME_SO)\ncase $host in\n   *) MZSCHEME_SO=.so;;\nesac\n\nAC_SUBST(LUA_SO)\ncase $host in\n   *-*-darwin*) LUA_SO=.so;;\n   *) LUA_SO=$SO;;\nesac\n\n# Check for specific libraries.   Used for SWIG examples\nAC_CHECK_LIB(dl, dlopen)\t# Dynamic linking for SunOS/Solaris and SYSV\nAC_CHECK_LIB(dld, shl_load)\t# Dynamic linking for HP-UX\n\ndnl The following three libraries (nsl,inet,socket) are needed on Sequent,\ndnl and must be checked for in this order since each library depends on the\ndnl preceding one.\ndnl\ndnl Most SVR4 platforms will need -lsocket and -lnsl.  However on SGI IRIX 5,\ndnl these exist but are broken, so we use AC_SEARCH_LIBS which will only try\ndnl the library if the function isn't already available without it.\nAC_SEARCH_LIBS(t_open, nsl) # SVR4\nAC_SEARCH_LIBS(gethostbyname, inet) # Sequent\nAC_SEARCH_LIBS(socket, socket) # SVR4 sockets\n\nAC_CHECK_LIB(swill, swill_init, [SWIGLIBS=\"-lswill $LIBS\" SWILL=\"-DSWIG_SWILL\"])\nAC_SUBST(SWIGLIBS)\nAC_SUBST(SWILL)\n\n# check for --with-libm=...\nAC_SUBST(LIBM)\nLIBM=-lm\nAC_ARG_WITH(libm, [  --with-libm=STRING      math library], [\nif test \"$withval\" != yes\nthen LIBM=$withval\nelse AC_MSG_ERROR([proper usage is --with-libm=STRING])\nfi])\nAC_CHECK_LIB(ieee, main, [LIBM=\"-lieee $LIBM\"])\nAC_CHECK_LIB(crypt,crypt, [LIBCRYPT=\"-lcrypt\"])\nAC_SUBST(LIBCRYPT)\n\n# check for --with-libc=...\nAC_SUBST(LIBC)\nAC_ARG_WITH(libc, [  --with-libc=STRING      C library], [\nif test \"$withval\" != yes\nthen LIBC=$withval\nelse AC_MSG_ERROR([proper usage is --with-libc=STRING])\nfi])\n\n#--------------------------------------------------------------------\n#\tLocate the X11 header files and the X11 library archive.  Try\n#\tthe ac_path_x macro first, but if it doesn't find the X stuff\n#\t(e.g. because there's no xmkmf program) then check through\n#\ta list of possible directories.  Under some conditions the\n#\tautoconf macro will return an include directory that contains\n#\tno include files, so double-check its result just to be safe.\n#--------------------------------------------------------------------\n\nAC_PATH_X\nnot_really_there=\"\"\nif test \"$no_x\" = \"\"; then\n    if test \"$x_includes\" = \"\"; then\n\tAC_TRY_CPP([#include <X11/XIntrinsic.h>], , not_really_there=\"yes\")\n    else\n\tif test ! -r $x_includes/X11/Intrinsic.h; then\n\t    not_really_there=\"yes\"\n\tfi\n    fi\nfi\nif test \"$no_x\" = \"yes\" -o \"$not_really_there\" = \"yes\"; then\n    AC_MSG_CHECKING(for X11 header files)\n    XINCLUDES=\"# no special path needed\"\n    AC_TRY_CPP([#include <X11/Intrinsic.h>], , XINCLUDES=\"\")\n    if test -z \"$XINCLUDES\"; then\n        dirs=\"/usr/unsupported/include /usr/local/include /usr/X386/include /usr/include/X11R4 /usr/X11R5/include /usr/include/X11R5 /usr/openwin/include /usr/X11/include /usr/sww/include /usr/X11R6/include /usr/include/X11R6\"\n        for i in $dirs ; do\n\t    if test -r $i/X11/Intrinsic.h; then\n\t        XINCLUDES=\" -I$i\"\n\t\tbreak\n\t    fi\n        done\n    fi\n    AC_MSG_RESULT($XINCLUDES)\nelse\n    if test \"$x_includes\" != \"\"; then\n\tXINCLUDES=-I$x_includes\n    else\n\tXINCLUDES=\"# no special path needed\"\n    fi\nfi\nif test -z \"$XINCLUDES\"; then\n    AC_MSG_RESULT(couldn't find any!)\n    XINCLUDES=\"# no include files found\"\nfi\n\nif test \"$no_x\" = yes; then\n    AC_MSG_CHECKING(for X11 libraries)\n    XLIBSW=\n    dirs=\"/usr/unsupported/lib /usr/local/lib /usr/X386/lib /usr/lib/X11R4 /usr/X11R5/lib /usr/lib/X11R5 /usr/X11R6/lib /usr/lib/X11R6 /usr/openwin/lib /usr/X11/lib /usr/sww/X11/lib\"\n    for i in $dirs ; do\n\tif test -r $i/libX11.a -o -r $i/libX11.so -o -r $i/libX11.sl; then\n\t    AC_MSG_RESULT($i)\n\t    XLIBSW=\"-L$i -lX11\"\n\t    break\n\tfi\n    done\nelse\n    if test \"$x_libraries\" = \"\"; then\n\tXLIBSW=-lX11\n    else\n\tXLIBSW=\"-L$x_libraries -lX11\"\n    fi\nfi\nif test -z \"$XLIBSW\" ; then\n    AC_CHECK_LIB(Xwindow, XCreateWindow, XLIBSW=-lXwindow)\nfi\nif test -z \"$XLIBSW\" ; then\n    AC_MSG_RESULT(couldn't find any!  Using -lX11.)\n    XLIBSW=-lX11\nfi\n\nAC_SUBST(XINCLUDES)\nAC_SUBST(XLIBSW)\n\nAC_ARG_WITH(alllang, AS_HELP_STRING([--without-alllang], [Disable all languages]), with_alllang=\"$withval\")\n\n#--------------------------------------------------------------------\n# Look for Tcl\n#--------------------------------------------------------------------\n\nTCLINCLUDE=\nTCLLIB=\nTCLPACKAGE=\n\nAC_ARG_WITH(tclconfig, AS_HELP_STRING([--without-tcl], [Disable Tcl])\nAS_HELP_STRING([--with-tclconfig=path], [Set location of tclConfig.sh]), [with_tclconfig=\"$withval\"], [with_tclconfig=])\nAC_ARG_WITH(tcl,\n [  --with-tcl=path         Set location of Tcl package],[\n\tTCLPACKAGE=\"$withval\"], [TCLPACKAGE=yes])\nAC_ARG_WITH(tclincl,[  --with-tclincl=path     Set location of Tcl include directory],[\n\tTCLINCLUDE=\"$ISYSTEM$withval\"], [TCLINCLUDE=])\nAC_ARG_WITH(tcllib,[  --with-tcllib=path      Set location of Tcl library directory],[\n\tTCLLIB=\"-L$withval\"], [TCLLIB=])\n\n# First, check for \"--without-tcl\" or \"--with-tcl=no\".\nif test x\"${TCLPACKAGE}\" = xno -o x\"${with_alllang}\" = xno; then\nAC_MSG_NOTICE([Disabling Tcl])\nelse\nAC_MSG_CHECKING([for Tcl configuration])\n# First check to see if --with-tclconfig was specified.\nif test x\"${with_tclconfig}\" != x ; then\n   if test -f \"${with_tclconfig}/tclConfig.sh\" ; then\n      TCLCONFIG=`(cd ${with_tclconfig}; pwd)`\n   else\n      AC_MSG_ERROR([${with_tcl} directory doesn't contain tclConfig.sh])\n   fi\nfi\n# check in a few common install locations\nif test x\"${TCLCONFIG}\" = x ; then\n    for i in `ls -d /usr/lib/ 2>/dev/null` \\\n\t     `ls -d -r /usr/lib/tcl*/ 2>/dev/null` \\\n\t     `ls -d /usr/local/lib/ 2>/dev/null` \\\n\t     `ls -d -r /usr/local/lib/tcl*/ 2>/dev/null` ; do\n\tif test -f $i\"tclConfig.sh\" ; then\n\t    TCLCONFIG=`(cd $i; pwd)`\n\t    break\n\tfi\n    done\nfi\nif test x\"${TCLCONFIG}\" = x ; then\n    AC_MSG_RESULT(no)\nelse\n    AC_MSG_RESULT(found $TCLCONFIG/tclConfig.sh)\n    . $TCLCONFIG/tclConfig.sh\n    if test -z \"$TCLINCLUDE\"; then\n        TCLINCLUDE=`echo $TCL_INCLUDE_SPEC | sed \"s/-I/$ISYSTEM/\"`\n    fi\n    if test -z \"$TCLLIB\"; then\n        TCLLIB=$TCL_LIB_SPEC\n    fi\nfi\n\nif test -z \"$TCLINCLUDE\"; then\n   if test \"x$TCLPACKAGE\" != xyes; then\n\tTCLINCLUDE=\"$ISYSTEM$TCLPACKAGE/include\"\n   fi\nfi\n\nif test -z \"$TCLLIB\"; then\n   if test \"x$TCLPACKAGE\" != xyes; then\n\tTCLLIB=\"-L$TCLPACKAGE/lib -ltcl\"\n   fi\nfi\n\nAC_MSG_CHECKING(for Tcl header files)\nif test -z \"$TCLINCLUDE\"; then\nAC_TRY_CPP([#include <tcl.h>], , TCLINCLUDE=\"\")\nif test -z \"$TCLINCLUDE\"; then\n\tdirs=\"/usr/local/include /usr/include /opt/local/include\"\n\tfor i in $dirs ; do\n\t\tif test -r $i/tcl.h; then\n\t\t\tAC_MSG_RESULT($i)\n\t\t\tTCLINCLUDE=\"$ISYSTEM$i\"\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\nif test -z \"$TCLINCLUDE\"; then\n    \tAC_MSG_RESULT(not found)\nfi\nelse\n        AC_MSG_RESULT($TCLINCLUDE)\nfi\n\nAC_MSG_CHECKING(for Tcl library)\nif test -z \"$TCLLIB\"; then\ndirs=\"/usr/local/lib /usr/lib /opt/local/lib\"\nfor i in $dirs ; do\n\tif test -r $i/libtcl.a; then\n\t    AC_MSG_RESULT($i)\n\t    TCLLIB=\"-L$i -ltcl\"\n\t    break\n\tfi\ndone\nif test -z \"$TCLLIB\"; then\n\tAC_MSG_RESULT(not found)\nfi\nelse\nAC_MSG_RESULT($TCLLIB)\nfi\n\n# Cygwin (Windows) needs the library for dynamic linking\ncase $host in\n*-*-cygwin* | *-*-mingw*) TCLDYNAMICLINKING=\"$TCLLIB\";;\n*)TCLDYNAMICLINKING=\"\";;\nesac\n\ncase $host in\n*-*-darwin*)\n    TCLLDSHARED='$(CC) -dynamiclib -undefined suppress -flat_namespace'\n    TCLCXXSHARED='$(CXX) -dynamiclib -undefined suppress -flat_namespace'\n    ;;\n*)\n    TCLLDSHARED='$(LDSHARED)'\n    TCLCXXSHARED='$(CXXSHARED)'\n    ;;\nesac\n\nfi\n\nAC_SUBST(TCLINCLUDE)\nAC_SUBST(TCLLIB)\nAC_SUBST(TCLDYNAMICLINKING)\nAC_SUBST(TCLLDSHARED)\nAC_SUBST(TCLCXXSHARED)\n\n#----------------------------------------------------------------\n# Look for Python\n#----------------------------------------------------------------\n\nPYINCLUDE=\nPYLIB=\nPYPACKAGE=\n\nAC_ARG_WITH(python, AS_HELP_STRING([--without-python], [Disable Python])\nAS_HELP_STRING([--with-python=path], [Set location of Python executable]),[ PYBIN=\"$withval\"], [PYBIN=yes])\n\n# First, check for \"--without-python\" or \"--with-python=no\".\nif test x\"${PYBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling Python])\nelse\n  # First figure out the name of the Python executable\n  if test \"x$PYBIN\" = xyes; then\n    AC_CHECK_PROGS(PYTHON, [python python2.8 python2.7 python2.6 python2.5 python2.4 python2.3 python2.2 python2.1 python2.0 python1.6 python1.5 python1.4])\n  else\n    PYTHON=\"$PYBIN\"\n  fi\n\n  if test -n \"$PYTHON\"; then\n    AC_MSG_CHECKING(for Python prefix)\n    PYPREFIX=`($PYTHON -c \"import sys; print sys.prefix\") 2>/dev/null`\n    AC_MSG_RESULT($PYPREFIX)\n    AC_MSG_CHECKING(for Python exec-prefix)\n    PYEPREFIX=`($PYTHON -c \"import sys; print sys.exec_prefix\") 2>/dev/null`\n    AC_MSG_RESULT($PYEPREFIX)\n\n\n    # Note: I could not think of a standard way to get the version string from different versions.\n    # This trick pulls it out of the file location for a standard library file.\n\n    AC_MSG_CHECKING(for Python version)\n\n    # Need to do this hack since autoconf replaces __file__ with the name of the configure file\n    filehack=\"file__\"\n    PYVERSION=`($PYTHON -c \"import string,operator,os.path; print operator.getitem(os.path.split(operator.getitem(os.path.split(string.__$filehack),0)),1)\")`\n    AC_MSG_RESULT($PYVERSION)\n\n    # Find the directory for libraries this is necessary to deal with\n    # platforms that can have apps built for multiple archs: e.g. x86_64\n    AC_MSG_CHECKING(for Python lib dir)\n    PYLIBDIR=`($PYTHON -c \"import sys; print sys.lib\") 2>/dev/null`\n    if test -z \"$PYLIBDIR\"; then\n      # Fedora patch Python to add sys.lib, for other distros we assume \"lib\".\n      PYLIBDIR=\"lib\"\n    fi\n    AC_MSG_RESULT($PYLIBDIR)\n\n    # Set the include directory\n\n    AC_MSG_CHECKING(for Python header files)\n    if test -r $PYPREFIX/include/$PYVERSION/Python.h; then\n      PYINCLUDE=\"-I$PYPREFIX/include/$PYVERSION -I$PYEPREFIX/$PYLIBDIR/$PYVERSION/config\"\n    fi\n    if test -z \"$PYINCLUDE\"; then\n      if test -r $PYPREFIX/include/Py/Python.h; then\n        PYINCLUDE=\"-I$PYPREFIX/include/Py -I$PYEPREFIX/$PYLIBDIR/python/lib\"\n      fi\n    fi\n    AC_MSG_RESULT($PYINCLUDE)\n\n    # Set the library directory blindly.   This probably won't work with older versions\n    AC_MSG_CHECKING(for Python library)\n    dirs=\"$PYVERSION/config $PYVERSION/$PYLIBDIR python/$PYLIBDIR\"\n    for i in $dirs; do\n      if test -d $PYEPREFIX/$PYLIBDIR/$i; then\n        PYLIB=\"$PYEPREFIX/$PYLIBDIR/$i\"\n        break\n      fi\n    done\n    if test -z \"$PYLIB\"; then\n      AC_MSG_RESULT(Not found)\n    else\n      AC_MSG_RESULT($PYLIB)\n    fi\n\n    PYLINK=\"-l$PYVERSION\"\n  fi\n\n  # Cygwin (Windows) needs the library for dynamic linking\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    PYTHONDYNAMICLINKING=\"-L$PYLIB $PYLINK\"\n    DEFS=\"-DUSE_DL_IMPORT $DEFS\"\n    ;;\n  *)PYTHONDYNAMICLINKING=\"\";;\n  esac\nfi\n\nAC_SUBST(PYINCLUDE)\nAC_SUBST(PYLIB)\nAC_SUBST(PYLINK)\nAC_SUBST(PYTHONDYNAMICLINKING)\n\n\n#----------------------------------------------------------------\n# Look for Python 3.x\n#----------------------------------------------------------------\n\n# mostly copy & pasted from \"Look for Python\" section,\n# did some trim, fix and rename\n\nPY3INCLUDE=\nPY3LIB=\nPY3PACKAGE=\n\nAC_ARG_WITH(python3, AS_HELP_STRING([--without-python3], [Disable Python 3.x support])\nAS_HELP_STRING([--with-python3=path], [Set location of Python 3.x executable]),[ PY3BIN=\"$withval\"], [PY3BIN=yes])\n\n# First, check for \"--without-python3\" or \"--with-python3=no\".\nif test x\"${PY3BIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling Python 3.x support])\nelse\n  for py_ver in 3 3.6 3.5 3.4 3.3 3.2 3.1 3.0; do\n    AC_CHECK_PROGS(PYTHON3, [python$py_ver])\n    if test -n \"$PYTHON3\"; then\n      AC_CHECK_PROGS(PY3CONFIG, [$PYTHON3-config])\n      if test -n \"$PY3CONFIG\"; then\n        break\n      fi\n    fi\n  done\n\n  if test -n \"$PYTHON3\" -a -n \"$PY3CONFIG\"; then\n    AC_MSG_CHECKING([for Python 3.x prefix])\n    PY3PREFIX=`($PY3CONFIG --prefix) 2>/dev/null`\n    AC_MSG_RESULT($PY3PREFIX)\n    AC_MSG_CHECKING(for Python 3.x exec-prefix)\n    PY3EPREFIX=`($PY3CONFIG --exec-prefix) 2>/dev/null`\n    AC_MSG_RESULT($PY3EPREFIX)\n\n    # Note: I could not think of a standard way to get the version string from different versions.\n    # This trick pulls it out of the file location for a standard library file.\n\n    AC_MSG_CHECKING([for Python 3.x version])\n\n    # Need to do this hack since autoconf replaces __file__ with the name of the configure file\n    filehack=\"file__\"\n    PY3VERSION=`($PYTHON3 -c \"import string,operator,os.path; print(operator.getitem(os.path.split(operator.getitem(os.path.split(string.__$filehack),0)),1))\")`\n    AC_MSG_RESULT($PY3VERSION)\n\n    # Find the directory for libraries this is necessary to deal with\n    # platforms that can have apps built for multiple archs: e.g. x86_64\n    AC_MSG_CHECKING([for Python 3.x lib dir])\n    PY3LIBDIR=`($PYTHON3 -c \"import sys; print(sys.lib)\") 2>/dev/null`\n    if test -z \"$PY3LIBDIR\"; then\n      # some dists don't have sys.lib  so the best we can do is assume lib\n      PY3LIBDIR=\"lib\"\n    fi\n    AC_MSG_RESULT($PY3LIBDIR)\n\n    # Set the include directory\n\n    AC_MSG_CHECKING([for Python 3.x header files])\n    PY3INCLUDE=`($PY3CONFIG --includes) 2>/dev/null`\n    AC_MSG_RESULT($PY3INCLUDE)\n\n    # Set the library directory blindly.   This probably won't work with older versions\n    AC_MSG_CHECKING([for Python 3.x library])\n    dirs=\"$PY3VERSION/config $PY3VERSION/$PY3LIBDIR python/$PY3LIBDIR\"\n    for i in $dirs; do\n      if test -d $PY3EPREFIX/$PY3LIBDIR/$i; then\n        PY3LIB=\"$PY3EPREFIX/$PY3LIBDIR/$i\"\n        break\n      fi\n    done\n    if test -z \"$PY3LIB\"; then\n      AC_MSG_RESULT([Not found])\n    else\n      AC_MSG_RESULT($PY3LIB)\n    fi\n\n    PY3LINK=\"-l$PY3VERSION\"\n  fi\n\n  # Cygwin (Windows) needs the library for dynamic linking\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    PYTHON3DYNAMICLINKING=\"-L$PYLIB $PY3LINK\"\n    DEFS=\"-DUSE_DL_IMPORT $DEFS\"\n    ;;\n  *)PYTHON3DYNAMICLINKING=\"\";;\n  esac\nfi\n\nAC_SUBST(PY3INCLUDE)\nAC_SUBST(PY3LIB)\nAC_SUBST(PY3LINK)\nAC_SUBST(PYTHON3DYNAMICLINKING)\n\n\n#----------------------------------------------------------------\n# Look for Perl5\n#----------------------------------------------------------------\n\nPERLBIN=\n\nAC_ARG_WITH(perl5, AS_HELP_STRING([--without-perl5], [Disable Perl5])\nAS_HELP_STRING([--with-perl5=path], [Set location of Perl5 executable]),[ PERLBIN=\"$withval\"], [PERLBIN=yes])\n\n# First, check for \"--without-perl5\" or \"--with-perl5=no\".\nif test x\"${PERLBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling Perl5])\nPERL=\nelse\n\n# First figure out what the name of Perl5 is\n\nif test \"x$PERLBIN\" = xyes; then\nAC_CHECK_PROGS(PERL, perl perl5.6.1 perl5.6.0 perl5.004 perl5.003 perl5.002 perl5.001 perl5 perl)\nelse\nPERL=\"$PERLBIN\"\nfi\n\n\n# This could probably be simplified as for all platforms and all versions of Perl the following apparently should be run to get the compilation options:\n# perl -MExtUtils::Embed -e ccopts\nAC_MSG_CHECKING(for Perl5 header files)\nif test -n \"$PERL\"; then\n\tPERL5DIR=`($PERL -e 'use Config; print $Config{archlib}, \"\\n\";') 2>/dev/null`\n\tif test -n \"$PERL5DIR\" ; then\n\t\tdirs=\"$PERL5DIR $PERL5DIR/CORE\"\n\t\tPERL5EXT=none\n\t\tfor i in $dirs; do\n\t\t\tif test -r $i/perl.h; then\n\t\t\t\tAC_MSG_RESULT($i)\n\t\t\t\tPERL5EXT=\"$i\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif test \"$PERL5EXT\" = none; then\n\t\t\tPERL5EXT=\"$PERL5DIR/CORE\"\n\t\t\tAC_MSG_RESULT(could not locate perl.h...using $PERL5EXT)\n\t\tfi\n\n\t\tAC_MSG_CHECKING(for Perl5 library)\n\t\tPERL5LIB=`($PERL -e 'use Config; $_=$Config{libperl}; s/^lib//; s/$Config{_a}$//; s/\\.$Config{so}.*//; print $_, \"\\n\"') 2>/dev/null`\n\t\tif test -z \"$PERL5LIB\" ; then\n\t\t\tAC_MSG_RESULT(not found)\n\t\telse\n\t\t\tAC_MSG_RESULT($PERL5LIB)\n\t\tfi\n    AC_MSG_CHECKING(for Perl5 ccflags)\n \t\tPERL5CCFLAGS=`($PERL -e 'use Config; print $Config{ccflags}, \"\\n\"' | sed \"s/-Wdeclaration-after-statement//\" | sed \"s/-I/$ISYSTEM/\") 2>/dev/null`\n \t\tif test -z \"$PERL5CCFLAGS\" ; then\n \t\t\tAC_MSG_RESULT(not found)\n \t\telse\n \t\t\tAC_MSG_RESULT($PERL5CCFLAGS)\n \t\tfi\n    AC_MSG_CHECKING(for Perl5 ccdlflags)\n    PERL5CCDLFLAGS=`($PERL -e 'use Config; print $Config{ccdlflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5CCDLFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5CCDLFLAGS)\n    fi\n    AC_MSG_CHECKING(for Perl5 cccdlflags)\n    PERL5CCCDLFLAGS=`($PERL -e 'use Config; print $Config{cccdlflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5CCCDLFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5CCCDLFLAGS)\n    fi\n    AC_MSG_CHECKING(for Perl5 ldflags)\n    PERL5LDFLAGS=`($PERL -e 'use Config; print $Config{ldflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5LDFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5LDFLAGS)\n    fi\n\telse\n\t\tAC_MSG_RESULT(unable to determine perl5 configuration)\n\t\tPERL5EXT=$PERL5DIR\n\tfi\nelse\n       \tAC_MSG_RESULT(could not figure out how to run perl5)\nfi\n\n# Cygwin (Windows) needs the library for dynamic linking\ncase $host in\n*-*-cygwin* | *-*-mingw*) PERL5DYNAMICLINKING=\"-L$PERL5EXT -l$PERL5LIB\";;\n*)PERL5DYNAMICLINKING=\"\";;\nesac\nfi\n\nAC_SUBST(PERL)\nAC_SUBST(PERL5EXT)\nAC_SUBST(PERL5DYNAMICLINKING)\nAC_SUBST(PERL5LIB)\nAC_SUBST(PERL5CCFLAGS)\nAC_SUBST(PERL5CCDLFLAGS)\nAC_SUBST(PERL5CCCDLFLAGS)\nAC_SUBST(PERL5LDFLAGS)\n\n#----------------------------------------------------------------\n# Look for Octave\n#----------------------------------------------------------------\n\nOCTAVEBIN=\nOCTAVE_SO=.oct\n\nAC_ARG_WITH(octave, AS_HELP_STRING([--without-octave], [Disable Octave])\nAS_HELP_STRING([--with-octave=path], [Set location of Octave executable]),[OCTAVEBIN=\"$withval\"], [OCTAVEBIN=yes])\n\n# First, check for \"--without-octave\" or \"--with-octave=no\".\nif test x\"${OCTAVEBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n   AC_MSG_NOTICE([Disabling Octave])\n   OCTAVE=\n\n# First figure out what the name of Octave is\nelif test \"x$OCTAVEBIN\" = xyes; then\n   AC_PATH_PROG(OCTAVE, [octave])\n\nelse\n   OCTAVE=\"$OCTAVEBIN\"\nfi\n\nif test -n \"$OCTAVE\"; then\n   AC_MSG_CHECKING([for mkoctfile])\n   mkoctfile=\"`dirname ${OCTAVE}`/mkoctfile\"\n   AS_IF([test -x \"${mkoctfile}\"],[\n      AC_MSG_RESULT([${mkoctfile}])\n   ],[\n      AC_MSG_RESULT([not found, disabling Octave])\n      OCTAVE=\n   ])\nfi\nif test -n \"$OCTAVE\"; then\n   AC_MSG_CHECKING([for Octave preprocessor flags])\n   OCTAVE_CPPFLAGS=\n   for n in CPPFLAGS INCFLAGS; do\n     OCTAVE_CPPFLAGS=\"${OCTAVE_CPPFLAGS} \"`${mkoctfile} -p $n`\n   done\n   AC_MSG_RESULT([$OCTAVE_CPPFLAGS])\n   AC_MSG_CHECKING([for Octave compiler flags])\n   OCTAVE_CXXFLAGS=\n   for n in ALL_CXXFLAGS; do\n     OCTAVE_CXXFLAGS=\"${OCTAVE_CXXFLAGS} \"`${mkoctfile} -p $n`\n   done\n   AC_MSG_RESULT([$OCTAVE_CXXFLAGS])\n   AC_MSG_CHECKING([for Octave linker flags])\n   OCTAVE_LDFLAGS=\n   for n in RDYNAMIC_FLAG LFLAGS RLD_FLAG OCTAVE_LIBS LIBS; do\n     OCTAVE_LDFLAGS=\"${OCTAVE_LDFLAGS} \"`${mkoctfile} -p $n`\n   done\n   AC_MSG_RESULT([$OCTAVE_LDFLAGS])\n   for octave_opt in --silent --norc --no-history --no-window-system; do\n      AC_MSG_CHECKING([if Octave option '${octave_opt}' is supported])\n      octave_out=`${OCTAVE} ${octave_opt} /dev/null 2>&1 | sed -n '1{/unrecognized/p}'`\n      AS_IF([test \"x${octave_out}\" = x],[\n         AC_MSG_RESULT([yes])\n         OCTAVE=\"${OCTAVE} ${octave_opt}\"\n      ],[\n         AC_MSG_RESULT([no])\n      ])\n   done\nfi\n\nAC_SUBST(OCTAVE)\nAC_SUBST(OCTAVE_SO)\nAC_SUBST(OCTAVE_CPPFLAGS)\nAC_SUBST(OCTAVE_CXXFLAGS)\nAC_SUBST(OCTAVE_LDFLAGS)\n\n#----------------------------------------------------------------\n# Look for java\n#----------------------------------------------------------------\n\nAC_ARG_WITH(java, AS_HELP_STRING([--without-java], [Disable Java])\nAS_HELP_STRING([--with-java=path], [Set location of java executable]),[JAVABIN=\"$withval\"], [JAVABIN=yes])\nAC_ARG_WITH(javac, [  --with-javac=path       Set location of javac executable],[JAVACBIN=\"$withval\"], [JAVACBIN=])\n\n# First, check for \"--without-java\" or \"--with-java=no\".\nif test x\"${JAVABIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling Java])\nJAVA=\nelse\n\nif test \"x$JAVABIN\" = xyes; then\n  AC_CHECK_PROGS(JAVA, java kaffe guavac)\nelse\n  JAVA=\"$JAVABIN\"\nfi\n\nif test -z \"$JAVACBIN\"; then\n  AC_CHECK_PROGS(JAVAC, javac)\nelse\n  JAVAC=\"$JAVACBIN\"\nfi\n\nAC_MSG_CHECKING(for java include file jni.h)\nAC_ARG_WITH(javaincl, [  --with-javaincl=path    Set location of Java include directory], [JAVAINCDIR=\"$withval\"], [JAVAINCDIR=])\n\nif test -z \"$JAVAINCDIR\" ; then\n  JAVAINCDIR=\"/usr/j2sdk*/include /usr/local/j2sdk*/include /usr/jdk*/include /usr/local/jdk*/include /opt/j2sdk*/include /opt/jdk*/include /usr/java/include /usr/java/j2sdk*/include /usr/java/jdk*/include /usr/local/java/include /opt/java/include /usr/include/java /usr/local/include/java /usr/lib/java/include /usr/lib/jvm/java*/include /usr/include/kaffe /usr/local/include/kaffe /usr/include\"\n\n  # Add in default installation directory on Windows for Cygwin\n  case $host in\n  *-*-cygwin* | *-*-mingw*) JAVAINCDIR=\"c:/Program*Files/Java/jdk*/include d:/Program*Files/Java/jdk*/include c:/j2sdk*/include d:/j2sdk*/include c:/jdk*/include d:/jdk*/include $JAVAINCDIR\";;\n  *-*-darwin*) JAVAINCDIR=\"/System/Library/Frameworks/JavaVM.framework/Headers $JAVAINCDIR\";;\n  *);;\n  esac\nfi\n\nJAVAINC=\"\"\nfor d in $JAVAINCDIR ; do\n  if test -r \"$d/jni.h\" ; then\n    AC_MSG_RESULT($d)\n    JAVAINCDIR=$d\n    JAVAINC=-I\\\"$d\\\"\n    break\n  fi\ndone\n\nif test \"$JAVAINC\" = \"\" ; then\n  AC_MSG_RESULT(not found)\nelse\n  # now look for <arch>/jni_md.h\n  AC_MSG_CHECKING(for java include file jni_md.h)\n  JAVAMDDIR=`find \"$JAVAINCDIR\" -follow -name jni_md.h -print`\n  if test \"$JAVAMDDIR\" = \"\" ; then\n    AC_MSG_RESULT(not found)\n  else\n    JAVAMDDIR=`dirname \"$JAVAMDDIR\" | tail -1`\n    JAVAINC=\"${JAVAINC} -I\\\"$JAVAMDDIR\\\"\"\n    AC_MSG_RESULT($JAVAMDDIR)\n  fi\nfi\n\n# java.exe on Cygwin requires the Windows standard (Pascal) calling convention as it is a normal Windows executable and not a Cygwin built executable\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n    if test \"$GCC\" = yes; then\n        JAVADYNAMICLINKING=\" -mno-cygwin -mthreads -Wl,--add-stdcall-alias\"\n        JAVACFLAGS=\"-mno-cygwin -mthreads\"\n    else\n        JAVADYNAMICLINKING=\"\"\n        JAVACFLAGS=\"\"\n    fi ;;\n*-*-darwin*)\n        JAVADYNAMICLINKING=\"-dynamiclib -framework JavaVM\"\n        JAVACFLAGS=\"\"\n        ;;\n*)\n        JAVADYNAMICLINKING=\"\"\n        JAVACFLAGS=\"\"\n        ;;\nesac\n\n# Java on Windows platforms including Cygwin doesn't use libname.dll, rather name.dll when loading dlls\ncase $host in\n*-*-cygwin* | *-*-mingw*) JAVALIBRARYPREFIX=\"\";;\n*)JAVALIBRARYPREFIX=\"lib\";;\nesac\n\n# Java on Mac OS X tweaks\ncase $host in\n*-*-darwin*)\n    JAVASO=\".jnilib\"\n    JAVALDSHARED='$(CC)'\n    JAVACXXSHARED='$(CXX)'\n    ;;\n*)\n    JAVASO=$SO\n    JAVALDSHARED='$(LDSHARED)'\n    JAVACXXSHARED='$(CXXSHARED)'\n    ;;\nesac\nfi\n\nAC_SUBST(JAVA)\nAC_SUBST(JAVAC)\nAC_SUBST(JAVAINC)\nAC_SUBST(JAVADYNAMICLINKING)\nAC_SUBST(JAVALIBRARYPREFIX)\nAC_SUBST(JAVASO)\nAC_SUBST(JAVALDSHARED)\nAC_SUBST(JAVACXXSHARED)\nAC_SUBST(JAVACFLAGS)\n\n#----------------------------------------------------------------\n# Look for gcj\n#----------------------------------------------------------------\n\nAC_ARG_WITH(gcj, AS_HELP_STRING([--without-gcj], [Disable GCJ])\nAS_HELP_STRING([--with-gcj=path], [Set location of gcj executable]),[GCJBIN=\"$withval\"], [GCJBIN=yes])\nAC_ARG_WITH(gcjh, [  --with-gcjh=path        Set location of gcjh executable],[GCJHBIN=\"$withval\"], [GCJHBIN=])\n\n# First, check for \"--without-gcj\" or \"--with-gcj=no\".\nif test x\"${GCJBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling GCJ])\nelse\n  if test \"x$GCJBIN\" = xyes; then\n    AC_CHECK_PROGS(GCJ, gcj)\n  else\n    GCJ=\"$GCJBIN\"\n  fi\n\n  if test -z \"$GCJCBIN\"; then\n    AC_CHECK_PROGS(GCJH, gcjh)\n  else\n    GCJH=\"$GCJHBIN\"\n  fi\nfi\n\nAC_SUBST(GCJ)\nAC_SUBST(GCJH)\n\n#----------------------------------------------------------------\n# Look for Android\n#----------------------------------------------------------------\n\nAC_ARG_WITH(android, AS_HELP_STRING([--without-android], [Disable Android])\nAS_HELP_STRING([--with-android=path], [Set location of android executable]),[ANDROIDBIN=\"$withval\"], [ANDROIDBIN=yes])\nAC_ARG_WITH(adb, [  --with-adb=path       Set location of adb executable - Android Debug Bridge],[ADBBIN=\"$withval\"], [ADBBIN=])\nAC_ARG_WITH(ant, [  --with-ant=path       Set location of ant executable for Android],[ANTBIN=\"$withval\"], [ANTBIN=])\nAC_ARG_WITH(ndk-build, [  --with-ndk-build=path       Set location of Android ndk-build executable],[NDKBUILDBIN=\"$withval\"], [NDKBUILDBIN=])\n\n# First, check for \"--without-android\" or \"--with-android=no\".\nif test x\"${ANDROIDBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling Android])\n  ANDROID=\nelse\n  if test \"x$ANDROIDBIN\" = xyes; then\n    AC_CHECK_PROGS(ANDROID, android)\n  else\n    ANDROID=\"$ANDROIDBIN\"\n  fi\n\n  if test -z \"$ADBBIN\"; then\n    AC_CHECK_PROGS(ADB, adb)\n  else\n    ADB=\"$ADBBIN\"\n  fi\n\n  if test -z \"$ANTBIN\"; then\n    AC_CHECK_PROGS(ANT, ant)\n  else\n    ANT=\"$ANTBIN\"\n  fi\n\n  if test -z \"$NDKBUILDBIN\"; then\n    AC_CHECK_PROGS(NDKBUILD, ndk-build)\n  else\n    NDKBUILD=\"$NDKBUILDBIN\"\n  fi\nfi\n\nAC_SUBST(ANDROID)\nAC_SUBST(ADB)\nAC_SUBST(ANT)\nAC_SUBST(NDKBUILD)\n\n#----------------------------------------------------------------\n# Look for Guile\n#----------------------------------------------------------------\n\nGUILE=\nGUILE_CFLAGS=\nGUILE_LIBS=\n\nAC_ARG_WITH(guile-config, AS_HELP_STRING([--without-guile], [Disable Guile])\n\tAS_HELP_STRING([--with-guile-config=path], [Set location of guile-config]),[ GUILE_CONFIG=\"$withval\"], [GUILE_CONFIG=])\nAC_ARG_WITH(guile,[  --with-guile=path       Set location of Guile executable],[\n\tGUILE=\"$withval\"], [GUILE=yes])\nAC_ARG_WITH(guile-cflags,[  --with-guile-cflags=cflags   Set cflags required to compile against Guile],[\n\tGUILE_CFLAGS=\"$withval\"])\nAC_ARG_WITH(guile-libs,[  --with-guile-libs=ldflags    Set ldflags needed to link with Guile],[\n\tGUILE_LIBS=\"$withval\"])\n\n# First, check for \"--without-guile\" or \"--with-guile=no\".\nif test x\"${GUILE}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling Guile])\nelse\n  if test -z \"$GUILE_CONFIG\" ; then\n    AC_PATH_PROG(GUILE_CONFIG, guile-config)\n  fi\n  if test -n \"$GUILE_CONFIG\" ; then\n    if test x\"$GUILE\" = xyes; then\n      AC_MSG_CHECKING([for guile bindir])\n      guile_bindir=\"`$GUILE_CONFIG info bindir`\"\n      AC_MSG_RESULT([$guile_bindir])\n      GUILE=$guile_bindir/guile\n      if ! test -f \"$GUILE\" ; then\n\tGUILE=\n        AC_PATH_PROG(GUILE, guile)\n      fi\n    fi\n\n    if test -f \"$GUILE\" ; then\n      AC_MSG_CHECKING([for guile version])\n      guile_version=`$GUILE -c '(display (effective-version))'`\n      AC_MSG_RESULT([$guile_version])\n      AC_MSG_CHECKING([for guile version >= 1.8])\n      guile_good_version=`$GUILE -c '(if (>= (string->number (effective-version)) 1.8) (display \"yes\") (display \"no\"))'`\n      AC_MSG_RESULT([$guile_good_version])\n      if test x\"$guile_good_version\" != xyes ; then\n        GUILE=\n      fi\n    fi\n\n    if test -z \"$GUILE_CFLAGS\" ; then\n      AC_MSG_CHECKING([for guile compile flags])\n      GUILE_CFLAGS=\"`$GUILE_CONFIG compile`\" # Note that this can sometimes be empty\n      AC_MSG_RESULT([$GUILE_CFLAGS])\n    fi\n\n    if test -z \"$GUILE_LIBS\" ; then\n      AC_MSG_CHECKING([for guile link flags])\n      GUILE_LIBS=\"`$GUILE_CONFIG link`\"\n      AC_MSG_RESULT([$GUILE_LIBS])\n    fi\n  fi\nfi\n\nAC_SUBST(GUILE)\nAC_SUBST(GUILE_CFLAGS)\nAC_SUBST(GUILE_LIBS)\n\n#----------------------------------------------------------------\n# Look for MzScheme\n#----------------------------------------------------------------\n\nAC_ARG_WITH(mzscheme, AS_HELP_STRING([--without-mzscheme], [Disable MzScheme])\nAS_HELP_STRING([--with-mzscheme=path], [Set location of MzScheme executable]),[ MZSCHEMEBIN=\"$withval\"], [MZSCHEMEBIN=yes])\nAC_ARG_WITH(mzc, AS_HELP_STRING([--with-mzc=path], [Set location of MzScheme's mzc]), [ MZCBIN=\"$withval\"], [MZCBIN=])\n\n# First, check for \"--without-mzscheme\" or \"--with-mzscheme=no\".\nif test x\"${MZSCHEMEBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling MzScheme])\n  MZC=\nelse\n  if test \"x$MZSCHEMEBIN\" = xyes; then\n     AC_PATH_PROG(MZSCHEME, mzscheme)\n  else\n     MZSCHEME=\"$MZSCHEMEBIN\"\n  fi\n\n  if test -z \"$MZCBIN\"; then\n     AC_PATH_PROG(MZC, mzc)\n  fi\n\n  if test -n \"$MZSCHEME\"; then\n    AC_MSG_CHECKING(for MzScheme dynext object)\n    MZDYNOBJ=`$MZSCHEME --eval '(begin (require dynext/link) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (printf \"~a\" x)) (expand-for-link-variant (current-standard-link-libraries)))))' 2>/dev/null`\n    if test -f \"$MZDYNOBJ\"; then\n      :\n    else\n      # older versions (3.72 approx and earlier)\n      MZDYNOBJ=`$MZSCHEME --mute-banner --version --eval '(begin (require (lib \"link.ss\" \"dynext\")) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (display x) (display \" \")) ((current-make-standard-link-libraries)))) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (display x)) (expand-for-link-variant (current-standard-link-libraries)))))' 2>/dev/null`\n    fi\n    if test -f \"$MZDYNOBJ\"; then\n      AC_MSG_RESULT($MZDYNOBJ)\n    else\n      AC_MSG_RESULT(not found)\n      MZDYNOBJ=\"\"\n    fi\n  fi\nfi\nAC_SUBST(MZDYNOBJ)\n\n#----------------------------------------------------------------\n# Look for Ruby\n#----------------------------------------------------------------\n\nRUBYBIN=\n\nAC_ARG_WITH(ruby, AS_HELP_STRING([--without-ruby], [Disable Ruby])\nAS_HELP_STRING([--with-ruby=path], [Set location of Ruby executable]),[ RUBYBIN=\"$withval\"], [RUBYBIN=yes])\n\n# First, check for \"--without-ruby\" or \"--with-ruby=no\".\nif test x\"${RUBYBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling Ruby])\nRUBY=\nelse\n\n# First figure out what the name of Ruby is\n\nif test \"x$RUBYBIN\" = xyes; then\n\tAC_CHECK_PROGS(RUBY, ruby)\nelse\n\tRUBY=\"$RUBYBIN\"\nfi\n\nAC_MSG_CHECKING(for Ruby header files)\nif test -n \"$RUBY\"; then\n        # Try Ruby1.9 first\n        RUBYDIR=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"rubyhdrdir\"]] || $rubyhdrdir') 2>/dev/null`\n\tif test x\"$RUBYDIR\" = x\"\" || test x\"$RUBYDIR\" = x\"nil\"; then\n\t\tRUBYDIR=`($RUBY -rmkmf -e 'print Config::CONFIG[[\"archdir\"]] || $archdir') 2>/dev/null`\n        else\n                RUBYARCH=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"arch\"]] || $arch') 2>/dev/null`\n        fi\n\tif test x\"$RUBYDIR\" != x\"\"; then\n\t\tdirs=\"$RUBYDIR\"\n\t\tRUBYINCLUDE=none\n\t\tfor i in $dirs; do\n\t\t\tif test -r $i/ruby.h; then\n\t\t\t\tAC_MSG_RESULT($i)\n\t\t\t\tRUBYINCLUDE=\"-I$i\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif test x\"$RUBYARCH\" != x\"\"; then\n\t\t\tRUBYINCLUDE=\"-I$RUBYDIR -I$RUBYDIR/$RUBYARCH\"\n\t\tfi\n\t\tif test \"$RUBYINCLUDE\" = none; then\n\t\t\tRUBYINCLUDE=\"-I$RUBYDIR\"\n\t\t\tAC_MSG_RESULT(could not locate ruby.h...using $RUBYINCLUDE)\n\t\tfi\n\n\t\t# Find library and path for linking.\n\t\tAC_MSG_CHECKING(for Ruby library)\n\t\tRUBYLIB=\"\"\n\t\trb_libdir=`($RUBY -rrbconfig -e 'print Config::CONFIG[[\"libdir\"]]') 2>/dev/null`\n\t\trb_bindir=`($RUBY -rrbconfig -e 'print Config::CONFIG[[\"bindir\"]]') 2>/dev/null`\n\t\tdirs=\"$dirs $rb_libdir $rb_bindir\"\n\n        rb_libruby=`($RUBY -rrbconfig -e 'print Config::CONFIG[[\"LIBRUBY_A\"]]') 2>/dev/null`\n        RUBYLINK=`($RUBY -rrbconfig -e '\n            c = Config::CONFIG\n            if c.has_key? \"LIBRUBYARG_STATIC\" # 1.8.x\n                if c[[\"LIBRUBY\"]] == c[[\"LIBRUBY_A\"]]\n                    link = c[[\"LIBRUBYARG_STATIC\"]]\n                else\n                    link = c[[\"LIBRUBYARG_SHARED\"]]\n                end\n            else # 1.6.x\n                link = \"-l\" + c[[\"RUBY_INSTALL_NAME\"]]\n            end\n\n            # Get the target Ruby was built for\n            target = c[[\"target\"]]\n\n            if target == \"i386-pc-mswin32\"\n              # Need to change msvcrt-ruby*.lib to -lmsvcrt-ruby*\n              ext = File.extname(link)\n              # Get index that counts backwards from end of string\n              index = -1 - ext.size\n              # Strip off the extension\n              link = link.slice(0..index)\n              puts \"-l#{link}\"\n            else\n              puts link\n            end') 2>/dev/null`\n\n\t\tif test \"$rb_libruby\" != \"\"; then\n\t\t\tfor i in $dirs; do\n\t\t\t\tif (test -r $i/$rb_libruby;) then\n\t\t\t\t\tRUBYLIB=\"$i\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tif test \"$RUBYLIB\" = \"\"; then\n\t\t\tRUBYLIB=\"$RUBYDIR\"\n\t\t\tAC_MSG_RESULT(not found... using $RUBYDIR)\n\t\telse\n\t\t\tAC_MSG_RESULT($RUBYLINK in $RUBYLIB)\n\t\tfi\n\telse\n\t\tAC_MSG_RESULT(unable to determine ruby configuration)\n\t\tRUBYINCLUDE=\"-I$RUBYDIR\"\n\t\tRUBYLIB=\"$RUBYDIR\"\n\tfi\n\n\tcase $host in\n\t\t*-*-mingw*) ;; # do nothing, the default windows libraries are already included\n\t\t*) RUBYLINK=\"$RUBYLINK `($RUBY -rrbconfig -e 'print Config::CONFIG[[\"LIBS\"]]') 2>/dev/null`\";;\n\tesac\n\n\tRUBYCCDLFLAGS=`($RUBY -rrbconfig -e 'print Config::CONFIG[[\"CCDLFLAGS\"]]') 2>/dev/null`\n\tRUBYSO=.`($RUBY -rrbconfig -e 'print Config::CONFIG[[\"DLEXT\"]]') 2>/dev/null`\nelse\n\tAC_MSG_RESULT(could not figure out how to run ruby)\n\tRUBYINCLUDE=\"-I/usr/local/lib/ruby/1.4/arch\"\n\tRUBYLIB=\"/usr/local/lib/ruby/1.4/arch\"\n\tRUBYLINK=\"-lruby -lm\"\nfi\n\ncase $host in\n*-*-cygwin* | *-*-mingw*)\tRUBYDYNAMICLINKING=\"-L$RUBYLIB $RUBYLINK\";;\n*)\t\tRUBYDYNAMICLINKING=\"\";;\nesac\nfi\n\nAC_SUBST(RUBYINCLUDE)\nAC_SUBST(RUBYLIB)\nAC_SUBST(RUBYLINK)\nAC_SUBST(RUBYCCDLFLAGS)\nAC_SUBST(RUBYSO)\nAC_SUBST(RUBYDYNAMICLINKING)\n\n#-------------------------------------------------------------------------\n# Look for PHP\n#-------------------------------------------------------------------------\n\nPHPBIN=\n\nAC_ARG_WITH(php, AS_HELP_STRING([--without-php], [Disable PHP])\nAS_HELP_STRING([--with-php=path], [Set location of PHP executable]),[ PHPBIN=\"$withval\"], [PHPBIN=yes])\n\n# First, check for \"--without-php\" or \"--with-php=no\".\nif test x\"${PHPBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n    AC_MSG_NOTICE([Disabling PHP])\n    PHP=\nelse\n\n    if test \"x$PHPBIN\" = xyes; then\n      AC_CHECK_PROGS(PHP, [php5 php])\n    else\n      PHP=$PHPBIN\n    fi\n\n    AC_MSG_CHECKING(for PHP header files)\n    dnl /usr/bin/php5 -> /usr/bin/php-config5\n    case $PHP in\n      *5)\n\tPHPCONFIG=`echo \"$PHP\"|sed 's/5$/-config5/'` ;;\n      *)\n\tPHPCONFIG=$PHP-config ;;\n    esac\n    php_version=`$PHPCONFIG --version 2>/dev/null`\n    case $php_version in\n    5*)\n\tPHPINC=`$PHPCONFIG --includes 2>/dev/null`\n\tif test -n \"$PHPINC\"; then\n\t  AC_MSG_RESULT($PHPINC)\n\telse\n\t  AC_MSG_RESULT(not found)\n\tfi\n\t;;\n    *)\n\tAC_MSG_RESULT([found PHP $version, but only PHP 5 is supported]) ;;\n    esac\nfi\nAC_SUBST(PHP)\nAC_SUBST(PHPINC)\n\n#----------------------------------------------------------------\n# Look for ocaml\n#----------------------------------------------------------------\n\nAC_ARG_WITH(ocaml, AS_HELP_STRING([--without-ocaml], [Disable OCaml])\nAS_HELP_STRING([--with-ocaml=path], [Set location of ocaml executable]),[ OCAMLBIN=\"$withval\"], [OCAMLBIN=yes])\nAC_ARG_WITH(ocamlc,[  --with-ocamlc=path      Set location of ocamlc executable],[ OCAMLC=\"$withval\"], [OCAMLC=])\nAC_ARG_WITH(ocamldlgen,[  --with-ocamldlgen=path  Set location of ocamldlgen],[ OCAMLDLGEN=\"$withval\" ], [OCAMLDLGEN=])\nAC_ARG_WITH(ocamlfind,[  --with-ocamlfind=path   Set location of ocamlfind],[OCAMLFIND=\"$withval\"],[OCAMLFIND=])\nAC_ARG_WITH(ocamlmktop,[  --with-ocamlmktop=path  Set location of ocamlmktop executable],[ OCAMLMKTOP=\"$withval\"], [OCAMLMKTOP=])\n\n# First, check for \"--without-ocaml\" or \"--with-ocaml=no\".\nif test x\"${OCAMLBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n    AC_MSG_NOTICE([Disabling OCaml])\n    OCAMLBIN=\nelse\n\n    AC_MSG_CHECKING(for Ocaml DL load generator)\n    if test -z \"$OCAMLDLGEN\"; then\n\tAC_CHECK_PROGS(OCAMLDLGEN, ocamldlgen, :)\n    fi\n\n    AC_MSG_CHECKING(for Ocaml package tool)\n\tif test -z \"$OCAMLFIND\"; then\n\tAC_CHECK_PROGS(OCAMLFIND, ocamlfind, :)\n    fi\n\n    AC_MSG_CHECKING(for Ocaml compiler)\n\tif test -z \"$OCAMLC\"; then\n\tAC_CHECK_PROGS(OCAMLC, ocamlc, :)\n    fi\n\n    AC_MSG_CHECKING(for Ocaml interpreter)\n\tif test \"x$OCAMLBIN\" = xyes; then\n\tAC_CHECK_PROGS(OCAMLBIN, ocaml, :)\n    fi\n\n    AC_MSG_CHECKING(for Ocaml toplevel creator)\n    if test -z \"$OCAMLMKTOP\"; then\n\tAC_CHECK_PROGS(OCAMLMKTOP, ocamlmktop, :)\n    fi\n\n    OCAMLLOC=loc\n    if test \"$OCAMLC\" != \":\" ; then\n\tAC_MSG_CHECKING(for Ocaml header files)\n\tdirs=\"/usr/lib/ocaml/caml /usr/local/lib/ocaml/caml\"\n\tdir=\"`$OCAMLC -where 2>/dev/null`\"\n\tif test \"$dir\"; then\n\t\tdirs=\"$dir/caml $dirs\"\n\tfi\n\tfor i in $dirs; do\n\t\tif test -r $i/mlvalues.h; then\n\t\t\tAC_MSG_RESULT($i)\n\t\t\tOCAMLEXT=\"$i\"\n\t\t\tOCAMLINC=\"-I$OCAMLEXT\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\tif test -z \"$OCAMLINC\"; then\n\t\tAC_MSG_RESULT(not found)\n\tfi\n\n\tAC_MSG_CHECKING(for Ocaml version 3.08.2 or higher)\n\tOCAMLVER=`$OCAMLC -version | sed -e 's/.*version //g'`\n\tAC_COMPARE_VERSION([$OCAMLVER],[3.08.2],[:],[:],[OCAMLLOC=_loc])\n\tAC_MSG_RESULT($OCAMLVER)\n    fi\nfi # Disabling ocaml\n\nexport OCAMLLOC\nexport OCAMLVER\nexport OCAMLINC\nexport OCAMLBIN\nexport OCAMLC\nexport OCAMLDLGEN\nexport OCAMLFIND\nexport OCAMLMKTOP\n\nAC_SUBST(OCAMLLOC)\nAC_SUBST(OCAMLVER)\nAC_SUBST(OCAMLINC)\nAC_SUBST(OCAMLBIN)\nAC_SUBST(OCAMLC)\nAC_SUBST(OCAMLDLGEN)\nAC_SUBST(OCAMLFIND)\nAC_SUBST(OCAMLMKTOP)\n\n#----------------------------------------------------------------\n# Look for Pike\n#----------------------------------------------------------------\n\n# Identify the name of the Pike executable\n# Priority: configure option, automatic search\nPIKEBIN=\nAC_ARG_WITH(pike, AS_HELP_STRING([--without-pike], [Disable Pike])\nAS_HELP_STRING([--with-pike=path], [Set location of Pike executable]),[PIKEBIN=\"$withval\"], [PIKEBIN=yes])\n\n# First, check for \"--without-pike\" or \"--with-pike=no\".\nif test x\"${PIKEBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n    AC_MSG_NOTICE([Disabling Pike])\n    PIKEBIN=\nelse\n\nif test \"x$PIKEBIN\" = xyes; then\n\tAC_CHECK_PROGS(PIKE, pike pike7.8 pike7.6 pike7.4 pike7.2)\nelse\n\tPIKE=\"$PIKEBIN\"\nfi\n\n\n# Check for pike-config\n# Priority: configure option, guessed from $PIKE, search from list\nAC_ARG_WITH(pike-config, AS_HELP_STRING([--with-pike-config=path],\n  \t[Set location of pike-config script]),\n  [PIKECONFIG=\"$withval\"], [PIKECONFIG=\"\"])\n\nif test -z \"$PIKECONFIG\" -a -n \"$PIKE\"; then\n\tAC_CHECK_PROGS(PIKECONFIG, $PIKE-config pike-config \\\n\t\tpike7.6-config pike7.4-config pike7.2-config)\nfi\n\n# Check for a --with-pikeincl option to configure\n# Priority: configure option, info from $PIKECONFIG, guessed by pike script\nAC_ARG_WITH(pikeincl, AS_HELP_STRING([--with-pikeincl=path],\n\t[Set location of Pike include directory]),\n  [PIKEINCLUDE=\"-I$withval\"], [PIKEINCLUDE=])\n\nif test -n \"$PIKE\"; then\n      AC_MSG_CHECKING([for Pike header files])\n      if test -z \"$PIKEINCLUDE\" -a -n \"$PIKECONFIG\"; then\n        PIKEINCLUDE=`$PIKECONFIG --cflags`\n      fi\n      if test -z \"$PIKEINCLUDE\" -a -n \"$PIKE\"; then\n        PIKEINCLUDE=`$PIKE -x cflags`\n        if test -z \"$PIKEINCLUDE\"; then\n          PIKEPATH=`which $PIKE`\n          PIKEINCLUDE=`$PIKE Tools/check-include-path.pike $PIKEPATH`\n          PIKEINCLUDE=\"-I$PIKEINCLUDE\"\n        fi\n      fi\n\n      if test -z \"$PIKEINCLUDE\"; then\n        AC_MSG_RESULT(not found)\n      else\n        AC_MSG_RESULT($PIKEINCLUDE)\n      fi\nfi\nfi\n\nAC_SUBST(PIKEINCLUDE)\nAC_SUBST(PIKECCDLFLAGS)\t\tdnl XXX: where is this used/defined?\nAC_SUBST(PIKEDYNAMICLINKING)\tdnl XXX: where is this used/defined?\n\n#----------------------------------------------------------------\n# Look for CHICKEN\n#----------------------------------------------------------------\n\nCHICKEN=\nCHICKEN_CONFIG=\nCHICKENHOME=\nCHICKENOPTS=\nCHICKENLIB=\n\n\nAC_ARG_WITH(chicken, AS_HELP_STRING([--without-chicken], [Disable CHICKEN])\nAS_HELP_STRING([--with-chicken=path], [Set location of CHICKEN executable]),[ CHICKENBIN=\"$withval\"], [CHICKENBIN=yes])\n\n# First, check for \"--without-chicken\" or \"--with-chicken=no\".\nif test x\"${CHICKENBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling CHICKEN])\nelse\n\nif test \"x$CHICKENBIN\" = xyes; then\nAC_CHECK_PROGS(CHICKEN, chicken)\nelse\nCHICKEN=\"$CHICKENBIN\"\nfi\n\nAC_ARG_WITH(chickencsc,[  --with-chickencsc=path  Set location of csc executable],[ CHICKEN_CSC=\"$withval\"], [CHICKEN_CSC=])\n\nif test -z \"$CHICKEN_CSC\"; then\n  AC_CHECK_PROGS(CHICKEN_CSC, csc)\n  # Both the Microsoft C# compiler and chicken have an executable called csc, so check that this csc is really the chicken one\n  if test -n \"$CHICKEN_CSC\" ; then\n    AC_MSG_CHECKING(whether csc is the chicken compiler)\n    $CHICKEN_CSC -version 2>/dev/null | grep \"chicken\" > /dev/null || CHICKEN_CSC=\"\"\n    if test -z \"$CHICKEN_CSC\"; then\n      AC_MSG_RESULT(no)\n    else\n      AC_MSG_RESULT(yes)\n    fi\n  fi\nfi\n\nAC_ARG_WITH(chickencsi,[  --with-chickencsi=path  Set location of csi executable],[ CHICKEN_CSI=\"$withval\"], [CHICKEN_CSI=])\n\nif test -z \"$CHICKEN_CSI\"; then\nAC_CHECK_PROGS(CHICKEN_CSI, csi)\nfi\n\nif test -n \"$CHICKEN_CSC\" ; then\n\n  AC_ARG_WITH(chickenopts,[  --with-chickenopts=args Set compiler options for static CHICKEN generated code],[\n\tCHICKENOPTS=\"$withval\"], [CHICKENOPTS=])\n  AC_ARG_WITH(chickensharedlib,[  --with-chickensharedlib=args    Set linker options for shared CHICKEN generated code],[\n\tCHICKENSHAREDLIB=\"$withval\"], [CHICKENSHAREDLIB=])\n  AC_ARG_WITH(chickenlib,[  --with-chickenlib=args  Set linker options for static CHICKEN generated code],[\n\tCHICKENLIB=\"$withval\"], [CHICKENLIB=])\n\n  AC_MSG_CHECKING(for compiler options for static CHICKEN generated code)\n  if test -z \"$CHICKENOPTS\"; then\n        CHICKENOPTS=\"`$CHICKEN_CSC -cflags`\"\n  else\n        CHICKENOPTS=\"`$CHICKEN_CSC -cflags` $CHICKENOPTS\"\n  fi\n  if test -z \"$CHICKENOPTS\"; then\n        AC_MSG_RESULT(not found)\n  else\n        AC_MSG_RESULT($CHICKENOPTS)\n  fi\n\n  AC_MSG_CHECKING(for linker options for shared CHICKEN generated code)\n  if test -z \"$CHICKENSHAREDLIB\"; then\n        CHICKENSHAREDLIB=\"`$CHICKEN_CSC -shared -libs`\"\n  else\n        CHICKENSHAREDLIB=\"`$CHICKEN_CSC -shared -libs` $CHICKENSHAREDLIB\"\n  fi\n  if test -z \"$CHICKENSHAREDLIB\"; then\n  \tAC_MSG_RESULT(not found)\n  else\n        AC_MSG_RESULT($CHICKENSHAREDLIB)\n  fi\n\n  AC_MSG_CHECKING(for linker options for static CHICKEN generated code)\n  if test -z \"$CHICKENLIB\"; then\n        CHICKENLIB=\"`$CHICKEN_CSC -libs`\"\n  else\n        CHICKENLIB=\"`$CHICKEN_CSC -libs` $CHICKENLIB\"\n  fi\n  if test -z \"$CHICKENLIB\"; then\n  \tAC_MSG_RESULT(not found)\n  else\n        AC_MSG_RESULT($CHICKENLIB)\n  fi\n\nfi # have CHICKEN_CONFIG\nfi # Check for --without-chicken\n\nAC_SUBST(CHICKEN)\nAC_SUBST(CHICKEN_CSC)\nAC_SUBST(CHICKEN_CSI)\nAC_SUBST(CHICKENOPTS)\nAC_SUBST(CHICKENLIB)\nAC_SUBST(CHICKENSHAREDLIB)\n\n#----------------------------------------------------------------\n# Look for C#\n#----------------------------------------------------------------\n\nAC_ARG_WITH(csharp, AS_HELP_STRING([--without-csharp], [Disable CSharp]), [with_csharp=\"$withval\"], [with_csharp=yes])\nAC_ARG_WITH(cil-interpreter, [  --with-cil-interpreter=path     Set location of CIL interpreter for CSharp],[CSHARPBIN=\"$withval\"], [CSHARPBIN=])\nAC_ARG_WITH(csharp-compiler, [  --with-csharp-compiler=path     Set location of CSharp compiler],[CSHARPCOMPILERBIN=\"$withval\"], [CSHARPCOMPILERBIN=])\n\n# First, check for \"--without-csharp\" or \"--with-csharp=no\".\nif test x\"${with_csharp}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling CSharp])\nCSHARPCOMPILER=\nelse\n\nif test -z \"$CSHARPCOMPILERBIN\" ; then\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    # prefer Mono gmcs (.NET 2.0) over mcs (.NET 1.1) - note mcs-1.2.3 has major pinvoke bug\n    AC_CHECK_PROGS(CSHARPCOMPILER, csc mono-csc gmcs mcs cscc)\n    if test -n \"$CSHARPCOMPILER\" && test \"$CSHARPCOMPILER\" = \"csc\" ; then\n      AC_MSG_CHECKING(whether csc is the Microsoft CSharp compiler)\n      csc 2>/dev/null | grep \"C#\" > /dev/null || CSHARPCOMPILER=\"\"\n      if test -z \"$CSHARPCOMPILER\" ; then\n        AC_MSG_RESULT(no)\n        AC_CHECK_PROGS(CSHARPCOMPILER, mono-csc gmcs mcs cscc)\n      else\n        AC_MSG_RESULT(yes)\n      fi\n    fi\n    ;;\n  *)AC_CHECK_PROGS(CSHARPCOMPILER, mono-csc gmcs mcs cscc);;\n  esac\nelse\n  CSHARPCOMPILER=\"$CSHARPCOMPILERBIN\"\nfi\n\nCSHARPPATHSEPARATOR=\"/\"\nCSHARPCYGPATH_W=echo\nif test -z \"$CSHARPBIN\" ; then\n  CSHARPCILINTERPRETER=\"\"\n  CSHARPCILINTERPRETER_FLAGS=\"\"\n  if test \"cscc\" = \"$CSHARPCOMPILER\" ; then\n    AC_CHECK_PROGS(CSHARPCILINTERPRETER, ilrun)\n  else\n    if test \"mcs\" = \"$CSHARPCOMPILER\"; then\n      # Check that mcs is the C# compiler and not the Unix mcs utility by examining the output of 'mcs --version'\n      # The Mono compiler should emit: Mono C# compiler version a.b.c.d\n      csharp_version_raw=`(mcs --version) 2>/dev/null`\n      csharp_version_searched=`(mcs --version | sed -e \"/C#/b\" -e \"/Mono/b\" -e d) 2>/dev/null` # return string if contains 'Mono' or 'C#'\n      CSHARPCOMPILER=\"\"\n      if test -n \"$csharp_version_raw\" ; then\n        if test \"$csharp_version_raw\" = \"$csharp_version_searched\" ; then\n          CSHARPCOMPILER=\"mcs\"\n        fi\n      fi\n      if test \"mcs\" != \"$CSHARPCOMPILER\" ; then\n        echo \"mcs is not a working Mono C# compiler\"\n      fi\n    fi\n    if test \"mcs\" = \"$CSHARPCOMPILER\" || test \"gmcs\" = \"$CSHARPCOMPILER\"; then\n        AC_CHECK_PROGS(CSHARPCILINTERPRETER, mono) # Mono JIT\n        CSHARPCILINTERPRETER_FLAGS=\"--debug\"\n    else\n      if test \"csc\" = \"$CSHARPCOMPILER\"; then\n          CSHARPPATHSEPARATOR=\"\\\\\\\\\"\n          CSHARPCYGPATH_W='cygpath -w'\n      fi\n    fi\n  fi\nelse\n  CSHARPCILINTERPRETER=\"$CSHARPBIN\"\nfi\n\n# Cygwin requires the Windows standard (Pascal) calling convention as it is a Windows executable and not a Cygwin built executable\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n    if test \"$GCC\" = yes; then\n        CSHARPDYNAMICLINKING=\" -mno-cygwin -mthreads -Wl,--add-stdcall-alias\"\n        CSHARPCFLAGS=\"-mno-cygwin -mthreads\"\n    else\n        CSHARPDYNAMICLINKING=\"\"\n        CSHARPCFLAGS=\"\"\n    fi ;;\n*)\n        CSHARPDYNAMICLINKING=\"\"\n        CSHARPCFLAGS=\"\"\n        ;;\nesac\n\n# CSharp on Windows platforms including Cygwin doesn't use libname.dll, rather name.dll when loading dlls\ncase $host in\n*-*-cygwin* | *-*-mingw*) CSHARPLIBRARYPREFIX=\"\";;\n*)CSHARPLIBRARYPREFIX=\"lib\";;\nesac\n\n# C#/Mono on Mac OS X tweaks\ncase $host in\n*-*-darwin*)\n    CSHARPSO=\".so\"\n    ;;\n*)\n    CSHARPSO=$SO\n    ;;\nesac\nfi\n\nAC_SUBST(CSHARPCILINTERPRETER_FLAGS)\nAC_SUBST(CSHARPCILINTERPRETER)\nAC_SUBST(CSHARPPATHSEPARATOR)\nAC_SUBST(CSHARPCYGPATH_W)\nAC_SUBST(CSHARPCOMPILER)\nAC_SUBST(CSHARPDYNAMICLINKING)\nAC_SUBST(CSHARPLIBRARYPREFIX) # Is this going to be used?\nAC_SUBST(CSHARPCFLAGS)\nAC_SUBST(CSHARPSO)\n\n#----------------------------------------------------------------\n# Look for Lua\n#----------------------------------------------------------------\n\nLUABIN=\nLUAINCLUDE=\nLUALIB=\nLUADYNAMICLOADLIB=\nLUAFLAGS=\nLUALINK=\n# note: if LUABIN is empty then lua tests will not be done\n# LUABIN will be cleared if certain dependencies cannot be found\n\nAC_ARG_WITH(lua, AS_HELP_STRING([--without-lua], [Disable Lua])\nAS_HELP_STRING([--with-lua=path], [Set location of Lua executable]),[ LUABIN=\"$withval\"], [LUABIN=yes])\nAC_ARG_WITH(luaincl,[  --with-luaincl=path     Set location of Lua include directory],[\n\tLUAINCLUDE=\"$withval\"], [LUAINCLUDE=])\nAC_ARG_WITH(lualib,[  --with-lualib=path      Set location of Lua library directory],[\n\tLUALIB=\"$withval\"], [LUALIB=])\n\n# First, check for \"--without-lua\" or \"--with-lua=no\".\nif test x\"${LUABIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling Lua])\nelse\n\n# can we find lua?\nif test \"x$LUABIN\" = xyes; then\n   # We look for a versioned Lua binary first, as there can be\n   # multiple versions of Lua installed on some systems (like Debian).\n   # The search order should match the include-file and library search\n   # orders below (a Lua shared library built for one version may not\n   # work with a Lua binary of a different version).\n   AC_PATH_PROGS(LUABIN, [lua5.2 lua5.1 lua])\nfi\n\n# check version: we need Lua 5.x\nif test \"$LUABIN\"; then\n   AC_MSG_CHECKING(Lua version)\n   # if version 5.x\n   LUAV5=`$LUABIN -e 'if string.sub(_VERSION,5,5)==\"5\" then print \"1\" end'`\n   # if not version 5.0\n   LUAV51=`$LUABIN -e 'if string.sub(_VERSION,5,7)~=\"5.0\" then print \"1\" end'`\n\n   if test -z \"$LUAV5\"; then\n     AC_MSG_WARN(Not Lua 5.x, SWIG does not support this version of Lua)\n     LUABIN=\"\"\n   elif test -z \"$LUAV51\"; then\n     AC_MSG_RESULT(Lua 5.0.x)\n   else\n     AC_MSG_RESULT(Lua 5.1 or later)\n   fi\nfi\n\nif test \"$LUABIN\"; then\n   AC_MSG_CHECKING(whether Lua dynamic loading is enabled)\n   # using Lua to check Lua\n   # lua 5.0 & 5.1 have different fn names\n   if test -z \"$LUAV51\"; then\n     LUADYNAMICLOADLIB=`$LUABIN -e '_,_,c=loadlib(\"no_such_lib\",\"\") if c~=\"absent\" then print \"1\" end'`\n   else\n     LUADYNAMICLOADLIB=`$LUABIN -e '_,_,c=package.loadlib(\"no_such_lib\",\"\") if c~=\"absent\" then print \"1\" end'`\n   fi\n\n   if test -z \"$LUADYNAMICLOADLIB\"; then\n     AC_MSG_RESULT(no)\n   else\n     AC_MSG_RESULT(yes)\n   fi\nfi\n\n# look for the header files & set LUAFLAGS accordingly\n# will clear LUABIN if not present\nif test -n \"$LUAINCLUDE\"; then\n  AC_CHECK_FILE($LUAINCLUDE/lua.h,[LUAFLAGS=\"$ISYSTEM$LUAINCLUDE\"],[LUABIN=])\nelse\n  LUA_OK=\"1\"\n  AC_CHECK_HEADER(lua.h,[LUAFLAGS=\"\"],[LUA_OK=\"\"])\n  # if we didn't get it, going to have to look elsewhere (the hard way)\n  if test -z \"$LUA_OK\"; then\n    AC_MSG_CHECKING(for lua.h in other locations)\n    # note: Debian/Ubuntu seem to like /usr/include/lua5.1/lua.h\n    # The ordering of the include directories to search should match\n    # the ordering of libraries to search in the library test below.\n    inc=/usr/include\n    dirs=\"$inc/lua5.2 $inc/lua5.1 $inc/lua51 $inc/lua5.0 $inc/lua50 /usr/local/include\"\n    for i in $dirs; do\n      #echo \"$i\"\n      if test -r $i/lua.h; then\n        AC_MSG_RESULT($i/lua.h)\n\tLUAFLAGS=\"$ISYSTEM$i\"\n\tbreak\n      fi\n    done\n    if test -z \"$LUAFLAGS\"; then\n      AC_MSG_RESULT(not found)\n      LUABIN=\"\" # clear the bin\n    fi\n  fi\nfi\n\n# look for the library files & set LUALINK accordingly\n# will clear LUABIN if not present\nlua_save_LIBS=$LIBS # the code seems to disrupt LIBS, so saving\n\nif test -n \"$LUALIB\"; then\n  AC_CHECK_FILE($LUALIB/liblua.a,[LUALINK=\"-L$LUALIB -llua\"],[LUABIN=])\nelse\n  AC_SEARCH_LIBS(lua_close, [lua lua5.2 lua5.1 lua51 lua5.0 lua50], [LUALINK=\"-l$ac_lib\"],[LUABIN=])\nfi\n\n# adding lualib for lua 5.0\nif test -z \"$LUAV51\"; then # extra for lua 5.0\n  LUALINK=\"$LUALINK -llualib\"\nfi\n\nLIBS=$lua_save_LIBS\t# restore LIBS\n\nfi # if not disabled\n\nAC_SUBST(LUADYNAMICLINKING)\nAC_SUBST(LUAFLAGS)\nAC_SUBST(LUALINK)\nAC_SUBST(LUABIN)\n\n#----------------------------------------------------------------\n# Look for Allegro Common Lisp\n#----------------------------------------------------------------\n\nALLEGROCLBIN=\n\nAC_ARG_WITH(allegrocl, AS_HELP_STRING([--without-allegrocl], [Disable Allegro CL])\nAS_HELP_STRING([--with-allegrocl=path], [Set location of Allegro CL executable (alisp)]),[ ALLEGROCLBIN=\"$withval\"], [ALLEGROCLBIN=yes])\n\n# First, check for \"--without-allegrocl\" or \"--with-allegrocl=no\".\nif test x\"${ALLEGROCLBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling Allegro CL])\nALLEGROCLBIN=\nelse\n\n# can we find allegrocl?\nif test \"x$ALLEGROCLBIN\" = xyes; then\n   AC_PATH_PROG(ALLEGROCLBIN, alisp)\nfi\nfi\n\nAC_SUBST(ALLEGROCLBIN)\n\n#----------------------------------------------------------------\n# Look for GNU CLISP\n#----------------------------------------------------------------\n\nCLISPBIN=\n\nAC_ARG_WITH(clisp, AS_HELP_STRING([--without-clisp], [Disable CLISP])\nAS_HELP_STRING([--with-clisp=path], [Set location of CLISP executable (clisp)]),[ CLISPBIN=\"$withval\"], [CLISPBIN=yes])\n\n# First, check for \"--without-clisp\" or \"--with-clisp=no\".\nif test x\"${CLISPBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling CLISP])\nCLISPBIN=\nelse\n\n# can we find clisp?\nif test \"x$CLISPBIN\" = xyes; then\n   AC_PATH_PROG(CLISPBIN, clisp)\nfi\nfi\n\nAC_SUBST(CLISPBIN)\n\n#----------------------------------------------------------------\n# Look for GNU R\n#----------------------------------------------------------------\n\nRBIN=\n\nAC_ARG_WITH(r, AS_HELP_STRING([--without-r], [Disable R])\nAS_HELP_STRING([--with-r=path], [Set location of R executable (r)]),[ RBIN=\"$withval\"], [RBIN=yes])\n\n# First, check for \"--without-r\" or \"--with-r=no\".\nif test x\"${RBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\nAC_MSG_NOTICE([Disabling R])\nRBIN=\nelse\n\n# can we find R?\nif test \"x$RBIN\" = xyes; then\n   AC_PATH_PROG(RBIN, R)\nfi\nfi\n\nAC_SUBST(RBIN)\n\n#----------------------------------------------------------------\n# Look for Go compilers\n#----------------------------------------------------------------\n\nAC_ARG_WITH(go, AS_HELP_STRING([--without-go], [Disable Go])\nAS_HELP_STRING([--with-go=path], [Set location of Go compiler]),[GOBIN=\"$withval\"], [GOBIN=yes])\n\nif test x\"${GOBIN}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling Go])\n  GO=\n  GOC=\n  GO1=false\n  GOGCC=false\n  GOOPT=\n  GOVERSIONOPTION=\nelse\n\n  if test \"x$GOBIN\" = xyes; then\n    AC_CHECK_PROGS(GO, go 6g 8g gccgo)\n  else\n    GO=\"$GOBIN\"\n  fi\n\n  GOGCC=false\n  GO1=false\n  GOOPT=\n  GOVERSIONOPTION=\n  if test -n \"$GO\" ; then\n    if $GO --help 2>/dev/null | grep gccgo >/dev/null 2>&1 ; then\n      GOGCC=true\n      GOVERSIONOPTION=--version\n      AC_MSG_CHECKING([whether gccgo version is too old])\n      go_version=`$GO $GOVERSIONOPTION | sed -e 's/[^0-9]* \\([0-9.]*\\) .*$/\\1/' -e 's/[.]//g'`\n      if test \"$go_version\" -lt 470; then\n        AC_MSG_RESULT([yes - minimum version is 4.7.0])\n      else\n\tAC_MSG_RESULT([no])\n        if test \"$go_version\" -lt 480; then\n          GOOPT=\"-intgosize 32\"\n\telse\n\t  AC_CHECK_SIZEOF([void *], [4])\n\t  if test \"$ac_cv_sizeof_void_p\" = \"8\"; then\n\t    GOOPT=\"-intgosize 64\"\n\t  else\n\t    GOOPT=\"-intgosize 32\"\n\t  fi\n        fi\n      fi\n    elif test \"`echo $GO | sed -e 's|.*/||'`\" = \"go\"; then\n      GO1=true\n      GOVERSIONOPTION=version\n      GOC=$(sh -c \"$(go env) && echo \\$GOCHAR\")c\n      go_version=$($GO $GOVERSIONOPTION | sed -e 's/go version //')\n      case $go_version in\n      go1.0*) GOOPT=\"-intgosize 32\" ;;\n      *) if test \"$GOC\" = \"6c\"; then\n           GOOPT=\"-intgosize 64\"\n         else\n           GOOPT=\"-intgosize 32\"\n\t fi\n\t ;;\n      esac\n    else\n      GOC=`echo $GO | sed -e 's/g/c/'`\n      GOVERSIONOPTION=-V\n      AC_MSG_CHECKING([whether Go ($GO) version is too old])\n      go_version=`$GO $GOVERSIONOPTION 2>/dev/null | sed -e 's/.*version.* \\([[0-9]]*\\).*/\\1/'`\n      go_min_version=7077\n      if test \"$go_version\" != \"\" -a \"$go_version\" -lt $go_min_version; then\n        AC_MSG_RESULT([yes - minimum version is $go_min_version])\n        GO=\n      else\n        AC_MSG_RESULT([no])\n      fi\n      GOOPT=\"-intgosize 32\"\n    fi\n  fi\nfi\n\nAC_SUBST(GOGCC)\nAC_SUBST(GO)\nAC_SUBST(GOC)\nAC_SUBST(GO1)\nAC_SUBST(GOOPT)\nAC_SUBST(GOVERSIONOPTION)\n\n#----------------------------------------------------------------\n# Look for D\n#----------------------------------------------------------------\n\nAC_ARG_WITH(d, AS_HELP_STRING([--without-d], [Disable D]), [with_d=\"$withval\"], [with_d=yes])\nAC_ARG_WITH(d1-compiler, [  --with-d1-compiler=path  Set location of D1/Tango compiler (DMD compatible)],[D1COMPILERBIN=\"$withval\"], [D1COMPILERBIN=])\nAC_ARG_WITH(d2-compiler, [  --with-d2-compiler=path  Set location of D2 compiler (DMD compatible)],[D2COMPILERBIN=\"$withval\"], [D2COMPILERBIN=])\n\n\n# First, check for \"--without-d\" or \"--with-d=no\".\nif test x\"${with_d}\" = xno -o x\"${with_alllang}\" = xno ; then\n  AC_MSG_NOTICE([Disabling D])\n  D1COMPILER=\n  D2COMPILER=\nelse\n  old_ac_ext=$ac_ext\n  ac_ext=d\n\n  if test -z \"$D1COMPILERBIN\" ; then\n    AC_CHECK_PROGS(D1COMPILER, dmd ldmd gdmd)\n\n    if test -n \"$D1COMPILER\" ; then\n      AC_MSG_CHECKING(whether the D1/Tango compiler works)\n      cat > conftest.$ac_ext <<_ACEOF\nimport tango.io.Stdout;\nvoid main() {\n}\n_ACEOF\n      rm -f conftest.$ac_objext\n      AS_IF(\n        [_AC_DO_STDERR($D1COMPILER conftest.$ac_ext) && test ! -s conftest.err && test -s conftest.$ac_objext],\n        [AC_MSG_RESULT([yes])],\n        [_AC_MSG_LOG_CONFTEST AC_MSG_RESULT([no])\n        D1COMPILER=]\n      )\n      rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n    fi\n  else\n    D1COMPILER=\"$D1COMPILERBIN\"\n  fi\n\n  if test -z \"$D2COMPILERBIN\" ; then\n    AC_CHECK_PROGS(D2COMPILER, dmd gdmd)\n\n    if test -n \"$D2COMPILER\" ; then\n      AC_MSG_CHECKING(whether the D2 compiler works)\n      cat > conftest.$ac_ext <<_ACEOF\nimport std.algorithm;\nvoid main() {\n}\n_ACEOF\n      rm -f conftest.$ac_objext\n      AS_IF(\n        [_AC_DO_STDERR($D2COMPILER conftest.$ac_ext) && test ! -s conftest.err && test -s conftest.$ac_objext],\n        [AC_MSG_RESULT([yes])],\n        [_AC_MSG_LOG_CONFTEST AC_MSG_RESULT([no])\n        D2COMPILER=]\n      )\n      rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n    fi\n  else\n    D2COMPILER=\"$D2COMPILERBIN\"\n  fi\n\n  ac_ext=$old_ac_ext\nfi\n\nif test -n \"$D1COMPILER\"; then\n  DDEFAULTVERSION=1\nelif test -n \"$D2COMPILER\"; then\n  DDEFAULTVERSION=2\nfi\n\n# Do not prefix library file names with \"lib\" on Windows.\ncase $host in\n*-*-cygwin* | *-*-mingw*) DLIBPREFIX=\"\";;\n*)DLIBPREFIX=\"lib\";;\nesac\n\nAC_SUBST(D1COMPILER)\nAC_SUBST(D2COMPILER)\nAC_SUBST(DDEFAULTVERSION)\nAC_SUBST(DLIBPREFIX)\n\n#----------------------------------------------------------------\n# Determine which languages to use for examples/test-suite\n#----------------------------------------------------------------\n\nSKIP_TCL=\nif test -z \"$TCLINCLUDE\" || test -z \"$TCLLIB\" ; then\n    SKIP_TCL=\"1\"\nfi\nAC_SUBST(SKIP_TCL)\n\n\nSKIP_PERL5=\nif test -z \"$PERL\" || test -z \"$PERL5EXT\" ; then\n    SKIP_PERL5=\"1\"\nfi\nAC_SUBST(SKIP_PERL5)\n\n\nSKIP_OCTAVE=\nif test -z \"$OCTAVE\" ; then\n    SKIP_OCTAVE=\"1\"\nfi\nAC_SUBST(SKIP_OCTAVE)\n\n\nSKIP_PYTHON=\nif (test -z \"$PYINCLUDE\") &&\n   (test -z \"$PY3INCLUDE\") ; then\n    SKIP_PYTHON=\"1\"\nfi\nAC_SUBST(SKIP_PYTHON)\n\nSKIP_PYTHON3=\nif test -z \"$PY3INCLUDE\" ; then\n    SKIP_PYTHON3=\"1\"\nfi\nAC_SUBST(SKIP_PYTHON3)\n\nSKIP_JAVA=\nif test -z \"$JAVA\" || test -z \"$JAVAC\" || test -z \"$JAVAINC\" ; then\n    SKIP_JAVA=\"1\"\nfi\nAC_SUBST(SKIP_JAVA)\n\n\nSKIP_GUILE=\nif test -z \"$GUILE\" || test -z \"$GUILE_LIBS\" ; then\n    SKIP_GUILE=\"1\"\nfi\nAC_SUBST(SKIP_GUILE)\n\n\nSKIP_MZSCHEME=\nif test -z \"$MZC\" || test -z \"$MZDYNOBJ\" ; then\n    SKIP_MZSCHEME=\"1\"\nfi\nAC_SUBST(SKIP_MZSCHEME)\n\n\nSKIP_RUBY=\nif test -z \"$RUBY\" || test -z \"$RUBYINCLUDE\" || test -z \"$RUBYLIB\" ; then\n    SKIP_RUBY=\"1\"\nfi\nAC_SUBST(SKIP_RUBY)\n\n\nSKIP_PHP=\nif test -z \"$PHP\" || test -z \"$PHPINC\" ; then\n    SKIP_PHP=\"1\"\nfi\nAC_SUBST(SKIP_PHP)\n\n\nSKIP_OCAML=\nif test -z \"$OCAMLBIN\" || test -z \"$OCAMLINC\" ; then\n    SKIP_OCAML=\"1\"\nfi\nAC_SUBST(SKIP_OCAML)\n\n\nSKIP_PIKE=\nif test -z \"$PIKE\" || test -z \"$PIKEINCLUDE\" ; then\n    SKIP_PIKE=\"1\"\nfi\nAC_SUBST(SKIP_PIKE)\n\n\nSKIP_CHICKEN=\nif test -z \"$CHICKEN_CSC\" || test -z \"$CHICKEN\"; then\n    SKIP_CHICKEN=\"1\"\nfi\nAC_SUBST(SKIP_CHICKEN)\n\n\nSKIP_CSHARP=\nif test -z \"$CSHARPCOMPILER\" ; then\n    SKIP_CSHARP=\"1\"\nelse\n    if test \"cscc\" = \"$CSHARPCOMPILER\" && test -z \"$CSHARPCILINTERPRETER\" ; then\n      SKIP_CSHARP=\"1\"\n    fi\nfi\nAC_SUBST(SKIP_CSHARP)\n\nSKIP_MODULA3=\"1\" # Always skipped!\nAC_SUBST(SKIP_MODULA3)\n\nSKIP_LUA=\n# we need LUABIN & dynamic loading\nif test -z \"$LUABIN\" || test -z \"$LUADYNAMICLOADLIB\"; then\n    SKIP_LUA=\"1\"\nfi\nAC_SUBST(SKIP_LUA)\n\nSKIP_ALLEGROCL=\nif test -z \"$ALLEGROCLBIN\" ; then\n    SKIP_ALLEGROCL=\"1\"\nfi\nAC_SUBST(SKIP_ALLEGROCL)\n\nSKIP_CLISP=\nif test -z \"$CLISPBIN\" ; then\n    SKIP_CLISP=\"1\"\nfi\nAC_SUBST(SKIP_CLISP)\n\nSKIP_R=\nif test -z \"$RBIN\" ; then\n    SKIP_R=\"1\"\nfi\nAC_SUBST(SKIP_R)\n\nSKIP_CFFI=\n#if test -z \"$CFFIBIN\" ; then\n    SKIP_CFFI=\"1\"\n#fi\nAC_SUBST(SKIP_CFFI)\n\nSKIP_UFFI=\n#if test -z \"$UFFIBIN\" ; then\n    SKIP_UFFI=\"1\"\n#fi\nAC_SUBST(SKIP_UFFI)\n\nSKIP_GO=\nif test -z \"$GO\" ; then\n    SKIP_GO=\"1\"\nfi\nAC_SUBST(SKIP_GO)\n\nSKIP_D=\nif test -z \"$DDEFAULTVERSION\" ; then\n    SKIP_D=\"1\"\nfi\nAC_SUBST(SKIP_D)\n\n#----------------------------------------------------------------\n# Additional language dependencies\n#----------------------------------------------------------------\nSKIP_GCJ=\nif test -z \"$GCJ\" || test -z \"$GCJH\" ; then\n  SKIP_GCJ=\"1\"\nelse\n  if test \"$GCC\" != yes; then\n    SKIP_GCJ=\"1\"\n  fi\nfi\nAC_SUBST(SKIP_GCJ)\n\n\nSKIP_ANDROID=\nif test -z \"$ANDROID\" || test -z \"$ADB\" || test -z \"$ANT\" || test -z \"$NDKBUILD\" ; then\n    SKIP_ANDROID=\"1\"\nfi\nAC_SUBST(SKIP_ANDROID)\n\n\n\n#----------------------------------------------------------------\n# Miscellaneous\n#----------------------------------------------------------------\n\n\n# Root directory\n# Translate path for native Windows compilers for use with 'make check'\nROOT_DIR=`pwd`\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n  if (cygpath --mixed $ROOT_DIR) >/dev/null 2>/dev/null; then\n    ROOT_DIR=`cygpath --mixed $ROOT_DIR`\n  fi\n  # Extra files generated by some Windows compilers\n  EXTRA_CLEAN=\"*.stackdump *.exp *.lib *.pdb *.ilk\"\n  ;;\nesac\n\nAC_SUBST(ROOT_DIR)\nAC_SUBST(EXTRA_CLEAN)\nAC_SUBST(ac_aux_dir)\n\n# Configure SWIG_LIB path\n\nAC_ARG_WITH(swiglibdir,[  --with-swiglibdir=DIR   Put SWIG system-independent libraries into DIR.],\n  [swig_lib=\"$withval\"], [swig_lib=\"${datadir}/swig/${PACKAGE_VERSION}\"])\nAC_SUBST(swig_lib)\nAC_DEFINE_DIR(SWIG_LIB, swig_lib, [Directory for SWIG system-independent libraries])\n\ncase $build in\n        # Windows does not understand unix directories. Convert into a windows directory with drive letter.\n        *-*-mingw*) SWIG_LIB_WIN_UNIX=`cmd //c echo $SWIG_LIB | sed -e \"s/[ ]*$//\"`;; # This echo converts unix to mixed paths. Then zap unexpected trailing space.\n        *-*-cygwin*) SWIG_LIB_WIN_UNIX=`cygpath --mixed \"$SWIG_LIB\"`;;\n        *) SWIG_LIB_WIN_UNIX=\"\";;\nesac\nAC_DEFINE_UNQUOTED(SWIG_LIB_WIN_UNIX, [\"$SWIG_LIB_WIN_UNIX\"], [Directory for SWIG system-independent libraries (Unix install on native Windows)])\n\nAC_CONFIG_FILES([\t\t\t        \\\n    Makefile\t\t\t\t        \\\n    swig.spec\t\t\t\t        \\\n    Source/Makefile\t\t\t        \\\n    Examples/Makefile\t\t\t        \\\n    Examples/xml/Makefile\t\t        \\\n    Examples/test-suite/chicken/Makefile\t\\\n    Examples/test-suite/csharp/Makefile\t        \\\n    Examples/test-suite/d/Makefile\t        \\\n    Examples/test-suite/guile/Makefile\t        \\\n    Examples/test-suite/java/Makefile\t        \\\n    Examples/test-suite/mzscheme/Makefile\t\\\n    Examples/test-suite/ocaml/Makefile\t        \\\n    Examples/test-suite/octave/Makefile\t        \\\n    Examples/test-suite/perl5/Makefile\t        \\\n    Examples/test-suite/php/Makefile\t        \\\n    Examples/test-suite/pike/Makefile\t        \\\n    Examples/test-suite/python/Makefile\t        \\\n    Examples/test-suite/ruby/Makefile\t        \\\n    Examples/test-suite/tcl/Makefile\t        \\\n    Examples/test-suite/lua/Makefile\t        \\\n    Examples/test-suite/allegrocl/Makefile\t\\\n    Examples/test-suite/clisp/Makefile\t\t\\\n    Examples/test-suite/cffi/Makefile\t\t\\\n    Examples/test-suite/uffi/Makefile\t\t\\\n    Examples/test-suite/r/Makefile\t\t\\\n    Examples/test-suite/go/Makefile\t\t\\\n    Lib/ocaml/swigp4.ml\n])\nAC_CONFIG_FILES([preinst-swig], [chmod +x preinst-swig])\nAC_CONFIG_FILES([CCache/ccache_swig_config.h])\n\nAC_OUTPUT\ndnl configure.ac ends here\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Lib/d/wrapperloader.swg": "/* -----------------------------------------------------------------------------\n * wrapperloader.swg\n *\n * Support code for dynamically linking the C wrapper library from the D\n * wrapper module.\n *\n * The loading code was adapted from the Derelict project and is used with\n * permission from Michael Parker, the original author.\n * ----------------------------------------------------------------------------- */\n\n%pragma(d) wrapperloadercode = %{\nprivate {\n  version(linux) {\n    version = Nix;\n  } else version(darwin) {\n    version = Nix;\n  } else version(OSX) {\n    version = Nix;\n  } else version(FreeBSD) {\n    version = Nix;\n    version = freebsd;\n  } else version(freebsd) {\n    version = Nix;\n  } else version(Unix) {\n    version = Nix;\n  } else version(Posix) {\n    version = Nix;\n  }\n\n  version(Tango) {\n    static import tango.stdc.string;\n    static import tango.stdc.stringz;\n\n    version (PhobosCompatibility) {\n    } else {\n      alias char[] string;\n      alias wchar[] wstring;\n      alias dchar[] dstring;\n    }\n  } else {\n    version(D_Version2) {\n      static import std.conv;\n    }\n    static import std.string;\n    static import std.c.string;\n  }\n\n  version(D_Version2) {\n    mixin(\"alias const(char)* CCPTR;\");\n  } else {\n    alias char* CCPTR;\n  }\n\n  CCPTR swigToCString(string str) {\n    version(Tango) {\n      return tango.stdc.stringz.toStringz(str);\n    } else {\n      return std.string.toStringz(str);\n    }\n  }\n\n  string swigToDString(CCPTR cstr) {\n    version(Tango) {\n      return tango.stdc.stringz.fromStringz(cstr);\n    } else {\n      version(D_Version2) {\n        mixin(\"return std.conv.to!string(cstr);\");\n      } else {\n        return std.c.string.toString(cstr);\n      }\n    }\n  }\n}\n\nclass SwigSwigSharedLibLoadException : Exception {\n  this(in string[] libNames, in string[] reasons) {\n    string msg = \"Failed to load one or more shared libraries:\";\n    foreach(i, n; libNames) {\n      msg ~= \"\\n\\t\" ~ n ~ \" - \";\n      if(i < reasons.length)\n        msg ~= reasons[i];\n      else\n        msg ~= \"Unknown\";\n    }\n    super(msg);\n  }\n}\n\nclass SwigSymbolLoadException : Exception {\n  this(string SwigSharedLibName, string symbolName) {\n    super(\"Failed to load symbol \" ~ symbolName ~ \" from shared library \" ~ SwigSharedLibName);\n    _symbolName = symbolName;\n  }\n\n  string symbolName() {\n    return _symbolName;\n  }\n\nprivate:\n  string _symbolName;\n}\n\nprivate {\n  version(Nix) {\n    version(freebsd) {\n      // the dl* functions are in libc on FreeBSD\n    }\n    else {\n      pragma(lib, \"dl\");\n    }\n\n    version(Tango) {\n      import tango.sys.Common;\n    } else version(linux) {\n      import std.c.linux.linux;\n    } else {\n      extern(C) {\n        const RTLD_NOW = 2;\n\n        void *dlopen(CCPTR file, int mode);\n        int dlclose(void* handle);\n        void *dlsym(void* handle, CCPTR name);\n        CCPTR dlerror();\n      }\n    }\n\n    alias void* SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return dlopen(swigToCString(libName), RTLD_NOW);\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      dlclose(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return dlsym(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      CCPTR err = dlerror();\n      if (err is null) {\n        return \"Unknown Error\";\n      }\n      return swigToDString(err);\n    }\n  } else version(Windows) {\n    alias ushort WORD;\n    alias uint DWORD;\n    alias CCPTR LPCSTR;\n    alias void* HMODULE;\n    alias void* HLOCAL;\n    alias int function() FARPROC;\n    struct VA_LIST {}\n\n    extern (Windows) {\n      HMODULE LoadLibraryA(LPCSTR);\n      FARPROC GetProcAddress(HMODULE, LPCSTR);\n      void FreeLibrary(HMODULE);\n      DWORD GetLastError();\n      DWORD FormatMessageA(DWORD, in void*, DWORD, DWORD, LPCSTR, DWORD, VA_LIST*);\n      HLOCAL LocalFree(HLOCAL);\n    }\n\n    DWORD MAKELANGID(WORD p, WORD s) {\n      return (((cast(WORD)s) << 10) | cast(WORD)p);\n    }\n\n    enum {\n      LANG_NEUTRAL                    = 0,\n      SUBLANG_DEFAULT                 = 1,\n      FORMAT_MESSAGE_ALLOCATE_BUFFER  = 256,\n      FORMAT_MESSAGE_IGNORE_INSERTS   = 512,\n      FORMAT_MESSAGE_FROM_SYSTEM      = 4096\n    }\n\n    alias HMODULE SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return LoadLibraryA(swigToCString(libName));\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      FreeLibrary(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return GetProcAddress(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      DWORD errcode = GetLastError();\n\n      LPCSTR msgBuf;\n      DWORD i = FormatMessageA(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        null,\n        errcode,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        cast(LPCSTR)&msgBuf,\n        0,\n        null);\n\n      string text = swigToDString(msgBuf);\n      LocalFree(cast(HLOCAL)msgBuf);\n\n      if (i >= 2) {\n        i -= 2;\n      }\n      return text[0 .. i];\n    }\n  } else {\n    static assert(0, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  final class SwigSharedLib {\n    void load(string[] names) {\n      if (_hlib !is null) return;\n\n      string[] failedLibs;\n      string[] reasons;\n\n      foreach(n; names) {\n        _hlib = swigLoadSharedLib(n);\n        if (_hlib is null) {\n          failedLibs ~= n;\n          reasons ~= swigGetErrorStr();\n          continue;\n        }\n        _name = n;\n        break;\n      }\n\n      if (_hlib is null) {\n        throw new SwigSwigSharedLibLoadException(failedLibs, reasons);\n      }\n    }\n\n    void* loadSymbol(string symbolName, bool doThrow = true) {\n      void* sym = swigGetSymbol(_hlib, symbolName);\n      if(doThrow && (sym is null)) {\n        throw new SwigSymbolLoadException(_name, symbolName);\n      }\n      return sym;\n    }\n\n    void unload() {\n      if(_hlib !is null) {\n        swigUnloadSharedLib(_hlib);\n        _hlib = null;\n      }\n    }\n\n  private:\n    string _name;\n    SwigSharedLibHandle _hlib;\n  }\n}\n\nstatic this() {\n  string[] possibleFileNames;\n  version (Posix) {\n    version (OSX) {\n      possibleFileNames ~= [\"lib$wraplibrary.dylib\", \"lib$wraplibrary.bundle\"];\n    }\n    possibleFileNames ~= [\"lib$wraplibrary.so\"];\n  } else version (Windows) {\n    possibleFileNames ~= [\"$wraplibrary.dll\", \"lib$wraplibrary.so\"];\n  } else {\n    static assert(false, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  auto library = new SwigSharedLib;\n  library.load(possibleFileNames);\n\n  string bindCode(string functionPointer, string symbol) {\n    return functionPointer ~ \" = cast(typeof(\" ~ functionPointer ~\n      \"))library.loadSymbol(`\" ~ symbol ~ \"`);\";\n  }\n\n  //#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\n  mixin(bindCode(\"swigRegisterExceptionCallbacks$module\", \"SWIGRegisterExceptionCallbacks_$module\"));\n  //#endif // SWIG_D_NO_EXCEPTION_HELPER\n  //#if !defined(SWIG_D_NO_STRING_HELPER)\n  mixin(bindCode(\"swigRegisterStringCallback$module\", \"SWIGRegisterStringCallback_$module\"));\n  //#endif // SWIG_D_NO_STRING_HELPER\n  $wrapperloaderbindcode\n}\n\n//#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\nextern(C) void function(\n  SwigExceptionCallback exceptionCallback,\n  SwigExceptionCallback illegalArgumentCallback,\n  SwigExceptionCallback illegalElementCallback,\n  SwigExceptionCallback ioCallback,\n  SwigExceptionCallback noSuchElementCallback) swigRegisterExceptionCallbacks$module;\n//#endif // SWIG_D_NO_EXCEPTION_HELPER\n\n//#if !defined(SWIG_D_NO_STRING_HELPER)\nextern(C) void function(SwigStringCallback callback) swigRegisterStringCallback$module;\n//#endif // SWIG_D_NO_STRING_HELPER\n%}\n\n%pragma(d) wrapperloaderbindcommand = %{\n  mixin(bindCode(\"$function\", \"$symbol\"));%}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Lib/mzscheme/mzrun.swg": "/* -----------------------------------------------------------------------------\n * mzrun.swg\n * ----------------------------------------------------------------------------- */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <escheme.h>\n#include <assert.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Common SWIG API */\n  \n#define SWIG_ConvertPtr(s, result, type, flags) \\\n  SWIG_MzScheme_ConvertPtr(s, result, type, flags)\n#define SWIG_NewPointerObj(ptr, type, owner) \\\n  SWIG_MzScheme_NewPointerObj((void *)ptr, type, owner)\n#define SWIG_MustGetPtr(s, type, argnum, flags) \\\n  SWIG_MzScheme_MustGetPtr(s, type, argnum, flags, FUNC_NAME, argc, argv)\n\n#define SWIG_contract_assert(expr,msg) \\\n if (!(expr)) { \\\n    char *m=(char *) scheme_malloc(strlen(msg)+1000); \\\n    sprintf(m,\"SWIG contract, assertion failed: function=%s, message=%s\", \\\n            (char *) FUNC_NAME,(char *) msg); \\\n    scheme_signal_error(m); \\\n }\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_MzScheme_GetModule((Scheme_Env *)(clientdata))\n#define SWIG_SetModule(clientdata, pointer) SWIG_MzScheme_SetModule((Scheme_Env *) (clientdata), pointer)\n#define SWIG_MODULE_CLIENTDATA_TYPE Scheme_Env *\n\n/* MzScheme-specific SWIG API */\n  \n#define SWIG_malloc(size) SWIG_MzScheme_Malloc(size, FUNC_NAME)\n#define SWIG_free(mem) free(mem)\n#define SWIG_NewStructFromPtr(ptr,type) \\\n        _swig_convert_struct_##type##(ptr)\n\n#define MAXVALUES 6\n#define swig_make_boolean(b) (b ? scheme_true : scheme_false)\n\nstatic long\nSWIG_convert_integer(Scheme_Object *o,\n\t\t     long lower_bound, long upper_bound, \n\t\t     const char *func_name, int argnum, int argc,\n\t\t     Scheme_Object **argv)\n{\n  long value;\n  int status = scheme_get_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_integer(Scheme_Object *o)\n{\n  long value;\n  return scheme_get_int_val(o, &value);\n}\n\nstatic unsigned long\nSWIG_convert_unsigned_integer(Scheme_Object *o,\n\t\t\t      unsigned long lower_bound, unsigned long upper_bound, \n\t\t\t      const char *func_name, int argnum, int argc,\n\t\t\t      Scheme_Object **argv)\n{\n  unsigned long value;\n  int status = scheme_get_unsigned_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_unsigned_integer(Scheme_Object *o)\n{\n  unsigned long value;\n  return scheme_get_unsigned_int_val(o, &value);\n}\n  \n/* ----------------------------------------------------------------------- \n * mzscheme 30X support code\n * ----------------------------------------------------------------------- */\n\n#ifndef SCHEME_STR_VAL\n#define MZSCHEME30X 1\n#endif\n\n#ifdef MZSCHEME30X \n/* \n * This is MZSCHEME 299.100 or higher (30x).  From version 299.100 of\n * mzscheme upwards, strings are in unicode. These functions convert\n * to and from utf8 encodings of these strings.  NB! strlen(s) will be\n * the size in bytes of the string, not the actual length.\n */\n#define SCHEME_STR_VAL(obj)  \t       SCHEME_BYTE_STR_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRLEN_VAL(obj)         SCHEME_BYTE_STRLEN_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRINGP(obj)            SCHEME_CHAR_STRINGP(obj)\n#define scheme_make_string(s)          scheme_make_utf8_string(s)\n#define scheme_make_sized_string(s,l)  scheme_make_sized_utf8_string(s,l)\n#define scheme_make_sized_offset_string(s,d,l) \\\n                   scheme_make_sized_offset_utf8_string(s,d,l)\n#define SCHEME_MAKE_STRING(s) scheme_make_utf8_string(s)\n#else\n#define SCHEME_MAKE_STRING(s) scheme_make_string_without_copying(s)\n#endif\n/* ----------------------------------------------------------------------- \n * End of mzscheme 30X support code \n * ----------------------------------------------------------------------- */\n  \nstruct swig_mz_proxy {\n  Scheme_Type mztype;\n  swig_type_info *type;\n  void *object;\n};\n\nstatic Scheme_Type swig_type;\n\nstatic void \nmz_free_swig(void *p, void *data) {\n  struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) p;\n  if (SCHEME_NULLP((Scheme_Object*)p) || SCHEME_TYPE((Scheme_Object*)p) != swig_type)\n    return;\n  if (proxy->type) {\n    if (proxy->type->clientdata) {\n      ((Scheme_Prim *)proxy->type->clientdata)(1, (Scheme_Object **)&proxy);\n    }\n  }\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_NewPointerObj(void *ptr, swig_type_info *type, int owner) {\n  struct swig_mz_proxy *new_proxy;\n  new_proxy = (struct swig_mz_proxy *) scheme_malloc(sizeof(struct swig_mz_proxy));\n  new_proxy->mztype = swig_type;\n  new_proxy->type = type;\n  new_proxy->object = ptr;\n  if (owner) {\n    scheme_add_finalizer(new_proxy, mz_free_swig, NULL);\n  }\n  return (Scheme_Object *) new_proxy;\n}\n\nstatic int\nSWIG_MzScheme_ConvertPtr(Scheme_Object *s, void **result, swig_type_info *type, int flags) {\n  swig_cast_info *cast;\n\n  if (SCHEME_NULLP(s)) {\n    *result = NULL;\n    return 0;\n  } else if (SCHEME_TYPE(s) == swig_type) {\n    struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) s;\n    if (type) {\n      cast = SWIG_TypeCheckStruct(proxy->type, type);\n      if (cast) {\n        int newmemory = 0;\n        *result = SWIG_TypeCast(cast, proxy->object, &newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n        return 0;\n      } else {\n        return 1;\n      }\n    } else {\n      *result = proxy->object;\n      return 0;\n    }\n  }\n  return 1;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_MustGetPtr(Scheme_Object *s, swig_type_info *type, \n                         int argnum, int flags, const char *func_name,\n                         int argc, Scheme_Object **argv) {\n  void *result;\n  if (SWIG_MzScheme_ConvertPtr(s, &result, type, flags)) {\n    scheme_wrong_type(func_name, type->str ? type->str : \"void *\", argnum - 1, argc, argv);\n  }\n  return result;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_Malloc(size_t size, const char *func_name) {\n  void *p = malloc(size);\n  if (p == NULL) {\n    scheme_signal_error(\"swig-memory-error\");\n  } else return p;\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_PackageValues(int num, Scheme_Object **values) {\n    /* ignore first value if void */\n    if (num > 0 && SCHEME_VOIDP(values[0]))\n\tnum--, values++;\n    if (num == 0) return scheme_void;\n    else if (num == 1) return values[0];\n    else return scheme_values(num, values);\n}\n\n#ifndef scheme_make_inspector\n#define scheme_make_inspector(x,y) \\\n        _scheme_apply(scheme_builtin_value(\"make-inspector\"), x, y)\n#endif\n\n/* Function to create a new struct. */\nstatic Scheme_Object *\nSWIG_MzScheme_new_scheme_struct (Scheme_Env* env, const char* basename, \n\t\t\t\t int num_fields, char** field_names)\n{\n    Scheme_Object *new_type;\n    int count_out, i;\n    Scheme_Object **struct_names;\n    Scheme_Object **vals;\n    Scheme_Object **a = (Scheme_Object**) \\\n        scheme_malloc(num_fields*sizeof(Scheme_Object*));\n    \n    for (i=0; i<num_fields; ++i) {\n        a[i] = (Scheme_Object*) scheme_intern_symbol(field_names[i]);\n    }\n\n    new_type = scheme_make_struct_type(scheme_intern_symbol(basename),\n                                       NULL /*super_type*/,\n                                       scheme_make_inspector(0, NULL),\n                                       num_fields,\n                                       0 /* auto_fields */,\n                                       NULL /* auto_val */,\n                                       NULL /* properties */\n#ifdef MZSCHEME30X\n\t\t\t\t       ,NULL /* Guard */\n#endif\n\t\t\t\t       );\n    struct_names = scheme_make_struct_names(scheme_intern_symbol(basename),\n                                            scheme_build_list(num_fields,a),\n                                            0 /*flags*/, &count_out);\n    vals = scheme_make_struct_values(new_type, struct_names, count_out, 0);\n\n    for (i = 0; i < count_out; i++)\n        scheme_add_global_symbol(struct_names[i], vals[i],env);\n\n    return new_type;\n}\n\n#if defined(_WIN32) || defined(__WIN32__)\n#define __OS_WIN32\n#endif\n\n#ifdef __OS_WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n  static char **mz_dlopen_libraries=NULL;\n  static void **mz_libraries=NULL;\n  static char **mz_dynload_libpaths=NULL;\n\n  static void mz_set_dlopen_libraries(const char *_libs)\n  {\n    int   i,k,n;\n    int   mz_dynload_debug=(1==0);\n    char *extra_paths[1000];\n    char *EP;\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    {\n      char *ep=getenv(\"MZ_DYNLOAD_LIBPATH\");\n      int   i,k,j;\n      k=0;\n      if (ep!=NULL) {\n\tEP=strdup(ep);\n\tfor(i=0,j=0;EP[i]!='\\0';i++) {\n\t  if (EP[i]==':') {\n\t    EP[i]='\\0';\n\t    extra_paths[k++]=&EP[j];\n\t    j=i+1;\n\t  }\n\t}\n\tif (j!=i) {\n\t  extra_paths[k++]=&EP[j];\n\t}\n      }\n      else {\n\tEP=strdup(\"\");\n      }\n      extra_paths[k]=NULL;\n      k+=1;\n\n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"SWIG:mzscheme:MZ_DYNLOAD_LIBPATH=%s\\n\",(ep==NULL) ? \"(null)\" : ep);\n\tfprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]\\n\",k-1);\n\tfor(i=0;i<k-1;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]=%s\\n\",i,extra_paths[i]);\n\t}\n      }\n\n      mz_dynload_libpaths=(char **) malloc(sizeof(char *)*k);\n      for(i=0;i<k;i++) {\n\tif (extra_paths[i]!=NULL) {\n\t  mz_dynload_libpaths[i]=strdup(extra_paths[i]);\n\t}\n\telse {\n\t  mz_dynload_libpaths[i]=NULL;\n\t}\n      }\n\n      if (mz_dynload_debug) {\n\tint i;\n\tfor(i=0;extra_paths[i]!=NULL;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:%s\\n\",extra_paths[i]);\n\t}\n      }\n    }\n\n    {\n#ifdef MZ_DYNLOAD_LIBS\n      char *libs=(char *) malloc((strlen(MZ_DYNLOAD_LIBS)+1)*sizeof(char));\n      strcpy(libs,MZ_DYNLOAD_LIBS);\n#else\n      char *libs=(char *) malloc((strlen(_libs)+1)*sizeof(char));\n      strcpy(libs,_libs);\n#endif\n      \n      for(i=0,n=strlen(libs),k=0;i<n;i++) {\n\tif (libs[i]==',') { k+=1; }\n      }\n      k+=1;\n      mz_dlopen_libraries=(char **) malloc(sizeof(char *)*(k+1));\n      mz_dlopen_libraries[0]=libs;\n      for(i=0,k=1,n=strlen(libs);i<n;i++) {\n\tif (libs[i]==',') {\n\t  libs[i]='\\0';\n\t  mz_dlopen_libraries[k++]=&libs[i+1];\n\t  i+=1;\n\t}\n      }\n      \n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"k=%d\\n\",k);\n      }\n      mz_dlopen_libraries[k]=NULL;\n      \n      free(EP);\n    }\n  }\n\n  static void *mz_load_function(char *function)\n  {\n    int mz_dynload_debug=(1==0);\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    if (mz_dlopen_libraries==NULL) {\n      return NULL;\n    }\n    else {\n      if (mz_libraries==NULL) {\n        int i,n;\n        for(n=0;mz_dlopen_libraries[n]!=NULL;n++);\n\tif (mz_dynload_debug) {\n\t  fprintf(stderr,\"SWIG:mzscheme:n=%d\\n\",n);\n\t}\n        mz_libraries=(void **) malloc(sizeof(void*)*n);\n        for(i=0;i<n;i++) { \n\t  if (mz_dynload_debug) {\n\t   fprintf(stderr,\"SWIG:mzscheme:loading %s\\n\",mz_dlopen_libraries[i]);\n\t  }\n#ifdef __OS_WIN32\n\t  mz_libraries[i]=(void *) LoadLibrary(mz_dlopen_libraries[i]); \n#else\n\t  mz_libraries[i]=(void *) dlopen(mz_dlopen_libraries[i],RTLD_LAZY); \n#endif\n\t  if (mz_libraries[i]==NULL) {\n\t    int k;\n\t    char *libp;\n\t    for(k=0;mz_dynload_libpaths[k]!=NULL && mz_libraries[i]==NULL;k++) {\n\t      int L=strlen(mz_dynload_libpaths[k])+strlen(\"\\\\\")+strlen(mz_dlopen_libraries[i])+1;\n\t      libp=(char *) malloc(L*sizeof(char));\n#ifdef __OS_WIN32\n\t      sprintf(libp,\"%s\\\\%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) LoadLibrary(libp); \n#else\n\t      sprintf(libp,\"%s/%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) dlopen(libp,RTLD_LAZY); \n#endif\n\t      if (mz_dynload_debug) {\n\t\tfprintf(stderr,\"SWIG:mzscheme:trying %s --> %p\\n\",libp,mz_libraries[i]);\n\t      }\n\t      free(libp);\n\t    }\n\t  }\n        }\n      }\n      {\n        int i;\n        void *func=NULL;\n\n        for(i=0;mz_dlopen_libraries[i]!=NULL && func==NULL;i++) {\n          if (mz_libraries[i]!=NULL) {\n#ifdef __OS_WIN32\n            func=GetProcAddress(mz_libraries[i],function);\n#else\n            func=dlsym(mz_libraries[i],function);\n#endif\n          }\n\t  if (mz_dynload_debug) {\n\t    fprintf(stderr,\n\t\t    \"SWIG:mzscheme:library:%s;dlopen=%p,function=%s,func=%p\\n\",\n\t\t    mz_dlopen_libraries[i],mz_libraries[i],function,func\n\t\t    );\n\t  }\n        }\n\n        return func;\n      }\n    }\n  }\n\n/* The interpreter will store a pointer to this structure in a global\n   variable called swig-runtime-data-type-pointer.  The instance of this\n   struct is only used if no other module has yet been loaded */\nstruct swig_mzscheme_runtime_data {\n  swig_module_info *module_head;\n  Scheme_Type type;\n};\nstatic struct swig_mzscheme_runtime_data swig_mzscheme_runtime_data;\n\n\nstatic swig_module_info *\nSWIG_MzScheme_GetModule(Scheme_Env *env) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n      data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n      swig_type = data->type;\n      return data->module_head;\n  } else {\n      return NULL;\n  }\n}\n\nstatic void\nSWIG_MzScheme_SetModule(Scheme_Env *env, swig_module_info *module) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n    data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n    swig_type = data->type;\n    data->module_head = module;\n  } else {\n    /* create a new type for wrapped pointer values */\n    swig_type = scheme_make_type((char *)\"swig\");\n    swig_mzscheme_runtime_data.module_head = module;\n    swig_mzscheme_runtime_data.type = swig_type;\n    \n    /* create a new pointer */\n#ifndef MZSCHEME30X\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data, \"swig_mzscheme_runtime_data\");\n#else\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data,\n\t\t\t       scheme_make_byte_string(\"swig_mzscheme_runtime_data\"));\n#endif\n    scheme_add_global_symbol(symbol, pointer, env);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Source/Modules/mzscheme.cxx": "/* ----------------------------------------------------------------------------- \n * This file is part of SWIG, which is licensed as a whole under version 3 \n * (or any later version) of the GNU General Public License. Some additional\n * terms also apply to certain portions of SWIG. The full details of the SWIG\n * license and copyrights can be found in the LICENSE and COPYRIGHT files\n * included with the SWIG source code as distributed by the SWIG developers\n * and at http://www.swig.org/legal.html.\n *\n * mzscheme.cxx\n *\n * Mzscheme language module for SWIG.\n * ----------------------------------------------------------------------------- */\n\n#include \"swigmod.h\"\n\n#include <ctype.h>\n\nstatic const char *usage = (char *) \"\\\nMzscheme Options (available with -mzscheme)\\n\\\n     -declaremodule                         - Create extension that declares a module\\n\\\n     -dynamic-load <library>,[library,...]  - Do not link with these libraries, dynamic load\\n\\\n                                              them\\n\\\n     -noinit                                - Do not emit scheme_initialize, scheme_reload,\\n\\\n                                              scheme_module_name functions\\n\\\n     -prefix <name>                         - Set a prefix <name> to be prepended to all names\\n\\\n\";\n\nstatic String *fieldnames_tab = 0;\nstatic String *convert_tab = 0;\nstatic String *convert_proto_tab = 0;\nstatic String *struct_name = 0;\nstatic String *mangled_struct_name = 0;\n\nstatic String *prefix = 0;\nstatic bool declaremodule = false;\nstatic bool noinit = false;\nstatic String *load_libraries = NULL;\nstatic String *module = 0;\nstatic char *mzscheme_path = (char *) \"mzscheme\";\nstatic String *init_func_def = 0;\n\nstatic File *f_begin = 0;\nstatic File *f_runtime = 0;\nstatic File *f_header = 0;\nstatic File *f_wrappers = 0;\nstatic File *f_init = 0;\n\n// Used for garbage collection\nstatic int exporting_destructor = 0;\nstatic String *swigtype_ptr = 0;\nstatic String *cls_swigtype = 0;\n\nclass MZSCHEME:public Language {\npublic:\n\n  /* ------------------------------------------------------------\n   * main()\n   * ------------------------------------------------------------ */\n\n  virtual void main(int argc, char *argv[]) {\n\n    int i;\n\n     SWIG_library_directory(mzscheme_path);\n\n    // Look for certain command line options\n    for (i = 1; i < argc; i++) {\n      if (argv[i]) {\n\tif (strcmp(argv[i], \"-help\") == 0) {\n\t  fputs(usage, stdout);\n\t  SWIG_exit(0);\n\t} else if (strcmp(argv[i], \"-prefix\") == 0) {\n\t  if (argv[i + 1]) {\n\t    prefix = NewString(argv[i + 1]);\n\t    Swig_mark_arg(i);\n\t    Swig_mark_arg(i + 1);\n\t    i++;\n\t  } else {\n\t    Swig_arg_error();\n\t  }\n\t} else if (strcmp(argv[i], \"-declaremodule\") == 0) {\n\t  declaremodule = true;\n\t  Swig_mark_arg(i);\n\t} else if (strcmp(argv[i], \"-noinit\") == 0) {\n\t  noinit = true;\n\t  Swig_mark_arg(i);\n\t}\n\telse if (strcmp(argv[i], \"-dynamic-load\") == 0) {\n\t  if (argv[i + 1]) {\n\t    Delete(load_libraries);\n\t    load_libraries = NewString(argv[i + 1]);\n\t    Swig_mark_arg(i++);\n\t    Swig_mark_arg(i);\n\t  } else {\n\t    Swig_arg_error();\n\t  }\n\t}\n      }\n    }\n\n    // If a prefix has been specified make sure it ends in a '_' (not actually used!)\n    if (prefix) {\n      const char *px = Char(prefix);\n      if (px[Len(prefix) - 1] != '_')\n\tPrintf(prefix, \"_\");\n    } else\n      prefix = NewString(\"swig_\");\n\n    // Add a symbol for this module\n\n    Preprocessor_define(\"SWIGMZSCHEME 1\", 0);\n\n    // Set name of typemaps\n\n    SWIG_typemap_lang(\"mzscheme\");\n\n    // Read in default typemaps */\n    SWIG_config_file(\"mzscheme.swg\");\n    allow_overloading();\n\n  }\n\n  /* ------------------------------------------------------------\n   * top()\n   * ------------------------------------------------------------ */\n\n  virtual int top(Node *n) {\n\n    /* Initialize all of the output files */\n    String *outfile = Getattr(n, \"outfile\");\n\n    f_begin = NewFile(outfile, \"w\", SWIG_output_files());\n    if (!f_begin) {\n      FileErrorDisplay(outfile);\n      SWIG_exit(EXIT_FAILURE);\n    }\n    f_runtime = NewString(\"\");\n    f_init = NewString(\"\");\n    f_header = NewString(\"\");\n    f_wrappers = NewString(\"\");\n\n    /* Register file targets with the SWIG file handler */\n    Swig_register_filebyname(\"header\", f_header);\n    Swig_register_filebyname(\"wrapper\", f_wrappers);\n    Swig_register_filebyname(\"begin\", f_begin);\n    Swig_register_filebyname(\"runtime\", f_runtime);\n\n    init_func_def = NewString(\"\");\n    Swig_register_filebyname(\"init\", init_func_def);\n\n    Swig_banner(f_begin);\n\n    Printf(f_runtime, \"\\n\");\n    Printf(f_runtime, \"#define SWIGMZSCHEME\\n\");\n    Printf(f_runtime, \"\\n\");\n\n    module = Getattr(n, \"name\");\n\n    Language::top(n);\n\n    SwigType_emit_type_table(f_runtime, f_wrappers);\n    if (!noinit) {\n      if (declaremodule) {\n\tPrintf(f_init, \"#define SWIG_MZSCHEME_CREATE_MENV(env) scheme_primitive_module(scheme_intern_symbol(\\\"%s\\\"), env)\\n\", module);\n      } else {\n\tPrintf(f_init, \"#define SWIG_MZSCHEME_CREATE_MENV(env) (env)\\n\");\n      }\n      Printf(f_init, \"%s\\n\", Char(init_func_def));\n      if (declaremodule) {\n\tPrintf(f_init, \"\\tscheme_finish_primitive_module(menv);\\n\");\n      }\n      Printf(f_init, \"\\treturn scheme_void;\\n}\\n\");\n      Printf(f_init, \"Scheme_Object *scheme_initialize(Scheme_Env *env) {\\n\");\n\n      if (load_libraries) {\n\tPrintf(f_init, \"mz_set_dlopen_libraries(\\\"%s\\\");\\n\", load_libraries);\n      }\n\n      Printf(f_init, \"\\treturn scheme_reload(env);\\n\");\n      Printf(f_init, \"}\\n\");\n\n      Printf(f_init, \"Scheme_Object *scheme_module_name(void) {\\n\");\n      if (declaremodule) {\n\tPrintf(f_init, \"   return scheme_intern_symbol((char*)\\\"%s\\\");\\n\", module);\n      } else {\n\tPrintf(f_init, \"   return scheme_make_symbol((char*)\\\"%s\\\");\\n\", module);\n      }\n      Printf(f_init, \"}\\n\");\n    }\n\n    /* Close all of the files */\n    Dump(f_runtime, f_begin);\n    Dump(f_header, f_begin);\n    Dump(f_wrappers, f_begin);\n    Wrapper_pretty_print(f_init, f_begin);\n    Delete(f_header);\n    Delete(f_wrappers);\n    Delete(f_init);\n    Delete(f_runtime);\n    Delete(f_begin);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * functionWrapper()\n   * Create a function declaration and register it with the interpreter.\n   * ------------------------------------------------------------ */\n\n  void throw_unhandled_mzscheme_type_error(SwigType *d) {\n    Swig_warning(WARN_TYPEMAP_UNDEF, input_file, line_number, \"Unable to handle type %s.\\n\", SwigType_str(d, 0));\n  }\n\n  /* Return true iff T is a pointer type */\n\n  int\n   is_a_pointer(SwigType *t) {\n    return SwigType_ispointer(SwigType_typedef_resolve_all(t));\n  }\n\n  virtual int functionWrapper(Node *n) {\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *d = Getattr(n, \"type\");\n    ParmList *l = Getattr(n, \"parms\");\n    Parm *p;\n\n    Wrapper *f = NewWrapper();\n    String *proc_name = NewString(\"\");\n    String *source = NewString(\"\");\n    String *target = NewString(\"\");\n    String *arg = NewString(\"\");\n    String *cleanup = NewString(\"\");\n    String *outarg = NewString(\"\");\n    String *build = NewString(\"\");\n    String *tm;\n    int i = 0;\n    int numargs;\n    int numreq;\n    String *overname = 0;\n\n    if (load_libraries) {\n      ParmList *parms = Getattr(n, \"parms\");\n      SwigType *type = Getattr(n, \"type\");\n      String *name = NewString(\"caller\");\n      Setattr(n, \"wrap:action\", Swig_cresult(type, Swig_cresult_name(), Swig_cfunction_call(name, parms)));\n    }\n\n    // Make a wrapper name for this\n    String *wname = Swig_name_wrapper(iname);\n    if (Getattr(n, \"sym:overloaded\")) {\n      overname = Getattr(n, \"sym:overname\");\n    } else {\n      if (!addSymbol(iname, n)) {\n        DelWrapper(f);\n\treturn SWIG_ERROR;\n      }\n    }\n    if (overname) {\n      Append(wname, overname);\n    }\n    Setattr(n, \"wrap:name\", wname);\n\n    // Build the name for Scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n\n    // writing the function wrapper function\n    Printv(f->def, \"static Scheme_Object *\", wname, \" (\", NIL);\n    Printv(f->def, \"int argc, Scheme_Object **argv\", NIL);\n    Printv(f->def, \")\\n{\", NIL);\n\n    /* Define the scheme name in C. This define is used by several\n       macros. */\n    Printv(f->def, \"#define FUNC_NAME \\\"\", proc_name, \"\\\"\", NIL);\n\n    // Emit all of the local variables for holding arguments.\n    emit_parameter_variables(l, f);\n\n    /* Attach the standard typemaps */\n    emit_attach_parmmaps(l, f);\n    Setattr(n, \"wrap:parms\", l);\n\n    numargs = emit_num_arguments(l);\n    numreq = emit_num_required(l);\n\n    /* Add the holder for the pointer to the function to be opened */\n    if (load_libraries) {\n      Wrapper_add_local(f, \"_function_loaded\", \"static int _function_loaded=(1==0)\");\n      Wrapper_add_local(f, \"_the_function\", \"static void *_the_function=NULL\");\n      {\n\tString *parms = ParmList_protostr(l);\n\tString *func = NewStringf(\"(*caller)(%s)\", parms);\n\tWrapper_add_local(f, \"caller\", SwigType_lstr(d, func));\t/*\"(*caller)()\")); */\n      }\n    }\n\n    // adds local variables\n    Wrapper_add_local(f, \"lenv\", \"int lenv = 1\");\n    Wrapper_add_local(f, \"values\", \"Scheme_Object *values[MAXVALUES]\");\n\n    if (load_libraries) {\n      Printf(f->code, \"if (!_function_loaded) { _the_function=mz_load_function(\\\"%s\\\");_function_loaded=(1==1); }\\n\", iname);\n      Printf(f->code, \"if (!_the_function) { scheme_signal_error(\\\"Cannot load C function '%s'\\\"); }\\n\", iname);\n      Printf(f->code, \"caller=_the_function;\\n\");\n    }\n\n    // Now write code to extract the parameters (this is super ugly)\n\n    for (i = 0, p = l; i < numargs; i++) {\n      /* Skip ignored arguments */\n\n      while (checkAttribute(p, \"tmap:in:numinputs\", \"0\")) {\n\tp = Getattr(p, \"tmap:in:next\");\n      }\n\n      SwigType *pt = Getattr(p, \"type\");\n      String *ln = Getattr(p, \"lname\");\n\n      // Produce names of source and target\n      Clear(source);\n      Clear(target);\n      Clear(arg);\n      Printf(source, \"argv[%d]\", i);\n      Printf(target, \"%s\", ln);\n      Printv(arg, Getattr(p, \"name\"), NIL);\n\n      if (i >= numreq) {\n\tPrintf(f->code, \"if (argc > %d) {\\n\", i);\n      }\n      // Handle parameter types.\n      if ((tm = Getattr(p, \"tmap:in\"))) {\n\tReplaceall(tm, \"$source\", source);\n\tReplaceall(tm, \"$target\", target);\n\tReplaceall(tm, \"$input\", source);\n\tSetattr(p, \"emit:input\", source);\n\tPrintv(f->code, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:in:next\");\n      } else {\n\t// no typemap found\n\t// check if typedef and resolve\n\tthrow_unhandled_mzscheme_type_error(pt);\n\tp = nextSibling(p);\n      }\n      if (i >= numreq) {\n\tPrintf(f->code, \"}\\n\");\n      }\n    }\n\n    /* Insert constraint checking code */\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:check\"))) {\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\n\tPrintv(f->code, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:check:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Pass output arguments back to the caller.\n\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:argout\"))) {\n\tReplaceall(tm, \"$source\", Getattr(p, \"emit:input\"));\t/* Deprecated */\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\t/* Deprecated */\n\tReplaceall(tm, \"$arg\", Getattr(p, \"emit:input\"));\n\tReplaceall(tm, \"$input\", Getattr(p, \"emit:input\"));\n\tPrintv(outarg, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:argout:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Free up any memory allocated for the arguments.\n\n    /* Insert cleanup code */\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:freearg\"))) {\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\n\tPrintv(cleanup, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:freearg:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Now write code to make the function call\n\n    String *actioncode = emit_action(n);\n\n    // Now have return value, figure out what to do with it.\n    if ((tm = Swig_typemap_lookup_out(\"out\", n, Swig_cresult_name(), f, actioncode))) {\n      Replaceall(tm, \"$source\", Swig_cresult_name());\n      Replaceall(tm, \"$target\", \"values[0]\");\n      Replaceall(tm, \"$result\", \"values[0]\");\n      if (GetFlag(n, \"feature:new\"))\n\tReplaceall(tm, \"$owner\", \"1\");\n      else\n\tReplaceall(tm, \"$owner\", \"0\");\n      Printv(f->code, tm, \"\\n\", NIL);\n    } else {\n      throw_unhandled_mzscheme_type_error(d);\n    }\n    emit_return_variable(n, d, f);\n\n    // Dump the argument output code\n    Printv(f->code, Char(outarg), NIL);\n\n    // Dump the argument cleanup code\n    Printv(f->code, Char(cleanup), NIL);\n\n    // Look for any remaining cleanup\n\n    if (GetFlag(n, \"feature:new\")) {\n      if ((tm = Swig_typemap_lookup(\"newfree\", n, Swig_cresult_name(), 0))) {\n\tReplaceall(tm, \"$source\", Swig_cresult_name());\n\tPrintv(f->code, tm, \"\\n\", NIL);\n      }\n    }\n    // Free any memory allocated by the function being wrapped..\n\n    if ((tm = Swig_typemap_lookup(\"ret\", n, Swig_cresult_name(), 0))) {\n      Replaceall(tm, \"$source\", Swig_cresult_name());\n      Printv(f->code, tm, \"\\n\", NIL);\n    }\n    // Wrap things up (in a manner of speaking)\n\n    Printv(f->code, tab4, \"return SWIG_MzScheme_PackageValues(lenv, values);\\n\", NIL);\n    Printf(f->code, \"#undef FUNC_NAME\\n\");\n    Printv(f->code, \"}\\n\", NIL);\n\n    /* Substitute the function name */\n    Replaceall(f->code, \"$symname\", iname);\n\n    Wrapper_print(f, f_wrappers);\n\n    if (!Getattr(n, \"sym:overloaded\")) {\n\n      // Now register the function\n      char temp[256];\n      sprintf(temp, \"%d\", numargs);\n      if (exporting_destructor) {\n\tPrintf(init_func_def, \"SWIG_TypeClientData(SWIGTYPE%s, (void *) %s);\\n\", swigtype_ptr, wname);\n      } else {\n\tPrintf(init_func_def, \"scheme_add_global(\\\"%s\\\", scheme_make_prim_w_arity(%s,\\\"%s\\\",%d,%d),menv);\\n\", proc_name, wname, proc_name, numreq, numargs);\n      }\n    } else {\n      if (!Getattr(n, \"sym:nextSibling\")) {\n\t/* Emit overloading dispatch function */\n\n\tint maxargs;\n\tString *dispatch = Swig_overload_dispatch(n, \"return %s(argc,argv);\", &maxargs);\n\n\t/* Generate a dispatch wrapper for all overloaded functions */\n\n\tWrapper *df = NewWrapper();\n\tString *dname = Swig_name_wrapper(iname);\n\n\tPrintv(df->def, \"static Scheme_Object *\\n\", dname, \"(int argc, Scheme_Object **argv) {\", NIL);\n\tPrintv(df->code, dispatch, \"\\n\", NIL);\n\tPrintf(df->code, \"scheme_signal_error(\\\"No matching function for overloaded '%s'\\\");\\n\", iname);\n\tPrintv(df->code, \"}\\n\", NIL);\n\tWrapper_print(df, f_wrappers);\n\tPrintf(init_func_def, \"scheme_add_global(\\\"%s\\\", scheme_make_prim_w_arity(%s,\\\"%s\\\",%d,%d),menv);\\n\", proc_name, dname, proc_name, 0, maxargs);\n\tDelWrapper(df);\n\tDelete(dispatch);\n\tDelete(dname);\n      }\n    }\n\n    Delete(proc_name);\n    Delete(source);\n    Delete(target);\n    Delete(arg);\n    Delete(outarg);\n    Delete(cleanup);\n    Delete(build);\n    DelWrapper(f);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * variableWrapper()\n   *\n   * Create a link to a C variable.\n   * This creates a single function _wrap_swig_var_varname().\n   * This function takes a single optional argument.   If supplied, it means\n   * we are setting this variable to some value.  If omitted, it means we are\n   * simply evaluating this variable.  Either way, we return the variables\n   * value.\n   * ------------------------------------------------------------ */\n\n  virtual int variableWrapper(Node *n) {\n\n    char *name = GetChar(n, \"name\");\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *t = Getattr(n, \"type\");\n\n    String *proc_name = NewString(\"\");\n    String *tm;\n    String *tm2 = NewString(\"\");\n    String *argnum = NewString(\"0\");\n    String *arg = NewString(\"argv[0]\");\n    Wrapper *f;\n\n    if (!addSymbol(iname, n))\n      return SWIG_ERROR;\n\n    f = NewWrapper();\n\n    // evaluation function names\n    String *var_name = Swig_name_wrapper(iname);\n\n    // Build the name for scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n    Setattr(n, \"wrap:name\", proc_name);\n\n    if ((SwigType_type(t) != T_USER) || (is_a_pointer(t))) {\n\n      Printf(f->def, \"static Scheme_Object *%s(int argc, Scheme_Object** argv) {\\n\", var_name);\n      Printv(f->def, \"#define FUNC_NAME \\\"\", proc_name, \"\\\"\", NIL);\n\n      Wrapper_add_local(f, \"swig_result\", \"Scheme_Object *swig_result\");\n\n      if (!GetFlag(n, \"feature:immutable\")) {\n\t/* Check for a setting of the variable value */\n\tPrintf(f->code, \"if (argc) {\\n\");\n\tif ((tm = Swig_typemap_lookup(\"varin\", n, name, 0))) {\n\t  Replaceall(tm, \"$source\", \"argv[0]\");\n\t  Replaceall(tm, \"$target\", name);\n\t  Replaceall(tm, \"$input\", \"argv[0]\");\n\t  /* Printv(f->code, tm, \"\\n\",NIL); */\n\t  emit_action_code(n, f->code, tm);\n\t} else {\n\t  throw_unhandled_mzscheme_type_error(t);\n\t}\n\tPrintf(f->code, \"}\\n\");\n      }\n      // Now return the value of the variable (regardless\n      // of evaluating or setting)\n\n      if ((tm = Swig_typemap_lookup(\"varout\", n, name, 0))) {\n\tReplaceall(tm, \"$source\", name);\n\tReplaceall(tm, \"$target\", \"swig_result\");\n\tReplaceall(tm, \"$result\", \"swig_result\");\n\t/* Printf (f->code, \"%s\\n\", tm); */\n\temit_action_code(n, f->code, tm);\n      } else {\n\tthrow_unhandled_mzscheme_type_error(t);\n      }\n      Printf(f->code, \"\\nreturn swig_result;\\n\");\n      Printf(f->code, \"#undef FUNC_NAME\\n\");\n      Printf(f->code, \"}\\n\");\n\n      Wrapper_print(f, f_wrappers);\n\n      // Now add symbol to the MzScheme interpreter\n\n      Printv(init_func_def,\n\t     \"scheme_add_global(\\\"\", proc_name, \"\\\", scheme_make_prim_w_arity(\", var_name, \", \\\"\", proc_name, \"\\\", \", \"0\", \", \", \"1\", \"), menv);\\n\", NIL);\n\n    } else {\n      Swig_warning(WARN_TYPEMAP_VAR_UNDEF, input_file, line_number, \"Unsupported variable type %s (ignored).\\n\", SwigType_str(t, 0));\n    }\n    Delete(var_name);\n    Delete(proc_name);\n    Delete(argnum);\n    Delete(arg);\n    Delete(tm2);\n    DelWrapper(f);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * constantWrapper()\n   * ------------------------------------------------------------ */\n\n  virtual int constantWrapper(Node *n) {\n    char *name = GetChar(n, \"name\");\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *type = Getattr(n, \"type\");\n    String *value = Getattr(n, \"value\");\n\n    String *var_name = NewString(\"\");\n    String *proc_name = NewString(\"\");\n    String *rvalue = NewString(\"\");\n    String *temp = NewString(\"\");\n    String *tm;\n\n    // Make a static variable;\n\n    Printf(var_name, \"_wrap_const_%s\", Swig_name_mangle(Getattr(n, \"sym:name\")));\n\n    // Build the name for scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n\n    if ((SwigType_type(type) == T_USER) && (!is_a_pointer(type))) {\n      Swig_warning(WARN_TYPEMAP_CONST_UNDEF, input_file, line_number, \"Unsupported constant value.\\n\");\n      return SWIG_NOWRAP;\n    }\n    // See if there's a typemap\n\n    Printv(rvalue, value, NIL);\n    if ((SwigType_type(type) == T_CHAR) && (is_a_pointer(type) == 1)) {\n      temp = Copy(rvalue);\n      Clear(rvalue);\n      Printv(rvalue, \"\\\"\", temp, \"\\\"\", NIL);\n    }\n    if ((SwigType_type(type) == T_CHAR) && (is_a_pointer(type) == 0)) {\n      Delete(temp);\n      temp = Copy(rvalue);\n      Clear(rvalue);\n      Printv(rvalue, \"'\", temp, \"'\", NIL);\n    }\n    if ((tm = Swig_typemap_lookup(\"constant\", n, name, 0))) {\n      Replaceall(tm, \"$source\", rvalue);\n      Replaceall(tm, \"$value\", rvalue);\n      Replaceall(tm, \"$target\", name);\n      Printf(f_init, \"%s\\n\", tm);\n    } else {\n      // Create variable and assign it a value\n\n      Printf(f_header, \"static %s = \", SwigType_lstr(type, var_name));\n      bool is_enum_item = (Cmp(nodeType(n), \"enumitem\") == 0);\n      if ((SwigType_type(type) == T_STRING)) {\n\tPrintf(f_header, \"\\\"%s\\\";\\n\", value);\n      } else if (SwigType_type(type) == T_CHAR && !is_enum_item) {\n\tPrintf(f_header, \"\\'%s\\';\\n\", value);\n      } else {\n\tPrintf(f_header, \"%s;\\n\", value);\n      }\n\n      // Now create a variable declaration\n\n      {\n\t/* Hack alert: will cleanup later -- Dave */\n\tNode *nn = NewHash();\n\tSetfile(nn, Getfile(n));\n\tSetline(nn, Getline(n));\n\tSetattr(nn, \"name\", var_name);\n\tSetattr(nn, \"sym:name\", iname);\n\tSetattr(nn, \"type\", type);\n\tSetFlag(nn, \"feature:immutable\");\n\tvariableWrapper(nn);\n\tDelete(nn);\n      }\n    }\n    Delete(proc_name);\n    Delete(rvalue);\n    Delete(temp);\n    return SWIG_OK;\n  }\n\n  virtual int destructorHandler(Node *n) {\n    exporting_destructor = true;\n    Language::destructorHandler(n);\n    exporting_destructor = false;\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * classHandler()\n   * ------------------------------------------------------------ */\n  virtual int classHandler(Node *n) {\n    String *mangled_classname = 0;\n    String *real_classname = 0;\n    String *scm_structname = NewString(\"\");\n    SwigType *ctype_ptr = NewStringf(\"p.%s\", getClassType());\n\n    SwigType *t = NewStringf(\"p.%s\", Getattr(n, \"name\"));\n    swigtype_ptr = SwigType_manglestr(t);\n    Delete(t);\n\n    cls_swigtype = SwigType_manglestr(Getattr(n, \"name\"));\n\n\n    fieldnames_tab = NewString(\"\");\n    convert_tab = NewString(\"\");\n    convert_proto_tab = NewString(\"\");\n\n    struct_name = Getattr(n, \"sym:name\");\n    mangled_struct_name = Swig_name_mangle(Getattr(n, \"sym:name\"));\n\n    Printv(scm_structname, struct_name, NIL);\n    Replaceall(scm_structname, \"_\", \"-\");\n\n    real_classname = Getattr(n, \"name\");\n    mangled_classname = Swig_name_mangle(real_classname);\n\n    Printv(fieldnames_tab, \"static const char *_swig_struct_\", cls_swigtype, \"_field_names[] = { \\n\", NIL);\n\n    Printv(convert_proto_tab, \"static Scheme_Object *_swig_convert_struct_\", cls_swigtype, \"(\", SwigType_str(ctype_ptr, \"ptr\"), \");\\n\", NIL);\n\n    Printv(convert_tab, \"static Scheme_Object *_swig_convert_struct_\", cls_swigtype, \"(\", SwigType_str(ctype_ptr, \"ptr\"), \")\\n {\\n\", NIL);\n\n    Printv(convert_tab,\n\t   tab4, \"Scheme_Object *obj;\\n\", tab4, \"Scheme_Object *fields[_swig_struct_\", cls_swigtype, \"_field_names_cnt];\\n\", tab4, \"int i = 0;\\n\\n\", NIL);\n\n    /* Generate normal wrappers */\n    Language::classHandler(n);\n\n    Printv(convert_tab, tab4, \"obj = scheme_make_struct_instance(\", \"_swig_struct_type_\", cls_swigtype, \", i, fields);\\n\", NIL);\n    Printv(convert_tab, tab4, \"return obj;\\n}\\n\\n\", NIL);\n\n    Printv(fieldnames_tab, \"};\\n\", NIL);\n\n    Printv(f_header, \"static Scheme_Object *_swig_struct_type_\", cls_swigtype, \";\\n\", NIL);\n\n    Printv(f_header, fieldnames_tab, NIL);\n    Printv(f_header, \"#define  _swig_struct_\", cls_swigtype, \"_field_names_cnt (sizeof(_swig_struct_\", cls_swigtype, \"_field_names)/sizeof(char*))\\n\", NIL);\n\n    Printv(f_header, convert_proto_tab, NIL);\n    Printv(f_wrappers, convert_tab, NIL);\n\n    Printv(init_func_def, \"_swig_struct_type_\", cls_swigtype,\n\t   \" = SWIG_MzScheme_new_scheme_struct(menv, \\\"\", scm_structname, \"\\\", \",\n\t   \"_swig_struct_\", cls_swigtype, \"_field_names_cnt,\", \"(char**) _swig_struct_\", cls_swigtype, \"_field_names);\\n\", NIL);\n\n    Delete(mangled_classname);\n    Delete(swigtype_ptr);\n    swigtype_ptr = 0;\n    Delete(fieldnames_tab);\n    Delete(convert_tab);\n    Delete(ctype_ptr);\n    Delete(convert_proto_tab);\n    struct_name = 0;\n    mangled_struct_name = 0;\n    Delete(cls_swigtype);\n    cls_swigtype = 0;\n\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * membervariableHandler()\n   * ------------------------------------------------------------ */\n\n  virtual int membervariableHandler(Node *n) {\n    Language::membervariableHandler(n);\n\n    if (!is_smart_pointer()) {\n      String *symname = Getattr(n, \"sym:name\");\n      String *name = Getattr(n, \"name\");\n      SwigType *type = Getattr(n, \"type\");\n      String *swigtype = SwigType_manglestr(Getattr(n, \"type\"));\n      String *tm = 0;\n      String *access_mem = NewString(\"\");\n      SwigType *ctype_ptr = NewStringf(\"p.%s\", Getattr(n, \"type\"));\n\n      Printv(fieldnames_tab, tab4, \"\\\"\", symname, \"\\\",\\n\", NIL);\n      Printv(access_mem, \"(ptr)->\", name, NIL);\n      if ((SwigType_type(type) == T_USER) && (!is_a_pointer(type))) {\n\tPrintv(convert_tab, tab4, \"fields[i++] = \", NIL);\n\tPrintv(convert_tab, \"_swig_convert_struct_\", swigtype, \"((\", SwigType_str(ctype_ptr, 0), \")&((ptr)->\", name, \"));\\n\", NIL);\n      } else if ((tm = Swig_typemap_lookup(\"varout\", n, access_mem, 0))) {\n\tReplaceall(tm, \"$result\", \"fields[i++]\");\n\tPrintv(convert_tab, tm, \"\\n\", NIL);\n      } else\n\tSwig_warning(WARN_TYPEMAP_VAR_UNDEF, input_file, line_number, \"Unsupported member variable type %s (ignored).\\n\", SwigType_str(type, 0));\n\n      Delete(access_mem);\n    }\n    return SWIG_OK;\n  }\n\n\n  /* ------------------------------------------------------------\n   * validIdentifer()\n   * ------------------------------------------------------------ */\n\n  virtual int validIdentifier(String *s) {\n    char *c = Char(s);\n    /* Check whether we have an R5RS identifier. */\n    /* <identifier> --> <initial> <subsequent>* | <peculiar identifier> */\n    /* <initial> --> <letter> | <special initial> */\n    if (!(isalpha(*c) || (*c == '!') || (*c == '$') || (*c == '%')\n\t  || (*c == '&') || (*c == '*') || (*c == '/') || (*c == ':')\n\t  || (*c == '<') || (*c == '=') || (*c == '>') || (*c == '?')\n\t  || (*c == '^') || (*c == '_') || (*c == '~'))) {\n      /* <peculiar identifier> --> + | - | ... */\n      if ((strcmp(c, \"+\") == 0)\n\t  || strcmp(c, \"-\") == 0 || strcmp(c, \"...\") == 0)\n\treturn 1;\n      else\n\treturn 0;\n    }\n    /* <subsequent> --> <initial> | <digit> | <special subsequent> */\n    while (*c) {\n      if (!(isalnum(*c) || (*c == '!') || (*c == '$') || (*c == '%')\n\t    || (*c == '&') || (*c == '*') || (*c == '/') || (*c == ':')\n\t    || (*c == '<') || (*c == '=') || (*c == '>') || (*c == '?')\n\t    || (*c == '^') || (*c == '_') || (*c == '~') || (*c == '+')\n\t    || (*c == '-') || (*c == '.') || (*c == '@')))\n\treturn 0;\n      c++;\n    }\n    return 1;\n  }\n\n  String *runtimeCode() {\n    String *s = Swig_include_sys(\"mzrun.swg\");\n    if (!s) {\n      Printf(stderr, \"*** Unable to open 'mzrun.swg'\\n\");\n      s = NewString(\"\");\n    }\n    return s;\n  }\n\n  String *defaultExternalRuntimeFilename() {\n    return NewString(\"swigmzrun.h\");\n  }\n};\n\n/* -----------------------------------------------------------------------------\n * swig_mzscheme()    - Instantiate module\n * ----------------------------------------------------------------------------- */\n\nstatic Language *new_swig_mzscheme() {\n  return new MZSCHEME();\n}\nextern \"C\" Language *swig_mzscheme(void) {\n  return new_swig_mzscheme();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Doc/Manual/swig16.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Doc/Manual/ch2.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Doc/Manual/SWIGDocumentation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Doc/Manual/android-simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Doc/Manual/android-class.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Examples/test-suite/char_constant.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.12-vl45t5bqblvk264l6r6fioac6i2kqh2t/spack-src/Examples/test-suite/ruby/char_constant_runme.rb"
    ],
    "total_files": 3828
}